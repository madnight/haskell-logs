00:00:18 <shanemikel> lol, at least the scheme interpreter I built in my SICP class resolved values by their given name
00:00:24 <dustmote> is https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/prof-heap.html still the accepted way of doing memory/heap profiling?
00:00:42 <dustmote> ie, to find the places to add strictness & plug leaks
00:01:07 <badmash> shanemikel: ok
00:01:12 <dustmote> followup: where the heck can one download hp2ps?
00:02:19 <badmash> shanemikel: just trying to understand what you said ... so in a compiled language, change not impacting the interface to the code ... what other effects could it have?
00:04:34 <shanemikel> you know what, now I'm starting to doubt what I've been saying
00:04:47 <badmash> shanemikel: i see
00:05:22 <shanemikel> I'd (and you'd) have to know how linking works to know if I'm making this up as I go
00:06:08 <badmash> shanemikel: does haskell require all source for dependencies for compilation?  because haskell once compiled doesn't keep type information at all.
00:07:33 <shanemikel> that's a good question, that's what C header files are for.. I can't say I know the answer to that
00:07:42 <badmash> shanemikel: one of the bewildering things i am having trouble understanding is, why does haskell pacakage management require such tight lower and upper bounds for all dependencies.  i don't see that (or haven't faced that in Java, for example)
00:08:45 <opqdonut> badmash: there's .hi "interface" files which kinda correspond to headers
00:08:53 <opqdonut> see e.g. https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/separate-compilation.html
00:09:16 <opqdonut> oh that's a pretty old version
00:09:18 <opqdonut> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html
00:09:36 <badmash> opqdonut: so does haskell require all source for dependencies for compilation?
00:09:44 <shanemikel> it's expensive (time-wise) to figure out the widest possible range of compatible versions of all deps for your package, so it's easier for developers to constrain more than to test compilation (and runtime testing especially) with every possible iteration of deps
00:09:51 <opqdonut> badmash: no, .hi and .o files are enough
00:09:53 <shanemikel> badmash: no, he's saying no
00:10:07 <badmash> i see
00:10:45 <badmash> opqdonut: how does it infer type information then? from .hi and .o files?
00:11:22 <opqdonut> badmash: .hi files are basically the types of all public functions
00:11:32 <opqdonut> badmash: and .o files are the compiled implementations
00:11:44 <badmash> i see
00:12:04 <badmash> opqdonut: thanks
00:13:00 <shanemikel> which makes it hard for consumers of their projects, but consider other ecosystems like javascript and java.. java on the one hand has a HUGE standard library, so you're not likely to require many dependencies from third parties in each application you build.. javascript (npm) on the other hand is much more widely used than haskell, yet dependency problems are significantly worse
00:14:18 <badmash> shanemikel: yes, i think you are right.  i think absence of a huge standrad library is what makes the problem so complex in haskell.
00:15:28 <shanemikel> If I've learned anything from javascript, it is to be patient and scrupulous about the libraries I depend on
00:15:47 <badmash> shanemikel: there is move towards nix-like package db in cabal, but i don't think it will fundamentally solve the problem.  you need a curated set of packages in hackage for any meaningful use of cabal.
00:16:22 <shanemikel> over time, you learn which ones are reliable.. it helps to look at github's contribution stats, and if you exclusively use stack you probably don't need to worry about it
00:19:29 <badmash`> opqdonut: when you do cabal install, cabal does download and build the source, but what does it in the package db?
00:20:38 <badmash`> i mean -- what does cabal put in the package db?  which somehow allows GHC to infer types etc from those packages
00:20:47 <shanemikel> nix wouldn't solve the problem at all... nix allows you to install multiple versions of applications, (which is really only required on unix because of how tightly applications rely on root directories for their runtime deps).. and it only guarantees that builds will be consistent across machines of the same arch, and that devs and packagers will not be fooled into forgetting to explicitely list deps because they are fooled by 
00:20:48 <shanemikel> the global nature of their dev boxes
00:22:17 <badmash`> shanemikel: yes, so i am wondering why cabal is moving towards a nix-like solution, when what we need fundamentally is a nice set of curated packages in hackage
00:23:00 <shanemikel> in fact, nix really just does the same thing we've been talking about: sandboxing.. it basically allows you to be confident that given the same source files (sandbox), you will still be able to build and run your program, so it's a nice target for deployment on multiple distros
00:23:49 <shanemikel> because that's what stackage is for, and cabal is a package manager, not an organization of packaging management
00:23:54 <badmash`> shanemikel: yes, and additionally, nix maintains a set of curated packages from which it installs etc
00:24:42 <shanemikel> the curating you speak of, requires a lot of manual work, and it's quite the same type of work that, for instance, a linux distribution does
00:24:49 <badmash`> shanemikel: yes, you are right, but i am wondering why not have what stackage does in hackage itself in the first place.
00:25:10 <badmash`> shanemikel: i see
00:25:21 <shanemikel> think of hackage like github, and stackage like debian
00:25:22 <ReinH> Why did we have horse drawn carriages first when clearly cars are superior?
00:25:23 <badmash`> shanemikel: i suppose it is very tedious
00:25:36 <ReinH> Like, why didn't they just start with cars instead of wasting our time?
00:25:36 <shanemikel> you can't remove hackage, or no work will ever get done
00:25:43 <badmash`> ReinH: :) that's a good point
00:26:26 <shanemikel> if you get rid of hackage, we'll all be stuck in a snapshot of the haskell universe, we'll have crossed the event horizon
00:26:41 <badmash`> shanemikel: :) 
00:27:07 <badmash`> i suppose i am goind ahead of myself :)
00:28:15 <badmash`> shanemikel: one question on the cabal thing -- cabal install downloads and builds the package source, but does it put in the package db?
00:28:43 <badmash`> i mean, what does cabal put in the package db?
00:30:05 <shanemikel> the package db (and there will be one for each sandbox as well as a global one) is basically a static mapping of absolute paths, to module names
00:30:22 <badmash`> shanemikel: i see
00:30:50 <shanemikel> and it's a huge pain in the arse, because it stupidly prevents you from moving sandboxes (like renaming your sandbox)
00:30:59 <shanemikel> that is, the directory
00:31:13 <badmash`> shanemikel: yes, i found that, too
00:31:45 <martinvlk> shanemikel: I believe work is being done to enable moving/renaming sandboxes
00:32:02 <badmash`> now, this absolute path is to the package binary, right?
00:32:22 <shanemikel> no, to the directories containing the source files
00:33:37 <shanemikel> and once you compile an application into an executable binary, it will be linked against the object files with absolute paths that closely resemble those in the package db
00:34:03 <shanemikel> also annoying.. but somebody on here mentioned that's due to the nature of LD on linux
00:35:33 <shanemikel> but you can get around that with static compilation, or using the traditional unix /lib directories to install your libraries (which nix would be good for, if you don't want to do that globally as root)
00:35:35 <badmash``> cabal does do a build on install, so i am wondering what it does with the build output
00:36:08 <shanemikel> if you're building an application, it'll put the executable in ~/.cabal/bin or ~/.cabal-sandbox/bin
00:36:11 <badmash``> shanemikel: yes, you mentioned the --static flag before
00:36:26 <shanemikel> it'll put the objects and header files in other ~/.cabal directories
00:36:33 <badmash``> shanemikel: i see, i forgot about that :)
00:36:34 <shanemikel> but the names are long scary hashes
00:36:50 <shanemikel> or.. long at least
00:38:19 <badmash``> shanemikel: the cabal business is at the moment quite fragile, i feel.  i hope things do improve in the future.  plus, the documentation is sparse, and doesn't go into details about practical issues enough.
00:40:10 <naudiz> glguy: nope, the guys on #hoskell-stack had no idea either
00:40:16 <shanemikel> it's not much different in languages like C, it seems every C project uses it's own unique combination of tooling and build system (scripts more than system).. I think cabal could have made linking cleaner if it used chroots and linked against canonical paths like /lib.. but i don't know what that would have done for portability
00:41:11 <badmash``> shanemikel: yes
00:41:42 <badmash``> shanemikel: ruby has nice things on this front
00:42:17 <badmash``> and java, as you mentioned, doesn't suffer too much because of its large library
00:43:17 <shanemikel> I think you'd find that tooling and build systems are pretty aweful in most languages... Java is another monster.. it's library dependency problems are reduced by the huge stdlib, but also, you have to consider the very nature of the language as a VM lang
00:43:39 <shanemikel> nothing runs on the hardware.. it's all on a higher layer
00:44:24 <narendraj9> So, most of the dependencies are in the virtual machine that it runs on?
00:44:26 <badmash``> shanemikel: yes, i agree, java is a bit of a monster.  i find haskell much more pleasant, despite the cabal issues
00:45:20 <narendraj9> But I have trying to get hakyll build on circleci properly, and I have been getting some error about hslua for weeks. 
00:45:25 <shanemikel> so, you've eliminated much of the pain of tooling and distribution right there (assuming you don't think depending on the jre is painful, and you don't feel the vm limits fundamental things like recursion)
00:45:28 <narendraj9> I am too lazy figure out what's wrong.
00:46:33 <badmash``> shanemikel: yes, i think that was the intent of java design, coming from facing all the issues in C++
00:48:53 <shanemikel> that's right
00:50:40 <FiredBall-0x71>  WELCOME TO ##ASTARA , HTTP://PEARLTREES.COM/PVPELITER OUR OFFICIAL WEBSITE ... . , THE MOST HIGH CHANNEL FOR HIS PRINCE AND SON ... .  HOW ARE YA ALL , I RELEASE ONE CLASSIFIED GAME FOR YOU ALL , HTTP://Us.runesofmagic.gameforge.com ... . , join ##Astara
00:52:21 <badmash> shanemikel: huge thanks for your time.  really appreciate your help
00:53:12 <shanemikel> badmash``: when you're comparing different ecosystems, you can't stop at apples vs apples, you gotta be willing to go apples v oranges.. if you try working with javascript and grunt (or even worse, Gulp) for a build system, and throw some transpiled languages into the mix, oh yeah and some html templating languages, and a minifier, something like browserify and source maps.. and you've entered a clusterf*** 100 times worse than 
00:53:14 <shanemikel> haskell dep management because all those things are, incidentally written in untyped javascript by developers with less discipline on average
00:54:02 <badmash> shanemikel: yes, i agree
00:54:11 <xd1le> shanemikel: that's why nix needs to infiltrate the js landscape, imo
00:54:36 <badmash> javascript world, i imagine, is a mess
00:55:00 <shanemikel> I think the majority of it could be solved with transpiled language parser/transpilers written in haskell and a haskell build system
00:55:13 <badmash> in fact, any untyped system, with a large code base is something quite fearful to deal with
00:55:14 <shanemikel> in fact, I intend to put some of that together one day
00:55:59 <badmash> shanemikel: i see, well, that will be good thing, indeed
00:56:10 <shanemikel> luckily, the elm and purescript transpilers are already haskell
00:57:08 <badmash> shanemikel: elm looks nice ... it started off from haskell
00:57:40 <FiredBall-0x71>  WELCOME TO ##ASTARA , HTTP://PEARLTREES.COM/PVPELITER OUR OFFICIAL WEBSITE ... . , THE MOST HIGH CHANNEL FOR HIS PRINCE AND SON ... .  HOW ARE YA ALL , I RELEASE ONE CLASSIFIED GAME FOR YOU ALL , HTTP://Us.runesofmagic.gameforge.com ... . , join ##Astara
00:57:45 <badmash> i think elm has a nice future ... javascript looks more like it will become the assembly langage of the web
00:57:53 <koz_> badmash: It basically already *is*.
00:59:48 <badmash> koz_: haven't they made changes etc?  i mean got away from laziness etc?
01:00:52 <koz_> badmash: I was referring to JS becoming the assembly language of the web.
01:01:32 <badmash> koz_: yeah ... javascript ... the only reason it is still there is because it is *fast*
01:01:52 <koz_> badmash: Given how much grinding at JIT compilation people had to do to get it there?
01:02:16 <shanemikel> yeah, I've been thinking about this a lot lately.. I don't think JS is a suitable low-level lang for anything.. so it's starting that way now, but eventually we need lamdascript browsers, or browsers that host a language that's suitable for implementing interpreters
01:02:37 <badmash> koz_: like they did for c compilers
01:02:59 <koz_> badmash: C is a lot easier to optimize. For one thing, it responds much better to AOT compilation, while JS ... doesn't.
01:03:21 <shanemikel> or maybe some evolution of linking itself
01:03:27 <koz_> shanemikel: It'd be nice if that ever happened, but I somehow don't see it happening.
01:05:12 <shanemikel> it will, because the language would also be suitable for implementing a JS interpreter
01:06:05 <shanemikel> the only major concern it brings up is related to open source
01:07:28 <badmash`> shanemikel:  huge thanks for your time.  really appreciate the help
01:08:14 <koz_> shanemikel: Well, I'll keep an eye out and see what happens.
01:08:27 <koz_> Thanks to ReinH, I now wanna write a BF interpreter in Haskell. :P
01:08:56 <koz_> Also, I am disappoint that this chan isn't called #skell.
01:09:39 <badmash`> thanks everyone
01:09:49 <badmash`> goodbye
01:10:35 <shanemikel> koz_: I think there are channel aliases.. so we could probably have that
01:10:52 <koz_> shanemikel: Well, I dunno if everyone else here thinks that pun worth making.
01:15:58 <shanemikel> http://sriku.org/blog/2014/07/17/two-trends-towards-partial-programming-language-freedom-everywhere/
01:18:35 <shanemikel> wow, I didn't know about NaCl and asm.js
01:19:07 <shanemikel> so maybe we're not so far off
01:49:48 * hackagebot EtaMOO 0.3.0.0 - A new implementation of the LambdaMOO server  https://hackage.haskell.org/package/EtaMOO-0.3.0.0 (RobLeslie)
01:59:53 <jle`> had to make an IORef containing IORefs today
01:59:58 <jle`> things are weird
02:31:28 <osa1> does anyone know why ghc-boot dependency of template-haskell is not shown here: http://hackage.haskell.org/package/template-haskell 
02:34:51 <WzC> hmm question: I want to iterate (with index) over a mutable bit vector, but I'm having trouble finding the correct combination of functions from the vector package to do that. 
02:35:41 <WzC> I'm currently using an Unboxed Mutable Bit vector, on which I wanted to use indexed (from Data.Vector.Generic), and then forM (from the same module)
02:36:07 <WzC> but now it is complaining that an Unboxed Mutable Bit vector is not an instance of Vector, and thus I cannot use indexed or forM
02:36:55 <WzC> which versions of indexed and forM should I be using ? (Or do I need to unsafeFreeze the mutable BV to pretend that I have an immutable one?
02:50:19 * hackagebot psqueues 0.2.2.0 - Pure priority search queues  https://hackage.haskell.org/package/psqueues-0.2.2.0 (JasperVanDerJeugt)
02:53:48 <JJJollyjim> Hey, why does the `fail' implementation for Either through an Exception rather than returning a Left?
02:54:59 <lyxia> JJJollyjim: What would fail "" :: Either Void () be equal to ?
02:55:44 <JJJollyjim> Wouldn't it be a type error?
02:56:10 <JJJollyjim> Oh I see
02:57:00 <JJJollyjim> You don't know when a function will fail, so you don't know whether the Left type is String or whatever it was defined as, right?
03:26:00 <John[Lisbeth]> (system ("echo ++ " " ++ (system ("echo" ++ " " ++ "hello world" ++ ";")) ++ ";"))
03:27:35 <John[Lisbeth]> The problem is that system from System.Process outputs the stdout of the process, but it also returns whether whether the process exited sucessfully or not
03:27:51 <John[Lisbeth]> I just want the strings that come before the exit status
03:32:07 <badmash> why does cabal/hacakage upper & lower bounds for package dependencies? instead, why can't a package be identfied with lower & upper bounds of GHC versions?
03:33:32 <badmash> appreciate any help
03:33:52 <lep_> > 512 .|. 133
03:33:54 <lambdabot>  645
03:38:23 <dramforever> badmash: 1. how do you expect it to work?
03:38:50 <badmash> dramforever: what do you mean?
03:39:04 <dramforever> What does identifying by GHC versions mean?
03:39:27 <dramforever> 2. What about users of compilers other than GHC?
03:39:55 <badmash> if i have a package A, i suppose i will specify that it is compatible with GHC versions 7.0 to 8.0
03:40:03 <koz_> 3. What has package versioning got to do with GHC versioning?
03:40:10 <badmash> so will all other packages
03:40:36 <koz_> A package can have a breaking API change without needing a newer GHC.
03:40:46 <dramforever> badmash: Yes you can do that indirectly, by putting a lower/upper bound on base
03:41:10 <badmash> koz_: so i am understanding your argument of package breaking API and GHC.  
03:41:35 <badmash> koz_: i am *not* understanding your argument
03:41:39 <dramforever> badmash: my package works with 7.10.3 doesn't mean it works with your program
03:41:45 <dramforever> *ghc 7.10.3
03:42:25 <badmash> dramforever: well, what will work with what other will be determined by a build & test cycle
03:43:04 <dramforever> badmash: you mean cabal should try all the combinations by *trying to build it*?
03:43:11 <koz_> badmash: A hilarious prospect when you have 10+ deps.
03:43:16 <koz_> Each with 10+ versions.
03:44:55 <dramforever> So, here: Do you want to 1. specify that your package only works with certain GHC versions, or 2. Tie package versions with GHC versions, or 3. both?
03:45:22 <badmash`> koz_: you see what i am saying ... i am just exploring ideas here
03:46:41 <badmash`> dramforever: i suppose, when i say a package is compatible with for  GHC versions 7.0 - 8.0, i am saying that all packages i use will also have the same version dendencies on GHC, and that my package
03:47:16 <dramforever> your message was cut off, leaving only "... and that my package"
03:48:09 <badmash`> dramforever:  i suppose, when i say a package is compatible with for  GHC versions 7.0 - 8.0, i am saying that all packages i use will also have the same version dendencies on GHC, and that my package will work with those packages that i use
03:48:44 <badmash`> dramforever: i retyped the message
03:49:19 <dramforever> The "my package will work" part is exactly the opposite of what the package versioning policy (a.k.a. PVP) is about
03:49:41 <badmash`> dramforever: ok, could you explain that?
03:49:55 <dramforever> If a package makes a non-backward-compatiable change, say, by removing a function
03:50:10 <badmash`> dramforever: so you are now enforcing an explicit declaration of all packages i use, instead/
03:50:18 <dramforever> It can just bump the major version number (the x in x.y.z)
03:50:37 <dramforever> In your system, it will have to wait for a newer GHC release
03:51:10 <badmash`> dramforever: i see
03:52:06 <badmash`> dramforever: so you need a more micro-level dependency declaration?
03:52:38 <dramforever> Just... How possibly can *my API*'s versions depend on GHC's?
03:53:24 <badmash`> dramforever: i see what you are saying.  i am just exploring things here
03:53:30 <koz_> dramforever: Not just yours - everyone else's whose code you happen to use as well.
03:53:41 <dramforever> badmash`: Well it might. It might use a new feature of a newer GHC. In that case, a bound on base should be enough
03:54:00 <dramforever> See the "base" row in https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/VersionHistory
03:54:04 <ReinH> Package versions generally have no relationship to GHC versions.
03:54:09 <badmash`> dramforever: yes
03:54:25 <ReinH> So it makes no sense to identify packages with GHC versions.
03:54:30 <badmash`> ReinH: yes, i noticed that
03:55:12 <badmash`> ReinH: but packages need to be compatible with at atleast some versions of GHC, right?
03:55:27 <badmash`> you can't have a package in vacuum
03:55:50 <ReinH> What does that mean?
03:56:06 <ReinH> They are compatible with versions of the base library that ships with GHC
03:56:13 <ReinH> but this is specified in the package's cabal file
03:56:19 <ReinH> and has nothing to do with the package version
03:56:22 <badmash`> ReinH: well, if a take a package right now from hackage, will it run with GHC version 1.0?
03:56:29 <ReinH> Maybe. Probably not.
03:56:45 <badmash`> well, then you have a dependency with GHC version
03:56:48 <ReinH> But again, that has nothing to do with the package's version.
03:57:02 <ReinH> I never said that packages don't have a relationship to GHC versions.
03:57:05 <badmash`> ok, may be i am missing something
03:57:11 <ReinH> I said that package versions don't have a relationship to GHC versions
03:57:53 <badmash`> so *what* in the package makes it clear that it will not run with GHC 1.0?
03:58:12 <ReinH> As I said, the bounds on the dependency on the base library in the cabal file.
03:58:22 <badmash`> ReinH: i see
03:58:48 <ReinH> base ships with GHC, and its versions are tied to GHC's versions.
03:58:59 <ReinH> Packages depend on base.
04:02:25 <badmash``> ReinH: so i suppose the current cabal/hackage dependency declaration is really needed to get things working, i suppose
04:04:40 <badmash``> ReinH: so i suppose the current system cabal/hackage use for dependencies is really needed to make things work, i suppose?
04:05:44 <lep_> $ mueval -l Import.hs -e '512 .|. 133'
04:05:44 <bergmark> we don't do it for fun... :-)
04:05:46 <lep_> http://sprunge.us/AKUY
04:05:56 <lep_> how does lambdabot manage to get default types
04:06:00 <lep_> > 512 .|. 133
04:06:02 <lambdabot>  645
04:06:27 <ReinH> default types?
04:06:41 <lep_> no error
04:07:37 <lep_> i just want to be able to use mueval without supplying type hints
04:07:37 <sbrg> :t 512 .|. 133
04:07:38 <lambdabot> (Num a, Bits a) => a
04:07:52 <badmash``> ReinH: so the current system we have in cabal/hackage for dependencies is really needed, i suppose?
04:07:59 <sbrg> lep_: what does it give you?
04:08:02 <sbrg> the error, that is.
04:08:05 <lep_> http://sprunge.us/AKUY
04:10:37 <koz_> Wtf is the .|. operator?
04:10:44 * koz_ reads that as 'middle finger'.
04:10:49 <lep_> :t (.|.)
04:10:50 <lambdabot> Bits a => a -> a -> a
04:11:02 <pavonia> Bitwise or
04:11:09 <geekosaur> I'd assume ExtendedDefaultRules
04:11:15 <ReinH> badmash``: only if you want dependencies.
04:11:44 <lep_> huh i tried that already
04:11:50 <lep_> but now it works of course
04:12:13 <koz_> pavonia: Yup, middle finger. :P
04:12:55 <geekosaur> koz_, https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/Data-Bits.html
04:13:16 <koz_> geekosaur: Nah, it's cool, I get how it works. I just find the spelling of that operator hilarious.
04:13:19 <lep_> or rather
04:13:33 <lep_> i enable ExtendedDefaultRules in the imported file
04:13:36 <lep_> but that does not work
04:13:48 <lep_> but if i supply it via -XExtendedDefaultRules
04:13:50 <lep_> it works
04:14:51 <geekosaur> I don't know enough about mueval to answer that, but it might well be that an expression on the command line is in a different environment than one in the import file; compare :set vs. :seti in ghci
04:25:22 * hackagebot rebase 0.3 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.3 (NikitaVolkov)
04:39:24 <John[Lisbeth]> how does zipWith (*) work in (zipWith (zipWith (*)) [[1]] [[3]])
04:40:20 <mniip> John[Lisbeth], well look
04:40:23 <mniip> :t (*)
04:40:25 <lambdabot> Num a => a -> a -> a
04:40:29 <mniip> :t zipWith (*)
04:40:31 <lambdabot> Num c => [c] -> [c] -> [c]
04:40:36 <mniip> :t zipWith (zipWith (*))
04:40:37 <lambdabot> Num c => [[c]] -> [[c]] -> [[c]]
04:41:30 <John[Lisbeth]> I can't fathom the maths behind that one
04:45:08 <ggole> Fire up ghci and try it with some inputs?
04:45:28 <John[Lisbeth]> doing so
04:47:14 <John[Lisbeth]> Ok I think I get it now
05:10:30 <ktonga> Hi. I need to use groupWith. is it ok to import functions from GHC.Exts?
05:13:01 <mauke> groupWith f xs = groupBy ((==) `on` f) (sortBy (comparing f) xs) ?
05:43:58 <ktonga> mauke: yes, I know how to implement it. Do you recommend reimplement it instead of importing it from Exts?
05:51:03 <rui1> "nixos-rebuild automatically fetches and uses the latest version of Nix"
05:51:59 <rui1> However, the channel https://nixos.org/channels/nixos-unstable has 1.8, while I need >=1.10 to run the nixpkgs
05:52:44 <rui1> Even if I install 1.11 manually, nixos-rebuild still uses the old one and fails to use my nixpkgs
05:53:12 <rui1> Anyone knows how to solve this?
05:54:30 <ktonga> mauke: I will implement my own. I need ** (a -> k) -> [a] -> Map k [a] ** anyway and I cant find an existing one
05:54:31 <wmealing> how can you tell if a function is infix by its type.. signature ?
05:56:00 <Gurkenglas_> You can't. You tell by its name. If it doesn't start with a letter or a number or a _, it's infix. (Also in the line of its definition where you write its type signature, it's in brackets.)
05:56:44 <wmealing> righto, i thought perhaps there was something missing
05:56:52 <wmealing> something i was missing
06:07:47 <nik> hi 
06:09:21 <nik> who use kali linux ,
06:15:25 * hackagebot fquery 0.2.2 - Installed package query tool for Gentoo Linux  https://hackage.haskell.org/package/fquery-0.2.2 (SergeiTrofimovich)
06:30:26 * hackagebot vector-binary-instances 0.2.1.1 - Instances of Data.Binary and Data.Serialize for vector  https://hackage.haskell.org/package/vector-binary-instances-0.2.1.1 (BenGamari)
06:35:00 <cads> hey this is neat
06:35:28 <cads> ryantrinkle's 'try-reflex' builds pretty fast
06:35:57 <cads> It must do some binary cache trick
06:38:11 <cads> It pastes together a nix-shell with ghcjs in about half an hour - booting ghcjs takes at least twice as long
06:40:26 * hackagebot Lazy-Pbkdf2 1.0.0 - Lazy PBKDF2 generator.  https://hackage.haskell.org/package/Lazy-Pbkdf2-1.0.0 (Ofenhed)
06:45:26 * hackagebot Lazy-Pbkdf2 1.0.1 - Lazy PBKDF2 generator.  https://hackage.haskell.org/package/Lazy-Pbkdf2-1.0.1 (Ofenhed)
06:47:49 <John[Lisbeth]> I don't understand what the second value in foldl and foldr do
06:48:51 <dramforever> > foldr undefined "Here we are" []
06:48:53 <lambdabot>  "Here we are"
06:50:17 <aweinstock> :t foldr undefined
06:50:18 <lambdabot> Foldable t => b -> t a -> b
06:50:50 <aweinstock> :t foldr
06:50:51 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:51:19 <aweinstock> foldr undefined == const ?
06:51:44 <dramforever> @free Foldable t => b -> t a -> b
06:51:44 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
06:51:49 <dramforever> @free b -> t a -> b
06:51:49 <lambdabot> Extra stuff at end of line
06:51:57 <dramforever> Arrgh whatever
06:52:09 <aweinstock> > foldr undefined 0 [1]
06:52:10 <ggole> aweinstock: nope, try with a non-empty list
06:52:11 <lambdabot>  *Exception: Prelude.undefined
06:52:14 <ggole> ^
06:52:16 <aweinstock> ah
06:53:10 <aweinstock> John[Lisbeth]: in (foldr f k zs), is "the second value" f or k?
06:53:32 <John[Lisbeth]> k
06:54:10 <aweinstock> it's the base value of the accumulator
06:54:28 <aweinstock> > (foldr (+) 0 [5,6])
06:54:29 <lambdabot>  11
06:54:35 <aweinstock> > foldr (+) 7 [5,6]
06:54:37 <lambdabot>  18
06:54:40 <John[Lisbeth]> I don't understand what that's for, and I seem to see fold functions that don't use the second argument
06:55:00 <aweinstock> :t fold
06:55:01 <lambdabot> (Foldable t, Monoid m) => t m -> m
06:55:08 <dramforever> > foldr (++) "haskell" (replicate 10 "ha")
06:55:10 <lambdabot>  "hahahahahahahahahahahaskell"
06:55:18 <aweinstock> fold == foldr mappend mempty
06:55:20 <ggole> Well, the second argument to foldr is essentially a replacement for the empty list
06:55:41 <ggole> So if you intend to work on infinite lists, it isn't important
06:56:12 <John[Lisbeth]> How does one logically determine what should go in as the second argument
06:56:27 <aweinstock> > foldr ((:) . (+10)) undefined [1..]
06:56:29 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
06:56:30 <dramforever> > foldr (++) (error "Not important") (repeat "ha") -- ggole you must mean this
06:56:31 <lambdabot>  "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahah...
06:57:12 <ggole> Pretty much.
06:57:44 <ggole> John[Lisbeth]: depends on what you are trying to do
06:57:46 <aweinstock> John[Lisbeth]: how would you determine the base case for a recursion, if you're operating over a list recursively?
06:58:09 <John[Lisbeth]> I don't know the concept of a base case
06:58:29 <ggole> Time to learn about that, then.
06:58:40 <John[Lisbeth]> I recognize why you put an empty list in cases
06:58:54 <John[Lisbeth]> But I don't see how the second argument of foldl maps to an empty list case
06:59:08 <aweinstock> @src foldl
06:59:08 <lambdabot> foldl f z []     = z
06:59:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:59:25 <anax> There are many catamorphism implementations (http://hayoo.fh-wedel.de/?query=cata). How do they differ from each other?
07:00:27 <John[Lisbeth]> Is there a way to tell foldl to make z the head of the list?
07:02:31 <John[Lisbeth]> It just doesn't make sense to me why fold is designed to take z, it seems like you should start on the head of the list instead
07:03:29 <ggole> I said foldr, not foldl: and it replaces the empty list like this:
07:03:31 <ggole> > foldr (:) ["!"] ["a","b","c"]
07:03:33 <lambdabot>  ["a","b","c","!"]
07:04:25 <ggole> Here each cons is replaced with (:) (eg, recreating another cons) and the empty list is replaced with a one-element list.
07:05:56 <aweinstock> John[Lisbeth]: if you don't have z, you can't handle empty lists
07:06:12 <John[Lisbeth]> why not. that's what I don't seem to be getting
07:06:17 <aweinstock> there's foldr1 and foldl1 that do that, and they fail on empty lists
07:06:27 <aweinstock> > foldr1 (+) [1,2,3]
07:06:29 <lambdabot>  6
07:06:34 <aweinstock> > foldr1 (+) []
07:06:36 <lambdabot>  *Exception: Prelude.foldr1: empty list
07:15:55 <codedmart> How do I deal with this error? https://gist.github.com/codedmart/cd4515c79835d1257297
07:22:45 <barrucadu> Show the code (preferably a minimal breaking example)
07:23:05 <codedmart> barrucadu Is that intended for me?
07:23:09 <barrucadu> Yes
07:25:33 * hackagebot hahp 0.1.0 - Analytic Hierarchy Process  https://hackage.haskell.org/package/hahp-0.1.0 (taeradan)
07:25:35 * hackagebot hahp 0.1.1 - Analytic Hierarchy Process  https://hackage.haskell.org/package/hahp-0.1.1 (taeradan)
07:29:14 <codedmart> barrucadu I will go a different way about it. In that way I have `StateT RoutingTable (ReaderT Socket App)` and App is `newtype App a = App {unapp :: ReaderT AppConfig (ExceptT ServantErr IO) a}`
07:35:34 * hackagebot hahp 0.1.2 - Analytic Hierarchy Process  https://hackage.haskell.org/package/hahp-0.1.2 (taeradan)
08:00:42 <codedmart> barrucadu I guess the general question is could I or would it even be ok to embed a reader in a reader/
08:02:08 <monochrom> you can
08:02:39 <codedmart> monochrom Then how does ask know what your are asking for?
08:02:57 <daakr> codedmart: it takes the outermost. yes, that is sub-ideal, and a limitation of monad stacks.
08:03:16 <monochrom> use "lift ask" for the inner
08:03:16 <John[Lisbeth]> @src foldl1
08:03:16 <lambdabot> foldl1 f (x:xs) = foldl f x xs
08:03:17 <lambdabot> foldl1 _ []     = undefined
08:05:32 <EvanR> you can also embed the next reader by combining the new context with the old in for example a tuple
08:05:57 <EvanR> asks fst, asks snd, or asks myFoo, asks myBar
08:08:38 <daakr> monochrom: actualyl, what guarantees that the lift refers to lifting past the reader monad, and not some other irrelevant one?
08:09:17 <daakr> e.g. if you have writer (reader (reader IO)), then a "lift ask" might still refer to the outermost reader
08:09:29 <snowowl> so much to my surprise, i found out that haskell has yesod
08:10:06 <snowowl> is it very usable compared with other web stacks in other languages/frameworks?
08:10:14 <lingxiao> hey anyone wnat to join me on #coq for a couple of questions?
08:10:19 <lingxiao> :)
08:10:21 <daakr> snowowl: it has advantages and disadvantages
08:10:42 <daakr> snowowl: if your question is "can you make a working website with this", the answer is definitely yes
08:11:27 <snowowl> daakr: ok, great
08:12:11 <snowowl> i'm really not a web programmer, but i need to make a site and i'm trying to give myself a good excuse to use haskell
08:12:20 <snowowl> does this fit that bill?
08:12:40 <Haskellmaybe> Haskell didn't really make much sense to me. In your opinions, why would someone want to use Haskell to build an interpreter, especially if they're an idiot like me?
08:12:53 <EvanR> not a web programmer, not a haskell programmer, using yesod for a website, good luck ;)
08:12:55 <daakr> snowowl: that depends completely on the project
08:13:06 <Haskellmaybe> Woops, forgot that haha
08:13:22 <snowowl> EvanR: you're my inspiration
08:13:50 <daakr> snowowl: if you just want to get your feet wet with websites and haskell, try hakyll
08:13:51 <snowowl> daakr: well, the application is very graph theory driven, so i really liked the idea of haskell for it
08:14:02 <EvanR> Haskellmaybe: haskell has nice parsing libs and the type system helps express your ideas of what an interpreter should be doing
08:14:29 <snowowl> hakyll: i'll take a look
08:14:34 <EvanR> there are many examples of such a thing floating around in the blogspace
08:14:56 <Haskellmaybe> So I've been working on an interpreter in node.JS just for fun, but lately a friend said that I'd find Haskell easier for my project. I looked at some Haskell code, but it didn't make much sense to me. Why would someone, especially an idiot like me, want to use Haskell to build an interpreter? Would it be more "fun"?
08:15:25 <snowowl> daakr: ahh, the site won't be static
08:15:35 <daakr> snowowl: in which sense will it not?
08:16:55 <daakr> Haskellmaybe: we can't promise "fun". but haskell, used right, can be very efficient for writing interpreters
08:17:23 <daakr> Haskellmaybe: for example, haskell is extremely good at parsing files (text and binary)
08:17:31 <snowowl> daakr: ok, the bulk of the site is essentially a calculation based on a given input that displays a result
08:17:31 <daakr> (if you use one of the *parsec libraries)
08:17:58 <snowowl> eventually, i'd want to tie it in with user credentials and a database
08:17:59 <codedmart> Alright guys I guess what I am trying to figure out is I am using this stack with my servant app: https://gist.github.com/codedmart/cd4515c79835d1257297#file-config-hs-L53-L55
08:18:30 <daakr> snowowl: well without the database you can potentially write haskell code, compile that to javascirpt, and compute everything client-side
08:18:41 <codedmart> I would like to be able to use `App` as my m here but still have access to the socket: https://gist.github.com/codedmart/cd4515c79835d1257297#file-socket-hs-L39-L51
08:18:53 <codedmart> Not sure if that is possible or where to go.
08:19:21 <snowowl> daakr: no way, i think that sounds like exactly what i'm looking for
08:19:47 <daakr> snowowl: ghcjs compiles haskell to javascript
08:20:33 <snowowl> great, i'll have to play with this
08:21:23 <dataguy> greetings, I'm trying to understand the following function definition: addThree = \x -> \y -> \z -> x + y + z but I'm a bit confused
08:21:36 <dataguy> how is currying working here?
08:22:18 <daakr> dataguy: first you feed it an x, then it outputs a new function. you feed it a y, it outputs a new function. you feed it a z, it outputs a number
08:22:31 <dataguy> \x has param x, and it generates a lambda y, which then generates a lambda z , is that it?
08:23:44 <dataguy> daakr: when I feed x to \x it outputs a lambda (y) ? is that correct?
08:23:50 <daakr> dataguy: so for example, addThree 6 = \y -> \z -> 6 + y + z
08:24:33 <dataguy> daakr: the confusing bit is \z having access to x and y :)
08:24:39 <dataguy> that kinda warps my brain
08:24:57 <daakr> dataguy: what do you mean by this?
08:25:04 <dataguy> by the time z is generated, x and y are constants, right?
08:25:11 <daakr> dataguy: it's sort of like the first input 6 is "remembered" until the y and z are also available
08:25:24 <daakr> dataguy: what do you mean by z being "generated"?
08:25:24 <benzrf> dataguy: think about it like
08:25:45 <benzrf> dataguy: when you apply "\x -> foo", what happens is that all the instances of 'x' in 'foo' are replaced with the value
08:25:47 <benzrf> so if i say
08:25:54 <benzrf> (\x -> \y -> \z -> x + y + z) 1
08:26:02 <benzrf> that becomes \y -> \z -> 1 + y + z
08:27:11 <dataguy> benzrf: yep, that's what I tried to say, but failed to do so :)
08:28:12 <geekosaur> I don't see what's confusing about it. inner scopes can see stuff in outer scopes, unless the inner scope shadows it
08:28:32 <geekosaur> same as any language with a sane notion of scope
08:28:45 <dataguy> daakr and benzrf thank you both
08:28:50 <benzrf> np
08:31:04 <glguy> @tell naudiz I did a fresh install of Gentoo on amd64 last night and stack worked, so you might have altered some other aspect of your gentoo installation
08:31:05 <lambdabot> Consider it noted.
08:33:36 <badmash> reading the haskell-mode documentation ... it talks about generating the hoogle database ... how can this be done?
09:04:07 <sbrg> badon: hoogle --help says "hoogle data" generates the database
09:14:02 <Big_G> What is the canonical way to test if two monadic values are the same? i.e. I get a value from an external service and want to make sure the inner value is "Test Val"
09:16:39 <monochrom> I don't think there is one.
09:17:04 <lambda-11235> > (return 9) >>= (return . (9 ==)) :: IO Bool
09:17:06 <lambdabot>  <IO Bool>
09:17:17 <lambda-11235> > (return 9) >>= (return . (9 ==)) :: Maybe Bool
09:17:18 <lambdabot>  Just True
09:17:25 <monochrom> unless you stop over-generalizing and start admitting, for example, "it is the Maybe monad", in which case we know how to do it.
09:23:10 <orion> What is levity?
09:23:40 <geekosaur> whether something is boxed or not
09:24:16 <orion> And why is levity and ($) causing quite a stir on the mailing list?
09:24:42 <EvanR> Big_G: you cant in general get the a from Monad m => m a to do any comparison
09:24:56 <geekosaur> someone typed ":t ($)" into ghci from ghc8 and got chicken guts
09:25:24 <Big_G> monochrom, It'd be the IO monad. 
09:26:06 <EvanR> IO being a good example of that
09:26:15 <dmj> chicken guts :(
09:26:22 <geekosaur> ($) :: forall (w :: GHC.Types.Levity) a (b :: TYPE w). (a -> b) -> a -> b
09:26:26 <mniip> geekosaur, I like the new type for ($) :(
09:26:36 <orion> geekosaur: Most professional Haskellers will never need to know about this, right?
09:26:49 * dmj clutches 7.10.3
09:27:07 <mniip> (\_ -> 1#) $ ()
09:27:09 <mniip> :c
09:27:11 <geekosaur> orion, I don't know. for *most* things it's probably not relevant?
09:27:35 <glguy> I don't think understanding what Levity is is going to be an issue for professional Haskell programmers
09:28:05 * geekosaur is actually a bit more annoyed that after all this it *still* doesn't describe ($) fully; you still can't express the runST hack
09:28:29 <mniip> you mean the type inference shortcut?
09:28:34 <Big_G> Is the new type for $ official or speculative?
09:28:50 <mniip> sure it is a hack but it doesn't not diverge from the type of $
09:35:45 <rod> z
09:38:01 <Joshtice_> hey
09:40:50 <EvanR> :k Levity
09:40:52 <lambdabot> Not in scope: type constructor or class ‘Levity’
09:40:58 <EvanR> :k TYPE
09:40:59 <lambdabot> Not in scope: type constructor or class ‘TYPE’
09:41:23 <monochrom> clearly, lambdabot does not use an unreleased version of ghc
09:41:41 <EvanR> @version
09:41:41 <lambdabot> lambdabot 5.0.3
09:41:41 <lambdabot> git clone https://github.com/lambdabot/lambdabot
09:42:54 <monochrom> in most cases, I agree that a typical Prelude thing bearing an advanced type is going to be an uphill battle for teachers and students.
09:43:04 <monochrom> but in the case of ($), good riddance.
09:43:33 <EvanR> what was wrong with it
09:43:36 <kadoban> The type of ($) is changing?
09:44:44 <EvanR> It's ok, haskell was getting too popular, traversable foldable and this will stave off adoption a little longer so more awesome features can be developed without breaking too many peoples code bases
09:44:47 <kevinkjt2000-tab> good riddance of ($)?  I'm curious to know what is changing too
09:45:36 <glguy> This is the thread on the subject https://mail.haskell.org/pipermail/ghc-devs/2016-February/011268.html
09:45:37 * hackagebot cabal-info 0.1.0.0 - Read information from cabal files  https://hackage.haskell.org/package/cabal-info-0.1.0.0 (barrucadu)
09:46:04 <glguy> It's unclear if the changed type will be visible by default
09:48:32 <kadoban> Well that looks terrible.
09:49:58 <kevinkjt2000-tab> It seems clear that the type change will be visible by default
09:50:21 <EvanR> reddit
09:50:51 <EvanR> well i feel better now that we have a levity-polymorphic version of stuff like error ...
09:51:01 <EvanR> screw simple types!
09:51:54 <kevinkjt2000-tab> I have never seen kind # mentioned until today, but I like the new type better if it help * vs #
09:52:42 <EvanR> Yeah, the kind of unboxed types
09:52:44 <kevinkjt2000-tab> after all, a huge goal in FP is to get the types correct at compile time
09:53:44 <monochrom> I am most happy that the new error has an implicit callstack parameter. this is the thing people have always wanted.
09:58:12 <kadoban> Sounds from later in the thread that the plan is to put it behind a flag to show that, so shouldn't be a problem. Unless I just didn't read enough of the thread.
09:58:39 <monochrom> it's a humongous thread. you cannot read enough of it :)
09:58:49 <geekosaur> that is a proposal/suggestion
09:59:15 <monochrom> (I just looked a a few messages and mark the whole thing read.)
09:59:45 <monochrom> (unless when edwardk speaks, then I read it)
09:59:56 <EvanR> call stack implicits
10:00:22 <EvanR> except you explicitly need to put it in every intervening function that leads to an error?
10:00:32 <monochrom> I don't know
10:00:34 <EvanR> (in the type sig)
10:00:51 <EvanR> if so that sounds like a ticking "just let the IDE do it" bomb
10:02:01 <kadoban> monochrom: Haha, yeah I read until I got bored, and at least nobody said "wow, hiding that behind a flag is a dumb idea", so I'm happy doing what I usually do, which is … hoping the GHC people do it Right (tm) and going about my day.
10:02:47 <geekosaur> iirc no, just in something that needs to use it (including that wants to have a call stack kept)
10:03:02 <geekosaur> intervening things find out about it because it's in the type
10:03:23 <EvanR> of the intervening things?
10:03:31 <geekosaur> so when you use error, type inference "fills in" the implicit callstack dependency
10:03:53 * geekosaur does not thinkt hat's the right word...
10:05:51 <EvanR> constraint synonym seems plausible
10:05:52 <EvanR> type AppendsCallStack = ?callStack :: CallStack
10:06:23 <bitonic> Is there a function that behaves like `mv` -- if source and targets are on the same filesystem, just rename the file, otherwise copy and delete original?
10:07:02 <geekosaur> there may be something in Distribution.Simple
10:07:13 <EvanR> renameFile :: FilePath -> FilePath -> IO ()
10:07:26 <geekosaur> read the details *carefully*, there's an evil gotcha in there that the maintainer has decided must not be fixed
10:08:23 <geekosaur> EvanR, that will (or at least is allowed to) fail across filesystems
10:09:03 <EvanR> rename :: FilePath -> FilePath -> IO () in the unix package hooks into the rename syscall
10:09:20 <geekosaur> yep. so you get cross-device link error if you rename across filesystems
10:09:21 <EvanR> geekosaur: yes, but sometimes that cant be atomic?
10:09:48 <EvanR> and im not too surprised by a system call IO action failing with EWHATEVER
10:10:10 <geekosaur> it's just not what was asked for
10:10:13 <Welkin> the first face I see when I enter is EvanR
10:10:18 <Welkin> how typical
10:10:28 <EvanR> heh... 
10:10:36 <EvanR> "source and target are on the same filesystem"
10:11:21 <Welkin> when is ghc 8 supposed to come out?
10:11:51 <geekosaur> current plan is middle of Feb
10:12:09 <geekosaur> there's another RC due "soon"
10:12:18 <zd234> if https://hackage.haskell.org/package/tables is deprecated, what do we use instead?
10:12:30 <geekosaur> (2nd RC was supposed to happen middle of Jan though, so I expect it'll slip)
10:13:02 <monochrom> it is also pretty likely there will be a 3rd RC
10:13:06 <Welkin> zd234: ask in #haskell-lens perhaps
10:13:14 <zd234> actually no
10:13:23 <zd234> it appears https://github.com/ekmett/tables/issues/15 has some unresonable issue
10:13:25 <zd234> Welkin: ^
10:16:41 <sfilipov> Hi everyone, I'm trying to create a tuple type from Template Haskell, but there is no tuple type constructor in TH
10:17:12 <sfilipov> I am trying to do something that looks like "data MyType = MyType (String, String)"
10:18:06 <monochrom> firstly you don't need (,) for this example, you should aim for "data MyType = MyConstructor String String" instead
10:18:09 <barryburd> Hasell beginner — I need a website with lots and lots of very simple Haskell exercises and their solutions. Any ideas?
10:21:02 <monochrom> secondly I think (,) is TupleT 2
10:22:10 <monochrom> and therefore (X,Y) is AppT (AppT (TupleT 2) put_X_here) put_Y_here
10:22:44 <sfilipov> monochrom: That last bit is great, thanks, I will give it a try, didn't think of combining with AppT
10:25:30 <jle`> zd234: it depends on your use case, but maybe vinyl?
10:25:48 <monochrom> heh
10:28:14 <monochrom> barryburd: https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems may help
10:28:41 <dreaswar_> why dosent this evaluate and print out a list in GHCI:     filter ( <1000 ) [ x^2 | x <- [1..]]
10:29:15 <geekosaur> because filter does not know that it can stop at a certain point
10:29:25 <geekosaur> you may want takeWhile instead
10:29:52 <dreaswar_> geeksaur, but filter (<1000) tells it to stop at 999 ? isnt it ? 
10:29:55 <geekosaur> no
10:30:11 <thimoteus> filter doesnt know that there arent any numbers < 1000 at, say, position 9999182
10:30:20 <geekosaur> it tells it to look for all elements that are < 1000. it does not tell it that [1..] is ALWAYS strictly ascending
10:30:23 <monochrom> replace "1" by "(1 :: Int)" to get it to stop
10:30:34 <geekosaur> it cannot know that so it keeps looking for the number < 1000 at the end of the list
10:30:38 <dreaswar_> oh..
10:31:00 <geekosaur> er, the possible number..
10:31:02 <Welkin> > filter (< 1000) [1..]
10:31:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:31:05 <dreaswar_> then takeWhile (<1000) would'nt know as well until that infinite list is built
10:31:19 <Hijiri> takeWhile stops when it finds something >= 1000
10:31:26 <geekosaur> no, because takeWhile stops as soon as the condition fails whereas filter will keep lookiung for things matching the condition
10:31:38 <thimoteus> < takeWhile (< 5) [1,2,3,4,5,6,7,6,5,4,3,2,1]
10:31:43 <thimoteus> whoops
10:31:46 <thimoteus> > takeWhile (< 5) [1,2,3,4,5,6,7,6,5,4,3,2,1]
10:31:47 <lambdabot>  [1,2,3,4]
10:31:52 <monochrom> takeWhile stops at the first violation. filter stops at the end of the list.
10:32:42 <monochrom> Haskell is a programming language, not a mathematician.
10:32:55 <dreaswar_> ah.. thanks geekosaur++, monochrom++
10:33:24 <monochrom> and Curry, a logician.
10:37:02 <barryburd> Are there any Haskell programmers out there who also know Android? (Strange question, I know, but worth a shot…)
10:40:02 <tero-> barryburd: \o (not very extensive Android knowledge though..)
10:41:21 <barryburd> tero- I have a GitHub site that supposedly contains definitions for doing Android in Frege (Haskell for the JVM) but I can’t make heads or tails out of it and the person who posted doesn’t respond. Looking for someone to help...
10:43:31 <tero-> barryburd: oh, I gave up with Haskell on Android after tinkering with ghc-android. I didn't know about Frege. It seems better if you want to do anything else but strictly SDL
10:44:07 <barryburd> tero- What does SDL stand for?
10:44:11 <EvanR> barryburd: have you tried the Frege channel
10:44:46 <tero-> barryburd: simple directmedia layer http://www.libsdl.org
10:44:58 <barryburd> tero- Fewer people on the Frege channel so no one knew anything about Android
10:45:31 <geekosaur> out of curiosity, what github repo are you looking at?
10:45:38 <EvanR> aiui frege is experimental, and haskell no android is experimental, so you are doing experimental^2
10:46:02 <barryburd> Yes - experimental^2
10:46:55 * geekosaur is looking at https://github.com/trilogysci/FregeAndroid, it's just Frege wrappers for native/"Java" Android classes
10:46:56 <barryburd> https://github.com/trilogysci/FregeAndroid
10:47:00 <tero-> barryburd: I'd go PureScript + phonegap or PureScript + react-native
10:47:15 <geekosaur> roughly the equivalent of FFI wrappers for C libraries in Haskell
10:47:50 <dreaswar_> why doent this evaluate and print out the list:   sum( [ x^2 | x <- [1..] , odd (x^2), (x^2) < 10000] ) while trying to return odd squares less than 10000 ?
10:48:33 <fizruk> dreamdust: you mean this doesn't stop, right?
10:48:37 <dreaswar_> yes
10:48:40 <geekosaur> there's presumably no documentation because you should be able to use the javadocs. (this may well be wishful thinking)
10:48:58 <geekosaur> dreaswar_, same reason, the condition is implemented using filter
10:49:15 <barryburd> Sorry — when you say “just Frege wrappers for native/“Java” Android classes”, I’m a bit lost. If I used this stuff for anything at all (even something very experimental) how would I use it?
10:49:21 <dreaswar_> oh, but where is filter there ? is it syntactic sugar ? 
10:49:41 <fizruk> dreaswar_: that's because (x^2) < 10000 does not really know that your values are ordered and you should break once that condition is wrong
10:49:45 <geekosaur> list comprehensions are syntactic sugar, yes
10:50:03 <geekosaur> barryburd, are you familiar with Android's Java API?
10:50:21 <barryburd> I am familiar with Android’s Java API. 
10:50:35 <dreaswar_> thanks geekosaur++, fizruk++
10:51:12 <geekosaur> so hat repo just makes those APIs directly available in Frege. you would also need to know about how Frege makes Java stuff accessible in general
10:51:45 <geekosaur> this repo does not help with anything else, e.g. going Frege -> JVM bytecode -> Dalvik bytecode
10:52:42 <barryburd> So if I understand correctly, if this repo did what it says it does, I could write some simple Android programs in Frege only (and have them turned into Java classes and thus Dalvik or Art code). Is that correct?
10:52:53 <geekosaur> yes
10:53:14 <geekosaur> it doesnt help you with the part in parentheses though, just makes the Java APIs visible in Frege
10:53:29 <barryburd> So the next question is, how do I write a Hello World app using the code in this repo? There’s a note in the repo about a yaml file to help, but the yaml file is missing
10:54:34 <geekosaur> hah
10:54:49 * geekosaur just lopoked at the commit. they forgot the file, just updated the readme >.>
10:55:06 <geekosaur> someone forgot a git add
10:56:07 <barryburd> Could I get this working without the yaml file or would that be a needle-in-a-haystack task because of the dependencies?
10:56:09 <geekosaur> in any case I can;t really help with that question. I have some limited familiarity with Android, but it's rather dated (Android 2.2 era)
10:56:20 <barryburd> Android 2.2 is okay
10:57:35 <geekosaur> I think you could work it out yourself; it sounds like you just need to compile things in dependency order, you could probably just try compiling the files and keep track of errors to figure out the dependencies yourself
10:57:47 <geekosaur> or read through the imports and figure out the order from that
10:58:07 <geekosaur> (from which I infer that frege lacks something equivalent to ghc --make)
10:58:29 <barryburd> OK. I’ll give it a try. Maybe this is O(experimental^3) instead of O(experimental^2) 
10:58:57 <geekosaur> likely it is...
10:59:47 <geekosaur> you might also file an issue on the github that they forgot to git add build.yaml-template in 64af4bc
11:00:24 <barryburd> I posted a comment and emailed the committer, but got no response.
11:00:34 <geekosaur> although... last update of that repo was last March so they may not care at this point
11:16:04 <dalastboss> im trying to load my stack project in ghci but i get the following error
11:16:21 <dalastboss> http://i.imgur.com/h4wMC9Q.png
11:16:28 <dalastboss> any idea how to troubleshoot this
11:17:29 <dirk103> heyo
11:17:42 <dirk103> atomic(const atomic&) = delete;
11:17:44 <dirk103> what is that called?
11:18:14 <dirk103> is that just to prevent people from using a class incorrectly?
11:18:54 <Industrial> Hi. Programming Node.js and React every day for work I find it hard to come up with a reason to start learning Haskell today, however I think it might be fun to have some haskell programs for my commandline. I know nothing of haskell (yet!) though I'm watching https://www.youtube.com/watch?v=E3QMHYTgJf0&list=PLwiOlW12BuPZUxA2gISnWV32mp26gNq56#t=0.265291 now.
11:19:19 <dirk103> opps wrong chat
11:19:35 <Industrial> Is there a Haskell to JavaScript thing? I'm using Babel.js but if I could write some of my modules in Haskell that would be awesome :-)
11:20:40 <geekosaur> ghcjs is recommended, because it's complete; there's also haste and fay, which are subsets of haskell that compile to javascript
11:21:20 <geekosaur> (ghcjs is still a bit of a bear to install though, I think --- no official release as yet?)
11:21:50 <megaTherion> dirk103: its deleting the copy constructor
11:22:00 <megaTherion> and it lookes like C++ not Haskell ^^
11:22:11 <geekosaur> but it seems to me like people who want to do haskell->js end up using ghcjs because haste and fay are too limited
11:33:36 <caconym> dalastboss: I'm not up on stack, but in cabal land that means you have tried to import from a package without listing it in your .cabal dependencies
11:44:22 <kadoban> It means the same thing in stack.
11:44:46 <kadoban> It looks like their executable section doesn't depend on the library or something at a guess.
11:45:57 <goog_> http://rosettacode.org/wiki/24_game/Solve#C Which part of this code changes the order of the numbers to get the solution?
11:49:09 <mniip> hmm I wonder
11:49:12 <mniip> @letlpaste 5306863046931513344
11:49:13 <lambdabot>  Defined.
11:49:21 <mniip> ooohh
11:51:16 <ralu> @goog_  n_cards?
11:51:17 <lambdabot> http://www.cookiesncards.com/
11:51:17 <lambdabot> Title: Cookies 'n' Cards - About Us
11:58:13 <johnw_> shanemikel: I personally wouldn't recommend it
12:06:07 <mniip> interesting
12:06:12 <mniip> :t undefined :: Setting p s t a b
12:06:13 <lambdabot> Setting p s t a b
12:06:18 <mniip> :t typeSeq (undefined :: Setting p s t a b)
12:06:20 <lambdabot> p a (Identity b) -> s -> Identity t
12:06:41 <EvanR> :t typeSeq
12:06:42 <lambdabot> a -> a
12:07:55 <mniip> compare
12:07:57 <mniip> :t id reads
12:07:59 <lambdabot> Read a => ReadS a
12:08:01 <mniip> :t typeSeq reads
12:08:02 <lambdabot> Read a => String -> [(a, String)]
12:08:15 <EvanR> wth is typeSeq
12:08:35 <mniip> evaluates the type to WHNF \o/
12:08:47 <EvanR> lol
12:09:48 <EvanR> with polykinds... might as well forget about value level and move on
12:10:02 <EvanR> the type system has a better type system than the value system
12:10:06 <mniip> I have one of higher kinds too
12:10:16 <mniip> :t proxySeq
12:10:17 <lambdabot> forall (k :: BOX) (a :: k). Proxy a -> Proxy a
12:12:59 <mniip> oh
12:13:03 <mniip> it doesn't work...
12:14:43 <mniip> hmm I wonder
12:15:56 <mniip> @let liftFun :: (forall a. a -> a) -> (b -> c) -> b -> c; liftFun id f = id . f . id
12:15:58 <lambdabot>  Defined.
12:16:04 <deni> when using persistent and get (or getJust) it seems I can't just pass an integer but a Key value. I don't see how to construct that though...I understand that insert returns exactly that, and in fact those are the only examples I could find...where they first use insert to get the id and then use that to pass to the get function
12:16:05 <mniip> :t liftFun typeSeq
12:16:07 <lambdabot> (b -> c) -> b -> c
12:16:19 <mniip> :t liftFun typeSeq $ runState
12:16:20 <lambdabot> State s a -> s -> (a, s)
12:16:24 <mniip> shame
12:18:03 <mniip> but oh wait
12:18:05 <mniip> :t runState . typeSeq
12:18:06 <lambdabot> StateT s Identity a -> s -> (a, s)
12:21:19 <mniip> :t shows
12:21:21 <lambdabot> Show a => a -> ShowS
12:21:25 <mniip> :t typeSeq shows
12:21:27 <lambdabot> Show a => a -> ShowS
12:21:35 <mniip> :t typeSeq . shows
12:21:36 <lambdabot> Show a => a -> ShowS
12:21:39 <mniip> but, wait for it
12:21:44 <mniip> :t \x -> typeSeq (shows x)
12:21:45 <lambdabot> Show a => a -> String -> String
12:22:26 <koz_> What would be the easiest way of filtering out every second element of a list?
12:25:14 <mniip> hmm
12:25:32 <EvanR> koz_: well you can do it by splitting into groups of 2, dropping, and reconcatting but
12:25:40 <mniip> :t (id :: (a -> b) -> (Seq a -> Seq b)) mapState
12:25:41 <lambdabot> ((a, s) -> (b, s)) -> State s a -> State s b
12:25:43 <EvanR> you can also just write a list function that does it pretty easily
12:25:56 <mniip> :(
12:26:00 <koz_> EvanR: I was asking in case there was an easy shorthand I wasn't aware of.
12:26:23 <EvanR> the shorthand is the first thing i said, compose like 2 functions which are the steps of the process
12:27:20 <EvanR> i mean 3
12:44:24 <barryburd> Having trouble with a very simple problem. Trying to work the first “challenge” at the Monad Challenges site..(http://mightybyte.github.io/monad-challenges/pages/ex1-1.html) I loaded my code (see http://burd.org/Set1.hs) into ghci. I got the error message “Not in scope: ‘putStrLn’”. What did I do wrong?
12:46:17 <geekosaur> looks like you;re not supposed to compile it, just load it in ghci and let it print results
12:46:37 <geekosaur> and MCPrelude just doesn't provide putStrLn
12:47:39 <geekosaur> yep, looks like MCPrelude doesn't provide any I/O facilities
12:47:46 <dxtr> Hi!
12:48:21 <barryburd> So, if I load the file into Prelude but I don’t include the main part, it doesn’t give me any errors. But then shouldn’t I be able to just type the word fiveRands on the next line in Prelude and have it spit out the value of fiveRands?
12:48:22 <deni> bah nevermind I should read the docs more carefully....there's the function toSqlKey
12:48:52 <geekosaur> (...I had heard of people doing that but I think this is the first time I;ve actually seen it...)
12:49:45 <geekosaur> barryburd, yes
12:49:51 <barryburd> Oops! Never mind. I’m rollin’ now.
12:50:59 <dxtr> Does it make sense, and is it possible, to make a type that basically says "This should be of type X or Y"?
12:51:20 <EvanR> @src Either
12:51:20 <mniip> dxtr, untagged union?
12:51:20 <lambdabot> Source not found. I feel much better now.
12:51:23 <geekosaur> in Haskell you can;t do that, unless you use something like Either
12:51:40 <geekosaur> > Right 5 :: Either String Int
12:51:42 <lambdabot>  Right 5
12:51:46 <mniip> you have Either for untagged union
12:51:48 <monochrom> there is no type-level "set union"
12:51:48 <mniip> er
12:51:50 <mniip> you have Either for tagged union
12:51:55 <geekosaur> there are also typeclasses, but those are open so someone might add a new type later
12:51:56 <dxtr> Right
12:52:27 <dxtr> I'm in the early stages of learning Haskell :p
12:52:42 <dxtr> I guess I still haven't gotten into the correct mindset yet
12:52:43 <geekosaur> there are closed type families also; but both typeclasses and type families are intermediate level
12:52:45 <monochrom> type class still does not give you all of "union" you expect.
12:53:01 <geekosaur> and yes, they do not behave like "unions"
12:53:46 <monochrom> to see this, there is no such thing as "a list in which different items have different types, but they are all the same type class"
12:53:51 <EvanR> untagged unions dont make sense for haskell because each distinct type is its own separate universe of values, values of a type will never be found in some other type, such as a union
12:54:26 <dxtr> So if I ask the same question but regarding function parameters?
12:54:34 <mniip> monochrom, is there not?
12:54:41 <monochrom> whereas set-theoretic union, or even untyped systems, allow such as list
12:55:21 <mniip> @let data Context c where Context :: c a => a -> Context c
12:55:21 <lambdabot>  Parse failed: Illegal class assertion
12:55:46 <EvanR> i thought you could use existentials to define such a "class constrained" list
12:56:42 <mniip> you totally can do that
12:56:44 <monochrom> the use of an existential type does not contradict my statement. in fact, it exemplifies my statement.
12:56:48 <mniip> [Context 1, Context "", Context ()] :: [Context Show]
12:56:50 <EvanR> dxtr: there is a lot to take in and it can be confusing. i realized this today when i found a slideshow on the mailing list attempting to explain it all at once ;)
12:57:31 <monochrom> read "different types" very carefully.
12:57:52 <monochrom> if all three items have type "Context Show" that they have the same type, not 3 different types.
12:58:10 <dxtr> EvanR: Although I have done some scheme and Erlang earlier
12:58:15 <EvanR> i was not thinking of [Context Show]
12:58:30 <mniip> data CtxList c where Nil :: CtxList c; Cons :: c a => a -> CtxList c -> CtxList c
12:58:34 <dxtr> So all of this isn't ENTIRELY strange
12:58:41 <samba1_> When I run stack exec my-projects-exec-name I get an error "Executable named my-projects-exec-name not found on path:"
12:58:43 <monochrom> every existential type you think of exemplifies my statement
12:58:53 <samba1_> How can I get it to run the current projects named executable
12:58:57 <samba1_> like with cabal run?
12:59:05 <monochrom> CtxList is not the [] list I am talking about
12:59:05 <EvanR> dxtr: which as i understand are dynamically typed, which is an entirely different animal
12:59:17 <dxtr> Yes they are
12:59:27 <monochrom> it also has different properties from [] lists.
12:59:41 <dxtr> In fact they don't like to talk about types at all :P
12:59:46 <mniip> ah well you want (True:():"hello":[])
12:59:49 <EvanR> good ;)
12:59:56 <mniip> aka [forall a. c a => a]
12:59:59 <EvanR> because they dont really have any
13:00:00 <mniip> that yes that you can't do
13:00:05 <dxtr> Exactly
13:00:34 <monochrom> for example [] is a Monad instance but CxtList is not
13:00:40 <Lara> Hi, I should ask about lambdabot in here right?  Seems there's no channel for it.
13:00:49 <EvanR> dxtr: another way to look at scheme and erlang is that all the values possible are in the same universe, but they can be distinguished in various ways at runtime thanks to extra invisible tag bits
13:01:04 <EvanR> but they cant be distinguished earlier
13:01:49 <EvanR> dxtr: the Either data type is an example of adding these tag bits for that purpose in haskell
13:02:21 <EvanR> but you *can* tell this is whats happening before runtime, thanks to the Either type constructor
13:02:29 <dxtr> EvanR: Yeah. I guess my moronic questions stem from the fact that I have played around with Erlang and Scheme too much for a while now :P
13:02:45 <geekosaur> if you are used to dynamic typing, static typing will look weird, yes
13:02:56 <geekosaur> and it will require you to think about data in new and unfamiliar ways
13:02:59 <dxtr> It doesn't look weird
13:03:15 <dxtr> Not at all
13:03:19 <Lara> I use usermode +g as a startup command, it's happened many times lately that someone uses @tell with me and lambdabot tries to PM me whatever they said as soon as I type in the channel... but I never receive it since I'm +g, and I don't know if there's a way to get that PM after I /accept lambdabot ... does anyone know?  I wish it would just show me that
13:03:20 <Lara> person's message in the channel, like jenni (another bot) does.
13:03:22 <samba1_> When I run stack exec my-projects-exec-name I get an error "Executable named my-projects-exec-name not found on path:"
13:03:25 <samba1_> How can I get it to run the current projects named executable
13:03:27 <samba1_> like with cabal run?
13:03:37 <saurabhnanda> I seem to be stuck with a similar problem as last week -- http://stackoverflow.com/questions/35246397/codifying-presence-absence-of-authentication-at-type-level -- any help?
13:03:47 <dxtr> geekosaur: I'm trying to figure out what makes sense and not :)
13:03:54 <dxtr> If that makes sense (harr harr)
13:04:21 <EvanR> and out of what makes sense, what you can express in haskell ;)
13:04:24 <monochrom> Lara: with +g, the irc server still sends you a brief notice. but ok, it doesn't let you retrieve the lost pm.
13:04:34 <dxtr> EvanR: Exactly!
13:04:38 <geekosaur> samba1_, if it's in the current directory, stack exec ./myproject or whatever
13:04:47 <EvanR> two big questions
13:05:03 <dxtr> I guess what I am actually doing is trying to get into the right mindset
13:05:05 <Lara> monochrom: I get the notification about the PM which is how I know there is one... but no way to get it afterwards it seems.
13:05:11 <geekosaur> hm, doesn't lbot just tell you that you have @messages?
13:05:35 <samba1_> geekosaur: "Did not find executable at specified path: ./my-projects-exec-name"
13:05:39 <Lara> geekosaur: When I've tested it in the past, pretty sure it PMs the actual message.
13:05:51 <itsu> Guys I have a question related to the notation of the bind operator with state monad without the do notation. It's a bit complicated to explain but it's simple with a piece of code http://pastebin.com/RLYmWj7C 
13:05:59 <samba1_> I think the problem is it at the end of stack build
13:06:01 * geekosaur wonders if that was something he added to his instance
13:06:04 <Lara> I don't want it as a PM anyway and just want to see it in the channel.
13:06:18 <samba1_> "Warning: the following files would be used as linker inputs, but linking is not being done:"
13:06:25 <samba1_> but I don't know why that is or what I can do about it
13:06:29 <geekosaur> some channels object to messages being delivered in-channel like that
13:06:32 <itsu> basically if I have a function: foo :: Int -> Int -> State Int Int
13:06:37 <monochrom> I don't want to read pastebin.com. double spacing and redacting your code.
13:06:41 <Lara> If it's too private to say in the channel someone could also use MemoServ with me if I'm gone.
13:07:04 <itsu> monochrom: so what should i use ?
13:07:23 <monochrom> lpaste.net is best. but everything is better than pastebin.com.
13:07:31 <Lara> geekosaur: Is lambdabot your bot?
13:07:37 <geekosaur> no
13:07:37 <monochrom> only a screenshot is worse than pastebin.com
13:07:52 <Gurkenglas_> What do you mean, redacting? Maybe someone should make a script that transforms pastebin links posted here to lpaste links
13:07:55 <geekosaur> I used to run a modified version in a non-Haskell channel
13:08:14 <EvanR> dxtr: an idiomatic strategy for having a function that can take one kind of argument or another... is to make two functions, one for each. (and internally they can reuse a portion of the implementation after doing whatever the different is with the two different args) if that makes sense.
13:08:24 <EvanR> dxtr: instead of taking an Either argument
13:08:30 <monochrom> redacting means putting dark green ink over dark black code
13:08:45 <geekosaur> (lambdabot source code is open)
13:08:48 <monochrom> the same thing governments do before releasing documents
13:08:56 <Gurkenglas_> itsu, why don't you think it should work?
13:08:56 <Lara> geekosaur: I see, well this version is running in #macosx .  Is the person the bot belongs to here so I can tell them about this problem?
13:08:58 <EvanR> dxtr: if instead you want to accept anything that satisfies some interface, then you can use a record of functions, or typeclasses
13:09:59 <geekosaur> looks like it's this instance that's in there. you could PM int-e
13:10:01 <monochrom> and people miss my point and say "yeah it doesn't know that ' in haskell does not always mean char/string literals"
13:10:15 <Gurkenglas_> Oh, I see. >>= associates to the left, but \ overrides that, associating to the right.
13:10:30 <monochrom> suppose I really have a bunch of char literals. do you really think it is right to redact them?
13:10:39 <Lara> Yes it's the same lambdabot that's in here.
13:11:13 <Lara> I PMd int-e to lambdabot and nothing happened...
13:11:41 <Lara> Oh maybe you mean that's the person's nick. :P
13:11:58 <Gurkenglas_> itsu, "x >>= f >>= g" is "(x >>= f) >>= g", but "x >>= \y -> f y >>= \z -> g z" is "x >>= (\y -> f y >>= (\z -> g z))", so it happens to work out the same way.
13:12:06 <dxtr> EvanR: Yeah, when I'm thinking about it my strategy here doesn't make sense
13:12:44 <dxtr> Because they are two distinct types (Although they share some fields)
13:13:15 <itsu`> Gurkenglas_: Sorry, my connection dropped... :-(
13:13:29 <dxtr> So if function X takes "Type A OR Type B" it'd be a lot of acrobatics because if type A and type B had the same fields it wouln't make a whole lot of sense to have two types
13:13:31 <Lara> If it's their bot, I PMd them, thanks.
13:13:33 <Gurkenglas_> itsu`, "x >>= f >>= g" is "(x >>= f) >>= g", but "x >>= \y -> f y >>= \z -> g z" is "x >>= (\y -> f y >>= (\z -> g z))", so it happens to work out the same way.
13:13:35 <geekosaur> Lara, yes, int-e currently runs this lambdabot
13:13:38 <Lara> Ok
13:14:14 <glguy> Lara: You can pre /accept lambdabot on connect
13:14:30 <dxtr> I don't know if that was very clear, though :P
13:15:09 <monochrom> dxtr: it is possible and recommended to create your own "data Mine = Case1 Int Bool | Case2 Int Char" so that you can have common fields and uncommon fields
13:15:42 <Lara> glguy: I know but haven't done that yet because I didn't think people would suddenly start using it all the time with me (now that they know @tell exists) and I don't really want PMs anyway... I might get jenni in the channel and tell them to use that instead, since it shows the message in the channel, but thanks.
13:15:52 <monochrom> Haskell makes it syntactically cheap to create your own algebraic types and encourages you to exploit it.
13:16:30 <itsu`> Gurkenglas: well yeah I understand that but in the case of the state Monad, >>= :: State s a -> (a -> State s b) -> State s b   which means that f >>= g is similar to f >>= \x -> g x where x is the second parameter of State right ?
13:16:30 <monochrom> unlike Java/Javascript which force you to create full-fledged classes or prototypes
13:16:39 <starc> sysinfo
13:16:50 <starc> 12Drives:    12HDD Total Size: 1000.2GB (48.2% used) 121: 12id: /dev/sda 12model: WDC_WD10EZRX 12size: 1000.2GB 
13:16:51 <starc> 12           12Optical: /dev/sr0 12model: N/A 12dev-links: cdrom,cdrw,dvd,dvdrw
13:16:51 <starc> 12           12Features: speed: 48x 12multisession: yes 12audio: yes 12dvd: yes 12rw: cd-r,cd-rw,dvd-r,dvd-ram
13:16:54 <monochrom> unlike Scheme which pushes you towards simulation by cons cells
13:17:00 <geekosaur> starc... channel?
13:17:01 <glguy> starc: Please don't do that
13:17:45 <itsu`> Gurkenglas: ok nevermind, I think I just understood my mistake...
13:17:53 <monochrom> starc: you're basically destroying your own privacy and exposing more attack vectors for bad people to exploit your computer.
13:19:04 <itsu`> Gurkenglas: Thank you for your help ;-)
13:19:35 <dxtr> monochrom: I basically want to do something like http://lpaste.net/6368445625243009024
13:20:01 <geekosaur> dxtr, that's almost right
13:20:18 <geekosaur> data User = Derived DerivedUser | Stored StoredUser
13:20:38 <geekosaur> and now you can distinguish based on the constructor which you got
13:20:45 <dxtr> Oh, neat
13:20:55 <geekosaur> well, except that it'll blow up on usage
13:21:10 <dxtr> :(
13:21:15 <geekosaur> because Haskell defines a function usage :: DerivedUser -> DerivedUsage for the first one
13:21:20 <geekosaur> and then can't make it for the second
13:21:28 <geekosaur> so you'll have to name it differently in each one
13:21:51 <dxtr> Right
13:21:53 <geekosaur> (Haskell doesn't use record.field syntax, instead the field selector is a function)
13:22:05 <dxtr> Oh that's right
13:23:04 <geekosaur> (this is planned to change btw. the upcoming ghc8 has some of the changes needed but not all)
13:23:20 <EvanR> dxtr: yes two records which share some fields is a common thing people want to do, but haskell doesnt have direct support for that
13:23:43 <EvanR> like, record subtyping, no
13:23:54 <dxtr> EvanR: Oh
13:24:35 <EvanR> a simple way to get around it is to convert one to the other with some boilerplate, though that could get hairy if you have a lot of different record types
13:24:58 <dxtr> Right
13:25:12 <EvanR> with some advance type system hackery though you can pull off something "interesting" (see https://hackage.haskell.org/package/vinyl)
13:25:35 <EvanR> this puts the fields in the type basically
13:26:20 <EvanR> but also you might be able to rethink your problem to not need to do any of this
13:31:19 <dxtr> Yeah
13:39:51 <ddssx> the funny nigger keeps talking can someone shut them up? pall wall? help!
13:43:55 --- mode: ChanServ set +o byorgey
13:44:01 --- mode: byorgey set +b *!*ddssx@2600:1003:b00f:6e85:9090:92b3:bcb9:*
13:44:01 --- kick: ddssx was kicked by byorgey (ddssx)
13:44:15 <Guest9222> thanks byorgey 
13:44:16 <Guest9222> freenode issues
13:44:16 --- mode: ChanServ set -o byorgey
13:44:21 * geekosaur was typing in wrong window...
13:45:27 --- mode: ChanServ set +o johnw
13:45:34 --- mode: johnw set -o johnw
14:01:02 <hodapp> huh, that was some pretty uncreative trolling.
14:01:38 <EvanR> it goes without saying!
14:24:44 --- mode: ChanServ set +o glguy
14:24:45 --- mode: glguy set +b-bo *!*@2600:1003:b00f:6e85:* *!*ddssx@2600:1003:b00f:6e85:9090:92b3:bcb9:* glguy
14:24:47 <isd> Is there haddock documentation for happstack up on the web somewhere? The module names on the hackage page aren't actually links, and I've found a few dead links elsewhere, but haven't actually found any built docs.
14:25:49 <isd> (happstack-server specifically)
14:30:44 * hackagebot hackport 0.4.7 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.4.7 (SergeiTrofimovich)
14:30:46 * hackagebot AbortT-transformers 1.0.1.2 - A monad and monadic transformer providing "abort" functionality  https://hackage.haskell.org/package/AbortT-transformers-1.0.1.2 (GregoryCrosswhite)
14:40:45 * hackagebot AbortT-mtl 1.0.0.1 - mtl instances for the AbortT monad transformer  https://hackage.haskell.org/package/AbortT-mtl-1.0.0.1 (GregoryCrosswhite)
14:45:42 <average> is there some place somewhere that talks about the atomicity of msgsnd and msgget ?
14:48:22 --- mode: ChanServ set -o quicksilver
14:50:49 <__fnord> hi, is there a convenient way to let a hint interpreter have the same modules in scope as a ghci started via stack?
14:51:19 <__fnord> I want for example use hint to interpret code using the lens library.
14:51:45 <__fnord> interpret code which uses the lens library, to clarify
14:52:51 <arw> average: SysV IPC or something else?
14:53:16 <__fnord> Hint seems to have a search path option, but I'm not sure how to get the searchpath for an external library like lens.
14:53:20 <arw> average: if its unix IPC, somewhere in POSIX
14:53:58 <average> arw: yes, SysV IPC
14:54:56 <arw> average: there won't be broken messages if you send simultaneously, if thats what you mean. 
14:55:05 <samba1_> how do I get stack to recompile my executable?
14:55:10 <samba1_> I've tried stack build
14:55:18 <samba1_> but then when I do stack exec my-proj-exe
14:55:25 <samba1_> I still see the same thing as before
14:55:42 <samba1_> I tried changing the name of the executable, and then I get an error
14:56:21 <samba1_> about the executable not existing
14:56:30 <samba1_> which is true, it doesn't exist, I'm trying to build it now
14:57:07 <augur> how can i get parsec to not treat ` as a special symbol with special parsing rules?
14:59:04 <glguy> Remove the code you wrote to treat ` as a special symbol with special rules?
14:59:30 <samba1_> stack is so hard...
14:59:32 <average> arw: my situation is one with one producer & multiple consumers
15:00:13 <arw> average: and you are worrying that only exactly one consumer should get a message?
15:00:26 <nikola> Hello, how can I parse json containing the following key and value: "textRU": "\u0422\u0440\u0438\u043c\u0430\u0440\u0430\u043d" . eitherDecode just gives Left "Failed reading: satisfy".
15:00:30 <average> yes
15:00:49 <average> in addition, I'd like to know if msgget/msgsnd are atomic
15:01:14 <augur> glguy: i didnt write such code tho!
15:01:20 <average> by that I mean that a message will only be read in full or won't be read at all
15:01:26 <average> IOW no partial reads
15:01:30 <augur> glguy: i think parsec has default options to treat ` as part of parsing infix names :(
15:02:54 <samba1_> how do I get stack to recompile my executable?
15:02:58 <samba1_> I've tried stack build
15:03:11 <samba1_> but then when I do stack exec my-proj-exe, I still see the same thing as before
15:05:15 <nikola> samba1_: try stack build --force-dirty
15:06:09 <samba1_> nikola: no change
15:06:13 <tommd> :q
15:06:24 <samba1_> I even deleted the binary fromm the stack-work directory
15:06:30 <samba1_> and it rebuilt _the same one_
15:06:33 <samba1_> the old one
15:06:41 <samba1_> from code that doesn't even exist anymore
15:06:45 <samba1_> how is this possible?
15:07:02 <glguy> augur: Parsec doesn't obviously have such a case
15:07:20 <glguy> Something else might be going on, maybe create a small example case on lpaste?
15:09:02 <augur> glguy: nevermind, im just going to change the syntax im using :p
15:09:26 <arw> average: if the syscall returns with data (i.e. no error), the message is complete and removed from the queue. 
15:10:05 <arw> average: but from reading the code, at least for linux, i'm not quite sure if the message will be requeued if an error occurs during the syscall
15:11:19 <average> arw: hm, interesting
15:11:30 <cj_howe> hi
15:12:02 <cj_howe> anyone used haskell for production backend code?
15:12:03 <arw> average: and you can instruct it to explicitly truncate with MSG_NOERROR
15:12:55 <augur> glguy: oh! you know what, it works fine, if i just remember to include the parser that uses ` in the relevant larger parse :)
15:12:55 <augur> x3
15:13:09 <glguy> yay :)
15:13:34 <nicoekkart> I'm doing the cis 194 course, but whenever I try registering, I get a heroku error: http://cis194.herokuapp.com/register/  Am I doing something wrong or is there an alternative way to submit the exercises
15:13:47 <arw> average: https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/ipc/msg.c#n825
15:14:14 <cj_howe> looking at maybe writing some distributed apache kafka stuff with haskell, but i am really leaning towards erlang now, so if anyone has been doing anything distributed with haskell, i'd really like to know how it's been working for them
15:14:34 <arw> average: line 889ff removes the message from the queue, but there are possible error conditions later on.
15:16:13 <kadoban> nicoekkart: You can't submit the exercises unless you're a student of the university. You're just meant to do them and learn from them.
15:19:06 <arw> average: hm, the only critical thing seems to be line 1003 which checks 'if (IS_ERR(msg)) {'
15:19:26 <arw> average: it would depend on the possible errors there if that would be a problem.
15:30:40 <arw> average: hm. from reading the possible errors, there is nothing that would happen after a dequeue. so as far as I read the code, your atomicity guarantee should be kept in linux, short of hardware defects or a kernel panic
15:33:51 <average> arw: that's very good news, thank you !
15:35:13 <arw> average: but read the manpage, and check for errors. some flags such as MSG_COPY will duplicate messages
15:36:02 <jle`> haskell is pretty neat, i like it
15:36:35 <hodapp> That's a good thing... IRC channels for languages that aren't neat and that no one likes tend to be pretty nasty.
16:01:23 <jdavis> I just install haskell-platform on ubuntu 14.04. I tried doing "cabal install pandoc" and it says it will break a couple regex packages. Suggestions? (newbie here)
16:02:28 <boj> jdavis: if you don't mind avoiding your package manager, the community seems to be moving towards https://www.stackage.org/
16:02:58 <jdavis> Never heard of it. Is it a replacement for cabal, or haskell-platform?
16:03:10 <boj> both in a way
16:03:53 <fr3tz0r> hi
16:04:01 <glguy> jdavis: You can install pandoc directly from your package manager, too. That'd be the easiest way forward
16:05:01 <jdavis> Hmm. OK. I guess I'll try the debian route, but I'm a little worried about having a mix of haskell packages.
16:06:17 <glguy> jdavis: Looking at http://packages.ubuntu.com/trusty/pandoc it doesn't look like installing pandoc with your package manager is actually going to install any haskell deps
16:06:29 <glguy> Just the executable, so there probably isn't a conflict
16:07:12 <jdavis> Oh
16:07:16 <jdavis> I wanted the library
16:07:39 <jdavis> So I guess I either need stackage, or to break the regex packages?
16:07:54 <glguy> You can use GHC without installing the "Haskell Platform"
16:08:32 <glguy> The GHC that comes in trusty looks like 7.6.3 which is older than you'll probably want, anyway
16:09:04 <jdavis> OK. Maybe I'll just update to 15.10 and try again?
16:10:56 <glguy> Most (but not all) people manage their GHC installation outside of their package manager either through manually installing one or by using stack (which can manage its own GHC installations if you want)
16:10:57 * hackagebot yesod-content-pdf 0.2.0.3 - PDF Content Type for Yesod  https://hackage.haskell.org/package/yesod-content-pdf-0.2.0.3 (alexkyllo)
16:10:59 * hackagebot servant-swagger 1.0.2 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.0.2 (NickolayKudasov)
16:11:32 <geoffreyiy> @djiin (a -> a -> b) -> [a] -> [b]
16:11:32 <lambdabot> Error: Undefined type []
16:12:16 <geoffreyiy> @djinn (a -> a -> b) -> [a] -> [b]
16:12:16 <lambdabot> Error: Undefined type []
16:12:24 <glguy> 15.10 comes with GHC 7.8.4 which is better, but still out of date
16:12:36 <geekosaur> :exf (a -> a -> b) -> [a] -> [b]
16:12:37 <exferenceBot> \ f1 -> fmap (\ f -> f1 f f)
16:12:47 <geekosaur> djinn doesn;t o recursive types
16:12:47 <jdavis> glguy: is stack the easiest way to do that?
16:13:34 <fr3tz0r> data B = HiB (Int,Int) | ByeB (Int,Int) ; data A = Something | B A A ; func1 :: A -> ; what is a valid pattern matching then ?: func1 B A A  or func1 HiB (Int,Int) A A ;  Say I func1 calls func2 is func2(B A A) a valid function call if I define func2 like: func2 HiB(a,b) A A = ... next row func2 ByeB(a,b) A A = ...
16:13:51 <glguy> jdavis: Yeah, it's pretty easy
16:14:07 <jdavis> OK, thank you
16:31:04 <fr3tz0r> data C = Void | D C C; I'm not able to pattern match on D Void Void, ghc says it needs two arguments and was given none 
16:31:37 <fr3tz0r> tried _ _ instead of Void but did not work either
16:31:55 <glguy> fr33domlover: You probably need parentheses around that pattern
16:31:55 <monochrom> show complete actual code. you do not really know the cause.
16:34:10 <fizruk> fr3tz0r: maybe you missed parenthesis around (D Void Void) ?
16:37:02 <dmj> Is using ghcjsi w/ haskell-mode a common thing? Have people been doing this and I've just not known this whole time
16:38:40 <black0range> Hey guys, wondering if anyone know about some decent package that makes a class for all string class where all standard methods are implemented
16:39:21 <monochrom> I think there is a "string like" package on hackage
16:41:13 <dmj> black0range: yea
16:41:43 <black0range> monochrom: Hmm it only does a very few things
16:42:11 <dmj> @package string-conversions
16:42:11 <lambdabot> http://hackage.haskell.org/package/string-conversions
16:42:18 <monochrom> I found one called "strings"
16:43:05 <black0range> i mean something that implements all standard methods (tail, break etc) under one roof
16:43:17 <monochrom> yes, that's what I mean too.
16:43:50 <black0range> monochrom: hmm would you mind sending a link? :)
16:43:51 <monochrom> I only suggest packages that define a type class that has 50 methods
16:43:59 <geekosaur> heh
16:44:08 <monochrom> do you know how to convert package names to urls?
16:44:54 <geekosaur> hm, that package looks a little old tbh
16:45:01 <black0range> monochrom: nvm :P
16:45:03 <glguy> monochrom: Is there a package for that?
16:45:33 <monochrom> there was a lambdabot command for that
16:47:40 <monochrom> another one is "str"
16:48:06 <monochrom> but "str" seems to have fewer methods
16:48:26 <geekosaur> @hackage classy-prelude
16:48:26 <lambdabot> http://hackage.haskell.org/package/classy-prelude
16:48:58 <monochrom> oh, classy-prelude may do it, by being classy on everything under the sun
16:49:10 <geekosaur> pretty much, yes
16:49:47 <monochrom> does it have a class for "class Safe m where safeHead :: [a] -> m a"?
16:50:09 * monochrom is obsessed with safeHead, yes
16:50:21 <geekosaur> it doesn't do head at all
16:50:41 * monochrom is also obsessed with safeFromJust
16:50:58 <Welkin> I read that as safeFromLust
16:51:03 <geekosaur> this would appear to be deliberate, considering that the first thing documented is `undefined` with a big DEPRECATED: DON'T WRITE PARTIAL FUNCTIONS YOU IDIOT (not in so many words)
16:51:11 <black0range> It doesn't have break
16:51:19 <black0range> and it relies on Mono-Traversable 
16:51:27 <Welkin> black0range: is black the new orange?
16:51:30 <black0range> which converts everything to lists 
16:51:45 <black0range> Welkin: No orange is back in black :P
16:52:20 <monochrom> I saw "strBreak" and "sBreak"
16:52:32 <geekosaur> black0range, re mono-traversable, your options, practically speaking, are either that or the stream abstraction that Parsec uses
16:52:49 <geekosaur> you *can;t* just pretend all string-likes are created equal
16:53:25 <black0range> geekosaur: well i've maybe not given it enought though but in some cases? 
16:54:10 <black0range> black0range: say i want to parse a http request theres very few things thats differs between the implementations 
16:54:18 <geekosaur> in some cases, yes the problem is that most libraries either end up limited to the cases that are always 100% safe, or end up needing to switch to one of those abstractions because someone wants/needs something else
16:54:59 <geekosaur> you'd be surprised, actually.  I think you'll find typing the intermediate values gets difficult
16:55:34 <geekosaur> this is an area where poeple always think it's easy, until they sit down and try to figure it out themselves and realize just how horrid it really is
16:55:51 <black0range> geekosaur: Well honestly i was typing away just fine with mono traversable until i realised it uses lists :( 
16:56:04 <black0range> geekosaur: I trust you :) 
16:57:12 <geekosaur> I haven't ctually sat down and written such a library. I did help someone in here debug something using OverloadedStrings, and the type errors they were getting --- around uses of `break`, in fact --- were informative
16:57:15 <Hijiri> @hoogle (a -> a ->a) -> (a->a->a->a)
16:57:17 <lambdabot> Data.IntMap.Strict insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
16:57:17 <lambdabot> Data.IntMap.Lazy insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
16:57:17 <lambdabot> Data.IntMap insertWith' :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
16:57:56 <geekosaur> hm, actually not break itself but something in the same basic "family" of functions.
16:58:29 <monochrom> the mixture of OverloadedStrings and Foldable is a lot of ambiguous type variables
16:59:02 <black0range> But it feels so wasteful to write the exact same thing 4 times to implement for example a url parser 
16:59:08 <geekosaur> I had to stop and think about what was happening on what level, and the result told me a lot about how hard it is to come up with an abstraction for string-like things that doesn't break down at the worst possible time for the end user
16:59:26 <monochrom> e.g., suddenly  mapM_ f "abc"  is ambiguous
16:59:27 <emmanuel_erc> Hi there!
17:00:45 <emmanuel_erc> Are zippers on the Map data type from Data.Map particularly useful?
17:01:36 <geekosaur> so, converting everything to a list looks lame but is one of the more reasonable possibilities. Parsec uses a stream typeclass instead; this gets you something that sometimes ends up being lists anyway and sometimes requires you to use operations that aren't "familiar string operations"
17:02:11 <geekosaur> ...in large part because in Haskell, all the "familiar string operations" aren't actually string operations. they're generic list operations that happen to be used on [Char] a lot
17:02:39 <geekosaur> and several of them only really make sense, as written, on lists
17:03:07 <geekosaur> which means there's some horrid gotchas in the ByteString and Text emulations of them
17:07:35 <black0range> geekosaur: Well i'll just do without then :) 
17:07:38 <geekosaur> oh, another point: just because something is written assuming lists doesn't mean it's actually doing them as lists, via the magic of stream RULES
17:08:04 <geekosaur> if you haven't done anything too strange, ghc will fuse the lists away
17:08:37 <geekosaur> if you *have* done something too strange, you weren't going to escape lists anyway --- this is the cause of the gotchas I mentioned in ByteString and Text
17:09:18 <monochrom> I forgot that mono-traversable was an option
17:12:00 <monochrom> this is a pretty big abstraction of uncertain value.
17:15:10 <black0range> monochrom: Well tried it for a while. Code is a lot slower to write but theres a whole lot less of it to write. Also i think the performance is worse in most cases 
17:15:34 <black0range> Unless ghc does some absolute magic as geekosaur said 
17:16:38 <monochrom> fusion relies on the library author carefully crafting rewrite rules
17:16:45 <geekosaur> ghc tries hard to do magic. it can't always succeed. ByteString and Text in particular have a lot of RULES to try to encourage stream fusion to occur --- but if it can't fuse, the only way to guarantee correct operation of the "familiar" string APIs is to unpack to lists and use the list APIs
17:16:55 <magic> Many many things try to do magic.
17:17:07 <monochrom> haha
17:17:31 <monochrom> but many many things try to be colorful, not monochromatic
17:17:55 <geekosaur> and the only way to escape it is to fin ways to eformulate what you're trying to do so you don't use APIs that at their heart are list-based. this ends up including things like break and span
17:18:17 <geekosaur> *reformulate
17:19:09 <black0range> magic: Just things? ;)
17:19:17 <fr3tz0r> I try to learn haskell datatypes but i don't really grasp it jet, what's wrong with this(i know is not fully comlplete): http://lpaste.net/517901355713560576
17:19:20 <magic> black0range: People are things.
17:20:35 <black0range> magic: True true 
17:21:19 <geekosaur> fr3tz0r, not many people here can just look at random code and figure out what errors it has. can you include full error text, or otherwise describe what you think it should do vs. what it actually does?
17:21:40 <geekosaur> however I will note that you already have some "red flags":
17:22:01 <geekosaur> you are defining a data type using a tuple internally. Why not separate fields?
17:22:01 <monochrom> I also wonder why lately many people like "data X = Ctor (A,B)" as opposed to "Ctor A B"
17:22:31 <geekosaur> you are using parentheses like you would in languages where function calls look like f(a, b, c) instead of (f a b c) like Haskell does
17:22:37 <monochrom> is there a recent lecture in which the lecturer did this?
17:24:05 <monochrom> "bt (Node t1 t2) = " is a case of not enough parameters
17:24:07 <geekosaur> monochrom, I suspect it has something to do with what I just said. if you;re used to languages where everything is uncurried, you end up defaulting to uncurried forms
17:24:24 <monochrom> the type sig promises two parameters. the implementation takes one only.
17:24:54 <geekosaur> mm, yes, that's confusion over the pointless tuple
17:27:21 <fr3tz0r> geekosaur:with internally you mean that i define Node in a different datatype instead of using it as a value constructor?
17:28:52 <geekosaur> no. I mean you used `MEN ([Char], Int)` instead of `MEN [Char] Int` which is more idiomatic. and being confused about this seems to have led to your later confusion about the number of values: a tuple is *one* value, not two
17:29:45 <geekosaur> you are also confused about type vs. value level. Node is a type; the pattern used in the definition of `bt` should be a value (here either `MEN` or `WOMEN`)
17:31:12 <geekosaur> and I was abotu to show what the first case for `bt` should look like, given how you defined `Node`, but I cannot figure out what you intended by `compare2(Node , Node)`
17:31:47 <geekosaur> oh, whoops
17:31:53 <geekosaur> here's a value level Node too >.>
17:32:02 <geekosaur> that's a lovely way to become confused
17:33:29 <geekosaur> rename the `data Node` to something else, perhaps. then the first case of bt is `bt (Node l r) = compare2 l r`
17:34:06 <geekosaur> (renaming data Node is not mandatory, but it will help you keep Node-the-type separate from Node-the-constructor-for-FamilyTree)
17:34:19 <fr3tz0r> i really appreciate your help/feedback :) please continue (y) ,i will fix the code in just a minute , brb 
17:34:28 <monochrom> I think overall you need to use a textbook at least 300 pages thick, and restart from the beginning, and go slowly, no dive-in.
17:36:00 * hackagebot fixfile 0.1.0.0 - File-backed recursive data structures.  https://hackage.haskell.org/package/fixfile-0.1.0.0 (rev_null)
17:40:47 <RyanGlScott> Is there a GHCi command that expands type synonyms?
17:41:14 <RyanGlScott> :kind! expands type family applications, but it apparently doesn't work on type synonyms
17:43:15 <RyanGlScott> Huh, well I found a workaround
17:43:27 <RyanGlScott> let wat :: CrazyTypeSynonym ...; wat = undefined
17:43:31 <RyanGlScott> Then run :t wat
17:52:05 <jle`> how about :t undefined :: CrazyTypeSynonym?
17:52:15 <jle`> oh, that doesn't work
17:52:33 <jle`> either way, not quite dieal
17:52:44 <jle`> RyanGlScott: :i seems to work for me
17:52:51 <jle`>  :i CrazyTypeSynonym
17:53:25 <RyanGlScott> jle`: I need to use CrazyTypeSynonym in a certain context, so that doesn't work
17:53:42 <jle`> i see
17:54:06 <geekosaur> RyanGlScott, I think mniip was playing around with that earlier
17:54:52 <RyanGlScott> What was the conclusion?
17:55:18 <geekosaur> https://lpaste.net/5306863046931513344
17:55:41 <geekosaur> and check channel logs from '@letlpaste 5306863046931513344'
17:55:58 <geekosaur> (I think it's still loaded in lambdabot)
17:56:26 <RyanGlScott> Ah, that's a handy trick
18:10:30 <naudiz> glguy: I'm using hardened, maybe that's the problem... 
18:29:43 <x393> hey
18:36:20 <testeh> Hello
18:40:25 <black0range> If I want to do something to a lazy bytestring and have defined the function for strict bytestring. Would fromChunks . function . toChunks be a good alternative for speed or should I use the lazy functions? 
19:11:33 <jle`> black0range: what's wrong with toStrict / fromStrict ?
19:12:14 <jellytux> what are the differences between unqualified and qualified when importing?
19:12:25 <Welkin> jellytux: namespacing
19:13:11 <jellytux> Welkin: ah, so if I just import it doesn't get into a namespace?
19:13:40 <Clint> it gets into the global namespace
19:13:50 <jellytux> Welkin: import Mod will bring x y z into scope, while import qualified Mod will bring Mod.x Mod.y Mod.z
19:14:00 <Welkin> yes
19:14:06 <Welkin> you can rename the namespace too
19:14:12 <jellytux> yep with the `as`
19:14:16 <jellytux> thank you
19:14:17 <Welkin> import qualified Data.Text as T
19:18:14 <bitemyapp> ReinH: plugged yer wishlist
19:26:31 * hackagebot invariant 0.3.1 - Haskell 98 invariant functors  https://hackage.haskell.org/package/invariant-0.3.1 (ryanglscott)
20:50:58 <Big_G> Are there any standard config files for emacs in regard to Haskell development?
21:03:25 <bsmt> haskell-mode?
21:31:34 * hackagebot hasql-pool 0.4 - A pool of connections for Hasql  https://hackage.haskell.org/package/hasql-pool-0.4 (NikitaVolkov)
21:36:34 * hackagebot success 0.2.6 - A version of Either specialised for encoding of success or failure  https://hackage.haskell.org/package/success-0.2.6 (NikitaVolkov)
21:38:52 <f-a> how ot get ghci to print unicode chars instead of \239 in Strings?
21:40:15 <pavonia> It should print them if you use putStrLn with the right charcter encoding
21:40:58 <f-a> pavonia: is that valid when I type something without putStrLn? (e.g. map f someString)?
21:41:37 <pavonia> No, if only String values are printed, the Show instance for String is used
21:44:46 <f-a> thanks
21:50:51 <django_> what is something useful i can work on
21:52:36 <jle`> what are you good at?
21:59:56 <Lokathor> so if i'm using persist
22:00:10 <Lokathor> and it populates a database with a template created datatype and all that
22:00:29 <Lokathor> when i change the data type by adding a field, and i recompile and re-run
22:00:44 <Lokathor> does it just flip out that the old database doesn't match the new schema it thinks it should have?
22:01:05 <Lokathor> how much ahead of time do i have to plan my data type, is i guess another way to phrase the question
22:06:45 <jle`> it depends on the backend, i think
22:07:03 <jle`> i'm pretty sure if you use an SQL backend then you're going to have to write/perform a migration on any non-trivial schema change
22:07:30 <Lokathor> hmmm, i was thinking sqlite, but wasn't married to hard to it
22:08:15 <jle`> this is sort of the "downside" of SQL databases, they're not super flexible in terms of schema changes and migrations can be tricky
22:08:30 <Lokathor> well, i do hear that MongoDB is web scale
22:08:35 <TommyC> Hrmmm...does the bot have a books factoid by any chance?
22:08:40 <jle`> i forgot how persist handles migrations and schema changes
22:08:58 <Lokathor> TommyC, books factoid?
22:09:33 <TommyC> A factoid for books recommended for learning haskell.
22:09:46 <Lokathor> oh, http://www.haskellbook.com/
22:10:07 <TommyC> Lokathor: Thank you.
22:10:09 <Lokathor> bitemyapp got a pretty sweet domain when he snagged that one, very to the point
22:10:31 <jle`> TommyC: there's a list of books on the sidebar of the haskell subreddit, too :)
22:10:33 <Lokathor> TommyC, the book is solid and self contained and all, but feel free to come back with questions as you have them
22:11:00 <TommyC> Hrmmm...perhaps it is time I checked out reddit (I never really did to be quite honest)
22:11:24 <dmj> Lokathor: go postgresql
22:12:07 <Lokathor> dmj well i'm running this as a toy project inside another guy's server, and so the less i have to bug him about getting me a db account and stuff the better, which is why SQLite was my SQL of choice
22:12:54 <Lokathor> he gets kinda sullen about the weirdest stuff. like i have two programs that use websockets, and he wanted me to just merge them into one huge program because "it's all the same right? I only want to use one port all the time"
22:13:03 <jle`> lol
22:13:29 <Lokathor> i'm like, "no, you have different URLS for different pages, this is the same deal here"
22:13:35 <jle`> with injective type families in ghc 8.0, will there be much uses for data families now?  besides just convenience in namespace issues
22:16:19 <Lokathor> the alternate solution is to use a huge map all the time, but it sounds shaky
22:18:34 <jle`> "huge map all the time" is sort of how acidstate works; it lets you use normal haskell data types and keep them persistent and stuff
22:18:48 <jle`> or well, it's not how it works, but it's one thing that acidstate enables you to do
22:18:50 <jle`> in a nice way
22:19:09 <Lokathor> well the thing i really want to try and get at is rolling persistance across software versions
22:19:27 <jle`> yeah, acid-state + safecopy handles that nicely
22:19:32 <Lokathor> hopefully, with live reloading as well :3
22:19:40 <boj> Lokathor: spin up a $5/mo digitalocean instance and skip the middle man
22:19:46 <jle`> safecopy lets you handle migrations and legacy versions in a pretty nice/cute haskelly way
22:20:29 <Lokathor> boj, mmm, but this is 0/month
22:20:40 <boj> two cups of coffee for freedom man
22:21:04 <Lokathor> well i only have about 40 dollars spare a month, so i'll keep my free but slightly ornry server
22:22:17 <dmj> boj: 1 cup in some places
22:22:30 <boj> indeed
22:26:56 <dmj> I wish it were possible to have symlinked dirs in hs-source-dirs, or to point to parent directories
22:36:37 <ReinH> dmj: why?
22:39:20 <dmj> ReinH: I'd like to share types between my web server and client code without introducing a third project. I'd like to have only have 2 cabal files, each w/ its own library section + executable, and then a third directory "common" that could be specified in hs-source-dirs of both the web server and client code projects
22:39:33 <dmj> to have only 2*
22:40:05 <dmj> the "common" directory isn't a project, just a folder with modules in it
22:42:56 <dmj> "one weird trick to share your types, type theorists hate him"
22:42:58 <Lokathor> can't a hardlink do that?
22:44:38 <dmj> Lokathor: if the directories look like app/client/client.cabal, app/server/server.cabal there'd be no way to specify a "common" directory (or any other for that matter) w/o specifying a parent directory in hs-source-dirs (which isn't possible afaict)
22:45:07 <Lokathor> can't you make one of the directories a hardlink to the other though, i mean?
22:45:30 <Lokathor> like, via the file system not via cabal
22:47:36 <dmj> Lokathor: not sure what you mean
22:47:46 <dmj> what would that look like
22:49:58 <dmj> ReinH: I'm on OSX so I can't do things like build ghcjs-dom / reflex-dom on regular ghc, since webkitgtk3 is fubar, but I have ghcjsi working w/ emacs. This means I can't have one cabal file that contains a single library and two executables
22:50:37 <boj> dmj: something like "ln src dst"
22:50:40 <dmj> and then call stack build specifying two different stack files, one that builds w/ ghc and the other w/ ghcjs
22:50:55 <dmj> boj: maybe...
22:56:17 <ReinH> dmj: I find it easiest to just share a package and organize things using stack
22:56:56 <ReinH> I can't imagine symlinking things around to be anything other than brittle and awful
23:00:49 <dmj> ReinH: yea, that's probably best
23:01:07 <ReinH> I'm already doing that for a ghcjs/ghc project, it works fine
23:02:18 <dmj> ReinH: do you use OSX?
23:03:01 <dmj> just curious
23:05:44 <Lokathor> dmj, http://lpaste.net/151826 is this kinda what you wanted?
23:06:31 <dmj> interesting, I'm not sure
23:07:15 <Lokathor> http://www.cyberciti.biz/tips/understanding-unixlinux-symbolic-soft-and-hard-links.html it's a giant pile of weirdness, but a hardlink means that two points in the filesystem point to the exact same point on disk, it's a little different from a symbolic link
23:11:46 * hackagebot rebase 0.3.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.3.1 (NikitaVolkov)
23:21:46 * hackagebot rebase 0.3.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.3.2 (NikitaVolkov)
23:22:39 <mniip> is it possible to 'pattern match' application in a type family?
23:24:31 <jle`> type instance (f a) = .. ?
23:26:06 <mniip> kinda
23:26:06 <mniip> it's a closed family though
23:26:06 <mniip> does that work?
23:29:51 <mniip> hmm it does
23:29:56 <mniip> I'm getting a weird error message though
23:31:56 <jellytux> do you have any small apps or modules on github?
23:33:18 <lpaste> mniip revised “wut”: “wut” at http://lpaste.net/151828
23:33:30 <mniip> jle`, any idea what's going on there
23:36:05 <jle`> that's definitely interesting :)
23:38:00 <mniip> something wonky in the kindchecker
23:38:18 <mniip> I can say
23:38:38 <mniip> 'TyFam (f a) = a' and 'TyFam (f a) = f' but not 'TyFam (f a) = f a'
23:39:59 <mniip> whut
23:43:46 <mniip> hmm I think I just created an ill-kinded type
23:44:34 <mniip> actually maybe not
