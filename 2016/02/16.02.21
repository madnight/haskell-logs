00:07:40 * hackagebot list-t 0.4.6.1 - ListT done right  https://hackage.haskell.org/package/list-t-0.4.6.1 (NikitaVolkov)
00:07:40 * hackagebot logging-facade 0.1.1 - Simple logging abstraction that allows multiple back-ends  https://hackage.haskell.org/package/logging-facade-0.1.1 (SimonHengel)
00:35:28 <osfameron> got some replies to my whining about stack on github! https://github.com/commercialhaskell/stack/issues/1816
00:35:35 <osfameron> kadoban: ^^
00:36:29 <osfameron> makes me realise how little I understand the haskell toolchain - one of the comments suggests that stack can also install modules from "hackage and stackage" (which, presumably cabal-install can't?)
00:36:39 <osfameron> and I don't really know what those are.  /me googles for an overview...
00:43:56 <cocreature> osfameron: hackage is the haskell package repository. it’s used by both stack and cabal-install. stackage maintains lists of snapshots containing hackage packages with a fixed version that are known to work together
00:44:26 <cocreature> by default stack uses one of those snapshots which in most cases means that you don’t run into version conflicts
00:46:24 <osfameron> sounds sensible.  and then you can upgrade a whole project to a later snapshot?
00:46:31 <cocreature> exactly
00:52:36 * hackagebot cryptohash 0.11.7 - collection of crypto hashes, fast, pure and practical  https://hackage.haskell.org/package/cryptohash-0.11.7 (VincentHanquez)
00:53:01 <osfameron> what is the expectation for what we put into the stack-generated ./test/Spec.hs file?
00:54:52 <osfameron> presumably any routine that raises an error on failure will do
00:54:57 <cocreature> osfameron: hspec tests, if you just want a simple template instead of one with a separate library and tests you can use "stack new test"
00:57:22 <osfameron> cocreature: great, thanks.
00:58:04 <osfameron> the Spec.hs generated was so generic I was a little worried I'd have to essentially write my own test mini-framework
00:58:33 <tomjaguarpaw> Is there a good comparison of different approaches to Generics?
00:58:53 <osfameron> hspec looks nice
00:59:26 <tomjaguarpaw> For example, what's the difference between Data.Data and GHC.Generic?
01:12:37 * hackagebot vinyl-utils 0.2.0.3 - Utilities for vinyl  https://hackage.haskell.org/package/vinyl-utils-0.2.0.3 (mjmrotek)
01:32:37 * hackagebot cryptonite 0.13 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.13 (VincentHanquez)
01:57:03 <tomjaguarpaw> Can someone point me to an example of using generics to define higher rank stuff?  Applicative instances, for example?
01:57:18 <tomjaguarpaw> kosmikus_: ^^ perhaps?
02:04:36 <osfameron> for a stack project, should I commit the stack.yaml ?
02:04:43 <osfameron> I'm guessing that .stack-work/ should be .gitignore'd
02:05:55 <Axman6> yes and yes (IMO)
02:06:24 <Axman6> including the stack.yaml makes it a lot easier for others to contribute
02:07:45 <ahihi> and to build the project in the first place
02:08:01 <osfameron> ah.  I thought that the {myapp}.cabal would be enough there?
02:08:13 <osfameron> e.g. when I needed to include 'containers', I only added it to the .cabal
02:08:20 <osfameron> and stack Did The Right Thing
02:08:27 <osfameron> won't it do that for contributors too?
02:08:42 <haskell000> How to deal with Maybe ()? For example I have filename inside Maybe. file = Maybe "foo.txt" how to delete this file with removeFile :: FilePath -> IO () ?
02:10:08 <lyxia> haskell000: pattern match, or mapM_
02:11:48 <osfameron> or fromJust or catMaybes
02:12:52 <ahihi> osfameron: more opinions here https://www.reddit.com/r/haskell/comments/415vne/to_ship_stackyaml_or_not_to/
02:15:38 <osfameron> ahihi: thanks!
02:15:56 <osfameron> so, for contribution, is it just a case of checking the repository out and Everything Just Works?
02:16:14 <osfameron> e.g., if you have stack intalled, you can just cd to the checkout and type `stack test` and `stack repl` ?
02:19:05 * osfameron pushes https://github.com/osfameron/crow -- comments very welcome
02:20:26 <haskell000> lyxia: thanks, mapM_ is what I wanted
02:51:31 <bollu> is it possible to have a cabal rule run another haskell file using runhaskell?
02:56:53 <lyxia> bollu: You can customize your build infrastructure by changing the build-type option and Setup.hs.
02:58:52 <bollu> lyxia: hm, but I just want this behaviour for one rule
02:58:57 <bollu> lyxia: is that possible?
03:02:45 <lyxia> bollu: What are you trying to do exactly?
03:03:12 <bollu> there's a bunch of examples, that I want to be able to run / build
03:03:24 <bollu> but they'll clutter up the cabal file if I add them all up
03:03:37 <bollu> so I'd like to have a rule in the cabal file that builds / runs the examples programatically
03:03:43 <bollu> context: https://github.com/cchalmers/plots/pull/5
03:12:49 * hackagebot product-profunctors 0.7.0.2 - product-profunctors  https://hackage.haskell.org/package/product-profunctors-0.7.0.2 (tomjaguarpaw)
03:19:10 <lyxia> bollu: it would be much simpler to expect a user to type 'stack runghc example.hs' themselves :)
03:23:03 * hackagebot relational-query 0.8.1.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.1.0 (KeiHibino)
03:26:10 <bollu> lyxia: heh, I suppose that is fair too
03:28:49 <lyxia> meh, in the end I don't see a way to achieve what you want :(
03:29:34 <montanonic> I'm reading Oleg, Sabry and Sword's paper on extensible effects as an alternative to Monad Transformers. Just wanted to ask: Any reason why it hasn't caught on more? It proposes itself as an alternative to Monad Transformers.
03:29:48 <montanonic> (sorry, didn't realize the redundancy there)
03:45:19 <puregreen> montanonic: here's Edward Kmett's comment on extensible effects, maybe it'll help
03:45:21 <puregreen> https://www.reddit.com/r/haskell/comments/387ex0/are_extensible_effects_a_complete_replacement_for/crt1pzm
03:45:53 <puregreen> also https://www.reddit.com/r/haskell/comments/1j9n5y/extensible_effects_an_alternative_to_monad/cbcwbsa
03:46:01 <montanonic> puregreen: perfect, thank you; I just finished reading another one of his comments from 2 years ago, but that was before Freer
03:46:12 <montanonic> ^^that's the one
03:48:04 * hackagebot pipes-key-value-csv 0.0.0.0 - Streaming processing of CSV files preceded by key-value pairs.  https://hackage.haskell.org/package/pipes-key-value-csv-0.0.0.0 (mjmrotek)
04:05:29 <Industrial> Hi. Coming from Node.js I would like to make a simple program with Haskell - as an excercise to learn it - that does a `ls -AlF`.
04:06:05 <mauke> have you considered starting with the easy stuff?
04:06:15 <Industrial> I have a small start, https://gist.github.com/Industrial/900888b76f92595dfaed, but it's incorrect.
04:06:47 <Lowl3v3l> Industrial, "haskell by example" and "learn you a haskell for great good" are THE sources to start ;)
04:07:39 <Industrial> "Couldn't match type ‘[Char]’ with ‘Char’ Expected type: String  Actual type: [FilePath]" is the error I get. I'm now trying to see how I can get these FilePath's printed
04:07:42 <Industrial> http://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html#t:FilePath
04:07:50 <montanonic> Industrial: https://github.com/bitemyapp/learnhaskell
04:08:02 <mauke> putStrLn takes a string. you're giving it a list of strings
04:10:49 <dramforever> When GHC says Couldn't match type A with B, Expected type X, Actual type Y
04:11:15 <dramforever> It means that from the context, something should have type X, but from the thing itself, it has type X
04:11:21 <dramforever> *but from the thing itself, it has type Y
04:11:36 <mniip> and X != Y because A != B
04:11:42 <dramforever> mniip: exactly
04:11:45 <mauke> /=
04:11:53 <mniip> =/
04:13:14 <dramforever> Industrial: you can keep in mind that String's in haskell are [Char]'s, i.e. lists of characters
04:14:28 <mauke> > word's "foo bar baz"
04:14:29 <lambdabot>  ["foo","bar","baz"]
04:15:48 <Hafydd> Why on earth is "word's" defined?
04:16:03 <mauke> for consistency with line;s
04:16:07 <mauke> er, line's
04:16:14 <Hafydd> Why on earth is "line's" defined?
04:16:30 <no-n> foor consistency with word's
04:16:35 <Hafydd> Hahaha.
04:16:39 <mauke> unline's
04:17:21 <FireFly> What is the definition of a word' anyway
04:17:40 * no-n bed
04:18:06 <mauke> :t word's :: String -> String's
04:18:07 <lambdabot> String -> String's
04:18:44 * dramforever feels weird seeing that
04:19:10 <mniip> HAHAHAHA
04:19:32 <dramforever> I'm probably leaving
04:19:39 <mniip> mauke, why not Char's's
04:20:00 <mauke> because dramforever only said String's
04:20:00 <FireFly> Is this where mauke is sneakily @def'ing these before demonstrating them in-channel?
04:20:09 <FireFly> or @let I guess
04:20:27 <Hafydd> I have to conclude so...
04:20:58 <Industrial> mauke: I've found the unlines function however `contents <- getDirectoryContents "."` `putStrLn unlines contents` doesn't work either. I'll get there though. :-)
04:21:11 <Hafydd> @check \xs -> words xs == word's xs
04:21:13 <lambdabot>  +++ OK, passed 100 tests.
04:21:37 <dramforever> Industrial: How much Haskell have you learned? Which tutorial have you been following?
04:22:59 <mauke> Industrial: again, why not start at the beginning?
04:23:04 <Industrial> None yet. The only experience I have right now is running xmonad (window manager).
04:23:19 <dramforever> Industrial: please start with a tutorial. seriously
04:23:59 <dramforever> If you have been learning programming languages by smashing together example code historically, please, for whatever's sake, don't do this with Haskell
04:25:03 <Industrial> I've learnt a lot from just prodding a thing with a stick. Even things with huge manuals. I will do the course though ;)
04:25:25 <dramforever> Haskell is vastly different from most languages (except maybe Ocaml or stuff), different enough that, yes I'm still repeating it, putting together things won't work as you expected
04:26:00 <dramforever> of course I could be just guessing too wildly, and it doesn't make sense on your side
04:28:47 <Industrial> Well, coming from JavaScript, the static typing I'll have to get used to. JS isn't pure or lazy but you can do some functional stuff with it. I'm not uncommon to asynchronous code or backarrows (some compile-to-js languages (LiveScript.net) use this syntax for async/io)
04:29:27 <Industrial> I love that you can leave lots of stuff away, and there's probably a looot of operators/syntax I don't know yet
04:29:37 <mauke> that should theoretically help you with IO's >>=
04:29:48 <Hafydd> Is "looot" pronounced as the musical instrument?
04:29:49 <mauke> but that requires you to understand the rest of the language first
04:30:09 <Industrial> Hafydd: yes. Some would say "lewt" :p
04:31:21 <Industrial> ok got it. `mapM_ putStrLn contents` :D
04:32:13 <mauke> Industrial: your first idea was better
04:32:18 <dramforever> Industrial: wow IMHO you are going really fast without a tutorial :) You're brain must be really suitable for Haskell
04:46:12 <Industrial> finally.
04:46:31 <Industrial> `contents <- getDirectoryContents "."` and `putStrLn $ unlines contents` :)
04:46:34 <Industrial> derp.
04:49:47 <mniip> Industrial, I'd do 'mapM_ putStrLn contents' instead
04:51:09 <jedai_> mniip: mauke just told him his first idea was better... And really, doing mapM_ putStrLn or putStrLn . unlines is a matter of taste, not very important
04:51:37 <mniip> ah well,
04:51:54 <jedai_> mniip: I can get the preference for "putStrLn . unlines" though, you minimize the IO part
04:52:18 <jedai_> But at this point that's stylistic differences :)
04:52:28 <mniip> not really
04:52:33 <mniip> unlines inserts \n
04:52:40 <mniip> putStrLn inserts systemwide newlines
04:52:43 <mauke> wrong
04:52:48 <mniip> oh?
04:52:50 <mauke> @src putStrLn
04:52:50 <lambdabot> putStrLn s = do putStr s; putChar '\n'
04:53:02 <mauke> it literally prints a \n
04:53:18 <mauke> also, \n is the systemwide newline
04:53:33 <jedai_> mniip: mauke: the translation of \n is taking place in the IO engine, both solution are identical in term of output
04:53:38 <mniip> oh? windows does the translation?
04:54:25 <jedai_> mniip: Right, if your handle is in textual mode (and not binary, in this case \n is a well defined 7bit character)
04:54:39 <mauke> the IO library does the translation
04:55:10 <mniip> mhm
04:55:11 <mniip> TIL
04:55:35 <mauke> looks like the actual implementation is a bit more involved: http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.IO.Handle.Text.html#hPutStr
04:55:42 <mauke> it still boils down to '\n', though
04:57:43 <jedai_> Right, the translation is there : http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.IO.Handle.Text.html#hPutcBuffered
04:57:44 <mauke> http://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.IO.Handle.Text.html#writeBlocks this part does the translation (| c == '\n' = ...)
04:58:12 <jedai_> Well, seems there several place where the translation is done...
04:58:36 <mauke> yours is for a single char, mine is (I think) for optimised putstr
04:59:11 <jedai_> mauke: if you look in hPutStr, it depend on the buffer mode
04:59:26 <dramforever> Does the Haskell report say anything about this?
05:00:00 <jedai_> dramforever: I don't think so, anyway this is platform-dependent behaviour
05:00:23 <dramforever> ok then
05:00:31 <jedai_> And only relevant to textual mode, not binary mode
05:02:07 <mauke> "he treatment of the newline character will vary on different systems. For example, two characters of input, return and linefeed, may read as a single newline character."
05:03:14 <mauke> yeah, doesn't say much
05:03:21 <mauke> but I'd assume C semantics by default
05:03:37 <mauke> C invented \n, and \n is The Portable Newline Abstraction
05:05:14 <ggole> No, \n is just a char. It's the C stdlib that treats \n specially, expanding it into multiple chars where necessary (on platforms where that is required)
05:05:49 <ggole> That's why there's strange things like text vs binary modes.
05:06:37 <maho> Hello, here's my question. It's somewhat worded strangely, but the examples make it clear. http://paste.ofcode.org/xknHNTgmMDnvKZ6TJu4NWp Solution: http://paste.ofcode.org/VJbgKZyrtjtdFipm8kXj3B However, the output of the last test case is wrong. Can anyone help?
05:07:30 <mauke> maho: wrong channel
05:14:43 <maho> mauke: Sorry, I can make do with any language
05:15:38 <mniip> maho, but this is #haskell
05:15:49 <mniip> perhaps you were looking for ##c or ##programming ?
05:16:00 <maho> Yes, so haskell logic and code will do
05:16:13 <mauke> ... I'm not going to write your program for you
05:16:42 <cocreature> mauke: you’re so selfish!
05:17:31 <maho> Please don't automatically assume that I want to get something done
05:18:27 <mniip> I was going to write something incomprehensible to non-haskellers but the task seems to be a bit more elaborate than what I expected :p
05:19:03 <mauke> k
05:19:40 <montanonic> mniip: can you explain what the task is?
05:19:49 <mniip> I don't think I can
05:20:00 <montanonic> I don't understand what it's saying aside from there being fibonacci somewhere
05:20:36 <mniip> ah
05:20:41 <montanonic> I think this exercise is intended to prepare you for working with legacy code?
05:20:45 <mniip> so
05:20:48 <Freundlich> Sounds more like an addition chain to me.
05:21:25 <Freundlich> But the problem is badly worded. I'm not sure what it's supposed to be.
05:21:35 <mniip> a "valid" sequence is defined as one where f(n) = f(n-1)+f(n-2), except exactly one of the elements is wrong
05:22:04 <mniip> you are given an array of numbers, you have to find the longest subsequence that is "valid"
05:22:17 <mniip> if there are multiple of equal length you have to output them all
05:22:27 <Freundlich> Ok, that makes it clearer.
05:23:03 <dramforever> maho: Sounds interesting, but what's the upper bound of the size of the array?
05:28:17 <mauke> maho: how many channels are you spamming with this?
05:28:30 <maho> mauke: Sorry
05:30:21 <jedai_> mniip: You're wrong, the output is more complicated than that...
05:30:32 --- mode: ChanServ set +o mauke
05:30:32 --- kick: maho was kicked by mauke (thanks for the spam)
05:30:33 <jedai_> maho: did you have your answer
05:30:35 <mniip> well yes,
05:30:42 <mniip> you have to print start/end indices
05:30:46 <montanonic> They were just in #haskell according to whois
05:31:00 <mniip> yeah I don't share any other channels with them either
05:31:06 <mauke> I just kicked them from #perl
05:31:07 <mniip> ah, #perl
05:31:25 <jedai_> mniip: Right but those don't indicate "valid" sequence, just sequence which contain only one error
05:31:39 <mniip> "one error" is within the definition of "valid"
05:32:15 <jedai_> mniip: ok then (but 0 error is not "valid" then)
05:32:32 --- mode: mauke set -o mauke
05:33:16 <mniip> yes
05:33:21 <jedai_> Ah, right, I missed your "except exactly one of the elements is wrong"
05:33:21 * hackagebot stack 1.0.4.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-1.0.4.1 (borsboom)
05:33:24 <jedai_> Sorry
05:53:22 * hackagebot path-io 1.0.0 - Interface to directory package for users of path  https://hackage.haskell.org/package/path-io-1.0.0 (mrkkrp)
06:40:38 <macalimlim> hello :) on what package can you find Control.Monad.Logic ?
06:41:22 <Clint> macalimlim: logict
06:41:57 <macalimlim> thanks Clint :)
07:03:31 <arianvp> Has anybody here used digestive-functors for clientside validation?
07:03:35 <arianvp> with javascript?
07:03:39 <arianvp> im sure it must be possible
07:03:57 <fr3tz0r> every new function a write in a module gets out of scope, how can i solve this?
07:04:38 <fr3tz0r> i write another function that does exactly the same with a different name to test
07:04:46 <fr3tz0r> and it got out of scope
07:04:49 <fr3tz0r> ...
07:05:19 <liste> @paste -- fr3tz0r please lpaste your code
07:05:19 <lambdabot> Haskell pastebin: http://lpaste.net/
07:05:34 <fr3tz0r> can't do that
07:05:41 <liste> why?
07:05:57 <fr3tz0r> so strange this will not happen in any other language
07:07:00 <liste> probably the functions you add are not in exports list, but we can be sure only when you paste your code
07:08:05 <geekosaur> can you reproduce this in something you are allowed to paste, or are we supposed to make wild guesses?
07:08:55 * osfameron notices that he's making much *bigger* refactors in Haskell code than corresponding OO, as the design changes.  Is that a common experience?
07:09:19 <osfameron> I expect it'll get better with time as I get more familiar with the common patterns
07:09:20 <liste> osfameron: yes, for me at least. refactoring is more fun when I feel safe (:
07:09:23 <hodapp> osfameron: I've noticed the same.
07:10:01 <hodapp> particularly, refactors have been over much bigger things because there was a much stronger sense of not breaking lots of things.
07:10:06 <hodapp> and breakage was noticed readily.
07:10:18 <osfameron> yes... but the problem is that it's broken for a lot longer
07:10:34 <osfameron> I'll know when it's refactored because the code will suddenly compile :-)
07:10:50 <osfameron> but until then, I don't get as much feedback from Haskell about whether the refactor is progressing well
07:10:50 <hodapp> fr3tz0r: err, yeah, some test code would be good
07:10:53 <fr3tz0r> liste: thx, i think i missed to add them, so stupid...
07:10:54 <osfameron> it's a little unnerving
07:11:12 <hodapp> osfameron: um, that feedback is the compile-time errors, likely
07:11:48 <osfameron> hmm.  I suppose I could try to compile frequently and notice the errors *changing* as I refactor different parts...
07:11:58 <osfameron> thanks, I'll try that
07:12:03 <fr3tz0r> can't i import all functions from a module wwihtout needing to add them to export lists?
07:12:31 <osfameron> fr3tz0r: if you don't supply a (...) list in the module declaration, then it will automatically export everything
07:13:22 <fr3tz0r> osfameron: thx
07:13:49 <kosmikus_> tomjaguarpaw: in case your question hasn't been answered in the meantime: generic-deriving contains a number of examples, including Foldable and Functor ...
07:14:03 <liste> fr3tz0r: you're welcome
07:18:48 * osfameron discovers (map.map) and (zipWith zip)
07:19:10 <liste> :t zipWith zip
07:19:11 <lambdabot> [[a]] -> [[b]] -> [[(a, b)]]
07:19:44 <Jinxit> :t map . map
07:19:45 <lambdabot> (a -> b) -> [[a]] -> [[b]]
07:20:30 <osfameron> you can call the former zipOverGrid
07:20:46 <osfameron> and create an infinite grid of [[(row,col), ...]]
07:20:51 <osfameron> with: zipOverGrid (map repeat [0..]) (repeat [0..])
07:21:02 <osfameron> then zipOverGrid some_other_grid coordinate_grid
07:26:37 <ggVGc> how does the default implementation of "deriving show" work?
07:27:56 <mniip> ggVGc, -ddump-deriv
07:30:08 <ggVGc> ah, from this I understand it's essentially just magic default behaviour, http://stackoverflow.com/questions/3864647/how-does-deriving-work-in-haskell
07:30:11 <ggVGc> as I figured
07:30:16 <ggVGc> thanks ghc
07:30:35 <ggVGc> it's pretty useful, but I always wondered how the hell it worked
07:38:50 <geekosaur> ggVGc, for Show and other language-specified derivings, it's documented in the Haskell Report. there are more magical ones in ghc.
07:43:43 <osfameron> hodapp, liste: yes, that seems to work fine - basically I make my initial change, and then wherever there is an error is the *next* thing to modify :-)  thanks
07:45:05 <liste> is there an autocomplete vim plugin using hdevtools?
07:47:27 <liste> couldn't find one with google
07:54:54 <jmcarthur> I wish GeneralizedNewtypeDeriving was not magical. If all it did was generate real code without cheating, we wouldn't need this complicated role system, and it would be easy to see why it fails when it fails, even if it failed more often than it does currently.
07:57:38 <hexagoxel> are the []-specific versions of stuff in Data.List to be removed entirely in the long run? it seems they are available as GHC.* modules currently.
07:58:21 <geekosaur> they were almost removed in the short run, GHC.List was a last minute insertion
07:58:47 <geekosaur> er OldList
08:01:02 <ggVGc> what I neve runderstood, is why head/tail/last (and maube others?) are impure
08:01:15 <ggVGc> what's the reasoning there?
08:01:38 <pavonia> They are partial, not impure
08:01:53 <hodapp> 'last' could also be impure if infinite recursion is considered a side effect, which it sometimes is.
08:02:04 <ggVGc> pavonia: thanks
08:02:07 <ggVGc> but my question still stands
08:02:23 <hodapp> I wouldn't call head/tail impure, I'd just call them partial.
08:02:46 <ggVGc> well, yeah, I have ther terminology wrong. but why are they partial?
08:03:26 <hodapp> > head []
08:03:28 <lambdabot>  *Exception: Prelude.head: empty list
08:03:31 <hodapp> > tail []
08:03:33 <lambdabot>  *Exception: Prelude.tail: empty list
08:04:52 <ggVGc> hodapp: my point is, why don't they return a Maube
08:05:07 <hodapp> because by definition, they do not.
08:05:20 <ggVGc> yes, but why. what's the reasoning for that definition
08:07:24 <hodapp> probably some combination of compatibility and the fact that versions that do return Maybe either already exist or are very easy to define.
08:07:29 <Cale> ggVGc: Because sometimes you know that the list is nonempty. For example, in map head . group . sort -- we know that any of the lists in the list produced by group are nonempty.
08:07:48 <Cale> and yeah, there are versions which produce Maybe values hanging around
08:08:41 <hodapp> also, most folks seem to prefer pattern matching on lists to using head & tail.
08:08:56 <Cale> Well, yeah, for the most part, you ought to be pattern matching.
08:09:15 <Cale> The head and tail functions are only for certain cases where you know for sure that you have a nonempty list.
08:09:51 <Cale> > ap zip tail [1..10] -- also safe
08:09:52 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
08:10:13 <Cale> > ap zip tail [] -- even if the list is empty
08:10:14 <lambdabot>  []
08:12:08 <Cale> In many cases, you'll want to write (\(x:xs) -> x) or (\(x:xs) -> xs) instead of head or tail though, especially if you expect, but you're not 100% sure that you'll always have a nonempty list,
08:12:18 <Cale> Those will give you a better error message in the case of failure.
08:12:57 <edkolev> Can someone let me know what arguments this function takes? I think it takes first argument list of functions, second argument - a list
08:12:59 <edkolev> combStep :: [a -> b] -> [a] -> [b]
08:13:16 <Cale> This is because you'll get the runtime pattern match failure that includes the place where the lambda occurs in your source code, rather than "Prelude.head: empty list"
08:13:30 <Cale> edkolev: that's correct
08:13:52 <edkolev> I see. Thanks!
08:20:01 <tomjaguarpaw> kosmikus_: Thanks!
08:24:22 <mniip> Cale, but CallStack
08:27:11 <hodapp> what about it?
08:44:32 <osfameron> what do people tend to use for Javascript layer for Snap apps?  I'm tempted by vuejs, but also interested in state of e.g. ghcjs
08:44:50 <osfameron> oops, mischan, meant to ask on #snapframework sorry
08:45:36 <Cale> osfameron: At Obsidian, we use reflex-dom
08:49:08 <osfameron> thanks.  what kind of thing do you build with it?
08:49:36 <osfameron> obsidian is https://obsidian.systems/ ?
08:51:03 <osfameron> reflex looks like a learning curve.  *bookmarks for later*
08:51:54 <Cale> osfameron: Yeah, there's quite a bit of a learning curve there, and we don't really have all the educational resources we'd like to yet.
08:53:05 <Cale> osfameron: We do web applications for a variety of clients (most of our current clients are unfortunately not listed on our marketing site, since we leave it up to them)
08:53:23 <Cale> osfameron: Reflex-dom is really quite nice to use once you get the hang of it though.
08:53:53 <osfameron> yeah.  FRP is something on my list of things to learn
08:54:49 <osfameron> but I think I should pace myself, so may not be for current-project ;-)
09:07:08 <fr3tz0r> function thinks a string inread by getLine is not the same as a string in a tuple even tho the shuold be equivalent
09:08:11 <fr3tz0r> why?
09:09:15 <lyxia> show us the code
09:10:58 <fr3tz0r> in main with io operations i read a string and pass as argument to a function that are in another module
09:11:23 <aweinstock> fr3tz0r: getLine is an (IO String) not a String, if you have a function f that takes a String as input you can do (fmap f getLine) to get its result in IO
09:12:26 <aweinstock> or in a do-block use "x <- getLine", and then use x as if it were a String inside the do-block
09:13:59 <danilo2> Hello guys! I've written about it yesterday and I thought I will write sometimes again, because if you're looking for really wise functional hackers, this is the best place to go :)
09:14:21 <danilo2> We've just released a funny programming language, that has dual - textual and visual representation that you can switch whenever you want to, a pretty advanced type checker currently supporting basic dependent types, its written in haskell and it will be shortly open source. We are looking for alpha testers and collaborators! :)  - luna-lang.org 
09:15:03 <danilo2> if you'll have any questions regarding the language, the alpha tester program or anything thats written in luna-lang.org , I would love to answer the questions here! :)
09:16:00 <Jinxit> that looks neat actually
09:16:48 <Toastier> @help
09:16:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:16:58 <Toastier> list
09:17:03 <Toastier> help list
09:17:05 <danilo2> Jinxit: thanks :)
09:17:19 <aweinstock> Toastier: all commands are prefixed with @
09:17:23 <Toastier> thanks
09:17:28 <Toastier> @help list
09:17:28 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
09:17:31 <Toastier> welp
09:17:32 <fr3tz0r> aweinstock: i do that in the do block but i also in the do block do func a x and then x does not equal first element of tuple which is a string
09:17:37 <Jinxit> you can also privately message lambdabot 
09:17:39 <Toastier> @list
09:17:40 <lambdabot> What module?  Try @listmodules for some ideas.
09:17:47 <aweinstock> also, do "/query lambdabot" to avoid spamming the main channel
09:18:12 <aweinstock> fr3tz0r: can you put the code you have so far on lpaste.net and link it here?
09:21:55 <obadz-> is the result that id is the only bottomless implementation with type signature forall a. a -> a someone in the wadler paper?
09:22:50 <obadz-> I can't find it
09:30:08 <mniip> you can probably prove it by yourself by induction on the lambda calculus syntax
09:31:02 <obadz> mniip: I certainly can't. Is that proof not online somewhere?
09:34:08 <lyxia> is there a way to tell "stack test" specific tests to run exclusively through the "detailed" interface?
09:34:46 <kadoban> lyxia: There's --test-arguments, is that enough?
09:35:02 <luigy> is that possible in cabal?
09:37:15 <shanemikel> why has there been so little interest in a functional shell?
09:39:13 <lyxia> kadoban: Do you know how that works? --help doesn't tell me much about it...
09:39:27 <lyxia> and it doesn't seem to do anything BTW
09:40:24 <kadoban> lyxia: It just forwards the arguments to the test-suite executable. Try --test-arguments "--help" maybe ?
09:40:40 <KaneTW> obadz: strictly speaking, that's not true
09:40:54 <KaneTW> :t id . id
09:40:55 <lambdabot> c -> c
09:41:16 <hodapp> shanemikel: functional shell?
09:41:23 <KaneTW> what you can prove however is that every term of type forall a. a -> a has normal form id
09:41:34 <shanemikel> shell, like bash
09:41:34 <obadz> KaneTW: id . id = id .. ?
09:41:45 <KaneTW> semantically, yes
09:41:47 <KaneTW> not syntactically
09:41:48 <hodapp> shanemikel: there are things like Shelly and Turtle...
09:42:14 <obadz> KaneTW: k I guess I mean semantically then
09:42:44 <obadz> :t f \ x -> do let y = x in x
09:42:45 <lambdabot> parse error on input ‘\’
09:42:51 <obadz> :t \ x -> do let y = x in x
09:42:53 <lambdabot> r -> r
09:42:57 <obadz> still id..
09:43:11 <shanemikel> oh, I remember seeing a link for each of those last night.. I knew I forgot something! thanks a bunch hodapp
09:43:13 <hodapp> shanemikel: but I suppose that in general, when it comes to things that one does on a shell, it's sort of in that "good enough" territory where as soon as it starts to involve more computations, richer data structures, or more safety-critical or reliability-critical things, it moves into a more general language
09:43:27 <KaneTW> it's still not id, but its normal form is id
09:43:39 <KaneTW> you can do a syntactic proof just fine
09:43:49 <hodapp> shanemikel: please let us know if you find anything interesting in this area though!
09:43:51 <obadz> ok so where is the proof for the semantic case?
09:44:06 <shanemikel> I'm playing with a shell called ES
09:44:12 <shanemikel> built it last night
09:44:16 <hodapp> link?
09:44:42 <shanemikel> http://web.mit.edu/~yandros/doc/es-usenix-winter93.html https://wryun.github.io/es-shell/
09:44:51 <hodapp> winter93 O_O
09:45:07 <shanemikel> yeah, like I said.. little interest :( but it built for me just fine
09:45:21 <lyxia> kadoban: Ah I think I got it. It seems I'm supposed to do more than "return" in defining "tests". Thanks!
09:45:27 <hodapp> I had talked to companion_cube over a somewhat similar matter
09:45:53 <shanemikel> lol, it's hard to search for 'turtle shell' and 'shelly shell'
09:46:01 <shanemikel> damn jokers
09:46:01 <hodapp> something like an embeddable subset of Haskell, lighter-weight but interpreted
09:46:19 <KaneTW> http://www.paultaylor.eu/stable/semsf.pdf
09:46:32 <hodapp> I was pondering that Hugs already has an interpreter for Haskell98 and it's written all in C
09:46:46 <KaneTW> 3.3
09:47:02 <hodapp> we were thinking of it more for a simple configuration language of sorts - but companion_cube suggested that it'd be usable too for a shell, I think
09:47:55 <shanemikel> I understand the good enough argument, but unix and linux people don't seem to follow that rule very closely at all.. people are using shell scripts for the whole init system, build systems, and all kinds of ugly stuff
09:48:30 <kadoban> lyxia: Cool
09:50:06 <hodapp> shanemikel: you might step into #haskell-embedded, though it's stretching the channel's purpose a bit
09:50:22 <hodapp> shanemikel: and yeah, shell scripts see all sorts of use for other stuff...
09:52:44 <hodapp> shanemikel: sivteck (who's around sometimes) was interested in something vaguely similar, I think.
09:53:55 <jmcarthur> obadz: Another way to go is to prove that there is exactly one bottomless value having that type. Since you already have the implementation, that would prove that (\a -> a) is the only value of type (a -> a).
09:55:05 <jmcarthur> obadz: There's probably some way to show that (forall a. a -> a) is isomorphic to () using the yoneda lemma.
09:58:08 <shanemikel> hodapp: the biggest issue, though, is there's not really any familiar notion of types that would make sense for a shell, that is, if you expect to use the *nix util ecosystem
09:58:22 <jmcarthur> obadz: The yoneda lemma is:  Functor f => (forall b . (a -> b) -> f b) ~ f a  ...  If a = () and f = Identity, you get  (forall b. (() -> b) -> Identity b) ~ Identity ()
09:58:35 <jmcarthur> obadz: (() -> b)  is isomorphic to  b
09:58:48 <shanemikel> and I don't know if using a language with haskell-like syntax would make sense without types
09:58:51 <jmcarthur> obadz: So you can simplify that to   (forall b. b -> b) ~ ()
09:59:24 <jmcarthur> obadz: So any bottomless value of type (forall b. b -> b) is isomorphic to ()
09:59:42 <jmcarthur> *to bottomless ()
10:00:27 <shanemikel> The only way I think you could type a shell in a meaningful way, is to consider arity (for calls) and the shape of stdout
10:00:39 <jmcarthur> obadz: Since there is only one value of type (), there must be only one value of type (forall b. b -> b).
10:01:51 <shanemikel> Idk, not really thought through, but I was thinking something like considering stdout as a [Vector k String]
10:02:39 <SrPx> Any good name for an infinite list enumerating all terms of a recursive datatype?
10:03:24 <monochrom> "the enumerator"
10:03:47 <SrPx> monochrom: but not the procedure, but the list itself?
10:04:01 <monochrom> since it also doesn't terminate, you could also consider: "the co-terminator"
10:04:09 <shanemikel> the set of whatever it is you're enumerating
10:04:12 <jmcarthur> SrPx: How large is the scope of this list?
10:04:12 <monochrom> what is the difference?
10:05:19 <monochrom> suppose I write this piece of code: "fix (\x -> 0 : x)". is that a piece of code or is it a list?
10:06:03 <jmcarthur> Yes.
10:06:05 <shanemikel> a piece of code until you try to evaluate something
10:06:20 <jmcarthur> shanemikel: It ceases to be code once evaluated?
10:06:25 <monochrom> the bane of lazy evaluation is that you can't distinguish code from value.
10:06:30 <hexagoxel> shanemikel: pm?
10:08:02 <bennofs> shanemikel: the universe?
10:08:30 <bennofs> SrPx*: the universe
10:11:53 <shanemikel> what's the universe
10:12:31 <bennofs> shanemikel: sorry, was addressed to SrPx's question
10:17:00 <SrPx> bennofs I like the universe name, I'll use it, thanks
10:17:10 <SrPx> jmcarthur what do you mean? 
10:17:19 <SrPx> It was for this list : http://lpaste.net/153007
10:19:29 <lyxia> SrPx: is that Haskell?
10:20:09 <SrPx> lyxia lambda calculus, a subset of haskell
10:21:05 <jmcarthur> SrPx: A good name for something depends on a number of factors, not just what it represents.
10:21:30 <lyxia> I mean, the syntax looked odd with the qualified LHSs and the indentation L11-13
10:21:31 <jmcarthur> SrPx: For example, if it will always be used in contexts where you know what the type of elements are, you perhaps don't need to include that in the name.
10:22:01 <jmcarthur> SrPx: If it's being defined in a where clause of just one function definition, you can probably omit a lot of information.
10:22:18 <jmcarthur> SrPx: If it's exported from a module that is meant to be imported unqualified, it probably needs a very descriptive name.
10:22:29 <jmcarthur> SrPx: And so on.
10:23:29 <SrPx> jmcarthur: fair enough :) I think Bits.universe looks good as long as I use universe for the same concept on other types
10:24:40 <SrPx> lyxia: implicit wheres, I hope it is readable 
10:24:52 <hodapp> shanemikel: might be worth trying to use Turtle for a bit and seeing what your experiences are like for 'normal' shell stuff.
10:26:15 <hodapp> shanemikel: just as the vagueness of what 'bits' mean in a computer doesn't much matter most of the time when you are dealing with types, perhaps it is similar with things like 'strings' and 'files' in the shell.
10:38:17 <schoppenhauer> hi. where can I find a complete definition of the Template Haskel `Exp` type?
10:39:20 <schoppenhauer> (I want to try to write a codewalker)
10:39:33 <d-snp> hi, if I use Filesystem.Path.FilePath (which is marked deprecated) because I feel Prelude.FilePath is retarded, will I regret it some day?
10:41:56 <d-snp> also, I sort of assumed Text is the better String, is that true or should I use something like the utf8-string package?
10:42:10 <castlelore> Haskell is Useless, says Simon Peyton Jones
10:42:14 <aweinstock> schoppenhauer: ":info Exp" in ghci (after importing Language.Haskell.TH) should show it to you
10:42:25 <kadoban> d-snp: Text is basically a better String, yeah.
10:43:06 <schoppenhauer> aweinstock: indeed. awsmthx!
10:43:16 <d-snp> kadoban: ok, so continuing on that idea, Filesystem.Path.FilePath would be a better FilePath right? :P
10:43:54 <kadoban> d-snp: Continuation on what idea?
10:44:46 <geekosaur> d-snp, do you have a problem with http://hackage.haskell.org/package/filepath ?
10:45:09 <kadoban> Something being deprecated means that whoever maintains it thinks it's not worth using. If you think you know better … I mean good luck I guess? Doesn't sound like a good idea though usually.
10:46:51 <d-snp> geekosaur: I don't, for some reason it doesn't come up if you google "haskell path dropExtension"
10:47:13 <d-snp> and Filesystem.Path doesn't mention what it's deprecated for
10:47:31 <geekosaur> if you look at the system-filepath module, the deprecation message tells you to use that package instead
10:47:39 <d-snp> hm
10:48:21 <geekosaur> (I don't trust google for API lookups, it will show you what people have linked to over time, not what is correct or appropriate or not-deprecated)
10:48:57 <nitrix> Using the `ekg` package for the first time today. Holy, crap.
10:49:13 <bennofs> d-snp: perhaps http://hackage.haskell.org/package/path could be an alterantive, maintained version to system-filepath ?
10:49:13 <bennofs> d-snp: [idk if that package is good though, haven't used it myself. at least it's not deprecrated]
10:49:23 <nitrix> It's the easiest thing to use, and yet so rewarding :)
10:50:36 <geekosaur> s/module/package/
10:53:24 <thomie> using haddock, how do I link to an identifier in another package?
10:58:14 <d-snp> it feels so good refactoring a project after you've spent months tinkering on it to get it working
10:58:40 <d-snp> I should market myself as a freelance refactorer :P
10:59:06 <d-snp> anyone got a boss that would pay to have a consultant come in and refactor? :P
11:00:14 <puregreen> “so you're saying we have to hire a specialist from outside just to *refactor* your code? you're fired”
11:01:40 <d-snp> you're bad at marketing me puregreen :P how about "So you're saying there's someone who will reduce our technical debt so our core development team can focus on creating business value?"
11:01:53 <d-snp> and you say yes, and he only costs $300 an hour
11:01:59 <d-snp> a bargain surely :D
11:02:05 <hsk3> When I do
11:02:05 <hsk3> data Foo a = Foo a deriving Show
11:02:06 <hsk3> it will not actually require a to be an instance of Show. Only if a happens to be an instance of Show will the whole Foo a be an instance of Show. I was not fully aware of this. Has this been a Haskell feature for a long time? It's purpose is to make things as flexible as possible, right?
11:07:52 <lyxia> yes
11:35:51 <orion> d-snp: Are you seriously $300/hr?
11:37:06 <Pennyw95> Hi guys, I've just started to read a haskell book name "Learn yourself a haskell" and I really don't get one thing...in this chapter the author compares two version of the addVectors function, and says that only the second one uses pattern matching but I really can't see why the first one doesn't, since it appear to provide the catch-all statement as well? http://learnyouahaskell.com/syntax-in-functions#pattern-matc
11:37:07 <Pennyw95> hing
11:37:10 <Pennyw95> http://learnyouahaskell.com/syntax-in-functions#pattern-matching
11:38:49 <orion> Pennyw95: He's saying that the second one is a pattern match which is a catch-all. He is making no claim about the catch-alliness of the first one.
11:39:31 <Pennyw95> My question is, is the first example addVectors a b = ... a pattern match too?
11:39:42 <orion> No, it's not.
11:41:12 <mauke> I'd say yes
11:41:15 <Pennyw95> Sorry if it sounds stupid but I really can't see the difference, they look just different ways of declaring tuples, with the 2nd one giving more options more tuples larger than 2
11:41:19 <MarcelineVQ> It is, it's just irrefutable, it will match anything
11:41:49 <Pennyw95> Then I guess one could say every function is a pattern match with only the catch-all statement?
11:41:49 <orion> I defer to MarcelineVQ.
11:43:29 <Pennyw95> and addVectors (x1,y1) (x2,y2) = ... is irrefutable too?
11:44:09 <MarcelineVQ> the x things are, (,) is a tuple constructor though so the tuples must be there
11:44:19 <MarcelineVQ> Pennyw95: here's some supplementary reading that may clarify things better than I could https://www.haskell.org/tutorial/patterns.html
11:44:45 <MarcelineVQ> *x/y things
11:45:18 <Pennyw95> Ok, I'll read that now....thank you for your help :)
11:45:20 <geekosaur> this is clearer when there are multiple constructors
11:45:36 <yamad> hm, but doesn't the type ensure that a and b are tuples in the first version?
11:45:36 <geekosaur> foo Nothing = ...; foo (Just x) = ...
11:45:50 <geekosaur> yamad, either could be bottom
11:45:55 <geekosaur> and patterns are strict
11:46:24 <geekosaur> so, "yes and no"
11:48:39 <geekosaur> also, patterns serve multiple purposes. they force lazy expressions to the extent that the constructor can be matched; you can use them to discriminate between those constructors if there is more than one; and you can "deconstruct" things (like tuples) to get at the values inside them
11:48:49 <geekosaur> you can also pattern match on those internals
11:49:35 <yamad> geekosaur: ah, thanks. that first part clears up what you meant by patterns are strict
11:49:55 <bennofs> &reconnnec
12:06:41 <jpll> inkscape
12:06:54 <jpll> sorry
12:25:47 <chad___> Not Haskell specific, but does anybody know of a good code for MIN-DOM-SET?
12:26:33 <chad___> I'm fine shelling out to some other solver with a thin Haskell wrapper.
12:27:25 <osfameron> MIN-DOM-SET?
12:27:50 <chad___> Smallest number of vertices such that their outgoing edges plus that set cover the entire graph.
12:28:12 <DogCat> is this NP-complete?
12:28:47 <chad___> Yes. It is NPC. https://en.wikipedia.org/wiki/Dominating_set
12:31:04 <DogCat> sorry, I just joined, what exactly are you trying to do?
12:32:51 <DogCat> http://networkx.github.io/documentation/latest/reference/algorithms.dominating.html
12:33:39 <DogCat> that said, I would look into approximation algorithms if you are trying to find a reliable solution
12:34:39 <DogCat> you should be able to covert this into another NP-complete problem, and use an approximation algorithm for that.
12:35:22 <lyxia> linear programming FTW!
12:38:35 * hackagebot autoexporter 0.1.0 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-0.1.0 (fozworth)
12:42:19 <chad___> Yeah. I could use an SMT solver. Just wondered if there was a code like there is with Cliquer for MAX-CLIQUE.
12:45:02 <dmj> cansis: ping
12:47:11 <DogCat> :chad__, I don't really follow the academic community using Haskell to solve algorithms, but can suggest "Pearls of Functional Algorithm Design" by Bird as a nice summary of good article from the journal, Functional Programming
12:47:13 <Cale_> chad___: I think maybe fgl has a solver for that...
12:48:35 * hackagebot autoexporter 0.1.1 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-0.1.1 (fozworth)
12:49:11 <chad___> Not interested in trying to roll my own MIN-DOM-SET, it would be far inferior to an optimized code already out there.
12:50:28 <Cale> Actually, I think I'm wrong, this looks like something different.
12:50:35 <hiptobecubic> Wiki just suggests just using a really straight forward greedy algo if you want to approximate
12:52:10 <hiptobecubic> i.e. select node which causes the largest number of new nodes to be dominated. Repeat until finished.
13:11:16 <Gurkenglas_> Has there been research on which examples those approximations behave badly on and whether they transform to pathological examples through the NPC-reductions to other problems?
13:13:47 <orion> Is it inefficient to do: ByteString.pack . show $ x -- where x is an Int64?
13:16:49 <puregreen> orion: if I remember correctly, show is actually not that slow (compared to read), but if you want a 100% fast solution, import Data.ByteString.Builder and do something like toStrict . toLazyByteString . int64Dec
13:17:20 <puregreen> I'll benchmark it, a sec
13:21:08 <puregreen> orion: the latter thing is 2× faster
13:21:21 <puregreen> 390ns vs 218ns
13:22:33 <orion> Wow, thank you!
13:23:08 <puregreen> but!
13:23:56 <puregreen> when the int is small (still Int64 but fits into Int32), performance becomes the same
13:24:19 <puregreen> and when I tried it with 1234, the Builder one was 2× slower
13:25:33 <orion> I'm converting values returned from epochTime.
13:27:20 <puregreen> okay, with current epoch (1456089940) it's the same (207 vs 196)
13:28:01 <puregreen> code (in case my benchmark is flawed and somebody would then point it out): http://lpaste.net/153019
13:29:52 <d-snp> I'm working with a library, and it has a bunch of these annoying types: withHostTargetMachine :: (TargetMachine -> IO a) -> ExceptT String IO a
13:30:05 <Lokathor> are there friendly libraries for reading a haskell source file and getting info about it? or are such things burried within GHC?
13:30:24 <jophish> Is it appropriate to release a package on hackage if it only works with ghc 8?
13:30:26 <d-snp> why doesn't it just give me  ExceptT String IO TargetMachine or whatever?
13:30:41 <jophish> I don't think it should be a problem
13:31:03 <Lokathor> jophish, if it says so in the cabal file and has all the correct versions and such, i don't see why not.
13:31:08 <d-snp> jophish: that's no problem as long as the cabal file says so
13:31:42 <jophish> cool beans
13:32:02 <d-snp> Lokathor: what I read about how the haskell compiler works, if there exists a nice interface I'd be pretty surprised
13:32:07 <lyxia> d-snp: It ensures TargetMachine doesn't escape some scope, so that withHostTargetMachine can do clean-up after you're done.
13:32:28 <Lokathor> d-snp, :(
13:32:32 <d-snp> lyxia: hmm ok that makes sense I guess
13:33:24 <d-snp> https://hackage.haskell.org/package/ghc-parser Lokathor 
13:33:30 <d-snp> but it does exist, so maybe it's ok :P
13:33:33 <lyxia> the alternative is that users don't forget to call the clean up code, which is less safe of course
13:34:39 <d-snp> yeah, I understand for the llvm interaction stuff, that loads up a llvm library and sets up a communication channel with it and such
13:34:57 <d-snp> but a targetmachine is just a structure that describes a compilation target
13:35:05 <d-snp> I don't get why there would be any need for cleaning up..
13:37:18 <EvanR> d-snp: lyxia also it doesnt really stop the TargetMachine from escaping
13:37:29 <EvanR> 100%
13:37:53 <lyxia> right
13:37:59 <d-snp> it's in an IO so I could put it in an mvar or something right?
13:38:22 <lyxia> but then you're more likely doing it on purpose
13:38:30 <EvanR> you can hide it in your trunk as you pass the border police
13:44:20 <d-snp> ah ain't it a beauty
13:44:20 <d-snp> generateObject ast = do
13:44:20 <d-snp> 	liftError $ LLT.withHostTargetMachine $ \tgm -> do
13:44:20 <d-snp> 		LLC.withContext $ \ctx ->
13:44:20 <d-snp> 			liftError $ LLM.withModuleFromAST ctx ast $ \m ->
13:44:23 <d-snp> 				liftError $ LLM.moduleObject tgm m
13:44:25 <d-snp> :P
13:44:43 <d-snp> the liftErrors really give it that extra touch :P
13:56:40 <hexagoxel> jophish: but if the ghc-8 release somehow breaks your package, you done goofed. to be pvp-compliant, you need to put ghc >=8 && <8. :D
13:56:44 <hexagoxel> (translate to base as appropriate)
13:57:48 <jmcarthur> @check \x -> not (x >= 8 && x < 8)
13:57:49 <lambdabot>  +++ OK, passed 100 tests.
14:02:24 <infinity0> is it possible to define fmap in terms of ap
14:02:41 <hexagoxel> @check let allowNewerBase=True in \x -> (x >= 8 && x < 8 || allowNewerBase)
14:02:43 <lambdabot>  +++ OK, passed 100 tests.
14:03:50 <jophish> Vulkan bindings anyone? https://gist.github.com/expipiplus1/ae536b5a50afda0c9e08
14:04:34 <hexagoxel> :exf "(Functor m, Monad m) => (m (a -> b) -> m a -> m b) -> ((a -> b) -> m a -> m b)"
14:04:34 <exferenceBot> \ f1 -> f1 . pure
14:07:05 <hexagoxel> :t ap . pure
14:07:06 <lambdabot> Monad m => (a -> b) -> m a -> m b
14:09:55 <tippeneinn> I'm a little over my head with the monad reader postgresql pool: http://lpaste.net/153023
14:09:56 <jmcarthur> jophish: There are at least three separate projects going on there.
14:12:14 <jophish> jmcarthur: huh?
14:13:13 <tippeneinn> I'm trying to get to runDb $ selectList [] [] with a global pool defined and read with the ReaderT
14:14:06 <jmcarthur> jophish: My use of the word "there" was really dumb. I just mean there are at least three separate repos by three different people for haskell vulkan bindings.
14:14:23 <jmcarthur> jophish: This one currently looks like it has the most progress though.
14:23:25 <jophish> jmcarthur: yeah, I think it's done to a first approximation 
14:23:43 <jophish> all the functionality is there, it's just bikeshedding the interface to do
14:23:46 <jophish> and inserting documentation
14:23:52 <jophish> and 32 bit support
14:31:01 <jophish> wow, this module takes much longer to compile with cabal build than ghc on its own...
14:31:35 <dcoutts> jophish: are you compiling with -O?
14:31:38 <dcoutts> cabal defaults to -O
14:32:34 <monochrom> for even moar optimization, set "optimization: 2"
14:32:52 <monochrom> > "two" > "true"
14:32:54 <lambdabot>  True
14:32:58 <monochrom> Haskell agrees :)
14:33:19 <jophish> dcoutts: yeah, setting it to -O0 in the .cabal file seems necessary
14:33:37 <dcoutts> jophish: no, don't do that, you just need to say: cabal build -O0
14:33:44 <dcoutts> jophish: or cabal configure -O0
14:35:27 <KaneTW> > "２" > "⊤"
14:35:29 <lambdabot>  True
14:35:59 <guy> > 1 + 1
14:36:01 <lambdabot>  2
14:36:15 <monochrom> the search for truth, pursued by two
14:36:22 <Fahr> > 1 + 2
14:36:23 <lambdabot>  3
14:36:26 <KaneTW> > "⊤" > "2"
14:36:27 <lambdabot>  True
14:43:56 * hackagebot vulkan 0.1.0.0 - Bindings to the Vulkan graphics API.  https://hackage.haskell.org/package/vulkan-0.1.0.0 (jophish)
14:55:31 <d-snp> nice work jophish :)
14:58:06 <jophish> d-snp: thanks! I'll get an example out tomorrow hopefully
15:00:03 <d-snp> fun, I've been meaning to check out Vulkan, I heard it's real arcane, with 200 lines for a triangle
15:00:10 <d-snp> which sounds awesome :D
15:03:12 <jophish> I think it's longer than 200, more like 1000 last I checked
15:04:04 * hackagebot octane 0.4.1 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.4.1 (fozworth)
15:05:00 <KaneTW> https://github.com/SaschaWillems/Vulkan/blob/master/triangle/triangle.cpp
15:05:02 <KaneTW> holy moly
15:06:39 <KaneTW> to be fair, "This example won't make use of helper functions or initializers (like the other examples) and is much more of an explicit example then the others included in this repository. It contains lot's of boiler plate that you'd usually encapsulate in helper functions and classes. 
15:12:35 <begriffs> I'm trying to debug an infinite loop caused somehow by my test suite. I enabled profiling but my .prof file always stays at 0 bytes. Is there a way to force the profiler to flush its incremental stats?
15:18:39 <hexagoxel> begriffs: iirc if you ctrl-c it writes the data. how do you stop the run currently?
15:18:53 <lyxia> begriffs: +RTS -xc gives you stack traces or something like that
15:19:15 <begriffs> hexagoxel: I press CTRL-C once but it doesn't die. I gave it like five minutes then CTRL-C'd it again.
15:19:25 <mgsloan> (but you need to have stuff built with profiling for +RTS -xc to work
15:19:49 <mgsloan> If you do "stack build --trace" you'll get stacktraces
15:21:05 <begriffs> @mgsloan I'll try the trace flag
15:21:05 <lambdabot> Unknown command, try @list
15:21:06 <hexagoxel> begriffs: sorry i don't know a different way (and there might very well be none).
15:22:15 <mgsloan> begriffs: Cool!  Note that you will need to pass in "+RTS -xc" on the commandline, but that's done automatically for tests and benchmarks
15:22:55 <mgsloan> It might be worthwhile to have "--trace" imply "--with-rtsopts -xc", but that seems a bit too magical
15:23:20 <mgsloan> (if this were the case then the built executable would generate -xc traces by default)
15:25:06 <hexagoxel> which makes sense, if you pass --trace when building (?)
15:26:25 <jophish> wow, with optimizations ghc takes 10 minutes to compile this one module
15:26:34 <jophish> with no template haskell or anything...
15:26:54 <jophish> What's the flag to see where it's spending its time?
15:28:04 <begriffs> @mgsloan OK I've got it outputting strack traces for exceptions happening during program execution, but I it still hangs with no output on first CTRL-C.
15:28:04 <lambdabot> Unknown command, try @list
15:28:31 <Axman6> jophish: what's the module got in it?
15:29:04 <hexagoxel> begriffs: "@" makes lambdabot feel important :p
15:29:11 <jophish> Axman6: this https://github.com/expipiplus1/vulkan/blob/master/src/Graphics/Vulkan.hs 6000 lines of fairly simple definitions 
15:29:35 * hackagebot activitystreams-aeson 0.2.0.2 - An interface to the ActivityStreams specification  https://hackage.haskell.org/package/activitystreams-aeson-0.2.0.2 (gdritter)
15:29:40 <begriffs> hexagoxel: just noticed it's name: not (at)name
15:29:46 <Axman6> yeah lots of definitions can make GHC pretty slow
15:29:47 <jophish> I don't even know what it could be optimizing in there aside from the Storable instances
15:30:18 <jophish> I'm sure I've seen before about non-linear slowdowns in the number of definitions in a module
15:30:28 <jophish> perhaps splitting this up into separate modules would help
15:32:35 <jophish> or perhaps I could improve it if I wrote the storable instances manually
15:33:41 <mgsloan> begriffs: Interesting! I think that can happen when it's in an uninterruptible block or FFI, or it's looping in the RTS
15:34:26 <begriffs> mgsloan: it does call out to postgres with ffi, so maybe I need to enable -threaded
15:41:24 <phasnox> \q
15:44:51 <tomus> I really like haskell - but I find it hard to justify using it for things. When I look for libs - there are just not there. How do you guys overcome the problem? Write stuff from scratch or ffi?
15:47:14 <jophish> tomus: I've found the library support on haskell to be pretty great for nearly everything I want to do
15:47:34 <jophish> But this is coming from a C++ background, I don't know how it might compare to Python or Perl
15:47:48 <tomus> what I do various quite a bit, but the last time I looked it was ML/data-sciency stuff
15:48:12 <tomus> data processing (csv) and stats algos - so I ended up with R and python
15:48:33 <tomus> before that I looked for simple gui, ended up with pyqt
15:50:55 <d-snp> tomus: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md <-- for an overview of what many people regard Haskell to be good at
15:51:25 <begriffs> mgsloan: -threaded doesn't help. :(
15:51:44 <d-snp> if haskell ranks "immature" or "bad" you're probably better off either implementing things yourself, or picking a different language
15:52:01 <d-snp> it's tough to bee the libs of python or perl or R for sciency stuff
15:52:08 <d-snp> s/bee/beat
15:52:25 <jle`> i do sciency stuff in haskell exclusively, but i'll admit that almost everything i use is built from the ground up
15:52:32 <mgsloan> There are some really cool math / stats libs out there in Haskell, but yeah, if you're going to compare to things like scipy, R's libs, matlab, etc, you're not going to find all the same stuff
15:52:32 <jle`> off of bare minamal GPU and linear algebra libraries
15:53:20 <jle`> one of my conscious efforts in doing all of my math/computation research in haskell is to show that haskell is viable, but i probably wouldn't be comfortable advising someone to learn haskell just to apply to sciency stuff out of the box
15:53:28 <emmanuel_erc> jle`: What type of science-type programs do you write in Haskell?
15:53:42 <mgsloan> Tons of people use and extend R / scipy / etc.  One effective approach is to just call out to R when you need to http://tweag.github.io/HaskellR/
15:54:19 <jle`> time series/data analysis, signal processing, image processing, ANN's, other ML stuff, cluster computing stuff, etc.
15:54:32 <emmanuel_erc> Are you a graduate student?
15:54:33 <jle`> haskell's a great tool with competitive speeds but almost everything i've done i've rolled from scratch, heh
15:54:34 <mgsloan> Native GUI is also a bit of a weakpoint, not because there aren't decent libraries for it, but there aren't very many "Haskelley" GUI libraries.
15:54:35 <jle`> yes
15:55:00 <mgsloan> Browser based UI is the way most folks go, and Haskell kicks ass at that
15:55:01 <emmanuel_erc> Cool... did you have the fortune of learning Haskell in college?
15:55:08 <emmanuel_erc> I mean undergraduate.
15:55:15 <jle`> i took a haskell class in undergrad, but only after i already knew it, heh
15:55:45 <jle`> or well, after i was already sorta proficient in it
15:55:49 <emmanuel_erc> Oh, yeah I somehow got caught with the Haskell bug when I was already in grad school (I actually learned it about a year ago).
15:55:55 <emmanuel_erc> I hope that doesn't bite me in the butt.
15:56:06 <tomus> jle`: even explarotary analysis?
15:56:08 <jle`> i first used it for numerical stuff actually, that was the reason i initially started using haskell
15:56:15 <tomus> just plotting histograms?
15:56:28 <tomus> I can imagine implementing an algo in haskell once I settle for it
15:56:40 <tomus> but before I know it I need to iterate through a couple
15:56:40 <jle`> there aren't any great "exploratory" platforms that make things as smooth as they would be in pyton, r, matlab, mathematica, etc.
15:57:25 <jle`> i use some libraries for 'exploratory' data analysis, but there's a lot of friction betwene the pieces, and i really only probably can do it because i'm already somewhat experienced
15:57:29 <emmanuel_erc> Was it difficult for to get used to lazy evaluation for numerical analysis? Was there any particular program or algorithm that made lazy evaluation easier for to comprehend?
15:57:47 <mgsloan> jle`: IHaskell looks like a pretty great shot at filling that gap
15:57:47 <emmanuel_erc> easier for you to*
15:57:55 <jle`> mgsloan: yea! :D i should try it out
15:58:14 <mgsloan> At least filling the UI part of the exploratory data analysis, not necessarily the library side
15:58:45 <jle`> emmanuel_erc: you sort of just start getting the hang of what should be strict and what shouldn't be
15:59:18 <Lokathor> jle`, with GHC 8, do you think  you'll use the Strict pragma much?
15:59:24 <jle`> i don't know
15:59:28 <jle`> i use laziness as much as i use strictness
15:59:40 <jle`> so i feel like Strict vs NoStrict it's still the same amount of thinking
15:59:51 <emmanuel_erc> I think that is what I am sort of experiencing now. I also just heavily lean on certain data structures to get the job done.
16:00:23 <emmanuel_erc> I think the Strict pragma is useful in some cases. I would probably only use it for very small modules.
16:00:34 <jle`> i can understand why people would want it
16:00:55 <emmanuel_erc> jle`: You wouldn't use it ?
16:01:19 <jle`> like i said, i take advantage of laziness just as often as i take advantage of strictness, so there really isn't too significant of an advantage for me
16:02:14 <jle`> laziness gives me improved space and time efficiency more often than it takes it away
16:06:30 <hodapp> jle`: I'd be interested in any references you have for data analysis, visualization, and so on in Haskell. I've mostly been using Python/SciPy/matplotlib, and some R for my machine learning class.
16:06:38 <hodapp> short version: I hate hate hate R.
16:08:37 <emmanuel_erc> hodapp: I never actually used R. Why the hate?
16:08:49 <hodapp> emmanuel_erc: it's just statistics-flavored MATLAB.
16:09:05 <jmcarthur> I can't see myself using Strict.
16:09:20 <hodapp> it's full of little corner cases that it does so that it's slightly easier to do certain things interactively, but that overall just make its behavior really annoying and vague
16:09:27 <jmcarthur> Strictness has always been something that I apply in a fine-grained manner.
16:09:37 <hodapp> coming from Haskell and even Python, I'm accustomed to being able to compose things how I want to, and R sort of destroys that
16:10:34 <tomus> R isn't a language per se
16:10:36 <tomus> it's a tool
16:11:00 <tomus> I see my statisctians love it
16:11:03 <hodapp> I don't recall anyone calling it a language
16:11:14 <tomus> they don't need to worry about programming at all
16:17:56 <Nublet> yo
16:18:47 <hodapp> hi
16:24:37 * hackagebot gore-and-ash-glfw 1.1.1.0 - Core module for Gore&Ash engine for GLFW input events  https://hackage.haskell.org/package/gore-and-ash-glfw-1.1.1.0 (NCrashed)
16:39:37 * hackagebot autoexporter 0.1.2 - Automatically re-export modules.  https://hackage.haskell.org/package/autoexporter-0.1.2 (fozworth)
16:43:49 <ij> Cabal's stuck on "preprocessing library" and the process runs on 99% CPU. What does it do and can I skip it? pkg: encoding
16:47:27 <glguy> The encoding package has a custom preprocessor defined
16:48:04 <glguy> I don't know what it does, but if it's getting stuck it's a bug in the encoding package
16:48:48 <nineonine> hey there !
16:49:01 <nineonine> q: how to get all maximum values from list ?
16:50:40 <lyxia> nineonine: get the maximum, filter.
16:51:19 <dfeuer> nineonine, what do you mean?
16:52:33 <begriffs> Is there a way to force ghc's profiler to flush its incremental stats? I've got a .prof file but it stays at 0 bytes.
16:52:43 <nineonine> [3,1,2,0,3,2,2,3] -> [3,3,3]
16:53:18 <nineonine> without read
16:53:25 <kadoban> Yeah, easiest way is in two passes like lyxia suggests. You can do it in one, but … probably not going to matter.
16:53:43 <dfeuer> nineonine, do you care about the possibility of distinct elements that compare ==?
16:54:10 <pavonia> kadoban: How can it be done in one pass?
16:54:27 <dfeuer> pavonia, in at least two ways :-). Can you come up with one?
16:55:21 <pavonia> dfeuer: Only with storing all read elements so far with their count in an array/map
16:55:42 <kadoban> Probably a decent exercise if you think about it for a few. If you can't figure it out I can give an answer. pavonia: Naw, you don't have to store all elements for sure.
16:56:15 <dfeuer> pavonia, assume first that == is true equality. Then, figure out how to avoid that assumption.
16:56:39 <Cale> begriffs: How are you running the program?
16:56:43 <dfeuer> Or the other way around.
16:57:08 <Cale> begriffs: Oh, I see, you want stats before the program actually finishes running?
16:57:17 <Cale> hmm
16:58:52 <Nublet> @pl \xs s -> ($s)
16:58:52 <lambdabot> const (flip id)
17:00:06 <Aleksejs> Hi, I need a code that would generate english-like words with 2-3 syllables and with given first character. Is there any package I can use?
17:00:23 <begriffs> Cale: exactly, a single CTRL-C won't stop the program and I never get any stats
17:01:33 <ij> glguy, grr, seems like there's not much I can do about that then.
17:01:43 <Nublet> @pl \s -> ($s)
17:01:43 <Cale> begriffs: You should definitely get stats when the program terminates normally though.
17:01:43 <lambdabot> flip id
17:02:14 <begriffs> Cale: I'm trying to debug an infinite loop of some kind. The program hangs and uses 100% cpu.
17:02:49 <Cale> I'm a little surprised that you don't get stats when you Ctrl-C out.
17:03:03 <Cale> Maybe the second Ctrl-C is actually sending a different signal or something.
17:08:20 <MarcelineVQ> dfeuer: That was a fun exercise :O
17:08:38 <dfeuer> MarcelineVQ, I'm glad you liked it.
17:08:54 <MarcelineVQ> I don't think​ I get your == hint though
17:09:32 <dfeuer> MarcelineVQ, well, there are two approaches. One of them uses counting (which requires the assumption that == is true equality) while the other does not.
17:09:47 <MarcelineVQ> Oh alright I see, I didn't count
17:10:14 <MarcelineVQ> Not explicilty at least
17:10:57 <dfeuer> Counting can potentially save a lot of memory (if there are many repetitions of the maximum).
17:11:54 <Nublet> @pl \s -> (flip map) [id, id] ($s)
17:11:54 <lambdabot> flip map [id, id] . flip id
17:14:06 <EvanR> true equality?
17:18:56 <Rotaerk> anyone here use yi as their main editor?
17:20:34 <letheed> question – could any one tell me why "hasLongerNumerator r = (length . show . numerator) r > (length . show . denominator) r" works but "hasLongerNumerator r = uncurry (>) $ (length . show) <$> (numerator r, denominator r)" fails to compile
17:22:24 <pavonia> :t uncurry
17:22:26 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:23:27 <pavonia> letheed: (<$>) for pairs only applies the function on the second argument
17:23:44 <pavonia> > succ <$> (10, 20)
17:23:45 <lambdabot>  (10,21)
17:24:52 <letheed> no (<$>) :: Functor f => (a -> b) -> f a -> f b
17:25:06 <letheed> <$> <=> fmap
17:25:13 <pavonia> Yes
17:25:52 <pavonia> It should compile though
17:26:29 <pavonia> :t \r -> uncurry (>) $ (length . show) <$> (numerator r, denominator r)
17:26:31 <lambdabot> Ratio Int -> Bool
17:26:43 <letheed> oww my bad I thought fmap would map both elements of the tuple
17:27:09 <EvanR> :t bimap
17:27:10 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
17:27:49 <letheed> Ah, thanks!
17:28:18 <EvanR> and if you had data Two a = Two a a, that could be a regular functor
17:30:05 <letheed> Ok, fmap is kinda confusing me here
17:33:45 <EvanR> letheed: fmap converts a function from a to b to a function from f a to f b
17:33:56 <Cale> letheed: The functor instance you're using with pairs is:
17:34:04 <Cale> instance Functor ((,) e) where
17:34:13 <Cale>   fmap f (x,y) = (x, f y)
17:34:41 <Cale> So, in general, we have fmap :: (a -> b) -> f a -> f b
17:34:49 <letheed> Yeah, just checked out the source code on hackage
17:34:51 <Cale> and here we're taking f = (,) e
17:34:59 <Cale> i.e. partially applied pair constructor
17:35:04 <EvanR> i.e. (e,)
17:35:13 <Cale> (if that were valid syntax)
17:35:29 <Cale> I guess we could say f t = (e, t)
17:35:30 <EvanR> or (e,_) ;)
17:35:32 <letheed> Because both elements of my tuple where of the same type I stupidly assumes fmap would map both elements
17:36:00 <Cale> Right, they might not be the same type in general, and the way it works, it can't actually know this
17:36:03 <v937xjd> Gerri
17:36:15 <letheed> Exactly
17:36:15 <v937xjd> Herro. 
17:36:41 <EvanR> letheed: but if it was the 1-type pair it would work
17:37:02 <Cale> You'll find that pairs often end up acting like containers of one element (which goes in the second component) with a "label" (that gets put in the first component).
17:37:20 <Cale> Even to the extent that the Foldable instance will tell you things like:
17:37:28 <Cale> > length (3,5)
17:37:30 <lambdabot>  1
17:37:58 <Welkin> :t ('a',)
17:38:01 <lambdabot> t -> (Char, t)
17:38:30 <EvanR> is pair foldable basically only so we have traverse it
17:38:38 <django_> anyone read this: http://www.stephendiehl.com/posts/production.html
17:38:47 <EvanR> so we can*
17:39:01 <Cale> Yeah, I don't think I've ever used its Foldable instance, but the Traversable instance has been quite valuable to me
17:39:10 <v937xjd> django_ yes
17:39:36 <django_> v937xjd, why should i learn haskell lol
17:39:39 <Cale> For a real-world example, in reflex-dom, we have:
17:39:43 <Welkin> django_: Unchained? Fett?
17:39:44 <letheed> thanks for the help :)
17:39:46 <Cale> performRequestsAsync :: (Traversable f, MonadWidget t m) => Event t (f XhrRequest) -> m (Event t (f XhrResponse))
17:39:49 <v937xjd> Good read. Nice to see a balanced view
17:39:53 <django_> Welkin, the movie lol
17:40:12 <v937xjd> django_: are you asking me?
17:40:17 <Cale> Basically, this thing takes an Event whose occurrences have XML HTTP requests in them
17:40:36 <Cale> and it gives you a widget that you can stick in a page, and its result will be an event whose occurrences have the responses
17:40:54 <Cale> But more generally than that, it lets you use any Traversable thing to contain the requests
17:41:22 <Cale> which it will traverse in order to put the responses in a similar container
17:41:38 <infinity0> is there a shortcut for (flip fmap) like $>= or something? i find it's quite convenient to do (m & fmap etc), was wondering if there was a shortcut for it
17:41:51 <EvanR> :t (<&>)
17:41:52 <Welkin> infinity0: <&>
17:41:52 <lambdabot> Functor f => f a -> (a -> b) -> f b
17:41:53 <Cale> So you can use f = (,) e in the case that you'd like the requests to be paired with some additional information so that you know which request each response goes with
17:42:03 <infinity0> ah nice thanks guys
17:42:09 <Welkin> infinity0: because & is flip . ($)
17:42:14 <Welkin> er
17:42:19 <Welkin> infinity0: because & is flip ($)
17:42:37 <infinity0> ah ok that's easy to remember
17:43:11 <EvanR> infinity0: probably more idiomatic to go the other way and use =<<
17:43:54 <infinity0> hmm yeah i'll play with it and see
17:43:58 <infinity0> where is <&> defined?
17:44:27 <EvanR> you havent defined it yet ;)
17:45:31 <EvanR> its in lens i think so just define it yourself
17:45:43 <infinity0> oh ok
17:48:21 <v937xjd> Neverending debates about forward or reverse composition being more natural..
17:48:36 <Welkin> it is?
17:48:39 <Welkin> I don't hear of it
17:48:43 <Welkin> just use whatever you want
17:48:53 <Welkin> I use both
17:49:12 <Welkin> oh, composition
17:49:23 <Welkin> thought you meant =<< and >>=
17:52:40 <infinity0> i think it's the same topic, i think EvanR meant i could avoid <&> if I did e.g. f4 =<< f3 <$> f2 =<< f1 <$> m or something like that
17:54:09 <v937xjd> Disconnected....
17:55:11 <v937xjd> Hey does the Frames library have an equivalent to fieldLabelModifier ?
17:55:24 <EvanR> infinity0: yurg... maybe if you redo the whole thing with <*>s
17:55:40 <Welkin> Cale: what kinds of interfaces have you built with ghcjs so far?
17:56:01 <Welkin> Cale: anything like a desktop application, or just standard web forms?
17:56:10 <v937xjd> all the generics trickery are for naught if I can't open more than one cab with the same column name
17:56:42 <v937xjd> Can = csv (trying to type on touchscreen here)
17:57:18 <Cale> Welkin: Pretty much just web stuff.
17:57:35 <Cale> Welkin: (all reflex-dom stuff)
17:57:39 <cheater> hey guys
17:57:59 <cheater> what is currently the best way to get ghc, cabal, and stack on a 32 bit ubuntu
17:58:09 <v937xjd> Hi cheater 
17:58:13 <cheater> my current installation of ghc is nuked
17:58:17 <Welkin> cheater: use stack
17:58:24 <cheater> i need to get it.
17:58:34 <v937xjd> Welkin 2nded
17:58:37 <mirpa> look on github, there should be link to repo
17:58:40 <Welkin> yeah, just install it, then use that to get ghc
17:58:49 <Cale> http://docs.haskellstack.org/en/stable/README/
17:58:53 <cheater> thanks
17:58:58 <Cale> There are instructions there
17:59:00 <v937xjd> Nobody else using frames?
17:59:19 <Welkin> v937xjd: no idea what that is
17:59:19 <cheater> not i sorry
17:59:53 <Cale> v937xjd: I haven't really -- mostly I would just use Cassava for CSV stuff.
18:00:34 <v937xjd> Cale yeah I feel like it's not there yet
18:00:48 <Cale> Frames does a bunch of crazy type level hackery, which might be cool in some cases, but mostly I think it would be overkill
18:01:20 <v937xjd> Deriving types is nice but then you try to open two csv files and get record name clashes and feel silly
18:01:36 <v937xjd> Also having to have data at compile time feels wrong..
18:01:36 <Cale> It seems oddly positioned -- usually if you were taking your data so seriously, you wouldn't be keeping it in CSV files, I would think.
18:02:27 <v937xjd> I think it's filling the R use cases or at least attempting tokik 
18:03:16 <v937xjd> But yeah probably a deeper rethink of how should data science stuff be done in Haskell is needed
18:03:53 <v937xjd> I've mostly moved to cassava myself
18:05:31 <v937xjd> One thing that's a bit of a bummer (coming from r) is the lack of some intelligence re inferring types from data. Like there has to be some middle ground between manually specifying records and strings for everything
18:05:51 <Cale> Oh?
18:06:40 <v937xjd> I don't know the right answer. 
18:06:52 <Cale> Types generally can't be inferred from data, because they don't exist at runtime.
18:07:00 <EvanR> i have to manually specify most types in excel anyway since it guesses wrong
18:07:02 <v937xjd> Maybe some pseudo dt sum type that
18:07:33 <Cale> But yeah, you can certainly define types which are quite general, like what's done with JSON
18:07:36 <v937xjd> Encompasses a few common types? It's a tricky design prob
18:07:54 <EvanR> string and int... instead of just string, done ;)
18:07:59 <EvanR> what did we accomplish really
18:09:04 <acertain> Type providers (in i think f# and idris) are nice, they can just guess by reading the data
18:09:29 <EvanR> and then youd have to fix the guesses
18:09:33 <acertain> You could do something similar with ghci/the ghc api
18:09:57 <v937xjd> A lot of data sciencey stuff has to rely on some data inferred types, at least for rough preliminary work because there are these datasets with hundreds or thousands of fields
18:10:18 <Cale> You might be able to do things with Template Haskell
18:10:28 <acertain> sure, but that's fine, you just have it guess and if parsing fails specify the type
18:10:35 <Ralith> having lots of fields doesn't mean the data doesn't have consistent types
18:10:47 <EvanR> if parsing fails / it guesses wrong
18:10:49 <Ralith> you only have to guess if it's all manually entered or you've somehow lost the schemas or something
18:11:00 <v937xjd> Cale which was the frames approach. They def need a fieldLabelModifier option though 
18:11:03 <Cale> Also, probably you don't want to be storing such things as simple records either.
18:11:10 <EvanR> yah you want control over the schema no matter how big it is
18:11:47 <v937xjd> Ralith: which is common. Lots of data analysis munching work is one off stuff
18:11:50 <Cale> Like, if there are so many fields, you'd immediately want to try to break that up into smaller data structures with more manageable numbers of related fields
18:12:04 <v937xjd> You can't count on having it prepackaged for you 
18:12:12 <Cale> (which isn't something that can really be done automatically, at least by computers today)
18:12:31 <Cale> and it probably depends a bunch on what you're doing with the data
18:12:31 <EvanR> you also cant count on it being auto packaged
18:12:57 <EvanR> you can count on manually curating a schema though
18:13:13 <EvanR> record types might not be the best method though
18:13:14 <v937xjd> Cale not necessarily for example you sometimes want to do clustering or automated statistical analysis
18:13:27 <Ralith> v937xjd: "one off" does not mean you've lost the schema or have very large quantities of corrupted data
18:15:33 <v937xjd> Ralith not always but in general a python or r person would be fine reading the csv file and working off a data inferred schema 
18:15:59 <v937xjd> I'm not sure if there's a Haskell alternative arm
18:16:12 <v937xjd> Writing records for subsets of the data isn't sufficient
18:17:52 <EvanR> v937xjd: i think it could benefit from a structural database language
18:17:54 <v937xjd> Yes data derived schema is kind of an 80/20 imperfect solution but there are times when it is needed
18:19:19 <v937xjd> EvanR what do you mean by 'it' - the task? R or Python? Haskell?
18:19:45 <Ralith> regardless, it's trivial to set up the kind of automation you want
18:19:52 <EvanR> v937xjd: the situation where you have a bunch of "raw" csv data and you want to munge it without a specific plan
18:19:58 <Ralith> you just need to be somewhat more explicit
18:20:09 <Ralith> in return you get much better fault tolerance and performance
18:20:16 <MitchellSalad> does anyone remember the name of the package that lets you write a main func like "Int -> IO ()" and it makes the appropriate command-line parser for you
18:20:25 <MitchellSalad> per the types of the arguments
18:21:48 <v937xjd> EvanR what is a structural database language? Sql?
18:22:17 <Cale> v937xjd: If the data actually matters, it might be worth organising it into some sort of database normal form in the first place, which would probably correspond more nicely to usable record types.
18:22:17 <EvanR> no
18:22:52 <EvanR> nosql
18:22:58 <EvanR> (and nomongo)
18:23:03 <EvanR> (and noeav)
18:25:30 <v937xjd> Cale well may go in that direction it's hard w data scientists and in their defense
18:25:56 <v937xjd> They're often expected to turnaround analyses on a several hour time scale
18:27:06 <v937xjd> EvanR: are you pulling my leg? Yet to find a concrete definition of nosql 
18:27:19 <Cale> (At least, it's hard for me to imagine how one would end up with hundreds of columns of varying types which still somehow satisfy 3NF... that's got to be somewhat rare. Maybe with really long surveys though...)
18:27:22 <EvanR> v937xjd: i was literally negating SQL ;)
18:28:30 <v937xjd> Oh then what's a positive example of a structural database language? I've never heard that term
18:28:42 <EvanR> Cale: yes badly organized data exists, and theres well organized data that has devolved into csv files
18:28:50 <Cale> A lot of "nosql" solutions actually go in the opposite direction of what I see as the solution to SQL's problems
18:29:02 <EvanR> v937xjd: i made it up... its vapor ware
18:29:19 <EvanR> but the problem youre describing gives me new input to chew on
18:29:33 <Cale> Really what we need are databases with *more* ability to express structure, not less.
18:29:40 <EvanR> right
18:29:51 <EvanR> sql doesnt do the best job at that
18:30:11 <EvanR> its actually pretty shitty for its original basis
18:30:17 <Cale> Especially sum typed columns, where you can say "this is Either a key of table A, or a key of table B (and we know which)"
18:31:00 <Cale> This is something which should have come out of relation theory to begin with, but it's especially jarring that it's missing when you start thinking about databases in a category theoretical way
18:31:24 <EvanR> yes relational algebra seems to be completely missing things
18:31:34 <Cale> Well, relational algebra isn't missing that
18:31:44 <EvanR> they have sum types?
18:31:48 <Cale> But all real-world databases are :P
18:31:58 <EvanR> they have any types ?
18:32:01 <v937xjd> Hmm well is there any tech that is useful here that's not sql?
18:32:20 <Cale> v937xjd: David Spivak is working on interesting things, but they're kind of embryonic.
18:32:22 <EvanR> v937xjd: well in the real world, there are OLAP systems
18:33:21 <EvanR> SQL stuff is concerned with real time data updates and sort of acceptable ability to do fast queries
18:33:25 <Cale> EvanR: Well, there are sets on which you're taking the relations, and it's possible to discuss what happens with disjoint unions.
18:33:35 <v937xjd> Hadn't heard of Olap much before
18:34:11 <v937xjd> Any particular software or Haskell library you'd recommend checking Out?
18:34:15 <EvanR> but OLAP is much better at looking at a static dataset from different angles
18:34:33 <EvanR> v937xjd: i think all the good software for this is not free, but ill get you some references
18:34:40 * hackagebot http2 1.5.0 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.5.0 (KazuYamamoto)
18:34:55 <v937xjd> Rats :/
18:35:14 <EvanR> another buzzword is business intelligence
18:36:19 <v937xjd> Evans yes but that can be basically anything
18:36:38 <v937xjd> I have been interested in using Postgres for more fluid workflows
18:36:59 <pavonia> For a type "data ParameterDefinition where ParameterDefinition :: ParameterType t => TaggedParameterDefinition t -> ParameterDefinition", is there a way to auto-derive a Show instance?
18:37:05 <v937xjd> But not quite sure of the right way to use it as such atm
18:38:52 <Cale> At Obsidian, we have a little project on the go which uses quasiquoters to reinterpret Haskell-ish syntax (using haskell-src-exts, but not handling all the cases...) into a more general category, and then the (presently somewhat hazy) vision is to have instances of Category and various subclasses for building queries on our database. So hopefully we'll end up with something where you can write stuff that looks at least
18:38:52 <Cale>  somewhat like Haskell, but gets translated into SQL which interacts with a Postgres DB. -- I'm not 100% sure how it's going to work, but Ryan has some ideas about it and Dan's been working on implementing it.
18:38:53 <EvanR> v937xjd: im trying to find the link to this VHS tape from 1990 which blew me away ;)
18:39:10 <orion> Is anyone familiar with how to use "parsed_" from pipes-parse with pipes-aeson?
18:39:26 <Cale> (I only started looking at what they've got the other day, and I've yet to really read it all)
18:40:10 <v937xjd> Cale aren't there already things like that?
18:40:49 <pavonia> The problem seems to be that 't' hasn't a Show instance in the definitio, but I'd rather like to avoid adding it there
18:41:09 <Cale> v937xjd: The closest thing I guess would be HaskellDB, but it doesn't quite go as far as this.
18:41:16 <v937xjd> In r there's dplyr which is a combinator edsl which can generate sql in the backend
18:41:33 <Cale> Oh, well, there are definitely things which generate SQL
18:41:45 <Cale> But not necessarily in quite this way :)
18:42:17 <Cale> If we can just beat groundhog/persistent, we'll be happy.
18:42:28 <v937xjd> I've seen similar Haskell edsl s too . Hmm interesting
18:43:00 <v937xjd> Seen/tried haxl?
18:43:16 <EvanR> dude its scary
18:43:41 <v937xjd> EvanR how so? 
18:43:44 <EvanR> trying to find history of data analysis products, you get 99% of people sounding like they know, and it goes back like 3 years
18:43:55 <EvanR> much less back to the 90s
18:44:24 <Cale> v937xjd: I have seen it, but haven't tried it.
18:44:42 <EvanR> v937xjd: for a modern version of what im talking about, there is a bug product called tableau
18:44:48 <EvanR> big product*
18:44:53 <EvanR> it has the OLAP cube thing going
18:45:34 <v937xjd> Gotta get some sleep 
18:45:53 <v937xjd> Evans thanks will check it Out 
18:46:12 <v937xjd> Kinda bummed there's not an oss solution
18:46:30 <EvanR> there are 7 open source things listed on the OLAP wikipedia page ive never heard of
18:47:02 <EvanR> youd think if it was worth anything there would be open source versions but ;)
18:47:05 <EvanR> you never know
19:14:16 <lethjakman> Hey, I'm having a hard time with a type signature
19:14:35 <Axman6> feel free to share the code on lpaste.com
19:14:36 <lethjakman> It's telling me that it can't deduce (MonadIO m0)
19:15:07 <lethjakman> So I tried to add it to a constraint, but I can't figure out how to notate it right
19:15:09 <lethjakman> https://gist.github.com/lethjakman/e596a7ce714aaaab6e89
19:15:14 <lethjakman> I'm not even quite sure I'm along the right track
19:15:41 <lethjakman> Axman6: Sorry, I was just trying to give a little info to the question instead of just posting code. 
19:15:56 <lethjakman> I'm getting error now
19:16:06 <lethjakman> But I was getting previous-error before adding , MonadIO master
19:16:31 <lethjakman> I think MonadIO needs to suggest (Rout Auth -> Route master), but I'm not sure how to do that
19:17:42 <Axman6> yeah 'master' is definitely not the right thing to have a MonadIO constraint applied to it, judging by the error
19:17:56 <lethjakman> Hmmm. 
19:18:03 <lethjakman> I've tried to continue with it a bit
19:18:17 <lethjakman> Do you think that's the right direction though?
19:19:09 <Axman6> well ' WidgetT master IO ()' definitely has a MonadIO instance... can you actually share the code it's complaining about? the loginForm code?
19:20:13 <lethjakman> Yeah, one moment
19:20:21 <Axman6> and all the code for login, if possible
19:20:55 <lethjakman> There are dispatches after that, but they're unrelated. 
19:20:59 <lethjakman> I can add it if you'd like though
19:21:00 <orion> Is there a good reason this function is of type Consumer' ByteString m () and not Consumer' ByteString m r?: http://hackage.haskell.org/package/pipes-bytestring-2.1.1/docs/src/Pipes-ByteString.html#stdout
19:21:01 <lethjakman> I just updated it. 
19:22:01 <Axman6> orion: IIRC all pipes which get composed need to be able to produce the same return value, and that's the only value stdout can return without knowing anything a priori
19:22:32 <Axman6>  MonadIO ((Route Auth -> Route master) -> WidgetT master ()) is almost certainly wrong
19:22:48 <lethjakman> Axman6: Oh, that was me messing with it. 
19:22:59 <lethjakman> It was just MonadIO master before that
19:23:01 <Axman6> I think WidgetT master _ () is probably more what you want
19:23:06 <lethjakman> Ooo
19:23:07 <lethjakman> I'll try
19:23:12 <lethjakman> Wait. Where?
19:23:14 <Axman6> give me a sec
19:23:17 <lethjakman> K
19:23:30 <lethjakman> Thank you 
19:23:48 <orion> Axman6: I'm in a predicament: I want to construct an Effect which pulls data off of a TCP socket, parses it with aeson, and prints it to stdout.
19:24:00 <orion> (forever)
19:24:44 <Axman6> I think you want something like: (RenderMessage master FormMessage, MonadIO m) => (Route Auth -> Route master) -> WidgetT master m (), and then any IO calls need to be called using liftIO $ <IO call>
19:25:24 <Axman6> actually, I think that will mean you need: (YesodAuthEmail m, MonadIO m) => AuthPlugin m
19:25:53 <orion> The way I envision doing this is: parsed_ decode clientReceiver >-> deserializeMessage >-> P.stdout, however that won't work because the return value for parsed_ is (Producer a m r), not (), which is what P.stdout expects.
19:26:31 <Axman6> hmm, i would have thought that would unify
19:26:38 <Axman6> r ~ ()
19:30:24 <lethjakman> Those both give me different errors. 
19:30:37 <lethjakman> MonadIO's type is wrong * instead of * -> *
19:30:48 <lethjakman> I can add it to the gist if that'd be helpful at all. 
19:31:39 <Axman6> sure
19:31:56 <Axman6> also, try leaving out the type signature of login and letting GHC infer it
19:33:22 <orion> Axman6: It won't typecheck. :(
19:33:31 <lethjakman> Axman6: https://gist.github.com/lethjakman/5eda503a10fe989e27f8
19:33:33 <lethjakman> I made a new one
19:33:43 <lethjakman> I'll post the error that leaves too. 
19:33:56 <lethjakman> I put it in a new gist because it got confusing...
19:35:09 <lethjakman> https://gist.github.com/lethjakman/e47467a8cc1b2bf0415d
19:35:12 <lethjakman> This is without any type signature
19:39:13 <squall> Hi, I have been trying to understand the Haskell Prelude and I'm confused about Alternative, it seems redundant as i could just use Monoid...
19:39:24 <squall> Can anyone help me understand this?
19:40:40 <EvanR> > Just 1 <> Nothing
19:40:41 <lambdabot>      No instance for (Show a0)
19:40:41 <lambdabot>        arising from a use of ‘show_M39728707156296336484612’
19:40:41 <lambdabot>      The type variable ‘a0’ is ambiguous
19:40:50 <EvanR> > Just 1 <> Nothing :: Maybe Int
19:40:52 <lambdabot>      No instance for (Monoid Int) arising from a use of ‘<>’
19:40:52 <lambdabot>      In the expression: Just 1 <> Nothing :: Maybe Int
19:41:00 <EvanR> nevermind!
19:41:11 <EvanR> squall: alternative instances are defined to use a different strategy, usually
19:41:30 <EvanR> there are many monoids out there
19:42:09 <squall> I thought this could be helpful; https://hackage.haskell.org/package/base-4.8.2.0/docs/src/Data.Monoid.html#Alt
19:42:11 <EvanR> and newtypes to switch between instances can get hairy
19:42:47 <squall> Oh so hence the name
19:42:49 <EvanR> Last and Alt being an example of using newtypes to switch between instances
19:43:56 <squall> So suppose I consider list, it's clearly a Monoid. But it also has an alternative instance...
19:44:25 <EvanR> > [True, True, False] <|> [False, False, True]
19:44:26 <lambdabot>  [True,True,False,False,False,True]
19:44:43 <EvanR> > [] <|> [False, False, True]
19:44:44 <lambdabot>  [False,False,True]
19:44:45 <Axman6> lethjakman: try: authEmail :: AuthPlugin (HandlerSite IO)
19:44:51 <EvanR> seems the same to me ;)
19:45:02 <squall> Exactly
19:45:12 <squall> Do I need MonadPlus?
19:45:26 <Axman6> squall: for some types, Monoid and Alternative have the same implementation, for some others, it's more clear that one as "And" semantics and one has "Or" semantics
19:45:56 <EvanR> > [True, True, False] <+> [False, False, True]
19:45:58 <lambdabot>      Ambiguous occurrence ‘<+>’
19:45:58 <lambdabot>      It could refer to either ‘Control.Arrow.<+>’,
19:45:58 <lambdabot>                               imported from ‘Control.Arrow’ at /tmp/mueval124...
19:46:16 <squall> Hmm, like a bimonad perhaps
19:46:26 <squall> Two directions to join
19:46:53 <squall> Two different associative functions and identities to fold with
19:47:13 <nshepperd> aside from the fact that Monoid and Alternative can sometimes behave differently, Alternative guarantees that you don't care what is 'contained'
19:47:38 <squall> But list Monoid instance has polymorphic type a
19:47:45 <nshepperd> it has more laws
19:47:59 <squall> True
19:48:25 <squall> But the type has no superclass constraint
19:48:30 <EvanR> there are laws now?
19:49:02 <squall> Alternative has weaker laws than MonadPlus
19:49:06 <nshepperd> Alternative has laws, yes
19:49:10 <squall> Which are those of Monoid
19:50:14 <nshepperd> oh, it has laws on some and many
19:50:53 <nshepperd> but of course there are also the free theorems because the methods are polymorphic in a
19:50:55 <squall> So in the case where only one binary operator exists, Alternative, and so also MonadPlus are superfluous?
19:51:38 <nshepperd> conceivably, yes
19:52:25 <squall> What are some and many?
19:52:46 <nshepperd> functions in the Alternative typeclass
19:52:49 <nshepperd> http://hackage.haskell.org/package/base-4.8.2.0/docs/Control-Applicative.html#t:Alternative
19:54:15 <squall> I don't understand; https://hackage.haskell.org/package/base-4.8.2.0/docs/src/GHC.Base.html#some
19:54:38 <lethjakman> Axman6: Should I have anything on login?
19:54:54 <geekosaur> squall: think of them as parser combinators
19:55:03 <squall> ??
19:55:22 <squall> Never dealt with parers
19:55:45 <squall> Parsers*
19:57:01 <nshepperd> squall: 'many' takes a parser that reads a single thing, and produces a parser that reads as many things as it can then returns all of them as a list
19:57:37 <squall> :t many
19:57:38 <lambdabot> Alternative f => f a -> f [a]
19:58:16 <squall> > many ['1']
19:58:20 <lambdabot>  mueval-core: Time limit exceeded
19:59:16 <nshepperd> I don't know if they really do anything useful on anything other than parsers
19:59:30 <dmj> > (==) <*> reverse $ [1..10]
19:59:32 <lambdabot>  False
19:59:40 <geekosaur> they don't, and that's something of a known gotcha
19:59:50 <squall> I still don't know what a parser is
20:00:33 <Clint> it's a thing that parses something
20:00:58 <geekosaur> so, an example that is in base is `read`
20:01:16 <squall> :t read
20:01:17 <lambdabot> Read a => String -> a
20:01:23 <geekosaur> which takes a String and parses out a value of a type specified by the requested result type
20:01:33 <geekosaur> > read "5" :: Int
20:01:35 <lambdabot>  5
20:01:39 <squall> > read "3" +1
20:01:41 <lambdabot>  4
20:01:51 <geekosaur> > read "5" :: Bool -- will fail
20:01:52 <lambdabot>  *Exception: Prelude.read: no parse
20:02:06 <squall> In some?
20:02:10 <geekosaur> (there's also reads, which gives you a bit more control)
20:02:11 <squall> Eg.
20:02:24 <squall> :t reads
20:02:25 <lambdabot> Read a => ReadS a
20:02:35 <squall> Lost
20:03:15 <EvanR> what does read have to do with many
20:03:19 <Clint> not much
20:03:50 <squall> It's a parser, many only works with parsers apparently
20:03:51 <geekosaur> squall asked what a parser was, I gave an example. I don't think read uses many or some, though
20:04:09 <nshepperd> many/some wouldn't work on read
20:04:12 <geekosaur> it does use Alternative IIRC
20:04:52 <squall> The question was when is Alternative not superfluous to Monoid
20:05:19 <geekosaur> when it uses a different monoid for the type
20:05:26 <squall> There are methods some and many, concerning parsers, which must be understood
20:05:32 <nshepperd> well, back to that question, Alternative is useful when you're writing typeclass instances
20:05:55 <nshepperd> you can write 'instance Alternative f => Foo f'
20:06:16 <nshepperd> you can't write 'instance (forall a. Monoid (f a)) => Foo f'
20:06:23 <squall> Why not instance Monoid (f a)?
20:06:25 <geekosaur> likewise, MonadPlus is "superfluous" but it sometimes uses a different monoid than the Monoid instance
20:06:49 <squall> We have instance Monoid [a]
20:07:26 <squall> Is that a special case?
20:07:30 <geekosaur> you can have only one Monoid instance for a type, but the type may have many different monoids. so the Monoid instance is given to one that is generally useful, but Alternative and MonadPlus may use different monoids
20:07:31 <nshepperd> squall: if you need it to work for *all* a, that won't work
20:07:51 <squall> What? It's in the prelude...
20:08:20 <nshepperd> squall: you're thinking of 'instance Blah => Monoid (f a)'
20:08:22 <nshepperd> that works
20:08:37 <squall> I don't see the difference
20:09:04 <squall> Oh, forall is like the opposite of a constraint?
20:09:29 <squall> Anyway, List is a fully polymorphic Monoid
20:09:31 <nshepperd> forall means 'for all'
20:09:37 <squall> Right...
20:09:54 <nshepperd> squall: the difference is what side of the => you are on
20:10:24 <squall> Aha
20:11:04 <squall> So I can't demand that (m a) is constrained
20:11:07 <nshepperd> squall: 'instance Blah f => Monoid (f a)' means "give me any f and a, and an instance for Blah f, and I will give you an instance for Monoid (f a)"
20:11:26 <squall> Such as for list
20:12:00 <squall> So why did we need Monoid (m a) => ¿
20:12:56 <squall> Oh alternative imposes that constraint
20:12:58 <squall> I see
20:13:04 <nshepperd> yes
20:13:31 <squall> Then the question it's when would we require this?
20:14:07 <squall> Since I can write a polymorphic Monoid instance
20:14:34 <squall> Like List's
20:16:16 <squall> Does that make sense?
20:18:14 <nshepperd> lots of cases
20:18:35 <nshepperd> for instance, when you want to use something as a functor at the same time as doing monoidy things
20:19:02 <pavonia> Could anyone help me with that Monad instance definition here? http://lpaste.net/504548620217876480  I don't know how to get the paramsB value into the final Builder value
20:19:19 <nshepperd> sure, you could write a function 'foo :: (Functor f, Monoid (f a)) => some type signature'
20:19:40 <nshepperd> but it's ugly to add a constraint on a that you don't need
20:20:03 <nshepperd> 'foo :: (Functor f, Alternative f) => some type signature' is more accurate
20:20:53 <squall> But a is not needed to see f a is a Monoid if I write a polymorphic Monoid  instance
20:21:11 <nshepperd> Plus, if you need the monoidy operations on multiple a, b, c.. you'd end up with 'foo :: (Functor f, Monoid (f a), Monoid (f b), Monoid (f c), ...) => ...'
20:21:23 <nshepperd> gross
20:21:25 <squall> Such as list
20:22:00 <nshepperd> squall: yes, but there's no way to state that in the type system that isn't a massive hack
20:22:07 <KaneTW> nshepperd: you don't need the functor context anymore in your signature
20:22:17 <squall> Do you understand? Like [a] is a Monoid
20:22:28 <KaneTW> since Alternative implies Applicative implies Functor
20:22:30 <squall> What!?
20:22:36 <squall> Hack?
20:22:48 <geekosaur> ?
20:22:52 <EvanR> hax
20:23:27 <samba1_> .
20:24:06 <geekosaur> why would it be a hack?
20:24:17 <squall> So while some kind 2 datatypes are Monoids for any supplied type, there is no way to describe these?
20:24:35 <nshepperd> squall: yes, you can't write 'foo :: (forall a. Monoid (f a)) => ...'
20:25:22 <squall> Ok I think i get it!
20:25:58 <squall> So calling [a] a Monoid is misleading
20:26:12 <squall> It should be Alternative
20:26:19 <squall> ?
20:27:51 <EvanR> what [a] is the free monoid!
20:27:55 <squall> Does that make sense?
20:28:16 <squall> EvanR, yes, hence my Year Long Confusion
20:28:20 <nshepperd> uhh... what's misleading here is eliding the 'forall's
20:29:17 <nshepperd> 'instance Monoid [a]' means that given any a, I can give you an instance of Monoid [a] for *that* a
20:29:57 <squall> Its coincidence that instance Monoid [a] works, to refer to this polymorphic requirement we must use Applicator
20:30:13 <squall> Applicative*
20:30:29 <EvanR> and also its the 1 instance for [A] (a=A)  (unless you allow evil overlapping instances)
20:30:41 <EvanR> 1 instance per type
20:30:50 <EvanR> at most
20:31:05 <squall> The class of all such polymorphic Monads who are Monoids is MonadPlus
20:32:23 <squall> Calling it a Monoid is misleading, it should not require the type parameter..
20:32:44 <squall> What am I trying to say?
20:33:00 <squall> You understand?
20:33:17 <EvanR> the class and instance statements have their own meaning in their own language
20:33:23 <EvanR> you might be using a different language in your head ;)
20:33:39 <nshepperd> [Int] is a Monoid, that's for sure
20:33:40 <xpera> I'm trying to get haskell-mode from melpa-stable but get this error File error: http://melpa-stable.milkbox.net/packages/haskell-mode-13.16.tar, Not found
20:33:50 <xpera> Do others get this toO?
20:34:08 <xpera> ^ in Emacs
20:34:19 <EvanR> squall: when you have a's in the class and instance statements, its not "polymorphism" like polymorphic function types
20:34:31 <EvanR> its sort of backwards
20:34:32 <squall> Oh
20:34:54 <squall> It's unconstrained type?
20:35:01 <Clint> xpera: 2016-02-21 21:34:32 ERROR 404: Not Found.
20:35:48 <EvanR> class (Functor a) => Monad a where means that if i have specific `a' and its a Monad, i can get a Functor instance
20:36:07 <squall> So should I use Monoid or Alternative for e.g. A Tree?
20:36:22 <EvanR> instance (Monoid a) => Monoid (Foo a) where means if i have a and its a Monoid, i can get a Monoid instance for Foo a
20:36:25 <EvanR> specific a's
20:36:34 <pavonia> Could anyone please have a look at http://lpaste.net/504548620217876480 ? I'm not even sure there is a Monad instance for that type
20:36:45 <KaneTW> monoid is a typeclass over kind *, alternative over * -> *
20:36:54 <KaneTW> they have different purposes
20:37:05 <xpera> Clint thanks -- next I need to figure out if it has already been reported and if it is a bad package or on melpa's end
20:37:06 <squall> Your first example you got the wrong way round?
20:37:16 <EvanR> no haskell's syntax is the wrong way around ;)
20:38:34 <squall> KaneTW the confusion stems from list being a monoid despite having kind *->*
20:38:39 <EvanR> when you write Monad instances you are guaranteed to be able to use the Functor methods
20:38:52 <EvanR> for that type
20:38:54 <Axman6> pavonia: yeah that looks like it's not possible the way you currently have it
20:39:04 <KaneTW> squall: list isn't a monoid. more specifically, [] isn't a monoid
20:39:07 <EvanR> squall: [A] for some A is not *->*
20:39:08 <KaneTW> [a] :: * is a monoid
20:39:13 <squall> Your second example is opposite to your first...
20:39:17 <KaneTW> not [] :: * -> *
20:39:32 <pavonia> Axman6: Bah. Any idea how I could rewrite it?
20:39:38 <xpera> Clint: looks like 13.18 is the latest stable on http://stable.melpa.org/#/haskell-mode
20:39:45 <squall> Yes that was my pont Kane
20:39:47 <xpera> maybe I need a package refresh
20:39:55 <squall> Point*
20:40:08 <EvanR> squall: yeah be careful when identifying what kind something is
20:40:14 <EvanR> [Int] is a *
20:40:57 <squall> instance Applicative m => Monoid (m a)
20:41:06 <EvanR> m a is a *
20:41:07 <squall> Why not?
20:41:27 <xpera> yup, M-x package-refresh did it
20:41:43 <EvanR> why not what
20:41:55 <squall> Ok sorry I should have Said list of a above
20:42:24 <squall> Why not the generic instance I just gave
20:42:26 <EvanR> well you cant have two different instances for Monoid [A]
20:42:32 <EvanR> you have to pick
20:42:40 <EvanR> or they will overlap
20:43:14 <nshepperd> did you mean Alternative there?
20:43:32 <nshepperd> 'instance Alternative m => Monoid (m a)' is certainly a possible instance
20:43:43 <squall> Aha, so I would solve my confusion writing the generic instance and using the overlapping instances extension?
20:43:49 <nshepperd> but it would overlap and break all other Monoid instances and be generally annoying
20:43:52 <nshepperd> no, don't do that
20:43:54 <EvanR> you can but overlapping is bad
20:44:01 <squall> I meant alternative yes sorry
20:44:16 <squall> But at least it would make sense
20:44:26 <EvanR> it makes sense, more sense actually, without overlaping ;)
20:45:03 <squall> It's the same, so the overlap isn't problematic
20:45:15 <nshepperd> it's not the same, not always
20:45:25 <EvanR> but you also allow overlapping globally
20:45:30 <squall> Right hence the name Alternative
20:45:42 <EvanR> even if you can ensure sameness for some of the cases
20:46:15 <squall> But in cases where they are the same we have excessive repetition and confusion
20:46:43 <squall> Eg taking about list of a being a Monoid when really we mean list is MonadPlus
20:46:54 <EvanR> youre suggesting repetition and confusion!
20:47:06 <squall> ...
20:47:09 <nshepperd> what's your actual problem?
20:47:30 <nshepperd> there's nothing wrong with using lists as monoids
20:47:37 <nshepperd> or using lists as Alternatives
20:47:38 <EvanR> you want to be able to access the monad plus instance using monoid methods?
20:47:39 <squall> Referring to list of a as a Monoid
20:47:53 <nshepperd> just use whichever one is relevant in context
20:48:22 <squall> I want minimal informative superclass structure
20:48:25 <EvanR> Monoid is the more sensible description of whats going on, these others are weird things
20:48:45 <EvanR> we just dont have enough namespace real estate for all the different kinds of monoids
20:49:12 <EvanR> and MonadPlus is kind of historical baggage
20:50:17 <EvanR> squall: let me direct you, probably to your horror, to the superclass structure of numbers ;)
20:50:32 <EvanR> figure that out pls and get back to me
20:50:35 <ggVGc> Is there any currently valid work compiling GHC Core to ansi C, to easily integrate with an existing C code base_
20:50:38 <ggVGc> ?
20:51:26 <squall> Not so even, opposite even. It's by chance that we don't need any properties of 'a' in Instance Monoid [a] which actually stems from the fact [] is a MonadPlus. It's a specific application of the generic instance I gave
20:51:44 <EvanR> what no
20:51:48 <squall> Yes
20:51:50 <nshepperd> squall: Monoid and Alternative are really different things, and shouldn't be mixed up like that
20:52:10 <squall> !? No!
20:52:12 <EvanR> the more obvious and common monoid for "list over some alphabet" is concat
20:52:18 <EvanR> most obvious*
20:52:28 <EvanR> so thats what it is, and it doesnt matter what the alphabet is
20:52:56 <EvanR> not much to do with Monads or MonadPlus
20:52:59 <nshepperd> you certainly don't need to know about monads or applicatives to invent concatenation
20:53:20 <squall> We don't use properties of the type parameter, so its Alternative
20:53:38 <squall> Firstly it's a Functor
20:53:56 <EvanR> its a functor, which is independent, and its a monoid, which is also independent
20:53:56 <nshepperd> so it's *also* Alternative
20:54:05 <squall> No
20:54:14 <squall> It's firstly alternative
20:54:28 <EvanR> what is this ordering of type classes xD
20:54:35 <squall> Then instance Alternative m => Monoid (m a)
20:54:50 <squall> There it's a big big
20:54:55 <squall> Bug
20:55:22 <EvanR> since nothing i use is alterantive, i guess i wouldnt be affected by that
20:55:49 <EvanR> i do instance Monoid a => Monoid (F a)
20:55:58 <squall> That I can write a generic Monoid instance for all MonadPlus means list of a is refered to as monoid
20:56:57 <EvanR> i still dont get the point of doing what you said, but im out ;)
20:57:25 <squall> Whereas the asociative operation does not require anything of the type a
20:59:07 <squall> You dont want me to write Alternative m => Monoid (m a), but it's ok to refer to [a] as a Monoid. It's contradictory
20:59:40 <nshepperd> 'instance Alternative m => Monoid (m a)' breaks Sum and Product
20:59:59 <nshepperd> which have instances that look like 'instance Num a => Monoid (Sum a)'
21:01:25 <kadoban> squall: I think a lot of the seeming confusing here would be cleared up by using some common Alternative and Monoid instances and seeing how they act. It becomes a lot clearer with some experience with them.
21:02:48 <squall> I understand that but "List is a MonadPlus" is less desructive than "List of a is a Monoid"
21:03:16 <Clint> wat
21:03:33 <squall> I'm not behind,  I know the examples you mention
21:03:37 <dfeuer> Am I missing something, or is the overlapping instance mechanism more eager to conclude that two types are not equal than the type family mechanism is?
21:04:39 <EvanR> how is it less destructive
21:05:12 <squall> It alleviates the forall discussion above
21:05:35 <EvanR> i dont think foralls enter into this?
21:05:51 <EvanR> you dont write foralls in contexts
21:06:08 <dfeuer> It looks like the OverlappingInstance mechanism is happy to conclude that  x is never equal to (x,y), while type families don't assume that.
21:06:19 <squall> I can't write instance Monoid (m a) =>
21:06:29 <squall> That business
21:06:52 <EvanR> you cant? (with FlexibleContexts?)
21:07:57 <squall> So, to conclude, if i have only one binary operator, I should avoid Alternative and MonadPlus, and instead write instance Monoid (m a)?
21:08:19 <squall> Like list
21:08:26 <Cale> er, what?
21:08:27 <EvanR> especially if m is not even Monad or Applicative
21:08:27 <Clint> why are you choosing only one class to write an instance for
21:08:49 <squall> It's Monad sure
21:08:57 <EvanR> then you have more than 1 binary op xD
21:09:21 <squall> !?
21:09:28 <Cale> Alternative/MonadPlus are for applicative functors/monads which create monoids
21:09:41 <squall> Yes
21:09:50 <nshepperd> squall: no, you should just use whichever of Alternative or Monoid are relevant to whatever you are doing
21:09:56 <nshepperd> which will be obvious in context
21:10:14 <nshepperd> uh, when you actually use the instances
21:10:19 <squall> I have a monad which can be grown so it's a Monoid, or rather, a MonadPlus
21:10:30 <nshepperd> when writing instances you should write both, if they are applicable
21:11:10 <squall> Obvious as for all inferred instances like fmapdefault
21:11:13 <nshepperd> don't overthink it
21:11:13 <fortress_> hello, how can I install Data.Text.Lazy?
21:11:26 <fortress_> I'm getting "module not found"
21:11:52 <kadoban> fortress_: It's from the 'text' package. Is there more to the error? How are you building, or in what context is this?
21:11:58 <squall> I will understand it I'm afraid, please don't discourage understanding in those seeking it
21:12:31 <kadoban> Who is discouraging your understanding? I just see a bunch of people trying to help you understand.
21:13:03 <fortress_> kadoban: it's... it's some automated testing app that my prof sent us to pre-test our assignment submission versus some common errors.
21:13:14 <fortress_> I can't compile it because of that "module not found"
21:13:35 <kadoban> fortress_: Is there more to the error? How are you building it?
21:13:50 <fortress_> ghc -main-is ApocCheckerMini ApocCheckerMini
21:13:59 <fortress_> i'll pastebin the error
21:14:08 <Clint> fortress_: depends how you install things.. perhaps `cabal install text` or `apt-get install libghc-text-dev`
21:14:22 <squall> It seems that in the case of List, the structure of the Monad,  regardless of the type parameter, defines the binary operator (e.g. (++)). That it's a Monoid follows from that it's Alternative
21:14:32 <fortress_> http://pastebin.com/uFCafP6z
21:14:59 <fortress_> Clint: thanks I'll try that. I'm on Debian testing and just installed Haskell from the repos
21:15:10 <squall> The kind 2 superclass being more general
21:15:25 <fortress_> Clint: I was missing that package! I'll try now
21:15:33 <squall> Does no one understand what I'm geting at?
21:15:44 <kadoban> fortress_: You should usually use a build tool, like 'stack' once you get serious, though yeah the stuff from the package manager should solve the immediate problem at least.
21:15:54 <Cale> squall: I mean, sure. The Alternative instance for [] matches the Monoid instance for [a]
21:15:56 <EvanR> kind *->* isnt more general, its totally separate from *
21:16:01 <dfeuer> Either that or overlapping instances excludes the middle ... but that seems most unlikely.
21:16:13 <Cale> squall: What was the question again? :)
21:16:35 <squall> I wrote it like 10 times
21:16:36 <Cale> squall: If it's why there aren't totally generic instances, the general rule about instances is that they should match some concrete type constructor somewhere so that instance resolution can make progress.
21:17:03 <squall> No
21:17:03 <fortress_> kadoban, Clint: problem solved! thank you very much, and kadoban I appreciate the suggestion, I do plan to continue studying Haskell on my own after this class
21:17:26 <EvanR> squall is suggesting that the monoid instance for [] be changed to be dependent on the Alternative instance instead of standing alone
21:17:32 <EvanR> for [a] rather
21:17:43 <squall> Why call list Monoid, that's the result of the fact it's MonadPlus
21:18:04 <EvanR> or the MonadPlus instance, its changing back and forth
21:18:05 <Cale> squall: [a] is a Monoid -- that instance is rather important
21:18:11 <nshepperd> because it's both?
21:18:26 <Cale> squall: There's code which is generalised over a choice of Monoid
21:18:31 <squall> The observation that a MonadPlus with a type parameter applied is a Monad is redundant
21:18:46 <nshepperd> you question is like asking why we say x is 4, when that's a result of the fact that x = 2+2
21:18:47 <Cale> squall: which won't work just because you have an Alternative or whatever, unless you use a newtype wrapper.
21:20:20 <geppettodivacin> From what I understand, Monoid, MonadPlus, and Alternative have three very different meanings, even though they are implemented the same in List. Is that correct?
21:20:28 <squall> Ok, it needs the Monoid instance sure, as does my MonadPlus
21:21:30 <squall> Also the list in the type of concat should be Foldable m not list
21:21:45 <squall> :t concat
21:21:46 <lambdabot> Foldable t => t [a] -> [a]
21:22:01 <squall> :t mconcat
21:22:02 <lambdabot> Monoid a => [a] -> a
21:22:11 <nshepperd> :t fold -- looking for this?
21:22:12 <lambdabot> (Foldable t, Monoid m) => t m -> m
21:22:16 <squall> Nope
21:22:29 <Cale> hm?
21:22:48 <Cale> fold is pretty clearly exactly what you're looking for
21:23:01 <Cale> isn't it?
21:23:21 <squall> mconcat :: (Foldable m, Monoid a) => m a -> a
21:23:28 <Cale> If you wanted the list in the type of mconcat to be an arbitrary Foldable... that's already part of the definition of a Foldable
21:23:47 <squall> mconcat = fold, yes sorry
21:24:43 <squall> can fromList be used to generalise this?
21:25:10 <squall> To extend mconcat to other containers
21:25:22 <Cale> toList can.
21:25:34 <squall> :t toList
21:25:35 <lambdabot>     Ambiguous occurrence ‘toList’
21:25:36 <lambdabot>     It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.toList’,
21:25:36 <lambdabot>                              imported from ‘Lambdabot.Plugin.Haskell.Eval.Trusted’ at /home/lambda/.lambdabot/State/L.hs:125:1-59
21:25:39 <Cale> heh
21:25:46 <squall> ...
21:25:50 <Cale> :t Data.Foldable.toList
21:25:51 <lambdabot> Foldable t => t a -> [a]
21:26:27 <squall> :t concat.Data.Foldable.toList
21:26:31 <lambdabot> Foldable t => t [a] -> [a]
21:26:52 <Cale> :t mconcat . Data.Foldable.toList
21:26:54 <lambdabot> (Foldable t, Monoid c) => t c -> c
21:26:59 <Cale> :t fold
21:27:00 <lambdabot> (Foldable t, Monoid m) => t m -> m
21:27:10 <squall> Great
21:27:53 <squall> Its just strange there is no Foldable contraint to Monoid
21:27:59 <Cale> huh?
21:28:13 <squall> And it uses a Monoid as a container
21:28:19 <squall> []
21:28:29 <Cale> You mean mconcat does?
21:28:31 <squall> It can be more general
21:28:36 <squall> Yeah mconcat
21:28:43 <nshepperd> you sound confused
21:28:44 <Cale> Really mconcat is just this extra nonessential thing
21:28:47 <squall> Should be over all foldables
21:28:58 <squall> It should be removed
21:29:01 <Cale> mempty/mappend are all you really have to define
21:29:14 <squall> It's a fold, it belongs in fold
21:29:28 <Cale> mconcat is just there because if want to define it instead, the mempty/mappend are easily obtained from it
21:29:33 <Cale> mempty = mconcat []
21:29:41 <Cale> mappend x y = mconcat [x,y]
21:29:43 <glguy> mconcat is in the Monoid class because in some cases it can be more efficiently implemented for certain Monoid instances
21:29:50 <squall> Nice Cake
21:29:55 <squall> Cale*
21:30:07 <glguy> mconcat can't work for all Foldables because it's not part of (and can't be) the Foldable class
21:30:09 <nshepperd> oh, in the Monoid type class, yeah it's there for efficiency
21:30:50 <dfeuer> GRRR...
21:30:54 <squall> It's considered a misfearure by m e
21:31:01 <dfeuer> This is really annoying.
21:31:09 <Cale> squall: Misfeature in what way?
21:31:34 <squall> It's for all foldable containers, not just list
21:31:52 <EvanR> squall: can you please lpaste the updated collection of instances you are suggesting, the alternative list monoid, and the monoid foldable
21:32:01 <squall> I can see how foldable allows us to generate a list, but that's coincidence
21:32:13 <EvanR> and class definitions, if any
21:32:21 <EvanR> just their headers would be fine
21:32:30 <Cale> squall: There's fold in Foldable if you want all Foldables. Lists are pretty special though.
21:32:35 <squall> Ok, so no I can't do that but I might one day
21:32:55 <squall> I guess it's someone elses job atm
21:33:05 <EvanR> i see
21:33:18 <squall> I might lose my job
21:33:23 <Cale> squall: You can think of lists as being loops that are waiting to happen. They ought to have some special treatment in Haskell for the same reason that loops are given special treatment over other forms of recursion in most languages.
21:33:30 <squall> (It's hackriledge btw)
21:34:12 <EvanR> Cale: interesting opinion, which i never followed up on to get more justification about
21:34:26 <ggVGc> I just posted this to the Elm mainling list. Any thoughts from around here? https://groups.google.com/forum/#!topic/elm-discuss/6KswgCWmwdc
21:34:27 <squall> Lists are the free Monoid, it does not make sense to use them within the Monoid class definition
21:34:29 <ggVGc> is the idea sound?
21:34:45 <Cale> squall: That's precisely *why* it makes sense to use them in the Monoid class definition.
21:35:39 <squall> Right... Why not just demand they be Foldable, since that's the property of list being used?
21:36:05 <Cale> squall: For any monoid (M,*,1), there is a homomorphism from the free monoid on the set M to the monoid M itself, and mconcat is that homomorphism.
21:36:06 <nshepperd> squall: it's in there for efficiency
21:36:21 <squall> It's obfuscating
21:36:28 <Cale> It's not just there for efficiency, it's also the more holistic way of defining what a monoid is.
21:36:50 <Cale> i.e. a monoid is a list monad algebra
21:37:00 <nshepperd> and no, those definitions do not normally use the Foldable methods
21:37:01 <Cale> and mconcat is the evaluation map
21:37:24 <dfeuer> Ping goldfire 
21:38:01 <nshepperd> since that would be a circular definition and spin forever, unless you used some wrapper newtype with a custom Monoid definition that *didn't* use the Foldable methods
21:38:05 <squall> But why use the free Monoid, rather than the more generic structure, foldable, which actually captures the mechanism used?
21:38:36 <EvanR> Cale: hes got a point that it could be generalized if it wasnt for efficiency, because we in haskell have somehow decided that Foldable is the new list ;)
21:38:53 <Cale> Yeah, I kind of hate Foldable tbh
21:38:57 <Cale> I see the need for it
21:38:58 <EvanR> yeah
21:39:02 <Cale> But it doesn't stop me from hating it
21:39:12 <johnw> Cale: what do you hate, the lawlessness of it?
21:39:22 <squall> Hmm, at least I'm getting to the bottom of the rationality perpetuating this
21:39:25 <Cale> johnw: kinda, but that's really just part of it
21:39:31 <johnw> what's the other part?
21:39:44 <Cale> johnw: It's helping people fail to see something important about lists.
21:39:48 <dfeuer> I think the mistake was in deciding to allow Data.Foldable to be imported unqualified, rather than just moving Foldable (foldMap) to the Prelude.
21:39:55 <Cale> It's really more of a cultural thing
21:40:01 <EvanR> there are plenty of data structures isomorphic to the list structure
21:40:06 <Cale> It's hard for me to explain :)
21:40:08 <squall> Foldable is second after Functor, map and fold being the generic programming patterns at the heart of most computation
21:40:10 <EvanR> would be cool if they were optimized 
21:40:15 <johnw> Cale: I'm eager to know, if you can find the words
21:40:43 <Cale> johnw: Polymorphic data structures can be universal in their own ways, and lists are no exception there.
21:40:50 <geppettodivacin> squall: It's easier to optimize code that the compiler knows will always be a list.
21:40:52 <EvanR> it would also be cool if we could get away from lists for nearly all problems, like in the lambda CCC conal video
21:41:03 <geppettodivacin> So by making it a list, you can make it faster.
21:41:08 <EvanR> though they is in the context of parallel hardware
21:41:08 <Cale> Lists perfectly express the notion of iterating over a sequence of things -- i.e. like I said, they're loops waiting to happen
21:41:09 <geppettodivacin> And faster is better.
21:41:21 <squall> Hmmm
21:41:25 <squall> But generic
21:41:32 <squall> Higher order
21:41:40 <EvanR> geppettodivacin: its even easier if the compiler knows its a finite list, or a completed tree of depth N
21:41:43 <geppettodivacin> Yes, but we have the generic version of it in 'fold'.
21:41:44 <EvanR> to optimize 
21:41:47 <squall> Rational syntax
21:41:50 <Cale> I can understand how efficiency-wise, it's not always the best idea to pass via a list
21:41:51 <johnw> Cale: right, lists can be "procedural"
21:41:59 <Cale> But in terms of expression of ideas
21:42:09 <Cale> I think it's a really good way to think about things
21:42:13 <Cale> a lot of the time
21:42:46 <squall> I can use trees like that
21:43:04 <squall> ForkIO style branches in computation
21:43:08 <EvanR> but it might be list blindness, when you have list fusion every problem looks like a list ;)
21:43:28 <squall> We have tolist
21:43:36 <squall> So they actually are
21:43:52 <Cale> EvanR: Well, kind of, but also I think it's undeniable that loops have been useful in terms of expressing algorithmic ideas independently of language
21:44:09 <geppettodivacin> squall: True, but for the instance declaration, we want it to be as fast as possible, because that code will be reused by every type that inherits it.
21:44:10 <squall> But nonetheless we require more complex data structures
21:44:10 <EvanR> yes loops a big procedural algorithmic idea
21:44:37 <squall> Maps and fold please
21:44:42 <Cale> The functional equivalent of which is factoring functions through an intermediate list
21:45:03 <Cale> i.e. if you have to write a function A -> B, your algorithm might consist of a function A -> [C] and a function [C] -> B
21:45:32 <EvanR> or it could be more natural for the intermediate structure to be Tree C
21:45:37 <Cale> For sure
21:45:37 <squall> mconcat = fold, so why no Foldable superclass?
21:45:44 <EvanR> which of course we are stuck doing list processing to process
21:45:46 <squall> Because faster over lists
21:46:02 <Cale> Other polymorphic data structures can also serve purposes of capturing other sorts of recursion
21:46:29 <squall> So move away from List
21:46:31 <Cale> But when we want linear iteration over a bunch of things in order, that's what lists do.
21:46:46 <squall> It's a subset
21:46:48 <EvanR> and why do we want that more often than something else?
21:46:56 <EvanR> it seems kind of barbaric!
21:47:00 <squall> Most general guise for polymorphism plz
21:47:03 <Cale> Well, for one it's often more efficient.
21:47:21 <EvanR> yeah its the more efficient way to do a map for example
21:47:24 <EvanR> but
21:47:31 <EvanR> a map is not inherently a sequential operation
21:47:45 <EvanR> neither is inner join
21:47:47 <Cale> In that you can avoid keeping track of much information with regard to what is left to be done
21:47:58 <Cale> Lists keep that down to a constant :)
21:48:05 <squall> I can't see how traversing a tree is slower than a list. Cf Data.Map load balanced trees
21:48:37 <EvanR> so in this sense sequential iteration is like a implementation detail
21:48:49 <Cale> It is in some respects
21:49:06 <geppettodivacin> Traversing a tree may not be slower in general, but by using Foldable in a class definition, every call to the class functions requires a type lookup.
21:49:10 <squall> It creates a redundancy between fold and mconcat
21:49:27 <Cale> geppettodivacin: That's a whole other kettle of fish from what I'm getting at though.
21:49:30 <gfixler> opinions on http://www.people.vcu.edu/~rhammack/BookOfProof/ ?
21:50:46 <geppettodivacin> Cale: True, but I think that's the line of thinking squall was going after. EvanR was going after your actual argument, but I think it was a tangent to the original question.
21:50:48 <Cale> EvanR: It's an important component of how many things are implemented, regardless of whether there might be some other options.
21:51:04 <squall> Cale you seem to be saying as all collections which are foldable are isomorphic to list, that list it's the conceptual entrance point, I'm arguing foldable is...
21:51:05 <Cale> geppettodivacin: Oh, fair enough
21:51:15 <nshepperd> you can't just write every single piece of code in terms of some other fully general and polymorphic thing
21:51:22 <Cale> squall: That's actually not true
21:51:27 <squall> Oh
21:51:34 <nshepperd> things actually have to be implemented at some point as some specific thing
21:51:55 <squall> Right, but until then...
21:51:57 <nshepperd> you can't define folding in terms of folding
21:52:01 <Cale> squall: There are instances of Foldable whose implementations can't quite be recovered from the toList
21:52:05 <EvanR> Cale: yes but putting this technique on a pedestle for all time... it seems similar to the gotos and forloops of yore. like something we dont want at the focus of thinking of software development
21:52:10 <nshepperd> which is essentially what you are suggesting
21:52:37 <Cale> For example, the one for Set implements foldMap differently (though you can't tell from its semantics, it will often perform better)
21:52:48 <EvanR> structured programming, how better to think of your loops
21:52:58 <EvanR> functional programming, how better to think of your... lists?
21:53:09 <geppettodivacin> I think lists are just ubiquitous enough and easily understandable enough that they should be used unless there's reason to use otherwise.
21:53:20 <geppettodivacin> But if there's reason to use something else, then do so.
21:53:36 <EvanR> geppettodivacin: no need to think like that
21:54:02 <Cale> EvanR: Well, there's something which goes beyond programming in a particular language here
21:54:07 <EvanR> but argeeing on a common type for stuff does help a lot
21:54:24 <Cale> EvanR: lists and loops are manifestations of a particular way of decomposing problems into parts, which shows up frequently
21:54:32 <EvanR> Cale: that is what im trying to figure out, because it seems specific to haskell (or lisp)
21:54:32 <geppettodivacin> EvanR: Is there a reason we shouldn't use lists as default? I understand that there are special cases where they don't make as much sense, but for general cases they do.
21:54:34 <Cale> Yes, they are a special case of recursion
21:54:46 <ggVGc> Lists annoy me since there's always the state of empty, which in many uses of a list is actually not a valid state. And that's not captured by the type system then
21:54:47 <Cale> But it's an important special case!
21:55:13 <EvanR> geppettodivacin: the general case i am thinking of, that i think youre thinking of, is processing data on a uni processor computer with 1 thread
21:55:20 <squall> I'm saying if you have a foldable container containing Monoids then mconcat = fold. That fold is already implemented for list and is available to Monoid is misleading, requiring that the user understand the triviality of list folds through foldFree, rather than just stating we require a foldable container as we intend to fold it
21:55:30 <EvanR> geppettodivacin: which... isnt that general
21:55:38 <EvanR> just very common
21:55:40 <EvanR> for us
21:55:48 <geppettodivacin> So use something else when it makes more sense!
21:55:54 <EvanR> right
21:56:06 <EvanR> Int and lists are a good common type to agree on
21:56:09 <EvanR> so we did
21:56:16 <EvanR> so things work together now
21:56:18 <nshepperd> squall: the user doesn't need to even know about mconcat
21:56:35 <Cale> ggVGc: Loops annoy me because there's always the possibility that their precondition isn't met which results in the loop not occurring, and that can be invalid in a way that the type system doesn't capture...
21:57:02 <Cale> ggVGc: It is of course, possible to use another data structure when you want to ensure that the list is nonempty
21:57:05 <EvanR> ggVGc: theres a trick to deal with that, use (a,[a]) ;)
21:57:06 <MarcelineVQ> feels like a sunday
21:57:12 <ggVGc> Cale: yeah, loops suck. But we're writing haskell, so that's not relevant
21:57:23 <Cale> ggVGc: hah
21:57:59 <squall> nsheppard, not so, it's in the Monoid class header as if it were a required implementation, despite arising for free...
21:58:05 <ggVGc> Cale: the issue is that other people use lists because they are ubiquitous and work with so many things, in cases where the empty list is not a valid state
21:58:08 <EvanR> haskell does have loops: forM_ [0..L-1] $ \i -> do ;)
21:58:33 <ggVGc> EvanR: but tht loop does not have the faults Cale stated
21:58:35 <Cale> ggVGc: Okay, I'll be more blunt. Hammers annoy me, because sometimes you have a screw and the hammer causes the screw's threads to make a mess of the wood when you hammer them in.
21:58:36 <EvanR> ggVGc: and thats a more general issue with invisible facts
21:58:42 <squall> When I write the Monoid class it has only 2 methods in the class deceleration
21:58:44 <EvanR> about data structures
21:58:58 <squall> Specifically because of this discussion toward foldable
21:59:01 <geppettodivacin> squall: It's not required. Minimal complete definition for a Monoid is mempty and mappend.
21:59:06 <ggVGc> Cale: I don't understand the point you're making
21:59:19 <ggVGc> I wish List was implemented in terms of NonemptyList
21:59:23 <ggVGc> because one is a superset of the other
21:59:23 <EvanR> ggVGc: non empty list, non zero integer, bytes that are valid utf8
21:59:24 <nshepperd> squall: the docs say right there on hackage 'Minimal complete definition: mempty, mappend'
21:59:29 <Cale> ggVGc: If you really really need to ensure nonemptiness via the type system, you *may* use a type to ensure this.
21:59:29 <dmj> squall: you get mconcat for free
21:59:42 <Cale> ggVGc: It's not the fault of lists that they don't do that job.
21:59:45 <squall> No, use foldable
22:00:29 <EvanR> ggVGc: when you have impossible cases, you can safely use error "OMG WTF" ;)
22:00:36 <EvanR> though youd rather that be done by the compiler
22:00:39 <koz_> EvanR: Best. Error. Message. Ever.
22:00:48 <squall> "For free" by coincidence, that you have made a foldable container, and ignored this property is actually the one you are using and writing crazy magic to confuse noobs
22:00:57 <nshepperd> squall: ??? you can't use foldable to define a monoid instance. foldable is completely unrelated
22:01:30 <squall> If list want foldable you couldn't write mconcat
22:02:26 <squall> Ignoring this superclass constraint is needless and misleading, cale argues it eludes to the beauty of lists and is useful in this respect, that's the debate
22:02:28 <Cale> EvanR: but anyway, yeah, I see how it's convenient and sometimes even more efficient to be able to just use sum and length and what-have-you on more general data structures. That's fine -- but a lot of problems might as well be expressed by producing a lazy list, and then folding that -- and I think it's good for people starting out to go through a bunch of that.
22:02:34 <ggVGc> Cale: I should have said "the ubiqiotous use of lists" rather than lists
22:02:41 <ggVGc> eh, can't spell
22:03:11 <Cale> EvanR: It's good to understand exactly how general that can be -- yes it doesn't do everything, and yes sometimes there are more efficient ways to go about things.
22:03:52 <EvanR> Cale: yes its a useful technique and needs to be mastered, and im not for generalizedFoo all the things either, but one thing i really like about haskell is how the data types dont seem built-in or special like java int and java bool
22:03:59 <Cale> EvanR: But it's a very general idea, and it's part of the enjoyment of working with lazy evaluation.
22:04:24 <squall> "I don't need to require that it's foldable, I can just use list, because it's foldable"
22:04:31 <squall> ...
22:05:19 <squall> You should require it's foldable
22:05:20 <Cale> squall: Why don't you appreciate the fact that lists are in fact a very general sort of data structure already? I mean saying "an arbitrary foldable" is actually not *much* more general than saying you have a list -- the difference is a lot more slight than you think.
22:05:38 <squall> I get your point
22:05:56 <squall> Can you see mine?
22:05:58 <EvanR> yeah why is foldable required again?
22:06:03 <nshepperd> telling you how to fold arbitrary Foldables is not what the monoid typeclass is for.
22:06:15 <nshepperd> that's what Foldable is for
22:06:16 <Cale> EvanR: because foldMap can be implemented more efficiently for Set
22:06:18 <dsop> In haskell if I store the same reecord in multiple hashtables (different lookup tables), I assume it's using references and not the values itself?
22:06:21 <Cale> EvanR: and things like that
22:06:28 <dsop> therefore only need a 64bit pointer per value?
22:06:32 <EvanR> really
22:06:36 <EvanR> so its a performance hack
22:06:36 <squall> You have a collection and a binary operation and identity you require the combination of all elements, use fold
22:06:39 <Cale> EvanR: mostly
22:06:53 <EvanR> ouch
22:06:59 <Cale> EvanR: yes, ouch
22:07:40 <Cale> EvanR: We're *so* close to having this really nice universal way of expressing these things (factor via list, implement list operations)
22:07:50 <Cale> EvanR: But it breaks for performance reasons, pretty much
22:07:50 <liste> dsop: yes, or it could also be a thunk
22:08:19 <dsop> liste: thanks, the thunk was what i was looking for!
22:08:38 <squall> nshepperd, the suggestion is not to specify how to fold in the Monoid instance, but to provide mconcat through foldables "fold"
22:08:39 <Cale> I should be fair, there are some things which you really can express with Foldable that can't quite be captured factoring through a list...
22:08:46 <Cale> But they're rare and a bit subtle
22:09:03 <Cale> Like, snoc-lists
22:09:10 <Cale> (infinite ones, especially)
22:10:00 <squall> I don't get how any collection couldn't be transformed to a list
22:10:30 <squall> But then I still wouldn't want to see lists everywhere we use Foldable
22:10:41 <squall> The superclass constraint is informative
22:11:02 <EvanR> ouch
22:11:06 <squall> The compiler should take care of speed, the syntax should be for humans to read
22:11:06 <EvanR> oops
22:11:10 <EvanR> trying to recompile too fast
22:11:46 <Cale> squall: Having a list of values is conceptually nice a lot of the time when trying to understand what something is doing.
22:11:57 <Cale> (as opposed to having an arbitrary Foldable)
22:12:21 <squall> And lists are the entry point to Haskell, they are the free Monoid, Monoid are the first stumbling block
22:12:33 <Cale> You could imagine having a type  data Foldish a = Foldish { foldMap :: forall m. Monoid m => (a -> m) -> m }
22:12:49 <squall> When what you are doing is folding, the foldable superclass should be required
22:13:06 <Cale> and that would capture pretty much everything that Foldable does, if you factored through that type instead of list -- even the weird cases
22:13:23 <dfeuer> Cale, someone made a package for that ;-)
22:13:23 <nshepperd> squall: using Foldable inside of mconcat would provide very little actual value as well as a great way to accidentally introduce infinite loops
22:13:24 <squall> If you want to use lists, their implementation of foldable should be refered to
22:13:29 <nshepperd> squall: you're free to just not use mconcat if you don't like it
22:13:52 <Cale> Though there might be certain Foldable operations (especially length) which would be a bit more efficient for certain types, like Set, and which wouldn't be helped by factoring through that type
22:14:05 <dfeuer> Sjoerd Visscher, in fact. https://hackage.haskell.org/package/fmlist
22:14:24 <Cale> Yeah, doesn't surprise me that it exists :)
22:14:46 <squall> Yeah I guess I'll just not use Haskell because I don't like it
22:15:14 <Cale> squall: You might prefer Agda
22:15:49 <squall> The problem is either the implementation or my understanding, please stop people inclined to discourage investigation
22:15:53 <dfeuer> Agda is rather *more* concrete in some ways, although much more abstract in others....
22:16:03 <Cale> Though, I shouldn't have said that, it will probably result in analogous discussions happening two months from now in #agda
22:16:15 <squall> I'm Haskell from birth, agda can go home
22:16:33 <dfeuer> o.O
22:16:44 <dfeuer> Agda and Haskell fill rather different niches.
22:16:59 <squall> It's pointless to discuss this now
22:17:03 <Cale> squall: I don't think anyone's trying to discourage investigation, however, you're frequently abrasive about your approach to the discussion and it rubs people the wrong way.
22:17:12 <dfeuer> Though there are plenty of people working hard to drag features from each to the other.
22:17:14 <squall> (nshepperd) squall: you're free to just not use mconcat if you don't like it
22:17:26 <Cale> squall: That is indeed a true statement!
22:17:38 <squall> It's discouraging investigation
22:17:42 <squall> Ok
22:17:47 <dfeuer> I think mconcat is almost entirely a historical artifact....
22:17:55 <Cale> dfeuer: I disagree!
22:17:58 * EvanR encourages squall to investigate
22:17:59 <dfeuer> An idea that didn't go anywhere.
22:18:10 <Cale> I might've totally agreed with you before I knew about T-algebras
22:18:14 <squall> Right, so cale has a really nice counterargument and I'm happy I heard it
22:18:38 <dfeuer> Cale, eh? What does mconcat do for you?
22:18:43 <Cale> List-algebras are monoids
22:18:49 <Cale> mconcat is the evaluation map
22:19:04 <Cale> https://en.wikipedia.org/wiki/Monad_(category_theory)#Algebras_for_a_monad
22:19:16 <Cale> or, Wikipedia calls it the structure map
22:19:27 <dfeuer> Cale, I try to avoid Wikipedia math.
22:19:41 <Cale> dfeuer: fair enough, but it's not too wrong here :)
22:19:47 <Cale> (and some people do call it the structure map)
22:19:53 <nshepperd> squall: it would be nice if your response to people trying to explain things to you was something other than "no"
22:20:15 <Cale> dfeuer: Good enough for the diagrams alone anyway :)
22:20:23 <squall> The point is (I think) that the Foldable nature of the Free Monoid is insightful and while initially confusing, having to basically have this conversation is useful in understanding why list is actually nicer than foldable in this context...
22:20:26 <squall> I think...
22:20:53 <dfeuer> Cale, since I still don't know/understand the category-theory definitions of monad, adjoint functor, etc., this sort of thing tends to go over my head.
22:21:16 <Cale> dfeuer: ah, okay, so I can translate it into lower-brow terms
22:21:18 <dfeuer> Cale, what I don't understand is why mconcat is a *class method*, rather than a function.
22:21:49 <Cale> dfeuer: We can extract from the *list monad*, in a very sensible and uniform way, the definition of a monoid.
22:21:56 <squall> That was my point, the answer is that it's a sufficient minimal definition
22:22:10 <johnw> dfeuer: "the function is included in the class definition so that an optimized version can be provided for specific types."
22:22:12 <Cale> dfeuer: and mconcat is the main part of what comes out of that
22:22:50 <dfeuer> Cale, which monoid in particular? The list monoid?
22:22:56 <Cale> dfeuer: all monoids
22:23:04 <Cale> dfeuer: Monoids are list monad algebras
22:23:06 <dfeuer> johnw, yes, but can you name a *single one*?
22:23:16 <Cale> Let me say what that means in terms of Haskell :)
22:23:27 <nshepperd> dfeuer: There's an obvious reason to have a concatenation function in a class definition, which is that the user defining the instance knows whether their type is more performant with left or right-associated mappending
22:23:28 <squall> It would be helpful to reuse this optimisation in all folds and place it in the foldable instance?
22:23:44 <Cale> Given a monad T, an algebra for T consists of some type A, together with a function eval : T A -> A, such that
22:24:18 <dfeuer> nshepperd, right, but *lists* don't come with their sizes, and are expensive to access from the rear. As a result, I have never seen a single Monoid instance that defines mconcat.
22:24:18 <nshepperd> or which balanced mappending, come to that
22:24:39 <dfeuer> Cale, you got cut off.
22:24:50 <Cale> dfeuer: No, just typing :)
22:24:58 <squall> He it's brewing up a storm
22:24:59 <Cale> 1) If we start at T (T A), we can apply join to get to T A, and then eval to get to A, or, starting from T (T A), we can first fmap eval to get to T A, and then eval to get to A
22:25:02 <nshepperd> dfeuer: O(n) expensive, sure. worth it if your type's inefficient associated concat is O(n^2)
22:25:06 <Cale> we want those two things to be equal
22:25:17 <Cale> i.e. eval . join = eval . fmap eval
22:25:35 <squall> Right
22:25:46 <Cale> 2) If we start at A, we can apply return to get to T A, and then eval to get back to A. We want that to be the same as the identity
22:25:53 <Cale> i.e. eval . return = id
22:26:07 <nshepperd> dfeuer: eg. you'd want snoc lists to define their mconcat as a left fold
22:26:29 <squall> This it's pretty close to what I'm busy with... Monoid can be mconcated, but monadplus only had join, preventing the final concatenation
22:26:47 <Cale> If we choose T = [] (the list monad), then for any monoid, mconcat is the function which gives the eval which makes it a list monad algebra
22:26:52 <squall> :t eval
22:26:53 <lambdabot>     Not in scope: ‘eval’
22:26:53 <lambdabot>     Perhaps you meant ‘ival’ (imported from Data.Number.Interval)
22:26:56 <dfeuer> nshepperd, ah, yes. I wonder if they do...
22:27:03 <Cale> and in fact, we could *define* a monoid as being a list monad algebra
22:27:23 <Cale> and recover mempty as eval [] and mappend x y as eval [x,y]
22:27:36 <squall> I like this way much better
22:27:50 <Cale> The associativity and unit laws are encoded by the join for lists
22:28:03 <squall> It allows us to define functions over lists and extend then to arbitrary MonadPlus
22:28:14 <Cale> (interacting with the law that  eval . join = eval . fmap eval)
22:28:25 <nshepperd> there don't seem to be any snoc lists on hackage, so I guess the answer there is 'mu'
22:28:31 <dfeuer> Cale, ah, you mean defining mempty and mappend in terms of mconcat?
22:28:35 <Cale> dfeuer: right
22:28:42 <squall> He wrote it above
22:29:17 <dfeuer> nshepperd, there are some buried in various implementations, but they may not be exported.
22:29:33 <Cale> dfeuer: mconcat has nice universal laws just like mempty and mappend do, but the laws for mconcat actually generalise in a way that lets us define many other sorts of algebraic structures in a uniform way, by constructing appropriate monads
22:29:49 <Cale> This, by the way, was the original motivation for defining monads in mathematics
22:30:01 <squall> AWESOME
22:30:21 <Cale> That by way of their algebras, we can define not only monoids, but things like rings, vector spaces and so on
22:30:44 <Cale> By picking the appropriate monad
22:30:50 <squall> Reference?
22:31:04 <squall> A fruitful discussion
22:31:14 <dfeuer> Cale, it generalizes to any Monad f and type x where there's an  f x -> x?
22:31:28 <Cale> TheCatsters on YouTube has a really nice bunch of videos on monads you should see if you haven't
22:31:29 * dfeuer hands squall some fruit, specifically a lychee.
22:31:34 <Cale> dfeuer: yeah
22:31:41 <dfeuer> Cale, I keep meaning to, and then forgetting and/or getting distracted.
22:32:08 <squall> I mean for my thesis
22:32:18 <squall> With a doi
22:32:44 <dfeuer> squall, for your thesis, you should visit the library. And talk to a research librarian.
22:32:50 <EvanR> heh, i just used existentials in a GADT ctors
22:32:57 <EvanR> and was unable to actually use it
22:33:02 <dfeuer> ctors?
22:33:09 <EvanR> constructors
22:33:15 <squall> What's a library?
22:33:30 <EvanR> i realized why, because theres no way to produce a value of the unknown rigid type
22:33:36 <EvanR> so whats the point?
22:33:41 <Cale> dfeuer: So, you can define vector spaces by way of a monad of formal linear combinations of elements of type V. The return for that monad will send v in V to the linear combination "1 * v" (however we want to represent that), and the join will take a linear combination of linear combinations, and multiply out the coefficients to get just a simple linear combination
22:33:51 <johnw> EvanR: can you show your code?
22:33:52 <squall> Ok well I'll just reference the irc log
22:33:56 <Cale> dfeuer: and the algebras of that monad are precisely vector spaces
22:34:17 <dfeuer> Cale, that is crazy.
22:34:58 <Cale> dfeuer: and of course you can do this for many other sorts of algebraic structures
22:35:17 <dfeuer> squall, you can probably get a campus map showing the location of the library from the security office. You should probably go to the library between 8AM and 4PM.
22:35:48 <dfeuer> Cale, interesting stuff to chew on. Thanks. I really should be getting ready for bed now, however :/
22:35:51 <EvanR> johnw: http://lpaste.net/153044
22:36:00 <EvanR> i fixed it by making all the variables polymorphic rank-1
22:36:06 <EvanR> but now im wonder what use it is
22:36:07 <squall> If cale worked there I would probably go
22:36:08 <nshepperd> huh, possible Foldable law: getAlt . foldMap (Alt . pure) = id
22:36:11 <Cale> dfeuer: Oh, and not only this, but you can actually define a T-algebra homomorphism, and extract, e.g. the definition of a monoid homomorphism or a linear map
22:36:14 <EvanR> (to do rank 2)
22:36:24 <nshepperd> for things that are Foldable and also Alternative
22:36:43 <johnw> EvanR: why do you have it in parens?
22:36:44 <Cale> dfeuer: (by plugging in the appropriate monad and then turning the crank)
22:36:47 <dfeuer> Cale, this is the sort of thing that sounds like a big coincidence wrapped in "whoa, deep", but I could be convinced otherwise :-)
22:37:08 <EvanR> johnw: indeed because i thought i was trying to do an existential, but it turns out that was wrong
22:37:13 <johnw> EvanR: what you have there isn't an existential
22:37:20 <Cale> dfeuer: Well, if it's a coincidence, it's that humans like to study things of a particular sort :)
22:37:27 <johnw> EvanR: it's asking for an object which satisifies something you can never satisfy
22:37:31 <EvanR> a rank-2 polymorphic ctor
22:37:31 <johnw> like having forall a. a
22:37:52 <johnw> if you have: MkRun :: forall r i j . (r, C r i j) ->
22:37:54 <johnw> that would be an existential
22:37:59 <squall> Awesome times everyone
22:38:07 <EvanR> johnw: huh... ok
22:38:09 <johnw> because only the user of MkRun would know which r i and j were chosen
22:38:09 <Cale> dfeuer: It doesn't work for all mathematical concepts, but it does get a lot of things
22:38:59 <squall> Thanks for the help on the discussion, it seems wrapped up now so I'll get on with trying to summarise those arguments for the chemists and getting some reference on t algebra etc
22:39:14 <EvanR> johnw: would you call this existential? http://lpaste.net/153044
22:39:41 <johnw> I would; does that also not work?
22:39:58 <johnw> i don't think i' and j' can come from the constructor like that
22:40:05 <EvanR> it works
22:40:06 <Cale> squall: Lawvere theories would be another thing to look for
22:40:08 <johnw> oh, ok
22:40:11 <EvanR> i' and j' are polymorphic as normal
22:40:15 <EvanR> caller chooses
22:40:16 <johnw> k
22:40:19 <johnw> that's true
22:40:26 <EvanR> but the other thre....
22:40:33 <EvanR> caller also chooses but
22:40:39 <EvanR> wtf is existential ;)
22:40:41 <johnw> you can't discover what they are by pattern matching
22:40:45 <johnw> they simply "exist", hence the name
22:40:58 <johnw> "there exists an r, i and j such that MkRun was callable"
22:41:28 <EvanR> so if the type vars are not in the type, its existential. if there are unused type vars in the type it is phantom
22:41:55 <johnw> not sure that generalization always works, but roughly yes
22:42:18 <EvanR> well the data type
22:42:30 <EvanR> i know you can get existential-like stuff with rank-2 function types
23:00:55 <johnw> hmm... a 60,000 line Haskell file compiles rather slowly
23:02:00 <EvanR> using haskell source files as a database are we
23:02:10 <johnw> no, it's code generated from Coq
23:06:14 <johnw> hmm... several minutes later and it's still not done; I wonder if a 6.3M source file should be this slow
23:06:35 <johnw> considering it uses no language features except the most basic 
23:07:26 <EvanR> is it slow compiling or linking
23:07:33 <johnw> this is just -c, no linking
23:08:23 <johnw> well, I'll leave it running as I go to sleep; good night ;)
23:37:23 <orion> Is static linking of executables pretty much hit or miss? I've successfully created a static binary which runs, but it doesn't actually do anything useful.
23:37:54 <orion> It's supposed to launch Warp and all that, but it just sits there rereading files in /etc/ssl over and over (I know this from strace)
23:43:27 <Ralith> static linking isn't really a thing linux wants you to do these days
23:46:18 <liste> orion: did you link C libraries (glibc etc) statically too?
23:49:26 <EvanR> so my module clobbers the prelude names null, swap, id, and fmap
23:49:35 <EvanR> how to proceed
23:49:41 <EvanR> also (+) ...
23:50:23 <EvanR> qualify? prime? underscore?
23:51:05 <Cale> import Prelude hiding? :)
23:51:32 <EvanR> yes
23:51:41 <EvanR> but these are exported
23:51:50 <Ralith> choose better names?
23:51:57 <EvanR> these are the best names :(
23:52:23 <EvanR> but ok
23:52:25 <superlinux> hi. I want a book very much like Deitle's "How to program " series . after reading "Learn you a haskell for great good" i felt it's also not suitable for beginners too. please , if there is such a book, tell me about it.
23:52:31 <Cale> swap isn't in the Prelude btw
23:52:31 <EvanR> whats better than + ?
23:52:49 <Cale> Perhaps <> ?
23:53:00 <Cale> (If it's a monoid...)
23:53:11 <EvanR> right, and its not commutative so <> probably makes more sense
23:53:48 <EvanR> i cant do standard instances though
23:53:52 <Cale> Why not?
23:53:58 <EvanR> the type ctor is
23:54:09 <EvanR> * -> [*] -> [*] -> *
23:54:25 <Cale> Shouldn't the instance be for the fully applied constructor?
23:54:34 <Cale> Shouldn't matter what kind the args are
23:54:48 <EvanR> well functor requires * -> *
23:54:50 * hackagebot logict-state 0.1.0.1 - Library for logic programming based on haskell package logict  https://hackage.haskell.org/package/logict-state-0.1.0.1 (AtzeDijkstra)
23:54:56 <Cale> ah
23:54:56 <EvanR> fully applied is *
23:54:57 <Cale> er
23:55:08 <Cale> Can you make it [*] -> [*] -> * -> * ?
23:55:37 <EvanR> yeah but the functor sends types to C r [a] [b]
23:56:02 <Cale> er, what?
23:56:06 <EvanR> so thats the wrong args
23:56:07 <Cale> What's the type of fmap?
23:56:21 <EvanR> (a -> b) -> C r [a] [b]
23:56:31 <Cale> oh, weird
23:56:32 <Cale> okay
23:56:44 <EvanR> yeah the [*] screws it up
23:56:47 <Cale> I'm not sure I'd even want to use fmap for that then
23:57:01 <Cale> I mean, it might abstractly be a functor, but even then...
23:57:02 <EvanR> well yeah, its fmap but not in Hask
23:57:54 <EvanR> whats another name for id
23:58:13 <Cale> idC ?
23:58:22 <Cale> identity ?
23:58:30 <EvanR> going to be typing it a lot ;)
23:58:39 <Cale> i ? :)
23:58:44 <EvanR> nice
23:58:45 <Welkin> eye
23:58:56 <Welkin> used in the linear algebra libraries
23:59:02 <Cale> haha
23:59:16 <EvanR> cat
23:59:25 <EvanR> kind of annoying though
23:59:26 <nachoman> any recommended book to learn haskell?
23:59:38 <EvanR> there will be too many cats
23:59:46 <Ralith> http://haskellbook.com/
