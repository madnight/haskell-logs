00:02:12 * hackagebot NXT 0.2.4 - A Haskell interface to Lego Mindstorms NXT  https://hackage.haskell.org/package/NXT-0.2.4 (MitarMilutinovic)
00:07:38 * hackagebot bitx-bitcoin 0.7.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.7.0.0 (tebello_thejane)
00:07:38 * hackagebot NXT 0.2.4 - A Haskell interface to Lego Mindstorms NXT  https://hackage.haskell.org/package/NXT-0.2.4 (MitarMilutinovic)
00:12:32 * hackagebot NXT 0.2.5 - A Haskell interface to Lego Mindstorms NXT  https://hackage.haskell.org/package/NXT-0.2.5 (MitarMilutinovic)
00:16:19 <jellytux>  /join turtlesnail
00:56:10 <haskell669> How can I use Maybe and IO inside one do notation? do x <- Just "foo"; print x; return x
00:58:47 <jle`> haskell669: let x = Just "foo"
00:59:17 <kadoban> haskell669: It's a little hard to tell how you want that to behave. What do you want to happen?
01:00:24 <haskell669> kadoban: More complex example do x <- Just 1; y <- Just 2; let z = x + y; print z; return z
01:01:38 <kadoban> haskell669: That doesn't really explain either what you want to happen. I have a feeling you have some other problem that you're trying to encode, but … the code you're writing is just a type error, so I have a feeling you're assigning it meaning implicitly that it doesn't have (and thus I can't really figure it out).
01:01:57 <haskell669> jle`: no, i want to use <-
01:02:09 <jle`> haskell669: do you want 'x' to be Just "foo"
01:02:13 <jle`> or to be '"foo"' ?
01:02:34 * hackagebot cndict 0.7.0 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.7.0 (DavidHimmelstrup)
01:02:36 <jle`> if you want x to be 'Just "foo"', then you can say let x = Just "foo"
01:02:46 <jle`> you can use <- if you want, but that'd be kind of silly; x <- return (Just "foo")
01:02:51 <haskell669> jle`: Other example do x <- Just 1; y <- Just 2; let z = x + y; print z; return z
01:03:05 <jle`> do you want x to be 1 there, or Just 1 ?
01:03:25 <haskell669> kadoban: I just want to sum two Just Int print and return the result
01:03:53 <kadoban> haskell669: And what do you want to happen if one (or both) of them are Nothing ?
01:04:12 <haskell669> jle`: I want use + so x should be 1
01:04:31 <jle`> any reason why you can't do the IO after everything?
01:05:11 <jle`> let res = do { x <- Just 1; y <- Just 2; let z = x + y; return z }; print res ?
01:05:11 <haskell669> kadoban: print shouldn't be used and result is nothing
01:05:34 <jle`> or `mapM_ print res` if you want to print only if it's Just
01:06:20 <EvanR> FTP FTW
01:06:47 <kadoban> haskell669: What jle` said make any sense?
01:07:02 <haskell669> jle`: Yes, but I want to undestand how to use Maybe and IO inside one do notation.
01:07:16 <EvanR> you cant
01:07:18 <jle`> do you understand what do notaion is?
01:07:24 <EvanR> one do notation is 1 monad
01:07:27 <jle`> it's just desugars into >>=
01:07:51 <puregreen> I think haskell669 wants something like MaybeT but since MaybeT is annoying to use...
01:07:51 <jle`> and (>>=) :: IO a -> (a -> IO b) -> IO b, or (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
01:08:11 <jle`> do notation just desugars into normal applications of (>>=)
01:08:27 <jle`> so it wouldn't make too much sense to use two different types there ... because each type implements (>>=) in its own way
01:08:40 <jle`> which (>>=) would be used?  the one for IO, or the one for Maybe?
01:10:14 <kadoban> puregreen: Not really I don't think. They should just nest a couple of do notations like jle` suggested above.
01:10:32 <haskell669> jle`: I can do this do x <- MaybeT $ return $ Just 1; y <- MaybeT $ return $ Just 2; let z = x + y; lift $ print z; return z. Is it the only way?
01:11:40 <jle`> in that case, you're writing your do notation in a new monad that isn't Maybe or IO
01:11:51 <jle`> it's a third, new monad type, so all the >>='s make sense within that one type
01:12:11 <jle`> and so all of that boilerplate is to "convert" Maybe a's and IO a's to that new type
01:12:36 <jle`> if you want to use a do block, every 'line' has to be of the same monad
01:12:54 <haskell669> jle`: I know. What would be the idiomatic way to do this?
01:13:06 <jle`> so you can "convert" Maybe a's and IO a's into a monad that has the effects you would use
01:13:13 <jle`> MaybeT is one such example, but there are others
01:13:24 <jle`> haskell669: the idiomatic way here would be to not try to combine them
01:13:33 <puregreen> kadoban: I'm not sure whether haskell669 wants to get the task done, or whether ne wants to learn how to mix monads together and the example with Maybe was just an example – in the latter case jle`'s solution isn't helpful
01:13:34 <jle`> and to just use separate do blocks for IO and Maybe
01:13:46 <kadoban> puregreen: I'm now unsure as well.
01:13:47 <EvanR> haskell669: do your Maybe calculation then do a case expression to either print the just value or not
01:14:00 <jle`> do Maybe w/o IO, and do IO on the result, yeah
01:15:27 <jle`> one case where it woild be tricky to separate things is if you had a 'maybe' result that depended on the result of an IO action
01:15:38 <haskell669> How about this do x <- Just 1; y <- readIntFromFile "foo.txt"; return x + y; Does this example make sense?
01:15:40 <jle`> but even in that case, you can just use normal pattern matching
01:16:06 <EvanR> return (liftA2 (+) x y)
01:16:38 <jle`> haskell669: for something like that, the idiomatic way would probably still to just use normal pattern matching
01:16:53 <jle`> but if you have a lot of those, you can abstract away from the pattern matching and case statements with something like MaybeT
01:17:11 <EvanR> x + y is not in any monad so would not work even with MaybeT
01:17:17 <haskell669> jle`: could you show some code with pattern matching?
01:17:53 <jle`> case x of Just x' -> do y <- readIntFormFile "foo.txt"; return (x' + y)
01:18:10 <jle`> or return (Just (x' + y)
01:18:12 <quicksilver> erm
01:18:20 <quicksilver> "MaybeT $ return $ Just 1"
01:18:22 <quicksilver> isn't that just
01:18:24 <quicksilver> return 1
01:18:24 <quicksilver> ?
01:18:35 <jle`> quicksilver: yeah, but i'm presuming the 'Just 1' is treated as a black box here
01:18:36 <quicksilver> isn't that the point of the monad? :)
01:18:48 <jle`> MaybeT (return isItJustOrMaybeWhoKnows)
01:19:22 <jle`> haskell669: er, i meant something like, case Just 1 of Just x -> do ...
01:19:28 <quicksilver> asome people give (MaybeT.return) a name
01:19:32 <quicksilver> liftMaybe or hoistMaybe or something
01:20:10 <jle`> yeah, wish there was something standard
01:22:23 <quicksilver> jle`: well there is mmorph
01:22:30 <quicksilver> but in practice I don't actually use it
01:22:30 <jle`> mmorph doesn't quite work with MaybeT
01:22:32 <jle`> wrong kind
01:22:39 <haskell669> So, overall the answer would be to use pattern matching?
01:22:55 <jle`> haskell669: in the end, all MaybeT does is abstract over repeated pattern matching
01:22:59 <quicksilver> not sure what you mean, jle` 
01:23:03 <quicksilver> MaybeT is an instance of MFunctor
01:23:27 <jle`> haskell669: so, i would pattern match first, and if the pattern matching gets out of hand, consider switching to MaybeT to help
01:23:50 <haskell669> ok, thanks
01:23:58 <jle`> quicksilver: yes, but you can't use hoist to turn a Maybe into a MaybeT
01:24:16 <jle`> you can use it to turn a MaybeT Identity a into a MaybeT m a
01:24:24 <jle`> but not Maybe a -> MaybeT m a
01:24:29 <quicksilver> right.
01:24:45 <quicksilver> I see what you mean :)
01:25:02 <jle`> yeah, my earlier statement wasn't too clear :)
01:25:06 <quicksilver> it does solve the problem in a sense, though
01:25:16 <quicksilver> it's just it adds more plumbing to hide the plumbing
01:25:17 <jle`> of Maybe a -> MaybeT m a ?
01:25:34 <quicksilver> of giving a canonical name to (MaybeT.return) I guess
01:26:00 <jle`> to use `Maybe a` with hoist, you'd have to turn it into a MaybeT m a, but then that's the same thing you had in the first place
01:26:14 <quicksilver> nod
01:26:17 <jle`> quicksilver: what name would that be?
01:26:20 <quicksilver> hoist
01:26:28 <quicksilver> modulo an isomorphism
01:26:34 <quicksilver> which is what I meant by plumbing :)
01:26:50 <quicksilver> in a sense it's inconsistent that Maybe isn't defined as MaybeT Identity
01:27:00 <quicksilver> since State is defined as StateT Identity
01:27:02 <jle`> hm, hoistMaybe would probably be (forall a. a -> m a) -> Maybe b -> MaybeT m b
01:27:05 <quicksilver> (but in another sense it would be a pain)
01:27:14 <jle`> and so what you want would be `hoistMaybe return`
01:27:24 <jle`> i think liftMaybe sort of makes more sense
01:29:45 <quicksilver> jle`: http://stackoverflow.com/questions/8684252/how-to-inject-a-maybe-value-into-maybet
01:29:52 <quicksilver> not that there is anything much there you didn't just say
01:31:02 <jle`> i did use maybe mzero return for a while, but i've started liking MaybeT.return too. but yeah :/
01:34:44 <phadej> interestingly MonadError e m => Either e a -> m a has name, but MissingH version don't have maybe counterpart, and either is deprecated
01:35:17 <phadej> I sue similar either throwError pure here and there
01:36:09 <merijn> phadej: What do you mean "either is deprecated"?
01:37:27 <geekosaur> the package with that name, I suspect
01:38:03 <merijn> geekosaur: Except that isn't deprecated
01:38:07 <geekosaur> alhough it doesn't/... yes
01:38:50 <jle`> what do people use 'either' for? the cute combinators?
01:38:50 <phadej> well, kind of. using Except is preferred?
01:39:11 <merijn> jle`: Validation applicative, EitherT transformer
01:39:11 <jle`> oh hey, it has Validation
01:39:30 <jle`> i've been using Validation from a different package all along, i didn't even realize 'either' had one
01:39:58 <merijn> jle`: There's a Validation package, but the Validation in there is so cumbersome
01:40:08 <merijn> Lenses and ridiculously convoluted API
01:40:09 <jle`> yeah, that's the one i've been using.  might switch
01:40:25 <jle`> but, i feel like most people would suggest ExceptT over EitherT these days
01:40:38 <jle`> since ExceptT comes with ghc effectively
01:41:00 <merijn> jle`: ExceptT has an Error constraint on left
01:41:09 <jle`> are you thinking of ErrorT?
01:41:53 <merijn> oh, maybe it's just mtl that still has Error constraint on left
01:42:10 <phaazon> dammit
01:42:11 <phaazon>     Expected type: Free (ASTF i0) b -> AST b
01:42:12 <phaazon>       Actual type: (forall i. Free (ASTF i) b) -> AST b
01:42:17 <phaazon> how can I remove that error?
01:42:19 <jle`> mtl has ExceptT now too
01:42:28 <jle`> ExceptT was supposed to be ErrorT-without-the-constraint
01:42:52 <phaazon> hm I guess my type is wrong actually
01:42:57 <jle`> i think it was introduced specifically in response to EitherT.  story is slightly convoluted
01:42:57 <phaazon> that’s what ghc might be telling me
01:43:15 <phaazon> newtype AST a = AST { runAST :: forall i. Free (ASTF i) a }
01:43:41 <phaazon> I guess I should use Some ASTF instead
01:43:59 <jle`> transformers had ErrorT but it has a weird constraint, 'either' package was made to address problem, and EitherT was 'merged' back into transformers as ExceptT
01:44:26 <jle`> yay historical baggage
01:44:46 <hvr> edwardk was not amused
01:44:49 <kadoban> I doubt I'll even remember which one is which. I should just write a post-it somewhere.
01:44:54 <kadoban> ever*
01:45:14 <hvr> (I think)
01:45:20 <jle`> phaazon: yeah, SomeASTF is different than what you have there
01:45:30 <EvanR> so the latest of all ErrorFoos is ExceptT
01:45:34 <EvanR> just to make sure
01:45:44 <jle`> well, the latest Either monad transformer
01:45:49 <phaazon> I personnaly use EitherT
01:45:59 <EvanR> the latest is EitherT?
01:46:06 <phaazon> I didn’t say it was the latest
01:46:09 <phaazon> I say I use it
01:46:15 <phaazon> it’s fair enough for what I do
01:46:15 <EvanR> im asking if jle` typoed
01:46:16 <jle`> ExceptT is EitherT but merged back into transformers/comes with ghc
01:46:30 <merijn> jle`: ExceptT in mtl is identical to Error
01:46:33 <jle`> ExceptT is the latest Either monad transformer, not EitherT
01:46:38 <jle`> the type is the same, but the Monad instance is different
01:46:44 <jle`> that's the important thing
01:46:59 <EvanR> is there are comparison of all these next to each other somewhere
01:47:06 <hvr> how does ExceptT's monad instance differ from EitherT?
01:47:14 <merijn> hvr: It doesn't, I think?
01:47:30 <jle`> ExceptT is supposed to just be an EitherT clone
01:47:44 <hvr> jle`: you got me confused as you wrote: 10:46 < jle`> the type is the same, but the Monad instance is different
01:47:44 <jle`> from what i can tell
01:48:05 <jle`> yeah, ErrorT, EitherT, and ExceptT are all the same ADT
01:48:16 <jle`> but EitherT and ExceptT have the 'correct' Monad intsance
01:48:51 <jle`> they are all Foo e m a = Foo (m (Either e a))
01:49:45 <EvanR> what was incorrect
01:50:00 <jle`> ErrorT's monad instance had a constraint on the 'e'
01:50:10 <jle`> so that it could implement a cute "fail"
01:50:41 <EvanR> what do the othetrs do with fail
01:50:50 <hvr> well... now it could be done via http://hackage.haskell.org/package/fail
01:50:58 <hvr> w/o infecting the MOnad instance
01:52:48 <jle`> EvanR: they defer to 'fail' of the wrapped monad
01:52:53 <jle`> fail = ExceptT . fail
01:53:30 <jle`> s/wrapped/wrapping?
01:53:51 <EvanR> at my chamber door
01:54:26 <jle`> hvr: nice :)
02:31:21 <Aleksejs> Hello, "\x -> read x :: Int" can this be defined with pointless notation?
02:31:44 <dramforever> :t read :: String -> Int
02:31:46 <lambdabot> String -> Int
02:32:07 <phadej> :t read :: _ -> Int
02:32:09 <merijn> Is Lennart's type annotation as operator extension in GHC yet?
02:32:10 <lambdabot>     Found hole ‘_’ with type: String
02:32:12 <lambdabot>     To use the inferred type, enable PartialTypeSignatures
02:32:14 <lambdabot>     In an expression type signature: _ -> Int
02:32:57 <dramforever> :t read @Int -- Will work with GHC 8.0 with explicit type application (I think)
02:33:00 <lambdabot> Pattern syntax in expression context: read@Int
02:33:11 <phadej> merijn: nope: https://ghc.haskell.org/trac/ghc/ticket/10803
02:33:20 <merijn> Wait, GHC 8.0 will have explicit type application?
02:33:50 <dramforever> merijn: I think so
02:34:02 <phadej> t read @Int
02:34:02 <phadej> read @Int :: Read Int => String -> Int
02:34:18 <phadej> funny ways it works.
02:34:18 <merijn> :O
02:34:50 <dramforever> And TIL GHC 8.0 will give the required type for a not-in-scope variable, like
02:34:54 <dramforever>     Variable not in scope: owsh :: Integer -> String
02:36:03 <dramforever> So I'm really looking forward to the final release
02:36:14 * dramforever gotta go quick :P
02:36:18 <phadej> but I don't know whether this feature of TypeApplications is a feature or a bug
02:37:54 <merijn> phadej: What do you mean?
02:38:00 <merijn> :t read
02:38:02 <lambdabot> Read a => String -> a
02:38:07 <merijn> hmm, no explicit forall
02:38:12 <phadej> t Proxy @Bool
02:38:12 <phadej> Proxy @Bool :: Proxy t
02:38:41 <phadej> I'm not sure whether GHC is confused by Proxy being polykinded
02:38:42 <phadej> ie
02:38:51 <merijn> I don't understand why it would be
02:39:00 <phadej> t Proxy
02:39:00 <phadej> Proxy :: forall k (t :: k). Proxy t
02:39:22 <phadej> but the type allication doesn't seem work to it
02:39:46 <phadej> otherwise one could write (Proxy @Type) instead of (Proxy :: Proxy Type) !
02:41:11 <merijn> phadej: You're type application for Proxy is wrong
02:41:29 <merijn> It should be "Proxy @(TYPE Lifted) @Bool"
02:41:39 <merijn> Or however you type apply * with levity polymorphism
02:41:58 <merijn> Perhaps "Proxy @* @Bool" works
02:42:19 <phadej> tried latter, it doesn't
02:43:09 <phadej> t Proxy @(*) @Int
02:43:09 <phadej> Proxy @(*) @Int :: Proxy Int
02:43:20 <phadej> with (*) from Data.Kind
02:43:45 <phadej> TypeApplications aren't as easy and cool as one would like them to be. Time shows.
02:44:33 <phadej> t Proxy @_ @Int
02:44:33 <phadej> Proxy @_ @Int :: Proxy Int
02:44:35 <phadej> works too
02:44:46 <EvanR> @_ @
02:44:48 <lambdabot> Maybe you meant: v @ ? .
02:44:58 <phadej> :D
02:58:09 <phaazon> hm
02:58:40 <phaazon> how can I declare a new type family and state that it should be an instance of a given set of typeclasses?
02:58:43 <phaazon> like
02:58:48 <phaazon> type Foo m :: * -> *
02:59:01 <phaazon> I’d like that to be a contravariant functor
02:59:13 <EvanR> isnt that like putting constraints on data types
02:59:40 <phaazon> hm, yeah, you’re right
02:59:56 <phaazon> so I should put the constraint on the functions that use that type then
03:00:18 <EvanR> the equivalent would be put constraints on type instances... but
03:00:36 <phaazon> no
03:00:38 <EvanR> that doesnt make sense
03:00:43 <phaazon> I want to be able to use the typeclasses in the generic code
03:00:54 <phaazon> so I guess the following will work:
03:01:02 <EvanR> you can make instances for the types
03:01:11 <phaazon> thingy :: (Contravariant (Foo m)) => Foo m -> …
03:01:12 <EvanR> and put constraints on the code
03:02:38 * hackagebot b9 0.5.18 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.18 (SvenHeyll)
03:03:24 <phaazon> neat
03:03:29 <phaazon> I just converted a type from
03:03:41 <phaazon> newtype Foo = Foo { runFoo :: IO () }
03:03:47 <phaazon> to a Semigroup constraint :)
03:03:53 <phaazon> way cooler
03:04:25 <jacke__> hi there! Quick question: I have a monad stack (newtype MyApp a = MyApp StateT MyState SomeMonad a) and a value v of type SomeMonad a. Does it makes sense to lift v to MyApp? If so, what is the function of type SomeMonad a -> MyApp a?
03:05:06 <phaazon> jacke__: MyApp . lift
03:05:33 <jacke__> phaazon: I feel silly now. Thanks!
03:06:03 <phaazon> you’re welcome :)
03:37:39 * hackagebot users 0.5.0.0 - A library simplifying user management for web applications  https://hackage.haskell.org/package/users-0.5.0.0 (AlexanderThiemann)
03:37:42 * hackagebot users-test 0.5.0.0 - Library to test backends for the users library  https://hackage.haskell.org/package/users-test-0.5.0.0 (AlexanderThiemann)
03:52:40 * hackagebot users-postgresql-simple 0.5.0.0 - A PostgreSQL backend for the users package  https://hackage.haskell.org/package/users-postgresql-simple-0.5.0.0 (AlexanderThiemann)
03:52:42 * hackagebot users-persistent 0.5.0.0 - A persistent backend for the users package  https://hackage.haskell.org/package/users-persistent-0.5.0.0 (AlexanderThiemann)
04:04:16 <Benzi-Junior> hey what is the best way to have an algorithm know it's position in a list (or list of lists)
04:04:48 <mniip> depends on what you mean by position
04:04:52 <mniip> a numeric index?
04:05:37 <Benzi-Junior> mniip: yes 
04:05:48 <mniip> well just carry a number around
04:10:30 <rom1504> I wonder how an algorithm can be stored in an haskell list
04:11:31 <Rembane> rom1504: You can store the instructions in the list.
04:13:13 <rom1504> ah yeah good point
04:15:46 <rom1504> next thing to solve is how these instructions stored in that list will know (=be executed) its position in a list. probably have to have the haskell program execute these instructions, which will in turn execute the haskell program which will print the position in the list. OR Benzi-Junior could learn english, idk what's easier :p
04:16:34 <Rembane> rom1504: Create an interpreter in Haskell that runs the instructions in the list sequentially.
04:16:36 <Gurkenglas_> You want "[Int -> a] -> [a]"?
04:17:38 <Gurkenglas> :t zipWith (flip ($)) [0..]
04:17:44 <lambdabot> (Enum a, Num a) => [a -> c] -> [c]
04:32:54 <M2tias> :t flip
04:32:58 <lambdabot> (a -> b -> c) -> b -> a -> c
05:12:52 <iphy> hi
05:14:16 <iphy> I have four types that are all very similar, and their code is exactly the same except for types and some varying integers: https://github.com/iphydf/hstox/blob/master/src/Network/Tox/Crypto/PublicKey.hs https://github.com/iphydf/hstox/blob/master/src/Network/Tox/Crypto/SecretKey.hs and two others
05:14:30 <iphy> what would be a good way to reduce this duplication?
05:20:10 <Gurkenglas> Where's Crypto.Saltine.Core.Box?
05:20:41 <Gurkenglas> Oh, under src ._.
05:20:55 <iphy> https://github.com/tel/saltine/blob/master/src/Crypto/Saltine/Core/Box.hs
05:21:16 <iphy> it's a package I don't control
05:21:35 <iphy> what this code actually wants to do is add some type class instances to the Saltine types
05:21:43 <iphy> Show, Read, Binary, Arbitrary
05:22:08 <lyxia> iphy: You could wrap the common parts in functions
05:23:33 <Gurkenglas> I don't see any varying numbers. Why make a newtype, instead of giving instances for the keys themselves? But generally the way would be "newtype Key a = Key a; instance IsEncoding a => Binary (Key a) where ..."
05:24:22 <lyxia> oh yeah that's very nice
05:24:35 <iphy> varying numbers are Sodium.boxPK, Sodium.boxSK, etc.
05:24:43 <iphy> in the Binary and Arbitrary instances
05:25:43 <iphy> why newtype: because otherwise the instances are orphans
05:26:06 <lpaste> songzh pasted “defualt Binary with SYB” at http://lpaste.net/153119
05:26:13 <iphy> why not IsEncoding => Binary: because the sizes vary (nonce is 24 bytes, keys are 32 bytes)
05:26:34 <Gurkenglas> Why not put the instances in the module where you define the types? You can also put boxPK and boxSK into the IsEncoding class as box
05:26:43 <songzh> can any tell me that how to implement a default put and get function with SYB for Data.Binary?
05:26:58 <iphy> I don't define Saltine types
05:27:03 <songzh> Or it is impossible.
05:27:27 <iphy> Saltine is a library I'm using, so I can't modify the modules defining SecretKey, IsEncoding, etc.
05:28:03 <Gurkenglas> Then define a hasBox typeclass for those four and your own instances, or make a pull request to the library
05:28:13 <ggVGc> is this a baking channel now?
05:28:20 <ggVGc> I come in and read saltines and sodium
05:28:27 <ggVGc> now I want tea and a cookie
05:28:57 <iphy> I won't be able to convince them to add Arbitrary instances to their types
05:29:33 <iphy> maybe Read and Show, but even then I'm not sure (because it adds a dependency on the base16 package)
05:29:56 <phaazon> is it possible to put type families of type families in a typeclass?
05:29:57 <phaazon> like hm
05:30:01 <phaazon> class Foo m where
05:30:29 <iphy> so, a HasBox type class?
05:30:38 <phaazon>   type family Bar m t :: *
05:30:39 <merijn> phaazon: "type families of type families"? That is a non-sensical notion
05:30:40 <iphy> something that returns the box* numbers?
05:30:55 <merijn> phaazon: Are you thinking of associated type families?
05:31:04 <phaazon> merijn: maybe
05:31:09 <phaazon> let met use the proper types actually:
05:31:18 <Gurkenglas> iphy, you only need them to add box to IsEncoding
05:31:37 <phaazon> class WeDontCare m where { type Texture m :: * -> Constraint; type family TextureSize m :: * }
05:31:50 <phaazon> I’d like that TextureSize be a type family inside the Texture typeclass
05:32:00 <songzh> Hey guys, I just want to know whether it is possible to implement Data.Binary with SYB. Any ideas?
05:32:03 <merijn> phaazon: Texture is not a typeclass
05:32:27 <phaazon> merijn: well it’s a constraint, so it’s a typeclass, no?
05:32:32 <songzh> songzh pasted “defualt Binary with SYB” at http://lpaste.net/153119
05:32:35 <merijn> phaazon: And I don't understand what you mean by "TextureSize is inside Texture"
05:32:44 <merijn> phaazon: No, Constraints are a superset of typeclasses
05:32:54 <merijn> phaazon: A typeclass gives rise to a constraint
05:32:59 <phaazon> merijn: well, I have a typeclass outside of this module
05:33:12 <phaazon> class Texture t where { type TextureSize t :: * }
05:33:44 <phaazon> hm I guess I could use it instead of delegating that to the implementation of the instances
05:33:48 <merijn> phaazon: Why is Texture mentioned in WeDontCare, then?
05:34:05 <phaazon> merijn: because I’d like to generalize it 
05:34:13 <phaazon> WeDontCare is actually called Driver
05:34:15 <merijn> phaazon: Texture in WeDontCare is defining a new type family
05:34:17 <iphy> class IsBox where { size :: ? -> Int }
05:34:20 <phaazon> yes
05:34:40 <iphy> (Sodium.box* are Ints)
05:35:00 <combinator> @pl \s -> s/= "t" && s/= "f"
05:35:02 <lambdabot> liftM2 (&&) ("t" /=) ("f" /=)
05:35:13 <merijn> iphy: You probably want to use "class IsBox b where { size :: Proxy b -> Int }"
05:35:36 <iphy> aha, Proxy
05:35:42 <merijn> combinator: You might want to use the Any/All newtypes and their monoid instance :)
05:35:49 <Gurkenglas> Umm why not "class IsBox b where { size :: Int }"
05:35:54 <merijn> combinator: (Depending on what you're doing)
05:36:00 <merijn> Gurkenglas: You can't use size there
05:36:09 <merijn> Gurkenglas: "Ambiguous type variable 'b'"
05:36:15 <Gurkenglas> Oh, hm.
05:36:20 <augur> is there a way to add effects (in particular, silent failure) to a Free monad?
05:36:23 <merijn> "size :: IsBox b => Int" <- which instance to pick?
05:36:54 <combinator> @pl \s -> s/= 't' && s/= 'f'
05:36:54 <lambdabot> liftM2 (&&) ('t' /=) ('f' /=)
05:37:19 <merijn> Gurkenglas: You always want the type parameters to appear in the type of a class member, else you get ambiguity problems
05:37:34 <merijn> Gurkenglas: It's one of the main uses of Proxy/the proxy trick
05:38:47 <Gurkenglas> "class IsBox b where { Monad m => (Int -> m b) -> m b }"
05:39:40 <Gurkenglas> *"sizeCont ::"
05:41:15 <merijn> Why the monad constraint there?
05:42:20 <Gurkenglas> Ah, I thought you can't just put b because you could have side effects so you don't actually need to look at them so yep "class IsBox b where { sizeCont :: (Int -> m b) -> m b }" should work
05:42:20 <c_wraith> I think it's intended as a counterexample
05:42:53 <Gurkenglas> And in https://github.com/iphydf/hstox/blob/master/src/Network/Tox/Crypto/PublicKey.hs , "get = sizeCont $ Bytes.getByteString >=> decode" and "arbitrary = sizeCont $ fmap ByteString.pack . Arbitrary.vector >=> decode"
05:43:03 <iphy>     Could not deduce (KeyClass a0) arising from a use of ‘size’ from the context (Eq a, Sodium.IsEncoding a, KeyClass a)
05:43:09 <iphy> KeyClass is IsBox
05:43:31 <merijn> iphy: lpaste the code?
05:44:08 <iphy> http://lpaste.net/153120
05:44:17 <iphy> line 65
05:46:39 <merijn> iphy: Proxy without type annotation doesn't help, because it can't infer which proxy :)
05:46:52 <merijn> (Proxy :: Proxy Foo)
05:47:14 <iphy> right, but Foo is a
05:47:35 <iphy> and a is the type variable in the instance head
05:47:53 <iphy> which is not in scope inside the implementations
05:49:29 <merijn> I think this can be solved with ScopedTypeVariables, etc. but I have to go to class so can't look into it now
05:50:13 <iphy> get :: Get a = -- invalid declaration
05:50:59 <ggVGc> is there any common pattern for "A list of things where one is the active one"?
05:51:52 <quchen> ggVGc: A list zipper, or maybe a heap
05:52:38 <lyxia> iphy: size (Proxy :: Proxy a) -- also enable ScopedTypeVariables
05:53:33 <iphy> fascinating
05:53:37 <iphy> lyxia: that works
05:54:41 <Benzi-Junior> hey is it possible to have  a case statement with indices and catch a case of index out of bounds ?
05:55:39 <MasseR> Benzi-Junior: if I understood your question correctly, no not in haskell2010
05:56:07 <Benzi-Junior> so I have a "case list!!x of"  but need to grab the index out of bound case
05:56:07 <nrky> Hello, I am trying to parse a read command line argument to an integer. Here's the example code I am trying to compile. Any advice? https://dpaste.de/f0Y6
05:56:24 <Benzi-Junior> MasseR: damn and blast
05:56:47 <Benzi-Junior> MasseR: is it possible in a later release ?
05:57:25 <MasseR> Benzi-Junior: Not like you asked. You can make indexed types however, where the types verify that you can't go out of bounds
05:58:23 <MasseR> With DataKinds, GADTs etc 
05:58:38 <quchen> Benzi-Junior: You can write a safe version of (!!) using drop and listToMaybe.
05:58:55 <liste> nrky: case reads s of { ((val, _):_) -> ... }
05:59:24 <lyxia> iphy: It's pretty much always necessary to annotate the Proxy (otherwise it probably shouldn't be part of the API). It's a way to have a value, here size, depending on a type.
05:59:45 <Benzi-Junior> quchen: I was rather hoping to not have to do a maybe 
06:01:45 <lyxia> Benzi-Junior: case drop x list of { y : _ -> ... ; [] -> ... }
06:13:21 <iphy> lyxia: yeah, makes sense, I didn't know ScopedTypeVariables would bring the a from the instance head into the implementation's scope
06:13:32 <iphy> thanks for that puzzle piece
06:34:22 <roelof> what is a nice memory so cabal can install things well. I have now 1G but things like Yesod takes more then 30 minutes
06:34:43 <roelof> and the install is still at 50% 
06:37:14 <srhb> roelof: Yesod is rather huge.
06:37:27 <quchen> roelof: Try stack instead of cabal-install. It shares installed packages, so you don't always need to install the sandbox from scratch.
06:37:41 <srhb> Or even nix, and enjoy binary cache, though the learning curve is steeper.
06:37:43 <srhb> (A lot.)
06:38:25 * quchen hasn't installed Yesod, and is doing `time stack install yesod` for the fun of it in his setup now.
06:38:34 <srhb> "fun"
06:38:38 <srhb> :-)
06:39:03 <Rembane> Losing is fun! :D
06:39:05 <quchen> srhb: Fun
06:39:14 <quchen> Rembane: Exactly :-D
06:40:15 <bennofs> There's also a docker image with all of stackage prebuilt iirc
06:40:22 <bennofs> though it's like 10G or something
06:40:25 <quchen> roelof: Done. stack install yesod  330,05s user 17,87s system 221% cpu 2:37,05 total7
06:41:14 <bennofs> quchen: was this from a clean start or did you already have base packages cached?
06:41:51 <quchen> bennofs: That's the point, I had lots of packages in my cache. There *is* a cache. In cabal-install you have none. (You can share sandboxes, but it's something you have to do manually.)
06:42:17 <quchen> Most notably, I had the usual suspects installed already, such as lens, servant, pipes.
06:42:23 <bennofs> quchen: oh ok. so it hugely depends if you tend to use yesod's deps in your projects :)
06:42:27 <roelof> Here I also use stack. The yesod tutorial tells me to install and use stack 
06:42:51 <roelof> quchen:  how many memory do you have ? 
06:42:53 <quchen> bennofs: Sure, but I haven't done anything yesod-related, so it's nice to see how I get good sharing nevertheless
06:43:18 <quchen> roelof: 16 gig
06:43:44 <quchen> Not sure about peak usage though.
06:43:58 <quchen> The conky graph only lasts for around 3 minutes here
06:45:59 <tdammers> hmm, is it normal for stack --haddock to generate haddock for everything except the main executable of the local package?
06:49:11 <quchen> I would assume it's building only for libraries
06:49:32 <tdammers> shame
06:49:40 <tdammers> would be useful to also have haddock for the executable itself
06:49:47 <tdammers> if only for internal purposes
06:51:48 <phadej> tdammers: waiting for the pr https://github.com/commercialhaskell/stack/issues/729 :)
06:52:46 * hackagebot diagrams-pandoc 0.3 - A Pandoc filter to express diagrams inline using the Haskell EDSL _Diagrams_  https://hackage.haskell.org/package/diagrams-pandoc-0.3 (bergey)
06:53:07 <hodapp> diagrams-pandoc? that's kind of awesome.
06:54:43 <swolffs> so there's this code, basically:
06:54:57 <swolffs> nMOS e s = not (MOS e s)
06:55:04 <swolffs> this works and compiles as intended
06:55:20 <swolffs> nMOS = (not .) . MOS
06:55:22 <swolffs> does not
06:55:43 <swolffs> (ehm, s/MOS/mOS/ shortened names...)
06:55:47 <tdammers> phadej: that'd be awesome...
06:56:28 <swolffs> according to rewrite rules, and pointfree, it *should* be equivalent, but it throws type errors
06:57:01 <roelof> Chips, I have only 1G on my cloud box and 4G on my own windows box , quaestor1 
06:58:47 <swolffs> ... nvm, adding type specifications disambiguated enough to make the error disappear
07:00:12 <roelof> Someone who develop haskell on Windows ? 
07:00:59 <pavonia> I do
07:01:58 <roelof> pavonia:  which "ide"  do you use then ?  
07:02:20 <pavonia> None, just a simple text editor + ghci
07:02:57 <roelof> oke, i tried several but none of them seems to be working with stack :( 
07:03:26 <Jinxit> hence ghci
07:03:57 <swolffs> roelof: atom?
07:05:28 <roelof> swolffs:  I could not find a plugin for things like stack new, stack test  
07:07:14 <obadz> is haskell-ide-engine usable in emacs at this point? I have a working setup with ghc-mod and wondering if I should be switching
07:08:12 <schoppenhauer> hi. is there a version of ArrayMemoize with dynamic memo buffer size that extends dynamically?
07:08:44 <hexagoxel> is it really necessary to add Paths_foo to your executable's other-modules when your library already expose-modules it?
07:11:37 <srhb> obadz: I don't think so.
07:13:51 <joeyh> sm: that segfault is a known bug in the ncurses library I'm using. jmillikin fixed it on hackage, but it's not percolated into the debian packages yet.
07:14:51 <joeyh> nomeata: http://bugs.debian.org/786727
07:16:07 <nomeata> joeyh: it’s just a matter of upgrading to the latest upstream version?
07:16:23 <nomeata> (too bad ncurses is not in stackage, that would make it easier for us to know about new upgrades)
07:16:52 <joeyh> yes, I think it's just new upstream
07:20:47 <nomeata> joeyh: building...
07:20:50 <roelof> ***. now I see this in the install of yesod :  Process exited with code: ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)
07:21:20 <nomeata> joeyh: uploaded...
07:22:00 <joeyh> you rock!
07:24:02 <Eduard_Munteanu> GHC seems to ignore the PATH I set when called from cabal, any idea why?
07:24:58 <Eduard_Munteanu> e.g. if calling commands from TH
07:27:19 <p13b> hey guys im new please put me some light at future of haskell and what i can do with it and some good thing made with it ﻿
07:28:00 <p13b> hey guys im new please put me some light at future of haskell and what i can do with it and some good thing made with it ﻿
07:52:09 <lambda-11235> Parsec doesn't error if I give it a bad string like "a+)" (regex). Instead it just parses "a+" and ignores ')'.
07:53:00 <lambda-11235> Is there a way to make it error if the full string doesn't match?
07:56:05 <liste> lambda-11235: would https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Combinator.html#v:eof help?
07:56:49 <lambda-11235> Oops, I forgot I have to go, but that is it, thanks liste.
07:58:53 <tossoo> ?src ErrorT
07:58:54 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
07:59:25 <tossoo> ?src throwError
07:59:26 <lambdabot> Source not found. There are some things that I just don't know.
07:59:44 <schoppenhauer> is there a function to access the n-th element of an array, such that it returns Just ... if n is in the bounds, and Nothing when it is not?
08:00:04 <schoppenhauer> or do I have to write this myself using exception handlers (or manual bounds checkinG)?
08:00:53 <schoppenhauer> i mean, I could do manual chekcing, and then use unsafeAt
08:01:04 <schoppenhauer> but I'd guess that such a function is already predefined
08:01:28 <phadej> schoppenhauer: https://www.stackage.org/lts-5.4/hoogle?q=Ix+i+%3D%3E+Array+i+e+-%3E+i+-%3E+Maybe+e doesn't look so
08:01:48 <phadej> schoppenhauer: vector has though.
08:01:51 <schoppenhauer> strange
08:02:11 <schoppenhauer> phadej: whats the difference between vector and array?
08:02:28 <phadej> schoppenhauer: vector is int indexed array
08:03:24 <schoppenhauer> phadej: but otherwise similar?
08:03:52 <phadej> vector has more bells and whistles
08:04:02 <schoppenhauer> hm?
08:04:12 <schoppenhauer> well I only need int-indexed arrays actually.
08:04:19 <schoppenhauer> just did not know about Vector
08:04:32 <schoppenhauer> the main thing I need is ... to keep overhead small.
08:05:26 <phadej> in that aspect vector and array are similar
08:06:25 <schoppenhauer> ok. then I'll just keep array.
08:06:32 <schoppenhauer> because I've written most stuff for it .
08:06:40 <phadej> if you seek for substitute for list then I'd use vector
08:07:49 <phadej> but to original question
08:07:54 <phadej> you can use lenses
08:10:50 <ethan__> I'm trying to compile the unit tests for the happy parser generator and I'm running into a kind mismatch between boxed (*) and unboxed (#)
08:11:05 <phadej> API FutuHours.Config FutuHours.Context FutuHours.Endpoints FutuHours.PlanMill FutuHours.PlanMillUserIds FutuHours.Types Orphans Servant.Futurice Control.Lens
08:11:08 <phadej> äh
08:11:13 <phadej> > "foobar" ^? ix 4
08:11:17 <lambdabot>  Just 'a'
08:11:22 <ethan__> Happy uses the MagicHash ghc extension which I think has something to do with the problem
08:11:27 <phadej> and that would work for vector and arrays
08:11:58 <ethan__> Any insight would be great
08:29:18 <augur> what is this isomorphism?    f a -> a   ~   forall r. f r -> (r -> a) -> a
08:30:39 <johnw> augur: where did you see that?
08:31:09 <augur> johnw: i think edwardk used it in FT
08:31:16 <johnw> augur: if that were in a data constructor, it would be CoYoneda
08:31:31 <augur> ah! CoYoneda! i new it was probably yoneda-related but i didnt know how :)
08:32:39 <johnw> the "-> a" part at the end is a bit irrelevant though
08:32:44 <johnw> (on both sides)
08:32:56 <johnw> (except that it negates the construction here)
08:33:11 <johnw> anyway, see Coyoneda in the kan-extensions package
08:33:51 <johnw> (so, it's not irrelevant, but necessary in this context, it just hides the Coyoneda nature a tiny bit)
08:34:59 <augur> right, i didnt think that was relevant but i didnt know how to pull it out, since the f r -> (r -> a)   was in an arg position under the forall
08:35:26 <augur> ok so then FT uses a Coyoneda instead of a Yoneda somewhere? hmm weird
08:35:44 <augur> i wonder why. ill have to puzzle about this a bit
08:35:55 <johnw> Coyoneda is a pairing of f r and r -> a under a forall r binder
08:36:05 <augur> *nod*
08:36:26 <johnw> these are, in effect, the arguments to a future call to fmap
08:36:35 <augur> right
08:36:37 <johnw> Yoneda is a closure over a past call to fmap
08:36:41 <johnw> making it the dual
08:38:34 <johnw> augur: one nice thing that Coyoneda does is defer the Functor constraint until the very end, since you can effectively "fmap" by simply composing functions onto the r -> a function without actually using fmap.  You only need fmap at the time you want to reduce to f a
08:38:46 <augur> indeed
08:38:54 <johnw> ok, you got it then :)
08:38:55 <augur> i think ive read that somewhere, about cheating w/ functoriality
08:39:04 <augur> probably in a kmett talk :)
08:39:23 <johnw> it's a trick that Oleg has been using recently too, for his "Freer monad"
08:40:37 <yellow_apple> hi
08:41:37 <yellow_apple> what is the simplest way to just get seconds of current minute?
08:45:16 <lpaste> glguy pasted “seconds in current minute for yellow_apple” at http://lpaste.net/153125
08:45:56 <augur> johnw: aha right so:   Coyoneda f a  ~  exists r. (r -> a, f r)    so    f a -> a  ~  Coyoneda f a -> a  ~  (exists r. (r -> a, f r)) -> a   and then currying twice we get   forall r. (r -> a) -> f r -> a
08:46:08 <augur> so   f a -> a   ~   forall r. (r -> a) -> f r -> a
08:47:05 <johnw> right
08:47:26 <johnw> without the "-> a", you wouldn't have the currying
08:47:36 <augur> right
08:47:48 <Nublet> hello everyone
08:47:48 <augur> so that expplains why FT has the definition it has! :)
08:49:00 <augur> going by the associated blog posts, it *ought* to be that    FT f m a  =  forall r. (a -> m r) -> (f (m r) -> m r) -> m r    or something like that, i think
08:49:21 <Nublet> anyone knows what happens when case guards are not exhaustive? Are the rest of the cases tried?
08:49:28 <augur> but in fact it's   FT f m a  =  forall r. (a -> m r) -> (forall x. (x -> m r) -> f x -> m r) -> m r
08:49:37 <augur> and i was perplexed by the forall x part in the middle
08:49:44 <johnw> ah, right
08:49:52 <augur> but!   forall x. (x -> m r) -> f x -> m r   ~   f (m r) -> m r    by coyoneda :)
08:49:59 <johnw> Ed used that particular trick at that place to change the GHC role for that f (m r)
08:50:12 <augur> i see
08:50:19 <augur> well now i have to puzzle about how to use this damn thing :)
08:50:35 <johnw> it's just a final encoding for free with a Coyoneda transformation
08:50:46 <augur> yeah
08:50:49 <johnw> meaning, it's isomorphic to FreeT
08:50:51 <augur> well, FreeT, in this case, but
08:51:07 <johnw> augur: see https://github.com/ekmett/free/issues/86
08:51:55 <augur> indeed!
08:52:04 <augur> hm. well time to puzzle over this a bit
08:52:22 <augur> f a -> a   i know how to use, but not so much the transformed version
08:52:27 <lpaste> acarrico pasted “Monadic Parsing in Haskell” at http://lpaste.net/153126
08:52:49 <acarrico> hey all, new to haskell and tired of 8+4 at the repl, so I'm trying the parser paper (see paste).
08:53:02 <acarrico> Can anyone translate the error message for me?
08:53:06 <augur> like, using Church encodings can be made "intuitive" because they're morally just a kind of pre-applied recursive, so you can fake a kind of case with them
08:53:27 <glguy> acarrico: You need to define: instance Applicative Parser, and instance Functor Parser
08:53:35 <johnw> augur: well, Church encoding specifically don't allow case
08:53:41 <johnw> augur: for that, you'd use a Scott encoding
08:53:50 <glguy> acarrico: This is because class Applicative m => Monad (m :: * -> *) and class Functor f => Applicative (f :: * -> *)
08:53:55 <augur> johnw: well, no what i mean is
08:53:57 <johnw> Church encoding are just folds, so they've erased all knowledge of structure
08:54:18 <augur> you can pretend you have a 'rec' combinator instead of a 'case' combinator that's just like case only it's for recursors not case-ors
08:54:43 <lpaste> glguy annotated “Monadic Parsing in Haskell” with “Monadic Parsing in Haskell (annotation)” at http://lpaste.net/153126#a153127
08:54:47 <johnw> augur: btw, I'm working on a library that uses TH to auto-generate Church encoding and their corresponding isomorphisms
08:55:13 <augur> eg   f xs = case xs of { [] -> n ; x:xs' -> g x (f xs') }    ~>    f xs = runChurch xs  {- [] -> -} n   (\x rec -> g x rec)
08:55:40 <bitemyapp> johnw: ooooooooooohhhhh
08:55:43 <augur> you can think about Church with a kind of "normal" set of tools
08:55:52 <bitemyapp> johnw: please post that prominently when you do
08:56:04 <johnw> bitemyapp: ok, sure; I had no idea there'd be actual interest in it
08:56:16 <bitemyapp> johnw: well, it ties into something else
08:56:19 <augur> johnw: or more elegantly, if you're using Free/Fix type data:    runChurch xs (\case { Nil -> n ; Cons x rec -> g x rec })
08:56:36 <bitemyapp> johnw: I didn't put it in the book because of the prerequisites, but I've had this idea for teaching certain things by writing TH/Generics for them.
08:56:50 <augur> because runChurch xs :: (ListF r -> r) -> r
08:56:58 <acarrico> glguy: hmm, they don't seem to show instance Functor Parser in the paper. Does anyone know of a source for the source? The uri in the poper is dead. Thanks for annotating my paste!
08:57:06 <bitemyapp> johnw: and I hadn't thought to apply this to church encodings until you mentioned it. So yes. Strong interest.
08:57:11 <augur> but with this coyoneda encoding, i dont know what the right "intuitive" way to code is
08:57:11 <acarrico> oops, paper.
08:57:17 <augur> johnw: does that make some sense?
08:57:18 <johnw> bitemyapp: ok, I'll clean it up and post it then, thanks for the encouragement
08:57:35 <bitemyapp> johnw: thank you for validating the idea!
08:57:37 <glguy> acarrico: In the past Applicative was not a superclass of Monad, but starting in GHC 7.10 it is
08:57:52 <bitemyapp> johnw: it's something I might turn into a monograph for intermediate/advanced folk if I can figure out a good sequence.
08:58:01 <lpaste> Nublet pasted “Non-Exhaustive Case Guards” at http://lpaste.net/153128
08:58:05 <acarrico> glguy: Ah. I see.
08:58:21 <bitemyapp> johnw: I think it'd help me firm up my ability to translate datatypes into their church encodings too.
08:58:34 <acarrico> glguy: I guess perhaps I should revist this when I have a bit more experience.
08:59:52 <johnw> bitemyapp: I've also been developing an "isomorphism workshop" in Coq, that uses plain rewriting to prove isomorphisms, and I wanted to do a companion article showing how simply every plain ADT forms its Church encoded form.  That is, you first de-tag the plain ADT into an algebraic composition of sums, products and exponentials; and then you use high school algebra to flatten out sums. That gives you the Church encoding.
09:00:11 <augur> johnw: auto-church would be cool
09:00:43 <johnw> augur: I'm not sure yet if that makes sense, without working it through
09:00:57 <cmotoche> Hello everyone. I'm having a problem hspec-discover when I run a project in travis with the version 7.4.2 and 7.6.3. Is there a way to run these test without hspec-discover. The problem is: "ghc: could not execute: hspec-discover"
09:01:11 <augur> johnw: well, it's just, normally church encodings are kind of hard to make sense of, but if you know that they're pre-applied folds, it's easy
09:01:38 <augur> johnw: because you just have to be able to think in folds!
09:02:19 <augur> and you get some nice cheap syntax if you use the F-algebraic fold, too, b/c you can use constructors to distinguish cases
09:02:26 <augur> thats all i mean
09:04:19 <lllshamanlll> Say i've stream of bytes & i wanna get stream of integers. Known, that in this particular case sum of every 3 sequential bytes in input stream produces one integer value for output stream. What's most idiomatic way to implement this behavior?
09:07:41 <liste> > let f (x:y:z:rest) = (x+y+z):(f rest); f _ = [] in f [5,34,2,7,531,3,4,673,4,16,31,2,3,613,5,4,31,5] -- don't know if idiomatic but this is simple at least
09:07:44 <lambdabot>  [41,541,681,49,621,40]
09:08:57 <liste> > let f (x:y:z:rest) = (x+y+z):(f rest); f _ = [] in f [1,2..]
09:09:07 <lambdabot>  [6,15,24,33,42,51,60,69,78,87,96,105,114,123,132,141,150,159,168,177,186,195...
09:09:48 <geoffreyiy> @pl (all id)
09:09:49 <lambdabot> and
09:15:30 <quchen> > (map sum . chunksOf 3) [1..] -- liste
09:15:36 <lambdabot>  [6,15,24,33,42,51,60,69,78,87,96,105,114,123,132,141,150,159,168,177,186,195...
09:16:02 <liste> where's chunksOf ?
09:16:10 <quchen> Data.List.Split I think
09:16:29 <gipp> it's not in base last i checked
09:16:33 <liste> in the split package?
09:16:38 <gipp> yeah
09:20:54 <quchen> Hm, I don't see a straightforward lens to do this.
09:22:14 <quchen> If you don't want to use chunksOf, you can also pray to Zipaptail.
09:22:30 <quchen> Ah nevermind, it's chunking, not a running average.
09:22:39 <quchen> s/average/window/
09:24:41 <Geraldus> Hi folks!
09:24:45 <dmj`> Geraldus: hi
09:25:15 <Geraldus> In there some function to split list in groups on N items, e.g. group :: Int -> [a] -> [[a]]?
09:25:34 <Geraldus> s/on N/of N
09:25:56 <Geraldus> s/in/into :D
09:28:55 <ClaudiusMaximus> Geraldus: there's chunksOf in the split package
09:30:03 <dmj`> :t splitOn 
09:30:06 <lambdabot> Eq a => [a] -> [a] -> [[a]]
09:30:09 <ClaudiusMaximus> Geraldus: http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html#v:chunksOf
09:30:21 <dmj`> :t chunksOf
09:30:28 <lambdabot> Int -> [e] -> [[e]]
09:30:37 <Geraldus> ClaudiusMaximus: thanks, Hackage lacks of docs for recent version BTW
09:30:46 <Geraldus> http://haddock.stackage.org/lts-5.4/split-0.2.3/Data-List-Split.html
09:31:50 <ClaudiusMaximus> Geraldus: i know, that's why i linked the previous version with docs (latest docs pending for six weeks, slow hackage doc builder..)
09:32:17 <ClaudiusMaximus> Geraldus: good to know about hte stackage version too though
09:32:41 <Geraldus> Ahh, I didn't spotted you have linked 0.2.2 version
09:33:26 <Geraldus> anyway, thank you, now I need to decide should I add slice to dependencies for single function :D
09:37:27 <cocreature> Geraldus: it’s also in extra not sure if that is a bigger or a smaller dep
09:37:57 <Geraldus> cocreature: didn't catch
09:38:21 <EvanR> so in what way is "TH now type safe"
09:39:06 <EvanR> split is a pretty common need for doing list splitting
09:39:18 <Geraldus> EvanR: thanks
09:39:27 <EvanR> chunksOf isn't the most fun function to write yourself
09:39:35 <Geraldus> yep ))
09:40:52 <ClaudiusMaximus> EvanR: it's not so bad, recursing with splitAt, if that's all you need from split the 3 lines (including type annotation) are probably less pain than adding to the deps
09:40:55 <greg`> hey how big is stackage and can it be downloaded?
09:41:12 <Geraldus> and it is in Stackage also
09:41:44 <Geraldus> I believe about 20GiBs
09:41:55 <Geraldus> if I recall correctly
09:41:58 <EvanR> paid of added a package to the deps list, vs pain of finding the code in the dep source itself and then copy pastaing ;)
09:42:37 <greg`> is there a mirror of stackage thats not on s3?
09:42:39 <EvanR> vs the pain of actually writing out the function in boring fashion
09:47:16 <doudou> Haskell.org server status  All Systems Operational  Updated 7 months ago
09:47:53 * hackagebot btrfs 0.1.2.0 - Bindings to the btrfs API  https://hackage.haskell.org/package/btrfs-0.1.2.0 (MariosTitas)
09:48:09 <andromeda-galaxy> by the way, does anyone know why the hackage docs builder seems to be slow relatively suddenly?  until a few months ago, I barely ever used to see packages without built docs
09:48:13 <doudou> all dead since more than 3 month
09:48:31 <davorb> hello. 
09:48:43 <geekosaur> doudou, #haskell-infrastructure
09:48:47 <davorb> is there any scraper library that will take care of csrf form protection?
09:50:03 <doudou> geekosaur: it is the word status, it has another meaning in my childhood
09:53:25 <geekosaur> doudou, you can nag abut it where nobody has any control or you can ask in the place where the people who run things are
09:54:53 <gipp> hah i thought you were just making a snarky hashtag joke, not pointing to an actual channel. twitter has ruined everything
09:55:49 <EvanR> not a "hashtag" -->#haskell
09:56:37 <johnw> bitemyapp: interesting thing my library just told me: the Church encoding of Void is "forall a. a" :)
09:57:01 <doudou> I was just checking my childhood
09:57:11 <bitemyapp> johnw: it's not wrong
09:57:16 <johnw> i know!
09:57:19 <bitemyapp> cheeky tho, lol
09:57:23 <bitemyapp> that's really cool :)
09:57:52 <bitemyapp> johnw: does that mean church encodings are less expressive than ADTs tho?
09:58:07 <johnw> they forget the ADT structure
09:58:18 <crough> bitemyapp: Aren't they secretly isomorphic?
09:58:32 <johnw> but yeah, they're isomorphic, so you can convert back
09:58:43 <johnw> so I guess they don't forget the structure, never mind me
09:58:52 <crough> johnw: They forget naming 
09:59:26 <greg`> if they are isomorphic then they couldnt lose anything surely
09:59:32 <crough> but `newtype Either e a = Either (forall c. (e -> c) -> (a -> c) -> c)
09:59:36 <bitemyapp> they're structurally isomorphic
09:59:41 <bitemyapp> but not names
09:59:52 <crough> greg`: The names are syntax and don't apply :)
09:59:55 <doudou>   echo "The directory / is not writable. Please run this script as root."
10:00:04 <greg`> ah
10:00:46 <doudou> are you a sect? or something like that?
10:00:59 <glguy> doudou: Did you have another question about Haskell programming?
10:01:13 <monochrom> an isomorphism may forget things not preserved by the isomorphism  </tautology>
10:03:24 <doudou> I came because, four years ago at least, in a despair mood i bought haskell real world oreilly. my question is how i get the 4 nice ghc ghci runghc the book spoke?
10:03:48 <doudou> another questions probably, but questions is nothing, answers that the point
10:04:23 <srhb> doudou: They come with ghc. 
10:04:47 <srhb> I'm not sure what the recommended way of acquiring it is these days -- it probably depends on your operating system of choice too.
10:04:56 <doudou> i tried http://downloads.haskell.org/ downloaded haskell platform, but i must admit platform does not speak to me
10:05:17 <doudou> i have linux kinux only
10:05:17 <srhb> doudou: You could probably go with Stack.
10:05:41 <greg`> i hate my macbook, it suggested i upgrade to elcapitan, then it wiped my linux dualboot
10:05:48 <srhb> doudou: http://docs.haskellstack.org/en/stable/README/
10:06:00 <greg`> cant hack haskell like i was doing before, so annoying
10:06:13 <kadoban> greg`: Oh noes.
10:07:14 <doudou> so i downloaded  HaskellPlatform-7.10.3-x86_64-setup.exe  a big mistake of my part then, haskell-platform-7.10.3.tar.gz but it want cabal??? and then haskell-platform-7.10.3-unknown-posix-x86_64.tar.gz who wants root power and probably informations about my wife too
10:07:39 <srhb> doudou: I think Stack is available for Windows, too.
10:07:42 <mnoonan> doudou: just get stack, it'll handle everything (including installing appropriate ghc versions) for you
10:07:42 <doudou> http://docs.haskellstack.org/en/stable/README/ thanks, look better for me
10:07:54 * hackagebot userid 0.1.2.5 - The UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.2.5 (JeremyShaw)
10:08:23 <dcoutts> doudou: what was wrong with the HP exe? it afterall includes ghc etc
10:08:24 <johnw> bitemyapp: in case you want to play around: https://github.com/jwiegley/recursors
10:08:25 <srhb> doudou: But in all honesty I think everything is a little more difficult on Windows, or at least it has been.
10:09:57 <EvanR> so when I runQ in ghci and I get a displayable Exp or something, does that mean it has picked m (from Quasi m =>) to = IO ?
10:10:13 <monochrom> I think so
10:10:18 <EvanR> can i get one of these Exp objects in pure code
10:11:01 <EvanR> i cant implement the runIO aspect of the Quasi class
10:12:39 <glguy> You're asking if it's possible to write a function :: Q a -> a ?
10:12:51 <glguy> or at least specifically Q Exp -> Exp?
10:12:54 * hackagebot users-persistent 0.5.0.1 - A persistent backend for the users package  https://hackage.haskell.org/package/users-persistent-0.5.0.1 (AlexanderThiemann)
10:12:56 * hackagebot users-postgresql-simple 0.5.0.1 - A PostgreSQL backend for the users package  https://hackage.haskell.org/package/users-postgresql-simple-0.5.0.1 (AlexanderThiemann)
10:13:27 <EvanR> im trying to write a function Q Exp -> Q Exp and then at the use site use $( ) on the result
10:13:45 <bitemyapp> johnw: thank you :)
10:14:02 <EvanR> i see, i guess i need to do it all in the monad
10:15:28 <doudou>  tc@box:/tmp/stack-1.0.4-linux-x86_64$ ./stack ghci         Populating index cache ...stack: out of memory (requested 2097152 bytes)     tc@box:/tmp/stack-1.0.4-linux-x86_64$
10:18:07 * hackagebot happstack-server 7.4.6.1 - Web related tools and services.  https://hackage.haskell.org/package/happstack-server-7.4.6.1 (JeremyShaw)
10:18:10 * hackagebot publicsuffix 0.20160223 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160223 (wereHamster)
10:19:49 <srhb> doudou: Working with ghc usually requires quite a bit of memory. How much do you have?
10:28:09 * hackagebot cpsa 3.3.0 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-3.3.0 (mliskov)
10:29:50 <cmotoche> Hello everyone, do you know how to install GHC 7.6.3 with Stack?
10:31:50 <johnw> bitemyapp: achievement unlocked: you've nerd-sniped me using my own project :)
10:32:30 <srhb> cmotoche: Isn't 7.8.something the earliest one?
10:32:51 <bitemyapp> johnw: *flexes bicep*
10:33:01 <kadoban> cmotoche: I don't think it can, that was before stack's time.
10:33:32 <johnw> bitemyapp: I'm now looking at auto-generating the Arbitrary instance (when appropriate) and the QuickCheck properties to test the isomorphism
10:33:41 <bitemyapp> that's...really cool.
10:33:59 <johnw> otherwise, my tests will consist of reading splice dumps, which is sub-optimal
10:34:06 <doudou> srhb i saw the size of a javascript interpreter is nothing, i beleive haskell performant, but if he want to play wondows, it will be without me
10:34:31 <cmotoche> Oh, ok. Thanks.
10:34:42 <bitemyapp> johnw: I wish core and splices were easier to read.
10:34:49 <bitemyapp> johnw: -dsuppress-all only goes so far.
10:34:53 <johnw> true
10:35:00 <bitemyapp> x-ray vision mode in haskell-mode would be nice.
10:35:02 <srhb> doudou: Poor performance or memory usage of a compiler does not mean that the programs it can generate will be non-performant or wasteful. :)
10:35:08 <bitemyapp> "okay now show me what this piece of code turns into"
10:35:17 <bitemyapp> and then it goes to specifically where in the Core that code lands.
10:35:23 * bitemyapp puts on John Lennon's Imagine
10:35:28 <srhb> doudou: (And Haskell can be very performant indeed.)
10:35:34 <MarcelineVQ> bitemyapp: That would be without optomization?
10:35:55 <MarcelineVQ> There's a few passes into core even without that
10:36:23 <bitemyapp> I just want to be able to read more easily what simpl dumps without manually scrolling in GHCi for the code I was trying to see the simpl-of
10:36:34 <bitemyapp> splitting code into a separate module just so I don't get spammed with Core sucks
10:36:41 <MarcelineVQ> hmm
10:36:43 <srhb> bitemyapp: I would love that feature.
10:36:46 <doudou> yes bit gcc compile much many language, and haskell should be very minimalist, something is broken
10:36:54 <bitemyapp> see? srhb understands my pain.
10:36:58 <bitemyapp> my psychic agony. despair.
10:37:12 <bitemyapp> MarcelineVQ: you know it'd be sweet
10:37:19 <srhb> doudou: GHC is one of the more complex compilers, I think of all of them. But sure, if you don't want to, don't feel obliged to play with it. :)
10:39:03 <levi> doudou: Why do you say haskell should be minimalist?
10:39:26 <crough> doudou: The language is pretty slim, but the compiler is crazy good at optimizing and type checking.
10:46:52 <doudou> is there another version? so i can read my book? I have 500M memory
10:47:56 <glguy> doudou: Does runing "stack exec ghci" instead of "stack ghci" work for you?
10:49:13 <glguy> GHCi on its own doesn't need as much memory to start-up as stack needs to do its index population step
10:49:36 <glguy> and you don't have to use stack to use/learn Haskell
10:51:19 <Gurkenglas> Looking at https://github.com/ghc/ghc/blob/master/ghc/Main.hs . This looks like it hasn't gone through basic usage-of-libraries refactoring. Are people careful about conserving behavior, or would there be a lot of politics behind changing any line, or what?
10:52:35 <sclv> for those that are interested, cloud.sagemath.com provides a unix repl with ghc installed (albeit not the most recent version)
10:52:36 <Gurkenglas> (Things like that 106-116 look like the standard usecase for StateT)
10:52:55 <sclv> if you're just trying haskell and on a resource-constrained machine, then it is a nice option
10:53:23 <Gurkenglas> Yusssss! How much would it cost for someone to set up something like that with the latest version?
10:54:32 <glguy> Gurkenglas: You'd get pushback trying to replace that code with StateT even if it wasn't in GHC
10:54:55 <doudou> same, need more place, cant run in memory, i dislike his way to download things ... i downloaded 3 days ago a javascript interpreter that can be embedded in C programms it was very very small
10:55:03 <Gurkenglas> Huh? Why?
10:56:01 <sclv> doudou: try cloud.sagemath to do it all online in the cloud
10:56:39 <glguy> Gurkenglas: It's not an improvement to do so
10:57:01 <doudou> thanks, i will try to find usb with 2G free
10:58:36 <Gurkenglas> Can you make an operator have a low precedence on the right but a high precedence on the left?
11:02:08 <Gurkenglas> glguy, how about something to keep lines 136 and 150 left-aligned so we don't need to call main'?
11:02:33 <aep-shoutlet> what's a decent filo/lifo queue in haskell?
11:02:47 <Gurkenglas> It's called []
11:02:53 <aep-shoutlet> lel
11:03:50 <pdxtech> What was that new dvcs that sounded kinda like darcs?
11:06:29 <crough> glguy: Why not just use an `MVar [a]`?
11:07:33 <glguy> crough: Dunno, not following that thread
11:08:02 <TimoMeijer> I'm trying to create Chess in Haskell, is there a way to represent the bounded indices of the board in a typesafe manner?
11:08:11 * hackagebot clckwrks 0.23.14 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.14 (JeremyShaw)
11:08:19 <aep-shoutlet> i thought appending to the end of a (singly) linked list is expensive, so [some large list] ++ [new elements] gets pretty slow, no?
11:09:08 <Walther> aep-shoutlet: iirc you could use Data.Sequence, which can be used like a list but it's internally more optimized
11:09:08 <Gurkenglas> Right, but you don't append to the end of a filo, you append to the front
11:09:14 <Walther> using finger trees
11:10:16 <Walther> might not be relevant to your specific usecase, but just that appending to end of a list doesn't /have/ to be expensive, if you use a different type of a list
11:11:34 <aep-shoutlet> Walther: right, so i'm looking for a data structure where pop and append are cheap
11:12:29 <dmj`> TimoMeijer: you could use type level nats, in fact, you could probably encode all valid moves a piece can make at the type level
11:13:10 <TimoMeijer> dmj`: Any pointers to where I can read up on this?
11:13:48 <dmj`> > natVal (Proxy :: (Proxy (1 + 1)))
11:13:54 <lambdabot>  Not in scope: ‘natVal’Not in scope: type constructor or class ‘+’
11:14:59 <infandum> Can I use `over` from lens on multiple things at once so I can use conditional setting? Like, over (this, that) (\(x, y) -> if y > 10 then (x, y + 1) else id)
11:15:31 <dmj`> TimoMeijer: I'd check out the GHC.TypeLits module from base, https://hackage.haskell.org/package/base-4.8.2.0/docs/GHC-TypeLits.html, then maybe the singletons package and the papers around it. There are 
11:15:33 <infandum> Obviously not exactly that but is there something with that functionality?
11:15:39 <dmj`> TimoMeijer: this is helpful too, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-level-literals.html, from the user guide
11:16:06 <TimoMeijer> dmj`: Thanks! Looks awesome
11:16:28 <dmj`> TimoMeijer: then you'll probably want to read up on 'promotion' 
11:16:42 <Walther> aep-shoutlet: in that case, Data.Sequence might actually work for you
11:16:45 <dmj`> @google giving haskell a promotion
11:16:54 <lambdabot> http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
11:16:57 <lambdabot> Title: Giving Haskell a Promotion
11:17:57 <Walther> aep-shoutlet: https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Sequence.html appending and reading from either end is O(1)
11:18:34 <dmj`> TimoMeijer: the paper is really dense, this video is really helpful in understanding the package in a more digestible way, https://www.youtube.com/watch?v=J47OTYArG08
11:18:37 <Walther> aep-shoutlet: and concatenating two sequences is O(log(min(n1,n2)))
11:19:11 <infandum> Nevermind, I didn't need it. Sorry!
11:28:12 * hackagebot opml-conduit 0.5.0.0 - Streaming parser/renderer for the OPML 2.0 format.  https://hackage.haskell.org/package/opml-conduit-0.5.0.0 (koral)
11:30:22 <js__> New to FRP and am learning Netwire.  I'm considering forking Netwire to prevent it from becoming abandonware.  It hasn't been updated since late 2014 and it'd be convenient to use it with LTS.  I've tried contacting the author.  Any thoughts?
11:43:07 <cocreature> is there a useful generalization of zipWith to (a -> b -> c) -> f a -> f b -> f c. I found https://hackage.haskell.org/package/keys-3.11/docs/Data-Key.html#t:Zip but that has no laws. I was hoping for something with a bit more “structure”
11:43:56 <Hijiri> something less general than applicative?
11:44:44 <cocreature> Hijiri: ah right applicative sounds good. sometimes I miss the obvious things :)
11:44:52 <Hijiri> though you might not need pure
11:44:55 <sLite> hmm, tasty or only hspec
11:44:55 <Hijiri> if you just want zipping
11:45:07 <cocreature> yeah
11:45:13 <cocreature> there is Apply somewhere
11:45:14 <sLite> any thoughts you can provide on that decision?
11:45:16 <Hijiri> PureScript has the Apply typeclass
11:45:23 <cocreature> semigroupoids
11:48:13 * hackagebot clckwrks-plugin-page 0.4.3.1 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.1 (JeremyShaw)
11:48:51 <Cale> :t liftA2
11:48:54 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:49:42 <Cale> Often that won't be "zippy" though
11:50:12 <Gurkenglas> In "lens :: Functor f => (s -> a) -> (s -> b -> t) -> Lens s t a b", why isn't it (b -> s -> t)?
11:50:43 <Ankhers> I'm trying to use pipes-csv to read a CSV file and place the data into a database using Persistent / Esqueleto. Would anyone have an example of doing something like this?
11:51:02 <phadej> Gurkenglas: it's easier to have `s` as first argument in both
11:51:02 <Gurkenglas> Hijiri, ZipList has pure.
11:51:08 <phadej> @src lens
11:51:09 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
11:51:26 <Gurkenglas> phadej, easier how? I'd think the s should be the last argument in both
11:52:38 <cmotoche> Do you know about a library to get information from a system (like the battery level, if it is charging or no, the screen brightness and so on)?
11:56:06 <Gurkenglas> :t lens ((,) <$> (^. _1) <*> (^. _2)) (\s (x, y) -> s & _1 .~ x & _2 .~ y) -- The other way round would allow to eta-reduce s away
11:56:09 <lambdabot> (Functor f, Field2 s s a a, Field2 s1 t a2 b1, Field1 s s a1 a1, Field1 s s1 a1 b) => ((a1, a) -> f (b, b1)) -> s -> f t
11:57:37 <gipp> cmotoche: unix and/or X11 for system-specific implementations
11:57:42 <phadej> :t _1 <> _2
11:57:44 <gipp> i don't know if there's a system-agnostic package
11:57:54 <lambdabot> (Functor f, Monoid (f t), Field2 s t a b, Field1 s t a b) => (a -> f b) -> s -> f t
11:58:02 <phadej> hmm.. lemme think
11:58:15 <deni> so when using wreq it throws an exception on every non 2xx response or other obvious things like connection refused etc... if using it in your library would you say it's a good idea to catch those exceptions and return an Either instead?
11:58:16 <cmotoche> Thanks gipp
12:00:17 <Gurkenglas> :t lens ((,) <$> view _1 <*> view _2) $ flip (\(x, y) -> set _1 x . set _2 y) -- (tada)
12:00:21 <lambdabot> (Functor f, Field2 s s a1 a1, Field2 s s1 a1 b2, Field1 s s b b, Field1 s1 t a b1) => ((b, a1) -> f (b1, b2)) -> s -> f t
12:00:25 <geekosaur> cmotoche, the only such library I'm aware of that makes any attempt at portability is libgtop. its license generally is considered problematic enough that it is avoided by non-GNU suff
12:01:49 <Gurkenglas> (Of course lenses only combine like this iff set _1 x and set _2 y commute.)
12:02:00 <Nublet> guys any theory-base resources on why not all arrows are monads?
12:03:02 <crough> Nublet: All ArrowJoin are.
12:04:06 <crough> They just don't have any means to join on themselves without that.
12:05:12 <Nublet> thanks, I will check out ArrowJoin
12:05:30 <phadej> ah, now I remember. You cannot easily make product lens from two arbitrary lenses, as you can easily break the laws
12:06:32 <phadej> ... if they point to overlapping parts in the structure
12:06:47 <Gurkenglas> Right: If set _1 x and set _2 x don't commute
12:06:53 <Gurkenglas> *y
12:07:18 <newsham> is there a showCReal type func to show CReal's in hex?
12:09:20 <crough> Nublet: Oops I meant ArrowApply :)
12:09:30 <crough> Nublet: Got my Arrow and Monad terminology mixed up there
12:09:58 <Nublet> yea figured something must be wrong after 0 search results
12:12:23 <Nublet> argh this is going to be a bit hard grok today. I am trying to understand how the additional laws allow us to derive bind.
12:12:54 <crough> Nublet: I usually figure it out by just trying to implement it
12:26:21 <Nublet> Maybe I'll do just that. Pretty new to haskell so I understand them intuitively and can use them but I have yet to go into that depth.
12:37:44 <black0range> Hey guys If i want to make my own graph implementation and add edges in a way such that a node has a list of references to other nodes. like data Node = Node [Node] how do i get around the immutability? 
12:39:02 <osfameron> black0range: put the links in a Map Node Node ?
12:39:09 <Cale> black0range: Perhaps consider Map Vertex [Vertex] or  Map Vertex (Set Vertex)
12:39:29 <Monkey_> test
12:40:06 <osfameron> what's the best way to get vim's :make to do something useful in a stack project?
12:40:20 <osfameron> e.g. write a Makefile?  download a Vim plugin for haskell/stack?  etc.?
12:40:50 <Cale> I use vim, but I have no idea, since I just don't use that command
12:41:00 <Cale> Usually I just keep another terminal window open for building
12:41:03 <mauke> osfameron: you can :set mp
12:41:12 <mauke> I don't know stack, though
12:41:32 <hodapp> can :make just run a command?
12:41:40 <hodapp> that's what I did in Emacs with M-x compile
12:41:44 <mauke> yes
12:41:45 <gipp> osfameron: if you use neovim or are open to it check out Neomake
12:41:57 <mauke> mp tells it which command
12:42:02 <osfameron> ah.  I saw a reference to it being a common way of editing Haskell with vim, but can't find a recipe that works out of the box
12:42:06 <Monkey_> It's all haskell
12:42:09 <Monkey_> https://gist.github.com/quchen/5280339
12:42:09 <osfameron> I guess I can get it to use `stack test`
12:42:12 <Monkey_> VIVA LA HASKELL!
12:43:21 <mauke> I've done :set mp=ghc\ % for simple stuff
12:43:41 <gipp> osfameron: what exactly do you want :make to be able to do?
12:43:56 <osfameron> gipp: basically open up a quickfix window if there are failures
12:44:01 <gipp> osfameron: Neomake makes it easy to do stuff like HLint/HDevtools with inline warnings/errors
12:44:24 <gipp> asynchronously too, which is nice
12:45:30 <osfameron> ah yes, that's the advertised advantage of neovim
12:45:37 <gipp> though typically I still keep a separate terminal open with `stack test --file-watch`
12:45:40 <osfameron> unsure whether to play wih that or spacemacs though...
12:45:51 <osfameron> oh, cute, didn't know about that
12:46:20 <osfameron> anyway, :set makeprog=stack\ test    seems to work for now
12:47:00 <mauke> if you use neovim, you run some of my code :-)
12:47:25 <gipp> mauke: well thanks for your effort, makes my life a little easier :)
12:47:38 <mauke> (it uses unibilium to read terminfo files)
12:54:03 <crough> osfameron: I used spacemacs for a really, really long time
12:54:15 <crough> osfameron: But it crashes for no reason FREQUENTLY and uses ~400mb ram
12:54:24 <crough> osfameron: Neovim has treated me much better
13:02:27 <mick> Hi, What is the semantic difference between the following two declarations:      data Foo = Foo [Double]          data Foo = [Double]  When do I use one over the other?
13:03:30 <gipp> mick: the second one is not a valid data declaration
13:03:32 <mauke> one of them is not a syntax error
13:03:41 <mick> whoops
13:04:05 <mnoonan> do you mean "type Foo = [Double]" for the second?
13:04:07 <mick> sorry guys, noob mistake
13:04:08 <monochrom> also do you mind not calling both Foo? while we're at it
13:04:38 <mick> i thought i typed that second one in ghci and it was fine
13:05:10 <monochrom> ok, if you like to call them both Foo, then I will stick to it.
13:06:14 <monochrom> firstly Foo is considered a different type from [Double] (think of nominal typing), but Foo is considered the same type as [Double], i.e., interchangeable.
13:06:19 <Ankhers> I'm trying to use the pipes-csv library. The decodeByName function requires a `Producer ByteString m ()` to be passed in. I am unsure how to create this. I tried `return $ C.pack "my byestring", but I'm getting a type error (http://lpaste.net/153141). Would anyone be able to point me in the right direction?
13:06:45 <monochrom> secondly "Foo undefined" is a non-bottom value for Foo, but there is no such thing for Foo.
13:06:52 <obk> Trying to upgrade a package to use stack, if I specify Cabal-Version: >= 1.8 then base-4.8.2.0 becomes hidden, so doesn't build; if I specify Cabal-Version: >= 1.6, it builds, but can't build sdist (because I use a test-suite section). Ideas?
13:08:11 <mauke> Ankhers: that sounds like 'return ()' would typecheck but also be useless
13:08:57 <Ankhers> mauke: Agreed. This is my first adventure into Haskell streaming libraries and I seem to hit a wall pretty fast :(
13:09:20 * mauke rtfm to see what a Producer is
13:09:47 <mauke> "Use yield to produce output"
13:10:05 <mauke> so have you tried 'yield (C.pack "...")'?
13:12:46 <Ankhers> That makes sense. I think I misunderstood the way yield works in this scenario. Unfortunately, I'm now getting a different error. One sec and I will paste that.
13:13:10 <Ankhers> http://lpaste.net/153142
13:14:18 <lyxia> Ankhers: this doesn't look like the right yield
13:14:26 <mauke> oh, wrong yield
13:14:44 <mauke> yours is from Control.Concurrent
13:14:48 <gipp> obk: not sure why base would be hidden. looks like 1.8 made dependencies component-specific; does every component have a base-4.8.2 dependency listed?
13:14:51 <Ankhers> lyxia: Thanks for that!
13:14:52 <mauke> you want the one from Pipes
13:16:41 <obk> gipp: Ah, I get it. I have a library and an executable (and a test). In 1.6, dependencies in the library are enough. In 1.8 I need to re-list some of them in the executable and test. Thanks!
13:18:05 <shachaf> obk: hi
13:18:55 <obk> shachaf: ho. Trying to drag yamlreference to the brave new world of stack. Seems cabal has changed semantics.
13:23:59 <Ankhers> mauke, lyxia: Thanks for the help. I think I have it working now.
13:26:29 <osfameron> woohoo! I used a list monad. https://gist.github.com/osfameron/4b5d9954e742110bd4ac
13:27:21 <lyxia> you won't be able to stop now
13:28:10 <osfameron> :-)
13:29:17 <osfameron> with using an accumulator, it feels like I could abstract it further into a fold?
13:29:31 <osfameron> but that's hurting my head
13:31:21 <lyxia> what does it do
13:31:41 <osfameron> sorry, I didn't quite give the example in the gist
13:32:06 <osfameron> but:  longestMatch m ss  -- will give "watchtower"
13:32:45 <osfameron> while  match m ss []  -- would also give ["watch", "tower"]  e.g. it finds all the combinations that add up to the word we're looking for
13:33:25 <osfameron> (I'm not a jehovah's witness, those were the two words that came into my head as a portmanteau word...)
13:33:38 <Rembane> All along the watchtower.
13:33:45 <osfameron> I'm not Hendrix either
13:33:57 <Rembane> Ach
13:34:25 <lyxia> build the accumulator with (s : acc) and reverse it at the end to avoid quadratic buildup
13:34:45 <hodapp> Dylan wrote that song, not Hendrix!
13:34:46 <hodapp> GAAAH
13:35:09 <osfameron> lyxia: ok, I don't think the numbers are going to make that critical for this application, but yeah may as well
13:35:25 <osfameron> hodapp: heh, I'd forgotten that he covered it too!
13:35:26 * osfameron hides
13:35:34 * hodapp throws things at osfameron
13:35:50 <lyxia> osfameron: there's stripPrefix to replace lines 8 and 9
13:37:32 <lyxia> osfameron: and indeed you don't need to keep an accumulator, since "s" will be an element in all of "match remainder blablabla"
13:38:03 <osfameron> lyxia: wonderful, I looked for that (but was searching for a (Bool, [a]) instead of Maybe [a]
13:38:21 <lyxia> osfameron: drop the accumulator and replace the last line by fmap (s :) (match remainder ss)
13:38:46 <lyxia> and return [] when target is null
13:39:12 <osfameron> lyxia: oh, clever.
13:39:33 <osfameron> how do I use the Maybe with a guard in a List monad?
13:39:47 <lyxia> Just remainder <- stripPrefix ...
13:40:10 <lyxia> this relies on fail becoming the empty list
13:40:23 <lyxia> uh
13:40:30 <lyxia> [stripPrefix ...]
13:41:10 <osfameron> ah!
13:41:41 <lyxia> there's Data.Maybe.maybeToList if you don't like fail
13:44:25 <erisco> what modules are favoured for implementing HTTP APIs?
13:45:07 <osfameron> lyxia: oh, that's lovely.  and prefixing (s:) gets the results in the correct order without reverse
13:45:15 <monochrom> I think all of the usual webapp frameworks are
13:45:49 <monochrom> at this moment the first names I think is "scotty". but all the others should be good.
13:45:49 <Ankhers> Would anyone tell me why I am getting this error when I try to make this function polymorphic, and potentially how to fix it?
13:45:52 <Ankhers> http://lpaste.net/153146
13:47:27 <jle`> erisco: if it's just an http api i sometimes get away with just using bare wai
13:47:34 <jle`> erisco: but also, servant is supposed to be good for http api's
13:47:36 <jle`> i haven't used it yet though
13:47:59 <Ankhers> Servant is really interesting.
13:48:01 <monochrom> Ankhers, perhaps runSqlPool does not support the polymorphism you want
13:48:06 <crough> jle` erisco: Servant is kind of crazy but not great yet
13:48:08 <Ankhers> I'm using it in an application right now.
13:48:15 <crough> I'm partial to scotty for little HTTP apis
13:48:23 * hackagebot js-jquery 1.12.1 - Obtain minified jQuery code  https://hackage.haskell.org/package/js-jquery-1.12.1 (NeilMitchell)
13:48:28 <crough> Well, Spock even more so, but there's a lot fewer docs
13:50:00 <lyxia> Ankhers: PersistEntity is too loose a constraint, runSqlPool has the additional requirement that the backend be Sql
13:50:40 <Ankhers> lyxia: That makes sense. How would I be able to add that information to the type?
13:52:46 <lyxia> Ankhers: PersistEntityBackend p ~ SqlBackend perhaps
13:53:47 <aep-shoutlet> My usage pattern is append more than i drop. Will Data.Sequence still use memory efficiently, or should I do something to help this?
13:54:15 <jle`> append as in ++ ?
13:54:41 <aep-shoutlet> append as in |>
13:54:47 <osfameron> lyxia: looking at both options, I think I prefer maybeToList (no real beef against fail, but it looks more explicit and comprehensible to me at my level)
13:55:06 <Ankhers> lyxia: That fixed it. Thank you!
13:56:16 <Cale> aep-shoutlet: should be okay -- you're using it as a queue?
13:56:20 <jle`> Ankhers: so, you mean snoc
13:56:40 <aep-shoutlet> i'm using it as a first in first out queue, where the tail grows more quickly than the head shrinks
13:56:52 <Ankhers> jle`: I think that was for aep-shoutlet.
13:56:59 <jle`> ah yeah, you're right :)
14:02:21 <indobits> hi
14:08:24 * hackagebot lentil 0.1.10.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.10.0 (fffaaa)
14:46:34 <heath> http://www.infoq.com/presentations/We-Really-Dont-Know-How-To-Compute
14:47:34 <heath> "The Problem is Evolvability not Correctness"
14:48:10 <heath> "Extensible Generic Operations may help", •Extension of function without modification, Makes Proofs very difficult
14:58:27 * hackagebot YamlReference 0.10.0 - YAML reference implementation  https://hackage.haskell.org/package/YamlReference-0.10.0 (OrenBenKiki)
15:06:33 --- mode: tepper.freenode.net set +o ChanServ
15:09:35 <heath> http://web.mit.edu/~axch/www/phd-thesis.pdf
15:09:47 <shapr> howdy heath
15:13:28 * hackagebot roller 0.1.7 - Playing with applicatives and dice!  https://hackage.haskell.org/package/roller-0.1.7 (PiotrJustyna)
15:48:29 * hackagebot werewolf 0.4.7.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.7.0 (hjwylde)
15:49:26 <anks> Can i have a mutable vector as a state in StateT transformer? I need a very fast random element access to an element, when parsing things..
15:51:05 <Zekka|Sigfig> anks: Could you perhaps use an IOArray and transform your parser over IO?
15:52:48 <Zekka|Sigfig> You could also use a finger-tree sequence or something. Those are O(log n) in random access/mutation although their constant factor is very high
15:52:59 <Zekka|Sigfig> (not really mutation but replacement)
15:53:20 <anks> What about Data.Map ?
15:53:51 <anks> is it slower than sequence?
15:54:03 <Zekka|Sigfig> That would probably work OK. Minding that slicing and appending/prepending would be slow, not that you’re necessarily doing that
15:54:17 <Zekka|Sigfig> Random access in Data.Map is O(log n) but I don’t know if it’s the same constant factor
15:54:39 <anks> And what do you mean by transforming parser over IO ?
15:54:46 <Zekka|Sigfig> Appending/prepending might actually be slow
15:55:03 <anks> I just care about updating things in place.
15:55:15 <Zekka|Sigfig> er, might actually be pretty fast*
15:55:38 <Zekka|Sigfig> anks: Well, I kind of figured you were using a parser monad like Parsec’s, in which case you’d use ParserT IO (probably with additional arguments to ParserT)
15:55:49 <Zekka|Sigfig> it sounded like that given that your original question was about using a monad transformer
15:56:09 <dfeuer> Data.Map and Data.Sequence serve two very different purposes. When would you choose between them?
15:56:12 <Zekka|Sigfig> If your parser doesn’t need to be part of a monad transformer stack, ST and STArrays will be both pretty fast and safe
15:56:26 <anks> Im using attoparsec :], does it have an alike transformer?
15:56:41 <Zekka|Sigfig> dfeuer: You can crudely implement a sequence type (not a Sequence) by mapping from an index type to values with Data.Map
15:57:08 <dfeuer> Zekka, that would be a stupidly slow way to do it. Why???
15:57:13 <Zekka|Sigfig> I don’t really think this is a very intent-revealing way to do it but it would probably work and I doubt it would be much slower than Data.Sequence if all you care about is normal array-style operations (and not random insertion, removal, slicing etc.)
15:57:40 <Zekka|Sigfig> dfeuer: Would it? Why? Aren’t the operations on a Sequence implemented by comparing to a logistic number of values of the finger-tree’s monad type? (This is a genuine question.)
15:57:55 <Zekka|Sigfig> er, not logistic. O(log n)
15:58:20 <crough> anks: If speed is *very* critical, and I mean **very** critical, you can use the unsafe thaw and freeze methods
15:58:23 <Zekka|Sigfig> AFAIK Maps make the same guarantee, except I think they’re based on binary trees and Sequences are based on 2,3,4-trees
15:58:26 <crough> anks: I do *not* recommend that though
15:59:05 <Zekka|Sigfig> er, the finger-tree’s monoid type (wrt what you’re comparing to — I really can’t think straight, apparently!)
15:59:19 <anks> ok, so you're saying that I could have a immutable vector and unsafely turn it into a mutable one?
16:00:11 <anks> as a state in StateT transformer?
16:00:18 <dfeuer> Zekka|Sigfig, well, it depends. Sequences are designed for extra-fast access at the ends, fast appending, and fast splitting.
16:00:45 <dfeuer> Zekka|Sigfig, Map Int is (pretty much) the same as IntMap, except that IntMap is much, much faster.
16:00:53 <Zekka|Sigfig> dfeuer: Yeah, but for random access you still have to traverse like log_4(n) nodes, right?
16:00:57 <anks> I'm going ot try Data.IntMap.Strict first and see if go on with the performance, thanks crough , Zekka|Sigfig 
16:01:19 <dfeuer> Zekka|Sigfig, sure, but that's not really what they're *for*.
16:01:45 <dfeuer> (and it's more like log_3(n), and sometimes as bad as log_2(n), but whatever)
16:02:09 <Zekka|Sigfig> It sounded like anks wanted array-style random access. In that case I’d be surprised if there was a significant performance difference between Sequences and Maps here, but don’t trust me
16:02:27 <Zekka|Sigfig> IntMaps I don’t know because I don’t know how IntMap was implemented
16:03:22 <dfeuer> Ah, yeah, for random access with persistence, IntMap is really very good. Edward Kmett's been doing some experiments trying to make faster ones, but it's tricky.
16:04:07 <Zekka|Sigfig> I’m strongly suspecting you can’t do better than log time for truly random access, but you can whittle away at the constant factor
16:06:22 <dfeuer> Oh, that certainly seems to be true for confluent persistence (full persistence offers, at least theoretically, butter bounds, but it's not much use in Haskell). But the constant factor is very important....
16:06:45 <dfeuer> edwardk, any progress making WordMap fast?
16:07:38 <Zekka|Sigfig> The other thing to consider is that I bet a lot of random access is not actually that random
16:08:00 <dfeuer> Good point.
16:08:12 <Zekka|Sigfig> I bet a structure that assumes certain parts will be randomly accessed way more often than others could be faster than one that makes no assumptions at all!
16:08:27 <Zekka|Sigfig> although I don’t really know a fast persistent sequence that makes that assumption right now
16:09:30 <dfeuer> Well, lots of assumptions can lead to better performance when they apply. Data.Sequence makes the assumption that the ends will be accessed more than the middle (bounds are given in terms of the distance from the nearer end for splitting and indexing, and the smaller part, for appending)
16:09:50 <dfeuer> Tries make the assumption that there will be useful sharing in the prefixes.
16:11:19 <Zekka|Sigfig> Well, yeah, but I don’t know a variation of those structures that doesn’t also make an order requirement on whatever they’re splaying to the top. You could probably hack one out by doing something like what splay trees do and always trying to put the favored node in the middle, but I don’t have full details right now on how that would work
16:12:47 <Zekka|Sigfig> I can’t imagine you could do it without losing fast append/remove! The more things you splay to the top, the slower stuff like that gets and it seems like the bookkeeping to both share the ends and splay them to the top would be really hard
16:13:17 <Zekka|Sigfig> Probably people who want a thing that’s filing the role of an array don’t really care about append/remove performance
16:13:38 <johnw> when I final encode [a] as forall r. (a -> r -> r) -> r -> r, what rule justifies replacing the recursive occurrence with 'r' in that first argument?
16:17:40 <tinco> hi
16:17:48 <tinco> I'm trying to get this to work: http://lpaste.net/153248
16:17:53 <tinco> anyone know what I'm doing wrong?
16:18:58 <pavonia> tinco: You probably want liftIO testfiles
16:19:09 <tinco> I tried that, but I get a different error then
16:19:21 <pavonia> What error?
16:19:43 <tinco>     No instance for (MonadIO
16:19:43 <tinco>                        (hspec-core-2.2.2:Test.Hspec.Core.Spec.Monad.SpecM ()))
16:19:44 <tinco>       arising from a use of ‘liftIO’
16:21:07 <pavonia> Seems SpecM doesn't implement MonadIO, but there's runIO :: IO r -> SpecM a r
16:22:53 <tinco> ohh it's because I'm in a describe and I can only do io in it right?
16:23:08 <tinco> why would it have a runIO but not implement monadio?
16:24:45 <pavonia> No idea
16:26:48 <glguy> Is there something one can add to a .cabal file along the lines of "library-stripping: False"? If not is there something to add to stack.yaml to pass "--disable-library-stripping" to cabal configure?
16:30:06 <mgsloan> glguy: Unfortunately not currently.  Here's an issue about it: https://github.com/commercialhaskell/stack/issues/1342
16:31:05 <geekosaur> that's executabe stripping. OTOH... library stripping should not be a thing, since it makes libraries kinda unusable?
16:31:22 <glguy> Cabal uses: strip --strip-unneeded
16:31:26 <glguy> on libraries
16:31:42 <glguy> when library-stripping is on, at least
16:31:47 <mgsloan> We've held off on doing it so far as there's been plans to revamp how options and flags are applied to extra-deps / snapshot packages.  Adding cabal configuration options would be yet another thing where we need to consider how the behavior is changing
16:31:49 <glguy> on Linux, in particular
16:32:15 <glguy> I think my best workaround for this might end up being a custom hook in the Setup.hs to turn it off
16:32:19 <mgsloan> The main reason to not strip libraries is so you can get DWARF symbols
16:33:07 <mgsloan> Yeah, or you can build a version of stack that always uses that flag, by editing this list of options https://github.com/commercialhaskell/stack/blob/704764f472d2542658a48c8ce5b16c03a99e6f43/src/Stack/Types/Build.hs#L687
16:33:32 <glguy> No, I'd need a solution so that people not using my custom stack executable could still get the benefits
16:34:15 <mgsloan> If you wanted to work on https://github.com/commercialhaskell/stack/issues/1438 , we'd probably accept it
16:34:34 <mgsloan> (even though there's the interaction with the revamp, that's been getting delayed for too many months already)
17:11:20 <marchelzo> fromConstr (toConstr (5 :: Int)) -- this throws an exception when I try to evaluate it. Is there a context where it would be valid?
17:12:31 <shachaf> marchelzo: The text of the exception is a hint.
17:12:37 <shachaf> *** Exception: Data.Data.constrIndex is not supported for Prelude.Int, as it is not an algebraic data type.
17:12:45 <marchelzo> Yeah, I know.
17:13:03 <marchelzo> Would it have been valid in the past? A different version of Data.Data maybe?
17:13:38 <shachaf> For Int?
17:13:50 <marchelzo> The implementation of fromConstr must be trying to use constrIndex. Maybe it didn't before?
17:14:01 * hackagebot fltkhs 0.4.0.3 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.0.3 (deech)
17:14:13 <marchelzo> shachaf: Yes, that exact expresision.
17:14:20 <marchelzo> expression*
17:15:07 <marchelzo> I'm reading post from early 2014 from Chris Done's blog, and that is part of an example.
17:15:13 <marchelzo> s/post/a post/
17:17:02 <shachaf> Oh.
17:19:02 * hackagebot fltkhs-demos 0.0.0.5 - FLTKHS demos. Please scroll to the bottom for more information.  https://hackage.haskell.org/package/fltkhs-demos-0.0.0.5 (deech)
17:19:04 * hackagebot fltkhs-fluid-demos 0.0.0.4 - Fltkhs Fluid Demos  https://hackage.haskell.org/package/fltkhs-fluid-demos-0.0.0.4 (deech)
17:28:25 <Ankhers> I'm currently trying to profile my application. Are the ghc docs the best resource to understand how to do this, or is there something else?
17:39:03 * hackagebot fltkhs 0.4.0.4 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.4.0.4 (deech)
17:56:19 <mjrosenb> Is it possible to give a type annotation for a variable in a do-block, where the monad is not definite?
17:58:13 <geekosaur> with ScopedTypeVariables you should be able to say x :: Foo <- ...
18:13:20 <montanonic> Can anyone recommend blog posts on  extensible effects? (http://okmij.org/ftp/Haskell/extensible/more.pdf) There's some stuff on it, but it's from the older version of the library. 2015 saw a revision of it, but I haven't been able to find any postings from that period. I'd like to find resources on it that show different ways of using the library, instead of explaining its theory and construction.
18:13:57 <LordBrain> I like the effect-monad package
18:14:01 <LordBrain> its not blogs
18:14:15 <LordBrain> but its the same kind of thing as extensible effects
18:15:10 <LordBrain> i actualy haven't used it for anything yet
18:15:21 <montanonic> LordBrain: is it based on Free/Freer monads? Does it have the same type of compositionality and extensibility?
18:15:43 <montanonic> The latest version of EE has quite good performance characteristics as well.
18:16:12 <montanonic> LordBrain: I'm looking into it in any case; thank you.
18:17:35 <mjrosenb> geekosaur: I'd like to do it beforehand, e.g. x :: m Foo; x <- mkFoo
18:18:16 <geekosaur> I think you need the new _ stuff in ghc8 then (x :: _ Foo)
18:18:47 <geekosaur> hm, maybe that;s in 7.10 already?
18:19:05 * hackagebot casr-logbook 0.0.1 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.0.1 (TonyMorris)
18:19:07 * hackagebot fltkhs-demos 0.0.0.6 - FLTKHS demos. Please scroll to the bottom for more information.  https://hackage.haskell.org/package/fltkhs-demos-0.0.0.6 (deech)
18:19:09 * hackagebot fltkhs-fluid-demos 0.0.0.5 - Fltkhs Fluid Demos  https://hackage.haskell.org/package/fltkhs-fluid-demos-0.0.0.5 (deech)
18:20:01 <geekosaur> ah, it is. PartialTypeSinatures extension
18:20:05 <geekosaur> ...
18:20:15 <geekosaur> PartialTypeSignatures
18:29:33 * hackagebot casr-logbook 0.0.2 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.0.2 (TonyMorris)
18:30:50 <GGuy_> Hi, I'm considering learning category theory through some form of online lectures. Any hints on how to make the most of it from a haskell perspective?
18:32:48 <mjrosenb> geekosaur: wow, I'm kind of surprised that this needs an extension.
18:33:34 <geekosaur> well, doing it just with type variables already has a different meaning
18:33:55 <mjrosenb> geekosaur: it does?
18:34:46 <geekosaur> foo :: m Foo -- means caller chooses the m, not that m is fixed but should be computed
18:35:13 <geekosaur> s/computed/inferred/
18:35:32 <geekosaur> adding forall doesn't help since there's an implicit forall on it
18:36:37 <mjrosenb> geekosaur: when you say add a forall, do you mean foo :: forall m. m Foo?
18:36:38 <geekosaur> that said I do not know what you're trying to accomplish...
18:36:42 <geekosaur> yes
18:36:49 <geekosaur> but that;s already wha foo :: m Foo means
18:36:54 <mjrosenb> I wish I had a small 10 line example
18:37:05 <geekosaur> only reason you;d be explicit is so ScopedTypears will scope the m over the followig expression
18:38:22 <montanonic> GGuy_: this might be a helpful resource: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
18:38:24 <mjrosenb> I have topLevel :: forall m. Foo -> Bar -> m baz; topLevel foo bar = do quux :: m Quux; quux <- mkQuux
18:39:55 <mjrosenb> oh, it is also mdo, rather than do, if that matters.
18:41:12 <pavonia> What's the type of mkQuux?
18:41:20 <geekosaur> ah. I don't think do syntax lets you do signatures that way, come to think of it. might request it as a language feature. which is why people either type the whole expression or use what was called a pattern signature before ghc8 repurposed the term
18:41:27 <GGuy_> montanonic: Thanks! Looks like it's worth a read :)
18:42:41 <geekosaur> come to think of it, since you have m forall-ed, and presumably have ScopedTypeVars on, quux <- mkQuux :: m Whatever
18:43:01 <geekosaur> (assuming it is in fact the same m)
18:43:42 <mjrosenb> geekosaur: yeah, but mkQuux actually takes like 10 parameters, and Quux is about 40 characters long already
18:44:00 <mjrosenb> which is why I'd really like to put the signature on a line of its own before the binding.
18:44:18 <geekosaur> I think you coul put it on a line after, as long as it's indented?
18:45:55 <marchelzo> is there a way in a type signature to express "a function that can be an a -> b or a c -> d"?
18:46:35 <LordBrain> well there is Either (a -> b) (c -> d), but that's too obvious and so probably not what you mean
18:46:44 <EvanR> also its not a function
18:46:45 <geekosaur> without more information it's not cear what you mean
18:46:54 <EvanR> also what is the diff between and c
18:47:00 <EvanR> a and c
18:47:07 <LordBrain> well he used quotes, but yeah i gather
18:47:35 <LordBrain> you could use type famiilies
18:48:00 <EvanR> a ->b and c->d are alpha equivalent
18:48:06 <LordBrain> where you have a type function applied to the calling type used as the return type
18:48:26 <LordBrain> right, he probably means specific values of a b and c and d, not type variables
18:48:36 <marchelzo> Ok, so the function I want to define is called f. Here's how it might be used: f show (4, "foo") -- evaluates to ("4", "\"foo\"")
18:48:40 <geekosaur> what EvanR just said is what I meant by it not being clear what you mean
18:49:08 <marchelzo> but it would be more generic than that (in this example, both b and d are String)
18:49:34 * hackagebot casr-logbook 0.0.3 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.0.3 (TonyMorris)
18:49:43 <EvanR> marchelzo: do you mean that whatever the return type is, its dependent on the input type?
18:49:57 <marchelzo> yes, I suppose so
18:50:03 <EvanR> ah ha!
18:50:11 <LordBrain> you could pass in an explicit dictionary
18:50:28 <LordBrain> or use the type family approach i suggested earlier
18:52:26 <marchelzo> LordBrain: I'm not really familiar with either of those things. How would you define f using one of those two solutions?
18:52:47 <LordBrain>  f :: ConstraintThing => a -> TypeFunc a
18:52:59 <EvanR> you didnt really explain what f is going to do
18:53:02 <LordBrain>  f :: ConstraintThing a => a -> TypeFunc a
18:53:14 <EvanR> so its not clear if tytype families is right
18:53:36 <marchelzo> I don't know how to write its type signature or else I would. But it just applies its first argument (a function) to each value in the pair.
18:53:51 <LordBrain> yeah, i think explicit dictionary is a more conservative suggestion
18:53:54 <EvanR> like this
18:54:20 <pavonia> What is an explicit dictionary?
18:54:37 <LordBrain> ie, just add the function(s) as a parameter or parameters
18:54:49 <EvanR> f :: (a ->b) -> (a,a) -> (b,b)
18:54:51 <LordBrain> well, or a Record type with functions
18:55:19 <marchelzo> EvanR: but I don't want it to be restrictive like that
18:55:32 <marchelzo> now f id (4, "foo") is a type error
18:55:47 <EvanR> is that not what you asked for
18:56:21 <LordBrain> data UsableInputType b = UsableInputType { func1 :: b }
18:56:29 <LordBrain> hmm
18:56:38 <EvanR> how about :: (a->b, c->d) -> (a,b) -> (c,d)
18:56:39 <marchelzo> Perhaps it is, but it's not what I meant. Sorry for explaining myself poorly.
18:56:50 <LordBrain> oops i messed up that type, nvm that
18:57:16 <marchelzo> EvanR: that's like a more restrivtive bimap isn't it?
18:57:25 <LordBrain> it would be easier to get at what is best if we know the exact use case 
18:57:41 <marchelzo> I only want to give one function, and have it applied to both values.
18:58:18 <marchelzo> There is no real use-case. I'm just exploring the type system. I am reading about RankNTypes and trying to grok its consequences.
18:58:21 <LordBrain> but you don't want that function to be fully polymorphic right?
18:58:28 <EvanR> well thats easy to do and be type unsafe
18:58:44 <geekosaur> LordBrain, I think what marchelzo is getting at is that you lose some polymorphism normally in that case, and I don't recall how you avoid that
18:58:54 <marchelzo> I don't want it to be fully polymorphic, that's right.
18:59:31 <EvanR> you have to decide what it needs to be able to do
18:59:42 <EvanR> "anything" doesnt work
18:59:45 <LordBrain> marchelzo, is it okay to have a type class that constrains the polymorphism to instances?
19:00:26 <LordBrain> so as in f :: (YourClass a, Yourclass c) => (a,c) -> (c,d)
19:00:37 <LordBrain> oops, 
19:00:51 <LordBrain> make those first two c's into b's for me
19:00:52 <LordBrain> heh
19:00:58 <LordBrain> you get my point anyway
19:01:32 <LordBrain> f :: (YourClass a c, Yourclass b d) => (a,b) -> (c,d) with -XMultiParamTypeClasses
19:01:39 <EvanR> "rankN" "more or less polymorphic" and "type families" doesnt get around the question of what needs to be supported, implied by the type sig
19:01:43 <LordBrain> and functional dependencies
19:01:48 <EvanR> throwing features randomly at a wall isnt going to help
19:01:55 <marchelzo> EvanR: I can write (show 5, show "bar"). I can write (id 4.3, id 'a'), I can write ((+1) 4.5, (+1) 6). But I don't know how to write a function that can do this. That's what I want to do.
19:02:06 <LordBrain> well he's not actually coding anyway, just learning
19:02:17 <EvanR> theres
19:02:51 <LordBrain> f g (x,y) = (g x, g y)
19:02:53 <LordBrain> heh
19:02:55 <EvanR> show2 :: Show a, Show b => (a, b) -> (String, String)
19:03:20 <EvanR> (with more parns , but im horribly lagged
19:03:40 <LordBrain> alright, you want the g's two only be the same name but not the same function
19:03:48 <marchelzo> exactly!
19:03:56 <EvanR> :t \g (x,y) -> (g x, g y)
19:04:01 <lambdabot> (t -> t1) -> (t, t) -> (t1, t1)
19:04:25 <EvanR> marchelzo: you either need to use type classes or pass in two functions
19:04:34 <EvanR> and type classes is sjust sugar for using two functions
19:05:06 <EvanR> IRL youd just pass in two Strings ;)
19:05:38 <LordBrain> two do this explicitly, you should give the g's different parameter slots, if you want to use the type class, you can do it by making a constraint f (x,y) = (yourFunc x, yourFunc y)   which has f :: (YourClass a, YourClass b) => (c, c)
19:06:12 <LordBrain> explicit is likely better
19:06:28 <LordBrain> so in other words, just don't
19:06:32 <marchelzo> haha
19:06:45 <LordBrain> instead do f g1 g2 (x,y) = (g1 x, g2 y)
19:06:46 <LordBrain> better
19:07:06 <LordBrain> the specific circumstances might make a type class reasonable however
19:07:21 <EvanR> the type system doesnt magically make it possible to do things that was previously non sensical
19:07:23 <LordBrain> but without more context, i'd say just do explicit parameters like above
19:07:33 <marchelzo> it's weird how doing this in a dynamically typed language is so simple. but it makes sense now.
19:08:12 <EvanR> thats the point, you  will go back to the dynamic language and hopefully understand what it was that you thoughtwas possible, and understand it in a different light
19:08:27 <EvanR> either it actually wasnt sensible in the first place, or it is and you didnt know what it was
19:08:39 <LordBrain> you could also pass the two parameters in in one type of course, using a product type, ie data TwoFuncs = TwoFuncs (a -> c) (b -> c)  
19:08:40 <marchelzo> it is definitely sensible
19:09:07 <EvanR> apply "any function to any argument" is misleadingly possible
19:09:19 <marchelzo> well, I can see why it's not possible. The fact that the two different functions happen share a name is merely a coincidence.
19:09:19 <EvanR> in a dynamic language all values are the same type
19:09:26 <LordBrain> you know that if you are just using a named function like "show", it will infer the proper constraint for you
19:09:37 <Zekka> Well, heads up -- if it seemed sensible without a type system, it's still sensible in a certain light with one
19:09:42 <EvanR> function names are irrelevant, its justlam lambdas
19:09:49 <marchelzo> right
19:09:51 <Zekka> Just because you can describe how one language works in terms of another one doesn't mean one is more fundamental
19:10:21 <marchelzo> EvanR: But it's still a sensible thing to do. It just can't be done. Unless I'm misunderstanding something.
19:10:27 <EvanR> Zekka: elementalest earlier i was talking about the opposite siutation, if it made no sense before, it still doesnt make sense with a type system
19:10:39 <EvanR> uhg
19:10:43 <Zekka> EvanR: Oh. That's possibly true
19:11:17 <Zekka> Sorry! I have a pet peeve of statements like "inheritance is just existentials" and I wanted to cut that sort of thing off at hte pass
19:11:21 <LordBrain> marchelzo, you can use type classes to do it
19:11:24 <EvanR> marchelzo: its not really. what youre describing is let me apply a function of type JS -> JS to two JS's
19:11:36 <EvanR> which you can do in Haskell
19:11:43 <LordBrain> marchelzo, so it can be done, its just not worth the draw backs in the general case, so it depends on the circumstances
19:12:25 <EvanR> in Js they arent different types
19:12:36 <LordBrain> type classes are haskell's original way of doing function overloading
19:13:13 <EvanR> type classes and names of functions are just clouding the principles here
19:13:16 <marchelzo> I guess the function I had in mind would have to operate at the level of syntax
19:13:55 <LordBrain> you're asking if you can make it a constraint of hte function that the parameter be overloaded in a specific way, the answer is yes, you could do it with extensions (Fundeps + multiparamtypeclasses) OR (typefamilies), but its not worthwhile in the general case, needless complicating of code.
19:14:00 <EvanR> marchelzo: well you can still write the function, and activate defer type errors, then itll run. and crash sometimes
19:14:04 <EvanR> like JS
19:14:21 <marchelzo> EvanR: But the function that I had in mind could never crash
19:14:30 <EvanR> for it not to crash you neeed to specify what youre trying to do more carefully
19:14:39 <LordBrain> marchelzo, operating at the level of syntax is a third option, in that case you could use templatehaskell
19:14:42 <EvanR> marchelzo: which one?
19:15:02 <EvanR> apply 1 function to two differently type args?
19:15:07 <LordBrain> so there are 3 ways to do it, but the typically best thing is just not to do it at all
19:15:19 <EvanR> i could use it to do apply ord ('c', True)
19:15:21 <marchelzo> EvanR: just think of it as a macro: f g (x, y) becomes bimap g g (x, y)
19:15:31 <marchelzo> it's perfectly type safe
19:16:18 <marchelzo> LordBrain: Yeah I'm not actually going to do it.
19:16:27 <LordBrain> the "names" of functions which are fields in a type class don't have to operate at the level of syntax, you could use MultiParamTypeClasses + FunctionalDependencies
19:16:49 <EvanR> its not about names
19:17:27 <LordBrain> as in, class YourClass a b | a -> b where yourfunc :: a -> b
19:17:42 <EvanR> marchelzo: yeah youre right, you cant defer the polymorphism that way. but you can use let polymorphism to do the bimap internally if you define the function with a let
19:17:59 <LordBrain> well you'd need a constructor on that without some additional extension
19:18:03 <LordBrain> hmm
19:18:42 <LordBrain> you'd end up pulling in a lot of extensions
19:18:57 <EvanR> marchelzo: the issue is that in f g (x,y) g's type is chosen too early
19:19:07 <EvanR> so youd need lazy type inference
19:19:09 <EvanR> or something
19:19:10 <marchelzo> yeah
19:19:30 <LordBrain> hmm i wouldn't word it that way...
19:19:50 <LordBrain> g's type isn't fixed at all, late or early, its overloaded
19:20:01 <EvanR> were talking about two different things
19:20:05 <LordBrain> oh
19:20:07 <EvanR> im not talking about type classes at all
19:20:43 <EvanR> also, f g (x,y) would fail sometimes in a dynamic language
19:20:53 <EvanR> even if it seems obviously working
19:21:01 <marchelzo> absolutely
19:22:26 <LordBrain> anyway, doing anything other than f g1 g2 (x,y) = ... would likely violate KISS
19:22:41 <EvanR> marchelzo: what type of g's are you thinking about supporting with this
19:22:50 <EvanR> a -> b isnt really a thing
19:23:05 <marchelzo> right
19:23:13 <EvanR> whatever the answer is, can be baked into the f type
19:23:32 <marchelzo> there is no type I guess
19:23:43 <marchelzo> at leat I don't know how to express it
19:24:10 <EvanR> "apply a function to two arguments of different types if and only if it makes sense" ;)
19:24:21 <EvanR> engage
19:24:25 <marchelzo> yeah
19:24:30 <LordBrain> it's really an associated type it seems to me
19:24:31 <marchelzo> that's why it would make sense as a macro
19:24:40 <marchelzo> just generate the code and then see if it type checks
19:24:45 <EvanR> yeah so TH
19:24:51 <EvanR> or just type g two times ;)
19:25:08 <marchelzo> yeah all of this doesn't seem worth it to avoid typing g hah
19:25:39 <EvanR> that is an interesting corner case
19:25:46 <LordBrain> hmm i guess even an associated type wouldn't type check when you try to use it on differently typed inputs
19:27:26 <marchelzo> it seemed natural to me when I thought of it, but after the realization that the two g's would be different functions, it doesn't seem as natural. I can see why it'd be impossible to express.
19:27:53 <EvanR> it might not be two different functions, which i only realized after you said bimap
19:28:28 <EvanR> it could be a -> a... buti guess thats pointless
19:29:07 <EvanR> if you add extra structure it could make sense
19:29:57 <EvanR> (Maybe a -> Maybe b) -> (Maybe a, Maybe b) -> (Maybe ... nevermind
19:30:36 <nitrix> data Bimap a b = MkBimap (Map a (Set b)) (Map b (Set a))
19:30:50 <EvanR> haha
19:31:04 <nitrix> My game uses that. The current bimap package doesn't handle duplicated values; and uses exceptions :/
19:33:17 <marchelzo> LordBrain, EvanR, thanks a lot for the help.
19:33:21 <marchelzo> good night
19:41:37 <LordBrain> Anyone know of a super-generic-prompt-for-input that uses whatever gui or commandline interface is appropriate given the users's context/
19:43:12 <LordBrain> something like "if executing from the terminal, display and input with stdio, but if the program is not running in a terminal window, then display a wxWidgets window that displays the prompt and lets the user enter it and click a submit button?
19:44:26 <EvanR> or xprompt! ;)
19:45:02 <LordBrain> sure
19:45:34 <LordBrain> xprompt apparently isn't installed in my debian
19:45:42 <LordBrain> what package would that be?
19:45:56 <EvanR> its an X package
19:46:03 <EvanR> so who knows
19:46:11 <peddie> LordBrain: 'apt-file search xprompt'
19:47:29 <LordBrain> i had to install apt-file
19:49:56 <LordBrain> looking at MonadPrompt package
19:56:06 <LordBrain> apt-file turned up nothing for xprompt
19:56:13 <LordBrain> sure it was called that?
19:59:38 * hackagebot pandoc-citeproc-preamble 1.1.0 - Insert a preamble before pandoc-citeproc's bibliography  https://hackage.haskell.org/package/pandoc-citeproc-preamble-1.1.0 (spwhitton)
19:59:59 <EvanR> i saw it with my own eyes on vector linux in the 2000s and ... ftp://mig-consulting.com/hpux/X11/Misc/xprompt-1.4/xprompt-1.4.man.html
20:00:20 <EvanR> maybe it ended up in /dev/null
20:12:03 <LordBrain> MonadPrompt isn't what i am looking for, its for separating effects and computations, where as i want something that senses context and behaves accordingly
20:22:06 <rcrcrc> how does 'printf' infer that in e.g. ```printf "%d" 4``` the 4 is e.g. a double?
20:22:53 <rcrcrc> it could be multiple types, but ghc doesn't require a type annotation
20:23:47 <shachaf> > printf "%f" 4 :: String
20:23:53 <lambdabot>  "*Exception: printf: bad formatting char 'f'
20:25:00 <LordBrain> rcrcrc, it uses a class called printfarg, see the source
20:25:12 <shachaf> Oh, you wrote %d, not %f.
20:25:12 <rcrcrc> right, i was wondering how it defaulted to anything, but i think it's just ExtendedDefaultingRules in ghci
20:25:21 <shachaf> It's not a Double, it's an Integer.
20:25:34 <shachaf> It's not ExtendedDefaultRules, it's just regular default rules.
20:25:44 <shachaf> Hmm, maybe not.
20:25:55 <LordBrain> ghci always uses extended i believe
20:26:14 <shachaf> Right, it's ExtendedDefaultRules.
20:34:35 <mitchty> does this look like a known arm issue to anyone? https://gist.githubusercontent.com/mitchty/77148ac7aa936463a7f0/raw/1147cff0a916640efa63e600ca7973026b153e71/gistfile1.txt
20:35:05 <mitchty> oops missed a bit above that
20:35:39 <mitchty> https://gist.githubusercontent.com/mitchty/f613a0aeb63f68451b18/raw/a9c14fb35e543cf2925691e2105c80f3ae58a64b/gistfile1.txt
20:43:11 <hk238> hello ^^
20:44:08 <mitchty> whoops meant that for #ghc :)
21:05:37 * hackagebot filtrable 0.1.0.5 - Class of filtrable containers  https://hackage.haskell.org/package/filtrable-0.1.0.5 (MatthewFarkasDyck)
21:15:38 * hackagebot category-traced 0.1.0.0 - Traced monoidal categories  https://hackage.haskell.org/package/category-traced-0.1.0.0 (MatthewFarkasDyck)
21:15:40 * hackagebot category-traced 0.1.0.1 - Traced monoidal categories  https://hackage.haskell.org/package/category-traced-0.1.0.1 (MatthewFarkasDyck)
21:40:39 * hackagebot hedis-config 0.0.3 - Easy trivial configuration for Redis  https://hackage.haskell.org/package/hedis-config-0.0.3 (AlekseyUymanov)
22:19:35 <mjrosenb> Is there a named function that does f [x] = Just x; f _ = Nothing?
22:20:13 <EvanR> :t listToMaybe
22:20:19 <lambdabot> [a] -> Maybe a
22:20:24 <glguy> That works differently on multiple element lists
22:20:46 <EvanR> tricky
22:21:41 <MarcelineVQ> differently?
22:23:05 <glguy> > let f [x] = Just x; f _ = Nothing; xs = [(),()] in (f xs, listToMaybe xs)
22:23:12 <lambdabot>  mueval-core: Time limit exceeded
22:23:16 <glguy> > let f [x] = Just x; f _ = Nothing; xs = [(),()] in (f xs, listToMaybe xs)
22:23:23 <lambdabot>  mueval-core: Time limit exceeded
22:23:33 <glguy> (Nothing, Just ())
22:25:09 <glguy> mjrosenb: Not that I'm aware of in base at least
22:27:02 <MarcelineVQ> what
22:27:15 <glguy> yup
22:27:24 <jle`> MarcelineVQ: the function mjrosenb is looking for returns Nothing if there is more than one element in the list
22:27:31 <jle`> listToMaybe will return Just if there are 2+ elements
22:28:13 <MarcelineVQ> That's clearer
22:28:27 <Lokathor> > (\_ _ -> GT) (1::Int) (5::Int)
22:28:35 <lambdabot>  mueval-core: Time limit exceeded
22:28:46 <Lokathor> why is lambdabot failing on such a seemingly simple thing?
22:29:02 <jle`> > (\_ _ -> GT) (1::Int) (5::Int)
22:29:11 <lambdabot>  mueval-core: Time limit exceeded
22:29:14 <glguy> Because it's in a broken state
22:29:20 <jle`> oh i see
22:29:21 <Lokathor> oh poor bot :(
22:29:21 <MarcelineVQ> usually just means somone's talking to her
22:29:24 <kadoban> Lokathor: It's really slow right now, I think it's overloaded.
22:29:49 <kadoban> It's taking several seconds just to respond to :t
22:31:13 <Lokathor> does ghc or ghci have a command line option for it to resolve a single expression and exit?
22:31:18 <Lokathor> like with -e in python
22:31:41 <glguy> Yeah, -e
22:31:53 <Lokathor> oh :P
22:31:57 <Lokathor> it wasn't listed in the --help info
22:45:43 * hackagebot zip-archive 0.3 - Library for creating and modifying zip archives.  https://hackage.haskell.org/package/zip-archive-0.3 (JohnMacFarlane)
22:49:39 <osfameron> where is safeHead defined?
22:49:55 <kadoban> osfameron: 'safe' package
22:50:07 <kadoban> Or wait … is it?
22:50:27 <kadoban> safe's is probably called headMay I think … so I'm not sure.
22:50:47 <shachaf> It's called listToMaybe, unfortunately.
22:50:49 <osfameron> https://www.haskell.org/hoogle/?hoogle=safeHead didn't find anything - I'm sure I've heard it called that though
22:50:56 <osfameron> ah
22:52:24 <kadoban> Yeah, listToMaybe works too, haha, but has a different connotation to me I think. I don't see safeHead called that in stackage's hoogle either, at least not a general one.
22:55:39 <EvanR> listToMaybe xs = Just xs ;)
22:56:08 <kadoban> Haha
22:56:16 <Lokathor> anyone happen to know much about the internals of lambdabot? Any tricks to keeping the connection alive? I've got a bot and when the connection dies from the server end the bot doesn't detect it, it just hangs
22:56:58 <Lokathor> should you just kill the connection and restart the thread once an hour regardless as a way to maintain a fresh conneciton? seems silly
22:57:26 <kadoban> Lokathor: Seems like you'd want to just use a library that handles the connection for you and doesn't hang :-/
22:58:03 <kadoban> Restarting every X time seems fairly useless. It should probably reconnect on connection failure, with exponential backoff if it can't reconnect.
22:58:47 <Lokathor> but the bot can't detect when the connection dies. it waits for the next message, and the fact that the socket has died doesn't seem to get reported up through the FFI correctly or something
22:59:12 <kadoban> Lokathor: Seems like the solution is to fix that then.
22:59:25 <Lokathor> well, yes...
22:59:34 <Lokathor> "how does one do that?"
23:00:03 <kadoban> Lokathor: Well, I mean is it a problem with the library you're using, did you implement all of those parts yourself?
23:00:15 <Lokathor> I'm just using Network.Socket
23:00:30 <Lokathor> and Network.Simple.TCP
23:00:58 <kazagistar> "Simple" sounds scary
23:01:15 <Lokathor> and, every once in a long while, "recv socket 512" will just hang forever without detecting that the socket has died
23:01:48 <Lokathor> most of the time it will detect a closed socket properly, i think maybe it's netsplits or something that are the trouble
23:01:56 <kadoban> Sounds problematic :-/
23:02:09 <Lokathor> it's a little hard to test, yes
23:02:14 <MarcelineVQ> idk about network stuff but you can use the ping/pong mechanism if nothing else helps, the server uses it to see if you're still there, if the server doesn't ping your bot within a certain perdiod there's a connection problem and the bot should reconnect
23:02:37 <kadoban> Lokathor: I guess a slightly better hacky workaround than reconnecting every X minutes would be, if it doesn't see *any* activitiy for a certain amount of time, have it reconnect.
23:02:45 <MarcelineVQ> similarily if your bot doesn't respond to a ping in a certain grace period the server drops you
23:02:53 <kadoban> That sounds like a good idea ^
23:02:56 <Lokathor> MarcelineVQ, fair point. I guess I should setup a timing mechanism somehow
23:03:27 <Lokathor> i'm not sure how that would even be done exactly
23:03:28 <MarcelineVQ> I think the timeout is typically around 4 minutes or so
23:03:55 <MarcelineVQ> Do you know what I mean by the ping/pong irc mechanism?
23:04:16 <Lokathor> yes, the bot responds to pings and other message types
23:04:31 <Lokathor> what i mean is that i'm not sure what the best way to strucutre a timer would be
23:04:54 <MarcelineVQ> yes, speficially the server sends you a PING <rendom number> and within a certain ammount of time you have to send back a PONG <same nuber>
23:06:12 <Lokathor> i guess perhaps.. every time a message comes in, write a time into a "last message time" TVar, and then that runs in an async, and the thread that spawned the async sleeps 5 minutes, checks the last time var, if it's too long ago it cancels and restarts the async
23:06:18 <Lokathor> otherwise it just sleeps for another 5 minutes
23:10:44 * hackagebot oden-go-packages 0.1.0.0 - Provides Go package metadata.  https://hackage.haskell.org/package/oden-go-packages-0.1.0.0 (owickstrom)
23:16:01 <mniip> how does going from 'foo x = bar x where bar x = ... x ... bar x ...' to 'foo x = bar where bar = ... x ... bar ...' affect performance?
23:16:44 <mniip> like, in the former we don't have to close bar over x every time foo is entered, but what's the performance impact?
23:18:26 <Cale> mniip: Potentially quite a lot because of potential sharing in the second case.
23:18:55 <Cale> I think you'd have to look more carefully at the types of things involved and the structure of the computation to know for sure, but for example, if bar is a list
23:19:23 <Cale> Then in the second case, you'll end up with a cycle in memory (potentially finite memory usage)
23:19:24 <mniip> oh so the first isn't always better?
23:19:46 <mniip> well bar is actually a function, there are other arguments besides x
23:20:00 <Cale> Whereas in the first, you don't get to do that -- the work will get repeated
23:20:15 <mniip> interesting
23:20:18 <Cale> If bar is a function, then potentially part of the evaluation of which function it is can be shared in the second case.
23:21:50 <mniip> hmm
23:22:10 <Cale> The first one can also keep memory usage low, if those things which would be shared are not worth the space
23:22:25 <Cale> (because they'll be recomputed for each x)
23:22:29 <mniip> so if I have a generalized function taking a predicate, or comparator, it might after all make sense to define the function as 'fun comp = \x y z -> whatever'
23:22:37 <mniip> closing over comp but not x y z
23:22:48 <nineonine> hey there
23:22:53 <nineonine> list comprehension question here
23:23:01 <nineonine> let say we have smth like
23:23:02 <nineonine> [ [a,b,c,d] | a <- [1..100], b <- [1..100], c <- [1..100], d <- [1..100], sum [a,b,c,d] == 100 ]
23:23:14 <Cale> mniip: Well, if it's just directly a lambda like that, it's not much difference
23:23:19 <nineonine> can i make the number if returned list arbitrary ?
23:23:35 <nineonine> the number of elements in returnd list *
23:23:36 <Cale> mniip: But perhaps there's a where clause, or perhaps it looks like  fun comp = let ... in \x y z -> ...
23:23:39 <mniip> Cale, do I need to let/where-bind it?
23:24:23 <Cale> nineonine: hm?
23:25:03 <Cale> nineonine: You shouldn't have to search for d here... after picking a, b, c, the only d which will work is 100 - a - b - c
23:25:36 <mniip> nineonine, you mean you want to partition 100 into an arbitrary number of addends?
23:25:44 <Cale> oh, I see
23:25:47 <mniip> or even, any number of addends?
23:25:58 <Cale> Yeah, you'll need to write something recursive
23:26:16 <Cale> I recommend starting out by writing a function which partitions n into parts of size at most k
23:26:36 <Cale> (the recursion will go more easily that way)
23:26:58 <Cale> Though I guess if you don't want the partitions to be in decreasing order, there might not be much point in that
23:27:10 <mniip> nineonine, do you want the amount of results to be fixed?
23:27:22 <nineonine> no
23:27:46 <mniip> so like, 5 -> [[5], [4,1], [3, 2], [3, 1, 1], [2, 2, 1], [2, 1, 1, 1], [1, 1, 1, 1, 1]]
23:27:53 <nineonine> oh
23:28:01 <nineonine> in that case - yes
23:28:12 <mniip> ok so you are splitting n into k parts
23:28:16 <nineonine> i want all elements to have one length
23:28:21 <mniip> ok
23:28:32 <Cale> er, what?
23:28:45 <mniip> so what Cale said then
23:28:55 <Cale> Wait, what? :D
23:29:34 <mniip> nineonine, do you consider [4, 1] and [1, 4] the same split?
23:29:41 <nineonine> no
23:29:55 <Cale> Can you just give an example of the function you want to write applied to some small, but not too small number?
23:30:16 <Cale> Is mniip's example correct for what you want to produce?
23:30:25 <mniip> I *think* what they want is 5 2 -> [[1, 4], [2, 3], [3, 2], [4, 1]]
23:30:32 <Cale> ah, okay
23:30:47 <nineonine> yea exactly
23:31:21 <Cale> no zeroes?
23:31:35 <mniip> well the original example with 4 parts didn't include zeros
23:31:40 <Cale> I suppose so
23:31:40 <mniip> nineonine, ok, then write a recursive function taking the number you are partitioning, and the requested amount of partitions
23:31:46 <mniip> start by thinking what the base cases are
23:32:20 <nineonine> ok thanks
23:32:27 <mniip> hint: there are multiple
23:42:00 <jhrcek> What's a canonical way to convert a ShowS value to String? myshows ++ "" ?
23:42:21 <jhrcek> I mean: myshows "" ?
23:43:54 <jle`> jhrcek: yeah, i usually see people doing things like that or ($"")
23:44:26 <EvanR> $"" looks like environmental hazard in nethack or similar
23:44:49 <jle`> |...@...$""..|
23:47:15 <jle`> |...@...$""..|
