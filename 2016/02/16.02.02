00:01:18 <kvda> what's the name for functions that given A input will provide B, then another function will turn B into A?
00:01:20 <johnw> mniip: 'Free f' lifts a functor 'f' into a Monad, regardless of 'f'; cf. how [] lifts any type into a Monoid. The ability to "endow" *any* type with a richer structure, is part of what freeness is in this context.
00:01:23 <mniip> ah yes, when I allocate a stack for the target executable, linux thinks it is a thread stack, and even after the original stack is unmapped, the kernel still treats it as such
00:01:25 <kvda> idempotent? isometric?
00:01:28 <kvda> it was something like that
00:01:37 <johnw> kvda: isomorphic?
00:01:45 <kvda> isomorphic! thanks johnw 
00:01:46 <kvda> :)
00:01:52 <mniip> johnw, well
00:02:03 <mniip> 'Foo a' lifts a Functor 'f' into a Monad?
00:02:12 <johnw> I didn't see any 'f' in your definition
00:02:16 <mniip> er
00:02:19 <mniip> 'Foo f' lifts a Functor 'f' into a Monad?
00:02:36 <mniip> wait
00:02:38 <johnw> then your Return wouldn't type check
00:02:40 <mniip> I need to rethink this
00:03:12 <jle`> kvda: it's only an isomorphism if it does that in general for all items in the input/output range
00:03:20 <jle`> not just for a specific value A and B
00:03:35 <mniip> data Foo f a = Return a | Join (Foo f (Foo f a))
00:03:36 <mniip> this
00:03:48 <kvda> yup, thanks for the clarificiation jle` 
00:04:24 <mniip> hmm a pretty boring monad it looks like
00:04:28 <jle`> np
00:04:35 <mniip> ok, nevermind
00:04:50 <jle`> it's probably the most boring monad, by construction :)
00:08:03 <johnw> mniip: that still ignores 'f'
00:08:11 <johnw> it's effectively just a phantom type in that definition
00:12:47 <mniip> on a totally unrelated note,
00:14:09 <mniip> instance Alternative IO where empty = throwIO (userError "empty"); a <|> b = catch a (\(e :: SomeException) -> b)
00:15:52 <johnw> what if 'a' didn't fail, but an async exception occurred while running it (for example, by using "timeout"); should 'b' really swallow that exception and then run?  that would make the behavior of "timeout"  for a <|> b unpredictable (it will timeout while running 'b', but not while running 'a')
00:17:38 <mniip> data AlternativeIOException = AlternativeIOException deriving (Show, Typeable, Exception)
00:18:07 <mniip> instance AlternativeIO where empty = throwIO AlternativeIOException; a <|> b = catch a (\AlternativeIOException -> b)
00:18:20 <johnw> ah, that's much better
00:18:31 <mniip> :)
00:18:46 <mniip> and then we can do backtracking in the IO monad!
00:19:02 <mniip> FreeT ((->) t) IO a
00:19:11 <jle`> (launchMissiles *> throwIO e) <|> return 10
00:19:43 <mniip> hmm
00:19:55 <mniip> I kinda intended it to catch all exceptions originally though
00:25:54 <KaiJia> 3 * 5
00:26:40 <KaiJia> 3 * 5
00:26:44 <pavonia> 14
00:26:46 <srhb> > 3 * 5
00:26:48 <lambdabot>  15
00:27:02 <srhb> pavonia: You're a bad person. :-P
00:27:13 <pavonia> :p
00:27:36 <KaiJia> > 3 * 5
00:27:38 <lambdabot>  15
00:28:21 <shachaf> > compare a (-a)
00:28:22 <lambdabot>  LT
00:28:24 <shachaf> > compare z (-z)
00:28:26 <lambdabot>  GT
00:28:51 <liste> > (a, z)
00:28:53 <lambdabot>  (a,z)
00:33:50 <KaiJia> @pavonia #!@$#
00:33:50 <lambdabot> Unknown command, try @list
00:37:34 <KaiJia> pavonia:hello
00:37:39 <KaiJia> pavonia hello
00:38:19 <pavonia> Hello too ;)
00:48:49 * hackagebot http-media 0.6.3 - Processing HTTP Content-Type and Accept headers  https://hackage.haskell.org/package/http-media-0.6.3 (TimothyJones)
00:48:49 * hackagebot stylish-haskell 0.5.15.1 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.5.15.1 (JasperVanDerJeugt)
00:56:35 <truman1> How do I compile an executable with stack to see the GHC core output? I'm trrying: `stack install --ghc-options="-ddump-simpl"` to no avail.
01:05:45 <magic_> hi, does anyone know how to setup ghcmod-vim with stack?
01:06:43 <magic_> i managed to get ghc-mod by installing stack nightly, but i am not quite sure how to configure the local directories stack uses
01:07:00 <kadoban> truman1: I'd think you want more 'stack build' instead of 'stack install', though it shouldn't matter much. Does --force-dirty help? stack won't usually rebuild things it doesn't have to (if no files changed for instance), so it wouldn't have any invocation of GHC to pass those options to necessarily.
01:07:20 <MasseR> magic_: I just did 'stack install ghc-mod' and it works somewhat
01:07:30 <MasseR> Sometimes it can't find stack ghc-pkg path
01:07:33 <MasseR> Sometimes it can
01:07:37 <magic_> sure, i could install ghc-mod
01:07:39 <truman1> kadoban: thanks, I'll give that a try.
01:07:56 <kadoban> magic_: I thought ghc-mod understood stack projects enough for it to Just Work, but I'm not sure.
01:08:12 <magic_> however since both ghc, and ghc-mod are binaries in local (different) directories ghcmod-vim seems to ahve a problem
01:08:25 <MasseR> magic_: you need to export your PATH
01:08:32 <magic_> i did
01:08:39 <cordawyn> is this intended that "liftM2 (:) (Right 1) (Left 2)" yields "Left 2"?
01:08:57 <magic_> to both directories i am assuming?! since ghc-mod seems to use ghc
01:09:08 <kadoban> cordawyn: Yes
01:10:00 <cordawyn> kadoban: thanks, I'll have to dig into that myself then
01:10:22 <kadoban> cordawyn: The meaning for Either e's Monad instance is … computations that can fail with an error. So Left 2's meaning here is "an error".
01:10:53 <MasseR> magic_: both directories?
01:11:02 <cordawyn> nice, so I won't be abusing this feature then :)
01:11:07 <MasseR> There's only one
01:11:42 <magic_> ghc-mod is in a kind of global bin direcotry, whereas ghc is project specific 
01:11:55 <magic_> so i need both in my path i am assuming
01:12:16 <MasseR> no
01:12:26 <MasseR> I don't think
01:12:33 <kadoban> Does ghc-mod actually require the ghc binary?
01:12:35 <MasseR> But that could explain why my ghc-mod only works part of the time
01:13:00 <magic_> yes, if the ghc bin is not in the path, i cannot run ghc-mod
01:13:31 <MasseR> interesting, I didn't have that problem
01:14:33 <magic_> once it is in the path and i call ghc-mod i ge: launching operating system process `cabal configure` failed: cabal: readProcessWithExitCode: runInteractiveProcess: exec: does not exist (No such file or directory)
01:15:05 <MasseR> I find ghc-mod to be some combination of deep magic and moon position
01:15:14 <MasseR> Works now, doesn't work on the next project
01:15:20 <magic_> haha, indeed
01:15:40 <MasseR> Shame really, it provides great functionality
01:16:07 <greeny> good morning. im trying to implement an algorithm that need to mutable arrays to perform well. how can i do this in the ST monad? i thought a transformer class would help but ST.Trans is experimental yet
01:16:16 <MasseR> But with cabal hell, cabal sandboxes, stack, virthualenv, we have a fast moving target for tools such as these
01:16:22 <greeny> *two mutable array
01:16:30 <MasseR> Can't really expect any kind of stability
01:16:57 <magic_> well ghc-mod used to work before i started using stack
01:19:29 <mjrosenb> is Prelude.read: no parse something that I should be able to acoid with catch?
01:20:44 <kadoban> greeny: Are you familiar with how to use ST to mess around with one mutable array and adding a second is proving difficult for you, or?
01:20:51 <mniip> mjrosenb, depends on how unexpected the situation is
01:21:03 <mniip> you might be more interested in 'reads' and 'readMaybe'
01:22:11 <greeny> kadoban: you got it
01:25:52 <greeny> i thougt carrying around  two different array states could be done via a transformer class...
01:27:04 <EvanR> greeny: i found this http://stackoverflow.com/questions/21915204/using-and-returning-multiple-stuarrays
01:27:11 <mjrosenb> the code is already using catch.
01:27:26 <mjrosenb> I want it to treat a malformed file the same as if it didn't exist
01:27:38 <mjrosenb> I thought catch could do that, but maybe not?
01:28:07 <EvanR> dont try to catch Prelude.read: no parse
01:28:25 <EvanR> use readMaybe and on Nothing throw an IO error (if you already are catching IO errors)
01:28:38 <EvanR> with throwIO
01:29:04 <EvanR> you can wrap the functionality in a function of this type
01:29:40 <EvanR> Read a => String -> IO a
01:30:11 <greeny> EvanR: that looks great. i searched the whole morning on the internet but havn't found this
01:30:24 <greeny> thanks
01:33:02 <greeny> some domjudge problems have a certain space limit. hope this will work now :)
01:59:52 <trubert1> I'm not understanding why I cannot generate a GHC Core file for my executable. I'm trying `cabal clean && cabal install --ghc-option=-ddump-simpl --ghc-option=-ddump-to-file`
02:00:04 <trubert1> Why is this not generating a Core file?
02:26:11 <mchall> I want to derive a new show for my datatype   data Card =  Card Int String how do I refer to the Card Int and Card string ?
02:27:35 <dramforever> show (Card foo bar) = ...
02:31:22 <dramforever> Question: How do I configure stack to use an HTTP proxy when downloading stuff?
02:38:47 * hackagebot polar-shader 0.1.0.4 - High-level shader compiler for Polar Game Engine  https://hackage.haskell.org/package/polar-shader-0.1.0.4 (Shockk)
02:43:13 <mchall> dramforever thanks, how do I convert the Int to a string so I can get from Card 5 Spades , "5Spades" instead of 5"Spades"
02:43:44 <domen> ['5']
02:45:04 <pavonia> mchall: How does your code look like now?
02:46:03 <mchall> instance  Show Card where  show (Card a b)   = show a ++ show b
02:46:36 <dramforever> > "Spades"
02:46:38 <lambdabot>  "Spades"
02:46:42 <dramforever> > show "Spades"
02:46:43 <lambdabot>  "\"Spades\""
02:47:19 <dramforever> > text (show Spades) -- text is like putStrLn in lambdabot
02:47:20 <lambdabot>      Not in scope: data constructor ‘Spades’
02:47:20 <lambdabot>      Perhaps you meant ‘Space’ (imported from Data.Char)
02:47:29 <dramforever> > text (show "Spades") -- text is like putStrLn in lambdabot
02:47:31 <lambdabot>  "Spades"
02:50:05 <mchall> dramforever this is what I tried instance  "Show Card where  show (Card a b)   = text (show a) ++ show b" and this is the error I got :  Not in scope: `text'
02:50:26 <mchall> this is part of the monad challenge using a custom prelude
02:50:52 <dramforever> sorry I might have confused you, text is in lambdabot for printing strings without quotes
02:51:44 <dramforever> mchall: you see, you are seeing 5"Spades", and just think about it. It's not that you need to convert the 5 to a string. It's that you need to avoid quoting the Spades
02:54:58 <dramforever> mchall: Need more hints? What is show b supposed to do?
02:55:23 <mchall> instance  Show Card where  show (Card a b) =  show a ++  b
02:58:51 <mchall> instance  Show Card where  show (Card a b) =  show (show a ++  b)
02:59:01 <zipper> How do I look up the type signature of a function on lambdabot if I can't find it on hoogle?
02:59:03 <mchall> dramforever many thanks
02:59:27 <EvanR> lambdabot and hoogle are both incomplete, you should use the docs for that function
03:01:33 <dramforever> mchall: you're welcome'
03:07:05 <dramforever> Proxy problem solved: should have used https_proxy instead of http_proxy
03:24:26 <pavonia> mchall: You don't want the outer show, do you?
03:26:47 <mchall> pavonia you're right I don't, I misinterpreted what I needed to get which was       show (Card 2 "h") == "2h"
03:27:18 <mchall> I forgot there was a show already in the example
03:35:55 <lostman_> is there a way to get tasty to display multi-line error messages nicely? it displays them as string "some text\nanotherline\nit stopped being readable a while ago"
03:40:13 <sbrg> lostman_: error messages from what?
03:40:23 <lostman_> from failed tests
03:40:44 <sbrg> well, if you display a string, yo uwill see the newlines. if you print it, the newlines will be printed properly.
03:41:17 <sbrg> if it's a pure functoin, then something like: putStr stuffThatReturnsAStringError
03:41:26 <sbrg> otherwise, if it's IO, stuff.. >>= putStr
03:42:24 <lostman_> yeah, but tasty has cabal/stack integration and I'm just checking whether there's any control over that. for instance, I have a bunch of golden tests (trough tasty-golden) and the output is like this: "Test output was different from 'input.golden'. It was: "long output with\nhere and\n there"
03:42:32 <sbrg> aah. 
03:42:53 <lostman_> I wouldn't mint that being a bit more verbose and easier to read
03:43:03 <sbrg> I'm not very familiar with tasty, I'm afraid
03:46:17 <lostman_> no worries. just checking whether this can be controlled. whenever I look into Travis logs and see the output jumbled up like that I end up comparing things manually on my computer so it's easier to read.
03:48:50 * hackagebot psc-ide 0.6.1 - Language support for the PureScript programming language  https://hackage.haskell.org/package/psc-ide-0.6.1 (kritzcreek)
03:50:17 <guest4587> 2016-02-02 17:19 !!! ":stormogulen!~user@c-94-255-196-118.cust.bredband2.com JOIN #emacs" (error Invalid search bound (wrong side of point))
03:56:46 <bouliiii> hello all, I see that unboxed vector of tuples are stored in struct of arrays. But, the linear package stores them as arrays of struct. Is there a specific rational for each implementation? They have obviously different domains of applications regarding performance but I was wondering why we have different storages for both.
04:08:51 * hackagebot language-puppet 1.1.5 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.1.5 (SimonMarechal)
04:13:50 <zipper> How can I make the result of this function hamletFile https://hackage.haskell.org/package/shakespeare-2.0.7/docs/Text-Hamlet.html to the type Lazy Bytestring?
04:13:51 * hackagebot github 0.14.1 - Access to the GitHub API, v3.  https://hackage.haskell.org/package/github-0.14.1 (phadej)
04:24:03 <JazzyEagle> Hey, when someone gets a chance, I need help again with network-conduit-tls (1.2.0.1).  In Data.conduit.Network.TLS, there is a datatype of TLSClientConfig that appears to be made importable in the module definition.  When I try to create a variable of datatype TLSClientConfig, it tells me that the constructor isn't in scope, even though I see it in the Module declaration...
04:24:47 <JazzyEagle> I made sure that my file is importing all of Data.Conduit.Network.TLS, not just a couple of functions/declarations.  Any idea why I may not have access to that data constructor?
04:25:37 <sbrg> JazzyEagle: There's a `tlsClientConfig` function instead of the constructor being exported, it seems
04:25:41 <sbrg> it's what I used, at any rate
04:25:49 <JazzyEagle> I have access to the quick function to create a TLSClientConfig (tlsClientConfig), but not creating one using the actual constructor.  Unfortunately, I need to make a setting change on one particular field that the smart constructor doesn't allow me to utilize.
04:26:11 <sbrg> JazzyEagle: then you access the fields of it directly, if those are exposed.
04:26:40 <sbrg> let cfg = tlsClientConfig foo bar baz in cfg { fieldFoo = bar }
04:27:05 <JazzyEagle> sbrg: but tlsClientConfig is a function call, not a constructor.
04:27:31 <JazzyEagle> That's why I'm trying to use the constructor directly.
04:27:43 <lostman_> JazzyEagle: which field are you trying to access?
04:28:16 <JazzyEagle> Within TLSClientConfig -> tlsClientTlSSettings -> settingDisableCertificateValidation
04:28:42 <JazzyEagle> lostman_: Unfortunately, it's the only way I can seem to figure out how to get around the self signed certificate error.
04:28:57 <JazzyEagle> The client isn't connecting to the server because it's a self signed certificate.
04:29:21 <JazzyEagle> So the only way I can see to make it connect is for it to not validate the certificate at all.
04:29:34 <JazzyEagle> Which totally sucks, but it's just for testing purposes, so I'm not going to worry about that at the moment.
04:29:52 <sbrg> the constructor seems to be exported, at least in the newest version. are you sure you're looking at the docs for the version you're using?
04:30:25 <JazzyEagle> sbrg: I'm looking at http://hackage.haskell.org/package/network-conduit-tls-1.2.0.1/docs/src/Data-Conduit-Network-TLS.html#TLSClientConfig
04:30:36 <JazzyEagle> And I agree that it appears to be exported, which is why I'm baffled by the error.
04:30:50 <sbrg> JazzyEagle: yes. and are you using that version of the library?
04:31:04 <sbrg> There's also the tlsClientTLSSettings which you can use as I explained above.
04:31:21 <JazzyEagle> sbrg: Yes.  I'm using stack with LTS 5.1, which uses network-conduit-tls-1.2.0.1
04:31:37 <sbrg> let cfg = tlsClientConfig 80 "www.google.com" in cfg { tlsClientTLSSettings = .. }
04:32:29 <JazzyEagle> tlsClientTLSSettings extracts the TLSSettings out of a TLSClientConfig.  It doesn't let me put it back in.
04:33:37 <sbrg> yes, it does. 
04:33:44 <JazzyEagle> sbrg: I'm still confused who you're using "in cfg { tlsClientTlSSettings...}
04:33:45 <lostman_> JazzyEagle: this is the Haskell record update syntax. tlsClientTLSSettings is the record field accessor
04:34:17 <sbrg> JazzyEagle: https://gist.github.com/46fcf60dae7697047c09
04:34:36 <lostman_> data Foo { foo :: Int } will get you foo :: Foo -> Int; this can be used to extract it or to modify it. let f = Foo 32 in f { foo = 42 }
04:35:08 <sbrg> ^
04:36:26 <JazzyEagle> Ok, so I guess I missed that part about record syntax while reading.  So, because we're working with immutables, is it basically creating a new copy of the variable but changing that particular record?
04:36:34 <sbrg> yep
04:36:53 <sbrg> that is the gist of it. AFAIK it tries to keep as much of the previous record as it can(the part that you're not modifying)
04:37:07 <sbrg> s:modifying:updating:
04:37:10 <JazzyEagle> Huh...  Kind of weird I have to do it in a two step process, but if it works...
04:37:14 <JazzyEagle> Let me give it a shot.  Thanks!!
04:37:36 <sbrg> the haskell record syntax is generally considered to be one of the least attractive things about haskell
04:38:55 <sbrg> JazzyEagle: at any rate, it is pretty normal to provide a smart constructor for the most common usecase(s) and then just let people use record updates to update other parts if they really need to
04:40:45 <dbushenko> is there ghc 8 for stack?
04:43:14 <JazzyEagle> sbrg: Good to know.  Ok, one more error.  I'm going to need to paste this one, as I'm not sure what's going on here...
04:44:18 <JazzyEagle> http://lpaste.net/3563217233695997952  I'm not sure why config is not in scope, as I'm defining it with a let command...
04:45:52 <sbrg> ah. because you're using let .. in .. you're saying "let this variable be this value, but only in the following scope"
04:46:55 <KaiJia> how to ignore join/quit message
04:46:57 <sbrg> you can simply put parentheses around stuff. this should work: http://lpaste.net/3563217233695997952
04:47:12 <sbrg> haven't tested it htough
04:47:56 <JazzyEagle> Will try that right now.  Do I still need in?
04:48:30 <lostman_> strange that it fails with config not in scope. that line `let config = ... in config { ...}` has type TLSConfig, no? 
04:48:58 <dbushenko> is there a way to deal with same record fields in different record types within same module?
04:49:10 <lostman_> JazzyEagle: you don't use in if you're inside do notation
04:49:40 <JazzyEagle> lostman_: Ok.
04:49:58 <JazzyEagle> It should have type TLSClientConfig, yeah.
04:50:19 <EvanR> dbushenko: yes. rename the fields
04:50:24 <JazzyEagle> Ok, I did what sbrg indicated, and am getting what appears to be other scope error with Network.Connection...
04:50:40 <EvanR> you can also move one of the records into another module
04:51:36 <JazzyEagle> I think I have to do another one of those function default things.
04:51:39 <dbushenko> no, thats not the solution
04:51:47 <EvanR> both are ways to deal with it
04:52:21 <dbushenko> I'm waiting for OverloadedRecords and DuplicateRecordFields but ghc8.0 is still on its way
04:52:36 <dbushenko> is there a way to get it working with stack somehow?
04:52:39 <JazzyEagle> No, I used the wrong constructor name.  I missed it.
04:52:41 <EvanR> in some libraries you see stuff like MyType'fieldA, MyType'fieldB
04:53:04 <EvanR> which amounts to the same as using another module and being like MyType.fieldA
04:53:09 <EvanR> the later is more flexible
04:53:15 <JazzyEagle> Awesome!!!  It works!!!
04:53:18 <JazzyEagle> Thank you all very much!!!
04:53:43 <sbrg> yw
04:53:53 <EvanR> i hope overloaded record fields works out
04:54:02 <dbushenko> EvanR, can you show me any reference? I just want to have those records within one file
04:54:14 <EvanR> without too much manual disambiguation
04:54:14 <icbm> In other languages, I'm accustomed to `xs.Add(x)`, but in Haskell, it seems that Monoid is preferred: `xs <> singleon x`.  Is this idiomatic?  For Seq, should I prefer `xs <> singleton x` over `xs |> x` ?
04:54:35 <EvanR> dbushenko: a reference to what
04:54:59 <dbushenko> to the stuff like you showed me
04:55:06 <dbushenko> I just didn't understand your solution
04:55:23 <EvanR> you have type A and type B in the same module with field name foo
04:55:43 <EvanR> so one fix is to rename one foo to A'foo and the other to B'foo
04:56:19 <dbushenko> ah, you mean that renaming...
04:56:56 <dbushenko> its a bit wordy but may be yes, in my case its better than splitting them to different modules
04:56:58 <dbushenko> thanks
04:57:51 <EvanR> i cant find the lib i saw that in
04:58:44 <dbushenko> no probs, I see your point, its OK for me, thanks
04:59:17 <lostman_> is there a way to query the amount of memory available in the system?
05:01:48 <rod_> Hi everyone, can someone help me with my program ? Trying to retrieve info from Web-Api in a repl-style hamradio-logbook program to autofill some logbook entries; however ....       
05:02:19 <rod_> ... the web-api-lookup is performed only when i quit the program ... have already tried different HTTP libs and BangPatterns to force strict evaluation ... no succsess ..... prog is @ http://lpaste.net/151452
05:03:07 <rod_> ...function doing web-api-lookup is "qrz"
05:03:42 <bouliiii> Interestingly, for vectors, using struct of arrays for unboxed tuples leads to O(1) zips. But there is an interesting side effect for the mutable version: the zipped vector now *references* its arguments and modifying the arguments modifies the zipped one.
05:10:45 <SX> Hi! Is there any class for Maps? To abstract over hashmap, map etc?
05:11:16 <SX> With lookup, fromList etc
05:11:24 <EvanR> they depend on wildly different support
05:11:25 <Axman6> the lens library abstracts over map like things
05:21:00 <troydm> Erlang has mnesia, is there something equivalent in Haskell?
05:21:35 <Manny12> Can anyone help me? Stuck behind firewall on tablet 
05:21:45 <Manny12> In China
05:22:09 <Manny12> Openvpn couldn't join 
05:22:15 <nchambers> vpngate.com
05:22:38 <Manny12> I installed it - soft ether
05:22:45 <nchambers> https://gist.github.com/Lazza/bbc15561b65c16db8ca8
05:23:02 <Manny12> But the default cx didn't load. It's very hard in China online 
05:23:12 <Jinxit> troydm: probably helps if you describe mnesia for those who don't know erlang
05:23:38 <nchambers> is erlang the one with the terrible errors?
05:23:59 <nchambers> nmd thats ocaml
05:24:00 <Jinxit> terrible in the sense that you get everything
05:24:19 <Jinxit> the entire state of your process when it crashed can be pretty huge
05:26:06 <Manny12> Last call, anyone? 
05:26:39 <Jinxit> I think this isn't the right channel for your issue, Manny12 
05:27:19 <troydm> Jinxit: basicly it's embedded database engine, https://en.wikipedia.org/wiki/Mnesia
05:28:40 <Manny12> Yes, no idea where to go unfort, ah well
05:29:17 <Heather> hello, what is easy way to have some optional argument?
05:29:18 <nshepperd_> Manny12: try #openvpn
05:29:40 <Heather> I've found some answer on stackoverflow but it was hard, very hard
05:31:48 <nshepperd_> icbm: I would prefer 'xs |> x'. It's shorter and does the same thing slightly more efficiently
05:32:25 <icbm> nshepperd_: Cool, that's what I suspected.
05:33:08 <bergey`> Heather: For one optional argument, I might have the argument type be Maybe Foo, or I might just make two functions.
05:33:30 <Jinxit> why do you want it to be optional?
05:33:48 <icbm> nshepperd_: In my toy project, I've also written an `Accum x a` typeclass that lets me generalize the |> to things which contain the Seq.
05:34:13 <bergey`> For a bunch of optional arguments, I sometimes make a record of them, with a Default instance, so the programmer can call `foo def` override some part of `def`.
05:35:26 <Heather> berge` I want normal solution, not poor man's optional arguments :)
05:35:45 <Heather> Jinxit it's handy to use optional argument
05:35:57 <Jinxit> but for what reason?
05:35:58 <nshepperd_> an optional argument is sometimes a sign your function is doing too much for a logical unit
05:36:10 <Jinxit> ^
05:36:47 <Jinxit> I usually view optional arguments as a bad design
05:38:52 <nshepperd_> if it frobnicates the combulator when you pass `Nothing`, and evolves the fizzbuzz when you pass `Just fizzbuzz`, maybe you really want two functions frobnicateCombulator and evolveFizzbuzz
05:39:18 <Heather> Jinxit well... imagine you define rule - action - and optionall dependies (alike in makefile)
05:39:43 <Heather> Jinxit for now I think about two variants - optional dependies or some mystical operator
05:39:59 <Jinxit> how about a list of dependencies that might be empty?
05:40:59 <int-index> You can write polyvariadic functions using type-class hackery, it's ugly on type-level but on term-level it looks exactly like optional arguments.
05:41:09 <Heather> Jinxit so my user will write [] everytime?
05:41:19 <Heather> Jinxit isn't it just poor
05:41:39 <Jinxit> typing isn't where programmers spend most of their time
05:42:01 <Jinxit> I prefer the clarity
05:42:09 <Heather> int-index Jinxit I've found some solution on StackOverflow but it was complicated, hard - and I exactly writing this thing to avoid complexity XD
05:42:28 <Jinxit> and simple > easy
05:43:08 <Heather> Jinxit I'm agreed that typing is not problem but [] in the end of rules is ugly thing
05:43:14 <int-index> Heather, if you want to avoid complexity you shouldn't look for optional arguments
05:43:24 <Heather> Jinxit I recently used html - generator on haskell
05:43:28 <nshepperd_> certainly [] is simple to understand
05:43:32 <Heather> there are was a lot of optional arguments
05:43:51 <Heather> nshepperd_ well it's not something you want to see in eDSL, really
05:43:56 <zomg> One easy solution would be to have the options as a data type and then have functions to build them
05:43:58 <Heather> even when it's simple
05:44:08 <zomg> since there's clearly two different common use cases
05:44:14 <Jinxit> maybe you want two functions - rule and ruleWithDependencies?
05:44:29 <Heather> take a loot to yet another EDSL as example - Lucene library
05:44:36 <Jinxit> some use ' for this purpose, rule and rule', but I think that's complex
05:44:39 <zomg> this way you could just use the function for the current case to build the config for the function and avoid the extra params or any trickery required for them
05:44:42 <Heather> it's built with optional arguments in mind - and it's not bad
05:45:07 <Heather> Jinxit it's still being "poor man solution" or "look, my language sucks" thing
05:45:29 <nshepperd_> Heather: certainly, if you have some rule type, you can have an operator like `!> :: Rule -> Dependency -> Rule` that would add a dependency to a rule object
05:45:33 <badmash> hello there
05:45:39 <Heather> Jinxit it's not something that solves problem, it's way to avoid it
05:45:59 <Jinxit> yes, because I think you're solving the wrong problem :)
05:46:07 <Heather> nshepperd_ well... currently my rule is just a string
05:46:25 <Jinxit> your rule could certainly stand to gain from the type system
05:46:36 <nshepperd_> Heather: `rule target action !> dep1 !> dep2`
05:46:47 <nshepperd_> Heather: or some other operator that looks nicer than that lol
05:46:48 <Jinxit> what nshepperd_ described is nice, it allows you to add multiple dependencies to a rule
05:46:52 <Jinxit> yeah exactly
05:47:21 <Jinxit> or rule target action !> [dep1, dep2] if you expect it to be multiple most of the time
05:47:28 <Heather> Jinxit imagine some language where you write additional things just because developer wanted to make things simple... e.g. for example imagine haskell without syntax sugar things (alike do)
05:48:11 <Jinxit> you don't think simplicity is worth striving for?
05:48:18 <nshepperd_> Heather: so it can be not a string for now, then convert it later, putting the dependencies where they need to be
05:48:40 <Heather> Jinxit nshepperd_ still can't understand how !> could be realized...
05:49:08 * hackagebot shakespeare-babel 0.2.0.0 - compile es2015  https://hackage.haskell.org/package/shakespeare-babel-0.2.0.0 (ncaq)
05:50:05 <kqr> anyone here familiar with Turtle.Pattern? I would like to construct a pattern that matches the same thing as the regex /^[^.]+.txt$/. I tried doing (invert (prefix ".") *> suffix ".txt") but this does not work
05:50:05 <nshepperd_> Heather: data Rule = Rule { target :: String, command :: String, dependencies :: [String] } (I assume these things are strings)
05:50:24 <nshepperd_> Heather: then define !> to just add whatever dependency into that list
05:50:47 <Jinxit> as Rule -> String -> Rule
05:50:49 <Heather> nshepperd_ alike... different constructors?
05:52:30 <nshepperd_> Heather: there's only only one constructor, `target/command/dependencies` are fields of the data type
05:53:24 <kqr> oh wait, I may be misunderstanding something different. never mind!
05:54:15 <nshepperd_> then when you build rules you use a function 'rule tgt cmd = Rule tgt cmd []'
05:55:31 <Heather> nshepperd_ I see... I wrap it into some type then modify type with operator?
05:55:42 <Heather> sounds like a way for me if you mean so
05:55:47 <nshepperd_> yep
05:56:10 <zyxoas> Peepmeisters of mine.
05:56:47 <nshepperd_> well gtg
05:56:48 <zyxoas> I'm having difficulty running doctest on Circle-ci, although I'm hoping someone can recognise this error regardless of the platform.
05:56:48 * Clint squints.
05:56:51 <Heather> nshepperd_ the only problematic thing is that I planned to specify it before declaring action
05:58:33 <badmash> hello there
05:58:40 <naudiz> can someone recommend a good graph library? Data.Graph from containers is lacking manipulation functions.
05:59:11 <badmash> is haskell-mode a nice thing to have for haskell development on emacs?
05:59:17 <sbrg> badmash: yes.
05:59:25 <sbrg> i can't live without it
05:59:48 <badmash> sbrg: is it pretty stable etc? no real headaches, and well-maintained?
05:59:54 <int-index> naudiz, what kind of manipulations do you want to perform? 
06:00:22 <naudiz> int-index: insertion, deletion, maybe even manipulating connections
06:00:44 <naudiz> oh, and it would be nice if it had something like path lengths 
06:01:00 <badmash> sbrg: and you need ghc-mode as well, right?
06:01:50 <sbrg> i don't think I have ghc-mode
06:01:55 <sbrg> and yes, it is very stable and very well maintained
06:01:58 <sbrg> just look at the github repo
06:02:01 <sbrg> there's also haskell-emacs
06:02:06 <sbrg> #haskell-emacs *
06:02:30 <badmash> sbrg: alright, thanks
06:02:45 <byorgey> naudiz: fgl, perhaps?
06:05:15 <fizruk> hey guys! I want to map a list of types [k] into a list of values [a] using (forall t. c t => proxy t -> a), is there a function for this somewhere?
06:05:32 <naudiz> byorgey: it does look promising. Thank you!
06:06:21 <zyxoas> I'm getting the following error when I try to run a doctest described in my cabal file, on circle-ci: setup-Simple-Cabal-1.22.5.0-ghc-7.10.3: can't find source for Doctest in .stack-work/dist/x86_64-linux/Cabal-1.22.5.0/build/doctests/doctests-tmp, test
06:06:49 <benzrf> fizruk: what would be the type of the list?
06:06:55 <zyxoas> Does this make sense to anyone? "can't find source for doctest in ...doctests-tmp"?
06:07:29 <int-index> fizruk, do you expect `t` to unify with `k`?
06:07:32 <fizruk> benzrf: input list would be proxy (xs :: [k])
06:07:41 <fizruk> int-index: no, t :: k
06:07:51 <int-index> oh, I misread your message
06:19:33 <int-index> so you have `f :: forall t. c t => proxy t -> a` and you want `populate f (Proxy :: Proxy '[Integer, Bool])` to expand into `[f (Proxy :: Proxy Integer), f (Proxy :: Proxy Bool)]`
06:20:01 <int-index> it looks like you'll need a type class for that, not a mere function. Haven't seen such typeclass anywhere, though
06:20:41 <domen> hey folks, will Repa eventually become part of the Prelude?
06:20:52 <int-index> domen, no.
06:21:07 <domen> why not?
06:21:34 <int-index> Why would you put a highly specialized set of tools for parallel programming into a module that is imported by default EVERYWHERE and restricted by the standard?
06:22:01 <fizruk> int-index: sure, typeclass, just seemed general enough to maybe be out there somewhere
06:22:44 <int-index> fizruk, closest I found is `apply` from `exists` but it's still quite far from what you want
06:23:49 <domen> i think that parallel programming will eventually become so essential that it will need to be included in basic tools
06:26:11 <int-index> domen, we won't have parallelism by default before we figure DPH
06:26:15 <bergey> Is Repa stalled the same way as Data Parallel Haskell in general?
06:27:03 <int-index> bergey, from what I know, it's the same people behind both projects
06:27:14 <int-index> repa is somewhat a playground for DPH ideas
06:27:20 <domen> what is DPH?
06:27:22 <ahihi> plenty of things that might be considered essential are not in the prelude, I don't really see that as a problem
06:27:23 <bergey> In general, libraries work fine, so we don't move things into base unless we need them for something already in base (eg, semigroup, overloaded record fields)
06:29:06 <geekosaur> domen: data parallel haskell
06:29:16 <geekosaur> which is kinda dead at the moment
06:29:36 <domen> thanks for reply, i'll check this
06:43:23 <fizruk> can anyone tell me, what's going on? am I missing something or is this a bug in typechecker? http://lpaste.net/151496
06:47:50 <int-index> it's an ambiguity check
06:47:54 <int-index> did you try turning it off?
06:52:19 <int-index> Disabling ambiguity check makes it compile for me.
06:52:37 <int-index> Although it does look like a false positive
06:52:41 <int-index> so might be a bug
06:53:48 <fizruk> that's what I thought, a false positive
06:56:43 <shapr> yay haskell!
06:56:51 <shapr> fun with number theory
07:14:02 <truman1> What is the status of auto-vectorisation with the vector library, when the LLVM backend is used? https://ghc.haskell.org/trac/ghc/wiki/SIMD
07:14:11 * hackagebot apply-refact 0.2.0.0 - Perform refactorings specified by the refact library.  https://hackage.haskell.org/package/apply-refact-0.2.0.0 (mpickering)
07:17:48 <lep_> :hoogle (a -> b) -> f a -> f b
07:18:21 <maerwald> @type fmap
07:18:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:18:38 <lep_> i just wanted to see if this channel has hoogle support
07:18:40 <lep_> cant remember
07:18:47 <maerwald> @hoogle (a -> b) -> f a -> f b
07:18:49 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
07:18:49 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
07:18:49 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
07:18:52 <shapr> seems to work
07:19:00 <lep_> ya, just wrong syntax
07:19:01 <shapr> lep_: does your ghci have hoogle support?
07:19:02 <lep_> been a while
07:19:05 <lep_> ofc!
07:19:08 <shapr> oh good!
07:19:14 <lep_> nah, im just testing
07:19:17 <shapr> I still wonder if using @command was a good syntax choice
07:19:25 <lep_> coz i have written my own typesarch for another language
07:19:31 <shapr> lep_: oh that's cool
07:19:35 <shapr> lep_: which language?
07:19:37 <shapr> rust?
07:19:41 <lep_> very niche
07:19:43 <lep_> jass
07:19:56 <lep_> i just wanted to see if hoogle in irc displays colors
07:23:02 <shapr> truman1: sounds like a question for #ghc
07:23:17 <truman1> shapr: ok thanks.
07:36:01 <fractalsea> Can you ever get “blocked indefinity in STM transaction” if only using a combination of `tryTake` and `tryPut`?
07:49:57 <ggVGc> is there any syntax extension or commonly used practice for accessing record fields left to right?
07:50:14 <ggVGc> I've defined 'a # b = b a' atm, but that doesn't seem so great
07:53:32 <bergmark> ggVGc: Data.Function.(&)
08:00:23 <ggVGc> bergmark: thankw
08:00:25 <ggVGc> eh, thanks
08:00:55 <Gurkenglas_> Haskell isn't installed on this computer. How can I run some Haskell code on an input file, perhaps online? If there was no input file I could use lpaste.net and lambdabot's @letlpaste. The file is perhaps a few thousand lines.
08:03:32 <Gurkenglas_> A haskell compiler that doesn't require sudo rights to install it would also work.
08:05:59 <ernst> Gurkenglas_: there are ghc tarballs https://www.haskell.org/ghc/download_ghc_7_10_2 afair you only needed to unpack them
08:07:57 <OutlawStar> hi all, question: i have a package a that uses a sandbox and uses another local package b, package b has a dependency on a C library. When I try to load package a with ghci I get an undefined symbol error for package b. But loading just package b in ghci works. Thoughts?
08:08:18 <OutlawStar> i'm using "cabal repl" to init ghci
08:09:05 <Gurkenglas_> ernst, thanks. How do I find out which of https://www.haskell.org/ghc/download_ghc_7_10_2#x86_64linux I need?
08:09:33 <coconut> any library to work with english dictionary files such as *.dict? to extract them ?
08:09:45 <dcoutts> OutlawStar: does the package b properly declare the C libs it needs?
08:09:45 <srhb> Gurkenglas_: You check which libgmp you have.
08:10:49 <ernst> Gurkenglas_: what srhb says. which linux distro are you using?
08:11:00 <OutlawStar> dcoutts: I don't think so, I wasn't aware of a setting for that
08:11:26 <dcoutts> OutlawStar: ok, you need to list the C libs in the other-libraries field in the .cabal file
08:11:33 <Gurkenglas_> This computer has openSUSE. Ok I'll look for a way to find what version I have
08:11:41 <OutlawStar> dcoutts: ok thx, I'll try that
08:12:29 <andreoss> .
08:13:01 <andreoss> can i have memoize function like memoize :: (a -> b) -> (a -> b)?
08:13:07 <ernst> Gurkenglas_: maybe even ls /usr/lib/libgmp.so.*
08:13:33 <marrrk> There's no coloured output from ghc, right?
08:13:58 <geekosaur> not currently
08:14:03 <Gurkenglas_> ernst, "ls /usr/lib/libgmp.so.*" says it didnt find that
08:14:37 <marrrk> geekosaur: Dommage.
08:14:41 <Gurkenglas_> andreoss: https://hackage.haskell.org/package/memoize-0.7/docs/Data-Function-Memoize.html
08:15:55 <andreoss> Gurkenglas: i'm trying this on a simple fibonacci function, but can't get it to work
08:16:12 <andreoss> why memoization isn't a compiler feature?
08:16:20 <geekosaur> andreoss, I don't think you can have a generally applicable memoize withthat signature
08:17:00 <geekosaur> do you want the program to remember everything it's ever computed, using ever expanding amounts of memory for something that might only be used once?
08:17:08 <andreoss> http://paste.debian.net/378167/
08:17:12 <geekosaur> automatic memoization that isn't wasteful is Hard
08:17:23 <andreoss> geekosaur: exaclty 
08:17:24 <OutlawStar> dcoutts: that worked, thx
08:17:29 <dcoutts> great
08:19:24 <fractalsea> I don’t understand how you can get a BlockedIndefinitelyOnSTM exception. The docs say “The thread is waiting to retry an STM transaction, but there are no other references to any TVars involved, so it can't ever continue.” But why can’t it just retry the transaction if there are no other references? Why does it matter that there has to be other references to it?
08:22:20 <hatds> fractalsea: TMVars I assume, where it may be waiting to read an empty TMVar or write to a full TMVar
08:22:35 <geekosaur> fractalsea, if here are no references then retrying is pointless
08:22:48 <geekosaur> if there are no other refereces then the TVar will never unblock
08:22:52 <fractalsea> hatds, the is with just TVars I’m getting this
08:23:01 <geekosaur> because it could only unblock ia some other reference, but there aren't any
08:23:09 <geekosaur> *via some
08:23:38 <fractalsea> geekosaur, but how could a thread be blocked on a TVar in the first place?
08:24:01 <geekosaur> as hadts said; it's not just TMVars
08:24:41 <hatds> well, I said I thought it had to be TMVars.  I don't know what to think if it is just TVars
08:24:45 <andreoss> so there's no way to memoize a function without altering the datastructures it uses or state monads?
08:24:55 <fractalsea> What he said only relates to TMVars
08:25:09 <fractalsea> Yeah that’s what I thought. Which is why I’m confused
08:25:44 <geekosaur> oh, sorry. the actual point here is that a retry waits for any TVar (not just TMVar) to change
08:26:18 <hatds> how can a transaction fail if there are no other references in other threads?
08:26:19 <geekosaur> if all TVar-s visible to the transaction are only accessible from the transaction itself, then they will never change and the retry can never unblock
08:26:56 <geekosaur> note that the retry is not here triggered by a TVar, but changes to TVars are relevant to retry-s unblocking
08:27:24 <Gurkenglas_> andreoss: Try "memoFix $ \fib n -> case n of 0 -> 1; 1 -> 1; _ -> fib (n-1) + fib (n-2)"
08:28:10 <andreoss> Gurkenglas_: yes, that works, i've just found this example in the source 
08:28:25 <geekosaur> guess that still leaves the question of how you'd trigger a retry in the first place.
08:28:41 <fractalsea> geekosaur, still trying to get my head around what you just said
08:29:07 <geekosaur> possibly a retry triggered by an update in another thread, which then exits leaving no other references to any TVar-s visible in the blocking thread
08:29:42 <fractalsea> geekosaur, I’m not sure because this is all happening in one thread (I’m only using TVars because I’m trying to test something that takes a callback — I want to pass in something that writes to a TVar)
08:30:22 <geekosaur> hrrr. why would you use STM with only one thread?
08:30:45 <geekosaur> there might well be lots of edge cases waiting to be discovered, since STM's only really useful with multiple threads
08:31:34 <Darwin226> Hey guys. Is this really landing in GHC8? https://ghc.haskell.org/trac/ghc/wiki/Proposal/CustomTypeErrors
08:31:40 <fractalsea> because the entity I’m testing takes a callback, and I want to capture the values that it is called with
08:32:08 <geekosaur> if there's only one thread, why not use a Chan?
08:32:12 <andreoss> Gurkenglas_: though i can't memoize any function. Which feels strange, it's pretty normal thing to want with pure functions
08:32:32 <fractalsea> geekosaur, hmm I haven’t used them before, so it didn’t occur to me
08:32:59 <int-index> Darwin226, it landed already
08:33:39 <fractalsea> geekosaur, also this could be one of those edge cases you mentioned because this is happening in quickcheck, and it only happens every 1000 times or so
08:33:53 <ernst> Gurkenglas_: sorry. dunno then:/ 
08:34:23 <Darwin226> int-index: Wow. That's pretty huge.
08:34:28 <geekosaur> I am opretty certain nobody even thought about STM behvior with only one thread, since STM is all about dealing with multiple threads
08:34:40 <int-index> Darwin226, pales in comparison to TypeInType, but yes
08:36:03 <Darwin226> int-index: That depends on what your priorities are. Custom type errors seem like a dream come true for type-heavy libraries like servant
08:36:38 <Darwin226> int-index: Though I guess they have even more reason to look forward to typeintype
08:36:44 <fractalsea> geekosaur, the API for Chan looks very simple though. I need to be able to in the callback insert the arguments the function is called with into a list at random locations (current in the TVar), and on the other side I need to be able to read from the head of the list.
08:36:46 <int-index> Darwin226, most of the time all I need from GHC errors is the line numbers.
08:37:54 <geekosaur> fractalsea, the idea behind Chan is it's a sort of "pipe". push something into it on one end, pull something out on the other. I am not clear on why you'd need more for this?
08:37:54 <Darwin226> int-index: Well up until now that was pretty much the only useful part of the message
08:38:31 <int-index> I'd put it this way: custom type errors is a tooling improvement, typeintype is a language improvement
08:39:13 <int-index> because I totally can develop with current error message reporting and I feel very limited in the type system expressiveness without TypeInType
08:39:59 <Darwin226> int-index: On the other hand. Useless error messages are much more of a show stopper for many less experienced people than the language expressiveness
08:40:26 <int-index> Agreed
08:40:42 <int-index> for general adoption custom type errors can do wonders
08:40:49 <zd234> is there any good library in haskell for handling parsing + auto completion? so imagine you're writing somethign like the command prompt of zsh; you want something that can parse AND auto complete
08:41:02 <zd234> is there any nice library for this? afaik, parsec + trifecta + attoparsec only do parsing, not auto completing
08:41:35 <marrrk> Is there a super simple tutorial on how to create a new project with stack for somebody who has no experience with cabal (like me)?
08:42:01 <int-index> marrrk, I do it this way: `cabal init`, then answer the questions it asks, then `stack init`
08:42:06 <int-index> done
08:42:28 <marrrk> okay
08:42:29 <marrrk> I will try
08:42:53 <dcoutts> marrrk: the cabal user guide has a quick start, that goes through cabal init etc
08:44:00 <fractalsea> geekosaur, Basically I have a list of “events” that I want to feed to a function one at a time. This function also generates its own events, and I want to insert these back into the original list at random locations. The function calls a callback with the events it generates. So at the moment I have this list of events as a `TVar [Events]`. And then the steps are 1. read next event, 2. call function with next event
08:44:00 <fractalsea> and pass in a callback to write any generated events into a random location in the TVar list, 3. repeat until there are no more events.
08:44:43 <geekosaur> if there is only one thread, why isn't that an IORef?
08:44:44 <fractalsea> geekosaur, I guess I could use a Chan instead, but I would have to have an extra step after 2. that reads everything out of the Chan, and inserts it into the current list of events.
08:44:58 <fractalsea> geekosaur, hmm
08:45:14 <fractalsea> geekosaur, I guess it could be, again I’ve never used them before
08:45:27 <fractalsea> Is that the most appropriate?
08:45:46 <geekosaur> TVar adds a bunch of machinery and overhead to no point whatsoever if there's only one thread. IORef looks sufficienthere
08:45:59 <geekosaur> with multiple threads you would need more than IORef
08:46:00 <fractalsea> geekosaur, ok thank you!
08:48:08 <luigy> stackage should go back to hyperlinked-source now that the proper fixes have been pushed :)
08:49:43 <int-index> luigy, that's great. I was surprised to find that Stackage doesn't hyperlink sources.
08:50:31 <luigy> int-index they did for a bit, but there were some bugs 
08:50:50 <luigy> and it comes from an unreleased haddock
08:51:10 <luigy> https://cldup.com/Gb0p0VZwNH.png
08:51:48 <luigy> also need latest cabal
08:53:26 <marrrk> How can I get the text that is "piped" into a terminal program?
08:53:34 <geekosaur> ???
08:53:59 <marrrk> Something like this: cat file.txt > myProgram
08:54:03 <Clint> that's not a pipe
08:54:19 <marrrk> True.
08:54:27 <hexagoxel> stdin?
08:54:34 <marrrk> Yeah, I guess.
08:54:36 <quchen> :t getContents -- marrrk 
08:54:37 <lambdabot> IO String
08:55:10 <geekosaur> or hGetLine if you prefer not to deal with lazy I/O
08:55:39 <fractalsea> geekosaur, just switched to IORefs and it’s working well. Thanks again! That was definitely the right choice
08:55:46 <marrrk> I will try hGetLine
08:56:34 <marrrk> How do I know that there's no text left? Is there something like EOF?
08:57:44 <cocreature> hgetline throws an eof exception
08:58:01 <barrucadu> It's in the System.IO module, which is documented here: https://hackage.haskell.org/package/base-4.8.2.0/docs/System-IO.html
08:58:26 <cocreature> so catch IOException and then check using isEOFError
08:58:50 <marrrk> Okay
09:04:27 * hackagebot frown 0.6.2 - LALR(k) parser generator  https://hackage.haskell.org/package/frown-0.6.2 (MatthewFarkasDyck)
09:16:20 <kqr> also the hIsEOF :: Handle -> IO Bool function I guess
09:17:09 <anks> im writing a parser in attoparsec. Before actually parsing some number of bytes i need to check if they pass a crc test. What would be the fastest way to do it? A 'lookAhead' parser with crc check?
09:18:27 <kqr> anks, you could just do something like
09:20:25 <kqr> anks, do { bytes <- parseBytes; if crc bytes then return bytes else fail "did not pass crc" }
09:21:12 <kqr> anks, (not sure if fail is the right way to bail out of an attoparsec parser, but assuming it is)
09:22:11 <anks> yup, but what about the actual parser for these bytes, should id be of type: Bytes -> MyStruct, or Parser MyStruct. Would using second aption and crcCheckParser as lookAhead parser be faster than first parsing n bytes, and then passing to the first one?
09:22:24 <anks> it*
09:22:53 <kqr> parseBytes should be a Parser MyStruct
09:23:19 <kqr> i don't know if lookAhead is faster. I suggest profiling if this is important
09:23:20 <anks> then i need the crcCheckParser not to consume the input
09:23:42 <kqr> why do you need that?
09:24:39 <anks> beacause { checkCrc <$> take n bytes; } would consume the input and it'd be nothing left for the actual parser. Am I wrong?
09:26:49 <anks> With lookAhead i can do it like this:   lookAhead preparser *> actualParser 
09:27:01 <kqr> anks, no that is correct, but if you do it like I suggested you don't need a preparser and an actual parser
09:27:04 <kqr> anks, you do the validation in the actual parser
09:28:52 <anks> but then id need to take N raw bytes, instead of using useful  parseInt, so i can pass bytes to the crc checking function
09:29:14 <kqr> i'm not sure I understand that bit
09:30:34 <EvanR> anks: what was the issue with using lookahead to get some bytes (without consume input)
09:30:46 <anks> well, assume i got a function: Bytes -> Bool (crc check), i need to pass to it some bytes; to get these bytes id call : {... bytes <- take N; ... }, and at this point i have consumed the input and got some raw bytes.
09:31:06 <anks> EvanR: im' just curious about the speed, and if there are any faster methods
09:31:23 <EvanR> lookAhead (take N <$> getInput)
09:31:37 <EvanR> slicing a ByteString is fast
09:31:52 <kqr> anks, http://lpaste.net/5430776285099982848
09:32:52 <EvanR> anks: here is the code http://hackage.haskell.org/package/attoparsec-0.7.1/docs/src/Data-Attoparsec-Internal.html#lookAhead
09:32:56 <anks> kqr: thx, so im left with two options ;]
09:33:06 <EvanR> it just puts the original input stream in the result
09:33:52 <kqr> anks, sure
09:33:57 <anks> It should be fast then.
09:34:04 <EvanR> youd basically do this if you could hack into the lib to do what you want
09:34:12 <kqr> anks, doing the validation in the parser gives you cleaner code compared to looking ahead first
09:34:20 <kqr> anks, and might be just as fast
09:35:23 <EvanR> kqr: in your code, you would be parsing the bytes to construct the value, but you wouldnt have attoparsec (unless youre implying you run a subparser)
09:35:55 <EvanR> so i dont know about clearner
09:35:56 <kqr> EvanR, I think that's what I'm implying. I edited with type signatures where take :: Int -> Parser a -> Parser [a]
09:36:02 <kqr> EvanR, does that make it more clear?
09:36:19 <kqr> else I'm missing something
09:36:42 <EvanR> you could make a crc parser which has no effect except to fail unless the crc check fails
09:36:46 <EvanR> which uses lookahead
09:36:57 <EvanR> and in the top level just run that, then run the regular parser, seems "cleaner"
09:37:25 <EvanR> no need to run a parser within a parser
09:37:48 <anks> yup, that'd be one option, and the second one it kqr's
09:38:08 <kqr> isn't "run a parser within a parser" basically what parser combinators are all about?
09:38:17 <anks> the first one look cleaner to be as i don't need using subparsers, or nonAttoParsec parsing function
09:38:21 <EvanR> but youd rather not have to literally runParser
09:38:26 <EvanR> for each one
09:39:11 <EvanR> in both cases you will have to "manually" cause a failure in the combinator
09:40:00 <anks> Well, finalparser = lookAhead preparser *> parser, should fail whenever preparser fails
09:40:19 <anks> imho
09:40:26 <EvanR> i was suggesting using lookahead only at the point where you need to get some bytes
09:40:52 <kqr> EvanR, http://lpaste.net/5275797707393335296
09:40:54 <anks> preparser = checkCrc <$> take N -- Bytes
09:40:59 <EvanR> and the final parser would be = crcCheck N >> parseThingy
09:41:02 <kqr> EvanR, are these two the alternatives? or am I missing something?
09:41:29 <EvanR> anks: kind of splitting hairs but i just would hide the details lower
09:42:12 <EvanR> kqr: your top case doesnt really solve the whole problem...
09:42:19 <kqr> EvanR, oh?
09:42:19 <EvanR> but i know what ... is from your previous paste
09:42:36 <EvanR> its a subinstance of runparser
09:42:43 <kqr> why would it be?
09:42:51 <EvanR> because you have raw bytes to parse
09:42:53 <kqr> the byte stuff stops just before the "..."
09:42:56 <EvanR> its not in the stream anymore
09:42:58 <kqr> ohhh
09:43:08 <kqr> I totally see what you're saying now
09:43:13 <anks> kqr: :)
09:43:16 <kqr> yeah
09:43:22 <bollu1> I'm trying to neatly implement a sort of a "finite modulo zipper" on a finite list
09:43:25 <kqr> in that case the lookahead thing is cleaner
09:43:29 <kqr> thanks EvanR
09:43:35 <bollu> so that you can have shiftLeft, shiftRight, etc
09:44:10 <bollu> I'm not able to write this neatly at all
09:44:16 <bollu> it looks like some ugly C implementation
09:44:16 <anks> Ok, anyway i'm satysfied with your answers, thanks, i think im gonna profile both of them but using lookAhead looks cleaner as im always in AttoParser Parsers
09:44:21 <bollu> is there a nice mathematical model?
09:44:26 <anks> thanks EvanR kqr 
09:44:43 <kqr> anks, if you need to parse the bytes to generate MyStruct, you should 100% use lookAhead
09:45:02 <bollu> byorgey: ping - and yes, I realized that what I was asking for was impossible (a linear map from N -> [0, 1]). I decided to just iterate for a "decent number of steps" and then created a gif for it
09:45:05 <kqr> anks, I was assuming you already had a [Bytes] -> MyStruct function
09:45:55 <anks> actually i wrote is already :), so i can go with either of options
09:46:16 <kqr> haha
09:46:38 <kqr> then I guess it depends on what kind of error reporting you need
09:46:38 <anks> :)
09:46:52 <kqr> if [Bytes] -> MyStruct is total then I'd probably prefer the first version without the lookAhead
09:47:06 <kqr> no idea if EvanR agrees though – I might be missing something else
09:48:30 <anks> it is :). Anyway gotta go, thanks for your time
09:50:53 <prati> @let data Person = Person { firstName :: String  , lastName :: String  , age :: Int  } deriving (Show) 
09:50:54 <lambdabot>  .L.hs:160:1:
09:50:55 <lambdabot>      Multiple declarations of ‘Person’
09:50:55 <lambdabot>      Declared at: .L.hs:154:1
09:51:00 <prati> @undefine
09:51:00 <lambdabot> Undefined.
09:51:02 <prati> @let data Person = Person { firstName :: String  , lastName :: String  , age :: Int  } deriving (Show) 
09:51:04 <lambdabot>  Defined.
09:51:15 <prati> @let data Person2 = Person2 String String Int
09:51:16 <lambdabot>  Defined.
09:51:21 <prati> :t Person
09:51:22 <lambdabot> String -> String -> Int -> Person
09:51:25 <prati> :t Person2
09:51:26 <lambdabot> String -> String -> Int -> Person2
09:52:00 <prati> So, Both looks good, except for the convenience, and accessor methods like  
09:52:03 <prati> :t firstName
09:52:04 <lambdabot> Person -> String
09:52:19 <prati> But, I am confused with 
09:52:42 <prati> @let { type Input = String ; type Output = String } 
09:52:43 <lambdabot>  Defined.
09:52:54 <prati> @let data FuncType a = FuncType ( Input -> (a, Output))
09:52:55 <lambdabot>  Defined.
09:53:27 <prati> In the above the type is accepting functions !! and it is different from earlier record syntax !!
09:53:58 <monochrom> is that a surprise? you aren't even using record syntax.
09:54:33 <prati> Yes, I was only thinking that type is meant for data, 
09:54:49 <geekosaur> functions are perfectly valid data?
09:54:50 <prati> now I don't understand the usage of the Functions inside the FuncType
09:55:25 <prati> What are some use cases of Types containing functions !!
09:55:37 <prati> ** Data constructors with functions !!
09:55:38 <phadej> well, almost everything_
09:55:59 <phadej> newtype State s a = State { runState :: s -> (a, s) }
09:56:16 <kqr> prati, do you know any object oriented programming? not saying it's the same thing but objects in java also contain methods...
09:56:47 <prati> kqr Yes, I know Java, But how can we related this  !!
09:57:16 <monochrom> I wouldn't say "functions are also data". but since "data XXX = MkX <write a type expression here>" is legal, and since "Input -> (a, Ouptut)" is a type expression, why are we suprised that it can't be done. 
09:57:31 <kqr> prati, why is it okay for java objects to have methods but not haskell objects to have functions?
09:58:19 <kqr> prati, haskell objects can contain any value, and functions are values in haskell
09:58:23 <prati> kqr  Java object can have methods, so that they have behaviour, or mutate the data !!
09:58:42 <prati> **and mutate the data, 
09:59:19 <kqr> not all methods mutate data
09:59:28 <prati> monochrom kqr , I kind of relate Types with most C structs, where there is just data !!
09:59:38 <prati> and parametric types !!
09:59:40 <kqr> C structs can have functions too, through pointers though
09:59:40 <monochrom> ok, C structs you want?
09:59:55 <kqr> but essentially the same thing, except in C a function isn't a value, a function pointer is
10:00:15 <prati> I just want to do understand some use cases with "types with functions"
10:00:27 <monochrom> struct XXX { char* (*method)(char *); };  is a C struct and its field is a function.
10:01:07 <prati> but only use case, is we can use that to pass functions and data together !!
10:01:18 <prati> but in haskell, we already have higher order functions !!
10:01:26 <monochrom> IMO you're narrow-minded
10:01:56 <prati> Hmm, If I am narrow minded I wouldn't have tried that example , 
10:02:01 <monochrom> what is your goal? to argue for banning this?
10:02:14 <kqr> prati, i'll show you a simple example
10:02:21 <ironChicken> in Distribution.TestSuite, the constructor `Progress String (IO Progress)` makes it look like i might be able to chain some Progress values together. is that the idea?
10:02:33 <ironChicken> and if so, does anyone know of an example?
10:02:36 <prati> kqr monochrom Thanks, I am just looking for some example !!
10:03:25 <ironChicken> for context, i'm trying to make my tests more modular so i can re-use code in similar tests
10:04:08 <monochrom> Cont is an example. StateT is another example. ReaderT is another example.
10:05:07 <monochrom> the problem is that you didn't expression "I want to see examples" until near the end. all over 10 minutes you're only expression surprise and disgust, as though you wanted it banned.
10:05:13 <prati> monochrom I will check those examples
10:05:24 <prati> kqr monochrom FYI, I looked for these examples in "Haskell Programming, from first principle" and "learnyouahaskell" , both of them didn't explain any example !!
10:06:06 <prati> And neither of them didn't even mention that it is possible !!
10:06:16 <prati> so, when I encountered that, it is a surprise for me !!
10:08:19 <m1dnight_> Is there a functorlike class for kind *?
10:08:39 <m1dnight_> So I can easily map a function over a nested datastructure
10:09:01 <glguy> prati: When you write "!!", what does it mean to you?
10:09:03 <prati> monochrom Cont is complex for me at this time !! as it requires continuations 
10:09:23 <prati> glguy exclamation 
10:09:37 <ARM9> how does a nested data structure have kind *?
10:10:17 <kqr> prati, http://lpaste.net/5424932513942339584
10:10:23 <kqr> prati, first the python object with methods
10:10:30 <kqr> prati, then a haskell object also with methods!!
10:10:44 <kqr> prati, (then followed by the implementation to convince you those are actually methods of the haskell object)
10:11:36 <prati> kqr I am checking it
10:12:16 <kqr> ARM9, by not taking any type arguments?
10:13:50 <glguy> m1dnight_: Maybe the class "Plated" is like what you're asking about. http://hackage.haskell.org/package/lens-4.13.1/docs/Control-Lens-Plated.html
10:13:58 <glguy> "A Plated type is one where we know how to extract its immediate self-similar children."
10:14:00 <ARM9> kqr don't ask me
10:14:32 <m1dnight_> glguy: exactly that! Thnx !!
10:17:35 <prati> kqr Awesome, Thanks !
10:19:07 <prati> glguy Thanks for correction !!
10:19:25 <prati> glguy I was just typing without thinking 
10:23:33 <echo-area> DatatypeContexts is deprecated.  Is it saying that contexts for data definition is not recommended to use?
10:23:50 <phadej> yes
10:24:33 <echo-area> Why is it considered a misfeature?
10:26:23 <geekosaur> people expect a datatype context to bring the context into scope when pattern matching. this is not possile
10:26:27 <geekosaur> *possible
10:27:50 <geekosaur> GADTs can bring a context into scope. but they introduce an existential to do it
10:27:58 <kqr> echo-area, sec
10:28:19 <kqr> echo-area, http://stackoverflow.com/a/19650352/1463507
10:38:49 <voltz> Hey, What does the tilde mean when pattern matching?
10:39:59 <oisdk_> voltz it means an irrefutable pattern http://dev.stephendiehl.com/hask/#irrefutable-patterns
10:40:05 <oisdk_> It's more lazy
10:40:09 <kqr> voltz, "lazy pattern". it extracts the components without actually causing evaluation
10:40:21 <voltz> Thanks
10:40:33 <kqr> voltz, (obviously once you use the components you need to evaluate the outer structure, but a lazy pattern doesn't do it on matching time)
10:41:20 <voltz> Makes sense
10:41:42 <andromeda-galaxy> I have a 'class C1 a b c | a b -> c where' and want to have something like 'class (C1 a a) => C2 a where', i.e. there exists some instance such that C1 a a is the case, and there can only be one instance due to functional dependencies... however GHC complains about out-of-scope type variables (presumably because the implicit wuniversal quantification only occurs over variables mentioned in the instance head).  Doe
10:41:43 <andromeda-galaxy> get around that?
10:42:06 <scshunt> you got cut off
10:42:39 <echo-area> geekosaur, kqr: I see.  Thanks
10:43:07 <andromeda-galaxy> scshunt: erc has automatic message splitting!  to me at least it looks like the rest of my question got another message...
10:43:16 <andromeda-galaxy> it was "get around that?"
10:43:40 <geekosaur> it split, but too late
10:43:59 <andromeda-galaxy> geekosaur: oh sorry, neve rmind. where did you see me cut off?
10:44:00 <geekosaur> first message ended with "head).  Doe"
10:44:11 <geekosaur> we can probably guess the rest, but safer to confirm
10:44:19 <andromeda-galaxy> Ah okay, it just said: 'Does anyone know how to get around that?'
10:44:36 <andromeda-galaxy> geekosaur, scshunt: thanks for letting me know, sorry I missed that
10:45:46 <dicej> Is it possible to rewrite the following without giving the value in x a name? do { x <- someMonad; case x of 1 -> return "yo"; 2 -> return "ya" }
10:46:01 <voltz> Is there a total prelude alternative?
10:46:28 <geekosaur> dicej, LambdaCase extension
10:46:30 <andromeda-galaxy> dicej: LambdaCase? someMonad >>, \case of 1 -> return "yo"; 2 -> return "ya"
10:46:42 <andromeda-galaxy> someMonad >>= (..), I mean
10:46:46 <dicej> ah, thanks!
10:46:47 <geekosaur> also no "of"
10:47:05 <andromeda-galaxy> oops, that's right.
10:47:08 <geekosaur> but you need {-# LANGUAGE LambdaCase #-} at the top
10:47:15 <dicej> got it
10:48:07 <andromeda-galaxy> geekoosaur: so, any ideas about the functional dependencies superclass constraint problem?
10:48:54 <geekosaur> no, sorry
10:49:31 <andromeda-galaxy> oh well, no problem.  I'll keep looking into it.. It's kind of annoying how that kind of thing is perfectly legal in *instance* declarations but not in *class* declarations
10:50:45 <ReinH> andromeda-galaxy: well, I notice C1 a b c but then C1 a a
10:50:50 <glguy> andromeda-galaxy: You could give up and replace the a b -> c dependency with a type family
10:51:16 <andromeda-galaxy> glguy: I can't, because it's relying on OverlappingInstances, and associated families can't overlap
10:51:55 <andromeda-galaxy> ReinH: right, the idea is that since 'c' is determined by 'a' and 'b' (fundeps) that I should be able to have a class constraint on a different class that doesn't care what 'c' actually turns out to be
10:52:43 <ReinH> But there still must *be* a c
10:53:29 <andromeda-galaxy> ReinH: right, but is there any way to express the existential constraint that there is a c, but I don't really care what it is?  It would work with associated type families, but as I mentioned, I can't use those for other reasons
10:54:22 <ReinH> C1 a a c => C2 a a ?
10:54:43 <glguy> Not in scope: type variable ‘c’
10:55:09 <andromeda-galaxy> ReinH: "Not in scope: type variable ‘c’"
10:55:09 <ReinH> glguy: eh?
10:55:27 <andromeda-galaxy> ReinH: that's the first thing that I tried, it doesn't work; it fails with that error
10:55:52 <andromeda-galaxy> ReinH: as far as I can tell, it's because the implicit universal quantification only applies to variables mentioned in the class head
10:56:41 <ReinH> Right.
11:00:13 <andromeda-galaxy> ReinH: so if that doesn't work for those reasons, do you knwow of anything that does?
11:18:07 <evenex> What's the most convenient way to check the type of an expression that's deep within some code (iow it would take a lot of typing to reconstruct the expression in prelude so I could use :type)?
11:19:11 <kadoban> evenex: Typed holes.  give it a type annotation of (:: _) and compile it, GHC will tell you what type it expects there.
11:19:50 <kadoban> evenex: You can also do it on the value level, like   map _ xs  and it'll do something similar.
11:21:22 <evenex> kadoban: Thank you! The resulting compiler message is very informative.
11:21:32 <kadoban> 'welcome. Yeah it's a pretty useful feature
11:21:50 <Jinxit> wow, that's useful
11:33:54 <roelof> anyone using windows for Haskell development. if so, how can I best install it and what IDE except vim and emacs can I use that can work with stack ? 
11:35:05 <dmj> roelof: I used emacs with cygwin back in the day. Sublime would work, but you want get that nice haskell-mode repl goodness
11:35:12 <dmj> s/want/won't
11:35:50 <roelof> dmj now on linux or OSX ? 
11:35:54 <Phyx-> roelof: depend on how comfortable you are with things. you could try https://github.com/fpco/minghc
11:36:06 <Phyx-> I personally just get the GHC binaries from haskell.org
11:36:15 <Phyx-> and install everything else I need manually
11:36:51 <Phyx-> MinGHC is good for getting packages using autotools to build, like network. But i see they have no 7.10.3 version
11:37:07 <roelof> dmj Can sublime work with Stack then. I could only find plugins for cabal 
11:37:33 <Phyx-> I wouldn't use Cygwin, as that's not really supported anymore
11:39:33 <dmj> roelof: osx
11:40:00 <dmj> roelof: I'd learn emacs or vim
11:40:51 <dmj> roelof: there is this "Atom" editor that looks like something close to visual studio for haskell though
11:41:06 <Jinxit> haha what
11:41:10 <dmj> https://atom.io/packages/ide-haskell
11:41:53 <dmj> visual haskell was abandoned in 2005, we're all waiting for a master's student to continue carrying the torch
11:41:55 <dmj> http://community.haskell.org/~simonmar/papers/vshaskell.pdf
11:43:57 <ReinH> roelof: leksah runs on windows
11:44:32 <ReinH> Personally I would use a VM if I had to develop haskell on windows.
11:44:37 <Phyx-> http://i.imgur.com/1eNUnLc.png https://mistuke.files.wordpress.com/2010/07/screenshot1.png
11:44:46 <Phyx-> just mostly missing hours in the day to work on it
11:46:00 <dmj> roelof: let's take a step back, why do you have to use windows
11:47:12 <roelof> dmj:  because Windows was already installed on the computer when I bought it 
11:47:27 <EvanR> classic
11:48:22 <NeverDie> Rofl.
11:48:29 <Phyx-> classic that this channel *still* actively tries to discourage people from using Windows
11:48:36 * Phyx- *shrugs*
11:48:43 <ReinH> Phyx-: have you tried to use Haskell on windows?
11:48:47 <NeverDie> Phyx-: Is that bad?
11:48:57 <EvanR> at least this channel admits that haskell sucks on windows
11:49:15 <NeverDie> Because Windows is a disease. 
11:49:36 <EvanR> its really no excuse for not having awesome support for windows
11:49:43 <Phyx-> EvanR: that's due to lack of maintainers
11:49:46 <ARM7> or you could just try to support the biggest operating system on the market instead of coming up with trite excuses
11:49:48 <Phyx-> not due to windows
11:49:54 <ReinH> Windows is fine, its just difficult to support as a platform for software development.
11:50:06 <ARM7> it's not his fault ghc and the rest of the ecosystem has terrible windows support
11:50:18 <Phyx-> that's not even remotely true ReinH 
11:50:29 <NeverDie> Phyx-: How so?
11:50:31 <ReinH> Phyx-: It's good for Microsoft-supported tools, bad for others.
11:50:47 <Phyx-> ReinH: maybe 10 years ago
11:50:53 <ReinH> Maybe. And also today.
11:51:04 <EvanR> yeah it needs microsoft research-supported tool support ;)
11:51:06 <ReinH> Phyx-: have you used Haskell on windows?
11:51:35 <Phyx-> ReinH: I actively maintain GHC on Windows
11:51:40 <ghorn> is there a gtk2hs irc channel?
11:52:02 <ReinH> Phyx-: Ok. Have you used it to build things?
11:52:04 <Phyx-> and have been working quite hard to fix all Linking and rts related problems with GHC
11:52:11 <dobq> in STM, where is TStack? am i supposed to use TVar [a] ?
11:52:19 <Phyx-> ReinH: yes
11:52:39 <ReinH> And how's that going for you?
11:53:24 <ReinH> How much time do you spend massaging include paths so that headers can be found in whatever non-standard location they are put, etc?
11:53:53 <ReinH> People who tell you that windows is a disease are wrong. People who tell you that it is all roses and bubblegum are also wrong.
11:54:11 <Phyx-> ReinH: Every platform has it's up and downsides
11:54:25 <ReinH> That's a true but meaningless statement.
11:54:30 <mmachenry> ReinH: For me the worst thing about developing on Windows is the lack of package management. 
11:54:33 <ReinH> Some have more downsides than upsides, compared to others.
11:54:40 <Phyx-> and so is this discussion
11:54:42 <Phyx-> gn
11:54:46 <ReinH> lol
11:54:49 <ReinH> classic
11:55:09 <Phyx-> you clearly have your axe to grind
11:55:14 <ReinH> As do you.
11:55:19 <mmachenry> When I have worked on just about any language on Windows, I find it works just like Linux or Mac until I need to use something like the audio or graphics library.
11:55:28 <Ankhers> mmachenry: I haven't used it, but I believe windows has something similar to hombrew from OS X called choclatey.
11:55:40 <EvanR> dobq: list is indeed an awesome stack data structure
11:55:46 <mmachenry> Then I need to figure out how to install that on Windows and all its package's dependencies. Does Windows have a solution for this that I don't know about?
11:56:14 <mmachenry> Ankhers: It's been years since I've used Windows but it's good to know there's finally something. 
11:56:27 <ReinH> All I said was that I would prefer to use a VM to develop Haskell on Windows.
11:56:32 <Ankhers> Apparently their site is down for emergency maintenance though.
11:57:09 <Phyx-> mmachenry: chocolatey does a good job. msys2 also has pacman. Which would give you native/non-emulated packages for a lot of things out there
11:57:59 <ReinH> dobq: A queue has the property that pushes and pops do not contend. A stack does not have that property. The end result is that you can't do better than, e.g., TVar [a], because you have to deal with contention on the head of the stack somehow.
11:58:02 <dmj> windows is cool for games
11:58:10 <mmachenry> Phyx-: Interesting. 
11:58:39 <dobq> ReinH: okay, so the reason that there is no TStack is that TVar [a] is pretty much ideal?
11:58:43 <Phyx-> mmachenry: it's how we build GHC now on Windows. Works quite well
11:58:51 <ReinH> dobq: That's my assumption, at least.
11:59:20 <EvanR> dobq: seems like thats how it would be implemented, and is rather trivial
12:00:03 <EvanR> whats nice about an STM stack is that you dont have to crash/burn when you pop an empty stack
12:00:27 <EvanR> it can block until something is pushed
12:00:54 <dobq> i'd rather crash and burn in this case actually :P
12:01:08 <dobq> it's more of a resource pool in my case, and i have a fallback if theer are no resources
12:01:11 <ReinH> The only think TStack might provide is a nicer interface, but you can write one yourself for TVar [a] in 10 lines of code or so.
12:01:17 <dobq> yes got it
12:01:22 <dobq> already on it :)
12:01:27 <ReinH> dobq: To be clear, you may want to deal with the exception, but you probably don't want to crash at runtime.
12:01:43 <ReinH> You presumably want to handle it without crashing.
12:01:44 <dobq> i was actually planning to fire the missiles
12:03:01 <EvanR> launchMissiles :: IO ()
12:03:05 <EvanR> classic ;)
12:04:33 * hackagebot binary 0.8.1.0 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.8.1.0 (LennartKolmodin)
12:07:15 <dicej> Can the following be rewritten such that x is not named (note that it returns Just 43 when applied to Just 42, and returns Nothing when applied to Nothing)?  evalState (runMaybeT (do Just x <- get; return (x + 1)))
12:08:02 <ReinH> dicej: fmap (+1) get
12:08:33 <ReinH> or rather, fmap (fmap (+1)) get
12:08:35 <mmachenry> dobq: You could put this at the top of the program: fromJust = maybe (unsafePerformIO fireTheMissiles) id
12:08:36 <exio4> fmap (fmap (+1)) 
12:08:42 <exio4> a single fmap wouldn't be enough 
12:08:59 <ReinH> exio4: yeah that's what I said ;)
12:09:16 <exio4> anyway, "runMaybeT $ do { Just x <- get; .." sounds wrong
12:09:20 <dobq> mmachenry: obligatory https://xkcd.com/534/
12:09:43 <exio4> wait, nvm, :) 
12:10:28 <ReinH> Is there a language where that function doesn't set and then throw a bunch of local variables?
12:10:34 <ReinH> *throw away
12:11:03 <EvanR> ruby
12:11:09 <dicej> thanks, ReinH, but that seems to give me Just (Just 43) when I give it Just 42
12:11:30 <dicej> (and Just Nothing when I give it Nothing)
12:12:11 <ReinH> dicej: Well, you're doing something weird with MaybeT there, so I dunno.
12:12:36 <dmj> what's the largest tuple representable? Anyone know off-hand? Trying to figure out the max # of fields opaleye can support
12:12:51 <ReinH> I think you can get away with just not using MaybeT at all
12:12:56 <Cale> ReinH: clearly they're globals being assigned to, haha
12:13:09 <ReinH> Cale: ah, right.
12:13:12 <ClaudiusMaximus> dmj: around 62 i think
12:13:22 <ReinH> Cale: Man it's weird when you forget that languages have global variables.
12:13:29 <ReinH> I guess I've been doing too much haskell
12:14:21 <dmj> ClaudiusMaximus: thanks, wonder why product-profunctors doesn't support that limit (p62)
12:14:49 <dicej> ReinH: my goal is to combine some Maybe values inside a State computation such that the result is Nothing if any of the Maybes are Nothing
12:15:05 <mlandry> < Very new to haskell, wants to know how to write a function that has multiple steps, ie take a number, turn it into an array, then read the array, and return true or false dependending on the numbers inside
12:15:49 <dobq> mlandry: tip: write individual functions to do all the intermediary steps
12:15:57 <mlandry> thats done
12:15:58 <dolio> dmj: Because no one uses tuples anywhere near that big.
12:16:03 <dobq> mlandry: okay, and then compose them
12:16:18 <mlandry> Do i just chain all the functions together in a big nest?
12:16:23 <Gurkenglas> (evaluateIntList :: [Int] -> Bool) . (numberToArray :: Int -> [Int])
12:16:46 <dolio> And no one should.
12:17:01 <ReinH> dicej: But then you pattern match on Just, which is causing the problem.
12:17:16 <dmj> dolio: sure, some sql tables might have more than 24 fields, and opaleye seems to require a type be a tuple to perform an insertion, just want to support that in case
12:17:29 <ReinH> You don't need to pattern match on Just inside a MaybeT computation. The definition of (>>=) for MaybeT already handles failing on Nothings
12:17:50 <ReinH> If you have a computation that actually gives a Maybe, yuu should wrap it in the MaybeT constructor instead.
12:18:14 <EvanR> been a while since someone asked for the globals package ;)
12:18:34 <ReinH> mlandry: You generally use the (.) operator to chain them together into a single function.
12:20:10 <EvanR> relying on tuples to do database access :(
12:20:35 <EvanR> rows in a table are *really* records
12:20:55 <EvanR> which have no tuple size problem
12:24:22 <ReinH> mlandry: recommend the first few chapters of Thinking Functionally with Haskell to help you wrap your head around writing programs compositionally.
12:24:30 <ReinH> And the rest of them as well.
12:24:59 <erisco> is there a Prelude definition for mapping [x1, x2, ..., xn] to x1 >> x2 >> ... >> xn ?
12:25:13 <dcoutts> :t sequence
12:25:14 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:25:16 <dcoutts> :t sequence_
12:25:18 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
12:25:36 <erisco> hm, I suppose so
12:25:48 <dedgrant> Phyx-: Just want to say thanks for the RTS linker work on Windows. I develop with GHC almost solely on Windows.
12:25:58 <erisco> I don't think I can ask this question in the way I want
12:29:13 <evenex> whats the difference between "somethingInAMonad >>= print" and "something >>= (return . print)"? 
12:29:27 <evenex> Specifically, why's the former print and the latter have no effect?
12:29:46 <ReinH> :t return . print
12:29:47 <lambdabot> (Monad m, Show a) => a -> m (IO ())
12:30:05 <evenex> :t print
12:30:06 <lambdabot> Show a => a -> IO ()
12:30:08 <ReinH> evenex: return wraps your print action in another context
12:30:36 <evenex> ReinH: If I didn't use return, the print action would be unwrapped?
12:30:47 <ReinH> Yes.
12:30:58 <evenex> ReinH: I thought (I'm a noob btw) that once something was inside a monad context, it doesn't come back out?
12:31:20 <evenex> ReinH: and the only way to continue interacting with it was to pass things into the monad in an applicative style?
12:31:24 <ReinH> Did I say something to make you think otherwise?
12:31:40 <ReinH> :t (>>=)
12:31:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:31:44 <evenex> Confirming that the print action would be unwrapped.
12:31:51 <ReinH> The right hand side of a bind has to be a function that returns an m-action
12:31:54 <ReinH> :t print
12:31:56 <lambdabot> Show a => a -> IO ()
12:31:57 <ReinH> print is already such a function
12:32:02 <ReinH> it does not need to be wrapped again
12:32:19 <ReinH> *its result* does not need to be wrapped again.
12:32:39 <EvanR> evenex: when you wrap something with return, you get an action that cant have any effect
12:32:55 <ReinH> You need a function a -> m b, and print :: a -> IO () is already such a functino for m ~ IO, b ~ ().
12:33:00 <ReinH> *function
12:33:03 <evenex> Okay, so the result of print already meets the type constraint for >>=
12:33:14 <EvanR> your print function is now suspended as a value in an no-op IO action
12:33:16 <ReinH> evenex: print itself meets the requirements.
12:33:29 <EvanR> if oyu use that action, youll get your print function back, then you can use it
12:33:40 <evenex> I see, so I've double-nested print in my example.
12:33:41 <EvanR> but no other effects will occur
12:33:51 <dmj> :t \m -> m >>= do return >=> print
12:33:52 <lambdabot> Show a => IO a -> IO ()
12:34:00 <ReinH> EvanR: Another way to look at it is that ma >>= *return . f) = fmap f ma
12:34:15 <ReinH> and join (fmap f ma) = ma >>= f
12:34:26 <EvanR> cool
12:34:28 <ReinH> So what you are doing when you stick the return in is creating a nested context that must be joined
12:34:34 <ReinH> which is unnecessary
12:34:40 <ReinH> er
12:34:43 <ReinH> sorry, that was for evenex
12:34:48 <EvanR> lol
12:35:01 <ReinH> er, (return . f)
12:35:23 <ReinH> evenex: the alternative is just to not nest them in the first place.
12:35:36 <ReinH> :t fmap print
12:35:38 <lambdabot> (Functor f, Show a) => f a -> f (IO ())
12:35:47 <ReinH> :t (>>= print)
12:35:48 <lambdabot> Show a => IO a -> IO ()
12:35:55 <ReinH> is the difference
12:36:46 <ReinH> You are probably specifically dealing with f ~ IO, so fmap print :: Show a => IO a -> IO (IO ()) is the nesting.
12:37:04 <EvanR> IO (IO ()) is interesting ;)
12:37:10 <evenex> ReinH: right, I Was trying to fmap print over the monad initially, and wasn't sure why it wasn't doing anything. But now I think I understand - its sort of like fmap \x -> [x] [a] = [[a]]?
12:37:20 <ReinH> It is interesting, it's just not interesting right now. ;)
12:37:35 <EvanR> can i haz fix IO
12:37:38 <ReinH> evenex: you started with fmap and you finished with a different spelling of fmap ;)
12:37:52 <dobq> EvanR: fixIO :: (a -> IO a) -> IO a
12:37:59 <ReinH> evenex: yes, exactly.
12:38:03 <EvanR> not fixIO ;)
12:38:16 <ReinH> evenex: if you think of [a] as a choice of a's, then [[a]] is a choice of choices of a's.
12:38:22 <ReinH> You can't make a choice directly because they are nested.
12:38:42 <evenex> ReinH: you've lost me. What do you mean by choice?
12:38:56 <ReinH> evenex: [1,2,3] represents my ability to choose a number between 1 and 3, inclusive.
12:38:58 <ReinH> e.g.,
12:39:27 <ReinH> [1..6] are the choices for a 6-sided dice
12:39:34 * hackagebot tagged-exception-core 2.2.0.0 - Reflect exceptions using phantom types.  https://hackage.haskell.org/package/tagged-exception-core-2.2.0.0 (PeterTrsko)
12:40:00 <ReinH> > fmap (\_ -> [1..6]) [1..6]
12:40:01 <lambdabot>  [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,...
12:40:14 <ReinH> er
12:40:31 <ReinH> These are the choices for each of 6 6-sided dice
12:40:35 <ReinH> each one can be 1..6
12:40:45 <ReinH> If I want to get all the actual dice rolls, I need to do something different:
12:40:56 <ReinH> > do d1 <- [1..6]; d2 <- [1..6]; return (d1,d2)
12:40:57 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
12:41:30 <ReinH> So if [a] represents a choice of a then [[a]] represents a choice of choices of a
12:41:58 <dicej> Restating my earlier question: if I have two values of type (State a (Maybe b)), how can I must succinctly apply function f with type (b -> b -> c) to them?
12:42:01 <evenex> what does the "do d1 <-...." expr represent in this analogy?
12:42:09 <ReinH> A better example would be: let's roll a 6-sided dice 3 times and tabulate the results.
12:42:10 <dicej> s/must/most
12:42:20 <ReinH> > fmap (\_ -> [1..6]) [1,2,3]
12:42:21 <lambdabot>  [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]]
12:42:38 <ReinH> > [1,2,3] >>= \_ -> [1..6]
12:42:40 <lambdabot>  [1,2,3,4,5,6,1,2,3,4,5,6,1,2,3,4,5,6]
12:42:45 <evenex> so the outer nesting is "choose which trial" and the inner is "choose which result"
12:42:50 <ReinH> evenex: yes
12:43:02 <ReinH> if I want to combine trials, I need to join after I fmap or use (>>=) to do both at once
12:43:23 <ReinH> and (>>=) for [] is exactly concat . map
12:43:31 <ReinH> (actually flip concatMap)
12:44:00 <ReinH> evenex: so return (print "foo") is an IO action that, when executed, gives another IO action.
12:44:18 <ReinH> But the runtime system executes IO a actions, it does not execute the "inner" action of an IO (IO a)
12:44:58 <ReinH> So the "do-nothing" context created by return is executed, which does nothing, and then the IO action return is *not* executed, and is probably thrown away.
12:45:24 <ReinH> *the IO action returned*
12:45:29 <evenex> I see, so by double-wrapping print, I have an action which declares a print action. By evaluating the outer action, I get an unexecuted print action.
12:45:46 <ReinH> evenex: exactly
12:45:47 <lambda-11235> dicej: > state >>= (\m -> m >>= (\b -> f b b)) -- Like that?
12:46:03 <ReinH> Similar to declaring a number of trials in the [] Monad and then not actually tabulating the results.
12:46:49 <ReinH> In both cases, join after fmap would do what you want, but join after fmap is just a more verbose spelling of (>>=)
12:47:20 <ReinH> (This is one of the monad laws)
12:48:03 <ReinH> It actually goes -> join (ma >>= return . f) = join (fmap f ma) = ma >>= f
12:48:12 <ReinH> employing various monad laws at each step
12:48:27 <evenex> Is it accurate to say that constructing the monad is like building an expression path, and join is like taking that path through one step of reduction?
12:48:48 <ReinH> evenex: accurate? No. A useful lie? Perhaps.
12:49:13 <evenex> Fair enough. It must be more abstract than that, then.
12:49:58 <ReinH> You are hitting on something interesting and true about monads and trees, but I don't want to claim that a metaphor is what really exists.
12:50:28 <ReinH> If you look at free monads, you'll see what I mean about monads and trees.
12:51:03 <dicej> lambda-11235: actually, let's make it more general: I have state1 :: (State a (Maybe b) and state2 :: (State a (Maybe c) I want to apply f :: (b -> c -> d) to them such that the result has type (Maybe d)
12:51:19 <dicej> sorry, mismatched parens
12:51:33 <dicej> lambda-11235: actually, let's make it more general: I have state1 :: (State a (Maybe b)) and state2 :: (State a (Maybe c)) I want to apply f :: (b -> c -> d) to them such that the result has type (Maybe d)
12:51:53 <ReinH> evenex: there are a bunch of more or less useful metaphors people use around monads, each of which is an interpretation of the elephant from a particular blind person's perspective.
12:52:05 <ReinH> "Computation tree" is one such, and is probably more useful than most.
12:53:02 <ReinH> evenex: I just don't want you to mistake an analogy for something it isn't.
12:53:26 <lambda-11235> dicej: > do { m1 <- state1; m2 <- state2; return $ f <$> m1 <*> m2 }
12:53:47 <ReinH> Up until recently, I would have claimed that "monads are like burritos" was one of the less useful ones, but it turns out to actually be not that bad...
12:54:05 <ReinH> Of course, in order to understand the analogy, you have to know what a monad is. ;)
12:54:10 <evenex> Thank you! And yeah the monad metaphors have really been done to death; I'm still new to this language and I'm already feeling inundated with burritos and boxes and whatever else...
12:54:31 <dicej> lamda-11235: thanks, that's what I came up with too, but I wondered if it was possible to do it without naming m1 and m2
12:54:44 <veyn> I'm playing around a bit, making something like the partition function, but making a list of lists where each sublist is a group of consecutive elements that either do or don't satisfy a predicate. I'm having a bit of trouble
12:54:55 <ReinH> evenex: If you want to get at the heart of the matter, try to wrap your head around free monads. They are the monads that have no other structure but that which is imposed by the monad laws.
12:55:10 <ReinH> So they are sort of what is essential about a monad.
12:55:44 <evenex> ReinH: Sounds good, I'm looking at the hackage page now.
12:56:24 <ReinH> evenex: The "computation tree" metaphor is basically this: 'a -> m b' is a function that takes an 'a' into m-shaped leaves of type b, and constructing an a -> m b by building up a bunch of these implicitly builds an m-shaped tree of computation.
12:56:39 <ReinH> evenex: This analogy is useful when m has a "shape", and less useful otherwise.
12:56:46 <EvanR> the monad story (as far as i can understand it so far) goes like this. you start at the prime meridian looking at the types for return and >>=, then you progress east and encounter burritos and ridiculous tutorials
12:57:05 <EvanR> at some point it gets so ridiculous you start to go back west, eventually coming back to the class definition
12:57:06 <evenex> lol, is the burrito metaphor because you can put whatever you want into the burrito but you have to eat it as a whole burrito, without picking anything out or something?
12:57:19 <ReinH> evenex: Here are some useful free monad resources http://blog.sigfpe.com/2014/04/the-monad-called-free.html  http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
12:57:37 <StoneToad> lol EvanR 
12:57:43 <EvanR> going further west you get monad instances for useful types, see they have wildly different behaviors
12:57:52 <EvanR> then you make your own monads
12:57:56 <EvanR> then you get buried in transformers
12:57:58 <ReinH> evenex: A tortilla is a monad in the category Füd https://www.cs.cmu.edu/~edmo/silliness/burrito_monads.pdf
12:58:09 <EvanR> at some point someone tells you thats all there is to it, and you can stop
12:58:20 <dicej> lambda-11235: I think I've got it: (liftM2 $ liftM2 f) state1 state2
12:58:29 <evenex> haha wow
12:58:30 <EvanR> but you can go even further west and see the category theory, functors, monoids, etc
12:58:36 <ReinH> EvanR: You are in a maze of twisty little monad tutorials, all alike.
12:59:16 <kadoban> veyn: Are you having a specific problem with your attempted solution, or looking for advice how to do it, or?
12:59:33 <ReinH> EvanR: it's an april fools joke, but it' actually pretty reaonable on it face.
12:59:34 * hackagebot binary 0.8.2.0 - Binary serialisation for Haskell values using lazy ByteStrings  https://hackage.haskell.org/package/binary-0.8.2.0 (LennartKolmodin)
12:59:39 <ReinH> er
12:59:41 <ReinH> evenex: ^ sorry
12:59:54 <ReinH> Ok, one more time and I will require one of you to change your handle...
13:00:17 <EvanR> that will be a pain in the ass for me
13:00:28 <veyn> kadoban: A bit of both I guess, I'm playing around so it's nothing really important.
13:01:08 <evenex> ReinH: this is a bad paper to read before you've had breakfast... now I have an urge to find a hipotle
13:01:11 <evenex> chipotle*
13:01:28 <ReinH> evenex: As a solipsist, I have no problem with that.
13:01:33 <ReinH> OMG
13:01:36 <ReinH> That's it.
13:01:40 <EvanR> comonads are like night clubs
13:01:56 <ReinH> It is far too difficult for me to type *three* letters before pressing tab, so one of you will have to go.
13:02:28 * dmj is waiting for EvanR's punchline
13:02:42 <EvanR> that was a real tutorial
13:02:46 <ReinH> hahaha
13:02:56 <bitemyapp> hi pottle.
13:02:58 <kadoban> veyn: I mean I could share my version, but I somehow doubt that'll teach you much. Want to share yours and we could try to figure out where to go from where you're at, or what's wrong with your approach?
13:03:14 <ewenex> <-- now it is the polish version
13:03:50 <ReinH> ewenex: no it's really ok you didn't have to change your handle
13:04:09 <ReinH> It's my problem, not yours
13:04:11 <ewenex> ReinH: haha, just having a bit of fun
13:04:42 <veyn> Well, I just have an idea right now, but I imagine it's very inefficient as it's doing a few inits and lasts, rebuilding the list of lists, then flattening
13:04:57 <ReinH> veyn: To start with, let's ask the question we always ask when working recursively with lists.
13:05:13 <ReinH> What do we do with the empty list, what do we do with x cons xs?
13:06:05 <veyn> the empty list doesn't have any elements to satisfy the predicate, so it's returned as is.
13:07:02 <ReinH> so group _ [] = []
13:07:32 <ReinH> er, groupBy _ [] = [] is the canonical name
13:07:45 <ReinH> Now, groupBy eq (x:xs) = ???
13:07:45 <kadoban> Well this isn't quite groupBy
13:08:28 <ReinH> I'm not sure what "either do or don't satisfy a predicate" means, but if I take it to mean "do satisfy a predice", it does seem to be groupBy
13:09:06 <kadoban> I shouldn't have said anything, you're doing fine and it doesn't really matter.
13:09:12 <ReinH> If you group elements that either do or don't satisfy a predicate, then I present to you groupBy _ [] = []; groupBy _ xs = [xs]
13:09:27 <veyn> if x satisfies the predicate, then append x to the last list if the last list is a list that satisfies the predicate, else append the list [x] to the end of the list of lists
13:09:33 <ReinH> which groups all elements that either do or don't satisfy a predicate, which is all elements.
13:09:35 * hackagebot data-json-token 0.1.0.0 - Json Token datatype  https://hackage.haskell.org/package/data-json-token-0.1.0.0 (newhoggy)
13:09:45 <veyn> but appending and lasts are rather inefficient
13:09:54 <ReinH> veyn: So don't do that.
13:10:13 <ReinH> veyn: appending and lasts ar inefficient, but prepending and heads are efficient.
13:10:16 <ReinH> *are
13:10:22 <ReinH> so just tackle the problem the other way around.
13:10:46 <veyn> one reverse is more efficient than a few lasts
13:11:02 <ReinH> No reverses.
13:11:32 <ReinH> so. groupBy eq (x:xs) = ???
13:11:52 <ReinH> What can we do? Well, we don't need to work with only the head of xs. We have access to all of it.
13:12:15 <veyn> groupsOf :: (a -> Bool) -> [a] -> [[a]]
13:12:36 <veyn> so it's not group by
13:12:41 <ReinH> :t groupBy
13:12:43 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
13:13:10 <ReinH> Ah, I see.
13:13:32 <ReinH> So is this breaking up the list on boundaries where the result of p changes?
13:13:55 <veyn> Yes
13:14:18 <ReinH> e.g., if the predicate p = \x -> mod x 3 == 0, do we get groupsOf p [1..] = [[1,2],[3],[4,5],[6],...]
13:14:31 <veyn> yes
13:14:48 <ReinH> Ok, so it's groupBy which ignores its first argument ;)
13:14:59 <ReinH> I mean, where the predicate ignores its first argument
13:15:20 <veyn> Pretty much
13:15:23 <ReinH> or, rather, groupBy (\x y -> p x && p y)
13:15:25 <ReinH> Anyway, I get it
13:15:41 <ReinH> This is basically the same function, so we can continue.
13:16:16 <ReinH> So we have p :: a -> Bool and (x:xs) :: [a] at hand
13:16:26 <ReinH> Are you allowed to use prelude functions?
13:16:50 <veyn> They are rather unsafe but sure
13:16:57 <ReinH> unsafe?
13:17:06 <veyn> non-total
13:17:12 <veyn> some of them
13:17:14 <ReinH> The vast minority of prelude functions are unsafe.
13:17:18 <ReinH> And I won't use any of those.
13:17:25 <ReinH> Are you familiar with span?
13:17:33 <veyn> No
13:18:06 <ReinH> What we want to do is break xs into (the first group which satisfies the predicate, the rest)
13:18:14 <veyn> Ok Yeah
13:18:21 <veyn> I see how to do that using span
13:18:31 <ReinH> We can do it like this: span p xs = (takeWhile p xs, dropWhile p xs). There is a more efficient way, but it will work if we can't use span.
13:19:12 <ReinH> But if we have span, we have: groupsOf p (x:xs) = let (ys,zs) = span p xs in ???
13:19:44 <veyn> ys : span p zs
13:19:48 <ReinH> Wait, sorry, we need to handle x
13:20:00 <veyn> feh
13:21:16 <ReinH> if we groupBy p xs (since [] has already been matched, xs will be non-empty) and (ys,zs) = span p xs
13:21:35 <ReinH> What can we do with ys and zs, and how does it depend on whether either of them are empty?
13:22:08 <EvanR> "vast minority"
13:22:15 <EvanR> lol
13:22:16 <ReinH> EvanR: fsvo "vast"
13:22:28 <ReinH> But I mean the Prelude is pretty big
13:22:32 <EvanR> the most vast it can be is like 49.99 %
13:22:53 <ReinH> the "converse of vast" minority.
13:22:53 <EvanR> maybe 49.999
13:23:43 <ReinH> Applying some boolean algebra, I offer "the vast majority are not unsafe"
13:24:23 <grayling_> Does anyone know how to filter backslash from a list of characters, say a string? 
13:24:38 <ReinH> EvanR: And, depending on your... ahem... intuition... for such things, I also offer "the vast majority are safe".
13:24:38 <Cale> filter (/= '\\')
13:25:12 <ReinH> EvanR: that's a joke about intuitionistic logic Evan.
13:25:19 <ReinH> It's very funny.
13:25:24 <grayling_> removeOccurrences list = filter (\x -> x /= '\\') list
13:25:34 <grayling_> That should work. But doesn't.
13:25:38 <dicej> Is there a standard function or operator with type (Monad m => m a -> m b -> (a -> b -> m c) -> m c)?
13:25:41 <ReinH> grayling_: Define "doesn't work"
13:26:07 <Gurkenglas> dicej, http://hayoo.fh-wedel.de/?query=bind2
13:26:08 <grayling_>  removeOccurrences "\test"
13:26:11 <ReinH> :t liftM2
13:26:12 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:26:19 <grayling_> should return "test"
13:26:20 <ReinH> dicej: ^, flipped around a bit.
13:26:25 <dicej> ah, of course
13:26:26 <dicej> thanks
13:26:33 <ReinH> > "\t"
13:26:34 <lambdabot>  "\t"
13:26:40 <ReinH> grayling_: "\t" does not include a forward slash.
13:26:43 <dicej> oops, not quite
13:26:48 <ReinH> "\\t" includes a forward slash.
13:27:04 <dicej> I need (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
13:27:05 <ReinH> "\t" is a tab character
13:27:12 <Cale> ReinH: No it doesn't, it includes a backslash
13:27:31 <ReinH> Uh. Yes. s/forward/backward/g
13:28:04 <sboosalis> :r
13:28:25 <EvanR> ReinH: yes it is, sorry attempting to read something else on a slow connection
13:28:36 <ReinH> EvanR: <3
13:28:46 <byorgey> @type \f x y -> join (liftM2 f x y)
13:28:47 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
13:28:53 <byorgey> dicej: you can use that ^^^
13:29:02 <byorgey> dicej: there is no single function in the standard libraries with that type
13:29:03 <dicej> thanks, byorgey
13:29:06 <ReinH> dicej: Oh, yes, I see. What byorgey said.
13:29:08 <grayling_> Soo. If I have "/test" and want to remove the backslash, I can't?
13:29:25 <ReinH> grayling_: Neither "/test" nor "\test" contain a backslash.
13:29:37 <ReinH> When interpreted as Haskell strings.
13:29:41 <grayling_> Sorry. Meant "\test"
13:29:54 <ReinH> "\t" is an escaped tab character.
13:30:05 <ReinH> There is no backslash in the Haskell string  "\test"
13:30:16 <byorgey> grayling_: "\test" is a representation of the string which contains four characters, a tab character, an e, an s, and a t
13:30:23 <grayling_> Ah. Sorry. My bad.
13:30:28 <ReinH> There is a backslash in the Haskell string "\\test", which the filter will remove.
13:33:23 <grayling_> Thanks ReinH
13:34:16 <ReinH> grayling_: Yeah, how could you confuse a forward slash for a backward slash I can't believe someone would do that...
13:35:57 <grayling_> I'll let that one slide...
13:37:07 <ReinH> grayling_: I guess I should have included a sarcasm mark.
13:37:36 <Enigmagic> i only see a reverse solidus
13:37:46 <Enigmagic> no backslashes anywhere
13:38:23 <grayling_> Yeah. It is the slash of something.
13:45:48 <tsahyt> What's the easiest way to define a Foldable instance for a data type in terms of the foldable instance of one of its fields? I have something like data T = T (Set A) <...other stuff...> and want a fold over T to behave like a fold over the Set
13:46:27 <tsahyt> oh wait
13:46:33 <tsahyt> that doesn't work anyway
13:46:35 <tsahyt> nvm
13:48:29 <shachaf> You can't define a Foldable instance, but if you use lens, you can define a Fold, which does the same thing.
14:01:38 <Chop22> hi ¿?
14:01:46 <Chop22> I need some rom developer that can make me a port some linux distro to smartphones, pay $100 to do it...
14:02:00 <Chop22> or more...
14:02:49 <frerich> Chop22: Unless that port involves writing programs using the Haskell programming language, I'm afraid such requests are offtopic here.
14:02:55 <bernalex> $100 looooooooooooooool. also unless you're going to use haskell, it's kind of off-topic.
14:03:15 <Chop22> nope
14:03:51 <mniip> Chop22, you'd need at least one more digit if you're serious. And again, this is the haskell channel. Unless your request has something to do with haskell you're being off-topic
14:04:08 <Chop22>  I thought that here I would find one ... since the android I channel anyone answer me....
14:04:21 <Zekka|Sigfig> This channel’s not really dedicated to that
14:04:25 <Chop22> mniip, It's off-topic...
14:04:29 <Zekka|Sigfig> you could post on a freelancing site if you wanted
14:04:41 <Chop22> Zekka, yes, I know...
14:04:43 <bernalex> mniip: one more digit won't cut it.
14:04:45 <Zekka|Sigfig> There might still be someone here who would help you although I’m guessing they would charge you more
14:04:52 <mniip> bernalex, well that depends
14:05:02 <Zekka|Sigfig> to give you an idea, in the US, $100 is 2-10hours work at typical wages
14:05:09 <bernalex> mniip: unless it's one that's already on a phone, it pretty much doesn't.
14:05:13 <EvanR> what is a rom developer?
14:05:34 <Majiir> Zekka|Sigfig, and in the US, $100 is <1 hour at tech consulting rates
14:05:35 <Zekka|Sigfig> Programmers who took that job for $100 and took more than 20 hours to finish it would probably not be able to eat
14:05:50 <ReinH> Zekka|Sigfig: For someone capable of porting a linux distro to a smartphone? You're off by an order of magnitude.
14:05:51 <mniip> EvanR, in context of android, rom = system image ~~ firmware
14:06:10 <ReinH> Anyway, it's totally off topic
14:06:17 <Chop22> Yeah
14:06:23 <bernalex> I wonder how we could use haskell for that
14:06:32 <bernalex> out of interest, how's haskell on android these days?
14:07:14 <Chop22>  Does anyone know a rom developer?
14:07:45 <bernalex> Chop22: try #haskell-blah instead of this channel. you'll just annoy people.
14:08:01 * bernalex >>= sleep
14:08:02 <shachaf> Chop22: This channel is for Haskell discussion. Please stay on-topic.
14:08:04 <Chop22> bernalex,  I'm not asking about Haskell, just looking for a developer rom ...
14:08:36 <Zekka|Sigfig> Chop22: This channel is mostly for people who are asking about Haskell, so if you don’t want to do that you might want to switch to another channel
14:08:37 <EvanR> #rom-developers
14:09:19 <JulesR> What is Haskell ?
14:09:37 <johnw> JulesR: a general purpose programming language
14:09:47 <mniip> a functional programming language
14:09:48 <JulesR> Oh my
14:09:51 <ReinH> JulesR: see haskell.org for more info
14:10:18 <JulesR> Thx. No idea on how i landed here. Cheers
14:10:39 <ReinH> Well, since you're here...
14:10:49 <EvanR> your life will never be the same again
14:10:51 <ReinH> You should learn Haskell.
14:21:09 <EvanR> uh does ~ have a kind?
14:21:19 <EvanR> * -> * -> Constraint?
14:21:39 <EvanR> or does it work on non-*
14:22:12 <prsteele> silly syntax question, but I have "do x <- get; let z = f x;"; how can I just do "do z <- something" ?
14:22:27 <prsteele> well, type question masquerading as a syntax question
14:22:57 <jle`> prsteele: `do something`
14:23:00 <jle`> = `something`
14:23:19 <glguy> z <- f <$> get
14:23:22 <jle`> or am i missing something?
14:23:26 <Zekka|Sigfig> prsteele: in general: do z <- fmap f get . alternately, for State: do z <- gets f
14:23:27 <jle`> oh, i see
14:23:55 <EvanR> i guess the equality of two * -> * kind of doesnt make sense
14:24:12 <prsteele> ah thanks!
14:24:30 <glguy> EvanR: It works on non * kinds
14:24:32 <prsteele> using monad transformers for the first time so the error messages are a nightmare
14:24:43 <EvanR> is it some kind of extensional equality?
14:25:19 <jle`> (f ~ Maybe) => (a -> b) -> f a -> f b
14:25:35 <EvanR> that being said, i guess ~ is magic, it has to type/kind of its own
14:25:39 <jle`> :t fmap :: (f ~ Maybe) => (a -> b) -> f a -> f b
14:25:41 <lambdabot> (a -> b) -> Maybe a -> Maybe b
14:25:42 <EvanR> has no*
14:25:53 <glguy> (~) :: k -> k -> Constraint
14:25:58 <jle`> i could consider it k -> k -> Constraint
14:26:00 <jle`> :k (~)
14:26:01 <lambdabot> k -> k -> Constraint
14:26:03 <jle`> neat
14:26:04 <EvanR> wut
14:26:13 <jle`> k is a kind variable
14:26:18 <EvanR> lol
14:26:18 <jle`> so it can be *, * -> *, Nat, etc.
14:26:28 <jle`> as long as the first and the second are the same kind
14:26:34 <EvanR> k :: BOX?
14:26:34 <jle`> just like how type variables work :)
14:26:52 <jle`> it can be any kind, i guess
14:26:56 <Zekka|Sigfig> :k k
14:26:58 <lambdabot> Not in scope: type variable ‘k’
14:27:15 <Zekka|Sigfig> Oh no! How do I quantify this on the kind level?
14:27:29 <pavonia> :k forall k. k
14:27:30 <lambdabot> k
14:27:49 <EvanR> and the universe explodes?
14:28:03 <pavonia> Is this the same k as in (~)?
14:28:15 <jle`> haskell has never been concerned about universes exploding
14:28:24 <jle`> that's why let x = x in x compiles, heh
14:28:38 <EvanR> the kind of all kinds is ... itself?
14:28:44 <glguy> different k
14:28:58 <Zekka|Sigfig> :k forall g. g
14:28:58 <EvanR> which k i swhich
14:28:59 <lambdabot> k
14:29:01 <EvanR> oh
14:29:26 <EvanR> right... PolyKinds
14:29:36 <pavonia> That's confusing
14:30:37 <mniip> :k forall (k :: moo). k
14:30:39 <lambdabot> moo
14:31:34 <pavonia> Ah wait, that one k is a type and the other one is a kind
14:31:48 <EvanR> moo is the kind, k is the type
14:32:06 <pavonia> Yes, in the earlier examples, I meant
14:32:45 <EvanR> i still dont understand what that one was saying
14:32:55 <mniip> :k forall (k :: k). k
14:32:57 <lambdabot>     Kind variable also used as type variable: ‘k’
14:32:57 <lambdabot>     In GHCi input
14:33:04 <mniip> oi
14:33:08 <EvanR> k must be the default 
14:33:15 <jle`> sounds sensible
14:33:23 <mniip> well you know how the typechecker generates variable names
14:33:47 <EvanR> a tank of dolphins manipulating idea balls?
14:33:49 <mniip> r from renamer, t from typechecker, k from kindchecker
14:33:54 <pikajude> hi, is this expected behavior or a GHC bug? http://lpaste.net/151508
14:34:23 <glguy> expected behavior, the $(return []) affects TH staging
14:34:42 <hpc> EvanR: like that keanu reeves movie! ;)
14:35:29 <pikajude> glguy: can I reorder my code to make it work without $(return [])?
14:37:33 <glguy> pikajude: Search for the phrase "declaration groups" https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html
14:37:43 <EvanR> oh jeez ghc user manual for ghc 8 looks all fancy
14:38:51 <pikajude> glguy: given their example, i'm not sure why my code doesn't work
14:39:04 <pikajude> oh wait, those are top-level splices. I thought they were in a where-binding
14:39:05 <pikajude> never mind
14:56:53 <tempay> Hi guys - anyone here understand Spacemacs?
14:58:09 <mzabani> hi everyone! I'm having issues with delayed read on closed handles. Being very new to Haskell, I wonder what kind of general patterns ther are for dealing with IO + Lazy Evaluation.
14:59:06 <mauke> don't close half-closed handles
14:59:58 <geekosaur> mzabani, are you using hGetContents and then trying to do something else with the handle?
15:00:15 <geekosaur> or perhaps using that under withFile?
15:00:27 <mzabani> I'm using it with withFile
15:00:46 <geekosaur> use a hGetLine loop, or don't use withFile
15:01:02 <mzabani> I thought this would guarantee that I wouldn't forget to close my handles, but it's not that simple with lazy evaluation..
15:01:06 <geekosaur> lazy I/O is its own weird
15:01:19 <geekosaur> it's not lazy evaluation *per se* here.
15:01:30 <mauke> mzabani: that's a bug
15:01:37 <geekosaur> lazy I/O (getContents, hGetContents) is weird
15:01:45 <mauke> hGetContents closes the handle
15:01:56 <mauke> so if you combine it with withFile, you get a double close
15:02:02 <geekosaur> basiclaly you open i a handle, and hGetContents "half-closes" it. it will be fully closed when you exhaust the string
15:02:11 <mzabani> oh wow..
15:02:14 <geekosaur> the string is magical and does reads in the background as you work with it
15:02:24 <mzabani> this is all new to me. So I shouldn't use withFile in this case?
15:02:27 <geekosaur> right
15:02:35 <mzabani> when should I use withFile?
15:02:39 <mauke> :t readFile
15:02:40 <lambdabot> FilePath -> IO String
15:03:02 <geekosaur> when using hGetLine or hGet or other strict (normal) I/O operations
15:03:08 <geekosaur> er hGetBuf
15:03:31 <mzabani> right, so I need to know whether or not the function to be used under withFile will close the handle or not
15:03:50 <mauke> yes
15:03:58 <mauke> hClose and hGetContents close the handle
15:04:08 <mzabani> interesting, but isn't it easy to make mistakes like this?
15:04:49 <mzabani> I mean, shouldn't I worry about this in the long term? Or does it get easier with practice?
15:04:49 <EvanR> yeah, you can avoid it completely in various ways
15:04:51 <geekosaur> it is. yes
15:04:57 <EvanR> just read the whole string in at once
15:05:00 <EvanR> close the file instantly
15:05:22 <EvanR> lazy IO is crazy
15:05:31 <geekosaur> it's annoying that lazy I/O is the default but defaults to dangerous behavior
15:06:01 <mzabani> hmm, what if the application passes handles down from the top and ensures closing after the application ends? Is this a viable option?
15:06:12 <mzabani> from the main function itself, I mean
15:06:13 <EvanR> i.e. never close it
15:06:45 <mzabani> yep, never closing it (until application termination)
15:06:45 <EvanR> no, just read the file strictly or use a streaming libr
15:06:50 <EvanR> library
15:07:28 <mzabani> by streaming library do you mean something like conduit?
15:07:44 <EvanR> lazy IO (readFile, getContents) is like a carnival side show
15:08:10 <EvanR> conduit, or pipes, and at one point there was a thing iteratees
15:09:22 <glguy> mzabani: It's OK to close a Handle multiple times. What's not OK is trying to use lazy IO on a Handle that you've manually closed
15:09:56 <glguy> so you can use withFile and also use hClose inside that without breaking anything
15:10:45 <mzabani> glguy: I think I get it, though I'm a little concerned now that lazy IO is indeed a very tricky thing
15:10:59 <Cale> Yeah, if you use lazy I/O primitives, you basically give up your right to hClose.
15:11:21 <Cale> (you can do it, but you'll end up arbitrarily truncating the values that you read)
15:11:36 <glguy> The other thing to be careful with is if you use lazy IO on a file, you can't open that file again for writing until it's closed for reading
15:11:48 <glguy> and if you're using lazy IO it's not obvious when that file will be closed
15:11:59 <mzabani> lol it really is very complicated
15:12:13 <mzabani> so, deterministically releasing resources is complicated
15:12:41 <EvanR> does LYAH recommend lazy IO or why is it still a thing? just because readFile happens to do it?
15:13:37 <Cale> Basically lazy IO is great in cases where you're not doing anything very complicated. If your program reads one or two big files which it doesn't write to, then lazy IO can be quite convenient.
15:13:39 <mzabani> I honestly can't say, it's been a while since I read the IO chapter in LYAH. I've been doing things with hoogle and looking at type signatures now
15:13:58 <geekosaur> *everything* recommends it
15:14:02 <Cale> But if e.g. the number of open filehandles might be a concern to you, don't use lazy IO
15:14:06 <EvanR> :(
15:14:39 * hackagebot b9 0.5.17 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.17 (SvenHeyll)
15:14:43 <mzabani> but what about other resources? Network connections, for instance
15:14:56 <Cale> Sure, those too!
15:14:58 <EvanR> you can totally use hGetContents on a socket
15:15:04 <EvanR> and be damned!
15:15:11 <Cale> Yeah, don't do that
15:15:12 <mzabani> lol
15:15:31 <Cale> You typically care about when sockets get closed
15:15:33 <mzabani> but do higher-level wrappers on sockets and other resources suffer from the same issues?
15:15:45 <Cale> So lazy IO is inappropriate for any nontrivial network application
15:16:09 <Cale> There are other ways of approaching these things which don't have the problems associated to lazy IO
15:16:17 <Cale> For example, strict IO, haha
15:16:32 <mzabani> hahaha oh my
15:16:36 <Cale> Or pipes/conduit/flavour-of-the-month-stream-IO
15:16:43 <EvanR> brilliant
15:17:09 <glguy> I'd use flavour-of-the-month-stream-IO if the package name wasn't so long
15:17:12 <Cale> haha
15:17:19 <mzabani> is one of these libraries you mentioned a de facto standard or am I free to use any of them?
15:17:40 <Cale> You can try them, but they're heavy tools
15:17:55 <Cale> I wouldn't just lightly decide to use one of them typically. Doing strict IO is not hard.
15:18:05 <EvanR> does attoparsec come with an incremental handle reader
15:18:28 <mzabani> Cale: anywhere I can learn about it?
15:18:28 <Cale> (usually, until you get to the point where things are complicated enough that you want one of those libraries)
15:19:12 <Cale> Are you doing text or binary IO?
15:19:19 <EvanR> secure reading of lines is hard :(
15:19:32 <mzabani> so far, just text
15:19:33 <EvanR> hGetLine will exhaust all memory
15:19:37 <Cale> http://hackage.haskell.org/package/text-1.2.2.0/docs/Data-Text-IO.html
15:19:44 <Cale> all this stuff is strict
15:20:31 <Cale> http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString.html -- similarly there's a bunch of ByteString I/O stuff toward the end of this
15:20:45 <Cale> and it's all strict too
15:21:17 <mzabani> hmm all right, so deepseqing things is really not the way to go
15:21:25 <EvanR> ;_;
15:21:27 <mzabani> I was scared you might've told me so
15:21:49 <EvanR> thats what you have to do in clojure to get maps over IO to execute effects
15:22:05 <EvanR> insanity
15:22:10 <mzabani> and if I want the benefits of lazy evaluation when doing IO, I should either use some stream library or do it myself carefully
15:22:22 <EvanR> dont confuse lazy evaluation with lazy IO
15:22:32 <mzabani> oops, sorry, lazy IO
15:23:34 <EvanR> yeah you can pretty easily fold over lines 1 by 1 yourself
15:23:52 <EvanR> but doing it on untrusted input is a bitch with just the standard IO commands
15:24:41 <mzabani> but then, if I may go back to an idea I had from the start, why is it a bad idea to acquire resources when the application starts and release them when it ends, passing them down to other functions?
15:25:14 <EvanR> you dont want to infect your whole app with IO and file handling
15:25:32 <EvanR> you want to keep that at the top level and use abstractions to deal with the purely functional parts
15:26:05 <mzabani> but is it not the same? With this approach, anything that reads from the handle will be IO, just like it would've been before
15:26:16 <mzabani> and everything else would not be IO, just the same as it was too, right?
15:26:41 <EvanR> if most of your functions have IO in the type, thats not the same
15:26:47 <EvanR> as what im saying ;)
15:27:11 <EvanR> you cant use a Handle in a non IO piece of code
15:28:30 <mzabani> I understand that, what I still don't get is why this would force functions that were previously "pure" (non IO) to become non-pure
15:28:56 <EvanR> i guess you have to describe what you had before
15:29:41 <EvanR> from what i understand, before you had functions operating on a whole string representing the whole file, and now you cant do that
15:29:55 <EvanR> (unless you read the whole file in one go)
15:32:27 <mzabani> EvanR: hmmm, let me see, we would have to have a function that is of type Handle -> IO String, and the caller of this function would extract the string from the monad and pass it to pure code
15:32:43 <mzabani> is it not the same?
15:32:50 <EvanR> well, thats not incremental
15:34:05 <EvanR> but it is the easiest, and that function already exists in Data.Text.IO
15:34:32 <EvanR> readFile :: FilePath -> IO Text
15:37:01 <Cale> mzabani: It's not such a terrible idea to acquire resources and not release them... so long as you don't need more resources than you have
15:37:22 <Cale> mzabani: Most OSes have pretty draconian limits on things like open filehandles and sockets
15:37:37 <mzabani> hmm I think I need to experiment on this, if only to better understand the issues and everything else
15:38:03 <mzabani> EvanR Cale is there any good article discussing IO in haskell?
15:38:25 <mzabani> not exactly IO, but rather resource acquisition and release
15:38:40 <Cale> I dunno, there's not really all that much to it
15:38:48 <Cale> There's some stuff in the documentation for System.IO
15:39:05 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.2.0/System-IO.html
15:39:31 <EvanR> acquire it, do what you need to do, and release it. 
15:39:58 <EvanR> the doing what you need to do is the tricky part if you are trying to avoid using more memory than necessary
15:40:00 <Cale> Well, maybe it's a bit of a lie that there's not much to it -- there's a lot of stuff you can do to configure Handles
15:40:17 <Cale> Oh, and you might want to know about bracket...
15:40:42 <EvanR> withFile
15:40:45 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.2.0/Control-Exception.html#v:bracket
15:40:46 <EvanR> :t withFile
15:40:48 <lambdabot>     Not in scope: ‘withFile’
15:40:48 <lambdabot>     Perhaps you meant one of these:
15:40:48 <lambdabot>       ‘writeFile’ (imported from Prelude),
15:40:54 <mzabani> EvanR: basically, default to strict IO when possible
15:41:18 <EvanR> which is always ;)
15:41:23 <Cale> mzabani: Yeah, if you can get away with using strict Text or ByteString IO, then just do that
15:42:03 <EvanR> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
15:42:16 <EvanR> this thing will open and close the handle for you
15:42:41 <mzabani> yep, will stop using it as I am now
15:42:44 <EvanR> even if an exception occurs
15:43:21 <mzabani> thank you
15:43:23 <mzabani> everyone
15:43:50 <c_my_nick> is there an image processing library that doesnt have any external dependencies (imagemagick, etc.)?  i am specifically looking for one that can tell me the file type and the dimensions of an image file.
15:44:47 <EvanR> juicy pixels?
15:45:58 <jellytux> http://sprunge.us/TLXR
15:46:14 <jellytux> I am getting an error on this three-lined code
15:46:37 <jellytux> parse error on input 
15:46:37 <pavonia> What error?
15:46:56 <jellytux> parse error on input ‘(’
15:47:17 <jellytux> what's wrong with it?
15:48:25 <pavonia> Does it work if you remove the parentheses?
15:48:46 <EvanR> jellytux: put the cases on the next line indented
15:48:57 <EvanR> maybe
15:49:43 <EvanR> though that code compiles for me
15:49:46 <EvanR> as is
15:50:08 <EvanR> i bet the problem is with the rest of your "three line code"
15:50:42 <pavonia> Or perhaps a tab in the original code?
15:51:01 <EvanR> yeah
15:51:18 <EvanR> dont use tabs
15:51:28 <jellytux> that's weird, yeah it was the tabs
15:51:49 <jellytux> copy pasted it probably why (?) idk
15:52:01 <ReinH> jellytux: GHC interprets tabs as 8 characters. If your editor is configured differently, things can appear to be correct that are actually incorrect.
15:52:15 <ReinH> Other tabs vs. spaces arguments aside, this is a strong reason to prefer spaces only for Haskell.
15:52:51 <jellytux> I am using spaces for tabs though in vim, it must have been that when I pasted it copied tabs?
15:53:58 <ReinH> jellytux: make sure you :set expandtab
15:54:40 <jellytux> ReinH: it is set
15:54:50 <ReinH> ok then
15:54:53 <ReinH> weird
15:54:55 <ReinH> carry on
15:56:42 <jellytux> oh, I resolved it by removing the tabs and replacing them with spaces - just to clarify
15:57:26 <EvanR> "Custom compile-time errors" holy sh- this latest ghc is awesome
15:58:59 <EvanR> assertions with a source location o_O
16:03:35 <Welkin> EvanR: ghc 8?
16:04:57 <Gurkenglas> Can we have "coerce :: (Functor f, Contravariant f) => f a -> f b" replaced with "coerce :: Coercible * a b => a -> b" in lambdabot?
16:09:40 <tempay> I'm having a really really hard time getting my environment set up. Super sad. Every time I load a Stack source file in my Emacs setup I get ghc-mod complaining about "Prelude.chr: bad argument: 1932009"
16:10:11 <tempay> I can build the project with stack and cabal and ghc just fine, so I guess I have a problem with ghc-mod in emacs?
16:10:45 <tempay> I don't know how anyone gets their environment set up, it unbelievably complicated
16:11:15 <dcoutts> tempay: looks like failing to read some binary file
16:11:29 * dcoutts has never used ghc-mod so cannot help with the env setup
16:11:44 * dcoutts has written a Haskell IDE but never used one
16:11:48 <glguy> Most people I know use a really simple set up
16:11:50 <mgsloan> tempay: The problem is that ghc-mod does not check that it was built with the right ghc version
16:11:57 <bitemyapp> dcoutts: it's pretty fussy. Having emacs or vim read error output from cabal build or stack build is easier.
16:12:07 <bitemyapp> flycheck "just works" for me as a result.
16:12:24 <mgsloan> It's on my todolist to take a look at ghc-mod and make stack integration more up to people's usual expectations of "just works"..
16:12:27 <bitemyapp> and yeah, it's simple. It's just invoking `stack build` and grepping for warnings/type errors and putting them in the buffer.
16:12:39 <ReinH> mgsloan: +1000 <3
16:12:46 <mgsloan> tempay: Doing "stack build ghc-mod" in your project dir should resolve that issue
16:13:07 <dcoutts> bitemyapp: the fact that these things don't have proper apis to each other makes it very likely to be fragile
16:13:10 <tempay> mgsloan I'll try that
16:13:12 <ReinH> mgsloan: mind if I pm?
16:13:28 <mgsloan> ReinH: Go for it!
16:13:45 <bitemyapp> dcoutts: yeah I don't blame Cabal for that.
16:13:53 <bitemyapp> dcoutts: I just try to steer people away from fragile bling.
16:14:07 <dcoutts> bitemyapp: well we could do better in providing apis for ghc-mod etc to use.
16:14:10 <bitemyapp> the "grep for warnings/errors and col/row" is much more reliable.
16:14:28 <bitemyapp> dcoutts: true enough but y'all barely keep up with the github issues for what's already in your scope of responsibilities.
16:14:35 <bitemyapp> dcoutts: it'd be better to let the haskell-ide-engine people do their thing
16:14:42 <ReinH> bitemyapp: vim's built-in compiler error reporting support is basically an elaborate version of that
16:14:54 <bitemyapp> ReinH: I'd linked that to brisbin recently.
16:15:02 <ReinH> brisbin?
16:15:04 <dcoutts> bitemyapp: as one of the original authors of haskell-ide-engine, I think it needs to integrate better with the Cabal lib :-)
16:15:07 <ReinH> Oh the person.
16:15:28 <bitemyapp> ReinH: they wanted something not-ghc-mod for vim. Okay, so regex the errors using vim's thingajigge.r
16:15:43 <mgsloan> dcoutts: haskell-ide-engine doesn't have much ide-backend code yet.  Infact, it's all based on ghc-mod which does have a lot of cabal integration, albeit quite complexly
16:15:45 <ReinH> iirc the haskell stuff already supports ghc as the make program
16:15:49 <ReinH> so they shouldn't have to do anything
16:15:56 <dcoutts> mgsloan: oh ok, separate code bases
16:16:08 <ReinH> well, except for configure it in an arcane and under-documented way
16:16:25 <mgsloan> Yup!  Hoping to at least get the info collection stuff in HIE, because it's much better than ghc-mod's (which seems to recompile the module for every query)
16:16:41 <tempay> so what does running "stack build ghc-mod" do exactly? is it something that I'll have to run every time I make a new project? it's asking me to add cabal-helper as a dependency now, should I add that to my project's dependancies?
16:16:54 <ReinH> bitemyapp: I once spent a fair amount of time with vim's makeprg support (e.g., https://github.com/reinh/vim-makegreen)
16:17:30 <ReinH> I am happy to not have to do so any more.
16:17:38 <mgsloan> tempay: It build ghc-mod and puts the binary in .stack-work/install
16:17:59 <mgsloan> tempay: Ugh, actually one issue is that emacs will not use the stack path in order to resolve ghc-mod
16:18:36 <tempay> so i guess i'll need to rebuild ghc-mod with a different version of ghc?
16:18:41 <tempay> globally i mean
16:18:53 <mgsloan> If you do "stack exec emacs", it will run with the PATH for your environment, so it will know where to find ghc-mod
16:19:12 <mgsloan> Might need to do --no-ghc-package-path if it ever invokes cabal, because cabal doesn't like that env var 
16:20:49 <tempay> so for each project i'll need to add ghc-mod's dependancies, run stack build ghc-mod, and then launch emacs from stack?
16:20:57 <mgsloan> tempay: If you just want to get to work now, do "stack install ghc-mod".  This will install the right version of ghc-mod globally, but you will need to install it again whenever you switch project
16:21:19 <EvanR> Welkin: yeah
16:21:55 <mgsloan> tempay: Yes, if you want to be able to use different ghc versions with different projects.  If there's a way to provide the ghc-mod path in emacs, you could also use that and have a dir-locals el or something
16:22:01 <tempay> why will i need to install it again if it's installed globally? in case i switch ghc versions?
16:22:02 <tempay> i see
16:22:05 <mgsloan> Yes
16:22:27 <mgsloan> Sucks, I know.  Maybe soon this will be cleaned up :)
16:22:42 <tempay> i hope so :) thanks very much for your help
16:22:57 <ghorn> if anyone knows gtk / gtk2hs, i would appreciate a look at http://stackoverflow.com/questions/35147473/cant-get-gtk2-cellrenderercombo-to-display-anything
16:23:52 <Gurkenglas> https://github.com/ekmett/lens/blob/master/examples/Pong.hs#L174 should be "zoom vectors $ state unconsJust". Also Safe should have unconsJust.
16:27:28 <EvanR> constraint canonicalization... this is cool
16:38:22 <edwardk> Gurkenglas: did it bit rot?
16:38:52 <edwardk> oh, just preferred style
16:39:12 <Gurkenglas> yes ^^
16:40:52 <dedgrant> Is there an idiomatic name for the practice of adapting a kind to * and back again?
16:45:12 <KaiJia> 东八区的各位菊苣早
16:51:12 <dedgrant> reifyhead :: k `f` l -> t k `g` l   ... looks a bit familiar.
17:03:41 <mniip> hey edwardk
17:07:41 <edwardk> heya mniip 
17:08:00 <mniip> edwardk, I've made an arguably interesting thing, mind checking it out? :o
17:08:27 <edwardk> feel free to send it my way, but you may get interrupted by dinner showing up =)
17:08:42 <mniip> edwardk, probably the shortest monadic parsing lib ever http://lpaste.net/151381
17:09:30 <edwardk> cute
17:10:18 <codehero> haskell is making me crazy..
17:10:28 <codehero> *driving
17:10:37 <mniip> edwardk, I shall name it yoctoparsec :p
17:14:03 <python476> one day I'll understand all this Free Monadic stuff 
17:14:10 * python476 back to Cont a
17:14:15 <mniip> wait
17:14:37 <mniip> :t Control.Monad.Trans.Free.FreeT . pure . Control.Monad.Trans.Free.Free
17:14:39 <lambdabot> Applicative m => f (Control.Monad.Trans.Free.FreeT f m a) -> Control.Monad.Trans.Free.FreeT f m a
17:14:55 <python476> Everything is clear now
17:15:46 <codehero> one day i'll understand all this monad stuff...
17:16:03 <mniip> -item = FreeT . pure . Free $ FreeT . pure . Pure
17:16:03 <mniip> +item = FreeT . pure . Free $ pure
17:17:04 <mniip> now if only there was a sane way to golf the 'consume' function
17:23:58 <Gurkenglas> mniip, many item?
17:24:07 <mniip> ?
17:24:11 <Gurkenglas> :t many
17:24:12 <lambdabot> Alternative f => f a -> f [a]
17:24:18 <mniip> what about it
17:24:24 <Gurkenglas> Shouldnt that be consume
17:24:41 <mniip> umm
17:24:42 <mniip> no?
17:25:13 <Gurkenglas> Is consume this? http://hackage.haskell.org/package/conduit-1.2.6.1/docs/Data-Conduit-List.html#v:consume
17:25:28 <mniip> no?
17:25:32 <mniip> http://lpaste.net/151381
17:25:34 <mniip> this consume ^
17:25:51 <Gurkenglas> Oh, only looked at the top level ._.
17:28:48 <anks> is there a special idiom for reusing leftovers with next chunk, when parsing with pipes-parse?
17:29:41 <jellytux> Hi this does not make sense to me, replicate' :: (Num i, Ord i) => i -> a -> [a]  
17:29:54 <jellytux> am I suppose to take `a` for anything?
17:30:14 <jellytux> and how come Num i, Ord i both refers to `i`?
17:30:43 <dedgrant> jellytux: a can be substituted with any type, and i has both Num and Ord typeclass constraints
17:30:50 <anks> jellytux: apparently they are disjoint and both needed in implemetaion of replicate
17:32:19 <anks> jellytux: imagine, someone using a Complex number for replicate.. ;] , htats why Ord is neccessary
17:33:43 <jellytux> I didn't know you could keep appending valid types classes like that
17:34:42 * hackagebot generic-accessors 0.6.0.0 - stringly-named getters for generic data  https://hackage.haskell.org/package/generic-accessors-0.6.0.0 (GregHorn)
17:35:10 <jellytux> anks replicate' :: (Num i, Ord i, String i) => i -> a -> [a]  
17:35:30 <jellytux> dedgrant: why could I do something like that?
17:35:34 <jellytux> couldn't*
17:36:15 <dedgrant> jellytux: well, what kind of thing is String?
17:36:36 <jellytux> dedgrant: a List of characters
17:37:16 <dedgrant> jellytux: It is a type. Num and Ord are typeclasses, not types.
17:37:59 <mniip> :k (m i) => m
17:38:02 <lambdabot>     Expecting one more argument to ‘m’
17:38:02 <lambdabot>     Expected a type, but ‘m’ has kind ‘k0 -> Constraint’
17:38:02 <lambdabot>     In a type in a GHCi command: (m i) => m
17:38:07 <jellytux> replicate' :: (Num i, Ord i, Bool i) => i -> a -> [a]  
17:38:08 <mniip> dammit
17:38:16 <jellytux> ah, sorry
17:39:04 <Enigmagic> you could say `Bool ~ i` (`i` is equal to `Bool) but not `Bool i`
17:39:43 <dedgrant> jellytux: If you meant (i ~ String), you could get 'replicate' :: String -> a -> [a]'
17:40:20 <dedgrant> Does (~) prove reflexivity?
17:40:24 <jellytux> dedgrant: no I just got it wrong
17:40:28 <mniip> :t undefined :: (Num i, Ord i, Bool ~ i) => i -> a -> [a]  
17:40:30 <lambdabot>     No instance for (Num Bool)
17:40:30 <lambdabot>       arising from an expression type signature
17:40:30 <lambdabot>     In the expression:
17:40:35 <mniip> damn
17:40:39 <jellytux> dedgrant: I kind of get it now, replicate' :: (Num i, Ord i, Bool i) => i -> a -> [a]  
17:40:48 <jellytux> http://sprunge.us/GVCA
17:41:04 <jellytux> sorry miss pasted the bool stuff
17:41:08 <codebje> is ~ in types haskell98/2010, or an extension?
17:41:19 <codebje> (and what does it actually mean? :-)
17:41:32 <jellytux> so we need Num i and Ord i because we use compare in our pattern guards as well as numbers
17:41:32 <mniip> it's a type equality constraint
17:41:53 <jellytux> we also use numbers when comparing n <= 0
17:41:59 <mniip> I *think* you can estimate ~ with: class (~) a b | a -> b, b -> a; instance (~) a a
17:42:15 <mniip> possibly with some extra polykind spice
17:42:58 <dedgrant> mniip: Yea I think it preserves kinds as well.
17:43:26 <mniip> @let class Tilde (a :: k) (b :: k) | a -> b, b -> a
17:43:28 <lambdabot>  Defined.
17:43:33 <mniip> @let instance Tilde a a
17:43:35 <lambdabot>  Defined.
17:43:50 <mniip> :t undefined :: (Tilde a Char) => a
17:43:51 <lambdabot> Char
17:43:54 <mniip> \o/
17:44:01 <dedgrant> hurrah! :)
17:44:12 <mniip> :k Tilde
17:44:13 <lambdabot> k -> k -> Constraint
17:45:23 <sboosalis> I have a stack issue if anyone can help. 
17:45:24 <sboosalis>  
17:45:24 <sboosalis> During `stack install`, a dependency doesn't configure. It fails very tersely with http://pastebin.com/tnzTHD3h
17:45:24 <sboosalis>  
17:45:24 <jellytux> o_O
17:45:27 <sboosalis> And then suggests increasing the verbosity. How can I pass `-v3` down (e.g. as if I'd entered `cabal configure -v3`)? `stack -v3 install` and permutations thereof don't work. (I'm new to stack, been reading http://docs.haskellstack.org/en/stable/GUIDE.html ).  
17:45:30 <sboosalis>  
17:45:33 <sboosalis>  
17:46:43 <codebje> mniip, thanks, that's the google-able bit I need
17:47:39 <sboosalis> oh wait just found there's a #haskell-stack chattel, sorry 
17:51:46 <mniip> hey Cale
17:51:52 <mniip> I checked out the catsters video
17:51:52 <mniip> s
17:51:55 <Big_G> Why would someone want to use the for all syntax?
17:52:15 <mniip> Big_G, huh?
17:52:52 <Enigmagic> forall prolly
17:52:52 <Big_G> mniip, In the type definition, I can write "for all a. [a]" or just "[a]"
17:52:59 <mniip> Cale, so I decided to start from the beginning, and I understood everything until the limits and colimits part 4, when she just started dumping categorical nonsense and I got lost :(
17:53:09 <dedgrant> Big_G: In rare situations forall is required to introduce a type variable explicitly.
17:53:23 <mauke> Big_G: scoped type variables or rank-n types
17:53:36 <dedgrant> Big_G: [a] implies (forall a. [a])
17:54:24 <Big_G> Thanks. I'll look into those two
17:54:43 <Cale> mniip: Yeah, that's okay, don't worry :)
17:54:53 <Cale> mniip: There isn't really a coherent order to the videos unfortunately
17:55:34 <mniip> I can totally see how a cone is an NT from the const functor to the diagram functor though
17:57:06 <Big_G> Why does scopedtypedvariables only work when specified by forall?
17:57:49 <synergistics> Hey everyone
17:58:22 <pavonia> Big_G: To give you control over when it should apply and when not, I presume
17:58:39 <Gurkenglas> mniip, I don't know about sane but this feels like a step in the right direction http://lpaste.net/151381  this feels like Witherable could help somehow?
17:59:29 <mniip> Gurkenglas, hmm how?
17:59:51 <Gurkenglas> What I'm writing feels like an implementation of catMaybes
18:00:07 <mniip> the idea is that we tear down the free monad using a monad transformer
18:00:14 <mniip> and in our case the transformer is a StateT over the string
18:00:27 <mniip> and on every iteration we uncons one character
18:00:33 <Gurkenglas> i know
18:00:51 <dedgrant> Big_G: something to consider: (forall a. a) -> b  is a different type than  forall a. (a -> b)  -- the type variable a is introduced in a different scope
18:00:52 <mniip> hmm
18:01:29 <mniip> Big_G, consider
18:01:59 <dedgrant> Big_G: a -> b  implies  forall a b. a -> b  in Haskell shorthand.
18:02:12 <mniip> \f (x, y) -> (f x, f y)
18:02:20 <Gurkenglas> Whoops, needed a StateT around the uncons of course http://lpaste.net/151518
18:02:31 <mniip> which infers the type (a -> b) -> (a, a) -> (b, b)
18:02:48 <mniip> but what if you call it with f=reverse and (x, y) = ([1,2,3], "foo")
18:02:56 <mniip> it would make sense however it would not typecheck
18:03:13 <mniip> to make it typecheck you have to manually specify that the function has type
18:03:30 <mniip> (forall a. [a] -> [a]) -> ([b], [c]) -> ([b], [c])
18:04:13 <mniip> hum, I'm probably giving a rather incoherent explanation there
18:04:37 <Big_G> Correct me if I'm wrong but isn't that just duck typing?
18:04:42 <pavonia> mniip: How is this related to ScopedTypeVariables?
18:04:43 * hackagebot metadata 0.4.0.0 - metadata library for semantic web  https://hackage.haskell.org/package/metadata-0.4.0.0 (KatsutoshiItoh)
18:04:53 <mniip> pavonia, his original question was about explicit foralls?
18:05:19 <pavonia> Ah sorry, I haven't seen that
18:06:24 <mniip> Cale, right, so, she says something about "the totality of all cones" - what is that even
18:06:59 <dedgrant> Big_G: What makes you think of duck typing?
18:07:36 <dedgrant> Big_G: Another perspective: If you're familiar with scope in imperative languages, say how { int a; } can mean that a is only defined within the {} in C, this is an analogous concept in the lambda calculus. Variables are only defined in their respective scopes.
18:07:39 <Big_G> dedgrant, The attitude of "I don't care what type it is as long as I can have this function (reverse) act on it"
18:08:02 <Gurkenglas> Oh hey mniip you missed two eta reductions there http://lpaste.net/151518
18:08:45 <dedgrant> Big_G: Ah I see. Yea, except in this case, forall is not so much 'I don't care' as it is 'this is proven for every type'.
18:11:09 <Reshi> The Serialable Type says: declare a Serialize instance for it without giving a definition for put and get. How do I make an instance without giving a definition? I tried `instance Serialize MyType where` and left it empty but that is an error of course.
18:12:33 <Big_G> mniip, How does "(forall a. [a] -> [a]) -> ([b], [c]) -> ([b], [c])" type check for that expression?
18:12:49 <mniip> what do you mean
18:13:15 <Big_G> You have a function that takes in an [a] and apply it to a value of [b]
18:13:24 <Big_G> *type 
18:17:53 <pavonia> Big_G: It doesn't have to work for "an" [a], but for all possible a's, so for b and c too
18:18:28 <Gurkenglas> mniip, oh I'm completely stupid. http://lpaste.net/151518
18:18:47 <mniip> :t maybe empty pure
18:18:48 <lambdabot> Alternative f => Maybe a -> f a
18:18:53 <mniip> :O
18:19:02 <Gurkenglas> :D
18:19:05 <Big_G> pavonia, That's pretty trippy
18:19:20 <mniip> :t runStateT . iterTM (mapStateT (maybe empty pure) (StateT uncons) >>=)
18:19:22 <lambdabot> Not in scope: ‘iterTM’
18:19:31 <mniip> :t runStateT . Control.Monad.Trans.Free.iterTM (mapStateT (maybe empty pure) (StateT uncons) >>=)
18:19:33 <lambdabot> (Monad m, Alternative m) => Control.Monad.Trans.Free.FreeT ((->) a1) m a -> [a1] -> m (a, [a1])
18:19:44 <Big_G> pavonia, Ourside of those parens, does the notion of 'a' get lost?
18:20:23 <pavonia> Yes, a is only defined in that parenthesized (?) scope
18:21:55 <pavonia> :t undefined :: (a ~ Int) => (forall a. a -> a) -> a -> a
18:21:57 <lambdabot> (forall a. a -> a) -> Int -> Int
18:24:43 <Big_G> In "(forall a. [a] -> [a]) -> ([b], [c]) -> ([b], [c])", do the two uses of a have to be the same? 
18:24:43 * hackagebot mappy 0.1.2.0 - A functional programming language focused around maps.  https://hackage.haskell.org/package/mappy-0.1.2.0 (mjgpy3)
18:26:17 <pavonia> What do you mean?
18:26:28 <dedgrant> Big_G: Yes both a's in (a -> a) are the same.
18:27:04 <dedgrant> Big_G: or ([a] -> [a]) 
18:27:13 <Big_G> Yeah, that was what I was going for
18:27:22 <mniip> Gurkenglas, I don't know how I feel about dumping a monadic constraint on 'item' though
18:29:08 <lpaste> mniip revised “monadic parser”: “monadic parser” at http://lpaste.net/151381
18:29:22 <Gurkenglas> mniip, elaborate pls. Isn't it just Applicative up to now? Can you keep editing a paste if you're refering to new code? Is that though meant to connect to the previous sentences of the discussion?
18:29:48 <mniip> Gurkenglas, if we say 'item = FreeT . pure . Free $ pure'
18:29:53 <mniip> we impose a monad constraint on item
18:30:42 <dedgrant> Big_G: but.. they would be different for  ([forall a. a] -> [forall a. a])  ;)    We try to avoid shadowing variable names like this because it is easy to read the code wrong. (Similar to the way { int a; { int a; } } would be bad practice in C.)
18:30:45 <flexk> :t pure
18:30:47 <lambdabot> Applicative f => a -> f a
18:31:06 <mniip> I have a feeling that the Applicative instance for FreeT can be lowered to an Applicative constraint
18:31:32 <mniip> but that's not a common thing to do in the monadtrans world
18:32:07 <Big_G> dedgrant, Would that be the same thing as a -> b
18:32:55 <mniip> Gurkenglas, bruh
18:32:58 <mniip> who needs mapStateT
18:33:02 <mniip> parse = runStateT . iterTM (StateT (maybe empty pure . uncons) >>=)
18:33:11 <Gurkenglas> hmm right
18:34:32 <mniip> oh duh
18:34:35 <mniip> maybe . uncons
18:34:41 <mniip> is the teardown I was looking for
18:35:30 <Gurkenglas> "maybe . uncons"???
18:36:40 <mniip> Gurkenglas, figuratively
18:37:22 <Gurkenglas> Then why'd the oh duh come more than a minute after the hmm right? Ah, communication.
18:38:07 <mniip> Gurkenglas, yesterday I was looking for something that'd do a -> (a -> [a] -> r) -> [a] -> r
18:38:19 <mniip> i.e a fold on lists that only destroys one layer
18:38:36 <mniip> maybe 'composed with' uncons is exactly that
18:43:27 <lpaste> mniip revised “monadic parser”: “No title” at http://lpaste.net/151381
18:44:44 * hackagebot Gifcurry 0.1.0.3 - Create animated GIFs, overlaid with optional text, from movies.  https://hackage.haskell.org/package/Gifcurry-0.1.0.3 (lettier)
18:46:59 <Gurkenglas> Oh hey lpaste-bot is back.
18:49:44 * hackagebot metadata 0.4.1.0 - metadata library for semantic web  https://hackage.haskell.org/package/metadata-0.4.1.0 (KatsutoshiItoh)
18:52:47 <mrlase> how would you guys make this look less like lisp? http://lpaste.net/4214751368633647104
18:53:02 <mniip> use $
18:53:37 <ReinH> Use (.)
18:53:49 <Gurkenglas> Use <$>
18:54:06 <mrlase> what does <$> do?
18:54:13 <Jinxit> infix fmap
18:54:18 <mniip> infix synonym for fmap
18:54:35 <monochrom> do { x<-a; return (f x) } = f <$> a
18:54:48 <mniip> yeah no, <$> won't help with readability much here
18:54:57 <mniip> it's parentheses you want to get rid of
18:55:08 <mrlase> ah okay
18:55:35 <ReinH> calculateBalance . map  entityVal . filter ((== mnth) . getL month . transactionDate . entityVal) <$> getTransactionsForCategory cid
18:55:47 <lpaste> Gurkenglas annotated “This shouldn't be lisp” with “This shouldn't be lisp (annotation)” at http://lpaste.net/4214751368633647104#a151525
18:55:57 <Gurkenglas> ninjad
18:56:03 <ReinH> extracting the filter predicate and giving it a name will also help
18:56:21 <ReinH> calculateBalance . map entityVal . filter correctMonth <$> getTransactionsForCategory cid
18:57:00 <ReinH> So yes, I think <$> will help.
18:57:12 <mniip> well yes, okay
18:57:25 <ReinH> I also note that you can factor out the map entityVal
18:57:33 <ReinH> since you do so for both the filter and the result
18:58:01 <ReinH> so calculateBalance . filter correctMonth . map entityVal <$> ...
18:58:58 <Gurkenglas> Does someone know why the lpaste browse function stopped updating the lists by author?
19:00:03 <mrlase> thanks for the help mniip ReinH :)
19:00:15 <Gurkenglas> :(
19:01:22 <dibblego> am I right that StandaloneDeriving requires the use of UndecidableInstances?
19:03:53 <mrlase> Gurkenglas: I didn't even notice that annotation
19:03:56 <mrlase> woop
19:03:58 <mrlase> woops
19:04:00 <mrlase> thanks :)
19:04:27 <geekosaur> dibblego, it shouldn't normally
19:04:34 <ReinH> dibblego: I believe only for certain forms, specifically ones that aren't allowed by the usual rules for inferred context.
19:04:57 <ReinH> FlexibleIntances may also be required for some forms
19:05:05 <dibblego> right
19:05:25 <dibblego> so, data T f = C1 (f Int) | C2; deriving instance Eq (f Int) => Eq (T f)
19:05:37 <monochrom> Gurkenglas: no, instead, I think the list is meant to not include some pastes by said author, e.g., when the paste or the paste's ancestor is "private"
19:05:51 <ReinH> dibblego: e.g., http://ghc.readthedocs.org/en/latest/glasgow_exts.html#inferred-context-for-deriving-clauses
19:06:09 <Gurkenglas> Nah I made loadsa public pastes under my name since then
19:06:22 <monochrom> I see. then I don't know
19:06:24 <ReinH> It isn't clear, but I believe UndecidableInstances is required for the third form.
19:06:45 <monochrom> but check that your paste's ancestors are also all public
19:06:48 <Gurkenglas> (Refering to http://lpaste.net/browse?author=Gurkenglas and, say, http://lpaste.net/150727 )
19:06:54 <dibblego> ReinH: ok thanks
19:07:13 <Gurkenglas> Ancestors? You mean what I was annotating? That example was no annotation.
19:07:24 <monochrom> right, ok I see
19:24:45 * hackagebot metadata 0.4.2.0 - metadata library for semantic web  https://hackage.haskell.org/package/metadata-0.4.2.0 (KatsutoshiItoh)
19:39:04 <xpxpxpxc> hello
19:45:02 <xpxpxpxc> I would like to work on gsoc ticket #1114 (Sandboxed Haskell) for gsoc
19:45:26 <xpxpxpxc> Would anyboy want to orient me?
19:45:32 <xpxpxpxc> *anybody
19:46:44 <xpxpxpxc> I see it's an oldt ticket
20:04:46 * hackagebot hleap 0.1.2.6 - Web Socket interface to Leap Motion controller  https://hackage.haskell.org/package/hleap-0.1.2.6 (BrianBush)
20:07:35 <mrmak> can anyone tell me why to learn haskell?
20:09:25 <scshunt> it builds character
20:09:33 <dfeuer> mrmak, it's a great way to burn time.
20:09:58 <Stratege> it makes you both want to go back to a different language and aware that you'll hate it when you go back.
20:10:21 <dfeuer> Also, it's fun. And, you know, practically speaking, refactoring Haskell code is easier than refactoring code in almost any other language....
20:10:41 <Stratege> so it's great if you are looking for a way to feel sad about the state of afairs
20:11:06 <nurupo> Stratege: tl;dr: hasskell will make you depressed
20:11:21 <Stratege> jup
20:11:30 <dfeuer> Now now, there are fun parts!
20:11:31 <caconym> mrmak: if you don't have a strong background in functional programming it'll make you see everything from a whole different perspective; it's truly mind-expanding
20:12:13 <mrmak> ok
20:12:23 <Stratege> dfeuer that's the problem. Haskell is a really great language. But also a serious pain to use at times. Especially when doing stuff that's not on the well trodden path.
20:12:33 <dfeuer> mrmak, one of the greatest Haskell concepts is the notion of actions as data.
20:13:01 <mrmak> then I'll learn
20:13:06 <caconym> Stratege is right though, learning it takes commitment and even once you "know" it, it can be irritating at times
20:13:21 <Stratege> (mainly because I refuse to just litter IORef everywhere and do the stuff I'd do in any other language)
20:13:23 <andromeda-galaxy> I've got a replacement Prelude with `(==) :: Eq a b c => a -> b -> c`, and using it seems to occasionally work but occasionally fail with 'Could not deduce (ghc-prim-0.4.0.0:GHC.Classes.Eq o)...', and GHCi (even with -XNoImplicitPrelude set, and the custom prelude loaded) thinks that `(==) :: Prelude.Eq a => a -> a -> Bool` (but oddly enough, :i seems to work).  Does anyone have any idea what might be going on?
20:13:40 <nurupo> mrmak: http://learnyouahaskell.com/chapters
20:13:48 <mrmak> thanks
20:13:51 <caconym> but it's so much more fulfilling than learning your n+1th python/ruby/whatever
20:13:59 <codebje> learning haskell has made me a better developer in other languages, by forcing me to look more closely at underlying abstractions and facing concepts you can handwave away elsewhere
20:14:00 <dfeuer> caconym, you mean like having to have a bunch of different types and classes to deal with "the same idea" at different arities? Yeah.
20:14:14 <geekosaur> andromeda-galaxy, there are other places that the standard Prelude can get dragged in. try -XRebindableSyntax for starters
20:14:28 <andromeda-galaxy> geekosaur: oops, sorry, I didn't mention it, but I've got that too
20:14:33 <geekosaur> (for example, if you have "f 0 = ..." somewhere then it is hardwired to the builtin)
20:14:36 <andromeda-galaxy> (part of my Prelude involves redefining ifThenElse)
20:14:38 <caconym> dfeuer: that and even dumber stuff, like having to deal with all the string types flying around everywhere
20:14:55 <geekosaur> do you import anything else?
20:15:14 <caconym> i don't mean to say there aren't good reasons for a lot of it, but coming from a more loose/permissive language it's a real change
20:15:17 <dfeuer> andromeda-galaxy, that sounds ... painful.
20:15:24 <andromeda-galaxy> geekosaur: hold on, let me double check
20:15:49 <Stratege> mrmak but in all seriousness. Haskell's great. And it's going to teach you a lot of stuff and as long as you can stomach working in an "inferior language" knowing haskell will generally help with writing in those languages. (Although you will very often run into those languages lacking basic features one get accustomed to in haskell. Like pattern matching. And not having that can be quite irritating)
20:15:59 <andromeda-galaxy> dfeuer: it's half painful and half really neat.  I think that there's a slightly better pain-to-neatness ratio than I would get from reading GHC Core though.
20:16:35 <dfeuer> caconym, what, you mean String and Text and lazy Text and ByteString and lazy ByteString and (though almost no one cares about it) Rope?
20:16:52 <andromeda-galaxy> geekosaur: it was importing Data.List, since this is supposed to be the module that I want to replace Data.List with, but I just took those lines out, and it's still not working...
20:17:13 <caconym> mrmak: that is true, for every thing that's more difficult in haskell there's a half dozen insanely useful abstractions from Haskell that you'll miss like a missing limb in other languages
20:17:27 <caconym> dfeuer: yeah that's exactly what I mean :)
20:17:42 <geekosaur> hm, we're about at my limit of what I know about it :(
20:18:06 <geekosaur> @paste it for others to look over, maybe (or url to gh repo or whatever)
20:18:06 <lambdabot> Haskell pastebin: http://lpaste.net/
20:18:24 <dfeuer> Stratege, I'm pretty spoiled by higher-rank types, scoped type variables, GADTs, and arbitrary-kind type classes. Hard to give that stuff up.
20:18:29 <Stratege> and a good part of the things that are more difficult in haskell could be done easily by just using IORef, unsafeCoerce, unsafePerformIO and the like (and thus basically "recover" the ways other languages do things)
20:18:42 <andromeda-galaxy> geekosaur: I'll try to extract a pastable example in a minute.  in the meantime, one more really weird thing:
20:19:04 <dfeuer> andromeda-galaxy, why do you want a different ==?
20:19:15 <andromeda-galaxy> dfeuer: it's complicated
20:20:01 <andromeda-galaxy> geekosaur: if I say 'foo :: Eq a b c => a -> b -> c; foo = undefined', and then ':t' it, ghci thinks that it's 'foo :: ghc-prim-0.4.0.0:GHC.Classes.Eq b => b -> b -> Bool'!
20:20:06 <dfeuer> Stratege, that's basically a lie. Using unsafePerformIO in a graph reduction machine just isn't the same as having (relatively) well-behaved side-effecting "functions".
20:20:11 <Stratege> dfeuer as is the ability to define control structure ... or simple stuff like sum types and pattern matching. or non-awful HOFs. Or syntactically non-awful partial application.
20:20:33 <nshepperd_> "Hey, this thing looks like it can be abstracted over an arbitrary Monoid! Oh, that doesn't work well in c++? Never mind then..."
20:20:40 <dfeuer> Stratege, that goes entirely without saying.
20:20:57 <scshunt> @src fix
20:20:57 <lambdabot> fix f = let x = f x in x
20:21:02 <andromeda-galaxy> nshepperd_: now I'm going to have to go write a C++ template library to allow Monoid abstractions just to find out if it ccan be done
20:21:09 <dfeuer> *barf*
20:21:34 <dfeuer> andromeda-galaxy, good luck. Please try to throw up only in the toilet.
20:21:43 <Stratege> dfeuer GHC's does not output a graph reduction machine and unsafePerformIO can be used in ways that are awful but "well behaved".
20:21:45 <geekosaur> heh
20:21:53 <Stratege> andromeda-galaxy it's possible.
20:22:10 <nshepperd_> I'd bet it can be done. But it'll look gross and be dog slow
20:22:23 * geekosaur has to deal with a C code base for $employer. threatens to rewrite in Haskell at least once a week...
20:22:31 <nshepperd_> great thing about ghc, your abstractions are inlined away with no effort
20:22:32 <Stratege> I wrote a little thing that gives a static monad class via templates, which is templated on both m and a
20:22:46 <andromeda-galaxy> dfeuer, Stratege: I'll not do that right now, I'm busy with a bunch of riduclously extensionful Haskell libarries (desigining, writing, etc.) nshepperd_: of course!  it might be useful to .0001% of people who are stck writing in c++ though
20:23:15 <dfeuer> Stratege, Haskell's operational semantics are based on graph reduction. GHC's optimizations make it a bit tricky to use unsafePerformIO in awful ways without shooting yourself in the foot. There are perfectly legitimate ways to use it, but those will not recover imperative programming.
20:23:17 <Stratege> tbh, it wouldn't be slow in C++. Well compile times might suffer.
20:23:49 <andromeda-galaxy> by the way, is it possible that if there's only one instance of a class in a given codebase ('instance Class1 a => Class2 a a Concrete', ghc internally rewrites certain terms from 'Class2 a b c => a -> b -
20:24:04 <andromeda-galaxy> > c' into 'Class1 a => a -> a -> Concrete'
20:24:05 <andromeda-galaxy> ?
20:24:06 <lambdabot>  <hint>:1:19: parse error on input ‘=>’
20:24:24 <andromeda-galaxy> (that wasn't meant for lambdabot)
20:24:39 <andromeda-galaxy> it seems a bit far fetched, but I can't figure out anything else that would cause this problem
20:24:45 <andromeda-galaxy> any ghc wizards here?
20:25:03 <Stratege> dfeuer eh, I suppose I haven't used it enough then, but I had a couple of cute cases with IORef manipulation and unsafePerformIO to have a counter of type Int or something close to that.
20:25:27 <dfeuer> andromeda-galaxy, can you paste some details somewhere, with the code and errors?
20:25:36 <geekosaur> andromeda-galaxy, might ask in #ghc. I think when you're working at this level, you probably need them...
20:25:54 <geekosaur> also consider asking on glasgow-haskell-users mailing list
20:26:13 <dfeuer> Stratege, it's easy to make something that seems to work, until you use it in some other context or something gets inlined and optimized some way you didn't expect, or or or, and then you're screwed.
20:26:37 <Stratege> dfeuer yeah well, to me that's part of certain imperative languages though :D (looking at you C! ^^)
20:26:44 <nshepperd_> STRefs serve most such purposes
20:28:01 <dfeuer> Stratege, not the same way. C isn't going to unexpectedly perform an action twice, or skip it altogether, unless there's a compiler bug.
20:28:35 <dfeuer> unsafePerformIO takes real care.
20:29:15 <Stratege> afaik unsafePerformIO can not run actions twice. That's what unsafeDupablePerformIO is for. Also a NoInline is a good idea, yeah.
20:29:26 <geekosaur> (gcc has had several such bugs, especially early 4.9)
20:29:43 <monochrom> I finally recall why I learned Haskell. I was studying formal methods, the imperative ones at first. But later I looked at the functional ones, Richard Bird's stuff specifically, and that set me on a collision path with Haskell.
20:29:44 <geekosaur> (cue loud screaming on lkml)
20:29:51 <caconym> is there any general application of unsafePerformIO besides "print statement debugging" that's generally considered acceptable? I've never felt like I had to use it
20:30:05 <Stratege> gcc also did the "optimizing code away" thing on purpose in some cases when you had undefined behaviour in some way in your code
20:30:44 <Stratege> caconym I'd suggest looking at some of edwardk's code. He sometimes gets rather creative with the unsafe* and I'd assume that he knows what he's doing.
20:31:12 <dfeuer> caconym, yeah, it's used in several FRP frameworks (deep magic code). And yeah, I was going to mention Ed.
20:31:15 <caconym> ha, understatement of the year award
20:31:49 <Stratege> reallyUnsafePointerEquality is still my favorite name for a function.
20:32:27 <nshepperd_> unsafeCoerce is frequently useful for constructing typeclass dictionaries
20:32:33 <caconym> it's really quite cool that I've been able to do practical work with Haskell without ever resorting to unsafe*, actually
20:32:45 <nshepperd_> that's an explicit case of telling the type system you know better
20:33:13 <Stratege> dfeuer oh! there's stuff even worse than abusing unsafe though... I read the spec on rules pragma recently and started experimenting ( http://christian-fania.de/blog/FunWithRULES.html )
20:33:22 <Stratege> turns out one can do compile time programming via rules.
20:33:25 <nshepperd_> well, 'frequently' if you use -XDependentHaskell all day
20:33:35 <andromeda-galaxy> geekosaur: I've got to go for now, but later I'll try to build a little minimal example; I'll link to the lpaste from here and in #ghc
20:33:36 <Stratege> it's really brittle, really awful and in direct violation of the manual.
20:33:42 <Stratege> but it can be done!
20:33:45 <andromeda-galaxy> nshepperd_: -XDependentHaskell exists?
20:33:53 <monochrom> caconym: creating a global IORef or TVar is one acceptable use of unsafePerformIO (but first you have to justify that your global var is acceptable and strongly necessary)
20:34:14 * nshepperd_ checks
20:34:20 <dfeuer> unsafeCoerce doesn't scare me nearly as much as unsafePerformIO, TBH.
20:34:38 <nshepperd_> andromeda-galaxy: nope, still a joke :)
20:35:15 <caconym> monochrom: interesting, I never thought to do that but I can see how it might be better behaved than some of the alternative uses
20:35:23 <monochrom> there is another acceptable use in the context of FFI, in which one of the FFI tools is in IO just for being paranoid, such that most use cases are actually pure.
20:35:32 <andromeda-galaxy> nshepperd_: oh ok, never mind.  Looking forward to -XTypeInType though, the wiki says that part of it should be out later this month (as far as I can tell)
20:35:35 <geekosaur> -XDependentHaskell is spelled "agda" in the real world
20:35:40 <dfeuer> Stratege, that RULES stuff looks rather foolhardy. If the rules engine runs out of steam early, you lose.
20:35:40 <geekosaur> :p
20:35:52 <dfeuer> Or, of course, if your rules don't fire for any of *many* reasons.
20:36:18 <nshepperd_> unsafeCoerce is more likely to gift you with a SIGSEGV or a nonsensical value than literally launching the missiles, it is true
20:36:53 <dfeuer> monochrom, that global IORef thing gives me the heebie jeebies. I want to fix that at the module level.
20:36:59 <Stratege> dfeuer oh I'm aware. I wouldn't ever do this for any reason other than just having fun and seeing what can be done. note the use of undefined as the base function. this results in the least helpful error message - if anything goes wrong at all, all the program compiled to is "main = undefined"
20:37:36 <dfeuer> Fun.
20:38:02 <Stratege> yeah, I play around with stuff and see how far down the abyss I can take things for fun.
20:38:27 <dfeuer> nshepperd_, I may be a bit twisted, but I think it's fun to coerce between ADTs and GADTs with the same numbers and arities of constructors :-)
20:38:41 <dfeuer> (and orders)
20:39:03 <nshepperd_> although being able to create Word8s with a value of 175511086 seems like it could impact missile launching outcomes
20:39:09 <monochrom> yes, isJust can be done by unsafeCoerce from Maybe a to Bool
20:39:30 <dfeuer> monochrom, that's much nastier than what I meant.
20:39:39 <Stratege> ... that's awful and cool.
20:39:55 <shachaf> But that Bool won't allow the Just pointer to be garbage-collected.
20:39:58 <monochrom> I think we even have...
20:40:11 <monochrom> @quote Just.*unsafeCoerce
20:40:12 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
20:40:34 <shachaf> @quote isTrue
20:40:34 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
20:40:42 <shachaf> Hmm, that works too.
20:41:29 <monochrom> I forgot my Rube Goldberg machine :)
20:41:47 <dfeuer> I meant   data GMaybe (t :: Bool) a where {GNothing :: GMaybe i a; GJust :: {fromGJust :: a} -> GMaybe 'True a}.  unsafeFromJust :: Maybe a -> a; unsafeFromJust m = fromGJust (unsafeCoerce m)   [Approximately]
20:43:05 <dfeuer> If you pass it a Nothing, things blow up in peculiar ways.
20:43:10 <monochrom> right, you just want to do type erasure before the compiler does type erasure
20:44:23 <monochrom> I heard you like type erasure so much, I give you unsafeCoerce so you can erase types before the compiler erases types
20:45:49 <dfeuer> Stratege, I love how you get down to just one helper in that RULES thing.
20:47:45 <Stratege> dfeuer a friend pointed out that I could actually get down to 0 via using undefined :D but I stuck with a short one for typing. Also I'm working on a follow up blog post to show that the whole thing's turing complete without calling haskell functions :3
20:48:44 <Stratege> (and there is only one data type necessary: "data Foo = forall a. Show a => Foo a" (for lack of better name, showable is too long to always use. And the Show a constraint is just so I can print the result in the end)
20:48:59 <monochrom> oh my god, TH inside RULES?!
20:49:03 <Stratege> (also that gives me the ability to pattern match on the type, essentially ^^)
20:49:07 <Stratege> yes. TH inside rules.
20:49:34 <monochrom> this is totally "the product is bigger than the sum"
20:49:39 <Stratege> RULES allow a lot of things. And I feel like it's entirely underappreciated in general.
20:50:28 <nshepperd_> hmm, `let fmap = unsafeCoerce :: Functor f => ((a -> b) -> f a -> f b) in fmap (+1) [1, 2, 3]` crashed my ghci
20:50:39 <nshepperd_> I must not remember how this works
20:51:18 <exio4> you might want a wrapper
20:53:18 <dfeuer> nshepperd_, you might also be forgetting about (<$)
20:54:12 <dfeuer> That will screw you up pretty badly, because a class with superclasses and/or more than one method will not work so nicely (at all) with that unsafeCoerce trick.
20:55:06 <Stratege> I like that the topic started with "why learn haskell" and now is in the paths that should be taken with care / not at all ^^
20:55:22 <nshepperd_> oh, functor isn't actually single method
20:55:28 <nshepperd_> that explains it
20:57:29 <nshepperd_> This is why you should learn haskell.
20:57:38 <lpaste> EXio4 pasted “unsafeCoerce + type class” at http://lpaste.net/151530
20:58:01 <exio4> nshepperd_: ^ working (GHC7.8) code
20:58:02 <nshepperd_> You get so sick of your code working correctly all the time that you do your best to break it
20:58:30 <exio4> that's a good one :D
21:02:47 <Stratege> nshepperd_ oh if only ^^
21:03:25 <artemis> how would I go about running the following reader and passing my config to it? http://lpaste.net/151532
21:09:51 <pavonia> artemis: Isn't there a runScottyT or so?
21:12:18 <artemis> pavonia, checking now
21:12:57 <artemis> pavonia, doesn't seem to be as far as I see
21:13:54 <kadoban> artemis: What do you actually do ever with a ScottyT, or a Scotty for that matter, I assume that exists?
21:13:56 <pavonia> There seems to be runS :: State (ScottyState e m) a, but that type is slightly confusing to me
21:14:27 <pavonia> Err, runS :: ScottyT e m a -> State (ScottyState e m) a
21:14:48 * hackagebot mmorph 1.0.6 - Monad morphisms  https://hackage.haskell.org/package/mmorph-1.0.6 (GabrielGonzalez)
21:15:19 <artemis> well I was just trying to pass my config to the app as a ReaderT
21:17:30 <scshunt> artemis: normally you wouldn't put the concrete type into the application's type
21:18:16 <artemis> scshunt, I do have it aliased in the application this was just an easy way to show what I was trying to get at
21:18:20 <scshunt> you'd do something more along the lines of (MonadScotty Text m, MonadReader Config m, MonadIO m) => m ()
21:18:39 <artemis> I am an idiot I figured it out
21:18:43 <artemis> It was actually pretty simle
21:19:04 <artemis> the runR function should should of been runR a = runReaderT a config
21:25:23 <Welkin> tromp: tell your borther Trump that he is a bastard
21:25:28 <Welkin> brother*
21:28:28 <scshunt> where did the convention of using co- originate?
21:28:49 <Welkin> co-pilot?
21:29:01 <Welkin> you mean in math? or in the english language?
21:29:02 <Stratege> I'd blame mathematicans.
23:19:51 * hackagebot werewolf 0.4.0.0 - A game engine for running werewolf in a chat client  https://hackage.haskell.org/package/werewolf-0.4.0.0 (hjwylde)
23:30:13 * hackagebot yesod-newsfeed 1.6 - Helper functions and data types for producing News feeds.  https://hackage.haskell.org/package/yesod-newsfeed-1.6 (MichaelSnoyman)
23:54:49 <pavonia> Are orphan instances the reason why package developers tend to stuff all possible package dependencies into a single package?
23:56:02 <pavonia> e.g. the Aeson package seems to depend on a lot of packages only to have a wide range of FromJSON/ToJSON instances
23:59:34 <phadej> pavonia: actually aeson uses all of those
