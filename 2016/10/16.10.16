00:00:46 <fred-fri> so why is the >>= style preferable to the do style in this case? when should either be used?
00:01:07 <calloc> What is the common method for viewing hackage docs from the command line?
00:01:36 <lpaste> taktoa pasted “splitStmtsStraight-cleaner.hs” at http://lpaste.net/267287
00:01:49 <taktoa> grantwu: how do you feel about that ^
00:02:06 <grantwu> taktoa: Hrm... it's pretty good
00:02:31 <taktoa> I don't think there's any pattern matching magic you can do to fix the redundancy without changing your data model
00:02:33 <grantwu> yeah, more syntactic sugar to support this kind of thing is probably excessvie
00:02:36 <grantwu> yeah
00:03:40 <taktoa> oh, woops, you should probably rename the variable `x` in the definition of consStraights since it shadows the `x` in the surrounding scope
00:04:02 <taktoa> grantwu: though if you're compiling with ghc -Wall it should warn you about that
00:04:26 <grantwu> So I decided to change the data model q.q
00:04:38 <grantwu> Something like 600 lines of code depends on this data type
00:06:25 <taktoa> grantwu: btw you may want to look into recursion schemes and/or lenses if you're writing haskell "seriously" (i.e.: not as a beginner project or school assignment); they can make it cleaner to write this kind of code (sometimes at the cost of readability)
00:07:03 <grantwu> This is technically for a school assignment :P
00:07:45 <grantwu> I'm still kind of new to Haskell, so I'm trying to reduce the amount of stuff to learn
00:09:31 <amalloy> what kind of school assignment for a new haskeller involves 600 lines of code?
00:10:29 <grantwu> amalloy: Write an optimizing compiler for a safe subset of C in a semester...
00:11:05 <grantwu> (with a partner.)
00:12:40 <grantwu> I mean, they don't say you have to Haskell.  They also provide starter code for OCaml and Java.
00:12:50 <grantwu> (they disadvise using Java)
00:13:09 <MarcelineVQ> wow ambitious, pretty cool though
00:13:26 <grantwu> it eats my life! http://www.cs.cmu.edu/~janh/courses/411/16/
00:15:09 <ongy> I love the rooms name
00:21:51 <Zemyla> Man, I can't wait for actual dependent-typed Haskell, so I can have a typesafe eval function.
00:22:08 <Zemyla> Like, eval "return 1" has a type of (Monad m, Num a) => m a.
00:32:04 <fred-fri> my god I feel like such a genious right now http://pastebin.com/Hp03ieUC
00:33:37 <fred-fri> though there has to be a more elegant way of getting multiple ints, no? something that just repeats readLn a given number of times and tacks it on to a given list?
00:34:25 <Maxdamantus> sequence $ replicate n readLn
00:35:17 <fred-fri> that function was provided by hackerrank
00:35:25 <fred-fri> seems like their haskell challenges don't get too much love
00:36:29 <ongy> it's just the simple easy to understand version. Hankerrank can be nice to learn since it gives small challenges. so using the most elegant might be confusing for users
00:36:38 <MarcelineVQ> good job fred-fri! if you're just after tersness one option is (`replicateM`(readLn :: IO Int)) replicateM is from Control.Monad
00:37:33 <grantwu> Hrm... I have a list of statements and blocks which can contain more statements
00:38:16 <grantwu> basically, data Code = S Stmt | Block [Code]
00:38:32 <grantwu> How do I flatten this efficiently?
00:39:06 <grantwu> a bunch of takeWhiles?
00:40:32 <lyxia> flattenCode (S s) = [s] ; flattenCode (Block b) = b >>= flattenCode
00:40:47 <grantwu> :o
00:41:48 <grantwu> Is that inefficient because it boxes and unboxes single statements?
00:41:57 <grantwu> er rather
00:42:07 <grantwu> How much does that cost?
00:43:02 <grantwu> I think this is premature optimization
00:43:17 <lyxia> it is
00:47:18 <fred-fri> MarcelineVQ, that looks great, intuitively this looks to me like it should work but doesn't, what am i missing? main = readLn >>= replicateM . readLn >>= print . Data.List.sum
00:50:23 <MarcelineVQ> replicateM takes two arguments, a number of times to perform an action and an action to perform, it'd probably be easiest to rewrite that like: main = readLn >>= \n -> replicateM n readLn >>= print . Data.List.sum
00:51:24 <fred-fri> mind blown
00:52:16 <fred-fri> how will i be able to go back to my regular java gig on monday, after seeing this?
00:53:19 * hackagebot staversion 0.1.0.0 - What version is the package X in stackage lts-Y.ZZ?  https://hackage.haskell.org/package/staversion-0.1.0.0 (debugito)
00:53:21 * hackagebot yaml 0.8.19.0 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.19.0 (MichaelSnoyman)
00:54:35 <grantwu> fred-fri: Time to start looking for Haskell jobs? :P
00:54:55 <fred-fri> main = readLn >>= \n -> replicateM n readLn >>= print . Data.List.sum. It's terse, clear and declarative at the same time. Usually when something is terse it's also incomprehensible.
00:55:38 <grantwu> Well, to be honest
00:55:43 <grantwu> I have no idea what the hell that does
00:56:10 <fred-fri> it could use a comment
00:56:28 <grantwu> oh, it reads a line... is the first line the number of lines?
00:56:49 <MarcelineVQ> It's pretty readable to me, if it get smuch longer though it won't be, do notation can help if it gets much larger, and also gives more space for comments
00:56:56 <grantwu> then it reads n more integers?
00:57:01 <grantwu> then prints their sum?
00:57:18 <fred-fri> readLn how many Ints should go into a list. replicateM readLine n times. print the sum of the ints in the list.
00:58:12 <grantwu> How do you get away without annotating the output of readLn?
00:58:29 <MarcelineVQ> :t sum
00:58:31 <lambdabot> (Foldable t, Num a) => t a -> a
00:59:05 <MarcelineVQ> oop, I forgot that's Num not Int, ghci is defaulting it perhaps
00:59:10 <ongy> but to be honest, for "real" code it would be a bit more complicated for error handling or performance reasons
00:59:24 <fred-fri> yeah this is just for a hackerrank challenge
00:59:28 <ongy> lambdabot defaults it to Integer. if compiled with -Wall that should also give a warning with GHC
01:00:14 <grantwu> Yeah, I guessed there must have been type defaulting happening somewhere...
01:00:35 <puregreen> grantwu: replicateM's first argument must be an Int so the first readLn has to be IO Int
01:00:47 <Athas> I've had some nasty experiences where GHC 8.0.1 seems to hang on type errors.  Has anyone else experienced this?
01:00:50 <puregreen> the second one is resolved through defaulting, yeah
01:03:05 <Cale> Athas: I haven't seen that... what extensions are you using?
01:03:35 <Athas> Cale: in the module that fails, FlexibleContexts and TypeFamilies.
01:03:55 <Cale> hmm... that's pretty benign, I'd expect
01:03:57 <Athas> But it's not an exotic error.  A missing argument to a value constructor.
01:04:04 <Cale> hmm
01:04:21 <Cale> Probably best to report it
01:04:59 <Athas> I will see if I am able to isolate the problem, but probably not.  The program is a whole is over 36000 SLOC.
01:11:36 <grantwu> Sigh.
01:11:46 <grantwu> Maybe I need a new laptop
01:12:13 <grantwu> Third time in 2 days I've had to kill ghc-mod to free up memory
01:23:57 <TommyC> Could be that ghc-mod isn't freeing the memory when necessary?
01:29:08 <grantwu> Possibly?  I don't really know how to debug this because by the time I notice, my system has ran out of memory and I lose interactivity
01:29:14 <grantwu> I end up switching to a text based console
01:29:25 <grantwu> It's also partially due to Chrome
01:30:25 <ongy> chrome liks to hog memory. For ghc-mod I would asume it's similar to hdevtools, that there's a ghc (the library) instance in memory that keeps all modules to speed up later operation. Which will increase the memory footprint for every module used by that instance
01:31:35 <grantwu> Yeah, it doesn't help that I'm using Atom :/
01:32:09 <grantwu> I'm not super happy with it, but I don't have time to futz with configuring Vim and learning all the keyboard commands
01:32:32 <grantwu> and Intero looks cool, but I don't want to learn emacs or configure evil mode.  Plus it looks like Intero uses chording commands anyways
01:33:18 <grantwu> Besides the resource usage, the ide-haskell plugin also has an issue where it seems to highlight incorrect lines in the wrong place
01:33:41 <ongy> I think intero is the emacs haskell integration. I'm using hdevtools with vim, and should get around neko-ghc at some point
01:34:01 <grantwu> It seems like it's taking the info from ghc-mod, and applying it to the screen position from the pre-saved file
01:34:15 <grantwu> So I have to write twice to get the highlights in the right place
01:38:00 <srk> is there a namespace browser for packages available on hackage?
01:46:12 <srhb> srk: What is a namespace?
01:47:09 <srk> srhb: module hierarchy
01:47:33 <srhb> srk: Ah. I don't think such a thing exists, especially since it's not a true hierarchy.
01:47:46 <srhb> (THough of course that doesn't make it impossible to construct.)
01:47:58 <srk> yup. would be nice
01:48:32 <srhb> I doubt it'd be very useful though. ;-)
01:48:43 <fr33domlover> srk, if you `stack haddock` some packages you can view all the modules in a single hierarchy
01:48:59 <fr33domlover> but dunno if such a thing exists for the entire hackage/stackage
01:49:19 <srk> maybe I'll try to put something together :)
01:49:44 <srk> such browser would be nice for discovering new libraries
02:02:58 <puregreen> for Stackage there's https://www.stackage.org/lts-7.4/docs (also see https://www.stackage.org/haddock/lts-7.4/frames.html) but it's a list, not a tree
02:03:10 <puregreen> srk: ^
02:03:54 <srk> puregreen: nice! thanks
02:18:34 <rgc>  Ĺ
02:18:43 <rgc> sorry
02:30:05 <puregreen> how to traverse all Exps in a TH Exp?
02:31:12 <puregreen> I know it can probably be done with pretty much any generics library, but is there some “standard” way to do it?
02:34:21 <joncol> I'm watching SPJ lens tutorial and I just got stuck on a simple (?) point-free transformation he did: set :: Lens' s a -> (a -> s -> s); set ln x = runIdentity . ln (Identity . const x) How is this the same as: set ln x s = runIdentity (ln t s) where t = const (Identity x) ?
02:35:04 <joncol> I'm confused by the switching in order of Identity and const in the first version?
02:36:44 <lyxia> joncol: Identity . const x = \y -> Identity (const x y) = \y -> Identity x = \y -> const (Identity x) y
02:43:59 <joncol> lyxia: Thanks, I'll have to think on that :)
02:53:22 * hackagebot sibe 0.1.0.1 - Machine Learning algorithms  https://hackage.haskell.org/package/sibe-0.1.0.1 (mdibaiee)
02:53:31 <oxcsh> Hello. Is there a way to compare two floats for equality, such that e.g. NaN is equal to NaN?
02:54:30 <benl23> NaN is never equal to NaN, by definition
02:55:50 <cocreature> oxcsh: you can always define your own equality function that uses whatever equality you define. if you need an Eq instance you can create a newtype and define the instance on that
02:56:26 <puregreen> oxcsh: you can use isNaN to write such a comparison function by yourself
02:56:50 <oxcsh> ben123: Yes, normally, but I want a reflexive equality for property testing. I was wondering if there is a built-in Haskell that does this.
02:57:12 <geekosaur> no, Haskell like pretty much every other language obeys IEEE754
02:57:41 <oxcsh> *built-in Haskell function
02:58:10 <oxcsh> Thanks puregreen, I think I will just define my own using isNaN.
02:59:06 <geekosaur> note that you can't even cheat and compare the underlying bits, because the bit representation of a NaN carries debugging information that may differ between NaNs
03:00:07 <oxcsh> ah, I didn't know that
03:00:11 <oxcsh> thanks :-)
03:00:12 <geekosaur> (IEEE754 specifically permits this; Intel FP hardware does so.)
03:02:30 <oxcsh> puregreen: it worked, thanks
03:20:23 <gargawel> Is there a way to document /kind/ signatures in Haddock ? (case in point: documenting an associated data type in a typeclass declaration)
03:21:34 <gargawel> I would like to document arguments of the type constructor
03:21:54 <gargawel> (much like function arguments can be individually documented)
03:52:40 <runeks> Is there a type of in-memory socket, which you create as a pair, and what's written on socket 1 can be read on socket 2, and what's written on 2 is read on 1? I'm unclear on whether any of the various (STM) channel types can be used for this purpose.
03:53:23 * hackagebot phaser 0.2.0.0 - Incremental multiple pass parser library.  https://hackage.haskell.org/package/phaser-0.2.0.0 (quick_dudley)
03:53:25 * hackagebot jsaddle-dom 0.5.0.0 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.5.0.0 (HamishMackenzie)
03:53:27 * hackagebot ghcjs-dom-jsaddle 0.5.0.0 - DOM library that supports both GHCJS and GHC using jsaddle  https://hackage.haskell.org/package/ghcjs-dom-jsaddle-0.5.0.0 (HamishMackenzie)
03:53:29 * hackagebot ghcjs-dom-jsffi 0.5.0.0 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.5.0.0 (HamishMackenzie)
03:53:31 * hackagebot ghcjs-dom 0.5.0.0 - DOM library that supports both GHCJS and GHC  https://hackage.haskell.org/package/ghcjs-dom-0.5.0.0 (HamishMackenzie)
03:55:07 <unit73e> hey. say I want to do multiple concurrent subversion 'ls' recursively. How would you do it?
03:55:41 <unit73e> in python I would use a pool with N threads and a thread safe queue but I have no clue if there's a better way in haskell
03:58:23 <ongy> you could forkIO your tasks ans have the RTS manage the threads (compile with threaded and maybe rtsopts), but I think that will interleave the tasks
04:00:27 <unit73e> RTS is like a pool?
04:02:31 <unit73e> let me rephrase that :p if I pass threaded N will only N threads run simultaneously at a time?
04:03:03 <unit73e> because I don't think it's a good idea for the many threads to be spawned because of multiple 'ls'
04:17:00 <Toxaris> unit73e: only N operating system threads will run at the same time, but the run-time system will happily schedule more than N Haskell threads on theses operation system threads
04:17:53 <Toxaris> and I think all of them would be able to start the external process and then block, so more than N external processes can be started, which is not what you want
04:19:05 <unit73e> Indeed. Thanks Toxaris and ongy. Maybe there's a queue or something. It would be the same thing I would do on python but the code may be more concise.
04:19:45 <Toxaris> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Concurrent-QSem.html
04:20:05 <Toxaris> I think this or something similar is what you want, unit73e 
04:20:25 <unit73e> y that will work. thanks.
04:20:42 <Toxaris> there are some notes in the implementation, if you want to learn how to build abstractions like this yourself: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Control.Concurrent.QSem.html#QSem
04:32:14 <ruski> hi all! only started with haskell and i've run into a memory problem. coming from C, i'd be inclined to work with arrays instead of lists for the purpose of reducing the memory usage of my code. is there a good reference for this? do the arrays libraries support analogs to list functions?
04:33:19 <boothead> ruski, maybe have a look at the vector package?
04:34:28 <ruski> indeed, vectors from what i read are even more efficient than arrays
04:34:44 <amx> also, I suggest you try profiling first
04:39:57 <amx> when using huge amounts of memory you may have a speak leak
04:42:46 <flxw> /quit
04:42:47 <flxw> [Sat Oct 15 2016]
04:42:47 <flxw> ** Topic for #haskell: https://www.haskell.org |
04:42:47 <flxw>    https://wiki.haskell.org/IRC_channel | Paste code/errors:
04:42:48 <flxw>    http://lpaste.net/new/haskell | Logs:
04:42:51 <flxw>    http://tunes.org/~nef/logs/haskell/?C=M;O=D
04:42:56 <flxw>    http://ircbrowse.net/day/haskell/today?mode=recent |
04:42:59 <flxw>    https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic:
04:43:02 <flxw>    #haskell-offtopic | Hackage status? https://status.haskell.org |
04:43:05 <flxw>    https://downloads.haskell.org				        [18:06]
04:43:06 <maerwald> flxw: fix your irc client
04:43:08 <flxw> ** #haskell: topic set by glguy, 2016-08-06 02:41:47
04:43:32 <flxw> ** Users on #haskell: 7ITAAABAS APic Adeon Adios Akii AlainODea Amadiro
04:43:33 <flxw>    Amun_Ra Ankhers AntiSpamMeta AppleJacks24 Arguggi Askanison Athas
04:43:33 <flxw>    Atomic_iCvbz AustinMatherne Axman6 Bane^ Baughn Belgarion0 Bengi__
04:43:33 <flxw>    Benzi-Junior Bez_ Big_G Biohazard_ Blkt Boomerang Boreeas Borkr
04:43:35 <flxw>    Brando753-o_O_o BrianHV_ CARAM__ Cassiopaya Cathy Cerise Cetusx @ChanServ
04:43:37 <ongy> nooo
04:43:39 <flxw>    Chobbes ChongLi Chousuke CindyLinz ClaudiusMaximus Clint CoconutC1ab
04:43:42 <flxw>    ContessaTP CosmicRay CurryWurst DANtheBEASTman DDR Deadhand
04:43:43 <maerwald> @ops
04:43:43 <lambdabot> Maybe you meant: pl oeis docs
04:43:45 <flxw> ** Users on #haskell: Deewiant Deide Desoxy Diabolik Digit DigitalKiwi DrCode
04:43:48 <flxw>    Drezil DustyDingo Dykam Eagle_Erwin Edoxile Eliel Elision Elsi Erlkonig
04:43:50 <maerwald> @op
04:43:50 <lambdabot> Maybe you meant: yow wn v rc pl id do bf @ ? .
04:43:51 <flxw>    EvanR EvilMachine Ewout Ezku_ Factionwars Fairy Faleidel[m] FjordPrefect
04:43:55 <ongy> @where ops
04:43:55 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
04:44:07 <ongy> but this will highlight all of them either way
04:44:10 <maerwald> lol
04:44:18 <Fairy> flxw hm?
04:51:32 <ruski> profiling already done :) 12GB of memory is allocated for a 30MB file. holy shit.
04:52:44 <ruski> though on the machine that i'm running it on with 1GB of memory doesn't die.
04:54:07 <Toxaris> ruski: that is not (only) because of list vs. array
04:54:48 <ruski> oh i can imagine. i'm imagining that there probably is a much cleverer way of doing what i'm trying to do
04:55:13 <Toxaris> ruski: are you sure you're measuring the right thing? 12GB sounds more like overall allocation to me, not peak memory size
04:55:44 <Toxaris> what are you trying to do?
04:55:50 <ruski> the 12GB thing is what i read from the .prof file
04:57:24 <ruski> from a text file, i'm separating it line-by-line, then grouping each line into a list with the number of occurrences, then dropping each group with >1 occurrence
04:58:25 <ruski> i guess the deign of it is shit, since it goes String -> [[String]] -> [[(Int), String]] -> [[String]] -> [String] -> String
04:58:26 <Toxaris> Use Data.Text for the strings, Data.HashMap for the data structure
05:00:53 <ruski> in one line: unlines $ concat $ map snd $ filter ((==1).fst) $ zip (map length (group . sort $ lines text)) (group . sort $ lines text)
05:00:56 <bollu> so I've been re-encoding coontinuations for myself 
05:00:59 <bollu> and while I can do it
05:01:13 <bollu> it still takes a minute to think of the way the types fit together
05:01:32 <bollu> unlike, say, implementing Applicative/Monad for some of the other types
05:01:41 <bollu> is there a very "natural" way to derive this?
05:02:22 <lpaste> bollu pasted “continuations-encoded” at http://lpaste.net/150323077970919424
05:02:30 <bollu> ^ that's me so far
05:02:49 <Fairy> How would I go about making           newtype Context = Context (String -> Maybe Integer)         to be part of the Ord and Eq classes?
05:03:14 <bollu> Fairy: what notion of Eq do you want to have on that?
05:03:30 <ruski> thanks Toxaris i'll see what i can do with those
05:03:44 <ongy> Fairy: do you want it for that one specifically or in general?
05:05:59 <Toxaris> Fairy: if your Context encodes a finite map, consider Data.Map or Data.HashMap
05:06:21 <Fairy> sorry, I'm having difficulties formulating what I want :S
05:06:36 <Toxaris> (hmm, everyone, consider Data.Map or Data.HashMap. They exist. In Haskell).
05:09:08 <Fairy> I have   data Stt = Number Integer | Name String | Block [Stt] | ... deriving (Eq, Show, Ord)   and I need to add Function String Stt Context, but that won't work because Context is only part of the Show class
05:09:12 <lyxia> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
05:09:13 <lambdabot> f a b c = a (\ d -> b d c)
05:09:32 <lyxia> bollu: ^ ?
05:10:14 <latro`a_> fairy, is a Context partial or total?
05:10:16 <bollu> lyxia: yes, but, like, how does that make intuitive sense to you?
05:10:22 <latro`a_> in particular, is its true domain finite?
05:11:03 <latro`a_> if not then I don't see why Eq would make any sense
05:11:49 <Fairy> latro`a_ I'm not 100% sure if I understand that question, but given that Context is a function, the domain is infinite?
05:12:32 <latro`a_> Fairy, the type String is of course infinite, but it could be that you only have finitely many strings in mind. In that case you could use Data.Map to "encode" such a function in a way that would permit Eq
05:12:42 <Toxaris> Fairy: but will it really do something interesting for every possible string, or will it just return Nothing for most strings, and only return (Just ...) for a finite set of strings?
05:13:04 <latro`a_> Fairy, or, alternately, it could be total, but return Nothing for all but finitely many strings
05:13:47 <ofirhas> hi guys
05:13:49 <latro`a_> and if you *know* that it willl return Nothing for all but finitely many strings then you can simply check the strings that might not return Nothing, which lets you do an Eq check again
05:13:50 <Toxaris> bollu: to make sense of f a b c = a (\ d -> b d c), first eta-expand and rename continuations to k
05:13:57 <Fairy> The Strings will be finite, if a string wasn't put in, it isnt there
05:14:06 <ofirhas> i'm having a problem with making my data a member of monad
05:14:20 <ofirhas> hope one of you can help
05:14:27 <Toxaris> bollu, oh wait, no eta expansion, since c *is* the k. see what I mean
05:14:48 <ofirhas> so i;m trying to build a lottery game just to kearn haskell
05:14:52 <ofirhas> learn*
05:14:56 <latro`a_> Fairy, what? we're talking about trying to make a notion of Eq for String -> Maybe Integer. I'm asking you what collection of strings you're expecting to insert in there
05:15:15 <ofirhas> this is my data definition :
05:15:19 <ofirhas> data Lotto a = Fail | Valid String [a]
05:15:39 <ofirhas> this is how i make it a member of functor
05:15:40 <Toxaris> bollu: f a b k = a (\d -> b d k)
05:15:42 <ofirhas> instance Functor Lotto where     fmap f Fail = Fail     fmap f (Valid name xs) = Valid name (map f xs)
05:15:54 <Toxaris> bollu: now let's rename a and d to show how they are related
05:16:20 <Toxaris> bollu: f a_action b k = a_action (\a_result -> b a_result k)
05:16:26 <Fairy> latro`a_ Sorry, but I don't quite understand what you're asking of me :S
05:16:29 <ofirhas> instance Functor Lotto where
05:16:34 <bollu> :t callCC
05:16:35 <ofirhas>     fmap f Fail = Fail
05:16:35 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
05:16:39 <ofirhas>     fmap f (Valid name xs) = Valid name (map f xs)
05:16:53 <ongy> @lpaste -- ofirhas your code is getting a bit long and mixed up for irc messages
05:16:53 <lambdabot> Haskell pastebin: http://lpaste.net/
05:17:09 <ofirhas> and this is how i fail to configure it as a data member of monad
05:17:11 <ofirhas> :
05:17:23 <ofirhas> instance Monad Lotto where
05:17:28 <ofirhas>     return x = Valid getRandomName $ take numbersOfGuesses $ repeat x
05:17:31 <Toxaris> bollu: at this point, the code is intuitive to me: to feed the result of a_action to b and then continue with k, we run a_action, get an a_value, and feed that one to b and ask b to continue with k for us
05:17:33 <ofirhas>     Fail >>= f = Fail
05:17:45 <ofirhas>     (Valid name xs) >>= f = Valid name (map getFirstOfEach (map getGusses (map f xs)))
05:18:20 <ongy> Fairy: the problem is, that functions are blackboxes for us in haskell. We can put things in and observe the output, but that's pretty much it. So a general Eq instance for Context as is isn't really possible to define. And for Ord I have no idea how it would even work 
05:18:22 <ofirhas> getGusses :: (Lotto a) -> [a]
05:18:32 <ofirhas> getFirstOfEach :: [[a]] -> [a]
05:18:46 <ofirhas> aaa\naaa
05:19:16 <latro`a_> Fairy, you're trying to make an Eq instance for String -> Maybe Integer. There is no "automatic" instance because although we can test equality for Maybe Integers, there are infinitely many Strings. But it could be that your Contexts have some finite set of strings on which they don't return Nothing, and such that you can tell the computer how to find it (or a finite superset of it). In that case *those particular functions
05:19:16 <latro`a_> * will have a meaningful sense of Eq
05:19:17 <ofirhas> lotto.hs:33:61: error:     * Couldn't match type `b' with `[a0]'       `b' is a rigid type variable bound by         the type signature for:           (>>=) :: forall a b. Lotto a -> (a -> Lotto b) -> Lotto b         at lotto.hs:32:10       Expected type: [[[a0]]]         Actual type: [[b]]     * In the second argument of `map', namely         `(map getGusses (map f xs))'       In the second argument of `Valid', namely         `(map
05:19:30 <Toxaris> ongy: well, you can have partial Eq and Ord by enumerating all strings. The Eq instance will be pretty unusable, but the Ord instance might be good for something 
05:19:55 <bollu> Toxaris: I see
05:20:00 <bollu> Toxaris: let me spend some time with this
05:20:53 <Fairy> Can I make Context part of Ord and Eq without them actually doing anything? right now I have     instance Show Context where show _ = ""
05:21:20 <latro`a_> ...technically yes but it's bad practice
05:21:34 <bollu> quick question
05:21:35 <bollu> :t callCC
05:21:37 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
05:22:05 <bollu> so, can't I have a callCC :: ((forall b. a -> Cont r b) -> Cont r a) -> Cont r a?
05:22:15 <bollu> since the thing "inside" the callCC should not depend on b?
05:22:21 <Toxaris> Fairy: consider this instead: instance Show Context where show _ = "(Context ...)"
05:22:23 <bollu> like, the escape hatch type
05:22:24 <Fairy> Because   Function String Stt Context   isn't actually supposed to be printed, ever
05:22:26 <bollu> can unify with anything?
05:22:29 <bollu> does that make sense?
05:22:31 <Toxaris> Fairy: probably gives easier to read debugging output :)
05:23:15 <bollu> Toxaris: can I generalise it like that?
05:24:50 <Fairy> Toxaris What I don't understand is how I would do the same for Eq and Ord
05:25:26 <Toxaris> Fairy: yes I got your real question, just wanted to point out how to improve your "fake" Show instance slightly
05:25:57 <Toxaris> Fairy: about your real question, my guess is still that you might want Data.Map or Data.HashMap instead of functions in your context, did you consider that?
05:26:25 <ongy> Fairy: you could make all Context equal all other Contexts, whcih would (I guess) do what you want. But it's ugly and smells. The prettier version would be to define Eq and Ord on your Stt by hand, but that's also more work
05:27:05 <Fairy> This is an assignment with certain strict requirements, not really at liberty to change certain things :S
05:27:21 <bollu> Toxaris, ongy: uh, any help with the callCC generalisation idea?
05:27:35 <Toxaris> bollu: I'm confused by it. Why is your type more general?
05:28:19 <bollu> Toxaris: because now the b is existential, right?
05:29:09 <ongy> bollu: I think that would require the function to be able to return all types. But I'm not familiar with MonadCont, nor am I sure about this
05:29:17 <bollu> ongy: I see
05:29:38 <wirrbel> how do I generalize that case?
05:29:38 <wirrbel>   I want to substitute the snippet at  http://lpaste.net/591994111414763520 with a general rule, i.e. Tuple es. I feel this should be doable with either foldlM or foldrM. Yet I am kind of stuck on how to do this.
05:30:27 <Toxaris> bollu: Ah I see. Let's consider `f x = ...; g = callCC f`. With the actual type, g can choose *one* b and f has to work with an x that produces that type. With your type, g doesn't choose b but instead f can expect x to produce arbitrary types. So your type is more general, because f can, for example, call x more than once and expect different types
05:31:45 <bollu> Toxaris: yes! that was what I had in mind :)
05:32:25 <Toxaris> bollu: so this begs the question: how is x supposed to achieve this?
05:34:54 <Toxaris> Fairy: hmm, so this is homework or something like that? Maybe you can share what you're supposed to be learning about?
05:36:17 <Fairy> I'm building a parser that can compute lambda functions
05:37:30 <flxw> I'm sincerely sorry about the noise I caused a minute ago. I've got no clue what happened, and I could see the mess only via ircbrowse (not locally). In order to prevent flooding the channel again, I set the maximum line speed to 1 line every 2 sec. Just to be sure.
05:39:17 <puregreen> flxw++
05:45:21 <Fairy> It needs to be able to parse a string like  "lambda x (x (3)) (lambda y ((y,y) +))"  and return a Stt Number (Number 6 in this example case), I'm done with all parsing, on evaluation now
05:51:57 <ongy> Fairy: I'm not sure why you want to have Eq and Ord here, you should be able to work without them
05:53:27 * hackagebot ghcjs-dom-hello 4.0.0.0 - GHCJS DOM Hello World, an example package  https://hackage.haskell.org/package/ghcjs-dom-hello-4.0.0.0 (HamishMackenzie)
05:54:17 <Fairy> Eq and Ord are used in a special Bool case where numbers are compared   if Case bool then expr else case
05:56:14 <Fairy> I'd link the text of the task, however it's not in English.
06:00:02 <ongy> does the task tell you to do this with the Eq instance? imo that should be a normal function
06:01:55 <lpaste> bollu pasted “callcc-forall-wrt-inner” at http://lpaste.net/267470
06:02:08 <bollu> Toxaris: x can achieve this, no?
06:02:10 <bollu> check that out
06:02:11 <bollu> ^ 
06:02:12 <bollu> http://lpaste.net/267470
06:39:50 <Xnuk> exit
06:41:55 <OnOut2k16> http://ilredentore.dynv6.net/
06:51:27 <bollu> I implemented callCC with the type callCC :: ((forall x. a -> Cont r x) -> Cont r a) -> Cont r a
06:51:31 <bollu> http://lpaste.net/267470#line43
06:51:38 <bollu> can someone just tell me if my implementation works?
06:51:56 <bollu> In the sense that, now it is existential in all "x" for (a -> Cont r x)
06:53:28 * hackagebot telegram-api 0.5.1.1 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.5.1.1 (klappvisor)
06:53:30 * hackagebot raft 0.3.7.2 - Miscellaneous Haskell utilities for data structures and data manipulation.  https://hackage.haskell.org/package/raft-0.3.7.2 (BrianBush)
06:56:43 <sm> morning all
06:57:35 <sm> ertesx: I have mended my ways and removed error (I want to reuse this code now)
07:00:06 <sm> today's question: I'm running some code that calls exitFailure (docopt), and catching that as SomeException, per System.Exit docs. In GHCI at least it doesn't seem to be catching the ExitFailure - is this expected ?
07:13:42 <mpickering> bollu: Works in what sense? 
07:13:49 <yulax> sm: looks like afternoon to me xD
07:13:50 <bollu> mpickering: is it correct?
07:13:52 <bollu> the implementation
07:15:25 <bollu> mpickering: like, it does what callCC is supposed to do, right?
07:15:34 <bollu> mpickering: and the forall x. .. will make it existential in x?
07:15:56 <mpickering> It doesn't look like I would expect. callCC takes one argument, a function which is applied to the current continuation
07:16:36 <mauke> isn't that what it does?
07:16:46 <bollu> mpickering: that is what my function takes as well, right?
07:17:00 <mpickering> oh right, I'm wrong
07:17:10 <mpickering> sorry for the confusion
07:17:34 <joncol> In the lens tutorial at https://hackage.haskell.org/package/lens-tutorial-1.0.1/docs/Control-Lens-Tutorial.html, it says that "A Lens' has a Functor constraint and Traversal' has an Applicative constraint. This means that any Lens' is automatically also a valid Traversal' (since Functor is a superclass of Applicative)." Shouldn't that be the other way around?
07:17:43 <bollu> so, it's correct? I was wondering why it's not encoded the same way in the standard library
07:20:46 <lyxia> joncol: The tutorial is right.
07:20:54 <joncol> lyxia: OK. Hmm.
07:22:00 <joncol> But Applicative is more restrictive than Functor? How can every Lens' be a Traversal'?
07:23:06 <joncol> Aren't there Lenses that satisfy the Functor constraint, but fail to satisfy the Applicative constraint?
07:23:10 <puregreen> joncol: a lens has to work with any Functor. A traversal has to work with any Applicative. Since any Applicative is a Functor, a lens can always work with any Applicative
07:23:22 <lyxia> joncol: Lenses don't satisfy constraints, they require them.
07:24:45 <lyxia> Something that requires just a Functor can be specialized by also requiring a subclass such as Applicative.
07:25:32 <lpaste> Fairy pasted “No title” at http://lpaste.net/3741057016081154048
07:27:03 <Fairy> Is anyone able to give me a couple pointers as to how I would solve this issue? http://lpaste.net/3741057016081154048  I'm having a hard time figuring out how I would go about converting the parsed information into a function that would return the desired result
07:28:30 <lyxia> what parsed information?
07:29:13 <Fairy> input: App (Lambda "x" (Name "x")) [Number 2]     needs to return Number 2
07:29:25 <saurabhnanda> quick question, is it possible to pattern match on the LHS of  do-notation binding? eg. ctx@{user=user, tenant=tenant} <- ask
07:30:53 <ongy> saurabhnanda: you can but your syntax looks wrong here
07:31:02 <lyxia> Fairy: ah you are trying to write run that evaluates your expression
07:31:14 <Fairy> lyxia correct
07:32:13 <lyxia> Fairy: what have you tried
07:36:03 <puregreen> saurabhnanda: ctx@Foo{a=a,b=b} <- ask
07:36:14 <puregreen> I think it looks like this
07:36:18 <saurabhnanda> ah thanks
07:36:30 <puregreen> and of course easier things like “(a,b) <- ask” are possible too
07:37:01 <lyxia> Fairy: Do you have an idea of the type of run first?
07:38:17 <joncol> puregreen: I don't see how your logic implies that any Lens' is a valid Traversal'.
07:38:27 <Fairy> its defined as  run :: Stt -> Stt
07:39:35 <puregreen> joncol: it doesn't imply that it's a valid traversal regarding traversal laws, it only implies that any “x :: Lens s t a b” can also be used as “x :: Traversal s t a b”
07:40:01 <Fairy> God, I have a hard time articulating what I've done so far, this part of a larger code that's already functioning
07:40:04 <lyxia> Fairy: oh right. of course.
07:40:48 <puregreen> joncol: in the same fashion any function “f :: Num a => a -> a” can be used as an “Integral a => a -> a”.
07:40:50 <mpickering> joncol: Do you understand conceptually what a Lens and Traversal are without details of these encodings?
07:41:06 <joncol> mpickering: Yes, in theory :)
07:41:22 <joncol> (At least partially.)
07:42:48 <glguy> lispy: Object was indeed gathering constraints on the contained type
07:44:16 <glguy> ski: I think you can build some of those other operations just using the existing usingN and upcast functions
07:44:48 <glguy> joncol: Because the restriction is an consumed and not created
07:45:01 <joncol> But to me the definition "type Traversal' a b = forall f. Applicative f => ..." seems to imply that f _has_ to have an applicative instance for (b -> f b) -> (a -> f a) to be a valid Traversal' ? And I don't understand why suddenly all Lens':es (of which f:s I think of as guarantueed to only have a Functor instance, and not an applicative instance)
07:45:38 <joncol> ...are valid Traversal':s as well.
07:45:56 <joncol> glguy: What does that mean?
07:46:29 <glguy> Traversals only work on a subset of the types that lenses work on
07:47:05 <glguy> the set of types that are Applicative is smaller than the ones that are Functor
07:48:04 <glguy> So if a lens works for any type with merely a Functor instance then it will work for any of the types a Traversal requires
07:49:09 <joncol> glguy: Ah, I think I get it now.
07:49:11 <joncol> :)
07:49:33 <joncol> Is it only me who find this confusing?
07:53:30 * hackagebot hsqml-demo-manic 0.3.4.0 - HsQML-based clone of Pipe Mania  https://hackage.haskell.org/package/hsqml-demo-manic-0.3.4.0 (RobinKay)
07:53:32 * hackagebot opencog-atomspace 0.1.0.4 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.4 (romanT)
07:53:46 <glguy> Probaby not
08:05:19 <suppi> is anyone interested in giving me some feedback on a blog post before i go embarrass myself on reddit or something? :) http://gilmi.xyz/post/2016/10/14/lisp-to-js 
08:05:25 <suppi> thanks in advance
08:17:59 <Toxaris> suppi: s/We have some built-in function in our language/We have some built-in special forms in our language/
08:19:29 <suppi> Toxaris: sounds good. thanks.
08:19:56 <Toxaris> suppi: "Usually, you would like to ... but we won't do that here so this is enough for us."
08:20:08 <Toxaris> hmm, so why not do it?
08:20:45 <Toxaris> and why do you provide EBNF for the special cases if you don't plan to reflect them in the data type?
08:21:07 <suppi> Toxaris: simpler parsing, wanted to show how uniform lisp syntax is
08:21:43 <ClaudiusMaximus> suppi: maybe an example of some concrete js syntax in section 5 where you introduce jsexpr would be useful, i got a bit lost there in my skim reading - and at the end an example transpiled output would be nice for lazy people like me who don't feel like getting it running
08:21:44 <Toxaris> maybe exercises 1 and 2 should be switched? I think 2 is much easier than 1
08:21:47 <suppi> Toxaris: the special forms are being addressed later, after parsing
08:22:54 <Toxaris> I would s/parsing combinators library/parser combinator library/g
08:23:33 <Toxaris> is it good to have section 2 mixed with the other stuff?
08:25:20 <Toxaris> suppi: "In it's essence, parsing is ..." no it's not. That's one way to implement parser combinators, sure, but this is not the essence of parsing. The essence of parsing is `String -> a`, and `String -> ... (a, String)` is your implementation idea
08:26:23 <suppi> ClaudiusMaximus: can you give an example for concrete js syntax you might want to see?
08:26:43 <suppi> Toxaris: you are right. i'll change it so it'll say that "our implementation in it's essence..."
08:28:26 <ClaudiusMaximus> suppi: a little snippet corresponding to each jsexpr case - but probably i was skimming too quickly anyway, it doesn't seem a problem anymore after reading it more carefully
08:28:35 <suppi> Toxaris: what do you mean by asking is it good to have section 2 mixed with the other stuff?
08:28:45 <suppi> ClaudiusMaximus: ok. thanks :)
08:29:14 <Toxaris> "write a compiler" and "write a parser combinator library" are very different tasks, why talk about both in the same blog post?
08:30:27 <suppi> Toxaris: because explaining how to use an existing library is more work than implementing a tiny one for our usage, or at least that's what i think
08:30:57 <Toxaris> ok that is a reasonable choice, maybe mention that in the blog post?
08:31:13 <suppi> also it's nice to be able to do everything with vanila haskell :)
08:31:19 <suppi> Toxaris: alright. i will
08:31:51 <Toxaris> suppi: at the beginning of Sec. 5, you talk at length about concrete vs. abstract syntax without using these words (why not use the words?)
08:32:05 <Toxaris> but that topic came up before, when talking about concrete vs. abstract lisp syntax. maybe link back
08:32:20 <Toxaris> mention that generateJS is similar to printExpr 
08:32:36 <Toxaris> (given that they are similar, why do they use different naming schemes?)
08:33:37 <suppi> Toxaris: I'm not sure i follow all the way
08:34:04 <Toxaris> I think it is good practice, for every language that shows up in a compilation pipeline, to define an abstract syntay with data types, a concrete textual syntax, a parser, and a pretty printer. Not all of the parsers and pretty printers will be used in production, but for debugging and testing, they will be good to have around
08:34:58 <suppi> right
08:35:30 <Toxaris> your blog posts hints at this good practice, but doesn't spell it out
08:36:01 <Toxaris> about printExpr and generateJS: well, printExpr is a pretty printer for your source language, and generateJS is a pretty printer for your target language. So they are both pretty printers. But their names don't show that they are both pretty printers.
08:37:35 <suppi> Toxaris: I see, so it will be more clear if I use a similar name for both? like printExpr and printJSExpr or generateExpr and generateJS ?
08:37:43 <Toxaris> yes
08:38:00 <Toxaris> and you can also point out in the text that they are similar
08:38:18 <Toxaris> "above, we wrote a printer for Expr, now we write a printer for JS"
08:39:57 <suppi> Toxaris: that's a good idea. thanks again
08:40:00 <Toxaris> I would consider s/mapM/traverse/g
08:41:35 <mpickering> bollu: Which library definition are you looking at?
08:42:09 <mpickering> it looks the same as this one - https://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.Cont.html#callCC
08:43:59 <Toxaris> suppi: I don't like your translateList and from Symbol. It took me 4min to understand how they work together. And in translateList, the expression `JSFunCall <$> translateToJS g <*> mapM translateToJS xs
08:43:59 <Toxaris> ` is duplicated :(
08:45:33 <suppi> Toxaris: i'll take a look
08:46:40 <suppi> yeah that's weird
08:47:39 <Toxaris> I like how you handle builtins by having a list of cases in an actual list. However, I don't think that your code correctly supports scoping
08:48:09 <Toxaris> consider the following lisp expression: (let ((+ -)) (+ 1 2 3))
08:49:25 <Toxaris> Before translation, this expression would compute -5, but I fear that after translation, it would compute +6. Maybe your choice of characters to allow in symbols avoids such cases, not sure.
08:50:18 <suppi> Toxaris: let me check
08:52:02 <Toxaris> why does transBinOp call translateList in the third case? Shouldn't transBinOp just do a foldr to construct a nested expression? 
08:52:03 <suppi> Toxaris: yeah, so the problem with that approach is that the build-in function are not first class but special cases
08:52:59 <Toxaris> yep. That's an ok limitation for a toy compiler, but maybe you can mention it.
08:53:28 <suppi> Toxaris: good idea.
08:53:32 * hackagebot word24 2.0.0 - 24-bit word and int types for GHC  https://hackage.haskell.org/package/word24-2.0.0 (winterland)
08:54:02 <suppi> Toxaris: what do you mean by foldr?
08:54:29 <Toxaris> https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:foldr
08:56:16 <Toxaris> or maybe foldr1
09:00:24 <suppi> Toxaris: Should be possible I guess. for some reason i can't find the right way to express it right now. i'll try again later
09:01:24 <suppi> Toxaris: I can get rid of second though, i think
09:02:39 <Toxaris> suppi: note that I have a rather low tolerance for non-perfectly structured code, which might explain my nitpicking about function names and duplication :) So the fact that I find something to complain doesn't mean the blog post is not ready for publication
09:03:02 <suppi> Toxaris: you're very helpful. thanks :)
09:04:08 <suppi> I think the binary code is a bit problematic anyway, i'll look at it again
09:12:00 <lpaste> Fairy pasted “No title” at http://lpaste.net/5525186950530596864
09:12:51 <suppi> Toxaris: ok, changed it. it should make more sense now
09:13:48 <Fairy> 80 lines of code might possibly be way too much, but I'm completely stuck on this expansion http://lpaste.net/5525186950530596864 maybe I'm being stupid and it's obvious, but I'm completely stuck :S
09:20:05 --- mode: ChanServ set +o monochrom
09:20:32 --- mode: monochrom set -qq *!~north@* *!~plant@*
09:20:37 --- mode: monochrom set -o monochrom
09:24:41 <Toxaris> Fairy: why does eval return a new Context?
09:26:04 <Toxaris> Fairy: why is Stt used for both expressions and values?
09:27:34 <Toxaris> overall, the code looks almost like a standard interpreter, but then the details are off. So either the details are off in the assignment (on purpose or not) or you somehow added stuff the wrong way
09:28:17 <Fairy> Because it stores previously set variables:   run "set a (0, 1)-; (a, 3)+;" evaluates to  Block [Set "a" (App (Name "-") [Number 0,Number 1]),App (Name "+") [Name "a",Number 3]] which then evaluates to (Number 2)
09:29:56 <Fairy> Toxaris Stt is used for both expressions and values because the lecturer says so and I'm not allowed to change :S
09:39:11 <joe9> I have a [ (Word8, MyType)] static lookup table -- Would you recommend using an IntMap or a HashMap?
09:39:27 <joe9> With IntMap, I would have to convert Word8 to Int for any operation.
09:39:41 <joe9> With HashMap, I would not have to do that. Not sure which would be better.
09:40:00 <joe9> http://dpaste.com/0QDW4DY is the actual code
09:40:21 <geekosaur> there's an EnumMap on hackage which wraps IntMap (optimized, I think) and handles any Enum instance
09:40:46 <joe9> geekosaur: I am rethinking having it as an Enum.
09:41:04 <joe9> I want to remove the Enum instance for this as I do not think I am getting anything by using an Enum.
09:41:27 <geekosaur> you can't remove Word8's Enum instance...
09:42:17 <geekosaur> also I think the coercion for Word8 is id and gets optimized away with any -O other than -O0
09:42:35 <joe9> No, I meant this instance: https://paste.pound-python.org/show/RdVkfXZhUaa0mhblFz28/
09:43:07 <suppi> Toxaris: thanks a lot for your help. I've editted the post according to your feedback. Is there anything else you'd like to comment on?
09:43:15 <geekosaur> that one is not relevant. if the key is Word8 then EnumMap will work with it
09:43:17 <joe9> geekosaur: because all I want to do this lookup and pattern match
09:43:28 <joe9> geekosaur: THanks. will check it out.
09:44:09 <joe9> geekosaur: one thing that I am worried about is that the values are not continuous. (Terror 106) is not a valid value.
09:44:38 <monochrom> "Terror" is a great name :)
09:44:52 <geekosaur> I... don't think that is relevant?
09:45:02 <geekosaur> I'm not sure what you think is going on here
09:45:11 <monochrom> . o O ( "How to understand GHC terror messages?" )
09:45:16 <geekosaur> the only question here is the type of the lookup key
09:45:47 <geekosaur> EnumMap places no constraints on the value, only the key
09:45:55 <joe9> geekosaur: I do not understand. EnumMap needs a Enum instance
09:46:07 <iomonad> Hello, I have a problem with stack. I started a project with `stack new project`, added all lib-dependencies in the cabal file and build the project. Today I wanted to build my project but stack gimme an error: "Failed to load interfaces for  'Web.Scotty', It is a member of the hidden package 'scotty'". I do rm -rf .stack-work and ~/.stack and retry building but the error is still persistent. If anybody have
09:46:08 <geekosaur> yes, for the key. the key is Word8
09:46:09 <iomonad> ideas I would be Great. Here is a screenshot of the error message -> https://u.teknik.io/Fqrm9.png || I also pushed the project on github
09:46:15 <geekosaur> the value is not constrained
09:46:20 <joe9> oh, ok.
09:47:06 <joe9> geekosaur: Thanks. That is a good idea.
09:47:39 <geekosaur> the only thing EnumMap does is transparently use an Enum instance on the key type to get an Int that it can use in an IntMap
09:49:02 <geekosaur> and for Word8, fromEnum is vacuous as the representation is identical to Int
09:53:34 * hackagebot compiler-warnings 0.1.0 - Parser for common compiler warning formats  https://hackage.haskell.org/package/compiler-warnings-0.1.0 (DmitryIvanov)
09:53:36 * hackagebot servant-db-postgresql 0.2.1.0 - Derive a postgres client to database API specified by servant-db  https://hackage.haskell.org/package/servant-db-postgresql-0.2.1.0 (NCrashed)
09:53:38 * hackagebot ip6addr 0.5.1.4 - Commandline tool to generate IPv6 address text representations  https://hackage.haskell.org/package/ip6addr-0.5.1.4 (MichelBoucey)
09:54:51 <knupfer> Can anybody explain to me GHC.TypeLits.sameNat ?  Is this equivalent to comparing the proxies with natVal?
09:54:53 <joe9> geekosaur: I was thinking EnumMap TransmitMessageType Word8 . it makes sense to use EnumMap Word8 TransmitMessageType
09:55:46 <geekosaur> which one are you looking up? that tells you which one to use. (if you are using both, then you are in a different area entirely; look for a bidirectional map package)
09:56:09 <geekosaur> but since you were thinking of using IntMap, EnumMap should work without code changes
09:57:25 <dfeuer> @where ops
09:57:25 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
09:57:34 <dfeuer> User ffggfgf just threw spam in PM.
09:57:41 <dfeuer> Or something. 
09:57:53 <bollu> ^ same
09:58:03 <geekosaur> one of those bots, sigh
09:58:05 --- mode: ChanServ set +o geekosaur
09:58:15 --- mode: geekosaur set +b *!*tytyryty@jrcollado1987.ddns.net
09:58:18 --- kick: ffggfgf was kicked by geekosaur (ffggfgf)
09:58:24 --- mode: geekosaur set -o geekosaur
09:58:35 <geekosaur> haven't seen one of those in a while, but they are definitely a thing
09:58:43 <lyxia> knupfer: the result of the comparison is also reflected at the type level.
10:00:21 <knupfer> lyxia: So can GHC use this while type checking?  If so, how if it's run at runtime?
10:00:31 <lyxia> knupfer: when you pattern match on the result, (Just Refl) provides an equality of types.
10:01:41 <lyxia> At runtime it's a regular comparison.
10:02:44 <joe9> geekosaur: I actually I need both direction lookup. will check up on bi-directional map. I did not even know that such data structures existed. Cool.
10:03:41 <joe9> geekosaur: Data.Bimap, correct?
10:03:57 <geekosaur> (also beware of "bimap" or at least look more closely; the term can also mean mapping a function over both values in a tuple :)
10:04:20 <geekosaur> yep
10:05:45 <knupfer> lyxia: thanks
10:06:16 <iomonad> sorry. Problem solved
10:06:30 <joe9> geekosaur: ok, Thanks.
10:07:38 <joe9> geekosaur: The problem is the lookup is throw'ing  instead of a Maybe
10:07:57 <joe9> will check if Maybe is an instance of MonadThrow
10:08:30 <joe9> it is.
10:09:03 <geekosaur> http://hackage.haskell.org/package/exceptions-0.8.2.1/docs/Control-Monad-Catch.html#t:MonadThrow says it is, yes
10:09:14 <geekosaur> also interesting they went back to that form :)
10:09:41 <geekosaur> back around ghc 6.6 Data.Map worked that way too, except there was no MonadThrow so they just used Monad. this offended people
10:14:09 <knupfer> lyxia: Is there a similar function to prove to GHC inequalities like (a < b) ?
10:15:19 <srk> I've tried implementing tcp server with broadcastTchan broadcasting data from clients connected on one port to clients on another port and it space leaks https://gist.github.com/anonymous/b85272a864634582a97ddcdbb9d87ac9
10:15:56 <srk> if anyone willing to take a look for an obvious mistake. trying to build with profiling meawhile
10:16:30 <ReinH> srk: have you profiled it?
10:16:37 <srk> on it!
10:17:34 <dhrosa> is there such a thing as a wireless usb hub? (e.g. the hub and host are connected over RF via a dongle)
10:17:52 <dhrosa> i've never found anything like one... so there must be a reason
10:17:55 <dhrosa> oops wrong channel
10:20:18 <geekosaur> dhrosa, for what it's worth I would expect that to only work sanely for USB1. USB2 and higher data rates would use a lot of bandwidth and require fairly short range RF link
10:21:19 <geekosaur> (this is why you see wireless dongles for mice and keyboards but not, say, drives)
10:23:08 <lyxia> knupfer: I don't know :(
10:26:14 <thesmileynoob> aki__: hello 
10:27:24 <knupfer> lyxia: ok :)
10:29:10 <lyxia> knupfer: I can't find one in base, but you can define yours.
10:30:58 <lyxia> But it won't be very useful without compiler support.
10:32:28 <Toxaris> iomonad: Maybe you need to add scotty also to the build-depends of the executable?
10:32:41 <mpickering> knupfer: What exactly are you looking for?
10:33:01 <Toxaris> iomonad, oh wait, that was two hours ago, probably already solved. sorry.
10:33:40 <thesmileynoob> Hello guys. Could you please point me towards a source to learn the concepts of functional programming? I am not a computer science graduate (Civil engineer here) so I would greatly appreciate a thorough book or a video lecture perhaps. Thank you
10:34:21 <knupfer> mpickering: Well, I'm just curious.  At the moment I'm writing a library to annotate the minimal and maximal length of a list.
10:34:40 <mpickering> at the type level?
10:35:42 <knupfer> mpickering: yes
10:36:16 <knupfer> It's like, if you take 2 of an arbitrary list, the compiler knows afterwards that the resulting list has got a length between 0 and 2
10:36:55 <knupfer> And if the length of the list is fully known at compile time, the length function returns instantly without traversing the list
10:38:58 <mpickering> maybe this package will be useful - https://hackage.haskell.org/package/ghc-typelits-natnormalise
10:40:55 <knupfer> I've already seen it.  It's really great, but at least until now I didn't need it.
10:42:18 <ReinH> thesmileynoob: For FP in generel, I'd recommend Introduction to Functional Programming using Haskell, or Thinking Functionally with Haskell, both by Richard Bird. (The latter is a recent rewrite of the former.)
10:42:29 <ReinH> The former can probably be found as a pdf these days
10:42:44 <ReinH> it is still one of the best books I've read about functional programming
10:43:34 <juri_> ok, list comprehension question. if i have data Objs = O1 String | O2 String String | O3 Float , i use allFloats children = [ x | O3 x <- children] to get all Floats.. how do i write a comprehension that resolves to "all O1s and O2s"?
10:43:34 <phaskell-1> O3: GHC - Utilities - https://phabricator.haskell.org/owners/package/3/
10:43:35 <phaskell-1> O2: GHC - Driver - https://phabricator.haskell.org/owners/package/2/
10:43:35 <phaskell-1> O1: GHC - Build System - https://phabricator.haskell.org/owners/package/1/
10:43:35 <phaskell-2> O3: GHC - Utilities - https://phabricator.haskell.org/owners/package/3/
10:43:35 <phaskell-2> O2: GHC - Driver - https://phabricator.haskell.org/owners/package/2/
10:43:35 <phaskell-2> O1: GHC - Build System - https://phabricator.haskell.org/owners/package/1/
10:44:03 <juri_> um. that was interesting.
10:44:41 <thesmileynoob> ReinH: Thank you. Does it require deep knowledge of algorithms (or computer sciency stuff)? 
10:44:47 <ReinH> Not at all.
10:45:13 <ReinH> Uh, who's running the phabricator bots?
10:45:40 <iomonad> Toxaris :: yes ! Thanks 
10:46:26 <ReinH> juri_: not easily
10:46:35 <Toxaris>  juri_: no super-concise way to do that.
10:47:20 <Toxaris> juri_: maybe define isO1or2 : Objs -> Bool and then [x | x <- children, isO1or2 x]
10:48:13 <lyxia> filter :)
10:48:23 <ReinH> lyxia: filter is what that desugars to
10:49:34 <Zemyla> Does an LLVM-enabled GHCi do JIT on BCOs?
10:50:05 <ReinH> Zemyla: impressive abbreviation density
10:52:25 <juri_> There's no more efficient form than two seperate filters?
10:53:06 <ReinH> No one suggested two separate filters
10:53:38 <juri_> but isn't the first [ x | O3 x <- children] barically filter?
10:53:39 <phaskell-2> O3: GHC - Utilities - https://phabricator.haskell.org/owners/package/3/
10:53:39 <phaskell-1> O3: GHC - Utilities - https://phabricator.haskell.org/owners/package/3/
10:53:53 <ReinH> @where ops
10:53:53 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
10:54:00 <ReinH> Can we silence that bot until it top spamming?
10:54:03 <ReinH> *stops
10:54:12 <geekosaur> Zemyla, ghci doesn't do any optimization at all
10:54:14 --- mode: ChanServ set +o geekosaur
10:54:32 <ReinH> juri_: Yes, that one is a filter, and the other one is a filter, but they are two different expressions.
10:54:51 <Zemyla> geekosaur: Any reason why it couldn't?
10:54:58 --- mode: geekosaur set +q phaskell-2!*@*
10:55:01 --- mode: geekosaur set +q phaskell-1!*@*
10:55:04 <ReinH> geekosaur: Thanks
10:55:09 <geekosaur> phaskell was already +q because of that
10:55:14 <geekosaur> dunno why it now joins 3 times
10:55:19 --- mode: geekosaur set -o geekosaur
10:55:36 <geekosaur> Zemyla, it could, but nobody has ever contributed optimizer code for the bytecode backend
10:55:51 <ReinH> juri_: you want to filter in two different ways. How do you expect to do it more efficiently than two different filters?
10:55:57 <juri_> sure, but if what i want is ([All O1s],[all O2s], [all O3s]), can't i get away with something more efficient?
10:56:00 <geekosaur> and/or nobody has ever cared enough
10:56:07 <ReinH> Yes, but that's not what you asked for.
10:56:21 <juri_> ok, how do i get that. ;)
10:56:46 <Tuplanolla> Why does GHCi have a different code generator in the first place?
10:56:48 <ReinH> You can use a foldr
10:57:19 <geekosaur> Tuplanolla, because you don't particularly want to have every expression entered at the prompt go through a full native code compile?
10:57:47 <knupfer> mpickering: https://github.com/knupfer/sized-foldable
10:58:01 <ReinH> foldr select ([],[],[]) where select x@(O1 _) (xs,ys,zs) = (x:xs,ys,zs); select y@(O2 _ _) = (xs,y:ys,zs); ...
10:58:02 <Tuplanolla> CHICKEN is a Scheme system that spins up a C compiler for every line and it's not even noticeable, geekosaur.
10:58:18 <ReinH> But I don't really see the point of doing this
10:58:18 <Tuplanolla> I'm sure GHC could match that.
10:58:23 <geekosaur> it works more like perl/python/ruby and compiles to a bytecode that is run by a simple interpreter, which ends up being faster for most cases. (note that it can run native compiled code, it just doesn't native comple itself)
10:58:58 <geekosaur> Tuplanolla, try running that on ARM and then tell me that. yes, every problem like that is simple if you require everyone use only the latest fastest hardware.
10:59:39 <juri_> ReinH: I'm trying to keep my haskell program from eating 480 gigs(!) of ram and dieing. so, "not premature optimization, but maybe the wrong optimization target".
10:59:40 <Zemyla> geekosaur: I would, but (a) I don't know where to start in learning to develop on GHC, and (b) would this mean that, since every Haskell program has a BCO interpreter, that every program built by an LLVM-enabled ghc would include LLVM?
10:59:52 <geekosaur> also haskell takes longer to compile than C does. and probably scheme if it's not trying to optimize that
11:00:10 <ReinH> juri_: if your program is eating 480 gigs of ram, I'm pretty sure this is not your problem.
11:00:21 <ReinH> Have you profiled it?
11:00:53 <juri_> sortof. i'm not really sure what profiling 'means' in haskell.
11:00:56 <ReinH> I don't see how doing this could do anything but make it use more memory.
11:01:03 <ReinH> @google ghc latest manual profiling
11:01:04 <lambdabot> https://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
11:01:13 <ReinH> Things like that.
11:01:15 <juri_> i've gone through the motions, but it doesn't really point me at anything.
11:01:21 <ReinH> Other things that are discussed in Simon Marlow's book.
11:01:34 <geekosaur> Zemyla, what? compiled code doesn't use bytecode at all. the LLVM backend generates LLVM IR and runs it through lld to generate native code; the asm backend generates native code directly. only ghci and TH use the bytecode backend and interpreter
11:01:37 <ReinH> Other things that are discussed on the internets, e.g., by bos and Stephen Diehl
11:01:40 <Tuplanolla> I guess 2008 counts as the latest here.
11:02:14 <ReinH> juri_: you can find out what the memory is being used for
11:02:40 <ReinH> Neil Mitchell has a nice writeup http://neilmitchell.blogspot.com/2013/02/chasing-space-leak-in-shake.html
11:02:57 <Zemyla> geekosaur: I think every Haskell program still includes the bytecode primops like newBCO# and mkApUpd0#.
11:03:08 <ReinH> But taking a structure and turning it into another structure is not going to *reduce* your memory use.
11:03:51 <ReinH> and guessing about what the problem is just leads to working on the wrong thing
11:04:17 <juri_> that makes some sense. I'm just trying to make a dent.
11:04:20 <ReinH> That's the point of "premature optimization". It's wasted work unless you happen to guess right.
11:04:36 <ReinH> You don't even know where to point the dent-making device.
11:04:57 <geekosaur> at this point I am just going to point you at #ghc. but I suspect even if that primop gets used, it doesn't generate bytecode in a native or LLVM backend
11:04:58 <ReinH> Go profile your program.
11:05:22 <ReinH> If you don't know how to profile your program, learning how should be your next goal.
11:07:09 <juri_> giving it a go. thanks.
11:07:40 <juri_> even if you did just tell me i'm stupid, and to read the manual. ;)
11:08:08 <ReinH> I only told you one of those things.
11:08:15 <ReinH> If anyone told you the other one, it was you.
11:08:21 <juri_> ;)
11:08:58 <ReinH> Which, I mean, that's not a nice thing to say about yourself.
11:09:54 <juri_> Learning haskell has been very different from learning other languages. my usual approach isn't quite returning rewards as fast as it does in other languages.
11:10:34 <EvanR> apparently ghc has decidable equality class
11:10:46 <EvanR> TestEquality in Data.Type.Equality
11:10:50 <EvanR> handy!
11:11:38 <Guest11942> Okay, can someone please explain to me what's the big deal with free monads?
11:11:52 <Guest11942> Assume competency with transformers and monads in general
11:12:26 <Guest11942> It just seems like a bad, inefficient way to structure a program. All this work to make haskell more efficient as a compiled language and... we waste it on turning our program into a bytecode interpreter!
11:13:17 <Tuplanolla> Sometimes you want an interpreter.
11:13:37 <ReinH> Free monads are not just interpreters.
11:13:38 <geekosaur> Guest11942, that's not really what you are doing, even though it may look like that. what you are really doing, in a functional rather than imperative way, is indirecting operations through a record of virtual to real operation functions
11:14:00 <Guest11942> That's, by definition, interpreting, I think.
11:14:03 <lyxia> It would still be more efficient than one written in python...
11:14:06 <ReinH> You are also reifying the structure of the computation in a principled way.
11:14:14 <Guest11942> But semantics aside, what advantages do I gain?
11:14:18 <geekosaur> (like the vfs or device strategy layers in a kernel)
11:14:58 <geekosaur> also, if that is "interpretation", then so is C++, because that also describes how C++ methods work
11:15:14 <geekosaur> (certainly how virtual methods work)
11:15:24 <Guest11942> ReinH: I can see that the computation is reified. It's neat. But I'm at a loss for why I want this!
11:15:32 <Guest11942> Besides "optimizing your program on the fly"
11:16:01 <ReinH> How do you test a DSL?
11:16:11 <ReinH> Do you execute it against example programs and test the output?
11:16:22 <EvanR> optimizing programs on the fly, converting them to run on a microcontroller...
11:16:39 <ReinH> If it's a DSL for making web requests, how do you test it without spinning up a server to receive them?
11:16:40 <Guest11942> ReinH: typically, yes. I also unit test individual components in the "language"
11:17:10 <Guest11942> ReinH: type synonym and replace some modules / types with the mock server :P
11:17:36 <ReinH> Or, instead, you define your DSL as a free construction and swap out the interpreters.
11:17:43 <Guest11942> Right, I've seen that
11:17:44 <Guest11942> however
11:17:59 <Guest11942> in Ocaml, we'd just use a functor and swap live environments with testing ones.
11:18:15 <ReinH> ML modules are nice.
11:18:21 <Guest11942> That's certainly more efficient and less roundabout than the interpreter method.
11:18:29 <Guest11942> In Haskell, to do the same thing, you'd have to operate entirely on typeclasses, but it's certainly not that bad
11:18:39 <ReinH> How do you know how inefficient this method is?
11:18:44 <ReinH> What are you basing this judgement on?
11:18:45 <Guest11942> I don't. It's a guess.
11:19:26 <ReinH> Ok, so you don't really know, but you're making claims about it inefficiency anyway.
11:19:32 <Guest11942> But I would imagine it's a good one! Dispatching on bytecode instructions. In fact, my rudimentary knowledge of compilation tells me that most of the unfolding and simplification that a compiler usually does [cont'd]
11:19:51 <Guest11942> [cont'd] is invisible to the compiler once you encode the actual program as data structure.
11:19:54 <Guest11942> That's concerning.
11:20:14 <ReinH> I'm going to put as much effort into defending this point as you have put into making it. ;)
11:20:15 <Guest11942> ReinH: I've heard some proponents claim there are "performance problems". That's not my entire criticism, anyway :P
11:20:49 <ReinH> What performance problems? Do you understand their claims?
11:21:49 <ReinH> Yes, but when we've responded to your other criticism, you've used efficiency as a fallback position.
11:21:58 <Guest11942> I did?
11:22:01 <Guest11942> rereading, hold on
11:22:25 <Guest11942> Well, I mentioned it, but like I said, I wouldn't say that's my whole argument. Here's the real crux
11:22:30 <Guest11942> by the way, this is Kristof, if you remember me
11:22:41 <ReinH> Hi :)
11:22:42 <Guest11942> Seems someone changed my nick's pass, or I've forgotten it
11:23:12 <ReinH> The performance problems with free monads that I'm aware of are based on an inefficient construction, and there are various optimizations intended to fix this problem.
11:23:50 <Guest11942> when I try to use free monads, rather than doing things the typical way (programmatic deconstruction into smaller and smaller functions) I find myself 1) designing the DSL and then 2) designing the interpreter
11:23:56 <Guest11942> it ends up being... a little more work!
11:24:00 <ReinH> There is of course an overhead, but you don't really know what it is, so you don't know whether it's significant for whatever use case you have in mind.
11:24:08 <Guest11942> true
11:24:34 <Guest11942> Surely you must admit there is some kind of conceptual divide between "normal Haskell" and "free monadic Haskell"
11:24:56 <Cale> Guest11942: I don't know what you mean by "free monadic Haskell"
11:25:00 <ReinH> I guess when you say "free monadic Haskell", you really mean "free monadic DSLs and their interpreters"
11:25:05 <Guest11942> Correct
11:25:10 <ReinH> Because many things are free monads that have nothing to do with DSLs
11:25:19 <Guest11942> Of course.
11:25:23 <ReinH> Free monads over ASTs let you perform variable substitution
11:25:32 <bollu> ReinH: what are the other uses of free monads?
11:25:49 <Cale> Guest11942: It's just yet another strategy for deferring the specification of how various operations are carried out.
11:25:53 <ReinH> e.g. data Expr a = Var a | Val Int | Add (Expr a) (Expr a)
11:25:55 <ReinH> is a free monad
11:25:57 <Guest11942> Free monads let you perform arbitrary restructuring in general. Useful, although I can't think of many usecases.
11:26:01 <ReinH> whose bind performs variable substitution
11:26:12 <ReinH> (it replaces a's, which are variables, with Expr a's, which are terms)
11:26:12 <Cale> Guest11942: and there also isn't really one way of encoding free monads either.
11:26:25 <Cale> There's are a few rather general ways
11:26:41 <Guest11942> I agree. I mean free monadic DSLs and their interprerters.
11:26:44 <Guest11942> Let me refine what I'm asking
11:26:48 <bollu> Cale: what are the other ways other that Free f a = Pure a | Roll f (Free f a)?
11:27:01 <ReinH> @hackage operational
11:27:01 <lambdabot> http://hackage.haskell.org/package/operational
11:27:03 <Guest11942> I've heard a lot of people say that this is a unique and pioneering way to structure programs. I'm trying to find justification for that claim.
11:27:20 <Guest11942> If people here believe it to be more special cased than I've heard, I'll be receptive to that answer.
11:27:42 <ReinH> The return and bind construction.
11:28:08 <bollu> ReinH: which one?
11:28:14 <ReinH> bollu: the one that operational uses
11:28:21 * geekosaur is inclined to think that both "unique and pioneering" and "more special cased" are in some sense wrong, or at least missing the point?
11:28:23 <ReinH> http://hackage.haskell.org/package/operational-0.2.3.2/docs/src/Control-Monad-Operational.html#ProgramT
11:28:23 <Guest11942> Yeah, I've heard of operational
11:28:25 <bollu> I see
11:28:39 <Guest11942> geekosaur: Help me see the point? :'(
11:28:42 <ReinH> which reifies return and (>>=) rather than return and join
11:29:28 <ReinH> Guest11942: So I guess you didn't find http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html or http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html compelling enough?
11:29:53 <ReinH> or http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
11:30:01 <Guest11942> Unlike most of Gabriel's articles, reading those is what brought me here :P
11:30:30 <Cale> bollu: There's Operational, there's MonadPrompt, there's FreeVL...
11:30:57 <bollu> Cale: time to check all these out :P
11:31:01 <ReinH> One advantage is that reifing the operations of our interpreter into a free monad let us reason about effects.
11:31:08 <Cale> Nevermind that there's like more generally the finally tagless stuff...
11:31:15 <ReinH> If I have a free monad interpreter for a teletype machine, I know it can't also make web requests, fire missiles, etc
11:31:23 <ReinH> which I don't know if I'm just composing IO actions.
11:31:23 <bollu> Cale: what's the finally tagless stuff?
11:31:37 <bollu> Cale: remember the whole "using free monads for FHE" thing I was telling you? maybe this would help
11:31:46 <Cale> http://okmij.org/ftp/tagless-final/
11:31:58 <stevenxl> Hello folks. When I write something like this: f :: Num a => a -> b -> Int -> Int, I'm used to calling it a type signature. Rarely, I've seen this called a type declaration. 
11:32:07 <stevenxl> Is type declaration also correct?
11:32:16 <ReinH> type declaration is correct, perhaps correcter.
11:32:32 <stevenxl> ReinH: Thank you. I'm always happier to be correcter. 
11:32:43 <ReinH> :: is the "is of type" operator, and this is a declaration that f is of type Num a => ...
11:32:55 <bollu> Cale: is there a package?
11:33:10 <Cale> bollu: no, it's just something you do using type classes
11:33:21 <Cale> bollu: There isn't so much of a package to make there.
11:33:24 <ReinH> stevenxl: It is called a declaration by the report.
11:33:31 <ReinH> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-620004
11:33:39 <stevenxl> What do we call something that simply does a Synonym: type String = [Char}
11:33:50 <stevenxl> err, that last } should be a ]
11:33:53 <ReinH> Everything at module scope is a declaration.
11:33:57 <ReinH> according to the report
11:33:59 <Cale> bollu: (also it's not really got much to do with monads, just the deferring implementation part)
11:34:34 <Cale> stevenxl: Yeah, that's awkward, I suppose, I would say "type synonym"
11:34:45 <ReinH> stevenxl: but the report also specifically calls f :: () a "type signature" as well
11:34:47 <stevenxl> ReinH: Thanks. In that report they call it "type synonym declaration"
11:34:49 <Cale> "type synonym declaration"
11:34:53 <Cale> if you want
11:35:00 <Cale> yeah
11:35:14 <ReinH> The line is "gendecl	→	vars :: [context =>] type	    (type signature)"
11:35:21 <bollu> Cale: cool, I'll check it out
11:35:34 <Cale> All the things that occur at the top level of a Haskell module are called "declarations" generally.
11:35:43 <ReinH> @quote fugue
11:35:44 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
11:36:01 <bollu> Cale: do you think that may help with the encryption thing?
11:36:04 <ReinH> "type synonym declaration" if you want
11:36:13 <Cale> ReinH: hehehe
11:36:28 <Cale> bollu: I dunno, maybe!
11:36:30 <ReinH> yeah if you want "type synonym declaration"
11:36:33 <EvanR> is there a "standard" (now included in base) type class for folding over all elements of a type
11:36:55 <Cale> Foldable?
11:37:06 <ReinH> Bounded + Enum?
11:37:07 <EvanR> thats for lists of elements of a type, or subsets if you will
11:37:08 <stevenxl> Thanks ReinH  and Cale - my big hang-up was that I thought type declaration was specifically "type synonym declaration", which it is not. This clears it up a bit, and I'll take a look at the report.
11:37:15 <EvanR> Bounded + Enum does play nice with GADTs
11:37:18 <EvanR> doesnt
11:37:18 <Cale> EvanR: ah, I see what you mean
11:37:25 <Cale> EvanR: then not really
11:37:26 <geekosaur> EvanR, Data.Data is in base
11:37:31 <bollu> Cale, ReinH: the free/monad + comonad interpreter works because of the Pairing between them, right?
11:37:36 <bollu> (and the free/cofree structures ofc)
11:37:39 <EvanR> right... generics and stuff
11:37:41 <ReinH> Bounded + Enum doesn't play nice with anything, but it's the closest thing there is.
11:37:42 <geekosaur> (basic generics interface, not necessarily friendly)
11:37:50 <Cale> EvanR: what would the type of the operation be if you want to enumerate all the elements of a GADT?
11:38:09 <EvanR> foldAll :: (forall a . u a -> b -> b) -> b -> b
11:38:33 <EvanR> not general gadts, but singleton like
11:38:38 <M-berdario> Hi, I have some code that uses IO, and I want to split it into separate effects... Among other things, I'm using Wreq and Haskeline... If I create a `class (Monad m) => MonadHTTPGet m` I'd then have to carry around 3 constraints: MonadHTTPGet, MonadThrow (for `Wreq.asJSON`) and MonadException (for Haskeline)
11:38:48 <EvanR> really it might generalize to arbitrary inductivey things
11:38:58 <geekosaur> https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/base-4.9.0.0/Data-Data.html
11:39:07 <M-berdario> should I just make MonadHTTPGet a subclass of MonadThrow, to restrict the amount of typeclasses that I'll juggle around?
11:39:12 <M-berdario> what is the best practice?
11:39:23 <EvanR> ah Data.Data
11:39:42 <geekosaur> note that this is just the primitives; you can probably write a gfold using that, but I'd expect a canned one to be in a generics package built on this
11:40:11 <EvanR> goldl
11:40:12 <EvanR> gfoldl
11:41:27 <geekosaur> M-berdario, with the DataKinds extension you can create type synonyms for multiple typeclass constraints
11:42:01 <Fairy> Does anyone have an example of a Lambda parser that I could look at? Been stuck at this task for 12hrs now with zero progress :S
11:42:09 <M-berdario> geekosaur: do you think that's better than adding MonadThrow as a superclass?
11:43:06 <geekosaur> "superclass" isn't really a thing (it's more a prerequisite), but unless your typeclass is actually a MonadThrow with additional behavior at its core I would consider that the wrong direction
11:43:12 <ReinH> bollu: The fundamental duality of Haskell evaluation is constructing data and pattern matching. The free/cofree interpreter pattern is something similar at the level of whole programs, and a Pairing is what links the two together.
11:43:12 <Tuplanolla> If you're stuck on a single problem for such long periods of time, you're probably out of your depth and should revisit easier subjects, Fairy.
11:43:50 <geekosaur> that said, there are other viewpoints with justifications for them
11:44:19 <geekosaur> if MonadThrow is actually intrinsic to your class, then it's justifiable. if you can justify instances that are not MonadThrow, then it doesn't belong in the class definition
11:44:44 <ReinH> geekosaur: We'd like it to be a lattice construction, and we can sort of map the "superclass" notion onto lub.
11:44:57 <Fairy> Tuplanolla easier said than done :S
11:45:42 <ReinH> e.g., the lub of Eq and Num is Eq
11:46:09 <Tuplanolla> How so, Fairy? You can't exactly make a complicated parser without, say, `<*>` or `>>=`.
11:46:24 <ReinH> Or maybe I mean the meet, I guess you can flip it either way you want.
11:46:42 <Tuplanolla> I mean, you can, but it's not going to be useful or instructive...
11:46:52 <ReinH> What is a "Lambda parser"?
11:47:32 <M-berdario> geekosaur: yeah, I heard other describing that idea as subclass/superclass (even if it feels out of place in a FP context) and I start to use it...
11:48:10 <Fairy> Tuplanolla: well, the task specifically is designed to be solved without Monads
11:48:18 <M-berdario> I don't foresee myself using instances of MonadHTTPGet without MonadThrow, so I think it wouldn't be terribly bad in this context
11:48:33 <M-berdario> Fairy: are you talking about applicative parsers?
11:48:40 <geekosaur> I am somewhat leery of using OOP terms for typeclasses because it encourages people to think of them as a way to do OOP in Haskell, and that doesn't really work. (You can do OOP in Haskell if you really want to, but typeclasses are not the way to do it.)
11:48:53 <Fairy> ReinH it's a parser that can take a String such as, say "lambda x (x) (5);" and evaluate it to 5
11:49:09 <ReinH> That isn't (just) a parser.
11:49:45 <ReinH> geekosaur: fair point
11:49:59 <ReinH> geekosaur: I am in general leery of "sort of mappings" ;)
11:50:05 <Fairy> I pasted the relevant code chucks bit earlier: http://lpaste.net/5525186950530596864 but I think it was a bit too long for anyone to properly look at it and provide any useful feedback
11:50:37 <ReinH> Fairy: Are you working on parsing or evaluation? That's evaluation code.
11:50:53 <Fairy> parsing is completely done. evaulation is the issue
11:50:56 <ReinH> You can work on evaluation without a parser, and you can work on parsing without an evaluator.
11:51:14 <ReinH> Fairy: then why are you asking us about parsing?
11:51:33 <ReinH> What is your question about evaluation?
11:52:32 <ReinH> If you want useful feedback, try to prepare a useful problem statement.
11:56:30 <lpaste> Fairy pasted “No title” at http://lpaste.net/6110348593611145216
11:56:46 <Fairy> sorry, english isnt my frist language :S I need to expand my evaluator so that it can evaluate lambda functions such as these http://lpaste.net/6110348593611145216
11:59:15 <ReinH> @where write yourself a scheme
11:59:16 <lambdabot> I know nothing about write.
11:59:21 <ReinH> @google write yourself a scheme
11:59:21 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
11:59:38 <ReinH> Have you looked at this? It covers evaluation of a language with similar features in depth.
11:59:49 <ReinH> It's a bit old in some ways, but the basic ideas are still relevant
12:02:47 <ReinH> But basically you need to add a case for lambdas to eval and do the appropriate things with the bound variables.
12:03:49 <M-berdario> Fairy: what ReinH said... but also: can you use external libraries? if so, I'd use Data.Map for your Memory...
12:04:05 <M-berdario> if not, look at `lookup`
12:04:07 <M-berdario> @type lookup
12:04:09 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
12:05:30 <M-berdario> also, that definition of Context seems icky... and try to avoid stuff like `(\(Just x) -> x)` (which is also known as `fromJust`)
12:06:48 <ReinH> Lines 59 and 60 are bugs.
12:06:58 <ReinH> But they aren't currently in question
12:07:23 * maerwald is tempted to write a blog post about partial functions and why they are underrated
12:08:01 <ReinH> If your memory and environment lookups can fail, assuming they succeed is a bug.
12:08:03 <EvanR> one less (pretty large) thing to worry about if there arent any
12:08:44 <ReinH> Anyway, the Context type is inefficient but not *wrong*. It's denotationally correct.
12:09:20 <ReinH> And the question now is how to write case (Lambda var expr) -> 
12:09:26 <EvanR> i feel really stupid putting in a partial function, then later getting a runtime error
12:09:30 <EvanR> "shoulda known"
12:10:18 <Fairy> ReinH: pretty much
12:10:23 <EvanR> for any runtime error i think "how could this have been avoided"
12:11:09 <maerwald> EvanR: the lack of a proof assistant has made haskellers hate partial functions, understandbly. However, I'd rather have something fail at runtime (and possibly get catched by tests) instead of crippling internal API.
12:11:53 <EvanR> you could say its really bad to put one in your public facing API
12:12:01 <EvanR> different levels of badness
12:12:03 <ReinH> Also this evaluator is not typesafe.
12:12:36 <Fairy> the code assumes that everything is syntactically correct, it's not of any particular concern if it crashes on incorrect input
12:13:21 <maerwald> EvanR: well, public API is different... so IMO "head" was a mistake, because people should be annoyed to write "fromJust . head". But don't provide it per se.
12:13:48 <maerwald> it also makes you more aware of what you do
12:13:54 <ReinH> It crashes on correct input.
12:14:38 <Fairy> Oh?
12:15:56 <ReinH> That is, it crashes on legal statements.
12:16:00 <Fairy> (to clarify, trying to access a variable that hasn't been defined should result in an error)
12:16:00 <ReinH> e.g., invalid memory access
12:16:20 <ReinH> And you want that error to be a pattern matching failure?
12:17:09 <ReinH> Ok, setting that aside
12:17:11 <ReinH> App is broken
12:17:19 <ReinH> App assumes its first argument is an operator
12:17:25 <ReinH> but you are using it with a Lambda
12:17:26 <ReinH> this will crash
12:17:47 <ReinH> with a pattern matching failure on evalOp
12:17:55 <ReinH> because, as I said, this evaluator is not typesafe.
12:18:00 <Fairy> Correct, I need to put in an App (Lambda name stt) [expr]
12:18:31 <Fairy> or at least, that's the intention
12:18:45 <ReinH> Your lambdas only take one argument?
12:19:45 <ReinH> Ok, I mean, I'm not the one who wants to get a good grade on the assignment
12:19:47 * ReinH shrugs
12:20:01 <Fairy> it takes one lambda with one argument at a time, any number of new ones can exist inside the stt
12:20:46 <Fairy> "lambda x (lambda y (y, x)+ )" is a valid input
12:21:06 <ReinH> I would find it difficult to maintain all my proof obligations while working with this system
12:22:26 <ReinH> How do you know the difference between a pattern matching failure that is a bug and a pattern matching failure that is intended behavior?
12:22:30 <ReinH> You have to keep track of them in your head.
12:22:43 <ReinH> Explicit error handling is useful in part because it makes these cases distinct
12:23:08 <Tuplanolla> "At some point you run out of head."
12:23:17 <ReinH> Is that pattern match on Just a bug? Is it intended behavior? Will you remember which one is which later?
12:23:27 <EvanR> should just built it into the language imo, theres a term for bug, and a term for failure. use bug when you want to write bugs
12:23:50 <ReinH> Tuplanolla: And at some point you use your head for other things
12:24:13 <ReinH> and then you lose the context and have to try to recover it, usually with only partial success
12:24:54 <ReinH> So yes, I'm not surprised that you are finding this code difficult to work with, nor am I surprised that you are pushing back on suggestions to make it easier to work with while at the same time complaining that it is difficult.
12:26:01 <Fairy> I have a very poor understanding of how to give any useful error in Haskell - when I intially errored the shit out of every possible point of failure, working with those errors was a complete nightmare - right now, I have a valid syntax I can test against, and any error is immediately identified by me
12:27:08 <sgronblo_> hey is there any point to untagged unions like in C? i guess to use them effectively you have to manually implement your own tagged struct which containes them?
12:27:31 <EvanR> there is a point to C unions
12:27:35 <sgronblo_> this question came to my mind when trying to figure out why haskell requires ADTs to be tagged
12:27:51 <EvanR> tagged unions make more sense though
12:28:06 <EvanR> for example how would you tell the diff between Left "foo" and Right "foo" without the tags
12:28:07 <Fairy> sorry, I'm not trying to push back on advice - I very much understand the importance of error handling. It's just that in this scenario, I'm attempting to understand how I'm supposed to solve a given problem that I should be able to solve - yet I'm completely unable to effectively visualize what I'm supposed to do
12:28:08 <Tuplanolla> As soon as you forget what you put in the union, you can no longer retrieve it, sgronblo_.
12:28:16 <sgronblo_> EvanR: thats exactly my point
12:28:44 <EvanR> and in C you often put tags anyway
12:28:49 <ReinH> Fairy: yes, and I'm saying that the state of our current codebase is contributing to your problem
12:28:52 <ReinH> s/our/your
12:28:55 <Tuplanolla> The only exception is when they both happen to have the same type, but then the union is pointless, sgronblo_.
12:29:06 <ReinH> If your code was easier to reason about, your problem would be easier to reason about
12:29:10 <sgronblo_> i guess the question should have been something like can c unions be useful without being wrapped in a struct that contains a typetag?
12:29:19 <ReinH> Yes, in C.
12:29:23 <EvanR> yes, that is used for tricky type casting tricks
12:29:23 <geekosaur> sgronblo_, Haskell requires tags for pattern matching by structure. C unions serve a different use case: generally either saving space in memory-limited ABIs (e.g. passing data between kernel and userspace) or talking to device interfaces
12:29:26 <dolio> There's a point to untagged unions, too, but C unions are more like unsound unions.
12:29:56 <geekosaur> s/by structure/on structure/
12:30:01 <EvanR> if theres more than one way to look at the bits of a thing in C, you could use a union of the ways
12:30:32 <EvanR> in haskell we dont think of that by default
12:31:19 <EvanR> more than one way to look at a thing is a function, not a union
12:31:44 <Fairy> ReinH: Sorry :S
12:32:17 <ReinH> Fairy: if you want to add a case for applying lambdas to eval, you have to reason about every interaction with all the partial functions you're using.
12:32:43 <ReinH> It becomes more and more difficult to extend a system like this, until eventually it is too difficult to add the thing you want.
12:33:16 <ReinH> That's usually when professional programmers say "hey refactoring is a really good idea let's do some of that". ;)
12:33:34 <ReinH> Ideally we try to do it more regularly, to keep these costs low throughout.
12:34:12 <sgronblo_> geekosaur: yeah i know you can save memory by using them? but can you still use them even without storing which of the union types are "currently in use"?
12:34:36 <geekosaur> usually the tag is detached somewhere, unless you're using them as the C equivalent of unsafeCoerce
12:34:43 <EvanR> yes, like i said you could look at the same bits in different ways
12:34:43 <ReinH> Even replacing pattern matching failures with a default case with a meaningful error message would be helpful.
12:34:56 <sgronblo_> EvanR: same bits in different ways?
12:35:10 <EvanR> yep, bits are encodings of data, they dont have an inherent value, its subjective
12:35:18 <geekosaur> in a device interface, there is generally a control register and a data register, and the layout to use for the data register depends on the value written to the command register
12:35:33 <ReinH> e.g., evalOp badOp = error ("error: " ++ show badOp ++ " is not an operator")
12:36:09 <ReinH> at least this would prevent you from having to manually unwind the stack every time to figure out where the error came from
12:36:30 <geekosaur> so there is still a union tag, but it's detached and usually has some additional meaning
12:37:12 <EvanR> you could have 8 1-byte values, but its also 4 2-byte values
12:40:05 <sgronblo_> EvanR: yeah, but what does that have to do with the union question?
12:40:21 <geekosaur> that's the unsafeCoerce usage of unions
12:40:32 <geekosaur> you often find that when marshaling/unmarshaling values
12:41:12 <Fairy> ReinH: ok, done so for most of the functions
12:42:43 <EvanR> sgronblo_: right... you could put char[8] and char[4][2] fields in the union and no tag. ive seen this done instead of casts
12:43:00 <EvanR> er
12:43:07 <EvanR> short[4]
12:43:47 <geekosaur> another example of an "untagged" union which has a detached tag: most *nix filesystems have an optimization where short file contents (the target of a symlink, for example) will fit within the space used to store the allocated block pointers for a file. the interpretation of this is controlled by a flag bit elsewhere in the inode
12:43:50 <EvanR> char[4][2] also works, its a matrix with another shape
12:44:06 <sgronblo_> EvanR: but how do you know when its safe to use it as char[8] and when its safe to use it as char[4][2]?
12:44:10 <EvanR> always
12:44:28 <sgronblo_> oh really, so there are some special cases like that?
12:44:40 <geekosaur> it's always safe in the sense that it won't dump core. whether its; semantically meaningful, yoru program must determine somehow
12:44:48 <EvanR> thats what i meant, if its always safe to look at some bits in different ways, such and such. just like its always safe to use view functions on a source value in haskell
12:45:17 <EvanR> if you are using it as a sum type, then theres obviously cases where its not safe to look at it a certain way
12:45:25 <Tuplanolla> I like the way you're surprised that doing something in C can be safe, sgronblo_.
12:45:30 <geekosaur> although you can get cases where it's not always safel for example a C (float) and (int) in most ABIs will fit in the same space, but while any bit pattern is legal for (int), some bit patterns for (float) will cause a floating point exception if accessed by the FPU
12:45:51 <EvanR> float ruins the show again
12:48:08 <sgronblo_> its not about being safe in C, its just about the case of storing a crocodile or a bunny in a box and when to know when its safe to put your hand in there
12:48:12 <geekosaur> or you can union a pointer and an int/long together, but not all numeric values are legal pointers (and whether it is legal may depend on the pointer type)
12:48:49 <Tuplanolla> The byte array reshaping is about the only portable thing you can do there, sgronblo_.
12:49:17 <geekosaur> in any case, it;s up to the program code to verify this. or to not do so and possibly get terminated by a signal or produce garbage. C happily lets you do this, since you sometimes need to do it for systems level programming.
12:49:26 <geekosaur> (as with the device control example)
12:49:57 <EvanR> sgronblo_: youre thinking specifically about sum types, which requires a tag.
12:50:43 <EvanR> C unions (without tags) dont really have anything to do with that
12:51:34 <MarcelineVQ> https://www.youtube.com/watch?v=Iu19igk-qsk :>
12:52:29 <ReinH> sgronblo_: Didn't you just make an argument for tagged unions?
12:53:38 * hackagebot hsinstall 1.5 - Install Haskell software  https://hackage.haskell.org/package/hsinstall-1.5 (DinoMorelli)
13:17:26 * Fairy stares into the abyss while hugging her teddy
13:18:08 <lyxia> Is that a side-effect of writing Haskell
13:21:16 <geekosaur> side effect of trying to stretch your mind just a bit too far too fast >.> 
13:21:56 <Fairy> How come Haskell is so difficult compared to Object-oriented languages? It only took me a month to grasp Java for the first time
13:22:33 <tom7942> oo is imperative
13:22:59 <geekosaur> you're trying to get a grasp of the functional programming paradigm, laziness, use of higher order functions, te somewhat weird way IO works, etc. all at the same time
13:23:22 <Cale> Fairy: What languages did you know before Java?
13:23:44 <Fairy> Cale: None. Java was my first intro into programming
13:23:46 <geekosaur> and some of those things work so differently from what you already know that what you already know is interfering with learning the new stuff
13:24:08 <hpc> it took me about a month to learn enough haskell to make an irc bot, and a lot of it was spent unlearning little assumptions from other languages
13:24:24 <hpc> that's probably what you're having trouble with?
13:24:48 <Tuplanolla> I found Java to be much harder to learn initially, Fairy. It has all these dark corners like type erasure and static inner classes.
13:25:53 <ertes> Fairy: language difficulty vs. problem difficulty:  OO is "easy" in the sense that it's easy to explain, not easy to *use*
13:27:02 <Tuplanolla> Locking and serialization are also horribly complicated.
13:28:30 <ertes> Tuplanolla: huh?  haskell has type erasure, too, or is that a different thing?
13:28:39 <ertes> in fact i'm pretty sure haskell is even more rigorous
13:28:58 <hpc> ghc has type erasure, but in a way that it matters significantly less
13:29:06 <hpc> because there is no type-case in haskell
13:29:18 <hpc> in java it's the instanceof keyword
13:29:37 <ertes> well, haskell has no built-in dynamic dispatch, but if you were to program that, you need Typeable
13:29:52 <ertes> (or some other means of preserving type information)
13:30:12 <ertes> most OO languages have an implicit Typeable constraint on every type variable
13:30:16 <haasn> Oh wow, reading the GHC 8.0.1 release changelog is like christmas came early. I'm not sure which feature I'm most excited about, but it's probably -XTypeInType
13:30:29 <hpc> and Typeable is almost type "un-erasure", since it ends up with a class dictionary existing at runtime with the type information
13:30:32 <geekosaur> I would argue that typeclasses are typecase. but principled and implemented in a way such that type erasure doesn't matter
13:31:30 <hpc> geekosaur: they do something similar, but you can't directly do "if type is X then foo else if type is Y then bar"
13:31:42 <hpc> which i consider the distinguishing factor for typecase
13:31:51 <geekosaur> true, that's part of what I meant by principled
13:32:05 <hpc> java has interfaces which are similarly principled
13:32:08 <geekosaur> you czn;t do arbitrary things, you have to advertise what you can do in the class definitoon
13:32:36 <hpc> and really interfaces should have totally subsumed instanceof in java
13:33:00 <geekosaur> which means it's a lot easier to figure out what typeclass code does than it is to figure out what code that might use instanceof does
13:33:09 <Cale> haasn: 8.0.2 is the one I'll be *really* happy about -- deterministic builds will mean that we can build with -j8 using nix
13:33:20 <geekosaur> (there's also an analogy to purity there...)
13:33:22 <haasn> That also sounds nice
13:33:47 <lispy> Cale: what is new in 8.0.2 that does that?
13:34:04 <Cale> https://ghc.haskell.org/trac/ghc/ticket/4012
13:34:38 <lispy> Cale: ah, interesitng
13:48:21 <ertes> type-classes are not really type-case, at least not in the OO sense, because instance resolution and thus "dispatch decisions" are made at compile time…  type-case depends on a "representation type", which is just a type that doesn't vary (like TypeRep)…  that's why Integral could (in principle) do type-case (via the Integer in toInteger), while e.g. Monoid could not
13:48:35 <ertes> i'm happy to call type classes "principled overloading" though
13:53:40 * hackagebot pandoc-types 1.17 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.17 (JohnMacFarlane)
13:56:59 <dolio> What does type case have to do with OO?
14:02:51 <hpc> it has to do with type erasure which has to do with learning java
14:07:59 <ertes> dolio: i'd call dynamic dispatch an OO thing intuitively
14:09:38 <lpaste> tippenein pasted “expected record (:*:)” at http://lpaste.net/268432
14:10:09 <tippenein> what is this aeson error message referring to?
14:10:14 <tippenein> (:*:) ?
14:11:04 <puregreen> (:*:) comes from generics
14:11:21 <puregreen> I've never seen this error before
14:12:11 <tippenein> ahhhh, probably DeriveGeneric pragma?
14:12:15 <puregreen> can you paste a full example so that I could play with it?
14:12:31 <puregreen> usually the generic instances work fine and don't throw such weird errors
14:12:32 <EvanR> ertes: right, dynamic dispatch is somewhere in the bucket labeled OOP of a universe of unrelated things
14:13:13 <EvanR> but really first class functions is about as dynamic dispatch as you can get
14:14:01 <EvanR> in which case you can abuse the hell out of jargon and say FP is OOP done right, which is clearly nonsense, reductio absurdum
14:14:24 <geekosaur> tippenein, I don't think you want show in decodeTxt
14:14:32 <geekosaur> that's probably where it is seeing the String
14:14:36 <lpaste> tippenein pasted “full parse error example” at http://lpaste.net/268438
14:14:48 <geekosaur> use T.unpack instead
14:15:29 <geekosaur> show will be wrapping the value in extra quotes, C.pack doesn't unwrap that, and that is likely what's getting a parse error when it sees a string instead of a record
14:17:13 <tippenein> *thumbs up* thanks geekosaur 
14:17:26 <ertes> EvanR: even with higher order functions the decision is usually made statically, isn't it?  i rarely find myself choosing the function argument from a list of functions (although i made be doing that sometimes without really thinking about it)
14:17:57 <ertes> s/made/may/
14:25:19 <haasn> Cale: re: that bug report, am I right in understanding that this only affects _determinism_, not functionality? so for a user of non-nix, I can still use -j to speed up builds?
14:25:42 <haasn> I'm asking because I noticed portage doesn't use any parallelism, which means GHC builds take an hour on my end
14:25:46 <geekosaur> hm. got disconnected, maybe didn't get through.
14:25:58 <geekosaur> you probably want encodeUtf8 instead of C.pack . T.unpack
14:26:00 <haasn> Actually it does seem to do *some* things with parallelism, not all
14:26:49 <grantwu> Is it possible to specify GHC options for a single module in a .cabal file?
14:27:06 <geekosaur> grantwu, no
14:27:14 <dcoutts> grantwu: yes, in the .hs file with a {-# OPTIONS_GHC -fblah #-}  pragma
14:27:16 <geekosaur> generally you use an OPTIONS_GHC pragma in the module
14:27:38 <M-berdario> Weird... I'm using stack with stackage lts 7.3, but `stack ghci` runs version 7.10 (instead of 8)
14:27:55 <grantwu> ooh, thanks
14:28:09 <Tuplanolla> There's `OPTIONS` too for some reason.
14:28:31 <sgronblo_> EvanR: the point im trying to make is that it seems useless to use raw untagged unions
14:28:50 <sgronblo_> without wrapping them in a struct, effectively making them tagged unions
14:29:20 <geekosaur> I gave an example where the tag is not as simple as that
14:29:56 <geekosaur> it's still "tagged" but you need to be more clever about where the tag is sometimes; C unions let you do that
14:30:19 <dolio> There are formal type systems with untagged unions.
14:30:29 <dolio> So they probably aren't useless.
14:30:41 <Tuplanolla> My favorite is storing the tag in the user, geekosaur.
14:32:08 <dolio> Same as intersection types aren't useless.
14:32:36 <sgronblo_> geekosaur: did I understand you correctly that you can sometimes make use of non-struct-wrapped c unions under some cases where we are going through a kind of state machine so we know what kind of value to expect based that?
14:33:16 <dolio> And ∃ and ∀ are like infinitary versions of union and intersection, yet we don't find them useless, either.
14:34:02 <grantwu> geekosaur: dcoutts: Thanks
14:34:03 <geekosaur> I don't think I said specifically that although someone else may have. I did say it's up to your program to know, and that would be one way for it to know. another is when it's using a union for marshaling, and which part of the union it uses when is determined by whether it is marshaling or demarshaling
14:34:09 <puregreen> tippenein: I reported the confusing error: https://github.com/bos/aeson/issues/474
14:35:05 <geekosaur> *unmarshaling
14:35:56 <tippenein> puregreen: did you figure out the culprit in the larger example?
14:37:27 <tippenein> actually. I think the way I'm sending SQS messages is confusing the parser
14:37:29 <puregreen> tippenein: in the larger example it's the same thing really – when you do “C.pack . show”, what you get is string "\"{\\\"s3_key\\\": \\\"stuff\\\"}\""
14:37:54 <puregreen> which is seen by aeson as a string value "{\"s3_key\": \"stuff\"}"
14:38:06 <tippenein>  Error in $: Failed reading: satisfy" <- also get this now
14:38:13 <puregreen> not as an object {"s3_key": "stuff"}
14:38:28 <puregreen> so it expects an object, sees a string, and fails
14:38:32 <tippenein> decodeTxt works in ghci, so I'm good with it
14:38:42 <geekosaur> right, that was what I was trying to say earlier
14:38:54 <geekosaur> also encodeUtf8 is better to go from Text to ByteString
14:40:09 <tippenein> it expects lazy bytestring
14:40:31 <puregreen> tippenein: there's a lazy variant
14:40:41 <puregreen> in Data.Text.Lazy.Encoding
14:41:27 <puregreen> there's also eitherDecodeStrict to decode a strict bytestring
14:42:43 <tippenein> the encodeUtf8 in Data.Text.Lazy.Encoding is for lazy text
14:43:01 <tippenein> that was the first thing I tried
14:43:37 <puregreen> oh well, then eitherDecodeStrict it is
14:44:05 <tippenein> hoogle is deceiving that way
14:44:45 <tippenein> I searched Text -> ByteString and got all the different encodeUtf8 variants, but it doesn't say which is lazy and which is strict
14:45:22 <geekosaur> that's actually a haddock issue, I think.
14:45:52 <tippenein> heh, haddock has a lot of issues
14:46:11 <MarcelineVQ> Check the module name if you'r eunsure, often modules will say Strict or Lazy
14:46:25 <geekosaur> well, maybe more correctly how it runs haddock. it is possible to request it to include fully qualified types instead of the basenames
14:46:39 <geekosaur> (or rather the type name without the module)
14:53:41 * hackagebot aur 6.0.0 - Access metadata from the Arch Linux User Repository.  https://hackage.haskell.org/package/aur-6.0.0 (fosskers)
14:55:14 <mahdi> Hey, when uploading packages there is a warning "Use of unallocated top-level name X". Is using an unallocated top-level name a bad practice? If so, where can I find a list of available top-level names, I couldn't find any searching through docs
14:56:25 <tippenein> It seems like pandoc should be able to read ebook metadata, but Ive been unable to find anything about it
15:04:14 <ydl> why is the type of callCC not "((a -> m b) -> m c) -> m a" given that it can be implemented "callCC f = Cont $ \k -> runCont (f $ \a -> Cont $ \_ -> k a) k"? the type in base is the more restrictive "((a -> m b) -> m a) -> m a". is this convention?
15:05:05 <int-e> mahdi: there's https://wiki.haskell.org/Hierarchical_module_names but I don't know what the check done by hackage is exactly.
15:05:58 <ydl> where in my case of course m a ~ Cont r a
15:06:57 <mahdi> int-e: I see, that's a good source, thanks
15:07:38 <int-e> mahdi: https://github.com/haskell/hackage-server/blob/master/Distribution/Server/Packages/Unpack.hs#L311-L316 looks like the actual list
15:08:00 <lispy> ydl: I've never looked into that before. Have you tried making a version with the more general type to see what happens?
15:09:07 <mahdi> int-e: oh, that's probably the latest list available, thanks!
15:10:03 <ydl> lispy: not sure what you mean. like examples?
15:10:22 <lispy> ydl: You could define your own callCC with the type you are proposing and then yeah, try examples
15:12:11 <ertes> ydl: your callCC can be expressed in terms of the standard one:  ydlCC f = callCC (\k -> f k >>= k)
15:12:44 <ertes> :t \f -> callCC (\k -> f k >>= k)
15:12:46 <lambdabot> MonadCont m => ((a -> m a) -> m a) -> m a
15:12:50 <ertes> uhm
15:13:10 <ertes> oh, not quite
15:13:13 <Koterpillar> I think there should be a _ somewhere
15:13:59 <ertes> if you're going to go there, callCC's type should be:  callCC :: (MonadCont m) => ((forall r. a -> m r) -> m b) -> m a
15:14:44 <ydl> i got disconnected for a second so maybe i missed a message in the discussion, but although i thought what i wrote was equivalent to the callCC defined in transformers/mtl, what i wrote is exactly the code. so for some reason an unnecessarily specific type was chosen
15:15:01 <ydl> i'm just trying to understand why.
15:15:30 <ydl> ertes: i actually agree, i was just trying to keep the typeclass momentarily out of it, since the only thing that matters is the ContT implementation of callCC (everything else is done by lifts of that function)
15:16:21 <ertes> yeah, it's not really relevant…  i just wanted to write 'm' instead of (ContT r m) with the appropriate constraint =)
15:16:49 <ertes> in any case, callCC's type is rather unfortunate, yeah
15:16:53 <ydl> makes sense :) so is there a natural explanation?
15:17:35 <ertes> i don't think so…  maybe ContT is just older than RankNTypes
15:18:35 <ydl> but even without RankNTypes you could write callCC :: (MonadCont m) => ((a -> m r) -> m b) -> m a, right?
15:19:16 <EvanR> MonadFoo classes are probably newer than Cont too
15:19:38 <ertes> hmm, can you?
15:19:52 <EvanR> and taking that forall out doesnt seem equivlant
15:20:44 <ydl> EvanR: without the MonadFoo classes, my original question applies and couldn't you write callCC :: ((a -> Cont r b) -> Cont r c) -> Cont r a
15:20:45 <ertes> :t \f -> ContT (\k -> f (\x -> ContT (\_ -> k x)))
15:20:47 <lambdabot> forall k a (r :: k) (m :: k -> *) a1. ((a -> ContT r m a1) -> m r) -> ContT r m a
15:21:19 <ydl> ertes: you need some runContTs in there
15:21:24 <ertes> :t \f -> ContT (\k -> runContT (f (\x -> ContT (\_ -> k x))) k)
15:21:26 <lambdabot> forall k a (r :: k) (m :: k -> *) a1. ((a -> ContT r m a1) -> ContT r m a) -> ContT r m a
15:21:43 <ertes> ydl: i'm not so sure that you can…
15:22:25 <ydl> :t \f -> Cont $ \k -> runCont (f $ \a -> Cont $ \_ -> k a) k
15:22:26 <lambdabot> error:
15:22:27 <lambdabot>     • Data constructor not in scope: Cont :: ((t2 -> r) -> r) -> t
15:22:27 <lambdabot>     • Perhaps you meant one of these:
15:22:37 <ertes> i think the forall really needs to be in there, but i don't see a way to differ between the types of the function's result and the overall action's result
15:22:53 <EvanR> ydl: regarding the c  there... since the action may not use the continuation, seems like ithas to be equal to a
15:23:15 <ertes> if you want to *force* the function to use the continuation, you have to have another forall
15:23:52 <ertes> onlyContCallCC :: (MonadCont m) => (forall r. (forall r'. a -> m r') -> m r) -> m a
15:24:00 <EvanR> interesting
15:24:13 <ertes> but that seems like an unnecessary constraint
15:25:09 <EvanR> that r there, still seems like it needs to equal a
15:25:33 <ertes> EvanR: onlyContCallCC will instantiate it at 'a'
15:25:45 <EvanR> oh
15:25:59 <ertes> but now the user can no longer just return the result…  the only way to leave the action is to use the continuation
15:26:49 <ghasea> does anyone know how to run djinn?
15:26:58 <ghasea> I tried installing it using cabal
15:27:02 <ghasea> djinn-ghci package
15:27:20 <ertes> EvanR: oops, no…  i was wrong about the instantiation…  it will instantiate it at the overall result type:  the 'r' in (ContT r m a)
15:28:59 <ghasea> @hoogle [a] -> [a]
15:29:00 <lambdabot> Prelude tail :: [a] -> [a]
15:29:00 <lambdabot> Prelude init :: [a] -> [a]
15:29:00 <lambdabot> Prelude reverse :: [a] -> [a]
15:29:58 <ertes> :t (\f -> ContT (\k -> runContT (f (ContT . const . k)) k)) :: (forall x. (forall x'. a -> ContT r m x') -> ContT r m x) -> ContT r m a
15:29:59 <lambdabot> forall k a (r :: k) (m :: k -> *). (forall x. (forall x'. a -> ContT r m x') -> ContT r m x) -> ContT r m a
15:30:12 <ghasea> @djinn-add type Rule m a = (m -> a) -> a
15:30:54 <ghasea> @djinn a -> a
15:30:54 <lambdabot> f a = a
15:31:17 <ydl> ertes, EvanR: so you guys are right, i can't get GHC to accept callCC' :: ((a -> Cont r b) -> Cont r c) -> Cont r a . can you explain why? it doesn't seem like i need c ~ a but ghc insists
15:31:59 <ertes> ydl: example:  callCC (\k -> pure x)  -- what is this supposed to return?
15:32:10 <ydl> with, as before, the simple callCC' = \f -> cont $ \k -> runCont (f $ \a -> cont $ \_ -> k a) k
15:32:38 <ghasea> @djinn type Testa e = e [] Integer
15:32:38 <lambdabot> Cannot parse command
15:32:46 <ghasea> @djinn-add type Testa e = e [] Integer
15:32:46 <lambdabot> Cannot parse command
15:32:57 <ertes> ydl: remember that the function can actually ignore its continuation
15:33:07 <Tuplanolla> You can private message lambdabot, ghasea.
15:34:07 <ertes> ydl: in other words: if you don't assume a = c, what does callCC do, if the function simply returns?
15:34:58 <joaraanew> what would be an example function to return the following type declaration |||| type Testa e s =  e s [] Integer
15:35:07 <ertes> now you have a value of type 'c', but you can neither assume c = a and return it, nor can you assume c = r and end the overall ContT action
15:35:46 <Fairy> ReinH: I'm a drooling idiot, I see what you saw now, that code was way past terrible. And here I was about to give up
15:35:58 <EvanR> well, my brain just exploded trying to figure the cont thing out. 
15:36:09 <EvanR> good luck!
15:36:45 <ydl> ertes: i don't see how this is a problem. shouldn't the type of f be enough to do the logic you are talking about?
15:37:38 <joaraanew> anyone any idea, Im honestly lost for what that type means |||| type Testa e s =  e s [] Integer
15:39:09 <ertes> ydl: no, because now callCC has a problem:  it holds a value of type 'c', but it can't really do anything with it…  nothing unifies with 'c'
15:39:57 <EvanR> joaraanew: well, its a type synonym with 2 parameters
15:40:16 <EvanR> its a little enigmatic because `e' itself takes 3 parameters
15:40:23 <EvanR> and we know nothing else about it
15:40:46 <ertes> ydl: remember that all type arguments are chosen by the user of callCC:  you're trying to allow them to choose c ≠ a, but if you do that, the function may actually *result* (without k) in such a value
15:41:00 <EvanR> apparently the second argument of e takes 1 parameter, hence the [] (the type constructor for lists)
15:41:14 <Cale> haasn: You can use -j so long as you don't care about the exact hash of the resulting binaries
15:41:16 <ydl> ertes: but if f k = return x with x of type a, f has type ((a -> m c) -> m a), and substituting the definition of return x gives: callCC (\k -> return x) = cont $ \k -> runCont (return x) = return x
15:41:36 <ydl> so that's fine, callCC holds a value of type a, not c?
15:41:44 <EvanR> joaraanew: you can think of type snonyms as a limited kind of function on types
15:41:58 <ertes> ydl: there are only two ways in which callCC can proceed:  either using its own k (which is equivalent to "returning"), or by ignoring its own k and ending the overall action
15:42:54 <ertes> ydl: look at the example:  callCC (\_ -> pure x)  -- here (x :: c)
15:43:13 <ertes> but you can assume neither c = a nor c = r
15:43:57 <ertes> ydl: the only thing you can do is to *force* the function to use the continuation such that the example itself is ill-typed…  in that case you need a rank 2 type
15:44:07 <ertes> (the rank-3 version of callCC is merely a convenience)
15:44:10 <joaraanew> EvanR: how do you say that e itself takes in 3 params?
15:44:36 <EvanR> joaraanew: e :: * -> * -> * -> *
15:44:50 <EvanR> er
15:44:52 <ydl> hmm. but i thought equational reasoning was supposed to hold in haskell? then i can prove callCC (\_ -> return x) = return x from only the definition. then shouldn't it be possible to infer c ~ a?
15:44:52 <EvanR> actually
15:45:09 <ertes> ydl: exactly
15:45:40 <joaraanew> EvanR: I get that something siple like || type Testaaaa a = [a] || is a list of type a like int so I can easily define a function for it like
15:45:51 <ertes> ydl: that's why you can only use your proposed type, if you actually constrain it by (c ~ a)
15:45:59 <joaraanew> EvanR: testReturn a :: Testaaaa a
15:46:08 <ertes> ydl: in other words: they are really the same type
15:46:46 <Tuplanolla> With `type Test e s = e s [] Integer` you can do this, joaraanew: `StateT (\ x -> [(0, x)]) :: Test StateT ()`
15:46:48 <ertes> ydl: remember that without the constraint your callCC definition *promises* that it will work for any 'a' and any 'c'
15:47:00 <Tuplanolla> That's a strange type synonym though.
15:47:03 <EvanR> joaraanew: just like Testaaaa, what Testa expands to depends on what the parameters are
15:47:26 <ydl> ertes: ah, i see now. if i had been able to write myCallCC :: (forall c. (a -> Cont r b) -> Cont r c) -> Cont r a, which means i am not forcing myCallCC to work with all c but the function it's given to work with all c, it should work
15:47:28 <ertes> ydl: it's like writing (const :: a -> b -> c), a promise…  but the actual function definition (const x _ = x) doesn't live up to the promise, so GHC rejects it
15:48:03 <joaraanew> EvanR: alright, and how should I read [] and Integer together?
15:48:15 <ertes> ydl: yeah, and that's the rank-2 variant i was talking about, but that one is actually a different thing
15:48:25 <ertes> ydl: that one *forces* the function to use the continuation
15:48:26 <joaraanew> EvanR: previosult Testaaa [a] was simple to read but [] is an empty list
15:48:42 <joaraanew> EvanR: previously*
15:49:28 <EvanR> [] is not an empty list here
15:49:47 <EvanR> [a] can also be written [] a
15:50:03 <joaraanew> EvanR: got it, so basically it means a list of integers
15:50:18 <EvanR> [] :: * -> *
15:50:25 <EvanR> no
15:50:28 <ertes> ydl: note that the example (callCC (\_ -> pure x)) is ill-typed with the rank-2 version
15:50:36 <ertes> ydl: unless x = undefined
15:51:09 <EvanR> Test e s = e s [] Integer  = ((e s ) []) Integer
15:51:26 <EvanR> no [Integer] going on here
15:53:42 * hackagebot sparse-linear-algebra 0.1.0.0 - Sparse linear algebra datastructures and algorithms  https://hackage.haskell.org/package/sparse-linear-algebra-0.1.0.0 (ocramz)
15:53:44 * hackagebot sibe 0.2.0.0 - Machine Learning algorithms  https://hackage.haskell.org/package/sibe-0.2.0.0 (mdibaiee)
15:53:47 * hackagebot choose 0.1.0.0 - Choose random elements from a stream.  https://hackage.haskell.org/package/choose-0.1.0.0 (chris_martin)
15:53:48 * hackagebot choose-exe 0.1.0.0 - Command-line program to choose random element from a stream.  https://hackage.haskell.org/package/choose-exe-0.1.0.0 (chris_martin)
15:53:54 <EvanR> e s may make use of [] and Integer in some way, we dont know
15:54:35 <joaraanew> EvanR: alright, thanks
15:55:39 <ydl> ertes: i think i'm starting to understand, in the sense i can work through it formally. no intuition yet though :) the closest i can get is just listing the inputs i would like, either something that ignores the (a -> m b) and gives me something in m a or something that uses the (a -> m b) to give me an m a, but something still feels incomplete :)
15:58:45 <ertes> ydl: ContT is all about "continuation" or "exit" paths, any ContT action has two options:  either the "overall result" type or the "individual result" type, and that's basically all ContT is…  if you keep that in mind, ContT becomes surprisingly simple and natural =)
15:59:22 <ertes> ydl: honestly i've actually never used callCC, but i do use ContT a lot
16:01:13 <ydl> ertes: i have some experience with scheme, so ContT is quite natural already, i'm more interested in learning about how to reason around more complex types. using the intuition of what ContT is actually makes the type very clear, of course if you think of callCC has handing you a local exit you want ((a -> m b) -> m a) -> m a since you want the computation to result in an m a regardless of how you exit. then the definition follows from
16:01:13 <ydl> the types or the intuition. my confusion was in what is the best way to go backward from the definition to the types.
16:02:08 <credditor> Hey, can anyone help me conceptualize a haskell problem I'm trying to figure out?
16:02:35 <glguy> It's possible that someone could, but you'll have to ask the question first.
16:03:34 <credditor> So I'm trying to write a function that'll take in an integer dollar amount and return a 4 element tuple. The tuple contains the amount of 20s,10s, 5s, and 1s that'd it take to sum up to the integer amount
16:03:42 <credditor> dollar :: Integral a => a -> (a,a,a,a) dollar i = 	if i < 0 then error "no negatives allowed" 	else if i == 0 then (a,b,c,d)     else if i > 20 then i = -20 a = a +20     else 2
16:03:55 <credditor> So far I have that, but I have no clue where to go from there. If I can'
16:04:17 <credditor> cant't hold the value of variables, how can I count down from i or store the amount of 20s/10s/5s/1s
16:04:17 <ertes> ydl: the description you just wrote is exactly the intuitive reasoning i was going with…  are you looking for a kind of "higher intuition"?  because i didn't have one either
16:04:40 <intothemountains> If some argument I take has the matemathical properties of a set, should I go for the correctness of using a set or the pragmatism of using a list?
16:05:10 <ydl> ertes: and although i can now see why it must be true that callCC has to have that type signature, it's still hard to see from the definition. I guess especially because as we have discussed it is ambiguous, with different types giving different behavior of the function (i.e. ambiguity in types is not just more vs less general). that's not something i'm used to.
16:05:17 <credditor> I'm looking for a general solution, I have the first 2 conditions handled (negative int or no $), but I don't know how to work an actual dollar amount 
16:05:27 <EvanR> intothemountains: really, a Set isnt completely mathmeatical either
16:05:43 <EvanR> so it comes down to what your pragmatism demands
16:05:57 <ertes> credditor: have you settled on the algorithm you want to use?
16:05:58 <ydl> ertes: i guess i'd like to be able to look at the definition and infer the "right" type myself, but when it's not unique that's impossible so i guess i don't even know what i want :)
16:06:03 <intothemountains> EvanR: what do you mean?
16:06:21 <ertes> ydl: it's unique, if you ignore -XRankNTypes =)
16:06:26 <intothemountains> Forget about "mathematical", if the collection I have has the properties of a set?
16:06:59 <ertes> ydl: and i think letting GHC tell you the type and then figuring out *why* it has that type is not a bad way to learn to come up with those types yourself
16:07:37 <ertes> ydl: when reasoning about higher-rank types you almost always want to have some domain-specific knowledge
16:07:51 <ertes> the reason why i came up with the rank-2 version is because i was using the "exit path" intuition
16:07:52 <credditor> @eretes well, I've only used OOLs, so what I really want to do is something like while (i<20) { i = i-20, #of20s++ } ect.
16:07:52 <lambdabot> Unknown command, try @list
16:08:36 <credditor> @eretes but I know that won't work in this case, because haskell can't do that kind of iterating. 
16:08:36 <lambdabot> Unknown command, try @list
16:08:38 <ertes> ydl: "so if the function can't make any assumptions about the type of the natural exit path, it can't exit naturally"
16:09:00 <credditor> eretes: well, I've only used OOLs, so what I really want to do is something like while (i<20) { i = i-20, #of20s++ } ect.
16:09:19 <ertes> credditor: it can…  it's just important that you know what algorithm you want to use…  now write a function that implements that algorithm for a specific coin type
16:09:37 <ertes> credditor: (that function is actually predefined, but write it anyway, as an exercise)
16:09:49 <credditor> like for quarters?
16:09:54 <ertes> credditor: yeah, for example
16:09:59 <credditor> umm
16:10:24 <EvanR> intothemountains: it might not even be a choice between list and Set
16:10:58 <intothemountains> EvanR: could you expand on that?
16:10:59 <EvanR> what properties are you trying to preserve
16:10:59 <ertes> credditor: you could use this type:  coinCount :: Integer -> Integer -> (Integer, Integer)
16:11:10 <intothemountains> uniqueness and being unordered
16:11:40 <ertes> credditor: coinCount 25 180 = (7, 5)
16:11:58 <credditor> why 25 180?
16:12:01 <credditor> why 2 vars?
16:12:29 <EvanR> intothemountains: if thats it, and youre not trying to do more efficient membership testing, then a list is probably more practical
16:12:36 <ertes> credditor: the first is the coin type (IIRC quarters are 25 cents), the second is the amount of cents
16:12:43 <credditor> got it
16:13:08 <credditor> yeah so first roadblock
16:13:20 <credditor> lemme write this out in psuedo code at least so it makes sense
16:13:23 <EvanR> intothemountains: to clarify from earlier, Set requires the elements to be comparable and cant be infinite
16:13:33 <ertes> credditor: let me just guide you
16:13:40 <credditor> alright cool
16:13:44 <intothemountains> EvanR: oh, I didn't consider that
16:13:44 <credditor> coinCount :: Integer a -> Integer -> (Integer, Integer)  coinCount a =   if a == 0 then  
16:14:00 <credditor> that's what i have atm, where the first if is supposed to be a recursive base case
16:14:08 <intothemountains> But yes, in he particular case I'm interested in, it would also have those to propierties
16:14:16 <credditor> if we can do it without recursion that'd probably be better for an introduction
16:14:24 <ertes> credditor: first figure out what the result should be, if the coin type is too large:  coinCount d x | d > x = (_q, _r)
16:14:38 <intothemountains> EvanR: Do you know if there are there any plans of having a more "inbuild" support of sets?
16:14:58 <ertes> credditor: _q is the number of coins, _r the remaining value
16:15:04 <EvanR> intothemountains: for a public facing API, id just accept a list and say "i am ssuming there no duplicates here"
16:15:05 <credditor> alright
16:15:11 <ertes> credditor: _q = ?
16:15:14 <credditor> can you explain d x | d > x?
16:15:24 <ertes> read "|" as "if"
16:15:29 <intothemountains> EvanR: ok!
16:15:35 <EvanR> intothemountains: you mean special syntax? you probably dont need that built in, theres quasi quoters
16:15:35 <credditor> so d x if d is greater than x
16:15:40 <ertes> yeah
16:15:49 <credditor> so if the coincount is greater than x, what is x in this case?
16:15:54 <ertes> credditor: if you find it easier, you can do a function for quarters first
16:15:55 <EvanR> as for the imports nece to use Set, alternative prelude to the rescue
16:16:20 <ertes> quarterCount x | 25 > x = (_q, _r)
16:16:30 <intothemountains> From what I saw, that's the usual choice, but it strook me as strange
16:16:38 <credditor> hmm ok
16:16:40 <ertes> credditor: you don't know what x is…  only that it's less than the coin value
16:16:43 <credditor> so just to translate
16:17:00 <EvanR> intothemountains: haskell is all about practicality, out of lack of a better options in many cases
16:17:05 <intothemountains> EvanR: By special syntax I mean something like lists have, where the infix constructor can be used like '[a]'
16:17:12 <credditor> hmm
16:17:19 <credditor> still a bit confused on syntax meaning
16:17:25 <credditor> can we run through it step by step?
16:17:27 <EvanR> [set| x, y, y, z] ...
16:17:32 <EvanR> [set| x, y, y, z|] ...
16:17:39 <credditor> quarterCount x | 25 > x
16:17:40 <intothemountains> EvanR: is that a thing?
16:17:44 <EvanR> could be
16:17:51 <intothemountains> If?
16:17:51 <EvanR> look up quasi quoters
16:17:55 <intothemountains> ok!
16:17:58 <credditor> so is this like, "do the function quarterCount with x if 25 > x??
16:17:59 <Tuplanolla> Then again `fromList [x, y, z]` isn't that bad.
16:18:02 <ertes> the syntax "quarterCount x | 25 > x = (_q, _r)" means:  if 25 > x, then the result of (quarterCount x) is the tuple (_q, _r)
16:18:09 <geekosaur> afaik this is currently handled by OverloadedLists? and Set should have an IsList instance
16:18:11 <ertes> credditor: does that make sense?
16:18:11 <EvanR> fromList [x,y,y,z] is actually a lot less work
16:18:12 <credditor> got it!!!
16:18:15 <credditor> yes
16:18:25 <ertes> credditor: ok, now _q and _r are placeholders you have to fill in
16:18:27 <intothemountains> EvanR: yeah
16:18:28 <credditor> alright cool
16:18:49 <ertes> credditor: _q is the number of coins, _r is the remainder…  what are their values?
16:19:06 <credditor> well
16:20:08 <credditor> at first, q is going to be equal to 0, and r will be equal to x
16:20:15 <credditor> but as you count that changes
16:20:28 <credditor> or q could also be x/25 
16:20:38 <ertes> credditor: don't think about changing…  under the constraint 25 > x, that's exactly the result
16:20:57 <credditor> alright
16:21:01 <credditor> yeah got it 
16:21:15 <credditor> alright i get it now
16:21:16 <ertes> nothing changes…  the assumption 25 > x is in place here, but now we have what is called a "base case"
16:21:21 <credditor> are we using recursion?
16:21:28 <credditor> ok cool I understand
16:21:30 <Tuplanolla> I use `Set` if the collection is finite, not streamed and not ordered, yet the elements have some order, intothemountains.
16:21:57 <ertes> credditor: now you can ask the more general question that *eventually* reduces to this "base case"
16:22:05 <credditor> hmm alright
16:22:21 <credditor> quarterCount x | 25 < x
16:22:30 <credditor> that's the recursive case conditional right?
16:22:43 <ertes> credditor: write what you have so far into an actual file
16:22:49 <credditor> yeah it's here
16:23:00 <ertes> then add a second clause without any conditional:  it will be used when the first one doesn't hold
16:23:06 <ertes> quarterCount x = …
16:23:58 <ertes> (let's assume that there are no negative integers for now)
16:24:20 <EvanR> assuming there are no negative integers... cant you prove anything? ;)
16:24:35 <credditor> what do you mean by prove?
16:24:49 <credditor> given the base case I know my recursive case will return something
16:24:50 <EvanR> nevermind
16:25:16 <credditor> quarterCount x = | 25 < x = (1,x-25)
16:25:21 <credditor> something like this?
16:25:25 <credditor> i need to add recursion
16:26:00 <ertes> credditor: not quite…  what you need to do is to apply the function recursively with a "smaller" argument:  quarterCount x = (_q, _r)  where (q', r') = quarterCount _x
16:26:38 <ertes> you need to figure out _x, _q and _r now
16:26:45 <credditor> got it
16:27:06 <credditor> quarterCount x = (_q, _r)  where (q', r') = quarterCount _x
16:27:11 <credditor> is this the whole line?
16:27:14 <ertes> yeah
16:27:27 <credditor> oh cool what does "where" do?
16:27:43 <ertes> read it literally…  it introduces an auxiliary definition
16:28:04 <credditor> quarterCount x = (1, x-25)  where (q', r') = quarterCount x - 25 
16:28:07 <credditor> something like this?
16:28:23 <credditor> (1, x-25) I think that's wrong but I wasn't sure what else would be placed there
16:28:33 <ertes> nope, but except for syntax your _x is correct:
16:28:46 <ertes> quarterCount x = (_q, _r)  where (q', r') = quarterCount (x - 25)
16:29:09 <credditor> oh got it 
16:29:11 <ertes> now q' is the number of coins when you remove a quarter, and r' is the remainder
16:29:20 <credditor> function will do QC x then subtract 25 otherwise
16:29:36 <ertes> you're not done yet
16:29:54 <credditor> sorry, I thought we were converting a dollar value into a number of quarters, why are we removing quarters?
16:29:56 <ertes> if q' is the number of coins if you remove one, what is the total number of coins _q?
16:30:02 <credditor> q-1
16:30:06 <credditor> oh
16:30:08 <credditor> q+1
16:30:11 <ertes> q' + 1
16:30:12 <credditor> q'+1
16:30:15 <ertes> yeah
16:30:31 <credditor> ooooooooooohhhhhhhhh
16:30:33 <ertes> and if r' is the remainder, if you remove a quarter, what is the remainder _r?
16:30:45 <credditor> r'+25
16:30:48 <ertes> nope
16:30:57 <credditor> r'-25
16:31:14 <ertes> remember that _r is the remainder after you removed *all* quarters
16:31:26 <ertes> and r' is the remainder after you removed *all* quarters
16:31:31 <credditor> right because the base case is where r' = x
16:31:41 <credditor> so it makes sense that each step away has a lower r'
16:31:56 <ertes> if there are no quarters, then the remainder is just the amount itself…  that's why r = x in the base case =)
16:32:14 <ertes> but ignore the base case
16:32:37 <ertes> what's the remainder for 180?
16:32:40 <credditor> 5
16:32:45 <ertes> what about (180 - 25)?
16:32:51 <credditor> 155
16:32:55 <ertes> nope
16:33:01 <ertes> i mean: what's the remainder?
16:33:12 <credditor> 5?
16:33:15 <ydl> ertes: i've thought about it some more, and the "most" correct type according to intuition is actually still not the one used by the transformers package, but the signature (MonadCont m) => ((forall b. a -> m b) -> m a) -> m a (which I think you mentioned above). btw to my point about intuition there are 4 type definitions that could come from the definition, and although no RankNTypes does make it unique, it so happens in this case
16:33:15 <ydl> RankNTypes are indeed necessary to give the most ideal meaning.
16:33:23 <credditor> if you run the function on the resultant which is 155
16:33:25 <ertes> exactly: the remainder is invariant under coin addition/removal of quarters =)
16:33:37 <ertes> so given r', what is _r?
16:33:39 <credditor> oh alright
16:34:25 <credditor> r'?
16:34:29 <ertes> exactly
16:34:37 <credditor> hooray!
16:34:38 <ertes> ydl: yeah
16:34:57 <ertes> credditor: did all of that make sense?
16:35:15 <credditor> yes
16:35:24 <credditor> btw its throwing a parse error on line 2
16:35:24 <credditor> quarterCount :: Integer -> Integer -> (Integer, Integer) quarterCount x = | 25 > x = (0,x) quarterCount x = (q'+1, r')  where (q', r') = quarterCount (x - 25)
16:35:29 <credditor> do you know whats wrong?
16:35:33 <ertes> credditor: the important thing is to keep in mind that in FP things don't "do"…  they "are"
16:35:38 <credditor> line 2 is "quarterCount x = | 25 > x = (0,x)"
16:35:53 <ertes> remove the first "="
16:35:56 <geekosaur> te first = doesn't belong there
16:36:03 <credditor> whoops!
16:36:12 <credditor> now it throws a bunch of nasty errors
16:36:21 <credditor> https://gyazo.com/d579601b27adfce3866fa69f6c8b72da
16:36:26 <ertes> credditor: because your type is wrong
16:36:34 <ertes> this is not a coinCount function, but a quarterCount function
16:36:39 <ertes> it takes only one argument
16:37:06 <credditor> ohh
16:37:08 <credditor> so quarterCount :: Integer -> (Integer, Integer)
16:37:14 <credditor> that was dumb ty
16:37:38 <ertes> no worries, i may be partially responsible for that error =)
16:37:46 <credditor> so that made a ton of sense, now how would we handle this with nickels, dimes, and pennies? 
16:37:53 <dubbelosix> um..hello...haskell newbie here
16:38:11 <credditor> the base case gets more complicated right? Because now even if we can't handle it with 20s we can still use 10s
16:38:16 <ertes> credditor: now you generalise that function to coinCount
16:38:35 <ertes> credditor: instead of hard-coding 25, you take another argument called 'd'
16:38:49 <ertes> (or whatever you want to call it, but "d" has a reason that i'll reveal later)
16:39:04 <dubbelosix> i'm trying to understand exactly what let does and googling isnt helping...in most places that i read, it says that let allows you to declare expressions in ghci..but i'm able to do that in ghci even without let..so what exactly is the difference between "x = 10" and "let x = 10" in ghci?
16:39:06 <ertes> (same reason why i called the number of coins "q" and the remainder "r")
16:39:13 <credditor> quarterCount :: Integer -> Integer d -> (Integer, Integer)
16:39:15 <credditor> correct header?
16:39:19 <credditor> dimes!
16:39:31 <ertes> credditor: the type is what you had previously
16:39:35 <credditor> gotcha
16:39:43 <credditor> ok good
16:39:43 <ertes> coinCount :: Integer -> Integer -> (Integer, Integer)
16:40:18 <ertes> dubbelosix: there are a few flavours of 'let', but the one with 'in' just allows you to define auxiliary stuff
16:40:35 <ertes> dubbelosix: this is a way to write the number 10: let x = 5 in x + x
16:41:26 <dubbelosix> ah...but without using the in clause, essentially let does nothing special right?
16:41:42 <ertes> dubbelosix: all 'let' flavours just introduce definitions
16:42:05 <dubbelosix> i see
16:42:09 <dubbelosix> thanks :)
16:43:07 <credditor> hmm how does replacing 25 with d help?
16:43:09 <ydl> ertes: sorry to bother you yet again, but how is ContT useful to you without callCC? just as an optimization trick for monad stacks? all the non-trivial examples i can think of use callCC
16:43:21 <credditor> if we have 192 and want to get that in Q/D/N/P
16:43:22 <ertes> credditor: it lets you cover all coin types with a single function
16:43:32 <ertes> credditor: then all you need to do is to apply it four times
16:43:48 <ertes> credditor: do you have a working coinCount implementation now?
16:43:55 <credditor> thinking about it
16:44:07 <Cale> :t (`runCont` id) . sequence . map cont
16:44:09 <lambdabot> [(a -> [a]) -> [a]] -> [a]
16:44:37 <Cale> :t (`runCont` return) . sequence . map cont
16:44:38 <ertes> ydl: i use ContT and the similar Codensity…  the former i mainly use to get an exit path out of 'forever' when it's more convenient than recursion
16:44:39 <lambdabot> Monad m => [(a -> m [a]) -> m [a]] -> m [a]
16:44:55 <credditor> how would you call the function? CoinCount (192)? 
16:44:57 <ertes> ydl: the latter i mainly use for streamlining 'bracket' or 'with*' style functions
16:45:44 <ertes> ydl: do r1 <- Codensity (bracket _open1 _close1); h <- Codensity (withFile _fp _m); …
16:46:19 <ertes> > coinCount 25 180
16:46:21 <Cale> :t runCont . sequence . map cont
16:46:22 <lambdabot>  (0,25)
16:46:23 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
16:46:27 <Cale> ^^ ah right
16:46:36 <ertes> whoops
16:46:41 <Cale> (that's what I was originally thinking of)
16:46:42 <credditor> ertes: can we do it just by saying coinCount(192)?
16:46:50 <ertes> > coinCount 25 180
16:46:52 <lambdabot>  (7,5)
16:46:53 <credditor> So that the user doesn't have to pass in an extra param?
16:47:02 <M-berdario> Hi, is anyone running Ubuntu 16.10 here?
16:47:12 <ydl> ertes: can you show an exit path from forever example?
16:47:12 <ertes> credditor: i added coinCount to lambdabot now, so you can experiment with it
16:47:19 <ertes> ydl:
16:47:25 <ertes> :t ContT . const . pure
16:47:27 <lambdabot> Applicative m => r -> ContT r m a
16:47:30 <credditor> ertes: cool, how do i use lamdabot?
16:47:39 <ertes> credditor: like this:
16:47:43 <ertes> > coinCount 25 180
16:47:45 <lambdabot>  (7,5)
16:47:48 <credditor> oh cool
16:47:51 <Tuplanolla> You can use him through private messages too, credditor.
16:47:54 <ertes> credditor: ideally: /query lambdabot 
16:48:09 <credditor> hahaha tupla you don't want me to share my lambda adventures??
16:48:33 <Tuplanolla> Only good adventures.
16:48:37 <ertes> ydl: you can call that function "abort"
16:48:42 <ertes> it exits the entire ContT
16:48:52 <ertes> or "break", if you want
16:48:55 <Tuplanolla> > length (2, 3) -- This is a good adventure.
16:48:56 <lambdabot>  1
16:49:49 <EvanR> you cant explain that
16:49:49 <credditor> coinCount 10 182
16:50:03 <Koterpillar> > "like this, credditor"
16:50:05 <lambdabot>  "like this, credditor"
16:50:10 <credditor> whoops
16:51:53 <ertes> credditor: do you have your own working coinCoint now?
16:52:35 <credditor> almost
16:53:44 * hackagebot sibe 0.2.0.1 - Machine Learning algorithms  https://hackage.haskell.org/package/sibe-0.2.0.1 (mdibaiee)
16:54:55 <credditor> https://gyazo.com/eee391a2ef7d3dd9de4c14a7fc8b3075
16:55:04 <credditor> do you know why its throwing a parse error there?
16:55:27 <ertes> credditor: could you use lpaste.net or gists?  it shows a blank page for me
16:55:35 <credditor> yeah sure
16:56:14 <credditor> http://lpaste.net/268747
16:56:49 <ertes> credditor: first thing: the 'd' is now an extra argument, so you should actually take it
16:56:56 <ertes> coinCount d x …
16:57:01 <mauke> you can't use +1 in a pattern
16:57:12 <credditor> ah I see
16:57:23 <credditor> :manuke does ++ work?
16:57:32 <mauke> no
16:57:38 <ertes> credditor: the second thing: apart from that it's almost the same function as quarterCount, including that it returns a pair of numbers, not a quadruple
16:57:38 <credditor> eretes: thanks I didn't realize that's how params were passed
16:58:11 <ertes> the only difference is that you don't subtract/compare to 25 specifically, but to the 'd' it received
16:58:40 <credditor> Yeah, I made that change then got confused by the parse error
16:59:05 <ertes> note also that the 'd' in the type signature doesn't belong there
17:01:04 <credditor> @ertes what is the base case in this situation? 
17:01:04 <lambdabot> Unknown command, try @list
17:01:44 <ertes> credditor: coinCount d x | d > x = (_q, _r)  -- how many d-cent coins are there, if x < d?
17:03:00 <credditor> d % x
17:03:18 <ertes> pay attention to the assumption
17:03:22 <ertes> x < d
17:03:49 <ertes> how many 17-cent coins are there for the amount of 8 cents?
17:03:58 <credditor> 0
17:04:14 <ertes> how many d-cent coins are there for the amount if x cents, where x < d?
17:04:27 <credditor> 0
17:04:31 <credditor> gotcha 
17:07:08 <credditor> ertes: http://lpaste.net/268747 do you know why this is throwing errors?
17:07:32 <credditor> " Couldn't match expected type ‘(t, t1)’                   with actual type ‘Integer -> (Integer, Integer)’"
17:07:43 <ertes> credditor: because your coinCount takes two arguments now =)
17:07:56 <ertes> look at your recursive application
17:09:34 <credditor> hmm
17:09:48 <credditor> So two questions
17:09:59 <credditor> 1st, does my recursive case not use both variables?
17:10:08 <credditor> and second, what does the compiler mean by "‘(t, t1)’                   with actual type ‘Integer -> (Integer, Integer)’"
17:10:44 <ertes> credditor: the second question you'll tackle when learning about function types and currying, so ignore it for now
17:11:11 <ertes> the first question: if your function takes two arguments, you should not only *take* two arguments when defining it, but also *give* two arguments when using it
17:12:11 <ertes> "recursion" (in the context of functions) means using the function you are defining within its definition…  you do that, but you're only giving it one argument, not two
17:13:27 <credditor> ertes: oh duhhhh
17:13:29 <credditor> oh my god 
17:13:30 <credditor> ffs
17:14:47 <ertes> credditor: does it work now? =)
17:15:28 <credditor> hmm no 
17:15:28 <credditor> http://lpaste.net/268747
17:15:34 <credditor> not sure why 
17:15:43 <ertes> you're still giving it *one* argument
17:15:49 <ertes> which is a tuple
17:15:57 <ertes> > replicate 5 'x'
17:15:59 <lambdabot>  "xxxxx"
17:15:59 <credditor> (d, x-d), why isn't that two?
17:16:01 <ertes> > replicate (5, 'x')
17:16:03 <lambdabot>  error:
17:16:03 <lambdabot>      • Couldn't match expected type ‘Int’
17:16:03 <lambdabot>                    with actual type ‘(Integer, Char)’
17:16:04 <credditor> ohhh freakin tuples
17:16:28 <lordcirth> credditor, you are thinking in C, perhaps? :)
17:16:32 <credditor> sorry how do you format this for a tuple?
17:16:47 <ertes> credditor: you don't, because there are no tuples involved:  coinCount d (x - d)
17:16:48 <credditor> lordcirth: java/C#, only other languages i've programmed in
17:17:03 <EvanR> credditor: (a,b) is a foldable... but in the dumbest possible way: toList (a,b) is [b]
17:17:13 <credditor> oh man
17:17:14 <ghast> \y-> y::(forall a. Ord a => a) (\x -> [(a,b)|a<-x,b<-x])
17:17:17 <credditor> thanks ertes:
17:17:20 <lordcirth> credditor, in C, f (x,y) is f with 2 args, x and y.  In Haskell, that's f of a Tuple
17:17:27 <credditor> I just didn't know how to format that 
17:17:40 <credditor> lordcirth, yeah that makes tons of sense
17:17:53 <credditor> freakin haskell, all convenient and shit 
17:17:57 <ertes> credditor: you pass functions to arguments by juxtaposing with a space
17:18:12 <lordcirth> f x y 
17:18:22 <credditor> its working!!!
17:18:34 <credditor> I'm so proud 
17:18:42 <lordcirth> credditor, nice.
17:18:42 <ertes> credditor: great, congratulations…  now delete it, because you have just reinvented integer division =)
17:18:47 <lordcirth> :P
17:18:48 <ertes> > divMod 180 25
17:18:50 <lambdabot>  (7,5)
17:18:56 <credditor> ertes ouch
17:19:08 <credditor> freakin lambdabot 
17:19:14 <ertes> sorry =)
17:19:15 <credditor> i bet divMods runtime is less too
17:19:19 <lordcirth> Story of me learning Haskell: 1: Make thing, doesn't work. 2: struggle to fix thing. 3: Works, find out there's a thing for that.
17:19:23 <Koterpillar> @src divMod
17:19:23 <lambdabot> Source not found. Abort, Retry, Panic?
17:19:30 <ertes> divMod is predefined and, yes, *waaaaaaaaaaaay* faster =)
17:19:44 <credditor> alright ertes, where too now?
17:19:58 <ertes> only difference: the arguments are flipped (unfortunately!)
17:20:11 <ertes> so you write (divMod x d) instead of (coinCount d x)
17:20:26 <ertes> now your coin distribution function is actually really simple to write:
17:20:52 <Phyx-> lordcirth: don't forget 4. realize that it can all be made one liners
17:21:11 <ertes> > let (q25, r25) = divMod 180 25; (q5, r5) = divMod r25 5 in (q25, q5, r5)
17:21:13 <lambdabot>  (7,1,0)
17:21:35 <ertes> this is the number of 25-cent coins, 5-cent and 1-cent coins you need for 180 cents
17:22:17 <lordcirth> Phyx-, well, that's part of 3.
17:22:42 <ertes> > evalState (liftA3 (,,) (state (`divMod` 25)) (state (`divMod` 5)) get) 180
17:22:44 <lambdabot>  (7,1,0)
17:23:10 <lordcirth> ertes, now, is that optimizing for minimum number of coins?
17:23:31 <ertes> > evalState (mapM (\d -> state (`divMod` d)) [25, 5, 1]) 180
17:23:33 <lambdabot>  [7,1,0]
17:23:53 <ertes> lordcirth: i think so,
17:24:16 <ertes> it's the algorithm: start with the most valuable coin, then decrease coin values
17:24:33 <Koterpillar> that doesn't optimize for the minimum of coins
17:24:39 <lordcirth> That's the naive solution, but not optimal
17:24:51 <ertes> the optimal may be a subset sum problem
17:25:05 <ertes> or something equivalent
17:25:25 <ghast> The union of two sets has multiple generators, how do I order them?
17:26:02 <credditor> hmm alright, how do you work that into a recursive function?
17:26:34 <ghast> I think it's permutations.permutations
17:26:35 <hpc> when is it not optimal?
17:26:42 <ertes> credditor: since your coin types are fixed, you're actually done with recursion…  all you need is to apply divMod (or coinCount, if you're sentimental)
17:27:01 <EvanR> ghast: if there was an order before, then the union also has that order
17:27:18 <ertes> hpc: i think it's optimal for certain sets of coins
17:27:39 <hpc> that's what i figure, as far as i can tell it's optimal for US coins
17:27:40 <lordcirth> hpc, for certain coin sizes, there can be cases where, say, 3 medium is better than 1 large + 5 smalls.
17:27:41 <Koterpillar> where each coin is a divisor of the ones after it
17:27:41 <ertes> like 100, 50, 20, 10, 5, 2, 1
17:27:53 <credditor> ertes: oh cool, thanks for showing me how divmod works
17:27:56 <lordcirth> hpc, for sanely sized coins, it should be optimal or nearly so
17:28:20 <ertes> credditor: exercise: write a function: coinDist :: Integer -> (Integer, Integer, Integer, Integer)
17:28:22 <Welkin> the knapsack problem?
17:28:36 <ertes> credditor: it should come up with coin counts for 4 coin types of your choice
17:28:40 <lordcirth> Welkin, similar but I don't think it's quite the same
17:28:58 <hpc> if there exist two coins in the set where a < b and 2a > b perhaps?
17:29:05 <hpc> no, that's not enough
17:29:34 <hpc> a concrete example is 1, 10, 15, and doing something like 25
17:29:39 <hpc> or 20
17:29:40 <Koterpillar> 10, 9 and 1
17:30:03 <Koterpillar> 10, 9 and 1; 27 results in an unoptimal solution
17:30:05 <hpc> the optimal 20 would be 10+10, but the naive would be 15+5*1
17:30:26 <ertes> hpc: 15+5 is optimal, too
17:30:29 <ertes> two coins
17:30:32 <Koterpillar> there is no 5
17:30:36 <hpc> but then if you have 15, 10, 5, 1, i think it becomes optimal again?
17:30:55 <ghast> I mean the order of the generators of the union, like \x y -> [(a,b)|a<-x ,b <-y x]
17:30:57 <hpc> because 15+5 = 10+10, or something
17:31:29 <Koterpillar> I have a feeling this is equivalent to something np-hard, and thus we might not be able to formulate the set of conditions under which it is not optimal
17:32:00 <ertes> the general subset sum problem doesn't have a 1-valued coin
17:32:47 <ertes> it has potentially coarse-grain coins
17:32:54 <hpc> ah yeah, so it might not even be possible for all values
17:32:58 <ertes> like:  how many 17-cent and 23-cent coins do you need for 100?
17:33:20 <hpc> like if the coins were 4, 3 and you tried to make 6
17:33:36 <ertes> or the largest value ≤ 6
17:33:57 <ertes> = 6, if there is a 1-cent coin
17:35:12 <credditor> hey ertes it works!!!
17:35:14 <credditor> thanks man
17:35:47 <ab9rf> i'm fairly certain that a "least number of coins" problems becomes a knapsack problem for arbitrary coins
17:35:48 <ertes> credditor: my pleasure…  now you *could* turn this into yet another recursive function that takes a list of coin sizes as its argument =)
17:36:45 <ertes> @let coins = evalState . mapM (\d -> state (`divMod` d))
17:36:49 <lambdabot>  Defined.
17:37:05 <ertes> > coins [25, 10, 5, 1] 4632
17:37:12 <lambdabot>  [185,0,1,2]
17:39:12 <credditor> quick question, if I wanted this to throw and error if someone passed a negative, how would that work?
17:39:22 <credditor> I tried bills x = if x < 0 then error "ff" else let (q20, r20) = divMod x 20; (q10, r10) = divMod r20 10; (q5, r5) = divMod r10 5 in (q20, q10, q5,r5)
17:39:36 <ertes> credditor: it depends
17:39:56 <ertes> credditor: do you consider passing negative amounts a bug in the program or a run-time exception?
17:40:07 <credditor> I would consider it to be a user error
17:40:16 <ertes> then use Maybe
17:40:29 <credditor> i'd like to just return a string to the user saying "DON'T DO THAT!"
17:40:41 <ab9rf> Either, then :)
17:40:49 <ertes> yeah, Either
17:41:20 <credditor> ok cool
17:41:27 <credditor> do you guys know why my error fails?
17:41:41 <credditor> oh maybe that's what it should look like
17:41:47 <credditor> *** Exception: ff CallStack (from HasCallStack):   error, called at qC.hs:2:25 in main:Main
17:41:54 <credditor> is that a correct output?
17:42:26 <credditor> nvm its right
17:44:41 <ertes> credditor: at this point i think you should start reading the beginners' track here: https://en.wikibooks.org/wiki/Haskell
17:45:01 <ertes> it takes you from here to a point where you can confidently write most simple functions on your own
17:45:18 <credditor> alright cool, I'll check it out
17:46:44 <Costar> hi
17:48:01 <ertes> credditor: if you want something more principled/better structured, consider buying this book: http://www.cs.nott.ac.uk/~pszgmh/pih.html
17:49:07 <fresheyeball> hey folks
17:49:14 <fresheyeball> I have question about MonadIO
17:49:45 <lordcirth> fresheyeball, don't ask to ask
17:50:05 <fresheyeball> lets say we have some generic m which MonadIO m
17:50:23 <fresheyeball> does that mean that I am guaranteed some way of moving from m -> IO?
17:50:36 <fresheyeball> I can lift IO with liftIO 
17:50:37 <Costar> use liftIO
17:50:41 <fresheyeball> right
17:50:43 <geekosaur> yes, and that way is liftIO
17:50:56 <fresheyeball> but when I go to unwrap my mtl build monad with MonadIO
17:51:11 <fresheyeball> does MonadIO mean it will necessarily be an IO at one point? 
17:51:16 <geekosaur> "unwrap"?
17:51:23 <fresheyeball> for example
17:51:26 <fresheyeball> lets say I have
17:51:40 <fresheyeball> type App a = MaybeT IO a
17:51:50 <fresheyeball> I would "unwrap" this with `runMaybeT`
17:52:18 <fresheyeball> and then I would have an IO
17:52:20 <Koterpillar> :t runMaybeT
17:52:21 <lambdabot> error: Variable not in scope: runMaybeT
17:52:22 <geekosaur> it's not really unwrapping
17:52:27 <fresheyeball> sure
17:52:34 <fresheyeball> I might not be articulating myself properly 
17:52:53 <Koterpillar> yes, MonadIO means there is IO under the hood
17:52:56 <geekosaur> you would use runMaybeT inside IO; this runs whatever the MaybeT is with the IO context that is current
17:53:10 <fresheyeball> Koterpillar: thats what I needed to know
17:53:33 <Koterpillar> [unless you make a really silly implementation, but then you've asked for it]
17:53:45 * hackagebot scalpel 0.4.0 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-0.4.0 (fimad)
17:54:04 <ertes> liftIO _ = return (error "No effects, bro!")
17:54:06 <geekosaur> note however that there are many instance declarations of the form MonadIO m => MonadIO (SomeMonad ... m) -- which will only actually exist if m has a MonadIO instance
17:54:14 <fresheyeball> so would an api that asks for some monad m that is (MonadIO m) and a function `m a -> IO a`
17:54:18 <fresheyeball> be reasonable?
17:54:22 <fresheyeball> as in, hey user
17:54:28 <fresheyeball> I know you are going use mtl
17:54:37 <fresheyeball> and I am just demanding that there be an IO in there somewhere
17:54:54 <fresheyeball> and you tell me how to "run/unwrap" your `m` into an `IO`?
17:55:31 <EvanR> hrm. an API which demands you give a monad which can do IO
17:55:46 <LordBrain> might as well return into that monad
17:56:08 <fresheyeball> hmm
17:56:09 <LordBrain> MonadIO m => m a -> m a
17:56:12 <ertes> fresheyeball: if that function is the inverse of liftIO, then m = IO
17:56:22 <EvanR> that seems a big overpowerred?
17:56:24 <fresheyeball> interesting
17:56:32 <EvanR> bit
17:56:41 <ertes> fresheyeball: if you want to ask for an IO action, ask for an IO action
17:56:50 <ertes> not something that ultimately is equivalent to one
17:57:13 <ertes> unless there is some point to that alternative representation
17:57:57 <LordBrain> i think it would be better to just generalize the return type
17:58:02 <fresheyeball> well, I just needed to know if the presence of `MonadIO m` meant that a function from `m a -> IO a` is necessarily possible 
17:58:04 <LordBrain> unless there is reason not to
17:58:12 <fresheyeball> and it sounds like that is infact the case
17:58:22 <fresheyeball> I'm working on an alternative `startApp` in the style of elm-lang
17:58:27 <ertes> fresheyeball: nope
17:58:50 <fresheyeball> ertes: how not? if MonadIO means there is IO in the Monad stack?
17:58:58 <LordBrain> the type signature is possible even from a pure value b -> IO a
17:59:12 <ertes> fresheyeball: that means you can convert IO actions into m-actions, but not necessarily m-actions into IO actions
17:59:16 <LordBrain> so i'm not sure if you're expressing your question well
17:59:34 <ertes> fresheyeball: (MonadIO m) establishes a natural transformation from IO -> m
17:59:43 <LordBrain> liftIO
17:59:54 <EvanR> fresheyeball: what are you using IO for inside this monad?
18:00:08 <fresheyeball> ertes: can you give an example of a concrete instance where its not possible to `run` the other Monads in the stack and be left with `IO`?
18:00:11 <ertes> fresheyeball: if you *also* have a natural transformation m -> IO, then you have in fact m = IO
18:00:25 <fresheyeball> right
18:00:45 <fresheyeball> which I think I have if `MonadIO m`. There is an IO in m
18:00:59 <ertes> fresheyeball: Proxy
18:01:04 <fresheyeball> or are there monads other than IO that cannot be eliminated?
18:01:05 <EvanR> for the particular actions you do behind the scenes, it might make more sense to ask for that interface and let the user decide what it does
18:01:24 <Koterpillar> fresheyeball: some might require additional things to run
18:01:31 <fresheyeball> sure
18:01:48 <fresheyeball> but if I ask the user to provide a function from `MonadIO m => m a -> IO a`
18:01:56 <fresheyeball> they can provide the extra goodies needed
18:02:04 <ertes> fresheyeball: it doesn't have a MonadIO instance, but it could have one: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Proxy.html
18:02:05 <EvanR> this seems backwards
18:02:06 <fresheyeball> like the initial state for the State= Monad
18:02:22 <fresheyeball> yes I am going backward
18:02:32 <Koterpillar> fresheyeball: given that you don't know anything about m, why do you insist on it?
18:02:48 <credditor> working on an nprime function
18:02:58 <ertes> fresheyeball: let's talk in terms of effects:  (IO -> m) means that m supports all IO effects
18:03:03 <credditor> returns the corresponding prime to whatever integer user put in
18:03:08 <ertes> fresheyeball: (m -> IO) means that IO supports all m effects
18:03:09 <Koterpillar> fresheyeball: you can't call anything on it except liftIO and that function
18:03:23 <credditor> so nprime 2 = 3, nprime 5 = 11
18:03:26 <ertes> fresheyeball: if you have both, then m and IO are indistinguishable in terms of effects
18:03:33 <credditor> any good ideas on what algorithims to use?
18:03:58 <ertes> credditor: start by defining a list of primes
18:04:06 <ertes> of all primes that is
18:04:25 <credditor> ertes: within the function?
18:04:25 <Welkin> just use the primes package
18:04:37 <ertes> credditor: then all you need to do is to take then n-th element of that list
18:04:49 <credditor> hmm ertes how do i make a list of all primes?
18:04:50 <ertes> credditor: or top-level, if you want
18:04:55 <Welkin> http://hackage.haskell.org/package/primes-0.2.1.0/docs/Data-Numbers-Primes.html
18:05:15 <credditor> wow
18:05:18 <credditor> that's pretty cool
18:05:24 <ertes> credditor: there are many approaches, but for now you may want to go with the naive approach:  just do trial division on every integer ≥ 2
18:05:44 <ertes> credditor: of course if this is *not* for exercise, you should really just use an existing package
18:06:02 <ertes> i personally recommend the arithmoi package
18:06:15 <Welkin> ertes: is that french?
18:06:27 <ertes> no idea
18:06:40 <credditor> ertes: ideally it'll only be a supporting function, so I'll just use the package 
18:06:41 <geekosaur> Greek, I'd think
18:06:45 <ertes> but it's super-fast…  GMP-level fast for most things
18:06:53 <credditor> do i define the list of primes within the function?
18:07:17 <ertes> credditor: if you use a package, you just import a module and use the definitions found therein
18:07:34 <geekosaur> fresheyeball, you can't go backwards
18:07:46 <ertes> for example with arithmoi you import Math.NumberTheory.Primes
18:07:48 <geekosaur> if you have IO, you cannot import some random m into it
18:08:23 <geekosaur> if you have an m that has a MonadIO instance, you can do IO from m using liftIO. you cannot "pass" the m to an IO action to enable it to use it
18:09:03 <geekosaur> sometimes you can pass a copy, but if m involves state then that state would be independent of the original m
18:10:06 <credditor> ertes: Cool, thanks. So how would I do this programmatically in a function?
18:10:13 <ertes> fresheyeball: BTW, i just realised that i made an assumption:  that the function you take is actually of type:  forall a. m a -> IO a
18:10:31 <LordBrain> http://hackage.haskell.org/package/transformers-runnable
18:10:31 <ertes> credditor: "this" being?
18:10:57 <credditor> ertes: an nprime function that returns the prime corresponding to n
18:11:19 <ertes> credditor: does it have to be exact?
18:11:29 <lordcirth> credditor, as in, the nth prime?
18:11:53 <geekosaur> fresheyeball, to give an example which I suspect is relevant: let's say you are trying to use a callback in IO. you could in theory pass a run function with a copy of your state to that callback; the callback would modify its copy of the state, which would be lost when the callback returned
18:11:55 <Welkin> zipper: habari
18:12:19 <geekosaur> what you cannot do is have that callback modify your state
18:12:26 <lordcirth> credditor, import Data.Numbers.Primes ; primes !! n
18:12:29 <credditor> yeah, so for example nprime 5 returns 11
18:12:48 <ertes> credditor: then you index the list of primes using (!!)
18:13:02 <ertes> (it's a bit unfortunate that it's a list, but oh well)
18:13:13 <credditor> hmm alright
18:13:15 <lordcirth> ertes, why? speed?
18:13:26 <ertes> lordcirth: because of []
18:13:35 <ertes> (!!) is a partial function
18:13:50 <lordcirth> ertes, what else would it be?
18:13:56 <ertes> lordcirth: a stream
18:14:03 <credditor> I'm a bit newbie confused, can you import that package into a function then call it its methods from within your own function or does it have to be imported in the gui?
18:14:05 <ertes> https://hackage.haskell.org/package/Stream
18:14:22 <geekosaur> credditor, you import it into your module
18:14:31 <ertes> lordcirth: like here: https://github.com/esoeylemez/snippets/blob/master/PurePrimeSieve.hs
18:14:32 <lordcirth> credditor, once you import it, 'primes' is now a function you can use in your code.
18:14:48 <geekosaur> (or program, which is just a module with an implied "module Main where" at the top)
18:15:07 <geekosaur> (and an IO action "main" defined somewhere within it)
18:15:13 <lordcirth> ertes, what makes Streams so much better than Lists?
18:15:28 <ertes> credditor: https://en.wikibooks.org/wiki/Haskell/Modules
18:15:43 <ertes> lordcirth: indexing is total, so if you have something infinite, you should use a stream
18:17:10 <lordcirth> ertes, but if you use !! on an infinite list, it will always return something, so what's the problem?
18:17:28 <ReinH> lordcirth: lists can be finite
18:17:31 <ertes> lordcirth: using head on a non-empty list will also always return something
18:17:34 <ReinH> and you can't tell the difference
18:17:59 <ertes> "the list is infinite anyway" is a piece of information that only the programmer has, not the compiler
18:18:11 <credditor> when I do "module Nprime where  	import Data.Numbers.Primes" loading the file causes a "failed to load interface" error
18:18:18 <ertes> lordcirth: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
18:18:23 <geekosaur> did you install the package?
18:18:29 <geekosaur> it's not going to download and install itself
18:18:44 <lordcirth> ertes, so, you think that all infinite lists should be Streams instead, so that all List-using things can be forcibly total functions?
18:19:05 <ertes> lordcirth: indeed
18:19:21 <ertes> all things that are *known to be* infinite
18:19:37 <lordcirth> right, naturally there will be some things which may or may not be at runtime
18:19:48 <ReinH> Not if they are streams
18:19:57 <EvanR> lordcirth: its pretty much like earlier, you can use lists and say "assuming this will be infinite" in the docs
18:20:10 <EvanR> pragmatic considerations
18:20:22 <lordcirth> Is !! defined for Streams?
18:20:39 <ertes> it's a bit unforuntate that Stream is not in base yet, so you need an extra package for streams like the Stream package
18:20:43 <Welkin> is Stream a type?
18:20:53 <Welkin> what is it?
18:21:01 <lordcirth> data Stream a 
18:21:02 <Welkin> a lazy list is already a stream
18:21:02 <EvanR> data Stream a = Stream a (Stream a)
18:21:13 <ReinH> a lazy list is not a stream
18:21:20 <ReinH> that's the whole point of the current discussion
18:21:35 <ertes> Welkin: literally just [] without [] =)
18:21:39 <ertes> type [] without data []
18:21:39 <lordcirth> Welkin, we are talking about splitting infinite lists into Streams so as to enforce better safety
18:22:04 <EvanR> lordcirth: yeah !! is defined in the Stream module
18:22:25 <EvanR> not like its any more efficient ;)
18:22:32 <lordcirth> I will consider using Streams, if I ever do complex work with both finite and infinite lists.  Sounds useful.
18:22:39 <ertes> another nice property of Stream is that its Applicative instance does something useful for *streams* =)
18:22:48 <ertes> (<*>) = zipWith ($)
18:22:51 <Welkin> how is this different from using pipes or conduit?
18:23:00 <ReinH> how is it similar?
18:23:02 <EvanR> its also a comonad, and has a more correct zip
18:23:07 <EvanR> and merge (on sorted streams)
18:23:58 <EvanR> merge also works on finite or infinite lists
18:23:59 <lordcirth> ertes, what does that code do?  Why would one zipWith $ ?
18:23:59 <ertes> the one from the 'streams' library also has a Comonad instance
18:24:44 <ertes> lordcirth: f <*> xs <*> ys <*> zs = zipWith3 f xs ys zs
18:24:57 <ertes> one zip to rule them all
18:25:37 <ertes> (it also has a Monad instance, but don't use that one)
18:25:53 <lordcirth> ertes, still don't get it.  You can create zipWithn for any n?
18:26:37 <ertes> lordcirth: similarly you can create liftAn for any n, but you wouldn't want to create liftA7…  you would just use applicative style
18:26:54 <ertes> f <*> … <*> … <*> … <*> … <*> …
18:27:00 <MarcelineVQ> > ZipList [(+), (*), const] <*> ZipList [1..] <*> ZipList [1..] -- yeah, in fact you can already but it's maybe a little clunky
18:27:01 <ertes> whoops
18:27:03 <lambdabot>  ZipList {getZipList = [2,4,3]}
18:27:14 <ertes> the first one should be (<$>)
18:27:28 <lordcirth> I don't really understand monads, applicatives, etc.
18:27:33 <lordcirth> Very new to Haskell.
18:27:55 <ertes> lordcirth: ah, ok…  the point of having an applicative zip is that you only need one function instead of one for every arity
18:28:24 <lordcirth> ertes, yes, that is certainly cleaner.
18:28:33 <credditor> ok cool that worked
18:28:53 <credditor> ertes, if i wanted to make my own nprime function how could i do it?
18:29:00 <lordcirth> Although, I would question the need for a zipWith7 of any type.  Sure you should still be using a tuple at that point? :P
18:29:21 <ertes> lordcirth: there are no tuples involved with zipWith*
18:29:30 <ertes> you're thinking of zip* =)
18:29:36 <lordcirth> ertes, oh, oops
18:29:57 <ertes> lordcirth: but think of reusing 2-tuples to construct tuples of any size you want
18:30:09 <ertes> instead of defining 3-tuples, 4-tuples, etc.
18:30:17 <ertes> credditor: how much of it should be your own?
18:30:33 <lordcirth> Ah, right, zipWith returns a list.  nvrm.
18:30:34 <credditor> ertes, well I'd like to do it all on my own 
18:30:52 <lordcirth> credditor, as in, no imports?
18:30:54 <credditor> no dependencies if needed
18:30:58 <credditor> yeah exactly
18:31:17 <lordcirth> Look up prime number sieves in Haskell
18:31:18 <ertes> credditor: then you reinvent the list/stream of primes
18:31:29 <lordcirth> They come in very differing complexities
18:31:40 <ertes> you can do trial division, or you can do something more fancy and use a sieve
18:36:59 <ertes> credditor: BTW, i suggest *not* using a sieve for now…  just write a function (isPrime :: Integer -> Bool), then later you can just filter the list of all integers using it
18:37:08 <EvanR> arithmoi, 
18:37:08 <credditor> alright cool
18:37:14 <EvanR> that package rocks
18:37:31 <ertes> EvanR: i agree, but credditor wants to do this as an exercise
18:39:06 <EvanR> should be useful as a check against whatever you write
18:39:35 <credditor> ok cool have my isprime rolling
18:39:57 <ertes> credditor: cool, that was fast
18:40:08 <ertes> credditor: is 9 a prime number by your function?
18:40:12 <ertes> (common mistake)
18:40:55 <credditor> ertes, I had an isprime function from a while ago I modified 
18:41:04 <credditor> no its not
18:41:11 <credditor> isPrime k = null [ x | x <- [2..k - 1], k `mod`x  == 0]
18:41:15 <credditor> that's the jist of it
18:42:03 <ertes> credditor: yeah, that looks correct
18:42:14 <ertes> credditor: now look at this function:
18:42:15 <ertes> :t filter
18:42:16 <lambdabot> (a -> Bool) -> [a] -> [a]
18:42:38 <ertes> do you see how you can express a list of primes?
18:43:08 <credditor> hmm
18:43:27 <credditor> can you explain what that header means?
18:43:54 <ertes> it means that 'filter' takes two arguments:  one of type (a -> Bool), and one of type [a]
18:44:04 <ertes> for any 'a' of your choice
18:44:08 <ertes> and returns a list of type [a]
18:44:11 <kadoban> > filter even [1..10]
18:44:13 <lambdabot>  [2,4,6,8,10]
18:46:51 <credditor> alright cool
18:46:58 <credditor> yeah that makes sense
18:47:09 <credditor> why [a] -> [a]?
18:47:13 <credditor> does it also return a list?
18:47:25 <credditor> so a boolean and a list?
18:47:50 <ertes> > [1..10]  -- it takes a list, say, of integers
18:47:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
18:48:03 <geekosaur> you misunderstand. it takes a function and a list; it produces a list of the same type as the one you give it
18:48:06 <ertes> > filter even [1..10]  -- and returns a list of integers filtered by the given function
18:48:09 <lambdabot>  [2,4,6,8,10]
18:48:19 <geekosaur> the function must take an element of that list type and produce a Bool
18:48:27 <kadoban> :t even
18:48:28 <lambdabot> Integral a => a -> Bool
18:49:00 <ertes> credditor: functions aren't special in haskell…  they can be arguments to functions
18:50:26 <credditor> alright, so should I have 3 functions?
18:50:48 <credditor> 1 checks if something is a prime, the second populates a list of primes, and the third returns the nth element of that list?
18:51:03 <credditor> or can I populate and return in the same function
18:51:06 <ertes> credditor: be careful about the second one:  it's not a function, just a list
18:51:13 <ertes> credditor: remember things don't "do", they "are"
18:51:30 <credditor> right
18:52:36 <ertes> so the first definition is a primality predicate (a function), the second one is a list of primes (just a value), the third is a function that indexes the second one
18:53:54 <credditor> alright that makes sense
18:54:05 <credditor> where should I "make" the list of primes?
18:54:21 <ertes> where you want, as long as it's in the scope of the third
18:54:29 <credditor> ok cool
18:54:53 <credditor> so I know the general idea making this list, but can you help me with the syntax?
18:55:06 <ertes> credditor: sure, what do you have right now?
18:55:12 <credditor> its like populate this infinitely with numbers that meet this condition
18:55:57 <credditor> primes = {[1..] | isPrime n}
18:56:12 <ertes> use the 'filter' function
18:56:14 <credditor> which I know is wrong but I'm not sure how to check each part of the list
18:56:39 <ertes> @let isPrime x = all (\d -> mod x d /= 0) [2..x - 1]
18:56:41 <lambdabot>  Defined.
18:56:53 <geekosaur> I think that whole thing about filter just went in and out again...
18:57:04 <Mibaz> Hey guys. This is my first time on IRC and I'm a noob. Is this the place for dumb questions?
18:57:17 <ertes> > [ x | x <- [2..], isPrime x]  -- this is the list comprehension version, but really, use 'filter'
18:57:20 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
18:57:25 <lordcirth> Mibaz, about Haskell?  Here or #haskell-beginners
18:57:38 <Mibaz> Yep! Haskell
18:58:14 <credditor> ertes why is filter better?
18:58:16 <Mibaz> Ok thanks. Don't actually have a question, just wanted to check it out.
18:58:26 <ertes> credditor: you'll see once you figured out how to use it =)
18:59:05 <credditor> primes = filter (isPrime) [1...] right?
18:59:09 <credditor> that's freakin awesome
18:59:12 <lordcirth> credditor, yup
18:59:15 <lordcirth> filter is great
18:59:22 <ertes> credditor: filter isPrime [2..]
18:59:26 <credditor> haskell's really smart 
18:59:41 <lordcirth> Yeah it's cool
19:00:13 <ertes> credditor: there are deeper reasons beyond "short and sweet" why 'filter' is in many cases better than a list comprehension: it's "more composable", if that makes sense
19:01:28 <credditor> ok so last step
19:01:35 <credditor> nprime :: Integer -> Integer nprime n =  	let primes = filter (isPrime) [1...] do primes !! n
19:02:10 <credditor> how exactly does the syntax work here
19:02:12 <ertes> credditor: or simply:  nthPrime n = filter isPrime [2..] !! n
19:02:28 <credditor> oh that's freaking cool
19:02:55 <ertes> credditor: that's not even the shortest version =)
19:03:13 <ertes> nthPrime = (filter isPrime [2..] !!)
19:03:36 <credditor> nprime :: Integer -> Integer nthPrime n = filter isPrime [2..] !! n
19:03:52 <credditor> why does this throw  "The type signature for ‘nprime’ lacks an accompanying binding"?
19:03:59 <credditor> Brain is fried
19:04:01 <ertes> if you paste it here, you can use ";" to replace line feeds
19:04:24 <ertes> i'll let you figure that one out yourself =)
19:04:32 <credditor> gotcha
19:05:24 <ertes> if you write the type signature above the definition in an editor with a fixed width font, the problem should jump at you
19:06:56 <lordcirth> Indeed, always program in monospace fonts
19:07:16 <lordcirth> credditor, what editor are you using, btw?
19:07:22 <credditor> sublime
19:08:06 <credditor> what do you guys normally use?
19:08:20 <lordcirth> credditor, I use vim at the moment, eventually I will look at IDEs
19:08:27 <lordcirth> credditor, have you found the problem yet?
19:08:30 <ertes> credditor: emacs and vim are popular around here
19:08:33 <credditor> no feelin kinda dumb
19:08:39 <credditor> i know its an easy thing too
19:08:45 <fresheyeball> I am and odd one, but I love Haskell in Atom.io
19:09:00 <lordcirth> credditor, do you have your function and it's signature next to each other?
19:09:04 <ertes> credditor: you copied my function
19:09:25 <ertes> credditor: so the type signature for your function doesn't fit, but it's not the type that's incorrect
19:09:40 <ertes> so everything beyond "::" is correct
19:09:45 <ReinH> credditor: what's the name in front of the "::"?
19:10:00 <credditor> nprime :: Integer -> Integer
19:10:03 <credditor> here's the full
19:10:14 <ReinH> credditor: what's the name in front of the "::"?
19:10:21 <credditor> Integer
19:10:31 <lordcirth> no, the ::
19:10:33 <ReinH> credditor: what's the name in front of the "::"?
19:10:48 <lordcirth> front = left of
19:10:54 <credditor> oh
19:10:55 <credditor> wow
19:10:58 <credditor> nprime
19:11:03 <lordcirth> indeed
19:11:06 <ReinH> what's the name to the left of the "="?
19:11:14 <credditor> hahaahahahhaahhahahahaahahah
19:11:17 <credditor> hahahahahaahahahahaahaha
19:11:18 <lordcirth> :)
19:11:20 <credditor> hahahahahahaahaha
19:11:25 <ertes> i was just waiting for that laugh =)
19:11:26 <credditor> jumping out of my windows brb
19:11:33 <ReinH> ertes: :D
19:11:55 <ReinH> Windows, plural? Like, going back up and jumping again?
19:12:09 <credditor> yeah 1st story window
19:12:16 <credditor> it'll be a little hop
19:12:19 <ertes> "for all windows x, i'm gonna jump out of x"
19:12:20 <lordcirth> so out and back in?
19:12:37 <ertes> always quantify!
19:13:26 <credditor> huh this is weird
19:13:35 <credditor>  Couldn't match expected type ‘Int’ with actual type ‘Integer’; In the second argument of ‘(!!)’, namely ‘n’
19:13:49 <ertes> credditor: it's a peculiarity of (!!)
19:13:52 <ertes> :t (!!)
19:13:54 <lambdabot> [a] -> Int -> a
19:14:05 <ertes> Int and Integer are not the same type
19:14:36 <credditor> So if I change my header to nprime :: Integer -> Int it still throws it
19:14:50 <ertes> credditor: (!!) wants an argument of type Int
19:14:59 <credditor> ah I see
19:15:33 <credditor> do I have to mess with the list?
19:15:37 <ertes> no
19:15:49 <ertes> if you write (nprime :: Integer -> Int), then nprime takes an Integer
19:15:55 <ertes> you called that one 'n' in the definition
19:16:01 <ertes> (n :: Integer)
19:16:13 <ertes> and you pass n to (!!) as the second argument, which *should* be an Int
19:16:16 <credditor> gotcha
19:16:25 <credditor> so int -> int
19:16:32 <ertes> nope, that's still a type error
19:16:46 <credditor> yeah i see now
19:16:49 <credditor> int -> integer
19:17:00 <ertes> if you write it like that, it's a type error
19:17:32 <credditor> really? 
19:17:37 <ertes> "int" and "Int" aren't the same thing
19:17:40 <credditor> it complied with nprime :: Int -> Integer
19:17:51 <credditor> oh yeah sorry that was just lazy typing
19:18:03 <ertes> don't type lazily, because "int" is an actual thing =)
19:18:23 <ertes> haskell already makes your code short enough that you really don't need to type lazily on IRC =P
19:18:30 <Hafydd> If you want to be reasilly lazy, just omit the type signature.
19:18:34 <Hafydd> *really
19:19:22 <lordcirth> ertes, wait, what is 'int' ?
19:19:25 <credditor> love putting big numbers into this and watching the compute time
19:19:35 <ertes> lordcirth: a type variable that you called "int"
19:19:37 <geekosaur> a type variable, likely unspecified
19:19:43 <lordcirth> well, ok, yeah
19:19:47 <geekosaur> which changes the meaning of the signature considerablt
19:20:02 <lordcirth> I thought you meant that int was defined
19:20:12 <geekosaur> (sometimes you intend that. doing if when you don't intend it can be confusing...)
19:21:01 <credditor> ertes do you know what the time complexity on this alg is?
19:22:18 <ertes> @let f otherwise | otherwise = not otherwise | True = otherwise
19:22:20 <lambdabot>  Defined.
19:22:49 <ertes> credditor: it's terrible =)
19:22:54 <ertes> quadratic at least
19:25:01 <ertes> @undef
19:25:01 <lambdabot> Undefined.
19:25:42 <ertes> @let f otherwise | otherwise = not otherwise; f = const otherwise
19:25:44 <lambdabot>  .L.hs:160:1: error:
19:25:44 <lambdabot>      Multiple declarations of ‘f’
19:25:44 <lambdabot>      Declared at: .L.hs:157:1
19:26:00 <ertes> @let confusing otherwise | otherwise = not otherwise; confusing = const otherwise
19:26:01 <lambdabot>  .L.hs:160:1: error:
19:26:01 <lambdabot>      Multiple declarations of ‘confusing’
19:26:01 <lambdabot>      Declared at: .L.hs:157:1
19:26:18 <credditor> so this is weird
19:26:33 <geekosaur> ertes, need to match # of patterns
19:27:02 <geekosaur> although it reports that oddly, presumably because of the way it validates
19:27:17 <ertes> geekosaur: oh, of course
19:27:22 <ertes> @let confusing otherwise | otherwise = not otherwise; confusing _ = otherwise
19:27:23 <lambdabot>  Defined.
19:27:52 <ertes> or:  confusing not = otherwise  -- =)
19:28:03 <geekosaur> :p
19:28:22 <credditor> nprime 20 returns 73, but the 20th prime is 71. Gets worse the larger n is, nprime 1000 is 7927, not 7919
19:29:04 <lordcirth> credditor, then you have a fencepost error :)
19:29:09 <geekosaur> credditor, think about it a bit
19:29:31 <geekosaur> hint: try 0
19:29:41 <credditor> oh i see
19:29:45 <credditor> [2..]
19:29:55 <lordcirth> Lists start at index 0, not 1.
19:30:01 <geekosaur> well, no, the point is that ... that
19:30:22 <lordcirth> computers count from 0.
19:30:24 <ertes> or rather (!!) starts at 0 (lists have no inherent indexing)
19:30:33 <lordcirth> ertes, fair point
19:30:51 <credditor> oh shoot 
19:30:57 <credditor> that's pretty obvious jeez
19:31:40 <ertes> credditor: you can now get an even slower list of primes by applying 'nprime' to the list of all natural numbers =)
19:31:46 <ertes> map nprime [0..]
19:33:35 <pikajude> then you can use the `length` function on that list to see the total number of primes
19:36:51 <lordcirth> because that's a great idea
19:39:04 <EvanR> lol
19:40:26 <EvanR> simplifying assumption, there are finite number of primes
19:43:18 <dolio> Obviously.
20:02:30 <kvda> why is hlint talking so long to compile O.o
20:02:49 <kvda> haskell-src-exts
20:09:30 <pikajude> i don't know why haskell-src-exts takes so long to compile but that's the culprit
20:35:43 <nitrix> Hi, are there known risks with DeriveAnyClass?
20:36:21 <nitrix> deriving (ToJSON, FromJSON) seems nicer than the instance lines by themselves.
20:37:40 <glguy> nitrix: In released GHC it creates conflicts with generalizednewtypederiving
20:40:22 <nitrix> Does it produces a diagnostic or breaks badly?
20:41:58 <glguy> one of them stops working since the two use the same syntax
20:50:03 <jle`> DeriveAnyClass can often break things unexpectedly
20:50:20 <jle`> it's just annoying
20:50:26 <jle`> (in those cases)
21:05:55 <Ashy> i wish i could hoogle within this c# codebase :/
21:07:19 <EvanR> coog#e
21:10:59 <credditor> heading off, thanks for the help ertes/lordcirth
21:16:08 <ertes> credditor: let the quotients be with you!
21:17:54 <ertes> s/let/may/
21:25:05 <hteap> my cabal is completely broken, i cant install anything
21:25:16 <hteap> whats up with that?
21:25:45 <glguy> Did you turn your computer on?
21:25:50 <hteap> check
21:26:03 <glguy> Is the power on in the room?
21:26:09 <hteap> confirmed
21:26:21 <glguy> cool, sounds like you're all set
21:26:37 <hteap> nono, it does not work even slightly
21:26:44 <geekosaur> ...point being, nobody's going to be able to tell you anything if you don't show us what it's doing wrong
21:26:50 <geekosaur> @paste
21:26:50 <lambdabot> Haskell pastebin: http://lpaste.net/
21:27:28 <hteap> i do eg cabal install hwreq, it says, this is installed, i open ghci and :m Network.Wr and press tab and nada
21:27:59 <Clint> it says hwreq is installed?
21:28:23 <hteap> All the requested packages are already installed:
21:28:42 <glguy> hteap: are you in a directory with a cabal sandbox?
21:28:52 <hteap> i think something like that must have happened
21:29:11 <hteap> can i stop it from doing this??
21:30:14 <hteap> i press alt+r and type cmd in the run box then use cabal in the command prompt it opens
21:30:17 <glguy> If you're in a sandbox, then you need to use cabal repl to get a ghci prompt that uses the packages you're installing in the sandbox
21:30:34 <hteap> no i dont want any of this sand box
21:30:53 <hteap> why is it not installing packages in a way that they are visible
21:31:26 <hteap> cabal -disableSandbox install
21:32:09 <glguy> What does "cabal sandbox hc-pkg list" say?
21:32:11 <hteap> also, this seems to have happened all on its own
21:32:34 <hteap> glguy, wuite a lot
21:32:37 <hteap> uite*
21:32:40 <hteap> sry
21:32:47 <hteap> quite*
21:32:57 <glguy> OK, try: cabal repl
21:33:22 <hteap> 7.10.2
21:33:51 <glguy> Does your Network.Wreq module work there?
21:34:24 <hteap> yes
21:36:31 <hteap> why do i have to use cabal repl instead of ghci now? how do i make typing ghci at the command prompt open up a working ghci that is connected to my cabal so that cabal install installs packages visible to ghci
21:37:16 <glguy> It sounds like you managed to create a sandbox in your home directory, or wherever CMD executes things by default
21:37:26 <glguy> You can delete the sandbox if you want with "cabal sandbox delete"
21:37:38 <hteap> awesome!
21:37:40 <hteap> tanks
21:37:50 <Koterpillar> aircraft carriers
21:38:26 <hteap> honey i shrank the nuclear submarine
21:38:42 <hteap> ok ciao! thanks again
21:54:29 <andrew> which version of llvm is supported with -fllvm in 7.10.2?
21:57:22 <glguy> andrew: Look up the -fllvm flag in the GHC users guide for whatever version of GHC you're interested in
22:04:41 <EvanR> is there a standardish minimum which takes a default for empty
22:06:18 <EvanR> or returns a Maybe
22:06:24 <ertes> EvanR: yes, prepend the bottom element
22:06:32 <EvanR> guess the safe package
22:06:41 <EvanR> and thats clever
22:06:58 <ertes> :t minimum . (minBound :)
22:06:59 <glguy> lens has minimumOf, it returns a Maybe and works on more than Foldable
22:07:00 <lambdabot> (Ord c, Bounded c) => [c] -> c
22:07:24 <EvanR> > minimum [Nothing, Just 1, Just 2]
22:07:26 <lambdabot>  Nothing
22:07:34 <EvanR> bollocks
22:07:42 <EvanR> :t minimumOf
22:07:43 <lambdabot> Ord a => Getting (Endo (Endo (Maybe a))) s a -> s -> Maybe a
22:07:56 <EvanR> Endo^2
22:09:04 <dubbelosix> hello there...haskell newbie here...i'm trying to understand why this doesnt work myfn :: a -> [a] myfn x = "test"
22:09:31 <dubbelosix> a -> [a] should mean that my function accepts any type and returns a list of that type right?
22:09:32 <ertes> dubbelosix: myfn promises to work for all types 'a', but then assumes that (a = Char)
22:09:35 <glguy> dubbelosix: Your type signature says that you function will work for any 'a' the user might choose
22:09:46 <dubbelosix> ah
22:12:50 <dubbelosix> got it thanks!
22:21:36 <dfeuer> Am I correct in thinking that  fromList xs = LogicT $ \c n -> foldr c n xs   converts a list of possibilities into a LogicT computation representing those possibilities?
22:27:16 <ertes> dfeuer: yes
22:27:30 <dfeuer> Thanks, ertes.
22:46:06 <grantwu> If i have one module that has a type synonym
22:46:20 <grantwu> How do I export the constructors of that a datatype used in that type synonym
22:46:42 * Clint squints.
22:46:51 <grantwu> sorry
22:46:57 <glguy> grantwu: By exporting the data type that the type synonym is a synonym for
22:47:02 <grantwu> ah.
22:47:10 <grantwu> thanks.
22:47:33 <grantwu> Is there a way to export everything in a file as well as some other thing?
22:48:00 <glguy> You can export a module in its own export list iirc
22:48:08 <grantwu> Huh
22:48:48 <grantwu> It doesn't seem to like it
22:48:58 <glguy> You can
22:49:08 <grantwu> do I put the full module name?
22:49:13 <grantwu> in a module Compile.Types.AsmTree
22:49:20 <glguy> Yeah, that's the module's name
22:49:29 <grantwu> if I try to export "Compile.Types.AsmTree" I get Not in scope: type constructor or class ‘Compile.Types.AsmTree’
22:49:40 <glguy> You have to prefix module exports with "module"
22:50:08 <grantwu> oh.
22:50:29 <glguy> Haskell 2010 section 5.2 export lists
22:50:36 <grantwu> having had the misfortune of dealing with Python import hell, Haskell's importing system seems to make so much sense
22:50:42 <glguy> Reading that might help with this line of questions
22:52:50 <grantwu> oh no... I think I have done something very dumb...
22:53:35 <grantwu> I have a data Foo a b = .... in a module Util, and a bunch of other modules which define type Foo = Util.Foo Bar Baz
22:53:58 <grantwu> Wait, no, I can solve this by having client modules just import Util qualified, I think?
23:04:32 <ab9rf> probably, yes
23:04:51 <EvanR> grantwu: sort of sounds like the lonely road of naming all your types T and importing qualified everywhere ;)
23:04:58 <EvanR> Module1.T Module2.T... etc
23:05:23 <grantwu> no no it's fine
23:05:39 <grantwu> infinitely preferable to 8 different types representing a function definition
23:06:06 <EvanR> 8 different types with the same name?
23:06:30 <ab9rf> EvanR: heh
23:06:43 <ab9rf> how can a function have more than one type?
23:09:08 <EvanR> id :: Int -> Int, id :: Char -> Char !
23:10:20 <ab9rf> fair point :)
23:11:00 <lpaste> glguy pasted “no most general type for ab9rf” at http://lpaste.net/269438
23:14:11 <grantwu> Well, we have a compiler with many different IRs, each needs to represent a function definition in a similar way
23:14:58 <grantwu> the overall shape of the datatypes is similar, but for some, they have names, in other places we've replaced all identifiers with virtual registers, etc.
23:23:30 <EvanR> grantwu: ah now the problem seems more clear
23:24:11 <EvanR> there could be 10 very similar but not the same representations
23:24:26 <EvanR> sounds hellish to do without types
23:38:38 <grantwu> I have a map from foos to bars... How do I add a [(foo, bar)] list to it?
23:38:50 <grantwu> I feel like I want something from Traversable
23:41:39 <Rotaerk> grantwu, what about union . fromList
23:42:20 <grantwu> :O
23:42:23 <grantwu> very nice.
