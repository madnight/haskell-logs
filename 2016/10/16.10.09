00:02:58 <nathyong> Does anybody have an opinion about whether to use one merged MonadState for an entire stack vs using multiple layers of state?
00:03:21 <nathyong> fwiw I'm building a code generator, with a state layer for "the entire module" as well as one for "the current function"
00:03:21 <EvanR> multiple layers sounds terrible
00:04:27 <EvanR> esp MonadStates
00:04:50 <nathyong> the main issue I'm trying to wrap my head around is how to "fork and run part of the computation"
00:05:30 <nathyong> for example how to define a new function inside one function (if it's all in the same state)?
00:05:31 <EvanR> fork?
00:05:47 <EvanR> concurrency?
00:05:53 <nathyong> wrong word
00:06:19 <nathyong> e.g. data FunctionState = FunctionState { insts :: Seq Instruction }
00:06:20 <EvanR> in that case, do you have a function for running code already
00:06:47 <EvanR> note it should still just be a function, with whatever context it needs to operate, since its not concurrent
00:07:04 <nathyong> vs. data AllTheState = AllTheState { current_function_insts :: Seq Instruction, (other things) }
00:07:37 * hackagebot hspec-discover 2.3.1 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.3.1 (SimonHengel)
00:07:37 * hackagebot hspec 2.3.1 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.3.1 (SimonHengel)
00:07:42 <EvanR> it sounds like you want to run an internal interpreter, not have multiple layers of MonadState
00:08:01 <nathyong> hmm, what do you mean by that?
00:08:15 <nathyong> I've heard a lot about Free interpreters, but is that what I want?
00:08:27 <EvanR> anywhere in any part of the program you can do runMyIntepreter ints otherStuff program
00:08:31 <EvanR> not Free
00:09:42 <EvanR> that would have nothing to do with the "current monad"
00:10:27 <nathyong> Ah, yeah that makes sense
00:11:14 <nathyong> EvanR: is there any way that I can build up that `insts` parameter then? Currently I'm doing that with a WriterT
00:11:32 <EvanR> eh?
00:11:49 <nathyong> for runMyInterpreter insts otherStuff program
00:11:50 <EvanR> if you use writer, you cant go back and look at it
00:12:03 <EvanR> build it up from what
00:13:15 <nathyong> as in, some environment to construct the list of instructions
00:13:34 <EvanR> how do you construct it
00:14:53 <nathyong> atm I've got a bunch of code that's got type `MonadState InstructionState m => m ()` that I chain together to emit instructions
00:15:57 <EvanR> are you trying to continue appending instructions while interpreting this other program
00:16:18 <EvanR> why do you need to give it instructions, not sure if youre saying this is the input or the output
00:16:32 <nathyong> ah, instructions is the output
00:16:34 <EvanR> are you sure you need all this state to do what youre doing
00:17:06 <EvanR> State monads are nice to solve isolated problem and be done with it, rather than encompass your entire application
00:17:34 <EvanR> if its the output, then get that input from runMyInterpreter and output it
00:17:41 <EvanR> errr get that output from
00:19:04 <nathyong> So I should consider factoring out the state, okay
00:19:38 <EvanR> no, i mean is your algorithm really dependent on large scale state
00:19:46 <nathyong> I think so
00:20:08 <EvanR> well i tried ;)
00:20:10 <koz_> How do you tell cabal to look for dependencies in a local directory foo?
00:20:26 <nathyong> EvanR: thanks for your time
00:21:12 <nathyong> koz_: I know that with stack you can just add it to your `stack.yaml` (if migrating is an option -- I find it makes a lot of package management easier)
00:21:36 <koz_> nathyong: I don't really have the time to learn Stack right of this minute. I will one day, but it won't be today.
00:22:14 <nathyong> koz_: well if your dependency is another cabal project, I'd just install both of them into the same sandbox
00:26:33 <koz_> nathyong: Never mind, it was 'cabal sandbox add-source' that I wanted.
00:42:09 <hvr> koz_: if you have a recent enough cabal, you could try http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
00:42:41 <hvr> koz_: there it's just a matter of adding a 'packages: . some-package-i-want-local/' line to your cabal.project file
00:42:44 <koz_> hvr: That's really cool! Thanks.
00:43:09 <hvr> koz_: but be warned, it's a tech-preview; so it's not polished yet
00:43:29 <hvr> but something that'll replace 'cabal sandbox'
00:43:39 <hvr> in the future
01:12:49 <Hanonim> Hello people !
01:13:14 <koz_> Hanonim: Hihi!
01:14:44 <Hanonim> I'd like to start learning haskell more seriously, but I wonder how much it is actually being used in production around the globe
01:15:33 <mikail`> Hanonim, it's getting increasingly popular in the financial sector here in the UK
01:15:50 <Hanonim> mikail`: because of its "correctness" ?
01:16:00 <mikail`> some blockchain start ups as also using it
01:16:07 <mikail`> that's one of the reasons
01:16:57 <srhb> Hanonim: Yes, I think correctness is the main driving force. It's easier to convince yourself that what you've written is actually right.
01:17:20 <koz_> Hanonim: I would also say that learning Haskell will help you program better in *every* language.
01:17:41 <koz_> It forces you to think about abstraction in ways other languages simply can't express.
01:18:44 <koz_> Also, could someone explain to me how @pl translates '\x -> x * x' into 'join (*)'?
01:19:36 <Hanonim> I mainly use clojure these days, would haskell provide a much different experience ?
01:20:06 <koz_> Hanonim: The static typing is a big one.
01:20:29 <koz_> Also, I don't believe Clojure has functors, applicatives and monads at the explicit language level.
01:20:36 <koz_> (or at least, it didn't when I last looked)
01:20:50 <pavonia> koz_: It probably simply has a rule "f x x = join f x"
01:21:08 <koz_> pavonia: I guess I was more curious about why that works.
01:21:42 <pavonia> That's the Monad instance for (->) r
01:26:19 <Alper> Hello, can someone check my answers for a haskell quiz please? http://lpaste.net/249932
01:28:49 <srhb> Alper: The first one is wrong.
01:29:50 <Alper> I see, the type is not specified, so the answer for question number 1 must be c
01:29:59 <srhb> Alper: Right.
01:30:03 <Alper> Updating.
01:30:05 <Alper> Thanks.
01:33:42 <neonfuz> so how good is jhc?
01:36:55 <hvr> neonfuz: when it works, it's quite good
01:37:31 <hvr> neonfuz: but a) it has long compile times for larger programs
01:37:35 * hackagebot yesod-job-queue 0.3.0.1 - Background jobs library for Yesod.  https://hackage.haskell.org/package/yesod-job-queue-0.3.0.1 (nakaji_dayo)
01:38:32 <hvr> neonfuz: b) there's a few minor bugs, and it supports little more than H2010, which means you can't use much of hackage
01:39:33 <hvr> neonfuz: but the main problem is that jhc's maintainer is quite busy, so jhc dev is unfortunately stalling; which is sad since JHC does create very compact and fast executables
01:41:45 <neonfuz> hvr: are there not many people working on it besides him?
01:45:29 <ashishnegi> hi.. how do we find stack lts for `ghc-7.10.1` ?
01:46:01 <hvr> neonfuz: well, the ajhc guys did some work which iirc got folded back into jhc
01:46:17 <hvr> neonfuz: but the ajhc project is done afaik
01:46:53 <hvr> neonfuz: see http://ajhc.metasepi.org/
01:59:02 <ineb> what is the syntax to call a function, that takes two arguments which themselves are taking two arguments each? None of my current tries are working: Rectangle (Point 0 0) (Point 5 5)
01:59:20 <neonfuz> hvr: cool, k
01:59:45 <neonfuz> ineb: looks good to me
02:00:04 <ineb> neonfuz: ok, the problem is somewhere else
02:01:09 <Gurkenglas> koz_, https://hackage.haskell.org/package/pointfree-1.1.1.2/src/Plugin/Pl/Rules.hs -> hmm the last step is probably "ap f id --> join f"
02:02:17 <Gurkenglas> (or perhaps "(=<<) id --> join"... maybe I'll better try to find it from the other end)
02:02:58 <Gurkenglas> Oh I missed the following resolution of his question.
02:05:24 <lyxia> ashishnegi: is there one?
02:05:52 <ashishnegi> lyxia: no.. it starts with 7.10.2
02:06:34 <ashishnegi> Has anyone tried deploying on heroku with halcyon ?
02:07:11 <archie__> Hi everyone. Just curious, if I'd like to use a function / module defined in a third party package (from hackage), do I need to add the whole package as a dependency? What if I just need one function?
02:09:10 <pavonia> archie__: If it doesn't have a lot of inner-package dependencies, you could just copy the source code for that function into your file
02:09:47 <pavonia> Otherwise you need the whole package as a dependency
02:13:31 <miomio9090> 4 Craig A Hewitt|ccsave|448 â€“ 4798531207480379|7 |2017||Derek | Ross | 109A E Washington Jackson Rd | Eaton | Ohio | 45320 | US | 9375335415 |-| Derek.ross107@gmail.com
02:13:32 <miomio9090> 5 Joseph B Young|ccsave|927 â€“ 4147099626941361|7 |2017||Joseph | Young | 15405 SW 116th Ave Suite 208 | King City | Oregon | 97224 | US | 5036840507 |-| drjosephyoung@gmail.com
02:13:34 <miomio9090> 6 Richard Mann|ccsave|611 â€“ 4154178053215968|12 |2016||Richard | Mann | 95 Madison Ave. Ste 100 | Morristown | New Jersey | 07960 | US | 9739843300 |-| dt2b@msn.com
02:13:36 <miomio9090> 7 Trang X Ngo|ccsave|171 â€“ 6011499433791413|1 |2019||Trang | Ngo | 4124 Winona Ct | Denver | Colorado | 80212 | US | 8326134123 |-| trango79@hotmail.com
02:36:34 <ReinH> @where ops
02:36:35 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
02:38:06 <Normen> Has anyone managed to run `:HdevtoolsType` within Vim utilizing `vim-hdevtools`? `hdevtools` at the command line works just fine. But within Vim I always get `Error loading targets ...`. Even for a trivial case like http://lpaste.net/250030.
02:45:44 <ongy> I'm running vim with hdevtools
02:46:24 <ongy> works fine on my machine TM. Are you using stack? Do have you ghc installed with your package manager? how have you installed hdevtools?
02:48:25 <Normen> Yes. I'm using stack.
02:48:39 <Normen> stack install hdevtools
02:49:07 <Normen> hdevtools works just fine on the command line, but not within vim
02:49:10 <ongy> have you started vim with stack (iirc stack exec --vim) or "normally"?
02:49:25 <Normen> "normally"
02:49:52 <Normen> I use MacVim
02:49:56 <ongy> if it works on command line, it shouldn't make a difference.
02:50:08 <Normen> but let me try stack exec --vim
02:50:24 <Normen> Yes, that's what I thought... but it doesn't. 
02:50:45 <monando> Is there a module which exports a function which parses text and compiles it to Haskell. I could use System.Process to run ghc but actually I want a non IO function...
02:50:54 <Normen> hdevtools on the command line works outside a stack project as well as inside
02:52:12 <monando> Is it called an interpreter? Maybe even a c++ interpreter would do...
02:52:55 <Normen> `stack exec -- vim` also does not work for the simple case at http://lpaste.net/250030. It still complains about error loading targets ... Failed to load interface for `Network.Wreq`.
02:53:06 <ReinH> monando: what do you mean "parses text"?
02:53:14 <monando> I want to start reading Haskell files and creating data types to hold the definitions
02:53:24 <ReinH> There isn't an eval function, no.
02:53:39 <ReinH> but you can parse haskell files
02:53:49 <monando> What about for smaller languages?
02:54:02 <ReinH> @hackage haskell-src-exts
02:54:02 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
02:54:19 <ReinH> You can write parsers, interpreters, and compilers in Haskell
02:55:05 <ongy> Normen: that error message usually means that hdevtools can't find the package used. Are you maybe inside a different sandbox (snapshot with stack I think) with vim than commandline hdevtools?
02:55:50 <Normen> Hmmm... well how to find out? :-(
02:56:02 <monando> Awesome! The documentation isn't so clear, I can't see how it represents the code... Are there any nice projects using this package?
02:56:42 <ongy> try an example without the import in line 5, if that works I think it's highly likely
02:57:29 <Normen> Oh! `killall hdevtools` and then `stack exec -- vim` and then `:HdevtoolsType` WORKED!
02:57:56 <monando> Actually it's totally brutal. This does not look like the most simple way to understand the compilation steps. Is there a smaller version perhaps without extensions?
02:58:02 <Normen> Well... that's already pretty good... but actually I'd like to keep on using MacVim
02:59:05 <monando> And does this actually compile to anything? Or does it just load the code into various types?
02:59:26 <Normen> Maybe `let g:syntastic_haskell_hdevtools_args=...` can fix the "issue"?
02:59:56 <ReinH> It is not a compiler.
03:00:49 <ReinH> It is used by packages like ghc-mod and hindent that want a haskell parser.
03:00:53 <monando> Isn't ghc written in Haskell? I can't believe iv never checked hackage for it...
03:01:13 <ReinH> ghc is mostly written in a combination of Haskell and C++
03:01:21 <monando> Oh :(
03:01:24 <ReinH> It isn't on hackage.
03:02:02 <monando> I was trying to understand how to reactor code like rewrite rules
03:02:18 <monando> Refactor*
03:03:16 <ReinH> I'm not sure what that means.
03:04:47 <monando> If a function is constructed of other functions passed into each other as arguments, i would like to be able to conduct fusion, removing redundant occurrences of a function composed with its inverse
03:07:13 <ReinH> So you want to write rewrite rules?
03:07:47 <ReinH> That isn't something rewrite rules can help with, except on a case-by-case basis.
03:08:01 <monando> Assuming I have contained isomorphisms in a class so that I can perform isInverse ::  (a->a->a) -> (a->a->a) -> Bool
03:08:19 <ReinH> That's a lot to assume
03:08:22 <ReinH> since it's impossible
03:08:39 <monando> I dont want to use rewrite rules, I want to implement something equivalent
03:09:55 <ReinH> Well, you're going to run into some problems
03:10:01 <ReinH> The first is that what you want is impossible
03:10:07 <monando> getInverse :: Isomorphism f a => f a -> f a
03:10:27 <monando> I'm assuming I can indicate an inverse
03:10:27 <ReinH> the second is that, were it possible, what you want would involve modifying GHC itself
03:10:37 <ReinH> Yes, and I'm telling you that assumption is wrong.
03:10:45 <monando> It's not
03:10:55 <monando> I can write that
03:11:02 <ReinH> Write what?
03:11:03 <monando> I don't know why you think i can't
03:11:11 <ReinH> The first one is impossible
03:11:16 <ReinH> The second one isn't helpful
03:11:31 <monando> I can hold a function along with an inverse
03:11:39 <monando> I specify the pairing
03:11:53 <ReinH> Ok, that's a third claim, and while true, is also not helpful
03:12:15 <ReinH> you said you want to detect inverses and eliminate them
03:12:22 <ReinH> so you need to be able to detect them
03:12:24 <ReinH> not produce them
03:12:28 <monando> your being facetious.
03:12:33 <ReinH> I am definitely not.
03:12:49 <monando> I can detect then once I have defined how
03:13:01 <ReinH> You can't detect them.
03:13:03 <ReinH> That's what I'm saying.
03:13:18 <ReinH> Functions are not comparable.
03:13:25 <ReinH> And I'm pretty sure you don't know what facetious means.
03:13:32 <ddk> hello all I wanted to read a file and update it but ghci is show me error msg like *** Exception: histRecFile: hPutStr: illegal operation (handle is closed) ..why is this even i have closed handle at last
03:14:07 <ReinH> ddk: you'll have to show us your code so we can see why it's being closed.
03:14:09 <ReinH> @where lpaste
03:14:09 <lambdabot> http://lpaste.net/
03:14:26 <monando> A more simple question which might upset you less but serves this purpose could be detecting a function by its name
03:14:29 <ddk> ok
03:14:31 <ReinH> I am not upset.
03:14:59 <ReinH> I am trying to explain something to you.
03:15:25 <monando> Needlessly, your just telling me you don't understand what I'm asking
03:15:41 <ReinH> That is not the only thing I have said to you
03:16:02 <ddk> you may look at http://lpaste.net/250110
03:16:15 <ReinH> In fact, I never said that at all.
03:16:35 <monando> Suppose I have restricted myself to functions composed of bivariate functions. I would like to detect if a function uses a particular function in its definition. Based on its name
03:16:56 <ReinH> If you just want to detect a function by its name, why does it matter what sort of function it is?
03:17:14 <monando> I'm composing them using (.)
03:17:54 <ReinH> But I'll bite. What is a bivariate function?
03:18:10 <monando> In a big long line. If they had more than 2 arguments I would need something more complex than list. So it's simply for example that I'm using this simple approach
03:18:29 <monando> I indicated this with the sentence starting "suppose"
03:18:43 <ReinH> "If they had more than 2 arguments I would need something more complex than list." I don't see how this follows.
03:19:07 <monando> I'm folding using (.)
03:19:28 <monando> I don't know how to handle more complex combinations
03:19:46 <monando> But again I attempted to avoid that discussion with my supposition
03:19:51 <ReinH> I still don't know what a "bivariate" function is. That is not a standard term.
03:20:09 <monando> Off two arguments
03:20:13 <monando> Of
03:20:22 <ReinH> :t (.)
03:20:24 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:21:07 <monando> Oh yeah, I guess I'm partially applying them with arguments, sorry that was my mistake
03:21:08 <ReinH> Two things. First, (.) composes functions of one argument. Second, technically all Haskell functions are functions of one argument.
03:21:16 <ddk> earlier i just used fun = do ; r <- readfile name ; writefile name (r ++r)   this also show error why ..~~Q
03:21:40 <monando> :t ((.).(.))
03:21:42 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:21:47 <monando> Nothing like this
03:21:51 <ReinH> ddk: because readFile is allowed to close its handle when it is done reading.
03:22:07 <monando> Ok sorry for that mistake
03:22:21 <ReinH> ddk: http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#v:withFile
03:22:44 <monando> You have taken me fat from what i was getting at. I guess I won't be able to move the discussion back to what I wanted to discuss
03:23:20 <ReinH> I'm not preventing you from discussing anything.
03:24:13 <monando> It's the third time iv asked here, normally after exhaustive description is coaxed from me I'm then ignored
03:24:38 <ddk> i wanted to know what's wrong I have done in my code
03:25:31 <ReinH> ddk: the handle is closed after readFile but before writeFile, you can use withFile instead to guarantee that the handle is available until withFile exits.
03:25:45 <monando> I would really rather you understood what i was saying instead of probing my poor phrasing, often my attempts to clarify my meaning lead to further pointless segways and inappropriate lessons
03:26:16 <ReinH> I am trying to understand what you are saying, and I can only do that by trying to interpret your "poor phrasing". I have not yet learned how to read minds.
03:26:22 <ddk> is here also the same case ...http://lpaste.net/250110
03:26:34 <ddk> I can't get it 
03:27:23 <monando> Finally leading to barely even any commentary in my actual problem, but a greatly increased and fruitless requirement on me to describe things if rather not.
03:28:08 <monando> I would say that "implementing rewrite rules in pure Haskell" was an adequate description
03:28:08 <ReinH> monando: perhaps that is because you are not very good at explaining yourself.
03:28:16 <monando> No
03:28:31 <monando> I'm being probed facetiously
03:28:46 <ReinH> Other people are able to ask questions and receive answers.
03:28:50 <monando> Great
03:29:07 <monando> I'm happy for them
03:29:08 <sbrg> monando: i just read through the backlog and i'm not sure what you want to accomplish either. 
03:29:24 <ReinH> monando: You can blame us for this if you want, but it won't help you be understood.
03:29:30 <ReinH> You are simply not making sense.
03:29:47 <monando> If you don't know what rewrite rules do I guess you can't help
03:29:55 <ReinH> I do know what rewrite rules do.
03:30:02 <ReinH> I am not convinced that *you* know what they do.
03:30:10 <monando> Then how do I implement then in pure Haskell?
03:30:17 <ReinH> You don't.
03:30:22 <ReinH> That is not a feature GHC provides.
03:30:34 <ddk> ReinH : please look at my code at http://lpaste.net/250110 
03:30:43 <monando> I can parse the Haskell file and reactor it
03:30:53 <ReinH> That's true.
03:30:56 <ReinH> And not relevant.
03:31:13 <ReinH> You can't port that to GHC
03:31:19 <ReinH> Because, again, GHC does not provide that feature.
03:31:39 <ddk> it doesn't seems to me that why that handle would be closed even i have opened explicitly with openFile
03:31:45 <monando> I load my decomposed definitions into a datatype, and then indicate which functions are inverse of each other and remove redundancy
03:31:58 <ReinH> Ok. That's fine. But it won't help you write a rewrite rule.
03:32:02 <ReinH> I'm not sure how to be more clear.
03:32:06 <ReinH> GHC can't do what you want.
03:32:18 <monando> !????!!!??
03:32:39 <monando> I don't mean implement a new extension our pragma
03:32:46 <monando> Or
03:33:18 <monando> I mean emulate the functionality of rewrite rules
03:33:29 <ddk> hello is there some one to look at a small problem for me ....
03:33:43 <ReinH> Ok, now you mean "emulate" rewrite rules. This is once again a new claim.
03:33:56 <ReinH> What does it mean to emulate rewrite rules??
03:34:04 <ReinH> Sorry, ? key is stuck a bit
03:34:38 <ddk> why this code is giving msgs like  ***Exception: histRecFile: hPutStr: illegal operation (handle is closed)
03:34:39 <ReinH> ddk: I'd guess that it's a similar problem. The handle is being closed before you finish using it.
03:34:49 <ReinH> Again, you can use withFile to acquire a handle in a way that will prevent that.
03:34:52 <monando> ddk, can you include the error in your paste?
03:35:28 <ddk> ReinH : but i have closed the handle explicitly after doing all things
03:35:32 <monando> Oh sorry I didn't see your post detailing that
03:35:54 <ddk> http://lpaste.net/250110
03:36:04 <ReinH> ddk: Yes, but the problem is that GHC is closing the handle for you.
03:36:21 <ReinH> Have you tried using withFile yet?
03:37:16 <ddk> ReinH : actually I have to use the result further even after updating the file
03:37:29 <ReinH> monando: You can't write a GHC rewrite rule using a Haskell data type. I don't know what it means to "emulate rewrite rules", so I can't speak to that.
03:37:36 <ddk> so i have not used withFile yet
03:37:39 * hackagebot tuntap-simple 0.1.0.0 - A simple tun/tap library  https://hackage.haskell.org/package/tuntap-simple-0.1.0.0 (riaqn)
03:38:03 <ReinH> I can imagine some things you might mean, but it would not be prudent for me to make assumptions.
03:38:04 <riaqn> Wow we get a bot here.
03:39:26 <phadej> can template haskell generate rewrite rules_
03:39:33 <ddk> ReinH : and also how to do error checking in withFile
03:39:51 <monando> I mean that i should be able to decompose a function defined in terms of other functions and detect, based on their name and a specification of names which are inverses of each other, and remove those which compose to yield identity *just like how rewrite rules are used* (I have seen it used in this way in pipes)
03:40:58 <monando> How this is not clear I have no clue
03:41:10 <ReinH> Well, for starters, you only mentioned this just now.
03:41:17 <ReinH> Before now you were just talking about rewrite rules.
03:41:29 <ReinH> And made no mention of "emulating" them.
03:41:35 <ddk> ok byee
03:42:10 <monando> (monando) If a function is constructed of other functions passed into each other as arguments, i would like to be able to conduct fusion, removing redundant occurrences of a function composed with its inverse
03:42:21 <ReinH> Yes, you said that.
03:42:29 <ReinH> fusion is done via rewrite rules
03:42:32 <ReinH> real ones, not emulated ones
03:42:47 <ReinH> so when you said both fusion and rewrite rules, I assumed you were talking about fusion and rewrite rules
03:42:52 <ReinH> not emulated fusion and emulated rewrite rules
03:43:05 <monando> Aha! I have pinned you down, I'm sure you understand me now so it's no good being evasive
03:43:25 <ReinH> Is that what you think is happening?
03:43:45 <monando> (monando) I was trying to understand how to reactor code like rewrite rules
03:44:02 <ReinH> That is barely even a sentence.
03:44:12 <monando> Refactor*
03:44:21 <ReinH> You can continue to believe that I'm the one with the problem if you want, but it won't help you get answers.
03:44:35 <ReinH> The common factor in your inability to be understood is you, not me.
03:44:44 <monando> *like* And you managed to conclude I somehow wanted to tinker with ghc
03:44:57 <ReinH> Yes, because you repeatedly talked about rewrite rules
03:45:01 <ReinH> which are a thing GHC does
03:45:26 <monando> (monando) I dont want to use rewrite rules, I want to implement something equivalent
03:45:58 <ReinH> <ReinH> Well, you're going to run into some problems
03:45:58 <ReinH> <ReinH> The first is that what you want is impossible
03:46:13 <monando> !!!!!!!!!!
03:46:32 <ReinH> You can't reflect on function names from the Haskell runtime
03:46:42 <ReinH> you can't compare Haskell functions with each other
03:46:47 <monando> *exasperated* throws irc channel into cauldron
03:46:55 <sbrg> So you want to write a tool does something similar to rewrite rules for Haskell source code, in Haskell? 
03:47:02 <ReinH> Apparently.
03:47:10 <ReinH> I'm not sure why they didn't just say so.
03:47:34 <monando> sbrg, yes! At last!
03:48:03 <sbrg> monando: seriously? how about stating "I want to write a tool that does something similar to rewrite rules for Haskell code, in Haskell"
03:48:09 <ReinH> I have already tried to explain why this is not feasible.
03:48:11 <monando> I tried to say that and you started saying all crazy things to indicate I wasn't saying it properly
03:48:15 <sbrg> that would have made it pretty clear from the get go.
03:48:40 <monando> Next time I will write that for sure
03:48:53 <ReinH> Something equivalent to rewrite rules could be another GHC mechanism for term rewriting.
03:49:10 <ReinH> I can't read your mind, so I don't know what you mean by equivalent if it is ambiguous
03:49:16 <monando> The reason I did not is because I assumed I had earlier but that phrasing had not passed the compiler
03:49:39 <ReinH> You went on a tangent about composition and "bivariate" functions, and I tried to follow you
03:49:42 <sbrg> okay, now that we have established what you want to do: what is your question?
03:49:45 <bollu> guys, cat. theory question
03:49:48 <ReinH> then you accused me of trying to derail you
03:49:55 <bollu> the free product of group is the coproduct in Grp, right?
03:50:14 <ReinH> bollu: Yes, confusingly enough.
03:50:31 <bollu> ReinH: okay, so now, what's the amalgamated free product?
03:50:38 <monando> I was describing my approach
03:50:38 <bollu> ReinH: is there a universal property for it?
03:50:49 <ReinH> monando: That's fine, and I was trying to understand you
03:50:54 <bollu> ReinH: best as I can tell, you make the free product, then quotient stuff out that you're choosing to identify?
03:50:54 <ReinH> But then you accused *me* of derailing you
03:50:59 <ReinH> you are the one who initiated the tangent
03:51:26 <ReinH> bollu: I'm not sure if it has an analogue in Grp or not.
03:51:27 <monando> So anyway, i have decomposed my function which was written by interspersing with (.)
03:51:33 <bollu> ReinH: ah, okay
03:51:43 <ReinH> How have you decomposed it?
03:51:46 <bollu> ReinH: I'm studying algebraic topology, so I want to get a good handle on this (for van kampen)
03:51:48 <ReinH> What do you mean by decompose?
03:52:00 <ReinH> Once you compose functions together with (.), you have a new function.
03:52:06 <ReinH> Functions are opaque. They cannot be decomposed.
03:52:14 <ReinH> So I don't know what you mean by "decompose", and I am asking.
03:52:26 <monando> It was composed like that, I checked for (.) In the same way build works
03:52:44 <ReinH> How did you check for (.)? What is doing the checking?
03:52:52 <sbrg> so you are looking at some haskell source code and you have determined that the definition of some function f = g . h, for example?
03:53:05 <sbrg> and you have used that information to decompose f into (.) g h? 
03:53:16 <monando> Yes
03:53:30 <ReinH> Guessing what you mean every time is not a very effective way to communicate
03:53:33 <ReinH> Just tell us what you mean
03:53:38 <monando> Then I can check to see if g is inverse of h
03:53:51 <monando> You know build?
03:53:55 <sbrg> how do you check that? 
03:54:09 <monando> Against a look up table
03:54:20 <ReinH> I assume you mean, e.g., foldr/build fusion, but I suppose I shouldn't assume that either.
03:54:28 <monando> I specify which functions are inverse of each other
03:54:50 <monando> I do mean that, thanks for you helpful descriptive syntax
03:55:04 <ReinH> Are you trying to write some sort of preprocessing step that parses a Haskell file and outputs another Haskell file?
03:55:18 <monando> I guess so
03:55:29 <monando> But I don't mind if it just executes
03:55:45 <monando> I don't need to read the refactored code
03:56:06 <ReinH> Ok, but without an eval function I don't see that happening directly.
03:56:21 <monando> Just to ensure my compiled code doesn't have expensive versions of id in it
03:56:30 <sbrg> i also don't quite see how you can determine whether g and h are each others inverses in the general case. 
03:56:56 <monando> Ghc can compile the refactored code
03:57:35 <monando> sbrg, obviously you can't, that's why I specify that they are. Oh said this a few times now
03:58:07 <sbrg> i was unsure what you meant or whether you used the correct word, tbh. but fair enough. but you still haven't really asked a question
03:58:09 <ReinH> Other people may have started reading the conversation at different points.
04:01:12 <bollu>  ReinH would you take another cat. theory question?
04:01:19 <ReinH> bollu: sure
04:01:25 <bollu> ReinH: so, as I understand, the fundamental object in HoTT is the C_infty groupoid?
04:01:37 <bollu> where each "layer" is the homotopies of the n-1 th layer?
04:01:45 <bollu> ReinH: actually, should have said Hott, not cat. theory
04:01:55 <ReinH> I don't know.
04:01:56 <bollu> ReinH: like, why would someone choose to study something this crazy? ;)
04:02:02 <bollu> ReinH: oh, okay :)
04:11:43 <monando> Sometimes people say helpful things just in reaction to the description if a problem, but normally only if it's well phrased...
04:11:54 <monando> Of*
04:12:20 <ReinH> monando: ?
04:12:42 <ReinH> I'm not sure what you're referring to.
04:14:30 <monando> The fusion emulator previously described
04:16:16 <ReinH> "I want to parse Haskell programs in Haskell so I can perform optimizations on the AST and then generate or run the new program" would have made sense to me.
04:16:25 <monando> It wasn't actually a question... But it's in new territory for me so maybe there are some things its obvious i should look into, or something like that
04:16:57 <ReinH> What you actually talked about was having a function (a->a->a) -> (a->a->a) -> Bool to detect isomorphisms
04:17:05 <ReinH> and then something f a -> f a
04:17:15 <ReinH> when what you apparently actually meant was just matching identifiers
04:17:19 <ReinH> which is entirely different
04:17:33 <ReinH> so I thought you were talking about doing something reflective at runtime
04:17:41 <ReinH> since that's when you'd need such a function
04:17:51 <ReinH> and such a function is impossible
04:18:00 <ReinH> because Haskell functions are opaque and incomparable.
04:18:03 <monando> Yes exactly, I want to emulate the use of rewrite rules in implementing fusion, specifically on an adaptation of fold/build, but decomposes on (.)
04:18:28 <no-n> what are ponies made of
04:18:31 <ReinH> Yes, but the key point here is that you wanted to do it on a Haskell AST, not from within a running program via reflection
04:18:42 <ReinH> and your subsequent comments only made sense if you were trying to do the latter
04:18:54 <monando> "Matching identifiers" that could be it you know
04:19:02 <ReinH> well yes, that's what you asked for later
04:19:24 <ReinH> once you have an AST, you can walk it looking for expressions of the right shape
04:19:37 <ReinH> e.g., (.) f g in AST form
04:19:43 <monando> Ooh
04:19:51 <ReinH> and if f . g = id is known to you somehow
04:19:54 <ReinH> you can replace it with id
04:20:02 <monando> It is
04:20:05 <monando> I can
04:20:08 <monando> I will
04:20:09 <ReinH> Right
04:20:47 <monando> But build works in a funny way
04:20:52 <monando> I want to do that
04:20:59 <ReinH> This doesn't seem to be related to fusion.
04:21:18 <ReinH> It's relatively simple term rewriting
04:21:43 <monando> I got fusion from pipes maybe I'm using it wrong
04:22:36 <monando> They factor out stream.unStream using a rewrite rule
04:22:57 <monando> If I could do this by a pure Haskell mechanism I would be success
04:23:07 <monando> Have succeeded*
04:23:28 <ReinH> fusion generally applies to stream-like things (vectors, lists, pipes), although I suppose you could call what you're doing fusion if you want.
04:23:50 <ReinH> But I"m not sure what you mean by "I want to do that".
04:23:55 <monando> I'm sure it's not fusion but actually just simple term rewriting which I desire
04:24:16 <monando> I got confused because it's used by pipes to do fusion
04:24:18 <ReinH> I guess it means that you want something other than replacing (.) f g with id, but I don't know what that other thing would be.
04:25:03 <monando> That's the thing I'm after anyway
04:25:29 <monando> I guess I have to load the function definition into an AST as you describe
04:25:49 <monando> I was using list and (.) For simplicity
04:26:09 <monando> But I guess there is a general way with more complex point free operator
04:26:26 <monando> Does that make sense?
04:27:54 <ReinH> I'm not sure what more complex point free operator means
04:28:07 <ReinH> I mean, I understand all of those words.
04:28:10 <monando> For composing functions of more than one argument... Despite their non existence
04:28:33 <ReinH> Ah, right
04:28:52 <ReinH> That would make things more complex, but not different in kind
04:29:38 <monando> As long as I have functions taking and returning only one argument I just compose then with (.) And then they are linear so I use a list. But if I was using funky owl things to compose functions I guess it would be a Tree
04:29:41 <ReinH> You're still finding a subtree by shape and replacing it
04:30:14 <ReinH> :t (.).(.)
04:30:16 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:30:18 <monando> My mind implodes when I imagine these funky owls because I understand them little
04:31:15 <monando> But they lie at the forks of the branches of the tree, I get that much
04:31:31 <monando> I suppose that's enough
04:32:22 <ReinH> :t let f .: g = \x y -> f (g x y) in (.:)
04:32:24 <lambdabot> (t -> t1) -> (t2 -> t3 -> t) -> t2 -> t3 -> t1
04:32:32 <ReinH> Same thing
04:32:54 <ReinH> But not suitable for a folding function for functions in a list
04:32:56 <monando> Oh perfect
04:33:05 <monando> I think I used one once
04:33:19 <ReinH> I.e., compared with foldr (.) id
04:33:26 <Gurkenglas> (define it like (f .: g) x = f . g x so it looks like (f . g) x = f $ g x)
04:33:31 <monando> But suitable for some other foldable structure
04:33:54 <ReinH> Gurkenglas: not bad
04:35:03 <ReinH> I don't think there's any suitable structure aside from uninteresting ones like (,)
04:35:24 <monando> Free [[]]
04:35:37 <monando> It's an epic rose tree
04:35:45 <ReinH> I don't see how.
04:35:47 <monando> Should be used everywhere
04:36:00 <ReinH> Have you done it or are you guessing?
04:36:51 <monando> A zipper is like ([],[]) so [[]] is just multiple pointing things (splits)
04:37:33 <ReinH> I remain unconvinced
04:37:36 <monando> I was going to extend my duplicate over Free ([],[]) to Free [[]]
04:38:20 <monando> Because I imagine it would be totally badass
04:38:50 <ReinH> Ok, you lost me
04:39:13 <ReinH> We're talking about free monads now?
04:39:30 <ReinH> Is this still related to (.:)?
04:41:20 <monando> Yes, elaborate dots require more arguments, indicating branches. A rose tree; Free [] can be made much more awesome by also giving it arbitrarily many position registering splits, hopefully for parallel navigation
04:43:18 <monando> (.:) is just requiring a single branch, so (,) suffices, but for longer dot chains trading more arguments, [] would be required
04:43:50 <monando> No harm in then using a zipper, and better yet a zipper with multiple pointing splits
04:44:15 <monando> s/trading/taking
04:45:30 <maerwald> s/$/\//
04:45:44 <monando> (Integer paramatrised navigation e.g. left :: Int -> [[a]] -> [[a]]
04:46:43 <monando> s/f.(1/f)/id
04:47:49 <ReinH> I don't see how you can use a rose tree for this, but feel free to try.
04:49:54 <ReinH> How do you chain multiple (.:) together?
04:49:55 <monando> Ok, thanks for listening, i know my approach is rash and unorthodox, ill conceived and poorly communicated, so your patience is greatly appreciated
04:50:09 <ReinH> yw
04:50:59 <monando> ReinH, functions are like magnets, you just let them snap together any way they like...
04:51:12 <ReinH> That's just a hand wave
04:52:43 <ReinH> The types of the arguments don't line up.
04:54:03 <monando> But you could use (.) And (.:) to construct functions with the correct number of arguments
04:54:18 <ReinH> How?
04:54:31 <monando> By supplying arguments to them
04:54:42 <ReinH> Show me an example
04:54:58 <monando> :t (.:)
04:55:00 <lambdabot> error:
04:55:00 <lambdabot>     • Variable not in scope: .:
04:55:00 <lambdabot>     • Perhaps you meant one of these:
04:55:38 <monando> Ok I'll talk to lambdabot. Brb
04:57:05 <koz_> Could someone help me understand the exact meaning of 'Phi' here? http://comonad.com/reader/2008/kan-extensions-ii/
04:57:21 <koz_> Like, it's described as an isomorphism, but I'm unsure what the notation means.
05:04:19 <ReinH> It's homset notation.
05:05:13 <ReinH> In Haskell, we might say (f x -> y) -> (x -> g y)
05:05:40 <koz_> ReinH: Oh, ok. That I get.
05:06:00 <ReinH> - and = are two arbitrary objects
05:06:53 <ReinH> Hom_C(X,Y) is the set of all morphisms from X to Y in C
05:06:57 <monando> > id ((.).(.)) ((id ((.).(.)) (const id)) (+) 1 2) (+) 3 4
05:07:03 <lambdabot>  7
05:07:07 <monando> Woot
05:07:17 <hpc> the next paragraph says phi = leftAdjunct also
05:08:37 <hpc> (also my terminal font's φ looks disorientingly different from that image)
05:08:41 <ReinH> Yes, in Haskell we like to define categorical concepts by their homsets.
05:09:31 <ReinH> This is largely because Hask is closed so they are internal homs carried by (->)
05:09:41 <ReinH> That is, they are just functions.
05:10:14 <hpc> is it called homset for homomorphism?
05:11:24 <ReinH> Maybe?
05:11:42 <ReinH> Also I should say that the homset is not required to be a set
05:12:01 <hpc> so it's like GHC's STG
05:12:08 <hpc> it's got a spine and tags, and isn't even really a G-machine
05:12:30 <ReinH> Heh I was wondering where you were going
05:14:28 <ReinH> koz_: you should watch the catsters videos on adjunctions
05:15:58 <koz_> ReinH: I may well do so.
05:18:41 <ReinH> koz_: they use - and = because it's obvious from context which objects they are and it's easier than writing "for all X in C, Y in D, Hom_D(FX,Y) -> Hom_C(X,GY)"
05:19:08 <ReinH> - can only be in C and = can only be in D
05:19:36 <ReinH> Because of F and G
05:20:07 <ReinH> You get used to it after a while
05:30:39 <Tuplanolla> Just like this: http://srfi.schemers.org/srfi-26/srfi-26.html
05:44:29 <mabs> hi guys, how do i specify in cabal the option to link with a static library?
06:37:44 * hackagebot OpenGLRaw 3.2.3.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-3.2.3.0 (SvenPanne)
06:37:46 * hackagebot fold-debounce 0.2.0.3 - Fold multiple events that happen in a given period of time.  https://hackage.haskell.org/package/fold-debounce-0.2.0.3 (debugito)
06:37:48 * hackagebot fold-debounce-conduit 0.1.0.3 - Regulate input traffic from conduit Source with Control.FoldDebounce  https://hackage.haskell.org/package/fold-debounce-conduit-0.1.0.3 (debugito)
06:37:50 * hackagebot stopwatch 0.1.0.3 - A simple stopwatch utility  https://hackage.haskell.org/package/stopwatch-0.1.0.3 (debugito)
06:37:52 * hackagebot wikicfp-scraper 0.1.0.4 - Scrape WikiCFP web site  https://hackage.haskell.org/package/wikicfp-scraper-0.1.0.4 (debugito)
06:42:54 * hackagebot boring-window-switcher 0.1.0.1 - A boring window switcher.  https://hackage.haskell.org/package/boring-window-switcher-0.1.0.1 (debugito)
06:42:56 * hackagebot wild-bind 0.1.0.2 - Dynamic key binding framework  https://hackage.haskell.org/package/wild-bind-0.1.0.2 (debugito)
06:42:58 * hackagebot wild-bind-x11 0.1.0.2 - X11-specific implementation for WildBind  https://hackage.haskell.org/package/wild-bind-x11-0.1.0.2 (debugito)
06:45:14 <zshlyg> Why is f = foldr (+) 0 ambigous but f xs = foldr (+) 0 xs not?
06:47:21 <Tuplanolla> That doesn't make sense, zshlyg. Both have the type `(Foldable f, Num a) => f a -> a`.
06:49:31 <Tuplanolla> There would be a small difference if you had something else in place of `foldr` though.
06:50:37 <zshlyg> Tuplanolla: ghci complains when I :load the former version.
06:50:59 <hpc> the monomorphism restriction perhaps
06:51:11 <Tuplanolla> Please `{-# LANGUAGE NoMonomorphismRestriction #-}`, zshlyg.
06:52:47 <lyxia> @where monomorphismrestriction
06:52:47 <lambdabot> https://wiki.haskell.org/Monomorphism_restriction
06:53:31 <Tuplanolla> I wouldn't mind having a LanguageExtensionAbbreviations extension.
06:54:29 <zshlyg> Thanks! :)
07:37:46 * hackagebot libvirt-hs 0.2.1 - FFI bindings to libvirt virtualization API (http://libvirt.org)  https://hackage.haskell.org/package/libvirt-hs-0.2.1 (IlyaPortnov)
07:53:07 <karanlearnshaske> hi - i am trying to create custom type like either - http://lpaste.net/250571
07:53:13 <karanlearnshaske> but getting error
07:56:15 <lyxia> karanlearnshaske: what is it
07:57:35 <lyxia> "ambiguous type variable"? try main = putStrLn $ show (Lefty "test" :: Myresult String ())
07:58:55 <lyxia> The problem is that it cannot deduce the full type of Lefty "test". It can be Myresult String b for any b, and the Show instance of Myresult requires Show for both a and b.
08:04:39 <Malkrith> Which of these ways is "preferred"?
08:04:39 <Malkrith> putStrLn(show(1 + 1))
08:04:39 <Malkrith> putStrLn $ show(1 + 1)
08:04:39 <Malkrith> putStrLn $ show $ 1 + 1
08:04:39 <Malkrith> putStrLn . show $ 1 + 1
08:05:45 <jmcarthur> Man, got kicked off for asking a real question.
08:05:58 <jmcarthur> Just did it badly.
08:07:42 <cocreature> they typed to fast :)
08:10:28 <MarcelineVQ> lines were too similar
08:10:31 <MarcelineVQ> That's rough.
08:10:49 <MarcelineVQ> Allthough, if you gotta ask about things similar enough to spam filter you, it may not matter
08:16:56 <ongy> it's a style question. But I guess they should have used lpaste
08:20:24 <{AS}> I would use print $ 1 + 1
08:29:22 <jmcarthur> I would use print 2
08:29:40 <jmcarthur> Or I guess print (2 :: Int)
08:37:41 <joncol_> Could someone help me clear some ReaderT confusion? I've just switched from a Reader monad to a ReaderT based on IO. (Because I want to print progress during time consuming calculation.) But I don't get how I should fix this last error. I created a gist at https://gist.github.com/joncol/7d2e46277fc6b3cf3d4e4b6a45524ccd . I guess I'm missing some lift or liftIO somewhere?
08:37:47 * hackagebot knead 0.2.0.1 - Repa array processing using LLVM JIT  https://hackage.haskell.org/package/knead-0.2.0.1 (HenningThielemann)
08:37:49 * hackagebot knead-arithmetic 0.0.0.1 - Linear algebra and interpolation using LLVM JIT  https://hackage.haskell.org/package/knead-arithmetic-0.0.0.1 (HenningThielemann)
08:37:52 * hackagebot text-metrics 0.2.0 - Calculate various string metrics efficiently  https://hackage.haskell.org/package/text-metrics-0.2.0 (mrkkrp)
08:38:44 <cocreature> joncol_: could you include the error in that gist?
08:39:26 <joncol_> cocreature: done
08:39:44 <cocreature> joncol_: what’s the type of colorPixel?
08:40:00 <joncol_> colorToPixel :: Color -> PixelRGB8
08:40:14 <joncol_> PixelRGB8 is JuicyPixel's type
08:40:23 <cocreature> so there is your problem, you are applying that to something of type IO Color
08:41:32 <joncol_> Yes, but how do I solve this?
08:43:08 <cocreature> joncol_: are you sure you don’t want Int -> Int -> RayTracer Px in your type signature?
08:43:41 <cocreature> the other possiblity would be RayTracer (Int -> Int -> IO Px)
08:43:47 <cocreature> your current type doesn’t work
08:44:15 <joncol_> cocreature: The problem is that JuicyPixel's "generateImage" function expects its first param to be Int -> Int -> Px.
08:45:30 <cocreature> joncol_: what kind of IO are primaryRay and trace performing?
08:46:08 <joncol_> They will perform none, I will have all my IO in renderPixel
08:46:20 <cocreature> then don’t give them a type involing IO
08:46:44 <cocreature> there are several solutions here
08:46:54 <joncol_> Yes, I will restrict that later. I can use something like MonadReader m => m Ray ?
08:47:04 <cocreature> you can either make them completely polymorphic in the monad and just require MonadReader
08:47:17 <cocreature> joncol_: you can’t do that later. this is what’s causing your error
08:47:37 <cocreature> alternatively if you never need to run them in a large monadic context just give them type "Reader Ray"
08:47:50 <cocreature> or you could also go for ReaderT Scene m and leave the m polymorphic
08:47:56 <cocreature> you can then instantiate them at Identity
08:48:01 <cocreature> but also run them in RayTracer
08:48:22 <joncol_> OK, I'll look into this, thx
08:50:07 <cocreature> joncol_: generally you should try to be as restrictive in your type signatures as possible. your function doesn’t do IO? forbid it by the type signature!
08:51:20 <joncol_> So what do you recommend? primaryRay :: MonadReader m => Int -> Int -> m Ray. Is that valid signature?
08:51:54 <cocreature> MonadReader Scene m => Int -> Int -> m Ray
08:52:02 <cocreature> the "Scene" argument is important
08:52:16 <joncol_> Ah! Of course.
08:52:49 <joncol_> Should I need FlexibleContexts for this?
08:52:54 <c_wraith> yes
08:53:00 <c_wraith> FlexibleContexts is harmless
08:53:04 <joncol_> OK :)
08:53:16 <cocreature> FlexibleContexts is one of those extensions you just enable without thinking when ghc tells you to :)
08:53:30 <joncol_> OK, I will from now on :)
08:54:01 <glguy> Even better than FlexibleInstances and using MonadReader Scene would be a typeclass specific to your problem
08:54:16 <c_wraith> I'm really surprised the Haskell 2010 effort didn't make FlexibleInstances and FlexibleContexts a default part of the language.
08:54:29 <c_wraith> Since the 12 years since Haskell98 showed they are easy and harmless
08:55:38 <c_wraith> wow, Haskell2010 was 6 years ago.  It still feels like it was recent!
08:56:47 <joncol_> OK, I changed everything to MonadReader Scene m => and now I get the slightly different error message Couldn't match expected type ‘Color’ with actual type ‘m0 Color’
08:57:02 <c_wraith> are you throwing a return in someplace?
08:57:23 <c_wraith> that error really sounds like there's an extra return someplace.
08:57:40 <c_wraith> ...  Or that you have a real design issue.  One of the two.
08:57:57 <cocreature> or a missing runIdentity or something like that :)
08:58:52 <c_wraith> If it was concrete, it wouldn't say m0 Color.
08:59:01 <cocreature> fair enough
08:59:13 <joncol_> Well, hmm. It's here: https://gist.github.com/joncol/7d2e46277fc6b3cf3d4e4b6a45524ccd
08:59:55 <cocreature> try runReader instead of runReaderT
09:00:07 <joncol_> That works!
09:00:13 <joncol_> hmm.
09:00:19 <joncol_> Why
09:00:19 <cocreature> that’s basically runIdentity . runReaderT
09:00:26 <c_wraith> hah, so it is
09:00:28 <cocreature> :t runReaderT
09:00:30 <lambdabot> forall k r (m :: k -> *) (a :: k). ReaderT r m a -> r -> m a
09:00:35 <cocreature> :t runIdentity
09:00:37 <lambdabot> Identity a -> a
09:00:52 <c_wraith> :t runReader -- for completeness
09:00:54 <lambdabot> Reader r a -> r -> a
09:00:57 <cocreature> :t \a b -> runIdentity $ runReaderT a b
09:00:58 <lambdabot> ReaderT r Identity a -> r -> a
09:01:29 <cocreature> Reader r a is just a type synonym for ReaderT r Identity a
09:01:35 <c_wraith> joncol_: The difference is that runReader returns a plain value.  runReaderT returns a value in some monadic context.  You wanted the plain value.
09:02:02 <joncol_> OK, I'm not fully understanding what the MonadReader x m => part implies.
09:02:16 <joncol_> I'll have to read up on that typeclass.
09:04:25 <c_wraith> joncol_: that class just means (ask :: m x) exists
09:05:05 <c_wraith> joncol_: in fact, that operation is what is defined in the class.  (There is a bit more in the class, but that's the important bit for now)
09:05:38 <joncol_> So when I passed my full stack to the functions taking MonadReader => stuff I essentially stripped away IO and replaced it with Identity?
09:06:02 <c_wraith> well, you took out IO and replaced it with "make the choice later, but you know I'm not using IO"
09:07:24 <c_wraith> And the reason you know it isn't using IO is because there's nothing in the type signature that says you will use IO.
09:07:47 <c_wraith> That's the nice thing about having typed IO.  If the IO type doesn't appear in the type signature, you know you're not using IO.
09:08:25 <joncol_> OK, and can I "switch" to *any* other monad? Or is Identity special?
09:08:36 <c_wraith> You can switch to any other monad.
09:08:41 <joncol_> Except IO?
09:08:48 <c_wraith> You can even switch to IO
09:09:05 <c_wraith> You just know that the operations in your functions won't use it
09:09:28 <c_wraith> It's like...
09:09:37 <c_wraith> :t liftM2
09:09:38 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:09:49 <c_wraith> You can use that operation with any monad, including IO
09:10:09 <c_wraith> But you know that what it does won't use operations specific to the monad you've chosen.
09:10:13 <c_wraith> -does
09:10:17 <c_wraith> Like..
09:10:30 <c_wraith> > liftM2 (+) (Just 1) (Just 2)
09:10:33 <lambdabot>  Just 3
09:10:45 <c_wraith> > liftM2 (+) [1,2,3] [4,5]
09:10:47 <lambdabot>  [5,6,6,7,7,8]
09:11:12 <c_wraith> What it does varies depending on the monad chosen - but it never does anything other than use (>>=)
09:11:27 <c_wraith> .. and return
09:11:54 <c_wraith> So you know it can't check what monad it's running in and say "Oh, it's IO?  Let me read a file"
09:13:13 <lyxia> I want to write a client for WeeChat relay. Is there an IRC frontend that I can somehow reuse, or am I better off writing a UI from scratch?
09:13:16 <joncol_> OK, when you "it can't" are you meaning the functions having MonadReader- restrictions?
09:14:28 <c_wraith> joncol_: Or just a Monad restriction..  I mean anything that specifies it's polymorphic in the type of monad it works with.  (MonadReader Scene m) is one way of saying that it's polymorphic
09:15:04 <joncol_> OK, thanks a lot for helping out.
09:15:13 <c_wraith> joncol_: I know, this sort of thing is tricky.  It's not what other programming languages give you.  Lots of new skills to pick up. :)
09:15:39 <Cale> It's worth noting that you can do this with data structures that hold operations too, not just type classes.
09:16:44 <joncol_> c_wraith: Yes, lot's to learn :).
09:16:53 <Cale> e.g. you can have something like  data Operations m = MkOps { frobnicate :: Text -> m Integer, ... }
09:17:25 <Cale> and then write functions with types like  (Monad m) => Operations m -> ... -> m Something
09:17:53 <Cale> and you get a sort of guarantee from the type system that only the operations you provide are those which get used
09:18:12 <Cale> (which is useful even if you only ever intend to use m = IO)
09:19:26 <joncol_> Cale, OK nice. So that's also used to guarantee that there is no IO or other stuff happening? Only >>= and returns?
09:20:01 <joncol_> (On the monad at least)
09:33:45 <YellowOnion> What options do I have for RAII like control of resources?
09:34:53 <Cale> YellowOnion: I'm... not even sure what that means in the context of Haskell.
09:35:30 <Cale> YellowOnion: But perhaps consider that you can have operations which have types like:
09:35:39 <Cale> (Resource -> IO a) -> IO a
09:36:17 <Cale> which allocate some resource, pass the allocated and constructed thing to the function, perform the action obtained, and deallocate before returning the result of the intermediate action
09:36:23 <jmcarthur> :t bracket
09:36:25 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:36:48 <jmcarthur> -- bracket create destroy f
09:36:52 <Cale> right, bracket is a good example of how to do that at the same time as handling exceptions, which is probably a good idea in most cases.
09:37:32 <YellowOnion> Ahh yeah there's also resourceT that follows the same pattern.
09:38:35 <YellowOnion> Cale, that type looks like with
09:38:36 <jmcarthur> ResourceT is meant to be sort of a more flexible bracket. More dynamic sets of open resources, but the cost is that destructors might not be guaranteed to be called as promptly.
09:38:38 <Cale> and then if you have a whole lot of such things which you need to nest, the Cont monad can do that for you.
09:39:11 <jmcarthur> I would not quite describe ResourceT is RAII-like. bracket is a bit closer.
09:39:15 <Cale> :t runCont . sequence . map cont
09:39:16 <lambdabot> [(a -> r) -> r] -> ([a] -> r) -> r
09:39:19 <jmcarthur> Neither are exactly RAII, though.
09:39:57 <Cale> ^^ take a list of such functions which will allocate some resource, and turn them into a function that allocates a list of resources
09:40:27 <Cale> heh, of course we could generalise that to other datastructures too, couldn't we?
09:40:30 <Cale> :t runCont . sequence . fmap cont
09:40:32 <lambdabot> Traversable t => t ((a -> r) -> r) -> (t a -> r) -> r
09:41:26 <YellowOnion> jmcarthur, Yeah, it doesn't look exactly like RAII.
09:41:50 <jmcarthur> :t \f -> runCont . traverse (cont . f)
09:41:52 <lambdabot> Traversable t => (a -> (b -> r) -> r) -> t a -> (t b -> r) -> r
09:43:18 <Cale> So one way of thinking about the Cont monad is that it's an attack on the kind of nesting that happens when you allocate many resources in this style
09:43:25 <jmcarthur> YellowOnion: There's also finalizers. Further from RAII. Almost no control over when the destructors are called. Maximally dynamic. Can be a little hard to get right in Haskell due to compiler optimizations.
09:44:03 <jmcarthur> I'm only talking about all these alternatives because I don't quite know what you are looking for by asking about RAII-like control.
09:44:14 <YellowOnion> jmcarthur, I need full control over when they are destructed
09:44:49 <jmcarthur> There's also monadic regions, which is pretty hard to learn, but has a pretty good tradeoff on the dynamism-promptness spectrum.
09:44:55 <Cale> :t Foreign.Marshal.Alloc.withArray
09:44:57 <lambdabot> error:
09:44:57 <lambdabot>     Not in scope: ‘Foreign.Marshal.Alloc.withArray’
09:44:58 <lambdabot>     No module named ‘Foreign.Marshal.Alloc’ is imported.
09:45:02 <jmcarthur> I usually think monadic regions is overkill, though.
09:45:23 <YellowOnion> jmcarthur, I'm testing the waters with Vulkan.
09:45:38 <jmcarthur> Honestly I would just use bracket with vulkan.
09:45:39 <Cale> :t Foreign.Marshal.Array.allocaArray
09:45:41 <lambdabot> Foreign.Storable.Storable a => Int -> (GHC.Ptr.Ptr a -> IO b) -> IO b
09:45:56 <jmcarthur> At least I think I would.
09:46:09 <Cale> ^^ all the FFI stuff gives you resource allocators in this style
09:46:13 <jmcarthur> I toyed with vulkan a little, but lost interest before I finished all the boilerplate. :)
09:46:35 <Cale> Maybe see what Ed might've already done
09:47:09 <Cale> I imagine that he'll eventually get to it if nobody else does. He's been doing VR stuff in C++ lately, but who knows. :)
09:47:35 <YellowOnion> Ed?
09:47:38 <jmcarthur> Kmett
09:47:47 <YellowOnion> Ahh
09:48:58 <mauke> the talking horse
09:50:30 <ongy> is the horse amazing?
09:51:07 <monochrom> the amazing spider-horseman
09:51:13 <jmcarthur> ContT with callCC does get really close offering something like RAII. You can just define all your functions with callCC so that you have an explicit return, and all the resources you had allocated in that block are freed by hidden uses of bracket.
09:51:17 <jmcarthur> I think it's overkill.
09:53:54 <nshepperd1> You can attach finalizers to foreignptr that do get called as soon as it is GCd, as long as the finalizer is a C function
09:54:00 <jmcarthur> Maybe someday we will be able to encode something interesting using https://ghc.haskell.org/trac/ghc/wiki/LinearTypes
09:54:19 <YellowOnion> jmcarthur, yeah maybe I'll just stick with something simple for now.
09:54:55 <jmcarthur> nshepperd1: vulkan doesn't like some resources being finalized in the wrong order.
09:55:40 <YellowOnion> I don't think you want a GC controlling your GPU at all.
09:55:45 <jmcarthur> agreed
09:56:44 <jmcarthur> "at all" might be too strong, but certainly it should be limited to very minor things.
09:57:04 <nshepperd1> I wish we could support something like c++'s shared_ptr<raii>
09:57:37 <jmcarthur> nshepperd1: That's reference counting? I always forget the various C++ pointer types.
09:57:47 <nshepperd1> Yeah
09:58:29 <YellowOnion> I've actually considered how to control the GC a little more tightly. GC pauses suck in video games.
09:58:30 <nshepperd1> Or unique_ptr which allows only linear use
10:00:17 <YellowOnion> I still get a little annoyed at Kerbal Space Program's pauses.
10:01:14 <nshepperd1> There must be a fully concurrent gc algorithm out there somewhere
10:01:29 <jmcarthur> YellowOnion: I would like a primitive to control over which generations are GCed when forcing a GC manually in GHC. This would allow to do something like allocate a large enough gen1 to support an entire frame without a major gc at all followed by any manual gc to copy multi-frame objects into gen2 without actually traversing gen2 on every frame.
10:01:42 <Tuplanolla> How about isolated heaps?
10:03:01 <nshepperd1> jmcarthur: performMinorGC?
10:03:14 <jmcarthur> An incremental GC would also be nice. It's certainly nice in OCaml, which has an incremental mark and sweep gc. GC pauses are not that bad except during compactions of multi gigabyte heaps, which are not very common.
10:03:35 <jmcarthur> nshepperd1: That just GCs the nursery, right?
10:03:49 <Cale> nshepperd: There is. GHC actually implemented one on a branch at some point, but it didn't perform as well as stop-the-world concurrent GC.
10:04:02 <Cale> bbiab, getting off my train
10:04:31 <jmcarthur> nshepperd1: I would still want the nursery to behave as normal. I'm talking about control over how many major generations to collection.
10:04:34 <jmcarthur> *to collect
10:05:31 <jmcarthur> I'd still want potentially many minor GCs during a frame since Haskell programs typically have a lot of very short-lived allocations.
10:06:42 <YellowOnion> jmcarthur, do you need to actually clean them up multiple times per frame?
10:07:07 <jmcarthur> The nursery? Oh yeah. Haskell is much more convenient to write when you don't have to think about every little allocation.
10:07:19 <jmcarthur> And minor GCs are super fast anyway.
10:08:12 <YellowOnion> jmcarthur, I mean whats the difference between one big GC pause per frame and a bunch of small ones?
10:08:20 <nshepperd1> Hmm i wonder how much "performed worse"
10:08:27 <jmcarthur> They usually only affect throughput, not latency. But of course each one might promote to gen1, which makes the next major collection take longer. That's why I'd want gen1 to be large so I can delay the major collection to the end of a frame when I expect much of that data to be dead.
10:09:01 <nshepperd1> Sometimes better latency would be worth less average throughput
10:10:06 <jmcarthur> YellowOnion: The whole point of a multigenerational GC is to get rid of short-lived allocations earlier. Without the minor GCs, I'd need a much larger gen1.
10:10:26 <jmcarthur> YellowOnion: Or I guess at least a much larger nursery...
10:10:55 <jmcarthur> YellowOnion: I think it would be a lot harder to figure out what the bound on the nursery should be, too.
10:13:37 <jmcarthur> YellowOnion: There is also some benefit to the nursery being more cache friendly, even if there must be more minor collections.
10:15:01 <YellowOnion> jmcarthur, oh yes that makes a lot of sense.
10:15:36 <YellowOnion> though there's always some free CPU cycles after the GPU submit.
10:15:56 <jmcarthur> That might be where I do the major gc.
10:17:08 <jmcarthur> And then start working on the next frame (before the previous one is even done rendering, probably).
10:17:21 <YellowOnion> true
10:18:11 <YellowOnion> I seriously don't mind as long as its not performing a 400ms GC every 2-3s
10:18:49 <jmcarthur> If it's taking 400ms, something is going *horribly* wrong.
10:20:40 <jmcarthur> A nice thing about the controlled single gen1 gc for each frame is that you can have some confidence about how much data is actually being retained from frame to frame and maybe even keep the memory footprint constant enough to not have to run gen2 until the level (or whatever) is done.
10:21:29 <jmcarthur> That is, it eliminates some kinds of false promotions to gen2.
10:23:56 <YellowOnion> jmcarthur, most games don't keep the entire level in memory these days.
10:24:25 <jmcarthur> YellowOnion: By "level" I meant only the currently loaded portion of the world.
10:24:29 <osager> what is the operator for concating strings? <> ?
10:24:45 <jmcarthur> osager: You can use <> or ++
10:24:57 <jmcarthur> osager: <> works on other textual data types. It's more polymorphic.
10:25:04 <osager> do i need to import something to use <> ?
10:25:08 <osager> i forgot which package
10:25:15 <jmcarthur> osager: ++ might avoid some type ambiguity problems sometimes.
10:25:21 <jmcarthur> osager: Data.Monoid for <>
10:25:26 <osager> oh great
10:25:27 <osager> thanks
10:26:11 <jmcarthur> YellowOnion: If there is a data pipeline for incrementally loaded parts of the world, the GC pipeline might need to be a bit more complicated.
10:27:47 <jmcarthur> YellowOnion: Probably I would just preallocate some mutable stuff to be put into gen2 and modify it. Unboxed data would always go directly to gen2. Boxed data might be harder to optimize; I don't know how effective eager promotion is.
10:30:27 <YellowOnion> jmcarthur, just avoid unboxed, its going to kill your prefetching, and you will want your level to be in the GB's of size.
10:30:56 <jmcarthur> YellowOnion: Why would it kill my prefetching?
10:31:15 <YellowOnion> jmcarthur, sorry I mean avoid boxed...
10:31:43 <jmcarthur> Some data structures need pointers anyway.
10:34:09 <jmcarthur> Really long lived data that can be unboxed should probably just be pinned anyway so it doesn't ever get copied.
10:34:11 <YellowOnion> jmcarthur, I saw a trick recenlty, that used a boxed type, that was backed by an unboxed type, and they sorted their access via the ptrs
10:34:48 <buttbutter> Is there a function that takes a list of lists [s1,s2,s3] and some string d and returns s1 ++ d ++ s2 ++ d ++ s3?
10:34:52 <jmcarthur> Even linked lists can behave pretty well with a copy collector like GHC's since the copying can sequentialize them.
10:35:11 <jmcarthur> :t intercalate
10:35:14 <lambdabot> [a] -> [[a]] -> [a]
10:35:31 <jmcarthur> > intercalate "foo" ["bar", "baz", "wibble"]
10:35:33 <buttbutter> jmcarthur: Thanks :)
10:35:35 <lambdabot>  "barfoobazfoowibble"
10:35:50 <dmwit_> ?. hoogle type \[s1,s2,s3] d -> s1 ++ d ++ s2 ++ d ++ s3
10:35:55 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
10:35:55 <lambdabot> GHC.OldList intercalate :: [a] -> [[a]] -> [a]
10:35:55 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
10:36:25 <Tuplanolla> Does a variation exist that changes the last separator?
10:36:38 <jmcarthur> Changes it how? (And I doubt it.)
10:37:11 <Tuplanolla> Like `intercalateHarder ", " " and " ["one", "two", "three", "four"]`.
10:37:42 <jmcarthur> for that case I'd probably just tack an "and " onto the last element before using intercalate
10:37:50 * hackagebot reactive-midyim 0.2 - Process MIDI events via reactive-banana  https://hackage.haskell.org/package/reactive-midyim-0.2 (HenningThielemann)
10:37:52 * hackagebot reactive-balsa 0.2 - Programmatically edit MIDI events via ALSA and reactive-banana  https://hackage.haskell.org/package/reactive-balsa-0.2 (HenningThielemann)
10:37:54 * hackagebot reactive-jack 0.2 - Process MIDI events via reactive-banana and JACK  https://hackage.haskell.org/package/reactive-jack-0.2 (HenningThielemann)
10:38:43 <YellowOnion> ohhh that library looks interesting.
10:39:55 <YellowOnion> jmcarthur, what did you use for vulkan window mangement?
10:42:16 <Zekka> Tuplanolla: It wouldn't be too hard to write one, but I don't know if anyone has written one
10:42:35 <Tuplanolla> I was just wondering whether someone had bothered, Zekka.
10:42:51 <Tuplanolla> A library for some other language had it.
10:43:02 <Zekka> I could swear I saw a definition like that in a library that wanted to provide something specific to English text generation, but I don't know if it was in Haskell
10:43:21 <Tuplanolla> We might have seen the same thing.
10:43:57 <jmcarthur> YellowOnion: Like I said before, I quit before I got through the basic boilerplate, so I hadn't bothered to make a windowing decision yet.
10:44:04 <jmcarthur> YellowOnion: For OpenGL I quite like sdl2.
10:44:21 <jmcarthur> YellowOnion: I don't know if that is usable for vulkan (yet?).
10:45:03 <YellowOnion> jmcarthur, SDL2 supplies the drawing surface you can send to vulkan.
10:45:48 <jmcarthur> YellowOnion: I mean the Haskell package sdl2 specifically.
10:46:25 <jmcarthur> YellowOnion: I think it offers some quite low level access if you want it, so probably it can be made to work.
10:49:34 <ertesx> are there vulkan bindings?
10:49:39 <jmcarthur> yes
10:49:45 <ertes> oh, yeah, indeed
10:49:59 <YellowOnion> jmcarthur, looks like raw SDL2 doesn't do anything special for vulkan.
10:50:39 <jmcarthur> Yeah, you just need to get to some primitives.
10:52:24 <YellowOnion> sadly that means I have to do OS specific coding (I think).
10:53:23 <YellowOnion> https://twitter.com/nvining/status/700387135581335552
10:54:00 <osager> how to concat a IsString type with a normal string ?
10:54:25 <lyxia> osager: IsString doesn't provide such functionality
10:54:43 <osager> the Request type from Network.HTTP.Simple is IsString
10:54:59 <osager> and when i contruct the url i need to modify It
10:55:14 <osager> what is the best practice for such tasks
10:56:22 <YellowOnion> osager, use a combinator library.
10:56:44 <geekosaur> no, it means it takes any string-like type. something else is determining what that is. if you want to modify it, you either have fixed the IsString to some known type or you can get away with constants and OverloadedStrings. "I don't know" is meaningless because you cannot concatenate utf8 with octet and get something meaningful unless there is a protocol for doing so that you are adhering to
10:57:04 <geekosaur> "just do it" means "just produce complete garbage"
10:57:36 <osager> thanks
10:57:37 <geekosaur> people don't want this to be true, they all want to believe  string is a string and it'll all work out. this is not a safe way to think.
10:57:55 <osager> I jsut found parseRequest :: MonadThrow m => String -> m Request
11:00:06 <osager> I want to excute a function multiple times, each time with a different argument(incrementing number) and i want to know how many times im it's been called
11:00:24 <osager> and sequence_ or mapM_ doesn't give me this
11:00:34 <siwica> Is there a way to see within ghci how Members of certain type classes implement the according required functions? E.g. I want to see how IO implements (>>=).
11:00:43 <osager> what do peole usually do ?
11:02:08 <osager> siwica, i think you have to check the source code in a web browser
11:02:28 <jmcarthur> osager: Do you mean you want to apply the function to each argument of a list and also know the index of the element in the list?
11:02:39 <jmcarthur> osager: Or do you mean you just want to apply the function to a number?
11:02:41 <YellowOnion> osager, look at foldM
11:03:07 <siwica```> osager: Ok. I thought that maybe this could be done from within ghci.
11:03:09 <jmcarthur> I see some relevance of foldM, but I somehow doubt it's what osager really wants.
11:04:08 <osager> E.g.: myFun "url=" [1..10]
11:04:22 <YellowOnion> siwica```, definitely can't see how IO is implemented since its system specific code.
11:04:35 <jmcarthur> osager: What is the type of myFun intended to be?
11:04:36 <osager> jmcarthur:  i need to concat the "url=" with each of [1..10]
11:04:40 <jmcarthur> ah
11:04:51 <jmcarthur> osager: I don't understand why map is insufficient then.
11:05:16 <osager> my func jsut download and save the file as 1.json, 2.json...
11:05:17 <jmcarthur> > map (\i -> "url=" ++ show i) [1..10]
11:05:20 <lambdabot>  ["url=1","url=2","url=3","url=4","url=5","url=6","url=7","url=8","url=9","ur...
11:05:51 <osager> jmcarthur: i see
11:06:31 <jmcarthur> ah, maybe you want something like   mapM_ (\i -> myFunc ("url=" ++ show i)) [1..10]  ?
11:06:54 <osager> got it thanks 
11:08:50 <YellowOnion> ahh right, I was thinking foldM (\i action -> somethingIO action >> return (i+1)) 0 [actions]
11:37:51 * hackagebot reactive-midyim 0.2.1 - Process MIDI events via reactive-banana  https://hackage.haskell.org/package/reactive-midyim-0.2.1 (HenningThielemann)
11:37:53 * hackagebot reactive-balsa 0.2.0.1 - Programmatically edit MIDI events via ALSA and reactive-banana  https://hackage.haskell.org/package/reactive-balsa-0.2.0.1 (HenningThielemann)
11:37:55 <siwica> When using intero-info it doesn't show information about functions that are imported in the file but aren't in scope for intero.
11:37:55 * hackagebot reactive-jack 0.2.0.1 - Process MIDI events via reactive-banana and JACK  https://hackage.haskell.org/package/reactive-jack-0.2.0.1 (HenningThielemann)
11:38:46 <siwica> How do I make intero loading them in scope automatically? (Emacs intero-mode)
12:21:33 <ongy>  you need a passport, so I can decline you
12:21:42 <ongy> whoops
12:21:46 <ongy> wrong chat -.-
12:22:25 <ongy> just for context: I'm watching a papers please stream, don't try that to get not declined :)
12:37:52 * hackagebot DataIndex 0.1.0 - A package for adding index column to data files  https://hackage.haskell.org/package/DataIndex-0.1.0 (steven_yhw)
12:37:54 * hackagebot DataIndex 0.1.1 - A package for adding index column to data files  https://hackage.haskell.org/package/DataIndex-0.1.1 (steven_yhw)
12:41:01 <anks> hi, i've got a little problem with flycheck crying about ambiguous interface for Prelude, my program needs base and fay-base. Do you know maybe how to solve it or work around ?
12:45:36 <lordcirth> anks, if asking for help, you should generally pastebin the real error message.
12:46:13 <anks> yea, but this is trivial message
12:46:16 <anks> Ambiguous interface for ‘Prelude’:
12:46:16 <anks>    it was found in multiple packages: fay-base-0.20.0.1 base-4.9.0.0 (haskell-stack-ghc)
12:46:16 <anks>  
12:52:05 <lyxia> anks: you can use PackageImports. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#package-qualified-imports
12:52:26 <lyxia> fay-base uses it for instance.
12:54:08 <anks> neeaat
12:54:13 <anks> lyxia: thanks :)
12:54:28 <lyxia> you're welcome!
12:59:16 <neochronomo> Without using guards, is this a perfectly acceptable haskell script? Is there a better way than using if/then/else?
12:59:18 <neochronomo> sign x = if x==0 then 0 else if x>0 then 1 else -1
13:00:04 <dmwit> :t signum
13:00:06 <lambdabot> Num a => a -> a
13:00:21 <dmwit> > map signum [-2 .. 2]
13:00:25 <lambdabot>  [-1,-1,0,1,1]
13:01:02 <neochronomo> dmwit: also without using Prelude's existing signum function
13:01:29 <dmwit> Your way is fine.
13:02:02 <dmwit> > let sign 0 = 0; sign x = x `div` abs x in map sign [-2 .. 2] -- another way, though I suppose then you're going to complain about using Prelude's abs function
13:02:04 <lambdabot>  [-1,-1,0,1,1]
13:02:34 <neochronomo> dmwit: I'm only just learning, and from what I know if haskell it seems weird to use if/then/else like in imperative languages, so I was wondering if I could do better
13:03:19 <grantwu>  you aren't using it like imperative languages
13:03:29 <grantwu> Haskell's if then else is more akin to the ternary operator
13:03:29 <Rembane_> neochronomo: You could also pattern match on 0.
13:04:33 <Rembane_> neochronomo: sign 0 = 0; sign x | x > 0 = 1; | otherwise = -1
13:04:38 <Rembane_> neochronomo: And guards!
13:04:46 <kyren> Hey, I'm pretty noobish still, and I think I've gotten over my head with functional dependencies and undecidable instances, and I feel like there's probably a better way to do what I want to do
13:04:57 <Rembane_> kyren: What do you want to do?
13:05:28 <kyren> well, I'm experimenting with making a bunch of classes like Vec2F Vec2D, like Linear, but monomorphic and unpacked
13:06:20 <dmwit> neochronomo: It is uncommon but not weird to use if/then/else. Pattern-matching subsumes it and works for many more types than `Bool`.
13:06:22 <kyren> and this is still super experimental, and please be gentle here I have a typeclass that has no laws and is not well thought out I'm just experimenting, but I'm trying to make it so that even though I'm going to have a whole boatload of monomorphic types, I still want polymorphic functions so I don't have to write, say, 10 Num instances
13:06:56 <neochronomo> dmwit: I'll have to look up how pattern matching works
13:07:36 <kyren> Feedback is welcome here, I'm still.. like I guess you could be generous and call me intermediate at best here
13:07:41 <kyren> http://sprunge.us/YAcE?haskell
13:07:54 <kyren> this doesn't work, and is wrong, I get lots of overlapping num instances for like.. Int
13:09:18 <kyren> I like Linear it's fine, it's great, but it's overkill for game development mostly which is harmless of course, but more importantly it's always polymorphic and thus unpacked, and unfortunately I have a lot of vecs I'm trying to like, upload to OpenGL and it DOES have an effect, unfortunately a large effect
13:09:38 <dmwit> Yes, don't write `instance .... => Class a`. Although it looks constrained, it's not.
13:09:41 <kyren> if having monomorphic vector types is just.. real crap, I'm willing to live with that actually, I'm partially doing this to kind of just get an idea
13:10:17 <dmwit> To avoid having to do search during instance resolution, the strategy is to first commit to any instance that matches, then demand that all the constraints needed for that instance also be matched.
13:10:45 <dmwit> So `instance ... => Class a` creates an instance of `Class` for *every* type -- then causes errors if that type doesn't validate the `...` part.
13:11:00 <kyren> Right, you know I've done this before, and realized this before
13:11:16 <kyren> one day it'll stick, thank you, so.. okay what would be the strategy here
13:11:28 <kyren> do I just need to, like, not care so much and write a bunch of Num instances
13:11:31 <dmwit> `instance Num Vec2I` plus `instance Num Vec2F`
13:12:11 <kyren> okay, that's not so bad then
13:12:16 <dmwit> You can write a bunch of default values to make them shorter, e.g. `vecNumPlus = vlift (+); vecNumMinus = vlift (-)` etc. then `instance Num Vec2I where (+) = vecNumPlus`.
13:12:27 <kyren> right right
13:12:58 <dmwit> These definitions are pretty short, though, so if you really only have two instances I might skip that until it actually becomes useful.
13:13:16 <kyren> yeah it's not like lift (binop) is a lot to type
13:14:06 <kyren> okay, thank you in any case
13:14:17 <dmwit> Another choice would be `newtype VecNum a = VecNum a; instance (Vec a b, Num b) => Num (VecNum a) where ...`, but then you will have to pay the newtype wrapping/unwrapping syntax cost every time you want to use a `Num` operation.
13:14:23 <dmwit> But you'd only have to write one instance.
13:15:06 <dmwit> You might want the `b` variable to appear (as a phantom) in the `newtype`; not sure how good GHC is with fundeps in that sense.
13:15:50 <kyren> I would rather just write a lot of instances by hand than do newtype wrapping, it's not so bad really
13:16:26 <kyren> it's unfortuante, but makes complete sense, that ghc cannot unbox polymorphic types, it seems very good at inlining and monomorphizing polymorphic *functions* though
13:17:06 <dmwit> This isn't related to unboxing, I don't think.
13:17:28 <dmwit> oh
13:17:32 <dmwit> I understand what you're saying.
13:17:48 <dmwit> Yes, it would be hard to unbox polymorphic types. Think about it operationally and I think you'll see why, too.
13:17:51 <kyren> no it's not, it's just the reason I'm even doing this, instead of just using Linear
13:17:56 * dmwit nods
13:18:02 <kyren> no it makes sense, I'm just a gross old c++ programmer
13:18:13 <dmwit> Ah, yeah, the template solution.
13:18:17 <kyren> so I'm used to gross old c++ yeah that
13:18:18 <dmwit> You can probably do taht with TH.
13:18:46 <dmwit> At the cost of having to write one invocation of the appropriate TH function for each type you want to expand the "template" at.
13:19:32 <kyren> yeah, if it becomes extremely onerous I will do that, but it's really not very hard to just copy paste some stuff, and it's really ONLY necessary for like.. low dimension vectors for video games
13:23:19 <Cale> I've sometimes wondered about whether it would be possible, with annotations, to specialise data types. It would be really nice to e.g. use FingerTree and have the values of the monoid that's in use get unpacked neatly into the tree structure.
13:24:23 <Cale> FingerTree is super cool, but all the best applications of it just end up being separate packages with specialised code, since that's so much more efficient.
13:37:54 * hackagebot shentong 0.3.1 - A Haskell implementation of the Shen programming language  https://hackage.haskell.org/package/shentong-0.3.1 (mjt128)
13:37:56 * hackagebot parsec-free 3.1.11.1 - Parsec API encoded as a deeply-embedded DSL, for debugging and analysis  https://hackage.haskell.org/package/parsec-free-3.1.11.1 (JohnWiegley)
13:42:03 <vapid> https://gist.githubusercontent.com/anonymous/7d0258a9675b126d8d7687f4859661b3/raw/578b737cb0391f3973211680a082e176f53452ba/gistfile1.txt
13:48:42 <nshepperd> hmm, if ghc can effectively inline/monomorphize polymorphic functions but can't unbox polymorphic datatypes, does that mean you could potentially get some mileage out of church encoding the datatype there?
14:08:10 <dmj`> what's the best way to deal with conflicting exports
14:08:26 <dmj`> i.e. if A re-exports B and C, but B and C have the same function name defined
14:09:37 <lyxia> just hide one
14:10:59 <dmj`> that works
14:19:00 <grantwu> Does the first parameter of scanl need to be associative?
14:19:57 <benzrf> grantwu: no, i dont think so
14:20:27 <grantwu> Okay, cool
14:21:06 <grantwu> This isn't what I need /right now/ but is there a version that does require associativity that executes in parallel?
14:21:32 <grantwu> aka using the technique from here: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch39.html
14:23:21 <hsgumby> do {-# INLINE pragmas work across modules?
14:24:35 <jmcarthur> hsgumby: yes
14:25:40 <hsgumby> great! thanks
14:27:31 <Tehnix> Hmm, is there a oneliner for something like `gen <- liftIO newStdGen; let test = f gen`? Ala `let test = (lifeIO newStdGen) >>= f`
14:27:39 <Tehnix> (which obviously doesn't work)
14:28:23 <ocramz> hullo
14:28:26 <jmcarthur> grantwu: The most similar to your link is going to be something like http://hackage.haskell.org/package/accelerate-0.15.1.0/docs/Data-Array-Accelerate.html#g:32
14:29:05 <jmcarthur> Tehnix: f <$> liftIO newStdGen    or    liftIO (f <$> newStdGen)
14:29:14 <jmcarthur> Tehnix: (<$>) is another name for fmap
14:29:24 <grantwu> jmcarthur: That's *exactly* what I meant, thanks!
14:29:46 <jmcarthur> grantwu: Note that to use that function requires some buy-in, since it's a DSL for using your GPU.
14:30:38 <grantwu> ah
14:30:52 <grantwu> would be nice to have it go to OpenCL, since they have drivers for CPU too but
14:30:57 <grantwu> not what I'm working on right now
14:30:57 <jmcarthur> grantwu: That's actually what I meant about being similar to your link.
14:31:11 <grantwu> oh
14:31:35 <jmcarthur> grantwu: I am not aware of a native Haskell version of this, but I doubt it would be terrible difficult to find/reinvent
14:31:35 <Athas> grantwu: they are working on an LLVM backend, which presumably will also let them target CPUs.
14:31:45 <grantwu> jmcarthur: I think there is one?
14:32:00 <grantwu> Data.Array.Accelerate.Interpreter: simple interpreter in Haskell as a reference implementation defining the semantics of the Accelerate language
14:32:24 <jmcarthur> That might not be fast or even parallel.
14:32:42 <Athas> Strangely, Repa does not seem to have a scan.
14:32:42 <jmcarthur> Since it's a model implementation they may have omitted actual parallelism.
14:32:51 <jmcarthur> I was surprised to see that Repa doesn't have this, too.
14:33:41 <mmaruseacph2> the call for contributions to the next HCAR is finally sent :) (https://mail.haskell.org/pipermail/haskell-cafe/2016-October/125204.html)
14:33:48 <Athas> I always thought that Accelerate was the faster-but-restricted version of Repa, but it actually seems to have it beat on features now, too.
14:34:20 <JagaJaga> How to call `<*>` in applicative?
14:34:41 <JagaJaga> I mean in a voice conversation :)
14:35:13 <jmcarthur> JagaJaga: I pronounce it "app" because there is a Monad version of this function called `ap`.
14:35:57 <jmcarthur> :t (<*>)
14:35:59 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:35:59 <jmcarthur> :t ap
14:36:02 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:37:55 * hackagebot fclabels 2.0.3.1 - First class accessor labels implemented as lenses.  https://hackage.haskell.org/package/fclabels-2.0.3.1 (AdamBergmark)
14:37:57 * hackagebot logging-effect 1.1.0 - A mtl-style monad transformer for general purpose & compositional logging  https://hackage.haskell.org/package/logging-effect-1.1.0 (OliverCharles)
14:37:59 * hackagebot servant 0.9.0.1 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.9.0.1 (jkarni)
14:38:01 * hackagebot servant-server 0.9.0.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.9.0.1 (jkarni)
14:38:03 * hackagebot servant-client 0.9.0.1 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.9.0.1 (jkarni)
14:39:04 <kyren> it's not that I'm complaining, but sometimes my code scales linearly across cores, and I DON'T KNOW HOW
14:40:10 <kyren> is it possible that code in Data.Vector.Unboxed is parallel?
14:41:00 <kyren> er, sorry Data.Vector.Storable
14:43:05 * hackagebot servant-docs 0.9.0.1 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.9.0.1 (jkarni)
14:43:07 * hackagebot servant-foreign 0.9.0.1 - Helpers for generating clients for servant APIs in any programming language  https://hackage.haskell.org/package/servant-foreign-0.9.0.1 (jkarni)
14:48:28 <ph88> hey guys, i'm trying to get quickcheck shrink going and i get this message     No instance for (GHC.Generics.Generic Identifier)  arising from a use of ‘genericShrink’    does that mean i have to derive Generic for my data type ?
14:49:42 <jmcarthur> kyren: Maybe you have a major GC bottleneck and the parallel GC is working well for you?
14:50:31 <kyren> maybe, what's the easiest way to check if that's the case, I didn't think it was the case but maybe it is?
14:50:45 <jmcarthur> kyren: See what your GC usage is with +RTS -s
14:51:07 <kyren> okay I will do that, I've only been using -p so far, this is all very new for me
14:52:38 <ph88> this tutorial https://wiki.haskell.org/GHC.Generics  says i can derive Generic when i enable the language extension   however i get this message from ghci: Not in scope: type constructor or class ‘Generic’
14:53:37 <Koterpillar> ph88: well, did you import it? Section 1.3 in your link
14:54:57 <ph88> noes :|
14:56:15 <ph88> well that didn't solve the problem with genericShrink ..
14:56:25 <ph88> i thought i had to derive a Generic but i guess that was not it ^^
14:56:30 <kyren> okay, IF profiling is enabled it does not scale beyond a single core
14:57:05 <Koterpillar> ph88: show the code and the error
14:58:07 <ph88> Koterpillar, https://paste.fedoraproject.org/447383/47605025/
14:58:32 <kyren> maybe I'm not invoking stack correctly, maybe stack build --profile gets rid of -threaded specified in the cabal file
14:59:05 <ph88> "If all this leaves you bewildered, you might try shrink = genericShrink to begin with, after deriving Generic for your type." https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Arbitrary.html
14:59:06 <Koterpillar> ph88: you have to have Generic for LogicalNameList and everything else inside it
14:59:14 <ph88> ah maybe that's it
14:59:19 <ph88> "everything else inside it"
14:59:25 <ph88> wait a moment i try again
15:01:34 <ph88> can i do derive on "type"  ?
15:01:45 <lyxia> no
15:02:00 <kyren> okay, yes it is almost entirely due to gc, darn
15:02:33 <kyren> or, maybe it's not.. I wish I knew how to read this output
15:02:57 <Koterpillar> ph88: just derive it for the right side
15:03:16 <Koterpillar> ph88: i.e. type String = [Char] -- you have to rely on the instances for Char and []
15:07:02 <ph88> https://paste.fedoraproject.org/447395/14760507/
15:07:25 <ph88> only thing i haven't derived the generic of is Text i think ^^
15:08:07 <ph88> the error message is not really specific here
15:08:53 <ph88> as i understand the error message it can't derive Generic from Terminal
15:10:23 <cheater> hello
15:10:29 <ph88> hai
15:11:24 <cheater> can dynamic typing help make programs that take unreliable input correct where they would be failing if they were statically typed?
15:12:19 <Koterpillar> cheater: the question is so generic the answer is almost certainly yes
15:12:46 <Koterpillar> I can probably devise a completely improbable example for you, but do you really want that?
15:13:00 <cheater> why would you think i want that?
15:13:01 <ph88> it can be that a dynamic typed program accepts the unreliable input in cases where the statically typed program rejects it, however if it then does the correct thing entirely dependent on specific circumstances/details
15:13:22 <Koterpillar> cheater: I don't, so you don't get the  example :)
15:13:26 <cheater> i'm looking for useful ideas
15:13:38 <Tuplanolla> If you simply remove the types from a statically typed program, the answer is most definitely no, cheater.
15:13:38 <Koterpillar> this was not one of them
15:14:06 <ph88> statically typed is a pretty good idea imo
15:14:30 <Koterpillar> well, let's take a problem: input a number and output the same number
15:14:39 <cheater> i just thought that, as much as static typing and inference is great for code that depends on data the programmer has bundled with it, maybe dynamic typing can do better in a space that's very close to input
15:14:53 <lyxia> ph88: it's saying there is no Arbitrary instance for Terminal
15:15:11 <lyxia> It derived Generic just fine
15:15:13 <kyren> I'm having a lot of trouble reading the output of the gc profiler, what is the way to determine the % of program time spent on gc
15:15:33 <Koterpillar> cheater: if your algorithm works on a certain data structure, it is not close to input and something has to bridge the gap
15:15:35 <ph88> cheater, i think statically typed helps correctly .. so if dynamic typing can do better then what is it actually doing better ?
15:15:45 <cheater> so for example, say the programmer does this: do { x <- getLine; let y = read x :: Int; print $ x + 4; }
15:15:59 <cheater> this is overspecified, because many other numbers can be added, other than Int
15:16:48 <Koterpillar> "overspecified" is a different problem from "statically typed"
15:16:53 <cheater> now if this were typed dynamically, x could e.g. be read as an int, or float, or complex number
15:17:05 <Koterpillar> not really
15:17:06 <lordcirth> cheater, 'read' is for importing data of known types
15:17:25 <lordcirth> cheater, if you are reading unknown input, you should handle that yourself.
15:17:29 <cheater> lordcirth: it's just a simple example. i'm not going to use parsec in a one liner
15:17:30 <Tuplanolla> What's the problem, kyren? Run with `+RTS -sstderr` and look for `%GC     time       4.2%  (6.9% elapsed)`.
15:17:44 <ph88> ah i see lyxia i think in these cases the genericShrink function is not going a good job since there shouldn't be an Arbitrary instance of Terminal
15:17:49 <kyren> it's not printing that actually, that's what I saw in the docs but I figured it might be because I'm using the threaded runtime?
15:17:58 <lordcirth> cheater, allowing types to be decided on the fly introduces many possibilities for bugs.
15:18:11 <cheater> sure
15:18:13 <Tuplanolla> Huh. What does it print then, kyren?
15:18:29 <Koterpillar> cheater: the question is, do you want it to process complex numbers?
15:18:32 <Koterpillar> or strings
15:18:32 <cheater> but here we have a false positive: we have a bug where the program can't work with a float.
15:18:34 <Koterpillar> or pointers
15:18:43 <cheater> Koterpillar: why not? the program would still make sense
15:18:45 <kyren> http://sprunge.us/PIiD
15:18:59 <cheater> strings? i don't think strings would make sense. or pointers.
15:19:02 <kyren> I'm experimenting with RTS flags ignore the top bit, I'm not sure if that's dumb or not
15:19:07 <MarcelineVQ> ph88: Aren't you trying to make an arbitrary instance for Terminal?
15:19:16 <Koterpillar> cheater: in some languages, "+" adds strings the same way it adds numbers
15:19:49 <cheater> right
15:20:03 <Tuplanolla> The productivity is a good measure of useful time by garbage collection time, kyren.
15:20:12 <Koterpillar> and in some languages, it can also perform pointer arithmetic
15:20:15 <cheater> see, that's a thing i didn't consider. i guess if i were writing in one of those languages, i wouldn't have considered it either.
15:20:24 <kyren> I thought so, but I can change the flags so that the program uses strictly more CPU but prints higher productivity *I think*
15:20:30 <Tuplanolla> I'm not sure why the percentage isn't there though.
15:20:47 <Koterpillar> cheater: ergo, dynamic typing can lead to unexpected behavior
15:21:36 <kyren> for example, right now this is a sample that loads 20k polys into a VBO and then renders it, it has to load 20k polys into a huge storable vector, which is reallocated, which I'm sure is where all the gc is coming from
15:21:51 <kyren> it uses 140% of one core, I will change some flags and show you more output, hold on
15:22:10 <ph88> MarcelineVQ, no ... i think since i use  shrink = genericShrink on one of the types that use Terminal that it "passes on" the shrinking to Terminal .. but terminal can not be shrinked .. but the minimum implementation of Arbitrary requires arbitrary and i don't want that on Terminal
15:23:00 <ph88> maybe i can put arbitrary = undefined or something
15:23:13 <Koterpillar> ph88: then you have to define it manually
15:24:33 <ph88> instance Arbitrary Terminal where  arbitrary = undefined  shrink = []
15:24:38 <ph88> i have this now
15:24:49 <Koterpillar> that's going to fail
15:25:09 <ph88> Couldn't match expected type ‘Terminal -> [Terminal]’                  with actual type ‘[t0]’    • In the expression: []
15:25:10 <ph88> yup
15:25:19 <Koterpillar> you don't have to define shrkin
15:25:21 <Koterpillar> shrink
15:25:21 <kyren> this uses like 250% of one core http://sprunge.us/BDfK
15:25:25 <ph88> oh ?
15:25:38 <kyren> maybe I don't understand the difference between % of total user vs % of total elapsed
15:25:38 <Koterpillar> and the simplest aribtrary is to always return a constant Terminal
15:25:50 <lpaste> lyxia pasted “Is this a bug” at http://lpaste.net/251249
15:25:51 <Tuplanolla> Task and spark monitoring seems to make the garbage collector metrics disappear, but you can accurately calculate them from the user and real time values above, kyren.
15:25:52 <ph88> but then i can't use genericShrink at the types that use Terminal right ?
15:26:05 <Koterpillar> ph88: well, you don't want to shrink a Terminal
15:26:19 <Koterpillar> I think the default implementation of shrink is []
15:26:32 <ph88> right
15:26:49 <ph88> yup that helped
15:27:29 <Tuplanolla> The different timers should be explained in `man time`, kyren.
15:27:34 <kyren> so what does each entry mean, init mut gc exit total
15:27:50 <kyren> okay, good then I understand it, I understand what user time is vs total time from like the unix time command
15:29:32 <Tuplanolla> They are, in order: runtime startup time, useful work time, garbage collection time, runtime teardown time.
15:29:50 <geekosaur> lyxia, I'd guess that was a bug inadvertently introduced by DuplicateRecordFields; it used to automatically qualify the name but it can't just do that any more. I *think* it should be an error, and that warning is just wrong
15:31:02 <kyren> aha, okay thank you that's extremely helpful, and MUT time wouldn't count something like, calling glBufferData or glDrawArrays right?
15:31:16 <kyren> it's not going to count going into some weird C library and then spending time there
15:31:52 <Tuplanolla> It should count foreign time too, but I don't remember.
15:32:15 <cheater> Koterpillar: interesting
15:33:12 <kyren> okay, actually then that still makes sense because it's locked to vsync, okay this is SUPER helpful thank you
15:33:32 <d4sh> So... I tried haskell in my first year cuz of a class. I'm now in my 3rd year and I have time. Why should I pick up haskell?
15:34:38 <geekosaur> lyxia, either that or someone slipped Trex in there when nobody was looking :)
15:37:57 * hackagebot tce-conf 1.2 - Very simple config file reading  https://hackage.haskell.org/package/tce-conf-1.2 (DinoMorelli)
15:37:59 * hackagebot fadno-xml 1.0.1 - XML/XSD combinators/schemas/codegen  https://hackage.haskell.org/package/fadno-xml-1.0.1 (spopejoy)
15:38:01 * hackagebot monoidal-containers 0.3.0.1 - Containers with monoidal accumulation  https://hackage.haskell.org/package/monoidal-containers-0.3.0.1 (BenGamari)
15:38:03 * hackagebot fadno-braids 0.0.4 - Braid representations in Haskell  https://hackage.haskell.org/package/fadno-braids-0.0.4 (spopejoy)
15:38:21 <YellowOnion> jmcarthur, Looking at this code agian, I'm thinking maybe its better to wait for GLFW or SDL2 to get vulkan support, so I don't have to bother with all the gritty details of WSI specifics.
15:39:20 <ggVGc> YellowOnion: or add vulcan support to GLFW!
15:42:46 <YellowOnion> ggVGc, considering that just requires an update to 3.2, it might be easy enough...
15:52:51 <hsgumby> is there an existing library function that does [a] -> (a -> b) -> [(a, b)], where the second elements in the tuple are the function applied to the first argument?
15:53:17 <hsgumby> or do I just have to map (\x -> (x, f x)) list?
15:53:25 <taktoa> I would have written zip xs (map f xs)
15:53:29 <Koterpillar> :t \f xs -> zip xs (map f xs)
15:53:31 <lambdabot> (a -> b) -> [a] -> [(a, b)]
15:55:13 <hsgumby> hmm that one is nicer if xs is lying around, but i need to make a let binding for it now (in the real example)  … probably I’ve already over-golfed it ;)
15:56:21 <Koterpillar> there might be something from Control.Arrow
15:56:43 <hsgumby> ah
15:57:55 <Koterpillar> :t \f -> map (id &&& f)
15:57:57 <lambdabot> (a -> c') -> [a] -> [(a, c')]
15:58:03 <Koterpillar> hsgumby: ^
15:59:01 <hsgumby> Koterpillar: beautiful, thanks :)
16:20:14 <ggVGc> what book would you recommend for introductory type theory?
16:22:16 <osa1> ggVGc: types and programming languages
16:22:17 <Tuplanolla> Types and Programming Languages or perhaps Software Foundations, ggVGc.
16:22:36 <osa1> oh you said type theory, no idea then
16:22:43 <osa1> I thought type systems
16:23:00 <Tuplanolla> They're a good start regardless, osa1.
16:23:07 <ggVGc> thanks
16:23:37 <osa1> OK. I have no clue about type theory although I've done fair amount of type systems stuff in the past (proving soundness in Coq etc.)
16:26:44 <Tuplanolla> If you want to approach the subject with "types only, no uses, Final Destination", try Homotopy Type Theory.
16:37:58 * hackagebot chitauri 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/chitauri-0.1.0.0 (marcusbuffett)
16:39:03 <BenzoKazooie> Is this linked to reddi5
16:39:14 <BenzoKazooie> U dam tourists
17:02:34 <Malkrith> I got klined for 9 hours for posting Haskell 
17:02:53 <lordcirth> Malkrith, define 'posting'?
17:02:53 <Malkrith> But... In that time I have been able to learn more about how Haskell works
17:03:04 <lordcirth> Did you paste a ton of lines to channel?
17:03:10 <Malkrith> So w/e
17:03:32 <Malkrith> I posted i think 4 likes with different ways to chain a function 
17:03:44 <Malkrith> And some global bot offed me 
17:03:51 <Malkrith> Lines*
17:03:56 <benzrf> lol
17:04:06 <lordcirth> Malkrith, interesting.  a kline is a bit much.
17:04:19 <lordcirth> Anyway, welcome back
17:04:32 <Malkrith> I will leave it as an honest mistake and pastebin Haskell from now on 
17:05:25 <lordcirth> That is usually the polite thing to do
17:05:39 <Malkrith> As I have come to realize 
17:06:04 <Malkrith> I hopped here from the JavaScript channel where you can eval code in the chat
17:06:13 <lordcirth> You can eval here, too.
17:06:14 <Malkrith> I will keep that behavior there 
17:06:26 <jle`> lambdabot can eval code in pm too :)
17:06:34 <lordcirth> however, you're only supposed to do it in channel if you're showing other ppl
17:06:37 <lordcirth> otherwise you pm
17:06:46 <zomg> ghci is your friend :)
17:06:46 <Malkrith> Of course 
17:06:47 <lordcirth> Or, you know, ghci
17:07:05 <lordcirth> Not much point to pm'ing if you have ghci, I guess
17:07:12 <zomg> (it's actually surprising how many people who eval JS on irc don't realize they could just, you know, paste it in their browser)
17:07:26 <jle`> maybe if you don't watn to install some libraries :o
17:07:28 <jle`> on ghci
17:07:41 <jle`> or maybe you're on irc from your phone heh
17:08:02 <Malkrith> I am almost always on from my phone 
17:08:11 <Malkrith> But that is beside the point 
17:11:08 <jle`> so much of my code now is littered with -- TODO: could probably be just unsafeCoerce?
17:11:58 <lordcirth> lol
17:12:17 <jle`> i wonder if i could just maybe write the actual implementation and just have unsafeCoerce as a rewrite rule heh
17:12:25 <lordcirth> Anyone know why this line:   UI_chooseClass :: Widget ()  throws an error?  I'll pastebin
17:12:50 <lordcirth> https://bpaste.net/show/dd1c3a02d467
17:13:11 <lordcirth> It seems a perfectly standard function type declaration to me.
17:13:12 <dfeuer> jle`, where/why are you hitting that?
17:13:15 <lordcirth> I am a noob tho
17:13:34 <Koterpillar> functions must not start with uppercase letters
17:13:43 <dfeuer> It's not about functions.
17:13:53 <dfeuer> Bindings in general can't start with uppercase letters.
17:13:55 <lordcirth> Koterpillar, really?  Well that might do it
17:14:10 <geekosaur> uppercase indicates a constructor name (or type or module name)
17:14:26 <Koterpillar> dfeuer: ah, right, that's a better term
17:14:29 <lordcirth> That is a perfectly reasonable rule, but a terrible error message
17:14:49 <geekosaur> ghc, sadly, has good type errors and lousy syntax errors
17:15:23 <lordcirth> This seems like a simple thing to fix (famous last words, I know)
17:15:58 <dfeuer> There's a proposal I very strongly support (maybe I initiated it?) to allow "smart constructors" to start with upper case letters, to separate the pattern matching and construction roles of pattern synonyms, but that's not implemented.
17:16:38 * slack1256 thinks this is the gold standard on introductory documentation http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
17:16:44 <dfeuer> geekosaur, I greatly dislike the way GHC formats its type errors as well, and some of their language as well. But the syntax errors are much, much worse.
17:18:10 <nitrix> varid   ->   (small {small | large | digit | ' })<reservedid>
17:18:14 <dfeuer> I think it's mostly that GHC prioritizes parsing speed over error message quality. 
17:18:30 <dfeuer> I imagine the complexity of the syntax (once you include the layout rules) can't help.
17:18:48 <nitrix> I'm not sure how it could be improved. GHC expects a variable name and it's not given a variable name; so it's complaining that the type signature format should be <variable> :: <type>
17:19:32 <Koterpillar> I think here it interpreted the construct as something obscure, but syntactically valid; and then that didn't pass the semantic analysis
17:19:49 <lordcirth> nitrix, right, but if it instead said "UI_sasd is not a variable name" even that would be a huge improvement
17:19:53 <dfeuer> nitrix, well, it could further explain that the problem is that what's before the :: is not a <variable>, and perhaps even to explain why.
17:20:13 <lordcirth> I spent 30min trying to figure that out.  fml
17:20:37 <kyren> I am making a large buffer of vertexes every frame, to pass to OpenGL, I know that I'm going to be making a fairly large buffer every frame, and I'd like to re-use the memory because it could be several MB and it creates a lot of gc pressure if I re-create it, what is the most sensible way to do this ugly C-ish thing in haskell, I was using Data.Vector.Storable
17:20:48 <lordcirth> Now back to figuring out the Brick library
17:21:28 <kyren> I've tried using reallocBytes directly, but it seems to be slow, but it's also possible I just did it wrong
17:21:45 <MarcelineVQ> kyren: http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable-Mutable.html ?
17:21:55 <kyren> like possibly poking individual vertexes is slower somehow than using vectors, I saw that MarcelineVQ 
17:22:05 <kyren> you don't seem to be able to resize vectors? which might be okay?
17:22:56 <geekosaur> nitrix, to be quite honest, any time something regurgitates a grammar description like <variable> :: <type> at me, I conclude it was not intended for anyone but compiler implementors to use
17:23:00 <geekosaur> that's just terrible
17:23:35 <kyren> I guess I'll just try that and use VSM.grow then
17:23:36 <geekosaur> the only time I want to see that is if I am debugging the parser
17:24:23 <Koterpillar> if I know what variables and types are, I would like to see that
17:24:32 <MarcelineVQ> kyren: have a look at slice too
17:25:13 <dfeuer> Anyone here familiar enough with BigNat to help me figure out the right way to read it in hexadecimal? I think using a general-purpose multi-base function is likely wasting time; all we really need to do is get the digits, pack them into a ByteArray, and then turn that into a BigNat. There are functions for doing it in GHC.Prim, but it's not entirely clear to me which order the bytes are supposed to be in to get the fastest conversion.
17:26:38 <dfeuer> geekosaur, well, it's better than if it just said "unexpected '::'", I supppose.
17:32:33 <geekosaur> dfeuer, don't make me go all T_PAAMAYIM_NEKUDOTAYIM on you >.>
17:34:24 <dfeuer> geekosaur, dots twice?
17:34:32 <dfeuer> Oh, is a colon "two periods"?
17:34:39 <geekosaur> yes. php's idea of a syntax error
17:35:02 <dfeuer> Does it actually give syntax errors in transliterated Hebrew?
17:35:11 <geekosaur> just that one token for some reason
17:35:12 <Koterpillar> it used to
17:35:15 <geekosaur> I don't even want to know
17:35:18 <dfeuer> o.O
17:35:49 <dfeuer> That's absolutely ridiculous. Whatever language you use, you should really spell it properly.
17:35:53 <geekosaur> (I know enough Hebrew to understand that; I'm afraid to ask what other programmers think when the computer starts "swearing at them" in Hebrew :)
17:36:26 <Koterpillar> that's not really different from "unexpected type class declaration" when you don't know what a type class is
17:36:39 <Koterpillar> expect it's easier to search for (!)
17:37:44 <grantwu> I mean what would you replace it with
17:38:07 <grantwu> I can't think of anything easier to comprehend
17:38:37 <Malkrith> Is there a... book people use to learn type theory or category theory?
17:44:34 <jle`> i wonder if i can expect (\f -> getConst . traverse (Const . f)) to be much worse than foldMap f in general
17:45:31 <jle`> the former never attempts to rebuild the structure, right?
17:46:02 <jle`> might as well benchmark on something with non-trivial structure like Data.Map
17:47:15 <jle`> or maybe i need to rewrite instance Functor (Const c) where fmap _ = unsafeCoerce
17:52:15 <jle`> dfeuer: mostly with dependently typed proofs
17:52:32 <jle`> structural witnesses for things that have different types but the same structure
18:02:29 <jle`> huh, the (\f -> getConst . traverse (Const . f)) implementation of foldMap actually is sometimes faster than Data.Map.Strict's actual foldMap
18:02:47 <jle`> i wonder if this is maybe a bug, if it's actually alwayas faster
18:03:01 <jle`> s/bug/problem with foldMap
18:18:28 <Gurkenglas> jle`, ala Const traverse won't work for Set
18:19:44 <Gurkenglas> *alaf Const traverse because of the extra f
18:20:10 <jle`> Gurkenglas: yeah, i'm talking about the case where the type is also Traversable
18:22:51 <lordcirth> I shall never again write code with single-character variable names, unless they are x,y,z, after reading Brick's sample code.
18:22:56 <Gurkenglas> I'd be surprised if lensy folding of a Map is slower than traversing with Const, since those are one and the same http://hackage.haskell.org/package/lens-4.15/docs/src/Control.Lens.Fold.html#foldMapOf
18:24:39 <jle`> oh neat
18:25:35 <jle`> well i'm consistently getting that 'sum' and traverse (Const . Sum) perform the same for Data.Map and Data.IntMap, and that both are faster than foldMap Sum
18:25:47 <jle`> what's up with the foldMap implementation of Data.Map then
18:26:33 <Gurkenglas> Lazy or Strict?
18:26:36 <jle`> Strict
18:27:12 <jle`> but that shouldn't matter because foldMap doesn't ever touch any keys, right?
18:28:38 <jle`> hm actually nvm it looks like their times are within their respective uncertainties of each other
18:29:09 <jle`> crisis averted
18:31:02 <jle`> i made my test maps so big that criterion only ran 8 iterations
18:35:54 <koz_> Argh, this is annoying. For some reason, Haskell can't get that all my instances of 'm' are the same...
18:38:26 <koz_> Here is my code, and I am completely lost as to why I'm getting those errors: http://lpaste.net/251461
18:40:31 <geekosaur> all those m-s are doing the opposite of what you intend, because you did not (a) enable ScopedTypeVariables (b) declare m with an explicit forall in the signature of runOne 
18:42:23 <koz_> geekosaur: OK, the first of those I can fix.
18:42:40 <geekosaur> you should be able to do both, and you must do both for it to work
18:43:03 <geekosaur> ScopedTypeVariables extension just enables the explicit forall to have that special meaning
18:43:31 <koz_> geekosaur: Sorry, what should my signature for 'runOne' look like, then?
18:43:33 <geekosaur> runOne :: forall m. MonadRandom m => Int -> m (Vector S.Formula)
18:43:39 <koz_> Oh...
18:44:01 <geekosaur> which tells it (when STV is enabled) that you intend m to scope over the function definition
18:44:33 <lordcirth> geekosaur, so that 'm' means  "MonadRandom m =>" in all places?
18:44:40 <koz_> Hold on. So without that 'forall m .', does the 'm' constraint apply ... to what? 
18:45:19 <geekosaur> without both STV and the forall, you have told it that there is some unspecified type in those type constraints. it can't know anything about it
18:45:26 <geekosaur> so it is guaranteed to not match
18:45:58 <koz_> geekosaur: Ah, OK. So with STV and the forall, I'm telling it 'every time I say m, I mean that specific MonadRandom I called out at the start'?
18:45:58 <geekosaur> but with ScopedTypeVariables and the forall, the m must match the one in the signature
18:46:02 <geekosaur> yes
18:46:10 <koz_> Oh, *now* I get it.
18:46:16 <koz_> What I don't get is why this isn't the default.
18:46:49 <geekosaur> because the Haskell standard says the scope of a type variable is the signature and nothing else. people do complain about this, but there are likely to be programs that expect this and reuse the type assuming it is distinct
18:47:10 <geekosaur> so nobody is quite willing to try to make it the default and quite possibly break existing programs
18:47:30 <MarcelineVQ> break all the things :o
18:47:32 <geekosaur> there's been a lot of discussion about this in the archives of the haskell-prime mailing list (and haskell-cafe for that matter)
18:47:50 <lordcirth> https://xkcd.com/1172/
18:51:26 <koz_> geekosaur: OK, I will now use ScopedTypeVariables all the time. :)
18:51:39 <koz_> (I already use NoImplicitPrelude and OverloadedStrings, so what's one more?)
18:51:45 <Malkrith> How does one join mailing lists
18:52:37 <koz_> Malkrith: Subscribe?
18:52:53 <Malkrith> I don't understand how to do this 
18:52:54 <koz_> You send an email to the server notifying it that you wanna subscribe.
18:53:03 <koz_> It depends on who's running the list.
18:54:06 <EvanR> *whose driving the bus!*
18:54:14 <EvanR> who's*
18:55:14 <MarcelineVQ> sunhine deh yah, time fi de busrida
19:24:10 <Axman6> Malkrith: Go to https://mail.haskell.org/mailman/listinfo, find the list you want to join, click it and fill in your details. don't use a password you care about, it will be sent to you in plaintext every month
19:25:14 <benzrf> literally candidates cannot shut the fuck up is this how its always been
19:25:18 <benzrf> fuck wrong channel
19:28:11 <Forlorn> what do we mean by types that can be enumerated? Such as types that implement Enum typeclass e.g Bool?
19:29:22 <benzrf> Forlorn: depends on the context - why do you ask?
19:32:08 <Forlorn> benzrf, my book describes instance Enum Bool – Enum for things that can be enumerated. When examining :info Bool.
19:32:16 <benzrf> oh, i see
19:33:33 <EvanR> enumerated here means you can assign numbers to each element
19:33:47 <benzrf> i guess i'd say that it means types with a canonical bijection between them and the integers
19:33:52 <Forlorn> what do you think they might have been referring to? Perhaps that each element is assigned an integer from 0 to 1
19:33:56 <EvanR> probably not a bijection
19:34:05 <benzrf> but that's not really what happens in practice
19:34:08 <benzrf> > succ 1.2
19:34:10 <lambdabot>  2.2
19:34:13 <EvanR> o_O
19:34:17 <EvanR> oh, thats not enum
19:34:29 <benzrf> yes it is
19:34:33 <benzrf> :t succ
19:34:33 <lordcirth> doesn't enumerable just mean there's a finite, known number of possible values?
19:34:34 <lambdabot> Enum a => a -> a
19:34:39 <EvanR> oh right
19:34:44 <lordcirth> Or not in this context?
19:34:46 <benzrf> lordcirth: i think that's a common meaning, but it's not what the Enum class means
19:34:57 <EvanR> lordcirth: you can also enumerate the naturals
19:35:00 <EvanR> and the rationals
19:35:24 * EvanR wtfs at the Double version of this...
19:35:32 <EvanR> > fromEnum 1.2
19:35:34 <lambdabot>  1
19:35:34 <Forlorn> Enum means that each member has a successor?
19:35:45 <EvanR> no, it means you can assigned numbers to each element
19:35:50 <EvanR> > fromEnum True
19:35:53 <lambdabot>  1
19:36:04 <EvanR> > toEnum 69 :: Char
19:36:06 <lambdabot>  'E'
19:36:14 <Forlorn> I see, thank you
19:36:15 <lordcirth> interesting
19:36:22 <EvanR> successor comes from going up 1 in the numbering
19:36:24 <lordcirth> > fromEnum '5.5'
19:36:27 <lambdabot>  <hint>:1:11: error: parse error on input ‘5.5’
19:36:31 <EvanR> now wtf does it mean for "5.5"
19:36:32 <lordcirth> > fromEnum 5.5
19:36:34 <lambdabot>  5
19:36:39 <lordcirth> wat
19:36:42 <Axman6> it's meens n-ish
19:36:58 <Axman6> > fromEnum (-1.5)
19:37:01 <lambdabot>  -1
19:37:14 <EvanR> > pred (-1.5)
19:37:17 <lambdabot>  -2.5
19:37:21 <Guest7776> quit
19:37:23 <Guest7776> exit
19:37:42 <johnw> permission denied
19:39:51 <koz_> What's a good pretty printing library?
19:40:10 <koz_> (I need to print expression trees which happen to be binary, if this helps any)
19:40:18 <johnw> pretty-show is not bad
19:40:47 <EvanR> i had success, after a few tries of other libs, with GenericPretty
19:41:44 <EvanR> ... not to be confused with generic-pretty, not sure what that is
19:42:29 <jle`> i usually use pretty-show
19:42:31 <koz_> johnw: So if I understand correctly - I just need to have an instance of PrettyVal for my type and then it works?
19:42:32 <jle`> for my pretty-printing needs
19:42:42 <jle`> it's pretty-neat
19:42:50 <koz_> jle`: That was pretty-clever of you.
19:43:26 <jle`> thank you
19:44:07 <pip16> whois
19:44:31 <jle`> koz_: oh wait actually i was wrong, i looked at my projects and my go-to is often pretty
19:44:34 <jle`> @hackage pretty
19:44:34 <lambdabot> http://hackage.haskell.org/package/pretty
19:44:51 <jle`> mostly because it was an SPJ project
19:45:01 <jle`> i am swayed by authority
19:45:06 <koz_> jle`: Lol.
19:45:21 <EvanR> respect my authorit-I
19:45:23 <koz_> In my case, I'm gonna be constructing the pretty representation using a catamorphism, so pretty-show seems OK.
19:45:46 <koz_> OK pretty-show, why u no build...
19:45:50 <koz_> Apparently needs happy.
19:46:03 <koz_> pretty does not appear to need happy.
19:47:51 * pip16
19:48:59 <Koterpillar> koz_: sad facts of life
19:49:35 * pip16
19:51:31 <koz_> Also, I just realized I clean forgot about a student meeting today.
19:51:32 <koz_> Well, fuck.
19:51:35 <koz_> Ahem, sorry.
19:55:59 <nitrix> You know it's the weekend when people cross the line with swears and teenager speak on the channel.
19:57:01 <EvanR> NO U
20:05:40 <MarcelineVQ> t̶h̶e̶ ̶l̶i̶n̶e̶
20:05:50 <Axman6> D:
20:06:20 <EvanR> what did you just do
20:06:27 <Axman6> take it back!
20:06:31 <johnw> nitrix: I could ban them for life
20:06:37 <MarcelineVQ> I apologize for nothing.
20:06:47 <koz_> nitrix: It's Monday for me. :(
20:07:26 <Koterpillar> it's Monday for most people by now
20:07:43 <MarcelineVQ> it's monday for everyone uncool
20:08:32 <EvanR> too bad you cant go west until its yesterday
20:09:31 <EvanR> in that respect i think the timezone system is disengenuous
20:10:25 <koz_> I know it's Monday, as I'm debugging Haskell space leaks.
20:11:34 <johnw> koz_: do you use Neil's technique?
20:11:56 <koz_> johnw: What is it?
20:12:11 <johnw> http://neilmitchell.blogspot.com/2015/09/detecting-space-leaks.html
20:12:19 <johnw> he has 3 posts in the series, if you need more examples
20:13:08 <koz_> johnw: That leak causes huge memory usage. Like, gigglebytes within about a second.
20:13:19 <johnw> which leak, yours?
20:13:23 <koz_> johnw: Yeah.
20:13:31 <johnw> ah, those are generally the easiest to find
20:13:57 <koz_> I'm currently trying to profile-detect it. Near as I can tell, nothing goes infinite here (at least, nothing I've noticed out of the possible suspects).
20:14:29 <johnw> residency leaks are much more subtle, than pending scrutinee leaks, than thunk explosion leaks
20:14:32 <johnw> show me the profile
20:15:03 <koz_> johnw: Sure, give me a second to run it.
20:15:11 <koz_> (well, run without causing my machine to thrash)
20:15:27 <Koterpillar> koz_: ulimit?
20:15:28 <johnw> insert an early exit into the code
20:15:35 <Koterpillar> seriously, ulimit
20:15:50 <koz_> Koterpillar: ulimit?
20:15:56 <Koterpillar> koz_: OS?
20:16:01 <johnw> ulimit might stop the process from writing out the profile
20:16:02 <koz_> Koterpillar: GNU/Linux.
20:16:38 <Koterpillar> ulimit -Sv 500000 # in your shell
20:16:57 <koz_> Koterpillar: What does this do exactly?
20:17:54 <johnw> the process will die when it exceeds the limit
20:17:56 <Koterpillar> wait, I'll find the right command
20:18:16 <Koterpillar> yes, as opposed to making the kernel kill it
20:18:38 <geekosaur> -S specifies soft limit, -v sets the address space limit in KB 
20:18:55 <johnw> Neil's techinque will also kill the process early
20:19:09 <Koterpillar> the only thing I can't find is if it applies to your shell, the processes it starts, or both
20:19:16 <geekosaur> both
20:19:25 <geekosaur> set in your shell, inherited by children
20:19:41 <Koterpillar> OK, so, that
20:20:16 <geekosaur> and soft limit means you can undo it (hard limits can only be raised by root)
20:20:36 <geekosaur> so "ulimit -Sv unlimited" will put you back to normal
20:21:17 <koz_> OK, so 'ulimit -Sv 500000' without root.
20:22:27 <geekosaur> in any case, since this kills the process, it's not ideal. I think you may actually want yourprog +RTS -M500000k (and build it with -rtsopts)
20:22:50 <koz_> geekosaur: OK, I'll do that. Can I pass +RTS -Mwhateverk to 'cabal run'?
20:23:11 <geekosaur> with --
20:23:26 <geekosaur> cabal run --RTS yourprog +RTS ...
20:23:37 <geekosaur> the first --RTS keeps cabal from reading the +RTS opt
20:23:59 <geekosaur> so it's passed on to your program, hopefully. but if it's using runhaskell then even more magic is needed
20:24:21 <geekosaur> ok, it builds and runs it, it should work that way
20:26:29 <koz_> geekosaur: Seems like it worked with the obvious syntax.
20:26:36 <koz_> OK, let me check out dat profile.
20:27:33 <lpaste> koz_ pasted “johnw: Profiling report” at http://lpaste.net/251559
20:28:00 <johnw> ok, can I see the code?
20:28:31 <koz_> johnw: The Main, or everything period?
20:28:50 <johnw> how many modules are there?
20:29:00 <koz_> Three, plus Main.
20:29:02 <jle`> i wonder why i can't lazy pattern match on gadt's
20:29:09 <johnw> let me try just Main
20:29:16 <koz_> johnw: Coming right up.
20:29:51 <lpaste> koz_ annotated “johnw: Profiling report” with “johnw: Main (annotation)” at http://lpaste.net/251559#a251562
20:30:09 <koz_> I apologise, in advance, for my likely-ghastly code.
20:30:18 <johnw> I'd like to see the module that is calling whileJust'
20:30:46 <koz_> johnw: Let me check which function this is. I don't think I ever use 'whileJust'' directly.
20:31:02 <geekosaur> jle`, presumably because it can't bring things into scope properly that way (because of how lazy pattern matching is implemented, so I suspect it would only try to bring it into scope when the pattern match actually happens which would be Weird)
20:31:57 <geekosaur> iirc it compiles to an irrefutable pattern match producing a lambda, and the lambda would bring it into scope
20:33:11 <lpaste> koz_ annotated “johnw: Profiling report” with “johnw: Code calling whileJust' (by way of unfoldM) (annotation)” at http://lpaste.net/251559#a251564
20:33:21 <johnw> rather, unfoldM
20:33:29 <lpaste> koz_ revised “johnw: Code calling whileJust' (by way of unfoldM) (annotation)”: “johnw: Code calling whileJust' (by way of unfoldM) (annotation)” at http://lpaste.net/251564
20:33:41 <koz_> johnw: Sorry, the second one is correct.
20:33:41 <johnw> aha
20:33:43 <koz_> (forgot to paste)
20:35:31 <johnw> so, unless I'm mistaken, randomIxes is just going to allocate an insane amount of memory until your machine kills it
20:35:43 <koz_> johnw: But I take only a small number from it.
20:35:53 <johnw> where's the limit?
20:36:03 <johnw> also, monads must compute their full answer
20:36:08 <koz_> I only use it in line 14. The limit is passed in as a parameter - in the code I'm using, it's *one*.
20:36:10 <koz_> Oh.
20:36:15 <koz_> I didn't know that...
20:36:29 <johnw> that's why streaming libraries and lazy I/O exist :)
20:36:52 <koz_> So I can't use unfoldM like that?
20:36:56 <johnw> oh, wait, getRandomR is just *a* value
20:37:14 <johnw> no, you can't use unfoldM like that
20:37:19 <johnw> there's no termination condition
20:37:28 <johnw> unless I'm not seeing something here
20:37:56 <koz_> So basically, I'm trying to generate an infinite list of random numbers... won't the fmap nub save me?
20:38:04 * hackagebot digit 0.2.9 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.2.9 (TonyMorris)
20:38:06 * hackagebot chitauri 0.1.0.1 - Helper for the Major System  https://hackage.haskell.org/package/chitauri-0.1.0.1 (marcusbuffett)
20:38:10 <johnw> why would it?
20:38:19 <johnw> nub is waiting for the infinite list to finish being generated
20:38:37 <koz_> johnw: My bad. I can fix that really easily, though.
20:38:37 <johnw> your unfoldM is just allocating new values as fast as it can
20:38:58 <koz_> Just parametrize getRandomIxes by the number of them I want.
20:39:05 <johnw> yep, that's one way
20:39:16 <koz_> johnw: It's the easiest way.
20:39:26 <koz_> Thanks for that - I guess I should be more careful with infinity.
20:39:48 <johnw> and when the profiling report says all your memory is coming from one function, examine the code that calls that function :)
20:40:19 <johnw> in this case it wasn't a leak; it was doing what you asked it to do :)
20:40:20 <koz_> johnw: Yeah, I figured as much. Will fix and retry - thank you!
20:40:32 <koz_> I've had this happen before, but that time it had been inadvertent.
20:46:27 <koz_> johnw: How would I ensure the generated indexes are unique? replicateM would work if I didn't need uniqueness.
20:48:18 <EvanR> to generate "random" unique numbers in some range... you can use the modular multiplication trick to permute the numbers in that range
20:48:30 <EvanR> which doesnt really involve RNGs
20:49:45 <koz_> EvanR: Well, suppose I *do* have an RNG available.
20:50:11 <EvanR> then it would be more complicated and less efficient to remember what you generated and check and retry
20:50:35 <koz_> EvanR: Could I just permute a list of indices randomly and take the first n?
20:51:05 <EvanR> how big of a list
20:51:26 <koz_> EvanR: It doesn't have to be a list per-se - I could easily use a Vector. About a thousand.
20:51:44 <EvanR> well thatd work, didnt know what range you were thinking of
20:52:01 <koz_> How would I permute a list of indices randomly, though?
20:52:06 <EvanR> with a shuffle
20:52:13 <koz_> Does Haskell have any?
20:52:17 <EvanR> yep
20:52:18 <koz_> (like, pre-made?)
20:52:25 <zeonic98> Hi all
20:52:31 <koz_> Hi zeonic98!
20:52:38 <zeonic98>  hi
20:52:48 <EvanR> shuffleM :: MonadRandom m => [a] -> m [a]
20:53:01 <amalloy> if you don't want the full permutation, you can do a partial/lazy fisher-yates to get N random unique indices
20:53:05 <lordcirth> koz_, are all the elements unique in content?
20:53:18 <lordcirth> which you are indexing
20:53:54 <koz_> lordcirth: Yes. EvanR: Where is that from?
20:54:04 <EvanR> random-shuffle
20:54:05 <lordcirth> koz_, then why not hash them?
20:54:24 <koz_> lordcirth: Because I may need to replace stuff at those indices later, and need to know what they are.
20:54:37 <lordcirth> koz_, without changing the index?
20:55:21 <jle`> koz_: it's easy to just zip with a list of random doubles
20:55:31 <koz_> jle`: Why doubles?
20:55:39 <jle`> no reason
20:55:42 <EvanR> haha
20:55:53 <EvanR> because doubles are great, they even have an Enum instance!
20:55:59 <benzrf> i mean
20:56:02 <benzrf> to be totally fairfieldt 
20:56:09 <benzrf> shit, why do i press tab :(
20:56:14 <jle`> > zip "hello" (randoms (mKStdGen 10) :: [Double])
20:56:16 <lambdabot>  error:
20:56:16 <lambdabot>      • Variable not in scope: mKStdGen :: Integer -> g0
20:56:16 <lambdabot>      • Perhaps you meant ‘mkStdGen’ (imported from System.Random)
20:56:21 <jle`> > zip "hello" (randoms (mkStdGen 10) :: [Double])
20:56:23 <lambdabot>  [('h',0.9411121095656491),('e',0.38022658385886665),('l',0.6880194990342998)...
20:56:31 <EvanR> so random
20:56:37 <jle`> > map fst . sortBy (comparing snd) $ zip "hello" (randoms (mkStdGen 10) :: [Double])
20:56:40 <lambdabot>  "oellh"
20:56:42 <lordcirth> why not Int?
20:56:48 <EvanR> why not zip with a list of random values of a random type?
20:57:11 <jle`> > map fst . sortBy (comparing snd) $ zip "hello world, how are you today" (randoms (mkStdGen 523) :: [Double])
20:57:11 <lordcirth> can you choose random types at runtime?
20:57:13 <lambdabot>  " ty,lwhodwaooroaeldlorye  h u "
20:57:15 * EvanR reaches into an urn of types
20:57:21 <jle`> yes
20:57:23 <EvanR> Maybe (Int, Bool)
20:57:42 <EvanR> lordcirth: Dynamic
20:57:46 <lordcirth> EvanR, that looks like a Maybe of Tuple (Int, Bool).  Is it not?
20:58:02 <EvanR> yes
20:58:24 <lordcirth> wouldn't Int `Either` Bool make more sense?
20:58:37 <EvanR> it was chosen randomly
20:59:19 <lordcirth> rand = 4
20:59:26 <lordcirth> IEEE standard random number.  Solved
20:59:42 <EvanR> pretty sure NaN was chosen randomly
20:59:53 <jle`> working with random types at runtime becomes a lot nicer with RankNTypes
21:00:21 <zeonic98> Hi all. Think I've landed in the wrong place. Wanted some hacking advice.
21:00:34 <EvanR> hasking advice?
21:00:44 <grantwu> This is #haskell, a channel about the Haskell programming language
21:01:36 <lordcirth> zeonic98, there is a bot, alis, which helps you find channels.
21:01:41 <zeonic98> Not how to steal my friends ex yahoo password lol
21:01:48 <lordcirth>  /query alis, say 'help'
21:02:16 <zeonic98> I've been through a few channels without success. 
21:03:17 <zeonic98> Could anyone point me in the direction of a channel with people that would be willing to help me extend my wifi range
21:03:26 <EvanR> thats a silly activity, please leave
21:03:31 <grantwu> wat
21:03:38 <lordcirth> zeonic98, ##hardware, maybe?
21:03:59 <zeonic98> Yes hard ware
21:04:07 <ezrios> what are the use cases for STM.TBQueue? why would I ever prefer a bounded to an unbounded queue?
21:04:18 <ezrios> is this to limit memory usage where I have more producers than consumers?
21:04:27 <glguy> zeonic98: Sorry, you'll have to take the topic elsewhere, it's offtopic here
21:04:33 <EvanR> unbounded queue plus an unbounded problem equals disaster
21:04:41 <Kaidelong> well an MVar is like a bounded queue of size one
21:04:47 <grantwu> backpressure, maybe?
21:04:53 <Kaidelong> if you try to push to it and it is full, you block
21:05:44 <zeonic98> Sorry to hit the wrong channel. I'm off.
21:05:48 <Kaidelong> there are a lot of use cases for those, and a bounded queue might work if you want to push some value of fixed size incrementally
21:06:21 <Kaidelong> also in other cases you might want bounded buffers of preprocessed input but not run the preprocessor too far ahead, although not for any application domain that would overlap with haskell
21:06:47 <Kaidelong> let me look at TBQueue's impl
21:07:07 <ezrios> EvanR: can you elaborate a bit? do you mean disaster == out of memory?
21:07:19 <Kaidelong> yeah write blocks if queue is full
21:07:51 <Kaidelong> the main reason I can think of to do this would be for things like media playback where you don't want the producer to starve other threads, especially the consumer
21:07:59 <EvanR> ezrios: when you get low on memory, various bad things can happen
21:08:17 <EvanR> for example, the kernel decides to kill your SSH server
21:08:18 <Kaidelong> not that you'd want to use haskell for those application domains anyway, but if you did
21:08:29 <ezrios> Kaidelong: ok, that is a good example
21:08:52 <ezrios> EvanR: so, bounded channels solve this problem by simply blocking subsequent writes when the queue is full
21:08:54 <ezrios> ?
21:09:06 <ezrios> whereas unbounded channels => unbounded use of memory =>? crash
21:09:07 <EvanR> that doesnt really solve everything, just the memory thing
21:09:25 <EvanR> but bounded channel just makes more sense by default
21:09:29 <Kaidelong> well blocking the thread does stop it from using up any other kinds of resources as well
21:09:47 <Kaidelong> except memory it already has allocated for it
21:09:49 <EvanR> it still means youll be dropping requests
21:10:01 <EvanR> if they cant wait
21:10:33 <EvanR> ex. your server used listen(5) to queue up at most 5 connection requests
21:10:36 <ezrios> so in what cases are unbounded channels acceptable, then? where I am assured that I have enough memory to process incoming data, and I cannot block?
21:10:43 <EvanR> then you block, then you pile up 5 connection requests
21:10:47 <EvanR> no more requests
21:11:05 <EvanR> ezrios: if you know you have enough memory for the problem, yeah. which is hard to know
21:11:51 <ezrios> ok, makes sense. thanks EvanR Kaidelong 
21:16:07 <koz_> How would I convert a Rational into its approximate Double representation?
21:16:24 <johnw> how approximate?
21:16:29 <johnw> like "I don't really care" approximate?
21:16:31 <EvanR> > realToFrac (1 % 3)
21:16:33 <lambdabot>  0.3333333333333333
21:16:46 <koz_> johnw: Yes. EvanR: Oh, OK. Thanks!
21:16:47 <johnw> the numbers library can give you a pretty faithful rendering
21:17:03 <EvanR> > realToFrac (39 % 3^300)
21:17:06 <lambdabot>  2.84897206664765e-142
21:18:34 <koz_> Wow, 1.6G of RAM on a normal workload, ouch.
21:18:46 <koz_> I suspect I'm gonna need to hunt for space savings.
21:19:34 <EvanR> 1.6G per second?
21:19:45 <koz_> EvanR: No, just 1.6G steady memory load.
21:20:00 <koz_> (and this is without *any* parallelism, which I fully plan to have)
21:20:32 <grantwu> Well... what are you doing?
21:21:05 <koz_> grantwu: Running EV (n,m) over a million generations, with a population of 1000 random propositional logic formulae on 10 variables.
21:21:44 <koz_> (starting depth of the formula trees is capped at 10, and each mutation introduces at most 1 leaf)
21:22:32 <koz_> (currently, n = m = 1)
21:22:42 <grantwu> I'm not sure what EV is :/
21:22:52 <koz_> grantwu: It's a very simple evolutionary algorithm.
21:22:58 <koz_> (like, it's pretty much as simple as it can get)
21:23:18 <grantwu> Is it just like... mutate, evaluate goodness, pick the better one?
21:23:39 <koz_> grantwu: Pick a random member of the population, mutate to make a new one, pick another, compare child with that, replace if better.
21:23:55 <koz_> (where 'better' is determined by some ranking function)
21:32:01 <koz_> Huh. My code spends ~50% of its time and allocation in shuffleM.
21:34:45 <EvanR> you are shuffling more than once?
21:36:36 <nitrix> Keep in mind shuffleM is recursively strict.
21:36:38 <koz_> EvanR: Let me check exactly how many times.
21:37:07 <koz_> EvanR: 20k calls.
21:37:39 <koz_> And in this case, most of the effort is wasted, since it shuffles a list of 1k elements to just take the first.
21:37:39 <nitrix> So if you have a large list and only pick the first element; you still pay the entire cost everytime.
21:37:45 <EvanR> lol
21:37:48 <koz_> nitrix: Yeah - I'm running *face* first into that.
21:38:06 * hackagebot lens 4.15.1 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.15.1 (EricMertens)
21:38:19 <koz_> Is there a way I can do better that this?
21:38:35 <EvanR> that shuffle algorithm cant be necessarily strict
21:39:48 <nitrix> koz_: Is your code "putting back" the elements in the set every time?
21:40:02 <koz_> Could I do something like take n . nub . getRandomRs (0, 999) or something?
21:40:18 <nitrix> Or does it shrinks progressively?
21:40:47 <EvanR> nub is n^2
21:40:50 <koz_> nitrix: My code always picks n-many from the full set of available indices.
21:41:11 <koz_> So if there are 1k members of the population, at each step, I have 1k indices to pick from, and I need n of them each time.
21:41:33 <EvanR> are you just trying to pick n random elements from a set?
21:41:57 <koz_> EvanR: Yes.
21:42:11 <nitrix> (Population? You make it sound like a genetic algorithm :P)
21:44:43 <EvanR> then write a fisher-yates that quits after making n moves
21:45:47 <EvanR> if you use a vector, you can select the items in O(1) and put them in your result list
21:45:53 <koz_> EvanR: I think I'll try that.
21:46:04 * koz_ goes off to code some.
21:47:46 <EvanR> actually that requires mutable
21:48:07 <EvanR> in which case ST arrays...
22:15:10 <neochronomo> Can someone help me utilize this line? How do I access it? data Color  = Red  | Orange | Green
22:16:55 <neochronomo> Here's the actual problem I'm trying to solve... http://pastebin.com/dRYZzU1h
22:17:22 <neochronomo> I figure I can use a case statement to assess argument "c", but I'm not sure how I'm supposed to use the colors from the data thing
22:17:54 <pavonia> You can use them like other values, because they actually are values
22:18:07 <pavonia> Red is a value of type Color
22:18:21 <pavonia> Just like "foo" is a value of type String
22:18:47 <pavonia> And you so can use them in pattern matching
22:18:53 <neochronomo> pavonia: So I would say something like... case c of "Red" -> "Stop" ?
22:19:29 <pavonia> But not in quotes, otherwise you'd make it a String
22:19:57 <pavonia> :t "True"
22:19:59 <lambdabot> [Char]
22:20:01 <pavonia> :t True
22:20:03 <lambdabot> Bool
22:20:32 <neochronomo> pavonia: Is there a reason the data expression has to be there at all? Why would I need to use it if I can just say case c of "Red" as a string?
22:22:07 <pavonia> Haskell has a very sophisticated type system, so newly declared values are more safe than just using strings everywhere
22:23:06 <pavonia> e.g. it's easy to mistype a string like "red" instead of "Red". If that'd happen with a data type, the compiler yould yell at you
22:23:14 <neochronomo> pavonia: so does data Colors = Red | Orange | Green mean that colors is a list of those listed colors?
22:23:40 <pavonia> It's a new type which has three values
22:24:18 <minn> Is there a short guide to setting up a modern Haskell environment with GHC 8.0.1? The last time I used Haskell for anything serious, things looked a little different (for one, Stack didn't exist).
22:25:10 <pavonia> neochronomo: You wouldn't say Int is a list of numbers, it's a type which has a lot of different values that are integer numbers
22:25:42 <neochronomo> pavonia: that makes sense
22:25:53 <minn> It looks like I shouldn't even be compiling stack/cabal/cabal-install anymore, and should compile Stack instead and use that to manage environments?
22:26:03 <minn> s/compiling stack/compiling GHC/
22:28:42 <EvanR> neochronomo: representing all data as strings is something you might do in javascript, but if youve tried that youd realize that results in a lot of pain
22:29:05 <EvanR> first, its easy to screw up and provide the wrong strings, or just nonsense as the data for a "type"
22:29:17 <EvanR> second, you no longer have any real documentation of what is allowed
22:29:28 <neochronomo> All very good oints
22:29:30 <neochronomo> points
22:29:51 <EvanR> third, when you do a switch (instead of a case) nothing stops you from omitting certain case checks
22:30:17 <EvanR> which results in, instead of an error, the program continuing on willy nilly with an undefined
22:30:39 <EvanR> when you refactor, nothing tells you what you broken in the process
22:32:49 <saurabhnanda> just broadcasting this here: https://www.reddit.com/r/haskell/comments/56qiw6/existential_question_how_practically_useful_is/
22:34:30 <EvanR> incredibly useful (sorry not good at reddit)
22:34:47 <dmj`> saurabhnanda: it was removed?
22:35:25 <saurabhnanda> dmj`: what was removed?
22:35:39 <saurabhnanda> EvanR: was that for me?
22:35:51 <brennie> saurabhnanda: that reddit post was deleted
22:36:01 <saurabhnanda> did I violate an guidelines?
22:36:30 <brennie> :/ All it says is [removed]
22:36:31 <EvanR> yeah
22:36:47 <dmj`> your question was too practical
22:36:52 <dmj`> needed more monad
22:36:52 <saurabhnanda> strange. will wait for the mods to message, in that case.
22:37:06 <EvanR> sounds like that question wasnt considered worthy
22:37:18 <saurabhnanda> strange, I can still access the link. Could be a caching issue at Reddit's end as well
22:37:33 <EvanR> is there anything there?
22:37:37 <brennie> saurabhnanda: open in a private/incognito tab?
22:38:06 <dmj`> saurabhnanda: but to answer your question, types are incredibly useful at managing complexity, which is the chief end of software engineering, something that weakly and dynamically typed languages fail hard at (fail hard at runtime that is) as well
22:38:08 * hackagebot parsec-free 3.1.11.2 - Parsec API encoded as a deeply-embedded DSL, for debugging and analysis  https://hackage.haskell.org/package/parsec-free-3.1.11.2 (JohnWiegley)
22:38:09 <saurabhnanda> yes, removed.
22:38:30 <saurabhnanda> I hope the mods at least tell me **why** it was deleted.
22:38:38 <brennie> you might be able to see it because youre the poster
22:38:51 <koz_> OK, I have something odd going on now. *The* biggest allocation source for me is a catamorphism. It's like, 90% of my allocation. I find that very odd, and suspect laziness at play. Could someone help me diagnose?
22:38:58 <saurabhnanda> hang on, will come back to this
22:39:17 <EvanR> and purity just makes sense
22:39:27 <ongy> to be honest, the "headline" (however reddit calls it) looks like one of the trolls
22:39:46 <brennie> purity makes functions easier to reason about. Easier reasoning => less bugs
22:40:31 <brennie> I still have yet to do anything actually useful in haskell, however
22:43:05 * EvanR cracks whip on brennie 
22:43:30 <brennie> too busy with my day job :)
22:46:59 <neochronomo> Shouldn't this convert a word into a string of asterisks? hide w = ['*' | b <- w]
22:47:37 <dmj`> > [ '*' | b <- "foo" ]
22:47:40 <lambdabot>  "***"
22:48:05 <dmj`> neochronomo: clever
22:48:19 <EvanR> youll never guess my password
22:48:27 <EvanR> > [ '*' | b <- "hunter2" ]
22:48:29 <lambdabot>  "*******"
22:49:29 <neochronomo> Hmm.. well it's not working for me.. I keep getting this error: Variable not in scope: secret :: String
22:50:12 <glguy> > '*' <$ "password"
22:50:14 <lambdabot>  "********"
22:50:41 <glguy> then you need to define secret
22:51:08 <EvanR> is that a hugs error message
22:51:58 <neochronomo> EvanR: it's GHCi
22:52:15 <neochronomo> glguy: no, that's the error I get whenI run the program... when i type "hide secret"
22:52:44 <glguy> neochronomo: sure, and it means you need to define secret, import it, etc
22:53:22 <neochronomo> glguy: But it's supposed to convert any word I type into asterisks.... like you did with "foo"
22:53:28 <neochronomo> Youdidn't have to import goo
22:53:29 <neochronomo> foo
22:53:44 <glguy> then you need quotes
22:54:06 <glguy> quotes indicate a string literal
22:54:58 <neochronomo> glguy: oh duh.. you're right. I thought coming from the command line it was auto-interpreted as a string
22:55:09 <vankooz> I have list like this ["aa", "bbb"] and I want to out put a list [('a', 2), ('b',3)] ie. each tuple contains the duplicated element and the length, I could do this [ (head c, length c) | c <- list]. Just not sure if this is idiomatic haskell. Any better ways?
22:55:34 <saurabhnanda> was this violating any Reddit guidelines? https://gist.github.com/saurabhnanda/16da89f33e3b573cc6c949b3597ed608
22:55:39 <EvanR> > group "aabbb"
22:55:42 <lambdabot>  ["aa","bbb"]
22:55:49 <glguy> that's a fine way, just keep in mind that it doesn't work for empty lists
22:55:55 <Axman6> > map (head &&& length) . group $ "aaaabbb"
22:55:58 <lambdabot>  [('a',4),('b',3)]
22:56:05 <dmj`> Axman6: beat me to it
22:56:10 <vankooz> cool, thx!
22:56:11 <Axman6> BAM!
22:56:21 <EvanR> but its already grouped i realize
22:56:32 <dmj`> > head &&& length <$> group "aaabbb"
22:56:32 <glguy> vankooz: if you're writing that in a file you should stick with your list comprehension
22:56:34 <lambdabot>  error:
22:56:35 <lambdabot>      • Couldn't match type ‘[]’ with ‘(->) [c]’
22:56:35 <lambdabot>        Expected type: [c] -> Int
22:56:46 <EvanR> &&&-ninja
22:56:57 * Axman6 agrees with glguy 
22:57:02 <vankooz> why?
22:57:05 <dmj`> go ninja, go ninja, go
22:57:22 <glguy> because it's a clearer implementation
22:57:34 <glguy> the &&& stuff is fun for messing around on irc
22:58:06 <vankooz> i c - thanks (I am trying to learn more magic stuff like yours...)
23:00:37 <ezyang> Ahoy, Haskellers. What is a simple programming problem (solution in 10 lines or so) that involves string manipulation? 
23:00:50 <ezyang> (Context: I'm looking for an example to demo Backpack with) 
23:00:53 <Axman6> LZM compesssion
23:00:54 <Axman6> >_>
23:00:59 <ezyang> 10 lines?! 
23:00:59 <Axman6> LZW*
23:01:03 <Axman6> yeah maybe not :P
23:01:08 <EvanR> 10 lines is huge
23:01:16 <saurabhnanda> ezyang: convert phone number to canonical format
23:01:18 <ezyang> ...with 80 cols I hope? :) 
23:01:19 <EvanR> everything here is solved in 1 line or less
23:01:41 <Axman6> ezyang: JSON parser?
23:01:55 <ezyang> saurabhnanda: Hmm, that doesn't sound very beautiful :{ 
23:02:10 <ezyang> Axman6: My first inclination was a parser combinator library. But actually you need a lot of junk 
23:02:15 <Axman6> yeah
23:02:18 <ezyang> Then I started thinking about regular expressions 
23:02:22 <saurabhnanda> ezyang: it's a real life problem we've dealt with. Had a lot of phone numbers and wanted to extract country codes out of them.
23:02:25 <ezyang> Maybe I should do that more seriously 
23:02:42 <ezyang> saurabhnanda: No, it's totally fair. I guess my aesthetic wants the problem solution to be "beautiful" 
23:02:55 <EvanR> phone numbers, is there really a canonical format
23:02:56 <saurabhnanda> ezyang: define beautiful, please?
23:03:06 <ezyang> I'm not a programmer, I'm an artiste 
23:03:27 <srhb> saurabhnanda: It's when your insides go all goeey and :3 :3 :3
23:03:34 <saurabhnanda> EvanR: probably not. But if you're sending text messages you need to know if it already has a country code or not. You need to remove extraneous formatting so 3rd party API doesn't reject. etc. etc.
23:03:49 <EvanR> just send the raw string to twilio ;)
23:03:55 <EvanR> theyll figure it out
23:04:11 <ezyang> When I started thinking about regular expressions I got worried because then I might start noodling with making both the string type and the element type parametrizable 
23:04:29 <ezyang> which... is actually pretty reasonable, but maybe one step at a time? 
23:04:31 <saurabhnanda> ezyang: given a bunch of email addresses find potential duplicates based on GMail's rules
23:05:02 * EvanR is now wondering about basic regexes
23:05:06 <ezyang> saurabhnanda: Isn't that just ordNubBy? :^) 
23:05:16 <ezyang> ordNubOn, even. 
23:05:25 <saurabhnanda> ezyang: what is a ordNubBy?
23:05:35 <ezyang> it probably doesn't exist haha 
23:05:41 <ezyang> but ordNub removes duplicates from a list 
23:05:51 <saurabhnanda> ezyang: lowercase, ignore periods (.), and +something all point to same mailbox.
23:05:53 <ezyang> so ordNubOn would let you also pass a function to run 
23:06:01 <ezyang> to canonicalize the email before running it 
23:06:05 <ezyang> That's too short for an example!! 
23:06:10 <saurabhnanda> ezyang: hmm
23:06:21 <saurabhnanda> 10 lins in haskell is a lot IMO
23:06:24 <saurabhnanda> go with LZW then
23:06:29 <ezyang> haha 
23:06:36 <EvanR> zip file reader
23:06:44 <saurabhnanda> or do everything in unicode
23:06:52 <saurabhnanda> it'll add layers of complexity to a simple problem
23:08:16 <Axman6> simeple search engine?
23:08:22 <saurabhnanda> ezyang: parsing the Postgres array format
23:08:32 <saurabhnanda> ezyang: word stemming?
23:09:09 <Axman6> word stemming would definitely be part of a search engine type thing (I've been playing with PostgreSQL's full text search a fair bit recently)
23:10:42 <ezyang> ok... I think I'm going to do regular expressions XD 
23:10:48 <saurabhnanda> any /r/haskell reddit mods on this IRC channel?
23:11:11 <saurabhnanda> ezyang: will that demonstrate the regex capabilities or your library's capabilities?
23:12:17 <Squarism> Recursive haskell forms ftw! https://gurgl.github.io/index.html: Try 
23:12:17 <Squarism> langd > vikt
23:12:18 <Squarism> bmi = CA
23:12:18 <Squarism> inskrivningsdatum < 2011-01-01
23:13:08 <Axman6> ezyang: I'm looking forward to seeing this article, I haven't managed to see the benefit of backpack yet, the examples so far haven't been particularly enlightening - are Strings really the best example?
23:13:45 <Axman6> Squarism: everything I enter disappears
23:14:54 <Axman6> saurabhnanda: I don't know why your question got removed, but it's one that's been answered many many times before
23:14:54 <ezyang> Axman6: Hmm, which examples have you seen so far? 
23:16:10 <saurabhnanda> Axman6: on reddit? Or elsewhere? Any links? I tried searching on Google, but couldn't come up with anything specific. Just the same old assertions that Haskell's type system is the best. I wanted to focus on, how those strengths translate to practical advantages.
23:16:19 <Axman6> on reddit
23:16:28 <Axman6> ezyang: I can't remember! =)
23:16:55 <Axman6> ezyang: but String seems like a poor example, because you kind of want to know whether you're working with a [Char] or a Text to deal with them efficiently
23:18:13 <glguy> string and text are rather similar in the complexity of their operations
23:18:26 <ezyang> Axman6: So, if I showed you an efficient parser combinator/regex for both STring and Text that would convince you? :) 
23:18:54 <ezyang> or... what glguy said! 
23:19:05 <Axman6> saurabhnanda: it can probably be summed up with: a powerful type system catched bad programs earlier, and the earlier bugs are caught, the less costly they are. more type information allows for better optimisations, and haskell's type system can actually do work for you by writing code for you by just specifying the types
23:20:01 <saurabhnanda> Axman6: vs Elixir's static analyzer? Or Javascript's Flow?
23:20:12 <Axman6> ezyang: possibly, but I think there might be more enlightening examples. Perhaps something which lets you work with HashMaps and Maps
23:20:25 <Axman6> saurabhnanda: yes, those type systems are extremely primitive
23:20:47 <Axman6> Flow doesn't assist in providing any useful type information to the compiler right?
23:20:51 <ezyang> Axman6: Hm. That actually might not be a very good use case for Backpack 
23:21:02 <saurabhnanda> Axman6:  in that case I'm just looking for an in-depth blog post which solidifies this argument.
23:21:22 <koz_> I think of it like this: A type system makes ridiculous states unrepresentable.
23:21:26 <saurabhnanda> Axman6: it helps in catching the same bugs that a static type system does. The practical outcome is the same. Methods are different.
23:21:35 <Axman6> Connor McBride's LambdaJam 2016 talk was pretty good (though quite advanced)
23:21:56 <saurabhnanda> koz_: not automatically. You have to really apply your mind to doing that in Haskell. Check our github repo for the kind of questions that we're trying to answer.
23:22:13 <koz_> saurabhnanda: Yes, and I find by doing this, I understand both my problem, and how to solve it, much better.
23:22:26 <koz_> The very mental process of coming up with the right types for my problem space helps my thinking.
23:22:36 <koz_> And as a result, I write better, cleaner and more logical code.
23:22:58 <grantwu> saurabhnanda: Out of curiosity, what was the question?
23:23:20 <saurabhnanda> grantwu: https://gist.github.com/saurabhnanda/16da89f33e3b573cc6c949b3597ed608
23:23:27 <Axman6> it can make writing the code to actually process your data very mechanical too (and thise is where theorum provers start to become useful, where they literally can write your programs based on the properties the functions should have)
23:23:53 <Axman6> ezyang: so, what else is a good use for backpack? I hope it's not just strings =)
23:24:08 <saurabhnanda> Axman6: isn't all that stuff pretty futuristic? Is all that really possible in Haskell today? Do we have any books from where I can learn about writing webapp using this stuff?
23:24:14 <ezyang> Axman6: Because you kind of don't want the key type to be a type parameter. If it is, you need type class constraints but there isn't a "right" one here. 
23:24:41 <EvanR> saurabhnanda: yeah, the idris book really helps illuminate how types can help the design process, also look at some conal videos
23:24:48 <ezyang> Hmm, I guess you could make the constraint abstract. Hmmmm!!! 
23:25:02 <ezyang> Axman6: There are a lot of "boring" use cases for Backpack. 
23:25:12 <saurabhnanda> EvanR: conal videos?
23:25:15 <Axman6> ezyang: hit me with 'em :)
23:25:41 <EvanR> its not bondage and discipline, its moving from a world of chaos to a world of order, which world is up to you
23:25:59 <Axman6> saurabhnanda: it's not that far off at all. Also, just the existance of thing slike the Traversable class make writing generic code once much easier than in some dumber languages
23:26:12 <Axman6> EvanR++
23:26:13 <grantwu> saurabhnanda: So, honestly, the literature on this sort of thing is really bad
23:26:21 <koz_> saurabhnanda: I'm not really interested in web apps.
23:26:23 <ezyang> Axman6: diagrams has multiple backends, currently it uses a flag to switch between them. Decouple it with Backpack 
23:26:39 <koz_> let EvanR = fmap (+1) EvanR
23:26:44 <grantwu> And there aren't very many large scale systems built in say... languages with HM type inference
23:26:44 <ezyang> there are a lot "backends" type situations. HDBC, Chart, satchmo 
23:26:46 <saurabhnanda> Axman6: apart from core libraries, are there any use-cases for the generic code?
23:26:48 <EvanR> saurabhnanda: https://www.youtube.com/watch?v=bmKYiUOEo2A
23:27:02 <jchia> Is it bad to define a newtype based on Int32 that has Bounded instance where minBound is not really the min possible value and maxBound is not really the max possible _representable_ value, but rather the min and max _valid_ values? Is there anything in the common libraries that depend on minBound and maxBound that will be broken by this convention?
23:27:05 <ezyang> Not strings, but filepaths could be usefully abstracted 
23:27:24 <ezyang> Any situation where you are tempted to write a multiparameter type class with a lot of parameters, but you know it'll be a bad idea 
23:27:28 <Axman6> saurabhnanda: I write web apps in Haskell for a living, and the Servant library, which makes specifying my API simple, and my app doesn't compile if I do stupid things like forget to handle a capture or return something of the wrong type.
23:27:40 <jle`> jchia: that's a common thing
23:27:49 <ezyang> jchia: That's fine, but it's best to have smart constructors which prevent you from constructing invalid values 
23:27:51 <Axman6> jle`: sounds appropriate to me
23:28:01 <EvanR> jchia: thats normal, you can search for it by "smart constructor"
23:28:08 <grantwu> saurabhnanda: The best I can offer to you is to just try Haskell - it feels more productive
23:28:09 <jle`> jchia: http://hackage.haskell.org/package/refined
23:28:09 <saurabhnanda> Axman6: hang on, is that an example for generic code, like traversables?
23:28:14 <Axman6> no
23:28:17 <saurabhnanda> grantwu: already doing that :)
23:28:22 <Axman6> though, it can be, one sec...
23:28:48 <Axman6> saurabhnanda: see https://haskell-servant.github.io/posts/2015-08-05-content-types.html
23:28:48 <jle`> jchia: your type in that library would be Refined (GreaterThan n `And` LessThan m)
23:29:26 <koz_> Genericity is its own reward. :)
23:29:27 <jchia> thanks, jle`, ezyang, EvanR
23:29:37 <grantwu> saurabhnanda: I honestly think anyone claiming that they can prove that functional programming results in fewer bugs needs to show really good evidence because I haven't seen this
23:30:01 <grantwu> How to reconcile that with the fact that languages like Haskell make wide classes of bugs impossible is... an open research question :)
23:30:07 <EvanR> where functional means javascript? clojure?
23:30:11 <saurabhnanda> grantwu: so it is an emacs vs vi debate, essentially? boils down to personal preference?
23:30:33 <ezyang> I think when people say that types help prevent bugs, that is missing the point 
23:30:38 <grantwu> EvanR: You could s/functional programming/programming in Haskell/
23:30:41 <grantwu> saurabhnanda: Well... no
23:30:45 <EvanR> there we go
23:31:03 <grantwu> Regardless of the lack of evidence, I still believe that more advanced type systems are useful for correctness
23:31:14 <Axman6> saurabhnanda: in that blog post, the entire API is specified in the types, the handler doesn't even get invoked unless the inputs are valid, and in thise case, the handler doesn't have to do anything, because the library provides the generic means to perform actions, in this case image format conversion, without the developer needing to do anything special at all.
23:31:28 <grantwu> But I'm forced to admit that there I don't have any empirical evidence for it
23:31:36 <koz_> I just find they help me think about the problem better, and describe the system in such a way as to make invalid states impossible.
23:31:47 <saurabhnanda> Axman6: I'll have to read that 3 times to grok it completely :)
23:31:49 <koz_> I don't have any empirical evidence for this either, but it *is* really fun and has taught me a lot.
23:32:22 <saurabhnanda> if I wear my developer hat, then I want to write in Haskell. If I wear my manager hat, I wonder whether it's worth the risk.
23:32:29 <grantwu> Evaluating whether or not one language is better than another for correctness is also really hard because of how many confounding variables there are
23:32:42 <EvanR> how about your pointyhair
23:32:42 <koz_> saurabhnanda: Lucky me, then. :)
23:33:01 <EvanR> how about developer-as-manager
23:33:14 <grantwu> Like, people have formally verified C, too...
23:33:17 <Axman6> We're running Haskell in production for the Australian Government, we don't see it as a risk
23:33:40 <lispy> grantwu: At this point, C is one of the more formally verified languages. As odd as that sounds.
23:33:55 <saurabhnanda> Axman6:  so the question to ask is, if you end your contract, and the Australian Government inherits the Haskell code, will they see it as a risk then?
23:34:25 <Axman6> it's open source, so we've all inherited it :P
23:34:27 <EvanR> they will simply rewrite it, just like any other langauge besides PHP
23:34:43 <saurabhnanda> EvanR: developer-as-manager hat = tech lead = how do I excite the team about Haskell
23:34:54 <grantwu> saurabhnanda: One useful bit of anecdata that might address your concern is
23:34:55 <EvanR> you put on reddit about how its risky
23:35:05 <EvanR> they read it, and affirm their bias
23:35:10 <Axman6> developers who aren;t excited about learning new things aren't worth keeping very long...
23:35:33 <saurabhnanda> Axman6: devs, like everyone else, respond to marketing. 
23:35:35 <grantwu> While there are a lot fewer programmers with functional programming experience, there are also a lot fewer people trying to hire them
23:36:00 <saurabhnanda> Axman6: devs will get excited about trying Kafka in production. Trying Facebook Flow. Or the next big rage in the tech scene.
23:36:06 <EvanR> saurabhnanda: in general how to expose people to the exciting parts of haskell the best way is a good question, hint "Monads"</ancientaliens> isnt that
23:36:06 * Axman6 gives grantwu bonus points for using 'fewer' correctly
23:36:22 <grantwu> And that functional programmers will often take into consideration whether or not they get to use FP at work
23:36:44 <grantwu> Like, I look at my spreadsheet of internships I'm applying to, and I'm sad that there's only one place I know for sure uses FP
23:36:59 <EvanR> yeah
23:37:24 <EvanR> i turned down a recruiter several times this year because they werent doing functional
23:37:34 <magneticduck> saurabhnanda: start an initiative to port everything to TorqueScript
23:37:49 <saurabhnanda> magneticduck: what new hell is TorqueScript?
23:38:08 <magneticduck> 9t
23:38:09 * hackagebot fold-debounce-conduit 0.1.0.4 - Regulate input traffic from conduit Source with Control.FoldDebounce  https://hackage.haskell.org/package/fold-debounce-conduit-0.1.0.4 (debugito)
23:38:32 <magneticduck> it's not so great -- anyway, they'll be excited to transition to Haskell
23:39:08 <saurabhnanda> aha -- got the mods to get this back online -- https://www.reddit.com/r/haskell/comments/56qiw6/existential_question_how_practically_useful_is/
23:39:53 <EvanR> i wouldnt reworded this question to sound more honest about where its coming from
23:40:06 <EvanR> though that might have already been asked 100 times on reddit
23:40:45 <EvanR> which is how do i justify haskell in a real work environment, given the status quo and lack of haskell people
23:41:18 <EvanR> because as it stands, its saying, "all these other things are better, so... whats the point"
23:42:09 <grantwu> That's... not how I understand it
23:42:50 <grantwu> I'm reading it as... do I want to use these technologies that were designed from day 1 with the functional/strong types philosophy?
23:43:13 <grantwu> Or should I instead use these tools that retrofit these ideas onto more widely used technologies
23:43:17 <saurabhnanda> EvanR: that slant is also there. But in this question I want to ask more about the practical benefits of the type system + purity. Does it really help catch more bugs compared to other altnernatives? If it does, it's my job to sell it internally.
23:43:39 <saurabhnanda> for example, is the refactoring story in Haskell really different from Java/C# ?
23:43:48 <EvanR> IDE support
23:43:51 <EvanR> ^ this
23:43:55 <saurabhnanda> compared to Ruby, it's obviously different, but compared to Java/C#?
23:44:04 <EvanR> is completely ignored by web languages including ruby
23:44:35 <magneticduck> the cited studies pull the 'bug density' metric from e.g. the number of 'bug-fixing' commits
23:44:42 <grantwu> Oh... come now, there are plenty of Ruby IDEs
23:44:52 <EvanR> in use?
23:45:04 <EvanR> theres plenty of haskell IDEs
23:46:04 <grantwu> I've never written Ruby so I wouldn't know
23:46:05 <saurabhnanda> EvanR: what, where? Which IDE? I've been looking for one!
23:46:30 <EvanR> https://wiki.haskell.org/IDEs
23:47:43 <EvanR> not listed is haskforce plugin
23:48:03 <EvanR> so theres probably some other data missing from this page
23:48:50 <liste> EclipseFP is dead AFAIK
23:49:04 <EvanR> wasnt somebody using in here the other day
23:49:29 <liste> https://github.com/JPMoresmau/eclipsefp -- "EclipseFP is currently NOT maintained anymore. Feel free to fork and take up maintainership!"
23:51:09 <EvanR> my point wasnt that IDEs are a strong point or a normal technique for haskell, but that its about as strong or normal as web languages and they dont care either
23:51:38 <magneticduck> saurabhnanda: interestingly, that medium article that you linked in your reddit post, the one that cites a graph of 'languages sorted by bug density'... 
23:52:11 <saurabhnanda> magneticduck: please go on...
23:52:21 <magneticduck> the second study that it links actually finds Haskell quite conclusively among the least bug-prone languages
23:52:36 <magneticduck> http://macbeth.cs.ucdavis.edu/lang_study.pdf see the results section
23:53:43 <grantwu> saurabhnanda: http://danluu.com/empirical-pl/ I found this to be an interesting and amusing read
23:53:56 <magneticduck> I'm reading the first study now -- supposedly that is where the condemning graph comes from
23:54:21 <grantwu> My link actually references that
23:54:30 <grantwu> The three typescript projects are actually C++ projects.
23:54:37 <grantwu> They just happen to use Qt configuration files.
23:54:49 <grantwu> This causes GitHub to classify them as typescript projects
23:54:56 <magneticduck> hehe :)
23:55:44 <EvanR> you could put together a statistical reliability metric on githubs detector
23:56:18 <saurabhnanda> grantwu: going through that link...
