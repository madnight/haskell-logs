00:00:05 <ertes> @let tails' = foldr (\x r -> foldr (\ys _ -> (x:ys) : r) [] r) [[]]
00:00:07 <lambdabot>  Defined.
00:00:09 <ertes> > tails' "abcd"
00:00:12 <lambdabot>  ["abcd","bcd","cd","d",""]
00:01:08 <Paprikachu> on line 61 i explicitly check for < n
00:06:32 <Paprikachu> oh, zeroes
00:16:26 <arzav> morning
00:16:51 <jle`> morning arzav !
00:36:44 <jle`> they are very different languages :)
00:36:47 <jle`> ~>
00:39:07 <neonfuz> What is the scope of where?
00:39:19 <jle`> oops, sorry, sent those by mistake
00:39:22 <neonfuz> is it just on the previous expression or something?
00:39:31 <jle`> neonfuz: where is attached to declarations
00:39:36 <neonfuz> it doesn't go accross multiple definions of the same function does it?
00:39:39 <neonfuz> like multiple patterns
00:39:55 <neonfuz> jle`: alright
00:39:58 <jle`> no, it's a part of declaration syntax, and if you're declaring it multiple times over the different patterns, it's only for the current pattern
00:40:02 <ertes> neonfuz: the scope of 'where' is the clause
00:40:13 <jle`> foo .. = .. where ..
00:40:17 <jle`> foo .. = .. where ...
00:40:27 <ertes> so it spans all guards, but doesn't span competing clauses
00:40:48 <neonfuz> okay
00:40:59 <ertes> and of course there are actually two flavours of 'where'
00:41:21 <ertes> one is part of 'class', 'instance', 'module', etc., which doesn't really have a "scope" in that sense
00:50:08 <lgstate> anyone feel that every time they flip flop haskell/clojure, they learn more about both languages?
00:50:27 <polarpop> Hello world.
00:51:31 <polarpop> How do I work this?
00:51:47 <gargawel> polarpop: how do you work what ?
00:53:01 <polarpop> This may sound stupid but i've never used IRC I saw this was a popular place for Kali-Linux tips and whatnot didn't know if there was a sub chat or something.
00:53:59 <gargawel> This channel is dedicated to Haskell, a functional programming language
00:54:10 <gargawel> I fear it's not the place you're looking for :)
00:54:40 <polarpop> Well darn, thanks for letting me know haha. Take it easy.
00:55:25 <gargawel> I'm taking it pretty easy, at first, I thought you were asking how to implement "Hello world" in Haskell ! ;)
00:56:07 <ertes> lgstate: if clojure is anything like scheme i didn't really feel like i learned anything about either by flip-flopping
00:56:29 <polarpop> Haha I know I could google this but is Haskell sort of like C++? What is it mainly used for?
00:56:35 <ertes> i really only learned to question whether scheme is really a functional language
00:57:04 <lgstate> eretes: I learned how to implement datomic / mini-kanren (sorta prolog) by studying clojure
00:57:12 <lgstate> now it's influencing the way I think about haskell
00:57:15 <ertes> polarpop: it's very different from C++, and it's a general purpose language, so you can use it for anything really
00:57:22 <gargawel> polarpop: Well, it's an entirely different paradigm
00:58:00 <tdammers> ertes: scheme is definitely not a functional programming language in the sense that functional programming is its default paradigm
00:58:30 <ertes> tdammers: it's one of those "confused about their paradigm" languages, i think
00:58:49 <tdammers> well, as any Lisp, scheme has this love-hate relationships with macros
00:58:55 <ertes> ES6 seems to be a lot more "functional" than scheme, and trust me, i feel really weird saying that
00:59:28 <tdammers> half of the schemer's mindset says "macros are the most awesome feature of the language", the other half says "if you can do it without macros, do it without macros"
01:00:11 <tdammers> frankly, the one thing that all those languages are missing in order to qualify them as "functional" in my book is a way of reliably controlling and containing effectful computations
01:00:55 <ertes> i have a hard time doing FP in non-static languages anyway, because the type-level interactions simply get too complicated for my limited brainpower
01:01:05 <tdammers> to me, "functional language" means it needs to have some sort of construct that models a function
01:01:11 <tdammers> (where "function" implies purity)
01:01:38 <tdammers> I think this has nothing to do with static vs. dynamic; it just so happens that none of the dynamic languages has such a construct
01:01:49 <Vyn> > let 2 = 1
01:01:52 <lambdabot>  <no location info>: error: not an expression: ‘let 2 = 1’
01:02:03 <Vyn> That works in my GHCI
01:02:10 <tdammers> every one of them allows at least some side effects in "functions", effectively making them "procedures"
01:02:13 <Vyn> But doesn't seem to do anything
01:02:20 <tdammers> at least Scheme has the intellectual honesty of not calling them "functions"
01:02:37 <tdammers> Vyn: correct. A let binding on its own doesn't do anything
01:03:13 <Vyn> tdammers: I mean if I now do 1 + 2, it doesn't evaluate to 1 (or 4, for that matter)
01:03:13 <ertes> tdammers: i'm comfortable just not using side effects, even when they're allowed, but i'd hardly call any non-static language functional, simply because i find it super-difficult to do FP without types
01:03:14 * hackagebot inline-java 0.5.1 - Java interop via inline Java code in Haskell modules.  https://hackage.haskell.org/package/inline-java-0.5.1 (MathieuBoespflug)
01:03:16 * hackagebot from-sum 0.1.1.0 - Canonical fromMaybeM and fromEitherM functions.  https://hackage.haskell.org/package/from-sum-0.1.1.0 (cdepillabout)
01:03:27 <ertes> Vyn:
01:03:29 <Vyn> > let 2 = 1 in 1 + 2
01:03:29 <ertes> @let 2 = 1
01:03:36 <lambdabot>  Defined.
01:03:36 <lambdabot>  3
01:03:50 <tdammers> > 1 + 1
01:03:56 <lambdabot>  2
01:04:05 <tdammers> I don't think you can rebind integer literals
01:04:17 <ertes> Vyn: you pattern-matching 1 against 2, which of course fails, but you never actually evaluate that match
01:04:19 <parsnip> Hello, i'd like to generate a TAGS file for use with emacs, from my hakyll site with site.hs, with tag generator also referring to codein cloned Hakyll repo. Any advice on which tag generator to use? 
01:04:30 <ertes> > let r@2 = 1 in r + r
01:04:34 <parsnip> *code in
01:04:36 <lambdabot>  *Exception: <interactive>:3:5-11: Irrefutable pattern failed for pattern r@2
01:04:55 <tdammers> I was about to wonder why it doesn't error, but when you remember that let introduces a pattern matching context, it makes sense
01:05:17 <ertes> it's really like:  let Just x = Nothing in …
01:05:25 <tdammers> > let f 1 = 1; f x = x + 1 in (f 1, f 2)
01:05:27 <lambdabot>  (1,3)
01:05:37 <ertes> parsnip: hasktags
01:05:46 <parsnip> ertes: thank you
01:06:03 <ertes> parsnip: also if you use haskell-mode it offers to use hasktags for you
01:06:12 <parsnip> nice
01:06:22 <ertes> parsnip: and if you use haskell-interactive-mode, you don't need TAGS at all (it will query the running GHCi instead)
01:06:48 <Vyn> Hm, okay
01:06:58 <ertes> parsnip: (with fallback to TAGS, if GHCi is not running)
01:07:22 <parsnip> ertes: oho, but then how would i make sure all functions are loaded in repl? wouldn't it only grab those i imported, or for each file i bothered to :load? 
01:07:42 <ertes> parsnip: that's why it falls back to TAGS =)
01:07:48 <parsnip> ah, nice
01:08:00 <parsnip> so _every_ function, sweet. 
01:16:53 <Gurkenglas> Reading https://hackage.haskell.org/package/machines-0.6.1/docs/Data-Machine-Moore.html , apparently you can inline class definitions with the [+]. Is another button to inline data/newtype definitions planned?
01:35:17 <ph88^> Gurkenglas, i don't see [+] in source, but i do see  {-# INLINE (@>) #-}
01:37:07 <kqr> byorgey, wait what. you are the inventor of "a new way to read and print double sided paper"?
01:37:48 <Gurkenglas> ph88^: I mean the [+] GUI element on the website linked to directly to the left of, for example,  "instance Closed Moore Source #"
01:38:32 <ph88^> ah so you are asking about documentation features ?
01:38:35 <Gurkenglas> yep
01:38:51 <ph88^> isn't this generated by haddock ?
01:40:19 <Gurkenglas> yep
01:40:46 <ph88^> maybe make an issue here about it https://github.com/haskell/haddock/issues
01:41:52 <Gurkenglas> Thought I should gather information here first, but sure
01:51:05 <Gurkenglas> https://github.com/haskell/haddock/issues/555
02:03:16 * hackagebot mysql-haskell 0.5.1.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.5.1.0 (winterland)
02:03:18 * hackagebot patat 0.3.2.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.3.2.0 (JasperVanDerJeugt)
02:03:20 * hackagebot sparse-linear-algebra 0.2.0.5 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.0.5 (ocramz)
02:29:44 <saurabhn_> does anyone know of a type-safe version of https://hackage.haskell.org/package/aeson-diff
02:33:31 <jophish> Is anyone using GHC-8.0.2?
02:41:13 <kqr> jophish, don't ask to ask, just ask
02:42:51 <kqr> jophish, (i assume your real question isn't if there exists an X such that X uses ghc 8.0.2)
02:42:58 <kqr> because the answer to that is yes
02:44:38 <jophish> kqr: no, my question was "is anyone using 8.0.2" :)
02:45:09 <jophish> well, I suppose the real question was "are people besides the people developing it using it"
02:50:21 <kqr> and I don't think you'll be wrong if you assume "yes" hehe
02:51:03 <[exa]_> Hi everyone
02:51:32 <[exa]_> I'm trying to implement the haskell-like type system using mostly information from THIH
02:52:05 <[exa]_> Q: How does the information from a 'data X = Y | Z | ...' statement get translated to the THIH structures?
02:52:52 <[exa]_> in particular, does it even touch the "classEnv" environment?
02:54:00 <jophish> [exa]_: It shouldn't touch the class environment
02:54:14 <jophish> I think that thih has quite a lot of examples programs to test on
02:54:29 <jophish> the prelude and such, it might be worth taking a look at those
03:00:12 <User12512> hey, i am trying to explain a friend the difference between functional and declarative programming languages. I want to give her a few examples of small problems solved either way. however my functional progtramming skills are not there. can you give me a few simple haskell examples of small-ish functions?
03:00:39 <liste> @src length
03:00:40 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:00:42 <liste> :(
03:00:46 <sbrg> @src zip
03:00:47 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
03:00:47 <lambdabot> zip _      _      = []
03:00:52 <liste> there's one ^
03:00:58 <sbrg> @src map
03:00:58 <lambdabot> map _ []     = []
03:00:58 <lambdabot> map f (x:xs) = f x : map f xs
03:01:07 <sbrg> all the standard combinators are probably good examples
03:01:14 <kqr> User12512, some people might argue functional programming is a kind of declarative programming, and thus that you won't find "the difference"
03:01:54 <sbrg> ^ when writing parsers using parser combinators, it feels very declarative, for example.
03:02:00 <[exa]_> jophish: so, from my example, the X translates to TCon, and Y, Z only create "constructing functions", right?
03:02:06 <sbrg> you're kind of just stating what you're parsing looks like.
03:03:17 * hackagebot netwire-vinylglfw-examples 0.0.0 - Netwire/GLFW/VinylGL input handling demo  https://hackage.haskell.org/package/netwire-vinylglfw-examples-0.0.0 (RandKleisli)
03:04:00 <User12512> sry...i meand the difference between imperative and declarative and functional as a verison of declarative to compare to a version of imperative
03:04:08 <User12512> my bad :D
03:04:31 <kqr> haha
03:04:35 <byorgey> User12512: how about incrementing every number in a list
03:04:36 <kqr> that question makes a lot more sense
03:04:57 <byorgey> User12512: in a functional language you can write something like  map (+1) theList
03:05:13 <jophish> [exa]_: I can't remember the details of thih but that sounds about right
03:05:18 <jophish> X would have kind Star
03:05:25 <User12512> i thought about something like fibonacci but a little bit longer 
03:05:27 <jophish> and Y and Z would have type X
03:05:40 <byorgey> User12512: in an imperative language (well, in a language without first-class functions, specifically) you would write some kind of loop.
03:06:10 <kqr> for comparisons between loops in imperative programming and fp, here are some examples: https://two-wrongs.com/myth-of-the-day-functional-programmers-dont-use-loops
03:06:20 <kqr> but that wasn't what I was really looking for
03:06:41 <[exa]_> jophish: one more question. Is it possible to derive the kinds of complicated stuff (e.g. RWST), or is it necessary that the programmer specifies them?
03:07:01 <User12512> i know the difference and have the explanation itself, its just about some examples :D the imperative code i can write myself the declaratice code is...a problem for me is the haskell code to compare it to
03:08:02 <[exa]_> e.g. RWST r w s m a  has kind *->*->*->(*->*)->*->* , I can see that 'm' would need to have the *->* kind because it's used as m(a,s,w) in the constructor. But what about a,s,w ?
03:08:46 <byorgey> User12512: well, maybe if you give some examples you have in mind, we can help you translate them into Haskell
03:09:22 <jophish> [exa]_: If they're not used then they'll default to Star
03:09:33 <jophish> you're right though, this is a slight complication
03:09:51 <[exa]_> so there are defaults. Thanks a lot
03:10:01 <byorgey> [exa]_: a, s, w *must* have kind * because they are used as  arguments to (,,)
03:10:02 <jophish> One option is to do the kind checking here in the same way as the type checking for functions
03:10:12 <byorgey> this is not because they just default to *.
03:10:21 <[exa]_> oh, yes
03:10:29 <jophish> split the data types into dependency groups and check them all together
03:10:47 <jophish> (in order)
03:11:08 <byorgey> [exa]_: though there are situations where you have to default kinds, and standard Haskell does default kinds to *
03:11:11 <jophish> with any unconstrained variables in each group defaulting to Star
03:11:21 <[exa]_> so anyway, having something like Data X x = Y (RWST x x x x x) should already know kinds of RWST and fail because the kinds don't match, right?
03:11:30 <jophish> exactly
03:11:53 <[exa]_> okay, thanks a lot
03:12:39 <jophish> if you have: data A x = A (B x); and data B x = B (A x), although x is used on the right in each declaration it's still subject to defaulting 
03:12:56 <jophish> because it's not constrained in the dependency group which is A and B
03:13:18 <[exa]_> (luckily I don't have recursive types)
03:13:40 <jophish> what's the compiler for out of interest?
03:13:45 <kqr> User12512, actually I have an example in mind, but you'll have to annotate it yourself
03:14:27 <[exa]_> jophish: trying a system-level haskell, no GC, linear-inspired types
03:15:00 <jophish> nice, let us know how it goes!
03:15:48 <User12512> would something like this be possible? http://pastebin.com/S6wFf7ZE @kqr
03:15:48 <[exa]_> e.g. (->) produces closure information so that there's no dynamic allocation needed for lazy evaluation
03:16:24 <[exa]_> jophish: well, I'll certainly be hanging around here for quite some time now :D
03:16:59 <User12512> it basically goes to a string and gets every part of it that matches a certain pattern
03:17:16 <[exa]_> anyway, main inspiration is this http://icfp2016.mirage.io/ICFP/the-best-of-both-worlds-linea/template.md (guess worth reading)
03:17:39 <[exa]_> eh wrong link
03:18:09 <[exa]_> this --- http://conf.researchr.org/event/icfp-2016/icfp-2016-papers-the-best-of-both-worlds-linear-functional-programming-without-compromise
03:18:53 <byorgey> User12512: I'm kind of surprised the regular expression library doesn't already have a function to get all matches
03:20:00 <jophish> [exa]_: the abstract sounds enticing!
03:20:45 <User12512> probably has, it was the task to write an own
03:22:29 <byorgey> User12512: in a functional language perhaps you would have a function like   match :: Pattern -> String -> Maybe (String, String)   which tests whether a string matches the given pattern, and returns the part that matched and the remainder if so
03:24:20 <byorgey> User12512: then you could write something like   allMatches pat "" = []; allMatches pat s = case match pat s of { Nothing -> []; Just (m,rest) = m : allMatches pat rest }
03:24:41 <kqr> User12512, http://lpaste.net/raw/6130382975369478144
03:24:54 <kqr> User12512, printing floyds triangle up to depth n is an interesting problem to do this comparison on
03:25:16 <kqr> User12512, note that while the haskell code defines a variable that contains the entire infinite floyds triangle and then prints a segment of it
03:25:41 <kqr> User12512, the C code "needs" (in the sense that it is the most straightforward solution) to define a function that both generates numbers as well as prints them
03:25:46 <kqr> User12512, and it specifies the loops very manually
03:26:09 <kqr> code not tested and so on
03:26:40 <kqr> User12512, I could translate your loop too if you told me what the regex meant
03:27:08 <kqr> oh it parses json
03:27:10 <kqr> that's dumb lol
03:27:12 <kqr> but I'll roll with it
03:27:38 <User12512> yeah...university....dumb shit you are supposed to do xD
03:28:11 <User12512> and that would be lovely
03:34:13 <kqr> User12512, http://lpaste.net/2292188638164811776
03:34:24 <kqr> User12512, i'm not kidding that's it
03:34:35 <kqr> User12512, it's doing the exact same thing except functionally
03:34:45 <User12512> @kqr thank you :§
03:34:46 <lambdabot> Arrr!
03:35:06 <kqr> normal standard library style functions
03:35:07 <User12512> and i know, that functional can be quite short...while i dont know anything anymore really i have had haskell
03:35:15 <kqr> i'm a bit surprised myself although I probably shouldn't be
03:35:50 <kqr> but a lot of the loop accounting and error checking your java code does is built into the "unfoldr" standard combinator
03:36:21 <kqr> and it helps that haskell regex libraries don't return "pointers" (in this case indices into the string) but rather values directly
03:45:52 <knupfer> Is there a function like   warning :: String -> a
03:46:15 <kqr> what would it do?
03:46:36 <liste> :t trace -- knupfer
03:46:38 <lambdabot> error: Variable not in scope: trace
03:46:55 <knupfer> Oh, I wanted to write  warning :: String -> a -> a
03:47:09 <liste> knupfer: http://hackage.haskell.org/package/base-4.9.0.0/docs/Debug-Trace.html#v:trace
03:47:14 <kqr> oh yeah that sounds like trace
03:47:15 <knupfer> liste: thanks
03:55:20 <jophish> It's really only a tool for debugging though
03:55:35 <jophish> I wouldn't suggest using it non-temporarily
03:59:19 <knupfer> jophish: Yeah, I'm trying to debug some rewrite rules
04:00:16 <knupfer> Ideally I would have the rewrite rule directly error out the compilation, but it seems that that isn't possible.
04:03:03 <knupfer> Perhaps it would be possible with a compiler plugin
04:19:53 <Jenaf> hi! how can you use something like Data.Sequence.singleton in pattern matching?
04:20:19 <Jenaf> I'm writing something to recurse over a Sequence and I'd like to know how to get my abort case in
04:20:48 <jophish> Jenaf: you can use view patterns
04:20:55 <mauke> http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Sequence.html#v:viewl
04:21:02 <Jenaf> uff...
04:21:09 <mauke> or just viewl
04:22:23 <Jenaf> so if i type a:<EmptyL in the pattern matching it should work? 
04:22:26 <jophish> that's probably much neater. It's not very often at all that you find people using view patterns
04:22:55 <mauke> Jenaf: ah, no
04:23:03 <jophish> not quite, the element to the right of :< is a sequence
04:23:32 <Jenaf> but in that case EmptyL is the emty sequence?
04:23:32 <mauke> x :< xs | S.null xs = ...
04:23:41 <mauke> no, EmptyL is an empty ViewL
04:24:02 <jophish> in that case you may as well do s | S.length x == 1 = ...
04:24:09 <Jenaf> arf
04:24:17 <jophish> unless you want evidence of an empty sequence and a single element
04:24:45 <saurabhn_> does anyone know of a typsafe version of https://hackage.haskell.org/package/aeson-diff
04:25:00 <mauke> oh, yeah. S.length is O(1)
04:26:57 <Jenaf> hm..
04:30:07 <zaquest> Jenaf, while (viewl -> x :< EmptyL) doesnt work, (viewl -> x :< (viewl -> EmptyL)) works not sure if it's a better idea to use it then length or null though
04:30:23 <jophish> pattern Singleton a <- (toList -> [a])
04:30:33 <Jenaf> fieldSorter l (opts,rows)|(Seq.length rows)==1 = ...
04:30:40 <Jenaf> should that work?
04:30:54 <Jenaf> where (coord,bools)= index rows 0
04:33:25 <Jenaf> okay it seems ghc doesn't like pattern matching in where clauses
04:33:43 <knupfer> Hm, how can I let fire rewrite rules on literal strings?
04:34:14 <knupfer> If I put on the LHS  a:b  it fires on lists of chars, but not on literal strings.
04:34:18 <zaquest> Jenaf, `where (coord,bools)= index rows 0` is fine while types match
04:34:57 <Jenaf> I got a parse error on input '(' error on that
04:35:04 <Jenaf> but it was in the second line of the where
04:36:56 <Jenaf> other issue:
04:37:12 <Jenaf>     Module `Data.Sequence' does not export `deleteAt'.
04:37:18 <Jenaf> huh? 
04:43:07 <afidegnum> hi, i m learning beginner in haskell, and there are few quesions i need your asistance with...    while reading, i want to find out about the explicit definition of (Num t) => t
04:43:17 <afidegnum> what does => stands for?
04:43:27 <afidegnum> what's the difference between => and -> ? 
04:43:28 <srhb> afidegnum: It's delimiting class constraints from the rest of the type
04:44:07 <srhb> afidegnum: So `Num a => a -> a` reads "Function from a to a, where a has an instance for Num"
04:45:15 <afidegnum> srhb: still more fuzzy, 
04:45:29 <afidegnum> can you please break it down for me please ?
04:45:39 <srhb> afidegnum: Let's start from functions then
04:46:00 <Jenaf> how can I delet a single element in a Data.Seqence.Seq(a)
04:46:11 <srhb> afidegnum: `x -> y` is the type of a function which takes an argument of type `x` and produces an argument of type `y`
04:46:55 <srhb> afidegnum: `a -> b -> c` is a function that takes two arguments of type `a` and `b` respectively and produce a value of type `c`
04:47:00 <srhb> afidegnum: Clear so far?
04:48:03 <afidegnum> srhb: so literally does -> means 'return'  ?
04:48:12 <srhb> afidegnum: No, it's the function construction operator.
04:48:46 <srhb> afidegnum: You can think of it as an infix operator from argument type to result type
04:48:53 <phanimahesh> a -> b is the type of a function that takes something of type a and returns something of type b
04:49:08 <srhb> phanimahesh: I just wrote that.
04:49:27 <phanimahesh> srhb: oops. sorry, dodn't read scrollback. :/
04:49:32 <srhb> phanimahesh: :)
04:50:25 <afidegnum> so let's say, a  and b is a function,    function a returns function b   right ?
04:50:46 <phanimahesh> afidegnum: do you have a ghci open?
04:50:46 <srhb> afidegnum: Not clear what you're asking.
04:51:04 <Jenaf> you should eat some curry  afid
04:51:07 <Jenaf> ;)
04:51:18 <knupfer> afidegnum: yes
04:51:29 <srhb> knupfer: What does that mean?
04:51:48 <Jenaf> :t curry = a -> b -> c -> ((a,b)->c) iirc
04:51:50 <lambdabot> error:
04:51:50 <lambdabot>     parse error on input ‘=’
04:51:50 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
04:51:51 <knupfer> srhb: It's a simplification, and return not in an Applicative, but imperative sense
04:52:08 <Jenaf> oh lambdabot likes me now! how did i earn that honor?
04:52:13 <Jenaf> :t curry
04:52:15 <knupfer> afidegnum: look at the function `even`
04:52:15 <lambdabot> ((a, b) -> c) -> a -> b -> c
04:52:20 <afidegnum> srhb: yes, i have ghci openeed
04:52:21 <srhb> knupfer: I mean, you must have understood the question, so can you explain it?
04:52:42 <phanimahesh> oh. I forgot lambdabot exists. we can use it directly.
04:52:57 <srhb> knupfer: That is, "let's say a and b is a function, function a returns function b, right?"
04:53:40 <knupfer> Well, I parsed it internally like "a->b" is a function which returns a "value b"
04:53:49 <srhb> I don't know how you managed that. ;-)
04:54:06 <knupfer> I'm a teacher, I'm used to read like that :)
04:54:10 <afidegnum> :)
04:54:19 <afidegnum> this is getting interresting :)
04:54:21 <knupfer> afidegnum:  even :: Int -> Bool
04:54:38 <knupfer> so, even takes an integer, and returns a bool
04:54:41 <afidegnum> even is an integer type,  right ?
04:54:42 <knupfer> > even 4
04:54:45 <lambdabot>  True
04:54:47 <knupfer> > even 3
04:54:48 <srhb> afidegnum: No.
04:54:49 <lambdabot>  False
04:54:50 <afidegnum> oh
04:54:54 <srhb> afidegnum: even is a function from Int to Bool
04:55:09 <knupfer> you can read it like  even(x)
04:55:13 <srhb> So it *has* a *function type*
04:55:35 <afidegnum> even x
04:55:44 <knupfer> if you give your function an integer, its type changes to bool.  Does that make sense to you?
04:55:57 <afidegnum> yes, 
04:55:58 <younder> no
04:55:59 <knupfer> you have to use a ">" to query mr. lambda
04:56:05 <knupfer> > even True
04:56:07 <lambdabot>  error:
04:56:07 <lambdabot>      • No instance for (Integral Bool) arising from a use of ‘even’
04:56:07 <lambdabot>      • In the expression: even True
04:56:09 <knupfer> oh no
04:56:12 <afidegnum> hahahah
04:56:19 <afidegnum> > even true
04:56:21 <lambdabot>  error:
04:56:22 <lambdabot>      • Variable not in scope: true :: Integer
04:56:22 <lambdabot>      • Perhaps you meant data constructor ‘True’ (imported from Data.Bool)
04:56:31 <younder> lol
04:56:36 <afidegnum> :) wow, this is getting interresting here, lol
04:56:40 <knupfer> Note that this function seems to behave different than in C world.
04:56:47 <phanimahesh> let's look at even, as suggested.
04:56:47 <phanimahesh> :t even
04:56:49 <lambdabot> Integral a => a -> Bool
04:56:56 <lordcirth> :t even 3
04:56:58 <lambdabot> Bool
04:57:13 <lordcirth> See? ^
04:57:19 <knupfer> :t not
04:57:21 <lambdabot> Bool -> Bool
04:57:26 <afidegnum> knupfer: so if i undestand, -> is a kind of convertor or apply function ? 
04:57:31 <knupfer> odd x = not (even x)
04:57:37 <knupfer> yep
04:57:46 <knupfer> Read it like maths
04:57:58 <afidegnum> what's the equivalent of this in python/java?
04:58:09 <srhb> afidegnum: It doesn't have an equivalent.
04:58:10 <younder> not even is a bit ODD
04:58:16 <srhb> afidegnum: And it's not a converter or apply function.
04:58:19 <afidegnum> hahahaha...
04:58:20 <srhb> afidegnum: (Whatever that means)
04:58:29 <afidegnum> wow, offside, 
04:58:30 <knupfer> srhb: Don't be overly precise
04:58:36 <Jenaf> :t uncurry $ flip $ curry (\ a b c d e -> foo)
04:58:38 <lambdabot> error:
04:58:39 <lambdabot>     • Variable not in scope: foo
04:58:39 <lambdabot>     • Perhaps you meant ‘for’ (imported from Data.Traversable)
04:58:39 <knupfer> That turn lerners nuts.
04:58:57 <Jenaf> :t uncurry $ flip $ curry (\ a b c d e -> (a,b,c,d,e))
04:58:59 <lambdabot> (b, a) -> t -> t1 -> t2 -> t3 -> ((a, b), t, t1, t2, t3)
04:59:12 <mauke> learners need to become nuts
04:59:19 <srhb> afidegnum: You can think of it either as syntax that explains what the types of arguments (the left-hands) and the resulting type is
04:59:21 <knupfer> mauke: peu a peu
04:59:23 <afidegnum> well, i m just a haskell fresher, who is learning from the right scratch
04:59:25 <Jenaf> :t curry $ flip $ uncurry (\ a b c d e -> (a,b,c,d,e))
04:59:27 <lambdabot> a -> b -> (t, t1) -> t2 -> t3 -> (t, t1, (a, b), t2, t3)
04:59:46 <srhb> afidegnum: Yes, I'm only complaining about preciseness because the explanations that are flying around are borderline lies that will end up confusing more than helping. :)
04:59:53 <srhb> "lies to children" is fine, in measure.
05:00:07 <phanimahesh> afidegnum: think of f :: a -> b as a function that takes an a and returns a b. yes, it is a bit like converting.
05:00:08 <afidegnum> ok, 
05:00:23 <phanimahesh> but when I convert kilometers to meters, I always get the same answer.
05:00:28 <knupfer> afidegnum: https://en.wikipedia.org/wiki/Function_(mathematics)#Notation
05:00:34 <knupfer> does that look familiar to you?
05:00:45 <afidegnum> yes, 
05:00:52 <phanimahesh> but to "convert" a number to a bool, I can define it in many ways. so calling it conversion is not good.
05:01:02 <knupfer> So it's actually the same in haskell
05:01:30 <younder> converting is SLOW
05:01:31 <knupfer> for example the   f: N -> Z
05:01:38 <afidegnum> > convert x = x*1000 in [1..1000]
05:01:42 <lambdabot>  <hint>:1:11: error:
05:01:43 <lambdabot>      parse error on input ‘=’
05:01:43 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
05:01:53 <afidegnum> oh, why = i snot valid?
05:02:00 <knupfer> it means that the function f takes a natural and returns an integer
05:02:21 <liste> afidegnum: you need a let there
05:02:28 <knupfer> > let convert x = x*1000 in [1..1000]
05:02:31 <afidegnum> ah, ok i remember, 
05:02:31 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:02:33 <liste> > let convert x = x * 1000 in [1..1000]
05:02:36 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
05:02:45 <afidegnum> oh, no
05:02:48 <younder> Is there any support for GPU computation in Haskell?
05:03:12 <afidegnum> > let convert x = x*1000 in [1..10]
05:03:15 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:03:20 * hackagebot binary-tagged 0.1.4.1 - Tagged binary serialisation.  https://hackage.haskell.org/package/binary-tagged-0.1.4.1 (phadej)
05:03:26 <afidegnum> no it didn't work
05:03:39 <quchen_> ?hackage accelerate -- younder
05:03:39 <lambdabot> http://hackage.haskell.org/package/accelerate -- younder
05:04:15 <younder> thx quchen
05:04:20 <knupfer> > let convert x = x*1000 in convert 5 
05:04:23 <lambdabot>  5000
05:04:24 <afidegnum> wait doesn't this supposed to print from *1000 onward ?
05:04:29 <knupfer> you have to use your function
05:04:34 <phanimahesh> afidegnum: you are asking it for [1..10], assuming that wherever convert x appears, consider it to be x * 1000
05:04:35 <afidegnum> aaaaah   oooooh
05:04:36 <knupfer> if not it's pointless
05:04:40 <afidegnum> i forgot again, Damn! 
05:05:09 <jophish> q
05:05:20 <afidegnum> > let convert x = x*1000 in convert [1..5]
05:05:22 <lambdabot>  error:
05:05:22 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M857538256652...
05:05:22 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
05:05:41 <knupfer> convert expects an Integer, but you give it a list of Integers
05:05:57 <phanimahesh> > let convert x = x*1000 in map convert [1..5]
05:06:00 <lambdabot>  [1000,2000,3000,4000,5000]
05:06:10 <knupfer> :t map
05:06:12 <lambdabot> (a -> b) -> [a] -> [b]
05:06:32 <knupfer> afidegnum: Can you parse that type signature?
05:06:37 <afidegnum> > let convert x = x*1000 in map convert [1..5]
05:06:39 <lambdabot>  [1000,2000,3000,4000,5000]
05:06:49 <afidegnum> good, i im taking note, 
05:06:57 <afidegnum> knupfer: which type ?
05:06:57 <phanimahesh> > map (+1) [1..5]
05:07:00 <lambdabot>  [2,3,4,5,6]
05:07:00 <sshine> for haskell packages, is there a convention as to which part of the version that may cause breaking changes? e.g. if I'm depending on bytestring, I seem to recall that I'd want to specify an upper-limit constraint on the package version, but is '>= 0.10.8 && < 0.11' reasonable when current is 0.10.8.1?
05:07:08 <knupfer> That of map, do you understand it?
05:07:13 <amx> sshine: http://pvp.haskell.org/
05:07:23 <knupfer> What do you think, why are there multiple -> ?
05:07:27 <sshine> amx, thanks!
05:07:34 <afidegnum> knupfer: yes, i do undestand
05:08:11 <knupfer> So look at the `a` in the type signature. Which types could that be?
05:08:12 <afidegnum> so with this, how do i write similar function with '->'  ?
05:08:14 <phanimahesh> afidegnum: look at types of map, (+1), and can you explain how `map (+1) [1..5]` works?
05:08:46 <afidegnum> phanimahesh: yes, map as far as i know, apply a function to a list or a sequence
05:08:58 <afidegnum> and output a result
05:09:18 <afidegnum> in fact list of results, 
05:09:26 <knupfer> afidegnum:  What would be the type signature of plus?
05:09:40 <phanimahesh> Great. That's close. Now can you explain this by using the notation in types?
05:09:42 <knupfer> (Don't look it up)
05:09:52 <afidegnum> > :plus
05:09:54 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
05:10:13 <knupfer> Don't read it up, think about it.
05:10:29 <knupfer> What is the function "plus" supposed to take and to return?
05:10:30 <afidegnum> plus is an addition funciton, 
05:10:53 <afidegnum> it suppose to take the integer or value from the left and return the result at the right side
05:11:11 <afidegnum> am i correct ?
05:11:12 <knupfer> Try to write a signature
05:11:20 <knupfer> (no, but that's not the point)
05:11:22 <afidegnum> signature ?
05:11:32 <knupfer> even :: Integer -> Bool
05:11:36 <knupfer> plus :: ???
05:12:12 <afidegnum> oh ok
05:12:48 <afidegnum> plus :: Integer -> Int
05:13:14 <lordcirth> nope
05:13:22 <knupfer> Ok, let's use your function and think about it.
05:13:31 <knupfer> plus 4 :: Int
05:13:41 <knupfer> This would be the result of your function
05:14:04 <knupfer> But something is off...
05:14:14 <afidegnum> yes
05:14:34 <knupfer> Actually, you would want that your function takes to Integers, no?
05:14:43 <phanimahesh> * two
05:14:49 <knupfer> :)
05:15:02 <afidegnum> yes
05:15:04 <knupfer> plus 4 :: Integer -> Integer
05:15:07 <knupfer> !
05:15:29 <afidegnum> so does this enforce type checking ?
05:15:34 <knupfer> If you give your function only one Integer, it returns a function which wants another Integer
05:15:37 <afidegnum> or type constrain ?
05:15:41 <knupfer> Yes
05:15:56 <lordcirth> all function arguments are typechecked
05:16:07 <knupfer> plus :: Integer -> Integer -> Integer
05:16:12 <knupfer> This is what you want
05:16:35 <knupfer> read like  Integer -> (Integer -> Integer)
05:16:47 <afidegnum> so meaning, we do a type checking before staring to write the appropriate expression, right ?
05:16:58 <lordcirth> afidegnum, what do you mean?
05:17:00 <knupfer> If you give it one Integer, it returns a function.  If you give it another Integer, it returns a value
05:17:17 <afidegnum> Heeey! 
05:17:18 <knupfer> afidegnum: Yes, that's possible
05:17:26 <phanimahesh> afidegnum: I don't know the distingction you have in mind, type constraints( or specifications or signaturess) are used to do type checking
05:17:42 <phanimahesh> * distinction. I can't type. :/
05:17:44 <knupfer> you could say    plus = undefined
05:17:57 <afidegnum> ok, 
05:17:58 <knupfer> and begin to implement the type signature
05:18:37 <knupfer> And afterwards, you implement the expression and the compiler says if this expression works with your type
05:19:15 <Jenaf> sigantures are awesome!
05:19:25 <Jenaf> always make them, ti really helps
05:19:28 <knupfer> > :t 4 + (5 :: Integer)
05:19:31 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
05:19:41 <knupfer> :t 4 + (5 :: Integer)
05:19:43 <lambdabot> Integer
05:19:59 <knupfer> :t (4 +)
05:20:01 <lambdabot> Num a => a -> a
05:20:08 <knupfer> :t (+)
05:20:10 <lambdabot> Num a => a -> a -> a
05:20:31 <Jenaf> :t (4 +(5 :: Integer)) :: Int
05:20:33 <lambdabot> error:
05:20:33 <lambdabot>     • Couldn't match expected type ‘Int’ with actual type ‘Integer’
05:20:33 <lambdabot>     • In the expression: (4 + (5 :: Integer)) :: Int
05:20:36 <knupfer> > "python" + 4
05:20:38 <lambdabot>  error:
05:20:39 <lambdabot>      • No instance for (Num [Char]) arising from a use of ‘+’
05:20:39 <lambdabot>      • In the expression: "python" + 4
05:20:51 <knupfer> There are no implicit conversions.
05:20:52 <afidegnum> ok, coming back here again, 
05:21:02 <hpc> that's easy, just fix the error like so:
05:21:04 <hpc> > fix error
05:21:04 <afidegnum> what's the difference between -> and => ?
05:21:07 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
05:21:27 <knupfer> afidegnum: I'd recommend that you ignore "=>" at the beginning
05:21:49 <knupfer> "=>" constrains some type to be part of a class
05:22:09 <knupfer> But think first about "->"
05:22:12 <Jenaf> for example Num a => a->a means that the type of a needs to be some sort of number
05:22:24 <Jenaf> bbut it can be Int or float or somethign elze
05:22:25 <jophish> Jenaf: that's uncurry
05:22:34 <jophish> oh sorry, that happened ages ago
05:22:43 <knupfer> afidegnum: look at this type   magic :: (a,b) -> (b,a)
05:22:55 <afidegnum> yes
05:23:02 <knupfer> What do you think, what could the function magic do?
05:23:31 <kqr> why magic, of course
05:23:33 <afidegnum> algebrically, ab could be = ba, right ?
05:23:45 <afidegnum> ab = ba
05:23:51 <Jenaf> think more abstract!
05:23:58 <afidegnum> oh
05:24:00 <afidegnum> ok
05:24:10 <hpc> inputs and outputs
05:24:12 <phanimahesh> ab and ba, in absence of more information are just two identifiers, as different as x and y.
05:24:26 <Jenaf> a can be a Traitor while b is a Planet
05:24:36 <afidegnum> :D ok
05:24:43 <knupfer> Or an Integer, or even a function
05:24:51 <phanimahesh> (a,b) however is a tuple, with a as its first element and b as its second element
05:25:04 <knupfer> magic :: (Banana, Spaghetti) -> (Spaghetti, Banana)
05:25:22 <knupfer> How could that possibly work
05:25:44 <Jenaf> magic apple carbonara
05:25:56 <Jenaf> magic (apple,carbonara)
05:26:05 <afidegnum> knupfer: magic :: (a,b) -> (b, a) means change ab to ba?
05:26:10 <Jenaf> would thenr esult in a type match error if you used the second version
05:26:12 <knupfer> Yep
05:26:34 <knupfer> You could have a expression which converts a Banana to Spaghetti
05:26:58 <knupfer> But that would be quite specific, and not valid for all possible types.
05:27:00 <afidegnum> wow, trying slowly to grasp it, 
05:28:00 <knupfer> So, an implementation which works for *every* type can only swap the tuple
05:28:25 <afidegnum> so how do i call magic then?
05:28:38 <kqr> i feel like you're talking at two different levels of understanding
05:28:48 <knupfer> > let magic (a, b) = (b, a) in magic (True, 2)
05:28:50 <lambdabot>  (2,True)
05:29:21 <knupfer> kqr: Not sure what you mean
05:29:44 <afidegnum> knupfer: no, wait
05:30:11 <afidegnum> :D :D :D    
05:30:40 <afidegnum> is the second one part of the initial type 'type enforcement' ?
05:31:11 <knupfer> Hm, I'm not sure if I understand you.
05:31:30 <afidegnum> meaning for the second one to be true, you meed to apply magic :: (a,b ) -> (b, a) ?
05:31:48 <knupfer> Yes
05:32:03 <afidegnum> then you call the magic function or it's just an alternative to the first ?
05:32:15 <knupfer> In this case you could be more specific:   profane :: (Bool, Integer) -> (Integer, Bool)
05:33:05 <Jenaf> knupfer: how do i delete a single element for a Sequence (Data.Sequence)?
05:33:22 <afidegnum> > let myswap (x, y) = (y, x ) in myswap (a, b)
05:33:25 <lambdabot>  (b,a)
05:34:06 <afidegnum> knupfer: please enlighten me more 
05:34:08 <Jenaf> like deleteAt (S.fromList [1..10]) 1 == S.fromList [1,3,4,5,6,7,8,9,10]
05:34:19 <afidegnum> srhb: u there?
05:35:14 <Jenaf> http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Sequence.html suggests that deleteAt exists
05:35:33 <Jenaf> but when i try to use it ghc says that Data.Sequence does not export deleteAt
05:35:38 <jophish> Jenaf: it's only been there since 5.8
05:35:39 <srhb> afidegnum: On and off. :)
05:36:00 <jophish> Jenaf: make sure you're using a correct version
05:36:06 <kqr> knupfer, you're talking about parametricity restricting implementation, and afidegnum is asking how to call functions
05:36:20 <Jenaf> how can i check Package/module versions from ghci?
05:37:09 <knupfer> afidegnum: What's your question?
05:37:33 <knupfer> Your swap implementation is perfect
05:38:25 <codedmart> Looks like there are a few options. Anyone have experience with aws s3 signedUrl's and which package is best?
05:38:33 <knupfer> kqr:  Yes, but we came from the types.  Types are more important than an implementation.
05:39:09 <afidegnum> i m tryig to find out the equivalence of magic :: (a,b ) -> (b, a)   and let myswap (x, y) = (y, x ) in myswap (a, b)
05:39:11 <knupfer> afidegnum:  Now you can run your "myswap" function on *any* tuple
05:39:21 <knupfer> Ah
05:39:39 <knupfer> So the upper is the specification (the type) and the lower is its implementation
05:39:59 <Jenaf> jophish: how can i check what version my Data.Sequence is? and how can i update it?
05:40:36 <knupfer> afidegnum: Think about your plus function:   plus :: Integer -> Integer -> Integer
05:40:50 <Jenaf> also i only got Haskell a few eeks ago so I thought it should have quite current versions
05:40:58 <knupfer> That's a specification, which has got some liberties in its implementation
05:41:24 <knupfer> minus has got the same type signature
05:41:30 <knupfer> but a different implementation
05:41:51 <srhb> Jenaf: ghc-pkg list | grep containers
05:42:02 <srhb> Jenaf: containers is the name of the package that has Data.Sequence (usually)
05:42:27 <knupfer> afidegnum: Does that sound understandable to you?
05:43:12 <Jenaf>     containers-0.5.7.1 -.- (how can i update it? is there some ghc command to do that?)
05:43:14 <kqr> knupfer, it's hard to experiment with types if you don't know how to run your code, though. not saying you absolutely need to run code to play with types, just that it may help build intution
05:43:43 <srhb> Jenaf: No, ghc has nothing to do with installing packages. Usually you use cabal-install, stack, nix, system package manager, ...
05:43:51 <knupfer> kqr, he said that he's got a ghci running
05:43:53 <afidegnum> knupfer: not totally
05:43:55 <srhb> Jenaf: There's a plethora of choices :)
05:44:19 <knupfer> afidegnum: ok, how could you possibly implement   foo :: Integer
05:44:28 <Jenaf> srhb: i got the "haskell platform" from the haskell web packe but I forgot what packagae manager came with it...
05:44:36 <srhb> Jenaf: cabal-install and stack, iirc.
05:44:45 <Jenaf> okay
05:45:30 <Jenaf> I'll just run cabal update; that should fix things
05:45:48 <srhb> Jenaf: note that it only fetches the list of packages and versions from Hackage
05:45:51 <knupfer> afidegnum:  One implementation would be  foo = 42
05:45:52 <srhb> Jenaf: It doesn't install any.
05:45:58 <Jenaf> oh
05:45:59 <afidegnum> yes
05:46:13 <Jenaf> and how Do i install the current version of containers?
05:46:17 <knupfer> But there are quite a lot implementations which satisfy this type.
05:46:48 <srhb> Jenaf: iirc, cabal install containers after doing cabal update should fetch the newest versio  that's compatible with your ghc.
05:47:02 <Jenaf> okay
05:47:14 <Jenaf> yeah now it's doing it
05:47:15 <knupfer> So the type signature is actually restricting you to some implementations
05:47:17 <Jenaf> thanks!
05:47:34 <afidegnum> knupfer: ok,
05:47:46 <knupfer> But there are normally multiple implementations for a type signature
05:47:53 <srhb> Jenaf: At least, if your ghc is pointing at that package db. :)
05:47:59 <srhb> Jenaf: (check afterwards with ghc-pkg list again)
05:48:10 <Jenaf> kthy
05:48:10 <knupfer> Think about the "even" function, it has got the same signature than the "odd" function
05:48:22 <knupfer> It takes an Integer and returns a Bool
05:48:27 <Jenaf> is it normal that the building takes a while?
05:48:32 <srhb> Jenaf: Yes.
05:48:38 <afidegnum> ok
05:48:44 <srhb> Jenaf: You're downloading it from source (and you may be getting dependencies too)
05:49:12 <Jenaf> now i have 2 versions of containers; that should not be an issue i guess?
05:49:53 <knupfer> The types help you, because they are a lot more clearer than an implementation.  And the compiler enforces correctness for the types.
05:50:01 <srhb> Jenaf: Try it out. :)
05:50:02 <Jenaf> okay now it seems to work, thanks a lot @shrb
05:50:46 <knupfer> Sometime you get lucky and write a type signature which allows only one implementation.
05:51:19 <knupfer> In this case, the type proofs your implementation correct.
05:51:20 <cocreature> not in haskell, you can always screw up in multiple ways and write an infinite loop :)
05:51:36 <knupfer> cocreature: *pss*
05:51:43 <knupfer> undefined etc
05:52:13 <afidegnum> it's gradually making sense,
05:52:17 <afidegnum> woow!
05:52:25 <knupfer> The type of "myswap" has only one possible implementation, try to think about another implementation.
05:52:29 <cocreature> well avoiding undefined is fairly easy. just don’t write undefined. but accidentally writing programs that loop forever has happened multiple times to me
05:52:31 <afidegnum> i think there will be more to read from 
05:53:49 <knupfer> cocreature: undefined and an infinite loop are the same.  And actually correct, because you can deduce from falsehood what you want :)
05:54:03 <knupfer> afidegnum: Do you know Learn You a Haskell?
05:54:51 <[exa]_> Hm. Is there some prominent usage of multiparameter typeclasses that can't be reasonably simulated by single-parameter ones?
05:55:22 <cocreature> knupfer: they are really not the same. you can easily observe the difference, e.g. by running seq.
05:55:54 <afidegnum> i started to read them
05:56:01 <afidegnum> i m reading them througout
05:56:09 <cocreature> you can take a theoretical point of view in which they are equivalent but when you look at the actual way ghc haskell behaves they are not the same
05:56:38 <knupfer> cocreature: You can observe the difference only from outside of your programm
05:56:58 <cocreature> knupfer: I can write seq in my program
05:57:11 <Jenaf> I have to admit a Sin I'm going to commit:
05:57:18 <Jenaf> unMaybe :: maybe Int -> Int
05:57:19 <Jenaf> unMaybe Nothing = -1
05:57:21 <Jenaf> unMaybe Just a = a
05:57:35 <knupfer> Jenaf: Why would you want to do that?
05:57:36 <cocreature> Jenaf: you’ve clearly written too much C :)
05:58:00 <younder> I love category theory and I would like more in my Haslell programs.Where do I lok?
05:58:04 <younder> look
05:58:26 <knupfer> cocreature: I don't use seq and exclude it generally of my thoughts
05:58:27 <Jenaf> bacause I don't know how to properly handla a maybe
05:58:38 <knupfer> I think it's quite sad that we've got `seq` in ghc
05:58:59 <Jenaf> boolfield.hs:47:129: error:
05:59:01 <Jenaf>     * Couldn't match expected type `Int' with actual type `Maybe Int'
05:59:02 <cocreature> so you just leave spaceleaks in your programs?
05:59:18 <Jenaf> anyway i g2g
05:59:42 <knupfer> cocreature:  If they are only curable with seq, then yes (in most cases, my programs terminate rather fast).
06:00:02 <younder> to weak to categorize the language and verify it.
06:00:16 <mauke> :t fromMaybe (-1)
06:00:18 <lambdabot> Num a => Maybe a -> a
06:00:20 <younder> Let's cange that!
06:00:28 <younder> change
06:00:34 <Jenaf> and mauke wins ^.^
06:00:39 <Jenaf> anyway i g2g
06:00:49 <Jenaf> >fromMaybe (nothing)
06:00:53 <knupfer> That's the same as your implementation
06:00:56 <Jenaf> >fromMaybe (Nothing)
06:01:08 <cocreature> knupfer: fair enough. personally I consider spaceleaks to be bugs that have to be fixed
06:01:16 <Jenaf> :t fromMaybe
06:01:18 <lambdabot> a -> Maybe a -> a
06:01:23 <Jenaf> ahhhh
06:01:57 <magneticduck> Jenaf: http://hayoo.fh-wedel.de/?query=a+-%3E+Maybe+a+-%3E+a
06:02:02 <younder> Formula is a change in that direction if any 'hard core' developers are interested.
06:02:10 <knupfer> cocreature: I don't fix bugs which force me to give up semantics.
06:03:08 <younder> We proove functions. Becuse the types alow us to. No 'lemma'a'
06:03:14 <younder> allow
06:03:18 <magneticduck> if it's semantically correct to have a spack leak that's not necessary, you have bad semantics
06:04:16 <knupfer> magneticduck: If you use seq, you have bad semantics.  So we'd have to find a way to express the problem without seq and without spaceleak.
06:04:39 <knupfer> In general, I'm much more interested in correctness than efficiency
06:04:47 <cocreature> knupfer: good luck writing a "sum" function that doesn’t leak space without seq
06:05:08 <magneticduck> knupfer: have we been conclusively convinced that seq is semantically ugly? I haven't, but I might be out of the loop.
06:05:18 <younder> I have a language. That is it. Formula is that language. It uses category theory and topology to create a language that can be proven
06:05:40 <younder> annyone wanna help?
06:06:26 <joe9> younder: check out HoTT? set theory for types has some issues and I doubt category theory can help in that regard.
06:06:27 <magneticduck> (and if it is ugly, it doesn't seem immediately obvious that space leaks are a good trade-off to avoid it)
06:07:25 <younder> joe9: set theory is weak. category theory is better. sets are just repeats of the alg..
06:08:41 <knupfer> cocreature:  You can use a strict fold (which uses seq) and consider the implementation of the fold an implementation detail, because it doesn't change the semantics (the list will be entirely consumed).
06:10:21 <knupfer> Anyway, I've to go
06:10:24 <cocreature> I prefer being able to write my own primitives over having more primitives that I can’t express in the language directly
06:12:04 <magneticduck> cocreature: is a primitive that you can derive a primitive at all?
06:12:46 <cocreature> magneticduck: I guess not
06:15:02 <magneticduck> cocreature: if you could suggest a seq-like primitive that didn't weaken so many results from lambda calculus without giving up all the power we need to express strict algorithms, I'm sure the community would love it!
06:15:30 <cocreature> magneticduck: oh I’m totally fine with seq, knupfer is the one that doesn’t like it :)
06:15:51 <magneticduck> .. well, I'm still right!
06:16:24 <younder> seq-like primitives are a must!
06:16:48 <implementation_> ...or just use bang patterns...
06:17:09 <younder> We can 'fake' it with procedural fun
06:17:44 <magneticduck> younder: if you want a perfect language, make a framework for formally proven ASM
06:18:03 <afidegnum> using ubuntu, what's the good editor / IDE i can use ?
06:18:14 <cocreature> “finally, the pain of writing asm and doing formal verification combined in one language”
06:18:37 <magneticduck> cocreature: in all seriousness, it would be the most expressive and safest language ever
06:19:17 <cocreature> magneticduck: sure and it’d be extremely painful to write anything in it so nobody would use it
06:19:40 <implementation_> afidegnum: there are many options. emacs has a good ghci-integration, but you can also use (g)vim, geany, kate, ...
06:20:03 <cocreature> afidegnum: do you already have a text editor that you use for other languages?
06:20:17 <implementation_> afidegnum: https://wiki.haskell.org/IDEs
06:20:41 <afidegnum> well, i have seen the one listed in haskell website, but still confused
06:20:47 <afidegnum> i am using pycharm, i 
06:20:51 <afidegnum> have sublime
06:21:09 <afidegnum> trying to get my hand of emacs since i m not much familiar with it 
06:21:29 <cocreature> there are haskell integrations for both sublime and intellij but I have used neither so I can’t comment on the quality
06:21:50 <cocreature> afidegnum: but at least when you’re starting out I wouldn’t worry about learning haskell and a new editor at the same time
06:22:21 <afidegnum> yes, you are right, 
06:22:22 <cocreature> afidegnum: you can get pretty far with just syntax highlighting & ghci. we don’t have ide integrations like you can find for something like java anyway
06:22:45 <afidegnum> what about emacs??
06:22:58 <cocreature> personally I like emacs and the haskell integration is pretty good
06:23:17 <Glitchy> cocreature: What plugin(s) should I be using in emacs?
06:23:22 <afidegnum> is there something better?
06:23:25 <stevenxl> Hello folks. I'm trying to be more strict in my usage of terms. I believe that it is a huge benefit in helping me learn. I have the following data declaration: data User = UnregisteredUser | RegisteredUser Username AccountNumber. I know that Username and AccountNumber are both types, and that data constructors such as UnregisteredUser are functions. It is
06:23:26 <stevenxl> proper to say: UnregistredUser is a data constructor that takes no arguments, while RegisteredUser is a data constructor that must be applied to values of type Username and AccountNumber?
06:23:42 <afidegnum> yes, Glitchy emacs plugins are also important
06:24:01 <Glitchy> afidegnum: Yeah, I already use emacs for ... well pretty much as an OS >_>
06:24:12 <Glitchy> What packages should I be installing for Haskell?
06:24:26 <implementation_> haskell-mode pretty much offers everything you need...
06:26:06 <Glitchy> implementation_: Thanks, anything like flycheck?
06:26:34 <implementation_> https://wiki.haskell.org/Emacs also lists scion and ghc-mod
06:26:53 <implementation_> but I don't know either of them
06:28:58 <amx> I've been told scion is dead
06:29:18 <sbrg> I am implementing a BST structure that is self-balancing. The paper with the original implementation naturally assumes mutability and uses pointers heavily. Thankfully, most of the algorithms are pretty simple to implement equivalently in Haskell. The insert operation in the paper works like the normal insert operation for BSTs, except that a stack of parent pointers is maintained. When an element is inserted, the parents are traversed
06:29:18 <sbrg> until an ancestor node is found that is unbalanced, at which point we balance that subtree. Currently, I am doing this in the same way(keeping a stack of parents) by tying the knot, as is shown here http://lpaste.net/284925. In the paper's implementation, the stack uses O(log height) space, and I am trying to argue that I am doing the same in Haskell. However, since I'm obviously not using actual pointers, I am in reality maintaining a
06:29:18 <sbrg> stack of the entire parent subtrees. But since I'm tying the knot, I'm unsure whether I can argue that internally, the list of parent subtrees is actually just a list of thunks that "point" into the original tree, until I force them. Does that make any sense, and is that something I can argue at all? It sounds pretty far-fetched now that I explain it, really.   
06:29:25 <sbrg> <.< that was longer than it looked.
06:29:27 <implementation_> last change in the repo is 4 years ago
06:30:20 <implementation_> but ghc-mod seems to be actively maintained
06:32:56 <Jenaf> and another sin:  fromMaybe (error "helpfull message") --snip--
06:34:29 <younder> A tree is NOT self balancing!
06:34:54 <magneticduck1> Jenaf: http://hayoo.fh-wedel.de/?query=Maybe+a+-%3E+a http://hayoo.fh-wedel.de/?query=String+-%3E+Maybe+a+-%3E+a
06:36:31 * ski . o O ( "If a tree falls in a forest, .. was it unbalanced ?" )
06:36:34 <magneticduck1> @type fromMaybe . error -- also see this, Jenaf
06:36:36 <lambdabot> [Char] -> Maybe a -> a
06:36:45 <younder> Random walk will inevitably create bias
06:38:13 <younder> sbrg, You need to allow for HUMAN intervention.
06:38:21 <sbrg> younder: hm? I am implementing a tree that is self-balancing. I am not saying that all tree datastructures in general are self-balancing. 
06:38:40 <younder> sbrg, sometimes things don't go so good
06:39:00 <sbrg> I have no idea what you mean. 
06:39:37 <ski> magneticduck1 : "have we been conclusively convinced that seq is semantically ugly?" -- it breaks extensionality
06:39:55 <younder> ski, it is a nesessity
06:40:07 <younder> ugly or not
06:40:11 <pgiarrusso_> sbrg: which algorithm did you use? Splay trees, red-black trees, finger trees
06:40:18 <ski> younder : hard to say
06:40:21 <sbrg> pgiarrusso_: I am implementing scapegoat trees
06:40:30 <younder> pgiarrusso_, He has a RB tree
06:41:01 <sbrg> which achieves amortized O(log n) deletion and insertion
06:41:28 <younder> sbrg, all trees do
06:41:50 <pgiarrusso_> younder: naive binary search trees don't
06:42:12 <divVerent> nobody[tm] uses them :)
06:42:52 <younder> sbrg hash tables thhough not easelli paralelled are prefered
06:43:28 <younder> Thogh i see the occasional A* or B*
06:44:06 <Jenaf> what is the most common way to get random numbers in haskell? (excplicitely I want some [[Bool]] with length = 9*9 for testing)
06:44:22 <Jenaf> I don't need any reliable randomness just some gibbersih for testing
06:44:56 <pgiarrusso_> Jenaf isn't it System.Random?
06:44:56 <sbrg> younder: This is for a course where the assignment is to implement scapegoat trees. so the choice of datastructure is not up to me. 
06:45:02 <Jenaf> or 9 random subsets of [1..9]
06:45:12 <younder> https://www.schoolofhaskell.com/school/starting-with-haskell/libraries-and-frameworks/randoms
06:45:29 <Jenaf> thanks at younder
06:45:38 <pgiarrusso_> sbrg, the statement that hash tables are preferred is contentious
06:45:41 <ertes> Jenaf: in 9/10 times i use the mwc-random library
06:46:09 <Jenaf> I just need something quick and dirty, it's only for testing a part of the thing I write. Nothing that will end up beeing really used
06:46:24 <divVerent> Why do people implement RNGs nowadays anyway...
06:46:29 <divVerent> every modern OS has a /dev/urandom equivalent
06:46:43 <younder> Jenaf, We call them lists
06:46:48 <sbrg> pgiarrusso_: I agree. saying that any datastructure is preferred over another makes no sense in the general case since it obviously depends on what you're doing and what properties you want.  
06:46:58 <ertes> divVerent: because /dev/urandom is slow and requires reading from a file handle, whereas a PRNG can be a simple pure algorithm
06:47:17 <divVerent> ertes: it's typically relatively low quality randomness for some applications
06:47:27 <pgiarrusso_> divVerent: ertes is right, urandom is stronger and slower than needed in many cases
06:47:28 <younder> As an old lisper I can tell you the are all JSON. All powerfull and all PROTOTYPE
06:47:37 <divVerent> shouldn't the "default" RNG be a cryptographic one, and you can optionally pick a repeatable or faster one?
06:47:50 <divVerent> as in, secure by default
06:47:50 <Jenaf> younder: in my little world a Set is a List without repetitions; so for all sets s nub s==s
06:47:56 <Glitchy> divVerent: It depends on your use case
06:48:02 <Jenaf> but thats my own little world ^.^
06:48:08 <divVerent> sure it depends on the use case
06:48:10 <ski> > (replicateM 3 . replicateM 3) (state random) `evalState` mkStdGen 1234 :: [[Bool]]  -- Jenaf ?
06:48:12 <ertes> divVerent: i'd love it to be that easy =)
06:48:13 <lambdabot>  [[True,True,True],[False,True,False],[True,True,True]]
06:48:18 <Glitchy> Most operations where you need random data, you don't need cryptographically strong random data.
06:48:23 <divVerent> my point is, shouldn't it be this way round "default is secure, if it's too slow for you, pick somethingn else"
06:48:25 <younder> Jenaf, But In a computer a lsit is less work than a set
06:48:30 <younder> list
06:48:32 <divVerent> because many people THINK they don't need a crypto RNG
06:48:37 <ertes> divVerent: in general i agree…  when in doubt use /dev/urandom
06:48:40 <divVerent> only to find out much later that they did need one
06:48:47 <ertes> but it's not exactly *easy* to use it
06:48:58 <Jenaf> younder: you can have some operations on lists wich preserve the set property
06:48:59 <divVerent> that's my point - this one should be the *easiest* to use
06:49:04 <divVerent> (CryptGenRandom on Windows, BTW)
06:49:21 <pgiarrusso_> divVerent: what's a use case when you need urandom without realizing?
06:49:23 <divVerent> http://hackage.haskell.org/package/random-fu-0.0.1.1/docs/Data-Random-Source-DevRandom.html e.g. I found this
06:49:34 <divVerent> pgiarrusso_: rate limiting/dropping, for example
06:49:37 <pgiarrusso_> divVerent: one where you're not reimplementing crypto yourself
06:49:40 <Jenaf> divVerent: I'm very very sure that i don't need crypto randomness
06:49:48 <divVerent> I remember a case where an attacker being able to predict the pattern may exceed the limit
06:49:48 <knupfer> divVerent: Giving a pure rng a seed is a huge plus for testing
06:49:49 <Glitchy> divVerent: I would say the 'default' should be for the developer to understand their use case and pick tooling accordingly. However we all know this isn't normal. :P
06:50:10 <divVerent> knupfer: that is true, of course... sort of
06:50:18 <divVerent> I'm also one of those people who disagree with repeatable RNGs for testing
06:50:29 <divVerent> as that tends to lead to tests that ONLY work with one specific seed
06:50:33 <pgiarrusso_> divVerent: OK, that's an interesting use case
06:50:35 <divVerent> and if anyone changes the RNG algorithm, lots of tests break
06:50:42 <Glitchy> divVerent: How do you test when you can't guarantee the outcome?
06:50:49 <divVerent> do math first
06:50:56 <divVerent> and build your test so it only fails at a chance of 10^-40
06:51:01 * ski . o O ( "test the distribution ?" )
06:51:06 <divVerent> exactly
06:51:08 <knupfer> if you test by properties, that shouldn't break if you use other seeds
06:51:20 <ertes> Jenaf: to answer your question: the good old random library could be classified as "quick 'n' dirty"
06:51:25 <pgiarrusso_> divVerent: that's not the way they're typically used thoughI need a seed printout to reproduce a detected failure
06:51:25 <divVerent> the only tests I ever wrote that NEEDED randomness were tests that do test the distribution
06:51:38 <pgiarrusso_> divVerent: quick check?
06:51:41 <divVerent> predecessors set the iterations to 1000, set some kind of thresholds (like 200-300)
06:51:45 <ertes> > randomRs (0, 9) (mkStdGen 0)
06:51:48 <lambdabot>  [3,3,3,8,0,7,1,1,1,6,3,0,2,0,4,5,0,1,5,2,2,6,0,5,6,9,0,9,1,0,7,2,3,4,0,0,0,8...
06:51:50 <divVerent> and I then noticed later that only few seeds meet that
06:52:00 <divVerent> pgiarrusso_: QC is one of the few examples that justify a repeatable RNG
06:52:05 <divVerent> although... no, not quite
06:52:11 <divVerent> if your tests only pass QC with a specific se4ed
06:52:14 <divVerent> then your code is broken
06:52:23 <ertes> Jenaf: but if you're using any of the *IO functions, you might as well pick a faster/better library like mwc-random
06:52:36 <pgiarrusso_> divVerent: again, not a use case I've ever seen except as a strawman
06:52:40 <divVerent> but QC is a good use case where one needs a FAST RNG and doesn't care much about its randomness
06:53:13 <divVerent> pgiarrusso_ "testing the distribution" is quite common where I work
06:53:23 <divVerent> e.g. when code is expected to pick one of two choices uniformly
06:53:38 <divVerent> we do tend to have tests that run this like 1000 times and check if the first choice is picked e.g. 400..600 times
06:53:39 <pgiarrusso_> again, the only use case I mentioned is "printing random seed to regenerate a failed test case and test a fix"
06:53:47 <divVerent> of course, anyone except me just runs this with a single predefiend seed...
06:53:59 <divVerent> I seem to be the only one who makes these tests work for "virtually any" seed by doing the math first
06:54:05 <divVerent> (and changing parameters as needed)
06:54:07 <Glitchy> divVerent: I tend to run it with a few seeds but yes. :)
06:54:16 * ertes has never done repeatable testing
06:54:23 <divVerent> so these kinds of tests then fail when someone in a totally different team decides to change the RNG
06:54:24 <Jenaf> I'm not doing real stuff here; just hcking together a sudoku solver for my own pleasure
06:54:36 <knupfer> divVerent: If you proof it by math, you obviously don't need the test.
06:54:36 <Jenaf> and I jsut want to see if my Bool squares get sorted correctly.
06:54:37 <pgiarrusso_> divVerent: I don't know your organization, I'm sampling over blog posts/papers about quickcheck
06:54:49 <divVerent> knupfer: I do need it, tests are there to detect accidental regressions :)
06:54:56 <divVerent> I can sure prove I get the distribution I want with CURRENT code
06:55:24 <pgiarrusso_> Jenaf: don't worry about us too much, we diverged into a tangent, not so much about what you should do
06:55:47 <divVerent> but anyway, back to the bools :)
06:55:49 <ski> Jenaf : did you see the `replicateM' and the `randomRs' examples ?
06:55:56 <divVerent> if all you need is 9x9 of them, System.Random seems good enough
06:56:01 <Jenaf> pgiarrusso: so you are converging to a point in projective space :-P
06:56:11 <divVerent> Jenaf: :)
06:56:37 <Jenaf> ski: yes I did
06:56:43 <Jenaf> I jsut have to figure out what to import
06:56:53 <ertes> Jenaf: those are from the 'random' library
06:57:03 <ertes> Jenaf: https://hackage.haskell.org/package/random
06:58:08 <joe9> any recommendations for a simple "pure(not IO)" bytestring parser
06:58:11 <ski> Jenaf : unless you want to (re)generate with a fixed seed, you shouldn't use `mkStdGen', though, instead `newStdGen'
06:58:25 <ertes> joe9: any specific format?
06:59:01 <ski> (but we can't show uses of that, in lambdabot)
07:03:23 * hackagebot ekg-prometheus-adapter 0.1.0.2 - Easily expose your EKG metrics to Prometheus  https://hackage.haskell.org/package/ekg-prometheus-adapter-0.1.0.2 (AlfredoDiNapoli)
07:03:25 * hackagebot ekg-prometheus-adapter 0.1.0.3 - Easily expose your EKG metrics to Prometheus  https://hackage.haskell.org/package/ekg-prometheus-adapter-0.1.0.3 (AlfredoDiNapoli)
07:15:47 <kamisama> Hello?
07:17:20 <ski> hello kamisama
07:17:45 <kamisama> Can you tell me whats this group about??? Myfriend gave me this
07:19:08 <ski> this is an IRC channel, for discussion of the programming language Haskell, and related topics
07:19:31 <ski> kamisama, are you interested in programming ?
07:19:55 <kamisama> ski : Yep
07:20:00 <padre_angolano> no, this is a usenet group
07:20:39 <kamisama> usenet or programmer?
07:21:09 * ski passes padre_angolano through a type-checker <http://www.lisperati.com/landoflisp/panel60.html> ;)
07:21:37 <ski> <------- [Usenet is over there]
07:22:25 <ski> kamisama : have you tried any programming yet ?
07:22:57 <ski> have you learnt something about some programming language ?
07:23:26 <ski> if you're interested in learning Haskell, have you found some tutorial or introduction text, to help with learning ?
07:23:51 <kamisama> ski : Only C ,C++,Python so far
07:23:58 <ski> ok
07:24:02 <ertes> it's raining type errors
07:25:09 <ski> if you decide to learn functional programming (as in Haskell, e.g.. or perhaps one of Scheme,Erlang,SML,OCaml), then you should be prepared for it being quite different from such imperative programming languages as you mentioned (C,C++,Python)
07:26:16 <Tazmain> Hi all, new to haskell, just wondering what real world applications have been done in haskell. I know the bot in C++ is done in haskell but that is about it 
07:26:44 <kamisama> Same question as Tazmain
07:27:05 <Tazmain>  ##c++-basic  *
07:27:44 <sbrg> Tazmain: Lots of stuff. Facebook's spam system is written in Haskell 
07:28:02 <sbrg> that's probably the best example we have of something massive written in Haskell
07:28:34 <Tazmain> facebook's spam system? I didn't know it has one, for what ?
07:28:54 <pmade> Tazmain: comments and posts.
07:28:59 <Tazmain> ooh 
07:29:26 <pmade> Also, search github and your favorite www search engine.  Tons of info out there on this subject. (i.e. what's written in Haskell)
07:31:25 <byorgey> Tazmain: for generating spam of course ;-)
07:31:48 <ski> pandoc
07:31:54 <Tazmain> byorgey, :p 
07:32:11 <jophish> Tazmain: there are several companies using haskell now. The company I work for uses haskell top-to-bottom for writing computer vision algorithms for autonomous vehicles 
07:32:26 <Tazmain> jophish, is that really wise? 
07:32:35 <kamisama> So its basically for Internet/browser focused???
07:32:45 <ab9rf> why would that be unwise?
07:32:50 <ski> kamisama, here's a link to learning material :
07:32:52 <ski> @where CIS194
07:32:52 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
07:33:03 <ski> if you want a textbook, then perhaps
07:33:05 <Tazmain> well actually besides being functional what does haskell offer? Does it offer type safety or won't cause memory leaks ?
07:33:10 <ski> @where haskellbook
07:33:11 <lambdabot> http://haskellbook.com
07:33:45 <Tazmain> Does haskell support arm? does it run native or need a VM. How is its performance compared to C ? 
07:33:51 <ski> Tazmain : type safety, and also type *expressivity*
07:34:11 <Tazmain> Is it easier to optimize haskell or C ?
07:34:25 <jophish> Tazmain: Overall, it's much easier to write correct software quickly in Haskell then in any other language
07:34:35 <ab9rf> Tazmain: there are back ends to compile haskell to a number of different architectures
07:34:50 <ski> it's easier for the compiler to employ higher-level optimizations
07:35:21 <ski> there is automatic memory management in implementations
07:35:36 <kamisama> Is there any channel for c programming?
07:35:41 <ski> ##c
07:35:42 <jophish> kamisama: ##C
07:35:44 <Clint> Tazmain: native code through LLVM
07:35:57 <ab9rf> if your architecture is suppored by LLVM yuo can compile haskell to it
07:35:58 <jophish> And native code via C--
07:36:04 <ski> there can still be "leaks" in the sense of you keeping hold of a reference to an old value, which otherwise would have been GCed
07:36:20 <kamisama> thanks , jophish
07:36:50 <ab9rf> you can definitely use memory stupidly
07:37:48 <haskell298> Hello, I want to see if in a list i have exactly three odd numbers.How do I do that?
07:40:22 <ski> haskell298 : remove all non-odd numbers first ?
07:40:26 <ab9rf> (3 ==) . length . filter ((1 ==) . (`mod` 2))
07:40:47 * ab9rf runs awy
07:40:56 <ab9rf> you can't use that unless you understand it
07:41:11 <ski> haskell298 : three *distinct* odd numbers, or just any three odd numbers (possibly repeating) ?
07:41:22 <jophish> :t odd
07:41:24 <lambdabot> Integral a => a -> Bool
07:41:25 <jophish> ab9rf: ^
07:41:34 <ab9rf> jophish: feh, forgot that existed.
07:41:40 <ab9rf> well, that makes the filter easer
07:42:08 <jophish> there's no countElemBy on hackage
07:42:28 <ertes> ab9rf: if you add a (take 3) somewhere and use 'odd' or 'even', that solution isn't actually too bad
07:43:35 <ab9rf> ertes: it's not ideal, in part because it's bottom on infinite lists that have 4 or more odd numbers, when it could terminate in such cases
07:43:55 <ertes> uhm…  actually you need a (take 4)
07:44:01 <ab9rf> yaeh, take 3 doesn't work, take 4 does
07:44:10 <ertes> :t (3 ==) . length . take 4 . filter odd
07:44:12 <lambdabot> Integral a => [a] -> Bool
07:46:08 <ab9rf> still bottoms on [1,3,5]++repeat 0
07:46:17 <ab9rf> but that's unavoidable
07:46:36 <Tazmain> oh I have one question , can haskell do networking? And if so can it do packet crafting? Like pcap or so to build up a packet from scratch? Or just work on the ethernet layer ?
07:46:45 <ab9rf> Tazmain: yes, you can do network IO in haskell
07:46:53 <ertes> well, the answer *is* bottom in that case
07:46:58 <ab9rf> ertes: yes
07:47:21 <ab9rf> ertes: you have ot use higher-level reasoning to determine that that list actually does contain only three odd numbers
07:47:21 <ertes> Tazmain: there are pcap bindings somewhere on hackage
07:47:43 <Tazmain> ertes, well I don't mean to use pcap I just meant like 
07:47:51 <ertes> Tazmain: here they are, but you may need to update them, because last release was in 2012: https://hackage.haskell.org/package/pcap
07:47:54 <ab9rf> Tazmain: GHC code can call arbitrary C libraries through the FFI
07:49:10 <ab9rf> you can open a raw socket with Network.Socket and inject arbitrary packets into the routing stack that way (provided your OS allows this)
07:49:57 <Tazmain> ab9rf, ah but you can't take control like pcap ? 
07:50:05 <ab9rf> Tazmain: you can use pcap
07:50:10 <ab9rf> Tazmain: why reinvent the wheel?
07:50:14 <ertes> Tazmain: what's the application?  this is all very vague
07:50:48 <ab9rf> Tazmain: haskell is a fully-functional general purpose programming language. if you can do it in any other language, you can do it in haskell.
07:52:53 <c_wraith> Haskell also has a full FFI.  If there's a C library for it, you can call it.
07:53:25 <c_wraith> (Though making it *pleasant* to call can require some thought in the interface)
07:53:26 <ab9rf> if i wanted to do "packet crafting" in a haskell app, i'd probably just use the FFI with libpcap, since libpcap already exists and works fairly well
07:54:09 <c_wraith> I think there are already bindings to it, too
07:54:31 <ab9rf> c_wraith: ertes found them but they are four years old so they'd probably need some love to get to work
07:55:21 <c_wraith> It's a bos library.  If you could find and poke him, he'd probably assist.  But he's hard to find these days.
07:55:36 <ertes> this question is so vague that any answer is as good as any other…  for example "packet crafting" could mean that they really want something like the 'ip' or 'network-house' package
07:56:35 <c_wraith> Then again, back when he and I worked in the same city, I ran into him on the street while getting lunch once.  I tried to convince him something in bytestring was too strict, but he was a tough sell on that topic.
07:57:51 <c_wraith> It's hard to get some folks to admit "too strict" both exists and is quite common in practice.
07:59:16 <Tazmain> ertes, I am busy learning networking, So I want to build from the group up starting by building my own packets 
07:59:30 <Tazmain> please tell me haskells network guide is better than Bjee's 
08:00:05 <ab9rf> i have no idea who bjee is
08:00:56 <nitrix> There seems to be a youtube video. Is it him https://www.youtube.com/watch?v=HB2HhHL5ygY ?
08:01:08 <ab9rf> also, what do you mean by "learning networking"? i've been a network engineer for 15 years and i can count the number of times i've had to "build my own packets" on both hands
08:01:47 <ertes> Tazmain: it highly depends on what level you're learning networking…  if your goal is to write a web application, then building IP/ethernet packets is hugely irrelevant
08:02:04 <ertes> Tazmain: if your goal is to craft your own TUN/TAP VPN solution, then it becomes relevant
08:02:12 <Tazmain> ab9rf, I started with the theory but I want to know how OS does it 
08:02:29 <ertes> Tazmain: oh, that's easy: the OS does it horribly
08:02:33 <ab9rf> hehe
08:02:39 <Tazmain> lol :p 
08:02:52 <ertes> the sad part is: i'm not joking
08:02:58 <Tazmain> but yeah tor as well 
08:03:04 <ab9rf> yeah, most IP stacks are dodgy as hell
08:03:25 * hackagebot jvm 0.1.1 - Call JVM methods from Haskell.  https://hackage.haskell.org/package/jvm-0.1.1 (MathieuBoespflug)
08:03:27 * hackagebot cabal2nix 2.0.3 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.0.3 (PeterSimons)
08:03:29 <Tazmain> ertes, no I know, there is much not documented. And each os does it different, hench the OS fingerprinting to kno whow to talk to it 
08:04:10 <ertes> it's not that, but we're getting on a tangent
08:04:24 <ab9rf> yeah, this is definitely far afield of #haskell
08:04:28 <ertes> so…  what kind of application do you want to write?  in other words: what are you learning networking *for*?
08:04:56 <ertes> is it just curiosity?
08:05:16 <Tazmain> ertes, curiosity . And embedded. I would like to use my ESP 8266 to talk to my pc using just the MAC address and not IP 
08:05:50 <ertes> well, haskell isn't really suitable for embedded stuff, except perhaps as a code generator like with the atom library
08:06:31 <ab9rf> haskell runtimes tend to be memory-piggy and don't do well in embedded contexts
08:06:37 <Tazmain> memory hog , why ?
08:06:59 <ab9rf> mainly the way lazy evaluation tends to be implemented
08:07:08 <Tazmain> ah okay 
08:07:20 <ab9rf> garbage collected thunks
08:08:02 <c_wraith> it also leans on the theorem that garbage collection is relative to (used memory/available memory).  
08:08:10 <jophish> Tazmain: ertes mentioned atom, a language embedded in haskell which can be used to generate C code
08:08:15 <c_wraith> The more memory is available, the less time is spent in garbage collection
08:08:25 <jophish> there are also the ivory and ion packages
08:08:37 <ertes> it's not really a memory hog, but there is a code size issue, and the RTS is not optional…  also i'm not sure how smoothly code generation for architectures other than x86 goes
08:08:42 <jophish> They're not the most beginner friendly packages to use though
08:08:54 <ab9rf> heh
08:09:00 <c_wraith> ivory is the one out of galois, right?
08:09:06 <jophish> c_wraith: yeah
08:09:08 <jophish> hodapp: ^
08:09:08 <c_wraith> Is it easier to use than cryptol?
08:09:11 <Tazmain> and how does it perform for large scale apps ? 
08:09:23 * hodapp peeks in
08:09:33 <ertes> Tazmain: very well…  i'd say that's haskell's main strength
08:09:50 <jophish> hodapp: Tazmain 
08:09:59 <Tazmain> oooh okay so it will be worth while to learn, friend started to learn it, and now it has me very curious 
08:10:02 <jophish> 's interested in networking low level stuff
08:10:06 <hodapp> c_wraith: I haven't used Cryptol. One thing is that Ivory in an EDSL, whereas Cryptol is a language unto itself.
08:10:27 <EvanR> web apps generally being horribly inefficient snyway haskell tech blows them out of the water there, for performance at least
08:10:33 <hodapp> Tazmain: I had started at making Ivory bindings for ESP8266, actually, but that's been on hold awhile
08:10:38 <ski> Tazmain : have you learned any other functional programming language ?
08:10:48 <Tazmain> ski, nope. 
08:10:53 <c_wraith> Hmm.  I haven't used cryptol, either.  I was thinking about a former coworker's remarks on *developing* it, where they had a policy of not writing top-level type signatures because the constraints usually would have been 3 lines by themselves.
08:11:08 <ski> then it will probably be worthwhile to learn, for that reason alone
08:11:28 <Tazmain> my languages have been Java, C++, C# ,delphi, python, C 
08:11:36 <Tazmain> ski, yeah thought about 
08:11:50 <c_wraith> Hmm.   Do type holes cover the "I don't want to list my billions of constraints" case?
08:11:55 <ski> (the great static type system is also nice to learn)
08:11:56 <hodapp> Tazmain: The deal with Ivory is that it, being embedded in Haskell, it assumes some existing fluency in Haskell.
08:12:00 * jophish always chuckles a little at 'coworker' in #haskell
08:12:19 <ab9rf> heh
08:12:32 <glguy> c_wraith: They can when combined with -XPartialTypeSignatures
08:12:34 <Tazmain> also curious about hacking, but that is a different story :p 
08:12:36 <hodapp> Tazmain: It has some documentation, but not a lot. Atom is in a similar boat (however, Atom is a bit more constrained of a library, and no longer really updated).
08:12:40 <ab9rf> i've always had the urge to name a monad 'ffee' so its comonad would be 'coffee'
08:12:51 <Tazmain> hodapp, ah I see 
08:13:02 <Tazmain> hodapp, I will look up ivory 
08:13:07 <hodapp> Tazmain: but go into #haskell-embedded if you want
08:13:14 <hodapp> shapr and Chobbes and I started a blog on some of this work
08:13:18 <hodapp> and that IRC channel
08:13:34 <c_wraith> ab9rf: you aren't satisfied by a nice cup of cofree?
08:13:46 <jophish> ab9rf: I want to write the 'coconut monad', and the 'cococonut comonad'
08:13:55 <ab9rf> c_wraith: not exactly the same, but it is close.
08:14:09 <EvanR> the nut monad
08:14:15 <jophish> :D
08:14:16 <Tazmain> sweet 64bit windows installer yay ! 
08:15:06 <wz1000> Is there any way to compose a [* -> Constraint] into a (* -> Constraint)? Example: Compose [Num, Ord] a = (Num a, Ord a)
08:15:21 <EvanR> its the free food in the category of gilligans island
08:15:27 <jophish> "<jle`> coconuts are just nuts, aren't they"
08:15:31 <c_wraith> what's ghc's flag to disable a specific warning?
08:15:34 <byorgey> c_wraith: most definitely (re: type holes).  As an example, see https://github.com/diagrams/diagrams-doc/blob/master/doc/manual.rst#polymorphic-diagrams-and-partialtypesignatures
08:15:52 <glguy> c_wraith: It's the flag for the warning with a no- added, you can search the flags with : ghc --show-options
08:16:48 <c_wraith> glguy: ah.  the "no" goes between W and the name of the warning.  That's the part I was missing.
08:17:07 <jophish> EvanR: hahaha
08:17:09 <ski> wz1000 : i suppoe you could define a `Sequence' like that ..
08:17:57 <wz1000> ski: How? I've been trying for the last 15 minutes and running into hurdles because you can't partially apply types/type families
08:18:06 <ski> @remember jle` coconuts are just nuts, aren't they
08:18:06 <lambdabot> Done.
08:18:11 <wz1000> s/types/type synonyms/
08:19:04 <glguy> wz1000: https://github.com/glguy/operations/blob/master/src/TypeListOps.hs#L9-L11
08:19:26 <tabaqui> i have type Data Foo = Foo1 Int | Foo2 Char
08:19:39 <tabaqui> and function f :: Foo -> smth
08:19:48 <tabaqui> how can i use guard inside it?
08:19:54 <tabaqui> i want f x 
08:20:04 <tabaqui>  | x == Foo1 = do smth
08:20:10 <tabaqui>  | x == Foo2 = do smth
08:20:23 <glguy> tabaqui: f Foo1{} = ....; f Foo2{} = ...
08:21:05 <c_wraith> byorgey: I really need to learn diagrams some day.  Out of curiosity, does it support things like intersecting shapes?
08:21:08 <tabaqui> glguy: it's pattern matching? i cannot use guard here?
08:21:23 <byorgey> c_wraith: yes, we have boolean operations on paths now
08:21:27 <c_wraith> tabaqui: you should only be using guards for things that can't be pattern-matched.
08:21:38 <geekosaur> tabaqui, not against a constrictor like that, that is wht pattern matching is for
08:21:47 <byorgey> c_wraith: well, we will once 1.4 is released, which should be any day now
08:21:49 <glguy> tabaqui: If you want to use a guard you'll need to define functions like `isFoo1' and `isFoo2', which you'll define using pattern matching
08:21:54 <geekosaur> Foo1 by itself is not a value, it is a function and you can't compare functions
08:22:07 <glguy> Foo1 by itself is a value, but not a value of type Foo
08:22:15 <glguy> and not easily compared for equality
08:22:36 <geekosaur> yes, I'm being loose with value (in approximately the same way new users are)
08:22:43 <tabaqui> but i want mix simple pattern matching and predicate for the other argument
08:22:55 <c_wraith> byorgey: ok.  That convinced me.  Time to learn diagrams.  (The lack of intersecting shapes is why I gave up on gloss)
08:22:57 <geekosaur> because "values" are tings you can compare...
08:23:00 <glguy> tabaqui: You can write: f (Foo1 x) | isAwesome x = 
08:23:25 <tabaqui> glguy: carring? hm, looks fine for me, thanks
08:23:42 <glguy> tabaqui: I don’t know what "carring" is.
08:23:51 <tabaqui> carrying?
08:24:05 <tabaqui> i don't know how this word is written
08:24:14 <c_wraith> What does it mean?
08:24:22 <glguy> I don’t know what you’re trying to describe, can you elaborate?
08:24:58 <tabaqui> doesn't matter, abbyy lingvo on another workspace)
08:25:14 <nitrix> A good recommendation is to not attempt to use words you do not fully understand yet; so that your interlocutors aren't confused (:
08:25:17 <ski> wz1000 : `type family Sequence (cs :: [* -> Constraint]) (a :: *) :: Constraint; type instance Sequence '[] a = (); type instance Sequence (c ': cs) a = (c a,Sequence cs a)' seems to work
08:25:36 <tabaqui> interlocutors? ah, i get it)
08:25:41 <wz1000> glguy: ski: Thanks.
08:26:41 <tabaqui> *currying
08:26:42 <ski> > sequence [cos,sin] x
08:26:45 <lambdabot>  [cos x,sin x]
08:27:03 <glguy> tabaqui: No, it doesn’t have to do with currying
08:27:06 <nitrix> tabaqui: I don't know how to answer your "interlocutors?" question. I can summarize it as the people engaged in a conversation.
08:28:09 <nitrix> tabaqui: Currying is transforming a function which accepts multiple arguments into a sequence of functions, with each a single argument.
08:28:58 <tabaqui> nitrix: i have dictionary near at hand, i mean that interlocutors is rare word for me)
08:29:05 <ski> currying is changing from "tupled style" to "curried style"
08:29:28 <ski> @wn interlocutors
08:29:30 <lambdabot> No match for "interlocutors".
08:29:33 <ski> @wn interlocutor
08:29:34 <lambdabot> *** "interlocutor" wn "WordNet (r) 3.0 (2006)"
08:29:35 <lambdabot> interlocutor
08:29:35 <lambdabot>     n 1: the performer in the middle of a minstrel line who engages
08:29:35 <lambdabot>          the others in talk [syn: {interlocutor}, {middleman}]
08:29:35 <lambdabot>     2: a person who takes part in a conversation [syn:
08:29:36 <lambdabot>        {interlocutor}, {conversational partner}]
08:29:49 <glguy> Presumably definition #1 was intended.
08:29:55 * ski nods solemnly
08:30:06 <tabaqui> glguy: in f Foo {} | pred arg2, you've used currying obviously
08:30:16 <glguy> tabaqui: No
08:30:29 * ski would forget about the `{}' version here, presently
08:31:40 <glguy> tabaqui: Focus on this one: f (Foo1 x) | isAwesome x = ...;
08:32:11 <glguy> The version with the Foo1{} pattern was a response to your using == on the data constructors for Foo
08:32:37 <tabaqui> glguy: wait isAwesome x or isAwesome y?
08:32:46 <tabaqui> my function gets two arguments
08:33:14 <glguy> tabaqui: | isAwesome x is a guard, not an additional argument
08:33:39 <glguy> It allows you to branch based on a boolean value
08:34:26 <tabaqui> glguy: ah, didn't know about that syntax, i thought, that it's (f Foo{}) :: Y -> Smth
08:35:07 <tabaqui> so, can i use f Foo{} | isAwesome y = smth?
08:35:24 <glguy> tabaqui: You’d need to bind y somewhere to do that
08:35:31 <tabaqui> yeap, right
08:35:39 <tabaqui> f Foo{} y | isAwesome y = smth?
08:36:22 <tabaqui> hmm, ok, i've realized
08:36:24 <tabaqui> thanks
08:39:24 <mauke> :t let aaa _ [] = []; aaa a ((a -> aa) : (aaa a -> aaaa)) = aa : aaaa in aaa
08:39:26 <lambdabot> (t1 -> t) -> [t1] -> [t]
08:46:53 <glguy> mauke: Those ViewPatterns really clear things up
08:47:07 <Tazmain> Tsk windows smart screen does not like the haskell install 
08:48:30 <Tazmain> wait msys ? 
08:48:33 <ab9rf> i had to change antivirus providers on my windows machiens because the one i had been using did not like cabal
08:48:50 <Tazmain> cabal or cobol ?
08:49:02 <ab9rf> cabal is a package manager for haskell
08:49:07 <Tazmain> ooh 
08:49:15 <Tazmain> wait it has a package manager that is awesome 
08:49:25 <ab9rf> it has two now, cabal and stack
08:49:28 <ab9rf> there may be others
08:49:33 <EvanR> or is it a build system, who knows
08:49:53 <ab9rf> EvanR: probably also a floor topping and a dessert wax, by now
08:50:23 <ab9rf> i suppose ghc-pkg is the package manager
08:50:28 <hvr> Tazmain: http://cabal.readthedocs.io/en/latest/
08:50:50 <ab9rf> at least if you use ghc, which most people do
08:51:12 <EvanR> im not sure if theres anything besides ghc anymore
08:51:25 <hvr> ab9rf: ghc-pkg is the low-level package registry interface as required by the CABAL spec
08:51:28 <Zemyla> We need to develop a new Haskell compiler.
08:51:29 <EvanR> i was surprised to see a student using hugs
08:51:43 <Clint> aren't people still using jhc for something
08:51:46 <ab9rf> i used to use hugs :)
08:51:47 <Tazmain> Zemyla, why ?
08:52:20 <nitrix> Zemyla: That's a big claim. Where does that "need" arise from?
08:52:36 <EvanR> you could argue ghc is getting slower
08:53:44 <Zemyla> Well, there's the fact that ghc is very slow and uses a shitton of memory, and there's also the fact that it could be that a clean implementation might hit upon different techniques that are faster without all the legacy baggage of ghc.
08:53:59 <nitrix> you could argue it'd be better to improve its performance than to rewrite a brand new one (You'd eventually reach the same point where one has to tackle the performance problem, but at the cost of rewriting all the rest).
08:54:03 <EvanR> but a lot of improvements youd like to make by starting over are kind of stopped by having to follow a standard
08:54:26 <EvanR> which is where all these purescripts, etc get their umph from, not following it
08:54:42 <nitrix> Zemyla: What prevents the legacy stuff from being dropped?
08:55:07 <orion> What aspects of the Haskell standard prevent performance improvements from being made to the compiler?
08:55:26 <Zemyla> I'm honestly not sure. I'm just kind of spitballing.
08:55:42 <hodapp> Zemyla: There are other reasonably full-featured Haskell compilers, like UHC, and ones that only support older standards, like Hugs, and very new, experimental ones, like Frege...
08:55:56 <EvanR> wait frege isnt haskell is it
08:55:59 <Zemyla> Okay, I didn't know that there were newer ones.
08:56:03 <EvanR> theres another one which actually is haskell on jvm
08:56:04 <hodapp> Zemyla: but the bigger issue is how much "Haskell code" is pretty much just "GHC code".
08:56:13 <hodapp> EvanR: I'm pretty sure that's Frege
08:56:17 <EvanR> nah
08:56:23 <EvanR> thats a haskell-like
08:56:39 <hodapp> EvanR: he's aiming to make it Haskell-compatible as much as possible, I believe
08:56:49 <hodapp> EvanR: if you know of some other Haskellian-JVM project, I'd like to know
08:56:55 <hodapp> unless it's Scala, in which case just shut up :P
08:57:06 <EvanR> ghcvm ?
08:57:11 <Zemyla> If I were starting a Haskell project from scratch, without worries about compatibility with GHC, one of the things I'd do is have IO be a free monad, as opposed to a state-passing thing.
08:57:35 <hodapp> Zemyla: Newer and older ones exist, yes; JHC/Ajhc is another. Some are a bit defunct.
08:58:14 <Zemyla> Though I'd have to see whether that actually produced better code. :V
08:58:30 <hodapp> Zemyla: first you'd have to see if it builds your code in the first place, since it probably relies on GHC extensions.
08:59:04 <EvanR> example improvement, default enable all teh awesome extensions so you dont have to put them all
08:59:14 <EvanR> suddenly its broken the standard
08:59:48 <hodapp> Zemyla: isn't that aspect of IO just an implementation detail?
08:59:50 <EvanR> so i like the idea of just making a new language instead of trying to redo ghc
09:00:14 <hodapp> EvanR: GO USE IDRIS IF YOU LOVE IT SO MUCH
09:00:25 <Zemyla> hodapp: Yes, but it's an implementation detail a lot of packages seem to rely on.
09:00:33 <EvanR> ive been using idris as far as that is possible, but its not like haskell really
09:00:52 <hodapp> Zemyla: how do you mean?
09:00:52 <EvanR> trying using interfaces seriously and see what happens
09:01:37 <voglerr_> can I define some catch-all instance that is used if there is nothing more specific?
09:01:56 <EvanR> theres overlapping instances
09:02:08 <EvanR> but itll probably blow up in your face
09:02:41 <Zemyla> Well, any package that depends on primitive, for one.
09:03:21 <hodapp> Zemyla: whatever the case, perhaps consider revamping existing compilers and making it possible for packages to not require GHC-isms!
09:03:23 <hodapp> or something.
09:03:27 * hackagebot HarmTrace-Base 1.5.3.1 - Parsing and unambiguously representing musical chords.  https://hackage.haskell.org/package/HarmTrace-Base-1.5.3.1 (BasDeHaas)
09:03:30 <EvanR> Zemyla: when you rewrite ghc, make sure to make IO an abstract type that no one ever finds out the internals of, unlike ghc ;)
09:03:30 <hodapp> I'd do it myself but I know next to nothing about compilers.
09:04:01 <orion> How hard would it be to extend Haskell to support linear types?
09:05:03 <EvanR> there might be techniques in existing ghc-haskell which let you do some stuff that linear types are for
09:05:40 <EvanR> with indexed monads, singletons, general type level shenanigans
09:06:49 <voglerr_> With XFlexibleInstances, I have `instance Show a where show _ = "??"`. But then ghci has a problem resolving show for Int.
09:08:03 <orion> Let's say I have a Haskell crypto library which defines a type representing the crypto state (symmetric key, nonce value, etc). I have a function "encrypt" which takes a CryptoState, a cleartext, and returns a new CryptoState (with nonce incremented) and ciphertext.
09:08:04 <voglerr_> I just want ghci to show me the type first before trying to print, which fails for things that don't have instance Show...
09:08:38 <orion> It would be catastrophic to reuse a CryptoState since it contains a nonce. Linear types seem like a solution, but given that Haskell doesn't have that, what alternative is there?
09:08:41 <how2haskell> hello, could anyone help me with understanding something about applicative? i'm new here and to haskell in general..
09:09:56 <ongy> how2haskell: best just ask your question. Someone will answer you
09:12:01 <how2haskell> alright, i'm trying to write the applicative instance for something like: data Two a b = Two a b deriving (Eq, Show). I don't understand why it's Two m f <*> Two m' x = Two (m <> m') (f x) and not Two m f <*> Two m' x = Two (m m') (f x). i'm not sure if the question even makes sense..
09:12:02 <neonfuz> so I'm used to c and...
09:12:09 <neonfuz> I'm wondering how dependencies usually go with types
09:12:28 <ongy> dependencies? on libraries?
09:12:47 <neonfuz> is it common for people to make a separate module that just defines a the type and methods on that type and then import that in everything that uses that type?
09:13:21 <how2haskell> i thought that since m and m' are a part of the structure we don't really touch them, but how come we use fmap? i feel like im missing something
09:13:52 <EvanR> orion: you would have to avoid lambdas at all costs... build your DSL completely in a pointless style
09:14:37 <EvanR> or implement linear types yourself for a new language... assigning anything to a variable potentially allows J. Cryptonoob to use it somewhere twice
09:14:40 <orion> This seems like a pointless use of my time.
09:14:46 <EvanR> yeah
09:14:48 <orion> :)
09:15:14 <EvanR> but DSLs which dont use lambdas are unheard of
09:15:37 <EvanR> concattenative style potentially allows you to avoid bottoms in user code
09:15:48 <amx> neonfuz: I typically have a directory Types/ with, well, types and instances. Then there is modules importing those types and providing functions on them. And other modules import one or the other as needed.
09:15:48 <EvanR> ARENT unheard of... stupid negation
09:15:48 <ski> how2haskell : in your case, `(<*>) :: Two a (b0 -> b1) -> Two a b0 -> Two a b1', since `Two a' is the applicative functor
09:15:52 <orion> What do you mean by DSL? Do you mean the interpreter can't use lambdas?
09:16:05 <ski> how2haskell : derive the types of your four variables, from that ..
09:16:06 <EvanR> not the interpreter, the language
09:16:43 <ski> how2haskell : .. also, `Monoid a' is assumed
09:16:59 <EvanR> orion: example simple language with no lambdas, data Exp = Const Int | Add Exp Exp | Mul Exp Exp
09:17:24 <EvanR> example language with lambdas, any monad
09:17:24 <orion> Note: I currently use a Free Monad to define my language: https://github.com/centromere/cacophony/blob/master/src/Crypto/Noise/Internal/HandshakePattern.hs#L17
09:17:38 <EvanR> right
09:17:54 <nitrix> neonfuz: Sometimes yes, sometimes no. It's more about separation of concern and how you want to compartmentalize these things. Usually, components in an application tend to be fairly self contained.
09:18:42 <nitrix> neonfuz: But the nature of having polymorphic type means that it'll probably appears in usage a lot of places all over the code.
09:19:54 <orion> EvanR: I'm slightly confused... the encrypt and decrypt functions aren't part of the DSL.
09:20:40 <EvanR> well your problem description has already restricted the requirements by defining what function you want
09:20:45 <EvanR> and its type
09:21:03 <EvanR> its a haskell function a particular type which definitely does this, theres no way to stop it from being used wrong
09:21:23 <EvanR> i was thinking about a different way to arrange it
09:22:12 <EvanR> have you looked at cryptol to see what it does?
09:29:23 <Zemyla> Is there any progress in anyone producing a performant pure-Haskell version of Integer?
09:31:18 <orion> EvanR: Never heard of it.
09:32:07 <Zemyla> Because it occurs to me that, if it is implemented in pure Haskell (or Haskell plus some Cmm), then it can do vector fusion-like tricks to improve speed and minimize allocation.
09:33:00 <Zemyla> Like, z = w + shiftR x 2 + 7 * y would allocate one z, and fill it all at once.
09:33:21 <tsahyt> when creating C bindings using FFI, should types implementing storable be restricted to be built from simple types that are also storable?
09:33:49 <Zemyla> tsahyt: I'm pretty sure the only actual restriction is it needs to have a fixed size.
09:33:52 <orion> EvanR: In my case, the end-user never really writes programs in my DSL as a matter of course. I supply a set of 15 standardized programs written in my DSL, and the end user calls functions that pass data to/from the computation.
09:33:54 <tsahyt> for example I have a location struct that represents location in a source file. it contains a bunch of size_t offsets that I would store as a Natural in Haskell
09:34:36 <jophish> tsahyt: have you seen CSize?
09:35:12 <tsahyt> jophish: yes, using that is the most direct translation, but I wonder whether it'd be worth the effort to provide a "nicer" binding
09:35:25 <tsahyt> I've looked at how the sdl2 package does it and all the low level types it provides use CSomething types
09:35:32 <orion> EvanR: Can you think of the simplest language possible which contains lambdas?
09:35:46 <jophish> orion: untyped lambda calculus?
09:35:49 <neonfuz> do import statements come before or after the module statement?
09:36:16 <jophish> tsahyt: Natural or Word might be a little nicer for the end user to use
09:36:24 <jophish> but you should be interfacing with the C using CSize
09:36:25 <ski> neonfuz : after (or more properly, inside)
09:37:38 <tsahyt> jophish: so the nice user-facing interface should be implemented in the high level bindings on top of a low level translation set?
09:37:53 <tsahyt> rather than reusing the types from the low level binding I mean
09:38:47 <jophish> well, I wouldn't want to prescribe that absolutely, but that's often how things are done
09:39:34 <tsahyt> jophish: can you point me to some examples of FFI bindings done right, providing both a low level interface and an idiomatic one? Maybe reading through some of these may help me figure out how I'm going to do this.
09:39:52 <tsahyt> I quite liked how sdl2 does it, but some more things to look at can't hurt
09:40:00 <damian_> hello people, I have one question, I have code that is talking to an HTTP API and I want to unit test it, I am not sure if using typeclasses for that is the best way, specially because I am using monad transformers, should I bother with unit test at all?
09:40:56 <tsahyt> damian_: If you use an mtl style approach you can simply run your code through a testing monad instead of whatever IO based transformer stack you use in production. this should make it relatively easy to write reproducible tests
09:41:01 <jophish> tsahyt: the ftdi package is ok
09:41:29 <tsahyt> jophish: thanks, I'll take a look at it
09:42:36 <damian_> tsahyt: do you have any example so I can take a look?
09:42:42 <Zemyla> tsahyt: Can't you do the same with an extensible effects-type approach?
09:43:12 <jophish> tsahyt: the usb package might be another one to look at
09:43:20 <tsahyt> Zemyla: I think so. it all boils down to using typeclasses to abstract the concrete implementation away so you can swap that out
09:44:05 <tsahyt> damian_: https://lexi-lambda.github.io/blog/2016/10/03/using-types-to-unit-test-in-haskell/ I think this blog post is where I last saw this approach
09:45:02 <damian_> tsahyt: I was reading this post (https://blog.pusher.com/unit-testing-io-in-haskell/) which seems interesting... have you seen it?
09:45:37 <hodapp> So, here's a question related to that: Is there a way to have something in a build that should purposely *not* compile?
09:45:54 <hodapp> basically - as a compile-time unit test that should fail the build if some change destroys some constraint or something
09:46:05 <neonfuz> alright thanks guys
09:50:07 <tsahyt> damian_: as far as I can tell it's not too different really
09:51:11 <fizbin> What's the recommended idiom for waiting until a thread is finished?
09:51:35 <damian_> tsahyt: ok, thanks for the link, will read it carefully
09:52:07 <fizbin> I found some functions to do it in an ancient version of concurrent-extras, but current versions of that library don't have that functionality.
09:52:11 <glguy> fizbin: The async package is the way to handle waiting on threads to finish
09:52:14 <tsahyt> fizbin: you could just use the async library
09:53:10 <fizbin> "just". I was looking at that, but it doesn't seem to fit my usecase nicely.
09:54:27 <glguy> fizbin: If you can’t use the async package you can look inside the async package to see how to do what you want and reimplement it in your code
09:55:24 <GSMiller> I asked a question in #haskell-stack but didn't get any help so maybe someone here can help me. I'm having trouble building a project using stack inside of a docker container without using the stack docker integration. It always fails at the 'cabal copy' step. I should mention this is using Docker for Windows which I'm guessing is the root of my problem. Any help would be appreciated I can reproduce the issue using the default stac
09:55:31 <GSMiller> I can give more details if anyone has any thoughts
09:57:12 <fizbin> glguy: Looking at that appears to pull in stm. Which might be worthwhile, though STM is something I haven't wrapped my head around yet.
09:58:35 <tsahyt> How should I handle a char const * in a Storable instance?
09:59:18 <mauke> depends on how its lifetime is managed, I guess
09:59:23 <mauke> and what it represents
09:59:29 <tsahyt> a filepath
09:59:49 <tsahyt> unfortunately the docs of the library aren't quite explicit on how it is managed
10:03:29 * hackagebot postgresql-orm 0.5.0 - An ORM (Object Relational Mapping) and migrations DSL for PostgreSQL.  https://hackage.haskell.org/package/postgresql-orm-0.5.0 (AmitLevy)
10:03:35 <c_wraith> that's a really bad thing for a library to not be explicit about. 
10:04:02 <tsahyt> c_wraith: maybe I'm missing something in the docs
10:04:18 <c_wraith> not telling the caller if they own it or not is basically saying "you get memory leaks or use after frees if you guess wrong!" 
10:05:28 <c_wraith> a surprisingly common pattern in C is returning a pointer into a local static buffer. it has so many ways to get wrong. of course it's common. 
10:05:41 <tsahyt> c_wraith: my C is very rusty but I believe the fact that it's a const char * implies that it won't be freed, it might as well have been allocated at compile time
10:06:22 <tsahyt> anyhow, I've got another question with regards to low level bindings. I've noticed that sdl2 mostly uses type synonyms rather than newtypes in its low level bindings. why is that?
10:06:54 <c_wraith> because the FFI doesn't see through newtypes, iirc
10:07:29 <tsahyt> ok, I'll just do the same then and introduce better type safety at a higher level
10:07:42 <codedmart> I can't remember the name [IO (Maybe Text)] but I want IO [Maybe Text].
10:08:05 <c_wraith> codedmart, did you ask Google about that type? 
10:08:41 <c_wraith> (the operation you're looking for is sequence.. but it's handy to learn to search by type) 
10:09:00 <codedmart> c_wraith: :) Thanks!
10:09:04 <c_wraith> err, hoogle, not Google. 
10:09:12 <c_wraith> hoogle is the useful one. 
10:12:03 <c_wraith> @hoogle [IO (Maybe Text)] -> IO [Maybe Text] 
10:12:05 <lambdabot> GI.Gtk.Functions init :: (MonadIO m) => Maybe ([Text]) -> m ((Maybe [Text]))
10:12:05 <lambdabot> Web.Routes.Base encodePathInfo :: [Text] -> [(Text, Maybe Text)] -> Text
10:12:05 <lambdabot> GI.GLib.Functions environGetenv :: (MonadIO m) => Maybe ([Text]) -> Text -> m Text
10:12:31 <c_wraith> ok, well, it could use some help in terms of match priority. 
10:12:33 <MarcelineVQ> Too specific I guess :X
10:12:57 <mauke> @hoogle [IO (Maybe a)] -> IO [Maybe a]
10:12:58 <lambdabot> Control.Monad.Loops unfoldM :: Monad m => m (Maybe a) -> m [a]
10:12:58 <lambdabot> Music.Theory.Time.Seq seq_cat_maybes :: [(t, Maybe q)] -> [(t, q)]
10:12:58 <lambdabot> Network.OAuth.OAuth2.Internal transform' :: [(a, Maybe b)] -> [(a, b)]
10:12:59 <c_wraith> it should probably prioritize results from base. 
10:13:30 <ab9rf> heh, music.theory? really?
10:13:38 <ab9rf> not what i'd think of as a high-priority result
10:13:52 <shapr> wait, music theory?
10:14:32 <Hijiri> I wonder if anyone has made a function that sticks coerce in front of all arguments and after the output
10:14:43 <mizu_no_oto_work> I don't think hoogle does well with finding typeclass functions if you give it concrete types
10:14:56 <Hijiri> a function that takes a function and does those things
10:15:12 <ab9rf> shapr: there's a whole category of music-related stuff on hackage, 81 packages
10:15:33 <mizu_no_oto_work> @hoogle [f (g a)] -> f [g a] 
10:15:34 <lambdabot> Music.Theory.Duration.Sequence.Notate all_right :: [Either a b] -> Either a [b]
10:15:34 <lambdabot> Music.Theory.Set.List partitions :: Eq a => [a] -> [[[a]]]
10:15:34 <lambdabot> Text.CSL.Proc.Disamb disambiguate :: (Eq a) => [[a]] -> [[a]]
10:15:49 <c_wraith> mizu_no_oto_work, as far as I know, it will ignore class constraints and return anything that unifies.. it's just a matter of prioritizing results. 
10:16:02 <mizu_no_oto_work> @hoogle f (g a) -> g (f a) 
10:16:02 <younder> hackage is cool. This must be the first functional language with a full set of libraries.
10:16:02 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoerceP :: a wX wY -> a wB wC
10:16:02 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoercePStart :: a wX1 wY -> a wX2 wY
10:16:03 <lambdabot> Darcs.Patch.Witnesses.Unsafe unsafeCoercePEnd :: a wX wY1 -> a wX wY2
10:16:31 <tsahyt> some of the callback functions that this library uses have a void* for user data. How would I deal with this with FFI? Ptr a?
10:16:54 <mizu_no_oto_work> c_wraith: compare https://www.haskell.org/hoogle/?hoogle=%5Bf+%28g+a%29%5D+-%3E+f+%5Bg+a%5D+  with https://www.haskell.org/hoogle/?hoogle=%5BIO+%28Maybe+a%29%5D+-%3E+IO+%5BMaybe+a%5D+
10:17:00 <neonfuz> Hey does anyone here use emacs haskell-interactive?
10:17:12 <younder> neonfuz, I do
10:17:13 <neonfuz> Every time I run main in it and then quit, it kills the ghci process...
10:17:21 <neonfuz> is that normal?
10:17:27 <younder> neonfuz, quit emacs?
10:17:36 <neonfuz> no it just says the process ended and needs to be restarted
10:17:40 <neonfuz> and then I press y and it restarts
10:17:52 <neonfuz> its just irritating because I have to reload the module
10:17:59 <younder> neonfuz, only when i kill the interpreter buufer
10:18:02 <c_wraith> mizu_no_oto_work, hmm. I stand corrected. 
10:18:34 <c_wraith> neonfuz, does main in your program kill itself in a special way? 
10:18:49 <neonfuz> younder: no so I made a program that quits when you feed it an empty line, I feed it an empty line and get "The Haskell process `haskell' has died. Restart? (y, n, l: show process log) y [2 times]"
10:18:59 <neonfuz> c_wraith: no it just ends
10:19:06 <neonfuz> c_wraith: do I need to have something special at the end of main?
10:19:28 <codedmart> c_wraith: I get what you mean.
10:19:29 <codedmart> Thanks!
10:19:32 <younder> On the whole for me the emacs mode works.. I hve other systems like the one in atom, but i prefer emacs
10:19:46 <c_wraith> neonfuz, no, I was just checking for something like "segfaults in native code" :) 
10:20:09 <younder> segfault in haskell?
10:20:27 <c_wraith> Haskell can call arbitrary C
10:20:40 <younder> never heard of such a thing unless you link in C
10:20:54 <c_wraith> or you can more directly break things with unsafeCoerce
10:21:17 <c_wraith> like.. unsafeCoerce () () will usually segfault 
10:21:38 <younder> Takes some effort though.. I am a c++ programmer too.
10:22:10 <younder> There it happens all the time. Though it too has become more reliable over the years
10:22:59 <c_wraith> there are other sufficiently unsafe operations as to cause segfaults in some cases. 
10:23:11 <younder> c++ 11 was actually quite brilliant. wery positivly suprised
10:23:26 <c_wraith> you usually have to make an effort to make them explode, though. 
10:23:44 <c_wraith> FFI bindings can accidentally corrupt memory much more easily. 
10:24:45 <c_wraith> just declare an argument somewhere with the wrong sized type, and you get silent memory corruption. 
10:25:44 <younder> I am writing a new functional language called Formula. You can follow it on github. At the moment there isn't anything there
10:26:32 <younder> The compiler is written in Haskell for now, but it is metacicular, so eventually it will be written in formula
10:27:06 <younder> (like the first GHC was written in ML)
10:30:50 <jophish> younder: link to github?
10:31:03 <younder> Highlights include: math notation, more support for category diagrams, mathematical verification., automatic parallelization
10:31:56 <younder> I've been working on this now for 6 years so wish me luck..
10:32:28 <younder> (YES.. it's that difficult)
10:32:54 <nitrix> We have a language called Haskell written in Haskell :D
10:33:01 <nitrix> It's great.
10:33:39 <younder> Well yes.. This is supposed to be an improvement for the 21'st cenury
10:33:39 <pikajude> GHC is written in Haskell, Haskell is written in English
10:33:41 <c_wraith> we have a compiler called ghc written in ghc's dialect of haskell. 
10:33:41 <pikajude> or in an editor
10:34:38 <younder> Mine uses a blink engine to render math and categry diagrams
10:34:47 <younder> (as in chromium)
10:35:52 <younder> expect steep learning curve awesome power
10:36:04 <ab9rf> can it wash dishes or make the bed?
10:36:13 <younder> ;)
10:36:58 <younder> if you ask it politely
10:38:30 <jay721> roughly 40,000 lines of C code in the GHC RTS
10:38:34 <EvanR> pikajude: if only english could be written in ghc... wed have a full cycle
10:38:55 <pikajude> would have to figure out which monad transformer to use to tell my cat not to pee on the bed
10:38:58 <pikajude> no thanks
10:39:06 <younder> Just wait and see.. You'll love it
10:39:27 <kadoban> I'm sure you could write a type encoding the English language, and some values thereof. If you were, ya know, totally batshit crazy.
10:40:00 <younder> I am totally batshit crazy and I am writing a new language
10:40:08 <ongy> I doubt you could sensibly encode a natural language
10:40:27 <kadoban> You could probably do like the schoolbook definition if you spent a lot of time.
10:40:33 <younder> No I use math as mmy natural language. sort of like haskell
10:40:37 <kadoban> Not sure how close to reality it'd get.
10:41:33 <younder> as you may know haskell is a acknoleged notation for math. 
10:41:46 <tsahyt> Is there some special pointer type for const pointers to enforce constness?
10:41:57 <tsahyt> it seems like I can't find anything
10:42:03 <haskell606> Why haskell is lazy? I am a newbie please explain me with example
10:42:24 <kadoban> haskell606: Because, why evaluate things you may never need?
10:42:50 <Tuplanolla> Here's another perspective, haskell606: Haskell is lazy, because laziness is interesting.
10:42:52 <johnw> haskell606: it was a design choice; exploring the utility of a lazy functional language was one reason that Haskell come into existence in the first place
10:42:54 <haskell606> kadoban can you please explain me with an example?
10:43:22 <jay721> let x = (putStrLn "hello", putStrLn "world")
10:43:24 <jay721> fst x
10:43:25 <jay721> snd x
10:44:01 <younder> Haskell was always ment to be a stopping point aiming for something grater. Since 1977 when Baccus had the first FPL conference. This is a path and you are not at the destination.. YET
10:46:18 <younder> All respect to Simon p. Jones and the awesome job he has done
10:46:33 <maerwald> yeah, it's also unlikely it will become something different, because it's too successful to reinvent itself
10:46:52 <EvanR> ghc continues to evolve
10:47:01 <maerwald> evolve != reinvent
10:47:22 <younder> It is not ONE, there will be many languages that go into the next generation as it was for Haskell
10:47:33 <c_wraith> the fact that ghc plans to add dependent types in 2 to 3 years is bigger than most evolutions. 
10:47:49 <maerwald> younder: yeah and that's fine
10:47:50 <EvanR> press B to stop
10:48:03 <younder> B
10:48:11 <maerwald> most languages that try to evolve too hard end up being something awkward, e.g. C++
10:48:21 <EvanR> ok, ghc-dependent-types has gone back to regular ghc
10:48:26 <younder> I like the new C++
10:48:57 <younder> It is one of the few languages that has actually improved over time
10:48:59 <maerwald> another one is Scala, randomly adding new features without much consideration about the complexity implications
10:49:15 <younder> Java :) that is a sadder story
10:49:17 <maerwald> hope this doesn't happen to GHC, but it might
10:49:26 <maerwald> younder: not really, it hasn't evolved a lot
10:50:47 <younder> auto types are awesome.. haskellish for sure
10:51:08 <EvanR> auto types in C++, now i dont know what any of the classes are anymore...
10:51:25 <ahihi> your editor doesn't tell you?
10:51:30 <EvanR> i guess IDE tells you
10:51:32 <younder> gtkmm is a pleasure to write in. the first C++ win lib I can say that about
10:51:37 <jophish> younder: sadly type inference in C++ is not bidirectional 
10:51:48 <jophish> unless something's changed since I stopped programming in it
10:52:25 <younder> love JSON and the deat of XML (studder and line noise version of Lisp)
10:52:50 <younder> On the whole thisgs are better now than in the 90's
10:55:07 <younder> Next: Computer Vision.. It will change EVERYTING. make robots possible and affordable. Get in while you can
10:55:33 <ski> @quote enterprise.industry
10:55:33 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
10:55:34 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
10:56:27 <younder> take it or leave it, but thats my advice
10:56:32 <sm> I just want to say one word to you. Just one word. 
10:56:55 <sm> Plastics.
10:57:04 <maerwald> amazing :D
10:57:14 <MarcelineVQ> hey... that's 13 words!
10:57:16 <cocreature> ski: yoneda’s lemma is the only way to make applications that are really webscale
10:57:47 <nitrix> sm: This makes me thinks of https://www.ted.com/talks/juan_enriquez_we_can_reprogram_life_how_to_do_it_wisely
10:57:57 <nitrix> sm: It's an amazing talk, deeper than it looks.
10:58:16 <sm> brrr
10:58:23 <younder> On the whole, HAVE FUN, and I hope you love programming as much as I do.
10:58:39 <sm> like we're wise enough to handle all the technology we've already got
10:59:40 <sm> anyway here it is, how I now see younder: https://www.youtube.com/watch?v=Dug-G9xVdVs
11:00:12 <humanoyd> Why does `m` need to be monad for the applicative instance of `ExceptT`? https://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.Except.html#line-183
11:00:22 <humanoyd> Wouldn't something like `m1 <*> m2 = ExceptT $ (<*>) <$> runExceptT m1 <*> runExceptT m2` work?
11:00:55 <younder> sm: whatever
11:01:59 <glguy> humanoyd: No, you need the Applicative isntance to be consistent with the Monad one
11:02:04 <divVerent> younder: XML dead... I'd hope so. Still remembering having to hack/debug Plone's XSLT mess ("You're in a twisted maze of little XSLT templates, all alike")
11:02:23 <sm> younder: aww.. 's funny ! :)
11:03:14 <younder> I'll just ceep on coding. You will like what I do, .. or you wont. Either way I had great joy doing it. And I am happier than you. Why? Because i realize you have to enjoy the path. It is not enough to druel at the destination.
11:03:30 * hackagebot gnss-converters 0.1.17 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.17 (markfine)
11:03:32 * hackagebot wolf 0.2.10 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.10 (markfine)
11:03:34 * hackagebot obd 0.2.0.0 - Communicate to OBD interfaces over ELM327  https://hackage.haskell.org/package/obd-0.2.0.0 (hverr)
11:03:36 * hackagebot obd 0.2.0.1 - Communicate to OBD interfaces over ELM327  https://hackage.haskell.org/package/obd-0.2.0.1 (hverr)
11:04:18 <younder> sorry about the terrible spelling
11:04:35 <sm> younder: no offense intended, just ignore me
11:04:58 <younder> sm: not at all. You amuse me
11:09:50 <younder> By current standards haskell programmers are probably among the best and the brightest, so pick your 'battles' well
11:10:08 <maerwald> er?
11:10:30 <humanoyd> glguy: thanks, did some more searching, apparently I'm not the first one with this issue: https://github.com/ekmett/either/pull/38
11:12:02 <glguy> humanoyd: Yeah, you aren't the first to be confused by that
11:15:20 <younder> Any NSA coders here? I know they love this language. I am also a member of AMS.
11:17:08 <younder> Well you had better no answer that one. :)
11:17:40 <Tuplanolla> No strings attached?
11:18:27 <younder> Wanderbar Bush did do some goog things though including creating the National Science Foundation (NSF) and DARPA
11:18:43 <younder> s(goog/good/
11:19:25 <glguy> younder: The topic of #haskell is the discussion of Haskell programming specifically
11:19:47 <younder> glguy, yes i am digressing. sorry
11:29:34 <karanlearnshaske> hi guys, i am a beginner . i wish to make a simple,fast gui. i should be able to work to make it work on popular operating systems. the gui i make should be fast and code should be easy to read by others. 
11:29:42 <karanlearnshaske> which library will be good
11:29:52 <karanlearnshaske> and does frp offer me any benefits
11:30:16 <karanlearnshaske> please guide as i am searching from yesterday and cant decide
11:30:51 <Skami> Do you want to make a GUI framework or a GUI app
11:31:12 <karanlearnshaske> also is it better to make the gui in c++ and communicate with haskell as the backend 
11:31:16 <karanlearnshaske> gui app
11:31:52 <karanlearnshaske> i love sublime text and am inspired by it- if i can make my app look and feel upto quality of sublime text - i will be happy
11:33:05 <karanlearnshaske> also i do not want to miss any benefits of haskell - if they matter for gui code
11:33:14 <Skami> If you are familiar with gtk, there are haskell bindings.
11:34:01 <karanlearnshaske> if i make gui in haskell and communicate with haskell backend - do i get any advantages
11:34:09 <karanlearnshaske> sorry
11:34:20 <karanlearnshaske> if i make gui in c++ and communicate with haskell
11:34:24 <ab9rf> you get extra haskell karma if you write an entire app in haskell 
11:34:24 <karanlearnshaske> are there any benefits
11:34:42 <ab9rf> that and $5 will get you a cup of coffee
11:34:56 <kadoban> karanlearnshaske: Not really, unless there's no GUI frameworks with haskell bindings that you like.
11:35:09 <karanlearnshaske> i read that sublimetext is made in c++
11:35:24 <ab9rf> the main advantage of writing the entire app in haskell is that you don't have to figure out how to make the FFI work
11:35:51 <younder> karanlearnshaske, http://www.muitovar.com/EddyAhmed/GladeGtk2Hs.html
11:36:06 <karanlearnshaske> fltkhs vs gtk hs - any thoughts
11:36:27 <ab9rf> i think gtk is fugly, but that's just an opinion
11:36:33 <ab9rf> (and i'm entitled: i used to be a gtk developer)
11:39:01 <karanlearnshaske> what do you think about fltk
11:39:16 <ab9rf> i have no experience with it
11:39:19 <ab9rf> so i can't comment
11:40:13 <maerwald> there's no desktop gui framework in haskell that doesn't suck. A few rudimentary and poorly documented FRP approaches maybe, that will require a ton of work if you want to get the full feature-set
11:40:54 <jg_> hi all. I want to learn how to write a type checker. Anyone know of some hands on resources on the topic?
11:41:07 <maerwald> it's basically the same story as if you use any other language like C++ or python: gtk vs qt
11:41:16 <sm> karanlearnshaske: fltkhs isn't the prettiest, but one of the most practical right now
11:41:29 <ab9rf> i've never encountered a gui toolkit that didn't suck in some way or another
11:42:32 <maerwald> ab9rf: imo, the natural language the toolkit was written in is the least painful one to develop a related app
11:43:08 <sm> karanlearnshaske: but ui "up to quality of sublime text" doesn't sound simple. If you want native look and feel one of the qt frameworks may be best
11:43:58 <sm> making a web ui and packaging with electron (like atom) is also a good option
11:46:28 <karanlearnshaske> i am ready to put in the work. not looking for a quick fix. what looks like a good direction to take to make a fast performing gui with haskell
11:47:37 <maerwald> gtk is fast performing
11:48:19 <maerwald> even with huge tree lists it renders pretty quickly
11:48:53 <karanlearnshaske> and no benefits in using c++ and communicating to haskell - is this not a good option at all ?
11:49:04 <younder> http://www.muitovar.com/EddyAhmed/GladeGtk2Hs.html
11:49:07 <karanlearnshaske> like a rest api in web terms
11:49:16 <younder> Modern fortan :)
11:49:19 <karanlearnshaske> thanks a ton for this tutorial
11:49:21 <sm> karanlearnshaske: some people have done that. Soundss more complex, but maybe not if you already know a c++ gui framework
11:49:22 <younder> fortran
11:49:50 <sm> keep in mind your cross-platform and deployment needs also
11:50:09 <sm> how hard can it be for your users to install ?
11:50:14 <sm> etc.
11:50:14 <younder> sm: gnome is cross platform
11:50:26 <Tuplanolla> Can't you use AWT, Swing and SWT with the Java package that was just announced?
11:50:38 <Athas> Is there a way to get 'stack install' to install programs that are not executables in the Cabal sense?
11:50:39 <sm> gtk has been famously hard for haskellers to set up most of the time
11:50:45 <Athas> (Specifically, small wrapper shell scripts.)
11:50:51 <karanlearnshaske> it should be easy and fast install as my users may or may not be technical
11:51:14 <karanlearnshaske> thanks sm for guidance. and thanks younder for tutorial
11:51:15 <younder> sm: admittedly I used C++ for that part
11:51:19 <sm> Tuplanolla: bleeding edge! but maybe, indeed
11:51:33 <koz_> Tuplanolla: Those shouldn't be used anymore, actually - you should have suggested JavaFx. Or Sodium, frankly.
11:51:54 <koz_> (calling out to Java to get an FRP GUI toolkit being heavily ironic aside)
11:52:02 <younder> web perhaps?
11:52:02 <Tuplanolla> I haven't used Java in ages, so I don't even know what those are, koz_.
11:52:18 <Tuplanolla> Which one do I want to read about?
11:52:30 <karanlearnshaske> who wants to work on java puzzlers all the time :)
11:52:32 <younder> They seem cross platform and the marsalling form Haskell is a singe
11:52:37 <koz_> Tuplanolla: JavaFX is the new way to do Java GUIs (new being ~3 years old). Sodium is an FRP library which provides GUI elements as well.
11:52:53 <koz_> s/FRP library/Java FRP library
11:52:57 <younder> F*** java
11:53:04 <koz_> younder: I am very much in agreement.
11:53:26 <ania123> is @ keyword of haskell
11:53:27 <ania123> ?
11:53:49 <Tuplanolla> In pattern context, yes, ania123.
11:53:58 <sm> some version of sodium is is on hackage too
11:54:29 <sm> just the FRP part I guess
11:54:46 <ania123> merge xs@(x:xt) ys@(y:yt)
11:54:54 <ania123> what is a role of @?
11:55:19 <sm> ania123: assigns the name "xs" to what is matched by the following pattern
11:55:26 <ab9rf> ania123: in pattern matching, x@(...) makes x bind to whatever (...) matched
11:55:53 <ania123> ok
11:56:06 <ab9rf> so for xs@(x:xt), if x:xt matches, then xs is bound to (x:xt) 
11:57:20 <sm> let all@(first:rest) = "123" -- all = 123
12:00:10 <Tuplanolla> You can nest them arbitrarily too.
12:00:18 <Tuplanolla> @let f x @ (y : ys @ (z : (u @ v @ w @ zs))) = ()
12:00:21 <lambdabot>  Defined.
12:02:54 <SrPx> It is said that HOAS is fast, but how fast exactly it is? Is it fast enough to replace a compiler for a practical language (when you're not absolutely concerned with speed)? Would such a language be considered an interpreted language?
12:03:19 <koz_> Tuplanolla: Did not know about the arbitrary nesting - will have to remember that!
12:03:33 * hackagebot hjsonpointer 1.0.0.2 - JSON Pointer library  https://hackage.haskell.org/package/hjsonpointer-1.0.0.2 (seagreen)
12:03:42 <peddie> SrPx: http://foswiki.cs.uu.nl/foswiki/pub/USCS/InterestingPapers/AugustsonLambdaCalculus.pdf  see the speed table on page 10 for one comparison
12:03:52 <Spolyk[m]> Hello :) I just would to know if shared screen is possible with Riot :)
12:05:02 <Spolyk[m]> In video calls i mean. It's to find an alternative to hangouts
12:05:49 <SrPx> peddie yea it seems *insanely* fast in comparison. In fact it is so fast I'm curious whether it could replace a compiler altogether when you're writing some non-performance-hungry language
12:05:59 <SrPx> i.e. a comparison with haskell itself would be cool
12:06:04 <OutlawStar> anyone one the in pacfic nw find their internet is half working half not?
12:06:24 * ski recalls an editor nammed peddie
12:06:51 <peddie> ski: no relation (unless someone secretly named it after me?!)
12:07:37 <dolio> HOAS is not very good for a real compiler, because you often want to inspect the syntax in ways that HOAS makes difficult.
12:08:12 <peddie> SrPx: I don't know of any such comparison.  just keep in mind that that paper shows it at its best, where literally everything is a lambda term.
12:08:39 <ski> you can inspect HOAS in lambdaProlog
12:08:58 <dolio> Right, in a language where lambda terms are a data structure, rather than the means of computation.
12:09:19 <SrPx> dolio what do you mean? You can inspect the syntax by quoting, right?
12:09:27 <ski> (also in MetaML, for quoted lambdas)
12:11:23 * ski . o O ( "An Extension to ML to Handle Bound Variables in Data Structures: Preliminary Report" by Dale Miller in 1990-05 at <http://www.lix.polytechnique.fr/~dale/papers/mll.pdf> )
12:11:33 <dolio> HOAS as implemented using the _functions_ in a functional language is bad.
12:11:43 * ski nods
12:11:52 <dolio> Having a type of syntactic lambda terms built into the language is good.
12:11:59 <shapr> Is there some sort of twitter or other feed that links to new nifty algorithms or papers about such?
12:21:09 <johnw> shapr: there's the twitter "papers we love" handle
12:27:51 <shapr> johnw: that's a good point, thanks
12:33:03 <babu> I understand that this is due to floating point arithmetic, but still it would be nice if ghci returned 0.6 for 3.1-2.5 and not 0.6000000000000001.
12:34:07 <peddie> babu: you could use https://hackage.haskell.org/package/numbers-3000.2.0.1  if it's really bothering you ;)
12:34:19 <johnw> yeah, numbers will solve that
12:35:23 <Tuplanolla> Is that release 3000 or year 3000?
12:35:58 <geekosaur> I think that's "package switched from a date to PVP"
12:36:26 <ski> > (showFFloat (Just 3) `flip` "") (3.1 - 2.5)
12:36:29 <lambdabot>  "0.600"
12:36:34 <Tuplanolla> Not a satisfying answer.
12:38:49 <babu> Haskell is so handy as a calculator, so it would have been nice if it worked 'correctly' out of the box.
12:38:57 <ertes> babu: you could use Rational
12:39:08 <ertes> > 3.1 - 2.5 :: Rational
12:39:11 <lambdabot>  3 % 5
12:39:12 <dolio> You're asking for it to work incorrectly, though.
12:39:53 <ertes> alternatively Data.Fixed does decimal arithmetic, so 3.1 is exact
12:40:22 <ertes> > 3.1 - 2.5 :: Milli
12:40:25 <lambdabot>  0.600
12:40:38 <johnw> babu: you could make a pull request for the algorithm used in Float's "show"
12:40:44 <kadoban> babu: It's working the only way the type you're implicitly choosing could work.
12:40:51 <johnw> there are plenty of algorithms out there for better printing of floating point values
12:40:59 <kadoban> Yeah, it could print something different I suppose
12:41:05 <sm> +1!
12:41:07 <dolio> Print the wrong answer?
12:41:31 <ertes> but 0.600…01 *is* the correct answer
12:41:32 <ski> @where floating-point
12:41:33 <lambdabot> "What Every Programmer Should Know About Floating-Point Arithmetic" at <http://floating-point-gui.de/> and "What Every Computer Scientist Should Know About Floating-Point Arithmetic" by David
12:41:33 <lambdabot> Goldberg in 1991 at <http://docs.sun.com/source/806-3568/ncg_goldberg.html> and <http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.102.244>
12:41:40 <sm> er.. damn
12:41:44 <kadoban> dolio: In what circumstances do you think the digits that insignificant are acutally correct and not rounding errors?
12:42:10 <ertes> kadoban: the problem starts with 3.1
12:42:19 <dolio> It's not the printer's job to decide that.
12:42:26 <ertes> there is no floating point number that represents 3.1 exactly
12:42:26 <shapr> dolio: parametric higher order abstract syntax - I'm reading "Functional Programming with Structured Graphs" by Oliveira and Cook
12:42:38 <kadoban> dolio: Why not?
12:42:49 <sm> surely it is the printer's job, or at least the printer in a convenience-oriented REPL
12:42:59 <johnw> babu: see http://www.ryanjuckett.com/programming/printing-floating-point-numbers/
12:43:00 <ertes> > 0.6 :: Double
12:43:03 <lambdabot>  0.6
12:43:05 <sm> like python's
12:43:10 <johnw> Gay's algorithm is quite simple, fast, and would do what you expected
12:43:13 <ertes> > 0.6 :: Float
12:43:15 <lambdabot>  0.6
12:43:23 <babu> FYI, F# interpreter returns 0.6. Scala interpreter returns the same as haskell, namely 0.6000000000000001 !!
12:43:46 <ertes> 0.6000000000000001 is the correct result
12:44:01 <ertes> F# is lying to you
12:44:10 <ertes> (or you're not using floating point)
12:44:51 <dolio> As I recall the algorithm in GHC prints the shortest string that will give you the same Float/Double when you read it back in.
12:45:14 <sm> which is probably not the optimal one for interactive calculations
12:45:34 <dolio> Which is what Show/Read tries to do in general. Print out something that will give you the same value when you put it in your source code or read it back in.
12:45:43 <ertes> Double is not the optimal one for interactive calculations…  if you want *decimal* calculations, use Data.Fixed
12:45:50 <ertes> or Rational
12:45:53 <dolio> > 0.6 == (3.1 - 2.5)
12:45:56 <lambdabot>  False
12:45:58 <thoughtpolice> Maybe not, but it's still the right thing to do. If the REPL prints 0.6, but the actual answer is 0.600000000001, and you can't tell the difference, what happens when you compare them for equality?
12:46:16 <thoughtpolice> Exactly, everything goes out the window. It's better to just "accept it" for what it is, rather than conveniently lie to yourself.
12:46:23 <johnw> thoughtpolice: how I can display the binary form of these Floating point numbers?
12:46:34 <johnw> i'd like to compare the binary fractions
12:46:53 <thoughtpolice> Unsure, TBH! I'm not actually aware of anything in Prelude for that, at least?
12:47:01 <c_wraith> thoughtpolice, maybe what happens is famous CS luminaries come out of the Internet to scold you for using floating point without knowing everything about it? 
12:47:03 <dmj`> isn't there that binary literals extension
12:47:09 <johnw> dolio's right that any show/read should be lossless
12:47:28 <dolio> You could probably set up your repl to default to Rational.
12:47:49 <bitemyapp> c_wraith: hahahahahah
12:47:58 <dolio> Yep, `default (Rational)`.
12:47:59 <bitemyapp> c_wraith: if you have not memorized IEEE-754 you are not worthyyyyyy
12:48:08 <thoughtpolice> c_wraith: Well, maybe that too. SaaS takes on a whole new meaning, there.
12:48:16 <bitemyapp> Sass As A Service
12:48:23 <bitemyapp> Sass on demand
12:50:21 <dmj`> Sassquatch
12:50:58 <babu> I have read the paper (atleast browsed it) and as I mentioned I understand why it happens, and I am not saying it is an error, just that it would be nice it the result was useful then correct to 100 decimal places.
12:51:00 <geekosaur> "sod that" :p
12:54:58 <Tuplanolla> Physicists say that a measurement with an unknown uncertainty is worthless, so it's difficult to distinguish useful from correct, babu.
12:56:16 <ongy> floats and known certainty....
12:57:46 <Tuplanolla> Treating floating-point numbers as if they were analog signals helps attain a peace of mind.
12:58:05 <johnw> Tuplanolla++
12:59:05 <jophish> time to plug exact-real https://hackage.haskell.org/package/exact-real
13:00:12 <Tuplanolla> How is this `Data.CReal` different from `Data.Number.CReal`?
13:00:39 <jophish> Tuplanolla: Data.Number.CReal is broken in a few ways, and is much slower
13:01:04 <dolio> We have a lot of CReal implementations that aren't actually computable reals.
13:02:08 <jophish> dolio: those are the only two exact real arithmetic packages on hackage to my knowledge
13:02:30 <dolio> Two is a lot, I think. :)
13:02:57 <ertes> johnw: see the RealFloat class
13:03:01 <dolio> Since we have 0 that are computable reals.
13:03:17 <ertes> johnw: (regarding how to see the binary form)
13:03:33 * hackagebot hjsonschema 1.2.0.2 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-1.2.0.2 (seagreen)
13:03:35 * hackagebot keysafe 0.20161007 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20161007 (JoeyHess)
13:04:07 <jophish> dolio: both those packages do represent computable reals
13:04:50 <sm> does http://hackage.haskell.org/package/Decimal also do that ?
13:04:51 <ertes> dolio: are they subsets of computable reals, or are they indeed wrong?
13:05:40 <sm> babu: it sounds like your best chance of getting that would be as an option for GHCI
13:06:26 <sm> ghci --I-am-a-human-show-me-the-wrong-numbers-I-prefer
13:07:22 <ertes> and GHCi answers: "that's not my business…  write to the libraries mailing list"
13:08:15 <dolio> jophish, ertes: They're not computable reals, because computable reals are a quotient, and both libraries allow you to distinguish equal computable reals from one another.
13:08:31 <dolio> Because they provide operations like, 'are these two equal up to a given precision.'
13:09:29 <ski> how's that allowing you to distinguish equal computable reals from one another ?
13:09:29 <sm> fine. A new tool, hcalc then
13:09:47 <sm> which must be kept secret
13:10:11 <jophish> dolio: I'm not sure I follow. That's exactly how they are represented in both packages
13:10:14 <dolio> Oh, actually, I got that backwards, I guess. You shouldn't be able to answer 'true' to the question of 'are these two reals equal.'
13:10:41 <ski> yes
13:10:46 <ertes> dolio: you mean because you get results in some cases?
13:10:48 <dolio> You can only answer 'false' or spin forever.
13:10:59 <ertes> i see
13:11:52 <ski> i suppose you could get `True' if you're sure they're within some distance of one another, and `False' if you're sure they're further apart than that distance ?
13:12:21 <Hijiri> it could be possible to answer True in some cases if you had special information  available
13:12:32 <Hijiri> such as "both of these reals were constructed from the Int 0"
13:13:24 <jophish> ski: yeah, that's what the phantom type is used for
13:13:26 <johnw> ertes: that's awesome, thanks!
13:13:43 <ski> Hijiri : but then you could get bottom or an answer, depending on which (supposedly) semantics-preserving transformations you apply ?
13:13:58 <johnw> babu: what was it exactly that you did in ghci that reported 6.00000001?
13:13:58 <jophish> Hijiri: I plan to do something similar when I get the time. Tag each CReal value with some interval warlpiri number
13:14:25 * ski can't recall what jophish is talking about
13:14:26 <dolio> You wouldn't be working with the computable reals then. You'd be working with something else that carries extra information.
13:14:34 <jophish> knowing if a number is in the range [0..1] allows some functions to be much faster
13:14:59 <jophish> ski: the Nat on CReal is the precision to compare at
13:15:02 <jophish> amongst  other things
13:15:13 <ski> which `Nat' ?
13:15:20 <dolio> Like, you'd be distinguishing `fromInt 0` from `lim n->oo. 2^-n`.
13:15:40 <jophish> ski: https://hackage.haskell.org/package/exact-real-0.12.1/docs/Data-CReal.html
13:15:43 * ski had something like what dolio said in mind, yes
13:15:49 <sm> johnw: it was 3.1 - 2.5
13:16:14 <ski> jophish : oh, not seen `Nat -> *' before
13:16:17 <jophish> dolio: the number tag would just be to aid performance
13:17:10 <ski> jophish : it would mean that a nonterminating program could terminate, if applying the equality mentioned by dolio
13:17:15 <jophish> and one possible value for the tag would be [-∞..∞]
13:17:50 <ski> (so it's not just terminating quicker. it's the difference between terminating at all, or not at all)
13:18:25 <jophish> that might not be an 'optimization' which would be good to put in
13:19:06 <jophish> but using https://hackage.haskell.org/package/exact-real-0.12.1/docs/Data-CReal-Internal.html#v:sinBounded when possible would be worth it
13:19:07 <monochrom> floating point arithmetic is not uncertain. floating point arithmetic is deterministic, so how could it be uncertain? (except for the subjective "uncertain" meaning you don't know the deterministic rules.)
13:21:47 <johnw> and one needs to know the rules for conversion to a decimal representation, since there can be more than one for the same floating point number
13:23:05 <c_wraith> monochrom, results can vary depending on compiler optimizations and flags. it may be deterministic, but the inputs are more than just "the code I wrote" 
13:23:12 <dolio> There are infinitely many decimal representations that will be most closely approximated by the same floating point number, even.
13:25:03 <pgiarrusso_> dolio: indeed, so printing back 0.6 as 0.6 should be correct, no?
13:25:09 <dolio> No.
13:25:16 <jophish> reminds me of this https://randomascii.wordpress.com/2014/01/27/theres-only-four-billion-floatsso-test-them-all/
13:25:26 <dolio> 0.6 isn't the closest approximation to 0.6000...01.
13:25:48 <dolio> Well, printing 0.6 as 0.6 is correct.
13:25:55 <dolio> But 3.1 - 2.5 isn't 0.6.
13:25:58 <monochrom> c_wraith: Yes for those of us who actually know.
13:26:18 <pgiarrusso_> ah I see
13:26:21 <joncol_> I just read that definition of nub3 at https://github.com/quchen/articles/blob/master/fbut.md#nub, and got very confused. How to start understanding this?
13:26:52 <dolio> At least, not under whatever settings were used for the test.
13:27:08 <dolio> It might be possible to set some things such that you get 0.6 for 3.1 - 2.5.
13:27:33 <dolio> I'm not IEEE floating point expert.
13:27:41 <dolio> No, even.
13:27:46 <johnw> 3.1 - 2.5 is a repeating binary pattern (10011001100110011....), while 0.6 is not; so you have to cut-off the former somewhere, and round according to IEEE
13:28:47 <pgiarrusso_> johnw: 0.6 must also be a repeating binary pattern
13:28:52 <sm> explanatory, johnw++ 
13:29:26 <pgiarrusso_> 0.6 is 3/5, which is periodic in any base not divisible by 5
13:30:11 <johnw> pgiarrusso_: interesting; when I use decodeFloat on 0.6 and view it as binary, it's 0x11000....0
13:30:43 <johnw> is the period just outside of 64-bits?
13:30:47 <pgiarrusso_> don't floats start with the exponent outside?
13:31:21 <c_wraith> joncol_, well, start with.. how comfortable are you with foldr? 
13:31:24 <johnw> I'm just looking at the decoded number
13:31:31 <johnw> > 6755399441055744*2 ^^ (-50)
13:31:33 <lambdabot>  6.0
13:32:02 <joncol_> c_wraith: I've just never seen foldr where the accumulators are functions.
13:32:09 <johnw> where 6755399441055744 = 11000000000000000000000000000000000000000000000000000
13:32:14 <pgiarrusso_> > decodeFloat 0.6
13:32:17 <lambdabot>  (5404319552844595,-53)
13:32:28 <johnw> omg, grr
13:32:38 <c_wraith> joncol_, OK. I have a SO answer on that topic. let me track it down.. 
13:32:38 <johnw> I stupidly had typed 6.0 in my lambdabot chat window and never saw it
13:32:46 <johnw> thanks, pgiarrusso_!
13:32:59 <joncol_> c_wraith: sweet
13:33:20 <pgiarrusso_> johnw: welcome! gotta check out decodeFloat now, didn't know it
13:33:41 <johnw> > decodeFloat (3.1 - 2.5)
13:33:45 <lambdabot>  (5404319552844596,-53)
13:33:59 <johnw> only 1 different, so we're at an edge between two representations
13:34:01 <dolio> 0.6's decode float is '100110011...'. And (3.1 - 2.5) ends '..110100'.
13:34:12 <pgiarrusso_> johnw: thanks, that makes sense
13:34:21 <johnw> as dolio said, within the bounds of Double, 0.6 really is different from 3.1 - 2.5
13:34:26 <dolio> Instead of '...110011'.
13:34:47 <c_wraith> joncol_, https://stackoverflow.com/questions/27456313/how-to-implement-delete-with-foldr-in-haskell/27458645#27458645
13:34:58 <pgiarrusso_> it sounds like the error in 0.6 is 1 eps, while the one in 3.1 - 2.5 is something like 2 eps
13:35:16 <pgiarrusso_> s/1eps/<= 1eps/
13:36:36 <c_wraith> well. 3.1 has error, too. (2.5 doesn't!) 
13:36:41 <monochrom> in fact, the problem already began when you thought you had 3.1. You never had 3.1.
13:36:48 <monochrom> yeah
13:37:03 <dolio> Yeah, 3.1 is repeating the same way as 0.6, but it eats up precision for the 3
13:37:17 <monochrom> generally, if the fraction part is not a nice sum of powers of 1/2, you're tossed.
13:37:18 <joncol_> c_wraith: Thanks, I'll look into that.
13:37:42 <dolio> And when you subtract, the error gets shifted over, instead of getting more of the pattern like 0.6.
13:38:53 <monochrom> the other thing to keep in mind is "round to even".
13:39:54 <monochrom> on that, even Donald Knuth has written elaborately and eloquently
13:40:00 <pgiarrusso_> dolio: you're right that 2.5 is exact I had overlooked that, thanks
13:41:03 <pgiarrusso_> monochrom: I learned round-to-even (and more) from http://floating-point-gui.de/errors/rounding/, that website is really nice. It's basic, but still a bit more than I knew from my (bad) numerical analysis course
13:42:39 <dolio> > encodeFloat 6755399441055744 (-53)
13:42:42 <lambdabot>  0.75
13:42:50 <ongy> > 2.5 + 3.1 - 2.5 -- :)
13:42:52 <lambdabot>  3.0999999999999996
13:42:54 <dolio> Oh, right.
13:43:42 <monochrom> yes, I love floating-point-gui.de, I highly recommend it too, at least until you are ready to also read the harder article "what every computer scientist should know about floating point"
13:44:08 <monochrom> also, it took me several years to notice why they went with the top-level domain "de".
13:44:41 <monochrom> ("why do they base themselve in Germany?")
13:44:41 <dolio> Or just avoid floating point forever. Also recommended. :)
13:45:43 <johnw> although sometimes giving up accuracy for speed is a big win, when the accuracy isn't all that accurate to begin with
13:46:22 <dolio> No, I mean, just only work on problems that use integers.
13:46:42 <johnw> i can feel your facetiousness from here
13:46:55 <monochrom> x86 provides a 3rd number type "binary-coded decimal". it does simple base-10 fractions like 3.1-2.5 exact. because it literally stores 18 decimal digits in 9 bytes.
13:47:15 <monochrom> it is there because the banks wanted it.
13:47:32 <dolio> I don't think many problems I'm interested in actually need real numbers.
13:47:40 <c_wraith> it just uses something like a truncated hex representation? 
13:47:40 <dolio> So I'm not that facetious.
13:47:49 * ski recalls the BCD processor status flag on 6502
13:47:52 <johnw> if you want to avoid them, I have no argument :)
13:48:00 <monochrom> however, GHC doesn't expose it to you. Most C compilers don't either, I think. But you can ask mauke for how to embed assembly code in Haskell.
13:48:05 <ongy> monochrom: wow I have never heard of that. since when are they in? Also why are they in de tld?
13:48:15 <johnw> I'm mainly thinking of games and certain scientific applications
13:48:20 <ertes> monochrom: so you went from "why GUI?  and why in germany?!" to the longest "ooooooooohhhhhhhhh!" you've ever had
13:48:23 <monochrom> since 8087 I think.
13:48:41 <monochrom> yes ertes that was exactly my puzzlement :)
13:48:54 <thoughtpolice> ongy: "gui.de" is a pun, referring to "guide", so the full domain name is "floating point guide"
13:48:54 <ongy> daaaaaaaaaaaaaaaaaaah
13:49:20 <dolio> Yeah, I think the obligation to use real numbers is part of why graphics doesn't interest me that much.
13:49:25 <c_wraith> keep precision uniform over the whole range. 
13:49:56 <monochrom> oh, you mean when was floating-point-gui.de created? I think 15 years +/- 5
13:49:58 <johnw> i'm writing code in another window involving sensor tracks w/ error estimates, which are summed in various ways, and so the imprecision of floating point fits the problem rather well; I actually don't want people thinking the results are super precise, because they aren't
13:50:32 <johnw> in fact, I wouldn't mind a library where I can explicitly give the epsilon and have it tracked through computations...
13:50:44 <c_wraith> johnw, yeah, floating point is nice for calculations with error relative to the magnitude of the measurement. 
13:51:13 <ongy> I was asking abou tthe decimal things. I don't remember seeing any hardware parts for them ever either (in cpu descriptions)
13:51:15 <dolio> johnw: That sounds like something Ed would have done.
13:51:28 <johnw> dolio: in fact, I think his reflection answer would be a good way to do it
13:51:29 <ertes> johnw: i think that package exists, but i can't recall its name
13:51:31 <johnw> s/answer/library
13:51:31 <c_wraith> but that and "performance hack" are the only places I think it really belongs. 
13:52:43 <Tuplanolla> I guess some simple cases of uncertainty propagation could work like `ad`.
13:53:06 <johnw> edwardk: bat signal, lit
13:53:14 <Tuplanolla> Uncorrelated normally distributed random variables is one such instance.
13:53:36 <peddie> ertes: johnw: doesn't  the numbers package also have a module with a configurable epsilon?  BigFloat or something?
13:53:37 <monochrom> c_wraith: yes, binary-coded decimal represents 65 as: 0110 for 6, then 0101 for 5. Each decimal digit is written in 4 binary bits. It is decimal semantics using a binary code, and so it is called binary-coded decimal. And the acronym BCD is cool too, being a segment of the alphabetic sequence.
13:54:01 * geekosaur has COBOL flashbacks
13:54:29 <peddie> ertes: johnw: https://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-BigFloat.html  "Floating point number where the precision is determined by the type `e`"
13:54:32 <johnw> according to https://mail.haskell.org/pipermail/haskell-cafe/2011-March/090355.html, edwardk mentions his intervals library as one answer to this
13:54:54 <ertes> peddie: i think peddie wants error propagation
13:54:59 <ertes> uhm
13:55:02 <ertes> peddie: i think johnw wants error propagation
13:55:06 <johnw> yes
13:55:08 <peddie> ertes: oh, sorry, I see
13:55:12 <peddie> misunderstood
13:55:25 <monochrom> interval arithmetic tracks error propagation too, in fact probably better
13:55:41 <johnw> my points are really circles, and when I sum the distance of a "track" of circles, I want an aggregate error that reflects how variant the distance might be
13:56:05 <Tuplanolla> It's too pessimistic for nonuniform distributions, monochrom.
13:57:22 <ertes> it may pay off to make the error dimensionality-aware, so you get error circles instead of error rectangles
13:57:53 <johnw> ertes: intuitively, how would an error circle relate to my computed approximate distance?
13:57:56 <Zemyla> Is it dumb of me to try and write a parser in Perl by first implementing Parsec, continuation-passing style and all?
13:58:03 <monochrom> although, interval arithmetic knows the error as a value, not as a type
13:58:20 <ertes> johnw: i don't know…  i don't know your application
13:58:43 <ertes> Zemyla: depends…  is there a cheaper option that's good enough?
13:59:02 <Zemyla> Not sure. I'm mostly doing this as an intellectual exercise.
13:59:03 <johnw> ertes: collection of lat/lon points scattered in time, thinking GPS sampling; I want to calculate distance over ground traveled
13:59:24 <monochrom> I think Haskell and Parsec is cheaper than Perl and porting Parsec
13:59:24 <johnw> where GPS is +/- 30 meters or something
13:59:35 <ertes> johnw: so this is not (just) FP error, but actual measurement error?
13:59:51 <johnw> Zemyla: you could use my parsec-free library to write a Parsec parser, and then compile it to Perl
14:00:04 <ertes> Zemyla: does perl even support functions properly?
14:00:04 <johnw> compilation to Perl being an exercise to the reader :)
14:00:15 <johnw> ertes: correct
14:00:29 <ertes> like closures, half-way sensible lambda syntax, etc.
14:00:40 <ertes> oh, and you really want tail calls to be optimised
14:01:21 <monochrom> Perl has "sub" which is sensible lambda.
14:01:38 <Zemyla> ertes: It also has manual tail call optimization.
14:01:53 <monochrom> so at least you can do callback-passing style
14:02:53 <ertes> manual?  like a trampoline?
14:03:18 * geekosaur wonders if that is supposed to mean goto ^sub
14:03:23 <geekosaur> er &sub
14:04:19 <Zemyla> geekosaur: Yep.
14:06:29 <joe9> I have a simple "number,UP" string to parse. Would I be better off using the read* functions of Safe or is there something better out there?
14:07:32 <bizarrefish> Hi all
14:07:39 <RouxTheDay> Would you call !! a partial function?
14:07:46 <kadoban> RouxTheDay: Yes, it is
14:07:53 <RouxTheDay> kadoban: Thanks
14:07:58 <monochrom> they you will have to use "reads" directly. see my http://www.vex.net/~trebla/haskell/reads.xhtml
14:08:02 <kadoban> joe9: I'd be split between using a real parsing library and just splitting on the comma and then whatever
14:08:08 <monochrom> you need "reads" because you need "the rest of the string"
14:08:34 <Zemyla> Also, part of the reason I was thinking about that is so I can have "match the front of this string with this regex" be a single primitive operation.
14:08:39 <bizarrefish> Say I have a function a -> b -> m c, and I want to compose it with d -> m a and e -> m b, so as to get d -> e -> m c....what's the nicest way to do that?
14:10:00 <Zemyla> :t \f g h -> \d e -> g d >>= (\a -> h e >>= f a)
14:10:01 <lambdabot> Monad m => (t2 -> a -> m b) -> (t -> m t2) -> (t1 -> m a) -> t -> t1 -> m b
14:10:26 <Zemyla> @pl \d e -> g d >>= (\a -> h e >>= f a)
14:10:26 <lambdabot> (. ((. f) . (>>=) . h)) . (>>=) . g
14:11:03 <joe9> monochrom: Thanks.
14:11:49 <joe9> monochrom: If you do not mind me asking, is there a reads for bytestrings? readbs, probably?
14:11:53 <joe9> readBS?
14:12:04 <monochrom> no, I don't think there is
14:12:47 <bizarrefish> Zemyla: So, no nice generalization :(
14:12:59 <bizarrefish> <=< almost does what I want
14:13:03 <bizarrefish> :/
14:13:11 <bizarrefish> :t <=<
14:13:13 <lambdabot> error: parse error on input ‘<=<’
14:13:16 <monochrom> but Data.ByteString.Char8 has the specific readInt which still solves half of your problem
14:13:21 <bizarrefish> aw
14:16:30 <joe9> monochrom: Thanks.
14:17:44 <geekosaur> bizarrefish, you need to wrap operators in parentheses for that
14:17:49 <geekosaur> :t (<=<)
14:17:51 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:29:20 <RouxTheDay> What would you call a type that implements only some functions of a typeclass? Like a Num instance that only supports (+) and (-) ?
14:29:39 <grantwu> Unfortunate
14:30:07 <RouxTheDay> lol
14:30:21 <needHelp> hi i am looking for help
14:30:32 <joncol_> Who would have thunk.
14:30:41 <needHelp> :-)
14:31:04 <needHelp> i am trying to get a haskell script running from ubuntu commando line
14:31:08 <needHelp> http://pastebin.com/Q9erUeAs
14:31:29 <needHelp> i have installed hugs98 and ghci
14:31:37 <needHelp> but haven't been able to succeed ye
14:31:38 <needHelp> yet
14:31:50 <needHelp> if anybody could have a look and point me to the right direction
14:31:55 <needHelp> i would be very grateful
14:31:56 <needHelp> :-)
14:32:04 <glguy> The file is fine, you'll have to tell us what you tried to do that didn't work
14:32:14 <needHelp> uhm
14:32:17 <needHelp> wait a second
14:32:21 <needHelp> i tried running it
14:32:24 <glguy> That file has no main action, so you can't "run" IT
14:33:01 <needHelp> alright i already tried adding "main = " at the beginning of the first line
14:33:05 <glguy> but you can load it with GHCi and try evaluating some expressions
14:33:54 <monochrom> "main = " is not enough.
14:34:24 <needHelp> what else do i need?
14:34:27 <needHelp> at the beginning?
14:34:43 <glguy> What do you expect to happen?
14:34:49 <grantwu> RouxTheDay: I'm not an expert but I think this sort of thing has happened before and it was painful
14:34:55 <monochrom> code that spells out what you want main to do.
14:34:57 <grantwu> RouxTheDay: Like, adding applicative as a superclass of monad?
14:35:09 <monochrom> Haskell is not a telepathic ESP language.
14:35:31 <glguy> monochrom: "main inference" would be a nice addition to type inference
14:35:49 <monochrom> Even for a human like me, I cannot ESP-sense what you want to do, e.g., do you want the answer to facInv 40? Or do you want the answer to facInv 32? Or what?
14:36:12 <dmj`> unless you use the ghci-esp package
14:36:18 <needHelp> no it should take the number as argument
14:36:18 <grantwu> I think needHelp probably just wants to load these definitions and evaluate some thing
14:36:31 <needHelp> and calculate a number
14:36:54 <needHelp> yes grantwu 
14:37:24 <monochrom> yeah the simplest thing is to not aim at a script on the command line, but to settle for "load it in ghci, then you can ask about facInv 40"
14:37:59 <monochrom> or you have use hugs instead of ghci too, it's a free country
14:38:04 <monochrom> s/have/can/
14:38:24 <needHelp> our professor said the script has to run under hugs98
14:38:30 <needHelp> so thats why i was trying with hugs first
14:38:57 <monochrom> that still doesn't resolve the ambiguity between "script on command line" vs "load it then enter an expression"
14:39:36 <needHelp> yes
14:39:44 <needHelp> i know lol
14:40:12 <glguy> needHelp: try $ ghci <YourFile>.hs
14:40:51 <grantwu> By the way how do I do this with stack ghci
14:41:30 <glguy> grantwu: It probably involves Twitter somehow
14:41:56 <monochrom> I don't know stack. But I don't know why Twitter is involved either.
14:42:07 <needHelp> glguy: it says modules loaded
14:42:16 <needHelp> and now Main>
14:42:22 <glguy> needHelp: OK, now you can type:   facInv 120
14:42:23 <monochrom> Unless it's because Twitter is an important tech support platform for stack.
14:42:31 <needHelp> THANKS
14:42:59 <monochrom> you could also replace "ghci" by hugs and repeat the experiment, and check that you get similar outcomes.
14:43:10 <needHelp> hmm let me try
14:43:17 <monochrom> "hugs yourfile.hs" then "facInv 120" again
14:43:46 <needHelp> okay guys
14:43:49 <needHelp> got it
14:43:59 <needHelp> i didnt know i had to enter the function name first
14:44:04 <monochrom> I don't know whether this satisfies your prof, but I actually think your prof is confused to begin with.
14:44:16 <needHelp> i think this is exactly what he wants lol
14:44:17 <needHelp> x-D
14:44:55 <needHelp> now it just hast to return the right value :/
14:45:05 <needHelp> :p
14:45:13 <needHelp> anyway thanks a bunch guys
14:45:44 <needHelp> will definitely reccomend
14:45:46 <needHelp> bais
14:46:23 <glguy> monochrom: Maybe the prof is teaching a class on computer history pre-Y2k and Haskell is incidental to the exercise
14:47:21 <monochrom> That is not a big deal. hugs is fine, and Erik Meijer chose hugs too, and Erik Meijer was not confused.
14:47:52 <monochrom> My big deal is "run this script" where there is no main. People in the know don't speak like that.
14:48:34 <monochrom> Then again there is only 50% chance the prof actually said that. The other 50% chance is it's the student's misinterpretation.
14:48:54 <glguy> Oh, I interpreted the line as meaning "My prof said to use Hugs", not that the prof used that literal phrase
14:49:07 <monochrom> Basically education is always screwed because 50% of the time the prof is wrong, and the other 50% of the time the student creates fiction.
14:50:04 <grantwu> Yeah, I know right.
14:50:11 <grantwu> Damn students not getting things the first time!
14:50:23 <grantwu> They should just *understand* and then education would not be screwed /s
14:50:52 <glguy> 50% grantwu made some fiction, 50% monochrom was wrong
14:50:59 * glguy grabs a quarter
14:51:31 <monochrom> No, there is stil a difference between "I don't get it" and "I don't get it but I can make up something"
14:52:24 <grantwu> People don't operate on intuitionistic logic; they can't always know exactly what they know and they don't know
14:52:53 <monochrom> There is a difference between "you said 'cosine' and I've never heard of it" and "you said 'cosine' and I've never heard of it but I've heard of 'sine' so let me just pretend you said 'sine'"
14:54:21 <monochrom> In fact in practice what people do is the more mysterious "you said 'cosine' and I've never heard of it but I know 'sqrt' so I'll pretend you said 'sqrt'"
14:55:05 <monochrom> Not even Dunning and Kruger could explain this. But it happens all the time.
14:56:24 <geekosaur> our brains edit correct based on the knowledge they have
14:56:39 <geekosaur> (there is actually evidence for this although not so phrased)
14:57:04 <monochrom> I prefer the "cosmic ray mutates RAM content" model.
14:57:04 <dolio> Speak for yourself.
14:57:51 <Rembane> Brain quantization.
14:59:05 <__________> does this chan have a lot of regulars
14:59:14 <monochrom> yes
14:59:16 <__________> or is it just random lurkers all day
14:59:22 <monochrom> also yes
14:59:41 <__________> bonus question: does this chan have power hungry ops
14:59:49 <joncol_> -quit
14:59:50 <__________> that ban because they dont like you
15:00:12 <monochrom> yes, that describe me, but I'm an exception
15:00:33 <glguy> __________: Did you have a question about Haskell?
15:03:32 <__________> glguy are you a mod
15:03:36 * hackagebot hackernews 1.1.0.0 - API for Hacker News  https://hackage.haskell.org/package/hackernews-1.1.0.0 (DavidJohnson)
15:04:20 <grantwu> __________: What is the purpose of this line of questioning?
15:04:26 <__________> i can already feel the hostile vibes emanating from the people who feel they own this chan
15:04:27 <JuanDaugherty> Faites vos jeux
15:04:36 <__________> bye all
15:04:37 <grantwu> @ops
15:04:37 <lambdabot> Maybe you meant: pl oeis docs
15:04:40 --- mode: ChanServ set +o mauke
15:04:40 --- kick: __________ was kicked by mauke (bye)
15:04:48 <pharaun> what
15:04:51 <monochrom> it's @where ops
15:04:58 <grantwu> sigh, I always forget
15:05:03 <monochrom> :)
15:05:05 <glguy> grantwu: You don't need to summon ops if two of them are already talking to the user
15:05:22 <grantwu> glguy: I don't know who is an op and who isn't, at least not yet
15:05:32 <mauke> grantwu: you could ask lambdabot in private
15:05:32 <pharaun> that was such a odd line of questioning
15:06:00 <glguy> Anyway, back to your regularly scheduled programming, discussion can happen in #haskell-ops if necessary
15:06:40 --- mode: mauke set -o mauke
15:19:09 <RouxTheDay> What is () called? void?
15:19:18 <mauke> unit
15:19:25 <RouxTheDay> ah okay, thanks
15:19:59 <geekosaur> unit is the type with one non-bottom inhabitant. Void is the type with no non-bottom inhabitants
15:20:40 <RouxTheDay> geekosaur: Nice, thanks for the explanation, makes sense
15:22:54 <KaneTW> void in c-style languages is actually unit, though
15:23:35 <Tuplanolla> Java has `void` and `Void` that are different...
15:23:56 <monochrom> that is an untestable theory. as is the alternate theory "no, it is actually void"
15:24:16 <monochrom> the conclusion is that the question is meaningless.
15:30:53 <mauke> __________: welcome back
15:30:56 <sphinxo> How can I do essentially " not (v ~ t)" in a GADT type sig ?
15:31:09 <sphinxo> ( possibly a stupid question )
15:31:10 <geekosaur> sphinxo, painfully
15:31:21 <sphinxo> geekosaur, go on :)
15:31:23 <mauke> oleg has probably done it in some way
15:31:39 * geekosaur trying to recall details beyond "ugly"
15:32:17 * sphinxo isn't sure if he wants to know anymore
15:32:21 <dolio> Oleg did it way back for fundeps, but as I recall it's very specific t o the exact way they work.
15:32:43 <dolio> And it probably won't give you not (v1 ~ v2).
15:32:51 <dolio> In that ~ doesn't work like fundeps.
15:33:57 <byorgey> you can do it with closed type families.   type Equal a b :: Bool where   Equal a a = True;  Equal a b = False
15:34:04 <geekosaur> http://stackoverflow.com/questions/6939043/is-it-possible-to-place-inequality-constraints-on-haskell-type-variables
15:34:10 <byorgey> then you can write   (Equal v t ~ False) => ...
15:34:15 <__________> mauke: Fuck you and guy know cucknode for having such weak willed ops
15:34:20 --- mode: ChanServ set +o geekosaur
15:34:29 --- mode: geekosaur set +b *!*uid190822@*.com/x-ciosbukvtbhjexta
15:34:29 --- kick: __________ was kicked by geekosaur (__________)
15:34:41 <geekosaur> actually that won't work, sigh
15:35:14 <Welkin> lol, mauke 
15:35:56 --- mode: geekosaur set +b __________!uid190822@*/irccloud.com/x-*
15:36:02 <pikajude> i wonder what "guy know cucknode" means
15:36:10 --- mode: geekosaur set -b *!*uid190822@*.com/x-ciosbukvtbhjexta
15:36:15 <pikajude> maybe an autocorrect failure
15:36:23 --- mode: geekosaur set -o geekosaur
15:36:52 <sphinxo> Cool thanks
15:38:12 --- mode: ChanServ set +o glguy
15:38:12 --- mode: glguy set +b-bo *!*@gateway/web/irccloud.com/x-ciosbukvtbhjexta __________!uid190822@*/irccloud.com/x-* glguy
15:39:50 <joe9> is there a better way of doing this: https://paste.pound-python.org/show/2Q1pepORZRMfJ3iwBKP1/ ? (defining them with newtype's and doing that using a generic put might be more code)
15:41:14 <geekosaur> huh?
15:44:37 <joe9> a little better https://paste.pound-python.org/show/0TerOUJ5iFavjutFnyLn/
15:52:36 <sphinxo> what do people think of this pattern? http://lpaste.net/8388600775865008128
15:55:08 <glguy> sphinxo: When would you want to use that?
15:55:23 <sphinxo> lol idk
15:55:54 <mauke> my bff jill?
15:55:59 <sphinxo> emulating dependently typed things ish
15:56:18 <Tuplanolla> It looks like heresy. I like it.
16:03:37 * hackagebot deriving-compat 0.3.4 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.3.4 (ryanglscott)
16:40:32 <tibbe> @messages
16:40:32 <lambdabot> You don't have any messages
16:40:41 <glguy> :(
16:40:44 <monochrom> :)
16:40:47 <Welkin> @messages
16:40:47 <lambdabot> You don't have any messages
16:40:58 <glguy> :(
16:41:01 <Welkin> Cale is in nyc?
16:41:24 <sm> is it time to assume GHC 8 is the right default for users, yet ?
16:41:40 <rando213> howdy fine people of #haskell! I'm having trouble getting some simple GADT code to work, can anyone take a look at my paste here? http://pastebin.com/RDzWA5Hi
16:42:24 <glguy> rando213: You can't write an isntance of Eq for FruitOrPetOwner
16:43:11 <Welkin> Fruit *or* a PetOwner?
16:43:22 <rando213> glguy: absolutely impossible? is there something other than GADTs that could help me here?
16:44:12 <rando213> Welkin: not sure what you mean, I'm still pretty new, is my question flawed?
16:44:32 <glguy> rando213: Certainly impossible as you’ve defined your type FruitOrPetOwner, without knowing what you hope to accomplish here I can’t offer a suggestion.
16:44:36 <Welkin> rando213: no, just weird
16:45:36 <lgstate> I know that in ghci, I can reload on a *file level* with :r *module-name* ; however, in clojure, I can reload on an expression level -- is there a nice way, in ghci/haskell, for interactive devel9pment / rapid prototyping, to reload an expression at a time?
16:45:42 <mauke> all is possible with the magic of Typeable
16:46:27 <ertes> lgstate: no
16:46:38 <ertes> lgstate: why?  does reloading the file take too long?
16:47:45 <rando213> glguy: I'm trying to have `x` be constrained only by being an Eq instance and produce False if I'm comparing a PetOwner with a FruitOwner (i.e. if x doesn't have the same type) .. are you saying that's impossible? How would you model something like this?
16:48:15 <Welkin> o.o
16:48:18 <glguy> rando213: data PetOrFruitOwner = PetOwner Pet | FruitOwner Fruit
16:48:19 <Welkin> is a fruit comparable to a pet?
16:48:20 <mauke> "if x doesn't have the same type" is constrained more than just Eq
16:49:15 <mauke> I'm pretty sure you can do this with Owner :: (Typeable a, Eq a) => ...
16:49:22 <mauke> but I probably wouldn't use it in real code
16:49:27 <johnw> glguy's type encodes the difference between pets and owners, allowing this difference to impact the meaning of Eq
16:49:30 <rando213> glguy: right, except I'd like to be able to add data constructors to PetOrFruitOwner from other places in the code, is that possible?
16:49:43 <rando213> mauke: what's wrong with Typeable?
16:49:50 <rando213> mauke: is it not safe?
16:50:02 <mauke> it's safe if you don't define instances manually
16:50:13 <mauke> (does ghc still let you do that?)
16:50:22 <ertes> mauke: i don't think so
16:50:39 <ertes> mauke: most notably because it writes instances for you regardless of whether you derive it or not
16:51:07 <ertes> so any manual instance would just overlap
16:52:04 <Sonolin> "it's safe if you don't define instances manually" > what does that mean?
16:52:06 <geekosaur> Typeable is generated internally for all types and manual instances are forbidden
16:52:16 <Sonolin> meaning declaring Typeable like "instance Typeable a where..." ?
16:52:19 <geekosaur> since I think 7.8, maybe 7.10
16:52:27 <geekosaur> Sonolin, yes
16:52:43 <Sonolin> oh crap, well there's a few "unsafe" modules in my xmonad code then
16:53:23 <Sonolin> does that mean unsafe as in "unsafePerformIO" or something else?
16:53:38 <geekosaur> (the reason it's unsafe is it's possible to give two types the same Typeable instance, which can be used to derive unsafeCoerce)
16:53:57 <Sonolin> ah ok
16:54:02 <geekosaur> and yes, given unsafeCoerce you can make unsafePerformIO, or just cause a coredump
16:54:44 <mauke> 'cast' is basically unsafeCoerce guarded by a typeOf check
16:54:54 <mauke> if you can make a typeOf that lies, you "win"
16:55:40 <johnw> mauke: if you know C++, is it coerce : static_cast :: unsafeCoerce : reinterpret_cast?
16:55:58 <mauke> what's coerce?
16:56:13 <johnw> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Coerce.html
16:56:54 <johnw> i.e., you can safely coerce to something with an identical runtime representation
16:57:20 <mauke> I don't think that exists in C++
16:57:58 <johnw> oh, you're right, even static_cast is not always safe
16:58:33 <mauke> and unsafeCoerce is more powerful
16:58:41 <mauke> e.g. I'm pretty sure C++ can't cast to struct types
16:59:24 <ContessaTP> I think you can do that with a union
16:59:35 <ContessaTP> Put multiple structs in a union and see what happens
16:59:42 * StoneToad shudders
16:59:48 <ab9rf> you can also do it with a forced plain C cast, although the compiler will whinge
17:02:31 <mauke> no, you can't
17:03:03 <mauke> or can you
17:03:10 <geekosaur> yes
17:03:39 * hackagebot hnix 0.3.4 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.3.4 (JohnWiegley)
17:03:40 <mauke> oh, it's playing nice
17:03:41 * hackagebot text-show 3.4.1 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.4.1 (ryanglscott)
17:03:48 <mauke> it tries to call a conversion constructor
17:03:58 <mauke> if it doesn't find one, it's an error
17:04:46 <johnw> likely either a conversion operator, or a constructor, whichever has the "best match"
17:04:48 <geekosaur> oh, I thought that was the union not a cast
17:04:59 <johnw> although, that's not quite what coerce is
17:05:03 <johnw> either
17:05:28 <geekosaur> C/C++ doesn't really have the concept of "same representation"
17:06:53 <monochrom> Strange world. People who say "I came from a C++ background" don't understand C++, but instead people who say "I came from a Haskell background" do.
17:07:16 <ContessaTP> I came from a QBASIC background :P
17:07:26 <Tuplanolla> Perhaps they have a different view of understanding.
17:07:32 <monochrom> I started with BASIC. Not even with Q.
17:08:29 <monochrom> Yeah, there are two kinds of "understanding": "I can write an essay" vs "I can make correct predictions"
17:09:53 <monochrom> But a C++ practitioner is not of the "just wrote essays" kind. They actually wrote code and that code actually worked fine.
17:10:53 <monochrom> (Then again you could chalk it up to "So why do you think their bug tracker is still non-empty?!")
17:11:04 <geekosaur> you can understanc c++ well enough to write working code without knowing what's going on under the covers
17:12:11 <dolio> You can also know what some C++ compilers implement even though the spec doesn't say that it's guaranteed.
17:12:27 <ContessaTP> If you're a total beginner that wants to become a C++ programmer, you should learn C just to get an understanding of the memory model. Otherwise you'll fall into that 'leaky abstraction' issue when something goes wrong.
17:12:52 <richardS125> Hey all, I just started trying to learn Haskell. I was finally able to get ghc-mod to work in atom a few days ago(though I'm not entirely sure what I did). Today I upgraded to Mac OS Sierra and it seems to have broken it again
17:13:11 <ContessaTP> Have you tried reinstalling it?
17:13:35 <richardS125> I saw some people suggested reinstalling (using manual method)
17:14:01 <Cale> richardS125: Yeah, Sierra has basically caused everyone a lot of problems
17:14:20 <geekosaur> it may still end up broken though. some object files that were legal in older macOS are rejected by sierra
17:14:28 <monochrom> In fact should take a "computer organization" course.
17:14:36 <geekosaur> so even rebuilding won't help, at least until 8.0.2 comes out with a workaround for the sierra change involved
17:14:56 <Cale> Almost every Mac OS upgrade is a disaster when it comes to getting compilers to work.
17:14:59 <geekosaur> (they set an arbitrary cap on the load commands table size)
17:15:12 <richardS125> I'm pretty new to all of this, so I guess I'm not really comfortable with reinstalling
17:15:32 <monochrom> Could you roll back to before Sierra? :)
17:15:50 <glguy> With TimeMachine
17:16:19 <monochrom> version-controlled file system NOW!
17:16:25 * dmj` wants unboxed sums 
17:16:28 <glguy> Either to restore from backup or to go into the future when 8.0.2 is released
17:17:52 <monochrom> file systems need to be like the Marvel Multiverse.
17:18:25 <johnw> dmj`: how would you pattern match?
17:21:12 <mauke> inb4 retroactive continuity
17:21:42 <_d0t> hi. Is it possible to do a join with a subquery in esqueleto?
17:21:43 <glguy> It turned out those files weren't actually canon
17:22:13 <c_wraith> My system was confiscated by law enforcement?  I'll just retroactively change it to a fresh OS install.
17:22:15 <_d0t> like, select * from t1 join (select * from t2) on ....
17:22:40 <RouxTheDay> I have a spec that goes something like `(f 1) shouldBe 1`, `(f 2) shouldBe 1`, etc., and I want to use map to do that instead, something like `fmap (\x -> (f x) shouldBe 1) [1..10]` (for the sake of this example my function takes a number and returns 1 always). The problem is the types don't match up when I do an fmap, I get an error like this: http://lpaste.net/286133
17:22:51 <c_wraith> Cale: upgrading this laptop to sierra didn't break already-installed GHC, but I haven't had the heart to try any new installs.
17:23:06 <johnw> if I delete a file, I'd be able to bring it back later in time by various means
17:24:01 <RouxTheDay> So I understand *why* it's an issue, I didn't expect it to work, but I don't understand the error message
17:24:35 <mauke> RouxTheDay: try mapM_
17:24:41 <monochrom> (f x) shouldBe 1? (f x) `shouldBe` 1?
17:24:48 <monochrom> Where can I see the actual code?
17:26:31 <RouxTheDay> monochrom: you're right, it's meant to be infix, didn't write it out right on here, the mapM_ thing worked perfectly though, and I *think* I understand why
17:26:34 <RouxTheDay> Thanks mauke!
17:28:13 <sssilver> Often I wonder if Haskell people are just folks that for whatever legitimate reason failed to understand the OOP paradigm and decided to go like "meh we'll just do functions"
17:28:35 <sssilver> the more I read about FP, the more I go "this is basically a limited subset of OOP"
17:28:56 <mauke> objects are just awkward closures
17:28:58 <augur> anyone know of any research on something like pattern matching on sets, or set-like state machines or something like this?
17:29:02 <Sonolin> *popcorn*
17:29:03 <sssilver> it seems that OOP is mathematically "better" being a superset
17:29:33 <saml_> is rabbitmq good?
17:29:41 <mauke> sssilver: what is the OOP paradigm?
17:29:41 <Welkin> saml_: why not zeromq?
17:29:43 <sssilver> saml_ depends
17:29:53 <saml_> thanks
17:29:58 <sssilver> mauke QED :))
17:30:11 <mauke> >implying I'm a Haskell user
17:30:38 <monochrom> I think we can all safely answer "yes" to sssilver and move on.
17:31:01 <Koterpillar> sssilver: why is being a superset better?
17:31:16 <sssilver> Koterpillar any superset is better, because you can do more stuff with it
17:31:24 <sssilver> that's pretty trivial
17:31:31 <Koterpillar> sssilver: is OOP better with the addition of "goto"?
17:31:35 <mauke> therefore asm is better than any programming language
17:31:45 <sssilver> Koterpillar you don't have to use goto, but sure it can be helpful in some situations
17:31:52 <sssilver> the linux kernel contains numerous gotos iirc
17:32:00 <augur> this channel isn't really for debating the merits of programming paradigms
17:32:09 <Welkin> what about nop?
17:32:19 <Welkin> you can't write a real program without plenty of nop's
17:32:25 <sssilver> mauke well asm isn't a superset of C++ by any means. If anything it's a subset of the C++ abstract machine
17:32:37 <monochrom> I agree with augur. Please move this discussion elswhere.
17:32:44 <saml_> rabbitmq has topic exchange. you publish a message to an exchange. the message has topic. "something.like.this".  given an exchange and a queue, there could be multiple bindings. each binding has topic. given E1 -(something.*)-> Q1,  something.foobar is sent to Q1
17:32:55 <sssilver> I'm just trying to understand why you guys are into Haskell
17:33:07 <sssilver> I honestly don't feel like this discussion is offtopic
17:33:12 <mauke> feel free to join me in #haskell-blah
17:33:18 <saml_> E1 -(something.#)-> Q1,   something.foo.bar.yo.lo  is sent to Q1
17:33:33 <saml_> so, i guess it's basically subset of regular language
17:33:56 <sssilver> basically there's nothing you can do in Haskell that you can't do in a more human way in C++ or even Java
17:34:00 <monochrom> I like Haskell's types and nonstrictness. This is why I am into Haskell.
17:34:06 <saml_> i'm trying to encode a program to rabbitmq topic exchange
17:34:38 <sssilver> monochrom OK I understand, but did you know that Java and C++ both have types that are basically Haskell types plus they're even more powerful, since you can couple member functions into them?
17:34:47 <Welkin> lol
17:34:57 <sssilver> that's pretty cool, right?
17:35:04 <mauke> that's enough
17:35:12 <monochrom> No. Instead, I know that their types are more lax, i.e., less informative.
17:35:14 <augur> if you wish you understand why people like functional program, there is a good paper from John Hughes that explains one perspective https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
17:35:32 <monochrom> But yes we should simply stop.
17:35:50 <augur> if Haskell or FP doesn't feel like its your thing, that's cool, you should use the tools you feel most comfortable with!
17:35:56 <monochrom> I can tell you what I like Haskell. You will not evangelize me out of it.
17:36:34 <sssilver> augur I bet it's gonna be another talk about how FP is better because it limits your choices, and somehow assumes that limited choices are a good thing, which seems to be the vibe in the FP community as far as I have encountered
17:36:48 <sssilver> let me go through it though
17:37:09 <augur> additionally here's John Hughes' talk on that subject from Code Mesh 2015 https://www.youtube.com/watch?v=FGQAP0GxlW8
17:37:22 <augur> in case you'd prefer to have something in that format
17:37:26 <Tuplanolla> You can head over to #scheme (or is it ##scheme) if you want functional things without static types, sssilver.
17:37:46 <c_wraith> sssilver: I can't argue, it *is* awesome to have 1000 wrong ways to do things.
17:38:48 <augur> if what we care about and value can be measured, then we can do empirical studies to see what paradigms, etc. are best on those measures, but most disputes over paradigms are purely subjective
17:39:01 <sssilver> I like strong typing actually Tuplanolla, I just find it fascinating that the argument boils down to "you have fewer options and are forced to program in this confined limited constrained space and that's amazing"
17:39:04 <augur> i say most, not all, b/c there has been some empirical work
17:39:21 <sssilver> sure reinterpret_cast may be used wrong, but if you understand exactly what it does, it only adds power to your arsenal
17:39:37 <Koterpillar> sssilver: the problem is it adds power to *everyone else*'s arsenal
17:39:40 <augur> at any rate, sssilver, you now have something from one of the actual creators of Haskell to chew over. read/watch and come to your own conclusions
17:40:05 <c_wraith> sssilver: that's..  not really how the argument goes.  The argument goes "I can trust the code because I know it can't do (some class of) wrong things".  Where the particular class depends on the wrong thing.
17:40:17 <c_wraith> Err, depends on the type system.
17:40:21 <augur> we should move this conversation elsewhere, such as -blah
17:40:26 <monochrom> Yes, predictive power.
17:40:36 <ContessaTP> blah requires an SSL connection to join
17:40:39 <c_wraith> It's really awesome to be able to trust code, instead of having to remember it.
17:40:42 <Welkin> lol ContessaTP 
17:40:51 <monochrom> Create your own channel to discuss this.
17:41:12 <augur> getting back to haskell
17:41:30 <sssilver> I'm failing to join #haskell-blah
17:41:39 <monochrom> Then create your own channel to discuss this.
17:41:39 <mauke> use more SSL
17:41:40 <augur> sssilver: /join #haskell-blah
17:41:43 <ContessaTP> sssilver: you need to reconnect with an SSL connection
17:41:50 <sssilver> augur [19:40:09] -card.freenode.net-	Only users using SSL could join this channel!
17:41:55 <augur> is there a monad, say, that would let me do state-like reads over sets? :\
17:42:10 <augur> sssilver: oh well.
17:42:35 <c_wraith> augur: in what way does what you want differ from just State?
17:42:47 <monochrom> what is state-like read?
17:42:56 <sssilver> well way to shut me up :/
17:43:00 <sssilver> see you guys I guess
17:43:01 <monochrom> Is it just "Reader (Set Int)"?
17:43:41 <monochrom> No one is shutting you up. You can create a new channel. The Freenode people is not going to stop you.
17:44:05 <monochrom> Do not conflat "I can speak" to "you people must listen".
17:44:25 <augur> c_wraith: i'd like to be able to consume specific values/patterns from the set-state, but in an order-independent way
17:44:51 <Sonolin> monochrom it does show an awful lot why he doesn't have the patience for FP though
17:45:01 <augur> c_wraith: eg i'd like to be able to say "this can consume X, Y, and Z in any order"
17:45:03 <c_wraith> augur: ok, but how does it differ from State with some extra helpers?
17:45:08 <stevenxl> Hi folks. I'm having a bit of trouble. I have the following functions in a source file: dodgy x y = x + y * 10. The type signature of dodgy :: Num a => a -> a -> a. I also have oneIsDodgy = dodgy 1, but the type signature of that is oneIsDodgy :: Integer -> Integer. I was expecting oneIsDodgy :: Num a => a -> a.
17:45:08 <ertes> "those evil people are forcing me to use a secure connection! how terrible!"
17:45:10 <stevenxl> What happened?
17:45:20 <Sonolin> lol
17:45:35 <c_wraith> stevenxl: Monomorphism Restriction attacked.
17:45:38 <augur> c_wraith: only, in a way that also lets me do bind-y things, right
17:45:53 <ertes> stevenxl: write a type signature
17:46:16 <geekosaur> @where dmr
17:46:17 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
17:46:39 <stevenxl> c_wraith: Thank you I'll look into that.
17:46:45 <c_wraith> augur: I have a feeling you know exactly what you mean, but I really don't.
17:46:52 <stevenxl> ertes: I'm not trying to fix the "problem". I'm trying to understand it.
17:46:58 <augur> c_wraith: so for instance:   do Foo x <- getFoo ; Bar y <- getBar ; f x y   but where the Foo and Bar can be fed in in any order
17:47:01 <c_wraith> stevenxl: see the link geekosaur got lambdabot to spit out
17:47:10 <stevenxl> c_wraith: Will do. 
17:47:14 <c_wraith> augur: fed?
17:47:25 <ertes> stevenxl: without a type signature the monomorphism restriction chooses concrete types for you via defaulting
17:47:34 <c_wraith> ertes: but only in some cases.
17:47:35 <Koterpillar> augur: do you want a StateT Foo (State Bar) ?
17:47:40 <geekosaur> short version is, you use a binding with no parameters and it is forced to have a single type, in this case Integer by defaulting
17:47:42 <augur> Koterpillar: no
17:48:01 <geekosaur> if you give it a parameter or you give it a type signature, then this doesn't happen
17:48:22 <stevenxl> c_wraith / ertes : I'm reading the monomorphism restriction link now, but i also don't get why in the compiler I do :t dodgy 1 and that gives me the type signature I expected.
17:48:28 <augur> c_wraith: so let me unwrap this further:   imagine you have a state machine (abstractly speaking), that transitions on reading a value of one sort or another
17:48:38 <c_wraith> stevenxl: because it only applies to bindings, not expressions
17:48:41 <Koterpillar> augur: your expression typechecks if getFoo = gets fst, getBar = gets snd, the whole thing is State (Foo, Bar)
17:48:41 <geekosaur> because that is not a binding and is not forced to be monomorphic
17:48:52 <dolio> The monomorphism restriction doesn't imply that there will be defaulting
17:49:20 <geekosaur> only top level bindings are affected. (although a similar restriction can be applied to let bindings if you have certain type-level extensions enabled; that one is controlled by MonoLocalBinds)
17:49:24 <augur> c_wraith: eg parsers consume characters and transition into new states to continue parsing, right
17:49:30 <stevenxl> c_wraith: ah I see. :t dodgy 1 is an expression. 
17:49:30 <dolio> There will only be defaulting if nothing else influences the types that must be monomorphized.
17:49:57 <stevenxl> oneIsDodgy = dodgy 1 is a binding - I'm binding the name oneIsDodgy to the expression dodgy 1. 
17:49:57 <geekosaur> dodgy 1 is an expression and :t gave you its type. it's only if you make a top level binding with that expression that it is monomorphized
17:49:58 <augur> c_wraith: but the consumption in a parser is ordered: it reads a thing, and then it reads another thing, and thats it, in that order, its fixed
17:50:12 <stevenxl> geekosaur: Thank you !
17:50:23 <dolio> Also the monomorphism restriction is not limited to top-level definitions.
17:50:46 <c_wraith> augur: Ok.  I think it's very important that values are being added incrementally. That's a detail I was missing.
17:50:48 <augur> i'd like something that's parser-like, but is order-independent, so that you can feed into symbols into it in arbitrary order
17:50:59 <dolio> Local definitions of the form 'x = ...' will be affected.
17:51:21 <ertes> augur: with incremental feeding?
17:51:33 <c_wraith> augur: with that in mind, you start to approach streaming library design.  Except you also want some emulation of non-deterministic reading.
17:51:34 <augur> ertes: yes
17:51:37 <geekosaur> hm, ok, I thought that got split off completely with MonoLocalBinds existing
17:51:52 <ertes> augur: then you have to engineer something (StateT alone can't be incremental)
17:51:58 <dolio> MonoLocalBinds makes every local definition monomorphic, I think.
17:52:00 <augur> c_wraith: yeah, its i guess some kind of message-passing-like thing too, right
17:52:03 <geekosaur> ...if not then I wonder if there can be "fun" interactions between those
17:52:15 <dolio> Or, every one with some other criteria, maybe.
17:52:42 <augur> but also there's an issue that i want to ideally be able to do this in a way that lets me bind things to variables
17:52:48 <c_wraith> dolio: I think it's just monomorphic in local context.
17:53:14 <ertes> augur: do you just not care about the order, or do you actually need to enforce that you will never receive the same value twice?
17:53:28 <ertes> augur: or do you need to enforce commutativity of reading?
17:54:05 <augur> ertes: uh.. i know (some) values will never be received twice, but some may be
17:54:17 <c_wraith> augur: this really sounds like you want something like STM.
17:54:27 <augur> c_wraith: really? why stm?
17:54:29 <ertes> augur: the thing is: enforcing commutativity is impossible without feeding everything upfront
17:54:41 <ertes> so no incremental
17:55:17 <ertes> augur: and if you simply don't care about the order, it sounds to me like any stream abstraction would do the trick, e.g. pipes
17:55:29 <c_wraith> augur: because it lets you wait until everything you need is available trivially, while updating what's available independently.
17:56:04 <augur> c_wraith: hm. im not sure that that's going to help here, but that's an interesting description of STM that ill have to look into for other reasons :)
17:56:22 <c_wraith> augur: fair enough. :)
17:56:26 <augur> im going to go get coffee and think some more about whether i can avoid this entirely
17:57:04 <ertes> alternatively you can use:  type PickyConsumer i = Free (State (Set i))
17:57:22 <ertes> that one can do something like STM, but without needing IO
17:57:32 <augur> basically the setting is: permutation parsing where the symbols are not simple
17:57:48 <augur> eg you have rules like   Foo(x,y) -> Bar(x), Baz(y)
17:58:00 <augur> where the order of the Bar(x) and Baz(y) nodes dont matter
17:58:11 <augur> and in fact the thing to be parsed isnt a string but is a set
17:58:14 <c_wraith> augur: in general, you end up solving that by having a processing step order the input in a way that plays nicely with the parser
17:58:42 <monochrom> I haven't thought of "Free (State X)". Now it looks interesting.
17:59:04 <c_wraith> Free yourself from the limitations of state.
17:59:15 <augur> c_wraith: *nod*
17:59:32 <ertes> monochrom: for any monad m you can view (Free m) as "m with suspend"
18:00:01 <c_wraith> I've used Free (Compose IO Foo) before.  That's a fun one.
18:00:04 <monochrom> yeah, it's how I understand it now
18:00:44 <ertes> c_wraith: you could have used FreeT Foo IO, i think
18:01:23 <c_wraith> ertes: does that play nicely with the next trick I had, which was traversing with unsafeInterleaveIO to preserve laziness while stripping out the composed IO?
18:01:51 <monochrom> an interpreter of Free (State X) is going to say: either a value and done; or a State effect I have to carry out, after that I have another Free (State X) to process at my leisure
18:02:12 <ertes> c_wraith: i think so, yeah
18:02:13 <c_wraith> I don't use Compose lightly.  :)
18:03:41 * hackagebot dns 2.0.8 - DNS library in Haskell  https://hackage.haskell.org/package/dns-2.0.8 (KazuYamamoto)
18:04:10 <monochrom> w00t I love unsafeInterleaveIO
18:04:39 <c_wraith> All I wanted was an IORef at every node, initialized to the same value.  IO's so strict about doing things at the right time, though..
18:04:47 <hpc> @remember monochrom w00t I love unsafeInterleaveIO
18:04:47 <lambdabot> I will remember.
18:04:52 <hpc> gotcha
18:04:59 <hpc> now when you run for president we can embarass you with it
18:05:00 <ertes> c_wraith: FreeT f m a ≃ a + m (f (FreeT f m a));  Free (m . f) a = a + m (f (Free (m . f) a))
18:05:03 <OutlawStar> -+
18:05:06 <ertes> c_wraith: so yeah, they seem to be the same thing
18:05:37 <monochrom> heh
18:05:54 <monochrom> I don't think I'll even run for ACM presidency
18:06:41 <monochrom> but do enjoy http://lpaste.net/77374
18:08:05 <dolio> All the good people like unsafeInterleaveIO.
18:08:31 <ertes> c_wraith: i wonder what would happen if you just used Control.Monad.ST.Lazy and stToIO
18:08:42 <ertes> without any unsafeInterleaveIO
18:08:51 <ertes> without any unsafeInterleaveST
18:10:05 <ertes> also why is there 'fixST'?  isn't that just mfix?
18:10:31 <dolio> What's the implementation of mfix for ST?
18:10:45 <monochrom> yes, it is mfix without needing to import the name mfix
18:10:49 <ertes> mfix = fixST
18:11:00 <dolio> Well there you go. :)
18:11:20 <ertes> =)
18:33:52 <ertes> does a functor between groupoids preserve inverses?  i.e. can i prove the following law without requiring it as an axiom?  inv-preserving : ∀ {A B} {f : C.Hom A B} → map (C.inv f) D.≈ D.inv (map f)
18:34:38 <dolio> ertes: Isomorphisms are preserved by functors.
18:34:53 <ertes> ah, indeed, thanks
18:37:56 <ccoc> If I take a given functor, what's the difference between the DSL produced by taking the fixed point of that functor and the Free of that functor? The Free version is more expressive? What sort of thing can I express in the Free DSL version that I can't in the fixed point DSL?
18:46:29 <ertes> ccoc: Free always includes the base case Pure
18:47:15 <ertes> also Free is constructed in such a way that it's always a monad
18:47:29 <ertes> Fix can produce a monad, but even if it is, there will be no instance
18:48:22 <Deeeezy> Hi
18:48:23 <ccoc> Right, I think I understand the mechanical parts. Not so much the implications for the language constructed
18:50:00 <ertes> ccoc: the main difference is the lack of the potential for Pure in every layer
18:51:12 <johnw> ccoc: also, the Free version could be expressed using Fix too; but not vice-versa
18:51:18 <ertes> ccoc: Free f a ≃ Fix (Const a + f)
18:51:24 <johnw> exactly
18:51:32 <johnw> i didn't think it was const a though
18:51:53 <johnw> but Free f a = Fix (Either a ∘ f)
18:52:17 <ertes> yeah, it's the same thing =)
18:52:27 <johnw> um, not at all
18:52:39 <dolio> One is composing with + and the other is using functor + with const.
18:52:46 <johnw> ah
18:56:04 <mutantmell> @dolio 'function +' ?
18:56:05 <lambdabot> Unknown command, try @list
18:56:16 <dolio> Functor.
18:56:22 <johnw> haha, I want an @dolio command
18:56:23 <mutantmell> er, yes, sorry
18:56:29 <dolio> (f + g) a = f a + g a
18:56:30 <Deeeezy> How do i get to a channel in criten?
18:56:36 <dolio> Point-wise.
18:56:38 <mutantmell> ok, thanks :)
18:56:46 <dolio> Where the second + is a different +, of course.
18:56:52 <mutantmell> yup yup!
18:57:23 <mutantmell> I didn't know what functor addition was :P
18:58:21 <mutantmell> Makes a good bit of sense though
19:06:41 <jazzycats> Hi, is there a snazzy way to get away with the first example of ispure in http://lpaste.net/286319 (i.e. without bindings)? My go at currying and composition seems to be no success
19:08:31 <johnw> jazzycats: it's not very pretty
19:08:51 <johnw> ((0 ==) .) . entry
19:09:00 <l_zzie> :t (.) . (.)
19:09:02 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:09:54 <johnw> I have never once see (.) . (.) in actual use; only here
19:10:17 <mutantmell> :t fmap.fmap
19:10:19 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:10:24 <mutantmell> I've used that one before
19:10:34 <johnw> i prefer naming it .:
19:10:39 <johnw> or just use points
19:11:02 <l_zzie> either works.
19:12:16 <l_zzie> I like (.:) because the name is suggestive of the purpose
19:12:23 <johnw> true
19:14:01 <jazzycats> (.:) is a neat idea for it, thank you!
19:33:38 <ertes> johnw: if i'd see code that actually uses that ass combinator, i'd probably not use it
19:34:28 <glguy> ertes: I was wondering what we were calling that operator
19:34:30 <ertes> or is that an ass-ass?  an ass cascade?  whatever it is, it's weird
19:36:03 * dmj` wonders if cabal clean should preserve configuration settings
19:36:36 <ertes> dmj`: see cabal clean -s
19:37:07 <dmj`> woa
19:37:09 <l_zzie> ertes I like to think of it as an owl
19:37:22 <l_zzie> :t ((.).(.))
19:37:24 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:37:59 <l_zzie> like those old owl clocks
19:38:01 <MarcelineVQ> yeah, an owl :>
19:38:06 <dmj`> ertes: def. a pro tip
19:39:14 <Welkin> the ass combinator?
20:03:44 * hackagebot game-of-life 0.1.0.5 - Conway's Game of Life  https://hackage.haskell.org/package/game-of-life-0.1.0.5 (marcusbuffett)
20:14:51 <joefromct> Hi, might be an off topic question, however i've been playing with FP for a few years and I tihnk i want to learn haskell.  In past years my preferred language has been some lisps so i'm curious about how i will find haskell without the polish notation () ... 
20:15:33 <johnw> you'll get used to the new notations after time
20:15:42 <joefromct> i guess i just hate the way list comprehensions work (for instance) in python, and really like it in clojure/other lisps.  I'm wondering what i'll think about haskell, and i think i'm going to invest some time in learning it. 
20:15:56 <johnw> i think you'll like it
20:16:15 <joefromct> ok, i'm going to set aside an hour a night and see how it goes. 
20:16:37 <Koterpillar> you can also write valid Haskell that looks exactly like Lisp
20:16:52 <joefromct> it would be great if i could get good enough to do a project for my day job, but my real attraction is i just hope to have more "ah ha" moments like the first time i learn FP with lisp-ish languages.
20:16:55 <johnw> or implement a Lisp in Haskell as a first exercise
20:17:05 <mauke> I can write valid Perl that looks exactly like Haskell
20:17:15 <mauke> not a great argument :-)
20:17:25 <sham1> But that would mean that Perl would actually be readable
20:17:32 <mauke> er. it is?
20:17:34 <sham1> And the circlejerk might nor like it
20:17:46 <joefromct> yeah, i'm going to put together a syllabus for myself and find some good learning resources that line up with my current FP level 
20:18:16 <joefromct> i'm a hadoop programmer, and we have a bunch of crappy programmers in the hadoop world.  it seems to me we should really study haskell. 
20:18:55 <joefromct> i'm never touching perl again :) 
20:19:18 <joefromct> unless i pass out on the keyboard and accidentally make a perl program (possible) 
20:20:09 <mauke> your chances are good if you hit # first
20:21:58 <joefromct> so what type of software do you folks typically build in haskell?  I know it can do anything, sorry for the general questions.
20:22:28 <mauke> silly IRC one liners
20:22:44 <mauke> :t let aaa _ [] = []; aaa a ((a -> aa) : (aaa a -> aaaa)) = aa : aaaa in aaa
20:22:46 <lambdabot> (t1 -> t) -> [t1] -> [t]
20:23:05 <ab9rf> joefromct: i use haskell to do bespoke ETL tasks
20:23:12 <ab9rf> conduit is lovely for that
20:23:24 <joefromct> ab9rf: ah ok thats sorta my place.  
20:23:28 <johnw> what do "bespoke" and "ETL" mean?
20:23:42 <ab9rf> johnw: ETL is extract-transform-load
20:23:59 <joefromct> yeah, it's when data warehousing people decided 'input processing output' was outdated 
20:24:00 <ab9rf> bespoke just means "custom-made for a single purpose"
20:24:25 <johnw> ah, thanks!
20:24:29 <joefromct> ab9rf: do you ever work over spark or hadoop?  what is you target usually (T) ? 
20:24:37 <ab9rf> joefromct: not usllay anything that large
20:24:43 <ab9rf> mostly smallish stuff
20:25:07 <sham1> Wouldn't hadoop be kind of overkill for a lot of stuff
20:25:14 <ab9rf> i haven't been doing much of that lately, been doing more parenting that programming
20:25:32 <joefromct> oh it sure is 
20:25:51 <ab9rf> it has to be a really freaking large ETL task to justify hadoop
20:26:04 <joefromct> hadoop is silly
20:26:24 <joefromct> it is my day job mostly b ecause execs were sold on it by sales people
20:26:46 <ab9rf> i also have a haskell library for reading minecraft files
20:27:12 <joefromct> i don't know, i know some folks h ave 1000 node clusters but for me, the largest i've been on was 64 
20:27:31 <joefromct> and i ended up just sharing NFS volumes and running clojure code parallel 
20:27:35 <ab9rf> which i need to update for some of the newer feature changes
20:28:04 <joefromct> ab9rf: are you going to teach your children haskell?  
20:28:27 <ab9rf> joefromct: my daughter has shown no interest in wanting to learn any programming language
20:28:28 <sham1> :P
20:28:43 <ab9rf> she fiddled with scratch for a while a few years back
20:28:44 <joefromct> ab9rf: ha, is that tuff for you?  I have a 5 month old. 
20:28:47 <ab9rf> but that's about it
20:28:59 <joefromct> ab9rf: and i feel like programming (logic) is life so i would be distraught 
20:29:00 <ab9rf> my son has shown somewhat more interest 
20:29:44 <ab9rf> i'm putting more energy into convincing her to push herself to learn more math
20:30:13 <joefromct> yeah thats probably a good idea.  one of my bigger regrets is not going further with math. 
20:32:38 <ania123> what this means?
20:32:39 <ania123> We will do our best to provide you with a decision and feedback shortly
20:32:56 <ania123> how long decision will take?
20:33:14 <johnw> i think you're asking in the wrong channel, ania123 
20:33:23 <ania123> ah sorry
20:34:09 <ab9rf> ania123: we'll do our best to provide you with an answer shortly.
20:34:16 <joefromct> i just joined a haskell fp meetup group in dallas.  :) i'm excited to learn a new language that i've been hearing about for 10 years. 
20:34:20 <joefromct> long overdue. 
20:34:28 <joefromct> lol
20:38:52 <jle`> congrats joefromct !
20:39:24 <jle`> are you from connecticut?
20:41:19 <joefromct> yeah but moved to texas old freenode name <joefromct> yeah thats probably a good idea.  one of my bigger regrets is not
20:41:19 <joefromct>             going further with math. 
20:41:20 <joefromct> *** afarmer (~afarmer@204.28.118.152) has joined channel #haskell  [22:30]
20:41:20 <joefromct> *** Sixmsj (~Sixmsj@c-73-223-134-226.hsd1.ca.comcast.net) has quit: Client
20:41:22 <joefromct>     Quit  [22:31]
20:41:26 <joefromct> *** redmq (~redmq@38.104.129.210) has joined channel #haskell
20:41:29 <joefromct> *** ania123 (5e89ad7a@gateway/web/freenode/ip.94.137.173.122) has joined
20:41:33 <joefromct>     channel #haskell
20:41:34 <joefromct> *** benjic (~benjica@host-69-145-150-244.msl-mt.client.bresnan.net) has joined
20:41:37 <joefromct>     channel #haskell  [22:32]
20:41:40 <joefromct> <ania123> what this means?
20:41:43 <joefromct> <ania123> We will do our best to provide you with a decision and feedback
20:41:44 <johnw> what's happening here?
20:41:45 <MarcelineVQ> stahp, freenode's gonna get mad :X
20:41:45 <ab9rf> oops
20:41:46 <joefromct>           shortly
20:41:49 <joefromct> <ania123> how long decision will take?
20:41:52 <joefromct> *** afarmer (~afarmer@204.28.118.152) has quit: Read error: Connection reset
20:41:54 <ab9rf> someone misoperated their client
20:41:55 <joefromct>     by peer
20:41:58 <joefromct> <johnw> i think you're asking in the wrong channel, ania123 
20:42:02 <joefromct> <ania123> ah sorry  [22:33]
20:42:06 <joefromct> *** afarmer (~afarmer@199.201.64.4) has joined channel #haskell
20:42:09 <joefromct> *** jedws (~jedws@119.17.160.225) has quit: Ping timeout: 250 seconds
20:42:12 <joefromct> *** jfischoff (~jonathanf@pool-96-246-91-244.nycmny.fios.verizon.net) has
20:42:12 <Axman6> :|
20:42:14 --- mode: ChanServ set +o johnw
20:42:15 <joefromct>     quit: Quit: jfischoff
20:42:17 --- kick: joefromct was kicked by johnw (Kicked by johnw)
20:42:20 <johnw> kick without ban
20:42:23 --- mode: johnw set -o johnw
20:42:30 <MarcelineVQ> $ irc &> irc
20:42:32 <Axman6> thanks johnw 
20:42:41 <ab9rf> seen that many many time
20:45:31 <joefromct> hi i'm really sorry about that mis-use i rarely use emacs erc and apparently i copied pasted trash 
20:46:19 <mutantmell> no problem :)
20:48:09 <bollu> I want to auto generate this code: -- newtype MC = MC(W a) | instance Comonad w => (MonoComonad MC) where ... when someone calls something like generateMonoComonad (MC)
20:48:25 <bollu> MC = is a newtype wrapper around some legit Comonad (which is the W)
20:48:32 <bollu> I want to auto-generate the MonoComonad instance on it
20:48:40 <bollu> I know it's possible, so I want to use template haskell to do this
20:48:48 <bollu> so, well, where do I get started with TH?
20:49:02 <bollu> or is there a way to hook into the deriving() mechanism?
20:49:16 <bollu> to allow someone to automatically derive MonoComonad?
20:49:39 <johnw> well, there's Generics, and as you said, TH
20:50:01 <bollu> which one gives me enough expressive power to do this? both?
20:51:30 <johnw> I haven't done it the Generics way before, where you provide a default definition for your MonoComonad member
20:51:55 <johnw> example: http://stackoverflow.com/questions/22850983/deriving-default-instances-using-ghc-generics
20:52:03 <bollu> ooh, thanks
20:52:05 <bollu> and for the TH way?
20:52:13 <johnw> with TH it would be very easy and straightforward, once you become familiar with the AST representation it uses
20:52:25 <johnw> that takes a little getting used it, but it's nothing special
20:52:38 <johnw> you literally just construct, AST-wise, the code you want to create
20:52:46 <bollu> hm, I see. that is pretty slick
20:52:49 <johnw> (or use quasi-quoting to help you out)
20:53:04 <bollu> for this, I would need a ConE constructor right?)
20:53:15 <bollu> http://hackage.haskell.org/package/template-haskell-2.11.0.0/docs/Language-Haskell-TH-Syntax.html#t:Exp <- I'm looking at this
20:53:19 <johnw> dunno; I never created an instance with TH
20:53:36 <johnw> lens has a makeClassy function that does this
20:53:39 <johnw> if you want an example
20:53:50 <bollu> yes, I'd like to look at it
20:55:31 <bollu> johnw: thanks for the references :) much appreciated
20:55:37 <bollu> johnw: are there any tradeoffs I need to be aware of?
20:55:43 <bollu> Generic versus TH?
20:55:56 <johnw> not having tried both, I can't say
20:56:28 <bollu> okay, very well
20:56:28 <bollu> ty
20:59:48 <bollu> ?
20:59:57 <bollu> johnw: what's  nice tutorial on template haskell?
21:01:35 <MarcelineVQ> I liked https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial
21:02:19 <johnw> i have some template haskell code here: https://github.com/jwiegley/recursors/blob/master/Control/Final.hs
21:31:08 <MichelleBachelet> @@@@ J@IN #wikimedia-ayuda @@@@
21:31:50 <chrismwendt> What would cause `-N8` to take 4x longer to execute and use ~11x CPU usage compared to `-N1`? I have some code that indexes files into Elasticsearch with multiple concurrent threads, and parallizing it seems to make it worse: https://gist.github.com/chrismwendt/619b7981043295fab90ba61c835eeb9e
21:31:58 <grantwu> Is there some way to add extra types to the ones recognized by OverloadedStrings?
21:32:12 <geekosaur> define an IsString instance
21:32:13 <grantwu> It would be nice I could get things automatically converted to ByteString builders
21:32:15 --- mode: ChanServ set +o glguy
21:32:15 --- mode: glguy set +b-bo *!*@gateway/web/cgi-irc/kiwiirc.com/ip.54.149.255.223 *!*@gateway/web/cgi-irc/kiwiirc.com/ip.92.40.249.72 glguy
21:32:36 <chrismwendt> grantwu: https://ocharles.org.uk/blog/posts/2014-12-17-overloaded-strings.html
21:33:26 <grantwu> chrismwendt: Thanks
21:39:47 <saurabhnanda> is there any blog/article which describes how GHC.Generics, Data.Data. Data.Typeable, and Data.Dynamic are related?
21:43:03 <ab9rf> there will be, when you write it :)
21:44:39 <saurabhnanda> is there any blog/article which describes how GHC.Generics, Data.Data. Data.Typeable, and Data.Dynamic are related? I'm trying to figure out if they are a replacement for TH (basically compile-time macros), or are they runtime meta-programming.
21:44:56 <geekosaur> (b)
21:45:28 <geekosaur> ...up to a point at least
21:48:39 <johnw> TH can always do more, because it can construct any code that you could have written
21:50:06 <geekosaur> as for the relationships, Typeable associates (compile-time generated) type data with values. Dynamic uses this to do type-safe "casting": cast will produce Nothing if the Dynamic value does not have the specified result type, else Just the value.
21:51:28 <geekosaur> Data is a low level interface using Typeable plus some additional compile-time-generated metadata to deconstruct values into their components. Generics uses that to provide a mid-level generic programming interface; higher level generics libraries (syb, uniplate, etc.) are built atop it
22:03:47 * hackagebot stb-image-redux 0.2.0.0 - Image loading and writing microlibrary  https://hackage.haskell.org/package/stb-image-redux-0.2.0.0 (sasinestro)
22:57:10 <coleman> Hi I'm just learning. How is my solution to euler 4? https://gist.github.com/JacksonGariety/21441e8c397a2a44580b0e75a8c6be8c
22:59:24 <coleman> I've been going through LYAH but I still don't quite have a grasp on best practices.
22:59:41 <coleman> Feedback for a newbie is much appreciated
23:01:09 <JuanManuelSantos> @@!!@@ J@IN #wikimedia-ayuda @@!!@@
23:01:46 <bollu> given a name
23:01:59 <bollu> given a Name, how do I check if a newtype with the name exists in TH?
23:02:20 <bollu> basically, I want to pass a newtype as a parameter, and I want the information about its declaration in the TH that I'm writing
23:03:48 * hackagebot typed-process 0.1.0.0 - Run external processes, with strong typing of streams  https://hackage.haskell.org/package/typed-process-0.1.0.0 (MichaelSnoyman)
23:03:51 <ania123> myconcat :: [[a]] -> [a]
23:04:00 <ania123> myconcat [x,[]] = x
23:04:29 <pavonia> bollu: Does lookupTypeName  work?
23:04:43 <bollu> pavonia: lemme see :)
23:04:43 <ania123> I want to write a function that concatenates a list of lists
23:04:45 <bollu> pavonia: ty 
23:05:20 <bollu> ania123: I'd recommend doing it recursively on the list-of-lists
23:05:44 <ania123> yes, that is what I need to do
23:05:52 <ania123> but I failed doing it 
23:05:59 <bollu> there are three cases: 1. list of lists is empty ([[]]) 2. list of lists has one elements [x] 3. list of lists has n elements (x:xs) <- x is a list, xs is the rest of the list of lsits
23:06:00 <ania123> is base case ok?
23:06:01 <bollu> lists*
23:06:09 <bollu> so can you tell me what will happen in cases 1, 2, 3?
23:06:23 <bollu> your case is specialised to only 2 lists. Solve for 1 list, 0 list, and then n lists :)
23:06:42 <daniel-s> :t fmap
23:06:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:06:55 <daniel-s> :k fmap
23:06:58 <lambdabot> error: Not in scope: type variable ‘fmap’
23:07:16 <bollu> daniel-s: yes, it's a function, so fmap will not have a kind
23:07:18 <bollu> :k Functor
23:07:20 <lambdabot> (* -> *) -> Constraint
23:07:24 <bollu> on the other hand, Functor has a kind
23:08:28 <ania123> myconcat [[]] = [] myconcat [[x]] = [x]
23:08:44 <bollu> pavonia: I'm looking for something along the lines of Name -> Maybe Type
23:08:57 <bollu> pavonia: Name -> Maybe (NewtypeDecl stuff) more like
23:09:06 <bollu> where I can get the newtype info from the Name if it exists
23:09:34 <ania123> bollu:
23:09:35 <ania123> myconcat :: [[a]] -> [a] myconcat [[]] = [] myconcat [[x]] = [x] myconcat x:xs = x ++ myconcat xs
23:09:44 <pavonia> bollu: For more info there's "reify"
23:09:44 <bollu> ania123: are you sure about the myconcat [[x]]? do you need to destructure the list two levels down? 
23:09:52 <bollu> ania123: or do you need myconcat [x] = x?
23:10:00 <bollu> pavonia: ty
23:10:11 <bollu> pavonia: TH is.. fun :)
23:11:06 <ania123> myconcat [[]] = [] myconcat [x] = x myconcat x:xs = x ++ myconcat xs
23:11:35 <ania123> bollu: is it ok?
23:11:46 <bollu> ania123: yep, that should work!
23:11:50 <ania123> thx
23:11:59 <bollu> ania123: you know that mconcat is a generic function in Monoid, right?
23:12:23 <ania123> no
23:12:27 <ania123> i do not know
23:12:36 <ab9rf> no it won't
23:12:38 <ania123> should i use deferent name
23:12:39 <ania123> ?
23:12:51 <ab9rf> myconcat [x] = x will not typecheck with the other equations
23:12:52 <ania123> pr1.hs:4:1: error: Parse error in pattern: myconcat
23:13:09 <ania123> i am getting this error
23:13:32 <ab9rf> sorry, my bad, i misunderstood the function
23:14:05 <bollu> ania123: I can you lpaste the file? I think the problem will be in myconcat x:xs. You will most likely need myconcat (x:xs)
23:14:07 <ania123> http://pastebin.com/zPa6pgx6
23:14:14 <ab9rf> it's the myconcat x:xs, uyou need parens
23:14:22 <ania123> ah
23:14:24 <ania123> yes
23:14:42 <ab9rf> also myconcat [[]] = [] is redundant with myconcat [[x]] = x
23:14:44 <MarcelineVQ> myconcat [[]] = [] and myconcat [x] = x are the same thing when x is [], the base case of any list is the empty list but [[]] isn't empty, it's a list of one element and that element is [], so you're missing the base case
23:14:46 <bollu> ania123: also, you don't need the special case for 1 list
23:15:08 <ab9rf> and you haven't covered the case of []
23:15:18 <bollu> ania123: yeah, sorry for the confusion.
23:15:36 <bollu> ania123: you need 2 cases: empty outer list [] and non-empty outer list (x:xs)
23:15:50 <ab9rf> you can just do myconcat [] = [] and myconcat (x:xs) = x ++ myconcat xs
23:16:48 <ania123> http://pastebin.com/UUhe96qH
23:17:15 <ania123> this also works
23:17:37 <ania123> myconcat [x] = x myconcat (x:xs) = x ++ myconcat xs
23:17:52 <ania123> is it ok?
23:17:55 <ab9rf> ania123: what's myconcat []
23:18:07 <ab9rf> test that, you'll get an error
23:18:43 <ania123> yes, but it has to concat list of lists
23:18:49 <ab9rf> [] is a list of lists.
23:18:50 <ania123> [] does not contain any list
23:18:51 <ania123> myconcat [ [ ] ]
23:18:59 <ab9rf> it's a list of zero lists.
23:19:00 <ania123> should return
23:19:01 <ania123> []
23:19:14 <ab9rf> [[]] is a list containing one empty list
23:19:18 <ab9rf> not the same as an empty list
23:19:20 <ania123> ah
23:19:23 <ania123> yes, u are right
23:19:58 <ab9rf> you wouldn't want to run into a fence post hole
23:30:10 <bollu> if I have a newtype N  = NCons (something)
23:30:18 <bollu> how do I pass the "N" to a splice?
23:30:26 <bollu> as in, the type itself?
23:30:27 <bollu> not the constructor
23:47:42 <bollu> I need to build the AST by hand, right?
23:47:47 <bollu> when I'm generating a Dec using TH?
23:54:19 <jle`> i wonder why 'vector' has generateM but not generateA
23:55:10 <jle`> for now i just have to generate and sequenceA
23:55:19 <jle`> but i can't even do that for Data.Vector.Storable
23:55:40 <sham1> Maybe they didn't feel the need to add generateA
23:56:11 <jle`> but why would they have generateM ?
23:56:22 <jle`> if that's the case?
23:57:25 <jle`> is there a fundamental reason from the implementation why they would implement the less-useful generateM instead of the much more useful and probably as easy to implement generateA ?
23:57:42 <jle`> generateA subsumes both functions and i think it's even easier to optimize
23:58:39 <jle`> i wonder how lens gets around this
23:59:12 <bollu> how exactly does [d| .. |] work
23:59:15 <bollu> what's the machinery?
23:59:17 <bollu> what is the type?
