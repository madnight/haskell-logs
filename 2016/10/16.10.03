00:07:38 * hackagebot helm 1.0.0 - A functionally reactive game engine.  https://hackage.haskell.org/package/helm-1.0.0 (ZackCorr)
00:07:38 * hackagebot publicsuffix 0.20161003 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20161003 (wereHamster)
00:30:22 <kqr> is there anything to generate an optparse-applicative parser from a data structure representing subcommands?
00:36:40 <Choups> guys I need help and I pay $$$: http://pastebin.com/6zpkNED3
00:36:41 <Choups> easy money guys
00:37:36 <liste> Choups: wrong channel
00:38:49 <EvanR> :t ($$$)
00:38:51 <lambdabot> error:
00:38:51 <lambdabot>     • Variable not in scope: $$$
00:38:51 <lambdabot>     • Perhaps you meant one of these:
00:39:12 <EvanR> :t ($) ($) ($)
00:39:14 <lambdabot> (a -> b) -> a -> b
00:39:33 <EvanR> fst full of $
00:42:39 <kqr> unrelated to previous question: is there a good library to handle configuration files for your program? where good means "i need to do as little work as possible"
00:43:12 <EvanR> hmm, uh https://hackage.haskell.org/package/ini-0.3.5/docs/Data-Ini.html
00:44:10 <EvanR> run the function on an ini file and get a  HashMap Text (HashMap Text Text)
00:45:36 <EvanR> comes with ways to parse particular entries with a couple of different readers/parsers
00:45:52 <EvanR> without deconstructing the HashMap
00:47:54 <koz_> Could anyone help me figure this one out? http://lpaste.net/239082
00:49:13 <NeverDie> What kind of PostgreSQL driver do you guys recommend to use with Haskell?
00:49:39 <koz_> NeverDie: Persistent with the PostGRE backend.
00:49:52 <koz_> If you wanna play with SQL, add Esqueletto.
00:50:10 <EvanR> also postgres-simple
00:50:14 <NeverDie> koz_: Persistent is the name of the package?
00:51:21 <koz_> NeverDie: Might be lower-case.
00:51:57 <kqr> EvanR, hm, might be what I need. cheers
00:52:45 <NeverDie> koz_: Thanks!
00:57:34 * hackagebot x509-store 1.6.2 - X.509 collection accessing and storing methods  https://hackage.haskell.org/package/x509-store-1.6.2 (VincentHanquez)
00:57:36 * hackagebot x509-system 1.6.4 - Handle per-operating-system X.509 accessors and storage  https://hackage.haskell.org/package/x509-system-1.6.4 (VincentHanquez)
00:57:38 * hackagebot x509-validation 1.6.5 - X.509 Certificate and CRL validation  https://hackage.haskell.org/package/x509-validation-1.6.5 (VincentHanquez)
01:07:09 <koz_> NeverDie: You're very welcome. :)
01:10:01 <koz_> :t curry
01:10:03 <lambdabot> ((a, b) -> c) -> a -> b -> c
01:11:39 <koz_> @pl \x -> x - 1
01:11:39 <lambdabot> subtract 1
01:14:16 <OnOut2k16> http://ilredentore.dynv6.net ost server :)
01:29:26 <jle`> hi all
01:29:32 <jle`> trying to hack around the lack of impredicative types
01:29:51 <jle`> say i had a newtype Showable = S (forall a. Show a => a)
01:30:03 <jle`> is there a nice way to turn a (forall a. Showable a => [a])) into a [Showable] ?
01:30:17 <jle`> er, wait
01:30:31 <koz_> jle`: Are you talking about existential types?
01:30:48 <jle`> RankN types
01:30:50 <koz_> Also, perhaps you might be able to help me too: http://lpaste.net/239082
01:31:24 <athan> @type 1.5e1
01:31:26 <lambdabot> Fractional t => t
01:31:30 <athan> @type 1.5
01:31:32 <lambdabot> Fractional t => t
01:31:35 <athan> @type 1
01:31:36 <lambdabot> Num t => t
01:31:41 <athan> @type 1e1
01:31:43 <lambdabot> Fractional t => t
01:31:46 <athan> :(
01:32:04 <jle`> the ugly way of doing what i want is just \xs -> zipWith (\i _ -> S (xs !! i)) [1..] xs
01:32:12 <jle`> but that's quadratic time or something isn't it?
01:32:17 <jle`> i feel like there should be a better way of doing it
01:33:19 <koz_> jle`: That would be quadratic time, due to the indexing.
01:33:31 <jle`> yeah, but this should only really need to be linear
01:33:36 <jle`> if the type system would let me v.v
01:34:09 <koz_> jle`: Could you use an intermediate vector?
01:34:22 <jle`> how?
01:34:44 <koz_> Convert xs to a vector and zip over that?
01:35:06 <koz_> Your indexing at least doesn't spin your into quadratic land, then.
01:35:08 <jle`> hm, how would that look like?
01:35:17 <lyxia> write your own zipWith?
01:35:37 <jle`> hm, one that can handle RankN types?
01:36:04 <lyxia> Or well, might as well write toShowableList directly
01:36:09 <jle`> i actually tried implementing it using explicit recursion first and haskell wouldn't let me, so i'm not sure if that'll be better
01:36:14 <jle`> yeah
01:36:16 <lyxia> oh?
01:36:23 <jle`> as soon as you pattern match, it fixes the type of the entire list
01:36:29 <jle`> and you can't recover the RankN-ness
01:36:34 <lyxia> ah, indeed
01:36:59 <jle`> maybe i would need to implement a custom list type
01:37:04 <jle`> idk
01:38:51 <koz_> \xs -> V.toList (V.generate (\i -> S (xs V.! i)) (V.fromList xs))?
01:38:56 <koz_> Or something?
01:39:19 <koz_> Sorry, my bad, wrong function.
01:39:33 <n98645> who knows a hackers irc ??
01:40:24 <n98645> who knows a hackers irc ch??
01:40:25 <koz_> Never mind, gonna leave it to jle`. Too tired to think.
01:40:30 <lyxia> jle`: it seems typechecking "case" is the only thing in the way, and you can work around it by using null/head/tail instead.
01:40:49 <jle`> lyxia: oh that's interesting
01:41:12 <koz_> Also, what's the other library for 'general monad-y stuff' other than monad-loops?
01:41:42 <NickHu> koz_: mtl
01:42:29 <n98645> ...
01:42:35 <jle`> koz_: johnw has a nice one but i always forget the name
01:42:57 <koz_> jle`: Maybe he'll notice and tell me.
01:44:47 <lyxia> jle`: I think it will be quadratic in any case actually.
01:45:02 <jle`> lyxia: i think it'd be ok if i recurse right?
01:45:06 <lyxia> Because the list is constructed *after* you pass a dictionary.
01:45:38 <jle`> hmm but lazily right?
01:48:18 <lyxia> In fact, you can't use null without specializing the list first.
01:48:43 <lyxia> Because the nullness of the list might depend on its type.
01:50:00 <jle`> whoa
01:50:02 <jle`> that's deep
01:50:28 <jle`> maybe i'll just do some major refactoring to never have the original (forall a. Show a => [a]) in the first place
01:50:42 <lyxia> I wonder how you even get such a value in the first place.
01:51:13 <jle`> well, Show here is just for demonstration, heh
01:51:19 <jle`> but you could easy get a (forall a. Num a => [a])
01:51:23 <lyxia> I see!
01:51:33 <jle`> but good point :p
01:51:55 <cocreature> koz_: jle`: maybe you are talking about monad-extras?
01:51:57 <jle`> well, i really wanted a [forall a. Num a => a] from the beginning
01:52:18 <jle`> cocreature: oh yes that was it
01:52:50 <jle`> thanks!
01:52:53 <lyxia> So everytime you want to get an element of your [Numable] list, you have to choose a type for it, then your initial (forall a. Num a => [a]) gets applied to the corresponding dictionary producing a new list, which you have to traverse from the beginning to get the corresponding element.
01:54:47 <jle`> oh huh
01:54:49 <jle`> yeah
01:54:56 <jle`> well i'll just refactor from the beginning then i think
01:57:35 * hackagebot ghc-dump-tree 0.2.0.2 - Dump GHC's parsed, renamed, and type checked ASTs  https://hackage.haskell.org/package/ghc-dump-tree-0.2.0.2 (EdskoDeVries)
01:57:37 * hackagebot terminal-progress-bar 0.1.1 - A simple progress bar in the terminal  https://hackage.haskell.org/package/terminal-progress-bar-0.1.1 (RoelVanDijk)
01:58:40 <koz_> cocreature: Thank you!
01:58:46 <cocreature> np
02:06:40 <koz_> I less-than-three monads right now.
02:10:19 <koz_> zip <$> pure children <-- this is actual code I just had to write
02:10:24 <koz_> I ought to pick better variable names...
02:10:48 <liste> koz_: unzip would be more awkward
02:10:55 <koz_> liste: ....
02:11:41 <mauke> isn't that just pure (zip children)?
02:12:37 <koz_> mauke: Yes, but what I wrote made me feel a bit weird. Then liste lifted it into the Humour monad.
02:14:35 <Athas> I have decided to practice with a pen whenever I am waiting for compilers etc.  I never knew programming in Haskell would improve my handwriting so much.
02:16:52 <koz_> Athas: In my case, my drawing.
02:17:34 <Athas> Compile-time is a time for quiet reflection.
02:18:11 <koz_> Athas: Especially if you have lens as a dependency.
02:19:00 <Athas> Actually, I find that linking is what takes forever.  I guess that's not really GHC's fault.
02:19:25 <Athas> But I have nine executables for this project, which may be an edge case.
02:20:15 <koz_> Seeking critique and suggestions on better coding: https://paste.rel4tion.org/405
02:20:32 <koz_> Also, seeking help with this lens-related issue, if anyone could: http://lpaste.net/239082
02:21:31 <lyxia> :( "Down for maintenance"
02:22:11 <merijn> Athas: Which OS?
02:22:28 <koz_> lyxia: Oh ${DEITY}-damn it...
02:22:36 <Athas> merijn: AMD64 GNU/Linux.
02:22:41 <Athas> I take it you'll recommend using gold?
02:23:42 <merijn> Athas: I was going to ask if you were using it, yes :p
02:23:54 <merijn> Especially since the pre-gold linux linker was retarded as hell
02:24:15 <Athas> I'm not.  Does it make a huge difference?  And is there a nice way to use it except for constantly passing --ghc-options to stack?
02:24:17 <merijn> I had so many issues moving my code from OSX to dealing with the old linux-ld's shit
02:24:38 <Athas> As I remember it, GHC triggered a worst-case behaviour in GNU ld's hash table implementation, but that was years ago.
02:24:43 <lyxia> koz_: you can makeChildren with mapM f . take i . cycle $ ixes
02:24:57 <merijn> Athas: I'm not sure if it makes a lot of difference, I only know: 1) gold was supposed to be much better than old ld and 2) old ld is stupid
02:25:58 <lyxia> koz_: uh, that should be something more complicated than f, but I hope you get the point
02:26:48 <koz_> :t cycle
02:26:49 <lambdabot> [a] -> [a]
02:27:20 <koz_> lyxia: Thanks - I was wondering if something like this existed.
02:27:32 <cocreature> koz_: do you need your vectors to be immutable? update1 is something that is a lot more efficient on a mutable vector
02:27:51 <koz_> cocreature: Nope - I was gonna change to mutable vectors inside of ST, but just don't know how to.
02:27:53 <lyxia> koz_: empty lines between imports look odd
02:28:08 <cocreature> it looks like at least the "go" function in compete could work on a mutable vector
02:28:08 <koz_> lyxia: Really? Always seemed OK to me...
02:28:21 * lyxia shrugs.
02:28:24 <cocreature> I use empty lines between imports to group imports into blocks
02:28:29 <merijn> cocreature++
02:28:31 <koz_> cocreature: I think I could probably do the whole ev function on a mutable vector inside ST.
02:28:51 <cocreature> koz_: yeah if that’s possible I would recommend that
02:29:14 <koz_> cocreature: It should be - I do basically all the work inside the 'loop' there, and only return the Vector to the outside world at the end.
02:29:19 <koz_> It seems pretty much textbook ST.
02:29:26 <cocreature> yeah
02:29:49 <koz_> I just need to learn how the heck to do that (never tried before).
02:30:11 <koz_> :t mapM
02:30:13 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:30:17 <lyxia> koz_: you can also pattern match directly in compete rather than define the auxiliary go.
02:30:38 <koz_> lyxia: Yeah, good point. Probably ought to do that.
02:32:00 <lyxia> koz_: zip <$> pure kids <*> fmap f w    =    fmap (zip kids . f) w
02:32:58 <lyxia> These are all minor stylistic tweaks though.
02:34:03 <koz_> lyxia: Applicative laws, amirite?
02:37:12 <lyxia> yeah
02:37:29 <koz_> I'm still getting the hang of those - thanks!
02:40:09 <koz_> Alrighty, time to figure out how to ST.
02:40:54 <koz_> cocreature: Should I be looking at Data.Vector.Mutable for this?
02:47:25 <lyxia> koz_: you've got a Lens s t a a where s /= t, but ^. expects something like Lens s s a a. It seems you can use "getting" to convert your lens.
02:47:50 <cocreature> koz_: yes, if you don’t have generic vectors you can also look into Data.Vector.Unboxed.Mutable which is potentially faster but probably not worth the trouble if you don’t have something like a vector of Int
02:49:43 <koz_> :t getting
02:49:45 <lambdabot> (Contravariant f, Functor f) => LensLike f s t a b -> LensLike' f s a
02:50:04 <koz_> :t (^.)
02:50:05 <lambdabot> s -> Getting a s a -> a
02:50:39 <koz_> lyxia: What would I do in this case, then>
02:50:41 <koz_> ?*
02:50:41 <lambdabot> Maybe you meant: v @ ? .
02:51:05 <koz_> cocreature: Nah, I have generic vectors. Mutable it is, then.
02:51:13 <lyxia> x ^. getting popL
02:51:33 <koz_> lyxia: Ah, I see. Thank you!
02:51:43 <cocreature> koz_: your update1 function is then just "set" (with a slightly different type)
02:51:45 <lyxia> heh, "POPL"
02:52:04 <koz_> cocreature: I'm gonna have to read on how to ST. Do you have any pointers?
02:52:19 <koz_> lyxia: Thanks!
02:52:51 <cocreature> koz_: sorry no. but it’s really quite easy to “just use it”. it’s just some abstract monad in which you can run your operations and when you’re done you run runST
02:53:46 <koz_> cocreature: In that case, I'm gonna need a transformer, because I'm already in Rand.
02:54:38 <cocreature> there is a RandT somewhere
02:55:02 <cocreature> https://hackage.haskell.org/package/MonadRandom-0.4.2.2/docs/Control-Monad-Random.html#t:RandT
02:55:30 <koz_> cocreature: So I'd have RandT g (STVector s a)?
02:57:30 <cocreature> not quite, you need RandT g (ST s) a
02:57:52 <cocreature> eh RandT g (ST s) (MVector s a)
02:59:04 <koz_> cocreature: Ah, I see.
03:00:45 <Myrl-saki> Profunctors are pretty cool.
03:05:09 <Myrl-saki> liste: How about here?
03:05:20 <Myrl-saki> liste: I think the convo will be most appreciated here.
03:05:56 <MarcelineVQ> will ST be needing something from Rand?
03:05:58 <liste> Myrl-saki: sounds good
03:06:20 <Myrl-saki> liste: So, like. I'm working on a game.
03:07:32 <Myrl-saki> liste: And well. Physics.
03:08:09 <koz_> MarcelineVQ: The entire computation relies on a lot of RNG.
03:08:18 <Myrl-saki> liste: Good so far?
03:08:25 <liste> Myrl-saki: yes
03:08:48 <Myrl-saki> liste: So. I'm implementing physics using integration.
03:09:35 <Myrl-saki> liste: So, first problem I'm having.
03:09:41 <Myrl-saki> liste: I want composability.
03:10:45 <Myrl-saki> Oh wait.
03:10:48 <Myrl-saki> Errr
03:10:56 <Myrl-saki> Stupid question.
03:10:58 <koz_> lyxia: Does microlens provide 'getting'?
03:11:02 <koz_> I can't seem to find it there.
03:11:17 <Myrl-saki> Errr...
03:11:25 <Myrl-saki> Okay.
03:11:57 <Myrl-saki> liste: Actually, my first problem is defining the underlying monad.
03:12:17 <kqr> anyone familiar with optparse-applicative? after parsing the mandatory string arguments, I want to take the rest of the arguments and count them as a single space separated string argument. I understand this breaks unix slightly, but is it possible?
03:12:22 <liste> Myrl-saki: what FRP library are you using?
03:12:40 <Myrl-saki> liste: And well. It's a puzzle game. It's simple pushing/pulling of blocks and hanging on ropes.
03:12:42 <Myrl-saki> liste: Wires.
03:14:52 <liste> Myrl-saki: maybe IO then?
03:15:41 <Myrl-saki> liste: Yeah. That's what I'm considering.
03:15:55 <Myrl-saki> For now, at least.
03:17:36 <Myrl-saki> liste: Now, the biggest question is the physics.
03:17:50 <Myrl-saki> I'm doing composition.
03:17:54 <Myrl-saki> Err
03:18:10 <Myrl-saki> I want composition, but I'm not exactly sure how I should go about it.
03:18:54 <Myrl-saki> Should I have a wire  `:: Wire m a (Either Position Acceleration`?
03:21:49 <lyxia> koz_: I can't see anything relevant either. Looks like you'll have to define your own.
03:21:50 <piyush-kurur> question regading stack
03:22:10 <piyush-kurur> suppose i build a project using stack as follows 
03:22:15 <liste> Myrl-saki: what would that wire do?
03:22:20 <piyush-kurur> stack install 
03:22:32 <koz_> lyxia: Or just pull in lens...
03:22:39 <piyush-kurur> then how do i run that version from outside the project
03:23:05 <piyush-kurur> I am trying out yi and I do not want to always go to the project directory just to run the editor
03:26:13 <liste> Myrl-saki: an integrator would be something like `:: Wire m Acceleration Position'
03:26:54 <liste> Myrl-saki: though not exactly
03:27:45 <liste> more like `:: Wire m (Event Acceleration) (Event Position)`
03:28:22 <liste> or even `:: Wire m (Event AccelerationOrTick) (Event Position)`
03:30:33 <liste> at least it'd work like that and reactive-banana, and wires seems very similar
03:31:41 <liste> wires are stateful, events are stateless
03:31:42 <Myrl-saki> liste: Yes.
03:32:30 <lyxia> koz_: it appears the reason Getting has this restricted definition is that it got in the way of type inference with very polymorphic lenses.
03:34:09 <liste> and then you can put a `hold' after it to have `:: Wire m (Event AccelerationOrTick) Position' 
03:37:25 <koz_> lyxia: Ah, well, given what I had to go through with the lenses I wrote, I can understand.
03:37:32 <koz_> GHC was *already* getting horribly confused.
03:50:36 <YellowOnion> :t uncurry
03:50:38 <lambdabot> (a -> b -> c) -> (a, b) -> c
03:51:36 <kqr> piyush-kurur, if you've run stack install it should be somewhere in your path
03:52:02 <kqr> piyush-kurur, if it's not, you may want to either add whereever it is to your path, or copy the binary to somewhere in your path
03:52:25 <kqr> piyush-kurur, one of the last lines of the stack install output should tell you where the executable is
03:57:37 * hackagebot call-stack 0.1.0 - Use GHC call-stacks in a backward compatible way  https://hackage.haskell.org/package/call-stack-0.1.0 (SimonHengel)
03:57:46 <piyush-kurur> kqr: thanks but yi is more complicated than that so I am asking the question on #yi 
03:58:24 <kqr> piyush-kurur, oh dear. well I hope you get a good answer!
04:00:35 <lyxia> kqr: have you tried using many from Applicative to parse all remaining arguments as a list of positional arguments?
04:01:34 <lyxia> Alternative*
04:06:22 <kqr> lyxia, no, but that might be a good idea!
04:10:46 <kqr> for some reason that hits some sort of infinite loop
04:11:07 <kqr> ah because of the default argument of course
04:11:14 <kqr> suddenly it found *very many* arguments...
04:21:28 <yulax> hmm, maybe it would be interesting to develop an operating system based on functional programming concepts
04:22:07 <yulax> does haskell compile to native code, or does it run in a simulator of some sort?
04:22:16 <MasseR> native
04:23:36 <liste> yulax: metasepi tried to use Haskell in kernel code http://ajhc.metasepi.org/
04:23:49 <liste> yulax: nowadays they're using ATS, which is more suitable for that
04:24:55 <liste> it's a FP language too
04:27:29 <merijn> yulax, MasseR: Pedantic note: *GHC* compiles to native code. Haskell is just a language, with no particular specification on it's execution :)
04:27:44 <MasseR> merijn: good point
04:28:00 <liste> Hugs used to be popular, it's a Haskell interpreter
04:29:05 <yulax> merijn: good point
04:29:39 <kqr> anyone got experience with writing network/UDP code and conduit? the documentation is a bit dense in conduit terminology, which I'm not 100% familiar with yet. my end goal is to create a UDP server which either waits for a message and then returns, or returns after 10 minutes, whichever comes first
04:29:45 <kqr> s/and/in/
04:30:19 <yulax> i suppose one could produce a haskell compiler with optimisations/new features designed to make haskell better for systems programming and development
04:31:01 <kqr> there are some examples online but I feel like they may be using an older version of conduit... maybe
04:31:29 <liste> yulax: metasepi did. but Haskell has very deep requirement for garbage collection, which may be a problem
04:35:13 <kqr> TCP would be fine too. it appears sourceSocket does not do any resource handling which sounds bothersome. runTCPServer looks nice, but from a cursory glance there's no way to signal the server process that it should terminate from a children process
04:37:58 <kqr> maybe conduit is overkill for this
04:42:48 <haskell161> hi guys , i am writing a program get roots of a quadratic equation 
04:43:09 <haskell161> getroots a b c = let 
04:43:20 <haskell161> so how do i make (-b)
04:43:46 <liste> @paste -- haskell161
04:43:46 <lambdabot> Haskell pastebin: http://lpaste.net/
04:43:57 <liste> please paste your code there ^
04:44:00 <haskell161> http://lpaste.net/239464
04:44:35 <haskell161> in line 4 and 5 can i use something else to make (-b)
04:46:06 <MarcelineVQ> > negate 3
04:46:09 <lambdabot>  -3
04:46:17 <haskell161> ok thanks 
04:46:20 <haskell161> thanks
04:47:11 <haskell161> i was searching unary in google and on hoogle
04:48:01 <liste> > let b = 27 in (-b) -- works too but has gotchas
04:48:03 <lambdabot>  -27
04:51:44 <ertesx> Myrl-saki: pong
04:52:46 <karanlearns> test
04:52:52 <Myrl-saki> ertesx: I feel like the problem was related to this. d <- scan 0 -< (const t) <$ e <!> subtract <$> deltas
04:53:37 <Myrl-saki> Actually, no.
04:53:50 <Myrl-saki> ertesx: Either that or the if-else construct.
04:57:38 * hackagebot argon2 1.2.0 - Haskell bindings to libargon2 - the reference implementation of the Argon2 password-hashing function  https://hackage.haskell.org/package/argon2-1.2.0 (OliverCharles)
04:57:40 * hackagebot SFML 2.3.2.4 - SFML bindings  https://hackage.haskell.org/package/SFML-2.3.2.4 (sulami)
04:57:42 * hackagebot cblrepo 0.23.0 - Tool to maintain a database of CABAL packages and their dependencies  https://hackage.haskell.org/package/cblrepo-0.23.0 (MagnusTherning)
04:59:11 <ertesx> Myrl-saki: but neither of that *should* be related…  still trying to reproduce
04:59:35 <Myrl-saki> ertesx: https://gist.github.com/Myrl/acbf07556828a057b40c0fbe1ae82f98
04:59:40 <Myrl-saki> ertesx: That's the whole file.
05:00:06 <hpc> heh, that package capitalizes cabal like it's COBOL
05:00:34 <hpc> CABAL, the package manager for turbo haskall
05:01:01 <dhananjay> Hi! I'm planning to give a short intro about haskell where I work. Its mostly to tell people about the study group me and a buddy running, we try to work through the haskell book together.
05:01:24 <dhananjay> Any suggestions or links to the presentations touching same topics?
05:01:50 <ertesx> Myrl-saki: thanks, i'll try to incorporate the relevant changes into the non-SDL ping-pong and start to narrow it down from there
05:02:59 <ertesx> dhananjay: a common mistake is to be unable to answer the "what's the point?" question properly, especially w.r.t. algebraic patterns like monoids and monads
05:05:14 <dhananjay> Yes, I agree. I've thought about it. Honestly I don't think I've a subset of features that I can introduce quickly and still express the point
05:05:28 <ertesx> recently a watched a talk of a guy to a C++ group…  he introduced algebraic patterns like monads, but completely missed the point of using them: to be able to *abstract* over them…  as a result the audience wasn't half impressed
05:05:45 <ertesx> "what's the point?" – "uh…  it's…  nice…  you see…  these are nice patterns…  uhm…  because…"
05:06:35 <hpc> first-class IO might be a good stand-alone feature, if you can get them past writing in a very un-C-like style
05:07:07 <hpc> showing how nice things like forkIO are, and how to write your own control flow
05:07:32 <hpc> dhananjay: what languages does your company currently use?
05:08:15 <dhananjay> Python, a bit of go and JS
05:09:11 <hpc> so do-notation shouldn't look quite so alien to them, theoretically
05:09:53 <hpc> js definitely has a lisp-like functions with functions as arguments which take functions as arguments which ... style
05:10:15 <dhananjay> I'm skeptical about that. Everybody seems to have their own JS syntax
05:10:25 <ertesx> another good stand-alone feature is lenses, but you need to show how lenses are *not* like object accessors…  how traversals can point to many things and still compose naturally, how lenses can point to things that are *not* fields, how lenses can point to things that are not simple values, etc.
05:11:02 <dhananjay> ertesx: good idea.
05:11:10 <veke> I have a sum type data Modifier = Public | ... | Synchronised (deriving ..., Show, ...) and for all the options I want to use the default show (which is derived automatically) however for one - Synchonised - I want to change it. Is there a way to do this? Or do I have to implement show manually for all?
05:11:19 <ertesx> don't worry about looking alien…  haskell *is* alien to most people, and you shouldn't try to hide it
05:12:14 <dhananjay> haha, I'll keep that in mind. 
05:12:19 <somaReve1> Hi, what is the type of '<0' ? is it a function currying?
05:12:41 <liste> yeah, lens' "jquery for data" functionality can look pretty nice (:
05:12:41 <ertesx> dhananjay: i'd take hpc's suggestion, too…  IO with first-class actions is really nice…  every time i show an implementation of 'replicateM' (i usually call it 'times'), it blows some people away
05:12:44 <kqr> somaReve1, inside parentheses, yes
05:12:50 <liste> somaReve1: it's called a section
05:12:52 <hpc> somaReve1: like that it's not an expression, however...
05:12:56 <hpc> :t (<0)
05:12:56 <kqr> somaReve1, (<0) means "\x -> x < 0"
05:12:58 <lambdabot> (Ord a, Num a) => a -> Bool
05:13:12 <kqr> somaReve1, the syntactic sugar responsible is called "operator section(s/ing)"
05:13:24 <hpc> look at it as "_ < 0" with something you haven't passed yet as the missing parameter
05:13:51 <hpc> when it's the other way, it does work out to be currying
05:14:00 <ertesx> dhananjay: main = 3 `times` putStrLn "Hello world."  -- =)
05:14:13 <hpc> (0<) would be (<) 0, which is \x -> 0 < x
05:14:29 <ertesx> s/replicateM/replicateM_/
05:14:58 <somaReve1> thanks!
05:15:26 <dhananjay> ertesx: hpc yes, that sounds quick and easy to explain.
05:16:32 <dhananjay> IO, lenses and data type magic and hope people gets it.
05:16:39 <hpc> dhananjay: oh, a big benefit of first-class IO is it sails right by the "what's the point" question by being... well IO
05:17:46 <ertesx> IO…  my favourite evil type =)
05:18:24 <hpc> ooh, if you want a neat library to make some really visible demonstrations with, check out juicypixels
05:19:15 <kqr> hpc, does that mean people don't ask "what's the point" when you explain first-class IO?
05:19:21 <lyxia> veke: you have to implement it manually
05:21:39 <tdammers> I just realized something - you know how they say that Haskell's types are often sufficient documentation?
05:21:45 <veke> lyxia: ok, thanks
05:21:55 <ertesx> dhananjay: if your audience goes into your presentation with some background they might ask ugly questions, but keep in mind that the answer to most questions is abstraction: "why do you use monads?" – "the reason why haskell code is often shorter and more maintainable/refactorable is that we can abstract over many programming patterns, monads being one of them…  it's DRY taken to the max"
05:21:56 <tdammers> I believe they're not, but they do provide a very good starting point for building documentation
05:22:03 <hpc> kqr: either it never occurs to them, or you have a much easier time answering
05:22:21 <tdammers> i.e., instead of starting with nothing (like you would, say, in Python or Clojure), you start with the types
05:22:43 <tdammers> and the types alone already provide most of the documentation structure - what depends on what, etc.
05:22:55 <ertesx> kqr: at that point you have already explained the point of IO: first-class actions, and the ability to abstract over them that comes with them =)
05:23:05 <hpc> tdammers: i usually take that saying to mean that in a well-designed library the type signature plus the name of the thing gets you at least 95% of the way to using it
05:23:17 <hpc> so like
05:23:20 <hpc> :t hGetContents
05:23:22 <lambdabot> error:
05:23:22 <lambdabot>     • Variable not in scope: hGetContents
05:23:22 <lambdabot>     • Perhaps you meant one of these:
05:23:26 <tdammers> hpc: yes, that too, but I never realized how big of a deal the structuring thing is, in practice
05:23:27 <somaReve1> Hi, why do we need to declare functions while the compiler could infer the types for us?
05:23:28 <hpc> @hoogle hGetContents
05:23:30 <lambdabot> System.IO hGetContents :: Handle -> IO String
05:23:31 <lambdabot> GHC.IO.Handle hGetContents :: Handle -> IO String
05:23:31 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
05:23:43 <hpc> that type signature and the name of the function gets you almost all the way
05:23:52 <tdammers> yes, I know all that very well
05:23:57 <hpc> pretty much all you need then is -- | it gets the contents lazily
05:24:06 <liste> somaReve1: because it makes finding errors easier
05:24:14 <hpc> ah, yeah
05:24:23 <tdammers> the epiphany is that it also gives Haddock all the information it needs to also create a concisive list of cross-links
05:24:39 <liste> somaReve1: and serves as compiler-checked documentation for other developers
05:24:49 <ertesx> somaReve1: you don't *need to*, but you *should*
05:25:03 <liste> somaReve1: and avoids the dreaded monomorphism restriction
05:25:08 <somaReve1> ok, so it's some kind of lint stuff right
05:25:11 <somaReve1> ?
05:25:12 <dhananjay> I could use juicypixel to show off some higher level functions, map, filter etc
05:25:18 <ertesx> somaReve1: one reason is that a quick look at the code may not reveal that much, not even the number of arguments (if there is any)
05:26:11 <ertesx> somaReve1: i find code without top-level type signatures so difficult to read that i often simply don't bother reading it
05:26:12 <hpc> somaReve1: so you don't have to go :t thisComplicatedThing in ghci every time you forget
05:26:55 <hpc> somaReve1: and so you can say "this is the type i want it to have", and it can reject programs that are well-typed but not what was desired
05:28:22 <somaReve1> hpc: cool, thanks
05:28:30 <lyxia> sometimes you write a function incorrectly but it still typechecks, and then you get an incomprehensible error at its use site
05:28:51 <hpc> oh yeah, and that
05:29:23 <hpc> type signatures "pin down" types, so ghc is able to recognize that foo is correct and it's bar's use of foo that's wrong
05:29:59 <hpc> i am sure the ghc devs have their own word for it
05:30:14 <ertesx> somaReve1: keep in mind that GHC *knows* the type…  if you write a type signature, you're not *declaring* the type, you're rather *assert* it
05:30:28 <somaReve1> ertesx: ah, i see
05:30:51 <ertesx> so type signatures are documentation of intent, and GHC will happily check if your intent matches your implementation
05:31:44 <somaReve1> hmm, why does haskell use 'data' instead of 'class' or 'type' keyword to define a type?
05:31:58 <hpc> because class and type do other things
05:32:07 <ertesx> 'class' would be inappropriate, the rest is just…  history…
05:32:08 <hpc> and because it was the 80s or something
05:32:36 <hpc> certainly if it was made today with zero historical influence, i would pick 'type' instead of 'data' and 'alias' instead of 'type'
05:33:05 <ertesx> they might just as well choose the same terms anyway
05:33:09 <ertesx> 'data' is quite common
05:33:37 <hpc> yeah probably
05:33:54 <hpc> it does make it easier to say "the data keyword defines a datatype"
05:34:44 <somaReve1> hmm, is there any serious projects that are suit for haskell new learners?
05:34:50 <joe9> this is a datatype that I want to pretty print (groom) easily. https://paste.pound-python.org/show/oh0GDhkyBGVGBk6bpKe1/  I did this: https://paste.pound-python.org/show/paXVlqrkfbi180msxk7P/
05:35:01 <joe9> just want to check if there is a better way of doing it.
05:35:34 <ertesx> somaReve1: haskell is suitable for most things these days, so really just pick anything you'd like to implement that isn't under time pressure
05:36:30 <hpc> as far as existing projects go, pandoc might be a good thing to start with if you want to try pull requests
05:36:35 <hpc> but i wouldn't start with that right away
05:36:52 <lyxia> joe9: you could make ShowState a field of State
05:37:37 <ertesx> joe9: style note: you went through the trouble of documenting all those fields…  if you use comment syntax that haddock recognises, it will include them in the generated module docs =)
05:38:05 <ertesx> like:  myField :: MyType,  -- ^ My documentation of this field.
05:38:21 <somaReve1> hpc: ok. What else would you suggest?
05:38:23 <hpc> or -- | above
05:40:17 <hpc> somaReve1: pretty much what ertesx said, pick something you would want to have that you can spend free time on
05:40:24 <hpc> my first project was an irc bot
05:47:39 <dhananjay> ertesx: yeah, but just stating that wouldnt help is the whole point. i guess i can just explain the replicateM a but further if somebody asks that
05:48:40 <hpc> oh, here's a good example perhaps
05:48:43 <hpc> :t forkIO . forever
05:48:45 <lambdabot> error:
05:48:45 <lambdabot>     Variable not in scope: forkIO :: f b0 -> c
05:48:50 <hpc> >:(
05:49:06 <hpc> anyhoo forkIO . forever is a function that takes an IO action and performs it over and over in a new thread
05:49:47 <somaReve1> Is haskell suitable for solving algorithm problems?
05:50:34 <Lowl3v3l> somaReve1, haskell is a turing complete general purpose language.
05:51:48 <joe9> ertesx: Thanks for the note about comment. will do that. good idea.
05:53:10 <Kuros-> some cellular automata are turing complete too
05:53:53 <JonReed> Hi, attoparsec's parseOnly tries parser only on the beginning of a input. Is there a way to search the whole input to see if a parser matches anywhere? 
05:53:55 <joe9> ertesx: adding ShowState as a field of State adds another level of indirection to State and I am trying to avoid using lens for this.
05:54:21 <dhananjay> ertesx: hpc thanks for the input. :)
05:57:39 * hackagebot parconc-examples 0.4.5 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  https://hackage.haskell.org/package/parconc-examples-0.4.5 (SimonMarlow)
05:57:41 * hackagebot glider-nlp 0.4 - Natural Language Processing library  https://hackage.haskell.org/package/glider-nlp-0.4 (klangner)
06:05:59 <karanlearns> how to make division function with parameters created by newtype or data keywords ?
06:06:11 <karanlearns> http://lpaste.net/239529
06:06:33 <karanlearns> so that user (other programmer ) does not mistakenly reverse the parameters/args while calling the function
06:09:37 <c_wraith> karanlearns: you need to pattern-match the arguments and construct the result.
06:09:55 <JonReed> karanlearns: division' (Numerator' a) (Denominator' b) = Result' (a `div` b)
06:10:02 <c_wraith> karanlearns: also, (/) isn't defined for Int...  Did you maybe mean to use Double?
06:10:12 <c_wraith> or the div function, as JonReed points out
06:14:04 <ongy> looking at https://ghc.haskell.org/trac/ghc/wiki/TypeApplication what's the difference between 'map @Int @Bool isEven xs' and 'map (isEven :: Int -> Bool) xs'?
06:14:39 <merijn> ongy: Nothing
06:15:22 <ongy> then why the extension? because parens are ugly?
06:15:45 <c_wraith> > show . read $ "11"
06:15:47 <lambdabot>  "*Exception: Prelude.read: no parse
06:15:51 <c_wraith> > show . read @Int $ "11"
06:15:54 <lambdabot>  error:
06:15:55 <lambdabot>      Pattern syntax in expression context: read@Int
06:15:55 <lambdabot>      Did you mean to enable TypeApplications?
06:16:06 <c_wraith> ...  darn you lambdabot
06:16:13 <c_wraith> anyway, does that answer the question?
06:16:21 <c_wraith> It's *way* less typing
06:16:34 <ongy> > show . (read :: String -> Int) $ "11"
06:16:36 <lambdabot>  "11"
06:16:36 <ahihi> the map isEven example isn't a very good one
06:16:51 <ahihi> the usage section has others
06:16:54 <ongy> also less redundancy. makes some sense
06:19:34 <c_wraith> But even your first example..  The @Bool application was totally redundant
06:19:43 <JonReed> Anybody knows how to search with attoparsec. I just want to make `string "find me"` to match anywhere in the input "start of input, find me, remaining text". 
06:20:39 <JonReed> There has to be some simple or ideomatic way to do this. But I can't find it :O
06:24:21 <ertesx> dhananjay: why wouldn't it help?  after all functional programming is all about abstraction over patterns in order to make code less redundant, less error-prone, more maintainable…  if you can't sell them abstraction, you can't sell them haskell =)
06:25:01 <cocreature> JonReed: depends on how much you care about performance. you can just "try" the parser at every char and see if it matches otherwise advance
06:25:21 <cocreature> JonReed: if you are really just searching for literal strings however there are are search procedures that are _a lot_ more efficient
06:25:44 <ertesx> dhananjay: almost all functions you use abstract in that sense, even the simple ones like mapM_ (over a Monad and a Foldable), foldr (over a Foldable), etc.
06:26:50 <cocreature> JonReed: for the latter, one algorithm is called boyer-moore (not sure which haskell package implements that)
06:27:53 <m1dnight_> Hey guys, I'm trying to write a monad parser using Alex and Happy and I'm kind of at loss on how I can get the position when the parser errors on an EOF.
06:28:13 <JonReed> cocreature: Thx. I'll do it without attoparsec then, found this one: https://hackage.haskell.org/package/stringsearch-0.3.6.6/docs/Data-ByteString-Search.html  And for attoparsec it would look something like this, but not efficient for a simple case like this: http://stackoverflow.com/questions/20273849/best-way-to-find-first-parse-success-in-a-string-using-attoparsec-haskell-librar
06:29:17 <m1dnight_> http://hastebin.com/cebilocixa.rb <- Lexer, http://hastebin.com/lixadelina.pl <- Parser
06:30:55 <m1dnight_> My current guess was, since the AlexEOF is a function in the Alex monad, I could call alexSetUserState and read out the curent position, but that doesn't seem to work.
06:32:40 <cocreature> why does putting an INLINABLE pragma on a toplevel binding in the same module cause that function to be inlined? if I read the docs correctly the rules for inlining are unchanged and the effect of INLINABLE is only to retain the rhs which should be available anyway if it is in the same module?
06:34:34 <phadej> cocreature: why shouldn't it be inlined in the same module? I think GHC is free to decide to inline something, you should use NOINLINE to prevent that (which doesn't make sense with INLINABLE though)
06:35:21 <cocreature> phadej: sorry I think I have been unclear. I am wondering why it is _only_ inlined when I add INLINABLE. It is not inlined when I don’t have INLINABLE
06:35:34 <cocreature> so somehow that seems to make a difference to GHC’s inline decision
06:35:39 <cocreature> and I don’t understand why from the docs
06:36:33 <phadej> cocreature: ah, that makes more sense indeed. I don't know, maybe some fuzzy ordering happens there
06:37:29 <cocreature> phadej: ah yeah that could be it, thanks!
06:41:57 <Cale> cocreature: While INLINE says “please inline me”, the INLINABLE says “feel free to inline me; use your discretion”. In other words the choice is left to GHC, which uses the same rules as for pragma-free functions. Unlike INLINE, that decision is made at the *call site*, and will therefore be affected by the inlining threshold, optimisation level etc.
06:43:25 <kqr> Cale, though "please inline me" may in some cultures be interpreted as "it would be nice if you inlined me but no hard feelings if you don't"
06:43:26 <Cale> cocreature: So it seems like GHC didn't think your function would be inlinable in the first place without the pragma, but, having told it that, it was successfully able to make the decision to inline it.
06:44:11 <Fairy> I'm trying to create a function String -> [String] so that "Hello, sir" returns ["H", "e" ,"l", "l", "o", ", ", "s", "i", "r"] - ie. take each character and turn it into a [Char] with the exception of any whitespace [' '] is just appended to the previous charstring
06:44:43 <Fairy> (I'm trying to teach myself Haskell)
06:44:54 <cocreature> Cale: but doesn’t that paragraph state that the rules for deciding when to inline stay the same? so why could it think that it is not inlinable without the pragma?
06:44:54 <Cale> Fairy: A list comprehension might be useful for excluding the spaces
06:45:10 <c_wraith> Cale: spaces aren't being excluded.  It's a bit trickier than that
06:45:24 <Cale> c_wraith: Oh, sorry, I misread
06:46:03 <m1dnight_> map show "hello, sir" is part of it, I guess
06:46:04 <tefter> filter then map ;)
06:46:14 <Cale> Fairy: So you want each group to consist of a non-whitespace character followed by as many whitespace characters as possible
06:46:17 <m1dnight_> Just figure out how to remove the spaces.
06:46:33 <Cale> m1dnight_: nono, that's what I missed as well
06:46:42 <Cale> ", " has a space in it :)
06:46:45 <Fairy> Cale: Yeah, any whitespace is just appended to the previous [character]
06:46:48 <m1dnight_> oooh.
06:47:00 <m1dnight_> chasing pointers and manual recursion then, I reckon
06:47:11 <Cale> Well, you could do this with groupBy
06:47:31 <kqr> yeah I was going to suggest groupBy as well
06:47:35 <kqr> that seems like a neat solution
06:48:01 <Cale> > groupBy (\x y -> isSpace y) "Hello, sir"
06:48:03 <lambdabot>  ["H","e","l","l","o",", ","s","i","r"]
06:48:30 <tefter> oh, neat
06:49:59 <Cale> > groupBy (\x y -> isSpace y) "Hello,   there\nsir\t."
06:50:00 <markv5> Not a busy channel i see
06:50:01 <lambdabot>  ["H","e","l","l","o",",   ","t","h","e","r","e\n","s","i","r\t","."]
06:50:45 <Cale> markv5: How many users did you expect? :)
06:51:07 <markv5> I dont know, a lot?
06:51:25 <cocreature> and 1483 is not a lot? :)
06:51:50 <markv5> Yes, but noone says anything
06:52:12 <Fairy> Cale not sure I quite understood that one :S
06:52:36 <markv5> Dissapoint. Bye
06:52:47 <bearchild> lol
06:52:53 <Cale> Fairy: groupBy takes a function as its first argument which is applied to the first element of each group, and each subsequent character to decide if it should be in the same group
06:53:19 <Cale> Fairy: In this case, we say that the subsequent elements should belong to the same group if they're whitespace
06:53:29 <Cale> (regardless of what the first character was)
06:53:43 <Cale> > groupBy (\x y -> isSpace y) "    let's start with some spaces"
06:53:45 <lambdabot>  ["    ","l","e","t","'","s ","s","t","a","r","t ","w","i","t","h ","s","o","...
06:54:36 <kqr> Fairy, something that may help: ['a', 'b', 'c'] is equivalent to "abc" as far as the standard Haskell String type goes
06:55:03 <kqr> Fairy, groupBy takes a "classifying function" and then a list, and uses the classifying function to break the list into groups
06:55:06 <Cale> > groupBy (<) [1,2,3,1,2,3,4,1,2,3,4,5,6]
06:55:08 <lambdabot>  [[1,2,3],[1,2,3,4],[1,2,3,4,5,6]]
06:55:27 <Cale> > groupBy (<) [1,2,3,2,3,4,3,4,5,6]
06:55:30 <lambdabot>  [[1,2,3,2,3,4,3,4,5,6]]
06:55:57 <Cale> ^^ (all that matters is the comparison with the first element of the group)
06:56:15 <kqr> Fairy, in this case, we're submitting the list ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'] (though written as the string "hello world") and we're looking to turn that into a grouped list based on some sort of classifying function
06:56:44 <kqr> Fairy, Cale came up with the classifying function "\x y -> isSpace y" which takes two characters and checks if the latter is a space, in which case it returns True. otherwise, it returns False
06:57:03 <kqr> Fairy, for almost all inputs, this will return False, and groupBy will decide that "nope, these things do not belong in the same group" so they are put into different groups
06:57:07 <Fairy> Variable not in scope: groupBy :: (() -> () -> Bool) -> [Integer] -> t
06:57:23 <kqr> Fairy, however, IF the second character is a space, then it will decide that they belong in the same group so it gets appended to whatever was currently there
06:57:24 <Cale> Fairy: Ah, groupBy is in Data.List
06:57:32 <Fairy> that makes more sense ;)
06:57:41 * hackagebot megaparsec 5.1.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-5.1.0 (mrkkrp)
06:57:43 * hackagebot rl-satton 0.1.2.3 - Collection of Reinforcement Learning algorithms  https://hackage.haskell.org/package/rl-satton-0.1.2.3 (SergeyMironov)
06:57:45 * hackagebot libroman 3.1.0 - Use Roman Numerals as a Numeric Datatype (sort of)  https://hackage.haskell.org/package/libroman-3.1.0 (ahakki)
06:58:18 <Cale> Fairy: But also, you should probably learn to write this recursively...
06:58:45 <Fairy> sorry, I'm a bit slow - I have a basic Lambda understanding (read: I read about it, it made good sense)
06:59:44 <Cale> So, one thing which might also be useful is the function called 'span'
06:59:46 <Cale> :t span
06:59:48 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
07:00:04 <Cale> > span isSpace "   here is a   string  "
07:00:06 <lambdabot>  ("   ","here is a   string  ")
07:00:45 <Cale> It takes a predicate and a list, and splits the list in two at the point where the predicate first fails to be true
07:01:15 <Cale> i.e. all the elements of the first list in the result will satisfy the condition, and the first element of the second won't.
07:06:23 <kqr> > span isSpace "also string"
07:06:25 <lambdabot>  ("","also string")
07:08:52 <ashishnegi> hi.. i am not able to understand https://hackage.haskell.org/package/wai-websockets-3.0.1.1/docs/src/Network-Wai-Handler-WebSockets.html#websocketsOr 
07:09:06 <ashishnegi> function takes 4 args and body has 5 arguments in funciton signature
07:09:14 <ashishnegi> s/funciton/function
07:09:49 <Fairy> ok, that worked, I think <3 now to figure out how exactly groupBy and isSpace works under the hood :p
07:09:49 <tdammers> ashishnegi: Application is a type alias for Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
07:10:16 <tdammers> ashishnegi: http://hackage.haskell.org/package/wai-3.2.1.1/docs/Network-Wai.html
07:11:19 <ashishnegi> thanks.. tdammers
07:14:16 <ashishnegi> tdammers: so `websocketsOr opts app backup req sendResponse` in this line `backup` is first Application and `req and sendResponse` are arguments of 2nd Application (return value) ??
07:21:55 <ashishnegi> hi.. i want to join two `Network.Wai.Application`'s so that if first fails, second serves.. first is `staticApp` and second is `jsonApi`
07:22:23 <ashishnegi> when i get a request, how do i check with Network.Wai.Application.Static that if it can serve it or not ?
07:29:58 <kqr> this feels like a silly question, but how do I convert from any Num to any other?
07:30:25 <lyxia> you can't
07:30:31 <kqr> fromInteger . toInteger perhaps
07:30:48 <kqr> oh that requires Integral
07:30:50 <kqr> but I have that so meh
07:30:50 <lyxia> well that's more restrictive
07:31:12 <hpc> :t fromIntegral
07:31:14 <lambdabot> (Num b, Integral a) => a -> b
07:31:30 <hpc> which is defined as that
07:31:44 <hpc> but yeah, in general it's not possible
07:31:56 <hpc> Num doesn't contain toInteger, only fromInteger
07:32:21 <hpc> and if you want to convert say, 3.5 to an integer
07:32:27 <hpc> is it going to be 3 or 4?
07:32:32 <unbalanced> hey :D
07:59:28 <tdammers> ashishnegi: not quite; websocketsOr takes a websocket app called 'app', and a regular WAI app called 'backup', and then it takes a request 'req', serves it through the websockets app if it's a websocket request, or through the 'backup' app if it's not
08:00:43 <tdammers> ashishnegi: what you're looking for is routing functionality; the nice thing about WAI is how an app is just a CPS function, that is, it takes a request and a "send response" function, so you can combine apps into larger ones
08:01:45 <ashishnegi> tdammers: it has to return `Application` and it is returning `IO ResponseReceived` so last two `req and sendResponse` are part of that Application.. right ??
08:01:57 <tdammers> for example, one thing you can do is run the first app first, but instead of passing it the original sendResponse, you wrap the sendResponse function such that if the response has status 404, you don't send the response from the wrapped app, but call the second app instead
08:02:29 <tdammers> forget about the 'Application' type for now; whenever you see 'Application', expand it into Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
08:02:38 <tdammers> and consider ResponseReceived mostly equivalent to ()
08:04:12 <ashishnegi> tdammers: if i expand Application into that it becomes `WS.ConnectionOptions -> WS.ServerApp -> Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived -> Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived`
08:04:43 <ashishnegi> then what in `opts app backup req sendResponse` what is `req and sendResponse` ??
08:05:17 <dkk> hello
08:05:25 <ashishnegi> tdammers: i also asked the question here, after writing what you suggested.. http://stackoverflow.com/questions/39834616/join-two-network-wai-application can you have a look ?
08:05:35 <tdammers> backup is an Application, so it's a function of type Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
08:06:00 <tdammers> hmm, I don't really play SO anymore...
08:06:41 <dkk> hi i am writing a simple console game in haskell and i wanted to take some action after someone have pressed say upper key could any one help me for the same
08:07:18 <buglebudabey> does anyone have some good example of dijkstra's algorithm in haskell?
08:09:28 <dkk> can some one have any clue how to do it in haskell
08:10:15 <ashishnegi> tdammers: thanks.. that helped
08:11:25 <byorgey> dkk: perhaps use the ncurses package? http://hackage.haskell.org/package/ncurses
08:11:45 <byorgey> it has built-in stuff for handling special keypresses like arrow keys
08:21:06 <Magellanicus> hello, anyone can help me with an instagram account security question?
08:21:17 <Magellanicus> (is this offtopic?)
08:22:03 <moonythedwarf> that is offtopic
08:22:13 <moonythedwarf> ask in a diffrent channel ^_^
08:22:31 <Magellanicus> k ty
08:27:06 <umib0zu> Hi all. I’m trying to debug stack path issues. I’ve added Hunit to my stack yaml and ran stack build, but when I run the text executable that has an import Hunit line, it doesn’t compile. I’ve also double checked and ran stack repl and I get an error when I run hunit. Any ideas as to what’s wrong?
08:29:12 <MarcelineVQ> depends what the error says, be sure that HUnit is in the build depends of your .cabal file for what you're building
08:29:46 <MarcelineVQ> also the import should be import Test.HUnit
08:36:13 <adnelson> hello peeps, is there a simple haskell equivalent of the `abspath` function in python? For example it would take `.` and convert it to cwd, etc
08:38:06 <electrocat> adnelson: https://hackage.haskell.org/package/directory-1.2.7.0/docs/System-Directory.html#v:makeAbsolute
08:38:14 <electrocat> adnelson: is this what you are looking for?
08:39:03 <electrocat> "makeAbsolute"
08:39:17 <adnelson> electrocat: yep, that's it! Thanks :)
08:41:26 <clue> Hello so I have this script where Im trying to implement a function called split that ultimately will insert a number between every x numbers in a list (the last function of the paste) but my question is if anyone can help me implement the types so that instead of inserting a number only, I could also insert a char or string or anything else ... thank you and sorry but types confuse me a lot
08:41:31 <clue> and im just learning haskell http://lpaste.net/239777
08:42:45 <benzrf> hey clue!
08:43:29 <severus_tux> Hello all :D
08:43:39 <benzrf> clue: would you like any other tips on improvements to your code, or just that specific problem? (there's some beginner-y stuff in there)
08:46:59 <severus_tux> Hello everyone :) . I am a beginner and  I am trying to get some applications go fullscreen on Xmonad (arch-linux) . But I am clueless. Could some one please help me ? here is somemore details about the problem : http://unix.stackexchange.com/q/314052/155386
08:50:53 <severus_tux> I am new to this IRC and I don't know if its working. could somebody please reply ?
08:51:03 <MarcelineVQ> :>
08:51:30 <srhb> severus_tux: pong. We see you. :)
08:51:30 <MarcelineVQ> It's just early monday for a lot of people, it'll pick up later
08:51:48 <severus_tux> Oh, thanks :)
08:51:50 <ski> severus_tux : you could try entering the IRC command `/join #xmonad' to join the XMonad channel (unless you're already there, i.e.)
08:52:15 <srhb> severus_tux: You haven't actually set the manageHook to your version though.
08:52:56 <severus_tux> ski : I will join it. Thanks :) 
08:53:38 <severus_tux> srhb: I don;t know. I just tried something from many different xmonad.hs files.
08:53:56 <srhb> severus_tux: You probably want to overwrite the one in defaultconfig with your own version.
08:53:56 <severus_tux> from the internet
08:54:14 <clue> benzrf: hey! yes desfinitely!
08:54:18 <benzrf> ok!
08:54:27 <benzrf> clue: first of all - prefix already exists, it's called take :)
08:54:31 <severus_tux> srhb: I hope I could, but I just started learning haskell
08:54:37 <benzrf> clue: just like drop
08:54:39 <severus_tux> * I wish
08:54:44 <srhb> severus_tux: Like you did with layoutHook. ie. xmonad defaultConfig { manageHook = yourManageHook }
08:55:03 <benzrf> clue: oh, wait - you're defining suffix but using drop instead of suffix?
08:56:37 <clue> benzrf: actually, yeah I see.. but I was asked to not use those haha and create a recursive function for each, so in the split part I meant to use suffic which is basically the same thing
08:56:59 <ph88> how can i make from this a version that gives back the result of the "end" parser in it's output??  https://hackage.haskell.org/package/megaparsec-5.1.0/docs/src/Text-Megaparsec-Combinator.html#manyTill
08:57:41 <benzrf> clue: kk
08:57:43 * hackagebot avers 0.0.16 - empty  https://hackage.haskell.org/package/avers-0.0.16 (wereHamster)
08:58:40 <benzrf> clue: ok, both prefix and suffix can be written in a way that doesn't use (!!)
08:58:48 <benzrf> and doesn't make so many comparisons
08:59:08 <ph88> maybe   \x -> [x] <$ end   instead of   [] <$ end   ??
08:59:15 <benzrf> i can get back to that if you want - re: your original question: change the type of split like so: "split :: Int -> a -> [a] -> [a]"
08:59:22 <ph88> eh i mean    \x -> [x] <$> end
08:59:29 <benzrf> that should typecheck, and then you can use split with any kind of list
09:00:47 <clue_> shiiiiit
09:01:11 <srhb> o...k
09:01:12 <clue_> benzrf: sorry, I lost connection
09:01:39 <ph88> maybe silly question but someone know a word for  until + include last item ?
09:01:49 <benzrf> clue_: http://lpaste.net/5259899855882420224
09:04:48 <clue_> benzrf: I am interested to see what other way there is to write it o.o and well the type part, thats what I thought but I get an error
09:04:56 <clue_> saying it expected an Int
09:04:58 <benzrf> what error?
09:05:23 <benzrf> aha
09:05:31 <benzrf> prefix expects a list of ints, and you call prefix
09:05:39 <benzrf> you'll need to change prefix's type as well to allow any kind of list
09:07:06 <clue_> benzrf: ahaaa
09:10:28 <benzrf> :)
09:13:04 <clue_> benzrf: thanks a lot, I might some more questions in a bit if thats fine haha
09:13:21 <benzrf> i may not personally be around to answer them, but that's what the channel is for
09:13:28 <benzrf> (actually you might want to check #haskell-beginners )
09:15:15 <clue_> benzrf: thanks again!
09:15:59 <benzrf> np
09:23:20 <Unicorn_Princess> when building a multi-module project with stack, where should i specify the modules so the whole thing compiles? so far i've been jamming them into the projectName.cabal file, under library -> exposed-modules. related - where should i specify the dependencies (e.g. containers, random, etc.)? putting them in the same file, under executable exeName -> build-depends worked so far
09:26:37 <fractalsea> Unicorn_Princess, that is the correct place to put them
09:26:59 <fractalsea> Unexposed modules can go in other-modules
09:28:24 <Unicorn_Princess> even if i'm not writing a library, and the modules are just for the main executable's internal use?
09:28:52 <geekosaur> then they could all (except the one with main in it) go in other-modules
09:32:48 <Unicorn_Princess> kay, thanks
09:34:06 <flonk> Can you implement your own deriving mechanisms?
09:36:54 <puregreen> is there a way to forbid a certain instance from being written? E.g. I want to make sure nobody can write a `Binary Foo` instance.
09:37:19 <puregreen> I naively tried to do `instance (Int ~ Bool) => Binary Foo` but got an error
09:38:35 <bash0r> Hi everybody
09:38:49 <geekosaur> you cannot, except by writing an "instance Binary Foo where (dummy instance here, probably all undefined)" and let them eat the overlap warning
09:39:07 <byorgey> flonk: yes, using GHC.Generics
09:39:21 <byorgey> flonk: this doesn't let you do arbitrarily complicated things but it's enough for most use cases
09:39:44 <byorgey> flonk: see the examples here: https://wiki.haskell.org/GHC.Generics
09:40:25 <flonk> byorgey, thanks, I'll check that out
09:40:33 <flonk> Alternatively there is Template Haskell, right?
09:41:02 <cocreature> flonk: yep
09:41:45 <benzrf> byorgey: is the idea that you set a default instance for things with Generic, and then there's some ghc extension that lets you automatically generate empty instances by saying deriving?
09:43:22 <bash0r> I'm currently developing a little language. I want to use Haskell (GHC to be specific) as my backend. At the moment I try to compile basic expressions with help of Template Haskell. In difference to Haskell I want integer literals with suffix like 10b or 10s. Does anybody know how I can create a value in the ExpQ that works? "" sigE (litE (intPrimL (fromIntegral i))) (varT (mkName "Int8")) "" yields "" Illegal type variable name: 
09:43:22 <bash0r> Int32      When splicing a TH expression: 10# :: Int32 "" when compiling my code.
09:43:24 <byorgey> benzrf: yep
09:43:59 <benzrf> bash0r: that's a type *constructor*, not a type *variable*
09:44:04 <geekosaur> theres at least two things wrong there
09:44:12 <benzrf> bash0r: so try conT
09:44:21 <geekosaur> what benzrf said, and 10# is unboxed and will do *bad* things if treated as a boxed type
09:44:21 <benzrf> but you can also probably just do [t| Int32 |]
09:44:38 <umib0zu> MarcelineVQ that worked! thank you. but for future reference, how is the namespace resolved? why is it Test.Hunit?
09:45:01 <geekosaur> ...at least if I read that error message correctly...
09:45:09 <bash0r> Ah nice that helped a bit. So I just need to box it?
09:46:06 <geekosaur> things get a little tricky there. "all" unboxed values are currently machine words, so you need the constructor for an Int32
09:46:09 <geekosaur> or an Int8
09:46:27 <geekosaur> lemme see if I can find that...
09:46:59 <benzrf> cant you just use IntegerL instead of IntPrimL
09:47:09 <benzrf> do you specifically *want* unboxed numbers?
09:47:36 <geekosaur> if so then Int8 is a bad idea because it's defined as boxed...
09:48:03 <bash0r> No I don't want unboxed numbers. I just want them to be fixed in size (e.g. 32 bit instead of at least 31).
09:48:18 <benzrf> use Int, then
09:48:25 <benzrf> or wait
09:48:26 <benzrf> is Int32 boxed
09:48:38 <benzrf> yeah
09:48:39 <bash0r> Int32 is boxed just like Int8 as far as I know.
09:48:42 <benzrf> just use IntegerL instead of IntPrimL
09:48:51 <bash0r> I'll try that.
09:49:04 <benzrf> IntPrimL is for unboxed literals - IntegerL is for regular numeric lits
09:49:10 <benzrf> integral ones i mean
09:49:10 <moonythedwarf> moo
09:49:44 <geekosaur> right, if you build it manually then Int32 is I32# and Int8 is I8# (data constructors)
09:50:09 <geekosaur> probably need import Data.Int
09:50:31 <benzrf> bbl
09:52:06 <bash0r> Wow cool, that worked! Thanks a lot.
09:56:14 <johnw> koz_: the name of what?
10:09:04 <felko> hey, i was trying to figure out how to turn common monads into arrows, such as StateT, ReaderT, WriterT, etc... and i was wondering how could we do the same with comonads, like Store for example
10:15:10 <hpc> felko: look at Kleisli and Cokleisli (might be CoKleisli)
10:15:40 <felko> hpc: yeah but for StateT for example i didn't use Kleisli
10:16:04 <felko> hpc: i did this newtype StateT s a b c = StateT { runStateT :: a (b, s) (c, s) }
10:16:33 <hpc> oh i see
10:16:36 <felko> (StateT is an arrow transformer)
10:21:56 <catau> I'm switching to ExceptT instead of EitherT after upgrading Servant, and I am feeling confused by monad transformers. I have an action of type "ExceptT ServantErr STM Int" and I want to run it inside a handler of type "ReaderT MyStore (ExceptT ServantErr IO) Int"
10:22:22 <catau> "liftIO . atomically . runExceptT" gives me back an Either ServantErr Int
10:22:45 <hpc> :t lift
10:22:47 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
10:22:56 <hpc> m = (ExceptT ServantErr STM)
10:23:02 <hpc> t = ReaderT MyStore
10:23:04 <hpc> a = Int
10:23:05 <johnw> you may need 'hoist', from @hackage mmorph
10:23:23 <johnw> in order to change STM -> IO underneath the transformer stack
10:23:26 <hpc> lift :: ExceptT ServantErr STM Int -> ReaderT MyStore (ExceptT ServantErr STM) Int
10:23:45 <hpc> and then yeah, you'll need to do something with STM
10:24:01 <catau> johnw: I have found and used hoistEither before in a similar situation -- I take it 'hoist' is generalized a little more :)
10:24:04 <shapr> Is it silly that using transformers makes me feel like a superhero?
10:25:06 <catau> hpc: indeed, the 'something with STM' is where I am stuck
10:25:24 <johnw> it should be as easy as "hoist atomically" in this case
10:25:45 <johnw> before you lift
10:25:48 <hpc> hoist is a thing if all those parts are instances of MFunctor
10:26:03 <johnw> anything in transformers should be
10:26:17 <catau> johnw: that's great, I'll try it, although I will feel like I'm cheating until I understand the underlying mechanics more
10:26:34 <johnw> hoist is to the underlying monad, as fmap is to the base type
10:26:39 <hpc> most of those have some type-specific thing that implements an instance of hoist iirc
10:27:04 <johnw> hpc: http://hackage.haskell.org/package/mmorph-1.0.6/docs/Control-Monad-Morph.html
10:27:11 <johnw> you'll see that everything from transfomers already has an instance there
10:27:43 <hpc> heh, you weren't kidding
10:27:46 <catau> I still have much to learn regarding monad transformers
10:27:55 <hpc> there's two instances for RWST
10:28:13 <hpc> oh of course, lazy and strict
10:28:17 <catau> thank you both for the guidance!
10:28:20 <vapid> hpc
10:28:56 <vapid> hi
10:33:38 <catau> oh no, unfortunately I didn't get far by cargo-culting your suggestion of hoist :)
10:35:07 <catau> "No instance for (Control.Monad.Error.Class.MonadError ServantErr STM)" -- Is this saying I got my chain of hoist and lift wrong?
10:35:18 <johnw> catau: https://gist.github.com/8ffcc2764bf48048b20e6cf64718ffbf
10:36:57 <catau> oh it's maybe me not being able to use (lift . throwError) inside my STM block
10:37:25 <johnw> you can just "throwError" inside an ExceptT e STM a block
10:37:41 <johnw> or lift . throwError if there's a ReaderT around that
10:37:52 <johnw> maybe you can paste your code?
10:38:08 <catau> ohh I see, throwError is just like 'left'
10:38:14 <catau> it compiled!
10:39:56 <catau> johnw: thanks again! sorry for not taking a closer look at my error initially, the error felt too confusing until I noticed line number 
10:40:16 <johnw> no problem, glad it works now
10:40:36 <Tuplanolla> At least for me, the line number is usually the only part of an error message that needs to be read.
10:41:14 <aetern> do u have a favorite editor/ide for haskell?
10:43:00 <lyxia> There are lots of vim and emacs users here.
10:43:06 <catau> Tuplanolla: with johnw's advice, now my monad transformer stack is writing checks I can't cash! It feels "magical" that hoist can reach into these stacks and change the base monads
10:43:30 <bash0r> @aetern I use atom.io. But no real support at the moment. The GHC-Mod plugin seems to be broken for me.
10:43:31 <lambdabot> Unknown command, try @list
10:43:33 <Tuplanolla> Sounds like monad transformers alright, catau.
10:44:47 <nyuszika7h> is there a digitToInt equivalent that returns unbounded Integer?
10:44:56 <nyuszika7h> or a better way to get the sum of digits of an Integer
10:45:07 <nyuszika7h> it's a very big one
10:45:27 <catau> I suspect reading the instances and refreshing my understanding of transformers/mtl will clear things up eventually, and I will endeavor to read http://www.haskellforall.com/2013/03/mmorph-100-monad-morphisms.html 
10:45:41 <mauke> :t unfoldr
10:45:43 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:48:10 <lyxia> nyuszika7h: so big that the sum doesn't hold in an Int ?
10:48:22 <nyuszika7h> judging by the output, yes
10:48:34 <nyuszika7h> I'm not entirely sure if the number is supposed to be that big though
10:48:43 <nyuszika7h> http://cadoth.net/bsp/eq.hs
10:49:19 <lpaste> nyuszika7h pasted “No title” at http://lpaste.net/239993
10:49:23 <nyuszika7h> or see that
10:49:32 <Tuplanolla> You can simply `fromIntegral` the accumulator to convert it from `Int` to `Integer`, nyuszika7h.
10:49:55 <nyuszika7h> (I need the number of digits of "k 29")
10:51:14 <Tuplanolla> It would be a better idea to avoid taking the trip through `String` though, nyuszika7h.
10:51:15 <int-e> nyuszika7h: the conversion to digits is not the problem here; n and m are recursing a lot, and that's taking a long time
10:51:19 <tsahyt> Are there any simple examples where a Functor is not "just a mappable like lists"?
10:51:26 <tsahyt> i.e. where Mappable would be a misnomer
10:51:30 <johnw> tsahyt: Const
10:52:02 <nyuszika7h> how would I optimize it?
10:52:06 <lyxia> nyuszika7h: does that require the sum of digits?
10:52:19 <nyuszika7h> the end result I need is the sum of the digits
10:52:22 <nyuszika7h> i.e. sd (k 29)
10:52:38 <tsahyt> johnw: I've never used Const, what is it exactly? from what I can tell the b in Const a b is a phantom parameter
10:52:45 <johnw> yes
10:52:48 <int-e> Tuplanolla: the trip through String is worthwhile unless you want to implement the divide and conquer conversion to digits that `show` does yourself.
10:52:55 <tsahyt> so what is it good for?
10:54:02 <johnw> tsahyt: it's a functor when you need a functor, that holds a constant value
10:54:08 <int-e> nyuszika7h: the code is slow for the same reason that implementing the fibonacci numbers using  fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)  is slow.
10:54:30 <nyuszika7h> well I don't know, this is the equation I was given to solve in some challenge
10:54:42 <nyuszika7h> well, these were the equations*
10:55:01 <tsahyt> johnw: fmap doesn't do anything on it then other than changing the type?
10:55:01 <johnw> tsahyt: functions are another good example
10:55:06 <johnw> tsahyt: correct
10:55:07 <lyxia> tsahyt: the lens packages uses it a lot to make getters out of lenses
10:55:16 <tsahyt> yeah I already thought of functions, I was wondering whether there are more.
10:55:18 <int-e> (if one avoids that excessive recomputation of values the code should run in half a minute, easily)
10:55:46 <tsahyt> I'll need to play around with this a bit to see why it'd be useful
10:55:59 <tsahyt> unfortunately I still haven't looked into lens
10:57:46 * hackagebot hnix 0.3.2 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.3.2 (JohnWiegley)
10:59:18 <mizu_no_oto_work> tsahyt: SPJ has a good lens tutorial
10:59:26 <johnw> http://ftp.newartisans.com/pub/Lenses.mp4
10:59:27 <johnw> ^
10:59:49 <tsahyt> nice. I'll be looking into this
11:01:31 <GLM> How might I capture all responses from a server that arrive in some time range as a list?
11:02:34 <johnw> GLM: that question is missing too many details
11:02:55 <nyuszika7h> ok I managed to get the answer, ran in a few seconds with ghc -O2
11:03:06 <nyuszika7h> seems like the sum of digits was small enough not to overflow even without the fromIntegral
11:04:24 <Tuplanolla> What divide and conquer do you refer to, int-e? At least GHC.Show seems to simply fold through a division by 10.
11:07:56 <int-e> Tuplanolla: scroll down to instance Show Integer
11:08:43 <Tuplanolla> Oh, pfft... of course.
11:09:50 <int-e> a bit over-engineered, maybe
11:11:02 <NickHu> Why don't arrows get the same amount of attention as monads?
11:11:32 <Clint> they don't get a lot of use anymore
11:11:52 <NickHu> Did they just fall out of fashion?
11:12:11 <Cale> NickHu: It's rarer to be in a situation which calls for an interface that looks like that, and unfortunately, Arrow somewhat undermines a lot of its potential applications even in those cases.
11:12:25 <NickHu> Cale: How so?
11:12:32 <NickHu> Is the interface to complex?
11:12:36 <NickHu> too*
11:12:46 <ski> `arr' should be re/moved
11:12:56 <Cale> In particular, one of the advantages that Arrow has over Monad is that its primary means of chaining computations together (>>>) takes arguments which are both of a user-controlled type
11:13:01 <Cale> :t (>>>)
11:13:03 <lambdabot> forall k (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
11:13:14 <Cale> jeez, those kind signatures :)
11:13:41 <Cale> anyway, note that 'cat' there would be some data type that you'd control
11:13:41 <NickHu> Are arrows really generalisations of monads? The typeclassopedia doesn't make it completely clear
11:14:15 <Cale> I want to say "no" -- if you stick to the original definition in the paper, then "yes", but there are some extra laws you end up wanting to assume, which most Kleisli categories won't satisfy.
11:14:37 <Cale> anyway
11:14:56 <Cale> The point I'm trying to make is that the right argument to (>>=) is always a function
11:15:02 <Cale> and therefore is a black box
11:15:25 <Cale> So there's absolutely no hope of looking ahead at what's to come in the computation and perhaps simplifying some of the work before starting
11:15:31 <NickHu> How does it being a function make a black box? The user specifies it, no?
11:15:32 <ski> (no static analysis, ahead of time)
11:15:44 <NickHu> Oh I see what you mean
11:15:50 <Cale> NickHu: At runtime, the only way to observe which function you have is to apply it
11:16:17 <Cale> NickHu: and by the time you can apply the function in the case of (>>=), it's too late, you already ran the left hand computation
11:16:37 <felko> (i know i already asked that question but i was disconnected) how to turn comonads into arrows, like one would turn the State monad into newtype StateT s a b c = StateT { runStateT :: a (b, s) (c, s) } ?
11:16:58 <int-e> Tuplanolla: this is only a bit slower than the  sum . map digitToInt . show: http://sprunge.us/DCje 
11:17:06 <Cale> So, Arrow looks good because it might be amenable to analysis -- but -- there are some issues.
11:17:13 <geekosaur> felko, someone suggested looking at CoKleisli
11:17:18 <Cale> As ski mentioned, there's arr
11:17:19 <Cale> :t arr
11:17:21 <lambdabot> Arrow a => (b -> c) -> a b c
11:17:25 <NickHu> Cale: Oh I see
11:17:27 <Tuplanolla> Neat, int-e.
11:18:05 <felko> geekosaur: yep but i told him that i want a real arrow, not just cokleisli on the comonad
11:18:07 <Cale> This basically puts black boxes into your computations -- that's maybe not terrible, so long as it's used sparingly, perhaps you could still get by simplifying all the other stuff
11:18:24 <Cale> But also, Arrow is lacking a bunch of things which you'd need if you were really going to avoid arr
11:18:52 <felko> i guess theres a difference between my StateT definition and Kleisli StateT (with StateT being the monad)
11:18:55 <Cale> The proc/do notation in GHC will actually stick an 'arr' in between every pair of lines
11:19:08 <int-e> Tuplanolla: the main difference to the code in GHC.Show is that the latter adds an additional layer: it converts the numbers first into a base such that all digits ("blocks") fit into machine words, and then converts those blocks using the standard iterated division by 10, without going through gmp.
11:19:26 <joe9> I am using this http://dpaste.com/37CABF7 to use this data type  https://paste.pound-python.org/show/J6gc1dP1dK14iVuJ4bz2/ . I would prefer to represent this data as something other than a Word32 or a list. Something like a vector or so. Just want to check if there is already a data structure that can help. I can think of Vector Bool. But, there might be something better than that.
11:20:14 <felko> Cale: are my StateT arrow and Kleisli StateT equivalent ?
11:20:19 <NickHu> >=> can be accurately described as the composition operation between Kleisli categories right?
11:20:20 <Cale> and so you're hosed if you wanted to do analysis at that point -- on a game project I worked on back around 2011-2012, we ended up replacing Arrow with something that had more of these structural operations, like assocL :: a (b,(c,d)) ((b,c),d), and swap :: a (b,c) (c,b)  and so on
11:20:54 <NickHu> (Is it also called a Kleisli star, or is that something else?)
11:21:00 <Cale> felko: hmm
11:21:26 <Cale> felko: Not really.
11:21:35 <joe9> using Vector Bool, I lose the fact that it is a Modifier.
11:21:45 <Cale> felko: Well, what do you mean by "Kleisli StateT"? That's a kind error...
11:21:50 <joe9> as, the Modifier is used to derive the position.
11:22:09 <Cale> felko: But the StateT for monads only applies to monads.
11:22:10 <felko> Cale: sorry I meant Kleisli (StateT s m)
11:22:29 <felko> with StateT being the monad this time, not my StateT arrow
11:22:30 <Cale> felko: Whereas you wrote an arrow transformer for State
11:23:26 <Cale> felko: You might expect StateTA s (Kleisli m) a b ~= Kleisli (StateT s m) a b
11:24:04 <felko> Cale: I have also an ArrowState typeclass, let me see if i can instantiate it with Monad m => Kleisli (StateT s m)
11:24:33 <Cale> hmmm...
11:24:49 <lyxia> joe9: I did not understand how your last two sentences are related.
11:25:10 <Cale> NickHu: (<=<) is composition of arrows in the Kleisli category.
11:25:29 <Cale> NickHu: Kleisli star is roughly (=<<)
11:25:55 <NickHu> Does >=> have a special name?
11:26:00 <Cale> "fish"
11:26:06 <joe9> lyxia: If I represent the bit mask as a Vector Bool. then the vector index would be the fromEnum Modifier
11:26:22 <lyxia> okay
11:26:32 <Cale> NickHu: but "Kleisli composition" if you're in a situation where people won't understand "fish" :)
11:27:15 <NickHu> Cale: Kleisli composition means something different to the composition of arrows in the Kleisli category?
11:27:23 <NickHu> Namely, arguments flipped?
11:27:38 <felko> Cale: do you have haskell projects on GitHub ?
11:28:06 <lyxia> joe9: I'd write a newtype BitMask, with index :: Modifier -> BitMask -> Bool
11:31:51 <Cale> NickHu: no
11:32:09 <Cale> NickHu: I mean, they're both composition, the only difference is which order the arguments are in
11:32:10 <joe9> lyxia: Thanks, I am trying to understand what you said.
11:32:16 <NickHu> Cale: I see
11:32:19 <NickHu> :t (.)
11:32:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:32:24 <NickHu> :t (>=>)
11:32:24 <Cale> felko: I don't use github a whole lot
11:32:25 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
11:32:47 <felko> Cale: do you use an equivalent website ?
11:33:36 <Cale> felko: Not really. Occasionally I'll stick code on my machine's webserver when I want people to have a look at it.
11:34:26 <felko> Cale: not really a haskell-related question but is there any reason you don't use GitHub ?
11:34:55 <Cale> Not really, apart from the fact that git is annoying to me, so I don't want to have to use it any more than I'm required to by work. :P
11:35:38 <felko> ok
11:36:04 <Cale> There are some funny examples...
11:36:26 <Cale> MonadRandom I originally put the code for on the Haskell Wiki as an example of how to specialise state monads
11:36:34 <Cale> and other people did the work of making a package out of it
11:37:35 <NickHu> In this article, http://www.stephendiehl.com/posts/monads.html, a natural transformation is described as a mapping between two functors F and G, both mapping category A to B, as associating every object in A to a morphism in B
11:38:01 <NickHu> Does he in fact mean associating every object in A to an object in B? I don't understand how you would associate an object to a morphism
11:39:25 <Cale> NickHu: It means what it says.
11:39:47 <Cale> For each object X in A, you have some arrow eta_X: FX -> GX in B
11:40:31 <Cale> and for each arrow a: X -> Y in A, you have a commutative square in B
11:40:43 <Cale> consisting of the arrows eta_X, eta_Y, Fa and Ga.
11:41:09 <Cale> (in particular, Ga . eta_X = eta_Y . Fa
11:41:18 <Cale> )
11:42:43 <NickHu> I see
11:42:55 <NickHu> I'm sure one day I'll fully understand natural transformation
11:42:59 <Cale> felko: https://hackage.haskell.org/package/astar is a package that I wrote and just uploaded to Hackage, but then Johannes Weiss eventually wanted to contribute to it so I made him a maintainer, and he set up a git repo for it
11:43:17 <felko> Cale: thanks
11:43:29 <Cale> felko: Why do you ask?
11:44:13 <felko> Cale: just wanted to see some haskell projects
11:44:30 <felko> Cale: especially the game (im looking for a lbrary for small 2D games)
11:44:50 <felko> Cale: i saw helm but it doesn't build on my pc
11:45:07 <felko> Cale: also i managed to instantiate ArrowState for Monad m => Kleisli (StateT s m), so i guess that means they are somehow equivalent
11:45:37 <Cale> felko: ah, I'm not a good person to look to for that -- most of the Haskell code I work on is either big proprietary projects that are under NDA, or trivial little things that I'm not sure are worth sharing. I often write little demos for people though, but I don't tend to package them nicely or anything.
11:45:37 <felko> doesn't mean their ArrowZero/Plus/Choice/Apply/Loop instances are equivalent though
11:46:04 <felko> Cale: haha ok thanks anyway
11:46:49 <felko> Cale: may i ask where you work ? or at least what field ?
11:47:22 <Cale> I'm presently working for Obsidian Systems. We write web applications for various clients (mostly startups thus far), entirely in Haskell.
11:47:57 <felko> Cale: i'll check it out, thanks
11:48:34 <Cale> We use snap for our backends, compiled to native code using ghc, and reflex-dom for our frontends, compiled to javascript with ghcjs :)
11:48:56 <Cale> https://github.com/reflex-frp/reflex-platform -- this stuff is really cool :)
11:49:46 <felko> thanks
11:51:54 <NickHu> Is there any reason the monad laws are usually presented with >=> rather than <=<?
11:53:09 <Cale> No
11:53:18 <Cale> also, I'm not sure that's even true
11:53:30 <NickHu> It is in the article I linked, and the typeclassopedia
11:53:30 <Cale> I usually see them presented with >>=
11:53:34 <NickHu> Oh
11:53:36 <NickHu> Sorry
11:53:42 <NickHu> I meant when Kleisli stuff is mentioned
11:53:49 <NickHu> It always seems to be >=> rather than <=<
11:54:09 <Cale> No good reason. I would tend to prefer (<=<) myself.
11:54:22 <NickHu> Me too
11:54:25 <Cale> Just because it lines up nicely with ordinary composition.
11:54:49 <NickHu> I seems like you can just replace the >=> with <=< anyway
11:54:49 <Cale> Literally the only difference between them is the argument order thoug
11:54:50 <Cale> h
11:54:54 <NickHu> mm
11:54:54 <Cale> yeah
11:57:47 * hackagebot ap-reflect 0.3 - Partial evaluation reflection a la simple-reflect.  https://hackage.haskell.org/package/ap-reflect-0.3 (NickolayKudasov)
12:02:34 <soLucien> hello guys ! Please help me figure out how to write the evalArrayFor .. i can't figure out how to switch from the monadic context to outside it in the same function http://lpaste.net/662707290494730240
12:03:28 <mauke> what's ArrayFor?
12:03:43 <soLucien> oh sorry . i'll include that
12:03:44 <soLucien> sec
12:04:14 <soLucien> http://lpaste.net/662707290494730240
12:05:49 <mauke> ... I have no idea what that's supposed to represent
12:06:24 <soLucien> i'll include an explanation in the paste, so i don't spam this channel
12:07:10 <soLucien> down for maintenance
12:07:54 <NickHu> So, say I have a subcategory of Hask, Lst, where the objects are types like [a] and the morphisms are [a] -> [b]
12:08:30 <NickHu> If I want to form a Kleisli category over Lst from the Maybe monad, the morphisms will have type [a] -> Maybe [b]
12:08:45 <bash0r> When looking at the TH function 'reportError' it returns a Q (). quoteExp requires it's return value to be Q Exp. Is there a nicer way to handle compile time errors of a DSL in Quasi Quotation than report an error and generate a call to undefined or something similar so that it matches the signature of 'quoteExp'?
12:08:51 <NickHu> But how can Lst and this new category have the same objects? Those morphisms map to Maybe [a] not [a]
12:09:21 <oherrala> is there something like Python's tox for cabal/stack to automate testing with multiple ghcs and library versions?
12:10:10 <geekosaur> hm, if it's Q () then it expects to *return*, not abort. (Q a for an unspecified a would indicate abort.) so you need to deal anyway
12:10:49 <bash0r> Okay thanks!
12:10:51 <geekosaur> actually no, it'd just be a not Q a
12:11:09 <geekosaur> unfortunately I have no idea how you deal with being in an error state
12:11:10 <bash0r> Just wanted to know if there's a nicer way than what I did.
12:11:46 <geekosaur> I would have expected some function to abort compilation and clean up, but if that is the function then it has the wrong type...
12:12:56 <geekosaur> probably it expects you to produce some kind of non-garbage so it can go on and report other errors
12:13:08 <NickHu> Are the objects of Lst not infact types like [a]?
12:13:18 <geekosaur> and it can't know what, so it just produces Q () and leaves you to deal
12:13:49 <bash0r> reportError reports an error to the logger and goes on compiling. This is exactly what I want it to do. I want to report multiple errors in one run.
12:14:27 <bash0r> It would be kinda annoying for a user when your compiler reports one error per compilation. ^^
12:14:40 <geekosaur> right, I think I just said that
12:14:48 <geekosaur> you still need to produce something so presumably you need to splice in an undefined (not just return undefined)
12:14:49 <mnoonan> NickHu: the construction you gave isn't a monad on Lst
12:14:51 <bash0r> Just wanted to agree.
12:15:02 <mauke> bash0r: I'd actually prefer that
12:15:17 <bash0r> That's exactly what I meant by "generating".
12:15:17 <geekosaur> there's also the things that defer errors to runtime, so probably splicing an undefined into the AST is correct
12:15:23 <geekosaur> yeh
12:15:25 <mnoonan> it's a monad on Hask, restricted to Lst (sort of)
12:15:42 <bash0r> So thanks everybody!
12:16:19 <NickHu> mnoonan: Which construction are you referring to?
12:17:06 <mnoonan> NickHu: considering morphisms of type [a] -> Maybe [b].  You're trying to make Maybe a monad on Lst, but Maybe isn't an endofunctor on Lst.
12:17:26 <NickHu> Oh, I see!
12:17:54 <NickHu> So, monads must be endofunctors?
12:18:30 <mnoonan> NickHu: right. it gets a little swept under the rug in Haskell since every Functor (the typeclass) is endofunctor on Hask.
12:18:39 <NickHu> I see
12:18:57 <NickHu> Do there exist subcategories of Hask for which there are no monads?
12:19:57 <mnoonan> I'd assume so, with the exception of the identity monad
12:20:53 <grantwu> I thought this was interesting re: Hask http://math.andrej.com/2016/08/06/hask-is-not-a-category/
12:21:14 <NickHu> Ah, yes, the identity monad must exist of course
12:21:21 <NickHu> grantwu: I saw that, yes
12:21:29 <NickHu> But if you ignore undefined it seems to be okay
12:21:32 <NickHu> (I think)
12:25:41 <geekosaur> yes, Hask is understood to exclude undefined. see
12:25:51 <geekosaur> @google fast and loose reasoning morally correct
12:25:52 <lambdabot> No Result Found.
12:25:55 <geekosaur> bah
12:26:04 <Tuplanolla> http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
12:26:12 <grantwu> I think the article addresses the idea that ignoring undefined is fine and the fast and loose reasoning article
12:26:31 <geekosaur> https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf
12:28:08 <geekosaur> undefined is more or less accounting for the difference between theory and the real world. if you can ignore it in any other theory, why not this one?
12:28:39 <grantwu> I think it's not just undefined that causes issues, somehow, at least that's the sense that I got from reading the article
12:29:47 <geekosaur> well, the very first complain he raises is seq, which explicitly breaks things
12:30:11 <geekosaur> (that is, seq *by definition* is not covered by theory)
12:30:40 <nitrix> Is there a way to obtain all inhabited values of an algebraic data type without using Enum (which doesn't allow constructors that aren't unary) ?
12:31:18 <soLucien> so how can i extract something from a monadic context ?
12:31:22 <geekosaur> nothing canned, but I'd expect generics to be able to do so provided the fundamental values are covered by Enum
12:31:26 <soLucien> in the same function
12:31:41 <Berra> :t >>=
12:31:42 <nitrix> soLucien: Monads don't let you remove the context. Comonads do.
12:31:43 <lambdabot> error: parse error on input ‘>>=’
12:31:51 <geekosaur> :t (>>=)
12:31:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:31:56 <soLucien> i want to extract a value from it ..
12:31:59 <sclv> if you read andrej' article in the best possible light
12:32:11 <nitrix> soLucien: Instead, with monads, you're supposed to give the transformation function, which will happen within the context and produce a new monadic context.
12:32:35 <sclv> he's asking for researchers to study models of haskell that are _richer_ and closer to the "real thing" than the subset which the fast & loose article lets us address
12:32:37 <nitrix> soLucien: Are you really sure you want :: m a -> a ?
12:32:40 <sclv> and i think that's a super interesting and hard question
12:33:04 <sclv> like to me the fast & loose article is more a cautionary tale about the limits of our current state of reasoning
12:33:13 <sclv> than a "case closed" on possible future research
12:33:36 <Tuplanolla> If you want to pry open a monad, you'll have to do it on a case-by-case basis, soLucien.
12:33:39 <geekosaur> yeh, I have finally managed to read past the first page and the complaint is nobody actually sat down and produced a rigorous definition
12:33:58 <Tuplanolla> For example Identity provides runIdentity for that, soLucien.
12:34:17 <geekosaur> (well, except for the assertion that one is not possible --- which Andrej doesn't prove, making it on the same footing as Hask >.> )
12:34:26 <joe9> lyxia: Thanks.
12:34:47 <sclv> categorical accounts of domain theoretic constructions are messy
12:34:55 <sclv> andrej spent a good portion of his career looking at them
12:35:17 <sclv> so i interpret the article as a lament that this hard problem has been sort of swept aside rather than solved :-)
12:35:18 <NickHu> geekosaur: Oh cool one of my professors wrote that paper
12:35:19 <geekosaur> I will agree that treating Hask as a full formal specification is incorrect. it's a useful formalism but not intended to be a full theoretical framework
12:35:36 <sclv> i think its a full formal specification of _something_
12:35:40 <sclv> just not of haskell proper :-)
12:35:57 <geekosaur> right, but we already know it's a specification of a specific subset
12:36:05 <geekosaur> we just never set down the full specification of what subset
12:36:26 <geekosaur> and I'm not sure anyone considers that question interesting enough, aside from maybe Andrej
12:37:07 <geekosaur> (which.. .well, reading the addenda, I think not even Andrej; he's complaining not about Hask but about sloppy mistreatment of it by random Haskellers. which tbh is correct)
12:37:32 <sclv> idk what's wrong with "inductive datatypes and total functions between them, excluding seq" tbqh
12:37:48 <geekosaur> it's useful but people regularly oversell it
12:38:13 <sclv>  hask is fun for "doing categories with haskell" but not for "doing haskell, categorically"
12:38:19 <sclv> i think that's the important distinction
12:41:59 <NickHu> Does <=< bind tighter than function application?
12:42:23 <NickHu> Actually it's probably the same as .
12:42:23 <geekosaur> actually this touches on a recentish peeve of mine: the current tagline for xmonad is "...with formally proven extensions". when, and which ones? over 90% of them cannot be formally proven without a formal specification of the X server....
12:43:15 <geekosaur> :info says (.) is infixr 9, (<=<) is infixr 1
12:43:15 <Tuplanolla> You can ask GHCi with :i, NickHu. Smaller infix numbers bind tighter.
12:43:31 <NickHu> I see
12:44:39 <tsahyt> What should I read to wrap my head around the Data.Functor.* modules that are in base since 4.9.0.0?
12:45:27 <geekosaur> uh, re xmonad, even worse than that as potentially you need formal specifications for all apps too! someone did not think that out at all >.>
12:46:29 <lyxia> I thought "bind tighter" = "higher precedence" = "higher number"
12:47:05 <glguy> lyxia: That's right, level 9 "binds most tightly"
12:47:23 <Welkin> what about level 10?
12:47:40 <hpc> the way i keep track of it is whitespace function application is precedence 10
12:47:41 <glguy> doesn't exist
12:47:48 <hpc> and f x * g y is (f x) * (g y)
12:48:41 <hpc> sometimes people will imagine a fake level 10 for syntactic constructs which are outside the precedence system
12:51:16 <cocreature> hpc: so record update syntax is 11 :)
12:51:28 <ski>   @
12:52:57 <tsahyt> why is Endo not an instance of Functor? Surely if (-> a) is a functor, endo could be too?
12:53:15 <johnw> (a -> a) can't be a Functor
12:53:17 <soLucien> http://lpaste.net/662707290494730240 so lines 48-55
12:53:18 <glguy> tsahyt: Try writing the instance and see where you get stuck
12:53:26 <soLucien> i am tyring to extract Value 
12:53:29 <soLucien> from the monadic context
12:53:32 <soLucien> and return it
12:53:47 <hpc> tsahyt: what is fmap show (Endo (\x -> x + 1))?
12:54:10 <tsahyt> ah I see
12:54:23 <ski> hpc : `Endo (show . (+ 1) . read)', obviously ..
12:54:23 <tsahyt> because fmap can change the type on the right hand side of the arrow
12:54:46 <soLucien> i have included some explanation .. is it possible to somehow extract that Value ? The idea is the evalExpr takes a Expr and puts it in the monadic context
12:54:46 <tsahyt> which means that it might not be an endomorphism anymore
12:54:53 <soLucien> i am trying to do the opposite action now
12:55:16 <soLucien> take something from a monadic context and make an Array of Expr out of it
12:56:02 <hpc> one way of saying it is that in (Endo a), a is both covariant and contravariant
12:56:20 <johnw> soLucien: you know the type of what you have, and of what you need; so write the function that represents such a conversion
12:56:29 <johnw> you'll find out by trying if it's possible
12:56:30 <hpc> which incidentally also prevents it from being usable with https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html
12:56:54 <jle`> soLucien: yeah, don't get hung up with monadic
12:57:03 <jle`> "monadic"
12:57:06 * ski . o O ( `Data.Functor.Invariant' )
12:57:08 <jle`> just forget about it and write your function :)
12:57:13 <jle`> using, say, pattern matching
12:57:49 * hackagebot GLFW-b 1.4.8.1 - Bindings to GLFW OpenGL library  https://hackage.haskell.org/package/GLFW-b-1.4.8.1 (javjarfer)
12:57:51 * hackagebot bindings-GLFW 3.1.2.2 - Low-level bindings to GLFW OpenGL library  https://hackage.haskell.org/package/bindings-GLFW-3.1.2.2 (javjarfer)
12:57:53 <hpc> ski: oh nice
12:57:59 <hpc> also ooh, glfw update
12:58:03 <jle`> soLucien: usually, knowing that something is a monad doesn't help you use it in general, except in specific situations :)
13:03:27 <dmwit_> geekosaur: I believe the #xmonad /topic is referring (a bit tongue-in-cheek) to X.A.Navigation2D. The proofs show that the navigation methods make it possible to reach any window no matter what layout you're using.
13:03:46 <geekosaur> ah
13:03:53 <dmwit_> The proofs are linked from the documentation: http://www.cs.dal.ca/~nzeh/xmonad/Navigation2D.pdf
13:08:40 <mnoonan> there is no way to do a type-level 'let', huh? Like, if I have "data X t = A (F t) | B (F t) | ... | Z (F t)" for some type family F, it would be nice to say "let t' = F t in ..."
13:09:16 <hvr> oherrala: https://github.com/hvr/multi-ghc-travis is related
13:11:00 <joe9> in this code: http://dpaste.com/2CJ3SGV , the last isInBitMask, would it have been better implemented as: testBit bm . fromEnum?
13:11:08 <joe9> s/last/last function/
13:16:09 <biglambda> Is it possible to force ghc to inline a function parameter?
13:16:41 <lyxia> how so?
13:17:06 <biglambda> As in g f x = f x, then g sin x becomes sin x
13:17:41 <lyxia> isn't that just inlining g
13:17:57 <Cale> Yeah, that's just inlining g, and it does do that
13:18:26 <biglambda> I see, I’ve got multiple layers I’d like to make sure I’m inlining in my actual program
13:18:56 <biglambda> What is the easiest way to tell if it’s actually happening?
13:19:16 <biglambda> Or maybe I’m really overthinking it.
13:19:34 <biglambda> It’s in the inner loop and I’m rerwriting for performance reasons basically
13:19:56 <biglambda> But it ended up more parametric than before :)
13:21:19 <absence> is there something like scastie.org for haskell?
13:22:14 <johnw> biglambda: ​`-ddump-inlinings`
13:22:32 <biglambda> Thanks
13:22:57 <nitrix> I think GHC inline monomorphic values primarily? foo = ... would, while foo x = ... wouldn't ?
13:23:19 <nitrix> I'd expect Monomorphism Restriction to play a role?
13:23:38 <nitrix> I guess you can always {-# INLINE #-} it to make it more predictable.
13:24:32 <nitrix> I think if a function is called only once, it's also guaranteed to be inlined.
13:27:15 <nitrix> Reading the wiki now, it also says you need -O for inline function across modules. Otherwise without it, inlining stays only within modules.
13:28:32 <Tehnix> Anyone tried using yesod with docker and stack? 
13:28:50 <thoughtpolice> nitrix: The rule is that GHC inlines 'saturated' function calls. If you have `foo x y = ...` and apply `foo x`, then it's not saturated, so GHC may not inline it until later when that is exposed (or maybe not at all if it never is). But `foo x` will get inlined if you have `foo x = \y -> ...`
13:29:22 <soLucien> so if i want the value from the monad
13:29:33 <thoughtpolice> nitrix: And you can work around the -O0 restriction, incidentally, if you say '-O0 -fno-ignore-interface-pragmas'.
13:29:39 <soLucien> should i just 'feed it' a context ?
13:29:52 <nitrix> thoughtpolice: So function extensionality plays a role with this "saturated" concept. Very cool.
13:30:12 <soLucien> jle` johnw how would you get the Value out of there ?
13:31:37 <intothem1untains> Given [a -> Maybe a] and a, is there a way I can apply all those functions to a?
13:31:48 <intothem1untains> Something like iterate but for monads?
13:31:50 <johnw> soLucien: stop thinking about "the monad"
13:32:00 <intothem1untains> Well, I don't even care about intermediate results, only the final one
13:32:04 <johnw> soLucien: think in terms of functions on concrete types, which is what you have
13:32:32 <soLucien> evalExpr returns SubsM Value. I have tried to pattern match the Value
13:32:35 <nitrix> intothem1untains: What's the expected end result. [a] (all the results) or a (single result, used as an accumulator, passed /chained to each function)
13:32:35 <soLucien> and i could not
13:32:51 <intothem1untains> nitrix: a, passed though all the functions
13:33:03 <soLucien> what else can i do ?
13:33:05 <johnw> soLucien: it's a function that needs an argument to yield the value you're looking for, which it will only do if that function results in a Right value
13:33:18 <johnw> so there are cases in which no such value exists
13:33:18 <soLucien> yes , i have that kind of reasoning
13:33:28 <soLucien> in the Monad implementation
13:33:49 <nitrix> intothem1untains: It isn't possible.
13:33:50 <soLucien> things like   return x = SubsM ( \(env, _) -> Right (x, env) )
13:34:08 <intothem1untains> nitrix: why not?
13:34:34 <soLucien> so in order to get the Value , i feed it a Context
13:34:38 <nitrix> intothem1untains: What happens if one of those functions return Nothing, what is going to be your final value ?
13:34:51 <intothem1untains> Oh, sorry, the result should be Maybe a
13:34:51 <nitrix> intothem1untains: You cannot apply the remainder of the functions.
13:34:52 <intothem1untains> my bad
13:35:25 <nitrix> intothem1untains: Do you stop on a Nothing or you continue with the previous accumulator?
13:35:32 <intothem1untains> we stop
13:35:33 <soLucien> johnw how to pattern match the value ?
13:35:46 <soLucien> apply some f to it ?
13:35:53 <intothem1untains> so [a -> t a] -> a -> t a
13:36:12 <intothem1untains> or [a -> t a] -> t a -> t a
13:36:18 <intothem1untains> i don't mind
13:37:57 <johnw> soLucien: you can apply an f with 'fmap'; but you can't extract an 'a'.  The best you can do is runSubsM, then provide a context, and then case analyze the Either result.
13:37:57 <nitrix> :: t (a -> m b) -> t a -> m b ?
13:38:01 <thoughtpolice> nitrix: Maybe! The original motivation IIRC was simply making the inliner more predictable since it didn't really follow any rules. I think it's generally more intuitive - if you have 'f x = \y -> ...', it sort of makes sense to think of 'f x' operationally as a thing that is fully applied, that just happens to return a lambda.
13:38:10 <nitrix> err
13:38:13 <nitrix> :: t (a -> m b) -> a -> m b ?
13:38:23 <intothem1untains> nitrix: I could do with that, because yey return
13:38:26 <intothem1untains> I could do with that too
13:38:32 <intothem1untains> only that it happens a == b
13:39:03 <nitrix> You're right, we should maybe maybe it `a` congruent to `a` to force the function to accept the same input as previous outputs.
13:39:17 <intothem1untains> ideally (a -> m b) -> a -> m a
13:39:37 <intothem1untains> is there anything that has such a definition in the standard library?
13:39:38 <thoughtpolice> nitrix: It probably has other effects. To turn the partial version into the saturated version you'd also have to eta-expand'f', but eta conversion can result in observable differences due to `seq`, so GHC may be necessarily more conservative. In general I think the rule means inlining behaves more in line with what you expect, and has a more regular
13:39:38 <thoughtpolice> syntactic definition
13:39:49 <thoughtpolice> (Rather than it just sort of being "the inliner decided to, just because")
13:40:03 <nitrix> That seems like a fold using >>=
13:40:09 <intothem1untains> oh my
13:40:11 <intothem1untains> of course
13:40:22 * intothem1untains is banging their head against the wall
13:41:28 <EvanR> intothem1untains: (a -> m b) -> a -> m b, how about id ?
13:42:01 <nitrix> He's missing `t`
13:42:10 <nitrix> foo :: t (a -> m b) -> a -> m b
13:42:29 <nitrix> foo :: (Foldable t, Monad m) => t (a -> m b) -> a -> m b
13:42:42 <intothem1untains> yeah, foldl (>>=) it is
13:42:54 <nitrix> Oh and we concluded no `b` but `a` instead since they're the same type.
13:43:07 <intothem1untains> yeah
13:43:11 <nitrix> Yush :)
13:43:16 <intothem1untains> :t foldl (>>=)
13:43:18 <lambdabot> error:
13:43:18 <lambdabot>     Ambiguous occurrence ‘foldl’
13:43:18 <lambdabot>     It could refer to either ‘Data.List.foldl’,
13:43:34 <intothem1untains> :t Data.List.foldl (>>=)
13:43:36 <lambdabot> (Foldable t, Monad m) => m a -> t (a -> m a) -> m a
13:43:42 <intothem1untains> Marvelous
13:44:11 <nitrix> :t Data.Foldable.foldl (>>=)
13:44:13 <lambdabot> (Foldable t, Monad m) => m a -> t (a -> m a) -> m a
13:44:29 <nitrix> I wonder why it complaints about it being ambiguous if it just re-exports it.
13:44:41 <MarcelineVQ> someone's prob included something general
13:44:43 <MarcelineVQ> @undefine
13:44:43 <lambdabot> Undefined.
13:48:12 <intothem1untains> What's the best way to run tests on a bunch of propositions using quickcheck?
13:49:37 <nitrix> A few months ago, I'd have probably set fire at myself and claimed witchwork on foldl (>>=). I somehow naturally came up to that conclusion right now, even though I can't infer the types mentally.
13:49:40 <nitrix> Which is funny :P
13:50:16 <intothem1untains> :)
13:51:24 <intothem1untains> if i want to check whether f and g give the same output on x, is there a shorter way than f x == g x?
13:51:46 <intothem1untains> I mean, which would allow me to make the function point free?
13:55:57 <nitrix> You could check manually but I doubt GHC has a mechanism to do this sort of analysis.
13:57:50 * hackagebot haskell-src-meta 0.7.0 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.7.0 (GeoffreyMainland)
13:57:58 <MarcelineVQ> intothem1untains: yes but f x == g x is nice and clear
13:58:20 <Cale> There's liftM2 (==) f g
13:58:24 <intothem1untains> MarcelineVQ: what other alternatives are there?
13:58:32 <Cale> (or liftA2)
13:58:37 <intothem1untains> oh, I will need to look into that
13:58:39 <MarcelineVQ> Practicallly just those ones
13:58:47 <Cale> Similarly, (==) <$> f <*> g
13:58:53 <ongy> @pl f x == g x
13:58:53 <lambdabot> f x == g x
13:58:55 <intothem1untains> I don't even know what the mysterious liftM2 and liftA2 are
13:58:57 <MarcelineVQ> You could write it otherwise but the dots add up
13:59:00 <ongy> lambdabot being helpful
13:59:01 <Cale> @pl \x -> f x == g x
13:59:02 <lambdabot> liftM2 (==) f g
13:59:08 <nitrix> Oh. I thought he suggested something else entirely.
13:59:41 <nitrix> I was thinking domain/codomain and substitutions.
13:59:43 <intothem1untains> What if f and g accepted more than one arg?
14:00:18 <intothem1untains> Would those definitions still hold?
14:00:51 <nitrix> Can you give an example?
14:00:54 <Cale> Well, not if you wanted (\x y -> f x y == g x y)
14:01:06 <intothem1untains> Cale: let's say I do :p
14:01:15 <nitrix> foo f g x y = f x y == g x y ?
14:01:22 <intothem1untains> nitrix: yeah
14:01:25 <Cale> @pl (\x y -> f x y == g x y)
14:01:25 <lambdabot> ap (ap . ((==) .) . f) g
14:01:28 <intothem1untains> well, ideally for any number of arguments
14:01:28 <nitrix> That'd be .: !
14:01:47 <Cale> bad job @pl
14:01:49 <nitrix> @let (.:) = (.) . (.)
14:01:51 <lambdabot>  Defined.
14:01:58 <Cale> liftM2 (liftM2 (==))
14:02:01 <Cale> would work
14:02:26 <Cale> :t liftM2 (liftM2 (==))
14:02:26 <intothem1untains> could I not do something with currying/uncurrying so that it works with any number of args?
14:02:27 <lambdabot> (Monad m1, Monad m, Eq a) => m (m1 a) -> m (m1 a) -> m (m1 Bool)
14:02:51 <Cale> (pick m = (->) e and m1 = (->) e')
14:03:15 <Tuplanolla> I feel like you could also do this with `on` somehow.
14:03:15 <Cale> :t liftM2 (liftM2 (==)) :: (Eq a) => (e -> e' -> a) -> (e -> e' -> a) -> (e -> e' -> Bool)
14:03:17 <lambdabot> Eq a => (e -> e' -> a) -> (e -> e' -> a) -> e -> e' -> Bool
14:03:50 <nitrix> Tuplanolla: Is it `on` or `.:` ?
14:03:57 <nitrix> I'm on the same track as you.
14:06:19 <ongy> that reminds me, is 'fmap fmap fmap' equivalend to 'fmap . fmap'?
14:06:42 <nitrix> (f `on` g) ?
14:06:46 <nitrix> (f `on` g) x y
14:06:54 <nitrix> Not sure how you'd make it variadic.
14:07:24 <MarcelineVQ> that applies g to x and y then passes the results on to f
14:07:30 <nitrix> ongy: It think it would. The functor instance for ((->) r) is function composition.
14:07:57 <nitrix> If it isn't, I'd love to know why :P
14:08:28 <ongy> they have the same type. I just can't really figure out how 'fmap fmap fmap' works
14:09:25 <ski> @src (->) fmap
14:09:25 <lambdabot> fmap = (.)
14:10:41 <ongy> ahh, thx
14:11:34 <joe9> hvr: monochrom: I am running into stack related issues when used with .hsc files. Just want to check if the version of cabal that localises installs is ready to go? Do you use it?
14:12:04 <soLucien> could a String be converted in an array of Strings in one line/prelude function ?
14:12:06 <monochrom> I don't know.
14:12:27 <soLucien> as in i want "abc" to become ["a","b","c"]
14:12:28 <MarcelineVQ> Actually I'm wrong about that, I'm used to seeing f`on`g applied to one argument
14:12:34 <nitrix> soLucien: An array or a list of strings? Also, depends on what you want it to become.
14:12:45 <ReinH> > map (:[]) "hello"
14:12:48 <lambdabot>  ["h","e","l","l","o"]
14:12:51 <soLucien> is there some Prelude thing that does that ?
14:12:52 <soLucien> great
14:12:54 <ReinH> Also please don't call lists "arrays"
14:13:01 <MarcelineVQ> wait no, gosh, gonna bow out for being a dumb
14:13:10 <EvanR> who needs prelude functions when you can compose existing prelude functions!
14:13:39 <ongy> > fmap pure "abc" -- is typeclasses in prelude ok?
14:13:42 <lambdabot>  error:
14:13:42 <lambdabot>      • Ambiguous type variable ‘f0’ arising from a use of ‘show_M500628588797...
14:13:42 <lambdabot>        prevents the constraint ‘(Show (f0 Char))’ from being solved.
14:14:08 <monochrom> I thought we solved this last Friday.
14:14:35 <monochrom> complete with both the specific "map (:[])" and the general "fmap pure"
14:15:02 <monochrom> in fact last Friday it was even more elementary, it was "map (\x -> [x])"
14:15:04 <joe9> stack issue (I think):  https://paste.pound-python.org/show/5YwuLkSyLcQbZBRwGTIE/ error I think having a .hsc file is causing this error. Any suggestions on how to fix this, please?
14:15:16 <andromeda-galaxy> So, is every category definable in haskell necessarily closed
14:15:17 <andromeda-galaxy> ?
14:15:37 <EvanR> what is a closed category
14:15:37 <ReinH> No.
14:15:41 <andromeda-galaxy> It seems like (->) or whichever is the type constructor for functions, which my understanding says is actually internal homs?
14:15:52 <ReinH> I can easily define any number of non-closed categories.
14:15:54 * ski . o O ( symmetric closed )
14:15:59 <andromeda-galaxy> ReinH: hmm, how?
14:16:24 <ReinH> By taking some objects and arrow and not equipping them with the structure of a closed category.
14:16:31 <joe9>  List of files in the build dir: https://paste.pound-python.org/show/i0xLWqw4PRsR8YORuqoH/
14:16:51 <ReinH> e.g., the category () with object () and arrow id :: () -> () is not closed.
14:16:51 <andromeda-galaxy> ReinH: but as far as I understand it, the structure of a closed category is that there are internal homs?
14:17:00 <ReinH> The structure of a closed category is that it is closed.
14:17:01 <andromeda-galaxy> not closed monoidal
14:17:03 <andromeda-galaxy> not closed symmetric
14:17:07 <andromeda-galaxy> https://ncatlab.org/nlab/show/closed+category
14:17:10 <ReinH> Yes.
14:17:12 <ReinH> Closed.
14:17:12 <johnw> andromeda-galaxy: all you need is a Category whose arrows are not also objects
14:17:41 <ReinH> The structure is equivalent to having internal homs
14:17:43 <andromeda-galaxy> hmm, the problem I am having is basically with the Category typeclass. Doesn't the fact that it needs a *type of arrows* mean that there are internal homs in that that type is an object?
14:17:54 <andromeda-galaxy> I am sure there is something tha tI am missing here...
14:18:10 <ReinH> The category () can't be closed by definition.
14:18:20 <soLucien> map ((Just).(:[])) "hello"
14:19:05 <andromeda-galaxy> ReinH: why not?
14:19:23 <nitrix> soLucien: pure . pure :P
14:19:45 <soLucien> okay now i would like to do this Map but instead of ["a","b","c"] i want [Just"a",Just"b", Just"c"] 
14:19:50 <johnw> andromeda-galaxy: it only has one object, meaning, no object is also a morphism in the category
14:20:03 <ReinH> () -> () is not an object in the category ()
14:20:07 <jle`> > map (\x -> Just [x]) "hello"
14:20:09 * ski was about to ask andromeda-galaxy's question
14:20:10 <lambdabot>  [Just "h",Just "e",Just "l",Just "l",Just "o"]
14:20:11 <ReinH> since it contains only the object () by definition
14:20:21 <nitrix> > map (pure . pure) "abc" :: [Maybe String]
14:20:23 <lambdabot>  [Just "a",Just "b",Just "c"]
14:20:26 <andromeda-galaxy> johnw: ah, right. Okay that makes sense. How do you define the category () using the Category typeclass in the standardish libraries?
14:20:43 <ski> andromeda-galaxy : no
14:20:47 <ReinH> I didn't claim that you could define () using the Category typeclass
14:20:55 <joe9> Anyone using stack with .hsc files and hsc2hs build tool? I have this .hsc file in the library, but, when I build the exe, the repl errors out as it finds a common symbol between the .hsc file and the .hs file that it built when building the library?
14:21:07 <jle`> the () category can be implemented using Monoid, though :)
14:21:12 <ski> ReinH : "() -> () is not an object in the category ()" -- why not ?
14:21:13 <ReinH> Are you confusing "things that can be instances of Category" with "things that can be categories"?
14:21:15 <andromeda-galaxy> right, but I clarified my questoin above: "the problem that I am having is basically with the Category typeclass"
14:21:38 <ReinH> Right, but I wasn't answering that question, since you didn't pose it.
14:22:00 <ReinH> So now you're goal post shifting to a goal I wasn't shooting for.
14:22:12 <jle`> hm, how about the (:-) instance of Category?
14:22:21 <andromeda-galaxy> I am not. I am asking about (a) what things that are categories can be instances of Category and (b) is there a well known way of parametrically representing categories in Haskell (like Category does) that supports more categories?
14:22:25 <jle`> its objects are things of kind Constraint
14:22:41 <andromeda-galaxy> sorry, I guess I didn't communciate the question well. That is what I was asking the whole time, I tried to clarify it partway through
14:22:52 <jle`> fwiw i could have not gotten those questions from reading what you wrote earlier, heh
14:23:23 <andromeda-galaxy> yeah, sorry. I am still a bit confused about CT so I'm not great at phrasing my questions yet.
14:23:35 <andromeda-galaxy> Thanks for all the help with the other questions, though! Any idea about these ones?
14:24:06 <ReinH> Yes, you did shift the goal posts in the middle of me answering the question. How can you not see that?
14:24:14 <ReinH> You literally changed the question halfway through my answer.
14:24:38 <johnw> andromeda-galaxy: I think https://gist.github.com/cb12ab6889dec9abb361f3e107a2e7ed
14:24:55 <ReinH> And then you asked me how my answer conforms to your new question.
14:25:00 <andromeda-galaxy> yeah, sorry - that was just that I asked the wrong question by mistake. That is why I apologized about that, and why I tried to clarify what I actually meant. Thank you for the answer to the first question, it is just not the question that I was trying to ask
14:25:08 <ReinH> Ok
14:25:16 <johnw> actually, I don't think that's right
14:25:29 <jle`> well, categories are a pretty abstract concept.  i'm not sure it'd be useful to really represent *all* types of categories in a unified way in Haskell
14:25:38 <ReinH> ski: Because () has one object, and that object is (), not () -> ()
14:25:39 <jle`> but i guess it'd be interesting
14:25:46 <EvanR> jle`: abstract, even worse, vague ;)
14:25:56 <ReinH> nonsensically abstract, even
14:25:56 <ski> ReinH : why can't the exponential of `()' to itself, be `()' ?
14:26:14 <ReinH> ski: Why can there be exponentials at all?
14:26:25 <ReinH> (hint: they require the structure you're assuming exists)
14:26:34 <ski> (noone said the exponential would have to concretely correspond to `(->) :: * -> * -> *' in Haskell)
14:26:44 <jle`> i feel like the definition of a category is pretty non-vague, isn't it?
14:27:04 <ReinH> ski: In order for a category to have exponentials, what must be true?
14:27:05 <EvanR> maybe in type theory, but that doesnt get you necessarily everything you were referring to
14:27:30 <jle`> i was referring to the mathematical concept
14:27:47 <EvanR> you could also represent it with sets
14:27:59 <EvanR> and arrow types are sets, hom sets, but then... what they heck is Set
14:28:17 <EvanR> how do you fix it, be vague!
14:28:25 <ski> ReinH : sorry, s/exponential/internal hom/
14:28:40 <ReinH> ski: In a way, what you are saying is: why is the set N not a monoid? Well, it is, if you equip it with that structure.
14:30:26 <ski> ReinH : at least the five data items on that ncatlab page seems to be trivially present in the present case
14:32:24 <ReinH> I should choose just another category
14:32:29 <ReinH> er, just choose
14:33:53 <unit73e> hello. If anyone here uses vim and arch linux I created the 'vim-neco-ghc-git' package in AUR.
14:34:12 <unit73e> because reasons
14:34:46 <EvanR> sounds rigged
14:35:23 <ReinH> ski: But, I mean, this shouldn't be surprising. There are lots of categories you can construct that obviously aren't closed. Take any two types a, b and include one morphism a -> b. This is 2, which is not closed.
14:35:59 <ReinH> The actual question, about additional structure on categories that are Category instances, is more interesting.
14:36:50 <ph88> hi guys i'm trying to figure out why the manyTo function expects a string instead of char, anyone an idea?  https://paste.fedoraproject.org/442763/30555147/
14:37:06 <unit73e> EvanR, my package?
14:37:32 <ph88> i'm not even sure if i implemented it right ^^
14:37:57 <Tehnix> Hmm, I keep getting "docker: Invalid hostPort:  3000" with `run-args: ["-p 3000:3000"]` in my stack.yaml (and docker enabled). Anyone know how to expose ports?
14:38:04 <ReinH> andromeda-galaxy: Although I don't think it's really surprising: the representation used by Category is the internal hom representation.
14:38:28 <ReinH> er, it is the homset representation, and things that are representable must then necessarily have internal homs
14:38:39 <ReinH> since we need to be able to represent them in Haskell
14:39:06 <cocreature> ph88: manyTo requires p and end to have the same type but eol has type m String and anyChar has type m Char
14:39:10 <andromeda-galaxy> yeah, I am not surprised at all that there are categories that are not closed.  Yeah, the internal hom representation used by Category is what made me ask this: what all structures does that rule out? How else could we allow for them?
14:39:31 <ReinH> andromeda-galaxy: It rules out all structures for which the homset isn't an internal hom, i.e., exactly those which are not closed.
14:39:45 <ReinH> This is basically by definition :)
14:40:16 <andromeda-galaxy> okay, that is roughly what I was expecting. Thanks for the confirmation! Do you know of any other ways of representing categories in Haskell that don't have that restriction?
14:40:46 <ReinH> I'm not sure about alternative formulations, but I imagine this homoiconicity will always be restrictive in some way.
14:41:12 <lyxia> ph88: is 'Parser String' he type of 'eol'?
14:42:09 <lyxia> ph88: contrary to what you said, manyTo expects Parser Char
14:42:14 <ReinH> andromeda-galaxy: it's also possible that a Category must be a fully faithful subcategory of Hask, since it's an injective construction?
14:42:22 <ReinH> Not as sure about this one
14:42:41 <joe9> any cabal new-build users here? like it?
14:43:52 <joncol> Are there known issues with replacing text using Data.Text.Lazy.replace ? I just spent too long time trying to replace a string and when switching to strict Data.Text it worked immediately...
14:46:19 <andromeda-galaxy> ReinH: hmm, that is interesting... I'll have to look into that some more, thanks!
14:46:36 <ReinH> andromeda-galaxy: np
14:49:49 <nitrix> joncol: Was the issue a crash?
14:50:19 <joncol> nitrix: No just that `replace` didn't replace any text. Trying to create a minimal example.
14:52:47 <joe9> Any hanging issues when using Tasty. There is a pure test that I am trying. The tasty interface just hangs when running a particular test.
14:53:03 <nitrix> joncol: Are you doing other replaces prior to that one on the same string?
14:54:20 <nitrix> joe9: Is the source of the string something else lazy? Like IO stuff, that, by the time you're replacing things in that text, would produce an empty result?
14:54:39 <nitrix> Whoops, meant joncol.
14:54:58 <joe9> nitrix: yes, there is an empty list being produced in the computation.
14:55:23 <ReinH> iow `replace' might not be slow, it might be causing the evaluation of thunks representing other slow computations.
14:55:28 <joncol> The source of the string is a Parsec parse
14:56:05 <ReinH> Try profiling this and forcing the contents of the text before you do a replace. See which one is slow.
14:56:33 <joncol> nitrix: Created a small gist> https://gist.github.com/joncol/594b48e0ec895ab326cb00ebbe77f8b8
14:57:01 <nitrix> My bad, I misdiagnosed. I thought it produced an empty text, but it's just slow.
14:57:03 <nitrix> Checking.
14:57:51 * hackagebot wrecker 0.1.2.0 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-0.1.2.0 (JonathanFischoff)
14:57:54 <joncol> nitrix: Just added the parser function.
14:58:41 <nitrix> That comment field is suspicious looking :P
14:58:45 <joe9> this hangs the haskell process: https://paste.pound-python.org/show/VVfnEmaFO3YuuyvIF2dv/ shouldn't this be an error or some such?
14:59:07 <joe9> notice, that I am using original before assigning it.
15:00:13 <glguy> It's not necessarily a mistake to use something while defining it, the common example of that is : let xs = 1 : xs
15:00:34 <joe9> glguy: That will hang the process, correct?
15:00:40 <glguy> incorrect
15:00:45 <nitrix> Tying a knot.
15:01:38 <ReinH> > take 5 $ fix (1:)
15:01:40 <lambdabot>  [1,1,1,1,1]
15:05:24 <geekosaur> it only hangs the process if you try to consume the entire result (as ghci will do when it tries to print it). but laziness means you have the chance to add something into the pipeline that stops it from consuming the whole thing
15:05:53 <geekosaur> and then it becomes useful, because it is as large as it needs to be
15:06:26 <joe9> geekosaur: ok, Thanks. like a blocking read.
15:06:30 <geekosaur> more: it can be *exactly* as large as it needs to be and no larger
15:06:57 <geekosaur> that simple one is automatically so; more complex ones may need help to accomplish it, but it is possible
15:07:45 <ph88> lyxia, yes you're right in my question i mixed the two ^^
15:08:14 <geekosaur> in multiple senses: large enough in that it produces the necessary number of results, but especially in that simple case it is smart enough to recognize that, in and of itself, it doesn't need additional memory to store it. the consumer may use more memory but that's up to the consumer; the producer isn't wasting memory producing it
15:08:57 <joe9> geekosaur: ok, Thanks. makes sense. on a different note, do you use cabal or stack?
15:10:26 <geekosaur> I use cabal mostly
15:10:54 <geekosaur> actually I don't have stack installed atm because they deprecated the ubuntu repo and I haven't had a reason to reinstall the new preferred way yet
15:10:55 <joe9> geekosaur:  cabal new-build?
15:11:05 <geekosaur> not yet although I have it
15:11:36 <geekosaur> new-build is new enough that you may want to consult with #ghc and/or #hackage where the devs hang out
15:11:56 <geekosaur> (and they may point you at prereleases due to known bugs)
15:15:46 <soLucien> is it possible to set breakpoints in Haskell ?
15:15:51 <soLucien> some debugger kind of tool ?
15:18:27 <monochrom> ghci can. but don't expect it to be identical to gdb or stuff. because the evaluation model is different to begin with.
15:18:39 <monochrom> read the GHC user's guide for the full story.
15:19:20 <hpc> gdb is definitely not as good as stuff ;)
15:19:44 <hpc> you would probably also be interested in Debug.Trace
15:21:52 <soLucien> basically i have a _ which is matching something that should not be matched
15:21:55 <soLucien> i want to see why
15:22:04 <monochrom> read the GHC user's guide for the full story.
15:22:21 <soLucien> is debugging the best tool , or is something else possible ?
15:22:22 <grantwu> you can use debugTrace to on show of what you're matching
15:22:25 <hpc> _ as in an actual underscore pattern in your code?
15:22:29 <soLucien> yes
15:22:31 <hpc> because that will match anything
15:22:33 * monochrom will not type out over IRC what is already written in a public document.
15:22:56 <soLucien> i am asking monochrom whether i am taking the right approach
15:23:07 <monochrom> read the GHC user's guide for the full story.
15:23:10 <soLucien> i will read it if i have to
15:23:41 <hpc> if you're just trying to figure out why something is the wrong value, Debug.Trace is exactly what you need
15:23:55 <hpc> it just prints values to stdout wherever you damn well please
15:24:52 <hpc> going all the way to debugging is more useful when you need to go below semantics and watch the actual execution happening
15:25:02 <hpc> like if you're working on a performance bug
15:26:22 <monochrom> but ghci's debugger is not going to tell you about performance. because it runs on unoptimized code.
15:26:57 <monochrom> ghci's debugger is when you want to be reminded how unoptimized lazy evaluation works.
15:26:58 <hpc> oh right
15:28:08 <hpc> anecdotally, i have never had a problem that required dropping to a debugger to solve, outside an academic environment
15:28:11 <monochrom> to be fair, optimizations pretty much preserve the asymptotic costs.
15:28:23 <ReinH> Usually unexpected pattern matching behavior can be debugged by looking at your code and thinking about the problem for a while.
15:28:41 <hpc> yeah, that too
15:28:42 <ReinH> Of course this requires a basic understanding of how pattern matching works
15:28:53 <ReinH> But so does using Haskell in general
15:29:04 <hpc> perhaps take it as an opportunity to get very direct feedback on how modular your code is
15:29:17 <hpc> you know the line number of the pattern that doesn't work, theoretically
15:29:28 <hpc> so see how many other lines of code you need to care about in order to determine what's going wrong
15:29:33 <ReinH> Maybe the debugger can help isolate the problem, but so would writing your code in a more compositional style.
15:29:48 <ReinH> hpc: exactly
15:30:16 <hpc> this opinion turns heads whenever i say it around non-haskellers, but i think you should always be able to debug a piece of code just by looking at it for a while
15:30:27 <ReinH> If your code is hard to understand, that's a good sign that it's hard to understand. And since being hard to understand is causing problems, you should try to make it easier to understand.
15:30:31 <hpc> if you can't, the code isn't written well enough
15:31:41 <hpc> a lot of programmers tend to think that means never writing any complex programs, but really it does just mean breaking a problem into modular parts that are easy to understand in isolation and easy to understand how they fit together
15:34:09 <zennist> what's the average cost of getting the n th permutation of a list's permutations using Data.List?
15:34:30 <zennist> (!!n) . permutations 
15:34:40 <monochrom> @src permutations
15:34:41 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
15:34:55 <monochrom> ah I have to read it elsewhere
15:35:05 <zennist> i suspect it should be much cheaper than generating the whole set - but not sure
15:35:14 <zennist> https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.OldList.html#permutations
15:35:26 <ReinH> Unless you specify some ordering of permutations, why not just take the first?
15:35:41 <hpc> i would assume it's not great
15:35:49 <zennist> trying to do a random shuffle
15:35:59 <ReinH> in what sense is the nth permutation defined, except by whatever arbitrary order is imposed by the particular algorithm used.
15:36:27 <zennist> it doesn't have it - i just need to know it's one of the finite possibilities that I can choose
15:36:31 <zennist> /it/to
15:36:41 <lordcirth> zennist, I'm no expert but I'd just make a shuffler function yourself
15:37:18 <ReinH> Anyway, it's still O(m!) where m = length of list.
15:37:27 <jle`> yeah ... generating very possible permutation and then picking one of them is a very bad way of shuffling a list
15:37:36 <jle`> that's like, one of the worst possible ways i could imagine, heh
15:37:44 <jle`> like actually
15:37:46 <ReinH> O(m!) is pretty not good
15:37:51 <lordcirth> jle`, presumably there's a lazy way of doing that, though, so it wouldn't be as bad.
15:37:54 <monochrom> you still haven't imagined bogosort
15:37:57 <lordcirth> Still a rather roundabout way
15:37:59 <jle`> i can't imagine a single worse algorithm for shuffling a list
15:38:04 <jle`> i'm sorry
15:38:07 <ReinH> Again, if n is arbitrary then set n to 1
15:38:24 <josephle> lazy won't help, since you could always choose the last permutation
15:38:29 <ReinH> compute *one* randomly selected permutation
15:38:34 <zennist> well - the thing is, i know permutations as the function is lazy - so was hoping that would ease it 
15:38:34 <josephle> last being whatever is at the end of the arbitrary ordering
15:38:36 <jle`> monochrom: bogosort is a sorting algorithm?
15:38:56 <monochrom> yes, but we can add something to it to obtain: bogoshuffle
15:39:10 <jle`> please expand my mind
15:39:14 <jle`> in the worst ways :)
15:39:16 <zennist> but if you are choosing the last element, if the perm func is lazy, why would the previous items have to be evaluated?
15:39:35 <ReinH> why would you care if it's the last element??
15:39:46 <ReinH> if you're arbitrarily ignoring some permutations
15:39:59 <zennist> i'm just saying picking the last element doesn't necessarily mean it must be the abosolute worst case
15:39:59 <ReinH> you can choose to arbitrarily ignore zero permutations and just take the first one
15:40:12 <ReinH> Well, none of the other cases are better
15:40:21 <ReinH> You still have to traverse more of the list
15:40:25 <ReinH> than any other number
15:40:49 <jle`> ReinH: i'm presuming the algorithm is: (1) run Prelude's permutations x, (2) pick a random number from 1 to n!, (3) index into n
15:41:03 <hpc> i still don't understand why not to just generate a random shuffle of the list
15:41:20 <zennist> i'm thinking about alternatives that might be of value
15:41:24 <ReinH> Right, instead just create one permutation by choosing elements at random.
15:41:36 <ReinH> rather than all permutations and then choosing one at random
15:41:37 <zennist> of course you can, but there is something that you can already use, why not
15:41:59 <ReinH> Because doing it this way is bad
15:42:11 <ReinH> And that other thing also already exists, so that argument is moot
15:42:17 <zennist> that's why i was asking if someone knows the real complexity...
15:42:26 <jle`> it is literally the worst possible algorithm you could use for shuffling a list
15:42:27 <ReinH> Yes, it's O(n!) in the size of the list
15:42:31 <zennist> i mean i guess it would be bad too - and not disputing that, but still curious
15:42:43 <hpc> assuming that algorithm exists, average case scenario is you're indexing that list to the midpoint
15:42:51 <hpc> assuming everything else about it is an oracle
15:42:56 <hpc> so that's n!/2
15:43:02 <hpc> which is asymptotically n!
15:43:07 <ReinH> You have to choose a point in the permutations list without sampling bias
15:43:13 <hpc> which is worse than 2^n
15:43:15 <ReinH> or otherwise you introduce sampling bias
15:43:26 <ReinH> hpc: I said O(n!)
15:43:36 <ReinH> Which does not care about average cases.
15:44:31 <hpc> big O is worst case
15:44:38 <ReinH> Correct.
15:45:10 <ReinH> And that's also what we care about, since we need to avoid sampling bias in our choice of permutation.
15:45:11 <zennist> i guess if i can write a permutation funciton that makes the order explicit and someone takes an integer order key and generate the respective list
15:45:12 <hpc> just pointing out how bad it is that if you assume everything about it is magically perfectly instantly fast, just indexing the list is what screws you over
15:45:13 <zennist> that can work
15:45:23 <ReinH> Which means we must be just as likely to select any position
15:45:40 <zennist> i see the problem as indexing - not with permutation itself
15:45:42 <ReinH> zennist: Why are you refusing to do this the not awful way?
15:45:48 <ReinH> Generate one permutation.
15:45:55 <zennist> i'm not refusing, i'm spotting the composability
15:45:56 <ReinH> Do so randomly.
15:46:30 <hpc> what's more composable about it?
15:46:35 <ReinH> hpc: Yes, indexing the list is O(n!)
15:46:55 <zennist> sure - but what's stopping me from saying: okay you want a random shuffle, you can do it with randomly picking elems one by one, or you see the entire space of all possibilities of the shuffle and you can choose to have whatever sample function to get a number for that specific perm
15:46:58 <zennist> what's wrong?
15:47:15 <ReinH> Because you don't have constant time access to the space
15:47:22 <ReinH> You have really poorly performing access to the space
15:47:29 <zennist> if you can make each perm constant for a given int key - that works
15:47:34 <hpc> is your operation to pick a random shuffle, or to pick a specific shuffle?
15:47:48 <ReinH> Yes, if you have constant time access to the space, you can just select at random from the space in constant time
15:47:50 <ReinH> but you do not
15:47:52 <hpc> we need to know what we're trying to do before comparing implementations
15:48:06 <zennist> e.g., if you give me 0 i'd return you the original list, if you give me n!-1 I give you the reversed list
15:48:31 <lordcirth> Isn't it possible to make a function which takes an Int, and returns that perm, in constant time?
15:48:36 <zennist> if you can encode the order of elems in the perms into the integer key itself - then you can do it
15:48:53 <zennist> lordcirth: that's what i've been saying all the time
15:49:09 <lordcirth> I mean, it's probably simpler to just make a random shuffler
15:49:11 <monochrom> very few things in the universe are constant time
15:49:12 <ReinH> lordcirth: Yes, that's literally what I'm suggesting
15:49:18 <ReinH> (constant in the size of the Int, at least)
15:50:01 <lordcirth> but if it is possible to make such a function, then it is also possible to lazily generate a list of f(all inputs)
15:50:02 <ReinH> You pass that int as a random seed, then you generate a permutation at random using the seed
15:50:10 <ReinH> that has been my suggestion the entire time
15:50:24 <ReinH> lordcirth: generating the list isn't the problem
15:50:42 <ReinH> it doesn't matter how much time it takes to generate the list, unless it somehow takes *longer* than O(n!)
15:51:10 <zennist> ReinH: i think you are missing the point
15:51:16 <ReinH> I think you are missing our point.
15:51:41 <zennist> i'm suggesting writing a function,  Int -> [a] which guarantees that for input n in the range of (0..n!-1), each returned output is different
15:51:43 <lordcirth> I think just about everybody is missing someone else's point
15:51:48 <ReinH> My suggested solution is *exactly* encoding the order of elems into the integer key itself
15:52:00 <ReinH> If you use the same key, you get the same permutation
15:52:15 <zennist> yes sure
15:52:36 <lordcirth> What's the encoding scheme?
15:52:36 <ReinH> And it is constant time with regard to the size of the int key
15:52:46 <ReinH> lordcirth: As I said: use the int as the seed to a prng.
15:53:18 <lordcirth> ReinH, ah, and "randomly" choose your element order using this prng?
15:53:29 <ReinH> Yes, just as "randomly" as anything else we're talking about.
15:54:02 <ReinH> If your int key is generated by a prng, you have the same amount randomness as the original solution.
15:54:14 <lordcirth> True
15:54:17 <ReinH> you need to generate the int key randomly either way
15:54:23 <ReinH> that process is the same
15:55:00 <zennist> not sure if that would definitely work though - are you sure two different seeds guarantee to give you different sequences for whatever length of output you are looking at
15:55:28 <adnelson> Hi guys, why is it that Text doesn't seem to have a Read instance?
15:55:47 <glguy> instance Read Text -- Defined in ‘Data.Text’
15:55:56 <glguy> It has one. You'd have to tell us why it seems that it doesn't
15:56:09 <adnelson> >>> read ("foo" :: String) :: Text
15:56:11 <adnelson> *** Exception: Prelude.read: no parse
15:56:31 <zennist> say i have two elems, you put in 0, 1 for seeds, and is it actually true that the 0 seed would definitely choose the different thing from 1?
15:56:36 <glguy> Your read simply failed, but it used a Read instance
15:56:48 <josephle> zennist: depends on your prng algorithm at that point
15:56:49 <adnelson> How could any read of a string fail? It's an isomorphic type
15:56:50 <ReinH> > show "foo"
15:56:52 <lambdabot>  "\"foo\""
15:56:55 <glguy> The syntax for Text literals is the same as for String literals
15:57:00 <ReinH> > show "foo" == "foo"
15:57:02 <lambdabot>  False
15:57:19 <zennist> using prng is quite different from my original idea of building up a prob space... but okay - i think it might be a good idea
15:57:24 <adnelson> glguy: but I'm annotating my literals, there's no ambiguity
15:57:25 <ReinH> If you want to get "foo", you must read "\"foo\""
15:57:36 <ReinH> Ambiguity is not the concern.
15:57:38 <glguy> adnelson: yeah, you just used the wrong syntax for a string literal
15:57:38 <adnelson> oh jeez really
15:57:50 <adnelson> I guess that makes
15:57:51 <adnelson> sense
15:57:52 * hackagebot propellor 3.2.1 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-3.2.1 (JoeyHess)
15:57:54 * hackagebot HsOpenSSL 0.11.2 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.2 (VladimirShabanov)
15:58:01 <lordcirth> That's not terribly intuitive tbh
15:58:17 <ReinH> If you understand the purpose of Show/Read, it's obvious
15:58:29 <adnelson> that's a little belittling but ok
15:58:36 <ReinH> which are to write a Haskell value in a way that can be parsed an expression that is equivalent to the original value
15:58:46 <ReinH> e.g. take the output of show v and paste it into ghci and it should work
15:58:57 <ReinH> if that's the goal then
15:58:59 <ReinH> > show "foo"
15:59:01 <lambdabot>  "\"foo\""
15:59:03 <ReinH> is exactly what it should be
15:59:12 <adnelson> no, I understand that aspect
15:59:13 <verement> adnelson: maybe you're looking for `pack` rather than `read`
15:59:25 <adnelson> no, I'm trying to write a function which parses things from environment variables
15:59:33 <ReinH> then what else could show possibly be?
15:59:50 <adnelson> ReinH: I'm not trying to argue with you
15:59:52 <EvanR> adnelson: so you need a parser
15:59:58 <adnelson> I know
16:00:02 <EvanR> parsec, or attoparsec, megaparsec, trifecta
16:00:02 <adnelson> I can write this stuff by hand
16:00:22 <adnelson> EvanR: or just a type class
16:00:28 <EvanR> huh
16:00:40 <adnelson> for everything except strings/text/etc the Read type class should be fine
16:00:44 <adnelson> but it's all good
16:00:57 <EvanR> for quick and dirty, read might work
16:01:05 <grantwu> I've heard that you aren't really supposed to use Read that way
16:01:07 <EvanR> or it might almost work, in which case it doesnt work
16:01:09 <adnelson> yeah if I just want to be able to read ints etc
16:01:21 <adnelson> sometimes almost works is fine :)
16:01:34 <ReinH> Read is not for parsing arbitrary values
16:01:37 <grantwu> there are better ways of reading ints
16:01:38 <EvanR> i would be annoyed writing "strings \n like \n this" in an env var
16:02:00 <ReinH> If you use it for parsing arbitrary values, your parser will probably continue to cause runtime errors.
16:02:35 <adnelson> this isn't meant to be super robust or cover all possible edge cases, just to get something for a few uses
16:02:35 <tangled_z> Hi guys! I need some help. I am making a program that will involve JSON files but the schema for the JSON is evolving as I go along. Is there an easy way to migrate from old schema to new? 
16:02:36 <tangled_z> ie if my program currently generates JSON files based on an ADT "Person" with a name and a surname, and I decide to change the Person type to include an address, will Aeson still be able to parse the old Person JSONs or will I need to somehow migrate them?
16:03:01 <puregreen> where it will get the address from
16:03:03 <puregreen> *?
16:03:06 <adnelson> there are only a few types of values that I'm parsing so
16:03:12 <adnelson> anywho I think I'm good
16:03:23 <tangled_z> puregreen: it won't, so it would just be an empty address
16:03:39 <puregreen> you'll have to code that explicitly
16:03:39 <tangled_z> puregreen: but in the future the address will be inputed by the user along with name/surname
16:04:02 <tangled_z> puregreen: when you say explicitly...  what do you mean
16:04:30 <puregreen> tangled_z: https://artyom.me/aeson#optional-fields
16:04:52 <ReinH> One option is to explicitly version your APIs
16:05:01 <ReinH> This is also often a good practice in general.
16:05:36 <ReinH> Even if you do want to maintain backwards/forwards compatibility, explicit versioning gives you checkpoints to assess that
16:06:02 <tangled_z> puregreen: thanks! so if I specify "address" as an optional field which defaults to "", then next time the program reads the JSON (and doesnt find the address) it will add the blank value, and then I can convert it back to JSON? 
16:06:12 <puregreen> yep
16:06:19 <tangled_z> puregreen: great, thanks a lot :)
16:06:35 <tangled_z> ReinH:  That's a good idea. Would you have something to read on API design? 
16:07:03 <tangled_z> ReinH: where is the API version stored and what will it affect?
16:07:17 <higgs> lots of good answers for that
16:07:40 <higgs> I enjoyed reading https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/
16:08:06 <tangled_z> higgs: thanks :)
16:08:58 <ReinH> Usually, it's a contract that is enforced by both specification/documentation and implementation.
16:10:17 <tangled_z> ReinH: you make it sound like it's automatically verified?  because that sounds very appealing
16:10:39 <ReinH> Well, it can be. Requires some work.
16:11:00 <ReinH> I'm saying you both define the API spec for each version and then ensure you write a conforming impl.
16:11:05 <ReinH> Sometimes one can generate the other.
16:11:20 <ReinH> e.g. servant can do some of that iirc
16:12:09 <tangled_z> ReinH: oh right! I see what you mean, that's a good idea to be more explicit. What is a good formal language to define an API spec in? 
16:12:30 <ReinH> hahahaha formal language for api specs good joke
16:12:36 <tangled_z> >.<
16:12:56 <ReinH> There are things like http://json-schema.org of varying quality
16:13:32 <tangled_z> ReinH: Hmm, thanks!
16:14:03 <ReinH> In the real world, everyone defines their own ad hoc spec format by fiat as whatever the documentation they write happens to look like
16:14:07 <ReinH> it's great
16:14:16 <ski> tangled_z : in case you haven't seen it, Postel's law <https://en.wikipedia.org/wiki/Robustness_principle> (and the fourth reference), might be interesting
16:14:47 <ReinH> Hmm... I think I meant "de facto" rather than "by fiat"
16:15:11 <tangled_z> ReinH: Yeah I do always wonder what other people do for specs. 
16:15:52 <tangled_z> ReinH: my comment on formal languages (bad phrasing I know) was more out of curiosity for how others specify such things
16:15:54 <achot11> how does google adsense work? why am i getting .2 cents a day?
16:16:22 <achot11> no iam serious
16:16:34 <Koterpillar> achot11: this is not the channel to ask about that
16:16:49 <achot11> lol jackass, i just lost money
16:16:57 <ReinH> @where ops
16:16:57 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
16:16:57 <achot11> why dont u explain to me how it works
16:17:26 <tangled_z> ski:  that's really interesting, thank you! 
16:17:32 <ReinH> It is off topic. Don't disrespect people.
16:17:39 <lordcirth> achot11, why don't you ask somewhere remotely relevant to adsense?
16:17:46 <ski> achot11 : this channel is for the discusson of the Haskell programming language, and related topics .. do you have a question or comment about that ?
16:17:52 --- mode: ChanServ set +o edwardk
16:18:08 * edwardk shrugs
16:18:13 --- mode: edwardk set -o edwardk
16:18:32 --- mode: ChanServ set +o dcoutts
16:18:36 --- mode: ChanServ set -o dcoutts
16:19:05 <ski> tangled_z : happy to be able to share something interesting :)
16:21:20 <tangled_z> ski: ah yes, that 4th reference is exactly what ive been thinking about recently, asynchronous interactions ^^ that's exactly the sort of thing i was hoping to see when i asked my question! :)
16:26:48 <ski> tangled_z : hm, istr seeing some other relevant discussion as well ..
16:27:24 <tangled_z> ski: istr?
16:28:37 <tangled_z> not entirely sure what you mean by that!
16:28:45 <ski> "i seem to remember/recall"
16:28:57 <tangled_z> ohhh! right. 
16:29:17 <tangled_z> ski: If you wish to share then I would be quite interested
16:29:52 <ski> well .. if i could find them
16:30:10 * ski thought they were linked from that WP page ..
16:31:53 <Fairy> what does the $ sign mean in haskell?
16:32:12 <Koterpillar> :t ($)
16:32:13 <lambdabot> (a -> b) -> a -> b
16:32:18 <tangled_z> ski: ah, i see! i am quite curious now :)
16:32:48 <Koterpillar> Fairy: function application, with a low priority so the whole right side is the argument
16:32:58 <EvanR> by the power of parametricity i do declare it means its the identity function
16:33:12 <ReinH> might not be
16:33:21 <Fairy> ahh, basically brackets, sorry, was bit confused for a moment there because $ and . seemed to have been used interchangably
16:33:37 <EvanR> what else could it be?
16:33:41 <ski> tangled_z : iirc, it made be think about bounded polymorphism
16:33:43 <ReinH> Fairy: They *can* be used interchangeably in one case: f . g . h $ x = f $ g $ h $ x
16:34:01 <ReinH> this is because f . g . h $ x = f (g (h x)) and f $ g $ h $ x ALSO means f (g (h x))
16:34:19 <ski> tangled_z : roughly, it was about situations (or considerations) in which Postel's law can't be applied, at least not naively
16:34:21 <ReinH> @src (.)
16:34:21 <lambdabot> (f . g) x = f (g x)
16:36:13 <ReinH> f . g $ x = (f . g) x = f (g x)
16:36:17 <ReinH> @src ($)
16:36:17 <lambdabot> f $ x = f x
16:36:19 <tangled_z> ski: hmm  that's quite interesting. how would one begin to reason about whether a given situation is applicable to postel's law or not?
16:36:20 <ReinH> f $ g $ x = f (g $ x) = f (g x)
16:36:58 <ReinH> tangled_z: 1. Do you accept and/or send things?
16:38:02 <tangled_z> ReinH: Ok,yes, I am, but that's an obvious one. 
16:38:07 <Fairy> ReinH: What would f . g x = ?
16:38:52 <tangled_z> I was more curious about what ski was saying - when would Postel's law technically apply but wouldn't be a good idea
16:38:57 <ReinH> f . g x = \y -> f ((g x) y) = f (g x y)
16:39:04 <tangled_z> ski: what sort of problems would naively applying Postel's law to one such situation create?
16:39:14 <ReinH> er, = \y -> f (g x y)
16:41:17 <ski> tangled_z : iirc, it was (at least partly) about the kind of problems raised by M. Rose. but i remember a more involved discussion, with an example protocol with fields mentioned, and passing protocol data through several nodes in a network, possibly running different versions or implementations
16:41:41 <neonfuz> So I'm trying to write a somewhat efficient conways game of life implementation for practice, and I'm wondering if there is a good haskell'y and efficient way of navigating 2d arrays in constant time in haskell
16:41:47 <Fairy> ReinH: now you confused me. I'm throwing  f . g x  and I suddenly got this weird  y
16:41:58 <ReinH> @src (.)
16:41:58 <lambdabot> (f . g) x = f (g x)
16:42:34 <ReinH> (f . g) x = f (g x) is equivalent to f . g = \x -> f (g x)
16:42:47 <ski> tangled_z : when i read it, it reminded me of the difference between `forall a. C a => T a -> U a' and `(exists a. C a *> T a) -> (exists a. C a *> U a)' (the latter being the "OO" way, in some sense)
16:43:05 <Fairy> ReinH: ahhh, I'm silly. Cool, thx ;)
16:43:29 <ski> (those can be seen as examples of bounded quantification. TaPL has something to say about bounded quantification)
16:43:38 <neonfuz> aaa
16:43:40 <neonfuz> oops
16:44:16 <ReinH> Fairy: np
16:50:40 <tangled_z> ski: ah, hm, i havent played around with existential quantifiers in haskell yet so am having a little bit of trouble following that.
16:52:24 <ski> @where TaPL
16:52:24 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
16:53:25 <tangled_z> ski: thank you! 
16:55:09 <tangled_z> ski: we shall continue our chat after I bring up my type knowledge up to speed :)
16:55:53 <ski> tangled_z : you could also try "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)>, for some info on existentials
16:56:38 <ski> (that is a paper i tend to suggest to people not having much experience reading systems)
16:56:47 <neonfuz> so nobody here knows how to have a 2d array that can be accessed in constant time?
16:56:57 <neonfuz> err, navigated in constant time at least
16:57:17 <ski> tangled_z : that, and "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
16:57:27 <ski> (er, reading *type* systems)
16:57:54 * hackagebot http-conduit-downloader 1.0.30 - HTTP downloader tailored for web-crawler needs.  https://hackage.haskell.org/package/http-conduit-downloader-1.0.30 (VladimirShabanov)
16:58:22 <ski> neonfuz : `Array (Int,Int) Blah' ?
16:59:29 <neonfuz> lol yeah, that's probably good
16:59:34 <neonfuz> I was thinking with lists
16:59:40 <neonfuz> but I should just use that
16:59:44 <neonfuz> I'm new to haskell
16:59:49 <ski> well, you were asking about *arrays* ?
17:00:00 <tangled_z> ski: ah just read their abstracts, these are fantastic, thanks a lot :)  will definitely help me fill in some longstanding holes
17:00:01 * ski wasn't following neonfuz's question from before
17:00:13 <ski> lists don't have constant time access, though
17:01:16 <neonfuz> ski: no not to an arbitrary index they don't, but you can iterate over them in constant time
17:02:58 <redmq> 2
17:03:47 <ski> tangled_z : "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> is sortof a follow-up to the latter of the above, about a way to regard OO (as opposed to abstract data types. a topic TaPL also brings up, but not from the same angle)
17:04:28 <ski> neonfuz : ok, that's what you meant by "navigated"
17:04:37 <ski> neonfuz : if you want to, you could use a list of lists ..
17:06:34 <ski> neonfuz : .. i suppose the problem with a list of lists is that you don't have an easy way to pass from a cell in a "row" in your "matrix", to the cell in the row below it
17:07:45 <ski> (if you only wanted to be able to navigate "down" and "right", but not change any data, then a binary tree would suffice)
17:09:21 <Phagus> Is "Learn You a Haskell" a good book for learning functional programming concepts?
17:09:34 <neonfuz> ski: yeah, thats what I thought too, if either the width or height was never going to be different I could use tuples, but that sounds stupid
17:09:37 <neonfuz> I guess thats why they have arrays
17:10:02 <tangled_z> ski: nice one, thanks! :)  just looking at it now. William seems like the sort of person I would enjoy having dinner with
17:10:55 <tangled_z> Phagus: It's a nice book, but try checking up this site for  aguide on how to start up on learning FP: https://github.com/bitemyapp/learnhaskell
17:11:13 <tangled_z> Phagus: if you can get the Haskell Book itself then I would recommend that  too
17:12:11 <Phagus> tangled_z: Thanks!
17:12:23 <tangled_z> :)
17:13:32 <rui> Is there a list of haskell functions/operators sorted by usage frequency is, for example, code in hackage?
17:14:14 <ReinH> Not that I've seen.
17:17:18 <ski> Phagus : fwiw, the author of the book set up the channel #haskell-beginners (partly) for people working through that book
17:18:08 <tangled_z> wow nice,that's a lot of people there!
17:20:42 <ski> tangled_z : oh, just noticed .. perhaps you'd prefer using a .. more capable IRC client, if you want to hang around these parts ;)
17:21:27 * EvanR spittoons
17:21:31 <tangled_z> ski: yeah i am getting more into this irc business :) what do you recommend? (preferably light weight and with channel logging)
17:21:56 * ski uses Irssi, but doesn't log
17:23:10 <ski> (on windows, some people like mIRC, or HexChat. dunno about Mac. i used X-Chat on *nix for some while. there's more alternatives)
17:23:22 * ski even tried AmIRC a little bit
17:23:26 <Koterpillar> pidgin
17:25:07 <ski> (.. apparently X-Chat got part of its design from it)
17:25:33 <monochrom> I used xchat. Now I use hexchat.
17:26:31 <ski> (the windows version of X-Chat used to nag people. there was an alternative build, but iiuc, it's not up-to-date anymore. hence HexChat)
17:27:38 <monochrom> yeah, but after using hexchat on windows, I find it such an improvement over xchat that I adopt hexchat on linux too
17:27:49 <ski> i see
17:29:41 <tangled_z> interesting, thanks for the recommendations guys! Im on *nix so will check out xchat/hexchat!
17:29:42 <tangled_z> :)
17:34:23 <ski> (fwiw, in case it was unclear, beginner questions are welcome in here as well)
17:35:24 <tangled_z> cheers! I am digging this community. 
17:35:24 <srhb> rui: It sounds like an interesting project for crawling Github... ;-)
17:35:38 <tangled_z> srhb rui : yeah i thought so too. 
17:35:54 <srhb> Someone Should Do That^tm
17:37:27 <rui> srhb: Yeah, interesting and useful. Unfortunately, it is way beyond me
17:37:56 <srhb> rui: Might not be for that long. :-)
17:42:54 <dmwit> rui: There's language-haskell for parsing. It won't get you renaming, but maybe just sorting on unqualified names is already interesting enough.
17:50:30 <soLucien> can i transform this into a let ? 
17:50:31 <soLucien> case runSubsM (evalExpr array) ctx of
17:50:31 <soLucien>     Right(x vals, _) -> do
17:51:12 <Axman6> technically, but it would be unsafe and would throw an exception if runSubsM returned a Left value
17:51:23 <soLucien> i would not mind that
17:51:32 <soLucien> i know it's always right
17:51:36 <Axman6> also, the x vals bit doesn't make sense, is that a placeholder for something?
17:51:44 <soLucien> it is a type
17:52:04 <soLucien> polymorphic 
17:52:53 <lordcirth> soLucien, if you know it's always Right, why not strip it out of the Either?  Or do you intend to pass the Either along?
17:53:04 <soLucien> so how would i write it, axman ?
17:53:12 <soLucien> how can i strip it
17:53:15 <soLucien> out of the either ?
17:53:27 <soLucien> ah you mean get rid of it ?
17:53:53 <lordcirth> Yeah, if it's always a Right value, just take it out of the Either first.
17:54:12 <lordcirth> (note I'm no Haskell expert but it makes sense to me)
17:54:13 <soLucien> please give me an example of how to do this with let
17:54:46 <Axman6> let Right (xvals,_) = runSubsM ... in ... 
17:55:26 <Axman6> but if there's any possibility that could return Left, you shouldn't do that (and if there's no chance that runSubsM can ever fail, then it shouldn't be using Either)
18:10:02 <stoogenmeyer> hey all, trying to go through the stack walkthrough and getting an issue.. the guide is telling me to import the text package via `import qualified Data.Text.IO as T` and then run `someFunc = T.putStrLn "someFunc"`
18:10:23 <stoogenmeyer> however, the compiler complains with `Couldn't match expected type ‘Data.Text.Internal.Text’  with actual type ‘[Char]’
18:10:41 <stoogenmeyer> Is the guide simply outdated and the T.putStrLn has changed since the time of writing?
18:10:51 <Koterpillar> enable OverloadedStrings
18:11:51 <stoogenmeyer> oh thank you.. that fixed it
18:11:55 <stoogenmeyer> what did that do?
18:12:35 <Koterpillar> changed the type of all the string literals from String to IsString a => a
18:12:38 <Koterpillar> :t "asdf"
18:12:40 <lambdabot> [Char]
18:13:07 <Koterpillar> @let {-# LANGUAGE OverloadedStrings #-}
18:13:08 <lambdabot>  Defined.
18:13:10 <Koterpillar> :t "asdf"
18:13:11 <lambdabot> [Char]
18:13:13 <Koterpillar> well
18:13:26 <Koterpillar> check it for yourself in GHCi
18:14:40 <rubenz> @type (flip $ (flip $ f . g) . g)
18:14:42 <lambdabot> error:
18:14:42 <lambdabot>     • Could not deduce (Show b0) arising from a use of ‘f’
18:14:42 <lambdabot>       from the context: (FromExpr c, Show a1, Show a)
18:15:01 <rubenz> @type \f g -> (flip $ (flip $ f . g) . g)
18:15:02 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:15:22 <stoogenmeyer> Koterpillar: hehe, doesn't work for me either in ghci
18:15:34 <stoogenmeyer> I tried just `{-# LANGUAGE OverloadedStrings #-}` instead of with @let
18:15:53 <geekosaur> ":set -XOverloadedStrings"
18:16:12 <rubenz> Is the above function in any of the standard packages anywhere?
18:16:42 <stoogenmeyer> geekosaur: yep that did it
18:16:42 <geekosaur> :t Data.Function.on
18:16:43 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
18:16:55 <rubenz> a ha!
18:17:13 <srhb> @hoogle (b -> b -> c) -> (a -> b) -> a -> a -> c --rubenz
18:17:14 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:17:14 <lambdabot> Data.Function.HT compose2 :: (b -> b -> c) -> (a -> b) -> (a -> a -> c)
18:17:14 <lambdabot> CorePrelude on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
18:17:25 <rubenz> cool thanks
18:18:25 <geekosaur> alos, re lambdabot, doing the @let there changes what @run (aka "> " prefix) does but doesn't affect @type (":t")
18:23:55 <Zemyla> Okay, I have a strange problem for you all.
18:26:44 <seagreen> With stack, is there a way to specify that you want a local project at a specific commit?
18:29:33 <Koterpillar> seagreen: yes, reference it as a repository
18:30:01 <Koterpillar> seagreen: hint: /path/to/a/repo is a valid location for git:
18:34:12 <dmwit> > (\f g -> flip $ (flip $ f . g) . g) f g x y
18:34:14 <lambdabot>  error:
18:34:14 <lambdabot>      • Could not deduce (Show b0) arising from a use of ‘f’
18:34:14 <lambdabot>        from the context: FromExpr c
18:34:23 <dmwit> > (\f g -> flip $ (flip $ f . g) . g) f g x y :: Expr
18:34:25 <lambdabot>  error:
18:34:25 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘f’
18:34:25 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
18:35:29 <glguy> :t f
18:35:31 <lambdabot> FromExpr a => a
18:35:40 <glguy> You have to give it a stronger hint on f and g
18:35:57 <dmwit> > (\f g -> flip $ (flip $ f . g) . g) f (g :: Expr -> Expr) x y :: Expr
18:35:59 <lambdabot>  f (g x) (g y)
18:36:57 <dmwit> Oh, there's an easier way.
18:37:03 <dmwit> ?unpl \f g -> flip $ (flip $ f .g) . g
18:37:04 <lambdabot> \ f g x y -> f (g x) (g y)
18:43:25 <seagreen> Koterpillar: Are you sure that works? I'm getting an error, even though I've checked the `git:` argument using cd and the `commit:` arg is correct.
18:43:40 <seagreen> Error: `/home/traveller/code/mine/jcycle/.stack-work/downloaded/sUd3RZ-3e2Hj/: getDirectoryContents: does not exist (No such file or directory)`
18:48:51 <ReinH> uh why would you put something in .stack-work there?
18:50:40 <geekosaur> um, if it's downloading it, it
18:50:51 <seagreen> ReinH: I haven't messed with ./stack-work, only my stack.yaml.
18:50:51 <geekosaur> s not a local project\
18:51:19 <geekosaur> ... um/ sounds like it is caching something, then
18:51:28 <geekosaur> probably need to do a full clean
18:52:06 <seagreen> geekosaur: I thought that might be it as well, so I deleted my ./stack-work and tried `stack build` again, but got the same error.
18:52:26 <geekosaur> you might be in "file a bug" territory then
18:52:57 <geekosaur> I would expect it to work given the documentation (I got there about the same time Koterpillar did but they responded first)
18:53:08 <geekosaur> (not n a position to test currently0
18:53:14 <geekosaur> ..... whoops
18:54:01 <seagreen> geekosaur: Agreed this has entered "file-a-bug". Thanks for the help everybody! "file-a-bug" is actually fine here, I happily don't have an urgent need for this:)
18:57:56 * hackagebot countable-inflections 0.0.1 - Countable Text Inflections  https://hackage.haskell.org/package/countable-inflections-0.0.1 (tippenein)
18:57:58 * hackagebot countable-inflections 0.1.0 - Countable Text Inflections  https://hackage.haskell.org/package/countable-inflections-0.1.0 (tippenein)
18:59:50 <ReinH> your path includes .stack-work, which seems wrong
19:03:18 <lpaste> Zemyla pasted “Typed SKI Calculus Problem” at http://lpaste.net/240303
19:03:39 <seagreen> Actually, are we sure that Stack intends to support local paths in `git:`? I don't want to file a bug about something that wasn't intended in the first place.
19:03:47 <ReinH> seagreen: what did you put in your stack.yaml?
19:04:29 <seagreen> ReinH: `git: '/home/traveller/code/mine/station'`
19:05:56 <glguy> seagreen: If it doesn't it should say so instead of reporting a getDirectoryContents failure
19:07:55 <seagreen> glguy: good point
19:12:16 <geekosaur> at the very least it should document that it doesn't, and it has no such documentation; it gives the impression any git repo is appropriate
19:12:33 <geekosaur> so I'm guessing it was just untested
19:15:11 <seagreen> geekosaur: Issue opened, going to pass this one to the experts.
19:15:32 <seagreen> Poor stack guys, 400+ opened issues:(
19:16:41 <Zemyla> seagreen: It could be worse. They could be the GHC guys.
19:16:49 <geekosaur> hey, it's proof that stack is used :)
19:17:00 <soLucien> how could i reduce duplication here? http://lpaste.net/5900146473168797696
19:17:05 <geekosaur> (99 bugs in the code.. take one down, patch it around, 101 bugs in the code...)
19:17:06 <seagreen> Oh snap, this may be a NixOS/shell.nix issue, I set `nix: pure:` to `false` in `stack.yaml` and now it's compiling..
19:20:09 <geekosaur> that may indicate an unfortunate interaction between their nix and git support, which is still a bug
19:20:24 <geekosaur> and at minimum could do with some clarifying documentation
19:20:47 <geekosaur> so, still very much worth reporting
19:21:35 <seagreen> geekosaur: Don't worry, no backing down now.
19:21:48 <seagreen> Updates to follow here: https://github.com/commercialhaskell/stack/issues/2670
19:30:22 <Koterpillar> seagreen: sorry, missed the whole thing, glad you figured it out
19:57:57 * hackagebot ghc-events-analyze 0.2.3 - Analyze and visualize event logs  https://hackage.haskell.org/package/ghc-events-analyze-0.2.3 (EdskoDeVries)
20:11:34 <seagreen> No worries, you gave the exact right advice.
20:13:15 <umib0zu> Hi all, what’s the exact details of the namespace when using stack?
20:14:16 <umib0zu> when I’m running tests and I specify in my test exectable statement HUnit as the build depends, I also seem to need to add import Test.HUnit in my test file.
20:14:30 <umib0zu> Why do I need to prepend a “Test.”?
20:16:18 <srhb> umib0zu: That's the way HUnit structures its modules.
20:16:21 <Gurkenglas> soLucien, http://lpaste.net/5900146473168797696#a240315
20:16:27 <srhb> umib0zu: https://hackage.haskell.org/package/HUnit-1.3.1.2
20:16:29 <umib0zu> srhb I’m seeing that now
20:16:45 <umib0zu> great catch thanks. srhb. this one had me stumped for a bit
20:18:38 <umib0zu> srhb do you have a haskell library to look at? I’m also confused about referencing my modules in the src folder. they also seem to not resolve.
20:19:10 <srhb> umib0zu: Do you know how the haskell module namespace works? Each directoty adds another layer to the module path
20:19:31 <srhb> umib0zu: So if src is the root of your source files, src/Foo/Bar/Baz.hs becomes the module Foo.Bar.Baz
20:19:59 <Gurkenglas> 'if cVal == TrueVal then return True else return False' x.x
20:20:30 <umib0zu> I do know that, but it still seems to fail. I have a folder with src/B.hs with a module B and a test filte test/TestB.hs.
20:20:40 <umib0zu> in TestB.hs I have import A.
20:20:54 <umib0zu> I think it’s wrong, but I’ve also tried src.A which I doubt is correct
20:21:05 <umib0zu> sorry, “import src.A"
20:21:10 <Koterpillar> for this to work, both src and test must be your roots
20:21:34 <Koterpillar> src.A won't work, you must have src/.. as a root _and_ modules must start with an uppercase letter
20:21:59 <Gurkenglas> For a moment there I even thought that TrueVal was True :D
20:22:54 <umib0zu> Koterpillar do I set that in the hs-source-dirs in the cabal file?
20:23:47 <Koterpillar> yes
20:24:00 <Koterpillar> do you have one or two targets in the cabal file?
20:24:49 <umib0zu> Koterpiller 2, I’m just using the stack new cabal file
20:24:59 <umib0zu> one’s a executable and the other is a test suite
20:25:07 <Gurkenglas> soLucien, is the program supposed to crash if arrCompr doesn't have the form ArrayIf condition Nothing?
20:25:19 <umib0zu> one has hs-source-dirs as app, the other test
20:25:21 <Koterpillar> then the test section should have hs-source-dirs: test and build-depends: <your library name>
20:25:32 <Koterpillar> app? not src?
20:25:39 <soLucien> yes, it's an interpreter
20:25:54 <soLucien> so it relies on the parser giving it correct output
20:26:01 <umib0zu> yes app Koterpillar
20:26:19 <Koterpillar> umib0zu: then nothing from src/ will be found
20:26:55 <stoogenmeyer> hey.. I've been looking at https://hackage.haskell.org/package/split-0.2.3.1/docs/Data-List-Split.html for how to split strings
20:27:06 <stoogenmeyer> but how would I split "123" into ["1", "2", "3"] ?
20:27:42 <jle`> stoogenmeyer: strings are lists, so you can just map a function
20:27:44 <amalloy> > map pure "123" :: [String]
20:27:45 <Koterpillar> stoogenmeyer: split on every character, why?
20:27:46 <lambdabot>  ["1","2","3"]
20:27:47 <jle`> > map (\x -> [x]) "123"
20:27:49 <lambdabot>  ["1","2","3"]
20:28:01 <stoogenmeyer> oh of course.. thank you
20:28:11 <umib0zu> Koterpillar got it it seems to be passing preprocessing now
20:28:37 <jle`> i feel like this question was just asked a couple of hours ago and a couple of days ago too
20:28:38 <umib0zu> thanks Koterpillar srhb
20:28:47 <jle`> i wonder if there's a course going on that is assigning it?
20:48:38 <Zekka> jle`: I don't know if someone is assigning it, but you're not wrong
20:57:59 * hackagebot hnix 0.3.3 - Haskell implementation of the Nix language  https://hackage.haskell.org/package/hnix-0.3.3 (JohnWiegley)
20:58:01 * hackagebot ghc-events-analyze 0.2.4 - Analyze and visualize event logs  https://hackage.haskell.org/package/ghc-events-analyze-0.2.4 (EdskoDeVries)
21:07:26 <stoogenmeyer> jle`: wasn't a course.. just played a bit on the first few project euler questions and that was necessary. night folks, thanks for the help!
21:10:19 <grantwu> https://hackage.haskell.org/package/twilio "While we would like to have a complete binding to Twilio's REST API, this package is being developed on demand."
21:10:26 <grantwu> I knew people said Haskell was lazy... but
21:10:28 <grantwu> :P
21:10:36 <jvanbure> 10/10
21:11:41 <amalloy> https://ro-che.info/ccc/11
21:12:24 <srhb> grantwu: as long as the unimplemented requests just block for now... :-)
21:13:35 <somaReve1> Hi, how can I use the scalpel library in haskell. I did 'import Text.HTML.Scalpel
21:13:37 <somaReve1> '
21:13:44 <somaReve1> It complains not found.
21:15:41 <srhb> somaReve1: Did you install the library, and if so how?
21:16:50 <somaReve1> srhb: oh, how can I install scalpel?
21:16:55 <soLucien> is there a function that would bring [['a'],['b']] to ['a','b'] ?
21:17:10 <srhb> soLucien: Try working out the type of that function and searching for it with hoogle
21:18:38 <srhb> somaReve1: There are many ways. cabal install, Stack, Nix, system package manager. How did you install ghc?
21:18:57 <Axman6> soLucien: concat:
21:18:59 <Axman6> :t concat
21:19:01 <somaReve1> srhb: using pacman install
21:19:01 <lambdabot> Foldable t => t [a] -> [a]
21:19:12 <Axman6> > concat ["a","b"]
21:19:14 <lambdabot>  "ab"
21:19:15 <soLucien> i need something else .. i found concat
21:19:19 <Koterpillar> zip?
21:19:28 <Axman6> what do you actually need?
21:19:35 <Koterpillar> > zip ['a'] ['b']
21:19:37 <lambdabot>  [('a','b')]
21:19:47 <soLucien> i actually need smth that will bring  [['a'],['b'],'c'] to ['a','b','c']
21:19:50 <srhb> soLucien: concat does exactly what you asked for.
21:19:59 <dmwit> soLucien: I don't believe you.
21:19:59 <soLucien> yes, i just realized that
21:19:59 <srhb> > ['a', 'b', 'c'] == "abc"
21:20:02 <lambdabot>  True
21:20:26 <soLucien> they are not chars, they are values of type X
21:20:34 <soLucien> i used char as an example
21:20:34 <dmwit> soLucien: Specifically, I don't believe you have something that will construct [['a'],['b'],'c'].
21:20:52 <Koterpillar> yeah, what type is that?
21:20:56 <soLucien> i
21:21:12 <soLucien> i am evaluating something recursively and i get a list of stuff
21:21:25 <srhb> somaReve1: Well, perhaps you can install cabal-install or Stack and use that. :) It's really a matter of personal taste, so you should probably research it a bit.
21:21:40 <soLucien> i have this function which does it, but there has to be something better
21:22:19 <soLucien> http://lpaste.net/8655711393367982080
21:22:40 <soLucien> so x is my type
21:22:48 <soLucien> ArrayVal is my type
21:22:49 <soLucien> sorry
21:22:53 <dmwit> I feel vindicated.
21:23:35 <Koterpillar> that doesn't typecheck in my head at least
21:23:48 <Koterpillar> oh, wait, priorities
21:24:24 <Koterpillar> :t concatMap -- soLucien
21:24:26 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
21:24:46 <soLucien> now it does http://lpaste.net/8655711393367982080
21:25:37 <somaReve1> srhb: cool, i use cabal install. thanks
21:26:26 <soLucien> concatMap miht work
21:29:56 <lpaste> koz_ pasted “Can I make this into a Functor?” at http://lpaste.net/240419
21:31:11 <Axman6> koz_: no, because a appears in negative position (on the right hand side of an arrow)
21:31:22 <koz_> Axman6: I thought so.
21:31:53 <koz_> It's the 'a -> m a' that's problematic, right?
21:32:52 <pavonia> and a -> o
21:33:40 <somaReve1> srhb: hmm, after i installed scalpel from cabal install, "import Text.HTML.Scalpel" still complains not found.
21:34:12 <dibblego> you could make it a functor if you rearranged the type constructor, over the parameter (o)
21:35:05 <koz_> dibblego: It'd need to be 'RunParams a m o' then, right?
21:35:13 <dibblego> yes
21:36:19 <koz_> Oh well, it was just an idle thought. I don't really need a functor instance there - I just wanted to confirm my intuition that I couldn't make one on 'RunParams o m'.
21:37:34 <Axman6> good intuition =)
21:39:07 <soLucien> okay so is it possible
21:39:18 <soLucien> to use concatMap to create the same behavior
21:39:28 <soLucien> as i have in the lpaste ? i just can
21:39:33 <soLucien> can't get it
21:39:45 <srhb> somaReve1: Paste the commands you used and their results on lpaste.net and someone might be able to assist. I have to go now though. :)
21:40:23 <soLucien> http://lpaste.net/8655711393367982080
21:40:41 <soLucien> can  i acheive the same thing in a shorter way ?
21:40:46 <Koterpillar> soLucien: you have a straight foldr now
21:41:38 <soLucien> so foldr ?
21:41:50 <soLucien> :t FoldR
21:41:51 <lambdabot> error:
21:41:51 <lambdabot>     • Data constructor not in scope: FoldR
21:41:51 <lambdabot>     • Perhaps you meant ‘Fold’ (imported from Control.Lens)
21:41:56 <soLucien> :t foldr
21:41:57 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:42:34 <soLucien> how to write it ?
21:43:44 <Koterpillar> soLucien: a = Value, b = [Value]
21:43:52 <Koterpillar> t = []
21:52:27 <imightbestupid12> what are the most essential books and languages to learn to be a strong, well-rounded, beginner/intermediate programmer?
21:52:31 <imightbestupid12> basically i would like to have a set of tools in my head such as principles and ways to solve problems in my head before i tackle a project
21:55:26 <benzrf> imightbestupid12: do a lot of programming
21:55:31 <benzrf> thats the best way to get better at programming
21:55:52 <dmwit> imightbestupid12: I think that goal is a mistake.
21:56:14 <dmwit> imightbestupid12: As they say, inexperience leads to mistakes, and mistakes lead to experience.
21:56:40 <dmwit> imightbestupid12: So make mistakes as quick as you can. Then you will be able to appreciate the tools other people suggest in a new light.
21:56:42 <benzrf> imightbestupid12: ok, i reread what you wrote, and - my bad, it's worth asking about things to look into if you want to ensure that you see important stuff
21:57:03 <dmwit> Definitely don't wait until you think you "know everything" before you do any programming.
21:57:20 <benzrf> regardless, trying to follow a structured path is probably not gonna work too well
21:57:32 <benzrf> do you know any languages yet?
21:57:41 <benzrf> wait, let me rephrase - have you *used* any languages yet?
22:07:03 <saurabhnanda> any students around here? which country are you in and what is a decent monthly stipend for an internship in your country?
22:07:28 <johnw> saurabhnanda: this channel is for discussion of the Haskell language
22:07:48 <zomg> wee oo wee oo internet police is here
22:08:07 <saurabhnanda> johnw: sorry, I forgot to mention that this is research for a Haskell Internship.
22:08:14 <johnw> aha!  important detail :)
22:08:18 <saurabhnanda> johnw: https://www.vacationlabs.com/haskell-internship/ 
22:08:35 <grantwu> saurabhnanda: I'm a student from the US
22:08:53 <saurabhnanda> any students around here? which country are you in and what is a decent monthly stipend for an internship in your country? (need help in figuring out stipend amounts for https://www.vacationlabs.com/haskell-internship/)
22:09:11 <grantwu> saurabhnanda: You might find this helpful https://www.reddit.com/r/cscareerquestions/comments/3pdvyp/summer_2016_interns_what_was_your_offer/
22:09:23 <saurabhnanda> grantwu: ah, thanks!
22:10:10 <athan> Anyone here know if it's possible to check if a port number is already bound?
22:10:20 <athan> I was thinking of just trying it, then catching on an exception
22:10:27 <EvanR> good idea
22:10:35 <athan> ideally something like `isBoundPortNumber :: PortNumber -> IO Bool`
22:10:41 <EvanR> because if you check, then try it, you might get an exception anyway
22:10:47 <EvanR> bool checks are not reliable with IO
22:11:27 <saurabhnanda> grantwu: just confirming -- is this for a PPO (pre-placement offer) or actual summer internships?
22:11:41 <athan> oh woah really EvanR? Why is that..?
22:12:02 <athan> I mean I can have the reasonable faith that there wouldn't be a race condidtion
22:12:02 <Koterpillar> athan: someone might bind it right after your first call
22:12:07 <athan> the Bool would just be clearer :\
22:12:19 <athan> Koterpillar: Yeah but I highly doubt it enough to use it like this
22:12:28 <dmwit> athan: Why would you have reasonable faith that there wouldn't be a race condition?
22:12:30 <athan> doubt that scenario*
22:12:37 <Koterpillar> it is unlikely
22:12:38 <grantwu> saurabhnanda: Uh.. actual summer internships I think?
22:12:47 <Koterpillar> but is it safe to ignore?
22:12:52 <saurabhnanda> grantwu: got confused because people are calling it a 
22:12:58 <saurabhnanda> grantwu: "salary" vs a "stipend"
22:13:01 <athan> dmwit: Because I wouldn't expect the person running the program to have other processes consuming ports like crazy hah
22:13:12 <athan> Koterpillar: In this case, I'd say so
22:13:14 <saurabhnanda> grantwu: also because of the Amazon offer (one of the top comments)
22:13:14 <Axman6> saurabhnanda: can you take this discussion somewhere else? like #haskell-offtopic?
22:13:21 <athan> but I think I understand
22:13:25 <dmwit> athan: That is exactly what happens at system startup. Do you want your program to fail, unreliably, in a hard-to-debug way, when used during system startup?
22:13:26 <saurabhnanda> Axman6: okay, sorry about that.
22:13:27 <athan> might as well catch it :)
22:13:42 <athan> dmwit: Don't you mean, in a fun way? :D
22:13:44 <grantwu> So, I have a datatype that represents machine instructions
22:13:52 <dmwit> athan: right =)
22:14:00 <grantwu> Add, sub, mod, div, sar, etc.
22:14:12 <grantwu> also jmp, ret, etc.
22:14:48 <grantwu> I want to be able to write a function which takes in an instruction and changes any virtual registers to concrete registers/spills
22:14:55 <Koterpillar> with operands?
22:15:02 <grantwu> Yeah, map over the operands
22:15:18 <athan> hmm, do you happen to know if the exceptions thrown by `bind` etc. are codified with types dmwit or Koterpillar?
22:15:21 <Koterpillar> data Instruction register = Mov register register | Inc register deriving (Functor)
22:15:25 <grantwu> The problem is the instructions are heteregenous - many have differing number of arguments, some have rvals and lvals
22:15:30 <grantwu> so I can't just derive functor
22:15:39 <athan> I know I've seen Bind errors before that are thrown, I'd just rather not catch with SomeException :\
22:15:41 <Koterpillar> grantwu: why not?
22:15:42 <grantwu> some instructions don't even take any arguments e.g. Ret
22:15:46 <Koterpillar> that's fine
22:15:53 <EvanR> athan: the only way i know how to find out this information, as important as it is, is by reading the source code
22:16:05 <Koterpillar> if there are different kinds of registers, parametrize on all of them
22:16:11 <athan> hrm, right on
22:16:14 <EvanR> generally any IO anything could throw one of a billion exceptions and it could be from inside of ghc
22:17:02 <Koterpillar> data Instruction register = Inc register | Ret | Prefix segment_register (Instuction register)
22:17:04 <Koterpillar> grantwu: ^
22:17:10 <Koterpillar> can still derive functor
22:18:59 <jvanbure> hmm
22:20:20 <somaReve1> Hi, how can I define an infix operator?
22:20:39 <dmwit> > let 2 + 2 = 5 in 2+2
22:20:42 <lambdabot>  5
22:21:07 <dmwit> You just... define it. =)
22:22:22 <somaReve1> dmwit: I only know how to define a function.
22:22:57 <liste> somaReve1: operators are just functions with symbols as names
22:23:05 <liste> somaReve1: and different syntactic rules
22:23:32 <somaReve1> liste: could you give an example?
22:23:57 <liste> somaReve1: +, -, >>=, <> for example
22:24:05 <liste> :t (+)
22:24:06 <lambdabot> Num a => a -> a -> a
22:24:12 <liste> :t (>>=)
22:24:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:24:40 <liste> > let a $$$$ b = (a, b) in 5 $$$$ 7
22:24:42 <lambdabot>  (5,7)
22:24:50 <EvanR> give a man a function, and he will apply it
22:24:59 <EvanR> teach him how to define a function
22:25:02 <EvanR> and uh
22:25:43 <somaReve1> liste: yeah, I mean how can I define a custom one
22:25:59 <liste> > let (%+) :: Int -> Int; (%+) a b = a * 2 + b in 5 %+ 7
22:26:01 <lambdabot>  error:
22:26:01 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Int -> Int’
22:26:01 <lambdabot>      • The equation(s) for ‘%+’ have two arguments,
22:26:08 <liste> > let (%+) :: Int -> Int -> Int; (%+) a b = a * 2 + b in 5 %+ 7
22:26:10 <lambdabot>  17
22:26:18 <liste> somaReve1: just like any other function
22:27:09 <liste> I just defined $$$$ and %+ operators
22:27:25 <somaReve1> thanks!
22:28:07 <grantwu> Koterpillar: I'm not sure I quite understood what you said there but
22:28:47 <Koterpillar> grantwu: it boiled down to "yes, you can derive Functor"
22:30:12 <somaReve1> what does  "IO ()" mean
22:30:30 <grantwu> Koterpillar: I guess what I'm confused about is...
22:30:33 <grantwu> :t fmap
22:30:35 <Koterpillar> somaReve1: do you know what does () mean?
22:30:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:30:39 <liste> somaReve1: it's an IO action that returns ()
22:30:46 <somaReve1> Why does putStrLn declared as  :: String -> ()   ?
22:30:46 <grantwu> I can't fmap over two types at once...
22:30:56 <EvanR> grantwu: but wait, bifunctors!
22:30:56 <Koterpillar> grantwu: which two types?
22:30:58 <somaReve1> I mean why not 
22:31:21 <grantwu> sigh, I need to try to come up with an example
22:31:21 <somaReve1> Koterpillar: I don't understand the IO word.
22:31:24 <liste> somaReve1: because then it couldn't print anything on the screen
22:31:24 <EvanR> > bimap (+1) chr (66,67)
22:31:26 <lambdabot>  (67,'C')
22:31:33 <liste> somaReve1: IO means Input/Output (basically)
22:31:49 <somaReve1> is "IO () " a specific type?
22:31:50 <Koterpillar> grantwu: or you can shove all of them into a single type
22:31:53 <Koterpillar> somaReve1: yes
22:31:53 <liste> somaReve1: yes
22:32:01 <grantwu> Koterpillar: Yeah, true
22:32:03 <EvanR> somaReve1: IO, I/O, Input/Output
22:32:04 <somaReve1> what about IO (String) ?
22:32:06 <grantwu> Just union up the two types
22:32:23 <Koterpillar> grantwu: data Instruction processor? :)
22:32:27 <liste> somaReve1: it's a different type, it's more commonly written as IO String
22:32:33 <liste> :t readLine
22:32:35 <lambdabot> error:
22:32:35 <lambdabot>     • Variable not in scope: readLine
22:32:35 <lambdabot>     • Perhaps you meant one of these:
22:32:49 <liste> :t getLine
22:32:50 <lambdabot> IO String
22:32:59 <grantwu> Koterpillar: In this case I think what you said works because we have
22:33:00 <liste> that's a value of type IO String
22:33:07 <somaReve1> ok, what is type union?
22:33:32 <EvanR> :t getChar
22:33:34 <lambdabot> IO Char
22:33:37 <Koterpillar> somaReve1: are you following a book or something?
22:33:59 <somaReve1> Koterpillar: no, I was looking around
22:33:59 <grantwu> data Lval = Temp Int | Reg Int | Spill Int; and data Rval = Imm Int32 | Lval Lval
22:34:02 <grantwu> so we can change this into
22:34:45 <jvanbure> data Rval lval = Imm Int32 | Lval lval
22:34:52 <jvanbure> deriving (Functor)
22:34:54 <ReinH> Sum types are sometimes called tagged unions, but not in Haskell.
22:35:11 <jvanbure> and we our instruction type would be parameterized over the lval type
22:35:15 <Koterpillar> grantwu: you can parametrize this over just register too
22:35:35 <Koterpillar> somaReve1: I suggest you pick up a book that explains these concepts in good order
22:36:17 <Koterpillar> grantwu: data Lval reg = Temp Int | Reg reg | Spill Int -- I don't actually get what Spill is
22:36:21 <jvanbure> Koterpillar: we map over it in order to map temporary registers to stack locations and the like, the registers are usually fixed
22:36:31 <jvanbure> Spill represents a stack location
22:36:35 <Koterpillar> ooh
22:37:05 <Koterpillar> then I would say data Instruction lval
22:37:10 <Koterpillar> and thread it through
22:37:10 <kqr> somaReve1, the Char type is a union of all unicode characters. in other words, a value of type Char can be any unicode character
22:37:27 <kqr> somaReve1, the Bool type is a union of True and False. in other words, a value of type Bool can be either True or False
22:37:38 <jvanbure> Koterpillar: thanks!
22:39:06 <somaReve1> :t String Num
22:39:07 <lambdabot> error:
22:39:07 <lambdabot>     • Data constructor not in scope: String :: t0 -> t
22:39:07 <lambdabot>     • Perhaps you meant one of these:
22:39:52 <Koterpillar> somaReve1: Either String Num is a union type
22:39:57 <Koterpillar> oh, sorry
22:40:00 <Koterpillar> somaReve1: Either String Int is a union type
22:40:18 <somaReve1> Koterpillar: How can I union them
22:40:31 <ReinH> That question doesn't make sense
22:40:33 <Koterpillar> somaReve1: do you know how to define your own data type?
22:40:50 <Koterpillar> ReinH: took it as "how can I make my own Either", won't hurt :)
22:40:52 <somaReve1> Koterpillar: ah, I see
22:41:08 <Koterpillar> somaReve1: I still recommend learning the language consistently
22:41:19 <Koterpillar> ?where learn
22:41:19 <lambdabot> https://wiki.haskell.org/Learning_Haskell
22:41:58 <somaReve1> Koterpillar: How can I make my type show as String Int just like IO String does?
22:42:18 <koz_> somaReve1: 'String Int' makes no sense as a type.
22:42:19 <Koterpillar> somaReve1: did you make a type?
22:42:45 <Koterpillar> also, I didn't say `String Int`, I said `Either String Int`
22:44:27 <somaReve1> Koterpillar: I did "data StringInt = String | Int"
22:44:50 <Koterpillar> you want: data MyStringInt = MyString String | MyInt Int
22:45:10 <Koterpillar> @let data MyStringInt = MyString String | MyInt Int
22:45:12 <lambdabot>  Defined.
22:45:20 <Koterpillar> :t MyString
22:45:22 <lambdabot> String -> MyStringInt
22:45:30 <Koterpillar> :t MyString "my  string"
22:45:32 <lambdabot> MyStringInt
22:45:36 <Koterpillar> :t MyInt 23
22:45:38 <lambdabot> MyStringInt
22:45:45 <Koterpillar> this is your union type
22:47:21 <somaReve1> so there are data types and type types?
22:47:44 <Koterpillar> the latter are called "kinds" in haskell
22:47:46 <Koterpillar> :k Int
22:47:47 <lambdabot> *
22:47:50 <ski> (there is no union types in Haskell)
22:47:58 <Koterpillar> :k []
22:47:59 <liste> somaReve1: the `type' keyword defines type aliases
22:48:00 <lambdabot> * -> *
22:48:20 <Koterpillar> ski: well, it looks like one
22:48:47 <somaReve1> :k ()
22:48:48 <ski> (what looks like one ?)
22:48:49 <lambdabot> *
22:49:14 <Koterpillar> ski: Either
22:49:59 <EvanR> thats a sum type
22:49:59 <ski> it's a disjoint union type, aka disjoint sum type, or just sum type, or variant type, or dicriminated union type, or variant record type
22:50:16 <ski> (s/dicr/discr/)
22:50:17 <EvanR> if Union Int Int = Int, then... Either aint that
22:50:33 <glguy> is it a union of those terms?
22:51:10 <ski> (if anything, i'd say `Char' resp. `Bool' are enumerations of all the respective values ("constant" data constructors))
22:51:48 <ski> `Either Int Int' is more like `(Bool,Int)'
22:52:06 <ski> one `Int', plus one tag telling whether we're `Left' or `Right'
22:52:23 <Koterpillar> ski: what about `Either Int String`?
22:52:23 <ski> (i suppose s/plus/times/ would be more correct :)
22:52:49 <ski> Koterpillar : `((b ::) Bool,if b then Int else String)'
22:52:58 <ski> (that's a dependent type, btw)
22:53:18 <Koterpillar> ...
22:53:26 <Koterpillar> and what's a union type in same notation?
22:53:52 <EvanR> union types only make sense if all values are the same type
22:54:03 <EvanR> and "types" are subsets
22:54:56 <ski> `RGB ∪ BlackWhite', possibly
22:55:21 <Koterpillar> ski: do I get to say Int ∪ String then?
22:55:25 <ski> you need subtypes of some form (possibly refinement types), for union types
22:55:27 <ski> Koterpillar : you don't
22:55:35 <Koterpillar> ah, I see
22:56:09 <Koterpillar> then, redefine "union type" as "sum type" in everything I say :)
22:56:41 <EvanR> yes "union" sounds like "untagged union" which... reminds me of C where that is gnarly
22:56:42 <ReinH> The key word is tagged. Tagged union.
22:56:48 <ReinH> Or just say sum type.
22:57:30 <ski> (assume `data Color = Black | Red | Green | Yellow | Blue | Magenta | Cyan | White', and then two refinement types `data BlackWhite :< Color = Black | White',`data RGB :< Color = Red | Green | Blue' .. then you could possibly talk about that union type i mentioned)
22:58:01 <EvanR> and the intersection type
22:58:15 <EvanR> and the complement!
22:58:36 <ski> (or you could possibly go the other way, starting from one type, then extending it in two ways two supertypes, then taking the union of those extensions)
22:59:13 <ski> (i don't recall whether O'Haskell or Timber can actually express such a union (either version))
22:59:43 <EvanR> oh extension to a super type 
22:59:53 <EvanR> how does that work
23:00:37 <ski> well, `data BlackWhite = Black | White', then `data Color :> BlackWhite = Red | Green | Yellow | Blue | Magenta | Cyan', e.g.
23:01:02 <Koterpillar> then I could get what I implied by extending ()
23:01:20 <EvanR> thats like inheritance
23:01:48 <gfixler> :t (:<)
23:01:49 <lambdabot> Cons t1 t1 t t => t -> t1 -> t1
23:02:03 <Kuros-> :t (:))
23:02:05 <lambdabot> error: parse error on input ‘)’
23:02:06 <ski> it's similar to `record Point2D a = Abscissa :: a & Ordinate :: a', `record ColoredPoint2D a :< Point2D = PointColor :: Color'
23:02:10 <gfixler> I need to learn this
23:02:43 <ski> Koterpillar : what did you imply ?
23:02:54 <Koterpillar> ski: just thinking aloud
23:03:09 <EvanR> maybe you want to extend the bottom type
23:03:19 <EvanR> or the top type
23:03:59 * ski . o O ( `data EvenList a :< [a] = [] | a : OddList a; data OddList a :< [a] = a : EvenList [a]' )
23:06:47 * ski idly wonders what would be nice names for the corresponding ways to combine two given quotient types ..
23:17:21 <gfixler> Haskell sucks. I'm glad I get to use C# at work. It just makes sense.
23:25:19 <Axman6> gfixler: lucky, I'm stuck using Haskell at work and it's such a pain trying to do things without exceptions and null
23:26:05 <gfixler> yeah, that sounds terrible
23:26:44 <gfixler> without null, you never know when to cry
23:26:48 <gfixler> you just have to guess
