00:02:08 <ski> yes
00:04:48 <koz_> I'm trying to make use of Data.Monoid.All, but I'm not quite clear how to do it.
00:04:59 <koz_> I have a list of Bools and I wanna use the All monoid to flatten it.
00:05:05 <koz_> (well, fold it, rather)
00:06:05 <ski> > getAll (foldMap All [True,True,True])
00:06:06 <ski> > getAll (foldMap All [True,False,True])
00:06:07 <lambdabot>  True
00:06:08 <lambdabot>  False
00:06:36 <koz_> Ah, that's what I was missing.
00:06:37 <ski> (though if the list is a `map f ...', you could instead of `All . f' there)
00:06:48 <ski> (s/of/use/)
00:06:57 <koz_> Is this where the newtype library can help?
00:07:14 <ski> @index foldMap
00:07:15 <lambdabot> Data.Foldable, Prelude
00:07:39 * hackagebot pipes-zlib 0.4.4.1 - Zlib and GZip compression and decompression for Pipes streams  https://hackage.haskell.org/package/pipes-zlib-0.4.4.1 (RenzoCarbonara)
00:07:39 * hackagebot HUnit 1.4.0.0 - A unit testing framework for Haskell  https://hackage.haskell.org/package/HUnit-1.4.0.0 (SimonHengel)
00:08:02 <ski> not sure whether `newtype' would be helpful for what you're doing
00:08:45 <koz_> ski: No worries, figured I'd ask.
00:08:48 * koz_ is playing with Fix.
00:08:53 <koz_> Catamorphisms ahoy.
00:09:31 <ReinH> > ala All foldMap [True, True, True]
00:09:33 <lambdabot>  True
00:09:48 <ReinH> ala and friends were ported to lens btw
00:10:18 <koz_> ReinH: I'm aware, but I don't wanna drag in half of Hackage *just* yet. :)
00:10:32 <ReinH> Submit.
00:10:35 <koz_> ReinH: Also, what's the etymology of 'alamorphism'?
00:10:40 <ReinH> Resistance is useless.
00:10:43 <koz_> (I assume that's what it's called)
00:11:03 <koz_> We are the Lens. Your theoretical and programmatical distinctiveness will be added to our own.
00:11:09 <ReinH> ala as in à la, I suppose.
00:11:59 <koz_> ReinH, ski: This is what I'm doing: http://lpaste.net/245994
00:12:11 <ReinH> As in "in the style or manner of"
00:13:09 <ReinH> Ah, similar to https://gist.github.com/reinh/d1c1aa863c26d817fa8aeb9bffff6f1d
00:14:10 <koz_> ReinH: Yeah, but I figured this would be a good use for Fix.
00:14:23 <koz_> Now I just have to figure out how to write the monadic anamorphism to generate a random one of those...
00:14:28 <ReinH> Not Free?
00:14:30 <koz_> (to a fixed length, obviously)
00:14:36 <koz_> ReinH: I gotta learn to walk before I can run.
00:16:57 <ski> @where DecoratingStructures
00:16:57 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
00:17:03 <ski> @where IndirectComposite
00:17:03 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
00:17:55 <koz_> Also, what would be an elegant way to write 'True if all elements in this Foldable are equal, False otherwise'?
00:17:55 <ski> why isn't `And' and `Or' simply taking a plain list of operands ?
00:18:05 <koz_> ski: Empty Ors and Ands aren't very meaningful.
00:18:10 <ski> sure they are
00:18:21 <ski> > or []
00:18:23 <lambdabot>  False
00:18:24 <ski> > and []
00:18:27 <lambdabot>  True
00:19:22 <koz_> (assume the elements in the Foldable are all Bool)
00:19:23 <ski> satisfies the generalized associative laws, like `and . map and = and . concat', and similarly for `or'
00:19:55 <koz_> ski: You make a valid point there.
00:19:58 <ski> (also `and . sing = id', where `sing = (: [])')
00:20:51 <koz_> ski: Could I do something similar with Iff?
00:21:53 * ski writes these suggestively as `and (| l0,and (| l1,b |) |) = and (| concat (| l0,l1 |),b |)' resp. `and (| sing (||),b |) = b'
00:23:24 <ski> koz_ : `Iff' (nor `Xor') isn't, imho, "naturally" associative in the same sense
00:24:16 <ski> koz_ : if you wanted to, you could define "flexible" variants of them, though
00:24:23 <koz_> ski: Iff associates fine: https://en.wikipedia.org/wiki/Associativity#Truth_functional_connectives
00:25:03 <ski> yes, if you assume excluded middle
00:25:09 <koz_> ski: I kinda am.
00:25:26 <ski> (which is why i said "naturally")
00:26:45 <koz_> ski: Never mind, figured it out.
00:26:48 * koz_ is dumb.
00:27:11 <ski> (it's not clear to me if `X' is the automorphisms on `Y', why `Y' should have to be iso to the isos between `X' and `Y')
00:28:48 <koz_> ski: I'm trying to understand anaM from data-fix. I wanna use it to generate a random Formula (using MonadRandom as the monad obviously). As I get it, the 'a' is a 'seed' value. What kind of seed value should I even begin with?
00:29:17 <koz_> Or am I using the wrong tool for this?
00:31:24 <ski> possibly you could use `()' for `a'
00:31:39 <ski> or perhaps a size/depth bound
00:31:55 <koz_> ski: A size or depth bound would force the wrong type on the coalgebra.
00:32:08 <koz_> (I have a size parameter, but that's separate)
00:32:24 <koz_> (i.e. given in the wrapper function that calls anaM)
00:32:57 <ski> well, i was thinking if you wanted to decrease it on each step
00:33:57 <koz_> ski: Oh, I get it now.
00:34:04 * ski doesn't see how the type would change, though
00:34:08 <koz_> Sorry, I keep getting confused on this.
00:34:11 <koz_> Never mind - I udnerstand!
00:34:45 <koz_> It's taking me a while to grasp recursion schemes, at least in actual use.
00:35:01 <merijn> koz_: I still don't grok half of them :p
00:35:25 * ski can't recall looking at `data-fix', before
00:52:22 <cocreature> why do "sum" and "maximum" (for []) use foldl instead of foldl'? it’s kind of annoying to get spaceleaks because of that
00:59:16 <merijn> cocreature: Dumb ass historical choices and hesitancy to chance because "something might rely on that behaviour..."
01:00:10 <cocreature> merijn: hm do you have an example of something that would break or is it just some “unknown thing” that might break?
01:02:15 <dibblego> Data.List.NonEmpty using Foldable1 is better anyway.
01:02:36 <cocreature> Data.List.NonEmpty is not better if my list is not empty
01:02:56 <dibblego> is too
01:03:50 <merijn> cocreature: Mostly speculation about a potential unknown thing
01:04:35 <cocreature> merijn: fair enough
01:07:42 <dibblego> for maximum I mean, fwiw
01:07:57 <zaquest> are differences observable at all? or is it run foldl to trigger oom killer kind of reliance :)
01:08:51 <cocreature> zaquest: it depends in a lot of cases ghc’s strictness analysis will rewrite it to a version that doesn’t leak space. but without optimizations it is observable if you are summing over a large list
01:09:24 <merijn> zaquest: Does "shit performance" count as observable? :)
01:12:12 <zaquest> i mean can it change semantics of a program? like change order of IO or something...
01:13:22 <merijn> zaquest: No
01:13:44 <merijn> zaquest: foldl' vs foldl only impacts performance/memory consumption
01:13:46 <cocreature> but shitty performance is still bad :)
01:13:55 <merijn> Well, assuming absence of unsafeX :p
01:14:57 <ski> > foldl (\_ () -> ()) undefined [()]
01:14:58 <ski> > foldl' (\_ () -> ()) undefined [()]
01:14:59 <lambdabot>  ()
01:15:00 <lambdabot>  *Exception: Prelude.undefined
01:16:03 <merijn> oh, I suppose that too
01:17:23 <zaquest> ski, but in sum/maximum could there be any difference?
01:17:27 <ania123> http://pastebin.com/qbWx7MaM
01:17:33 <ania123> can one tell me why i get this error
01:17:34 <ania123> ?
01:18:02 <ski> zaquest : not sure
01:18:20 <dibblego> ania123: where is pairs defined/
01:18:22 <dibblego> ?
01:18:22 <merijn> I don't think so, unless your Integral has a bottom value for 0
01:19:39 <ania123> dibblego: ah, yes, 
01:19:48 <ania123> add is builtinn function
01:19:54 <ania123> I want to see its decription
01:20:04 <ania123> what it accepts and what it returns
01:20:09 <ski> @type and
01:20:11 <lambdabot> Foldable t => t Bool -> Bool
01:20:15 <ski> simpler :
01:20:21 <ski>   and :: [Bool] -> Bool
01:20:42 <ski> presumably you'll have
01:20:49 <ski>   pairs :: [a] -> [(a,a)]
01:20:58 <ski> but you don't seem to have defined that one yet
01:32:35 * hackagebot cuda 0.7.5.0 - FFI binding to the CUDA interface for programming NVIDIA GPUs  https://hackage.haskell.org/package/cuda-0.7.5.0 (TrevorMcDonell)
01:39:49 <fld> Hi all. I'm currently trying to learn a bit about haskell performance.
01:39:49 <fld> When I do cat <30MBcsvish-file >o on linux, it takes .1 sec,
01:39:49 <fld> when I do wc <30MBcsvish-file it takes .2 sec.
01:39:49 <fld> And when I do main = interact id, it takes .6 sec.
01:39:52 <fld> (I compiled the oneliner with ghc -O t.hs).
01:39:55 <fld> Is interact id a bad way of establishing a baseline on lined-based
01:39:59 <fld> file processing?
01:40:58 <liste> fld: interact is string-based, which is bad for performance
01:40:59 <srhb> fld: Depends what you mean by baseline. Try a few other methods, notably not using String, and see what happens.
01:41:29 <liste> fld: you probably want something using ByteStrings (for binary data) or Text (for text data)
01:41:31 <srhb> I actually don't imagine this particular use of String to be _super_ bad
01:42:44 <liste> fld: there's https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-IO.html#v:interact and https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Char8.html#v:interact
01:43:57 <fld> I see. As a first exercise I want to implement something along the lines of wc. The files I'm dealing with are 7-bit clean ASCII.
01:46:08 <liste> fld: then bytestring has a bit better performance but text is a safer option that works for non-ASCII too
01:47:38 <merijn> liste: *hiss*
01:47:52 <merijn> Data.ByteString.Char8 is absolutely haram >.<
01:48:12 <liste> merijn: is there non-Char8 version of interact?
01:48:31 <liste> I didn't find one, but I think there should be
01:49:19 <fld> Alright. Thank youall for the input. I'm catching up on following the pointers.
01:49:20 <merijn> liste: eh, Data.ByteString.interact? :p
01:50:00 <fld> :-)
01:50:22 <liste> merijn: yeah, that one (: linked the Char8 one by accident (damn you hayoo!)
01:51:09 <liste> https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html#v:interact -- fld use this one instead of the Char8 one if you end up using ByteStrings
01:51:41 <koz_> Damn power outages...
01:52:48 <Myrl-saki> I'm starting to think that maybe it's not a good idea to use FRP for game logic.
01:53:05 <merijn> Myrl-saki: Why not?
01:53:16 <fld> liste: Okay.
01:53:21 <Myrl-saki> Actually, not game logic.
01:53:25 <Myrl-saki> More like physics.
01:53:44 <Myrl-saki> Or any data that is heavily recursively dependent, really.
01:53:49 <Myrl-saki> Such as... well. . physics.
02:00:45 <koz_> What's the function I wanna use to get the base-2 log of something?
02:01:09 <ski> > logBase 2 1024
02:01:11 <lambdabot>  10.0
02:01:20 <koz_> ski: Thanks!
02:02:38 <Myrl-saki> > log2
02:02:40 <lambdabot>  error:
02:02:40 <lambdabot>      • Variable not in scope: log2
02:02:40 <lambdabot>      • Perhaps you meant ‘log’ (imported from Numeric)
02:02:47 <Myrl-saki> til. there's no log2.
02:03:08 <biglama> hi guys, can you explain why I cannot do : (+) <$> Just 2 <*> Just 3 <*> Just 4  ?
02:03:22 <merijn> biglama: Because + only takes two argmuents?
02:03:50 <biglama> ok, so how can I sum everything then ?
02:04:04 <Myrl-saki> biglama: fold.
02:04:43 <Myrl-saki> Hmmm
02:04:50 <jle`> sequence and sum?
02:04:51 <Myrl-saki> What was that function again
02:04:59 <jle`> > sequence [Just 2, Just 3, Just 4]
02:05:01 <lambdabot>  Just [2,3,4]
02:05:05 <koz_> :t round
02:05:06 <jle`> > sum <$> sequence [Just 2, Just 3, Just 4]
02:05:07 <lambdabot> (RealFrac a, Integral b) => a -> b
02:05:08 <lambdabot>  Just 9
02:05:29 <jle`> sequence is basically (\x y z -> [x,y,z]) <$> fx <*> fy <*> fz
02:05:29 <merijn> I wonder...
02:05:30 <koz_> :t logBase
02:05:32 <lambdabot> Floating a => a -> a -> a
02:05:39 <jle`> ^ biglama 
02:05:47 <merijn> > Just 2 + Just 4 -- is "Num a => Maybe a" a num instance?
02:05:49 <lambdabot>  error:
02:05:50 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M673558449193...
02:05:50 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
02:05:50 <biglama> thanks !
02:05:54 <Myrl-saki> merijn: No.
02:05:57 <merijn> apparently not :)
02:06:00 <jle`> so sequence is what gets you multi-arity <$>/<*> i guess
02:06:24 <Myrl-saki> There was also this automatic Monoidal fold function.
02:06:57 <Myrl-saki> ala.
02:06:59 <Myrl-saki> :t ala
02:07:01 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
02:07:05 <jle`> this isn't really using it as a monoid though
02:07:16 <biglama> my initial problem was to concatenate strings, can you help me a little more ?
02:07:21 <biglama> something like (++) <$> Just "aa" <*> Just "bb" <*> Just "cc"
02:07:34 <ski> `concat'
02:07:41 <Myrl-saki> > ala Sum foldMap [1..10]
02:07:44 <lambdabot>  55
02:08:39 <Myrl-saki> Err
02:08:42 <Myrl-saki> Wait
02:08:43 <Myrl-saki> jle`: Use traverse lol.
02:08:47 <tsahyt> why does the takeV function not typecheck? http://lpaste.net/5883230645689253888
02:08:49 <Myrl-saki> :t traverse
02:08:49 <koz_> Argh, I wish there was an integer log base 2 function (floor or ceiling, I don't care).
02:08:51 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:08:59 <Myrl-saki> jle`: map f . sequence == traverse f
02:09:12 <tsahyt> it works without the constraint, but then I end up with runtime errors when I try to take too much of the list
02:09:19 <ski> koz_ : i was looking for one in `Data.Bits', but didn't see it ..
02:09:46 <koz_> ski: I guess I could roll my own easily enough.
02:09:59 <Myrl-saki> :t map . sequence
02:10:00 <lambdabot> error:
02:10:00 <lambdabot>     Ambiguous occurrence ‘map’
02:10:00 <lambdabot>     It could refer to either ‘Data.List.map’,
02:10:02 <koz_> Also, ski: I've got how I'm gonna rock anaM, but I'm having a bit of trouble.
02:10:10 <Myrl-saki> :t \f -> map f . sequence
02:10:11 <lambdabot> error:
02:10:12 <lambdabot>     Ambiguous occurrence ‘map’
02:10:12 <lambdabot>     It could refer to either ‘Data.List.map’,
02:10:14 <Myrl-saki> Errr
02:10:20 <Myrl-saki> It could refer to either Data.List.map or what???
02:10:22 <koz_> Namely, I have my Operator a type, with like, a bunch of constructors.
02:10:27 <Myrl-saki> Functor?
02:10:30 <koz_> And I need to pick one randomly.
02:10:38 <Myrl-saki> :t \f -> fmap f . sequence
02:10:40 <lambdabot> (Traversable t, Monad f) => (t a -> b) -> t (f a) -> f b
02:10:40 <koz_> Is there a better way than 'pick random integer, then casematch?'
02:10:45 <ski> @type (fmap .) . sequence
02:10:47 <lambdabot> (Traversable ((->) a1), Functor f) => (a1 -> a -> b) -> a -> f a1 -> f b
02:10:52 <Myrl-saki> Hmmm
02:10:55 <ski> oh, right
02:10:56 <Myrl-saki> Apparently, I was wrong.
02:11:04 <ski> @type (. sequence) . fmap
02:11:07 <lambdabot> (Traversable t, Monad f) => (t a -> b) -> t (f a) -> f b
02:11:19 <Myrl-saki> I think foldMap would be better, actually.
02:11:44 <Myrl-saki> > ala (fmap Sum) foldMap [Just 1, Just 2, Just 3]
02:11:48 <lambdabot>  error:
02:11:48 <lambdabot>      • Couldn't match expected type ‘Maybe a0’
02:11:48 <lambdabot>                    with actual type ‘Unwrapped (Maybe (Sum a0))’
02:11:54 <Myrl-saki> Ehhhh
02:12:17 <Myrl-saki> that makes me sad. :(
02:12:35 <Myrl-saki> :t foldMap
02:12:37 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
02:12:45 <merijn> Myrl-saki: Why not just
02:12:52 <merijn> :t foldMap Sum . catMaybes
02:12:54 <lambdabot> Num a => [Maybe a] -> Sum a
02:12:59 <merijn> :t getSum . foldMap Sum . catMaybes
02:13:01 <lambdabot> Num c => [Maybe c] -> c
02:13:12 <Myrl-saki> > ala Sum (foldMap . fmap)  [Just 1, Just 2, Just 3]
02:13:15 <lambdabot>  error:
02:13:15 <lambdabot>      • Couldn't match type ‘Sum b’ with ‘Maybe Integer’
02:13:15 <lambdabot>        Expected type: [Maybe Integer] -> Sum b
02:13:15 <Myrl-saki> plss
02:13:24 <Myrl-saki> i giff up
02:13:34 <Myrl-saki> I think it's because fmap has no dual.
02:13:39 <koz_> Myrl-saki: What are you trying to do?
02:13:54 <Myrl-saki> koz_: Not me.
02:14:35 <biglama> ski: thank you
02:14:44 <ania123> http://pastebin.com/iY7Cj6PY
02:15:03 <Myrl-saki> > fmap getSum . foldMap (fmap Sum) [Just 1, Just 2, Just 3]
02:15:05 <lambdabot>  error:
02:15:05 <lambdabot>      • Couldn't match expected type ‘a -> f (Sum b)’
02:15:05 <lambdabot>                    with actual type ‘Maybe (Sum Integer)’
02:15:13 <ania123> can one tell me why i get that error
02:15:14 <ania123> ?
02:15:42 <merijn> > text "\8217"
02:15:44 <lambdabot>  ’
02:15:48 <Rembane> ania123: You use a ´ instead of a '
02:15:52 <merijn> ania123: You're using the wrong quote
02:16:01 <ania123> ah
02:16:02 <ania123> thx
02:16:07 <Myrl-saki> > fmap getSum . foldMap (fmap Sum) $ [Just 1, Just 2, Just 3]
02:16:09 <lambdabot>  Just 6
02:16:10 <ski> ania123 : `Eq a ->' should be `Eq a =>'
02:16:12 <Myrl-saki> YAY
02:16:14 <Myrl-saki> I GOT IT!
02:16:22 <merijn> Rembane: No, he's using an even odder quote
02:16:28 <Myrl-saki> I wonder if there's an ala way to do it.
02:16:30 <lpaste> koz_ pasted “Can I write this better?” at http://lpaste.net/246120
02:16:49 <Myrl-saki> :t ala
02:16:51 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
02:16:55 <Rembane> merijn: Oh. Wow.
02:17:28 <koz_> Myrl-saki: Can't you just sequenceA the Justs to the front of the list?
02:17:30 <merijn> Rembane: Seems like a fancy word curly quote or something
02:17:37 <Myrl-saki> :t sequenceA
02:17:38 <merijn> I don't even know how you'd type that
02:17:39 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
02:17:39 <koz_> Or do you worry about potential Nothings wrecking your fun.
02:17:47 <cocreature> it’s the unicode apostroph ’
02:17:51 <Myrl-saki> koz_: I mean, sure. But that's boring.
02:17:54 <merijn> koz_: Or you just do catMaybes :p
02:18:03 <koz_> merijn: That works too.
02:18:10 <merijn> koz_: Which, admittedly does something different
02:18:27 <koz_> merijn: Could you (or indeed, anyone else) advise me on this? http://lpaste.net/246120
02:18:41 <merijn> koz_: I don't have particularly great advice for that :)
02:19:00 <koz_> merijn: I'm wondering if there really is no other way than 'generate random number and casematch'.
02:19:27 <merijn> koz_: There's surely other ways, I'm just not sure those are easier/better :p
02:19:27 <Myrl-saki> Errr
02:19:48 <Rembane> merijn: They are a nuisance!
02:20:03 <ania123> http://pastebin.com/STNMhT84
02:20:13 <ania123> i still get problems :)
02:20:13 <cocreature> koz_: it also depends on what kind of distribution you are looking for.
02:20:20 <koz_> cocreature: Flat.
02:20:26 <koz_> (i.e. each of them is equally probable)
02:20:28 <Myrl-saki> Oh. A ring.
02:20:30 <Myrl-saki> I remember now.
02:20:32 <ski> koz_ : i suppose one could build something like `oneof' in QuickCheck
02:20:36 <cocreature> ania123: you are calling position instead of positions
02:20:53 <koz_> ski: Against constructors? I guess they're functions too.
02:21:02 <cocreature> koz_: equal distribution between the toplevel data constructors or equal distribution between all inhabitants of your type?
02:21:16 <cocreature> in the latter case it gets quite tricky
02:21:39 <ski> koz_ ?
02:22:03 <Myrl-saki> well...
02:22:58 <Myrl-saki> Shouldn't `Algebra.Additive.C a => Algebra.Additive.c (Maybe a)`?
02:23:15 <Myrl-saki> oh wait.
02:23:17 <Myrl-saki> There are two zeroes.
02:23:25 <Myrl-saki> Hmmm
02:23:36 <koz_> cocreature: Equal chance of choosing any of the data constructors for Operator.
02:23:45 <koz_> ski: Never mind - thinking out loud.
02:23:46 * ski . o O ( Henning )
02:24:26 <ski> koz_ : see if you can define `oneof :: MonadRandom m => [m a] -> m a', i suppose
02:26:07 <Myrl-saki> :t traverse head
02:26:08 <lambdabot> error:
02:26:08 <lambdabot>     Ambiguous occurrence ‘head’
02:26:08 <lambdabot>     It could refer to either ‘Data.List.head’,
02:26:11 <Myrl-saki> FFS
02:26:37 <Myrl-saki> :t traverse Data.List.head
02:26:41 <lambdabot> (Traversable t, Applicative f) => t [f b] -> f (t b)
02:26:58 <Myrl-saki> Okay. That doesn't seem to be it.
02:26:59 <ski> @type traverse head
02:27:00 <lambdabot> (Traversable t, Applicative f) => t [f b] -> f (t b)
02:27:17 <Myrl-saki> > fmap head . sequence
02:27:19 <lambdabot>  error:
02:27:19 <lambdabot>      • No instance for (Typeable f0)
02:27:19 <lambdabot>          arising from a use of ‘show_M56932240260985520031582’
02:27:27 <Myrl-saki> :t fmap head . sequence
02:27:28 <lambdabot> Monad f => [f b] -> f b
02:27:33 <ski> (someone `Data.ByteString.Char8' unqualified)
02:30:30 <Myrl-saki> :t \xs -> getRandomR (0, length xs - 1) >>= (xs !!)
02:30:32 <lambdabot> error:
02:30:32 <lambdabot>     Variable not in scope: getRandomR :: (Integer, Int) -> m Int
02:30:49 <Myrl-saki> meh
02:32:18 <Myrl-saki> Okay. This is a really stupid question.
02:32:47 <Myrl-saki> But why is there no `Wrapped a => Wrapped (Wrapped a)` instance?
02:33:11 <Myrl-saki> Errr
02:33:14 <Myrl-saki> or something.
02:33:22 <Myrl-saki> I don't know how to say it.
02:33:31 <Myrl-saki> Basically, 2 levels of wrapping.
02:36:07 <merijn> Myrl-saki: ...
02:36:30 <merijn> Myrl-saki: How would that possibly make sense? Why would you wrap something that's already an instance?
02:36:49 <Myrl-saki> merijn: Yeah.. I think I'm just stupid. xD
02:39:54 <koz_> merijn: Yo dawg, we herd u liek newtypes, so we wrapped your wrapped type, so you can ala while you ala?
02:40:01 <Myrl-saki> xD
02:40:14 <koz_> Pimp My Code. :)
02:40:15 <merijn> koz_: Except the right hand side there uses a class instead of a datatype? :p
02:40:20 <Myrl-saki> Hmmm
02:41:17 <Myrl-saki> Well.
02:42:51 <Myrl-saki> merijn: I'll try to define a string/distance constraint, FRP style.
02:43:18 <Myrl-saki> Meh. I was pretty stupid to immediately say that it's hard.
02:44:20 <Myrl-saki> I already got the framework of my code. It'd be a shame if I don't continue working on it.
02:50:47 <Myrl-saki> welp. here we go again.
02:54:15 <Myrl-saki> I think the first problem is that I can't design the wire, at all.
02:54:42 <Myrl-saki> *I* literally can't. Someone else probably can. :(
02:59:44 <Myrl-saki> Oh wait. I think I just figured it out.
03:21:08 <helplessSurvivor> isnt there a function in the haskell library where you can return (head x, tail x) of a list? or am I blind
03:21:42 <ski> @type uncons
03:21:43 <lambdabot> [a] -> Maybe (a, [a])
03:22:03 <ongy> let (x:xs) = ys?
03:22:14 <ski> (brackets redundant)
03:22:57 <Myrl-saki> :t split
03:22:59 <lambdabot> Splitter a -> [a] -> [[a]]
03:23:07 <Myrl-saki> :t splitAt
03:23:08 <lambdabot> Int -> [a] -> ([a], [a])
03:23:15 <Myrl-saki> > splitAt 1 []
03:23:17 <lambdabot>  ([],[])
03:23:32 <Myrl-saki> Mmm. I guess that's technically not head/tail.
03:25:35 <jle`> > uncons [1..10]
03:25:37 <lambdabot>  Just (1,[2,3,4,5,6,7,8,9,10])
03:25:58 <Myrl-saki> Why Maybe? Why not just return `(undefined, [])` /s
03:26:07 <ski> > uncons []
03:26:10 <lambdabot>  Nothing
03:26:25 <ski> > unfoldr uncons [0,1,2]
03:26:30 <lambdabot>  [0,1,2]
03:26:44 <ski> `unfoldr uncons' is supposed to be `id'
03:27:14 <ski> (also `maybe [] (:)' is inverse to `uncons')
03:27:47 <ski> (er, `uncurry (:)' rather than `(:)')
03:32:38 * hackagebot stack-prism 0.1.6 - Stack prisms  https://hackage.haskell.org/package/stack-prism-0.1.6 (MartijnVanSteenbergen)
03:32:40 * hackagebot megaparsec 5.1.2 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-5.1.2 (mrkkrp)
03:38:39 <iphy> hi, I'm trying to build a shared library using haskell
03:38:52 <iphy> and I'm failing for one of many reasons, depending on what I do
03:39:10 <iphy> right now I'm getting undefined reference to hs_init/hs_exit when linking the library itself
03:46:45 <iphy> I can also get a bunch of undefined references to various haskell functions: https://travis-ci.org/TokTok/c-toxcore-hs/builds/165776557#L642
03:50:10 <ongy> iphy: looking at the warnings, your linker can't find the haskell libraries you depend on (line 638 of the log). Which would cause undefined references
03:50:53 <iphy> I found another example that uses cabal, maybe that works better: https://github.com/rTreutlein/OpenCogHaskellLibTemplate
03:50:57 <iphy> I'm trying that now
03:54:02 <yulax> i wrote a program to work out fibonacci numbers recursively
03:54:16 <yulax> fib n = fib (n-1) + fib (n-2)
03:55:17 <ski> .. and also base cases, i hope
03:55:25 <yulax> but it is painfully slow. i had written one in C with libgmp which was extremely fast - it took 22 hours to calculate and write a 22G file for the millionth fibonacci number.
03:55:44 <yulax> i would like some advice on making it more efficient
03:56:02 <yulax> whilst also being accurate
03:56:10 <merijn> yulax: THat's because that recursive definition of fibonacci is terribly inefficient
03:56:14 <ski> the time to compute your `fib n' is `O(fib n)' (exponential), iirc
03:56:18 <yulax> yes
03:56:24 <Maxdamantus> yulax: well, `fib (n - 1)` already involves invoking `fib (n - 2)`
03:56:31 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
03:56:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
03:56:37 <ski> was the one you wrote in C also double recursive ?
03:56:47 <Maxdamantus> so you're invoking `fib (n - 2)` twice.
03:57:08 * ski . o O ( dynamic programming ftw )
03:57:57 <yulax> Maxdamantus: the code doesnt work without the fib (n-2)
03:58:00 <yulax> it cant
03:58:16 <Maxdamantus> I don't think what merijn wrote would sensibly be considered dynamic programming.
03:58:29 <merijn> No, mine is more the iterative version
03:58:34 <yulax> that is the definition of fibonacci...
03:58:35 <ski> make sure to remember and reuse `fib' called on smaller numbers, as much as possible
03:58:50 <merijn> In ghci it computes the 100,000th fibonacci numbers in less than a second
03:58:52 <Maxdamantus> Yeah, and that's the most reasonable way to calculate it, not DP.
03:59:06 <merijn> The millionth is still running in ghci
03:59:08 <lyxia> how is that not DP
03:59:18 <merijn> I'm sure if I compile it, it'll be faster
03:59:26 <ski> keeping track of the last pair is (bottom-up) DP
03:59:32 <merijn> ooh
03:59:40 <merijn> after 30s ghci dies with bus error
04:00:03 <koz_> I am *very* impressed with recursion schemes.
04:00:08 <koz_> And will use them more often from now on.
04:00:14 <Maxdamantus> It's not DP because it doesn't lazily refer to arbitrary previous results.
04:00:23 <ski> the stream one is just caching the whole history, rather than just the last two values
04:00:37 <Maxdamantus> but it's not doing fibs !! n - 1
04:00:47 <Maxdamantus> fibs !! (n - 1), rather
04:00:59 <merijn> I think my version isn't allowing the fibs to be GCed? Not sure
04:01:10 <merijn> I seems to run out of memory with 1,000,000
04:01:11 <Maxdamantus> It could theoretically be GCed.
04:01:18 <Maxdamantus> unless you're keeping a reference to `fibs`.
04:01:21 <merijn> oh, nope
04:01:25 <merijn> It finished when compiled
04:01:26 <yulax> merijn: how can i define a limit in this example?
04:01:43 <merijn> yulax: What do you mean?
04:01:45 <yulax> it appears to just go on forever
04:02:11 <merijn> yulax: Sure, it's a list of all fibonacci numbers, so if you want the 1,000,000th fibonacci, you take the 1,000,000th number of the list
04:02:24 <yulax> ah yes
04:02:28 <yulax> now i see
04:02:31 <merijn> Takes about 36 seconds to compute 1,000,000th fibonacci when compiled with -O2 on my laptop
04:03:00 <koz_> merijn: Dat be one *huge* number.
04:03:04 <merijn> koz_: It is
04:04:04 <merijn> I actually crashed vim trying to paste it xD
04:04:35 <Maxdamantus> 36 seconds sounds like it's not being GCed.
04:04:42 <merijn> Maxdamantus: No, I think it is
04:04:53 <merijn> It's just *REEEEEEEEAAAAAAAALLLLLLYYYYY* huge
04:05:10 <merijn> Maxdamantus: Like I said, huge enough that copy+pasting it into vim killed vim
04:05:13 <zoran119> is there a function to turn [1,2,3] and [4,5,6] into [[1,2,3],[4,5,6]]?
04:05:13 <Maxdamantus> It can't be *THAT* huge that it would take 36 seconds to do a million additions.
04:05:23 <Maxdamantus> vim is pretty easy to crash ime
04:05:24 <Insanity_> If you just want the 1.000.000 fib number I wouldn't do it that way
04:05:49 <lyxia> zoran119: \x y -> [x, y]
04:05:52 <Maxdamantus> If you try loading some minified JavaScript from some webpage in it'll likely become unusable.
04:06:39 <ski> @pointless \x y -> x : y : []
04:06:39 <lambdabot> (. return) . (:)
04:07:37 <lyxia> (<|>) `on` return
04:08:22 <merijn> yulax: http://lpaste.net/246268
04:08:39 <merijn> It doesn't seem to linewrap the result, so it's hard to see how large it actually is
04:09:06 <Maxdamantus> Hm, okay, I guess it does take that long even when GCed.
04:09:16 <Maxdamantus> 36 seconds for me, on my desktop.
04:09:42 <merijn> Anyway, certainly doesn't require 22 hours and 22GB ram :)
04:10:09 <yulax> thanks merijn, i'm only a beginner but i'll make good use of this
04:10:15 <yulax> for learn
04:10:49 <yulax> well part of the reason it took so long may have been because it wrote all the numbers to a file
04:11:02 <Maxdamantus> anyway, it's only 208988 digits long.
04:11:02 <yulax> a very large file!
04:11:48 <merijn> yulax: That would certainly slow it down even more :p
04:11:59 <cocreature> Maxdamantus: “only” :)
04:12:28 <Maxdamantus> Well, people have computed trillions of digits of pi, right?
04:12:37 <Maxdamantus> or is it quadrillions?
04:12:54 <Maxdamantus> actually, I imagine it's probably quintillions at least.
04:13:07 <Maxdamantus> Oh, meh, only 13 trillion.
04:13:34 <yulax> ah but keep in mind that the millionth is not a mere 10 times 100 000!
04:13:45 <merijn> yulax: If you try the same recursive definition in C it'd crash before it got to like a few 100, I think :)
04:14:14 <merijn> yulax: The zipWith one is basically the haskell version of: http://lpaste.net/246278
04:14:24 <merijn> Well, except that size_t would overflow pretty fast...
04:14:32 <Xnuk> Is there any Stylus(stylus-lang.com) parser for Haskell?
04:14:34 <merijn> but you get the idea :)
04:19:18 <iphy> ongy: https://travis-ci.org/TokTok/c-toxcore-hs#L283 it still won't link
04:20:30 <iphy> with cabal it's even worse
04:20:42 <iphy> it doesn't link HSrts
04:23:30 <yulax> merijn: my computer just crashed trying to work out fib 1000000
04:23:52 <ongy> iphy: you still have the same problem. It can't find all the libraries your haskell file depends on. The line you highlighted tells you that the linker can't find libHSdeepseq-1.3.0.2-ghc7.8.4.so, which is the object file for deepseq. You will have to add additional -L arguments to the cc call. if you have installed the libraries with cabal they should be somewhere in ~/.cabal/lib/
04:24:11 <merijn> tbh
04:24:27 <merijn> It's probably simpler to have GHC link your C code than have cc link your haskell code
04:25:12 <iphy> the test program is not my final goal
04:25:25 <iphy> my final goal is to have a haskell .so I can load from JNI
04:25:55 <iphy> so I can make the test program more realistic by making it use dlopen
04:25:57 <MarcelineVQ> iterestingly fix ((0) . scanl (+) 1) is consistently faster for me with and without O2, though not by more than a couple seconds for fib !! 1000000
04:25:57 <phaskell-1> O2: GHC - Driver - https://phabricator.haskell.org/owners/package/2/
04:25:57 <phaskell-2> O2: GHC - Driver - https://phabricator.haskell.org/owners/package/2/
04:26:16 <iphy> but I don't think it'll help if I can't even link with cc
04:26:53 <MarcelineVQ> (0 :) .
04:27:10 <merijn> iphy: Well, you will have to locate all the GHC libraries
04:27:33 <iphy> can ghc help me do that?
04:27:58 <merijn> Yes, by having ghc call the linker instead of cc...
04:28:16 <iphy> ok, so how do I get a shared library that I can load with dlopen?
04:28:36 <merijn> iphy: What's insufficient about the shared library that ghc produces?
04:28:46 <iphy> merijn: I'll try
04:29:00 <iphy> I figured that if I can't link with ld, I can't dlopen
04:29:15 <merijn> iphy: You do realise GHC uses ld to link?
04:29:36 <iphy> yes
04:29:51 <iphy> but it links a shared library, not a program
04:32:39 * hackagebot mollie-api-haskell 0.1.0.2 - Mollie API client for Haskell http://www.mollie.com  https://hackage.haskell.org/package/mollie-api-haskell-0.1.0.2 (matsrietdijk)
04:32:41 * hackagebot JsonGrammar 1.0.5 - Combinators for bidirectional JSON parsing  https://hackage.haskell.org/package/JsonGrammar-1.0.5 (MartijnVanSteenbergen)
04:35:08 <iphy> merijn: interesting, it works with dlopen
04:35:15 <iphy> but it doesn't call hs_init
04:35:27 <iphy> maybe it removes the symbols
04:36:54 <merijn> Why would it call hs_init? The user has to do that
04:58:15 <iphy> merijn: is there no way to make a C shared library written in haskell?
04:59:41 <iphy> normally when you link to a shared library, you don't need to specify all its dependent libraries as well
04:59:59 <merijn> iphy: You just made one and succesfully dlopen'ed it?
05:00:03 <merijn> iphy: Eh, yes you do
05:00:10 <iphy> yes, dlopen works
05:00:55 <merijn> Then I don't understand what makes you think it's not possible?
05:04:17 <goodChar> How do I remove all occurrences of a given element in a list?
05:05:09 <merijn> goodChar: filter (==x) myList ?
05:05:18 <ocramz> hullo
05:06:02 <iphy> merijn: hm, you're right
05:06:07 <iphy> on osx, you don't need to do that
05:06:20 <iphy> https://travis-ci.org/TokTok/c-toxcore-hs#L211
05:07:12 <lordcirth> merijn, wouldn't it be !=, not == ?
05:07:34 <ocramz> (/=)
05:07:42 <merijn> lordcirth: I always forget which :)
05:07:52 <lordcirth> right, that one.  Point is filter returns things that match
05:07:59 <merijn> iphy: That's because the OSX linker is much more helpful to you than most others
05:08:47 <lordcirth> Whoa someone's working on a Haskell Tox? That's great.  I wish I was skilled enough to help.
05:09:11 <iphy> lordcirth: #toktok :)
05:10:25 <Insanity_> iphy: started on it today?
05:10:48 <iphy> I started on the C API today
05:11:34 <Insanity_> You should consider adding readme files to your projects :P "pokemon go api"
05:12:22 <iphy> yes
05:12:29 <Insanity_> Looks nice though. I didn't know about tox until about 30 minutes ago on hackernews
05:13:09 <Insanity_> it's trending now there so if you'd want to get more contributors, perhaps now is the time to leave a comment
05:13:18 <Insanity_> https://news.ycombinator.com/item?id=12657891
05:30:25 <iphy> Insanity_: good idea
05:57:20 <iphy> lordcirth: you can help :)
06:10:19 <Insanity_>  I'd love to help as well, but pretty much in the same boat as lordcirth here
06:10:26 <Insanity_> Still learning Haskell :-)
06:19:52 <Guillaum> Hi there. I'm playing with the Earley package for parsing. My grammar is ambiguous and left recursive, so naturally I'm getting many different results for the same input. I'm looking for a way of sorting theses results based on the order of the alternative rule inside the grammar.
06:26:00 <c_wraith> lordcirth: /=
06:26:11 <c_wraith> bah, I was scrolled and didn't realize
06:26:47 <c_wraith> Guillaum: not sure, but the author is ollef, who is in here.  Maybe he's paying attention to mentions
06:29:05 <Guillaum> c_wraith: thank you. Actually I just find an enhancement request on github detailling this issue, apparently it is not possible yet.
06:32:50 <Guillaum> A side question can be, do you know any haskell parsing tool which handles left recursion and priority in the altenatives ? As far as I know, we need to modify the grammar in parsec family parser to remove the left recursion (but it handles priority).
06:33:19 <paolino> hello, anyone using pipes can tell if there is a function  :: Monad m => (y ->  m b) -> Pipe y y m b ?
06:35:18 <c_wraith> paolino: did you mean Proxy there?
06:35:48 <paolino> Pipe
06:36:01 <paolino> Proxy () y () y m b
06:36:16 <c_wraith> oh
06:36:26 <paolino> I call it peekM
06:36:54 <paolino> seems like super basic operation, that's why I suspect it's there
06:38:12 <c_wraith> It's a morphism from a Kleisli category to a pipe category.
06:38:42 <c_wraith> Given that it's a Gabriel Gonzales library, it seems like that morphism should be *somewhere*
06:39:49 <paolino> it's easy to implement with await and yield, but I see in the prelude there are helpers,similar like P.chain 
06:41:39 <paolino> c_wraith, I was thinking a method of a class I cannot spot
06:41:59 <c_wraith> It didn't look like it's part of any class defined on Proxy
06:43:38 <ashishnegi> hi.. is there a way to REPL to production haskell box and change one particular function ?
06:44:25 <paolino> btw ,Pipes library is very interesting a sweet point of practical vs theoretical 
06:44:46 <c_wraith> ashishnegi: Not in GHC.  (Or any other haskell compiler I know of.)  GHC produces statically-compiled binaries
06:46:06 <paolino> is Proxy a finite state machine ?
06:47:19 <c_wraith> paolino: It's a state machine, but no part of its definition restricts it to a finite state space
06:47:59 <paolino> ah I thought finite was referring to the number of constructors :-/
06:52:15 <paolino> c_wraith, has await >>= yield a name ?
06:52:41 <c_wraith> Not that I know of.  But something like passthrough would describe it nicely
06:55:29 <paolino> if I just want to count data item flowing do I need that ?
06:56:29 <paolino> run n = await >>= yield >> run (n +1) in run 0
06:57:30 <c_wraith> Well, you'd need something other than that to be able to do something with the count, but...  Yeah, you would need something like that.
06:58:22 <paolino> ok
06:58:27 <paolino> thanks
07:01:35 <ggVGc> has anyone here done any work with Ur?
07:02:38 <c_wraith> like Ur/Web?
07:04:56 <ggVGc> c_wraith: yeah
07:05:09 <ggVGc> it looks interesting, mainly because of the lack of GC
07:05:21 <ggVGc> but seems pretty esoteric so far
07:05:22 <c_wraith> I haven't..  Just wanted to be sure I knew what you were asking about.
07:08:22 <c_wraith> paolino: wait, your first question...  You didn't want a type like Monad m => (x -> m y) -> Pipe x y m a  ?
07:09:05 <c_wraith> or Monad m => (x -> m y) -> Pipe x y m () ?
07:09:29 <paolino> no, peekM is computung a monadic value from the stream downstream value
07:09:40 <c_wraith> Ah, that explains the name
07:10:14 <paolino> doesn't touch the stream
07:10:28 <umib0zu> is there a haskell online editor and runner for code examples?
07:11:18 <c_wraith> umib0zu: there's http://tryhaskell.org/  and something else..
07:11:31 <paolino> something with reflex
07:13:59 <Cale> paolino: you're probably thinking of http://hsnippet.com/
07:14:15 <paolino> hi Cale, that one
07:15:30 <c_wraith> Cale: that one of yours?
07:20:07 <ollef> Guillaum: Hey! There's some discussion about ordering the results in Earley's issue tracker. The gist of it is that I haven't found a way to order the results without making parsing quite a bit slower. So it's a tradeoff.
07:22:26 <iphy> Insanity_: you're welcome to join #toktok as well
07:22:53 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
07:22:53 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
07:22:53 --- names: list (clog uwap mads-_ int-e bartavel` suppi sbrg ThugNasty noplamodo_ luigy_ telmich_ `0660_ luite kmicu djapo Iskarlar darkbolt e14_ wraithm worch V3 fengshaun Gurkenglas connrs king_jah ilyanok eivarv doomlord manuel_ mmhat madbub HanlonsRazor takuan ashishnegi albertus1 umib0zu Intensity nomicflux exferenceBot e14 dsh dramforever hariel fizruk dextertzu sdothum Vbitz jgornick pmade sleezd sighingnow mszczygiel lieven zomg jrp6 hanDerPeder Ornedan mpw jomg)
07:22:53 --- names: list (Rarrikins Princess17b29a Voldenet fcpga_te paolino sunakshi_ mizu_no_oto_work rgrinberg Kruppe mmachenry1 Noldorin shookees mac10688 Insanity_ soLucien Guillaum newsham cloudhead contiver thunderrd zyhn mada derdon Kuros` copy` saurabhnanda smwangi kishar AntiSpamMeta eliasr dilinger mokus xaimus ziocroc vlatkoB_ curious_corn mvr_ drdo malcon cchalmers Yuras kurnevsky2 cereal_killer_ sigma9142 fractalsea slackircbot ype ocramz LordDeath bhiliyam Big_G whoops)
07:22:53 --- names: list (KireinaHoro[m] dhil bamboo thomas_24 deank andy____ irrequietus simukis_ cyborg-one nwf JeanCarloMachado amyers danthemyth Profpatsch[m] alexelcu Sose Lowl3v3l descender knyppeldynan herzmeister UnlikeSuika ali_bush kaste petermw oisdk_ romich danza cYmen phaji joncol lonokhov brian[m] nilg` OnkelTem sdemos alx741_ Guest57190 locallycompact lspitzner evanpro SeriousBug[m] helloworld1[m] M-Shrike bb010g[m] davidar srenatus[m] M-wamaral SShrike prose[m])
07:22:53 --- names: list (M-david M-Magnap jamon[m] radix1 tagada[m] M-schmittlauch M-Illandan M-mistake pkmx[m] todd_killings[m] rdesfo[m] M-krsiehl nilg M-Quora nour latk meras marr raichoo koz_ ertesx nepiktaz Tesseraction Vektorweg11 JagaJaga tabaqui ggole_ ludat carado lsk fld juhp augur PatrickRobotham merijn eizua phanimahesh albertid johnw_ baldrick1 caumeslasal hackagebot fbergmann zipper guiben Itkovian ericsagnes infinity0 mjo geekosaur valkyr2e zaquest norotartagen)
07:22:53 --- names: list (harfangk ThomasLocke_ kamog zero_byte hamishmack babu` igniting BartAdv daey martyix lispy avalokite falafel justanotheruser gfixler vili_ jchia shyn osa1_ sooheon hexagoxel pavonia jokleinn hucksy jzl dsantiago sebastian-w eell acertain leothrix _kit_ phileas Rotaerk buttbutter JoshS zugz Destol watersoul joachifm Zekka markus1189 nshepperd nakal__ utdemir theDon beaky verement fkurkowski dcoutts_ latro`a arw_ dcoutts quaestor Forlorn greeny yulax niteria)
07:22:53 --- names: list (schell wriggle abra0 mero Cale xocolatl phaskell-2 phaskell-1 phaskell dhananjay solatis jokester abh sns mbwe thewormkill dogui mnoonan Sonarpulse ph88 sword_smith t0mb0_ Shandy potatoe huonw unclechu_ codeman777 kosh__ voorhies vinnie92 joe9 calloc fryguybob gienah_ nathyong ccomb rlr crough ggherdov carter peteretep a____ptr spinda MorTal1ty solidsnack_ adulteratedjedi dmoon1221_ rann chriswk beckyconning_ PotatoGim mbrcknl Filthy_casual pchiusano cmdv)
07:22:53 --- names: list (sbauman quoboo alex_lu mpickering mindos_cloud____ NickSeagull phuu dsm g4k seanparsons thoughtpolice fuziontech mankyKitty dstockwell jroesch_ jorendorff_ OliPicard dmh JackMc sisir___ dmwit rfw heyj jlyndon yminsky Bengi_ jonrh caw iphy xplat|work lexi-lambda Tritlo shennyg sclv Flaeme loopspace lancetw NemesisD sephiap stephe marcel_ shelling__ trig-ger bgyss zero7 grandy guampa Shock_ xinming sevas_ jmnk tristanp acarrico robertk nont_ PennyNeko)
07:22:53 --- names: list (rockfruit mendez majjoha Enigmagic jrpls Qommand0r chbatey obadz Askanison ion averell armyriad Orion3k MrWoohoo kantokomi moei jamesbvaughan leat2 clever aloiscochard moop dpower NeverDie pikajude Davehkiin _xor atomi Sorella CurryWurst bydo otto_s Moto-chan angerman pikhq ego larion niko catsup earthy wtw_ pie__ limeburst katymoe hughrawlinson albel727 besenwesen qlkzy Jesin amuck isd pacak jibi prkc sdrodge Factionwars Brando753-o_O_o ronstra nekomune hvr)
07:22:53 --- names: list (henriquev wizonesolutions reem mrBen2k2k2k zpconn__________ sa1 bitonic amatecha YP-Cloud__ Matajon citaret shans_ Dunearhp codebam _flow_ hiratara Nik05 Ravana dolio kus_ubuntui686 qryantm miklcct Taylor niklasb sag3 otulp abbe Deadhandd kolko m1dnight_ hongminhee cdsmith_ yrdz fr33domlover timrs2998 zoran119 raek s4kashya1 opqdonut ElderFain ixian hpc amiri Blkt ktomz a3Dman_ lucz shutdown_-h_now astocko sqrt2 deni magicman phoenix___ happy0 dud opios)
07:22:53 --- names: list (chattered magthe ohsix free_beard platz owickstrom cantstanya PlasmaStar hive-mind CaptainLex byorgey ab9rf wedens cheater tokik zph vikram__________ ryoia spicydonuts tjpeden edwardk alphonse23_ TabAtkins dwarders bluepixel MindlessDrone dmiles cyberlard rootnode chrpape tnks sbjorn thallada kolmodin ctag dibblego chameco ristos schjetne mk-fg Rodya shymega avn t0m0 kier bdeferme taktoa ninefingers Khisanth shirt kurnevsky1 fractalcat wagle LuckyRawApe)
07:22:53 --- names: list (sea-gull ntpttr boothead hc riehfp [exa] daishan skyres trevorriles nathanic ggVGc texasmynsted ploop ollef rootmos boj petercommand zv gseitz drewbert logcat fiddlerwoaroof bus000 oldmanmike __main__ knack kipras ClaudiusMaximus dedgrant andor9001 marens Chobbes adnelson jluttine kyren jnoah drbean SlashLife maerwald padre_angolano tinkyholloway erikd wolfcore dax jgertm SAL9000 Adios StoneToad elgot WizJin atk troydm Natch Fairy capisce lordcirth inr)
07:22:53 --- names: list (mmierz Frankablu dxld trampi joeyh jud mt araujo haasn cdk_ cgfbee ar53nic chris2 asjo geppettodivacin fugyk MitchW BrianHV andromeda-galaxy valdyn jrib1 spion emeritus Tinchos frug72 electrocat monty josephle Nahra hiredman heurist rossberg no-n peddie fergusnoble odamn ortmage_ AustinMatherne segmond phadej thorkilnaur_ zerokarmaleft irishsultan IndigoTiger a6a3uh spoonm Bane^ obihann IanKelling elementalest tommd treehaqr Philonous prefork srhb pygospa)
07:22:53 --- names: list (ephemeron robogoat Robin_Jadoul phaazon martinga_ pleiosaur K0HAX bengt_ tessier_ Forkk kwantam grantwu eyck kaol orion Xe staffehn henrytill_ qinusty kosmikus tumdedum srk xtal_ octo_ chelfi laudiacay eronel chrzyki Baughn divVerent Dykam gsingh93 liyang grol heinrich5991 tharper paf31 integral nbouscal zmanian___ enolan eatonphil amontez_ Bigcheese MasseR Neo KorriX mauke sivs Quintasan sdx32 yorick avdi Cathy borkdude thebnq s4msung xaxisx _janne koray)
07:22:53 --- names: list (monochrom ethercrow sleblanc killerpty vervain hex0punk1 meta-coder revprez_ lulf kini flonk rbocquet theorb smithsto1w abrar PalTale eddsteel Sonderblade mjrosenb bsmt Ankhers alunduil Ralith_ wrmsr fold4 o`connor sgronblo Laney cstrahan_ TrevorBramble CARAM__ codedmart hxegon strixy Guest84199 wting Paks flebron ahihi urdh tristero stelleg gpampara officer_raccoon otterdam tg jaimguer Tenkeyless_Cooki jorj cods jstolarek laxdog bencryption siklsten)
07:22:53 --- names: list (MarcelineVQ amx Myrl-saki m0rphism Bashmetim yusukesuzuki Madars nilsi HalfEatenPie ljhms luis iross sujeet pdxleif ChongLi johtso mell jbalint japesinator Stratege_ urh Kneiva JPohlmann benjamin1rom Drezil vqrs jfokkan__ rotty zrl mbrock si14 andreypopp Freundlich arkeet dunj3 thomas joehillen ManiacTwister Reyu julmac diskie ent cjwelborn SegFaultAX mitchty bshelden minsky adamCS bgamari andjjj23_ neonfuz Klumben carter-znc Phillemann hiptobecubic_ zxtx)
07:22:53 --- names: list (siddhu ricardo82 intelux acfoltzer vikraman hegge cjh` Hafydd alercah brolin_empey tomku bairyn_ haircode_ frontendloader metalrain ess_sing Xorlev s4kashya_ funfun Marqin ongy nopf joeytwiddle zymurgy simony mantovani johl chirpsal1 ngWalrus kjanosz bsermons brent eyenx bd_ kian lenstr wildleaf xacktm monkeyiq lyxia anderson hpd pelegreno___ d3lxa tolt samgd CindyLinz bshd mattp_ hsyl20 PHO _Tristan-Speccy_ tippenein dqd mathu Ewout fabiopbx lstrano fycth)
07:22:53 --- names: list (qknight jophish Jello_Raptor LnL kshannon brixen Hijiri Fylwind amalloy_ iskander zhulikas coeus edwtjo Desoxy folsen netblaze eL_Bart0 jtcs ao1ei8_ Speed exio4 mariothemad mrm sphalerite hodapp zenzike kandinski benj02 chronon-io poga ycheng mitch_ nille glowcoil mceier qnix bind filibustr suzu JRHaigh RGamma guios Arguggi Ezku kennyp froztbyte parenthetical bcoppens lambdabot Ranhir dredozubov_ sshine RageD adarqui klugez Twey RevJohnnyHealey numberten)
07:22:53 --- names: list (jix_ hansihe arianvp qguv Guest15006 jw358 fairfieldt jcp__ swhalen xxpor unbalanced lhynes daf tv Gothmog_ Akii marmoute djm ijp quuxman Willis_ ario Fuuzetsu vishesh canta yeltzooo Ke Saimeidae javax ReinH_ jackhill tomus horatioh1 seliopou_ flippant Zemyla l3france nikolah Soft andreass davl foobars bogdanteleaga dan64 metaf5_ adraenwan amiller_ aaron7 EvanR sm radek1 ernst imalsogreg Ariadeno pdgwien Jonno_FTW s4kashya statusfailed __rlp dyreshark cdidd)
07:22:53 --- names: list (Saizan osfameron etabot __name__ thoros bob_twinkles oelewapperke eamelink Vq ahf tsani statusbot swistak35_ lachenmayer edran johnstein reactormonk scopedTV_ Adeon dh parsnip hemite ski Solarion jlouis Ninja3047 wrengr_away ryantm vfs Fubar^ KaneTW baweaver ajmccluskey iteratee icedev Xnuk sleepynate toure sLite ps-auxw runawayfive LeaChim_ ppnkk alpounet relrod cic kqr bitemyapp lattenwald dredozubov dpn` Clint staticfox arrdem_ shapr Morgawr angseus)
07:22:53 --- names: list (martinr- christiansen haldean ynyounuo mudfog_ tero- tjt marienz xplat tdammers niluje obiwahn bbee davean lanodan acro tek0 cross cmr oherrala myfreeweb_ sajith_ anachrome comboy_ etcinit freekevin jle` KeelOfSteel nerdystreetrat topi TimWolla dgonyeo kipd frostarea briansteffens Sgeo bounb vin-ivar Desu barrucadu supki alanz killtheliterate Reisen GGMethos_ irclogger_com rembo10 Ring0` geal ryanpcmcquen Hermit rotcpy nickpascucci Yaiyan Xandaros APic)
07:22:53 --- names: list (naudiz p_q liste m1dnight` Pucilowski Geekingfrog ben PanicSkittle spacebug mak` Maxdamantus cow-orker Deewiant richi235 Guest5571 ephess_ tswett indiffernet Elision wayne superfatkappa Belgarion0 Amun_Ra qmm hausdorff snoogie saurik Profpatsch fmapE _drazil lassulus n__dles ndeine Raynes absence unsymbol c_wraith linduxed Rembane ec\ dschoepe benzrf dustinm psmolen_ isomorphismes navilan- emmflo hydPaz tjbp gornikm schultz aatxe brennie gargawel ddima)
07:22:53 --- names: list (implementation_ Sagi surtn Jaak AppleJacks24 ft fabianvf tctara krgn Igloo Tene codebje tych0 garphy`aw pieter ajaniMember epta _ashbreeze_ mrowe yarou stux|RC-only Oxyd Eagle_Erwin lukky513 Rabbit_ cjay Lutin` ramatevish nilOps DDR vodkaInferno jpl aweinstock nurupo [swift] orzo fxrs brisbin jvanbure RazorX trajing SiCC fingerzam mimi_vx ybit g2` lpsmith Majiir saidinwot Khudher CodeKiwi tekacs rodlogic prooftechnique_ jinblack riscool DustyDingo cynick)
07:22:53 --- names: list (mgaare juri_ gabiruh_ jtobin mrlase gridaphobe Nikotiini kloeri johnv_ noctux ircbrowse ipuustin_ DiabolikFreenode ido_ theo mrd buoto jrslepak so cin wjm wamaral Biohazard anoe tazjin_ Phyx- Starfire_ Chousuke_ pyrtsa XMunkki_ e stass eagleflo oberstein bjobjo Benzi-Junior Hakey mmaruseacph2 taruti donwilliam hbar_ hyPiRion squimmy oldsk00l reynir koala_man orcus danieli nitrix SLi jkarni_ Jinxit Moyst Eliel_ Wamanuz2 cnr noexcept_ sohum pflanze akermu)
07:22:53 --- names: list (codehero fyolnish SuperTux88 cbaines tgeeky brezel da-x raid Jaxan minad _6a68 x1n4u cschneid Axman6 Purlox koomi Tehnix gniourf ncl28 esmiurium M2tias buckowski alem0lars Edoxile Amadiro betawaffle higgs kriztw mudfog asm89 kungp felixsch dfranke burp_ posco Liskni_si Sigyn mikeplus64 SenpaiSilver @ChanServ SolarAquarion flux Lord_of_Life mikeizbicki xfix carc idupree gothos spaceships eikke tomaw Ulrar JDevlieghere_ alang solarus dzack counterfeit mkloczko)
07:22:53 --- names: list (xa0 jimki bananagram shwouchk Elsi LFDFQ mw jlewis seagreen CosmicRay baetheus catgirl)
07:23:15 <iphy> Insanity_: the haskell we're using is intentionally fairly simple, avoiding language extensions etc., because high security software should be "obviously correct", not "arguably correct"
07:25:15 <amx> iphy: are you iphydf on github?
07:26:37 <iphy> yes
07:28:02 <babu`> mgsloan: I forgot to mention that this is a regression after I updaed intero. I have seen other people reporting the same problem.
07:29:43 <paolino> can I express this with fix ? "recurse x g = g x >>= flip recurse g"
07:31:05 <lyxia> always
07:31:22 <lyxia> recurse = fix $ \recurse x g -> g x >>= flip recurse g
07:31:46 <lyxia> @pl \recurse x g -> g x >>= flip recurse g
07:31:46 <lambdabot> flip (ap . ((>>=) .) . flip id) . flip
07:32:19 <ski> @type flip (fix . (>=>))
07:32:21 <lambdabot> Monad m => a -> (a -> m a) -> m c
07:32:43 * hackagebot yesod-bin 1.4.18.7 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.18.7 (MichaelSnoyman)
07:32:56 <lyxia> it's iterateM_ from monad-loops
07:33:19 <lyxia> More precisely, flip iterateM_
07:36:34 <ocramz> anyone knows why `distributed-process` and related packages are not on Stackage?
07:38:49 <Guillaum> ollef: (sorry I did not see your answer sooner). I saw the discussion on the bug tracker. Actually I don't really care about the speed, so do you know if there is a simple workaround that I can integrate in my grammar to get an ordering ?
07:39:27 <paolino> :t fix . f
07:39:28 <lambdabot> (FromExpr c, Show a, Show c) => a -> c
07:39:50 <paolino> :t \f -> fix . f
07:39:52 <lambdabot> (a -> c -> c) -> a -> c
07:40:50 <paolino> :t \f -> (fix .) .  f
07:40:52 <lambdabot> (a -> a1 -> c -> c) -> a -> a1 -> c
07:42:15 <ollef> Guillaum: I'm not sure there's a nice way to do it, but perhaps you could achieve what you want e.g. by augmenting the AST you're producing with some ordering info. You could also try the OrderedResults branch on github. :)
07:42:18 <paolino> :t (>=>)
07:42:19 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:44:35 <paolino> how c is both (a -> m b) and (a -> m c) ?
07:45:09 <paolino> mh, got it wrong
07:45:24 <vinnie92> Hi paolino 
07:45:49 <paolino> hello
07:46:00 <vinnie92> "ciao" :P
07:47:38 <andreoss> is there exec() in System.* modules? 
07:47:48 <javjarfer> Hi there! I was looking into Servant internals and I found this https://hackage.haskell.org/package/servant-0.9/docs/src/Servant-API-Sub.html#%3A%3E
07:48:04 <Guillaum> ollef: ok, I'll try that. Thank you.
07:48:30 <javjarfer> anyone knows why they restrict the type of path to "k"? It's to just combine fixed types with the operator?
07:51:17 <monochrom> andreoss: somewhere under System.Posix
07:53:01 <Gurkenglas> > map (take 10) $ transpose [replicate 3 i | i <- [1..]] -- why isnt http://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.OldList.html#transpose lazy this wa
07:53:03 <Gurkenglas> *y
07:53:07 <lambdabot>  mueval-core: Time limit exceeded
07:54:28 <monochrom> is it lazy some other way?
07:56:07 <benzrf> > transpose [replicate 3 i | i <- [1..]]
07:56:09 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:56:14 <benzrf> > transpose [replicate 3 i | i <- [1..]] !! 2
07:56:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:56:25 <benzrf> weird
07:56:46 <benzrf> oh i see
07:56:48 <MarcelineVQ> take an infinitely tall reactangle and tip it over, how wide is it?
07:56:58 <benzrf> Gurkenglas: it cant figure out that there is no fourth element of the transposed list
07:57:27 <benzrf> > take 3 (map (take 10) $ transpose [replicate 3 i | i <- [1..]])
07:57:29 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]]
07:57:33 <benzrf> but *that* works
07:58:03 <benzrf> if you plug the original into ghci, it spits out the first three elements and then hangs
07:58:12 <benzrf> actually - can we get that functionality in lambdabot?
07:58:21 <benzrf> i.e. as much of the Show instance as ends up being spit out
07:58:37 <Gurkenglas> (Ah yes I bumped into this one a few times already, should have realized, yes on the lazy printing)
08:00:22 <Gurkenglas> (bumped into the strict printing, that is)
08:00:58 <mnoonan> does anybody have some hints on structuring code to reduce ghc's memory usage? I have a 20k line (generated) .hs file that is gobbling >8g of ram to compile.
08:01:11 <mnoonan> I have to kill ghc before it makes my machine unusable.
08:02:55 <benzrf> cripes
08:03:50 <mnoonan> it isn't particularly complex though. 70% of it is a very long but linear "do" block.
08:04:00 <MarcelineVQ> does it eventually compile?
08:04:45 <mnoonan> When it was 12k lines it did, but now it renders ubuntu useless if I let it keep going.
08:04:57 <mnoonan> (frozen mouse pointer, etc)
08:10:05 <ClaudiusMaximus> mnoonan: try   ghc +RTS -M4G -RTS  or similar so that ghc will abort when memory usage gets too high, instead of crippling the operating system
08:11:52 <ClaudiusMaximus> mnoonan: that won't solve the problem, but will make testing changes to the code less fraught
08:12:00 <mnoonan> thanks, will do
08:17:15 <heebo> I have a ScottyT Text (ReaderT Config IO) ()  and I want to turn it into a ScottyT Text (IO) ()
08:17:22 <heebo> what do i need to do?
08:19:08 <Axman6> doesn't look like that's something which is exposed. 
08:19:38 <heebo> Axman6: you mean unwrapping a ScottyT?
08:20:12 <heebo> I thought i might be able to reach the inner context by composing fmap
08:20:43 <Axman6> fmap only lets you touch the final type parameter
08:20:54 <Axman6> looks like the scottyT function migth help you though
08:21:19 <Axman6> https://hackage.haskell.org/package/scotty-0.9.1/docs/Web-Scotty-Trans.html#g:1
08:21:19 <heebo> I dont really understand its type signature
08:21:54 <Axman6> the (forall a. m a -> n a) bit is essentially your `runReaderT config` function
08:22:45 <heebo> oooooh thansk
08:22:47 <heebo> thanks
08:22:56 <dramforever> 0.10.2 looks like this: http://hackage.haskell.org/package/scotty-0.10.2/docs/Web-Scotty-Trans.html
08:23:12 <Axman6> the (m Response -> IO Response) function seems a little harder, but it's after 2 in the morning so I might just be too tired to figure out how to use it
08:23:41 <Axman6> bleh, damn google giving me old results
08:23:56 <dramforever> well, *if* you've got (forall a. m a -> IO a) you *have* (m Response -> IO Response)
08:24:10 <Axman6> this is true
08:24:30 <dramforever> Yes 2 a.m. problem
08:31:13 <mnoonan> Ok, I got around the build memory usage by re-rolling the big do block into a loop. but it does make me concerned about why things blew up so badly in the unrolled version.
08:32:44 * hackagebot hspec-expectations 0.8.0 - Catchy combinators for HUnit  https://hackage.haskell.org/package/hspec-expectations-0.8.0 (SimonHengel)
08:35:13 <heebo> fixed the issue , thanks guys would never have guessed that (forall a. m a -> n a) what (`runReaderT` config)
08:35:24 <heebo> still have a way to go I guess
08:54:03 <Guillaum> ollef: I'm trying the ordered branch and changing the order of my alternatives rules does not change the order of the results. Am I missing something ?
08:57:10 <ollef> Guillaum: It could either be that the branch is buggy or that your expectations are off :)
08:57:50 <codedmart> I am running a web server (servant), but I forkio because I want to listen to rethinkdb changes. I am using https://github.com/AtnNn/haskell-rethinkdb/blob/master/Database/RethinkDB/Network.hs#L407. I haven't done too much debugging yet but it seems the thread just dies. Any suggestions on what to do or where to look?
08:59:10 <Guillaum> ollef: alright.
09:01:17 <nitrix> Hi. Can `data Foo a = F (a -> Bool)` and `data Bar b = B (b -> b -> Bool)` both be made contravariant functors?
09:01:35 <glguy> nitrix: yes
09:01:41 <nitrix> Is there a general rule? I'm assuming (Bool -> a) cannot work?
09:02:06 <monochrom> Bool -> a is like Reader Bool a and is a functor.
09:02:33 <glguy> nitrix: In b -> b -> Bool, both of the uses of `b' are in "negative" positions
09:02:41 <glguy> so you can write a contravariant functor instance
09:02:43 <nitrix> A friend mentioned a rule about odd/even amount of arrows but I can't seem to see the relation.
09:02:53 <glguy> In the case of Bool -> a, all the uses of `a' are in positive positions
09:03:01 <glguy> so you can write a covariant functor instance
09:03:07 <nitrix> glguy: negative meaning they appear first? As inputs?
09:03:46 <Tuplanolla> Consider `let x = b -> Bool in b -> x`, nitrix.
09:04:11 <Tuplanolla> Both arrows have `b` as the source.
09:04:12 <glguy> nitrix: Yeah, as inputs to the function. Every time you go on the left-hand side of a function arrow you flip the "polarity"
09:04:39 <glguy> So you can have a functor instance for:   data T a = D ( (a -> Bool) -> Char )
09:05:14 <Gurkenglas> Why isn't there DeriveContravariant?
09:05:22 <nitrix> Char is position, a -> Char negative, (a -> Bool) -> Char, positive again ?
09:05:32 <nitrix> s/tion/tive/
09:05:35 <glguy> Gurkenglas:  because it's somewhat ambiguous how you'd derive it in general
09:06:05 <monochrom> there is no "a" in "Char".
09:06:35 <nitrix> glguy: Do we say the whole signature is positive/negative, or is it in relevance to the position of specific things in the signature?
09:06:37 <glguy> Gurkenglas: If you search around you can find some different approaches with generics or template haskell, and they'll generally (hopefully) mention what bias they have
09:06:46 <glguy> nitrix: position of things
09:06:57 <nitrix> glguy: As I thought. Appreciated.
09:07:00 <glguy> (a -> b),  a is in a negative position, b is in a positive one
09:07:09 <nitrix> Gotcha.
09:08:37 <hexagoxel> mnoonan: you could try to call ghc with -v to see what phase it gets "stuck" in.
09:10:03 <Guillaum> ollef: actually all the test of the branch related to ordering are failing. I'll try to investigate why.
09:10:42 <Sceinox> I'm doing Haskell for about 1 week or 2 by just learning via youtube videos and the internet. Is there any book you guys can recommend?
09:11:28 <Tuplanolla> What's your background, Sceinox?
09:11:36 <Sceinox> Java, C#, C
09:11:43 <shapr> Sceinox: I like the most recent Haskell Book
09:12:01 <shapr> Sceinox: https://twitter.com/haskellbook
09:12:06 <ollef> Guillaum: Oh, damn. Maybe that's the wrong branch I pushed. It's been a while since I looked at that stuff.
09:12:21 <Sceinox> thanks shapr. I'm taking a look at it :)
09:12:39 <Tuplanolla> That's a good idea then. You might also enjoy Real World Haskell, Sceinox.
09:12:54 <Cale> Graham Hutton's book http://www.cs.nott.ac.uk/~pszgmh/pih.html is pretty good.
09:13:20 <Cale> http://www.cis.upenn.edu/~cis194/spring13/lectures.html -- there's a bunch of free course materials here which are also a decent tutorial
09:13:55 <Sceinox> okay, thanks guys :)
09:14:09 <Sceinox> i'll take a look at them
09:16:03 <buttbutter> I thought RWH was terrible :(
09:16:17 <MarcelineVQ> it's great, it's just aging
09:16:34 <buttbutter> So many mistakes. Nothing ever compiles. Extremely long-winded. 
09:16:39 <MarcelineVQ> the comments in the material go a long way
09:16:46 <buttbutter> Yeah.
09:16:58 <buttbutter> IMO, this is by far the best resource to learn Haskell: http://cis.upenn.edu/~cis194/spring13/
09:17:05 <buttbutter> Solutions are available from Brent if you email him.
09:17:14 <hohonut> how to wrtie bytestring to file with utf8 encoding?
09:17:16 <buttbutter> It's how I learned, after failing with RWH and LYAH
09:17:52 <hohonut> do i need to decode the bytestring to text first ?
09:18:03 <buttbutter> The pedagogy of just reading along and following examples is absurd. No one learns like that. You need the strong exercise component. :)
09:18:54 <monochrom> RWH is great if you already know Haskell
09:19:05 <geekosaur> hohonut, your question doesn't make a lot f sense. a bytestring is bytes, it isn't something you would encode to utf8
09:19:11 <monochrom> it's why all the Haskell experts say it's great.
09:19:34 <geekosaur> ...or if it was intended to, you have made a terrible mistake and it has a high probability of containing garbage
09:19:41 <Tuplanolla> I found LYaH and RWH to be a good tour of Haskell for someone already familiar with functional programming, buttbutter.
09:20:19 <geekosaur> hohonut, so, what is this ByteString, what does it actually contain
09:20:20 <buttbutter> Tuplanolla: Yeah. But they're not good ways to *learn* it. They're more references than anything else. I think the UPenn course is a great way to learn Haskell, coming from a non-functional background. 
09:20:25 <Sceinox> Yeah, the only functional programming I know are lambda expressions in Java 8 and c# :D
09:20:41 <buttbutter> Sceinox: I really very strongly recommend the UPenn class then :)
09:20:44 <EvanR> Sceinox: i guarantee you thats a lot better than nothing
09:20:50 <buttbutter> I've done every assignment and it was great and I learned a ton.
09:21:13 <buttbutter> The only lacking area was in Monads. But once you get there you'll be strong enough for some more sophisticated resources. :)
09:21:17 <monochrom> You will need exercises. Created by others or created by yourself.
09:21:39 <Sceinox> buttbutter: UPenn class?
09:21:40 <monochrom> I am great at creating exercises for myself, so I just needed The Gentle Introduction.
09:21:46 <buttbutter> Sceinox: http://cis.upenn.edu/~cis194/spring13/
09:21:48 <Sceinox> ah
09:21:55 <buttbutter> Email Brent Yorgey for solutions.
09:21:58 <Sceinox> that link :D
09:22:02 <buttbutter> Or actually just ask me. I have them. :D
09:22:14 <buttbutter> I'll put them on my bitbucket :)
09:22:25 <Sceinox> that would be very nice :D
09:23:16 <geekosaur> hohonut, understand that if you thought you just wanted the simple solution, then your ByteString is prpbably already corrupted and there is *no* solution. because there is no utf8 involved unless it was already encoded to utf8 to start with, in which case there is nothing to do 
09:24:06 <ryantrinkle> how expensive is the 'touch' primitive?
09:26:06 <JuanDaugherty> did you mean the unix command?
09:26:55 * geekosaur presumes touch#
09:27:09 <geekosaur> but no idea how expensive it is
09:27:17 <buttbutter> Sceinox: https://bitbucket.org/rschenck/cis194_brent_yorgey_solutions/
09:27:56 <hohonut> i use httpLBS from the http-conduit library to download a file as bytestring
09:28:07 <hohonut> then I need to write the content to a local file
09:28:17 <hohonut> as text
09:28:24 <JuanDaugherty> looks like it's the same function, so no neglible for a single file
09:28:26 <Sceinox> buttbutter: you are awesome :D thank you very much
09:28:28 <dfeuer> int-e, my intuition about this Integer thing is clearly lousy. I couldn't get your fancy version to be fast without risking a space leak, but I was able to get a variation on your simple version that's around 6 times as fast as the version in base for small inputs and around twice as fast for extremely large ones.
09:28:35 <buttbutter> Sceinox: I can't strongly recommmend the class enough. It's great. :)
09:28:38 <buttbutter> Good luck! :)
09:29:08 <JuanDaugherty> but conceivable large impact on dependencies, build time, it's purpose
09:29:14 <JuanDaugherty> *its
09:29:30 <ryantrinkle> geekosaur: yes, touch#
09:29:32 <geekosaur> hohonut, unless you know that it has a particular encoding and need to convert it, just use the ByetString writeFile
09:29:37 <Cale> ryantrinkle: It... looks unsupported on everything except Mach
09:29:47 <ryantrinkle> Cale: haha, well, it does *something*
09:30:35 <ryantrinkle> the actual situation is that i need to have a function a -> b, based on unsafePerformIO, and guarantee that it doesn't get floated to a CAF, even though it doesn't actually access its argument
09:30:48 <dfeuer> Er... except I measured slightly the wrong thing, so that may not be quite right. Silly paren business.
09:30:51 <ryantrinkle> i.e. for each distinct value the function is called on, i need the unsafePerformIO to run again
09:30:57 <int-e> dfeuer: the space leak you described can be fixed by putting the bases into the stack... but later...
09:30:59 <hohonut> geekosaur: can bytestring write with utf8 encoding?
09:31:14 <geekosaur> hohonut, did you even read what I said before?
09:31:47 <geekosaur> ByteString is ByteString. the content is already encoded, *somehow*, you have to find out how. that encoding may be utf8
09:31:59 <hohonut> ok
09:32:10 <EvanR> if its not utf8, but close, you could fudge it
09:32:15 <geekosaur> you cannot "convert" it to utf8, because either it already is utf8 or you have to decode it and re-encode it to utf8
09:32:19 <EvanR> its designed to recover
09:32:45 * hackagebot leancheck 0.6.0 - Cholesterol-free property-based testing  https://hackage.haskell.org/package/leancheck-0.6.0 (rudymatela)
09:32:47 * hackagebot fitspec 0.4.0 - refining property sets for testing Haskell programs  https://hackage.haskell.org/package/fitspec-0.4.0 (rudymatela)
09:33:04 <Cale> hmmm
09:34:20 <geekosaur> unfortunately encodings are not magical, you cann;t just say "write this ByteString as utf8" because the ByteString is just bytes, it does not know what encoding it is
09:34:30 <geekosaur> but it has to be an encoding, or else it is binary data
09:34:34 <Cale> ryantrinkle: I suspect that the fact that it appears unsupported on all these other architectures means that it actually doesn't end up making it to codegen in most cases, but I'm not sure where it gets consumed.
09:35:22 <ryantrinkle> Cale: well, it definitely prevents floating
09:35:22 <ryantrinkle> haha
09:35:23 <Cale> (which would make sense, if it's just a dependency analysis thing)
09:35:27 <ryantrinkle> cool
09:36:03 <geekosaur> and with httpLbs there is no way to find out from the server what encoding it used, so I guess you get to hope it's already utf8 and write it out
09:36:54 <geekosaur> unless you know the server gave you something else. if you don't know, you need to find out. because a ByteString has no idea what encoding if any it contains, and cannot "just convert it ok?"
09:36:59 <ph88> dmwit, i wouldn't even know where to start minimizing the code really
09:37:04 <EvanR> yes "encode this bytestring as UTF8" is a gross type error
09:37:34 <EvanR> its a worse violation than normal because people think it makes sense
09:38:02 <geekosaur> ^ and because many other languages just assume, and someone else has to clean up the mess afterward
09:39:06 <EvanR> thats like can you please decrypt this plaintext
09:39:45 <EvanR> doesnt make sense? i dont care just do it
09:41:49 <joncol> Hi, should a function solveQuadratic (for solving eqs of the form ax^2+by+c = 0) return: [Float] or Maybe (Float, Float)? What's nice?
09:43:38 <juri_> i would think the latter.
09:43:39 <mnoonan> maybe just "data Roots = NoRoots | OneRoot Float | TwoRoots Float Float", or even "type Roots = Set Float"??
09:43:48 <Tuplanolla> How about `[Complex Double]`, joncol?
09:44:08 <ski> (if you're doing modular arithmetic, then there can be more than two solutions)
09:44:58 <joncol> This is for a pretty limited scenario where I'm only interested in real roots. Nice ideas though.
09:45:47 <Tuplanolla> Don't use `Float` unless you really have to, joncol.
09:46:46 <joncol> Tuplanolla: OK, no real speed advantage against Double?
09:46:59 <ryantrinkle> joncol: just try to avoid making it possible to represent invalid values
09:47:40 <ryantrinkle> if [1] or [1,2,3] wouldn't make sense as results, then the Maybe option (or something like it) is probably better than a list
09:48:10 <ryantrinkle> there's probably also an "infinite roots" case
09:48:28 <ryantrinkle> (trivial, of course, but who knows what'll happen in a real program :))
09:48:52 <geekosaur> joncol, all current hardware either emulates Double or does it in hardware; in both cases the result has to be truncated in an extra step to get Float
09:49:07 <joncol> geekosaur: ok, I see
09:49:14 <geekosaur> (ARM's the only platform that emulates it)
09:49:24 <geekosaur> (and even there you can find chips with hardware FP)
09:49:32 <Tuplanolla> The only advantage of `Float` is minimizing storage in bulk, joncol.
09:50:52 <joncol> OK, size problems would not be applicable here (I'm making a simple raytracer).
09:51:16 <EvanR> joncol: http://lpaste.net/246696
09:51:36 <EvanR> thats what im using in my game in the module which involves solution a quadratic equation
09:51:45 <Tuplanolla> You're missing the infinite case, EvanR.
09:51:52 <EvanR> lol
09:52:20 <EvanR> the algorithm would return finite solutions
09:52:32 <EvanR> for the problem its solving
09:53:34 <joncol> EvanR: Cool, I went with something like that as well.
09:54:00 <joncol> EvanR: You have a page for your game?
09:54:52 <EvanR> was about to say no... but actually theres an entire blog and a youtube video
09:56:35 * EvanR is now wondering how in the world OneSolution would happen
09:56:55 <ryantrinkle> EvanR: isn't that when the parabola just barely touches the X axis?
09:57:05 <EvanR> thats what im thinking
09:57:05 <ski> "kisses", yes
09:57:12 <EvanR> that seems highly nlikely
09:57:34 <EvanR> i guess the doubles could work out
09:57:38 <hohonut> thanks geekosaur 
10:03:03 <joncol> EvanR: What blog is that? Sounds interesting.
10:06:31 <JonReed> Hi, how can I extract a nat value from the type that looks like this `data MyData a b = MyData { _someField :: String }; getAValue :: (a ~ Nat) => Proxy (MyData a b) => Integer; getAValue = ???`. I know that I have to use natVal, but I haven't been able to find a way how to do it in this case.
10:12:11 <ClaudiusMaximus> JonReed: what is the type of natVal?  possibly use -XScopedTypeVariables to be able to use  ::a  within the body of getAValue;  see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#lexically-scoped-type-variables
10:13:46 <ClaudiusMaximus> JonReed: your type of getAValue looks a bit off to me too, what with two =>
10:14:23 <JonReed> ClaudiusMaximus: Ah, yeah. It should be:  getAValue :: (a ~ KnownNat) => Proxy (MyData a b) -> Integer; getAValue = ???`
10:15:13 <ClaudiusMaximus> i'd have expected  :: KnownNat a => ...
10:16:26 <ClaudiusMaximus>  ~ means type equality, which would imply   a :: * -> Constraint  or something like it
10:32:46 * hackagebot Glob 0.7.12 - Globbing library  https://hackage.haskell.org/package/Glob-0.7.12 (MattiNiemenmaa)
10:35:59 <Fairy> newtype Test = Test (String -> Maybe Integer)    could someone try to explain what I'm looking at here? How would I use a data like this?
10:36:19 <ph88> could someone take a look at this function? it does a quickcheck and print input and output (which appear the same) .. but the quickcheck is still failing .. not sure where i made a mistake   https://paste.fedoraproject.org/445111/14757796/   output: https://paste.fedoraproject.org/445115/79805147/
10:37:16 <ongy> Fairy: a newtype. It is similar to the data keyword, but more restricted so it can be optimized. This will introduce a new Type called "Test", and a new constructor Test with type '(String -> Maybe Integer) -> Test'
10:37:18 <ski> Fairy : a value of type `Test' contains a function converting a `String' to a `Maybe Integer'
10:39:15 <Fairy> I'm sorry, but could I get a usage example? I'm not understanding this very well :S
10:39:56 <JonReed> doTest :: Test -> Maybe Integer; doTest (Test f) = f "hello";
10:40:03 <ski> @let newtype Test = Test (String -> Maybe Integer)
10:40:05 <lambdabot>  Defined.
10:40:15 <JonReed> testMain :: IO (); testMain = print (doTest (Test (Just . fromIntegral . length)));
10:40:28 <ski> @let doTest :: Test -> Maybe Integer; doTest (Test f) = f "hello"
10:40:30 <lambdabot>  Defined.
10:40:33 <geekosaur> you use it the same way you would use the equivalent `data`. the only difference is that `newtype` is restricted in a way that lets the compiler remove it after typechecking, so it has zero cost (whereas `data` inserts an additional indirection)
10:40:48 <ski> > doTest (Test (Just . fromIntegral . length))
10:40:51 <lambdabot>  Just 5
10:41:17 <JonReed> Fairy: It's the same as idea as doTest :: (String -> Maybe Integer) -> Maybe Integer
10:41:26 <ski> > doTest (Test (fmap fromIntegral . findIndex (== 'e')))
10:41:28 <lambdabot>  Just 1
10:41:57 <JonReed> Fairy: Youc an rename that function to: type MyFunction = (String -> Maybe Integer) and have: doTest :: MyFunction -> Maybe Integer
10:43:39 <JonReed> Fairy: newtype is like a type synonym (plain `type` keyword). Expect that you have to explicitly wrap and unwrap that type.
10:45:21 <JonReed> Fairy: You can have `type Distance = Int; type Speed = Int;` and a function like `myFunction :: Distance -> Speed -> Something;` and using it like `myFunction 5 5`
10:45:54 <JonReed> Fairy: If myFunction gets refactored then you can accidentally swap distance for speed and compiler won't notice it because they are synonymous to Int for it
10:46:58 <JonReed> Fairy:  With newtype you would have: `newtype Distance = Distance Int; newtype Speed = Speed Int;` and you'll use it like `myFunction (Distance 5) (Speed 5)`
10:47:43 <byorgey> buttbutter: I'd rather you didn't post my solutions publically
10:48:41 <byorgey> buttbutter: various people (myself included) still use those materials for teaching actual classes.  That's why I have not posted them.
10:48:51 <JonReed> Fairy: Now if myFunction becomes `myFunction :: Speed -> Distance -> Sometihng`, then GHCI will complain about the line `myFunction (Distance 5) (Speed 5)`
10:48:59 <JonReed> GHC*
10:50:46 * ski idly wonders whether Fairy is lost yet
10:51:16 * Fairy squanders around within the walls of text wondering if she's stupid :S
10:52:00 <ski> it takes some practice and time to get used to thinking about and using the concepts
10:52:08 * erisco watches, quietly slurping a bowl of soup
10:52:53 <ski> Fairy : do you have a context, in which your `newtype Test = Test (String -> Maybe Integer)' appeared ?
10:53:09 <Fairy> Like, I seem to be able to use data types just fine, but then this weird type one pops up and I get completely stumped - the "explanations" make sense, but I can't for the life of me actually "use" them
10:53:46 <byorgey> Fairy: in terms of using them, newtypes work exactly the same as a data type with one constructor
10:54:04 <fld> ?let
10:54:04 <lambdabot>  Define what?
10:54:15 <byorgey> so  newtype Test = Test (String -> Maybe Integer)   is just like    data Test = Test (String -> Maybe Integer)
10:54:18 <erisco> you do not need to set out to use newtypes, they're narrow in purpose
10:54:30 <byorgey> or  data Test where   Test :: (String -> Maybe Integer) -> Test ,  if you are used to GADT syntax
10:54:34 <erisco> nothing more than a loophole for type classes
10:54:51 <ski> Fairy : do you understand yet how to read types like `String -> Maybe Integer' ?
10:55:47 <Fairy> I read them as "give String, get Maybe Integer"
10:56:02 <ski> that's roughly right
10:56:23 <ski> more accurate is "the type of functions, that when given a `String' as input, will produce a `Maybe Integer' as output"
10:56:29 <ski> so that if you see
10:56:40 <ski>   mystery :: String -> Maybe Integer
10:57:06 <ski> you then know that `mystery' is a function, that when given a `String' as input, will produce a `Maybe Integer' as output
10:57:24 <ski> makes sense ?
10:57:42 <Fairy> it does, everything makes perfect sense so far
10:57:51 <ski> have you used higher-order functions yet ?
10:57:59 <ski> e.g. `filter' or `map'
10:58:12 <ski> or `takeWhile' or `foldr'
10:58:28 <Fairy> Yeah, a couple of times now, they're very straightforward
10:58:42 <erisco> f :: a -> b, x :: a ---> f x :: b   i.e. application or modus ponens
10:59:19 <ski> let me briefly define a higher-order function, for reiteration
10:59:21 <ski> recall that
10:59:24 <ski> @type words
10:59:26 <lambdabot> String -> [String]
10:59:27 <ski> @type unwords
10:59:28 <lambdabot> [String] -> String
10:59:36 <ski> they works as follows :
10:59:48 <ski> > words "This is a short sentence"
10:59:50 <lambdabot>  ["This","is","a","short","sentence"]
11:00:02 <erisco> it is that rule by which you have "given an A, get a B"
11:00:19 <ski> > unwords ["Cat","on","mat","in","black","hat"]
11:00:21 <lambdabot>  "Cat on mat in black hat"
11:01:17 <erisco> the great thing to unlearn is the way we hold this apart from other rules
11:01:22 <erisco> or at least that is a struggle I have
11:01:27 <ski> we can use these to define a function that when `String', will cut it apart into a list of words, then apply a custom, *user*-supplied function to that list, then stitch the resulting list of words back together into a single `String'
11:02:00 <ski> @let onWords :: ([String] -> [String]) -> String -> String; onWords f str = unwords (f (words str))
11:02:02 <lambdabot>  Defined.
11:02:09 <ski> and we can use it like
11:02:11 <erisco> I am able to stand back and look at the machinery of equals, for example, as reflexive, transitive, symmetric, yet have great difficulty seeing functions similarly
11:02:51 <ski> > onWords reverse "cat is happy"
11:02:57 <lambdabot>  "happy is cat"
11:03:01 <ski> or
11:03:22 <ph88> > onWords reverse "happy is dog"
11:03:27 <lambdabot>  "dog is happy"
11:03:32 <erisco> there is this strong sense that functions do stuff, or some special association like this, that muddies the thinking
11:03:34 <ph88> good
11:03:51 <ski> > onWords (take 3) "A somewhat longer sentence can be written here"
11:03:54 <lambdabot>  "A somewhat longer"
11:04:03 <ski> Fairy : does this make sense, so far ?
11:04:18 <EvanR> erisco: well, some wise guy decided to call them *functions* for a reason
11:04:29 <Fairy> ski: yes, I haven't had any problems with those
11:04:34 <EvanR> today we can call them mappings
11:05:06 <ReinH> > onWords (take 2) "this  is a test"
11:05:08 <lambdabot>  "this is"
11:05:17 <ski> Fairy : now, your `newtype Test = Test (String -> Maybe Integer)' means that the data constructor here, `Test', will get the signature
11:05:28 <ski>   Test :: (String -> Maybe Integer) -> Test
11:05:45 <erisco> EvanR, when you've used functions for years to glue libraries together and handle HTTP communications and so on, the notion of "function" can become convoluted
11:06:02 <ski> meaning that if you pass a function of type `String -> Maybe Integer' to the data constructor `Test', it will "package up" that function inside a resulting value of type `Test'
11:06:12 <ski> then, if you define a function like
11:06:30 <ReinH> Luckily the notion in Haskell is straightforward.
11:06:34 <ski>   doTest :: Test -> Bool
11:06:43 <ski>   doTest (Test f) = ..f..
11:06:46 <erisco> EvanR, so there becomes many unnecessary associations with "function" that renders them unclear
11:07:11 <ReinH> you just have to forget the other notions that basically mean "procedure" and use Haskell's definition.
11:07:14 <ski> then you're unpackaging the function that you got inside the `Test' argument, so that `f' is here of type `String -> Maybe Integer'
11:07:29 <ski> Fairy : fine with this ?
11:08:44 * ski would actually have preferred to define `newtype Test = MkTest (String -> Maybe Integer)', in order to not as easily confuse the data constructor `MkTest' with its associated type (constructor) `Test'
11:09:10 <erisco> but this may be a Sheldon-like thing to bring up
11:09:20 <erisco> "What is physics?"
11:10:31 <ski> Fairy : if anything is unclear, please say so, e.g. asking
11:10:47 <ski> (or perhaps you're thinking things over, which is also fine)
11:11:00 <erisco> why the newtype though
11:11:13 * ski doesn't know
11:13:02 <Fairy> ski: give me a min please, it makes sense that  f  is just a function that takes String and returns Maybe Integer, but I can't seem to be able to make that function :s
11:13:28 <erisco> newtypes select type class instances. If you have a data type which incidentally has one constructor with one component then you might also choose newtype for some runtime performance benefit
11:14:25 <ski> Fairy : it's not "that function"
11:14:45 <ski> Fairy : each value of type `Test' will contain a (possibly) different function of type `String -> Maybe Integer'
11:14:47 <Fairy> sorry, a function* like that
11:15:09 <ski> you can define many such functions, and call e.g. `doTest' many times, each time with a different one packaged inside a `Test' value
11:15:30 <erisco> :t undefined :: String -> Maybe Integer -- erisco ducks
11:15:32 <lambdabot> String -> Maybe Integer
11:15:38 <ski> so, instead of the *explicitly* higher-order
11:15:48 <ski>   doTest :: (String -> Maybe Integer) -> Bool
11:15:51 <ph88> i heard refactering should be a breeze in haskell .. when i change one thing the whole type system blows up
11:15:56 <ski> we have the *implicit*
11:16:00 <ski>   doTest :: Test -> Bool
11:16:14 <erisco> ph88, yeah, that is a good thing
11:16:27 <ski> where the input function (aka callback) of type `String -> Maybe Integer' is "hidden" inside the input of type `Test'
11:16:52 <ph88> the errors are not even on the line where i changed stuff
11:17:05 <erisco> ph88, a reason refactoring in Haskell is easier is because of purity
11:17:14 <geekosaur> that's actually the point. it tells you what else needs to be changed to get the types back in line
11:17:16 <ongy> ph88: they should be at a usesite of what you changed
11:17:21 <erisco> which means that if you refactor with something functionally equivalent it necessarily still works
11:17:26 <ski> ph88 : the type system will (often) keep track of when and where you also need to change other things, to accomodate the change you started with. this is good as erisco says
11:18:27 <ph88> not sure how it's good because i don't really understand what's going on :/
11:18:38 * ski looks at Fairy
11:19:34 <ph88> i had a function    foo = \x -> someStuff x == someOtherStuff x    .. so it would yield a Bool right?  so i replace it with   foo -> \_ -> True  .. and errors all over
11:19:38 * Fairy looks timidly at the floor.
11:20:02 <ski> no need to be shy. we've all been beginners :)
11:20:06 <erisco> who installed this intimidating floor? outright oppression this is!
11:21:08 <erisco> ph88,  what is  foo -> … ?
11:21:34 <ski> Fairy : did the last remarks i made above make sense ?
11:21:38 <ph88> it was a type i replace it with    foo = \_ -> True
11:21:40 <ph88> typo
11:21:43 <ph88> omg
11:22:15 <erisco> well I had to make sure that wasn't the problem first, didn't I?
11:22:19 <ski> Fairy : do you have an idea in which "area" you're still a bit unsure ? perhaps about how to actually use this for solving some problem ?
11:22:59 <ph88> i just said omg cuz i made a typo in "typo" oh the irony
11:23:37 * ski figures ph88 is so used to typing `type', that it naturally came out that way
11:23:45 <Fairy> ski: I've been constantly trying to "print" the results to the screen (literally ANY result) to no avail, until I suddenly realized that the datatype doesn't derive Show
11:24:00 <ski> Fairy : yes. and it can't
11:24:09 <ski> Fairy : functions can't be `show'n
11:24:15 <ski> (in general at least)
11:24:26 <erisco> ph88, it is possibly due to inference, as the function you replaced it with is less constrained. Can you pastebin the errors?
11:24:31 <erisco> or lpaste them, rather
11:24:42 <ski> Fairy : however. you *can* print the results of *using* a `Test' together with some `String'
11:25:40 <ski> .. the only way one can "inspect" a function, is to try and feed it some input, and see what output it produces
11:26:09 <ski> if you don't know "who defined it", where it's defined, then it's a "black box"
11:26:14 <ph88> erisco, https://paste.fedoraproject.org/445738/75864744/
11:26:32 <ski> if you know where it's defined. then you can try to read the definition, and see whether it makes sense
11:26:45 <erisco> yup, ambiguity errors, it is because it is less constrained
11:26:55 <ski> but in any case, you can't make the program "read the definition" of a function, while it's running
11:27:01 <EvanR> erisco: i was referring to seventeenth century alchemists or whoever named them that
11:27:08 <ph88> erisco, how can i put the constraint ?
11:27:15 <erisco> so what you need to do is to add in a type annotation
11:27:35 <ski> .. if you get a function as input, then really, the only way you can figure out something about it, is by calling it
11:27:41 <erisco> EvanR, what was their reason?
11:28:07 <EvanR> hell if i know, but it oughtta be a cool topic for research followed by a presentation
11:28:12 <EvanR> at a functional programming meetup
11:28:19 <ski> e.g., if someone gave you the `not :: Bool -> Bool' as input, then you could try feeding it `False', and get `True' in response. and also try feeding it `True' and get `False' in response
11:28:31 <ski> and then you could realize that this was the `not' function
11:28:35 <erisco> ph88, whatever the type of x was, call it T, then you need to annotate  foo :: T -> Bool
11:28:52 <ski> but in general, there's too many (even infinitely many) possibly inputs for a function, to be able to do that
11:29:19 <ph88> erisco, i try this   parser_prop :: (P.Pretty a, Arbitrary a, Show a, Data a, Eq a) => a -> Bool
11:29:41 <ski> Fairy : if you don't understand all of that right now, don't worry .. i just attempted to give some background as to *why* functions aren't `Show'able
11:30:17 <erisco> ph88, what was the result of that?
11:30:56 <ph88> erisco, https://paste.fedoraproject.org/445741/75865028/
11:31:12 <erisco> right, I didn't think that would fix the problem
11:31:21 <erisco> it isn't going to solve an ambiguity
11:31:27 <shapr> ski: would be neat to have a Show instance for QuickSpec 
11:31:42 <ph88> erisco, why not ?
11:31:46 <erisco> what is the type of someStuff and someOtherStuff ?
11:32:10 <ph88> not sure, how can i find out ?
11:32:13 <erisco> ph88, the problem is that there is more than one possible instance to choose. Merely annotating the constraint isn't going to choose the instance
11:32:31 <ski> shapr : does that contain functions ?
11:32:46 <ski> shapr : shallow embedding ?
11:32:47 <sldkfjsldk161007> @pl (\x-> (x,x))
11:32:47 <lambdabot> join (,)
11:32:48 * hackagebot hjsonpointer 1.0.0.1 - JSON Pointer library  https://hackage.haskell.org/package/hjsonpointer-1.0.0.1 (seagreen)
11:33:05 <erisco> ph88, well the way I figure it out is to load it in ghci and ask with :t
11:33:06 <begriffs> Is there a package to generate an OS-dependent path for a configuration file? For instance in Linux it would suggest /etcc/myprogram.conf but in windows it would suggest whatever the convention is there?
11:33:37 <erisco> or you can work it out in your head
11:33:42 <begriffs> Closest thing I've seen is xdg-basedir but that's for per user config files.
11:33:43 <ph88> erisco, well i couldn't because it was not a function on the toplevel .. but i was able to work around it and for someStuff i got   Data b => b -> Either a b
11:33:44 <shapr> ski: no, but still might be interesting: https://hackage.haskell.org/package/quickspec
11:34:00 <erisco> what is someOtherStuff ?
11:34:34 <erisco> if it isn't a TLD then I just copy it to the top level
11:34:47 <erisco> or copy & paste into the REPL
11:35:56 <ski> Fairy : if you want to, you could show your current code to us, e.g. using a paste site like
11:35:59 <ski> @paste
11:35:59 <lambdabot> Haskell pastebin: http://lpaste.net/
11:36:02 <ph88> erisco, someOtherStuff :: (P.Pretty a, Data a) =>     a -> Either (M.ParseError Char M.Dec) ContextClause
11:37:06 <ph88> but that is only because i choose contextClause ... i could choose another parser there ^^
11:37:49 <Phyx-> begriffs: filepath should have what you need. it has operators to manipulate paths so it always produces one correct for the platform
11:39:51 <Fairy> ski: Well, I'm not actually coding anything really - just looking through various code and trying to understand what's happening. Right now my code looks like this:  newtype Test = Test (String -> Maybe Integer);   doTest :: Test -> String -> Maybe Integer;  doTest (Test f) a = f a
11:39:52 <erisco> that is strange to me, I don't have a hypothesis for what is causing the problem
11:40:05 <ph88> alright ^^
11:40:17 <ph88> i was just trying this to debug the original problem anyway
11:40:24 <ph88> i guess i will have to think of something else
11:40:33 <erisco> but you can enable ScopedTypeVariables and add in forall. as appropriate
11:40:45 <ongy> Fairy: I would recommend trying them out in ghci, to get a bit of a feeling for it
11:40:46 <erisco> that will fix your annotation, likely, and may resolve the issue
11:41:00 <ski> Fairy : yes. .. and that `doTest' doesn't really explain much about why you'd want to do something like this
11:41:12 <ph88> erisco, not sure what the notation on forall should be
11:41:34 <ski> Fairy : where did you get the declaration `newtype Test = Test (String -> Maybe Integer)' from ? did you invent it yourself, or read it somewhere ?
11:41:55 <begriffs> Phyx-: thanks. That plus conditional compilation should maybe do the trick -  #ifndef mingw32_HOST_OS
11:41:56 <erisco> it might be something to do with the type class hierarchy, and someStuff and someOtherStuff constrained sufficiently for a unique instance
11:42:07 <erisco> that is tough to see without the complete picture
11:42:27 <Phyx-> begriffs: you shouldn't need that. the library already abstracts away playform differences.
11:42:29 <erisco> ph88 you annotate on the TLD
11:42:35 <ph88> TLD ?
11:42:42 <erisco> top-level definition/declaration
11:42:48 <javjarfer> Anyone knows the meaning of "un-decorated" in the context of a polymorphic kind?
11:43:20 <erisco> so  foo :: forall a. F a -> B a   or whatever have you
11:43:24 <begriffs> Phyx-: except I'll need to use different names for directories themselves, not just their path separators. Like one would be `etc/foo.conf` the other would be `Local Preferences\foo\foo.conf` or something.
11:43:32 <erisco> this captures the variable for use in scope of the definition
11:43:33 <ph88> no =>  ??
11:43:53 * ski imagines javjarfer might mean "polymorphic type", like `Typeable :: forall k. k -> Constraint'
11:43:58 <erisco> the double arrow is for conjoining constraints with types, it is something else
11:44:09 <Fairy> I'm not aiming to use it within any context, it's just something I saw somewhere online when I was first getting into Haskell so I wrote it down, it looked weird so I copied it down - and now I'm trying to understand it
11:44:59 <geekosaur> ski, the reference I find is for polykinds
11:45:01 <ph88> erisco, right now the top-level type annotation looks like this:    qcrp :: (P.Pretty a, Arbitrary a, Show a, Data a, Eq a) => M.ParsecT M.Dec Data.Text.Internal.Text Data.Functor.Identity.Identity a -> Maybe (String, Int) -> IO ()
11:45:02 <Phyx-> begriffs: doesn't the directory package cover your needs then? https://hackage.haskell.org/package/directory-1.2.7.0/docs/System-Directory.html if you want to store them in standard location
11:45:06 <ski> Fairy : one somewhat similar thing that one could use could be `newtype Parser a = MkParser (String -> Maybe a)'
11:45:52 <Fairy> It was used in some Calculator written in Haskell (original name was  newtype Mem = Mem (String -> Maybe Integer), but that's just a different name for the same thing )
11:46:22 <ski> Fairy : a value of type `Parser a' would contain a function that could be used for attempting to interpret a `String' as a text representation of an `a' value, and in that case, the function will return `Just' that value, otherwise `Nothing'
11:46:24 <erisco> ph88, so you write  qcrp :: forall a. …
11:46:31 <ph88> alright
11:46:45 <erisco> and make sure you have the ScopedTypeVariables extension turned on
11:46:54 <javjarfer> geekosaur, you are right I was talking about polykinds
11:46:55 <ph88> got it
11:47:02 <geekosaur> but onlu pre-8.0, where TypeInType chanegd things
11:47:25 <erisco> geekosaur, is that @me?
11:47:40 <ph88> that worked !
11:47:43 <ph88> thanks erisco 
11:47:45 <ski> Fairy : e.g. one could have `integerLiteral :: Parser Integer', so that if we apply the function inside to the string `"-23"', we get `Just' the `Integer' `-23', apply it to a bogus `String' like `"not a number"', we get `Nothing'
11:48:05 <geekosaur> no, it was the discussion I was already in (ski / javjarfer)
11:48:26 <geekosaur> javjarfer, an undecorated kind is where you did not explicitly declare a polykind and one is inferred
11:48:31 <JonReed> Fairy: Here is a code that you can play with if you want to understand newtypes and functions and what it's doing: http://lpaste.net/246912
11:48:42 <JonReed> Fairy: It should compile
11:48:53 * ph88 throws erisco a mandarin orange
11:48:59 <JonReed> Fairy: You can load it in ghci
11:49:08 <ski> Fairy : your `newtype Mem = Mem (String -> Maybe Integer)' sounds like a "variable lookup", a "dictionary" if you will, that for some strings (variable names), will return `Just' the corresponding `Integer' stored in the `Mem'ory. otherwise `Nothing', in case no such variable exists in your `Mem'ory
11:49:21 <ski> Fairy : it could e.g. be used for interpreting a simple programming language
11:49:39 <erisco> ph88, the reason is that the "a" in qcrp is not the same as the "a" in parser_prop, not without ScopedTypeVariables
11:49:41 <JonReed> Fairy:  Or you can just play with it and modify things to see what compiles and what doesn't. Right now it should compile. 
11:49:42 <ski> Fairy : does that make any sense at all, or is it just gobbledygood to you, at this point ?
11:50:09 <geekosaur> javjarfer, https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/kind-polymorphism.html#idp24312304 (it's not in the current manual because TypeInType changed the rules)
11:50:15 * ski always thought `PolyKinds' was a misnomer
11:50:19 <ph88> erisco, yes i used ScopedTypeVariables before ... just i didn't know it would be a solution in this case ^^
11:50:32 <jle`> in my .prof files, i see the function "foo", and then the next line, "foo.\"
11:50:40 <jle`> what is the difference here?  what does the \ signify?
11:50:46 <erisco> my assumption is that one of "P.Pretty a" or "Data a" has constrained "a" to a unique Show instance
11:50:46 <jle`> maybe pattern matching/case statement?
11:51:25 <erisco> possibly "P.Pretty a" has done that
11:51:43 <ski> Fairy : oh, you already said it was a calculator. it slipped my mind
11:52:12 <javjarfer> geekosaur, wow, such a little descriptive name for that, thanks you, I'm going to read the link
11:52:44 <ph88> erisco, do you have any tips on figuring out why someStuff yield something different than someOtherStuff ?
11:53:01 <javjarfer> geekosaur, okay, I have read that link before, but thanks you for the clarification
11:53:16 <erisco> ph88, yield what? are we talking types or values? and I don't know the definitions of someStuff or someOtherStuff
11:53:49 <ph88> erisco, value .. they should be of the same type no? i mean i compare them using ==
11:54:19 <erisco> well they have to unify to the same type, but that does not mean they need the same type form (i.e. type with variables)
11:54:41 <geekosaur> jle`, it's a lambda somewhere in foo's definition
11:55:09 <geekosaur> since it's anonymous by definition, it can't be given a name (and probably gets all such lambdas)
11:55:13 <ph88> erisco, it's' about line 33 in this paste  https://paste.fedoraproject.org/445111/14757796/
11:55:28 <ph88> i replaced that now by   parser_prop = \_ -> True
11:55:42 <ph88> and quickCheck test succeeds
11:57:57 * ski blinks
11:58:01 <erisco> I am not familiar with quickcheck but I do know it is not exhaustive. It is unit testing with some automated intelligence
11:58:26 <danza> hey all, can anyone give me a quick answer about variadic functions in Haskell: yes or no? I've got a feeling that it's a no. The solutions i find look like hacks. Okay there is printf, but it involves IO. Any way to have a pure variadic function?
11:58:44 <ph88> that's ok .. it doesn't need to be exhaustive .. it just provides a possible value   x
11:58:59 <erisco> danza, Haskell does not have variadic functions, no. In fact, all functions have one argument.
11:59:12 <monochrom> printf is also pure without IO
11:59:19 <erisco> ph88, well if it is not exhaustive then it may fail to find such an x even if it exists
11:59:35 <hpc> quickcheck's magic comes from the shrink function, https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#v:shrink
11:59:45 <ph88> erisco, it should yield True for any x otherwise the mistake is on my part
11:59:54 <monochrom> > printf "%d" (5 :: Int) :: String
11:59:55 <hpc> which is basically "given a test case, make a list of related test cases"
11:59:56 <lambdabot>  "5"
11:59:58 <monochrom> no IO
12:00:05 <erisco> ph88, I would start up ghci and begin playing with each part until I find one which is not behaving how I expect
12:00:14 <erisco> ph88, it would also be helpful to know which 'x' it is failing on
12:00:24 <ph88> all of them so far ^^
12:00:41 <ph88> for example this one on line 1   https://paste.fedoraproject.org/445115/79805147/
12:00:42 <erisco> well then quickcheck has really failed you oO
12:01:12 <erisco> yes, well, I would go through each step one at a time with ghci
12:01:17 <danza> monochrom, the printf doc says "Format a variable number of arguments with the C-style formatting string. The return value is either String or (IO a) (which should be (IO '()'), but Haskell's type system makes this hard)."
12:01:22 <erisco> transformIn, then printSource, then T.toStrict, and so on
12:01:28 <erisco> with a small x so it is easy to keep track of
12:01:50 <erisco> if it is failing on lots of x's then it is probably easy to see where it goes wrong
12:02:02 <ongy> danza: it can also be IO, but that's for convenience.
12:02:05 <ski> > let x = "x = %s" in printf x (show x) :: String  -- using `printf' without `IO'
12:02:07 <lambdabot>  "x = \"x = %s\""
12:02:57 <ongy> I have some old code somewhere that did variadic arguments, but I don't think that's really nice. The combinator way formatting does feels better (in contrast to printf)
12:02:59 <danza> ongy, monochrom but then how does it works? It seems to involve some tricks with the typeclasses ... my intuition is that dependent types would be needed
12:03:16 <monochrom> it plays with type classes.
12:04:17 <danza> i mean ... it seems to me that Haskell is designed to avoid these cases ... in general you want to be notified when the number of arguments is not the expected one
12:04:38 <ski> > printf "" "" :: String
12:04:40 <lambdabot>  "*Exception: printf: formatting string ended prematurely
12:04:45 <ski> > printf "%s" :: String
12:04:47 <lambdabot>  "*Exception: printf: argument list ended prematurely
12:05:09 <erisco>  > [10,10,10].map(Number.parseInt)
12:05:14 <erisco> [10, NaN, 2]
12:05:21 <ski> (so it does dynamic checking (of the format string), at run-time (obviously ?)
12:05:50 <danza> there is no other way, since it's a string
12:05:53 <ski> )
12:05:56 <ski> yes
12:06:07 <ski> other approaches involves not using a string
12:06:10 <monochrom> You should simply read its source code instead of writing an essay on what you think. Read a very old version, it's much simpler and more to the point than today's version (more complex for extensibility)
12:06:15 <ski> you can do that, without dependent types
12:06:55 <danza> i just don't want to force this if it's not idiomatic
12:07:48 <erisco> it is a neat trick, but little more
12:10:03 <mizu_no_oto_work> danza: out of curiosity, have you seen http://okmij.org/ftp/Haskell/polyvariadic.html ?
12:10:03 <erisco> you can printf with TH if you're so inclined
12:10:24 <danza> no i'd like to avoid code generation
12:10:32 <monochrom> the Haskell community is diverse. you willl not find an unanimous voice "it is idiomatic" or "it is not idiomatic".
12:10:35 <erisco> I do not recommend compiling then
12:11:00 <monochrom> instead you will find one third who say "it is perfectly legit", one third who say "it is evil", and one third who say "I am not religious".
12:11:08 <monochrom> and I belong to the third group.
12:11:21 <danza> mizu_no_oto_work, yes, but it was not clear and i thought that it was an hack
12:11:45 <erisco> instead of "it is evil" I say it is the wrong thing to clamour after
12:11:50 <monochrom> what you should do is you find out how it is done and then make your own judgment.
12:12:21 <danza> okay ... you say that it can be done purely, this is already a good hint for me
12:12:59 <mizu_no_oto_work> I think that the combinator approach is often a bit cleaner
12:13:17 <erisco> I am hearing the story of being new to Haskell and trying to replicate the usual ways of doing things, which is a mistake
12:13:45 <danza> exactly that is what i wanted to avoid
12:13:53 <monochrom> I have a feeling that the Haskell people value independent critical thinking a bit more than herd thinking.
12:14:12 <danza> sometimes people show what can be done in Haskell just for the sake of showing the paradoxes in it but i just want to learn how to play with the language trying to follow its design
12:14:21 <monochrom> I for one certain hold the stance "screw what other people think. what do you think?"
12:15:02 <erisco> I don't mind people sharing their opinion so long as they're not also withholding the information I am seeking
12:15:23 * ski . o O ( "well, i think : but what do you *really* think ?" )
12:15:41 <erisco> seeing as we've given danza the references of how to emulate variadic functions, isn't it then prudent to share that this is unusual and probably unhelpful?
12:16:15 * ski is mostly in favor of handing people some rope, while explaining why they shouldn't use it to hang themselves by
12:17:16 <ski> (assuming a reasonable level of judgement available on their side)
12:18:07 <dmiles> i am combining the codebase of EclipseFP and ghcvm (runs all on JVM)
12:18:16 <erisco> giving means without wisdom is reckless, and giving wisdom without means is helpless
12:18:41 <mizu_no_oto_work> danza: is there a particular problem you're trying to solve?
12:18:46 <monochrom> how do you know that you are giving wisdom, not anti-wisdom?
12:18:55 <erisco> you mean cowisdom?
12:19:11 <danza> so what is the wisdom, here? If the type system plays nicely with this, i see no danger
12:19:29 <ph88> erisco, thanks again, i was stuck on this for days !
12:19:32 * hackagebot Glob 0.7.12 - Globbing library  https://hackage.haskell.org/package/Glob-0.7.12 (MattiNiemenmaa)
12:19:32 * hackagebot hjsonpointer 1.0.0.1 - JSON Pointer library  https://hackage.haskell.org/package/hjsonpointer-1.0.0.1 (seagreen)
12:19:49 <dmiles> so that a person can write and debug their Haskell .. i've never written a line of Haskell in my life :)
12:20:13 <ski> danza : dynamic checking that format corresponds to the inferred signature
12:20:26 <danza> mizu_no_oto_work, i wanted to write a function for formatting things where i can use existing symbols, like in `format "this " value " is " result `
12:20:27 <joncol_> Could someone take a look at https://gist.github.com/joncol/d0d418d412c5216c3eb8baef60e48334 ? I'm thinking there must be a nicer way of applying functions that are within the reader monad? Like what I'm doing on line #10 and #17...? Can I use lift here?
12:20:29 <ski> hiya dmiles
12:21:16 <danza> ski, ugh ... i knew there was some similar catch ... so it *is* about tricking the type system
12:21:46 <dmiles> ski: hi!  i am hoping having  CYC+LISP+Prolog+Haskell all inb the same runtime will inspitre me to learn Haskell
12:21:51 <ski> danza : more like side-stepping, i suppose
12:22:04 * ski smiles
12:22:37 <neochronomo> How do you type a negative number into Haskell? Everytime I type something like -6 I get the error: "Non type-variable argument in the constraint: Num (a -> a)"
12:22:46 <dmiles> though i also want OCaml in there to afte ri complete the Haskell bits
12:22:46 <joncol_> (-6)
12:22:53 <ski> > 2 * (-6)
12:22:55 <lambdabot>  -12
12:22:57 <monochrom> > -6
12:22:59 <lambdabot>  -6
12:23:01 <neochronomo> joncol_: oh you have to use parentheses?
12:23:08 <monochrom> not everytime for me
12:23:09 <ski> neochronomo : depends on the context
12:23:14 <joncol_> neochronomo: yeah!
12:23:33 <monochrom> > 2 * -6
12:23:34 <joncol_> If the negative number is first in an expression it's ok without.
12:23:35 <lambdabot>  error:
12:23:36 <lambdabot>      Precedence parsing error
12:23:36 <lambdabot>          cannot mix ‘*’ [infixl 7] and prefix `-' [infixl 6] in the same infi...
12:23:39 <neochronomo> I'm using it as an argument to the abs function
12:23:43 <monochrom> ah this one needs parens
12:23:51 <joncol_> -6 * 2
12:23:57 <joncol_> > -6 * 2
12:23:59 <lambdabot>  -12
12:24:08 <monochrom> abs (-6) needs parens
12:24:16 <dmiles> back in a bit
12:24:25 <joncol_> > abs $ -6
12:24:27 <lambdabot>  6
12:24:29 <erisco> danza, there is no danger. The advice is that you do not cling to variadic functions, as you may have in JavaScript or PHP or some language like this
12:24:30 <neochronomo> Thanks, all
12:24:31 <ski> neochronomo : `abs -6' means "subtract `6' from `abs'", which doesn't make sense, type-wise
12:24:39 <monochrom> "abs -6" would mean "abs - 6" like "x - y"
12:24:56 <danza> erisco, Lisp?
12:25:04 <erisco> danza, sure, I haven't used it myself
12:25:20 <neochronomo> ski: right, that makes sense. It's different from other languages I'm more familiar with that would be able to tell the difference
12:25:20 * ski . o O ( Scheme )
12:25:21 <monochrom> eventually you will have to develop a sense of tokenization that does not always rely on space. space is not the only way to separate tokens
12:25:35 <danza> alright, i will use operators to achieve a clean syntax anyway. Thanks everybody for the support! :)
12:25:47 <ski> danza : passing a list often works
12:26:03 <danza> i wanted something cleaner :)
12:26:10 <ReinH> And also an understanding of obtuse error messages involving Num.
12:26:17 <ski> > maximum [2,5,3]
12:26:20 <lambdabot>  5
12:26:34 <erisco> foiled?
12:27:22 <mizu_no_oto_work> danza: Out of curiosity, have you seen Applicatives?  With applicative style, you use operators with fixed arity to provide one argument at a time to something that expects n arguments.
12:27:37 <erisco> mizu_no_oto_work++
12:27:52 <erisco> whatever you were doing with variadic arguments is probably an Applicative
12:28:00 <mizu_no_oto_work> > (+) <$> ZipList [1,2,3] <*> [4,5,6]
12:28:02 <lambdabot>  error:
12:28:03 <lambdabot>      • Couldn't match type ‘[]’ with ‘ZipList’
12:28:03 <lambdabot>        Expected type: ZipList b
12:28:09 <mizu_no_oto_work> > (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
12:28:11 <lambdabot>  ZipList {getZipList = [5,7,9]}
12:28:55 * ski isn't sure how mizu_no_oto_work meant
12:28:56 <erisco> Applicative is syntactically painful to use in many languages and so you may not have seen it
12:29:05 <danza> mizu_no_oto_work, erisco i don't see the connection
12:30:09 <danza> what i want to achieve is a function `format "your " operation " yielded result " result` ... i see how to do this with a list, but it looks ugly. I don't see how Applicative would help
12:30:46 <danza> `format` is the function i want to write ... which accepts a variable number of showable parameters
12:31:25 <erisco> it may not apply to your problem, it is not equivalent
12:31:38 <hexagoxel> joncol_: try using type `a -> m b` instead of `m (a->b)`. I think it will remove some overhead.
12:31:40 <erisco> like a list, it just satisfies some use cases of variadic functions
12:31:46 <mizu_no_oto_work> I'm not sure that Applicative is what you want in this case, exactly, but it's a useful thing to be aware of in general for variadic functions
12:31:53 <monochrom> you know, erisco asked for my wisdom, so here it is: I disbelieve in polyvariadicity and string interpolation ("format strings"). At least when in Haskell.
12:31:59 <joncol_> hexagoxel: Yeah, I Just Realized! Thanks!
12:32:07 <ReinH> What is the relationship between Applicative and variadic functions?
12:32:16 <danza> okay thanks everybody for the support, you were very helpful!
12:32:20 * ski is also wondering ..
12:32:52 <ReinH> danza: imo the best advice for variadic functions in Haskell is "instead of wanting to do that, try wanting to do something else instead."
12:33:23 <monochrom> For formatted output, I first try elementary code like: "You have " ++ show m ++ " dollars left".
12:33:34 <danza> yeah i wanted to improve on that
12:33:53 <danza> i guess that i will go for a single character operator
12:34:04 <ReinH> @hackage formatting
12:34:04 <lambdabot> http://hackage.haskell.org/package/formatting
12:34:06 <monochrom> After a while if that is too boring, I may try pretty-printing combinators.
12:34:07 <mizu_no_oto_work> ReinH: You can replace e.g. zipWith, zipWith2, zipWith3, etc. with the ZipList applicative.
12:34:24 <ski> > concat ["You have ",show (let m = 14 in m)," dollars left"]
12:34:26 <lambdabot>  "You have 14 dollars left"
12:34:27 * hackagebot haskell-gi-base 0.19 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.19 (inaki)
12:34:29 * hackagebot hylolib 1.5.2 - Tools for hybrid logics related programs  https://hackage.haskell.org/package/hylolib-1.5.2 (GuillaumeHoffmann)
12:35:01 <ski> mizu_no_oto_work : oh, for that particular family, yes
12:36:22 <ReinH> @hackage formatting
12:36:22 <lambdabot> http://hackage.haskell.org/package/formatting
12:36:35 <erisco> unfortunately, due to syntax, you're probably better with zipWith2, zipWith3, and so-forth in some other languages
12:36:59 <ReinH> That is both true and not relevant.
12:37:20 <erisco> we were relating with other languages, so it is somewhat relevant
12:37:24 <monochrom> yeah, the formatting package shows you another elegant approach
12:37:40 <ReinH> Sorry, I'm having irc problems.
12:38:01 <monochrom> Relevance is why I always withold information.
12:38:05 <mizu_no_oto_work> Looks like a lot of people are
12:38:25 <erisco> never told a partial truth? ;)
12:38:35 <monochrom> Actually that's just half of why. The other half is I don't have the technology to upload all of my brain.
12:38:48 <monochrom> I always tell partial truths.
12:38:51 <ReinH> The arity of the function used with Applicative isn't variable.
12:39:03 <ReinH> You can use applicative with functions of different arity, but that isn't the same thing.
12:39:54 <monochrom> Case in point: Just earlier today someone asked for an exec() in System.*. I answered simply, after some consideration, "System.Posix".
12:39:55 <ongy> there was a global notice about server cleanups and some reboots on freenode
12:40:23 <sssilver> Hey guys, I'm about to start an isometric 2D game project that uses sprites and runs inside of a browser, rendering on canvas. And I'm about to write it in ghcjs. The reason is that I already know some Haskell, and I don't really like Javascript. Should I go with Purescript instead? What will be the caveats? Will this have rendering performance implications? Does anyone know anything about this in this channel?
12:40:30 <monochrom> That is, I did not, despite your wish, lecture them on how they might not need exec() and they might benefit more from System.Process
12:41:22 <neochronomo> I literally just began learning Haskell and functional programming yesterday. My background is mostly in object oriented programming. Can functional programming be used to write any program I've written in OOP? Is that what I'll ultimately find out is another way of doing the same thing?
12:41:29 <erisco> sssilver, when I used ghcjs, and this was 3 years ago or so, there were scant bindings, so I would be particularly interested in what webgl bindings are available, if any
12:41:47 <erisco> sssilver, or if you are just using the canvas draw API, then what bindings there are for that
12:42:05 <erisco> have you seen Elm?
12:42:15 <sssilver> neochronomo short answer is -- yes
12:42:28 <mizu_no_oto_work> ReinH: it's an example of replacing what you might achieve with a variadic operator in other languages, using operators with fixed arity and polymorphism.
12:42:37 <sssilver> neochronomo but the way you frame that question seems to underplay the significance of learning that other way of doing the same thing
12:42:52 <sssilver> it's significant to an extent where it'll no longer really be the "same thing" in a metaphysical sense
12:43:00 <erisco> neochronomo, not exactly the same programs, no, but in effect, yes. I say this because there are different ways of constructing things in functional programming
12:43:03 <monochrom> neochronomo: If I use Haskell to write an interpreter of your OOP language, does that count as writing your OOP program in a functional language?
12:43:08 <sssilver> it'll be a different thing that achieves the same functional effect
12:43:18 <erisco> monochrom the reductionist
12:43:38 <sssilver> erisco I haven't seen elm, why do you ask?
12:43:47 <neochronomo> sssilver: sorry I didn't mean that at all. I meant would I be learning a new way of doing what I have been with added advantages and/or new ideas that could make things better in certain contexts. Didn't mean to downplay haskell or functional programming at all
12:44:05 <mizu_no_oto_work> neochronomo: Essentially all programming languages are Turing Complete, which means that they can all compute the same set of things.
12:44:17 <sssilver> neochronomo you wouldn't be learning a new way of doing what you've been doing. You'll be learning a new way of doing what you haven't been doing :)
12:44:18 <erisco> sssilver, worth a look then, there are game examples http://elm-lang.org/
12:44:47 <monochrom> But yes you will be learning new thinking.
12:45:29 <monochrom> Some OOP programs do not have nice translations to Haskell. (But not all.)
12:45:33 <neochronomo> I apologize for any negative language I may be unintentionally using. I don't understand the importance of FP yet or how it even works since I literally began yesterday. I was just trying to get a feel for where I maybe headed
12:45:39 <erisco> kloeri is soon to invoke the CD tray eject program
12:45:52 <monochrom> Don't worry, I don't think anyone takes you negatively.
12:46:01 <dfeuer> I sent out a message to the libraries list a couple days ago about the semantics of reading integers, but nobody responded :-(
12:46:05 <mizu_no_oto_work> neochromono: if by "Can functional programming be used to write any program I've written in OOP?" you mean "Is there a Haskell program that outputs the same thing as any Java program I can write", the answer is "yes".  The mechanics of it will be rather different, though.
12:46:12 <kloeri> erisco: haha
12:46:15 <dfeuer> Perhaps no one cares.
12:46:26 <erisco> neochronomo, http://www.randomhouse.com/teachers/wp-content/uploads/2013/05/978-0-679-80527-4.jpg
12:46:32 <EvanR> monochrom: are you trying to say that not all OOP programs dont have a nice translation to haskell
12:46:41 <EvanR> i like it
12:46:48 <neochronomo> erisco: haha
12:46:58 <ski> neochronomo : if you haven't seen FP before, it may help to pretend you're learning programming from scratch all over again. of course many things do carry other, but it's better to try to not suppose and compare with other things, until after you've learned some basics, at least
12:47:03 <sssilver> erisco so Elm transpiles to JS as well?
12:47:05 <monochrom> dfeuer: Instead, I think there is a possibility that no one finds a refutation to your message. :)
12:47:12 <dfeuer> > reads "123e-" :: [(Integer, String)]
12:47:15 <lambdabot>  [(123,"e-")]
12:47:16 <dfeuer> > reads "123e-3" :: [(Integer, String)]
12:47:19 <lambdabot>  []
12:47:33 <erisco> sssilver, afaik the only compiler is for JS, it is web oriented
12:47:41 <dfeuer> monochrom, well, I would hope that in that case they'd respond to support such a change....
12:47:52 <ski> > (reads :: ReadS Double) "123e-3"
12:47:54 <lambdabot>  [(0.123,"")]
12:48:09 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
12:48:09 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
12:48:09 --- names: list (clog_ scopedTV JackMc caw bluepixel Bengi_ PotatoGim MorTal1ty OliPicard lancetw NemesisD beckyconning_ sephiap zero7 jlyndon stephe shennyg cstrahan_ CARAM__ biglama ggherdov jbiesnecker irrequietus jfokkan__ avdi lanodan trism Sorella loopspace SeriousBug[m] rfw ristos thoughtpolice jorendorff_ lexi-lambda mindos_cloud____ solatis ManiacTwister meta-coder dunj3 codebam fall_ brian[m] killerpty abbe chrzyki Natch cjwelborn otterdam Guest89002 Baughn joeyh)
12:48:09 --- names: list (umib0zu spion maerwald xacktm caconym ricardo82 pdxleif flonk PlasmaStar minsky bydo AutoMonkey01 octo_ abh augur sag3 yamadapc gnusosa Klumben frug72 Ankhers vikraman jrpls nshepperd_ xtal LuckyRawApe greymalkin borkdude a3Dman redmq jgornick ephemeron acfoltzer iross Dunearhp zariuq infinity0 nont_ cantstanya ziocroc Coldblackice kolko t0mb0_ Kuros grantwu BlueRavenGT SegFaultAX zxtx sparr cgfbee aloiscochard ali_bush torgdor gsingh93 intelux qryantm)
12:48:09 --- names: list (miklcct staffehn schjetne sivs sea-gull Qommand0r rbocquet _flow_ troydm wedens xinming mauke zipper eronel Athas hegge cjh` hex0punk1 sbjorn voorhies Guest71655 kolmodin robtaylor Cale ph88 rotty kamog MasseR Deadhandd liyang shymega stelleg ocramz m1dnight_ pikhq cdsmith_ s4msung ahihi eatonphil wting CurryWurst robogoat chelfi rossberg qinusty ortmage_ o`connor hongminhee bengt_ ar53nic irishsultan siklsten divVerent heurist descender cereal_killer_ ploop)
12:48:09 --- names: list (kaol carado Nahra valdyn keko-2 pikajude juhp taksuyu Khisanth pfoetchen lordcirth xnyhps Quintasan siddhu Moto-chan dhil vili_ armyriad sqrt2_ cocreature integral phaazon kav mk-fg tessier robin madbub Neo atk mrBen2k2k2k kantokomi jbalint lispy knack petercom1and catsup_ _Shandy theDon runawayfive marienz icedev rcschm wizonesolutions alanz chbatey alphonse23_ dwarders spicydonuts ocharles_ mada bgyss Tinchos pchiusano goldfire iphy BartAdv adulteratedjedi)
12:48:09 --- names: list (reem PennyNeko S11001001 zpconn__________ sa1 kipd vandenoever solidsnack rlr Tritlo ajmccluskey mvr_ etcinit dgonyeo xplat|work joncol_ phoenix___ sssilver mpw Guest39_ PhsShft adelbertc afcondon NickSeagull mankyKitty monad_cat GGMethos_ wyvern SuperTux88 phuu banjiewen lucz jmct raid iomonad madknight cYmen osa1__ mkurkov Noldorin notdan mno2 marr neochronomo fcpga_te lpaste Factionwars cyberlard vapid brezel wolfcore chris2 Guest49116 Jaxan mt beaky)
12:48:09 --- names: list (w4and0er96 johnw mizu_no_oto_work Askanison marmalodak cbaines_ greenbagels trevorriles sohum teppic TimWolla valkyr2e danthemyth SlashLife drewbert nyazdani tristanp moei fyolnish kus_ubuntui686 squisher _6a68 ctag codehero acertain inr prohobo Denommus nathanic rgrinberg ElderFain Tesseraction rockfruit sim642 codeman777 timrs2998 cheater fr33domlover theelous3 yulax manuel_ dcoutts akermu minad xiinotulp albel727 javjarfer fnordbert rembo10 hariel ixian)
12:48:09 --- names: list (scinawa1 pie__ gseitz pflanze yrdz jokester Berra watersoul christiansen` JuanDaugherty opios hiratara ClaudiusMaximus radiofree mjo takuan pharaun jamesbvaughan dolio byorgey t0m0 niteria andromeda-galaxy hackagebot sevas shutdown_-h_now atomi mendez otto_s ziman sns potatoe ntpttr x1n4u max-m besenwesen xaimus jzl tgeeky dpn` deni Ornedan_ da-x_ kishar jotrk nathyong_ mheinzel grandy a____ptr ryoia sigma9141 yminsky sunakshi_ carter chriswk sbauman marcel_)
12:48:09 --- names: list (cmdv milessabin tarcwynne_ sdemos dsm Filthy_casual sisir___ Immune aristid dmoon1221_ louispan hughrawlinson g4k billstclair ReinH stevenxl jmathes edwardk steeze dmh rstone Insanity_ kyagrd nomeata joedevivo {AS} georgew jml runeks kritzcreek doomlord hvr amalloy eacameron kier scottj pkogan justanotheruser jnoah bhiliyam dax fengshaun CaptainLex CaptainLex_ jibi qwesste ype Adios feth1 Bez_ joncfoo m4lvin dmiles thallada oldmanmike latk jud bdeferme)
12:48:09 --- names: list (verement Shock_ malcon ego takle begriffs fractalcat mnoonan YellowOnion erikd _xor ericsagnes scared eell zaquest boj_ paolino thunderrd fugyk lush zudov dcoutts_ Jesin schell fiddlerwoaroof phileas pmade logcat albertus1 adnelson cyphase_eviltwin taktoa Nik05 fryguybob chrpape daishan Blkt dud zoran119 knyppeldynan king_jah tokik tnks ps-auxw Clint magicman uwap suppi haasn s4kashya1 limeburst Guest7667 tinkyholloway joncol avn dibblego Nycatelos astocko)
12:48:09 --- names: list (electrostat hanDerPeder kmicu amiri marens buttbutter Matajon jrp6 schnizzle sleepynate sebastian-w SCHAAP137 derdon Deide geekosaur sleblanc Xe smwangi Taylor chaosmasttter vervain Reyu paf31 dfeuer zmanian___ chattered gpampara grol free_beard herzen ronstra Sonderblade araujo Chobbes carlomagno martingale crobbins wraithm adamCS fold4 Cathy hiptobecubic_ LordDeath flebron ljhms jluttine haircode hackebeilchen StoneToad grumble peddie Rodya nwf calloc)
12:48:09 --- names: list (whoops nour_ Orion3k dextertzu Philonous kyren officer_raccoon koray goodboytyler dedgrant nmattia Sonarpulse anemecek nepiktaz Davehkiin niko Phillemann eddsteel jorj prkc _janne Lokathor csauce wriggle Shou skyres dxld happy0 wrmsr kaste thebnq tomku nakal simony hc meditans IanKelling luis` xaxisx ethercrow phadej obihann __main__ bgamari Ralith_ fld djapo yorick clever kian alercah hpc otulp asjo TrevorBramble electrocat niklasb wagle arkeet bairyn)
12:48:09 --- names: list (AustinMatherne henrytill Bigcheese c-rog joehillen opqdonut mitchty earthy carter-znc nilsi_ dpepsilon sdx23 JPohlman1 tumi_ monochrom padre_angolano ohsix_ japesinator_ bus000_ Drezil BrianHV_ larion_ lulf_ stef204 elementalest simukis_ MoALTz ianclark dsantiago revprez dkettman danza agocorona JonReed eh_eff_ qguv felixsch pyon Sonolin kosorith coltfred dmwit codesoup ksf darkf sdothum rdesfo[m] jonrh royc jfischoff ashishne_ ahf caasih bigs lukexi jlouis)
12:48:09 --- names: list (nesqi Scorchin AlainODea yaknyasn stasku_ ericbmerritt kilimanjaro Merv strmpnk defanor whiteline nyuszika7h Tharbakim mdarse nshepperd1 glguy Soup nek0 majoh Guest11138 DANtheBEASTman Boreeas przembot mads-_ bartavel` armlesshobo noplamodo_ luigy_ telmich_ `0660_ worch Intensity exferenceBot Vbitz sleezd lieven zomg jomg Rarrikins Princess17b29a Voldenet Kruppe Liskni_si Sigyn mikeplus64 @ChanServ SolarAquarion flux Lord_of_Life mikeizbicki xfix carc)
12:48:09 --- names: list (idupree gothos spaceships eikke seagreen jlewis mw bjs Elsi shwouchk bananagram jimki xa0 mkloczko counterfeit dzack solarus alang JDevlieghere_ Ulrar tomaw posco burp_ dfranke kungp mudfog betawaffle Amadiro Edoxile alem0lars buckowski gniourf Tehnix Axman6 cschneid noexcept_ cnr Moyst SLi danieli orcus koala_man reynir oldsk00l squimmy hyPiRion hbar_ donwilliam taruti mmaruseacph2 Hakey Benzi-Junior bjobjo oberstein eagleflo stass XMunkki_ pyrtsa Chousuke_)
12:48:09 --- names: list (Starfire_ Phyx- tazjin_ anoe Biohazard wamaral wjm cin so jrslepak buoto mrd theo ido_ DiabolikFreenode ipuustin_ ircbrowse noctux johnv_ kloeri Nikotiini gridaphobe mrlase jtobin gabiruh_ juri_ mgaare cynick DustyDingo riscool jinblack prooftechnique_ rodlogic tekacs CodeKiwi Khudher saidinwot Majiir lpsmith g2` ybit mimi_vx fingerzam SiCC trajing RazorX jvanbure brisbin fxrs orzo [swift] nurupo aweinstock jpl vodkaInferno DDR nilOps ramatevish Lutin` cjay)
12:48:09 --- names: list (Rabbit_ lukky513 Eagle_Erwin Oxyd stux|RC-only yarou mrowe _ashbreeze_ epta ajaniMember garphy`aw tych0 codebje Tene Igloo krgn tctara fabianvf ft AppleJacks24 Jaak surtn Sagi implementation_ ddima brennie aatxe schultz gornikm tjbp hydPaz emmflo navilan- isomorphismes psmolen_ dustinm benzrf dschoepe ec\ Rembane linduxed c_wraith unsymbol absence Raynes ndeine n__dles lassulus _drazil fmapE Profpatsch saurik snoogie hausdorff qmm Amun_Ra Belgarion0)
12:48:09 --- names: list (superfatkappa wayne indiffernet tswett Guest5571 richi235 Deewiant cow-orker mak` spacebug PanicSkittle ben Geekingfrog Pucilowski m1dnight` liste naudiz APic Xandaros Yaiyan nickpascucci rotcpy Reisen supki barrucadu Desu briansteffens topi nerdystreetrat freekevin myfreeweb_ oherrala tek0 davean bbee obiwahn niluje tdammers xplat tjt tero- mudfog_ ynyounuo haldean dredozubov bitemyapp relrod sLite baweaver KaneTW Fubar^ ryantm wrengr Solarion ski hemite)
12:48:09 --- names: list (parsnip Adeon johnstein lachenmayer swistak35_ statusbot Vq eamelink oelewapperke bob_twinkles thoros __name__ etabot osfameron Saizan cdidd dyreshark __rlp statusfailed s4kashya Jonno_FTW pdgwien imalsogreg ernst sm EvanR aaron7 amiller adraenwan dan64 bogdanteleaga foobars davl andreass Soft nikolah l3france Zemyla flippant horatioh1 tomus ReinH_ Saimeidae Ke yeltzooo canta Fuuzetsu quuxman ijp Akii Gothmog_ tv daf lhynes unbalanced xxpor swhalen)
12:48:09 --- names: list (fairfieldt jw358 jix_ numberten RevJohnnyHealey Twey adarqui RageD dredozubov_ kennyp Ezku Arguggi filibustr bind qnix mceier glowcoil ycheng poga chronon-io benj02 zenzike sphalerite mrm mariothemad exio4 Speed jtcs Desoxy coeus zhulikas iskander LnL qknight fycth lstrano fabiopbx mathu dqd _Tristan-Speccy_ PHO mattp_ samgd tolt d3lxa pelegreno___ anderson lyxia lenstr eyenx brent kjanosz ngWalrus chirpsal1 mantovani joeytwiddle nopf Marqin s4kashya_ Hafydd)
12:48:09 --- names: list (andjjj23_ julmac Freundlich mbrock vqrs benjamin1rom Kneiva urh Stratege_ ChongLi sujeet HalfEatenPie Madars yusukesuzuki m0rphism Myrl-saki amx bencryption jstolarek cods Tenkeyless_Cooki jaimguer urdh Guest84199 hxegon Laney alunduil mjrosenb PalTale abrar theorb kini laudiacay Bane^ IndigoTiger odamn monty Fairy ollef [exa] ab9rf platz Brando753-o_O_o sdrodge pacak amuck qlkzy moop leat2 ion Enigmagic majjoha guampa trig-ger heyj jroesch_ dstockwell)
12:48:09 --- names: list (fuziontech seanparsons mpickering alex_lu mbrcknl rann spinda peteretep crough vinnie92 huonw sword_smith dogui mbwe phaskell phaskell-2 mero abra0 arw_ joachifm leothrix hucksy jokleinn hexagoxel sooheon falafel daey Vektorweg11 koz_ pkmx[m] M-mistake M-Illandan radix1 jamon[m] M-Magnap M-Shrike helloworld1[m] lspitzner alx741_ UnlikeSuika amyers andy____ mokus dilinger AntiSpamMeta copy` newsham mmachenry1)
12:48:51 <monochrom> EvanR: Some OOP programs have a nice translation. You can use a Haskell record for an object. This works out fine when your class hierarchy is flat, plus some other conditions.
12:48:53 <neochronomo> ski: I've heard it's like a programming 'epiphany' and that it's actually better than OOP. That's what got me interested
12:49:07 <ski> here we go again  ..
12:49:24 <dfeuer> Oh boy.
12:49:34 <ski> neochronomo : certainly i'd say more *different* (and useful) ways of attacking problems is a good thing
12:49:49 <monochrom> glguy should advertise his glirc now. greatest impact.
12:50:30 <erisco> neochronomo, maybe I missed something, but OOP bottoms out with visitors and factories and strategies and such-like
12:50:52 <erisco> neochronomo, the body of knowledge contained in FP is vast in comparison
12:51:17 <neochronomo> erisco: I don't really know what you mean
12:51:26 <monochrom> oh hell, I will advertise it for him. it collapses join-part messages and other things of your choice. "collapse" is different from omitting. "collapse" means there is a button you could click to expand, if you want to, when you want to.
12:51:47 <erisco> neochronomo, well, what are visitors and factories and strategies? they are design patterns, right?
12:52:09 <erisco> neochronomo, these are advanced generalisations in OOP that cover a wide range of problems
12:52:38 <neochronomo> erisco: I've never heard of those strategies by name
12:52:54 <Tuplanolla> Haskell is a great gateway to type theory, mathematics and mathematical philosophy, neochronomo.
12:53:11 <erisco> never heard of "visitor pattern" or "factory pattern" or "strategy pattern"?
12:53:23 <neochronomo> erisco: Nope :P
12:53:23 <ski> neochronomo : .. should you become interested in such matters
12:53:26 <Tuplanolla> You don't have to follow that route, but it's very inviting if you enjoy living inside your head, neochronomo.
12:53:33 <ski> otherwise, it's fine for just programming
12:54:05 <erisco> ah, well, if you dig into OOP you will find these
12:54:24 <neochronomo> erisco: I've been using OOP for 10 years... I'm just not an enterprise developer
12:54:31 <neochronomo> maybe that's what they're for
12:54:42 <monochrom> Is it just me or is it true that "gateway" is just a typo away from "getaway"?
12:54:58 <erisco> they are generalisations, patterns, not things themselves, but you can have instances of them
12:55:04 <Tuplanolla> Visitors come up often in interpreters and compilers, for example, neochronomo.
12:55:17 <PhsShft> need some serious tutoring on haskell, willing to pay, takes an hour, anyone?
12:55:38 <erisco> visitors are also used to fold sum types, roughly
12:56:28 <jle`> geekosaur: ah i see, thanks
12:57:04 <erisco> but anyways, FP has an easier relationship with mathematics and so benefits more substantially from its accumulated knowledge
12:57:11 <erisco> and so that is why there is more to find
12:57:51 <erisco> you can go back to Java or C# or a language like this and employ what you've learned, though sometimes you will be hindered by the type system
12:58:08 <erisco> higher-kinded polymorphism being a frequent problem
12:58:16 <neochronomo> erisco: hmmmm
12:58:53 <joncol_> neochronomo: What language were you using before?
12:59:03 <erisco> professionally I have written PHP and C#, never Haskell, but I could use my Haskell knowledge nonetheless
12:59:49 <neochronomo> joncol_: C#
12:59:58 <c_wraith> yeah, I keep wanting to use traverse in every language.. 
13:00:19 <c_wraith> it really works poorly without a strong type system, though. 
13:00:30 <erisco> one traverse for every type
13:01:01 <c_wraith> well, not that so much as.. what is the leaf type? 
13:01:23 <c_wraith> if you have nested structures, which values are you traversing? 
13:01:32 <erisco> every type you use, I mean. In the programs I have worked on it happened that only one or two instances were needed
13:01:38 <c_wraith> with dynamic types, it gets ugly. 
13:02:05 <erisco> it feels a bit like programming in C, but far less pervasive
13:04:00 <Tuplanolla> Even if you end up not using Haskell, you might find yourself not enjoying most other languages anymore.
13:05:05 <erisco> symptoms of Haskell may include language dysphoria
13:05:28 <EvanR> or enrolling in graduate school
13:05:37 <EvanR> both are pretty bad
13:06:02 <Tuplanolla> I wrote a computer vision thing in Java some years back and it annoyed me to no end that I had to implement separate convolutions for images and polygons.
13:06:19 <erisco> may include professional studentship 
13:08:57 <erisco> Tuplanolla, I do find it enjoyable trying to weasel things into languages
13:09:55 <erisco> type classes, ADTs, eDSLs
13:10:25 <erisco> I was surprised with how much you can actually do with C# wrt eDSLs
13:10:49 <monochrom> that's because Erik Meijer is always pulling strings.
13:11:13 <erisco> I wonder if he petitioned "using static"
13:15:11 <Tuplanolla> @hoogle maximumOn
13:15:12 <lambdabot> Control.Monad.Loops maximumOnByM :: Monad m => (a -> m b) -> (b -> b -> m Ordering) -> [a] -> m (Maybe a)
13:15:12 <lambdabot> Control.Monad.Loops maximumOnM :: (Monad m, Ord b) => (a -> m b) -> [a] -> m (Maybe a)
13:15:24 <Tuplanolla> Where's the normal one?
13:15:46 <erisco> do you mean maximumBy?
13:15:54 <Tuplanolla> No.
13:16:43 <erisco> what is the difference?
13:16:49 <neochronomo> Is Haskell generally considered pretty difficult to learn? I'm having a lot of trouble getting through the exercises of the first couple lessons
13:17:06 <erisco> yes, it is difficult to learn
13:17:23 <buttbutter> What's that GHCI option that will still compile code if there are errors? So you don't have to comment things out to play with types you have defined or something.
13:18:12 <erisco> if you know Java and you want to pick up C# it is not much of a stretch. Haskell on the other hand is drastically different, and so there is far less familiarity to leverage
13:18:18 <Tuplanolla> That `maximumOn :: (Foldable f, Ord b) => (a -> b) -> f a -> a` while `maximumBy :: Foldable f => (a -> a -> Ordering) -> f a -> a`, erisco.
13:18:27 <erisco> now if you've already used OCaml or some such then you'd have an easy time
13:19:12 <lyxia> buttbutter: defer-type-errors
13:19:31 <buttbutter> lyxia: Ah, thanks :D
13:19:39 <ski> neochronomo : some people think Haskell is easier to pick up, if you have no former programming experience
13:19:44 <erisco> :t maximumBy . comparing
13:19:46 <lambdabot> (Foldable t, Ord a) => (b -> a) -> t b -> b
13:19:55 <lyxia> buttbutter: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-warnings.html#ghc-flag--fdefer-type-errors
13:20:12 <ski> (less to unlearn)
13:20:20 <neochronomo> ski: well I've been programming for 20 years, so that could be why
13:20:22 <Tuplanolla> It'd be nice to have that somewhere since `sortOn` exists too, erisco.
13:20:34 * ski started programming around age 6.5
13:20:43 <ski> (BASIC, and then assembler)
13:20:49 <neochronomo> 20 years ago for me was 7, so we're similar haha
13:21:38 <ski> so .. there's probably hope
13:22:07 <monochrom> In my case it's my attitude or preference, rather than what I had seen previously.
13:22:47 <erisco> in my case it is because I don't like not knowing what the smart people know :P
13:23:07 <monochrom> My attitude and/or preference is that math is right, imperative programming is a hack.
13:23:44 <monochrom> And so even though I learned imperative programming first, when I finally saw Haskell I was "finally something that actually makes sense".
13:24:10 <erisco> imagine you were in the world of Harry Potter. would you want to be a muggle or the most proficient wizard of them all?
13:24:24 <monochrom> As opposed to other people's "why is it so different"
13:24:26 <ocramz> hullo
13:24:49 <monochrom> I don
13:24:56 <monochrom> I don't want to be a wizard.
13:25:02 <monochrom> What is a muggle?
13:25:07 <glguy> non-wizard
13:25:15 <monochrom> I want to be a scientist.
13:25:24 <erisco> in their world magic is a science
13:25:43 <monochrom> My kind of science. Not their kind.
13:26:05 <monochrom> My kind of science means refutable and has predictive power.
13:26:22 <erisco> you don't want to defeat evil with the unbreakable power of love?
13:26:23 <monochrom> It does not necessarily mean being able to fly.
13:27:06 <ski> (how about defeating ignorance with reason ?)
13:27:17 <erisco> the famous equation e=¬♥
13:27:56 <monochrom> @quote monochrom download
13:27:56 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
13:29:12 <monochrom> Haskell is going to be a bit harder than other languages for two reasons. One reason I skip now. Another reason is that you likely deplored algebra (equational reasoning) but Haskell is best used with that skill.
13:29:29 <ski> @quote rules.of.Go
13:29:30 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
13:29:41 <neochronomo> The most bizarre concept  I haven't understood yet about Haskell is how there aren't any variable statements... I use variable in everything I do in OOP and I have absolutely no idea how an expression-only language will even work. It'll be exciting when it finally clicks
13:30:01 <monochrom> Now, of course, "best used with" means you don't have to, but then you will be at an disadvantage.
13:30:08 <ocramz> ha
13:30:21 <ocramz> the other, evil, SPJ
13:30:23 <ski> neochronomo : *nod*, it was a nice realization when i got that it wasn't that big of a deal :)
13:30:38 <monochrom> whereas with most imperative programming you do just as well with or without, and therefore you don't find the same agony.
13:31:45 <erisco> I don't remember it clicking rather than just slowly going away
13:31:53 <monochrom> I was not good at highschool math. But I loved it. It's why I find Haskell easier. And Haskell's algebra is easier than highschool algebra. No cubic equations to worry about.
13:32:13 <ski> what ?! don't most competent imperative programmers know their Hoare triple logic by heart !?
13:32:36 <ocramz> can I interrupt this highly enjoyable stream of though with a very down-to-earth question? how do I ask stack to use a specific revision of a hackage pkg?
13:32:47 <monochrom> but Hoare triples aren't quite applicable to Haskell
13:33:25 <monochrom> I think you hardcode the version number in *.cabal or stack.yaml?
13:33:41 <monochrom> I don't know stack, but I know how it would be done in *.cabal
13:33:42 <erisco> the only interesting algebra is abstract algebra (my two cents)
13:33:46 <erisco> of which I was taught none
13:36:50 <erisco> any time you have a model, the only really interesting thing is the analysis of that model
13:37:04 <erisco> rather than the particular things you can build with it
13:37:23 <monochrom> eh? No, another interesting thing is to use that model for prediction
13:37:49 <erisco> for physical phenomenon? sure, but I wasn't limiting to that
13:38:21 <monochrom> I have a model of Haskell. I use it all the time to predict what happens to my code. It's how I happen to write correct code.
13:38:48 <monochrom> And this is in a gray area of "is computer behaviour physical or is it mathematical?"
13:39:17 --- mode: asimov.freenode.net set +o ChanServ
13:39:35 <joncol_> For some colorfulness and lambdaness and hoogleness.
13:39:45 <erisco> then we're just choosing different distinctions
13:39:56 <koz_> Can anyone give me some help and/or advice with this? http://lpaste.net/247092
13:40:15 <erisco> I have been in the trap of finding different ways to model things
13:40:29 <erisco> as a set, as a graph, as a function, as a grammar, or what-have-you, things like this
13:40:36 <monochrom> is that a trap? or is that a paradise?
13:40:53 <erisco> but the only interesting questions are the analysis of those models
13:41:37 <erisco> so in this sense it is like finding the AST of Lambda Calculus devoid of all else
13:42:08 <erisco> sure, you can build stuff, but what does any of it mean
13:42:42 <Tuplanolla> Do we have `logBase :: Integer -> Integer -> Integer` somewhere?
13:42:56 <monochrom> no
13:42:58 <geekosaur> not for Integer, no
13:43:01 <koz_> Tuplanolla: I've only been able to find premade ones for specific bases.
13:43:07 <koz_> ANd yes, not for Integer.
13:43:16 <Tuplanolla> Damn it.
13:43:35 <Tuplanolla> Writing one looks annoying.
13:43:40 <geekosaur> :t logBase
13:43:42 <lambdabot> Floating a => a -> a -> a
13:43:58 <monochrom> You should write your own because you should choose your own rounding.
13:44:10 <lyxia> koz_: try using a para.
13:44:48 <lyxia> koz_: either you change the current constructor, or you recurse in one of the fields
13:44:50 <monochrom> And yes it is always annoying to sit down in a full-service restaurant, only to be given a long menu and told to make my own choices.
13:45:08 <joe9> anyone with experience writing a wayland client from haskell? How do you get the registry_listener callbacks working from haskell?
13:45:15 <koz_> lyxia: I'll have to write the paramorphism then. data-fix doesn't provide them...
13:45:21 <monochrom> Why can't "full-service" include "choose one for me telepathically"?
13:45:37 <erisco> monochrom, menus are okay, choosing ingredients is not… damn you Subway
13:45:45 <monochrom> :)
13:45:50 <erisco> $5 for a sandwich and I have to tell them how to make it taste good
13:45:53 <JonReed_> Does anybody know how can I extract value of n2 inside bar' ? `data Bar' (n :: Nat) (n2 :: Nat) = Bar' String deriving Show; bar' :: (KnownNat n, KnownNat n2) => Bar' n n2 -> (String, Integer); bar' b@(Bar' s) = (s, natVal b)`
13:46:23 <koz_> lyxia: How would I make sure that I only change *exactly one* *random* part of the expression tree when using a paramorphism?
13:46:26 <ski> erisco : .. or inspecting the chicken to neck
13:46:36 <Tuplanolla> The question is basically how many digits I would need to show a number in a given base.
13:46:41 <monochrom> I have solved that one by sticking to "6 inch meatball, honey oat, cheese yes, heat no, lettuce and tomato, no sauce". I invite you to duplicate this great recipe.
13:48:09 <erisco> after much trial and error, mine is parmesan oregano, everything, mayo, pepper and oregano
13:48:26 <koz_> erisco: You must clearly like oregano.
13:48:44 <nitrix> He likes everything.
13:49:30 <erisco> and they always ask "hot peppers as well?"
13:49:57 <erisco> they need clarification as being a "thing" and part of "every"
13:50:23 <nitrix> forall s. Sandwich s => ...
13:51:09 <nitrix> Can we define a type-safe sandwich?
13:51:25 <nitrix> One that every compiler will enjoy?
13:51:31 <ski> perhaps in a dependently typed language
13:52:02 <monochrom> erisco, that is just akin to computer dialog boxes like "are you sure you want to delete IO.SYS?"
13:52:19 <jle`> Tuplanolla: it's around the logarithm of that number in that base
13:52:33 <Tuplanolla> Hence my previous question, jle`.
13:52:45 <jle`> oh wait, misread your intent in your question
13:53:33 <neonfuz> So generally is foldl or foldr faster?
13:53:54 <jle`> neonfuz: they do different things
13:54:00 <monochrom> False dichotomy. Incomparable.
13:54:00 <jle`> so it might not be meaningful to ask for a "generally" answer
13:54:30 <neonfuz> like, assuming for the application it doesn't matter which way we fold (like folding with (+)) and assuming no optimization
13:54:40 <monochrom> But apples are more tasty than oranges.
13:54:41 <jle`> it depends on the folding function
13:54:47 <jle`> and what you want to do
13:54:50 <jle`> and waht you need from the answer :o
13:54:57 <monochrom> both are slow. use foldl' (+)
13:55:14 <jle`> and yeah, foldl' is probably want you want to compare, not foldl
13:55:29 <jle`> foldl' (+) 0 is probably the fastest way to sum a list
13:55:30 <neonfuz> but foldr has to traverse to the end of the list first, right?
13:55:35 <monochrom> both are slow because both waste time allocating much memory and then deallocating.
13:55:38 <jle`> foldl' has to traverse to the end of the list
13:55:40 <jle`> foldr doesn't
13:55:46 <neonfuz> summing was an example of an operation that it doesn't matter which direction I fold, I'm not actually interested in summing a list
13:56:03 <neonfuz> okay, well I think I had foldl and foldr confused then
13:56:05 <jle`> `foldl' (||) True` is much worse than foldr (||) True, if your goal is to see if a list has any True's in it
13:56:09 <neonfuz> I thought foldr was the one that needed to traverse to theend
13:56:18 <monochrom> foldr (+) is much different from foldr (||). You now need to tell the real problem. It really matters.
13:56:20 <jle`> > foldl' (||) True (replicate 1000000 False)
13:56:23 <lambdabot>  True
13:56:25 <jle`> oops
13:56:29 <jle`> > foldl' (||) True (replicate 1000000000 False)
13:56:35 <lambdabot>  mueval-core: Time limit exceeded
13:56:38 <jle`> > foldl' (||) True (replicate 1000000000 True)
13:56:44 <lambdabot>  mueval-core: Time limit exceeded
13:56:45 <jle`> > foldr (||) True (replicate 1000000000 True)
13:56:47 <lambdabot>  True
13:56:51 <jle`> foldr is much better there, see? :)
13:56:56 <jle`> it returns immediately
13:57:03 <neonfuz> why?
13:57:05 <jle`> the two functions do two different things in two completely different ways
13:57:16 <monochrom> why not?
13:57:23 <verement> @src foldr
13:57:23 <lambdabot> foldr f z []     = z
13:57:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:57:25 <monochrom> But I'll show you a few steps.
13:57:52 <neonfuz> ohh, does foldr stand for "fold going right", I thought it meant "fold from the right"
13:57:53 <monochrom> foldr (||) whatever (True : whatever) = True || much_ado = True. Done.
13:57:59 <burrino> @src (||)
13:57:59 <lambdabot> True  || _ = True
13:57:59 <lambdabot> False || x = x
13:58:09 <jle`> which one is faster *always* depends on the situation and function and what you want to do.  there is no general answer
13:58:29 <jle`> neonfuz: foldr can short-circuit, but foldl' can't
13:58:43 <monochrom> I hope you see now it really depends on your real problem. You can't be elusive and get a precise answer other than "it depends"
13:58:52 <burrino> > id == id
13:58:54 <lambdabot>  error:
13:58:54 <lambdabot>      • No instance for (Eq (a0 -> a0)) arising from a use of ‘==’
13:58:54 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
13:58:59 <burrino> how can i make this work?
13:59:07 <jle`> burrino: what do you want to do?
13:59:07 <erisco> you can't
13:59:16 <jle`> @let id = 10 in id == id
13:59:16 <neonfuz> monochrom: well of course
13:59:16 <lambdabot>  Parse failed: Parse error: in
13:59:20 <erisco> > not == not
13:59:21 <jle`> > let id = 10 in id == id
13:59:22 <lambdabot>  error:
13:59:22 <lambdabot>      • No instance for (Eq (Bool -> Bool)) arising from a use of ‘==’
13:59:22 <lambdabot>          (maybe you haven't applied a function to enough arguments?)
13:59:24 <lambdabot>  True
13:59:32 <jle`> > let not = 11 in not == not
13:59:34 <lambdabot>  True
13:59:36 <erisco> someone did @undefine... evilt hing
13:59:57 <neonfuz> monochrom: but I think I gave an adequate example that satisfied the "it depends"
14:00:05 <burrino> let not = 11 in not == (not.not.not)
14:00:10 <jle`> neonfuz: for summing a list, you'd want to foldl' (+) 0
14:00:16 <jle`> for orring a list, you'd want to foldr (||) True
14:00:35 <jle`> just showing that you have to think about what you want to do in each case :)
14:00:44 <jle`> they do different things in different ways
14:00:49 <burrino> can i define something like (==) which just checks the types are the same?
14:01:00 <jle`> if they did the *same* thing in different ways, then you might be able to compare
14:01:04 <erisco> > not == not
14:01:06 <lambdabot>  True
14:01:07 <erisco> I fixed it
14:01:07 <jle`> but they do *different* things in different ways.
14:01:11 <jle`> burrino: yes
14:01:22 <burrino> > not == not.not.not
14:01:22 <jle`> @let sameType x y = typeOf x == typeOf y
14:01:25 <bgamari> phadej, ping
14:01:25 <alercah> The main advantage to foldr is that it works better with laziness
14:01:27 <lambdabot>  Defined.
14:01:27 <lambdabot>  True
14:01:31 <jle`> > sameType True False
14:01:37 <lambdabot>  True
14:01:38 <jle`> > sameType True "hello"
14:01:41 <lambdabot>  False
14:01:42 <alercah> since foldr doesn't need to traverse the spine of the list in order to calculate any result
14:01:49 <neonfuz> jle`: would foldr' work just as well for summing?
14:01:53 <burrino> :t typeOf
14:01:55 <jle`> there is no foldr'
14:01:55 <lambdabot> Typeable a => a -> TypeRep
14:02:02 <jle`> :t sameType
14:02:04 <lambdabot> (Typeable a1, Typeable a) => a -> a1 -> Bool
14:02:15 <neonfuz> also where is a good source where I can read implementations of standard library functions
14:02:26 <jle`> neonfuz: it's in the report, but you can also just look at the documentation
14:02:29 <alercah> :t foldr'
14:02:31 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:02:33 <jle`> there are links to their sources next to the names of the functions
14:03:09 <erisco> burrino, I used great liberties to make it work, though
14:03:21 <burrino> what about checking if a function can be rebuilt to use list opperations... eg sum == foldl (+) 0
14:03:26 <jle`> although i guess now since foldr is polymorphic, you'd have to look t the source for the [] instance, heh
14:03:48 <jle`> burrino: what list operations?
14:03:57 <neonfuz> jle`: what documentation, the online documentation?
14:04:01 <jle`> yeah
14:04:06 <jle`> http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html
14:04:51 <burrino> i mean if the datatype is foldable then i can lift functions that work on lists to work on this new type using build...
14:04:52 <jle`> oh, there is a foldr' now heh
14:05:16 <jle`> burrino: build?
14:05:22 <burrino> :t build
14:05:22 <nitrix> burrino: sum is a foldMap of Sum.
14:05:24 <lambdabot> error:
14:05:24 <lambdabot>     • Variable not in scope: build
14:05:24 <lambdabot>     • Perhaps you meant ‘buildG’ (imported from Data.Graph)
14:05:25 <jle`> well, you can see what GHC infers the type of
14:05:31 <jle`> :t foldl (+) 0
14:05:33 <lambdabot> (Foldable t, Num b) => t b -> b
14:05:38 <jle`> thatll help :)
14:05:53 <alercah> the advantage to foldl' is that it that, when you're collapsing everything into a single result without short-circuiting, like with sum, it reduces it all at once
14:06:04 <jle`> neonfuz: the implementations of list functions are more conveniently accessed here http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-OldList.html
14:06:43 <jle`> but yeah, foldl' is pretty good for modeling "imperative" algorithms, where you continually mutate/modify an accumulator according to items in your list one-by-one
14:06:44 <burrino> in fusion i can factor out toDatatype.fromDatatype in eg pipes
14:06:49 <nitrix> As far as I know, sum isn't strict, since it's using foldMap.
14:06:55 <jle`> foldr is good for short-circuiting functions
14:07:01 <nitrix> You'd need foldMap' f = F.foldl' (\m -> mappend m . f) mempty
14:07:03 <jle`> and also for functions when you want to take advantage of the internal structure of linked lists
14:07:15 <monochrom> foldr' for [] is a disaster like foldr for [] in SML. But I guess foldr' may make sense for other containers.
14:07:38 <nitrix> monochrom: Some finger trees possibly.
14:07:45 <jle`> neonfuz: i just described situations where i'd use foldr and foldl' above.  but i still don't think you can say one is "faster" in general
14:07:46 <nitrix> monochrom: Sequence for example?
14:07:49 <burrino> more generally any isomorphism can be fused like this, it seems to be finding functions equal to id
14:08:36 <jle`> neonfuz: neither is "faster" in general because the situations where you'd use foldl' are situations where you wouldn't use foldr, and the situations where you'd use foldr, you wouldn't use with foldl'
14:08:41 <burrino> filter isFoldable
14:08:48 <jle`> neonfuz: so it doesn't really make sense to ask what is faster "in general"
14:09:18 <jle`> neonfuz: i just described situations where i'd prefer one over the other, so those are the use cases where a specific situation might be faster :)
14:11:02 <jle`> this is kind of like asking if hammers or vacuums are faster
14:11:19 <lyxia> koz_: If you have a binary constructor Cons a b, when you write the para, you get Cons (changeA, a) (changeB, b), then you can write three alternatives: change the constructor (and put back a, b), call changeA, call changeB.
14:11:34 <burrino> if fusion is going to reduce function composition to minimal syntax, cant i use this to check function equality?
14:11:46 <monochrom> vacuum is faster at capturing hammer. hammer is faster at breaking out of vacuum.
14:12:13 <erisco> hammers swing faster in a vacuum
14:12:44 <nitrix> burrino: Functional equality is very complicated to do properly.
14:12:58 <Tuplanolla> Univalence in 3, 2, 1, ...
14:13:23 <nitrix> You could compare domain, codomain and images, but you cannot crack open the guts of a function to compare them...
14:13:26 <neonfuz> jle`: why do you only talk about foldl' and foldr? not foldl or foldr'?
14:13:34 <monochrom> we need a rock-paper-scissor-like game of hammer, vacuum, screwdriver
14:13:42 <nitrix> Besides, it raises the question of extentionality vs. intentionality.
14:13:45 <jle`> neonfuz: foldl is always worse than both and there is no reason to ever use it
14:13:48 <jle`> it's a mistake
14:13:54 <jle`> neonfuz: foldr' doesn't make sense for lists
14:14:44 <jle`> if you are talking about useful folds to do on lists, you're going to be chosing between foldl' and foldr :)  foldl is one of the worst mistakes in haskell history, and foldr' is only relevant for other data structures
14:15:01 <monochrom> burrino: fusion happens at compile time, not run time; and fusion is carried out by the compiler blindly trusting your equations, there is no check.
14:15:05 <nitrix> burrino: foo = 2 * 5  and  bar = 2 + 8  are extentionally identical, yet intentionally different. In your proposed model, would you consider those equal or not?
14:15:12 <neonfuz> so foldl is useless because it can't short circuit and must finish before returning?
14:15:18 <alercah> no
14:15:25 <burrino> with code that rewrites haskell functions i can simply check the syntax of the definition for equality, especially if i can provide information about how the two functions are related, eg providing types which are insttances of an Isomorphism class
14:15:33 <juri_> hmmwell that's an interesting result.
14:15:35 <grantwu> Isn't functional equality undecidable in general?
14:15:40 <alercah> fold is useless because it makes an O(n) series of lazy thunks on each term
14:16:01 <jle`> foldl' can be considered a constant-space version of foldl
14:16:01 <EvanR> in general you say
14:16:15 <joncol_> Can anyone take a look at https://gist.github.com/joncol/d9047ca958e4ebcfc95f21d1a118299b ? I'm just unsure of if my use of the Reader monad is OK? I'm a bit worried about all the calls to runReader that I make. The main problem is that JuicyPixels generateImage function expects a function that takes two Ints (x and y). I'm wrapping that in Reader monad and I haven't found a better way than what is in 
14:16:21 <joncol_> the gist.
14:16:32 <Cale> It's worth pointing out that the compiler is usually smart enough to optimise foldl such that it becomes equivalent to foldl' in cases where that would be an improvement
14:16:43 <jle`> burrino: foldl is what you get when you ask, "hey, foldl' is constant space, i wonder if i can make it take O(n) space on the length of the list for no reason?"
14:16:50 <jle`> * neonfuz 
14:16:50 <Cale> It's just, sometimes you'd rather not rely on that.
14:16:53 <EvanR> in general you have hypercomputation which can decide anything less powerful than itself, in the hierarchy of halting oracles!
14:16:54 <monochrom> haha
14:17:08 <grantwu> lol
14:17:23 <Cale> foldl' hints more strongly to the compiler that the result of evaluating the function application at each step will be needed later, and so might as well be evaluated right away
14:17:25 <erisco> sounds like when I wondered how you could make a super-exponential function
14:18:08 <burrino> i cant easily check that two functions are not identical, but i can provide transformations that show two functions are identical, i would be satisfied that a specified sugaring did not transform implementation of a function into another
14:18:17 <monochrom> yes, you start with Ackermann, then simply add "what happens if the numbers are in unary notation?"
14:19:21 <mmaruseacph2> is it possible to promote floats to type level?
14:19:42 <jle`> yes
14:19:42 <EvanR> float floats to the type level?
14:19:51 <jle`> but you won't get nice literals
14:19:54 <erisco> floating types
14:19:58 <burrino> yes you can use the infinite type [[[[[[[[ etc ]]]]]]]
14:20:02 <monochrom> would you trust type equality for type floats?
14:20:10 <EvanR> [[[[[[[[[[[...
14:20:14 <monochrom> or rather, type inequality?
14:20:16 <mmaruseacph2> I only need to compute with them, only test if they're above 0 :)
14:20:25 <erisco> a little imprecise, sometimes not a type, sometimes positive or negative infinity
14:20:34 <EvanR> NaT
14:20:37 <jle`> mmaruseacph2: reflection has the machinery you need
14:20:45 <jle`> @hackage reflection
14:20:45 <lambdabot> http://hackage.haskell.org/package/reflection
14:20:46 <Tuplanolla> > let x = ("Urgh!", x) :: (String, Any)
14:20:47 * ski . o O ( `x :: -Natural' )
14:20:49 <lambdabot>  <no location info>: error:
14:20:49 <lambdabot>      not an expression: ‘let x = ("Urgh!", x) :: (String, Any)’
14:20:50 <monochrom> If you have x :: 1.0001 and y :: 1.0002 would you say "they are close enough, same type"?
14:21:01 <EvanR> an Unnatural
14:21:11 <mmaruseacph2> monochrom: most likely
14:21:16 <mmaruseacph2> jle`: thanks
14:21:17 <Tuplanolla> How did you get around the occurs check again?
14:21:58 <jle`> mmaruseacph2: alternatively you can make an ADT that implements the semantics of IEEE floats from scratch using only promotable types ([Bool]?) and work with that :)
14:22:21 <burrino> i can order all functions, so i can write an equality?
14:22:31 <jle`> but, can you really?
14:22:35 <burrino> yes
14:22:51 <rgc> hi all
14:23:10 <erisco> how have you ordered them?
14:23:13 <burrino> eg using the String Ord instance on the definition. there are many ways
14:23:21 <monochrom> soon we're going to have type-level hash tables
14:23:29 <ski> you can't get to the definition, from the function
14:23:40 <grantwu> that's not exactly a useful ordering
14:23:44 <Tuplanolla> > let x = unsafeCoerce <$> ("Urgh!", x) :: (String, Any)
14:23:46 <lambdabot>  <no location info>: error:
14:23:46 <lambdabot>      not an expression: ‘let x = unsafeCoerce <$> ("Urgh!", x) :: (String, Any)’
14:23:53 <burrino> id = 0 etc
14:24:00 <Gal3rielol> Hi all, I have a question, say I have 2 functions parse :: String -> Parser AST, and typing :: AST -> State SymTab (), how do I perform them sequentially in main :: IO ()
14:24:15 <burrino> i think its just ordered point free combinators
14:24:22 <Gal3rielol> the monad there is different
14:24:46 <ski> Gal3rielol : use `execState' and your "run" function for `Parser'
14:24:54 <EvanR> if A is a subtype of B, and B is a subtype of A, does that mean A and B are equivalent?
14:25:39 <burrino> subclass?
14:25:49 <erisco> if you order them syntactically this does not tell you about their functional equivalence
14:26:06 <burrino> what if i ordered the compiled code?
14:26:13 <erisco> same thing, just syntax
14:26:32 <jle`> mmaruseacph2: umm i'm not sure actually how you do it using reflection but i have a feeling it's possible >____>
14:26:52 <mmaruseacph2> I'll try it over the weekend
14:27:19 <erisco> think about the effect of this. Say you have determined  S(SK)K < SS(KS)  by your syntactic ordering. From this, how can you determine if the functions are equivalent?
14:27:43 <mmaruseacph2> in the end, I could represent them as Rational's over some large (%n)
14:27:46 <burrino> but its compilation to a basic set of nested operations could recognise two different implementations as the same function, depending on the compilers ability to refactor and *cannonicalise* the program.
14:28:15 <erisco> syntactic equality implies functional equality, but not the other way around
14:28:18 <mmaruseacph2> and then promote only the int to type level
14:28:32 <EvanR> burrino: two programs in a total language can be compared that way, canonicalize and compare the structure
14:28:38 <jle`> mmaruseacph2: o it looks like you'd implement it using reflection + unsafePerformIO
14:28:45 <jle`> if you wanted to lift floats
14:28:55 <burrino> so i should compile to a "total language"?
14:29:05 <EvanR> if you want awesome properties
14:29:05 <jle`> that's how it's done, from scanning how other packages have done it
14:29:12 <erisco> well if it is total you just normalise, yes
14:29:24 <jle`> fun stuff
14:29:30 <erisco> i.e. you just run the programs and see if they give the same result, a bit unexciting
14:29:38 <burrino> thats no good at all
14:29:39 <EvanR> thats another story
14:29:46 <EvanR> thatd be funext
14:29:49 <ph88> can anyone tell me the difference between these two lines ? i thought they were the same but apparently not ^^  https://paste.fedoraproject.org/445792/87573914/
14:29:56 <EvanR> and you cant actually compare stuff that way
14:30:20 <erisco> well you need a result like in Lambda Calculus, where normal forms are unique
14:30:24 <ph88> i still would like to use .
14:30:48 <EvanR> erisco: difference between comparing the program and comparing what it does to all inputs
14:30:59 <mmaruseacph2> ph88: and you can, just replace all but the last $ in the first line with .
14:31:01 <mmaruseacph2> but not the <$>
14:31:02 <EvanR> which there are infinite of
14:31:15 <erisco> EvanR, normalising is much like running the program, only you may be left with some abstractions
14:31:20 <burrino> yes, that approach does not bear consideration
14:31:21 <jle`> ph88: you turned a <$> into a $ for some reason
14:31:22 <EvanR> which is the whole point
14:31:30 <erisco> yes well it is a trivial distinction
14:31:36 <EvanR> no its not
14:31:53 <lyxia> ph88: a <$> b $ c $ d = (a <$> b) $ c $ d = (a <$> b) . c $ d = a . b . c $ d
14:31:53 <EvanR> you can have two programs that look different but behave the same way on all inputs
14:32:02 <ph88> jle`, second line is how it was, first line how it is now ... so i'm surprised it typed check with both lines
14:32:21 <mmaruseacph2> ph88: but does it give the same results?
14:32:26 <ph88> nooo
14:32:29 <ph88> it's a bug
14:32:40 <erisco> I don't see the contradiction
14:32:42 <ph88> first line gives the right result
14:32:57 <burrino> i could give you two obviously identical implementations of (+), you would not attempt to satisfy yourself they are the same by plugging in test examples and worrying which tests you needed to perform to give a representative answer.
14:33:12 <EvanR> erisco: by a trivial distinction, i assume you mean its the same notion of equivalence or comparison
14:33:20 <EvanR> but its two different notions
14:33:42 <ph88> lyxia, . is the same as <$>  ?
14:33:45 <erisco> EvanR, well from the perspective of reductions, it doesn't seem so significant to me
14:33:55 <mmaruseacph2> ph88: (transformOut <$> parseSource parser . T.toStrict . printSource . transformIn x)
14:34:00 <mmaruseacph2> no, . is not <$>
14:34:05 <mmaruseacph2> @t (<$>)
14:34:05 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
14:34:11 <EvanR> well whether the difference is significant i dont know, but its totally different regardless
14:34:11 <mmaruseacph2> @type (<$>)
14:34:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:34:17 <mmaruseacph2> @type (.)
14:34:19 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:34:22 <EvanR> one is computable the other isnt
14:34:23 <burrino> why isnt haskell a total language? can it be made total?
14:34:27 <erisco> EvanR, you're suggesting something other than syntactic equality?
14:34:29 * hackagebot hsx2hs 0.14.0 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  https://hackage.haskell.org/package/hsx2hs-0.14.0 (JeremyShaw)
14:34:31 * hackagebot HsOpenSSL 0.11.2.4 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.2.4 (VladimirShabanov)
14:34:33 <Tuplanolla> @source (->) Functor
14:34:33 <lambdabot> Unknown command, try @list
14:34:34 <EvanR> erisco: several people including you were
14:34:37 <Tuplanolla> @src (->) Functor
14:34:37 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:34:43 <jle`> burrino: total languages are a little less useful
14:34:48 <EvanR> erisco: funext is do they agree on all inputs
14:35:03 <EvanR> jle`: lies!
14:35:04 <ph88> mmaruseacph2, fyi your solution doesn't type check
14:35:09 <ski> erisco : general recursion, pattern-matching failure, lack of distinction between `data' and `codata'
14:35:12 <ski> er
14:35:12 <burrino> why should i care if it terminates, i can still check the function does the same thing
14:35:19 <ski> burrino : ^
14:35:25 <mmaruseacph2> ph88: (transformOut <$> parseSource parser . T.toStrict . printSource $ transformIn x)
14:35:35 <EvanR> you cant check that they do the same thing
14:35:43 <mmaruseacph2> my bad, was too eager in changing $ to . (and I told you above not to change the last one :">)
14:35:49 <erisco> if you're so sure burrino, get on it, many computer scientists will be fascinated :P
14:35:55 <burrino> EvanR, i would be a terrible programmer if i couldnt
14:36:09 <EvanR> eh
14:36:13 * mmaruseacph2 should stop multitasking
14:36:33 <burrino> many computer scientists must be totally baffled by their own ability to compare and rewrite programs
14:37:01 <erisco> that isn't the problem
14:37:02 <EvanR> given an arbitrary N -> N, you cant know if they are extensionally equal
14:37:06 <erisco> the problem is general equality
14:37:11 <burrino> foldl (+) 0 == foldr (+) 0
14:37:15 <neonfuz> jle`: internet went out, I'm back now
14:37:19 <EvanR> "general equality" ?
14:37:42 <erisco> you can take two particular programs and figure out if they are equal or not
14:37:49 <EvanR> erisco: you might be able to
14:37:52 <erisco> this is different than devising a way to test if any two programs are equal
14:38:02 <EvanR> you cant prove that its possible in general
14:38:13 <neonfuz> jle`: well anyways, I think I don't understand how haskell does laziness in general, because I really don't get why foldl can stack overflow
14:38:19 <neonfuz> wouldn't it just be tail call recursive?
14:38:26 <burrino> separatist functional discrimination extremists
14:38:28 <EvanR> @src foldl
14:38:28 <lambdabot> foldl f z []     = z
14:38:28 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:38:48 <jle`> neonfuz: it doesn't "stack overflow", and there is no such thing as tail call optimization in haskell
14:38:53 <jle`> evaluation in haskell doesn't work that way
14:38:58 <neonfuz> oh really
14:38:58 <jle`> there is no call stack :o
14:39:01 <EvanR> foldl is doing a tail call ;)
14:39:02 <ski> (there tail calls, though)
14:39:07 <erisco> EvanR, yes, might :)
14:39:21 <burrino> i didnt ask for a proof that you can do so in general, nnot only is that impossible, its far beyond the practical requirements
14:39:37 <lordcirth> http://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
14:39:40 <burrino> what can be achieved is sufficient
14:39:46 <neonfuz> jle`: learn you a haskell said that foldl stack overflows and foldl' doesn't
14:39:52 <jle`> neonfuz: when you do something like (1 + 3), GHC sort of represents it like a tree with (+) as the root and 1 and 3 as leaves.  it allocates it in the heap, and when it's finally necessary to evaluate it and see what the result is, it collapses the tree
14:39:58 <jle`> lyah is lying :)
14:40:01 <erisco> well so you type in f == g in Haskell and what is Haskell to do with this?
14:40:02 <EvanR> it used to stack overflow before they unlimited the stack size
14:40:06 <EvanR> by default
14:40:13 <EvanR> erisco: _|_
14:40:16 <erisco> is this == not asking the impossible question?
14:40:38 <jle`> neonfuz: what foldl does is it never "forces"/collapses the tree
14:41:06 <jle`> neonfuz: it builds up a huuuge tree in the heap, with O(n) nodes on the length of the list
14:41:16 <burrino> i said earlier i would be satisfied with something that returned false if a specified sugaring did not transform one definition into another
14:41:24 <jle`> foldl' collapses the tree/evaluates the terms as it goes along
14:41:34 <jle`> so it never builds a huge nested unbalanced tree of unevaluated thunks
14:41:48 <jle`> it's constant-space in the length of the list
14:41:58 <ggVGc> has anyone here looked at this? https://github.com/Kinokkory/cluss
14:42:12 <lordcirth> jle`, so what's the main reason to use foldl?
14:42:21 <erisco> that could become quite specific to GHC
14:42:31 <jle`> there is no real reason to use foldl
14:42:35 <jle`> it is a historical accident
14:42:38 <ggVGc> I'm not sure I understand what problem cluss is solving
14:42:41 <jle`> one of the worst mistakes in the history of haskell
14:42:46 <jle`> even worse than Monad/Applicative
14:42:52 <jle`> even worse than record syntax
14:42:57 <jle`> even worse tha Num
14:43:03 <neonfuz> are there any relevant compilers other than ghc?
14:43:05 <ggVGc> jle`: you mean foldl instead of foldl'?
14:43:12 <jle`> yeah
14:43:17 <jle`> or well, foldl in general
14:43:17 <geekosaur> neonfuz, not currently
14:43:20 <ggVGc> yeah I never undertood why foldl exists
14:43:22 <jle`> let's just comment it out of the source code
14:43:30 <burrino> haskell seems to be able to factor out needless isomorphisms, so i know something like what i need is going on under the hood in pipe fusion
14:43:38 <jle`> nobody will notice, except for people whose code was already hoplessly broken in the first place
14:43:40 <ggVGc> jle`: hm? so what should be used rather than foldl'?
14:43:44 <erisco> burrino, as you stated it, that seems doable in principle
14:43:45 <neonfuz> thats pretty lame that haskell doesn't have tail call optimization
14:43:46 <lordcirth> well, it would be better to alias foldl to foldl'
14:44:05 <jle`> ggVGc: i'm saying there isn't any reason to use foldl.  but foldl' has a lot of purposes :)
14:44:09 <ggVGc> ah, wait, you mean foldl should go away and foldl' should stay
14:44:12 <ggVGc> right
14:44:13 <jle`> yeah
14:44:15 <geekosaur> neonfuz, that is a non sequitur
14:44:18 <ggVGc> jle`: I misunderstood your "in general"
14:44:21 <geekosaur> in one sense, all calls are tail calls
14:44:23 <jle`> well, the story is a bit more complicated now with generalized Foldable
14:44:29 <lordcirth> neonfuz, it doesn't 'not have it' it's "not applicable'
14:44:48 <geekosaur> in another sense, it's meaningless because haskell does graph reduction, not "calls"
14:45:10 <geekosaur> (the former sense is ghc's implementation details, the latter is Haskell's evaluation model)
14:45:15 <burrino> i think maybe id get closer to understanding what im trying to achieve if we could speak about this fusion and how it works...
14:45:26 <jle`> neonfuz: the situations where tail call optimization would help you in other languages is simply irrelevant in haskell
14:45:56 <ggVGc> I quite a lot wish that haskell would adopt the extensible records of purecript
14:46:01 <ggVGc> but that won't happen
14:46:04 <ski> (the scrutinee in a `case'-expression is not in tail position wrt the whole `case'-expression)
14:46:05 <ggVGc> I guess
14:46:11 <koz_> jle`: Could you help me with recursion schemes?
14:46:18 <jle`> ask a question here :) i have to leave soon
14:46:39 <implementation> neonfuz: it's exactly the "there are no other relevant compilers than ghc" attitude that makes people code ghc-centered, which in the end prevents other compilers from becoming relevant... :/
14:46:42 <koz_> jle`: http://lpaste.net/247092 <-- lyxia suggested paramorphisms, but I can't figure out how to do what I want with them.
14:47:04 <implementation> kind of a vicious circle
14:47:14 <ski> (anyway, it's better to not have tail calls as an optimization, but rather as an (asymptotical space complexity) *requirement*)
14:47:46 <erisco> maybe your program stack overflows, maybe it doesn't, depends on how the compiler is feeling about your flags
14:48:06 <ggVGc> erisco: #haskell-life
14:48:23 <ggVGc> "It won't fail!"
14:48:36 <ggVGc> "but if it does, we I won't help you much.." -- runtime
14:49:51 <jle`> koz_: implement what you want to do using explicit recursion first
14:49:59 <jle`> w/o using higher order functions
14:50:08 <jle`> and then you can start looking at how you can use hofs
14:50:16 <Guest92589> http://code.haskell.org/~dons/papers/icfp088-coutts.pdf
14:50:16 <jle`> *refactor it into higher order functions
14:50:42 <jle`> koz_: remember that Fix Operator is a normal data type that you can pattern match on
14:50:54 <koz_> jle`: OK, I will try.
14:51:15 <jle`> it's essentailly the same as if you had data Operator = Atom Int | Neg Operator | And [Operator] | ..., etc.
14:51:24 <jle`> you just need to deal with the annoying newtype wrapper, heh
14:51:31 <burrino> 2.2 Eliminating conversions http://code.haskell.org/~dons/papers/icfp088-coutts.pdf
14:51:35 <neonfuz> implementation: yeah, I get that
14:51:43 <burrino> map f · map g =
14:51:43 <burrino> unstream · maps f · stream · unstream · maps g · stream
14:51:56 <burrino> it then factors out the stream.unstream
14:52:02 <burrino> i dont undertand how
14:52:45 <koz_> jle`: I'm not sure where to even *begin*.
14:52:55 <geekosaur> burrino, it's using a feature of ghc called rewrite rules
14:52:56 <jle`> koz_: i suspect that your problem is with what algorithm you want to implement
14:53:02 <jle`> koz_: and it's not a problem with recursion schemes
14:53:04 <jle`> :)
14:53:14 <koz_> jle`: My problem is that I don't know how to express the former using the latter.
14:53:16 <jle`> mutateFormula (Fix x) = case x of
14:53:16 <burrino> It is interesting to note that the stream/unstream rule is not really a classical fusion rule at all. It only eliminates the list allocations that were introduced in converting operations to work over streams.
14:53:16 <geekosaur> you can tell the compiler that any time it sees the sequence (stream . unstream), it can eliminate it without changing the meaning
14:53:22 <jle`>   Atom i -> ...
14:53:27 <jle`>   Neg o -> ...
14:53:34 <jle`>   And os -> ...
14:53:38 <burrino> this seems to indicate a library could be introduced to generalise this approach
14:53:44 <jle`> koz_: express the algorithm first
14:53:48 <jle`> using explicit recursion
14:54:01 <jle`> and then people can start helping you refactor it to use recursion-schemes
14:54:26 <burrino> so my function equivalence could tell me if rewrite rules transform one implementation into another?
14:54:36 <EvanR> Atomi, Nego, Andoughoughough....
14:54:38 <erisco> well if it is to be of any use there it has to reduce  (x . stream) . unstream  to  x
14:54:39 <jle`> koz_: implement it as if Operator was any other ol' recursive tree type
14:55:12 <koz_> jle`: OK, that raises another question - how do I select only *one* specific target in the expression tree for mutation?
14:55:14 <jle`> s/Operator/Fix Operator
14:55:38 <koz_> That, I guess, is the heart of the problem I'm having.
14:55:49 <erisco> how to map numbers to operators
14:56:03 <erisco> well, you have an expression tree, find a way to number the nodes
14:56:18 <koz_> erisco: Thanks - that's *exactly* what I needed!
14:57:04 <burrino> aha, no my problem is more simple. i want to be able to implement ghc's rewite rules using pure haskell to remove the need to use ghc rewite rules to abstract out these redundant transformations. thats why im trying to check to see if things are == id, but i guess i could just put them in a class so that its explicit when two functions are inverses
14:57:04 <burrino>  of one anothr
14:57:10 <jle`> maybe you can also pair each node with its "address" on the tree?  not sure what you'll need eventually. but implementing it out using explicit recursion will help you understand the algorithm, and perhaps more relevantly, it'll help people help you
14:57:27 <jle`> because they'll know what you're trying to do in concrete terms, instead of guessing based on your english description :)
14:58:06 <burrino> does that make sense? is it based on some miscomprehension of mine?
14:58:32 <koz_> jle`: Thanks - erisco's suggestion is exactly what I needed.
15:00:07 <erisco> you might also assign a probability to each node changing, not mutually exclusive
15:00:33 <erisco> so, say, a 50% chance the node changes, then you use the RNG to decide
15:01:19 <burrino> i think i get stuck when i think about how build is implemented and trying to traverse a bunch of functions composed using (.) which seems to be the same as [] if i use build...
15:01:48 <koz_> erisco: I can just pick a node from the numbering and change that.
15:02:00 <koz_> I can do a 'targeted change' using a catamorphism provided I have a unique numbering.
15:02:04 <erisco> that's right, that is a mutually exclusive version
15:02:13 <koz_> s/pick/randomly pick
15:02:28 <burrino> does anyone understand what im saying?
15:04:01 <koz_> Or maybe I should just follow jle`'s idea and number all nodes ahead of time.
15:04:11 <koz_> I might just do that actually.
15:04:15 <burrino> im wondering how rewrite-rules can be implemented in pure haskell
15:05:07 <erisco> I am interested in functions of type  a -> Maybe a  to define a graph
15:05:24 <burrino> specifically;
15:05:25 <burrino> "fold/build"  forall k z (g::forall b. (a->b->b) -> b -> b) .
15:05:26 <burrino>               foldr k z (build g) = g k z
15:05:28 <erisco> it defines the edges simultaneously with defining the nodes, needing only then initial nodes
15:05:44 <burrino> sounds like an unfold
15:06:19 <erisco> well you could unfold a graph with it, yes
15:06:57 <burrino> oh, i thought you were asking how a producer was used to construct a stream
15:07:06 <erisco> together with this I am interested in how you generate one node from another
15:07:28 <burrino> i am also interested in this
15:07:53 <erisco> there is this little language that is quite interesting, consisting of &&&, id, fst, snd, and const
15:08:08 <erisco> this allows you to arbitrarily rewrite 2-tuples
15:08:31 <erisco> oh, and (.) I forgot
15:08:40 <burrino> that sounds very small, is it turing complete?
15:09:01 <hiptobecubic_> turing completeness is way overrated
15:09:05 <erisco> :t fst.snd &&& (snd &&& snd.snd)
15:09:07 <lambdabot> (a, (c, b)) -> (c, ((c, b), b))
15:09:14 <erisco> just an example
15:09:59 <erisco> :t snd &&& const 3
15:10:00 <lambdabot> Num c' => (a, c) -> (c, c')
15:10:14 <burrino> should i abandon my discussion on rewite rules and fold/build?
15:10:36 <erisco> the simple way it works is you replace commas with &&& and variables with the path constructed of fst, snd, and (.)
15:11:30 <erisco> but I want to get to something I can use for graphs, so this is roughly how it has to be expanded
15:12:04 <erisco> the nodes are constructed as  data X = Pair X X | Unit
15:12:36 <erisco> so now this sum, not just 2-tuples, and also the graph function is of type  a -> Maybe a
15:13:08 <erisco> the idea being that if the node doesn't match then it returns Nothing, otherwise it gives an edge to the next node
15:13:31 <erisco> I haven't figured out how to extend this simple language into what I want
15:14:51 <grantwu> Are type holes a thing
15:14:58 <grantwu> I want to see what type GHC infers for a function
15:15:04 <lyxia> _ ?
15:15:19 <erisco> they are in 8.1 or whatever we're on now iirc
15:15:53 <lyxia> they were there in 7.10 already
15:17:13 <erisco> the idea is that you can encode anything you want with X, and a small language for the graph function makes analysis easier
15:18:15 <erisco> hard to get answers for these broad questions though
15:21:02 * koz_ is not sure if he wants StateT s (RandT g) or RandT g (StateT s)...
15:21:11 <koz_> Like, does it even *matter*?
15:21:56 <MarcelineVQ> You could even include a seed in your State and not RandT at all
15:23:10 <monochrom> probably does not matter
15:23:14 <koz_> MarcelineVQ: My state is already (Int, Int, Int).
15:23:23 <koz_> I'm not sure further complication is warranted...
15:23:36 <koz_> I should probably define a record for that...
15:25:21 <lyxia> Well if you're going to define a record, including the seed won't cost much.
15:25:31 <koz_> lyxia: You make a valid point there.
15:25:58 <koz_> I'm using RandT mostly for convenience, honestly.
15:26:41 <ryantrinkle> so, i've got an instance of Functor, say Functor T, and with -ddump-simpl i get fmap @T s @Int @Int f x
15:26:57 <ryantrinkle> in other words, it looks fully saturated with known types
15:27:11 <ryantrinkle> in my instance, fmap is marked INLINE
15:27:16 <ryantrinkle> however, it doesn't inline
15:27:25 <ryantrinkle> does anyone have an idea why that might be?
15:33:36 <monochrom> ryantrinkle: is your fmap code recursive? recursion doesn't get inlined
15:34:09 <ryantrinkle> monochrom: nope,   fmap f = fmapMaybe $ Just . f
15:34:12 <ryantrinkle> and then   fmapMaybe f = push $ return . f
15:34:25 <ryantrinkle> and 'push' is the thing i want it to expose so i can have rules fire on it
15:34:30 * hackagebot hspec-meta 2.3.0 - A version of Hspec which is used to test Hspec itself  https://hackage.haskell.org/package/hspec-meta-2.3.0 (SimonHengel)
15:34:31 <monochrom> then I don't know
15:34:32 * hackagebot hspec-core 2.3.0 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.3.0 (SimonHengel)
15:34:34 * hackagebot hspec-discover 2.3.0 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.3.0 (SimonHengel)
15:34:36 * hackagebot hspec 2.3.0 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.3.0 (SimonHengel)
15:34:38 <ryantrinkle> (well, actually one or two more layers down to a different push)
15:38:58 * koz_ is rockin' with transformers.
15:39:58 <juri_> well that's a riddle. I've been cleaning up some warnings in my 3d modelling program and i changed.. something..
15:40:27 <juri_> that actually had a result, but i'm not sure what the result is. some objects are rendered with more faces.
15:40:34 <juri_> some aren't.
15:40:56 <juri_> I have so much haskell to learn. :/
15:44:30 <benzrf> :)
15:46:59 <EvanR> does this look like something a -> m (b -> m c)
15:47:45 <EvanR> toward a cartesian closure of a kleisli category ... or uh something maybe
15:49:37 <jle`> you can `m (b -> m c) -> (b -> m c)` if m is a Monad
15:49:53 <jle`> and...go backwards, too?
15:50:08 <jle`> it wouldn't be an isomorphism though heh
15:51:29 <EvanR> well say i have this Category
15:51:56 <EvanR> (i have a feeling someone is going say arrows)
15:52:34 <EvanR> and i can define new functions out of a type A into B, the requirements are determined by A and the allowed things i can do are determined by B
15:52:57 <EvanR> how do i upgrade from that to defining arrows from A to B -> C
15:54:06 <EvanR> (so i dont have to figure out products, maybe)
15:56:32 <EvanR> jle`: m (b -> m c) -> (b -> m c) wait how
15:56:39 <EvanR> oh i see
15:57:02 <EvanR> sneaky
15:57:22 <EvanR> it looks like something of the form m a -> a ;)
15:58:13 <Tuplanolla> Looking at your type I sense map and join (or counit, if you prefer), EvanR.
15:58:40 <Tuplanolla> Where did this come up?
16:00:30 <EvanR> im trying to define a category of spaces and mappings between them, source space has "recursion principle" for producing the maps, you are allowed to use "moves" in the target spaces in the process
16:01:23 <Tuplanolla> Ah, ##categorytheory calls.
16:01:25 <EvanR> by making a space of maps itself (exponential) i, according to haskell experience, should get currying 
16:01:42 <koz_> I'm a bit confused about the monad transformers and how to use them here: http://lpaste.net/247285 Could someone lend me a helping mind?
16:01:57 <EvanR> Tuplanolla: well by category i mean haskell Category
16:02:01 <EvanR> this is code 
16:02:18 <koz_> (sorry about the lack of factoring and good naming in the 'foo' function - it'll get re{named, factored}, I swear!)
16:02:39 <kamog> :t \f a -> f >>= ($ a)
16:02:40 <lambdabot> Monad m => m (a -> m b) -> a -> m b
16:03:08 <EvanR> kamog: weve clearly figured out how to unwrap a monad
16:03:11 <EvanR> hax
16:04:09 <Tuplanolla> This looks like an excellent toy for confusing unsuspecting students.
16:05:04 <jle`> EvanR: it's also "distribute" for the Distributive ((->) a) instance
16:05:06 <EvanR> how do you get a (String -> IO String) out of the IO (String -> IO String)... you just need a String
16:05:27 <jle`> just kidding i'm wrong
16:06:32 <samgd> Is Data.Vector the best thing to use for representing bit vectors of arbitrary length or is there a more efficient package?
16:06:52 <jle`> samgd: bytestring ?
16:07:35 <samgd> True, but Word8/element seems a waste
16:07:49 <jle`> oh wait i'm wrong
16:07:54 <EvanR> thats what Vector is
16:07:55 <jle`> i mean, i'm right
16:08:18 <jle`> kamog, EvanR: you can do it without Monad too
16:08:20 <EvanR> also theres probably a bitvector package
16:08:39 <jle`> er wait nvm you need Monad
16:11:33 <samgd> EvanR: bv seems to do what I want - just doesn't look widely used from a quick scan
16:12:49 <koz_> I've edited this to try and solve it, but it still doesn't work - I've also added the compiler error: http://lpaste.net/247285 Could someone please help me?
16:12:53 <samgd> There's also no complexity annotations
16:13:04 <erisco> there are other ways to seemingly unwrap a monad
16:13:34 <Unicorn_Princess> is it just me, or does https://www.seas.upenn.edu/%7Ecis194/spring13/lectures.html kinda skip a lot of stuff when it throws its homeworks at you? like, i looked up the solution for homework 5, exercise 6, and it has monads, which weren't covered yet
16:13:53 <jle`> koz_: annotate go with a type signature
16:14:56 <koz_> jle`: Am I breaking type inference?
16:18:21 <erisco> :t (unwrap1, unwrap2) -- I present unwrapping a Monad, a two-part story
16:18:23 <lambdabot> (Monad m1, Monad m) => (m (a, b) -> (m a, m b), m1 [a1] -> [m1 a1])
16:18:43 <Tuplanolla> Are you sure you shouldn't have `evalStateT` instead of `runStateT`, koz_?
16:19:19 <Tuplanolla> The other option would be to compose your functors with `Compose`, koz_.
16:20:35 <koz_> Tuplanolla: Yeah, I saw that.
16:20:40 <koz_> I now have a *different* issue: http://lpaste.net/247285
16:21:25 <Miodec> hi guys, im having troubles using irssi. it keeps telling me connection to chat.freenode.net is refused
16:21:30 <vapid> irc.tauri.hu /join #godx
16:21:43 <erisco> > unwrap2 (fmap return [1..])
16:21:45 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:22:26 <Tuplanolla> Does your `go` suffer from the `MonomorphismRestriction`, koz_?
16:22:35 <dfeuer> int-e, I'm benchmarking your new code (wired into a lexer, pretty much). It performs almost identically to your previous "simple" version on small-to-medium sized inputs, but it pulls ahead when the input gets really big. Nice work!
16:22:51 <koz_> Tuplanolla: I don't know...
16:23:10 <Tuplanolla> Enable the extension to lift that, koz_.
16:23:28 <erisco> seemingly so mundane that no one bats an eyelash
16:23:39 <koz_> Tuplanolla: I just did - no change.
16:23:43 <vapid> wrong chat lolz
16:24:20 <Tuplanolla> Can I see anyway, koz_?
16:24:36 <koz_> Tuplanolla: It's exactly the same code, with exactly the same compiler error.
16:26:04 <Tuplanolla> Oh, it's because you added that type annotation without the inherited constraints, koz_.
16:26:24 <Tuplanolla> Enable `ScopedTypeVariables` to inherit `m` from the enclosing scope, koz_.
16:26:38 <koz_> Tuplanolla: Thanks!
16:26:45 <koz_> I've actually never had this problem before...
16:26:54 <Tuplanolla> The other option would be to manually copy the constraints there.
16:27:27 <koz_> Tuplanolla: I'll just try that.
16:27:51 <Tuplanolla> With `NoMonomorphismRestriction` you shouldn't even need the type annotation.
16:28:20 <koz_> Tuplanolla: Restating the constraints did it. I'll try removing the type sig now.
16:28:38 <koz_> Yay! It worked! Thank you Tuplanolla!
16:28:51 <koz_> (I sure don't mess around with my first jump into monad transformers, huh...)
16:29:36 <koz_> Tuplanolla: Would you mind helping me refactor this code a little bit?
16:29:39 <Tuplanolla> This mess is commonly caused by the unfortunate history of certain extensions.
16:29:43 <koz_> I would appreciate your advice.
16:29:49 <koz_> Let me just do a clean working paste.
16:30:08 <Tuplanolla> I don't have the time now. Refactoring actually requires thinking.
16:30:46 <koz_> Tuplanolla: No worries, then. I'll just solicit the chan. Thanks anyway!
16:31:12 <koz_> Could someone please make comments or suggestions about how to better factor this code? http://lpaste.net/247285
16:34:31 * hackagebot test-fixture 0.4.1.0 - Test monadic side-effects  https://hackage.haskell.org/package/test-fixture-0.4.1.0 (lexi_lambda)
16:34:33 * hackagebot clckwrks 0.23.19.2 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.19.2 (JeremyShaw)
16:34:35 * hackagebot clckwrks-theme-clckwrks 0.5.2.1 - simple bootstrap based template for clckwrks  https://hackage.haskell.org/package/clckwrks-theme-clckwrks-0.5.2.1 (JeremyShaw)
16:34:37 * hackagebot reform-hsp 0.2.7.1 - Add support for using HSP with Reform  https://hackage.haskell.org/package/reform-hsp-0.2.7.1 (JeremyShaw)
16:34:39 * hackagebot happstack-hsp 7.3.7.1 - Support for using HSP templates in Happstack  https://hackage.haskell.org/package/happstack-hsp-7.3.7.1 (JeremyShaw)
16:39:41 * hackagebot hspec-wai 0.7.0 - Experimental Hspec support for testing WAI applications  https://hackage.haskell.org/package/hspec-wai-0.7.0 (SimonHengel)
16:39:43 * hackagebot hspec-wai-json 0.7.0 - Testing JSON APIs with hspec-wai  https://hackage.haskell.org/package/hspec-wai-json-0.7.0 (SimonHengel)
16:49:59 <ryantrinkle> i could use some help understanding this core: http://lpaste.net/247336#line185
16:50:16 <ryantrinkle> i have a chain of fmaps here, and i think they should be inlining, but they're not
16:50:37 <mheinzel> koz_: I can't offer much help, but I find it interesting to read.
16:51:28 <MichaelK> Hi, how can I debug type families? I'm working on a type-level program and want to get the steps taken so I can see what went wrong
16:54:23 <mheinzel> koz_: I'm not sure what you need all these different numbers for. Isn't the StateT always run with initial state of 0 (and finishes with state 1)?
17:02:05 <koz_> mheinzel: It doesn't have to finish with 1. The idea is that each node in the expression tree gets a unique index.
17:02:46 <samgd> > tranpose ([[]] :: [[Int]])
17:02:48 <lambdabot>  error:
17:02:48 <lambdabot>      • Variable not in scope: tranpose :: [[Int]] -> t
17:02:48 <lambdabot>      • Perhaps you meant one of these:
17:02:52 <samgd> > transpose ([[]] :: [[Int]])
17:02:54 <lambdabot>  []
17:02:59 <samgd> Annoying...
17:04:03 <Xnuk> > transpose [[]]
17:04:05 <lambdabot>  []
17:04:59 <koz_> samgd: Why, were you expecting [[]]?
17:05:30 <mheinzel> koz_: But inside each evalStateT there is only one execution fo randOp. The recursion only happens on the layer above (because of the anaM), so I don't see how the state would be passed to the "next layer".
17:05:51 <samgd> Well, it's essentially loosing information, no? I'm implementing [fromList, toList] for something (that is essentially a matrix) and needed tranposes
17:05:54 <mheinzel> But that could just be a misunderstanding on my side.
17:06:01 <samgd> and now fromList . toList /= id
17:08:14 <koz_> mheinzel: randOp is recursed via anaM.
17:08:57 <koz_> But I'm gonna write a quick test to check that.
17:09:09 <yhhko> joe9: ping
17:10:51 <jle`> koz_: i didn't mean that you were breaking type inference, i meant that adding a type signature will help you figure out what's going on :)
17:11:35 <koz_> jle`: Well, it kinda did, thanks.
17:15:25 <mheinzel> koz_: Yes, testing it would be best. I think the problem is that the whole ReaderT is only inside one expansion of the structure. That's what go does, only expand once.
17:16:14 <koz_> mheinzel: It seems you were right.
17:16:25 <koz_> That's... definitely not what I want.
17:16:54 <mheinzel> To pass information to the next expansion you have to put it in the "a" arguments of your constructors
17:17:28 <koz_> mheinzel: So do I need to redefine Operator, or just the generator?
17:17:33 <mheinzel> This will end up in the argument to randOp.
17:18:01 <koz_> mheinzel: How can I be sure that I'm not getting repeated indices then?
17:18:33 <mheinzel> Operator should be fine. We just have to tweak randOp/go.
17:18:51 <koz_> mheinzel: My idea was that I assign to each node a unique index as I generate.
17:19:00 <mheinzel> Okay, that's not that simple.
17:19:10 <koz_> mheinzel: Yeah, I'm starting to see that now.
17:19:32 <mheinzel> Something like annotating the depth / number of layer would have been easy, but this is tricky.
17:19:38 <koz_> I guess I need state at the level of randomFormula, *not* randOp?
17:20:42 <mheinzel> Well, the problem with the unique index is that if you create a If Int a a, you don't know how large these a's will become.
17:21:00 <mheinzel> And you can't, because that's random.
17:21:02 <koz_> mheinzel: Yeah, that's definitely an issue.
17:21:50 <mheinzel> So you can do tricks in the spirit of only giving the even indexes to the first a and odd to the second.
17:21:50 <koz_> So does that mean an anamorphism isn't powerful enough to describe this kind of construction?
17:22:23 <mheinzel> It depends on your requirements. Probably there is a way to make it work.
17:22:38 <koz_> mheinzel: Indexes must be unique. That's it.
17:22:56 <koz_> They don't even have to be consecutive or anything - just unique.
17:23:40 <mheinzel> Then there is a (slightly more complicated) way. But maybe t would be better to use Integer, because the indices might become quite large in certain cases.
17:23:52 <koz_> mheinzel: What is this slightly more complicated way?
17:24:23 <mheinzel> You have to pass information to each substructure that makes sure none of the indices will collide.
17:25:02 <mheinzel> Without thinking much about performance/optimisation you could start with an infinite list [0..] you pass to the first layer.
17:25:23 <mheinzel> If you just need one index, take it off and pass the tail to the next layer.
17:26:24 <mheinzel> If there are multiple substructures you create, you have to divide the list into multiple parts you pass on.
17:26:31 <koz_> OK, I think I see.
17:26:42 <koz_> Let me just explain why I need these.
17:26:52 <koz_> Basically, I need to be able to randomly 'mutate' my expression trees.
17:27:04 <koz_> Currently, I'm trying to get the idea of 'change one operator into another' as a mutation.
17:27:13 <koz_> Now, I need it to happen in *one* *random* place.
17:27:28 <koz_> Someone suggested indexing might be a way to make this happen, but I'm having doubts about that being a good plan now.
17:27:41 <koz_> mheinzel: Do you think there's a better/easier way?
17:28:32 <mheinzel> Ah, there is a simpler way. You are inside a monad anyways (currently for randomness).
17:28:44 <koz_> Well, yeah, that was kinda a given.
17:28:46 <mheinzel> Then you can make it work the way you initially wanted.
17:29:35 <grantwu>  /quit
17:29:50 <mheinzel> The State just has to be on a "higher level". go has to run inside the StateT.
17:30:29 <koz_> mheinzel: So you're saying that the anaM goes inside StateT, and then I unwrap at the very end?
17:30:56 <mheinzel> go has to be :: MonadState m => ...
17:31:08 <koz_> Or, putting it differently, the 'm' in anaM will have the constraint of MonadState *as well as* MonadRandom, right?
17:31:43 <mheinzel> Yes, anaM will the be in MonadState as well.
17:31:49 <koz_> mheinzel: OK, that makes sense.
17:32:11 <koz_> Let me just try that.
17:32:22 <mheinzel> That's a much simpler fix than what I first thought of :D
17:33:26 <koz_> mheinzel: Yeah, definitely. It compiles OK - let me just test it.
17:34:15 <mheinzel> And you can get rid of the ReaderT as well. It does not make things simpler here.
17:34:32 * hackagebot happstack-authenticate 2.3.4.5 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.4.5 (JeremyShaw)
17:34:36 <koz_> mheinzel: Yeah, I guess I could just carry around an extra argument.
17:34:37 <mheinzel> Just use an additional parameter.
17:34:46 <koz_> But your solution works!
17:34:48 <mheinzel> There is not much carrying around here.
17:35:42 <lpaste> koz_ pasted “mheinzel: Pudding” at http://lpaste.net/247383
17:36:10 <koz_> mheinzel: I guess this was actually a scoping issue.
17:38:24 <mheinzel_> koz_: Do you want to further improve it?
17:38:43 <koz_> mheinzel_: I'm just rewriting to remove MonadReader from it.
17:38:46 <koz_> After that, sure!
17:42:50 <koz_> mheinzel_: http://lpaste.net/247392 <-- took out the Reader stuff
17:42:52 <Gurkenglas> koz_, I'd replace the "choice <- …; case choice of 0 -> ...; 1 -> ...; ..." by "join $ uniform [..., ..., ...]"
17:43:32 <koz_> Gurkenglas: Where does 'uniform' come from?
17:43:47 <Gurkenglas> http://hackage.haskell.org/package/MonadRandom-0.4.2.3/docs/Control-Monad-Random.html#v:uniform
17:44:08 <koz_> Gurkenglas: That's brilliant - thank you!
17:48:41 <PhsShft> hi guys, I’m trying to implement this multiply function, but couldn’t seem to get negative cases to work
17:49:07 <geekosaur> don't forget unary - usually needs parentheses
17:49:52 <PhsShft> http://paste.ofcode.org/bxR53zLNQL79X8ur3dbztm here is my code
17:50:10 <PhsShft> *AbstractInteger> multiply five negativeFive
17:50:11 <PhsShft> *** Exception: AbstractInteger.hs:(105,3)-(108,25): Non-exhaustive patterns in function 
17:50:52 <PhsShft> this is the error message,  (add, negator and absolute properly implemented)
17:52:44 <Gurkenglas> koz_, you could factor out that replicateM pattern you have 4 times, something like "let repl = do c <- randC; replicateM c randD" after line 37... you see I'm running out of steam :P
17:53:22 <jle`> PhsShft: what are the constructors for AbstractInteger ?
17:53:23 <koz_> Gurkenglas: That's a good point.
17:53:25 <Gurkenglas> (If you were already using lens, 32-33 would be "i <- id <<+= 1")
17:53:34 <koz_> Gurkenglas: I'm not (yet).
17:53:55 <jle`> PhsShft: and is predecessor partial?
17:54:02 <PhsShft> jle`: it’s a bit long I can code share with you
17:54:11 <jle`> @where lpaste
17:54:11 <lambdabot> http://lpaste.net/
17:54:31 <PhsShft> https://codeshare.io/XIDLU
17:54:32 <Gurkenglas> What's the first Int argument to each Operator constructor do? Perhaps you ought to factor it out
17:55:13 <mheinzel> Gurkenglas: A unique inde
17:55:16 <mheinzel> *index
17:55:42 <jle`> PhsShft: the problem isn't with multiply
17:55:46 <jle`> PhsShft: look at the error message
17:55:58 <jle`> it gives you the line numbrs of where the issue is :)
17:56:07 <PhsShft> jle`: oh 
17:56:58 <PhsShft> jle`: so my Ord AbstractInt lol
17:57:00 <PhsShft> jle`: thanks
17:57:04 <jle`> np
17:57:22 <mheinzel> koz_: A question regarding the Iff and Xor constructors: The a and (NonEmpty a) together make sure you have at least two elements?
17:58:44 <Gurkenglas> Maybe the Int doesn't need to be in the data structure. Could you count where you are while you consume the Formula?
17:59:08 <PhsShft> jle`: omg this is so dumb… i spent 30+ minutes trying different fixes on multiple, and after you pointed out the problem being on the different part.. fixed it in 30 seconds
17:59:14 <PhsShft> jle`: Thank you so much :)
17:59:36 <koz_> mheinzel: Correct.
17:59:46 <koz_> Gurkenglas: I need that for indexing later.
17:59:47 <jle`> no problem!
18:00:04 <Gurkenglas> Can we see the relevant code yet?
18:00:20 <mheinzel> Personally I would just use two "a"s and a regular list then. Especially since you seem to use a partial fromList later.
18:00:47 <lpaste> koz_ pasted “Gurkenglas and mheinzel: Here is the new one, with both suggested improvements” at http://lpaste.net/247416
18:00:50 <mheinzel> It just works on the assumption that you randC is >0.
18:01:04 <joe9> I am trying to translate this to haskell https://gist.github.com/c0aedc4736ede0f071879973bb4230cd but, I cannot figure out how the callbacks can be translated to haskell.
18:01:07 <jle`> today i learned that BLAS is not a library/implementation/software package, but a specification
18:01:09 <jle`> i feel kinda silly now
18:01:09 <joe9> Any suggestions, please?
18:01:12 <koz_> mheinzel: You make a valid point.
18:01:20 <koz_> I'll make that change now.
18:02:08 <jle`> mono-traversable has a list type that has at least two elements, fwiw
18:02:25 <Gurkenglas> I think the do* stuff's a step in the wrong direction, lemme annotate
18:04:55 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
18:04:55 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
18:04:55 --- names: list (clog hzjd cyphase eivarv nomeata systemfault Wizek__ jbomo crobbins osa1__ ekinmur mheinzel fcpga_te jfischoff perrier-jouet WizJin phoenix___ bjz ReinH Insanity_ enolan tsou micmus hsgumby rcshm afcondon cloudhead andyhuzhill dgonyeo codedmart jcp__ etcinit emiliocobos stevenxl zugz gornikm Flyr smwangi P1RATEZ pyon YP-Cloud__ Sgeo_ Orion3k nidr0x kamog copy` nakal_ inteq ryanpcmcquen pkogan paf31 markus1199 fabianvf mizu_no_oto drewbert_ banjiewen)
18:04:55 --- names: list (louispan lambda-11235 zmanian___ kilimanjaro Destol ajmccluskey ype yaknyasn Merv stasku_ nbouscal nkpart incomprehensibly ryantrinkle si14 strmpnk tharper aristid Scorchin Rotaerk etrepum theDon johtso jmathes zipper prefork AntiSpamMeta Xorlev rstone fengshaun augur Sigyn otulp mgsloan nickhs Goplat Zekka arc- MrWoohoo herzmeister argent0 acowley Lord_of_Life deank thewormkill takle alx741 acidjnk TxmszLou zyhn geekosaur cyborg-one nomicflux ilja_kuklic)
18:04:55 --- names: list (marmoute ohsix Levex yqt unclechu isd zort bluezone jnoah JuanDaugherty hjulle_ pingu_ ggherdov thunderrd_ verement oberstein angular_mike_ andreypopp BartAdv henriquev wizonesolutions caw al-damiri MorTal1ty zrl hughrawlinson sephiap bgyss sa1 JonReed mankyKitty tjpeden trig-ger dwarders jlyndon JackMc katymoe_ thewired_ reem quoboo toogood2bgood amatecha dsm alphonse23_ fuziontech PotatoGim OliPicard rann vikram__________ lancetw shennyg groscoe buff3r)
18:04:55 --- names: list (zpconn__________ Sixmsj wyvern Flaeme ocharles_ beckyconning_ bigs spicydonuts w4and0er96 milessabin acertain cgfbee jfokkan__ pchiusano Bengi_ peteretep Sorella solidsnack marcel_ urodna phuu Taylor jonrh NemesisD carter dmoon1221_ tarcwynne_ zph nekomune_ sbauman zero7 tumdedum mpickering kipd stephe metalrain mpw Tritlo Rarrikins APic dstockwell NickSeagull armyriad m1dnight_ theelous3 atomi jml {AS} Akahige newsham glguy bus000_ nilsi_ arkeet wagle)
18:04:55 --- names: list (niklasb hpc tomku wrmsr happy0 skyres wriggle prkc jorj dextertzu StoneToad carlomagno sleblanc jrp6 amiri dibblego joncol tinkyholloway limeburst ps-auxw king_jah adnelson fiddlerwoaroof boj_ ego Shock_ oldmanmike thallada Bez_ kishar Ornedan_ mendez shutdown_-h_now watersoul dcoutts cheater codeman777 notdan kantokomi kav phaazon ar53nic bengt_ Cale wedens sea-gull qryantm Kuros kolko infinity0 ephemeron maerwald spion ManiacTwister avdi strixy-)
18:04:55 --- names: list (iteratee_ smithstonw javax_ hsyl20 eyck_ sgronblo_ diskie_ elgot comboy dh jackhill seliopou Paks neonfuz spoonm edran edwtjo a6a3uh fkurkowski mell drbean srhb magthe chameco bshd tsani Sose nshepperd zv Ninja3047 KeelOfSteel dpower sbrg tg irclogger_com mathu julmac thoros- [exa] Arguggi Soft s4kashya_ abrar johnstein orzo_ topi_ ski kennyp_ masquerade zenzike_ davean Laney aatxe yaiyan qnix yusukesuzuki Pucilowski_ Raynes numberten baweaver ndeine)
18:04:55 --- names: list (benj02 surtn dredozubov niluje bencryption obiwahn dyreshark d3lxa bind tych0 Madars superfatkappa barrucadu kungp jtobin_ monty Starfire Nikotiini buoto pyrtsa Tenkeyless_Cooki Benzi-Junior mudfog jgertm worch henrytill AustinMatherne electrocat alercah phadej ethercrow dxld eddsteel Phillemann niko Sonarpulse goodboytyler officer_raccoon haircode araujo free_beard gpampara vervain SCHAAP137 magicman zoran119 pmade Adios ntpttr potatoe ziman otto_s)
18:04:55 --- names: list (byorgey dolio jamesbvaughan yrdz gseitz pie__ albel727 rgrinberg tristanp trevorriles Factionwars runawayfive lispy jbalint pfoetchen siklsten pikhq liyang robtaylor kolmodin mauke grantwu nont_ zariuq Dunearhp jgornick LuckyRawApe nshepperd_ Ankhers octo_ PlasmaStar joeyh Natch trism lanodan cmr Morgawr ent texasmynsted 7YUAAAF28 bcoppens eL_Bart0 kshannon staticfox Forlorn netblaze hodapp int-e M2tias kosmikus zerokarmaleft bd_ jophish folsen pygospa)
18:04:55 --- names: list (ephess_ riehfp suzu geppettodivacin hamishmack catgirl shookees Jinxit shapr metaf5_ hive-mind kipras`away joe9 slackircbot SAL9000 angerman _kit_ jtcs_ horatiohb odamn adarqui statusbot lhynes foobars mattp_ ijp dan64 fycth aarvar Adeon nopf mrm l3france [swift] ddima ngWalrus ft Fubar^ naudiz rotcpy spacebug urdh tdammers Akii dschoepe epta m0rphism daf ec\ AppleJacks24 ramatevish yeltzooo richi235 DDR emmflo sujeet xxpor Igloo bjs jrslepak tusj)
18:04:55 --- names: list (Intensity Drezil dpepsilon carter-znc Bigcheese clever yorick __main__ obihann luis` simony dedgrant Philonous nwf Rodya peddie flebron hiptobecubic_ adamCS martingale grol chattered electrostat Nycatelos avn Guest7667 s4kashya1 haasn daishan logcat dcoutts_ zudov scared jud dmiles joncfoo hvr georgew kyagrd chriswk grandy da-x_ dpn` tgeeky jzl xaimus sns niteria t0m0 ClaudiusMaximus hiratara opios fr33domlover nathanic _6a68 squisher kus_ubuntui686 moei)
18:04:55 --- names: list (valkyr2e greenbagels marmalodak beaky mt cyberlard iphy petercommand knack cocreature xnyhps juhp valdyn ortmage_ qinusty CurryWurst wting eatonphil cdsmith_ stelleg shymega voorhies sbjorn cjh` Athas sivs staffehn miklcct intelux aloiscochard sparr BlueRavenGT t0mb0_ acfoltzer vikraman frug72 Klumben gnusosa minsky xacktm Guest89002 cjwelborn killerpty brian[m] codebam solatis SeriousBug[m] ario sjl_ greeny lattenwald koomi sshine Hijiri Guest10767)
18:04:55 --- names: list (tippenein SenpaiSilver pieter klugez jkarni higgs jle` hiredman ongy thomas1 JRHaigh pleiosaur trampi cic jrib1 Maxdamantus ludat froztbyte funfun Ravana geal Tuplanolla karls bshelden MindlessDrone asm89 Purlox martinr_ Yuras bb010g[m] M-krsiehl M-david SShrike davidar brixen nitrix bsmt M-wamaral tagada[m] srenatus[m] descender KaneTW statusfailed wrengr_away Kneiva jlewis oelewapperke Freundlich PHO andjjj23_ Guest65558 dredozub- Myrl-saki hemite kini)
18:04:55 --- names: list (HalfEatenPie M-schmittlauch Profpatsch[m] M-Quora Gurkenglas KireinaHoro[m] haldean exferenceBot adraenwan Kruppe lulf_ larion_ BrianHV_ japesinator_ padre_angolano monochrom tumi JPohlman1 joehillen c-rog Shou Lokathor nmattia whoops jluttine LordDeath dfeuer Reyu sebastian-w marens tnks tokik taktoa _xor justanotheruser nathyong_ deni besenwesen max-m x1n4u hariel ctag Askanison marienz _Shandy siddhu carado heurist irishsultan Deadhandd hex0punk1)
18:04:55 --- names: list (xinming schjetne iross greymalkin sag3 flonk Baughn dunj3 meta-coder bluepixel scopedTV angseus_ Frankablu_ ao1ei8 johl MitchW toure gargawel parenthetical ninefingers ppnkk ncl28 kriztw sajith kwantam Bashmetim LeaChim Ranhir thorkilnaur_ nille mmierz RGamma Fylwind heinrich5991 kqr Hermit cross monkeyiq zymurgy Willis K0HAX brolin_empey treehaqr emeritus lambdabot Ezku_ EvanR chronon-io_ Fuuzetsu etabot joeytwiddle mantovani brent betawaffle bob_twinkles)
18:04:55 --- names: list (amiller Tene Gothmog_ hxegon jpl_ relrod Ke Marqin nickpascucci osfameron sphaleri1e fabiopbx canta nilOps exio4 tv n__dles Belgarion0 Desu lukky513 stux|RC-only mrowe c_wraith jaimguer hydraz jimki_ eagleflo_ Jaak_ mgaare ido mrd kloeri koala_man Phyx- mmaruseacph2 tjt Trippy oldsk00l caasih bitonic giraffe_ cantstanya buttbutter mada SolarAquarion alem0lars IndigoTiger ipuustin Amadiro_ PalTale indiffernet mrlase BigTrouble kurnevsky Moyst otterdam)
18:04:55 --- names: list (implementation bananagram linduxed johnv_ gniourf ircbrows- xfix Tehnix wamaral lpsmith Guest49740 anoe bjobjo juri_ cnr XMunkki cynick reynir cin orcus donwilliam rodlogic ybit hbar_ Majiir spaceships tazjin noctux alang noexcept fingerzam xa0 Hakey steeze squimmy Biohazard_ Elsi_ mimi_vx brian1 dzack1 DustyDin1o mkloczko_ absence_ mikeizbicki wjm hyPiRion_ taruti shwouchk_ tjbp_ burp DigitalKiwi BrAsS_mOnKeY Chousuke jinblack` idupree2 Edoxile Ulrar_)
18:04:55 --- names: list (carc SLi saidinwot1 Geekingfrog_ theolaurent gabiruh mikeplus32 gridaphobe ssedov cschneid- JDevlieghere Diabolik dfranke_ prooftechnique flux gothos riscool_ solarus__ tekacs Liskni_si CARAM__ adulteratedjedi snoogie krgn Rembane_ codebje eyenx amontez prose[m] TabAtkins kaste dustinm shans_ ajaniMember todd_killings[m] garphy`aw iskander brisbin ynyounuo Guest6851 jvanbure mbwe cYmen chirpsal1 jstolarek theorbtwo nerdystreetrat Amun_Ra tctara zhulikas)
18:04:55 --- names: list (sLite Reisen LeNsTR|away sm amx tswett isomorphismes Stratege_ tomus brennie unbalanced navilan wayne pdgwien hausdorff bitemyapp LnL poga unsymbol nikolah parsnip _drazil coeus _ashbreeze_ bbee kjanosz Guest81638 lassulus Deewiant oherrala fxrs myfreeweb lachenmayer PanicSkittle pelegreno___ Lutin` psmolen alunduil benzrf Rabbit_ Xandaros SparkySparkyBoom mceier yarou ernst swistak35 filibustr Twey lyxia lstrano Profpatsch trajing Eagle_Erwin s4kashya)
18:04:55 --- names: list (imalsogreg aweinstock qknight Vq xplat Zemyla RevJohnnyHealey 14WAAABDB platz saurik quuxman __rlp liste m1dnight` RageD nurupo schultz ycheng Hafydd qmm freekevin mak` Saimeidae ben vodkaInferno eamelink cjay so Sagi SiCC RazorX- Oxyd ChongLi urh_ tek0_ cow-orker tero- dqd benjamincrom fmapE supki jix mbrock ccomb hc jrpls killtheliterate eikke wildlander qlkzy e hansihe rmarko jokester integral mw anderson __name__ Desoxy ollef Speed jw358 bogdanteleaga)
18:04:55 --- names: list (fairfieldt cdidd ryantm aaron7 swhalen tolt Saizan mariothemad cods ReinH_ andreass davl samgd Jonno_FTW vqrs glowcoil mjrosenb_ Bane^ ab9rf Gloomy wtw segmond Taneb Dykam Elision Forkk esssing vin-ivar bounb KorriX drdo rom1504 acro sclv shelling__ esmiurium Guest6986 Ring0` reactormonk arianvp owickstrom alpounet baetheus Xnuk guios tristero obadz dhananjay Ewout MarcelineVQ norotartagen djm CindyLinz radek1 fergusnoble Wamanuz2 vfs gienah CosmicRay)
18:04:55 --- names: list (frontendloader ggVGc vishesh xocolatl citaret anachrome bsermons raek hpd capisce arrdem tabaqui Jello_Raptor cdk_ rootmos wildleaf jchia p_q kandinski luite quaestor Eliel irrequietus loopspace rfw ristos thoughtpolice jorendorff_ lexi-lambda mindos_cloud____ fall_ abbe chrzyki ricardo82 pdxleif bydo abh yamadapc xtal borkdude a3Dman SegFaultAX zxtx ali_bush gsingh93 Qommand0r rbocquet _flow_ troydm eronel hegge josephle rotty MasseR s4msung ahihi)
18:04:55 --- names: list (robogoat chelfi rossberg o`connor hongminhee divVerent ploop kaol Nahra keko-2 pikajude taksuyu Khisanth lordcirth Quintasan sqrt2 mk-fg tessier robin Neo atk mrBen2k2k2k catsup_ icedev alanz chbatey Tinchos PennyNeko S11001001 rlr mvr_ xplat|work adelbertc monad_cat GGMethos_ SuperTux88 lucz jmct raid madknight mkurkov Noldorin mno2 lpaste xenti3 brezel wolfcore chris2 Jaxan johnw cbaines_ sohum teppic TimWolla danthemyth SlashLife fyolnish codehero inr)
18:04:55 --- names: list (prohobo ElderFain Tesseraction rockfruit sim642 timrs2998 yulax akermu minad plutoniix fnordbert rembo10 ixian scinawa1 pflanze christiansen` pharaun andromeda-galaxy hackagebot sevas jotrk a____ptr ryoia yminsky cmdv sdemos Filthy_casual sisir___ g4k billstclair edwardk dmh joedevivo runeks amalloy kier bhiliyam dax CaptainLex_ jibi feth1 m4lvin bdeferme fractalcat mnoonan YellowOnion erikd ericsagnes zaquest eell fugyk Jesin Nik05 chrpape Blkt dud)
18:04:55 --- names: list (fryguybob Clint uwap suppi knyppeldynan astocko hanDerPeder kmicu Matajon schnizzle sleepynate Xe herzen ronstra Sonderblade Chobbes fold4 Cathy ljhms grumble calloc kyren koray anemecek _janne thebnq xaxisx IanKelling bgamari Ralith_ djapo kian opqdonut mitchty earthy asjo TrevorBramble bairyn sdx23 elementalest simukis_ revprez dkettman danza qguv felixsch kosorith dmwit codesoup ksf darkf sdothum rdesfo[m] ashishne_ ahf lukexi jlouis nesqi AlainODea)
18:04:55 --- names: list (ericbmerritt defanor whiteline nyuszika7h Tharbakim mdarse nshepperd1 Soup nek0 majoh Guest11138 DANtheBEASTman Boreeas przembot mads-_ bartavelle armlesshobo noplamodo_ luigy_ telmich `0660_ Vbitz sleezd lieven zomg Princess17b29a Voldenet tomaw seagreen @ChanServ posco Axman6 Brando753-o_O_o sdrodge pacak amuck moop leat2 ion Enigmagic majjoha guampa heyj jroesch_ seanparsons alex_lu mbrcknl spinda crough vinnie92 huonw sword_smith dogui phaskell)
18:04:55 --- names: list (phaskell-2 mero abra0 arw_ joachifm leothrix hucksy jokleinn hexagoxel sooheon falafel daey Vektorweg11 koz_ pkmx[m] M-mistake M-Illandan radix1 jamon[m] M-Magnap M-Shrike helloworld1[m] lspitzner UnlikeSuika andy____ mokus dilinger)
18:05:24 <lpaste> Gurkenglas annotated “Now with 100% less Reader” with “Not everything deserves a name (ie sour-graping being bad at naming)” at http://lpaste.net/247392#a247422
18:05:59 <koz_> Gurkenglas: Ah, I see. That's a bit more repetitive than I prefer, but I kinda see your point.
18:06:48 <Gurkenglas> Repetetive where? In the i part? I agree lemme annotate some more :P
18:07:17 <koz_> Gurkenglas: Yeah, I was wondering how I could pull out that i.
18:07:51 <mheinzel> Gurkenglas: No, don't factor it out! Readability will not improve :D
18:10:52 <mheinzel> koz_: Does an Or of an empty list make sense for you (it definitely could)?
18:11:01 <koz_> mheinzel: Yes. Same with And.
18:11:36 <koz_> mheinzel: The evaluator algebra relies on 'or' and 'and' respectively here.
18:12:38 <mheinzel> koz_: You don't need lists in Operator at all.
18:13:12 <mheinzel> koz_: But maybe there are reasons to have them in your situation.
18:13:46 <mheinzel> Or [a,b,c] = Or a (Or b c)
18:14:21 <koz_> mheinzel: Yes, but that gives me trees of linear depth on 'runs' of expressions like that.
18:14:32 <mheinzel> koz_: Makes sense.
18:17:30 <koz_> On a somewhat-unrelated note: This article (http://blog.sumtypeofway.com/recursion-schemes-part-iii-folds-in-context/) talks about R-algebras in the context of paramorphisms. Is there such a thing as an L-algebra?
18:17:31 <mheinzel> koz_: Then, I think we covered the greater part.
18:17:50 <koz_> mheinzel: Thank you - my code is better for your advice.
18:20:42 <lpaste> Gurkenglas annotated “Now with 100% less Reader” with “mheinzel, challenge accepted” at http://lpaste.net/247392#a247444
18:21:30 <koz_> Gurkenglas: That is very impressive.
18:22:36 <mheinzel> koz_: Can you give a final paste of it?
18:23:00 <koz_> mheinzel: Sure - this will be without Gurkenglas' suggestions, as I'm not that fast a typist.
18:23:55 <mheinzel> Gurkenglas: This would change the structure of the whole Formula type, though.
18:24:07 <lpaste> koz_ pasted “mheinzel: More pudding!” at http://lpaste.net/247447
18:24:23 <Gurkenglas> mheinzel, I'm betting it's more elegant to consume this way too
18:25:45 <mheinzel> Gurkenglas: But nice. I'm not sure about the typechecking though. One thing is the functor instance of Annotated.
18:26:12 <mheinzel> Gurkenglas: Will that work as intended?
18:26:18 <koz_> mheinzel: I think so.
18:26:23 <koz_> >fmap (+1) (2, 3)
18:26:29 <koz_> > fmap (+1) (2, 3)
18:26:32 <lambdabot>  (2,4)
18:26:35 <Gurkenglas> Ah yep we might need Compose there
18:28:40 <koz_> mheinzel: So you approve? Should I begin the refactoring?
18:29:02 <lpaste> Gurkenglas annotated “Now with 100% less Reader” with “Let's get this dirty indexing as far away from the actual code as possible” at http://lpaste.net/247392#a247452
18:29:21 <koz_> Wait, what's Compose?
18:29:45 <Gurkenglas> oh wait go's got an argument
18:30:19 <mheinzel> koz_: I'm not sure it will work out nicely, yet.
18:30:30 <koz_> :t Compose
18:30:31 <mheinzel> But I will try.
18:30:32 <lambdabot> error:
18:30:32 <lambdabot>     • Data constructor not in scope: Compose
18:30:32 <lambdabot>     • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
18:31:23 <lpaste> Gurkenglas revised “Let's get this dirty indexing as far away from the actual code as possible”: “Oh, wasn't so bad.” at http://lpaste.net/247452
18:31:46 <koz_> Gurkenglas: Beautiful!
18:31:54 <koz_> But could someone please tell me what Compose is all about?
18:32:03 <Gurkenglas> koz_, http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html
18:32:53 <Gurkenglas> Oh shoot anaM wants a monad
18:33:31 <Gurkenglas> then we might need a special case of Compose that gives us a monad instance - they're called monad transformers
18:33:49 <koz_> Gurkenglas: That link gives me an 'it's not here'.
18:33:57 <koz_> Gurkenglas: So, ComposeT?
18:34:18 <Gurkenglas> koz_, http://webcache.googleusercontent.com/search?q=cache:http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html
18:34:33 * hackagebot clckwrks-plugin-page 0.4.3.5 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.3.5 (JeremyShaw)
18:34:42 <Gurkenglas> No, that would be general in the monads to be composed, but monads dont compose in general
18:34:51 <koz_> Gurkenglas: True.
18:35:11 <Gurkenglas> I mean the special case (Compose ((,) a)), because ((,) a) does compose with any monad into a monad
18:35:19 <mheinzel> Gurkenglas: Why not just a newtype Annotated with hand-writted Functor instance?
18:35:44 <Gurkenglas> mheinzel, then we could use Compose - we need a monad instance
18:36:14 <koz_> Gurkenglas: A newtype Annotated with a hand-written Monad instance, then?
18:36:25 <Gurkenglas> No, someone else already hand-wrote it
18:38:18 <Gurkenglas> Wait, what am I saying? anaM doesn't need Annotated Operator to be a monad, just the m in MonadState and MonadRandom ._. Annotated Operator is the Traversable
18:38:34 <Gurkenglas> The hand-written one I meant is WriterT.
18:38:44 <koz_> Does Compose give us Traversable 'for free'?
18:38:59 <Gurkenglas> http://hackage.haskell.org/package/transformers-0.5.1.0/docs/Data-Functor-Compose.html "(Traversable f, Traversable g) => Traversable (Compose * * f g)" yep
18:39:09 <koz_> So it works? Yay!
18:39:17 <koz_> mheinzel: Thus, I should start writing?
18:39:28 <Gurkenglas> Who knows? The typechecker'll tell you :P
18:39:50 <koz_> Gurkenglas: OK. I can see that only an older transformers seems to have Compose, for some reason.
18:40:09 <Gurkenglas> Newers have it too, but the documentation is not on hackage yet
18:40:13 <koz_> Ah, OK
18:40:17 <koz_> That's easy, then.
18:40:25 <Gurkenglas> http://hackage.haskell.org/package/transformers-0.5.2.0 shows you "Data.Functor.Compose" without a doc link
18:40:27 <koz_> Shall begin my rewrite. Thank you for all the help and advice!
18:43:25 <lpaste> Gurkenglas revised “Oh, wasn't so bad.”: “(Oh hey I can eta-reduce out the t, and then Annotated doesn't seem so name-deserving anymore and it looks like nobody got the pun of this being an Annotation anyway)” at http://lpaste.net/247452
18:50:44 <koz_> Gurkenglas and mheinzel: http://lpaste.net/247392#a247470
18:54:07 <Gurkenglas> Another one of those times where you want type error slicing. I'd start adding annotations. Oh and lets see whether lambdabot has those modules
18:54:29 <Gurkenglas> @letlpaste 247470
18:54:30 <lambdabot>  .L.hs:43:1: error:
18:54:31 <lambdabot>      Failed to load interface for ‘BasicPrelude’
18:54:31 <lambdabot>      Use -v to see a list of the files searched for.
18:55:01 <Gurkenglas> dang kids using nonstandard preludes
18:55:04 <mheinzel> Gurkenglas: You need the annotated type for the randOp type declaration too.
18:55:35 <Gurkenglas> what why
18:56:22 <mheinzel> Gurkenglas: Ah no, sry. Just go need it.
18:57:10 <koz_> Gurkenglas: So you suggest adding type annotations to 'go'?
18:59:07 <koz_> Gurkenglas: Should 'go' have the type 'MonadRandom m => Int -> m (Compose ((,) Int) Operator)'?
18:59:11 <Gurkenglas> Yea, adding "go :: MonadRandom m => Int -> m (Compose ((,) Int) Operator)" makes it obvious that "Compose $" doesn't work here
18:59:22 <koz_> Gurkenglas: We need to fmap it in, right?
18:59:39 <Gurkenglas> yep
19:00:23 <lpaste> Gurkenglas revised “koz_, try this”: “and now with the in-channel pasting” at http://lpaste.net/247479
19:00:39 <Gurkenglas> (annotation still in there in case we get another error)
19:01:03 <koz_> Gurkenglas: The type is incomplete. I believe it should be: go :: MonadRandom m => Int -> m (Compose ((,) Int) Operator Int)
19:01:22 <koz_> (or something - the Operator has a type variable we need to take care of too)
19:01:40 <Gurkenglas> yes of course. a is Int
19:02:34 <koz_> It complains that we have 'm1 (Compose ((,) ()) Operator Int)' instead of 'm1 (Compose ((,) Int) Operator Int)'.
19:02:34 <Gurkenglas> Oh, I thought you wrote a there instead of Int, you got it right. (If it compiles, you can also load it up in ghci and ask it for the type of gooooooo actually no you cant its in a where block ._.)
19:03:09 <koz_> (the error is triggered at 'Compose <$>')
19:03:14 <lpaste> Gurkenglas revised “and now with the in-channel pasting”: “._.” at http://lpaste.net/247479
19:04:54 <koz_> Gurkenglas: OK, fixed!
19:05:04 <koz_> Needed to add a MonadState Int m constraint there.
19:06:14 <koz_> Gurkenglas: Suppose I wanna ignore the annotations. What would the skeleton of such an anamorphism look like?
19:06:48 <Gurkenglas> sure that too. hrrm wrestling with a compiler via IRC middlemen is sad. What do you mean by any part of anything in that line :D
19:07:31 <mheinzel> koz_, Gurkenglas: I'm going to sleep now. Thanks for the discussion!
19:07:35 <koz_> Gurkenglas: Never mind. I'll try writing it myself, then ask something more specific.
19:07:39 <koz_> mheinzel: Thanks for all your help!
19:08:48 <mheinzel> And I hope you will be successful!
19:08:53 <koz_> Gurkenglas: So wait. 'Compose ((,) Int) Foo' is just (Int, Foo)?
19:09:34 <Gurkenglas> Yes, with all the instances attached - just like StateT s m a is just s -> m (a, s)
19:09:49 <koz_> Gurkenglas: OK, so suppose I need one of these: Compose ((,) Int) Operator Bool -> Bool
19:09:57 <koz_> And I already have a 'Operator Bool -> Bool'.
19:10:03 <koz_> (i.e. I don't care about the annotations)
19:10:18 <koz_> What would I need to add to make that work with the new representation?
19:12:03 <koz_> Gurkenglas: Would it just be 'fmap'?
19:12:25 <Gurkenglas> :t (?f :: String -> Bool) . snd . Data.Functor.Compose.getCompose
19:12:27 <lambdabot> (?f::String -> Bool) => Data.Functor.Compose.Compose ((,) a) [] Char -> Bool
19:12:59 <koz_> Ah, so you unpack, grab the bit you care about, then do your thing.
19:14:08 <koz_> Yay, thank you!
19:34:34 * hackagebot jsaddle 0.5.0.2 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.5.0.2 (HamishMackenzie)
19:49:03 <jle`> is there some common type used that has either "one or two" values a type?
19:49:18 <jle`> (a, Maybe a), or Either a (a, a)
19:57:06 <c_wraith> jle`: I think the neither package does that
19:57:33 <c_wraith> No, that's not it.
19:57:38 <c_wraith> I know I've seen it
20:00:38 <grantwu> Is there something like unpl but which applies more nuanced rules?
20:00:47 <amalloy> These
20:00:51 <amalloy> oh, no, misread
20:01:21 <grantwu> i.e. get rid of all compositions where the function on the left requires more than one argument to become "fully applied"
20:06:56 <koz_> :t sequenceA (10, Just 20)
20:06:58 <lambdabot> (Num t, Num a) => Maybe (t, a)
20:07:07 <koz_> > sequenceA (10, Just 20)
20:07:10 <lambdabot>  Just (10,20)
20:11:43 <saulzar> Is anyone here familiar with the library 'syntactic'? I'm curious as to how the observable sharing works - pre version 2.0 it seems to use stable names like data-reify.. and a graph representation - but that seems to have changed
20:32:44 <PhsShft> how would you write/structure a recursively defined modulo function that follows Euclidean division? meaning that the remiander is always positive.
20:33:39 <PhsShft> for example, -10 `mod` 3 gives you 2 as -10 = 3*(-4)+2, but 10 `mod` 3 should give you one
20:33:53 <PhsShft> I’m trying to get the logic here but can’t seem to exhaust options
20:34:35 * hackagebot nvvm 0.7.5.0 - FFI bindings to NVVM  https://hackage.haskell.org/package/nvvm-0.7.5.0 (TrevorMcDonell)
20:41:58 <Maxdamantus> > let a = -10; b = 3 in take 50 $ iterate (\n -> n - signum (n `div` b)*b) a
20:42:00 <lambdabot>  [-10,-7,-4,-1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
20:43:24 <PhsShft> :Maxdamantus what if you have to define div in terms of mod? how is haskell implementing mod internally? is there a site to look it up?
20:43:46 <Maxdamantus> Well, it's using `div` for a silly purpose there. It doesn't require actual division.
20:43:52 <koz_> jle`: I followed your advice and tried to write what I want from scratch. I wanna see how I would convert what I've written so far to use recursion schemes. Here is what I have so far: http://lpaste.net/247601
20:44:15 <koz_> Anyone who isn't jle` who could help me is, of course, warmly welcome.
20:44:21 <Maxdamantus> It's just used because n `div` b == 0 if it's already in range.
20:45:39 <PhsShft> Maxdamantus: I got it, I forgot the signum function, there should be a way without any division
20:46:07 <Maxdamantus> Sure, you can trivially break the above mechanism up into cases involving >= and <
20:48:15 <Maxdamantus> > let a `mod` b | a < 0 = (a + b) `mod` b | a >= b = (a - b) `mod` b | otherwise = a in (-10) `mod` 3
20:48:17 <lambdabot>  2
20:49:54 <PhsShft> :Maxdamantus thanks
21:28:50 <dmiles> is cabal-1 different that cabal? 
21:33:28 <pavonia> dmiles: Where is cabal-1 from?
21:33:49 <dmiles> looks like from  2014.2.0.0
21:34:16 <pavonia> I mean where do you see that?
21:34:44 <dmiles> oops . i had that backwards its in 2010.2.0.0  .. /cygdrive/c/Program Files (x86)/Haskell Platform/2010.2.0.0/lib/extralibs/bin/cabal-1
21:35:13 <dmiles> its called from a legacy plugin called EclipseFP trying to make a class tree
21:35:59 <dmiles> i am going to port it .. but was wondering if cabal-1 was supposed to be an okld version of a frozen api
21:38:03 <pavonia> No idea, I don't have such a file in my installation
21:38:28 <Gurkenglas> koz_, should 32+33 really reuse i?
21:40:46 <dmiles> i decided to copy it over and it works
21:41:05 <dmiles> cabal-1.exe: failed to parse output of 'ghc-pkg dump'
21:41:23 <Cale> dmiles: What version of GHC are you trying to use it with?
21:41:59 <Cale> If it's from 2010, you'll probably need 6.12.3
21:42:08 <dmiles> oh woerd i have three versions in my path.. thougth i only had 2
21:42:10 <dmiles> The Glorious Glasgow Haskell Compilation System, version 8.0.1
21:42:33 <dmiles> cabal-install version 1.24.0.0
21:42:33 <dmiles> compiled using version 1.24.0.0 of the Cabal library
21:42:36 <Cale> Can you somehow avoid using such an old version of the Haskell Platform?
21:43:05 <Cale> Well, that cabal is recent
21:43:26 <dmiles> oh yes i can.. but i need to be able to make sure i can model the features of the old scripts
21:43:42 <dmiles> the old scripts are the things that genrate class trees and such
21:43:48 <lpaste> Gurkenglas revised “Need help converting to recursion scheme”: “koz_, well first here's some help with the wrappety” at http://lpaste.net/247601
21:44:04 <dmiles> ok.. Cale, going to get all modern on the platform now
21:44:24 <Gurkenglas> (What is to happen with the other cases of Operator?)
21:53:34 <dmiles> ok old stuff washed away.. stiull have EclipseFP "wanting to all" cabal-1.exe
21:53:48 <dmiles> "wanting to call"*
21:54:21 <dmiles> i ported the plugin to the bleeding edge of eclipse.. now need to port some of its scripts to modern Platform
21:54:34 <lpaste> Gurkenglas revised “koz_, well first here's some help with the wrappety”: “koz_, this one uses ekmett's arcane grownup take on Fix, because it provides para” at http://lpaste.net/247601
21:57:33 <lpaste> Gurkenglas revised “koz_, this one uses ekmett's arcane grownup take on Fix, because it provides para”: “(Actually I forgot to lift Fix into the monad again, as I did with Compose earlier)” at http://lpaste.net/247601
21:58:34 <Gurkenglas> And maybe I shouldn't have edited all this onto your paste lol
21:59:03 <Gurkenglas> (psa tho you can find all the previous versions of a paste under Expand)
22:01:14 <koz_> Gurkenglas: Ah, I see.
22:01:19 <koz_> Figures Lens would have the answers...
22:02:15 <koz_> :t uncurry
22:02:17 <lambdabot> (a -> b -> c) -> (a, b) -> c
22:02:19 <Gurkenglas> (You can skip lens if you can bear the wrappety)
22:02:29 <koz_> Gurkenglas: I think so. I was going along that route anyway.
22:02:39 <koz_> Gurkenglas: So I should be using a paramorphism, *not* a catamorphism, here?
22:02:54 <koz_> (I have an implementation of paraM I wrote)
22:03:13 <Gurkenglas> I think so, because you sometimes want the original x, and sometimes the mutated one
22:04:09 <koz_> Gurkenglas: OK, that helps a lot.
22:04:19 <koz_> I was thinking I was doing something wrong by using a catamorphism there.
22:04:27 <koz_> But even as a paramorphism, that's *painful* to write.
22:06:11 <Gurkenglas> At which part? The rebuilding?
22:07:12 <koz_> Gurkenglas: Yes.
22:07:17 <koz_> Also, wtf GHC: (Int, Operator (Fix (Compose ((,) Int) Operator), Formula))
22:07:27 <koz_> Isn't that just (Int, Operator (Formula, Formula))?
22:08:51 <Gurkenglas> Can I have 38 use i because it isn't otherwise in use anymore?
22:10:03 <koz_> Gurkenglas: I... guess? I'm just trying to write this all myself.
22:10:15 <koz_> It'll likely take me a while - ${EXCREMENT}-tonne of cases.
22:12:43 <Gurkenglas> koz_, I think you forgot to remove the previous index in 39
22:18:18 <koz_> Gurkenglas: This is officially doing my head in.
22:18:32 <koz_> Let me read what you wrote again.
22:19:02 <lpaste> Gurkenglas revised “(Actually I forgot to lift Fix into the monad again, as I did with Compose earlier)”: “Okay lemme factor out some is. Less painful on the eyes?” at http://lpaste.net/247601
22:19:44 <johnw> koz_: isn't Fix (Compose ((,) Int) f) the same as Cofree f Int?
22:20:49 <koz_> johnw: I wouldn't know.
22:21:12 <Gurkenglas> So it is, huh. Does something provide paras for that?
22:21:14 <koz_> If that's the case, maybe it might make what I'm doing a bit simpler.
22:21:21 <koz_> Yeah - where can I find Cofree?
22:21:28 <johnw> in the 'free' package
22:22:05 <johnw> what is it that you're trying to do?
22:22:21 <Gurkenglas> http://hayoo.fh-wedel.de/?query=Cofree
22:23:08 <koz_> johnw: I have an expression tree, with each node indexed by a unique Int. I wanna randomly select an index, navigate down into it, and randomly mutate it with by means of a randomly-chosen operation, from a set depending on the kind of node I have.
22:23:18 <koz_> Alternatively, I can link you the code I have so far. One sec.
22:24:37 <koz_> johnw: http://lpaste.net/247761
22:25:01 <koz_> I've been using recursion schemes to great effect with this so far, but this mutation one is *murdering* my brain.
22:25:13 <koz_> If I can use Cofree to make this simpler for myself, I will happily do so.
22:25:20 <johnw> which is the murdering part?
22:25:52 <koz_> The part that I described above - the 'mutate the expression tree' operation.
22:26:00 <koz_> johnw: I have an expression tree, with each node indexed by a unique Int. I wanna randomly select an index, navigate down into it, and randomly mutate it with by means of a randomly-chosen operation, from a set depending on the kind of node I have.
22:26:03 <koz_> ^ that
22:26:10 <johnw> ok
22:26:15 <koz_> I've tried writing it several times, with Gurkenglas's help, and I'm still hopelessly lost.
22:26:44 <johnw> can you show me the best thing you had so far?
22:27:29 <koz_> johnw: http://lpaste.net/revision/247601 <-- this is the part I started on
22:27:42 <koz_> Gurkenglas tried to improve on it, but my head hurts just trying to make sense of what's going on there.
22:27:46 <koz_> (I've been at this all day)
22:30:25 <johnw> and how would you like to mutate it?  By changing an And into an Or, that kind of thing?
22:31:17 <koz_> johnw: For Atom, either change its Int, or generate a new pair of indices and Ints, and replace that Atom with an And, Or, Xor, If, or Iff with new atoms based on those indices and Ints.
22:31:27 <koz_> For And, either add a new Atom or trim a branch.
22:31:34 <koz_> Or switch operator.
22:31:41 <koz_> Same for Or, Xor, Iff, and If.
22:32:07 <koz_> For Neg, remove it (so just 'hoist' whatever it was negating up the expression tree).
22:32:47 <koz_> Would writing each of these sub-operations as separate functions be a sensible thing to do?
22:32:57 <johnw> well, that can never hurt, but let me think for a sec
22:33:07 <johnw> if I understand right, what you want to do should be very easy to express
22:33:25 <koz_> Using Cofree, or what I have already?
22:33:30 <johnw> Cofree
22:33:37 <koz_> OK, that's promising.
22:33:47 <koz_> Would the same be true of all the other stuff I wrote for it?
22:34:42 <johnw> you have Cofree Operation Int.  What you want is: at a particular value of Int (and this may result in non-termination), exchange the Operation for another under the effects of MonadRandom, meaning going to Cofree (m Operation) Int.  Then you want to go to m (Cofree Operation Int).  I'm trying to think now whether this makes sense for your Formula comonad.
22:35:09 <johnw> (or rather, Cofree (Compose m Operation) Int)
22:35:26 <johnw> let me see if that makes sense at all in general
22:42:15 <johnw> koz_: example: https://gist.github.com/df4cf1a4f36d1313200ab3f9e6ce2150
22:43:12 <koz_> johnw: OK, what am I looking at here?
22:43:19 <koz_> I dunno anything about Cofree at all, sorry...
22:43:42 <johnw> this searches for the tree location at index "n", and mutates it under the effects of 'm'
22:43:46 <johnw> located*
22:44:17 <johnw> here I've mutated a Neg into an If
22:44:33 <johnw> change to MonadRandom if you want to use random effects for the mutation
22:44:33 <koz_> johnw: Will you be here for a while? I wanna try and get the hang of Cofree by rewriting the stuff I already have into it.
22:44:48 <johnw> sure; I mean, Cofree is exactly the Fix type you were using, so there's nothing new here
22:44:58 <johnw> except that it's automatically a Comand now
22:45:01 <johnw> Comonad
22:45:09 <koz_> johnw: But I obviously won't be able to use cataM and paraM like I am in my stuff, right?
22:45:35 <johnw> sure you can, because in Haskell, data and codata coincide
22:45:56 <johnw> if you didn't have the "Atom" case, then you wouldn't be able to use cataM
22:46:34 <koz_> Is there an operation on Cofree similar to the cataM I'm using?
22:46:39 <koz_> (or anaM, for that matter...)
22:47:34 <koz_> Wait, hold on one second. coiter = anamorphism?
22:47:48 <johnw> correct, it corresponds to that
22:48:17 <koz_> OK, that's good. But what if I wanna have a *monadic* anamorphism?
22:48:37 <koz_> Is that unfoldM?
22:48:55 <johnw> correct
22:49:06 <koz_> OK, so what's the primary difference between coiter and unfold?
22:49:38 <johnw> unfold separate the seed type from the carrier type
22:49:54 <johnw> it gives you 'a' and 'b'
22:50:07 <koz_> johnw: The 'carrier type' being 'the type the Cofree is of', I take it?
22:50:22 <johnw> Cofree f a <--- 'a' being the carrier type here
22:50:27 <koz_> Ah, OK.
22:50:38 <koz_> So in my case, since I have Cofree Operator Int, my carrier is 'Int'?
22:50:44 <koz_> s/carrier/carrier type
22:50:52 <johnw> yes, but I may be misuing the term 'carrier', so let's just say the base type or something
22:51:07 <koz_> OK, sure.
22:51:25 <koz_> Now, is there an equivalent operation for Cofree to catamorphism?
22:51:42 <johnw> built-in, no
22:51:52 <koz_> johnw: :(
22:51:54 <johnw> because termination depends on the structure of 'f'
22:52:05 <johnw> but you can easily write a cataM for your type
22:52:09 <koz_> Yeah, it could be an infinite stream or something.
22:52:10 <johnw> because your 'f' *does* terminate
22:52:23 <johnw> you just can't write a total definition of cataM for any Cofree f
22:52:29 <koz_> OK, I understand.
22:52:35 <koz_> Let me just guess at the signature.
22:52:49 <koz_> Functor f => (f a -> a) -> Cofree f a -> a?
22:53:29 <johnw> i don't think that's quite it
22:53:38 <johnw> because that doesn't handle the 'a' that occurs at each position along the stream
22:53:53 <johnw> let me try
22:54:42 <johnw> I think something along these lines:
22:54:43 <johnw> cocataM :: Functor f => (a -> f b -> b) -> Cofree f a -> b
22:54:44 <johnw> cocataM k (x :< xs) = k x (fmap (cocataM k) xs)
22:55:02 <koz_> Ah, I see.
22:55:49 <koz_> So the monadic version would be something like :: (Monad m, Traversable f) => (a -> f b -> m b) -> Cofree f a -> m b?
22:55:58 <johnw> yeah, I think so
22:56:20 <koz_> And in the definition, you just replace 'k' with (k =<<) and fmap with traverse?
22:56:26 <johnw> I think you'll need an extra argument of type 'b'
22:56:39 <johnw> to become the base case when the b turns into a phantom in the final 'f b'
22:57:40 <koz_> johnw: OK, I'm gonna try and put that into practice. Please give me one second to do some updating.
22:58:41 <johnw> this still isn't right
22:59:07 <johnw> there's no way for your function (a -> f b -> m b) to choose an "m b" at the base case
22:59:19 <johnw> and cocataM doesn't know what the base case is, so it can't pass it along
22:59:27 <johnw> you're going to need to write this for:
22:59:40 <johnw> cocataM :: Monad m => (a -> Operation b -> m b) -> b -> Cofree Operation a -> m b
22:59:50 <johnw> *that* you can write, because you'll know when you hit the base case in the recursion
23:02:06 <johnw> koz_: https://gist.github.com/8d692e70cadbe4a3a4336825daa61f65
23:02:12 <koz_> Ah, so I have to fix it to my ... Functor/Traversable/whatever component?
23:04:59 <koz_> johnw: The Either is there to deal with the base case, right?
23:05:04 <koz_> (i.e. when we hit an Atom?)
23:05:08 <johnw> yes
23:05:12 <koz_> OK, that makes sense.
23:05:41 <koz_> Now, stop me if I'm wrong, but does this mean that Free has catas, but anas might not terminate?
23:06:18 <koz_> Or rather, there isn't a general way to define an anamorphism for a Free, just like there isn't a general way to define a catamorphism for Cofree?
23:06:54 <johnw> Free is inductive, and terminates at Pure.  Cofree is coinductive, and does not terminate
23:07:07 <johnw> in a lazy language like haskell, you can write an anamorphism for Free, sure
23:07:48 <johnw> also, cata/ana apply to Fix
23:07:57 <johnw> not just Free/Cofree
23:08:35 <johnw> specifically, cata is for Fix as the least fixed point, and ana is for Fix as the greatest fixed point
23:08:45 <johnw> but in Haskell, these coincide
23:09:00 <koz_> johnw: As you said, Haskell doesn't distinguish between data and codata.
23:09:02 <johnw> Free gives Fix a base case, and Cofree adds a value at every step
23:09:11 <johnw> right
23:10:02 <johnw> so if you want to "think" about cata and ana, it's better to think in terms of least and greatest fixed points
23:10:11 <koz_> johnw: OK. I dunno if I wrote something wrong, but the compiler isn't too happy about cocataM.
23:10:19 <ReinH> which Haskell also doesn't have >_<
23:10:24 <johnw> show me; it type-checked here
23:10:38 <ReinH> (or, rather, distinguish between)
23:10:41 <johnw> right
23:10:41 <koz_> Never mind, I just forgot something.
23:10:53 <johnw> but it's better than thinking in terms of Free/Cofree, which are just specializations
23:13:35 <koz_> johnw: OK, so when I'm writing 'count' (count the nodes in the expression tree), cocata expects 'Int -> Operator Int -> Int' as its first argument. Now I guess that Int is the index, and Operator Int is the node itself?
23:13:54 <johnw> yep
23:14:17 <koz_> So basically, the algebra here is kinda of the form (Int, Operator Int) -> Int, but curried.
23:14:18 <johnw> Int -> Operator Int -- that's two different Ints
23:14:30 <johnw> the first Int is your index; the second Int is the aggregated result from all the prior invocations down the line
23:14:40 <koz_> johnw: Yeah, I got that much.
23:14:43 <johnw> ok
23:14:52 <koz_> (all my practice with morphisms today has brought some enlightenment)
23:14:58 <johnw> you kind of need (Int, Either a (Operator a)) -> a
23:15:06 <johnw> with an 'a' passed in as the base value
23:15:41 <johnw> but you'll find out exactly why you need that once you start writing some code :)
23:15:46 <johnw> it'll become pretty obvious what's missing
23:17:51 <koz_> OK, I'll take your word for it for now.
23:17:56 <koz_> OK, first attempt: http://lpaste.net/247827
23:18:04 <koz_> This is deliberately very easy so I can get the hang of it.
23:18:43 <koz_> (as an aside, is there a way to write countOp to be of the form 'Operator Int -> Int', since I just end up ignoring the indices anyway?)
23:19:00 <johnw> oh, you've got it; you don't need Either or the extra argument
23:19:09 <johnw> because you get to choose the result type, of course
23:19:20 <johnw> silly of me
23:19:41 <koz_> johnw: So what *should* cocataM look like?
23:19:56 <johnw> cocataM :: (Monad m) => (a -> Operator b -> m b) -> Cofree Operator a -> m b
23:19:56 <johnw>  
23:20:21 <johnw> and you can write it generally too
23:20:29 <johnw> let me edit my paste
23:20:53 <koz_> johnw: Let me try and rewrite it myself, and then I'll see if mine is the same.
23:21:21 <johnw> good idea; updated https://gist.github.com/jwiegley/8d692e70cadbe4a3a4336825daa61f65
23:25:03 <Squarism> So there is no replace:: String -> String -> String -> String
23:25:04 <Squarism> ?
23:25:13 <koz_> johnw: I'm not sure how to get the 'Operator b' for the second argument of k. I know that there's a traverse involved, but I'm not too clear how.
23:25:15 <Squarism> string functions seems scarse
23:25:59 <Squarism> ie.. how to replace a sub-string in a string with another substring?
23:26:08 <johnw> koz_: for maximum benefit, keep thinking on it until you get it, however long it takes
23:27:14 <Rotaerk> Squarism, there's a replace for Text
23:27:14 <johnw> Squarism: you'll need to (a) find the index of the string, (b) split at that index, (c) drop it from the remainder, (d) merge around the new string, (e) repeat within the remaindern
23:27:47 <Squarism> johnw, You are pulling my leg?
23:27:50 <Rotaerk> for lists, http://stackoverflow.com/questions/14880299/how-can-i-replace-a-substring-of-a-string-with-another-in-haskell-without-using
23:27:54 <johnw> no, I'll show you what I mean
23:28:10 <Squarism> i wont write my string replace function
23:28:13 <Squarism> that ought to exist
23:30:12 <Squarism> johnw, but thanks for reaching out. I guess you believe i had school assignement =D
23:30:23 <johnw> :)
23:30:31 <johnw> I didn't, but that's ok
23:30:56 <newsham> import Language.Haskell.TH;main=print $(ListE .replicate FOO<$>[|0|])
23:31:56 <newsham> for FOO=2^10
23:32:37 <koz_> johnw: Got it!
23:32:40 <koz_> Let me check yours.
23:33:03 <koz_> Yep, I got the same one.
23:33:07 <koz_> Just by following the types, mostly.
23:33:18 <johnw> Squarism: https://gist.github.com/4571477080baa8556c85b9abd0440a5a
23:33:19 <koz_> (and knowing a traverse and a bind were involved somewhere)
23:34:23 <Squarism> now i gather why everyone persist with using Data.Text instead of string
23:34:35 <johnw> Data.Text is, for most use cases, more efficient
23:34:39 * hackagebot hspec-wai 0.8.0 - Experimental Hspec support for testing WAI applications  https://hackage.haskell.org/package/hspec-wai-0.8.0 (SimonHengel)
23:34:39 <koz_> johnw: In my writeup of count, is there a way to not have to repeatedly ignore that first Int I'm being given? Ideally, I'd like countOp to be of type Operator Int -> Int, and ignore the first incoming Int from the cocata in count, not countOp over and over.
23:34:41 * hackagebot hspec-wai-json 0.8.0 - Testing JSON APIs with hspec-wai  https://hackage.haskell.org/package/hspec-wai-json-0.8.0 (SimonHengel)
23:34:43 * hackagebot hsexif 0.6.0.9 - EXIF handling library in pure Haskell  https://hackage.haskell.org/package/hsexif-0.6.0.9 (EmmanuelTouzery)
23:34:52 <Squarism> and it has more than 4 functions
23:35:06 <johnw> koz_: cocata (const countOp)
23:35:15 <koz_> johnw: Of course, thank you!
23:37:25 <koz_> johnw: Another aside, but I thought you'd know. I know the K combinator is 'const'; what's the S combinator?
23:37:33 <dibblego> ap
23:38:12 <koz_> :t ap
23:38:14 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:39:25 <Xnuk> :t (<*>)
23:39:27 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:42:37 <ReinH> @djinn (a -> b -> c) -> (a -> b) -> a -> c
23:42:38 <lambdabot> f a b c = a c (b c)
