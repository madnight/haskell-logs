00:14:11 <koz_> johnw: I'm a little confused about unfoldM.
00:14:24 <koz_> I'm trying to write the random expression tree generator, parametrized by depth.
00:14:42 <koz_> So my top-level signature is MonadRandom m => Int -> m Formula
00:16:30 <koz_> Now, this is what I have so far, but I'm a bit confused: http://lpaste.net/247827
00:17:27 <koz_> johnw: Am I right in thinking that in 'm (Int, Operator Int)', the first thing in the tuple is an index, or is it a depth?
00:18:08 <koz_> Because I would like to have it be indexed by unique Ints, but also have a depth parameter (so that it can stop generating at some point).
00:18:14 <puregreen> does haskell-mode provide a function to ask for a tag name to jump to?
00:18:26 <puregreen> I'm trying to do (haskell-mode-jump-to-tag t) but it doesn't work
00:23:08 <dmj`> puregreen: hasktags might do this, I usually just use 'ag' to search across multiple files or 'C-s' if in a single buffer
00:23:29 <puregreen> hasktags generates tags, I think, not handles tag search
00:23:50 <puregreen> ag and C-s find uses, not definitions
00:24:41 <dmj`> M-x haskell-mode-jump-to-def works for me
00:24:44 <Squarism> anyone know where "JSVal" is defined?
00:25:09 <puregreen> haskell-mode-jump-to-def jumps to whatever is at point
00:25:20 <dmj`> Squarism: GHCJS.Prim
00:25:59 <puregreen> I already can jump to things at point, now I also want a separate function that would prompt me for thing-to-jump-to
00:26:36 <dmj`> Squarism: https://github.com/ghcjs/ghcjs/blob/master/lib/ghcjs-prim/GHCJS/Prim.hs#L36
00:34:40 * hackagebot app-settings 0.2.0.8 - A library to manage application settings (INI file-like)  https://hackage.haskell.org/package/app-settings-0.2.0.8 (EmmanuelTouzery)
00:34:40 <sedeki> hi all
00:34:42 * hackagebot cmark-sections 0.1.0.1 - Represent cmark-parsed Markdown as a tree of sections  https://hackage.haskell.org/package/cmark-sections-0.1.0.1 (Artyom)
00:34:44 * hackagebot bioinformatics-toolkit 0.2.3 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.2.3 (kaizhang)
00:36:15 <sedeki> anyone familiar with lambda calculus (dumb question here? lol)? what is \lambda xy.x in beta normal form? i'm trying to understand what this term could possibly evaluate too. is there such a thing as a "null lambda term" or noop ?
00:36:32 <sedeki> i.e., if you apply \lambda xy.x to two arguments, what is the result
00:36:33 <sedeki> ?
00:39:54 <EvanR> sedeki: \x y . x ?
00:40:04 <EvanR> theres nothing to apply it to, its in normal form
00:41:39 <EvanR> :t \x y -> x
00:41:41 <lambdabot> t -> t1 -> t
00:42:21 <EvanR> if you apply it to two arguments, the result is the first one, second one ignored
00:44:05 <sedeki> hmm I see now. because it is (\lambda x . (\lambda y . x))
00:44:46 <EvanR> \lambda is redundant, \ stands for lambda
00:44:53 <EvanR> \x . \y . x
00:45:53 <EvanR> and this form needs to parens because each binder extends to the end by default
00:45:57 <EvanR> need no*
00:46:27 <EvanR> \x . (\y . x) for clarification
00:47:00 <EvanR> (\x . \y . x) 3 'c'
00:47:07 <EvanR> (\y . 3) 'c'
00:47:10 <EvanR> 3
00:47:52 <sedeki> i didn't follow what you meant by "needs to parens"
00:48:37 <EvanR> needs no parens
00:48:47 <sedeki> ah.
00:48:48 <EvanR> typo
00:48:59 <sedeki> yes I understand, I was just trying to clarify my thought process.
00:49:20 <EvanR> you can think of LC having the following grammar
00:49:41 <EvanR> there are 3 formations
00:49:44 <EvanR> Var :: String -> LC
00:49:48 <sedeki> 'c' above is "any value" right? why do you use apostrophs?
00:49:54 <EvanR> App :: LC -> LC -> LC
00:50:08 <EvanR> Lam :: String -> LC -> LC
00:50:25 <EvanR> sedeki: thats just a haskell char, similar to haskell 3
00:51:19 <sedeki> I read this as App takes an abstraction/function and one argument and returns the reduced LC, correct?
00:51:22 <EvanR> so give the above grammar, if you have no App, you cant do any beta redunction
00:51:30 <EvanR> App is application
00:51:38 <EvanR> yes
00:51:44 <sedeki> what is Lam?
00:51:46 <EvanR> lambda
00:51:52 <sedeki> why String?
00:51:59 <sedeki> ah. grammar.
00:52:01 <EvanR> thats the new variable being introduced
00:52:13 <EvanR> its grammar, its doesnt do anything, it just represents the expression
00:52:39 <sedeki> what is the technical difference between the "abstraction" [i.e., function] and "lambda" in LC?
00:52:53 <EvanR> nothing
00:53:02 <sedeki> are the terms equivalent?
00:53:35 <EvanR> pretty much
00:53:55 <EvanR> \x . _ is sometimes called "lambda abstraction"
00:54:13 <sedeki> what does underscore mean?
00:54:20 <sedeki> is it a free variable?
00:54:22 <EvanR> fill in the blank
00:54:27 <sedeki> ok
00:54:35 <EvanR> its a hole in the expression
00:54:54 <sedeki> so it is not really an expression at all
00:55:05 <sedeki> since it is not fully defined
00:55:10 <EvanR> well, if \_ . _ is a String -> LC -> LC
00:55:18 <EvanR> then \x . _ is a LC -> LC
00:55:22 <EvanR> and \x . x is a LC
00:56:50 <sedeki> beta reduction ... is it guaranteed to end in one unique LC?
00:57:13 <EvanR> no, thats one of the big properties of lambda calculus
00:57:37 <sedeki> with LC I mean lambda term
00:57:40 <EvanR> but if it ends at all, then the result is unique
00:57:55 <EvanR> thats another big property
00:58:28 <sedeki> so, not ending means that we'd have to have recursion
00:58:43 <EvanR> no, theres no recursion
00:58:55 <sedeki> how can it not end, then?
00:58:59 <EvanR> thats not in the grammar ;)
00:59:14 <EvanR> there are terms which never reach a normal form
00:59:23 <EvanR> see if you can think of one
00:59:53 <sedeki> the definition of normal form is that no more application can be done
00:59:59 <EvanR> right
01:00:42 <sedeki> i don't understand the problem, since there are just a finite number of terms...
01:01:02 <EvanR> you mean a finite number of parts to the expression?
01:01:18 <sedeki> yes, finite # of subexpressions
01:01:24 <EvanR> yes
01:01:33 <EvanR> and the word "reduction" would seem to imply that number decreases
01:01:42 <EvanR> but it might increase or stay the same
01:02:28 <sedeki> yeah
01:02:39 <sedeki> OK, I'll take a guess
01:07:40 <sedeki> increment,  s := \n s(n) -- given a zero element (0), the number n is the n'th application of "s" on 0.
01:07:58 <EvanR> LC expressions are kind of like conway game of life, with beta reduction as the computation rule. Conway originally simulated life on graph paper, today you can write a program in haskell pretty easily to do the LC for you ;)
01:08:09 <sedeki> so the LC \n . n + 1 increases the number of subexpressions for each n
01:08:20 <EvanR> that would work if you had access to numbers
01:08:36 <EvanR> well, not really, \n . n + 1 is in normal form
01:09:19 <EvanR> and apply it to any number would terminate in 1 move
01:09:26 <sedeki> EvanR that's an interesting description.
01:09:30 <sedeki> (game of life)
01:11:27 <sedeki> why would it terminate in 1 move? did you mean n moves for the number n?
01:11:41 <EvanR> (\n . n + 1) 5
01:11:43 <EvanR> 6
01:11:45 <sedeki> s(s(s(...))) right?
01:11:56 <EvanR> oh, are you trying to use s, which you defined with recursion
01:12:05 <sedeki> yeah
01:12:33 <EvanR> LC doesnt come with a facility for recursion
01:12:42 <sedeki> no i mean that...
01:13:09 <sedeki> given fixed n, s^{n + 1}(zero element) is the successor
01:13:54 <EvanR> so you have a shorthand to say s(s(s(... n times ( something ))))) ?
01:13:58 <sedeki> if you use this somehow, that there are n+1 applications... maybe I can construct something that isn't reducible
01:14:01 <sedeki> yes
01:14:40 <sedeki> I give up :-) tell me
01:15:12 <EvanR> not only that, having terms such as s(s(s(0))) arent in the grammar either ;)
01:15:33 <EvanR> though something like it can be encoded in a chain of lambdas
01:16:21 <EvanR> give up? first of all, you could easily look this up. second of all youre in an opportunity to say you invented something that was discovered by geniuses
01:16:23 <slack1256> Am I miss-guided into worry about the nested (>>=) on monad transf stacks?
01:17:11 <sedeki> what exactly does \x.xx mean?
01:17:27 <sedeki> there's an application in the body?
01:17:32 <EvanR> Lam "x" (App (Var "x") (Var "x"))
01:17:36 <ggole> Take an argument, apply that argument to itself
01:17:43 <EvanR> yes
01:17:46 <ggole> Often called the w combinator
01:18:01 <EvanR> maybe more clear to say \f . f f
01:18:05 <EvanR> or f(f)
01:18:06 <koz_> I'm having a bit of trouble getting the unfoldM here to terminate. Would appreciate feedback on what I'm doing wrong: http://lpaste.net/247964 johnw: In case you see this, I'm having trouble stopping the expansion.
01:19:13 <sedeki> what is (\x.xx) 3 ?
01:19:22 <EvanR> reduces to 3 3
01:20:12 <EvanR> LC doesnt have any numbers in it, as the grammar earlier showed, so that 3 is just a symbol
01:21:30 <sedeki> "symbol" ?
01:21:34 <sedeki> i see.
01:21:37 <EvanR> Var "3"
01:21:51 <sedeki> is it a free variable?
01:21:53 <EvanR> a free variable no less
01:23:13 <EvanR> LC is almost the worst programming language of all time, if it werent for unlambda
01:25:37 <int-e> IMHO Turing machines are worse. (Turing was clever though and actually did some structured programming (macros, you could say) to build TMs in his "On Computable Numbers" paper)
01:25:49 <ggole> You can express that term in more safe and convenient languages than STLC, it just needs recursive types
01:27:02 <EvanR> i guess turing machine programming is comparable to malbolge
02:06:53 <Xnuk> dexit
02:06:56 <Xnuk> sry
02:18:42 <phadej> bgamari: pong
06:09:49 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
06:09:49 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
06:12:58 <Asido> I wonder what are your opinions on rdbms and nosql when it comes to building a client in haskell? I was looking at various sql drivers, but I find them difficult and requiring lots of administration. then I looked at mongodb-haskell and was surprised how simple it is to use it
06:22:37 <maerwald> Asido: mongodb without mongoose is rather useless and there is no mongoose-like library in haskell
06:27:58 <Asido> maerwald, for rdbms I am leaning towards opaleye. what do you think about it?
06:32:09 <pingu_> Asido: mongodb, unfortunately, likes to throw away data: https://aphyr.com/posts/284-jepsen-mongodb
06:32:48 <pingu_> I like to be able to run a transaction sometimes.
06:33:09 <exio4> Asido: for simple things, I prefer to go with something like postgresql-simple (or sqlite-simple)
06:33:18 <pingu_> Not have to set up my own ZK cluster for a linearizable system...
06:33:49 <pingu_> Asido: If you really want EC, try Riak.
06:34:47 * hackagebot picedit 0.1.0.0 - simple image manipulation functions  https://hackage.haskell.org/package/picedit-0.1.0.0 (mdibaiee)
06:34:49 * hackagebot servant-mock 0.8.1.1 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.8.1.1 (jkarni)
06:34:51 * hackagebot servant-auth 0.1.0.0 -   https://hackage.haskell.org/package/servant-auth-0.1.0.0 (jkarni)
06:34:53 * hackagebot servant-auth-client 0.1.0.0 -   https://hackage.haskell.org/package/servant-auth-client-0.1.0.0 (jkarni)
06:34:55 * hackagebot servant-auth-server 0.1.0.0 -   https://hackage.haskell.org/package/servant-auth-server-0.1.0.0 (jkarni)
06:39:57 * hackagebot servant-auth-docs 0.1.0.0 -   https://hackage.haskell.org/package/servant-auth-docs-0.1.0.0 (jkarni)
06:42:05 <maerwald> Asido: looks overcomplicated
06:43:17 <maerwald> when the "basic" tutorial is 800+ lines...
06:45:28 <Asido> maerwald, there is a simplier intro. not the easiest way to read though: http://opaleye.benkolera.com/#/3
06:45:47 <Asido> you can scroll using up - down - right - left
06:47:19 <exio4> maerwald: "hey, look, this one has a nice intro" *link to 1k pages pdf*, "hm, maybe I could check the paper" *link to 50 page pdf with so many words I don't understand I doubt I know English* :p 
07:28:10 <codedmart> Is this code ok or a bad idea? https://gist.github.com/codedmart/56e54dd6cc2f9f5cfb6a2aaf33757381. R.next dies from a `MVar blocked indefinitely` error, so I want to restart the thread when that happens. R.next -> https://github.com/AtnNn/haskell-rethinkdb/blob/master/Database/RethinkDB/Network.hs#L407
07:34:48 * hackagebot free-game 1.1.9 - Create games for free  https://hackage.haskell.org/package/free-game-1.1.9 (FumiakiKinoshita)
07:34:50 * hackagebot free-game 1.1.90 - Create games for free  https://hackage.haskell.org/package/free-game-1.1.90 (FumiakiKinoshita)
07:34:52 * hackagebot servant-auth 0.1.0.1 - Authentication combinators for servant  https://hackage.haskell.org/package/servant-auth-0.1.0.1 (jkarni)
07:34:54 * hackagebot servant-auth-client 0.1.0.1 - servant-client/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-client-0.1.0.1 (jkarni)
07:34:56 * hackagebot servant-auth-server 0.1.0.1 - servant-server/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-server-0.1.0.1 (jkarni)
07:37:17 <Gurkenglas> codedmart, https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:untilJust will allow you to eliminate that explicit retry recursion
07:38:01 <Welkin> Gurkenglas: you mean, will allow you to make the program more difficult for others to read
07:38:10 <Welkin> for the sake of code golfing
07:38:56 <codedmart> Gurkenglas: OK I will take a look. Thanks!
07:39:07 <Gurkenglas> I think it's better to use as many predefined recursion schemes as possible, because reading actual recursion stays hard even once you get gud
07:39:58 * hackagebot servant-auth-docs 0.1.0.1 - servant-docs/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-docs-0.1.0.1 (jkarni)
07:40:08 <Gurkenglas> codedmart, and then forever to get rid of the other recursion. Now that I see the other one too, though, there's a better way:
07:41:44 <Gurkenglas> Since the recursive call to handleCursor happens at the end of both cases, you can take it out of the case, like so: http://lpaste.net/8495434754458386432
07:41:58 <Gurkenglas> (Getting rid of the undefined soon, therefore I didnt look up what to actually put there)
07:42:37 <lpaste> Gurkenglas annotated “No title” with “codedmart, then you can use forever to get rid of that recursion immediately” at http://lpaste.net/8495434754458386432#a9000438576785129472
07:43:37 <lpaste> Gurkenglas annotated “No title” with “codedmart, then you can use forever to get rid of that recursion immediately (annotation)” at http://lpaste.net/8495434754458386432#a3648318823800504320
07:44:00 <Gurkenglas> Whoops, didnt change the last title: "And then you can use mapM_ to reduce that common Nothing -> return () pattern"
07:44:52 <codedmart> Gurkenglas: Wait so then are you saying I don't need the `runCursor` anymore?
07:45:42 <Gurkenglas> I didn't say that, I merely refactored handleCursor into an equivalent expression
07:45:44 <codedmart> Or just the recursion on `handleCursor`
07:45:49 <codedmart> Ah ok.
07:45:50 <codedmart> Thanks!
07:46:03 <codedmart> That makes sense. I appreciate it.
07:47:46 <Gurkenglas> codedmart, and now since you're just repeatedly fetching the next value from the cursor and doing something with it, that looks like the sort of thing that can be replaced by doing something with all values from the cursor instead if the library authors did well
07:48:58 <codedmart> Fair enough, thanks again! I will also checkout the `untilJust`.
07:49:28 <Gurkenglas> And it looks like they did: collect :: Cursor a -> IO [a] from the source you linked, if it does what I hope it does, allows you to do "handleCursor md els = (fmap . map) (handleModel md els) . collect"
07:50:57 <Gurkenglas> (Although I wonder how this can return a lazy finite list if there can be a just value after a Nothing returned from next)
07:54:35 <sedeki> is it possible to overload e.g. (/) such that my overload does not conform to `Fractional` ?
07:57:17 <Gurkenglas> codedmart, oh was your original question whether its a bad idea to have runCursor restart itself in the finally?
07:57:36 <codedmart> Gurkenglas: Yeah
07:58:11 <Gurkenglas> Aha I knew that "I appreciate it" smelled fishy >:D
07:58:13 <codedmart> Code suggestions were welcome as well :)
08:00:36 <Gurkenglas> "Were"? Hmm I'll take the risk and do some more: Once you eliminated the recursion from handleCursor, you can pull lines 20 and 24 into it too
08:01:18 <osa1> does anyone know if lists sorted on keys are a worst case for Data.Map.fromList ?
08:01:47 <Gurkenglas> codedmart, won't that zombie forkFinally keep spawning threads when the program tries to self-terminate?
08:03:00 <codedmart> Gurkenglas: I don't know :). That is why I was asking. I run this with a web server (servant). When I shut it down it seems like everything is cleaned up ok, but I thought I would ask.
08:03:52 <lyxia> sedeki: do you really mean overload, or just redefine? You can define your own type class with (/) as a method, or you can define (/) as a local or top-level function.
08:04:02 <Gurkenglas> Yea let's get a third opinion from here then. osa1, http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Map-Lazy.html#v:fromList says ordered lists give linear time
08:04:57 <sedeki> lyxia OK. so what happens if I have a type T which is an instance of both Fractional and MyCustomType which defines (/) -- which (/) gets precedence?
08:05:40 <osa1> Gurkenglas: cool
08:05:41 <lyxia> sedeki: you have to hide one of the typeclasses or you get a conflict at compile-time
08:05:51 <sedeki> ah ok
08:08:31 <sedeki> another question, more practical: say that I want to create an Ord instance of my custom type. can I declare (==) in that instance at the same time?
08:10:01 <lyxia> You can't.
08:13:06 <sedeki> so if I want to declare Ord, then I must have another declaration as well, for Eq ?
08:13:40 <lyxia> Correct.
08:14:04 <lordcirth> Ord's must already be Eq's, right?
08:16:28 <ph88> anyone know how to interpret stacktraces ?
08:17:22 <ph88> by the way .. is it possible to step through the program and inspect memory ?
08:18:17 <pingu_> ph88: they usually make sense to me
08:18:34 <pingu_> but you need to understand how haskell executes code a little, or at least have a feel for it
08:18:55 <ph88> pingu_, would you take a look at my stacktrace? the program sometimes doesn't terminate
08:18:59 <pingu_> ph88: I tend not to bother doing that... unless you have a compiler bug.
08:19:12 <pingu_> You're much more likely to have a regular bug.
08:19:34 <pingu_> ph88: please post the whole source
08:19:38 <pingu_> and the trace
08:19:49 <ph88> eh the source is rather long with a lot of crap in it
08:19:59 <sedeki> why do people talk about lambda calculuses (plural) instead of one thing?
08:20:01 <pingu_> And minimise it, if possible ;)
08:20:32 <hpc> two relatively simple lambda calculi are the untyped LC (which you are probably familiar with)
08:20:38 <hpc> and the simply typed LC
08:21:10 <hpc> in untyped LC you can write fix = λg.(λx.g (x x)) (λx.g (x x))
08:21:21 <hpc> in STLC that's an infinite type and not allowed
08:21:36 <sedeki> ok, so it is a reference to theories with slighly different rules
08:21:47 <hpc> there's another LC that's STLC with fix taken as a postulate even though you can't define it
08:21:53 <Gurkenglas> ph88, paste the crap I'm in a refactoring mood :D
08:21:56 <hpc> pretty much
08:23:07 <pingu_> That made sense to me at precicely one point, when implementing the occurs check of HM.
08:23:11 <pingu_> And never again.
08:23:21 <Gurkenglas> ph88, http://downloads.haskell.org/~ghc/7.10.2/docs/html/users_guide/ghci-debugger.html 2.5.6 tells you how to inspect infinite loops
08:24:32 <javjarfer> Anyone knows why many types in "servant" use "deriving Typeable" if after that they don't use any actual functions from Typeable?
08:24:58 <ph88> pingu_, Gurkenglas https://paste.fedoraproject.org/446136/75940261/ https://paste.fedoraproject.org/445916/14759263/
08:25:06 <javjarfer> maybe i'm missing some actual uses?
08:25:33 <hpc> perhaps so you don't have to do a standalone deriving if you want that instance yourself
08:25:55 <hpc> and it doesn't add a dependency so might as well
08:26:51 <pingu_> javjarfer: I have a suspicion
08:27:35 <javjarfer> pingu_, which one?
08:28:14 <Gurkenglas> ph88, also if that doesn't help I feel turning off inlining might make it easier to follow the traces
08:28:15 <pingu_> javjarfer: https://github.com/haskell-servant/servant/pull/19
08:28:22 <pingu_> jkarni: ^^
08:29:26 <ph88> pingu_, Gurkenglas my hypothesis is that the test on line 171 is at least involved in the weird behaviour .. if i would change that test to  \_ -> True   to always succeed i don't think i will have the problem .. 
08:30:55 <ph88> Gurkenglas, in the documentation you linked i only see one mention to infinite loops .. but the context is that ":print does not cause infinite loops" .. 
08:30:57 <javjarfer> pingu_, so they added it to all constructors as part of a cleanup? Wouldn't an actual clean up remove it from placed where it isn't needed?
08:31:44 <ph88> this is only my 4th program
08:31:58 <pingu_> javjarfer: that would have been my vote, open an issue if it bothers you.
08:32:11 <Gurkenglas> ph88, 2.5.6 contains "Breaking on exceptions is particularly useful for finding out what your program was doing when it was in an infinite loop. Just hit Control-C, and examine the history to find out what was going on."
08:32:23 <Gurkenglas> And if you read all of 2.5.6 it'll tell you how to do that
08:32:34 <ph88> oki
08:32:41 <pingu_> ph88: it hurts my head, sorry, just keep cutting it in half untill you find the offending code.
08:32:49 <pingu_> Debug.Trace can help
08:33:09 <ph88> this is just 1/4 of the original actually ^^
08:33:20 <pingu_> If you can't make progress with that and a bit of thinking, then that document linked by Gurkenglas is good.
08:33:22 <javjarfer> pingu_, unless... they wanted it to be uniform for a reason we ignore... maybe the guess when using the project that all constructor are typeable so they can play with introspection
08:33:27 <Gurkenglas> :list is also useful after doing :back in order to get a visual representation of the current thunk
08:33:35 <Gurkenglas> *ph88
08:33:42 <javjarfer> pingu_, ***"maybe they guess"
08:34:06 <pingu_> javjarfer: yes, but my argument is that we shouldn't leave backdoors open for someone to trip into.
08:34:42 <javjarfer> pingu_, perfectly reasonable argument, I was just looking for a motivation to it
08:34:46 <pingu_> But, we're kind of already reflecting.
08:34:49 * hackagebot picedit 0.1.1.0 - simple image manipulation functions  https://hackage.haskell.org/package/picedit-0.1.1.0 (mdibaiee)
08:35:11 <pingu_> So I don't see what we lose in terms of yet more insanely un-beginner-friendly type level stuff.
08:39:06 <MarcelineVQ> pingu_, javjarfer: there's a #servant channel that these questions may be good for. mentioning it because I'm also interested, not to redirect you
08:40:23 <javjarfer> MarcelineVQ, thanks you, I'm going to ask there the same, and see if we get an answer
08:41:23 <osa1> when I group type decls (e.g. `x, y, z :: T`) I can still document definitions individually by using -- | before the value definitions, right?
09:01:09 <riaqn> hey guys.
09:01:30 <riaqn> I imported Control.Concurrent.STM.TArray, and it tolds me that newArray is not in scope.
09:01:34 <riaqn> wierd?
09:02:25 <srhb> riaqn: No? That module doesn't export newArray.
09:02:46 <riaqn> srhb: hmm.. then which module should I use?
09:02:55 <ertes> riaqn: TArray doesn't use the API from the 'array' library
09:03:15 <srhb> Data.Array.MArray for instance
09:03:30 <riaqn> ertes: well, all I see is that it implemented the MArray interface.
09:03:38 <riaqn> So I expect to be able to use it.
09:05:06 <ertes> huh?  i was wrong
09:05:42 <ertes> that's really weird
09:06:00 <riaqn> great, now it tells me unsafeWrite is not in scope.
09:06:02 <srhb> Oh it's just an instance
09:06:42 <srhb> Err umm :)
09:07:58 <ertes> riaqn: 'unsafeWrite' is from the vector library
09:08:11 <ertes> not entirely sure, but IIRC 'array' doesn't have it
09:08:43 <riaqn> ertes: so to use an instance, it's not enough to import the module implementing that instance?
09:09:06 <ertes> riaqn: you need to import the module that defines the API
09:09:16 <ertes> the instance only allows you to use it with that particular type
09:11:47 <riaqn> ertes: in this case Data.Array.MArray? well that's not enough in my case.
09:12:15 <ertes> riaqn: you need both: the class itself to be able to refer to the API, and the instance that defines the API for the type you want to use
09:19:02 <thunderblack> We have gotten all the nice and several data of a girl with her photos in Mega. The access link is just on the Onion Network and will be available for 1 hour only, then it will be destroyed automatically and we will post it with a new link again here or in any other place: http://zerobinqmdqd236y.onion/?838a0dab6a73e8cd#wepapimYCYdeA/6Lm3QjmcJTTJcomTQ5ZjPf+LxRZ/s=
09:20:33 <thunderblack> We have gotten all the nice and several data of a girl with her photos in Mega. The access link is just on the Onion Network and will be available for 1 hour only, then it will be destroyed automatically and we will post it with a new link again here or in any other place: http://zerobinqmdqd236y.onion/?838a0dab6a73e8cd#wepapimYCYdeA/6Lm3QjmcJTTJcomTQ5ZjPf+LxRZ/s=
09:21:21 --- mode: ChanServ set +o glguy
09:21:21 --- mode: glguy set +b-o *!*@62.109.30.187 glguy
09:25:27 <riaqn> ertes: thanks, my problem is solved.
09:25:38 <lysgaard> Is there a way to make a lens that traverses all fields of a specific type in a recursive tree-like data structure?
09:25:54 <riaqn> import Data.Array.Base, where unsafe stuff is defined, which is used by unsafeWrite instance.
09:27:24 <glguy> lysgaard: The Control.Lens.Plate module is worth looking at, and the Data.Data.Lens
09:28:34 <lysgaard> glguy: Yes. I have spent some time trying to figure it out, but haven't cracked it yet.
09:33:37 <mitchty> is/are there any good introductions to control.monad anyone can suggest
09:34:55 <mitchty> i assume anything by johnw is good will give this a quick go https://www.schoolofhaskell.com/user/jwiegley/monad-control
09:41:06 <ertes> mitchty: what do you mean by "control.monad"?  the Control.Monad module?  monads?  the monad-control pattern?
09:41:29 <bgamari> phadej, we need contravariant in `base` or something along these lines
09:41:42 <bgamari> phadej, I was looking at the new FromJSONKey class
09:41:43 <mitchty> ertes: yeah control-monad as a concept really
09:41:59 <ertes> mitchty: monads or something named "control-monad"?
09:42:20 <bgamari> phadej, it's unfortunately quite tricky to derive these instances
09:42:43 <mitchty> mtl in general is something i need more practice with but the monad-control module is specifically what i'm looking at in reference to conduit
09:43:27 <bgamari> phadej, it seems like aeson should expose an lmapToJSONKeyFunction function or something along these lines (or take on a dependency on contravariant)
09:43:52 <ertes> mitchty: if you want to learn specifically monad-control, the best way i found was to just implement instances yourself
09:43:52 <mitchty> in a bit over my head with both conduits and mil monads in general but think i've an idea of where i need to go to figure it out
09:45:09 <mitchty> to be a bit more specific with the actual end goal of this exercise
09:45:10 <ertes> mitchty: you could refer to monad-control monads as "delimited state monads" in a way
09:45:43 <mitchty> i've something to talk to over a unix tcp socket that requires... certain shenanigans to happen before I can get at data from it
09:46:04 <mitchty> but in the end, it ends up just being jsonrpc data
09:46:09 <mitchty> all thats the easy bit
09:46:33 <mitchty> what i'm trying to do is figure out how I can wedge the encoding/decoding into something like this https://hackage.haskell.org/package/conduit-extra-1.1.13.3/docs/Data-Conduit-Network.html
09:46:43 <mitchty> runGeneralTCPServer specifically
09:47:13 <mitchty> so from there i've been spelunking through source code for conduit and doing tutorials for that to get the gist of things
09:47:49 <mitchty> which has led me to mtl and monad-control monads
09:48:54 <mitchty> hopefully i'm pointed the right..ish way 
09:50:30 <mitchty> i'll admit i'm still at best a dangerous beginner using haskell so feel free to point anything out I should probably start to read/learn to help out
09:58:14 <Xnuk> ;q
09:58:21 <javjarfer> pingu_, MarcelineVQ, they said me that GHC does it by default from 7.10, so... not a big deal to make it explicit there
09:58:41 <Cale> I've often felt that if the solution to the problem you're having is to use MonadBaseControl, it might be better to take a step back and reconsider the way that things are structured.
09:59:19 <MarcelineVQ> javjarfer: interesting
10:01:15 <Cale> mitchty: Are you sure that the plain runTCPServer isn't enough?
10:01:23 <javjarfer> MarcelineVQ, really interesting, I had no idea, and my first thought was, that it doesn't feel right, but if all the community said nothing since 7.10... I guess it really is right, and that there isn't any related issue
10:01:51 <MarcelineVQ> The majority is always sane? :>
10:03:30 <glguy> javjarfer: it's standard practice to provide instances of commonly used type classes for library defined data types so that consumers on the library will have access to those instances
10:03:45 <monochrom> No, the majority is always insane, and the minority is always sane.
10:03:47 <Cale> javjarfer: What are you referring to?
10:04:02 <monochrom> And the Haskell community is the minority, not the majority.
10:04:34 <javjarfer> MarcelineVQ, well speaking of GHC they always have been very careful and conservative in terms of including something that may be controversial. So, short answer no, but in this case... I really would go for "I'm wrong"
10:04:38 <Cale> The minority also isn't always sane
10:04:52 <Cale> But the sane are typically a minority ;)
10:04:56 <geekosaur> looks like the context is servant getting a bunch of deriving Typeable
10:05:42 <Cale> javjarfer: You're asking about why there are Typeable instances for types defined by Servant?
10:05:56 <geekosaur> amd, from 7.10 on ghc does that anyway (it needs unique tags for every type to avoid a derive-unsafeCoerce corner case) but doesnt necessarily expose them
10:07:34 <javjarfer> Cale, I was asking that at first because they didn't use then at all, but now they already solved me that question
10:08:07 <javjarfer> geekosaur, exactly, that was the info I didn't had when I asked
10:09:35 <geekosaur> plus if you derive Typeable then there are useful non-Servant-specific libraries that can work on your types
10:09:57 <geekosaur> (generics libraries, in particular)
10:10:57 <javjarfer> sorry, ** didn't have **
10:12:45 <andromeda-galaxy> How could one define "take" using recursion-schemas?
10:13:01 <javjarfer> geekosaur, yes... my first thought was introspection too. Could you solve me a question? Did you guess why here they decorate the type of the (:>) operator with (path :: k) "https://hackage.haskell.org/package/servant-0.9/docs/src/Servant-API-Sub.html#%3A%3E"?
10:13:12 <andromeda-galaxy> I am trying to implement as much as possible of Data.List using recursion-schemas neatly, as an exercise
10:13:39 <andromeda-galaxy> it seems like catamorphisms are inherently sort of "bottom up", and I need somtehing more "top down"
10:14:07 <geekosaur> javjarfer, that's a kind annotation, and the intent is to enable it to work on any kind, not just the default kind *. which allows you to use it with type level programming
10:14:19 <geekosaur> and I think servant itself uses that these days
10:14:45 <Cale> Well, if you look at the example immediately preceding that line
10:14:54 <Cale> It wouldn't kind-check if it weren't for that annotation
10:15:12 <Tuplanolla> Do you know the function composition trick used in `shows` to turn a fold upside down, andromeda-galaxy?
10:15:33 <geekosaur> as an example, you can define: data POST; data GET; ... for the different HTTP requests, then promote those to type level and parameterize values with them so you can't accidentally POST a GET request (it becomes a type error)
10:16:09 <ertes> andromeda-galaxy: can you define (take 1) in terms of foldr?
10:16:21 <ertes> once you have that, try (take 2)
10:16:47 <ertes> then see if that generalises
10:16:49 <Gurkenglas> What's going on if Ctrl-C doesn't interrupt ghci running something with :trace?
10:16:58 <geekosaur> (meaning, it's an error caught at compile time instead of an exception at runtime)
10:17:00 <Gurkenglas> (The last few times, it at least stopped after we waited some seconds)
10:17:06 <Cale> > let take n xs = foldr (\x xs k -> if n == k then [] else x : xs (k+1)) (const []) xs 0 in take 10 [1..] -- hint for andromeda-galaxy 
10:17:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
10:17:14 <geekosaur> Gurkenglas, I think it only gets processed when something does allocation
10:17:44 <andromeda-galaxy> ertes: that's the thing, I'm not sure how to defined 'take', or take anything, in terms of foldr at all - it seems like it starts from the "wrong end" of the list, so there's no way to know when there's only 1 thing left and stop
10:17:48 <geekosaur> you may be able to improve that with: ghc -fno-omit-yields (but I'm not sure that flag even applies to bytecode...)
10:17:56 <geekosaur> er, ghci not ghc
10:18:02 <Cale> (well, maybe that's exactly what you were asking for)
10:18:39 <Cale> andromeda-galaxy: foldr starts at the beginning of the list. Everything has to start at the beginning of a list, there's no choice about that.
10:18:44 <geekosaur> andromeda-galaxy, they all go left to right (or more precisely, from the outside in). when reduction occurs differs, but when pattern matching occurs is the same
10:19:00 <Cale> @src foldr
10:19:00 <lambdabot> foldr f z []     = z
10:19:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:19:14 <Cale> The cool thing about foldr is that in the recursive case, it immediately passes control to f
10:19:22 <javjarfer> geekosaur, Cale, ohhh thanks! I was trying to experiment that with the Polykinds macro, when I read the docs I thought they need the annotation, then I make a small test to check that but I left the Polykinds pragma in the file... and I confused myself.
10:19:32 <Cale> Only if and when the second argument to f is needed will the evaluation of the foldr proceed.
10:19:51 <Cale> So if f can produce some or all of its result while only looking at its first argument, the foldr might stop early.
10:19:52 <javjarfer> geekosaur, Cale thanks you, now I know, no need for testing xD.
10:19:56 <Cale> By contrast...
10:19:58 <Cale> @src foldl
10:19:58 <lambdabot> foldl f z []     = z
10:19:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:20:25 <andromeda-galaxy> Cale: oh yes, right, I momentarily got more confused than I should have, probably because I've been trying (and failing) to understand hylo
10:20:30 <Cale> foldl just applies itself to new arguments until it gets to the end of the list: it will never work on an infinite list because those don't have an end
10:20:48 <andromeda-galaxy> this was my break from that
10:20:53 <geekosaur> javjarfer, well, testing is still needed because you cant determine what a remote will send at compile time. but you can still handle whole classes of errors at compile time that you otherwise could not
10:22:45 <Cale> andromeda-galaxy: Another trick you should know about is that by accumulating functions that will produce the ultimate result instead of accumulating results, you can effectively carry "state" along through a foldr
10:22:48 <javjarfer> geekosaur, the testing was for me to fully understand the decoration, and its relation with Polykinds, but I left the pragma in the file when I thought I had removed it... And I confused myself, because It was compiling when it shouldn't, so I asked you
10:22:55 <Cale> andromeda-galaxy: consider:
10:23:21 <Cale> > foldr (\x xs s -> s : xs (s + x)) (const []) [1..10] 0
10:23:23 <lambdabot>  [0,1,3,6,10,15,21,28,36,45]
10:23:35 <Cale> Here, we have foldr doing the job of scanl
10:24:02 <Cale> (Indeed, this sort of thing is a snappy way to define scanl)
10:24:16 <javjarfer> geekosaur, but thanks for the example and the POST GET explanation, very revealing. 
10:26:53 <Cale> > foldr (\x xs s -> s : xs (s + x)) (const []) [1..] 0 -- just to show that we don't work from the end backwards
10:26:55 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
10:29:17 <andromeda-galaxy> so, that sort of builds up a function, with const [] as the initial value...
10:30:05 <Cale> It's best not to think of that as the initial value
10:30:47 <Cale> A good way to think about what foldr f z does is that it replaces each (:) in the construction of the list with f, and the [] at the end (if any) with z
10:30:56 <Cale> So const [] is the replacement for the empty list.
10:31:43 <Cale> But, as in the second case I gave there with the infinite list, we might never actually use that.
10:32:03 <Cale> > foldr (\x xs s -> s : xs (s + x)) undefined [1..] 0 -- we don't need it here
10:32:06 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
10:32:15 <andromeda-galaxy> right. The important thing though is that the f that each cons is replaced with doesn't directly return a value, it ends up returning another function - which uses the function returned by the "next" call
10:32:24 <Cale> yeah
10:32:46 <andromeda-galaxy> it kind of *feels* like there there should be a way of doing this without that...
10:33:05 <andromeda-galaxy> but maybe my intuition for doing more general things with folds is just not that good
10:34:52 * hackagebot sibe 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/sibe-0.1.0.0 (mdibaiee)
10:35:20 <EvanR> a first approximation of what you can do with folds is to pretend haskell is eagerly evaluated, then imagine the list getting folded to the right or to the left
10:36:41 <EvanR> but because its lazy you can strictly do more
10:37:12 * erisco groans
10:38:41 <monochrom> :)
10:39:52 <augur> slightly off topic paper that's been going around: https://arxiv.org/abs/1609.09562
10:39:58 <andromeda-galaxy> e.g. you can say let take' k = snd . foldl (\(n, l) a -> (if n == k then (n, l) else (n+1, l++[a]))) (0, [])
10:40:03 <augur> proof that  NP = PSPACE  via proof theoretic constructions
10:40:17 <monochrom> it is a very poor approximation. it is informative for finite lists only, and for finite lists it is informative on what answer you get only, not time and space.
10:40:36 <monochrom> in fact it is way off on time and space, you even get the wrong big-O answers.
10:40:52 <andromeda-galaxy> monochrom: wait, why is that foldl off on big-O?
10:41:52 <monochrom> foldl (+) 0 (list of n things) is O(1) space in SML, Omega(n) space in de facto Haskell
10:42:24 <monochrom> read my http://www.vex.net/~trebla/haskell/lazy.xhtml
10:43:18 <EvanR> time and space? who needs it
10:43:30 <EvanR> i run my haskell on a denotational machine
10:44:17 <monochrom> you don't even say "run" when denotational.
10:44:37 <monochrom> the program simply *is*. you simply *are*.
10:44:59 <ryantrinkle> does anyone have advice on how to build a test suite for RULES, to make sure they're firing?
10:45:22 <ryantrinkle> (i.e. so you can catch regressions where they fail to fire)
10:45:22 <andromeda-galaxy> and anyway that only works for finite lists, which is bad...
10:46:02 <Rarrikins> ryantrinkle: RULES as in rewriting optimizations?
10:46:05 <andromeda-galaxy> I'm just curious if there is a way to do the regular take with foldr/recursion-schemas without building up a function and then evaluating that on 0
10:46:07 <ryantrinkle> Rarrikins: yeah
10:46:19 <andromeda-galaxy> it makes recursion-schemes feel not quite right to me
10:46:53 <monochrom> my advice is be agnostic to recursion schemes, like I do.
10:47:03 <ryantrinkle> i'm about to spend some effort writing rules, and i'd like to make sure i don't blow up all my work next time i start changing the code again :P
10:47:05 <andromeda-galaxy> what do you mean by that?
10:47:14 <Tuplanolla> Functions are goood, andromeda-galaxy.
10:47:54 <monochrom> if you have an obvious case of foldr, great. if it is not obvious but it is still true, learn whatever you can learn from it. if it is not a foldr, don't feel bad about foldr.
10:48:12 <Rarrikins> ryantrinkle: I'm not sure how you'd do that. I've checked the Core generated by some things that should be fused or whatever, but I'm not sure if the Core would change each time a new GHC came around.
10:48:22 <ryantrinkle> hmm
10:48:29 <ryantrinkle> maybe i should write it at the GHC API level
10:48:31 <andromeda-galaxy> ah. makes sense. As an exercise to familiarize myself with the concepts, I'm just trying to write a bunch of the Data.List functions on lists and trees using cata/ana/para/etc.
10:48:49 <monochrom> there was a time a lot of papers churned out a lot of recursion schemes.
10:49:55 <monochrom> and the way I foresaw that it would go bunk (and soon later it did) is that the rate of increase was greater than in physics, the rate of increase of non-fundamental particles before they figured out the Standard Model.
10:50:31 <ocramz> hullo
10:50:42 <ongy> hello
10:50:51 <andromeda-galaxy> But do you still think the relatively basic ones like cata/ana/para/hylo are useful?  Those seem to capture a good number of cases...
10:51:34 <ocramz> are there any synchronous primitives for IO? say I want to perform an action every N seconds
10:51:55 <EvanR> sounds like a job for a cron
10:52:05 <monochrom> I only keep cata and ana around. They are the only two (even just one coin, two sides) that are fundamental under a constraint.
10:52:15 <Tuplanolla> In my experience cata is very useful, ana is sometimes appropriate and with hylo all bets are off, andromeda-galaxy.
10:52:41 <andromeda-galaxy> Tuplanolla, monochrom: okay, I think that makes sense. Thanks for all the advice!
10:52:47 <ocramz> EvanR it's more than that; I'd like to model a synchronous state machine
10:52:51 <Tuplanolla> I recall there being a proof of hylo being Turing-complete, so in addition to being confusing, it doesn't have as many nice properties, andromeda-galaxy.
10:52:56 <ocramz> where time is a parameter
10:53:07 <Tuplanolla> Someone can probably correct me on this.
10:53:08 <ongy> cata ana? are those recursion schemes?
10:53:17 <ocramz> ongy: yep
10:53:19 <andromeda-galaxy> Tuplanolla: ooh, right, I think I may have seen something like that...
10:53:20 <ongy> ocramz: there's threadDelay, I think System.Concurrent
10:53:30 <monochrom> yes but I don't care about recursion schemes.
10:53:37 <ocramz> ongy got it, I'll look into it
10:53:41 <EvanR> ocramz: if you want a simulation to step at a fixed rate, youll have to do like game loops and sleep until the desired time, and if you slept too long (OS scheduling, user dragging your windows window freezing the dispatcher) then youll need to step more than once
10:53:45 <monochrom> I care about cata and ana because I care about initial and final algebras.
10:53:46 * ongy barely knows fold
10:54:04 <EvanR> to know how many steps to do, use divMod
10:54:07 <EvanR> and a monotonic clock
10:55:43 <monochrom> yes there is a theorem saying every computable thing can be computed by a composition of one cata and one ana.
10:56:18 <monochrom> it still does not write programs for you because the intermediate thing between the cata and the ana is where all your creativity and invention goes.
10:56:46 <Tuplanolla> All your memory goes there too, usually.
10:56:53 <monochrom> yeah
10:57:15 <andromeda-galaxy> the proponents of hylo seem to be of the opinion that that intermediate thing ties up the recursion in a datastructure which is easier to do some kinds of analysis on, also, right?
10:59:08 <monochrom> more concretely the data structure you use in the middle is what you have to tailor-make for the problem you want to solve.
11:00:39 <monochrom> there are also times, for ergonomic reasons, you do not want to structure your program as just combining just one cata and just one ana.
11:01:15 <monochrom> all expert compiler writers envision a compiler to be like 5 stages, not just 2.
11:01:41 <monochrom> the theorem says that you can have just 2 but no one really wants to do that.
11:02:18 <EvanR> not 1 stage?
11:02:53 <andromeda-galaxy> that makes sense!
11:02:58 <Tuplanolla> Try this little exercise, andromeda-galaxy: https://github.com/Tuplanolla/ties341-schemes
11:02:58 <Tuplanolla> Convert the explicit recursion in `Explicit.hs` to use the appropriate recursion schemes. You can start by defining `FormF` for `type Form = Fix FormF`. The solutions are in `Implicit.hs`.
11:03:08 <monochrom> and there are other data processing problems you will want to have a non-trivial dataflow graph rather than even a pipeline.
11:04:00 <Tuplanolla> Some hylo is involved.
11:09:37 <andromeda-galaxy> Tuplanolla: wow, that looks useful! Thanks. monochrom: Indeed...
11:15:44 <mitchty> Cale: had to step away for a bit sorry, i'm not entirely sure, basically I have to knock after the socket is opened, and then do some other stuff to send, so its a bit involved but just busy work to be honest, receiving is simpler however
11:15:47 <andromeda-galaxy> (Tuplanolla: I was just trying to finish my previous exercise before going on to the one that you linked to) http://lpaste.net/1540770378719166464, either I am horribly misunderstanding how to use cata, or using it makes lots of filter-ish functions allocate way more than they should need to...
11:16:56 <andromeda-galaxy> for every node that is processed, that takes a Tree, builds up a TreeF, and then builds up another Tree that is, in some cases, the same as the first one!
11:17:57 <Tuplanolla> Avoid construction with `alg i @ (IBranchF x l r) | p x = i`.
11:19:34 <andromeda-galaxy> Tuplanolla: I tried that, but the return value is an InternalTree, not an InternalTreeF
11:19:36 <phadej> bgamari: there is contramap.... http://hackage.haskell.org/package/aeson-1.0.1.0/docs/src/Data-Aeson-Types-ToJSON.html#contramapToJSONKeyFunction also https://github.com/bos/aeson/pull/399#issuecomment-221926123
11:19:50 <Tuplanolla> Oh, indeed.
11:20:00 <bgamari> phadej, ahhh!
11:20:13 <bgamari> how did I miss that/
11:20:27 <phadej> bgamari: also toJSONKeyText
11:20:41 <phadej> which make be even easier in some cases
11:20:46 <bgamari> ahh, it's only in Data.Aeson.Types
11:21:02 <phadej> yeah, I guess that could/should be fixed
11:21:18 <bgamari> I also just should have looked more carefully
11:21:23 <bgamari> phadej, thanks!
11:21:24 <Tuplanolla> Can you just `Fix` or `unFix` it though, andromeda-galaxy?
11:21:26 <phadej> bgamari: np
11:22:05 <Tuplanolla> Perhaps this is something to worry about later.
11:22:20 <andromeda-galaxy> hmm, in this particular case InternalTree is actually a separately defined type and 'Base (InternalTree a) = (InternalTreeF a)', so that doesn't work here, but that makes sense more generall
11:22:47 <phadej> bgamari: not in base, but shipped with ghc? :)
11:23:03 <bgamari> heh
11:23:16 <bgamari> phadej, I don't know; we have bifunctors; why not contravariant as well?
11:23:31 <phadej> bgamari: and profunctors for the sake of completeness? :)
11:24:03 <phadej> bgamari: I have no good "where to stop" opinion, I'm personally ok with using more packages than just 'base' :)
11:24:28 <phadej> (I'm not sure if `contravariant` has some hidden TH somewhere though)
11:24:51 <phadej> probably not
11:25:04 <andromeda-galaxy> Tuplanolla: is this along the lines of what you meant by "that's usually where all your memory goes, too"?
11:25:35 <Tuplanolla> No. Only hylo involves a temporary base functor, andromeda-galaxy.
11:26:45 <Tuplanolla> Your problem here seems to be that the data type and its fixed version are disjoint, so you can't reuse existing things.
11:34:53 * hackagebot hjsonschema 1.2.0.1 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-1.2.0.1 (seagreen)
11:34:55 * hackagebot eventstore 0.13.1.7 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.13.1.7 (YorickLaupa)
12:08:59 <xuxu> :t pwd -- pwd :: MonadIO io => io Turtle.FilePath      :t ls -- ls :: Turtle.FilePath -> Shell Turtle.FilePath  
12:09:01 <lambdabot> error: Variable not in scope: pwd
12:09:11 <xuxu> pure ls <*> pwd -- returns nothing
12:09:29 <xuxu> no errors, just goes to the next line
12:09:35 <mtesseract> Good evening :)
12:09:42 <xuxu> hello mtesseract!
12:11:00 <koz_> I'm having a bit of trouble getting the unfoldM here to terminate. Would appreciate feedback on what I'm doing wrong: http://lpaste.net/247964 johnw: In case you see this, I'm having trouble stopping the expansion.
12:12:21 <geekosaur> xuxu, you have there an IO action inside an IO action.
12:12:42 <geekosaur> try join, or rephrasing so you don't nest IO actions
12:13:10 <geekosaur> (look at: :t pure ls <*> pwd)
12:14:04 <Gurkenglas> koz_, you never decrease d
12:15:46 <xuxu> thanks geekosaur, i guess i need to figure out how to get around ls "/Users/xu/" -- having no instance for (Show (Shell Turtle.FilePath))
12:15:59 <geekosaur> correct, you cannot show an action
12:16:46 <geekosaur> just looking at types, I think this is what you want: pwd >>= ls
12:16:55 <Gurkenglas> koz_, i also is not identifying a node, but the depth of a node
12:18:03 <xuxu> view $ join $ pure lstree <*> pwd
12:18:27 <xuxu> pwd >>= ls  -- No instance for (Show (Shell Turtle.FilePath))
12:18:39 <koz_> Gurkenglas: Ah, so the integer *is* depth...
12:18:48 <koz_> OK, that explains why it's not terminating, thanks.
12:18:55 <koz_> Still getting the hang of Cofree.
12:19:44 <xuxu> view $ join # pure ls <*> pwd -- works
12:19:44 <Gurkenglas> koz_, if you use Ints only in order to have a unique identifier, you can avoid passing an i between the different branches of the Cofree by replacing the Int by String, where the index is just for each node a char that says which way to go next
12:19:56 <xuxu> view $ join $ pure ls <*> pwd -- rather
12:20:11 <Gurkenglas> That is, each node is indexed by the path you used to go to it
12:20:14 <geekosaur> something needed to run an action of type Shell, yes, since it's not just an IO action but a something-involving-IO
12:20:58 <geekosaur> view $ pwd >>= ls, probably; Applicative can't quite do what you want which is why you need the join if you insist on Applicative
12:21:00 <andromeda-galaxy> Tuplanolla: sorry for the delay---network problems on my client. Now I better understand what you were talking about earlier, thanks!
12:21:08 <Gurkenglas> That'll also help you modify it if you want to replace a leaf by a tree later - it's more of an address than an index
12:21:12 <xuxu> geekosaur: that works 
12:21:52 <ReinH> Also note that pure f <*> x = f <$> x is an Applicative law
12:22:00 <koz_> Gurkenglas: I think I'll stick to integer indexes.
12:22:54 <Gurkenglas> And if your usecases are fitting enough, you can do away with indices at all and use lenses to go into the parts of the tree that you want, perhaps using telescoped
12:23:13 <Gurkenglas> And if you are only refusing because you don't understand how to implement this, you can paste your current code and ill see what I can do :P
12:24:31 <xuxu> thanks geekosaur. that fits nicely
12:26:33 <koz_> Gurkenglas: I understand I could use lenses, or different kinds of indexes. However, I'm on a very strict deadline, and I have to be able to understand wtf is going on.
12:26:54 <koz_> Like, don't take it the wrong way, I really appreciate the help, but I'm not sure I'll be able to get what's going on. I learn *slowly*.
12:27:56 <mtesseract> When I use DataKinds and define a data type as in "data Foo where Wrap :: a -> Foo", is it possible to possible to define a function extract :: Proxy (Wrap a) -> a", which extracts the type-level "a" and returns it as a value?
12:28:43 <koz_> Gurkenglas: If you could, could you correct what I've pasted so that it actually does what it's supposed to? I assume I'll need to use State somewhere in there, but I'm not sure where.
12:29:51 <Gurkenglas> (Here's the index idea drawn up: http://sketchtoy.com/67522894 the expression is (2*4)+3 and each node has its index annotated
12:30:14 <Gurkenglas> The index of the 4 is "go left at the plus, then right at the times")
12:30:37 <koz_> Gurkenglas: That makes sense - however, your indexing is non-uniform.
12:30:50 <Gurkenglas> brb food
12:30:52 <koz_> The whole point of my indexing scheme is that I can randomly select any node as a mutation target.
12:34:54 * hackagebot aeson 1.0.2.0 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.0.2.0 (AdamBergmark)
12:34:56 * hackagebot escape-artist 1.0.0 - ANSI Escape Sequence Text Decoration Made Easy  https://hackage.haskell.org/package/escape-artist-1.0.0 (ryan_daniels)
12:39:37 <javjarfer> geeksosaur, as a curiosity, servant guys tell me, they were using Polykinds there to been able to join there * and Symbol kinds
12:43:08 <Gurkenglas> koz_, so any mutation preserves the number of nodes?
12:43:47 <koz_> Gurkenglas: Not necessarily - it can increase or decrease them too.
12:43:58 <koz_> The index is a 'target' - what occurs there varies.
12:44:01 <sm> escape-artist looks nice
12:44:31 <Gurkenglas> So how you got to an expression that is being mutated matters to what future states are likely
12:46:45 <koz_> Gurkenglas: Yes, indeed.
12:47:03 <koz_> One thing I can guarantee - we only add one node at a time at most.
12:47:17 <koz_> (i.e. any mutation can increase the vertex count in the tree by at most one)
12:49:05 <nitrix> Can I have a newtype of a monad transformer stack, with the original monad being `IO`, and allow some computations of that type to do _some_ IO, but not all IO, excepted for a given module ?
12:50:34 <limeburst> Good morning
12:50:59 <limeburst> I tried translating some C code to Ivory this week
12:51:12 <limeburst> It's for a keyboard controller
12:51:17 <limeburst> https://github.com/limeburst/cadet
12:51:51 <limeburst> I'm new to Haskell and FP in general, so I thought I'd look for some advice on my code here!
12:53:37 <lyxia> How does one handle multiple versions of template-haskell? 2.11 (with GHC8) introduced a new field in DataD which of course breaks any code using it. CPP?
12:53:38 <nitrix> An eDSL like Ivory might be quite the leap if you're not comfortable with Haskell first.
12:54:35 <geekosaur> cpp's about the only option, I'm afraid
12:54:57 <lyxia> geekosaur: Okay, thanks.
12:55:05 <nitrix> The other option is bumping the lower package bound of your dependency on template-haskell.
12:55:08 <lpaste> Gurkenglas revised “What's missing here?”: “koz_, painful” at http://lpaste.net/247964
12:55:25 <Gurkenglas> Argh I did edit instead of annotate - but at least people can see the old version under expand
12:55:30 <Gurkenglas> eh ill fix it
12:56:22 <limeburst> nitrix: it was!
12:56:52 <limeburst> The first function was the hardest, after that it was almost mechanical
12:58:10 <lpaste> Gurkenglas revised “koz_, painful”: “Put a $ instead of an <$> _again_.” at http://lpaste.net/248952
13:00:23 <johnw> koz_: hi
13:00:32 <nomeata> nitrix: yes. you keep the constructor of the newtype private, and re-export all the IO operations you want to allow, wrapped in your newtype
13:00:47 <nomeata> nitrix: does not require transformers, you can simply newtype IO.
13:01:00 <nitrix> nomeata: That's what I have so far: https://github.com/nitrix/lspace/blob/master/src/Game.hs#L48
13:01:21 <nitrix> nomeata: https://github.com/nitrix/lspace/blob/master/src/Game.hs#L93
13:01:36 <Gurkenglas> (koz_, in the non-uniform indexing you could keep a list of all the valid indices, and then use uniform to select one. If that's the only thing you do with them, using lenses would take all the choices from you on how to call the index characters)
13:01:56 <nomeata> nitrix: and you are not satisfied?
13:02:49 <nitrix> nomeata: That part is nice. What I'm not happy with is, now, I cannot have my renderer do arbitrary IOs. So I had to duplicate the module and call it "Core" https://github.com/nitrix/lspace/blob/master/src/Core.hs
13:03:01 <Gurkenglas> Oh hey you can seperate the indexing logic from the generating logic, and then you dont have the painful _, let me do that
13:03:15 <nitrix> nomeata: This one is the exact same type, but derives MonadIO, and lets you "embed"  Game computations inside Core.
13:03:24 <nomeata> nitrix: ah, you want some _other_ module have special rights?
13:04:09 <nitrix> nomeata: Yeah. I mean my current approach of embedding Game (pure) in Core (less pure) is nice and principled, but I hate how the type is duplicated and unwrapped-rewrapped. :/
13:04:26 <nomeata> you can probably replace embed-game with `coerce` from Data.Coerce.
13:04:36 <javjarfer> geekosaur, as a curiosity, servant guys tell me, they were using Polykinds there to been able to join there * and Symbol kind
13:05:00 <geekosaur> yes, I saw that the first time, thanks
13:05:00 <javjarfer> geekosaur, they are explaining me more in #servant channel
13:05:25 <nomeata> nitrix: how about one module, ….Internal, that exports Game with the constructor, and then the other module re-exports that, leaving out the constructor.
13:05:38 <iomonad> io
13:05:43 <nomeata> Privileged code can import ….Internal, normal code imports the other module
13:05:51 <javjarfer> oh, sorry I misspelled your name and thought you didn't see it
13:06:41 <iomonad> I'm on gentoo, Do I need to install stack with Emerge package manager (with haskell overlay) or simply just with cabal ?
13:07:21 <lpaste> Gurkenglas annotated “What's missing here?” with “koz_, there, much better. And lenses unnecessitate the new do block again, of course.” at http://lpaste.net/247964#a248969
13:08:12 <nitrix> nomeata: That's not a bad idea at all.
13:08:48 <nomeata> nitrix: it’s a fairly standard idiom. Look at bytestring and may more.
13:09:29 <nomeata> you an even prevent other code from using the ….Internal module if you do not export that in your pacakge (exposed-modules vs. other-modules)
13:11:07 <lpaste> Gurkenglas revised “koz_, there, much better. And lenses unnecessitate the new do block again, of course.”: “And a type signature error, and oh hey maybe I can get rid of the void somehow” at http://lpaste.net/248969
13:12:05 <johnw> since you ignore the values in the tree, the void should be irrelevant
13:13:11 <johnw> that whole forM block looks... odd
13:13:56 <johnw> I think you could also write: get <* modify (+1)
13:14:01 <Gurkenglas> The void is because I ignore the value, it's supposed to look like a clutch because it is one
13:14:06 <johnw> but what is it doing?
13:14:10 <Gurkenglas> Ooh nice
13:14:45 <ggVGc> so, I have one file with essentially all my IO and mutability, and my type signatures look like this, https://gist.github.com/bce504b5798672476b5b812e51d7536a
13:14:48 <Gurkenglas> The void destroys the depths contained in the Cofree as soon as possible so it's obvious I don't need them
13:14:52 <ggVGc> I feel like I'm not doing very well
13:15:05 <johnw> ggVGc: maybe see a doctor?
13:15:36 <ggVGc> this channel is the doctor I need for my haskell
13:18:53 <xuxu> best way to extract "foo" from ["foo", "bar", "baz"]? 
13:19:01 <delYsid> I have a simple class Enum b => Braille b where toChar :: b -> Char, can I make an instance that works for all Integral types?
13:19:02 <xuxu> rather...
13:19:16 <buttbutter> xuxu: If you're sure the list is never empty, just use head?
13:19:51 <delYsid> I've tried all sorts of combinations, but nothing seems to work, so I wonder if I am trying to do something that is actually not possible?
13:20:10 <xuxu> best way to extract "foo" from ["foo", "bar", "baz"] given that "foo" has the chars "fo" -- i'm looking for anything that has "fo" so "foo" and "food" would match if the list were ["foo", "food", "red"]
13:20:21 <xuxu> ?
13:20:29 <johnw> filter ("fo" `isPrefixOf`)
13:21:11 <lpaste> Gurkenglas revised “And a type signature error, and oh hey maybe I can get rid of the void somehow”: “By the golf of johnw and the power of Applicative!” at http://lpaste.net/248969
13:22:01 <xuxu> thanks johnw!
13:23:28 <Gurkenglas> koz_, note that the i in your nonhalting example was the literal tree-depth of the node it decorates, while the d in the last annotation is your probable original intent of an amount of depth points that goes down by about half on each layer
13:28:10 <Gurkenglas> :t mapMaybe (stripPrefix "fo") -- xuxu, if you're only interested in the remaining part
13:28:12 <lambdabot> [[Char]] -> [[Char]]
13:31:46 <Gurkenglas> delYsid, yep. You don't want to give all Integrals an instance because that forbids any instances that are not Integral. You could make a newtype wrapper "newtype IntegralBraille a = IntegralBraille a" and then do "instance Integral b => Braille (IntegralBraille b)", that would only forbid Braille instances for all types of form "IntegralBraille b" where b is not Integral.
13:33:36 <siwica``> How do I find out what version a particular package of the standard library has in my installation?
13:33:52 <johnw> ghc-pkg list, I believe
13:33:58 <Gurkenglas> ggVGc, what happens with the a in line 38?
13:34:03 <johnw> although, it may depend on: stack, cabal sandboxes, etc. etc.
13:35:47 <siwica``> I was just interested in System.Directory
13:36:06 <siwica``> ghc-pkg was the way
13:36:33 <Tuplanolla> It doesn't seem to play well with sandboxes, johnw.
13:38:03 <ggVGc> Gurkenglas: yeah.. nothing, so it might a well be ()
13:38:04 <ggVGc> why?
13:40:58 <geekosaur> Tuplanolla, that is what johnw meant by [08 20:33:41] <johnw> although, it may depend on: stack, cabal sandboxes, etc. etc.
13:41:18 <geekosaur> use the appropriate command (cabal/stack exec ghc-pkg list, for starters)
13:43:06 <ggVGc> I think I've asked this before, but I didn't get anywhere, so I'll try again. I have a model, and I want to be able to define different views that can work on it, I want each of these views to be able to keep some internal state. What would the type signature be for such a view?
13:43:36 <ggVGc> weach view should have a state that's opaque to the function applying them to the model
13:43:55 <ggVGc> the only way I can think of is for each view to hold a local MVar?
13:44:32 <ggVGc> so, FooView :: MVar FooViewData -> Model -> Model
13:44:36 <ggVGc> but that doesn't seem so great
13:44:52 <delYsid> Gurkenglas: hmm, I hear you, I still have no intuition for why instances can not be defined for a whole class of types at once.  It feels so natural to me to just say "instance Integral b => Braille b" or something like that.
13:45:58 <delYsid> Anyway, thanks for confirming that I was on the wrong track.
13:47:01 <koz_> Gurkenglas: Thanks for that - I'll investigate. I think I'm gonna pull in Lens anyway.
13:50:30 <koz_> Gurkenglas: Typechecker is unhappy - let me try and unravel that.
13:51:51 <koz_> Gurkenglas: Never mind - missing import. Problem solved!
13:52:08 <Cale> ugh, lol, there's a package called aeson-lens, when the real one is lens-aeson
13:52:53 <Cale> It defines the same module and a bunch of the same names, but isn't type compatible
13:53:53 <Gurkenglas> It swaps all the parameters and tuple orders around? :D is it acme
13:53:56 <koz_> Gurkenglas: It works!
13:54:39 <koz_> Gurkenglas: OK, so for mutations, it's probably better if I construct an indexing lens, right?
13:55:05 <Gurkenglas> That would give you the property that mutating into something is the same as generating it immediately
13:55:35 <koz_> Gurkenglas: I'm looking more for convenience than anything else.
13:55:56 <koz_> Like, I could do it with just plain Cofree, but I'm wondering if lensing would make it simpler/faster to implement/less of a headache.
13:56:15 <Gurkenglas> If all you use the index for is "if i == t then" so you can modify the correct node, then lenses fit
13:56:25 <koz_> OK, lenses it is.
13:56:29 <koz_> Just let me add the dependency.
13:56:48 <Gurkenglas> About implementing speed, I don't know, it might depend on your lurning curve
13:56:58 <koz_> Gurkenglas: So should I just make Formula an instance of Ixed and be done with it?
13:57:36 <Gurkenglas> Ooh didnt even think of that, I thought you'd keep a list of lenses from the root into a node
13:58:08 <koz_> Gurkenglas: That seemed like the most logical approach, honestly.
13:58:34 <Gurkenglas> That = Keeping a list, or making "indexed lenses"?
13:59:03 <koz_> Indexed lenses.
14:01:52 <Gurkenglas> If you're pulling in lens anyway, and want to keep Int indices, then yes making an Ixed instance, even one that just traverses everything and picks out the node with the right index as you currently do, goes towards an at-least-local optimum
14:02:36 <koz_> Gurkenglas: Cool. Also, it seems Lens clashes with Cofree.
14:02:42 <koz_> (so Lens is going in qualified)
14:02:46 <koz_> (for the first time *ever*)
14:03:02 <Gurkenglas> wut how, both are by ekmett, Cofree contains lens definitions for crying out loud
14:03:14 <koz_> It clashes on (:<)
14:04:06 <Gurkenglas> http://hayoo.fh-wedel.de/?query=%3A%3C I dont see it
14:04:17 <Gurkenglas> Couldn't you do import Control.Lens hiding ((:<))
14:05:19 <Gurkenglas> (Dont see the Cofree one either tho, huh)
14:05:28 <koz_> Gurkenglas: I guess I could.
14:06:22 <Luthifar> Ello persons
14:06:27 <koz_> Gurkenglas: I dunno - I'm just tellin' it like the typechecker.
14:07:00 <koz_> Gurkenglas: It seems Formula will have to become a newtype.
14:07:13 <Luthifar> I am a noob, who has a question regarding Haskell
14:07:33 <koz_> Luthifar: Then please ask and don't hesitate!
14:07:42 <Luthifar> Okay!
14:07:44 <Luthifar> So
14:07:50 <Luthifar> Say I define a list as follows
14:08:07 <Luthifar> let listy = [x|x<-[1,1..], x /= 1]
14:08:15 <Luthifar> Which should be the empty set
14:08:29 <Luthifar> I know from doing this and running it that
14:08:33 <Luthifar> [] == listy
14:08:45 <hsgumby> is there a -ddump-foo for the last stage ghc is done optimizing core?  (i.e. a fully optimized dump)
14:08:50 <Luthifar> while we can see it must be True, it never returns a value
14:09:03 <Gurkenglas> koz_, you could give Traversable t => Cofree t Int an Orphan instance >:D
14:09:04 <hsgumby> (I am having trouble finding it in the manual)
14:09:21 <Gurkenglas> (This is an application rather than a library, right?)
14:09:49 <koz_> Gurkenglas: Library.
14:10:02 <Luthifar> I assume this has to do with laziness, as even though we can see that [1,1..] is all ones by definition, Haskell is actually checking each 1 to see if it is not 1, since it is lazy and will not, so to speak, look down the hallway at the infinite ones
14:10:04 <Gurkenglas> nevermind then about the orphan
14:11:00 <lpaste> koz_ annotated “What's missing here?” with “How do I modify this to operate on a newtype?” at http://lpaste.net/247964#a249091
14:11:09 <Gurkenglas> (You don't really need an Ixed instance though, you can just define something like ix without making it a class instance)
14:11:12 <Luthifar> Is this a correct understanding of laziness, and why Haskell can't just immediately set that list to []?
14:11:16 <koz_> Gurkenglas: Could you help me with the newtype conversion please? ^
14:11:28 <koz_> Gurkenglas: I'd rather define an Ixed and At instance - it makes more sense to me, honestly.
14:12:01 <Gurkenglas> Can't do At, you can't put a new value at an arbitrary index, or remove arbitrary nodes
14:12:20 <koz_> Well, Ixed then.
14:12:32 <koz_> But wait, Ixed is lookup-only.
14:12:44 <koz_> So that means I can't do mutations that cut branches or add new nodes?
14:13:03 <nshepperd> Luthifar: I wouldn't really describe this as being "about" laziness. the only thing laziness does here is allow infinite lists/streams to exist in the first place
14:13:24 <nshepperd> Luthifar: but you're basically right
14:13:45 <Gurkenglas> koz_, your lookup is going to access the whole subtree with that index
14:13:56 <nshepperd> Luthifar: that list comprehension syntax is sugar for 'listy = filter (/= 1) [1,1..]'
14:14:13 <koz_> Gurkenglas: Ah, and then we can just work on it?
14:14:43 <Gurkenglas> (this index thing does not get the "doesn't-matter-what-sequence-of-mutations-got-us-here property btw)
14:14:50 <Luthifar> nshepperd: So, the way the filter function works, it has to literally go through and check each element? That's why it isn't about laziness, but rather the way in which filter works?
14:14:54 <nshepperd> Luthifar: the definition of filter is that it checks the first item for a match then recursively filters the rest of the list
14:14:57 <nshepperd> yeah
14:15:00 <nshepperd> @src filter
14:15:00 <lambdabot> filter _ []     = []
14:15:00 <lambdabot> filter p (x:xs)
14:15:01 <lambdabot>     | p x       = x : filter p xs
14:15:01 <lambdabot>     | otherwise = filter p xs
14:15:34 <Luthifar> nshepperd: I see. This makes total sense.
14:16:00 <Tuplanolla> Good choice of words, Luthifar.
14:16:16 <Luthifar> nshepperd: Are you aware of an alternative way of indirectly creating an empty list such that Haskell won't go through the whole thing?
14:16:39 <Luthifar> nshepperd: I try to be as clear as possible, and thanks for the help!
14:17:00 <lpaste> Gurkenglas annotated “What's missing here?” with “T'was just missing a "Formula <$>". And you probably want to lift the FFT instances.” at http://lpaste.net/247964#a249101
14:17:19 <nshepperd> well, usually if you want to filter an infinite list and for the final answer to be finite, you need a takeWhile somewhere in your program
14:17:33 <nshepperd> > takeWhile (<10) [1..]
14:17:35 <lambdabot>  [1,2,3,4,5,6,7,8,9]
14:17:52 <implementation> indirectly creating an empty list?
14:18:00 <implementation> > tail [1] -- is this what you mean?
14:18:03 <lambdabot>  []
14:18:14 <Tuplanolla> > mempty :: [a]
14:18:17 <lambdabot>  []
14:18:34 <koz_> Gurkenglas: I can't derive Functor from that... :(
14:19:19 <Luthifar> nshepperd: Okay, or like take 100 [1,1..] which would then check for all the \= 1, and come back empty
14:19:40 <Luthifar> implementation: yes, or any other type of code which makes an empty list
14:19:53 <Gurkenglas> Oh, of course, you're not polymorphic in the rightmost type argument anymore, and you'll need Int for the Ixed. Shame, nvm about the deriving then
14:19:59 <nshepperd> > takeWhile (/=1) [1,1..]
14:20:01 <lambdabot>  []
14:20:09 <Luthifar> I am coming at this from a more mathy background, where you can look at definitions and see they are self-contradictory and thus create an empty set
14:20:11 <koz_> Gurkenglas: I just need to know how to do the proper wrapping and unwrapping in the code you gave me.
14:20:21 <koz_> It's a little *too* golfed for me to make sense of it.
14:20:37 <Luthifar> nshepperd: Now, that piece of code stops at the very first element, right?
14:20:51 <implementation> > fix (take 0)
14:20:53 <lambdabot>  []
14:20:57 <nshepperd> yes, it sees that the first element does not match, then ignores all the others
14:21:20 <Luthifar> nshepperd: cool. so far, so logical.
14:21:25 <safareli> hey is there name for 
14:21:28 <lpaste> Gurkenglas revised “T'was just missing a "Formula <$>". And you probably want to lift the FFT instances.”: “T'was merely missing the one "Formula <$>".” at http://lpaste.net/249101
14:21:29 <nshepperd> @src takeWhile
14:21:29 <lambdabot> takeWhile _ []                 = []
14:21:29 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
14:21:29 <lambdabot>                    | otherwise = []
14:21:33 <safareli> k :: (a -> b -> c) -> (z -> b) -> z -> a -> c 
14:21:34 <safareli> k = (.) . flip
14:21:46 <Luthifar> The recursive call is missing from the otherwise, gotcha
14:23:38 <Gurkenglas> safareli, https://hackage.haskell.org/package/data-aviary have fun
14:23:58 <koz_> Gurkenglas: How do I define type family instances again?
14:25:08 <Gurkenglas> koz_, http://hackage.haskell.org/package/lens-4.14/docs/src/Control.Lens.At.html#line-229 demonstrates
14:26:34 <koz_> Gurkenglas: What would IxValue for a Formula be?
14:26:35 <koz_> Formula?
14:26:46 <Gurkenglas> yep
14:27:19 <Gurkenglas> Or perhaps Cofree Operator Int, since you probably dont want to allow another ixing
14:27:50 <koz_> Gurkenglas: So the unwrapped form? Makes sense.
14:34:57 * hackagebot fltkhs 0.5.0.0 - FLTK bindings  https://hackage.haskell.org/package/fltkhs-0.5.0.0 (deech)
14:34:59 * hackagebot freddy 0.1.1.0 - RabbitMQ Messaging API supporting request-response  https://hackage.haskell.org/package/freddy-0.1.1.0 (indrek)
14:46:49 <javjarfer> Someone could clarify me this about datakinds? Here ("https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/promotion.html") it says that BOX "is the (unique) sort that classifies kinds". And also that constructors are promoted to type constructors, I have understood this as following: 1 Now all types have their own kind 2 Value constructors are promoted to kinds of type * -> * -> * ... depending of number of a
14:46:49 <javjarfer> rguments. How wrong I'm?
14:53:18 <erisco> javjarfer, (1) should be "all kinds have sort BOX"
14:54:16 <jle`> javjarfer: from a pre-8.0 pesrpective, types are promoted to kinds, and value constructors are promoted to types
14:54:24 <jle`> and their kinds aren't necessarily * -> * -> ...
14:54:27 <jle`> :k 'Just
14:54:29 <lambdabot> a -> Maybe a
14:54:41 <jle`> Just is promoted to a poly-kinded type constructor
14:54:49 <jle`> :k 'Just Bool
14:54:51 <lambdabot> Maybe *
14:54:55 <erisco> javjarfer, types and type constructors become kinds, and the sort of kind is BOX
14:55:35 <jle`> javjarfer: i wouldn't say that "Types have their own kind"; it's just that declaring a type now also declares a kind, as well, of the same name
14:55:42 <erisco> javjarfer, value constructors are promoted to types
14:56:00 <jle`> but the two are actually not directly linked by GHC/Haskell
14:56:19 <lpaste> koz_ pasted “Gurkenglas: Typechecker is unhappy, and I am unsure how to fix” at http://lpaste.net/249158
14:56:42 <jle`> declaring `data Maybe a = Nothing | Just a` declares two things: a type with two value constructors, and a kind with two type constructors.  they happen to just both have the same names
14:57:16 <erisco> a value constructor is   a -> b  or  X  where a and b are type variables and X is a type (and a -> b is a type)
14:57:26 <erisco> a value constructor has type*
14:57:41 <Gurkenglas> {-# LANGUAGE ScopedTypeVariables #-}? And then I think you want to remove the second "Applicative f =>"
14:57:56 <koz_> Gurkenglas: If I remove that constraint, the otherwise case breaks.
14:58:09 <koz_> Because then the sequenceA call becomes problematic.
14:58:24 <jle`> Int -> (forall f. Applicative f => Cofree operator Int -> f (Cofree Operator Int))
14:58:30 <Gurkenglas> Why fmap Formula?
14:58:34 <jle`> your parentheses are around the wrong thing
14:59:00 <koz_> jle`: Derp.
14:59:03 <koz_> Thanks.
14:59:05 <jle`> np
14:59:12 <koz_> Gurkenglas: Return type needs to be kept happy.
14:59:16 <erisco> for value constructor  v :: a -> b   p(v) :: P(a) -> P(b),   v :: X  p(v) :: P(X)   where  p(v) is a type, P(x) is a kind
14:59:19 <Gurkenglas> oh nvm my fmap Formula remark was stupid
14:59:27 <jle`> Foo -> forall a. Bar a -> Baz is the same as forall a. Foo -> Bar a -> Baz
15:00:02 <erisco> P(a -> b) = * -> *, P(X) = K(X)  where K(X) is X as a kind
15:00:45 <Gurkenglas> "deriveWrapped ''Formula" and "au (_Unwrapping Formula)" btw
15:00:48 <erisco> sorry, the variables got a bit confused there
15:01:09 <javjarfer> erisco, what you mean by "sort" because I think its a concept I don't get
15:01:12 <koz_> jle`: Is this the right sig? ix :: Int -> (forall f . Applicative f => Cofree Operator Int -> f (Cofree Operator Int)) -> Formula -> f Formula
15:01:15 <erisco> causing me to miss a piece of it
15:01:21 <jle`> ask the compiler :o
15:01:22 <koz_> Gurkenglas: I need to see the whole thing without any magic first.
15:01:25 <erisco> but that is the gist, you can fill in the mistake
15:01:41 <koz_> jle`: I'm not sure - I tried fixing it by following your suggestion, and even more broke...
15:01:50 <erisco> javjarfer, values have types, types have kinds, kinds have sorts
15:01:57 <javjarfer> jle`, I didn't thought about poly-kinded
15:01:58 <Gurkenglas> jle`, how does he ask the compiler for the signature of something within a where clause
15:02:13 <Gurkenglas> koz_, does it compile if you leave out the signature for go?
15:02:28 <javjarfer> erisco, sort is a classification?
15:02:31 <koz_> Gurkenglas: Let me try
15:02:45 <jle`> the 'f' shouldn't be accessible from the type of ix
15:02:51 <jle`> if it's rankn
15:03:23 <koz_> Gurkenglas: No, I still have the same issue.
15:03:26 <erisco> javjarfer, I do not know the official meaning of sorts, but it is probably the same as types
15:03:35 <jle`> because 't' is polymorphic
15:03:35 <koz_> jle`: Then I'm confused...
15:03:36 <Gurkenglas> I think 29+30 ought to be | x == i = t (x :< xs)
15:03:44 <jle`> can you post your updated code?
15:03:46 <erisco> i.e. propositions, but I am not sure that is official either
15:03:53 <koz_> Gurkenglas: Let me try that.
15:04:20 <javjarfer> erisco, so how you can distinguish all kinds, if all have the same sort?
15:04:40 <jle`> javjarfer: that's like asking how you can distinguish 1, 2, and 3 if they all have the same type
15:04:40 <koz_> Gurkenglas: Same issue. Let me just paste the exact error.
15:04:59 <erisco> P(a -> b) = P(a) -> P(b)   P($a -> b) = * -> P(b)   P(a -> $b) = P(a) -> *   where $x is a literal variable
15:05:00 <jle`> values of the same type are often distinguishable
15:05:13 <jle`> True and False are distinguishable, despite both being of type Bool
15:05:14 <erisco> would have to check more carefully but the construction rules are something like this
15:05:46 <javjarfer> jle`, ahh... okay I get it, value
15:06:04 <erisco> javjarfer, there is no need for different sorts, apparently, and so it suffices to have just one
15:06:15 <lpaste> koz_ annotated “Gurkenglas: Typechecker is unhappy, and I am unsure how to fix” with “Gurkenglas: Now with more error (annotation)” at http://lpaste.net/249158#a249171
15:06:45 <jle`> koz_: er wait yes that's definitely wrong, GHC can't infer RankN types
15:07:02 <koz_> jle`: I knew that.
15:07:17 <koz_> So what should it be?
15:07:23 <erisco> I don't even know all the kinds, or what they are used for
15:07:26 <jle`> oh wait, ix isn't RankN
15:07:30 <jle`> having the forall in the middle threw me off
15:07:53 <erisco> other than * is the kind of types that have values
15:07:55 <jle`> why not ix :: forall f. Applicative f => Int -> (Cofree Operator Int -> f (Cofree Operator Int)) -> Formula -> f Formula ?
15:08:00 <jle`> you know, like... a normal type signature, heh
15:08:23 <javjarfer> erisco, jle` thanks you both, now I think I see it clearer, could you think about a meaning example that doesn't use GADT in which promoting value constructors to types has a use?
15:08:31 <koz_> jle`: Oh, derp, OK.
15:08:47 <Gurkenglas> btw sequenceA (fmap go xs) is traverse go xs
15:08:58 <koz_> The thing is, the actual type of ix is Int -> Traversal' Formula (Cofree Operator Int).
15:09:08 <jle`> javjarfer: it's nice for refinement types and things you can "tag"
15:09:09 <EvanR> i wonder why youd want to not consider GADTS
15:09:15 <koz_> I just rolled out the type signature to help myself understand it better.
15:09:26 <koz_> EvanR: Because my brain is already breaking with all the *other* stuff I'm using?
15:09:27 <erisco> javjarfer, well the idea is quite simple, it is just that you can write programs where types are values and kinds are types
15:09:43 <jle`> javjarfer: for example, you might have a type wrapping emails that are sanitized or unsanitized
15:09:57 <jle`> data Status = Clean | Unclean
15:09:58 <erisco> javjarfer, so any ordinary value & type program you write can be promoted to a type & kind program, in principle. In Haskell there are limitations to this
15:10:06 <jle`> newtype Email (a :: Status) = E String
15:10:19 <jle`> so you can have types of `Email Clean` that are sanitized emails
15:10:29 <jle`> and values of type `Email Unclean` that are unsanitized emails
15:10:32 <erisco> javjarfer, so you can, for example, have a list of types, and program ordinary list operations for lists of types
15:10:40 <erisco> javjarfer, same as you would for a list of values
15:11:05 <jle`> w/o data kinds, Email would be completely polymorphic and `Email Bool` or something silly like that would be a valid type
15:11:08 <jle`> gross
15:11:24 <erisco> negligence
15:11:28 <jle`> koz_: ah ok.  does the pulled out version compile?
15:11:49 <koz_> I de-unravelled it back, and I still get the same error, jle`.
15:11:51 <Tuplanolla> Can you raise floating-point numbers to the type level with all their fantastic rounding problems?
15:12:07 <jle`> you mean you put back in the Traversal' type synonym?
15:12:11 <koz_> (i.e. I replaced it with 'Int -> Traversal' Formula (Cofree Operator Int)')
15:12:13 <koz_> jle`: Yes.
15:12:26 <koz_> (de-unravelled = ravelled or re-ravelled?)
15:12:51 <jle`> what's the type error now?
15:13:20 <koz_> jle`: Same as what I pasted.
15:13:26 <jle`> Tuplanolla: there's one basic way to do it, yes, but you won't get nice literals and all your proofs would happen at runtime
15:13:39 <koz_> Oh wait, not *quite* the same.
15:13:42 <koz_> Let me repaste.
15:13:56 <javjarfer> erisco, jle` okay that was truly mind opening, thanks you both
15:13:57 <koz_> ... and lpaste dies.
15:14:19 <jle`> javjarfer: np!
15:14:24 <jle`> btw, any reason why you're talking about 7.8 in particular?
15:14:32 <jle`> the story in 8.0 with -XTypeInType is a little different
15:14:35 <jle`> maybe even significantly so
15:15:22 <jle`> i had actually almost completely forgotten that sorts existed
15:15:30 <jle`> now that they don't exist anymore with TypeInType
15:15:41 <koz_> Man, lpaste has been dying a lot lately.
15:16:20 <geekosaur> I think you just have to retry a few times. I imagine it's running on a limited/cheap vps and times out a lot and puts up the maint page as fallback
15:16:49 <koz_> jle`: https://paste.rel4tion.org/407 <-- new error
15:17:22 <jle`> wait, this is after you put back in the type synonym?
15:17:42 <koz_> jle`: Yes. Also, if I remove the type sig for 'go', it compiles.
15:18:08 <javjarfer> erisco, jle` as you said that should have some limitations, because if you have programs where "types are values and kinds are types" which difference will that have with dependent types?
15:18:18 <jle`> koz_: can you post the updated code?
15:18:23 <koz_> jle`: Sure.
15:18:24 <yulax> does haskell compile to native code?
15:18:30 <jle`> GHC des yes
15:18:32 <jle`> *does
15:18:46 <Tuplanolla> Do people call their local functions `go` just for the `let go` pun or what's the deal with that?
15:19:00 <jle`> heh
15:19:07 <jle`> i think someone started it and people are very lazy with thinking about names
15:19:19 <Tuplanolla> Trust the `f`.
15:19:47 <koz_> jle`: https://paste.rel4tion.org/407 <-- updated code, with old error. I commented out go's typesig, and the error below vanished.
15:21:03 <Gurkenglas> {-# LANGUAGE ScopedTypeVariables #-}?
15:21:20 <koz_> Gurkenglas: Nope. Would adding that solve it?
15:21:33 <jle`> oh i assumed that you've had it on this entire time
15:21:34 <Gurkenglas> I think so, put it in and restore go's sig
15:21:42 <jle`> cause it was suggested initially
15:21:57 <koz_> jle` and Gurkenglas: OK, I'll give it a shot.
15:21:58 <EvanR> Tuplanolla: and then you get people complaining that were bad programmers because wereNotUsingIncrediblyDescriptiveNames
15:22:00 <jle`> but i don't think that would help in this final situation
15:22:24 <jle`> because f is not in scope to begin with
15:22:38 <koz_> jle`: It doesn't.
15:22:52 <koz_> If I add the sig back, the compiler still complains in the same way.
15:23:04 <jle`> scopedtypevariables should always be on by default anyways, there's no reason to ever not have it on and it'll save you from a lot of headache when the errors do come up
15:23:19 <koz_> jle`: I'll keep that in mind.
15:23:30 <jle`> the errors come up even when you're writing mundane non-fancy haskell code heh
15:23:31 <koz_> So basically, in this case, just don't bother with a signature for go?
15:23:50 <jle`> well
15:23:52 <jle`> it'd be nice to have one
15:24:02 <jle`> it's interesting to think about what's goin on
15:24:24 <erisco> javjarfer, with dependent types, values are types and types are values. This is not the case in Haskell even with this promotion, because the promoted items are not the same as the unpromoted ones
15:24:59 <koz_> jle` and Gurkenglas: Does my definition of Ixed seem sensible?
15:25:22 <javjarfer> erisco, ahhh okay okay...
15:26:06 <Gurkenglas> You best be happy there's no law about ixes over different indices commuting with each other!
15:26:18 <javjarfer> thanks you again
15:26:42 <Gurkenglas> Wait actually they do commute because the one further away from the root gets deleted in any order
15:27:00 <jle`> koz_: hm yeah, the problem is probably because you "split" the RankN type by taking t as an argument
15:27:10 <erisco> javjarfer, that said, there is interesting work in the "singletons" package which uses singleton types (i.e. they have exactly one value)
15:27:11 <Gurkenglas> This is only lawful tho if the index remains unchanged
15:27:29 <jle`> koz_: you can expand the type signature back out (with the forall), and then go will have 'f' in scope to use
15:27:33 <Gurkenglas> Perhaps IxValue ought to be not Cofree Operator Int, but Operator (Cofree Operator Int)
15:27:39 <erisco> javjarfer, in effect then, if you know the type you know the value. If you promote these, then if you know the kind then you know the type
15:27:53 <Gurkenglas> So you can't possibly edit the index
15:28:16 <koz_> Gurkenglas: I think that's sensible. Let me edit that.
15:29:05 <jle`> koz_: i think the weirdness comes from the fact that you're "splitting" up the Traversal' type and its RankN-ness.
15:29:19 <jle`> by taking t as an argument
15:29:55 <koz_> jle`: I see. So how would I avoid this in the future?
15:29:58 <jle`> koz_: t is not (forall f. Cofree Operator Int -> f (Cofree Operator Int))
15:30:18 <jle`> you can factor out the traversal as its own function
15:30:26 <jle`> ix i = go
15:30:30 <jle`>   where
15:30:37 <jle`>   go :: Traversal' Formula (Cofree Operator Int)
15:30:43 <jle`>   go t = ...
15:30:45 <koz_> Oh, right!
15:31:05 <koz_> So instead of defining how t is applied, you have go be the Traversal that does the applying?
15:31:32 <jle`> yeah. hm, actually, there might not be any avoiding expanding out the type signature if you want a helper function
15:31:44 <jle`> so this actually wouldn't help technically, it'd just make it a little cleaner
15:32:01 <jle`> that is, if you wanted to have a helper function with a type signature
15:32:11 <jle`> hm
15:32:18 <koz_> jle`: OK, well, that's still a nice idea I think.
15:32:27 <Gurkenglas> "ix i = iso unFormula Formula . go . _unwrap", and go becomes Traversal' (Cofree Operator Int) (Cofree Operator Int)
15:32:51 <koz_> Gurkenglas: Let me just write this minus magic for the moment. :P
15:33:04 <koz_> I know it's odd, but I need understanding from first principles.
15:33:05 <Gurkenglas> Oh hey jle` just had the same idea I did :D
15:34:22 <jle`> yeah.  well, i think if you wanted to make an internal helper function "inside" go, and needed to give it a type signature, there's no getting around expanding the type synonym
15:34:38 <jle`> but i never actually work with those type synonyms directly so i wouldn't know for sure if there's not some way
15:34:58 * hackagebot freddy 0.1.2.0 - RabbitMQ Messaging API supporting request-response  https://hackage.haskell.org/package/freddy-0.1.2.0 (indrek)
15:41:41 <javjarfer> erisco, very interesting! I will read about that when I read a bit more about this... 
15:44:05 <elliptic00> let notVowel = makeRegex "[^aeiou]" :: Regex
15:44:33 <alercah> why make that a regex? that's overkill
15:44:45 <elliptic00> anyone can explain to me what is ::Regex here? it is weird to me why we need ::Regex
15:45:04 <alercah> :t makeRegex
15:45:06 <lambdabot> error: Variable not in scope: makeRegex
15:45:13 <alercah> what is the type of makeRegex?
15:45:20 <koz_> jle` and Gurkenglas: Did I do it right here? https://paste.rel4tion.org/407
15:48:07 <Gurkenglas> Looks right.
15:48:32 <hpc> searching hoogle for "vowel" is entertaining
15:48:56 <koz_> Gurkenglas: OK, so now, I can (hopefully) write the mutator.
15:52:12 <jle`> koz_: alternatively you can just pass in t to go
15:52:38 <jle`> and go's type signature will just be Traversal' Formula (O (C O I))
15:52:49 <jle`> then it can have a nice sig :)
15:53:22 <koz_> jle`: Yeah, I guess. Now I have to figure out the mutator construction.
15:53:25 <jle`> ix i t = fmap Formula . go . unFormula, and you'd have go :: Traversal' ....; go t (x :< xs) = ...
15:53:38 <jle`> type signature problems are gone :)
16:00:26 <javjarfer> jle`, the reason why Just is promoted to a poly-kinded type constructor it's because Maybe had the form * -> * before being promoted? (Was parametriced and that parameter used in Just)
16:04:09 <byorgey> hpc: why? I get "no results found"
16:05:39 <koz_> Is there a monadic 'over' in lens?
16:07:03 <jle`> javjarfer: Just takes a value of type 'a' and returns a value of type 'Maybe a'
16:07:33 <jle`> javjarfer: 'Just takes a type of kind `a` and returns a type of kind `Maybe a`
16:07:58 <jle`> javjarfer: if i applied Just to (True :: Bool), i'd expect a Maybe Bool
16:08:13 <jle`> javjarfer: if i applied 'Just to ('True :: Bool), i'd expect a Maybe Bool
16:08:41 <glguy> koz_: Yes, the lens itself is a monadic over
16:09:04 <jle`> koz_: 'traverseOf'
16:09:06 <koz_> glguy: I'm trying to do an action in the context of MonadRandom.
16:09:16 <jle`> but traverseOf = id ;_
16:09:19 <jle`> * ;)
16:09:25 <jle`> :t traverseOf
16:09:27 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
16:09:28 <glguy> koz_: OK
16:10:08 <koz_> glguy: So what I wanna do is write something like 'over (singular (ix target)) doMonadicThing f'.
16:10:14 <koz_> (I know target will hit)
16:10:30 <koz_> Where 'doMonadicThing' requires use of MonadRandom.
16:10:30 <jle`> traverseOf, or just id
16:10:33 <glguy> koz_: OK, delete over
16:11:04 <koz_> glguy: So it'd be '(singular (ix target)) doMonadicThing f'?
16:11:09 <koz_> And then x <- that out?
16:11:14 <jle`> traverseOf :: Lens s t a b -> (a -> f b) -> (s -> f t)
16:11:29 <jle`> over     :: Lens s t a b -> (a ->   b) -> (s ->   t)
16:11:50 <jle`> but also, traverseOf is just id
16:11:59 <koz_> jle`: Ah, I think I get it.
16:12:09 <koz_> Let me try and write it.
16:12:50 <javjarfer> jle`, thanks for clarification, that is what I tried to mean, finally I get it
16:12:59 <koz_> Wow, it really works! Thanks jle` and glguy!
16:13:08 <koz_> Lenses are cooler than I ever thought possible.
16:13:21 <jle`> yeah, traverseOf = id because of the way lenses/traversals are encoded in the lens library
16:13:27 <jle`> did you notice the type of a traversal?
16:13:41 <koz_> jle`: Not until you just pointed it out to me.
16:13:54 <jle`> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> (s -> f t)
16:14:04 <jle`> that's basically lifting an (a -> f b) to an (s -> f t)
16:14:12 <jle`> which is what you wanted originally :o
16:16:10 <monando> How do I do rewrite rules in pure Haskell?
16:16:46 <koz_> jle`: I see. Thanks!
16:16:48 <jle`> what do you mean by pure haskell?
16:16:53 <koz_> I should have resorted to lenses earlier, lol.
16:17:03 <monando> Not using language extension trickery
16:17:26 <koz_> monando: You mean Haskell2010 only?
16:17:31 <koz_> Or Haskell98 only?
16:17:40 <monando> Rewrite rules is since kind of pragma
16:17:47 <jle`> you don't need language extensions to do rewrite rules, but also rewrite rules aren't a part of Haskell, they're a feature of compilers
16:17:48 <monando> Without that
16:17:50 <geekosaur> um. rewrite rules are an extension, just not covered by the language
16:18:05 <jle`> rewrite rules aren't really language extensions, they're basically compiler flags
16:18:12 <jle`> so that's like asking if you can implement -O2 within haskell
16:18:22 <jle`> or -fllvm
16:18:23 <monando> I want to factor out patterns which I know are equivalent to id
16:18:58 <jle`> grep ?
16:18:59 <monando> To avoid unnecessary computation
16:19:30 <jle`> you can run your source code through a preprocessor maybe, if you don't want to leverage any compilers
16:20:16 <jle`> rewrite rules are basically a way to tell the compiler how you want it to compile your code
16:20:27 <monando> Eg 3 * 5 * 3 / 5 can be examined to find a permutation where the * 5/5 can be omitted
16:20:32 <jle`> they aren't a part of haskell
16:20:43 <monando> That's why I want to avoid them
16:20:58 <jle`> ah. well, if you represent your numbers as a data structure/tree, you can inspect the tree and see
16:21:25 <jle`> data MyNum = AnInt Int | Mul MyNum MyNum | Div MyNum MyNum | ...
16:21:32 <monando> So I should fold a list of functions?
16:21:35 <jle`> and you can inspect that tree within haskell
16:21:56 <jle`> refactorNum x = case x of Mul a b -> ...
16:22:06 <monando> Ok
16:22:32 <monando> But I want to work with lists of functions composed with (.)
16:22:54 <jle`> if you have a (MyNum -> MyNum) function that optimizes, you can compose multiple ones with (.)
16:23:00 <yulax> hej,
16:23:01 <monando> I guess a use a Tree if the functions have more than 2 arguments
16:23:06 <jle`> optimizeAlot = optimize1 . optimize2
16:23:09 <Fairy> I read that a right-fold works on infinite lists (it reaches start eventually), while a left-fold doesn't - this doesn't make sense, how would a  foldr  deal with an infinite list? Where would it start?
16:23:22 <jle`> Fairy: look at the source of foldr and all will be seen
16:23:26 <jle`> @src foldr
16:23:27 <lambdabot> foldr f z []     = z
16:23:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:23:33 <jle`> it starts with 'f'
16:23:40 <yulax> i have a problem that i am confused about, from "haskell, the craft of functional programming"
16:23:42 <utdemir> Hey. Why doesn't this syntax for -XTypeFamilyDependencies work? "type family Replicate i t = r | i t -> r where ...". It says syntax error on "t".
16:23:52 <yulax> i have to compute the integer square root
16:24:08 <jle`> > foldr (\x _ -> x*2) 0 [1..]
16:24:10 <lambdabot>  2
16:24:15 <monando> It's basically like storing a function definition as a value in a way it can be manipulated
16:24:16 <jle`> ^ Fairy 
16:24:34 <yulax> I came to this page https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division
16:24:53 <jle`> Fairy: foldr f z (1:[2..]) is f 1 (foldr f z [2..]), and if you apply (\x _ -> x*2) to that, you get 1*2
16:25:00 <yulax> what i dont understand about the integer square root, is how wikipedia explain it.
16:25:18 <yulax> (i understand the basic concept of it)
16:25:25 <jle`> utdemir: er, i t -> r is already implied by the fact that it's a type family
16:25:46 <jle`> do you mean to say t r -> i or something?
16:26:22 <utdemir> jle`: Oh I meant, r -> i t
16:26:35 <utdemir> Now it isn't a syntax error, but gives another error, looking to it now. thanks
16:26:46 <yulax> i am assuming that the sequenc x increments by one, and we assume that x(0) is equal to n, the value that we are trying to find
16:30:18 <yulax> this is a really strange problem for me. it seems like something remarkably simple
16:48:13 <Fairy> jle` ok, I think that made sense, thanks ;)
17:05:48 <calsaverini> @lambdabot
17:05:48 <lambdabot> Unknown command, try @list
17:05:52 <calsaverini> @list
17:05:52 <lambdabot> What module?  Try @listmodules for some ideas.
17:05:57 <calsaverini> @pf 
17:05:58 <lambdabot> Maybe you meant: pl bf
17:06:35 <calsaverini> @pf cons x xs = List (\c e -> c x $ foldList xs c e)
17:06:35 <lambdabot> Maybe you meant: pl bf
17:06:38 <calsaverini> pl
17:07:00 <calsaverini> @pl cons x xs = List (\c e -> c x $ foldList xs c e)
17:07:02 <lambdabot> cons = (List .) . (. foldList) . ap . ((.) .) . flip id
17:07:45 <calsaverini> @hoogle ap
17:07:48 <lambdabot> Control.Monad ap :: (Monad m) => m (a -> b) -> m a -> m b
17:07:48 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
17:07:48 <lambdabot> Text.ProtocolBuffers.Header ap :: Monad m => m (a -> b) -> m a -> m b
17:10:20 <ReinH> calsaverini: Please us a private message unless you're using lambdabot to demonstrate something
17:10:50 <ReinH> *use
17:13:00 <calsaverini> sorry, I thought I was in pvt
17:13:19 <calsaverini> I'm using a new client and I'm confusing the windows
17:26:22 <hsgumby> @src maximumBy
17:26:23 <lambdabot> Source not found. Whoa.
17:35:01 * hackagebot netwire-input-javascript 0.0.2 - JavaScript instance of netwire-input  https://hackage.haskell.org/package/netwire-input-javascript-0.0.2 (ZioCrocifisso)
18:14:53 <camm> Hello everyone, may you know something like Byebug (https://github.com/deivid-rodriguez/byebug) for Haskell? Or, can you tell me which tools (libraries, programs, etc) for debugging, please?
18:47:19 <ReinH> ghci has some debugging features
18:55:14 <benzrf> ReinH: they left
18:55:22 <ReinH> k
19:00:09 <slack1256> I worry about monad trans stacks size because the amount of nested (>>=) I hve to do each time
19:00:15 <slack1256> Is misguided that concern?
19:00:57 <EvanR> i heard theres some optimizations unlocked by these fancy libs mtl, transformers
19:03:58 <monando> I don't get monad transformers
19:04:19 <monando> What's the dealio?
19:04:54 <EvanR> they allow you to increase the amount of boilerplate support required to do stuff without only 1 line of code
19:04:55 <dmj__> Do you have a specific question about them
19:05:03 <benzrf> EvanR: :]
19:05:09 <EvanR> s/without/with/
19:05:20 <monando> Is it like a style?
19:05:39 <monando> What's the appeal?
19:05:49 <benzrf> monando: do you understand monads
19:05:54 <monando> Yeah
19:06:06 <benzrf> well, here's an example
19:06:24 <monando> Parameterized types supporting internal concatenation
19:06:35 <benzrf> ...close enough i guess
19:06:47 <yulax> i have a strange problem
19:06:49 <yulax> http://paste.debian.net/hidden/31bba9aa/
19:06:50 <benzrf> @let newtype MyReaderT r m a = MyReaderT {runMyReaderT :: r -> m a}
19:06:53 <lambdabot>  Defined.
19:07:13 <benzrf> monando: now i can write a Monad instance for "MyReaderT r m" as long as "m" is another monad
19:07:32 <benzrf> and if i use (>>=) or return with MyReaderT r m, they will make use of the return and (>>=) for m
19:07:51 <koz_> I know I can pull the head of a Cofree by matching (like (x :< xs)). Is there a way to get at the xs *without* having to pattern-match?
19:08:04 <slack1256> Actually I do have one, is it good practice to realy on lift (m >>= f) = lift m >>= (lift . f) law from right to left to lower the complexity of >>= ?
19:08:11 <geekosaur> yulax, so what is the problem? (if it is an error message, please add the full error to the paste)
19:08:38 <monando> koz_ no
19:08:43 <slack1256> it seems that although correct decreases the generality of my code
19:09:05 <yulax> essentially, the task is "Given a function f of type Int -> Int give a recursiwe definition of a function of type Int -> Bool which on input n returns True if one or more of the values f 0, f 1....f n is zero and false otherwise"
19:09:10 <yulax> i get
19:10:19 <yulax> geekosaur: http://paste.debian.net/hidden/4e2e3c30/
19:10:42 <ReinH> yulax: show us your code
19:10:47 <yulax> i did
19:10:54 <yulax> in http://paste.debian.net/hidden/31bba9aa/
19:10:57 <monando> :t any
19:10:59 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
19:11:13 <ReinH> yulax: there is no `print' anywhere in the code you showed us
19:11:18 <yulax> right
19:11:36 <ReinH> so you haven't showed us the code
19:11:55 <geekosaur> ReiinH, the errors contain it, they're running ti in ghci and it's doing its default print
19:11:58 <yulax> ReinH: run the code and that is the errer produced
19:11:59 <ReinH> you did something in ghci, but you didn't tell us what you did
19:12:09 <ReinH> geekosaur: the statement was `print it'
19:12:16 <geekosaur> see lijnes 5, 11, 17
19:12:16 <yulax> i did :l test.hs (the file that has the code)
19:12:20 <geekosaur> the first oen got omitted
19:12:35 <monando> benzrf, so you have defined a monad in terms of the monad constraint on one of its parameters. How does this relate to monad transformers?
19:12:47 <ReinH> Oh right, that's GHC's error message for any unprintable expression
19:12:47 <geekosaur> so they are calling isZero with various parameters
19:12:54 <yulax> and then isZero func 56
19:12:54 <ReinH> so, what expression was `it'?
19:13:12 <geekosaur> *Main> isZero func 1
19:13:16 <ReinH> yulax: can you tel me the type of isZero func 56?
19:13:19 <ReinH> *tell
19:13:38 <geekosaur> and that;s the answer actually
19:13:40 <yulax> it should be false
19:13:45 <ReinH> yulax: false is not a type
19:13:45 <yulax> shouldnt it?
19:13:47 <geekosaur> it wants 3 parameters: function, current iteration, limit
19:13:57 <yulax> False
19:14:01 <ReinH> False is not a type
19:14:04 <geekosaur> you use it correctly in isZero's recursive case but forget the third parameter in ghci
19:14:18 <yulax> does `a` not provide the iteration?
19:14:28 <ReinH> you're expecting isZero func 56 to be a Bool, but it is not.
19:14:29 <geekosaur>   | a /= n && f (a) /= 0 = isZero f (a+1) n
19:14:33 <geekosaur> from original paste
19:14:56 <geekosaur> but when you call it in ghci you say *Main> isZero func 1
19:15:07 <geekosaur> so either a or n is missing there
19:15:11 <yulax> ah yes
19:15:19 <yulax> good point geekosaur 
19:15:31 <geekosaur> and it partially applies it and returns a function, which ghci can't print
19:15:32 <benzrf> monando: that is what a monad transformer is
19:15:41 <ReinH> Given that you know that it stops at 0, you don't need to keep track of both numbers
19:15:50 <ReinH> you can just start at n and keep subtracting 1 until it gets to 0
19:16:03 <yulax> yea the code appears to work in the case of "isZero func 0 56"
19:16:10 <yulax> i get false
19:16:32 <yulax> i am, as usual, doing silly things then thinking my code is wrong!
19:16:55 <monando> A monad transformer is a Monad defined in terms of a monad supplied?
19:17:05 <benzrf> yes
19:17:07 <benzrf> well -
19:17:14 <EvanR> MonadTransforer = Monad -> Monad
19:17:25 <geekosaur> ghci could do better in reporting that; at the prompt, it's far more likely you dropped a parameter and it would be nice if it said so instead of complaining about a missing Show instance for functions
19:17:26 <benzrf> you also need to be able to take an action in the monad you're supplying and turn it into an action in the bigger monad
19:17:34 <yulax> yes 
19:17:40 <benzrf> in this case that looks like "Monad m => m a -> ReaderT r m a"
19:17:41 <Cale> monando: Yes, together with a way to transform (lift) actions in the original monad so that they become actions of the newly defined one.
19:17:49 <ReinH> geekosaur: also about its implicit use of print
19:17:53 <geekosaur> that said, it's probably Hard to handle that without, say, postprocessing the error produced by the bytecode compiler
19:17:54 <Cale> :t lift
19:17:55 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
19:17:56 <geekosaur> or evaluator
19:18:08 <yulax> the code is always false since there is no integer sqrt3
19:18:31 <monando> Is lift a function of some class?
19:18:37 <benzrf> yeah, MonadTrans
19:18:37 <yulax> so when i changed func to be "func a = a*a - 9"
19:18:50 <jle`> so you could say that a monad transformer is both the (t :: Monad -> Monad) type function, as well as  its (m a -> t m a) value-level action lifter
19:18:57 <yulax> it worked
19:19:02 <yulax> what a horrid exercise
19:19:11 <ReinH> It's a decent exercise.
19:19:12 <yulax> thanks for all your help
19:19:24 <yulax> ReinH: *shrugs*
19:19:25 <ReinH> A pretty usual exercise in recursion.
19:19:29 <yulax> mm
19:19:53 <ReinH> If you think that exercise is horrid, I have a bad feeling about how the rest of the class will go
19:20:13 <monando> What's all this Identity business?
19:20:36 <ReinH> data Identity a = Identity a and a bunch of typeclass instances.
19:20:46 <monando> Thanks
19:20:58 <jle`> http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Identity.html
19:21:13 <monando> Oh, what's the point of it?
19:21:18 <geekosaur> Identity is the trivial Monad. It provides a way to define, say, a StateT transformer and then use it without an underlying monad (because there is one but it does nothing, so you just get the transformer)
19:21:24 <jle`> it's useful here and there
19:21:30 <ReinH> monando: A monad transformer adds some extra behavior to an existing monad
19:21:42 <ReinH> It might add state, or a read-only value (Reader)
19:21:49 <geekosaur> orignally we had separate State monad and StateT transformer. these days State is just StateT Identity, one definition instead of two
19:21:54 <ReinH> if that monad transforms the Identity monad, you get just the added behavior and nothing else
19:22:00 <ReinH> so State is StateT of Identity
19:22:11 <monando> So it's like the base case of a recursion which comlexifies monads?
19:22:18 <monando> Is that the style?
19:22:24 <geekosaur> which composes them in a certain restricted sense
19:22:31 <ReinH> Your intuition is nearly correct, but there's no recursion
19:22:36 <ReinH> it's the "do nothing monad"
19:22:43 <ReinH> so when you transform it, you only get the effect of the transformer
19:22:53 <ReinH> just like id is the "do nothing function"
19:22:57 <geekosaur> so we can build more complex monads out of simpler ones
19:23:01 <jle`> well, there are many uses of it, but it's useful because it's the boring monad you can give to a monad transformer
19:23:02 <ReinH> so when you compose it with something else, you just get the behavior of the other function
19:23:38 <jle`> it's like if you had a function that adds items to a list.   if you just want the items it adds, you can pass it the empty list
19:23:52 <jle`> @let addStuff xs = ["hello","world"] ++ xs
19:23:52 <ReinH> [] is the "do nothing list"
19:23:53 <lambdabot>  Defined.
19:24:04 <jle`> > addStuff ["neat","cool"]
19:24:07 <lambdabot>  ["hello","world","neat","cool"]
19:24:08 <jle`> > addStuff []
19:24:10 <lambdabot>  ["hello","world"]
19:24:13 <ReinH> 0 is the "do nothing number" when adding
19:24:14 <ReinH> and so on
19:24:34 <jle`> if you want to just get whatever addStuff adds on, you can just pass in [] to addStuff
19:25:01 <monando> I get what an identity is
19:25:46 <monando> What's interesting here is the operation it's the identity of
19:26:01 <jle`> so if you think of monad transformers as functions that take monads and add features to them
19:26:08 <jle`> if you want to just get the features that it adds, pass in Identity
19:26:34 <jle`> if i have a monad transformer `AddStuff` that adds state, environment, logging, failing, etc.
19:26:39 <jle`> and i just wanted to get the effects that it adds
19:26:49 <jle`> i'd just `AddStuff Identity`
19:26:57 <monando> Ok
19:27:00 <monando> Thanks
19:27:12 <jle`> `AddStuff Identity` is the Monad that has only the effects that AddStuff adds, nothing more
19:27:27 <jle`> just like "addStuff []" is the list that has only the items that addStuff adds, and nothing more
19:29:00 <monando> But what about this overall approach, I still don't get why it's so in vogue, is out just because Haskell = monads = cool, or are there powerful higher order functions I can define to factor out common operations over there transformer towers?
19:29:46 <monando> It*
19:29:59 <monando> These*
19:31:36 <koz_> What's the lens-y way to remove an item at index i from a list?
19:31:41 <koz_> (assuming i is a valid index, obviously)
19:31:54 <monando> I guess I can get infinite parameters this way at least
19:33:54 <monando> I would like to see an example of handling a recursively defined transformer... Can I define something like take?
19:33:58 <EvanR> monando: so you can learn more about this buy going out and writing monads yourself
19:35:12 <EvanR> make a monad which has an immutable context, an RNG, a way to cancel early
19:35:15 <EvanR> that should be enough
19:35:21 <EvanR> dont use transformers
19:35:31 <monando> I'm working with Free. It would be nice to extend it to include branching and use it to hold function definitions
19:36:51 <monando> I will write an RNG some other time
19:39:05 <jvanbure> has anyone had succes building SourceGraph recently?
19:39:20 <monando> Personally I prefer directed access over random access so I refrain from incorporating random numbers in my algorithms, obviously this breaks down for large dimensions when monte Carlo converges faster, but I'm working in 2d so normal linear algebra is not prohibitively expensive
19:40:31 <monando> Eg nearest neighbor spin magnet in n dimensions
19:41:46 <monando> Monte Carlo would be used over a stencil convolution above about n = 5
19:42:23 <EvanR> maybe you want comonads then
19:42:36 <EvanR> if youre looking for something wildly unpopular ;)
19:42:52 <Cale> My Haskell project of the day: http://cale.yi.org/reflex/PrismataUnits/PrismataUnits.jsexe/ :)
19:42:56 <monando> Yes I was investigation unfolds
19:43:02 <Cale> http://cale.yi.org/reflex/PrismataUnits/PrismataUnits.hs -- source code
19:43:59 <EvanR> unfolds... na
19:44:36 <monando> Such cool icons
19:46:02 <koz_> monando: You meant 'Wow, such cool, very icon', right?
19:46:13 <monando> If join of monad is like fold (:) [] via concat, then by the yoneda lemma comonad is like unfold producer []
19:46:54 <monando> koz_ no, i advocate neither use of that meme or any currency based upon it
19:47:31 <Lokathor> does the difference between divMod and quotRem only matter for negative numbers?
19:47:36 <monando> I actually strongly resent such subliminal programming
19:48:48 <koz_> monando: To each their own. I find it funny.
19:48:51 <monando> Also it's detracting from my new line if questioning regarding the dual of join, duplicate, which always much like an unfold despite EvanRs instance
19:49:03 <Cale> Lokathor: negative numbers are where the difference occurs
19:49:08 <monando> Appears*
19:49:15 <Cale> > (-3) `mod` 5
19:49:17 <lambdabot>  2
19:49:20 <Cale> > (-3) `rem` 5
19:49:22 <lambdabot>  -3
19:49:45 <Lokathor> okay. I'm using a vector to hold "2d" data, and just wanted to make sure that my converstion between 1d and 2d was fine with div and mod
19:49:50 <Lokathor> or if i needed to check quot and rem
19:49:58 <Lokathor> but they're all positive so i should be good
19:50:08 <EvanR> monando: its not an unfold
19:50:08 <Lokathor> well, non-negative i guess
19:50:20 <monando> :t duplicate
19:50:22 <lambdabot> error:
19:50:22 <lambdabot>     • Variable not in scope: duplicate
19:50:22 <lambdabot>     • Perhaps you meant one of these:
19:50:38 <monando> Hrmf
19:51:05 <monando> It's as much like an unfold as fold is like join
19:51:06 <EvanR> for example the convolution window thing on an array
19:51:20 <Hafydd> Is that a Unicode bullet point character? Did GHC get integrated with systemd?
19:51:31 <EvanR> you would duplicate and collapse
19:51:48 <EvanR> with fmap
19:52:16 <EvanR> where as with monads, you fmap then collapse with join
19:52:32 <EvanR> in monads you use fmap to do the duplicate
19:52:45 <monando> !?!?!?!?
19:53:33 <EvanR> but since fmap can only see "right here" you cant do stuff like convolution
19:53:33 <geekosaur> it's easiest to understand with the list monad. applying fmap to each element of the original list gets you a number of lists with 0 or more result elements; join in the list monad is concat, collapsing them to a single list
19:54:18 <geekosaur> (thta is, for the list monad, fmap is map and join is concat)
19:54:58 <monando> Are you taking about that free zipper stuff?
19:55:13 <EvanR> this is every monad, bind is fmap followed by join
19:55:50 <monando> :t concatMap (:[]))
19:55:52 <lambdabot> error: parse error on input ‘)’
19:55:58 <EvanR> in comonads, extract is duplicate followed by fmap
19:56:05 <monando> :t concatMap (:[])
19:56:07 <lambdabot> Foldable t => t b -> [b]
19:56:22 <EvanR> i mean, extend is duplicate followed by fmap
19:56:39 <lingxiao> hey all
19:56:53 <lingxiao> is anyone famiillry with python here? im a little desparate here 
19:56:56 <monando> :t [fold,join]
19:56:58 <lingxiao> i cannot seem to return a value from a recursive function
19:56:58 <lambdabot> (Monoid (m a), Foldable m, Monad m) => [m (m a) -> m a]
19:57:13 <lingxiao> something that would work in haskell does not work in python
19:57:14 <Squarism> Hurray!!! haskell + ghcjs has helped med create http://78.68.60.82:8081/hform/ 
19:57:25 <grantwu> lingxiao: PM me the issue?
19:57:30 <grantwu> or ask in #python
19:57:36 <monando> [unfold,duplicate]
19:57:41 <grantwu> Python things are offtopic here, I think...
19:57:41 <Squarism> forms-described-by-a-function
19:57:43 <lingxiao> http://lpaste.net/249460
19:57:54 <lingxiao> grantwu i just pastd it ====^
19:58:02 <Squarism> ..with unlimited nesting
19:58:08 <lingxiao> in line 4, return board.moves is not returning anything
19:58:17 <grantwu> lingxiao: Your recursive case doesn't return anything
19:58:25 <lingxiao> yeah the problem is if i return it
19:58:31 <lingxiao> it seems like the function just stops?
19:58:42 <grantwu> Well, yes... you can only return once
19:58:56 <lingxiao> yeah.. it's a in a for loop
19:59:01 <grantwu> You need to somehow combine the results of your recursive calls
19:59:03 <lingxiao> so Im not sure how to express this
20:00:16 <monando> Squarism strange page
20:01:06 <lingxiao> ok here: http://lpaste.net/249460
20:01:43 <lingxiao> grantwu so I've named the output to dl_search ... but it's still not clear to me how to combine the values
20:01:59 <grantwu> lingxiao: Actually... I think your base case isn't right
20:02:05 <lingxiao> how so?
20:02:38 <grantwu> oh wait, no, your base case is right
20:03:00 <lingxiao> yea it's just really fraustrating, i dont know how to pass the values into the base case
20:03:08 <grantwu> You need to check if any of your recursive calls return a result (i.e. dl_search(...) is not None)
20:03:11 <Lokathor> :t fromMaybe
20:03:12 <lambdabot> a -> Maybe a -> a
20:03:26 <grantwu> If so, you can just return that, otherwise, return None
20:03:36 <grantwu> (return None after your loop)
20:04:03 <grantwu> I'm not sure exactly how you'd get this sort of short circuiting behavior with Haskell... foldr perhaps/
20:04:27 <lingxiao> wait i dont want things to short circut though
20:04:34 <Squarism> monando, Strange?
20:04:36 -lingxiao(~lingxiao@2607:f470:6:400d:7115:4a77:b909:7399)- isnt that what return would do?
20:04:57 <EvanR> o_o
20:05:05 <grantwu> lingxiao: You want to continue searching for solutions after you've found it?
20:05:16 <lingxiao> yeah i want to find all solutions
20:05:21 <grantwu> ah
20:05:29 <grantwu> this reminds me of the list monad, almost?
20:06:03 <grantwu> because the recursive call returns a list of solutions
20:06:06 <lingxiao> yeah none of those things i can use here though
20:06:09 <grantwu> then you'd do the Python equivalent of concatMap
20:06:14 <lingxiao> which is why im having trouble expressing it
20:06:29 <grantwu> well, just make your function return a list of solutions and then add a step which concats everything together
20:06:44 <lingxiao> yeah that's fine but i cant even express that:(
20:06:51 <grantwu> http://stackoverflow.com/questions/952914/making-a-flat-list-out-of-list-of-lists-in-python might help you?
20:07:02 <ReinH> This isn't a python channel.
20:07:14 <lingxiao> i know but that one is dead
20:07:22 <EvanR> find it hard to believe the python channel is dead
20:07:25 <ReinH> That's a bad argument.
20:07:38 <ReinH> If your supermarket is closed, do you go to a pet store to buy milk?
20:07:44 <lingxiao> #python is dead to me
20:07:45 <grantwu> lingxiao: Yeah, I would go to #haskell-offtopic
20:07:54 <geekosaur> aaand we are seeing here one of the occupational hazards of learning haskell: you want to do the same things in languages that aren't really cut out for it :)
20:08:03 <lingxiao> ok i'll see you there
20:08:11 <lingxiao> yea its really fraustrating
20:08:17 <lingxiao> i feel dumber by the line of code
20:08:17 <EvanR> ignorance is bliss
20:08:43 <ab9rf> i've used bliss, it's not that great
20:09:14 <geekosaur> heh indeed
20:09:23 * geekosaur has not used it but has been exposed to it...
20:09:56 <grantwu> whenever I do an interview in Python I often wish I has haskell ADTs
20:09:57 <geekosaur> let's just say that after encountering bliss, one understands why C was considered such a huge step forward for its time
20:10:01 <ab9rf> mostly i just read it, but i did write a couple of tiny programs in it about 3 decades ago
20:10:23 <grantwu> But then state or hashmaps becomes useful and I'm relieved that I had effects
20:10:29 <EvanR> i thought we were surrepticiously talking about drugs for a second
20:10:37 <slack1256> heh
20:10:53 <ab9rf> lots of dots
20:10:57 <geekosaur> well, it could well have a mind-numbing effect >.>
20:11:07 <grantwu> yeah, my last interview asked me to solve problems in ways where I just couldn't pay the logn tax...
20:11:14 <MarcelineVQ> yeah sooo python is off topic but this isn't? :>
20:11:23 <ab9rf> fair point
20:11:26 <geekosaur> true
20:11:41 <EvanR> can you show me how to do concatMap in bliss
20:11:54 <ab9rf> EvanR: please don't make me hurt you
20:16:21 <EvanR> what does amortized constant time mean
20:17:22 <EvanR> constant on average?
20:18:08 <ReinH> basically
20:18:28 <ReinH> https://en.wikipedia.org/wiki/Amortized_analysis
20:20:32 <grantwu> It's a bit more refined than on average
20:20:41 <grantwu> "While certain operations for a given algorithm may have a significant cost in resources, other operations may not be as costly. Amortized analysis considers both the costly and less costly operations together over the whole series of operations of the algorithm. This may include accounting for different types of input, length of the input, and other factors that affect its performance."
20:22:28 <ReinH> Yes, that's why I gave the link.
20:23:16 <EvanR> reddit
20:38:06 <koz_> I have an expression tree whose leaves are Int-labelled. I wanna write a catamorphism that returns (count of most frequent label)/(count of leaves). How would I write this?
20:46:37 <Lokathor> :t filter
20:46:39 <lambdabot> (a -> Bool) -> [a] -> [a]
20:48:18 <ertes> koz_: do you know which label is the most frequent without traversing?
20:49:15 <koz_> ertes: No - so I need *two* different catas.
20:49:25 <koz_> I can do the leaf counting cata, but I'm not sure how to do the most frequent label cata.
20:49:29 <grantwu> I read that as you need two different cats.
20:49:34 <grantwu> I agree, you need more cats.
20:49:34 <ertes> koz_: or a data structure that trakcs that information
20:49:37 <koz_> (should I just cata on an assoc-list or a map or something?)
20:49:39 <ertes> tracks
20:49:39 <glguy> Just collect the leaves into  Map Leaf Count
20:49:55 <koz_> glguy: Yeah, that'd work.
20:49:57 <glguy> combine them by summing when two collide
20:50:16 <glguy> and then at the end you can pick the most frequent and sum the total count
20:50:20 <ertes> koz_: in any case, i'd just convert to list, then fold
20:50:26 <neochronomo> Isn't Haskell supposed to be a  completely "pure language"?
20:50:39 <ertes> neochronomo: yeah
20:51:12 <neochronomo> ertes: Alright, then how come in my course we're learning about I/O, and they explicitly say that I/O in Haskell is impure?
20:51:22 <nshepperd1> That's pure as in freedom, not pure as in beer
20:51:28 <ertes> neochronomo: they are wrong…  it's actually pure
20:51:40 <glguy> Evaluation in Haskell is pure, executing IO doesn't conflict with that
20:51:50 <neochronomo> ertes: is it pure to use do {} and if/thens ?
20:51:53 <grantwu> neochronomo: How would you have pure I/O?
20:51:56 <ertes> neochronomo: yes
20:52:22 <grantwu> the whole purpose of running a program is to get a side effect
20:52:30 <grantwu> that's why main is IO a
20:52:41 <neochronomo> grantwu: could you explain "side effect" to me in the programming sense?
20:52:49 <ertes> neochronomo: some teachers explain the type (IO A) as the "type of impure values of type A", but that's a misleading (and arguably wrong) explanation
20:52:57 <grantwu> er, well, you can have pure I/O in the sense that Haskell does it
20:53:04 <ertes> neochronomo: an (IO A) is "a program that produces an A", which is a pure notion
20:53:28 <grantwu> neochronomo: A side effect is just... a change in the "world" caused by executing a function
20:53:30 <neochronomo> ertes: interesting, well the course is from Glasgow.. so if they're teaching it wrong it would be weird
20:53:50 <ertes> neochronomo: i don't know if that's the case, since i didn't visit their course =)
20:54:00 <koz_> Argh, lens won't compile for containers > 0.5.8...
20:54:04 <koz_> Someone should prod Ed.
20:54:05 <ertes> but if they say that IO is impure, i would be highly skeptical
20:54:47 <neochronomo> ertes: well if you're curious, it's this course directly from the Uni of Glasgow: https://www.futurelearn.com/courses/functional-programming-haskell/
20:55:11 <neochronomo> ertes: not trying to say you're wrong, it's just weird that they are
20:55:25 <grantwu> what exactly do they say?
20:55:39 <ertes> neochronomo: did my IO mini-explanation make sense to you?
20:55:57 <neochronomo> grantwu: "Input and output (I/O) operations are impure. They influence and interact with the ‘outside world’. Essentially, this is the only way to make computers do interesting things."
20:56:05 <neochronomo> ertes: I'm still looking over them
20:56:09 <glguy> neochronomo: No one is saying Haskell doesn't allow for effects, they are saying that evaluation in Haskell doesn't have side-effects
20:56:19 <grantwu> neochronomo: That seems correct
20:56:34 <grantwu> That quote isn't saying that the I/O monad is inherently impure
20:56:42 <neochronomo> ertes: You're saying that it's pure because it produces the same result? that (IO a) will always produce a therefore it's pure?
20:56:54 <grantwu> constructing a value of type I/O a is a pure operation
20:57:07 <ertes> neochronomo: yeah, that one doesn't say: "I/O in haskell is impure"…  it essentially says: "I/O is impure [and haskell has pure mechanisms to express I/O]"
20:57:08 <grantwu> but getting it to actually perform the I/O - i.e. unsafePerformIO - is impure
20:57:47 <ertes> neochronomo: let me put it this way:  if you say "x = getLine", where getLine is the program that reads a line, then "x" is the same program
20:58:09 <ertes> in particular 'x' is not the line read, and it's not "an impure string", it's the program that reads a line
20:59:00 <neochronomo> ertes: but we use x<-getLine... is that not impure since it's the line being read?
20:59:33 <ertes> neochronomo: no, but to explain why, you would have to understand how IO programs compose (and what do-notation ultimately desugars to)
20:59:55 <ertes> in other words: learn haskell to see why it's still pure =)
21:00:00 <neochronomo> ertes: maybe they'll explain that later int he course
21:00:09 <glguy> neochronomo: No line is read just because you wrote x<-getLine. For example:   do let x = (do y <- getLine; putStrLn y); putStrLn "Hello"
21:00:11 <ertes> neochronomo: they certainly will
21:00:14 <glguy> neochronomo: No line was read
21:00:26 <grantwu> I like to think of the IO monad as a way to write down plans for what sort of IO I want to do
21:00:50 <neochronomo> they're also saving the "monad" thing til later in the course.. they said that explicitly. 
21:00:51 <ertes> glguy: (syntactic subtlety: you need braces for the 'let')
21:00:57 <grantwu> The plan doesn't get executed until I do unsafePerformIO on it, or unless I set main equal to it at which point the runtime executes the I/O for you
21:01:09 <glguy> ertes: I don't think that's going to trip neochronomo tonight
21:01:27 <ertes> glguy: sure, just saying =)
21:01:34 <neonfuz> How do I say "type I don't care about" in type declarations
21:02:14 <neochronomo> Haskell doesn't have generic types right?
21:02:28 <ertes> neochronomo: haskell has parametric polymorphism
21:02:31 <ertes> :t id
21:02:33 <lambdabot> a -> a
21:02:37 <ertes> > id "blah"
21:02:39 <lambdabot>  "blah"
21:02:40 <ertes> > id 15
21:02:41 <grantwu> neochronomo: Yeah, you don't really need to know about the generalized concept of a monad - just understand that IO a represents an computation that does I/O (that hasn't been executed)
21:02:46 <lambdabot>  15
21:02:47 <glguy> neonfuz: Generally by not providing a type declaration. There's an extension for allowing partial type signatures
21:03:04 <neochronomo> grantwu: alright, thanks
21:03:33 <grantwu> neochronomo: https://blog.jle.im/entry/io-monad-considered-harmful might be useful... or might not
21:03:59 <neochronomo> grantwu: I should probablt just wait for them to cover it later in the course haha
21:04:51 <grantwu> neochronomo: Yeah probably - the blog post argues for the pedagogical approach that course seems to be taking (i.e. do not talk about monads when introducing I/O)
21:05:06 <ertes> neochronomo: the post (which is quite useful IMO, but probably not right now) is about the phrase "IO monad", not about IO or monads =)
21:09:31 <mbuf> What is the recommended approach to upgrading your dependencies for your package one at a time to check if they don't break anything?
21:10:38 <ertes> mbuf: first make sure you understand:
21:10:41 <ertes> @where PVP
21:10:41 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
21:11:57 <ertes> most packages follow it, and that should already give you an idea how to approach it
21:12:19 <mbuf> ertes, thanks! will read
21:17:20 <geppettodivacin> Haskell is the first language I've seen that makes "generics" actually look and feel natural.
21:24:35 <neonfuz> glguy: okay, so the only way to do partial signatures is thorugh an extension? How do you do that normally
21:25:45 <grantwu> could type holes be useful for you?
21:27:56 <ertes> typed holes are on the value level
21:29:26 <glguy> neonfuz: The other way to provide partial type information is with a helper function
21:30:32 <glguy> :t let helper :: f Char -> f Char; helper = id in \f xs -> helper (map f xs)
21:30:34 <lambdabot> (a -> Char) -> [a] -> [Char]
21:52:09 <koz_> Could someone help me understand Control.Lens.Wrapped in practical use?
21:52:16 <koz_> I'm a bit mystified by it.
21:53:29 <glguy> It provides a typeclass for isomorphisms between newtypes and the types those newtypes wrap
21:53:53 <koz_> glguy: I've defined Wrapped for my type (by providing the Unwrapped type definition). How would I use it?
21:54:59 <riaqn> hey gues, how to use a type a=b definition in a module not exported?
21:55:52 <Clint> what
21:58:32 <lpaste> glguy pasted “for koz_” at http://lpaste.net/249663
22:00:03 <koz_> glguy: Thanks!
22:00:05 <Clint> how is that more "convenient and efficient" than Control.Newtype?
22:01:07 <glguy> I don't know; I haven't used Control.Newtype.
22:01:59 <Clint> hmm
22:03:47 <glguy> It doesn't take much to get caught up on “newtype” seeing how it's a single module. Wrapped is compositional and integrates into the rest of the lens framework, for one.
22:04:31 <glguy> I’m not sure why it is more efficient.
22:04:54 <Clint> i'm sure edwardk knows
22:04:59 <edwardk> ?
22:05:12 * edwardk tunes in
22:05:16 <glguy> “The Wrapped class provides similar functionality as Control.Newtype, from the newtype package, but in a more convenient and efficient form.”
22:05:23 <lpaste> koz_ annotated “for koz_” with “glguy: What should I use here? (annotation)” at http://lpaste.net/249663#a249670
22:05:42 <edwardk> there was a reason it was more efficient, i forget now =)
22:05:47 <Clint> ha
22:06:23 <koz_> edwardk: Hi! Thought you might like to know that lens 4.14 won't build against containers 0.5.8.1. Is this intentional?
22:06:40 <edwardk> or maybe that was raw braggadocio
22:06:51 <edwardk> koz_: not to my knowledge
22:07:10 <edwardk> koz_: what is the error? can you file an issue?
22:07:15 <glguy> koz_: We just haven’t had a release since that was updated.
22:07:22 <koz_> edwardk: Cabal fails to solve the constraint.
22:07:41 <glguy> It fails to solve the constraint because it’s incompatible
22:07:45 <edwardk> file an issue with lens, we're probably due a new release or to relax bounds
22:08:01 <koz_> edwardk: OK, I will, once I've got this bit of code written.
22:08:01 <edwardk> github.com/ekmett/lens/issues or whatever
22:08:05 <glguy> Don’t file an issue, since the fix is already in master
22:08:10 <edwardk> oh k
22:08:12 <koz_> glguy: Oh, OK then.
22:08:28 <edwardk> sounds like glguy is more on top of things than i am
22:08:42 <glguy> Ryan fixed it in e089254441cf77bac3f6baebdce8fe5d4b3ac8e7
22:09:07 * edwardk is currently trying to figure out why the left eye started flickering in his vr application after he updated steam
22:09:24 <glguy> edwardk: Make sure that the world isn't flickering in your left eye outside of VR first!
22:09:36 <edwardk> just the left one, seems to be flickering between the left and right eye's contents
22:09:43 <edwardk> while the right eye remains properly stable
22:10:09 <edwardk> its happening in the compositor outside of my application
22:10:15 <edwardk> so something changed in steamvr
22:10:42 <edwardk> but other apps work fine
22:10:52 <edwardk> so it must be something about how i'm handling the handoff
22:11:05 <nitrix> VR sounds fun.
22:11:28 <edwardk> i sort of micro-optimized the way i manage the resolve buffer to shave a couple of milliseconds off, and its probably something in there =/
22:12:57 <edwardk> nitrix: the oculus is polished like whoa, but feels kinda weird. just display, the touch controller isn't ready yet, so vive is currently eating their lunch. room scale is a much better experience. the vive is good for what it does, but the lack of asynchronous time/spacewarp, etc. makes it so you have to work harder to keep 90fps steady
22:13:29 <edwardk> playstation vr and gear vr have the potential for _much_ larger installed bases, but i don't really know the control story there
22:14:06 <edwardk> i've mostly been playing with super-fancy water caustics
22:14:35 <grantwu> don't forget Daydream :P
22:14:49 <grantwu> I bought a Pixel and realized afterwards that I get a free VR headset
22:14:58 <grantwu> edwardk: Are you doing that in Haskell?
22:15:00 <edwardk> meh, daydream will hit install numbers around the same as vive, etc. with cruddier controls =)
22:15:10 <grantwu> I don't think Daydream is comparable to Vive?
22:15:17 <edwardk> grantwu: right now i'm doing things in c++ that may change
22:15:20 <grantwu> More comparable to Gear VR...
22:15:37 <edwardk> grantwu: i'm just going by some industry analyst numbers about # of expected installations
22:15:39 <grantwu> Ah yeah, I imagine the GC latencies would be hard to hit...
22:16:38 <koz_> edwardk or glguy: I'm still a bit confused over what should go in the gap here: http://lpaste.net/249684
22:16:50 <edwardk> playstation and gear have much larger markets open to them, can see something like 2-3 million units going out. vive/daydream aren't likely to peak over a fourth to a sixth of that
22:17:05 <glguy> koz_: Write it without lenses first to make it more obvious what it is you're actually doing
22:17:11 <grantwu> edwardk: Sure - but the Daydream is in a different price point than the Vive, I'd argue that the Daydream doesn't compete with the Vive at all
22:17:12 <glguy> and I can jump in after that
22:17:34 <koz_> glguy: Without lenses, I just need to do 'cocata (const (countOp)) . unFormula'.
22:18:04 <edwardk> i wasn't indicating they were targeting the same niche, mearly that that they are both seem to have the same sort of end install base of say 400k units
22:18:10 <edwardk> er merely
22:18:26 <edwardk> the vive and oculus are the two i've been experimenting with primarily
22:18:35 <edwardk> i have a cardboard set up as well
22:18:40 <grantwu> Yeah, makes sense
22:19:23 <edwardk> i've been focusing on the vive because the development experience is easy
22:19:30 <edwardk> and i like roomscale
22:20:05 <elliptic00> Can I think data Maybe a = Just a | Nothing  is like interface and subclass in Java?
22:20:08 <elliptic00> interface Maybe<T>{
22:20:08 <elliptic00> }
22:20:09 <elliptic00> class Just implements Maybe<String>{
22:20:10 <elliptic00>     public Just(String s){
22:20:12 <elliptic00>     }
22:20:14 <elliptic00> }
22:20:16 <elliptic00> class Nothing implements Maybe{
22:20:18 <elliptic00>     public Nothing(){}
22:20:39 <grantwu> Oops.
22:21:07 <edwardk> anyways daydream is kinda messy just because doing things like opengl dev on android sucks rather badly
22:21:22 <edwardk> you lose context pretty randomly, like doing xp dev back in the day
22:21:29 <grantwu> Don't they have Vulkan now
22:21:44 <edwardk> in theory, but now i have to maintain two engines
22:21:58 <edwardk> at least with vulkan i can share shaders with gl
22:22:21 <edwardk> but its still a pretty invasive change in the coding style
22:22:26 <grantwu> (also this should possibly go in #haskell-offtopic)
22:22:36 <edwardk> or #haskell-game
22:33:25 <ashishnegi> hi.. what is the best type-safe way to use config files in haskell ? which package should i use ? please recommend
22:35:09 * hackagebot curryrs 0.1.0.0 - Easy to use FFI Bridge for using Rust in Haskell  https://hackage.haskell.org/package/curryrs-0.1.0.0 (mgattozzi)
22:35:11 * hackagebot hspec-meta 2.3.1 - A version of Hspec which is used to test Hspec itself  https://hackage.haskell.org/package/hspec-meta-2.3.1 (SimonHengel)
22:51:53 <jle`> ashishnegi: i usually do something with yaml :)
22:52:43 <rnat_> Is it imperative to learn abstract algebra to fully exploit haskell?
22:55:49 <jle`> i don't even think it's possible to fully exploit haskell
22:56:39 <EvanR> any sufficiently advanced exploitation of haskell is isomorphic to magic
22:57:00 <jle`> learning abstract algebra can help you see some pretty things in a neat way
22:57:06 <rnat_> I see, 
22:57:07 <jle`> but it's not necessary to actually use haskell
22:57:30 <jle`> i can speak english without being a shakespeare scholar :)
22:57:34 <EvanR> knowing what a monoid is would be a good idea, since it comes up a lot
22:57:38 <ashishnegi> jle`: i was looking at `http://hackage.haskell.org/package/configurator` and i see that it uses `IORef` in the config to provide auto-reload.. i was thinking of using config with Reader Monad. But with this i should not be passing its own config, but should read and create my own object and pass that to the reader-monad.. right ?
22:57:40 <EvanR> but thats about it
22:57:51 <jle`> ashishnegi: yup that's fine
22:58:14 <glguy> ashishnegi: You don't need to even use Reader, you can just pass it as an argument
22:58:25 <glguy> That'll often be a less invasive solution
22:59:36 <rnat_> jle`: agreed
22:59:39 <ashishnegi> sure.. same thing.. but passing Configurator's config is like passing mutable variable.. i should read my values like port and create another type and then pass to the argument.. right ?
23:01:08 <jle`> ashishnegi: you can jsut read it to get thet value at the time of reading
23:01:14 <jle`> and then use that for the rest of your program
23:01:18 <jle`> remember that values don't mutate
23:01:37 <jle`> of you read the number 1 from an IORef and use the 1, it's not going to mutate on you while you're using it
23:01:43 <jle`> welcome to one of the best parts about Haskell :)
23:01:55 <ashishnegi> yess.. right. thanks. 
23:02:23 <jle`> ashishnegi: using an IORef, you can read an immutable value out it using readIORef
23:03:19 <jle`> the "ref" part is that every time you use execute readIORef, the result you get might be different
23:03:33 <jle`> but that result itself is an immutable value
23:03:36 <jle`> kind of like 'getLine' :)
23:09:14 <ydl> is there a way to "break out of a fold" in the sense that the fold stops processing the list given a condition? specifically, my problem is the following: i want to fold over a Foldable, f a, with a function g :: (a -> b -> Maybe b) such that i continue accumulating b/processing the foldable f a until g returns Nothing, at which point i would like the result of the last computation to return Maybe
23:10:04 <ydl> for example, in an imperative language I could do this with exceptions or loop breaks or other methods of nonlocal exits
23:12:27 <pavonia> You want an unfold
23:12:31 <pavonia> :t unfold
23:12:36 <EvanR> :t unfoldr
23:12:36 <lambdabot> error:
23:12:36 <lambdabot>     • Variable not in scope: unfold
23:12:36 <lambdabot>     • Perhaps you meant one of these:
23:12:40 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
23:12:58 <EvanR> which is something different
23:13:21 <pavonia> Hhm
23:13:26 <ydl> I don't think this quite does what i want
23:13:44 <ashishnegi> ydl:  `foldr` if your fn is lazy on first argument.. 
23:14:12 <EvanR> yes foldr has the ability to end early, under the right circumstances
23:14:43 <ydl> can you explain how I would do it in this case? the function can be lazy in the first argument
23:15:24 <aarvar> you mean the second argument, right?
23:15:26 <EvanR> what is your function going to do?
23:15:36 <EvanR> what are you doing with the result of the fold
23:15:47 <ydl> EvanR: i want access to it directly
23:15:55 <EvanR> huh
23:16:58 <ashishnegi> ydl: can you give body of `g`
23:17:07 <aarvar> ydl: foldr f z (x:xs) = f x (foldr f z xs)
23:17:09 <ydl> an example: the foldable is a list [0..10], and g a b = if b > 7 then Nothing else Just (a + b)
23:17:29 <aarvar> so if the f doesn't need to evaluate the second argument, then it won't recurse any further
23:18:33 <ydl> in this particular case there is a way using scanl, but I was wondering what the solution is for a generic Foldable. is there some trick that can be played with a special Monoid and foldMap?
23:18:42 <ashishnegi> ydl: passing `flip g` to foldr should work then..
23:19:53 <ydl> ashishnegi: not quite, it is important that the condition "b > 7" is on the accumulating parameter
23:20:33 <aarvar> ydl: that function is of the wrong type, isn't it?
23:20:41 <EvanR> ydl: a generic foldable... what would your stop at 7 mean then?
23:20:56 <EvanR> oh, stop at 7 on the accumulator
23:21:13 <aarvar> oh, I see what you mean
23:21:21 <aarvar> sum and stop if the sum is > 7?
23:21:22 <ydl> aarvar: it's the wrong type for a fold, yes, but a monadic fold or something similar might be able to handle it
23:21:23 <riaqn> Is it possible to derive instances  from other types(with no relation) by specifying conversion between types?
23:21:28 <EvanR> scanl makes more sense here
23:21:50 <ydl> EvanR: but you typically don't have scanl except for lists...
23:21:55 <EvanR> :t scanl
23:21:57 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
23:22:03 <EvanR> uh.
23:22:16 <riaqn> I mean, I want to get instance Num A, by specifying a conversion from A to B, where instance Num B is already established.
23:22:20 <EvanR> so much for the Foldable Traversable proposal
23:22:49 <EvanR> ydl: oh... well you can manually convert to a list, thats Foldable
23:23:01 <EvanR> you will only consume the prefix before 7
23:23:02 <ydl> EvanR: ok, but that seems inefficient :)
23:23:17 <EvanR> think of lists as loops
23:23:19 <ashishnegi> ydl: you can just write that function yourself for your datatype
23:23:37 <aarvar> which seems inefficient, the scanl or the toList?
23:23:38 <EvanR> it could be infinite even
23:24:07 <ydl> the toList seems like it might be inefficient, even if lazy it's extra indirection. unless it's reasonable that the whole list gets fused away...
23:24:21 <EvanR> looking at the intermediate accumulation with something else is exactly what scanl is for
23:24:51 <EvanR> if you think so, it would be interesting to compare it to the other solutions
23:25:01 <EvanR> haskell is really geared towards using lists
23:25:22 <EvanR> sometimes it seems like the dumbest possible way, and its awesome that that way is often fast
23:25:53 <ydl> ok. i was thinking it would be interesting to use some specialized monoid, like First and Last are used for finding elements. or learning why such a thing is impossible
23:26:18 <EvanR> finding the first what ;)
23:26:50 <EvanR> you can also write the function directly with recursion, keeping your own accumulation
23:27:00 <EvanR> this is probably much more common than even folds
23:27:33 <EvanR> that would totally avoid (that) list
23:32:47 <ydl> the thing is the monoid instance for Maybe would work great in principle, it's just unclear to me how to get foldMap to "see" that it can stop
23:33:38 <ydl> or foldr
23:35:10 * hackagebot lens 4.15 - Lenses, Folds and Traversals  https://hackage.haskell.org/package/lens-4.15 (EricMertens)
23:35:12 * hackagebot hspec-core 2.3.1 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.3.1 (SimonHengel)
23:35:14 * hackagebot hspec-discover 2.3.1 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.3.1 (SimonHengel)
23:35:16 * hackagebot hspec 2.3.1 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.3.1 (SimonHengel)
23:35:53 <hvr> weeeh... lens 4.15
23:36:29 <joncol_> Is there a recommended way to name operators that I make for my own datatypes? For instance I have a Color type, with a `colMul` function. Do people ordinarily use operators like (<**>) or something? It's a bit ugly to write `colMul` and `vecMul` etc...
23:37:01 <jle`> joncol_: defining your own operators, usually not encouraged
23:37:21 <jle`> joncol_: some style guides suggest "mul" for all, but importing things qualified
23:37:23 <jle`> idk about that one though
23:37:39 <hvr> joncol_: does a Monoid or Semigroup instance make sense for that operation?
23:38:02 <joncol_> hvr: Perhaps...
23:38:30 <joncol_> Is there Group?
23:38:31 <hvr> as then you can avoid having to name an op... :)
23:39:02 <hvr> there is likely more than one package that defines a Group class, but it's not in the core libs
23:39:14 <joncol_> Or some better category for things that have two ops (add and mul) and also can be multiplied by scalar.
23:39:50 <hvr> joncol_: https://www.reddit.com/r/haskell/comments/55spkg/is_group_class_useful/
23:40:17 <joncol_> ty
23:40:37 <hvr> `groups` seems fairly popular
23:41:11 <joncol_> hvr: That wouldn't cover the case for multiplying with scalar though, right?
23:41:25 <EvanR> joncol_: want more operators? use agda!
23:41:34 <ashishnegi> ydl: http://lpaste.net/249803  hope this helps.. you can refactor it.
23:41:39 <hvr> joncol_: 'pow' can be seen as scalar mult
23:42:03 <hvr> joncol_: if your monoid operation is addition
23:42:07 <EvanR> joncol_: scalar? are you doing linear algebra? we have some libraries which have established some convention for vector space operator punctuation
23:43:01 <joncol_> EvanR: Linear algebra and a Color class. Making a raytracer for pedagogical reasons.
23:43:19 <joncol_> Color *type I should say
23:44:10 <joncol_> EvanR: What are some of the standard libraries?
23:44:46 <hvr> joncol_: otoh, you seem to want a 'ring'
23:44:51 <hvr> since you have two ops
23:45:02 <joncol_> Is Group not two?
23:45:14 <hvr> joncol_: nope: https://en.wikipedia.org/wiki/Group_(mathematics)
23:46:43 <EvanR> joncol_: get a package for color, thats such a commonly needed type. im referring to linear, the package. also Data.Vec
23:46:53 <EvanR> hvr: you mean vector space ;)
23:47:18 <EvanR> theres also HMatrix
23:48:45 <joncol_> So the difference between group and semigroup is that the op has to be invertible?
23:49:12 <joncol_> I should google it :)
23:49:53 <EvanR> semigroup is "a monoid without necessarily an identity"
23:50:05 <EvanR> a group is a monoid with inversion
23:50:34 <EvanR> see all semigroupoid and groupoid, its the same relationship
23:50:37 <EvanR> also
23:51:21 <EvanR> (wait why is monoid over there and not between semigroupoid and groupoid
23:53:02 <joncol_> The table at the end of that wiki was good.
