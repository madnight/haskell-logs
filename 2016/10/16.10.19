00:00:35 <dmj`> Typeable a => Typeable (K a)
00:05:04 <jle`> you could create your own TypeRep-like class
00:05:13 <jle`> that you could serialize
00:05:16 <jle`> s/class/data type
00:06:49 <jle`> but you can't get around requiring an extra constraint or witness of some type on 'a', because of type erasure
00:07:19 <dmj`> the 'a' is user-defined, so consumers of the lib would have to 'deriving Typeable'
00:07:24 <dmj`> on their 'a's
00:07:40 * hackagebot ekg-prometheus-adapter 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/ekg-prometheus-adapter-0.1.0.0 (AlfredoDiNapoli)
00:07:40 * hackagebot ekg-prometheus-adapter 0.1.0.1 - Easily expose your EKG metrics to Prometheus  https://hackage.haskell.org/package/ekg-prometheus-adapter-0.1.0.1 (AlfredoDiNapoli)
00:10:35 <dmj`> if we can guarantee the witness from another equivalent type, how dirty would coercion be. K a -> M,  M -> K a
00:11:56 <dmj`> jle`: wouldn't that still require deriving (TypeRepLikeClass)
00:28:04 <joss> geekosour are u there?
00:31:20 <joss> I downloaded gtk package ... then create a sandbox and install dependencies first...but happy program was missing, is it correct if I download happy program and built it on sandbox then go back to gtk installation and use cabal sandbox add-resource /to my happy direct where is installed by on sandbox? 
00:33:59 <jg> hi all. I'm reading Typeable source, TypeRep has this TyCon field that doesn't seem to be defined explicitly anywhere in Typeable. It's also labeled as 'abstract'. How does that work anyway? I'd expect at least a 'newtype' or type alias
00:46:17 <mauke> jg: :i says -- Defined in ‘GHC.Types’
00:46:29 <jg> oh
00:46:44 <mauke> same as Int or Double
00:47:38 <jg> thanks mauke, i need to learn to use :i
00:47:54 <jg> and stop assuming haskell is playing magic tricks on me
00:48:59 <mauke> I'm pretty sure GHC.Types is actually magic
00:49:17 <mauke> ':i []' shows a data definition that's syntactically invalid haskell
00:50:48 <M2tias> :i []
00:57:37 <Xnuk> data [] a = [] | a : [a]
01:02:35 * hackagebot netwire-input 0.0.6 - Input handling abstractions for netwire  https://hackage.haskell.org/package/netwire-input-0.0.6 (Mokosha)
01:02:37 * hackagebot netwire-input-glfw 0.0.6 - GLFW instance of netwire-input  https://hackage.haskell.org/package/netwire-input-glfw-0.0.6 (Mokosha)
02:27:26 <jle`> i wonder why EmptyCase cases don't give incompleteness warnings
02:27:34 <jle`> doesn't that defeat the whole point
02:28:40 <jle`> can i enable warnings for EmptyCase
02:28:55 <jle`> er, for empty cases that aren't exhaustive
02:29:14 <jle`> i feel like this is the entire point of EmptyCase
02:38:37 <ocramz> morning all
02:38:41 <jophish> hi ocramz 
02:38:51 <jophish> how's tricks?
02:45:04 <ij> In ruby I can sort_by values that have a "<"/">" which returns true or false. sortBy seems more sophisticaed, but I could achieve the same thing with sortBy (\a b -> if key a == key b then EQ else GT) list?
02:46:36 <tdammers> Haskell has the Ord typeclass to do roughly what Ruby's overloaded comparison operators do
02:46:40 <tdammers> :t (<)
02:46:42 <lambdabot> Ord a => a -> a -> Bool
02:46:45 <tdammers> :t sort
02:46:46 <fr33domlover> :t sort
02:46:47 <lambdabot> Ord a => [a] -> [a]
02:46:48 <lambdabot> Ord a => [a] -> [a]
02:46:51 <fr33domlover> :P
02:46:54 <tdammers> :)
02:47:28 <fr33domlover> there's also 'Down' for reverse order
02:47:44 <tdammers> in a nutshell, you implement Ord by writing a suitable compare method for your type, and then plain sort will work as expected
02:47:46 <fr33domlover> > sort [Down 1, Down 2, Down 3]
02:47:49 <lambdabot>  [Down 3,Down 2,Down 1]
02:47:54 <tdammers> :t compare
02:47:56 <lambdabot> Ord a => a -> a -> Ordering
02:48:21 <M2tias> wait, you need to map Down to get reverse sort?
02:48:25 <ahihi> > sortBy (flip compare) [1,2,3]
02:48:25 <Saizan_> wasn't the question just about how to actually specify this particular ordering?
02:48:27 <lambdabot>  [3,2,1]
02:48:33 <M2tias> > sort . map Down [1,2,3]
02:48:35 <lambdabot>  error:
02:48:35 <lambdabot>      • Couldn't match expected type ‘a -> [a1]’
02:48:35 <lambdabot>                    with actual type ‘[Down Integer]’
02:48:42 <M2tias> I don't know haskell ._.
02:48:51 <ocramz> :t Down
02:48:52 <lambdabot> a -> Down a
02:49:01 <M2tias> isn't that a bit complicated?
02:49:07 <Saizan_> ij: can you give an example of how you want things sorted?
02:49:19 <ahihi> (\a b -> if key a == key b then EQ else GT) seems like a strange ordering
02:49:19 <tdammers> M2tias: it is one way to do it
02:49:32 <fr33domlover> M2tias, you cal always use sortBy
02:49:40 <M2tias> oh, ok
02:49:42 <tdammers> sortBy (flip compare) -- is another
02:49:51 <fr33domlover> Down is useful in some more generic cases when you just want to say "plz reverse the order"
02:49:53 <tdammers> reverse . sort -- is yet another, though less efficient
02:50:11 <ij> Oh, there's compare! That's all I need then.
02:51:11 <M2tias> :t sort
02:51:12 <lambdabot> Ord a => [a] -> [a]
02:51:13 <ahihi> :t comparing -- see also this
02:51:15 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
02:52:41 <fr33domlover> :t sortOn
02:52:43 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
02:53:00 <lyxia> jle`: https://ghc.haskell.org/trac/ghc/ticket/10746 for some reason this is still open
02:53:59 <ahihi> huh, sortOn must be somewhat new
02:54:08 <M2tias> > sort $ map Down [1,2,3]
02:54:11 <lambdabot>  [Down 3,Down 2,Down 1]
02:54:16 <jle`> lyxia: huh, hm
02:54:20 <jle`> i wonder if there's still progress
02:54:49 <jle`> ahihi: came with ghc 7.10 i believe
02:54:54 <jle`> since base 4.8
02:54:56 <ahihi> I see
02:56:15 <ij> sortOn — that's the ruby function.
02:57:28 <ij> Sweet — with sortOn, you don't even have to de-Down the data.
02:58:46 <ahihi> > sortOn Down [1,2,3]
02:58:48 <lambdabot>  [3,2,1]
02:58:50 <ahihi> right
02:58:53 <ahihi> that's pretty nice
03:07:08 <haskell690> Hello all, I am very confused with a haskell issue
03:07:18 <haskell690> I'm trying to store 0x46000000 as a word8
03:07:29 <haskell690> but I have no idea how to construct one directly...
03:07:44 <oherrala> that value doesn't fit in Word8
03:07:56 <haskell690> Sorry, word32
03:08:05 <oherrala> :t 0x46000000 :: Word32
03:08:07 <lambdabot> Word32
03:08:12 <oherrala> that should do it :)
03:09:12 <haskell690> Ok thanks :)
03:09:20 <tdammers> numeric literals are polymorphic \o/
03:12:27 <M2tias> :t 0x46000000 :: Word8
03:12:29 <lambdabot> Word8
03:12:41 <M2tias> err
03:12:45 <M2tias> > 0x46000000 :: Word8
03:12:48 <lambdabot>  0
03:13:38 <MarcelineVQ> evaluating that in ghci should emit an overflow warning
03:13:53 <oherrala> > (maxBound :: Word8) + 1
03:13:55 <lambdabot>  0
03:33:29 <ocramz`> I want to generalize a few related methods into a typeclass; I thought of picking the actual implementation by using a phantom type, i.e. `t` in `class Solver t a where method :: Op a -> Op a -> Result a`. Why do I get a "enable AllowAmbiguousTypes"? where's the ambiguity? In not using `t` in `method`?
03:34:03 <geekosaur> yes
03:34:30 <jle`> ocramz`: yeah, if you did method x y, there wouldn't really be an obvious way to pick which 't' instance
03:34:51 <ocramz`> sure, makes sense. Thanks
03:35:00 <jle`> `method :: p t -> Op a -> Op a -> Result a` is the traditional way to give the type inference machine help
03:35:11 <jle`> just take a dummy argument involving t
03:38:16 <jle`> but as of ghc 8.0 there's a trick you can do with TypeApplications to make it work without the dummy argument
03:38:37 <jle`> but, it would involve AllowAmbiguousTypes
03:39:05 <ocramz`> jle` I have to first understand it in the classic sense an then I'll think of turning on the crazy extensions
03:39:06 <ocramz`> :D
03:39:29 <jle`> indeed :)
03:40:49 <hpc> don't you also need | t -> a?
03:41:15 <hpc> or is this for multiple 'a' instances?
03:42:05 <ocramz`> ah that's also a good point. No, a single type `a` would be involved. So a fundep would help here?
03:42:37 <jle`> wait, are you saying that the same a will always be associated with the same t?
03:43:09 <hpc> if it's 1:1, you can do t -> a, a -> t
03:43:14 <jle`> oh, or that every t will have the same a
03:43:20 <ocramz`> no, I would have a few different t, a single numerical type a
03:43:22 <jle`> well, if it's 1:1, you can drop t as a parameter altogether
03:43:56 <jle`> if you only have a single a ever, then there's really no point in having the 'a' parameter in your typeclass is there?
03:43:57 <hpc> what about newtypes around a?
03:44:07 <hpc> like for Monoid, the numeric types have Sum and Product
03:45:55 <jle`> yeah, or you could even just move your phantom parameter to the newtype wrapper
03:46:27 <jle`> class Solver t where method :: Op' t Foo -> Op' t Foo -> Op' t Foo
03:47:01 <jle`> newtype Op' t a = O (Op a)
03:47:40 <ocramz`> this is a good idea. Have to meditate and try things out. Thanks jle` , hpc
04:02:39 * hackagebot Spintax 0.1.0.1 - Random text generation based on spintax  https://hackage.haskell.org/package/Spintax-0.1.0.1 (MichelBoucey)
04:02:41 * hackagebot envelope 0.2.0.0 - Defines generic 'Envelope' type to wrap reponses from a JSON API.  https://hackage.haskell.org/package/envelope-0.2.0.0 (cdepillabout)
04:02:43 * hackagebot template-haskell-compat-v0208 0.1 - A backwards compatibility layer for Template Haskell newer than 2.8  https://hackage.haskell.org/package/template-haskell-compat-v0208-0.1 (NikitaVolkov)
04:04:03 <gargawel> So, let's say I have a C API that is essentially pure, but some functions take CString's as arguments ; is it relatively safe to use "unsafePerformIO . newCString" to convert Haskell strings to C strings and stay out of the IO monad ?
04:04:50 <gargawel> I would really like to present a pure API ...
04:06:58 <m1dnight_> can you drive a typeclass (e.g., show) for a data type you have no control over?
04:07:15 <m1dnight_> Concretly, I want to specify `deriving (Show)` for the AlexState class.
04:07:29 <liste> m1dnight_: see StandaloneDeriving extension 
04:07:57 <cocreature> gargawel: most likely you want withCString, otherwise you have a memory leak. but using unsafePerformIO when interacting with pure C APIs is fairly safe and quite common
04:08:15 <m1dnight_> Concretly, I want to specify `deriving (Show)` for the AlexState class.
04:08:17 <liste> m1dnight_: https://downloads.haskell.org/~ghc/6.12.1/docs/html/users_guide/deriving.html
04:08:20 <m1dnight_> oops, wrong terminal
04:08:21 <gargawel> cocreature: thanks :-)
04:08:31 <m1dnight_> Thanks liste. Exactly what I was looking for!
04:08:32 <gargawel> I glad to hear that
04:08:42 <gargawel> *I'm
04:09:03 <gargawel> it would be a pity to be forced to live inside IO /just/ because of string conversions :-/
04:09:52 <cocreature> yeah
04:10:36 <cocreature> I would say that C FFI is one of the most sensible use cases for unsafePerformIO
04:10:55 <merijn> To be precise, it's exactly why unsafePerformIO was added to the report
04:11:27 <tdammers> I would even argue that it's the only sane use case for it :x
04:11:35 <gargawel> actually, things are a little more complicated: (almost) all functions take a "context" argument that must be initiated with a specific IO function, and values initiated within different contexts cannot be mixed
04:11:56 <gargawel> but it seems like I have a way to handle this using a phantom type argument and rank-2 types, à-la ST
04:12:28 <lyxia> poor lazy io, everyone hates it
04:13:03 <gargawel> =)
04:13:46 <gargawel> lazy IO is the kind of things you're embarrassed to tell your friends when advocating the use of Haskell
04:15:04 <cocreature> you first tell your friends that lazyness is great because it gives you streaming for free and then you hope that they don’t ask about IO
04:16:02 <tdammers> lazy IO is OK (ish) when its unexpected side effects are actually desirable :x
04:16:10 <tdammers> which is probably never
04:19:51 <Vq> It may be acceptable for implementing cat(1).
04:21:52 <merijn> It's acceptable for shell scripts
04:22:01 <merijn> Not so much for Reliable Code (TM)
04:24:18 <grantwu> I hope cat is very reliable.
04:28:57 <tazjin> I have a sort of philosophical question
04:29:07 <tazjin> Data.List.all defaults to True for empty foldables 
04:29:12 <tazjin> why? 
04:29:49 <grantwu> Because the predicate is vacuously true.
04:30:11 <grantwu> I guess it's also vacuously false...
04:30:13 <cocreature> tazjin: True is the identity for and
04:30:19 <cocreature> just like False is the identity for Or
04:30:58 <tazjin> cocreature: that makes sense actually
04:31:41 <grantwu> yeah, I think cocreature's answer is better.
04:32:22 <merijn> tazjin: Also, generally in math (well, predicate logic) you have "∀a. a ∈ S -> X" is true for any X if S is the empty set
04:34:54 <merijn> Note also that "∀x.P(x)" is supposed to equal "¬∃x.¬P(x)"
04:35:21 <merijn> That is, a predicate P is true "for all x" is the same as "there is no 'x' for which P is not true"
04:35:50 <merijn> The latter formulation is trivially true for empty sets, if there are no x's, there clearly is no 'x' for which P is not true
04:36:10 <tazjin> merijn: hmm, interesting 
04:39:02 <mrkgnao> is Data.Graph suitable for finding paths of a given length between two given nodes?
04:39:23 <mrkgnao> I mean, the graph implementation in there
04:39:33 <mrkgnao> or is it better to roll my onw
04:39:37 <mrkgnao> *own?
04:39:39 <merijn> mrkgnao: Depends on the size of the graphs? :p
04:41:00 <mrkgnao> I guess so 
04:41:25 <gargawel> tazjin: another way to see it is that "all" must be a morphism from (List, ++) to (Bool, and)
04:41:27 <mrkgnao> does it already contain any functions I could use to do that job for me?
04:41:43 <gargawel> all(l1 ++ l2) == all(l1) and all(l2)
04:42:26 <mrkgnao> path looks interesting
04:42:29 <mrkgnao> :hoogle path
04:42:33 <gargawel> as, for any list l, l == l ++ [], you have: all(l) == all(l ++ []) == all(l) and all([])
04:42:43 <mrkgnao> wait, I don't remember how to call lambdabot
04:42:46 <mrkgnao> @lambdabot path
04:42:47 <lambdabot> Unknown command, try @list
04:42:47 <merijn> mrkgnao: How big are yours graphs? (Order of magnitude)
04:43:01 <mrkgnao> not very much
04:43:09 <mrkgnao> say 500 nodes at most
04:43:22 <mrkgnao> but much less than now to start with
04:43:27 <gargawel> (well, that's not really Haskell syntax, but you get the point)
04:43:31 <mrkgnao> I just want to get a proof-of-concept going
04:43:31 <merijn> mrkgnao: tbh, at that size any non-stupid implementation should be fine
04:43:56 <mrkgnao> I'm just lazy and was wondering if I could use the Data.Graph path method
04:44:02 <merijn> If you wanna, say, analyse twitter, probably not :p
04:44:15 <mrkgnao> if it only returned an actual path and not a Bool
04:44:22 <mrkgnao> *digs into source*
04:47:37 <fr33domlover> mrkgnao, for such small graphs any sane impl will work
04:48:01 <fr33domlover> personally I use FGL for most graph things unless there are extra requirement it can't handle well
05:02:41 * hackagebot html-tokenizer 0.4.1 - An "attoparsec"-based HTML tokenizer  https://hackage.haskell.org/package/html-tokenizer-0.4.1 (NikitaVolkov)
05:02:43 * hackagebot list-t-text 0.2.1 - A streaming text codec  https://hackage.haskell.org/package/list-t-text-0.2.1 (NikitaVolkov)
05:02:45 * hackagebot identicon 0.2.0 - Flexible generation of identicons  https://hackage.haskell.org/package/identicon-0.2.0 (mrkkrp)
05:02:47 * hackagebot list-t-libcurl 0.3.1 - A "libcurl"-based streaming HTTP client  https://hackage.haskell.org/package/list-t-libcurl-0.3.1 (NikitaVolkov)
05:02:49 * hackagebot list-t-attoparsec 0.4.1 - An "attoparsec" adapter for "list-t"  https://hackage.haskell.org/package/list-t-attoparsec-0.4.1 (NikitaVolkov)
05:07:51 * hackagebot list-t-html-parser 0.4.2 - Streaming HTML parser  https://hackage.haskell.org/package/list-t-html-parser-0.4.2 (NikitaVolkov)
05:07:53 * hackagebot record 0.3.2 - First class records implemented with quasi-quotation  https://hackage.haskell.org/package/record-0.3.2 (NikitaVolkov)
05:23:06 <Reisen> If I have some data X = X { a :: Concrete, b :: Concrete }, is there a way I can derive tuple instances for it? In the sense that, I would for example like Ord (a, b) to apply to this type without having to write the deriving completely
05:23:33 <Reisen> Can it be done with -XStandaloneDeriving?
05:23:38 <lyxia> deriving Ord?
05:23:51 <lyxia> you don't need an extension here
05:23:53 <Reisen> I tried but it doesn't seem to allow me to automatically derive it
05:24:00 <Reisen> Let me double check the error
05:24:01 <lyxia> you need Concrete to be Ord too
05:24:05 <Reisen> They are
05:24:16 <lyxia> and you need to derive Eq too
05:33:26 <Reisen> lyxia: you're right, thanks, I just messed up the deriving on another type
05:39:40 <kuribas> Can I get the size of a lazy bytestring without reading the whole string in memory?
05:40:05 <merijn> kuribas: No
05:40:49 <kuribas> I could calculate the size from chunks, so they can be garbage collected...
05:41:20 <merijn> kuribas: Actually, the chunks might be able to get gc ed if you don't hold onto the the BS, yes. But I'm not sure
05:43:15 <kuribas> this binary file format puts the lenght first, then the content...
05:44:06 <merijn> kuribas: A very sensible choice, because then you don't have to read the entire thing in ;)
05:44:15 <kuribas> yeah :)
05:44:51 <merijn> Golden rule for fast and efficient parsing/handling. Each field must either be statically known length or have a length prefix
05:46:04 <kuribas> hm, I guess in a C program it would also load the content into an in-memory buffer.
05:47:15 <merijn> kuribas: Are you trying to serialise a lazy bytestring with length prefixed?
05:48:31 <kuribas> merijn: I have a table of offsets for each subtable, then the subtables with length prefixed.
05:48:49 <Twey> Why is Pipe bidirectional?
05:49:00 <Twey> What does a bidirectional Pipe give you that a unidirectional Pipe doesn't?
05:49:11 <merijn> Twey: The ability to give feedback upstream?
05:49:50 <merijn> kuribas: For smalltables I'd just say "screw it" and load it into memory and then write it out
05:50:07 <Twey> merijn: Could you not build that into your composition operator on top of unidirectional Pipes?
05:50:15 <merijn> kuribas: For files you could write your own "write out, then insert length afterwards" approach, but that's painful
05:50:51 <merijn> Twey: How?
05:51:04 <Adeon> does taking WHNF of 'Data.ByteString.Lazy.length bs' mean all contents are evaluated?
05:51:11 <Adeon> I assume yes but I'm not entirely sure
05:51:45 <Twey> merijn: Something like, a bidirectional Pipe a a' b b' r is a unidirectional Pipe that takes Either a a' and gives Either b b', and the tag of the sum decides in which direction the information is propagated
05:52:47 <kuribas> merijn:  It's the encodings for truetype.  A full truetype file is a few Mb at most.
05:53:05 <merijn> kuribas: Yeah, I remembered, hence the "just load it in memory" solution :)
05:53:28 <kuribas> yeah, I guess a few Mb isn't much these days :)
05:54:00 <merijn> Twey: That description fundamentally doesn't make sense with the current design of pipes, I think
05:54:57 <gargawel> Adeon: Given how ByteString is implemented, I'd say yes :)
05:55:21 <kuribas> I remember upgrading from 8Mb to 16mb to run windows more smoothly, finding it a lot of RAM.
05:57:01 <kuribas> bytestring is defined as: data ByteString = Empty | Chunk {-# UNPACK #-} !S.ByteString ByteString
05:57:34 <kuribas> So whnf would only evaluate the first chunk?
05:57:35 <gargawel> so basically, a lazy bytestring is either empty, or a strict bytestring followed by a lazy one
05:57:44 <kuribas> yeah
05:57:45 <gargawel> kuribas: he's running length on it
05:57:57 <kuribas> ah right :)
05:58:02 <gargawel> and length goes through all chunks, calling S.length on each one
05:58:13 <gargawel> so yeah, that would do it
05:58:15 <tsahyt> I've got a C library that is GPL3 licensed that I want to write Haskell bindings for. Do my bindings have to be GPL3 licensed too? Technically it links to the C library and I think GPL is contagious that way
05:58:34 <joe9> What is the recommended alternative for FilePath?
05:58:34 <kuribas> tsahyt: yes, it has to be GPL3
05:58:48 <tsahyt> ok thanks
05:58:52 <merijn> tsahyt: No, it just has to be licensed in such a way that the binary package as whole can be redistributed under the GPL3
05:58:59 <merijn> kuribas: That's wrong
05:59:09 <tsahyt> merijn: can or has to?
05:59:33 <tsahyt> because if it has to be GPL3 licensed anyhow eventually, I don't think there's any advantage in making the bindings say BSD licensed
05:59:47 <merijn> tsahyt: Correct
06:00:06 <tsahyt> so I'll accept my fate (or rather that of my users) and use GPL3 then
06:00:41 <merijn> tsahyt: Well, the difference is when, say, your haskell code introduces some generic functionality others might want to duplicate
06:00:58 <joe9> anyone knows a FilePath package that uses ByteString or Text?
06:01:06 <kuribas> merijn: I doubt you can make bindings to GPL3 under another licence...
06:01:09 <merijn> tsahyt: If your haskell code is BSD licensend (for example), I can reuse that part of the code in my BSD project (which doesn't link with said GPL3 library)
06:01:19 <gargawel> joe9: I am not sure there is an agreed upon alternative, but I'd recommend path or pathtype for type safety
06:01:23 <merijn> kuribas: You can, as long as the total package is distributed under GPL
06:01:39 <merijn> kuribas: That means your code has to be a license which can be relicensed under GPL3
06:01:55 <tsahyt> merijn: Good point, but I can't see anything of the sort happening at the moment. I want to provide an idiomatic specific interface to this library. I might end up implementing a more general eDSL with changable backends eventually but that'd be a separate package.
06:01:56 <gargawel> I think they both use String, though
06:02:04 <kuribas> merijn: yeah, that's the same thing basically.
06:02:10 <merijn> kuribas: MIT and BSD licensed code can easily be relicensed under GPL3, so you can make youre code BSD and distribute the total package as GPL
06:02:24 <merijn> kuribas: No it's not, see my example of lifting parts of the haskell code out into another BSD project
06:02:42 * hackagebot rebase 1.0.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.0.1 (NikitaVolkov)
06:02:44 * hackagebot hasql-postgres-options 0.1.6 - An "optparse-applicative" parser for "hasql-postgres"  https://hackage.haskell.org/package/hasql-postgres-options-0.1.6 (NikitaVolkov)
06:02:46 * hackagebot hasql-backend 0.4.3 - API for backends of "hasql"  https://hackage.haskell.org/package/hasql-backend-0.4.3 (NikitaVolkov)
06:02:48 * hackagebot http-api-data 0.3.2 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.3.2 (NickolayKudasov)
06:02:50 * hackagebot template-haskell-compat-v0208 0.1.1 - A backwards compatibility layer for Template Haskell newer than 2.8  https://hackage.haskell.org/package/template-haskell-compat-v0208-0.1.1 (NikitaVolkov)
06:03:07 <tsahyt> another question before I embark on this. c2hs or hsc2hs? When would I want to use which? and what provides me with the easiest way to avoid writing (too much) boilerplate?
06:03:47 <merijn> tsahyt: hsc2hs is a tool that ships with GHC, c2hs I forgot about
06:03:52 <merijn> tsahyt: There's also c2hsc
06:03:57 <joe9> gargawel: That sucks.
06:03:58 <cocreature> personally I find c2hs to be more convenient
06:04:05 <tsahyt> https://potassco.org/clingo/c-api/current/ <-- in case anyone wants to see the scope of what I'm doing. it's not massive but not trivial either
06:04:29 <merijn> tsahyt: Also, you only need those tools incase you plan to mutate C structs from Haskell directly (not sure what you're doing?)
06:04:42 <kuribas> merijn: it should be clear for the user that it is actually GPL, not MIT.  
06:04:57 <merijn> kuribas: That's irrelevant for the user
06:05:02 <cocreature> that’s not quite true for c2hs. I mean “need” is true but c2hs does help with a lot more stuff than just structs
06:05:06 <merijn> kuribas: GPL does not restrict users, only distributors
06:05:11 <cocreature> it makes it really easy to marshall things
06:05:16 <tsahyt> merijn: I think I'll have to do that here or there on the lowest level but I want to provide a more idiomatic interface too
06:05:46 <kuribas> merijn: it's relevant if you want to distribute your program, which is almost always...
06:06:14 <merijn> kuribas: Then you have to inspect your recursive dependencies anyway
06:06:24 <merijn> kuribas: You can't rely on the license of direct dependencies for that
06:07:20 <kuribas> I still think putting BSD/MIT on a library which requires GPL code is misdirecting the user.
06:07:41 <kuribas> But I get the idea of having different licences for parts of your code...
06:07:53 * hackagebot rebase 1.0.2 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.0.2 (NikitaVolkov)
06:08:35 <joe9> gargawel: Thanks, good recommendation
06:08:47 <tsahyt> merijn: on the licensing thing. I'd argue that the general functionality that might benefit from a more permissive license should really be part of a separate library
06:08:51 <gargawel> joe9: there may be valid reasons regarding text encoding
06:08:58 <gargawel> I am not too sure
06:12:44 <tsahyt> About namespaces, should I put my modules into Clingo.*, or Data.Clingo.*, etc? What is the preferred way to do this? Data strikes me as weird but that's how sbv does it. glpk-hs uses a similar naming
06:13:25 <tsahyt> For some reason I'm wary of introducing new "top level" module names
06:13:44 <kuribas> tsahyt: you can give parts of your program a more permissive GPL compatible licence, but the whole can only be distributed under GPL3.
06:14:35 <phadej> tsahyt: don't be, especially if it's a proper noun
06:14:43 <phadej> and/or the same as the package name
06:14:50 <tsahyt> phadej: well it's the name of the library I'm providing bindings for
06:20:30 <dariush_> hi
06:21:44 <tabaqui> is there some decart's tree library?
06:22:06 <tabaqui> i mean heap and search tree for pairs
06:24:59 <kuribas> tabaqui: for which operations?
06:25:51 <tabaqui> kuribas: logarithmic search by first elements and O(1) search for the smallest value by second elements
06:26:32 <tabaqui> kuribas: well, in russian it's called like deramid
06:27:16 <tabaqui> or Decart's tree
06:27:51 <kuribas> this? https://en.wikipedia.org/wiki/Cartesian_tree
06:29:57 <kuribas> :t Data.Map.fromList
06:29:59 <lambdabot> Ord k => [(k, a)] -> M.Map k a
06:30:11 <tabaqui> yeah, it is
06:31:06 <tabaqui> Data.Map is just a binary search tree
06:31:18 <tabaqui> ti doesn't provide heap operations
06:31:39 <kuribas> > Data.Map.lookupGE (4, 0) $ Data.Map.fromList [(1, 0), (4, 3), (4, 6), (6, 5)]
06:31:41 <lambdabot>  error:
06:31:41 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M523396303230...
06:31:41 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
06:32:18 <kuribas> > Data.Map.lookupGE (4, 0) $ Data.Map.fromList [(1::Int, 0::Int), (4, 3), (4, 6), (6, 5)]
06:32:20 <lambdabot>  error:
06:32:20 <lambdabot>      • Couldn't match type ‘Int’ with ‘(t, t1)’
06:32:20 <lambdabot>        Expected type: M.Map (t, t1) Int
06:32:44 <tabaqui> nope, it looks for the smalles key, not for the smallest value
06:33:30 <kuribas> ah...
06:45:45 <kuribas> tabaqui: it seems not, but perhaps there is another structure for your application...
06:46:10 <kuribas> perhaps kd-tree
06:48:29 <tabaqui> kuribas: i've read once about 'em, i have not such complicated problem actually )
06:50:52 <kuribas> defining a cartesian tree would be so hard...
06:50:53 <Gurkenglas__> can ghc do deterministic builds?
06:51:32 <lyxia> not yet
06:52:32 <tabaqui> i mean, that treap is pretty simple structure unlike kd-tree, i don't want to use it for simple load balancer
06:53:42 <kuribas> tabaqui: or maybe a priority queue?
06:55:06 <jophish> Gurkenglas__: trac ticket 4012
06:55:15 <jophish> https://ghc.haskell.org/trac/ghc/ticket/4012
07:02:44 * hackagebot rebase 1.0.2.1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1.0.2.1 (NikitaVolkov)
07:02:46 * hackagebot x86-64bit 0.4.2 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.4.2 (PeterDivianszky)
07:33:32 <tabaqui> kuribas: nope, priority queue doesn't provide search operation
07:33:40 <codedmart> If I have something like `Just (ProductAddress Nothing Nothing Nothing Nothing Nothing Nothing Nothing Nothing)`. Can I alias that so I don't have to type it out more then once? `type` seems to only apply to `Maybe`.
07:34:12 <tsahyt> that's just a value, you can bind it to something
07:34:31 <codedmart> tsahyt: Duh sorry for the dumbness :)
07:34:41 <tsahyt> if you want to pattern match on something that has this shape, pattern synonyms are what you're looking for
07:35:29 <sshine> 'wat :: TheTypeForWhichProductAddressIsAConstructor'  and  wat = ProductAddress Nothing Nothing Nothing Nothing Nothing Nothing Nothing Nothing'
07:35:41 <sshine> a good name might be 'emptyProductAddress'.
07:36:31 <kadoban> tabaqui: It could. A heap + a balanced BST, side by side, would be O(lg n) search, insert, delete and O(1) find-min (note: I wasn't here for the context of the conversation)
07:37:31 <codedmart> Yeah sorry I had a brain fart.
07:37:33 <sshine> although all those Nothings suggest that your type is more nullable than it should be...
07:37:36 <tsahyt> what would be the idiomatic haskell equivalent to a bitset? 
07:37:54 <tsahyt> I suppose a record of bools or something like that?
07:38:00 <sshine> tsahyt, Bools?
07:39:09 <codedmart> sshine: What do you mean more nullable then it should be? I am working with data in a database that is already filled in. But all the values could be null.
07:40:26 <sshine> codedmart, I'm not sure I understand the purpose of allowing an "empty" address enter the database. usually when there's an irregular pattern of NULLs in a database table, it suggests that the table isn't properly normalized.
07:40:45 <sshine> codedmart, but this isn't a Haskell problem then, anyways. :)
07:41:31 <codedmart> sshine: I agree with you, but they are already in there. I guess I could remove them, but there is another app that is nodejs that uses this same db and obviously doesn't account for that.
07:42:10 <codedmart> Thanks!
07:43:44 <sshine> tsahyt, you can pack bit flags into more primitive types: https://hackage.haskell.org/package/data-flags-0.0.3.2/docs/Data-Flags.html
07:44:23 <sshine> tsahyt, or better yet: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Bits.html
07:44:40 <tsahyt> sshine: the package above looks nice
07:44:52 <tsahyt> a Bits instance is too general, it might allow setting illegal flags
07:45:28 <tsahyt> I'm writing bindings to a C library that uses quite bitflags in quite a few places. data-flags might come in useful
07:45:28 <sshine> tsahyt, I suppose that can easily be solved by encapsulation and tests?
07:45:36 <sshine> tsahyt, nice.
07:46:44 <tsahyt> sshine: I don't think tests can help here. say I have a newtype MyFlags with a Bits instance but only the 3 least significant bits have meaning, nothing's stopping a user from setting say the 5th bit. I don't want to dig into the C library to guarantee that this doesn't damage anything.
07:47:20 <tsahyt> having some function [MyFlags] -> MyFlags to combine them is a lot safer as I can just hide the constructor and export only what's legal
07:47:52 <tabaqui> kadoban: that's called carthesian tree, and i've discussed it earlier
07:48:26 <tabaqui> kadoban: there is no library in hackage, so i have to write it self
07:51:31 <kadoban> Never heard it named
08:02:45 * hackagebot jni 0.1 - Complete JNI raw bindings.  https://hackage.haskell.org/package/jni-0.1 (MathieuBoespflug)
08:02:47 * hackagebot jvm 0.1 - Call JVM methods from Haskell.  https://hackage.haskell.org/package/jvm-0.1 (MathieuBoespflug)
08:02:49 * hackagebot inline-java 0.5 - Java interop via inline Java code in Haskell modules.  https://hackage.haskell.org/package/inline-java-0.5 (MathieuBoespflug)
08:02:51 * hackagebot x86-64bit 0.4.3 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.4.3 (PeterDivianszky)
08:14:03 <DELB_> I'm trying to check if a list is equal at a certain index
08:14:03 <DELB_> sameListIndex :: [Int] -> [Int] -> Integer -> Bool  sameListIndex (x:xs) (y:ys) n = sameListIndex xs ys (n - 1)
08:14:11 <DELB_> but I keep getting a Non-exhaustive pattern error, why?
08:14:43 <ertes> DELB_: you have defined the function for non-empty lists
08:15:01 <DELB_> which is what I want ;o
08:15:02 <ertes> what should it evaluate to, if one of the lists is empty?
08:15:09 <sshine> DELB_, sameListIndex [1,2,3] [] 3 is...?
08:15:09 <DELB_> False I guess
08:15:17 <DELB_> I'm new to this
08:15:21 <ertes> DELB_: *you* might guess, but GHC doesn't =)
08:15:23 <sshine> DELB_, welcome then :)
08:15:25 <ertes> hence the warning =)
08:15:35 <DELB_> ahh
08:15:52 <DELB_> so what should I do to cover non empty lists
08:15:55 <DELB_> I mean empty
08:15:55 <mizu_no_oto_work> "sameListIndex (x:xs) (y:ys) n" pattern matches on both lists having at least one element
08:15:56 <DELB_> lol
08:16:12 <ertes> DELB_: well, that's up to you really…  depends on the function you're trying to write
08:16:41 <ertes> i'm not really sure what "sameListIndex" means, and from the clause that you have currently written it's just 'drop' on both lists so far
08:17:06 <mnoonan> DELB_: the easiest thing would be to also write definitions "sameListIndex [] _ _ = whatever" and "sameListIndex _ [] _ = whateverElse"
08:17:14 <ertes> > drop 3 [5,4,7,1,8,11]
08:17:14 <mizu_no_oto_work> DELB: typically, you'd define multiple definitions that pattern match on different things
08:17:16 <lambdabot>  [1,8,11]
08:17:17 <mnoonan> the underscores mean "I don't care about this parameter"
08:19:07 <ertes> DELB_: just to be safe: you can (and often do) write multiple clauses for a single function:  not True = False; not False = True
08:19:27 <DELB_> I'm getting a bit confused
08:19:29 <pikajude> GHC will tell you if you've missed anything
08:19:37 <mizu_no_oto_work> See e.g. https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.List.html#head
08:19:42 <ertes> DELB_: imagine that you define the following function:
08:19:48 <ertes> myNot :: Bool -> Bool
08:19:53 <ertes> myNot True = False
08:20:02 <ertes> that's the full definition
08:20:13 <ertes> it's just the "not" function for booleans
08:20:36 <ertes> if you type it like that and try to compile/load it, GHC will give you the same warning
08:20:42 <ertes> do you see why?
08:21:14 <DELB_> nope :/
08:21:20 <ertes> let's try it out then
08:21:23 <ertes> @let myNot True = False
08:21:26 <lambdabot>  Defined.
08:21:30 <ertes> > myNot True
08:21:32 <lambdabot>  False
08:21:36 <ertes> good so far
08:21:39 <ertes> but…
08:21:42 <ertes> > myNot False
08:21:45 <lambdabot>  *Exception: /tmp/mueval6281750111656478042.hs:170:1-18: Non-exhaustive patte...
08:22:06 <DELB_> you don't have something that covers when False is entered
08:22:11 <ertes> exactly
08:22:42 <ertes> @let properNot True = False; properNot False = True  -- you would put these on separate lines
08:22:42 <DELB_> so I'm missing something in my function definition that doesn't cover if an empty list is entered?
08:22:44 <lambdabot>  Defined.
08:22:53 <ertes> > properNot False  -- this time both cases are covered
08:22:56 <lambdabot>  True
08:23:08 <Cale> DELB_: correct
08:23:34 <mizu_no_oto_work> DELB: usually, you define a function on multiple lines, pattern matching on different things
08:23:45 <DELB_> sameListindex (x:xs) (y:ys) 0 = x == y
08:23:46 <DELB_> ?
08:24:05 <c_wraith> The line only handles when both lists are non-empty
08:24:06 <ertes> DELB_: what should the function evaluate to?
08:24:19 <ertes> first explain that, then we'll figure out how to write it properly
08:24:39 <DELB_> it just checks to see if both lists are non empty
08:24:50 <ertes> then what's the integer argument for?
08:25:10 <DELB_> to check the list at a certain index
08:25:32 <ertes> so you want to check whether the lists are of a certain minimum length?
08:25:38 <tsahyt> are there any guarantees made that CInt is a 32 bit int? The C library I'm wrapping has things defined as int32_t or uint32_t etc, and I'm unsure which type to use on the haskell side?
08:25:55 <c_wraith> I think the idea is to check if the lists have the same element at a particular index
08:26:02 <ertes> tsahyt: Int32 would be an option
08:26:02 <DELB_> yeah that's it
08:26:12 <c_wraith> tsahyt: it's whatever type the C compiler uses for Int
08:26:23 <c_wraith> tsahyt: So it depends on your C compiler and environment.
08:26:42 <ertes> tsahyt: alternatively Word32 (from Data.Int or Data.Word resp.)
08:26:56 <tsahyt> c_wraith: but int32_t is always a 32 bit int afaik. does Int32 always correspond to that?
08:27:08 <tsahyt> also what's the difference between Int and CInt then
08:27:16 <c_wraith> Int is the Haskell type.  CInt is the C type
08:27:32 <DELB_> ertes: still stuck D:
08:27:35 <c_wraith> tsahyt: on 64-bit linux, compiling with gcc, Int is usually 64 bits, CInt is usually 32.
08:27:52 <c_wraith> tsahyt: But those are both "usually".  They're both allowed to vary.
08:28:07 <ertes> DELB_: ok, let's handle the case where both lists are non-empty and the integer is zero:  sameAt (x:xs) (y:ys) 0 = ?
08:28:34 <pavonia> ertes: Can Int32 even be used as a foreign type?
08:28:40 <DELB_> well you aren't checking any element in particular because there are no lists 
08:28:44 <ertes> DELB_: (i took the liberty to rename the function to sameAt)
08:28:59 <ertes> DELB_: not sure what you mean
08:29:08 <ertes> pavonia: i don't see why not
08:29:09 <DELB_> what's the "?" for?
08:29:18 <ertes> DELB_: that's the part you fill in =)
08:29:21 <DELB_> oh
08:29:34 <tsahyt> so if I have a typedef int32_t foo_t in C, how would I represent the same in Haskell? The typedef carries some semantics so I'd like to do a newtype wrapper, would that be newtype Foo = MkF Int32? what would the marshalling look like when calling a function that expects a foo_t
08:29:55 <DELB_> x == y
08:29:56 <DELB_> ?
08:30:13 <ertes> DELB_: yeah
08:30:42 <c_wraith> tsahyt: I don't trust myself to ever get that stuff right by hand, so I use libraries like bindings-dsl to create correct Haskell type aliases for whatever types are used in a C library
08:30:51 <ertes> DELB_: that's your first clause…  for the remaining clauses you can assume that the integer is non-zero (because the zero case is already handled)
08:30:58 <tsahyt> or to phrase this differently, do FFI C calls depend only on runtime representation? that should be the same between int32_t and Int32 after all
08:31:11 <DELB_> so I have to fill out all of the possibilities?
08:31:12 <ertes> DELB_: sameAt (x:xs) (y:ys) n = ?  -- remember that n is non-zero
08:31:33 <c_wraith> tsahyt: those don't have close to the same runtime representation.
08:31:45 <tsahyt> c_wraith: what, but they're both just 32 bit integers
08:31:53 <c_wraith> tsahyt: Int32 is lifted
08:32:01 <DELB_> I'm not sure about that one ertes
08:32:34 <mizu_no_oto_work> DELB_: you already wrote it above
08:32:38 <ertes> DELB_: firstly: are x and y relevant?
08:32:43 <DELB_> yeah
08:32:48 <ertes> really?
08:32:48 <DELB_> but what's the n?
08:32:54 <tsahyt> c_wraith: huh but CInt is just newtype for Int32 according to the docs
08:33:06 <ertes> DELB_: you don't know n…  all you know is that it's non-zero
08:33:12 <ertes> that makes x and y irrelevant
08:33:16 <tsahyt> data {-# CTYPE "HsInt32" #-} Int32 = I32# Int# deriving (Eq, Ord, Typeable)
08:33:27 <tsahyt> the annotation might have something to do with it
08:33:31 <DELB_> oh ok
08:34:04 <DELB_> so what are you asking me again?
08:34:14 <ertes> DELB_: sameAt (x:xs) (y:ys) n = ?
08:34:23 <DELB_> x == y?
08:34:31 <tsahyt> technically CInt is defined using a macro, but after expansion it should be a newtype for Int32 on x86_64
08:34:40 <tsahyt> or whatever hackage uses to build the docs
08:34:48 <DELB_> or x != y?
08:34:52 <ertes> DELB_: if n were 0, then you would be interested in whether x and y are equal
08:35:26 <ertes> DELB_: but n is specifically *not* 0…  so you're interested in some pair of elements further down the lists
08:35:50 <tsahyt> the FFI wiki page also names Int32 as the haskell counterpart to int32_t
08:35:51 <ertes> does that make sense?
08:36:16 <mizu_no_oto_work> DELB_: you had written " sameListIndex (x:xs) (y:ys) n = sameListIndex xs ys (n - 1)" above, right?  What was your thought pattern, there?
08:37:36 <DELB_> ertes right ok, kind of
08:38:13 <DELB_> mizu_no_oto_work n - 1 because list starts at 0 and then you compare the two lists together and n being a certain index
08:39:33 <ertes> DELB_: when writing a recursive definition you assume that the function already does what it's supposed to do, so you can simply reuse it, and that's what you did in your recursive clause from earlier
08:39:52 <ertes> so yeah, (sameListIndex xs ys (n - 1)) is exactly the answer you're looking for, isn't it?
08:40:14 <mizu_no_oto_work> DELB_: So you're walking down the list, decrementing the index and throwing away the current element?
08:40:20 <ertes> sameListIndex "hello" "world" 3 = sameListIndex "ello" "orld" 2
08:40:40 <ertes> and at some point you hit:  sameListIndex "lo" "ld" 0 = 'l' == 'l'
08:41:14 <DELB_> tbh, I might see my lecturer about this because I'm not 100% sure what she's asking
08:41:19 <DELB_> I am pretty sure it's like this
08:41:19 <glguy> tsahyt: You can use hsc2hs's (#type foo_t) to map foo_t to the correct Haskell type
08:41:27 <DELB_> [1, 2, 3] [1, 2, 3] then you input an Integer
08:41:30 <DELB_> like 1
08:41:51 <DELB_> and it compares the second element of the first list and the second element of the second list to see if they are equal
08:42:07 <DELB_> and yeah it is ertes
08:42:19 <ertes> DELB_: that's really all there is to it
08:42:43 <ertes> you reuse the functionality you are currently defining on smaller arguments, until you hit a base case (n = 0)
08:42:52 <DELB_> n is the Integer that is being inputted yes
08:42:52 <DELB_> ?
08:43:51 <glguy> tsahyt: You can also wrap that in a newtype and use it in FFI declarations: newtype Foo = Foo (#type foo_t)
08:44:04 <ertes> DELB_: would you be open to doing a simpler exercise first?
08:44:11 <ertes> or not simpler, just smaller
08:44:13 <DELB_> yeah
08:44:22 <DELB_> tbh I'm doing this for University, but I've fallen behind
08:44:23 <glguy> tsahyt: It's not relevant that Int32 is lifted, the FFI knows how to deal with it
08:44:30 <DELB_> I'm trying to catch up but everyone is going at a speed I can't go at
08:44:54 <DELB_> they only give us 2 hours to do this exercise and if you're one of the slower students it's hard to catch up :S
08:44:57 <glguy> tsahyt: and also the CTYPE pragma has to do with the CApiFFI extension, not the normal FFI
08:45:23 <ertes> DELB_: define the factorial function, let's call it fact…  its behaviour on the argument 5 should be: fact 5 = 5 * 4 * 3 * 2 * 1
08:46:10 <ertes> DELB_: you're not allowed to use lists…  define it recursively
08:47:24 <DELB_> ok, I will be 5 mins and I'll be back
08:50:04 <tsahyt> glguy: Thanks for the help, I'll use hsc2hs, as I'm in a hsc file already anyhow
08:53:23 <DELB_> might be longer than 5 mins, when I'm back I'll send you a message
08:55:14 <ertes> DELB_: there are plenty of good teachers around, so just write here =)
08:57:42 <DELB_> can we come back to that?
08:58:03 <DELB_> I'd like to do something that seems a bit easier
08:59:17 <DELB_> ertes: For the next ones you also need to check which of the constraints: Num a, Ord a, Eq a you need to add. add x y z = x + y + z ordered (x,y,z) = x<=y && y<=z iszero n = (n == 0)
08:59:28 <DELB_> how do I know what constraints to use?
08:59:59 <ski> check which are required by the operations you use in the definition
09:00:11 <c_wraith> let the compiler tell you. 
09:00:29 <DELB_> how?
09:00:40 <osa1> how do I see which version of a package a stack project is using?
09:00:52 <osa1> bounds are not specified in .cabal
09:01:07 <DELB_> ski do I just use :t and the name of the function?
09:01:25 <glguy> osa1: There's a command "stack list-dependencies" that might help
09:01:52 <osa1> glguy: thanks, that worked
09:02:48 * hackagebot pareto 0.2.0.0 - A library for cause-effect relationships.  https://hackage.haskell.org/package/pareto-0.2.0.0 (bwe)
09:02:50 * hackagebot sparkle 0.3 - Distributed Apache Spark applications in Haskell  https://hackage.haskell.org/package/sparkle-0.3 (MathieuBoespflug)
09:02:52 * hackagebot singleton-bool 0.1.2.0 - Type level booleans  https://hackage.haskell.org/package/singleton-bool-0.1.2.0 (phadej)
09:03:08 <ski> DELB_ : try it ?
09:04:08 <DELB_> yeah that seemed to work, thanks
09:05:26 <ski> DELB_ : `(+)' requires `Num', `(<=)' requires `Ord', `(==)' requires `Eq'
09:05:43 <ski> (knowing those by heart might be handy)
09:05:50 <DELB_> thanks
09:14:15 <drninjabatman> hello
09:15:03 <drninjabatman> IIRC there is a package that makes tuple an instance of Arrow. Does anyone remember which one?\
09:15:40 <drninjabatman> (actually I think it was a module..)
09:15:45 <drninjabatman> in base
09:15:59 <glguy> drninjabatman: No, a tuple can't be an instance of Arrow
09:16:07 <drninjabatman> ah
09:16:22 <drninjabatman> how so? glguy
09:16:41 <glguy> Because you won't be able to implement the Arrow methods
09:17:24 <ertes> drninjabatman: arr :: (a -> b) -> (a, b)  -- try to write this function
09:17:41 <tdammers> arrows are closely linked to pairs though, through the signatures of the Arrow methods
09:17:44 <DELB_> http://pastebin.com/DcZrgPd3
09:17:47 <DELB_> am I anywhere close?
09:18:01 <DELB_> what I want to happen is for me to input a word, check to see if it is a palindrome, if it is then leave it as it is
09:18:16 <DELB_> if it isn't, turn the word that isn't into a palindrome into a palindrome by reversing it and adding to what was inputted
09:18:31 <drninjabatman> ertes: right, thnx!
09:18:47 <tdammers> DELB_: close, but not quite
09:18:53 <DELB_> what's missing?
09:19:01 <ertes> DELB_: for one thing that code is a type error
09:19:05 <tdammers> more like, what do you need to remove
09:19:17 <tdammers> why don't you feed it to a compiler and see what it has to say
09:20:19 <DELB_> the first two lines are okay yeah?
09:21:04 <ertes> DELB_: you can comment out mkpal and then load the file into GHCi…  then you can play around with 'pal'
09:21:16 <DELB_> pal works
09:21:23 <DELB_> it just checks to see if something is a palindrome
09:21:31 <DELB_> but my task is to get mkpal and pal working together
09:21:45 <ertes> ok, now that you verified that, look at line 3
09:21:56 <ertes> specifically this part:  pal (reverse xs == xs)
09:22:00 <ertes> pal takes a list, right?
09:22:12 <DELB_> String
09:22:20 <DELB_> but sure
09:22:21 <DELB_> it's a list
09:22:26 <ertes> then why are you giving it a boolean? ;)
09:23:05 <DELB_> uuh
09:23:14 <tdammers> ^ which is pretty much exactly what the compiler will tell you, only it'll speak compilerese
09:23:42 <DELB_> but the pal function is supposed to check whether the list of Chars entered is a palindrome
09:23:45 <DELB_> so I need a bool for that?
09:24:03 <tdammers> no
09:24:09 <tdammers> pal takes a String and returns a Bool
09:24:18 <ertes> DELB_: if you apply your definition, then:  pal (reverse xs == xs) = reverse (reverse xs == xs) == (reverse xs == xs)
09:24:19 <DELB_> pal :: [Char] -> Bool
09:24:53 <tdammers> inside mkpal, xs is a String, and the `if` construct wants a Bool for its condition
09:24:56 <ertes> DELB_: but think about it as a software engineer:  you wrote 'pal' specifically in order *not* to have to spell out "reverse xs == xs", right?
09:25:17 <DELB_> yeah
09:26:13 <ertes> think about it a little…  consider what your 'if' is supposed to check
09:26:46 <DELB_> honestly the way I'm reading it is okay
09:26:50 <DELB_> I know it is wrong but it's okay
09:27:06 <DELB_> all my if statement wants to do is check to see if the word entered is a palindrome
09:27:14 <DELB_> if it is don't do anything, just output xs
09:27:20 <tdammers> DELB_: yes, and you have written a function to do exactly that
09:27:21 <DELB_> if it isn't output xs but with the reverse of it too
09:27:40 <DELB_> mkpal :: String -> String mkpal xs = if pal 			   then xs 			   else xs++reverse xs
09:27:40 <DELB_> ?
09:27:49 <tdammers> your pal function is supposed to take the string to check, but you're giving it the result of the check itself, spelled out
09:28:04 <DELB_> pal :: [Char] -> Bool pal xs = (reverse xs == xs) mkpal :: String -> String mkpal xs = if pal(xs) 			   then xs 			   else xs++reverse xs
09:28:05 <DELB_> ?
09:28:18 <tdammers> why don't you try it?
09:28:34 <DELB_> works
09:28:36 <DELB_> thanks!
09:29:05 <tdammers> I recommend going back to the compiler errors you get with the previous version, and try to make sense of them
09:29:24 <tdammers> they tell you exactly what we've been explaining
09:29:41 <DELB_> ok, thanks
09:30:14 <drninjabatman> Turns out what I needed was lenses... I keep confusing lenses for arrows
09:30:33 <ertes> how do you confuse those? =)
09:30:38 <glguy> Might be time for a nap
09:31:36 <drninjabatman> I think I can do something with arrows and it turns out what I need is lenses.. Pobably because I haven't fully grasped any of the two
09:31:39 <DELB_> I'm still a bit unsure what this means
09:31:40 <DELB_> sameList xs ys = xs == ys
09:31:52 <DELB_> sameList :: [Int] -> [Int] -> Bool 
09:31:52 <DELB_> sameList xs ys = xs == ys
09:31:59 <DELB_> xs and ys are the two Int list inputs
09:32:23 <DELB_> so the stuff after the "=" is what is being evaluated on those two inputs?
09:32:29 <lyxia> it's a function named sameList, it takes two lists as arguments, and returns (xs == ys)
09:32:32 <RouxTheDay> DELB_: yes
09:33:51 <DELB_> I think I'll ask ertes to come back for this one, it's regarding that list thing
09:33:56 <DELB_> also thanks
09:34:00 <DELB_> ertes you there?
09:34:34 <ertes> DELB_: you really don't need to ask me specifically…  if you just ask the question you have, many people can help you
09:34:53 <ertes> i'm happy to help of course, if i can
09:34:59 <DELB_> ok I just didn't want to explain what it's about again
09:35:02 <joe9> is there any other package built on top of System-Posix-ByteString-FilePath that does takeDirectory or takeFileName functions?
09:35:11 <DELB_> try to explain this line by line to me
09:35:32 <DELB_> well, I'll have a go at saying what I think it is and then you tell me if I'm right or wrong
09:35:36 <DELB_> sameListIndex :: [Int] -> [Int] -> Integer -> Bool
09:35:39 <DELB_> sameListIndex (x:xs) (y:ys) 0 = x == y
09:35:53 <DELB_> okay so what does the colon do in (x:xs)?
09:36:36 <ertes> DELB_: a list can be of two forms…  either it's the empty list written as [], or it's a head element together with a tail list written as (x : xs), where x is the head and xs is the tail
09:37:14 <ertes> 1 : (2 : (3 : []))  -- this is a list with the head element 1 and the tail list 2 : (3 : [])
09:37:29 <ertes> every list in haskell is of one of those two forms
09:37:31 <DELB_> ok that makes sense
09:37:57 <DELB_> and the whole line is saying what exactly?
09:38:13 <ertes> sameListIndex (x:xs) (y:ys) 0 = x == y  -- if the integer argument is 0, then the result is whether the two head elements are equal
09:38:59 <DELB_> is it checking if the 0th element of the list is equal to the head of the first list and the head of the second list?
09:39:22 <RouxTheDay> DELB_: was there a line below `sameListIndex (x:xs) (y:ys) 0 = x == y`, if not it's a partial function
09:39:24 <ertes> there are only two lists involved:  (x:xs) and (y:ys)
09:39:36 <ertes> RouxTheDay: it's not written yet
09:39:47 <RouxTheDay> Ah okay, nvm
09:40:38 <DELB_> am I right ertes?
09:41:11 <ertes> DELB_: it doesn't *sound* right, but i can't say for sure
09:42:43 <ph88^> how can i write Uniplate.Direct instances for records? https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Direct.html  isn't a record the same as tuple in basis ?
09:43:40 <DELB_> okay so what does the "0" do?
09:44:22 <DELB_> I had a friend who did this help me on it 
09:44:24 <RouxTheDay> > let sameListIndex (x:xs) (y:ys) 0 = x == y
09:44:27 <lambdabot>  <no location info>: error:
09:44:27 <lambdabot>      not an expression: ‘let sameListIndex (x:xs) (y:ys) 0 = x == y’
09:44:48 <RouxTheDay> How do I define a function for lambdabot?
09:44:53 <RouxTheDay> > sameListIndex (x:xs) (y:ys) 0 = x == y
09:44:55 <lambdabot>  <hint>:1:31: error:
09:44:56 <lambdabot>      parse error on input ‘=’
09:44:56 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
09:45:26 <lyxia> ph88^: what is your record
09:45:33 <ertes> RouxTheDay: you could use @let, but you can't add clauses later
09:45:55 <mizu_no_oto_work> > case 1 - 1 of { 0 -> "Zero" ; n -> "nonzero" }
09:45:58 <lambdabot>  "Zero"
09:46:07 <mizu_no_oto_work> > case 1 + 1 of { 0 -> "Zero" ; n -> "nonzero" }
09:46:10 <lambdabot>  "nonzero"
09:46:31 <ertes> DELB_: at this point i think you should learn the basics of haskell
09:46:45 <ertes> DELB_: read at least the "haskell basics" track here:  https://en.wikibooks.org/wiki/Haskell
09:48:13 <mizu_no_oto_work> DELB_: https://www.schoolofhaskell.com/school/starting-with-haskell/introduction-to-haskell/1-haskell-basics is also a good intro
09:49:00 <mizu_no_oto_work> DELB_: but to answer your question, 0 is pattern matching on that particular argument equalling zero
09:50:04 <DELB_> there is some recursion going on here to right?
09:51:03 <DELB_> I think the recursion is indicated by the (x:xs) bits
09:51:34 <RouxTheDay> DELB_: there is no recursion
09:51:56 <Rotaerk> hmm they should turn School of Haskell into a movie
09:51:58 <Rotaerk> starring Jack Black
09:52:06 <DELB_> lol
09:52:16 <sm> +1
09:53:27 <mizu_no_oto_work> DELB_: No, sameListIndex (x:xs) (y:ys) 0 = x == y doesn't use recursion.  Yes, you will want a recursive case where both lists are non-empty and the index isn't yet zero, and at least 2 base cases - one where you've reached the end of a list, and another where the index is zero
09:55:01 <mizu_no_oto_work> sameListIndex (x:xs) (y:ys) 0 = x == y is like saying sameListIndex xs ys n = if (length xs > 1 && length ys > 1 && n == 0) then head xs == head ys else undefined.
09:56:02 <DELB_> sameListIndex (x:xs) (y:ys) n = sameListIndex xs ys (n - 1)
09:56:05 <DELB_> is this the recursive case?
09:58:17 <RouxTheDay> DELB_: looks right to me
10:02:50 * hackagebot packdeps 0.4.3 - Check your cabal packages for lagging dependencies.  https://hackage.haskell.org/package/packdeps-0.4.3 (MichaelSnoyman)
10:02:52 * hackagebot yaml 0.8.20 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.20 (MichaelSnoyman)
10:18:30 <parsnip> does `ghc: out of memory (requested 1048576 bytes)' mean i need 10 megs of RAM? 
10:18:59 <parsnip> i keep upgrading my instance, and keep falling short. 
10:19:07 <bitemyapp> parsnip: that's the number of bytes a malloc call was requesting when it failed, I think.
10:19:16 <bitemyapp> parsnip: you don't need to upgrade your instance per se
10:19:17 <younder> http://stackoverflow.com/questions/9190712/why-does-my-haskell-program-keep-running-out-of-memory
10:19:31 <bitemyapp> I've run GHC on machines with 512mb of RAM, but I had a 4gb swap partition and swappiness to 100.
10:19:39 <bitemyapp> naturally this means it's much slower.
10:19:40 <dolio> That's 1 million bytes, not 10 million.
10:20:04 <parsnip> oh, woops
10:20:58 <parsnip> it happens during `stack build' in my hakyll site, and especially for some JuicyPixels 
10:21:59 <parsnip> http://sprunge.us/cWRU
10:22:31 <parsnip> trying to build on an EC2 t2.*
10:23:47 <parsnip> t2.micro has 1GB of RAM, so i don't think i understand the problem. 
10:24:14 <parsnip> and i tried on t2.medium, which has 4GB of RAM. 
10:24:39 <dolio> Are there ulimits set up?
10:25:27 <dolio> Try `ulimit -a`.
10:26:09 <spdionis> hello
10:26:34 <parsnip> http://sprunge.us/XAdh
10:27:04 <spdionis> can anyone tell me why "isFactor a = (==) 0). mod a" compiles and "isFactor = (==) 0 . mod" doesn't?
10:27:16 <spdionis> just a quick question :)
10:27:37 <parsnip> spdionis: are you missing a paren on the left
10:28:03 <spdionis> "isFactor = ((==) 0) . mod" also doesn't compile
10:28:04 <dolio> Hmm, it's not limits. Maybe the thing you're compiling really takes more than 4 GB.
10:28:23 <parsnip> okay, will try more ram :(
10:28:24 <Tuplanolla> If you want to pass two arguments to the first function, you need to compose with `.:`, spdionis.
10:28:46 <Tuplanolla> :t (.) . (.) -- = (.:)
10:28:48 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:28:59 <nitrix> Looks like unecessary pointfree to me.
10:29:09 <spdionis> thank you Tuplanolla :)
10:29:09 <Tuplanolla> It is usually not a good idea.
10:29:18 <spdionis> of course it is nitrix, it was a for fun experiment
10:29:19 <quchen_> :t \f g x y -> f (g x y) -- which one is more readable
10:29:21 <lambdabot> (t -> t1) -> (t2 -> t3 -> t) -> t2 -> t3 -> t1
10:29:52 <spdionis> just a way to understand better how `.` works
10:29:56 <lyxia> :t fmap . fmap
10:29:57 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:30:15 <lyxia> :t fmap fmap fmap
10:30:16 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:30:17 <ertes> :t fmap fmap fmap
10:30:19 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:30:25 <lyxia> :P
10:30:31 <parsnip> :t (.)
10:30:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:30:36 <nitrix> It's even more generalized, right?
10:30:44 <nitrix> Where `f` is ((->) r) ?
10:31:07 <lyxia> yes
10:31:15 <nitrix> (a -> b) -> (r -> r2 -> a) -> r -> r2 -> b
10:31:47 <nitrix> That unifies. Cute :P
10:33:16 <quchen_> spdionis: You can view (->) as a type of map that does a lookup on its LHS to give you an entry on the RHS. You’d expect “fmap” for a “Map a b” to change the “b” to something, and likewise “fmap” changes the “b” in “(->) a b” to something.
10:34:47 <spdionis> i think this was for lyxia?
10:35:07 <lyxia> nope :)
10:35:45 <quchen_> Nope.
10:35:59 <nitrix> Or you can think of it as the context of your functor being partially applied functions. Surely you undo or change applied value, but you can add more transformations to the result.
10:36:27 <nitrix> Thus fmap = (.), composing other functions (applying more functions on the result).
10:36:48 <nitrix> *cannot undo
10:38:36 <quchen_> The other reason for fmap = (.) is that it’s the only way to implement it for functions.
10:38:47 <quchen_> That doesn’t help intuition, but it’s nice to keep in mind anyway.
10:39:20 <spdionis> ok, I'm taking my time to parse your explanations
10:39:22 <spdionis> thank you
10:41:55 <Jenaf> Hi! can there be an unhealthy overuse of where?
10:42:03 <Jenaf> i kinda like it..
10:42:08 <maerwald> unhealthy? :o
10:42:43 <glguy> Jenaf: The question is probably too broad to have a useful answer.
10:43:03 <Jenaf> @glguy the function i jsut wrote: https://gist.github.com/anonymous/1dc6670e76e990c8082b8e093f76da4d
10:43:04 <lambdabot> Unknown command, try @list
10:43:15 <glguy> Jenaf: @ is for bot commands
10:43:20 <Jenaf> oopsie 
10:43:39 <cocreature> looks ok from a stylistic point of view (without having looked at what the code actually does)
10:43:40 <maerwald> looks normal, keep going
10:43:45 <Jenaf> k cool
10:44:06 <cocreature> Jenaf: you might want to pattern match on theOpt instead of calling fst and snd
10:44:38 <Jenaf> I'm not too sure about the pattern matching capabilities of haskell yet
10:44:43 <maerwald> I find long lines like: foo . bar . baz (++) meh . flip (.) whatever $ dada $ gaga -- much worse, because there is no indiciation of logical pieces
10:44:47 <Jenaf> is there a nice tutorial about that somewhere?
10:45:11 <maerwald> so adding where clauses just to make things more readable is not uncommon
10:45:25 <Jenaf> maerwald: like this? (I kind ahate myself a bit for writing that line)
10:45:28 <Jenaf> putStr $ concatMap (\l -> (map intToDigit l)++"\n") $ map (take 9)$ take 9 $ iterate (drop 9) $ map cellToEntry $ toList world
10:45:35 <maerwald> yes
10:46:01 <cocreature> Jenaf: sorry I don’t have a nice one handy. in this case you could just replace theOpt by (theOptFst, theOptSnd) in the second line and then use theOptFst and theOptSnd instead of calling fst and snd (obviously you should try to find better names
10:46:03 <cocreature> )
10:46:24 <Jenaf> yeah
10:47:00 <cocreature> Jenaf: and newOpts will create an infinite number of concatenated copied of optList, I’m not sure if that’s what you intend to do
10:47:16 <cocreature> if it is, there is a "cycle" function
10:47:21 <Jenaf> huh?
10:47:24 <Jenaf> oh
10:47:47 <Jenaf> typo'd there
10:48:05 <Jenaf> newOpts  = optList++unlisted
10:48:12 <Jenaf> that's the thing I wanted
10:48:24 <Jenaf> thy for pointing that out
10:49:17 <quchen_> Jenaf: The problem with “where” is that it’s always potentially recursive, so in a block of 10 definitions they could all reference each other.
10:49:46 <quchen_> Same for “let”, but those can be nested more nicely to give you smaller individual scopes.
10:50:25 <Jenaf> I use where manly to represent my thinking process; that should also avoid unwanted recursion
10:51:11 <quchen_> Sure, but reading the code we cannot see that.
10:51:29 <fnurglewitz> quchen_: noob question, aren't 10 definitions considered an antipattern?
10:51:58 <fnurglewitz> quchen_: 10 looks like a lot
10:52:14 <quchen_> fnurglewitz: Replace 10 with “n”.
10:52:28 <quchen_> In the snippet above there are 5, and that’s confusing enough.
10:52:48 * glguy hadn't heard of the 10 definition anti-pattern, and no breaking things up into many small definitions isn't an "antipattern"
10:53:12 <fnurglewitz> glguy: yes, sorry, wrong term
10:53:17 <bitemyapp> if you try hard enough, anything can be an anti-pattern
10:53:19 <fnurglewitz> glguy: english is not my main language =)
10:53:28 <bitemyapp> you just have to believe in yourself
10:53:47 <fnurglewitz> glguy: code smell sounds better?
10:54:03 <glguy> I can't stand that term, but people seem to like it
10:54:07 <Jenaf> well I could avoid having 5 wheres and instead have 5 different functions!
10:54:11 <quchen_> It’s an antipattern if you see a piece of code and think “oh my god, I’ll need to untangle this in order to understand anything”
10:54:14 <johnw> I'm just worried about what happens when a pattern meets an anti-pattern
10:54:15 <Jenaf> way less anti-pattern .-P
10:54:15 <glguy> But the point is that it's OK and encouraged to break things up into small definitions
10:54:17 <Tuplanolla> It sounds like you need antipattern matching.
10:54:32 <cocreature> Tuplanolla: that’s a good one :)
10:54:55 <fr33domlover> johnw, they disappear into /dev/null ?
10:55:18 <Jenaf> the issue I'm currently talking only came into the world because I had no internet connection. and now instead of using a real datatype I hacked together my own ugly representation.
10:55:30 <Jenaf> but it's just a hobby piece so it's ok
10:57:05 <geekosaur> they probably breed >.>
10:57:40 <Jenaf> oh I just found a typo in the description of Data.Sequence on hackage
10:57:50 <Jenaf> http://hackage.haskell.org/package/containers-0.2.0.1/docs/Data-Sequence.html
10:58:05 <glguy> Jenaf: You're looking at an old version of the package
10:58:06 <Jenaf> in the function drop "take" is linked where drop should propably be
10:58:25 <Jenaf> oh..
11:03:33 <stevenxl> Hello folks. Does anyone know if this keynote from CUFP 2015 is available anywhere?
11:03:33 <stevenxl> http://cufp.org/2015/amanda-laucher-keynote.html
11:03:37 <stevenxl> I can't seem to find it.
11:09:35 <mgore_> I've got a question regarding warp and warp-tls: is running a server for both HTTP and HTTPS as simple as running the same Application with both Network.Wai.Handler.Warp.run and Network.Wai.Handler.WarpTLS.runTLS?
11:17:24 <Jenaf> is there something like map to use on data.Sequence.Seq a ?
11:17:40 <Cale> fmap
11:17:54 <alercah> map
11:18:00 <Koyaanis> ap
11:18:00 <Koyaanis> ape
11:18:01 <Koyaanis> niggers
11:18:02 <Koyaanis> oops
11:18:03 <alercah> Seq is Traversable
11:18:10 --- mode: ChanServ set +o glguy
11:18:11 --- mode: glguy set +b Koyaanis!*@*
11:18:11 --- kick: Koyaanis was kicked by glguy (bye)
11:18:12 <Jenaf> ahh
11:18:45 --- mode: glguy set +b-b *!*@h2537215.stratoserver.net Koyaanis!*@*
11:19:13 <alercah> oh wait, map is not polymorphic?
11:19:19 <alercah> did that change lately or am I just crazy
11:19:29 <nitrix> alercah: map is fmap specialized to lists only.
11:19:45 <mgore_> Prelude.map is the specialized version
11:19:56 <nitrix> fmap :: (a -> b) -> f a -> f b
11:20:07 <nitrix> :: (a -> b) -> [] a -> [] b
11:20:15 <nitrix> map :: (a -> b) -> [a] -> [b]
11:20:23 <alercah> yeah I thought map had been made generic
11:20:25 <alercah> that's all
11:20:30 <Jenaf> thanks a LOT
11:21:33 --- mode: glguy set -qqo *!*@AAnnecy-653-1-81-186.w90-41.abo.wanadoo.fr *!*@2.237.171.7 glguy
11:21:51 <nitrix> instance Functor [] where fmap = map
11:22:37 <nitrix> I'm sure plenty of people wish it happened, but it probably wont for a lot of reasons (backwards compatibility, beginner friendlyness, etc).
11:22:40 <nitrix> I have faith though.
11:23:03 <Tuplanolla> Don't we have that extension in the making that allows programmable error messages?
11:23:13 <jg_> i'm having trouble understanding the type signatures of Data.Typeable functions. What should i read to understand the type signature of eg "typeOf3 :: forall t a b c. Typeable t => t a b c -> TypeRep"
11:23:44 <EvanR> nitrix: backwards compatability (we dont care in general! heart breaking proposals), beginner friendlyness... anything else? ;)
11:23:52 <nitrix> jg_: There's a couple parts to it. Begin by asking the first things that is confusing you about it.
11:24:00 <Cale> alercah: Back before Haskell 98, map was a method of Functor, but that was a long time ago.
11:24:16 <EvanR> i just found this blog post about something which might make IntMap comparisons faster https://www.schoolofhaskell.com/user/edwardk/revisiting-matrix-multiplication/part-4
11:24:19 <alercah> Cale: clearly I just haven't written any haskell in too long :)
11:24:46 <EvanR> i wonder if dfuere knows about this or if it was followed up on
11:24:53 <ReinH> EvanR: Yes, and yes.
11:25:04 <nitrix> EvanR: I'd really like to see those disappears. Same story for mapM... and a lot of the partial functions too.
11:25:06 <jg_> okay, so probably the simplest thing that'd confuse me would be: "f :: a b -> c d" -> so are 'a' and 'c' some type constructors of one argument?
11:25:10 <ReinH> There's ongoing work to get something similar into containers
11:25:22 <EvanR> cool
11:25:44 <ReinH> jg_: they must be
11:25:48 <lyxia> jg_: they may be partially applied type constructors
11:25:53 <lyxia> Either a
11:26:00 <ReinH> They must be of kind * -> *
11:26:05 <glguy> jg_: No, a and c are type variables
11:26:31 <ReinH> Right, rather they are "for all type constructors a, c of kind * -> *"
11:26:37 <nitrix> What function has that type?
11:26:53 <ReinH> None that is useful.
11:26:57 <glguy> ReinH: No, a and c don't need to be limited to type constructors
11:27:15 <glguy> Either String  would be an appropriate instantiation for a
11:27:17 <ReinH> sorry, for all types a, c of kind * -> *
11:27:26 <jg_> so typeOf2 is about type constructors that take two arguments like uh - Either?
11:27:30 <ReinH> the terminology continues to confuse me
11:27:46 <glguy> jg_: It's about *types* that take two arguments
11:28:06 <nitrix> :t typeOf2 (Right 5)
11:28:07 <lambdabot> TypeRep
11:28:11 <ph88^> lyxia, it's SourcePos from the megaparsec library
11:28:12 <nitrix> :t typeOf1 (Just 5)
11:28:14 <lambdabot> TypeRep
11:28:46 <nitrix> Maybe :: * -> *,   Either :: * -> * -> *
11:29:47 <nitrix> Both Maybe and Either are Typeable, you can see how the kind of `t` varies though for typeOf1 and typeOf2.
11:30:13 <EvanR> is there a more efficient way to convert an enum type to Int than pattern matching... perhaps Data.Data ?
11:30:21 <lyxia> ph88^: why would you want it to be Uniplate
11:30:28 <EvanR> speaking of which i wonder how deriving Enum works
11:30:31 <ph88^> lyxia, https://hackage.haskell.org/package/megaparsec-5.1.1/docs/Text-Megaparsec-Pos.html#t:SourcePos
11:31:17 <nitrix> jg_: It's only possible because `t` is poly-kinded because of Proxy.
11:31:24 <lyxia> ph88^: It's not recursive. Isn't uniplate to write transformations on recursive types?
11:31:31 <ph88^> lyxia, this record is part of my syntax tree which consists of several types. I want to use transform biplate to do transformations on the syntax tree. As i understand it to do Biplate i have to implement Uniplate first (see the link in my original question)
11:31:50 <jg_> nitrix: i'd love to understand what that means (to be poly-kinded)
11:32:12 <haskell558> hey guys, following the knight position example of LYAHFGG, I started to wonder if it was possible to create a function that applies the same function to a monad a given number of times and returns the final result
11:32:24 <haskell558> but when trying to implement it, I only got this far http://lpaste.net/282684
11:32:26 <nitrix> jg_: class Functor f where fmap :: (a -> b) -> f a -> f b
11:32:30 <ph88^> lyxia, i'm using Uniplate.Direct because i have problems with Uniplate.Data and it should also be faster than Uniplate.Data (i tried Uniplate.Data before)
11:32:31 <nitrix> jg_: What is the kind of `f` ?
11:32:35 <lyxia> ph88^: well, don't implement uniplate or biplate for sourcepos
11:33:00 <jg_> nitrix: erm * -> * i guess
11:33:18 <nitrix> Correct. Do you understand why or is it a random guess :P ?
11:33:23 <ph88^> lyxia, the compiler is giving me an error that it can't find this instance
11:33:55 <Tuplanolla> In the case for applying it `n` times, you applied it once, haskell558. If only there was a function you could call to apply it `n - 1` more times...
11:34:19 <jg_> nitrix: types of values are *, Functor takes a type to return another type
11:35:02 <lyxia> ph88^: I suppose something is wrong with your definition then
11:35:05 <haskell558> Tuplanolla, yeah I was trying to figure out how to do the recursion, but not sure how to go about, seeing my applyMulti returns a monad, not a function :o
11:35:06 <ph88^> lyxia, to be more precise: no instance for (Biplate ContextClause SourcePos)
11:35:07 <jg_> or at least that's what i remember from LYAH
11:35:10 <ReinH> Functor is not a type.
11:35:15 <nitrix> jg_: (->) has kind * -> * -> *, where all its arguments must have concrete types. Thus we can deduce that `a` and `b` both have kind `*`, they're type variables for concrete types, and so `f a` and `f b`, if `f` is applied on them, it must thus be a type constructor, `* -> *` or more.
11:35:21 <ReinH> *instances* of Functor are types of kind * -> *
11:35:27 <nitrix> jg_: Good. Now, Either.
11:35:42 <ph88^> lyxia, ContextClause does not contain SourcePos directly ... but it does through one of it's many child types
11:36:01 <jg_> nitrix: * -> * -> *
11:36:14 <ph88^> ContextClause is the root of the tree and sourcePos is a leaf
11:36:17 <nitrix> jg_: Correct. Now Typeable :P
11:36:47 <nitrix> jg_: class Typeable a where ... (let's pretend) ... typeRep :: forall proxy a. Typeable a => proxy a -> TypeRep
11:36:59 <nitrix> What kind does the type variable `proxy` have :P ?
11:37:49 <jg_> * -> * 
11:38:11 <nitrix> Almost.
11:38:14 <nitrix> :k Proxy
11:38:16 <lambdabot> k -> *
11:38:28 <jg_> the heck is a 'k'
11:38:40 <nitrix> A kind variable :)
11:38:44 <nitrix> Polymorphic kinds :P
11:38:52 <haskell558> oh, I was thinking it totally backwards
11:39:40 <nitrix> jg_: Thus, I'm not an expert on the subject, but I think that's what allows you to build (* -> *) -> *
11:39:45 <lyxia> ph88^: I'd try to make it so I don't need such an instance
11:39:49 <ph88> lyxia, this is the tree structure of types https://paste.fedoraproject.org/455822/14769023/
11:39:49 <ph88> well part of it ..
11:39:50 <Jenaf> I keep getting a parse error on this pattern: (coord,opts):rest
11:40:02 <Jenaf> and I don't really know why
11:40:14 <ph88> lyxia, why do i need such an instance now and how can i make it so that i don't need this instance?
11:41:14 <ReinH> Jenaf: what's your code and error message?
11:41:15 <ReinH> @paste
11:41:16 <lambdabot> Haskell pastebin: http://lpaste.net/
11:41:17 <jle`> Jenaf: can you give more context?
11:41:34 <jle`> or yes, that
11:41:38 <nitrix> jg_: And use Proxy to wrap any type of any kind. If we step back, that allows us to have Typeable on things of varying kinds.
11:41:40 <ReinH> ((coord,opts):rest) is a legal pattern
11:41:44 <jg_> nitrix: trying to read up on the stuff in the ghc manual. Is that the thing that's being enabled by XPolyKinds?
11:41:57 <nitrix> jg_: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Proxy.html#Proxy
11:41:59 <ReinH> matching a value of type [(a,b)] for some a, b.
11:42:08 <nitrix> jg_: Indeed. You can see PolyKinds extension at the top.
11:42:25 <jle`> Jenaf: if you're using it as function arguments or as the pattern for a lambda, you need parentheses
11:42:38 <parsnip0> nice. so i turned server up to 8GB RAM, stack build succeeded, then discovered i could dial it back to .5GB RAM for a new cheaper instance, and stack build still works! 
11:42:55 <ph88> lyxia, i thought i only had to describe the Biplate of one node to it's child node. But right now it says it's missing instances from root node to leaf nodes
11:42:57 <parsnip0> my hakyll site is safe on the remote! 
11:42:58 <Jenaf> http://lpaste.net/282748
11:43:00 <lyxia> ph88: What did you do that lead you to having this constraint
11:43:18 <Jenaf> and Yes I am doing some onbeautifull things there
11:43:19 <ReinH> Jenaf: yes, you need parens
11:43:24 <jle`> Jenaf: oh yes this is exactly what i expected
11:43:26 <jle`> earlier
11:43:34 <Jenaf> oh
11:43:37 <Jenaf> thy
11:43:47 <jle`> foo x:xs parses as having three tokens for inputs, x, :, and xs
11:44:12 <jle`> which haskell freaks out over becuase : can't be a pattern
11:44:12 <ph88> lyxia, somewhere i define a transformation .. and i define that the input variable a should be of type ContextClause
11:44:38 <Jenaf> okay works now
11:44:44 <nitrix> jg_: Now since this class has to work on everything; it's a magical typeRep# implemention by the compiler that does the hard work of creating the TypeRep values.
11:44:54 <jle`> Jenaf: alternatively you can use a caes statement, which doesn't require parentheses
11:45:01 <srk> https://www.haskell.org/hoogle/?hoogle=(%3A%7C)
11:45:03 <srk> much amusing :D
11:45:06 <jle`> because case statement branches are unambiguously one single pattern
11:45:20 <Jenaf> no need for case there
11:45:41 <jle`> yeah, i'm saying you can rewrite your function to use a case branch instead if you wanted to avoid the parentheses
11:45:58 <nitrix> jg_: Things ending with # (magic hash) are typically compiler intrinsic with pixel dust; but you can see at least how it's still sound at the type level.
11:46:10 <ph88> lyxia, here is a piece of the code where this constraint was given https://paste.fedoraproject.org/455827/76902715/
11:47:51 <ReinH> (note that the '#' itself has no special meaning, it's just used by convention)
11:47:57 <jg_> :k int
11:47:58 <ReinH> that is, special meaning to the compiler
11:47:59 <lambdabot> error:
11:47:59 <lambdabot>     Not in scope: type variable ‘int’
11:47:59 <lambdabot>     Perhaps you meant type constructor or class ‘Int’ (imported from Data.Int)
11:48:05 <nitrix> jg_: Uppercase.
11:48:07 <jg_> :k Int
11:48:09 <lambdabot> *
11:48:16 <nitrix> :k Either
11:48:18 <lambdabot> * -> * -> *
11:48:25 <jg_> hm, i've read that # stands for unboxed types/ functions dealing with them
11:48:27 <nitrix> :k Typeable
11:48:28 <lambdabot> k -> Constraint
11:48:35 <jg_> shouldn't Int be of kind '#'?
11:48:42 <geekosaur> Int is boxed
11:48:42 <Tuplanolla> :k Int#
11:48:44 <nitrix> jg_: Int# has kind #
11:48:44 <lambdabot> error:
11:48:45 <lambdabot>     Not in scope: type constructor or class ‘Int#’
11:48:45 <lambdabot>     Perhaps you meant one of these:
11:48:47 <jg_> oh okay
11:49:20 <lyxia> ph88: hmmm... I'm not sure anymore whether this is a bad idea
11:49:36 <nitrix> jg_: See GHC.Prim.
11:49:37 <lyxia> ph88: but since SourcePos is not recursive there is a trivial instance
11:49:53 <ph88> lyxia, so in my tree i can walk a path: ContextClause -> ContextItem -> LibraryClause -> Terminal -> SourcePos   and i want to transform this tree by changing all the SourcePos as you can see in the transformation function. I had this working with Uniplate.Data but there is a bug in the uniplate library that causes it sometimes to not terminate, that's why i'm switching to Uniplate.Direct. Ok so the root node is ContextClause .. but later on i will choose 
11:49:53 <ph88> other root nodes. I thought i had to implement the Biplate from each node to it's child nodes .. that is ..   ContextClause -> ContextItem,  ContextItem -> LibraryClause,  LibraryClause -> Terminal,  Terminal -> SourcePos
11:50:57 <geekosaur> jg_, since Haskell is lazy-by-default, all the standard types are boxed
11:51:05 <ph88> lyxia, yes you are right i think the instance of Uniplate from SourcePos will be easy .. this is just a syntactic issue .. namely: i don't know the right syntax
11:51:09 <lyxia> ph88: instance Uniplate SourcePos where uniplate x = (Zero, \Zero -> x) ; descend = const id ; descendM = const return
11:52:02 <lyxia> I assume you're not supposed to apply the function passed to descend and descendM to the root, since it says "on all the immediate children".
11:52:26 <lyxia> Children of which there are none.
11:52:55 <lyxia> ph88: Does that work?
11:54:04 <ph88> lyxia, i don't belief i have to implement either descend or descendM .. in the examples implementing uniplate for the Uniplate instance is enough to make it work on tuples. As i understand records they are like decorated tuples so they should also only need the implementation of the uniplate function
11:55:14 <ph88> lyxia, i don't understand your proposed implementation:  uniplate x = (Zero, \Zero -> x)    what's Zero, and what's \Zero even ?
11:55:26 <lyxia> fair enough
11:55:50 <lyxia> ph88: the first component should be the collection of immediate children of x
11:56:15 <lyxia> ph88: "immediate children" of the same type
11:56:54 <Jenaf> great.. the site I read stuff from had a \\ function (\\) :: Eq a => [a] -> [a] -> [a] ; but ghc doesn't seem to find it
11:57:23 <lyxia> ph88: and the second component is a function that takes an updated collection and puts it back into x.
11:57:31 <Tuplanolla> :t Data.List.\\
11:57:32 <nitrix> jg_: Did that help? I don't have the full details, just a general feel of it. Still new with Haskell (:
11:57:33 <lambdabot> error: parse error on input ‘Data.List.\\’
11:57:35 <lyxia> ph88: Was that clear?
11:57:45 <Tuplanolla> :t (Data.List.\\) -- Here it is, Jenaf.
11:57:47 <lambdabot> Eq a => [a] -> [a] -> [a]
11:58:07 <ph88> lyxia, from the examples at https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Direct.html  suppose you have  data Stmt = Let String String   i think the uniplate implementation would be:  uniplate (Let x y) = plate Let |- x |- y
11:58:10 <Jenaf> and how do i import it? import Data.List ((\\))
11:58:12 <Jenaf> ?
11:58:20 <Tuplanolla> Try it and see.
11:58:27 <jg_> nitrix: yes, talking about it cleared up some of my confusion at all those letters at the typelevel. Thanks!
11:58:58 <ph88> lyxia, so |- help create the tuple you describe ?
11:59:11 <lyxia> yeah
12:00:23 <lyxia> but if the type is not recursive these operators are not really useful
12:00:33 <EvanR> hmm. i cant seem to derive Generics or Data for GADTs
12:00:40 <EvanR> Typeable works
12:01:13 <lyxia> ph88: it's actually slower because it requires you to destruct and reconstruct the value
12:01:38 <cocreature> EvanR: yeah generics don’t work with GADTs sadly
12:01:41 <younder> bloody hell, haskell has grown 1547 users!
12:02:01 <EvanR> bollocks
12:02:11 <younder> #haskell
12:02:28 <ph88> lyxia, when is something an immediate child of x? for example sourceLine which is an element of the record type SourcePos is of type Pos .. so this seems to be another type and thus also needs a Uniplate instance? Why then are you putting Zero as the first element of that tuple?  In case it's immediate children of the same type this can only be true with recursive types, correct?   Then about the second element of the tuple: what collection are you talking 
12:02:28 <ph88> about?   And last question: what is Zero ?
12:02:53 * hackagebot epub-metadata 4.5 - Library for parsing epub document metadata  https://hackage.haskell.org/package/epub-metadata-4.5 (DinoMorelli)
12:02:55 * hackagebot epub-tools 2.9 - Command line utilities for working with epub files  https://hackage.haskell.org/package/epub-tools-2.9 (DinoMorelli)
12:03:20 <EvanR> cocreature: do you know of a way to crack over the constructors anyway and get the ConIndex (Int)
12:03:24 <EvanR> crack open
12:04:11 <younder> Haskelll doens't have classes.. Constructor?
12:04:25 <ph88> lyxia, with Uniplate.Direct i have to implement quite a lot of stuff .. i wonder what it actually gives me in comparison to make an implementation on top of GHC.Generics myself .. which should also be about 10x faster according to this issue  https://github.com/ndmitchell/uniplate/issues/11
12:04:36 <cocreature> EvanR: sadly I don’t. the last time I tried to do generics on gadts I gave up when I found an open trac issue
12:04:57 <cocreature> younder: data constructors, e.g. Nothing, Just, True, …
12:05:47 <younder> cocreature, ok types
12:06:08 <ph88> cocreature, did you use GHC.Generics ?
12:06:13 <cocreature> younder: type constructors and data constructors are different things
12:06:24 <lyxia> ph88: it's faster than SYB; not hand rolled instances with Direct
12:06:29 <Jenaf> how do get to the first element in a sequence? like using head on a list
12:06:30 <cocreature> ph88: I tried but it’s been months and I forgot anything about GHC.Generics :)
12:06:35 <Jenaf> I kinda keep forgeting the basic things
12:06:39 <younder> cocreature, I know..
12:06:51 <m1dnight_> hoogle "[a] -> a" might help
12:06:55 <m1dnight_> I think it's just "first"
12:07:02 <m1dnight_> or xs !! 0
12:07:03 <cocreature> Jenaf: sequence as in Data.Sequence?
12:07:10 <Jenaf> yes
12:07:14 <m1dnight_> oh out of context, carry on.
12:07:42 <ph88> lyxia, not sure what you are saying about "not hand rolled instances with Direct"
12:07:54 <cocreature> Jenaf: \s -> index s 0 should work. not sure if there is a better way
12:07:57 <lyxia> ph88: I mean something like what I wrote
12:08:20 <Jenaf> cocreature yeah i guess that should work, too but.. it's kinda meh
12:08:24 <byorgey> Jenaf: call 'viewl' on it and pattern-match the result
12:08:28 <lyxia> ph88: that would be the fastest instance of uniplate for SourcePos since it doesn't even look at its argument
12:09:08 <ph88> lyxia, maybe you can refer me to some relevant documentation? I have absolutely no idea where you got the idea of (Zero, \Zero -> x) .. i still don't know what Zero is. And i don't understand how  \Zero -> x  can be valid syntax
12:09:21 <osa1> does anyone know if generalizing list comprehensions to use any foldables in the right hand side of `<-`s was considered before?
12:09:23 <byorgey> {-# LANGUAGE ViewPatterns #-}   myFunc (viewl -> (x :< xs)) = ...
12:09:24 <ph88> lyxia, ok give me a moment i will try that ..
12:10:11 <ReinH> osa1: Not sure. Seems reasonable. Ofc you can just use toList now.
12:10:29 <Jenaf> okay it seems to work
12:10:37 <ph88> lyxia, Not in scope: data constructor ‘Zero’
12:10:52 <lyxia> ph88: I think the notion of "immediate child" is not rigid, but for your purposes, the fields of the record sounds correct.
12:11:21 <joe9> Is there a version of TQueue from which I can read n number of bytes?
12:11:28 <lyxia> ph88: it's in Data.Generics.Str
12:11:47 <osa1> ReinH: sure, it's not a huge improvement but still. I was pleasantly surprised that I didn't have to update a function that I wrote with lists in mind when I switched to a Data.Set.Set from list thanks to generalizations like this we've done recently :)
12:11:47 <joe9> the readTQueue but read only n bytes
12:12:27 <lyxia> ph88: Str is just a quick way of putting some values together. It might as well have been a list.
12:12:47 <ph88> found a relevant piece of documentation here, it mentions Zero  https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Operations.html
12:12:54 <ReinH> joe9: Is n fixed?
12:13:15 <lyxia> ph88: Uh, yeah that's what I was looking at, sorry for not mentioning this.
12:13:21 <joe9> ReinH , n might change for each read
12:13:31 <lyxia> ph88: It is linked to from .Direct
12:13:47 <ReinH> joe9: Then a queue doesn't seem appropriate
12:13:52 <jle`> osa1: might wonk up type inference if MonadComprehensions is also on
12:13:54 <ReinH> queues are for discrete things
12:14:08 <lincsimp_> Hi. What's the best way to get GHC + cabal + a reasonable selection of packages installed on an air-gapped machine w/o root? Haskell Platform Linux generic binary install appears to require root. Haskell Platform source install requires cabal-install + other packages and it would be tedious to resolve deps and copy them over manually. I'm able to install GHC and then cabal-install, but don't know where 
12:14:12 <lyxia> ph88:I've got to go for now
12:14:14 <lincsimp_> to go from there. Perhaps I could install Haskell Platform on another machine and copy over the packages? Any help appreciated!
12:14:48 <ReinH> And I doubt putting the data into the queue a byte at a time is reasonable 
12:15:05 <ph88> lyxia, ok see you later. Thank you for help
12:15:31 <ReinH> Maybe you want pipes or conduit + concurrency? I'm not sure what your use case is.
12:15:34 <osa1> jle`: mmmm good point.
12:16:52 <osa1> wow MonadComprehensions have some weird syntax
12:16:54 <EvanR> cocreature: yeah just tried a manual Data instance, gadts dont fit the polymorphic type of gunfold
12:16:58 <ReinH> lincsimp_: this sounds like a perfect use case for Skete, if only it were finished.
12:17:03 <osa1> "then group by e using f"
12:17:07 <EvanR> blast!
12:17:07 <jle`> osa1: it's just the normal syntax isn't it?
12:17:25 <osa1> jle`: as far as I can see from the wiki page it's not: https://ghc.haskell.org/trac/ghc/wiki/MonadComprehensions
12:17:44 <y3ckw7ia> sorry for the off topic question; haven't been on irc in a while.  how do you hide the userlist on the right of the channel?
12:17:47 <osa1> I was also looking at the paper http://db.inf.uni-tuebingen.de/staticfiles/publications/haskell2011.pdf
12:17:54 <ReinH> lincsimp_: but I'd imagine a Haskell Platform installer for your platform would be sufficient.
12:17:58 <lincsimp_> ReinH, is it in a usable state?
12:18:08 <jle`> y3ckw7ia: that's a feature of your client, not of irc :)
12:18:10 <guillaum2> Hi today. Is there something special which allows ghc to accept defaulting some Num literal sometimes and not some others times. For example, http://lpaste.net/282890, I'm trying to implement a custom "Enum" typeclass and I don't get the defaulting behavior.
12:18:15 <ReinH> lincsimp_: Not really
12:18:41 <y3ckw7ia> jle` ah, right.  sorry about that.  i'm using mirc if anyone's familiar
12:19:01 <younder> thats's an old one
12:19:09 <kadoban> lincsimp_: I'd use 'stack' personally. You might be able to do it with cabal too, but I dunno how. I'd just still stack and install a few dependency-heavy packages like pandoc, yesod, etc. I think there's also docker containers you could download that include all packages from hackage, but I dunno how that works.
12:19:16 <younder> I use XChat'
12:19:20 <y3ckw7ia> ha, it's the only one i've every really used
12:19:24 <y3ckw7ia> is xchat the new go to?
12:19:33 <younder> not a chance
12:20:01 <younder> it's as old as the hills
12:20:54 <geekosaur> xchat is so old it's dead now... hexchat is the active fork
12:21:22 <geekosaur> and unlike xchat it is free on windows (this is a large part of why xchat is dead)
12:21:38 <jle`> i use weechat, it's still actively maintained :)
12:21:44 <y3ckw7ia> yeah, i was just looking at weechat
12:21:46 <y3ckw7ia> looks really nice
12:21:55 <guillaum2> irssi for the winners ;)
12:22:02 <y3ckw7ia> thanks for the info.  haven't been on here in forever it feels like
12:22:21 <y3ckw7ia> irssi looks very clean
12:22:40 <younder> weeee
12:23:22 <lincsimp_> ReinH, kadoban: thanks, I'll explore both approaches.
12:23:50 <EvanR> cocreature: actually i just got it to work
12:24:03 <cocreature> EvanR: oO, how?
12:24:12 <guillaum2> y3ckw7ia: actually I'm using irc occasionally, so irssi is alright, but i don't know any of its advanced features.
12:24:32 <EvanR> implemented the Data instance method toConstr manually
12:24:56 <EvanR> ... which just does a pattern match
12:25:00 <y3ckw7ia> guillaum2, yeah i really like the look of it.  we run windows on our work computers, so it's looking like i'd need to install cygwin to get it from what i'm reading
12:25:02 <EvanR> so pointless
12:25:07 <y3ckw7ia> which isn't an issue, just checking out some other options atm
12:25:54 <cocreature> EvanR: and you just didn’t implement the other methods?
12:25:54 <younder> hexchat looks suprisingly exactly like xchat
12:25:58 <EvanR> right
12:26:03 <cocreature> ah fair enough
12:26:24 <EvanR> it seems that template haskell is the only way, and in the end its still not really extracting any preexisting number
12:26:39 <cocreature> what are you actually trying to do?
12:26:51 <EvanR> convert enum-like gadt's ctors to ints
12:27:04 <geekosaur> it's just a fork from just before the xchat folks changed the license to non-gpl, then further development
12:27:38 <younder> template haskell is like a aphrodisiac to a lisper
12:27:39 <EvanR> since to have a set of these, i currently use testEquality
12:28:02 <younder> gotta lisp to love i guess
12:28:05 <EvanR> if i had numbers itd be faster, but then how do you get numbers, gotta pattern match a potentially large amount
12:28:52 <maerwald> younder: I consider it cancer :P so yeah
12:30:18 <geekosaur> (fr a template haskell wrapper called p53)
12:47:57 <fastuous> Anyone familiar with the trifecta parser? I have a question about backtracking and I can't find any good documentation.
12:48:48 <joe9> is there a better data type for this: Maybe ( Either Rerror Rread),
12:50:32 <kadoban> Either SomeError Rread, where SomeError is a sum type of the possible errors, perhaps?
12:50:47 <kadoban> Assuming that Nothing would be some kind of error anyway.
12:51:34 <joe9> kadoban: when it can be proccesed now, I get the Rerror or Rread. When it cannot be processed now and it is a blocking read, I just get Nothing now.
12:52:01 <joe9> kadoban: I clean up the blocking read later when it reads something.
12:52:07 <kadoban> Ah, hmm. Maybe not then.
12:53:32 <Aperson_> Hello. I'm considering learning haskell, can anyone recommend it to me?
12:53:39 <simukis_> I have a function of form `x :: a -> a -> Bool`, then I have a number of implementations pattern matching on said `a` and finally a `x = flip x` as a catch-all which is supposed to swap the arguments for rest of the cases I haven’t pattern matched yet
12:53:57 <simukis_> however the compiler complains to me about “Equations for ‘x’ have different numbers of arguments”
12:54:13 <geekosaur> yes, you have to use the same arity in all of the patterns
12:54:24 <kadoban> simukis_: Yeah, you can't do that unfortunately.
12:54:32 <kadoban> Aperson_: You should learn haskell
12:54:47 <fastuous> you can use "x _ _ = flip x" for your catch-all
12:55:00 <fastuous> that will preserve arity
12:55:11 <simukis_> fastuous: I can do `x a b = x b a` too
12:55:15 <geekosaur> but lose the parameters in the next call
12:55:17 <simukis_> was trying to avoid that
12:55:21 <geekosaur> so no, that's wrong
12:55:45 <fastuous> oh, misunderstood query
12:55:57 <Aperson_> Does it have business usage? I'm php dev at the moment.
12:56:38 <simukis_> Aperson_: haskell is widely (by haskell standards) used in banking sector last time.
12:56:43 <simukis_> last time I checked*
12:56:45 <kadoban> Less than most of the common languages, but it has some industry usage, and seems to be becoming more common.
12:57:19 <y3ckw7ia> simukis_,  what are you working on?       disclaimer: hardly any programming knowledge, but curious about it.
12:58:15 <geekosaur> simukis_, I think in this case you can't avoid the x a b = x b a. But I also suspect that's a risky construct (what if neither a nor b matches the pattern?)
12:58:50 <simukis_> geekosaur: sure its risky, I was considering pattern mathcing explicitly but am way too lazy to do that for just homework
12:59:10 <simukis_> y3ckw7ia: ↑ should also answer your question.
12:59:45 <Aperson_> Community appears to be more 'academic' than in other languages I've tried.
13:00:08 <sbrg> Aperson_: it probably is. 
13:00:11 <sbrg> but that's not bad.
13:00:49 <joe9> ReinH: What would you recommend instead of a Queue? to be able to read a count of bytes at a time?
13:00:50 <sbrg> what you basically get is a bunch of people that are so interested in the language, that whenever you ask for help, you will get tons of people falling over each other all trying to help you at once
13:01:11 <ReinH> joe9: I don't know. Maybe a ByteString in a TVar. Depends on your use case.
13:01:15 <ek> Aperson_: it comes across as more academic but there are more and more companies looking for good Haskell developers. If you want a language (not one I like much) but that is FP and widely searched for in industry, check Scala. However the community will never be as great as Haskell, sbrg is right, it's one of the most friendliest communities I've come across. 
13:01:51 <sbrg> I agree. and the easiest to nerd-snipe ;)
13:01:55 <Aperson_> That's good. Tbh I grew tired of 'learn how to do something, do it passionlessly, forget about it all' way of programming attitude.
13:02:23 <kadoban> Aperson_: Also, regardless of if you end up using it in production, haskell is very interesting for the concepts you'll learn along the way.
13:02:55 * hackagebot servant-subscriber 0.5.0.3 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.5.0.3 (eskimo)
13:03:12 <ek> Aperson_: I am very new to Haskell but have been amazed with the level of detail people go into to help you. Be sure to check out #haskell-beginners 
13:04:06 <Tuplanolla> Teaching is a good way to hone your skills.
13:04:20 <Aperson_> I think I'm sold
13:05:23 <y3ckw7ia> not to hijack the conversation, but would you guys mind telling me what it is you're working on in haskell?  i'm trying to get a fuller grasp of what people are doing with it
13:05:44 <y3ckw7ia> obviously simukis is working on pattern matching
13:05:56 <sbrg> y3ckw7ia: I'm currently implementing a self-balancing tree datastructure for a course. and also implementing AES for another course. 
13:06:24 <Sonolin> metal-archives.com mini CLI lookup tool
13:06:39 <Sonolin> (for lack of better engrish)
13:06:42 <sbrg> well, I haven't started the latter, since tree assignment is due before the AES one, heh. 
13:06:43 <neonfuz> is there a standard function that is the same as (not . null) ?
13:06:44 <y3ckw7ia> sbrg, so essentially learning how to integrate encryption into [program]?
13:07:19 <sbrg> y3ckw7ia: not sure what you mean. the assignment is simply to write a program that encrypts input with AES
13:07:49 <Clint> sm: shelltestrunner appears to build fine with process 1.4
13:07:50 <y3ckw7ia> sbrg, yah
13:08:31 <ek> y3ckw7ia: just learning it for fun, thinking about writing a neural network implementation in Haskell 
13:08:54 <y3ckw7ia> i'm completely fascinated by it all, but i've been too overwhelmed by it to even know where to begin
13:09:00 <simukis_> y3ckw7ia: I’ve self-tought haskell some 4 or 5 years ago; the classes are compulsory so can’t avoid those
13:09:19 <ek> For me http://haskellbook.com/ has been an amazing resource
13:09:24 <sbrg> y3ckw7ia: At the beginning :) there are lots of beginnings, but the beginning of some online course or book is a good start.
13:09:46 <simukis_> and I’ve fthe issue I’ve ran across seemed weird to me, hence the question here
13:11:17 <y3ckw7ia> taking a look at haskellbook.com.  anyone have any other resources they recommend for getting started?  like i said, i know very little about programming, so some concepts are new to me with it.  always worked with front end growing up / for work
13:11:45 <Glitchy> Hi, I have a general 'functional programming' question and I'm wondering if this is the place to post it. I come from an OOP background, and idiomatically we typically test things like databases separately to business logic (for example by mocking the Gateway objects to read from memory or a flat file). How would you go about testing db dependent applications in a functional paradigm?
13:11:51 <ek> I like the course which just started by Levi Notik but to be honest, that book is a solid foundation even if you know zero programming
13:12:09 <nitrix> y3ckw7ia: HaskellBook if you don't mind investing a couple dollars, otherwise the free online courses CIS194 and NICTA.
13:12:19 <nitrix> y3ckw7ia: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
13:12:24 <nitrix> y3ckw7ia: https://github.com/NICTA/course
13:12:37 <ek> y3ckw7ia: nitrix is one of those friendly users I mentioned over at #haskell-beginners 
13:12:47 <nitrix> :)
13:13:00 <y3ckw7ia> ek nitrix, awesome, i'll check it out.  thanks for the info.  been a bit hesitant to ask the basic questions i have in other channels
13:13:33 <sbrg> Glitchy: Mocking is still a thing in functional programming/haskell
13:13:46 <nitrix> You'll get the same quality help in both #haskell and #haskell-beginners; but we're hoping the -beginners help alleviates people's hesitation to ask their questions.
13:13:53 <ek> y3ckw7ia: really don't worry, I continue to ask very newbie questions and the community has been very friendly
13:13:59 <sbrg> in fact, some of the features of Haskell let you auto-generate mocking stuff pretty easily. 
13:14:08 <sbrg> (in some cases)
13:14:10 <Glitchy> sbrg: But if you're not using objects, how would you deal with the dependency inversion?
13:14:21 <ertes> Glitchy: you use functions
13:14:38 <y3ckw7ia> just joined the beginners channel, i'll probably have some questions to ask there in the next coming weeks.  appreciate the push
13:14:45 <Glitchy> ertes: So I pass the repository functions in as an argument? (I'm very beginner on this)
13:14:54 <nitrix> Besides, it's a little less noisy and beneficial overall to hear other beginner's questions. Soon you'll be the one helping others :P
13:15:11 <sbrg> Glitchy: One way of doing stuff is to "roll your own Monad" which basically determines all the stuff you can do in your program. Think of it kind of like an interface and an implementation. You can swap the implementation out with one that doesn't access the database
13:15:12 <ertes> Glitchy: it depends a lot on how you design the application
13:15:34 <vandenoever> i've an exe on linux that works fine but needs LD_LIBRARY_PATH, when i call that exe with System.Process.createProcess and the right LD_LIBRARY_PATH , unf it cannot find the dynamically linked libs
13:15:54 <Sonolin> Glitchy: the Reader monad is one simple way to deal with dependencies
13:15:57 <vandenoever> both exes are haskell binaries
13:16:12 <Glitchy> sbrg: So let's assume a basic case. I have an ISBN number and I want to return the title of the book. In production I do this with MySQL, in development I just want to read it from a collection.
13:16:26 <Glitchy> in testing* not development
13:16:48 <ertes> Glitchy: for example what i like to do is to construct a data model for the application that is a specification of what the database binding should look like, and then write tests against the model
13:17:05 <ertes> Glitchy: then you can simply run the test suite against any concrete implementation you write
13:17:24 <Glitchy> ertes: Do you have an example I could look at? (that's what I'm looking for, basically -- I come from a Java background)
13:17:46 <ertes> Glitchy: then i tend to have two implementations: one using STM for testing the rest of the application, and one using an RDBMS (mostly postgresql) for actual use
13:18:05 <ertes> Glitchy: unfortunately not, but i might write an article about it
13:18:25 <Glitchy> ertes: That's basically what I'm looking for, because I want to be able to test my business logic independently of my border technologies.
13:18:47 <ertes> Glitchy: but it's just as simple as it sounds, as soon as you understand the basics of haskell: you create a type class that specifies the data model
13:20:21 <Glitchy> ertes: Any recommendation for a book to learn Haskell?
13:20:51 <dmj`> Glitchy: typeclassopedia
13:21:19 <dmj`> and pacpih 
13:21:27 <HelgeS> Why doesn't this work:
13:21:39 <HelgeS> (read "asfd") :: String
13:21:46 <sbrg> Glitchy: A popular "webserver library" in Haskell uses types heavily to specify endpoints (which also means you have typesafe routing and stuff). Because the types contain so much information of the structure of the data that the endpoint accepts, the types can actually be used to automatically create mocked APIs. 
13:21:47 <ertes> Glitchy: none that i've read myself
13:21:55 <glguy> HelgeS: Because   asfd   isn't valid syntax for a string literal
13:21:56 <HelgeS> when this works: (read "17") :: Int
13:22:06 <ertes> Glitchy: but i think i can recommend this one blindly: http://www.cs.nott.ac.uk/~pszgmh/pih.html
13:22:11 <Glitchy> sbrg: Could I get a link to the sources?
13:22:12 <isovector> HelgeS: try `read "\"asdf\"" :: String`
13:22:16 <sbrg> https://hackage.haskell.org/package/servant-mock 
13:22:49 <hexagoxel> > show "asfd"
13:22:52 <lambdabot>  "\"asfd\""
13:22:53 <HelgeS> Excellent! Now I udnerstnane
13:22:55 <glguy> HelgeS: you write [[17]] to make an integer literal, you write [["asdf"]] to make a string literal ([[ ]] used for bracketing)
13:23:16 <HelgeS> thanks a lot!
13:23:56 <Glitchy> ertes: Thanks
13:25:01 <nitrix> I'm used to putting code in backticks. It bothers me that Haskell uses that too; I'm running out of options at times :P
13:25:29 <Tuplanolla> Pretend it's Markdown, nitrix: ``42 `quotRem` 13``
13:26:35 <lyxia> Markdown is single quotes isn't it?
13:26:49 <nitrix> Triple.
13:26:56 <kadoban> I think you can use at least up to 3, or maybe exactly 3?
13:27:11 <Tuplanolla> It's single until you want to escape single quotes, in which case it's double, lyxia.
13:27:20 <Tuplanolla> This proceeds recursively.
13:27:20 <lyxia> ok I see
13:27:21 <ertes> nitrix: how about (parentheses)?
13:28:37 <mniip> (())ъ
13:28:45 <mniip> (()) *
13:29:00 <sbrg> nitrix: obviously the solution is to invent yet another scheme
13:29:29 <ongy> mniip: looks like 2 people from above. One with a fist and one with a morning star
13:30:31 <mniip> you could wrap the code in STX/ETX characters
13:31:19 <mniip> "hi"
13:32:31 <nitrix> It shows in a nice white for me.
13:32:52 <Tuplanolla> How about something completely distasteful? █▓▒░ 42 `quotRem` 13 ░▒▓█
13:34:36 <mniip> oh oh oh
13:34:49 <mniip> surround the code with two unit separators!
13:35:01 <mniip> code
13:43:38 <joncol> Would someone be kind enough to take a look at this: http://pastebin.com/UWtYXJSV. I'm trying to solve a problem from the HPFFP book, but tasty-quickcheck is not my friend. When running the test without Tasty, it fails as it should, but when running it using Tasty, it strangely passes. (I'm trying to prove that my monoid instance is incorrect, due to wrong identity element.)
13:44:07 <glguy> http://pastebin.com/raw/UWtYXJSV
13:44:38 <nitrix> sbrg: I have +g
13:45:19 <sbrg> how do I set that?
13:45:24 <sbrg> what else does it ignore?
13:45:30 <nitrix> srk: There, I whitelisted you :)
13:45:49 <glguy> sbrg: Try: /quote help accept , to learn more
13:45:54 <sbrg> cheers
13:46:02 <nitrix> sbrg: /umode +g  It's only private messages.
13:46:34 <sbrg> aaah. okay, I was just /ctcp version'ing you, just curious
13:46:42 <sbrg> was maybe hoping it could ignore stuff like /whois or some such
13:47:36 <nitrix> sbrg: Whois are server-side. All users have +i (invisible), but I have mine off -i. If you whois me, you'll see all my channels :)
13:47:52 <nitrix> (Instead of only the ones we have in common)
13:48:38 <sbrg> aah, yeah i see. I'm reading the freenode page about the modes.
13:48:39 <sbrg> nifty!
13:49:32 <Rembane> I have a name of a function in a String, is there a function to turn that String into an actual function?
13:49:46 <glguy> Rembane: Not without Template Haskell
13:50:10 <glguy> or writing one yourself that supports some specific set of functions
13:50:23 <Rembane> glguy: Oh. I thought Data.Data or some other syb shenanigans could help me.
13:50:37 <mniip> the GHC API
13:50:49 <mniip> no easy way to do that
13:50:52 <mniip> much like in C
13:55:28 <Rembane> mniip: Okay. That is unfortunate, or maybe fortunate in the long run, I'm having a hard time to decide. Thank you for the answer.
13:56:24 <EvanR> String -> Code, like eval?
13:56:57 <Rembane> EvanR: Yes.
13:57:11 <Rembane> Is this true even for field accessors of data types?
13:58:49 <nitrix> Rembane: https://hackage.haskell.org/package/plugins-1.5.5.0/docs/System-Eval-Haskell.html
13:59:02 <mniip> that's the ghc api
13:59:16 <nitrix> It is.
13:59:21 <geekosaur> that's going to work in a separate haskell environment though
13:59:23 <glguy> Rembane: If you have something specific you’re trying to do, you could ask about it.
13:59:37 <haskImp> I am trying to call C++ from Haskell via FFI. I have been able to do this successfully via `stack build`. However I cannot run `stack ghci` !! My problem is outlined here with the compiler error: http://stackoverflow.com/questions/40141042/trouble-running-stack-ghci-when-calling-c-from-haskell
13:59:37 <geekosaur> it can't inspect (and certainly can't modify) your program's data
13:59:39 <nitrix> It makes it simpler to work with though, if you sole purpose is to compile some bits of code.
13:59:41 <haskImp> Does anyone have any suggestions?
14:01:29 <Rembane> nitrix: Wow. Cool!
14:02:24 <Rembane> The specific thing I'm trying to do is to loop over all fields accessors of a datatype and get their types in a way I can pattern match on so I can create a serializer for that datatype.
14:03:33 <ongy> haskImp: have you tried making a .so? I'm not sure if ghci can load the .o file during runtime
14:03:51 <glguy> Rembane: The `binary' package uses GHC.Generics to accomplish that kind of thing. It doesn’t make use of the field names, but you can.
14:03:55 <haskImp> @ongy: How would I do that via the *.cabal file and Stack?
14:03:56 <lambdabot> Unknown command, try @list
14:04:00 <glguy> Rembane: the aeson package does, too
14:04:04 <glguy> haskImp: @ is for bot commands
14:04:15 <haskImp> sorry
14:04:17 <haskImp> ongy: How would I do that via the *.cabal file and Stack?
14:04:48 <ongy> haskImp: I don't know how to do it, sorry. It's just the first idea looking at the error
14:05:59 <jarista> Does anyone know where to find the haskell source codes, particularly for the Data.List and Data.Set libraries
14:06:11 <geekosaur> @hackage containers
14:06:12 <lambdabot> http://hackage.haskell.org/package/containers
14:06:16 <geekosaur> ^
14:07:58 <Rembane> glguy: Thank you. I'll try to make sense of how Aeson does it.
14:09:37 <geekosaur> Rembane, they use generic, but not the way you seemed to be suggesting
14:09:41 <geekosaur> *generics
14:10:19 <glguy> GHC.Generics is appropriate for making serializers and deserializers that have access to the field names
14:11:08 <acowley> haskImp: GHCi has a nifty linker you could try to use manually to see if it sheds some light on where things are breaking https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghci-8.0.1/GHCi-ObjLink.html
14:12:04 <Rembane> geekosaur, glguy: Aha, it might be so that my initial googling led me to ten year old research... hm... 
14:18:52 <sshine> @pl \x -> f . g <$> h x
14:18:52 <lambdabot> (f . g <$>) . h
14:20:00 <sshine> hmm, (fmap $ f . g) . h seems more readable, then.
14:20:21 <Tuplanolla> Try `fmap (f . g) . h`.
14:20:30 <sshine> ah, thanks.
14:26:25 <joncol> It seems my problems with tasty-quickcheck were because of orphan instance of Arbitrary typeclass. Should you always put the Arbitrary instances in the same file as where the datatype is defined?
14:27:52 <lyxia> It's not always a good solution.
14:28:26 <lyxia> The problem is that you incur a dependency on a package that may be irrelevent to your users.
14:28:45 <joncol> Exactly.. That's what's bothering me
14:28:49 <jle`> there aren't any satisfying alternatives, though
14:29:17 <jle`> keeping instances in the same module where the class or type is defined is the lesser of many evils
14:30:49 <lyxia> What about packages for orphan instances?
14:31:16 <lyxia> You write a library foo that has nothing to do with testing, and foo-quickcheck that defines Arbitrary instances for it.
14:34:25 <dmj`> {-# OPTIONS_GHC -fno-warn-orphans #-}
14:34:49 <bitemyapp> dmj`: brutal
14:35:30 <dmj`> ;)
14:35:56 <johnw> Providing instances for libraries you don't want to depend on is something of an unsolved problem. For example, I submitted a PR to add Semigroup instances for pipes, but was rejected because the semigroups library is too large a dependency; and I really couldn't argue with that all...
14:36:33 <joncol> Is it common to have to run `stack clean` between runs of `stack test`. My changes don't seem to take effect until I do so for some reason!?
14:36:47 <kadoban> joncol: No
14:36:49 <johnw>  I wonder if part of what that means is: if you're going to provide a library that offers a generally useful type class, try to keep its dependencies to an absolute minimum
14:37:19 <joncol> kadoban: Worrying...
14:37:20 * lyxia looks at lens.
14:38:48 <glguy> johnw: unfortunately that's generally not possible because libraries also won't pick up a small dependency either
14:39:06 <glguy> and you end up with even fewer instances
14:39:20 <johnw> yes, that's true too
14:42:18 <kadoban> joncol: Do you have all of your modules listed in either exposed-modules or other-modules in the .cabal file maybe? Can't remember what particular problems that can cause if you don't.
14:44:22 <lyxia> And that's why if neither the library defining the datatype or the one defining the typeclass will provide an instance, the only way left is creating an orphan package.
14:44:44 <joncol> kadoban: Yes I do...
14:46:21 <ongy> I feel like it should be possible to have code only compile if a dependency is instllaed, and then have cabal (or stack) know about the optional dependency and recompile the module/package when appropriate
14:48:33 <jle`> there's that packback project that ezyang is working on
14:48:36 <joncol> kadoban: I put a .tar.gz of my repo if you'd like to take a look.
14:48:42 <joncol> at http://jcodev.eu/repo.tar.gz
14:49:02 <Squarism> anyone want to help me verify a websocket connection? i have a demo in 30 minutes that is quite important to me
14:49:14 <Squarism> takes max 30 secs
14:49:51 <joncol> stack test should fail, but changing line 108 of `src/Semi.hs` to mempty = BoolConj True should cause stack test to succeed, but it doesn't until stack clean.
14:50:07 <sbrg> Squarism: what do you need?
14:50:25 <kadoban> joncol: What verison of stack are you running?
14:50:40 <joncol> 1.2.0
14:51:12 <joncol> lts-7.4
14:51:14 <Squarism> sbrg, i tried to msg you but got autoignore
14:51:30 <Squarism> sbrg, dont wanna post url in channel.. just want 1 connector
14:51:42 <sbrg> Squarism: should work now
14:53:39 <glguy> joncol: If you run ‘stack build’ before ‘stack test’ does it work?
14:54:22 <joncol> glguy: No, that doesn't work
15:02:58 * hackagebot wolf 0.2.9 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.9 (markfine)
15:03:00 * hackagebot x86-64bit 0.4.4 - Runtime code generation for x86 64 bit machine code  https://hackage.haskell.org/package/x86-64bit-0.4.4 (PeterDivianszky)
15:25:06 <jle`> it's still weird using Type as the kind of kinds
15:25:17 <jle`> very disconcerting
15:25:57 <jle`> maybe i should alias type Kind = Type
15:26:02 <jle`> just for self-documentation
15:26:20 <jle`> (k :: Kind) ...
15:38:07 <isovector> jle`: it hurts my brain that kinds even have kinds
15:44:11 <Zemyla> Okay, question.
15:44:14 <madidier> I remember at some point the "kind" of kinds was called sorts
15:44:32 <madidier> You can go arbitrarily high in this hierarchy
15:44:34 <geekosaur> yes, that's gone now
15:44:42 <geekosaur> in ghc at least
15:45:21 <jle`> i just wanted to specify "hey, this type avriable is supposed to be a kind", but all i can say is that it is :: Type
15:45:44 <jle`> well, if i have TypeInType on, that is
15:45:55 <Zemyla> @let newtype Req c a = Req { runReq :: c => a }; instance Functor (Req c) where fmap f (Req a) = Req (f a)
15:45:58 <lambdabot>  Defined.
15:46:17 <Zemyla> @let instance Applicative (Req c) where { pure = Req; Req f <*> Req a = Req (f a) }
15:46:19 <lambdabot>  .L.hs:179:16: error:
15:46:19 <isovector> jle`: curious what you're working on. my coworker and i thought we might be the only people using TypeInType :)
15:46:19 <lambdabot>      • Couldn't match type ‘a’ with ‘c => a’
15:46:19 <lambdabot>        ‘a’ is a rigid type variable bound by
15:46:24 <Zemyla> And yet...
15:46:44 <jle`> isovector: sometimes i just turn TypeInType so i can use 'Type' instead of *
15:46:45 <Zemyla> @let instance Applicative (Req c) where { pure a = Req a; Req f <*> Req a = Req (f a) }
15:46:47 <lambdabot>  Defined.
15:46:55 <jle`> er wait, is TypeInType even needed for that?
15:47:01 <Zemyla> Why is it that I can do pure a = Req a, but not pure = Req?
15:47:22 <jle`> :t Req
15:47:24 <lambdabot> (c => a) -> Req c a
15:47:38 <jle`> :t pure
15:47:40 <lambdabot> Applicative f => a -> f a
15:47:52 <Tuplanolla> Sometimes I dream of a language where you can import evaluation models and type systems just like modules, but actually Haskell is kind of headed that way.
15:48:02 <isovector> Zemyla: presumably you need it to pull that constraint into scope
15:48:17 <jle`> :t pure `asTypeOf` Req
15:48:20 <lambdabot> error:
15:48:20 <lambdabot>     • Occurs check: cannot construct the infinite type: a ~ c => a
15:48:20 <lambdabot>       Expected type: a -> Req c a
15:49:18 <Zemyla> :t \a -> Req a
15:49:19 <lambdabot> error:
15:49:20 <lambdabot>     • Couldn't match expected type ‘a’ with actual type ‘t’
15:49:20 <lambdabot>         ‘a’ is untouchable
15:49:48 <Zemyla> @let pReq :: a -> Req c a; pReq = \a -> Req a
15:49:50 <lambdabot>  Defined.
15:49:59 <Zemyla> So f isn't always equal to \a -> f a.
15:57:38 <dmj`> lpaste ;_;
16:00:20 <Eduard_Munteanu> Has there been any progress on https://wiki.haskell.org/GHC/QualifiedModuleExport ?
16:06:06 <Forlorn> Hi, what library do you recommend for plotting simple graphs like f(x) = x^2?
16:07:50 <sbrg> there is chart
16:10:19 <Forlorn> sbrg, thanks
16:10:54 <Forlorn> exactly what I want
16:10:55 <Forlorn> :)
16:24:41 <simony> hm, say one wants to contribute to open source + haskell ecosystem in some way, any good places to look for things to do & start?
16:27:25 <ReinH> simony: The issues list for packages you use, for one
16:27:40 <ReinH> Documentation improvements are always welcome and highly valuable.
16:29:53 <Tuplanolla> For open source in general, see if you would like to package or maintain some of these packages, simony: http://wnpp.debian.net/
16:30:24 <SrPx> What exactly makes a type system consistent? If I get a small implementation of CoC (say, "Simpler Easier") and try refactoring it further, how can I know what can be removed without making the system inconsistent?
16:31:03 <SrPx> simplifying it further*
16:33:29 <Eduard_Munteanu> SrPx, it's usually adding things which makes it inconsistent
16:34:00 <Eduard_Munteanu> And you can't really know it's inconsistent until you prove false in it.
16:36:29 <SrPx> Eduard_Munteanu: this is all very confusing to me; I want a simple typed core like that one, but there are many things there that "look" redundant. For example, "Pi" and "Lam" are almost identical. "eval/infer" could be merged in a single function without much effort
16:37:07 <SrPx> So I made those changes and it *looks* like it doesn't affect the algorithm, but how do I know if I didn't "break" anything? 
16:37:40 <ReinH> SrPx: I guess it depends on what you mean by "consistent".
16:37:54 <acowley> Progress and preservation!
16:38:12 <Tuplanolla> The bigger risk is not being able to do anything useful with the system anymore, SrPx.
16:38:19 <ReinH> acowley: Yes, that's what I assumed, but I am learning to make fewer assumptions when answering questions.
16:39:55 <Forlorn> any how to keep the x-axis on zero in haskell chart?
16:40:07 <Forlorn> http://sprunge.us/OQBe
16:40:56 <SrPx> ReinH: and I have no idea what "consistent" means. What I do know, though, is that I'd like to have the simplest core language that is flexible enough to write useful programs and dependently typed witchcraft 
16:41:13 <ReinH> SrPx: if you don't know what "consistent" means, how can you know if anything is consistent?
16:42:44 <SrPx> ReinH: in the same way I explored the untyped λ-calculus and learned a lot about functional programming that way (algorithms, adts, etc), I'd like to explore an equivalent to it, but with dependent types, so I can learn more about those
16:42:49 <geekosaur> SrPx, with respect to type systems consistent means you can't create an illegal type (equivalently, if you map the type system to logic, you can't prove false)
16:42:49 <SrPx> the issue is that it is easy to implement the λ-calculus, there isn't much room to get it wrong
16:43:20 <SrPx> geekosaur: ah
16:43:47 <ReinH> geekosaur: What is an "illegal type"?
16:43:52 <hpc> a bit more precisely, you can't create a value of a type with no inhabitants
16:43:53 <SrPx> so pretty much anything I do to restrict the scope of a function and call it a type system is an acceptable type system? it just won't be one that maps to logic specifically
16:44:28 <ReinH> hpc: Yes, one way to check is to see if there is a bottom value
16:44:28 <SrPx> but isn't a type with no inhabitants defined by one you can't create a value of?
16:44:35 <ReinH> (Haskell's type system is thus inconsistent)
16:44:46 <hpc> the correspondence between type systems and logic is that types are propositions, and values are proofs of those propisitions/types
16:45:02 <hpc> so if you make an "unprovable" type like Void, and then use undefined :: Void
16:45:13 <hpc> that's assuming false
16:45:14 <geekosaur> in some sense it will map to logic, though. it may just not be a logic you'd use for something :) (Curry-Howard correspondence)
16:45:32 <hpc> er, proving false
16:45:42 <hpc> you can assume false just fine, via (Void ->)
16:45:51 <hpc> and then you can never apply it, so those proofs are totally fine
16:46:13 <ReinH> I think consistency coincides with triviality here.
16:46:33 <ReinH> e.g., every type is inhabited is a statement that the type system is trivial
16:46:39 <geekosaur> ohai, Gödel :p
16:46:58 <hpc> indeed
16:47:03 <SrPx> but there are many different logic systems, right? so, when you say "this type system can be used as a foundation of math" or that "you can write mathematical proofs on that system" what exactly is the meaning of that? What is the magic property of a type system that allows you to do that?
16:47:29 <hpc> you might not normally consider a type system trivial in that way, but a logic that admits all propositions is definitely trivial
16:47:42 <hpc> (so even haskell's type system is trivial in that respect)
16:47:47 <ReinH> hpc: and by correspondence, a type system where all types are inhabaited is trivial
16:47:59 <ReinH> *inhabited
16:47:59 <Tuplanolla> Now you're talking about completeness, SrPx.
16:48:34 <hpc> SrPx: welcome to the hojillion different ways to measure the characteristics of a type system / logic :D
16:48:34 <SrPx> Tuplanolla: tell me more
16:49:02 <ReinH> I'm not sure that SrPx is talking about completeness.
16:49:24 <geekosaur> SrPx, I think the answer to "what is the magic property" is what drives developments in type theory...
16:49:31 <ReinH> The magic property of a type system that allows one to treat types and values as theorems and proofs is the Curry-Howard correspondence.
16:49:48 <geekosaur> although I am tempted to read "can be used a s afoundation of math" as "type system can represent ZFC"
16:50:15 <ReinH> We can look at the motivations for HoTT as well
16:51:32 <SrPx> Well, I thought the great attractiveness of dependent types is that you can prove much more about your programs than their shapes (i.e., this is a list, this is a tree). As I understood, dependent types somehow magically allow to express something like "the type of lists with safe prime numbers"
16:51:45 <geekosaur> it's not magic by any means
16:51:49 <SrPx> you can't do that on the λ-calculus. you can't do that on system-f. but you can do that on CoC, on Idris, on Agda.
16:51:55 <geekosaur> it's a lot of hard work
16:52:12 <hpc> dependent types expand the language of propositions
16:52:26 <geekosaur> basically, a dependent type system means your types can depend on values (such as the length of a list)... which means they must carry around proofs
16:52:43 <SrPx> I know, but the point is: somewhere on that line there is something that makes a type system "strong enough" to prove those things. What is that?
16:53:07 <SrPx> geekosaur: but there are many type systems with types that depend on values that can't carry proofs, right?
16:53:11 <hpc> it depends on the "those things"
16:53:14 <geekosaur> if you figure that out, let us know :p
16:53:24 <grantwu> Isn't there a correspondence between type systems and logics
16:53:41 <geekosaur> curry-howard was already mentioned a few times, yes
16:53:56 <hpc> grantwu: scroll up about 10 minutes ;)
16:54:28 <grantwu> No, I meant specifically that like
16:54:28 <SrPx> if you could take a look on this, btw: http://lpaste.net/283689 -- I basically took andrás's implementation and removed everything that *looked* redundant
16:54:30 <geekosaur> SrPx, I don't think so unless you are talking about dynamic typing... which basically means you have no proofs, you just crash if the condition is violated
16:55:10 <grantwu> What logic does dependent typing correspond to?
16:55:10 <geekosaur> but part of what makes type systems interesting is being able to prove instead of just hope
16:55:12 <SrPx> it certainly has types that depend on values... and it looks like it works as I thought it would, for the simple terms I tried (nats, zero, etc)... but it is so stripped down that it is probably broken in many way
16:55:18 <Tuplanolla> One kind of completeness is the ability to express the first-order theory of arithmetic (Peano axioms for natural numbers), SrPx.
16:55:23 <SrPx> that is what I want to know, what is broken? what I removed that couldn't be removed?
16:55:51 <SrPx> many ways*
16:56:23 <geekosaur> SrPx, I think you are not using "types that depend on values" the way it normally is in this context
16:56:28 <Tuplanolla> That's quite a useful definition, because natural numbers tend to pop up everywhere.
16:56:40 <SrPx> geekosaur: why not?
16:57:12 <geekosaur> an example of a type that depends on a value is a number that is only an element of some type if it is greater than 5
16:57:17 <ReinH> It depends on what you mean by "dependent types"
16:57:50 <grantwu> Oh, hrm, I found what I was looking for in Wikipedia
16:57:59 <ReinH> dependent types a la Howard and de Bruijn corresponds to predicate logic.
16:58:09 <grantwu> ^
16:58:43 <ReinH> indexed products and sums correspond to universal and existential quantification, respectively.
16:58:52 <ReinH> intuitionistic predicate logic, to be more precise
17:00:52 <ReinH> If you add an equality type and the type of natural numbers, you get something that corresponds to Heyting arithmetic
17:00:59 <ReinH> So it depends on specifically what type system you are referring to
17:03:01 * hackagebot Files 0.1.1.1 - File content extraction/rearrangement  https://hackage.haskell.org/package/Files-0.1.1.1 (steven_yhw)
17:05:43 <ReinH> The way to answer these questions about a particular type system is to do the work of proving such a correspondence with some system of logic.
17:09:12 <yulax> i have encountered a strange behaviour
17:09:25 <yulax> filter isAlpha "***The*** %quick) HaMburgerrrs£££$$$"
17:09:30 <yulax> produces
17:09:38 <yulax> "ThequickHaMburgerrrs\194\194\194"
17:09:46 <Koterpillar> > filter isAlpha "***The*** %quick) HaMburgerrrs£££$$$"
17:09:48 <lambdabot>  "ThequickHaMburgerrrs"
17:09:59 <yulax> this behaviour occurs on OpenBSD
17:10:07 <Axman6> > text "\"\194\""
17:10:09 <lambdabot>  "Â"
17:10:12 <yulax> in Ghci
17:10:23 <Koterpillar> yulax: aha, your encodings are broken
17:10:28 <Axman6> might be because your terminal isn't set up for unicode properly?
17:10:32 <Koterpillar> ^
17:11:10 <geekosaur> which behavior exactly is broken?
17:11:47 <yulax> it appears to be that the use of "£££" is what produces the "\194\194\194"
17:11:48 <geekosaur> \194 is because the Show instance doesn't assume ability to display anything outside of U+0020 .. U+007E
17:12:06 <Koterpillar> yulax: try reading them from a file
17:12:09 <yulax> when i add it to the end of a text string
17:12:46 <geekosaur> ok, that is locale. likely some things are using ISO8859 and others UTF8
17:13:30 <c_wraith> yulax: are you sure the problem isn't just that show is being called?  like, are you doing this in ghci?
17:13:59 <yulax> c_wraith: i am doing this in ghci
17:14:04 <Koterpillar> c_wraith: that's not the problem
17:14:18 <Koterpillar> c_wraith: typing pound and getting \194 is
17:14:26 <Koterpillar> > "£"
17:14:28 <lambdabot>  "\163"
17:14:39 * SrPx is confused
17:14:56 <geekosaur> terminal is in a different locale from the shell
17:15:05 <yulax> it shouldn't be displaying this at all, since i am filtering for alphabetical characters
17:15:15 <geekosaur> isAscii is unicode aware
17:15:34 <geekosaur> > isAlpha '\194
17:15:36 <geekosaur> er
17:15:37 <lambdabot>  <hint>:1:14: error:
17:15:37 <lambdabot>      unexpected end-of-file in string/character literal at end of input
17:15:38 <geekosaur> > isAlpha '\194'
17:15:41 <yulax> geekosaur: that may be it, i am using the us.dvorak keyboard layout in tty but in X i am using dvorak gb
17:15:41 <lambdabot>  True
17:15:47 <Koterpillar> > isAlpha '\163'
17:15:49 <lambdabot>  False
17:16:34 <geekosaur> so terminal is sending the wrong codepoint for the shell's locale, and ghci is using the shell's locale (and cannot know the terminal is different)
17:16:50 <yulax> weird
17:17:02 <yulax> just openbsd things
17:17:05 <geekosaur> this is often easy to cause, if locale is being set in shell dotfiles
17:17:14 <yulax> i am not sure
17:17:16 <Tuplanolla> Aren't you happy this feature exists?
17:17:42 <yulax> see, on debian, i did not get this error, even when tty was set to something completely diiferent to X
17:17:50 <geekosaur> because very few systems read shell dotfiles while setting up an X11 session so if you onluy set locale in the shell dotfiles then you will have a mismatch
17:17:59 <geekosaur> sometimes that "just works", sometimes it throws weirdness
17:18:00 <Koterpillar> I find it strange that neither 163 nor 194 is the right (UTF-8) encoding for pound
17:18:09 <geekosaur> depends on what kind of mismatch between the locales
17:18:38 <Clint> Koterpillar: why?
17:18:53 <geekosaur> 163 is the right codepoint
17:18:56 <Clint> neither would be a legal utf-8 encoding
17:19:00 <yulax> another strange behavoir was that a � symbol was randomly inserted when i scroll back throught the commands
17:19:02 <geekosaur> it's not going to be utf8 there
17:19:29 <geekosaur> unless locale is an iso8859 which will cause it to misinterpret any utf8 sent to it
17:19:37 <Koterpillar> Clint: what is it?
17:19:39 <yulax> so for instance i was actually getting 4 instances of the \194 when there were three pound signs
17:19:43 <geekosaur> > showHex 194 ""
17:19:46 <lambdabot>  "c2"
17:19:50 <parsnip0> my whole is freezes when I get close to done on `stack setup' in a Vagrant session. :(
17:20:02 <parsnip0> s/is/os/
17:20:03 <Koterpillar> it should be c2 a3
17:20:10 <geekosaur> ah, so terminal is sending utf8 but shell locale is iso8859
17:20:21 <yulax> which is \189
17:20:42 <yulax> right, so presumably i should set everything to utf8
17:21:03 <Clint> Koterpillar: i don't understand the question
17:21:29 <yulax> perhaps this is due to obsd's origins and codebase from 4,4BSD-lite
17:21:37 <yulax> and lack of major change
17:21:39 <Koterpillar> Clint: in which encoding is pound 163?
17:21:55 <geekosaur> > text "\163"
17:21:58 <lambdabot>  £
17:22:03 <geekosaur> *codepoint* not encoding
17:22:23 <Clint> Koterpillar: ISO-8859-1 and ISO-8859-15
17:22:30 <Koterpillar> ah, OK, question answered
17:22:37 <Koterpillar> thanks Clint and geekosaur
17:22:48 <Koterpillar> :t text
17:22:50 <lambdabot> String -> Doc
17:22:57 <geekosaur> but note that the codepoints (NOT ENCODINGS) for U+0080 .. U+00FF are the same as ISO8859-15
17:23:28 <geekosaur> which is confusing until you get used to keeping codepoints and encodings separate
17:24:08 <Koterpillar> Now I see that I did know that (you have to encode everything >128) but didn't apply the knowledge
17:26:09 <yulax> thanks everyone!
17:26:10 <EvanR> how about codepages
17:26:15 <EvanR> how do those work
17:26:37 <yulax> admittedly, i only installed openbsd today
17:26:56 <EvanR> Koterpillar: you have to encode everything <= 128 as well
17:26:57 <yulax> there is all sorts of unfamiliar stuff for me
17:27:00 <geekosaur> "poorly"
17:27:15 <geekosaur> generally there is some file in /etc you can set the locale in to have it apply globally
17:27:21 <Koterpillar> s/encode/mangle/
17:27:24 <geekosaur> instead of shell dotfiles, which can cause this
17:27:24 <EvanR> really even that is sloppy
17:27:35 <EvanR> 128 isnt whats being encoded, characters are being encoded
17:27:42 <EvanR> 128 is the result
17:27:48 <geekosaur> as for codepages, they are a translation table living inside some device (a terminal window counts as a "device")
17:28:59 <EvanR> in haskell we like types, so text and encodings are a great place where that clears up all the nonsense of equating numbers and characters
17:29:19 <geekosaur> I don't recall how they worked before NT; as of NT they map Unicode codepoints to an output encoding appropriate for the device.
17:29:33 <EvanR> codepages are based on unicode?
17:29:42 <geekosaur> these days, yes
17:29:47 <EvanR> whoa
17:29:57 <geekosaur> in older Windows they weren't, but I don't recall details
17:30:11 <EvanR> i guess you need codepagepages to specify that
17:30:11 <geekosaur> Windows NT and its successors are fully Unicode internally
17:30:45 <geekosaur> but terminal windows still default to an 8-bit codepage (850 I think? may still be 437)
17:31:20 <geekosaur> "chcp 65501" maps the internal UTF16 to UTF8
17:31:29 <c_wraith> Is that also true in Japanese versions of windows?  I seem to recall that the Japanese tended to prefer a character set that wasn't a subset of unicode about 10 years back.
17:31:46 <geekosaur> the defaults wil lbe different for national versions of Windows, yes
17:31:59 <EvanR> ah not a map from unicode to something, but from some space of unicode "encododons" to something
17:32:24 <EvanR> i knew MS had to muck it up
17:32:30 <geekosaur> enh
17:32:53 <geekosaur> other systems that do the same thing: Java, and our own Data.Text
17:33:15 <EvanR> true, until they retrofit Text's internals as UTF8
17:33:23 <geekosaur> oh are they finally doing that?
17:33:33 <geekosaur> the evaluation was only done last decade >.>
17:33:37 <EvanR> no, the blog post on it was like "yep, sounds great. itll probably never happen"
17:33:58 <geekosaur> yes, that
17:34:49 <geekosaur> c_wraith, and what you are probably thinking of is BIG5 encoding
17:35:11 <c_wraith> That's the one
17:37:40 <kadoban> Isn't big5 traditional chinese or something?
17:38:04 <Koterpillar> it is
17:38:25 <geekosaur> there's enough overlap in ideographs that it gets used for both
17:38:38 <geekosaur> then there's another encoding used for Hangul
17:39:32 <geekosaur> mostly because they make the most common glyphs single bytes, whereas various Unicode encodings tend to use much more space for them
17:39:48 <kadoban> I thought japan's old encoding was shift jjs or something
17:39:50 <Koterpillar> there's not enough single bytes for hangeul
17:40:07 <geekosaur> yes, that is why I said "most common"
17:40:12 <kadoban> Ah
17:40:39 <geekosaur> they went for an optimized encoding that saves as much space as possible rather than forcing every character to be 2 bytes, or maybe 3 or 4 as UTF8 encoding would get you
17:40:56 <geekosaur> (or worse for the non-BMP part of the CJK range)
17:41:37 <EvanR> hrm not worse than 4
17:42:01 <geekosaur> just be glad you don't have to deal with this on a regular basis. it'll make you prematurely old and haggard >.>
17:42:18 <kadoban> Haha, yeah text encodings are terrible
17:42:35 * geekosaur doesn't have to deal with this regularly. just often enough to need to be aware of this stuff
17:42:54 <Koterpillar> > "한"
17:42:56 <lambdabot>  "\54620"
17:43:03 <geekosaur> generally when trying to decipher mojibake
17:43:44 <c_wraith> Remember that guy asking for help decoding some old format a while back, and we (I think it was geekosaur specifically) finally realized the format defined text was EDCDIC format?
17:43:45 <EvanR> yeah utf8 only goes up to 4 bytes
17:43:58 <EvanR> semimiraculously
17:44:10 <hpc> see also https://en.wikipedia.org/wiki/Bush_hid_the_facts
17:44:31 <geekosaur> hm, thought it could go to 6. ... oh right, they decided unicode will never get that big and removed those encodings
17:44:38 <geekosaur> (famous last words)
17:45:06 <c_wraith> UTF-8 is trivially extensible to any size of input.  They capped the unicode range so they could say "It'll never go over 4!"
17:45:13 <EvanR> unicode, the biggest waste of space ever? (except for ipv6)
17:45:25 <EvanR> s/?/!/
17:45:32 <kadoban> I thought there just weren't enough codepoints yet to make it need more than 4 ... though I'm not bothering to look that up, that's just what my impression was.
17:45:44 <EvanR> there arent, "and never will be"
17:45:47 <geekosaur> only if you use utf32 for everything...
17:46:24 <pikhq> No, it's more that UTF-16's design is very much restricted to a hard max of 0x10ffff, and to make things not crazy, all the other UTFs are artificially restricted similarly.
17:46:28 <EvanR> two characters per double
17:46:51 <EvanR> i take it back, Double is the biggest waste of space
17:47:07 <geekosaur> long double
17:47:20 <c_wraith> EvanR: what about 64-bit pointers in programs that never will allocate gigs of ram?
17:47:29 <geekosaur> 80 bits but at least some ABIs use 128 bits to represent it
17:47:42 <EvanR> this is haskell, i didnt know there were programs that dont allocate gigs of ram
17:47:49 <Clint> zing
17:47:49 <kadoban> c_wraith: At least pointers are rarely written to disk for long-term storage.
17:48:04 <c_wraith> Intel's choice to support 80 bits in hardware was weird.  Why 80?
17:48:21 <kadoban> 80 bit floating point you mean?
17:48:24 <c_wraith> yeah
17:48:32 <EvanR> 128 would surely be an insane amount of precision
17:48:47 <geekosaur> iirc that was the minimum needed to account for rounding errors so that the external 64 bit format would be mostly stable?
17:48:52 <EvanR> and wires take up space
17:49:28 <c_wraith> But didn't that mean that technically they weren't IEEE754-compatible?
17:49:48 <c_wraith> The extra internal precision led to different results than you'd get.
17:49:57 <c_wraith> (With 64-bit computation, that is)
17:50:00 <EvanR> is that true
17:50:34 <EvanR> ieee754 is beaten over out heads so often i would be surprised if it werent even followed
17:50:35 <geekosaur> yes, and various compilers used to have a flag to force strict IEEE
17:50:42 <capisce> also you get different results if you store intermediate results to memory or if you keep them in registers
17:50:47 <c_wraith> I know I still don't trust computers on different architectures to get the same result for a sequence of floating point operations.
17:50:58 <geekosaur> but everyone wanted the excess precision, so these days it's default and I think even gcc got rid of the strict ieee flag
17:51:24 <SrPx> So, I have a question... take this term: "natOrBool = (λ c : bool . λ t : c Star nat bool . t)". This typechecks: "natOrBool true c3". This typechecks: "natOrBool false true". This doesn't: "natOrBool false c3". So, basically, this term receives a Bool and returns either a function "Nat -> Nat" or a function "Bool -> Bool" depending on the received value
17:51:33 <EvanR> can we have a witness computation and two computers which gets different answers?
17:51:38 <geekosaur> (-f[no-]excess-precision in fact, iirc)
17:51:39 <SrPx> geekosaur: isn't this an example of a dependent type? I'm pretty sure you can't do that in haskell 98
17:52:16 <c_wraith> This is why I'm highly suspicious of network games that use floating-point in their core simulations.
17:52:35 <EvanR> c_wraith: or send floats over the internet!
17:52:47 <geekosaur> that is dependent, yes.
17:52:53 <kadoban> c_wraith: Do those typically rely on floating point giving the exact same results on multiple machines?
17:53:13 <EvanR> yes, when youre trying to do a bisimulation without communicating
17:53:17 <c_wraith> kadoban: some do.  Usually the ones that haven't considered the problem.
17:53:30 <c_wraith> kadoban: others know there are potential problems and architect around them.
17:53:56 <kadoban> Hmm
17:54:14 <EvanR> starcraft and similar games already checked for the simulations diverging (for other reasons) so floating point probably wasnt a show stopper
17:54:19 <geekosaur> SrPx, so as I mentioned earlier, you can define type systems which don't make you prove such things, they just aren't very interesting because you generally use a type system to try to verify your program before running it. if you don't provide some kind of proof, you can't verify at compile time that it typechecks
17:54:53 <c_wraith> There was an article on gamasutra talking about network desyncs in..  Stacraft, maybe, iirc?  Anyway, it went into a lot of detail about how certain floating point values couldn't just be sent around, because different computers would calculate them differently.
17:55:25 <kadoban> That sounds quite interesting/terrible
17:55:31 <geekosaur> yes, yes it is
17:55:59 <c_wraith> Not that it was the only source of desyncs, but it was a trickier one, because it leads to non-deterministic results from code that *looks* like it should be deterministic.
17:56:26 <EvanR> deterministic isnt the word that comes to mind when i see C++ code
17:57:03 <EvanR> the operational semantics consist of a map from compilers to results
17:57:08 <EvanR> compilers and flags
17:57:43 <EvanR> in the future when games are written in FRP, the desync issue will be interesting ;)
17:57:51 <geekosaur> SrPx, you can actually define a type system so that the compiler can build the proofs itself... but as this is difficult, sticking to the subset that it can figure out proofs for itself tends to result in a type system too weak to use
17:58:15 <SrPx> geekosaur: that sounds cool
17:58:16 <c_wraith> I mean, it looks more deterministic than code that explicitly requests a random number in the middle of it. :)
17:58:45 <SrPx> anyway, how do I know if that thing I implemented is a type system and if it is good? that is what I don't get...
18:00:41 <EvanR> Sigma[x : Thing] isATypeSystem(x)
18:01:53 <geekosaur> SrPx, that's not really answerable. lots of things can be type systems. whether they are "good" depends on whether they accomplish what they were designed to do.
18:02:24 <c_wraith> I claim Haskell's type system is pretty good for a programming language, even though it's terrible as a logic.
18:02:43 <c_wraith> :t fix
18:02:45 <lambdabot> (a -> a) -> a
18:02:52 <c_wraith> That's not so great to have in your logic.
18:03:03 * hackagebot sqlite-simple-errors 0.6.0.0 - Wrapper around errors from sqlite-simple  https://hackage.haskell.org/package/sqlite-simple-errors-0.6.0.0 (jmc41493)
18:03:13 <SrPx> geekosaur: what I want to accomplish is a type system on which I can define types for λ encodings, and on which I can define dependent types so I can learn more about those. that is all
18:03:30 <SrPx> I'm just looking for the simplest system with those 2 things and I wonder if that one I posted qualifies
18:03:31 <geekosaur> yes, and undefined wrecks the type system as a logic. this does not mean it's a bad type system.
18:04:11 <SrPx> a simple question, why the term (λ x . x x) (λ x . x x) having a type implies the system is inconsistent? How do you jump from that to "all types are inhabited"? 
18:04:31 <EvanR> SrPx: rather than start with arbitrary lambda calculus (which is not well typed, free of bottoms) and try to put a type system on it, you could just start over from scratch and build up the language from well typed primitives
18:04:53 <EvanR> correct by construction
18:05:45 <geekosaur> IIRC the specific problem there is that the type of x has to be the same as the type of x x
18:06:06 <geekosaur> which is kinda difficult
18:06:17 <EvanR> everything in ULC has the same type anyway
18:06:35 <c_wraith> SrPx: If that has type (a -> a) -> a, and you have (\ x . x) with type (a -> a), then you kind of automatically have a term with type a, for all a
18:07:35 <EvanR> in other news: http://blog.tweag.io/posts/2016-10-17-inline-java.html
18:08:00 <EvanR> [java| { javax.swing.JOptionPane.showMessageDialog(null, $message); return 0; } |]
18:09:18 <c_wraith> :t fix id -- SrPx
18:09:20 <lambdabot> a
18:12:35 <jle`> EvanR: what hath haskeller wrought
18:12:51 <SrPx> c_wraith: oh
18:13:05 <geekosaur> well, if the type system wasn't inconsistent before... :p
18:14:13 <EvanR> in that blog post they mention a "performance improvement" where closed expressions in a let "can be" lifted to the top level as a CAF
18:14:22 <EvanR> is that real?
18:14:35 <EvanR> didnt know ghc did that
18:15:19 <geekosaur> yes, ghc can do that
18:15:31 <grantwu> https://www.microsoft.com/en-us/research/publication/let-floating-moving-bindings-to-give-faster-programs/
18:15:43 <c_wraith> that's the oft-maligned full laziness transform. 
18:16:08 <c_wraith> it can result in asymptotic speed-up.. or slowdown
18:16:30 <EvanR> ive been relying on that NOT happening to make sure i lose an infinite list
18:16:44 <c_wraith> yeah, that's the slowdown case. 
18:17:09 <c_wraith> you might need to disable full laziness in the module that's in. 
18:17:15 <EvanR> o_O
18:17:33 <EvanR> so its on by default?
18:17:46 <c_wraith> when optimizations are, anyway. 
18:17:52 <EvanR> oh geez
18:18:23 <c_wraith> but it doesn't always fire. sometimes it recognizes it will make things worse. 
18:20:35 <geekosaur> "-ffull-laziness	Turn on full laziness (floating bindings outwards). Implied by O."
18:20:39 <EvanR> i was just thinking today about how optimizations have a hypocratic oath to do no performance harming
18:20:54 <geekosaur> every optimization is a tradeoff of some kind
18:21:08 <geekosaur> and, different use cases have different definitions of harm
18:21:30 <jle`> even switching from an O(n^2) to O(n) algo might make things worse
18:21:31 <geekosaur> are you optimizing for time? for size? for some interaction between them?
18:21:39 <jle`> "worse"
18:21:44 <EvanR> but like, if it cant tell whether an expression has an infinite value
18:22:05 <EvanR> seems like the ethical thing is to do nothing
18:23:56 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html#ghc-flag--ffull-laziness
18:26:19 <EvanR> so main = do{ let xs = [1..]; forM_ xs (\n -> print n); }
18:26:41 <EvanR> will exhaust all memory with this flag
18:26:43 <EvanR> or might
18:30:01 <Zemyla> EvanR: Wouldn't forM_ [1..] (\n -> print n) produce better code if it did list fusion?
18:31:12 <EvanR> theyre supposed to be equivalent
18:31:26 <EvanR> but i guess lets have an influence on performance
18:31:59 <EvanR> i daresay unbounded memory growth with nothing to show for it isnt just inefficient but somehow wrong
18:36:18 <SrPx> I think a better question is: by taking the simply easier system and unifying Lam and Pi as the same constructor (which I think is the biggest difference to my system) is that new system fundamentally different?
18:36:48 <SrPx> because Pi and Lam work exactly the same in all cases, except for minor differences, which you can just pick one
18:38:01 <SrPx> also, I'm used to think intuitively that the system on simpler easier == the calculus of constructions == pretty much the same of what you have on Idris, Agda, except for primitive types... is that wrong?
18:40:29 <John[Lisbeth]> I am reconsidering going back to haskell from lisp.
18:40:47 <John[Lisbeth]> Because haskell is pretty much as good as lisp and has its own advantages and is fairly popular
18:41:22 <jle`> they are very different languages :)
18:41:40 <John[Lisbeth]> Sure but you can modify the language to do whatever you want in the end.
18:41:43 <John[Lisbeth]> and people do
18:42:00 <John[Lisbeth]> and it's a pleasure to do it in haskell compared to say bash
18:42:10 <EvanR> template haskell exists... but really, is macroing really something people want to do on a regular basis?
18:42:23 <John[Lisbeth]> Is haskell macro free?
18:42:34 <EvanR> template haskell generates code at compile time
18:42:55 <grantwu> Template Haskell isn't technically part of Haskell, right?
18:43:24 <jmcarthur> Macros are just an easy way to get some language features when it's not clear how to add them in a more principled way.
18:43:25 <EvanR> we also have quasi quoters
18:43:37 <jmcarthur> Macros are quite useful in that sense.
18:43:40 <SrPx> Am I wrong in thinking that the only use for templates is to cover a lack of expressivity on the language? If Haskell had first class datatypes then most of the uses of TH could be just plain functions, no?
18:43:53 <glguy> Use of Template Haskell doesn't masquerade as normal code, so you don't have the normal trouble with macros making it impossible to reason about a program without knowing all of the possible macros
18:43:55 <jmcarthur> SrPx: You're not wrong.
18:44:09 <jmcarthur> SrPx: But I wouldn't say that means template haskell is bad or even a sign of something bad.
18:44:18 <SrPx> no, didn't mean that
18:44:23 <jmcarthur> Just making sure. :)
18:44:39 <EvanR> i questioned why macros existed and werent just functions
18:44:43 <John[Lisbeth]> I notice this language is much more in flux than say common lisp or scheme, and the channel can't always agree on how things should work
18:44:53 <EvanR> but the answer is the existence of two phases of compilation / runtime
18:44:58 <EvanR> with different semantics
18:45:10 <EvanR> which is also why "first class datatypes" might not make sense
18:45:18 <EvanR> (with only 1 phase)
18:45:50 <jmcarthur> John[Lisbeth]: I think it's just that ML languages are a bit "hotter" in terms of recent developments, so there's a lot to talk about.
18:46:09 <SrPx> EvanR not sure I agree, theoretically if you could construct any function generically from datatype definitions then what expressive power templates add?
18:46:22 <EvanR> they are able to operate before compilation
18:46:57 <jmcarthur> SrPx: The phase distinction is still a pretty big deal. For example, I have used TH to generate lookup tables that are just built into the executable.
18:47:00 <SrPx> EvanR okay so you could get away with templates and add a "expand" primitive which would inline all function calls in compile time...?
18:47:35 <EvanR> run regular code prior to compilation too?
18:47:38 <jmcarthur> SrPx: Perhaps I want the generated code to depend on some data from the environment.
18:48:05 <jmcarthur> SrPx: Maybe I want to just query a database to generate code from a schema, for example.
18:48:23 <jmcarthur> SrPx: (Not that such a thing is always a good idea, but sometimes it might be.)
18:48:50 <EvanR> another way to look at it is, what does a first class data type mean when types dont exist during runtime
18:49:25 <SrPx> I'm not very familiar with defining template haskell, how exactly does it work? Do you build a string? An AST representation of a haskell program? or what?
18:49:32 <SrPx> (I've only used it from libs)
18:49:33 <EvanR> its an AST 
18:50:45 <SrPx> jmcarthur: just wondering, if that is possible, wouldn't that be a security issue? Could a lib execute arbitrary IOcode on my machine when I compile a haskell program?
18:51:21 <EvanR> yep!
18:52:06 <glguy> SrPx: If the package was malicious it could also do bad things at runtime; you have to trust it either way.
18:52:38 <EvanR> well, you dont have to trust C code in the same way, if you trust the compiler
18:52:57 <jmcarthur> I do consider this a big deal.
18:53:10 <jmcarthur> But, really, we run code we haven't inspected all the time anyway.
18:53:17 <jmcarthur> Which is also a big deal.
18:53:36 <EvanR> most of the code was written by edwardk, so we just have to trust him
18:54:58 <dolio> Pff, big mistake.
18:55:54 <EvanR> true, you might be able to embed a virus that looks like abstract categorical nonsense
18:55:58 <SrPx> ah that is quite a shame, with all the purity haskell has it wouldn't be hard to guarantee that malicious code couldn't be executed at all (both in runtime and compile time)
18:56:04 <SrPx> not that it is a problem in practice .... but yea
18:56:20 <EvanR> you could enable "safe haskell"
19:03:04 <Zemyla> Okay, I had a strange thought.
19:03:44 <SrPx> Zemyla: we like strange thoughts
19:03:56 <Zemyla> I was working on making a fingertree for a specific purpose, and I was kind of worried that I would, for instance, put elements in out of order.
19:04:20 <Zemyla> And the type system wouldn't catch it, because both elements are of the same type.
19:04:44 <Zemyla> But then I realized there is a way for the type system to ensure everything stays in the same order.
19:06:04 <Zemyla> I could, for instance, define the Node structure as data Node v p a b where { Node2 :: v -> p a x -> p x b -> Node v p a b; Node3 :: v -> p a x -> p x y -> p y b -> Node v p a b }
19:07:12 <Zemyla> And similarly with Digits, and Seqs.
19:08:22 <Zemyla> So you literally can't put things out of order.
19:09:16 <EvanR> and if a and b are the same type?
19:09:46 <EvanR> ok, your internal code cant assume that, so cant mix it up
19:09:47 <glguy> Zemyla: that sort of type indexed finger tree comes up in the Reflection without Remorse paper
19:11:04 <Zemyla> EvanR: Precisely. I don't know how to keep the Monoid from possibly being produced out of order, though.
19:12:40 <glguy> Zemyla: https://hackage.haskell.org/package/type-aligned-0.9.6/docs/Data-TASequence.html
19:12:56 <Cale> Zemyla: for that, you'll need dependent types
19:12:59 <Zemyla> But yeah, for a normal Seq, it eventually becomes newtype Const2 a x y = Const2 a; newtype Seq a = Seq (forall x y. TSeq Int (Const2 a) x y)
19:19:01 <Zemyla> glguy: It doesn't have the attached monoid which allows splitting.
19:19:22 <VikingofRock> Hey so I'm trying to build a library which depends on symengine on OSX, but I keep getting linker errors. I'm like 90% sure symengine is install correctly, and /usr/local/lib/libsymengine.dylib exists.
19:19:27 <VikingofRock> Here's the linker error: http://pastebin.com/raw/yFJk7mQW
19:19:31 <VikingofRock> any ideas?
19:19:42 <VikingofRock> I'm new to dynamic linking in Haskell
19:20:43 <glguy> Zemyla: I don't understand what Monoids have to do with splitting
19:21:23 <Zemyla> glguy: Each node and Seq of a Fingertree can have a value attached, and automatically combined with mappend.
19:21:57 <Zemyla> For Seq, that value is an Int, and it gives it the O(log n) index and splitAt functions.
19:22:41 <glguy> OK, I didn't realize you were talking about the measure on the fingertree package
19:22:56 <Zemyla> Yeah.
19:23:48 <Axman6> VikingofRock: you probably need to specify --extra-lib-dirs=/usr/local/lib when calling cabal/stack/whatever
19:27:58 <zyhn> does instance (Random a, Random b) => Random (a,b) and similar conveniences exist anywhere?
19:30:12 <VikingofRock> Axman6: Okay I am trying with `stack ghci --ghci-options " -L/usr/local/lib -lstdc++ -lgmpxx -lgmp -lsymengine" --extra-lib-dirs=/usr/local/lib` and I'm getting the same error
19:31:05 <glguy> VikingofRock: Did you check that libsymengine.dylib exports the symbol in question?
19:32:54 <VikingofRock> glguy: Yeah, `nm /usr/local/lib/libsymengine.dylib | grep heap` gives `00000000000c78e0 T _basic_free_heap` and `00000000000c78c0 T _basic_new_heap`
19:34:28 <TiltMeSenpai> hello
19:36:09 <linoge> Hi there :)
19:36:19 <glguy> VikingofRock: Have you replaced libsymengine.dylib since you compiled the Haskell library that links against it, perhaps?
19:36:34 <TiltMeSenpai> I need some help with a bit of STM stuff
19:36:39 <TiltMeSenpai> well composing STM and IO
19:37:11 <TiltMeSenpai> or a better way to do api ratelimits
19:38:15 <linoge> Once again I turn to you pleading for help :). Should I have a function F that might fail, but, should it ever complete, there is no return value, and I want to use this F in another function G and check if it failed...
19:38:25 <glguy> VikingofRock: (I'm just speculating in light of any other ideas) Does otool -L libHSsymengine-0.1.2.0-CFDO5GoFnPYANnt609mDOk-ghc8.0.1.dylib show that the version of libsymengine.dylib you expected is being used?
19:39:14 <EvanR> TiltMeSenpai: .oO( keep a table of counters for each user, increment the corresponding field when they access the api. if the user has reached their limit, deny. periodically dump the whole table and reset to zeros )
19:39:25 <ReinH> linoge: I don't understand.
19:39:32 <TiltMeSenpai> no, I need client side rate limits
19:39:36 <VikingofRock> glguy: yeah actually. How do I force stack to reinstall a package?
19:39:37 <ReinH> There is no such thing as a Haskell function without a return value.
19:39:38 <TiltMeSenpai> using haxl
19:39:41 <geekosaur> linoge, that makes no sense
19:39:43 <linoge> I've got a function with side effects that might fail
19:39:55 <geekosaur> define fail
19:39:55 <ReinH> What is the type of F?
19:39:58 <TiltMeSenpai> @linoge can't you return a bool or something?
19:39:58 <lambdabot> Unknown command, try @list
19:40:03 <TiltMeSenpai> oh
19:40:06 <TiltMeSenpai> umm awkward
19:40:13 <Koterpillar> no @ on IRC
19:40:14 <linoge> It just updates a field in a database
19:40:19 <ReinH> What is the type of F?
19:40:21 <EvanR> returning bottom kind of doesnt count as a value
19:40:48 <Zemyla> linoge: The type called "void" by languages such as C and Java is the unit type in Haskell, ().
19:41:11 <Zemyla> IO operations with no useful return value generally have the type IO ().
19:41:19 <TiltMeSenpai> linoge, you could always return Either String ()
19:41:28 <TiltMeSenpai> where the String is an error message
19:42:29 <linoge> Cool, I just feel... not quite right about it. But no matter how I model it, I can't find anything that I could use for a return value :/
19:42:32 <Zemyla> TiltMeSenpai: Honestly, it'd be better to turn the set of possible errors into an enumerated type, like data Error = IOError | DeviceNotReady | OutOfCheese | ...
19:43:01 <ReinH> linoge: what is the type of F?
19:43:12 <TiltMeSenpai> ok, so I'm writing an api wrapper for the Discord api, the api has rate limits
19:43:13 <geekosaur> if by side effect you mean IO, then the no-value is (). and you still have not defined fail
19:43:39 <TiltMeSenpai> I need to parse the response to see if I got rate limited (not a problem), then queue all subsequent requests until the limit resets
19:45:29 <Zemyla> TiltMeSenpai: You should probably have whatever Discord connection function you use create a separate thread which does all the actual communication asynchronously.
19:46:02 <linoge> ReinH: Well, I'm not quite sure :/
19:46:17 <TiltMeSenpai> Zemyla, I'm using haxl to solve that problem
19:46:32 <TiltMeSenpai> or unless
19:46:35 <geekosaur> linoge, then you need to figure out what you are doing
19:46:43 <ReinH> Then we really don't know how to answer your question.
19:47:54 <TiltMeSenpai> I could throw in an atomically and make the entire function IO instead of mixing IO and STM
19:48:02 <TiltMeSenpai> but I don't think that's the best solution
19:48:12 <ReinH> For example, we don't know if "F" is really a function. I am at least pretty sure that it isn't really named "F".
19:48:29 <TiltMeSenpai> it would be better to have the entire api check happen atomically
19:49:42 <linoge> Ok, let me give it a shot. confirmEmail :: String -> EitherT String IO (?)
19:50:43 <ReinH> @unmtl ErrorT String IO ()
19:50:43 <lambdabot> IO (Either String ())
19:50:59 <ReinH> (You probably want to use ExceptT now, which is the name given to EitherT in transformers and mtl)
19:51:23 <ReinH> String -> ExceptT String IO () would be a reasonable way to build an IO action that might fail with a String error message.
19:52:03 <joe9> Is there a foldl'M?
19:52:11 <TiltMeSenpai> but your error message is (I'm guessing) dependent on a side effect, so "String -> IO (ExceptT String ())" might be better
19:52:21 <TiltMeSenpai> bc your side effect happens either way
19:52:27 <EvanR> :t foldM
19:52:28 <ReinH> TiltMeSenpai: No, that would not be better.
19:52:29 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
19:52:32 <ReinH> That would not be a valid type.
19:52:32 <VikingofRock> glguy: so `otool -L /Users/devon/.stack/snapshots/x86_64-osx/lts-7.2/8.0.1/lib/x86_64-osx-ghc-8.0.1/symengine-0.1.2.0-CFDO5GoFnPYANnt609mDOk/libHSsymengine-0.1.2.0-CFDO5GoFnPYANnt609mDOk-ghc8.0.1.dylib` doesn't actually list the libsymengine.dylib at all
19:52:39 <TiltMeSenpai> or maybe not, idk
19:52:41 <Koterpillar> joe9: no, because you can't guarantee anything about the monad
19:53:00 <linoge> ReinH: thank you very much, and sorry for being way too unclear at first ^^.
19:53:18 <EvanR> joe9: hmm. you could bang pattern the inputs to the folding function
19:53:35 <EvanR> but that still might not help
19:54:20 <glguy> VikingofRock: That seems wrong to me (and related to why things aren't working)
19:55:02 <VikingofRock> glguy: yeah this seems like a good hint as to what could be wrong
20:01:07 <nshepperd> I suppose a foldl'M could be written
20:01:27 <nshepperd> but normally the monadic sequencing already allows you to write whatever strictness you need
20:01:29 <glguy> VikingofRock: http://hackage.haskell.org/package/symengine-0.1.2.0/symengine.cabal shows that the extra-libraries section isn't actually on the library
20:01:33 <nshepperd> with foldlM
20:02:48 <VikingofRock> glguy: I'm not sure I follow
20:04:50 <Zemyla> I have a question. Why is there no Bounded instance for Either?
20:05:14 <EvanR> er
20:05:23 <EvanR> whats the maxBound of Either Bool Int
20:05:31 <VikingofRock> glguy: Hmmm I wonder if this github issue is relevant: https://github.com/haskell/cabal/issues/2715
20:05:51 <Zemyla> instance (Bounded a, Bounded b) => Bounded (Either a b) where { minBound = Left minBound; maxBound = Right maxBound }
20:06:07 <Axman6> EvanR: surely the range would be Left minBound to Right maxBound
20:06:17 <Axman6> not sure how useful that is though
20:06:41 <EvanR> you need an ordering here to talk about a law of bounded
20:06:45 <VikingofRock> glguy: if so, the next quesiton would be, how do I manually load the dependency?
20:07:07 <Zemyla> EvanR: If it doesn't have an ordering, then can you meaningfully talk about it being bounded?
20:07:16 <EvanR> what does maxBound mean?
20:07:45 <Zemyla> What does Bounded mean on types without an Ord instance?
20:07:51 <EvanR> you need like a partial order
20:08:30 <Zemyla> EvanR: For a lot of types with partial orders, they have only either a minBound or a maxBound.
20:08:53 <nshepperd> one assumes that at least succ maxBound = ⊥
20:09:28 <EvanR> well, thats a symptom of nobody wanting to use the half bounded classes
20:09:51 <EvanR> > succ maxBound :: Int
20:09:52 <Zemyla> Sadly, you could define (Enum a, Enum b, Bounded a, Bounded b) => Enum (Either a b), if succ and pred weren't partial.
20:09:53 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
20:10:17 <Zemyla> If succ's type were (Enum a) => a -> Maybe a, then you could do that.
20:10:18 <EvanR> i dunno if Enum is supposed to imply ordering
20:10:21 <nshepperd> also, you can do (Enum a, Enum b) => Enum (Either a b)
20:10:42 <EvanR> the enumeration of the rationals cant go in order
20:11:10 <nshepperd> but then the behaviour of Bounded (Either a b) would be strange, in that [minBound..maxBound] doesn't contain maxBound
20:11:35 <Zemyla> succ (Left maxBound) = Right minBound, or it should.
20:11:52 <nshepperd> (Bounded a, Bounded b) => Enum (Either a b) works, with succ (Left x) | x == maxBound = Right minBound
20:12:10 <nshepperd> but then you also need Eq a, Eq b
20:12:24 <nshepperd> I guess the whole thing is just a can of worms
20:12:43 <EvanR> a partial ordering on the two types is pretty conservative
20:14:26 <EvanR>  Bounded may also be derived for single-constructor datatypes whose constituent types are in Bounded.
20:15:17 <EvanR> throw the whole thing out and define the Compact class
20:16:09 <Zemyla> Well, Bounded is defined for (,), with minBound = (minBound, minBound) and similarly for maxBound.
20:16:58 <Zemyla> And in things that are both Ord and Bounded, max minBound = id and min maxBound = id (modulo weird exceptions like Float and Double).
20:17:04 <EvanR> yeah so you could imagine products getting bounded by forming a 2d partially ordered space
20:18:00 <EvanR> with Either, you could place the right space above the left space
20:20:13 <EvanR> compact wouldnt capture the notion that you have 2 extrema...
20:23:36 <mckeankylej> what would you guys do if you wanted to split text based on some sub string? Would you write an alg is there a regex libaray that works on data.text? for example alg : Text -> Text -> [Text] alg "hi" "hiahi" => ["hi","a","hi"]
20:25:01 <EvanR> regex is overkill 
20:25:06 <dmj`> > Data.Text.splitOn "hi" "hiahi"
20:25:08 <lambdabot>  error:
20:25:09 <lambdabot>      Not in scope: ‘Data.Text.splitOn’
20:25:09 <lambdabot>      Perhaps you meant ‘Data.Set.split’ (imported from Data.Set)
20:25:14 <EvanR> splitOn :: Text -> Text -> [Text]
20:27:13 <mckeankylej> EvanR: awesome! The text libaray has so many functions its hard to remember them all sometimes. Yea I hate regexes.
20:28:00 <EvanR> i know right!
20:28:20 <EvanR> sorry
20:37:33 <Zemyla> EvanR: I would say use Text.Regex.Applicative, but it's not very well optimized.
20:37:46 <glguy> VikingofRock: You don't manually load it, you fix the .cabal file
20:37:48 <EvanR> to split?
20:51:46 <dmj`>                                                                                         |                                                                                         
20:51:56 <Paprikachu> hi, ghc is rejectng my pattern in a function definition
20:51:57 <Jello_Raptor> I'm trying to set up a nice little shake build system for some latex stuff I'm doing and is there a good way to get first pass dependencies for a .tex file that doesn't choke when something is missing? (often I want to know so that I can tell my system to build the file) 
20:52:01 <Paprikachu> facInvImpl n n c = c
20:52:15 <Paprikachu> says something about conflicting definitions or whatever
20:52:19 <Jello_Raptor> I'm mainly looking for directly includes of .tex files, packages, and images. 
20:52:23 <Koterpillar> Paprikachu: what does this pattern mean?
20:52:44 <Paprikachu> isn't that obvious?
20:52:49 <Koterpillar> Paprikachu: I'm guessing you wanted facInvImpl n n' c | n n' = c
20:52:49 <haasn> Paprikachu: You can't re-use a variable twice
20:52:54 <okuu> Is “retract” the same as “foldFree id” ?
20:53:15 <Koterpillar> Paprikachu: it might be, or you might be using 'n' when you mean '_'
20:53:26 <Paprikachu> i mean "the same value twice"
20:53:30 <Koterpillar> Paprikachu: sorry, facInvImpl n n' c | n == n' = c
20:53:41 <okuu> Never mind, just read the definition.
20:54:18 <geppettodivacin> Jello_Raptor: You could probably search through the .tex files for particular commands (like \usepackage) and collect the results in lists, then check through those lists to see whether they exist.
20:54:27 <geppettodivacin> That's my first thought, anyway.
20:54:59 <Jello_Raptor> yeah, I'm looking for an existing parser that makes that reasonable. Sadly hatex doesn't have a foldable instance or something nice that'll let me collect those commands up easily. 
20:55:07 <geekosaur> Paprikachu, Haskell only supports linear patterns; the usage you intend there has some nasty corner cases
20:55:14 <geekosaur> so it's not supported
20:55:36 <pavonia> What corner cases are that?
20:55:50 <haasn> (What if n and n' are functions?)
20:55:52 <joe9> I have a blocking read on a socket. But, I sometimes want the process to not block and move on. I plan on using "concurrently (read from socket) (read from a channel)" and plan to write something to the channel when I want to move on. Is there a better way of doing this? such as an MVar or TVar, etc?
20:55:57 <haasn> (What if they're infinite?)
20:56:14 <Koterpillar> haasn: I thought patterns require Eq anyway
20:56:29 <geekosaur> only for numbers
20:56:41 <jmcarthur> joe9: Try the async package. You could just cancel the Async when you don't want to wait anymore.
20:56:48 <pavonia> haasn: You'd have the same problem whith these when using (==) directly
20:56:53 <geekosaur> because the language is faking it and rewriting a pattern e.g. foo 1 = ... to foo x | x == 1 = ...
20:57:57 <EvanR> Koterpillar: luckily you can pattern match on data types you write that dont have Eq
20:58:13 <haasn> pavonia: Using (==) forces you to write an Eq instance
20:58:18 <haasn> Which must resolve these issues
20:58:42 <haasn> Although arguably you could simply desugar f n n = ... to f n tmp | n == tmp = ...
20:58:55 <haasn> Haskell simply prefers to explicit here to avoid pulling in an Eq out of nowhere
20:59:08 <EvanR> thats pretty yuck...
20:59:16 <EvanR> its possible to have non linear patterns without eq
20:59:21 <EvanR> but.
20:59:44 <joe9> jmcarthur: yes, the concurrently is from the async package. I am more confused on the channel (TQueue) or MVar to use for the "read from a channel" function
21:01:10 <jmcarthur> joe9: I mean instead of doing this write-to-channel thing, you could just cancel the Async directly.
21:01:48 <jmcarthur> joe9: async (read from socket) >>= \a -> (do stuff) >> cancel a
21:02:56 <geppettodivacin> Jello_Raptor: You should be able to fairly easily write a recursive function to parse a Latex object for the commands you're looking for.
21:03:31 <glguy> joe9: The "concurrently" approach is dangerous in that the read might succeed but get ignored
21:03:41 <joe9> jmcarthur: I could use TQueue.But, I am not sure if that is too much https://github.com/joe9/9pserver/blob/master/Network/NineP/Server.hs is my code.
21:03:48 <joe9> glguy: good point. Thanks.
21:03:52 <Jello_Raptor> geppettodivacin: yup, that's what I'm on now just checking to see if there's something I was missing. 
21:04:26 <joe9> jmcarthur: is my code. the run9pServer in line 39 runs in a different thread.
21:04:48 <joe9> jmcarthur: the receiver in line 149 is the socket read loop.
21:05:25 <joe9> jmcarthur: I want the process to process any blocked reads that might have completed while also waiting for anything from the socket.
21:05:27 <glguy> joe9: If you don't want to lose data the best way is to have a dedicated read thread that reads from the socket and writes what it reads to a TQueue (or TChan). If you want to have a timeout you can use STM's registerDelay
21:06:56 <joe9> jmcarthur: I have the list of Async values of the blocked reads. I want to process any completed blocked read or if there is a value on the socket, process it too.
21:07:18 <glguy> joe9: STM is good for waiting on many things at the same time
21:08:13 <glguy> Example reading from the network and interleaving timers, network messages, and console events:
21:08:14 <glguy> https://github.com/glguy/irc-core/blob/v2/src/Client/EventLoop.hs#L73-L79 https://github.com/glguy/irc-core/blob/v2/src/Client/Network/Async.hs#L176-L183 
21:09:52 <joe9> glguy: let me read up on atomically. Thanks for the suggestion.
21:18:04 <geppettodivacin> Jello_Raptor: Have you seen lookForCommand?
21:18:14 <geppettodivacin> It looks useful for this kind of thing.
21:44:02 <Paprikachu> http://ideone.com/Mh1qR3
21:44:09 <Paprikachu> getting a bunch of type errors here, can anyone help me?
21:44:59 <Koterpillar> :t digitToInt
21:45:01 <lambdabot> Char -> Int
21:45:09 <Koterpillar> :t fromIntegral
21:45:11 <lambdabot> (Num b, Integral a) => a -> b
21:45:19 <Koterpillar> :t (fromIntegral . digitToInt)
21:45:21 <lambdabot> Num c => Char -> c
21:45:44 <Koterpillar> :t (fromIntegral . digitToInt) :: Char -> Int
21:45:45 <lambdabot> Char -> Int
21:45:48 <Koterpillar> :t (fromIntegral . digitToInt) :: Char -> Integer
21:45:49 <lambdabot> Char -> Integer
21:45:52 <Koterpillar> ^ 
21:46:37 <Paprikachu> ok, that's pretty long
21:46:40 <Paprikachu> is there an easier way?
21:47:04 <Koterpillar> with digitToInt, you have to use fromIntegral to get an Integer
21:48:15 <Paprikachu> ok, but is there something other than digitToIn?
21:48:17 <Paprikachu> t
21:48:18 <EvanR> Paprikachu: fromInteger itself is overly long for how often you need it, so you can define a utility function fi = fromIntegral, or implement your conversion function somewhere where you can reuse it
21:48:30 <Koterpillar> Paprikachu: read?
21:48:39 <Koterpillar> > read "1234" :: Integer
21:48:42 <lambdabot>  1234
21:48:46 <EvanR> digitToInteger = fromIntegral . digitToInt
21:48:57 <Paprikachu> i think that defeats the purpose of the task
21:49:03 <EvanR> d2i = fromIntegral . digitToInt
21:49:04 <Paprikachu> conver = read
21:49:07 <Paprikachu> :D
21:49:22 <Koterpillar> Paprikachu: you can also do it manually but it won'
21:49:25 <Koterpillar> Paprikachu: you can also do it manually but it won't be shorter
21:49:26 <EvanR> this last one is both shorter and more honest since its polymorphic
21:49:49 <Paprikachu> what would be the correct type annotation
21:50:03 <Paprikachu> since you said it's polymorphic
21:50:14 <EvanR> perhaps we should have just had digitToNum :: Num a => Char -> a
21:51:27 <EvanR> :t fromIntegral . digitToInt
21:51:29 <lambdabot> Num c => Char -> c
21:51:32 <EvanR> good
21:51:52 <EvanR> (Integral actually not required)
21:54:04 <lpaste> geppettodivacin revised “No title”: “findLatexDeps.hs” at http://lpaste.net/284066
21:54:38 <VikingofRock> glguy: Hey thanks with your help earlier. It seems to be fixed if I fix the cabal file, so I'll go submit a pull request to the library fixing it
21:54:39 <geppettodivacin> Jello_Raptor: ^ I wrote a function to do that, in part because I was curious myself.
21:55:23 <Paprikachu> does foldr require the type of the initial value to be the same as the list element type?
21:55:42 <kadoban> :t foldr
21:55:44 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
21:55:44 <EvanR> no
21:55:49 <kadoban> No
21:55:59 <Paprikachu> hm, that's weird. it's not complaining that it doesn't match.
21:56:22 <geppettodivacin> It's not the same type as the list element, but it is the same type as the accumulator.
21:56:25 <Paprikachu> http://ideone.com/OMmWh5
21:56:27 <Koterpillar> because your type is a -> b -> a
21:56:42 <Koterpillar> flip it somewhere
21:57:46 <kadoban> Paprikachu: Sure it is? There's compilation errors there.
21:58:10 <Paprikachu> s/not/now
21:59:34 <kadoban> Oh
21:59:55 <kadoban> You see why?
22:00:14 <Paprikachu> i do not
22:00:34 <Paprikachu> i tried flippin the convertimpl function, different errors
22:01:25 <geppettodivacin> Paprikachu: How did you flip it?
22:01:28 <EvanR> fliping a -> b -> a would give you b -> a -> a
22:01:32 <EvanR> not a -> b -> b
22:01:33 <Paprikachu> (flip . converImpl)
22:01:57 <geppettodivacin> Try just (flip converImpl)
22:02:06 <geppettodivacin> :t flip
22:02:08 <lambdabot> (a -> b -> c) -> b -> a -> c
22:02:18 <Koterpillar> Paprikachu: since it's an assignment, also try writing out all the types and applying them in your head before checking with the interpreter
22:02:22 <kadoban> You have: foldr (someFunc :: (Integer, Integer) -> Char -> (Integer, Integer)) (Integer, Integer) xs,  but foldr :: (a -> b -> b) -> b -> [a] -> b.     So your initial value doesn't match the correct piece of the function you gave it.
22:02:45 <kadoban> You're treating it like foldr :: (b -> a -> b) -> b, but it's not.
22:03:25 <Paprikachu> ok, flip works. i realized that "." was wrong seconds after i typed it.
22:03:49 <Paprikachu> but that's also weird, because i know i tried swapping the arguments of convertImpl itself before and that didn't work
22:04:03 <kadoban> It should have
22:04:10 <kadoban> Maybe forgot to save or something?
22:04:39 <Paprikachu> http://ideone.com/qRftn4
22:04:56 <Paprikachu> oh... the type signature
22:05:00 <Paprikachu> silly me
22:05:17 <kadoban> Ah, yeah
22:05:43 <Paprikachu> now it works, thanks.
22:06:04 <Paprikachu> it actually makes a lot of sense that the initial value is the right argument when the function is called 'foldr'
22:06:31 <kadoban> I never remember which is which honestly, I pretty much guess randomly and fix it if it complains xD
22:06:44 <kadoban> That sounds like a decent mnemonic though.
22:06:58 <EvanR> i know, and the fact that foldl and foldr reversed them...
22:07:31 <geppettodivacin> Well, you can think of it as "the thing you're folding over goes on the right."
22:07:59 <EvanR> it goes first in foldr
22:08:13 <geppettodivacin> Actually, never mind, I'm tired and reading type signatures wrong.
22:08:20 <Paprikachu> oh yeah, what's up with this error: http://ideone.com/besOCi
22:08:36 <Paprikachu> that is, when i leave off the last argument in 'convert' that is also the last argument to foldr
22:08:58 <Koterpillar> that's when you need .
22:09:22 <Paprikachu> oh right :c
22:10:00 <kadoban> Paprikachu: Well it kinda tells you. You're applying 'fst' to something and saying the result is type :: String -> Integer, thus :: (String -> Integer, b0). But the actual type of foldr a b -- doesn't match that.
22:10:41 <EvanR> it says, probably cause you left off an argument, but thats what Paprikachu was trying to do, so that was probably frustrating ;
22:11:02 <Paprikachu> ^
22:14:07 <coleman> When solving euler problems I never know when to use a list comprehension or pattern matching. Is there a good rule of thumb here? There's a lot of overlap.
22:14:34 <coleman> this is how I did problem 1: `sumMultiplesOf3And5Below n = sum [x | x <- [1..999], mod x 3 == 0 || mod x 5 == 0]`
22:15:02 <kadoban> coleman: You're not actually using n, just FYI
22:15:15 <coleman> kadoban: just noticed that
22:15:25 <coleman> other than that
22:15:28 <coleman> any problems w it?
22:15:30 <kadoban> But that's fine. The other way you could do it would also be fine IMO
22:15:37 <coleman> okay
22:17:19 <kadoban> blah n = sum . filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) $ [1..n]  or whatever
22:18:47 <coleman> kadoban: that's a little cleaner
22:19:37 <kadoban> I think I like yours a tad better actually, but they're pretty close to equivalent IMO.
22:22:56 <kadoban> coleman: By the way, if n was 1 billion instead of 999, can you find a better way to solve it? (less of a programming question than a math one)
22:23:29 <coleman> kadoban: I know it's possible but I don't know how
22:24:36 <kadoban> coleman: It's quite related to the closed-form solution to sum [1..100], if that helps. (think about how to find the sum of all of the multiples of 3 from say 1 to 300, perhaps)
22:25:30 <coleman> kadoban: you could use a seive and tailor it to the ceiling of 1 billion
22:26:29 <kadoban> A sieve would work, though you can do better than that by far.
22:27:10 <coleman> i'm sure it's an easier problem than getting urxvt to forward the super key
22:33:15 <mjo_> Can't you do it analytically without much thought ?
22:34:00 <kadoban> Depends on what you know offhand I guess
22:34:28 <mjo_> Just consider the numbers in groups of 15 plus a bit left over
22:34:39 <coleman> kadoban: I was joking. it's a real problem but I'm not having a good time with urxvt rn
22:35:05 <kadoban> coleman: I didn't really understand that comment, heh.
22:35:05 <Koterpillar> clearly the answer is some quadratic function of n, take 3 values and solve for coefficients
22:35:10 <kadoban> mjo_: Hmm, yes that would work.
22:35:26 <coleman> kadoban: ha
22:39:02 <mjo_> [0..14] -> sum $ [0,3,5,6,9,10,12] = 45
22:39:25 <mjo_> [15..29] -> 45 + 7 * 15 = 150
22:39:42 <mjo_> [30..44] -> 45 + 2 * 7 * 15 = 255
22:40:07 <mjo_> and so on
22:40:55 <mjo_> so if there are k lots of 15, you get k (k + 1) / 2 * 105 + 45 * k
22:45:38 <kadoban> My answer was based on f k n, where f gives the sum of the multiples of k up to n, then it's just f 3 n + f 5 n - f 15 n. And you can use the closed-form solution to sum [1..(n `div` k)] to define f. Comes out pretty much the same really.
22:58:01 <dmwit> Koterpillar: It's a step function, so it isn't quadratic.
22:59:38 <dmwit> Koterpillar: Each of "sum of multiples of 3", "sum of multiples of 5", and "sum of multiples of 15" is a quadratic composed with a step function that picks the nearest multiple of whatever, but functions of that form aren't closed under addition.
23:00:26 <Paprikachu> http://ideone.com/pWmP1c
23:00:30 <Paprikachu> what am i doing wrong now?
23:02:10 <dmwit> Paprikachu: The 'where' has to come after all the guards.
23:02:15 <dmwit> err
23:02:18 <dmwit> I think?
23:03:40 <dmwit> confirmed =)
23:04:11 <Paprikachu> the | things are called guards?
23:04:47 <amalloy> well, the where has to come at the end of the pattern being matched, which means after all of its guards. but there can be more guards after that, if they are for a different pattern
23:05:41 <amalloy> and yes, guards are the boolean expressions after the | symbols
23:06:11 <Paprikachu> ok cool, seems to work
23:06:21 <Paprikachu> when is 'k' evaluated here? only when needed?
23:06:35 <dmwit> Yes, as with everything in Haskell.
23:06:54 <Paprikachu> cool, then i can actually move the 'if' into the guard as well
23:07:40 <dmwit> Yes, I think that would be a nice refactor.
23:08:18 <dmwit> One fewer repetition of `findLeftMostPrimeImpl xs n`. =)
23:25:27 <Paprikachu> given a list of elements, is there a way to 'iterate' over the sub-tail-lists
23:25:48 <Paprikachu> so for [1, 2, 3] i want [1, 2, 3], [2, 3], [3] and []
23:26:06 <Paprikachu> (empty list optional i guess)
23:26:38 <Paprikachu> i was thinking of a fold but that only gives me an element at a time
23:27:54 <EvanR> :t scanl
23:27:56 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
23:28:20 <EvanR> hmm
23:28:32 <EvanR> :t unfoldr
23:28:34 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
23:28:46 <ReinH> > tails [1..3]
23:28:49 <lambdabot>  [[1,2,3],[2,3],[3],[]]
23:29:17 <Paprikachu> oh wow.
23:29:29 <EvanR> now thats just cheating
23:29:46 <Paprikachu> ?
23:29:51 <EvanR> just kidding
23:29:55 <EvanR> @src tails
23:29:55 <lambdabot> tails []         = [[]]
23:29:56 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
23:58:51 <Zemyla> Man, Enum is a real tire fire of a typeclass.
23:58:55 <ertes> :t foldr (\x r -> foldr (\ys _ -> (x:ys) : r) [] r) [[]]
23:58:57 <lambdabot> Foldable t => t a -> [[a]]
23:59:13 <Zemyla> Half of its functions are potentially partial, with no way to make them total.
23:59:51 <Paprikachu> http://ideone.com/npuViE
23:59:59 <Paprikachu> this returns elements shorter than the given n, why?
