00:00:00 <geekosaur> ffi directly to c++ is annoyingly complex and difficult; some other languages have attempted it, with only limited success
00:00:26 <athan> cripes, thanks for the heads up
00:07:43 * hackagebot psi 0.1.1.0 - Yet another custom Prelude.  https://hackage.haskell.org/package/psi-0.1.1.0 (fractalcat)
00:07:43 * hackagebot pptable 0.1.0.1 - Pretty Print containers in a tabular format  https://hackage.haskell.org/package/pptable-0.1.0.1 (gdevanla)
00:11:14 <sed12> is anyone here? i have a question
00:11:49 <sed12> i tried in haskell-beginners but no one answered there
00:14:09 <lyxia> just ask
00:15:14 <sed12>  if i enter at ghci:  show "\11"
00:15:27 <sed12>  i get "\"\\v\""
00:15:36 <sed12> where does the v come from?
00:15:42 <athan> utf8?
00:15:55 <sed12> \11 is part of a regex
00:16:07 <athan> no it's not, pretty sure
00:16:18 <sed12> the right way would be "\"\\11\""
00:16:23 <athan> it's a 8byte encoding or something
00:16:32 <sed12> no, no, i wanna stringify a regex
00:16:49 <athan> rofl
00:17:01 <athan> maybe escape the \?
00:17:13 <athan> show "\\11"
00:17:28 <athan> > show "\\11"
00:17:30 <lambdabot>  "\"\\\\11\""
00:17:38 <srhb> > text "\\11"
00:17:40 <lambdabot>  \11
00:18:00 <athan> shwat, where's text defined?
00:18:01 <sed12> yes but that would change the regex
00:18:26 <srhb> athan: I think it's lambdabot specifit. The point is that you certainly don't want to use show on it _again_ since it's still the String instance.
00:18:31 <srhb> And it will just escape things again and again.
00:18:38 <athan> hm
00:18:47 <srhb> putStrLn "\\11" would give you the same result.
00:18:48 <athan> like putstrln?
00:18:49 <lyxia> 11 is ascii for vertical tab, which is usually denoted by \v
00:18:51 <srhb> Yes
00:18:52 <athan> ahh
00:18:59 <athan> lyxia++
00:19:07 <srhb> > chr 11
00:19:09 <lambdabot>  '\v'
00:19:09 <sed12> but i wanna stringify a regex, is it possible in haskell?
00:19:20 <athan> > lyxia & fix (. ++)
00:19:20 <srhb> sed12: You already did it.
00:19:22 <lambdabot>  <hint>:1:16: error: parse error on input ‘++’
00:19:25 <srhb> sed12: "\\11"
00:19:44 <sed12> srhb, no that was my minds output
00:19:55 <sed12> ghci output has a \v
00:20:08 <srhb> sed12: Not if you escape the backslash.
00:20:42 <sed12> so using haskell, is impossible to stringify regex without altering it, right?
00:21:00 <srhb> sed12: Any special characters in Haskell Strings will have to be scaped, yes.
00:21:11 <athan> strings aren't regexes
00:21:16 <srhb> sed12: Conversely, the regex 123 can be represented by "123"
00:21:18 <athan> strings are just lists of characters
00:21:24 <srhb> Because there are no special characters in Haskell in it
00:21:37 <srhb> In Haskell Strings, I should say.
00:22:41 <sed12> whats the fastest way to learn haskell?
00:22:52 <srhb> sed12: I think it varies from person to person.
00:22:59 <srhb> sed12: I like exercises and heavy reading material
00:23:26 <sed12> how much time u needed to understand haskell?
00:23:52 <srhb> sed12: I still don't understand everything in Haskell, but I was productive after a few years of researching it on and off.
00:24:07 <sed12> and what are u using haskell for?
00:24:28 <srhb> sed12: Lots of things. Graphics, client and server side programming, ...
00:24:35 <srhb> Shell scripting.
00:24:55 <sed12> what did u do in client programming?
00:25:12 <srhb> sed12: Mostly ghcjs stuff, compiling Haskell to javascript.
00:25:38 <sed12> can haskell be used to automatize things on a desktop?
00:25:48 <ongy> yes
00:26:06 <sed12> what can u automatize on a desktop these days?
00:26:13 <sed12> i use linux
00:26:23 <sed12> and systemd
00:26:32 <ongy> depending on what you want to automate and which hooks you have it may be a bit more tedious (since you have to FFI some hooks) but it is possible
00:27:00 <sed12> ongy, give me some examples
00:27:15 <srhb> sed12: Personally, I've hooked my window manager into the xkb library to control keyboard layout by window.
00:27:28 <ongy> really depends on what you want to do. I don't think it's a good idea to automate for the sake of automation. I prefer automating what I do often
00:27:43 <sed12> ongy, im looking for ideas
00:28:01 <sed12> if i find them useful ill seek to implement them
00:28:16 <sed12> but i dont wanna build a replacement for systemd for example
00:28:51 <ongy> most Ideas I have I try to do myself, so I don't have spare ones.
00:29:04 <sed12> lol
00:31:36 <sed12> what were your first haskell resources used and appreciated?
00:31:58 <srhb> sed12: cis194 is pretty neat.
00:33:00 <sed12> is it downloadable? i cant find a link
00:33:20 <sed12> i found a few books but im not too happy
00:34:37 <sed12> theres a highly appreciated book "crafted haskell" but its written in 2008 and a new haskell was released in 2010
00:35:48 <sed12> i found somewhere that if u wanna learn fp you must start with scheme
00:36:05 <ReinH> Nah
00:36:17 <sed12> but scheme interpreters arent as comfortable as ghci
00:36:26 <ReinH> Hutton's new book is great
00:40:35 <Hijiri> sed12: https://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
00:40:41 <Hijiri> oh
00:40:45 <Hijiri> wait
00:40:51 <Hijiri> ok, I thought I pinged the wrong person
01:00:20 <athan> how would you tail -f a file in pure haskell?
01:00:33 <athan> Right now, I can only think of a polling mechanism
01:00:45 <sbrg> I would probably use one of the streaming libraries like pipes or conduit
01:00:47 <sbrg> (I'd use conduit)
01:00:48 <athan> where I'd loop over hGetLine with a timeout
01:01:16 <athan> sbrg: Well, aren't those pull-based anyway?
01:01:26 <ewsfgwet> im trying to right a function that does xor on binary. I found xor in Data.Bits but it doesnt seem to work, so i wrote my own function.
01:01:26 <athan> I'd really like to subscribe to changes
01:01:26 <ewsfgwet> xor' (x:xs) (y:ys) = if x == y then "0" ++ xor' xs ys else "1" ++ xor' xs ys
01:01:35 <sbrg> aah yeah
01:01:36 <ewsfgwet> but it doesnt work in all cases
01:01:39 <sbrg> well, what about inotify?
01:01:59 <athan> hrm :s
01:02:08 <sbrg> ewsfgwet: why doesn't it seem to work? I've actually been using xor from Data.Bits the past couple of days and it works fine
01:02:11 <sbrg> > xor 1 1 
01:02:13 <lambdabot>  0
01:02:15 <athan> dang :) thanks sbrg
01:02:36 <grantwu> :t xor
01:02:38 <lambdabot> Bits a => a -> a -> a
01:02:40 <athan> ewsfgwet: I don't think it would work on strings though
01:02:52 <athan> > "asdf" `xor` "fghj"
01:02:54 <lambdabot>  error:
01:02:54 <lambdabot>      • No instance for (Bits [Char]) arising from a use of ‘xor’
01:02:54 <lambdabot>      • In the expression: "asdf" `xor` "fghj"
01:02:56 <athan> oh
01:03:09 <athan> > zipWith xor "asdf" "fghj"
01:03:12 <sbrg> > zipWith xor "asdf" "fhgj"
01:03:12 <lambdabot>  error:
01:03:12 <lambdabot>      • No instance for (Bits Char) arising from a use of ‘xor’
01:03:12 <lambdabot>      • In the first argument of ‘zipWith’, namely ‘xor’
01:03:14 <lambdabot>  error:
01:03:14 <lambdabot>      • No instance for (Bits Char) arising from a use of ‘xor’
01:03:14 <lambdabot>      • In the first argument of ‘zipWith’, namely ‘xor’
01:03:19 <athan> heh
01:03:32 <sbrg> huh
01:03:43 <sbrg> ah.  
01:04:03 <ewsfgwet> sbrg: 1100 `xor` 1000
01:04:13 <ewsfgwet> returns 1956
01:04:15 <sbrg> ewsfgwet: that's in base 10, though, you know
01:04:15 <athan> > zipWith (xor <$> ord <*> ord) "asdf" "fghj"
01:04:17 <lambdabot>  error:
01:04:17 <lambdabot>      • Couldn't match type ‘Int’ with ‘Char -> c’
01:04:17 <lambdabot>        Expected type: Char -> Char -> c
01:04:29 * athan still doesn't know how to do that
01:04:34 <athan> wait!
01:04:38 <athan> no nevermind
01:04:43 <ewsfgwet> sbrg: how can i make it work with binary?
01:04:54 <grantwu> You can pasre the binary
01:05:05 <sbrg> ewsfgwet: well, it is working with binary. binary is just a representation. if you want to use binary literals.. well
01:05:06 <sbrg> sec
01:05:26 <sbrg> Enable BinaryLiterals 
01:05:41 <sbrg> {-# LANGUAGE BinaryLiterals #-} at the top of your file
01:05:45 <grantwu> http://stackoverflow.com/questions/5921573/convert-a-string-representing-a-binary-number-to-a-base-10-string-haskell
01:06:01 <sbrg> > xor 0b100 0b010
01:06:03 <lambdabot>  error:
01:06:03 <lambdabot>      Variable not in scope: b100 :: t0 -> t1 -> terror: Variable not in scope...
01:06:16 <sbrg> I guess lambdabot doesn't have BinaryLiterals enabled.
01:06:17 <athan> > xor 0x100 0x010
01:06:19 <lambdabot>  272
01:06:24 <athan> oh hm
01:08:21 <sbrg> > let toBin = showIntAtBase 2 intToDigit in (toBin 255, toBin 123)
01:08:24 <lambdabot>  (<[Char] -> [Char]>,<[Char] -> [Char]>)
01:08:36 <sbrg> gah
01:08:52 <sbrg> > let toBin n = showIntAtBase 2 intToDigit n "" in (toBin 255, toBin 123)
01:08:54 <lambdabot>  ("11111111","1111011")
01:09:12 <sbrg> > xor 123 255
01:09:14 <lambdabot>  132
01:09:30 <sbrg>  > let toBin n = showIntAtBase 2 intToDigit n "" in toBin 123
01:09:48 <sbrg> > let toBin n = showIntAtBase 2 intToDigit n "" in toBin 123
01:09:50 <lambdabot>  "1111011"
01:09:58 <sbrg> is lol.. 
01:10:05 <sbrg> that was supposed to be 132
01:10:10 <sbrg> at any rate, xor works just fine.
01:11:03 <athan> hinotify is perfect
01:11:10 <athan> thanks sbrg
01:16:47 <sbrg> yw
01:18:13 <ewsfgwet> thanks for the help
01:28:55 <sbrg> Anyone know if there are some problems with the stackage server? I remember seeing a thread about it being down recently and right now my download of ghc 8 is very slow and keeps hanging
01:31:18 <sbrg> seems it went through this time
01:36:47 <smorele> hi there. Can someone explain me how to translate date in Haskell ? I'd like to get french dates in a project but I do not find translations (ie: Monday -> Lundi, Tuesday -> Mardi, October -> Octobre ) Do I have to create my own function ?
01:37:50 <glguy> the Format module in the time package has a Locale parameter, have you looked at that yet?
01:38:31 <athan> so I've got a tricky problem, I'm not sure how to solve
01:38:33 <glguy> I need to go look to see what it can actually do, but surely it's related
01:38:35 <athan> it's for debouncing
01:38:44 <smorele> yep https://hackage.haskell.org/package/time-1.6.0.1/docs/src/Data.Time.Format.Locale.html#TimeLocale but no translations
01:38:56 <athan> it's something like this:
01:39:32 <athan> ref <- listen $ \event -> do {waitAsec; destroyRef}
01:39:34 <glguy> smorele: I expect you'll need to provide the translations
01:39:44 <athan> where destroyRef would remove the listener
01:40:14 <athan> but the issue is - destroyRef would somehow need to be defined after the listener is invoked
01:40:29 <athan> I was thinking about doing something with IORefs, but I'm just not sure
01:44:45 <glguy> smorele: you could write or find bindings to the libc locale procedures perhaps
01:44:48 <glguy> http://man7.org/linux/man-pages/man3/nl_langinfo.3.html
01:44:54 <sbrg> What are you trying to accomplish? 
01:45:25 <ongy> you will have to provide your own locale. I have done https://hackage.haskell.org/package/env-locale-1.0.0.1 which uses the current locale as given by evironment
01:46:19 <ongy> that should match your system language. It's not explicitly french
01:46:35 <glguy> yay, bindings found :)
01:46:57 <smorele> yep thanks for help, it would be great to map a function on a date with a local parameter which returns the correct translation
01:47:39 <glguy> sounds like you're almost there
01:48:50 <athan> Here's the best that I could come up with: http://lpaste.net/234833
01:50:38 <glguy> athan, have you considered using STM?
01:51:40 <glguy> that would handle rescheduling your loop automatically rather than using an explicit delay and explicit retry
01:52:18 <athan> glguy: I'm not sure what structure I should use :\
01:52:44 <athan> how would you write it?
01:55:04 <glguy> you could use TVar in place of your IORef
01:55:18 <athan> Damn, this loop doesn't block either
01:56:33 <glguy> I'm also not following as closely as I might normally, on phone idling while I wait to board my flight :)
01:56:36 <athan> I'm not sure glguy :\ I'm rittled with race conditions here
01:56:55 <athan> heh, thank you regardless! No way I'd be so attentive
01:57:28 <glguy> well, tvars and stm will help with your races
01:58:24 <glguy> you'll be able to atomically update multiple Tvars
02:00:43 <athan> ffs, inotify isn't even working v_v
02:02:37 <athan> hah! AllEvents was just a hoax! sweet
02:04:32 <lgstate> with stack now using ghc 8, is ghcjs easier to install via stack?
02:04:47 <athan> lgstate: I hear it's very easy now
02:05:15 <hvr> lgstate: imho it's equally easy
02:05:42 <lgstate> athan: how easy is it? can you point me at a link?
02:05:50 <lgstate> is it still downloading some tar.gz from aws?
02:06:22 <hvr> (i.e. stack is not really easier than cabal for setting up ghcjs)
02:08:10 <lgstate> athan hvr: what are current instructions for setting up ghcjs
02:08:16 <lgstate> I can just try them and know whether it's hard or easy
02:08:36 <athan> u_u
02:08:56 <athan> thou shalt not ask other people to google things for you
02:09:24 <lgstate> https://github.com/ghcjs/ghcjs <-- therea re instructinos there
02:09:27 <lgstate> but they're not stack specific
02:09:39 <lgstate> i.e. it appears to be installing globally rather than locally via stack
02:10:04 <srhb> Those are the current instructions.
02:10:17 <srhb> You can do it in some other way if you want.
02:11:48 <sbrg> i don't think it's very hard but as far as I understand it can take a while to build everything etc
02:12:11 <lgstate> yeah; those instructions broke for me on ghcjs-boot last time
02:12:24 <lgstate> and there's no reason to believe they'll work now since it's still 7.10.2 rathe4 than 8
02:12:40 <mgsloan> stack specific ghcjs instructions here https://docs.haskellstack.org/en/stable/ghcjs/
02:13:35 <athan> mgsloan in with the assist :)
02:14:26 <lgstate> mgsloan: yes, but that appears to just be pulling from aws
02:15:04 <mgsloan> lgstate: See the "community repacks" section, it has tolysz's newer tarballs
02:15:06 <athan> is there a way to get the last line of a file? Or read backwards or something?
02:15:10 <mgsloan> We should probably have that stuff up higher
02:15:58 <sbrg> athan: sure, you can read backwards. you just need to determine the size of the file and then set the file pointer to the end. 
02:16:05 <sbrg> there may be a way to just set it to the end without knowing the size.
02:16:08 <lgstate> athan: fseek
02:16:45 <athan> awesome :) thank you both!
02:16:46 <ongy> how would I read backwards?
02:17:24 <lgstate> ongy: I would just backward a block size, then read forward
02:17:31 <lgstate> I'm not sure if there is a low level posix function for 'read backwards'
02:17:49 <ongy> ok. I thought I was missing something here
02:18:28 <lgstate> ongy: unlikely, I have a hard time believing someone convinced linus to accept a kernel patch that allows filesystems to read files backwards :)
02:18:29 <athan> hseek handle SeekFromEnd 0
02:18:38 <athan> hmm
02:19:32 <athan> maybe 1, so hGetLine has something to eat
02:20:04 <lolisa> Hello, I had read philip's theorem for free. But why must 'x :: forall A, A -> A' be id?
02:20:23 <dibblego> what else could it be, even just by guessing?
02:20:43 <lgstate> the thing is that we're not given that x belongs to any typeclasses
02:20:46 <ongy> athan: 1 (or -1, I am not sure how it would be done) will position you one byte from the end of the file. So a read would give you exactly the last character (which will often be \n)
02:20:47 <lgstate> so we don't have a list of functions we can apply to x
02:20:50 <lgstate> so we can just return x
02:20:52 <lolisa> yes, but I want a formal proof, like the one given for (list a -> list a)
02:21:09 <athan> oh shoot, that's right it's not line based. Thanks ongy
02:21:39 <ongy> so you will have to make a guess how long your line will be and still do something like 'last . lines' with the read data
02:22:02 <lolisa> I know it must be id, but I am just curious in 'exactly why from formal sense' ...
02:22:09 <athan> lolisa: It's the same reason why `x :: forall A B, A -> B` can't be anything
02:22:14 <athan> er can't exist
02:27:35 <lolisa> athan, thx, you hint me... I should select A to be the relation that is true only if both argument equal a specific value
02:28:08 <athan> or every possible one :)
02:32:07 <lolisa> proved property on (A -> A -> A)! thx, think I understand parametricty better now
02:32:27 <athan> :) np
02:40:49 <mahe2> Is it correct that utf-8 bytes in a Prelude FilePath are lost and therefore unrecoverable since FilePath is just String? I'm wondering if I can use Data.Conduit.Filesystem (sourceDirectory) to produce a stream of file paths containing utf-8 chars by transforming the String to Text somehow
02:41:45 <ongy> String supports utf8. If they get lost it's somewhere further down the line
02:43:00 <glguy> utf8 is an encoding, String supports Unicode
02:43:02 <athan> does ghci automatically run with -threaded?
02:43:12 <glguy> yes
02:43:19 <athan> awesome :)
02:43:31 <athan> you were right too glguy ._.
02:43:38 <athan> TMVars I think are the best bet
02:43:52 <athan> even if I'm just using takeTMVar and swapTMVar with () to do the control flow
02:43:57 <lolisa> In what extent does parametricity extends to adt/gadt?
02:44:20 <athan> lolisa: Every one! Definitionally! :v
02:44:46 <lolisa> As a coq user, I do not accept non constructive proof :)
02:44:55 <lolisa> like, what paper should I read next?
02:45:07 <athan> nevermind ._.
02:45:07 <glguy> ._. feels like the wrong emoticon for "glguy was right" :-p
02:45:11 <athan> about the TMvar thing
02:45:16 <athan> :v
02:45:27 <athan> it looks like it's blocking indefinitely
02:46:59 <mahe2> I basically do TIO.putStrLn . T.pack (where TIO = Data.Text.IO and T = Data.Text) on a FilePath, but I'm seeing my unicode chars as "??" in ghci
02:48:12 <ongy> mahe2: if the FilePath is the problem, your file name would be messed up, not what you write
02:48:52 <athan> lolisa: What are you trying to learn?
02:49:10 <lolisa> how do parametricity extend to user-defined adt/gadt
02:50:16 <athan> what do you mean?
02:50:25 <athan> I'm not very good with coq :\
02:50:40 <athan> gadt's are like the poor man's inductive families
02:50:47 <lolisa> that's just a coq joke, forget that...
02:51:23 <athan> heh
02:51:30 <lolisa> I mean, suppose user define a skip list, or just something, can the user still use parametricity on it, just like how user use para on list
02:52:56 <athan> skip list?
02:54:18 <lolisa> or a binary tree, doesnt matter what it is, just that it is not 'preclude' in parametricity. my question is, can machine still deduct some para theorem about it?
02:56:04 <athan> oh!
02:56:11 <athan> like -XDeriveFunctor?
02:56:21 <lolisa> yes, -XDeriveTheorem
02:56:40 <athan> well, only trivial theorems I think
02:56:49 <athan> ones that aren't in the "negative position"
02:56:55 <athan> (I haven't read the paper yet)
02:57:03 <athan> theorems anologous to newtypes
02:59:10 <athan> there's also -XDeriveTraversable
03:03:47 <athan> hinotify actually isn't that great :\
03:04:39 <athan> from the looks of it, the handler you supply to the event listener is single-threaded for some reason
03:05:03 <athan> it spams me with modify events, when the file isn't modified lol
03:06:36 <ggVGc> athan: not sure what you're doing, but this might be interesting for you, http://entrproject.org/
03:06:42 <athan> This should block forever, shouldn't it? http://lpaste.net/234966
03:07:15 <athan> hmm, thank you ggVGc, just getting frustrated :\
03:09:56 <martinirungu> join #emacs
03:10:22 <athan> I'll try :x
03:11:53 <athan> ffs, I think TSem is dual to the problem I'm working with
03:12:06 <athan> the int supplied is "at most", not "at minimum"
03:12:48 <ongy> athan: can you describe what you are doing? I have semi followed it and I'm not quite sure what your goal is
03:13:20 <athan> ongy: Basically, I want to listen to these file changes
03:13:30 <athan> but the file changes _could_ be happening at a rapid rate
03:13:43 <athan> basically, I want to wait until the rate dies down past a threshold before I move on
03:13:53 <athan> (and stop listening)
03:14:16 <athan> it's a "debouncer" for file changes, in a sense
03:14:26 <athan> so at first, there will be a lot of changes happening, keeping the thread blocked
03:14:35 <athan> then, once the changes stop, the thread continues
03:14:47 <athan> blocks*
03:14:53 <athan> er sorry I was right
03:15:01 * athan hasn't slept in a few days
03:18:36 <athan> wait wtf? This _should_ block ><
03:19:42 <athan> because the TSem is never filled with signalTSem
03:29:31 <ongy> athan: I think it start's at 1, not 0. So it shouldn't block
03:30:45 <ongy> athan: you could use https://hackage.haskell.org/package/timers-updatable-0.2.0.2/docs/System-Timer-Updatable.html and update the timer if it exists. To get the reference and store the timer a MVar would help
03:31:10 <ongy> I don't know if it's a good idea, but it's the nicest I can think of right now
03:33:03 <athan> ongy: Nope :\ issuing `signalTSem` before I even listen to inotify doesn't fix a thing
03:33:42 <ongy> it shouldn't. I would asume the first waitTSem get's the semaphor, and a second waitTSem would then block.
03:35:16 <athan> woah holy crap!
03:35:27 <athan> this is like the poor man's letrec ongy haha
03:35:29 <athan> thank you!
03:36:23 <ongy> the way semaphores usually work you should be able to create it with 0 and signal it later to wake up any thread waiting on it
03:36:46 <athan> ongy: They still have a timeout it looks like
03:36:57 <athan> an exception gets thrown
03:38:06 <ongy> can you please show me your code and the error you get
03:38:08 <Guillaum> Hi there. Haskell can easilly handle paramtric polymorphism and adhoc polymorphism (using typeclass). But what when I want a mix of both: a generic implementation using parametric polymorphism for most types and an adhoc implementation for a few subtypes. I can do this in C++ templates using template specialization, but I don't find a way in Haskell.
03:39:12 <athan> "*** Exception: thread blocked indefinitely in an STM transaction"
03:39:33 <lpaste> athan pasted “No title” at http://lpaste.net/235004
03:39:41 <athan> ^ ongy
03:40:09 <athan> Guillaum: parametric poly strictly means _all_ types
03:40:18 <athan> for most types, that's what typeclasses are for :)
03:40:22 <athan> and inheritence of them
03:40:33 <ongy> I would expect that to work.
03:40:40 <athan> ongy: Right?!
03:40:45 <athan> it's very frustrating
03:41:02 <ongy> how are you testing it? Is the main thread ending?
03:41:16 <athan> with ghci
03:41:31 <athan> I can't really show the codebase for this though
03:43:19 <ongy> I would build a minimal example and try with ghci and compiled code. I have no idea if ghci complains about blocking in some way the compiled code won't
03:43:29 <xocolatl> I suck at haskell (trying to learn on my own).  what data structure would you use for a simple game like checkers?
03:43:43 <Guillaum> athan: hum. Imagine I want a function "myshow :: t -> String" which is `show` for each type except `String` where it is `id`. I can easilly write `myshow = show`, but how to handle the specific case for `String`. I can also write a typeclass, but then I'm forced to instanciate manually for every types.
03:44:20 <athan> Guillaum: I think you're trying to dynamically type that
03:44:26 <athan> because how would you pattern match?
03:44:41 <xocolatl> (or draughts for the british)
03:44:44 <athan> xocolatl: We all do! :P lists though
03:45:13 <athan> ongy: good idea v_v
03:45:18 <xocolatl> what kind of list?
03:45:34 <athan> a list of columns?
03:45:35 <xocolatl> [(x,y,player)] ?
03:45:47 <athan> [[Maybe player]]?
03:45:56 <xocolatl> ooh
03:46:05 <athan> :)
03:46:12 <athan> structure, not indexing
03:46:15 <Guillaum> athan: it can be compile time I guess... (But I don't know how ;)
03:46:24 <ongy> you could also do something like ([(Int, Int)], [(Int, Int)]) and keep a list of stone positions for each player
03:46:38 <Berra> fst, snd, trd?
03:46:50 <Berra> Naming wise I mean
03:52:22 <mahe2> ongy: You were right, it's just a problem within ghci. The resulting binary works fine
03:52:42 * hackagebot phaser 0.1.0.0 - Incremental multiple pass parser library.  https://hackage.haskell.org/package/phaser-0.1.0.0 (quick_dudley)
03:52:44 * hackagebot distributed-closure 0.3.3.0 - Serializable closures for distributed programming.  https://hackage.haskell.org/package/distributed-closure-0.3.3.0 (MathieuBoespflug)
03:52:47 <mahe2> Somehow ghci does not use my system's encoding
03:53:35 <berndl> Is it possible in Haskell to "decorate" a record type with additional fields?
03:54:59 <ongy> berndl: What are you trying to do?
03:57:04 <berndl> ongy: Say I have a record type Person with name and age fields.
03:57:22 <berndl> Now I want to expand it by adding a sex field.
03:57:32 <berndl> But I don't want to change the orginal Person type.
03:57:55 <berndl> I want a new type Person' with the same fields as Person and the additional sex field.
03:58:48 <ongy> the best I know is data Person' = Person Sex (if you have Sex as type)
03:59:19 <berndl> But I need it as a record type.
04:07:07 <athan> ongy: https://github.com/athanclark/fileneglect/blob/master/src/Mer.hs
04:07:55 <DenisL> Hi, I've just started to learn haskell. And reach the point when there is a need to talk with somebody (like with a psychotherapist) in order to blown away my fears and doubts. The issue in question is polymorphism, overloading and type classes.
04:08:43 <hpc> heh, what's giving you trouble?
04:09:43 <DenisL> does it's true that we can't overload functions without type classes. i.e. type classes is the way functions get overloaded?
04:09:47 <frostarea> DenisL: I am listening
04:10:04 <hpc> correct
04:10:05 <frostarea> DenisL: yes
04:11:31 <berndl> Is there a way to define a total function that accepts a Nat, but only if that Nat has the form Succ n for some n?
04:11:36 <DenisL> is it true that in order to function to be polymorphic it should use overloaded functions? except the cases when the function does nothing with parameter (i.e. id function or const)
04:11:58 <frostarea> DenisL: I am not sur what you mean by that?
04:12:36 <frostarea> DenisL: but I would say no: a function can be polymorphic (we say "parametrically polymorphic") without having anything to do with overloading
04:12:58 <DenisL> an example?
04:13:17 <frostarea> the confusion is that overloading can be referred to as ad-hoc polymorphism
04:13:23 <frostarea> oh sorry I missed the second part of your sentence
04:13:24 <frostarea> well
04:13:39 <frostarea> "except the cases when the function does nothing with parameter"
04:13:59 <frostarea> map : (A -> B) -> [A] -> [B] is parametrically polymorphic
04:14:10 <hpc> lower-case A and B
04:14:14 <frostarea> although you could argue it "does nothing with the parameters"
04:14:25 <frostarea> (a -> b) -> [a] -> [b], sorry
04:14:56 <ongy> athan: it's the withINotify. You are closing the notify resource and using it later.
04:15:16 <frostarea> I might be going on a tangent here, but the general idea is that if you don't force the parameters to be instances of some typeclass, you can't really do anything with them directly
04:15:34 <hpc> probably a more specific formulation of "does nothing with the parameters" is "the definition of the function is such that elements of its type can be anything"
04:15:50 <athan> ongy: ??
04:15:52 <athan> wow okay
04:16:03 <DenisL> yes. but the the map function first parameter (a->b) will be overloaded function, isn't it?
04:16:08 <ongy> athan: http://lpaste.net/235090
04:16:24 <frostarea> DenisL: no
04:16:24 <hpc> let's just look at map, since it's a pretty good example
04:16:27 <hpc> @src map
04:16:27 <lambdabot> map _ []     = []
04:16:27 <lambdabot> map f (x:xs) = f x : map f xs
04:16:50 <hpc> f is whatever you give to it
04:17:04 <hpc> the way it's being used is only in relation to other parameters
04:17:11 <hpc> and (:)
04:17:22 <hpc> so those are the things that restrict the type of what f can be
04:17:58 <hpc> it ends up being that f can be any (a -> b), with the caveat that the second parameter must also be of type [a]
04:18:41 <hpc> you can pass anything that fits that type, no matter what it is
04:18:47 <athan> what's weird to me is hinotify is single threaded ongy 
04:18:58 <hpc> it might certainly be something that's in a type class definition, for instance
04:19:03 <hpc> > map show [1,2,3]
04:19:05 <lambdabot>  ["1","2","3"]
04:19:13 <hpc> but it can also be something that's not
04:19:23 <hpc> > map (:[]) [1,2,3]
04:19:27 <lambdabot>  [[1],[2],[3]]
04:19:29 <hpc> :t show
04:19:33 <lambdabot> Show a => a -> String
04:19:35 <hpc> :t (:[])
04:19:36 <lambdabot> a -> [a]
04:20:09 <DenisL> ok. in those examples show and (:) are overloaded
04:20:17 <hpc> not quite
04:20:46 <hpc> (:) is the cons constructor for [], the singly linked list type
04:21:21 <hpc> show has a class constraint "Show a =>" in its type, which means what it does can be overloaded in some way depending on what 'a' we pick
04:21:26 <hpc> but it might not itself be overloaded
04:21:38 <hpc> in this case we know it is, because show is part of the class definition for Show
04:22:18 <hpc> the definition of show can be different for every type 'a' that satisfies the constraint
04:22:21 <hpc> which is overloading
04:22:26 <hpc> another example:
04:22:28 <hpc> :t (*2)
04:22:30 <lambdabot> Num a => a -> a
04:22:43 <hpc> this is always going to be the same thing, a function \x -> x * 2
04:22:53 <hpc> no matter what 'a' is used to meet the Num constraint
04:23:40 <hpc> but it still has some wiggle room because it uses things that are themselves part of a class definition, specifically (*) and fromInteger
04:23:55 <ongy> athan: what about that is weird? what should it do in threads?
04:24:01 <hpc> (fromInteger being used internally to turn the literal "2" into fromInteger (2 :: Integer))
04:24:21 <hpc> > (*2) (127 :: Word8)
04:24:24 <lambdabot>  254
04:24:27 <athan> ongy: I would imagine the handler to be called _for each_ modificaiton event, like an async exception
04:24:29 <hpc> er
04:25:05 <hpc> > (*2) (200 :: Word8) -- one example where with a particular type, (*) does something quite different from what you expect
04:25:07 <lambdabot>  144
04:25:21 <hpc> > (*2) (200 :: Int) -- a more normal example
04:25:23 <lambdabot>  400
04:25:28 <ongy> athan: is it not? I would asume each watch has one thread in which it then calls the handler for each event
04:25:34 <hpc> > (*2) (200 :: Double) -- slightly different
04:25:37 <lambdabot>  400.0
04:25:39 <frostarea> DenisL: Alright, let me try to explain this. On one hand you have "parametric polymorphism", the idea being that some functions can operate very generally on their arguments without caring about what they actually are. The simplest example of this is the function "id : a -> a", which takes some object of type "a" and returns it. It does not care what "a" actually is, since it does not "operate" on it. Now, sometimes those parametrically polymor
04:25:53 <frostarea> Now, sometimes, this is not enough.
04:25:53 <athan> ongy: Try the exectuable: you'll see it only prints one time, not 10
04:25:59 <joncol> Hello, I got a simple question about Stack/Cabal. As far as I know, there can only be one library per .cabal file. So what if I have created two libraries L1 and L2, and want my executable E to use these? What's a good physical structure for this? Should I create L1 and L2 each in its own separate dir, with its own .cabal file? How can I then reference them from the executable E? I don't want to publish 
04:25:59 <phaskell-1> L2 Developer Certificate of Origin - https://phabricator.haskell.org/L2
04:26:00 <phaskell-1> L1 Developer Certificate of Origin - https://phabricator.haskell.org/L1
04:26:00 <phaskell-2> L2 Developer Certificate of Origin - https://phabricator.haskell.org/L2
04:26:00 <phaskell-2> L1 Developer Certificate of Origin - https://phabricator.haskell.org/L1
04:26:05 <joncol> L1 and L2 to Hackage.
04:26:21 <ongy> athan: it was 3 for me. Also you are racing with the thread you start earlier against creation of the watch
04:26:32 <exio4> frostarea: your message was cut, "Now, sometimes those parametrically polymor" ...
04:26:42 <frostarea> exio4: ah damn
04:26:43 <athan> oh, dang good point
04:26:47 <ongy> and then there's some userspace and filesystem caches that may combine a few of the changes you think of as seperate into one
04:27:05 <frostarea> DenisL: Alright, let me try to explain this. On one hand you have "parametric polymorphism", the idea being that some functions can operate very generally on their arguments without caring about what they actually are. The simplest example of this is the function "id : a -> a", which takes some object of type "a" and returns it. It does not care what "a" actually is, since it does not "operate" on it.
04:27:14 <frostarea> Now, sometimes those parametrically polymorphic functions do care that the type "a" satisfies some properties. For example, they might want to compare objects of type "a" for equality, or for "greater than, less than". An example of such function would be "sort : (Ord a) => [a] -> [a]".
04:27:26 <frostarea> If sort had type "[a] -> [a]" it wouldn't be able to do its job, because there would be no guarantee that "a" are "comparable". The precondition "Ord a" ensures that "a" is an instance of the typeclass "Ord", which implements the functions ">", "<", etc. This does not make sort overloaded; it's still a parametrically polymorphic function.
04:27:32 <frostarea> Now, sometimes, this is not enough.
04:28:26 <frostarea> Sometimes, you want a function with the same name to be implemented on different types, not in a general way, but in a specific way. For example, you want the function "==" (which compares two things for equality) to be implemented on many different types
04:28:44 <frostarea> You want "(==) : Int -> Int", "(==) : Bool -> Bool", etc.
04:29:40 <frostarea> In this case, you need what we call "ad-hoc polymorphism", or "overloading", and which is implemented through type classes in Haskell. You define a typeclass with the function/functions you want to overload (eg. ==, or <, etc), and then you declaretypes as "instances" of that typeclass
04:30:01 <exio4> frostarea: (it's Int -> Int -> Bool :p)
04:30:13 <lpaste> athan pasted “No title” at http://lpaste.net/235128
04:30:27 <athan> ongy: Yeah you're right. I can't seem to get it to go past 1 second
04:30:55 <athan> there were 2 others, like you said - a total of 3 prints
04:31:13 <athan> therefore, the expectation should be +2 above the very first one, yet... it's not
04:34:48 <frostarea> exio4: just woke up and haven't had coffee yet haha
04:35:07 <frostarea> well, tea
04:35:34 <frostarea> DenisL: does that help?
04:36:37 <DenisL> the examples with map and (:) makes sence for me. they are polymorhic but don't use overloaded functions inside. That's what I looking for.
04:36:44 <DenisL> feel much better now. Thank you!
04:36:56 <ongy> athan: ah, it is blocking the thread. But this code will always return 1sec after the first event
04:37:01 <ongy> that's just what the code says
04:37:29 <athan> why though?
04:37:45 <ongy> look at it and think about what the first event will do.
04:37:47 <athan> did you see the new paste?
04:38:04 <ongy> ah I did not
04:38:10 <athan> the first event will increment the TVar, then  wait 1 second, then re-read the TVar
04:38:24 <athan> of which, 2 other events should have fired, causing the increment to be +2
04:38:35 <athan> which _should_ cause the equality condition to fail, but it's not
04:38:37 <ongy> forkIO the eventhandler
04:40:07 <athan> holy s**t that did it
04:40:10 <athan> thank you ongy
04:40:24 <ongy> also I think this code is still a bit racy
04:40:42 <ongy> ah, no looks ook
04:40:50 <athan> :)
04:40:54 <ongy> but I'm no compiler or debugger, so don't quote me on that :)
04:40:55 <athan> I'm going to package it
04:41:01 <athan> fileneglect is too good of a name
04:41:06 <athan> heh
04:41:11 <ongy> also: Control.Monad.when
04:41:39 <athan> oh right
04:42:48 <Will> Hey, I'm new to Haskell... getting a type error that I have been struggling with for an hour - can anyone help? http://pastebin.com/KhbkM3v3
04:44:11 <DenisL> frostarea: hpc: the map and (:) are polymorphic and dont use overloaded function in their definitions. At the same time they don't touch parameters in their definitions thy just pass them around. e.g. map just pass list values to some function. and Cons just join the value to some list.
04:44:28 <ertesx> Will: what's the type of (mapM fromRow)?
04:45:24 <frostarea> DenisL: yes
04:45:29 <ongy> Will: in line 27 you are doing 'user <- head users' which looks like the source of the problem to me
04:46:13 <ertesx> line 26 is wrong as well, and in a less trivial way (misunderstanding IO)
04:47:45 <Will> OK thanks... I am expecting users to be a list of Users 'user <- head users' to give me a single user.
04:47:57 <Will> From that code, does it appear that users should not be a list, is that what you mean?
04:48:25 <ertesx> Will: you are applying the function (mapM fromRow) to the argument (fetchUser id)…  i'll assume that by "id" you mean any arbitrary id, so let's use (fetchUser 0)
04:48:33 <ongy> no. the <- syntax desugar will make it something you don't expect. But ertesx is right. There's a more fundamental problem in line 26
04:48:50 <DenisL> but if we need to touch the parameter, that is look at it and take some decision based on the value of the parameter than we will use overloaded function for that. right?
04:49:20 <ertesx> Will: what's the type of the (mapM fromRow) function?  try to answer that
04:51:09 <ertesx> Will: BTW, "i can't" is a valid answer =)
04:51:11 <Will> (mapM fromRow) would perhaps be IO [[SqlValue]] -> [a]?
04:51:13 <Will> haha
04:51:14 <Will> :)
04:51:28 <ertesx> Will: not quite
04:51:40 <Will> IO [[SqlValue]] -> IO [a]?
04:51:45 <ertesx> mapM :: (a -> IO b) -> [a] -> IO [b]
04:52:22 <ertesx> the argument you give mapM is (fromRow :: (Object a) => [SqlValue] -> a)
04:52:44 * hackagebot avwx 0.3.0.2 - Parse aviation weather reports  https://hackage.haskell.org/package/avwx-0.3.0.2 (hc)
04:52:51 <Will> Yes...
04:53:00 <ertesx> so you're trying to unify mapM's type 'a' with fromRow's [SqlValue], which is fine
04:53:01 <Will> OK..
04:53:39 <ertesx> but you're also trying to unify fromRow's type 'a' with (IO b), where 'b' is from mapM
04:54:55 <ertesx> which makes that function have a rather weird type you probably didn't intend it to have:  mapM fromRow :: (Object (IO a)) => [[SqlValue]] -> IO [IO a]
04:55:29 <Will> Right, OK
04:55:36 <Will> I'm just going to digest that :)
04:55:53 <ertesx> now let's return to the problem ongy pointed out, which seems to be the source of all your problems in a sense =)
04:56:16 <ertesx> in a do-block when you write "x <- c", where (c :: IO A), then (x :: A)
04:56:40 <ertesx> the "<-" syntax is for naming the results of IO actions and nothing else (for now)
04:56:59 <Will> Yep
04:57:11 <ertesx> if you want to write an actual definition, you have to use 'let' instead:  let user = head users
04:57:18 <Will> Ahhhh
04:57:20 <ertesx> now 'user' and 'head users' are actually equal
04:57:21 <Will> Of course
04:57:36 <Will> because head users is not an IO action, right?
04:57:42 <ertesx> exactly
04:58:38 <ertesx> however, (fetchUser 0) *is* an IO action, so if you want to get at the [[SqlValue]] it produces, you have to use "<-"
04:59:13 <Will> Before it gets plugged into fromRow, you mean?
04:59:36 <ertesx> not quite, but yeah
04:59:47 <ertesx> at the same time fromRow's result is *not* an IO action (just a value), so it's not a valid argument to 'mapM'
04:59:56 <ertesx> you probably meant to use regular 'map' there
05:00:37 <ertesx> (well, it is a valid argument, as you saw, but it leads to a function with a rather weird type)
05:00:56 <Will> Yeah, OK
05:01:03 <Will> Thanks, it's becoming clearer
05:05:39 <mahe2> quit
05:05:55 <Will> OK perfect, it compiles and runs, ertesx.  Thanks a lot for your help
05:06:12 <ertesx> glad to help =)
05:06:38 <Toplology> Hello, does anyone know what's up with the schoolofhaskell website?
05:07:52 <ertesx> Toplology: probably something went wrong on their server…  just try again later
05:08:46 <Toplology> I guess, I just have to. Oh well...
05:10:15 <ertesx> how to kill a dying server for good: ask: "does anyone know what's wrong?"…  now you have a DDoS attack =)
05:10:50 <Toplology> haha, sorry about that
05:11:04 <ertesx> Toplology: i'm just joking =)
05:25:19 <sdrodge> I have a C++ library (w/ a C interface) that includes a few functions that take structure arguments by value, does anyone know the best practice for calling such functions from Haskell?
05:25:48 <sdrodge> Write a small shim library around it? Use some GCH primop magic? Something else entirely?
05:26:03 <sdrodge> *GHC
05:30:05 <Gloomy> Hi :) Can I ask about lambda calculus here or is there a better place ?
05:30:40 <vapid>  hi
05:30:41 <vapid> i have no idea
05:30:54 <vapid> is lambda calculus some kind of hipster math knowledge?
05:31:06 <lyxia> I think it's fine here.
05:31:19 <Gloomy> It's the basis of functional languages and especially Haskell :)
05:31:32 <vapid> oh man
05:31:37 <ongy> if it gets to long of a discussion people might tell you to move to -overflow or similar, but generally it should be fine
05:31:41 <JuanDaugherty> this is as good as any, though you might think #lisp or #scheme would be better, they aren't
05:32:03 <vapid> where can i find out more
05:32:06 <Gloomy> Anyway, if someone can help : I'm just starting out and can't find out my mistake here: http://mathb.in/89381
05:32:16 <JuanDaugherty> as implementations of igess they would be
05:34:03 <Gloomy> vapid : This is what we were suggested to follow at uni: http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf
05:34:52 <vapid> ty
05:35:20 <ertesx> Gloomy: first error i found: when you apply, the lambda abstraction should actually vanish
05:35:25 <sed12> thanks man
05:36:00 <Gloomy> ertesx Sorry, I'm still a bit struggling with terminology, where would that be ?
05:36:49 <ertesx> Gloomy: (λ n a b. a (n a b)) (λ s z. z) beta-reduces to: λ a b. a ((λ s z. z) a b)
05:37:20 <Gloomy> ertesx : Why? Where does that first n go ?
05:37:49 <ertesx> Gloomy: in haskell (\x -> x + 1) 3 beta-reduces to: 3 + 1
05:37:56 <ertesx> same thing in lambda-calculus
05:38:42 <ertesx> and remember that you are already using convenience syntax:  "λ n a n." is the same thing as "λ n. λ a. λ b."
05:39:30 <Gloomy> Hmmm yes true. Ok I see :) 
05:39:31 <Gloomy> Thank you ç
05:39:33 <Gloomy> *!
05:52:45 * hackagebot servant-auth-token 0.3.2.0 - Servant based API and server for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-0.3.2.0 (NCrashed)
05:52:47 * hackagebot fileneglect 0.0.0 - Block thread until a file stops being modified  https://hackage.haskell.org/package/fileneglect-0.0.0 (athanclark)
05:52:49 * hackagebot bit-array 0.1.2 - A bit array (aka bitset, bitmap, bit vector) API for numeric types  https://hackage.haskell.org/package/bit-array-0.1.2 (NikitaVolkov)
05:52:51 * hackagebot fileneglect 0.0.0.1 - Block thread until a file stops being modified  https://hackage.haskell.org/package/fileneglect-0.0.0.1 (athanclark)
05:52:53 * hackagebot postgresql-binary 0.9.1.1 - Encoders and decoders for the PostgreSQL's binary format  https://hackage.haskell.org/package/postgresql-binary-0.9.1.1 (NikitaVolkov)
05:57:55 * hackagebot hasql 0.19.15.2 - An efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.15.2 (NikitaVolkov)
06:18:09 <Gloomy> Another question with lambda calculus: (λz . z z); does this mean (λz.(z z)) (= function returning the function of itself) or ((λz.z) z) (identity function applied to z) ?
06:18:35 <lyxia> the former
06:18:55 <lyxia> \z. (z z)
06:19:04 <Gloomy> thank you :)
06:19:49 <ertesx> i don't think you can call 'z' a "function"
06:19:53 <ertesx> it's something weird
06:21:01 <Gloomy> Isn't everything a function in lambda calculus?
06:21:24 <ertesx> everything is something you can apply, but not necessarily a "function"
06:22:19 <ertesx> IMO to talk about "functions" (a mathematical object that maps values to values), you need types…  but (λ x. x x) has no type
06:22:57 <ertesx> (or an "infinite type", if you prefer)
06:23:58 <lyxia> Just extend the syntax of types to write isorecursive types finitely.
06:24:21 <lyxia> uh, itim equirecursive
06:25:00 <Gloomy> ertesx That's true. I see what you mean.
06:25:05 <ertesx> not sure if general recursion *should* be well-typed as a raw lambda expression
06:25:28 <ertesx> better just introduce 'fix' as a primitive
07:18:49 <the_2nd> how can I define a "where" for all pattern matches of a function?
07:19:15 <the_2nd> currently I can only define for global scope or the scope of one of the cases
07:19:39 <lyxia> nope
07:19:43 <lyxia> just use let
07:20:04 <lyxia> oh even let doesn't work for a function
07:21:54 <lyxia> the closer you can get is probably to use a case expression instead
07:23:16 <exio4> the_2nd: the workaround I use is fun1 something = go where { shared_values = something + 123; go Nothing = ... ; go (Just x) = ...; }
07:23:31 <Welkin> pattern matching is desugared to case expressions anyway
07:28:46 <NickHu> Is return = pure a result of parametricity?
07:29:16 <Welkin> what?
07:30:02 <Welkin> Applicative was recently made a requirement for Monad, and then return became redundant
07:30:11 <Welkin> because pure and return are the same thing now
07:30:22 <Welkin> well almost
07:31:15 <Welkin> like how `liftM` isn't used any more
07:31:21 <Welkin> and it is the same thing as `fmap`
07:32:23 <Tuplanolla> The real bikeshed is whether "pure" or "return" is the better name.
07:33:11 <Welkin> return is a terrible name
07:33:14 <Welkin> and always has been
07:33:38 <Welkin> it was chosen simply to fir with do-notation to make it feel more "imperative"
07:33:41 <Welkin> which was dumb to begin with
07:33:49 <Welkin> to fit with*
07:34:41 <nitrix> I hope they do not try to keep it for too long with the pretext of "backwards compatibility".
07:37:56 <sdrodge> Should be around for at least another four years, if I understand deprecation policy correctly.
07:38:44 <haasn> What's a good haskell datatype to use for efficiently storing dense (as in not sparse) subsets of the integer line? For example I might want to store [0,1000] ∪ [1500,2000]. I want to be able to efficiently test whether any given integer n is in this set or not, and I want union to be “smart” (i.e. I will grow this set often, and I want it to update existing limits where applicable, and also merge
07:38:46 <haasn> ranges where possible)
07:39:38 <Welkin> IntSet?
07:40:16 <haasn> I plan on storing millions integers overall, I don't want to have an IntSet that actually stores millions of tree elements for something that could be a small handful of ranges
07:40:30 <haasn> I suppose that's what IntSet does, though?
07:40:32 <Welkin> oh, just use a list (or array) of tuples
07:40:42 <Welkin> that each define the range
07:40:43 <haasn> I said good :p
07:40:47 <haasn> as in, not having to write it myself
07:41:29 <ggole_> Interval trees?
07:41:37 <ggole_> There's probably a library for that somewhere
07:41:40 <ertesx> haasn: there is IntervalMap
07:42:09 <ertesx> haasn: alternatively you can construct an efficient representation yourself using fingertree
07:43:18 <haasn> IntervalMap seems like a map from intervals to values
07:43:29 <ertesx> haasn: sure, just use () as the value type
07:43:50 <int-e> haasn: intset and fingertree are two other packages that you could look into
07:44:10 <haasn> But that would defeat the point; because I want overlapping intervals to get merged, whereas IntervalMap is designed to let them overlap
07:44:48 <haasn> If this is more work than 4 lines of code then it would be less work for me to change my program instead and make it so I no longer need this data structure :p
07:44:50 <int-e> (I believe the former comes closest to what you've asked, but may have bitrotted)
07:44:51 <ertesx> haasn: you need to do that yourself in both cases, but in the fingertree case you can at least build that merging into your primitive functions
07:44:52 <haasn> Just figured asking whether it would be possible
07:45:02 <haasn> (Since doing it the other way has limitations)
07:45:05 <ggVGc> are the majority of the optimizations of GHC reliant on the fact that haskell is lazy?
07:45:14 <ggVGc> It bothers me that a lot of optimizations aren't in purscript yet
07:45:28 <ggVGc> and they seem like they would be essentially the same as in haskell
07:45:56 <ertesx> ggVGc: a lot of GC-related optimisations probably are, but other than that: unlikely
07:46:00 <ertesx> sharing also relies on laziness
07:46:07 <haasn> Oh well, I'll give it up. Would be a nice-thing-to-have as a data structure, I think
07:46:08 <ertesx> but that's not really an optimisation
07:46:30 <ertesx> haasn: i think it's really straightforward to implement using fingertree, but it definitely requires more than 4 LoC =)
07:46:58 <haasn> In my case I wanted to form an “atlas” of things I've already processed (since the jobs I'm receiving may contain duplicates and be out-of-order), so I can efficiently query for whether I've already processed something and skip it
07:47:26 <ggVGc> it's annoying that purescript and haskell are so similar, but still different enough to have completely separate compilers
07:47:29 <haasn> But what I'll do instead is make sure they're always in order, so I can just record a “last ID processed” instead
07:47:35 <ggVGc> seems to me a large chunk of the compiler could be shared
07:47:40 <haasn> Won't let me skip ahead and process things out of order though :/
07:47:44 <Welkin> ggVGc: lol, that is what I said
07:47:51 <ertesx> haasn: sounds like that would require an ordered data structure, too
07:47:52 <ggVGc> Welkin: when?
07:47:53 <Welkin> ggVGc: I don't see a point in purescript, really
07:48:00 <ggVGc> Welkin: have you worked in it?
07:48:04 <Welkin> ggVGc: I said that a few times a while back
07:48:08 <ertesx> haasn: like a priority queue of some sort
07:48:11 <ggVGc> I've been doing stuff in it the past weeks, and it's quite different tbh
07:48:16 <Welkin> I have not worked with it, but I read through the guide
07:48:19 <ggVGc> the record system makes a big difference
07:48:25 <Welkin> I've been using elm
07:48:30 <ertesx> haasn: in other words: you'll do the same work, just call it differently
07:48:33 <Welkin> and started playing with ghcjs
07:48:41 <int-e> haasn: btw, by intset I meant this: https://hackage.haskell.org/package/intset-0.1.1.0 not Data.IntSet
07:49:13 <ggVGc> imo, purecript and ghcjs are not competing things. Purescript is a different language in it's own right
07:49:25 <Welkin> yes, it is
07:49:29 <Welkin> but why use it when you have ghcjs?
07:49:32 <haasn> ertesx: The way I would approach this on paper is with a binary search tree where the leaves are (sorted) disjoint ranges
07:49:35 <Welkin> and if you want something simpler, you have elm
07:49:52 <haasn> That will allow O(log n) insert, union and check, and also permit efficient merging
07:49:55 <exio4> Purescript is closer to JS than Elm, though, isn't it?
07:49:55 <ggVGc> because in many ways purescript is nicer than haskell imo
07:50:01 <Welkin> no
07:50:09 <haasn> (when updating one of the leaves, merge it with the sibling if the two touch)
07:50:25 <Welkin> ggVGc: you mean because of the extensible effects system?
07:50:29 <Welkin> because haskell has that too
07:50:31 <ggVGc> Welkin: right, that's your opinion. I'm just saying it's not a case of "why would you use X when you have Y"
07:50:49 <exio4> while Elm is more reactive-ish, purescript lets you write normal-looking JS code (I mean, the generated code!)
07:51:08 <exio4> record subtyping is a big difference
07:51:14 <ertesx> haasn: that *really* sounds like exactly the thing you would do with the fingertree approach, just manually =)
07:51:22 <ggVGc> anyway, there seems to be a lot of GHC optimizations that would be directly applicable to purescript
07:51:28 <ggVGc> wonder if I should try looking into that
07:51:29 <ertesx> haasn: as said, you'll be doing the same work, just call it differently
07:51:47 <ertesx> haasn: and in the end it will be less efficient, too
07:52:05 <haasn> I did say on paper, and on paper I have no idea what a fingertree is :)
07:52:49 * hackagebot js-jquery 3.1.1 - Obtain minified jQuery code  https://hackage.haskell.org/package/js-jquery-3.1.1 (NeilMitchell)
07:54:14 <dmj`> w/ elm you'll end up writing quite a bit of js anyways
07:54:21 <haasn> looking at the fingertree haddock I'm not sure how you'd implement insert. By going through split / append?
07:54:21 <ertesx> haasn: it's basically a sequence data structure with a monoid that collects extra info with O(log n) query
07:54:27 <ertesx> haasn: a generalised Seq
07:54:41 <dmj`> Welkin: o/
07:54:46 <ertesx> haasn: yeah, generally changes involve split/append
07:55:30 <Welkin> hi dmj` 
07:55:40 <Welkin> dmj`: yeah, I realized that
07:55:43 <ertesx> haasn: so split first, check the upper and lower bounds, then you have four cases:  1. insert new range, 2. merge with lower range, 3. merge with upper range, 4. just merge the lower with the upper range
07:55:59 <Welkin> and my previous issues with elm were not so bad once I realized I could work around the problems mostly
07:56:06 <Welkin> using the ports system and al ittle bit of ingenuity
07:56:18 <dmj`> Welkin: elm's event handler logic only lets you return pure values, so you can't call functions on dom nodes (like .focus()), or perform assignment, w/o using a 'port'
07:56:27 <Welkin> yeah
07:56:42 <Welkin> I have to use ports to execute .play() and .pause() on my audio elements
07:56:52 <Welkin> it ends up being not so bad though
07:56:59 <ertesx> haasn: looking up a value again involves splitting first, then checking the lower or upper range (depending on the split predicate)
07:57:00 <dmj`> yea but have fun testing that code
07:57:02 <Welkin> as long as I give the audio element an id to reference it by
07:57:28 <Welkin> dmj`: what do you mean?
07:57:43 <dmj`> how do you test that code
07:58:10 <haasn> Well, I'll make the project work first. Maybe I'll try the fingertree thing later :)
07:58:31 <Welkin> dmj`: I'm not sure what you mean
07:59:00 <soLucien> hi guys ! Is it possible to write this somehow ? http://lpaste.net/2521083985287708672
07:59:02 <Welkin> write a test for the elm side
07:59:07 <soLucien> line 25 is incorrect
07:59:47 <soLucien> sorry
07:59:49 <soLucien> line 30
07:59:57 <soLucien> Array [Expr]
08:00:16 <Welkin> soLucien: your type declaration is wrong
08:00:23 <soLucien> yes
08:00:27 <Welkin> type ArrayFor = (Ident, Expr, Maybe ArrayCompr)
08:00:34 <Welkin> in your pattern match, you need to match the constructor
08:00:40 <Welkin> in this case, (,,)
08:00:55 <Welkin> (ident, expr, marray)
08:01:39 <Welkin> also, you are using `fail` inside a pure function
08:03:16 <soLucien> it's the fail from the monad
08:03:22 <Welkin> what monad
08:03:23 <soLucien> shouldn't that be used ?
08:03:25 <ertesx> (it's best to avoid using 'fail' in general…  it's not part of the Monad semantics)
08:03:37 <Welkin> and no, you shuold never use `fail` anyway
08:03:44 <soLucien> what should i do instead ?
08:03:55 <soLucien> i can see some problems like this one 
08:03:57 <Lokathor> wasn't Monad Fail going to be a thing to split off fail from the main Monad definition?
08:04:05 <Lokathor> or did that never happen? or has it not happened yet?
08:04:18 <Welkin> use Either, or Except or something else
08:05:27 <ertesx> soLucien: if your monad has a failure effect, you should use Alternative (or perhaps the more expressive 'throwError' from Control.Monad.Except from mtl)
08:05:54 <soLucien> I am using Either
08:06:06 <soLucien> when a fail is received, 
08:06:11 <ertesx> then just use Left
08:06:19 <soLucien>   fail err = SubsM ( \_ -> Left (Error ("Interpreter error: " ++ err)))
08:06:28 <ertesx> Lokathor: most likely not happened yet
08:06:34 <soLucien> i'll remake the paste with the monad as well
08:07:25 <intothem1untains> Is it possible to have something like type constructor synonims?
08:08:00 <intothem1untains> of course, I could define such a synonim as a function, but I would like to use it as if it was a normal uppercased constructor
08:08:43 <soLucien> http://lpaste.net/2521083985287708672
08:09:03 <ertesx> intothem1untains: only when you can eta-reduce:  type MyEither = Either SomeException
08:09:33 <ertesx> now MyEither is a valid type constructor
08:09:46 <intothem1untains> ertesx: but that doesn't introduce a constructor synonim, right? I would still have to use Left and Right
08:10:08 <ertesx> intothem1untains: oh, you mean data constructors
08:10:13 <ertesx> there are pattern synonyms
08:10:28 <intothem1untains> ertesx: er, yes, sorry
08:10:37 <intothem1untains> pattern synonyms?
08:10:38 <ertesx> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms
08:10:39 <soLucien> so line 59 .. how can my evalArrayFor return an Array[Expr] type ?
08:10:59 <soLucien> should i match the data (Expr) definition ?
08:11:22 <ertesx> intothem1untains: like this: pattern Just2 x = Just (Just x)
08:12:34 <intothem1untains> ertesx: Oh, cheers!
08:13:05 <ertesx> intothem1untains: caveat: there was a shortcoming of the exhaustiveness checker when i last tried to use them *exhaustively*, so the compiler would warn me that my clauses aren't exhaustive…  i don't know if the problem is still there in GHC 8
08:13:38 <ertesx> like:  pattern N = False; pattern Y = True  -- now write 'not' in terms of these
08:40:03 <colo> hello, what is the easiest way to get a random element from a list
08:40:17 <Welkin> use the random package
08:40:39 <colo> i tried with System.Random
08:41:19 <Welkin> choose a raondom Int that can be used to index the list
08:41:36 <colo> but i can only get a IO Int and i dont know how to work with
08:41:49 <Welkin> use bind
08:41:52 <Welkin> or do notation
08:42:29 <dagda1> if I can use an infinite with zip to index a list zip lst [0..]
08:42:44 <dagda1> how can I make it so the index decrements starting at the list length?
08:42:54 <Welkin> get the list length
08:43:10 <dagda1> list zip lst [(length lst)..0]
08:43:14 <dagda1> does not work
08:43:15 <Welkin> then use [listLength, listLength - 1, .. 0]
08:43:23 <dagda1> Welkin ah I see
08:43:24 <Welkin> or
08:43:29 <Welkin> you can reverse the list itself
08:43:37 <dagda1> I am confused whty [4..0] returns []
08:43:49 <Welkin> > [5,4 .. 0]
08:43:53 <lambdabot>  [5,4,3,2,1,0]
08:43:58 <Welkin> > [5 .. 0]
08:44:03 <lambdabot>  []
08:44:04 <Welkin> because it doesn't have enough information
08:44:16 <Welkin> > [5, 3 .. 0]
08:44:18 <lambdabot>  [5,3,1]
08:44:25 <Welkin> you didn't specify the step
08:44:32 <Welkin> [ .. ] is just sugar
08:44:39 <Welkin> the real function is enumFromTo
08:45:04 <Welkin> and enumFromThenTo
08:45:06 <colo> Welkin: sory can you do an example of the do notation
08:45:11 <Welkin> > enumFromThenTo 5 4 0
08:45:13 <lambdabot>  [5,4,3,2,1,0]
08:45:20 <Welkin> > enumFromTo 5 0
08:45:22 <lambdabot>  []
08:46:03 <Welkin> colo: do int <- randomIOInt
08:46:20 <Welkin> or just feed it through directly using bind
08:46:26 <Welkin> randomIOInt >>= ...
08:51:05 <colo> i got this error  The last statement in a 'do' block must be an expression
08:51:13 <Welkin> yes
08:51:20 <Welkin> do
08:51:27 <Welkin>   int <- randomIOInt
08:51:37 <Welkin>   return $ somefunction int
08:51:54 <Welkin> or just use
08:52:12 <Welkin> randomIOInt >>= return . someFunction
08:52:26 <erisco> someFunction <$> randomIOInt
08:53:29 <Welkin> erisco: okay mr code golf
08:53:35 <mantovani> ÷win 6
09:06:53 <andromeda-galaxy> Okay, so, any cateory theorists here?  I've been trying to use Applicatives on arbitrary categories (subcategories of Hask, but with a different morphism type that wraps some subset of Hask's morphisms) , and it's seeming like the existing category heirarchies in subhask, hask, category-extras, etc. are not really quite nice
09:08:48 <Franciman> Hello
09:09:07 <andromeda-galaxy> also, a clarification: category-theoretically, does fmap actually map arrows, or does it map internal homs?
09:09:44 <Welkin> andromeda-galaxy: this might be better for #category-theory
09:09:51 <andromeda-galaxy> or is it sort of both, since at the value level it maps functions to functions but it's defined as an arrow between the internal hom objects, I guess?
09:10:07 <andromeda-galaxy> Welkin: oh cool, I didn't know that existed. Wouldthe questions about Haskell's category support also be good there?
09:10:24 <Welkin> probably
09:10:29 <Welkin> a lot of haskell users are there
09:10:45 <andromeda-galaxy> wait, what network is that on? #category-theory on Freenode seems to be empty and unowned
09:11:03 <Tuplanolla> Double hash, andromeda-galaxy.
09:11:17 <Franciman> I have this: data Interval = Interval { start :: Int, end :: Int } it represents an interval of numbers from start to end (extremes included)
09:11:23 <Franciman> Now, if I have a Set Interval
09:11:23 <Welkin> I meant ##categorytheory
09:11:49 <Franciman> how can I find the smallest Interval in Set that contains a given Int ?
09:12:04 <andromeda-galaxy> Welkin, Tuplanolla: cool, I'll go over there, thanks!
09:12:41 <lyxia> Franciman: Use filter and minimumBy ?
09:12:46 <Welkin> Franciman: filter and sort
09:12:53 <erisco> Franciman, filter by intervals which contain the integer, then sort by interval magnitude
09:12:56 <Welkin> Franciman: filter and sort and take 1
09:13:07 <Franciman> what is its complexity?
09:13:09 <Welkin> oh yeah, minView
09:13:09 <Franciman> filter is linear?
09:13:14 <Franciman> or logn?
09:13:19 <erisco> linear
09:13:35 <erisco> if you have a list
09:14:13 <erisco> rebuilding a set is likely to be nlogn
09:14:44 <erisco> but since it is also likely lazy, and you are ultimately only finding the smallest interval, i.e. one element, it isn't so clear what the complexity is
09:14:49 <lyxia> filtering a set is linear
09:15:37 <erisco> I don't see how that is lyxia, because if you start with n elements, filter down to m, then you build a set with m elements, and this is mlogm
09:15:39 <Franciman> erisco, I already have a set
09:16:29 <erisco> there is no relationship between the order used by the set and the filter predicate
09:16:54 <Franciman> ohh ok
09:17:00 <Franciman> while takeWhileAntitone?
09:17:09 <Franciman> it's log n
09:17:25 <lyxia> A Set represents its elements in order, filtering doesn't modify that order.
09:17:37 <Franciman> dropWhileAntitone*
09:17:46 <Franciman> I could use it to remove all useless ranges
09:17:51 <Franciman> and it's log n
09:17:51 <lyxia> http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Set.html#v:filter O(n)
09:17:52 <Franciman> ight?
09:18:00 <erisco> lyxia, ah, so there is a relationship :)
09:18:28 <lyxia> you don't even have to go through an intermediate list either
09:19:14 <lyxia> But if you do, there is fromAscList :: [a] -> Set a in linear complexity as well.
09:34:37 <ReinH> Maybe you don't want a set? Maybe you want a heap?
09:35:06 <ReinH> Even a sorted list might be better
09:36:21 <mettekou> Is there a way to expose all members in modules from the library of a Cabal project to the test suites without exposing them to users of the library?
09:36:32 <ReinH> No.
09:36:45 <hvr> mettekou: in cabal 2.0 there would be a way
09:37:05 <hvr> mettekou: via convenience library + reexported-modules
09:37:29 <NickHu> Is return always necessarily pure, or can it be something else?
09:38:22 <hvr> mettekou: but it'd require quite a bit of boilerplate
09:38:46 <amalloy> return and pure must be the same
09:39:02 <NickHu> amalloy: Why? Is it something linked to parametricity?
09:39:09 <lyxia> NickHu: it's written here http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:Monad
09:39:30 <erisco> it is "thou shalt have pure and return be one"
09:39:45 <NickHu> lyxia: That doesn't really explain why
09:39:52 <hvr> NickHu: somewhat related: https://ghc.haskell.org/trac/ghc/wiki/Proposal/MonadOfNoReturn
09:40:00 <lyxia> Any Monad is an Applicative.
09:40:06 <amalloy> there's no other way to satisfy both the monad laws and the applicative laws, i think
09:40:23 <NickHu> In Hask, yes, but is there an argument of why pure and return must be the same functions?
09:40:24 <mettekou> hvr: So I'm supposed to either export everything or test only what I export to end users?
09:40:25 <Myrl-saki> Is there a way to have a type such that `do x <- f; y <- f` is a type error?
09:40:40 <Myrl-saki> For some f.
09:40:47 <hvr> mettekou: well, one thing you can do already now is export everything via .Internal modules
09:41:02 <erisco> Myrl-saki, that is already an error because it does not return anything
09:41:07 <Zemyla> Myrl-saki: Why do you want that?
09:41:08 <lyxia> And the convention is thus that if a type implements Applicative and Monad, then the Applicative instance must be "equivalent" to the one that would be derived from the Monad.
09:41:25 <erisco> you have written  f >>= \x -> f >>= \y ->
09:41:31 <hvr> mettekou: and if your testsuite is in the same package, you can have the testsuite access those internal modules directly, so you don't even need to expose those
09:41:39 <NickHu> lyxia: Still convention, I'm looking for a more mathematical reason
09:41:51 <Myrl-saki> Zemyla: f is stateful and thus I only want a single instance of it.
09:42:10 <lyxia> NickHu: you're free to do whatever you want and deal with the consequences
09:42:14 <Zemyla> Myrl-saki: Indexed monads?
09:42:25 <erisco> Myrl-saki, stateful? it mutates? this isn't Haskell
09:42:30 <Myrl-saki> erisco: heh.
09:42:54 <mettekou> hvr: So test-suite entries get access to everything in other-modules for the library entry of a package?
09:42:57 <erisco> something something linear types, Haskell doesn't have these
09:43:02 <NickHu> lyxia: Are all monads necessarily applicative functors, in general, not just in Hask?
09:43:10 <Zemyla> Myrl-saki: https://hackage.haskell.org/package/indexed-0.1.3/docs/Control-Monad-Indexed.html
09:43:23 <Zemyla> f's type would be Something False True a.
09:43:42 <hvr> mettekou: no, the testsuite wouldn't depend on the library component; you'd have the testsuite use the modules indepedently directly
09:43:44 <Myrl-saki> Zemyla: Hmmm
09:43:55 <lyxia> NickHu: Uh, I don't know.
09:43:55 <Zemyla> And since (>>=)'s type is m i j a -> (a -> m j k b) -> m i k b, then you can't call f twice.
09:43:58 <hvr> mettekou: as if there was no 'library' component definition
09:44:19 <hvr> mettekou: the downside is that the .hs files get compiled twice, once for the library, and once for the testsuite
09:44:37 <Myrl-saki> Zemyla: I see.
09:44:50 <hvr> mettekou: the double-compilation is what can be avoided in cabal 2.0
09:45:13 <mettekou> hvr: And in which field for each test-suite entry do I need to add the internal modules?
09:45:35 <hvr> mettekou: in the testsuite's other-modules field
09:45:39 <NickHu> Why isn't `join` part of the Monad typeclass?
09:45:46 <mettekou> hvr: Oh okay, thanks.
09:45:52 <Myrl-saki> Zemyla: Wait, how does that work though.
09:45:55 <NickHu> Then surely we could have instances of monad defined by specifying `join`
09:46:01 <erisco> how is that?  f >>= const f
09:46:36 <NickHu> erisco: join x = x >>= id
09:46:42 <Myrl-saki> Zemyla: Oh. You mean >>>= ?
09:46:45 <Zemyla> Yeah.
09:46:52 <Myrl-saki> Zemyla: I see.
09:46:59 <Myrl-saki> Zemyla: So I can't use do notation.
09:47:02 <Tuplanolla> I'm not sure about your desires, but it sounds like arrows could help, Myrl-saki.
09:47:04 <erisco> NickHu, I was replying to someone else
09:47:09 <NickHu> oh
09:47:13 <Myrl-saki> Tuplanolla: I'm actually using arrows right now.
09:47:16 <erisco> NickHu, join is insufficient
09:47:20 <erisco> NickHu, to answer your question
09:47:23 <NickHu> Well, you need fmap too
09:47:28 <erisco> yes
09:47:36 <Myrl-saki> Tuplanolla: I'm working with FRP.
09:47:44 <Tuplanolla> Oh, I see.
09:47:46 <Zemyla> Myrl-saki: Use the RebindableSyntax extension.
09:47:46 <erisco> fmap is definable from return and >>= but not from return and join
09:47:58 <NickHu> But because of the current heirarchy, isn't the Functor typeclass a superclass of Monad?
09:48:24 <Zemyla> NickHu: Yes, but you might have instance Functor X where fmap = liftM
09:48:26 <NickHu> oh if you want to describe your functor instances with >>= you mean
09:48:38 <erisco> no
09:48:45 <Myrl-saki> Zemyla: Hmmm
09:48:48 <erisco> I mean if you have just return and join you cannot define fmap, nothing to do with type classes
09:48:50 <NickHu> sorry, I mean lack of >>=
09:48:57 <NickHu> Yes, I see
09:49:32 <Myrl-saki> Zemyla: I see. Thanks. I'll take that into consideration. It sounds good, but it's probably overkill for what I'm doing.
09:49:52 <erisco> for subtyping, the idea is that the subtype has the properties of the supertype, and so because return and bind can define fmap, Functor is a super type of Monad
09:50:26 <erisco> Functor is not a super type because Monad inherits the properties of Functor, it is the other way around
09:50:52 <erisco> Monad implies Functor, and so Functor is a super type of Monad
09:51:13 <Myrl-saki> Zemyla: Tuplanolla: I think I should provide more context. I'm using the wires library. I'm working with type `MonadIO m => Wire m (Event (These SDL.Keycode Event Double)) b`
09:51:28 <erisco> or, Monad refines Functor, and so Functor is a super type of Monad
09:51:39 <Welkin> but there is no super or sub anything in haskell
09:51:43 <NickHu> erisco: I see
09:51:50 <Welkin> Monad simplies requires a Functor instance as well
09:51:54 <erisco> yes there is, this is part of type classes Welkin
09:52:09 <NickHu> Welkin: He means that if you give a monad instance you can tell the compiler to cook up your functor instance for you
09:52:17 <NickHu> Because it has to exist
09:52:18 <Welkin> it could require any number of other typeclasses
09:52:31 <NickHu> Hence Monad is a subclass of Functor
09:52:46 <Myrl-saki> Tuplanolla: Zemyla: So, what I did was `do x <- f -< (); y <- g -< (); h -< align x y`. The problem here is that f and g uses liftIO and uses destructive read. So I must ensure that I can't call f and g in h.
09:52:52 * hackagebot tttool 1.6.1.3 - Working with files for the Tiptoi pen  https://hackage.haskell.org/package/tttool-1.6.1.3 (JoachimBreitner)
09:53:09 <Myrl-saki> Tuplanolla: The only thing I can think of right now is to make my own monad.
09:53:21 <Myrl-saki> Whitelisting rather than blacklisting.
09:53:25 <Welkin> that is not the right vocabulary
09:53:29 <Welkin> that is from oop
09:54:03 <erisco> saying "super type" is a bit off, since we're talking classes, so "super class" then
09:54:08 <Zemyla> Myrl-saki: As a compromise, have it be a runtime error?
09:54:23 <Myrl-saki> Zemyla: Yeah, that's also what pyon suggested to me.
09:54:31 <erisco> it is the same relation, and so it doesn't matter who invented the super and sub terminology
09:54:38 <erisco> it applies to both
09:55:46 <erisco> I am pointing out that the relationship works in the way opposite to what your intuition may be
09:55:52 <Myrl-saki> Zemyla: Err... stupid question. How would I do that?
09:55:52 <Tuplanolla> I don't know; write Coq and extract Haskell?
09:56:09 <andromeda-galaxy> Are all Haskell types proper sets?
09:56:17 <Tuplanolla> I only have bad suggestions at this point.
09:57:20 <erisco> with existential type classes you can turn classes into types
09:57:58 <hpc> andromeda-galaxy: most are algebraic data types
09:58:07 <hpc> some are abstract and don't have a good mathematical model for them
09:58:46 <hpc> "abstract" is denotationalese for "implementation-defined"
09:58:56 <andromeda-galaxy> hpc: sure, I know that - I am thinking more about the "size", and whether or there is a requirement on it. For example if I make a kind-unrestricted variable for basically the type of objects in a category
09:59:04 <andromeda-galaxy> then is it only possible to model small categories?
09:59:07 <erisco> Myrl-saki, Zemyla I am unsure about IxMonad for this purpose… how are you supposed to keep fresh indexes?
09:59:13 <hpc> ah
09:59:32 <hpc> in some sense you can, using their algebraic properties
09:59:34 <erisco> Myrl-saki, Zemyla if you use Bool, for example, then there are only 4 index pairs, and so you must run in a cycle
09:59:40 <andromeda-galaxy> e.g. in edwardk's hask package: https://github.com/ekmett/hask/blob/master/src/Hask/Category.hs, it says that all categories are locally small, so they curry the Hom-functor
09:59:41 <hpc> () is 1, Void is 0, Bool is 2, etc
09:59:46 <hpc> Either is (+), (,) is (*)
09:59:51 <hpc> a -> b is b^a
10:00:09 <Welkin> what?
10:00:10 <hpc> and that final result is the number of members of the "set"
10:00:13 <andromeda-galaxy> but I'm trying to figure out how his 'type Ob p :: i -> Constraint' could work for a proper class of objects?
10:00:40 <andromeda-galaxy> and if it can't, then wouldn't all categories modelled in haskell be small (not just locally)?
10:00:58 <hpc> ah
10:01:18 <hpc> not sure how it works out once you add in class constraints like that with ConstraintKinds
10:01:47 <andromeda-galaxy> a->b = b^a or [a,b] is another question I had actually - is it only possible to model closed categories in haskell? Because arrows are some value "between" two things, so they must have a type, which would be the internal hom
10:01:56 <andromeda-galaxy> and you have every hom-set being internal and the whole category is closed
10:02:03 <erisco> Myrl-saki, Zemyla say f :: M True False a, g :: M False True b, f >> g :: M True True b, and so f >> g >> f :: M True False a
10:02:08 <hpc> but i know a level down when you have something like Show a => (a, Bool), you can't really say anything about the size of that set other than it's 2 * some unknown thing that varies in size based on whatever Show decides to match
10:02:21 <hpc> so not sure
10:03:07 <Myrl-saki> erisco: Ah. True. Mmmm.
10:03:24 <andromeda-galaxy> hmm, interesting. Even in the case like Show a => (a, Bool) though, if a is countable then so is Show a => (a, Bool).... oh well
10:03:28 <Myrl-saki> erisco: There's also the problem that it'd be kinada nice to make g and f commutative.
10:03:44 <andromeda-galaxy> hpc: any idea about not closed categories in HS
10:03:45 <andromeda-galaxy> ?
10:04:02 <hpc> you don't really know what a can be though
10:04:30 <erisco> Myrl-saki, commutative over what?
10:04:31 <hpc> normally a would be "any haskell type", which you can reason about even if you can't give it a real number
10:04:48 <Myrl-saki> erisco: x <- f; y <- g === y <- g; x <- f
10:04:54 <hpc> but there might be finitely many Show instances or there might be some silliness with type-level lists or something that allow infinite instances
10:05:43 <hpc> it turns out there are infinite instances because you have arbitrarily nested Show a => [[[[[[...[[a]]...]]]]]]
10:05:58 <andromeda-galaxy> right, that's why I'm also still not sure, I'm not good enough with the various types of infinity to figure out what it owuld be in HS...
10:06:13 <erisco> Myrl-saki, that is nonsense because those are not well-formed expressions
10:06:20 <Myrl-saki> erisco: I guess.
10:06:23 <monochrom> you might want to distinguish between "forall a. Show a => (a, Bool)" and "exists a. Show a *> (a, Bool)"
10:06:34 <erisco> Myrl-saki, as I said earlier you have written  f >>= \x -> g >>= \y ->
10:07:21 <Myrl-saki> erisco: Yes.
10:07:51 <Myrl-saki> erisco: x <- f; y <- g; return (x,y) === y <- g; x <- f; return (x, y)
10:07:53 <Myrl-saki> erisco: better?
10:10:23 <erisco> perhaps more generally just  do x <- f; y <- g; h x y ≡ do y <- g; x <- f; h x y  and is an interesting property
10:10:34 <hpc> andromeda-galaxy: this is probably a really hacky trick but perhaps assuming every valid haskell type has a finite serialized representation you can safely say there's countably infinite possible haskell types
10:11:36 <Tuplanolla> Why not finite by that reasoning, hpc?
10:12:24 <hpc> because the serial representation can be of arbitrary size as long as it's not actually infinite
10:12:31 <hpc> there's always a bigger type, so to speak
10:15:47 <erisco> I think it holds for Maybe, but not []
10:17:12 <hpc> erisco: that's the extra property of commutative monads
10:17:17 <hpc> which is useful for some mtl things
10:17:24 <erisco> what is being commuted?
10:17:43 <hpc> f and g
10:17:45 <andromeda-galaxy> hpc: hmm, interesting. that's a good point
10:17:52 <erisco> more than that, so are the bindings
10:18:26 <hpc> you can reformulate it with (>=>) to be more obvious
10:18:51 <andromeda-galaxy> but now I'm trying to be rigorous about my CT constructions and am running into the immovable wall of Hask's not actually being a category, so when I try to make my Category class have machine-checked laws everything dies (and it just feels wrong to pretend that Hask actually is a category)
10:18:57 <erisco> what is the formulation with >=> ?
10:19:41 <andromeda-galaxy> hpc, et al: do you know of a language that has the categoryish structure of haskell but as an actual category with operational semantics to back up its being a category
10:19:44 <andromeda-galaxy> ?
10:19:49 <hpc> erisco: er, i am derp
10:20:11 <andromeda-galaxy> or maybe Haskell + only Liquid-verified-to-terimanate programs would do it? although the `seq undefined` and `(undefined, undefined)` problems are still there...
10:20:55 <hpc> ah, here we go: https://wiki.haskell.org/Monad#Commutative_monads
10:21:01 <erisco> I can squint and see how you might call it commutativity, but it seems like a stretch
10:21:10 <hpc> you do seem to just have to squint
10:21:24 <erisco> what about "interchange"
10:22:01 <erisco> reorderable? *shrug*
10:22:28 <hpc> i bet it looks more like commutativity in CT
10:25:39 <andromeda-galaxy> hpc: except that as andrej bauer likes to point out Haskell != CT & pretending it is is bad math...
10:32:26 <anon9002> Is there something like Scheme's SRFI-26 in Haskell?
10:32:38 <anon9002> http://srfi.schemers.org/srfi-26/srfi-26.html
10:35:03 <jmcarthur> anon9002: It looks like this just solves a problem not present in idiomatic Haskell, though.
10:35:14 <ReinH> Bauer's argument is not convincing
10:35:23 <nshepperd1> That argument seems silly to me. The fast and loose reasoning proper showed that the total subset of Haskell is well defined, so surely you can just do your category theory there then import it into real Haskell
10:35:23 <amalloy> it's not present in much scheme either
10:35:29 <jmcarthur> Yeah
10:35:54 <Tuplanolla> It probably stems from "lambda" being too verbose in Scheme.
10:36:21 <ReinH> Category theory generally doesn't have operational semantics anyway
10:36:25 <jmcarthur> `flip` can be used for a limited subset of these.
10:36:57 <jmcarthur> > let f a b c d e = a + b + c + d + e in (f 1 2 `flip` 4 5) 3
10:36:59 <lambdabot>  error:
10:36:59 <lambdabot>      • Could not deduce (Num t0)
10:36:59 <lambdabot>        from the context: (Num (t -> a), Num t, Num a)
10:37:06 <jmcarthur> what did i do now
10:37:26 <andromeda-galaxy> nshepperd1, ReinH: Andrej's point there is that even for that subcategory there hasn't been any work that actually showed that a category did exist
10:37:34 <Tuplanolla> At least it's not called "anonymous-function-with-some-arguments".
10:37:43 <nshepperd1> Basically, don't worry about undefined and nontermination, because it's inconsequential to any actual results, except those that are "about" totality
10:37:47 <ReinH> Yes there has. It is quite easy to show.
10:38:29 <ReinH> And also work that had shown that hask with bottoms forms a CPO
10:38:38 <andromeda-galaxy> ReinH: but the behavior of Haskell programs has not been well-defined ever, really. It can bed one inside domain theory with omega-CPO s, but that's not the commonly known Hask
10:38:41 <jmcarthur> Ah I put the flip in the wrong spot.
10:38:44 <andromeda-galaxy> it's the omega-CPO category
10:38:56 <jmcarthur> It's not expressive enough to solve the general "problem" anyway.
10:38:57 <nshepperd1> (which cashes out as, when you import results back to real Haskell, adding "modulo totality")
10:39:43 <ReinH> Can you stop moving the goal posts please?
10:40:25 <monochrom> this is why I don't read blogs
10:41:03 <nshepperd1> I don't remember the part of the definition of "category" that requires defining the behaviour of things
10:41:20 <andromeda-galaxy> eh, sorry, I am also trying to reconcile my "agh, it's not quite a category" with "there are all these useful results in it". It's probably true to be good enough, but I would definitely be *nice* to have a language which is all mathematically defined through everything and has formal verification of various CT properties, etc.
10:42:16 <jmcarthur> I'm not sure where the goal posts are in the first place.
10:42:30 <ReinH> Plenty of useful work had been done by treating Haskell categorically, just look at lens
10:42:34 <jmcarthur> I think different people have different ideas of this.
10:43:04 <ReinH> But you read a blog post and now it is known that Haskell can't form a category.
10:43:08 <ReinH> Spare me.
10:43:16 <monochrom> I think you can safely delete "agh, it's not quite a category". then there is nothing to reconcile.
10:44:04 <erisco> Cthulhu will spare no one, but may he eat us first
10:44:18 <ReinH> We have multiple useful models of Haskell as a category.
10:44:34 <ReinH> People get real work done with them
10:44:43 <monochrom> the kind of sentences "true modulo totality" are from parametricity rather than category theory
10:45:14 <ReinH> Parametricity is from category theory :p
10:46:17 <nshepperd1> They're from fast and loose reasoning
10:47:38 <Myrl-saki> Is there a type A + AB?
10:47:56 <Welkin> data Z = A | AB
10:47:57 <Welkin> yeah
10:47:58 <Myrl-saki> Considering that someone decided to make These.
10:48:04 <ReinH> Either a (a,b)
10:48:08 <Myrl-saki> Yeah.
10:48:22 <Myrl-saki> I'm asking if someone has a package with that type.
10:48:34 <Myrl-saki> Because, well, class instances.
10:48:53 <ReinH> Why would you need a package to combine two types from the Prelude?
10:49:06 <Myrl-saki> ReinH: https://hackage.haskell.org/package/these-0.7/docs/Data-These.html
10:49:15 <ReinH> What instances are you missing?
10:49:28 <EvanR> sweet things are made of that
10:49:38 <Myrl-saki> ReinH: Nothing that comes into mind.
10:49:44 <Myrl-saki> But better have it ready in case.
10:49:46 <Myrl-saki> :P
10:50:06 <ReinH> Nah
10:50:11 <Myrl-saki> Hmmm...
10:50:19 <Myrl-saki> This is making me feel weird.
10:50:26 <andromeda-galaxy> ReinH: well suree, there are lots of good categories. I'm talking specifically about the one model that I was using, that looks like the Control.Category module, and which doesn't actually look like category theory
10:50:35 <Myrl-saki> I'm using These, but it doesn't make much sense to have a keyboard event without a tick event.
10:50:47 <Myrl-saki> But it make sense to have a tick event without a keyboard event.
10:50:58 <nshepperd1> NJ
10:51:48 <EvanR> tick event o_O
10:51:52 <EvanR> whyyy
10:52:07 <Welkin> sdl2?
10:52:11 * nshepperd1 notices that data AB a b = X a | Y a b is the base functor of non empty lists
10:52:17 <EvanR> really?
10:52:25 <Myrl-saki> EvanR: I'm just following the example in wires.
10:52:28 <Myrl-saki> EvanR: How should I do it?
10:52:40 <Myrl-saki> It uses tick events and keyboard events.
10:52:43 <EvanR> probably like that in wires
10:52:53 * hackagebot conduit-combinators 1.0.8.1 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.8.1 (MichaelSnoyman)
10:52:55 * hackagebot monad-logger 0.3.20 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.20 (MichaelSnoyman)
10:52:56 <nshepperd1> Fix (AB a) ~ NonEmpty a
10:54:30 <Myrl-saki> nshepperd1: :o
10:55:35 <nshepperd1> Probably not relevant to your use case :p
10:55:49 <erisco> :t (<*>)((<*>)((pure)(<*>))((<*>)((pure)(pure))(<*>)))((pure)(pure))
10:55:50 <lambdabot> Applicative f => f (a -> b) -> a -> f b
10:55:52 <Myrl-saki> nshepperd1: I know. :P
10:56:10 <sbrg> erisco: what have you done?!
10:56:15 <Myrl-saki> nshepperd1: Oh lol.
10:56:22 <Myrl-saki> nshepperd1: Just realized what was happening.
10:56:24 <erisco> sbrg, it is flip for Applicative
10:57:08 <Myrl-saki> nshepperd1: It actually easily makes much sense if named properly. `data Cell a b = End b | Cons a b`
10:57:39 <Myrl-saki> nshepperd1: Also, I think it should be X b rather than X a for ~ NonEmpty a.
10:57:47 <erisco> johnw, I figured it out, what I was after … quite simple really
10:57:59 <nshepperd1> End a
10:58:05 <Myrl-saki> nshepperd1: Are you sure?
10:58:24 <Myrl-saki> nshepperd1: I think it'd be ~ [Maybe b]
10:58:31 <Myrl-saki> With End a.
10:58:56 <Myrl-saki> Err
10:58:59 <erisco> johnw, from S and K you can construct all functions (I am not sure how this changes wrt typing though), and so just those signatures is what I need
10:59:13 <Myrl-saki> ~ Stream (Maybe b)? Dunno what's the convention for a neverending list.
10:59:41 <nshepperd1> Fix (Cell a) substitutes the b with Fix (Cell a)
11:00:00 <EvanR> a stream of Maybe doesnt seem quite right... even without much context
11:00:24 <Myrl-saki> nshepperd1: Oh wait.
11:00:30 <Myrl-saki> nshepperd1: I see what you mean now. Yeah.
11:00:41 <Myrl-saki> nshepperd1: My mistake!
11:01:13 <erisco> johnw, and above is the proof that a → b → c is the same as b → a → c
11:01:53 <Myrl-saki> Hmmm
11:02:38 <Myrl-saki> EvanR: Wires seem a bit weird to me wrt not using events.
11:02:54 <EvanR> huh
11:03:07 <Myrl-saki> Wait.
11:03:29 <erisco> johnw, I know sans typing you have general recursion, and with typing none, but I am not interested in recursion so this should suffice
11:03:57 <Myrl-saki> I'm trying to make a recursive wire(is that a correct term?) If y is equal to c, then z <- f z.
11:04:01 <Myrl-saki> Or something.
11:04:25 <Myrl-saki> z <- scan a -< f <$ e
11:04:39 <Myrl-saki> But is there a way to not use scan or e?
11:05:07 <Myrl-saki> where e is an Event ofc.
11:07:04 <Myrl-saki> I tried doing that a while ago and just gave up and used events.
11:07:20 <Myrl-saki> Now I'm doing it again and want to find a better way.
11:10:07 <ReinH> nshepperd1: Alternatively, Cofree Maybe a ~ NonEmpty a
11:11:57 <ertesx> Myrl-saki: (feel free to highlight me, when you have a wires question) regarding your original question: 'f' is stateful, but if you use it twice in wires, you're actually constructing the state twice
11:12:32 <ertesx> Myrl-saki: wires have local state, so in (f . f) one doesn't interfere with the other's state, but each have their own
11:13:04 <Myrl-saki> ertesx: Right.
11:13:42 <Myrl-saki> ertesx: I was using your pingpong code and ported it to SDL.
11:14:20 <erisco> you may find more success by borrowing the idea of "using" or RAII
11:14:31 <Myrl-saki> ertesx: And I noticed that my second newCharEvent was only recognizing like 1/100 of the events.
11:14:39 <erisco> because Haskell is not designed to handle this "use once" requirement
11:15:11 <erisco> on the other hand, say you want to open and close files. Then naturally the issue is there is only one file, and so how do you do this?
11:15:16 <Myrl-saki> ertesx: I'm trying to find a way that I can call newCharEvent and it will only read events from SDL once.
11:15:23 <erisco> also the handle is either opened or closed, and once closed is not open
11:15:31 <EvanR> you can open the same file many times
11:15:50 <EvanR> on linux at least
11:15:59 <ertesx> Myrl-saki: the proper way is not to use newCharEvent at all, but implement newSdlEvent, then do the event splitting within wires semantics
11:16:03 <erisco> well, not necessarily, maybe you lock it for writing, for example
11:16:07 <ertesx> Myrl-saki: i.e. using catMapE or filterE
11:16:12 <erisco> but also, the file handle object itself is stateful
11:16:27 <EvanR> a file descriptor isnt stateful
11:16:29 <EvanR> its just a number
11:16:59 <erisco> this is a conflated view
11:17:09 <EvanR> have you seen the way idris can encode the state of the file?
11:17:09 <Myrl-saki> ertesx: I see.
11:17:18 <ertesx> Myrl-saki: personally i'd just ignore the timestamp and construct an Event EventPayload, where Event is from wires, and EventPayload is from sdl2
11:17:20 <EvanR> in the type
11:17:37 <ertesx> Myrl-saki: then using catMapE you can construct constrained events easily
11:17:43 <erisco> anyways, other languages have a way to cope with this which can also work in Haskell, such as "using" and RAII
11:17:57 <Myrl-saki> ertesx: I see. Thanks.
11:18:33 <grantwu> Can someone explain to me why type inference requires manual annotations sometimes
11:18:38 <grantwu> Here let me get an lpaste
11:18:51 <JonReed> With linear types one could encode how many times a type is supposed to be used. It would bring a lot of cool applications. But currently Haskell does not have it. 
11:18:58 <erisco> instead of a file handle object, you have an object for the whole transaction, and so this may look like  writeToFile :: FilePath → Text → IO ()
11:19:02 <Welkin> grantwu: because it can be ambiguous
11:19:31 <erisco> instead of, say, open :: IO File  and  write :: File → Text → IO ()  and  close :: File → IO ()
11:19:39 <ertesx> JonReed: "currently" as in "not any time soon" =/
11:19:50 <erisco> I mean  open :: FilePath → IO File
11:20:43 <erisco> the reason you may want these file objects, particularly to open and close them, is so you may do multiple operations on them without opening and closing each time
11:20:52 <JonReed> ertesx: I like to dream : https://www.reddit.com/r/haskell/comments/50nkbo/linear_types_coming_to_ghc/
11:21:02 <erisco> but we can compose operations on files absent of these file objects
11:21:26 <Myrl-saki> ertesx: Oh right.
11:21:29 <erisco> Text → Text  transforms the contents of a file, for example, and you can compose many of these together
11:21:36 <grantwu> Welkin: http://lpaste.net/235992
11:21:38 <Myrl-saki> ertesx: I posed another question earlier.
11:21:45 <erisco> and you can imagine more sophisticated tasks, but all can be done absent of the file handle itself
11:22:05 <Myrl-saki> ertesx: Does it make sense to have an input event outside of tick events?
11:22:21 <Myrl-saki> ertesx: I mean, wouldn't that kinda mess up some timings?
11:22:21 <erisco> so we might then have a way to run these transformations such as  onFile :: FilePath → (Text → Text) → IO ()
11:22:32 <grantwu> Welkin: Not quite understanding this
11:23:04 <ertesx> Myrl-saki: not at all, it makes perfect sense!  the cases when you would have something like this is when you want to tie rendering to ticks, but handle all pending events in a single "tick frame"
11:23:29 <Myrl-saki> ertesx: tick frame?
11:23:59 <ertesx> Myrl-saki: background: imagine that your game runs at 60 FPS, and due to rendering each tick is 1/60 seconds apart…  but there are events that potentially occur with much higher frequency, for example mouse movement
11:24:05 <EvanR> erisco: this way works ok, but if you have the handle you can still smuggle it out of the block. if you dont have a handle you cant do things with more than one file 
11:24:09 <Myrl-saki> ertesx: I see.
11:24:50 <erisco> EvanR, there is no handle in this picture, it is only under the covers of onFile or whatever interface you decide on
11:24:56 <Welkin> grantwu: it's asking you to specify which Foldable instance you want
11:25:08 <EvanR> right so youre limited to using one file at a time
11:25:20 <erisco> not so
11:25:21 <ertesx> Myrl-saki: you'd want to process all of those events without rendering (do rendering via 'onEvent' on 'ticks'), except for the last pending event, at which point you also tick, and rendering happens with all pending events processed
11:25:29 <EvanR> or else, closing in the opposite order
11:25:59 <Welkin> :t concatMap -- grantwu 
11:26:00 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
11:26:07 <Welkin> that `t` could be anything
11:26:22 <ertesx> Myrl-saki: (you can also just process all SDL events, then have a tick event separately)
11:26:32 <grantwu> Oh, hrm, I guess I thought I was using the one from Prelude
11:27:15 <ertesx> i think i should write a combinator for that
11:31:11 <Myrl-saki> ertesx: Also, any plans to make some custom functions for These?
11:31:26 <erisco> EvanR, I have to think about it more, but read :: FilePath :→ Text; write :: FilePath :→ Text :→ () is a start, where :→ is an Arrow
11:31:26 <Myrl-saki> Or Align.
11:31:54 <Myrl-saki> Oh wait.
11:32:01 <Myrl-saki> I mean someting unalign-esque.
11:32:04 <Myrl-saki> Yeah.
11:32:14 <Myrl-saki> unalign :: f (These a b) -> (f (Maybe a), f (Maybe b))
11:32:23 <erisco> I mean, it would be  Read :: FilePath :→ Text; Write :: FilePath :→ Text :→ ()
11:32:40 <Myrl-saki> Oh wait.
11:32:48 <EvanR> erisco: keeping the state of the file processing program in the type is an option
11:33:01 <EvanR> and lets you deal with errors
11:33:02 <Forgetaboutit> Hi folks!  Quite recently, I came across an interesting article ( http://degoes.net/articles/modern-fp-part-2 ).  Since it appears to be written in Purescript and I'm quite interested in separating concerns using Free approaches, I played around and tried rewriting the code in Haskell.  I came across the `example' function from the post, which I couldn't manage to compile.  I get an error saying `• Expected a constraint, but ‘Inject
11:33:02 <Forgetaboutit> Banking f’ has kind ‘*’'.  For reference, `Inject' comes from another post from the same blog.  I translated it into `type Inject f g = forall a. Control.Lens.Prism' (f a) (g a)'.  I'm not very good higher kinded types, but I understand that the kind of the `Banking' type class doesn't match the expected kind `(* -> *)' from Inject.  I'm wondering what can be done about the situation.  Maybe a completely different approach is neede
11:33:02 <Forgetaboutit> Haskell.  I'd be grateful for any pointers.
11:33:20 <Myrl-saki> I think I just realized what I can do.
11:33:41 <Myrl-saki> Oh yeah. Now I know
11:33:45 <erisco> EvanR, from that, if you keep it finite, you can figure out when files should be opened and closed
11:34:01 <Myrl-saki> ertesx: thereE :: Event (There a b) -> Event b
11:34:24 <Myrl-saki> oh wait
11:34:31 <Myrl-saki> justThisE*
11:34:39 <erisco> well, it may have to be  Read :: FilePath → () :→ Text; Write :: FilePath → Text :→ ()  instead
11:34:55 <Myrl-saki> ugh. I'm wrong again.
11:34:56 <erisco> if the file paths are not constant then you really cannot know when to close a file
11:35:40 <EvanR> time dependent paths?
11:35:50 <erisco> EvanR, it doesn't sound applicable to Haskell though, using types
11:35:53 <Myrl-saki> ertesx: Ignore what I just said. There were so many flaws there.
11:36:09 <EvanR> why not
11:37:09 <EvanR> singletons phantom types indexed monads oh my
11:37:34 <Myrl-saki> https://gist.github.com/f22264f7b6cd380a80d351dc1f76bd43
11:37:36 <erisco> you need a way to identify files, and so presumably this is by file path, and so then we're talking about singletons
11:37:36 <Myrl-saki> oh boi.
11:37:55 <erisco> where "foo" :: "foo" roughly and "foo" is a singleton
11:38:14 <erisco> but then file paths have to be static
11:38:22 <EvanR> if you decide on that at the beginning of the session then its just a value
11:38:42 <EvanR> i dont understand the use case of filepaths changing from under you
11:38:43 <erisco> whereas the arrowised version does not have to be static. Effectively the program is compiled at runtime
11:39:02 <erisco> the file paths may be determined by IO
11:39:04 <EvanR> you dont issue the filepath on each operation
11:39:52 <erisco> unless you have the explicit constant "foo" in your program you cannot read the "foo" file under the singleton system
11:40:09 <fm1> Hi, short question: I'd like  to parse a hex number from a string into an Int. The fuction read throws if it can't parse, and readHex from the Numeric module returns a list of possible parses. I don't want an exception and I don't need backtracking as I know that there is a hex number in the string. What would you guys ue?
11:40:48 <fm1> I mean use.
11:43:28 <erisco> the weakness still in the arrowised version is that the file paths still have to be known ahead of time, only that you can do IO by other means (at runtime) to determine these paths
11:44:00 <erisco> you could address this by having dynamic schemes for deciding when to close files
11:44:12 <Tuplanolla> @hoogle hexStringToInt
11:44:15 <lambdabot> Text.XML.HXT.DOM.Util hexStringToInt :: String -> Int
11:44:19 <erisco> if after so many operations a file goes unused then it is closed, for example
11:44:49 <erisco> should it happen to be used again then of course you open it again
11:45:59 <erisco> this is actually less of a divergence from the original goal than you may think
11:46:22 <erisco> originally we deal with file handles, and we decide when these are created and destroyed, i.e. files opened and closed
11:46:35 <erisco> but this may be the same file we are opening and closing repeatedly
11:46:50 <fm1> Ah, thanks for the hoogle hint.  Okay, I'll try both suggestions.
11:47:13 <sbrg> @hoogle readHex
11:47:14 <lambdabot> Numeric readHex :: (Eq a, Num a) => ReadS a
11:47:14 <lambdabot> Text.Read.Lex readHexP :: (Eq a, Num a) => ReadP a
11:47:14 <lambdabot> Diagrams.Backend.CmdLine readHexColor :: (Applicative m, Monad m) => String -> m (AlphaColour Double)
11:47:14 <erisco> any time we make a local decision to open and close a file we are blind to the bigger picture of our program, where this file may be opened and closed many times
11:47:28 <erisco> this is similar to memory allocation
11:47:31 <Myrl-saki> @pl \x _ -> (y, x)
11:47:31 <lambdabot> const . (,) y
11:47:31 <sbrg> Tuplanolla: ^
11:47:41 <erisco> we can make local, static determinations about it but be blind to the bigger picture
11:48:02 <erisco> so are we interested in tracking just file handles or files themselves?
11:48:02 <Myrl-saki> @pl \x _ -> (x,y)
11:48:02 <lambdabot> const . flip (,) y
11:51:13 <EvanR> the file themselves?
11:51:15 <Tuplanolla> Neither really answers fm1's question, sbrg.
11:51:26 <erisco> yes
11:51:46 <EvanR> not sure what abstraction that is honestly
11:52:00 <erisco> h <- open "foo"; write h "hello"; close h;
11:52:05 <erisco> that is handles
11:52:14 <EvanR> when i said you could open the same file many times... 
11:52:16 <erisco> h <- open "foo"; write h "hello"; close h; h <- open "foo"; write h "hello"; close h; h <- open "foo"; write h "hello"; close h;
11:52:19 <erisco> 3 handles, 1 file
11:52:32 <EvanR> 3 handles?
11:52:37 <erisco> yes
11:52:41 <EvanR> oh in the second one
11:52:55 * hackagebot netwire-input-javascript 0.0.1 - JavaScript instance of netwire-input  https://hackage.haskell.org/package/netwire-input-javascript-0.0.1 (ZioCrocifisso)
11:52:59 <EvanR> yeah, once you have that handle, "the file itself" almost doesnt matter
11:53:08 <EvanR> until way later
11:53:13 <erisco> what if we use a dynamic scheme like I suggested instead
11:53:18 <EvanR> when you possible did 3 different things "with the same file"
11:53:29 <erisco> so we can open handles and they are closed for us automatically when deemed appropriate
11:53:42 <erisco> so we do just  h <- open "foo"; write h "hello";
11:53:44 <EvanR> when is it appropriate?
11:53:52 <erisco> now when we do  h <- open "foo"; write h "hello"; h <- open "foo"; write h "hello"; h <- open "foo"; write h "hello";
11:53:58 <erisco> it shares the same handle, likely
11:54:25 <EvanR> AI pooling of FDs doesnt really sound feasible
11:54:26 <erisco> well, look at scheduling, there is debate and variation
11:54:44 <EvanR> you need to somehow tell the system what your workflow is supposed to be
11:55:35 <erisco> a simple scheme is that after x consecutive operations not involving a handle, that handle is closed, and also all handles are closed when the program ends
11:55:35 <EvanR> otherwise you could just go with the current system and take whatever you get
11:55:39 <EvanR> when you do a random writeFile
11:55:46 <grantwu> @pl tab stmts = unlines (map (('\t' :) . show) stmts)
11:55:46 <lambdabot> tab = unlines . map (('\t' :) . show)
11:56:16 <EvanR> erisco: well, you might not want auto flushing and closing
11:56:19 <EvanR> or auto syncing
11:56:21 <EvanR> or whatever
11:56:37 <EvanR> performance or consistency concerns
11:56:38 <erisco> it is like scheduling
11:56:47 <erisco> or garbage collection
11:56:53 * EvanR head scratch
11:57:06 <EvanR> randomly closing a file 100 times while youre working on it has gotta be bad
11:57:11 <erisco> in both, arbitrary decisions have to be made about what algorithm to use
11:57:26 <erisco> same deal here
11:58:00 <EvanR> you could say the same about network connections, can we insert an entity that disconnects you and reconnects you while youre working for no reason
11:58:02 <erisco> you look at the common uses and design an algorithm to appease that
11:58:19 <EvanR> it would save connectedness
11:58:28 <EvanR> and hurt performance
11:58:40 <erisco> you can say all the same things about scheduling and garbage collection
11:58:49 <erisco> yet in many, if not most, applications we don't worry about either one
11:59:23 <erisco> you will have cases where it actually improves program performance
11:59:56 <erisco> and cases where it is worse, or not viable
12:00:36 <EvanR> complex file workflows are complex, simple ones are like dump a large object to a file with writeFile and are simple
12:01:14 <EvanR> for complex, i worry that some AI thing is going to mess up consistency
12:01:27 <EvanR> "the should not have been closed yet..."
12:01:42 <erisco> consistency in performance? yes I would not rely on that
12:01:55 <EvanR> what data consistency
12:02:07 <EvanR> durable protocols
12:02:19 <erisco> are we talking about concurrency then?
12:02:29 <EvanR> no
12:02:40 <erisco> how does it make any difference then
12:03:13 <EvanR> are you having an actual problem with files?
12:03:25 <erisco> are you?
12:03:29 <soLucien> is this possible ? evalArrayFor :: (Ident, Expr, Maybe ArrayCompr) -> Expr
12:03:37 <EvanR> no
12:03:44 <erisco> neither am I
12:03:53 <soLucien> or should it necessarily be evalArrayFor :: Ident -> Expr -> Maybe ArrayCompr -> Expr
12:04:32 <EvanR> one is the curried version of the other
12:04:47 <soLucien> even with the commas ?
12:04:55 <soLucien> (,,) is a tuple
12:04:55 <EvanR> thats the uncurried version
12:05:02 <EvanR> :t uncurry
12:05:03 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:05:10 <soLucien> while -> is the function
12:05:15 <EvanR> not sure if uncurry3 exists
12:05:19 <erisco> there are questions, such as what does  h <- open "foo"; g <- open "bar"; unlink h; write g "hello";  mean
12:05:24 <Tuplanolla> :t uncurry3
12:05:25 <lambdabot> error:
12:05:26 <lambdabot>     • Variable not in scope: uncurry3
12:05:26 <lambdabot>     • Perhaps you meant ‘uncurry’ (imported from Data.Tuple)
12:05:36 <EvanR> erisco: yeah you could establish that with "type state"
12:05:51 <EvanR> perhaps establish that as meaningless now that i read it
12:05:53 <erisco> er, I mean …
12:06:01 <Tuplanolla> It might exist in the utility FT or TF thing.
12:06:05 <erisco> h <- open "foo"; g <- open "foo"; unlink h; write g "hello";
12:06:08 <soLucien> so the comma is a valid type expression
12:06:21 <NickHu> soLucien: (,) is a function
12:06:27 <EvanR> once you unlink it, it still works, because "the file itself" isnt a real thing
12:06:42 <soLucien> yes, true
12:06:54 <EvanR> :k (,)
12:06:55 <lambdabot> * -> * -> *
12:07:13 <NickHu> EvanR: A file with no hard links only disappears when all handles to it are closed
12:07:17 <erisco> that could be a possible meaning, i.e. writing to a file that does not exist just does nothing
12:07:20 <NickHu> At least on UNIX systems
12:07:21 <Tuplanolla> Utility HT: https://hackage.haskell.org/package/utility-ht-0.0.12/docs/Data-Tuple-HT.html
12:07:51 <EvanR> erisco: it might exist in some sense, the file system and the virtual memory system are basically the same and can be used for IPC
12:08:06 <erisco> in particular to automatic handling of file handles though this has to be carefully considered
12:08:17 <erisco> if we left it to chance of when handles were closed, this program can give different results
12:08:20 <erisco> that is why I brought it up
12:08:24 <soLucien> basically what i'm trying to do is http://lpaste.net/2521083985287708672
12:08:26 <EvanR> definitely
12:08:30 <soLucien> i can't get it to typecheck
12:08:45 <EvanR> so avoid hGetContents
12:08:49 <soLucien> the trouble is on line 59
12:09:04 <soLucien> and maybe the function on l 53-56
12:09:06 <soLucien> please help 
12:09:26 <erisco> one possibility is it takes out two read locks, and so unlink fails
12:09:35 <erisco> but the write would succeed
12:09:45 <EvanR> erisco: also without a specific semantics of IO, even if you attempted to do all this deterministically it could have different results
12:09:48 <erisco> another possibility is it is just one handle, and so unlink succeeds and then write fails
12:10:39 <EvanR> of course, i have a mildly awesome deterministic semantics of IO bwahahaha
12:10:46 <erisco> I guess not a question of closing handles but a question of opening them
12:11:44 <EvanR> to reinvent the API of files, you might need to take into account the entire virtual memory system and what it can do
12:11:50 <EvanR> and what people use it for
12:12:20 <NickHu> soLucien: What is the type for evalExpr supposed to be?
12:12:35 <erisco> soLucien, line 68 has -do but I think you meant --do
12:13:31 <erisco> soLucien, additionally, your type should be  Ident -> Expr -> Maybe ArrayCompr -> Expr  assuming the rest checks out
12:13:50 <erisco> or your parameters should be  (ident, expr, Nothing)
12:15:48 <soLucien> NickHu evalExpr :: Expr -> SubsM Value
12:16:01 <soLucien> sorry i somehow removed from the paste
12:16:08 <erisco> soLucien, also, it looks like  evalExpr :: Expr -> Value  but you use it as  arrVal <- evalExpr expr  which is a type error, Value is not a Monad
12:16:21 <soLucien> yes i am getting that
12:16:29 <NickHu> soLucien: Well, it evaluates to a Value
12:16:34 <NickHu> Assuming that it evaluates at all
12:16:42 <soLucien> let me implement these advices 
12:16:46 <soLucien> i'll repaste 
12:26:53 <erisco> checking if a file exists is a fruitless exercise
12:28:01 <erisco> the operation is not "does file exist" but rather "did file exist"
12:28:19 <NickHu> Which paper is *the* Wadler paper on monads?
12:28:28 <NickHu> As in, the one referenced in the typeclassopedia?
12:28:39 <NickHu> It just links to a page with a bunch of his publications on monads
12:29:19 <byorgey> NickHu: http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
12:30:42 <NickHu> byorgey: Thanks
12:30:59 <NickHu> Also are the terms "unit" and "identity" interchangable in algebra? Do they differ?
12:31:36 * ni642610 Login Here Sometime Chat With Camera -> www.albachat.com/phone/
12:31:37 * ni642610 Login Here Sometime Chat With Camera -> www.albachat.com/phone/
12:31:38 * ni642610 Login Here Sometime Chat With Camera -> www.albachat.com/phone/
12:31:39 * ni642610 Login Here Sometime Chat With Camera -> www.albachat.com/phone/
12:34:52 <tomleb> Hey guys, what do you use for code sharing ?
12:35:03 <erisco> () is the identity for products. I don't know
12:35:22 <erisco> tomleb, GitHub
12:35:40 <tomleb> sorry I mean to show snippets
12:35:44 <erisco> lpaste.net
12:36:53 <tomleb> erisco: Thanks
12:37:04 <erisco> () is 1 for sums
12:37:19 <erisco> maybe this is what is meant by unit
12:37:37 <erisco> unit circle, for example
12:38:08 <erisco> the unit by which we measure
12:38:30 <Tuplanolla> Unit and identity usually refer to the same idea, but unit is more often like an object while identity is more often like a morphism, erisco.
12:39:13 <erisco> does CT get the say on this?
12:39:33 <Tuplanolla> No?
12:43:00 <EvanR> unit type is so called because it has one element
12:43:32 <EvanR> you could also called it 1
12:43:40 <Welkin> or One
12:43:45 <Welkin> or Unity
12:43:59 <EvanR> its a terminal object in Hask (ignoring bottoms)
12:44:10 <Welkin> in elm it's called Never o.o
12:44:11 <erisco> but what is important? that it is the identity of product or the relationship to sums? or both?
12:44:35 <EvanR> Never?
12:44:40 <Welkin> I think
12:44:46 <Welkin> no wait, it still has () though
12:45:38 <EvanR> yeah theres also the type algebra
12:45:47 <Welkin> it's bugadobadoobedoo
12:52:56 * hackagebot servant-auth-token-api 0.3.2.0 - Servant based API for token based authorisation  https://hackage.haskell.org/package/servant-auth-token-api-0.3.2.0 (NCrashed)
12:52:58 * hackagebot hoppy-generator 0.2.1 - C++ FFI generator - Code generator  https://hackage.haskell.org/package/hoppy-generator-0.2.1 (khumba)
12:53:00 * hackagebot hoppy-runtime 0.2.1 - C++ FFI generator - Runtime support  https://hackage.haskell.org/package/hoppy-runtime-0.2.1 (khumba)
12:53:02 * hackagebot hoppy-std 0.2.1 - C++ FFI generator - Standard library bindings  https://hackage.haskell.org/package/hoppy-std-0.2.1 (khumba)
12:57:01 <shirt> Is "configurator" library recommended for use? or is it unmaintained? last release was in 2014
13:03:43 <erisco> :t ((app <<<) .) . (&&&)
13:03:44 <lambdabot> ArrowApply cat => cat a (cat b c) -> cat a b -> cat a c
13:04:20 <EvanR> cat within a cat
13:04:35 <erisco> it is S for ArrowApply
13:05:21 <erisco> I was noticing that it may be useful to have S and K across domains
13:05:41 <erisco> K is simple, S is the more interesting one
13:06:08 <erisco> so what you can do is you can describe manipulations from one domain in another domain
13:06:30 <vapid> k keep me posted
13:06:39 <vapid> that sounds very interesting
13:06:41 <vapid> bruh
13:07:48 <ReinH> ArrowAply (~>) = (a ~> b ~> c) -> (a ~> b) -> a ~> c
13:08:16 <ertesx> Myrl-saki: hehe, there you go
13:09:53 <ReinH> (<*>) is this for Hask, i.e., (~>) ~ (->)
13:10:30 <ReinH> or rather, S is.
13:10:42 <ReinH> Which is (<*>) for ((->) r)
13:11:18 <ReinH> two different generalizations of S
13:12:56 <ReinH> It frustrates me that we can't use type operator variables (any more), they make working with all arrow abstractions much nicer.
13:13:12 <dagda1> I thought this would return a list of chars [x | (x) <- "haskell"]. 
13:13:49 <ReinH> > [x | (x) <- "haskell"]
13:13:51 <lambdabot>  "haskell"
13:13:53 <ReinH> It does.
13:14:01 <ReinH> The parens are redundant.
13:14:06 <geekosaur> the problem is that a String is exactly a list of Char
13:14:15 <ReinH> But they don't change the meaning.
13:14:15 <dagda1> I am looking for ["h", "a", "s", "k", "e"
13:14:16 <dagda1> etc
13:14:21 <ReinH> That is not a list of characters.
13:14:29 <ReinH> > [[x] | x <- "haskell"]
13:14:31 <lambdabot>  ["h","a","s","k","e","l","l"]
13:14:33 <ReinH> that is a list of lists
13:14:40 <dagda1> ah, I see
13:14:44 <dagda1> thanks
13:14:49 <ReinH> type String = [Char]
13:14:58 <soros_gyurka> aka the worst mistake ever made
13:15:16 <ReinH> I dunno, n + k patterns were pretty bad
13:15:24 <geekosaur> if  you meant 'h' and friends (actual Char) then the problem is that String is exactly [Char] and the Show instance can never know whether you want "Haskell" or ['H','a',
13:15:26 <geekosaur> er
13:15:39 <geekosaur> ['H', 'a', 's', 'k', 'e', 'l', 'l']
13:15:44 <APic> ☺
13:15:46 <geekosaur> so it always shows it as the string form
13:15:47 <ReinH> > "hello" == ['h', 'e', 'l', 'l', 'o']
13:15:49 <lambdabot>  True
13:16:07 <ReinH> Data type contexts were pretty bad.
13:16:30 <mauke> > intercalate "," (map show "hello")
13:16:33 <lambdabot>  "'h','e','l','l','o'"
13:16:36 <intothem1untains> How could I apply a pair of functions to a tuple? (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:16:39 <ReinH> String is nice when you want to perform induction on potentially infinite texts /s
13:16:41 <geekosaur> likewise there is no way to distinguish between 'a':'b':'c':[] and ['a','b','c'] and "abc" --- they are three ways to write the exact same value
13:16:53 <ReinH> Just like 0.999... and 1
13:16:54 * ReinH ducks
13:16:58 <mauke> :t (***)
13:16:59 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:17:26 <ReinH> Arrow (~>) => b ~> c -> b' ~> c' -> (b, b') ~> (c, c')
13:17:37 <soros_gyurka> > explode
13:17:39 <lambdabot>  error: Variable not in scope: explode
13:17:54 <intothem1untains> What is ~>?
13:18:16 <ReinH> The type parameter.
13:18:25 <ReinH> In my imaginary Haskell where one can do this.
13:18:32 <ReinH> it replaces `a' as the type variable.
13:19:01 <ReinH> Arrows are (abstract) arrows, it would be nice to represent them as such.
13:19:26 <erisco> what is  a ~> b ~> a  ?
13:20:15 <ReinH> a ~> (b ~> a) for some Arrow (~>)
13:20:24 <ReinH> or indeed for all arrows (~>)
13:20:28 <erisco> yes, how do you implement it
13:20:33 <ReinH> Implement what?
13:20:39 <erisco> a ~> b ~> a
13:21:06 <ReinH> With the const arrow, I suppose. Why?
13:21:23 <erisco> what package has this?
13:21:42 <ReinH> Arrows are in base.
13:21:50 <ReinH> Control.Arrow
13:22:03 <erisco> what is the const arrow called, then?
13:23:21 <jmcarthur> I'm confused.
13:23:42 <jmcarthur> :t arr (uncurry const)  -- ?
13:23:44 <lambdabot> Arrow a => a (c, b) c
13:24:00 <erisco> do not use arr
13:24:12 <erisco> I am not sure if Arrow is defined in such a way that it works without arr
13:24:36 <jmcarthur> This is why Arrow isn't so great.
13:24:43 <ReinH> :t arr (arr . const)
13:24:45 <lambdabot> (Arrow a1, Arrow a) => a c (a1 b c)
13:25:35 <jmcarthur> :t app . first const
13:25:37 <lambdabot> (c, b) -> c
13:25:48 <jmcarthur> :t app <<< first const
13:25:50 <lambdabot> (b1, b) -> b1
13:26:08 <jmcarthur> ah of course
13:26:33 <jmcarthur> I think you just need arr due to the way Arrow is designed.
13:26:34 <erisco> maybe it doesn't have it
13:26:41 <ReinH> Anyway, I don't know why you asked me to implement a ~> b ~> a in the first place
13:26:58 <erisco> I wasn't asking you specifically
13:27:23 <VikingofRock> Is there a way to have a generic function do something different for a specific type? For example, if I have foo :: Num a => a -> b, can I have foo :: Int -> b do something different?
13:27:32 <VikingofRock> I know this is dangerous territory but I am kind of curious
13:27:38 <ReinH> The type of arr (arr . const) is a proof that you can write a ~> b ~> a for all arrows.
13:27:43 <ReinH> er, rather, the implementation is the proof
13:27:46 <ReinH> the type is the theorem
13:28:03 <erisco> arr is nonsense to me though
13:28:06 <ReinH> Ok.
13:28:09 <jmcarthur> VikingofRock: Only by having control over the Num Int instance. You could make a newtype wrapper around Int with different behavior if you wanted.
13:28:10 <ReinH> That doesn't mean that it's nonsense.
13:28:24 <soros_gyurka> are arrows actually useful for anything
13:28:30 <soros_gyurka> because i never really got them
13:28:35 <ReinH> Yes, but not as much as was originally thought
13:28:35 <soros_gyurka> and im wondering whether i should
13:28:50 <ReinH> arrow parsers are more reflective than monad parsers
13:29:04 <ReinH> That is, you can examine their structure and potentially perform optimizations
13:29:07 <jmcarthur> Not that useful. It would be better if arr was replaced with some primitives that don't require being able to lift (->).
13:29:13 <ReinH> whereas monad parsers create a computational black box
13:29:23 <erisco> in regard to parsers, arr is a thorn
13:30:02 <ReinH> soros_gyurka: http://homepages.inf.ed.ac.uk/slindley/papers/idioms-arrows-monads.pdf
13:30:48 <jmcarthur> http://www.megacz.com/berkeley/garrows/ would be nicer although I don't care for the proposed syntax.
13:31:10 <soros_gyurka> y-you too
13:34:45 <VikingofRock> jmcarthur: Hmm I think I may have oversimplified my question. Really what I want is this: Let's say I have a class Foo a, and I want to have generic instance for Num a => Foo a, and also a different instance for Foo Int. Is that doable? I think it might boil down to the same thing but it's hard for me to tell
13:34:51 <tippenein> I;m finding it difficult to find references to backreference in Regex packages
13:35:41 <ReinH> VikingofRock: No, it is not doable.
13:36:08 <tippenein> my needs are not advanced by any means, need to match something like "(octop|vir)us$" and backref with "\1i"
13:36:18 <geekosaur> not without wrapping Foo Int in a newtype so it no longer looks like a Foo
13:37:06 <jmcarthur> VikingofRock: It's "doable," but not reliably. Sometimes the compiler just won't be able to tell that it's an Int.
13:37:14 <VikingofRock> Fair enough. Yeah I could see this quickly getting into weird territory where it's not clear which instance to use
13:43:24 <erisco> why can't we have type operators?
13:43:30 <ReinH> It is doable fsvo "doable" which sometimes includes "not doable".
13:44:05 <jmcarthur> erisco: We can. Just not as variables.
13:44:14 <erisco> oh
13:44:26 <Tuplanolla> Check out Repa, erisco.
13:44:28 <jmcarthur> erisco: We used to be able to do that, but for some reason we changed it.
13:44:58 <ReinH> jmcarthur: it makes me very sad
13:46:35 <jmcarthur> I feel like it was changed because whoever did it (SPJ?) just happened to not often/ever use them as variables and wanted to make the non-variable case look prettier? I don't remember whether I objected, but if not then I wish I had.
13:47:04 <jmcarthur> Maybe I'm wrong about that.
13:47:45 <Tuplanolla> My guess would be that they conflicted with how type operators work now or making their fixity consistent with normal operators was too messy.
13:47:46 <geekosaur> I recall a number of people wanting the non-variable case to be prettier/more flexible
13:48:02 <geekosaur> and not caring much about variables in that context
13:49:48 <jmcarthur> http://haskell.1045720.n5.nabble.com/Type-operators-in-GHC-td5154978.html
13:52:57 * hackagebot hoppy-docs 0.2.1 - C++ FFI generator - Documentation  https://hackage.haskell.org/package/hoppy-docs-0.2.1 (khumba)
13:53:56 <ReinH> Can I have back it as an extension please??
13:54:21 <ReinH> Or do I have to make my own Haskell with type operator variables and programmable brackets?
13:54:23 <Tuplanolla> Imagine something like this: (Wiggler (~~), infix 6 ~~, Donger (~>), infixr 8 ~>) => a ~> b ~> a ~~ b
13:54:47 <ReinH> Yeah, I mean, I'd be happy with a fixed fixity tbf.
13:55:10 <ReinH> right associative and higher than -> meets most of my use cases
13:55:17 <VikingofRock> Wait, so how does Show [a] get specialized for Show [Char]? Like they must have instance Show a => Show [a], and also have a separate instance Show [Char], right?
13:55:35 <ReinH> VikingofRock: showList
13:55:58 <ReinH> VikingofRock: http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:showList
13:57:02 <ReinH> showList is defined for the Char instance, which overrides the default
13:57:20 <VikingofRock> Hmm interesting
13:57:38 <ReinH> This avoids overlapping instances for Show a => Show [a] and Show [Char]
13:58:21 <ReinH> This is done precisely because doing it the way you propose is untenable :)
13:58:57 <VikingofRock> Yeah now I'm trying to figure out how to reformulate stuff with that. It seems like a neat workaround
13:59:13 <VikingofRock> I was so sure the answer was going to have to do with {-# OVERLAPPING #-} or whatever
14:03:20 <soLucien> does anyone know how much a Haskell private lesson/coaching session would cost , and how to get one ? 
14:03:40 <Welkin> lol
14:03:43 <Welkin> um
14:03:46 <Welkin> it won't cost anything
14:03:50 <Welkin> just ask your questions here
14:04:09 <soLucien> it is taking too long to get answers, and i kind of need a teamviewer thing
14:04:17 <soLucien> where i explain what i'm trying to do
14:04:22 <Tuplanolla> Does "private" imply some inappropriate things?
14:04:24 <slack1256> you can always step up your google-fu skills
14:04:25 <maerwald> Welkin: asking here isn't really a _private_ lesson
14:04:39 <soLucien> no as in teamviewer
14:04:41 <soLucien> for 2 hours
14:04:44 <soLucien> explain the problem
14:04:51 <soLucien> explain what i am trying to do
14:05:05 <soLucien> and get the help i can't from a TA
14:05:05 <slack1256> plus if you can get some personality development if you can discuss problems in the open.
14:05:11 <slack1256> at least it happened to me
14:05:34 <soLucien> because i might be trying to do something which is impossible
14:05:47 <soLucien> i've spent over 100 hours on this assignment
14:05:55 <ertesx> ReinH: even as a heavy user of arrows i've never actually found myself using an arrow transformer (arrow to arrow) in practice, so i don't really miss type operator variables that much
14:06:27 <slack1256> soLucien: state the simplest subpart of your problem
14:06:28 <ertesx> ReinH: you can still use `infix` syntax, which helps in those cases though
14:06:43 <ReinH> a bit
14:06:47 <soLucien> i am trying to evaluate an array of expressions
14:06:50 <soLucien> inside a context
14:07:03 <soLucien> .. i can't even state it
14:07:06 <soLucien> it's like monads
14:07:13 <soLucien> once you get them , you cannot explain them
14:07:14 <soLucien> :D
14:07:19 <slack1256> not really
14:07:45 <Zekka> Can you post an example at all from your code? It sounds like the thing you're doing is not impossible but I don't know for sure
14:07:51 <ReinH> Being able to state it is your next challenge then.
14:08:02 <soLucien> ReinH i can post the assignment, the code
14:08:06 <soLucien> the errors
14:08:09 <ReinH> Being able to state it in your own words
14:08:10 <soLucien> anything
14:08:13 <ReinH> means that you understand it
14:08:19 <ReinH> if you don't understand it, you can't solve it except by accident
14:08:24 <ReinH> which explains why you've spent 100 hours
14:08:27 <ReinH> without solving it
14:08:28 <soLucien> i am evaluating Expressions and yielding monadic values
14:08:30 <slack1256> we don't do homework, we help (free) to understand haskell
14:08:34 <soLucien> i am trying to evaluate an array comprehensions
14:08:45 <soLucien> i am NOT asking for someone to do my homework
14:09:00 <Zekka> So when you've got an array comprehension to evaluate, how do you represent that?
14:09:03 <soLucien> i already have someone else's homework and if that was my interest, i would simply paste it in
14:09:04 <soLucien> and submit
14:09:11 <ReinH> Your time would be better spent trying to understand the problem than going on a random walk looking for a solution
14:09:12 <soLucien> what I am trying to do is understand it
14:09:35 <soLucien> ReinH i have spent hundreds of hours on it , ReinH
14:09:39 <soLucien> i do understand it
14:09:43 <ReinH> I don't believe you
14:09:46 <Zekka> (right now what I'm trying to nudge you about is to come up with some specific types that represent your problem)
14:09:46 <geekosaur> soLucien, the real problem is you don't seem to be learning. you keep coming back having made the same mistakes over and over
14:09:46 <ReinH> since you can't explain it to me
14:09:58 <soLucien> i have explained the issue
14:09:58 <slack1256> yeah, understanding without being able to explain is... weird
14:09:59 <ReinH> if you can explain it then you understand it
14:09:59 <geekosaur> so it's questionable whether you really do understand it
14:10:05 <ReinH> Not really
14:10:15 <ReinH> Then if you understand it, it should be easy to explain it again
14:10:19 <soLucien> so
14:10:23 <Zekka> I don't know, I think there are things you can understand without being able to explain -- but most of those things aren't programming assignments
14:10:25 <soLucien> back to explaining
14:10:39 <ReinH> Zekka: like "what is love?"
14:10:47 <slack1256> can you state the simplest subpart (possible with code, lambdabot helps) doesn't work?
14:10:52 <slack1256> ie
14:10:54 <Zekka> ReinH: Yeah, or more concretely "is there a person in this picture?"
14:11:06 <soLucien> my issue is the switch from a monadic to a non-monadic context
14:11:11 <slack1256> > fmap (const) [2,3,4] 
14:11:11 <ReinH> (that is indeed a programming assignment)
14:11:14 <lambdabot>  error:
14:11:14 <lambdabot>      • No instance for (Typeable b0)
14:11:14 <lambdabot>          arising from a use of ‘show_M51102424416517876442573’
14:11:16 <slack1256> why it fails?
14:11:22 <ReinH> What is a "monadic context" and what is a "non-monadic context"?
14:11:30 <Zekka> So you're producing a value with a type like m a, and you want to get a value with a type like a?
14:11:39 <ReinH> :t fmap const [2,3,4]
14:11:40 <lambdabot> Num a => [b -> a]
14:11:51 <Welkin> soLucien: you wrote an interpreter?
14:11:52 <ReinH> slack1256: that is what lambdabot is trying to show
14:11:54 <ReinH> it can't show that
14:11:57 <Zekka> Because if so, we probably want to know what m is before we can help with that
14:12:04 <slack1256> ReinH: yeah, but an example of a doubt that can be stated in #haskell
14:12:04 <Welkin> like Write Yourself a Scheme in 48 Hours?
14:12:12 <soLucien> yes i am writing an interpreter
14:12:15 <ReinH> I believe it is a weird javascript-like language
14:12:24 <soLucien> now i have to add recursive array comprehensions
14:12:28 <Welkin> soLucien: take a look at what I just mentioned
14:12:37 <Welkin> it's a bit outdated, but the basic concepts are there
14:12:54 <ReinH> So, if you can do things on "monadic contexts", you understand what a "monadic context" is. What is it?
14:13:18 <soLucien> in my case it's something that preserves a state
14:13:20 <ReinH> What concrete thing are you referring to as a "monadic context"?
14:13:21 <Zekka> (ReinH: Apologies for guessing by the way, I'm trying to do the thing where people respond more accurately if you give a list of alternatives than if you just give them an open question -- not sure if that's helping)
14:13:31 <Zekka> So, what does a thing with a monadic context look like vs a thing without one?
14:13:33 <ReinH> What something? What state?
14:13:42 <soLucien> it's a Context object that has a Environment state
14:13:42 <ReinH> You are working with concrete data types and functions
14:13:44 <Zekka> if I had two values and one had a monadic context and the other wouldn't, would they have the same type?
14:13:49 <ReinH> What concrete thing in your program are you referring to?
14:13:51 <soLucien> that changes on every execution step
14:13:58 <Zekka> Are we looking at `Context` vs `State Environment Context`?
14:14:22 <slack1256> do you want a function from 'State something a -> a' right?
14:14:27 <soLucien> Context = primitives environment + variables environment
14:14:30 <ReinH> We are looking at an ADT for an AST that soLucien hasn't defined for us yet
14:14:39 <soLucien> ReinH
14:14:43 <ReinH> but is instead attempting to describe with in vague terms
14:14:46 <ReinH> s/with //
14:15:00 <ReinH> Just show us the data structure
14:15:07 <slack1256> maybe he didn't know the term (i certainly didn't) so I can cut him some slack
14:15:11 <ReinH> and the function you need to write, its type, and a description of what it does
14:15:18 <ReinH> we don't need terms
14:15:20 <ReinH> we just need code
14:15:23 <ReinH> and simple explanations
14:15:25 <jmcarthur> soLucien: http://lpaste.net/
14:15:43 <ReinH> And don't give us 100 lines and ask us to find the 5 relevant lines. Give us a *minimal* complete example.
14:16:09 <ReinH> If you expect it to work, try to compile it and show us an error message if there is one.
14:16:10 <soLucien> http://lpaste.net/2521083985287708672
14:16:16 <ReinH> Don't give us something you just guess might work like you've done before
14:16:24 <soLucien> lines 54 and 60
14:16:27 <soLucien> are relevant
14:16:28 <ReinH> What did I just say
14:16:31 <grantwu> Urgh, why would anyone write foo True = const bar instead of foo True _ = bar
14:16:34 <ReinH> Give us a minimal complete example
14:16:43 <ReinH> Extract the relevant things out into their own file.
14:16:59 <soLucien> i cant because i am 1) unsure whether evalArrayFor :: (Ident, Expr, Maybe ArrayCompr) -> Expr
14:17:04 <soLucien> is the right type signature
14:17:13 <soLucien> evrything is relevant
14:17:29 <grantwu> Haven't you been working on this for a while
14:17:34 <grantwu> Don't you have TAs for this
14:17:42 <soLucien> no man .. i don't 
14:17:57 <grantwu> Are there no TAs for your class
14:18:05 <Zekka> It sounds like from what you're saying, there may be a bunch of places in the code where something's relevant to the problem you're experiencing, and you don't know well enough yet what should be factored out/stubbed/etc
14:18:40 <grantwu> Like, to me it sounds like you need a TA; I've been a TA, and the help you can get from a TA/need is not something that really works over IRC too well
14:18:57 <soLucien> Zekka evrything i posted here is a explanation of my problem. i've extracted 60 lines out of 300
14:19:01 <Zekka> Previously he was asking if anyone wanted to do an over-the-shoulder coaching session
14:19:07 <soLucien> exactly
14:19:13 <soLucien> i need a TA
14:19:15 <soLucien> i can't get one
14:19:33 <Zekka> I've done that sort of thing before but I'm not really looking to do it now -- I can see value in that sort of thing though
14:19:34 <soLucien> so i would gladly pay someone for teamviewer and a couple of hours
14:19:37 <soLucien> that's how desperate i am
14:19:49 <soLucien> after spending my last 2 weeks on it.
14:19:51 <grantwu> Out of curiosity why are there no TAs
14:20:10 <soLucien> there are TAs but they are not helpful
14:20:29 <ReinH> I feel like this isn't an unbiased representation of the facts
14:20:29 <soLucien> they are there for grading and giving us feedback
14:20:37 <glguy> the discussion of the lack of TAs and the neverending struggle with this assignment is exceeding topical discussion
14:20:39 <soLucien> plus 4 hours/week exercise sessions
14:20:56 <soLucien> this week they were doing Prolog. i skipped school to work on this
14:21:13 <ReinH> glguy: I read that as "exceedingly" and was confused.
14:21:28 <slack1256> glguy: maybe, but it seems some colleges say "refer to freenode #haskell for questions"
14:21:30 <glguy> it wasnt a good sentence...
14:21:32 <ReinH> like "is glguy having problems with TAs?"
14:21:35 <slack1256> so it is maybe forced upon us
14:21:45 <grantwu> slack1256: Which college is this?
14:21:57 <glguy> I'm in my phone and don't want to have to do enforcement from it
14:22:10 <ReinH> But yes, if there's a haskell question to be had here, let's move on to it
14:22:11 <slack1256> that is the general impression I've gotten from progit/reddit 
14:22:12 <glguy> but I'm bored and waiting for a flight
14:22:34 <slack1256> which also isn't on topic
14:22:40 <ReinH> I'll note that "How do I implement array comprehensions for a javascript-like language" is not a Haskell question.
14:23:10 <Zekka> soLucien: Would it be at all helpful to implement just the feature that's not working right in a language other than Haskell?
14:23:26 <Zekka> It's often not that hard to translate code like that to Haskell-using-State or something
14:23:58 <soLucien> guys listen .. i really need some help because i am desperate . I am prepared to pay for it. There's 4 TAs for 120 of us and they are there for 5 hours/week in the exercise sessions
14:24:03 <Zekka> Then you could separate problem-specific concerns from language-specific ones
14:24:08 <soLucien> i can't get help from them
14:24:15 <soLucien> Zekka i can't
14:24:20 <soLucien> it has to be in Haskell
14:24:41 --- mode: ChanServ set +q solucien!*@*
14:24:48 <Zekka> I just meant so that you're sure you understand how the problem outside of Haskell would be solved
14:24:48 <slack1256> can you *please* state haskell problems you have?
14:24:55 <grantwu> soLucien: The suggestion is for you to implement something first in something else
14:25:00 <Zekka> that way you only have to think about Haskell-specific stuff
14:25:03 <grantwu> soLucien: Then come back for help in translating
14:25:06 <slack1256> not the general "how do I design an interpreter" but haskell specific stuff
14:25:20 <ReinH> Ok everyone let's take a breather.
14:25:34 <Zekka> Sorry, I don't mean to cause trouble -- I kinda wish I could do more for you but I'm on the hook at unpredictable times this weekend
14:28:30 <grantwu> How does casing on integers work?
14:29:04 <slack1256> casing? maybe your meant casting?
14:29:21 <Zekka> or maybe caseof/pattern matching?
14:29:56 <grantwu> How is it possible to pattern match on Integers, is what I mean
14:30:09 <grantwu> like clearly Integer is not defined as data Integer = 0 | 1 | 2 | 3 ...
14:30:16 <EvanR> it uses the Eq instance
14:30:35 <grantwu> Oh
14:30:37 <grantwu> ...huh
14:30:43 <EvanR> in that case specifically
14:31:03 <EvanR> same as data Char = 'a' | 'b' | 'c' | ...
14:31:27 <grantwu> Are these just special cased
14:31:31 <EvanR> yeah
14:32:23 <EvanR> it kind of messes of the theory, but its practical in some cases
14:32:32 <Zekka> yeah, there's an argument to be made that some Eq instances might be evil
14:33:14 <Zekka> with data = . | . | ... types you can guarantee that pattern matching is yea fast
14:33:26 <Zekka> with Eq you just kinda have to hope that the Eq implementors aren't bastards
14:35:43 <slack1256> but that special 'case .. of' matching hardcoded for those numeric types right?
14:36:09 <EvanR> its for Char and Num/Eq
14:36:15 <EvanR> maybe something else
14:36:15 <slack1256> then it should be a problem, those instances are battle tested (well not Double) and we can't add new ones
14:36:19 <slack1256> *shouldn't
14:36:40 <Zekka> slack1256: Oh yeah, I'm not on the side that this is evil
14:36:52 <verement> I think it also happens for IsString when -XOverloadedStrings
14:39:08 <geekosaur> ...although you can simulate it for any other type with view patterns
14:40:13 <geekosaur> well, view patterns and/or pattern guards depending on how you want to approach it
14:41:30 <ReinH> Oh no, cabal-install 1.24.0 is throwing that "File in tar archive is not in the expected directory" that 1.22.4 used to throw
14:42:03 <glguy> how'd you fix it then?
14:42:23 <ReinH> By waiting for a new version
14:42:26 <glguy> delete the cache in .cabal?
14:42:28 <ReinH> It bricked cabal-install.
14:42:42 <ReinH> This one apparently was fixed by a new lower-bound on tar, perhaps added as a hackage revision?
14:42:47 <ReinH> So I guess I just need to install it again
14:43:04 <ReinH> https://github.com/haskell/cabal/issues/3390
14:46:35 <ReinH> I sometimes forget that different installs of the same package version can have different results.
14:46:59 <ReinH> (it's really a (package, version, revision) triple, but the revision number is usually hidden)
14:48:29 <ReinH> Yeah, new tar version fies it
14:48:31 <ReinH> fixes
14:51:35 <grantwu> ghc-mod is complaining about a line that doesn't exist and the error won't go away by resaving my file >_<
14:52:59 * hackagebot doctemplates 0.1.0.0 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.1.0.0 (JohnMacFarlane)
14:53:01 * hackagebot qtah-qt5 0.1.2 - Qt bindings for Haskell  https://hackage.haskell.org/package/qtah-qt5-0.1.2 (khumba)
14:53:03 * hackagebot qtah-examples 0.1.2 - Example programs for Qtah Qt bindings  https://hackage.haskell.org/package/qtah-examples-0.1.2 (khumba)
14:59:41 <ReinH> Zekka: EvanR's answer is true if the function is polymorphic
14:59:46 <ReinH> e.g., f :: Num a => a -> a
15:00:41 <EvanR> well, doesnt the usual inlining rules apply for non polymorphic ==
15:00:50 <ReinH> Numbers as patterns are treated (depending on whether they contain a decimal place) as Integers or Rationals respectively
15:00:51 <grantwu> Why can't I have equations with different number of arguments in the definition of a file?
15:01:01 <grantwu> for example I can't do
15:01:14 <grantwu> assertMsg True _ = return ()
15:01:26 <grantwu> assertMsg False = throwError
15:01:44 <ReinH> The typeclass dicts for Eq and Num or Fractional (respectivley) are used to compare the pattern to the value, converted to an Integer (Rational)
15:02:04 <ReinH> then the Bool is case scrutinized, possibly nested with more cases, as needed to handle all the definitions
15:02:22 <ReinH> for f :: Int -> Int, GHC pattern matches literals on 0#, 1#, etc.
15:05:24 <ReinH> For f :: Double -> Double, the primitive ==## comparison for doubles is used and the resulting Bool is case scrutinized.
15:06:58 <ReinH> grantwu: because Haskell doesn't allow you to.
15:07:22 <ReinH> You can do assertMsg True = \_ -> return (), ofc
15:08:15 <grantwu> ReinH: Well, yes, I know Haskell doesn't allow me to.  But why doesn't it let me?
15:08:27 <ReinH> Because someone decided not to.
15:08:40 <geekosaur> because desugaring that to a case is painful when the arity varies
15:08:45 <ReinH> Probably specifically to annoy grantwu
15:08:54 <ReinH> or that
15:09:00 <grantwu> ah, okay
15:09:13 <ReinH> desugaring could have been done by eta conversion, I suppose
15:09:18 <ReinH> but it's easier to just not
15:09:19 <geekosaur> there's another reason but I'm not recalling it offhand, where it turns into a nasty corner case
15:15:48 <tippenein> whhyyyyy, type MatchArray = Array Int (MatchOffset, MatchLength)
15:18:07 <tippenein> why does regex not give back the text that matched?
15:18:27 <geekosaur> it can. but figuring out how can be ... painful.
15:18:48 <tippenein> what is the intended way of working with this result?
15:19:16 <geekosaur> the Text.Regex interface is polymorphic in a way that is difficult to decipher
15:20:43 <ReinH> Have you considered writing a parser?
15:20:44 <EvanR> regex-applicative?
15:21:44 <tippenein> ReinH: I would like to, but the interface I'd like to expose is like this: https://github.com/rails/rails/blob/master/activesupport/lib/active_support/inflections.rb
15:22:13 <ReinH> That would be easy to express with a parser.
15:22:47 <tippenein> so, except a Regex-like Text to define the parser?
15:23:27 <ReinH> I mean, you could, but this is an EDSL, so you can just have people write parsers.
15:23:47 <tippenein> When I heard "people don't really use regex in haskell" I didn't know there was subtext "*because they're nearly unusable"
15:24:09 <ReinH> Or maybe they're nearly unusable because people don't really use them.
15:24:27 <tippenein> true and fair
15:25:04 <ReinH> Anyway, pcre-light is pretty easy to use.
15:25:19 <geekosaur> it wouldn't be that difficult to make a saner interface, but I do suspect one of the objectives of the current one is to make them so horrible that people are pushed to doing parsers instead
15:25:25 <ReinH> hah
15:25:47 <ReinH> match :: Regex -> ByteString -> [PCREExecOption] -> Maybe [ByteString]
15:26:20 <ReinH> Is the interface you seem to want
15:26:45 <geekosaur> (which is not always a good thing as there are in fact legitimate uses for regex, especially when providing tools that integrate with a typical shell environment that uses regexes e.g. grep/sed)
15:26:54 <tippenein> yeah, backreference would be nice too, but I can just hack that in
15:27:18 <geekosaur> (which happens to be an environment I not only use but also support, and the low energy route for me ends up being using perl instead of haskell)
15:27:18 <ReinH> I haven't seen any uses of backreferences yet
15:27:40 <ReinH> I see, e.g., '\1' used in the substitution string, but that is not a back reference.
15:27:46 <ReinH> Just a form of string interpolation.
15:28:14 <tippenein> oh, I thought it was a backref, albeit a simple one
15:28:27 <ReinH> backreferences are references *within the regular expression* to previous captures
15:28:53 <ReinH> e.g., /([a-c])x\1x\1/ matches axaxa, bxbxb and cxcxc
15:28:57 <ReinH> but not axbxa
15:29:18 <ReinH> they are the thing that make extended regular expressions actually not regular
15:29:54 <ReinH> None of the regexp in the rails inflector use backreferences.
15:31:26 <tippenein> I'm not opposed to using a parser. this project already uses megaparsec
15:32:03 <tippenein> what would you expect an interface for this to look like?
15:32:16 <grantwu> Maybe what you want is a lexer?  Not entirely sure, haven't been following
15:53:00 * hackagebot hocilib 0.2.0 - FFI binding to OCILIB  https://hackage.haskell.org/package/hocilib-0.2.0 (Thierry)
16:35:10 <Lu> i find the chatban from glguy to be extremely unfair, and totally random
16:41:12 <grantwu> We know you're the same person...
16:42:47 <johnw> glguy does not ban at random
16:43:30 <lgstate> wc -l counts # of lines, including comments; is there a better way to 'count lines' in haskell ?
16:43:41 <johnw> sloccount
16:43:52 <johnw> oh, you mean implementing it in Haskell
16:44:05 <lgstate> no no, I just want to use it at the commandline
16:44:21 <johnw> then sloccount might be good
16:44:26 <lgstate> cool; thanks!
16:44:43 <lgstate> it surprises me taht https://github.com/sweirich/pi-forall/tree/2014/full , with all comments, is only 4kLOC
16:44:54 <lgstate> I'd expect dependent types to be a bit bigger, like 40k or something
16:45:13 <EvanR> a core dependently type language doesnt have much to it
16:45:31 <johnw> yeah, the core theory is very, very small
16:45:39 <johnw> it's really quite elegant how you get so much out of so little
16:45:48 <Lu> 14:21:57 <glguy> I'm in my phone and don't want to have to do enforcement from it
16:45:50 <Lu> 14:22:12 <glguy> but I'm bored and waiting for a flight
16:46:06 <Lu> i find that very random
16:46:11 <Lu> and no warning was given
16:46:11 <grantwu> Lu: I think what glguy is saying there is
16:46:22 <Cale> Lu: discuss it on #haskell-ops
16:46:32 <grantwu> "I would've banned you earlier if I was at my desktop; however, I happen to be able to here"
16:46:44 <Cale> I'm sure glguy will let you know why he muted you.
16:47:01 <Lu> how about "you are going off-topic, stick to the topic or i mute you" ?
16:47:15 <grantwu> Discuss it there
16:48:06 <Lu> my question was this :  http://lpaste.net/2521083985287708672 totally related to Haskell
16:48:11 <lgstate> johnw: yeah, for some reason (perhaps due to idris, coq, and dependent-types sorta being faked in haskell), theres' this expectation that 'dependent types' = OMG, really ahrd to implement
16:48:24 <Lu> and it still is
16:48:26 <lgstate> whereas looking at the work of pi-forall, it's clearly got a very clean core
16:48:45 <EvanR> but core theory is necessarily everything youd want, you want inductive types, termination checking
16:48:53 <EvanR> is not necessraily*
16:48:58 <Lu> basically my question is whether the approach I am trying is fit as a solution
16:49:04 <grantwu> Lu: You're just going to get banned again lol
16:49:09 <EvanR> implicit argument passing
16:49:14 <Lu> omg why ?
16:49:29 <grantwu> Lu: People have told you dicuss this on #haskell-ops and you're still discussing it here
16:49:30 <Lu> i really don't get it .. been on freenode a lot
16:49:43 <Lu> i was asking a question about haskell
16:50:00 <joe9> lgstate:  have you checked out HoTT.
16:50:15 <grantwu> Is there a better way of doing Set.size . Set.filter
16:50:23 <lgstate> joe9: homototetopy theory? the new foundation of mathematics by a fields medalist on coq ?
16:50:38 <lgstate> joe9: that seems like the opposite direction of what I want, it appears to be "here's a new set of libraries *ON TOP* of Coq"
16:50:41 <jmcarthur> grantwu: length . filter . Set.toList  would probably be more efficient
16:50:45 <lgstate> rather than "what's the minimal core we need for depenent type theory"
16:52:02 <grantwu> jmcarthur: Thanks
16:52:38 <grantwu> Do you think this would be something useful to have in Data.Set
16:53:02 * hackagebot pasta 0.1.0.2 - PostgreSQL Abstract Syntax Tree Assember  https://hackage.haskell.org/package/pasta-0.1.0.2 (diogob)
16:53:11 <jmcarthur> Not sure it passes the fairbairn threshold.
16:53:49 <EvanR> lgstate: https://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
16:56:29 <lgstate> EvanR: what does lambdaPi have over piForall? (I ask becaused I tried lambdaPI before, found it incomprehensible; whereas piForall, looks very easy to understand so far)
16:56:53 <EvanR> the size of the core code is even smaller
16:57:05 <EvanR> if thats what youre going for
16:57:43 <lgstate> EvanR: piForall has 12 video lectures attached to it -- I'm going to understand piForall first
17:01:50 <juri_> haskell: you must think your way out of all of the problems.
17:06:04 <ertesx> grantwu: is your filter predicate monotonic?  if yes, you can use splitLookup instead
17:06:36 <grantwu> ertes: Uh... I'm not sure what you mean by monotonic in this case?
17:06:58 <grantwu> Oh, no
17:07:04 --- mode: ChanServ set +o dibblego
17:07:06 <grantwu> I don't think the elements of the set even have an order
17:07:25 <ertes> grantwu: they certainly do, otherwise you wouldn't be using Set =)
17:07:25 --- mode: dibblego set -q solucien!*@*
17:08:05 <grantwu> ertes: ...Wait, why do they need to be ordered in order to use Set
17:08:40 --- mode: dibblego set -o dibblego
17:08:47 <EvanR> :t Data.Set.insert
17:08:49 <lambdabot> Ord a => a -> S.Set a -> S.Set a
17:09:06 <EvanR> :t Data.Set.singleton
17:09:08 <lambdabot> a -> S.Set a
17:09:18 <EvanR> technically you can make a 1-element set without ordering
17:09:41 <EvanR> :t Data.Set.singleton ($)
17:09:43 <lambdabot> S.Set ((a -> b) -> a -> b)
17:10:02 <ertes> grantwu: all of Set's efficiency is due to clever use of the ordering
17:10:55 <ertes> grantwu: including the O(log n) complexity of splitLookup…  so if you have a monotonic predicate, you can use that one instead
17:11:23 <ertes> split at a certain point in the ordering, then count the relevant side of the resulting subtrees (and perhaps the extra element)
17:12:57 <grantwu> oh right, I forgot that the typeclass constraints are put into the functions
17:14:37 <grantwu> ertes: What is splitLookup?
17:14:49 <grantwu> I am only finding split
17:15:49 <ertes> oh
17:15:52 <ertes> it's splitMember for Set
17:17:10 <ertes> apparently in the latest version of containers there are all those *Antitone functions that look much more convenient
17:17:31 <ertes> like takeWhileAntitone and spanAntitone
17:17:59 <ertes> but split/splitMember are of course safer
17:18:58 <grantwu> sigh but now I need to manufacture an element which compares less than everything I want and greater than everything I don't
17:19:03 <grantwu> I guess in my case I can something like
17:19:06 <grantwu> Spill -1
17:19:12 <grantwu> Even though spills should only ever be positive
17:19:45 <johnw> grantwu: add a UI that doubles every number it adds to the set
17:19:52 <johnw> then the odd positions can be used for comparison requests
17:20:28 <grantwu> I'm... not sure if you're serious
17:20:36 <johnw> i'm totally serious
17:20:41 <Welkin> why so serious?
17:20:50 <johnw> i did exactly this for a register allocator, to allow for "between" position
17:21:14 <grantwu> I'm not sure why you would care about between positions o.O
17:21:19 <grantwu> Like what I'm really trying to do is
17:21:40 <grantwu> I have data Lval = Temp Int | Spill Int | Reg Register
17:21:51 <johnw> oh, I thought you said "less than everything I don't want, greater than everything I do want"; it sounded like you need a vaule in between
17:22:13 <grantwu> Well, I do... but only to get an efficient count
17:22:22 <grantwu> What I really want is to find out how many spills I have in a set of lvals
17:26:41 <ReinH> johnw: the Hilbert's hotel trick :)
17:27:21 <EvanR> ??? -> hilbert's hotel trick -> profit
17:27:38 <johnw> I thought that trick was lazily incrementing everything else by one so you can insert at the beginning
17:28:06 <ReinH> A bus containing countably infinite guests arrives.
17:28:55 <ReinH> Tell all guests to move to room \n -> 2n
17:29:11 <ReinH> Put the new guests in the odd rooms
17:29:22 <johnw> ah, ok, I had just heard it told differently
17:29:26 <ReinH> To be fair, there are many Hilbert's hotel tricks
17:29:26 <johnw> \n -> n + m
17:29:58 <ReinH> Like the one for taking out the trash
17:30:46 <ReinH> Which is probably my favorite
17:32:52 <ReinH> Since the trash literally disappears from the universe
17:33:16 <ReinH> Which is rather surprising
17:33:31 <EvanR> huh
17:34:22 <Welkin> the universe is a closed system, right?
17:34:39 <Welkin> unless the multiverse has a way for allowing universes to interact
17:35:54 <ReinH> There universe containing Hilbert's hotel has very different rules from ours
17:36:22 <EvanR> namely, Reno NV, i dont recommend it
17:36:25 <geekosaur> Everett-Wheeler QM forbids interaction because it would enable you to know both aspects of a conjugate pair to arbitrary accuracy
17:37:36 <ReinH> Every guest has 30 seconds to bag their trash and pass it to the next (larger) room, 15 seconds to pass the bag they receive up, 7.5 seconds for the next bag, and so on.
17:38:15 <ReinH> The passing completes in 1 minute and the bags are now NOWHERE.
17:38:47 <ReinH> no room contains a trash bag
17:39:07 <ReinH> The trash bags have formed a singularity
17:39:50 <EvanR> we can do that in haskell
17:40:48 <ReinH> EvanR: what happens in Hilbert's hotel stays in Hilbert's hotel except clearly it doesn't
17:42:28 <EvanR> f ((guest,trashes):(guest',trashes'):rest) = (guest,[]) : f ((guest',trashes++trashes'):rest)
17:42:42 <EvanR> f hotel has no trash anymore
17:42:58 <ReinH> Indeed!
17:43:07 <ReinH> I think that's pretty cool.
17:43:28 <johnw> nerd snipe achievement: complete
17:43:35 <ReinH> :D
17:44:32 <EvanR> probably not the best performing GC algorithm tho
17:45:36 <ReinH> Hahaha
17:56:10 <koz_> I'm a bit confused between these two different definitions of Lan. The one here: http://okmij.org/ftp/Computation/free-monad.html#freer is parametrized over two types, but the one here: http://hackage.haskell.org/package/kan-extensions-5.0.1/docs/Data-Functor-Kan-Lan.html is over *three*. How do they differ exactly, and how would I recover the former from the latter?
17:59:17 <jle`> koz_: the first Lan seems to be the second Lan where h ~ Identity
17:59:26 <jle`> er, wait, nvm
17:59:44 <koz_> Is the first Lan is the second Lan over the same thing twice?
17:59:55 <koz_> So it'd be 'Lan f f a'?
18:00:01 <koz_> (sorry, 'Lan g g a'?)
18:00:03 <slack1256> with the newtype package, which hof can I pass instead of foldMap?
18:00:15 <slack1256> to the ala combinator I mean
18:01:11 <jle`> koz_: i think type Lan1 h = Lan2 h Identity
18:01:34 <jle`> um Lan2 Identity h
18:01:38 <koz_> jle`: Could you please explain why you think so? I'd like to understand your reasoning.
18:01:41 <jle`> it's just that the g in the second one is Identity
18:01:47 <johnw> the first Lan isn't really "Lan" in general, it's one instance of Lan as the parenthesized comment says
18:01:47 <koz_> Or is this just a 'follow the types' type story?
18:01:57 <johnw> general Lan involves two functors
18:02:03 <jle`> the second constructor is Lan :: (g b -> a) -> h b -> Lan g h a
18:02:19 <jle`> the third is Lan :: (b -> a) -> h b -> Lan h a
18:02:31 <jle`> so set the g to Identity in the second one and you get the first one
18:02:38 <koz_> jle`: OK, I see, thank you!
18:02:53 <koz_> I've tried to make sense of that stuff, plus Ed's writings on it, but my head begins to spin very quickly.
18:02:58 <jle`> s/third/first
18:04:30 <johnw> koz_: I found this explanation extremely helpful: https://www.quora.com/What-is-a-laymans-explanation-of-Kan-extensions
18:04:48 <koz_> Thanks johnw - I will read it.
18:04:49 <johnw> specifically, his compiler/evaluator metaphor
18:04:59 <johnw> oops, wrong link, one sec
18:05:16 <koz_> johnw: I was about to say...
18:05:43 <johnw> ah, there it is, the 2nd answer
18:05:51 <johnw> "say you have a program ..."
18:05:59 <koz_> Also, where does the Identity functor/monad/whatever-the-fuck live again?
18:06:08 <jle`> Data.Functor.Identity
18:06:09 <johnw> Data.Functor
18:06:11 <johnw> .Identity
18:06:28 <Welkin> oh
18:06:30 <Welkin> is that a new TLD?
18:06:40 <Welkin> functor.identity
18:06:46 <jle`> http://data.functor.identity
18:09:03 <Myrl-saki> jle`: holy cow. lol.
18:09:53 <Lokathor> so, if my program gets a Ctrl+C sent at it, is there a way to ensure that it executes particular code before it actually dies, or is that controlled by the OS?
18:10:11 <jle`> Ctrl+C is sent to haskell runtime as an async exception
18:10:17 <jle`> so it can be handled like any other async exception
18:10:21 <Lokathor> okay
18:10:33 <ertes> Lokathor: e.g. via 'finally'
18:10:37 <ertes> or 'onException'
18:10:49 <Lokathor> yeah i've seen a few of those in the docs, but i'll have to look it up again
18:10:58 <Lokathor> i just wasn't sure if the OS killed the process externally or not
18:11:10 <jle`> simon marlow's concurrent haskell book has a nice chapter on it
18:11:21 <jle`> i think sigkill is what you're thinking of
18:11:26 <johnw> Lokathor: yeah, it depends on the signal
18:11:49 <intothem1untains> any book you nca
18:11:53 <jle`> ctrl+c is sigterm.  for unix systems
18:12:10 <jle`> programs get a chance to clean themselves up from a sigterm
18:12:10 <johnw> I thought it was SIGINT
18:12:15 <jle`> oh yeah, that's right
18:12:32 <intothem1untains> sorry, any downloadable haskell book directed to an intermediate audience you can recommend?
18:12:40 <Lokathor> yeah it's a curses program, so cleaning up the terminal's IO state is pretty important even if the program is suddenly going to die
18:12:59 <geekosaur> Welkin, they opened up the TLDs, you can register pretty much anything these days
18:13:16 <slack1256> what alternatives to the newtype package exist?
18:13:26 <Lokathor> intothem1untains, http://chimera.labs.oreilly.com/books/1230000000929/index.html you have to read it online, but it's very good, and very useful
18:13:31 <jle`> slack1256: lens has somewhat absorbed the functionality
18:13:40 <intothem1untains> gonna have a look, thanks Lokathor 
18:13:53 <Welkin> geekosaur: yeah, for the right price
18:14:00 <Welkin> which seems to be 50k USD and up
18:14:01 <Myrl-saki> isn't it kinda funny that using `max n` means that the minimum the number can go is n?
18:14:06 <slack1256> oh, I'll check out
18:14:10 <jle`> slack1256: http://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Wrapped.html
18:14:15 <Myrl-saki> I mean, sure, individually, the functions makes sense
18:14:16 <ertes> Lokathor: you can buy that one
18:14:18 <Lokathor> intothem1untains, you can also buy a copy to get a downloadable ebook, but the website isn't that bad even on mobile
18:14:24 <geekosaur> for curses, you should check for something specific because curses itself likes to set a SIGINT handler. also you can put it into a mode where keyboard signals are not generated at all
18:14:36 <jle`> slack1256: it's a somewhat nicer interface than the newtype package, and is consistent with other lensy tools, so it's nice like that
18:14:50 <ertes> but apparently only in electronic formats, so nevermind =)
18:14:54 <Myrl-saki> But it's kinda weird if you're going to use it partial application style.
18:14:54 <jle`> and there's a port of 'ala' too if you just want to stick to the same API as newtype
18:15:09 <Lokathor> geekosaur, yeah, RAW vs CBREAK. I'm using CBREAK for simplicity. I just want a guard against common crashes mostly
18:15:46 <jle`> > ala Sum foldMap [1..10]
18:15:49 <lambdabot>  55
18:15:51 <Welkin> o.o
18:15:53 <Welkin> wtf is ala?
18:16:01 <geekosaur> :t ala
18:16:02 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
18:16:02 <Myrl-saki> :t ala
18:16:04 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
18:16:05 <Myrl-saki> woops
18:16:06 <ertes> Myrl-saki: yeah, i commonly write something like (min 99 . max 0), which is rather confusing =)
18:16:10 <Myrl-saki> oh boi. that sounds awesome.
18:16:10 <slack1256> yeah but the examples with foldMap are really boring. I mean
18:16:13 <jle`> it's a port of the 'newtype' package ala written with lens tooling
18:16:19 <slack1256> > foldMap Sum [1..10]
18:16:19 <intothem1untains> I thought that was ala for "á la" in french
18:16:21 <lambdabot>  Sum {getSum = 55}
18:16:42 <ertes> @let atMost = min
18:16:43 <ertes> @let atLeast = max
18:16:45 <lambdabot>  Defined.
18:16:46 <lambdabot>  Defined.
18:16:50 <Welkin> > getSum $ foldMap Sum [1..10]
18:16:52 <lambdabot>  55
18:16:53 <Welkin> :D
18:16:55 <Myrl-saki> ertes: Thanks. I'll be using that. xD
18:17:29 <ertes> > map (atLeast 0 . atMost 99) [-5, -4, 4, 5, 99, 100, 120]
18:17:31 <lambdabot>  [0,0,4,5,99,99,99]
18:18:08 <jle`> :t ala Sum
18:18:11 <lambdabot> Functor f => ((b -> Sum b) -> f (Sum b1)) -> f b1
18:18:30 <Myrl-saki> Errr
18:18:52 <Myrl-saki> Rewrapped t s, Rewrapped s t
18:18:53 <jle`> ala Sum f = getSum <$> f Sum
18:19:00 <jle`> it basically handles the wrapping and unwrapping for you
18:19:08 <Myrl-saki> jle`: yeah, but how?
18:19:10 <jle`> ala Product f = getProduct <$> f Product
18:19:16 <jle`> like that ^^
18:19:21 <Myrl-saki> jle`: Mmm. I see.
18:19:48 <jle`> Rewrapped/Unwrapped are just typeclaseses and associated types to associate Sum a, a, and getSum
18:19:50 <Myrl-saki> jle`: <$> is for (->) *?
18:19:53 <jle`> Product a, a, and getSum, etc.
18:19:58 <jle`> Myrl-saki: for the case of foldMap, yes
18:20:07 <ertes> @let between x _ y = max x . min y
18:20:08 <lambdabot>  Defined.
18:20:17 <ertes> > map (between 0 and 3) [-2..5]
18:20:19 <lambdabot>  [0,0,0,1,2,3,3,3]
18:20:24 <Myrl-saki> ertes: LOL
18:20:38 <jle`> so Rewrapped is just a typeclass that associates Sum a, a, and getSum ... All, Bool, and getAll ... Endo a, (a -> a), and appEndo
18:20:48 <jle`> it just associates the newtype wrapper, the value inside the wrapper, and the unwrapper
18:20:51 <jle`> nothing too fancy :)
18:20:59 <jle`> s/value inside/type of the value inside
18:21:26 <jle`> it's all just boring typeclass instances
18:21:47 <Myrl-saki> jle`: Why must Rewrapped be commutative(?) though.
18:22:01 <jle`> what do you mean?
18:22:11 <Myrl-saki> jle`: f a b <=> f b a
18:22:26 <Myrl-saki> jle`: it's my first time seeing a typeclass like that.
18:22:34 <jle`> what is <=> ?
18:22:38 <Myrl-saki> iff.
18:22:55 <Myrl-saki> talking about this part.
18:23:05 <Myrl-saki> `Rewrapped t s, Rewrapped s t` or am I reading too deep into that?
18:26:18 <jle`> hm, i think it's just because the actual implementation is more polymorphic than we use it here.  not sure about the exact mechanism
18:26:47 <geekosaur> I think you're reading too much into it. for this particular usage you could get away with one Rewrapped, one Unwrapped, and a ~ relation
18:26:58 <geekosaur> I think
18:27:27 <geekosaur> (or maybe that would require injectivity...)
18:27:48 <Myrl-saki> actually, there's a typeclass exactly for that.
18:27:53 <Myrl-saki> it's called rewrapping.
18:28:08 <jle`> :t ala (Sum . fromInteger)
18:28:09 <lambdabot> Functor f => ((b -> Sum b) -> f (Sum Integer)) -> f Integer
18:29:07 <Myrl-saki> oh
18:29:12 <Myrl-saki> newer does use rewrapping.
18:29:15 <Myrl-saki> ala :: (Functor f, Rewrapping s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
18:29:52 <Myrl-saki> Sorry. I got thrown off by that. xD
18:34:27 <koz_> OK, I'm having *serious* issues making sense of actually using the free (and free-er) monad constructions. I know that what I want to do is exactly the use case, but I'm having trouble even translating something very simple into it.
18:34:40 <johnw> koz_: I can help
18:34:46 <johnw> koz_: can you show me what you have so far?
18:35:17 <koz_> johnw: Basically nothing but the definition of Freer, constructed from kan-extensions and free, which doesn't take much thinking. Let me just write some comments to explain what I'm doing.
18:35:35 <johnw> anything you do with Freer, you can do with just Free to begin with
18:35:58 <johnw> (well, modulo the lack of needing Functor in all the same places)
18:36:11 <johnw> (but until you need that freedom, I'd start with Free to aid understanding)
18:40:25 <ertes> (and you don't need kan-extensions for that…  a church-encoded FreeT is already in the 'free' package)
18:40:34 <lpaste> koz_ pasted “Here is what I wanna do, johnw” at http://lpaste.net/236629
18:40:42 <koz_> Hope that explains what I'm after, johnw.
18:41:28 <squall> Can anyone tell me why this short paste does not terminate? lpaste.net/236627
18:41:39 <johnw> koz_: you're familiar with abstract syntax trees and evaluators?
18:41:46 <slack1256> Mmm I think the newtype package/lens isn't what I need. I would like to reuse functions over Int over a newtype on Int. With generalized newtype deriving if that function is on a typeclass I can use it
18:41:48 <koz_> johnw: Yes, I think so.
18:42:07 <slack1256> what if I don't? remembering the constructor (or having it imported) is a pain
18:42:21 <ertes> squall: line 4 looks suspicious
18:42:53 <ertes> squall: it's non-productive recursion and has no base case, so it's really just an infinite loop
18:43:28 <johnw> koz_: so, Free/Freer is a way to take a term algebra, and turn it into a full DSL permitting all the sentences generated from that algebra.  Then you write an evaluator to reduce these DSL terms, which Free automates by abstracting away the recursion.  What you wrote in your comments sounds more like an algorithm, than an algebra.  So I wonder why you think Free is a "perfect use case"?
18:43:37 <athan> How would you bind a Handle to your current main's stdout?
18:43:40 <squall> I thought I could handle infinite loops...
18:43:49 <athan> non-blocking and concurrently, though - not with hGetContents
18:44:18 <koz_> johnw: Because the other approach that seems correct for implementing this is an increasingly-complex monad transformer stack. Should I do that instead?
18:44:21 <ertes> squall: was that a remark on your privileges or on your skill? =)
18:44:28 <athan> squall: I thought I could handle infinite thought I could handle ... fix fix :|
18:44:48 <johnw> koz_: transformers stacks can be another way of encoding a DSL.  The question to ask is: are you focused on *describing* a computation, or *performing* a computation?
18:44:56 <johnw> if the former, then yes, Free is a great way to reduce boilerplate
18:45:02 <koz_> johnw: You have to describe a computation before you can perform it, though, right?
18:45:11 <squall> take 10 [1..]
18:45:37 <koz_> Because the idea is that I wanna write an interpreter for 'very basic EV', then another for 'EV with logging', and another for 'EV with annealing', etc.
18:45:37 <johnw> sure, but there are descriptions, and then there are abstract families of description.  For example, Get (a -> r) | Put a r is an algebraic description of a terminal
18:45:53 <Zemyla> koz_: Are you familiar with Unlambda?
18:46:01 <koz_> Zemyla: No...
18:46:14 <Myrl-saki> :t (***)
18:46:15 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
18:46:16 <johnw> Free Term a is a DSL for such a terminal algebra, permitting statements Free (Put 10 (Free Put 20 (Free (Put 30 (Pure ())))))
18:46:32 <Myrl-saki> @pl \x -> const x *** const y
18:46:33 <lambdabot> (*** const y) . const
18:46:37 <johnw> koz_: so, describe EV to me in terms of constructors that describe the operations
18:46:49 <johnw> then maybe Free is indeed the way to lift that description into a DSL
18:47:11 <koz_> It's just a chain of state changes with a fixed length. So something like Change s (Change s (Change s (Start a)...) for 3 generations.
18:47:25 <koz_> (sorry, should probably be (Start s a))
18:47:29 <johnw> ok, that does sound like an algebra: Change s r | Start a
18:47:46 <Myrl-saki> :t second
18:47:48 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
18:47:53 <johnw> or, data EVF r = Change s r | Start s a, type EV = Free EVF
18:48:22 <koz_> johnw: OK, that *already* helps. For some reason, I didn't realize that 'Start' needed to be in there...
18:48:31 <ertes> i prefer:  type EV a = forall m. (MonadFree EVF m) => m a
18:48:41 <johnw> then you could have Free (Change s (Free (Change s (Free (Change s (Free (Start s a)))))))
18:49:06 <johnw> or, change s = liftF $ Change s ()
18:49:27 <johnw> start s x = liftF $ Start s x
18:49:33 <koz_> OK, that already helps a lot. I'll try and write that, and check back in when I can. I'll start with Free instead of Freer.
18:49:36 <johnw> change s >> change s >> change s >> start s x
18:49:40 <koz_> (and the non-Church Free, probably)
18:49:48 <johnw> yes, start with the simplest free
18:49:51 <koz_> OK.
18:49:52 <johnw> understand the structures that it's building for you
18:50:01 <johnw> then optimize to church Free, then optimize to Freer
18:50:11 <johnw> and by then, the reason for those optimizations should become clear by working with them
18:50:14 <Zemyla> koz_: Well, never mind. Just remember that a Haskell program can assemble a computation directly instead of just a description of one.
18:50:25 <ertes> another side note: if you put the response field first, most functions of your new monad are easier to implement
18:50:46 <ertes> data EVF r = Change r S | …
18:50:59 <ertes> change = liftF . Change ()
18:51:03 <johnw> right, the "mtl style" is yet another way of encoding DSLs that can eliminate the build/evaluate steps
18:51:10 <johnw> there are lots of ways to achieve the problem
18:51:41 <johnw> the nice thing about working with Free to begin with is that you'll come to understand how all of these approaches to algebraic abstraction relate
18:51:51 <koz_> johnw: That's why I wanted to do this for this particular task.
18:52:09 <Zemyla> And speaking of Unlambda, I've decided it'll be easier for my Unlambda compiler to create an infinite trie containing every possible program and its optimized representation than trying to keep updating a map with what it's seen so far.
18:52:10 <johnw> I personally think it's one of the power tools in the Haskeller's toolbox
18:52:14 <koz_> Also, should it be 'EVF r = ...'? GHC doesn't like that very much.
18:52:21 <johnw> which optimization you reach for is a secondary question
18:52:37 <koz_> Because I have s and a in there also.
18:52:41 <johnw> EVF is your term algebra; EV = Free EVF is your DSL
18:52:52 <ertes> koz_: EVF a s r = …
18:52:55 <johnw> right
18:53:04 * hackagebot result 0.2.6.0 - Encode success or at least one error  https://hackage.haskell.org/package/result-0.2.6.0 (srijs)
18:53:07 <koz_> ertes: I thought so - I just wanted to check if I was missing something obvious.
18:53:45 <koz_> OK, so now, I need to make EVF a functor?
18:53:48 <Zemyla> Oh, koz_, I thought of an example for the difference between description and computation.
18:53:56 <koz_> (well, EVF s r, I guess)
18:53:58 <Zemyla> Are you familiar with the State monad?
18:53:59 <johnw> koz_: yes, DeriveFunctor will make that trivial
18:54:03 <ertes> koz_: the important thing is that it's a functor on the "response type" or "recursion point type"
18:54:06 <johnw> data EVF = ... deriving Functor
18:54:24 <johnw> Functor should be the *only* instance you ever need to derive too, aside from maybe Show for debugging
18:54:46 <koz_> johnw: Yeah, figures.
18:54:47 <johnw> for writing evaluators, use "iter"
18:54:54 <ertes> and for most interesting monads Show isn't even possible, so… =)
18:56:01 <koz_> johnw: In this case, I assumed I'd want iter.
18:56:18 <johnw> koz_: cool, you're on your way :)
18:56:36 <koz_> johnw: So, with iter, I need to give it a way to turn a term into a value?
18:56:51 <johnw> yes, f a -> a
18:57:03 <koz_> And there's two cases - Pure and Free?
18:57:11 <johnw> no, Pure and Free are not part of it
18:57:15 <johnw> those are taken care of for you
18:57:16 <Zemyla> ertes: I was going to say that Show is always possible, but then I realized that there are cases where it literally isn't.
18:57:22 <koz_> Wait, sorry, they will be Start and Change?
18:57:26 <johnw> you have to say what f a -> a means for Change and Start
18:57:38 <koz_> johnw: OK, let me just try to do that.
18:57:50 <johnw> what's handy here is that the f a -> a (aka, f-algebra) that you pass to iter is almost always non-recursive
18:58:12 <Zemyla> For instance, (Integer -> Bool) -> Bool.
18:58:14 <johnw> compared to traditional, non-Free based recursive type DSLs
18:58:18 <koz_> Well, in my case, it would be, right? Because to process a Change, I need to process whatever it's changing first?
18:58:35 <johnw> koz_: remember that Change has a recursion parameter
18:58:49 <johnw> so you'll have access to the "subsequent" evaluation result
18:58:55 <johnw> Change s r <--
18:59:19 <Zemyla> Or even just Integer -> Bool.
18:59:30 <ertes> it may be useful to see the similarity between Free and Fix, and between 'iter' and 'cata'
18:59:34 <koz_> johnw: Ah, I see.
19:00:06 <johnw> and if needed, you can use hoistFree to inject other information, by enriching your functor, but you probably won't need that
19:00:47 <koz_> OK, now I have to write the 'what to do with 'Change'', and it's already confusing me. This is the bit that actually does each step of EV, right?
19:01:00 <johnw> that's up to you
19:01:02 <koz_> However, s is completely arbitrary - how can I pull random values out of it, for example?
19:01:13 <johnw> defining an f-algebra is assignment semantics to your data type
19:01:19 <johnw> assigning*
19:01:37 <johnw> you can specialize 's'
19:01:43 <johnw> no one said your use of iter had to be fully general
19:01:49 <koz_> Oh, derp, of course...
19:02:08 <koz_> In this case, it has to be an instance of 'thing I can pull random values out of'.
19:02:41 <koz_> RandomGen, right?
19:02:42 <johnw> then requrie a (s -> randomThingsType) function, or Lens' s randomThingsType
19:03:24 <Myrl-saki> ertes: I think I should work use Lens if I want to work with These.
19:04:15 <johnw> koz_: now, if you need to *generate* random values, *during* evaluation, you'll need iterM
19:04:26 <johnw> with MonadRandom m =>
19:04:57 <johnw> if you want to generate random values while constructing DSL terms, you'll need MonadRandom m => FreeT EVF m
19:05:03 <ertes> Myrl-saki: why?
19:05:10 <Myrl-saki> ertes: ble for use with Control.Lens.
19:05:11 <Myrl-saki> Err
19:05:13 <johnw> (or, FreeT (EVF s a) m)
19:05:31 <Myrl-saki> ertes: Wait.
19:05:40 <Myrl-saki> I don't know how to work with PRIMARY on Emacs.
19:05:56 <squall> What is IterT?
19:06:05 <johnw> that's iter for FreeT
19:06:15 <Myrl-saki> dirx <- holdFor 1 0 -< mapThat (const 1) <$> e
19:06:29 <koz_> johnw: OK, am I on the right track here? runEV :: (RandomGen g) => EV g r a -> g -> a -> a
19:06:33 <Myrl-saki> ertes: I've been throwing a shittonne of const in my code. D
19:06:35 <Myrl-saki> xD
19:06:40 <Myrl-saki> ertes:   (x', d) <- scan (x, 0) -< mergeTheseWith (second . subtract) (\x -> const x &&& const t) const <$> e
19:07:00 <johnw> koz_: I'm not sure what RandomGen requires, or what the semantics of EV are
19:07:07 <johnw> code it, see if it works out
19:07:12 <ertes> squall: it's a special FreeT that really only allows you to set "breakpoints"
19:07:23 <johnw> oh, IterT, not iterT :)
19:07:29 <ertes> squall: (IterT IO) is "IO with breakpoints"
19:07:44 <squall> :t Control.Monad.Trans.Free.wrap
19:07:46 <lambdabot> Control.Monad.Free.Class.MonadFree f m => f (m a) -> m a
19:07:51 <koz_> johnw: The thing is, I'm actually trying to understand how to code it.
19:07:58 <squall> What's that?
19:08:19 <johnw> koz_: just keep trying to draft it out; first know what kind of outputs you expect from your inputs to the evaluator
19:08:58 <ertes> Myrl-saki: that code is really hard to read
19:08:59 <squall> Oh it's just the constructor sorry
19:09:03 <Myrl-saki> ertes: Exactly.
19:09:26 <ertes> Myrl-saki: i'm trying to figure out what you're trying to do
19:09:40 <Myrl-saki> ertes: xDD
19:09:43 <Myrl-saki> ertes: https://gist.github.com/340afec65a11864bf3875dceb4104e88
19:09:50 <Myrl-saki> ertes: Holds for a duration.
19:11:02 <squall> I don't understand about monad transformer laws for FreeT
19:11:13 <johnw> squall: how so?
19:11:52 <squall> Not sure about the difference between lift and liftF
19:11:59 <johnw> another way of thinking of FreeT is data FreeT f m a = FEffect (f (FreeT f m a)) | MEffect (m (FreeT f m a)) | Pure a
19:12:07 <ertes> Myrl-saki: the interface to that is a bit suspicious…  why not take two events?
19:12:09 <johnw> liftF makes an FEffect; lift makes an MEffect
19:12:38 <Myrl-saki> ertes: I'd like to take advantage of These.
19:12:58 <Myrl-saki> ertes: Though, honestly, I should probably be using a reader monad.
19:13:00 <ertes> Myrl-saki: (Event a, Event b) ≃ Event (These a b)
19:13:12 <Myrl-saki> s/a/the/
19:13:23 <Myrl-saki> ertes: Yeah.
19:13:28 <ertes> Myrl-saki: also remember that Event has an Align instance
19:13:40 <squall> So this is kind of like Free with 2 different functions that can be used interchangeably?
19:13:43 <Myrl-saki> ertes: Mhm.
19:13:50 <Myrl-saki> ertes: That's how I got these.
19:13:53 <koz_> johnw: I have this so far: http://lpaste.net/236670 . Now, how would I actually construct an EV? Like, my goal is to have something like 'Step s (Step s (Step s (... (Start s a)...)' as the result, but I'm not completely sure how Free fits into all this.
19:14:03 <johnw> squall: it's Free that can include effects from m, as well as effects from f
19:14:14 <squall> Is that how monad transformers work?
19:14:17 <johnw> it's just Free where the 'f' is a coproduct of m and f
19:14:40 <squall> coproduct?
19:14:57 <squall> Like Either?
19:15:02 <johnw> yeah, functoral either in this case
19:15:11 <johnw> usually called like :+: or something
19:15:16 <johnw> Free (f :+: m) a
19:15:23 <squall> yuck
19:15:50 <squall> I can't see how you would write join
19:15:54 <ertes> Myrl-saki: honestly i'd just write two scans there
19:16:13 <ertes> event simultaneity is well defined, so you can rely on it
19:16:13 <Myrl-saki> ertes: I see. Makes sense, yeah.
19:16:43 <johnw> squall: try writing it :)
19:17:10 <squall> I found it
19:17:15 <johnw> koz_: define helper functions: step s = liftF $ Step s ()
19:17:31 <koz_> Let me just check what liftF does.
19:17:31 <johnw> then just use the monad provided by Free: step 1 >> step 2 >> step 3, etc.
19:17:36 <Myrl-saki> ertes: BTW, why does hold use a function?
19:17:46 <johnw> liftF (Step s ()) is the same as writing Free (Step s (Pure ()))
19:17:57 <Myrl-saki> ertes: As opposed to hold/holdWith, where hold is a specialize version of holdWith that uses const.
19:18:10 <squall> It only requires one parameter is a Monad, that seems strange
19:18:25 <johnw> squall: only the 'm' needs to be a monad; the other is just a Functor
19:18:31 <squall> There must be since asymmetry
19:18:39 <squall> Some*
19:18:46 <johnw> it's intentional that f (f a), as encoded by Free, is never 'collapsed'
19:18:49 <ertes> Myrl-saki: what's holdWith?
19:19:05 <johnw> where any occurence of m (m a) within an encoding by FreeT, should be by join
19:19:27 <Myrl-saki> ertes: holdWith is the current hold.
19:19:40 <Myrl-saki> err...
19:19:42 <Myrl-saki> wait.
19:19:51 <Myrl-saki> ertes: I mean scan. xD.
19:19:55 <Myrl-saki> OHHH
19:19:57 <Myrl-saki> wait. I'm stupid.
19:20:23 <koz_> johnw: I'll need FlexibleContexts to write that, no?
19:20:31 <Myrl-saki> ertes: Just... ignore that. I should drink some more water. I'm mixing up a lot of things.
19:20:32 <johnw> koz_: you shouldn't need that
19:20:39 <ertes> hehe
19:21:16 <koz_> johnw: Then I'm horribly confused again.
19:21:30 <johnw> koz_: whenever you get stuck, show me a paste
19:21:34 <squall> :t FreeT . return . Wrap . (fmap return)
19:21:36 <lambdabot> error:
19:21:36 <lambdabot>     Data constructor not in scope: FreeT :: m0 a0 -> c
19:21:36 <lambdabot> error:
19:21:40 <koz_> johnw: OK, I'll try.
19:21:40 <johnw> koz_: you're SO close to the lightbulb moment, I can feel it :)
19:22:24 <squall> What's the Church version all about?
19:22:32 <johnw> it gets rid of the constructors
19:22:43 <johnw> at the cost of removing the ability to case analyze constructors
19:22:45 <squall> Seems drastic
19:22:55 <johnw> yeah, but it hecka improve performance
19:22:58 <johnw> can*
19:23:02 <squall> Oh cool
19:23:05 <johnw> one kind of performance, that is
19:23:10 <squall> And Freer?
19:23:23 <johnw> Freer defers the Functor requirement to evaluation time
19:23:35 <squall> !?
19:23:42 <koz_> johnw: http://lpaste.net/236670
19:23:51 <koz_> johnw: I *know* I'm close.
19:23:51 <squall> Haskell is kind of insane sometimes
19:24:01 <johnw> it uses a Coyoneda embedding to stand in place of needing to know it's a functor during construction of the Freer terms :)
19:24:07 <johnw> squall: indeed :)
19:24:15 <koz_> I can feel it, but I'm missing something obvious.
19:24:30 <johnw> koz_: start x a = liftF (Start x a)
19:24:38 <johnw> Start has no recursion argument
19:24:52 <squall> Oh no, not a Coyoneda, I'm out...
19:25:25 <koz_> johnw: Oh, right.
19:25:26 <johnw> Coyoneda in this case means "acts like a functor, and must be *at reduction time*, but don't need the details until then"
19:25:57 <ertes> church already does that though
19:26:19 <squall> I have no clue how it is helpful to defer implementation to runtime...
19:26:19 <koz_> johnw: The typechecker is still insisting on FlexibleContexts. Let me paste the error as well.
19:26:50 <ertes> squall: it's mostly an efficiency/performance thing with the extra generality being a nice bonus
19:27:04 <johnw> ertes: ah, right, thanks
19:27:28 <johnw> squall: Oleg has a paper that describes the merits of Freer
19:27:59 <squall> Or even how it's useful. When do I have a functor that's only a functor at runtime? It seems most bizarre, am I confused?
19:28:05 <koz_> johnw: http://lpaste.net/236670
19:28:18 <johnw> ertes: church still needs 'f' to be a Functor for liftF; I think Freer doesn't need it until later
19:28:56 <ertes> squall: a functor is a functor…  the question is whether some functions (like (>>=)) need a it to be a functor or can go without that knowledge
19:29:05 <johnw> squall: you can make, for example, IORef appear to be Functor-like
19:29:40 <squall> Thanks etres, that actually makes sense, especially in the context of Free
19:30:13 <johnw> koz_: let me try this here, one sec
19:30:50 <johnw> koz_: just use this: start x y = Free (Start x y)
19:31:01 <johnw> the lack of a recursion argument, and of a type signature for 'start', is messing with you
19:32:12 <squall> So because Free has an intuitive join and return, regardless of the Functor constraint on the parameter, something something, speed increase
19:32:18 <johnw> squall: the Coyoneda embedding is really just a tuple of the two arguments to fmap: the 'f a' value and the function to be passed to fmap.  As a functor, "fmap" is defined by simple composition.  It's not until later, when you need to apply that function, that you either (a) need to know it's a Functor, or (b) need to know the exact type to perform the equivalent operation (such as in the case of IORef)
19:32:48 <koz_> johnw: OK, thanks!
19:33:50 <ertes> johnw: liftF for (FT f m) doesn't seem to require (Functor f) either
19:33:50 <squall> Hmm, I wrote a class Folder, which required a tuple of base case, associative function, list. Could i use some magic here?
19:33:51 <johnw> squall: http://okmij.org/ftp/Computation/free-monad.html
19:34:32 <johnw> ertes: I was looking at the docs for Control.Monad.Free.Church.liftF
19:34:49 <johnw> ertes: in the most recent version of 'free', Ed actually applied the Freer trick
19:35:03 <johnw> in order to get better optimization from GHC 7.10 when the roles support went it
19:35:22 <johnw> ertes: it happened here: https://github.com/ekmett/free/issues/86
19:35:37 <squall> Omg Freer monads are blowing up in here
19:35:40 <johnw> yada yada, Mendler-style catamorphism
19:36:04 <johnw> he only did this for the transformer version, though, not the non-transformer one
19:36:26 <squall> https://wiki.haskell.org/Catamorphisms#Mendler_Style
19:36:41 <ertes> yeah, i saw that change when it happened and was at first puzzled, but then i saw the generalised MonadFree instance that went with it
19:36:44 <johnw> squall: exactly
19:38:57 <squall> I need new eyes, these ones are broken now. Can anyone recommend a booktape I can listen to while sleeping... I think I would have more confidence I could climb a mountain than understand all this stuff. I think if it was lain out more clearly I could at least see the extent of this learning task
19:38:58 <koz_> johnw: OK, let me try this another way. Suppose I have an s and an a, and I wanna make an EV out of it that doesn't do any Step, just Starts.
19:39:08 <koz_> How would I write this?
19:39:26 <johnw> koz_: your current algebra does not allow this
19:39:39 <EvanR> this is not the algebra youre looking for
19:39:48 <johnw> it presently allows either 1 or 0 Starts
19:39:59 <koz_> 0 Starts makes no sense.
19:40:18 <johnw> when you use Free there is always the "pure" case, meaning no effects from 'f'
19:40:36 <johnw> if you don't want that, then you might need Fix instead
19:40:41 <koz_> Fix?
19:40:46 <johnw> Fix is Free without the Pure case
19:40:55 <johnw> which would force exactly 1 use of Start, in your case
19:41:08 <koz_> johnw: OK, where would I find Fix?
19:41:17 <johnw> "any number of Steps, then a Start"
19:41:41 <squall> Id like to use Fix to handle tying the knot
19:42:07 <johnw> newtype Fix f = Fix { unFix :: f (Fix f) }
19:42:16 <koz_> johnw: Is there a library providing Fix?
19:42:17 <johnw> i actually don't know of a good library that provides this type....
19:42:23 <koz_> Really? OK then.
19:42:23 <johnw> many do, but they all come with lots of other stuff
19:42:42 <johnw> maybe data-fix 
19:42:44 <johnw> that's small
19:42:58 <johnw> yeah, that's what you want
19:43:05 <johnw> now instead of using iter, you use cata
19:43:13 <johnw> or cataM, depending
19:43:23 <koz_> johnw: OK, I'm looking at it right now.
19:43:32 <squall> Then you get hylo eventually right?
19:43:34 <johnw> yes
19:43:43 <johnw> and lots of great educational resources on recursions schemes
19:43:49 <squall> Oooh that's the bit I like
19:43:52 <johnw> which Free is really just a subset of
19:44:04 <johnw> start here: , recursion-chemes
19:44:11 <johnw> https://www.youtube.com/watch?v=Zw9KeP3OzpU
19:44:18 <koz_> johnw: OK, let me try using that instead.
19:44:21 <squall> Did you see my Free CoMonad johnw?
19:44:27 <johnw> squall: no
19:45:06 <squall> http://lpaste.net/194212
19:46:21 <koz_> johnw: This package makes ... a lot more sense to me.
19:46:55 <squall> It's much faster than random access data structures like Map or Vector for granular problems, where information on "directed navigation" is used intensively over "random access"
19:47:02 <johnw> koz_: Free f a = Fix (Compose (Either a) f)
19:47:30 <squall> Can I get a high 5?
19:47:32 <johnw> it's just the least defined fixpoint of f with an option for "exiting with a value"; but this a monad makes
19:47:45 <johnw> squall: cool; why is it Free and not Cofree?
19:48:25 <squall> Many f single a
19:48:41 <johnw> ah
19:48:44 <johnw> great explanation :)
19:48:47 <squall> Like nested lists, only a in the lowest level
19:49:28 <squall> But such a nice duplicate
19:49:42 <koz_> johnw: I think I'll stick to figuring out what I've got with Fix.
19:49:56 <johnw> koz_: sounds good!
19:50:00 <squall> Presents the nd navigable list at each location
19:50:31 <squall> So is contained in a structure of the same shape
19:50:34 <jle`> is there a Snoc List type somewhere in a common library?
19:50:44 <koz_> johnw: It seems like Fix was more like what I needed, actually.
19:50:53 <squall> I guess i should look into making it Freer...
19:51:25 <johnw> koz_: note that with Fix, you get a Functor, but not a Monad or Applicative.  The burden is on you to make those
19:51:59 <koz_> johnw: OK, do I understand correctly that I can describe EV as a hylomorphism?
19:52:14 <koz_> It seems like I ana out to make the generation chain, then cata it down into the final answer.
19:52:15 <johnw> EV is not the hylomorphism
19:52:25 <squall> It's unfold
19:52:36 <johnw> a hylomorphism is when you apply both a fold and unfold to an EV
19:52:50 <johnw> "ana followed by cata"
19:53:16 <koz_> johnw: From what I can see by the types, ana requires a way of expanding an a into an EV a, and a starting a.
19:53:30 <koz_> (sorry, EVF a)
19:53:32 <johnw> yep, it's an unfold
19:53:50 <johnw> building an EV from a seed, if you will
19:53:57 <squall> I dont get about the fixed point business, i could use it to remove the nasty Eq constraints in my post maybe...
19:54:00 <koz_> johnw: So this is exactly the first part of what I need to do.
19:54:31 <koz_> Then, after that, to 'run' the EV computation, I basically have to 'collapse' the entire EV into the final value, which sounds like a cata to me.
19:54:38 <koz_> So how is this process *not* a hylomorphism then?
19:55:01 <johnw> hylo just combines the two steps into one
19:55:06 <johnw> EV itself is not the hylo
19:55:12 <squall> repeat is a good unfold, if your datatype is like List then you can just fold a list generated with repeat using your constructor
19:55:22 <johnw> EV is the intermediate structure used by the hylo
19:55:31 <koz_> johnw: OK, I guess we were talking about different things. I meant 'EV the algorithm', you meant 'EV the structure'.
19:55:37 <johnw> right
19:55:38 <koz_> In that case, yes, you're right, and sorry I wasn't being more clear.
19:55:56 <johnw> algebra vs. semantics aka evaluator
19:56:15 <koz_> johnw: How would I control the expansion of the ana part? I only want it to expand to a fixed 'length' of the Fix, but from the description, it seems like it would expand forever.
19:56:17 <squall> If your structure is unbranched, why not use List?
19:56:37 <johnw> at the very end of a lot of type explorations... lies a simpler type :)
19:56:40 <johnw> but the exploration is worthwhile
19:57:06 <koz_> squall: Because each element depends on the previous one? Although I guess I could just use unfoldr....
19:57:41 <johnw> i'm out, guys; good luck!
19:57:47 <koz_> johnw: Thanks!
19:57:48 <squall> you would still need to implement choose
19:58:07 <squall> Oh no that's Unfolder, sry
19:58:22 <cath_> I have a question of Ghc options and threads.  I'm using the paralell-io package to work with a pool of threads:  withPool (128) $ \pool -> parallel pool (fmap f l).  if I want to actually use a pool of 128 threads, do I have to pass ghc the -N128 flag?
19:58:24 <koz_> squall: So you reckon I should just use unfoldr rather than Fix?
19:58:44 <squall> I would recommend using []
19:58:54 <squall> And using repeat
19:59:21 <squall> Was your type isomorphic to List?
19:59:29 <EvanR> use -N128 if you have 128 processors or cores
19:59:42 <cath_> cool, thanks
19:59:52 <koz_> squall: I'm gonna think abotu this some more and try again.
20:00:05 <EvanR> thats the number of capabilities, and only one capability can run on a given core at a time, regardless of how many threads you spawn
20:00:45 <cath_> Right, ok.  I was just uncertain if the flag handled cores or threads.  thanks!
20:01:19 <squall> EVR looks a lot like Free
20:01:28 <squall> So EV seems redundant
20:03:28 <koz_> squall: I'm gonna try and do it with simpler mechanisms now, before I decide if I need to power it up any.
20:03:37 <koz_> All this has basically made me realize I was probably overthinking it.
20:04:24 <squall> I'm totally confused about what your doing with that
20:04:45 <squall> The Free only appears within Start, right?
20:05:02 <squall> As 'a'
20:05:23 <squall> Which seems wrong...
20:05:52 <squall> I'm confused, I guess id need to understand what you were trying to do...
20:06:09 <koz_> squall: Let me paste a description of what I'm trying to actually do: http://lpaste.net/236748
20:08:48 <squall> Thanks
20:09:26 <koz_> I'm open to all suggestions as to how to do this - my initial thought would be that I'd need monad transformers.
20:09:42 <koz_> But for now, I'm just trying to implement the simplest of these (which relies on random state only).
20:10:17 <squall> Can't you just repeatedly act on a list?
20:11:04 <squall> Or something with better random access like Vector?
20:11:19 <squall> What's with all the monads?
20:11:33 <koz_> squall: I was gonna use Vector, but I'd need to maintain a lot of additional state, potentially.
20:11:41 <koz_> Like, at the *very* least, an RNG.
20:12:08 <squall> RandomR?
20:12:42 <koz_> squall: I could start with defining it as a 'Rand g (Vector a)', but then later, I'd want Writer-based logging of the changes made at each step, for example.
20:12:53 <Myrl-saki> ertes: Isn't Event a valid Alternative?
20:12:56 <EvanR> look again and what you once knew as a state has been stateless the whole time
20:13:11 <koz_> But anyway, I think I'll just ponder this some more. Obviously I'm over-complicating things.
20:13:24 <squall> I mean why are you composing parameterized types rather than functions?
20:14:35 <squall> Do you wish that your datatype instantiates  some class?
20:14:48 <EvanR> "there is no state" -- neo learning haskell
20:14:55 <koz_> squall: What I wish is precisely what I've described in said comments.
20:15:01 <koz_> (like, the ones I linked)
20:15:10 <koz_> I am at this point honestly not sure what I should or should not be doing.
20:15:30 <squall> That alone does not seem to indicate additional requirements over list
20:15:58 <squall> Certainly it is possible to implement your algorithm on list
20:16:18 <koz_> Alrighty, as I said, I'll go think on it. I suspect I'm not being clear, which probably means I'm not thinking clearly.
20:16:24 <squall> Accessing a random element and concatenating a modified result
20:17:05 <squall> Can be written as a function on lists
20:17:54 <ertes> Myrl-saki: no, because it's not a valid Applicative
20:18:04 <Myrl-saki> ertes: Oh.
20:18:17 <squall> The real important point is that List is very similar to Free, and actually all countable sets are isomorphic to list.
20:18:23 <Myrl-saki> ertes: But it's an Alt with an empty though, doesn't it?
20:18:38 * EvanR hmms at that
20:18:43 <ertes> Myrl-saki: yeah, it's a Plus
20:18:46 <Myrl-saki> ertes: Ohh
20:19:02 <Myrl-saki> ertes: Thanks. :D
20:19:33 <Myrl-saki> @pl \x -> +x*y
20:19:33 <lambdabot> (line 1, column 7):
20:19:33 <lambdabot> unexpected "+"
20:19:33 <lambdabot> expecting lambda abstraction or expression
20:19:37 <Myrl-saki> Eh.
20:19:53 <Myrl-saki> @pl \x -> (+y*x)
20:19:54 <lambdabot> (+) . (y *)
20:20:01 <Myrl-saki> @pl \x -> (+x*y)
20:20:01 <lambdabot> (+) . (y *)
20:20:10 <EvanR> all countable sets are isomorphic to all other countable sets, in Set, but that seems useless
20:20:17 <Myrl-saki> oh cool. it takes advantage of commutativity. :o
20:20:58 <EvanR> and morally, infinite lists of something might not be countable
20:22:21 <squall> Perhaps a simpler approach will allow me to communicate what I mean... As Tree is Foldable, why use a Tree instead of a List? For faster directed access?
20:24:03 <joe9> need some advice, please? I want to replace a C library on linux with my own haskell library. I plan on linking the old library to my new library and then ensure all the function definitions in the include .h file using ffi.
20:24:21 <squall> How is that different from sequencing with a function on lists describing tree like construction?
20:24:28 <joe9> s/file using ffi/file are defined using ffi/
20:24:31 <EvanR> writing a C library in haskell eh
20:24:33 <joe9> Would that wokr?
20:24:52 <EvanR> that will be a pretty huge dll
20:25:07 <EvanR> access it from C will necessarily spin up ghc runtime
20:25:18 <joe9> EvanR: yeah, the C library is pretty old and is a pita to understand and change.
20:25:51 <joe9> EvanR: It is a pure lookup code and the core functionality is pure haskell (no IO, just for ffi)
20:26:03 <joe9> EvanR: will it be unusable?
20:26:21 <EvanR> the only part of this im not sure about is how easy it is to generate linkable shared libraries, which ive never done
20:26:21 <joe9> EvanR: I do not care about the size (linux, so .so, correct?)
20:26:35 <joe9> EvanR: I got that part working.
20:26:39 <cath_> I how can I resolve needing two executables?  My cabal file specifies the correct main-is information, but cabal won't copy the second because its module name isn't Main.  But then it can't be because I already have a module named Main.
20:26:40 <EvanR> haskell is usually statically linked
20:26:56 <EvanR> sounds like you got it then
20:26:58 <joe9> EvanR: https://github.com/joe9/skb
20:27:32 <joe9> EvanR: I just want to make sure that relinking the .so file is enough or if I need to do something more.
20:27:47 <EvanR> i dont know
20:30:06 <squall> I like that using build I can bypass expensive construction functions which don't contribute to a fold
20:31:19 <squall> Since eg, a Tree is constructed sequentially, it can basically be handled as a list composed with a different symbol than (:)
20:31:33 <Myrl-saki> welp. rip.
20:32:07 <EvanR> long live welp
20:32:48 <Myrl-saki> game: thread blocked indefinitely in an MVar operation
20:32:50 <Myrl-saki> ;~;
20:33:22 <EvanR> it seems that youre trying to do untyped concurrent programming
20:33:38 <EvanR> would you like a paper about typed concurrent programming
20:34:00 <squall> Me?
20:34:24 * geekosaur managed to read that as clippy...
20:34:37 <Myrl-saki> lol
20:35:12 <dmiles> anyone using Haskell in EclipseFP ?  the plugin seems to always be in Starting mode
20:36:10 <geekosaur> huh, I thought eclipsefp was dead
20:36:39 <dmiles> it might be.. perhaps i should use the 3.7 and not 4.6
20:36:44 <geekosaur> (I mean, I just looked it up and it's resuscitated at least, but I don't recall seeing an announcement)
20:38:15 <Myrl-saki> Oh.
20:38:22 <dmiles> yeah it may not being improved 
20:38:22 <Myrl-saki> I think I know what's happening.
20:38:40 <Myrl-saki> Yeah. I know what's happening.
20:39:12 <squall> Does anyone know how to make this work? http://lpaste.net/236627
20:42:03 <Myrl-saki> https://gist.github.com/6a7961ab6b0a5cb389a835ba885c3cf5
20:42:23 <Myrl-saki> ertes: game: thread blocked indefinitely in an MVar operation
20:44:15 <Myrl-saki> ertes: What's the proper way to have done that?
20:44:43 <Myrl-saki> ertes: I was thinking of having an onGround :: Wire m a ()
20:44:50 <Myrl-saki> ertes: And use <!>
20:46:08 <Myrl-saki> Err
20:46:12 <Myrl-saki> ertes: Wire m a (Event ())
20:46:20 <squall> It's ok I figured it out, http://lpaste.net/236627
20:46:41 <EvanR> hehe http://lpaste.net/diff/236627/236812
20:47:03 <EvanR> there were 200 posts since your original and the fix
20:47:33 <EvanR> im going with automated spam
20:47:51 <squall> This saddens me
20:49:23 <squall> Eggs and spam...
20:50:44 <koz_> OK, I think I have it.
20:51:36 <koz_> squall: Please could you have a look and make suggestions/comments? http://lpaste.net/236821
20:51:46 <koz_> (sorry if the function signatures are a bit misaligned)
20:52:22 <ertes> Myrl-saki: is that the full rec-block?
20:52:40 <Myrl-saki> ertes: yep.
20:53:23 <Myrl-saki> ertes: https://gist.github.com/Myrl/674d9bc79cf7cc96e661cd88ef1d3710
20:53:59 <koz_> There's a few things in that I would like some advice on improving.
20:54:34 <koz_> Most notably: 1) Is there a better way to write what I want than foldM? I don't end up using the list items in any way whatsoever. 2) Having to take my structure apart like that is upsettingly verbose. 
20:55:10 <squall> Looks good
20:55:36 <ertes> Myrl-saki: that's weird…  cooperating scans should never cause that…  or maybe the error is somewhere else
20:55:41 <koz_> squall: Only took me about a zillion detours to get there... :P
20:55:46 <Myrl-saki> ertes: I should send the whole file
20:56:20 <Myrl-saki> ertes: https://gist.github.com/acbf07556828a057b40c0fbe1ae82f98
20:56:56 <Myrl-saki> ertes: Removing the mutual dependency makes it work.
20:57:05 <koz_> squall: Is there a better choice for what I'm doing there than 'foldM, then ignore the list elements'?
20:57:07 <squall> I don't understand what you mean about foldM... Won't garbage collection take care of that?
20:57:16 <koz_> squall: It just seems kinda ugly.
20:57:40 <koz_> Like, I don't really need to fold a list - I just wanna loop the monadic computation into itself n times.
20:57:53 <squall> Use a decrementing counter?
20:58:14 <squall> Int seems appropriate here
20:59:43 <koz_> squall: Could you please show me?
20:59:50 <EvanR> koz_: replicateM with Cont?
21:00:21 <squall> :t \ f n -> last.(take n).(iterate f)
21:00:22 <lambdabot> (c -> c) -> Int -> c -> c
21:00:36 <koz_> :t iterate
21:00:38 <lambdabot> (a -> a) -> a -> [a]
21:01:00 <squall> @src iterate
21:01:00 <lambdabot> iterate f x = x : iterate f (f x)
21:01:26 <squall> I guess you could adapt that to include take
21:01:33 <koz_> squall: That won't work with my function - it has type (a -> m a), not (a -> a).
21:01:37 <squall> @src take
21:01:37 <lambdabot> take n _      | n <= 0 = []
21:01:37 <lambdabot> take _ []              = []
21:01:37 <lambdabot> take n (x:xs)          = x : take (n-1) xs
21:01:45 <ertes> Myrl-saki: that sounds like a bug in wires…  cooperating scans should *never* do that
21:01:53 <squall> That's the decrementing counter i meant
21:01:57 <ertes> Myrl-saki: i'll look into it after i got some sleep
21:02:16 <Myrl-saki> ertes: Okay, thanks. I'll take a look at it myself.
21:02:35 <squall> So you could wrote it using bind?
21:02:40 <koz_> squall: I guess I meant 'could you show me how you would write the thing I use foldM for without having to have a throwaway list like that'.
21:02:55 <koz_> Like, I just wanna know how I can do something like that without needing foldM and a throwaway list.
21:03:02 * koz_ is surprised there's no built-in for this.
21:03:43 <ertes> Myrl-saki: thanks for your inadvertent bug report =)
21:03:43 <Ucenna> Had a question
21:03:55 <squall> Probably you mean foldM_
21:04:15 <squall> @src foldM_
21:04:15 <lambdabot> foldM_ f a xs = foldM f a xs >> return ()
21:04:38 <squall> Hmm
21:04:45 <squall> That's not what I expected
21:04:54 <Ucenna> Been doing some functional javascript, is array.push() considered mutating?
21:04:56 <koz_> squall: My point exactly.
21:05:08 <squall> Nice
21:05:11 <koz_> Ucenna: This seems like an odd channel for such a question.
21:05:38 <Myrl-saki> ertes: BTW, is there a way to convert something into an Evnet?
21:05:44 <Ucenna> koz_: Perhaps, I don't know where else to ask. And everyone here programs functionally...
21:06:05 <koz_> Ucenna: What does array.push() do exactly?
21:06:23 <Myrl-saki> ertes: :: ... -> Wire m a b -> Wire m a (Event b)
21:06:33 <Ucenna> koz_ sorry, it adds a value to the end of an array. x.push("apple")
21:06:54 <tefter> Ucenna what does x.push returns?
21:07:05 <squall> @src sequence_
21:07:05 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
21:07:23 <Ucenna> tefter: I'm confused. It's not a function, so it doesn't return anything?
21:07:43 <tefter> so you have your array with apple at and, that's mutating
21:07:57 <Ucenna> Okay :/
21:08:10 <Ucenna> I'll have to seek a different method then, thanks!
21:09:02 <Ucenna> The thought was that x[1] might = orange, and x[2] after the push = apple. Is that considered creating a new 'variable' or mutating an array.
21:09:32 <koz_> Ucenna: A good rule of thumb - if it doesn't return, it's probably not functional.
21:10:31 <squall> So your point was that you wanted to store the Int state in the datatype, so you could write a function to increment the seed stored in the type no?
21:10:36 <Ucenna> Okay.
21:10:48 <Myrl-saki> ertes: Yep. Repeated testing. Same results.
21:27:34 <Myrl-saki> oh wow.
21:28:04 <Myrl-saki> back to functors(contravariant, to be exact) and turns out I don't understand anything at all.
21:31:45 <joe9> from a .hsc file: https://paste.pound-python.org/show/fRNIW7g9hy43cTihiaR7/
21:32:10 <joe9> how does the <enum xkb_keysym_flags> translate to a haskell type?
21:32:14 <joe9> Is it an Int?
21:32:39 <ertes> Myrl-saki: 'newEvent' and 'never' are the only ways to create root events
21:33:01 <Myrl-saki> ertes: I see.
21:39:08 <koz_> ${DEITY}-damn it, lpaste...
21:41:37 <koz_> I'm having something weird happening. This: https://paste.rel4tion.org/402 , when I run 'ev paramSimple (mkStdGen 42)' spits out a vector of ten identical elements. This happens no matter what seed I give. What am I missing?
21:59:49 <lgw> m
22:00:10 <lgw> s/m//
22:00:34 <benzrf> lol
22:13:09 <koz_> I'm having something weird happening. This: https://paste.rel4tion.org/402 , when I run 'ev paramSimple (mkStdGen 42)' spits out a vector of ten identical elements. This happens no matter what seed I give. What am I missing?
22:13:34 <squall> koz, are you copying the std gen?
22:13:58 <koz_> squall: I've pasted the entire code, and how I ran it. I have no idea why I'm getting vectors full of identical results on every seed value.
22:14:33 <squall> Have you tried making a list of random numbers?
22:15:48 <koz_> squall: I don't follow.
22:16:34 <haasn> I think he means e.g. replicateM 10 getRandomPairR (or other intermediate functions)
22:17:11 <koz_> haasn: I'll give it a shot, but I suspect I'm missing something fundamental.
22:17:13 <squall> So I had a similar problem where all my random numbers came out the same and it turned out I was basically using the same seed over and over instead of collecting a new see and using that to get the next random number.
22:17:42 <koz_> squall: I suspect that might also be the issue, but I'm not sure how this could be happening.
22:17:57 <haasn> koz_: Wait, you're using a MonadRandom with just function applicaiton?
22:18:12 <squall> Try using next
22:18:30 <haasn> How does that work? Is there a MonadRandom instance for (StdGen -> a) ? The only way I can imagine that instance working is by re-using the same StdGen
22:18:31 <squall> :t System.Random.next
22:18:32 <lambdabot> RandomGen g => g -> (Int, g)
22:18:52 <koz_> haasn: What specific thing are you referring to in my case?
22:19:18 <jle`> koz_: 'ev paramSimple (mkStdGen 42)' is not really how you run a MonadRandom computation
22:19:19 <haasn> koz_: You said you ran “ev paramSimple (mkStdGen 42)”. This means that “ev paramSimple” has type `StdGen -> a` for some a
22:19:34 <jle`> koz_: in GHCi, try 'x <- ev paramSimple'
22:19:36 <haasn> koz_: But from your code I see `ev paramSimple` has type `MonadRandom m => m (Vector a)
22:19:38 <jle`> and then viewing x
22:19:46 <koz_> jle`: Good catch, sorry. Let me just clarify that point.
22:19:53 <jle`> or, try `evalRand (ev paramSimple) (mkStdGen 42)`
22:20:02 <koz_> jle`: evalRand (ev paramSimple) (mkStdGen 12) <-- this is what I did
22:20:10 <koz_> And on *any* seed, I just get a vector full of identical results.
22:20:17 <jle`> ah ok, that's totally different than before, heh
22:20:17 <koz_> Sorry for the confusion.
22:20:32 <haasn> koz_: Unifying ‘m (Vector a)’ with ‘StdGen -> b’ requires a `MonadRandom (StdGen ->)` instance
22:20:34 <squall> > System.Random.randomIO :: IO Int
22:20:37 <lambdabot>  <IO Int>
22:20:42 <squall> Doh
22:21:00 <jle`> haasn: yeah, koz_ meant evalRand (ev paramSimple) (mkStdGen 12), so they're using the Rand StdGen instance
22:21:20 <haasn> I don't see where you got your Control.Monad.Random from, but if there's an instance like that then surely it must work by re-using the same RNG state for every usage
22:21:40 <jle`> it's probably from the MonadRandom package
22:21:46 <koz_> jle`: It is indeed.
22:22:05 <jle`> koz_: what does 'step' do ?
22:22:49 <LambDuh> anyone think they could help out with a BST implementation? i'm getting stuck due to dumb procedural programming brain
22:23:22 <jle`> koz_: i'm not really sure what your algorithm is even doing.  can you provide a minimal working example using MonadRandom/RandT ?
22:23:31 <jle`> otherwise i would conclude that your algorithm just converges to the same number for every item
22:23:45 <squall> lol
22:23:55 <jle`> ie, your're running sqrt x a bunch of times on different x's, but they always reach 1 no matter waht x you start with
22:24:23 <jle`> > iterate sqrt 9.13 !! 100000
22:24:26 <squall> Can't see a rng doing so
22:24:26 <lambdabot>  1.0
22:24:30 <jle`> > iterate sqrt 0.1 !! 100000
22:24:32 <lambdabot>  0.9999999999999999
22:24:37 <jle`> > iterate sqrt 3023.8 !! 100000
22:24:38 <koz_> jle`: It chooses two indices i and j. Then, it randomly modifies whatever's at i according to mut. Then, we compare the result of that to whatever's at index j; if what we just generated is better, put it at index j; otherwise, change nothing.
22:24:40 <lambdabot>  1.0
22:24:45 <koz_> And just do that over and over.
22:24:59 <jle`> it might just be that doing your algorithm over and over causes the result to converge no matter waht the starting point is?
22:25:08 <koz_> jle`: On every value, this should not occur.
22:25:19 <koz_> (assuming all the values were random to begin with, and each modification is random)
22:25:27 <koz_> So my guess is one or the other thing is not actually occuring.
22:25:52 <jle`> it's tricky because it could also be a misimplementation of your algorithm
22:26:00 <jle`> it's hard to figure out what's really the problem here
22:26:05 <koz_> jle`: I suspect I've misunderstood how to use MonadRandom.
22:26:10 <jle`> unless you can isolate where the problem is
22:26:30 <jle`> yeah, but it's hard to confirm that because there's so much that could be at play here.  can you isolate the problem, maybe write something simpler?
22:26:51 <jle`> can you write a minimal example that shows the weird behavior
22:27:21 <koz_> That *is* the minimal example - that's the simplest I can write this algorithm without it, well, not being this algorithm.
22:27:45 <haasn> jle`: koz_: Can you confirm that you are using ‘evalRand’?
22:27:54 <jle`> have you tried implementing simpler algorithms with MonadRandom?
22:27:57 <koz_> haasn: Let me actually do this in GHCi and dump it.
22:28:04 <jle`> maybe just try seeing if you can generate a vector where every item is unique
22:28:13 <jle`> start with that
22:28:18 <jle`> if that works, then we'll go from there
22:28:27 <jle`> just generate a vector of random values first :)
22:29:47 <koz_> jle`: OK, I'll try.
22:30:12 <jle`> if you believe that you simply don't understand MonadRandom, then we can see if that's the case or not before we move on
22:30:16 <koz_> haasn: http://lpaste.net/236905
22:30:26 <koz_> jle`: Alright, let me just try doing that in GHCi.
22:30:45 <haasn> (Okay, based on that your invocation is fine)
22:31:27 <haasn> It's also clearly producing random numbers. I conclude that your algorithm makes all elements converge to the same thing
22:31:36 <jle`> koz_: when you do `ev (paramSimple { gens  = 0 })`, what happens?
22:32:00 <jle`> it does look like your algorithm causes all numbers in the vector to converge to the same number
22:32:07 <jle`> or try ev (paramSimple { gens = 2 })
22:32:39 <squall> That works for me
22:33:36 <squall> 8457 are the last digits displayed
22:33:38 <koz_> jle`: Oh, right, so it just converges very fast.
22:33:46 <koz_> Whoops, now I feel daft, lol.
22:33:51 <jle`> no need :)
22:34:00 <squall> I like the code
22:34:18 <koz_> squall: You do?
22:34:25 <squall> Not the doTimesM
22:34:51 <koz_> squall and jle`: I welcome all suggestions for how to write doTimesM better. I seem to need this often.
22:34:54 <jle`> also fwiw getRandomPairR r = (,) <$> getRandomR <*> getRandomR
22:35:03 <jle`> er, getRandomR r
22:35:21 <jle`> monad-loops has an iterateM that is similar
22:35:55 <jle`> or just \n x -> iterate (>>= f) (return x) !! n is sometimes ok too, except for !!/iterate leaking space
22:37:31 <saurabh__> ANNOUNCING: Paid Haskell Internship at Vacation Labs (Goa, India) -- https://www.vacationlabs.com/haskell-internship/
22:38:25 <joe9> What is the C data type for HsStablePtr?
22:39:15 <joe9> got it 
22:39:15 <joe9> extern H
22:39:27 <joe9> typedef void *HsStablePtr;  /* C representation of a StablePtr */
22:43:15 <squall> I annotated your paste
22:46:07 <saurabh__> apart from Reddit and https://wiki.haskell.org/Jobs#Internships is there any other place to announce haskell jobs/internships?
22:53:09 * hackagebot finite-field 0.9.0 - Finite Fields  https://hackage.haskell.org/package/finite-field-0.9.0 (MasahiroSakai)
22:55:25 <squall> Is it common that these internship announcements are scams? Not sure about luna.lang
22:57:22 <squall> I don't mean to imply job offers are dubious, I'm just not sure how to check safety...
22:58:15 <squall> I would happily apply for an internship but I guess I can't guarantee it isn't a phishing attack
22:58:34 <koz_> Thanks - I now realize why my numbers were suspect.
22:58:39 <koz_> I mis-implemented one of the parameters....
23:00:19 <koz_> squall: Thanks!
23:00:25 <koz_> (well, and jle` also)
23:00:31 <jle`> np!
23:01:33 <koz_> OK, now time to add more stuff.
23:02:40 <ReinH> I mean, I haven't really heard of phishing attacks, but I have some doubts about the ethics of unpaid internships
23:03:16 <AndroUser> koz_ did you see Control.Monad.MC
23:03:26 <koz_> AndroUser: No?
23:04:07 <koz_> squall: That's pretty cool. What's the advantage over MonadRandom though?
23:04:33 <koz_> Oh, never mind, I see.
23:04:40 <koz_> It has different distributions built-in.
23:05:06 <squall> Also Control.Monad.MontrCarlo
23:05:47 <squall> It uses State
23:08:17 <squall> Yeah the point is the weighted random sampling is the basic principle of Monte Carlo.
23:08:58 <Arguggi> Does anyone know if the Chart library can be used to create a svg and show it with ghcjs? (I'm trying Chart -> Chart-diagrams -> diagrams-svg) I think it tries to load fonts from the filesystem and I'm getting this error: "fonts/SourceSansPro_R.svg: openFile: failed (operation unsupported on this platform)"
23:11:26 <koz_> squall: In my implementation, I use a structure to hold all the various arguments that control the computation. However, that means I have to take that structure apart all the time. Is there a better way?
23:12:01 <squall> Lens...
23:12:21 <squall> I would just write modifier functions
23:12:47 <squall> It's just syntax overhead, if it's neat and informative it's no bother
23:13:07 <koz_> squall: Isn't there some GHC extension that can take apart a structure more easily?
23:13:35 <koz_> I forget the name, but it basically allows you to write {...} or something, and it'll just use the names of the fields access functions as if they were fields themselves.
23:13:38 <squall> idk sry
23:13:46 <koz_> squall: No worries - I'll look it up myself.
23:14:02 <squall> Oh that, i though you were using it already, it's called record syntax
23:14:57 <squall> No need for a language extension
23:15:30 <ahihi> RecordWildCards is the extension
23:16:06 <koz_> squall: Found it - RecordWildCards.
23:17:00 <lgw> Hmm. do if True then return (Just 23) else return Nothingdoesn't typecheck. Why don't  become both branches of the if Maybe Int for example?  
23:17:07 <squall> Oh literally {..}, i have never seen that before
23:17:26 <koz_> squall: I knew it'd come in handy one day, but I couldn't recall the name offhand.
23:17:30 <sed12> is there a language with such a huge standard library so that there are only a few third party libraries?
23:17:57 <koz_> sed12: Generally, third-party libraries meet specific needs, which vary over a language's history.
23:18:13 <koz_> It'd be unreasonable for any language to have libraries for all major NoSQL products built-in, for instance.
23:18:27 <koz_> Since 'all major NoSQL products' changes like, every 10 minutes.
23:18:29 <ahihi> :t if True then return (Just 23) else return Nothing
23:18:31 <EvanR> PHP probably does by now
23:18:31 <lambdabot> (Num a, Monad m) => m (Maybe a)
23:18:41 <sed12> koz_, how big is haskell standard library compared to other languages?
23:18:43 <ahihi> lgw: this looks fine, maybe provide more context?
23:18:50 <koz_> sed12: I dunno, honestly.
23:19:08 <squall> Prelude is pretty small
23:20:45 <ahihi> lgw: if you wanted this expression to have type Maybe Int, remove the returns
23:20:50 <squall> Can't say much about other languages. SmallTalk is supposed to be pretty small but that's not really the standard library as such. Haskell is pretty cool since the Prelude is written nicely.
23:21:30 <lgw> ahihi: Oh, thank you!
23:21:48 <sed12> do u all use ghc latest version?
23:22:18 <squall> The principle of higher order programming provides a powerful api in much reduced syntax. Common libraries in C can certainly be very large, but then they do allot...
23:22:36 <lgw> sed12: Yes and no. :-)
23:23:32 <squall> I would like to see how small a prelude I could really make do with...
23:24:30 <lpaste> manyone pasted “mangoes.hs” at http://lpaste.net/236940
23:26:00 <squall> Perhaps a very small ghc with a very small prelude could compile to a very simple language...
23:26:19 <squall> I remember something about stgm
23:27:30 <sed12> can i build the functionality of a third party library easier than in other languages using only haskell standard library?
23:28:20 <koz_> sed12: Probably. Haskell can do things with higher-order programming other languages could only dream of.
23:28:53 <sed12> just a guess, how much easier would it be?
23:29:02 <koz_> sed12: Depends on what you wanna do.
23:29:10 <lpaste> manyone revised “mangoes.hs”: “mangoes.hs” at http://lpaste.net/236940
23:29:10 <Rarrikins> sed12: It's 11 easier.
23:29:11 <koz_> I can't give a sensible answer to any question that's so broad.
23:29:24 <koz_> Rarrikins: 12 if you use lens. :P
23:32:04 <manyone> help - why do i get compile error in ghci for mangoes.hs? it says maxfriends n m h a, a is expected Int but actual Integer
23:32:46 <Rarrikins> manyone: Can you put mangoes.hs in a pastebin, please?
23:32:59 <Rarrikins> manyone: Oh, I see you have.
23:33:12 <manyone> its n lpaste.net now...
23:34:01 <Rarrikins> manyone: The problem is probably with anything to do with the length of a list.
23:34:08 <Rarrikins> manyone: Or a position in the list.
23:34:14 <Rarrikins> manyone: The default for that is Int.
23:34:38 <manyone> can i put toInteger before it (length)
23:35:02 <Rarrikins> manyone: If you want Integer instead, you need to use things like genericLength and genericTake.
23:36:54 <manyone> i didnt want integer for the length and list position but its saying my list a is Int but i read it as Integer
23:37:37 <Rarrikins> manyone: You need Integer for the length (so you need genericLength), because maxfriends is returning an Integer.
23:37:55 <Rarrikins> manyone: If you really want Int there, you can change the type signature of maxfriends.
23:39:25 <manyone> i never had a type signature (its got --) how did maxfriends get a return type of Integer 
23:39:51 <Rarrikins> manyone: It doesn't in the pasted code. It has Int.
23:39:59 <Rarrikins> @t length
23:40:00 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
23:40:04 <Rarrikins> :t length
23:40:05 <lambdabot> Foldable t => t a -> Int
23:40:14 <Rarrikins> :t Data.List.length
23:40:15 <lambdabot> Foldable t => t a -> Int
23:40:17 <joe9> What conversion would I need to convert from CUInt -> Word32?
23:40:23 <joe9> haskell word32, I meant.
23:40:29 <ongy> fromIntegral
23:40:50 <Rarrikins> When did Data.List.length turn into something that handles any Foldable?
23:41:18 <lpaste> manyone revised “mangoes.hs”: “mangoes.hs” at http://lpaste.net/236940
23:41:22 <ahihi> in ghc 7.10
23:41:48 <joe9> ongy, Thanks.
23:43:05 <lpaste> manyone revised “mangoes.hs”: “mangoes.hs” at http://lpaste.net/236940
23:43:13 <manyone> i revised mangoes.hs (with the errors in comments)
23:47:16 <ahihi> manyone, it's easier to see where the mismatches come from if you add type signatures for your functions
23:48:45 <manyone> i took rarrikins advice - i used genericTake - and it compiled. thanks rarrikins and all
23:50:50 <ReinH> manyone: Alternatively, if you don't expect your integer value to exceed the max size of Int, you can convert your Integer into an Int
23:51:03 <ReinH> genericTake is probably slower than take (fromInteger i)
23:51:19 <ReinH> er, genericTake i
23:53:10 * hackagebot cblrepo 0.22.0 - Tool to maintain a database of CABAL packages and their dependencies  https://hackage.haskell.org/package/cblrepo-0.22.0 (MagnusTherning)
23:53:12 * hackagebot swagger2 2.1.3 - Swagger 2.0 data model  https://hackage.haskell.org/package/swagger2-2.1.3 (phadej)
