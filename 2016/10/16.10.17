00:02:41 <grantwu> Is there any sort of extension that lets you use $ and . with types?
00:02:53 <liste> :t Compose
00:02:54 <lambdabot> error:
00:02:54 <lambdabot>     • Data constructor not in scope: Compose
00:02:54 <lambdabot>     • Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
00:03:13 <liste> :t Compose
00:03:14 <lambdabot> forall k k1 (f :: k -> *) (g :: k1 -> k) (a :: k1). f (g a) -> Compose f g a
00:03:29 <liste> that's a different type though
00:03:36 <grantwu> like, instead of type FDefn = C0Types.FDefn C0Types.Virtual (Seq (Instruction C0Types.Virtual))
00:03:40 <grantwu> It would be nice to do
00:04:03 <grantwu> Foo Bar $ Seq $ Baz Cat
00:04:37 <grantwu> liste: Wait, did you just write the same thing twice and get different results from Compose
00:04:40 <grantwu> er, from lambdabot
00:05:24 <liste> grantwu: yes
00:05:38 <cocreature> liste is a magician
00:06:37 <liste> the magic of /msg lambdabot @let import Data.Functor.Compose
00:06:38 <liste> (:
00:07:01 <cocreature> liste: the important point about being a magician is to not explain your tricks!
00:07:02 <ongy>  @lets are global?
00:07:14 <grantwu> I need more RAM to use ghc-mod :'(
00:07:17 <liste> ongy: yes
00:07:41 * hackagebot sibe 0.2.0.1 - Machine Learning algorithms  https://hackage.haskell.org/package/sibe-0.2.0.1 (mdibaiee)
00:07:41 * hackagebot scalpel 0.4.0 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-0.4.0 (fimad)
00:09:54 <MarcelineVQ> grantwu: cabal build or stack build when you run into memory issues, depending on your setup occasionally the enrivonment using ghc-mod is building dependencies that are the real culprit for ram usage
00:10:23 <grantwu> Hrm... how does that work exactly?
00:10:38 <grantwu> All I need is typechecking
00:13:57 <MarcelineVQ> I don't have a concrete example but in my experience this happens to me every once in awhile with atom where it tries to build dependencies so ghc-mod can do its job, which results in one or more ghc processes running in the background eating up ram
00:15:11 <grantwu> Hrm... I'm also using Atom
00:15:18 <MarcelineVQ> oho
00:15:40 <grantwu> but why is it building dependencies >.>
00:16:00 <grantwu> I'm not doing any special, I didn't pull in any new dependencies
00:17:17 <MarcelineVQ> I honestly don't know, it's not something I've tracked well enough, but try building your project from cli when it happens then go back to editing
00:17:39 <MarcelineVQ> It may not be your issue at all as well, but it is something I've seen
00:18:43 <grantwu> Does this work even when your code is broken?
00:19:15 <grantwu> I usually get the issue when my code doesn't typecheck and I want to know why (I lean heavily on the typechecker)
00:19:30 <MarcelineVQ> ghc-mod? yes, if your code is broken you'll get a parse or type error and that should be reflected where it happens in your IDE's
00:20:08 <MarcelineVQ> It's not suuuper reliable though, it's more of a nice aide, one less time you need to `asTypeOf` or _ in ghci
00:20:53 <grantwu> No, I mean the memory issue
00:21:11 <grantwu> Like, I get the memory issue when I ask ghc-mod to do a typechecking pass
00:21:19 <grantwu> Not all the time, but when it does happens, it's after a write
00:23:30 <MarcelineVQ> I don't recall having oom issues with ghc-mod alone, more typically it'll just crash for me, and that's usually due to mismatch between what it's built with and what I'm using it on
00:24:28 <grantwu> I wish ghc-mod was better, sigh
00:24:33 <grantwu> case split doesn't respect qualified imports
00:25:12 <ongy> grantwu: how much memory do you have in your system?
00:25:22 <grantwu> only 8 GB :(
00:25:41 <grantwu> I'm also running Atom and Chrome at the same time
00:26:31 <ongy> still sounds like something is weird. Or you have a rather large project. I have 4 total in my laptop and it's enough for me
00:26:41 <guillaum2> Hello. Suppose I have a sum types such as `data AllIntT = T8 Int8 | T16 Int16 | T32 Int32 | T64 Int64 | TLong Integer... I want to wrap many operations on top of that, for example `show`. I can easyly write a myShow command which applies show on each case, but that's painful. Can I write a generic function which apply another function (a -> b) on all cases as long as the function is polymorphic enough 
00:26:47 <guillaum2> to handle all of my cases ? For example `myShow n = applyOp show n`, I want to define `applyOp`.
00:27:06 <grantwu> ongy: Project isn't really that big... about 3k lines?
00:27:51 <ertes> guillaum2: the easiest option would be to write a conversion function to Integer
00:28:20 <ertes> guillaum2: in fact Integer is really similar to the type you're defining, except that it has only two variants:  one for machine-sized integer, and one for arbitrary-size integer
00:29:09 <grantwu> ongy: So, right now it has 1.1GB resident memory
00:29:53 <grantwu> i'm at 5.1GB memory used, 2GB swap partition is basically full
00:30:12 <guillaum2> ertes: well, you are right. Suppose now that my `AllIntT` types also stores `Float`, `Double`. I still want to show them, and I cannot convert to Integer.
00:31:06 <ertes> guillaum2: you can add more canonical types
00:31:23 <ertes> withCanonical :: (Integer -> r) -> (Rational -> r) -> AllWhateverT -> r
00:31:58 <guillaum2> ertes: haa, yes, smart.
00:32:17 <MarcelineVQ> grantwu: Have you ran ghc-mod directly instead of having atom do it? To see if it's the issue. from your project root: ghc-mod check sourcefile.hs
00:32:32 <guillaum2> ertes: funny, it will ends as `withCanonical show show show show show show`, but it will work ;)
00:32:37 <grantwu> MarcelineVQ: No, haven't done that before
00:32:38 <MarcelineVQ> output means it found an issue, alternatively try ghc-mod lint
00:33:15 <ertes> guillaum2: there is a crazier option that stops even that repetition, but it requires some understanding of the type system…  let me code it up
00:36:18 <ongy> I have a record of functions. To build one of the functions I want to put into my record, I the already done record (so it recurses into itself later). Can I sensibly do that? Or will I have to restructure some code
00:36:49 <guillaum2> ertes: I'm interested ;) I played with RangNTypes for was limited with my knowledge. The idea is the function I want to apply is of type `Ctx t => t -> a`, but I don't know how to make the `Ctx` polymorphic for my cases ;)
00:38:13 <ertes> guillaum2: apparently haskell can't do it
00:38:31 <ertes> withNumber :: (c Integer, c Rational) => (forall a. (c a) => a -> r) -> Number -> r
00:39:12 <ertes> it seems that GHC needs to know the class
00:39:54 <ertes> i wonder why though…  it seems that this should be possible in principle
00:41:11 <ertes> so yeah, i'd go with canonical types
00:45:56 <guillaum2> ertes: thank you for the try ;)
00:47:45 <ertes> guillaum2: hah, i figured it out =)
00:49:59 <ertes> guillaum2: https://gist.github.com/esoeylemez/010011b6b78dc1b9d7dcdec9d4249212
00:50:31 <ertes> i'm pretty sure there is a predefined Dict type that streamlines this a bit
00:51:49 <merijn> ertes: What if you explicitly forall the 'c'?
00:52:18 <haskell021> Just wanted to say hello.I hope I'm talking to people.
00:52:28 <ertes> merijn: tried it, didn't work
00:52:41 <jle`> hi haskell021 !
00:53:22 <grantwu> I wonder if there's some way to produce better type error messages by speculatively inserting parens and $ and seeing if the result typechecks
00:53:28 <grantwu> "did you mean to insert a $ here?"
00:55:11 <ertes> slightly more reasonable: https://gist.github.com/esoeylemez/010011b6b78dc1b9d7dcdec9d4249212
00:57:23 <merijn> grantwu: That doesn't sound very sensible? But, have you tried using typed holes to get better feedback? :)
00:57:36 * hackagebot pandoc-types 1.17.0.1 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.17.0.1 (JohnMacFarlane)
00:57:38 * hackagebot bioinformatics-toolkit 0.2.4 - A collection of bioinformatics tools  https://hackage.haskell.org/package/bioinformatics-toolkit-0.2.4 (kaizhang)
01:00:04 <grantwu> merijn: How would typed holes help?
01:00:05 <guillaum2> ertes: thank you. I really need some work to wrap my head around it, but well, it appears to work ;)
01:00:25 <grantwu> Like, suppose I write     return expCalc ++ [Instr (Assert t)]
01:00:36 <grantwu> I need a $ after return
01:00:56 <grantwu> I get a very strange error here without it
01:01:11 <grantwu> I mean, I understand why I need a $
01:01:29 <grantwu> I just think that maybe the compiler can give better errors for precedence issues
01:01:47 <jle`> ertes: constraints package has this, and there's a continuation-style combinator so you wouldn't have to pattern match on Dict explicitly
01:01:51 <merijn> grantwu: There's really only one precedence you need to know for that example
01:01:53 <ertes> guillaum2: it's the following on crutches:  withNumber :: (c Double, c Int, c Integer, c Rational) => (forall a. (c a) => a -> r) -> Number -> r
01:02:00 <merijn> grantwu: Function application is *always* higher than operators
01:02:17 <ertes> jle`: ah, thanks
01:02:33 <jle`> not sure about the original problem though, so i might just be addressing a problem with the solution
01:02:47 <merijn> grantwu: The issue is that there's no sensible way to report an error there unless you expect it to try ALL possible (exponential) parses and report all possibly correct ones
01:02:48 <grantwu> merijn: No, I know that
01:02:59 <grantwu> merijn: Ah yeah - well what I'm saying is that it could try a few
01:03:10 <ertes> guillaum2: the function is parameterised over the type constructor (c :: * -> Constraint) and works whenever there is an instance for (c Double), (c Int), etc.
01:03:14 <grantwu> Say, only adding on e$
01:06:25 <ertes> wow, the constraints library looks useful
01:06:45 <jle`> it's basically the canonical Dict library in the ecosystem
01:07:26 <jle`> it's neat :)
01:07:38 <jle`> i'm still discovering new ways to use the various things it exports haha
01:09:23 <jle`> oh my PR for withDict that I mentioned has not been pushed to hackage yet
01:09:52 <ertes> at some point we should start writing order property classes
01:10:28 <ertes> though Category should be sufficient for (:-)
01:11:42 <guillaum2> ertes: Is there a way to call the "withNumber" without fully specifing the type of "Dict". For now I must do `withNumber (Dict :: Dict (Show Double, Show Int, Show Integer, Show Rational)) show (RationalNum 3)` which is, well, long...
01:14:02 <jle`> guillaum2: how about withNumber @Show Dict show (RationalNum 3)
01:14:14 <ertes> guillaum2: i would have expected that to be inferred, but if not, you can add a Proxy argument or use -XTypeApplication
01:14:50 <guillaum2> jle`: well done ;) ertes: yes ;) Thank you.
01:15:07 <jle`> withNumber takes a single type parameter, 'c', so you can specify it with @Show
01:15:20 <jle`> i don't think that it's possible to infer in general
01:15:24 <ertes> well, it takes two =)
01:15:39 <jle`> oh, that's true
01:15:40 <ertes> so you should probably explicitly quantify all types
01:15:48 <ertes> forall c r. …
01:16:18 <jle`> yeah, that's the annoying thing about -XTypeApplication ....
01:16:26 <jle`> playing guess-the-order-of-type-parameters
01:16:39 <jle`> and it's kind of frustrating that changing the order of the forall's is a breaking API change heh
01:16:55 <ertes> the price of approaching dependent types =)
01:17:23 <jle`> i guess it's not that different from changing the order of type arguments in a dependently typed language being a breaking api change
01:18:14 <ertes> on the other hand we could do what agda does:  allow explicitly naming the arguments
01:18:25 <ertes> withNumber @(c = Show) …
01:19:05 <jle`> oh that'd be neat
01:21:38 <guillaum2> ertes: actually we can remove the Dict parameter by using `AllowAmbiguousTypes`, using `withNumber' :: (c Double, c Int, c Integer, c Rational) => (forall a. (c a) => a -> r) -> Number -> r
01:21:58 <guillaum2> ertes: by "I don't have a clue about what I'm doing"...
01:22:49 <jle`> i don't think that actually works
01:23:28 <jle`> from all of my experience, AllowAmbiguousTypes just means "the error comes at runtime instead of compiletime"
01:23:41 <jle`> or well, that's how i read it as heh
01:23:51 <jle`> i don't remember a situation where it's actually solved a problem for real
01:24:14 <lyxia> not anymore with TypeApplications
01:24:23 <jle`> :o
01:25:05 <jle`> i want to believe
01:25:32 <guillaum2> jle`: well, it works. The TypeApplication is still needed, but the implicit Dict argument can be removed.
01:25:57 <jle`> guillaum2: by "works", do you mean you just got it to compile, or does it actually run correctly too?
01:27:17 <Reisen> Can you do pattern guards where any of the patterns match rather than all? I.E something like foo x | Just a <- something x env0 or Just b <- something x env1 = 0
01:28:37 <lyxia> jle`: instead of    bar :: Foo a => Proxy a -> Int   , and    bar (Proxy @MyType)    at the use site, you can now write an ambiguous    bar :: forall a. Foo a => Int    and just    bar @MyType   .
01:29:01 <ertes> Reisen: that would be problematic because of variable scope
01:29:28 <Reisen> That makes sense, really obvious when you say it, but didn't occur to me
01:29:29 <ertes> Reisen: try to restructure your match such that you match everything *except* those two first
01:29:30 <guillaum2> jle`: it compiles and runs ;) And even refuses compiling for some weird constraints, such as `withNumber' @Integral toInteger v` because `Rational` is not an `Integral`.
01:29:44 <lyxia> Reisen: | Just a <- something x env0 <|> something x env1 = 0
01:30:14 <merijn> ertes: It really wouldn't be problematic, it just requires both patterns to bind the exact same variables
01:30:20 <merijn> ertes: Ocaml supports this
01:30:39 <Reisen> lyxia, perfect, thank you
01:31:09 <jle`> guillaum2: nice :)
01:31:13 <jle`> it's a new day
01:31:28 <merijn> It's one of the few things I think ocaml does nicer than haskell :)
01:31:52 <jle`> * lyxia too
01:33:53 <NeeravSingh_> Whos all on here 
01:34:21 <guillaum2> jle`: ertes: https://gist.github.com/guibou/c0bbe73a5fb70c54694785e09c4bb706
01:34:25 <NeeravSingh_> Quick question for you cyber master minds 
01:34:41 <ertes> merijn: true
01:35:06 <jle`> congrats!
01:35:07 <ertes> merijn: but lyxia's solution is more warmer and fuzzier =)
01:37:08 <ertes> guillaum2: great!  in that case you can remove ExistentialQuantification
01:39:54 <guillaum2> ertes: well, actually no, it does not compiles.
01:40:53 <guillaum2> ertes: but to be honest, I'm not really satisfied with `AllowAmbiguous...`, I really have the feeling I'm playing with a nuclear weapon...
01:41:27 <guillaum2> ertes: so I'll keep your first solution (or, actually, the canonical version, which is a bit more verbose, but highly explicit)
01:44:50 <ertesx> guillaum2: the Dict version is fine though…  it's perfectly safe
01:45:48 <jle`> guillaum2: hm.  maybe try a version with just a Proxy instead, does that work?
01:46:14 <jle`> withNumber :: (c Integral, ...) => Proxy c -> (forall a. (c a) => a -> r) -> ...
01:46:28 <jle`> it should work the same as your other version, but it might not require allowambiguoustypes
01:47:21 <ertesx> i was trying to hack around the limitation
01:47:28 <guillaum2> jle`: the Proxy or the dict are roughly equivalent no? Or I missed something ?
01:47:37 <ertesx> class HasDict (c :: Constraint) where dict :: Dict c; default dict :: c => Dict c; dict = Dict
01:47:38 <ertesx> instance c => HasDict c
01:47:49 <ertesx> but it doesn't accept HasDict constraints either
01:47:58 <jle`> guillaum2: they're different
01:48:02 <jle`> well,
01:48:06 <jle`> Proxy and Dict are different
01:48:26 <jle`> but they might just accidentally be doing the same thing here in this case, in which case Dict is overkill/the dictiness of it is not adding anything
01:48:40 <ertesx> jle`: they're doing the same thing (semantically)
01:48:51 <jle`> in that case, there's no reason to use Dict :o
01:48:59 <ertesx> i'm pretty sure the technical difference is exponential vs. product
01:49:55 <guillaum2> jle`: in that case, you are right, but that's kind of bikeshedding ;)
01:50:25 <ertesx> oh, wait, there is a semantical difference!
01:50:32 <jle`> guillaum2: maybe, but using Dict there if Proxy works is kind of silly
01:50:37 <jle`> might as well use (IO a)
01:50:48 <ertesx> the dictionary is no longer bound to the proxy argument, so Proxy is actually better =)
01:50:56 <ocramz> good morning all
01:51:05 <ertesx> withNumber _ f (DoubleNum x) = f x  -- works!
01:51:18 <jle`> guillaum2: using Dict there where you could use Proxy would be like using Double when you could use Bool
01:51:25 <jle`> and just promise that the double is always 0 or 1
01:51:25 <guillaum2> jle`: ha, yes, well, it works with IO a, you are right ;)
01:51:28 <ocramz> is there a style guide for Haddock ? I'd like to divide the docs in sections 
01:51:44 <ertesx> guillaum2: so yes, use Proxy instead of Dict
01:51:56 <merijn> ocramz: You can create up to three levels of different sections
01:52:14 <jle`> oh, or a better analogy
01:52:17 <ertesx> guillaum2: bonus: it's predefined in base:  import Data.Proxy
01:52:25 <jle`> it's like using some complicated type like Double when all you needed is ()
01:52:28 <ocramz> merijn: does it work like markdown ?
01:52:35 <ocramz> as in * , ** ..
01:52:42 <merijn> ocramz: No, but the haddock documentation was pretty good
01:52:51 <jle`> why not make putStrLn :: String -> IO Double, and just ask everyone to ignore the Double result which is meaningless?
01:53:22 <merijn> ocramz: You create sections in the module export list
01:53:31 <jle`> or putStrLn :: Double -> String -> IO (), and just tell everyone that the first argument is ignored
01:53:46 <ocramz> merijn : I've found it https://www.haskell.org/haddock/doc/html/index.html
01:54:07 <guillaum2> jle`: yes, you are right actually ;)
01:54:12 <jle`> guillaum2: oh, actually, i think the current best-practice here is to not use Proxy
01:54:14 <jle`> and just use 'p a'
01:54:19 <jle`> that way people can put whatever they want
01:55:05 <guillaum2> jle`: (difficult to see if this is sarcasm or not ;)
01:55:16 <ertesx> guillaum2: to be honest i'd most likely go with -XAllowAmbiguousTypes
01:55:20 <jle`> oh, it actaully is a current best-practice i think, heh, that's replaced taking Proxy as an argument
01:56:00 <jle`> instead of taking Proxy a -> ..., people like taking forall p. p a -> ... instead
01:56:13 <ertesx> take :: (Fractional a) => Double -> [a] -> [a]
01:57:08 <ertesx> guillaum2: -XAllowAmbiguousTypes is not *unsafe*…  in fact it does what it's supposed to do in this case
01:57:22 <ertesx> so don't worry about programs suddenly crashing with run-time type errors =)
01:57:38 * hackagebot slack-api 0.10 - Bindings to the Slack RTM API.  https://hackage.haskell.org/package/slack-api-0.10 (mpickering)
02:00:49 <ertesx> my final version: https://gist.github.com/esoeylemez/010011b6b78dc1b9d7dcdec9d4249212
02:02:33 <guillaum2> ertesx: you copied mine ;) I'll read more about AllowAmbiguousTypes to understand what it does really imply, but thank you for the solution and the discussion.
02:02:56 <jle`> i apologize for inspiring needless paranoia earlier :)
02:04:39 <ertesx> guillaum2: nah, i removed ExistentialQuantification =P
02:08:38 <ocramz> recursive functions: is memory usage kept constant by using strict State combinators?
02:09:38 <guillaum2> ertes: ha, yes.. Well... Haa, yes, the ExistentialQuantification was needed for Dict and not for the forall inside withNumber, exact ;)
02:09:41 <joncol> Have you used the Text.PrettyPrint.Leijen library? It's satisfying most of my pretty printing needs, except for one detail: I cannot find an identity element for <$> (i.e. some empty element with width /and/ height 0). Has anyone else run into this?
02:10:47 <merijn> joncol: Doesn't mempty work? (Pretty sure Doc is a monoid)
02:12:12 <guillaum2> ertes: however I'm still stuck at understanding what you meant by "The dictionary is no longer bound to the proxy argument". I saw the result (you can ignore the proxy argument with "_", and I discovered that ignoring argument changes the semantic of a function and this just blow my mind... Too much for today)
02:12:30 <joncol> merijn: No it's not Monoid from what I can tell. Text.PrettyPrint /is/, but not https://hackage.haskell.org/package/wl-pprint-1.2/docs/Text-PrettyPrint-Leijen.html
02:13:05 <merijn> hmm
02:13:52 <ertes> guillaum2: this is a case of what is called "type refinement":  note how in Dict the actual dictionary information is bound to the Dict *value* constructor
02:14:02 <joncol> merijn: Maybe I should switch lib :)
02:14:15 <ertes> guillaum2: imagine that Dict was defined this way:  data Dict c = c => Dict | NoDict
02:14:33 <merijn> joncol: Why exactly do you need an identity for <$>?
02:14:39 <guillaum2> ertes: in case of NoDict you may not have any information about c.
02:15:09 <abbe> ashishnegi: is this the same guy from ilugd ?
02:15:10 <ertes> guillaum2: exactly, now NoDict does not carry the dictionary information…  you need to pattern-match *and* find a Dict to infer the constraint c
02:15:42 <ashishnegi> abbe: sorry i do not know the context of your question ?
02:15:44 <guillaum2> ertes: I guess I understand, I saw that when I was toying with dependent typing (And lost my soul with singletons)
02:15:59 <ertes> guillaum2: yeah, it's exactly the same thing
02:16:13 <abbe> ashishnegi: ignore me, if you don't. sorry, confused you with someone i knew :)
02:16:21 <joncol> merijn: I'm using <> to combine elements and some of these are possibly empty.
02:16:50 <ertes> guillaum2: data Eq :: k -> k -> * where Refl :: Eq a a  -- you actually need to find a Refl in order to infer equality
02:16:56 <merijn> joncol: But empty is a unit of <> already?
02:17:16 <merijn> joncol: So I'm not sure how that fits in?
02:17:29 <ertes> guillaum2: you may also find it interesting that the following type is equivalent:  newtype Dict c = Dict { withDict :: forall r. (c => r) -> r }
02:18:20 <guillaum2> ertes: nice!
02:19:10 <ertes> it shows you more clearly why you need to pattern-match:  in this case the equivalent to pattern-matching is using 'withDict', and only the argument to withDict receives the knowledge that c holds
02:19:43 <ertes> withNumber d f (DoubleNum x) = withDict d (f x {- only here it's known that the constraint holds -})
02:20:03 <merijn> joncol: Wouldn't it be simpler to produce (potentially) empty lists of [Doc] and use hsep/vsep?
02:21:38 <jle`> guillaum2: one way i like to think about it is that, for the original construction `data Dict c = c => Dict`, there are only two values of type 'Dict c' -- the one constructed with Dict :: c => Dict c, and bottom
02:21:48 <ertes> "forall r. (c => r) -> r" = "give me an 'r' that depends on the knowledge 'c', and i will give you an 'r' back, because i happen to carry that knowledge your 'r' depends on"
02:22:11 <jle`> in order to use the first constructor, 'Dict', you need 'c' to be satisfied.  in order to create the second value, you don't
02:22:28 <jle`> so pattern matching on the Dict constructor is like pattern matching between the case where c is satisfied and the case where it isn't
02:22:57 <jle`> if you *don't* pattern match, then for all you know, that 'Dict c' you got could have been a bogus (undefined :: Dict (Show (IO Int))
02:24:10 <joncol> merijn: That's a nice idea. Using <> with one operand = empty seems to insert empty lines above.
02:24:16 <jle`> but if you pattern matched and got Dict, then that means that 'c' was in fact satisfied at the time of creation, becuase that's required in order to use the Dict constructor
02:25:14 <ertes> it's in fact a rather strong kind of satisfaction:  it doesn't fall for bottoms =)
02:25:49 <guillaum2> ertes: jle`: thank you both, I learned a few things.
02:26:33 <merijn> joncol: That's because "empty <>" prepends an "empty line" in front of it's argument, so "empty <> empty" is an empty line
02:26:38 <ertes> "our love is bottomless"
02:27:00 <merijn> joncol: But if you build [[Doc]] and filter out the completely empty cases and THEN hsep/vsep you should be fine
02:27:01 <ertes> wow, that can be misunderstood in so many ways…
02:27:01 <jle`> haskell love story for the ages
02:27:33 <ertes> haskell overloaded love story for the ages
02:27:45 <jle`> reminds me of http://haskellryangosling.tumblr.com/
02:28:45 <jle`> but yeah, the informal intution i stated earlier doesn't really help show how you can manipulate dictionaries and how Dict's reify constraints and how you can use unsafeCoerce for fun and profit, so it's not a perfect picture
02:29:29 <jle`> but it's sort of a quick way to assure yourself why you have to pattern match, i think
02:29:58 <jle`> s/assure/convince
02:32:04 <ertes> bottomless love = total love
02:32:08 <ertes> alright, i'll stop
02:32:32 <mettekou> ertes: Please don't.
02:33:47 <guillaum2> ertes: bottomless love = total and not lazy love, no ?
02:34:04 <ertes> topless love = partial love…  you need to get bottomless to experience total love
02:36:36 <ertes> hmm…  but you can't have both, unless your love is void =/
02:36:47 <ertes> what a depressing love story
02:43:25 <joncol> merijn: Yeah, I'll go with that. Thanks
02:46:05 <Alper> Hello, can someone double check my answer/reasoning for a type check question? http://lpaste.net/269939
02:47:11 <cocreature> Alper: the correct answer is a
02:47:24 <cocreature> Alper: by applying to x a and Char are unified
02:47:37 <cocreature> b doesn’t make sense, because x is not a type
02:47:56 <jle`> Alper: remember that f :: a -> (a -> (a -> a))
02:48:00 <jle`> so f x :: a -> (a -> a)
02:48:10 <joncol> merijn: Argh, no Eq instance for Doc either. So difficult to filter out empty.
02:48:22 <merijn> joncol: null
02:48:25 <merijn> :t null
02:48:27 <lambdabot> Foldable t => t a -> Bool
02:48:32 <jle`> Alper: you're asking for the type of "f x" not "f"
02:48:36 <jle`> s/you're/they're
02:49:00 <merijn> joncol: At least, I'm assuming you were checking for equality using "l == []" and have now learned why that's a bad idea ;)
02:49:46 <Alper> Thanks, cocreature / jle`.
02:50:14 <jle`> the only two answers with the right amount of "arguments" are a and c
02:50:32 <Alper> f :: a -> (a -> (a -> a)) Kinda helps me understand why the number of arguments change.
02:50:57 <jle`> yeah, giving `f` a single value gets you an (a -> (a -> a))
02:51:33 <joncol> merijn: Ah I see, you're going with lists of lists, instead of lists of Doc.
02:51:39 <Alper> cocreature: What is unified types? Applying x to the type a in this instance?
02:52:03 <merijn> joncol: I suggested [[Doc]] outer list being lines, inner list being parts of the same line
02:52:10 <cocreature> Alper: unifying two types means that you try to specialize type variables such that the two types are equal
02:52:21 <cocreature> Alper: in the case of a and Char the only way to do that is to set a = Char
02:52:29 <merijn> joncol: So you'd do "vsep . map hsep $ myDocs :: [[Doc]]"
02:52:52 <merijn> joncol: But first you'd filter out the empty list (i.e. empty lines) from myDocs
02:54:41 <joncol> ok
02:57:39 * hackagebot hakyll 4.9.0.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.9.0.0 (JasperVanDerJeugt)
02:58:30 <Alper> cocreature: jle` does this make sense then? http://lpaste.net/269939
02:58:54 <cocreature> Alper: sorry I have to run
02:59:14 <jle`> looks good to me
02:59:22 <Alper> no worries, thanks cocreature 
02:59:27 <Alper> thank you jle` 
02:59:32 <jle`> no problem!
03:01:07 <Alper> These exercises don't have the correct answers so I wanted to check before I move on to more complicated types. I appreciate your help.
03:10:18 <M62844[m]> hii
03:25:34 <Xnuk> hi
03:28:42 <alpineswift> how do I change the background color on irssi to white
03:42:35 <jophish> joncol: which Doc?
03:42:49 <jophish> I added an isEmpty function to one of the packages I think
03:57:00 <Aleksejs> Hi, is there any way to optimize this code http://vpaste.net/4LVLo ? This code takes a list of integers and does xor over a list elements and all contiguous sub-lists. I optimized it with: 1) xor is associative; 2) if lists length is even then each element will be repeated even times, making result 0; 3) if length is odd, I need to xor only odd indexes
03:57:37 <Aleksejs> this code timeouts on test cases with 90k numbers
03:58:05 <Aleksejs> here is a task https://www.hackerrank.com/challenges/sansa-and-xor
04:00:09 <lyxia> Aleksejs: you keep recomputing the length of the list with "length n"
04:00:52 <Aleksejs> hmm, yes, I need to calculate it only once, thanks!
04:03:18 <lyxia> Aleksejs: you can refactor times with replicateM_
04:03:44 <lyxia> and you don't need to (take n)
04:03:52 <lyxia> (take (read n))
04:04:57 <Aleksejs> lyxia: I put it just in case there some special test case where they made a larger list than it should be
04:05:25 <lyxia> This parameter is useful in languages where breaking lists into words is not simple to do.
04:06:23 <lyxia> It's guaranteed to be redundant in such problems.
04:06:39 <Aleksejs> lyxia: each test case has 2 parameters - length of list and list itself. So, if the first parameter is 5 and the second is list with 1000 numbers, my code will fail if I remove that take n
04:07:04 <lyxia> Aleksejs: but that doesn't match the stated format.
04:07:24 <Aleksejs> but actually I passed all cases by moving that length higher, thank you!
04:08:09 <Aleksejs> the last version is http://vpaste.net/GGEPZ
04:08:35 <lyxia> Challenges like Hackerrank don't give you bad inputs.
04:11:43 <joncol> jophish: I'm using https://hackage.haskell.org/package/wl-pprint-1.2/docs/Text-PrettyPrint-Leijen.html
04:11:44 <m1dnight_> I am looking at the lexer for Tiger in the Alex repository and they mention a parser in there too. I am wondering where Ic ould find it. Ive found the example really helpful in learning about alex, but now I would like to see the parser too, so I know how to hook both together.
04:11:58 <m1dnight_> https://raw.githubusercontent.com/simonmar/alex/master/examples/tiger.x This is the lexer I am talking about.
04:38:32 <tabaqui> can i translate word32 to word64 without toEnum, fromEnum methods?
04:38:52 <phadej> fromIntegrak
04:38:54 <phadej> fromIntegral
04:39:09 <phadej> :t fromIntegral :: Word32 -> Word64
04:39:10 <lambdabot> Word32 -> Word64
04:40:41 <tabaqui> i cannot find this function in docs
04:41:05 <sshine> m1dnight_, it doesn't look like Simon supplied one. but I think there should be other examples of alex+happy fitting together.
04:41:36 <sshine> m1dnight_, are you looking for any particular configurations of Happy? (e.g. simple, position, monadic)
04:42:29 <m1dnight_> Well, I wanted to use the monadUserState lexer, for didactic purposes. And now I want to hook up my parser but it seems like you don't need any sort of boilerplate code (anymore)
04:42:33 <phadej> tabaqui: it's in Prelude
04:42:46 <tabaqui> phadej: ok, thank, i'll look at it
04:42:55 <m1dnight_> I'm gradually increasing the complexity here. So for now it seems to work by just removing the definitions for parse and such.
04:43:07 <phadej> tabaqui: it has more general type, so it's hard to spot
04:43:10 <phadej> :t fromIntegral
04:43:12 <lambdabot> (Num b, Integral a) => a -> b
04:43:40 <liste> https://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:fromIntegral
04:50:28 <jophish> joncol: ah, I was thinkig of this one: https://hackage.haskell.org/package/pretty-1.1.3.4/docs/Text-PrettyPrint.html#v:isEmpty
04:57:42 * hackagebot sparse-linear-algebra 0.1.0.1 - Sparse linear algebra datastructures and algorithms. Currently it provides iterative linear solvers, matrix decompositions, eigenvalue computations and related utilities.  https://hackage.haskell.org/package/sparse-linear-algebra-0.1.0.1 (ocramz)
04:57:44 * hackagebot sparse-linear-algebra 0.1.0.2 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.1.0.2 (ocramz)
04:57:46 * hackagebot patat 0.3.0.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.3.0.0 (JasperVanDerJeugt)
05:19:38 <{AS}> when was it polymorphic records were coming?
05:19:54 <merijn> {AS}: I think you mean OverloadedRecordFields?
05:20:01 <{AS}> merijn: Yeah
05:20:06 <merijn> GHC has had polymorphic records for a long time :p
05:20:22 <merijn> I think there's an experimental version in 8.0? Or maybe that was held back for 8.2
05:20:25 <{AS}> I guess I meant the other kind of polymorphism :)
05:21:49 <lyxia> Row polymorphism?
05:22:22 <{AS}> Yeah
05:23:18 <merijn> Row polymorphism isn't coming anytime soon
05:24:22 <{AS}> so I can't do r { x = bla }
05:24:33 <{AS}> where x is a polymorphic label?
05:24:56 <merijn> That's overloadedrecordfields, which is very different from row polymorphism
05:25:20 <hpc> merijn: i think {AS} means something like \r x v -> r {x = v}
05:25:34 <hpc> which is some sort of structural typing thing
05:25:35 <merijn> hpc: That is still diferent from both of those
05:25:54 <{AS}> I meant \r v -> r {x = v} :)
05:26:02 <{AS}> x can be fixed I think
05:26:13 <hpc> does x occur in more than one data type?
05:26:30 <{AS}> hpc: Yeah
05:29:45 <hpc> it looks like in the current proposal that type would be HasField "x" r v => r -> v -> r
05:29:59 <{AS}> Yeah
05:30:09 <{AS}> Is there any ETA known?
05:30:14 <{AS}> or is it under discussio
05:30:40 <hpc> https://github.com/ghc-proposals/ghc-proposals/pull/6 - this is the proposal
05:31:01 <hpc> no milestone yet
05:31:47 <hpc> (not sure if they use that field)
05:32:50 <{AS}> thanks
05:34:34 * hpc . o O ( lambda syntax is a pretty convenient way to distinguish "this is a placeholder for syntax" from "this is an expression" )
05:57:44 * hackagebot pandoc-types 1.17.0.2 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.17.0.2 (JohnMacFarlane)
05:57:46 * hackagebot sparse-linear-algebra 0.1.0.3 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.1.0.3 (ocramz)
05:57:48 * hackagebot wikicfp-scraper 0.1.0.5 - Scrape WikiCFP web site  https://hackage.haskell.org/package/wikicfp-scraper-0.1.0.5 (debugito)
06:39:42 <hodapp> given the knowledge that stack works just fine in this build, can anyone make heads or tails of the errors at https://hackage.haskell.org/package/ion-1.0.0.0/reports/1 at "Compiling Ivory.Language.Syntax.Concrete.QQ.BitDataQQ"?
06:41:42 <dmwit> Is cabal choosing all the same dependency versions? Perhaps the type of `newtypeD` (or something else in that expression) has changed.
06:41:57 <hvr> hodapp: fwiw, I've just queued http://matrix.hackage.haskell.org/package/ion
06:42:57 <hodapp> hvr: thanks, I'll check back soon
06:44:01 <hodapp> bleah. only real reason I'm doing this is because I don't know how to upload docs from stack
06:57:45 * hackagebot pandoc-types 1.17.0.3 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.17.0.3 (JohnMacFarlane)
06:57:47 * hackagebot sparse-linear-algebra 0.2.0.0 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.0.0 (ocramz)
06:57:49 * hackagebot pareto 0.1.0.0 - A library for cause-effect relationships.  https://hackage.haskell.org/package/pareto-0.1.0.0 (bwe)
07:07:24 <hodapp> hvr: thanks, I see that it's working on 7.10 and not 8.0
07:08:06 <hvr> hodapp: I've just fixed up 'ivory' which had inaccurate version bounds
07:08:25 <hodapp> hvr: version bounds on what?
07:08:26 <hvr> hodapp: that may already allow the docbuilder to find a working installplan 
07:08:39 <hvr> hodapp: https://hackage.haskell.org/package/ivory-0.1.0.3/revisions/
07:08:46 <hodapp> hvr: the failing build was on 8.0 and it's still failing on 8.0 though
07:09:02 <hvr> hodapp: it takes a bit of time till the change propagates
07:09:17 <hvr> hodapp: if you look at http://matrix.hackage.haskell.org/package/ivory
07:09:26 <hodapp> hvr: oh, I thought you meant that that's why it was working on 7.8 (the changes you made)
07:09:41 <hvr> you see that one failure was casued by a missing upper bound on TH, and the other by a too lax lower boundon base
07:10:02 <hodapp> ohhh...
07:10:12 <hvr> anyway, now cabal will be able to avoid those situations
07:10:34 <hodapp> guess I'll check that link again soon
07:11:31 <hvr> and in addition to that, 'ion' needs a stricter lower bound on base
07:11:50 <hvr> (due to AMP)
07:11:53 <joncol> jophish: I see. It's a bit confusing with all the different versions of pretty printing libraries that are almost the same.
07:12:23 <jophish> yeah, it's a mess :(
07:12:52 <merijn> joncol, jophish: Implement a new one consolidating all the feature of the existing...waitaminute...
07:13:22 <lyxia> I was about to make the joke too.
07:14:28 <jophish> hahahah
07:14:51 <hodapp> hvr: what AMP-related issue is Ion bumping into?
07:17:12 <hvr> hodapp: assuming that Prelude exports <$>
07:17:18 <hvr> which is only true post-AMP
07:18:39 <hodapp> hvr: wouldn't that be better-resolved with the proper imports?
07:19:02 <hvr> hodapp: I'm not the maintainer :-)
07:19:11 <hodapp> hvr: I am :P
07:19:15 <hvr> hodapp: but regardless, the meta-data needed fixing
07:19:24 <hvr> for the version already uploaded to hackage
07:19:38 <hodapp> hvr: so if I fix the imports, existing version bounds should in theory be okay?
07:19:39 <merijn> hvr: Incidentally, is there a way to view all packages a given hackage account has access to?
07:19:42 <hvr> but you're right, if you care about supporting pre-GHC-7.10, you should tweak the imports
07:19:51 <hvr> merijn: yes
07:20:09 <hodapp> I think Galois wants to keep Ivory supporting older GHC (to a point) and I don't have any reason not to
07:20:09 <merijn> hvr: Where?
07:20:22 <hvr> merijn: http://hackage.haskell.org/user/jkarni
07:21:10 <hvr> merijn: i.e. just click on the username links you see e.g. for the uploader of a release, and you'll get to this user-page
07:21:52 <merijn> I don't see an uploader link on some of my own packages :p
07:22:06 <merijn> oh, I was looking in the wrong spot
07:22:11 <hvr> hodapp: I'd also suggest making use of https://github.com/hvr/multi-ghc-travis to make sure all GHCs you support do still build
07:25:04 <ph88> hey guys, i'm using stack and i'm trying to use this flag  https://github.com/ndmitchell/derive#appending-to-the-module  so i type  stack build --ghc-options '--append'  however now i get this message:  ghc: unrecognised flag: --append  anyone know how to use this ?
07:25:40 <hvr> ph88: it's supposed to be a cabal flag, not sure how to pass those to stack
07:26:08 <ph88> maybe cabal flags should go in the cabal file ?
07:26:19 <hvr> ph88: not really :-)
07:26:39 <hvr> ph88: here's how you control those flags with cabal: http://cabal.readthedocs.io/en/latest/installing-packages.html#controlling-flag-assignments
07:27:05 <hvr> maybe stack has a similiar CLI
07:27:06 <ph88> is extension DeriveDataTypeable needed to derive Generic ?
07:27:09 <hodapp> hvr: good idea, I'll do that
07:27:09 <ph88> oki
07:27:17 <hodapp> Travis is already set up
07:27:19 <hvr> ph88: no, you only need DeriveGeneric
07:27:24 <geekosaur> um, none of the above, that option ius to go to the derive program not cabal/stack/ghc as I read it
07:27:46 <geekosaur> there's an example using added OPTIONS_DERIVE pragma on that page
07:28:12 * hvr should have read more closely before suggesting cabal flags :-/
07:29:10 <ph88> hvr, stack build --ghc-options '-rtsopts -fprof-auto -fprof-auto-calls -fprof-cafs' --executable-profiling --flag derive:append
07:29:53 <ph88> ok that doesn't work then 
07:30:00 <ph88> anyway that would have been passing the cabal flag
07:32:27 <ph88> do i have to do anything other than {-# LANGUAGE CPP #-} to use the c pre processor ?
07:32:48 <hvr> ph88: nope, that should be enough
07:33:11 <hvr> ph88: unless you're referring to something 'derive'-specific
07:33:37 <phanimahesh> Did you make an offering to the CPP gods?
07:34:54 <ph88> :/
07:35:10 <ph88> i tried both the C and GHC preprocessor and i get errors with both  https://paste.fedoraproject.org/453931/71485714/
07:35:43 <ph88> eh the error message of one isn't correct, let me make a new paste ^^
07:36:26 <ph88> https://paste.fedoraproject.org/453935/71495814/
07:36:45 <hodapp> hvr: alright, ion seems to be building again; will hackage automatically try to rebuild given some time?
07:37:29 <ph88> anyone know how i can get either one of the preprocessors to work ?
07:37:56 <glguy> hodapp: ion transitively depends on an older GHC than the build bot uses
07:38:12 <glguy> hodapp: If you're the maintainer you should upload documentation for it manually
07:39:33 <geekosaur> ph88, the haskell preprocesor one "worked". Generic is not in the list at https://github.com/ndmitchell/derive#supported-derivations
07:40:09 <ph88> why is it trying to derive Generic ? this should already been derived
07:40:30 <glguy> hodapp: You’ll need to use this script or one of the other tools that does the same thing: https://raw.githubusercontent.com/ekmett/lens/7e269b3e79ee54c0b34e4c62770fa1220068b769/scripts/hackage-docs.sh
07:41:10 <ph88> i use  {-# LANGUAGE DeriveGeneric #-}   and   deriving (Eq, Show, Generic {-! Uniplate, Biplate !-})   on my types
07:41:44 <geekosaur> I don't know. I am not familiar with this tool, I'm just reading its docs...
07:42:14 <hodapp> glguy: lately I've just been trying to make the cabal build work so that I can make docs
07:42:19 <hodapp> as stack doesn't seem to be able to do this
07:44:39 <hvr> hodapp: fwiw, I uploaded docs: https://hackage.haskell.org/package/ion-1.0.0.0/docs/Ivory-Language-Ion.html
07:44:54 <hodapp> thank you
07:45:22 <hodapp> cabal build is completely b0rked on my machine and I'm trying to figure out why
07:45:29 <hvr> hodapp: you'll have to bug galois to make ivory compatible w/ GHC 8.0 though :)
07:45:45 <hodapp> I had sworn it was but perhaps I mis-remembered
07:45:56 <hvr> it failed due to template-haskell-2.11
07:46:33 <hodapp> oh...
07:47:54 <hvr> hodapp: the Git version may well be, as I see https://github.com/GaloisInc/ivory/commit/637eeab77e9956e54bc8702d80c473dc1ae80ddf
07:49:31 <hodapp> perhaps that's what I was remembering
07:50:38 <muzzle> hi
07:50:57 <hodapp> hi!
07:50:58 <muzzle> does anyone have an idea how i can use the @{...} interpolation in yesod with julius
07:51:05 <muzzle> if i have a route with parameters
07:51:11 <muzzle> where I want to pass in javascript parameters
07:56:21 <Squarism> Does one say a function  "myFkn :: ... -> IO a" has side effects or that it just returns IO actions?
07:56:40 <phadej> both are right
07:57:09 <Squarism> so its not pure?
07:57:47 * hackagebot clash-systemverilog 0.6.10 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.6.10 (ChristiaanBaaij)
07:57:47 <phadej> well, that depends on how you define "pure" :)
07:57:49 * hackagebot clash-verilog 0.6.10 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.6.10 (ChristiaanBaaij)
07:57:51 * hackagebot clash-ghc 0.6.24 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.24 (ChristiaanBaaij)
07:57:53 * hackagebot sparse-linear-algebra 0.2.0.1 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.0.1 (ocramz)
07:57:55 * hackagebot HsOpenSSL 0.11.3.2 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.3.2 (VladimirShabanov)
07:59:21 <phadej> Squarism: and whether your aim is to be as formal/rigid as possible or spend more time on the job, and not philosophical questions ;)
07:59:30 <sm> but yes, haskell programmers frequently call IO/non-IO code impure/pure
08:00:01 <c_wraith> I disagree.  I think it's dangerously misleading to call functions with an IO return value impure.  It makes people think IO is magical in ways that it isn't.
08:00:19 <glguy> Squarism: myFkn is a pure function, executing the resulting IO action will have the specified effects
08:00:22 <c_wraith> I think unsafePerformIO is impure.  That's a different case.
08:00:37 <phadej> c_wraith: good point!
08:00:48 <hexagoxel> "putStrLn is pure"
08:00:52 <hexagoxel> i dunno..
08:01:00 <hexagoxel> yes, but misleading as well
08:01:02 <sm> that goes against common usage, certainly
08:01:12 <phadej> hexagoxel: but:
08:01:20 <phadej> > const 'a' (putStrLn "foobar")
08:01:22 <lambdabot>  'a'
08:02:40 <Squarism> phadej, glguy : i want to be formal when explaining haskell to imperative programmers. 
08:03:08 <Squarism> Feels like.. "its pure, but not really" wont do 
08:03:27 <phadej> Squarism: then you should define what being pure means
08:03:50 <c_wraith> It is pure, but actually really.
08:04:07 <Squarism> ok, good
08:05:03 <phadej> Squarism: with "pure = referentially transparent" definition everything in Haskell is pure (sans unsafePerformIO)
08:05:12 <c_wraith> The biggest danger when explaining Haskell to people who don't know it is that they may have heard of the language and got the impression they need to understand monads.
08:05:21 <joncol> merijn: haha
08:05:21 <c_wraith> That's a far bigger worry than the nature of purity
08:06:09 <Squarism> i thought pure meant that a function does not have sideeffects? 
08:06:40 <c_wraith> being referentially transparent implies that it can't have side effects.
08:06:42 <tdammers> it does
08:07:00 <tdammers> referential transparency is a subset of the effects of purity
08:07:43 <tdammers> you can write functions that are impure but (arguably) referentially transparent, at least under a certain frame of reference
08:08:18 <tdammers> for example, a function that does something pure but also logs intermediate computation steps could be considered referentially transparent, because the logging does not cause it to produce different outputs on subsequent invocations
08:08:25 <tdammers> but it is not pure, because it does have side effects
08:08:41 <ph88> i have a question about   https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Direct.html   is  ||* for when refering to a list of self   and  ||+  for a list of other datas ?
08:08:55 <tdammers> anyway, the thing with functions like putStrLn is that they are pure in the sense that they do not *have* side effects, they merely *describe* effects
08:09:29 <tdammers> you could say that putStrLn is a pure function that takes a string and returns an action
08:09:38 <tdammers> the action is impure, but the function is not
08:10:17 <tdammers> and from within the Haskell language, we don't execute the action, we merely describe it, and purely combine it with other actions to construct more complex actions
08:10:31 <tdammers> and then we purely bind one such action to Main.main, and the runtime executes it
08:10:47 <tdammers> that last part is of course impure, but we don't do that ourselves, the runtime does
08:15:03 <c_wraith> .tell Squarism The thing I don't like about calling something like "print :: Show a => a -> IO ()" an impure function is that it assigns misleading meaning to IO.  How do you describe "timeout :: IO a -> IO (Maybe a)" or "join :: IO (IO a) -> IO a" or even what a type like "IO (IO a)" means when you think "IO" means "this function is impure"?
08:15:51 <c_wraith> err
08:15:57 <c_wraith> @tell Squarism The thing I don't like about calling something like "print :: Show a => a -> IO ()" an impure function is that it assigns misleading meaning to IO.  How do you describe "timeout :: IO a -> IO (Maybe a)" or "join :: IO (IO a) -> IO a" or even what a type like "IO (IO a)" means when you think "IO" means "this function is impure"?
08:15:57 <lambdabot> Consider it noted.
08:18:31 <ph88> i'm trying to use Uniplate.Direct i made and instance for my data https://paste.fedoraproject.org/453955/47671739/ .. i don't understand why the compiler still wants to use Data because i want to use Uniplate.Direct and not https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Data.html where i need to derive Data and Typeable
08:19:58 <ph88> import Data.Generics.Uniplate.Direct (plate, (|-))
08:49:58 <colo> using V2 from Linear.V2 why doesnt the function: f :: V2 Double -> Double -> V2 Double       f vect k = vect/k work while f :: V2 Double -> V2 Double      f vect = vect/2.5 does?
08:50:11 <glguy> ph88: It’ll be hard to guess what you did wrong; there is not enough in that paste to reproduce the problem
08:50:38 <glguy> colo: Because in the second bit of code 2.5 :: Vector Double
08:50:50 <glguy> colo: and in the first bit k :: Double
08:51:07 <glguy> Since the type of (/) :: Fractional a => a -> a -> a
08:51:14 <glguy> You can't divide a V2 Double by a Double
08:51:24 <zaquest> :t (^/)
08:51:25 <glguy> the types of the arguments to (/) must match
08:51:25 <lambdabot> error:
08:51:26 <lambdabot>     • Variable not in scope: ^/
08:51:26 <lambdabot>     • Perhaps you meant one of these:
08:53:02 <isovector> i have the following constraints satisfied: `∀(a :: k1). c (f a)` and `∀(b :: k2). c (g b)`, and am trying to use them to get some `h` to satisfy `∀a b. c (h (Either a b))`. any thoughts?
08:53:31 <colo> ok thanks
08:53:48 <isovector> err. that last bit should be: `∀(d :: Either k1 k2). c (h d)`
09:02:34 <pi3r2> Using stack build on nightly seems to be so slow with the latest v1.2.0. Is it something that others have noticed ? 4 CPU at 100% 5G of RAM and it takes to b uild a medium size project.
09:04:20 <sm> pi3r2: not me. Is it building more packages than you expect, or building the expected packages slower than you expect ?
09:04:49 <pi3r2> sm: no, What suprised me the most is that changing the LTS to jump 15 days is causing another very long rebuild.
09:05:51 <pi3r2> anyhow I am switching to the latest nixos as well so it is difficult to tell what's causing such a slowdown.
09:06:40 <pi3r2> at least it does build nicely and the integration with nix just works now
09:08:36 <pi3r2> copy/register is just slow for some reason
09:14:16 <ph88> anyone know what the error on line 15 is about? https://paste.fedoraproject.org/453976/47672079/  more specifically: what argument would fit here ?
09:15:07 <ph88> glguy, i think it's because i put the constraint on aeis to be  Data from => from -> from  .. i made a small test case, without that it doesn't require to derive Data
09:16:44 <glguy> ph88: Did you look at the example at the top of http://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Direct.html
09:18:10 <lyxia> ph88: class Uniplate to => Biplate from to where    <--- Biplate takes two arguments.
09:18:21 <ph88> glguy, yes
09:18:34 <glguy> ph88: OK, do that
09:18:46 <ph88> oh i see my mistake
09:18:48 <ph88> thx lyxia 
09:20:22 <ph88> should i use the  MultiParamTypeClasses as described on line 17? https://paste.fedoraproject.org/453978/72117314/
09:20:41 <glguy> ph88: You have to enable MultiParamTypeClasses to make an instance of one
09:20:50 <glguy> and Bipate is a multi-parameter typeclass
09:20:57 <ph88> that's not in the documentation but ok i will enable MultiParamTypeClasses
09:22:07 <ph88> glguy, why do you say that Biplate is not a multi-parameter typeclass ? it expects two arguments, no ?
09:22:25 <koray> anyone else having problems with building stuff with LTS-7.x on Ubuntu Yakkety?
09:22:46 <ph88> koray, no problem here ^^
09:22:56 <koray> I can't seem to build the clock-0.7.2 lib
09:23:15 <ph88> koray, maybe use verbose flag on stack
09:23:52 <koray> this one here: https://github.com/corsis/clock/issues/43
09:24:11 <koray> ph88: will do, thanks
09:24:34 <glguy> ph88: I said 09:20 glguy           : and Bipate is a multi-parameter typeclass
09:25:08 <ph88> indeed you did .. strange that i misread that o_O
09:26:44 <koray> ph88: I think this is about the pie stuff being enabled by default on Yakkety, I keep getting this error (which I can also see without --verbose): /usr/bin/ld: .stack-work/dist/x86_64-linux-nopie/Cabal-1.24.0.0/build/System/Clock_hsc_make.o: relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC
09:27:35 <koray> if I try to build that repo (clock) with `cabal build`, it works alright btw :/
09:28:30 <ph88> glguy, any idea what type annotation i could supply here? https://paste.fedoraproject.org/453981/76721639/  before i was  saying from is   Data from => from -> from  but now i don't use Uniplate.Data anymore but Uniplate.Direct
09:29:07 <ph88> koray, try stack clean first ^^
09:29:30 <ph88> koray, maybe google for "stack gcc flags" so you can supply -fPIC somewhere ^^
09:29:54 <ph88> i had this error when compiling a C program, -fPIC fixes that error
09:30:46 <ph88> do you think the file is being compiled by gcc or ghc? for ghc i don't know what flag generates position independent code
09:30:55 <ph88> maybe that's worth another google "ghc position independent code"
09:32:52 <koray> ph88: I saw somewhere to use `stack build --ghc-options "-fPIC -optc-fPIC` but then I saw that Stack has a new version that install GHC with nopie, so it should have build with no PIC I guess :/
09:33:07 <koray> so maybe it's being compiled with gcc
09:34:56 <ph88> what's nopie ?
09:35:45 <ph88> well if it's haskell program for sure it's compiled but ghc .. but i notice that sometimes haskell programs dependent on some C files ^^
09:39:16 <koray> I guess it's a special version of ghc for yakkety that don't use pie :) and clock seem to require some C files because it's providing some realtime clock stuff
09:41:35 <koray> so my version of stack is 1.2.1 (installed via `stack upgrade --git`) and that installs the nopie version of GHC 8.0.1
09:55:13 <ph88> koray, what's pie? :/
09:57:50 * hackagebot twitter-feed 0.2.0.11 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.11 (jpvillaisaza)
09:57:52 * hackagebot sparse-linear-algebra 0.2.0.2 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.0.2 (ocramz)
09:58:37 <geekosaur> position independent executable
09:58:46 <geekosaur> a program, as opposed to a library, built with PIC
10:00:21 <joe9> Does anyone know the equivalent command using stack repl: stack exec ghci -- -Wall Network/NineP/Server.hs ? I understand the stack syntax of packagename:exe:executablename
10:00:41 <joe9> but, cannot figure out howto load a particular haskell file instead
10:02:20 <isovector> joe9: stack ghci packagename:exe:executable
10:02:47 <isovector> oh, sorry, misread
10:03:23 <isovector> is there a known trick to partially apply type synonym families?
10:07:54 <saurabhnanda> design question -- is it a good idea to put your domain API in a big-fat transformer stack (DB + Redis + Logging + Email + whatever), or is it better to make smaller monad stacks for different functions and compose as needed?
10:08:55 <bitemyapp> I usually have two monads
10:08:57 <bitemyapp> Handler and DB
10:09:14 <bitemyapp> DB only knows/cares about the Reader for the connection pool and MonadIO, generally.
10:09:22 <bitemyapp> Handler is whatever your web stack Monad is.
10:09:26 <saurabhnanda> bitemyapp: and the DB monad doesn't implicitly depend on Handler, right?
10:09:53 <bitemyapp> it does not, I'll have a runDB combinator that lifts DB into Handler instead.
10:10:02 <saurabhnanda> bitemyapp: so, if you have to create a user and send the user an activation email, would you create one function or two? if two, would they be in different monads?
10:10:39 <bitemyapp> For logging, I'll just have an mtl-style class with an instance for my Handler type.
10:10:39 <EvanR> updating the database, this is a separate thing completely from sending email. you shouldnt be sending email from within a transation
10:10:43 <chreekat> I do the same as bitemyapp incidentally
10:10:55 <chreekat> DB/Handler split
10:10:57 <EvanR> ideally, you insert the fact that an email should go out during the transaction
10:11:00 <bitemyapp> chreekat: I think it's something a lot of Yesod users converge on.
10:11:09 <bitemyapp> chreekat: I ended up replicating it in Servant with good success.
10:11:22 <EvanR> if the transaction fails, the email doesnt go out, if it succeeds, the email definitely will go out
10:11:23 <chreekat> bitemyapp: cool, I hope to play with Servant some time
10:11:35 <bitemyapp> saurabhnanda: I'm not sure what database you're using but the semantics of database transactions make sending an email inside one not a great idea.
10:11:44 <saurabhnanda> EvanR: email can be implemented outside the DB txn as well, but inside the DB monad, right?
10:11:51 <bitemyapp> chreekat: I might be able to help when you get there. There's been some gnarly bits.
10:12:00 <bitemyapp> chreekat: I'm working on the storefront for Lore Pub in Servant.
10:12:18 <saurabhnanda> okay, let me think of a different example
10:12:32 <EvanR> saurabhnanda: sure. my remarks are kind of orthogonal to how you organize monads. but if you organize them in some way related to real life, then maybe its relevant
10:12:43 <saurabhnanda> update a record in the DB and then bust the Redis cache. One function or two? Single monad or separate monads?
10:12:54 <bitemyapp> generally speaking I try to keep IO actions inside a DB transaction limited to things which could fail and which should abort the transaction, but which aren't going to mess anything up if they get repeated.
10:12:56 <EvanR> when bitemyapp said DB monad i figured it was completely a transaction monad
10:13:04 <bitemyapp> It is a transaction monad.
10:13:09 <bitemyapp> but it's also got MonadIO.
10:13:15 <EvanR> right so i was confused after that
10:13:29 <bitemyapp> the monad shoves the Reader out until you're ready to "run" the monadically combined actions.
10:13:46 <saurabhnanda> bitemyapp: I'm sorry, what's a "transaction monad"
10:13:59 <EvanR> a monad is a great way to define a transaction complete with "what to do with what comes back in the intermediate state" without actually doing IO
10:14:10 <saurabhnanda> so, DB update + Redis cache busting? Single monad, or separate monads?
10:14:19 <EvanR> thats sort of how datomic has done it, though without monads
10:14:23 <bitemyapp> saurabhnanda: do you understand what a database transaction is?
10:14:41 <saurabhnanda> bitemyapp: yes, I do. Unless you're referring to something very subtle.
10:15:28 <bitemyapp> the monad, until you ground out the reader and actually "run it" is delimiting some transaction which has zero or more actions inside it which potentially talk to the database.
10:16:38 <saurabhnanda> bitemyapp: are you referring specifically to how Persistent implements it?
10:16:39 <EvanR> just checking, why does it need MonadIO ?
10:17:13 <bitemyapp> you have an IO action which furnishes information needed for query 2
10:17:25 <saurabhnanda> bitemyapp: because it's not always necessary that a DB action (monad) necessarily needs to be a DB txn
10:17:26 <bitemyapp> query 1 furnishs information needed to run the IO action
10:17:45 <EvanR> hmm spooky
10:17:48 <bitemyapp> running this in two different transactions because you have developed a puritanical cleanliness complex about IO is going to break atomicity.
10:17:51 <EvanR> thats not very transactional, potentially
10:18:00 <bitemyapp> so you run it one transaction, let it abort and rollback if something fails.
10:18:07 <bitemyapp> uhm...this is the point of database transactions.
10:18:13 <chreekat> bitemyapp: tangentially, would you agree that Database.Persist.Sql.transactionSave should be considered unsafe? It breaks the relationship between a SqlPersistT value and a single transaction
10:18:19 <bitemyapp> If we could everything inside the database, BEGIN/COMMIT wouldn't exist
10:18:37 <bitemyapp> chreekat: yeah but my coworker has monkeyed around with such before.
10:18:49 <EvanR> if you want to repeat this transaction on the prior state again, youd have to recreate whatever context the IO was accessing
10:18:53 <bitemyapp> unsafeTransactionSave would be a better canary.
10:18:56 <bitemyapp> but what can yeh do.
10:18:59 <chreekat> Yeah, I don't think I'd want to throw it out, but yeah
10:19:52 <saurabhnanda> okay, I've lost the discussion. I'm not sure I agree that DB monad == DB txn. Persistent = Exhibit A.
10:19:55 <EvanR> i wasnt suggesting breaking it into two transactions
10:20:21 <bitemyapp> ooooookay
10:20:55 <EvanR> just saying datomic transactions dont have IO, its a piece of data
10:21:27 <bitemyapp> having used Datomic in production, I don't care.
10:21:51 <bitemyapp> datomic is a terrible scam
10:21:57 <EvanR> kind of klunky UI and API... 
10:22:05 <EvanR> and performance issues
10:22:18 <bitemyapp> it's a way to dump labor that isn't on a client assignment
10:22:19 <bitemyapp> that's it.
10:22:47 <EvanR> and they could use more types in the data model
10:24:38 <saurabhnanda> are we saying there's no way to write the following as a single Haskell monadic operation:  BEGIN; Write to DB; COMMIT; Bust Redis Cache ?
10:24:56 <chreekat> EvanR: in principle i agree that a DB monad shouldn't have access to IO. It's one of my lesser gripes about Persistent, though
10:25:42 <EvanR> yeah im not going to complain about persistent but thats just how i would do it
10:26:17 <EvanR> saurabhnanda: no, you can combine however much you want into one giant monad
10:26:39 <EvanR> but theres an uncanny valley where its so big why did you just use ReaderT over IO
10:26:44 <EvanR> didnt*
10:27:04 <EvanR> (partial answer, you went with the transformer stack happy frameworks)
10:28:10 <saurabhnanda> so, if everything is in one giant transformer stack, then you're basically losing the ability to track effects -- basically if everything is in IO then you're tossing away purity.
10:28:32 <EvanR> if you have a giant transformer stack which has IO...
10:28:35 <chreekat> saurabhnanda: you could go either way, putting the redis action inside the SqlPersist value (liftIO bustRedis), or inside a Handler value (liftIO bustRedis), since both are instances of MonadIO. I'd probably keep it in the Handler, outside of the DB
10:28:37 <saurabhnanda> so, what's a good middle ground -- separate monads for separate components of the app -- email, DB, Redis?
10:28:46 <EvanR> thats not "more pure"
10:29:00 <EvanR> not that purity is the issue
10:30:28 <EvanR> one transformer is enough to deal with, having multiple ones which reimplement support and you have to mediate between with runs lifts and hoists... sounds like its past the critical mass
10:30:44 <EvanR> and if they can all do IO...
10:32:16 <saurabhnanda> that's exactly what I'm debating internally
10:32:29 <saurabhnanda> if everything essentially is a MonadIO, any IO action can be lifted into it
10:32:37 <saurabhnanda> does it really give me any effect tracking at all?
10:32:58 <EvanR> what do you mean effect tracking?
10:33:19 <saurabhnanda> If I have a DB monad and a Redis monad, is there any way to ensure that Redis is not accessed inside DB monad and vice versa?
10:33:49 <EvanR> the key being who has the connection handle
10:34:46 <chreekat> I think it's the same security/ease-of-use tradeoff one finds elsewhere. One is either burdened with threading a ton of values around, or burdened with verifying good coding standards and practices wrt "what kinds of actions do we allow in X"
10:34:46 <EvanR> stopping yourself from doing obvious stupid and out-of-the-way stuff seems like less of a concern than needing types which guide you to what youre supposed to be doing
10:44:27 <saurabhnanda> EvanR: sorry got disconnected
10:44:45 <saurabhnanda> the app is going to initialize two pools -- DB pool and redis pool. and they will need to be in some sort of a ReaderT monad. which means separate ReaderT monads?
10:47:25 <EjikPoni> hi
10:47:46 <lambdabot> Hello.
10:50:13 <karina_> hi
10:50:35 <EjikPoni> аалалалал
10:51:55 <ph88> anyone know what the error on line 15 is about? https://paste.fedoraproject.org/453976/47672079/  more specifically: what argument would fit here ?
10:52:49 <Tuplanolla> :t Data.Generics.Uniplate.Direct.Biplate
10:52:51 <lambdabot> error:
10:52:51 <lambdabot>     Not in scope:
10:52:51 <lambdabot>       data constructor ‘Data.Generics.Uniplate.Direct.Biplate’
10:53:13 <glguy> Tuplanolla: That's got to be an accidental repost of the question from about an hour earlier
10:53:39 <Tuplanolla> Good to know, glguy.
10:54:30 <saurabhnanda> is there a roundup on various logging libraries in haskell?
10:57:52 * hackagebot sparse-linear-algebra 0.2.0.3 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.0.3 (ocramz)
10:57:54 * hackagebot colonnade 0.4.6 - Generic types and functions for columnar encoding and decoding  https://hackage.haskell.org/package/colonnade-0.4.6 (andrewthad)
10:57:56 * hackagebot reflex-dom-colonnade 0.4.6 - Use colonnade with reflex-dom  https://hackage.haskell.org/package/reflex-dom-colonnade-0.4.6 (andrewthad)
10:57:58 * hackagebot yesod-colonnade 0.1 - Helper functions for using yesod with colonnade  https://hackage.haskell.org/package/yesod-colonnade-0.1 (andrewthad)
10:58:00 * hackagebot hsexif 0.6.0.10 - EXIF handling library in pure Haskell  https://hackage.haskell.org/package/hsexif-0.6.0.10 (EmmanuelTouzery)
11:00:43 <ReinH> ph88: Biplate takes two types, look at the example
11:00:55 <ReinH> Oh, sorry
11:02:47 <joe9> geekosaur: Is there a WordMap instead of an IntMap? Or, is it just HashMap?
11:03:02 * hackagebot app-settings 0.2.0.9 - A library to manage application settings (INI file-like)  https://hackage.haskell.org/package/app-settings-0.2.0.9 (EmmanuelTouzery)
11:04:09 <geekosaur> the general ones are Map and HashMap
11:07:47 <PhsShft> How do you check whether input texts are all ASCII chars ?
11:08:16 <PhsShft> Is there a regular expression matching for ASCII characters ?
11:09:23 <maerwald> what is input texts?
11:10:21 <PhsShft> umm. let’s say im checking the chars in a text file one by one
11:10:38 <maerwald> in haskell, a parser is more "natural" than doing regexp stuff
11:10:46 <maerwald> so you would just fire it through a parser
11:11:16 <ongy> for that something like 'all ((<127) . ord)' might be enough aswell
11:11:24 <PhsShft> haven’t learned about Parser yet lol
11:14:48 <Tuplanolla> :t Text.Parsec.runParser (Text.Parsec.many (Text.Parsec.oneOf ['\NUL' .. '\DEL']) <* Text.Parsec.eof) () ""
11:14:50 <lambdabot> Text.Parsec.Prim.Stream s Identity Char => s -> Either Text.Parsec.Error.ParseError [Char]
11:14:55 <Tuplanolla> That should do, PhsShft.
11:15:08 <glguy> all isAscii :: String -> Bool
11:15:29 <Tuplanolla> Assuming you want a parser.
11:15:34 <maerwald> "all" is slow
11:15:57 <maerwald> man1 $ satisfy isAscii -- or something like that with attoparsec
11:15:59 <maerwald> *many1
11:16:08 <PhsShft> I’ll look up isAscii
11:16:28 <glguy> PhsShft: It's in Data.Char
11:18:35 <PhsShft> Thank you all
11:18:49 <glguy> If the input is a bytestring there'd be no reason to drag attoparsec onto the scene rather than to use bytestring's all
11:31:58 * geekosaur notes that we never even got to whether they actually mean ASCII, or some "you know what I mean" that is not in fact obvious (control chars? only some of them? ISO8859 extensions?)
11:38:39 <glguy> and now I guess we’ll never know
11:39:32 <monochrom> we will not know. we must not know.
11:42:08 <Hafydd> If you ask a shit question, you get a shit answer.
11:42:23 <Hafydd> So justice has been done, in my opinion.
11:42:39 <nitrix> Surely there must be a better way to word this.
11:42:47 <glguy> Or maybe everything worked out great and there's no need to talk like that
11:43:00 <dmj`> I have a question about unifying an existential type with some free variable.
11:43:04 <dmj`> http://lpaste.net/272513
11:43:11 <Hafydd> If they asked what they really wanted, then my second statement still applies.
11:43:29 <dmj`> I'd like the 'action' in K (returnType -> action) to be the same as the 'action' in (action -> IO ())
11:43:31 <glguy> and whether or not they did you can drop the first statement
11:43:46 <Hafydd> Do you disagree that it is true?
11:44:12 <monochrom> I don't think an existential type can be unified with a free variable, or at least a type of your choice.
11:44:13 <geekosaur> dmj`, by definition if it is existential then it cannot unify
11:44:18 --- mode: ChanServ set +q *!*@unaffiliated/joo
11:44:34 <nitrix> dmj`: You cannot, unless you parametrize K over it.
11:44:45 <nitrix> dmj`: That's the very issue of existantial types.
11:44:49 <geekosaur> bu then it is not existential
11:45:51 <haskell303> hey, I'm following LYAHFGG, and tried to slightly modify the rpn solver and add an interaction to it, but my putStr isn't showing up until I write my input, why is this? http://lpaste.net/272525
11:46:18 <geekosaur> because output is line buffered by default, and haskell does not have ghc's hack to autoflush stdout if you read in stdin
11:46:21 <monochrom> Suppose I have created a value of K. Then I have chosen a secret type for "action".
11:46:23 <ianclark> All right, so I want to make sure I'm doing something correct: I query a database and wrap the resulting record in an IO monad because it's impure code. I should then pass the IO <record> to a pure function to extract fields in that record and return a pure value, correct?
11:46:42 <geekosaur> er
11:46:43 <nitrix> haskell303: Use putStrLn. On linux, stdout is lined buffered.
11:46:43 <haskell303> oh, so changing to putStrLn fixes it?
11:46:47 <geekosaur> glibc's hack
11:46:56 <haskell303> cool, thanks!
11:46:58 <geekosaur> or using hSetBuffering
11:47:13 <geekosaur> (you would need to import System.IO)
11:47:52 <nitrix> Alternatively, hSetBuffering stdout NoBuffering
11:48:06 <nitrix> But then you'll have to use the `h`-family of functions.
11:48:13 <geekosaur> ?
11:48:21 <nitrix> Or not?
11:48:36 <geekosaur> putStrLn = hPutStrLn stdout
11:48:55 <geekosaur> it's not some magic that ceases to work if you ever do an h-function on stdout yourself
11:48:55 <chreekat> ^
11:49:04 <dmj`> geekosaur, nitrix: I was afraid of that, if I parametrize K over action, then if I do so, Irun into another problem regarding Typeable
11:49:12 <chreekat> it's the other kind of magic, global magic
11:49:29 * chreekat throws sparkles
11:49:52 <nitrix> geekosaur: My mistake. Forgot how handles affected that reasoning.
11:50:04 <monochrom> the other alternative is to remake testK as: K -> (forall action. action -> IO ()) -> IO ()
11:50:20 <nitrix> It's very reminiscent of C :/
11:50:24 <monochrom> and this incurs RankNTypes
11:50:25 <geekosaur> stdout is special only insofar as the OS hands it to you instead of you needing to open it
11:50:46 <geekosaur> (and even that is only convention...)
11:51:27 <monochrom> and this also incurs restrictions on testK's 2nd parameter
11:51:49 <amx> ianclark: your database library would already give you the result wrapped in IO.
11:52:15 <dmj`> monochrom: woa
11:52:32 <dmj`> I'm trying to round trip some haskell through javascript, but retain type information
11:52:47 <ianclark> amx: The part I was confused about was essentially getting the field from a Record wrapped in an IO monad. I would have to wrap it in a `do` block and use pure functions to get the fields from the Record, correct?
11:53:01 <geekosaur> or use >>=
11:53:02 <monochrom> I think overall K is mis-designed. It is not very useful.
11:53:08 <ianclark> Or that
11:53:17 <dmj`> monochrom: this works, but it didn't incur RankNTypes
11:53:20 <dmj`> http://lpaste.net/272576
11:53:22 <amx> ianclark: yes, within the do-block you can use it normally
11:53:37 <ianclark> amx: Thanks :)
11:53:38 <dmj`> unsafeCoerce is safe here
11:53:40 <nitrix> dmj`: I did the same thing for a similar library that is using Dynamic/Typeable. Functions are high-order and `(action -> IO ())` are values that can literally be part of your existantial.
11:54:09 <nitrix> dmj`: This is when lazy-evaluzation becomes lovely :)
11:54:12 <monochrom> It contains two fields. The 2nd field is an unknown returnType. The only think I can do is to pass it to the 1st field and get yet another unknown action type. Great, I'm chasing more unknowns.
11:54:26 <dmj`> nitrix: hmmm :)
11:55:01 <dmj`> yes, lots of unknowns
11:55:02 <nitrix> dmj`: You partially apply the `action` when the existantial is created, save the IO () for later.
11:55:19 <nitrix> https://github.com/nitrix/lspace/blob/master/src/Link.hs#L45
11:55:27 <monochrom> Your new design now has the problem of "how do I even create a value of K?"
11:55:27 <nitrix> Please don't look at the rest to not vomit.
11:55:49 <mizu_no_oto_work>  \j #haskell-ops
11:56:00 <mizu_no_oto_work>  /j #haskell-ops
11:56:03 <dmj`> nitrix: yes, can do that too :] 
11:56:21 <monochrom> programming is a dialectic class struggle between doing the possible and doing the useful.
11:56:44 <monochrom> s/the useful/the would-be useful/
11:56:51 <dmj`> monochrom: yes it's complicated, I've hidden other parts of K, which consist of a class constraint that contains a Symbol, and a free monad
11:57:24 <dmj`> constructing K is done through a function 'on'
11:57:39 <monochrom> with forall and exist types, it's so easy to go the "possible" extreme that it would be useless. Or to go the "would-be useful" extreme that it is not possible.
11:57:53 * hackagebot udp-conduit 0.1.0.0 - Simple fire-and-forget conduit UDP wrappers  https://hackage.haskell.org/package/udp-conduit-0.1.0.0 (kqr)
11:57:55 * hackagebot maxsharing 1.1 - Maximal sharing of terms in the lambda calculus with letrec  https://hackage.haskell.org/package/maxsharing-1.1 (JanRochel)
11:57:57 * hackagebot udp-conduit 0.1.0.2 - Simple fire-and-forget conduit UDP wrappers  https://hackage.haskell.org/package/udp-conduit-0.1.0.2 (kqr)
11:57:59 * hackagebot pipes-extras 1.0.7 - Extra utilities for pipes  https://hackage.haskell.org/package/pipes-extras-1.0.7 (GabrielGonzalez)
11:59:06 <dmj`> monochrom: 'on' would be something like on :: Proxy eventName -> (returnType -> action) -> K
11:59:26 <dmj`> and that higher order function would be hidden inside of K
11:59:36 <dmj`> but then pattern matched out later and applied
11:59:43 <dmj`> of the existential
12:01:51 <joe9> How does Data.Vector.modify work? Does it return a vector with the updated value?
12:02:11 <joe9> my usage:                 , cQids = V.modify (\v -> DVM.write v i Free) (cQids c)
12:02:31 <joe9> is how cQids is defined  , cQids :: Vector (FSItem Context)
12:02:38 <Tuplanolla> :t Data.Vector.modify
12:02:39 <lambdabot> (forall s. Data.Vector.Mutable.MVector s a -> ST s ()) -> Data.Vector.Vector a -> Data.Vector.Vector a
12:03:05 <joe9> I just used Data.Vector. (Does it mean that it is a mutable vector?)
12:03:26 <Tuplanolla> It's mutable while inside `ST`, joe9.
12:03:35 <joe9> Tuplanolla: oh, ok. Thanks.
12:04:10 <joe9> Tuplanolla: the return value from modify is the updated vector ,correct?
12:04:42 <Tuplanolla> Yes. It doesn't make any sense to use it to perform a single write as you did there.
12:06:10 <joe9> Tuplanolla: What do you mean? I just need to update a single value. How would you recommend I do it?
12:07:09 <Tuplanolla> :t Data.Vector.update
12:07:10 <lambdabot> Data.Vector.Vector a -> Data.Vector.Vector (Int, a) -> Data.Vector.Vector a
12:07:43 <isovector> is anyone familiar with the constraints package?
12:08:35 <Tuplanolla> I also recommend reconsidering your approach if all you do is create a vector, change one element and then dispose it.
12:08:53 <joe9> Tuplanolla: But, I need to only change one value. I am not disposing it. It is part of my context
12:09:08 <Tuplanolla> All good then.
12:11:45 <joe9> Tuplanolla: https://github.com/joe9/9pserver/blob/master/Network/NineP/Internal/Context.hs#L110 is how I am defining it. https://github.com/joe9/9pserver/blob/master/Network/NineP/Internal/Response.hs#L100 is how I am using it.
12:23:35 --- mode: ChanServ set -q *!*@unaffiliated/joo
12:23:52 <ph88> ReinH, sorry my bad .. i was giving wrong paste ..  any idea what type annotation i could supply here? https://paste.fedoraproject.org/453981/76721639/  before i was  saying from is   Data from => from -> from  but now i don't use Uniplate.Data anymore but Uniplate.Direct
12:29:27 <sigrlami> how to build snap with support for ssl from stack?
12:30:34 <dmj`> monochrom: so, for some reason ImpredicativeTypes was enabled, that seems to also enable RankNTypes, so yes, forall r . (forall a . r -> a) r requires RankNTypes
12:40:26 <ReinH> ph88: Why are you using biplate?
12:40:32 <ReinH> why not just uniplate?
12:45:16 <ph88> ReinH, because later on i want to mix several types ... this is just a small test case
12:47:30 <d[10]> what's haskell ?
12:47:46 <kori> d[10]: it is a programming language
12:48:05 <d[10]> kori for web ?
12:48:26 <pikajude> potentially
12:48:36 <pikajude> haskell can perform any task, except for cleaning your house and washing your dog
12:48:52 <ReinH> And even then, we can say "not yet".
12:48:58 <fnurglewitz> pikajude: is that because you can't compile for the raspberry pi?
12:49:09 <pikajude> You could always cross-compile.
12:49:15 <fnurglewitz> does it work?
12:49:24 <ReinH> It's a general purpose functional programming language. Many people use it for web things.
12:49:25 <pikajude> also, s/house/apartment/ and s/dog/student loans/ for millenials.
12:49:42 <kori> d[10]: could be. it's general purpose.
12:49:42 <ReinH> Washing your student loans? Is that money laundering?
12:49:47 <pikajude> Exactly.
12:49:58 <kori> pikajude: I'd argue that point that it can't do that
12:50:04 <pikajude> I use Haskell for the web. I use compile-time code execution to embed all my static dependencies in the resulting executable.
12:50:08 <kori> eventually, it will be able to do that, just wait for the singularity
12:50:08 <ongy> apartment? luxus
12:50:13 <pikajude> The deploy process is an scp.
12:50:58 <d[10]> kori wow, nice!
12:53:55 <ph88> ReinH, do you understand my question ?
12:54:31 <ReinH> ph88: I think so, but I don't know what the solution is. Have you tried leaving off the type signature? Can the type be inferred?
12:54:35 <isovector> edwardk: is there some way of pulling a `forall x. f x ~ g (h x)` out of the constraints package combinators?
12:54:58 <ph88> ReinH, type signature of what ?
12:55:06 <ReinH> ph88: the function that isn't type checking.
12:55:26 <ph88> ReinH, yes line 17 is commented out
12:55:29 <ph88> i tried it like that
12:55:57 <ReinH> You might need scoped type variables so that `x' can reference the `from' in the outer type, but I'm not sure.
12:56:05 <ReinH> the type of `x', rather
12:56:48 <ph88> i can rewrite it without where maybe then i don't need scope ?
12:57:02 <ph88> or make it two toplevel functions
12:57:29 <edwardk> isovector: without f g or h being a type family i don't see that happening and i can't give you combinators for partially applying a type family
12:57:34 <ReinH> ph88: I'm not sure.
12:57:40 <ph88> ok
12:58:07 <isovector> edwardk: that's what i thought =( thanks anyway! 
13:01:31 <Phallus> Can I ask a haskell related question here or is there a separate channel for that?
13:02:28 <chreekat> nope, this is it
13:02:59 <Phallus> Alright, I just had ghc eat up all my ram
13:03:09 <Phallus> I simply closed my terminal
13:03:18 <Phallus> thinking that would end everything, but it clearly didn't
13:03:27 <Phallus> How do I prevent this from happening again?
13:04:18 <Phallus> Also, how do I properly exit when I'm stuck in an infinite loop (cause closing terminal clearly didn't work and :q doesn't work either when in a loop)
13:05:06 <Tuplanolla> You have three options.
13:05:59 <Tuplanolla> Send SIGINT with Control C to interrupt computations, prevent memory hogging with `ulimit` or don't write programs that use too much memory.
13:06:45 <Tuplanolla> These work for all other languages too.
13:07:13 <Phallus> Ah yes, didn't expect Control C to work on haskell
13:07:25 <Phallus> Thanks a lot 
13:07:28 <MarcelineVQ> it won't always but it's the first thing to try
13:07:29 <hexagoxel> and the language/compiler-specific +RTS -M500M
13:07:51 <hexagoxel> instead of ulimit that is
13:08:15 <Tuplanolla> That's good, but you have to compile with `-rtsopts`.
13:08:26 <hexagoxel> `ghci +RTS -M1G`
13:08:45 <hexagoxel> (i thought ghc was the offending program)
13:09:05 <Phallus> Well the process eating my ram was called ghc 
13:11:41 <MarcelineVQ> You can also use your system's process manager to kill ghc if you need to, if you can get it open without any ram left anyway :> Often the cause of unexpected memory use is that you've written an infintie loop so the first place to look is the code you're writing
13:11:49 <Phallus> I actually had another question, is it possible to use a filter like this filter 'function' list x y? Where list would be the list that needs to be filtered and 'x and y' extra parameters for that function. So far it seems I need to make a separate function that simply reorders the arguments so the list is in the end
13:12:02 <Phallus> MarcelineVQ Yeah that's how I fixed it.
13:12:04 <geekosaur> note that if this was ghci, the process that will be showing will be ghc (with --interactice)
13:12:10 <geekosaur> --interactive
13:12:51 <hexagoxel> (ghc seems to be compiled with -rtsopts, at least the one i am using.)
13:13:50 <geekosaur> yes, it generally is
13:15:51 <MarcelineVQ> lambda's are good for reordering things, it depends a bit what you're writing though, if you have a specific example it'd be better: \list x y -> filter (function x y) list
13:16:20 <Tuplanolla> @pl \ list x y -> filter (function x y) list
13:16:21 <lambdabot> flip (flip . (filter .) . function)
13:16:28 <Tuplanolla> Horrible.
13:17:50 <kaol> @pl \a b c d -> d c b a
13:17:51 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
13:18:58 <hexagoxel> flip filter list $ \a b -> _  is not that horrible though.
13:19:42 <Tuplanolla> :t flip flap flip flap
13:19:45 <lambdabot> (a -> (b -> (a1 -> b -> c1) -> a1 -> c1) -> c) -> a -> c
13:20:29 <ongy> :t flap
13:20:30 <Phallus> Thanks a lot for both answers
13:20:30 <lambdabot> b -> (a -> b -> c) -> a -> c
13:20:51 <kaol> :t flip
13:20:52 <lambdabot> (a -> b -> c) -> b -> a -> c
13:21:36 <ongy> can I get the qualified name of a function from lambdabot? @hoogle would do it, I guess
13:22:14 <geekosaur> there's @index but it's not very complete. I generally use hayoo (web)
13:25:44 <ph88> ReinH, fyi i found out with using ghci that it should be   aeis :: Biplate from Identifier => from -> from
13:26:42 <ph88> dont really understand why though ^^
13:41:07 <ski> glguy : ok
13:49:09 <nshepperd1> Phallus: i use https://github.com/rfjakob/earlyoom to auto kill processes that eat up all my ram without waiting for the computer to swap frantically for an hour :P
13:57:56 * hackagebot tracy 0.1.4.0 - Convenience wrappers for non-intrusive debug tracing  https://hackage.haskell.org/package/tracy-0.1.4.0 (dredozubov)
14:01:04 <sm> great name
14:02:28 * JuanDaugherty thinks FailUs would have worked better
14:02:59 * sm is talking about tracy :)
14:07:28 * JuanDaugherty yeah name but not much behind it
14:24:33 <stevenxl> Hello folks. 
14:24:55 <stevenxl> Question - when I see something like "instance Eq MyReallyGreatType where", is is proper to refer to that as an instance declaration?
14:27:39 <johnw> I'd call it an instance definition
14:28:11 <chreekat> stevenxl: Haskell98 chapter 4.3.2: "Instance Declarations"
14:28:15 <chreekat> I think you're in the clear
14:28:17 <johnw> or that :)
14:28:27 <stevenxl> Sweeet
14:28:29 <stevenxl> thanks folks.
14:28:33 <chreekat> :)
14:28:50 <stevenxl> So this Haskell98 - that's the bible?
14:30:09 <Kaidelong> does apfelmaus come in here?
14:30:27 <chreekat> I think that's something you can put in the Good Question box. It's just a standard.  There's Haskell2010, as well, and some people making noises about a new one
14:30:33 <Kaidelong> I have about 2 hours before the next class and was hoping I could do something to help that windows binary along
14:30:48 <stevenxl> ok thank you. 
14:31:11 <Kaidelong> (apfelmus?)
14:33:18 <ski> Kaidelong : they used to
14:33:30 <Kaidelong> shame
14:33:31 * ski haven't seen them for some time, though
14:33:46 <Kaidelong> did you see his announcement?
14:33:51 * ski did not
14:34:33 <Kaidelong> https://mail.haskell.org/pipermail/haskell/2016-October/025010.html
14:36:09 <ski> interesting
14:36:29 <ski> i think i've seen them semirecently on the network, though (but not in the channel)
14:43:40 <sm> I was just trying to think of a tool letting me set a fixed total then tweak a list of numbers, auto-adjusting the others as I edit to keep them summing to the total. Would HyperHaskell help build that ?
14:44:40 * sm thinks "FRP"
14:45:31 <jle`> sounds like something lensy
14:45:38 <jle`> not sure if it'd follow the laws though
14:46:59 <jle`> @let withTot f xs = (\ys -> fmap (sum xs/sum ys)) <$> traverse f xs
14:47:00 <lambdabot>  Defined.
14:47:10 <jle`> er wait
14:48:31 <sm> Kaidelong: I don't think so, but I'm sure you could so something.. maybe set up an appveyor script ?
14:48:38 <sm> s/so/do/
14:52:04 <jle`> @let withTot f xs = (\ys -> fmap (* (sum xs/sum ys)) ys) <$> f xs
14:52:05 <lambdabot>  Defined.
14:52:19 <jle`> > over (withTot . ix 0) [10,15,20]
14:52:22 <lambdabot>  error:
14:52:22 <lambdabot>      • Couldn't match expected type ‘IxValue (f1 b) -> IxValue (f1 b)’
14:52:22 <lambdabot>                    with actual type ‘[Integer]’
14:52:31 <jle`> > over (withTot . ix 0) (+1) [10,15,20]
14:52:33 <lambdabot>  [10.76086956521739,14.673913043478262,19.565217391304348]
14:53:17 <jle`> > over (withTot . ix 'a' (+4)) (M.fromList [('a', 10), ('b', 15), ('c', 20)])
14:53:20 <lambdabot>  error:
14:53:20 <lambdabot>      • Couldn't match type ‘Char -> Identity b0’ with ‘Identity (f1 b)’
14:53:20 <lambdabot>        Expected type: (Char -> Identity b0) -> t b -> Identity (f1 b)
14:53:29 <jle`> > over (withTot . ix 'a') (+1) (M.fromList [('a', 10), ('b', 15), ('c', 20)])
14:53:31 <lambdabot>  fromList [('a',10.76086956521739),('b',14.673913043478262),('c',19.565217391...
14:53:38 <jle`> adjust things but keep the total the same, heh
14:54:06 <jle`> this breaks a few lens laws
14:54:09 <sm> jle`: are you winning ? I can't tell :)
14:54:36 <jle`> yeah, the map had 10, 15, and 20, and so i add 1 to 10, but the others get smaller to keep the total still 45
14:55:23 <jle`> so it became a map with 11, 15, and 20, and then re-scaled itself to keep the total 45
14:55:33 <sm> ah, nice
14:55:53 <Tuplanolla> The next step up would be to make it exact and distribute the remainders somehow.
14:55:59 <sm> yes
14:56:09 <sm> that + a web gui and I'd be in business
14:56:43 <sm> or any gui
14:57:26 <sm> I guess a text file and a script to rewrite it would work
14:57:58 * hackagebot JuicyPixels-extra 0.1.1 - Efficiently scale, crop, flip images with JuicyPixels  https://hackage.haskell.org/package/JuicyPixels-extra-0.1.1 (mrkkrp)
14:58:24 <sm> I thought at first I could do it with spreadsheet formulas but I think not
15:11:49 <babu> p
15:12:16 <ski>   q
15:13:04 <babu> newtype Price = Price Float deriving (Show, Read)
15:13:05 <babu> p :: Price
15:13:05 <babu> p = read "23.5"
15:13:05 <babu> -- when I try to print the value of p in ghci, I get Price *** Exception: Prelude.read: no parse.
15:13:36 <jle`> @let newtype Price = Price Float deriving (Show, Read)
15:13:38 <lambdabot>  Defined.
15:13:39 <jle`> > Price 23.5
15:13:43 <lambdabot>  Price 23.5
15:13:51 <jle`> > read "Price 23.5" :: Price
15:13:53 <lambdabot>  Price 23.5
15:14:29 <jle`> read/show are sort of supposed to be inverses, so if showing Price 23.5 gets you "Price 23.5", then that's how it should be parsed too
15:15:12 <ski> (they're also supposed to convert between values, and string representations of Haskell expressions evaluating to that value (in an appropriate module environment))
15:15:48 <jle`> babu: try p = read "Price 23.5
15:15:53 <jle`> "
15:16:08 <ski>   p = Price (read "23.5")  -- would be another way to achive your possible goal
15:16:24 <ski> if you want to, you could define a function for that
15:16:27 <jle`> > Price (read "23.5")
15:16:30 <lambdabot>  Price 23.5
15:16:40 <ski>   readPrice :: String -> Price
15:16:47 <jle`> @let readPrice = Price . read
15:16:48 <ski>   readPrice str = Price (read str)
15:16:49 <lambdabot>  Defined.
15:16:52 * ski nods
15:16:54 <jle`> > readPrice "23.5"
15:16:56 <lambdabot>  Price 23.5
15:16:59 <jle`> :o
15:17:10 <jle`> @let readPriceMaybe = fmap Price . readMaybe
15:17:11 <lambdabot>  .L.hs:161:31: error:
15:17:12 <lambdabot>      Variable not in scope: readMaybe :: a -> f Float
15:17:14 <jle`> aw
15:17:21 <jle`> @let import Text.Read
15:17:22 <lambdabot>  Defined.
15:17:26 <jle`> @let readPriceMaybe = fmap Price . readMaybe
15:17:27 <lambdabot>  Defined.
15:18:31 * ski looks at babu
15:18:53 <jle`> don't mind me i'm just procrastinating
15:19:00 <jle`> i could do this all day
15:20:07 * ski . o O ( <http://www.structuredprocrastination.com/> )
15:20:46 <babu> jle`, ski: thanks.
15:21:09 <jle`> ski: do i dare click
15:21:30 <nacho1> Hello. Quick question, suppose I need the following package Text.Regex how do I search Hackage for the correct package that provides the functionality needed?
15:22:57 <jle`> nacho1: do you mean you need that module?
15:23:13 <jle`> you can search hoogle or another hackcage index to find out what package exports a given module
15:23:30 <jle`> http://hoogle.haskell.org/?hoogle=Text.Regex&scope=set%3Astackage
15:24:39 <nacho1> jle`: thanks!
15:25:15 <jle`> np!
15:25:27 <GLM> What ways can I query an Oracle database with Haskell?
15:25:37 <jle`> nacho1: another popular index is the stackage hoogle, stoogle
15:25:46 <jle`> https://www.stackage.org/lts-7.4/hoogle?q=Text.Regex
15:25:53 <jle`> disclaimer -- i'm the only person who calls it stoogle
15:26:04 <sm> good one!
15:26:36 <JaanusBanaanus> Hi guys, can anyone help me
15:26:42 <jle`> nacho1: but stagckage hoogle only indexes packages that are on stackage
15:26:45 <JaanusBanaanus> how do I convert this tree to a list of tuples: http://pastebin.com/EftT88Gm
15:27:21 <jle`> JaanusBanaanus: what would you want the list of tuples to be ...?
15:27:38 <JaanusBanaanus> desired output: fromList [('a',1),('a',3),('a',6),('a',20),('b',4),('b',8),('b',12)]
15:28:07 <jle`> oh, so you really just want MyTree a -> [a], right?
15:28:14 <JaanusBanaanus> yeah
15:28:36 <jle`> the simplest way would be to just use explicit recursion w/ concatenation
15:28:47 <Tuplanolla> Feels `Foldable`.
15:28:58 <jle`> toList (Two t1 x t2) = toList t1 ++ [x] ++ toList t2
15:29:11 <jle`> but yeah, you can also derive Foldable and use the toList that is automatically generated
15:29:54 <jle`> but when you do that, you can't control the order of the items in the output list
15:30:17 <jle`> the derfault toList that deriving Foldable gets you is an in-order traversal
15:32:12 <Tuplanolla> This Structured Procrastination describes me too perfectly, ski.
15:32:35 <ski> jle` : subtitle "Do Less, Deceive Yourself, And Succeed Long-Term"
15:35:54 <Tuplanolla> Too bad my thesis has been stuck at the top for a while now.
15:38:55 <JaanusBanaanus> jle`, but how could I get it to return "Set a" type
15:40:31 <monochrom> JaanusBanaanus, is this an exercise someone else designed? Where can I read the original exercise question?
15:44:00 <JaanusBanaanus> monochrom, it is an exercise indeed. Here is all the information that has been given: http://pastebin.com/dDhWtRij 
15:44:11 <Cale> JaanusBanaanus: Okay, so first of all, just try writing it with pattern matching and recursion: any tree that you match out of a pattern, you can assume that your function to traverse the tree works on that.
15:44:26 <Cale> So, like...
15:44:33 <Cale> inorder :: MyTree a -> [a]
15:44:48 <Tuplanolla> There's no exercise there, JaanusBanaanus.
15:44:48 <Cale> inorder (Two t1 x t2) = ...
15:45:01 <Cale> inorder (Three t1 x t2 y t3) = ...
15:45:42 <Cale> inorder (Node mx my) = ...
15:46:05 <Cale> In the Two and Three cases, you'll want to use inorder t1, etc.
15:46:09 <monochrom> OK, I am unconvinced that a list is involved at all. So-called "fromList [('a',1), ..." is how a Set is printed. It totally does not mean a list.
15:46:37 <Cale> oh, I didn't see a fromList
15:46:56 <Cale> But yeah, that clearly says  treeToList :: Ord a => MyTree a -> Set a
15:47:11 <Cale> treeToList is a misleading name for a function of that type
15:47:20 <monochrom> But yes you should use the strategy of "what to do for each pattern", and expect to use recursion somewhere.
15:48:08 <jle`> JeanCarloMachado: you can just write toList, and then use fromList at the end of that
15:48:50 <jle`> er, sorry, meant Jaa<tab> who is now offline
15:48:57 <jle`> JaanusBanaanus ^ (nvm)
15:49:02 <JeanCarloMachado> no problema :P
15:49:33 <JaanusBanaanus> I am not offline, trying to solve it with pattern matching atm :v
15:49:53 <jle`> oh yeah, sorry, i just misspelled your name when searching the list of users :)
15:50:08 <monochrom> there are functions like "insert" and "union" for Set for adding an element or merging two sets
15:50:57 <monochrom> for more information read the doc of Data.Set and find "insert" and "union"
15:53:12 <Tuplanolla> How often do you come across legitimate uses for lazy `ST`?
15:53:34 <ydl> when writing functions that take random number generators, is it more conventional/for some reason better to return a pair of the generator with the result, or to only return the result and expect the user of the function to split their original generator before passing to your function? so should a typical function look like "fr :: (RandomGen g) => g -> a -> (g, b)" or "fr :: (RandomGen g) => g -> a -> b"?
15:53:44 <monochrom> I still haven't come across one. Because I still don't understand its evaluation criteria.
15:54:20 <monochrom> my http://lpaste.net/63925 shows some examples I cannot coherently explain.
15:54:34 <Tuplanolla> I think I just found one. I'll tell you more when it fails.
15:54:43 <monochrom> well, the first few ones I can, but I can't explain the last one
15:55:27 <jle`> ydl: your first one is more conventional
15:55:35 <c_wraith> yeah, I can see uses for unsafeInterleaveST more often than lazy ST
15:55:42 <allenj12> so when trying to build stack I get, 'base-4.9.0.0 must match <4.7 && <4.9' shouldnt it auto replace base with a prior version if thats in my .cabal
15:56:02 <Cale> ydl: Usually people return a pair of the new generator and the result -- splitting repeatedly behaves poorly for StdGen (but is perfectly okay if you're using tf-random
15:56:02 <jle`> ydl: the second one actually throws away information, because a lot of RandomGen implementations get you a new seed with the result value at the same time
15:56:05 <Cale> )
15:56:27 <monochrom> base is irreplaceable. you have to actually switch GHC version.
15:56:39 <Cale> It's actually really sad that very little is known about the implementation of splittable PRNGs
15:56:42 <monochrom> basically base is non-negotiable.
15:56:45 <jle`> also the first one follows the common (s -> a -> (a, s)) Haskell idiom
15:56:57 <dcoutts> allenj12: as monochrom says the version of base is tied to the version of ghc
15:57:12 <Tuplanolla> I have a bunch of pseudorandom walkers on the natural numbers and they occasionally die or multiply. The idea is to produce an infinite list of their lifetimes placed at their graves.
15:57:30 <allenj12> monochrom: o gotcha, thanks
15:57:42 <jle`> er well, the idiom is actually a -> s -> (a, s), but yeah
15:57:58 <monochrom> of course, you could also switch stack version, find one that is happy with GHC 8.0.1
15:58:00 * hackagebot hw-bits 0.3.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.3.0.0 (haskellworks)
16:00:50 <allenj12> monochrom: im changing the lts-resolver to 6.22 (seems to be last 6 version). just trying to get cuda working
16:01:04 <ydl> jle`: how does it throw away information?
16:01:53 <jle`> look at the methods in the RandomGen typeclass
16:02:07 <jle`> they all generate new seeds while creating their values
16:02:10 <ydl> jle`: rather, i understand how it's losing the random number generator, but in terms of useful information isn't one half of a split-off gen just as good as an iteratively used gen?
16:02:21 <jle`> it's throwing away extra work
16:02:30 <jle`> so it's like taking the time to compute a new gen, then throwing it away
16:02:37 <jle`> and then making a new gen in a separate process
16:03:19 <jle`> so it's not exactly that it's throwing away information, but that it's throwing away work, heh
16:03:20 <monochrom> dcoutts: If a package gets the id "cabaldummy-1.1-4trlXTcXq7IC689Dicy7k9" and the abi hash "55e428a03112bb75fee58c7d9e1139aa", what is the relation between the string "4trlXTcXq7IC689Dicy7k9" and the hash "55e428a03112bb75fee58c7d9e1139aa"? Are they two notations for the same number?
16:03:35 <ydl> jle`: ok, but split is indeed meant to be a pure function, right?
16:03:41 <jle`> yes
16:03:43 <dcoutts> monochrom: you're talking current release Cabal right?
16:03:50 <monochrom> yes
16:04:44 <monochrom> oh interesting, cabal 1.22 didn't do that
16:04:46 <dcoutts> monochrom: ok, there's almost no relation at all. The ABI hash is computed by ghc from the .hi files by hashing the interface of all the exported things.
16:05:00 <monochrom> err, cabal 1.22 did something else
16:06:23 <monochrom> And how was the string "4trlXTcXq7IC689Dicy7k9" computed?
16:06:26 <dcoutts> monochrom: the hash in the package id is a hash of the names and versions of the package and all its deps (only names and versions, not content etc)
16:06:37 <monochrom> I see
16:06:52 <jle`> ydl: so it's sort of like calculating the mean and standard deviation in separate functions, when you actually get the mean for free anyway while computing a standard deviation
16:07:56 * monochrom squints. That will be more brittle than the previous scheme.
16:08:43 <dcoutts> monochrom: tbh, I'd have to double check to be totally sure, this stuff has changed every Cabal release and ghc version in recent times.
16:09:04 <monochrom> especially since GHC 8.0.1 does not do shadowing like 7.* did
16:09:40 <dcoutts> monochrom: note that the nix style new-build is somewhat different again
16:10:01 <dcoutts> monochrom: it's actually quite hard to keep straight what all the different notions of package id are
16:10:12 <monochrom> haha that's scary
16:10:24 <dcoutts> the new story is coherent though
16:10:29 <monochrom> "cabal 1.26. This changes everything, again"
16:11:02 <dcoutts> monochrom: it's more like backpack changed everything a couple times during its development, and you see that in ghc 7.10 and 8 and 8.2
16:11:10 <ydl> jle`: yep, makes sense. wasn't sure if split was so cheap one might as well use it.
16:11:12 <monochrom> Oh, I don't worry about that. I feel that every snapshot of time is coherent...
16:12:32 <ydl> when using applicative syntax with monads like ST or IO, is there some guarantee on order of operations? i mean if i have (pure f <$> action1 <*> action2) will action2 always get executed after action1?
16:12:33 <dcoutts> monochrom: so the new-build uses proper nix style hashes for the "unit id" which is the id field in the ghc-pkg db. But for the library name (file name, ELF SO name, linker name prefix) we use the hash of names + versions, since this should be unique within a set of packages linked into one thing
16:13:02 <dcoutts> and we don't want the linker name changing with package content changes
16:13:03 <jle`> ydl: not necessarily
16:13:14 <jle`> well, it depends on what you mean by "monads like ST or IO"
16:13:19 <jle`> what other monads are included in that list?
16:13:34 <EvanR> ReaderT IO !
16:13:38 <jle`> for instances of Applicative that are also instances of Monad in general, the answer is no
16:13:56 <dcoutts> monochrom: but due to backpack, a simple name + version is not unique within a linked program
16:13:59 <jle`> for IO and ST in particular, and their actual monad instances as they are written in their libraries, the answer is yes
16:14:07 <ydl> other monads where action2 can depend non-trivially on action1. like the state monad.
16:14:38 <jle`> what do you mean by "action2 can depend non-trivially on action1" ?
16:14:51 <jle`> when you're using <$>/<*>, the actions aren't allowed to depend on the results of the other actions
16:15:02 <jle`> the structure of your actions are fixed
16:15:07 <allenj12> what do you do when stack fails to install a package? http://pastebin.com/2xLgZZGc , anyone with cuda experience here?
16:15:24 <dcoutts> monochrom: so to fully understand this you need to grok: (source) package id, component id, unit id, and how these relate between packages and components within packages (since ghc cares about libs & exes, not packages as such)
16:15:24 <jle`> you can't decide to putStrLn "hello" or putStrLn "hi" depending on the result or structure of action1
16:15:52 <dcoutts> monochrom: and there's no such thing as "package key" anymore
16:15:54 <jle`> so for <$>/<*>, action1 and action2 aren't allowed to depend on each other or the results of each other
16:17:51 <jle`> ydl: i really think the only meaningful answer you can get comes from the implementation of the monad instance for your specific type
16:18:02 <ydl> jle`: suppose that i am computing in the state monad. action1 modifies the state, and action2 accesses that part of the state. pure f <$> action1 <*> action2 depends on the order of action1 vs action2
16:18:12 <sm> allenj12: in a case like this, you would probably check the bug tracker/file a bug
16:18:32 <jle`> ydl: ah, 'action2' doesn't depend on the results of action1, but its results might depend on the effects of action1
16:18:37 <sm> allenj12: (for the cuda package)
16:18:54 <jle`> 'action2', the actual 'State s a' value, can't depend on action1
16:19:05 <ydl> sorry for the typo btw, i should be writing f <$> action1 <*> action2 btw.
16:20:02 <geppettodivacin> jle`: In that sense,no monad can really "depend" on another monad. Simply the results of the monad computation may depend on the effects of other monads.
16:20:18 <geppettodivacin> But the monad itself is fixed.
16:20:25 <jle`> geppettodivacin: actually, monadic actions can depend on the results of a previos action, if you use >>=
16:20:39 <jle`> you can chose to sequence a different 'State s a' value after another if you use >>=/bind
16:20:51 <jle`> foo >>= \x -> (choose action1 or action2 based onx)
16:21:02 <jle`> but, this is not possible if you're using <$>/<*>
16:21:11 <jle`> it's only possible with monad combinators
16:21:13 <ydl> jle`: but the outcome of the computation can. the point is that i might run "runState (f <$> action1 <*> action2) s". this depends on the order of evaluation of action1 and action2. of course the choice of what particular action i take is fixed, but not their outcomes
16:21:26 <jle`> yeah, that is the point i was making
16:21:39 <jle`> you're talking about the outcomes of the actions depending on each other, not the actions themselves
16:21:59 <jle`> i'm still not sure you can make a general statement about this
16:22:47 <dcoutts> monochrom: ooi, why were you wondering about this?
16:23:13 <allenj12> sm: so the accelerate-cuda on github, seems to be nothing there, guess ill file an issue
16:23:36 <jle`> ydl: for example there's the `Tardis sb sf` Monad, which satisfies your criteria
16:23:48 <jle`> ydl: but its effects run both backwards and forwards
16:24:35 <jle`> so that's an example of a monad instance that satisfies your criteria, but does not reqire that f <$> a1 <*> a2 sequences the events of a1 before the events of a2 
16:24:53 <jle`> s/events/effects
16:25:07 <jle`> the effects of a2 might happen "before" the effects of a1 in the case of Tardis sb sf
16:25:22 <jle`> but the results of a2 can depend on the effects of a1
16:27:56 <jle`> so, i don't think you can make any general conclusions
16:28:04 <jle`> you have to ask this on an instance-by-instance basis
16:28:20 <ydl> jle`: ok. can i guarantee that it is stable for each instance?
16:28:40 <jle`> what do you mean by stable?
16:29:19 <sm> allenj12: https://github.com/tmcdonell/cuda/issues
16:29:37 <EvanR> i think the notion of effects "happening in an order" deserves some precise formalization
16:30:37 <EvanR> because i am plagued by the informal notion conjuring pictures of location-of-parentheses vs order-of-evaluation
16:31:11 <EvanR> neither of which seems to be able to really explain effects
16:32:06 <jle`> there was a definition proposed by ydl where a1 happening before a2 meant that the results of a2 can depend on the "effects" of a1, which sort of makes sense if you have an interpretation of 'effects' for your given Monad instance
16:33:39 <EvanR> see, how does dependency result in ordering
16:33:52 <ydl> jle`: as in do i have to worry about the /compiler/ assuming that the order does not matter and doing some rearrangement. so even if the instance says f <$> a1 <*> a2 executes in the correct order, maybe the compiler decides "flip f <$> a2 <*> a1 ~ f <$> a1 <*> a2" and does that transformation
16:34:12 <ydl> can i be certain that won't happen?
16:34:19 <jle`> oh, i'm pretty sure ghc does no such transformation
16:34:28 <EvanR> you could define ordering as dependency, but then itd be less confusing to just talk about dependency
16:34:33 <jle`> indeed
16:35:53 <jle`> one point i was sort of trying to make was that you need to create a contrived definition of ordering to get the answers you want, making your answer less generalizable and more of a tautology if you found one
16:37:11 <jle`> ydl: i don't think that transformation is allowed within Applicative laws...and also i'm pretty sure it breaks for 90% of applicative instances
16:37:13 <EvanR> i wonder if flip f <$> a2 <*> a1 ~ f <$> a1 <*> a2 makes sense for some Applicative
16:37:37 <jle`> it does, for the class of Applicative's i've heard called "commutative"
16:37:50 <EvanR> ah
16:37:53 <jle`> ie, Identity, Maybe, Reader r
16:38:06 <EvanR> makes sense
16:38:10 <jle`> um those are the ones i can think of off of the top of my head
16:38:58 <jle`> Proxy is another :)
16:39:41 <dibblego> @djinn (t -> a -> b) -> (t -> a) -> (t -> b)
16:39:42 <lambdabot> f a b c = a c (b c)
16:40:44 <jle`> http://stackoverflow.com/questions/6089997/how-do-i-find-out-whether-a-monad-is-commutative
16:41:16 <monochrom> dcoutts: I'm revising my sicp.xhtml article and I need to be accurate
16:41:21 <jle`> the answer is not particularly helpful in this context though heh
16:41:43 <dcoutts> monochrom: oh cool. If you want ezyang and me to review for accuracy, let us know.
16:43:27 <neonfuz> How do I define a type that is an array of another type?
16:43:40 <neonfuz> like String
16:43:57 <neonfuz> I would expect it to be like this, but I get a syntax error:
16:44:02 <neonfuz> data String = [Char]
16:44:07 <jle`> do you mean a list?
16:44:11 <EvanR> @src String
16:44:11 <lambdabot> type String = [Char]
16:44:11 <jle`> data types need constructors :O
16:44:11 <neonfuz> sorry yes
16:44:18 <EvanR> use type for type synonyms
16:44:20 <jle`> data ListOfChar = LoC [Char]
16:44:22 <neonfuz> okay
16:44:31 <jle`> but yeah, if you just want a type synonym, use 'type'
16:44:39 <neonfuz> sorry I learned haskell from LYAH and they didn't really go over type (at least yet)
16:44:41 <jle`> do you know about 'data'/algebraic data type syntax?
16:44:56 <neonfuz> ...maybe?
16:45:08 <jle`> the general structore is data MyType = Constructor1 (things inside here) | Constructor2 (things inside here) | ...
16:45:30 <jle`> (for unparameterized types)
16:45:50 <jle`> ie, data MaybeAnInt = NoInt | ThereIsAnIntSurprise Int
16:46:26 <neonfuz> okay, is it possible to define the constructors outside and then reference them?
16:46:32 <jle`> data CouldBeAnIntOrStringOrBoth = Neither | JustAString String | JustAnInt Int | BothStringAndInt String Int
16:46:49 <jle`> neonfuz: nah, constructors are sort of a part of the description of the type itself
16:46:55 <neonfuz> k,
16:47:12 <neonfuz> so... 'type' is only used to make type aliases?
16:47:23 <jle`> yeah, like typedef in C
16:47:31 <neonfuz> okay,
16:47:45 <jle`> it's basically a lexical alias ... imagine the compiler just doing a find-and-replace lexically before it compiles things
16:47:46 <neonfuz> alright this makes sense now
16:47:57 <neonfuz> yea
16:49:25 <neonfuz> jle`: is this syntax alright?: http://lpaste.net/274016
16:49:48 <jle`> neonfuz: it's correct, but it's a little confusing
16:50:22 <neonfuz> okay, how would you do it?
16:50:23 <jle`> data Expr = ListExpr List | ConstExpr Const   -- a little less confusing
16:50:29 <neonfuz> okay
16:50:36 <jle`> or a common idiom is data Expr = ExList List | ExConst Const
16:50:45 <neonfuz> alright, I like that
16:59:09 <neonfuz> so just doing a 'type' declaration doesn't make any constructors, right?
16:59:43 <lordcirth> neonfuz, afaik, 'type' just makes a new name for an existing type, like an alias 
17:02:04 <neonfuz> okay
17:07:04 <neonfuz> Also the only way to tell if a type is a given "subtype" is by attempting to pattern match against it?
17:07:07 <neonfuz> like
17:07:19 <neonfuz> data Foobar = Foo | Bar
17:07:29 <neonfuz> then I'd have to pattern match against Foo and Bar to see if it is one of those?
17:07:51 <Koterpillar> ultimately yes, but you can write functions for that
17:07:56 <lordcirth> That is a good way.  There are probably others, but I am very new to Haskell
17:08:11 <neonfuz> Koterpillar: yeah, thats what I've been doing 
17:08:19 <neonfuz> so like "isFoo", "isBar", etc
17:09:17 <acowley> Anyone know how to write a type signature for a pattern synonym in GHC 7.10?
17:10:07 <acowley> e.g. "pattern Foo :: C a => a" works in 8.01, but not earlier
17:12:21 <monochrom> neonfuz, Foo is a value (not subtype) of type Foobar.
17:13:21 <acowley> Hah, I had to #ifdef out the pattern synonym type signatures in hpp.
17:13:30 <acowley> Seems fitting.
17:13:59 <monochrom> And it matters because you cannot have Foo in a type expression, just like you will not imagine having Foobar in a value expression
17:16:33 <geekosaur> acowley, https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/syntax-extns.html#idp46686523311744 I think it has to have an arrow?
17:17:39 <acowley> geekosaur: So like "pattern Foo :: C a => () => a"?
17:18:23 <acowley> It seems to have been "fixed" so I'm not sure I'm going to add the 7.10 compatible type sig :/
17:18:30 <geekosaur> I meant a normal arrow; all the examples in the 7.10 manual are pattern Foo :: [[req =>] prov =>] constr -> resulttype
17:19:04 <acowley> Oh, that doesn't sound right
17:19:08 <geekosaur> I don't know what you do if it doesn;t include parms
17:19:13 <acowley> The pattern synonym works just fine
17:19:21 <geekosaur> but tat may be why 8 changed
17:19:29 <geekosaur> you should be able to ask ghci the type with :info
17:19:30 <acowley> It's just the type signature that 7.10.3 doesn't like
17:19:46 <geekosaur> (using 7.10.3 so you get its form instead of 8's)
17:25:11 <acowley> Okay, compiling stuff for the build environment. I only noticed the issue on CI, so I couldn't test locally.
17:26:20 <neonfuz> monochrom: alright, that makes sense
17:30:28 <acowley> Oy, wanting a non-empty list on 7.10.3 means you pull in text
17:30:34 <acowley> What a mess
17:31:25 <acowley> I guess I should vendor that module from semigroups and conditionally include it based on ghc version in the .cabal file
17:31:45 <acowley> But it's papering over ugly with more ugly
17:33:01 <acowley> Well I was almost right with how to fix the pattern synonym type signature
17:33:06 <acowley> It needs to be "() => C a => a"
17:33:20 <acowley> Aesthetic as all get out
17:34:59 <acowley> Thanks for the nudge to actually fix it geekosaur
17:37:18 <acowley> The travis builds are so consistent wrt GHC speed: 7.10.3 => 1:39; 8.0.1 => 1:55; HEAD => 2:31
17:37:33 <acowley> Going in the wrong direction and picking up speed!
17:41:22 <jle`> yeah, i have to cpp my libraries to get pattern synonym type signatures to work
17:41:59 <jle`> it's slightly frustrating but the new system actually is a little more intuitive for me, so i guess i'm glad we took the plunge heh
17:42:36 <lpaste> xuxu pasted “lambdabot installation failure” at http://lpaste.net/274300
17:44:13 <arrrr> ello, anyone know where i can get the pdf for hutton's 2nd edition ?
17:44:43 <xuxu> "no suitable image found"
17:45:17 <monochrom> I think no one knows.
17:45:38 <xuxu> i probably do, but i don't know if it's appropriate to share
17:45:42 <arrrr> dang, i really want to check some of the examples that are only in the 2nd edition
17:46:18 <arrrr> i already own the first ed, dont be misled by my nick
17:58:11 <dmwit> acowley: base-compat?
17:58:20 <dmwit> ?hackage base-compat
17:58:20 <lambdabot> http://hackage.haskell.org/package/base-compat
17:58:37 <monochrom> base-compat is unlikely to help syntax changes
17:59:27 <acowley> I don't think it has NonEmpty 
18:02:25 <monochrom> oh! that one.
18:06:30 <xuxu>  trying "brew cask install haskell-platform", maybe that will fix the problem
18:07:39 <dmwit> acowley: Perhaps you should file a feature request, or fork it.
18:08:02 <dmwit> acowley: It would be less of a hack than doing it one-off just for your project, at least.
18:08:07 <xuxu> nope :| i shouldn't have upgraded to el captain. it's broken quite a bit of my workflow
18:09:09 <dmwit> oh
18:09:11 <acowley> dmwit: I don't think it's worth it.
18:09:27 <dmwit> acowley: Never mind, they explicitly say "we purposefully do not backport data types or type classes introduced in newer versions of base"
18:09:28 <acowley> dmwit: In a year nobody will support 7.10
18:10:38 <acowley> I use the type in as basic a way as possible, too. If it's actually a problem just inlining the data type definition would work.
18:18:08 <xuxu> that didn't work. i might create an issue for lambdabot
18:21:27 <benzrf> heyalex[hey
18:21:30 <benzrf> fuck
18:21:31 <benzrf> hey
18:21:47 <Welkin> benzrf: habari
18:22:13 <benzrf> i have a graph and i want to build a total ordering on the nodes
18:22:49 <benzrf> i'm going to traverse the graph, and each time i cross an edge i can record whether the next node is greater than or less than the current node, and furthermore i may know that it's the successor or predecessor of the current node
18:23:00 <benzrf> what's the best way to get a sorted list of nodes out of this?
18:31:19 <benzrf> ...anybody know??
18:31:57 <amalloy> benzrf: can you just look up a good toposort algorithm and implement it?
18:32:32 <benzrf> aha, that's the kind of thing i'm looking for :)
18:33:09 <benzrf> is there something that takes into account if i know that a is the successor of b, and not just greater?
18:34:18 <amalloy> i don't think that's a thing that really makes sense for partial orderings, which is what toposort is about
18:35:16 <benzrf> well... i actually have a total ordering, it's just that my input only lets me see a subset of it
18:35:18 <benzrf> until i construct the rest
18:35:31 <benzrf> but i can see that some things are successors
18:36:29 <amalloy> my wild guess is that you probably won't be able to gain much efficiency by taking advantace of that knowledge, compared to just doing a general thing like (sort . toList)
18:36:44 <benzrf> well, there may not be a unique result if i don't take that info into account
18:38:44 <jle`> it'd be nice if there was a compiler flag that turned incomplete pattern matches into errors
18:38:52 <benzrf> jle`: there isn't?
18:38:56 <benzrf> i couldve sworn there was
18:39:06 <jle`> there's that flag that turns all warnings into errors i think
18:39:20 <jle`> there might actually be one but i am not aware of it :O
18:40:37 <ianclark> If I have a record wrapped in the IO monad (think function :: IO MyRecord) , I should be able, in a do block, to pass it to a function that only accepts a `MyRecord` (function :: MyRecord -> Maybe RecordField), correct?
18:41:02 <Koterpillar> ianclark: you have an action to get that record, but yes
18:41:14 <Koterpillar> :t fmap
18:41:15 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:42:02 <ianclark> hmm
18:42:16 <Koterpillar> ianclark: i.e. fmap function thatAction
18:42:35 <Koterpillar> ianclark: or: do { record <- thatAction; return $ function record }
18:43:46 <ianclark> Koterpillar: Crazy it worked. Guess I don't actually understand functors
18:43:54 <ianclark> A never ending spiral :)
18:43:57 <lordcirth> jle`,  -fwarn-incomplete-patterns
18:44:43 <ianclark> Ahh, so because [MyRecord], is a functor, it can be fmap'd over. I'm not 100% sure why that operates within the IO monad, though. Koterpillar: any point in the right direction?
18:44:52 <Koterpillar> IO is also a functor
18:45:05 <ianclark> Neat
18:45:07 <amalloy> lancetw: you're not fmapping over your record, but over the IO action containing your functor
18:45:10 <Koterpillar> so fmap is (a -> b) -> IO a -> IO b
18:45:14 <amalloy> er, containing your record
18:45:21 <jle`> lordcirth: i ge the warnings, becuase i already -Wall, but i'd like them to be errors
18:45:22 <ianclark> Ah that makes a lot more sense
18:45:27 <lordcirth> Oh I see
18:45:51 <ianclark> Thanks a lot!
18:45:51 <Koterpillar> ianclark: in the second example with do, you're using bind + return which end up being the same thing
18:46:47 <ianclark> Koterpillar: Would `thatAction` represent a pure function that accesses a field in the record?
18:46:57 <Koterpillar> thatAction :: IO MyRecord
18:47:03 <Koterpillar> you didn't give it a name
18:47:19 <lordcirth> jle`, and you don't want to do -Werror ?
18:50:27 <drninjabatman> hello, Is there a way to have a pattern synonym match multiple patterns? Something like `pattern X a = C1 a | C2 a` ?
18:51:35 <glguy> drninjabatman: Yes, using ViewPatterns
18:52:05 <glguy> Note that this won't be useful for constructing values with the pattern, it will be view only
18:52:40 <drninjabatman> glguy: is there no way to make it bidirectional? 
18:53:09 <glguy> drninjabatman: It wouldn't be sensible for it to be bidirectional if it could match one of two constructors
18:54:03 <benzrf> hold on -
18:54:09 <benzrf> drninjabatman: what do you mean by bidirectional, here?
18:55:35 <drninjabatman> So I have a GADT for symbolic numeric expression like `data Expr where :+: :: Expr -> Expr -> Expr; :*: :: Expr -> Expr -> Expr; Sqrt :: Expr -> Expr`
18:56:02 <drninjabatman> There are quite a few unary and binary operators
18:56:12 <drninjabatman> (also symbols but those are not a problem)
18:56:30 <drninjabatman> I am trying to make it easy to build rewrite rules
18:56:53 <drninjabatman> so for example I want a pattern to capture all binary operators
18:57:27 <Javadavinci> Hey
18:57:37 <lambdabot> Hello.
18:57:50 <drninjabatman> I thought PatternSynonyms would support something like that but it looks like they don't
18:58:07 <Javadavinci> Heard this was a good channel for devs
18:58:14 <drninjabatman> I also though about using Generics but I feel like I am forcing them
18:58:30 <benzrf> drninjabatman: oh, i see what you mean - you want to capture which constructor was used?
18:58:52 <benzrf> PLT redex may be exactly what you want! but it's in racket, not haskell
18:59:22 <drninjabatman> :P 
19:00:04 <drninjabatman> racket is a sea of awesome stuff that I never took the time to look into
19:02:58 <nshepperd> could you replace those constructors by 'BinOpExpr :: BinOp -> Expr -> Expr -> Expr
19:03:33 <nshepperd> then rewrite :+: and so on as convenience functions / pattern synonyms rather than constructors
19:05:37 <drninjabatman> nshepperd: I thought of that but ideally I would like to be able to do `pattern BinOp e1 e2 = ...` and `pattern CommutativeOp e1 e2 = ...`. If I fail I will probably go with that
19:07:44 <benzrf> drninjabatman: plt redex is exactly what you're looking for, seriously
19:08:38 <benzrf> http://i.imgur.com/rS9GTv6.png
19:10:22 <benzrf> it has its own triple evil magic pattern matching construct that interfaces with grammar definitions or something
19:10:43 <drninjabatman> hmm, move everything to rackt you say.. The project is in a quite premature statge
19:10:46 <benzrf> well, not "grammar" - sexp structure laws
19:10:51 <benzrf> well, you dont have to :)
19:11:02 <benzrf> it just seems like designed for precisely this
19:11:16 <benzrf> wow i mangled that sentence
19:12:17 <drninjabatman> I was just looking into it as well, it is indeed exactly what I am looking for. Maybe I can do everything in haskell and find a way delegate rewrites to racket
19:12:49 <benzrf> uhh... that sounds like it'd be more trouble than just writing it in haskell, honestly ;p
19:12:55 <lpaste> nshepperd pasted “BinOp” at http://lpaste.net/274768
19:13:21 <nshepperd> ^^
19:13:34 <nshepperd> BOP pattern there is a bit pointless, but
19:13:50 <benzrf> drninjabatman: you may be able to just do something with template haskell, if you really want to
19:14:24 <benzrf> i'm pretty sure you can splice a quasiquoter in pattern position!
19:14:35 <drninjabatman> nshepperd s solution is much more appealing than template haskell :P
19:14:42 <benzrf> drninjabatman: as for CommutativeOp - how about this:
19:15:45 <benzrf> pattern CommutativeOp o e1 e2 = BinOpExpr ((\binop -> (binop, isCommutative binop)) -> (o, True)) e1 e2
19:15:52 <benzrf> (although that's ugly as hell)
19:16:31 <benzrf> oh wait -
19:16:37 <nshepperd> :o is that a think patternsynonyms can do?
19:16:50 <benzrf> pattern CommutativeOp o e1 e2 = BinOpExpr o@(isCommutative -> (o, True)) e1 e2
19:16:56 <benzrf> fuck
19:17:02 <benzrf> pattern CommutativeOp o e1 e2 = BinOpExpr o@(isCommutative -> True) e1 e2
19:17:10 <benzrf> ...actually that should be a <- and not an =
19:17:17 <benzrf> so it won't be bidirectional
19:17:27 <benzrf> but it lets you bind which operator it is
19:17:29 <drninjabatman> benzrf: Anyway I got your point
19:17:36 <benzrf> ok :)
19:17:38 <drninjabatman> that should work
19:18:04 <drninjabatman> thanks benzrf and nshepperd
19:18:13 <drninjabatman> you have been very helpful
19:19:22 <benzrf> no problem
19:21:15 <jle`> lordcirth: no, that'd make all warnings errors :O
19:21:38 <jle`> i just want only incomplete pattern matches to be errors
19:21:46 <jle`> and i also like seeing other warnings
19:21:49 <jle`> as warnings
19:25:48 <geekosaur> jle`, at the moment you can't. I think there's some planning in the direction of greater control over errors/warnings
19:46:32 <ydl> is there a way to program generically over a stack of multiple StateT's at one time? for one StateT at a time we can write functions "f :: MonadState s m => ...", but what if i have states s and s'? i would like something like "f :: (MonadState s m, MonadState s' m) => ..." but this (understandably) fails to compile
19:48:01 <Koterpillar> ydl: use something like extensible-effects?
19:48:53 <benzrf> has somebody come up with some trick to use constraints as row types
19:51:42 <samba1_> how can I tell hlint to ignore a Reduce duplication suggestion for a specific pair of functions for which it sees duplication. Adding ignore annotations for either or both didn't do it, only adding it for the whole module worked which I'd rather avoid
19:52:00 <Cale> ydl: Usually you just combine all your states.
19:52:37 <Cale> ydl: It's typically worthwhile to specify what your operations are in a more application-specific way than relying on MonadState
19:53:02 <Cale> (and usually you have something better in mind than get and put)
19:53:49 <Cale> So, typically you just make a new type class for those operations, or something of that sort.
19:54:03 <Cale> You can also do things like
19:54:54 <Cale> data StateOps s m = SO { read :: m s, write :: s -> m () }
19:55:17 <Cale> and then explicitly pass arguments like  StateOps s m -> StateOps s' m -> m ...
19:56:04 <Cale> foo s1 s2 = do v <- read s1; write s2 (bar v)
19:57:18 <ydl> i see. thanks!
20:00:11 <ybit_> wadler speaking tomorrow on definitional interpreters: https://twitter.com/pwlremote/status/788160437963587588
20:00:15 <ybit_> live stream linked
20:04:46 <Axman6> Hey all, does anyone if there exists something of the following type? (MonadError E1 m, MonadError E2 n) => (E1 -> E2) -> m a -> n a
20:06:07 <Axman6> for concrete m (such as EitherT) it seems trivial, but there doesn't seem to be any general way to do it
20:06:08 <geekosaur> I don't think that can be done for arbitrary MonadError
20:06:37 <geekosaur> that is, there *can't* be a general way to do it
20:06:50 <Axman6> yeah I guess that makes sense, since e could be very specific to that m, not a type parameter like in eitherT
20:07:42 <Axman6> hmm, not I'm not sure how to proceed. 
20:08:33 <Axman6> I don't really want to have one massive error type for all the functions in this library, some of those errors are specific to certain things which are fairly self contained
20:08:50 <Axman6> I think I'll just have to do that for now :(
20:10:09 <Koterpillar> Axman6: that signature allows converting IO to Either
20:16:37 <jle`> Axman6: alternatively, you can use a polymorphic error type
20:22:23 <samba1_> how can I tell hlint to ignore a Reduce duplication suggestion for a specific pair of functions for which it sees duplication. Adding ignore annotations for either or both didn't do it, only adding it for the whole module worked which I'd rather avoid
20:37:39 <koz_> :t comparing
20:37:41 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
20:44:06 <jle`> is there a color output for ghc's errors lol
20:44:21 <grantwu> atom colors them
20:44:34 <jle`> oh nice
20:44:43 <grantwu> I'm not sure how exactly it goes about doing that
20:45:31 <lpaste> koz_ pasted “How can I avoid this repetition?” at http://lpaste.net/275260
20:46:21 <glguy> koz_: Move the `return x' out of the if expression
20:46:36 <geekosaur> return is not a control structure
20:47:02 <geekosaur> :t when
20:47:04 <lambdabot> Applicative f => Bool -> f () -> f ()
20:47:13 <koz_> geekosaur: Thanks!
20:47:35 <lpaste> glguy annotated “How can I avoid this repetition?” with “How can I avoid this repetition? (annotation)” at http://lpaste.net/275260#a275269
20:47:52 <lpaste> geekosaur annotated “How can I avoid this repetition?” with “How can I avoid this repetition? (annotation)” at http://lpaste.net/275260#a275270
20:48:17 <geekosaur> heh. stereo...
20:50:37 <koz_> glguy: Also thanks.
21:10:23 <joss> Hi
21:11:06 <lambdabot> Hello.
21:13:17 <joss> Lambdabot
21:13:29 <joss> I need to use gtk library
21:13:36 <joss> package
21:13:54 <joss> but i don't know how to install this package 
21:14:09 <lispy> I doubt lambdabot knows either
21:14:26 * geekosaur was wondering how that would go :p
21:14:31 <lispy> joss: Have you already installed the C libs for gtk?
21:14:58 <lispy> if you're on linux it's probably like gtk-dev or gtk-devel or some variation like that
21:15:08 <geekosaur> install your distribution's gtk development headers/libraries, then use cabal or stack to install gtk2hs-buildtools, then install gtk the same way
21:15:10 <joss> Im on mac
21:15:22 <geekosaur> then you need to get gtk from brew or macports
21:17:05 <joss> ok, ty
21:17:11 <joss> i will do this rn
21:58:10 * hackagebot sparse-linear-algebra 0.2.0.4 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.0.4 (ocramz)
22:07:40 <grantwu> Is there an idiomatic way to undo a constructor?
22:07:47 <Koterpillar> ?
22:07:55 <grantwu> i.e. instead of (\(Foo x) -> x)
22:08:27 <Koterpillar> is it the only one?
22:08:32 <grantwu> No
22:08:39 <grantwu> So yeah, this would be a partial function
22:08:43 <jle`> are you talking about a uniform way of naming functions that take values from constructors?
22:08:47 <Koterpillar> well, you can still call it unFoo
22:08:57 <Koterpillar> data Foo = Foo { unFoo :: Bar }
22:09:26 <grantwu> jle`: I guess
22:09:42 <jle`> there's runState, appEndo, getSum
22:09:43 <grantwu> jle`: ...Hrm, I suppose
22:09:55 <jle`> so the runX/appX/getX idioms are a common naming scheme
22:10:02 <grantwu> Oh, no, not a naming scheme
22:10:08 <jle`> actually appEndo is the only one i know that uses appX, heh
22:11:36 <jle`> can you give more context?
22:12:43 <piyush-kurur> lens question: As I understand it an Iso is an isomorphism
22:13:06 <grantwu> jle`: Uh... not super sure how it would help.  I guess what I want is a getter like unFoo, but without having to define it in the datatype
22:13:24 <piyush-kurur> I came up with this code to take an Iso' a b and a b and get an a out of it. 
22:13:25 <jle`> are you looking for a way to auto-generate one?
22:13:36 <grantwu> jle`: Uh... perhaps?  Are you about to generate lenses
22:13:42 <grantwu> er
22:13:46 <grantwu> s/generate/suggest/
22:14:08 <jle`> you could auto-generate prisms for your constructor/data type, yes
22:14:09 <piyush-kurur> I do not like it because it uses undefined
22:14:29 <grantwu> Eh, not worth the effort to save a bit of typing :P
22:15:13 <jle`> > Left 10 ^?! _Left
22:15:15 <lambdabot>  10
22:15:21 <jle`> > Right 10 ^?! _Left
22:15:23 <lambdabot>  *Exception: (^?!): empty Fold
22:15:41 <piyush-kurur> let tgen isom v = isom $ const $ Just v 
22:15:42 <benzrf> is there a newtype for the monoid given by an applicative
22:15:58 <benzrf> with a fixed monoid argument i mean
22:16:01 <grantwu> Really, the problem is... I have data Foo = Foo1 bar | Foo2 baz.  I have a function which converts has type a -> [Foo].  However for most types of a, it always yields a [Foo1]
22:16:12 <piyush-kurur> the tgen has type t -> f t  when isom is Iso' t v
22:16:16 <grantwu> So I'm calling it in a way in which I know it's yielding a [Foo1], and I need a [bar] from it
22:16:24 <grantwu> Basically, refinement types pls?
22:16:27 <jle`> benzrf: Alt
22:16:27 <piyush-kurur> now I just call tgen with undefined
22:16:45 <jle`> benzrf: er, wait, no that's w/ <> = <|>, sorry
22:17:04 <jle`> grantwu: oh, then the best way to do that is just with list comprehensions
22:17:19 <jle`> [ x | Foo1 x <- listOfFoos ]
22:17:23 <jle`> s/best/most idiomatic
22:17:52 <grantwu> oh... the thing is I'm actually fmapping the getter over a monadic action
22:18:10 <grantwu> (so, a -> State mystate [Foo])
22:18:21 <jle`> why don't you just have your function return [bar] instead
22:18:26 <jle`> easy refinement types :)
22:19:01 <grantwu> heh.  because one branch returns Foo2
22:19:21 <jle`> so how can you be sure that it can only have Foo1's ?
22:20:19 <grantwu> Because I call it in a way that I know it'll go into a branch in which it doesn't
22:21:14 <grantwu> it's... hard to explain without taking more time than I have
22:21:33 <grantwu> (And no, I'm not completely convinced there's not a better way of doing things)
22:21:39 <grantwu> But I don't have time to think of one
22:21:49 <jle`> unsafeFoo1 would just be (^?! _Foo1) with prisms
22:21:51 <jle`> but yeah
22:22:05 <jle`> without more context it's hard to see any other clues on how to improve
22:23:14 <grantwu> Yeah... it's for a class assignment so I can't post too much code
22:31:48 <joss> I've already has gym from homebrew
22:31:57 <joss> i mean gtk
22:32:24 <joss> Whats the next step geekosaur
22:40:43 <Lokathor> i was having the biggest problem with a FFI thing, and I thought i'd have to give up on curses with my project, but it turns out that once again Putty was just screwing with me and it's all fine
22:41:05 <Lokathor> i'm so happy that i almost don't even want to add any more to the code today
22:53:46 <grantwu> Blegh, how do I move the outer map into the first argument of zipWith?                 map Instr (zipWith (Instr . Mov) (map Lval paramSources) paramTemps)
22:53:55 <grantwu> oops
22:54:13 <grantwu> map Instr (zipWith (Mov) (map Lval paramSources) paramTemps)
22:55:06 <grantwu> It seems like Instr. Mov ought to work, but it doesn't
22:56:03 <pavonia> (Instr .) . Mov
22:56:04 <MarcelineVQ> (Instr .) . Mov prob
22:56:06 <MarcelineVQ> oop
22:56:51 <grantwu> I'm... having trouble seeing why it's that
22:57:21 <Lokathor> https://github.com/Lokathor/ireniko/blob/master/src/Ireniko/Util.hs#L48 somehow I thought that this would make a thread that keeps starting another thread if the other thread stopped being responsive
22:57:27 <Lokathor> but it does not
22:57:46 <Lokathor> looking at old code is annoying because you always become aware of how much old you was dumb
23:03:48 <MarcelineVQ> grantwu: if I wrote it right: \x y -> (Instr .) . Mov $ x y === \x y -> Instr . Mov x $ y === \x y -> Instr (Mov x y)
23:06:32 <pavonia> That doesn't work, f $ x y = f (x y)
23:07:48 <MarcelineVQ> Right :X Should have used parens, hopefully the pattern is conveyed at least
23:10:03 <grantwu> I seem to vaguely remember a tool which shows the evaluations online
23:24:03 <srhb> grantwu: The bubble thing?
23:38:20 <grantwu> srhb: Uh... do you have a link?
23:41:12 <MarcelineVQ> grantwu: larger example of a more general use of nesting . http://lpaste.net/155174 more specific example to your use http://lpaste.net/275978
23:45:30 <grantwu> MarcelineVQ: Thanks, I'll bookmark that for later
23:46:04 <MarcelineVQ> that first one is by Hafydd
23:46:20 <MarcelineVQ> Or rather, that's where I got it from, idk the 'source'
