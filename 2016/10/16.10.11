00:07:40 * hackagebot fadno-braids 0.0.5 - Braid representations in Haskell  https://hackage.haskell.org/package/fadno-braids-0.0.5 (spopejoy)
00:07:40 * hackagebot parsec-free 3.1.11.6 - Parsec API encoded as a deeply-embedded DSL, for debugging and analysis  https://hackage.haskell.org/package/parsec-free-3.1.11.6 (JohnWiegley)
00:42:36 * hackagebot large-hashable 0.1.0.3 - Efficiently hash (large) Haskell values  https://hackage.haskell.org/package/large-hashable-0.1.0.3 (StefanWehr)
00:52:20 <the_2nd> has anyone used juicy pixels yet? I'd like to automatically choose the correct type
00:54:20 <bollu> can I thread Writer through CofreeT?
00:54:56 <bollu> the docs say "…with a comonad w threaded through it.."
00:55:00 <bollu> but I want to thread a monad
00:55:02 <bollu> is this not possible?
00:55:10 <sdx23> the_2nd: what do you mean?
00:56:03 <bollu> though there is this: (https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Applicative.html#t:Alternative f, https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html#t:Monad w) => https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Monad.html#t:Monad (https://hackage.haskell.org/package/free-4.12.4/docs/Control-Comonad-Trans-Cofree.html#t:CofreeT f w)
00:56:08 <bollu> god damn it
00:56:13 <bollu> (Alternative f, Monad w) => Monad (CofreeT f w)*
00:56:13 <the_2nd> sdx23, I could e.g. map the file ending to the encoding, like .bmp => use bmp, .jpg => use jpg. But maybe there's a way to actually analyze the image for its type
00:56:20 <the_2nd> since often the endings are incorrect
00:57:05 <merijn> the_2nd: There's probably a library for that somewhere, or (if *nix) you can use the 'file' command to figure that out
00:59:35 <sdx23> the_2nd: so if you use readImage you get a DynamicImage with content depending on what kind of file you read.
01:01:33 <bollu> when I'm writing a cofree interpreter, how do I thread a monadic effect through it?
01:01:41 <bollu> I understand how the pairing works now (somewhat)
01:01:48 <bollu> but I want an effect in between
01:01:51 <bollu> say, IO or Writer
01:01:59 <bollu> how do I "put this in the interpreter"
01:07:59 <the_2nd> sdx23, overlooked that one, thangs
01:08:01 <the_2nd> thanks
01:14:24 <hapo> What's this channel about?
01:14:36 <hapo> Also hello everyone
01:15:00 <Insanity_> Hello hapo
01:15:03 <Insanity_> https://www.haskell.org/
01:16:52 <hapo> Hello
01:17:01 <hapo> How's it going
01:17:37 <bollu> hapo: hey!
01:18:56 <hapo> Hey
01:18:58 <hapo> What's up
01:20:22 <ongy> hapo: have you seen the topic of this channel?
01:23:07 <the_2nd> he's trolling, just throw him out
01:24:42 <merijn> the_2nd: You don't know that, #haskell scores pretty high on the channel list on freenode, so occasionally random people join. No need to indulge people with smalltalk, but no point in being rude and kicking people out unless they're being disruptive
01:38:29 <the_2nd> sdx23, I now managed to get a Vector (PixelBaseComponent PixelRGB8) and would like to convert it to [PixelRGB8]
01:38:43 <the_2nd> no idea how to unwrap the "PixelBaseComponent"
01:40:43 <the_2nd> http://hackage.haskell.org/package/JuicyPixels-3.2.8/docs/Codec-Picture.html#t:Image
01:41:01 <the_2nd> where a is an RGB8 . how can I access the a's?
01:42:37 * hackagebot jsaddle 0.5.1.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.5.1.0 (HamishMackenzie)
01:42:39 * hackagebot jsaddle-dom 0.4.1.0 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.4.1.0 (HamishMackenzie)
01:42:41 * hackagebot ghcjs-dom-jsaddle 0.4.1.0 - DOM library that supports both GHCJS and GHC using jsaddle  https://hackage.haskell.org/package/ghcjs-dom-jsaddle-0.4.1.0 (HamishMackenzie)
01:42:43 * hackagebot ghcjs-dom-jsffi 0.4.1.0 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.4.1.0 (HamishMackenzie)
01:42:45 * hackagebot ghcjs-dom 0.4.1.0 - DOM library that supports both GHCJS and GHC  https://hackage.haskell.org/package/ghcjs-dom-0.4.1.0 (HamishMackenzie)
01:49:35 <sdx23> the_2nd: are you sure you need this conversion? 
01:50:44 <the_2nd> sdx23, found another, currently working on it
01:50:46 <tsahyt> I was thinking about functor instances and noticed that I can define a functor instance for lists that only applies the function to the head of the list. Are there really multiple possible functor instances for lists?
01:51:26 <lyxia> tsahyt: fmap f (x : xs) = [f x] ?
01:51:37 <lyxia> that violates fmap id = id
01:51:39 <tsahyt> lyxia: no, fmap f (x:xs) = (f x) : xs
01:51:46 <lyxia> that one doesn't typecheck
01:51:56 <tsahyt> right
01:51:57 <tsahyt> thanks
01:52:01 <tsahyt> I need caffeine
01:52:23 <tsahyt> so between the functor laws and actually type checking, the list instance is unique then?
01:52:38 <lyxia> It would perhaps be a MonoFunctor
01:53:20 <lyxia> I believe it is unique.
01:54:35 <tsahyt> then I should be able to derive it from the laws without guesswork
01:55:21 <lyxia> Something something theorems for free by Wadler.
01:58:37 <comerijn> tsahyt: Not only the list instance, all functors are unique
01:59:04 <comerijn> tsahyt: And you only need one of the two functor laws in Haskell, as the other follows as a free theorem from whichever law you satisfy
01:59:25 <tsahyt> Yes I'm aware of the free theorem
01:59:40 <tsahyt> I don't know why functors would necessarily be unique though
01:59:57 <tsahyt> For Maybe for example it's quite obvious because there's literally no other way to satisfy the type signature
02:00:06 <tsahyt> no wait
02:00:14 <tsahyt> satisfy it while satisfying the laws too
02:00:21 <tsahyt> otherwise I could just map everything to Nothing of course
02:01:04 <merijn> tsahyt: Without the laws you can have multiple, yes. But law satisfying instances are unique, but tbh I couldn't reproduce the proof at will :p
02:01:36 <merijn> I don't remember whether Monad instances are unique. Applicatives certainly aren't
02:02:01 <tsahyt> merijn: I suppose this is a general result from category theory then?
02:04:13 <the_2nd> sdx23, decodeImage fails for many images for me
02:04:25 <merijn> tsahyt: Well, it only applies to Hask (i.e. the category of haskell types), as I'm pretty sure functors in general are not limited in such a way
02:04:56 <tsahyt> ok. I think I'll have to play around a bit and see how I would get a definition for fmap out of fmap id = fmap for a specific type
02:05:03 <tsahyt> fmap id = id *
02:05:31 <merijn> tsahyt: I can sketch out the logic for you, it consists of two observations
02:06:14 <merijn> 1) "fmap id = id" implies "fmap cannot change the structure of the functor" (i.e., for trees it must return a tree with the exact same structure, a list with the exact same structure, etc.)
02:07:15 <merijn> 2) parametricy of "(a -> b) -> (f a -> f b)" implies that fmap MUST apply the argument function to *every* 'a' contained in 'f a' (else it wouldn't typecheck)
02:08:04 <merijn> Given those two properties the behaviour becomes "keep structure identical and update every 'a' by replacing with a 'b', everything else remains unchanged"
02:08:30 <merijn> Which should, at least intuitively, convince you the behaviour of fmap is pretty unique.
02:08:34 <tsahyt> seems simple enough so far
02:09:13 <merijn> tsahyt: The intuitive proof is pretty straightforward. Formalising it and generalising to 'any f' is the tricky part :p
02:10:21 <tsahyt> merijn: the intuitive proof uses the idea of f "containing" something, e.g. "every 'a' in 'f a'" etc. which I think does not hold for every f
02:10:34 <tsahyt> I can see how it translates one way or another, but the intuition breaks down in edge cases I think
02:10:56 <tsahyt> say Functor ((->) r)
02:10:59 <merijn> tsahyt: Containing doesn't require 'f' to actually have a's :)
02:11:36 <merijn> tsahyt: "r -> a" is isomorphic to "Map r a", though
02:12:31 <merijn> tsahyt: But yes, containing is not a great description, but I'll be damned if I can think of a better one :)
02:13:01 <Mortomes|Work> It's all burritos, man.
02:14:31 <geekosaur> "representing" perhaps
02:17:17 <bollu> if I have a free comonad interpreter
02:17:24 <bollu> how do I thread a monadic effect through it?
02:17:27 <bollu> like, I have a Comonad Interp
02:17:30 <tsahyt> merijn: the idea of containment or wrapping or whatever, which seems more like a value level thing is exactly what I'm trying to do away with here. not because I don't think of it like that, it's a good intuition imo, but purely as an exercise
02:17:37 <bollu> I want IO along with it
02:17:39 <bollu> how do I do this?
02:17:49 <bollu> merijn, geekosaur ^
02:17:54 <tsahyt> so I can treat f as what it is, f :: * -> *, a type level function, and then build from there
02:19:15 <tsahyt> i.e. f maps some type to any other type, and fmap lifts the arrows between those types, which becomes quite apparent with explicit parentheses, fmap :: (a -> b) -> (f a -> f b)
02:19:24 <tsahyt> to some other type, not any.
02:20:02 <tsahyt> and at this point it seems defining fmap with help of equational reasoning seems like the right thing to do
02:22:51 <{AS}> I sometimes really like non-strict semantics 
02:23:36 <{AS}> like I can make (x `div` length as), which only runs if as has some elements
02:23:47 <{AS}> and do not have to worry about checking whether the length is 0
02:23:55 <{AS}> because it would never be evaluated if it was
02:24:05 <merijn> {AS}: :)
02:24:44 <{AS}> It takes purity to a whole new level
02:27:39 <tdammers> I try to avoid relying on non-strict semantics that way
02:28:13 <{AS}> tdammers: the alternative would be to have a complicated if around my division, which would never really be executed anyway
02:28:15 <geekosaur> true, that has some similarity to fromJust
02:28:40 <tdammers> {AS}: judgment call, sure
02:29:10 <{AS}> in my case I could just inline the expression and it would be fine
02:29:16 <tdammers> case items of { [] -> 0; xs -> x `div` length xs } -- reasonable
02:29:26 <tdammers> although I'd prefer a total flavor of `div`
02:29:27 <{AS}> but I kind of like it being bound to a let
02:30:23 <tdammers> I prefer the pattern-matched version because it's harder to accidentally bork
02:30:27 <tdammers> in this example at least
02:31:59 <{AS}> I guess it would be nice to have a "if this expression is ever evaluated in an unsafe context then compile error" thing
02:32:15 <{AS}> a non-strict type system so to speak :)
02:32:28 <{AS}> (of course this is nonesense, but I am unsure what to call it)
02:32:33 <{AS}> nonsense*
02:32:48 <geekosaur> you're depending on a value for safety. get thee to agda :)
02:33:02 <tdammers> Well, if you avoid partial functions, the problem goes away. Mostly.
02:33:09 <tdammers> except that now you need a totality checker
02:33:41 <the_2nd> how can I have nested do notation there? http://lpaste.net/5233643118779170816
02:34:14 <{AS}> so I mean I could have something like a total div
02:34:31 <{AS}> but the problem is that if we do local type checking, we may not satisfy the predicate of non-zeroness
02:35:03 <merijn> the_2nd: Looks like you want EitherT?
02:35:06 <{AS}> we need something that is still static but postpones the predicate checking until places where it is possibly evaluated
02:35:25 <{AS}> Agda's type system is not sufficiently lazy in that manner I think
02:35:32 <the_2nd> merijn, maybe, never used it
02:35:51 <ashishnegi> i have a `data Config = Config { url :: URL }` and `newtype URL = URL String` .. so in function `foo :: Config -> Something` `foo config = ...` how do i get `String` inside `config -> url` easily.. is `case (url config) of (Url u) -> u` is the only option ?
02:35:59 <lyxia> the_2nd: return $ do { d <- dynamic ; ... }
02:36:20 <vektor> Quick question: https://github.com/vektordev/GP/blob/master/src/TypeCheckProblem.hs#L46 - eval is memory-expensive and this op runs out of ram for even 100 list elements - any easy fix to this?
02:36:50 <vektor> (It should fit in memory if evaluated properly - that is not spawn new eval processes while old ones are still running.)
02:37:06 <{AS}> We need some kind of type system with non-strict semantics :)
02:37:14 <{AS}> I am not sure how to express this
02:38:20 <geekosaur> ashishnegi, foo (Config (URL url)) = ...
02:38:28 <geekosaur> at least if it's the only thing in Config
02:38:50 <geekosaur> if it's not, Im not sure if you can pull the same thing with record syntax
02:39:11 <lpaste> lyxia annotated “No title” with “to the_2nd” at http://lpaste.net/5233643118779170816#a253524
02:40:02 <ashishnegi> geekosaur: that would work :) thanks
02:40:11 <geekosaur> ah, you can
02:40:29 <geekosaur> f (Config {url = (URL url)}) = ...
02:40:59 <ashishnegi> this will work if `config` has more fields ?
02:41:06 <geekosaur> that one will, yes
02:41:14 <ashishnegi> nice 
02:41:23 <geekosaur> and if you also need the rest of the config record, you can toss in an as-pattern
02:41:28 <geekosaur> f cf@(Config {url = (URL url)}) = ...
02:42:00 <merijn> I would probably use one of the record name extensions that lets you use a record's field names directly as variables combined with pattern guards
02:42:23 <ashishnegi> i am using `recordwildsyntax` extension.. but did not know how to go one level deeper..  
02:45:37 <the_2nd> lyxia, thanks
02:47:55 <geekosaur> ashishnegi, I think you can specify just the one special case and handle the rest with wildcard: f Config {url = (URL url), ..} = ...
02:48:23 <lyxia> vektor: are the output taking up the space?
02:49:00 <lyxia> vektor: I don't see how this is spawning multiple process simultaneously
02:49:35 <lyxia> vektor: does eval return early while the inner string is being computed concurrently?
02:53:34 <vektor> lyxia: I don't know exactly what's going on there. What I'm seeing is that the function is taking up too much memory (>2G)
02:53:38 <merijn> vektor: I can't tell from the code, but you appear to be generating and combing Strings?
02:53:56 <merijn> vektor: How long are your strings and how many are you keeping in your population?
02:54:03 <vektor> lyxia: I'm assuming it has to do with there being multiple partially evaluated instances of eval open concurrently.. or so
02:54:20 <vektor> merijn: Well, calling that function with a param of 100.
02:54:41 <cocreature> vektor: out of memory or out of stackspace?
02:54:57 <tsahyt> I think I've found a satisfying way to construct fmap being guided by the laws and types without any box analogies
02:55:05 <merijn> vektor: And how big is your population?
02:55:38 <vektor> merijn: Population? This particular piece of code isn't dealing with genomes, if that's what you're thinking.
02:56:09 <vektor> merijn: So it generates 100 strings, all quite short. And while eval uses a bit of mem there, a single call is no problem. Apparently though mapM clogs up memory quickly.
02:56:33 <vektor> cocreature: >2G, so I assume memory? The exception sounded like mem, not like stack
02:56:41 <vektor> Though I don't remember it verbatim
02:56:44 <merijn> vektor: Try profiling memory usage
02:57:04 <tsahyt> it's actually surprisingly easy to do away with box analogies if you allow for the idea of fmap lifting a function rather than "opening box, applying, closing box".
02:57:04 <vektor> cocreature: Actually, it's still here: "<interactive>: out of memory (requested 2097152 bytes)"
02:57:20 <cocreature> vektor: yeah sounds like mem. mapM is one of those candidates that runs out of stack if you try to run with a small stackspace to detect spaceleaks
02:57:29 <vektor> Derp, that's not gigs...
02:57:37 <vektor> That's only 2 megs.
02:57:52 <cocreature> oh right
02:57:54 <cocreature> reading is hard
02:58:15 <cocreature> but for 100 elements I would be surprised if mapM is the problem
02:58:24 <cocreature> you can always try a bigger stacksize just to make sure
02:58:25 <vektor> Idunno. It works for a few.
02:58:28 <Fairy> Lets say I have a type  Test = Number Integer | Name String deriving (Eq, Show, Ord)  can I create a function that only accepts Name Strings of the Test type?
02:58:50 <tsahyt> just to make sure, haskell's Functor is really a covariant endofunctor on Hask? does that description fully qualify the Functor class?
02:59:00 <cocreature> Fairy: no
02:59:25 <merijn> tsahyt: Not sure about covariant, but Functor is definitely an endofunctor on Hask
02:59:34 <Fairy> cocreature thanks <3
03:00:23 <tsahyt> merijn: as far as I understand covariant means that direction of arrows is preserved by the mapping, i.e. a -> b is taken to f a -> f b, rather than f b -> f a
03:00:25 <cocreature> Fairy: sorry for the disappointing answer :/
03:00:28 <tsahyt> I might need to read up on it though
03:00:53 <merijn> tsahyt: I think that's implicitly assumed
03:01:10 <merijn> tsahyt: Since other functors are explicitly called contravariant functor
03:01:24 <tsahyt> merijn: true, covariant is redundant
03:02:11 <vektor> cocreature: So I tried with 10, 20, that's no problem
03:02:39 <vektor> cocreature: It's weird because the result is a relatively short string
03:03:55 <vektor> vektor: 200 chars at worst, 30 on average or so. That shouldn't take anywhere near 2M memory with 100 strings. So short input, short output, enormous interim computation must mean that the interim is not being disposed of before starting the next thing, right?
03:04:49 <lyxia> vektor: you could try ending each item with evaluate . force
03:05:45 <vektor> lyxia: from the deepseq package?
03:05:59 <lyxia> yeah
03:07:46 <vektor> lyxia: Something like "mapM (\(TCI inp) -> force $ eval $ head inp) lstOfInputs"?
03:09:39 <lyxia> I don't know if you actually need to evaluate the whole string, perhaps changing eval to end with return $! str is enough
03:09:52 <lyxia> otherwise return $! force str
03:10:07 <vektor> Yeah, eval is IO String, can't force that. gotta force the string before returning from eval.
03:10:44 <lyxia> indeed
03:16:21 <vektor> lyxia: Excellent, seems like that worked. Thanks everyone :)
03:17:01 <lyxia> yw
03:22:36 <tabaqui> in Yampa, if i have several inputs (console input, sockets, etc) should i build "sort" station or reactimate provide me some functionality?
03:23:00 <tabaqui> *provides
04:15:50 <tsahyt> does haskell have a notion of a monoidal functor?
04:19:22 <opqdonut> tsahyt: hmm so having an isomorphism f (a,b) <-> (f a, f b)?
04:19:43 <opqdonut> tsahyt: so zip/unzip
04:19:59 <lyxia> Applicative has f a -> f b -> f (a, b)
04:20:14 <tsahyt> hmm. I think that could work. as long as it can preserve monoidal properties assuming adequate laws
04:20:52 <opqdonut> http://hackage.haskell.org/package/these-0.6.1.0/docs/Data-Align.html this might be related
04:28:12 <ocramz> hi all
04:29:06 <ocramz> does `stack build --profile` pass -rtsopts to GHC ?
04:29:57 <lyxia> I believe it does.
04:30:35 <ocramz> lyxia : thanks; Trying to fix my first thunk leak, wish me luck
04:30:54 <hpc> tsahyt: "Applicative functors are the programming equivalent of strong lax monoidal functors in category theory" - https://en.wikipedia.org/wiki/Applicative_functor
04:30:54 <lyxia> Have fun.
04:31:49 <f-a> foreign export ccall triple :: Int -> Int <-- I am having trouple trying this (from the wiki)
04:31:56 <f-a>     Illegal foreign declaration: requires unregisterised, llvm...
04:31:58 <tsahyt> hpc: thanks
04:32:01 <f-a> how should I modify it?
04:33:29 <merijn> f-a: You can't foreign export Int
04:33:34 <merijn> f-a: You need to marshal it to CInt
04:33:51 <merijn> f-a: Because C's and GHC's definition of Int might not be identical
04:34:06 <f-a> merijn: thanks
04:34:14 <hpc> you might also want to read https://wiki.haskell.org/Calling_Haskell_from_C
04:34:25 <merijn> f-a: Case in point: I had to fix a bug on OSX where 64bit GHC's Int was 64bit whereas 64bit clang/gcc has a 32bit int
04:34:27 <hpc> which could be more up to date
04:34:35 <tabaqui> once again: in Yampa, if i want to use several inputs (sockets, stdin, etc) should I build "sort station" or just use reactimate in different threads?
04:34:48 <f-a> I ll do that hpc 
04:35:02 <merijn> f-a: I have a minimal example here: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
04:35:02 <PhsShft> can someone explain Foldr to me? or provide a easy-to-understand webpage...
04:35:13 <merijn> f-a: I'd also recommend reading the FFI chapter of the report
04:35:37 <hpc> PhsShft: Foldr as in https://hackage.haskell.org/package/yarr-1.4.0.2/docs/Data-Yarr-Shape.html#t:Foldr ?
04:35:46 <tabaqui> PhsShft: foldr (+) [1,2,3,4] = 1 + (2 + (3 + 4))
04:35:51 <f-a> thanks merijn 
04:36:01 <PhsShft> so it’s just like…map?
04:36:09 <tabaqui> PhsShft: like reduce
04:36:12 <hpc> oh, foldr
04:36:32 <hpc> foldr (*) z list will replace the (:) in list with (*), and the [] with z
04:36:42 <tabaqui> but you have to remember that you cannot reduce streams or infinite lists with foldr
04:36:47 <tabaqui> you should use foldl
04:36:51 <hpc> so, foldr (+) 0 [1,2,3,4]
04:37:00 <hpc> foldr (+) 0 (1 : 2 : 3 : 4 : [])
04:37:00 <PhsShft> :hpc oh that helps
04:37:07 <hpc> 1 + 2 + 3 + 4 + []
04:37:12 <hpc> er, + 0
04:38:09 <hpc> you can use foldr to reduce infinite lists if your choice of (*) is non-strict in its second argument
04:38:45 <hpc> i think foldl can be used to reduce infinite lists as well, but only in extraordinarily contrived circumstances
04:39:00 <hpc> > foldl (\_ _ -> 0) 1 [2..]
04:39:10 <lambdabot>  mueval: ExitFailure 1
04:39:20 <hpc> oh, or it can't
04:39:51 <tabaqui> and foldr has O(n) memory consuming
04:39:59 <hpc> if you're interested, there's a concept of a universal fold on a data type
04:40:00 <tabaqui> while foldl only O(1)
04:40:21 <Squarism> Im gonna do a presentaiton on FP (Haskell and elm) on at work. Anyone got some buzz for tired java devs that FP is coming / companies adopts it / job market demand etc?
04:40:29 <hpc> which is a definition that abstracts the concept of pattern matching for that specific type
04:40:36 <hpc> foldr is the universal fold for []
04:40:37 <PhsShft> o?
04:40:44 <Squarism> ...and is not a curiosity
04:41:32 <hpc> Squarism: jane street is a classic example
04:41:40 <Squarism> jane street?
04:41:41 <hpc> :t maybe
04:41:43 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:41:43 <Squarism> never heard of
04:41:51 <hpc> PhsShft: maybe is another universal fold, for Maybe
04:42:02 <hpc> it has a case for matching Nothing and a case for matching (Just _)
04:42:22 <Squarism> hpc, what about jane street?
04:42:22 <hpc> Squarism: they do high frequency trading with ocaml iirc
04:42:22 <PhsShft> i see...
04:42:42 * hackagebot phoityne-vscode 0.0.10.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.10.0 (phoityne_hs)
04:42:43 <hpc> which is basically haskell
04:42:54 <hpc> (they're both MLs)
04:42:57 <ashishnegi> hi.. i came to know about `--backpack` feature in ghc ; which use case does it solves ?
04:43:16 <Squarism> hpc, so are they some stock rocket or something?
04:43:32 <hpc> PhsShft: it's not important for understanding folds, but still a neat bit of theory in any event ;)
04:44:15 <hpc> Squarism: or something, i try to avoid looking too closely at how the stock market works ;)
05:19:38 <bollu> is there a CofreeT that can take a monad?
05:19:45 <lucyfx> (more of a maths question) how do I find the next number in a set, assuming the set --isn't-- a polynom?
05:19:52 <bollu> I want to thread effects through my cofree comonad
05:20:02 <bollu> lucyfx: what's "polynom"?
05:20:20 <lucyfx> bollu, as in polynomial
05:20:39 <bollu> lucyfx: what do you mean by saying the set isn't polynomial
05:20:40 <bollu> ?
05:20:53 <merijn> hpc: I don't think Jane Street uses ocaml for high frequency trading
05:20:56 <merijn> hpc: Way too slow
05:21:08 <bollu> merijn: any idea about the cofree comonad thing?
05:21:11 <merijn> hpc: You use custom built asics/FPGA built into your network cards for that
05:21:16 <merijn> bollu: I'm not sure you can
05:21:24 <bollu> merijn: ah, damn
05:21:25 <lucyfx> bollu, if a set is polynomial, you can reverse engineer its formula and construct a formula for that. so for polynomials its easy
05:21:26 <bollu> merijn: so in that case
05:21:41 <lucyfx> bollu, but imagine [10,15,20,30,35,40,45,55]
05:21:44 <bollu> merijn: in the cofree interpreter pattern, how do allow your interpreter to have effects?
05:21:48 <lucyfx> bollu, so how do you figure which number will be next
05:21:54 <merijn> bollu: I'm not sure you can?
05:22:02 <bollu> lucyfx: there are an infinite number of solutions to that question..?
05:22:36 <bollu> lucyfx: a n degree polynomial is determined by n points passing through it. so I can create an infinite number of polynomials degree >= n which satisfy your condition
05:22:50 <liste> lucyfx: do you mean an arithmetic progression?
05:22:53 <bollu> merijn: I see, so doesn't that severely limit the cofree interpreter free DSL patten?
05:22:55 <merijn> hpc: Pretty sure like all the Haskell banks they built tooling for analysis of data and validating mathematical models
05:23:32 <lucyfx> liste, yep. I think so.
05:24:27 <merijn> bollu: Define "severely" and "limit" :)
05:24:34 <lyxia> lucyfx: Why would there be a "next number"
05:24:52 <bollu> merijn: :) I mean, I would like to do IO in an interpreter. What's the point of interpretation if you can't leave a mark on the world?
05:24:54 <lyxia> You might want to discuss this on ##math instead.
05:25:32 <merijn> bollu: You build a pure interpreter and do something with the result. What's stopping you from having, say, an IO return value from your interpreter?
05:26:17 <bollu> merijn: but in that case, I can't use the nice monadic machinery I get by lifting mtl-style, do I?
05:27:12 <merijn> bollu: Well, built a more complicated stuck than IO and use that as return value?
05:27:21 <bollu> merijn: hm, right.
05:27:26 <bollu> merijn: I'll try that.
05:35:20 <f-a> I managed to get a C program calling a haskell function compiled using ghc
05:36:08 <f-a> my question is: do I *need* to use ghc to compile my .c program? Say as (example) I want to share my work with my colleagues
05:36:15 <f-a> (who only have gcc)
05:38:51 <ongy> the linking step can be quite annoying without using ghc
05:39:13 <ongy> afaik it's possible, but not really something you want to do
05:39:17 <f-a> I see. Thanks ongy 
05:40:10 <merijn> f-a: GHC *can't* compile your C program
05:40:36 <merijn> On account of not being a C compiler
05:42:17 <ocramz> is there a tool for plotting .prof files?
05:42:26 <merijn> f-a: In the end GHC just builds binaries that can be linked by the system linker. It's usually easier to have GHC do the linking than asking gcc or ld to do it because GHC knows the locations of all the haskell libraries, but there's no reason you can't have gcc or ld link haskell libraries. Although that does require you to understand shared libraries and how linking works
05:42:54 <merijn> ocramz: hp2ps
05:43:01 <f-a> merijn: then I'll s/with/thro- indeed indeed. I won't do it personally I was just curious if that was possible. Thanks
05:43:09 <ocramz> thanks merijn
05:43:28 <merijn> ocramz: Oh wait, are you talking about GHC profiling info or something else?
05:43:55 <ocramz> yes profiling info
05:44:40 <merijn> ocramz: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html#hp2ps-rendering-heap-profiles-to-postscript
05:45:55 <ocramz> merijn: super, thanks
06:01:26 <aphorisme> Hello. This isn't a explicit Haskell related question. But since I'm a Haskell enthusiast I would like to hear opinions from Haskellers point of view: which graph query/modify language would you recommend?
06:01:47 <merijn> aphorisme: None of them, it's all terrible >.<
06:02:31 <merijn> aphorisme: What kinda stuff do you wanna do?
06:03:26 <aphorisme> merijn: I'm building a small embedded graph database and looking for a language to test which features the backend needs to be able to do. 
06:03:34 <aphorisme> merijn: so far I've the same impression.  : /
06:05:49 <merijn> aphorisme: I don't have much experience with Graph query languages like SparQL/GraphQL/whatever, mostly benchmarking distributed graph processing frameworks, and the conclusion there is: all the famous/open sources/marketed things are downright awful
06:06:08 <bollu> merijn: wait what, seriously?
06:06:12 <bollu> merijn: performance wise?
06:06:15 <merijn> bollu: Yes
06:07:06 <merijn> But this might be more something for #haskell-offtopic :p
06:07:24 <aphorisme> Oh.
06:08:05 <zeawee>  /msg NickServ identify asd123qwe
06:09:30 <ggole> Pretty strong password there.
06:12:07 <bollu> ouch
06:28:20 <M2tias> :D
06:39:20 <exio4> @src (^)
06:39:21 <lambdabot> x ^ 0            = 1
06:39:21 <lambdabot> x ^ n | n > 0    = f x (n-1) x
06:39:21 <lambdabot>   where
06:39:21 <lambdabot>     f _ 0 y = y
06:39:21 <lambdabot>     f x n y = g x n
06:39:22 <lambdabot> [3 @more lines]
06:40:08 <ski> @more
06:40:09 <lambdabot>         where g x n | even n    = g (x*x) (n `quot` 2)
06:40:09 <lambdabot>                     | otherwise = f x (n-1) (x*y)
06:40:09 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
06:52:08 <delYsid> shapr: So, after (supposedly) 15 years of learning and using Haskell, what sort of code are you into these days?
06:55:19 <bollu> shapr: wow, you've been using haskell for 15 years?
07:03:34 <delYsid> bollu: At least I remember when he basically defected from #emacs to #haskell roughly 2003 or so.
07:04:11 <bollu> wow
07:04:19 <bollu> "defected" :)
07:04:43 <delYsid> I am not even sure if I got the right english word there, but from your reaction, I guess I did :-)
07:06:14 <delYsid> I wonder how Yi is doing, was always quite fond of the idea, but never actually got to use it enough to get hooked.
07:07:23 <ocramz> Where does one add SCC annotations ? I'm getting a parse error when adding one in a let binding
07:08:52 <geekosaur> to an expression, so if you are annotating a let binding you want it after the =
07:09:27 <geekosaur> unless you are annotating the entire binding ({-# SCC "this" #-} let ... in ...)
07:13:04 <ocramz> geekosaur, I've added one SCC after the = in a let binding, still parse error.
07:13:06 <ocramz> stumped
07:13:22 <geekosaur> @paste
07:13:22 <lambdabot> Haskell pastebin: http://lpaste.net/
07:14:13 <ocramz> geekosaur : http://lpaste.net/3810994949269225472
07:16:30 <geekosaur> hm, that looks like it should work
07:17:25 <delYsid> Is it expected that GHC (7.10) apparently suggests "illegal" type signatures for top-level bindings?  I've seen this now three times.  I get the warning, with a suggested type-sig like "digits :: forall a. Integral a => a -> a -> [a]", but when I just put that in with copy-paste, GHC rejects it, suggesting the RankNTypes extension...  It is a minor anoyance, I can just get rid of the forall... but I wonder why GHC keeps doing that?
07:18:31 <ocramz> geekosaur: and in fact, it does compile. For some reason flycheck gives me an error. False positive. Thanks anyway!
07:19:12 <geekosaur> ah. would guess flycheck uses language-haskell-ext and it doesn't support SCC properly for some reason
07:20:28 <tsahyt> I was wondering, why does Haskell use bind instead of join in its definition of Monad? join seems to be the default way to do it in category theory
07:20:31 <tabaqui> once again: in Yampa, if i want to use several inputs (sockets, stdin, etc) should I build "sort station" or just use reactimate in different threads?
07:20:51 <merijn> tsahyt: Because in most practical cases it's easier to implement bind than it is to implement join :)
07:21:46 <lyxia> It happens to be easier to compose actions with, being a binary operator.
07:21:58 <geekosaur> also, I suspect, because bind matches better with do notation and is expected to be more of a "hot path" as a result
07:22:59 <tsahyt> lyxia: but after defining join I get bind for free
07:23:10 <tsahyt> assuming a functor instance of course
07:24:15 <tsahyt> actually I don't need the functor to define bind in terms of join
07:24:31 <tsahyt> I think I do need it the other way round though
07:24:47 <tsahyt> so maybe that's another possible answer, because Functor wasn't a superclass of Monad back in the day
07:25:23 <merijn> tsahyt: He meant that bind, being the most common one, is the one most likely for programmers to want to optimise
07:25:57 <tsahyt> merijn: then there's still the option of putting both into the typeclass and providing default implementations that can be overwritten when desired
07:26:31 <geekosaur> that is something still being discussed, I believe
07:27:23 <ashishnegi> hi.. who developed the idea behind machines library ? .. `Runar https://twitter.com/runarorama` ??
07:27:29 <merijn> tsahyt: It was discussed to include join into the class during the AMP discussion, I think
07:27:48 <merijn> tsahyt: But no one thought it was crucial enough to push that in too
07:28:10 <merijn> ashishnegi: Hackage claims edwardk is the maintainer
07:28:19 <tsahyt> it's not like it needed to happen within a major change like AMP either
07:28:32 <tsahyt> adding join with a default implementation shouldn't break anything, should it?
07:28:57 <tsahyt> all instances would still be valid as far as I can tell
07:29:01 <merijn> I don't remember what the issue was, tbh
07:29:31 <osa1> I have a package in .cabal's "exposed-packages" field but after a cabal repl I can't import it. any ideas why?
07:29:33 <ashishnegi> yes.. he is the maintainer.. he has added slides by `Runar` ... but i can not find any docs by Runar..  Is there any `official` post about what machines by creator/inventor ?
07:30:06 <geekosaur> vaguely reclaling some edge case in moving from the global one to the typeclass one and backward compat, but not recalling any details :/
07:30:13 <Gurkenglas> What alternative minimal cardinality-1 definitions are there for Monad now that it's a subclass of Alternative?
07:31:13 <tsahyt> ok, Moggi also introduces Monads using join, so the change must have come further down the line
07:31:14 <bollu> merijn: why do we not have the instance Monad m => Applicative m, instance Applicative m => Functor m in base?
07:31:32 <merijn> bollu: That makes no sense
07:31:43 <bollu> merijn: if I know that it's a monad, automatically derive applicative for me
07:31:49 <bollu> merijn: it makes perfect sense..?
07:32:16 <merijn> bollu: That makes it impossible to define custom functor/applicative for any type
07:32:29 <bollu> merijn: in the sense?
07:32:41 <merijn> bollu: Because those instances overlap everything
07:32:48 <shapr> delYsid: looking into dependently typed languages lately, what are you doing?
07:32:49 <bollu> merijn: ahh, right. okay
07:33:22 <bollu> merijn: but, like, it's "doable" albeit stupid, correct?
07:33:46 <tsahyt> Is Wadler's 1995 paper the "origin" of monads in haskell?
07:33:48 <merijn> bollu: Doable in the sense of legal haskell? Sure
07:33:54 <bollu> merijn: cool, thanks
07:33:54 <tsahyt> "Monads for Functional Programming"
07:34:01 <merijn> tsahyt: Yeah
07:34:03 <bollu> merijn: I was wondering why it wasn't done, overlapping instances is a good reason
07:34:24 <tsahyt> well that one already uses bind. I think I'll skim it and see if I can find an explanation
07:35:24 <Gurkenglas> If I got that stuff right about applying homotopic type theory to Haskell, the idea is that some code changes in libraries induce code changes where those libraries are used, such that nothing changes in any program behavior; and this would allow libraries to make structural changes without breaking backwards compatibility? (Like, we could have implemented FAM immediately, and that MonadFail thing, etc.)
07:35:50 <merijn> tsahyt: Wadler got it from Eugene Moggi
07:36:45 <tsahyt> merijn: Moggi introduces monads in the standard way using join. He might switch somewhere during the paper though, I haven't checked that yet.
07:37:06 <delYsid> shapr: Coming back to Haskell every few months, but I've been fascinated by Idris lately as well :-)  However, it is so much over my head that I didn't even write a single piece of code yet.  However, I've been wishing for a Fin-alike thing in Haskell recently, wishing to close some holes of run-time checking for valid values.
07:38:13 <delYsid> So I think I sort of know why Idris is cool, but the proof stuff has been putting me of because I don't understand *a single word* about this stuff.
07:38:19 <shapr> delYsid: Also, Haskell isn't even close to the language it was 15 years ago, amazing new features include Software Transactional Memory, compositional parallelism, and much more
07:38:31 <merijn> delYsid: Fortunately there's a free book!
07:38:33 <merijn> @where sf
07:38:34 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages",
07:38:34 <lambdabot> "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof assistant."
07:38:46 <merijn> delYsid: Everything you never knew about formal proofs of programs !g
07:38:49 <bollu> merijn: sf takes a while. I'm at chapter 5 right now
07:38:55 <bollu> merijn: college takes way too much time 
07:39:53 <delYsid> merijn: Thanks for the pointer!
07:42:41 <delYsid> shapr: Indeed.  While I have been only casually watching from the side-lines, I very positively notice the language is evolving.  I've seen the whining on the list, but I am actually totally for fixing things (like AMP), gives you a commfy feeling regarding the platform.
07:42:48 * hackagebot dynamic-linker-template 0.1.1.0 - Automatically derive dynamic linking methods from a data type.  https://hackage.haskell.org/package/dynamic-linker-template-0.1.1.0 (SylvainHenry)
07:46:08 <tsahyt> on things like AMP I can really only say that I'm not much of a fan of backwards compatibility at all costs. People make mistakes, and it's better to fix them than to carry them around forever.
07:46:25 <delYsid> shapr: I have two toy-projects in Haskell by now.  braille-parsers allows me to parse Unicode Braille based on ekmetts parsers library, and haskore-braille is my little experiment to write a braille music parser in Haskell.  -> github/mlang
07:46:43 <tsahyt> otherwise you end up with something like x86
07:46:53 <delYsid> tsahyt: +1
07:48:47 <delYsid> AMP actually helped me to conceptually connect Applicative and Monad better, prior to that fix, I wasn't even aware that pure and return are the same.
07:49:11 <delYsid> But thats just me, a hobby programmer with almost no math background but a fascination for Haskell.
07:49:48 <delYsid> Best language for writing one-liners EVER!
07:49:58 <tsahyt> delYsid: The monad of no return proposal is still around too. Eventually we'll probably get rid of return altogether
07:50:07 <Tuplanolla> J would like to have a word with you, delYsid.
07:50:26 <fnurglewitz> Tuplanolla: J is hell
07:50:51 <bollu> tsahyt: what's that proposal?
07:50:53 <Tuplanolla> Concise hell.
07:51:36 <tsahyt> bollu: basically just removing return from Monad now that Applicative is a superclass and pure does the very same thing
07:51:39 <tsahyt> bollu: https://ghc.haskell.org/trac/ghc/wiki/Proposal/MonadOfNoReturn
07:51:43 <bollu> ah
07:52:03 <tsahyt> there's also the ongoing effort to get rid of fail
07:54:45 <ashishnegi> can someone suggest some good paper/blog about idea/theory about machines ? or just give me some good words to google.. hackage says it is `transducers`.. is it like `clojure` transducers ? terms are overloaded today :(
07:57:35 <delYsid> Tuplanolla: Speak up.
07:58:08 <shapr> @remember tsahyt there's also the ongoing effort to get rid of fail
07:58:08 <lambdabot> It is forever etched in my memory.
07:58:17 <tsahyt> ashishnegi: about the library?
07:58:17 <shapr> delYsid: I don't have any math background either
07:58:27 <tsahyt> ashishnegi: this is linked on the hackage page, maybe it helps https://dl.dropboxusercontent.com/u/4588997/Machines.pdf
07:58:53 <ashishnegi> tsahyt: yes.. about machines library.. that is really slides with very few explaination..
07:58:54 <Tuplanolla> delYsid: `mean=.+/%#`
07:59:33 <delYsid> Tuplanolla: huh?
07:59:41 <ashishnegi> is there something more `elaborate` in docs about machines library ? edwardk if i may ask you.
07:59:49 <Tuplanolla> It's one of those languages, delYsid.
08:00:17 <delYsid> Tuplanolla: APL?
08:00:20 <tsahyt> ashishnegi: unfortunately I can't find a recording of the corresponding talk. edwardk has this repository up with a few examples https://github.com/alanz/machines-play/blob/master/Main.hs 
08:00:24 <geekosaur> delYsid, J
08:00:28 <tsahyt> oh it's actually not his repository
08:00:35 <geekosaur> although iirc that's not actually valid K
08:00:37 <geekosaur> er J
08:00:43 <tsahyt> it looks like well documented code
08:01:27 <Tuplanolla> It works in my jconsole, geekosaur.
08:01:30 <ashishnegi> tsahyt: i am actually more interested in idea behind machines.. hopefully that code would have that..
08:01:35 <ashishnegi> thanks :)
08:03:01 <delYsid> > harmonicMean = uncurry (/) . foldr (((1 +) ***) . (+) . recip) (0, 0)
08:03:04 <lambdabot>  <hint>:1:14: error:
08:03:04 <lambdabot>      parse error on input ‘=’
08:03:04 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
08:03:28 <geekosaur> no definitions in @run, maybe you wanted @let?
08:03:31 <delYsid> point-free is beautiful and scary at the same time, a little bit like darkside electronic music :-)
08:04:23 * geekosaur was misreading the j the first time, apparently. only been, er, 30 years
08:05:14 <delYsid> or maths, for that matter ...
08:07:13 <bollu> has anyone filled up Google's internship form? Like, they have this huge list of things, and I've used / dabbled with a lot of them, but I'm not experienced. Do I still tick it?
08:07:23 <bollu> candititae information request form^
08:07:31 <ongy> with cereal and binary, is there a significant advantage to either of them? My usecase is an existing protocol, so I have to be bit-presize for bools
08:09:00 <amx> I think nowadays they are almost the same feature-wise
08:09:03 <tsahyt> delYsid: point-free is beautiful as long as you only carry one thing through the pipeline. once you need to thread multiple things through functions it can become very scary indeed
08:09:50 <amx> ongy: I went with cereal because I liked it a bit better
08:14:16 <puregreen> ongy: cereal – strict bytestrings, binary – lazy bytestrings
08:16:06 <puregreen> it doesn't matter in practice I think because cereal can serialize/deserialize lazy bytestrings too, but I remember reading about someone going with cereal over binary because they got tired of converting their bytestrings all the time
08:16:32 <tabaqui> ongy: and runGet from cereal returns Maybe (or Either), and binary returns object or raise an exception
08:16:35 <puregreen> which seems kinda weird now that I think about it, but still, it's what I read
08:17:00 <puregreen> tabaqui: binary does provide “decodeOrFail” though
08:17:23 <tabaqui> ongy: in my case i've pick binary cause other code uses lazy bytestring
08:17:41 <tabaqui> if you have strict, it will be simplier get cereal
08:17:47 <tabaqui> *to get
08:18:23 <tabaqui> puregreen: yes, but cereal does not provide decode without Maybe
08:19:01 <puregreen> well, but getting it is as simple as doing “either error id” so it seems to be a minor flaw
08:19:27 <tabaqui> puregreen: again, in my case there were already mess with Either, so i didn't want to write another "do" block
08:33:09 <glguy> tabaqui: binary and cereal both support the same lazy vs strict bytestring
08:35:29 <kyren> I'm finding that if I use stack build and stack build --profile, I can get into a situation where if I've previously done a stack build --profile, I have to do a stack clean before the performance of the resulting binary is the same again when doing a stack build
08:35:57 <kyren> I've set the rebuild-ghc-options option to true in stack.yaml, but I'm wondering if maybe I'm doing something wrong, or just using the tool incorrectly, or assuming too much
08:36:40 <kyren> sorry if this is the wrong channel for stack questions
08:37:48 <kyren> I find that I'm just constantly unsure if I built with the settings I thought I did, or what state was saved and where
08:38:12 <geekosaur> it's not wrong to ask stack questions here but there aren't always people who know stack around. #haskell-stack also exists but tends to be rather quiet in my experience
08:39:00 <geekosaur> in any case this question sounds better suited to stackoverflow or maybe a mailing list
08:39:19 <kyren> yeah that's fair, thanks anyway though!
08:42:49 * hackagebot phaser 0.1.1.0 - Incremental multiple pass parser library.  https://hackage.haskell.org/package/phaser-0.1.1.0 (quick_dudley)
08:57:48 <tsahyt> Is there a good write-up about computational power of Applicatives and Monads? I understand that bind gives me the option of introducing choice into my computations while Applicative only does sequencing, but is there something comprehensive about this topic?
08:59:25 <geekosaur> @google arrows idioms monads meticulous
08:59:35 <geekosaur> bah
09:00:12 <tsahyt> ahh, I think I have that paper though
09:00:26 <Arguggi> How do I use an offset and a limit AFTER a a restrict using opaleye? If I use the functions on my initial query and then restrict it gives me the first n rows of the table and then filters
09:00:32 <tsahyt> ever since I started using zotero to manage my references I keep accumulating papers and only read very few of them
09:06:08 <knupfer> Why aren't there instances for Bounded (Maybe a) and Enum (Maybe a) ?
09:08:01 <knupfer> Or (,)? It has got a Bounded, but no Enum instance
09:10:52 <mizu_no_oto_work> knupfer: enum isn't very composable - "The calls succ maxBound and pred minBound should result in a runtime error."
09:10:55 <flxw`> /15 y
09:12:06 <tsahyt> since (,) and Either are dual to each other, is there some kinda of dualism going on between a writer monad and an error monad?
09:13:27 <mizu_no_oto_work> knupfer: I'm not sure you can define a very good Enum instance for (,), given that runtime error.
09:13:36 <knupfer> mizu_no_oto_work: I know that enum is partial, but it's everywhere partial
09:13:59 <knupfer> for (a,) , you could run enum 
09:14:15 <knupfer> for (a,b) , you could run (enum a, enum b) 
09:14:29 <knupfer> succ (True,False) == (True,True)
09:15:06 <knupfer> or minBound == Nothing
09:15:11 <knupfer> maxBound == Just True
09:15:15 <knupfer> hm
09:16:06 <knupfer> I'm writing a library which helps writing exhaustion proves, using enum and bounded to exhaust a type, but it seems that I'm better off with generic
09:17:10 <mizu_no_oto_work> minBound = Nothing throws away the 'real' minimum bound of the underlying type, which might be why it wasn't included
09:17:46 <geekosaur> @hackage universe
09:17:47 <lambdabot> http://hackage.haskell.org/package/universe
09:18:02 <geekosaur> ^ possibly more to your liking than Enum/Bounded
09:19:38 <knupfer> geekosaur: Thank you!
09:25:54 <GLM> How would I be able to fix the type error where it expects a String but I'm giving a bytestring-0.10.8.1:Data.ByteString.Lazy.Internal.ByteString?
09:26:07 <GLM> I have the overloaded strings pragma as well
09:27:11 <amx> depending on what's inside the bytestring you can use Data.ByteString.Char8 or you go via Data.Text
09:27:43 <GLM> amx: If it matters, I'm using Wreq to get the responseBody
09:28:13 <GLM> amx: Also, shouldn't the pragma automatically convert it?
09:30:07 <geekosaur> GLM, the pragma only applies to literals
09:30:33 <geekosaur> Haskell *never* autocoerces expressions. literals can be made polymorphic, that's it
09:32:04 <GLM> geekosaur: Do you know how I can put in that specific type instead of String? It complains that it can't find it when I do.
09:34:00 <geekosaur> @paste the code, ideally. if you just want people to guess at what you are doing, probably Data.ByteString.Lazy.Char8.unpack to make a String
09:34:00 <lambdabot> Haskell pastebin: http://lpaste.net/
09:37:43 <GLM> geekosaur: I fixed it by not casting explicitly to a String
09:40:15 <tsahyt> (>>=) == flip concatMap on lists, right?
09:41:44 <puregreen> right
09:42:51 * hackagebot proto-lens 0.1.0.4 - A lens-based implementation of protocol buffers in Haskell.  https://hackage.haskell.org/package/proto-lens-0.1.0.4 (gnezdo)
09:42:53 * hackagebot proto-lens-protoc 0.1.0.4 - Protocol buffer compiler for the proto-lens library.  https://hackage.haskell.org/package/proto-lens-protoc-0.1.0.4 (gnezdo)
09:42:55 * hackagebot proto-lens-combinators 0.1.0.4 - Utilities functions to proto-lens.  https://hackage.haskell.org/package/proto-lens-combinators-0.1.0.4 (gnezdo)
10:06:23 <ashishnegi> hi.. can some help me with this GADTs problem ? http://lpaste.net/254280  i want that `Eq` func should restrict it to same `a`.. how to tell compiler that ?
10:06:31 <yulax> i have a problem
10:07:39 <yulax> https://paste.debian.net/hidden/d873b42f/
10:08:09 <yulax> i can do "True == (3 + 3 + 3 == 3*3)" in ghci to get true
10:08:36 <yulax> the function in solution is supposed to produce true or false
10:09:19 <ashishnegi> yulax: what is the error.. ?
10:09:22 <yulax> and then when it can't get true/false from the function it produces false
10:09:30 <yulax> right, the errer is
10:10:17 <yulax> never mind
10:10:23 <ReinH> yulax: you say f :: Int -> Bool but then give it three arguments
10:10:33 <yulax> yea
10:10:43 <yulax> i read the error more carefully
10:10:45 <johnw> ashishnegi: the error is just what it says; there is no Eq a constraint
10:10:48 <ReinH> that often helps
10:10:58 <johnw> ReinH!
10:10:59 <yulax> this is what always happens xD
10:11:22 <yulax> i write solid code then make a stupid mistake and put it here
10:11:47 <ashishnegi> johnw: oh .. foolish me.. i was reading error as about my `Eq`.. thanks 
10:11:50 <ReinH> johnw!
10:11:54 <yulax> actually
10:12:06 <yulax> now i *have* discovered a problem
10:12:13 <yulax> it always returns true
10:12:26 <geekosaur> ashishnegi, seems to me if you say Expr a -> a, then return Bool, you are forcing Expr Bool
10:13:09 <yulax> even though the function as the argument might return false
10:13:16 <ReinH> I think it also seems that way to the compiler.
10:13:54 <ashishnegi> geekosaur: no.. in `Expr a` in eval for `Eq e1 e2` : a is Bool
10:14:07 <yulax> hmm this is rather strange
10:14:39 <ashishnegi> because `Eq :: e1 -> e2 -> Expr "Bool"` 
10:19:02 <parket> Hey, guys. How can i define type, that have some of values of another type?
10:19:20 <NickHu> parket: data constructor
10:19:39 <ReinH> What do you mean by "some of value"?
10:19:44 <ReinH> *values
10:19:56 <ashishnegi> yulax: your solution will give True `if allEqual gives False and (p + q  + r == 3 *p) is also False`
10:20:11 <ReinH> You can't restrict a type to a subset of another type's values. Haskell does not have subtyping or refinement.
10:21:14 <parket> Imagine that we have some type `data Fun = Hey | Ho | Lets | Go`. How cat i define another type `data subFun = Hey | Lets`
10:21:22 <ReinH> You can't.
10:21:24 <ReinH> I just said that.
10:21:46 <parket> Ok. Sorry. I was writing this...
10:22:16 <ashishnegi> parket: what is your use case ?
10:22:35 <parket> No case. Just interesting
10:22:35 <yulax> ashishnegi: yes that is right, i understand now
10:23:06 <yulax> it is just a silly question in the ntextbook so i will go on to the next one
10:23:12 <parket> Ok. But i can define polymorphic constant `let fun :: forall a. Num => a; fun = 10` 
10:23:43 <parket> So 10, is the intersection of `Num a` typeclass datatypes. Right? 
10:23:45 <ashishnegi> parket: i also think that since `Hey` is data constructor.. you can not have two DCs with same name atleast in one module .. i think.. please correct anyone, if wrong
10:23:46 <geekosaur> numbers are magical
10:24:01 <ReinH> parket: You can constrain types via typeclasses, yes.
10:24:19 <ReinH> x :: Num a => a says that x can be of any type that has an instance of Num.
10:24:32 <geekosaur> a literal number is translated by the compiler to an application of fromInteger or fromRational as appropriate. this is not done for random constructors, and generally can't be because pattern matching relies on constructors being distinct
10:24:59 <geekosaur> (numbers are again hacky in patterns, and add Eq constraints silently to translate them to guards)
10:25:30 <ReinH> I don't think the question is really about number literals
10:25:59 <parket> Ok, so this is `exception of the rules`. 
10:26:08 <ReinH> What rule do you think it is an exception of?
10:26:49 <parket> That different types can have common values.
10:26:55 <ReinH> No, it is not.
10:27:11 <ReinH> 10 :: Int and 10 :: Nat are different values in different types.
10:27:29 <ReinH> Their constructor is "overloaded" via the typeclasses
10:28:24 <parket> Hmm. Sorry, i do not understand about `overloaded` constructors
10:28:44 <parket> have not understood
10:28:54 <ReinH> Ok, it is a question about number literals. Listen to geekosaur.
10:29:12 <ReinH> :t 10
10:29:13 <lambdabot> Num t => t
10:30:20 <ReinH> Multiple types have a value called 10. They share the same name, but they are different values.
10:30:22 <ReinH> :t fmap
10:30:24 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:30:29 <ReinH> multiple types have a function called fmap defined on them
10:30:36 <ReinH> they share the same name, but they are different functions.
10:31:04 <ReinH> 10 :: Int and 10 :: Double are no more the same value than fmap for Maybe and fmap for []
10:31:13 <parket> Ok. Overloaded function. I know. What abut overloaded constructors?
10:31:22 <geekosaur> there aren't any
10:31:40 <parket> Ok. All clear. Thx guys :)
10:31:57 <geekosaur> I think there's a way to hack it using typeclasses and pattern synonyms (an extension) but that's getting fairly advanced
10:31:58 <Tuplanolla> I find it helpful to imagine 42 not as an integer, but as a variable with a name that happens to be numeric.
10:32:08 <parket> Number literals is a kind of magic. It is an "exception". Ok. :)
10:32:34 <exio4> geekosaur: and ViewPatterns :p 
10:32:37 <Tuplanolla> Unlike other variables, you have infinitely many of those.
10:32:52 <ReinH> Why is that unlike other variables?
10:33:30 <Tuplanolla> You can't import or export infinitely many definitions in a module, ReinH.
10:33:52 <parket> Tuplanolla: nice point of view :)
10:35:44 <ReinH> You can't put infinitely many integer literals into a file either
10:36:48 <mizu_no_oto_work> ReinH: however, the set of integer literals you can use is infinite, right?
10:36:54 <ReinH> So is the set of variable names you can use.
10:37:26 <ReinH> Indeed there are exactly the same number of both
10:37:45 <ReinH> (I should say, the two sets have the same cardinality)
10:38:43 <exio4> there aren't infinitely many defined "normal" variables at any given time in a Haskell program though
10:38:50 <Tuplanolla> The difference is that free variables don't have definitions, ReinH.
10:39:00 <ReinH> How is that relevant?
10:39:10 <mizu_no_oto_work> Whereas any integer has a definition
10:39:13 <ReinH> So?
10:39:46 <exio4> to "fix" Tuplanolla's statement, unlike other bound variables, you have infinitely many of those
10:40:03 <ReinH> That isn't a fix, that is a different claim.
10:40:15 <ReinH> This is goal post shifting.
10:40:33 <Tuplanolla> It seems that you're purposefully misunderstanding to create a controversy, ReinH.
10:40:56 <Tuplanolla> It's a helpful analogy, not a proposition to be proven.
10:41:13 <exio4> a free variable is quite useless in Haskell, per se. a program with free variables won't compile, would it?
10:41:22 <ReinH> Why do you think I'm trying to create a controversy?
10:41:23 <mizu_no_oto_work> parket: there's also overloaded strings
10:41:49 <ReinH> I just disagreed with a statement.
10:41:51 <exio4> because it wasn't meant to be an absolute statement but simple a way to develop some intuition 
10:42:04 <ReinH> So disagreeing with things is "creating a controversy" now?
10:42:22 <ReinH> and responding to the statement as written and not to future changes to that statement is "purposefully misunderstanding" it?
10:42:32 <ReinH> That is a strange, unkind characterization.
10:42:53 * hackagebot textlocal 0.1.0.1 - Haskell wrapper for textlocal SMS gateway  https://hackage.haskell.org/package/textlocal-0.1.0.1 (psibi)
10:42:58 <exio4> ambiguous statement at best, you understood differently to most :) 
10:42:59 <ReinH> That assumes bad faith on my part in a way that is entirely uncalled for, imo
10:43:13 <ReinH> I was just pointing out that there are an infinite number of potential variable names.
10:44:37 <parket> mizy, What about strings?
10:45:10 <mizu_no_oto_work> parket: https://ocharles.org.uk/blog/posts/2014-12-17-overloaded-strings.html
10:45:39 <parket> Thx. I'
10:45:45 <parket> Thx. I'll read it
10:46:00 <exio4> ReinH: (per his previous comment, "but as a variable with a name that happens to be numeric") - I understood it as a bound variable
10:47:25 <exio4> in the general case, it doesn't make sense to talk about both free and bound variables, even. because (assuming we're talking only about valid programs), you will be using only bound variables
10:47:29 <mizu_no_oto_work> parket: much like how '42 :: Num a => a', there's  -XOverloadedStrings where '"a string" :: IsString a => a'.
10:49:27 <parket> http://pastebin.com/Bm3pikJv
10:49:42 <mizu_no_oto_work> parket: and there's IsString instances for e.g. Text and Bytestring
10:49:46 <parket> what's the problem with [Char] here
10:51:39 <geekosaur> standard Haskell only accepts something like [a] there. if you enable FlexibleInstances then it will work
10:51:56 <geekosaur> standard Haskell is a bit conservative...
10:52:20 <parket> Oh. Ok. Thx ;)
10:52:22 <vapid> haskell is a pile of shit
10:52:26 <vapid> in general
10:52:28 <vapid> nobody even uses it
10:52:36 <parket> Bgg. I will.
10:52:36 <grantwu> wat
10:53:03 <parket> Sorry, i need to go. Wife is waiting. Arr.. (she hates haskell too)
11:01:14 <ReinH> exio4: Ok, I can see how it would be interpreted that way. I still think the claim that I was "purposefully misunderstanding" and "creating a controversy" was unfair and unkind.
11:05:16 <ReinH> exio4: I think it makes sense to talk about the supply of variable names, regardless of their free or bound status.
11:06:05 --- mode: ChanServ set +o johnw
11:06:09 --- mode: ChanServ set +o johnw
11:06:10 --- mode: johnw set +b *!~dfgsfdghs@h42-57.pool95-168.dyn.tolna.net
11:06:10 --- kick: vapid was kicked by johnw (Kicked)
11:06:10 --- mode: johnw set -o johnw
11:08:06 --- mode: ChanServ set +o glguy
11:08:06 --- mode: glguy set +b-bo *!*@h42-57.pool95-168.dyn.tolna.net *!~dfgsfdghs@h42-57.pool95-168.dyn.tolna.net glguy
11:20:31 <shapr> Random question, when did fold start using Foldable?
11:20:57 <johnw> just "fold"?
11:20:57 <hpc> recently
11:20:59 <geekosaur> 7.10
11:21:16 <johnw> :t fold
11:21:17 <lambdabot> (Monoid m, Foldable t) => t m -> m
11:21:28 <geekosaur> foldable/traversable proposal
11:21:54 <hsk3> I love how, when making major changes to the structure of my app, I don't have to worry about pure functions.
11:21:54 <hsk3> Can't do that in other langs.
11:22:08 <hsk3> s/about pure/about the pure
11:22:57 <hpc> technically you still don't have to worry about pure functions in other languages either, but then you still have to know which are which
11:23:02 <hpc> :D
11:23:17 <hsk3> hpc: yep
11:23:40 <hsk3> in haskell i just have to look at the type signature. if i don't see IO, I'm good
11:23:46 <hsk3> it's like a load is off of my shoulders
11:25:20 <nshepperd1> Did fold ever exist outside of Foldable?
11:25:41 <Hafydd> I have some concerns about your methodology, then, because (1) a function IO in its signature is still pure - in fact, all functions in Haskell are pure; it is only the execution of main that produces side effects. And (2) there are types other than IO that can encode some kind of side effects, such as ST.
11:25:52 <geekosaur> hm, actually I don't think so
11:26:15 <shapr> johnw: Just ran across a Haskell bot plugin (at work) that doesn't have Foldable in the foldr type signature, just wondering how old that made the underlying Haskell version
11:26:25 <johnw> ah, foldr is 7.10
11:26:26 <geekosaur> since there was at least one fold-like thing for most of the types that supported folding
11:26:47 <geekosaur> and lists always forced you to pick a foldl or foldr
11:26:59 <Hafydd> Indeed, there are types without the text "IO" appearing in their names that can encode IO effects.
11:27:24 <nshepperd1> Pre-Foldable there was mconcat for lists
11:27:37 <monochrom> I'm sure hsk3 knows all of those.
11:28:05 <Hafydd> Then I'd be interested to know how looking for "IO" in type signatures helps with restructuring an application.
11:28:37 <shapr> nshepperd1: I was trying to do "foldr (+) 0 (Data.Tree.Node 1 [Data.Tree.Node 2 [], Data.Tree.Node 3 []])" but it broke :-(
11:29:13 <nshepperd1> Oh yeah, foldr was list only before 7.10
11:29:30 <shapr> ah, too bad
11:29:32 <nshepperd1> The one in prelude anyway
11:30:46 <grantwu> Also https://mail.haskell.org/pipermail/haskell/2009-March/021064.html ?
11:30:52 <nshepperd1> You could still hide it from prelude and import Data.Foldable
11:33:47 <shapr> grantwu: yeah, if the world changes underneath you, that's a real problem
11:34:36 <nshepperd1> That's easy to avoid though, you can just not use functions starting with "unsafe"
11:35:15 <mightybyte> What's the pragma to suppress a particular warning at a particular module/place in the code?
11:35:16 <grantwu> nshepperd1: No functions starting with unsafe were used in that example
11:36:21 <glguy> mightybyte: You can use an {-# OPTIONS_GHC pragma at the top of the file with a ghc flag to turn off the warning, typically inserting a no- into the flag
11:36:42 <nshepperd1> Or the standard file io functions (readfile, *getContents) :(
11:36:43 <glguy> mightybyte: See $  ghc --show-options | fgrep no-
11:37:00 <mightybyte> glguy: Awesome, thanks.
11:39:34 <nitrix> Given "abcd", how would I generate [["abcd"], ["a","bcd"], ["ab","cd"], ["abc","d"], ["a","bc","d"]] ?
11:39:47 <nitrix> (All groupings, order preserving)
11:40:08 <nitrix> This is not combinations, nor permutations :/
11:40:29 <grantwu> your example is missing a few, I think?
11:40:52 <grantwu> you should have 2^(n-1) groupings
11:40:57 <johnw> "a", "b", "cd", etc.
11:41:07 <nitrix> You're right, I'm missing a few.
11:41:24 <nitrix> I would I write that? I'm trying a divide and conker approach with a list comprehension and failing.
11:42:43 <lispy> nitrix: lpaste.net if'd like to show your code. That's usually the best way to get help on homework-ish problem like this
11:42:54 * hackagebot vty 5.11.1 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.11.1 (JonathanDaugherty)
11:42:56 * hackagebot glirc 2.20.1 - Console IRC client  https://hackage.haskell.org/package/glirc-2.20.1 (EricMertens)
11:42:58 * hackagebot epub-metadata 4.4 - Library for parsing epub document metadata  https://hackage.haskell.org/package/epub-metadata-4.4 (DinoMorelli)
11:43:06 <Tehnix__> Hmm, does anyone else experience that stack wants to build in root on Ubuntu?
11:43:08 <Tuplanolla> Do you divide by those that have "a" and those that don't, nitrix?
11:43:48 <Tuplanolla> That would seem like a good start.
11:45:33 <nshepperd1> Enumerate the possibilities for the first group, then group the rest of the list?
11:49:33 <lyxia> > let f [] = [[]] ; f xs = [ a : as | (a, ys) <- tail (liftA2 zip inits tails xs), as <- f ys ] in f "abcd"
11:49:35 <lambdabot>  [["a","b","c","d"],["a","b","cd"],["a","bc","d"],["a","bcd"],["ab","c","d"],...
11:49:50 <lyxia> > let f [] = [[]] ; f xs = [ a : as | (a, ys) <- tail (liftA2 zip inits tails xs), as <- f ys ] in f "abc"
11:49:52 <lambdabot>  [["a","b","c"],["a","bc"],["ab","c"],["abc"]]
11:51:39 <hsk3> Can a UTF-8 data always be successfully converted to Data.Text ?
11:51:51 <hsk3> They say Data.Text is UTF-16.
11:53:10 <glguy> If you have a valid UTF-8 encoding of some Unicode text, then you'll be able to decode that with the text package to create a Text value
11:53:26 <hsk3> yeah ok. found Data.Text.Encoding for that
11:53:31 <hsk3> decodeUtf8
11:53:39 <glguy> That Text is represented with UTF-16 internally isn't an issue
11:53:40 <lyxia> nitrix: It is in bijection with subsets of spaces between elements, or combinations of the tail (cut the list before every chosen element).
11:54:46 <nitrix> lyxia: I could've come up with it after a while, but your approach seems super straight forward and rational.
11:55:04 <nitrix> I'll break it down and definitely learn a thing or two from it :)
11:55:39 <Tuplanolla> I like the `(a, ys) <- tail` part.
11:55:42 <nitrix> I'm sure that instinct comes over time. I appreciate.
11:56:04 <lyxia> Tuplanolla: :)
11:56:08 <nitrix> I like the recursive as <- f ys.
11:57:18 <shapr> I like recursion, what about you?
11:58:00 <systemfault> I like recursion, what about you?
11:58:10 <shapr> systemfault: correct answer :-)
11:58:17 <systemfault> :)
11:58:20 <johnw> I like recursion, provided that this statement is true
11:58:44 <kyren> am I right in thinking that there is not a specific way to fold over a subset of a Data.Array.Array, I thought maybe there was slicing magic going on with ixmap but it appears not
11:59:15 <lyxia> kyren: what do you mean by fold over a subset
11:59:39 <ReinH> a contiguous subset (i.e., a slice)?
11:59:42 <kyren> I mean I can do it using ! of course, I just wanted an easy fast way
12:00:02 <kyren> yeah, it's a 2d array here so.. yes depending on what you mean by contiguous
12:00:15 <ReinH> Although, with arbitrary indices, the meaning of contiguous depends... yes
12:00:15 <kyren> it's actually an array of bools, I just want to see if an array range is all False
12:00:31 <ReinH> Well, how do you compute the indices in the range?
12:00:53 <kyren> I'm using V2 from Linear as the index
12:00:54 <phaskell-2> V2: What DNS naming convention should we use for GHC buildbots? Come Vote https://phabricator.haskell.org/V2
12:00:54 <phaskell-1> V2: What DNS naming convention should we use for GHC buildbots? Come Vote https://phabricator.haskell.org/V2
12:01:44 <ReinH> so you want to work with rectangular slices?
12:01:51 <ReinH> iirc repa has facilities for that built in
12:01:56 <kyren> yeah, or just really fast check a bunch of bools
12:02:13 <kyren> yeah I know, I figured repa would be the answer
12:02:22 <dmj`> is there a way to specify in the cabal file what configuration options should be used if 'cabal configure' is called
12:04:13 <kyren> I was trying to avoid learning repa, it seems like it's massive overkill, but if it's the best way then that's sensible
12:08:04 <ReinH> I mean, you can generate the indices you care about and then fold over them.
12:08:16 <ReinH> If you want to short-circuit, you can foldr.
12:10:33 <neonfuz> Any good way to learn cabal? Real world haskell has like nothing on it
12:10:38 <neonfuz> Real world my ass
12:10:59 <johnw> Rational world haskell would have been more accurate
12:11:09 <geekosaur> it largely predates cabal-install, is the problem there
12:11:17 <johnw> Fractional a => a world haskell
12:11:42 <ReinH> Fraction real => real world haskell trollface.jpg
12:11:46 <geekosaur> unfortunately the haskell ecosystem changes so rapidly that it was already out of date when it was published (extensible exceptions had gone in)
12:12:09 <dmj`> neonfuz: probably this
12:12:10 <dmj`> https://www.haskell.org/cabal/users-guide/developing-packages.html#configurations
12:12:16 <dmj`> it doesn't cover some newer things though
12:12:24 <dmj`> like sandboxes :)
12:12:49 <mizu_no_oto_work> You probably want to be using cabal sandboxes, though
12:13:13 <dmj`> mizu_no_oto_work: well... I'd just use stack then, or nix. Which sandboxes ghc, or your whole system
12:13:34 <thoughtpolice> The newer docs with up-to-date info and a better style is here: http://cabal.readthedocs.io/
12:14:30 <dmj`> thoughtpolice: ooo :) 
12:14:32 <thoughtpolice> (Also: for newer cabal, it's hip to be using cabal new-build these days, instead of sandboxes, since now they're basically obsolete)
12:14:32 <mizu_no_oto_work> Nix does have advantages, but I'm not sure I really understand why I'd want to switch from cabal sandboxes to stack.
12:14:53 <ReinH> If someone wants to learn how to use Haskell packages and your advice is "learn nix"...
12:15:23 <ReinH> nix is nice, but it's also a LOT of work to learn and use.
12:15:29 <geekosaur> try new-build. think of it as nix without the pain of nix
12:15:39 <dmj`> thoughtpolice: off hand, would you happen to know how to specify default configuration options. It'd be nice instead of cabal saying "using last known configuration options", to use some specified default (esp. when working with ghcjs)
12:15:52 <dmj`> ReinH: so true
12:15:59 <dmj`> failed to learn it many a time, finally have a sane workflow
12:16:01 <johnw> dmj`: isn't that what cabal.config does?
12:16:11 <thoughtpolice> You can do that with new-build and cabal.project files. Alternatively, I suppose you could do 'cabal configure -w ghcjs' or whatnot.
12:16:18 <thoughtpolice> Which should cache the chosen compiler and options, etc.
12:17:55 <dmj`> thoughtpolice: ahh, hmm, I have two shells working on the same project, one only has ghc and the other ghcjs. If I add a module in the ghc shell, then the ghcjs one will see the cabal file has changed and attempt to reconfigure, the problem is that it will configure with the ghc options (omits the --ghcjs) flag. So I have to exit emacs and 'cabal configure --ghcjs' like a poor man.
12:18:43 <dmj`> so if in cabal.config there was a way to do if impl(ghcjs) then default-configure: cabal configure --ghcjs else default-configure: cabal configure, that would be sweet
12:19:04 <thoughtpolice> dmj`: Ah, that's a tricky one, yeah. So, new-build can handle two different compilers in two different shells very easily, much like a sandbox (it's even nicer than that). But the options thing is tricky.
12:21:03 <thoughtpolice> dmj`: ATM, I don't think anything like that exists I'm afraid, although it seems like it could be handled. You should definitely file a bug; something like this will be easier to fix in new-build (since it's still evolving and not set in stone, yet)
12:21:11 <dmj`> thoughtpolice: yea, makes sense, it's kind of a wonky thing that I'm doing, but maybe some patch where 'cabal configure' attempts to read "$CONFIGURE_OPTS" if specified, but I can see that going very badly in some cases, causing parse failures / confusion if the user forgot they specified that environment variable. export CONFIGURE_OPTS=--ghcjs
12:21:34 <thoughtpolice> dmj`: Alternatively -- if cabal can automatically detect that 'ghc' is actually ghcjs... You could just 'alias ghc=ghcjs' in one shell and be done.
12:21:58 <geekosaur> emacs won't inherit shell aliases though
12:22:16 <kyren> okay, repa cannot slice over a range anyway apparently
12:22:26 <thoughtpolice> Well sure, alias isn't really the point, you get what I mean. If you can just reasonably specify ghcjs as ghc, and cabal can detect that, it should work.
12:23:08 <thoughtpolice> I'm not sure if cabal requires --ghcjs at the moment. If it could autodetect it, you wouldn't need any extra options during the reconfigure step.
12:24:22 <thoughtpolice> That doesn't solve the more general problem though, but something like the environment variable bit could work, there.
12:24:38 <thoughtpolice> dmj`: Anyway, I definitely suggest filing a bug with your thoughts. Maybe I'm missing something and this is easily achievable now.
12:24:41 <dmj`> thoughtpolice: hmmm, that might be the ticket, the nix-shell's I'm using aren't pure, so maybe it's looking at 'ghc' first. But in haskell-mode it says in the log, "Using last known configuration options" 
12:25:13 <dmj`> since ghc is in my nix profile, I realized later I have to manually add cabal to my libraryHaskellDepends when using --pure
12:25:43 <dmj`> thoughtpolice: for sure, I'll add a feature / bug request see what others say, hopefully it exists already :) 
12:26:43 <dmj`> pretty sure emacs would inherit the environment variable
12:26:52 <dmj`> johnw: but yea, maybe this already can be done in cabal.config
12:28:09 <dcoutts> thoughtpolice, dmj`: you need to tell cabal that you're using ghcjs
12:28:23 <dcoutts> or hugs or jhc or ...
12:28:41 <linoge> So, I'm learning cat theory. Can Bank Accounts be considered a cathegory and transactions an endofunctor?
12:28:55 <pikajude> meow
12:30:42 <c_wraith> linoge, what are the objects and morphisms in the category? 
12:30:47 <johnw> linoge: I've spent some time thinking about that in fact
12:30:56 <dmj`> dcoutts: yea, I think my issue is I'm using both, one in each shell, where they're both symlinked from the nix store. So poor cabal doesn't know what I want when I want it
12:30:57 <c_wraith> linoge, that's always what you start with. 
12:33:21 <dcoutts> dmj`: I don't see that that's a problem
12:34:47 <c_wraith> dcoutts, is there any plan for cabal-install to get the ability to specify that an executable should be built with ghcjs, but a different one in the same file should be built with ghc? 
12:35:15 <dcoutts> c_wraith: not in a .cabal file, but yes we want to support that in new-build, specified in the cabal.project file
12:35:34 <dcoutts> c_wraith: ie to support the frontend/backend  ghcjs/ghc project setup
12:35:38 <linoge> c_wraith: thanks for the insight. I can't think of any arrows that takes you from a bank account to another right now. But I'll think about it ^^.
12:36:07 <linoge> And will come later with my answer, as I'm going out right now ^^
12:36:10 <c_wraith> dcoutts, awesome. I'm glad you're working on it 
12:36:40 <dcoutts> c_wraith: not working on it actively, but there's a design there
12:36:46 <dcoutts> if you want to help...
12:36:48 <dcoutts> :-)
12:42:56 * hackagebot textlocal 0.1.0.2 - Haskell wrapper for textlocal SMS gateway  https://hackage.haskell.org/package/textlocal-0.1.0.2 (psibi)
12:47:23 <ab9rf> can someone point me to somewhere where i can read what's new in 8.0.1 platform?
12:47:35 <PhsShft> Can someone explain to me how type class works? like in http://paste.ofcode.org/35VugpHNjBWafnGyzFEfwQp here, how do I use “Point” and its “Double” value?
12:47:41 <Tuplanolla> ab9rf: https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html
12:47:54 <ab9rf> Tuplanolla: thank you
12:50:25 <ab9rf> i've been working in other languages for the last several months and have been away :)
12:51:40 <geekosaur> PhsShft, that has nothing to do with typeclasses. and you probably do not want to define typeclasses unless you understand what they are (which is, specifically, nothing to do with OOP)
12:52:21 <PhsShft> geekosaur: ok.. i’ll go read first..
12:56:30 <geekosaur> anyway if you just want to know what was going on in that data declaration:
12:56:46 <geekosaur> you have defined a type called Point, with a data constructor also called Point which takes a Double as a parameter.
12:57:02 <geekosaur> (Point 5.001) is a literal of type Point
12:57:29 <PhsShft> Thanks…
12:57:31 <geekosaur> you can pattern match on a Point to extract the Double. this is usually done in function definitions that take a Point parameter
12:58:14 <geekosaur> sorry (Point 5.001 4) would be the literal
12:58:25 <PhsShft> yea was just gonna ask :)
12:58:35 <geekosaur> and a function, foo (Point x y) = ... {- here x and y are the Double-s -} ...
13:01:21 <geekosaur> if you prefer, you can define it as a record instead:  data Point = Point { x, y :: Double }
13:01:33 <geekosaur> and now you have functions x and y you can apply to a Point value
13:01:47 <geekosaur> (in practice you really want to use more distinctive names though)
13:01:59 <PhsShft> so if I want to use the double value in a function foo (Point x y) , what do I need to do?
13:03:08 <geekosaur> that definition has a pattern match in it. it gives you x and y as the Doubles
13:03:19 <PhsShft> oh i see
13:03:50 <geekosaur> we use pattern matches to extract values like that quite often
13:06:24 <miomio9090> hello
13:07:18 <miomio9090> cist some friend who speaks Italian I need a hand
13:09:47 <sigrlami> hi, I'm trying to upload docs to hackage with curl to directory of my package, while I get message that it was successfully upload, I can't see them on site. Is something broken?
13:10:37 <sigrlami> or this should take some time? is there auto generation for package?
13:10:49 <puregreen> sigrlami: maybe it's a trouble with CDN. What's your package?
13:12:56 <sigrlami> puregreen: sorry for disturbance, it just appeared, took about 10 min
13:14:57 <chenyu> A question: do you use intero for coding haskell on emacs?
13:15:52 <puregreen> chenyu: I don't
13:15:55 <jg_> how can i pass a haskell ADT constructor to a function without the compiler complaining that i didn't provide all the parameters?
13:16:37 <johnw> why would it complain at all?  It's a function
13:16:42 <jg_> exactly
13:16:43 <johnw> can you show me your code?
13:17:05 <chenyu> company and company-ghc works well for me, but recently I saw intero, so I wonder what it has over company
13:19:05 <Phyx-> jg_: probably missing () around the constructor so it knows not to try to apply it.
13:19:07 <jg_> johnw: http://lpaste.net/5506906345653141504
13:20:05 <geekosaur> oh. you're not allowed to use variable arity like that in patterns. 
13:20:09 <jg_> compiler says Neg is applied to too few arguments in second argument of 'prefix'
13:21:11 <geekosaur> ad I misread the last part, sigh, that's not relevant x.x
13:22:13 <ab9rf> that cvnfused me
13:23:19 <johnw> jg_: I don't see the complaint
13:24:29 <Phyx-> jg_: what's the type of Infix and Prefix?
13:25:16 <geekosaur> those `return fun (getInfo pos)` look wrong to me
13:25:36 <geekosaur> but yes, more types and the actual error (preferably a runnable example) would help
13:25:48 <Phyx-> they have different return types for sure, so I'm wondering how those two constructors are defined
13:25:54 <ab9rf> ll the AExpr constructors need an Info, and i don't see where Info is coming from]
13:26:00 <lyxia> const fun (getInfo pos) = fun
13:26:52 <ab9rf> there's not really enough types here to understand the problem
13:27:07 <ab9rf> the code checks vaguely ok because much of it is missing
13:27:08 <jg_> sorry
13:27:15 <jg_> i've posted the whole file to lpaste
13:27:22 <jg_> wasn't sure how to cut it down to size
13:27:24 <nitrix> jg_: I see no issue with the inferred type of `fun`, but I too I'm suspicious about return (fun (getInfo pos))
13:27:50 <geekosaur> actually that would parse as (return fun) (getInfo pos), I think
13:28:05 <ab9rf> it does
13:28:25 <geekosaur> and I'm having trouble imagining a type for Prefix that would make that make sense
13:28:38 <nitrix> `t (a -> b)`  applied on `a`
13:28:46 <ab9rf> geekosaur: there is one, but it's hard to see how it would be useful
13:29:03 <jg_> i took that code from https://hackage.haskell.org/package/parsec-3.1.11/docs/Text-Parsec-Expr.html . Probably used it wrong?
13:29:04 <nitrix> Possibly ((->) r) or some fun stuff :P
13:29:28 <geekosaur> definitely would be that, but mixing it with the rest seems dubious
13:30:06 <nitrix> postfix name fun       = Postfix (do{ reservedOp name; return fun })
13:30:24 <ab9rf> i would strongly advise whoever's paste this is to put declared types on binary, prefix, and postfix
13:30:32 <ab9rf> you'll get a much more useful error message from the compiler
13:30:57 <nitrix> jg_: You can replace `return fun (getInfo pos)` with `return (fun (getInfo pos))` and be happy :)
13:31:37 <ab9rf> or return $ fun (getInfo pos) or even return $ fun $ getInfo pos, if you are adverse to parentheses and don;'t mind dollar signs littering your code
13:31:41 <nitrix> Or getPosition >>= return . fun . getInfo  ?
13:33:45 <jg_> thanks! 
13:34:03 <jg_> i'll add the type annotations too
13:34:32 <jg_> should've started with that i guess
13:34:54 <nitrix> jg_: `a b c`, reads as `(a b) c`. I think you assumed `a (b c)` because you got temptated to think of `return` as some kind of keyword/operator, which it isn't.
13:35:07 <ab9rf> "tempated"
13:35:15 <ab9rf> "temptated" that is
13:35:17 <ab9rf> good word, sorta
13:35:30 <jg_> tempted maybe? definitely :)
13:35:33 <nitrix> What's the correct word?
13:35:36 <ab9rf> tempted
13:35:41 <ab9rf> but temptated sounds sexier
13:35:41 <nitrix> Ah. Noted.
13:36:20 <nitrix> Strange. Temptation vs. Tempted/Temption.
13:36:30 <nitrix> You'd think it'd be more consistent.
13:36:41 <geekosaur> someone expects English to be consistent...
13:36:50 <codedmart> If a function is `func :: a -> b -> c` and I use flip that just swaps a and b right? But if I want to swap b and c?
13:37:09 <nitrix> codedmart: (\a b c -> a c b)
13:37:10 <geekosaur> codedmart, that makes no sense, did you want a -> b -> c -> d?
13:37:18 <geekosaur> (c would be the result in yours)
13:37:19 <nitrix> But you can't :D
13:37:21 <mizu_no_oto_work> nitrix: When has natural language ever been consistent?
13:37:29 <codedmart> geekosaur: Sorry yes
13:37:38 <nitrix> Unless you get into fancy contravariant functors :P
13:37:38 <codedmart> You are right I left off the last one.
13:38:30 <geekosaur> there is probably some combination of flips that would do it, but you're usually better off just writing what you want
13:38:41 <codedmart> OK thanks guys!
13:38:42 <geekosaur> things get *scary* beyind a single flip
13:38:45 <nitrix> @pl (\a b c d -> a c b d)
13:38:45 <lambdabot> flip
13:38:47 <koz_> @pl (\x y z -> x z y)
13:38:47 <lambdabot> flip
13:38:48 <geekosaur> *beyond
13:38:54 <codedmart> Just wanted to be sure I wasn't missing something.
13:38:54 <koz_> Damn ninjas...
13:38:56 <Tuplanolla> :t flip3
13:38:56 <nitrix> err.
13:38:57 <mmaruseacph2> English is hard though through throughout thought you can learn it
13:39:00 <lambdabot> error:
13:39:00 <lambdabot>     • Variable not in scope: flip3
13:39:00 <lambdabot>     • Perhaps you meant ‘flip’ (imported from Data.Function)
13:39:14 <Tuplanolla> There's `flip3` in `Data.Function.Flippers`.
13:39:17 <koz_> mmaruseacph2: s/throughout/thorough ?
13:39:23 <nitrix> @pl (\f a b c d -> f a c b d)
13:39:23 <lambdabot> (flip .)
13:39:27 <nitrix> There :P
13:40:59 <mmaruseacph2> koz_: yep
13:41:02 <mmaruseacph2> I still learn it
13:41:07 <mmaruseacph2> *I'm still learning it
13:41:37 <nitrix> codedmart: You could use (flip .) but I'd advise agaisn't it.
13:41:51 <ab9rf> don't use code you don't understand
13:42:15 <nitrix> codedmart: Swap the arguments or write a lambda that does it, or even a flip2 helper.
13:42:15 <codedmart> nitrix: OK thanks!
13:42:58 * hackagebot snaplet-sqlite-simple 1.0.0.0 - sqlite-simple snaplet for the Snap Framework  https://hackage.haskell.org/package/snaplet-sqlite-simple-1.0.0.0 (sigrlami)
13:43:04 <nitrix> Forth calls it "dip
13:43:13 <nitrix> "
13:43:14 <ab9rf> there's no penalty for using a lambda or an explicit helper function, and the resulting code will be easier for you to understand later than some freaky idiom that works but you will never understand why
13:43:40 <koz_> Yeah - relying on @pl as a refactoring tool leads to bad times.
13:43:42 <ab9rf> (well, ok, the compiler takes 227 milliseconds longer)
13:44:58 <lyxia> that's a lot
13:45:19 <nitrix> You could actually make a neat higher-order function `dip` that temporarily remove the first argument of the target function, then apply a function of your choice like flip on it, then puts it back.
13:46:19 <Tuplanolla> There's also `cardinalstar` in `Data.Aviary.Birds`.
13:47:31 <koz_> Tuplanolla: Is that based on Smullyan's book?
13:47:39 <Tuplanolla> Yes, koz_.
13:47:41 <koz_> (like, the one where all the logic combinators are birds?)
13:50:12 <nitrix> dip trans func = trans . func
13:50:44 <nitrix> dip flip (\a b c d -> (a,b,c,d)) == (a,c,b,d)
13:51:43 <nitrix> And, so we learn why @pl simplified dip as just (.) o:
13:56:40 <nitrix> Then you can dip (dip flip)! Double dip :P
13:56:59 <hpc> that's just dip . dip $ flip
13:57:04 <hpc> or dip dip dip $ flip
13:57:09 <hpc> triple dip
13:57:29 <ab9rf> dippity doo dah
13:57:29 <nitrix> Mhm. No one likes double dippers.
13:57:30 <hpc> don't even need the ($) there, dip dip dip flip
13:58:15 <Tuplanolla> Forth dsl coming up?
14:04:39 <ongy> @pl (\f a b c d e -> f e d c b a) -- scary flips? I don't think I want to understand this
14:04:39 <lambdabot> flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .) . flip
14:05:14 <nathyong> What's the difference between ReaderT StateT and StateT ReaderT?
14:06:45 <ab9rf> i'm reallyq uite glad that that's not simpler than it is
14:07:58 <ab9rf> nathyong: practically, or technicall?
14:08:07 <nathyong> practically
14:08:32 <nathyong> I'm still trying to wrap my head around what `local` would do for instance
14:08:48 <ab9rf> hm.
14:09:24 <johnw> r -> s -> (a, s) vs. s -> r -> (a, s)
14:13:00 <ongy> I'd be interested in the technicall difference aswell :)
14:13:43 <johnw> that is the technical difference: they are isomorphic
14:14:02 <mmaruseacph2> just one flip away
14:14:11 <johnw> I did it for Reader r (State s a) vs. State s (Reader r a), but just insert the m's to get the transformer variety
14:19:16 <nathyong> oh cool
14:27:37 <dredozub-> it's a nice quality of writers/readers/states - you can reaarange them however you want and it'll be isomorphic
14:36:07 <neonfuz> How good is "The Haskell Book" btw?
14:39:00 <fnurglewitz> neonfuz: this one? http://haskellbook.com/
14:40:35 <MarcelineVQ> it's 20 good
14:41:32 <neonfuz> so... its good?
14:41:56 <neonfuz> right now I'm looking at "the haskell book", "real world haskell" and "learn you a haskell"
14:43:00 * hackagebot hw-prim 0.3.0.4 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.3.0.4 (haskellworks)
14:43:02 * hackagebot llvm-pretty 0.5 - A pretty printing library inspired by the llvm binding.  https://hackage.haskell.org/package/llvm-pretty-0.5 (TrevorElliott)
14:43:30 <MarcelineVQ> It's a bit of a tough question because good is probably the most subjective human word there is :> I enjoyed the book, it takes you from the very basics through everything you need to know to write your own stuff. You can learn everything it teches you elsewhere, between stack exchange and real world haskell and something like the cis course or nicta, but you'll pick it up a lot faster with the haskell book because it introduces 
14:43:30 <MarcelineVQ> everything in a structured way that builds on each thing you learn.
14:44:06 <MarcelineVQ> @where learnhaskell
14:44:06 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:44:07 <MarcelineVQ> links for the cis course and nicta can be found here
14:44:35 <hpc> indeed, the key thing is ordering the concepts so you learn each after the others it depends on
14:45:15 <puregreen> neonfuz: lots of people like it. Some people dislike it and recommend more rigorous books instead. Some people (like me) are turned off by its humor (while others might like its humor). Overall it's hard to say that it's *unambiguously* better than LYAH, but in terms of coverage it's definitely better.
14:45:21 <hpc> (which there are multiple orderings of for many of the core language features)
14:45:27 <neonfuz> MarcelineVQ: the thing I didn't like about learn you a haskell is they didn't get into cabal usage or any of that
14:46:14 <MarcelineVQ> learn you a haskell is regarded as, and I agree, a great introduction to the language but not an ideal way to actually learn it.
14:46:21 <neonfuz> yeah, 
14:46:25 <neonfuz> I can completely see that
14:48:07 <ab9rf> i didn't care for lyah
14:48:11 <ab9rf> rwh was more useful for me
14:48:25 <fnurglewitz> puregreen: which is a more rigorous book?
14:49:15 <ab9rf> which is a better book likely depends on your background (e.g. how much math you have, how much CS theory, how much and what experience in other languages)
14:49:19 <puregreen> I think Hutton's “Programming in Haskell” was mentioned
14:49:40 <fnurglewitz> he released a version a couple of weeks ago, right?
14:50:06 <puregreen> well, September 1
14:52:30 <sm> PIH (short) and HB (long) are generally the highest-reviewed haskell books
14:54:22 <sm> oh, not HB.. HPFFP I guess
14:54:37 <fnurglewitz> haskell programming from first principles? :P
14:54:56 <puregreen> HB is how everyone calls it so HPFFP would just create confusion, I guess
14:55:30 <sm> seems the confusion is already here (haskell book vs haskell programming vs haskell programming from first principles)
14:55:40 <fnurglewitz> marketing-wise they chose a quite good domain name
14:55:59 <puregreen> sm: yep! that's why it's important not to create more :)
14:56:07 <fnurglewitz> "haskellbook" gives you the idea that it is THE haskell book
14:56:39 <sm> bitemyapp: what's your preferred naming and acronym ?
14:57:15 <puregreen> fnurglewitz: it's also somehow the first name that comes to people's minds when they are writing a Haskell book, so there's a possible innocent explanation to that. I mean, I'm writing a book and my repository is called “hb”, my friend (was) writing a book and their repository was called “hb” too :)
14:57:32 <fnurglewitz> indeed
14:57:49 <fnurglewitz> but there's no shame in trying to sell more, after all there's a lot of hard work on that book
14:58:38 <ertes> i very much prefer a confusing "HPFFP" over people calling any particular book "the haskell book"
15:00:13 <Tuplanolla> You can still do better and call the next one The Book.
15:00:18 <ab9rf> BOOK, THE
15:00:34 <fnurglewitz> "hey bro, what are you reading?"
15:00:36 <fnurglewitz> "the book"
15:00:44 <fnurglewitz> "ok but... which one?"
15:00:51 <ertes> no, that one is reserved for The Book: http://chimera.labs.oreilly.com/books/1230000000929/
15:01:01 <ertes> not "the book"
15:01:03 <ertes> "The Book"
15:01:07 <sm> "the good book".. oh no, it's taken
15:01:07 <fnurglewitz> is it good?
15:01:29 <ertes> not even "The Book", but The Book
15:01:32 <xocolatl> the bookie
15:01:33 <ertes> you know, the one
15:01:41 <fnurglewitz> does it end like star wars?
15:01:48 <ertes> i don't know how star wars ends
15:01:52 <nshepperd1> Haskell tome
15:02:33 <xocolatl> fnurglewitz: a musical I recently went to see ended like that, and was about a book
15:02:35 * lispy was gonig to suggest someone write sureal-world haskell, but then remembered LYAH
15:02:46 <puregreen> according to “explicit is better than implicit”, “This Is The Best Book To Learn Haskell” would be a good name
15:03:20 <ab9rf> heh
15:03:44 <fnurglewitz> Haskell: Avoid learning at all costs
15:03:45 <ab9rf> xocolatl: for a moment i thought you were suggesting someone write a musical about learning haskell
15:03:55 <fnurglewitz> HALAAC
15:03:58 <xocolatl> ab9rf: that would be awesome
15:04:00 <fnurglewitz> best acronym ever
15:04:12 <xocolatl> Haskell on Broadway/WestEnd
15:04:28 <MarcelineVQ> "Many People Will Prefer This Book For The Length Of Time It Remains Relevant, It Had A Better Name But The Margain Couldn't Contain It"
15:04:28 <ertes> Dirty Morphing
15:04:48 <fnurglewitz> MarcelineVQ: but... is it point free?
15:04:52 <ab9rf> too many consonants in the acronym
15:04:56 <MarcelineVQ> Even better, it's pointless
15:04:59 <ertes> you know, morphing with bottoms
15:05:01 <ab9rf> without looking like either welsh or polish
15:05:07 <ertes> sometimes tops, too
15:05:18 * xocolatl would like to buy a vowel
15:06:43 <MarcelineVQ> "Learning Modern PHP: This Book Will Burn At 423 Degrees Farenheit" /edge
15:07:00 <xocolatl> not 451°?
15:07:04 <fnurglewitz> nah
15:07:06 <MarcelineVQ> No it's value added
15:07:22 <Tuplanolla> We could've avoided this problem by naming the Haskell language Book.
15:07:32 <MarcelineVQ> by-the-by, is there anything like wordpress with haskell?
15:07:33 <fnurglewitz> "Learning Modern PHP: This Book Will Burn At T_PAAMAYIM_NEKUDOTAYIM Degrees Farenheit"
15:08:09 <sm> MarcelineVQ: how about http://hackage.haskell.org/package/clckwrks
15:08:10 <MarcelineVQ> I guess there's hakyll, allthough that requires a rebuild if you add 'posts' ne?
15:08:14 <isd> Hey all. I'm finding myself in need of http://hackage.haskell.org/package/binary-0.8.4.1/docs/src/Data.Binary.Class.html#getMany, but the function isn't exported. Right now I've just yanked it and have the code duplicated in my module, but I feel like I must be missing something... is there really no exposed version of that functionaltiy?
15:09:33 <MarcelineVQ> sm: Thanks
15:10:17 <sm> clckwrks has recent releases but I've never heard of a user, would like to know how it is
15:10:53 <ertes> i think the homepage itself is a clckwrks app
15:11:14 <ertes> http://www.clckwrks.com/
15:16:47 <acowley> isd: It looks like replicateM
15:17:03 <acowley> isd: But with a bit of care taken to evaluate things
15:19:35 <lyxia> isd: Do you need something more fine grained than the Binary instance for lists?
15:19:49 <lyxia> the get given by that instance
15:19:52 <isd> acowley: yeah, that care is rather important.
15:21:54 <isd> http://hackage.haskell.org/package/binary-0.8.4.1/docs/src/Data.Binary.Class.html#line-564
15:22:02 <isd> The list instance prefixes a length word; that's a dealbreaker
15:22:08 <isd> I have a pre-defined format I'm working with
15:22:31 <isd> Which doesn't have that
15:22:52 <acowley> In general I avoid lists if I'm in a position where seq'ing matters. But if you need lists and care about performance, you may be able to construct a "get" that forces the evaluation you need.
15:23:48 <isd> It doesn't actually have to be a list. The exact thing I'm trying to parse is this: https://capnproto.org/encoding.html#serialization-over-a-stream
15:24:17 <isd> in particular, the sequence of segment sizes. And then of course I'll need to deal with the segment themselves
15:25:20 <isd> The list ends up being an intermediate thing anyway; I end up using stuff from Data.Array when all is said and done. But the instances for those seem to have the same problem as the instance for lists (leading bounds information)
15:25:28 <acowley> Then you can use an unboxed vector
15:25:43 <acowley> And the replicateM from vector
15:27:21 <isd> acowley: thanks, this looks like it might do the trick.
15:27:42 <allenj12> what is the @ symbol in haskell? I was looking at RB Trees implementations here https://www.cs.kent.ac.uk/people/staff/smk/redblack/Untyped.hs and was wondering what that symbol ment in the context of the insert function
15:28:04 <acowley> It's a way of binding a name to a sub-pattern
15:28:13 <glguy> allenj12: It's an "as-pattern"
15:28:29 <glguy> allenj12: Page 29 https://www.haskell.org/definition/haskell2010.pdf
15:28:30 <acowley> e.g. let pair@(x,y) in fst pair == x
15:28:52 <allenj12> oo gatcha thanks for the link and description
15:36:32 <dazednconfused> hi room
15:36:43 <Koterpillar> hi participant
15:37:01 <puregreen> let the experiment begin
15:37:34 <dazednconfused> can some give me a really simple explanation of the Maybe and Either type constructors? I'm going through "Learn you a Haskell.." and I don't understand it
15:37:54 <dazednconfused> something with a code snippet would be great
15:38:53 <lyxia> Maybe is typically used as the result type of functions that can fail on certain inputs.
15:38:57 <pikajude> > Right 3
15:39:00 <lambdabot>  Right 3
15:39:04 <zizai[m]> how they're constructed or how they're used?
15:41:58 <lyxia> You construct a value of type Maybe a either as the constructor Nothing, or Just applied to a value x of type a: Just x.
15:42:54 <dazednconfused> I don't understand how and where I'd want to use Maybe
15:43:01 * hackagebot vty-menu 0.0.4 - A lib for displaying a menu and getting a selection using VTY  https://hackage.haskell.org/package/vty-menu-0.0.4 (TimothyHobbs)
15:43:03 * hackagebot llvm-pretty-bc-parser 0.3.0.0 - LLVM bitcode parsing library  https://hackage.haskell.org/package/llvm-pretty-bc-parser-0.3.0.0 (TrevorElliott)
15:43:20 <Koterpillar> dazednconfused: is there a language you're more familiar with than Haskell?
15:43:35 <dazednconfused> I know a bit of Ruby
15:43:48 <pikajude> dazednconfused: where you'd have something that might be nil in other languages, you use Maybe
15:44:13 <Koterpillar> OK, let's say you want a function that searches for a substring. In Ruby, it returns a zero-based index of a match, or -1 if it wasn't there
15:44:25 <pikajude> :t elemIndex
15:44:26 <lambdabot> Eq a => a -> [a] -> Maybe Int
15:44:35 <Koterpillar> some careless person can forget about -1 and write something that crashes
15:44:56 <Koterpillar> but see the type above - you either get a Just 2, or Nothing, and you are forced to consider both cases
15:45:41 <dazednconfused> Ok makes sense. Can you give me a small trivial function as an example?
15:45:54 <zizai[m]> or you're lazy and just write fromJust everywhere and it crashes anyways ;)
15:45:55 <Koterpillar> @src elemIndex
15:45:55 <lambdabot> elemIndex x = findIndex (x==)
15:46:00 <Koterpillar> oh well
15:46:06 <Koterpillar> @src findIndex
15:46:06 <lambdabot> findIndex p = listToMaybe . findIndices p
15:46:20 <pikajude> lol
15:46:23 <Koterpillar> dazednconfused: keep reading, there are going to be examples there
15:47:12 <Koterpillar> dazednconfused: findIndex _ [] = Nothing; findIndex a (a:_) = Just 0; findIndex x (_:xs) = ...
15:47:24 <Koterpillar> dazednconfused: exercise: write that thing that I was too lazy to
15:54:48 <tomjaguarpaw> Arguggi: Did you get an answer to your Opaleye question?  If you need help feel free to email me.  My address is in the README.
15:56:01 <Hanslo> is it wrong to think of this, <- , as somewhat of an assignment operator?
15:56:42 <dazednconfused> @Koterpillar: I still don't understand it :(
15:56:43 <lambdabot> Unknown command, try @list
15:56:56 <erisco> assignment is =, and <- is not that, so I don't know
15:57:09 <dazednconfused> @list
15:57:09 <lambdabot> What module?  Try @listmodules for some ideas.
15:57:17 <ertes> @let isqrt x = fmap fst . find ((== x) . snd) . takeWhile ((<= x) . snd) . iterate (\(r, s) -> (r + 1, s + 2*r + 1)) $ (0, 0)
15:57:19 <lambdabot>  Defined.
15:57:28 <ertes> > map isqrt [-2..]
15:57:30 <lambdabot>  [Nothing,Nothing,Just 0,Just 1,Nothing,Nothing,Just 2,Nothing,Nothing,Nothin...
15:57:34 <lyxia> Hanslo: I think it's a fair way to call it
15:58:30 <ertes> Hanslo: we usually call it binding, because "assignment" is often associated with some kind of destructive update, which doesn't happen here
15:58:30 <Hanslo> lyxia: ok, thanks. 
15:58:53 <ertes> binding is a common term for giving something a name
15:59:13 <Hanslo> ertes: ah, had a feeling there was a bit more to it. Thank you
16:00:11 <ertes> (that's why (>>=) is called the "bind" operator)
16:00:27 <Hanslo> ertes: so the contents previously stored in that variable will not necessarily be overwritten if binded instead of assigned?
16:00:56 <ertes> Hanslo: "contents previously stored in that variable" doesn't really make sense
16:01:08 <zizai[m]> dazednconfused: say you wrote a function to pick a lucky number for someone. say, sometimes you think someone's so unlucky they don't deserve a lucky number
16:01:20 <zizai[m]> dazednconfused:  how would you do this normally?
16:01:26 <ertes> you're literally just naming a result, and if you give it a name that was already in use, you're shadowing the old name
16:01:44 <dazednconfused> zizai[m]: ok
16:02:01 <ertes> Hanslo: in other words, if you write "x <- c", better don't think of the 'x' as a "memory cell"…  it's just a name
16:02:35 <Hanslo> ertes: ah, thank you! still slowly snapping out of an OOP state of mind. 
16:03:20 <dazednconfused> zizai[m]: I don't know. Am I supposed to pick it randomly from a list of numbers?
16:03:30 <ertes> Hanslo: example:  do x <- c1; x <- c2; print x  -- you're printing the result of c2, but not because you overwrite "the memory of the variable x", but because your reuse of the name 'x' made the old name go out of scope
16:03:56 <ertes> we call that "shadowing"
16:05:01 <zizai[m]> dazednconfused: the point isn't so much the logic in determining who's lucky, i'm trying to get you to reason about the return type
16:05:59 <zizai[m]> say if a person is lucky, you want to return their lucky number
16:06:03 <zizai[m]> but if a person isn't, what do you return?
16:06:12 <dazednconfused> and if they're unlucky i return a Nothing?
16:06:34 <zizai[m]> exactly
16:06:56 <ertes> dazednconfused: the integer square root function i wrote above is an example use of Maybe
16:07:00 <ertes> > isqrt 0
16:07:02 <lambdabot>  Just 0
16:07:03 <ertes> > isqrt 1
16:07:05 <lambdabot>  Just 1
16:07:06 <ertes> > isqrt 2
16:07:08 <lambdabot>  Nothing
16:07:44 <ertes> it's a bad idea to pick some "extra" number as the failure result, most notably because in this case every integer is actually a valid square root
16:08:08 <ertes> (isqrt 2 = -1) would be a terrible idea, because (-1) is an actual square root, namely of 1
16:08:39 <ertes> in haskell we prefer to have an explicit failure wrapper, and that's what Maybe is
16:10:11 <zizai[m]> dazednconfused: so wheverever you'd call the getLuckyNUmber method, you'd check if it's Just something, or Nothing
16:10:35 <dazednconfused> if a function such as elemIndex returns a value Just 2 or Just 3 or Nothing, how can use the return value? Let's say to print a msg "element found at 2" or "element not found"
16:11:25 <Koterpillar> > case (Just 2) of Just x -> "element found at " ++ show x; Nothing -> "element not found"
16:11:27 <lambdabot>  "element found at 2"
16:11:31 <Koterpillar> > case Nothing of Just x -> "element found at " ++ show x; Nothing -> "element not found"
16:11:33 <lambdabot>  "element not found"
16:11:56 <Koterpillar> and you can't do a careless thing and ignore it
16:12:00 <Koterpillar> > (Just 2) + 1
16:12:02 <lambdabot>  error:
16:12:02 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M469813451819...
16:12:02 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
16:12:07 <Koterpillar> > Nothing + 1
16:12:09 <lambdabot>  error:
16:12:09 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M589576172073...
16:12:09 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
16:12:30 <Koterpillar> > (Just 2) + (1 :: Int)
16:12:32 <lambdabot>  error:
16:12:32 <lambdabot>      • Couldn't match expected type ‘Maybe a’ with actual type ‘Int’
16:12:32 <lambdabot>      • In the second argument of ‘(+)’, namely ‘(1 :: Int)’
16:12:39 <Koterpillar> > Nothing + (1 :: Int)
16:12:41 <lambdabot>  error:
16:12:41 <lambdabot>      • Couldn't match expected type ‘Maybe a’ with actual type ‘Int’
16:12:41 <lambdabot>      • In the second argument of ‘(+)’, namely ‘(1 :: Int)’
16:12:55 <Koterpillar> because what's Nothing + 1 anyway?
16:13:02 <dazednconfused> Either I have a short term memory loss or the book hasn't covered across -> yet
16:13:28 <dazednconfused> i haven't seen -> yet
16:13:31 <Koterpillar> dazednconfused: it's a case statement, like switch in Ruby
16:15:07 <Cale> Just to be picky, it's a case *expression* here :)
16:15:30 <Cale> (i.e. the whole thing always evaluates to a value)
16:15:47 <Koterpillar> yes, sorry
16:17:50 <ertes> dazednconfused: the 'maybe' function is worth knowing
16:18:06 <ertes> > maybe "(none)" show (Just 5 :: Maybe Integer)
16:18:08 <lambdabot>  "5"
16:18:13 <ertes> > maybe "(none)" show (Nothing :: Maybe Integer)
16:18:14 <lambdabot>  "(none)"
16:18:34 <ertes> it's the case expression in disguise, but usually more convenient
16:18:56 <erisco> less noisy
16:19:09 <erisco> and is a function, rather than a... thing
16:19:25 <ertes> more churchy =)
16:19:40 <ertes> or scottily =)
16:19:49 <dazednconfused> just realized that the book had covered case in the same chapter as pattern matching and guards but i couldn't remember it
16:20:27 <zizai[m]> dazednconfused: and back to your original question, Either is very similar, however, is useful when you want the Nothing to actually be something
16:21:47 <zizai[m]> ie, the lucky number function returns a number for lucky people, but returns a string explaining why they're not lucky otherwise
16:24:47 <dazednconfused> understood
16:24:51 <dazednconfused> thanks guys
16:57:51 <hololeap> I'm trying to do this challenge: https://www.hackerrank.com/challenges/fp-hello-world-n-times | here is my code: https://dpaste.de/byDR | and here is the error: https://dpaste.de/6mLm
16:59:25 <Koterpillar> hololeap: the type of hello_worlds is wrong, it should take an Int
16:59:59 <hololeap> what? it says right there: "n <- readLn :: IO Int"
17:00:15 <Axman6> that says that readLn has type IO Int, but n has type Int
17:00:26 <hololeap> oh, damn
17:00:38 <hololeap> confusing
17:00:46 <Axman6> that desugars to (readLn :: IO Int) >>= \n -> hello_worlds n
17:02:02 <Malkrith> What does >>= do>
17:02:03 <Malkrith> ?
17:02:09 <Axman6> :t (>>=)
17:02:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:02:15 <Axman6> it's monadic bind
17:02:36 <Axman6> it's how you sequence monadic actions, my taking the results of one and passing them onto others
17:03:21 <Malkrith> It returns monad a from (a from monad b) from monad b
17:03:22 <Malkrith> ?
17:03:42 <Axman6> well, that's its type, yes
17:03:54 <Koterpillar> no, the other way around 
17:03:55 <Malkrith> Alright
17:03:59 <Axman6> :t (>>=) `asAppliedTo` Nothing
17:04:00 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
17:04:05 <Koterpillar> monad a to (a to monad b) to monad b
17:04:07 <Axman6> :t (>>=) `asAppliedTo` []
17:04:08 <lambdabot> [a] -> (a -> [b]) -> [b]
17:04:13 <Malkrith> Monad b from (monad b to a) from monad a?
17:04:20 <Axman6> :t (>>=) `asAppliedTo` (Left "")
17:04:22 <lambdabot> Either [Char] a -> (a -> Either [Char] b) -> Either [Char] b
17:04:55 <hololeap> ok, i got the challenge correct. thanks
17:04:55 <Malkrith> I am not actually sure what a monad is so this is a bit confusing
17:05:04 <Malkrith> But I kind of see what it is doing
17:05:24 <Axman6> > Just 7 >>= \n -> Just (n+n)
17:05:26 <lambdabot>  Just 14
17:05:32 <Axman6> > Nothing >>= \n -> Just (n+n)
17:05:34 <lambdabot>  Nothing
17:05:40 <Axman6> > Just 7 >>= \n -> Nothing
17:05:42 <lambdabot>  Nothing
17:05:51 <hololeap> yeah, Maybe is the simplist monad. if you can figure it out you will know how monads work
17:06:12 <Zekka> (well, you will know how Maybe works)
17:06:14 <Malkrith> So it takes (this) and applies it to (some monad)?
17:06:28 <Axman6> what is (this)?
17:06:33 <Zekka> Malkrith: You might have some success if you try writing >>= yourself
17:06:41 <Zekka> see if you can reverse-engineer how it works for Maybe
17:06:45 <Zekka> (it's different for each monad type)
17:06:52 <Axman6> A monad is just something which you can implement (>>=) for which abeys the monad laws
17:07:48 <Malkrith> So `Maybe 4` is applied to the function \n -> Maybe (n + n) in this case?
17:08:27 <Malkrith> What are the monad laws?
17:08:27 <Koterpillar> it's >>='ed 
17:08:27 <Koterpillar> ("kind of")
17:08:43 <hascules> Malkrith, a Monad is just a datatype which takes an argument which you can join together. (>>=) maps a function which creates a Monad over the contents of a monad and then joins the result together, like concatMap, but over a type more general than list, a Monad.
17:08:53 <hascules> :t concatMap
17:08:54 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
17:09:15 <hololeap> Malkrith: these helped me: https://bartoszmilewski.com/2011/01/09/monads-for-the-curious-programmer-part-1/ http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
17:09:23 <Koterpillar> https://wiki.haskell.org/Monad_laws
17:09:23 <Malkrith> Is there any canonical pronunciation of >>=?
17:09:30 <Zekka> yeah, "bind"
17:10:11 <hascules> Im struggling trying to write 'data F f a = F (f  (F f a)) | F0' and 'data G a = G ((F G) a)' in one line, can anyone help?
17:11:16 <napping> put a ;
17:11:27 <Zekka> hm, do you mean in one data decl?
17:11:41 <hascules> I mean I want to inline the definition of F into that of G
17:11:49 <napping> you can't
17:11:52 <hascules> Yes Zekka
17:12:06 <hascules> Oh dear, I can't understand why
17:12:30 <Malkrith> Hololeap
17:12:46 <Malkrith> The first blog is clearing up so many things
17:12:46 <Malkrith> x.x
17:12:46 <napping> well, you can't get exactly the same constructors
17:13:42 <hascules> Would it be possible with 'data F f a = F (f (F f a))'
17:13:51 <hascules> ?
17:14:44 <hascules> I mean, is the problem the | ?
17:15:10 <hascules> Or the 2 recursions?
17:15:12 <napping> I thought both were recursive, but they are not, so maybe it can work
17:15:13 <ertes> Malkrith: look at the type signature of (>>=), then substitute all the monads you know for 'm' and guess what the resulting function might be doing
17:15:24 <ertes> (>>=) :: IO a -> (a -> IO b) -> IO b
17:15:28 <Zekka> I think it can be done but I'm not clear yet on how
17:15:30 <Zekka> it's hairy
17:15:31 <ertes> (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
17:15:33 <ertes> etc.
17:15:56 <hascules> They are both recursive
17:16:17 <hascules> Is that the problem?
17:16:38 <Malkrith> I am not yet to monads in the blog
17:16:39 <napping> data G a = G ((F G) a  doesn't directly have a G
17:16:55 <napping> not a value made directly from G anyway
17:17:12 <Malkrith> I am at morphisms and functors 
17:17:13 <Axman6> (it should probably also be a newtype)
17:17:14 <Koterpillar> you can't inline G
17:17:21 <hascules> You mean because it could be F0?
17:17:23 <Koterpillar> and you can't inline F
17:17:24 <ertes> Malkrith: sometimes it helps to look at the flipped version of (>>=) called (=<<), because its type may have a more familiar shape for many monads
17:17:26 <napping> If you don't need the constructor G, then G a is basically a synonym for F G a
17:17:41 <Koterpillar> because they are both referenced
17:17:59 <hascules> Malkrith, Functor ftw!
17:18:01 <Zekka> (=<<) may look similar to fmap or (<*>) to you, if you squint
17:18:10 <Zekka> if it doesn't, that's cool, keep trying stuff
17:18:38 <napping> hascules: is data FG a = F (FG (FG a)) | F0 right?
17:18:40 <hascules> Koterpillar, that makes sense
17:19:11 <napping> there's nothing wrong with just defining two types, but I think that's equivalent?
17:19:14 <hascules> Yes napping, that's what I'm trying to show
17:19:29 <hascules> It collapses I think
17:19:41 <hascules> G = F
17:20:07 <Malkrith> I think I need to rest from this maths for today x.x
17:20:37 <richarddwi> Hi all, I'm working with the UI.NCurses library and I've defined a new color, but when I try to use it with setColor in another function, it's complaining that ColorID =/= Curses ColorID, and I'm not sure what that even means  
17:21:03 <ertes> Malkrith: sure, but keep in mind that you can understand monads as a programmer…  for starters it's little more than just an API with a certain contract
17:21:13 <Axman6> richarddwi: you'll need to share the code for us to be able to begin to help
17:21:20 <napping> hascules: whats the objective here?
17:21:25 <hascules> A guess maybe just return the Color
17:21:26 <Malkrith> I was never good at maths
17:21:35 <ertes> Malkrith: me neither =)
17:21:48 <geekosaur> @paste code, richarddwi?
17:21:48 <lambdabot> Haskell pastebin: http://lpaste.net/
17:22:07 <dmwit> hascules: I think the inlining is `data Nat = Z | S Nat`.
17:22:25 <hascules> I came up with that expression while reducing another but didn't know if that last equivalence was true
17:22:49 <richarddwi> geekosaur, Axman6: http://lpaste.net/254966
17:22:57 <geekosaur> however, since defining a color pair requires calling out to curses, I suspect you needed <- but used let
17:23:03 <hascules> dmwit, an I right in thinking you mean that it will not terminate?
17:23:13 <dmwit> hascules: What is "it"?
17:23:39 <Axman6> what's the type of colorOn and newColorID?
17:24:21 <richarddwi> newColorID is Color -> Color -> Integer -> Curses ColorID
17:24:29 <Axman6> looks like you need to use onID <- newColorID ...; offID <- newColorId ...; let clockState = ClockState {colorOn = onID; colorOff = offID}
17:24:31 <Malkrith> So... I am kinda stumbling into this
17:24:31 <Malkrith> So functors map types to each other? 
17:24:31 <Malkrith> Like A -> F(A) -> F(F) -> F(B) -> B
17:24:31 <Malkrith> Or I guess just F(A) -> F(B)
17:24:37 <geekosaur> heh, that'd be the opposite problem. you don't want to store a Curses ColorID, just a ColorID
17:25:03 <geekosaur> but doing so as an action in the Curses monad
17:25:09 <hascules> Your version had no parameter of kind * ('a'), nvm I got confused
17:25:15 <ertes> Malkrith: haskell functors are always two things:  a type constructor (like Maybe) together with a function fmap
17:25:23 <napping> hascules: a is never actually used in the definition
17:25:37 <Axman6> Malkrith: yes, Functors let you take 'ordinary' functions a -> b and turn them into functions on some type F, F a -> F b
17:25:47 <hascules> Oh dear, F0 a
17:25:49 <dmwit> hascules: Your parameter `a` is never used anyway.
17:25:56 <richarddwi> so, doing it the way I was doing it, I'm actually storing the monad itself?
17:25:58 <hascules> Pardon me
17:25:58 <ertes> Malkrith: the type constructor maps types to types (Maybe is of kind * -> *, so if you apply it to a type (like Int), you get another type (like Maybe Int))
17:26:02 <napping> oh, that's not going to collapse all the way to Nat
17:26:07 <Axman6> richarddwi: "yes"
17:26:14 <Malkrith> Wow
17:26:19 <Malkrith> So I got something right?
17:26:21 <geekosaur> you're storing the action to define a color, more precisely
17:26:27 <Axman6> richarddwi: that's a slightly strange way to put it, but I think you have the right intuition
17:27:08 <Axman6> it's the difference between an Int and an IO Int, and IO Int isn't a number, it's an action which can produce a number
17:27:25 <richarddwi> oh man, that's actually pretty funny
17:27:28 <ertes> Malkrith: to elaborate on what Axman6 said:  fmap :: (a -> b) -> (F a -> F b)  -- it takes an (a -> b) and turns it into an (f a -> f b)
17:27:53 <dmwit> hascules: Doesn't change much. Just `data NatWith a = Z a | S (NatWith a)`.
17:28:03 <Malkrith> Haskell is lazy so it won't calculate the value of IO Int until you request it's value right?
17:28:09 <napping> dmwit: I think the nested recursion is more than that
17:28:32 <ertes> Malkrith: yes, but note that the value of type (IO Int) is an action
17:28:35 <ertes> not an integer
17:29:43 <Malkrith> I know it isn't
17:29:43 <Malkrith> But it won't perform the action unless it needs to 
17:29:43 <Malkrith> So you won't get an integer until you request one out of it 
17:29:43 <richarddwi> So then, do I need to also move my let clockState ... out of main $ runCurses...? It's not liking my <- in colorOn <- newColorID...
17:29:47 <Malkrith> And then IO Int -> Int right?
17:29:53 <Malkrith> Or is it Int -> IO Int
17:30:06 <Axman6> richarddwi: you'll probably need a do block
17:30:06 <hascules> @let data F f a = F (f  (F f a)) |  F0 a
17:30:08 <lambdabot>  Defined.
17:30:22 <Koterpillar> Malkrith: Haskell as a language doesn't "perform" actions
17:30:24 <koz_> hascules: That's the free monad, no?
17:30:24 <ertes> Malkrith: do x <- fmap read getLine; putStrLn "point 1"; print (x :: Integer); putStrLn "point 2"
17:30:38 <hascules> @let data G a = G ((F G) a)
17:30:39 <lambdabot>  Defined.
17:30:44 <Axman6> runCurses $ do onID <- ...; offID <- ...; let clockstate = ...; eventLoop clockState 0 0
17:30:50 <Koterpillar> it defines a main function the result of which is an action, and the program, when run, performs that action
17:30:51 <Malkrith> What does it do with IO Int then?
17:31:01 <hascules> Yeah koz_ it is, but is G?
17:31:10 <ertes> Malkrith: when you run this, the action (fmap read getLine) will be evaluated, then the resulting action is executed, but the result value will *not* be calculated yet (it's still an unparsed string)
17:31:18 <koz_> hascules: I dunno - I just saw it and was like 'zomg, free monad!'.
17:31:20 <ertes> Malkrith: after point 1, no parsing has occurred
17:31:29 <ertes> Malkrith: after point 2, parsing will have occurred
17:31:36 <Axman6> Malkrith: you can thing of IO as a recipe for actions which need to be performed, which is passed to the runtime system to actually do the IO that's needed
17:31:39 <Malkrith> I understand that
17:31:54 <koz_> Also, I am sad that pretty still uses String instead of Text...
17:32:02 <richarddwi> Axman6: so does the <- always have to be in the immediate scope of the do block then?
17:32:14 <Malkrith> And I see Axman6 
17:32:26 <Malkrith> So the language only writes recipes that the runtime executes?
17:32:26 <Axman6> richarddwi: it's syntax which can only be used in a do block
17:32:37 <Axman6> Malkrith: yes, you can think of it that way
17:32:48 <ertes> Malkrith: a good way to get a deeper understanding of how laziness and IO interact is by using 'undefined'
17:32:53 <richarddwi> and the constructor isn't considered in the do block even though it's nested under it?
17:33:02 <hascules> I was reasoning using pencil and paper so I shortened it, and I kept running into types with basecase, so I wrote with 0 suffix.
17:33:06 <ertes> Malkrith: (undefined :: IO Integer)  -- running this action will crash
17:33:16 <ertes> Malkrith: (pure undefined :: IO Integer)  -- running this action will not crash, but printing the resulting integer will
17:33:25 <Axman6> richarddwi: what do you mean? let statements are prefectly valid in do blocks (and don't need the 'in' keyword when used in a do block)
17:34:09 <Malkrith> I heard kind of not great things about haskell chats and how they tend to use complicated terms and talk down on people that dont know them 
17:34:09 <Malkrith> But y'all have been really helpful
17:34:09 <Malkrith> And I appreciate it a lot
17:34:19 <dmwit> napping: I don't think it does. It just makes the "type tag" on the deeply nested `C (A (C (A (C (A ...))))` chains big.
17:34:22 <ertes> (pure (Just undefined) :: IO (Maybe Integer))  -- even pattern-matching and finding the Just will not crash, but trying to print the innermost Integer will
17:34:31 <Axman6> richarddwi: see the annotation on the paste: http://lpaste.net/254966
17:34:57 <hascules> Oh, so G is NatWith, sorry. Ok. Thanks
17:35:05 <Malkrith> Why will it crash?
17:35:15 <Malkrith> Is it because there is nothing there?
17:35:16 <richarddwi> Axman6: yeah, I'm just not sure why { colorOn <- ... } doesn't work in that case then
17:35:16 <dmwit> napping: Or, hm. Perhaps it does.
17:35:18 <ertes> Malkrith: because the Integer is 'undefined'
17:35:19 <Axman6> Malkrith: people who say that are people who fear learning
17:35:28 <ertes> Malkrith: trying to evaluate 'undefined' will always crash
17:35:28 <Axman6> richarddwi: what do you mean?
17:35:29 <Malkrith> Oh
17:35:31 <Malkrith> I thought there was some deep reason to it 
17:35:50 <koz_> evalState (modify (+1)) Axman6
17:35:57 <napping> hascules: I think it still simplifies as far as data FG a = F (FG (FG a)) | F0 a
17:35:59 <Malkrith> I guess that makes sense
17:36:05 <richarddwi> Axman6:  let clockState = ClockState { colorOn <- newColorId ColorWhite ColorBlack 0,
17:36:08 <ertes> Malkrith: BTW, by "crash" i mean something very specific:  something that never *results*…  an infinite loop is a "crash" in that sense
17:36:08 <Axman6> Malkrith: some people find language which they don't immediately understand as elitist
17:36:15 <Axman6> richarddwi: yes, that's not valid syntax
17:36:27 <Malkrith> I really want to learn haskell 
17:36:43 <Malkrith> So I am trying to wrap my mind around these things which seem really complicated 
17:36:43 <koz_> Axman6: This appears relevant: http://www.stephendiehl.com/posts/abstraction.html
17:36:49 <Malkrith> But kind of aren't that hard
17:36:52 <hascules> napping, is that different to F?
17:36:53 <richarddwi> is the data constructor not considered in the do block then?
17:37:18 <Malkrith> So evaluating undefined will result in a never ending loop?
17:37:27 <ertes> Malkrith: example: Just (let x = x in x :: Integer)  -- this is a (Maybe Integer); if you use 'case' to distinguish between Nothing and Just, everything will be fine, but if you find the Just and try to print its payload, you will crash
17:37:28 <EvanR> Malkrith: if they were complicated, people would be into them. the issue is each topic in haskell is too simple
17:37:32 <ertes> and this particular kind of "crash" is the infinite loop crash
17:37:39 <Axman6> Malkrith: The haskell community has a reputation for using language which is foreign, but they do so because it is precise and correct. We don't shy away from calling a functor a Functor, because that's ewhat it is, and using terms like "mappable" can actually hinder understanding how broad a term is (most people don't think of functions as being mappable, only datastructures, but ther definitely
17:37:45 <Axman6> are)
17:38:10 <napping> hascules: that should be ismorphic to F G under your original definitions
17:38:12 <hascules> it directs reference to abundant literature
17:38:40 <Axman6> koz_: looks handy. I've got a lot of time for anything written by Stephen, he puts in a lot of effort in his work.
17:38:42 <ertes> @let mx = Just (let x = x in x :: Integer)
17:38:43 <lambdabot>  Defined.
17:38:50 <Malkrith> Mapping functions is what functors do as well right?
17:38:56 <ertes> > case mx of Nothing -> "nothing"; Just _ -> "something"
17:38:57 <koz_> Axman6: Yeah - 'What I wish I knew' is something I wish I'd found much sooner.
17:38:58 <lambdabot>  "something"
17:39:04 <Axman6> yeah
17:39:06 <ertes> > case mx of Nothing -> "nothing"; Just x -> "something: " ++ show x
17:39:11 <lambdabot>  mueval-core: Time limit exceeded
17:39:26 <ertes> Malkrith: see what i mean?
17:39:26 <Malkrith> I see
17:39:29 <hascules> I was after G not F G...
17:39:43 <hascules> Maybe that's the problem
17:39:44 <Malkrith> I do 
17:39:44 <Malkrith> So I can use patterns to avoid this sort of crash too?
17:39:48 <Malkrith> That's handy
17:40:03 <napping> hascules: your G has only one constructor that's a wrapper around a single value of type (F G a)
17:40:33 <ertes> Malkrith: you can never *check* for such crash-values (we call those bottoms: you can't check for bottoms), but if you never ask for the value of a bottom, everything will be fine
17:40:43 <richarddwi> anyway, Axman6, geekosaur I appreciate your help
17:40:43 <ertes> > take 3 (1 : 2 : 3 : undefined)
17:40:44 <lambdabot>  [1,2,3]
17:40:48 <richarddwi> have a good day guys
17:40:53 <Malkrith> So if I am careful I can avoid it
17:40:57 <hascules> Oh, excellent!
17:41:09 <Axman6> richarddwi: hope you learnt something! =)
17:41:15 <ertes> Malkrith: the remainder of the list is bottom, but i never asked for it, because (take 3) stopped just before reaching it
17:41:20 <EvanR> Malkrith: if you use total functions, then you wont get a bottom
17:41:28 <napping> If you do care about keeping exactly the same wrapper constructors then I don't think you can simplify at all
17:41:50 <Malkrith> What is a total function?
17:41:55 <hascules> obviously
17:42:03 <johnw> Malkrith: a function that has an answer for all inputs
17:42:04 <ertes> Malkrith: a function that never produces bottoms =)
17:42:05 <EvanR> a total function is also known as a regular math function
17:42:10 <EvanR> its defined on the entire domain
17:42:20 <EvanR> "bottom" is not defined
17:42:24 <ertes> Malkrith: all the definitions you just saw are equivalent =)
17:43:26 <ertes> f False = True; f True = False  -- a total function…  given a defined argument, it gives you a defined result
17:43:43 <ertes> f False = True; f True = undefined  -- a partial function…  given the defined argument True, it gives you nothing
17:44:11 <ertes> it crashes/never answers
17:45:32 <EvanR> it hopefully crashes but could freeze up
17:45:39 <hascules> I guess I would need to apply join for them to be equivalent... I don't think I'm going to get my proof. Nvm, thanks for the help!
17:45:41 <EvanR> which is bad mmkay
17:46:21 <sm> hey all. Is there a way to keep using error for program termination, without GHC 8 showing a call stack to users ?
17:46:43 <EvanR> you could unsafePerformIO exitFailure
17:47:04 <jle`> alternatively, consider not using 'error' for program termination
17:47:23 <sm> EvanR: ah, good idea. error is pretty convenient in many quick command-line tools
17:47:58 <sm> but this does encourage me to try harder to avoid it in future
17:48:13 <pikajude> you could use errorWithoutStackTrace?
17:48:19 <pikajude> I don't think that generates a stack trace
17:48:21 <jle`> most quick command-line tools involve IO, don't they?
17:48:23 <napping> maybe catch it, maybe throw a different exception
17:48:29 <johnw> you could also redefine error
17:48:32 <EvanR> catch what?
17:48:44 <hascules> error should only be used where appropriate, ie an error, like head []
17:48:54 <EvanR> dont catch error, or you go to haskell hell
17:49:27 <ertes> sm: the proper way would be to throwIO
17:49:33 <sm> pikajude: ha! you win the quick fix award
17:49:36 <jle`> fwiw "ie, an error" is probably one of the less descriptive ways to describe situations where one would use 'error' :p
17:49:57 <pikajude> i like "unreachable" and "unimplemented" as good places for error
17:50:00 <ertes> sm: if you really need to crash, consider using 'throw' instead, which allows you to select arbitrary exception types, so you can at least use the ExitFailure exception
17:50:30 <hascules> I think if a program terminates properly it should print to stdOut using error
17:50:43 <hascules> Should not*
17:50:44 <geekosaur> I would hope it prints to stdErr
17:50:49 <sm> ertes: I'll try that too
17:50:53 <geekosaur> oh, terminates properly
17:51:33 <hascules> "Displays a message to the user"
17:52:34 <EvanR> what, if it terminates properly, clearly it prints nothing at all! ;)
17:56:23 <sm> I think usability for small-code programmers is important, and easy controlled program termination from anywhere is a good thing to support somehow
17:57:37 <sm> and I guess unsafePerformIO exitSuccess/exitFailure may be it
17:58:18 <sm> bbl o/
18:00:31 <ertes> sm: use 'throw'!
18:01:28 <ertes> sm: throw (ExitFailure 1)
18:02:14 <ertes> sm: same result, but without using a potentially unsafe API (except for the obvious non-totality)
18:03:20 <sm> ertes: I'll usually want to show stdout or stderr output too, which is a bit harder ?
18:03:35 <Koterpillar> throw a custom exception
18:03:38 <ertes> sm: make an exception type for that
18:03:49 <sm> sure, but I'm saying we should make this easy
18:04:26 <sm> ie, as easy as calling error
18:04:38 <ertes> sm: make an exception type and reuse it
18:05:08 <ertes> sm: or you can make this as simple as using 'userError' without a custom type
18:05:14 <ertes> throw (userError "Blah")
18:05:23 <ertes> that one throws an IOException
18:05:32 <sm> that's sounding good
18:06:15 <ertes> > throw (userError "blah")
18:06:17 <lambdabot>  *Exception: user error (blah)
18:06:39 <ertes> > error "blah"  -- i wonder what exception 'error' throws
18:06:41 <lambdabot>  *Exception: blah
18:06:47 <sm> we'd want full control of output, though
18:07:37 <ongy> Reminds me of the "thanks for playing" story
18:07:38 <ertes> sm: you're passing the threshold where your application is "quick-n-dirty"…  at some point you should just admit that your application needs proper error handling
18:07:51 <ertes> s/is/stops being/
18:08:51 <ertes> sm: in other words: write a proper exception handler around your application, optionally with a custom exception type that lets you decide the proper error response
18:09:37 <lordcirth> What's the difference between 'error' and 'throw' ?
18:09:47 <ertes> lordcirth: semantically?  nothing
18:09:57 <ertes> 'error' throws a specific exception type
18:10:04 <ertes> 'throw' lets you choose the exception type
18:10:08 <lordcirth> Oh I see
18:12:56 <ertes> sm: i promise you that the proper design is not any more expensive (in terms of code size) than the quicker-n-dirtier solution you're trying to find…  but it is *way* cheaper in terms of the brainpower needed to understand, because it has no semantically weird stuff like unsafePerformIO =)
18:14:19 <ertes> here is a design you might like:  data MyExit = MyExit String (IO ())
18:14:20 <sm> ertes: I don't think I agree. We shouldn't make people use unsafePerformIO, but error fills a real need and I think we can offer something as easy to use as that, and it would be smart usability engineering to do so
18:14:46 <ertes> myApp `catch` (\(MyExit msg c) -> c >> putStrLn msg)
18:15:02 <ertes> throw (MyExit "my error message" myCleanupAction)
18:15:03 <sm> but let's not argue further (and I can't, I'm out of battery :). See you o/
18:15:48 <ertes> sm: i'm not arguing…  i'm trying to save your life =P
18:17:07 <bidzapfc> Hello people
18:17:43 <benzrf> hi bidzapfc
18:17:52 <bidzapfc> how is it going?
18:19:19 <benzrf> pretty good!
18:19:27 <bidzapfc> I had no idea that freenode has >10000 channels
18:19:29 <bidzapfc> :D
18:19:47 <bidzapfc> What are you guys using for OS?
18:20:00 <benzrf> this is kind of off topic :P
18:20:16 <grantwu> Consider #haskell-offtopic
18:20:23 <benzrf> or #haskell-blah
18:20:30 <bidzapfc> sorry... :(
18:20:32 <benzrf> its ok
18:22:27 <jle`> what's a good name for a list with a maximum length?
18:22:40 <jle`> "bounded" ?  sounds like the items would be bounded, not the length
18:23:05 <bidzapfc> "overloaded"
18:23:12 <geekosaur> I would say bounded (the other is a list of bounded items)
18:23:41 <jle`> er, i to be clear, i mean the type of a list whose length is guarunteed to be below a given number
18:23:45 <geekosaur> (the other is also a bit tricky to use in haskell so not much of a conflict in reality...)
18:23:52 <jle`> hm, ok
18:24:05 <geekosaur> or bounded length list if you want to be more specific
18:24:33 <jle`> yeah, if i saw 'Bounded', it would not be immediately clear what would be the thing that is bounded
18:24:41 <ertes> jle`: let's call that type L, then L : List = Fin : Nat
18:24:43 <jle`> bounded-length is a little bit wordy
18:24:52 <ertes> jle`: with that in mind, maybe FinList?
18:24:58 <jle`> oh
18:25:02 <jle`> that's neat
18:25:28 <jle`> yeah i might go with that
18:25:39 <jle`> thanks :)
18:25:46 <ertes> you're welcome =)
18:25:57 <benzrf> jle`: wait - you mean the type itself indicates a number which inhabitants will be shorter than?
18:26:25 <jle`> well, my original question was about "type" in an abstract sense
18:26:32 <jle`> but yes
18:27:17 <benzrf> then FinList is probably bad - that just implies that the length is finite, not necessarily bounded below a *specific* number
18:27:25 <jle`> a word to describe a type whose inhabitants are list whose lengths are at most N
18:27:31 <ertes> index :: Fin n -> FinList n a -> Maybe a
18:27:43 <ertes> or ShortList
18:28:21 <jle`> benzrf: well, `Fin n` is a type that can be said to contain integers numbers that are less than n
18:28:30 <jle`> s/integers numbers/naturals
18:28:42 <Koterpillar> jle`: I think that interpretation is less natural
18:28:51 <jle`> maybe
18:29:06 <ertes> Fin itself is a slightly unfortunate name, but at least it's a common convention
18:29:08 <jle`> BoundedList is probably the best one
18:29:11 <benzrf> jle`: yeah, "Fin" indicates that the *type itself* is finite
18:29:15 <jle`> but my IDE charges me per character
18:29:24 <benzrf> :)
18:29:46 <ertes> jle`: is it *up to* n items long or exactly n items long?
18:29:51 <EvanR> Fin isnt finite...
18:30:01 <jle`> can be either
18:30:05 <jle`> ^ ertes 
18:30:33 <ertes> for any (n : Nat), Fin n is finite
18:31:05 <ertes> similarly for any (n : Nat) and finite 'a', (FinList n a) is finite, and for any 'a' it has at least finite length
18:31:53 <ertes> oh, and read ":" as "::"…  i'm in agda mode =)
18:31:53 <benzrf> at most* ?
18:32:13 <jle`> anyway, thanks for the disucssion, but i have to run :)
18:32:21 <ertes> that "at least" was in the sense: "even if it's not finite, at least its length is finite"
18:35:47 <benzrf> ah
18:37:20 <EvanR> nots not finite, its not even infinite!
18:37:29 <EvanR> !@#$
18:43:06 * hackagebot sqlite-simple-errors 0.1.0.0 - Wrapper around errors from sqlite-simple  https://hackage.haskell.org/package/sqlite-simple-errors-0.1.0.0 (jmc41493)
18:43:08 * hackagebot sqlite-simple-errors 0.2.0.0 - Wrapper around errors from sqlite-simple  https://hackage.haskell.org/package/sqlite-simple-errors-0.2.0.0 (jmc41493)
18:59:22 <hololeap> what is the point of <* and *> ?
19:00:43 <benzrf> as opposed to (>>), you mean?
19:01:02 <benzrf> that's a valid question for (*>), but it's worth noting that there's no (<<)
19:01:06 <benzrf> so (<*) is definitely useful
19:02:39 <kadoban> hololeap: To use the "side effect" of an action, but not the actual result. For example in parsers like parsec, you might do something like    string "blah" <* char ')'   to require blah) in the input text, and give the result "blah"
19:03:34 <hololeap> ok. i just noticed it in the Applicative definition
19:04:36 <ab9rf> i thought (<*) amd (*>) were variants of (<*>)
19:05:56 <kadoban> It depends on your point of view I suppose. (*>) is the same thing as (>>) for anything that's both an Applicative and Monad, for instance.
19:06:26 <kadoban> But since they're part of Applicative, they have meaning separate from Monad, in which case yeah you could see them as variants of (<*>)
19:43:07 * hackagebot sqlite-simple-errors 0.3.0.0 - Wrapper around errors from sqlite-simple  https://hackage.haskell.org/package/sqlite-simple-errors-0.3.0.0 (jmc41493)
20:01:47 <Hanslo> Can anyone breifly explain to me what this , =. , is?
20:02:08 <Koterpillar> more context, please
20:02:36 <umib0zu> Hanslo what library did you see it in?
20:03:45 <Hanslo> umib0zu: It is from Persist.Sqlite I beleive
20:05:30 <byorgey> Hanslo: and which package is that module from?
20:06:02 <Hanslo> byorgey: Database package
20:06:41 <byorgey> Hanslo: I mean what is the name of the package on Hackage?  There is no package named Database.
20:06:55 <byorgey> Hanslo: but a better question would be: where did you see this =. operator?
20:07:47 <byorgey> there is no 'standard' =. operator so it just depends on how it is defined by whatever library defined it
20:08:25 <Hanslo> Im reading a tutorial on building a Haskell API, the line is: 
20:08:58 <ezyang> @hoogle (=.) 
20:09:00 <lambdabot> Database.Persist (=.) :: forall v typ . PersistField typ => EntityField v typ -> typ -> Update v
20:09:00 <lambdabot> Data.Label.Monadic (=.) :: MonadState f m => Lens (->) f o -> (o -> o) -> m ()
20:09:00 <lambdabot> Database.Esqueleto (=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField typ) => EntityField val typ -> expr (Value typ) -> expr (Update val)
20:10:06 <Hanslo> lambdabot: ah thanks. The Database.Persist is it. 
20:11:13 <Koterpillar> they all look like they're doing the same thing
20:14:47 <Hanslo> is it safe to say that =. writes or overwrites the given type to the data base? 
20:15:22 <Koterpillar> it defines an update action
20:15:35 <Koterpillar> which you then (guessing) give to the database to execute
20:16:35 <Hanslo> Koterpillar: understood. Thank you. 
21:27:20 <ezrios> @pl (\x -> x)
21:27:20 <lambdabot> id
21:28:25 <ezrios> @pl (\f g x y -> (f x) `g` (f y))
21:28:25 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
21:39:48 <EvanR> flips and dots arent the most inspiring generating set
21:43:11 * hackagebot simple-tar 0.5.1 - Simple, pure, file-system-free reading of tar files  https://hackage.haskell.org/package/simple-tar-0.5.1 (AdamWick)
21:44:57 <Forlorn> Why doesn't, let f :: (Num a) => a; f = 1.0 :: Float, work?
21:45:36 <EvanR> because a can be anything
21:45:46 <EvanR> and your definition violates that
21:45:53 <EvanR> (a can be any Num)
21:47:07 <EvanR> you may have wanted f :: exists a . (Num a) => a
21:47:11 <Forlorn> yeah, it can be any Num, and Float is a subtype of Num, no?
21:47:25 <EvanR> it can be any num, for example Int
21:47:33 <EvanR> your definition doesnt allow that
21:47:43 <EvanR> another way to say this is, the "caller" chooses what a is
21:47:48 <kadoban> Forlorn: Whatever uses f could choose Float, but you can't choose it for them, because the type you're specifying is saying it's *any* Num.
21:48:10 <ab9rf> the implementation has to be prepared to accept any a provided that a is an instance of Num
21:48:31 <ab9rf> yours only accepts a's that are Float
21:48:54 <kadoban> This is a little confusing here because 1.0 kind of logically seems like it could be any number you want, it'd be more clear maybe if the example was something else, though nothing comes immediately to mind.
21:49:01 <EvanR> a is any type AND a = Float, is illogical ;)
21:49:18 <EvanR> just 1 would work
21:49:27 <EvanR> 1.0 will not because it requires Fractional, not Num
21:49:38 <EvanR> but 1 :: Float, or 1.0 :: Float will not work
21:50:14 <ab9rf> it takes a while to get used to the thicket of numerical types in haskell
21:50:25 <Forlorn> same for
21:50:26 <Forlorn> let f :: (Num a) => a; f = 1.0
21:50:35 <Forlorn> but for, let f :: (Num a) => a; f = 1 -- it is ok.
21:50:35 <EvanR> yes,
21:50:38 <EvanR> :t 1.0
21:50:39 <lambdabot> Fractional t => t
21:50:58 <EvanR> :t 1
21:50:59 <lambdabot> Num t => t
21:51:01 <Forlorn> 1 is a Num shared between all instances of Num?
21:51:04 <ab9rf> Forlorn: that's because the parser instantiates numeric constants with a polymorphic type
21:51:07 <tippenein> Should I be avoiding forkIO for an SQS poller running alongside my server?
21:51:14 <Forlorn> 1.0 :: Float is not shared between all instances?
21:51:18 <kadoban> :t 1
21:51:19 <lambdabot> Num t => t
21:51:51 <kadoban> Float is a single type, it's one instance of Num, yeah.
21:52:09 <ab9rf> 1.0 is shared amongst all instance of Fractional
21:52:13 <ab9rf> (which includes Float)
21:52:31 <ab9rf> :t 1.0 :: Double
21:52:32 <lambdabot> Double
21:52:51 <EvanR> :t 1.0 :: Rational
21:52:52 <lambdabot> Rational
21:53:23 <Forlorn> that's insightful, thank you
22:02:29 <dmj`> so hackage doesn't build docs for ghcjs projects right
22:05:35 <dmj`> would be nice if there was like a tab to see the ghc and ghcjs built docs :]
22:14:05 <ReinH> Forlorn: 1 :: Num a => a is basically the same as fromInteger 1
22:16:45 <ReinH> GHC uses the return type polymorphism of fromInteger to implement polymorphic integer literals
22:17:04 <ReinH> And similarly for fromRational and Floating instances
22:17:28 <ReinH> I wouldn't really call them "shared"
22:18:49 <EvanR> yeah 1.0 isnt a thing in of itself, its syntactic sugar
22:19:19 <Axman6> is it equivalent to fromRational (1%1)?
22:19:23 <Axman6> I can't remember now
22:19:27 <Axman6> :t 1.1
22:19:28 <lambdabot> Fractional t => t
22:19:30 <ReinH> On the pattern matching side, fromIntegral and (==) are used to compare polymorphic integer patterns, and similarly for polymorphic patterns with a decimal point and the Fractional and Eq typrclasses
22:19:40 <Axman6> :t fromRational
22:19:42 <lambdabot> Fractional a => Rational -> a
22:20:33 <EvanR> 3.14, is fromRational (314 / 100)
22:21:32 <EvanR> , literally Rational so... i guess %
22:22:16 <ReinH> It's just sugar for conversion using the typeclasses
22:26:20 <grantwu> quit
22:26:22 <grantwu> oops
22:26:54 <Axman6> but I don't want to :(
22:29:29 <nathyong> Is there a function that generalises the pattern do {p1 <- getP1; p2 <- getP2; p3 <- getP3; return Datatype p1 p2 p3} ?
22:30:45 <Axman6> yes, applicative functors
22:30:47 <mauke> Datatype <$> getP1 <*> getP2 <*> getP3
22:30:58 <Axman6> ^^^
22:31:35 <nathyong> oh cool
22:31:46 <nathyong> what if I want to run 'function p1 p2 p3' instead?
22:32:26 <Axman6> what type does function have?
22:32:43 <nathyong> function :: a -> b -> c -> m d
22:32:56 <erisco> then you've already wrote the answer
22:33:12 <EvanR> liftA3 Datatype p1 p2 p3
22:33:26 <Axman6> you can use join in that case: join $ function <$> getP1 <*> getP2 <*> getP3
22:33:40 <nathyong> :t join
22:33:41 <lambdabot> Monad m => m (m a) -> m a
22:33:43 <Axman6> where join :: Monad m => m (m a) -> m a
22:33:51 <nathyong> oh wait, join = (>>=)
22:34:06 <Axman6> the result of function <$> getP1 <*> getP2 <*> getP3 is m (m d) in this case
22:34:08 <erisco> :t (>>=)
22:34:08 <nathyong> no.. join is the 'concat' generalisation
22:34:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:34:10 <Axman6> not quite
22:34:28 <nathyong> okay cool
22:34:29 <Axman6> but they're somewhat equivalent, you can implement join with >>= and >>= with join
22:34:32 <nathyong> thanks for your help all
22:34:32 <Axman6> (and fmap)
22:34:43 <nathyong> yeah, >>= = join . fmap right?
22:34:54 <mauke> needs more .
22:35:15 <mauke> :t (.) (.) (.) join fmap
22:35:16 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
22:35:23 <Axman6> :(
22:35:28 <nathyong> aww
22:35:52 <mauke> :t (>>= id)
22:35:54 <lambdabot> Monad m => m (m b) -> m b
22:40:45 <nathyong> wasn't there some proposal about this that was on /r/haskell a few weeks ago
22:40:57 <nathyong> something about it being in ocaml, with lots of ! symbols
22:42:41 <EvanR> about what?
22:45:25 <Axman6> yeah I believe there was a proposal to use similar syntax to Agda, but for many reasons it's probably not a good idea
23:03:20 <johnw> you mean idris syntax?
23:03:36 <johnw> f !x   ==   x >>= f
23:04:05 <Axman6> oh was it idris? I swear there was some mention of Agda in there too
23:04:48 <ertes> that looks quite useful…  i'd actually like that
23:04:53 <johnw> me too
23:05:21 <ertes> if !(doesFileExist …) …
23:05:28 <johnw> instead of (,) <$> x <*> y, we could say (!x, !y)
23:05:58 <ertes> yeah, and if it would honour -XApplicativeDo, we wouldn't give up anything either
23:06:02 <EvanR> bang bang ... on the door baby
23:06:33 <EvanR> even more ! for your $
23:07:16 <johnw> it was mentioned to haskell-prime, but the thought is that it should appear in GHC first and be proven there
23:08:04 <EvanR> another extension pragma to add to the pile
23:08:17 <johnw> it's a good way to test extensions
23:08:39 <ertes> new extension pragmas is why i love reading the GHC release notes every single time =)
23:08:51 <EvanR> do we ever garbage collect "failed" extensions?
23:09:07 <ertes> and it's the only compiler for which the release notes are genuinely interesting
23:13:42 <Axman6> EvanR: yes pragmas have definitely been removed, as have language features, like n+k patterns
23:14:08 <EvanR> ah right
23:15:02 <ertes> were pragmas removed because they became meaningless, or were actual extensions removed?
23:15:41 <ertes> like an optional feature that used to be there, but no longer is…  even -XImpredicativeTypes is still there
23:16:05 <cocreature> iirc there was recently a discussion on ghc-devs on removing -XImpredicativeTypes
23:34:44 <ReinH> Please god yes, impredicative types longs for the sweet embrace of death.
23:44:44 <johnw> it longs to embrace itself, I think
