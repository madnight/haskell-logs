00:00:11 <bollu> @quote trump
00:00:11 <lambdabot> Riastradh says: Personally I am not at a point where the danger of NSA targetting trumps the danger of handling hydrofluoric acid for me.
00:00:15 <bollu> wtf
00:00:15 <Mibaz> bollu: except the natural transformation?
00:00:20 <ab9rf> heh
00:00:23 <bollu> Mibaz: what about it? 
00:00:30 <bollu> Mibaz: I'm not sure how to construct it
00:00:34 <ab9rf> hydrofluoric acid? 
00:00:40 <geekosaur> nasty stuff
00:00:41 <EvanR> haha
00:00:56 <ab9rf> yeah, no shit, but wow that was out of the blue
00:00:56 <geekosaur> eats through almost anything
00:01:02 <Mibaz> bollu: Nor do I. But lambdabot probably doesn't either is what I was saying.
00:01:12 <bollu> xD
00:01:13 <bollu> yeah
00:01:22 <bollu> I was just fooling with it, seing what sort of quotes it has stored
00:01:26 <ab9rf> i remember reading one of my mom's practice guides for treating various types of poisonings
00:01:27 <bollu> is there a "list of all quotes"
00:01:27 <EvanR> how its real
00:01:38 <EvanR> er, oh, its a real chemical
00:01:38 <geekosaur> hololeap, iirc Applicative has no correspondence to anything in CT.
00:01:38 <bollu> that'd be entertaining
00:01:46 <ski> @quote standard.operating.procedure
00:01:47 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
00:01:50 <bollu> geekosaur: lax monoidal functor
00:02:00 <EvanR> Applicative is a sort of monoid 
00:02:03 <ab9rf> it had a section on HF, which was basically "make the patient comfortable and call his relatives, attorney, and ask the coroner to be on standby"
00:02:03 <bollu> geekosaur: I know it exists cause I'd asked kmett once IIRC :P
00:02:04 <EvanR> like Monad
00:02:22 <geekosaur> bollu, I think that is not an exact correspondence, although it is related?
00:02:27 <bollu> geekosaur: but you need to define something called Day convolution IIRC for it to work out. I don't know the details
00:02:28 <cocreature> applicative is a monoid in the category of endofunctors with the tensor operation being day convolution
00:02:31 <ab9rf> and a brief discussion on the ethics of using "excessive painkillers"
00:02:35 <cocreature> but I always forget how day convolution works
00:02:36 <bollu> ^ that
00:02:42 <nwolverson> http://cstheory.stackexchange.com/questions/12412/explaining-applicative-functor-in-categorical-terms-monoidal-functors
00:02:56 <bollu> nwolverson: that article doesn't actually go into details
00:02:57 <cocreature> well I never really understood it I guess so I can’t claim to have forgotten it
00:03:04 <hololeap> geekosaur: it appears to be related to functors that encapsulate functions
00:03:15 <hololeap> > [odd, even] <*> [1,2,3]
00:03:16 <nwolverson> bollu: ok, made sense to me
00:03:17 <lambdabot>  [True,False,True,False,True,False]
00:03:28 <bollu> like, I started learning math because I wanted to understand what the hell an "ideal" is. I guess I'm learning category theory now to see the correspondence to applicative
00:03:41 <Mibaz> It's so hard for me to tell sarcasm apart from technical explanation with this language.
00:04:04 <Mibaz> How did you guys learn CT?
00:04:06 <EvanR> hololeap: it might be clearer if you reword Applicative as unit :: f () and fuse :: f a -> f b -> f (a,b)
00:04:10 <ab9rf> Mibaz: why do you tink there's a distinction?
00:04:13 <EvanR> which satisfy a form of monoid laws
00:04:13 <hololeap> and since Monad takes an Applicative, it would mean that it is a *part* of monads in haskell
00:04:23 <bollu> Mibaz: reading and playing around with haskell
00:04:41 <EvanR> that part im not really sure about
00:04:42 <bollu> Mibaz: I don't think it's possible to learn category theory in isolation(?) some legit math helps for examples
00:04:43 <nshepperd> iirc day convolution is (×) where you have f (a -> b) -> g a -> (f × g) b
00:04:47 <nwolverson> Mibaz: staring at the MacLane book years ago. and slowly
00:05:02 <EvanR> not sure the theoretical justification for making Applicative a prereq for Monad
00:05:06 <bollu> nwolverson: maclane expects you to know some abstract algebra and some topology
00:05:13 <nshepperd> so an applicative functor is a functor F where F × F = F
00:05:29 <ab9rf> i have basically no topology
00:05:31 <Mibaz> bollu: I would agree; can't really learn a mathematical subject without some rigor
00:05:56 <Mibaz> nwolverson: Are those textbooks?
00:06:00 <EvanR> ab9rf: so, the trivial topology
00:06:04 <ab9rf> my ex was a math grad students and i typed a lot of her papers, but that is abotu all i know about topology
00:06:12 <nshepperd> er, I don't recall how `pure` works in that framework though
00:06:36 <ski> Mibaz : "Conceptual Mathematics" by Steve Schanuel and William F. Lawvere might help with CT
00:06:55 <EvanR> i volunteer somebody in here to do a "talk" in the channel which details carefully the CT behind Applicative
00:07:00 <EvanR> like they used to do in ##math
00:07:22 <cocreature> Mibaz: awodey’s book (I think it’s just called “category theory”) is pretty good and personally I found it to be more accessible than the one from MacLane
00:07:27 <Mibaz> ski: Could I jump right into that from ~diffeq?
00:07:40 <Mibaz> ski: Or should I do some other foundational learning?
00:08:03 <ski> Mibaz : it's a pretty slow-going book, not assuming too much
00:08:50 <ski> Mibaz : basic familiarity with algebra is assumed, iirc
00:09:26 <Mibaz> ski: basic familiarity with algebra or with abstract algebra?
00:09:34 <ski> the former
00:09:48 <Mibaz> ski: excellent; I have that.
00:10:38 <nshepperd> hm, I think the identity of Day convolution is Identity, which seems obvious..
00:11:20 <Mibaz> ski: If you don't mind one more question, does this book have exercises (like I would expect in a textbook) and did you do all of them/some of them/etc.?
00:11:46 <nshepperd> edwardk explained monads and applicative functors in terms of Day convolution and Compose really well in that recent talk on discrimination/sorting
00:12:10 <nshepperd> https://www.youtube.com/watch?v=cB8DapKQz-I
00:12:45 <ski> Mibaz : iirc, it has
00:17:16 <Mibaz> How many people get to professionally develop in Haskell? Doesn't seem like there's a lot of industry using it.
00:17:30 <Mibaz> tragically
00:17:33 <ab9rf> there aren't a lot, but the ones who do do it are paid well
00:17:39 <nshepperd> ah, right, applicative functors have pure :: Identity ~> F, and <*> :: Day F F ~> F being the monoid object
00:17:59 <nshepperd> monads have return :: Identity ~> F, and join :: Compose F F ~> F
00:18:09 <hololeap> Mibaz: i think that as people start to see the benefits of hiring someone who knows haskell, it will start to take off
00:18:37 <nshepperd> where ~> is natural transformation, and i'm ignoring the unwrapping of newtype constructors etc
00:18:57 <bollu> nshepperd: what exactly is Day F F?
00:19:28 <Mibaz> hololeap: I feel like there needs to be a large succesful company that breaks the ice, too.
00:20:18 <nshepperd> bollu: data Day f g b where Day :: f (a -> b) -> g a -> Day f g b
00:20:22 <hololeap> Mibaz: there probably will be soon, especially with the language's proclivity towards big data type stuff
00:20:52 <bollu> nshepperd: wow, that seems extremely unmotivated :P where is that from? any common example of something?
00:21:01 <Mibaz> hololeap: Jet.com (being acquired by walmart $3bill or so) uses F#, I hear. Big win for functional and hopefully a good sign
00:21:59 <hololeap> i am trying to move toward functional programming as a programmer just because writing multithreaded imperitive code is so painful
00:22:11 <nshepperd> bollu: which is basically a way of combining two functor by taking a product of two functor values rather than combining them
00:22:37 <bollu> nshepperd: hm, okay, interesting
00:22:46 <nshepperd> bollu: yeah, I have no idea what a person would use Day for in practice, like as a data type lol
00:22:57 <bollu> yes, exactly
00:23:19 <hololeap> the future is definitely in thousands or millions of cores working in unison, not in maxxing out GHz
00:23:30 <nshepperd> I guess if you wanted some kind of "free" applicative
00:23:50 <Mibaz> Well Moore's law isn't going to save us anymore. So that's going to be necessary.
00:23:55 <ab9rf> well, obviously. speeds haven't moved much in the past decade
00:23:56 <nshepperd> because the point there is that the Day constructor is basically the signature of <*> from Applicative
00:24:02 <bollu> hololeap: or highly speacialized architectures
00:24:07 <bollu> hololeap: ASICs/FPGAs
00:25:09 <hololeap> fpgas are interesting, but i don't know much about them because i haven't been able to play with one. i hear there is one on the USRP though :)
00:25:26 <ab9rf> the usrp uses two fgpas iirc
00:25:39 <ab9rf> it's been a while since i looked at usrp
00:25:49 <ski> @quote We.failed
00:25:50 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
00:25:54 <hololeap> i want one soo bad, but it's kinda pricey
00:26:04 <ab9rf> i know a guy with two
00:26:25 <ab9rf> i would love a couple
00:26:32 <hololeap> i don't have $650 to burn, unfortunately
00:26:33 <ab9rf> and then i have to talk bruce into making some amplifiers for me
00:26:45 <ab9rf> since the output is like 2 W or something
00:26:53 <nshepperd> bollu: I'm sure there's a really clever use of Day in lens somewhere as just the right functor to build some combinator
00:27:23 <Mibaz> Thanks all
00:27:27 <bollu> xD I see
00:27:33 <bollu> kmett is awesome
00:27:43 <ab9rf> i know a guy who has legal limit amplifiers in every band from 80 m to 440 MHz
00:28:07 <ski> @quote I'll.use.lenses
00:28:08 <lambdabot> merijn says: If you have a problem and you think "I know, I'll use lenses!", you now have morphisms in the category of problems :P
00:28:18 <ab9rf> morphisms in the category of problems
00:28:37 <bollu> xD
00:28:45 <ab9rf> i've seen that before
00:29:14 * hackagebot hw-rankselect 0.4.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.4.0.0 (haskellworks)
00:31:29 <bollu> data Day f g a where … <- this is GADT syntax right?
00:31:38 <geekosaur> yes
00:31:58 <bollu> thanks
00:32:43 <hololeap> i was just thinking that the word "corresponds" in english is kinda like a functor
00:44:00 <nshepperd> ahah
00:44:03 <nshepperd> :t confusing
00:44:04 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
00:44:34 <nshepperd> 'Curried' there is the right adjoint of Day :>
00:44:36 <grantwu> :i confusing
00:44:37 <nshepperd> apparently
00:44:48 <grantwu> @src confusing
00:44:48 <lambdabot> Source not found. The more you drive -- the dumber you get.
00:44:55 <grantwu> I want to find where that is defined >_>
00:45:23 <nshepperd> grantwu: https://github.com/ekmett/lens/blob/6f8e5539fccca2e07a3e0b54bb0ec3364f9f3d52/src/Control/Lens/Traversal.hs#L1290
00:45:51 <ski> that's quite some lines, there
00:47:17 <sham1> It is very confusing indeed
00:47:19 <nshepperd> aside from the funny name, looks like confusing makes your traversals faster through Yoneda magic
00:47:21 <hololeap> @src help
00:47:21 <lambdabot> Source not found. Abort, Retry, Panic?
00:48:13 <ab9rf> yoneda makes me think of the world being hollow
00:48:23 <nshepperd> for Traversals foo,bar: confusing (foo.bar) = foo.bar, but with racing stripes
00:51:30 <nshepperd> but it doesn't look like Day itself is used anywhere in lens, sadly
01:00:17 <bollu> @quote tribal
01:00:17 <lambdabot> No quotes match. There are some things that I just don't know.
01:00:30 <bollu> hm, nothing
01:00:30 <bollu> @quote day
01:00:30 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
01:00:30 <lambdabot> will stab you in the back with a mantissa
01:00:47 <bollu> xD
01:00:57 <bollu> @quote maclane
01:00:57 <lambdabot> No quotes match. Just what do you think you're doing Dave?
01:01:05 <bollu> @quote yoneda
01:01:05 <lambdabot> quicksilver says: It's also the same thing as the Yoneda lemma.  That's the thing about maths. Everything is actually the same.
01:01:16 <bollu> @quote acme
01:01:16 <lambdabot> No quotes match. Maybe you made a typo?
01:01:18 <bollu> hm
01:01:20 <bollu> interesting
01:01:25 <bollu> @quote cofunctor
01:01:25 <lambdabot> No quotes match. You type like i drive.
01:01:38 <bollu> I was hoping for more "joke" quotes
01:01:40 <bollu> @quote opengl
01:01:41 <lambdabot> SimonM says: People don't seem to believe me when I say this.  In retrospect we shoulnd't have called it forkOS, we should have called it forkReallyExpensiveOnlyNecessaryForCallingOpenGL_IO.
01:01:58 <bollu> @quote frp
01:01:58 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
01:03:40 <bollu> @quote reflex
01:03:40 <lambdabot> hpc says: i am having such a silly problem, i am trying to watch "silence of the lambs", but i keep reflexively typing "silence of the lambda"
01:03:49 <bollu> @quote dom
01:03:49 <lambdabot> hpc says: if you are going to let random people from IRC into your pants, you should use protection, preferably AES or RSA
01:04:03 <bollu> @quote javascript
01:04:04 <lambdabot> sadasdf says: Javascript is awesome
01:04:27 <lyxia> you can pm lambdabot 
01:05:20 <bollu> ahh, thanks
01:16:56 <bollu> > let (><>) = ((flip ($)) (foldr ((:) . succ) [] "hs&r\US`\USehrg") $ (.) const const) in "what is this" ><> "i don't know"
01:16:58 <lambdabot>  "it's a fish"
01:17:04 <bollu> WHAT?
01:18:11 <Vyn> What
01:19:20 <sham1> what
01:19:24 <Vyn> That's clever
01:19:25 <Vyn> Haha
01:19:40 <Hafydd> > map succ "hs&r\US`\USehrg"
01:19:42 <lambdabot>  "it's a fish"
01:20:39 <grantwu> Why does Data.Bits not have bitwise not?
01:21:18 <Vyn> Or equivalently: Why does Data.Bits have bitwise ?
01:21:37 <sham1> :P
01:22:15 <grantwu> Please, this is #haskell where we use type systems backed by intuitionistic logic, we don't have double negation elimination
01:22:31 <Vyn> Okay, okay
01:22:38 <grantwu> :P
01:22:50 <grantwu> On topic, I know that we can do xor 1, but it still seems... odd
01:24:26 <sham1> It seems such an elementary thing to have
01:25:21 <sham1> Because ~x shouldn't be too bad to implement
01:26:23 <grantwu> Never mind!  It does have it
01:26:46 <sham1> Is it (~)?
01:26:51 <Vyn> It's complement
01:27:12 <Vyn> Right?
01:27:12 <grantwu> Yeah, the documentation is a bit funky
01:27:20 <grantwu> "Reverse all the bits" isn't what I was looking for so I missed it
01:27:23 <sham1> Which is what a bitwise NOT is
01:27:45 <Vyn> Okay, lemme correct: It's "complement". Right?*
01:28:52 <grantwu> "reverse all the bits" seems to me to be like... changing 00011111 to 11111000
01:29:04 <Vyn> > Data.Bits.complement 3
01:29:06 <lambdabot>  -4
01:29:34 <u-ou> PONY
01:30:06 <Vyn> That's what I meant, sham1
01:30:19 <Vyn> By the way, you can't implement ~x, can you?
01:30:32 <Vyn> How'd you implement a unary operator?
01:32:32 <sham1> Well
01:32:39 <sham1> (~) :P
01:33:27 <Vyn> Yeah, that's stupid
01:34:00 <Vyn> I don't mean your implementation is stupid
01:34:05 <Vyn> It's stupid to have to write it that way
01:34:30 <sham1> Well we already have one instance of syntax sugar
01:34:43 <sham1> Unary minus
01:34:55 <Vyn> That's fine, I don't have to write (-) 3
01:46:56 <mlife> http://lpaste.net/289150 can someone help me figure out why my last function wont work?
01:47:51 <jle`> what do you mean by won't work?
01:48:05 <jle`> does it compile?
01:48:36 <sham1> It says that it has a redundant parenthesis
01:48:48 <ongy> mlife: you ned a , between fs and ss in line 27
01:49:04 <sham1> Also, as a stylistic choice, I'd use contains as an infix
01:49:17 <sham1> So fs `contains` ss !! 0
01:49:30 <sham1> Which you could also probably replace with head now when one thinks about it
01:49:52 <sham1> so fs `contains` (head ss) or something
01:51:00 <sham1> Because it will fail for an empty ss anyway
01:52:11 <mlife> sham1: thanks, | fs 'contains' (head ss) == False = fs ++ ss
01:52:24 <sham1> ya
01:52:39 <ongy> mlife: it's ` not ' to infix the function
01:52:55 <ongy> (backtick, not apostrophe)
01:53:17 <mlife> got it, thats what I was going to ask
01:53:37 <mlife> Now like my original question was this jle : Couldn't match expected type ‘t0 a0’ with actual type ‘Int’     • In the second argument of ‘($)’, namely ‘overlap (fs, ss)’
01:53:44 <ongy> mlife: do you want remarks about style? there's other things
01:54:14 <mlife> ongy: definitely!
01:54:31 <ongy> mlife: you have the length in overlap already, so you are trying to take the length of an Int
01:56:07 <sham1> I'd probably have something like "length . head . filter (`isPrefixOf` s') $ tails s"
01:56:12 <sham1> In overlap
01:57:03 <sham1> No reason to just compose the functions there
01:57:18 <sham1> No reason to not just compose the functions...*
01:59:17 * hackagebot hablog 0.5.1 - A blog system  https://hackage.haskell.org/package/hablog-0.5.1 (gilmi)
02:01:44 <lpaste> ongy annotated “No title” with “Style remarks” at http://lpaste.net/289150#a290895
02:05:08 <mlife> ongy: thanks a lot!
02:05:14 <mlife> let me look at the differences
02:05:44 <bollu1> @protontorpedo
02:05:45 <lambdabot> does haskel work one windows?
02:05:50 <bollu1> hahaha, what?
02:06:26 <bollu> Alternative is monoid for Applicative?
02:06:59 <jle`> yeah it provides monoidal operations
02:07:01 <ongy> bollu: don't worry about protontorpedo, I have only encountered them once, but from what I was told it's a troll/spammer that comes from time to time
02:07:33 <sham1> Time to annotate some annotations
02:07:39 <jle`> bollu: <|> is associative, and it has an identity with 'empty'
02:09:08 <jle`> it's kind of arbitrary that it requires Applicative, and you could imagine a * -> * monoid typeclass without the Applicative constraint.  but Applicative is sort of more or less to give context for the some/many methods
02:10:37 <mlife> im curious, like I always see the same people answering questions here, why?
02:10:45 <mlife> or how does it work haha
02:11:12 <bollu> jle`: ah, I see
02:11:21 <bollu> mlife: there are regulars here
02:13:54 <ongy> may also be a bit of a confidence thing. It took me around a year to start answering, because I was unsure if I was right
02:14:52 <ongy> does ghc have an option to only output the first N errors?
02:15:24 <kadoban> There's a few people that are almost always here, a bit more that are here a lot, a ton that are here sometimes, etc. So you see both a lot of the same people and a lot of variety really.
02:16:20 <nshepperd1> Some of us are neither here nor there
02:16:34 <kadoban> Some of us are here but not all there
02:17:14 <bollu> the template haskell API is pretty terribly named, no?
02:18:15 <bollu> https://wiki.haskell.org/Template_Haskell <- the wiki has dead links. May I update it?
02:19:38 <nshepperd1> I don't know about terribly named. I suppose using Haskell as a metalanguage is more powerful than your usual "templates"
02:20:15 <mlife> and you guys just help because?
02:20:25 <bollu> yes. The problem is that I don't know what half of the things do, and there's nothing even described. Like, what's a Bang? I can take an educated guess that it's about strictness
02:20:32 <bollu> mlife: world domination
02:20:46 <nshepperd1> bollu: please do fix the links if you can
02:20:47 <kadoban> mlife: Boredom mostly
02:20:51 <bollu> nshepperd: on it
02:21:04 <bollu> mlife: cause it's fun, and the channel has a lot of people who like showing you cool things :P
02:21:23 <bollu> when I first came here with some problem, someone felt the urge to show me fmap . fmap as fmap fmap fmap
02:21:39 <bollu> as I think monochrom said to me, "this is idiomatic #haskell"
02:21:42 <bollu> :)
02:22:39 <jle`> i often help to procrastinate v.v
02:22:48 <bollu> uh, how do I register to haskell wiki?
02:22:55 <jle`> if you see me answering questions here it usually means that i have something important due soon
02:23:14 <bollu> mlife: like, I have so many examples of people spending hours to teach me things. I dunno, I feel like I'm here to give back, and cause teaching is fun
02:23:36 <bollu> nshepperd: how do I register to haskell wiki? where is the "edit" button or something? there's login but no register
02:24:14 <mlife> well thats impressive and as a learner rn thank yall :p
02:24:26 <nshepperd1> I have no idea sorry :)
02:24:32 <ongy> sounds a bit like OSS in general. Countless hours have gone into things I use, should give some back. Also teaching is fun to some people. And looking things up/thinking about them also helps the teacher to better understand things
02:25:27 <bollu> if I want to change the way haddock renders
02:25:27 <bollu> how do I do this?
02:26:53 <bollu> oh wow, you gotta email the freaking wiki-account-request@haskell.org for an account?
02:26:58 <bollu> why? that's ridiculous
02:27:12 <mlife> my last question of the day http://lpaste.net/290945 Im getting some types errors, but regardless of that, is the logic correct for naive function? trying to use foldr and the o 
02:27:15 <jle`> to prevent spam and vandalism maybe?
02:27:45 <bollu> jle`: but, like, who would spam a wiki of a purely functional programming language? And I really think that well, we should lower the barrier to entry as much as possible
02:28:35 <bollu> jle`: anyway to change this? make it open?
02:28:42 <bollu> jle`: I seriously doubt that there's that much vandalism
02:29:20 <jle`> mlife: just letting you know, if you're getting type errors, 95% of the time, it's from logic errors :)  in other languages, you often only get type errors from basic type mistakes, but in haskell, type errors more often indicate logic errors than "i used a string instead of an int"
02:30:29 <bollu> shot an email to haskell-cafe and the wiki
02:30:30 <jle`> a lot of people complain that getting things to typecheck in haskell is annyoing, but the reality is usually that those programs that don't typecheck are actually logic errors  -- so it's pretty neat that haskell lets you catch those at compile time instead of runtime :o
02:31:16 <jle`> the type system in haskell catches more mistakes in logic than other languages' type systems do, almost to the point that you expect most type errors to stem from logic errors, heh
02:32:11 <jle`> if i get a compile error in haskell i usually think "oh, i implemented my algorithm incorrectly" more often than "oh, i used the wrong type", like i would in other languages if i saw a compiler error :o
02:32:11 <mlife> o.O neeeeat
02:34:15 <bollu> to change haddock rendering, what do I need to edit in haddock?
02:34:20 <bollu> where does it actually build the html + css
02:34:31 <jle`> mlife: a consequence of this is that fixing type errors often fixes logic errors too
02:35:06 <sham1> Umn
02:36:28 <mlife> jle`: can you explain whats wrong with naive?
02:36:39 <mlife> in this case, 
02:36:59 <jle`> what makes you think something is wronog?
02:37:16 <sham1> Couldn't match type 'a' with 'Char' is what I get from naive
02:37:35 <pavonia> bollu: Do you mean to change the source code?
02:37:35 <jchia_> I have a MonoTraversable-related compiler error. How can I fix it? http://lpaste.net/290971
02:37:45 <bollu> pavonia: yes, where do I need to change it?
02:37:46 <sham1> It would like a [Str Char] -> Str Char
02:37:56 <jle`> mlife: it's easiest for people to help when you post the error, too :)
02:38:03 <sham1> However, because it takes anything that can be Eq'd
02:38:03 <jchia_> ghc can't deduce a certain type relationship
02:38:35 <jle`> jchia_: where are you using monotraversable methods?
02:38:36 <sham1> So basically mlife, the "" you pass to foldr makes it type error
02:38:51 <jchia_> jle: in my own module
02:38:58 <sham1> The function signature says that the function is more generic than it actually is
02:39:00 <jchia_> not sure what you mean by 'where'
02:39:00 <jle`> jchia_: to appease the compiler, you can add it it as a constraint
02:39:20 <pavonia> bollu: Somewhere in the Backend modules
02:39:21 <ertesx> mlife: you made an assumption about the types, but did not encode it in the type
02:39:27 <ertesx> mlife: you assumed a = Char
02:39:27 <jchia_> sham! why is it more generic than it really is?
02:39:30 <jle`> jchia_: ah i just don't see anything from monotraversable there ... just things from base, so it's surprising that that error would come up
02:39:36 <bollu> pavonia: cool. Is there a nice pluggable way to change the output?
02:39:40 <bollu> or will I have to slog it?
02:39:41 <ertesx> mlife: do you see where you made that assumption?  it's a bit subtle
02:39:42 <jchia_> i'm using ClassyPrelude
02:39:48 <bollu> pavonia: I want to redesign the haskell output
02:39:54 <jchia_> which includes stuff from MonoTraversible
02:40:13 <jle`> jchia_: ah
02:40:16 <sham1> Because the type signature of naive is Eq a => [Str a] -> Str a
02:40:18 <jle`> that explains it
02:40:30 <jle`> jchia_: anyways yeah you can add what you need as a constraint
02:40:31 <pavonia> bollu: I don't think so, its pretty hard-coded
02:40:39 <bollu> pavonia: damn, okay
02:40:43 <jle`> jchia_: foo :: forall t. (Traversable t, Element (t Int) ~ Int) => ...
02:40:56 <bollu> pavonia: so when I use cabal docs or whatever, which haddock does it invoke?
02:41:00 <bollu> like, if I change haddock
02:41:02 <bollu> how do I test it
02:41:08 <sham1> However, the default value passed to foldr is "", which will not work with the type signature Eq a => [Str a] -> Str a
02:41:29 <jle`> jchia_: i wonder where the Element (t Int) ~ Int constraint is being requested from
02:41:29 <pavonia> bollu: You can change the binary via some cabal flags, I presume
02:41:35 <bollu> pavonia: oh, I see
02:41:42 <jle`> jchia_: maybe it's 'toList' ? what's the type of toList ?
02:41:45 <bollu> pavonia: do you know that for a fact?
02:41:45 <ertesx> sham1: let them experience the joy of figuring out for themselves =)
02:42:10 <sham1> :P
02:42:17 <pavonia> bollu: I don't
02:42:18 <sham1> I'm also fixing some other problems with the code
02:42:34 <sham1> Like for instance some aesthetics and unused names and whatnot
02:42:50 <jchia_> jle: toList :: MonoFoldable mono => mono -> [Element mono]
02:42:56 <jchia_> jle: the ~ worked
02:43:00 <jle`> jchia_: ah yeah, that'd be the problem
02:43:14 <jchia_> it's very verbose
02:43:18 <pavonia> bollu: --with-haddock=... apparently
02:43:23 <bollu> thanks :)
02:43:25 <jchia_> no way to make ghc deduce types more intelligently?
02:43:35 <jle`> jchia_: the issue is that you're using toList as t Int -> [Element (t Int)]
02:43:42 <jle`> from the type of toList there
02:43:49 <jle`> but in general, Element (t Int) is *not* Int
02:43:58 <jle`> it can be literally anything, depending on 't'
02:44:04 <jle`> it could be Bool, or IO String
02:44:39 <jle`> jchia_: you could use toList from the Foldable typeclass in base; that would help
02:44:44 <jle`> the type signature is a lot less general
02:44:54 <jle`> it's toList :: Foldable t => t a -> [a]
02:45:34 <jle`> but toList from wherever you're getting from is much more "general", and you can't expect Element (t Int) to be Int in every case
02:45:41 <jchia_> jle: OK that seems to defeat the purpose of using ClassyPrelude
02:45:55 <jle`> not really
02:46:02 <jle`> you can use it for cases when it's useful
02:46:02 <ertesx> i feel like once in a while we should recommend newbies the Haskell Road To Logic as an introduction to haskell (dear newbies, please ignore this!)
02:46:03 <jchia_> i can use generic functions but i have to hand-hold  the compiler
02:46:08 <jle`> and use other methods from other packages for cases when they are useful
02:46:17 <jle`> it's a case-by-case basis really
02:46:48 <jle`> for example, sometimes HashMap is a better fit than Map, but that doesn't make 'containers' useless
02:46:56 <jle`> Map is nice sometimes, HashMap is nice others
02:47:30 <jchia_> to me the ideal situation is i can use the generic functions as much as possible without having to do special things like this to avoid compiler errors. it doesn't seem simpler than using the classic functions from regular Prelude
02:48:16 <mlife> "" being a is not compatible with list
02:48:17 <mlife> char
02:48:31 <ertesx> mlife: correct!
02:48:33 <sham1> Indeed
02:48:33 <jle`> jchia_: in this case, you're writing a super duper polymorphic function, so it's not crazy surprising that the compiler might need your help
02:48:47 <ertesx> mlife: [] and "" are the same value, but "" is of a less generic type
02:48:51 <jle`> jchia_: if you had written foo to work for a specific type, this wouldn't come up
02:49:12 <jchia_> jle: maybe I should have done that
02:49:26 <jle`> jchia_: you're also mixing up Traversable methods with MonoTraversable methods
02:49:29 <jle`> so the two operate a bit differently
02:49:34 <mlife> ertesx: goddammit haha I was trying the weirdest combinations with [" idk why
02:49:44 <lpaste> sham1 annotated “No title” with “Some aesthetic changes and fixes” at http://lpaste.net/290945#a290994
02:50:03 <sham1> There you go
02:50:04 <jle`> jchia_: but also, `Element f ~ Char` is kind of a non-bizarre thing when you're using monotraversable
02:50:26 <jle`> omap toUpper :: (MonoFunctor a, Element a ~ Char) => a -> a
02:50:46 <bollu> ~ forces unification?
02:51:01 <jle`> yeah, it's a constraint
02:51:18 <jchia_> jle: toList works for MonoFoldable and fmap works on Functor. Is that what you mean by 'mixing'?
02:51:33 <jle`> jchia_: if you're used to MultiParamTypeClasses/fundeps from the 'mtl' package, then you might be used to seeing the same thing in a different style
02:51:33 <mlife> sham1: thanks lots, in the o func, what does making infix mean?
02:51:53 <jle`> mptcStyleOMap toUpper :: MonoFunctor' Char a -> a -> a
02:52:20 <jle`> that'd be what omap would look like if monotraversable was written with mtl-style fundeps/mptc's instead of type families like it is now
02:52:23 <bollu> > f :: Int ~ Chat => a -> a; f = id
02:52:23 <sham1> You see how your version of o has contains and drop as prefix functions?
02:52:25 <lambdabot>  <hint>:1:26: error: parse error on input ‘;’
02:52:26 <ertesx> mlife: haskell supports infix notation for every function:  (o x y = x `o` y)
02:52:36 <jle`> jchia_: yeah, that's what i mean
02:52:43 <bollu> > f = if :: Int ~ Char => a -> a
02:52:45 <lambdabot>  <hint>:1:3: error:
02:52:45 <lambdabot>      parse error on input ‘=’
02:52:45 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
02:52:52 <jle`> jchia_: when you work with Functor/Traversable/Foldable, you get used to the assumption that 't Int' "contains" Int's
02:53:04 <jle`> jchia_: but monotraversable typeclasses make no such assumptions
02:53:18 <ertesx> :t (undefined :: Char ~ Int => ())
02:53:20 <lambdabot> error:
02:53:20 <lambdabot>     • Couldn't match type ‘Char’ with ‘Int’
02:53:20 <lambdabot>       Inaccessible code in
02:53:24 <jle`> so your intuition from using fmap and Traversable methods is clashing
02:53:41 <sham1> In certain cases using infix functions helps eliminating stuff like unnecessary parenthesis
02:54:04 <jle`> jchia_: but yeah, (Element a ~ Char) and things like that are common, i'd think, when using monotraversable
02:54:16 <jle`> jchia_: you can think of it as another way of saying MonadState s m => ...
02:54:33 <jle`> just using type families and ~ instead of MPTC's and fundeps
02:54:53 <jle`> in another universe, mtl might have been written as (MonadState m, StateOf m ~ s) => ...
02:55:13 <jle`> (and actually, both versions of mtl are on hackage, it's just that the MPTC/FunDeps one became more popular)
02:55:23 <ertesx> @let id' :: (a ~ b) => a -> b; id' x = x
02:55:26 <lambdabot>  Defined.
02:56:19 <ertesx> @let id'' :: (c ~ (->), a ~ b) => c a b; id'' x = x
02:56:20 <lambdabot>  Defined.
02:56:34 <jle`> jchia_: i guess my point is that when you start using monotraversable and other type-family-based libs, (Element a ~ Char) stuff will start looking mundane.  they only look weird because of ecosystem/style battles
02:57:01 <jle`> jchia_: but mtl-tf could have just as likely won over mtl-fundeps, and in an alternative universe, (Element a ~ Char) would seem as normal to you as MonadState s m
02:57:08 <jle`> and MonadState s m would be the weird thing, heh
02:57:35 <jle`> (this is assuming that you are familiar with mtl heh)
02:59:55 <ertesx> :t (\f x -> f x) :: (d ~ (->) a) => (forall c. (c ~ b) -> d c) -> d b
02:59:57 <lambdabot> error:
02:59:57 <lambdabot>     • Expected a type, but ‘c ~ b’ has kind ‘Constraint’
02:59:57 <lambdabot>     • In an expression type signature:
03:00:05 <ertesx> :t (\f x -> f x) :: (d ~ (->) a) => (forall c. (c ~ b) => d c) -> d b
03:00:07 <lambdabot> (forall c. c ~ b => a -> c) -> a -> b
03:00:46 <ertesx> sport invented: type obfuscation
03:00:55 <ertesx> or how about type golfing?
03:01:51 <bollu> ertesx: doesn't callCC take the cake for that? 
03:01:51 <sham1> oh no
03:01:53 <bollu> :t callCC
03:01:55 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
03:02:00 <bollu> damn,I wanted the general one
03:02:17 <jchia_> jle: So, maybe I should have done this instead? http://lpaste.net/291000
03:03:42 <jle`> jchia_: i think if you wanted to stay in the ecosystem, (Traversable t, Element (t Int) ~ Int) is the least dramatic way of making it work
03:04:07 <jle`> you should get used to (Element a ~ Char) as a constraint if you want to continue to write polymorphic functions in monotraversable style, anyway
03:04:07 <ertesx> bollu: does it?  i don't think i've ever used it, even though i've used ContT a lot
03:04:44 <bollu> ertesx: monochrom used it as examples for me when learning universal quantification.
03:04:54 <ertesx> bollu: you can generalise the type of callCC using a rank-3 type
03:05:02 <bollu> ertesx: yes
03:05:26 <ertesx> callCC :: (MonadCont m) => ((forall r. a -> m r) -> m a) -> m a
03:05:29 <jle`> in fact, maybe monotraversable should have type T (t a) = Element (t a) ~ a
03:05:51 <jle`> er, type T t a = Element (t a) ~ a
03:05:57 <jle`> then you could write (Traversable t, T t a) => ...
03:06:01 <ertesx> bollu: it's actually the more sensible type, but for some reason (probably history) mtl/transformers don't have it
03:06:06 <jle`> er, (Traversable t, T t Int) => ...
03:07:36 <jchia_> jle: maybe i'll write in the mono stye a bit for practice, but using it everywhere seems to make the code hard to read
03:08:24 <jle`> if you want to stay in mono-style, then yeah, you'll either have to (1) get used to (Element a ~ Char) constraints, or (2) write monomorphic functions
03:09:46 <jle`> i feel like most of the times i've used mono-traversable functions, they've been for monomorphic reasons
03:10:03 <jle`> things like omap toUpper to modify a Text
03:10:19 <jchia_> ClassyPrelude replaces the Foldable foldr with MonoFoldable foldr. Doesn't that mean if I want to import ClassyPrelude unqualified, I'll be forced to write certain functions in a mono style?
03:10:44 <jchia_> i don't think foldr is the only function that got changed to use the mono type classes
03:10:59 <jle`> i think it changes all of the Foldable methods
03:11:17 <jle`> if you use them monomorphically, all of the normal Foldable methods can be replaed with MonoFoldable methods
03:11:30 <jle`> (the same can't be said for Functor/Traversable)
03:12:04 <jle`> it's just when you use them polymorphically like you did here that you have to tell the compiler to expect (Element (t Int) ~ Int)
03:12:19 <jle`> because Element (t Int) is not Int, in general
03:13:01 <jchia_> so, is it fair to say that using ClassyPrelude as a replacement Prelude (importing it unqualified) forces you to either write your functions in the mono style or import and use the standard functions from places like Data.Foldable?
03:13:48 <jle`> well, yeah, classyprelude replaces everything with monotraversable mechinery when possible
03:14:08 <jle`> monotraversable was actually invented for classy prelude
03:14:15 <jchia_> do you know how i can easily get a list of functions that got replaced with the mono version?
03:15:37 <jle`> i noticed this list here -- http://hackage.haskell.org/package/mono-traversable-1.0.0.1/docs/Data-MonoTraversable-Unprefixed.html
03:15:57 <jle`> those are all the functions that can work as "drop in replacements" for their normal-Prelude counterparts
03:16:29 <jle`> so those are the cases where you *can* replace the normal-Prelude functions with mono-traversable functions
03:18:16 <jchia_> these functions can lead to the type of compiler problem encountered just now, so maybe it'll help to make a module containing their regular counter part. then one can just import that module qualified (e.g. import RegularPrelude as R) and use the regular function like this: R.toList R.foldr
03:19:25 <jchia_> well, i take that back
03:19:37 <jchia_> it sems that they are all from Data.Foldable
03:20:53 <jchia_> almost all
03:20:58 <jchia_> foldM is from Control.Monad
03:22:13 <jchia_> and intercalate doesn't have a typeclass version
03:37:32 <kuribas> hi, Vector.cons is O(n).  However when it fuses, can it become O(1)?
03:39:12 <bollu> ski: ping
03:39:14 <mettekou> In interpreted languages commonly used for server-side web development such as PHP, JavaScript, Ruby... source code lives on the server. This makes it easier for third parties to develop plug-ins for content management systems such as Drupal. Is there an approach to this in Haskell in particular or compiled languages in general?
03:40:20 <kuribas> mettekou: don't you mean easier to deploy, rather than easier to develop?
03:40:41 <kuribas> I don't think haskell is harder to develop...
03:40:53 <sham1> >server-side
03:40:55 <sham1> >javascript
03:40:56 <sham1> Pick one
03:41:03 <zomg> mettekou: recompiling with plugins enabled, or providing some interface to which plugins are written and compiled to, which can be dynamically linked at runtime
03:41:52 * ski looks at bollu
03:41:58 <bollu> ski: ping
03:42:03 <zomg> sham1: I picked both and it works for me ¯\_(ツ)_/¯
03:42:05 <bollu> ski: it doesn't let me reply to you in PM
03:42:13 <bollu> ski: it says "security breached"
03:42:30 <ski> (oh, that's just an away message)
03:42:34 <bollu> ah
03:42:46 <bollu> interseting
03:42:50 <bollu> ski: don't know ends yet though
03:42:59 <bollu> all I know is that you use a little integral to write it :P
03:43:05 * ski aren't that familiar with them, either
03:45:07 <ski> i just wanted you to realize the correspondence to the quantifiers in Haskell types, `Nat(Hom(X, -), g)' being `(x ->) ~> g', which is `forall y. (x -> y) -> g y'
03:45:56 <ski> (`type f ~> g = forall a. f a -> g a' defining `(~>)' corresponding to `Nat')
03:46:09 <bollu> right
03:46:31 <lpaste> bollu pasted “yoneda-too-easy-in-hask?” at http://lpaste.net/291107
03:46:35 <bollu> http://lpaste.net/291107
03:46:37 <bollu> is that it?
03:46:40 <bollu> yoneda lemma
03:47:06 <ski> that's one direction
03:47:23 <bollu> oh hm right
03:47:24 <ski> there's also the other direction, and the proof that they are inverses of each other
03:47:28 <bollu> let me quickly do the other
03:48:06 <bollu> ski: can I derive that using equiational reasoning?
03:48:24 <ski> at least in one direction, iirc
03:48:27 <ski> as you can see, we're playing with the type of `fmap'
03:48:31 <bollu> yes
03:48:45 <ski>   fmap :: Functor f => (a -> b) -> (f a -> f b)
03:49:00 <ski> pick a particular `f', satisfying `Functor f', and we have
03:49:11 <ski>   forall a b. (a -> b) -> (f a -> f b)
03:49:22 <ski>   forall a b. f a -> (a -> b) -> f b
03:49:32 <ski>   forall a. f a -> (forall b. (a -> b) -> f b)
03:49:35 <bollu> now we "push" one of the forall's inside
03:49:37 <bollu> yeah
03:49:40 <bollu> that's really.. weird
03:49:41 <ski>   forall a. f a -> Yoneda f a
03:49:46 <ski> and, for the other
03:49:51 <ski>   forall a b. (a -> b) -> (f a -> f b)
03:50:04 <ski>   forall a b. (a -> b,f a) -> f b
03:50:12 <ski>   forall b. (exists a. (a -> b,f a)) -> f b
03:50:20 <ski>   forall b. CoYoneda f b -> f b
03:50:46 <bollu> ski: I still don't know how to encode exists a. using forall a. in Haskell. that correspondence always confuses me
03:51:07 <ski> i don't see why you'd need to encode it, here
03:51:40 <bollu> ski: interest, to write CoYoneda in haskell
03:51:41 <ski> you just need to know that `(exists a. ..a..) -> ...' is iso to `forall a. (..a.. -> ...)' (`a' not free in `...')
03:51:56 <ski> ok, let's start with
03:52:09 <ski>   data CoYoneda f b
03:52:11 <ski>     where
03:52:28 <ski>     MkCoYoneda :: (exists a. (a -> b,f a)) -> CoYoneda f b
03:52:39 <bollu> sure
03:52:44 <ski> we rewrite the data constructor signature as
03:52:52 <ski>   MkCoYoneda :: forall a. (a -> b,f a) -> CoYoneda f b
03:52:56 <ski> and uncurry as
03:53:03 <ski>   MkCoYoneda :: forall a. (a -> b) -> f a -> CoYoneda f b
03:53:21 <ski> (changing from `exists' to `forall', as above, can also be seen as a kind of uncurrying)
03:53:24 <bollu> ski: (exists a. (a -> b,f a)) -> CoYoneda f b ~= forall a. (a -> b,f a) -> CoYoneda f b why?
03:53:27 <bollu> ski: yes, how?
03:53:33 <ski> if you want to write this with the old syntax, it becomes
03:53:51 <ski>   data CoYoneda f b = forall a. MkCoYoneda (a -> b) (f a)
03:54:10 <ski> `forall a.' there before the data constructor name, because the data constructor is polymorphic in `a'
03:54:21 <bollu> no, I'm fine with GADT syntax
03:54:35 <ski> bollu : "why?" -- because "`(exists a. ..a..) -> ...' is iso to `forall a. (..a.. -> ...)' (`a' not free in `...')"
03:54:50 <bollu> ski: yes, can you show me why that iso exists? or how that iso exists?
03:54:59 <bollu> ski: I'm guessing it comes from logic right?
03:55:06 <ski> it's a logical equivalence
03:55:08 <bollu> ski: I've been shown a proof by Cale using type theory
03:55:11 <bollu> ski: but I don't see it
03:55:31 <bollu> ski: like, what confuses me the meaning of (exists a. a ) -> .. versus forall a. (..a .. ->)
03:55:35 <ski> for concreteness, let's say we have `length :: forall a. [a] -> Int'
03:55:36 <bollu> the scoping of the exists and forall
03:55:40 <bollu> okay
03:56:23 <ski> and let's say we write `length @a :: [a] -> Int' for explicitly specalizing the polymorphic `length' to the type `a'
03:56:40 <ski> so `length @Int :: [Int] -> Int', e.g.
03:56:45 <bollu> okay
03:56:52 <bollu> (this was added in GHC 8 IIRC?)
03:56:55 <bollu> the @ syntax
03:56:59 <ski> something like that
03:57:06 <bollu> okay
03:57:19 <ski> now, we want to define `lengthPrime :: (exists a. [a]) -> Int'
03:57:37 <ski> we define it by `lengthPrime (@a,as) = length @a as'
03:58:05 <ski> where `(@a,as)' is a pair of the type `a', and a value (`as') of type `[a]'. the whole pair has type `exists a. [a]'
03:58:09 <kuribas> ok, this is weird.  I tested "V.sum $ V.enumFromN 0 100000000" against "V.sum $ V.cons 20 $ V.enumFromN 0 100000000", and the second is actually faster!
03:58:18 <bollu> okay
03:58:30 <bollu> so when we have exists a. , we actually get access to the type that exists?
03:58:35 <kuribas> 2.3 sec vs 2.05 sec.
03:58:51 <ski> hopefully you can now see that `lengthPrime' is the uncurried version of `length', if we're talking about explicitly passing type arguments around
03:59:17 <ski> bollu : not in GHC (afaik), i'm just using the syntax `(@a,as)' above to explain what conceptually happens
03:59:21 <kuribas> somehow ghc is optimising the second one better...
03:59:25 <bollu> ski: yes, I guess I can see that
03:59:29 <ski> (there is no `exists' in GHC)
04:00:01 <bollu> ski: how do you know that you are supposed to capture exists a. as a tuple?
04:00:22 <ski> bollu : anyway, since we talked about the one approach for representing `exists a. (a -> b, f a)' in Haskell, i should probably mention the other (CPS) way as well ?
04:00:37 <bollu> ski: and what would this type mean: length_exists_malformed :: exists a. [a] -> Int. length_forall_malformed :: (forall a. [a]) -> Int
04:01:12 <bollu> ski: uh, once I fully appreciate the exists/forall duality? also, CPS as in continuation passing style?
04:01:16 <ski> bollu : it's mentioned by "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)>, e.g.
04:01:20 <kuribas> I tried again with annotation on the constant, but I get the same result...
04:02:13 <ski> `length_exists_malformed :: exists a. [a] -> Int' means that there is some hidden/abstract/opaque type `a' that `length_exists_malformed' won't tell you above, such that if you pass it an argument of type `[a]', it'll return an `Int'
04:02:39 <ski> you could e.g. pass `[] :: forall a. [a]', since then also `[] :: a' for that unknown type `a'
04:03:05 <bollu> huh
04:04:04 <ski> `length_forall_malformed :: (forall a. [a]) -> Int' is not polymoprhic (either). you are required to pass it a polymorphic argument, an argument that can have type `[a]', for any type `a' that `length_forall_malformed' decides to pick (possibly many of them)
04:04:23 <ski> in this case, the only (non-bottom) value that fits would be `[] :: forall a. [a]'
04:04:30 <bollu> ski: is [] the only inhabitant of that?
04:04:30 <bollu> right
04:04:42 <ski> CPS as in Continuation-Passing Style, yes
04:04:47 <bollu> ski: hm, okay
04:04:55 <bollu> ski: I think I'm getting a better handle on things
04:04:59 <bollu> ski: okay, now onto CPS!
04:05:54 <ski> anyway, i wanted to at least mention this, because otherwise people often seem to think "i need to express `exists', so i must use an existentially quantified data type constructor"
04:06:13 <bollu> ski: ..yes? you don't? :O
04:06:37 <ski> (it's really the (type of the) data type constructor, not the data type itself, which expresses the `exists', with this encoding. often, but not always, there's just one data constructor, though)
04:07:02 <ski> bollu : right, hence people ought to also know about the other common *encoding* of `exists' in Haskell (with extensions)
04:07:12 <bollu> ski: sure, so, well, do tell :)
04:07:24 <ski> bollu : the other encoding relies on `...' being iso to `forall o. (... -> o) -> o'
04:07:55 <bollu> ski: sure, the "…" is the "rest of the computation that you turn into continuation style
04:08:08 <ski> if you have `42 :: Int', you can convert it into `(\k -> k 42) :: forall o. (Int -> o) -> o'
04:08:31 <bollu> ski: yes
04:08:36 <bollu> ski: with you so far
04:08:41 <ski> and the idea is that any (total) value of type `forall o. (Int -> o) -> o' has to be of shape `\k -> k x', for some `x :: Int'
04:08:54 <bollu> ski: right
04:09:12 <ski> because it has to produce an `o', and it can only do that by applying the argument of type `Int -> o', picking some `Int'
04:09:34 <ski> it could apply it more than once, but then it gets multiple `o's, of which one must be picked as result
04:09:43 <ski> so the others can be GCed
04:09:54 <bollu> okay, with you so far
04:09:58 <bollu> so this relates to exists..?
04:10:22 <ski> because `o' is opaque/abstract to `\k -> ..k..' here, this is the only way to produce a non-bottom value (also ignoring `seq')
04:10:25 <ski> right
04:10:33 <ski> so, we wanted to encode `exists a. ..a..'
04:10:52 <ski> we first rewrite this as `forall o. ((exists a. ..a..) -> o) -> o'
04:11:12 <bollu> okay
04:11:17 <ski> then, as `forall o. (forall a. ..a.. -> o) -> o', and that's it !
04:11:23 <bollu> this will be some $MAGIC proof, I can tell :P
04:11:40 <bollu> ski: huh
04:11:42 <ski> so instead of
04:12:17 <ski>   blah :: Foo a -> exists b. Bar a b
04:12:21 <ski> which you could encode as
04:12:29 <ski>   blah :: Foo a -> SomeBar a
04:12:31 <ski> where
04:12:45 <ski>   data SomeBar a = forall b. WrapSomeBar (Bar a b)
04:12:53 <ski> we instead encode `blah' as
04:13:10 <ski>   blahWith :: Foo a -> (forall b. Bar a b -> o) -> o
04:13:48 <bollu> ski: I find this much more intuitive
04:13:52 <bollu> the continuation encoding
04:13:56 <ski> instead of calling it like `..(blah myFoo)..', we cann it like `blahWith myFoo (\myBar -> ..myBar..)'
04:14:00 <ski> s/cann/call/
04:14:09 <bollu> ski: given the coninuation encoding, is it possible to get back the other encoding of exists?
04:14:15 <bollu> ski: I think that the way I would like to think about exists
04:14:25 <ski> this version can sometimes be a little easier to use
04:14:53 <ski> if you want to store your existential stuff in data structures, then the "existentially quantified data constructor" encoding is probably better
04:15:15 <ski> if you want to directly "unwrap" your existential as soon as you receive it, then this encoding may be better
04:15:41 <ski> bollu : `blahWith myFoo WrapSomeBar'
04:16:06 <bollu> right
04:16:24 <bollu> ski: example where I can see this in action? I think codensity uses this right?
04:17:08 <haskell382> Is this the place to come to ask for help with Haskell?
04:17:11 <ski> (also, imho, the extension `ExistentialQuantification' is a misnomer. it ought to be the name for an extension that actually lets you write `exists' (and `*>') in types .. and not just in argument types, like in LHC (?))
04:17:17 <bollu> haskell382: yes, it is
04:18:03 <ski> bollu : see `reify' at <https://hackage.haskell.org/package/reflection-2.1.2/docs/Data-Reflection.html>, e.g.
04:18:42 <ski> `reify :: forall a r. a -> (forall s. Reifies s a => Proxy s -> r) -> r' encodes the type `forall a. a -> exists s. Reifies s a *> Proxy s'
04:19:22 * hackagebot netwire-vinylglfw-examples 1.0.0 - Netwire/GLFW/VinylGL input handling demo  https://hackage.haskell.org/package/netwire-vinylglfw-examples-1.0.0 (RandKleisli)
04:19:22 <ski> bollu : codensity uses the existential data constructor encoding
04:19:27 <bollu> yes
04:19:54 <ski> bollu : btw, `CoDensity' "plays" with `(=<<)' in a similar way to what we did with `fmap' above
04:20:16 <ski>   forall a b. (a -> m b) -> (m a -> m b)
04:20:26 <ski>   forall a b. m a -> (a -> m b) -> m b
04:20:32 <ski>   forall a. m a -> (forall b. (a -> m b) -> m b)
04:20:40 <ski>   forall a. m a -> CoDensity m a
04:20:42 <ski> and
04:20:45 <ski>   forall a b. (a -> m b) -> (m a -> m b)
04:20:53 <ski>   forall a b. (a -> m b,m a) -> m b
04:21:00 <ski>   forall b. (exists a. (a -> m b,m a)) -> m b
04:21:08 <ski>   forall b. Density m b -> m b
04:21:23 <bollu> hm, interesting
04:21:35 <bollu> ski: I was shown Codensity as way to optimise fmap operations IIRC.
04:21:50 <ski> (this is a good mnemonic device to recalling how to define `Yoneda',`CoYoneda',`Density',`CoDensity', imho)
04:22:20 <ski> no, `Yoneda' and `CoYoneda' are for fusing `fmap'
04:23:08 <ski> er, sorry, i mixed up `Density' above a little bit .. that one is a comonad, so should start with the type of `(<<=)'
04:23:20 <ski>   forall a b. (w a -> b) -> (w a -> w b)
04:23:27 <ski>   forall a b. (w a -> b, w a) -> w b
04:23:35 <ski>   forall b. (exists a. (w a -> b, w a)) -> w b
04:23:43 <ski>   forall b. Density w b -> w b
04:23:44 <bollu> ski: which one? oh, the pushing foralls around
04:23:55 <ski> (that's the correct derivation for `Density')
04:24:06 <bollu> I see
04:24:10 <bollu> that is quite interesting
04:24:18 * ski doesn't know whether `exists a. (a -> m b,m a)' has a name / is useful for anything
04:24:24 <bollu> is this process of pushing forall's around common? and, well, where did it start from?
04:24:37 <ski> anyway, `CoDensity' is for fusing `(=<<)'/`(>>=)'
04:24:44 <bollu> hm
04:24:45 <bollu> right
04:24:56 <ski> (and `Density' for fusing `(<<=)'/`(=>>)')
04:25:25 <ski> well, i suppose it's related to Church encodings of data types
04:25:46 <ski> e.g. `Bool' is `forall o. o -> o -> o', and `[a]' is `forall o. (a -> o -> o) -> o -> o'
04:26:30 <bollu> ski: I've seen bool
04:26:34 <ski> not sure who first noticed that e.g. `a \/ b' could be expressed as `forall o. (a -> o) -> (b -> o) -> o', &c. for some other logical connectives
04:26:37 <bollu> ski: I've never seen list 
04:26:52 <ski> the list one is the basis for `foldr'/`build' fusion
04:26:57 <bollu> ski: how is that list?
04:27:06 <ski> @type GHC.Base.build
04:27:08 <lambdabot> (forall b. (a -> b -> b) -> b -> b) -> [a]
04:27:27 <ski> @type \as f z -> foldr f z as
04:27:29 <lambdabot> Foldable t => t a -> (a -> b -> b) -> b -> b
04:27:37 <ski> well, specialize the latter to
04:27:52 <ski>   [a] -> (forall b. (a -> b -> b) -> b -> b)
04:27:59 <ski> these two are inverses of each other
04:28:02 <ski> namely
04:28:33 <ski> hm
04:29:15 <ski> well, i was thinking i'd apply `Yoneda', but then i recalled that that doesn't work exactly for recursive datatypes
04:29:22 <ski> if we tried that we'd get
04:29:40 <ski> hmm
04:29:48 <cath_> I have a dumb filepath -> Bytestring question:  /Project/Sub/Server.hs and /Project/Sub/Frontend/Static/index.html.  With respect to Server.hs, how can I get the file path to index.html?
04:30:11 * ski probably should do this the informal way
04:30:33 <ski> `foldr' is the universal recursion operator, on lists
04:31:06 <ski> `foldr (:) []' will recover the original list, so no information is lost, by deciding to apply `foldr' to a list
04:31:20 <bollu> ski: ah, yes, I've seen the isomorphism between Foldable and ToList
04:31:25 <ski> we have an iso `[a] = 1 + a * [a]'
04:32:55 <bollu> sure
04:32:57 <bollu> oh, oh
04:32:59 <bollu> what the hell
04:33:04 <bollu> you just convert that to the type
04:33:06 <bollu> that's.. almost cheating
04:33:16 <ski> so `[a]' is `forall o. ([a] -> o) -> o' is `forall o. ((1 + a * [a]) -> o) -> o' is `forall o. ((1 -> o) * (a * [a] -> o)) -> o' is `forall o. (o * (a -> [a] -> o)) -> o' is `forall o. (a -> [a] -> o) -> o -> o'
04:33:54 <ski> however, this gets us to `forall o. (a -> [a] -> o) -> o -> o', not to `forall o. (a -> o -> o) -> o -> o', because we're only doing one unwrapping of the recursion
04:34:47 <ski> more specifically `[a]' is the type `mu r. 1 + a * r', which is the least type `r' that's iso to `1 + a * r' (least fixed point of `\r -> (1 + a * r)')
04:35:16 <ski> and now i claim that `mu r. ..r..' is iso to `forall r. (..r.. -> r) -> r'
04:35:36 <ski> (at least when `..r..' occurs (only) covariantly in `..r..')
04:36:53 <ski> we can convert a value of type `mu r. ..r..' to any result type `r' we like, provided that we can effect `..r.. -> r', iow transform the "last layer" with `r' already having replaced recursive instances of the type, to the final `r'
04:37:49 <ski> in the case of `[a]', we're converting `mu r. 1 + a * r' into `r', provided that we can convert `1 + a * r' into `r' (iow provided that we have a "base case" value of type `r', and that we can convert an `a' and an `r' into an `r' .. which is what `foldr' does)
04:44:03 <kuribas> shouldn't "V.sum $ V.cons 20 $ V.enumFromN 0 1000000" be slower than "V.sum $ V.enumFromN 0 1000000" ?
04:47:03 <ski> kuribas : perhaps both fuse ?
04:47:49 <kuribas> ski: I'd expect it to be the same...
04:47:56 <kuribas> not faster
04:48:56 <ski> hm, then i dunno
04:54:23 * hackagebot hw-rankselect-base 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-base-0.0.0.1 (haskellworks)
05:19:24 * hackagebot atom-basic 0.2.4 - Basic Atom feed construction  https://hackage.haskell.org/package/atom-basic-0.2.4 (cbaatz)
05:29:24 * hackagebot hw-rankselect-base 0.1.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-base-0.1.0.0 (haskellworks)
05:35:53 <Nalread> Hey, I know this question is not directly connected to Haskell per se, but what would be a good functional language for someone, who's looking for some change from Python (i.e. OOP)? For now I found advocates for Haskell, Clojure, Common Lisp and Scheme. Which would be considered most newbie-friendly?
05:36:43 <kritzcreek> Nalread: if you don't mind programming in the browser elm has a reputation of being very beginner friendly and easy to learn
05:37:29 <Nalread> kritzcreek: I understand it's also compiled in the browser?
05:38:17 <kritzcreek> Nalread: it's compiled on your machine into html + js + css, but it only runs in the browser so you can't do any system tasks with it.
05:38:41 <kritzcreek> if you're writing programs that read files and spawn processes that won't do it of course. in that case I'd suggest to go for haskell
05:39:19 <Nalread> kritzcreek: Hmm, I'll have to dig a little deeper then. But thanks a bunch for suggestions!
05:54:25 * hackagebot obd 0.2.0.2 - Communicate to OBD interfaces over ELM327  https://hackage.haskell.org/package/obd-0.2.0.2 (hverr)
06:03:27 <mettekou> sham1: How so, pick one?
06:03:40 <mettekou> kuribas: Yeah, I meant deploy, but you get the gist of it.
06:04:04 <sham1> Umn, care to refresh my memory?
06:04:25 <mettekou> sham1: You asked me to pick one between JavaScript and server-side.
06:04:34 <sham1> Oh yeah, that
06:04:53 <sham1> Well the thing is, even with stuff like Node, Javascript is still clearly a client-side language
06:06:23 <mettekou> Which features of JavaScript make it aimed at client-side applications to you?
06:06:44 <mettekou> Because to me it's just another general-purpose programming language.
06:07:01 <sham1> Whose main usecase is client-side scripting
06:07:25 <sham1> It was designed for adding dynamic stuff for websites
06:07:32 <mettekou> That does not exclude server-side applications or even make it especially suitable to client-side applications.
06:08:03 <sham1> Because it was designed for Netscape Navigator. It being used anywhere else than webpages was an afterthought
06:08:18 <sham1> It is not ideal, but it is the only thing we have right now
06:08:39 <sham1> Waiting for WebAsm so I can compile Haskell code into something browsers can use
06:09:47 <mettekou> I do not dispute that JavaScript was designed for use in a browser. However, it is not the case that it was designed to be specific to that problem domain. It's not PostScript.
06:10:18 <mettekou> Otherwise, something like PHP would have come out.
06:12:58 <zomg> I always found it weird how people seem to think languages can't evolve
06:13:43 <zomg> Haskell was originally a research language, and yet, here we are. But JavaScript obviously cannot evolve beyond Netscape Navigator :)
06:14:58 <mettekou> zomg: As long as it's Turing complete, people will eventually try to do everything in it.
06:15:05 <sham1> yes
06:16:10 <sham1> While JS and Haskell grew out of their respective usage domains into more of a general-purpose role
06:16:27 <sham1> Neither of them have been able to really get that stigma out of themselves
06:17:35 <zomg> I don't see that being the case.. Maybe some years ago, but recently interest in Haskell is growing quite a lot
06:18:02 <joe9> What is the proper way to putStrLn a bytestring. I get some unprintable characters. Is there  a better way of printing the bytes and the character translation?
06:18:10 <sham1> There still are a lot of people who see it as the language that only the academic types use
06:18:37 <zomg> The problem is just people who spread that kind of ideas, that Haskell is only suitable for X, or that JavaScript is only suitable for Y.
06:19:21 <sham1> joe9, I assume that the bytes you have in the bytestring are of the UTF-8 type
06:19:27 <mettekou> zomg sham1: I think JavaScript has managed to shed most of the stigma, and Haskell is shedding more and more of it too.
06:19:57 <zomg> Yeah, but it really depends on who you ask I think :)
06:20:32 <mettekou> Erlang seems to have turned its stigma of "telecom language" around to become "language with awesome concurrency primitives".
06:20:43 <sham1> While something like Node for JS and *insert a killerapp for Haskell here* have been able to make interest grow
06:20:59 <zomg> Unfortunately languages and communities tend to have a habit of compartmentalizing which grows that kind of mentality
06:20:59 <geekosaur> joe9, a bytestring is just bytes. if there is a character translation for that bytestring, you must get it from elsewhere; if that encoding does not match your needs, you must decode to Text and then re-encode.
06:21:09 <jmcarthur> I don't think I've ever heard somebody claim Haskell is only suitable for some specific X before.
06:21:19 <geekosaur> If it is actual binary data then this will not help and you will need to decide how to handle it.
06:21:20 <zomg> Where it becomes a clique and they have their own jokes like making fun of Haskell or making fun of JS
06:22:05 <geekosaur> None of this is automatic. None of it ever is; programmers have always either known what they were doing and done the conversions as needed, or just hoped the right thing would happen and blamed anything but themselves if it didn't
06:24:00 <sham1> Speaking of character encodings, what encoding does Char represent for its characters
06:24:15 <sham1> It's some Unicode, I know that much
06:24:18 <geekosaur> Char is unicode codepoints
06:24:26 * hackagebot hw-excess 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-excess-0.0.0.1 (haskellworks)
06:24:52 <sham1> And how are they laid out in the memory
06:24:58 <sham1> UTF-8, 16, 32?
06:24:59 <geekosaur> ghc's runtime used to just truncate these; from 6.12 on it looks at $LANG (POSIX) / the current output codepage (Windows) and encodes as appropriate
06:25:06 <geekosaur> ...
06:25:13 <geekosaur> > maxBound :: Char
06:25:15 <lambdabot>  '\1114111'
06:25:16 <jmcarthur> sham1: A Char is not a string or array.
06:25:20 <geekosaur> *codepoints*
06:25:26 <jmcarthur> sham1: So there is no "layout" for a Char.
06:25:26 <geekosaur> not an external encoding
06:25:38 <sham1> Indeed, but the codepoints need be represented in memory somehow
06:25:46 <geekosaur> native machine words
06:26:40 <jmcarthur> sham1: A String is a linked list of Chars. A Text is an array containing UTF-16.
06:27:21 <sham1> Ah
06:27:44 <sham1> Also, UTF-16. Well this is just lovely
06:28:26 <geekosaur> again that is Text not Char
06:29:02 <sham1> So Char just does not care
06:29:10 <geekosaur> @src Char
06:29:10 <lambdabot> data Char = C# Char#
06:29:25 <geekosaur> and a Char# is just a machine word containing the integer value of a codepoint
06:29:34 <sham1> okay
06:29:38 <sham1> that clears it up
06:29:42 <geekosaur> it doesn't do encodings. it just stores codepoints as numbers
06:30:02 <sham1> Well then
06:30:30 <sham1> Then the only thing I wonder is why is Text UTF-16
06:30:37 <sham1> Legacy?
06:31:22 <geekosaur> probably because "everyone else did it that way"
06:32:03 <geekosaur> https://jaspervdj.be/posts/2011-08-19-text-utf8-the-aftermath.html
06:32:40 <geekosaur> ^ final report from GSoC project looking at making Text use UTF-8 instead of UTF-16
06:32:45 <AlecTaylor> hi
06:33:09 <AlecTaylor> Trying to fix up someone's code-golf print greek alphabet problem, what am I doing wrong?           (['Α'..'Ρ']++['Σ'..'Ω']++['α'..'ρ']++['σ'..'ω'])<$>getArgs>>=putStr
06:33:53 <byorgey> AlecTaylor: what is it supposed to do?
06:34:03 <AlecTaylor> print greek alphabet
06:34:11 <lyxia> why does that need getArgs
06:34:43 <sham1> I imagine so that it can get the string to be printed from the arguments
06:35:07 <geekosaur> but it doesn't do anything with it
06:35:20 <AlecTaylor> I'm editing Angs' http://codegolf.stackexchange.com/a/97075
06:35:55 <geekosaur> <$> is fmap, which takes a function to map over a Functor. this is not giving it a function, it's giving it a String
06:36:02 <geekosaur> :t (['Α'..'Ρ']++['Σ'..'Ω']++['α'..'ρ']++['σ'..'ω'])<$>getArgs>>=putStr
06:36:04 <lambdabot> error:
06:36:04 <lambdabot>     • Couldn't match expected type ‘a0 -> String’
06:36:04 <lambdabot>                   with actual type ‘[Char]’
06:36:18 <byorgey> AlecTaylor: note that f is defined as a *function*
06:36:45 <AlecTaylor> Hmm
06:36:50 <AlecTaylor> :t (['Α'..'Ρ']++['Σ'..'Ω']++['α'..'ρ']++['σ'..'ω'])
06:36:52 <lambdabot> [Char]
06:37:35 <geekosaur> :t let f [] = ['Α'..'Ρ']++['Σ'..'Ω']; f _ = ['α'..'ρ']++['σ'..'ω'] in f
06:37:37 <lambdabot> [t] -> [Char]
06:37:42 <AlecTaylor> putStrLn $ ['Α'..'Ρ']++['Σ'..'Ω']++['α'..'ρ']++['σ'..'ω']
06:37:55 <AlecTaylor> I think that's all I wanted: putStrLn $ ['Α'..'Ρ']++['Σ'..'Ω']++['α'..'ρ']++['σ'..'ω']
06:38:00 <geekosaur> which is a hrrid hack that does uppercase with no parameters and lowercase if you give any parameters
06:38:18 <geekosaur> yes, if you just want to print them, that would do it
06:38:50 <sham1> Horrid hacks are fun sometimes
06:39:13 <geekosaur> well, it *is* code golf...
06:39:27 * hackagebot BlogLiterately 0.8.4.1 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.4.1 (BrentYorgey)
06:39:38 * geekosaur can't help but see the Greek first and try to decode it as APL >.>
06:39:52 <AlecTaylor> ;)
06:40:16 <sham1> APL, the only language that is TOO expressive
06:40:52 <AlecTaylor> Any ideas on making this more concise?
06:40:53 <AlecTaylor> putStrLn$['Α'..'Ρ']++['Σ'..'Ω']++['α'..'ρ']++['σ'..'ω']
06:41:36 <geekosaur> convince the Unicode Consortium to not split the Greek range in the middle like that
06:41:44 <AlecTaylor> >.<
06:42:35 <sham1> :P
06:42:49 <sham1> Sadly that is too late for all the Latin blocks
06:43:17 <AlecTaylor> Hmm wait I think there's a bug
06:44:19 <AlecTaylor> ς vs σ
06:44:27 * hackagebot hunit-dejafu 0.3.0.3 - Deja Fu support for the HUnit test framework.  https://hackage.haskell.org/package/hunit-dejafu-0.3.0.3 (barrucadu)
06:46:07 <osa1> does anyone know how to generate a struct expression in language-c-quote? I can't see anything relevant here http://hackage.haskell.org/package/language-c-quote-0.11.7/docs/Language-C-Syntax.html
06:47:36 <AlecTaylor> osa1: `Tstruct`?
06:47:59 <osa1> AlecTaylor: "expression"
06:48:35 <osa1> I'm trying to generate an expression, not a type declaration
06:48:36 <AlecTaylor> osa1: BTW what are you wanting to create structs for? - FFI?
06:48:46 <osa1> AlecTaylor: writing a c codegen
06:48:55 <AlecTaylor> From a DSL?
06:48:59 <osa1> yeah
06:49:20 <AlecTaylor> And what, just hate LLVM / libclang?
06:50:30 <AlecTaylor> Here have fun: http://www.stephendiehl.com/llvm/
06:50:36 <osa1> am I supposed to use LLVM / libclang? C is a good target for our use case and C is easier to target than LLVM usually
06:51:48 <AlecTaylor> osa1: Honestly for C, C++, D, Rust & others LLVM works just fine
06:52:13 <AlecTaylor> It's old hat to generate C code for your DSL
06:52:33 <osa1> :-)
06:52:36 <AlecTaylor> ;)
06:55:36 <AlecTaylor> Tell me how it goes!
06:55:40 * AlecTaylor notes it's 1AM
06:57:07 <thoughtpolice> osa1: http://hackage.haskell.org/package/c-dsl might help as well
06:57:44 <osa1> thoughtpolice: nice, thanks
06:59:28 * hackagebot aeson 1.0.2.1 - Fast JSON parsing and encoding  https://hackage.haskell.org/package/aeson-1.0.2.1 (AdamBergmark)
07:03:15 <osa1> I think CompountLit constructor is what I'm looking for
07:03:37 <osa1> not quite what I wanted but it should work
07:03:45 <osa1> I need to generate statements like `struct T t = { .t1 = 1, .t2 = 2 };`
07:04:32 <Glitchy> Coming from an OO background with Interfaces, I'm wondering how best to do my unit testing in a functional language. Normally I can use doubles to mock behavior I don't want to test (for example API calls, or datastores) but I don't know how to do that in functional programming.
07:05:30 <joe9> just read about hood and hat-observ? Does hood still work? or, is there something better?
07:06:18 <osa1> Glitchy: instead of "injecting" mocked objects you define your stuff parametric on the things you want to mock and then pass a parameter for your tests
07:07:04 <osa1> Glitchy: like using an abstract recv function instead of directly doing recv system call in your server etc. then in your tests you can pass a recv function that returns the byte sequences you want
07:10:26 <Glitchy> osa1: So there wouldn't be a cut & dry separation between production & testing code?
07:10:59 <amx> often referred to dependency injection
07:11:02 <amx> +as
07:11:04 <osa1> Glitchy: no hacks, no
07:11:45 <Glitchy> amx: Dependency injection, yes. I was wondering if it's idiomatic to do something similar in functional programming
07:11:59 <Glitchy> (or if there's just a better way)
07:12:02 <amx> pretty much exact same thing
07:12:12 <osa1> Glitchy: the final code is usually not too bad IMHO. helps with logging etc. too (you can "inject" a version that logs)
07:12:43 <osa1> amx: except in Java etc. you get same type that behaves differently. or just patch a method etc.
07:12:56 <Glitchy> osa1: So for example if I have a registerUser 'control' function, I'd pass in the function I want to call to store the user?
07:13:28 <osa1> Glitchy: that's one way, yes
07:14:06 <osa1> Glitchy: another way would be to return "user data" to register in registerUser. then you switch between the function that uses that returned data.
07:14:57 <osa1> Glitchy: another way would be to return some kind of "what to do" types in your control functions then interpret them differently in tests vs. production
07:18:32 <dimsuz> hi! how can I write this more consicely (in applicative syntax): fmap (fmap (+1)) [(1,2), (1,5)] ?
07:18:56 <dimsuz> (i.e. applying fn to a snd in each pair)
07:19:04 <osa1> dimsuz: fmap = <$>
07:19:10 <dimsuz> I know
07:19:25 <dimsuz> but somehow I can't wrap my head around on how to rewrite this :)
07:19:50 <dimsuz> fmap (+1) <$> [(1,2), (1,5)]
07:19:51 <osa1> > ((+1) <$>) <$> [(1, 2), (1, 5)]
07:19:53 <lambdabot>  [(1,3),(1,6)]
07:20:04 <dimsuz> okay
07:20:09 <dimsuz> still looks a bit weird
07:20:19 <osa1> dimsuz: just use two "map"s
07:20:19 <dimsuz> maybe there's some common idiom for such things?:)
07:20:32 <osa1> > map (map (+1)) [(1, 2), (1, 5)]
07:20:34 <lambdabot>  error:
07:20:34 <lambdabot>      • Couldn't match expected type ‘[b]’
07:20:34 <lambdabot>                    with actual type ‘(Integer, Integer)’
07:20:37 <osa1> > map (fmap (+1)) [(1, 2), (1, 5)]
07:20:39 <lambdabot>  [(1,3),(1,6)]
07:21:02 <osa1> dimsuz: you can also use "second" for the inner map
07:21:08 <osa1> > map (second (+1)) [(1, 2), (1, 5)]
07:21:10 <lambdabot>  [(1,3),(1,6)]
07:21:13 <dimsuz> ok, you kinda retraced same steps I took
07:21:25 <dimsuz> oh, didn't know about second
07:21:29 <osa1> it's from Data.Bifunctor
07:21:47 <dimsuz> thanks
07:22:07 <osa1> personally I'd hate to see <$> in this expression. I think I'd like map + second version the best
07:22:26 <sham1> Why is that
07:24:59 <jmcarthur> > (fmap . fmap) (+1) [(1,2), (1,5)]
07:25:01 <lambdabot>  [(1,3),(1,6)]
07:25:37 <ahihi> > fmap fmap fmap (+1) [(1,2), (1,5)]
07:25:40 <lambdabot>  [(1,3),(1,6)]
07:26:05 <osa1> > fmap fmap fmap succ [(1, 2), (1, 5)]
07:26:07 <lambdabot>  [(1,3),(1,6)]
07:26:18 <jmcarthur> Come on. My suggestion was serious. :(
07:26:23 <ahihi> ;)
07:26:27 <osa1> :)
07:31:10 <Glitchy> I guess what I'm asking is... how would you do this in haskell? http://paste2.org/PjN7G5kW
07:33:10 <osa1> Glitchy: write a functions with type `UserGatewayInterface -> IdGeneratorInterface -> RegistrationInterface`
07:33:10 <kuribas> dimsuz: maybe with lenses?
07:33:20 <osa1> function*
07:34:14 <jmcarthur> Glitchy: I don't think I understand your question. You just want a straightforward port of that code?
07:35:02 <jmcarthur> s/straightforward/direct/
07:35:12 <Glitchy> jmcarthur: I want to know how I'd idiomatically get the same flexibility for testing & flexibility down the line, to change out my datastore and id generator (and any other dependency)
07:36:11 <jmcarthur> Glitchy: I don't see what in your example looks like a datastore, but your id generator thing looks like it would just be some IO action that generates ids.
07:36:22 <kuribas> > over (each.second) (+1) [(1, 2), (1, 5)]
07:36:24 <lambdabot>  error:
07:36:24 <lambdabot>      • Couldn't match type ‘(Integer, Identity Integer)’
07:36:24 <lambdabot>                       with ‘Identity b’
07:36:26 <Glitchy> jmcarthur: Gateway is a common term for datastore, sorry :)
07:36:29 <jmcarthur> I see.
07:36:49 <jmcarthur> I guess that looks like a function that accepts a user as an argument.
07:38:25 <Glitchy> jmcarthur: My knowledge of functional programming is highly limited, I'm trying to wrap my head around trying to do it in a testable way
07:38:56 <jmcarthur> This looks a lot more stateful than what I'm used to in Haskell, so it's a little hard to wrap my head around it.
07:39:17 <Glitchy> jmcarthur: So, let's say any function where we want to put something in a database.
07:39:22 <jmcarthur> Glitchy: If I am to port this as directly as possible without defining too many abstractions, createRegistrationInteractor :: (User -> IO ()) -> IO Id -> RegristrationInteractor
07:39:42 <Glitchy> Just want to take a something, and put it in a database.
07:39:59 <jmcarthur> Glitchy: and... handle :: RegistrationInteractor -> User -> IO Id
07:40:19 <Glitchy> But we want to be able to swap out that database for testing, because testing on postgres means a bunch of setup just to run tests
07:41:30 <jmcarthur> Ah, an Id is a String, apparently, so I already failed to avoid too many abstractions. :)
07:41:47 <jmcarthur> Glitchy: Are my answers actually answering your question?
07:42:22 <Glitchy> jmcarthur: In terms of how to port it, yes. I'm just wondering if there's a more idiomatic way to do it.
07:42:35 <Glitchy> I'm trying to learn the 'right' way to do haskell / functional programming.
07:42:58 <jmcarthur> It's hard to say without more context. There are a lot of choices with many pros and cons.
07:43:00 <Glitchy> jmcarthur: In this instance a userId would probably just be a uuid
07:43:37 <jmcarthur> Are you intending to also test the database or just some business logic?
07:44:14 <Glitchy> jmcarthur: Just business logic, so in the Java I'd be creating some kind of double implementing the GatewayInterface and the IdGeneratorInterface
07:44:23 <Glitchy> So that I can test that the application logic is calling the contracts
07:44:27 <Glitchy> as I expect it to
07:44:29 * hackagebot yes-precure5-command 5.5.3 - Extended yes command to reproduce phrases in Yes! Precure 5.  https://hackage.haskell.org/package/yes-precure5-command-5.5.3 (igrep)
07:44:36 <jmcarthur> If it's just business logic, I'd try to find a way to express it as a pure function.
07:44:49 <jmcarthur> Then I can feed it inputs and check its outputs and be done with it.
07:45:24 <Glitchy> jmcarthur: That's what I'd like to be able to do, but then how can I test the end-to-end (let's say this is an API call)
07:45:47 <jmcarthur> Ah, so you *are* including some IO in the test?
07:45:52 <kuribas> > over (each._2) (+1) [(1, 2), (1, 5)] -- dimsuz 
07:45:53 <Glitchy> So I call the API with /api/v1/user POST {'username':'bob', 'password':'secret'}
07:45:55 <lambdabot>  [(1,3),(1,6)]
07:45:58 <Glitchy> On production
07:48:11 <Glitchy> jmcarthur: In Java I'd be testing at two levels: behavioral (does this API call create the correct records in the database and the correct response?) and unit (does this interactor call the correct functions with the correct arguments on the Interfaces).
07:48:35 <Glitchy> This lets me know that if I swap out my Gateway all of a sudden for Oracle or MySQL, my business logic doesn't change at all.
07:48:40 <jmcarthur> Glitchy: The general pattern I use is to define a pure function that accepts some inputs and outputs an inspectable representation of what API calls it wants to make. For testing, I check that they are as expected. For production, I translate them to actual API calls. However, sometimes something simpler can be done instead.
07:49:27 <Cale> It is of course, still possible to do real behavioural testing... it's just nicer to be able to test pure functions when you have them
07:50:05 <Cale> (Because you know they will always produce the same result given the same inputs, and so the tests are more meaningful, for one.)
07:50:12 <jmcarthur> Cale: Yeah. Glitchy has been asking about what's the most idiomatic way to do this kind of thing, not just a direct port.
07:50:18 <Glitchy> jmcarthur: That makes sense, I'd much rather have that testable input & output.
07:50:19 <Cale> Yeah
07:51:00 <Cale> Pure functions can be trusted to do the same thing in the real application as they do when you test them in isolation
07:51:13 <Cale> Whereas stuff that has input and output effects generally can't.
07:51:24 <Glitchy> Cale: Right, so how do we avoid testing those IO 'parts'?
07:51:47 <jmcarthur> You can even model the latter with pure functions with some lightweight session type encoding (which sounds complicated, but I promise isn't).
07:51:56 <Cale> Well, of course you still have to test the IO parts in general, but you can thin them out, so they make as few real decisions as possible
07:52:32 <jmcarthur> For example if you need to test a function that as part of its logic has to generate a query, send it to a server, and also process the result of the query, you can just make that function return something like  (Query, Response -> FinalResult)
07:52:40 <Glitchy> jmcarthur: Do you have any examples I could see? I guess I'm at the point where I understand how to do trivial things functionally, and I'm trying to make the jump from nontrivial
07:52:54 <Glitchy> to* nontrivial
07:52:54 <jmcarthur> For testing, you inspect the query, then supply it with a response and inspect the result.
07:53:08 <jmcarthur> For production, you send to the query to database or whatever, then supply the function with the result.
07:53:14 <jmcarthur> s/result/response/
07:53:22 <Cale> Xmonad had some really nice crisp examples of this in its early days...
07:53:49 <Cale> They separated the window management logic from the stuff which actually asked the windows to position themselves appropriately
07:54:11 <kuribas> Anyone have an idea why "V.sum $ V.cons 20 $ V.enumFromN 0 1000000" would be faster than "V.sum $ V.enumFromN 0 1000000"?
07:54:32 <jmcarthur> kuribas: That sounds weird.
07:54:48 <kuribas> jmcarthur: ghc with -O2
07:54:50 <Glitchy> So I guess what I'm getting wrong is trying to test this 'Interactor' when really it should just be a chain of functions
07:55:15 <Glitchy> and in testing, I can just chain slightly different functions to test the same behavior (and still know that I'm correctly testing all the ones I haven't changed)
07:55:25 <Cale> So you were just computing a data structure consisting of a bunch of named rectangles arranged in some order, and they could do a lot of randomised testing with QuickCheck to make sure that various combinations of operations on that central data structure satisfied all the properties expected.
07:55:35 <kuribas> jmcarthur: first one is 0.076s, second one 0m0.074s
07:55:55 <kuribas> jmcarthur: no, other way around...
07:56:14 <jmcarthur> kuribas: It looks like you are just benchmarking with time in a shell? Are these results actually consistent? There tends to be a lot of noise when benchmarking this way.
07:56:26 <kuribas> jmcarthur: surprisingly yes.
07:56:44 <jmcarthur> Have you inspected the core?
07:57:05 <hpc> kuribas: wouldn't that make the first slower than the second?
07:57:23 <jmcarthur> hpc: kuribas followed up saying it was the other way around
07:57:32 <kuribas> jmcarthur: 
07:57:33 <hpc> oh
07:57:36 <kuribas> jmcarthur: no
07:58:18 <jmcarthur> That would be my first step (after verifying that these results are actually consistent).
07:58:57 <kuribas> jmcarthur: perhaps my sample space is to small...
08:00:09 <kuribas> I'll try criterion
08:00:26 <jmcarthur> If the core looks roughly unchanged, I might just suspect something boring, like the code generator doing something that affects the instruction cache.
08:00:57 <jmcarthur> Although I'd probably expect a larger difference if that was the case.
08:01:20 <jmcarthur> I strongly suspect this is just a sampling error.
08:02:43 <jmcarthur> Anyway, until I see a substantial difference, I'd just follow the line of core->cmm->assembly until I see a suspicious looking difference.
08:02:54 <kuribas> jmcarthur: yeah
08:04:09 <Apocalisp> What are people using for string interpolation these days?
08:06:41 <sham1> If it can be counted as string interpolation, I use the printf stuff
08:06:51 <kuribas> Apocalisp: printf of course ;-)
08:07:16 <Apocalisp> that's good enough for me
08:08:22 <ongy> formatting, it uses Text instead of String and is nicer in general
08:08:45 <sham1> Couldn't Text.Printf be extended in that regard?
08:09:17 <sham1> Apparently not
08:11:08 <sham1> Although there also is text-format
08:12:21 <kuribas> jmcarthur: hm, criterion reports slightly slower with V.cons (as expected).
08:13:54 <kuribas> lesson, don't use time for benchmarks :)
08:19:31 * hackagebot mysql 0.1.2 - A low-level MySQL client library.  https://hackage.haskell.org/package/mysql-0.1.2 (paulrouse)
08:30:47 <younder> Thought you might like this one: Someone wants to raise 100 000$ to find the end digit of pi :) https://www.reddit.com/r/shittykickstarters/comments/2x1uq1/100k_supercomputer_dedicated_to_finding_the_end/
08:32:49 <laudiacay> so i understand the difference between the functor instances of ((,) e) and Pair, and Im guessing you have fmap f (Pair a b) = Pair (f a) (f b)
08:33:02 <younder> For those of you that think this sounds like a great idea try reading this book first http://press.princeton.edu/titles/9664.html
08:33:25 <laudiacay> and you just implement it to apply the function to the second member of the tuple?
08:33:50 <jmcarthur> laudiacay: "it" = the ((,) e) instance?
08:33:56 <laudiacay> jmcarthur: yeahhh
08:33:57 <jmcarthur> laudiacay: If so, yes.
08:34:18 <laudiacay> ok, then im having a syntax issue... ill paste my code in here one sec
08:35:09 <geekosaur> @paste
08:35:10 <lambdabot> Haskell pastebin: http://lpaste.net/
08:35:45 <laudiacay> http://pastebin.com/isPx3392
08:35:55 <laudiacay> (im doing the typeclassopedia if that helps
08:37:44 <jmcarthur> laudiacay: types have to start with Capital letters
08:37:58 <jmcarthur> laudiacay: type Tuple a b
08:38:04 <laudiacay> jmcarthur: hahahah i forgot that... glad it's not anything super important
08:38:18 <jmcarthur> laudiacay: Also, you seem to be trying to pattern match on a non-existence constructor tuple'
08:38:27 <jmcarthur> (which would also need to start with a capital letter)
08:39:00 <jmcarthur> laudiacay: Also, your Tuple thing is just a type synonym, not a new type, so this instance will conflict with the existing ((,) e) instance
08:39:17 <laudiacay> i thought you used type to mean a type synonym
08:39:22 <jmcarthur> that's right
08:39:26 <jmcarthur> it's not a new type
08:39:34 <laudiacay> ohhhh wait that makes sense
08:39:44 <jmcarthur> newtype would be the mechanism for defining a new type from an existing one
08:39:50 <laudiacay> ohh that makes sense
08:40:16 <laudiacay>     Cannot parse data constructor in a data/newtype declaration: (,) a b
08:40:34 <byorgey> (,) is special built-in syntax, you can't use it yourself
08:40:34 <jmcarthur> newtype MyMaybe a = MyMaybeWrapper (Maybe a)
08:40:51 <laudiacay> wait im v confused
08:40:52 <byorgey> or maybe you forgot to add a constructor
08:41:16 <byorgey> laudiacay: what did you actually write that generated the error about "Cannot parse data constructor"?
08:41:26 <laudiacay> http://pastebin.com/rLjiss2z
08:42:21 <byorgey> laudiacay: when you use newtype (or data) you have to give it a data constructor
08:42:34 <geekosaur> you can't reuse (,) there
08:42:37 <laudiacay> ohhh so like Tuple' (,) a b sort of thing?
08:42:39 <byorgey> you can't just write  newtype MyType = ExistingType,  you have to write   newtype MyType = MyConstructor (ExistingType)
08:42:56 <jmcarthur> Sorry for this, but the report is one of the most unambiguous ways to learn the syntax of the language. Of course, we could help you understand it. https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2
08:42:57 <byorgey> laudiacay: yes, but with parens:  Tuple' ((,) a b)
08:43:21 <pawel_> Hello, I'm going through "Real World Haskell", and I'm having a problem with mapM vs forM
08:43:27 <pawel_> http://pastebin.com/w5UUnHV5
08:43:34 <jmcarthur> I wish the grammar in the report had internal links to other parts of the grammar...
08:43:39 * byorgey disagrees that laudiacay should look at the haskell report right now
08:43:47 <pawel_> Here's what I get: "RecursiveContents.hs:34:5: error: parse error on input ‘return’"
08:44:02 <jmcarthur> Ah, no, I didn't mean to look at it immediately.
08:44:05 <laudiacay> oh god this looks fucking awful lmao
08:44:11 <laudiacay> im just going to stick to typeclassopedia for now
08:44:17 <pawel_> I know it has something to do with the indentation
08:44:20 <laudiacay> this is very intimidating
08:44:36 <byorgey> pawel_: the 'return' on line 34 has to be indented to match everything else after the 'do'
08:44:51 <jmcarthur> More that once laudiacay understands what was going wrong here, we can show laudiacay how the report explains this. It's a great reference when you know how to interpret it.
08:44:55 <byorgey> ie.  let path = ....   isDirectory <- ...
08:45:14 <byorgey> pawel_: return (concat paths) has to be lined up under those so it is part of the do-block
08:45:15 <jmcarthur> Sorry for doing something overwhelming. :(
08:45:24 <jmcarthur> I take it all back.
08:45:30 <geekosaur> pawel_, the where in getRecursiveContents2 ends its definition
08:45:33 <laudiacay> jmcarthur: no thank u :D i will read it soon
08:45:49 <geekosaur> the return at the end is not part of the definition any more and is illegal because it's not inside a function
08:45:58 <byorgey> oh, geekosaur is right, ignore me
08:46:00 <laudiacay> im mostly getting really really good at haskell to prep for a midterm, ill satisfy my curiousity when i am in less of a timecrunch
08:46:09 <jmcarthur> I see.
08:46:13 <pawel_> I'm kinda lost here, in the second function, the indentation for the "return" is the same as in the first one, isn't it?
08:46:23 <geekosaur> it's not indentation
08:46:27 <byorgey> pawel_: yes, I was wrong.  listen to geekosaur 
08:46:28 <geekosaur> it's the "where"
08:46:32 <geekosaur> move it *after* the return
08:46:40 <geekosaur> (and the definition fo f with it)
08:46:47 <geekosaur> *of f
08:47:25 <pawel_> Ok, I see
08:47:35 <geekosaur> you can't attach "where" to arbitrary expressions; it's part of a definition
08:47:46 <geekosaur> getRecursiveContents2 = ... where ...
08:48:06 <geekosaur> so the main body of getRecursiveContents2 ends at the where
08:48:47 <jmcarthur> laudiacay: Anyway, was byorgey's explanation helpful?
08:48:52 <pawel_> Ok, works now :)
08:48:56 <pawel_> Thanks a lot
08:49:00 <laudiacay> jmcarthur: not really but im going to keep trying
08:50:01 <pawel_> Here's the updated version in case someone needs it: http://pastebin.com/5Swd7E8c
09:09:33 * hackagebot legion 0.6.0.0 - Distributed, stateful, homogeneous microservice framework.  https://hackage.haskell.org/package/legion-0.6.0.0 (taphu)
09:16:12 <Paprikachu> hi, i was wondering: how does haskell know if something is a parenthesized expression or a tuple with one element?
09:16:32 <monochrom> there is no tuple with one element.
09:16:42 <Paprikachu> hmm
09:16:55 <Paprikachu> so there's a tuple with no element, a tuple with two elements, but no tuple with one element?
09:17:02 <geekosaur> exactly
09:17:06 <Paprikachu> interesting.
09:17:34 <monochrom> I don't consider () to be a tuple with no element.
09:19:37 <latro`a> () is "the thing in the canonical type with one inhabitant"
09:19:52 <latro`a> to me
09:19:58 <glguy> If you're using TH, () is the tuple with no elements
09:34:39 <chris__> Testing
09:35:02 <chris__> Arghh... Just typed something out and now it's completely gone. 
09:35:57 <chris__> Firstly, hello everyone. I'm trying trying to figure out how to create a function that would be dynamically created... I'm not even sure if this is possible.
09:36:09 <chris__> But essentially I have something like
09:36:09 <chris__> f 0 = 0
09:36:09 <chris__> f 1 = 1
09:36:35 <chris__> f n = (f (n -1)) + (f (n - 2))
09:37:30 <chris__> How could i create a function that would have a different starting values (the values returned by (f 0) and (f 1)?
09:39:42 <ahihi> makeF v0 v1 = f where f 0 = v0; f 1 = v1; f n = ...
09:41:01 <Cale> chris__: There's no difference between a function of multiple arguments and a function which constructs another function :)
09:41:45 <chris__> Just curious is there a way to do it without the where or let construct?
09:41:59 <chris__> But thanks! Looks like exactly what I need.
09:42:51 <ahihi> makeF v0 _ 0 = v0; makeF _ v1 1 = v1; makeF _ _ n = ...
09:42:55 <ahihi> is an equivalent definition
09:44:11 <Cale> (you will want to pattern match the first two arguments in the recursive case)
09:45:00 <Cale> @let slowLucas a b 0 = a; slowLucas a b 1 = b; slowLucas a b n = slowLucas a b (n-1) + slowLucas a b (n-2)
09:45:01 <lambdabot>  Defined.
09:45:13 <Cale> > slowLucas 1 3 6
09:45:16 <lambdabot>  29
09:46:03 <Cale> You can actually do the same thing much more efficiently though
09:46:15 <Cale> > slowLucas 1 3 30
09:46:22 <lambdabot>  mueval-core: Time limit exceeded
09:46:23 <ahihi> oh, true, you need to pass them along to the recursive calls
09:46:25 <Cale> ^^ really really slow
09:46:39 <ahihi> one reason why I prefer my first version
09:47:11 <Cale> @let lucas a b 0 = a; lucas a b n = lucas b (a+b) (n-1)
09:47:12 <lambdabot>  Defined.
09:47:17 <Cale> > lucas 1 3 30
09:47:20 <lambdabot>  3010349
09:47:23 <Cale> ^^ not as slow
09:49:28 <chris__> I can't really comprehend what is going on with those further examples. But thanks! 
09:49:58 <Cale> chris__: Well, think about how you'd calculate it by hand
09:50:38 <tsahyt> this might be a stupid question but as I'm writing FFI bindings at the moment I have noticed that this library does use const on pointers a lot to enforce at least a basic level of safety. Is there a way to denote const ptrs on the Haskell side?
09:51:04 <Cale> chris__: you probably would work your way along the sequence, referring to the previous two values in order to determine the next at each step
09:51:44 <Cale> chris__: and the nth term in the sequence starting with a and b will be the same as the (n-1)th term in the sequence starting with b and (a+b)
10:04:56 <jmcarthur> tsahyt: You could make your own wrapper around Ptr for that.
10:05:22 <tsahyt> jmcarthur: a newtype? but that can't be used through the FFI afaik
10:05:28 <jmcarthur> Yes it can.
10:05:36 <Cale> newtypes of FFI types are FFI types
10:06:02 <tsahyt> good to know
10:06:03 <Cale> It's quite common to use something like  newtype A = A (Ptr A)
10:06:07 <monochrom> there is a requirement. you have to make sure to import the data constructor as well.
10:06:36 <Cale> (which looks recursive, but since the type argument to Ptr is phantom, is sort of not)
10:07:19 <tsahyt> so whenever I have some opaque handle as a pointer I can use a newtype for that then
10:07:33 <jmcarthur> yup!
10:07:34 <tsahyt> so far I've been using data A and Ptr A for that
10:07:42 <tsahyt> but just writing A -> something seems much nicer
10:07:50 <tsahyt> I think I'll change that then
10:08:36 <tsahyt> I've been writing on these bindings for a few days now. I forgot how terribly unsafe C is. this isn't even bad C to be fair, but it is C...
10:09:39 <tsahyt> I wish there was a way to derive storable instances though
10:10:37 <monochrom> :)
10:10:52 <glguy> tsahyt: There are a few
10:10:54 <Cale> There are a bunch of tools to help writing them... I'm not sure what's best at the moment since it's been a while since I've done any FFI
10:11:21 <tsahyt> I'm using hsc2hs and it helps a ton with the ugliest bits, but I still have to write an instance declaration for each type
10:11:28 <Cale> Perhaps check out c2hs
10:11:32 <glguy> Yeah, hsc2hs isn't one of the few
10:11:32 <Cale> ah, yeah
10:12:00 <tsahyt> currently the best tool I've found is really vim and its macro feature
10:12:12 <monochrom> haha
10:12:26 <Cale> heh
10:44:36 * hackagebot legion-extra 0.1.0.4 - Extra non-essential utilities for building legion applications.  https://hackage.haskell.org/package/legion-extra-0.1.0.4 (taphu)
10:48:35 <novak`> Hi everyone, Haskell newcomer is here. I'm trying to setup my Emacs, I've heard that it could offer a full pleasure. :) I'm stuck with hindent. It looks to me like it's not properly installed. I've installed it using stack install hindent. When I run hindent --help I get an error: CallStack (from HasCallStack):
10:48:35 <novak`>   error, called at src/main/Main.hs:59:10 in main:Main
10:55:39 <fr33domlover> hey novak`
10:55:55 <fr33domlover> it looks like a problem with hident hmmm
10:56:02 <fr33domlover> which GHC are you using?
10:57:34 <novak`> fr33domlover: ghc --version says The Glorious Glasgow Haskell Compilation System, version 7.6.3
10:59:37 * hackagebot obd 0.2.1.0 - Communicate to OBD interfaces over ELM327  https://hackage.haskell.org/package/obd-0.2.1.0 (hverr)
11:00:42 <fr33domlover> novak`, it may be too old for some things by now. i'd upgrade to 7.10.3 (or 8, depending on which Stackage version you want to use)
11:01:40 <mlife> hello guys, http://lpaste.net/292174 so for my naive function (naive = foldr o [] ) I tried changing it to (naive list = foldr o [] list) but with both  I keep getting the exception Exception: Prelude.head: empty list when trying to run naive ["string"] 
11:01:41 <fr33domlover> novak`, which distro are you using?
11:02:06 <novak`> fr33domlover: Ubuntu 14.04
11:02:29 <fr33domlover> novak`, then if you like, you can install GHC from hvr's PPA
11:02:38 <fr33domlover> I use Trisquel 7 and I get GHC from there
11:02:56 <kadoban> Half of the fun of using stack is that you don't have to install GHC yourself. It's not using GHC 7.6.whatever to build hindent, unless you really tricked it into it.
11:03:10 <kadoban> It's extremely likely using its own locally installed version.
11:03:44 <fr33domlover> kadoban, but installing GHC is something you do once, and rarely upgrade
11:04:02 <fr33domlover> it's fun to have stack do it, but i'd say it's much less than half of the fun :P
11:04:07 <kadoban> Is hindent one of those things that needs GHC on the command line? Maybe it's breaking because that version is so old.
11:04:11 <fr33domlover> especially if you can just apt-get install GHC
11:04:23 <novak`> fr33domlover: I got it from default haskell-platform
11:04:28 <sham1> I'm glad mlife that you took my changes into consideration :P
11:04:32 <estike> hello
11:04:41 <estike> can i ask you a question
11:04:58 <estike> can i use the statement where in a comprehension list?
11:05:01 <sham1> Don't ask to ask
11:05:10 <Tuplanolla> What does that get you, fr33domlover? GHC 6?
11:05:15 * hvr considers it rather annoying that stack installs GHC
11:05:27 <fr33domlover> Tuplanolla, thanks to the PPA? no, I can get any GHC I like
11:05:29 <sham1> Well it does install the latest one...
11:05:30 <geekosaur> estike, where is part of a declaration
11:05:32 <sham1> So that's good
11:05:57 <geekosaur> it is not part of an expression. you can use let in expressions, including list comprehensions
11:06:04 <estike> https://thepb.in/p/lOhOWR2DKk6cB
11:06:09 <estike> can i use like this?
11:06:10 <Tuplanolla> Alas that takes a couple extra commands.
11:06:36 <geekosaur> you have to indent it
11:06:38 <fr33domlover> The problem with stack installing GHC is that it's - afaik - per user
11:06:39 <geekosaur> and the things under it
11:06:49 <fr33domlover> I have multiple users which use GHC
11:06:57 <fr33domlover> so the PPA method works great for me
11:07:08 <sham1> mlife, have you tried to have it be ss instead of [head ss]
11:07:12 <mlife> sham1: they truly helped! One question I had for u is eg in prefix where you changed a input var for _ , that was a more convenient change rather than for functionality right?
11:07:19 <hvr> fr33domlover: there's a few other issues, like not tracking system deps 
11:07:38 <sham1> Oh, in like the prefix-function?
11:07:46 <hvr> fr33domlover: there's a reason we moved away from install .tar.gzs in modern linux distros over a decade ago :0
11:07:50 <fr33domlover> hvr, issues with that? stack setup or the PPA?
11:08:07 <estike> https://thepb.in/p/LghN0BRoRvwuZ
11:08:12 <sham1> I did it because if you have an unused parameter, you might as well have the underscore
11:08:16 <mlife> sham1: if i make that change, o doesnt do what its supposed to do anymore :o
11:08:17 <estike> can i use like that?
11:08:21 <fr33domlover> hvr, I'm all in favor of convenient packages and single command installation :P
11:08:25 <sham1> What is o supposed to do
11:08:27 <hvr> fr33domlover: GHC's bindists shupped as .tar.gz don't take care to install additional dependencies you may need... like C headers, c compiler, and all that
11:09:03 <mlife> sham1: and yes in the prefix function :) o does : "fire" ‘o‘ "red" = "fired" "water" ‘o‘ "blue" = "waterblue" - concatenates two string where they overlap
11:09:10 <hvr> fr33domlover: that's what a system pkg manager like nix, apt, yum, rpm etc does for you
11:09:22 <sham1> Oh
11:09:32 <fr33domlover> hvr, and that's what I use :P don't forget Guix
11:10:00 <estike> parse error on input `where' what error is this ?
11:10:03 <mauke> :t let foo n = [a | x <- [1 .. n - 1], y <- [1 .. x], let a = x * y, let b = show a, b == reverse b, a > 10] in foo
11:10:05 <lambdabot> (Show t, Ord t, Num t, Enum t) => t -> [t]
11:10:14 <geekosaur> estike, that's still not indented. haskell is indentation sensitive, like python
11:10:18 <mauke> estike: broken indendation
11:10:35 <mauke> > let foo n = [a | x <- [1 .. n - 1], y <- [1 .. x], let a = x * y, let b = show a, b == reverse b, a > 10] in foo 100
11:10:38 <lambdabot>  [11,22,33,44,55,66,77,88,99,121,272,252,171,323,252,22,44,66,88,242,484,161,...
11:10:49 <sham1> mlife, I know what your problem is
11:10:52 <nitrix> f <- g :: type
11:10:59 <sham1> ss is passed [] by default
11:10:59 <nitrix> Is the type annotation for g or f ?
11:11:09 <mauke> nitrix: g
11:11:10 <sham1> Because foldr's type is
11:11:11 <estike> i dont get why i need to put let in the list
11:11:13 <sham1> :t foldr
11:11:13 <nitrix> mauke: thanks.
11:11:15 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
11:13:37 <mlife_> I apologize, my laptop died on me
11:14:01 <sham1> Also mlife_, wouldn't it be easier to just return fs if fs contained [head ss]
11:14:06 <sham1> So like
11:18:38 <Gurkenglas> estike, me neither, if I was in power I'd get rid of that let and the one in do notation. I guess you can remember it by knowing that it's desugared to actual let blocks
11:19:38 <mlife_> hmm about returning fs only, I think you are also supposed to add the string afterwards? like abc bac I understand it should return abcbac?
11:19:54 <mlife_> so returning fs wouldnt do this would it?
11:22:06 <Lokathor> esqueleto doesn't seem to be in lts 7 :(
11:22:31 <sham1> mlife_, scratch that
11:22:35 <sham1> I managed to solve it for ya
11:22:50 <kadoban> Lokathor: Maybe doesn't work with ghc 8 yet?
11:23:28 <mlife_> is the change in o or naive? I wanna try to figure it out ><
11:23:29 <Lokathor> yeah, guess i'll stay with lts 5.5
11:23:58 <kadoban> lts 6 is still ghc 7.10 or whatever, if that helps
11:24:20 <juri_> eep. first adventure in profiling.
11:24:45 <Lokathor> well, it's an older program that was written with 5.5 in mind, and i was just going to bump it up to 7
11:24:48 <Lokathor> but i guess not
11:29:17 <lpaste> sham1 revised “No title”: “No title” at http://lpaste.net/292174
11:30:07 <sham1> mlife_, that should work
11:30:24 <sham1> Also, the case where ss is empty, returning fs is a sane default
11:32:12 <mlife_> x.x basically creating an event for empty fs
11:32:21 <sham1> ss*
11:32:45 <juri_> it takes a while to compile one's world with library profiling.
11:36:46 <sham1> Well the world is huge
11:36:55 <sham1> So recompiling it is kind of annoying
11:39:23 <bollu> :t Lift
11:39:25 <lambdabot> error:
11:39:25 <lambdabot>     • Data constructor not in scope: Lift
11:39:25 <lambdabot>     • Perhaps you meant one of these:
11:39:26 <bollu> :t lift
11:39:29 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
11:39:34 <bollu> uh, wrong lift
11:40:48 <bollu>     lift :: t -> Q Exp
11:40:54 <bollu> what are the semantics?
11:43:47 <mlife_> sham1: I see, also could you explain me (giving an example would be nice plz) of what this is supposed to do? function maximize :: Eq a => (a -> Int) -> a -> a -> a which takes a function f of type a -> Int, and two arguments of type a. It returns the argument which maximizes the function f.
11:45:05 <sham1> Where is that kind of function
11:45:31 <bollu> mlife_: it seems like you described what the function should do? :)
11:45:46 <sham1> Am confuse
11:46:58 <sham1> So you want a function that takes in a function that turns anything of type a into an Int and then take two Ints and return the one that produces higher Int?
11:47:43 <bollu> mlife_: do you want to know how to define the function? or..?
11:47:52 <yulax> hi folks, i am trying to write a recursive function that iterates.
11:48:02 <bollu> yulax: go on
11:49:12 <yulax> http://paste.debian.net/hidden/1bbf6ec0/
11:49:36 <mlife_> I mean the function is maximize: Eq a.. idk if the "function" before confused you, what im asking though is for an example to make sure i got it,
11:49:57 <sham1> "Recursive function that iterates" I'd like you to be little bit more specific
11:49:58 <yulax> the error is  Couldn't match expected type `Int -> Int' with actual type `Int'
11:50:24 <mlife_> from what I get it should do something like maximize squared 2 4 and returns 4 since 4^2 is bigger than 2^2? and assuming there is a squared func :p
11:50:27 <bollu> yulax: what is the type of f? and what are you passing it in the n > 0 branch
11:50:34 <yulax> sham1: basically it takes n f and x. and does f(f(x)) and so on.
11:50:44 <sham1> Also mlife_, do you mean maximize f a b = if f a > f b then a else b
11:50:48 <sham1> Because
11:50:50 <bollu> yulax: look at the n > 0 branch
11:50:58 <sham1> > maximize f a b = if f a > f b then a else b
11:50:59 <yulax> type f is the function (Int -> Int)
11:51:00 <lambdabot>  <hint>:1:16: error:
11:51:00 <lambdabot>      parse error on input ‘=’
11:51:00 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
11:51:10 <sham1> Meep
11:51:16 <sham1> :t maximize f a b = if f a > f b then a else b
11:51:17 <lambdabot> error:
11:51:18 <lambdabot>     parse error on input ‘=’
11:51:18 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
11:51:19 <bollu> yulax: okay, and what is the type of "iterate"?
11:51:24 <sham1> Well shit
11:51:30 <bollu> yulax: iteration*
11:51:31 <bollu> n > 0  = f (iteration (n-1) f x)
11:51:53 <geekosaur> I see a different problem there... the type seems wrong
11:51:53 <bollu> > let maximize f a b = if f a > f b then a else b in maximise (**2) 2 4
11:51:56 <lambdabot>  error:
11:51:56 <lambdabot>      • Variable not in scope:
11:51:56 <lambdabot>          maximise :: (Double -> Double) -> Integer -> Integer -> t
11:52:04 <bollu> ah, fuck Num
11:52:16 <bollu> > let maximize f a b = if f a > f b then a else b in maximise (\x -> x * x) 2 4
11:52:18 <lambdabot>  error:
11:52:18 <lambdabot>      • Variable not in scope:
11:52:18 <lambdabot>          maximise :: (Integer -> Integer) -> Integer -> Integer -> t
11:52:23 <mlife_> x)
11:52:26 <sham1> :P
11:52:27 <Tuplanolla> It's your spelling, bollu.
11:52:32 <bollu> ahh xD
11:52:50 <bollu> > let maximize f a b = if f a > f b then a else b in maximize (\x -> x * x) 2 4
11:52:53 <lambdabot>  4
11:52:57 <bollu> yay :P
11:53:01 <sham1> Woot
11:53:05 <sham1> Oh type errors
11:53:11 <sham1> You never truly get rid of them
11:53:33 <bollu> yulax: right, so, back to n > 0  = f (iteration (n-1) f x)
11:54:02 <geekosaur> bollu, yulax: might look at the type signature on line 1
11:54:02 <yulax> well since iterate produces an Int value, then putting Iterate in f, which takes an Int should be ok?
11:54:15 <yulax> that was my line of thinking..
11:54:16 <geekosaur> compared to the patterns on line 2
11:54:21 <sham1> Yeah
11:54:29 <sham1> It lacks one Int
11:54:39 * hackagebot unfoldable 0.9 - Class of data structures that can be unfolded.  https://hackage.haskell.org/package/unfoldable-0.9 (SjoerdVisscher)
11:54:48 <bollu> geekosaur: yeah, you need an additional -> Int there
11:54:59 <bollu> geekosaur: which will fuck up the call. So I wanted to do the "other" way :P
11:55:38 <sham1> Also, not all cases are exhausted
11:55:57 <yulax> well thi issue i am having is that my file won't load.
11:56:03 <mlife_> hmm whats another example of a a-> int func?
11:56:27 <ongy> length
11:56:28 <sham1> minimize ;)
11:57:09 <yulax> line 2, we take iteration, and give it three arguments, Int (Int ->Int) and Int, i still can't see what is invalid, unfortunately.
11:57:23 <yulax> newbie issues <3
11:58:13 <yulax> sham1: should f be of type Int -> Int -> Int?
11:58:19 <sham1> You need the type signature to be "iteration :: Int -> (Int -> Int) -> Int -> Int"
11:58:39 <yulax> how silly of me
11:58:43 <yulax> now i see...
11:59:09 <sham1> One learns to see this stuff as they try to go forth in Haskell
11:59:15 <yulax> of course! for the value that i want iteration to return...
11:59:51 <yulax> sham1: yea, i am currently just solving as many trivial (and not--so-trivial) exercise as i can 
11:59:58 <yulax> then i can be better.
12:00:19 <sham1> Also, there is an underhanded case in your function
12:00:33 <sham1> What if n is negative
12:01:11 <sham1> So what I would suggest is to ditch n == 0 and put | otherwise = x to be the last case
12:01:57 <yulax> yes, i see this. thanks sham1 !
12:03:16 <sham1> like this
12:03:27 <sham1> iteration n f x | n == 1 = f x | n > 0 = f (iteration (n-1) f x) | otherwise = x
12:03:40 <sham1> Obviously across multiple lines
12:08:19 <yulax> in the end i just had n < 0 throw an exception, and then did f (iterate ...) for n > 0 and otherwise = x
12:08:28 <yulax> thank you for all your help
12:08:38 <yulax> types types types!
12:09:06 <sham1> That is a very bad idea
12:10:30 <sham1> These so-called partial functions are usually frowned upon. Especially if they can exist in pure code (*cough* head *cough*)
12:15:04 <Zemyla> yulax: You can avoid throwing an exception for n < 0 by having the type be iteration :: Natural -> (a -> a) -> a -> a.
12:15:36 <Zemyla> Because a value of type Natural can't be < 0.
12:15:56 <ongy> Zemyla: from Int Word makes more sense than Natural, which is closer to Integer
12:16:01 <sham1> Natural numbers, or how they call them usually in programming, unsigned numbers
12:16:06 <yulax> Zemyla: thank you, I was not aware that Natural existed
12:16:28 <yulax> convenient indeed.
12:16:51 <ongy> take care with natural though, it's partial
12:16:57 <ongy> > 1 - (2 :: Natural)
12:16:59 <lambdabot>  *Exception: Natural: (-)
12:17:57 <sham1> Well base's Data.Word has a Word32, that is an unsigned 32-bit integer, which would also work
12:18:03 <sham1> Unless you need 64-bit integers
12:18:13 <sham1> > 1 - (2 :: Word32)
12:18:16 <lambdabot>  4294967295
12:18:21 <sham1> Although that happens
12:18:28 <ongy> Word is 64bit (on 64bit platform)
12:18:57 <sham1> Ah, because it follows the bitsize of Int
12:19:07 <sham1> And in 64-bit systems it is 64 I assume
12:19:15 <younder> duh
12:19:18 <ongy> I'd say correlated, not caused
12:19:23 <Tuplanolla> It can be 62, sham1.
12:19:52 <Zemyla> sham1: Does GHC even support compiling with a word size of 31 or 30?
12:19:53 <younder> no it cant but it can be signded so 63
12:19:55 <Zemyla> Anymore?
12:20:21 <sham1> Why would it ever be 62 bits
12:20:36 <younder> http://www.allaboutcircuits.com/textbook/digital/chpt-2/negative-binary-numbers/
12:21:03 <sham1> Signed 64-bit numbers are still 64 bits long, not 65 for instance
12:21:12 <ongy> Word is unsigned, so negative numbers may matter for Int, not Word though
12:21:23 <sham1> The magnitude is represented by the first 63 bits
12:21:38 <sham1> But the sign-bit is still very much present
12:21:44 <monochrom> you ever heard of "2's complement"?
12:22:06 <Zemyla> I think the 63-bit Word is so the other bit can be a tag bit? Maybe?
12:22:11 <Zemyla> Some things use tag bits?
12:22:12 <Tuplanolla> The Haskell 98 Report says: "The finite-precision integer type Int covers at least the range  [ - 2^29, 2^29 - 1]."
12:22:21 <younder> yes hence the difference between 63 bit's and 64
12:22:41 <sham1> That value is still stored in a qword, which is 64 bits
12:22:41 <younder> the 64'th bit is the sign
12:22:55 <sham1> Even if the most significant bit is the sign bit'
12:22:57 <younder> PLEASE till me you all know this
12:22:58 <Zemyla> I think the tag bit is to tell the difference between pointers and integers in the GC?
12:23:00 <monochrom> The Haskell Reports try to be lax so some compiler writers can steal 2 bits for tags etc. But GHC doesn't actually do that.
12:23:13 <ongy> it can be used as sign, but it isn't a sign bit
12:23:20 <younder> Ah it's the TAB
12:23:24 <younder> TAG
12:23:43 <monochrom> Instead, GHC allocates one extra machine word for all its tagging and pointering and stuff.
12:23:52 <juri_> so, when i'm using -xc, and it's reporting exceptions.. what does that *mean*?
12:23:54 <younder> That seems criminal to steal a bit from a integer
12:24:00 <sham1> ^
12:24:16 <ongy> Zemyla: There's pointer tagging. iirc GHC aligns to wordsize, so it has 3(?) bits for information on each pointer
12:24:23 <younder> afterall it's range decreases exponentially
12:24:35 <sham1> If I am promised a 64-bit number, I expect that I can write 0xFFFFFFFFFFFFFFFF to it
12:24:36 <Zemyla> ongy: Two on 32, 3 on 64.
12:25:06 <monochrom> Well stealing is criminal yes. What about taking an extra 64 bits for what could be just 2 bits?
12:25:24 <Zemyla> Does the Haskell standard provide Word32/Word64, or just Word?
12:25:26 <monochrom> The logical conclusion is that the whole world is criminal one way or another.
12:25:36 <younder> rotfl
12:25:53 <monochrom> The Haskell standard has to still require Word32 and Word64 for FFI purposes.
12:26:12 <monochrom> But it doesn't say that Word is either. (GHC does choose either.)
12:26:33 <Zemyla> monochrom: I think a tagged implementation of Haskell would have to store a Word32 in two Word31s, or a Word64 in two Word63s :V
12:26:44 <monochrom> It means another compiler writer can choose to say: Word is 30 bits, Word32 is 32 bits but takes up more memory.
12:26:51 <monochrom> yeah
12:27:05 <Zemyla> Also, taking bits off of numbers is worse, because then you have to take them off and put them back on again every time you do arithmetic.
12:27:28 <ongy> or have fun with overflows
12:27:30 <monochrom> More precisely, Word exposes 30 bits to you but takes 32 bits internally, Word32 exposes 32 bits to you but takes 1MB internally.
12:28:09 <monochrom> Yeah but I think they mitigate it by saying "the tag bits are at the LSB end" so it doesn't hurt addition that much for example.
12:28:24 <monochrom> Appel's compiler textbooks have a paragraph on this.
12:28:52 <sham1> This is sounding more and more silly
12:29:16 <younder> Word32 then deffinatly that way my comoter of 64 Gb can express 128 values
12:29:22 <monochrom> So for exmaple you don't have to bit-shift. You mask, +, or-back lower tag bits
12:29:23 <ongy> this can be useful, but I don't think it's good for general purpose compilers
12:29:40 * hackagebot sigma-ij 0.2.0.2 - Thom polynomials of second order Thom-Boardman singularities  https://hackage.haskell.org/package/sigma-ij-0.2.0.2 (BalazsKomuves)
12:29:47 <younder> totally inssane if you ask me
12:30:03 <younder> Anf I write compilers
12:30:04 <Tuplanolla> You just need to assume less.
12:30:12 <monochrom> On the bright side, the GHC people agree with you. Just look at what they chose to do.
12:30:44 <monochrom> They would rather make Char occupy 128 bits than steal 2 bits :)
12:30:47 <Tuplanolla> We're still quite far away from the madness that is C.
12:31:00 <younder> Simpo P Jones has more brains than that
12:31:14 <ongy> how much memory does a Char take currently?
12:31:18 <younder> Thats what my insticst tell me
12:31:19 <monochrom> 128 bits
12:32:17 <geekosaur> 1 machine word for the constructor tag, 1 machine word for the codepoint
12:32:22 <monochrom> Any moment you see "data X = MkX# X#" you can pretty much bet on: the constructor MkX# corresponds to one machine word, the value part X# corresponds to one more machine word.
12:32:31 <younder> 8 or 16 or 30 depending on the encoding. Though in practice alwayse 8 UTF-( or 16 UTF-16
12:32:36 <monochrom> And then on x86-64 "machine word" means 64 bits. 8 bytes.
12:32:44 <geekosaur> younder, Char is codepoints
12:32:49 <monochrom> And Char is like that.
12:32:49 <younder> s/30/32
12:33:15 <monochrom> Moreover, let's also see what this means to "data List a = Nil | Cons a (List a)"
12:33:41 <younder> THis is gettingmore insane by the minute
12:33:41 <monochrom> Cons is 8 bytes, "a" is 8 bytes (pointer), "List a" is 8 bytes (pointer).
12:33:59 <younder> haskell does NOT useUnicode?
12:34:04 <mauke> younder: wtf?
12:34:13 <sham1> They are Unicode codepoints
12:34:15 <younder> yes wtf
12:34:22 <mauke> younder: please stop talking
12:34:28 <monochrom> This means your list of length n is 24n bytes to boot, and this is just the list skeleton, not even actual data.
12:34:40 <Tuplanolla> Unicode is different from its encodings, like UTF-8, younder.
12:35:15 <geekosaur> younder, Char is a codepoint. decoding/encoding takes place during I/O
12:35:36 <monochrom> So if you say "my list is merely 10^9 items and I have 8GB RAM already, why do I run out of memory?" Answer: you need 24GB.
12:35:38 <younder> UTF-8 is an encding . Unicode requieres 18 bits in it's full form. Never 3
12:35:41 <geekosaur> the range of a Char is U+0000 to U+10FFFF
12:35:55 <younder> s/3/32/
12:36:00 <mauke> by 18, do you mean 21?
12:36:14 <younder> no 2^18
12:36:22 <monochrom> In fact sometimes you need 48GB (twice of 24GB) because copying GC wants double-buffering.
12:36:26 <glguy> mauke: different base
12:36:28 <yulax> wow
12:36:30 <geekosaur> and ghc stores scalar values in a multiple of machine words (1 for most things, 2 for Double)
12:36:51 <monochrom> Yeah, Word8 takes 128 bits too :)
12:37:01 <sham1> One codepoint encoded with UTF-8 might require 4 bytes
12:37:04 <ongy> why does double need 2?
12:37:23 <ongy> also machine word sounds weird. I'm pretty sure both intel and amd see word as something different than register size -.-
12:37:28 <younder> 64 * 4 = 256
12:37:30 <sham1> I have a feeling that it is because it is double precision
12:37:44 <monochrom> Word8 takes 16 bytes and you said stealing 2 bits was criminal... :)
12:37:46 <mauke> > logBase 2 (fromIntegral (ord maxBound))
12:37:48 <lambdabot>  20.087461546321563
12:37:50 <geekosaur> actually that would be for i386 (32 bit words)
12:37:55 <mauke> looks like 21 bits to me
12:38:04 <sham1> I thought it was common nomenclature that word means 16 bits
12:38:16 <mauke> sham1: only on DOS
12:38:19 <geekosaur> machine word means what the hardware uses natively
12:38:20 <kadoban> sham1: Naw, it's ... ambiguous in the extreme
12:38:24 <younder> I may not be an orace of haskell but I know machine hardware
12:38:30 <geekosaur> I am specifying *machine* word for a reason
12:38:30 <monochrom> The corollary is that if you're renting a virtual machine that has 512MB RAM, you may like to go back to 32-bit GHC.
12:38:52 <Tuplanolla> Now we just need to add nonoctet bytes to this mess.
12:38:53 <monochrom> because the 64-bit inflation is really scary
12:39:17 * geekosaur only occasionally misses TOPS-20, thanks :p
12:39:31 <ongy> Tuplanolla: I don't think ghc runs on any (or compiles to any) platform that uses those
12:39:33 <younder> Ah Haskell still uses Octetts, Kinda like Lisp
12:39:35 <sham1> Well that's odd because according to this table, the word size under AMD64 (x86_64) is 16 bitshttps://en.wikipedia.org/wiki/Word_(computer_architecture)#Table_of_word_sizes
12:39:59 <monochrom> "word" is 16 bits in asm context.
12:40:01 <younder> A bit obsolete but lats go with it
12:40:16 <monochrom> But I carefully said "machine word" :)
12:40:27 <geekosaur> sham1, do I really need to write out "native full size of a general CPU register" just to make you happy?
12:40:32 <younder> A word is 64 bit's today
12:40:56 <younder> 64 bit computer 64 bit word
12:41:06 <monochrom> I build more wonders to make my people happy (in Civ 5)
12:41:06 <Zemyla> younder: There are still 32-bit computers.
12:41:08 <sham1> Word /= register size
12:41:21 <younder> I've been thrgh 16, 32, and now 64
12:41:26 <geekosaur> so you are saying yes?
12:41:57 <younder> Zenyla: I know I use PI-2's
12:42:01 <geekosaur> I don't think many people in programming actually use that any more unless writing in assembly language
12:42:17 <mjhamrick> Could someone point me towards some help on constructing an Arbitrary instance for Reader? 
12:42:24 <Zemyla> Also, speaking of words, is there any way we can expose the plusWord2#, timesWord2#, and quotRemWord2# functions in some form usable by people who aren't including GHC.Prim?
12:42:25 <geekosaur> and even there it's become fairly rare because it's uncommon to use only 16-bit values
12:42:35 <monochrom> There was a public FTP server hosting free software and freeware for everyone to download. It used 36-bit words.
12:43:05 <monochrom> Probably the idea was "4 bytes, plus 4 parity bits"
12:43:11 <geekosaur> nope
12:43:16 <sham1> Well that is why you use multiples of word, like dword (double-word aka 32 bits) and qword (quad-word aka 64 bits)
12:43:23 <Zemyla> mjhamrick: Wouldn't it be something like (Coarbitrary r, Arbitrary (m a)) => Arbitrary (ReaderT r m a)?
12:43:25 <geekosaur> DEC used multiples of 6 for register sizes
12:43:40 <geekosaur> bytes were faked originally for IBM mainframe compatibility
12:43:49 <sham1> I default to assuming i386-compatible computers
12:43:50 <younder> Thruth be told 32 bit make a lot of sense if you have 1 GB or less. The PI3 just doesn't hve enoughRAM to pull off 64 bit
12:43:51 <monochrom> Ah, but I think it was not a DEC.
12:43:52 <ongy> so with GHC I should encode 8bit values into groups of 64bit types for memory saving?
12:44:09 <geekosaur> it was a DEC running Tenex/Twenex
12:44:30 <monochrom> OK!
12:44:46 <younder> geekosaur: PDF11 was a LONG time ago
12:45:23 <geekosaur> you have at least two errors there... PDP10
12:45:41 <younder> sorry PDP
12:45:42 <geekosaur> PDP11 used 8-bit bytes and competed with IBM minis that used 8-bit bytes
12:46:00 <Tuplanolla> I think Texas Instruments still produces processors with funny byte sizes, younder.
12:46:32 <younder> It probably does. In Lisp wi still call them octets
12:46:46 <joe9> How do I build an Arbitrary instances when the values are not sequential Enum values: http://dpaste.com/25FNDPS is my code . The line 97 hangs when I run quickcheck. This is the bitmask code: http://dpaste.com/1R1GD0X
12:47:32 <joe9> is it because of the use of foldr? in line  28 of the BitMask code?
12:47:48 <monochrom> Only fractional numbers of bits are funny.
12:48:09 <monochrom> Along with "the average programmer indents by 3.72938 spaces"
12:48:44 <ongy> how many spaces would a tab be for that count?
12:48:49 <sham1> Yes
12:49:01 <younder> I have a problem with that thigs like forld are basicallly unparalizabele loops.
12:49:24 * geekosaur reminded of a stat from the 1970s about US families having an average of 2.3 kids... leading to a lot of jokes about where the extra 0.3 kid was
12:49:31 <younder> I have a problem with that things like fold are basicallly unparalizabele loops.
12:49:33 <monochrom> well, list is pretty sequential to begin with
12:49:42 <joe9> younder:  replace foldr with foldl'?
12:49:53 <monochrom> but you get to complain that tree fold is also unparallelized
12:49:53 <younder> zip is fine parelellizapbele
12:50:40 <younder> fold is that bastard that will always hur paralell performance
12:50:54 <ongy> use foldMap if possible then
12:51:18 <joe9> ongy: foldMap for me? Thanks.
12:51:48 <ongy> joe9: that was more to younder. I have no idea about arbitrary, sorry
12:52:20 <geekosaur> Arbitrary for a Reader sounds wrong
12:52:33 <geekosaur> because a Reader is a newtype over a function
12:52:42 <geekosaur> @unmtl Reader r a
12:52:42 <lambdabot> r -> a
12:53:56 <geekosaur> I wish you luck generating arbitrary functions
12:54:07 <monochrom> geekosaur: It turns out that the semantics of "every person is happy" requires shift-reset to get you back to "forall p. p is happy". So I think sentences like "the average person has 9.999 fingers" is similar.
12:54:25 <younder> Serisosly the flodl and the foldr serialim compromize paralell performane. They are are basically unparaleizableloppps
12:55:21 <younder> and they are not just in the top they are key functions and not easy to get rid of
12:55:32 <amalloy> i'm starting to think younder is stuck in an unparalizabele loop
12:56:06 <ongy> joe9: do you know if quickcheck genererates infinite lists? that would hang in toBitMask
12:56:19 <sham1> I think he is udping TCP packages he is sending to this IRC server
12:56:22 <younder> yes, fold is evil, fold compromizes haskell's  future
12:56:24 <sham1> UDPing*
12:56:51 <geekosaur> apparently any algorithm that requires collecting values is not a true algorithm
12:57:05 <geekosaur> (also I wonder if younder has ever heard of mapreduce)
12:57:42 <ongy> :t foldMap -- isn't this pretty exactly mapreduce?
12:57:45 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
12:57:52 <sham1> Distributed mapreduce, so we may have a webscale database
12:57:58 <joe9> ongy, good point. https://paste.pound-python.org/show/mtqjrKvukxO9o32FunyA/
12:58:14 <joe9> https://paste.pound-python.org/show/mtqjrKvukxO9o32FunyA/ I can replace the foldr there with foldMap, correct?
12:58:59 <joe9> ongy:  I do not think QuickCheck is generating an infinite list. I think there is something wrong with the toBitMask instance for the list.
12:59:05 <ongy> joe9: you need the Monoid instance. Maybe there's some Or newtype. But if you don't mind the newtype wrapping/unwrapping, go for it
12:59:29 <sham1> Doesn't that get optimised away anyway?
12:59:30 <younder> geekosaur, of cource I have herad of mapreduce, or scatter-gather, or  whatever you wish to call it
12:59:32 <geekosaur> ongy, no, because mapreduce is about splitting the list into chunks, distributing them to workers, and then reducing across the results. foldMap does not distribute work to other threads or processors
12:59:38 <joe9> ongy: let me try replacing foldr with foldl' and try.
12:59:38 <monochrom> clearly, true algorithms compute those and only those who don't compute themselves.
12:59:41 * hackagebot bitcoin-payment-channel 0.5.0.0 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.5.0.0 (runeks)
12:59:53 <geekosaur> so it's just not an actual mechanism, since it is a distributed fold?
13:00:44 <younder> true functtinal programming NEEDS to reduce the number of lops. Or else it will never be fully paralellizable
13:00:59 <sham1> And will not be webscale?
13:01:23 <younder> Haskell has yest to reach that target
13:01:30 <ongy> geekosaur: ah, right, but we could do one with the same type (I guess result would be in IO), or is there something preventing that?
13:01:53 <younder> It's core libraries still depend to much on a fold
13:01:55 <geekosaur> ongy, there's a whole Control.Parallel.Strategies about this
13:02:04 <younder> That IS the truth
13:02:29 <geekosaur> yes, as is the truth that computers are not required to do anything useful, merely to be perfectly parallelizeable
13:02:31 <monochrom> you can use "par" without incurring IO.
13:02:51 <geekosaur> because when you need to do something useful, you often need to do something that does not parallelize perfectly
13:03:11 <younder> geekosaur: we have work to do, you and I
13:03:17 <geekosaur> maybe you do
13:03:36 <younder> geekosaur:  yes maybe me 
13:03:44 <ongy> geekosaur: ohh, now I just need to find a usecase where I can benefit from them
13:04:15 <younder> geekosaur:  This is not some promo
13:04:23 <younder> geekosaur:  This is survival
13:04:32 <geekosaur> no, it sounds like a troll
13:04:41 * hackagebot bitcoin-payment-channel 0.5.0.1 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.5.0.1 (runeks)
13:04:47 <geekosaur> why does making something not useful equate to survival?
13:05:18 <sham1> A lot of companies do that and they seem fine /s
13:06:12 <younder> geekosaur:  This is love of the functional paradigm, but with a twist, I will add category theory, at the CORE. Make the computer reason in Category theory. Make it proove instead of test. Now that is prety cool
13:06:18 <joe9> if I add this line, the Quick check hangs    && toBitMask m1 == toBitMask m2
13:06:45 <joe9> same result with foldr and foldl'
13:09:21 <joe9> other than adding trace statements , is there a better way of debugging this?
13:09:35 <younder> Geekosaur: it doesn't
13:09:39 <joe9> I read about Hood, but, not sure how maintained it is or if it works.
13:09:41 * hackagebot dbmigrations 2.0.0 - An implementation of relational database "migrations"  https://hackage.haskell.org/package/dbmigrations-2.0.0 (JonathanDaugherty)
13:09:43 * hackagebot dbmigrations-sqlite 2.0.0 - The dbmigrations tool built for SQLite databases  https://hackage.haskell.org/package/dbmigrations-sqlite-2.0.0 (JonathanDaugherty)
13:09:45 * hackagebot dbmigrations-postgresql 2.0.0 - The dbmigrations tool built for PostgreSQL databases  https://hackage.haskell.org/package/dbmigrations-postgresql-2.0.0 (JonathanDaugherty)
13:09:47 * hackagebot dbmigrations-mysql 2.0.0 - The dbmigrations tool built for MySQL databases  https://hackage.haskell.org/package/dbmigrations-mysql-2.0.0 (JonathanDaugherty)
13:09:54 <ongy> joe9: I would trace it
13:10:11 <joe9> ongy, adding trace or traceShow, correct?
13:10:25 <joe9> ongy, or hat?
13:10:36 <mlife_> is this similar to how u guys would tackle my last func? http://lpaste.net/292174
13:10:41 <ongy> I would try it with traceShowId, yes
13:11:15 <younder> Geekosaur: Ill be 50 next year. You are nor the only dinosaur here ;)
13:11:20 <geekosaur> hat's bitrotted beyond usability
13:12:07 <younder> Geekosaur: Well I haven't
13:12:24 <joe9> younder: what about this? http://projects.haskell.org/hat/
13:12:51 <younder> not yet
13:12:55 <geekosaur> joe9, hat required knowledge of compiler internals to annotate data types. it doesn't work past ghc 6.6
13:13:13 <ongy> mlife_: you have a few syntax errors in there. I'm not quite sure what you want to do
13:13:34 <geekosaur> hood/ghood was one successor. there's also ghc-vis which you can use while stepping evaluation in ghci
13:13:34 <mlife_> yeah disregarding the syntax
13:14:23 <mlife_> and im not saying the logic is complete, im asking if thats somewhere along the line
13:16:25 <ongy> looks about right to me
13:16:26 <joe9> younder: this line does not show any output: just seems to hang in there -- && traceShowId (toBitMask (traceShowId m1)) == toBitMask (traceShowId m2)
13:16:28 <geekosaur> joe9, in fact I think ghc-vis is the currently best supported of those. but none of them will be very helpful for an infinite loop unless you are stepping evaluation in ghci
13:16:41 <geekosaur> otherwise you'll just get massive amounts of output
13:16:50 <geekosaur> too fast to see what's going on
13:17:01 <younder> _mlife: yes somthing alog the line. Byt mre proovable and more paralell
13:17:15 <ongy> younder: don't confuse newbies
13:17:20 <joe9> geekosaur: ok, Thanks.
13:17:37 <sham1> mlife_, one thing I suggest is that you get yourself hlint
13:17:40 <younder> ongy.
13:19:02 <younder> :ongy:  sory in mirc you appear in yeallow which is practiacally unreadble to me. But I will try not to cofuse newbies
13:19:28 <joe9> is there a library function to just or all the values in a list? such as sum, etc. other than writing our own foldl' function.
13:19:49 <mauke> :t or
13:19:50 <lambdabot> Foldable t => t Bool -> Bool
13:19:50 <joe9>  https://paste.pound-python.org/show/LVRWMapDdvDF7dhm2Flw/
13:20:10 <Tuplanolla> @src or
13:20:11 <lambdabot> or = foldr (||) False
13:20:12 <joe9> mauke:  I am talking about the (.|.) of Data.Bits
13:21:35 <Tuplanolla> I was expecting `or = any id`.
13:22:36 <ongy> :t Or
13:22:38 <lambdabot> error:
13:22:38 <lambdabot>     • Data constructor not in scope: Or
13:22:38 <lambdabot>     • Perhaps you meant one of these:
13:23:44 <ongy> :t getAny . foldMap Any -- Tuplanolla for all the fun
13:23:46 <lambdabot> Foldable t => t Bool -> Bool
13:24:13 <Tuplanolla> I was expecting that.
13:24:55 <joe9> https://paste.pound-python.org/show/zXSA54gOh1hxFi25e3ov/ is how I defined my data type.
13:25:11 <joe9> I suspect that the issue could be caused as I do not have a continuous enum
13:25:36 <younder> Python?
13:26:26 <joe9> younder: wgetpaste picked that.
13:26:41 <younder> I mean Python is a fine language. But it is not Haskell which wi discuss here.
13:27:04 <joe9> younder: my code is haskell. Did it get formatted as Python?
13:27:35 <younder> nop
13:27:55 <systemfault> Someone saw the word "python" in the url and led that person into false assumptions.
13:28:29 <joe9> when I derive Enum, Bounded it works fine.
13:29:04 <younder> systemfault, basically me, sorry
13:29:25 <jle`> :t ala Any foldMap
13:29:27 <lambdabot> Foldable t => t Bool -> Bool
13:29:27 <younder> This is crearly haskell
13:30:01 <younder> Though just some basic defintitons no cade
13:30:21 <younder> code
13:30:38 <Tuplanolla> That's a lens, isn't it, jle`?
13:30:46 <joe9> geekosaur: ongy: when I add this instance, https://paste.pound-python.org/show/ZExLlsRO6bnL8P9NRTlQ/ , it hangs the process. When I use derive Enum, it works fine.
13:30:49 <ongy> :t ala
13:30:50 <jle`> Tuplanolla: what's a lens?
13:30:51 <lambdabot> (Rewrapped t s, Rewrapped s t, Functor f) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> f s) -> f (Unwrapped s)
13:30:59 <younder> anm SType and a cople of instances
13:31:14 <joe9> younder: http://dpaste.com/3PRWE4Q
13:31:29 <Tuplanolla> Rather "from lens", jle`.
13:31:30 <joe9> younder: http://dpaste.com/3X87Z4D
13:31:35 <younder> That is better
13:31:54 <joe9> maybe I should use something different than this:   arbitrary = QC.arbitraryBoundedEnum
13:31:54 <geekosaur> users of Enum do not expect there to be gaps
13:32:23 <geekosaur> :t succ
13:32:25 <lambdabot> Enum a => a -> a
13:32:30 <younder> seems to me this should work
13:32:31 <jle`> Tuplanolla: it is :o but the way it works doesn't really rely on any lensy mechanisms
13:32:37 <joe9> geekosaur: I added this   toEnum _  = Unknown and   fromEnum Unknown                = 28
13:32:40 <jle`> ala Any f = getAny <$> f Any
13:32:43 <joe9> to take care of unknown values.
13:32:50 <jle`> ala Sum f = getSum <$> f Sum
13:32:58 <Welkin> allah!
13:32:59 <jle`> the main mechanism is just a simple typeclass
13:33:14 <Welkin> the mosque of haskell
13:33:27 <younder> This is nothing special setting some values and printing them
13:33:44 <geekosaur> joe9, but arbitraryBoundedEnum will expect the entire range from minBound to maxBound to be populated. fromEnum will throw if handed 9, for example
13:33:56 <geekosaur> or a value generated with it
13:33:58 <ongy> jle`: is that autoderived on newtypes?
13:34:07 <jle`> ongy: i think it's derived by hand
13:34:27 <younder> geekosaor: I see no generation
13:34:29 <Welkin> template haskell can do anything though
13:34:44 <joe9> geekosaur: Can I try with fromEnum _ = 28? Would that fix the issue?
13:34:54 <ongy> can it do concurrency?
13:35:14 <younder> geekosaor: perhaps you can see the error that I can't see
13:35:15 <jle`> the derivation?
13:35:17 <joe9> geekosaur: no, it does not. I think I should use the arbitrary to generate a Word32
13:35:21 <geekosaur> joe9, I doubt it. there are a lot of functions that assume that there are no gaps; you can do your fromEnum/toEnum but succ will produce garbahe
13:35:51 <joe9> geekosaur:    QC.arbitrarySizedBoundedIntegral -- I will try to see how I can use this function instead.
13:35:58 <younder> I'll import and run it ad see what I see
13:36:25 <geekosaur> not sure that will help either, but today seems to be a day when we all believe what we want instead of what the implementation does, so go nuts
13:36:27 <jle`> ongy: if you're talking about 'ala', i showed you the entire function there pretty much
13:36:38 <jle`> ongy: ala Any = getAny <$> f Any
13:36:52 <joe9> geekosaur: what do you recommend?
13:36:57 <jle`> ongy: it's not magical
13:37:09 <ongy> jle`: that was towards Welkin's TH remark
13:37:09 <jle`> @let alaAny f = getAny <$> f Any
13:37:11 <lambdabot>  Defined.
13:37:14 <geekosaur> joe9, I see you using a Haskell Enum as if it were a C enum. it's not
13:37:16 <joe9> geekosaur: just add junk values to make it continuous?
13:37:25 <jle`> > alaAny foldMap [True,False,True]
13:37:29 <lambdabot>  True
13:38:05 <geekosaur> I would probably make a newtype over a value chosen from a list, and use a smart constructor to produce such values, and an Arbitrary instance that picks values from the list
13:38:54 * juri_ uses runEval for the first time.
13:39:07 <ongy> jle`: is the <$> there used as (.)?
13:39:31 <joe9> geekosaur:  can you think of any sample code that follows this approach?
13:40:45 <joe9> geekosaur: on a different note,     name <- BS.pack <$> QC.arbitrary is how I generated a ByteString. I need to figure out how to generate a [ByteString].
13:41:23 <geekosaur> shouldn't there already be an Arbitrary for [a] given an Arbitrary for a?
13:41:54 <byorgey> there is.
13:42:33 <joe9> but, there is no ByteString Arbitrary
13:42:42 <ruski_> hi all. need some help on optimising memory used by my program. it's a simple counter of how frequenly elements occur in a list, i'm just working on a massive list. for elements i'm using bytestrings (i found those more efficient than Text), and my data structure is a vector, with a hashmap to produce count tuples. that still uses too much memory
13:42:50 <younder> stats.hs:3:7: parse error on input ‘,’
13:43:14 <joe9> byorgey: geekosaur , so, would it be (QC.arbitrary (BS.pack <$> QC.arbitrary))?
13:43:16 <Welkin> ruski_: stream the data using pipes or conduit
13:43:20 <joe9> to generate a [ByteString]
13:43:32 <ruski_> thanks Welkin 
13:43:38 <Welkin> ruski_: you can keep memory usage constant
13:43:47 <geekosaur> joe9, seems to me you just described one. did you for some reason not actually make an Arbitrary instance? (it would be an orphan but that's fine in a test program, just not in a library)
13:44:14 <joe9> geekosaur: I was trying to avoid the orphan instance error
13:44:16 <ruski_> are pipes and conduit similar in use-case?
13:44:19 <joe9> s/error/warning/
13:44:58 <Welkin> ruski_: I prefer pipes
13:45:09 <Welkin> ruski_: yes, they do the same thing
13:45:15 <geekosaur> you are going to make using quickcheck much harder than it needs to be. tests are a place where orphans are considered fine and even expected for many use cases
13:45:39 <ruski_> the case is here, is that the input is already streaming.
13:45:48 <joe9> geekosaur: ok, Thanks.
13:46:10 <geekosaur> you just have to keep them out of the library, which may mean a separate testing library that most people wouldn't install
13:46:29 <ruski_> code goes through hadoop
13:46:42 <joe9> geekosaur:  ok, Thanks.
13:47:41 <geekosaur> ruski_, "stream" here refers to the data flow within the haskell program. a stream in haskell would be appropriate for a stream of data coming from elsewhere, and that is where pipes or conduit come in
13:48:40 <ruski_> thanks for the clarification geekosaur 
13:48:48 <geekosaur> which you use is to some extent a religious argument, although you may want to look at what helper packages already exist that might do what you need
13:49:15 <Welkin> yeah, sometimes there is a library that uses one or the other that you might want to use
13:50:17 <joe9> geekosaur: when I go with this approach: newtype SType = SType {unSType :: Int} , I lose the functionality provided by  http://dpaste.com/3G24NW1
13:51:15 <joe9> geekosaur: Are you recommending using both newtype and the deriving Enum?
13:51:38 <Welkin> GeneralizedNewtypeDeriving
13:51:43 <geekosaur> joe9, no I am not. why do you need this to be what it is not (that is, Enum)?
13:51:44 <joe9> geekosaur: or, I would have to rewrite the ToBitMask class
13:52:00 <geekosaur> again, Haskell Enum is not C enum
13:52:32 <joe9> geekosaur: I like using the ToBitMask class. It will show me a list of all actual bit values, instead, of trying to figure out what bits are set manually.
13:56:32 <joe9> geekosaur: I will just do this.
13:56:36 <joe9> https://paste.pound-python.org/show/Pzw1QcLKgxkg6eO1Vqds/ geekosaur
13:57:39 <younder> just https://wiki.haskell.org/Haskell
13:59:16 <younder> thx geekosaur
14:02:26 <joe9> geekosaur: or, I can change the BitMask class to use Ord a instead of Enum a and try to figure out if I can assign Ord values to the data types?
14:08:49 <geekosaur> sorry. I had some code that expands bitmasks, but am not remembering where I put it (and just spent several minutes scanning the wrong thing because it *should* have been using it for something...)
14:09:57 <joe9> geekosaur:  Thanks, if you remember, please let me know. It would be a good experience to figure out how it works. Thanks.
14:13:04 <joe9> geekosaur: do you recall if you used Enums too?
14:13:19 <geekosaur> I did not
14:13:53 <geekosaur> although the code I just found deciphers bits in a CInt, so it's not actually relevant :(
14:14:35 <geekosaur> (bitmask comes from low level FFI stuff so no point in trying to make it Haskelly)
14:15:22 <lpaste> Tuplanolla pasted “Infinite List with Mutable Backing Storage” at http://lpaste.net/293070
14:15:40 <Tuplanolla> How can I make this silly idea a reality?
14:16:22 <drninjabatman> hello
14:16:26 <Tuplanolla> Right now it cannot deduce `PrimMonad (ST s)` for `VM.replicate`.
14:17:52 <Tuplanolla> I basically want a mutable closure for `ST` that I can use to lazily generate an infinite list.
14:18:09 <glguy> Tuplanolla: The Lazy ST doesn't have a PrimMonad instance
14:18:12 <drninjabatman> I have a class `class Generic a => MyCls a` and then I want to do `data H a = MyCls a => H a deriving (Generic); instance Hashable (H a);`
14:18:49 <drninjabatman> but I am getting `Can't make a derived instance of ‘Generic..`
14:19:52 <glguy> drninjabatman: You can't make a Generic instance for the H type due to the MyCls constraint on the H data constructor
14:20:46 <drninjabatman> glguy: hmm, so the only way to restrict what `a` can be is type families?
14:21:03 <glguy> drninjabatman: Or better is to put the restriction on the functions that use H
14:21:15 <haasn> It would be great if I could combine `attoparsec` and `binary` somehow, to give me the equivalent of a `Get a -> Parser a` function. I'm wondering whether this doesn't exist somewhere already?
14:21:33 <haasn> Ah, there's attoparsec-binary for this
14:21:34 <mlife> http://lpaste.net/292174 how do I go about applying this logic but individually for each elem in the list? for my last function
14:21:59 <haasn> Oh, that's a different meaning of the word `binary`; but in my case it's still sufficient (I just want to parse 32-bit words)
14:22:22 <lpaste> Tuplanolla revised “Infinite List with Mutable Backing Storage”: “Infinite List with Mutable Backing Storage” at http://lpaste.net/293070
14:22:22 <drninjabatman> glguy: Hmm I'll try that
14:22:37 <Tuplanolla> That one compiles, but is obviously not lazy enough.
14:23:35 <ongy> mlife: remove the 'list' inside the parens in line 42
14:24:23 <ongy> also the 'length' in the same line will give you an error, because the result type of update is [Str a] 
14:24:59 <haasn> Hmm, although I'm still struggling to do some other things in attoparsec. I guess what I really want is to do most of my parsing in `get`, the only reason I'm interested in attoparsec is because I want to parse a list of structures (where I don't know the length of the list in advance)
14:27:00 <glguy> haasn: Why isn't binary's Get suitable for parsing a list of structures where you don't know the length in advance?
14:27:20 <Tuplanolla> Can I define a `PrimMonad` instance for lazy `ST` then, glguy?
14:27:50 <haasn> glguy: Oh, there's `isEmpty`; I guess that makes it just as suitable (if I write the loop myself)
14:29:05 <glguy> Tuplanolla: https://github.com/haskell/primitive/issues/24
14:29:12 <ongy> haasn: you may like ControlMonad.Loops.whileM
14:29:22 <mlife> ongy: would that make the function work? as intended
14:29:44 <Tuplanolla> That sucks.
14:29:55 <glguy> Tuplanolla: I haven't thought through the consequences (if any) of such an instance)
14:30:08 <ongy> mlife: I think. But I do make mistakes from time to time
14:31:10 <Tuplanolla> Can I get around this with `unsafeInterleaveST` or such?
14:32:14 <Tuplanolla> Apparently I can. Neat.
14:32:47 <lpaste> Tuplanolla revised “Infinite List with Mutable Backing Storage”: “Infinite List with Mutable Backing Storage” at http://lpaste.net/293070
14:35:52 <mlife> ongy: wouldnt removing the second arg of contains make it wrong?
14:36:09 <ongy> :t filter
14:36:11 <lambdabot> (a -> Bool) -> [a] -> [a]
14:36:24 <haasn> ongy: I guess, don't like pulling in a lib just for that though. Not a big deal
14:36:39 <Tuplanolla> I don't even need the freezing and thawing now that the do blocks unify.
14:37:14 <ongy> mlife: you want to give a function with type 'Str a -> Bool' to filter
14:37:42 <mlife> nvm nvm , but actually I am doing the opposite haha
14:39:24 <mlife> how can I filter the ones that ARE contained - like remove them
14:39:47 <ongy> negate the filter function, e.g. with not
14:39:51 <Welkin> mlife: not
14:40:04 <Gurkenglas> mlife, Data.List has isPrefixOf and isInfixOf
14:41:59 <Gurkenglas> Wait you even used isPrefixOf in overlap why would you define prefix
15:08:22 <Gurkenglas> mlife, the arguments to update should be in the other order, and whatever is calling update should be the only one calling o, with s'' being passed to update instead of (s,s')
15:10:26 <mlife> http://lpaste.net/292174 it was assigned, hmm but after revising the code and making some changes , how would you use not  , in the condition right? not the function
15:10:32 <lpaste> Gurkenglas annotated “No title” with “mlife, with those adjustments, I'd do it like so.” at http://lpaste.net/292174#a293323
15:10:52 <Gurkenglas> (lpastebot's slow today)
15:32:23 <drninjabatman> do type synonyms not have kinds?
15:32:43 <dolio> They do have kinds.
15:33:32 <drninjabatman> so I have type `type QSet a = HS.HashSet (Query a)`
15:33:38 <drninjabatman> and `class QRebasable (q :: * -> *) (qc :: * -> *) | q -> qc where ...`
15:33:54 <drninjabatman> but I can't make `instance QRebasable QSet QSet where ...`
15:34:17 <dolio> Just because they have kinds doesn't mean they work in all the same places as other things.
15:34:30 <drninjabatman> I get `The type synonym ‘QSet’ should have 1 argument, but has been given none`
15:34:37 <drninjabatman> is there a way to get around that?
15:34:47 <dolio> No.
15:35:15 <drninjabatman> Could you give me any leads on why I am getting this error?
15:35:48 <dolio> You're getting the error because you're trying to make an instance for a partially applied synonym, which is not allowed.
15:35:57 <dolio> You need to make it not a synonym if you want to partially apply it.
15:37:59 <Gurkenglas> The problem is that the compiler desugars type synonym definitions before it desugars instance definitions.
15:38:24 <dolio> Well that's not the only problem.
15:38:38 <drninjabatman> is there a way to compose types? In my case HashSet . Query 
15:38:47 <drninjabatman> to get a type with the right kind?
15:38:49 <Gurkenglas> You can define a newtype, or use Compose
15:39:14 <Gurkenglas> (Which is also a newtype, but someone else already defined it for you)
15:39:22 <drninjabatman> Yes! compose sounds great!
15:39:23 <drninjabatman> damn
15:39:41 <drninjabatman> I wanted to still be able to use the HashSet functions
15:41:03 <EvanR> HashSet `o` Query
15:41:37 <amalloy> a good irish professor's name
15:43:00 <mlife> Gurkenglas: thanks lot, it did the job
15:58:09 * byorgey bakes lambda pies for everyone
16:03:31 <bogdanteleaga> :t liftM
16:03:33 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
16:03:42 <bogdanteleaga> :t liftM3
16:03:43 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
16:04:16 <prohobo> BOHEMIA
16:05:02 <EvanR> that liftM signature is a little rough isnt it
16:05:18 <EvanR> like it was inferred
16:08:30 <mlife> http://lpaste.net/293582 how would I go onto 'looping' trhough a list elements comparing each one to all of the rest? in the last function
16:10:05 <EvanR> you can do 
16:10:30 <EvanR> > [(i,j)| i <- [1,2,3,4], j <- [1,2,3,4]]
16:10:32 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
16:10:56 <EvanR> > filter (\(x,y) -> not (x == y)) [(i,j)| i <- [1,2,3,4], j <- [1,2,3,4]]
16:10:59 <lambdabot>  [(1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)]
16:11:33 <EvanR> unordered pairs seems trickier
16:13:50 <Boomerang> > let f xs = filter (uncurry (/=)) $ zip xs xs in f ["one", "two", "three"]
16:13:53 <lambdabot>  []
16:14:13 <Tuplanolla> > Data.Set.toList . powerset . Data.Set.fromList $ [1, 2, 3, 4]
16:14:15 <Boomerang> obviously not zip
16:14:48 * hackagebot hw-rankselect 0.5.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.5.0.0 (haskellworks)
16:14:50 <lambdabot>  [fromList [],fromList [1],fromList [1,2],fromList [1,2,3],fromList [1,2,3,4]...
16:15:34 <Tuplanolla> Disregard that; I wasn't thinking.
16:16:02 <EvanR> theres a good way, thinking
16:16:15 <ab9rf> we're allowed to think?
16:16:18 <Tuplanolla> It often helps.
16:16:26 <jle`> strictly forbidden
16:16:33 <Welkin> think with your heart
16:17:04 <Tuplanolla> There should still be a "subsets of size n" function somewhere.
16:17:18 <Welkin> Tuplanolla: subsets, then filter by length
16:17:29 <Tuplanolla> Sounds like a good way to spend a lot of time.
16:19:48 * hackagebot keysafe 0.20161022 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20161022 (JoeyHess)
16:21:36 <EvanR> > let f (x:xs) = map (\i -> (x,i)) xs; f [] = [] in [1,2,3,4] >>= f
16:21:38 <lambdabot>  error:
16:21:38 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M454233877601...
16:21:38 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
16:21:53 <EvanR> > let f (x:xs) = map (\i -> (x,i)) xs; f [] = [] in tails [1,2,3,4] >>= f
16:21:56 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
16:23:19 <EvanR> a tuplesections, lambdacase later...
16:24:22 <mlife> EvanR: so update is not even encessary?
16:24:28 <EvanR> update ?
16:25:05 <EvanR> i only looked at the last function
16:25:32 <Boomerang> > let f xs = concat $ zipWith (\x y -> zip (repeat x) y) xs (tails xs) in f [1,2,3,4]
16:25:35 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)]
16:26:12 <EvanR> to get unordered pairs which arent the same, i thought about the upper or lower triangle of a matrix
16:26:22 <Boomerang> > let f xs = concat $ zipWith (\x y -> zip (repeat x) (tail y)) xs (tails xs) in f [1,2,3,4]
16:26:25 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
16:26:39 <EvanR> which you can get just by looping over tails and forming the pair with everything after the first element
16:27:00 <Welkin> you forgot about sonic
16:27:09 <Welkin> where does he come in?
16:28:00 <Tuplanolla> > [1, 2, 3, 4] & \ xs -> do {x <- xs; y <- xs; guard $ x < y; return (x, y)}
16:28:02 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
16:29:00 <Boomerang> We're forgetting all the reversed pairs (since we have to generate all pairs)
16:29:52 <Welkin> :t permutations
16:29:53 <lambdabot> [a] -> [[a]]
16:30:05 <Welkin> > permutations [1..4]
16:30:07 <EvanR> i specifically forgot the reversed pairs
16:30:15 <lambdabot>  [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4,...
16:30:42 <EvanR> > tails [1,2,3,4] >>= \case{[]->[]; (x:xs)-> map (x,) xs}
16:30:45 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
16:31:07 <Tuplanolla> I was looking for a way to use `join` for this, but failed.
16:31:56 <EvanR> combinations or "ways to do something" = list monad
16:32:50 <Boomerang> > let g = concatMap (\(x,y) -> [(x,y),(y,x)]) in g (f [1..3])
16:32:53 <lambdabot>  error:
16:32:53 <lambdabot>      • Could not deduce (Foldable t0)
16:32:53 <lambdabot>        from the context: (FromExpr (t (t1, t1)), Foldable t)
16:33:19 <EvanR> if you do want reversed pairs, you can just do a list comprehension
16:34:05 <EvanR> > let xs = [1,2,3,4] in [(i,j)| i <- xs, j <- xs, i /= j]
16:34:10 <lambdabot>  [(1,2),(1,3),(1,4),(2,1),(2,3),(2,4),(3,1),(3,2),(3,4),(4,1),(4,2),(4,3)]
16:35:15 <EvanR> actually, constructing that from my 1/2 list is probably better since it avoids the /=
16:35:42 <mlife> wait Im so lost onto which one was for me haha
16:35:50 <EvanR> not really sure
16:37:12 <Tuplanolla> Does `lens` contain a thing for converting a list to a pair?
16:39:02 <Tuplanolla> > tuple2 . filter ((== 2) . length) . subsequences $ [1, 2, 3, 4]
16:39:05 <lambdabot>  ([1,2],[3,4])
16:39:18 <Tuplanolla> > fmap tuple2 . filter ((== 2) . length) . subsequences $ [1, 2, 3, 4]
16:39:20 <lambdabot>  [(1,2),(1,3),(2,3),(1,4),(2,4),(3,4)]
16:39:26 <Tuplanolla> There we go.
16:40:40 <EvanR> length D:
16:40:56 <mlife> x.x
16:41:07 <Welkin> mlife: what's the m?
16:41:47 <mlife> m?
16:42:02 <Welkin> monad life?
16:43:03 <EvanR> life is like a box of Char
16:43:24 <mlife> ahh, medellin :) Col
16:44:57 <ab9rf> EvanR: could be worse, it could be an unboxed Char
16:45:01 <mlife> Tuplanolla: whats tupla2?
16:45:33 <Tuplanolla> It's some toy combinator from `mps`.
16:45:56 <Tuplanolla> It just slaps the first and last elements of a list into a pair.
16:48:45 <Profpatsch> Hm, do you guys know of a method to generate example input to parsers?
16:48:57 <Profpatsch> Something like quickcheck, but only the generating part.
16:49:22 <Profpatsch> Or maybe I can use just the generation part of quickcheck/smallcheck?
16:50:02 <mlife> Tuplanolla: tuple2 :: [Str a] -> (Str a, Str a) why would the variable not be in scope if passed a list of strings though
16:50:05 <Profpatsch> Background: Most RFCs specify their grammars with an ABNF (defined in https://tools.ietf.org/html/rfc5234)
16:50:21 <Profpatsch> But they almost never provide any examples for them.
16:50:42 <Tuplanolla> Don't use my solutions, mlife. They're terrible.
16:50:53 <mlife> haha
16:50:55 <Profpatsch> So autogenerating a few (which should be easily possible with the right approach) would help a lot in better understanding those.
16:51:13 <mlife> I mean it did what I need to do too
16:52:13 <Tuplanolla> It uses `length` and `last`, so I disagree.
16:53:05 <Profpatsch> Hm, I could use the listM :: Monad m => Depth -> Series m a -> m [a] function of smallcheck.
16:53:23 <Profpatsch> And then write a small pretty-printer.
16:53:30 <Profpatsch> Maybe there’s a better way?
16:54:31 <Tuplanolla> I shall leave before I propagate more bad ideas.
17:00:32 <NemesisD> is there a function like zip that can take 2 lists of differing length and interleave them with eachother?
17:01:02 <NemesisD> i.e. f [1,2] [3,4,5] = [1,3,2,4,5]
17:01:44 <NemesisD> ah i think it may be transpose
17:02:00 <Rotaerk>  hah: http://hoogle.com/
17:02:15 <EvanR> > transpose [[1,2,3,4],[5,6,7,8]]
17:02:17 <lambdabot>  [[1,5],[2,6],[3,7],[4,8]]
17:02:25 <EvanR> > transpose [[1,2,3,4],[5,6,7,8,9,10,11,12]]
17:02:27 <lambdabot>  [[1,5],[2,6],[3,7],[4,8],[9],[10],[11],[12]]
17:04:04 <jngrn> I'm wondering if anyone can help me understand something. Why is the result of this pure `lambda x. (lambda. (sideEffect x))`?
17:04:33 <mlife> Boomerang: how can I implement it with a list of strings?
17:04:58 <mlife> or where does In the first argument of ‘(.)’ comes from?
17:05:11 <EvanR> its pure because it has no side effects, and doesnt depend on any context
17:06:05 <EvanR> unless its a trick question, and that language has "impure functions" / procedures
17:07:13 <jngrn> I can see why the outer function is pure, but couldn't the inner function return different results and be impure?
17:07:50 <glguy> jngrn: Because if you're working in a language with only pure functions then all the functions are pure
17:07:51 <Boomerang> mlife: are you asking about the allPairs function? I think EvanR's answer should work for strings as well
17:08:27 <EvanR> mlife: you might be distracted by the Str a aspect of your question, but it has nothing to do with the question
17:09:09 <EvanR> we showed two ways to get all pairs, depending on if you want reflections or not
17:09:27 <jngrn> glguy: But what if `sideEffect` was a database call or http request.
17:09:50 * hackagebot hw-json 0.3.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.3.0.0 (haskellworks)
17:09:57 <Boomerang> if you want the remove the Eq a constraint you can do that by generating half of the tuples in one of the several ways shown and then create the "reversed" pairs
17:10:21 <EvanR> yes, use my code and do pairs ++ map swap pairs
17:10:30 <glguy> jngrn: Haskell doesn't have functions like that. If we were talking about Haskell what you'd get is a function that returns an action where if you executed the action that the database would be queried
17:10:49 <jle`> jngrn: it's impossible to answer your question without explaining what the thing you're talking about is
17:10:54 <jle`> is it a lambda caluclus function?
17:10:58 <jle`> is it a haskell function?
17:11:02 <jle`> is it a lisp function?
17:11:14 <EvanR> is it a math function
17:12:50 <jngrn> Sorry. I guess it's a lisp function.
17:13:17 <jngrn> `getFromStorage :: String -> (_ -> String)`
17:13:35 <mlife> EvanR: http://lpaste.net/293670 Im asking because it is not compiling
17:13:38 <jle`> well, it returns the same (_ -> String) no matter what
17:13:42 <jle`> so it's pure
17:13:53 <nitrix> Is there a way to get a list of the intermediate types inferred during unification? Sometimes tracking down an `ambiguous a0` is very painful.
17:14:20 <EvanR> jle`: jngrn agreed to that part
17:14:39 <glguy> jngrn: Lisp doesn't demand that functions be pure, so in that case your example might not be pure
17:14:46 <jle`> oh yeah, there's that too
17:15:01 <jle`> even in lisp, you might bet a different (_ -> String) when you pass in the same string twice
17:15:16 <nitrix> (The complaint isn't about the ambiguous type variable, but rather the `a0` that has been alpha converted from a large variety of `a` things).
17:16:30 <ertesx> mlife: you're using quite a portfolio of extensions there…  are you sure you enabled them?
17:16:36 <jngrn> I see so `(_ -> String)` itself doesn't need to be pure for the function as a whole to be pure.
17:17:04 <ertesx> mlife: ideally write lines like this before the 'module' header: {-# LANGUAGE LambdaCase #-}
17:17:07 <EvanR> jngrn: indeed
17:17:46 <ertesx> mlife: that way you don't have to use command line flags, and readers of your code will be informed of the extensions used
17:18:27 <jngrn> I'll ponder on this. Thanks!
17:20:06 <mlife> http://lpaste.net/293670 :) ?
17:20:39 <ertesx> mlife: still incomplete
17:20:48 <ertesx> i see at least one more extension there
17:21:10 <ertesx> mlife: hint: in most cases the compiler will tell you which extensions you need
17:21:27 <jle`> mlife: can you post the compile error?
17:21:40 <jle`> usually the compiler error contains instructions on how to fix it
17:21:42 <mlife> tuplesection, 
17:21:47 <mlife> looking for the ext
17:21:51 <jle`> okay
17:21:54 <jle`> so, add tuplesections
17:22:14 <ertesx> mlife: yeah, if the compiler says something about "-XTupleSections", the extension is named TupleSections
17:22:31 <ertesx> (-X is the command line syntax for extensions)
17:23:23 <jle`> mlife: that's the nice thing about compiler errors -- if you read them, they help you fix what your problem is :)
17:25:04 <ertesx> in other words: you should always read what the compiler says, even if the sometimes 20 lines of output for a single error seem intimidating at first…  GHC is *really good* at gathering useful information that contains more than just "your code sux!" =)
17:26:05 <mlife> Couldn't match expected type ‘b0 -> c0’ with actual type ‘[Char]’ dont get this error though
17:26:45 <ertesx> mlife: under the lambda-case, second clause, what's the type of 'x'?
17:28:49 <ertesx> mlife: no, wait…  the code looks correct to me
17:29:20 <ertesx> no, it doesn't, sorry
17:31:00 <EvanR> #haskell is the best compiler
17:31:23 <ertesx> again sorry, yes, it does
17:31:52 <ertesx> the type is really weird
17:32:31 <ertesx> allPairs :: [a] -> [(a, a)]  -- it should be this
17:33:42 <Boomerang> How are you build your "Str a"? You should just do "abcde", the error makes it seem like you might be doing something like Str "abcde", Str is just a type alias though 
17:33:54 <Boomerang> *building
17:34:13 <hsgumby> when looking at custom monads, sometimes people just use a newtype, e.g. newtype IOEnv env a = IOEnv (env -> IO a), and sometimes I see it done with a record, like data IOEnv env a = IOEnv { unIOEnv :: env -> IO a }.  Does anyone know if there is any real non-stylistic difference?
17:34:31 <ertesx> the whole Str thing is irrelevant to this code…  mlife probably wants to find all pairs of a list of strings, but this function works for anything
17:34:47 <hsgumby> (like a difference at runtime)
17:34:48 <Boomerang> Yes, ertesx type signature is better
17:35:00 <monochrom> No runtime difference.
17:35:14 <geekosaur> hsgumby, the only difference between those is automatic definition of unIOEnv as a function
17:35:29 <glguy> The difference is in newtype vs data
17:35:42 <geekosaur> oj, newtype, missed that
17:35:43 <glguy> which will affect the strictness and memory behavior
17:35:56 <ertesx> hsgumby: the latter style is where all those run* functions are coming from
17:35:57 <geekosaur> so newtype is a bit faster in some cases and is stricter
17:36:04 <monochrom> I did assume s/data/newtype/
17:36:19 <ertesx> hsgumby: like:  newtype ReaderT e m a = ReaderT { runReaderT :: e -> m a }
17:36:24 <geekosaur> but you could define either of those forms as newtype or as data
17:36:53 <geekosaur> and the difference between the record form and the other is just definition of a function for you.
17:36:55 <hsgumby> ah; ok so ignoring newtype vs data (accidental difference here), sounds like it is just the function definitions?
17:37:19 <mlife> I see, too focused on trying to define it for str
17:37:29 <hsgumby> cool; thanks for the help
17:38:12 <ertesx> mlife: don't worry…  every new haskell programmer has a history of writing overspecialised types =)
17:39:07 <geekosaur> but some also write underspecialized types (unused polymorphism is sometimes expensive)
17:39:16 <geekosaur> s/unused/unnecessary/
17:39:28 <monochrom> and a future of not being able to decide which way to overgeneralize because GADTs adds non-unique generalizations.
17:40:58 <ertesx> add RankNTypes to the mix for a thrilling edge-of-the-seat story of a programmer's dilemma
17:41:12 <Boomerang> "s/unused/unnecessary/" is that search and replace from vim?
17:41:23 <ertesx> Boomerang: sed
17:41:28 <EvanR> ed
17:41:31 <ertesx> d
17:41:36 <ertesx> > tails "sed"
17:41:38 <lambdabot>  ["sed","ed","d",""]
17:41:46 <Boomerang> thanks :) I should learn that
17:41:51 <EvanR> (empty string) is the best editor name
17:42:03 <jle`> i never realized that 'sed' came from 'ed'
17:42:14 <monochrom> vim got it from vi, and vi got it from sed, and sed probably got it from ed
17:43:01 <pikajude> ed got it from editor, which got it from éditer
17:43:10 <pikajude> thanks france!
17:43:11 <geekosaur> vi got it from ed
17:43:12 <monochrom> (and now a turning point) and ed came from Ken Thompson, and Ken Thompson came from his parents...
17:43:14 <geekosaur> as did sed
17:43:27 <geekosaur> ed -> ex -> vi
17:43:41 <monochrom> what did ex do?
17:43:44 <geekosaur> (ex lives on as the : mode of vi/vim)
17:44:04 <monochrom> so "ex machina" could have been a unix command?
17:44:08 <ertesx> geekosaur: i'm wondering about your statement…  it seems only true in the context of type classes like overgeneralising Int to any Num/Eq
17:44:13 <EvanR> its really annoying when i end up in ex mode accidentally
17:44:21 <ertesx> geekosaur: is that what you meant?
17:44:51 * hackagebot hw-eliasfano 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-eliasfano-0.0.0.1 (haskellworks)
17:44:57 <pikajude> nobody wants ex mode
17:45:11 <geekosaur> ertesx, yes, non-typeclass functions usually get specialized by the compiler automatically
17:45:24 <geekosaur> but with typeclasses involved, this can't always be done
17:45:25 <ertesx> ok
17:46:31 <geekosaur> vim still has ex in it; press Q and you get the ex prompt. "vi" goes back into vi mode
17:46:48 <geekosaur> (this also works in real vi, but without the help messages)
17:47:26 <geekosaur> it may or may not have a symlink from vi or vim to ex, depending on distribution whims
17:48:25 <monochrom> https://en.wikibooks.org/wiki/Learning_the_vi_Editor/Vim/Modes w00t
17:49:14 <ertesx> main = do args' <- getArgs; case args' of "machina" : args -> withArgs args realMain; _ -> hPutStrLn stderr "Parse error: expected 'machina'"
17:49:16 <monochrom> actually https://en.wikipedia.org/wiki/Ex_(text_editor) is more direct
17:51:48 <fred-fri> given only a string time like 07:05:45PM, how can it be parsed and printed in 24h format? my searching only finds answers for how to parse strings that also have the date
17:52:40 <glguy> fred-fri: Using the parse and format functions in the "time" package
17:52:53 <monochrom> oh great there was also em between ed and ex.
17:53:06 * Clint squints.
17:53:52 <geekosaur> also, before sed there was gres (substituting version of grep)
17:54:29 <geekosaur> sed was actually an improvement :)
17:57:46 <EvanR> parseTimeM, interesting
17:58:02 <EvanR> you choose the manad to choose the failure behavior
17:58:48 <EvanR> though i guess Applicative wouldve been better in retrospect
17:59:20 <ertesx> how about Either String?
17:59:21 <glguy> neither Monad nor Applicative are appropriate
17:59:43 <ertesx> it's one of those historical fail'ures
17:59:51 <glguy> There was a phase in Haskell when Monad was used to hijack fail as an error response
18:00:17 <geekosaur> ob https://downloads.haskell.org/~ghc/6.6.1/docs/html/libraries/base/Data-Map.html#v%3Alookup
18:00:29 <monochrom> no, you want MonadZero or MonadCatch for "could err".
18:00:30 <EvanR> parseTimeM True defaultTimeLocale "%l:%M:%S%P" "07:05:45PM" :: Maybe TimeOfDay ===> Just 19:05:45
18:01:39 <monochrom> and yeah, I was there when Data.Map.lookup gave Monad m => m a
18:01:55 <ertesx> why not Either String?  i feel like any monad that can have failure with a String payload can easily lift Either String
18:02:10 <ertesx> (if all else fails use 'either')
18:02:14 <monochrom> OK, I agree with Either String quite simply
18:02:38 <monochrom> just like Data.Map.lookup is better off with simply Maybe a.
18:03:10 <monochrom> w00t, overpolymorphism :)
18:03:16 <ertesx> =)
18:03:56 <EvanR> for time format parsing i dont even want a String
18:04:04 <EvanR> its valid or it isnt
18:04:16 <ertesx> :t either (const Nothing) Just
18:04:18 <lambdabot> Either b a -> Maybe a
18:04:38 <monochrom> ooohhh, and users soon demand "helpful error message"
18:05:03 <ertesx> :t maybe (Left "your string sux!") Right . either (const Nothing) Just
18:05:04 <lambdabot> Either b1 b -> Either [Char] b
18:05:13 <ertesx> there, helpful error message
18:05:30 <ertesx> those functions even fuse nicely
18:05:30 <EvanR> Left "", Left "FFFFUUUUUU", and either (const Nothings) floating around really seem silly
18:06:05 <monochrom> No, the best fusion scheme ever is my:
18:06:09 <monochrom> @quote monochrom unsafe
18:06:10 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
18:06:11 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
18:06:16 <monochrom> err, the other one
18:06:20 <monochrom> @quote monochrom unsafeCoerce
18:06:20 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
18:06:58 <EvanR> lol
18:07:35 <monochrom> I now think "RealWorld# Is Not Enough" is better.
18:09:16 <ertesx> {-# RULES "fuse/safeCoerce" forall x. (unsafeCoerce (unsafeCoerce x) :: a -> a) = x #-}
18:09:25 <ertesx> whoops
18:09:34 <ertesx> {-# RULES "fuse/safeCoerce" forall x. (unsafeCoerce (unsafeCoerce (x :: a)) :: a) = x #-}
18:10:09 <EvanR> forall x... where x is not a type?
18:10:21 <ertesx> EvanR: it's a value in RULES
18:10:41 <ertesx> i'm not even sure type signatures are allowed
18:12:10 <geekosaur> "RULES, as in break the"
18:13:36 <ertesx> apparently not
18:20:02 <Mibaz> What's the naming convention for factory methods? Like methods I use to replace data constructors I don't export?
18:21:27 <ertesx> Mibaz: we call those smart constructors, and there is no convention
18:21:38 <ertesx> Mibaz: choose any name that makes sense
18:22:18 <Mibaz> ertesx: excellent thanks!
18:22:53 <ertesx> newtype SortedList a = SortedList { _fromSortedList :: [a] };  toSortedList :: (Ord a) => [a] -> SortedList a;  fromSortedList :: SortedList a -> [a]
18:24:24 <Boomerang> Maybe you could use the name of the data constructor with a lower case letter at the start
18:24:53 * hackagebot hw-balancedparens 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-balancedparens-0.0.0.1 (haskellworks)
18:26:48 <mlife> http://lpaste.net/293851 why is haskell so complicated? :@ how do I implement my min with this type of func?
18:26:56 <ertesx> (one of the more annoying things about OOP for me was all those pointless naming conventions, and how obsessive people would get over them)
18:26:57 <mlife> lst one in the paste
18:27:51 <ertesx> mlife: superstring?
18:29:01 <Boomerang> mlife your type signature shows 2 arguments to your function but the the function seems to only be taking one
18:29:40 <ertesx> no, it's rather confused about how many arguments it takes
18:29:55 <ertesx> in the first guard clause, it wants to be a list, but in the last one it wants to be a function
18:29:58 <mlife> http://lpaste.net/293851
18:30:00 <Boomerang> Yes and the recursive call wouldn't type check
18:30:38 <ertesx> mlife: first fix the type signature
18:30:42 <Sinestro> Is anyone else trying to get Haskell debugging working on OS X and struggling with dsymutil segfaults?
18:30:45 <Sinestro> *Has
18:31:08 <ertesx> mlife: also i'm not sure whether you're doing yourself a favour with the 'Str' type alias
18:32:28 <mlife> http://lpaste.net/293851 Type correct?
18:32:48 <mlife> hmm, trying to complete it like that
18:33:24 <ertesx> at least it's no longer a kind error, but i can't make enough sense of the description below to judge whether it's the type you want
18:34:16 <ertesx> mlife: next remember that you're taking both arguments, so all results should be of type (Str a)
18:35:02 <ertesx> only the first guard case is correct in that regard, and i'm not sure whether it's correct by accident
18:35:25 <ertesx> because the way you wrote the function i feel like it wants to result in a *list* of strings
18:36:46 <Mibaz> What IDEs do you guys use?
18:37:20 <ertesx> Mibaz: emacs + haskell-mode + haskell-interactive-mode
18:40:11 <Mibaz> ertesx: Maybe I'll try to get that to work. I tried to get Atom to work with me and failed miserably.
18:41:02 <ertesx> Mibaz: i remember that at least one person here uses it, so at least it should be possible
18:41:40 <ertesx> Mibaz: emacs and vim are probably the most popular ones though
18:42:04 <Mibaz> ertesx: Yeah I think it's possible but an hour and a half in I gave up. 
18:42:11 <mlife> ertesx: http://lpaste.net/293851 ?
18:43:25 <ertesx> mlife: should the result of superstring be a single string?
18:43:45 <mlife> yeah thats what im trying to
18:43:45 <mnoron> I've not got a great grasp on foldr. For example, why can we define length as length = foldr (\_ n -> 1 + n) 0?
18:44:40 <ertesx> mlife: now fix the final guard case, because that one results in a function
18:45:06 <ertesx> mnoron: by that definition:  length (x : xs) = 1 + length xs
18:48:58 <ertesx> mnoron: really just apply the definition of foldr:  length = foldr (\_ n -> 1 + n) 0;  foldr f z (x : xs) = f x (foldr f z xs),  therefore: length (x : xs) = (\_ n -> 1 + n) x (length xs) = 1 + length xs
18:54:11 <mlife> comment on this? http://lpaste.net/293851
18:56:53 <ertesx> mlife: can you show with some representative examples what that function is supposed to do?
18:57:30 <ertesx> i tried to understand the description in your comment, but couldn't really understand it
18:59:41 <ertesx> for example i have no idea what "combine" means in that text
19:01:33 <mlife> hmm I was told when asked about it something like 
19:02:21 <mlife> explain what  update and naive does -> then how naive is related to update -> thne how update is related to superstring
19:04:55 * hackagebot hw-rankselect 0.6.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-rankselect-0.6.0.0 (haskellworks)
19:05:52 <AlecTaylor> hi
19:06:41 <ertesx> mlife: i just noticed that your 'update' is wrong
19:07:35 <ertesx> mlife: is there a reason why you defined Str?
19:11:18 <mnoron> ertesx, Thanks. Tracing it out it's pretty clear to me what's going on. the book i'm reading just hand-waved the recursion away, which i think made it mroe confusing
19:11:59 <mlife> hmm trying to represent them like that
19:12:21 <nitrix> http://lpaste.net/293974
19:12:28 <nitrix> Hi, can someone tell me why I need two getSum ?
19:13:45 <nitrix> main' is printing the Num a => a, while main is somehow printing a Num a => Sum a
19:16:05 <nitrix> `asTypeOf` is confirming that the result of filterF is `Sum Int` in my case; how does the double getSum make any sense?
19:22:30 <mlife> T.T
19:22:32 <nitrix> Oh no it isn't. That's odd ._.
19:30:01 <pavonia> :t let filterF f xs = foldMap (\x -> if f x then pure x else mempty) xs in filterF (==5) [Sum 3, Sum 5, Sum 5]
19:30:04 <lambdabot> (Monoid (f (Sum a)), Applicative f, Num a, Eq a) => f (Sum a)
19:30:13 <pavonia> :t let filterF f xs = foldMap (\x -> if f x then pure x else mempty) xs in getSum $ filterF (==5) [Sum 3, Sum 5, Sum 5]
19:30:16 <lambdabot> (Num a, Eq a) => Sum a
19:30:26 <pavonia> :t let filterF f xs = foldMap (\x -> if f x then pure x else mempty) xs in getSum $ getSum $ filterF (==5) [Sum 3, Sum 5, Sum 5]
19:30:29 <lambdabot> (Num a, Eq a) => a
19:30:59 <nitrix> http://lpaste.net/293974
19:31:05 <nitrix> I updated the lpaste; I figure it out :)
19:31:48 <nitrix> I misunderstood the purpose of filterF.
19:43:38 <ertesx> i would have liked to know which book
19:43:50 <ertesx> hand-waving recursion away doesn't seem like a good idea
19:43:58 <ertesx> especially for beginners
19:44:20 <ertesx> actually: hand-waving in general is bad
19:50:01 <Boomerang> I am getting the following error from ghc: "Couldn't match expected type ‘'GT’ with actual type ‘CmpNat ((2 * i0) + 2) (2 * i0)’ The type variable ‘i0’ is ambiguous"
19:50:41 <Mibaz> When I make helper functions should I define them on their own or shove them all into a "where" block? Generally, I mean. Obviously big functions should be defined on their own.
19:50:41 <Boomerang> It seems to me that ghc should be able to handle such comparaison without needing to know what i0 is (as long as it's a KnownNat)
19:52:30 <thoughtpolice> Boomerang: GHC isn't very good at this by default at the moment and its solver for things like equalities is very basic. These are known problems; the plugins written for the Clash compiler (Haskell -> Verilog) may be able to help you: https://github.com/clash-lang
19:52:53 <Boomerang> That's the one I'm using :)
19:53:39 <Boomerang> And I am already using the extra solver suplied, I assumed this was a more simple error since CmpNat is defined in base
19:54:37 <thoughtpolice> It's hard to say OTTOMH. Reporting it to the clash tracker is probably best; Christiaan can probably deduce where the real issue lies.
19:55:11 <Boomerang> Alright I'll ask him tomorrow on #clash-lang
19:55:40 <Boomerang> Thanks!
20:18:35 <mrkgnao_> morning
20:18:49 <ertesx> Mibaz: size has nothing to do with whether a function should be top-level or not
20:19:22 <mrkgnao_> why does doing pure (+5) <$> Just 6 <*> Just 5 "ignore" the 6?
20:19:24 <ertesx> if it only makes sense in the context of a definition, it should be part of it, even if it's large…  if it makes sense standalone, it should be top-level, even if it's small
20:19:36 <mrkgnao_> as in, I can change the 6 to any number and still get Just 10
20:19:58 * hackagebot hw-balancedparens 0.0.0.2 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.0.0.2 (haskellworks)
20:20:29 <Mibaz> ertesx: Thank you
20:20:33 <ertesx> mrkgnao_: the function (\x y -> x + y + 5) is not the same as the function (\x -> x + 5)
20:20:35 <mrkgnao_> I think I sort of "extended" the function (+5) by one argument and then ended up ignoring it
20:20:43 <fred-fri> noob having some troubling parsing time http://pastebin.com/Pqver5NY
20:21:17 <mrkgnao_> can you elaborate, @ertesx? I agree with what you're saying but don't see exactly how that relates
20:22:50 <geekosaur> fred-fri, the format you gave it expects 07:05:45:PM
20:24:22 <fred-fri> geekosaur, your patience and ability to help noobs out is seemingly endless
20:24:26 <fred-fri> geekosaur++
20:24:39 <Mibaz> geekosaur: geekosaur++
20:24:48 <mrkgnao_> can someone help me?
20:25:03 <mrkgnao_> why does writing pure (+5) <$> Just 6 <*> Just 5 "ignore" the 6?
20:26:44 <benzrf> is that well-typed?
20:26:51 <benzrf> oh
20:26:52 * geekosaur tries to figure out what that is even doing
20:26:56 <benzrf> i see
20:26:59 <benzrf> geekosaur: pure there is for Reader!
20:26:59 <geekosaur> :t Just 6 <*> Just 5
20:27:01 <lambdabot> (Num (a -> b), Num a) => Maybe b
20:27:26 <benzrf> mrkgnao_: you want to either get rid of the `pure' or else change the (<$>) into a (<*>)
20:27:48 <benzrf> right now, that's using `pure' from the instance for ((->) r)
20:27:53 <geekosaur> mm, yeh, that'd do it
20:28:18 <geekosaur> and yes, things get weird when ((->) r) comes into it and you weren't expecting it
20:33:26 <mrkgnao_> benzrf: I know, I started with a sensible version and was playing around with the operators trying to see what I could get past the typechecker
20:33:43 <mrkgnao_> and then (->) r pops up out of nowhere and hits me over the head
20:33:53 <mrkgnao_> pure is const, right, for (->) r?
20:34:16 <benzrf> yeah
20:34:18 <benzrf> hehe
20:34:30 <mrkgnao_> that explains it
20:35:30 <fred-fri> still not getting it :( http://pastebin.com/wHEK1gvD
20:37:29 <geekosaur> um
20:38:02 <geekosaur> so %l is documented as ' 1' to '12' (space padded, not leading zero)
20:38:30 <geekosaur> %I looks like the leading zero version
20:39:02 <geekosaur> oh, fonts...
20:39:20 <geekosaur> uppercase i vs. lowercase l
20:39:58 <geekosaur> programming font reasons >.>
20:41:18 <monochrom> I ran into I vs l too when I entered a coupon code at McDonald's :)
20:42:36 <geekosaur> life's too short to wrangle fonts that think they're for old manual typewriters
20:42:38 <monochrom> and yeah the coupon code on the smartphone was displayed in a sans-serif font so I had to think
20:42:55 <monochrom> on that note:
20:43:00 <monochrom> @quote monochrom IO
20:43:01 <lambdabot> monochrom says: some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748)
20:43:01 <lambdabot> and find one single student who faithfully evaluate 389238493+97283748 first.
20:43:07 <monochrom> err, no
20:43:13 <monochrom> @quote monochrom semantics.*IO
20:43:14 <lambdabot> monochrom says: <monochrom> great way to answer a semantics question by commenting on the font  <monochrom> "what is the semantics of IO?" "the I may be narrower than O in some fonts, and same width
20:43:14 <lambdabot> in some other fonts"  <monochrom> "on very old typewriters, it also denotes the number 10 (ten), for those of you looking for a denotation" XD
20:53:55 <pavonia> fred-fri: I think your type annotation :: UTCTime is wrong, you want a LocalTime instead
20:55:50 <fred-fri> pavonia, cheers
20:56:16 <geekosaur> did you catch the format thing around the extra verbiage?
21:01:59 <ReinH> monochrom: those are both good quotes though
21:04:25 <haskell451> Hi, How do I create a haskell function that will do the following:  makeList [3,4,2] = Cons 3 (Cons 4 (Cons 2 Nil))
21:05:31 <monochrom> one way is to write your own recursion
21:05:42 <monochrom> base case: makeList [] = ???
21:06:00 <monochrom> recursive case: makeList (x:xs) = ???  this case you need recursion
21:06:59 <haskell229> Hi guys, I wanted to make a haskell function that will do the following: makeList [3,4,2] = Cons 3 (Cons 4 (Cons 2 Nil))
21:07:08 <monochrom> one way is to write your own recursion
21:07:10 <monochrom> base case: makeList [] = ???
21:07:12 <monochrom> recursive case: makeList (x:xs) = ???  this case you need recursion
21:08:59 <haskell229> @<monochrom>  So base case will be makeList [] = Nil? 
21:08:59 <lambdabot> Unknown command, try @list
21:09:04 <monochrom> yes
21:10:00 * hackagebot hw-diagnostics 0.0.0.5 - Diagnostics library  https://hackage.haskell.org/package/hw-diagnostics-0.0.0.5 (haskellworks)
21:11:24 <grantwu> makeList = foldr Cons Nil
21:11:27 <grantwu> Does that work?
21:12:15 <monochrom> yes.
21:12:30 <monochrom> but are you ready for foldr?
21:12:45 <grantwu> I am, I don't know if the person who asked the question is
21:12:53 <haskell229> what is foldr?
21:12:59 <grantwu> I guess not.
21:13:18 <grantwu> haskell229: Is this for a class?  If it is I presume the class will introduce folds sometime soon
21:14:23 <haskell229> makeList [] = Nil  makeList (x:xs) = Cons x * makeList xs 
21:14:32 <haskell229> This is how I'm trying
21:14:46 <haskell229> I'm sorry I'm new in haskell
21:14:56 <grantwu> That looks mostly right
21:15:07 <grantwu> I'm not sure why there's a "*" after "Cons x" though
21:15:10 <grantwu> What were you trying to do there?
21:15:46 <haskell229> But Cons and Nil are not in scope
21:16:04 <ReinH> How can Cons and Nil not be in scope?
21:16:27 <monochrom> I thought you were given code for Cons and Nil already.
21:16:36 <grantwu> If you weren't, you will need to define that
21:16:36 <monochrom> Where can I read the original homework question?
21:17:10 <haskell229> The following code provides the operator +++ that you can use to append lists as you would the ++ operator. (+++) :: List a -> List a -> List a (+++) x Nil = x (+++) Nil x = x (+++) (Cons a b) e@(Cons c d) = (Cons a (b +++ e)) Note that +++ is really just acting as a name of a function here. This is meant to give you an idea of how to use these user defined data types. (a) (10 points): Create a recursive function called makeLis
21:18:06 <monochrom> No. Where can I read the original homework question? One where it also says what your starter code is.
21:18:22 <haskell229> wait, he said he gave data structure in class but I was absent.
21:18:25 <grantwu> haskell229: Are you provided with some sort of starter code?
21:18:35 <grantwu> Ask a friend in the class?
21:18:45 <monochrom> OK you should go hunt down that absent code.
21:19:00 <monochrom> But it's going to be data List a = Nil | Cons a (List a)
21:20:00 * hackagebot hw-prim 0.4.0.0 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.4.0.0 (haskellworks)
21:24:47 <haskell229> @<monochrom> please read my code https://shrib.com/lxlqH5ywtdErMg2
21:24:47 <lambdabot> Unknown command, try @list
21:25:20 <glguy> haskell229: @ is for bot commands, and <NICK> is generally for quoting
21:25:25 <monochrom> Yes that should be right.
21:25:57 <haskell229> I'm getting error though 
21:26:31 <monochrom> post verbatim error output
21:27:12 <haskell229> <monochrom> https://shrib.com/lxlqH5ywtdErMg2
21:28:13 <monochrom> OK I see. "data List a = Nil | Cons a (List a) deriving Show"
21:30:00 * hackagebot hw-int 0.0.0.1 - Integers  https://hackage.haskell.org/package/hw-int-0.0.0.1 (haskellworks)
21:30:39 <haskell229> <monochrom> bunch of thanks!
21:48:50 <jchia_> I notice that in ghci, ':i' omits some class instance entries when there are two same-name classes from different modules are instances of the same class. For example, ByteString and Lazy.ByteString are instances of Data.IOData.IOData but ":i IOData" only shows one instance for ByteString unqualified:
21:48:51 <jchia_> instance IOData ByteString 
21:48:51 <jchia_>   -- Defined in ‘chunked-data-0.3.0:Data.IOData’
21:49:15 <jchia_> How do I get ghci to show qualified names and to show an instance for ByteString and an instance for Lazy.ByteString?
21:49:31 <glguy> jchia_: :info filters things by what's in scope, try:   :info!
21:49:52 <jchia_> got it, thanks
21:52:50 <bollu> why can't we nest template haskell brackets?
21:52:59 <bollu> I want to nest a [e| ..] inside a [d| …]
21:53:08 <bollu> it's hell to construct expressions inside a declaration :(
21:53:46 <lpaste> bollu pasted “mono-comonad-derive-impl” at http://lpaste.net/294294
21:53:58 <bollu> ^ I want to make that more idiomatic template haskell
21:54:08 <bollu> can someone please take a look and tell me how to improve it?
21:55:43 <glguy> bollu: What part did you think you might be able to improve?
21:56:49 <bollu> glguy: the building up AST could be nicer I think. I'm manually $(conE ..) $(varE ..) ing. Thee's also the fact that you need to dfferentiate between the type constructors, type names, variable names, pattern matches
21:57:01 <bollu> glguy: like, I want to learn how to use quasi quotes effectively
21:57:14 <glguy> You won't be able to get around using conE and varE for dynamically generated names
21:57:15 <bollu> glguy: so it's readable. The current code isn't very reflective of what's going on
21:57:22 <bollu> glguy: especially the pattern match at least?
21:57:38 <bollu> glguy: like, can you show me how to use [p| …|] for the pattern match?
21:58:19 <bollu> glguy: but, well, the names are known at compile time: I'm destructuring "newtypeconsname" for example. Can I somehow remove the $(conE) for it at least?
21:58:34 <bollu> glguy: doesn't it took way too verbose to you..?
21:59:10 <glguy> I don't see how you'd squeeze any [p| uses in
22:00:03 <bollu> glguy: the patternMatchInner builds a pattern match, right?
22:00:13 <bollu> glguy: can't I construct it using the [p| …|] in some way?
22:00:16 <glguy> no
22:00:27 <glguy> It's too dynamic
22:00:36 <glguy> "dynamic" from the point of view of the definition of patternMatchInner
22:00:49 <glguy> It's parameterized on all the names it matches on
22:00:50 <bollu> glguy: okay, like, what makes this "dynamic"? I don't really understand how TH is dynamic in this case.
22:01:08 <bollu> glguy: yes, but, like, all of those names come as input. Is that what makes it "dynamic" ?
22:01:11 <glguy> "dynamic" in that it's parameterized on the names as values
22:01:20 <bollu> glguy: so, it would be "static" if I knew the names beforehand? ah
22:01:36 <glguy> It would be static if the names were explicit in the syntax of the file, yes
22:01:48 <glguy> you could make a pattern like this: [p| X y |]
22:02:05 <glguy> where the pattern itself is matching X and naming that first field y
22:02:17 <bollu> glguy: ah I see
22:02:24 <glguy> But if you want X or y to be passed in as Names then you're back to conP
22:02:29 <bollu> hm
22:02:29 <bollu> damn
22:02:34 <bollu> so in this case, what is "y"?
22:02:45 <bollu> some Name right?
22:02:53 <glguy> some Haskell syntax for the literal name y
22:03:18 <glguy> you can write this, however: patternMatchInner newtypecons var = conP newtypecons [varP var]
22:03:23 <glguy> slightly less code
22:03:45 <glguy> The system is that all the lowercased names work with the Q type
22:03:53 <glguy> so varP x = return (VarP x)
22:04:04 <glguy> and all the lowercased names take Q arguments
22:04:12 <glguy> (where appropriate)
22:05:22 <bollu> ah
22:05:25 <bollu> hm
22:06:07 <bollu> in a Q[Dec], is only the last value actually defined? It doesn't look like deriveMonoFunctor and deriveMonoElement are being called
22:06:12 <bollu> only deriveMonoComonad is happening
22:06:18 <shirt> which hackage package is better: aws or amazonka?
22:06:39 <glguy> bollu: No, the whole list is used
22:06:55 <glguy> OH, yeah, but the way you've done it you're ignoring all but the last
22:07:05 <bollu> glguy: so how should I do it correctly?
22:07:15 <glguy> sequence [deriveThis, deriveThat, deriveTheOther] is nice
22:07:27 <glguy> and... fmap concat on that
22:07:38 <bollu> hm
22:07:45 <bollu> :t  concat
22:07:47 <lambdabot> Foldable t => t [a] -> [a]
22:07:48 <glguy> or gather the names up and return then x++y++z
22:07:59 <bollu> wait what? oh, it's an [Dec]
22:08:02 <bollu> oh right right
22:08:17 <glguy> gather the Decs*
22:08:18 <bollu> damn, I thought the Q monad would do some sort of magic fusion thing, ofc that's silly
22:08:22 <bollu> damn I need sleep :)
22:12:57 <bollu> glguy: how do I debug print TH code?
22:14:26 <glguy> You mean you want to see the generated code?
22:15:45 <glguy> Prelude Language.Haskell.TH> $(stringE . show =<< [p| Just y |])
22:15:45 <glguy> "ConP GHC.Base.Just [VarP y_1627410321]"
22:16:01 <glguy> and -ddump-splices
22:17:01 <bollu> ah
22:17:02 <bollu> neat
22:17:03 <bollu> thanks
22:40:27 <saurabhnanda> is there a way to write TemplateHaskell how Lisp macros are written. Something on the lines of generating the actual code, and not the AST?
22:43:21 <bollu> saurabhnanda: ahaha, I'm working on TH right now as well
22:43:39 <saurabhnanda> bollu: do you know the answer?
22:43:59 <bollu> saurabhnanda: you can use the quasi-quoters to get pretty far, but apparently once things start depending on non-hardcoded names, you're forced to build the AST by hand is what I gather. I'm no expert though
22:43:59 <bollu> glguy: ^
22:44:04 <MarcelineVQ> In fact you're both working on similar things iirc, in that you're generating instances and declarations
22:44:38 <saurabhnanda> is there no equivalent of `gensym` in Haskell quasi-quotes?
22:45:04 * hackagebot hw-bits 0.4.0.0 - Bit manipulation  https://hackage.haskell.org/package/hw-bits-0.4.0.0 (haskellworks)
22:45:08 <EvanR> saurabhnanda: in lisp, it does generate an AST
22:45:13 <haskell841> Hi, I'm new in Haskell.I'm trying to solve a problem but getting error.Can someone take a look?http://www.rapidtables.com/tools/notepad.htm
22:45:16 <bollu> MarcelineVQ: I got it to work, and I'm decently happy with it now. Wish it was a little less verbose though. https://github.com/bollu/cellularAutomata/blob/master/src/DeriveMonoComonadTH.hs#L47
22:45:33 <bollu> @lpaste
22:45:34 <saurabhnanda> EvanR: so, it different. You write Lisp code in the AST itself. That's not how you write Haskell code.
22:45:34 <lambdabot> Haskell pastebin: http://lpaste.net/
22:45:36 <EvanR> concrete syntax in lisp is kind of confusing in that respect, its an AST
22:46:15 <bollu> haskell841: it'd be nice if you could put it on lpaste in the future, it compiles your code and shows us the errors :) also, the link doesn't show me anything
22:46:43 <EvanR> haskell has concrete syntax that looks different from the AST, thankfully, but it means templating is more complex
22:47:05 <bollu> EvanR: "thankfully" is debatable :P
22:47:11 <MarcelineVQ> bollu: It looks pretty good to me, your use of [d| |] makes it easier to see what the end result will be than the construction expample I had made
22:47:12 <EvanR> saurabhnanda: have you see bollu's questions so far regarding quasi quoters, they help define ASTs with less direct munging
22:47:37 <haskell841> bollu: http://lpaste.net/294377
22:47:42 <saurabhnanda> EvanR: no. bollu: are is this Q&A online?
22:47:47 <bollu> 	MarcelineVQ yeah, It did. I wish I could nest quasi quoters though, it would help to be able to build up expressions inside delcarations
22:48:10 <bollu> saurabhnanda: no, I was asking on IRC for the past day ish. Wait a sec, let me pull up the IRC logs where people helped me
22:48:15 <saurabhnanda> EvanR: why would templating be more complex in Haskell? you can basically treat it as HTML templating for most simple cases.
22:48:27 <EvanR> no you cant
22:48:31 <glguy> you can nest them, as long as there's a splice in between
22:48:32 <EvanR> since HTML is raw text
22:48:55 <bollu> glguy: splice is $(..) right? but each $() imples a "context switch" from static world to dynamic world right?
22:49:29 <glguy> it's more of a tower than a switch
22:49:35 <EvanR> saurabhnanda: its more complex because all the nice syntax is expanded, and because youre working with the environments in scope during compilation, stuff might not work like you think
22:49:50 <bollu> haskell841: maxList (Cons x xs) "=" … I think you dropped as "=" 
22:50:04 <saurabhnanda> EvanR: I'm sorry. I don't get why what happens in the lisp macro system can't be done in TH.
22:50:10 <bollu> saurabhnanda: also, it doesn't let you pull things from different "stages" of compilation. I don't fully understand it.
22:50:21 <bollu> glguy: elaborate on the tower thing please?
22:50:44 <glguy> you can make programs that make programs that make programs
22:50:47 <EvanR> saurabhnanda: not sure, are you implying thats what i said?
22:51:02 <glguy> you aren't alternating between a notion of static and dynamic
22:51:46 <saurabhnanda> EvanR: isn't that what you said?
22:52:03 <EvanR> it doesnt work like HTML thats for sure
22:52:12 <bollu> saurabhnanda: http://ircbrowse.net/day/haskell/today?id=23609054&timestamp=1477198348#t1477198348
22:52:17 <haskell841> bollu: Now I'm getting more errors http://lpaste.net/294377
22:52:36 <EvanR> and lisp macros really arent like textual templating
22:53:05 <glguy> saurabhnanda: You can quote Haskell syntax in TH, you don't necessarily have to build things using the raw AST or the combinators around the AST
22:53:06 <bollu> saurabhnanda: http://ircbrowse.net/day/haskell/2016/10/22?id=23603225&timestamp=1477108035#t1477108035
22:53:16 <glguy> and you can generate fresh names programatically
22:54:01 <saurabhnanda> glguy: any tutorial around the simpler ways of using TH? (without going down to AST level?)
22:55:10 <bollu> haskell841: what do you think x:dunk does? actually, back up a little, explain to me what your solution should do first
22:55:37 <bollu> saurabhnanda: for quasi-quoters, the GHC guide is insufficient but should get you started: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell-quasi-quotation
22:55:56 <glguy> saurabhnanda: There's a bunch of stuff linked in https://wiki.haskell.org/Template_Haskell . I can't recommend anything in particular.
22:56:00 <bollu> saurabhnanda: do you want to write a tutorial together once you're done with this? God knows I could have used one :P
22:56:04 <glguy> I don't remember when it was that I learned TH or how I did it at the time
22:56:10 <bollu> glguy: many of those links are broken, I fixed them yesterday
22:56:15 <glguy> cool
22:56:41 <bollu> haskell841: ping
22:56:44 <saurabhnanda> bollu: sure, for simple practical stuff.
22:56:52 <bollu> saurabhnanda: yes, agreed
22:57:04 <haskell841> :bollu I'm trying to add all integers a,b,c in Cons a(Cons b(Cons c..) in a list
22:57:04 <glguy> There's also https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XTemplateHaskell
22:57:25 <saurabhnanda> bollu: what's the problem you're trying to solve with TH?
22:57:32 <haskell841> bollu :so that I can compare.Please see the question:http://lpaste.net/294377
22:58:21 <bollu> saurabhnanda: let's say there's [] which derives functor. Now, you can do something like newtype IntList = IntList ([Int]). I want to automatically derive MonoFunctor on this (which comes from mono-traversable). I actually want to derive mono functor and mono comonad
22:58:27 <haskell841> bollu :http://lpaste.net/294377
22:58:45 <bollu> haskell841: do you want the maximum element in the list?
22:58:59 <haskell841> bollu: yes
22:59:13 <saurabhnanda> okay. that's definitely NOT my definition of "simple, practical stufF". What's is the **problem** you're trying to slve
22:59:13 <saurabhnanda> ?
22:59:25 <glguy> saurabhnanda: What's some simple, practical stuff?
22:59:39 <EvanR> TH can be used to generate instances of classes, thats practical once it works
22:59:40 <haskell841> bollu : but the list is defined as Cons a(Cons b(Cons c...)))
22:59:46 <bollu> saurabhnanda: automatically derive typeclass instances to make it easier for people to create pretty cellular automata: https://github.com/bollu/cellularAutomata
22:59:53 <bollu> haskell841: okay, agrees
23:00:04 <bollu> haskell841: so, the spirit of your idea is right
23:00:07 <saurabhnanda> glguy: that is -- http://stackoverflow.com/questions/40171037/apply-a-function-to-all-fields-in-a-record-at-the-type-level/40171268# and the core problem is also given in the question.
23:00:18 <bollu> haskell841: now let's think of the second case
23:00:35 <bollu> haskell841: where you have the (Cons x xs), x :: a, xs :: List a
23:00:47 <bollu> haskell841: now, how do you get the maximum from this, recursively?
23:01:08 <haskell841> bollu : yes recursively 
23:01:30 <bollu> haskell841: yes, but how? clearly, x :: a needs to be compared with something you do recursively on (xs :: List a)
23:01:35 <bollu> so what needs to be done, exactly?
23:02:39 <EvanR> saurabhnanda: i would not try to do this, with or without TH
23:02:52 <saurabhnanda> EvanR: why not?
23:02:52 <haskell841> bollu: I'm extracting all numbers from Cons format and adding them in a list.Then I'm getting the maximum of the list.Isn't it?
23:02:58 <EvanR> this seems like a thing where TH would be heavy handed, headed down the wrong path
23:03:22 <bollu> haskell841: why? don't use a built-in list. you already have a list!
23:03:34 <haskell841> bollu: expected output =  maxList (Cons 2 (Cons 7 (Cons 3 (Cons 4 Nil)))) -> 7
23:03:44 <saurabhnanda> EvanR: is TH over-engineering or the way I'm trying to solve the problem?
23:03:46 <bollu> haskell841: 	yes
23:03:56 <bollu> haskell841: but you already have a list: your List definition
23:04:03 <bollu> haskell841: so don't go around building a haskell p[
23:04:04 <bollu> []*
23:04:12 <bollu> haskell841: try and solve it within your List
23:04:55 <bollu> haskell841: what is the value of maxList (Cons x xs)? can you use maxList on xs?
23:05:00 <haskell841> bollu: do I( just treat Cons like a normal list?
23:05:04 <bollu> haskell841: yes
23:05:13 <EvanR> saurabhnanda: a record where everything may be omittable is a special case of a more flexible general thing... like an extensible record
23:05:45 <EvanR> it would be a lot of work to make a TH thing for this, only to decide you want to omittable everything but 1 field
23:05:56 <EvanR> or add a field
23:05:58 <haskell841> bollu : Cons (x:xs _) like this?
23:06:33 <bollu> haskell841: no, I mean, think of Cons(x xs) can you use these to get the maximum by recursively calling maxList on xs?
23:07:13 <bollu> maxList (Cons 1 (Cons 2)) == (something) maxList (something) can you tell me what the (something) is?
23:07:26 <saurabhnanda> EvanR: I'm not sure I agree on the "lot of work" part. I'm expecting TH to do all the boilerplate for me.
23:07:44 <haskell841> bollu: x maxLis xs
23:08:15 <EvanR> saurabhnanda: right, its for generating boilerplate that you actually want to have in the first place, which i think here you dont
23:08:47 <EvanR> a lot of work, thats the development of the TH, thats not automated yet
23:08:54 <bollu> haskell841: is it that? don't you need to compare x and maxList xs?
23:09:20 <bollu> haskell841: to figure out which one is actually greater?
23:09:34 <saurabhnanda> why isn't this working in GHCi? $([d|foo x = x + 2|])
23:09:53 <bollu> haskell841: would something like this work: maxList (Const x xs) = if x > (maxList xs) (…something…)
23:09:56 <haskell841> bollu: yes. So I just do x > xs = x | otherwise = maxList xs 
23:10:07 <bollu> haskell841: yes, something like that
23:10:12 <bollu> haskell841: can you give that a shot?
23:10:24 <haskell841> bollu: ok I'mm trying
23:10:31 <bollu> saurabhnanda: have you enabled TH when you launched GHCi?
23:10:44 <saurabhnanda> bollu: used set to do that
23:10:55 <lpaste> glguy pasted “for saurabhnanda” at http://lpaste.net/294412
23:11:13 <glguy> saurabhnanda: That's how you can do that in TH if you wanted to do it
23:11:47 <bollu> saurabhnanda: what's the error?
23:12:07 <saurabhnanda> it's working in a separate file though. Not working on GHCi
23:12:09 <bollu> glguy: you seemed to have used a lot of TH. For what, I'm curious
23:12:57 <saurabhnanda> Couldn't match type ‘[template-haskell-2.10.0.0:Language.Haskell.TH.Syntax.Dec]’ with ‘template-haskell-2.10.0.0:Language.Haskell.TH.Syntax.Exp’ Expected type: template-haskell-2.10.0.0:Language.Haskell.TH.Lib.ExpQ Actual type: template-haskell-2.10.0.0:Language.Haskell.TH.Lib.DecsQ In the expression: [d| foo x = x + 2 |] In the splice: $([d| foo x = x + 2 |])
23:13:59 <EvanR> remove the $( ), the [d| ... |] is a valid DecsQ
23:14:00 <glguy> saurabhnanda: You can't splice a declaration where an expression goes. Where'd you put the $([d| foo x = x + 2 |]) ?
23:14:18 <haskell841> bollu: updated:http://lpaste.net/294377 I'm getting error although you can at least understand if I'm close to the right point.
23:14:18 <saurabhnanda> at the prompt
23:14:18 <slack1256> off-topic: when replying -cafe, should reply-to: sender & cc:cafe; or just reply-to cafe?
23:14:38 <glguy> saurabhnanda: If you want to splice a declaration in GHCi you have to trick it into thinking you're making a declaration
23:14:39 <saurabhnanda> EvanR: if I remove the $() then it tries to Show the DecsQ and fails
23:14:47 <EvanR> you can do :t on it
23:14:48 <glguy> example: data Fake ; someTemplateHaskell
23:15:05 * hackagebot hw-rankselect-base 0.2.0.0 - Rank-select base  https://hackage.haskell.org/package/hw-rankselect-base-0.2.0.0 (haskellworks)
23:15:12 <glguy> Otherwise it interprets your intent as splicing in an expression
23:15:30 <EvanR> $([e| "yes"|]) thatll work in ghci
23:16:06 <bollu> haskell841: to use guards (the | way of doing things), you first need some conditional to match on. also, you're missing an =. I'd suggest using an if then else in this case
23:16:32 <glguy> bollu: I've done the current implementation of the lens TH, work on the shakespear templating package, various work projects where generating code was appropriate
23:16:47 <bollu> haskell841: like, you need the = for the if condition
23:16:51 <bollu> haskell841: wait, I'm wrong
23:17:06 <glguy> It looks like my Minecraft proxy used some TH :)
23:17:32 <haskell841> bollu: if I use guards then I guess I don't use = right after the function declaration.Am I?
23:17:42 <bollu> haskell841: yeah
23:17:46 <glguy> saurabhnanda: Did you see the paste ?
23:17:47 <bollu> haskell841: look at your otherwise case
23:18:05 <bollu> haskell841: actually, look at your x > xs case
23:18:11 <bollu> haskell841: is that valid?
23:18:12 <glguy> saurabhnanda: It's fine if you want to look later, I just don't want you to miss it altogether
23:18:15 <bollu> as types?
23:18:20 <bollu> x :: a, xs :: List a
23:18:25 <bollu> so what does x > xs mean?
23:18:32 <bollu> don't you need a maxList in there somewhere?
23:18:38 <saurabhnanda> glguy: looked at it. Wondering if that's a better approach or what I had in mind.
23:19:01 <haskell841> bollu: I know I can't compare x with xs . Do I do x > max xs then?
23:19:05 <bollu> glguy: I see, that is quite interesting. 
23:19:11 <bollu> haskell841: max or maxList?
23:19:51 <haskell841> bollu: I mean max built in function that gets the max in [1,2,3] format
23:19:51 <bollu> haskell841: but why do you need to do it? Like, do you get the idea behind it? you're saying, that if my current value is more than everything else that I have, then I return that. otherwise, I return the other value in the list that is the maximum
23:20:02 <bollu> haskell841: why can't you use __your__ maxList?
23:20:20 <glguy> that's just how you would derive the data type using TH. another way to accomplish the overall goal is to use a type family
23:21:06 <saurabhnanda> glguy: I was planning of giving the generator/TH function a list of tuples. Each tuple representing a field, its data-type, whether it is omittable or not, and what its lens should be called. TH then generated both the record types from the tuple.
23:21:22 <saurabhnanda> glguy: was that for me? (type family stuff?)
23:22:14 <bollu> saurabhnanda: can you link to your SO question again please?
23:22:18 <glguy> Yeah (it's an option, I don't know that it's the best option)
23:22:32 <saurabhnanda> bollu: http://stackoverflow.com/questions/40171037/apply-a-function-to-all-fields-in-a-record-at-the-type-level/40171268#
23:23:22 <saurabhnanda> glguy: can I call $(makeLenses <recordWithOmittableTypes>) when <recordWithOmittableTypes> itself is generated by previously run TH in the same module?
23:24:16 <glguy> Only if there's a division between the two runs
23:24:23 <glguy> but what you *can* do is call declareLenses
23:24:32 <saurabhnanda> glguy: so separate modules, for no real reason.
23:24:35 <glguy> no
23:24:43 <glguy> Not for no reason, not separate modules
23:25:10 <glguy> Just separate top-level instantiations
23:25:24 <bollu> saurabhnanda: what's the use-case for this?
23:25:27 <glguy> but declareLenses doesn't take a Name, it takes a DecsQ
23:25:37 <glguy> so then the data type doesn't have to be previously declared
23:26:01 <saurabhnanda> bollu: webapps sending a PATCH request. Want to represent the PATCH in a type-safe manner.
23:26:02 <glguy> Generally you'll do better that when you don't understand something that you don't assume it's for no reason
23:26:22 <lpaste> glguy annotated “for saurabhnanda” with “for saurabhnanda (annotation) with type families” at http://lpaste.net/294412#a294455
23:26:38 * glguy heads to bed
23:27:14 <saurabhnanda> glguy: I know the the stage restriction in GHC. It's just unfortunate it exists. forces you to split stuff into modules for no real reason related to code modularity
23:27:41 <glguy> no, that wasn't what i was talking about
23:29:01 <glguy> makeLenses uses reify to look up a type by name
23:29:06 <elliptic0> Hi, can anyone explain to me what is   data Integer::* ?  what does '*' mean?
23:29:20 <glguy> so obviously that's not going to work if the type isn't defined yet
23:29:28 <glguy> enter declareLenses
23:30:15 <glguy> elliptic0: it's the kind of Integer
23:30:25 <bollu> elliptic0: it is the kind, if I'm not mistaken. Integer does not take any type parameters, so it has kind *
23:31:55 <bollu> saurabhnanda: what was the issue with the proposed SO answer?
23:34:33 <bollu> saurabhnanda: was it the fact that you did not want Identity everywhere?
23:35:00 <elliptic0> thx
23:36:52 <saurabhnanda> bollu: yes
23:37:08 <MarcelineVQ> glguy: gosh that's cool
23:37:10 <saurabhnanda> bollu: runIdentity for every individual field that needs to be used. not practical
23:38:27 <bollu> saurabhnanda: can't you fmap?
23:38:35 <bollu> saurabhnanda: oh, okay, nvm
23:38:51 <elliptic0> Hi, when I change directory in GHCi using :cd newdir and all my modules are unloaded. And I try to reload my modules with :source myOwnModule.hs, it does't work. Any suggestion would be appreciated
23:39:47 <elliptic0> Any idea how to stop the GHCi stop unload my modules when I change dir with :cd newdir ?
23:42:13 <bollu> saurabhnanda: so did you decide on an approach?
23:50:37 <EEVV> How do I do this: Int::a = 2?
23:50:44 <EEVV> I want a to be a type of Int
23:50:47 <EEVV> and equal 2
23:51:15 <bollu> > let a = 2 :: Int in a
23:51:16 <Vyn> > let a::Int; a = 2
23:51:18 <lambdabot>  2
23:51:20 <lambdabot>  <no location info>: error: not an expression: ‘let a::Int; a = 2’
23:51:50 <Vyn> > a
23:51:54 <lambdabot>  a
23:52:22 <Vyn> Hm
23:52:47 <EEVV> bollu, any way to do it without `let`?
23:53:06 <Vyn> Strange, that works in my GHCI
23:53:10 <grantwu> At top level, I think you can just do
23:53:10 <EEVV> or is that just for the interpreter
23:53:15 <grantwu> a :: Int
23:53:17 <grantwu> a = 2
23:53:23 <EEVV> ok thanks, grantwu
23:53:40 <grantwu> I haven't tried it though
23:54:14 <EEVV> grantwu, it works
23:54:45 <bollu> EEVV: that was just to show it in lambdabot :)
23:55:08 * hackagebot hw-rankselect 0.7.0.0 - Rank-select  https://hackage.haskell.org/package/hw-rankselect-0.7.0.0 (haskellworks)
23:55:16 <Vyn> bollu: Why does let a :: Int; a = 2 work in GHCI but not with lambdabot?
23:55:47 <benzrf> Vyn: lambdabot expects an actual expression
23:56:01 <benzrf> ghci is some kind of bizarre do-notation weirdness
23:56:11 <Vyn> Okay
23:56:39 <bollu> benzrf: yeah, lambdabot literally sticks the expression into some .hs code right?
23:56:48 <benzrf> that's @let, i think
23:57:03 <bollu> if I want to read the definition of GeneralizedNewtypeDeriving, where can I do that?
23:57:18 <Vyn> @let x :: Int; x = 3
23:57:23 <lambdabot>  Defined.
23:57:24 <Vyn> > x
23:57:28 <lambdabot>  error:
23:57:28 <lambdabot>      Ambiguous occurrence ‘x’
23:57:28 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
23:57:53 <bollu> what? that exists? -_^
23:57:58 <benzrf> ya
23:57:59 <bollu> :t Debug.SimpleReflect.x
23:58:01 <lambdabot> Expr
23:58:21 <benzrf> its a lame trick, look:
23:58:24 <benzrf> > y + z
23:58:28 <lambdabot>  y + z
23:58:34 <bollu> WTF what https://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect-Vars.html
23:58:37 <bollu> right
23:58:37 <benzrf> > sum (replicate 20 y)
23:58:40 <lambdabot>  0 + y + y + y + y + y + y + y + y + y + y + y + y + y + y + y + y + y + y + ...
23:59:16 <ertesx> EEVV: if you just want to enforce the type of a literal or a short expression, you can just give it a type signature anywhere:  sin (3 + 4 :: Double)
23:59:25 <benzrf> > foldr f z [x, y]
23:59:28 <lambdabot>  error:
23:59:28 <lambdabot>      Ambiguous occurrence ‘x’
23:59:28 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.x’,
23:59:32 <benzrf> woops
23:59:38 <benzrf> > foldr f z [q, v, c]
23:59:42 <lambdabot>  f q (f v (f c z))
23:59:43 <ertesx> EEVV: no need to create a throwaway name like 'a'
23:59:45 <EEVV> ertesx, I know that, but I just forgot how to do it -- it has been a month
23:59:57 <bollu> > let y f = f (y f) in y (f :: Expr -> Expr)
23:59:59 <benzrf> > foldl f z [q, v, c]
