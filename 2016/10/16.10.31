00:04:29 * hackagebot persistable-record 0.4.1.0 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.4.1.0 (KeiHibino)
00:07:39 * hackagebot text-zipper 0.8.3 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.8.3 (JonathanDaugherty)
00:07:39 * hackagebot persistable-record 0.4.1.0 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.4.1.0 (KeiHibino)
00:15:16 <suppi> http-client maybe?
00:16:19 <jchia> is there a more succinct way to express map (map (map (map ... (map x)...) that allows me to just specify with an integer how many layers of 'map' there are?
00:17:22 <jle`> jchia: it's not a simple thing
00:17:28 <ahihi> you can write something like that using TH, but I'm not sure it's worth it
00:17:39 <jchia> not worth it in my current situation
00:18:00 <jle`> if it was a "normal" haskell function, it wouldn't be well-typed
00:18:21 <jchia> the situation is reminiscent of liftIO
00:18:47 <jle`> yeah, you could do something wiht typeclasses
00:18:49 <jchia> i want to apply the fewest number of 'map' that makes sense
00:18:53 <jle`> but you wouldn't be able to specify with an Integer
00:18:56 <jchia> that would be overengineering in my case
00:19:25 <jle`> well, liftIO is a fairly straightforward typeclass trick
00:19:44 <jle`> but it's not straightforward to apply the same technique here
00:21:37 <jchia> If I have a x :: Maybe (Maybe (Maybe (Maybe Integer))), and I want to convert the Integer to Int, it would be nice if I can do something like liftMap fromInteger x
00:22:08 <jchia> i literally mean fmap. I'm using ClassyPrelude where map == fmap
00:22:39 <jle`> you could probably get something like that with typeclass tricks
00:23:05 <jchia> yeah
00:23:23 <jchia> i don't know whether it's worth the trouble though
00:23:25 <jle`> but in real haskell it doesn't happen often enough that people need a dedicated solution for it i think
00:23:45 <jle`> well
00:24:06 <mnu> I think a question I have is a little bit related (this is from a class). I'm trying to write a liftA function of type liftAN :: Applicative f => ([a] -> b) -> f [a] -> f b
00:24:28 <jle`> mnu: sounds like just fmap
00:24:42 <mnu> Would I be wrong in saying lifeAN f as = (pure f) <*> as?
00:24:48 <jle`> that wouldn't be wrong
00:24:52 <mnu> Yes, that was my first thought. But i'm not sure how to test
00:24:54 <jle`> but liftA = pure f <*> as
00:25:03 <jle`> so that's just liftAN = liftA
00:25:14 <jle`> but even better would be liftAN = fmap
00:25:19 <srhb> The N makes it sounds like it can be nested arbitrarily deep though
00:25:23 <jle`> mnu: what do you want to test?
00:25:28 <mnu> Right, but wouldn't the type of f be different from what we deal with with liftA?
00:25:34 <srhb> Oh actually, it's more like number of parameters I guess.
00:25:39 <liste> :t liftA
00:25:40 <lambdabot> Applicative f => (a -> b) -> f a -> f b
00:25:44 <jle`> mnu: what do you want to test?
00:25:51 <jle`> that it typechecks?
00:25:57 <jle`> you can just try it out in ghci :)
00:26:47 <mnu> Basically, we have a list of arguments in our list. So I was expecting something like liftAN (+) [(Just 2),(Just 4),(Just 6)] to work
00:27:03 <jle`> mnu: (+) is the wrong type there
00:27:06 <jle`> you might be thinking about sum
00:27:13 <jle`> but, what do you really want to do?
00:27:21 <jle`> what do you want the result to be?
00:27:24 <jle`> what do you mean by "work" ?
00:27:36 <jle`> because i can think of several different meaningful ways to interpret that
00:28:07 <mnu> But it just returns [2,3,4]
00:28:14 <jle`> [2,3,4] is a reasonable answer
00:28:17 <mnu> Oh, gotcha
00:28:21 <jle`> what do you expect?
00:28:59 <mnu> lifeAN (some summing function) [Just 2, Just 3, Just 4] -> 9
00:29:01 <jle`> i think the issue is that we aren't even sure what you want liftAN to do
00:29:03 <mnu> Or rather
00:29:04 <mnu> Just 9
00:29:18 <jle`> what happens if there's a Nothing?
00:29:39 <Axman6> > foldr (liftA2 (+)) (Just 0) [Just 1,Just 2, Just 3]6
00:29:41 <lambdabot>  error:
00:29:41 <lambdabot>      • Couldn't match expected type ‘Integer -> t’
00:29:41 <lambdabot>                    with actual type ‘Maybe Integer’
00:29:47 <Axman6> > foldr (liftA2 (+)) (Just 0) [Just 1,Just 2, Just 3]
00:29:50 <lambdabot>  Just 6
00:29:54 <jle`> mnu: so you don't really want ([a] -> b) -> f [a] -> f b
00:29:58 <Axman6> > foldr (liftA2 (+)) (Just 0) [Just 1,Just 2, Just 3, Nothing]
00:30:00 <lambdabot>  Nothing
00:30:04 <jle`> mnu: maybe you want ([a] -> b) -> [f a] -> f b ?
00:30:09 <Axman6> alternatively:
00:30:19 <jle`> > sum <$> sequence [Just 1, Just 2, Just 3]
00:30:21 <lambdabot>  Just 6
00:30:25 <Axman6> > sum . catMaybes $ [Just 1,Just 2, Just 3, Nothing]
00:30:27 <mnu> Hmm, I must be misinterpreting what the function is supposed to do then
00:30:28 <lambdabot>  6
00:30:36 <jle`> > sum <$> sequence [Just 1, Just 2, Just 3, Nothing]
00:30:38 <lambdabot>  Nothing
00:31:05 <jle`> mnu: i'm presuming you have a function in mind and you're figuring out how to implement it.  not that you don't have a function in mind and you don't know how to implement it, heh
00:31:30 <jle`> if you don't know what function you want or the type it should have or what it should do then we can't help :|
00:31:57 <jle`> if you have a name for it we can think of silly possible functions that could have that name :)
00:32:01 <mnu> jle`, I suppose I'm a bit closer to the latter. I know the type of the function, but not exactly what the fucntion is, per se, besides the type (liftAN :: Applicative f => ([a] -> b) -> f [a] -> f b)
00:32:10 <jle`> :t liftAN = lift "AN"
00:32:12 <lambdabot> error:
00:32:12 <lambdabot>     parse error on input ‘=’
00:32:12 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
00:32:38 <jle`> :t let liftAN = lift "AN" in liftAN
00:32:40 <lambdabot> MonadTrans t => t [] Char
00:32:58 <Axman6> mnu: that function is just fmap
00:33:16 <jle`> mnu: if that's the case, then you can't apply that to [Just 1, Just 2, Just 3]
00:33:30 <jle`> mnu: [Just 1, Just 2, Just 3]'s type can't unify with f [a]
00:33:34 <jle`> it could be [f a], though
00:33:38 <mnu> Oh, I see
00:33:46 <jle`> (if f is Maybe)
00:33:51 <mnu> f [a] would be like Maybe [a], right?
00:33:58 <jle`> yes, if f is Maybe
00:33:59 <Axman6> :t sequence
00:34:01 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
00:34:14 <jle`> > fmap sum (Just [1,2,3])
00:34:16 <Axman6> :t sequence `asAppliedTo` [Just 1]
00:34:18 <lambdabot>  Just 6
00:34:20 <lambdabot> Num a => [Maybe a] -> Maybe [a]
00:35:54 <mnu> jle`, Axman6 Thanks a bunch. I see how I was not interpreting the type signature correctly
00:36:08 <jle`> no problem!
00:36:13 <sky__> q
00:36:24 <sky__> whoops
00:36:25 <jle`> the most reasonable interpretation of a liftAN (following liftA, liftA2, liftA3, etc.) would be 'traverse'
00:36:41 <jle`> > liftA negate (Just 1)
00:36:44 <lambdabot>  Just (-1)
00:36:47 <jle`> > liftA2 (+) (Just 1) (Just 2)
00:36:49 <lambdabot>  Just 3
00:37:08 <jle`> > liftA3 (\x y z -> x + y + z) (Just 1) (Just 2) (Just 3)
00:37:10 <lambdabot>  Just 6
00:37:24 <jle`> > sum <$> sequence [Just 1, Just 2, Just 3, Just 4]
00:37:26 <lambdabot>  Just 10
00:37:28 <jle`> sorry, not traverse, but yeah
00:37:48 <jle`> @let liftAN f xs = fmap f (sequenceA xs)
00:37:50 <lambdabot>  Defined.
00:37:56 <jle`> > liftAN sum [Just 1, Just 2, Just 3]
00:37:58 <lambdabot>  Just 6
00:39:20 <jchia> :t liftAN
00:39:22 <lambdabot> (Traversable t, Applicative f) => (t a -> b) -> t (f a) -> f b
01:32:46 <ph88> hi guys, i would like to use something like parMap .. but right now i'm using replicateM in that piece of my code .. which functions can i use to build parallel version of replicateM ?
01:34:58 <ongy> replicateM x val -> parMap (const val) [1..x]? (haven't used it, just throwing idea in)
01:35:13 <MasseR> Caveat: I haven't gotten parmap to actually speed up anything yet but:
01:35:21 <MasseR> replicateM is just \n -> sequence . replicate n
01:36:05 <MasseR> No wait, monadic, buffering wouldn't necessarily be easy
01:36:15 <MasseR> Disregard
01:37:35 <ph88> o_O
01:38:32 <ph88> maybe combine sequence with parMap ?
01:38:37 <ph88> :@src parMap
01:38:43 <ph88> @src parMap
01:38:43 <lambdabot> Source not found. Wrong!  You cheating scum!
01:38:49 <ph88> :'(
01:38:53 <ongy> :t parMap
01:38:55 <lambdabot> error:
01:38:55 <lambdabot>     • Variable not in scope: parMap
01:38:55 <lambdabot>     • Perhaps you meant ‘para’ (imported from Control.Lens)
01:39:04 <grantwu> @hoogle parMap
01:39:07 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
01:39:07 <lambdabot> Control.Monad.Par.Combinator parMap :: (Traversable t, NFData b, ParFuture iv p) => (a -> b) -> t a -> p (t b)
01:39:07 <lambdabot> Control.Monad.Par.Combinator parMapM :: (Traversable t, NFData b, ParFuture iv p) => (a -> p b) -> t a -> p (t b)
01:39:19 <ph88> > import Control.Parallel.Strategies
01:39:21 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
01:39:22 <ongy> ph88: which monad are you in?
01:39:37 <ph88> IO
01:39:44 <ph88> the most famous one
01:40:22 <ph88> https://hackage.haskell.org/package/parallel-3.2.1.0/docs/src/Control-Parallel-Strategies.html#parMap
01:41:45 <ongy> I don't think parMap (or Control.Parallel) are intended for IO. forkIO and collecting results may be better
01:43:39 <ph88> well this is the line in my code:   runAlgo algo = mapM (\x -> (replicateM iterations $ algo <$> getBits x) >>= \cts -> return $! stats cts) [1..signal_count]
01:44:07 <ph88> possibly i could also do   (replicate iterations $ algo <$> getBits x)  and then lift that into IO later ??
01:44:46 <ph88> then i could write like    (`using` parList rseq) . replicate f  or something
01:44:48 <ph88> be back later :)
01:48:59 <Axman6> in Pipes, if I have a Producer a IO b, how can I get a Producer a (SafeT IO) b?
01:59:41 <cocreature> Axman6: try "hoist lift" where hoist is from Control.Monad.Morph (pipes already depends on the mmorph package)
02:09:23 <ph88> back
02:09:34 <ph88> @src replicateM
02:09:34 <lambdabot> replicateM n x = sequence (replicate n x)
02:10:05 <ph88> parMap strat f = (`using` parList strat) . map f
02:10:47 <ph88> parReplicateMap = sequence $ (`using` parList rseq) . replicate f
02:11:05 <ph88> let's try it ^^
02:12:39 * hackagebot List 0.6.0 - List monad transformer and class  https://hackage.haskell.org/package/List-0.6.0 (YairChuchem)
02:15:02 <jchia> If a typeclass function f can be applied to types a, b and c, and I want to get [f a, f b, f c], is there a more concise way to express it? I can't do fmap f [a, b, c] because a, b, c are of different types.
02:16:31 <jchia> sorry, mixing values and types here, the a b c in [f a, f b, f c] refers to variables of types a b and c
02:19:15 <Hijiri> jchia: I would guess not
02:19:48 <Hijiri> [f a, f b, f c] is 15 characters, and any solution will have at least f, a, b, and c, plus separating characters, so at least 7 characters
02:20:28 <Hijiri> so the upper bound on saved characters is 8, but the extra machinery to only write f once would probably take more than that (with no objective basis, just intuiting)
02:26:26 <EvanR> jchia: you cant write [a,b,c] because they have different types, thatll be the first problem
02:28:16 <m1dnight_> I have Haskell project that uses Alex and Happy. I just tried moving my Lexer.x file from src/Lexer.x to src/Parsing/Lexer.x. To do this I changed all the module names from 'Lexer', to 'Parsing.Lexer' but now I get the error "cabal: can't find source for Parser in src, dist/build/autogen"
02:28:30 <m1dnight_> I would swearI 've done this before in other projects.
02:28:33 <m1dnight_> What am I missing here?
02:29:17 <EvanR> jchia: passing a polymorphic function like f into another function to do polymorphic stuff is what RankN types lets you do, but here you cant get that far because lists are homogeneous
02:29:28 <m1dnight_> Ah djeez, nvm. I was forgetting I have the test config *and* the regular config in the .cabal file. 
02:32:43 <ph88> what is this error message trying to tell me?  https://paste.fedoraproject.org/466740/14779063/
02:33:24 <ph88> maybe i should ask: why is FlexibleContext required for this ?
02:34:09 <EvanR> that function has a constraint which isnt allowed in haskell 98
02:34:19 <EvanR> which is pretty restrictive
02:35:08 <jchia> I'll get to reading up on Rank-N types sometime, after I figure out how to use TH, GADT and type families
02:35:09 <EvanR> erhm... and its partially your fault, you chose the type to be ((->) a)
02:35:42 <ph88> EvanR, my fault ?
02:36:09 <ph88> ah yes this was the infered type parReplicateMap :: Traversable ((->) a) => Int -> [a -> a]
02:36:22 <ph88> never seen that type  -> a    before
02:36:29 <EvanR> its not -> a
02:36:32 <ph88> what does that mean ?
02:36:40 <EvanR> (->) a b is a -> b
02:36:42 <opqdonut> it's (a->)
02:37:09 <ph88> what's   a ->   ?
02:37:18 <EvanR> its a partially applied type ctor
02:37:27 <ph88> a function that takes a value and produces white space ?
02:37:36 <EvanR> no, its like Map Int
02:37:49 <EvanR> a map from Ints to... you havent decided yet
02:38:16 <ph88> kind of hard to grasp but i see where you're going
02:38:33 <EvanR> whats the fully general type of parReplicateMap
02:39:03 <ph88> i was trying to get the same type as   replicateM :: Monad m => Int -> m a -> m [a]
02:39:13 <ph88> it's currently not working that way
02:39:21 <ph88> @src replicateM
02:39:22 <lambdabot> replicateM n x = sequence (replicate n x)
02:39:22 <EvanR> ah you are trying to write this function yourself
02:39:30 <ph88> parMap strat f = (`using` parList strat) . map f
02:39:31 <ph88> yes
02:39:51 <ph88> parReplicate strat f = (`using` parList strat) . replicate f
02:40:21 <EvanR> it might help you and ghc if you put the expected type sig 
02:40:27 <ph88> i thought if i rap that in sequence i would be done
02:40:50 <EvanR> sequence takes an [m a] and gives you m [a]
02:41:03 <EvanR> that doesnt seem like an [m a]
02:41:26 <EvanR> but i have no idea since theres no sigs
02:41:31 <ph88> https://paste.fedoraproject.org/466744/14779068/
02:41:45 <ph88> sigs on what ?
02:42:02 <ph88> i want a drop in replacement for replicateM that uses parList with a strategy
02:42:10 <EvanR> you put the sig
02:42:16 <EvanR> now you got a better error message
02:42:28 <EvanR> which is basically what i just said, sequence takes a list but you didnt give it one
02:43:07 <ph88> this doesn't produce a list ??   (`using` parList rseq) . Data.List.replicate f
02:43:19 <EvanR> that produces a function
02:43:25 <EvanR> because .
02:43:29 <ph88> aaah w8
02:44:32 <ph88> https://paste.fedoraproject.org/466746/77907044/
02:44:52 <EvanR> its still a function
02:45:08 <EvanR> the top level of that expr is still .
02:46:59 <ph88> ok i changed it to   parReplicateM n xs = sequence $ (`using` parList rseq) $ Data.List.replicate n xs   now
02:47:09 <ph88> > let parReplicateM n xs = sequence $ (`using` parList rseq) $ Data.List.replicate n xs
02:47:15 <lambdabot>  <no location info>: error:
02:47:17 <ph88> @pl parReplicateM
02:47:19 <lambdabot>      not an expression: ‘let parReplicateM n xs = sequence $ (`using` parList...
02:47:23 <lambdabot> parReplicateM
02:47:37 <ph88> @pl parReplicateM n xs = sequence $ (`using` parList rseq) $ Data.List.replicate n xs
02:47:41 <lambdabot> parReplicateM = ((sequence . (`using` parList rseq)) .) . Data.List.replicate
02:47:47 <ph88> LoL !
02:47:54 <ph88> that certainly doesn't look easier
02:48:09 <EvanR> not really
02:48:37 <EvanR> sequence (replicate n xs `using` parList rseq)
02:49:04 <ph88> eh my program still uses only 1 core
02:49:41 <ph88> ah yes that looks even better !
02:49:43 <EvanR> somehow i dont expect sequence to result in using more than 1 core
02:49:56 <EvanR> unless its IO actions spawning threads
02:50:27 <EvanR> but in your case, its probably executing each list element 1 by 1 until it finishes
02:50:35 <ph88> but this part should be in parallel   (replicate n xs `using` parList rseq)    then sequence should be applied later
02:50:54 <ph88> because of strategy rseq ?
02:50:59 <ph88> maybe i should try rpar ?
02:51:41 <EvanR> youre trying to parallelize replicate
02:51:49 <ph88> yeah !
02:51:51 <EvanR> @src replicate
02:51:55 <lambdabot> replicate n x = take n (repeat x)
02:52:21 <cocreature> there is nothing to parallelize in replicate
02:52:23 <EvanR> im not sure if it makes sense to try to do that
02:52:36 <cocreature> x is always the same object, it will only be evaluated once
02:52:42 <cocreature> and the list can’t be constructed in parallel
02:54:00 <EvanR> lists are pretty bad for parallel, i heard
02:54:58 <cocreature> it depends on what you are doing, but often treelike structures are a lot easier to parallelize
02:55:44 <ph88> weeeelllll i was using replicateM and not replicate
02:55:52 <ph88> x change every time because it makes use of a random number
02:56:02 <EvanR> thats really not going to work then
02:56:15 <EvanR> to get more random numbers you have to take them sequentially
02:56:28 <ph88> eh why ?
02:56:45 <EvanR> its a state machine
02:57:09 <ph88> it can read the source again and not try to do pseudo-random ...
02:57:12 <EvanR> the next number depends on the current state, and taking it sends the generator to the next state
02:57:26 <ph88> or it can do pseudo-random a whole lot of times so that the numbers are ready in advance ?
02:57:35 <EvanR> so its like asking for a parallel fibonacci sequence
02:57:57 <ph88> i'm sure those numbers can be genered more quickly than 1 iteration of my algorithm
02:58:15 <ph88> anyway .. another approach would be to look for parallism in another place ^^
02:58:21 <ph88> i actually have another candidate
02:58:52 <ph88> so the full line is this:  mapM (\x -> (replicateM iterations $ algo <$> getBits x) >>= \cts -> return $! stats cts) [1..signal_count]
02:59:07 <ph88> i can also try to parallel on mapM maybe ?
02:59:14 <EvanR> i would take the time right now to understand why this cant be parallelized so you a) learn something b) more quickly see why the next idea wont work
02:59:55 <EvanR> is M the random monad? then you cant parallelize mapM
03:00:06 <ph88> ooooooh
03:01:01 <ph88> what about my two ideas, are any of them viable ?
03:01:22 <EvanR> what ideas
03:01:58 <ph88> idea 1: not use a sequence of random numbers but request a fresh randomness from the system each time i need a random number
03:02:11 <EvanR> a fresh randomness?
03:02:24 <ph88> like read from /dev/urandom
03:02:32 <EvanR> that doesnt work in parallel either
03:02:36 <EvanR> its a stream
03:02:40 <ph88> oh ok
03:02:40 * hackagebot digestive-functors 0.8.1.1 - A practical formlet library  https://hackage.haskell.org/package/digestive-functors-0.8.1.1 (JasperVanDerJeugt)
03:02:42 <koz_> ph88: You can basically 'cash out' your random computations with different random generators, and parallelize *that*.
03:02:49 <cocreature> you can split rngs to create multiple generators
03:02:56 <cocreature> so you want one per thread
03:02:58 <koz_> It's what I did when I needed something like this, cocreature.
03:03:04 <ph88> so idea 2: get the list of random numbers BEFORE applying all those numbers to the algorithm
03:03:04 <koz_> It works pretty well.
03:03:26 <koz_> ph88: Just make one RNG for each computation you intend to do in parallel.
03:03:39 <koz_> You can do it by splitting a starting RNG.
03:03:42 <tdammers> ^ this, pretty much
03:03:53 <ph88> koz_, this sounds like an implementation of idea 1
03:04:04 <koz_> ph88: It worked quite well for me.
03:04:29 <ph88> say the list is 1000 items, do you make 1000 rng's or 1 per core, = 4  ?
03:04:46 <tdammers> one RNG per thread
03:04:50 <EvanR> its not exactly, because if you reseed a given RNG over and over, you dont necessarily get proper statistics. the standard haskell generator actually has this "issue"
03:04:53 <koz_> ph88: 1000 RNGs also works.
03:04:56 <EvanR> but split is supposed to take care of that
03:05:11 <koz_> Just feed each random computation its own RNG from a chain of splits.
03:05:16 <EvanR> you see once them split 1000 times
03:05:17 <tdammers> is the split implementation from base cryptographically sound these days?
03:05:45 <jle`> tdammers: do you mean from 'random' ?
03:05:47 <EvanR> i didnt think StdGen was crypto at all
03:05:54 <tdammers> jle`: yes, right
03:05:55 <ph88> 1000 is actually more it's about 10 000 or even higher
03:06:00 <tdammers> jle`: forgot it's not actually in base
03:06:03 <koz_> ph88: That's fine - do it anyway.
03:06:24 <ph88> koz_, you have some example of this? i know what you're saying but there are a few things in there i haven't done before
03:06:28 <jle`> yeah, i don't think crypto security was ever a design consideration or goal/priority
03:06:37 <EvanR> ph88: remember to split instead of attempting to restart the standard gen with different seeds
03:06:50 <koz_> ph88: Let me do some pasting.
03:07:23 <tdammers> normally, I'd say that if crypto isn't important, roll with an implementation that isn't cryptographically sound, but the more I think of it the more I'm convinced that this isn't something you should assume ever
03:07:41 * hackagebot digestive-functors-blaze 0.6.1.0 - Blaze frontend for the digestive-functors library  https://hackage.haskell.org/package/digestive-functors-blaze-0.6.1.0 (JasperVanDerJeugt)
03:07:51 <grantwu> Hrm... can two threads read from a file at the same time?
03:08:05 <grantwu> EvanR: I think you said something about the I/O manager preventing that
03:08:11 <EvanR> if statistics isnt that important i cant see how crypto is important ;)
03:08:16 <grantwu> But it would actually be useful to have each thread just read out of /dev/urandom
03:08:28 <EvanR> grantwu: yes they can
03:08:33 <EvanR> its not parallel though
03:08:52 <koz_> ph88: http://lpaste.net/316581 <-- here, this should work.
03:08:53 <grantwu> I mean, actually in parallel
03:09:03 <koz_> Key functions are 'makeManyGens', 'doTheNeedful' and 'main'.
03:09:05 <jophish> n
03:09:27 <piyush-kurur> grantwu: be careful with buffering though. The two threads might get the same data
03:09:49 <grantwu> Oh, never mind, the kernel actually locks /dev/urandom
03:09:59 <EvanR> just found that 
03:10:29 <grantwu> I thought there were frumious hacks in the kernel to allow reading in parallel from /dev/urandom - I guess not
03:10:32 <fr33domlover> i didn't read all the backlog, but perhaps running a thread that generates random numbers would help? e.g. using an MVar
03:10:45 <piyush-kurur> grantwu: also if you are not careful about interrupts and do not check the returned values, the read might not read as much as you thought it would
03:10:47 <fr33domlover> and then other threads can safety fetch numbers, unaware of each other
03:11:02 <fr33domlover> (thanks to MVar fairness)
03:11:16 <tdammers> EvanR: the reason I think that is because too many people do not read documentation, so putting "careful, this isn't actually random" in the README doesn't work
03:11:31 <EvanR> grantwu: linux has 1 generator, i would be curious how you parallelize it
03:12:27 <grantwu> Same way you'd parallelize ph88's code; have it split off per thread generators
03:12:41 <grantwu> http://drsnyder.us/2014/04/16/linux-dev-urandom-and-concurrency.html#comment-1345524493 seems to imply this was done in Solaris
03:13:07 <grantwu> s/per thread/per core/
03:13:27 <EvanR> one generator per core?
03:13:47 <grantwu> Well, one instance of generator state per core
03:14:08 <EvanR> which one do you get when you read from the file, or open it, or
03:14:21 <EvanR> and does it change
03:14:29 <EvanR> how do you guarantee the statistics
03:14:47 <grantwu> Well, presumably the kernel lies
03:14:52 <grantwu> And gives everyone the same fd
03:15:13 <grantwu> But depending on which core you're running you get output from different state
03:15:37 <EvanR> i think the hackernews comments are right, you shouldnt be using urandom for high speed rng, just use it sparingly for seeding your own
03:16:11 <EvanR> then we dont have to answer these questions as users
03:16:14 <grantwu> There are a number of experts who argue that userspace RNG is a bad idea
03:16:33 <grantwu> see https://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/
03:17:20 <EvanR> do we have splittable rngs which are known to be statistically reliable? much less secure
03:17:42 <grantwu> Well... this might be why /dev/urandom doesn't split :P
03:18:22 * grantwu is not an expert on this
03:18:40 <piyush-kurur> grantwu: speed is a big problem with /dev/urandom. I found out that arc4random for example is 300 times faster than reading from /dev/urandom
03:19:17 <EvanR> is /dev/urandom on linux supposed to be used for crypto ?
03:19:17 <grantwu> That said, I can imagine not splitting and just gathering more device entropy
03:19:34 <grantwu> Yes, see http://www.2uo.de/myths-about-urandom/ for an additional source
03:19:43 * grantwu is not an expert, grantwu just googles a lot ._.
03:20:22 <piyush-kurur> EvanR: /dev/urandom is good for crypto but on linux on initial startup /dev/urandom returns some bad stuff
03:20:47 <EvanR> this blog post reads like a jehovas witness brochure
03:21:09 <piyush-kurur> also it is slow and you have to take care of things like interrupts and actually check for the returned values
03:21:36 <EvanR> if its supposed to be used for crypto, then i use that to support the argument that you should use something else for high speed random numbers
03:21:47 <EvanR> because cryptorngs are not as fast, QED
03:21:57 <grantwu> Oh, well, sure
03:22:04 <grantwu> But sometimes you need fast and crypto
03:22:09 <EvanR> probably 2 or 3 logical fallacies there
03:22:34 <grantwu> Yeah, if you don't need cryptographic security, there are plenty of fine userspace RNGs
03:22:54 <grantwu> Heck, for some work, you probably want something that's not cryptographically secure so you can reproduce results
03:23:23 <piyush-kurur> grantwu: you just need to seed things the same way.
03:23:51 <grantwu> Well, yes.
03:24:04 <grantwu> I suppose there are cryptoRNGs which support seeding
03:28:07 <amx> piyush-kurur: the way i recall it linux seeds urandom on boot with random numbers persisted on disk
03:31:01 <ph88> thank you koz_ is that using split instead of restart the standard gen with different seeds ?
03:31:08 <piyush-kurur> amx: yes but /dev/urandom, since it is supposed to not block at all, sometimes does not wait for the system to gather enought entropy. The getrandom call was designed to avoid this and some other problems.
03:32:41 * hackagebot hakyll 4.9.1.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.9.1.0 (JasperVanDerJeugt)
03:32:52 <ph88> fr33domlover, that was my second idea :P
03:38:06 <fr33domlover> ph88, actually if you do that, you can make a package out of it. Maybe even use a typeclass to generalize over the various PRNGs available on Hackage
03:45:31 <koz_> ph88: Yeah - that's what makeManyGens is meant to do.
03:56:27 <ph88> koz_, why you put mkStdGen 42 ?
04:02:43 * hackagebot patat 0.3.3.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.3.3.0 (JasperVanDerJeugt)
04:22:43 * hackagebot sparse-linear-algebra 0.2.1.0 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.1.0 (ocramz)
04:27:43 * hackagebot juicy-gcode 0.1.0.0 - SVG to G-Code converter  https://hackage.haskell.org/package/juicy-gcode-0.1.0.0 (dlacko)
04:43:34 <mrkgnao> o/
04:43:48 <mrkgnao> how do I profile an exectutable built with stack?
04:44:07 <sbrg> pretty sure there's something along the lines of `stack build --profile`
04:44:13 <mrkgnao> it's a simple Gloss program with a game loop
04:44:21 <mrkgnao> when I ctrl-C out of it, I get an empty .prof file
04:45:26 <mrkgnao> sbrg: how do I not get an empty profiler report?
04:45:49 <sbrg> mrkgnao: ensure that it exits cleanly? 
04:46:06 <sbrg> you can just add a handler  to the gloss loop that handles "q" and exits gracefully
04:46:29 <mrkgnao> hmm, I was hoping there was some easy way out
04:46:39 <mrkgnao> guess I'll go learn about gloss event handling
04:47:14 <sbrg> It's pretty simple. you just need to pattern match on a single thing and pass that function to the event handler parameter
04:49:26 <mrkgnao> sbrg: yeah
04:49:37 <mrkgnao> I figured I could just error out early, and it works
04:49:50 <mrkgnao> guess I'll let my laziness get the better of me now :)
04:49:55 <sbrg> haha
04:54:28 <Hi-Angel> Is there a notation to write a binary number? Like "0xab12" for hexadecimals.
04:55:13 <opqdonut> nope, only hexadecimal and octal
04:55:21 <sbrg> there is, actually
04:55:23 <sbrg> there's an extension
04:55:27 <sbrg> BinaryLiterals?
04:55:32 <opqdonut> see e.g. https://www.haskell.org/onlinereport/lexemes.html#sect2.5
04:55:37 <opqdonut> oh, right there might be an extension
04:55:53 <opqdonut> newer link, https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-190002.5
04:56:11 <Hi-Angel> sbrg, oh, cool, thank you, that worked!
04:56:28 <sbrg> yw
05:33:44 <reygoch> can anyone help me with a very annoying problem?
05:34:22 <reygoch> stack has trouble linking libcurl when I include project that depends on curl package in another project
05:34:22 <sbrg> you should just ask your question
05:34:38 <reygoch> sbrg: I just have :D
05:34:42 <sbrg> heh
05:34:52 <sbrg> pasting the error, etc, would probably help as well
05:34:55 <reygoch> I made it a stackoverflow question
05:34:57 <reygoch> http://stackoverflow.com/questions/40342264/haskell-stack-cant-link-libcurl-in-external-project-on-windows
05:35:31 <reygoch> I'm scratching my head for two days wit this problem
05:35:36 <reygoch> *with
05:35:44 <reygoch> can't figure out what to do
05:35:47 <sbrg> i'm afraid I can't help you, but maybe someone here can. just a matter of waiting a bit.
05:38:39 <reygoch> anyone had problems with linking dlls when building with stack?
05:39:13 <reygoch> i need some help
05:45:37 <reygoch> does anyone know how linking with stack and cabal work on windows?
05:46:09 <reygoch> I'm having trouble building a project because linker can't correctly find required dlls
05:47:05 <dcoutts> reygoch: in general you need to tell cabal where to look for pre-installed dlls
05:47:31 <dcoutts> reygoch: e.g. with the --extra-lib-dirs flag (iirc), or the equivalent in the local cabal.config file
05:48:13 <reygoch> well, problem is that I build one project successfuly that required libcurl but than when I include that project into another project it can't link libcurl properly
05:48:36 <reygoch> dcoutts: if you can take a look 
05:48:44 <reygoch> dcoutts: http://stackoverflow.com/questions/40342264/haskell-stack-cant-link-libcurl-in-external-project-on-windows
05:50:07 <dcoutts> reygoch: it probably doesn't work for the first one either, one just doesn't notice immediately
05:50:42 <dcoutts> reygoch: where does the curl.dll actually live? I bet it's not really part of mingw right?
05:50:51 <reygoch> I've tried using curl library in haskell on a separate clean project and it works
05:50:55 <reygoch> yes, it's in mingw folder
05:51:02 <reygoch> and location is correct
05:51:15 <reygoch> but it reports it doesn't exist
06:13:42 <eacameron> Why does everyone now use this as the version bounds for base? base >= 4.5 && < 5?  Almost every major version bump to base been in the 4. range. I would totally expect the next version of GHC to hase base 4.10, not base 5.
06:17:56 <srhb> eacameron: Isn't that what the pvp dictates?
06:18:17 <srhb> Anyway, it's just a proxy for "this ghc version and the next ones" which seldom works anyway :P
06:18:26 <eacameron> srhb: Heh...it's true.
06:19:07 <eacameron> srhb: I don't know what the PVP dictates. So PVP says that succ 4.9 == 5? 
06:20:29 <lyxia> <4.10 would be PVP compliant actually
06:20:50 <lyxia> People use <5 in the hope that their code won't break with the next GHC version.
06:21:55 <eacameron> Hah...well, going by history, it would be "hope their code won't break with the next dozen GHC versions"
06:21:55 <ongy> a bump to 5 may be something rather breaking. New FilePath or something weird
06:22:07 <ongy> so you would expect most things to break
06:30:58 <muzzle> hi, is GHC broken on OS X Sierra?
06:31:05 <muzzle> specifically for yesod-builds?
06:31:29 <ertesx> eacameron: i use "from here to the next major version" almost for every package
06:32:00 <eacameron> muzzle: I believe it is. Search reddit for a discussion
06:32:13 <eacameron> ertesx: where "next major version" is 4.10?
06:32:23 <amx> muzzle: from what I've read you need the upcoming 8.0.2 on sierra
06:32:38 <ertesx> eacameron: base >= 4.8 && < 5, vector >= 0.11 && < 1, …
06:32:46 <muzzle> I saw something to that effect on github eacameron
06:32:58 <eacameron> ertesx: ohh, for every dependency package. Gotcha.
06:33:03 <muzzle> does anyone know, if there is going to be a fix from either apple or the GHC team soon
06:33:04 <eacameron> ertesx: How does that work out?
06:33:26 <eacameron> muzzle: GHC devs are working on it for 8.0.2 which was supposed to be out by now but was delayed for this very reason.
06:33:40 <ahihi> muzzle: https://ghc.haskell.org/trac/ghc/ticket/12479
06:33:48 <ertesx> eacameron: usually good enough, as most package authors try not to break too much between minor versions, and it makes the maintenance burden much lighter
06:33:59 <muzzle> eacameron thx
06:35:26 <muzzle> what library do i best use for the FTP protocol? ftphs?
06:37:33 <eacameron> muzzle: for server or for client?
06:37:52 <muzzle> client
06:39:35 <eacameron> muzzle: that's the only sensible library I'm seeing, so I'd say try it out.
06:40:06 <eacameron> muzzle: It's 3 years old, but this library is much newer and uses it: https://hackage.haskell.org/package/FTPLine
06:40:24 <eacameron> s/library/package
06:49:09 <jchia> I have simple code that caused GHC 8.0.1 to crash: http://lpaste.net/316918. It's related to TH. Is bad TH code expected to cause GHC to crash?
06:50:56 <geekosaur> yes, or at least TH was not designed to be bulletproof, it was designed to expose compiler internals
06:51:42 <jchia> So I suppose it's not considered a bug.
06:51:54 <jchia> not considered a GHC bug
06:58:45 <eacameron> jchia: That does look like a potential GHC bug so I'd report it. Might also want to create an issue for Aeson in case it's Aeson's fault.
07:00:04 <eacameron> jchia: That's an awesome minimal failure case.
07:06:10 <jchia> eacameron: Well, the GHC trac says I lack TICKET_CREATE privilege.
07:06:20 <eacameron> :/
07:06:27 <jchia> never mind
07:06:30 <jchia> email verification
07:06:33 <eacameron> ah.
07:06:39 <eacameron> Thanks for contributing.
07:14:19 <jchia> https://ghc.haskell.org/trac/ghc/ticket/12788
07:24:32 <orion> I'm using GHC 8.0.1 from hvr's PPA on Xenial, and I'm running a small scotty application. When I run the application and take no requests, the Virtual Memory Size is (almost exactly) 1 GB, but the Resident Set Size is 25KB. Does anyone know why this might be?
07:25:10 <jchia> orion: Are you concerned about the large virtual memory size?
07:27:17 <orion> Yes.
07:27:56 <geekosaur> that is expected and meaningless
07:28:32 <jchia> orion: Generally speaking, without involving Haskell or Scotty in the context, virtual memory just means how much memory space has been mapped by the process. It doesn't mean it's even been accessed.
07:29:17 <geekosaur> not even mapped
07:29:18 <orion> Indeed -- I've looked at the various profiling options available, but I'm not sure how to determine the root cause of this.
07:29:34 <jchia> i mean addressable, not "mapped to RAM"
07:29:36 <geekosaur> just has page table entries allocated
07:29:36 <geekosaur> http://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/8.0.1-notes.html#runtime-system
07:30:37 <jchia> the process can read or write the address, but it doesn't mean that it has or it will or that the address corresponds to RAM
07:32:26 <orion> geekosaur: Thanks, I'll consider is benign then.
07:38:07 <ab9rf> it would be a problem if you tried to run it on an OS from 1973
07:38:15 <ab9rf> but we're smarter than that today
07:38:38 <iFlow> Hello there!... I got a little question and maybe someone is able to explain :) ... Why does using the fromInteral function on the numerator of a Rational not match the signature of my funcion Int -> Int? I get "Instance of Floating Int required for definition ..."..
07:40:41 <geekosaur> @paste
07:40:41 <lambdabot> Haskell pastebin: http://lpaste.net/
07:41:05 <geekosaur> you are probably focusing on the wrong "cause"
07:44:09 <geekosaur> fromIntegral only confers a Num constraint. if you are getting a Floating constraint then you are getting it from somewhere else
07:46:49 <iFlow> http://ideone.com/OgqRQY
07:47:23 <iFlow> here is the code that is causing this error in hugs...
07:47:40 <geekosaur> so you declare i as Int but then pass it to log
07:47:42 <geekosaur> :t log
07:47:44 <lambdabot> Floating a => a -> a
07:47:57 <geekosaur> you have to apply fromIntegral to it
07:48:04 <vinnie92> :t uncurry
07:48:06 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:50:22 <hexagoxel> "denominator x == 0" uuh
07:52:09 <geekosaur> yeh, that is a bit dubious
07:52:36 <ahihi> it would also make more sense for this function to return Maybe Int rather than (Bool, Int)
07:52:37 <iFlow> @geekosaur: well that fixed at least the error ^^
07:52:37 <lambdabot> Unknown command, try @list
07:52:53 <geekosaur> right, hexagoxel just pointed at a logic error though
07:53:18 <bollu> :t fmap . const
07:53:20 <lambdabot> Functor f => b -> f b1 -> f b
07:53:21 <buglebudabey> if i want to have a mutable matrix, is it better to use STArray, Vector.Mutable, or something else?
07:53:24 <bollu> how do I derive that type?
07:53:45 <bollu> like, I can't quite see how (.), fmap, and const fit together
07:54:42 <exio4> bollu: I would try to expand (.) first
07:54:46 <exio4> @src (.)
07:54:46 <lambdabot> (f . g) x = f (g x)
07:54:50 <hexagoxel> @pointful fmap . const
07:54:51 <lambdabot> (\ x -> fmap (\ _ -> x))
07:54:59 <lpaste> iphy pasted “callback boilerplate” at http://lpaste.net/317313
07:55:11 <byorgey> bollu: write out the types for fmap, (.), and const.  Use different type variable names for all of them.  Then unify the argument types of (.) with the types of fmap and const.
07:55:11 <exio4> \x -> (fmap . const) x = \x -> fmap (const x) 
07:55:23 <iFlow> thank you for your help geekosaur and hexagoxel :)
07:55:32 <iphy> I have the above boilerplate about 15 times
07:55:34 <bollu> byorgey: yep, was doing that. Got a little confused with the interaction between (.) and fmap. Lemme try again
07:55:58 <iphy> this boilerplate (http://lpaste.net/317313) is repeated 15 times, is there any way I can reduce it?
07:56:48 <byorgey> well,  fmap :: (d -> e) -> (f d -> f e).  So if  (.) :: (b -> c) -> (a -> b) -> (a -> c)  then  in  fmap . const,  we have   b = d -> e   and   c = f d -> f e.
07:57:51 * hackagebot feed-gipeda 0.3.0.1 - CI service around gipeda  https://hackage.haskell.org/package/feed-gipeda-0.3.0.1 (sgraf812)
07:58:52 <bollu> byorgey: thanks! that helps
07:59:46 <lyxia> iphy: can you paste all of it to get an idea of what part exactly is repetitive 
08:00:08 <iphy> I haven't done all of them yet, but I can do a second one
08:00:23 <lyxia> that would help indeed 
08:00:56 <hexagoxel> iFlow: also that toRational conversion (or the division itself) is not lossless, so you can get wrong results.
08:01:18 <hexagoxel> > toRational $ log (2**50+1) / log 2
08:01:20 <lambdabot>  50 % 1
08:01:39 <hexagoxel> => "2**50+1 is power of 2"
08:01:53 <bollu> byorgey: I usually think of (.) as a math composition. fmap and const both have multiple parameters, so fmap . const throws me off
08:02:01 <bollu> byorgey: how do intuitively think about this?
08:02:08 <lpaste> iphy revised “callback boilerplate”: “callback boilerplate” at http://lpaste.net/317313
08:02:15 <iphy> lyxia: ^
08:02:44 <iphy> the fromCEnum is not really necessary, I can do that in client code if removing it makes reducing boilerplate easier
08:03:21 <ph88> is there a function to map but keep the old value? like   zip (map f xs) xs  ?
08:03:29 <lpaste> iphy revised “callback boilerplate”: “callback boilerplate” at http://lpaste.net/317313
08:03:34 <iphy> so like this ^
08:04:27 <ahihi> > let f = (*2) in map (f ||| id) [1,2,3]
08:04:29 <lambdabot>  error:
08:04:30 <lambdabot>      • Ambiguous type variable ‘b0’ arising from a use of ‘show_M865394242015...
08:04:30 <lambdabot>        prevents the constraint ‘(Show b0)’ from being solved.
08:04:41 <ggVGc> I'm wishing to do something along the lines of combining a ({x::Int} -> Foo) and ({y::String} -> Foo), and getting a function ({x::Int, y::String} -> Foo). Is Vinyl the right tool for this?
08:04:45 <ahihi> > let f = (*2) in map (f &&& id) [1,2,3] -- oops
08:04:47 <lambdabot>  [(2,1),(4,2),(6,3)]
08:05:13 <ggVGc> is can I do something similar in a simpler way?
08:05:39 <Welkin> has anyone used the amazonka library?
08:05:49 <ph88> does someone know a function to divide an integer in parts so that each part is also an integer ?  example: 5 / 4 = 1.25 but 1.25 is not an integer, so instead you can have 4 parts: [2,1,1,1]
08:05:56 <Welkin> I've been using hsS3 for a while now, because amazonka has massiv dependencies (including lens?)
08:06:17 <Welkin> I have o idea how to construct the request body to send an object
08:06:22 <Welkin> no idea*
08:06:24 <iphy> ph88: `div`
08:06:43 <iphy> ph88: 5 / 4 is not integer division
08:07:19 <Welkin> http://hackage.haskell.org/package/amazonka-core-1.4.4/docs/Network-AWS-Data-Body.html#t:RqBody
08:07:20 <ph88> yeah ok .. that wasn't haskell code
08:07:25 <byorgey> bollu: the way to think about it is to realize that fmap and const both have only one parameter, just like every function in Haskell
08:07:44 <mizu_no_oto_work> bollu: remember that a - > b -> c == a -> (b -> c).   const :: a -> (b -> a) and fmap :: Functor f => (a -> b) -> (f a -> f b)
08:07:45 <byorgey> bollu: in particular they take one parameter and return a function.    fmap :: (a -> b) -> (f a -> f b),   const :: a -> (b -> a)
08:08:06 <ashishnegi> hi.. i am reading the `y combinator` wiki page and it says.. "The Y combinator is an example of what makes the Lambda calculus inconsistent.".. can someone explains this ?
08:08:24 <Welkin> is it just this? http://hackage.haskell.org/package/amazonka-core-1.4.4/docs/Network-AWS-Data-Body.html#t:ToBody
08:08:32 <ahihi> ph88: this seems like an uncommon thing, I expect you'll have to write it yourself
08:08:33 <ashishnegi> is it because `:t let y x = x x ` 's type is not defined ?
08:08:35 <geekosaur> ph88, maybe more to the point look at divMod and/or quotRem
08:08:43 <ph88> oki
08:08:51 <geekosaur> ashishnegi, lambda calculus is not necessarily typed
08:09:07 <fr33domlover> bollu, "const takes value x returns a constant function i.e. one that takes whatever and always returns X"
08:09:22 <ashishnegi> geekosaur: so why then that comment on wiki page ?
08:09:27 <bollu> byorgey: oh right, think of the curried version
08:09:36 <bollu> fr33domlover, byorgey: thanks :) that helps
08:09:39 <bollu> mizu_no_oto_work: ty
08:09:44 <ashishnegi> the full line is "The Y combinator is an example of what makes the Lambda calculus inconsistent. So it should be regarded with suspicion. However it is safe to consider the Y combinator when defined in mathematic logic only. "
08:10:47 <ph88> if i have two list one like  [1,1] and the other like [1,1,1,5]  what function can i use so that i do + so i get  [2,2,1,5]  ?
08:11:17 <tdammers> ph88:  naively, zipWith (+)
08:11:27 <Welkin> I guess I'll just have to installed all of hackage to get this package working
08:11:32 <tdammers> ph88: that won't work entirely though, because it'll chop both lists to the length of the shorter one
08:11:47 <ph88> that's not what i want, i want the size of the biggest list
08:11:56 <tdammers> yes, so you'll have to do some padding
08:12:35 <lyxia>  iphy you can use (fmap .  fmap) to compose with a function of 2 arguments, (fmap . fmap . fmap)  with 3, etc. 
08:12:37 <tdammers> something like:
08:13:16 <c_wraith> ashishnegi: are you familiar with fix in haskell?  It's not implemented as the Y combinator, but it does the same thing.
08:13:39 <tdammers> > let f a b = let l = max (len a) (len b) in take l (zipWith (+) (a ++ [0..]) (b ++ [0..])
08:13:41 <lambdabot>  <hint>:1:89: error:
08:13:42 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:13:54 <ashishnegi> c_wraith: i have "used" fix.. sometimes.. but i am not aware of any type theory behind it..
08:13:56 <tdammers> > let f a b = let l = max (len a) (len b) in take l (zipWith (+) (a ++ [0..]) (b ++ [0..]) in f [1,1] [1,1,2,3]
08:13:58 <lambdabot>  <hint>:1:90: error: parse error on input ‘in’
08:14:04 <c_wraith> ashishnegi: well...
08:14:07 <tdammers> httngh
08:14:09 <c_wraith> :t fix id -- ashishnegi 
08:14:10 <lambdabot> a
08:14:19 <iphy> lyxia: that doesn't decrease boilerplate, does it?
08:14:34 <c_wraith> ashishnegi: There.  A proof of absolutely anything at all.  As far as logics go, that's inconsistent by definition
08:14:53 <c_wraith> ashishnegi: since the definition of inconsistent is that allows proving both a and Not a
08:15:00 <c_wraith> (for some a)
08:15:12 <c_wraith> ashishnegi: well, the Y combinator allows it for all a
08:15:50 <ashishnegi> c_wraith: "A proof" .. how is `fix id` a proof of something ? i mean .. by "type" ?
08:16:07 <c_wraith> ashishnegi: are you familiar with the Curry-Howard isomorphism?
08:16:46 <flyt> Is there a way to add value constraints to a data declaration such that its inputs are tested at initialisation?
08:16:48 <ashishnegi> c_wraith: familiar yes..
08:17:37 <geekosaur> tdammers, nested let-s, you need braces on the inner one to delimit
08:17:38 <c_wraith> ashishnegi: well, it says all programs are proofs of their types, if you view their type as a logical proposition.  (Note that every type system is its own logic, in this interpretation)
08:17:50 <ph88> tdammers, what do you think of this? https://paste.fedoraproject.org/466856/79270391/
08:17:52 * hackagebot persistent-iproute 0.2.3 - Persistent instances for types in iproute  https://hackage.haskell.org/package/persistent-iproute-0.2.3 (sickmind)
08:18:18 <geekosaur> flyt, no, you need to make smart constructors and not export the generated ones (or only export them from an Internals module)
08:18:27 <ashishnegi> c_wraith: "propositions as types"
08:18:49 <flyt> geekosaur: Ok, thanks.  I'll take a look
08:19:37 <ashishnegi> :t fix
08:19:38 <lambdabot> (a -> a) -> a
08:20:48 <c_wraith> If that type is viewed as a logical proposition, it's the logical fallacy known as "begging the question". (Which is poorly named given modern idioms.)
08:20:48 <ashishnegi> c_wraith:  oh.. so fix without taking any `a` but only a fn (a -> a) can give me `a`.. that is inconsistent.. right ?
08:21:11 <c_wraith> ashishnegi: yes.  id is just the simplest example of it.
08:21:33 <c_wraith> ashishnegi: since id matches up with the a -> a perfectly, fix id is obviously not good. :)
08:21:47 <tdammers> > let f a b = (let l = max (len a) (len b) in take l (zipWith (+) (a ++ [0..]) (b ++ [0..])) in f [1,1] [1,1,2,3] --right
08:21:49 <lambdabot>  <hint>:1:92: error: parse error on input ‘in’
08:22:16 <geekosaur> {} not ()
08:22:32 * tdammers facepalms
08:22:52 * hackagebot hledger-ui 1.0.3 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-1.0.3 (SimonMichael)
08:22:54 <tdammers> .oO( no haskell for me today )
08:23:40 <ashishnegi> c_wraith: nice.. so inconsistent is one that allows proving a and Not a (for some a).. can you give some pointers around `for some a` ?
08:24:02 <ashishnegi> and how Y combinator does that for all "a" ?
08:24:38 <ashishnegi> for some a.. does it mean for functions of type only `(a -> a)`
08:24:50 <ashishnegi> and not of type say.. (a -> b) .. or (a -> b -> c)
08:25:06 <c_wraith> ashishnegi: Usually unbound type variables are assumed to be universally quantified.
08:25:14 <elfeck> Hi, I am looking for some way to iterate a IO-function with arguments from the previous function call. How can I do that?
08:25:20 <c_wraith> ashishnegi: But if we make the quantification explicit:
08:25:39 <c_wraith> ashishnegi: a logic is inconsistent if there exists an a such that it can prove both a and Not a
08:25:54 <c_wraith> ashishnegi: and the type of fix is forall a. (a -> a) -> a
08:26:42 <c_wraith> ashishnegi: So the Y combinator means that it's really easy to find a specific a such that there are proofs of a and Not a.  You pick any a you want.
08:29:23 <ashishnegi> c_wraith: and in case of fix it is little difficult to find for which logic is inconsistent..
08:30:40 <byorgey> ashishnegi: 'fix id' has any type you like, since you get to pick the type 'a'.   So for some chosen type p we have both  fix id :: p  and  fix id :: Not p
08:31:08 <byorgey> however Not is defined, it is typical to define  Not p = p -> Void  but it doesn't really matter, the point is that fix allows you to prove anything you want.
08:31:27 <c_wraith> ashishnegi: well, go back to Curry-Howard.  Every language defines its own type system, which is its own logic.  So if you go to the untyped lambda calculus..  Well, it's a pretty barren logic.  The simply-typed lambda calculus matches propositional logic, iirc, and actually forbids the Y combinator.
08:34:25 <c_wraith> ashishnegi: Haskell's logic is an inconsistent variant of System F, with some other stuff thrown in.  The more extensions you enable, the more other stuff gets thrown in.  :)
08:34:54 <ashishnegi> byorgey: oh.. so fix is like "fooling" the type system .. sometimes..
08:34:56 <TallerGhostWalt> can someone tell me the stack equivalent of --show-details=always please?
08:35:04 <TallerGhostWalt> for tests I mean
08:37:46 <byorgey> ashishnegi: I don't think that's the right way to think about it, the type system works just fine with fix.  The point is that if you have fix, the type system corresponds to an inconsistent logic.  Every type is inhabited, i.e. every proposition is provable.
08:38:55 <tsahyt> when wrapping a C library that uses an OO style, what's the best way to provide a function with a "class that implements a given interface"? the C library uses a struct of function pointers, and I was thinking a record of functions would be a good way to do this on the Haskell side. Is there a better way?
08:39:43 <c_wraith> tsahyt: a record of functions is pretty good.
08:40:42 <ashishnegi> c_wraith: byorgey thanks.. so much.. one last question : Would should i start to read to understand all this in better way ?
08:41:03 <lpaste> aphorisme pasted “Design advice / Undecidable Instances okay?” at http://lpaste.net/317573
08:41:18 <tsahyt> good, thanks!
08:41:35 <c_wraith> ashishnegi: not sure.  I've learned most of this from keeping an eye on this channel.  It's a great place for passive learning. :)
08:42:08 <c_wraith> byorgey: does something like TAPL discuss this in a good introductory manner?
08:42:27 <c_wraith> (I'm asking byorgey on this one because he's the academic and has probably actually read it)
08:42:53 <TallerGhostWalt> stack test --show-details=always doesn't work... what does
08:45:37 <aphorisme> I would appreciate if anyone finds time to have a look into http://lpaste.net/317573  : )
08:47:17 <geekosaur> the second instance overlaps the first, and indeed any other instance that might be defined
08:50:13 <ph88> how can i change this code so that i can run another algorithm and plot it in the same chart ?  https://paste.fedoraproject.org/466875/28973147/
08:50:25 <ph88> maybe i can replace >>= on line 3 with a do block ?
08:51:46 <byorgey> c_wraith: TaPL only mentions Curry-Howard in passing
08:52:31 <c_wraith> So it's not the answer here.  Got it. :)
08:54:52 <byorgey> ashishnegi: good question.  you might like to read http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf
08:55:42 <timeoff88> It was a good feeling writing my first Monadic code in Haskell. And it delivered the same  result as the original, non-monadic version. Unfortunately, what changed was that the monadic version takes exponentially more time to return. I did not attempt to do any "premature" optimisation (just trying to get a better feel for monads first) but I would
08:55:42 <timeoff88>  now appreciate any comments: http://lpaste.net/317639
08:57:48 <timeoff88> On the JVM I would be suspicious of equals/hashcode/compare (I made instances of Eq and Ord here, for Profiler, as the function uses min :: [a] -> a)
08:58:41 <timeoff88> the code is not disimillar in shape to Waddler's Monads For FP clasic
09:00:22 <ph88> how can i let the program report the time it took to run some function? this is for the user so i don't want program statistics or something like that
09:01:58 <sm> ph88: timeit is a nice little package
09:02:00 <ggVGc> Is there anything that could help me automatically convert tuples like  (((a,b), c), d) into (a,b,c,d)?
09:04:21 <dmwit_> ggVGc: I'm not sure about any packages that exist. I've seen a few attempts at doing it and they all suck for various reasons.
09:08:14 <ph88> alright sm i'll check out timeit
09:08:20 <dmwit> timeoff88: Those `Eq` and `Ord` instances for `Profiler` look pretty suspicious to me.
09:08:39 <timeoff88> dmwit: not a great surprise!
09:08:59 <timeoff88> I pretty much wrote them by brute-force
09:09:25 <dmwit> timeoff88: Perhaps you wanted `otherwise = liftM2 min (...) nextD` instead?
09:09:47 <dmwit> timeoff88: Otherwise you're "escaping" from the `Profiler` on every recursive call.
09:10:06 <ph88> can anyone help me out refactor a do-block ?
09:11:56 <timeoff88> dmwit: I tried something like that but couldn't get it to type check - I will try again, thanks
09:12:30 <dmwit> timeoff88: I just tested. It is indeed the problem; inserting `liftM2` before `min` takes us back to 0.01 seconds to compute `tM`.
09:12:59 <dmwit> And you don't need the instance declarations after that, either. =)
09:13:21 <ggVGc> Does anyone have any comments on this? I am basically trying to create a tree of "Ops" where each one has a state. https://gist.github.com/bf30a21e6a9632f1eccfcba908e79dc9
09:13:47 <timeoff88> dmwit: my laptop must be faster than yous, on mine it took 0.00 secs
09:14:02 <timeoff88> ... faster than the raw version ;)
09:14:02 <dmwit> sure =)
09:15:13 <timeoff88> dmwit: yes, I felt it was a bit OTT to have to write Eq & Ord with all the lifting posibilities, but I misses liftM2 in this case
09:15:43 <timeoff88> dmwit: I have never shown any Haskell code to anybody before. Does the code look OK otherwse?
09:16:09 <Welkin> timeoff88: just read a lot of code, particularly from truest libraries
09:16:14 <dmwit> timeoff88: Seems reasonable enough to be.
09:16:20 <Welkin> you'll get a feel for how to write
09:16:26 <Welkin> trusted*
09:16:30 <timeoff88> dmwit: and if I did have to implement Eq and/or Ord, can you give any tips on how to improve those?
09:16:35 <Welkin> feeling*
09:16:40 <dmwit> ggVGc: I have to admit I don't understand your goal yet.
09:16:56 <dmwit> ggVGc: Still trying to decipher your code. Your very abstract names aren't helping. =P
09:17:32 <dmwit> timeoff88: If you want them to be law-abiding, you're going to have a bad time.
09:17:47 <dmwit> timeoff88: See the `universe-reverse-instances` package (and its source) for some ideas.
09:18:20 <dmwit> http://hackage.haskell.org/package/universe-reverse-instances-1.0/docs/src/Data-Universe-Instances-Eq.html
09:18:46 <dmwit> Since your domain is `Int`, anything law-abiding is going to take a *long* time to complete.
09:19:43 <timeoff88> dmwit: so the idea is always to look for a way to lift existing (trusted) functions as much as possible, right?
09:20:12 <dmwit> timeoff88: On the other hand, if you changed from `State Int` (with only `modify (+1)` as the exposed API) to `Writer (Sum Int)`, equality and comparison would be much quicker and easier to write to boot.
09:20:37 <ggVGc> dmwit: in the end it's for a UI thing. Basically I want to define UI modules that hold an internal state. And I want to combine these in a generic way. But I also need to be able to access this internal state, in order to create meta-modules that can sync parts of the states of underlying modules. So the way I see it the type of the state of a combination of modules has to reflect all the types of the 
09:20:39 <NemesisD> how would one modify one of a prism's functions. for instance I've got Prism' a b and I have a -> c, I need a Prism' c b
09:20:43 <ggVGc> nested states
09:20:44 <ggVGc> so this is what I came up with
09:21:49 <timeoff88> dmwit: ok, I need to digest that, and your comment about "escaping the monad". Thank you.
09:22:12 <dmwit> timeoff88: I'm happy to unpack that statement some.
09:22:27 <dmwit> ggVGc: That is a tough domain to work in. I can understand why a solution would end up being complicated.
09:22:47 <timeoff88> dmwit: I'm all ears
09:23:13 <timeoff88> dmwit: (I guess Imiised your pun)
09:23:25 <dmwit> timeoff88: `State Int a` is `Int -> (a, Int)`, right? The problem with this type is that functions can do "too much stuff". You've chosen to just look at what your `State Int a` does starting from state `0`. But to be really careful, you would have to see what it does starting from any old state, since functions can inspect their inputs before deciding what to do.
09:23:34 <ggVGc> dmwit: I've got a solution already, where my modules are Monoids, but since I couldn't solve it I now keep all the states of all modules in one big record, that every module works on. Hence they can be monoids(since they all get passed the same state)
09:23:50 <ggVGc> but that's obviously not what I want
09:23:55 <dmwit> timeoff88: Inspecting what it does for *every* starting `Int` takes a long time, because there are lots of starting `Int`s.
09:24:16 <dmwit> timeoff88: On the other hand, you're really expecting that the only functions you'll have are of the form `\s -> (v, s+x)` for some `v` and `x`.
09:24:37 <dmwit> timeoff88: (That is, you're expecting to just add something to the initial state, then return your value.)
09:24:57 <dmwit> timeoff88: So you should make your type reflect that, by just storing `v` and `x` instead of allowing the type to have all the values a function can have.
09:25:18 <dmwit> timeoff88: This is what `Writer (Sum Int) a` does: after unwrapping all the `newtype`s, a `Writer (Sum Int) a` is an `(Int, a)`.
09:25:45 <dmwit> timeoff88: Which you would interpret as "the number you're going to add" (`x` from above) and "the value you're going to return" (`v` from above).
09:26:02 <dmwit> timeoff88: Instead of `modify (+1)` you would then write `tell 1`.
09:26:16 <dmwit> timeoff88: Now comparisons are easy: you just do lexicographical ordering on tuples.
09:26:34 <dmwit> timeoff88: Okay, now I'll pause. Tell me which bits made sense and which didn't.
09:27:35 <timeoff88> dmwit: I am working on the functions can have lots of values bit - is that in the context of making my Eq/Ord slow or in the context of easier to write Eq/Ord?
09:27:55 * hackagebot semiring-num 0.1.0.2 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.1.0.2 (oisdk)
09:28:21 <dmwit> timeoff88: I refuse to talk about your Eq/Ord instance being slow. It's too wrong to worry about performance. =P
09:29:20 <timeoff88> dmwit: "premature optimisation is th eroot of all evil" is how I got into this mess in the first place - I totally ignored optimisation ;).
09:29:26 <dmwit> timeoff88: Consider: your instance says that `\s -> (v, s)` and `\s -> (v, 2*s)` are equal. This is clearly absurd.
09:30:02 <timeoff88> dmwit: yes I was not comfortable about ignoring the state, but for this purpose the value was all I cared about
09:30:32 <timeoff88> and as functions, ir's nonsense
09:30:43 <dmwit> timeoff88: Oh, right, I forgot just how wrong your thing was. Okay, then consider this, which affects the value: your instance says that `\s -> (s, s)` and `\s -> (2*s, 2*s)` are equal, which is even more absurd.
09:30:59 <timeoff88> dmwit: I see what you mean. A bit like no instance of Show for ... idea
09:31:26 <timeoff88> dmwit: worse than absurd - close to criminal
09:31:29 <dmwit> timeoff88: That is, my complaint is that you *start from the fixed state `0`*, not that you ignore the ending state.
09:31:44 <dmwit> (Though that other thing is bad, too. =)
09:32:43 <dmwit> timeoff88: Okay. So now maybe you should sit down and think about how to fix that problem, or I'll be happy to tell you how I would fix it. Once you see the fix, you'll see why you don't want to do that...
09:33:02 <timeoff88> dmwit: yes everything re the state is just added fro convenience, and totall ignored. But at least I decided if 2 Profilers are the same if the value returned is the same
09:33:22 <dmwit> timeoff88: Right. But `Profiler`s can return different values if you start them off in different states.
09:33:39 <dmwit> timeoff88: And two `Profiler`s might happen to agree on state `0` coincidentally but not agree anywhere else.
09:34:03 <timeoff88> dmwit: yes - my equals is god (if that is not too strong a word) only if they start at 0, otherwise undefined
09:34:16 <timeoff88> s/god/good
09:34:37 <dmwit> timeoff88: Indeed. So my point is: let's encode the "starts at `0`" thing *into the type* so that it's not an assumption.
09:34:48 <timeoff88> dmwit: nice
09:36:05 <dmwit> newtype Profiler a = Profiler { runProfiler :: (a, Int) }; intsance Monad Profiler where return x = Profiler (x, 0); Profiler (i, c) >>= f = let Profiler (o, c') = f i in Profiler (o, c+c')
09:37:03 <dmwit> Now equality and ordering are easy. `instance Eq a => Eq (Profiler a) where Profiler p == Profiler p' = p == p'` and similarly for `compare`.
09:38:11 <dmwit> Of course now you have a semantic difference between `min` and `liftM2 min`: the former picks the action that gets the smaller answer (or the same answer in fewer ticks, if they get the same answer), while the latter picks the smaller value but counts ticks from both actions.
09:38:30 <timeoff88> dmwit: I started by writing the exact same impl for my Profiler, but of course, it is nonsense when a p is a function.
09:38:45 <dmwit> What is `p`?
09:39:18 <dmwit> Oh, you mean the `p` in the instance of `Eq` that I wrote?
09:39:40 <dmwit> Well, it's not nonsense. But you probably don't want that.
09:39:59 <timeoff88> I was trying pattern matching in my instance declarations (which ghc didn't like: Profiler p1 == Profiler p2 = p1 == p2
09:40:21 <dmwit> Yes, you need an `Eq` instance for functions for that to work.
09:40:32 <timeoff88> obviously wrong, but it was my first attempt; probably due to the namespace diggerence between types and expresions
09:40:36 <dmwit> It can be done (as in the package I posted above). But it's unlikely that you want this.
09:41:02 <timeoff88> dmwit: it's good to know it exists, but I am not quite there yet ;)
09:41:23 <dmwit> It's not a namespacing issue, it's a semantic one. You have to say what `p1 == p2` means when `p1` and `p2` are functions (and this is not done in the base library).
09:42:34 <timeoff88> dmwit: yes, I understand that bit, but I was so dissappointed at not beingable to lift min and having to write Eq and Ord that I momentarily thought of the type constructor taking an a
09:43:04 <dmwit> Okay. Can you say more about what went wrong when you tried to lift `min`? That worked just fine for me.
09:43:42 <timeoff88> ...and that I could equals check that. So all wrong. And I knew my Eq and Ord smelt, but wasn't sure why yet. Escaping the monad and == on functions is a good steer
09:44:35 <timeoff88> dmwit: it works fine for me too, it was just someting I did wrong
09:45:09 <timeoff88> dmwit: I don't understand how minCoinsM is now faster than minCoins though!
09:45:44 <timeoff88> does lift'ing allow the compiler to take more liberties re strictness?
09:47:23 <dmwit> Not sure about that myself. But I wouldn't read too much into it: until you compile with `-O2`, all performance comparisons are suspect in my mind.
09:52:16 <timeoff88> dmwit: I think I had preconceptions about how hard it might be to profile/optimise Haskell code vs JVM languages, so it probably blurred my vision a bit. With knowledge and advice like this at hand, I hope I can find what is real and what is FUD for myself, because the language is very pretty.
09:53:52 <timeoff88> dmwit: and give a warm fuzzy feeling when you find a nice solution. If you know him, you can also blame Mr Waddler for using State in his paper rather than your version of the Monad!! ;)
09:54:54 <kuribas> Is there a better way to do this?  test :: (Binary a, Num a) => [a] -> Put; test l@[] = put (0 `asTypeOf` head l)
09:56:48 <kuribas> type of `head l` is `a`, even if it's bottom...
09:58:16 <MarcelineVQ> that's quite interesting
10:00:38 <kuribas> Or I could use scopedTypeVariables
10:00:57 <kuribas> test :: forall a.(Binary a, Num a) => [a] -> Put; test l@[] = put (0::a)
10:02:30 <kuribas> I wonder which one is prefered...
10:02:41 <Welkin> damn it...
10:02:49 <Welkin> the amazonka package forces you to use lens o.o
10:03:03 <Welkin> it doesn't export any of the field accessors...
10:03:31 <Welkin> I don't even rememner anything about how to use it
10:03:34 <Welkin> remember*
10:03:40 <MarcelineVQ> I'd prefer the second one since it makes your intent obvious
10:04:11 <Welkin> record & accessor1 ~. newValue1 & accessor2 ~. newValue2
10:04:11 <Welkin> ?
10:04:14 <Welkin> will that even work?
10:04:21 <Welkin> god that looks terrible
10:05:03 <Welkin> compared to `record { accessor1 = newValue1, accessor2 = newValue2 }`
10:06:34 <stumpedGuy> Hey galz and guyz.
10:06:58 <stumpedGuy> In Spacemacs, using Intero, how do I regenerate TAGS?
10:07:23 <kuribas> MarcelineVQ: yeah, asTypeOf is the poor mans scopedTypeVariables
10:07:35 <stumpedGuy> Basically, go-to-definition pops up a Helm box asking me to specify wher my tags file is. I have no idea why it does not do it automatically...
10:08:19 <stumpedGuy> Deleting all generated files, including stack output, etc, and then opening the project, does not seem to help...
10:10:22 <stumpedGuy> :-\
10:27:57 * hackagebot publicsuffix 0.20161031 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20161031 (wereHamster)
10:29:56 <lpaste> hal_ pasted “convolve” at http://lpaste.net/318214
10:29:59 <timeoff88> is there an equivalent of runhaskell for Windows/dos prompt? Does it do more than compile/run your cabal project?
10:30:46 <hal_> Hello, I have here a naive implementation of 1D convolution: http://lpaste.net/318214
10:31:05 <hal_> Are there obvious ways to make this faster or otherwise improve it?
10:34:40 <geekosaur> timeoff88, ghc for windows should come with a runhaskell or runghc
10:35:33 <geekosaur> it's essentially the same as loading your main module into ghci and typing ":main" to run it
10:36:24 <timeoff88> geekosaur: yes, it's there (added to path), thank you.
10:38:08 <kuribas> hal_: this is the one I used, I don't know if it is faster or not:  http://lpaste.net/318246
10:45:04 <Welkin> has anyone used the amazonka package
10:45:05 <Welkin> ?
10:45:09 <Welkin> I am having a lot of trouble with it
10:45:20 <Welkin> I keep getting an error that I don't understand
10:45:28 <pikajude> what might that be
10:46:19 <shapr> Ok, style question, how do I improve my simple interview question code? http://lpaste.net/318297
10:47:00 <Welkin> hold on, may have found what it is
10:47:04 <Welkin> the docs suck for it
10:47:15 <Welkin> and I have to use stackage because they didn't build for this version on hackage
10:47:33 <ongy> shapr: put type annotations in
10:47:37 <shapr> I think there could be more use of fmap in that simple code I just pasted, but I'm not sure how. Any ideas?
10:47:40 <mfukar> shapr, I would not shave variable names. `pat` -> `pattern`
10:47:48 <shapr> mfukar: that's a good point
10:47:58 <shapr> ongy: also a good point
10:48:05 <Welkin> okay, got it to compile at least
10:48:41 <byorgey> shapr: switch the order of arguments to phones, and make it   phones pattern = map head . catMaybes . fmap pattern . lines
10:49:09 <dmwit> shapr: mapMaybe = catMaybes . map pat
10:49:37 <byorgey> oh, I didn't know about mapMaybe.  nice.
10:49:43 <hal_> kuribas, thank you. I hadn't thought of using take/drop. Interesting.
10:50:17 <dmwit> shapr: Does `local` actually do what you want?
10:50:28 <dmwit> Oh! I get it.
10:50:58 <dmwit> neat
10:51:58 <dmwit> shapr: I think I might consider rolling `areacodes` into the regex.
10:52:12 <hal_> kuribas, if I would benchmark these two, would you be interested in the results? I will do it later tonight.
10:52:42 <dmwit> shapr: It's pretty easy, I think: just replace the `[0-9]{3}` with `(404|770)`.
10:53:01 <shapr> Yeah, that's a good point, wasn't sure if I really cared about easy configurability there.
10:53:13 <dmwit> right
10:53:32 <dmwit> I guess my complaint is that `local` is too clever. =P
10:53:59 <shapr> oh, because of "ac p" part at the end?
10:54:16 <shapr> Yeah, anytime someone says "neat" about my code, I realized I need to rewrite that part.
10:54:26 <shapr> or "hey that's cool, didn't know that"
10:54:30 <dmwit> =D
10:57:48 <ongy> shapr: I think that gives you multiples though (if possible)
10:58:26 <timeoff88> has anybody got ghc to work in Windows 10 Ubuntu/bash setting? Is there a write up somewhere? is it known to be not supported?
10:58:45 <kuribas> hal_: sure? I am benchmarking right now
10:58:51 <shapr> ongy: You mean that "ac p" part? 
10:58:56 <kuribas> I mean sure!
10:58:58 <PhsShft> how do you lift an unboxed function so that it can be  applied to boxed arguments? 
10:59:21 <ongy> shapr: If I saw it correctly, you are checking multiple patterns against the number. if multiple patterns fit, you will get the number multiple times
11:00:42 <shapr> Yes, that's a good point, if there are duplicate prefixes, there will be duplicate results.
11:01:35 <ongy> if you know all your patterns will be distinct, it's fine. just something I saw
11:05:57 <kuribas> hal_: my function is slightly faster: http://lpaste.net/318422
11:06:18 <kuribas> 332.8 μs vs 488.1 μs
11:16:08 <hal_> kuribas, thank you!
11:17:06 <kuribas> hal_: feel free to copy
11:18:45 <shapr> byorgey: aha, point-free it, I finally get it.
11:18:49 <shapr> My brain is slow today
11:20:19 <kuribas> hal_: what's your application?
11:22:21 <hal_> experimenting with DSP, mostly audio
11:23:05 <kuribas> nice!  Do you have a library?
11:23:45 <hal_> slowly accumulating one, not open sourced quite yet
11:23:52 <kuribas> DSP in haskell has interests me too.
11:24:24 <kuribas> Though my convolve is used for polynomial multiplication.
11:25:12 <hal_> is it part of a library?
11:25:37 <kuribas> https://hackage.haskell.org/package/cubicbezier-0.4.0.2/docs/Math-BernsteinPoly.html
11:26:35 <hal_> looks very interesting :)
11:28:41 <hal_> I have done some type design in the past, so I can see how the library can be useful
11:29:20 <kuribas> yeah, it was made for type design.
11:29:25 <kuribas> but not exclusively
11:32:31 <kuribas> hal_: it'd be nice to have DSP on the GPU using accelerate for example.
11:35:48 <kuribas> hal_: are you going to open-source it?
11:36:41 <hal_> yes I think so, but it's quite green, and I think it doesn't cover any new terrain yet within the ecosystem
11:37:57 <hal_> I do have some ideas for a massive speed-up for 1D convolution compared to our current algorithms. I will let you know if/when I implement them
11:38:34 <mmaruseacph2> I'll be interested in that too
11:39:48 <hal_> I'll let you know too once I get to it :)
11:40:08 <kuribas> hal_: you can write it as a explicit loop
11:40:18 <hal_> sure, and use mutable vector
11:40:37 <kuribas> The speedup depends on how well Vector fusion works.
11:40:37 <hal_> but even without doing so I think I can push it a bit
11:41:04 <mmaruseacph2> thanks
11:41:18 <kuribas> hal_: well, let me know when you succeed :)
11:41:42 <hal_> I will, I put both your nicks in a TODO ^^
11:42:12 <mmaruseacph2> ^_^
11:43:16 <kuribas> or you can use the FFT.
11:43:44 <hal_> I'll get into FFT-based optimizations later, but good idea.
11:44:01 <kuribas> I don't know if FFT is faster for small convolutions also...
11:44:43 <hal_> I recall reading that it is slower for small kernel size, I think you are right.
11:45:01 <kuribas> So perhaps it's useful as a separate function.
11:45:28 <kuribas> Or switch implementations based on size.
11:46:22 <kuribas> convolution can also be evaluated in parallel easily, so it's a good candidate for GPU.  Probably the GPU already has library functions for it.
11:46:39 <hal_> I wouldn't be surprised.
11:49:50 <mohsen_> Hi 
11:50:35 <mohsen_> How long does it take to learn haskell with studying 3 hours a day the book learnyouahaskell?
11:50:48 <mohsen_> (I mean the online version of it)
11:51:33 <kuribas> mohsen_: depends on what you plan to do with it.
11:51:49 <srhb> If that's all you do, infinity time! :-)
11:52:39 <Nachtgespenst> There are too many variables to that question
11:52:49 <kadoban> mohsen_: I'm of the opinion that LYAH is not enough to learn haskell, I'd choose different learning materials if it were me. http://haskellbook.com/ is good, though not free.
11:54:08 <mohsen_> I meant how long does it take to read it, I don't how many pages it is
11:54:22 <mohsen_> even approximately
11:54:31 <amx> it's 397 pages
11:55:25 <amx> a number that is essentially worthless without knowing page size, font size, or wordcount etc. :P
11:56:08 <mohsen_> I need to learn the basic syntax in a limited time, that's why I'm asking.
11:58:03 <kadoban> mohsen_: Only reading a book will *not* teach you any language I know of. You must, at a minimum, do exercises. (which unfortunately, LYAH doesn't have; which would mean you'd have to both find and then do appropriate exercises, which is ... a hard problem, especially finding appropriate ones)
11:58:07 <ongy> sounds like a weird limitation.
12:00:44 <maerwald> Even if lyah had exercises, it's still too verbose and not concise enough to be proper learning material. It's that kind of thing you can still read after 2 glasses of wine. So if that's the case for you, it might be good.
12:02:24 <nitrix> Is it possible that a `finally` is printing the exception it catches to stderr/stdout ?
12:02:36 <nitrix> The computation is ran, but that noise in the output bothers me.
12:03:44 <geekosaur> only if you had something in there to print it
12:04:15 <hexagoxel> nitrix: finally does not catch.
12:04:35 <hexagoxel> so your exception probably is never caught
12:04:46 <hexagoxel> and then printed by default thread wrapper stuff
12:04:55 <nitrix> Oh, that's the issue then o:
12:05:50 <nitrix> It does say it's a variant of bracket, and bracket re-raises the exception afterwards.
12:05:55 <nitrix> hexagoxel: Appreciated.
12:09:43 <ongy> @src bracket
12:09:43 <lambdabot> bracket before after thing = block $ do
12:09:43 <lambdabot>     a <- before
12:09:43 <lambdabot>     r <- catch (unblock (thing a)) (\e -> after a >> throw e)
12:09:43 <lambdabot>     after a
12:09:43 <lambdabot>     return r
12:10:20 <ongy> :t block
12:10:21 <lambdabot> error: Variable not in scope: block
12:11:56 <hexagoxel> block (unblock) are a shorthand for mask $ \unmask -> .. there
12:12:10 <hexagoxel> :t mask
12:12:12 <lambdabot> ((forall a. IO a -> IO a) -> IO b) -> IO b
12:13:02 <hexagoxel> more confusing than helpful imo
12:13:29 <fabian__> Hi there, I am completely new to Haskell (But not to programming), and I was wondering wich book is the best for learning this language
12:14:08 <kadoban> fabian__: http://haskellbook.com/ is my favorite
12:15:08 <fabian__> Okay, I will look at it! Thanks.
12:15:52 <mohsen_> Does haskell also use libraries like other languages?
12:17:02 <kuribas> mohsen_: of course
12:17:37 <kuribas> They should make a new edition of real-world haskell.
12:17:43 <kuribas> I really liked that book.
12:17:47 <pmade> mohsen_: http://hackage.haskell.org/
12:18:25 <Geraldus> Hi folks! If I'm not mistaken there was some issue with GHC and / or stack on latest macOS Sierra, wasn't it?
12:18:34 <amx> fabian__: I just got this one for my library: http://amzn.to/2e6bqx4
12:18:41 <Geraldus> I wonder is it good time to upgrade OS?
12:18:48 <fabian__> 20:18 < amx> fabian__: I just got this one for my library: http://amzn.to/2e6bqx4
12:18:53 <amx> fabian__: there is definitely less content in that one, but it's available in deadtree and cheaper
12:19:14 <mohsen_> kadoban: Learning a language does not take an infinite time, but the libraries may, because everyday someone in the world may publish a library so thinking generally it would be a large amount.
12:19:32 <fabian__> amx: Thanks
12:19:36 <kadoban> mohsen_: I don't recall saying (or implying) that learning a language takes infinite time.
12:21:08 <mohsen_> kadoban: Wanted to send that message to the channel, sorry.
12:21:27 <Geraldus> Well, no https://github.com/commercialhaskell/stack/issues/2577
12:21:33 <Geraldus> Thanks :D 
12:23:26 <jmorris> How can I make hexToBase64 return a String instead of a ByteString? https://github.com/joshua-morris/cryptopals/blob/master/src/Set1/HexToBase64.hs
12:25:20 <amx> jmorris: I don't know that package, but did you try show?
12:25:25 <ongy> jmorris: why do you want to do that?
12:25:49 <geekosaur> amx, show is a bad idea for that
12:26:32 <jmorris> ongy I can't use putStrLn on it
12:26:42 <ongy> jmorris: Data.ByteString.putStrLn
12:27:15 <ReinH> jmorris: OverloadedStrings only works on string literals
12:27:18 <ReinH> So it does nothing here.
12:27:29 <Geraldus> Ok, let's wait till december :D 
12:28:02 <jmorris> it wont work without it
12:28:47 <nitrix> Using https://hackage.haskell.org/package/websockets-0.9.7.0/docs/Network-WebSockets.html, I am supposed to close the connection upon a CloseRequest :: ConnectionException.
12:28:55 <nitrix> I can't find how to close it though.
12:31:32 <amx> geekosaur: because it should only be used for debugging?
12:32:10 <geekosaur> do you want every string to have quotes wrapped around it and anything outside U+0020 through U+007E converted to escapes?
12:32:20 <geekosaur> that is what show does with a string
12:32:50 <amx> fair enough
12:33:39 <geekosaur> basically show produces the Haskell source that would reproduce the string. not the string itself
12:34:24 <dmwit> jmorris: ...but base64 decoding produces a stream of bytes, not a string.
12:34:54 <dmwit> jmorris: If you want to interpret that stream of bytes as a string, you need to specify an encoding; then the way to do that is to use one of the decoding libraries.
12:35:12 <dmwit> jmorris: And even then `String` seems like a suspicious target type. You might prefer `Text` for most things.
12:36:17 <dmwit> `Data.Text.Encoding` has several functions of type `ByteString -> Text`.
12:38:02 * hackagebot legion 0.7.0.0 - Distributed, stateful, homogeneous microservice framework.  https://hackage.haskell.org/package/legion-0.7.0.0 (taphu)
12:38:15 <jmorris> dmwit what decoding libraries?
12:39:18 <dmwit> The `text` package has decoding functions for some encodings built in. `text-icu` offers more flexibility. `utf8-string` offers UTF8 decoding from `ByteString` to `String`.
12:39:23 <dmwit> There are probably others, too.
12:40:52 <dmwit> I think `bytestring` has some stuff built in for the latin-1 encoding. But if you use that, you automatically fail the "ready for 1999" criteria. ;-)
12:42:22 <geekosaur> they called encode on it, I assume it's utf8
12:43:16 <dmwit> Well, then I'm confused.
12:44:08 <geekosaur> I think they;re confused
12:44:17 <dmwit> I think there's plenty of confusion to go around, yeah.
12:44:24 <geekosaur> like, the earlier claim that they needed to enable OverloadedStringfs
12:44:43 <geekosaur> I think that does nothing to the *source file*, but they;re testing it by loading it in ghci and feeding it a string literal
12:45:11 <geekosaur> and it's ghci that needs OverloadedStrings for that to work, and it inherits it from the module
12:45:42 <geekosaur> whole thing feels kinda cargo-cult stringy :/
12:46:11 <jmorris> im a little bit confused
12:46:23 <EvanR> reading the comments and lore behind the unamb combinator, i get the feeling nobody really understands ghc :D
12:46:36 <c_wraith> ghci doesn't enable extensions used in modules it loads.. 
12:46:37 <ania123> http://pastebin.com/VBL7vBgb
12:46:46 <dmwit> jmorris: Me too. I suspect I've been giving you some bad advice out of my confusion.
12:46:49 <ania123> can ine help me?
12:46:52 <dmwit> jmorris: Maybe we'd better start again, from the top.
12:47:17 <dmwit> ania123: Yes, n+k patterns have been removed from the language for 6 years.
12:47:25 <geekosaur> ania123, N+K patterns were dropped form haskell2010
12:47:40 <dmwit> ania123: You can turn them back on with a language pragma, or refactor your code to avoid needing them.
12:48:21 <ania123> x + y pattern is not allowd?
12:48:31 <ania123> ?
12:48:37 <dmwit> correct
12:48:46 <geekosaur> yes. it was of limited usefulness and caused quite a few problems, so it was removed
12:49:18 <ania123> foo x+y = something
12:49:25 <ania123> can not be defined ?
12:49:33 <dmwit> ania123: correct
12:49:37 <ania123> :(
12:49:37 * geekosaur wonders what is confusing about this
12:49:51 <ania123> so, how can I define
12:49:54 <ania123> wait
12:49:57 <ania123> sorry
12:49:58 <dmwit> geekosaur: I suspect it's just a language barrier. I would want to double-check, too, if I wasn't sure I understood the language.
12:50:27 <jmorris> dmwit do you have any ideas about how i can return a string
12:50:37 <Tuplanolla> Perhaps it would help to consider literals like `42` to be constructors.
12:50:37 <dmwit> ania123: You can write `fibonacci n = fibonacci (n-1) + fibonacci (n-2)`. Or you can add `{-# LANGUAGE NPlusKPatterns #-}` at the top of your file.
12:50:58 <ania123> fibonacci :: Int -> Int fibonacci 0 = 0 fibonacci 1 = 1 fibonacci n = fibonacci (n-2) + fibonacci (n - 1)
12:51:13 <dmwit> ania123: Yes, that's good.
12:51:17 <ania123> thx
12:51:18 <ania123> :)
12:51:52 <dmwit> jmorris: Is `encode` doing base64 encoding, or another kind?
12:52:02 <jmorris> yes base64
12:52:04 <Tuplanolla> You can write `fibonacci 0`, because `0` is a constructor for `Int`, but not `fibonacci (n + 1)`, because `(+)` is just a function.
12:52:53 <dmwit> jmorris: Okay. So what's coming out the other side is ASCII (and also latin-1). You can convert to `String` with `bytestring`'s latin-1 support. But you should not need to; why do you want a `String`?
12:53:02 * hackagebot legion-extra 0.1.0.5 - Extra non-essential utilities for building legion applications.  https://hackage.haskell.org/package/legion-extra-0.1.0.5 (taphu)
12:53:14 <jmorris> dmwit to use putStrLn
12:53:26 <jmorris> i tried databyte string putstrln but had a problem
12:53:30 <dmwit> jmorris: There is a `putStr` available from `Data.ByteString`; is that not enough?
12:53:41 <jmorris> I had a problem
12:53:54 <dmwit> We are not mind-readers. Tell us the details of your problem.
12:54:05 <jmorris> ok hold on
12:55:11 <jmorris> Couldn't match expected type ByteString with actual type f0 ByteString
12:55:17 <octarin> Hey.
12:55:39 <octarin> Do you think this code is efficient enough to generate prime numbers ? http://zerobin.org/?6c08ff6277924e0f#ZPnjm/RjuEuGMXdMQw8LPZDuX5seW251Jd48vtOsRP0=
12:55:44 <octarin> How can I improve it ?
12:56:32 <dmwit> jmorris: It's polite to include the exact code needed to reproduce your problem, as well as the complete error produced. Use a pastebin, because this content is usually longer than makes sense to paste into IRC.
12:56:35 <dmwit> ?lpaste
12:56:36 <lambdabot> Haskell pastebin: http://lpaste.net/
12:56:42 <kadoban> octarin: It depends what "efficient enough" means. Does it give the answers quickly enough for whatever you're using it for?
12:56:56 <jmorris> http://lpaste.net/319066
12:56:58 <kadoban> (Note: it's not particularly efficient, as far as prime generation algorithms go, if that's your question)
12:57:55 <kuribas> :t encode
12:57:56 <octarin> My question was more about the coding style.
12:57:57 <lambdabot> error: Variable not in scope: encode
12:58:25 <octarin> Is it "haskell-ish" ?
12:58:30 <kadoban> octarin: https://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf is one of my favorite papers, it's very readable and goes through several ways to generate prime numbers in haskell and their tradeoffs (mostly in terms of speed).
12:58:35 <kadoban> As for style ... let me look again.
12:58:51 <dmwit> octarin: My only complaint would be converting `Integer`s to `Double`. That's a lossy conversion, and especially in this case isn't needed.
12:58:53 <octarin> thanks for the paper
12:59:05 <dmwit> octarin: You can `takeWhile (\i -> i*i <= n)` instead.
12:59:09 <octarin> oh
12:59:17 <EvanR> prime numbers involving Double ? O_o
12:59:27 <octarin> EvanR: it was for using sqrt
12:59:37 <octarin> but dmwit answered this problem…
12:59:44 <kuribas> octarin: you can do the comparison without sqrt
12:59:48 <octarin> with an actually very simple
12:59:53 <octarin> and dumb solution
12:59:57 <EvanR> i see, but going through double for that probably was wrong
12:59:59 <octarin> I did’nt think of
13:00:05 <dmwit> octarin: Or you could use an `Integer` square root (e.g. from `arithmoi`). But of course the ultimate refactoring is to just use `primes` or `arithmoi` for the whole shebang in the first place. ;-)
13:00:26 <kadoban> octarin: Other than that, I might make a function 'divides' :: Integer -> Integer -> Bool which says if a `divides` b, but it's fairly understandable without that anyway.
13:00:27 <octarin> no, I think your proposition is adequate
13:01:05 <kuribas> :t (<$>)
13:01:07 <octarin> kadoban: yes, I thinked about that a bit but in the end I though this was readable enough
13:01:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:01:20 <octarin> using a lambda
13:01:44 <kuribas> jmorris: putStrLn doesn't take a monad as argument
13:01:52 <kuribas> jmorris: use >>=
13:02:10 <jmorris> how should i use >>=
13:02:29 <kuribas> jmorris: (encode <$> unhex s) >>= ByteString.putStrLn
13:03:16 <jmorris> oh thank you it worked
13:03:55 <kuribas> jmorris: that might crash though
13:04:02 <jmorris> oh why
13:04:30 <jmorris> is it because its deprecated?
13:04:36 <kuribas> jmorris: because you unhex will use IO fail, which means crash with error
13:06:02 <kuribas> Isn't monad fail deprecated?
13:08:19 <kuribas> jmorris: hex is from 2011
13:08:26 <kuribas> jmorris: you should use something newer
13:10:11 <kadoban> Old isn't necessarily bad. Some libraries just don't need more changes past a certain point.
13:11:21 <kuribas> kadoban: yes, but this library uses Monad fail for parser error.
13:11:48 <kuribas> Maybe or Either would be more sane
13:11:59 <kadoban> Quite possibly a good point
13:12:13 <kuribas> https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail
13:12:41 <Clint> @hackage fail
13:12:42 <lambdabot> http://hackage.haskell.org/package/fail
13:22:06 <EvanR> sometimes iw ant something like fail, but it doesnt take a string, and i cnat call it fail since its already taken
13:25:14 <kadoban> You can always just make things more vulgar, those usually aren't already reserved
13:26:06 <ania123> is 'add' higher order function?
13:26:31 <ania123> add :: Int → Int → Int
13:27:09 <lyxia> none of its arguments are functions 
13:27:45 <kuribas> interesting how easy it is to defined `asTypeOf`
13:27:46 <liste> talk about that: https://en.wikipedia.org/wiki/Talk:Higher-order_function#Curried_functions_higher_order
13:27:56 <kuribas> :t let asTypeOf :: a -> a -> a; asTypeOf a b = a in 1 `asTypeOf` (undefined :: Double)
13:27:57 <lambdabot> Double
13:28:04 * hackagebot juicy-gcode 0.1.0.1 - SVG to G-Code converter  https://hackage.haskell.org/package/juicy-gcode-0.1.0.1 (dlacko)
13:28:06 * hackagebot ntrip-client 0.1.0 - NTRIP client.  https://hackage.haskell.org/package/ntrip-client-0.1.0 (markfine)
13:28:41 <ania123> plus a  returns function
13:28:46 <ania123> so, it is high irder
13:28:48 <ania123> no?
13:28:59 <coleman> Is there a way to use 0 when accessing an out of bounds place in an array?
13:29:13 <warbo> anyone had trouble with QuickCheck's "once" not working (maybe due to semi-recent updates)? e.g. "quickCheck (once (return True :: Gen Bool))" does 100 tests
13:29:28 <kuribas> ania123: a higher order function takes functions as argument.
13:29:48 <ania123> kuribas: if a function returns function
13:29:55 <ania123> it is also higher order
13:29:56 <ania123> no?
13:30:12 <monochrom> coleman: depends on the library that provides the array. So which library is it so we can be concrete?
13:30:21 <coleman> monochrom: Data.Array
13:30:27 <EvanR> kuribas: its even easier in idris.. the : (t : Type) -> (a : t) -> t, the _ x = x
13:30:35 <monochrom> OK, this one you have to write your own if-then-else.
13:30:42 <Tuplanolla> Even if a function returning a function was higher-order, it would be not-higher-order up to isomorphism, ania123.
13:31:00 <Tuplanolla> Such a definition would be a little silly.
13:31:24 <monochrom> some other libraries provide an "Int -> Maybe a" and that's when you can easily pattern-match against Nothing and return your 0
13:31:39 <monochrom> but Data.Array lacks that.
13:31:52 <kuribas> In a way all haskell functions with two or more arguments are higher order.
13:31:58 <coleman> monochrom: what libs have it?
13:32:02 <kuribas> Due to currying
13:32:22 <ania123> I confuse now
13:32:45 <ania123> function with more than two arguments is higher order or not?
13:32:54 <monochrom> vector does. it has (!?) :: Vector a -> Int -> Maybe a
13:33:05 <kuribas> ania123: I guess so
13:33:14 <Tuplanolla> It depends on how you define it, ania123.
13:33:29 <exio4> ania123: it is high order in Haskell because of currying, which means multiple arguments are implemented as functions returning functions
13:33:31 <ania123> how haskell comunity defenes it?
13:33:40 <exio4> f = \x -> \y -> x+y*2
13:33:47 <exio4> f x y = x+y*2
13:34:01 <EvanR> add :: Int -> (Int -> Int)
13:34:07 <EvanR> returns a function
13:34:16 <ania123> ok
13:34:16 <monochrom> I don't define it. I simply don't make a big deal out of "higher-order".
13:34:37 <Bor0> monochrom, that's because you're used to it ;)
13:34:39 <coleman> monochrom: thanks m8
13:34:54 <monochrom> I have a function. Oh it's domain or codomain happens to be a function type too. Nothing to see here, move along.
13:35:48 <coleman> monochrom: oh I need 2d accesibility: ! (x,y)
13:35:54 <coleman> monochrom: should've mentioned
13:36:37 <monochrom> There are times, to be sure, when I speak to people outside functional programming. That's when I will mention "higher-order functions" because their languages disallow it. But still I won't define it precisely, I will only show examples.
13:37:11 <monochrom> But to you, when you are learning Haskell as opposed to getting an overview, there is no need. I use types.
13:37:13 <exio4> monochrom: definition by multiple examples is the PHP way to define things "precisely" :p
13:37:35 <johnw> exio4: TDD: Test Driven Definition
13:37:35 <Bor0> haha
13:38:00 <monochrom> You understand the type "(a -> b) -> ([a] -> [b])" and you will be infinitely better than writing an essay on higher-order functions.
13:38:04 * hackagebot mcmc-types 1.0.2 - Common types for sampling.  https://hackage.haskell.org/package/mcmc-types-1.0.2 (JaredTobin)
13:38:06 * hackagebot mighty-metropolis 1.0.3 - The Metropolis algorithm.  https://hackage.haskell.org/package/mighty-metropolis-1.0.3 (JaredTobin)
13:38:07 <dolio> It makes the difference between the Ackermann function being primitive recurisve or not, though. :P
13:38:33 <exio4> (sorry, I know PHP is offtopic, I just have to rant, my homework required it)
13:38:41 <kuribas> ania123: If you follow a course, go with the definition of the course.
13:38:46 <exio4> johnw: that's a good one, I'll steal it :P
13:39:26 <monochrom> And if you further understand the type "(a -> r) -> r" you will be in the top 1%.
13:40:25 <bollu> I'm trying to learn trufecta
13:40:34 <bollu> how do I even run the parser?
13:40:50 <bollu> monochrom: really? is that so "deep"?
13:41:06 <bollu> monochrom: not being snarky, genuinely curious
13:41:15 <monochrom> coleman: Data.Array is very convenient for 2D, yeah. But if you use the 1D vector library you can also code up your own 2D-to-1D wrapper.
13:41:31 <jle`> bollu: it's not very well documented
13:41:46 <jle`> i forked it intending to add some more documentation but i haven't gotten around to it heh
13:41:59 <bollu> jle`: :) so, how do I actually run the parser?
13:42:13 <coleman> monochrom: how do I do the if-else. Have an example?
13:42:18 <monochrom> I don't know about deep. But to a large extent there is no relation between "deep" and "only 1% grok it".
13:42:19 <EvanR> monochrom: when you get out of "just a function", and you want a continuous map with a space of continuous maps as the domain or codomain then it doesnt seem so trivial anymore
13:42:38 <grantwu> I don't really understand that type
13:42:44 <jle`> bollu: the runners are in here http://hackage.haskell.org/package/trifecta-1.6/docs/Text-Trifecta-Parser.html
13:42:44 <bollu> monochrom: fair :P
13:42:59 <dolio> EvanR: But all functions are continuous. :P
13:43:05 * hackagebot speedy-slice 0.1.4 - Speedy slice sampling.  https://hackage.haskell.org/package/speedy-slice-0.1.4 (JaredTobin)
13:43:05 <bollu> jle`: what exactly is a delta?
13:43:06 <EvanR> in some videos, they throw around "just a function from reals to Bool" and im like .... what
13:43:06 * hackagebot hasty-hamiltonian 1.1.4 - Speedy traversal through parameter space.  https://hackage.haskell.org/package/hasty-hamiltonian-1.1.4 (JaredTobin)
13:43:07 <bollu> dolio: ?
13:43:08 * hackagebot declarative 0.2.3 - DIY Markov Chains.  https://hackage.haskell.org/package/declarative-0.2.3 (JaredTobin)
13:43:15 <monochrom> Instead, I believe that the correct relation is between "you have to do it logically not feelingly (aka intuitively)" and "only 1% grok it"
13:43:23 <grantwu> It's a function that takes (a -> b) and yields a b.  How do I put an a into the (a -> b)?
13:43:30 <EvanR> dolio: for some value of
13:44:05 <grantwu> Lambdabot's djinn says that the function cannot be realized.
13:44:14 <jle`> bollu: as for the 'delta' you use, you have to find the answer in a closed issue on github
13:44:18 <jle`> bollu: https://github.com/ekmett/trifecta/issues/29
13:44:25 <jle`> grantwu: that's not your job, that's the function's job
13:44:43 <jle`> @djinn (Int -> r) -> r
13:44:43 <lambdabot> Error: Undefined type Int
13:44:53 <dolio> EvanR: Well, there aren't many of those. Just `const True` and `const False`. :)
13:45:15 <jle`> grantwu: you don't have to put an a into the (a -> b).  the function does
13:45:17 <jle`> or, it can
13:45:19 <grantwu> @djinn (Integer -> r) -> r
13:45:19 <lambdabot> Error: Undefined type Integer
13:45:24 <bollu> jle`: I don't really understand, what _is_ it though?
13:45:28 <EvanR> dolio: what a world
13:45:31 <grantwu> jle`: Which function?
13:45:45 <grantwu> I don't think you can really write a function of type (a -> b) -> b
13:45:46 <dolio> Seems like it's simpler to just have a boolean.
13:45:59 <grantwu> i guess you can put a bottom into the argument
13:46:02 <jle`> you don't have to give an a, you just have to give an ( a -> b)
13:46:10 <amx> apparently we are not in the top 1% :(
13:46:18 <grantwu> can you write an example of a function that has type (a -> b) -> b
13:46:21 <EvanR> you regularly are presented with discontinuous functions from reals to something
13:46:23 <jle`> grantwu: presumably the person meant forall r. (a -> r) -> r
13:46:31 <jle`> grantwu: for a specific 'a'
13:46:38 <grantwu> o
13:46:42 <jle`> so, (Int -> r) -> r, (Bool -> r) -> r, etc.
13:46:43 <grantwu> Well that changes things >.>
13:46:45 <monochrom> coleman: if inRange (bounds my_array) n then my_array ! n else 0
13:47:03 <coleman> monochrom: won't that slow it down significantly?
13:47:09 <monochrom> yes
13:47:12 <jle`> bollu: good question!
13:47:34 <monochrom> actually, not yes, just likely. I haven't checked.
13:47:53 <monochrom> however, Data.Array is famous for not being fast in other aspects either
13:48:05 <coleman> monochrom: okay i'll give it a shot
13:48:06 <coleman> thanks
13:48:24 <monochrom> But I think you should measure the speed before deciding whether it's slow or fast.
13:48:40 <monochrom> You never know whether you really need the speed.
13:49:28 <monochrom> jle`, sometimes it's just "Cont r a" so it's just "(a -> r) -> r) without forall.
13:49:55 <monochrom> In fact sometimes you want to pull some shift-reset trick so it is purposedly without forall.
13:50:24 <EvanR> do you call (Int -> r) -> r, (Bool -> r) -> r "CPS'd" or is that "church encoded"
13:50:49 <jle`> not quite church encoded
13:51:03 <monochrom> Also, every Halloween, I show you: pumpkin catmorphism http://www.vex.net/~trebla/photo/unorganized/pumpkin-catmorphism.jpg
13:51:18 <jle`> :3
13:51:33 <EvanR> kin-catmorphism.jpg
13:51:34 <kuribas> :t \f -> f undefined
13:51:36 <lambdabot> (t -> t1) -> t1
13:52:58 <EvanR> who thought selecto-text idiom + 1970s terminal was a good combination
13:53:39 <monochrom> my opinion is who thought The Year 2016 of Our Lord + 1970s terminal was a good combination.
13:54:04 <Tuplanolla> Did you mean: 1870s terminal?
13:54:09 <EvanR> computers generally converge toward stuck
13:54:28 <EvanR> the ecosystem of stuff just becomes clogged unable to progress
13:54:41 <monochrom> No, 1870s would be punch cards and Hollerinth stuff
13:58:49 <EvanR> clearly we need to wait until 2070 to get a new interface
14:02:10 <dsub> is there a simple way to rename a stack project? So that the .cabal-file get updated on every relevant field. Or do I simply edit everything manually?
14:03:04 <dsub> or with sed rather...
14:03:43 <dolio> EvanR: I think most that you're presented with are actually continuous functions to the Sierpinski space, and the presenter is confused.
14:05:36 <EvanR> i still dont really get sierpinski space
14:06:28 <grazie> I'm curious about the purpose of the array brackets in the`ch` helper function in `simpleEscapes` in this gist https://gist.github.com/1ccb24672403a08fad2f92794a916bd5
14:06:44 <grazie> how come the array brackets don't appear in the output to the function?
14:07:25 <glguy> grazie: The String type is an alias for [Char].
14:07:31 <glguy> > ['a','b','c']
14:07:33 <lambdabot>  "abc"
14:08:12 <kuribas> grazie: brackets denote List, not Array
14:08:23 <glguy> The Show instance for [a] uses showList from the Show instance for Char, which implements that special "" behavior
14:08:23 <grazie> @glguy so when I do ('\b',[\\b]), it automatically gets converted to ('\b',"\\b")
14:08:23 <lambdabot> Unknown command, try @list
14:08:52 <glguy> grazie: @ is for bot commands. There's no "" syntax that takes variables, which is why [] gets used here
14:08:54 <grazie> kuribas  so when I do ('\b',[\\b]), it automatically gets converted to ('\b',"\\b")
14:09:03 <grazie> glguy ok, thank you
14:09:36 <kuribas> :t \\b
14:09:37 <lambdabot> error: parse error on input ‘\\’
14:09:55 <kuribas> :t \b
14:09:56 <lambdabot> error:
14:09:57 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:10:06 <monochrom> I don't understand [\\b]
14:10:06 <kuribas> :t ('\b',[\\b])
14:10:08 <lambdabot> error:
14:10:08 <lambdabot>     A section must be enclosed in parentheses thus: (\\ b)
14:13:06 * hackagebot katip 0.3.1.0 - A structured logging framework.  https://hackage.haskell.org/package/katip-0.3.1.0 (MichaelXavier)
14:16:17 <jle`> grazie: i woudn't say that it gets converted
14:16:30 <ReinH> > '\\b'
14:16:31 <lambdabot>  <hint>:1:4: error:
14:16:32 <lambdabot>      lexical error in string/character literal at character 'b'
14:16:43 <ReinH> Er
14:16:46 <ReinH> > '\\'
14:16:48 <lambdabot>  '\\'
14:16:51 <ReinH> I' not sure where you're getting \\b from
14:16:53 <jle`> grazie: ['a'] *is* "a", they're the same thing
14:17:03 <ReinH> or [\\b]
14:17:06 <grazie> jle` thank you
14:17:25 <jle`> grazie: that's like saying that 1 gets converted to 1
14:17:33 <ReinH> > "abc" == ['a','b','c']
14:17:35 <lambdabot>  True
14:17:37 <jle`> there isn't any conversion, they're the same thing :)
14:17:57 <jle`> it's just that ['a','b','c'] is displayed as "abc" if you want to print it out
14:18:03 <ReinH> > ['a','b','c']
14:18:05 <lambdabot>  "abc"
14:18:08 <ReinH> > head "abc"
14:18:10 <lambdabot>  'a'
14:18:31 <ReinH> "" is sugar for constructing a list of characters, a.k.a. a string
14:19:14 <kuribas> Is it possible to make this work?  http://lpaste.net/319511
14:19:26 <kuribas> (constant class method)
14:20:22 <dmwit> monochrom: 1970s terminal, designed as it was for low-bandwidth receivers, forwards like a dream over low-bandwidth network connections.
14:20:25 <glguy> kuribas: You can either add a "proxy" argument for the type 'a', or you can use -XAllowAmbiguousTypes -XTypeApplications with GHC 8
14:21:25 <glguy> kuribas: the extra "Test a =>" on "count :: Test a => Int" isn't helping anything
14:21:32 <kuribas> glguy: right
14:24:22 <kuribas> glguy: how could I refine "count" to a specific instance?
14:24:43 <kuribas> (count :: Test TestData => Int) doesn't work
14:24:59 <jle`> if you're using a proxy type
14:25:15 <glguy> kuribas: You'll have to use TypeApplications syntax if you don't want to add a proxy argument
14:25:31 <jle`> you'd redefine count :: p a -> Int
14:25:40 <jle`> so the type of count would be count :: Test a => p a -> Int
14:25:56 <jle`> and so you could do count (Proxy :: Proxy TestData) to get 4
14:26:06 <jle`> that lets the typechecker be able to infer what instance you want
14:26:26 <jle`> if you don't want to add a proxy argument, you could leave it as count :: Test a => Int, and call it with 'count @TestData'
14:26:26 <kuribas> jle`: yeah, I understand the proxy way, but I wonder if it is possible without proxy.
14:26:27 <lpaste> glguy pasted “using type applications for kuribas” at http://lpaste.net/319552
14:26:56 <ReinH> Yes, it's possible using type applications in GHC 8. Otherwise, there's no way to specify which type you want to use count at.
14:27:07 <kuribas> glguy: that's great, thanks!
14:28:15 <xa0> haskell doesn't really have much rein in the embedded/realtime sector does it?
14:29:41 <kuribas> xa0: if space is constrained, haskell isn't that good, but for raspberry pi or so haskell is just fine.
14:30:06 <xa0> i'm thinking from an industry point of view here
14:30:13 <ongy> also hard realtime with a stop the world GC isn't really a thing
14:30:39 <jle`> haskell can be used a nice dsl to write embedded code though
14:30:43 <ReinH> It is an active area of research
14:30:51 <xa0> i suppose what i'm thinking of is less realtime and more speed is absolutely essential here"
14:31:03 <ReinH> Haskell can be good at soft realtime
14:31:14 <jle`> if speed is absolutely essential, then haskell is pretty fast
14:31:27 <xa0> hmm
14:31:36 <jle`> if space isn't a big constraint
14:31:49 <xa0> but there's no real incentivising reason to use it over traditional languages
14:31:59 <ReinH> @google ivorylang
14:31:59 <xa0> am i wrong?
14:32:00 <jle`> actually, there are a lot
14:32:00 <lambdabot> http://ivorylang.org/
14:32:01 <lambdabot> Title: Ivory - index
14:32:05 <jle`> type safety
14:32:08 <jle`> maintainability
14:32:21 <jle`> composability
14:32:21 <ReinH> Basically the same reasons as everywhere else
14:32:31 <jle`> pretty much the same reasons why you'd use haskell over anything else anywhere else, yeah
14:32:38 <ReinH> But the downsides are more significant in embedded or realtime domains
14:32:56 <xa0> well, i know there are nice reasona like that, but i mean reasons that can depose the fact that you have very little hiring power with haskell, and training expenses become an issue
14:32:59 <ReinH> since ability to reason about timing and memory usage are even more important than usual
14:33:17 <ReinH> What are you basing that claim on?
14:33:39 <xa0> the fact that next-to-nobody in industry currently uses haskell :p
14:33:49 <jle`> what industry are you talking about? :p
14:33:59 <ReinH> Ok, so a false premise.
14:34:04 <jle`> does facebook, microsoft, twitter, big i-banking firms count?
14:34:04 <ReinH> Is Facebook "nobody"?
14:34:27 <ReinH> Also, if demand is low, it's ok if supply is also low
14:34:35 <xa0> well, they're high profile and a kinda special case, slight appeal to authority
14:34:45 <ReinH> Appeal to authority is valid
14:34:49 <ReinH> In this case
14:34:53 <ReinH> That's literally what you asked for
14:35:02 <xa0> i mean, a traditional software company isn't going to consider haskell for anything they do, is my point
14:35:13 <ReinH> Ok, let's stipulate your point
14:35:18 <ReinH> They also won't be hiring haskell developers
14:35:19 <jle`> "next to nobody in industry uses haskell" => "here is a list of important companies in industry using haskell" => "that doesn't count"
14:35:34 <ReinH> Again: if demand is low, supply can also be low.
14:36:02 <ph88> is it possible to have a do block in a do block ?
14:36:03 <ReinH> If there are fewer Haskell programmers, but there are also fewer Haskell job openings, the likelihood of finding a Haskell developer for a particular job opening might not be lower.
14:36:07 <ReinH> ph88: yes
14:36:09 <ph88> foo <- do
14:36:17 <jle`> ph88: yes, do blocks are just normal expressions
14:36:21 <Tuplanolla> > do do do Nothing
14:36:23 <jle`> ph88: so you can use them where you'd use any other expression
14:36:23 <lambdabot>  Nothing
14:36:24 <xa0> so, you believe that if i was to suggest to my company tomorrow that they should use haskell for project X Y Z, they would do it?
14:36:36 <ReinH> xa0: When did I ever claim that?
14:36:39 <jle`> ph88: you can put a do block anywhere where haskell expects an expression
14:36:46 <ReinH> xa0: Why don't you restrict yourself to things I plausibly could have said.
14:36:49 <ph88> ok that's good to know
14:37:04 <Tuplanolla> You can literally do anything, ph88.
14:37:04 <xa0> i'm trying to understand
14:37:11 <jle`> ph88: also, the first response to your question might be: "what happens when you try?"
14:37:15 <ReinH> You claimed that it's harder to hire Haskell developers
14:37:18 <ReinH> I am responding to that claim
14:37:30 <ReinH> By challenging both its premise and its conclusion.
14:37:38 <jle`> scientific method goes a long way :)
14:37:52 <kuribas> xa0: there are many reasons not to use haskell, and there are many reason to use haskell.
14:37:53 <xa0> oh i didn't actually claim it's harder, my point "hiring expsnese" was literally that you'd have to hire at all.
14:38:03 <xa0> because most software developers in industry, don't know haskell.
14:38:15 <ReinH> Yes, and most jobs in the industry are not Haskell
14:38:17 <ReinH> It balances out.
14:38:20 <xa0> exactly
14:38:24 <ReinH> I haven't had trouble hiring a Haskell developer.
14:38:48 <kuribas> xa0: if your company has a large legacy in another language, haskell may not be the best choice, though it could be useful for a secondary project.
14:38:53 <xa0> i'm not saying you would, but i'm saying industry isn't very haskell oriented at the moment, and i'm trying to figure how to play that
14:39:13 <kadoban> "how to play that" what does that mean?
14:39:28 <xa0> kuribas: that's exactly my plan, but i don't know how i could suggest it to them in a way that it'd seem a viable and good idea
14:39:32 <xa0> kadoban: ^
14:39:49 <ReinH> That depends on your company's policy/culture.
14:39:53 <dolio> Seems like you'd know your boss better than we would.
14:39:55 <ph88> jle`, i have the problem now that IO was expected but now i have EC
14:40:02 <jle`> EC ?
14:40:06 <kuribas> xa0: that might be hard if they aren't familiar with functional programming.
14:40:16 <ReinH> ph88: Well, the expression does have to have the right type.
14:40:17 <ph88> jle`, https://hackage.haskell.org/package/Chart-1.8/docs/Graphics-Rendering-Chart-State.html#t:EC
14:40:18 <xa0> very true
14:40:28 <jle`> ph88: yeah, remember that do blocks are just expressions
14:40:33 <jle`> so they have types
14:40:47 <xa0> dolio: this is a hail mary at this point tbh, cause i can't think of a nice way myself
14:40:47 <ph88> then what exactly was i doing in:    runAlgo algo1 >>= \stats -> toFile C.def (filename) $ do
14:41:13 <DexterLB> hello.. I need a function which returns a random minimal value from a list, by a key function (e.g. for the list [4, 2, 3] and the key function (`div` 2) it should return either 2 or 3 at random)
14:41:21 <jle`> if your thing is EC, then it's not IO.  do you just want a 'let' statement instead of a <- ?
14:41:24 <DexterLB> here's my implementation: http://lpaste.net/317554
14:41:49 <xa0> realistically, they gain "not much" from using haskell with anything, and they lose all office experience and traction, while probably gaining a bit of technical debt too. not to mention build tools aren't compatible and will probably never be
14:41:55 <ph88> jle`, thx let statement fixed it
14:42:08 <DexterLB> currently it's very suboptimal (not to mention the double call to f), and it gets called a lot of times per second, and is the main thing which slows down my program
14:42:15 <DexterLB> does anyone know how to optimise it?
14:42:27 <jle`> ph88: np! you only use <- if you want to bind actions in the monad of the do block you're in
14:42:31 <ReinH> DexterLB: for starters,
14:42:37 <jle`> ph88: you can use 'let' to specify declarations
14:42:52 <ReinH> :t foldl' (minBy f) (error "empty list")
14:42:54 <lambdabot> error:
14:42:54 <lambdabot>     Variable not in scope: minBy :: t0 -> b -> a -> b
14:42:57 * xa0 gives up
14:42:59 <jle`> for example, if you wanted to define x = 10 in an IO do block, you'd use let x = 10, not x <- 10
14:43:04 <ReinH> er
14:43:07 * hackagebot ntrip-client 0.1.1 - NTRIP client.  https://hackage.haskell.org/package/ntrip-client-0.1.1 (markfine)
14:43:21 <ReinH> :t \f -> foldl1' (minBy f)
14:43:23 <lambdabot> error:
14:43:23 <jle`> x <- foo is only for sequencing the IO action foo :: IO something, and namign the result x
14:43:23 <lambdabot>     Variable not in scope: minBy :: t -> a -> a -> a
14:43:26 <ReinH> Ugh sorry
14:43:34 <ReinH> @src minimum
14:43:34 <lambdabot> minimum [] = undefined
14:43:34 <lambdabot> minimum xs = foldl1 min xs
14:43:49 <ReinH> Oh right
14:43:52 <ReinH> :t minimumBy
14:43:53 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
14:43:54 <ReinH> Already exists
14:44:12 <ReinH> Sorry for lambdabot spam
14:44:18 <DexterLB> ReinH: yes, I know, but it returns the first occurance of a minimal element
14:44:31 <kuribas> xa0: you cannot expect your company to start rewriting their software in haskell.
14:44:35 <DexterLB> ReinH: I need a random minimal element
14:44:53 <xa0> kuribas: i'm not expecting them to rewrite anything, there's more than enough technical debt as it is
14:44:56 <ReinH> :t \f -> head . group . sortBy f
14:44:58 <lambdabot> Eq a => (a -> a -> Ordering) -> [a] -> [a]
14:45:07 <xa0> but i'd like to see if i could get them to try and use haskell for a small project somewhere
14:45:12 <ReinH> Will give you the equivalence class of minimum elements by f
14:45:15 <ReinH> now take a random sample
14:45:38 <DexterLB> ReinH: nice! that is very elegant!
14:45:47 <ReinH> (and handle the empty list)
14:45:54 <kuribas> xa0: do you have the expertise?
14:46:09 <kuribas> or your colleges?
14:46:11 <ReinH> er
14:46:12 <Tuplanolla> Why does `minimum` use `foldl1` there?
14:46:17 <xa0> to run the project on my own, or to use haskell?
14:46:22 <kuribas> xa0: to use haskell
14:46:25 <ReinH> DexterLB: Actually, I think I ean \f -> head . groupBy f . sortBy (comparing f)
14:46:25 <xa0> because former, probably not, latter, sure
14:46:40 <ph88> could this use some more refactoring ?  https://paste.fedoraproject.org/466985/79503661/
14:46:44 <EvanR> Tuplanolla: its expecting a non empty list
14:46:53 <ReinH> This could be done more efficiently with a Schwartzian transform
14:47:07 <Tuplanolla> Why not `foldr` or `foldl1'`?
14:47:16 <DexterLB> ReinH: hehe, I just implemented "comparing" using a lambda. I should start googling more.
14:47:22 <ReinH> Tuplanolla: That might not be the actual source
14:47:29 <Tuplanolla> Deceitful!
14:47:59 <EvanR> i see your schwartzian is as big as mine!
14:48:04 <ReinH> DexterLB: Schwartzian transform version: \f -> map fst . head . groupBy snd . sortBy snd . map (id &&& f)
14:48:07 * hackagebot cold-widow 0.1.2 - File transfer via QR Codes.  https://hackage.haskell.org/package/cold-widow-0.1.2 (mihaigiurgeanu)
14:48:21 <ReinH> This might be more or less efficient depending on the cost of f
14:48:32 <DexterLB> ReinH: f is quite costly
14:48:43 <kuribas> xa0: I would propose it, if you can explain clearly the advantages.
14:48:45 <ReinH> (&&& is an annoying way to spell fanout from Arrow)
14:49:02 <johnw> why is it annoying?
14:49:23 <ReinH> johnw: I find the arrow combinators annoying
14:49:38 <xa0> kuribas: fair enough, perhaps. i'll have to find a smalltime project where it might be applicable first
14:49:43 <ReinH> in general I find the Arrow interface hard to remember and hard to work with
14:49:51 <dolio> Shoudl clearly be <id,f>
14:49:53 <ReinH> is it &&& or ***?
14:49:56 * ReinH elaborate shrug
14:50:08 <ReinH> dolio: I'd buy that
14:50:15 <kuribas> xa0: they could worry that if you leave, nobody can work on the project.
14:50:30 <dolio> I don't know, that syntax isn't amazing.
14:50:31 <xa0> yeah, these are the issues
14:50:48 <ReinH> dolio: Maybe we need apple brackets?
14:50:53 <EvanR> companies regularly rewrite everything if dude leaves
14:50:54 <ReinH> A full assortment of fruit-related brackets?
14:50:58 <EvanR> not new
14:51:13 <ReinH> A fruit basket of brackets, if you will
14:51:26 <ReinH> dolio: Actually I wish Haskell had programmable brackets.
14:51:52 <ReinH> (Aside from [| |])
14:52:20 <EvanR> <_,_> 
14:52:33 <Tuplanolla> How about optional balancing, Forth style?
14:52:54 <ReinH> Then, with a little extra work, we could have owl homsets! <-,->
14:53:17 <EvanR> general mixfix punctuation would be pretty cool
14:53:25 <ReinH> Sorry, I mean (-,-)
14:53:32 <kuribas> xa0: https://www.youtube.com/watch?v=_K6UAq4hjAs
14:53:34 <johnw> I predict that mixfix would be cool for authors of Haskell programs
14:54:10 <kuribas> xa0: wait that isn't haskell ...
14:54:14 <ReinH> I predict that mixfix would enable lens to troll us to new and unprecedented heights
14:54:23 <Athas> Is there any experience with long-term use of mixfix?
14:54:29 <kuribas> xa0: I remember a great video, but I can't find it...
14:54:30 <xa0> haha
14:54:31 <EvanR> troll me baby one more time
14:54:32 <Athas> I mean, how it affects maintainability.
14:54:38 <xa0> no worries
14:55:09 <EvanR> Athas: it seems no worse than haskells "omg so many operators" problem
14:55:26 <EvanR> only better because youre not limited to using the same 10 symbols in random order, i guess im also thinking of using unicode too
14:55:28 <johnw> but at least with Haskell, you can identify the operator :)
14:55:30 <dolio> The mixfix I've used isn't really nicer than Haskell.
14:55:44 <dolio> Since it loses some stuff that Haskell has.
14:55:55 <EvanR> the =[ ]= thing in agda really helps, i think
14:55:55 <dolio> Nicer in some ways, inferior in others.
14:57:01 <nshepperd> all i want is banana brackets
14:57:17 <ph88> this is what ghci reports:   (13.93 secs, 6,060,462,672 bytes)    how can i find out why it uses so much memory ?
14:57:19 <dolio> I guess some of what is in Agda can't be blamed on mixfix.
14:57:19 <ReinH> nshepperd: Would you accept as substitute banana bread?
14:57:29 <johnw> nshepperd: program formatters are certainly allowed
14:57:38 <ReinH> nshepperd: Argument #1: banana bread is delicious
14:57:39 <dolio> Like, (x , y) vs. (x, y).
14:57:41 <nshepperd> ReinH: always!
14:57:58 <nshepperd> -XBananaBread
14:58:04 <dolio> vs. (x,y).
14:59:10 <maerwald> are there still people here who like simplicity?
14:59:31 <ph88> https://imgur.com/a/KOYA2 algo2 wins !
15:01:59 <maerwald> kuribas: awkward haskell code :o
15:02:11 <Tuplanolla> Pfft, unlabeled axes and no error bars, ph88...
15:02:15 <kuribas> xa0: not the video, but this one is nice: https://www.youtube.com/watch?v=moAfgDFVLUs
15:02:24 <kuribas> maerwald: yeah
15:02:30 <maerwald> he's using IO a lot and talking about type safety :o
15:02:57 <xa0> ah, ty
15:04:05 <daey> could it be that the regex getAllTextMatches implementation in Text.Regex.Posix is very slow?
15:05:24 <kuribas> maerwald: right, still better than javascript though
15:07:27 <maerwald> maintenance burden is not that different, because you can't properly reason about heavy IO code either
15:07:39 <kuribas> yeah true
15:07:52 <maerwald> it might be less annoying to write though
15:08:59 <exio4> writing IO heavy code in Haskell tends to require you to abstract things differently though 
15:09:32 <maerwald> what does that mean?
15:10:03 <exio4> maerwald: you have a type system that can work with you - and most libraries will tend to use it, even if "IO heavy" (up to some extent)
15:10:44 <exio4> maerwald: in one side, you have things like <db>-simple's "Query" datatype, which makes writing sql injectable code a pain, and writing safe code easy (which is the opposite of most languages)
15:11:15 <exio4> maerwald: on the other side, you could have phantom types keeping "things that shouldn't be mixed discriminated" or so
15:11:25 <DexterLB> I have the following simple function, which is called pretty often: http://lpaste.net/319761
15:11:40 <DexterLB> profiling says that it is responsible for a huge amount of the allocs in my code
15:11:44 <exio4> maerwald: while still being IO-heavy code, the type system can help you write some trivially checkeable invariants there
15:11:48 <DexterLB> what causes an alloc?
15:12:02 <EvanR> phantom types changed my life
15:12:10 <exio4> DexterLB: the thing is, it might be called too many times :)
15:12:18 <exio4> DexterLB: also, you're solving the eight queens problem, right?
15:12:37 <maerwald> exio4: I don't see how that "tends to require you to abstract things differently", which is what I was asking, not about what the haskell type system can do
15:12:37 <DexterLB> exio4: "eight" would be an understatement, but yeah :D
15:13:05 <maerwald> in the given example, things are basically structured the same way
15:13:08 <c0dehero> the only thing you have to worry about with IO is to only do IO stuff in the IO monad and use functions for data processing, right? You don't really have a choice about making an application "IO heavy." Either it needs IO or it doesn't
15:13:22 <maerwald> it does not require you to structure it differently
15:13:27 <exio4> maerwald: you will end up using libraries implemented using those techniques, I didn't check the example
15:13:27 <maerwald> although you can
15:13:45 <EvanR> c0dehero: its possible to add more IO to anything
15:13:48 <exio4> maerwald: (pipes/conduit, lens, etc)
15:14:01 <maerwald> you don't need to use any of those
15:14:05 <maerwald> and you are rarely required
15:14:22 <exio4> maerwald: well, if you connect to a database, I don't see people rewriting the bindigns
15:14:25 <exio4> bindings
15:14:39 <c0dehero> exio4: well, yes. but a text editor has to be IO heavy for example
15:14:45 <c0dehero> * EvanR 
15:14:53 <EvanR> i dont know about that
15:14:54 <exio4> DexterLB: I basically solved it changing the algorithm :p
15:15:09 <EvanR> a text editor certainly has an IO layer for interaction
15:15:10 <maerwald> exio4: I don't know, you seem to make some weird assumptions here about what libraries people will use or have to use
15:15:11 <exio4> c0dehero: and the IO heavy part is mostly renderization, the state changes might be pure functions
15:15:23 <maerwald> while this was about general IO code
15:15:38 <kuribas> c0dehero: I'd use something like reactive-banana for event processing.
15:15:40 <exio4> you can use pretty much everything as String
15:15:52 <DexterLB> exio4: yeah, I tried implementing a genetic algorithm and it is very fast.. but my task is specifically to use the minConflicts algorithm
15:15:55 <exio4> with acme-php and stuff
15:16:07 <exio4> DexterLB: ah, well, are you unboxing the integers?
15:16:11 <ReinH> Everything has an IO layer for interaction.
15:16:17 <kuribas> c0dehero: the callbacks will be IO, but the logic will be mostly functional.
15:16:20 <c0dehero> EvanR: yeah, that's what i meant about just doing IO stuff in the IO monad. if you do everything else with pure functions, you should be fine
15:16:28 <DexterLB> exio4: what is "unboxing"?
15:16:49 <EvanR> c0dehero: but theres libraries which directly or not are entirely permeated with IO
15:17:01 <exio4> DexterLB: well, adding an UNPACK pragma and making things as strict as possible
15:17:01 <c0dehero> kuribas: sounds cool :) (but i guess it uses arrows, which i don't understand yet, lol)
15:17:03 <EvanR> any sort of MonadIO-able transformer based lib
15:17:18 <kuribas> c0dehero: no, reactive-banana is monadic...
15:17:43 <exio4> https://downloads.haskell.org/~ghc/7.8.2/docs/html/users_guide/pragmas.html
15:17:54 <exio4> well, the newest documentation would be better, but it's the same there
15:18:02 <c0dehero> kuribas: oh, cool. most the reactive gui libs seem to use arrows
15:18:15 <EvanR> c0dehero: and there are C libraries you want to use which have to have something like IO, even if its not even doing IO, for it to be at all manageable
15:18:28 <kuribas> c0dehero: it's old and well maintained.
15:18:31 <maerwald> and there are plenty examples of IO heavy code where you even can't do any useful abstraction with pipes/conduits, lens etc
15:18:42 <c0dehero> EvanR: oh, yeah C libs can cause problem
15:19:18 <monochrom> Can I sum it all up with a simple "it depends"?
15:20:15 <EvanR> i just reviewed the diagram for shared memory multiprocessing, and it has a network connecting cpus and memory... and a big centralized choke point called "I/O"... and im like, man in haskell so much IO doesnt even go there
15:20:33 <kuribas> c0dehero: you encapsulate the state in a Behaviour, and you can see which events will change the state right away, rather than having any function possibly changing the state.
15:20:36 <maerwald> monochrom: exactly why the word "required" is not appropriate here
15:23:57 <EvanR> its interesting to see how thin the IO-layer-that-every-program-has can go
15:25:22 <onintza> https://paste.debian.net/891219/
15:25:31 <onintza> What am I missing?
15:26:11 <EvanR> i guess the most extreme is a single function which you can ask to be evaluated at points
15:26:54 <glguy> onintza: An error message on your paste?
15:26:58 <Tuplanolla> You're feeding two things into `g`, onintza.
15:27:41 <onintza> Tuplanolla: right, but `g` is a two argument function
15:28:04 <EvanR> g :: a -> Fun x b
15:28:06 <monochrom> More subtle than that. Write down the type of g.
15:28:33 <monochrom> So after "g (f x)" you have to unF before you can give the 2nd parameter
15:28:50 <onintza> I would say that `>>=` for `Function` is of type `(a -> s) -> (s -> a -> t) -> (a -> t)`
15:29:13 <onintza> Oh, right!!
15:29:26 <onintza> I was unFunning but not at the right place
15:29:41 <EvanR> Fun a b is "semantically" a function a -> b, but ... only almost
15:29:58 <onintza> Why only almost?
15:30:03 <EvanR> the newtype
15:30:10 <onintza> Er, yes
15:30:50 <onintza> Thank y'all!
15:31:32 <monochrom> you probably should be aware of "nominal typing" vs "structural typing"
15:32:08 <monochrom> because nominal type is where you just look at two different names and decide "they are distinct". You don't even look at the content. and newtype does this.
15:33:00 <monochrom> structural typing is when you get to say "they have the same content, why do you call them different?"
15:34:54 <onintza> so with newtype i make them diferent nominal types, with type i don't and they match as long as the structure matches, and with data i create a different structure?
15:35:21 <monochrom> yes. "data" also causes nominal typing
15:35:55 <onintza> oh, true
15:36:01 <monochrom> "data X = MkX Int" and "data Y = MkY Int" are treated as different, despite identical content.
15:36:23 <monochrom> use unsafeCoerce to break the nominal barrier :)
15:36:40 <onintza> I wouldn't want to
15:36:50 <monochrom> yeah, just kidding
15:37:14 <EvanR> it seems like, nominal and structural are red herrings. you could ask for any type that satisfies a set of laws
15:37:30 <EvanR> then it doesnt matter how its implemented or what its called
15:37:44 <EvanR> up to performance differences
15:39:41 <monochrom> That is just going to be structural typing on steroid. As opposed to eliminating the boundary between nominal and structure.
15:40:07 <monochrom> Instead of eliminating the boundary, that idea draws the boundary longer
15:40:15 <onintza> On an unrelated question, where do the names monoid and monad come from?
15:40:18 <EvanR> structural on the laws but not the structure of the particular types
15:41:16 <EvanR> for any type that could satisfy the laws, you still have to say how, and there might be more than one way
15:41:59 <EvanR> so theres no way it could be checked against the types structure in general
15:42:13 <Xnuk> Oh sry
15:45:37 <EvanR> "The term "groupoid" in the sense of a category with invertible arrows was already well-established. So, the use of "monoid" to mean a category of arrows on a single object seems quite natural."
15:45:44 <EvanR> http://math.stackexchange.com/questions/156952/why-the-terminology-monoid
15:45:52 <EvanR> (in 1954)
15:48:01 <EvanR> the relationship between monoids, groupoids, and semigroupoids keeps waffling in my head
15:48:30 <EvanR> jargon history-wise
15:51:54 <EvanR> the monad terminology i think is well documented
16:03:10 * hackagebot sbp 1.2.5 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-1.2.5 (ljbade)
16:03:36 <imPure> Hi. Trying to write a function with the signature ∷ ∀ α β. α → Maybe β, with the functionality that if α ≡ β then it return Just x, and if not it returns Nothing. I'm using Haskell 8 and have TypeInType and all other DT language extensions on, but everything I try ends up requriing a constraint be specified everywhere it's used.
16:05:40 <imPure> For example, class Mayhaps α β where mayhaps ∷ α → Maybe β..., instance α α where..., instance α β where..., when using {-# Overlaps #-} on the more specialized instance... it works, but then the function signature Mayhaps α β has to be included on every function that uses the function mayhaps
16:06:13 <imPure> However, if there is no specialized version of Mayhaps no constraint is needed.
16:07:25 <imPure> b
16:12:59 <c_wraith> imPure, you want value level computations to depend on types. the only mechanism haskell provides for that is classes. 
16:13:10 * hackagebot git-annex 6.20161031 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20161031 (JoeyHess)
16:13:29 <imPure> c_wraith: Is there a tutorial / write-up?
16:14:56 <c_wraith> it sounds like you already know how to do it, because that's exactly what you described 
16:15:58 <imPure> c_wraith: Problem is, every transitivie use of mayhaps requires a proof that the function is defined.
16:16:09 <imPure> c_wraith: But the function should be defined for all types...
16:16:30 <imPure> c_wraith: So no proof should be neccessary.
16:16:42 <c_wraith> imPure, just because an instance is defined doesn't mean you get to leave out saying that you depend on it. 
16:17:18 <imPure> c_wraith: But, I know (yet can't prove, apparently) that it's always defined.
16:17:33 <c_wraith> I mean, recent versions of GHC have automatic Typeable instances for all types. but you still need to declare that you're using them. it'd be chaos if you didn't have to. 
16:18:09 <c_wraith> might as well have C casts in the language. 
16:18:49 <imPure> c_wraith: Any time a class has an instance with no constraints, even if there are specializations it's the case that there is an instance for everything.
16:19:30 <c_wraith> imPure, you're missing the point. it's not about what's possible, it's about how much it would break parametricity
16:20:42 <c_wraith> imPure, right now, if a function has a type variable with no constraints on it, you know the behavior of the function can't depend on the specific type. 
16:21:14 <imPure> c_wraith: I see. So, working as intended.
16:21:20 <c_wraith> imPure, adjusting the language as you suggest would remove that property, and weaken a lot of type safety 
16:23:23 <c_wraith> imPure, indeed. changing that would make some things more convenient, but it would be seen as a loss overall by a lot of people 
16:23:43 <imPure> So the mayhaps function would inherently violate parametricity, so it'll never be possible...
16:24:13 <imPure> The obnoxious part about this is the proof has to be threaded throughout the entire program.
16:24:31 <imPure> So every function has to know about this.
16:26:00 <c_wraith> it's possible that it's not that bad, depending on whether you can higher-order utilities to separate pieces. 
16:26:09 <c_wraith> can *write*.. 
16:26:30 <imPure> c_wrait: What do you mean?
16:27:27 <imPure> c_wraith: Hmmm. According to Wikipedia seq breaks parametricity.
16:27:28 <c_wraith> as a dumb example.. map can use functions that require constraints,  even though it had no such constraints itself. 
16:28:11 <c_wraith> seq does, but in a very limited manner compared to grabbing instances automatically. 
16:29:33 <imPure> c_wraith: The map example is interesting, but it's an example of still having to thread the constraints through the whole program.
16:30:38 <c_wraith> well, my point was that you might be able to write things such that the constraint plumbing is minimal. 
16:31:40 <imPure> c_wraith: The use case is that a function, somewhere, will want to do this... That function will be called by other functions I don't want to constrain.
16:31:46 <imPure> Nothing gets passed in.
16:32:20 <imPure> My work-around effectively does this, but it's already driving me nuts - the need to provide a constraint for this will be very non-intutive to users.
16:32:54 <imPure> c_wraith: But hey, at least I know I'm not crazy now for being unable to do this :)
16:35:57 <EvanR> imPure: if there was some magic happening (that i needed to understand or know about) and there is no constraint or indication of whats going on the type sig, I would be confused
16:36:10 <EvanR> just based on haskell norms
16:36:39 <EvanR> if i dont need to know about it, then we can talk 
16:37:49 <slack1256> I need help with a hoogle query, https://www.haskell.org/hoogle/?hoogle=%3A%3A+Vector+a+-%3E+CArray+a+a+%2Bhmatrix+%2Bfft 
16:38:04 <slack1256> why does (Vector a) matches Flag on that example?
16:38:32 <imPure> EvanR: It's more that the entire point of Mayhaps is that when the types don't match I get Nothing, otherwise I get Just.
16:39:17 <EvanR> theres a thing for that
16:39:26 <imPure> EvanR: o.O Go on.
16:39:32 <EvanR> youre not going to like it
16:39:40 <imPure> EvanR: O.o
16:40:01 <EvanR> testEquality :: TestEquality f => f a -> f b -> Maybe (a :~: b)
16:40:18 <EvanR> if a = b, then you get Just Refl, otherwise Nothing
16:40:51 <EvanR> the Just Refl can be used to satisfy the type checker when youre doing shenanigans
16:41:23 <imPure> EvanR: What about testEquality ∷ a → b → Maybe (a :~: b)?
16:42:09 <imPure> What does a :~: b mean here?
16:42:11 <EvanR> nope
16:42:21 <EvanR> you dont have this kind of support for arbitrary a and b at runtime
16:42:42 <EvanR> a :~: b is a data type for evidence that a = b
16:42:55 <EvanR> the only ctor is Refl :: a :~: a
16:43:25 <imPure> EvanR: You're right. Don't like it. Not one bit.
16:43:28 <EvanR> TestEquality is for type (wrappers) that support checking for this at runtime
16:43:37 <EvanR> which makes sense sometimes
16:43:58 <EvanR> but not all the time
16:44:39 <EvanR> remember types dont exist at runtime
16:44:42 <imPure> EvanR: It's fine, I have an alternative way to do what I want to do. It's messier internally, but doesn't pollute the user side.
16:44:50 <imPure> EvanR: This is all static.
16:45:08 <imPure> EvanR: It's more parametricity like c_wraith noted.
16:45:34 <EvanR> well a -> Maybe b seems like a runtime thing to me
16:45:41 <imPure> That is, the types will be determined at compile time... just not at library authoriship time.
16:46:02 <EvanR> with more context maybe theres a better way to do what you want
16:46:08 <EvanR> but i wasnt following the whole time
16:47:19 <imPure> EvanR: Basically, I want to collect all the type-matching elements from an HList.
16:47:27 <EvanR> uh huh
16:47:33 <madhatter__> hi 
16:47:39 <EvanR> matching what?
16:48:03 <imPure> So, HList of Bool, Integer, Bool, mayhaps ∷ HList... → [Integer] should return a list with 1 element
16:48:34 <imPure> EvanR: Was using the mayhaps function to go from HList... → [Maybe α], and from there to [α]
16:49:28 <imPure> Having to pass along a proof / constraint with the HList is too annoying.
16:49:42 <EvanR> as c_wraith said the only way to make something like this is with type classes
16:49:52 <EvanR> which requires you to put constraints
16:50:07 <EvanR> you might not want an HList basically
16:50:26 <EvanR> or you might not want haskell ;)
16:51:02 <imPure> EvanR: My workaround is to wrap the HList elements with a tuple, that is, (α, [α]), then each time an element is added include it.
16:51:12 <imPure> Err, include the previous element.
16:51:16 <imPure> That'll work for my case.
16:51:27 * EvanR scratches head
16:51:28 <EvanR> ok
16:52:01 <EvanR> theres something similar i was working on. imagine you had a hetero set of "whatever"s
16:52:19 <imPure> EvanR: Well, it was Haskell or Python. Pretty happy with the choise, even despite this :)
16:52:22 <EvanR> and you have an interface "is Integer" which means, whatever satisfies this can be viewed as an integer
16:52:39 <EvanR> and only some of the "whatevers" satisfy it, however they choose to do it
16:53:00 <EvanR> now youd like to be able to say "give me all the whatevers that satisfy the interface" "and perhaps also give me the integer"
16:53:09 <EvanR> makes sense
16:53:17 <imPure> EvanR: Yea, I tried to do that too... didn't get too far
16:53:36 <imPure> Best idea I had was store a key/value tuple, and on the whatevers, have a class that give you the key.
16:53:59 <imPure> Then when inserting into the HList you add the key.
16:54:00 <EvanR> you can implement this in so many words, but i eventually felt that the programming side of using it wouldnt turn out nice enough to warrant it
16:54:43 <EvanR> well you want whatevers to support more than one kind of interface potentially
16:54:53 <EvanR> then you can combine the queries
16:55:25 <EvanR> in any case, the interface to this thing would not involve type classes
16:55:30 <imPure> Yea, the idea was the class that gave the key would also give the interface.
16:55:32 <EvanR> which i try to avoid
17:01:19 <EvanR> imPure: no HList, it would be Selection (no parameters). Selector a can be applied to a Selection to either get a new (smaller) Selection or a [a]
17:01:46 <EvanR> no HList, no type classes
17:02:52 <EvanR> Selector a can be mapped, combined with Selector (a -> b), Monoid a => Selector a's, etc
17:03:17 <EvanR> Monoid a => Monoid (Selector a)
17:04:20 <EvanR> you can never see the whatevers true form
17:13:12 * hackagebot sbp 1.2.6 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-1.2.6 (jgross)
17:20:37 <Axman6> cocreature: Hey, thanks for the tip re pipes producers and hoist list. I'll see how that goes
17:21:46 * hackagebot git-annex 6.20161031 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20161031 (JoeyHess)
17:21:46 * hackagebot sbp 1.2.6 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-1.2.6 (jgross)
17:24:28 <jmnoz> so I have a HTML fragment in a string and I want to shorten it to an approximate length without breaking HTML. Any ideas for how? 
17:25:05 <Axman6> how much do you know about how it'll look?
17:25:42 <jmnoz> not a whole lot
17:26:16 <jmnoz> it's from rss/atom feeds so could look like whatever
17:26:41 * hackagebot ntrip-client 0.1.2 - NTRIP client.  https://hackage.haskell.org/package/ntrip-client-0.1.2 (markfine)
17:28:07 <Axman6> you could parse it, keep track of every tag which is opened (subtracting the tag from the length of characters you want to show) and then close all opened tags which haven't been closed yet once you've reached enough printable characters
17:29:01 <Axman6> keep a list of open tags you've seen, and pop them off when you see the close tag
17:29:37 <Axman6> if you need to keep it below a certain number of bytes, then that might be a bit tricky, but easily done if you're happy to strip all html
17:30:39 <jmnoz> thanks! yeah suppose I'll look some at the parsing packages 
17:41:04 <jle`> jmnoz: if your html is rendered from something like markdown, you could shorten the markdown and re-render that
18:04:56 <ryu0> I have a question for those here who are more familiar with functional languages, specifically Haskell if appropriate. How important or relevant is calculus and its related topics like linear algebra to being effective and/or productive with a functional language, such as Haskell?
18:06:04 <geekosaur> not very, unless they are important to the problem domain, I'd say
18:06:07 <Hijiri> ryu0: I don't think it's that relevant, unless you are developing something in a domain where calculus or linear algebra is useful
18:06:28 <ryu0> Hijiri: which i have yet to really do. mostly only used to discrete.
18:06:28 <Cale> ryu0: It is exactly as relevant as with any other programming language.
18:06:40 <knx32542> I am no expert, but for the sake of discussion I will bite. Calculus in the traditional sense would only be useful for algorithm repitoire, as well as linear algebra.
18:07:16 <ryu0> I just thought it might be a good question to ask considering functional has deeper roots in mathematics than imperative does.
18:07:45 <ryu0> Thanks.
18:07:48 <geekosaur> "mathematics" is a BIG domain. not all areas of it are necessarily relevant
18:08:02 <Cale> Even the mathematics which does have some connection to functional programming, such as algebraic combinatorics and category theory is very much an optional matter.
18:08:30 <knx32542> True. Symbols are used more often in haskell, as in foralls and some editor plugins will go as far as displaying character sequences as familiar mathematical ones.
18:08:30 <Tuplanolla> Whenever real numbers are involved, the connections to programming are few, ryu0.
18:08:32 <ryu0> i would think graph theory, set theory, boolean algebra, and such would have a greater connection.
18:09:48 <ryu0> Tuplanolla: i assume that applies regardless of paradigm?
18:10:23 <Tuplanolla> Yes.
18:37:55 <Fylwind> The hardest part of teaching Haskell in person is figuring out how to pronounce things like “*>” or “<$”
18:39:05 <EvanR> make up intercal-like nonsense
18:39:50 <EvanR> *> splat-rrow
18:39:59 <kadoban> Fylwind: right-ap and left-map
18:40:20 <kadoban> Actually I'm not sure what that second one is, so maybe not that.
18:40:59 <jle`> "*>" is andThen ?
18:41:50 <jle`> <$ might be 'replace-result', but i don't think there's an accepted name heh
18:41:54 <Tuplanolla> Go with "ply" for the right half of "apply" and "mmph" for the left half of "map".
18:41:55 <jle`> > 5 <$ [1..10]
18:42:04 <jle`> rip lambdabot
18:42:04 <lambdabot>  [5,5,5,5,5,5,5,5,5,5]
18:42:15 <jle`> oh just a little delayed
18:46:07 <JonReed> Hi, I'm new to lens, how can I write a lens expression where there is a map in the middle that returns maybe. E.g. lets say that `myData :: MyData`  and I want to get some deeply nested property, something like`myData^.prop1.subprop1.(at key).subsubprop1.subsubsubprop1`
18:46:41 <Fylwind> jle`: "andThen" is how non-Haskellers call "bind" :P ( https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then )
18:47:12 <Fylwind> I think 'then' is appropriate for *> or >>
18:47:35 <JonReed> subprop1 is a lens into a map and that at returns maybe, so afterwards I need somehow to continue to accessing deep into the structure that now shifted to maybes
18:52:26 <EvanR> JonReed: i think to get into a Maybe, you just use fmap
18:53:05 <EvanR> somehow
18:55:36 <Fylwind> JonReed: try using the `_Just` prism to "pull the value out", and then replace your use of `^.` with `^?`
18:56:04 <Fylwind> (I vaguely remember running into this same question a long time ago … had to dig up some old JSON-parsing code to remember)
18:58:53 <Fylwind> For example, Data.Map.fromList [("x", ("a", "b"))] ^? at "x" . _Just . _1 ⇒ Just "a"
19:00:58 <JonReed> Fylwind: Thanks! It works. fmap would also work, but your solution is better IMO since lens from from left to right, but fmap flows in reverse, so combining both is more confusing.
19:01:42 <EvanR> if by reverse you mean flip, theres <&> in lens
19:01:45 <EvanR> which is flip (<$>)
19:03:33 <JonReed> EvanR: Hm, did not know about it. That's good to know.
19:07:14 * hackagebot jammittools 0.5.2 - Export sheet music and audio from Windows/Mac app Jammit  https://hackage.haskell.org/package/jammittools-0.5.2 (mtolly)
19:12:10 <unclechu> hi there, how I realize which module provides a function when I use non-qualified import? is there any unix-way tool for that for example?
19:12:59 <osa1> unclechu: load the module to ghci, run `:info <function>`
19:13:53 <unclechu> osa1: okay, thanks
19:14:40 <osa1> unclechu: alternatively, you can try some of the fancy emacs modes. I don't know anything about those as I have a very simple vim setup that I've been using for the last 5 years.
19:18:07 <unclechu> osa1: I was one cool emacs mode, repl with already loaded current module functions and stuff. I'm using vim, I wonder if I can use `ghci` to just run and answer me which module function/type belongs, like `:!ghci -blablaflags % ':info smth'` I'll see in man-s
19:18:58 <unclechu> but I guess it would be impossible if module isn't in compilable state
19:19:47 <unclechu> or what if my module have *.hsc extension?
19:20:15 <unclechu> would ghci understand that?
19:22:13 <osa1_> unclechu: yes, those are problematic cases. you just need to be careful with your imports. use explicit import lists.
19:22:58 <osa1> unclechu: use a tag generator and an editor that supports tags, that helps because you can jump to the definition of a symbol
19:23:26 <unclechu> osa1_: I'd glad to but if I use some examples for first time, I don't know what provides it and I need to realize it first
19:24:01 <unclechu> yaeh, I guess I should read about tags generating for haskell first
19:24:48 <osa1> yeah if you're just getting started it's annoying, I had the same problem when I first got started
19:25:05 <osa1> if you're an emacs user check out the emacs modes first, those may be provide that.
19:25:13 <osa1> providing*
19:25:26 <osa1> nowadays I use explicit import lists or qualified imports + tags
19:25:36 <osa1> also, ghci
19:26:00 <osa1> unclechu: note that in Haskell it's relatively easy to bring your modules to compilable state using `undefined`s everywhere.
19:27:12 <EvanR> or you could use holes
19:27:19 <EvanR> and then defer type errors flag
19:27:44 <EvanR> undefined has uses in production code so its hard to remember whats not finished if you use them for holes
19:27:48 <unclechu> EvanR: `holes`?
19:27:51 <EvanR> yes
19:28:07 <EvanR> fmap (\x -> x + _) [1,2,3,4]
19:28:15 <unclechu> I'm not sure which kind of holes you're talking about
19:28:16 <EvanR> f x y z = _
19:28:25 <unclechu> okay
19:28:35 <EvanR> _ is a valid expression, GHC will tell you what the type of it is when you try to compile
19:29:05 <EvanR> and whats in scope
19:29:11 <EvanR> so it might give you a clue how to proceed
19:30:11 <EvanR> not to be confused with the _ pattern, which matches anything
19:35:37 <Cale> EvanR: Though, almost always, it's better in production code to at least use a more particular error message than undefined. There's loch-th which will insert line numbers and such into your failure cases.
19:35:59 <EvanR> not really thinking of that
19:36:21 <EvanR> dont use undefined for that
19:36:58 <Cale> Even for the cases that "can't happen" -- they might happen at some point, and some message letting you know where is better than Exception: undefined
19:37:48 <EvanR> yeah use error in case analysis which is supposed to be impossible
19:38:43 <EvanR> and proxy when its for selecting instances
19:39:05 <Cale> ah, yeah
19:40:05 <Cale> For a similar reason, apart from some idioms like map head . group . sort, I tend to use (\(x:_)->x) rather than head
19:40:07 <EvanR> but libraries that use Void for stuff, or position unreachable values at time infinity, or unamb where undefined is considered a valid value
19:41:49 <EvanR> or returning an answer about lists known to be infinite
19:42:24 <EvanR> sometimes undefined "is" the answer
19:52:23 <unclechu> is there any way to generate ctags for *.hsc files?
20:06:55 <begriffs> unclechu: have you tried hasktags?
20:12:57 <unclechu> begriffs: it's working. thanks, I used hothasktags
20:22:17 * hackagebot language-c-inline 0.7.10.0 - Inline C & Objective-C code in Haskell for language interoperability  https://hackage.haskell.org/package/language-c-inline-0.7.10.0 (ManuelChakravarty)
20:35:27 <EvanR> heh, heres another one: randomNumber <- stateful (undefined, randomGenerator) nextRandom
20:35:44 <EvanR> example code from elerea
20:55:08 <bollu> What's the easiest way to implement *> and <*? Easiest in the sense of most straightforward 
20:56:30 <Cale> To not implement them at all and let the default definition do it.
20:57:55 <bollu> Cale: yes, but I want to show the implementation to a couple people today
20:57:57 <bollu> But I want so
20:58:07 <bollu> Something that's more intuition and less follow the types 
20:59:13 <Cale> Then liftA2 (\x y -> x) and liftA2 (\x y -> y)
21:04:08 <bollu> Ah damn. Why didn't I think of that -_- 
21:04:15 <bollu> Cale:
21:04:17 <bollu> Thanks! 
21:04:22 <Cale> bollu: no problem
21:05:25 <bollu> Cale: the prelude implementation is a little non straightforward. Why is it that way?
21:06:08 <Cale>     a1 *> a2 = (id <$ a1) <*> a2
21:06:08 <Cale>     -- This is essentially the same as liftA2 (const id), but if the
21:06:08 <Cale>     -- Functor instance has an optimized (<$), we want to use that instead.
21:06:19 <Cale> that?
21:06:56 <Cale> I think the comment explains it -- they want to take advantage of a custom (<$) if something better than fmap . const is available for that type.
21:08:39 <bollu> Oh, I see. I thought they were talking about a custom <* implementation in itself, not <$ 
21:09:16 <bollu> What's an example of a functor with a different <$ instance?
21:10:46 <Cale> Map k
21:11:08 <Cale> http://hackage.haskell.org/package/containers-0.5.8.1/docs/src/Data.Map.Base.html -- search for "instance Functor"
21:11:14 <bollu> Ooh. Thanks! :)
21:11:43 <bollu> I think I should read all of Prelude  
21:11:48 <bollu> Think itll help
21:11:53 <bollu> It'll help*
21:15:38 <Cale> bollu: If you don't (and probably even if you do), you'll end up reimplementing it a random half of it by accident :)
21:15:56 <Cale> -it
21:16:40 <bollu> Cale: hahaha. I suppose that's true :P 
22:04:47 <jchia> I want to throw an exception from IO for failing to parse an input CSV. Should I throw IOException or my own Exception type? If the former, how do I construct an IOException value? If the latter, do I just make it an instance of Exception and define the instance functions that are needed?
22:06:57 <sham1> Do you really want to throw an exception
22:07:31 <Axman6> throwing exceptions should be a last resort and only used in truly exceptional sircumstances
22:07:36 <Axman6> circumstances*
22:07:55 <jle`> it makes sense in a script, i think
22:07:57 <dmj`> jchia: why not just use either, why get IO all involved
22:08:00 <jle`> especially as IO
22:08:10 <jle`> but parsing a CSV is a pure function, so no reason to use errors there
22:08:23 <jle`> parsing a CSV doesn't sound like an IO exception
22:08:29 <jle`> it sounds like a pure function
22:09:13 <jle`> jchia: but if your script errors and ends if the CSV file doesn't parse, i usually would use something like userError 
22:09:14 <jle`> http://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO-Error.html#v:userError
22:09:22 <Axman6> cassava (which you should be using) provides a (painful) streaming API which reports errors as they occur, there's also things like pipes-csv which gives you Pipe ByteString (Either String a) m b
22:09:49 <jchia> I'm reading a CSV file and parsing it to get some data. If I use Either, is it Either String/Either Text? Then everyone upstream has to check where it's Left or Right. If I throwIO, I can catch the problem somewhere upstream wherever it's convenient
22:09:59 <jle`> so if you're writing a simple script to process files and you want the script to error out, userError makes sense
22:10:13 <dmj`> jchia: does it have to be CSV?
22:10:40 <jchia> dmj`: the input to my program is a CSV, so yes
22:10:42 <Cale> jchia: You generally don't have to define any of the methods of Exception
22:10:56 <Cale> jchia: You just derive Typeable and then write  instance Exception MyType
22:11:35 <Axman6> jchia: are you using cassava? it's probably the most widely used CSV parsing library and uses fairly sensible error handling
22:11:40 <jchia> i'm already reading a file, so i'm already in IO. IO (Either Text SomeData) means everyone upstream who uses this has to check whether it's Left or Rgiht
22:11:48 <Cale> The default methods are good enough unless you want to do something like reinterpreting other exception types as your own.
22:11:52 <jchia> Axman6: Yes, I'm using cassava
22:12:02 <jle`> even if jchia is using cassava, they have to eventually handle what happens when they parse a bad file
22:12:22 <jle`> if it's a part of a script that's heavy IO and you want the script to error out on that case, an io exception is reasonable
22:12:23 <jchia> Data.Csv.decodeByName returns an Either String. I'm using it in an IO where I read a file first
22:12:36 <Cale> But yeah -- the question is: is the upstream user probably going to want to handle the failure in some way, or are they probably going to want to ignore it and let it kill their program?
22:12:54 <Cale> If they probably want to handle the condition, better to make it Either
22:13:00 <jchia> someone upstream will need to detect the problem and indicate that the task failed
22:13:12 <jchia> so it's just catching an exception somewhere upstream
22:13:17 <jle`> in that case, it makes sense to just return an Either
22:13:25 <Cale> (if they *certainly* need to handle it, then even moreso)
22:13:26 <sham1> jchia: what you could do, is have your parser have the type Text -> Either Error CSVStuff
22:13:30 <jchia> with Either String, I have to check every level where it's Left or Right. Isn't that cumbersome?
22:13:38 <jle`> jchia: only if they want to use it
22:13:46 <dmj`> @package attoparsec-csv
22:13:47 <jle`> if they don't need to use the parsed thing, they don't need to check if itls Left or Right
22:13:47 <lambdabot> http://hackage.haskell.org/package/attoparsec-csv
22:14:30 <jle`> jchia: they only need to check if left/right in the case that they need to use the parsed thing.  but this is the same case where they would have to catch an exception too
22:14:31 <sham1> And they can go under an assumption that it is Right by using something like fmap or (>>=)
22:14:41 <jle`> jchia: so really, it's the same burden
22:15:08 <jle`> except Either is easier to work with
22:16:37 <lispy> happy mailman day!
22:16:48 <lispy> (just got my haskell.org list mails)
22:17:27 <dmj`> plain text password delivery, love it
22:20:04 <jchia> jle`: I could have f :: IO (), g:: IO (Either String Data1), h:: IO (Either String Data2) or f :: IO (), g :: IO Data1, h :: IO Data2
22:21:20 <jchia> I think the former design is more troublesome than the latter. h returns an Either String, so g has to be able to handle both Left and Right. In the latter design, g is simple. It doesn't need to worry about left, and I just let f catch the exception thrown in h.
22:24:03 <mrkgnao> o/
22:26:06 <jle`> jchia: except g does have to worry about the error
22:26:20 <jchia> jle`: Why?
22:26:34 <jle`> unless you're trying to say that g will rethrow any errors
22:26:37 <jle`> no matter what
22:26:50 <jchia> When h throws an exception and g doesn't catch it but f does, why does g have to worry about the exception?
22:27:03 <jle`> is g called in h?
22:27:09 <jle`> *h called in g
22:27:10 <jchia> f calls g, g calls h
22:27:58 <jle`> in either case, you have to make the choice how to handle the error
22:28:07 <jle`> in the second, you make the choice that g doesn't handle it
22:28:18 <jle`> the choice is made either way
22:29:07 <jle`> besides, handling either is pretty easy in haskell using higher order functions
22:29:12 <jchia> f is running some task. if the task fails, i let it fail. I don't try to recover and make the task work but just catch all the problems that could happen in f and report it.
22:29:26 <jle`> you can just use 'forM' on Either String Data1
22:29:30 <jle`> *Data2
22:29:31 <jchia> jle`: I know Either a is a Functor but it's still code and cognitive burden
22:30:04 <jle`> forM :: (Data2 -> IO Data1) -> Either String Data2 -> IO (Either String Data1)
22:30:23 <jle`> i would argue that the cognitive burden is stronger in the second case
22:30:35 <jle`> because you have to remember the network of possible exceptions in your head
22:30:43 <jle`> that's more you have to keep track of in your head
22:30:53 <jle`> with explicit Either, the compiler handles it for you
22:31:05 <mrkgnao> is there any function of the kind fromVector :: Vector (k, v) -> Map k v?
22:31:12 <jle`> mrkgnao: M.fromList ?
22:31:16 <mrkgnao> that doesn't involve converting the vector to a list
22:31:33 <jle`> mrkgnao: Map inserts are done one-by-one anyways
22:31:37 <EvanR> isnt fromList . toList fused?
22:31:38 <mrkgnao> fromList is [(k, v)] -> Map k v, I guess
22:31:38 <Axman6> what's wrong with converting to a list? it'll be optimised away at compile time
22:31:40 <jle`> so it's going to come in one-by-one
22:31:51 <jle`> going through a list is literally the fastest way
22:31:54 <mrkgnao> Axman6: oh, then I'm happy
22:32:01 <jle`> how would reading it in as a vector have any advantage?
22:32:05 <jle`> are you worried about performance?
22:32:07 <EvanR> if it wasnt fused, it would still be going 1 by 1
22:32:21 <jle`> Map can't take advantage of the fact that vector is constant-space access, because it inserts items one by one
22:32:38 <Axman6> you should trust that any time you create some data and then immediately deconstruct it the compiler will never create the structure in the first place
22:32:45 <mrkgnao> yeah, I figured if there were a way to do it in one go that'd probably be quicker, although that was a vague feeling
22:32:50 <mrkgnao> jle`: that makes sense
22:32:53 <jle`> mrkgnao: what would you mean by "one go"?
22:32:57 <EvanR> Axman6: skeptical
22:33:09 <Axman6> EvanR: trust is easily broken =)
22:33:18 <jle`> jchia: forM makes things pretty clean actually in this case
22:33:27 <mrkgnao> jle`: I meant skipping the conversion to a list
22:34:08 <EvanR> mrkgnao: conversion to a list, at worst, would mean putting each element in the loop into a list node, giving it to the Map code, and it will take it out
22:34:14 <EvanR> so its not as bad as say ruby
22:34:43 <EvanR> which creates entire arrays between each step of a list processing algorithm
22:34:43 <jle`> mrkgnao: even if you could do some crazy low-level magic with Map's internal implementation, you're actaully going to find that the best way to construct one is to convert to a streaming list and insert them in one-by-one from the list :)
22:35:09 <mrkgnao> haha
22:35:11 <EvanR> but beyond that, ghc does fusion to remove the "put into list node" step
22:35:24 <jle`> in fact, i'd argue that something like this is actually one of the perfect examples of when using a list would be useful
22:35:52 <jmorris> How come this (https://github.com/joshua-morris/hpass/blob/master/src/UI/AddPassword.hs)  won't work with parse in this (https://github.com/joshua-morris/hpass/blob/master/src/Hpass.hs)
22:36:27 <jchia> jle`: so, something like this? Seems complicated. Can it be simplified?
22:36:27 <jchia> g = do
22:36:27 <jchia>     ...
22:36:27 <jchia>     foo <- h
22:36:27 <jchia>     either pure (do ...) foo
22:36:30 <Axman6> Hey, you're Tony's son! 
22:36:33 <jle`> jchia: no
22:36:44 <jle`>  foo <- h
22:36:52 <jle`>   forM foo $ \x -> ...
22:37:03 <jle`> er, or forM foo $ \x -> do
22:37:06 <jle`>     ...
22:37:14 <mrkgnao> stupid question #2: suppose I have something of the form (a, Maybe b)
22:37:15 <Axman6> h >>= either pure $ do ...
22:37:34 <mrkgnao> sorry, I meant [(a, Maybe b)]
22:37:35 <jle`> jchia: there's an extra layer of indenation, but if you have a lot, you can actually start switching to EitherT
22:37:52 <mrkgnao> how do I slickly do a catMaybes-style thing over the second "slot"
22:38:09 <jle`> :t mapMaybe sequence
22:38:12 <lambdabot> Traversable t => [t (Maybe a)] -> [t a]
22:38:27 <jle`> > mapMaybe sequence [(1, Just 10), (2, Just 11), (3, Nothing)]
22:38:30 <lambdabot>  [(1,10),(2,11)]
22:38:30 <lambdabot>  
22:38:37 <mrkgnao> oh, nice
22:38:44 <jmorris> Axman6: :)
22:38:47 <jle`> but i probably wouldn't use this in code you expect other people to read hehe
22:38:55 <EvanR> thats damn slick
22:39:18 <jchia> jle`: Yeah, seems simple enough if it becomes adopted as an idiom, but like you said, the indentation is a drawback.
22:39:24 <Axman6> jmorris: pretty sure you need to use (Just username) and Nothing
22:39:41 <Axman6> jmorris: pretty sure the error message would've said as much too ;)
22:42:21 <Axman6> jmorris: also, you're giving addPassword a list of Strings, but it's a function of type FilePath -> String -> Maybe String -> String -> IO (), not [String] -> IO ()
22:42:22 <jle`> jchia: yeah, there's a tradeoff to the levels you want to propagate and handling it explicitly.  one way you could justify using exceptions would be to think about read-and-parse as itself an IO action
22:42:27 <jchia> jle`: I tried using EitherT. It works as expected but I get lost easily in monad transformer stacks -- they still impose quite a cognitive burden on me, so I'm inclined to use syntactically (not necessarily conceptually) simple things.
22:42:30 <jle`> in that case, having that throw an IO exception would be meaningful
22:44:04 <jle`> i'd use something like userError
22:44:43 <jle`> but yeah, there's going to be a tradeoff between cognitive burden of keeping track what's throwing what, and the syntactic burden of working with Either
22:45:11 <jle`> there are points on both ends of the spectrum
22:45:21 <jmorris> Axman6 thanks
22:45:32 <EvanR> for application wide long range exceptions...
22:45:44 <EvanR> skeptical about using Either
22:45:44 <jchia> jle`: That's nifty. I just want to report errors to the user so that's just right for my use case.
22:46:11 <EvanR> if youre already in IO, use IO exceptions
22:46:13 <jle`> throwIO (userError "hey what are you doing") :: IO a
22:46:35 <Axman6> jmorris: get it working?
22:47:55 <jmorris> Axman6 I think you mean adding (Just username) and Nothing in the parse function, right?
22:48:39 <Axman6> jmorris: yeah. I'm resisting the urge to give you the answer directly, your dad wouldn't approve :P
22:49:40 <jmorris> Axman6: I'm guessing it has something to do with not giving an array to parse
22:51:13 <jchia> can this be simplified? I'm returning IO [Text]:
22:51:13 <jchia>     ...do
22:51:13 <jchia>         bs <- readFile (unpack optionsRdFile)
22:51:13 <jchia>         let resultE = decodeByName bs >>= traverse symToText . snd
22:51:13 <jchia>         either (const $ (throwIO . userError) "Error reading options CSV") (pure . vectorToOption) resultE
22:51:15 <Axman6> parse is fine, but you need to give the arguments to addPassword individually
22:51:44 <jchia> especially the last line
22:51:49 <jle`> jchia: cassava has decodeFile i think
22:52:08 <jle`> the last line i'd use pattern matching
22:52:23 <jchia> jle`: but not decodeByNameFile
22:53:43 <jle`> shame
22:54:13 <jle`> i don't really like using >>= with . because you have to jump back and forth
22:54:22 <jle`> mixing application/composition in different directions
22:55:56 <jle`> but yeah, however you do the first two lines, pattern matching is probably the best way to write the last line
22:56:01 <jmorris> Axman6: I think I got it! c:
22:57:08 <jle`> symbs <- fmap snd . decodeByName <$> readFile (unpack optionsRdFile)
22:57:13 <jle`> case traverse symToText symbs of
22:57:15 <jle`>   Right -> ...
22:57:48 <jle`> (traverse symToText symbs isn't right, but yeah)
23:01:57 <Axman6> jmorris: linky?
23:05:46 <jchia> jle`: The (>>=) is for the Either monad. If I don't use it, I have to 'unwrap' the 'content' manually.
23:05:57 <jchia> this is also why the traverse is wrong
23:06:08 <jle`> yeah.  but `traverse symToText =<< symbs` is kinda uggs
23:07:27 <jchia> jle`: What about         case join $ traverse symToText <$> symbs of
23:08:25 <jchia> using join instead of ">>="
23:10:33 <jchia> But "case symbs >>= traverse symToText of" looks fine to me 
23:22:23 * hackagebot from-sum 0.2.0.0 - Canonical fromMaybeM and fromEitherM functions.  https://hackage.haskell.org/package/from-sum-0.2.0.0 (cdepillabout)
