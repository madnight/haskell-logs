00:00:48 <grantwu> Jesus chris, ghc-mod is using 3 GB of memory
00:02:20 <jle`> same
00:12:35 <jvanbure> same
00:12:51 <grantwu> It's definitely like... a slow leak
00:22:34 <jonge> hi there. i have a haskell module where i want to export one function, and all symbols of a "data CType = Char | Short | Int | Long | ...(many)". how do i export all the latter? i want to use symbols like "Short" in the importing code later.
00:23:19 <ertes> jonge: export CType(..)
00:23:21 <pavonia> CType (...)
00:23:38 <pavonia> two dots
00:25:49 <jonge> lol i tried it with three dots before and thought that's completely wrong. :D thank you, pavonia. That works great.
00:58:14 * hackagebot yesod-auth-hashdb 1.6 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.6 (paulrouse)
00:58:16 * hackagebot WaveFront 0.5.0.0 - Parsers and utilities for the OBJ WaveFront 3D model format  https://hackage.haskell.org/package/WaveFront-0.5.0.0 (SwiftsNamesake)
01:19:44 <f-a> I have troubles with HXT. I can select every <a> element with a specific ref value with: //> hasAttrValue "href" (\x -> take 3 x == "jav")
01:20:05 <f-a> but how to extract (return) the string of attribute href?
01:25:22 <DexterLB> hello.. I have a pseudo-graph type of structure: I have a Node type with some data, and a function which given a Node outputs a list of its children
01:26:31 <DexterLB> I also have some data that is global for the graph, but is needed by the children function. Should I pass the nodes and the global data separately, or should I place the global data in the Node and pass it downwards? (e.g. will haskell do something clever not to duplicate data each time)
01:35:01 <grantwu> ghc-mod is back up to 3.3 GB memory used.
01:35:04 <quchen> f-a: XmlArrow has a number of methods that suggest giving you access to attributes, such as ‘getAttrl’, have you seen those?
01:35:11 <grantwu> I should write a script that reboots it periodically
01:36:11 <quchen> f-a: Oh, there’s even ‘getAttrValue :: String -> xmlArr XmlTree String’.
01:37:52 <f-a> quchen: `//> getAttrValue "href"` gives me an empty list. Want me to upload the code?
01:39:24 <lpaste> f-a pasted “hxt” at http://lpaste.net/276609
01:45:10 <quchen> By the way, instead of ‘\x -> take 3 x == y’ you can use ‘x `isPrefixOf y’.
01:46:39 <f-a> roger
01:47:01 <jchia1> can i express f a == f b && g a == g b && h a == h b in an applicative style? f, g, h are functions
01:48:55 <jchia1> or more succintly?
01:50:44 <ertesx> jchia1: let cmp f = f a == f b in cmp f && cmp g && cmp h
01:52:03 <quchen> f-a: No idea, sorry. I haven’t used HXT :-/
01:52:24 <Xnuk> @pl \a b -> f a == f b && g a == g b && h a == h b
01:52:24 <lambdabot> ap (ap . ((&&) .) . (. f) . (==) . f) (ap (ap . ((&&) .) . (. g) . (==) . g) ((. h) . (==) . h))
01:52:39 <quchen> f-a: What happens when you delete the “href” part? Will you get all DOM nodes?
01:53:25 <f-a> quchen: yeah, I get everything
01:53:37 <f-a> and then I can select the relevant <a>
01:54:59 <quchen> f-a: What if you change ‘hasAttrValue’ to ‘hasAttr’ and leave the \ away? Do you also get an empty list in this case?
01:55:50 <quchen> Trying to reduce it to a minimal non-working example :-)
01:57:36 <jchia1> @pl \a b fs -> all id $ fmap (\f -> f a == f b) fs
01:57:36 <lambdabot> (((and .) . fmap) .) . (. flip id) . ap . ((==) .) . flip id
01:57:43 <f-a> no empty list, quchen , it works. and if I put //> hasAttr "href" //> getText it's still no empty list (i get what's , uhhh, between <a> and </a>)
01:58:10 <f-a> I am pretty sure I just don't know the combinator
01:58:15 * hackagebot netwire 5.0.2 - Functional reactive programming library  https://hackage.haskell.org/package/netwire-5.0.2 (esz)
01:58:17 * hackagebot rapid 0.1.3 - Rapid prototyping with GHCi: hot reloading of running components and reload-surviving values  https://hackage.haskell.org/package/rapid-0.1.3 (esz)
01:58:18 <gargawel> jchia1: let cmp a b = let foo = (\a -> (f a, g a, h a)) in foo a == foo b
01:58:21 <f-a> and since it's all arrows hoogle doesn't help that much
01:58:46 <gargawel> granted, that's not much more concise
01:59:46 <f-a> jchia1: maybe (\a b -> all (\f -> f a == f b) [(+1)]) 1 1 ?
01:59:52 <quchen> f-a: Alright, so if ‘hasAttr "href"’ works, try ‘hasAttrValue "href" (const True)’.
01:59:54 <ertes> jchia1: all id = and
02:00:00 <f-a> (were you put functions inside the list?)
02:00:57 <jchia1> ertes: you're right
02:01:08 <ertes> jchia1: foldr (\f -> (f a == f b &&)) True
02:01:23 <f-a> quchen: maybe I misunderstood you, but just incase: hasAttrValue "href" (\x -> take 3 x == "jav") works, it correctly fetches stuff
02:01:23 <ertes> but we're approaching golf code now =)
02:02:15 <quchen> :t \functions x y -> and [ f x == f y | f <- functions] -- jchia1, if you’re looking for readability, maybe this one?
02:02:16 <lambdabot> Eq a => [t -> a] -> t -> t -> Bool
02:02:18 <gargawel> (and the runtime cost is probably higher)
02:02:32 <quchen> If you’re looking for Applicative style here, there is nothing to gain.
02:02:32 <gargawel> (unless the function is inlined, and GHC is able to optimize something)
02:02:33 <jchia1> @pl \f -> (f a == f b &&)
02:02:33 <lambdabot> (&&) . liftM2 (==) ($ a) ($ b)
02:03:01 <quchen> You don’t even have Applicative here, you have an example of Applicative (namely Reader). Using <*> and friends won’t help code quality at all.
02:03:25 <ertes> it can in some rare cases
02:03:55 <ertes> like:  let (<&&>) = liftA2 (&&) in f <&&> g <&&> h
02:03:59 <ertes> but that doesn't really help here
02:05:03 <ertes> Biapplicative could help to make point-free in a half-way sane manner
02:05:11 <ertes> + this
02:07:15 <jchia1> biapplicative was the intuition i had about applying the same functions to two things
02:07:19 <jchia1> didn't know that was a thing
02:07:38 <ertes> jchia1: it's in the bifunctors package
02:08:19 <jchia1> can it be used to express the original expression more concisely?
02:08:42 <ertes> it doesn't really help without a wrapper type though
02:09:03 <jchia1> you mean wrap a and be in (a, b)?
02:10:18 <jchia1> i think i'm going to need to learn some category theory to use stuff like this
02:11:18 <jchia1> quchen: I think that list comprehension approach is quite readable
02:11:40 <ertes> @let import Data.Biapplicative
02:11:42 <lambdabot>  Defined.
02:12:50 <ertes> jchia1: sorry, i misled you…  Biapplicative doesn't really help, unless you combine it with Bifoldable as well, but this is major overengineering
02:13:07 <f-a> quchen: it was >>> getAttrValue "href" !!11!!1one
02:13:09 <m4lvin> Can I use type classes to generalize Either? I want to decide which instance to use depending on an integer input parameter ... http://lpaste.net/276741
02:13:13 <f-a> I am balder and sadder, to be honest
02:13:36 <f-a> but at least I can say I managed to scrape this :P
02:14:12 <ertes> m4lvin: what do you mean?  try to express the application
02:14:20 <ertes> s/express/explain/
02:15:31 <jchia1> So for my original expression of f a == f b && g a == g b && ...,  if you had a lot of those f g h functions, maybe 10 of them, how would you express for readability while avoiding repetition? (applying the same functions to a and b is a form of repetition)
02:15:48 <elliptic00> hi, anyone know how to reload ghci.conf file from inside Prelude console without :quit ghc
02:15:51 <m4lvin> ertes: I want to use Math.Core.Field from HaskellForMaths but only at runtime decide which field to use, depending on how large I need it to be.
02:16:25 <m4lvin> and in MathCoreField each field is a type. the paste linked to above is a toy example with the same problem.
02:16:55 <elliptic00> I try  :r  ~/.ghc/ghci.conf , but it doesn't work
02:17:41 <ertes> m4lvin: it depends…  if you want the field choice to be static, you need dependent types, which haskell doesn't have (emulating them is possible, but is rather hacky)
02:18:21 <ertes> m4lvin: if dynamic choice together with dynamic "dispatch" (by pattern-matching on Either) is enough, then you should just use Either or something similar
02:19:05 <m4lvin> ok, thanks. what is better way than 14 nested Eithers? ;-)
02:19:14 <ertes> m4lvin: there is also a middle ground called reflection, but it too requires some advanced type system features like RankNTypes…  if you're comfortable with those, check out the reflection package
02:19:21 <jchia1> quchen: it turns out that the list comprehension approach requires the functions to have the same type
02:19:43 <jchia1> i suppose that's a given since i decided to put the functions in a list
02:19:43 <ertes> m4lvin: i've parameterised over groups and moduli using reflection
02:20:07 <jchia1> so putting functions in a list has another disadvantage
02:20:23 <ertes> m4lvin: but i don't know if that's suitable for the way HaskellForMaths is designed (no experience with that library)
02:21:06 <ertes> m4lvin: here is a toy example of reflection for a number field: https://github.com/esoeylemez/snippets/blob/master/FibNF.hs
02:24:46 <m4lvin> ertes: thanks! this looks very interesting!
02:25:06 <m4lvin> I don't even get the toy example but I think the general idea what reflection does could help us
02:29:02 <ania123> hi
02:29:12 <ania123> can one help me why it gives me error?
02:29:13 <ania123> http://pastebin.com/SQMSTC1x
02:30:04 <whiteline> ania123: neither a or b is defined
02:30:40 <ania123> they are typed variables
02:30:46 <jchia1> ania123: your a and b only appear as function arguments when you define firsts
02:31:07 <jchia1> outside the context of firsts, they have no meaning
02:31:19 <ania123> they are variables
02:31:21 <ania123> typed variables
02:37:43 <jchia1> ania123: outside of the first line, a and b are bound to nothing
02:38:09 <ania123> how should i change it?
02:39:09 <ania123> how can I declare that, a and b are type variables
02:39:09 <ania123> ?
02:39:41 <lyxia> what do you expect the type of first [(a,b)] to be anyway
02:39:55 <gargawel> Hi, I'm toying with TH to generate FFI bindings
02:40:12 <gargawel> Could someone tell me what's wrong with this example ? (The error is shown in a comment in the second file): https://gist.github.com/gdeest/7f8376b2c775543450da48a32c7d4b94
02:40:52 <gargawel> It looks like the types are correctly resolved by "lookupTypeName", and yet, I get an "Illegal type variable name" error
02:41:29 <ania123> int
02:41:31 <ania123> string
02:41:34 <ania123> char
02:41:36 <ania123> whatever
02:41:54 <gargawel> ania123: your function must be applied to values, not types
02:42:12 <ania123> it has to applied to any values
02:42:15 <gargawel> I am not sure what you're even trying to do
02:42:16 <ania123> having those types
02:42:29 <ania123> I want function
02:42:47 <ania123> which applies list of tuples and returns list of its first elements
02:42:59 <gargawel> You've already defined that
02:43:15 <gargawel> but the way you're calling it is wrong
02:43:24 <ania123> how should i call?
02:43:27 <gargawel> you're not calling it on anything meaningful
02:43:50 <ania123>  firsts[(1,2),(3,4)]
02:43:58 <ania123> this is
02:44:04 <gargawel> Yes, that would do
02:44:14 <ania123> it gievs error
02:44:38 <ania123>  firsts[(1,2),(3,4)] 
02:44:39 <ania123> [1,3]
02:44:41 <ania123> if I 
02:44:53 <ania123> firsts :: [(Int, Int)] -> [Int]
02:44:55 <ania123> have this
02:45:38 <gargawel> If I understand well, you're trying to /refine/ the function to a more specific types 
02:45:44 <gargawel> *type
02:45:45 <gargawel> is that it ?
02:45:48 <ania123> ah
02:45:49 <ania123> clear
02:45:50 <ania123> thx
02:46:13 <gargawel> if that's so, you can't give the same function two different type signatures
02:46:25 <pavonia> gargawel: I think you want ConT instead of VarT, VarT is for type variables
02:47:09 <gargawel> pavonia: Aha ! I'll try that and let you know
02:47:33 <gargawel> pavonia: It works, thanks ! :)
02:48:06 <gargawel> That's obvious, in retrospect
02:58:17 * hackagebot yesod-auth-hashdb 1.6.0.1 - Authentication plugin for Yesod.  https://hackage.haskell.org/package/yesod-auth-hashdb-1.6.0.1 (paulrouse)
02:58:19 * hackagebot grid 7.8.6 - Tools for working with regular grids (graphs, lattices).  https://hackage.haskell.org/package/grid-7.8.6 (AmyDeBuitleir)
03:20:53 <danilo2> Hello guys! Could anybody please explain to me what exactly context reduction stack overflow is? I've got a code that I'm sure should work (it uses UndecidableInstances) and I'm getting this error, but to be honest Im pretty sure the typechecking should be ok
03:24:00 <tdammers> for a second there, I thought http://contextreduction.stackexchange.com/ ...
03:24:34 <pavonia> I think it tries to resolve the left side of the instance declaration but gets into a loop because the context doesn't get smaller
03:25:22 <danilo2> pavonia: I was thinking the same, but in my case it doesnt (Or I'm just wrong). Is there any way to print the conttexts and check them ?
03:26:03 <pavonia> I don't know
03:28:53 <byorgey> danilo2: doesn't it print the contexts as part of the error message when you get a context reduction stack overflow?
03:29:27 <danilo2> byorgey: it prints only the type which raises the error but without expansion
03:34:17 <byorgey> danilo2: huh, I have definitely seen error messages listing the top entries on the context stack when it overflows.  Not sure how to get that if it isn't printed by default though.  Maybe just try -v ?
03:39:26 <danilo2> byorgey: hmm, have you seen it in ghc8 ?
03:40:36 <byorgey> danilo2: no, this would have been quite a while ago.  
03:41:09 <danilo2> byorgey: ghc8 has new error diasplaying mechanism so I'm just thinking that maybe there is another option here. Ok thank you for help, I'll try to investigate it further
03:58:18 * hackagebot alex 3.2.1 - Alex is a tool for generating lexical analysers in Haskell  https://hackage.haskell.org/package/alex-3.2.1 (SimonMarlow)
04:08:22 <jophish> does anyone know if Ericson2314 is on Freenode?
04:10:45 <MrElendig> jophish: /ns info Ericson2314
04:11:05 <MrElendig> /quote ns * if your irc client doesn't send unknown commands to the server by default
04:12:15 <jophish> ah, thanks MrElendig, didn't know about that
04:15:47 <MrElendig> will explode the second you update your system
04:17:26 <MrElendig> bha that last line was for #xmonad
04:27:52 <ThreeOfEight> Hallo, does anyone have experience in giving haskellbook.com to someone who's done next to no programming in their life? Or any other introductory book, for that matter?
04:35:19 <tabaqui> why this definition is correct?
04:35:24 <tabaqui> data Foo = Int | Bool
04:35:37 <tabaqui> it has no data construction
04:35:42 <tabaqui> *constructor
04:36:46 <ongy> I'm having difficulties setting up necoghc with vim. I can't seem to get its completion function
04:36:51 <hpc> it has two, Int and Bool
04:36:58 <hpc> Int :: Foo, Bool :: Foo
04:37:10 <hpc> they happen to share names with types, but constructors are in a different namespace so it's fine
04:37:26 <hpc> if you want to be tremendously confusing, data Foo = Int Int | Bool String
04:37:33 <hpc> Int :: Int -> Foo, Bool :: String -> Foo
04:37:58 <hpc> it's a bit easier to understand if you use GADTSyntax, which i quite like
04:38:02 <hpc> data Foo where
04:38:05 <hpc>   Int :: Foo
04:38:07 <hpc>   Bool :: Foo
04:43:17 <Squarism> So, if all ... -> IO a functions are pure. Where does the obvious sideeffects take place? Or how should one explain it to newcomers - wo simplyfing it beyond truth.
04:43:56 <mauke> the effects happen in the runtime system which is like an interpreter for IO actions
04:44:07 <ThreeOfEight> Squarism: think of "IO a" as a cooking recipe that, when you cook it, gives you a value of "a"
04:44:33 <ThreeOfEight> writing the recipe is something pure
04:44:41 <mauke> the runtime system is imperative but it can call into the pure haskell system
04:44:43 <ThreeOfEight> the side effects occur when you actually execute the recipe
04:44:47 <merijn> Squarism: There are no side-effects. Side-effects implies a function does something that is hidden from it's type (e.g., ocamls "print :: String -> ()" or C's printf being "void printf(char *)", etc.
04:45:19 <merijn> Squarism: By enforcing the tracking of effects in the type system (e.g., IO), the effects are, by definition, no longer side-effects, but just effects.
04:46:05 <merijn> Squarism: Then, the more technical question would become: When do effects happen? and Who/what makes effects happen?"
04:47:10 <merijn> Squarism: To which the answers (depending on desired level of detail) are: "the runtime makes effects happen" and "whenever it damn well pleases" (with the added constraint that the monad laws of IO tell us *some* things about the actual ordering/behaviour)
05:07:46 <jophish> ongy: are you able to run ghc-mod outside of vim?
05:07:56 <jophish> does vim give you any error messages?
05:09:08 <ongy> jophish: teh :NecoGhcDiagnostics output says: "ghc-mod is executable: 1" so that shouldn't be it. Also "omnifunc: necoghc#omnifunc"
05:10:10 <jophish> ongy: but does ghc-mod work :) can you do ghc-mod check some/file.hs
05:10:37 <ongy> no complaints from ghc-mod
05:10:40 <jophish> hmm
05:11:23 <jophish> I've only used it with deoplete, ongy 
05:13:05 <jophish> my vimrc is here if you want to look, it's huge and messy though https://github.com/expipiplus1/dotfiles/blob/master/config/nvim/init.vim
05:14:52 <merijn> jophish: You should do what I do, reserve 1-2 weeks every year to clean up and version your config!
05:15:01 <merijn> And fix minor warts/annoyances
05:15:56 <jophish> merijn: seems like quite an investment
05:16:38 <jophish> I'm sure that the fixing-annoyances time I spend every year is <2 weeks
05:17:04 <merijn> jophish: It varies depending on the complexity of the annoyance, and it's not like I do that fulltime :p
05:17:55 <jophish> merijn: perhaps I'll post it to /r/vim as an example of a neat and tidy vimrc and wait for other people to suggest fixes for me :)
05:18:29 <ertes> that's the paul graham algorithm
05:19:27 <ongy> with all that neocomplete and deoplete going on it doesn't help much. maybe I should just use one of those
05:21:05 * merijn has a bugtracker for issues with his setup to fix "sometime" :p
05:22:59 <ertes> "The first discovery I'd like to present here is an algorithm for lazy evaluation of research papers. Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers you should have cited. I discovered this algorithm after ``A Plan for Spam'' [1] was on Slashdot."
05:23:25 <jophish> hahahaha
05:23:36 <jophish> ongy: deoplete is pretty easy to set up
05:24:09 <jophish> merijn: my todo list is going to take years to complete :(
05:24:45 <ongy> todo, high urgency: get a decent os. "Note: will have to create it"
05:25:23 <jophish> oh, it's nothing nearly as useful as that :)
05:25:53 <ertes> my todo list consistently has one item on it with the highest urgency: "do your book-keeping! come on, it takes longer the longer you wait!"
05:27:19 <merijn> Mine is: "Debug annoyingly intermittent issues with OpenCL implementation being linked, which may or may not be the result of kernel driver/library incompatibilities, but who knows?"
05:28:45 <jchia> Question about Data.Vector: Since Vector already has a Foldable instance, why does it need to define length? If I import both Data.Foldable and Data.Vector, I get an ambiguous length and it's distracting to have to do hiding (length). The same for toList. Any ideas for how to smoothly deal with this an similar name clashes between different modules (e.g. Data.IntMap.Strict.null vs Data.Vector.null). I find that i spend so much time messing with imports and cla
05:29:07 <tabaqui> hpc: i'm back
05:29:16 <tabaqui> hpc: about Foo = Int Bool
05:29:25 <tabaqui> why i cannot use it so?
05:29:30 <tabaqui> let x = 1 :: Foo?
05:29:46 <tabaqui> *data Foo = Int | Bool
05:29:49 <jchia> right now, i deal with he name clashes on a case-by-case basis, when the compiler complains. Is there a better way?
05:30:16 <merijn> jchia: Hide the clashing names during the import?
05:30:50 <merijn> jchia: "import Data.Vector hiding (length, toList)"
05:31:00 <merijn> jchia: Alternatively, explicitly import Prelude hiding those
05:31:24 <jchia> merijn: i don't remember what those clashing names are without the compiler telling me, and N libraries clash in N * (N - 1) different ways. I add the hiding when I get compiler complain, which is an interruption from the actual problem solving
05:31:46 <hexagoxel> import qualified Data.Vector as V
05:31:49 <jchia> is there a prelude alternative that can help with this problem?
05:31:55 <merijn> jchia: Qualified/explicit imports
05:32:01 <jchia> hexagoxel: sometimes i do that
05:32:34 <jchia> but then so many things becomes qualified, which is also not ideal
05:32:43 <jchia> hard to read
05:34:08 <amx> tabaqui: because Int and Bool are type constructors, not types. If you want to use them like you intended you must write let x = Int :: Foo
05:34:23 <jophish> jchia: I imagine that most alternative preludes export foldable's length
05:34:28 <merijn> amx: In that example they're *value* constructors
05:34:33 <amx> yes
05:34:40 <amx> I always mix them up, thx
05:34:52 <amx> on github at least I can edit my comment then ;)
05:37:54 <quchen> Int and Bool are neither type constructors nor value constructors. They’re types of kind *.
05:38:02 <quchen> True is a value constructor (for the type Bool).
05:38:11 <amx> in his example
05:38:12 <quchen> Maybe is a type constructor (of type * -> *).
05:38:15 <grantwu> What is the best way to convert a String into a ByteString?
05:38:29 <quchen> grantwu: Choose an encoding.
05:38:45 <grantwu> ASCII.
05:38:57 <quchen> For a quick and dirty version, just use Binary’s serialization.
05:39:14 <grantwu> I have to use something that's not in ByteString?
05:39:23 <ongy> for ascii Data.ByteString.Char8 pack/unpack should be enough
05:39:31 <jchia> jophish: perhaps a prelude that has prelude stuff and reexports the non-duplicate parts of Vector (e.g. length, null), Data.Map.Strict (null, foldr) etc would help
05:39:56 <jchia> are there such things
05:40:15 <quchen> Note that the Char8 module is usually a code smell. For quick and dirty hacks it’s sometimes suitable. https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
05:40:23 <merijn> encodeUtf8 . Data.Text.pack
05:40:30 <merijn> Anything else deserves a stoning
05:40:45 <quchen> Well, not stoning, but yeah.
05:40:48 <jchia> i mean a prelude that has prelude stuff and reexports (Vector minus length, null, etc) (Data.Map.Strict minus null, foldr, etc) etc
05:40:59 <merijn> quchen: It will once I take over the world >.<
05:41:12 <jophish> jchia: it's possible
05:41:52 <jchia> or maybe i should have my own modules that does nothing but reexports the non-duplicate parts, e.g. my own Vector that exports the regular vector minus things like null and length
05:42:06 <merijn> jchia: The latter is easy to do
05:42:09 <ongy> quchen: you even have the "If it's only ascii, it's ok" on your page
05:42:15 <grantwu> Ugh.
05:42:25 <jchia> is this because these modules have to be compatible with code written for older versions of the language where Foldable didn't exist yet?
05:42:28 <merijn> jchia: "module MyVector where (module Data.Vector) where import Data.Vector hiding (null, length)"
05:42:34 <grantwu> How do I convert a strict bytesting into a lazy bytestring?
05:42:40 <merijn> jchia: Foldable existed, but was not in Prelude
05:42:42 <grantwu> *strict bytestring into a lazy bytestring
05:42:54 <merijn> grantwu: There's a toStrict and toLazy somewhere in bytestring
05:43:03 <quchen> ongy: Problem is, things are rarely only ASCII.
05:43:13 <grantwu> And why does the BS docs never make the distinction
05:43:13 <quchen> (Name an example of something that is always ASCII.)
05:43:16 <jchia> so is this because of the desire to be backward compatible with code based on older language versions where Prelude didn't have Foldable?
05:43:44 <merijn> jchia: Older compiler versions, but yes
05:43:46 <ongy> I know. I haven't taken the liberty to rely on that in ages.
05:43:50 <merijn> jchia: Technically they're all the same language
05:44:04 <grantwu> merijn: There's not.
05:44:08 <tabaqui> in data Bool = True | False there is no errors cause True and False are not in namespace
05:44:10 <grantwu> Not that I can find.
05:44:16 <tabaqui> so we can use 'em
05:44:33 <merijn> grantwu: https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/doc-index-T.html
05:44:34 <tabaqui> in data Foo = Int | Bool, we already have types Int and Bool
05:44:59 <grantwu> @hoogle toLazy
05:45:01 <lambdabot> Pipes.ByteString toLazy :: Producer ByteString Identity () -> ByteString
05:45:01 <lambdabot> Pipes.Text toLazy :: Producer Text Identity () -> Text
05:45:01 <lambdabot> Agda.Utils.Maybe.Strict toLazy :: Maybe a -> Maybe a
05:45:02 <merijn> grantwu: I shall teach you my secret ways: At the bottom of the module list is an [Index] link which gives you an alphabetical list of all types/constructors/functions ;)
05:45:02 <tabaqui> and constructors
05:45:49 <grantwu> merijn: toLazyByteString takes a Builder.
05:46:20 <merijn> grantwu: "byteString :: ByteString -> Builder Source"
05:46:25 <merijn> eh
05:46:29 <merijn> Ignore the source part :p
05:46:32 <merijn> copy paste fail
05:47:09 <grantwu> okay.  Does that take a lazy or a strict bytestring?
05:48:03 <ongy> why did people think it's a good idea to call to things 'ByteString' and not one something like 'LazyBS'?
05:48:06 <merijn> Strict, because below it is a lazeByteString :: ByteString -> Builder" :)
05:48:17 <merijn> ongy: Because normally you'd import them qualified
05:48:24 <grantwu> merijn: Okay... but there's no way for me to tell just from the type.
05:48:32 <grantwu> Is this not broken?
05:48:35 <merijn> grantwu: You can if you mouseover in the documentation
05:48:52 <ongy> merijn: In code I get it, but it makes documentation really anoying to read
05:48:54 <grantwu> Mousing over in the docs isn't doing anything for m.e
05:48:57 <merijn> One hyperlinks to ByteString.Lazy
05:49:21 <grantwu> So, I should reason from documentation URLs.
05:49:32 <merijn> ongy, grantwu: I agree, but I don't know how to automatically change things. Having all types fully qualified is annoying to read too
05:51:25 <merijn> ongy, grantwu: I suppose you could define some functionality to generate custom names from the types, but that's...tricky
05:51:32 <lyxia> Display the fully qualified type on mouseover or on toggling a switch.
05:55:36 <jchia> Why does "stack haddock" seem to compile the source code when I'm using it only for generating documentation? It even fails when some source code has an error.
05:55:40 <merijn> There's a bunch of useful things you could implement, but it's not as trivial as it sounds.
05:56:20 <cocreature> jchia: source code can include things like template haskell which require compilation
05:56:22 <merijn> jchia: Because Template Haskell/generated code could be required for documentation generation
05:57:01 <jchia> the entire "stack haddock" run fails when one source file has an error. it doesn't even try to process the other packages. Is this a bug or a feature?
05:58:21 * hackagebot hxt 9.3.1.16 - A collection of tools for processing XML with Haskell.  https://hackage.haskell.org/package/hxt-9.3.1.16 (UweSchmidt)
05:58:23 * hackagebot hxt-cache 9.1.0.2 - Cache for HXT XML Documents and other binary data  https://hackage.haskell.org/package/hxt-cache-9.1.0.2 (UweSchmidt)
05:58:25 * hackagebot hxt-regex-xmlschema 9.2.0.3 - A regular expression library for W3C XML Schema regular expressions  https://hackage.haskell.org/package/hxt-regex-xmlschema-9.2.0.3 (UweSchmidt)
05:58:27 * hackagebot hxt-tagsoup 9.1.3.1 - TagSoup parser for HXT  https://hackage.haskell.org/package/hxt-tagsoup-9.1.3.1 (UweSchmidt)
05:58:29 * hackagebot servant-quickcheck 0.0.2.2 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.2.2 (jkarni)
05:58:43 <tdammers> haddock also does things like resolve includes to generate proper links across packages
05:59:57 <merijn> I'm pretty sure a haddock patch would be good :)
06:01:16 <ongy> but the best idea I have would be to special-case Data.ByteString.Lazy.ByteString to have some annotation
06:03:12 <Phyx-> Test
06:03:31 * hackagebot pandoc-types 1.17.0.4 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.17.0.4 (JohnMacFarlane)
06:04:11 <jchia> tdammers: The offending package is MemoTrie-0.6.4. I retry multiple times after the initial failure. Haddock shows that there are fewer & fewer things to process ("Progress: 1/X"), suggesting that on some retries, additional processes other than MemoTrie, which keeps failing, are getting processed successfully. This means at the initial failure, haddock was not trying its best to process things that have nothing to do with MemoTrie, and instead just immediatel
06:04:35 <tdammers> vOv
06:05:06 <tdammers> could be that this is one of those cases where stack's opinionatedness doesn't work in its favor
06:06:51 <jchia> i think i'll file a github issue for this
06:45:21 <jg> hi all. "typeRep :: forall proxy a. Typeable a => proxy a -> TypeRep" -> i'd like to read up on this "forall proxy" thingy. Any ideas where i could start?
06:46:34 <lyxia> jg: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#explicit-universal-quantification-forall
06:50:20 <merijn> jg: proxy is just a type variable (like a) there
06:50:44 <jg> oh
06:50:53 <jg> thought it was some ghc type magic
06:51:31 <jg> thanks!
06:51:52 <benzrf> jg: to be precise, any polymorphic type implicitly has a `forall' at the beginning
06:51:55 <merijn> jg: The theory on which GHC's implementation of Haskell is built (System F_omega, roughly) explicitly passes type arguments to functions
06:52:10 <benzrf> jg: `map :: forall a b. (a -> b) -> [a] -> [b]'
06:52:39 <merijn> jg: Haskell has no such notion, but you can convert Haskell types to System F by imagining a "forall" to the left of the entire type that introduces all missing type variables, as benzrf is illustrating
06:53:01 <benzrf> what's more interesting is that - if you turn on certain extensions - you can write types like this: `(forall a. a -> a) -> Int -> Int'
06:53:15 <benzrf> this is *different* from `forall a. (a -> a) -> Int -> Int'
06:53:23 <merijn> jg: Where "\x -> ..." introduces a value level function that captures a variable in '...', you can think of forall as kinda being the type level version of that
06:53:23 <jg> yeah, i'm not clear on the distinction there yet
06:53:29 <jg> benzrf
06:53:44 <merijn> jg: Explicitly introducing a scope for type variables
06:54:00 <merijn> jg: The difference is "Who get's to pick 'a'?"
06:54:01 <benzrf> jg: well - a function the second type will let you pass it a function of type `String -> String', or a function of type `Int -> Int', or whatever
06:54:15 <benzrf> jg: a function of the first type *requires* that the argument be polymorphic
06:54:22 <benzrf> so you can only pass id to the first function
06:54:37 <merijn> jg: "forall a . (a -> a) -> Int -> Int" says "You can pick any type 'a' and give me a function 'a -> a' and I'll give you 'Int -> Int'
06:55:17 <merijn> jg: (forall a . a -> a) -> Int -> Int says "If you give me a function that works for any 'a' that *I* (the function) can pick, I'll give you 'Int -> Int'"
06:55:32 <tabaqui> which packate is better for jinja rendering: karver or ginger?
06:55:44 <sander> i have 16 variables that can't have thesame value. is there an easy way to write that in an expression?
06:55:48 <merijn> jg: The RankNTypes extension lets you write types like this in GHC
06:55:58 <tabaqui> *package
06:56:29 <merijn> jg: I have a simple gist illustrating a simple example of something that it "obviously" possible, but cannot be typed in standard haskell: https://gist.github.com/merijn/77e3fa9757658e59b01d
06:57:16 <drninjabatman> hello!
06:57:43 <knupfer> sander: length [vars] == S.size (S.fromList [vars])
06:58:10 <knupfer> sander: Or are you talking about type level?
06:58:28 <greymalkin> merijn: Wouldn't that just be better as a typeclass, Mangleable or some such?
06:58:43 <merijn> greymalkin: What would that typeclass look like?
06:59:17 <merijn> greymalkin: You cannot type that function without RankNTypes, so whether you make a typeclass or not is irrelevant
06:59:43 <merijn> greymalkin: The problem is that when you call "mangle" you *can't* know whether you'll end up having to handle an Int or a Double
06:59:50 <sander> its a math assignment, they cannot hold thesame value, i am typing a/=b, a/=c, a/=d....that gets a bit boring, thought it should be possibel to write is shorter
07:00:12 <merijn> greymalkin: And standard haskell has no way to define the type of a function that "most work on both Int *and* Double"
07:00:17 <merijn> s/most/must
07:01:10 <merijn> greymalkin: As an exercise try and write down the types for this Mangleable class :)
07:01:19 <ongy> sander: the line knupfer wrote should work, if you importet Data.Set as S
07:01:29 <sander> ah ok
07:01:49 <sander> tnx will look there
07:02:49 <ahihi> you can also do  length vars == length (nub vars)  if you don't want the Set
07:03:00 <merijn> ahihi: That has horrible performance, though :)
07:03:01 <ahihi> not sure whether the performance difference will be significant for 16 values
07:03:31 <ertes> quickCheck $ \i j -> i /= j ==> arr ! i /= arr ! j
07:03:52 <knupfer> sander: but note that this forces an Ord constraint, albeit Eq would be sufficient for your problem
07:07:55 <knupfer> How is GHC.TypeLits.SomeNat supposed to work?
07:08:52 <ertes> knupfer: do you know how existentials work in general?
07:09:04 <knupfer> I think yes.
07:09:23 <Big_G> Does any one know why my Haskell program (using Casssava) is taking an order of magnitude longer than my python script to read a CSV file, parse it, and write the parsed format to a file?
07:10:13 <knupfer> Big_G: You'd have to post your program.  Cassava is quite performant.
07:10:16 <ertes> knupfer: in this case the SomeNat constructor carries the knowledge that the type variable is a KnownNat
07:10:29 <Big_G> knupfer, I don't have access to it at the moment 
07:10:49 <Big_G> I basically copied the tutorial code and renamed the values
07:10:57 <ertes> knupfer: and if a type is a KnownNat, it means that it carries a natVal function
07:11:06 <JuanDaugherty> Big_G, fwiw, I loled
07:11:29 <Big_G> JuanDaugherty, Glad I can bring a smile 
07:11:34 <knupfer> ertes: Thanks for the pointer, I'll think about it.
07:12:00 <ertes> knupfer: look at how you might *construct* a SomeNat, i.e. look at the type of the SomeNat constructor
07:12:28 <knupfer> ertes: Yeah, I think I understand now.
07:13:02 <knupfer> ertes: Do you know if it is possible to reify a constraint on a Nat to the value level as a predicate?
07:13:30 <ertes> i'm not sure what that means
07:13:36 <Big_G> Would overloaded strings cause a performance issue?
07:14:23 <jg> merijn: so what is it about default haskell that makes complain about the type of mangle in the first snippet?
07:14:23 <jg>  Does it bind 'a' to 'Int' and then complain that it can be a 'Double' also?
07:14:33 <knupfer> Let's say we've got:   foo :: n <= 5 => Proxy n
07:14:51 <merijn> jg: The *caller* gets to pick 'a'
07:15:14 <knupfer> Now I'd like to have a function which takes foo and returns  (<=5) :: Integer -> Bool
07:15:40 <jg> right, so haskell can't know what 'a' will be?
07:15:51 <merijn> jg: Suppose I have "foo :: Word -> Word", well "instance Num Word", so I can decide to call "mangle foo" and it would typecheck (mangle takes any function 'a -> a' as long as 'a' is an instance of Num)
07:15:52 <ertes> knupfer: foo doesn't exist
07:15:54 <greymalkin> merijn: You mean this? http://pastebin.com/t4qNErBX
07:16:03 <ertes> knupfer: at least not totally
07:16:14 <merijn> jg: Which is obviously bogus, because my "Word -> Word" can never deal with Foo as it defined in that file
07:16:48 <merijn> jg: What you'd *want* to say "give me a function that works *for all possible* a's, as long as those a's are instances of Num"
07:16:48 <knupfer> ertes: Why not?  foo = Proxy
07:16:55 <merijn> jg: Which is what the second case describes
07:17:06 <ertes> knupfer: no instance for …
07:17:18 <ertes> or rather…  couldn't prove types equal
07:17:20 <ertes> in this case
07:17:39 <merijn> greymalkin: But you can only define one implementation that way
07:17:41 <knupfer> huh, on my side it works. I guess I've got too many extensions turned on
07:18:00 <merijn> greymalkin: What if I first want to, say, "add 1" and then "multiply 3" with those values
07:18:10 <ertes> knupfer: oh, nevermind
07:19:01 <merijn> greymalkin: Actually, yours (right now) just crashes when I have"foo :: Int -> Int" and call "mangle foo (Bar 2.0)"
07:20:02 <ertes> knupfer: i think you can use the TestEquality class on the resulting Bool (or Ordering, if you use CmpNat)
07:20:14 <merijn> jg: Since I know Int is an instance of Num and Double is too, then it follows that if I have a function 'f' that works for ALL possible Num instances (i.e. it only uses functions from Num, for example) it's safe to use that on Foo, because regardless of which constructor of Foo I have 'f' will always work :)
07:20:37 <jg> right
07:22:17 <greymalkin> merijn: Ah, it was not clear that this needed to work on doubles with int functions (I have perhaps just not been online long enough to see the original problem)
07:22:20 <merijn> jg: That's the distinction between having the forall completely on the left (the caller of 'mangle' picks 'a') and the forall inside the function type ('mangle' gets to pick *any* 'a', although in this case we know it will only ever pick either Int or Double)
07:22:55 <merijn> greymalkin: Well, there's no actual problem. More of a "what's this extension good for?" question, and this is the simplest example I've been able to construct :)
07:23:02 <greymalkin> What would be the expected behaviour when trying to use a Double -> Double on Ints? Should it round? Should it ceiling?
07:23:07 <greymalkin> Ah.
07:23:10 <jg> thanks merijn, i understand your snippet better now
07:23:19 <merijn> greymalkin: Well, that's why the first one is a type error ;)
07:23:44 <merijn> greymalkin: The second one forces your function to be more polymorphic, that is, passing "Int -> Int" to mangle is a type error
07:24:05 <ertes> knupfer: actually you could just use natVal =)
07:24:19 <merijn> You can test this, "mangle (+1)" will work, but "mangle ((+1) :: Int -> Int)" will not :)
07:24:29 <merijn> This is because
07:24:29 <merijn> :t 1
07:24:32 <lambdabot> Num t => t
07:24:33 <merijn> :t (+1)
07:24:37 <lambdabot> Num a => a -> a
07:25:02 <merijn> Numeric literals are polymorphic and thus that functions works for any Num instance (both Int and Double)
07:25:33 <greymalkin> merijn: But the behaviour still would not be defined with NRankN on either -- what does an Int->Int give when handed a double? The intent cannot be made clear (in that instance, anyway)
07:25:40 <knupfer> ertes: Hm.  No, that doesn't work.  If you'd try to use natVal on `foo`, it would complain that the Nat is ambiguous.
07:25:55 <merijn> greymalkin: With the RankN example it's a type error to pass "Int -> Int" to mangle :)
07:26:14 <ertes> knupfer: i'm not even sure what you're trying to do
07:26:32 <ertes> knupfer: well, sure…  if you use 'foo' you have to instantiate the 'n'
07:26:42 <merijn> greymalkin: Like I said, try it in ghci. "mangle (+1)" will work for both Foo and Bar constructors. But "mangle ((+1) :: Int -> Int)" will, correctly, result in a type error
07:26:57 <greymalkin> Rather than a runtime error. Agreed. 
07:27:28 <knupfer> ertes: I'd like to have a function which takes an Integer and checks wether this Integer would be a valid instantiation of 'n'
07:28:33 <ertes> knupfer: ah, now i see…  as far as i know you can't branch on whether contexts are satisfied, so you need to have the constraint in some computable form
07:29:06 <greymalkin> merijn, jg: I was under the mistaken impression that there was a problem being solved where the RankN was not desirable; forgive my misunderstanding.
07:33:39 <knupfer> ertes: I'll experiment a bit more with type families
07:34:29 <knupfer> ertes: It's quite sad that one can't express laws (besides injectivity) for type families
07:35:24 <knupfer> like commutes, or is idempotent
07:38:33 <c_wraith> If you could express commutes, it seems like it could make type resolution exponential.
07:38:38 <jchia> Question about local hoogle. i'm running one with "stack exec hoogle -- server --local p 8000". On certain searches there are many results and hoogle only gives the top 20 or so. On https://www.haskell.org/hoogle/, there would be a "Show more results" at the bottom but on my local hoogle, there's no such link and I can only filter by package. What do I need to do to enable "Show more results" on my local hoogle?
07:39:22 <jophish> jchia: same version of hoogle?
07:39:34 <jchia> newer
07:39:43 <jchia> i'm using 5.0.1
07:40:28 <knupfer> c_wraith: with type families, you can already let the type checker loop...
07:41:30 <c_wraith> yes, but that's not actually as bad.  It runs out of gas and you say "oops".  An exponential search, on the other hand, makes you say "if it just went a little further it would have found it"
07:43:16 <knupfer> c_wraith: Well, for stuff like computing continued fractions on the type level, you can already spend 30 min without problems in the typechecker
07:44:50 <c_wraith> knupfer: But in all honesty why not just use a type checker plugin?
07:45:08 <c_wraith> knupfer: then you get to specify exactly the properties you want, including the bailout conditions
07:45:44 <daniel-s> :t [1,2,3]
07:45:45 <knupfer> c_wraith: Until now I feared the effort.  There are not many tutorials and the few existing plugins don't seem simple to understand.
07:45:45 <lambdabot> Num t => [t]
07:46:27 <c_wraith> knupfer: did you see the supermonad thing?  I bet the type checker plugin for it is an interesting start.
07:48:45 <knupfer> c_wraith: No, starting to read... Thank you!
07:57:04 <ertes> knupfer: i gave up on doing that stuff in haskell
07:58:25 * hackagebot constraint-classes 0.4.0 - Prelude classes using ConstraintKinds  https://hackage.haskell.org/package/constraint-classes-0.4.0 (guaraqe)
08:17:24 <knupfer> ertes: You switched to agda?
08:18:48 <ertes> knupfer: no, i just don't do it at all…  i use agda, but not for programming
08:20:19 <ertes> knupfer: without dependent types any non-trivial proofs tend to just make the code unbearably complicated and ugly
08:22:16 <knupfer> ertes: I'm recently falling in love with LiquidHaskell, but it doesn't aid in my present situation.
08:24:00 <c_wraith> I'd love liquid haskell if it had a sane interaction with type classes.
08:25:24 <ertes> i'll wait for -XDependentTypes
08:25:39 <exio4> we already have -XDependentKinds
08:25:52 <c_wraith> Thing is, -XDependentTypes isn't going to help for proofs.
08:26:00 <c_wraith> Since Haskell is an inconsistent logic.
08:26:21 <c_wraith> Also, it's still at least 2 years out.
08:26:35 <knupfer> DependentKinds?
08:27:25 <ertes> c_wraith: that's ok
08:27:28 <knupfer> I'd argue that it will help for proofs, but not necessarily produce proofs
08:27:43 <ertes> c_wraith: i'm comfortable with fast/loose reasoning
08:28:26 <ertes> and yes, i know that it's still a long way to go, and until it's there i'll stick with good old testing =)
08:28:59 <knupfer> at least we've got QuickCheck
08:29:03 <ertes> except perhaps for some really simple things like vec lengths
08:30:17 <EvanR> agda is cool, but i like "lightweight dependent types" in haskell
08:30:32 <EvanR> for getting shit done
08:30:38 <voglerr> can I tell ghci to use shorter paths? e.g. :browse Data.Set is not very readable with entries like `containers-0.5.7.1:Data.Set.Base.valid :: Ord a => containers-0.5.7.1:Data.Set.Base.Set a -> Bool`
08:31:09 <knupfer> haskell is more practical
08:31:11 <knupfer> (I'm sounding like a java programmer talking about haskell)
08:31:31 <merijn> Idris? :p
08:31:54 <EvanR> idris is still working on the practical part
08:32:39 <knupfer> Hm, I dislike its strictness, but perhaps I'll learn it a bit.
08:32:59 <ertes> knupfer: i'm totally the equivalent of a java programmer in haskell
08:33:01 <EvanR> agreed
08:33:23 <knupfer> ertes: :)
08:33:25 <EvanR> but you can add laziness annotations
08:33:34 <geekosaur> voglerr, import the module
08:33:44 <ertes> knupfer: i obsess over algebraic design patterns and engage in abstracting to a crazy level =)
08:34:17 <geekosaur> that is, after "import Data.Set.Base" it will at least stop reporting the package name as part of those names
08:34:53 <knupfer> ertes: Design patterns are the disruptive idea for the prospective industry best practices!
08:35:34 <ertes> funny thing:  if you rename Monad to Business, Functor to Factory and 'pure' to 'new', haskell may actually look a lot like java
08:35:52 <knupfer> (I'm so happy that I haven't got a boss who forces java down my throat)
08:36:07 * EvanR goes to get coffee
08:36:17 <EvanR> i need to force java down my throat
08:36:31 <knupfer> Hm.
08:36:37 <voglerr> thanks geekosaur. there's no special syntax for :browse or :t so that I don't need to import first?
08:36:39 <knupfer> That's sad
08:37:09 <ertes> knupfer: honestly i don't think many bosses do that
08:37:23 <ertes> knupfer: your team leader might do it, but your bosses likely doesn't
08:37:35 <ertes> s/bosses/boss/
08:37:44 <EvanR> we need the equivalent to sun to force haskell into university cirricula of the world
08:37:45 <knupfer> ertes: Why do you think so?
08:37:54 <EvanR> or the equivalent of MS to force haskell into high school computer class
08:38:10 <geekosaur> voglerr, no, this is not generated by :browse so :browse has no control over it. and the default is designed for compiled programs, and is fully qualified because of corner cases that are otherwise hard to diagnose
08:38:23 <ertes> knupfer: why would they?  smart bosses know to leave technical decisions to smart engineers
08:38:40 <ertes> knupfer: if your *boss* wants you to use java, you should reconsider working there
08:40:21 <srhb> ertes: I think you probably live in wonderland. :P
08:41:08 <knupfer> Oh, wonderland is very nice. Atm I don't have any boss, so I don't have any trouble :)
08:42:07 <knupfer> EvanR: Not sure if that's a good idea.  Afterwards we'll have backwards compatibility at all costs.
08:42:27 <ertes> srhb: i've seen instances of bosses running to their engineers going: "hey guys, this guy wants to sell me this thing that seems really exciting, what do you think?", but i haven't seen a single instance of a boss running to engineers going: "i want you to use this!"
08:42:42 <EvanR> i think the point where they were freely breaking backwards compatability is over
08:43:17 <EvanR> now they are breaking backwards compatability regardless of who's affected!
08:44:26 <knupfer> EvanR: Is this a contradiction or is my english rusty?
08:44:39 <EvanR> probably
08:44:49 <knupfer> s/or/xor/
08:45:16 <EvanR> ghc already cares about backwards compatability stuff, and at the same time continues to plan future breakage
08:45:44 <EvanR> a potentially interesting issue is how to install old GHCs
08:45:52 <EvanR> if for some reason you really needed to
08:45:58 <knupfer> With nix, that's no problem.
08:46:04 <EvanR> is it?
08:46:08 <knupfer> Yes
08:46:30 <EvanR> you could restore an old ghc you already had right
08:47:07 <knupfer> In all my projects, I put a default.nix which also specifies the commit of nixpkgs, so I've always compiling environment at every commit of my library
08:47:24 <ertes> EvanR: i test my code on GHC 7.10.3 with: nix-build shell.nix --argstr compiler ghc7103
08:47:34 <ClaudiusMaximus> if you go back far enough, old ghc needs old perl and old binutils, which quickly gets horribly messy without using a vm
08:47:34 <ertes> similar with 7.8 and GHCJS
08:47:44 <EvanR> interesting
08:47:50 <ertes> without nix i'd most likely just not bother doing that test
08:48:00 <knupfer> ClaudiusMaximus: That's also no problem if you specify the nixpkgs commit.
08:48:25 <ClaudiusMaximus> good to know, though i think this might be before nixpkgs existed...
08:49:05 <srhb> EvanR: I do the same, plus I have some shell functions set up for quickly giving me a test environment. For instance, gwp -c 784 aeson bytestring gives me a ghc 7.8.4 with aeson and bytestring available. It still feels like magic compared to before Nix. :P
08:49:52 <EvanR> in that case, awesome, i need to set this up
08:50:15 <voglerr> :set +t in ghci seems pretty useless for things without a Show instance. can I get tell ghci to only print if there is one and otherwise output the type?
08:50:20 <knupfer> ClaudiusMaximus: At least ghc 6.10.2 is currently in nixpkgs. If you take an old commit, you'll probably find even older versions
08:50:45 <srhb> knupfer: Though the Haskell infrastructure will also change, making it a bit less reliable.
08:50:46 <jophish> Are there any statistics on the current userbase of ghc versions?
08:51:06 <srhb> knupfer: (As in, no haskellng in nixpkgs)
08:51:13 <ertes> if you go to an older nixpkgs commit, you're also going to an older hackage snapshot
08:51:15 <ertes> so no problem there
08:51:28 <ertes> oh, yeah…  there was a time before haskellng =)
08:51:31 <srhb> Yes.. :)
08:51:44 <ertes> haskellng feels a bit like the big bang
08:51:49 <srhb> But that's the only real caveat I know of.
08:52:21 <daniel-s> Hi. If I use "cabal sandbox init" then "cabal install something" is that something now installed in my cwd somewhere and automatically available in I'm running code in the current directory?
08:52:42 <merijn> daniel-s: It gets installed into the sandbox directory
08:52:43 <christiansen> daniel-s: it ends up in .cabal-sandbox/bin
08:52:48 <ertes> daniel-s: yeah, but only to things you run via 'cabal exec' or 'cabal repl'
08:53:10 <knupfer> srhb: But normally one doesn't transition to an older ghc.  So if you start a project and can build your project at that moment with a checkout of nixpkgs, it'll build in all eternity.
08:53:29 * dcoutts notes that the cabal new-build stuff will do exactly what daniel-s suggests, without needing further commands (and without needing explicit sandbox commands either)
08:53:41 <ertes> knupfer: i generally go back at least one minor version of GHC
08:53:49 <ertes> so currently 7.10
08:54:33 <jg> so i'm reading the scrap you boilerplate paper and trying to understand how haskell actually does the type matching with Typeable (code: http://bit.ly/2e2Owuj). tried doing a 'showsTypeRep (typeOf genCom) ""' but that gives only an unhelpful "Company" string. How can i get to the actual Typeable representation of that type?
08:55:26 <daniel-s> OK. Thanks.
08:55:29 <knupfer> ertes: Yeah, my point was more related to breaking changes by ghc not beeing that breaking if you've got a reproducible build environment.
08:55:38 <daniel-s> I'm new to haskell and have no real idea how to use cabal or hackage.
08:55:55 <knupfer> ergo I'm strongly in favor of breaking changes which removes warts
08:56:01 <daniel-s> IIRC it's not mentioned here http://learnyouahaskell.com/chapters
08:56:13 <knupfer> daniel-s: both, cabal uses hackage
08:56:46 <geekosaur> jg, internally there is a unique Fingerprint associated with it, as well as full package/module qualification that the Show instance doesn't show (I think for historical reasons)
08:56:50 <knupfer> daniel-s: The more common question would be: Shall I use cabal, stack or nix?
08:57:10 <dcoutts> daniel-s: so currently it's not quite as convenient as what you're hoping for, in that the packages you install into the sandbox are only available via other cabal commands, e.g. building other packages or running cabal repl or cabal exec.
08:57:44 <dcoutts> daniel-s: but the answer is yes it is installed in the sandbox, and yes you can use it for further things.
08:57:57 <knupfer> daniel-s: Oh sorry, I didn't see the word `how` in your question.
08:58:25 <ertes> somehow i never found cabal-install sandboxes that bad…  the new-build stuff sounds nice, but i really don't know why people are so negative about the *current* cabal-install
08:58:36 <daniel-s> OK. Thanks dcoutts. It's because I'm familiar with python's virtualenv, but sandbox isn't /exactly/ the same.
08:58:41 <drninjab`> hello
08:58:47 <knupfer> hello
08:58:51 <drninjab`> is it possible to expose pattern synonyms?
08:58:57 <drninjab`> like from a module
08:59:01 <knupfer> export?
08:59:21 <ertes> drninjab`: i think you can use this syntax in the export list:  pattern Pat
08:59:22 <ozgura> hi! does split-objs not work on mac os currently? I get "on the commandline: warning: ignoring -fsplit-objs"
08:59:35 <dcoutts> daniel-s: for what it's worth, we're going to be making cabal more like that so you can just run ghc/ghci from a project dir and get the env of that project. But the current cabal sandbox isn't quite that friendly yet.
08:59:50 <ozgura> I pass --enable-split-objs to cabal-install 
09:00:12 <drninjab`> ertes: that worked thnx!
09:00:18 <knupfer> drninjab`: https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/syntax-extns.html
09:00:22 * geekosaur actually has to figure out how to deal with the TypeRep thing, since xmonad serializes a TypeRep-keyed Map across instances and it's currently unsafe at best --- but needs to work back to 7.6.3 (thanks debian oldstable)
09:00:30 <ph88> anyone know where the error on line 26 is coming from? https://paste.fedoraproject.org/455059/76806376/   maybe i'm doing something wrong with <$> ??
09:01:46 <nitrix> Hi. Is there a nice way to build a system similar to pointers to pointers other than using IORef(IORef a) ? It's for an optimization/memoization technique, all the Weak stuff is already figured out.
09:02:41 <ertes> nitrix: if IORef . IORef is not good, what properties do you want?
09:03:01 <ertes> i.e. why is IORef . IORef not good?
09:03:27 <nitrix> ertes: One of the limitation is that it requires a value. Making it optional leads to even uglier IORef(Maybe (IORef a)).
09:03:59 <ertes> nitrix: well, if the inner IORef is optional, then the Maybe is rightfully there
09:05:01 <nitrix> Surely there's a more general concept/alternative to nesting two IORefs to build my in-memory relational system.
09:05:38 <ertes> nitrix: perhaps with more information…  why do you nest two IORefs?
09:05:58 <s4ke> hi. is here anyone that knows specifics about accelerate?
09:07:57 <EvanR> IORef (Maybe (IORef (Maybe a)))
09:08:07 <nitrix> ertes: You'd actually be the right person for this. Funnily enough, it resembles a lot FRP.
09:08:10 <EvanR> IORef `o` Maybe `o` IORef `o` Maybe
09:08:21 <EvanR> at least in clojure, this kind of thing is discouraged heavily
09:08:25 <johnw> at that point, make IORef (Maybe a) its own type, with a library around it
09:08:32 <johnw> IOMaybeRef a
09:09:02 <chindy> Anyone know why emacs says : "Symbol's value as variable is void: interactive-haskell-mode-map"
09:09:05 <nitrix> johnw: It's actually part of what I was wondering; albeit I should also use MVar/TVar at this point, for other benefits.
09:09:12 <ertes> well, it's a mutable variable…  and it's optional…  so Maybe
09:09:14 <ertes> MVar?
09:09:19 <johnw> nitrix: well, then just use TMVar
09:09:53 <EvanR> TMVars with TMVars in them?
09:10:05 <nitrix> It's probably what I'll do, except that I can't get away with having two levels of indirections.
09:10:36 <nitrix> Why? Because I'm trying to achieve some memoization, where you pointer gets "upgraded" to pointing to the value in some storage area.
09:10:56 <nitrix> Essentially, the first usage is O(log n), but then it gets upgraded and future usages are O(1).
09:11:15 <EvanR> sort of manual lazy evaluation
09:11:25 <Xnuk> ph88: Is `ExtendedIdentifier` Functor?
09:12:08 <nitrix> EvanR: It's very close to how memoization works in GHC, except it's in user-space and more awkward to implement.
09:12:21 <EvanR> memoization? or lazy evaluation
09:12:29 <EvanR> i dont think ghc does memoization
09:12:58 <EvanR> otoh memocombinators is a library which apparently simplifies memoization in user space
09:13:17 <nitrix> EvanR: Of course it does. It shares thunks and thunks are only evaluated once. It's a form of memoization.
09:13:24 <geekosaur> EvanR, I think nitrix is talking about the usual encoding of memoization via laziness
09:13:25 <EvanR> nah...
09:13:27 <ertes> it certainly doesn't memoisation is not a compiler thing
09:13:46 <tsahyt> what are some C binding libraries that have been built with c2hs? I need some examples to look through
09:13:47 <ertes> i swallowed my usual ellipses there
09:14:07 <EvanR> saving the output functions, keyed by inputs
09:14:08 <geekosaur> they are doing explicitly what one usually relies on Haskell's laziness to do
09:14:14 <EvanR> right
09:14:28 <nitrix> ertes: geekosaur Okay, well that's interesting, but I'll keep it for the next discussion to not get side-tracked.
09:14:32 <nitrix> EvanR: ^
09:14:50 <nitrix> So, I'll say it's some manual lazy evaluation, presumably.
09:14:51 <geekosaur> I'm a little surprised this needed to be clarified, actually :/
09:14:54 <geekosaur> yeh
09:15:12 <EvanR> it didnt, were all talking about the same thing
09:15:25 <EvanR> nitrix: once again it seems like a forkThunk could be useful
09:15:29 <ertes> i've never actually needed memoisation…  when is it useful?
09:15:30 <nitrix> geekosaur: It's just that the line is blurry because of what I'm using this system for later, but it's irrelevant for now.
09:16:58 <EvanR> then you could exploit laziness 
09:17:18 <EvanR> but using weak pointers, sometimes forget to save memory
09:17:25 <nitrix> EvanR: geekosaur But yeah, the idea is you create a reference to something (it's a relational system), which creates a unique identifier, or if you're loading a relation from the disk/network, then it can be pure because you immediatly have that identifier (perfect for Aeson's serialization).
09:18:43 <nitrix> EvanR: geekosaur Then on the first use, that identifier is used to lookup a storage area which contains the 1000 most recent values (some kind of cache/memo table).
09:19:32 <EvanR> on first use, and then something later unloads it?
09:19:39 <nitrix> EvanR: geekosaur Then, your "reference", gets its IORef upgraded to point to that value. The only way that I know how to do this is via two nested IORef.
09:19:57 <nitrix> EvanR: Yeah, they're actually Weak (IORef ) ... 
09:20:13 <nitrix> EvanR: The table is free to evict any value at any time, which would cause reloading it later on when needed.
09:20:15 <EvanR> well, you could use just Weak a, no IORefs at all
09:20:31 <nitrix> EvanR: I think need IORef on the outer.
09:20:33 <EvanR> the loading would happen in an unsafePerformIO
09:20:53 <nitrix> EvanR: Otherwise you cannot "upgrade" your reference to the final value. You'll keep doing O(log n) lookups.
09:21:20 <EvanR> isnt Weak a "a reference" ?
09:21:41 <nitrix> EvanR: Yeah but you cannot change its value :/
09:21:51 <EvanR> are you trying to change a value?
09:21:58 <nitrix> You cannot make a weak point to something again once its lost what its pointing at.
09:21:59 <EvanR> or just instantiate that value on demand
09:22:01 <nitrix> EvanR: Yes.
09:22:08 <nitrix> EvanR: https://github.com/nitrix/lspace/blob/master/src/Link.hs
09:22:19 <EvanR> like, it used to be 3 and now its 4 ?
09:22:39 <nitrix> EvanR: Don't mind the terrible attempt there, the interface is still representative of what I'm trying to achieve.
09:22:40 <EvanR> thatd be more like a cell
09:22:45 <nitrix> It is a cell :)
09:22:57 <EvanR> yurg
09:23:09 <EvanR> also called "slots" in some languages
09:23:12 <nitrix> But it's serializable and loaded/unloaded when needed.
09:23:41 <nitrix> With O(1) complexity AND relational.
09:23:52 <nitrix> So the dependencies are loaded lazyly as well when needed.
09:24:25 <EvanR> all that mutation is going to give ghc a hangover
09:25:38 <EvanR> so are you serializing all these objects separately?
09:25:55 <nitrix> Yeah.
09:26:12 <EvanR> are you worried about potential corruption of the images
09:26:37 <nitrix> As in, some gets saved and the application crashed?
09:26:46 <EvanR> when you have 1 large "save file" and you just dump it, one missing letter means the save doesnt load
09:26:55 <EvanR> now you have 1 small files
09:26:59 <EvanR> er N small
09:27:18 <EvanR> yeah a crash during a save
09:27:36 <nitrix> It's a little odd because you're saving and loading all the time.
09:27:42 <nitrix> But I have this concept of "Context".
09:27:54 <nitrix> Which is, all those little cells belongs to a given context.
09:28:09 <nitrix> I can duplicate the contexts and have actual backups or "saves".
09:28:23 <EvanR> ok
09:28:24 <nitrix> But otherwise, it just load/unload/read/write to disk/network continuously.
09:28:49 <nitrix> It's for a multiplayer game.
09:29:24 <EvanR> is it all concurrent
09:29:34 <nitrix> Nope. Hence why I'm rewriting it :P
09:29:43 <nitrix> TVar or MVar probably.
09:30:06 <nitrix> But the double IORef thing to do the reference upgrades or whatever you wanna call it, I cannot be the first one doing this...
09:30:27 <nitrix> That has to be a concept that exist somewhere in the Haskell ecosystem with someone that made a library around it.
09:30:32 <EvanR> i have not heard of anyone doing this
09:30:46 <nitrix> Because everyone hate cells :( ?
09:30:48 <EvanR> ive heard of NOT wanting to do it though
09:31:24 <EvanR> specifically the nested ones, so you have hate^2
09:31:32 <nitrix> EvanR: The original reason that lead to this was avoiding silly Identifiers all over my game with hundreds of O(log n) lookup tables.
09:31:45 <zq> is it possible to split a slice into one immutable and one mutable slices without having to write my own unsafe impl?
09:31:57 <exio4> I normally use SQLite when I want info to avoid crashing and fucking up
09:32:01 <nitrix> EvanR: If you're storing some Identifier, might as well store the reference directly.
09:32:05 <EvanR> what makes your new plan O(1) ?
09:32:29 <nitrix> EvanR: Because foo :: Link Player gives me O(1) readLink and modifyLink.
09:33:12 <nitrix> I can now move the player, rotate him, change his inventory, etc, very quickly. No need to look him up in an entity table all the time.
09:33:14 <EvanR> ok, because youre passing cells around
09:33:17 <nitrix> Nor, to draw him independently.
09:33:52 <EvanR> im planning to use lookup tables, but with Vector if the default structure is too slow
09:34:04 <EvanR> C++ style
09:34:12 <nitrix> I know it smells a lot like C, but it's actually very nice to work with. I just need to refine the idea.
09:34:21 <nitrix> You can even compose the Links together.
09:34:28 <EvanR> how?
09:34:31 <nitrix> To get like, a player's guild or something. Kinda like lenses.
09:34:42 <ertes> zq: what's a slice?  which library are you talking about?
09:34:56 <EvanR> Link -> Link -> Link ?
09:35:26 <nitrix> EvanR: There's not a function for it yet, but it's definitely do-able, I'm seeing the pattern arise very often in my code already.
09:36:04 <EvanR> i see GraphQL in your future
09:37:30 <ongy> their page actually looks nice
09:38:16 <nicknitewolf> Is haskell easy to learn?
09:38:23 <EvanR> ongy: i want a DSL for generating pages like that one
09:38:50 <nitrix> EvanR: Very close. I just want it to have a lens-y feel to it; not actually writing queries.
09:38:54 <ertes> nicknitewolf: it depends a lot on the learner actually, particularly whether they have prior programming experience
09:39:16 <nicknitewolf> Hmm I know java and partially C
09:39:31 <exio4> it might make other languages harder to learn, I have had issues learning PHP lately
09:39:41 <ertes> nicknitewolf: you may have to unlearn some of the concepts you know from java and C then
09:39:46 <ongy> that may be on the side of PHP though
09:39:55 <nicknitewolf> wow ok
09:40:01 <exio4> it's just that I need to bash PHP, it's quite annoying to work with :p 
09:40:18 <EvanR> nitrix: so just reaching through a graph path and updating fields or retrieving them
09:40:25 <EvanR> "the power of the dot"
09:40:26 <ertes> nicknitewolf: but i wouldn't call it difficult, if you're open to the idea that programming can look very different from what you have learned it to be
09:41:07 <nicknitewolf> Hmm interesting. I'll take a look at some guides. Thanks
09:41:10 <EvanR> nitrix: i am told by people who work with languages where this is commonplace that its really bad, spooky action at a distance
09:41:26 <nitrix> EvanR: Yes. Haskell, as great as it is, is missing this very badly. Lenses are cool, but they don't do relational stuff. If I can add relations, it makes developing games in Haskell a breeze.
09:41:26 <EvanR> they have a hard time figuring out where stuff is being modified from
09:41:33 <ph88> anyone know where the error on line 26 is coming from? https://paste.fedoraproject.org/455059/76806376/   maybe i'm doing something wrong with <$> ??
09:41:42 <nitrix> EvanR: I know how you feel.
09:41:49 <ertes> nitrix: a breeze? =)
09:42:04 <nitrix> EvanR: ertes Which is why, I started to look at FRP.
09:42:14 <ph88^> Xnuk, sorry i missed your response .. i'm not sure if it's Functor ..
09:42:21 <nitrix> I felt like it did the same "spooky action as a distance", but elegantly.
09:42:26 <EvanR> nitrix: the "FRP" mentality where you specify all this at the end point... sounds like it would make that nicer, but not sure
09:42:36 <ertes> well, FRP solves only one single piece of the problem
09:43:17 <ph88^> data Foo = Foo String  isn't this a functor by default?
09:43:32 <ertes> game dev is actually really difficult, haskell or not
09:43:37 <nitrix> ph88^: You could derive it.
09:43:47 <EvanR> Foo :: *, but functors need to be * -> *
09:43:51 <nitrix> ph88^: But you'll need a parameter.
09:44:57 <ph88^> i thought  Foo was first * and String was second *
09:45:30 <geekosaur> that's at data level
09:45:35 <geekosaur> at type level there is only Foo
09:45:42 <ph88^> i see ^^
09:45:55 <nitrix> ertes: Game dev is the only reason why I'm "bending the rules" of Haskell. FRP tried one approach; I want to take another approach with cells, but rafine the idea so that it doesn't appear magical. Bring things up at the type level for example.
09:45:56 <ph88^> i will try to rewrite that bit of code .. i can also change the pattern matching
09:46:32 <ertes> nitrix: i hope your approach is orthogonal to FRP, so we can use *both* =)
09:46:51 <ertes> nitrix: also have a look at reflex…  it may have already done what you're trying to do
09:47:00 <nitrix> ertes: Isn't FRP very close to what I described though?
09:47:13 <nitrix> ertes: Minor the lazy-loading and serialization.
09:47:16 <ph88^> changed it to this:  where x (IExtended (EI a)) = IExtended $ EI $ "Hello " ++ a
09:47:35 <nitrix> I'm so conflicted. Maybe I need to give wires another shot.
09:47:35 <ertes> nitrix: not really…  FRP is about events and values that change over time
09:47:54 <ertes> lazy loading is an orthogonal matter
09:47:58 <nitrix> ertes: Sounds very much like cells. Isn't FRP just Excell :P
09:48:01 <nitrix> *teases*
09:48:06 <ertes> hehe
09:48:16 <ertes> behaviours actually *are* like excel
09:48:18 * geekosaur mutters something about löb
09:49:53 <nitrix> ertes: The only difference is this notion of events. I somehow would only want the behaviors it seems.
09:50:56 <ertes> nitrix: i really think reflex has already solved your problem, or at least part of it
09:51:05 <ertes> *and* it gives you behaviours, too
09:51:06 <ertes> uhm
09:51:09 <ertes> i mean events
09:51:15 <nitrix> Now I'm wondering if I cannot just implement my "reference" system as a simple function composition.
09:51:50 <nitrix> It'd just compose, compose, compose, and eventually apply all of that on a value that's obtained.
09:51:59 <nitrix> The obtention is O(log n), the applications are all O(1).
09:53:18 <nitrix> You somehow give the results to the next frame and keep going...
09:54:22 <nitrix> Suddently it doesn't feel as imperative anymore, because you have to explicitly pass the old value and new value (with the added composition).
09:54:50 <nitrix> Am I just re-inventing higher-order functions!? D:
09:55:17 <hexagoxel> is it at all possible that some operation inside STM.atomically blocks while being masked? I just worked around some curious case of a blocking killThread.
09:55:46 <hexagoxel> specific operation was readTChan
10:00:26 <EvanR> nitrix: before figuring out the answer, you need to figure out the question!
10:00:36 <nitrix> ertes: "higher-order Functional Reactive Programming system"
10:00:51 <EvanR> higher order frp is yet another thing already defined
10:01:00 <ertes> nitrix: FRP is already higher order =)
10:01:26 <nitrix> But they make it sound like what I'm doing, without mentioning FRP!
10:01:28 <nitrix> >:3
10:01:52 <EvanR> behaviors as ertes describes is not just like cells, because you cant issue a command to update them, they change only via their definition
10:02:22 <EvanR> and it would be nice if they could animate continuously with time
10:02:31 <EvanR> though they dont in wires or reflex
10:02:39 <ertes> FRP is actually a pure concept…  things don't act like changing mutable variables, but more like functions of time
10:03:11 <nitrix> I don't need time. For real.
10:03:21 <EvanR> i like animations in video games ;)
10:03:22 <nitrix> I just need things to behave like functions, which is super odd to say.
10:03:31 <alercah> try functions
10:03:51 <ertes> EvanR: well, both of them are FRP, so you have the choice to forget the discreteness at any time =)
10:04:15 <EvanR> im not so sure about that, but well leave it for later in #haskell-game
10:04:55 <nitrix> So, all this rubber ducking; I wonder if I'm not missing a fundamental thing about my idea. It looks like I could just leverage first-class functions and higher-order functions to achieve my goal.
10:05:08 <EvanR> thats the dream
10:05:26 <EvanR> functional programming really continues to surprise me where it works
10:05:43 <nitrix> Excepted, I'd need some kind of monad for the statefulness of modifying things.
10:05:57 <EvanR> well, now youve left the building ;)
10:06:02 <nitrix> e.g. not having   foo :: Cell a -> Blah -> Cell a, returning modified cells is awkward.
10:06:38 <EvanR> commands to modify cells is really a thorn in the side of FP
10:07:01 <ertes> nitrix: i'd really like to help you, but honestly i don't even understand what problem you're solving
10:07:11 <nitrix> EvanR: Do you consider State as bad as cells though?
10:07:29 <EvanR> yeah, its 1 "global" cell
10:07:37 <EvanR> for an isolated algorithm though that could be fine
10:07:47 <zq> ertes: sorry. wrong language, wrong channel.
10:08:22 <EvanR> in which case STRefs might be better because you can have more than 1
10:08:59 <EvanR> thats a tangent though
10:09:19 <nitrix> Right. My goal is to do something akind to STRefs but with serialization and lazy loading at the runST ends.
10:09:26 <nitrix> So not pure o.<
10:09:32 <nitrix> It'd be in IO.
10:09:38 <EvanR> yes, you really need to find a way to move all your backend machinery out of the language
10:09:50 <ertes> nitrix: something like a promise?
10:09:59 <ertes> or a future?  or what's the word of the week?
10:10:02 <EvanR> a promise ends up with 1 value
10:10:11 <EvanR> but nitrix wants to modify the cell
10:10:42 <ertes> at this point a "cell" sounds to me like a mutable variable that may cause some side effect when read
10:10:54 <EvanR> the only side effects are possibly loading from disk
10:11:01 <EvanR> a big one but it could be worse
10:11:28 <EvanR> the main effect is mutation
10:11:53 <nitrix> ertes: The only side effect is reading from disk, but I could actually have that done strictly prior, like in runFoo, then past that point, you'd have the value for sure.
10:11:58 <ertes> but mutation doesn't involve putting an actual value in, but a new loader action?
10:12:19 <EvanR> it does
10:12:33 <EvanR> modify :: Cell a -> a -> IO ()
10:12:42 <quchen_> There’s also the trick of running an IO action via a finalizer.
10:12:49 <quchen_> Not sure whether that helps here.
10:12:53 <ertes> i'm picturing all of this as:  type Cell a = IORef (Either (IO a) a)
10:13:26 <nitrix> ertes: It's actually very close to that.
10:13:33 <EvanR> ertes: it can also "decide" to unload and save to disk
10:13:44 <ertes> ok, add a Weak to the mix
10:13:55 <nitrix> ertes: Minor that the value lives somewhere else in my implementation is you actually had a (Weak a) instead.
10:14:06 <nitrix> But yeah.
10:14:21 <nitrix> You got the idea right.
10:15:05 <ertes> i see…  but the first question that immediately comes up in my mind is:  does the value have to be changable?
10:15:26 <ertes> as a *user* of such a type i can't think of a scenario where i'd want to change it
10:15:51 <EvanR> a ship rotates, opens pod bay doors, etc
10:16:42 <nitrix> modifyCell player (playerPosition %~ moveDirection North)
10:16:45 <ertes> ah, now i get it!  i don't understand the problem! =)
10:17:36 <ertes> more seriously:  i think i'm starting to understand…  now i'm picturing a game world that is so huge that you wouldn't want to hold it in memory
10:17:51 <nitrix> ertes: That's exactly the constraint I'm working with.
10:18:04 <nitrix> And not only that, I have SO many relations, they cannot fit in memory.
10:18:37 <Tuplanolla> I'm picturing a game world that is so huge that you wouldn't want to play the game.
10:18:50 <nitrix> Tuplanolla: Like Dward Fortress?
10:19:00 <nitrix> Or Minecraft?
10:19:02 <geekosaur> I was thinking minecraft
10:19:30 <maerwald> isn't there this new sci-fi game where you have a 0,0001% chance to meet another player?
10:19:51 <EvanR> sounds pleasant
10:20:07 <zomg> maerwald: you might be thinking of No Man's Sky... and they basically just lied about that aspect of the game, it doesn't have any multiplayer to it at all :P
10:20:09 <geekosaur> or for that matter phantasia from the late 80s had an infinite grid in much the same way minecraft does
10:20:40 <Tuplanolla> If you want to guarantee players getting lost, just make the metric of your space hyperbolic.
10:20:41 <ertes> an MMO where you can actually enjoy the atmosphere without being attacked by another player?  sounds nice
10:20:59 <nitrix> My game's in space. It's literally infinite. The infinite is easy, because of spatial partitioning, the complicated part are extremely large complicated ships.
10:21:07 <maerwald> zomg: yeah, could be it
10:21:53 <nitrix> Hence why I worked on a O(1) biconnected component algorithm.
10:22:23 <ertes> it's weird…  stuff gets larger and larger and more difficult, but at some point you cross that threshold to infinity and suddenly things get easy again
10:22:40 <nitrix> Which I don't think has ever been done before. Best cases I've seen were O(|V| + |E|), but I have the benefit of having a grid to work with.
10:22:54 <nitrix> The edges are predictable. And I did use pointer hackery, again, nested IORefs.
10:23:24 <ertes> nitrix: i'm wondering whether what you really need is a data structure that can swap out parts of itself
10:23:44 <nitrix> ertes: Like lenses?
10:23:44 <ertes> the whole mutable variable thing seems suspicious to me
10:24:19 <EvanR> ertes: nitrix had a structure where nodes had IDs, but he said it was to slow, O(logn)
10:24:33 <ertes> nitrix: you could use lenses with it, but that's not the point…  i'm thinking of something like a k-d-tree, that can have branches of itself swapped out
10:25:01 <nitrix> ertes: The thing is, lets say it's explicit, you take a cell and return a modified new cell (immutable), then you make that into a monad because it's painful to pass it explicitly, then you connect an IO at the runCellular, it's exactly the same.
10:25:06 <ertes> O(log n) doesn't sound slow to me, particularly since you traverse only once, do your job and only then "come back"
10:25:29 <nitrix> ertes: There's a ridiculous amount of relations in a game.
10:26:30 <ertes> should we move this to #haskell-game?
10:27:23 <nitrix> In my case, cells are in rooms, rooms have pressure, oxygen, etc, the cells are also attached to form ships, your position and speed is relative to the ship, the ship's position relative to other ships. You have players in alliances groups, maybe some machinery with electrical systems, pipes, things connects, have effects...
10:27:31 <nitrix> There's tons, tons of relations :P
10:27:37 <nitrix> Nah, it's alright, I'll stop here.
10:29:53 <EvanR> yeah ive usually imagined a large game as being a relational database, "huge" is probably not a good qualifier in that case since... even a large game is not a huge database by database standards of huge
10:30:30 <EvanR> a terabyte of artwork and 3d models maybe!
10:31:01 <davean> EvanR: That seems pretty small
10:31:21 <EvanR> im out of date as far as that goes
10:33:49 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
10:33:49 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
10:33:49 --- names: list (clog_ bengt_ JagaJaga_ robotroll V3 Uakh sathish_haskell sdothum tomphp MarcelineVQ wirrbel li4ick_ Destol crobbins Swizec redmq Rodya_ bgamari jmnk connrs Lokathor LKoen fcpga_te Bez_ anemecek mikel traunio mmachenry MindlessDrone slackircbot herzmeister caconym sns sdlnv psychicist__ noddy eh_eff_ fnurglewitz moongazer e14 raichoo acowley skeet70 refold quchen_ modlin mizu_no_oto_work Sixmsj bkonkle zipper kosorith nicknitewolf cdg_ isovector govg jathan)
10:33:49 --- names: list (path[l] Amun_Ra _cyril_ eklavya rgrinberg dhil eizua argent0 jrajav animated chindy xuxu stevenspasbo ph88^ Digit Sonolin trism chreekat heurist__ Jackneill_ andrew Jeanne-Kamikaze jmelesky gawen sonvh eliasr leat2 JeanCarloMachado posco khisanth__ sssilver simukis_ prohobo joneshf-laptop ryoia amatecha caasih spicydonuts Apocalisp razi1 S11001001 zrl vikram__________ JoshS runeks wizonesolutions chbatey angular_mike_ Procrat zph mno2 w4and0er96 igniting)
10:33:49 --- names: list (bitonic tjpeden hackebeilchen reem_ elrikdante henriquev dwarders TabAtkins bennofs LordDeath senthil derdon MoALTz CaptainLex carlomagno sellout- plutoniix hariel umib0zu paul0_ samrat glguy king_jah Cetusx Bigcheese cpennington knupfer mac10688 Cale kurnevsky irrequietus Princess17b29a newhoggy Voldenet ashishnegi danthemyth cereal_killer_ ype mvr_ mattrepl meditans magneticduck goodboytyler takuan mpw ChristopherBurg martinbjeldbak Hermodoros takle)
10:33:49 --- names: list (groscoe copy` vlatkoB_ locallycompact doomlord flonk zeroed `^_^v Squarism ristos sepp2k zort daniel-s ziocroc shirt drazil nakal mattyw rcschm_ ThreeOfEight mzf dh vinnie92_ CurryWurst tjayanth vili_ fabiopbx shock_ fractalcat ahihi theelous3 watabou hive-mind sebastian-w jchia a3Dman Maxdamantus Shoue ljhms kritzcreek dsub joncol geekosaur fengshaun niko marr flatmap13 LuckyRawApe xinming_ sooheon Hafydd grouzen ertes benl23 inad922 mostalive Sorella)
10:33:49 --- names: list (DexterLB kurnevsky2 romich_ Insanity_ fiddlerwoaroof yqt ccomb augur thc202 HanlonsRazor Taylor dyreshark alunduil orion thunderrd babu SparkySparkyBoom zerotech harfangk vqrs Guest43144 jle` paolino ali_bush Mokosha Jesin danvet s4kashya2 pavonia BartAdv hamishmack _sjs Vektorweg1 daey IlanGodik slomo Kuros` otto_s UnlikeSuika OnkelTem StoneToad desophos Ravana Ninja3047 howdoi hexagoxel lspitzner exferenceBot latk ab9rf shans_ alx741 hucksy moop darkbolt)
10:33:49 --- names: list (Immune_ aloiscochard emiliocobos_ tarcwynne_ iphy caw dmoon1221__ yminsky steshaw NeverDie phileas okuu zugz_ Moto-chan treehaqr dsantiago markus1199 theDon rkazak ecr hiptobecubic mitchty qguv cheater LnL grumble teh[m] IndigoTiger yusukesuzuki ploop RouxTheDay jokleinn diamaths[m] sz0 s4kashya Starfire_ sinopeus JuanDaugherty heyj abbe xocolatl zq michalrus M41px[m] heyalex[m] monomon[m] leadingthenet[m] MartialJob[m] Oat[m] xxblx[m] Faleidel[m])
10:33:49 --- names: list (sudoreboot[m] vise890[m] comexk[m] mith[m] ShibaInu[m] rewzn[m] chujji[m] cbHXBY1D[m] tiltec[m] M60452[m] tagada[m] noam[m] SeriousBug[m] prose[m] jacs[m] M-krsiehl ostuda_lidstva[m knightking[m] rdesfo[m] M-Illandan fxrs[m] todd_killings[m] zizai[m] sssilver[m] schum[m] Soif[m] pkmx[m] M-mistake undu[m] unclechu M-schmittlauch M-wamaral aminb Profpatsch[m] M41971[m] M-Magnap helloworld1[m] M-david toogood2bgood M-Shrike SShrike fazil[m] drasich[m] radix)
10:33:49 --- names: list (davidar M-berdario brian[m] srenatus[m] bb010g[m] M62844[m] qryantm jay72 Orion3k xplat dedgrant revprez_ rossberg pikhq yulax folsen josephle cods Koyaanis bogdanteleaga ddiaz gta3 mspo voter101 Matajon drdo sqrt2 cchalmers jorj KeelOfSteel ClaudiusMaximus srhb cdidd athaller nilsi magicman comboy Sose Guest28451 pgiarrusso tabaqui Zialus gridaphobe magthe TimWolla hackagebot dud free_beard juhp ysshiu Bengi kvda piyush-kurur Willis miscyb haasn sleblanc)
10:33:49 --- names: list (SAL9000 jzl MrWoohoo rjeli boothead inr bydo atk Tesseraction kaffepanna albel727 pikajude s4kashya1 amuck lordcirth leothrix texasmynsted Rarrikins mimi_vx eell thewormkill ipuustin Dunearhp sigma9141 rootnode abrar Sgeo dcoutts Pent danpalmer gienah ethercrow ericsagnes otulp zaquest spoonm k4rtik latro`a_ m0rphism flxw noxd burp_ supki dcoutts_ catsup falafel a6a3uh arrdem bluepixel ludat nont_ mach jbalint Wizek Xandaros ongy Tharbakim dredozubov)
10:33:49 --- names: list (dredozubov_ dmwit mauke dpower s4kashya_ _ashbreeze_ mico_the_mailman norotartagen jtcs phaskell-2 phaskell-1 phaskell atomi kolmodin siloxid nyuszika7h tristanp orcus cschneid ircbrowse max-m dzack1 stass flux cpape Autumndreams mudfog- donwilliam omilu dxld acro Xnuk grol PlasmaStar tych0 niluje dualboot predkambrij chirpsalot qz newsham mell shutdown_-h_now bshd przembot happy0 kennyp boj davean topi smithstonw masquerade notdan aatxe Levex edran ycheng)
10:33:49 --- names: list (johnstein keb ndeine- gothos hausdorff mk-fg Natch urh_ Tehnix`_ Laney rootmos phz_ kishar_ Gothmog_ Ralith__ jstimpfl1 kaol pcapriot1i jrp6_ zhulikas Pucilowski anelson diskie kolko_ noam_ mendez_ johnw tg DrCode edwtjo Tenkeyless_Cooki benj02 prkc arianvp Soft irclogger_com niklasb qlkzy nshepperd seliopou_ bind1 MTwister elgot_ monty dibblego Nikotiin1 o`connor_ strixy hsyl20 ernst m1dnight1 tinkyhol1oway [exa]_ hpc pyrtsa Ornedan Eliel ggVGc squimmy)
10:33:49 --- names: list (zenzike javax eyck ps-auxw sgronblo_ johnv__ sevas ebird Desoxy codeman7_ u-ou mt hiratara cyphase hnz martinga_ jnoah julmac nullfxn sdx23 tessier ego Nik05 carc keifer _6a68 grandy sparr georgew miklcct bgyss sephiap minsky seanparsons chriswk shwouchk WizJin wahrsagevogel buckowski micmus chris2 electrostat Ulrar Elsi bananagram sa1 mpickering stasku_ killtheliterate katymoe_ aristid afcondon mindos_cloud____ xplat|work koray blubbb {AS} poga lassulus srk)
10:33:49 --- names: list (Tuplanolla xa0 cin jokester solidsnack jinblack stefan otterdam Liskni_si x1n4u clever ntpttr garphyx`aw wjm parsnip anderson fycth_ Yaiyan cnr carter bsmt mikeizbicki kureta Fuuzetsu sag3 rodlogic AntiSpamMeta tjbp sphaleri1e robin wildleaf_ andromed1-galaxy citaret_ froztbyte YP-Cloud____ codebje_ xfix_ tek0 schultz_ JDevlieghere_ Zemyla beaky CoconutCrab fps strmpnk orzo nkpart implementation_ herzen fxrs_ myfreeweb_ zmanian____ beckyconning__ niteria_)
10:33:49 --- names: list (jmct eatonphil Flaeme greenbagels_ jml jud brisbin astocko obiwahn pkogan prefork cdsmith_ dmiles Benzi-Junior Athas wedens rotcpy pharaun SamuelB tsani barrucadu whoops Sigyn padre_angolano Axman6 MrElendig ohsix bartavelle jinglebellz bounb bshum1 Madars tmciver Qommand0r ortmage_ tnks majoh zomg Twey Chousuke jlouis nurupo tomus ahf mattp_ catern intothemountains timrs2998 Oxyd d3lxa joachifm tumdedum pratch Moyst sword_smith johtso Deadhand buoto)
10:33:49 --- names: list (tristero troydm c-rog MitchW c_wraith Saimeidae angseus kloeri averell thallada quangl mjo ktomz bencryption theorbtwo FransWillem gniourf tctara sm besenwesen shyn CARAM__ Nahra hughrawlinson alphonse23_ billstclair Brando753-o_O_o si14 Merv incomprehensibly andreypopp codedmart ocharles_ adulteratedjedi bigs monad_cat nathyong JackMc Rabbit_ Arguggi Guest7479 wrmsr Lutin` maerwald ephemeron wagle @ChanServ APic mikeplus32 dogui integral e ChongLi)
10:33:49 --- names: list (vodkaInferno freekevin qmm RevJohnnyHealey aweinstock imalsogreg Eagle_Erwin lstrano mceier pelegreno___ lachenmayer bbee coeus 7ITAAABAS unsymbol unbalanced mbwe ynyounuo Rembane_ krgn tekacs gabiruh theolaurent Biohazard_ fingerzam noexcept XMunkki pchiusano wyvern zpconn__________ trig-ger mankyKitty MorTal1ty Scorchin tharper jcp__ enolan ReinH jtobin naudiz jrslepak danieli obadz Jello_Raptor lucz anoe_ amx brennie tswett TrevorBramble_ gsingh93)
10:33:49 --- names: list (linduxed mtesseract1 jxv frolv __main__ marmalodak eL_Bart0 zxtx psmolen_ Reisen tero- Tristan-Speccy paf31 metalrain kaste etcinit etrepum Forlorn idupree reynir Majiir alang SLi DANtheBEASTman Philonous dschoepe laudiacay Guest31921 ambrosia kantokomi thoughtpolice stephe nbouscal fuziontech lexi-lambda AlainODea dsm Xorlev gornikm phuu sbauman PotatoGim avdi shennyg quoboo dgonyeo ajmccluskey mbrock vin-ivar Elision wtw ollef fmapE benjamincrom SiCC cjay)
10:33:49 --- names: list (liste quuxman saurik Profpatsch filibustr yarou kjanosz lenstr sLite jvanbure amontez noctux spaceships lpsmith wamaral arc- spion Baughn sleezd sdrodge swhalen jw358 asjo nerdystreetrat Stratege absence luite_ fairfiel- abk7 Speed segfaulthunter MasseR Guest49740 tomku mak` mniip lulf brolin_empey thebnq indiffernet_ cynick navilan RazorX- Hakey scared andreass Edoxile uwap DigitalKiwi fryguybob iteratee PanicSkittle eikke hungryhugo oberstein ricardo82)
10:33:49 --- names: list (mero abra0 jix jophish iliastsi robogoat tomaw PalTale ion majjoha jroesch_ spinda huonw arw_ koz_ mokus dilinger Vbitz `0660_ telmich noplamodo_ armlesshobo Boreeas nek0 Soup nshepperd1 felixsch opqdonut hegge _flow_ Vq Amadiro Bane^ alem0lar- saidinwot1 oldsk00l tjt mmaruseacph2 Phyx- koala_man mrd ido Jaak_ eagleflo jimki_ hydraz mrowe stux|RC-only lukky513 Belgarion0 n__dles tv exio4 nilOps canta osfameron nickpascucci Marqin Ke relrod jpl_ hxegon Tene)
10:33:50 --- names: list (amiller bob_twinkles betawaffle mantovani joeytwiddle etabot chronon-io_ EvanR Ezku_ zymurgy cross heinrich5991 Fylwind RGamma mmierz Ranhir LeaChim kwantam sajith kriztw ncl28 ppnkk ninefingers parenthetical gargawel toure johl ao1ei8 Frankablu_ scopedTV meta-coder dunj3 greymalkin iross hex0punk1 irishsultan siddhu _Shandy marienz deni taktoa tokik Reyu jluttine joehillen JPohlman1 BrianHV_ larion_ adraenwan haldean HalfEatenPie kini Solarion andjjj23_ PHO)
10:33:50 --- names: list (Freundlich oelewapperke jlewis Kneiva wrengr statusfailed KaneTW nitrix brixen martinr_ Purlox asm89 bshelden karls geal funfun jrib1 cic trampi pleiosaur JRHaigh hiredman jkarni klugez pieter SenpaiSilver tippenein Guest10767 Hijiri sshine lattenwald greeny sjl_ ario solatis codebam cjwelborn xacktm gnusosa Klumben frug72 vikraman acfoltzer t0mb0_ intelux staffehn sivs cjh` stelleg wting qinusty xnyhps cocreature petercommand cyberlard valkyr2e squisher)
10:33:50 --- names: list (nathanic opios t0m0 xaimus tgeeky dpn` da-x_ kyagrd joncfoo logcat daishan avn Nycatelos adamCS flebron peddie nwf simony obihann yorick carter-znc dpepsilon Drezil tusj bjs Igloo xxpor emmflo DDR richi235 yeltzooo ramatevish AppleJacks24 ec\ daf epta Akii tdammers urdh spacebug Fubar^ ft ngWalrus ddima [swift] l3france mrm nopf Adeon dan64 ijp foobars adarqui odamn horatiohb _kit_ kipras metaf5_ shapr geppettodivacin ephess_ bd_ zerokarmaleft kosmikus)
10:33:50 --- names: list (M2tias int-e hodapp netblaze kshannon bcoppens ent Morgawr cmr lanodan joeyh Ankhers nshepperd_ jgornick robtaylor liyang nathanel pfoetchen lispy runawayfive Factionwars trevorriles yrdz byorgey ziman potatoe pmade vervain gpampara haircode officer_raccoon eddsteel phadej alercah electrocat AustinMatherne henrytill worch pingu_ staticfox dju japesinator schjetne yamadapc tolt benzrf RageD sujeet ybit_ bitemyapp isomorph1smes samgd_ knyppeldynan jstolarek)
10:33:50 --- names: list (baetheus_ abh_ amalloy_ Jonno_FTW quaestor alpounet Sonderblade cmn pacak statusbot mgaare mw Deewiant grantwu TommyC Paks bairyn DustyDingo mudfog trajing- dqd platz_ bjobjo ryantm mkloczko_ lyxia eyenx_ emeritusnot bdeferme ReinH_ snoogie monochrom tomjaguarpaw hemite joe9 mjo_ fall_ sbjorn K0HAX Phillemann monkeyiq ben Wamanuz2 oherrala luigy wayne killerpty Cerise erikd m1dnight_ nille mdarse SolarAquarion jamesbvaughan jgertm acertain capisce skyres)
10:33:50 --- names: list (cgfbee dustinm watersoul Ring0` elementalest GGMethos Guest18807 kungp thoros nekomune IanKelling Guest48686 fabianvf hansihe marmoute so)
10:37:30 <PhsShft> Is there a function that returns true if two lists have at least one same element? If not how to write it?
10:38:39 <EvanR> > not (null (intersect [1,2,3,4] [5,6,7]))
10:38:46 <lambdabot>  False
10:38:51 <EvanR> > not (null (intersect [1,2,3,4] [4,5,6,7]))
10:39:00 <lambdabot>  True
10:39:15 <ertes> > not (null (intersect [1,2,3,4] [5,4,6,7]))
10:39:22 <lambdabot>  True
10:39:29 <EvanR> its the real deal
10:39:43 <ertes> that means it's horribly slow
10:39:46 <ertes> :t intersect
10:39:50 <EvanR> probably
10:39:54 <lambdabot> Eq a => [a] -> [a] -> [a]
10:40:05 <ertes> oh yeah…  that one has to be slow
10:40:21 <EvanR> next problem, solve it in the special case of sorted lists
10:41:03 <ertes> > intersect [1] [2..]
10:41:12 <lambdabot>  mueval-core: Time limit exceeded
10:41:13 <lambdabot>  mueval: ExitFailure 1
10:41:20 <EvanR> @src intersect
10:41:20 <lambdabot> intersect = intersectBy (==)
10:44:33 <nitrix> intersectBy eq xs ys    =  [x | x <- xs, any (eq x) ys]
10:44:36 <nitrix> n * m
10:45:42 <EvanR> judicious use of slow-as-hell algorithms can save you a lot of time IRL 
10:50:04 <ReinH> Look in Data.List.Sorted
10:51:26 <nitrix> Data.List.Ordered.isect
10:56:58 <ybit_> phillip wadler talking now: https://twitter.com/pwlremote/status/788160437963587588
10:57:13 <ybit_> streaming started, talk to begin <1min
11:00:10 <ReinH>  Oh right, Data.List.Ordered.
11:01:09 <Tuplanolla> How does that work, ybit_?
11:02:48 <lyxia> Click "Join the webinar", give your email, and enjoy.
11:04:59 <sbrg> I always feel like I should be breaking the universe because I created some self-referential paradox when I'm tying the knot in haskell
11:07:44 <ongy> how often do you do it? And how is it done?
11:09:14 <sbrg> I don't have any idea of how often I do it -- I do it when I need to and its appropriate. but any explanation I can come up with is probably going to be worse and less detailed than tabnew https://wiki.haskell.org/Tying_the_Knot
11:09:21 <sbrg> -tabnew <.<
11:11:53 <sbrg> brb
11:21:14 <bollu> does GHC have a C api for running arbitrary haskell code?
11:21:16 <bollu> or GHCi
11:21:26 <bollu> if it does, I shall pray to all the haskell gods
11:21:28 <bollu> with love
11:21:58 <ongy> there's ways to call into haskell with the ffi
11:22:08 <johnw> sbrg: tying the knot is really no different than writing a function that calls itself, except that in this case, the function calls are implicit due to lazy evaluation
11:22:23 <bollu> ongy: do tell
11:22:24 <sbrg> johnw: yeah, but it feels magical! 
11:22:58 <johnw> it is a bit magical, since the language and the compiler are doing work for you behind the scenes.  But you could write the exact same construction, in any language, using function abstraction and a partial evaluator.
11:22:59 <joe9> bollu: check out the haskell wiki on FFI
11:23:33 <bollu> joe9: ty
11:23:36 <sbrg> of course. still magical!
11:23:55 <sbrg> like the way prolog works. I may understand it completely, but what prolog can do still feels like magic
11:24:00 <joe9> bollu: https://github.com/joe9/skb/blob/master/src/skb.c is a c file that calls some haskell code.
11:24:13 <ongy> bollu: but you should be aware that linking with haskell libraries will be rather annoying unless you use ghc to call the linker
11:24:17 <lispy> prolog is pretty magical
11:24:23 <bollu> ongy: damn
11:24:31 <bollu> ongy: I wanted my shell to allow you to evaluate haskell
11:24:37 <bollu> ongy: so I wanted a hook into GHC
11:25:06 <sbrg> bollu: write the shell in Haskell and use the GHC API to run the haskell code
11:25:37 <bollu> sbrg: no, I already have a shell written in C (thanks to OS assignment). I just want to extend this 
11:25:41 <bollu> sbrg: also, fun exercise
11:25:50 <sbrg> bollu: aaah, cool assignment.
11:25:55 <bollu> sbrg: yes :)
11:26:52 <ongy> were you not allowed to use haskell in the assignment?
11:27:02 <bollu> ongy: nope, I asked
11:27:08 <bollu> ongy: the point was to "deal with C" 
11:27:55 <ongy> how "nice". I was even allowed to use haskell for our rootkit seminar. Sadly kernel mode haskell isn't really a thing, so it was just the userspace part
11:28:09 <joe9> bollu: I think you should be able to call haskell stuff from C (as long as you do the hs_init and hs_add_root), I think. But, it would be a pita to do all the data marshalling, etc.
11:28:15 <bollu> ongy: depends on the prof. Our algo prof doesn't care. 
11:28:24 <bollu> joe9: I see. is there a library that helps with this?
11:29:53 <joe9> bollu: HSFFI
11:30:02 <bollu> nice
11:30:03 <bollu> thanks
11:30:53 <ongy> and a lot of hsc2hs and Storable instances for data going between C and haskell
11:31:19 <ertes> ongy: a rootkit in haskell…  that's a great way to hide it
11:31:37 <ertes> "what's this process that uses 1 TiB of virtual memory?!  oh, it's a kernel thing, nevermind!"
11:32:05 <ongy> :) sadly I didn't find resources convinient enough for kernel mode haskell. But I did make the controlling application in haskell, it was rather fun
11:32:11 <Cale> ertes: haha :)
11:34:27 <sbrg> i've read that some reverse engineers consider haskell executables nearly reverse-proof
11:34:46 <fnurglewitz> sbrg: is that even an issue?
11:34:46 <sbrg> there's so much indirection it's almost impossible to glean any information from it
11:34:50 <sbrg> not at all
11:35:07 <bollu> sbrg: lol
11:35:31 <haskell080> ongy: what dws your controlling application do?
11:35:55 <ongy> fnurglewitz: we reached the point where we modified proprietary userspace "driver" (ioctl usb-hid) to work, after looking into what failed
11:36:06 <bollu> if I know that type w has a Comonad instance, then I want to auto-derive the MonoComonad instance on some newtype WaWrapper = WaWrapper {inner :: w a}
11:36:10 <bollu> this is plainly possible
11:36:25 <bollu> since you just need to take the comonad instance and stick it into using the MonoComonad code
11:36:27 <fnurglewitz> ongy: cool :D
11:36:28 <bollu> but I don't know how to do this
11:36:33 <bollu> I think I need template haskel
11:36:35 <bollu> any ideas?
11:36:37 <fnurglewitz> ongy: how much time did it take?
11:36:59 <ongy> haskell080: it talked to the kernel part over netlink and controlled hidden files/ports/processes, portknocking etc. Every function was fully controllable during runtime 
11:50:12 <bollu> 	if I know that type w has a Comonad instance, then I want to auto-derive the MonoComonad instance on some newtype WaWrapper = WaWrapper {inner :: w a}. This is obviously possible. If I know how to do this, can I use TemplateHaskell to create a "template" that automatically does this? 
11:52:49 <ertes> sbrg: so if you write a rootkit in haskell, you should probably use intentionally terrible code…  that fake qsort might come in handy
11:53:35 <ertes> "wow! is that really qsort in haskell?" – "oh, no, that code is just for obfuscation"
11:54:53 <ReinH> Also, it probably wouldn't really be qsort even if it were supposed to be qsort.
11:55:18 <ertes> i wonder if one of the GHC versions actually used the SKI compilation scheme SPJ explained in his book
11:55:33 <ertes> because that one basically compiles haskell to unlambda =)
11:58:31 * hackagebot pgdl 10.2 - browse directory listing webpages and download files from them.  https://hackage.haskell.org/package/pgdl-10.2 (sifmelcara)
11:58:33 * hackagebot wavefront-obj 0.1.0.0 - Wavefront .obj file loader  https://hackage.haskell.org/package/wavefront-obj-0.1.0.0 (sasinestro)
11:58:35 * hackagebot patat 0.3.1.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.3.1.0 (JasperVanDerJeugt)
12:00:57 <ongy> it was also really fun to see for me. At that point I wasn't really proficient with haskell, but the netlink stuff was so much easier to compared to C
12:18:35 <darthron> Hi guys! Sorry to bother with my question. How do I use where inside another where? As in `let f  = x * 5 where x = y + 1 where y = 3`
12:20:03 <srhb> > let x = y where y = z where z = 42 in x
12:20:06 <lambdabot>  42
12:20:11 <masteraka> darthron: this seems to work as you wrote it
12:20:27 <darthron> :masteraka Maybe I misindent
12:20:33 <masteraka> most likely
12:20:46 <masteraka> > let f  = x * 5 where x = y + 1 where y = 3
12:20:48 <lambdabot>  <no location info>: error:
12:20:48 <lambdabot>      not an expression: ‘let f  = x * 5 where x = y + 1 where y = 3’
12:20:57 <masteraka> let f  = x * 5 where x = y + 1 where y = 3 in f
12:21:03 <masteraka> > let f  = x * 5 where x = y + 1 where y = 3 in f
12:21:05 <lambdabot>  20
12:21:39 <masteraka> it works without the `in f` in the REPL though
12:21:57 <srhb> ghci is a bit special.
12:22:18 <Tuplanolla> The catch is that `where` does not construct an expression, so you can't say `2 + (x where x = 3)`.
12:22:28 <darthron> :masteraka Do you think vim replaces four spaces with tab and mess up with the ghc?
12:25:55 <ReinH> darthron: don't use tabs, only use spaces
12:26:33 <ReinH> You *can* use tabs, but they are a source of indentation errors because GHC always treats them as 8 spaces and your editor might be configured differently.
12:26:52 <darthron> :ReinH I only use spaces when writing Haskell. I thought it may do something to it.
12:26:56 <ReinH> so things that appear correctly indented might not be
12:26:58 <masteraka> darthron: 1. don't know much about vim. 2. don't use tabs, use spaces - its the only way to be consistent
12:29:04 <Tuplanolla> As a Vim user you should have this in your configuration file: `set list listchars=tab:├─,trail:·,extends:…,precedes:…,nbsp:␣`
12:29:27 <Tuplanolla> No longer will leading or trailing spaces cause trouble.
12:31:47 <Clint> what's kind `Meta'?
12:54:34 <dmj`> does hackage really reject packages with -Werror?
12:54:55 <dmj`> cabal check says it does
12:54:59 <geekosaur> yes
12:56:15 <geekosaur> because -Werror turns out to be equivalent to "only compatible with specific versions of all dependencies" in most cases
12:58:20 <dmj`> geekosaur: hmm, I see
12:58:32 * hackagebot newtype-generics 0.4.2 - A typeclass and set of functions for working with newtypes, with generics support.  https://hackage.haskell.org/package/newtype-generics-0.4.2 (jcristovao)
12:58:35 * hackagebot newtype-generics 0.5 - A typeclass and set of functions for working with newtypes, with generics support.  https://hackage.haskell.org/package/newtype-generics-0.5 (jcristovao)
12:58:36 * hackagebot wavefront-obj 0.1.0.1 - Wavefront .obj file loader  https://hackage.haskell.org/package/wavefront-obj-0.1.0.1 (sasinestro)
12:58:54 <geekosaur> in particilar it tends to mean your code works with one ghc version, since older versions will almost always throw warnings
13:00:54 <geekosaur> or the other way around: consider for example how Foldable/Traversable caused some tings to migrate intot he Prelude; if you also import from modules for pre-7.10 compat then 7.10 throws warnings about the "useless" imports
13:02:14 <Tuplanolla> > do do do do "doo" -- The next version could start to warn you about unnecessary `do` too.
13:02:17 <lambdabot>  "doo"
13:03:14 <geekosaur> (similar things happen with C++, I work with some other projects that forbid -Werror because it prevents compatibility between compiler versions)
13:05:40 <kuribas> Would you use "either"?
13:05:45 <kuribas> :t either
13:05:47 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:06:04 <kuribas> It's kind of objuscating...
13:06:19 <dmj`> kuribas: I love using either
13:07:03 <kuribas> I am not sure to use it...
13:07:05 <dmj`> x :: c <- either leftThing rightThing =<< someIOEitherStringResult
13:07:17 <kuribas> But I guess haskell user are used to pointless style.
13:07:41 <dmj`> x :: c <- either (leftThing :: a -> c) (rightThing :: b -> c) =<< (thing :: IO (Either a b))
13:08:00 <dmj`> well, technically you'd need pure $ either
13:08:08 <dmj`> in this case you'd just use 'fmap' (<$>)
13:08:10 <kadoban> 'either' replaces explicit pattern matching mostly. If you find it easier to understand, a case statement is fine.
13:08:17 <kuribas> I have "either fail (return . CMapIntern) $ functionThatReturnsEither"
13:08:38 <Tuplanolla> It's nicer when you haven't already named the third argument, kuribas.
13:08:48 <dmj`> right, that works too
13:09:17 <kuribas> Tuplanolla: I named it for the example...
13:09:26 <dmj`> c :: c <- either (l :: a -> IO c) (r :: b -> IO c) =<< (thing :: IO (Either a b))
13:10:07 <kuribas> it's inside the Get Monad
13:18:20 <joe9> When writing haskell server library, Is there a pattern that is used? such as callbacks, etc?
13:18:52 <joe9> dealing with the server library specific context and the user context is proving to be a nuisance.
13:19:17 <joe9> If I write the server library such that it runs it its own thread, then i would need Chan's to communicate with the main thread.
13:19:45 <joe9> If I write a server library which uses callbacks, then I would have to make sure that any state used by the callbacks is encapsulated in the server library state
13:20:01 <joe9> I think xmonad has "user state" for such.
13:20:10 <joe9> Is there a pattern that is recommended for such design?
13:20:13 <davean> joe9: well, theres a few other options
13:20:53 <davean> joe9: You can have a library of functions that deal with the state, several threads that run in the background doing stuff with it, and interact with the state directly, particularly via STM for example
13:21:10 <davean> There are any number of options
13:21:20 <joe9> davean: That is using Chan's, correct?
13:21:24 <davean> no
13:21:27 <joe9> or, TQueue, etc.
13:21:29 <davean> nope
13:21:43 <davean> (next up is "still nope")
13:21:43 <joe9> IORef?
13:21:55 <davean> definately not
13:22:12 <davean> I strongly recomend against IORef for this sort of thing
13:22:20 <davean> its semantics are quite complicated in reality
13:22:36 <davean> http://hackage.haskell.org/package/stm
13:22:45 <davean> All of STM is based on TVar
13:23:17 <davean> TChan/TQueue/TBQueue are all implimentations on top of TVar for a specific communication mechanism, I'm talking about state
13:23:30 <amx> joe9: chapter 12 http://chimera.labs.oreilly.com/books/1230000000929/index.html
13:23:39 <davean> (You know, I've never used TArray ...)
13:24:14 <davean> joe9: I'm actually a bit confused by your focus on Chans
13:24:32 <davean> They're useful, and appropriate, but you seem to think they're a more general primative?
13:24:34 <joe9> davean: You are talking about how to communicate between the different threads. I need help on how to structure the library itself.
13:25:02 <davean> joe9: they're not inherantly seperate tasks
13:25:46 <joe9> I am not talking about concurrency in general. I am talking about how to structure a library when it has some functions which interact outside of itself (such as callbacks, etc).
13:26:11 <joe9> one pattern I notice is, context <- initializeContext, use this context to run any library function
13:26:30 <davean> joe9: or you can encapsulate that in a monad
13:26:35 <davean> "runThing $ do"
13:27:00 <joe9> another pattern I see is, (in xmonad) run the library loop but providing callbacks in the context.
13:27:44 <davean> joe9: but thats not about threading at all
13:27:57 <joe9> yes, I am not talking about threading.
13:28:17 <joe9> structure/organization of code.
13:28:18 <davean> "16:18:55 joe9 If I write the server library such that it runs it its own thread, then i would need Chan's to communicate with the main thread."
13:28:59 <joe9> wrongly worded, sorry about that.
13:29:29 <joe9> I am writing a server library which can be used by another application.
13:29:38 <joe9> The Main is not in this library.
13:29:42 <ph88^> anyone know how to write Uniplate.Direct instances for records? https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Direct.html 
13:30:33 <joe9> I am trying to figure out the haskell recommended patterns for such a library. callbacks + loop in the library vs loop in the Main function but any library call is provided with a context.
13:30:55 <joe9> davean: Does that make sense?
13:31:33 <davean> I mean, it makes sense but you're conflating things
13:31:42 <davean> "callbacks +", theres no plus
13:31:47 <davean> thats an entirely seperate decision
13:32:08 <davean> where the loop happens, and if its callbacks or a context are seperate
13:32:18 <davean> all a callback really does is wrap some context
13:32:56 <joe9> but, if the callback needs more than the context that it is being called with? (user context)
13:33:24 <davean> "doA :: context -> param -> result"
13:33:31 <davean> "doACurried :: param -> result"
13:33:35 <davean> do you see how they're the same?
13:33:55 <davean> The second form just says less about its implimentation
13:34:03 <davean> and theres a 3rd form
13:34:14 <davean> "doAM :: param -> m result"
13:34:19 <davean> where m carries the context
13:34:39 <davean> (though result in both cases above often has an m component)
13:34:41 <joe9> m = IO for reading Chan's?
13:34:52 <davean> no
13:35:07 <davean> *head desk*
13:35:10 <davean> ok, next up?
13:35:22 <davean> (Sorry, I just don't know where I'm lossing you)
13:35:33 <joe9> So, the 'm' can be any user specified monad, correct?
13:35:51 <davean> no, in this case its some specific monad to doAM
13:36:00 <davean> "where m carries the context"
13:36:25 <davean> Like perhaps "m result" is "ReaderT context m result"
13:36:36 <allenj12> how can something like MVar exist in haskell? or IVar for that matter
13:36:43 <davean> or perhaps its "MyCustomDSL rsult"
13:37:15 <kuribas> What if I have a lazy bytestring, and have to calculate a checksum before writing to disc?  Would it be faster to calculate the checksum on the written file?
13:37:17 <davean> Its definately not IO though, IO can't really carry a specific context
13:37:36 <davean> kuribas: you can calculate it as you write the file
13:37:52 <allenj12> MVar seems mutable although its contents are not necessarily, shouldnt this be a problem?
13:38:02 <davean> allenj12: no
13:38:13 <joe9> davean: any sample code that you would recommend for this scenario? so, I can read it to figure out what is happening. I think I understand what you are saying. but, am not sure I get it either.
13:38:30 <allenj12> davean: why not? how is it implemented? Im assuming it cant be native?
13:38:48 <kuribas> davean: in chunks?
13:39:33 <davean> allenj12: http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.MVar.html is how they're implimented but I don't think thats really your question
13:39:48 <davean> kuribas: chunks work well
13:40:08 <allenj12> davean: ill skim through it and ill see :D
13:40:10 <allenj12> thansk
13:40:49 <davean> allenj12: I think it'll actually lead you astray to see the mechanics of it, since what really matters is that its faithful to the specification, not that it behaves in an inherant way
13:41:10 <davean> allenj12: so, you see how >>= changes the "m" part?
13:41:19 <davean> allenj12: (in general)
13:41:48 <kuribas> davean: with a IORef?  like mapM writeAndCalckChecksum (fromChunks myByteString)?
13:42:13 <kuribas> erm toChunks
13:42:22 <davean> kuribas: well, I'd certainly want mapM_!
13:42:40 <kuribas> yeah
13:42:50 <davean> nd wouldn't that be toChunks?
13:42:51 <ongy> could you not use foldM to build it?
13:42:52 <allenj12> davean: not really, only >>= i see is in newMvar
13:43:04 <allenj12> o
13:43:11 <allenj12> sorry missed the (in general part)
13:43:13 <davean> allenj12: Ignore the actual implimentation that will confuse you
13:43:36 <davean> moands in general, the specific value of "m" is a different one in each part of the >>=
13:43:56 <allenj12> davean: yea that i get
13:44:00 <davean> Ok, so
13:44:08 <davean> allenj12: for the purposes of a thought experiment
13:44:50 <davean> allenj12: consider m to be "data M = M {..., mDict :: Map (mvar m) m, ...}"?
13:45:05 <allenj12> ok
13:45:11 <davean> so mvar now becomes a (type tagged) key to a store thats in the monad
13:45:17 <kuribas> davean: yeah toChunks.
13:45:45 <davean> WE never change the mvar, we change the value in the cell that the mvar points to, and that cell is in the m, which we come up with a new one on every >>= usage
13:45:48 <davean> allenj12: see?
13:46:07 <davean> now m changes, but mvar never does
13:46:19 <allenj12> davean: i think so,
13:46:43 <davean> This is more faithfully represented in the implimentation of State
13:46:58 <EvanR> :t (>>+)
13:47:00 <lambdabot> error:
13:47:00 <lambdabot>     • Variable not in scope: >>+
13:47:00 <lambdabot>     • Perhaps you meant one of these:
13:47:12 <davean> allenj12: http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#t:StateT
13:47:25 <davean> allenj12: thats the implimentation I'd look at if I were you
13:47:49 <allenj12> davean: oo, so it is similar to the state monad?
13:48:02 <davean> allenj12: conceptually at least
13:48:12 <EvanR> :t (>>=)
13:48:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:48:26 <EvanR> :t (>>=)doesnt change
13:48:27 <davean> allenj12: You asked "how is it not a problem"
13:48:28 <lambdabot> error: Variable not in scope: doesnt :: m a0
13:48:28 <lambdabot> error:
13:48:28 <lambdabot>     • Variable not in scope: change :: a0 -> m b
13:48:48 <allenj12> davean: ok I think what got me is that it just seems weird that the view of different threads can change based on other threads
13:48:51 <davean> allenj12: lets never talk about the details of the implimentation deep down below IO
13:48:52 <EvanR> what is wrong with my internet
13:49:10 <EvanR> the particular value of m there doesnt change
13:49:37 <davean> EvanR: the type doesn't
13:49:45 <EvanR> it stays IO, or whatever
13:49:47 <davean> the value certainly does
13:49:51 <davean> EvanR: thats type
13:50:03 <EvanR> its not the value of "m" though
13:50:30 <davean> what we fill in m by doesn't change, what the actual data is certainly does
13:51:11 <EvanR> the m a 
13:51:27 <davean> EvanR: even in the weird case of IO we make a new value
13:51:31 <ongy> where is readMVar# defined? primitive?
13:51:39 <EvanR> sure
13:51:41 <davean> ongy: yah
13:51:45 <EvanR> but not a value of type IO
13:51:57 <ongy> -.- and I though I had a chance to understand it better
13:52:10 <EvanR> you create IO Foos
13:52:17 <davean> ongy: http://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/GHC-Prim.html#v:readMVar-35-
13:53:51 <davean> EvanR: "bindIO (IO m) k = IO (\ s -> case m s of (# new_s, a #) -> unIO (k a) new_s)"
13:53:59 <davean> You make a new IO, with a Foo component
13:54:19 <davean> Thats not what every monad does, but it is what IO does
13:54:48 <ongy> 'takeMVar# = takeMVar#' really helpful :) so is it somewhere in the RTS then?
13:54:55 <davean> Also, can we really not look at the internals of IO? its like an impressionistic painting of Haskell
13:55:01 <EvanR> im complaining about calling one of those "an IO"
13:55:14 <davean> ongy: Yes
13:55:26 <davean> ongy: those things are replaced by the compiler to RTS calls
13:55:50 <davean> EvanR: why?
13:56:11 <EvanR> because IO :: * ->* and so doesnt have any values
13:56:48 <EvanR> also the charactersization of bind as "changing m"
13:56:48 <EvanR> you thus never have "an m"
13:57:56 <davean> EvanR: I mean, you have the "data IO" part, and you have the "Foo" part
13:58:14 <davean> They're seperate, and its important here that they're operating seperately
13:58:34 * hackagebot google-translate 0.3 - Google Translate API bindings  https://hackage.haskell.org/package/google-translate-0.3 (DavidJohnson)
13:58:36 * hackagebot dotenv 0.3.1.0 - Loads environment variables from dotenv files  https://hackage.haskell.org/package/dotenv-0.3.1.0 (mrkkrp)
13:59:07 <davean> EvanR: you never have just an IO, but you you have a part of definition of IO irrespective of what Foo is
13:59:21 <davean> and thats the part I'm talking about
13:59:26 <davean> the part that doesn't depend on Foo
13:59:33 <davean> that part changes
13:59:35 <EvanR> not buying it
13:59:52 <davean> Ok, well, I don't buy your version at all either :)
13:59:56 <davean> so lets disagree :)
14:00:20 <EvanR> there is no such thing as an IO part
14:00:31 <EvanR> so its certainly not changing
14:00:35 <davean> I mean there clear is
14:00:49 <kuribas> Isn't there a risk with haskell project to have a high entry for contributors?
14:00:49 <davean> I'm looking right at it
14:00:59 <davean> kuribas: bar to entry?
14:01:06 <EvanR> this explanation seems to be mixing up type level  runtime level and metaphysics
14:01:15 <davean> EvanR: great, lets disagree
14:01:27 <davean> EvanR: though, fine
14:01:43 <davean> if you want to argue, the boxing makes this very concret
14:01:43 <kuribas> davean: yeah
14:01:49 <davean> kuribas: isn't that a good thing? :)
14:01:59 <kuribas> davean: yes and no...
14:02:17 <davean> kuribas: well I think you just answered your own question
14:02:24 <ongy> scary
14:02:32 <EvanR> kuribas: isnt there a barrier to entry for any project written in a language people dont know ?
14:02:43 <EvanR> like clojure, elixir, etc
14:03:02 <kuribas> EvanR: there is.  But in haskell is not just syntax etc...
14:03:05 <johnw> kuribas: I get a lot more contributors for my Haskell projects that I've ever had for my C++ projects
14:03:17 <EvanR> neither is it just syntax in those other languages
14:03:18 <kuribas> johnw: right :)
14:03:27 <EvanR> but yeah youre getting closer to the real concern
14:03:32 <davean> Very few languages are just different by syntax
14:03:41 <davean> infact I think I know of all of two?
14:03:59 <EvanR> javascript and all its skin languages
14:04:02 <davean> (that lisp variant with an s-expression form and a non-s-expression form)
14:04:10 <EvanR> C++ has its own share of skin languages
14:04:26 <davean> (which are ACTUALLY the same language, with 2 syntaxes for encoding)
14:05:02 <EvanR> then you have languages which are different but have the same syntax!
14:05:06 <davean> https://en.wikipedia.org/wiki/Dylan_(programming_language)
14:05:11 <davean> Haha! Yes, that one!
14:05:32 <kuribas> python is easer to learn than haskell for an imperative programmer
14:05:48 <davean> kuribas: well, it would be if I'd ever meet someone who'd learned python :)
14:06:00 <davean> kuribas: lots of people program in python, no one knows it
14:06:45 <EvanR> so if they already knew something like python, itd be easier to learn python, yeah. i found haskell pretty easy to learn after learning scheme
14:07:11 <davean> I mean, very few people know C, but I've meet a few
14:07:28 <EvanR> but its odd to take this into account, because how do you learn something like python or scheme in the first place
14:07:37 <kuribas> davean: in that sense haskell is easier yeah...
14:08:12 <davean> kuribas: ever seen the implimentation of pointers that conforms to the C spec, for a lisp machine? That was trippy
14:08:13 <yulax> anyone use haskell on openbsd? will the ports packages work all right?
14:09:05 <kuribas> davean: maybe haskell is in essence easier, but people don't realize it yet...
14:09:29 <EvanR> haskell as a first language is always an interesting experiment
14:09:39 <ongy> it's harder to get to compile, but I feel like easier to get it right (outside of all the IO errors you can get)
14:09:43 <davean> kuribas: most people don't really care what their code actually does if they get the result they want. but that makes dealing with patches and maintaining a project hard
14:10:09 <davean> kuribas: This effect seems worst in python from my experience
14:10:23 <davean> which is one reason I abandoned python :(
14:10:30 <ongy> I can /sign that one. ever seen how anki plugins work?
14:10:45 <kuribas> EvanR: I read about a woman that tried haskell as first language, but she had a hard time, because all material actually presumes a programming knowledge.
14:11:06 <kuribas> davean: right, and ruby is even worse.
14:11:07 <EvanR> i have heard of similar anecdotes
14:11:08 <davean> ongy: no, I can't say I have?
14:11:19 <davean> kuribas: is it? when I did ruby it was better then python, but that was 2005
14:11:30 <EvanR> but usually its that they thought it was easy (perhaps because of the teacher, or materials), and then had a hard time with C
14:11:41 <davean> (there wasn't a whole lot of ruby code at the time, I expect its increased popularity has hurt its code quality)
14:12:07 <kuribas> davean: well, there is a lot of changing internal classes etc...
14:12:23 <ongy> it relies on the monkey-patching. A plugin is simple loaded before the application singleton is and is supposed to modify the class. So most plugins are just copy-paste code with a little modification. I think there's hook for some things, but not that many
14:12:24 <davean> kuribas: monkey patching?
14:12:27 <kuribas> yeah
14:12:42 <davean> ongy: oh, hell, you had to do that to get python's HTTP module to work
14:12:56 <EvanR> thats ruby in general
14:13:04 <EvanR> or is that python
14:13:10 <davean> monkey patching has nothing on what I'm really talking about
14:13:21 <davean> I'm talking about not actually knowing the semantics of the language
14:13:39 <davean> and getting lucky on it running when invoked certain ways
14:13:47 <glguy> The horrors of Python and Ruby are better for #haskell-offtopic
14:14:01 <EvanR> you could compare it to electronics, many people can put together a circuit without having any understanding of physicss
14:14:31 <kuribas> davean: are you talking about a basic understanding or esoteric constructs?
14:14:54 <davean> kuribas: sadly in python theres not a real clear destinction when you start mixing libraries
14:15:00 <EvanR> lets talk about the basics and esoterica of haskell! ;)
14:15:00 <davean> kuribas: so, to get back to your initial question
14:15:50 <davean> kuribas: does haskell raise the bar of contributions to your project? in some ways, like you said, but sometimes things contributed in other languages perhaps are best not viewed as contributing? etc? So your question really doesn't say much.
14:15:57 <davean> kuribas: the contributions you'll get will be different
14:16:07 <davean> kuribas: and volume probably is a terrible metric
14:16:08 <kuribas> ok, that makes sense.
14:16:21 <EvanR> i think viewing haskell's inherent difficulty as a sort of blessing to keep noobs out is pretty wrong
14:16:22 <davean> kuribas: from there it depends on what you're doing
14:16:40 <davean> EvanR: Oh no, I was actually refering to how hard triaging the effects of a patch are
14:16:56 <davean> EvanR: and quality control
14:17:06 <EvanR> perhaps theres a culture of higher quality code
14:17:14 <davean> EvanR: lets ignore the code quality
14:17:14 <EvanR> thats not the same thing as a barrier to entry
14:17:24 <kuribas> EvanR: well, haskell does require understand of the code, or at least the types to contribute.
14:17:26 <davean> EvanR: lets just consider the problem of inspecting a patch
14:17:46 <EvanR> kuribas: yes, but with proper abstraction it doesnt require full understanding of the entire project
14:18:26 <EvanR> kuribas: and improper abstraction of the entire project is kind of hard to pull off in haskell
14:18:33 <davean> I was specificly refering to the workload of the patch merger, vs time of them working on the project themselves
14:18:47 <EvanR> theres no "monkey patch" operation
14:18:55 <davean> time dealing with patch merger is often time one would have actually been doing work themselves
14:19:10 <davean> often a project maintainer has a higher productivity then fly-by contributers
14:19:29 <allenj12> davean: sorry to poke again, Im just looking at the state monad, im not to sure if Mvar and something like that are similar, I think the main difference is that the state combines results however it will not change the view of any others view on any state they get, similarly however MVar will, if MVar actually dosnt change but what it points to changes isnt that still a raw mutation? things with the same binding do change without
14:19:29 <allenj12> evaluating themselves in a non-contained way
14:19:35 <ongy> haskell doesn't even have something ASM java bytecode editing like, does it?
14:19:41 <allenj12> i might just need to take a break, and look at it again
14:20:01 <EvanR> ongy: uh. that exists in java? o_O
14:20:49 <EvanR> allenj12: to understand State monads, implement one yourself
14:20:54 <davean> allenj12: you can show all the changes of view are during >>=s though. Consider the laws
14:21:02 <davean> EvanR: no, this isn't about state
14:21:04 <kuribas> davean: thanks, I guess haskell isn't the wrong language for my project after all :)
14:21:06 <joe9> allenj12: http://www.haskellforall.com/2013/06/from-zero-to-cooperative-threads-in-33.html
14:21:19 <davean> EvanR: this is about MVar and if it breaks abstractions
14:21:34 <EvanR> davean: i could not tell at all that thats what you were trying to explain
14:21:50 <davean> EvanR: thats because the conversation has been ongoing
14:21:57 <davean> EvanR: you came in near the end
14:22:31 <joe9> allenj12: also this, http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.39.8039&rep=rep1&type=pdf
14:22:54 <joe9> allenj12: title of the above: Functional Pearls: A Poor Man's Concurrency Monad (1999)
14:23:51 <davean> joe9: Oh yes, that might be helpful
14:26:04 <allenj12> ill look into both of those thank you
14:31:22 <joe9> any recommendations for a filesystem tree like data structure that can be easily flattened to a Vector of items?
14:33:28 <sbrg> well, trees can be easily flattened.
14:33:49 <EvanR> well, into a vector?
14:34:01 <EvanR> adds an interesting ingredient
14:34:28 <EvanR> more importantly the file system aspect...
14:34:51 <jle`> file system aspect seems like a basic tree
14:34:58 <jle`> rose tree
14:35:00 <EvanR> Map Path [Item]
14:35:10 <EvanR> hmm
14:35:12 <jle`> http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Tree.html
14:35:25 <EvanR> Map Path [Either Item Path]
14:35:55 <jle`> has anyone ever actually used Data.Tree
14:36:02 <joe9> https://hackage.haskell.org/package/filesystem-trees-0.1.0.6/docs/System-File-Tree.html found this . It has a flatten
14:36:19 <joe9> EvanR: I just want a list.
14:36:28 <jle`> oh, if it's a list then that's a lot simpler
14:36:34 <EvanR> ah then Foldable instance would just do that
14:36:35 <jle`> you get it for free if it's a Foldable instance
14:37:45 <davean> joe9: I'm not entirely sure I understand the problem, but a trie?
14:37:58 <EvanR> a filesystem tree is more than just a rose tree, since you have paths and a difference between subdirs and files
14:38:04 <davean> I use a trie to represent filesystems a lot
14:38:11 <joe9> What is "pre-order" and  "post-order" traversal?
14:38:48 <EvanR> yeah, bytestring-trie might make a good filesystem tree
14:38:49 <jle`> joe9: if the information in the node is traversed before or after the information in its leaves
14:39:01 <jle`> data Tree a = Leaf | Node (Tree a) a (Tree a)
14:39:11 <johnw> as opposed to "in order" traversal
14:39:24 <davean> EvanR: I use list-trie
14:39:57 <davean> With list of byte string keys
14:40:00 <jle`> joe9: toListPreOrder (Node t1 x t2) = x : toListPreOrder t1 ++ toListPreOrder t2
14:40:02 <davean> But I'm POSIX
14:40:15 <EvanR> bytestrings not containing '/' 
14:40:16 <jle`> joe9: toListPostOrder (Node t1 x t2) = toListPostOrder t1 ++ toListPostOrder t2 ++ [x]
14:40:35 <jle`> joe9: toListInOrder (Node t1 x t2) = toListInOrder t1 ++ [x] ++ toListInOrder t2
14:42:23 <joe9> jle`: Thanks, makes sense.
14:43:05 <delYsid> Is it "ok" to use pattern matching to do big (on the order of 10000 entries) static tables in haskell, or is it better to use a specific data structure and lookup? ( https://github.com/mlang/haskore-braille/blob/master/src/Haskore/Interface/Braille/TextTables.hs )
14:43:34 <joe9> delYsid: pattern synonyms, generate them?
14:44:03 <joe9> https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html , no run-time cost (from what I understand) delYsid.
14:44:49 <EvanR> delYsid: for Int -> Int tables, an array / vector might be more efficient
14:44:55 <EvanR> than pattern matching
14:45:09 <EvanR> or pattern synonyms
14:45:35 <davean> EvanR: let's not mention how upset I am with Haskell's filename types and handling
14:45:39 <EvanR> if the keys are all low and consecutive
14:45:53 <EvanR> lets not, but youre not alone
14:47:23 <johnw> davean: so create a good answer :)
14:48:02 <EvanR> i liked the proposal on the mailing list but it seems to have been forgotten
14:48:11 <davean> We have a great answer
14:48:16 <johnw> oh?
14:48:30 <davean> johnw: the problem is all the base functions use the broken interface
14:48:46 <EvanR> they use FilePath...
14:48:46 <davean> RawPosixPath is wonderful
14:48:57 <johnw> ?
14:48:58 <davean> EvanR: File path is broken
14:49:17 <EvanR> well, if you fix it, they suddenly use the right interface without being modified! ;)
14:49:38 <davean> EvanR: yes, but it's inherently broken
14:50:09 <johnw> I'd sort of like an API on top of RawPosixPath that uses DataKinds to distinguish relative paths from absolute ones, etc., or paths rooted from a certain directory
14:50:11 <davean> EvanR: and people didn't like fundamental ly changing it
14:50:26 <davean> Because if course breakage
14:50:42 <davean> But you literally can't write correct code now
14:50:47 <EvanR> changing it to be a newtype which is really a ByteString makes sense to me
14:51:04 <davean> EvanR: I wish I could have that
14:51:26 <davean> I floated the idea ages ago
14:51:43 <allenj12> davean: I think im getting it, slowly, is it wrong to think that it is 'ok' because they essentially stem from the same computation anyway
14:51:44 <davean> Back in like 2012?
14:51:51 <EvanR> theres plenty of bells and whistles beyond this and platform insanities that could be addressed
14:52:50 <davean> EvanR: yes
14:53:04 <davean> EvanR: what are your particular concerns?
14:53:11 <EvanR> but all that seems to harm the chance of success
14:53:27 <davean> EvanR: also, bytestring isn't in base
14:55:15 <EvanR> however ByteString is implemented, use that for the innards, and put the conversions to and from ByteString in the bytestring package (which use that base support)
14:55:36 <EvanR> you wouldnt be converting back and forth without the ByteString package
14:55:37 <davean> EvanR: I think I favor [ByteString], but thats a minor preference
14:55:54 <EvanR> that is a major difference
14:56:03 <davean> johnw: interesting, I ... kinda like that
14:56:30 <EvanR> johnw's idea could be a lib on top of FilePath
14:56:38 <davean> EvanR: yah
14:57:20 <EvanR> "abtract filepath proposal"
14:57:21 <davean> EvanR: yah
14:57:35 <davean> EvanR: er, thats a yah to "[ByteString]" not being the same
14:57:36 <EvanR> spelled right in actual proposal
14:57:57 <EvanR> your conversions could also include to and from [ByteString]
14:58:21 <EvanR> but internally its a buffer of bytes, i.e. what the OS gives you
14:58:36 * hackagebot operational 0.2.3.4 - Implementation of difficult monads made easy  with operational semantics.  https://hackage.haskell.org/package/operational-0.2.3.4 (HeinrichApfelmus)
14:58:51 <davean> EvanR: yah, though some OSs give it as seperate ByteStrings
14:59:24 <EvanR> well good, all the more reason to make it abstract
14:59:27 <allenj12> the only way I can see MVar currently as still pure is that if you were to represent the forks as a list like in the paper joe9 mentioned but when you replace whats in the MVar box your actually creating a new list.
14:59:33 <allenj12> is this somewhat right?
14:59:56 <EvanR> MVars arent functions, so what would it mean for them to pure or not pure
15:00:10 <davean> EvanR: true
15:00:36 <allenj12> EvanR: hmmmm, I guess i ment that they cant be 'mutated'
15:00:46 <EvanR> the reference to an MVar cant be mutated
15:00:53 <EvanR> thats the "value"
15:01:42 <allenj12> but tha value can (thats what you ment right?)
15:01:53 <EvanR> the contents of the object yes, but thats not what youre passing around
15:01:57 <davean> EvanR, johnw: sadly the Haskell report specifies Filepath 
15:02:13 <davean> (and I have no idea how it specified it wrong, this was a major issue at the time too)
15:02:22 <allenj12> EvanR: omg i think i get it
15:02:47 <davean> allenj12: yay!
15:02:52 <EvanR> like, you pass 3 around, but nothing can change it
15:03:18 <geekosaur> this may be an area where ghc has to take point and then push for the report change
15:04:38 <EvanR> allenj12: you cant show an MVar, but if it did it might be like "MVar aba687e68dab6d"
15:04:55 <EvanR> the contents arent visible there, and nothing can change it
15:05:01 <EvanR> the "name"
15:05:19 <EvanR> if you could show it*
15:05:49 <allenj12> EvanR: so that location is always the same to?
15:06:06 <allenj12> of ab...
15:06:06 <EvanR> not a location, but a way to tell that two mvars refs are not the same
15:06:16 <EvanR> it doesnt change
15:06:20 <allenj12> o gotcha
15:07:19 <EvanR> a unique label
15:08:43 <allenj12> ok yea, I think I got it. I dont think I could explain it yet. But I got it
15:08:56 <allenj12> the links and everything were very helpful
15:09:25 <davean> geekosaur: Do you think it might actually happen? I could look into what it would take, but I'd given up hope at no one understood why it might matter years ago, but now it sounds like people here do ...
15:10:17 <geekosaur> I don't know. I've complained about it here (and gotten argued back at) a few times...
15:10:19 <EvanR> whenever something like this is proposed, someone usually runs a test on hackage to see what suddenly wont build
15:10:34 <EvanR> maybe FilePath being fixed is extra breaky
15:10:40 <geekosaur> it's extra pervasive
15:11:29 <geekosaur> but, yes, awareness is finally slowly growing and maybe it is finally time that something can be pushed through
15:11:33 <Tuplanolla> We could make the transition easier by calling the successor FileBath.
15:11:47 <geekosaur> especially since we seem to be in a time when people are accepting fairly breaky changes
15:11:57 <geekosaur> get it all over with at once...
15:12:11 * EvanR holds the match next to the bridge
15:12:37 <EvanR> find some more bridges to throw on this pile
15:12:53 <davean> maybe I can do the research to put together  decent proposal again on my sail
15:13:33 <EvanR> https://ghc.haskell.org/trac/ghc/wiki/Proposal/AbstractFilePath
15:13:55 <Tuplanolla> Rename `$` and `&` to be more consistent, like in Elm? That'll break a few things.
15:14:14 <ongy> looking at this, it was a mistake to make Filepath not at least newtype
15:15:49 <davean> ongy: often is :)
15:17:52 <ongy> I will just migrate all (++) on filepath to (<>) and hope OverloadedStrings fixes the rest :)
15:18:15 <EvanR> :t (++)
15:18:20 <lambdabot> [a] -> [a] -> [a]
15:18:36 <EvanR> seems curiously concrete anyway
15:18:57 <davean> yah, ++ is a wart
15:20:20 <ongy> you could say the same about map, since there's fmap
15:20:31 <davean> ongy: and I generally do
15:20:56 <davean> I'd like us to alias <> to ++ and call it a day, same with fmap/map
15:21:04 <EvanR> i would think <> is easier to swallow than fmap... but maybe not
15:21:30 <davean> EvanR: interesting. I see them as exactly equivilent, what difference do you see?
15:21:42 <EvanR> davean: ah... the forward compatability stage 1 thing here defines conversions to and from String, not ByteString. makes more sense as a first step, and doesnt require mixing up with bytestring package
15:21:57 <ongy> I agree with http://stackoverflow.com/questions/6824255/whats-the-point-of-map-in-haskell-when-there-is-fmap/6824333#comment8112310_6824333 but with Monoid in Prelude (++) is somewhat useless
15:22:31 <knupfer`> ongy: You want to say with Semigroup in Prelude?
15:22:38 <ongy> EvanR: also allows for OverloadedStrings, which I think is nice
15:23:11 <EvanR> yeah...
15:23:13 <ongy> I thought (<>) is infix mappend and (<>) for [a] is (++)?
15:23:21 <EvanR> :t (<>)
15:23:23 <lambdabot> Monoid m => m -> m -> m
15:23:23 <knupfer`> besides, why do we have `stimes`? Seems to dangerous to me.
15:23:43 <ongy> :t stimes
15:23:43 <EvanR> provides option for more efficient ... times
15:23:45 <lambdabot> error: Variable not in scope: stimes
15:25:11 <knupfer`> stimes 0 (Left 1)
15:25:12 <davean> knupfer`: its important for the efficiency of some instances?
15:25:34 <knupfer`> this errors out
15:25:40 <EvanR> stimes :: Integral b => b -> a -> a
15:25:46 <EvanR> so dont use 0 or negative
15:25:54 <EvanR> its the usual issue
15:25:57 <davean> knupfer`: the docs say that
15:26:09 <knupfer`> Yeah, I dislike partial functions.
15:26:25 <EvanR> with Int being conventional cant really help it
15:26:37 <knupfer`> Obviously (stimes 0) doesn't make sense, because it isn't necessarily a monoid
15:27:01 <davean> EvanR: We have Word! Sadly we don't have the typeclasses for it and that doesn't handle zero
15:27:04 <EvanR> or stimes (-1), are you ensuring that you dont use negatives anywhere you use Int as "unsigned' ?
15:27:28 <davean> You want a bad case of this? look at vector
15:27:41 <davean> why do we use Int there? THAT I can't come up with a good excuse for
15:27:42 <EvanR> converting between Word, Natural, Positive, or EveryOddMultipleOfAPrime
15:27:45 <EvanR> is really a drag
15:28:28 <EvanR> the proper way is to use numeric properties on regular number types
15:28:37 <EvanR> then you dont need to reimplement all the math 
15:29:05 <knupfer`> Liquid Haskell to the rescue
15:29:31 <knupfer`> Word wouldn't help in the case of stimes
15:30:22 <knupfer`> stimes :: 1 <= n => Proxy n -> a -> a
15:30:26 <knupfer`> that would be the real deal
15:36:24 <EvanR> :t mtimes
15:36:25 <lambdabot> error: Variable not in scope: mtimes
15:36:40 <EvanR> conspicuously missing for monoids
15:37:19 <EvanR> satisfying the requirement that a number is non zero just to use stimes ... were even farther out than well typed division by zero
15:37:24 <EvanR> er by non zero
15:43:43 <knupfer``> EvanR: mtimes isn't missing
16:05:08 <bobajett> noobie stupid question: how can I read a value into a variable from ghci?  ghci> myInt <- readLn -- doesn't work
16:06:00 <bobajett> myInt <- getLine -- works. why doesn't readLn work?
16:06:53 <bob_twinkles> because GHCI doesn't know that you want myInt to be an Int
16:07:07 <bob_twinkles> if you give it some help, things will work
16:07:16 <bob_twinkles> myInt <- readLn :: IO Int
16:08:20 <bobajett> bob_twinkles: ah, got it! So whereas getLine is only going to read it's value as a string - readLn needs to know what to read the value as. Thanks bob!
16:08:25 <geekosaur> yes
16:08:35 <geekosaur> and in ghci the default type it will choose is the useless ()
16:08:44 <geekosaur> (ExtendedDefaultRules)
16:08:56 <bobajett> cool. Thanks!
16:28:41 <jle`> bobajett: btw, it'd be easier for people to answer if you elaborated what you mean by "doesn't work"
16:28:53 <jle`> bobajett: it'd also help you debug yourself, if you nail down exactly what you mean :)
16:41:59 <bobajett> jle`: yes sorry, that's an excellent point. I had just gotten so confused going in circles reading about "read" "readS" "reads" "Read" that all my brain could quickly reach for was "doesn't work". But you're right that doesn't help anyone much. :-)
16:42:19 <Neo> there is no state
16:44:41 <c_wraith> sure there is. it's just explicit. 
16:44:59 <jle`> bobajett: oh, no need to be sorry!
16:45:24 <jle`> bobajett: just for future reference.  also, one thing that sometimes helps for me is that in looking how to describe what is wrong, i actually end up answering the question myself :)
16:45:51 <lordcirth> Noob question: In OOP, I might make a class Creature, with subclasses Player and Monster.  What is the Haskell equivalent? (I know it's not 1:1)
16:46:34 <lispy> it depends on whether you'll want subclassing
16:46:47 <Koterpillar> lordcirth: that's just one of the solutions in OOP too; what do you want those things to do/
16:46:49 <Koterpillar> ?
16:46:52 <lispy> data Creature = Player | Monster, is an easy way to allow both
16:47:18 <lispy> but if the set of creatures is open, then it's unlikely to do everything you want
16:47:27 <lordcirth> Well, I want Player and Monster to share many fields, but not all
16:47:49 <lispy> in that case, I would define those fields as a type and include it in both
16:48:03 <lispy> data Common = ...; data Creature = Player Common | Monster Common
16:48:09 <lordcirth> I see
16:48:22 <jle`> data CreatureInfo = ...
16:48:30 <jle`> data Player = Player CreatureInfo PlayerInfo
16:48:32 <lordcirth> That works I guess
16:48:54 <jle`> it really does depend on what exactly you want to do with it
16:48:55 <lispy> lordcirth: are you familiar with using composition instead of inheritance? That's really all we're doing.
16:49:35 <jle`> one common pattern in OOP is that you are able to use instances of the subclass as if they were instances of the parent class
16:49:50 <lordcirth> jle`, right
16:50:00 <jle`> handling that also depends on what you really want to do in the end
16:50:08 <c_wraith> really serious games in OOP languages tend to use entity-component systems. those work basically the exact same way in fp
16:50:23 <jle`> you might want to look towards the bigger problem you want to solve in that case
16:50:23 <lordcirth> So in Haskell, I might make a function, damage :: Int -> Creature -> Creature?
16:50:45 <jle`> yeah, or damage :: Int -> CreatureInfo -> CreatureInfo maybe, in the case i made
16:51:13 <jle`> and then you could write a function like mapPlayer :: (CreatureInfo -> CreatureInfo) -> Player -> Player, and explicitly lift it, maybe
16:51:18 <lordcirth> jle`, seems that taking a Creature would be a bit more convenient, or am I missing something?
16:51:30 <jle`> (note that the lens library has some mechanisms for auto-deriving that lifting function)
16:51:37 <lordcirth> Yeah I might uses lenses
16:51:39 <jle`> lordcirth: well, in the system i wrote earlier, there is no Creature
16:51:51 <lordcirth> I'm using the Brick library, and it recommends lenses
16:51:56 <lispy> lordcirth: in FP it's often best to take only the parameters you actually use and then make more general version of the function using that
16:52:07 <jle`> so yeah, if you had data Player = Player { _pCreature :: CreatureInfo, _pName :: String }
16:52:14 <jle`> and you had damage :: Int -> CreatureInfo -> CreatureInfo
16:52:27 <lordcirth> lispy, makes sense I guess
16:52:28 <jle`> you could damage a player with over pCreature (damage 10) :: Player -> Player
16:52:47 <jle`> lift your CreatureInfo function into a Player function
16:52:51 <Koterpillar> ...unless damaging randomly turns a player into a monster
16:53:03 <lordcirth> Koterpillar, lol no
16:53:04 <lispy> lordcirth: that principle is known as the law of demeter, if you want to look it up later to see what it's about
16:53:37 <lordcirth> lispy, cool thanks
16:53:55 <lordcirth> jle`, this is a function called 'over' ?
16:54:14 <Koterpillar> :t over
16:54:16 <lambdabot> ASetter s t a b -> (a -> b) -> s -> t
16:54:18 <jle`> lordcirth: yeah, 'over' takes a lens and and "unlocks" the mapper inside it
16:54:28 <jle`> s/unlocks/unwraps
16:54:37 <jle`> you can think of a lens as a tuple of a mapper/modifier and a getter, sorta
16:54:44 <jle`> so over gives you that mapper that the lens encodes
16:54:50 <jle`> > over _1 negate (10,"hello")
16:54:53 <lordcirth> I have a feeling lenses might take a while to understand
16:54:54 <lambdabot>  (-10,"hello")
16:55:04 <lordcirth> what does _1 mean?
16:55:10 <jle`> _1 is a lens into the first item of a tuple
16:55:17 <jle`> so "over _1 f" mapes 'f' over the first item in a tuple
16:55:26 <lordcirth> ah ok, that's handy I guess
16:55:32 <jle`> 'over pCreature f' maps 'f' over the CreatureInfo field of a Player
16:55:49 <lordcirth> How and where is 'pCreature' defined?
16:56:03 <jle`> you could write it yourself, or use the lens library to auto-define/implement it for you
16:56:04 <lispy> lordcirth: you might already know this, but one of the biggest pitfalls in coming from OOP is to use type classes in place of classes.
16:56:23 <lispy> lordcirth: you haven't indicated that youw anted to do that, but I still feel like I should warn you in case it becomes tempting later
16:56:25 <lordcirth> lispy, I was wondering about them
16:56:34 <jle`> if you create your Player like i wrote above, the lens library will create 'pCreature' for you, based on its naming convention
16:56:48 <jle`> data Player = Player { _pCreature :: CreatureInfo, _pName :: String }
16:56:52 <lordcirth> If I had a lot of very diverse things which could be 'damaged' would it make sense to make a typeclass for them then?
16:56:54 <bobajett> jle`: so was that underscore in pCreature a typo? 
16:57:07 <geekosaur> no
16:57:09 <jle`> lens takes a field called _foo and creates a lens called foo
16:57:13 <jle`> it's just a naming convention
16:57:13 <lispy> lordcirth: possibly, although even if you did that you couldn't have a list of diverse things.
16:57:18 <bobajett> ah ok.
16:57:19 <lordcirth> jle`, just by prepending an underscore?
16:57:33 <jle`> lens's naming convention is to take the field name and remove the initial underscore
16:57:36 <geekosaur> a current wart in haskell is that, since a record field defines a function, you can only reuse field names in very limited ways
16:57:37 <jle`> and then there's your lens into that field
16:57:54 <jle`> but you could name the lens anything you want, really
16:58:02 <geekosaur> and that includes not having smart lenses in their place
16:58:37 <jle`> if you have a field "_pCreature", then it's commonly expected that if you had a lens for it, it'd be called "pCreature".  but this is just a convention, not a fundamental property of lens or anything
16:58:37 <geekosaur> so you define the record field with _ and then use a lens function to have it derive lenses for the fields
16:58:42 <lispy> lordcirth: sometihng you might do instead is make a sum type that holds all the options. Make a list of those and then implement taking damage for that type anyway you like
17:01:19 <lordcirth> The Brick library exports microlens interfaces, should I use that one then?
17:01:21 <lispy> lordcirth: this is one of the big differences between interfaces and type classes. In Java you might make a list that olds things of a particular interface. In Haskell that is still possible, but doing it has some disadvantages and people tend to use other solutions.
17:01:31 <lordcirth> It does say it's compatible with the full one
17:01:53 <lispy> Brick uses microlens so that it is leaner in the case where you don't use lens
17:02:13 <lispy> But really if you are going to use lenses you suhold just use lens (and it is compatible as you say)
17:03:28 <lordcirth> lispy, ok, thanks
17:03:47 <lordcirth> How many Haskell programs use Lens, would you say?
17:03:59 <jle`> um
17:04:01 <jle`> do you want a number?
17:04:09 <lispy> It's pretty popular these days. It's a big dependency but it fixes a lot of warts with the record system.
17:04:23 <lordcirth> Just wondering how popular
17:04:27 <lispy> I would recommend getting comfortable with it at some point
17:04:34 <lispy> There is also #haskell-lens
17:04:42 <jle`> i think that this point, lens is considered a standard part of the haskell ecosystem
17:05:16 <jle`> or at least, using lenses/etc. are normal haskell idioms
17:05:22 <sm> lordcirth: 617 packages use lens
17:06:06 <lordcirth> What's the best place to learn?  The Lens wiki?
17:06:13 <sm> (and 41 use microlens)
17:20:10 <ReinH> And an unknown number include lenses without depending on lens.
17:21:05 <lispy> Yeah, I co-maintain a library like that
17:21:16 <lispy> But it's not on hackage yet anyway :)
17:35:32 <stinkypinkycommi> 99 subroutines on the wall, 99 subroutines, call one down, the system crashes, 0x00f00003 errors on the wall
18:21:05 <grantwu> Aiui bytestring builders support cheap concatenation basically through laziness
18:21:12 <grantwu> What is the difference between a lazy bytestring and builder?
18:21:29 <ReinH> grantwu: lazy bytestring is a list of strict bytestrings
18:21:35 <ReinH> builder is a difference list
18:21:58 <grantwu> A... difference list?
18:22:02 <EvanR> builder has more efficient repeated concatenation
18:22:11 <ReinH> cheap concatenation is not achieved via laziness, but because function composition is constant time
18:22:17 <EvanR> remember when you do ++ on lists, it copies the entire first list
18:22:30 <grantwu> Oh
18:22:38 <EvanR> so if you do ++ many times...
18:22:51 <grantwu> I thought if I do ++ on lists, and then read the entire list, it avoids that
18:22:59 <grantwu> becaue it's lazy... or something...
18:23:15 <ReinH> The problem is when the ++ associate to the left
18:23:24 <grantwu> Ah
18:23:25 <ReinH> then each new ++ requires rebuilding the entire list
18:23:28 <grantwu> When do they associate to the left?
18:23:38 <EvanR> when you append on the right via a loop 
18:23:54 <EvanR> like youd do in a naive template renderer
18:24:04 <ReinH> :t ("hello" ++)
18:24:06 <lambdabot> [Char] -> [Char]
18:24:10 <ReinH> That's the trick.
18:24:27 <ReinH> @google hughes difference list
18:24:29 <lambdabot> http://stackoverflow.com/questions/3352418/what-is-a-dlist
18:24:29 <lambdabot> Title: list - What is a DList? - Stack Overflow
18:24:35 <ReinH> that'll probably do
18:25:14 <EvanR> imagine trying to manually achieve, "foo" ++ ("bar ++ ("baz" ++ "quux")), youd have to begin at the end the "list" of things to join
18:25:34 <EvanR> not the beginning
18:25:57 <grantwu> I see.  So I should avoid relying on laziness with ++ to avoid https://en.wikipedia.org/wiki/Joel_Spolsky#Schlemiel_the_Painter.27s_algorithm ?
18:26:32 <EvanR> ++ works well if the total expression is associating right
18:26:43 <EvanR> which is what concat does
18:27:01 <ReinH> @src concat
18:27:01 <lambdabot> concat = foldr (++) []
18:27:05 <ReinH> note the foldr
18:27:14 <lordcirth> That's a great link
18:28:03 <c_wraith> I mean, laziness works great for creating lists, if you can structure your operation to use.
18:28:24 <c_wraith> But if you can't, don't repeatedly append in a loop.
18:28:47 <c_wraith> difference lists are for avoiding the latter, but they don't use the former.
18:29:22 <EvanR> why is that called a difference list
18:30:19 <c_wraith> no idea
18:30:50 <EvanR> its neither a difference nor a list ;)
18:31:17 <shirt> how do i "throwError" from inside "liftIO" inside ExceptT?
18:31:23 <benzrf> it's a list represented by means of the difference between each step and the next
18:33:34 <c_wraith> shirt: what package is that from?
18:35:01 <shirt> c_wraith: mtl: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html
18:35:42 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
18:35:42 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
18:35:42 --- names: list (clog crobbins vikaton umib0zu Wizek_ herzmeister connrs alanz rcschm jfischoff rnons koray montanonic nyazdani angerman bluezone mizu_no_oto sathish_haskell tripped phileas alienbot i-amd3 vili taksuyu whaletechno Big_G pavonia e14 lambda-11235 refold thewired_ Jeanne-Kamikaze Cetusx dfeuer djapo jay721 nomicflux zugz buglebudabey TrevorBramble tripperx[m] a3Dman I-Win infinity0 Rotaerk Lowl3v3l radvendii pikajude k4rtik redmq markus1189 uglyfigurine csauce)
18:35:42 --- names: list (jaykru AustinMatherne srcerer ludat cstrahan sellout- Gurkenglas dan_f theDon paul0 dolio ContessaTP zar fcpga_te Schn31d3r zero_byte hvr ype urodna heurist newhoggy leothrix jovial[m] Sonderblade skeet70 Koterpillar hamishmack phaskell zv solarus_ systemfault alem0lars unclechu davidar grumble Amadiro srenatus[m] teh[m] undu[m] M-Illandan aminb tiltec[m] wolfcore sbrg toogood2bgood M-krsiehl Faleidel[m] vise890[m] M62844[m] xxblx[m] tagada[m] M-wamaral)
18:35:42 --- names: list (prose[m] heyalex[m] noam[m] cbHXBY1D[m] ShibaInu[m] Oat[m] SeriousBug[m] M-berdario fxrs[m] zizai[m] sssilver[m] knightking[m] jacs[m] M-Shrike brian[m] monomon[m] M-david pkmx[m] M-mistake SegFaultAX Vbitz felixsch mithsv chujji[m] mith[m] leadingthenet[m] rewzn[m] M60452[m] MartialJob[m] schum[m] Soif[m] comexk[m] rdesfo[m] bb010g[m] todd_killings[m] M41px[m] diamaths[m] fazil[m] fr33domlover M-schmittlauch drasich[m] Soup sudoreboot[m] ostuda_lidstva[m)
18:35:42 --- names: list (helloworld1[m] Boreeas SShrike radix M-Magnap noplamodo M41971[m] Profpatsch[m] enthropy spinda zph tjpeden caasih mno2 madidier jroesch_ kritzcreek Zekka|2 aramcheck roconnor OnkelTem cyborg-one argent0 logcat noddy cantstanya copy` rotty mada S11001001 TabAtkins wizonesolutions AllanEspinosa vikram__________ zrl ocharles_ reem_ spicydonuts sclv slackircbot Myrl-saki path[l] nomotif bgamari sdhand riehfp Guest68538 alhariel bollu fairfieldt Malkrith Forlorn)
18:35:42 --- names: list (ctag replay Tinchos XO_Odin kadoban earthy rgr katymoe_ mkurkov angular_mike_ Procrat dwarders Bengi zero7 sdemos guampa Guest61912 edwardk rlr loopspace jxv sephiap lancetw sisir___ tazjin OliPicard ixian NemesisD fkurkowski shelling__ a____ptr marcelh YP-Cloud____ kilimanjaro CARAM__ jcp__ johtso sz0 lukexi jlyndon_ etcinit Tritlo peteretep kipd rfw rstone milessabin jorendorff_ stevenxl joedevivo Rumia louispan ggherdov crough banjiewen ericbmerritt_)
18:35:42 --- names: list (yaknyasn mbrcknl jfokkan__ dstockwell jonrh adelbertc rann Neo g4k shock_ jaimguer cmdv Xe raid nesqi kier ryanpcmcquen dax chrzyki lpaste icedev Lord_of_Life pdxleif slick Dykam esssing brezel chelfi luis dhananjay whiteline drbean Forkk prooftechnique c0dehero Cathy defanor Jaxan m4lvin rom1504 kyren_ minad Guest5077 sim642 teppic borkdude_ dfranke sohum suppi verement Chobbes Rodya neonfuz fold4 Guest85325 brian2 SuperTux88 guios SlashLife eronel)
18:35:42 --- names: list (thorkilnaur frontendloader bsermons KorriX cbaines scinawa1 christiansen` keko-2 rbocquet kori janne- mnoonan radek1 owickstrom fergusnoble divVerent sleepynate vishesh esmiurium chameco rockfruit djellemah hc fnordbert lieven vfs hongminhee akermu CosmicRay taruti Geekingfrog surtn numberten hpd RayNbow`TU raek glowcoil Blkt jackhill schnizzle Ewout Saizan_ Diabolik Quintasan mrlase CindyLinz Clint baweaver djm lambdabot ski_ riscool amiri s4msung valdyn)
18:35:42 --- names: list (Taneb kmic anachrome hyPiRion p_q_ mathu hanDerPeder jotrk_ kav bengt_ sdothum MarcelineVQ jmnk Lokathor Bez_ MindlessDrone sns acowley bkonkle kosorith isovector Amun_Ra dhil ph88^ Digit trism gawen eliasr leat2 posco khisanth__ simukis_ joneshf-laptop ryoia amatecha runeks chbatey w4and0er96 bitonic elrikdante henriquev LordDeath carlomagno glguy king_jah Bigcheese mac10688 kurnevsky Princess17b29a Voldenet mvr_ mattrepl mpw martinbjeldbak doomlord flonk)
18:35:42 --- names: list (ristos zort shirt nakal ThreeOfEight mzf dh vinnie92_ CurryWurst tjayanth fabiopbx fractalcat ahihi theelous3 watabou hive-mind sebastian-w jchia Maxdamantus ljhms joncol geekosaur fengshaun niko LuckyRawApe sooheon Hafydd grouzen ertes Sorella DexterLB kurnevsky2 Insanity_ fiddlerwoaroof ccomb augur thc202 Taylor dyreshark alunduil orion SparkySparkyBoom harfangk vqrs jle` ali_bush Mokosha Jesin s4kashya2 _sjs Vektorweg1 daey slomo otto_s StoneToad desophos)
18:35:42 --- names: list (Ravana Ninja3047 hexagoxel lspitzner exferenceBot latk ab9rf shans_ alx741 hucksy moop darkbolt Immune_ emiliocobos_ tarcwynne_ iphy caw dmoon1221__ yminsky steshaw NeverDie okuu Moto-chan treehaqr dsantiago rkazak ecr hiptobecubic mitchty qguv cheater LnL IndigoTiger yusukesuzuki ploop RouxTheDay jokleinn s4kashya Starfire_ sinopeus JuanDaugherty heyj abbe xocolatl michalrus qryantm Orion3k xplat dedgrant revprez_ rossberg pikhq yulax folsen josephle cods)
18:35:42 --- names: list (Koyaanis bogdanteleaga ddiaz gta3 mspo voter101 Matajon drdo sqrt2 cchalmers KeelOfSteel ClaudiusMaximus srhb cdidd athaller nilsi magicman comboy Sose Guest28451 pgiarrusso tabaqui Zialus gridaphobe magthe TimWolla hackagebot dud free_beard juhp ysshiu kvda piyush-kurur Willis haasn sleblanc SAL9000 jzl MrWoohoo rjeli boothead inr bydo atk Tesseraction kaffepanna albel727 s4kashya1 amuck lordcirth texasmynsted Rarrikins mimi_vx eell thewormkill ipuustin)
18:35:42 --- names: list (Dunearhp sigma9141 rootnode abrar Sgeo dcoutts Pent gienah ethercrow ericsagnes otulp zaquest spoonm latro`a_ flxw noxd burp_ supki dcoutts_ catsup falafel a6a3uh arrdem bluepixel nont_ mach jbalint Wizek Xandaros ongy Tharbakim dredozubov dredozubov_ dmwit mauke dpower s4kashya_ _ashbreeze_ mico_the_mailman norotartagen jtcs atomi kolmodin siloxid nyuszika7h tristanp orcus cschneid ircbrowse max-m dzack1 stass flux cpape Autumndreams mudfog- donwilliam omilu)
18:35:42 --- names: list (dxld acro Xnuk grol PlasmaStar tych0 niluje dualboot predkambrij chirpsalot qz newsham mell shutdown_-h_now bshd przembot happy0 kennyp boj davean topi smithstonw masquerade notdan aatxe Levex edran ycheng johnstein keb ndeine- gothos hausdorff mk-fg Natch urh_ Tehnix`_ Laney rootmos phz_ kishar_ Gothmog_ Ralith__ jstimpfl1 kaol pcapriot1i jrp6_ zhulikas Pucilowski anelson diskie kolko_ noam_ mendez_ johnw tg DrCode edwtjo Tenkeyless_Cooki benj02 prkc arianvp)
18:35:42 --- names: list (Soft irclogger_com niklasb qlkzy nshepperd seliopou_ bind1 MTwister elgot_ monty dibblego Nikotiin1 o`connor_ strixy hsyl20 ernst m1dnight1 tinkyhol1oway [exa]_ hpc pyrtsa Ornedan Eliel ggVGc zenzike javax eyck ps-auxw sgronblo_ johnv__ sevas ebird Desoxy codeman7_ u-ou mt hiratara cyphase hnz martinga_ jnoah julmac nullfxn sdx23 tessier ego Nik05 carc keifer _6a68 grandy sparr georgew miklcct bgyss minsky seanparsons chriswk shwouchk WizJin wahrsagevogel)
18:35:42 --- names: list (buckowski micmus chris2 electrostat Ulrar Elsi bananagram sa1 mpickering stasku_ killtheliterate aristid afcondon mindos_cloud____ xplat|work blubbb {AS} poga lassulus srk Tuplanolla xa0 cin jokester solidsnack jinblack stefan otterdam Liskni_si x1n4u clever ntpttr garphyx`aw wjm parsnip anderson fycth_ Yaiyan cnr carter bsmt mikeizbicki kureta Fuuzetsu sag3 rodlogic AntiSpamMeta tjbp sphaleri1e robin wildleaf_ andromed1-galaxy citaret_ froztbyte codebje_)
18:35:42 --- names: list (xfix_ tek0 schultz_ Zemyla beaky CoconutCrab fps strmpnk orzo nkpart implementation_ herzen fxrs_ myfreeweb_ zmanian____ beckyconning__ niteria jmct eatonphil Flaeme greenbagels_ jml jud brisbin astocko obiwahn pkogan prefork cdsmith_ dmiles Benzi-Junior Athas wedens rotcpy pharaun SamuelB tsani barrucadu whoops Sigyn padre_angolano Axman6 MrElendig ohsix bartavelle thomas bounb bshum1 Madars tmciver Qommand0r ortmage_ tnks majoh zomg Twey Chousuke jlouis)
18:35:42 --- names: list (nurupo tomus ahf mattp_ catern intothemountains timrs2998 Oxyd d3lxa joachifm tumdedum pratch Moyst sword_smith Deadhand buoto tristero troydm c-rog MitchW c_wraith Saimeidae angseus kloeri averell thallada quangl mjo ktomz bencryption theorbtwo FransWillem tctara sm besenwesen shyn Nahra hughrawlinson alphonse23_ billstclair Brando753-o_O_o si14 Merv incomprehensibly andreypopp codedmart adulteratedjedi bigs monad_cat nathyong JackMc Rabbit_ Arguggi Guest7479)
18:35:42 --- names: list (wrmsr Lutin` maerwald ephemeron wagle @ChanServ APic mikeplus32 dogui so marmoute hansihe fabianvf Guest48686 IanKelling nekomune thoros kungp Guest18807 GGMethos elementalest Ring0` watersoul dustinm cgfbee skyres capisce acertain jgertm jamesbvaughan SolarAquarion mdarse nille m1dnight_ erikd Cerise killerpty wayne luigy oherrala Wamanuz2 ben monkeyiq Phillemann K0HAX sbjorn fall_ mjo_ joe9 hemite tomjaguarpaw monochrom snoogie ReinH_ bdeferme emeritusnot)
18:35:42 --- names: list (eyenx_ lyxia mkloczko_ ryantm bjobjo platz_ dqd trajing- mudfog DustyDingo bairyn Paks TommyC grantwu Deewiant mw mgaare statusbot pacak cmn alpounet quaestor Jonno_FTW amalloy_ abh_ baetheus_ jstolarek knyppeldynan samgd_ isomorph1smes bitemyapp ybit_ sujeet RageD benzrf tolt yamadapc schjetne japesinator dju staticfox pingu_ worch henrytill electrocat alercah phadej eddsteel officer_raccoon haircode gpampara vervain pmade potatoe ziman byorgey yrdz)
18:35:42 --- names: list (trevorriles Factionwars runawayfive lispy pfoetchen nathanel liyang robtaylor jgornick nshepperd_ Ankhers joeyh lanodan cmr Morgawr ent bcoppens kshannon netblaze hodapp int-e M2tias kosmikus zerokarmaleft bd_ ephess_ geppettodivacin shapr metaf5_ kipras`away _kit_ horatiohb odamn adarqui foobars ijp dan64 Adeon nopf mrm l3france [swift] ddima ngWalrus ft Fubar^ spacebug urdh tdammers Akii epta daf ec\ AppleJacks24 ramatevish yeltzooo richi235 DDR emmflo xxpor)
18:35:42 --- names: list (Igloo bjs tusj Drezil dpepsilon carter-znc yorick obihann simony nwf peddie flebron adamCS Nycatelos avn daishan joncfoo kyagrd da-x_ dpn` tgeeky xaimus t0m0 opios nathanic squisher valkyr2e cyberlard petercommand cocreature xnyhps qinusty wting stelleg cjh` sivs staffehn intelux t0mb0_ acfoltzer vikraman frug72 Klumben gnusosa xacktm cjwelborn codebam solatis ario sjl_ greeny lattenwald sshine Hijiri Guest10767 tippenein SenpaiSilver pieter klugez jkarni)
18:35:42 --- names: list (hiredman JRHaigh pleiosaur trampi cic jrib1 funfun geal karls bshelden asm89 Purlox martinr_ brixen nitrix KaneTW statusfailed wrengr_away Kneiva jlewis oelewapperke Freundlich PHO andjjj23_ Solarion kini HalfEatenPie haldean adraenwan larion_ BrianHV_ JPohlman1 joehillen jluttine Reyu tokik taktoa deni marienz _Shandy siddhu irishsultan hex0punk1 iross greymalkin dunj3 scopedTV Frankablu_ ao1ei8 johl toure gargawel parenthetical ninefingers ppnkk ncl28 kriztw)
18:35:42 --- names: list (sajith kwantam LeaChim Ranhir mmierz RGamma Fylwind heinrich5991 cross zymurgy Ezku_ EvanR chronon-io_ etabot joeytwiddle mantovani betawaffle bob_twinkles amiller Tene hxegon jpl_ relrod Ke Marqin nickpascucci osfameron canta nilOps exio4 tv n__dles Belgarion0 lukky513 stux|RC-only mrowe hydraz jimki_ eagleflo Jaak_ ido mrd koala_man Phyx- mmaruseacph2 tjt oldsk00l saidinwot1 Bane^ Vq _flow_ hegge opqdonut nshepperd1 armlesshobo telmich `0660_ dilinger mokus)
18:35:42 --- names: list (koz_ arw_ huonw majjoha ion PalTale tomaw robogoat iliastsi jophish jix abra0 mero ricardo82 oberstein hungryhugo eikke PanicSkittle iteratee fryguybob DigitalKiwi uwap Edoxile andreass scared Hakey RazorX- navilan cynick indiffernet_ thebnq brolin_empey lulf mniip mak` tomku Guest49740 MasseR segfaulthunter Speed abk7 luite_ absence Stratege nerdystreetrat asjo jw358 swhalen sdrodge sleezd Baughn spion arc- wamaral lpsmith spaceships noctux amontez jvanbure)
18:35:42 --- names: list (sLite lenstr kjanosz yarou filibustr Profpatsch saurik quuxman liste cjay SiCC benjamincrom fmapE ollef wtw Elision vin-ivar mbrock ajmccluskey dgonyeo quoboo shennyg avdi PotatoGim sbauman phuu gornikm Xorlev dsm AlainODea lexi-lambda fuziontech nbouscal stephe thoughtpolice kantokomi ambrosia Guest31921 laudiacay dschoepe Philonous DANtheBEASTman SLi alang Majiir reynir idupree etrepum kaste metalrain paf31 Tristan-Speccy tero- Reisen psmolen_ zxtx eL_Bart0)
18:35:42 --- names: list (marmalodak __main__ frolv mtesseract1 linduxed gsingh93 tswett brennie amx anoe_ lucz Jello_Raptor obadz danieli jrslepak naudiz jtobin ReinH enolan tharper Scorchin MorTal1ty mankyKitty trig-ger zpconn__________ wyvern pchiusano XMunkki noexcept fingerzam Biohazard_ theolaurent gabiruh tekacs krgn Rembane ynyounuo mbwe unbalanced unsymbol 7ITAAABAS coeus bbee lachenmayer pelegreno___ mceier lstrano Eagle_Erwin imalsogreg aweinstock RevJohnnyHealey qmm)
18:35:42 --- names: list (freekevin vodkaInferno ChongLi e integral)
18:36:56 <Koterpillar> shirt: if you're "inside liftIO", you're not in ExceptT
18:37:26 <shirt> Koterpillar: i know, that's why i can't do it. but is there some magic way?
18:37:34 <geekosaur> ...
18:37:46 <EvanR> shirt: youll need to return an error code then respond by throwErroring
18:37:47 <Koterpillar> there is no magic
18:37:52 <EvanR> or you could throw an error in IO
18:37:59 <Koterpillar> split away the bits that need liftIO
18:38:19 <Koterpillar> instead of liftIO $ do { a; throwError; b }
18:38:27 <Koterpillar> do { liftIO a; throwError; liftIO b }
18:38:47 <shirt> Koterpillar: i can't do that because i have "withFile" for the duration of the liftIO
18:38:53 <EvanR> you can catch the IO error right inside the liftIO, respond by converting to throwError after you return
18:39:12 <EvanR> and that pattern can be extracted out into its own function
18:39:20 <shirt> EvanR: hmm... that might work
18:39:25 <dibblego> @djinn ((a, b) -> c) -> a -> b -> c
18:39:26 <lambdabot> f a b c = a (b, c)
18:39:33 <dibblego> @hoogle ((a, b) -> c) -> a -> b -> c
18:39:36 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
18:39:36 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
18:39:36 <lambdabot> CorePrelude curry :: ((a, b) -> c) -> a -> b -> c
18:39:41 <nitrix> ertes: What was the bigger problem in reflex again?
18:40:39 <EvanR> shirt: i have to say... ExceptT over IO ?
18:40:50 <EvanR> IO already has exceptions...
18:41:14 <nitrix> ertes: (And possibly, how does wires handle that issue in comparison? But I'm asking that second question after, hoping it wont bias the first one.)
18:41:22 <shirt> EvanR: i am using "servant" package. that's the way they authored it
18:41:27 <EvanR> gah
18:41:41 <EvanR> what happens if you just throw an IO error?
18:41:55 <joe9> shirt, https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/exceptions-best-practices.md check out the ExceptT anti-pattern
18:42:41 <joe9> anyone know of any samples using list-trie to represent a file system tree?
18:43:14 <shirt> joe9: i am sure the servant authors have seen that :=
18:43:29 <geekosaur> joe9, the exception stuff in servant is probably returning an HTTP error, and makes sense in context. I expect it's not intended for *this* particular usage
18:44:25 <joe9> geekosaur: ok, Thanks.
18:44:35 <shirt> geekosaur: i dunno... servant could have just used plain IO, and told us to throw a special IO "ServantException" for returning HTTP errors
18:45:01 <geekosaur> much of servant is not in IO, you can do quite a lot in pure code where you need an HTTP "exception"
18:45:10 <geekosaur> so yes, it does make sense when used correctly.
18:45:32 <geekosaur> in fact, it's using it so you can produce HTTP errors from pure code, not just from IO
18:46:10 <Clint> what's kind `Meta' mean?
18:46:21 <geekosaur> if you are doing things in IO yourself, you should handle errors/exceptions appropriately, which may or may not involve an HTTP error return
18:46:59 <shirt> i think that every servant handler must do some sort of IO (unless it is just returning a constant result or result based only on http request; both are useless in practice)
18:47:44 <x1f577> any suggestions for lazily parsing a 55GB xml file? I need to transform a wikipedia data dump into a set of files, one for each article, and their mappings to the category taxonomy
18:49:43 <joss> Hello people
18:49:55 <joss> iI have this error on when i Try to complie
18:49:58 <joss>     Could not find module ‘Graphics.UI.Gtk’
18:50:18 <geekosaur> Clint, https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/GenericDeriving#Type-levelmetadataencoding
18:50:18 <joss> anyone can tell me why ?
18:50:31 <Clint> geekosaur: thanks
18:50:47 <Clint> joss: do you have that module installed?
18:51:06 <joss> That module is gtk?
18:52:38 <Clint> joss: gtk is a package that has a module named that, and so is gtk3
18:52:57 <EvanR> x1f577: if XML libs can do this, i would be impressed as hell
18:53:23 <joss> Clint, where can i found this?
18:53:39 <joss> in homebrew I have the list
18:53:41 <joss> gtk+                                     spring-loaded gtk+3                                    spring-roo gtk-doc                                  sproxy gtk-engines                              sql-translator gtk-gnutella                             sqlcipher gtk-mac-integration                      sqldiff gtk-murrine-engine                       sqlite-analyzer gtk-vnc                                  sqlite gtkdatabox           
18:54:06 <joss> gtk+
18:54:10 <joss> and gtk+3
18:54:23 <joss> which is correct?
18:54:52 <geekosaur> um
18:54:59 <geekosaur> those are homebrew packages, not haskell packages
18:55:56 <joss> so...i don't know where can I found this packages
18:56:01 <x1f577> EvanR: I'm trying to find one that doesn't do the validation that requires the whole thing to be in memory
18:56:05 <joss> :'(
18:57:28 <benzrf> what's the best way to chop an image into subrectangles and then shuffle and flip them around?
18:57:31 <benzrf> from haskell
18:57:49 <EvanR> repa?
18:58:02 <EvanR> https://hackage.haskell.org/package/JuicyPixels-repa
18:58:42 * hackagebot u2f 0.1.0.1 - Haskell Universal Two Factor helper toolbox library thing  https://hackage.haskell.org/package/u2f-0.1.0.1 (ebutleriv)
18:58:56 <geekosaur> joss, I told you that yesterday. are you using cabal or stack for haskell? (or neither? in which case I'd suggest using either a cabal sandbox or stack rather than working outside of a sandbox)
18:59:14 <benzrf> i dont know anything about using repa >.>
19:00:09 <EvanR> its the high powered array manipulation lib
19:01:19 <EvanR> this thing seems to give you a (newtyped) Array D DIM3 Word8
19:03:08 <joss> geekosaur, i just  downloaded installer from this page https://www.haskell.org/platform/mac.html
19:03:36 <EvanR> delayed, 3d array of word8
19:03:36 <geekosaur> yes, fine, but that still leaves the question of what you are doing with it and how
19:03:47 <EvanR> i assume the 3rd dimension is color channel
19:05:02 <EvanR> the slice operation gives you a sub array
19:05:11 <joss> When I try to use cabal and stacks commands on terminal its ok... I mean I have those commands active
19:07:26 <joss> After downloaded I just follow the steps: Download Xcode, add Path to bash_profile and then I can run ghci on terminal and load modules, no more than that
19:22:35 <jchia> Question about ClassyPrelude/Data.MonoTraversable: I'm starting to use ClassyPrelude and see that there are 'generic' functions that operate on containers, like insertLookupWithKey, so I don't need the type-specific functions from e.g. Data.IntMap.Strict. However, to even have a container to work on, previously, I would use something like Data.IntMap.Strict.fromList or Data.IntMap.Strict.empty. When I'm using ClassyPrelude/Data.MonoTraversable, are there 'gene
19:23:16 <jchia> I couldn't find anything from scanning the mono-traversable documentation.
19:30:27 <joe9> geekosaur: I am maintainingg a list  of files and a list of file descriptors. For each file in the first list, I am maintaining a list of file descriptors open for that file. In the list of file descriptors, I am maintaining the index of the file in the first list.
19:30:48 <joe9> basically, a 1-to-many mapping, that I am maintaining manually.
19:31:01 <joe9> Just want to check if there is any data structure that can make this easier.
19:31:57 <joe9> when the file is deleted, ensure that all the file descriptors are closed, when a file descriptor is closed, ensure that it is removed from the list of file descriptors maintained with the file.
19:33:12 <joe9> jchia: do not bother with classy prelude, check out basic-prelude or protolude.
19:33:57 <joe9> jchia: there is a reddit post on the troubles when using classy prelude. it sounds cool. but, the ghc errors get very hard to decipher.
19:34:53 <geekosaur> joe9, I'm not aware of one offhand
19:37:45 <joe9> geekosaur: what do you think of just maintaining a Bimap of list of (FileDescriptors <-> Files)? I am not sure if a Bimap allows having duplicate keys. such as, fd 1 -> file 1, fd 2 -> file 2, fd 3 -> file2, etc.
19:38:50 <jchia> joe9: if it's that bad, i would like to know before committing to it. any references with more concrete info?
19:39:20 <jchia> i couldn't find warnings about ClassyPrelude in r/haskell
19:39:23 <geekosaur> I would expect they don't. I am also thinking that any such structure is probably inherently application specific to the point that there's no point in making a common package
19:40:00 <geekosaur> re BiMap: "inserting a pair of elements will cause any overlapping bindings to be deleted."
19:40:11 <geekosaur> so, both keys will be forced to be distinct
19:40:51 <joe9> geekosaur: found this, http://stackoverflow.com/a/9234807 . acid-state and ixset. never used them. any experiences?
19:40:51 <dk007> hello
19:41:00 <lambdabot> Hello.
19:42:45 <geekosaur> joe9, ixset looks like it will do it, but seems kinda heavy syntax-wise. (acid-state isn't really part of it, aside from that it uses ixset to do something you don't need)
19:43:18 <geekosaur> so I guess people do write such general libraries... but you pay for the generality with syntax
19:45:04 <joe9> geekosaur: ok, Thansk.
19:45:11 <joe9> s/Thansk/Thanks/
19:45:34 <joss> geekosaur: I can use cabal and stack commands from terminal
19:45:43 <geekosaur> yes, I saw that
19:45:57 <geekosaur> yes, fine, but that still leaves the question of what you are doing with it and how
19:46:19 <joe9> jchia: I found that reddit post when I was researching classy prelude. Someone had posted that they switched their large code base to clasy prelude and had to switch it back as the error messages got indecipherable. I do not have the time to search for the post now. good luck finding it.
19:46:49 <joss> So, Should I use this commands to install gtk
19:47:13 <geekosaur> all I know is you want the gtk module for something. you WILL want to use it in some kind of sandbox, and you should make that choice before actually installing it because you need to install it appropriately for whatever sandbox you are using
19:47:18 <jchia> joe9: OK
19:47:20 <joe9> jchia: I kind of faced a similar situation when using Diagrams. great package, lots of flexibility, but the error messages were just so hard to understand.
19:47:45 <joss> Actually, I just try to compile a program
19:48:24 <jchia> joe9: I'm right now mainly interested in not having to wrestle with multiple versions of length, null, empty, etc from things like Vector, Map, IntMap and classy-prelude seems to have a solution. Do you know of other preludes that address this?
19:48:24 <joss> My code say
19:48:25 <joss> import Graphics.UI.Gtk
19:48:36 <acertain> i want something like [(Int,a)] that 1. has log lookup and 2. doesn't force the whole spine of the tail when consing (forces a finite amount of it)
19:48:39 <geekosaur> (this isn't even haskell specific, particularly. ruby folks will tell you to use rbenv or rvm, python folks will tell you to use pyenv/virtualenv, etc. and you need to do so *before* installing their respective interface packages)\
19:48:43 <joss> but, Obviously, I don't have this module
19:48:52 <joe9> cool package: http://hackage.haskell.org/package/vacuum-cairo
19:48:58 <acertain> is there one somewhere?
19:49:11 <EvanR> Sequence a ?
19:49:32 <acertain> really? i thought that was not lazy enough
19:49:36 <glguy> Data.Sequence's Seq is spine strict
19:49:37 <EvanR> doesnt really give you [(5,'c'), (2,'a')] 
19:49:44 <joss> the question is how can get this module ... 
19:49:44 <geekosaur> acertain, I'm tempted to point you to Data.IntMap
19:49:53 <geekosaur> joss, did you even read what I said
19:49:56 <joe9> jchia: use qualified for Vector, Map, IntMap, etc.. It sounds stupid, but, it keeps things simple.
19:50:05 <glguy> It has some laziness built in, but it needs to know enough about the structure to keep things balanced
19:50:27 <acertain> EvanR, don't need that or rather inserts will be ordered
19:50:34 <EvanR> ah
19:50:36 <acertain> geekosaur, not lazy enough i think
19:50:48 <geekosaur> hjoss, if you absolutrely insist then you can just plow ahead and install stuff. and you WILL regret it. Use a sandbox.
19:50:58 <EvanR> acertain: theres... Bag a
19:51:07 <EvanR> but not going to be guaranteed log lookup
19:51:14 <jchia> joe9: I know a lot of people do that. The meaning is clear but I find the frequent use of "Foo." distracting. It's also harder to change if I decide to use a different type of container later.
19:51:14 <ab9rf> yeah, nobody wants to be stuck in cabal hell
19:51:23 <ab9rf> at least if you use a sandbox you can just wipe it out and start over
19:52:20 <joss> Ill do, ty geekosaur
19:52:41 <sgronblo_> Could someone remind me of the rules of <*>? If you have f :: a -> b -> c, M => Applicative in ma :: M a and mb :: Mb. Is it then ok to start exeucting ma and mb at the same time in f <$> ma <*> mb ?
19:52:43 <geekosaur> so you need to decide which one you are using (cabal or stack), then use that to install the module
19:52:57 <joe9> glguy:  can you please fix the module url's ? http://hackage.haskell.org/package/ixset
19:53:01 <ertes> nitrix: three reasons: 1. relevant for high-frequency real-time applications: <https://github.com/reflex-frp/reflex/issues/63>, 2. i could live with this one, but it can likely be fixed: there is a constant overhead factor that becomes noticable as you scale up, 3. the semantics can't handle randomness, so there is a rather ugly controller round-trip, if you need e.g. random initialisation
19:53:02 <ReinH> sgronblo_: the laws are in the documentation
19:53:07 <geekosaur> X install gtk2hs-buildtools; X install gtk -- where X is either cabal or stack
19:53:19 <glguy> acertain: You might be interested in the MemoTrie package
19:53:40 <geekosaur> but if you are using cabal, run "cabal sandbox init" first, and if you are using stack then you should "stack init" first.
19:53:47 <joe9> jchia, changing is just a sed/grep. The amount of time you gain from a good error message (imho) offsets the advantage.
19:53:53 <geekosaur> to set up the sandbox. Don't run both, pick one.
19:53:58 <EvanR> ertes: dont handle randomness?
19:54:10 <sgronblo_> ReinH: ok ill have a look, thanks
19:54:11 <ertes> nitrix: the first two can be fixed, and i could live with the third one, but i don't really know anything about the current implementation (Spider), so i had to make a choice: "learn reflex or write that wires thing you wanted to write for ages"
19:54:28 <lordcirth> :%s/Foo\./Bar\./
19:54:31 <glguy> jchia: The overhead of the non-standard prelude isn't free
19:54:59 <glguy> joe9: http://hackage.haskell.org/package/ixset-1.0.7
19:55:06 <ertes> EvanR: you can have randomness, but like everything else it must be fed from outside (or you have to choose hard-coded initialisation values, which is probably not a good idea)
19:55:31 <jchia> glguy: What kind of overhead? Do you mean compile-time or run-time?
19:55:44 <EvanR> ertes: well, you mean you want a "random" starting seed?
19:55:55 <glguy> all of the above, compile time, runtime, programmer time
19:55:58 <EvanR> how would anything pure ever pull that off
19:56:22 <EvanR> take the seed as the argument to the program
19:56:27 <ab9rf> make the seed as part of the program's input
19:57:01 <EvanR> then you can get different seeds, or you could reproduce a previous experiment
19:57:18 <ertes> EvanR: yeah, and exactly…  normally i would create, say, a (Behavior Blah) within the application code, but because of this issue i need to construct it in the controller, and the application has to update it via an event
19:57:27 <EvanR> i thought you meant you wanted a signal which was really noisy
19:57:43 <ertes> EvanR: it's okayish, so if this were the only issue, i would most likely just use reflex
19:57:58 <EvanR> doing like video poker and having an "event faster than tick event tick event" "spin" the rng is really inefficient
19:58:18 <joe9> glguy: Thanks.
19:58:22 <EvanR> and violates time if you look at the signal twice at the same time and get two answers
19:58:49 <ertes> EvanR: a noisy signal isn't really enough though, because at any particular point in time its value will be constant
19:58:59 <EvanR> thats the point
19:59:14 <EvanR> how else would it make sense?
19:59:27 <ertes> wires allows you to have effects at time zero
19:59:36 <ertes> and switching resets time
19:59:43 <joe9> jchia: for what it's worth, I had good experiences with basic-prelude. I like the protolude author's comments about protolude's origin.
20:00:10 <EvanR> i dont understand the use case for having more than 1 value of a signal at the same time...
20:00:33 <fatX1136> haskell programmers should try lisp, it's much nicer
20:00:54 <ertes> EvanR: huh?  that's not what i do
20:01:43 <EvanR> are you saying you want a C rand() command
20:01:48 <ertes> EvanR: nope
20:01:54 <EvanR> alright
20:02:16 <ertes> that would be horrible =)
20:02:44 <sgronblo_> ReinH: Is the answer related to this statement? "instances can perform analysis of computations before they are executed, and thus produce shared optimizations"
20:03:29 <EvanR> i just dont understand the form of randomness implied here
20:03:43 <EvanR> like what reflex would be missing
20:03:44 <ertes> EvanR: reflex does the right thing IMO, and the randomness thing is really a minor inconvenience…  i could live (and have lived) with it
20:04:22 <jchia> joe9: I'm checking those two out. Is there a prelude alternative that address the problem of the 'legacy' functions working with String (e.g. show) but Text being actually more suitable for 'real' code? For example, classy-prelude has tshow.
20:05:10 <ertes> EvanR: in fact reflex is still my number one default choice for FRP…  wires is for a rather narrow use case:  high-frequency applications
20:06:30 <glguy> show using String isn't generally a problem given that it's a debugging tool. Text and ByteString both have builder interfaces for rendering large amounts of textual outputs
20:06:55 <ab9rf> yeah, i wouldn't use show in performance code
20:07:19 <ab9rf> so this sounds to me like a solution in search of a problem
20:08:51 <jchia> show is easy to use. I sometimes use haskell as a "scripting language"
20:09:03 <jchia> so performance isn't always important
20:09:28 <jchia> but if i mix String and Text in my codebase, the code is confusing
20:10:24 <joe9> jchia:  protolude author has an arcticle about that.
20:10:54 <joe9> jchia: s/that/replacing string with text/
20:11:21 <joe9> jchia: I like groom. I found Data.STring.Conversions helpful. You just need cs function to do much.
20:11:22 <jchia> joe9: http://www.stephendiehl.com/posts/strings.html ?
20:11:38 <jchia> what's "cs function"?
20:13:45 <EvanR> cs :: ConvertibleStrings a b => a -> b
20:13:48 <EvanR> in that package
20:14:16 <EvanR> it seems to automatically convert anystring into another
20:14:42 <EvanR> so fromIntegral only not as long
20:18:33 <jchia> I've played with ConvertableStrings a few times. groom looks like an interesting show replacement
20:29:45 <joe9> jchia: groom uses show internally. For debugging, I use groom . When not, it is better to stick with Text/ByteString. I noticed a big performance change when I switched from String to Text in one app.
20:35:14 <parsnip> any ideas on my fail to `stack repl' error? http://sprunge.us/BTUS
20:36:14 <glguy> parsnip: "malformed mach-o: load commands size (33520) > 32768)" indicates that you upgraded to Sierra too early
20:36:23 <parsnip> lol
20:37:51 <glguy> parsnip: You can read more at https://ghc.haskell.org/trac/ghc/ticket/12479 
20:39:26 <parsnip> okay, so realistic solution is make sure my remote linux can build my website, i suppose. 
20:39:38 <parsnip> since in long run, that would be a good idea. 
20:40:26 <parsnip> glguy: thank you, for identifying problem. 
20:44:27 <coleman> are definitions of list comprehensions functions?
20:44:45 <coleman> Is it good practice to give them type declarations?
20:45:37 <Koterpillar> what is a function?
20:45:40 <glguy> coleman: Your question doesn't really make sense. list comprehensions aren't functions, it's not necessary to annotate their types in general
20:46:44 <coleman> glguy: if I say `foo = [x | x <- [1..10]]`
20:46:55 <coleman> glguy: should I add foo :: [] ?
20:47:00 <coleman> is that common practice?
20:47:11 <Koterpillar> is it a top level definition?
20:47:11 <coleman> or Enum or something? I'm brand new
20:47:13 <glguy> coleman: It's common practice to annotation top-level definitions
20:47:35 <coleman> glguy: okay, thanks
20:47:52 <Koterpillar> also, [] isn't a valid type
20:47:53 <pavonia> Note that [] isn't a complete type
20:47:55 <geekosaur> and some of us also annotate inner definitions (let/where) because it helps localize type errors better (inference is handy except when it propagates a type bug)
20:48:05 <glguy> It's a complete type, it's just not the type of `foo'
20:48:19 <coleman> glguy: what is the type of foo in this case?
20:48:22 <pavonia> What?
20:48:32 <Koterpillar> :t [x | x <- [1..10]]
20:48:33 <lambdabot> (Num t, Enum t) => [t]
20:49:01 <ab9rf> heh
20:49:06 <lispy> When you said complete type you probalby meant kind *
20:49:17 <coleman> Koterpillar: thanks
20:49:38 <pavonia> Right. Are "types" of other kind considered types too?
20:49:42 <ReinH> Yes.
20:49:47 <geekosaur> pavonia, in a type level world a type of kind other than * is useful
20:50:01 <coleman> What sort of fields do you guys work in?
20:50:02 <geekosaur> they just can't have values associated. so it's a complete type, but not the type of a value
20:50:03 <ReinH> Everything that has a kind is a type.
20:50:14 <lispy> coleman: computer science :)
20:50:21 <coleman> lispy: academic?
20:50:23 <lispy> nope
20:50:30 <coleman> lispy: what does the company do?
20:50:32 <lispy> I work at galois
20:50:35 <glguy> pavonia: sure, types can have more kinds than *
20:50:40 <lispy> (dunno if you know them)
20:50:58 <glguy> pavonia: It's like how functions are still values
20:51:20 <coleman> lispy: i live in portland but i don't know them
20:51:37 <lispy> coleman: you should stop by the next time we have a tech talk that is open to the public
20:51:44 <lispy> coleman: do you use calagator?
20:51:49 <coleman> lispy: I used to
20:52:06 <coleman> lispy: I mostly stay at school now
20:52:12 <lispy> I put talks on the calendar there and also on our twitter and g+ page
20:52:20 <coleman> lispy: cool
20:52:55 <pavonia> glguy: That probably makes sense given that we have type familes an such, but it feels a bit strange to me to call [] a type rather than a type constuctor
20:53:01 <lispy> if school is PSU then we're not far, otherwise your mileage may vary (get it!)
20:53:07 <coleman> lispy: reed
20:53:07 <glguy> pavonia: You're confusing categories
20:53:15 <geekosaur> pavonia, you would have to get into type level programming to see its usefulness
20:53:23 <coleman> lispy: transferred from PSU
20:53:32 <glguy> pavonia: Maybe and Bool are type constructors, the capitalized atomic names of types that you can match on
20:53:35 <lispy> coleman: nice
20:53:44 <glguy> pavonia: It's like how Just and True and data constructors
20:53:44 <geekosaur> as long as you are working on value level, your viewpoint makes sense. once you start working on type level, things get more interesting :)
20:54:21 <glguy> pavonia: Other things in the category of "type constructor" are "type synonym" and "type variable"
20:54:22 <coleman> lispy: wow pietro belluschi built the commonwealth buildin
20:54:26 <coleman> building*
20:54:47 <pavonia> glguy: How is [] different from Maybe and Bool expect for syntax?
20:54:59 <lispy> coleman: I know nothing about architecture, but yes the building had a pretty famous architect and is on a regstry of important buildings for other reasons
20:54:59 <glguy> [] Maybe and Bool are all type constructors
20:55:16 <geekosaur> and [] and Maybe are both kind * -> * whereas Bool is kind *
20:55:21 <coleman> lispy: idk either he designed a few things for reed
20:56:29 <lispy> getting back on topic, I hope you enjoy learning and using Haskell
20:56:40 <coleman> lispy: do you actually use haskell for cryptography?
20:56:55 <lispy> no, but cryptol is in haskell
20:57:05 <coleman> lispy: what do you use haskell for?
20:57:27 <lispy> I don't use haskell as much as I would like. I tend to do a lot of systems level programming.
20:57:32 <coleman> lispy: ah
20:57:52 <coleman> lispy: that's the bummer about most functional I tihnk
20:58:19 <lispy> You might ask glguy if he can talk about some of the stuff he does in haskell
20:58:45 * hackagebot here 1.2.9 - Here docs & interpolated strings via quasiquotation  https://hackage.haskell.org/package/here-1.2.9 (TaylorHedberg)
20:58:47 <ReinH> I've used Haskell for cryptography
20:59:02 <ReinH> Well, my team did.
20:59:11 <coleman> ReinH: how was it?
20:59:13 <pavonia> glguy: So what other categories are there beside type constructors?
20:59:16 <glguy> pavonia: It might help to see that (Either Bool) is not a type constructor, even though it has kind (* -> *). It's the application of the type Either to the type Bool (both of which are type constructors)
20:59:18 <ReinH> Better than anything else I've tried.
20:59:30 <coleman> ReinH: cryptol?
20:59:49 <glguy> pavonia: There are type variables, there are type applications
20:59:59 <ReinH> No.
21:00:30 <ReinH> Custom stuff. The author of most of the Haskell crypto libraries was on our team.
21:00:47 <coleman> ReinH: oh cryptol is not what I tohught it was
21:00:52 <lispy> ReinH: vincent?
21:00:52 <glguy> pavonia: given (f :: * -> * -> *) and (a :: *),  (f a :: * -> *), but (f a) is not a type constructor, it's the type variable f applied to the type variable a. No type constructors involved
21:01:56 <lispy> glguy: I like that example
21:01:58 <pavonia> Hhm, okay
21:02:41 <ReinH> lispy: yeah
21:03:22 <lispy> I needed an ssl library and I was greatful to be able to use his stuff (connection?) because pure haskell meant easier dependencies
21:03:54 <glguy> pavonia: Ah, a more complete answer to your question about other peer names to type constructor comes from Haskell 2010 pg 10. There are 6 kinds of names: variables, constructors, type variables, type constructors, type classes, modules.
21:03:57 <lispy> We may still switch to openssl bindings, but having a pure haskell thing to get off the ground was awesome
21:04:00 <glguy> https://www.haskell.org/definition/haskell2010.pdf
21:04:31 <lispy> clearly f a :: * -> * is a module
21:08:41 <pavonia> On p.38 they also mention type application as another category
21:09:48 <glguy> pavonia: type application is a way to form a type, certainly
21:10:24 <ReinH> Ok, by "category", you don't mean "category". I was confused for a second.
21:11:12 <glguy> The "class or division" definition, not the "unifying math theory" one
21:12:45 <ReinH> I mean, they also form a category.
21:16:49 <coleman> How would I go about representing a syntactic tree in haskell?
21:17:02 <coleman> I can do it in scheme wil something like '(not (not p))
21:17:22 <coleman> But haskell's type system won't allow it. What do you do?
21:17:46 <coleman> a list can't be a sibling with a string
21:17:55 <Koterpillar> coleman: data Expr = P | Not Expr
21:18:44 <coleman> Koterpillar: so unfamiliar to me
21:18:46 <coleman> Koterpillar: thanks
21:20:13 <Koterpillar> well, if you want to model lisp, then data Sexp = Nil | Atom String | Cons Sexp Sexp
21:20:33 <Koterpillar> do you see what that means?
21:20:46 <coleman> Koterpillar: not yet. i'm reading through LYAH
21:20:56 <Koterpillar> yes, that will help :)
21:26:19 <doyougnu> coleman: there is a wikibook on writing a basic version of scheme in Haskell that you could cross reference: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
21:26:47 <doyougnu> however I do think it is a little out dated now
21:30:05 <ReinH> Quite out of date, but still somewhat useful.
21:30:29 <ReinH> coleman: algebraic data types are exactly what you want to represent abstract syntax
21:33:11 <coleman> ReinH: thanks I'll note that. My goal here is to write a Haskell program which does derivations.
21:33:35 <coleman> ReinH: on truth function logic: dni, dne, ande, andi, mpp, and mtt
21:33:57 <coleman> ReinH: not sure if that will be sufficient for this case, but it may be a starting point
21:36:30 <ab9rf> i would think that implementing scheme in haskell would be insanely easy
21:37:30 <johnw> implementing scheme in haskell should be extremely easy
21:38:03 <johnw> you represent the AST for scheme as a data type, and write a parser from scheme syntax into that type, and a recursive evaluator from that type to the final result
21:38:13 <doyougnu> yup, perhaps that's why its a "x in 48 hours" wiki book
21:38:50 <jle`> it's so well-suited for haskell that a lot of courses have you implement it as a project heh
21:39:21 <jle`> and not even as a final project, just as a minor one haha
21:40:44 <ab9rf> scheme is also extremely easy to parse
21:43:03 * Maxdamantus wrote a purely functional purely imperative language for a Haskell course in uni.
21:52:57 <ReinH> coleman: if you look at the original work in the field, they were using ADTs before they even knew what they were
21:53:27 <coleman> ReinH: what field? Compositional logic?
21:53:43 <ReinH> coleman: language design in the 60s
21:53:55 <ReinH> e.g., you'd have a union type, like ENV = NIL u SIMP u REC and predicates nil? simp? rec? and such
21:54:42 <coleman> ReinH: who knew about ADTs before they understood them?
21:55:42 <ph88^> how can i write Uniplate.Direct instances for records? https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Direct.html  isn't a record the same as tuple in basis ?
21:58:34 <ab9rf> they were definitely around when i was a CS major in the mid-80s
21:58:59 <ab9rf> i don't know exactly how far back it goes, probably late 70s or early 80s
22:16:20 <EvanR> just implemented a non trivial monad with Free instead of transformers
22:16:30 <EvanR> not sure if im impressed or not with it
22:16:59 <EvanR> it actually takes up less space than the transformers version
22:18:42 <EvanR> but sort of at a loss on how to explain the magic
22:19:48 <EvanR> data TeletypeF next = PutString String next | GetString (String -> next), what is this next supposed to be
22:20:13 <Koterpillar> the next action
22:20:28 <EvanR> what type would it have?
22:21:07 <Koterpillar> the type you gave it in the type definition
22:21:15 <Koterpillar> "data TeletypeF next"
22:21:29 <EvanR> next = "data TeletypeF next" ?
22:21:40 <EvanR> next = TeleTypeF next ?
22:21:46 <Koterpillar> for TeletypeF Next, the type of next is Next
22:22:03 <EvanR> sure but Next isnt an action
22:22:25 <ReinH> coleman: Reynolds, Steele, Sussman, McCarthy, etc
22:22:27 <ReinH> coleman: e.g., https://cs.au.dk/~hosc/local/HOSC-11-4-pp363-397.pdf
22:22:30 <EvanR> im trying to understand what kind of "action" were talking about
22:22:54 <EvanR> GetChar is an action, PutChar 'c' is an action, or PutChar is an action... . confusing
22:22:54 <coleman> ReinH: ah McCarthy huh
22:23:12 <Koterpillar> EvanR: where's the definition of Teletype?
22:23:14 <EvanR> will next be a function?
22:23:39 <EvanR> there isnt one, do you mean type Teletype a = Free TeletypeF a ?
22:23:44 <Koterpillar> yes
22:24:21 <coleman> ReinH: He's great but idunno if I can get with his stance on artificial intelligence
22:24:24 <coleman> "Machines as simple as thermostats can be said to have beliefs, and having beliefs seems to be a characteristic of most machines capable of problem solving performance. However, the machines mankind has so far found it useful to construct rarely have beliefs about beliefs"
22:24:52 <Koterpillar> so the next will also be a Teletype a
22:24:53 <coleman> thermostats don't have beliefs. it's a misuse of language. if he can't say it comprehensibly we can't even know he knows what he is saying
22:25:14 <EvanR> next will be a Free TeletypeF a ?
22:25:24 <Koterpillar> for some a
22:25:56 <Koterpillar> so it can be a Pure some_a, or PutChar 'c' next
22:26:02 <EvanR> which is either Pure x or
22:26:05 <Koterpillar> sorry, Free (PutChar 'c' next)
22:26:15 <Koterpillar> where next is again a Teletype a
22:27:11 <EvanR> i see, so next wont be a function, itll be a Pure or MkFree
22:27:21 <Koterpillar> what is a function?
22:27:31 <EvanR> \_ -> _
22:27:38 <Koterpillar> then no
22:27:55 <EvanR> ok making sense
22:28:21 <Koterpillar> a fully evaluated (but not executed!) value of Free is a chain of those constructors
22:28:26 <EvanR> eventually you think of next ending up being one of the two free ctors
22:28:46 <EvanR> and Free means more to come
22:29:46 <EvanR> are there two free monad packages?
22:29:57 <EvanR> my types in ghci dont seem to match up with the docs
22:30:05 <EvanR> liftF :: (Functor f, Monad m) => f a -> FreeT f m a
22:30:19 <Koterpillar> oh, FreeT
22:30:22 <EvanR> liftF :: (Functor f, MonadFree f m) => f a -> m a
22:30:54 <EvanR> MonadFree o_O
22:31:19 <ReinH> coleman: not really interested in his beliefs about thermostats
22:32:42 <Koterpillar> EvanR: I think I saw at least two
22:33:49 <EvanR> i imported Control.Monad.Trans.Free just like in the docs for transformers-free ... are they clobbering on the same module name...
22:41:08 <EvanR> ok from free package
22:53:31 <kadintrooper> Hello :)
22:58:44 <kadintrooper> hhttps://github.com/klappvisor/haskell-telegram-api trying to use this to send a message to myself on telegram but am getting a Not in scope: data constructor ‘MessageResponse’ error when I try to compile the sendMessage example
22:58:48 * hackagebot gnss-converters 0.1.16 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.16 (markfine)
23:05:16 <jle`> if i have an injective type family, is there any way i can access the inverting function
23:05:25 <jle`> er, the inverse of it
23:06:14 <c_wraith> (Foo a ~ t) =>
23:06:51 <jle`> hm yeah
23:07:08 <jle`> now to figure out how to introduce 'a' into an existential scope
23:07:36 <jle`> if i had a function that expected (forall t. t -> ...), i wonder how i can bring a into scope there in that way
23:07:42 <jle`> within that function
23:15:04 <johnw> if it had an inverse, wouldn't that be a bijective type family?
23:16:48 <cocreature> johnw: couldn’t it just be stuck for types that don’t have an inverse?
23:20:48 <dmj`> jle`: if you figure out how, I'd like to know as well
23:21:23 <jle`> dmj`: i ended up naming a helper function with an explicit type signature
23:21:42 <jle`> within the (forall t. ...), using a let .. in ...
23:26:44 <dmj`> jle`: hmm, interesting, care to paste your signature :] 
23:30:05 <dmj`> I couldn't get my free type variable to unify with what was in the existential, so I had to pull it out, contemplated unsafeCoerce
23:31:07 <johnw> dmj`: and you should never be able to; otherwise, it wouldn't be an existential, unless you have evidence of the equality
23:37:30 <dmj`> johnw: sure, technically they're equal. But I don't know how I'd carry a witness around in this case
23:37:49 <johnw>  what do you mean by "technically"?
23:42:57 <dmj`> johnw: I'm trying to think of a simple example to illustrate my use case
23:46:25 <dmj`> johnw: If we have: data K a = forall r o . K (G o r) (r -> a)
23:46:57 <dmj`> and some function, f :: (K a -> IO ()) -> IO ()
23:48:36 <dmj`> f :: (K a -> IO ()) -> IO (); f g = g $ (deserialize bytestringK :: K a)
23:48:44 <dmj`> the 'a''s here will unify
23:49:05 <dmj`> since 'a' is free in K
23:50:05 <dmj`> what I'm trying to get at is, suppose K didn't have 'a' as free, but was constructed in the presence of 'a', the same 'a' we see in f, we'd know the types were equivalent
23:50:22 <dmj`> even though it's hidden in the existential
23:50:44 <johnw> that's the evidence you'd have to carry then, the context of construction
23:51:30 <dmj`> like, what if there was another type data M = forall a r o . M (G o r) (r -> a)
23:51:43 <dmj`> and we converted, K a -> M
23:51:55 <johnw> once you tuck the data into a K without free a, it goes into a one-way box; unless you can convey some knowledge about how it was constructed, that information is lost
23:55:01 <dmj`> yea, that's the issue I'm having. If I do data K a r o = K (G o r) (r -> a), it requires a Typeable constraint on every free type variable, which really makes the API ugly
23:55:28 <lyxia> K a r o    that's a nice name
23:55:55 <dmj`> the problem is the witness must live inside of K
23:58:35 <dmj`> so we could construct with K a, convert to M, serialize M, deserialize M, then coerce back to K a, as long as K a was constructed in the presence of a -> IO (), it'd be 'safe'
23:58:49 * hackagebot ekg-prometheus-adapter 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/ekg-prometheus-adapter-0.1.0.0 (AlfredoDiNapoli)
23:58:51 * hackagebot ekg-prometheus-adapter 0.1.0.1 - Easily expose your EKG metrics to Prometheus  https://hackage.haskell.org/package/ekg-prometheus-adapter-0.1.0.1 (AlfredoDiNapoli)
23:59:30 <dmj`> this is all to get around a Typeable constraint
