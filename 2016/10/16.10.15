00:00:46 <shanemikel> splitOn? or rewrite lines
00:01:52 <ongy> quick question, why? But you could just append a newline to find out if there was one (wasn't -> ignored, was -> empty element)
00:04:18 <EvanR> > lines "1234"
00:04:21 <lambdabot>  ["1234"]
00:04:23 <EvanR> > lines "1234\n"
00:04:25 <lambdabot>  ["1234"]
00:04:59 <shanemikel> think he means 
00:05:01 <EvanR> you say i can append a newline to detect the difference?
00:05:08 <shanemikel> > lines ["1234\n\n"]
00:05:10 <lambdabot>  error:
00:05:11 <lambdabot>      • Couldn't match expected type ‘Char’ with actual type ‘[Char]’
00:05:11 <lambdabot>      • In the expression:
00:05:23 <shanemikel> err...
00:05:44 <ongy> > lines . (++ "\n") "1234"
00:05:46 <lambdabot>  error:
00:05:46 <lambdabot>      • Couldn't match expected type ‘a -> String’
00:05:46 <lambdabot>                    with actual type ‘[Char]’
00:05:57 <MarcelineVQ> :>
00:06:51 <ongy> > lines . (++ "\n") $ "1234"
00:06:53 <lambdabot>  ["1234"]
00:06:53 <ongy> > lines . (++ "\n") $ "1234\n"
00:06:55 <lambdabot>  ["1234",""]
00:07:03 <ongy> I meant like that
00:07:41 * hackagebot legion-discovery 0.2.1.1 - Initial project template from stack  https://hackage.haskell.org/package/legion-discovery-0.2.1.1 (taphu)
00:07:41 * hackagebot repa 3.4.1.2 - High performance, regular, shape polymorphic parallel arrays.  https://hackage.haskell.org/package/repa-3.4.1.2 (BenLippmeier)
00:07:44 <EvanR> so if there is an empty string at the end of the list, what does it mean
00:07:48 <EvanR> anything?
00:08:29 <shanemikel> there's an empty line
00:08:45 <EvanR> huh
00:08:54 <EvanR> theres no empty line in "1234\n"
00:08:59 <EvanR> its just properly terminated
00:09:23 <EvanR> which im using the signal "correct file"
00:09:29 <EvanR> to signal
00:09:56 <shanemikel> there's an empty line in "1234\n\n"
00:10:09 <EvanR> i get that
00:10:32 <ongy> you complained that lines eats the \n at the end. By appending another \n you can make it visible as empty line at the end
00:11:08 <EvanR> i still dont think i can tell the difference between original data was missing a newline or not
00:11:45 <EvanR> and this still doesnt address my original concern that reading the entire thing into memory then splitting is the least efficient way
00:11:45 <ongy> I was thinking about something like: let hadNewline = (== "") . last . lines . (++ "\n")
00:12:22 <ongy> do you have a reasonable guess about the max-size (in characters) of the numbers? That would allow you to fseek somewhere more reasonable
00:12:35 <EvanR> like 10 digits
00:13:37 <EvanR> good point
00:13:48 <EvanR> i think
00:16:54 <shanemikel> laziness eh..
00:17:27 <shanemikel> just write your program, profile, and then decide what it does
00:17:45 <MarcelineVQ> > unfoldr (\xs -> case (span (/='\n') xs) of ([],_) -> Nothing; (_,[]) -> Nothing; (x,y) -> Just (x,drop 1 y)) $ "123\n456\n789\n"
00:17:47 <lambdabot>  ["123","456","789"]
00:21:22 <EvanR> nah i just had to deal with a ruby program downloading a 1000 line spreadsheet from google, and triggering the OOM killer 
00:21:33 <EvanR> while trying to parse it
00:21:54 <EvanR> im in the mood to get this to "do it right"
00:27:02 <shanemikel> what's this "Seek from end" think I'm reading in System.IO
00:27:03 <EvanR> http://lpaste.net/262573 seems too simple and or ad hoc to be right
00:29:48 <EvanR> but it sure is not much code
00:30:40 <shanemikel> wow.. does that work?
00:30:42 <EvanR> ah... if theres a 60 digit number at the end of the log, itll read only part of it and call it good
00:31:51 <EvanR> and end up being a wacky Int regardless
00:31:56 <shanemikel> I was thinking maybe seek from the end one char at a time until you hit a newline
00:32:24 <EvanR> dang, why cant we just getC backwards ;)
00:32:43 <shanemikel> exactly
00:33:23 <EvanR> its funny that hGetC exists but it might secretly read more than 1 byte
00:33:30 <EvanR> hGetChar
00:33:50 <EvanR> but theres no hGet1Byte in ByteString
00:33:53 <shanemikel> artificial limits are the reason GHC can't be packaged on OSX right now, so I'd avoid it
00:34:22 <EvanR> artificial limits?
00:34:47 <shanemikel> 50 bytes in your paste
00:34:56 <EvanR> well yeah that is broken
00:35:26 <fps_> ok, what do i need to learn about to understand this type annotation:
00:35:28 <fps_> asciichangesfile :: Parsec String st [String]
00:35:43 <fps_> list of String and String do ring a bell.. 
00:35:48 <fps_> but what about "st"?
00:35:59 <EvanR> the user state
00:36:09 <EvanR> its a type variable
00:36:21 <EvanR> that parser works for any st you want
00:37:20 <fps_> EvanR: thanks.. will check out type variables :)
00:37:33 <EvanR> that annotation is shorthand for
00:37:48 <EvanR> forall st . Parsec String st [String]
00:38:33 <fps_> hmm, interesting. is there somewhere in this a familiar "->" ?
00:38:55 <EvanR> theres no -> here
00:39:15 <fps> so it's not a function?
00:39:22 <fps> forgive my ignorance 
00:39:26 <EvanR> no, Parsec is a 3-argument type constructor
00:39:34 <EvanR> so here it is taking 3 args
00:40:09 <EvanR> (->) is a 2-arg type constructor
00:40:57 <fps> ok, i suppose i have enough info now to keep on reading a little more :)
00:40:58 <fps> thanks
00:42:23 <Alper> hello everyone, I have a beginner question about importing modules
00:43:36 <cocreature> Alper: go ahead and ask :)
00:43:56 <Alper> In ghci why does intersperse '.' "MONKEY" fail but head [1,2,3] work?
00:44:09 <Alper> They are both in Data.List
00:44:23 <cocreature> Alper: there is a special module called "Prelude" which is imported by default
00:44:24 <Alper> but for intersperse I have to do import Data.List
00:44:30 <cocreature> Alper: and that module reexports head
00:44:59 <cocreature> but it doesn’t reexport intersperse
00:46:43 <Alper> makes sense thanks. How can I import a non-standard module like attoparsec? (I want to parse a csv file) 
00:46:55 <Alper> I have no experience with cabal or stack etc.
00:47:11 <cocreature> just type "import modulename"
00:47:22 <cocreature> e.g. import Data.Attoparsec.Text
00:48:09 <Alper>  Could not find module `Data.Attoparsec.Text'
00:48:25 <cocreature> then you need to install the attoparsec package
00:48:36 <ReinH> You're going to want to learn cabal or stack.
00:48:38 <cocreature> you can either do that via "stack build attoparsec" or "cabal install attoparsec"
00:49:19 <Alper> what does installing entail? is it similar to node i.e. downloading the package and putting into a folder?
00:49:45 <cocreature> since haskell is a compiled language it also entails building the package
00:50:02 <cocreature> and it is also registered in a package database so ghc knows how to find it
00:51:04 <Alper> any good resources you know for getting started with stack? I read that learning stack is the preferred option is that correct?
00:51:30 <cocreature> depends on who you ask. stack has pretty good documentation https://docs.haskellstack.org/en/stable/README/#quick-start-guide
00:52:05 <Alper> ok, thanks for the info.
00:56:56 <fps> Alper: coincidence: i'm a haskell noob, too, and just setup my first stack project because i want to write a parser (albeit a different file format)
00:57:35 <Alper> @fps https://www.haskell.org/platform/ says that the download includes stack but cannot run it from cmd line (Windows 8.1). 
00:57:35 <lambdabot> Maybe you meant: pl faq
00:57:46 <fps> Alper: i found the stack experience quite good, although the installation and initial setup took quite a while
00:58:12 <cocreature> Alper: btw if you just want to parse csv instead of writing a parser (which can be a nice exercise), you might want to take a look at https://hackage.haskell.org/package/cassava
00:58:22 <fps> Alper: oh, windows.. you probably need to setup the PATH variable
00:58:40 <Primordus> hey guys, i want to develop a FPGA circuit with the Lava package .. but I noticed there were 4 variants. are there big differences between them?
00:59:16 <fps> Alper: windows is a, erm, weird operating system. expect troubles ;)
01:00:07 <Alper> fps I don't know what the path should be, I cannot see a stack.exe under C:\Program Files\Haskell Platform\8.0.1
01:01:03 <fps> Alper: did you search for stack.exe including subdirs?
01:01:42 <fps> https://www.stackage.org/stack/windows-x86_64-installer
01:01:46 <fps> does that one work?
01:02:11 <fps> the nice thing about stack is that it downloads the ghc toolchain for you anyways.. 
01:02:58 <Alper> yeah I saw that one, I just wanted to make sure that I don't already have it. If I accidentally install two different versions I'm worried about conflicts etc.
01:03:50 <Alper> oh great, looks like the installer updates the PATH. I'll do that.
01:05:08 <Alper> installer worked, thanks fps.
01:05:13 <fps> anyways, once you have stack setup and done "stack new yourprojectname"
01:05:20 <fps> [which will take a while]
01:05:39 <fps> and then inside it "stack setup" [iirc]
01:05:51 <Alper> can I just use it as a package manager though? I don
01:06:05 <fps> you'll have to edit the .cabal file and add the package [attoparsec] to the build-depends of your main app
01:06:15 <Alper> can I just use it as a package manager though? I don't want bunch scaffolding code at this time, just to import a few modules.
01:06:34 <cocreature> Alper: just run "stack build packagename" outside of any project
01:06:50 <cocreature> there is an implicit global project that will be used in that case
01:07:04 <cocreature> you need to use "stack ghc" and "stack ghci" to get access to these packages
01:07:16 <fps> oh nice :)
01:07:19 <fps> til
01:07:59 <Alper> ok, thanks cocreature. Is it a good to run stack new xxx and see what it does to learn about project structure and where files go etc.?
01:08:15 <Alper> *good idea.
01:09:07 <cocreature> Alper: "stack new xxx" is for when you want to create a “real project” so that you can just run "stack build" and it will take all your sources and build them together in a library or executable. if you just want to play around in ghci or with one or two files using ghc, I wouldn’t use it
01:10:04 <Alper> agreed thanks.
01:12:47 <Alper> cocreature, what are your thoughts on deploying haskell functions and/or projects to cloud providers like AWS Lambda? I kinda assumed that it should not be too difficult to do as long as the cloud provider is supporting it.
01:13:17 <cocreature> Alper: I have never used something like aws lambda so I can’t comment on that :)
01:14:38 <Alper> thanks again for the info cocreature , fps
01:24:23 <fps> Alper: i recently read about includeOS and i think there was mention of unikernels for cloud computing for haskell, too
01:24:26 <fps> IIRC
01:25:37 <fps> halvm :)
01:27:43 <Alper> fps I know nothing about unikernels :)
01:29:06 <fps> https://www.youtube.com/watch?v=oHcHTFleNtg
01:29:10 <fps> Unikernels: Who, What, Where, When, Why - Adam Wick, Galois
01:29:41 <fps> Alper: that was for you :)
01:30:06 <Alper> bookmarked, thx
01:38:37 <ProfSechs> Can anyone give me some startup ideas?
01:40:55 <zomg> Uber of Haskell programmers
02:04:46 <MrElendig> kolab implemented in haskell
02:05:18 <MrElendig> an actual secure IoT hub
02:06:05 <ongy> how about secure IoT devices? Those things...
02:35:10 <m1dnight_> How would an uber of haskellers work?
02:35:21 <m1dnight_> Only haskellers can pick you up?
02:49:25 <joncol> I tried to use the graphviz library, but it doesn't seem to be able to handle edges appearing before the nodes they refer to. The `dot` command seems to handle this fine, so I'm unsure of if I'm missing something in how I should use graphviz. I created a minimal example at http://pastebin.com/YEGELMFL, where the error can be seen. Anyone?
02:52:42 * hackagebot rawfilepath 0.1.0.0 - Use RawFilePath instead of FilePath  https://hackage.haskell.org/package/rawfilepath-0.1.0.0 (XT)
02:52:44 * hackagebot legion-discovery-client 0.1.0.1 - Client library for communicating with legion-discovery.  https://hackage.haskell.org/package/legion-discovery-client-0.1.0.1 (taphu)
03:07:01 <zennist> when using IORef: having many IORefs for many different fields vs. having one IORef to a product type containing all these fields; which generally works better?
03:07:14 <zennist> assuming each field needs to be read/written individually
03:08:01 <zennist> slight change: assuming most of the time all fields need to be read together, but updated separately
03:09:03 <srhb> zennist: If the data is small, it's probably mostly about convenience.
03:30:10 <lyndon> Hey Haskellers, is there a better place to ask conduit questions?
03:30:30 <lyndon> Otherwise I've got a bit of a puzzle about ZipConduit
03:41:45 <srhb> lyndon: Just ask :)
03:42:01 <lyndon> thanks srhb 
03:42:35 <lyndon> srhb: I've had this problem for a while that I reimplement in a few different 'frameworks': https://gist.github.com/sordina/9ad93ac23073269889b6db0d62e6ba10
03:42:53 <lyndon> This is the conduit solution that I've come up with but I'm not super happy with it
03:42:58 <srhb> lyndon: If you direct the question at me, you're less likely to get an answer from others, and I know little about conduit :-)
03:43:10 <lyndon> Ah np :)
03:43:28 <srhb> What are you unhappy with?
03:43:42 <lyndon> It's the interaction with "roll" and "pairs"
03:44:45 <lyndon> Roll is esentially running two functions in parallel, and I'd like them to be reconvened with (,), but ZipConduit emits both results into the output stream.
03:44:59 <lyndon> So I use "pairs" to couple up successive lines again.
03:45:17 <lyndon> And while it works, it seems quite an error-prone implementation.
03:45:59 <lyndon> Ideally I'd like something like ZipConduit, but that actually allows for a zipping function as an argument
03:46:13 <lyndon> Not sure if this exists, or how to implement it.
04:05:27 <nilminus> b
04:29:49 <fred-fri> noob trying to convert some java interview question solutions to haskell, struggling with these http://pastebin.com/rA5UMY7a
04:30:36 <maerwald> where are the questions?
04:31:24 <fred-fri> "write a method that identifies the majority element in a list"
04:32:05 <maerwald> so what is your haskell code so far?
04:33:12 <fred-fri> so far im constructing a map with the elements as keys and 0s as values
04:33:50 <fred-fri> my problem is my brain tries to just write the same code as haskell instead of using functional paradigm
04:34:10 <maerwald> then don't look at the java solution ;)
04:34:35 <maerwald> @where learn
04:34:35 <lambdabot> https://wiki.haskell.org/Learning_Haskell
04:34:47 <fred-fri> i think maybe recursion and folding could be combined to solve the task
04:34:49 <maerwald> erm, that was not it
04:35:17 <pavonia> @where lyah
04:35:17 <lambdabot> http://www.learnyouahaskell.com/
04:35:21 <pavonia> That?
04:35:21 <maerwald> no
04:35:26 <maerwald> definitely not
04:35:30 <maerwald> @where bitemappy
04:35:30 <lambdabot> I know nothing about bitemappy.
04:35:36 <pavonia> :<
04:36:06 <maerwald> @where learnhaskell
04:36:06 <lambdabot> https://github.com/bitemyapp/learnhaskell
04:36:09 <maerwald> yes
04:36:54 <maerwald> fred-fri: I'd argue you picked a non-optimal starting point
04:37:22 <maerwald> now you got the java solution in your mind and are trying to map it to functional style
04:37:42 <maerwald> that's imo harder than trying to solve "functional problems"
04:38:37 <fred-fri> you know how sum can be implemented using fold
04:38:51 <maerwald> that should be doable :)
04:38:53 <fred-fri> i thought id do that but only increment if current element is same as starting one
04:39:16 <maerwald> then you just use a custom function instead of (+)
04:39:50 <fred-fri> yes. thats about as far as ive got trying to come up with a functional solution
04:41:49 <fred-fri> eg first reduce the list to its unique elements, then for each element, fold using a custom function that only accumulates if current element is same as specified one
04:42:25 <fred-fri> return whichever element reached a majority
04:42:27 <fred-fri> something like that
04:52:47 * hackagebot HsOpenSSL 0.11.3.1 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.3.1 (VladimirShabanov)
04:52:49 * hackagebot haquery 0.1.1.2 - jQuery for Haskell.  https://hackage.haskell.org/package/haquery-0.1.1.2 (crufter)
04:55:38 <flxw> Hi all. Over the course of the last days, a few interesting things where mentioned here. :-)
04:56:55 <flxw> Among others, that by using fold, one can implmenent all primitive recursive functions.
04:57:09 <flxw> When I started thinking about how to prove this, I noticed that fold can in 
04:58:12 <flxw> in fact be viewed as the pritive recursion operator itself. Is taht right, or am I missing something?
04:59:44 <flxw> s/something/something substantial/
05:03:18 <ski> `foldr' is a recursion operator on lists
05:03:38 <maerwald> on Foldable
05:04:02 <ski> primitive recursion on lists would have type `(a -> [a] -> o -> o) -> o -> [a] -> o', though
05:05:22 <ski> (`Foldable' is more or less lists, though see <http://comonad.com/reader/2015/free-monoids-in-haskell/>)
05:06:58 <ski> flxw : cf. primitive recursion over naturals havnig type `(Natural -> o -> o) -> o -> Natural -> o' (rather than just `(o -> o) -> o -> Natural -> o', which is the type of the catamorphism/fold on `Natural')
05:12:17 <flxw> ski: Aha, thank you.
05:12:39 <joncol> Who was talking about the majority element question?
05:13:13 <flxw> I gotta think a bit about what you just said and follow up on the link. I'm pretty sure it'll be quite enlithening in a mite. ;-)
05:58:30 <pavonia> Slightly offtopic: I'm trying to encode a subset of "the type of Haskell types" in Church encoding. AFAIU, if you'd convert a Haskell data type, you'd introduce another lambda variable for each constructor. However, that would lead to many variables, and I'd ideally want the system to be easily extendable. Is there a clever way to limit the whole thing to only a few variables, e.g. by using...
05:58:32 <pavonia> ...integers or strings to encode constructors with the same arity somehow?
06:14:36 <troydm> I have two functions f and g that both return Maybe a
06:15:08 <troydm> is there a builtin function that will call f and if it returns Nothing will only then call g and return it's result 
06:15:14 <troydm> otherwise return f's result
06:15:23 <troydm> something like or but for Monads
06:15:44 <ski> call `g' with what argument ?
06:16:30 <troydm> ski: never mind the argument
06:16:37 <hpc_> > Nothing <|> Just 5
06:16:39 <lambdabot>  Just 5
06:16:44 <hpc_> > Just 5 <|> Just 10
06:16:47 <lambdabot>  Just 5
06:16:52 <ski> perhaps you just want `Alternative', then
06:16:53 <troydm> hpc_: thx
06:16:59 <ski> @type (<|>)
06:17:00 <lambdabot> Alternative f => f a -> f a -> f a
07:02:48 <Franciman> Hello, what is a faster way to do last . takeWhile p, for p some predicate?
07:03:32 <Franciman> faster as in more efficient in time
07:03:33 <hpc> that should be fine
07:04:19 <Franciman> hpc, isn't it a bit slow if I have as result of takeWhile a list of like 2000 numbers?
07:05:15 <int-e> Franciman: you have to test p for all those 2000 numbers anyway
07:05:30 <mpickering> If you want to be sure the list doesn't get allocated then you can use `span` or `break`
07:05:40 <mpickering> or something like that
07:05:53 <Franciman> int-e, isn't takeWhile just considering the first k+1 elements?
07:06:04 <Franciman> with k length of the longest prefix
07:06:07 <mpickering> or probably better to just write your own function
07:06:29 <int-e> Franciman: 2000 was the length of the result list in your example, so what you now call k.
07:06:44 <int-e> (at least that's how I read it)
07:07:05 <Franciman> oh right, sorry
07:07:39 <Franciman> I got confused. So you're saying that it's ok to traverse twice 2000 numbers?
07:08:07 <int-e> In any case, last will consume the list as takeWhile produces it (in fact I expect the two will fuse and no intermediate list will be produced at all)... so I don't see how you could be faster without changing the semantics, possibly because you know something about the input list and p.
07:10:24 <Franciman> wow, cool. Thank you for your help
07:10:44 <puregreen> Franciman: last [1..2000] takes 5 microseconds (that's 1/200th of a millisecond) in GHCi. That's without any optimisations or fusion. Unless you're running it *lots* of times, you probably don't have to worry about it.
07:11:26 <Franciman> ok, thanks
07:13:38 <int-e> interestingly, ghc 7.8 didn't fuse last . takeWhile p, but 7.10 and 8.0 do (when compiling with -O)
07:15:00 <Franciman> int-e, how can I check it?
07:16:43 <int-e> I made a test module containing a single function (t p = last . takeWhile p) and used  ghc -c -ddump-stg  to see the corresponding ghc core code... but that code is quite hard to read because it's full of confusing annotations.
07:17:52 <puregreen> ghc-core (from Hackage) removes some annotations, I recommend it if you're curious about core 
07:18:24 <puregreen> (int-e probably knows about it though)
07:28:25 <int-e> Franciman: http://lpaste.net/264356
07:29:30 <int-e> ah, -ddump-simpl is a tad less messy than -ddump-stg
07:32:09 <int-e> puregreen: I had forgotten, actually
07:34:48 <joe9> What is a good haskell data type for an unsigned Int (Word32)?
07:37:31 <puregreen> joe9: `Word32`
07:37:36 <zaquest> joe9, Word32 is a thing
07:37:42 <puregreen> or just `Word`
07:37:53 <puregreen> and if you want unsigned `Integer`, there's `Natural`
07:38:51 <nitrix> alercah: Hey. Wanna share your thoughts on the algo of yesterday?
07:39:09 <nitrix> alercah: I'm looking at adjancy matrix currently.
07:39:21 <nitrix> *adjacency
07:39:31 <Hafydd> A janky matrix.
07:39:46 <nitrix> Hafydd: Is it how it's called?
07:40:01 <Hafydd> nitrix: I assume you did indeed mean "adjacency matrix," which is correct.
07:56:00 <mpickering> int-e: Use -dsuppress-all
07:56:16 <mpickering> Or there are other suppression flags, see them by " ghc --show-options | grep suppress"
07:57:33 <int-e> oh, nice!
08:00:48 <joe9> Can anyone please update/generate these package urls? https://hackage.haskell.org/package/text-show
08:01:04 <wz1000> Is there any nice way to set a lens to the view another lens?
08:01:14 <wz1000> s/view/view of/
08:01:44 <puregreen> joe9: what do you mean?
08:02:20 <wz1000> Currently I have this: \s b -> s & (l1 .~ (b ^. l2))
08:03:18 <osa1> it seems like I can't use a function defined in `where ...` part of a definition in view patterns used in the definition, right? e.g. f (fn -> x) = ... where fn = ... doesn't work
08:05:08 <alercah> nitrix: well you could just store "is X a cut-vertex" on each vertex, then the lookup time is how long it takes to look it up
08:05:33 <alercah> every time you change your graph, you recalculate
08:06:03 <alercah> you could also use a variant of a union-find structure for 2-connected componentns
08:08:11 <osa1> containers' map's toList does not return different lists when I insert in different order, right?
08:08:36 <puregreen> riht
08:08:38 <puregreen> * right
08:32:30 <joe9> puregreen: the module url's are not there
08:32:51 <puregreen> joe9: you mean, there's no documentation?
08:33:24 <puregreen> you can ask the maintainer to upload it; you can wait while Hackage generates it; you can browse docs for a slightly older version; or you can use Stackage docs
08:33:54 <puregreen> wz1000: you can write “set l1 . view l2”, but it accepts the arguments in reverse order
08:33:59 <puregreen> (b s, not s b)
08:34:11 <joe9> puregreen: no, I think it has something to do with hackage docbuild errors
08:34:19 <joe9> puregreen: ok, Thansk.
08:36:34 <aania123> is there chanel to discuss about types?
08:37:09 <mipleh> Is Theodore here? I'm looking for him 
08:37:25 <mipleh> Theodooooooooooooooore??
08:38:02 <puregreen> aania123: to my knowledge, no. There are some smaller channels for “more advanced discussions” I think, but they're somewhat deserted
08:38:45 <puregreen> aania123: there also might be type theory channels not related to Haskell, but I don't know anything about those
08:39:19 <aania123> puregreen: is here ppl interested about type theory?
08:39:22 <puregreen> also, for some questions #haskell-lens is a better fit than #haskell but frankly I still haven't managed to figure out what *exactly* haskell-lens is for
08:39:29 <aania123> Most type-safe languages include some form of dynamic type checking, even if they also have a static type checker. The reason for this is that many useful features or properties are difficult or impossible to verify statically. 
08:39:38 <aania123> https://www.wikiwand.com/en/Category:Dynamically_typed_programming_languages
08:40:16 <puregreen> aania123: yes, lots of people here are interested in type theory, but the problem is that hard or specialised questions have a tendency to go unnoticed in this channel
08:40:20 <puregreen> it's a matter of luck
08:40:28 <puregreen> or pinging the right people :)
08:40:38 <aania123> I have problem to infer types of terms, and if I considr dynamic type checking, does it helps?
08:45:43 <jmcarthur> I think dynamic type features can be useful for quick and dirty hacks, but I've not yet come across a case where it was necessary in Haskell.
08:45:51 <joe9> aania123:  check out HOTT
08:46:37 <jmcarthur> Well, I take it back. I've used unsafeCoerce in cases that I knew it was safe just to avoid the overhead of Dynamic. I don't know if I could have avoided either. At least I couldn't think of a way.
08:47:05 <jmcarthur> Ah, yes, I could have.
08:47:12 <jmcarthur> It would have just been very inconvenient.
08:47:37 <jmcarthur> (e.g. reimplementing containers)
08:49:04 <aania123> joe9: what?
08:50:57 <geekosaur> @where hott
08:50:57 <lambdabot> http://homotopytypetheory.org/book/
08:51:03 <geekosaur> aania123, ^
08:52:25 <hpc> (the intro is dense but ignorable)
08:52:35 <joe9> aania123: imho, most probably something is wrong with the program structure if one is looking for dynamic type checking in the haskell program. or, Free monad supports something similar
08:52:55 * hackagebot haquery 0.1.1.3 - jQuery for Haskell.  https://hackage.haskell.org/package/haquery-0.1.1.3 (crufter)
08:56:48 <joe9> geekosaur: as an fyi, http://dpaste.com/0MW2161 is what I ended up with. Thanks.
08:58:10 <joe9> geekosaur: for finding a file/dir, I would have to go through the whole vector of cQids, correct?
08:58:30 <geekosaur> yes. this is going to be true of any structure
08:58:41 <joe9> geekosaur: http://dpaste.com/3NDWKQK is the relevant file ADT
08:59:05 <geekosaur> (and, if you are doing it often, this is where a dcache-like thing might be handy)
09:00:17 <joe9> ok, Thanks.
09:01:03 <wz1000> Is there any function (Lens' s a -> Lens' s b -> Lens' s (a,b))?
09:02:55 <aania123> geekosaur: I think it is wrong book
09:15:25 <siwica> This is probably a stupid beginner question having to do with not fully understanding the type system: I have `type R a = Rand StdGen a` and `type RandomList a = R [a]` with a being an instance of Show. Now I have an instance of `RandomList a` how would I make sure I can print it in ghci?
09:16:10 <glguy> You don't provide typeclass instances for type synonyms
09:16:47 <noobFP> Hi! I've been learning Haskell lately (finished chapter 7 of Learn you a Haskell, yeah still a noob I'm afraid). I really like it and want more of my friends to know about it! I'm to set a coding question for a competition at my college. I was looking for suggestions wherein Haskell solutions are particularly elegant! So that people will come to appreciate it more.
09:16:50 <glguy> If you want to be able to print a `RandomList a', you'll need to check for a show instance for `Rand g a'
09:17:06 <noobFP> Any help on this will be much appreciated. Thank you :)
09:18:50 <srhb> noobFP: Quines are really cute in Haskell, but also really useless. ;-)
09:20:41 <glguy> noobFP: There isn't really a class of problem that's the most elegant in Haskell. It's a rather general purpose language. What you can do is select inputs and outputs that Haskell has better support for: file-based, console I/O and network interface rather than native GUI in particular
09:26:51 <noobFP> srhb: I just hade a look at what they are. Looks interesting, thanks :)
09:27:24 <siwica> glguy: Could you elaborate on this? Rand is defined like `type Rand g = RandT g Identity`, and I have no clue how to find/define a Show instance for `Rand g a`.
09:28:14 <noobFP> glguy: Oh okay. I did read though that Haskell is well suited for mathematical problems and concurrency related ones!
09:28:42 <joe9> stack cache issue? https://paste.pound-python.org/show/bTFNTUE5PAILXsYjywL9/ any suggestions on how I can fix it, please? TMPDIR=/tmp/ghc stack exec ghci -- -Wall Network/NineP/Internal/Response.hs
09:28:46 <joe9> is how I started ghc
09:29:24 <joe9> s/ghc/ghci/
09:32:15 <joe9> same issue when using the repl https://paste.pound-python.org/show/uL3y1wJJl5l8acDgam49/
09:35:08 <joe9> Is there a cache somewhere that I can clean?  I did "stack clean" and " rm -rf .stack-work"
09:38:44 <fr33domlover> joe9, there is stuff at ~/.stack
09:39:29 <chreekat> joe9: but that's probably not the problem. can you build ok with 'stack build' ?
09:40:28 <joe9> chreekat: not yet, I am developing this package and there are errors
09:40:50 <joe9> chreekat: so, stack build fails when building the package. but, the dependencies build fine
09:41:12 <joe9> chreekat: I do not understand why the build/exec does not take the new dependencies even if the build fails.
09:41:18 <joe9> chreekat:  Does that make sense?
09:43:23 <chreekat> joe9: the error you see in ghci, is that not an error about the library you're building? 
09:44:01 <joe9> chreekat: yes, this is the library that I am building. But, the Tversion/Rversion are in a different package (added as extra-dep: true)
09:44:27 <joe9> chreekat: I think for some reason if the build fails, stack is falling back to using the older version of the dependent packages
09:46:07 <chreekat> if you've changed the underlying lib, you don't want to set extra-dep: true. That tells stack to treat it as immutable
09:46:22 <joe9> oh, ok. will remove the extra-dep
09:46:32 <chreekat> I mean, it should. Sometimes things build when they shouldn't still. But that's the intention
09:55:07 <joe9> chreekat: I am developing both packages. changing the first and expecting the changes to carry over to the second (i think extra-dep is for that scenario)
09:55:32 <joe9> chreekat:still the same issue even after removing the extra-dep
09:56:16 <joe9> https://gist.github.com/28f5dc0a02a17f864a38a2ecf02b25b3 is the stack.yaml
09:56:24 <joe9> I tried without that extra-dep : true
09:56:30 <joe9> both scenarios have the same issue
10:01:26 <joe9> I think the packages are cached somewhere and not in .stack-work
10:01:36 <joe9> something global
10:05:43 <joe9> any cabal sandbox users here? is it more reliable than stack for development?
10:09:19 <sm> joe9: no
10:09:24 <hpc> they do different things
10:10:34 <Clint> i use cabal sandbox and i don't understand the question
10:10:54 <sm> joe9: stack exec -- ghc-pkg list PKG or stack build --cabal-verbose should show which version of the package it's using
10:13:38 <joe9> sm, that helps https://paste.pound-python.org/show/qAGn3dwqALQfaAA0YFS6/
10:13:42 <joe9> it has both versions
10:14:02 <sm> did you install one manually perhaps ?
10:14:40 <joe9> https://paste.pound-python.org/show/SirLbRjx3B2fcYEXT5kw/ but, I cannot find the older one https://paste.pound-python.org/show/SirLbRjx3B2fcYEXT5kw/
10:15:15 <joe9> oh, it is there in the /home/j/var/stack/snapshots/x86_64-linux/nightly-2016-10-14/8.0.1/pkgdb and /home/j/dev/apps/haskell/libraries/37-9pserver/.stack-work/install/x86_64-linux/nightly-2016-10-14/8.0.1/pkgdb
10:15:29 <joe9> and I want to use the one in the local package below.
10:15:39 <sm> oh I see.. that looks ok
10:16:21 <joe9>  https://paste.pound-python.org/show/ydmX6EZqaIr7VDEaGWo8/
10:17:06 <sm> so it's using the newer one, the problem is something else
10:17:17 <sm> perhaps your code is wrong 
10:17:20 <joe9>  -package-id NineP-0.0.2.3-QoDhmeiV5H1pBsh3PwPpv from here
10:18:23 <joe9> http://dpaste.com/2K9NSAV is my code
10:18:55 <joe9> is the ghci error https://paste.pound-python.org/show/Der3pei6vgjvVjbCOUEp/
10:18:58 <joe9> sm, ^
10:19:06 <joe9> I import it unqualified
10:19:20 <joe9> into Response.hs
10:19:55 <joe9> ifI comment out the version function:  https://paste.pound-python.org/show/cvBxK3d3CEnYrwqhxaGJ/
10:19:59 <joe9> it finds the correct Tversion
10:20:56 <joe9> sm, i think i got it. I think there is something with the code.
10:21:10 <joe9> sm, sorry for the bother. chreekat
10:22:18 <sm> great
10:22:30 <joe9> version (Tversion size version) context = -- is causing the issue
10:22:48 <joe9> https://paste.pound-python.org/show/pVH3EvBrNMcTg8FixwG1/ is the appropriate data definition
10:24:47 <sm> I confess I still don't see why it was complaining, but glad you do
10:25:05 <joe9> got it, the function name and the variable name are the same
10:25:12 <joe9> version (Tversion size version) context = undefined
10:25:28 <joe9> version is the function name and the pattern match variable name too.
10:25:43 <joe9> funny, I thought I would get a better error message.
10:26:03 <sm> I can see how that might cause an infinite loop, but not the error message we're talking about
10:27:15 <joe9> sm, you are correct: version (Tversion size rversion) context = undefined
10:27:17 <joe9> fails to
10:27:32 <joe9> message https://paste.pound-python.org/show/P7gOKsXL7XfiBuTdn30M/
10:27:58 <joe9> https://paste.pound-python.org/show/rCImdVvhmhCd1OIVQQyN/
10:28:00 <joe9> sm ^^
10:29:05 <joe9> is there something wrong with this definition that makes it not pattern-matchable? https://paste.pound-python.org/show/kB7gApf5HDQDtGn0o7Ti/
10:29:23 <sm> joe9: is your repo online ?
10:29:47 <sm> pastes are not working :)
10:30:23 <joe9> sm, I will update it in a few minutes.
10:31:21 <sm> must be something simple, like importing the type but not the type constructors (import Module (Type) vs import Module (Type(..)))
10:31:22 <joe9> sm, https://github.com/joe9/9pserver
10:31:32 <joe9> sm, that makes sense
10:31:39 <joe9> sm, yes I did not do (..)
10:31:45 <joe9> sm, Thanks.
10:32:13 <Zemyla> You know, the binary method for exponentiation is quite often not optimal in terms of number of multiplications performed.
10:33:23 <Tuplanolla> It's usually optimal in terms of cpu time though.
10:34:01 <sm> joe9: from the repos I see, Tversion is a data constructor of the VarMsg type , not of the Tversion type
10:34:23 <joe9> sm, do not worry. I think I got it. I was missing (..) when exporting it.
10:35:11 <joe9> Thanks for the help. I was clueless.
10:35:22 <sm> I won't worry.. but I think you're not quite there yet :)
10:36:18 <ania123> when type inference is a problematic for static typing, can it happen  dynamic typing  simplifies type inference? 
10:37:10 <joe9> sm, https://paste.pound-python.org/show/JnMMiZ66dZ0ZA4EfuthJ/ is my current error and I know why that is happening. The online repo of 9ph is still old, hence, the discrepancy you noticed.
10:37:18 <Zemyla> Tuplanolla: Actually, I think there are methods that can get fewer multiplications for next to no overhead.
10:37:52 <Tuplanolla> You're probably right, Zemyla. There's simply a point at which performing the multiplications is faster than storing all the intermediate results.
10:37:58 <EvanR> ania123: yes, since in the language static types, a system of dynamic types are all the same type, so the answer is obvious
10:37:59 <ania123> I am looking for a person working in type theory
10:37:59 <Tuplanolla> Let me look at how GCC does it.
10:38:00 <sm> joe9: fair enough, sounds like you are making progress
10:38:31 <sm> later
10:38:32 <EvanR> ania123: so its easier in the sense that you give up and dont actually solve any problem
10:39:06 <ania123> EvanR: type inference in my system requiring to solve inequality between regular languages
10:39:16 <ania123> which is obviously very hard
10:39:23 <ania123> if I consider synamic typing
10:39:31 <ania123> how can be things simpolified?
10:39:35 <Tuplanolla> Look at `gcc/tree-ssa-math-opts.c` and `gcc/tree-ssa-reassoc.c` if you want to play along, Zemyla.
10:39:39 <EvanR> you do all your checks at runtime
10:40:02 <EvanR> and programs which are grammatical are just accepted regardless if they make sense
10:41:00 <ania123> EvanR: do you work in type theory?
10:42:04 <Tuplanolla> It says "we use a hybrid algorithm that combines the "window method" with look-up tables".
10:43:32 <EvanR> no i quit 4 years ago
10:43:38 <Tuplanolla> Here's the paper: http://math-www.uni-paderborn.de/~aggathen/Publications/ott01.pdf
10:46:54 <ania123> EvanR: are you researcher?
10:49:07 <grantwu> Is there any way to get ghc-mod to use type synonyms on hover over
10:49:13 <Zemyla> Tuplanolla: Where is the source? I tried googling it, and the only place that said it had it was down.
10:49:57 <grantwu> ExceptT foo Data.Functor.Identity.Identity bar is really verbose when all I need is Except foo bar
10:51:33 <Tuplanolla> This one is up, Zemyla: https://github.com/gcc-mirror/gcc
10:51:52 <joe9> sm, Thanks.
10:52:58 * hackagebot http-pony 0.1.0.5 - A type unsafe http library  https://hackage.haskell.org/package/http-pony-0.1.0.5 (JinjingWang)
10:53:03 <ania123> EvanR: are you researcher?
10:53:55 <Tuplanolla> You don't need to be a researcher for this basic insight, ania123.
10:54:24 <ania123> it is not basic things what I need, it is advance...
10:55:03 <Tuplanolla> Unfortunately your question didn't indicate that.
10:55:08 <Tuplanolla> Try again?
10:55:11 <ania123> ok
10:55:47 <ania123> if I have M: t1->t2    N : t3 
10:56:31 <ania123> and I want to construct MN, I will have to decide t3<<t1, which is in general very hard to decide for my types
10:57:06 <ania123> if I consider dynamic typing, does it simplifies things wrt type inferece?
10:57:11 <ania123> this is my question
10:57:53 <hpc> if you make it dynamically typed, what happens if t3 is not << t1 (whatever (<<) is supposed to be)
10:59:17 <Tuplanolla> With dynamic typing you'll defer type checking until you have concrete types, when the program is run, and abort on failure, ania123.
11:01:08 <ania123> Tuplanolla: I have polimorfism, so, I have type variables and deciding t3<<t1 when they contain type variables is very hard... I do no see point why/how variables can vanish when we have dynamic typing...
11:02:43 <Tuplanolla> The whole point of dynamic typing is to tag the runtime representations of your types and check them for nominal equality when they're used.
11:03:45 <ania123> not clear
11:03:55 <ania123> Tuplanolla
11:04:06 <ania123> do you know regular expressions?
11:04:35 <Tuplanolla> Try this exercise: define any Haskell function (or use, say, `id`) and call it with a value that's not concrete.
11:05:16 <Tuplanolla> In other words `Int` and such are prohibited.
11:05:30 <ReinH> What do you think dynamic typing is?
11:06:21 <ReinH> ania123: ^
11:07:06 <ania123> I do not think anything :)
11:07:37 <ania123> it is similar to static type
11:07:39 <ania123> i think
11:07:43 <geekosaur> not
11:07:45 <jmcarthur> If you have dynamic types, it makes it very simple (statically) because there is nothing to check.
11:08:24 <grantwu> Isn't dynamic typing the opposite?
11:08:25 <ReinH> You don't know what dynamic typing is? Then our answers will be meaningless to you.
11:08:40 <jmcarthur> grantwu: The opposite of what?
11:08:42 <jmcarthur> oh
11:08:49 <grantwu> to static typing
11:09:19 <ggole> It's more like a special case of it.
11:09:31 <jmcarthur> grantwu: It depends on your point of view. Once could also consider dynamic typing to be a static type system where all types are just ().
11:09:46 <grantwu> Sure, dynamic languages are just unityped static type systems
11:09:49 <grantwu> er
11:09:54 <grantwu> that's a type error right there but
11:09:59 <grantwu> I've seen the Bob Harper post yes
11:10:07 <jmcarthur> So then dynamic types are kind of degenerate static types.
11:10:13 <ReinH> And I'm not sure why you posed the question in the first place, since the question doesn't make sense to you.
11:10:37 <Tuplanolla> This discussion is steering towards philosophy again, so I recommend going through some basic materials on dynamic typing and revisiting our conversation then, ania123.
11:11:20 <hpc> it's more steering towards just teaching all the words that occurred in the question
11:11:23 <ania123> let me state my question again
11:11:48 <jmcarthur> Your question is in writing (multiple times) already.
11:11:51 <ania123> I have a type system where type inference is hard to decide
11:12:21 <grantwu> What does it mean that type inference is hard to decide?  Is it decidable or not?
11:12:34 <ania123> I need to design a programing language with this type system, so since type inference is difficult to decide statically
11:12:54 <ania123> I am asking whether it will change wrt dynamic typing?
11:13:06 <grantwu> What does this type system look like?
11:13:07 <geekosaur> there is no type inference in a dynamic typing system
11:13:09 <ReinH> Why do you think dynamic typing would help if you don't know what it is?
11:13:11 <ania123> I do not know whether it is decidable
11:13:33 <jmcarthur> Your question does not make sense. Dynamic typing would preclude type inference. Look up what dynamic typing is.
11:13:40 <Tuplanolla> I guess you could say that no type inference is vacuously trivial.
11:13:55 <ania123> type infeerence requitring to solve inequality between regular expressions
11:14:00 <ania123> more pricisly
11:14:23 <ReinH> I don't see how that is true
11:14:50 <ania123> r1<<r2  iff there is substittion sigma such that L(r1\sigma) \subseteq L(r2\sigma)
11:15:51 <grantwu> Testing equality of two regular expressions is decidable
11:16:32 <grantwu> According to http://www.diku.dk/hjemmesider/ansatte/henglein/papers/stockmeyer1973.pdf it requires PSPACE time though
11:16:43 <grantwu> er, rather, it's PSPACE-complete
11:16:48 <hpc> what do regular expressions have to do with types?
11:17:07 <ReinH> Regardless, the question is poorly posed and, given that this isn't about Haskell, my patience is wearing a bit thin.
11:17:08 <grantwu> hpc: I dunno ¯\_(ツ)_/¯
11:17:45 <jvanbure> try #haskell-offtopic?
11:18:03 <hpc> i would start first by figuring out what question you want to ask
11:18:11 <hpc> this whole thing seems very confused
11:18:31 <joe9> is TextShow the best option for converting data types to Text?
11:18:53 <ReinH> joe9: pack . show ?
11:19:03 <hpc> :t Text.pack . show
11:19:04 <lambdabot> error:
11:19:05 <lambdabot>     Not in scope: ‘Text.pack’
11:19:05 <lambdabot>     No module named ‘Text’ is imported.
11:19:10 <hpc> :t pack
11:19:12 <lambdabot> error:
11:19:12 <lambdabot>     • Variable not in scope: pack
11:19:12 <lambdabot>     • Perhaps you meant one of these:
11:19:16 <hpc> :(
11:19:53 <Tuplanolla> :t Data.Text.pack . show
11:19:55 <lambdabot> Show a => a -> Data.Text.Internal.Text
11:20:02 <ania123> grantwu: I have polimorfism, so regular expressions over varoables and alphabe letters
11:20:36 <ReinH> "polymorphism"
11:20:47 <ania123> R ::= x|a|R+R|RR|R*
11:20:48 <grantwu> ania123: I've never really heard of polymorphism connected with regular expressions
11:21:16 <ania123> I think sulzman has something related
11:21:17 <grantwu> There might be a legit question in here but not one that's obvious to us
11:21:21 <ania123> XHaskell
11:21:54 <grantwu> http://link.springer.com/chapter/10.1007%2F978-3-540-85373-2_5 ...huh
11:22:22 <ania123> yes
11:22:49 <ReinH> You could have mentioned that.
11:22:58 <ania123> ok
11:23:26 <ReinH> you don't get any points for making your question harder to understand.
11:24:29 <ania123> I am not trying to make it harder
11:24:39 <ReinH> Well, you're certainly not doing much to make it easier.
11:24:47 <hpc> does this even belong in #haskell?
11:24:52 <grantwu> ania123: I'm guessing English isn't your first language?
11:25:02 <grantwu> hpc: The linked paper is technically an extension of Haskell...
11:25:04 <ReinH> hpc: there seems to be a tenuous connection
11:26:08 <ania123> right, my english is poor
11:26:11 <geekosaur> they did say they were looking for type theory, not haskell
11:26:34 <Tuplanolla> I have an unrelated question. What array library would you recommend for convolutions and generalized convolutions (where the folding operator is customizable)?
11:30:11 <elrikdante> Hi all looking for some help on sorting-merging 1M ULInts in a linked list.  : http://lpaste.net/265390#line88
11:30:53 <ania123> no help :(
11:31:09 <grantwu> ania123: I'm pretty sure that this is a really obscure topic
11:31:09 <aukeroorda> Hey Haskellers
11:31:26 <hpc> elrikdante: why aren't you using the built-in sort?
11:31:34 <aukeroorda> I have a question about pattern matching. Can you pattern match basic operations? https://dpaste.de/D9tO#L29
11:32:13 <obadz> aukeroorda: no
11:32:14 <hpc> that last line doesn't work
11:32:16 <aukeroorda> I have a data type where basic operations like + and - are used in
11:32:21 <elrikdante> hpc: I'm eventually going to split it into worker threads using Tqueue, so I wanted to practice dealing with computational units working on some shared work load
11:32:40 <obadz> aukeroorda: :+: etc. are value constructors
11:32:42 <elrikdante> I also don't know sorting very well so I'm trying to practice that as well.
11:32:49 <aukeroorda> Yeah I tried it; Is there some way to make this work, so that I don't have to implement every basic operation a lot of times
11:32:58 <geekosaur> functions in general are cannot be matched
11:33:11 <obadz> aukeroorda: it's like doing case x of f y -> … where j would be "Just" or something like that. It doesn't work.
11:33:23 <geekosaur> and e.g. + is not as basic as you might think
11:33:30 <aukeroorda> yeah, hmm
11:33:57 <geekosaur> (specifically (+) is a typeclass member function that dispatches to a different *possibly* basic implementation based on type)
11:34:20 <elrikdante> the speed at which the program runs currently degrades horribly as the list of the size increases.  I'm not taking advantage of the structural properties of the sorted list
11:34:42 <aukeroorda> Hmm, thanks a lot for the information
11:35:18 <obadz> aukeroorda: if you really wanted you could redefine your data type as data Expr = Val Int | Var String | BinOp Op Expr Expr with data Op = Plus | Minus | Times | ...
11:35:31 <obadz> aukeroorda: then you can pattern match on BinOp op e1 e2
11:35:54 <hpc> aukeroorda: consider writing op1 (x :+: y) = x; op1 (x :*: y) = x; ...
11:35:58 <hpc> aukeroorda: and similar for op2
11:36:42 <hpc> aukeroorda: then you can write evalExpr e = op1 e `something` op2 e
11:37:36 <hpc> but that would only really put the extra lines of code somewhere else
11:37:48 <hpc> depends on what else you're doing with it
11:39:15 <hpc> elrikdante: it looks like you're trying to write parallel mergesort?
11:39:42 <hpc> with a janky quicksort as the special case for small lists?
11:40:46 <elrikdante> hpc: yeah pretty much
11:41:09 <elrikdante> hpc: the quick sort is a crutch atm
11:41:43 <hpc> so combine' looks like the merge operation, in which case you don't really need to do anything with Maybe
11:41:52 <hpc> so you have two lists
11:42:13 <hpc> if one list is empty, you merge the lists by just producing the other
11:42:49 <hpc> if neither list is empty, say they match as (x:xs) and (y:ys)
11:43:05 <hpc> the first element of the merged list is going to be the smaller of x or y (since both lists are sorted already)
11:43:16 <hpc> and the remainder of the list is going to be the merge of the remaining elements
11:43:41 <elrikdante> hpc: both lists are sorted, but the left and right trees aren't sorted when taken together.
11:44:25 <elrikdante> hpc: λ> lst <- return $ combine' (sorted [22,56,10,12,4,5,6,8]) (sorted [10,1,2,4,28])
11:44:28 <elrikdante> λ> lst
11:44:29 <elrikdante> [1,4,2,5,4,6,8,10,10,28,12,22,56]
11:44:33 <ReinH> merge sort is a tree fold of the sorted list monoid :)
11:44:41 <ReinH> tree folds are easy to parallelize
11:45:04 <ReinH> (insertion sort is a linear fold of the sorted list monoid)
11:45:35 <elrikdante> ReinH: addSorted might cover the linear case based on that description
11:45:57 <elrikdante> I was hoping to promote combine to mappend for my sorted list monoid instance once I got it working
11:46:17 <hpc> so Sorted is not the type of lists that are guaranteed to be already sorted?
11:46:24 <lpaste> Zemyla pasted “Faster semigroup multiplcation using continued fractions” at http://lpaste.net/265477
11:46:47 <Zemyla> Tuplanolla: Here's the algorithm I came up with, no tables required.
11:47:02 <hpc> ReinH: it seems so obvious in retrospect, but i had no idea there was a sorted list monoid
11:47:07 <elrikdante> hpc: the lists are sorted, it's just their combination that isn't
11:47:37 <elrikdante> I get what you're saying about combing the lists, but the result can still be out of order even though the two branches are ascending
11:47:47 <elrikdante> I'ts like I'm mising a scratch area or something
11:47:54 <ReinH> then your combining function is wrong?
11:47:58 <elrikdante> yep
11:47:59 <hpc> look at https://hackage.haskell.org/package/MissingH-1.4.0.1/docs/src/Data-List-Utils.html#mergeBy
11:48:13 <hpc> what i described above is a correct sorted list merge function
11:48:45 <Zemyla> hpc: Actually, I had a dumb idea for a sorted list monoid.
11:49:06 <Zemyla> @let newtype SList a = SList { runSList :: (a -> a -> Ordering) -> [a] }
11:49:08 <lambdabot>  Defined.
11:49:34 <Tuplanolla> Neat, Zemyla. I'll need a moment to digest this.
11:49:50 <elrikdante> That's awesome: thanks hpc
11:50:05 <ReinH> I like Conor McBride's formulation http://stackoverflow.com/a/28994079/2225384
11:51:48 <elrikdante> Thanks ReinH: =) That is dope.  I'll be using Gabriel's FoldL to handle the work queues, so that will be right up my ally
11:52:13 <elrikdante> thanks guys!
11:52:19 <Zemyla> @let instance Monoid (SList a) where { mempty = SList $ const []; mappend (SList sa) (SList sb) = SList $ \cmp -> let { merge [] lb = lb; merge la [] = la; merge la@(a:la') lb@(b:lb') = case cmp a b of { GT -> b:merge la lb'; _ -> a:merge la' lb } } in merge (sa cmp) (sb cmp) } }
11:52:19 <lambdabot>  Parse failed: Unexpected }
11:52:47 <Zemyla> Remove that extra }, I guess.
11:54:05 <hpc> ReinH: that makes me think of https://en.wikipedia.org/wiki/Sorting_network#Insertion_and_selection_networks
11:54:24 <ReinH> hpc: I think so!
11:56:02 <hpc> "While an important theoretical discovery, the AKS network has little or no practical application because of the linear constant hidden by the Big-O notation, which is in the "many, many thousands"."
11:56:08 <hpc> sometimes wikipedia really has some gems
11:56:39 <rmrfroot> can anyone give me a simple example of a algebraic group, besides integers and (+)?
11:57:15 <Zemyla> rmrfroot: The free group?
11:57:18 <Zemyla> Permutations?
11:57:41 <Zemyla> Rotations and reflections of a polygon?
11:58:18 <hpc> rational numbers and (+)
11:58:19 * hpc ducks
11:59:45 <pikajude> NaN and (==)
11:59:50 <pikajude> whoops, wrong discussion
11:59:55 <Tuplanolla> Oh no.
12:00:01 <geekosaur> heh
12:00:16 <hpc> lol
12:00:34 <Zemyla> rmrfroot: Transformations of a Rubik's cube.
12:01:19 <Zemyla> Integers and xor.
12:01:21 <rmrfroot> what about binary numbers and xor? 
12:01:23 <Tuplanolla> Anything in physics would probably work too.
12:02:00 <EvanR> rmrfroot: are you familiar with the classification of finite groups
12:02:08 <rmrfroot> sorry if i'm asking stupid questions, i guess this is what happens when programmers without formal training tries to learn abstract algebra :P
12:02:23 <EvanR> for a finite group of size N, theres only so many different groups up to isomorphism
12:03:42 <allenj12> what happens if you are using the Eval monads rpar, to calculate say a list, but later on before its done calculating everything you use the length of that list. Will it just use the WHNF of rest of the list or park until the calculation is finished
12:04:14 <ski> rmrfroot : free groups ?
12:04:58 <ski> (FSVO simple)
12:06:11 <ReinH> allenj12: length only evaluates the spine, so it will evaluate only what is necessary to construct the spine
12:07:05 <pikajude> > (length [undefined], length undefined)
12:07:08 <lambdabot>  (1,*Exception: Prelude.undefined
12:07:16 <allenj12> ReinH: gotcha, thats what I thought. thanks
12:07:46 <Tuplanolla> I still don't know which library I should use for higher-dimensional convolutions on arrays.
12:08:01 <aukeroorda> Hmm still trying with the data type: https://dpaste.de/ivvQ#L25 Is it possible to pattern match a function type?
12:09:06 <ContessaTP> you could try using an arrow instead if you want pattern matching
12:09:53 <aukeroorda> Sorry? I don't understand
12:10:05 <aukeroorda> Where should I try to use an arrow?
12:13:11 <ContessaTP> An arrow is kind of like an object representation of a function
12:13:11 <wz1000> Is there any way to prove to GHC that a closed type family satisfies a typeclass?
12:13:43 <EvanR> ContessaTP: hrm.....
12:14:15 <EvanR> as far as composition of functions goes, things like that are Category
12:14:24 <EvanR> but Arrow doesnt even let you apply functions
12:14:25 <wz1000> For example, givern type family F (b :: Bool) = r | r -> b where F True = Int; F False = Bool, can I satisfy GHC that (Show (F a)) is valid?
12:14:28 <ContessaTP> true
12:16:08 <aukeroorda> Hmm, I still don't quite follow
12:16:33 <aukeroorda> Im really new to haskell, so I don't understand too much yet
12:16:50 <Zemyla> wz1000: No, because Any is an inhabitant of every type.
12:17:12 <Zemyla> Or another bottom type.
12:17:41 <EvanR> bottom isnt a type, Any isnt a value...
12:18:39 <aukeroorda> I know that the test function together with the calculate function here work: https://dpaste.de/ivvQ#L13,20,25 Now I am trying to match the function type of the +-*/% functions (Integer -> Integer -> Integer) in my last function, test2, but this is not possible the way I am currently trying to do it. Does someone know if there exists a similar way 
12:18:39 <aukeroorda> like the test2 function that does work?
12:18:57 <aukeroorda> I know that my functions will always be of the type Integer -> Integer -> Integer
12:19:02 <romanandreg> Is there a way to fold a HashMap.Strict using Control.Lens API?
12:19:20 <romanandreg> I'm trying to foldM a map with key, values
12:19:48 <romanandreg> I tride:
12:20:22 <romanandreg> tried:  ifoldrMOf folded
12:20:23 <romanandreg>                          (\k v acc -> undefined) 
12:20:24 <romanandreg>                          []
12:20:25 <romanandreg>                          hash
12:20:28 <Zemyla> @let class Test (s :: *) where { type family Bad s :: Bool }
12:20:30 <lambdabot>  Defined.
12:20:39 <romanandreg> but that doesn't compile because folded only works on folds with Ints as keys 
12:20:53 <Zemyla> EvanR: What is Bad s for an s that isn't an instance of Test?
12:21:40 <EvanR> a type error?
12:24:52 <aukeroorda> ContessaTP: Was the suggestion to use an arrow for me? I am a bit lost here : /
12:25:32 <ContessaTP> yes, if you're not out to do anything really fancy with the functions you can try looking into using arrows
12:27:27 <aukeroorda> Do you mean https://www.haskell.org/arrows/syntax.html ? Oi oi oi
12:32:47 <carlodag1> aukerooda, Arrows are perhaps an advanced topic. In short: you can't pattern match on functions. Your `test` function was ok, if you want to operate on your custom data with (+),(-),(*),(/), then look into implementing the `Num` (and some other) typeclass(es)
12:33:06 <romanandreg> found it, just needed itraversed
12:35:08 <aukeroorda> carlodag1: Hmm, I will look into that. I think that arrows are indeed a bit too advanced for me at the moment. Thanks
12:37:58 <allenj12> is there a consensus for do blocks vs list comprehension?
12:38:42 <ski> "use whichever makes the most sense", in case both apply ?
12:39:10 <allenj12> yea, style wise since there both the same dealing with the list monad
12:39:22 <allenj12> do people prefer to read on over another
12:40:30 <Tuplanolla> There's MonadComprehensions for extra fun, allenj12.
12:40:33 <ski> can depends on the circumstance, i think
12:40:53 <ReinH> allenj12: (list comprehensions don't desugar via the Monad typeclass)
12:44:50 <allenj12> ski: what about this as a simple example I just typed up http://pastebin.com/94J4TSSQ 
12:45:33 <ReinH> allenj12: that's just fmap fib [1.;]
12:45:36 <ReinH> [1..]
12:45:52 <ReinH> Overly simple examples don't really offer much insight.
12:46:57 <allenj12> not even for style? alright, I know you can just map it, was just trying to write in a way to see if this was a complete eyesore to anyone
12:47:02 <rightfold> Is there an Applicative-like subclass of Invariant?
12:47:28 <ski> probably too simple to sway much either way, yes
12:47:34 <ReinH> They don't offer much insight because it's not something anyone is likely to write
12:47:46 <ReinH> when they can just write map fib instead
12:48:17 <allenj12> alright, maybe I will wait until I can think of a better example or just run across it later :D
12:48:17 <ski> if i'm using `replicateM',`sequence', &c. for the `[]' monad, then i'm more likely to use `do' as opposed to list comprehension, i think
12:48:26 <ReinH> a more complex example would offer more insight, because it would more accurately demonstrate the tradeoffs between do notation, list comprehensions, and some other solution more similar to the desugaring of list comps.
12:48:47 <ReinH> there's an initial cost to using do notation that an overly simple example will exaggerate
12:49:08 <ReinH> since it's a fixed cost, while a do block can become arbitrarily complex
12:49:36 <allenj12> ok
12:53:01 * hackagebot HUnit-approx 1.1 - Approximate equality for floating point numbers with HUnit  https://hackage.haskell.org/package/HUnit-approx-1.1 (RichardEisenberg)
13:23:21 <allenj12> anyone using stack run into 'package must match -any but the stack configuration has no specified version'
13:23:29 <allenj12> while running stack build
13:25:53 <glguy> allenj12: Did you specify a package without a version in your stack.yaml
13:25:55 <glguy> ?
13:26:41 <allenj12> probably not, guess I got confused because I havent had to do that yet with other imports. I ll see if I can do that
13:29:49 <allenj12> glguy: how do I know the name of the extra-dep? I want to use parralel for Control.Parralel
13:30:01 <allenj12> i cant really find it on the package page
13:30:10 <glguy> It's unlikely that parallel isn't already a part of your resolver
13:30:25 <glguy> What do you have next to "resolver:" in your stack.yaml?
13:31:05 <allenj12> lts
13:31:11 <allenj12> lts-7.1
13:32:14 <glguy> You can look at https://www.stackage.org/lts-7.1 to see what packages are already a part of that resolver and therefore don't have to be added to extra-deps
13:33:07 <allenj12> glguy: seems there is no parralel
13:33:36 <srhb> Hm, I can't figure this one out. What's different when I do "instance Show Foo" instead of data Foo ... deriving Show?
13:33:53 <allenj12> wait a minute i might be dumx
13:33:57 <allenj12> dumb
13:34:01 <geekosaur> the former doesn't provide a default instance
13:34:09 <srhb> duh
13:34:12 <srhb> :-)
13:34:17 <srhb> I was thinking of standalone deriving
13:34:19 <srhb> Derp.
13:34:32 <geekosaur> er, a default instance function. and I was wondering if I should suggest deriving instance Show
13:34:51 <srhb> geekosaur: Yes, exactly. Brainfart. Thanks :)
13:35:17 <allenj12> glguy: i think I got it, might have been a spelling error? but I got an error completely different than when using a non-existant package
13:35:43 <geekosaur> well, it's also confused by things that supply their typeclasses with default instances based on e.g. generics, so the former is actually what you want
13:39:17 <ski> @quote
13:39:17 <lambdabot> monochrom says: the guys that I see when I look into the irc window believe that I'm just a bunch of text.
13:53:02 * hackagebot pipes-extras 1.0.6 - Extra utilities for pipes  https://hackage.haskell.org/package/pipes-extras-1.0.6 (GabrielGonzalez)
13:53:04 * hackagebot rdf4h 3.0.1 - A library for RDF processing in Haskell  https://hackage.haskell.org/package/rdf4h-3.0.1 (RobStewart)
13:58:14 <Tuplanolla> Is there a canonical `Bool -> Int` somewhere?
13:58:57 <EvanR> fromEnum ?
13:59:16 <Tuplanolla> But of course!
13:59:34 <Tuplanolla> Thank you for thinking.
13:59:57 <ongy> > map toEnum [-2,-1, 0, 1, 2]
13:59:59 <lambdabot>  [*Exception: Prelude.Enum.().toEnum: bad argument
14:00:06 <ongy> > map toEnum [-2,-1, 0, 1, 2] :: [Bool]
14:00:08 <lambdabot>  [*Exception: Prelude.Enum.Bool.toEnum: bad argument
14:00:31 <EvanR> toEnum is brokey
14:01:55 <ongy> also, why did it default to () instead of telling me it's ambigous?
14:02:48 <hpc> lambdabot stuff
14:02:52 <ski> ongy : probably because of a `default ()' declaration somewhere
14:03:01 <hpc> it turns on ExtendedDefaultRules or whatever that extension is called, iirc
14:03:09 <Tuplanolla> @pl \ x y -> fromEnum (x == y)
14:03:09 <lambdabot> (fromEnum .) . (==)
14:03:38 <geekosaur> :t on
14:03:40 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:03:44 <EvanR> > toEnum ()
14:03:47 <lambdabot>  error:
14:03:47 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘()’
14:03:47 <lambdabot>      • In the first argument of ‘toEnum’, namely ‘()’
14:03:47 <EvanR> > toEnum 0
14:03:50 <lambdabot>  ()
14:03:52 <geekosaur> :t (==) `on` fromEnum
14:03:54 <lambdabot> Enum a => a -> a -> Bool
14:04:07 <erisco> Type classes are not types, nor do they construct types. They construct constraints.
14:04:25 <ongy> geekosaur: that's something different thatn Tuplanolla wants though
14:04:33 <geekosaur> oh, right
14:04:40 <EvanR> back to the difference between types and constructors
14:04:54 * geekosaur is starting to fade, sigh
14:04:57 <EvanR> with no real way to tell which were talking about
14:04:59 <Tuplanolla> Now I'm after the canonical (.:).
14:05:32 <erisco> this is a frequent stumbling block for the experienced OOP greenhorn
14:06:46 <EvanR> type classes are neither types nor classes
14:06:57 <ongy> Tuplanolla: there's https://hackage.haskell.org/package/composition-1.0.2.1/docs/Data-Composition.html which might be the most canonical you will find
14:07:25 <erisco> they are constraint constructors ^.^
14:07:38 <Tuplanolla> I didn't know I wanted (.::::.), but now I do, ongy.
14:08:23 <erisco> suspension bridge programming .::..::::..::.
14:08:42 <EvanR> according to something, "type classes" are types, because they have a kind
14:09:06 <agocorona> new extension:  ParameterizedDot :    .:3:.  ===   .:::.
14:10:11 <erisco> okay, fair enough
14:10:29 <erisco> it is then that you think they're like * types
14:11:28 <pikajude> the golden gate bridge operator
14:15:19 <agocorona> work with suspensions a.k.a space leaks
14:18:27 <ElvishJerricco> Hey everyone, could anyone who knows about adjunctions help me out? I want to put a package on Hackage, but it has its own kind of adjunction that I'm not sure I've expanded as much as I should. https://github.com/ElvishJerricco/kleisli-functors
14:20:56 <allenj12> how do i denote the namespace of the function im using to avoid clashes
14:28:08 <ski> allenj12 : `<module name>.<identifier>'
14:33:35 <allenj12> ski: thank you
14:34:07 <allenj12> also how is this possible? http://pastebin.com/X40hV6tK the function says to return a Strategy only but takes a pair argument?
14:35:06 <ReinH> What is the definition of Strategy?
14:35:10 <byorgey> allenj12: probably because Strategy is defined as a function type.
14:35:26 <byorgey> allenj12: somewhere I expect you will see   type Strategy a = ...
14:35:43 <allenj12> ooo
14:35:45 <allenj12> it is!
14:45:02 <grantwu> dfeuer: Is there an implementation of the monoid1 typeclass anywhere?
14:45:08 <grantwu> Is he not in the channel right now
14:46:06 <erisco> is it just me or is fromIntegral a mistake
14:47:11 <hpc> fromIntegral exists if you want it or not
14:47:16 <hpc> it's fromInteger . toInteger
14:48:35 <erisco> mm, no, that is not the same thing
14:49:41 <erisco> ah, what I should have said is fromInteger is a mistake
14:50:08 <erisco> I thought it was fromIntegral that was part of Num, but that wouldn't make sense
14:50:31 <Tuplanolla> It's `Num` that's the mistake here.
14:53:04 * hackagebot hyper 0.1.0.0 - Display class for the HyperHaskell graphical Haskell interpreter  https://hackage.haskell.org/package/hyper-0.1.0.0 (HeinrichApfelmus)
14:53:06 * hackagebot hyper-extra 0.1.0.0 - Display instances for the HyperHaskell graphical Haskell interpreter  https://hackage.haskell.org/package/hyper-extra-0.1.0.0 (HeinrichApfelmus)
14:53:08 * hackagebot hyper-haskell-server 0.1.0.0 - Server back-end for the HyperHaskell graphical Haskell interpreter  https://hackage.haskell.org/package/hyper-haskell-server-0.1.0.0 (HeinrichApfelmus)
14:58:57 <puregreen> is there some version of pprint for TH that prints names more intelligently based on what's in scope? I'm tired of seeing “GHC.Types.Int” where just “Int” would do
15:00:03 <erisco> nowadays we could put the bounds in the type
15:00:50 <erisco> but maybe just separate functions for each sensible conversion would suffice
15:02:13 <erisco> not the bounds, the range
15:04:49 <ertes> grantwu: Monoid1?  in the semigroupoids package there is the Plus class, which is Alternative without the Applicative constraint
15:05:18 <erisco> why does it have the Applicative constraint
15:06:04 <erisco> Alternatives are not Applicatives =\
15:07:16 <grantwu> ertes: I was referring to this post: semigroupoids
15:07:18 <grantwu> er
15:07:20 <grantwu> http://osdir.com/ml/libraries@haskell.org/2016-10/msg00000.html
15:46:18 <Gurkenglas> Would there be a reasonable Alternative instance that's not Applicative?
15:47:27 <erisco> sure, anything that is like Monoid but with kind * -> *
15:48:31 <EvanR> you mean if Applicative were a prereq
15:48:34 <EvanR> were not*
15:48:49 <erisco> endofunctors
15:49:05 <EvanR> zero or more sources suggest that Applicative should have certain laws
15:49:13 <EvanR> beyond monoid
15:49:26 <EvanR> er i mean Alternative
15:49:36 <erisco> not endofunctor, I mean endomorphisms
15:50:21 <erisco> *shrug* laws are not part of the language
15:51:38 <EvanR> the functor, monad laws are in the haskell report
15:52:58 <erisco> you could add memberless type classes for the laws which interact between two other classes
15:54:06 <erisco> it is clumsy though
15:54:34 <erisco> then there are classes which merely have members and no laws, then memberless classes which add laws
15:56:55 <EvanR> why separate them?
15:57:58 <erisco> you even see classes becoming singletons wrt members
15:59:35 <erisco> it is just about how ad-hoc you want to be
16:00:37 <EvanR> ill take classes with laws plz
16:02:00 <ertes> Gurkenglas: (Map k)
16:03:01 <ertes> that one is Bind (intersection) and Plus (union), but not Applicative/Monad (no 'pure')
16:04:41 <grantwu> How do I make something an instance of Semigroup?
16:04:57 <grantwu> https://hackage.haskell.org/package/semigroups doesn't seem to really explain
16:05:06 <grantwu> wait, never mind.
16:05:30 <grantwu> Do I want to use Data.Semigroup.Generic though?
16:05:54 <grantwu> Oh, wait, https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Semigroup.html#t:Semigroup is what I want.
16:07:06 <EvanR> now in base(tm)
16:10:30 <sgronblo_> does aeson have a way to parse json into different ADT sub-types based on a configurable field?
16:11:31 <EvanR> yes, you can implement your own FromJSON parsers
16:11:44 <jle`> sgronblo_: mhm, it's allowed to do that because it's monadic :)
16:12:23 <sgronblo_> EvanR: sure, but does it have a way to make it "easy"
16:12:38 <EvanR> do notation
16:12:54 <sgronblo_> got any examples?
16:13:05 <EvanR> read the field, branch on the result and run different parsers next
16:13:14 <EvanR> look in the aeson docs under parsers
16:13:29 <sgronblo_> EvanR: yeah but now you cant use the generic automation any more right?
16:13:48 <EvanR> im not sure i ever used that
16:13:55 <sgronblo_> ah
16:14:03 <EvanR> unless youre talking about the instance it comes with
16:14:04 <ertes> sgronblo_: variant1 <|> variant2 <|> variant3 <|> …
16:14:19 <EvanR> which you can still use
16:14:23 <ertes> sgronblo_: the Data.Aeson module haddocks explain how to write the individual variants
16:14:54 <sgronblo_> well i guess its not too bad
16:15:33 <ertes> not sure how to make it any easier without making it domain-specific
16:15:46 <ertes> custom aeson parsers are super-easy
16:15:50 <puregreen> sgronblo_: lots of examples here: https://artyom.me/aeson#more-interesting-choices. The generic automation thing lets you parse types with different constructors too, and lets you choose how to encode the configurable field, but it's not infinitely configurable
16:16:05 <EvanR> *you* can make it as easy as you want with more functions, more abstract, worse comes to worst, TH
16:16:30 <EvanR> abstraction
16:17:06 <puregreen> sgronblo_: for descriptions of different automatic ways you can use, see http://hackage.haskell.org/package/aeson-1.0.1.0/docs/Data-Aeson-Types.html#t:SumEncoding
16:17:50 <puregreen> you can choose the name of the configurable field, for instance
16:21:05 <ertes> alternatively: parseJSON (Object o) = do t <- o .: "type"; case t of "blah" -> …; "blubb" -> …
16:32:00 <Tertain> Does anyknow why this program iterating over nested vectors hangs? http://lpaste.net/266414
16:32:02 <sgronblo_> yeah i didnt mean easy as in "not difficult". just wondered if there was a way to do it with a minimum of manual effort.
16:32:49 <Tertain> I think there is some strictness happening there that I'm missing.
16:36:10 <danl-ndi> is there a way to get the conf package installing with latest haskell platform (that has base-4.9 while conf needs < 4.8)
16:36:43 <joe9> Is it a big deal to upload packages to hackage? I have a few in github
16:37:00 <jle`> Tertain: vectors aren't lazy in their length lol
16:38:25 <jle`> Tertain: V.fromList [1..] is an infinite vector
16:38:28 <EvanR> infinite vectors eh
16:38:28 <jle`> so it tries to allocate it
16:38:41 <EvanR> never thought of that
16:39:30 <EvanR> haskell is about no compromise, infinite vectors, jle` make it so
16:39:41 <Tertain> jle`: Oops, thanks I didn't realize that
16:40:00 <danl-ndi> ...or is there a better config file parser package to use?
16:40:07 <ReinH> This is why vector provides iZipWith*
16:40:20 <ReinH> Becaue the usual trick of zipWith f [0..] doesn't work
16:50:03 <grantwu> Where do I report a bug with hindent?
16:50:13 <grantwu> I guess on the GitHub
16:50:26 <ReinH> what bug?
16:51:48 <grantwu> I had a function
16:51:55 <grantwu> deref = (IM.!) . blocks
16:51:59 <grantwu> (IM = IntMap)
16:52:03 <grantwu> writing once changes this to
16:52:09 <grantwu> deref = IM.(!) . blocks
16:52:12 <grantwu> writing again changes it to
16:52:18 <grantwu> deref = IM . (!) . blocks
16:52:23 <jle`> lol
16:56:34 <ReinH> There's also a bug with derive clauses
16:56:51 <ReinH> deriving Eq => deriving (Eq) => deriving ((Eq)) => deriving (((Eq))) ...
17:00:32 <jle`> well, i don't envy the task of having to tame haskell syntax
17:02:17 <grantwu> https://github.com/chrisdone/hindent/issues/337
17:10:22 <neonfuz> @where src
17:10:22 <lambdabot> The fixed database for the `src' lambdabot command is at <https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source>
17:14:25 <neonfuz> @src foldr
17:14:26 <lambdabot> foldr f z []     = z
17:14:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:14:47 <neonfuz> why is the foldr not in <https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source>
17:14:59 <neonfuz> wait it is, nm sorry
17:16:45 <neonfuz> @src foldl
17:16:45 <lambdabot> foldl f z []     = z
17:16:45 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:31:15 <Fairy> doSomething x = ... where ... ; doSomething (x:xs) = ... where ... ;        <--- am I understanding correctly that the two "where" will never interfere with eachother? (bit banal question, I know, bit tired :S)
17:32:08 <ski> yes, each `where' attaches to its own defining equation
17:32:13 <chreekat> I'm interested in creating Arbitrary "programs" built up of individual actions defined via a Free monad. Some of the actions return values, of course, which gives the actions different types. I'm not interested in their return values, however, just in their side effects. So what I'd like is something like «arbitrary = sequence_ [list of arbitrary actions]», but I can't build the list since the actions have different types.
17:32:17 <ski> (also `x' overlaps with `x:xs' there)
17:33:06 <Fairy> ski: <3
17:33:07 <ski> chreekat : .. and generating arbitrary types tends to be not simple, as well
17:34:17 <ski> Fairy : however, if you have multiple guards on a defining equation, then the bindings from `where' are in scope in all the guards (and corresponding bodies) .. and the bindings from the patterns to the left of `=' are in scope in the `where'-declarations, obviously
17:34:49 <ski> Fairy : .. it is also possibly to attach a `where' to a branch in a `case'-expression
17:35:10 <ski> (and it's possibly to use guards there as well, should you wish to do so)
17:35:14 <chreekat> I have a concrete example for my Arbitrary programs: using instructions defined by https://github.com/chreekat/usort/blob/master/src/Merge.hs#L91, and the best i've done is create a newtype and defined Arbitrary over *just the instructions that return the same type*. In this case all side-effectful instructions return (), so it works. But that's not very general.
17:35:14 <Fairy> ski: that's what I once did, figured I didn't wish to repeat my mistakes ;)
17:35:40 * ski isn't sure what would be the mistake, here
17:36:54 <Fairy> My original code basically didn't satisfy the specs, so I'm in the process of doing a complete re-write
17:37:05 <ski> ok
17:39:51 <jle`> chreekat: that's sort of the problem that extensible-effects solves, in a way
17:41:02 <chreekat> jle`: interesting, maybe it's time for me to look into that
17:41:37 <jle`> yeah, i think it solves it by lifting them to polymorphic types that are constrained *just enough* to give the type checker what it needs
17:41:40 <jle`> and then it unifies them all
17:44:03 <jle`> chreekat: you might be able to do something similar by re-appropriating vinyl machinery too
17:44:39 <jle`> not super sure
17:47:08 <chreekat> well, that sounds fun and interesting. Thanks!
17:49:21 <jle`> chreekat: no problem! you're about to embark on a frightening and exciting journey :)
18:15:55 <ElvishJerricco> Xk
18:27:40 <ertes> that's emacs' answer to "7part"
18:34:48 <Fairy> Can I use a guard without an "otherwise" and have the haskell continue checking the remaining functions? doSomething x; | check x = x; doSomething _ = 0 ?
18:36:41 <Fairy> nvm, I can't read errors properly :S
18:36:48 <slack1256> can coerce replace numeric casting?
18:37:07 <slack1256> I forget when to fromEnum/toEnum/fromIntegral each apply
18:37:56 <kadoban> slack1256: Sounds kind of bad, you should probably just learn what they all mean.
18:38:44 <slack1256> I know what they mean, I just to want to remember
18:38:57 <slack1256> *just don't want
18:40:20 <alercah> slack1256: no, coerce cannot
18:40:47 <alercah> but coerce will probably do what you want most of the time :)
18:41:49 <geekosaur> only sometimes
18:50:45 <ski> Fairy : yes, you can
18:52:04 <Fairy> ;)
18:53:10 * hackagebot curryrs 0.1.1.0 - Easy to use FFI Bridge for using Rust in Haskell  https://hackage.haskell.org/package/curryrs-0.1.1.0 (mgattozzi)
19:53:03 <jazzycats> hi, is it possible to avoid having to type out the latter example of feature in http://lpaste.net/267073? I understand why it's not okie dokie with the first example, but, the second is just ya know, ugly
19:56:08 <lispy> jazzycats: the type of unwrap is wrong
19:56:17 <lispy> just as an aside
19:56:41 <jazzycats> lispy: i just noticed lol 
19:57:24 <jazzycats> lispy: it's just a more tiny example from what I do have
19:57:41 <jazzycats> lispy: it's just a tiny example from what I do have
19:59:22 <lpaste> mac10688 pasted “How to get config in app method?” at http://lpaste.net/267112
19:59:40 <pavonia> jazzycats: You can't do it with standard lists
20:00:40 <jazzycats> pavonia: oh so are there non-standard things I can do something similar with?
20:01:26 <pavonia> There are packages for heterogenous lists
20:01:45 <pavonia> But it's probably not worth the trouble
20:03:37 <pavonia> Using an existentially quantified wrapper type would be another option
20:05:25 <EvanR> there are ways to do hetero lists that arent that bad
20:05:33 <EvanR> but it depends on what you want to do with them
20:06:03 <EvanR> with regular lists its interesting how little you have to plan ahead regarding what youre going to do with them
20:07:08 <geppettodivacin> What do you mean by that, EvanR?
20:07:13 <geekosaur> mac10688, if `ask` doesn't work then `lift . ask`
20:07:31 <jazzycats> pavonia: ahhh existential types are what I was reading about now but they make a point about going with something similar to the second example
20:07:54 <geekosaur> or e.g. pfx <- lift $ asks prefix
20:07:55 <EvanR> after getting used to list processing style, you kind of feel like, meh ill just make an intermediate list and figure the rest out later
20:08:09 <jazzycats> EvanR: hmmm
20:08:44 <EvanR> but hetero lists tends to reveal that what you would have done makes no sense, or its trickier to say what you want
20:09:49 <EvanR> to map a hetero list, you need a type aligned list of functions, for example
20:11:11 <EvanR> the haskell way to deal with that would be to map before you put them into a regular list
20:11:20 <EvanR> assuming they all map to the same type
20:12:02 <EvanR> similar things can be said for list of existential wrappers
20:13:04 <jazzycats> EvanR: maybe another time, i found this golden mc nuggest " if you have such an existential list, the only thing you can ever do1 is execute the bar action. Well, then why not simply put that action in the list right away!"
20:13:27 <jazzycats> really i'm just trying to get away with being *lazy*
20:13:44 <EvanR> yes, the last part of that quote
20:14:08 <fred-fri> What is the getMultipleLines function doing? It's not needed? https://www.hackerrank.com/challenges/simple-array-sum
20:14:15 <geekosaur> right, but whne you want to put that action on a bunch of different things into the list, you kinda want some way to use map...
20:15:03 <fred-fri> I just did this http://pastebin.com/ums9KA0C
20:15:25 <EvanR> there were times when i thought applying later would be more natural
20:15:33 <geekosaur> was there supposed to be code in the first one? I got the submission page
20:16:07 <fred-fri> switch to haskell and youll get some prefilled code
20:16:50 <mac10688> geekosaur, I haven't see anything about this asks function. Where is that?
20:16:50 <phaskell-1> No symbol 'that' found anywhere.
20:16:50 <phaskell-2> No symbol 'that' found anywhere.
20:17:17 <jazzycats> geekosaur: sure that makes sense. Although if I immediately map the function doesn't that avoid the benefit you mentioned?
20:17:45 <geekosaur> jazzycats, that was aimed at EvanR, not you; it's summarizing your problem, you could say
20:18:02 <EvanR> immediately applying the function before you put it in a list works, but sometimes its kind of awkward wrt what you already have going
20:18:04 <geekosaur> as viewed through that quote
20:18:14 <EvanR> so sometimes you can use rankN types to help
20:18:29 <jazzycats> geekosaur: ahh yeah
20:18:36 <glguy> I've been playing with a library for working with existentially quantified types http://lpaste.net/267073
20:19:24 <geekosaur> mac10688, https://downloads.haskell.org/~ghc/8.0.1/docs/html/libraries/transformers-0.5.2.0/Control-Monad-Trans-Reader.html#v:asks and you're already importing that module
20:19:28 <EvanR> cool
20:19:44 <EvanR> which library
20:20:07 <geekosaur> it's a variant of ask that takes a function to apply to the reader environment; convenient for, say, pulling one field out of a record, you can say asks theField instead of catching the whole recoird with ask and then extracting the field you want
20:20:21 <mac10688> geekosaur, cool! I never thought to look there. I should have though. Thanks! This is a practice problem from a book. I didn't realize all the imports
20:20:39 <glguy> EvanR: me?
20:21:47 <EvanR> yeah
20:22:04 <glguy> EvanR: I put the URL next to the import for the Object module
20:22:22 <glguy> It's not released beyond my github, I'm still exploring it for a DSL I'm working on
20:22:31 <geekosaur> fred-fri, it doesn't make sense with that problem specification. I would suspect an earlier iteration of it had a line with the number of elements, then the array with one element per *line*; then they didn't change the code fully, or something
20:22:31 <geppettodivacin> fred-fri: Looks like getMultipleLines is identical to `take n . lines . getContents`
20:22:34 <EvanR> oh didnt see the bottom section
20:23:07 <geppettodivacin> fred-fri: I also agree with geekosaur, it's not really necessary.
20:23:10 <fred-fri> I'm glad I'm not alone in thinking it's unnecessary
20:23:17 <fred-fri> i was really thrown off by it
20:23:48 <geppettodivacin> fred-fri: Also interesting is that the function isn't used in the example main function.
20:23:58 <geekosaur> yep, that;s why I think it's a fossil
20:24:02 <fred-fri> yes
20:24:19 <geekosaur> because it would make sense if an earlier version of the problem had one element per line instead of one line with space-separated elements
20:24:31 <ludat> so, I have a little weird problem with stack, when I build the template for servant I get this error http://pastebin.com/Xf1h7vV9
20:25:58 <ski>   mapNK :: forall cs ds. cs ⊆ ds => Object ds -> (forall o a. All cs a => a -> (forall b. All ds b => b -> o) -> o) -> Object ds  -- glguy ?
20:26:18 <lolisa> Hi, what haskell high-level gui library work good on both windows and *nix?
20:27:13 <EvanR> three-penny-gui
20:27:29 <EvanR> ghcjs
20:30:01 <ski>   mapNK :: forall cs ds es fs. (cs ⊆ ds,es ⊆ fs) => Object ds -> (forall o a. All cs a => a -> (forall b. All fs b => b -> o) -> o) -> Object es  -- or even ?
20:31:44 * ski . o O ( `forall a. All cs a => a -> ExistsId (All fs)' )
20:32:56 <lolisa> EvanR, thx! looking at three-penny, look dope to me
20:34:46 <fred-fri> geppettodivacin, geekosaur: the getMultipleLines method has type Int -> IO [String], how would you print what it collects?
20:35:06 <geekosaur> you use it with <-
20:35:09 <fred-fri> im attempting to use it just for kicks although as mentioned its an unnecessary fossil
20:35:15 <geekosaur> you might want to read up on how IO works
20:35:45 <jazzycats> glguy: it looks interesting, but, it's mostly new stuff for me and the assignment is due in the next few days lmao
20:35:59 <fred-fri> ah, same as getLine
20:36:04 <geekosaur> yes
20:36:18 <fred-fri> I think I get it, I'm just a slow, unobservant learner
20:36:39 <geekosaur> well, the way this stuff works in Haskell is a bit different than you'd be used to from other languages
20:36:44 <radvendii> is this the right place to ask a question about template hsakell?
20:36:48 <geekosaur> yes
20:37:02 <geekosaur> (although I personally can make no promises about being able to answer...)
20:37:54 <radvendii> okay, so I'm trying to quasiquote the contents of a String variable. And I'm running into all kinds of problems and it seems like it might not even be possible
20:38:17 <geekosaur> no, I wouldn't expect that to work
20:38:18 <radvendii> as in, I have a variable a = "1 + 1" lets say
20:38:20 <radvendii> oh
20:38:23 <radvendii> shoot
20:38:26 <radvendii> why?
20:38:26 <geekosaur> that value exists at runtime, not compile time
20:38:38 <geekosaur> quasiquotes exist only at compile time, not runtime
20:38:43 <radvendii> ah, right.
20:39:29 <radvendii> okay, is there a way to parse haskell at runtime?
20:39:48 <geekosaur> haskell-src-exts package, or ghc-api
20:40:10 <geekosaur> I suggest the former, as the latter is both painful and subject to change with every ghc release
20:40:31 <radvendii> thanks! will that allow me to make a quasiquote that essentially builds off of haskell (like do notation)
20:40:32 <geekosaur> (also packages such as hint, for e.g. evaluating Haskell code at runtime)
20:41:30 <geekosaur> up to a point. it's subject to the staging restriction, so you can't refer arbitrarily to things outside of the quasiquote, but depending on what you are doing that may be sufficient
20:41:40 <geekosaur> for some things, you are better off with a preprocessor
20:42:14 <radvendii> interesting. I think that ultimately I want to make this into a syntax extension. Mostly this is to test the concept
20:42:48 <geekosaur> (in regular code, you can refer to things that are not defined until later. in anything that happens at compile time, those things have not been seen yet and cannot be referenced; likewise anything in the current "chunk" of code has not yet been fully defined.)
20:43:43 <slack1256> any package that launch a http.server on the current folder?
20:43:49 <slack1256> like python3 -m http.server
20:44:13 <radvendii> geekosaur: thanks. I'll look into hint and src-exts
20:48:35 <jle`> slack1256: wai i think
20:48:49 <jle`> er, warp
20:51:05 <jle`> @hackage wai-app-static
20:51:06 <lambdabot> http://hackage.haskell.org/package/wai-app-static
20:53:12 * hackagebot sensei 0.2.0 - Automatically run Hspec tests on file modifications  https://hackage.haskell.org/package/sensei-0.2.0 (SimonHengel)
20:53:14 * hackagebot HUnit 1.5.0.0 - A unit testing framework for Haskell  https://hackage.haskell.org/package/HUnit-1.5.0.0 (SimonHengel)
20:53:16 * hackagebot quickcheck-io 0.1.4 - Use HUnit assertions as QuickCheck properties  https://hackage.haskell.org/package/quickcheck-io-0.1.4 (SimonHengel)
20:53:18 * hackagebot hspec-expectations 0.8.1 - Catchy combinators for HUnit  https://hackage.haskell.org/package/hspec-expectations-0.8.1 (SimonHengel)
20:55:24 <joe9> I have some data that is serialized in little endian format. Which package should I use? Data.Binary or Cereal?
20:55:42 <joe9> I do not want to use the IO monad for this. Just pure code.
20:55:51 <joe9> I think both packages support Either return type
20:58:01 <EvanR> attoparsec and Data.Bits maybe
21:02:57 <joe9> EvanR: It seems Vector is pretty fast for decoding/encoding little endian byte strings
21:03:06 <joe9> https://www.fpcomplete.com/blog/2016/03/efficient-binary-serialization got it from here
21:05:10 <joe9> it seems that a vector expects a length field of Int64 as the first field. I get a length of 32 bits as the first field.
21:05:43 <EvanR> youre trying to "cast" a blob of your own as a vector?
21:06:02 <lispy> joe9: binary and cereal can both do it without IO but use a Put monad
21:06:41 <lispy> the put monad is really for efficiently inserting into the bytestring
21:09:04 <joe9> EvanR: No, I am reading little endian data from a socket.
21:09:23 <joe9> EvanR: The message has 32 bits of length data in the beginning.
21:09:40 <mac10688> geekosaur, I'm confused how ask can help me get the Configuration. ask :: ReaderT r m r. if I runReaderT I'm left with r -> m r. I need an r to kick it off and get the new r
21:10:16 <lispy> joe9: I'm pretty sure the cereal maintainer does that it at least one of his libraries. Let me check.
21:10:31 <mac10688> geekosaur, it seems that lift ask would just wrap it more. I'm trying to dig in.
21:10:47 <lispy> joe9: ah yeah, this library uses cereal and implements tcp: https://hackage.haskell.org/package/hans
21:11:12 <geekosaur> mac10688, lift reaches inside the ScottyT to the Reader
21:11:18 <geekosaur> type Scotty = ScottyT Text (ReaderT Config IO)
21:11:47 <joe9> lispy but cereal and binary seem to be pretty slow as per https://www.fpcomplete.com/blog/2016/03/efficient-binary-serialization
21:12:42 <geekosaur> I would expect ScottyT to already have a MonadReader m => ScottyT (ReaderT m) instance, so ask or asks should just work. if not, lift will apply something to that embedded ReaderT
21:13:32 <geekosaur> unless it also doesn't have a MonadTrans instance, but in that case it should not have a T extension because the convention is that means it is MonadTrans
21:13:48 <lispy> joe9: FWIW, they link to the set of performance related PRs they created for cereal and all of them are closed now: https://github.com/GaloisInc/cereal/pulls?q=is%3Apr+author%3Abitonic+is%3Aclosed
21:15:26 <geekosaur> er I wrote that MonadReader instance wrong, but the point remains that transformers generally include derived instances for useful things like MonadState and MonadReader, so you can use them directly
21:16:18 <joe9> lispy, you recommend cereal?
21:16:18 <mac10688> I'll try to put it together. I'm really confused though
21:16:52 <lispy> joe9: I'm biased. I sit next to the maintainer at work. Use whatever you are comfortable with. I mostly wanted to make the point that cereal is up to the task.
21:17:14 <joe9> lispy: ok, Thanks.
21:17:51 <lispy> yw
21:19:02 <geekosaur> mac10688, you probably want to learn about monad transformers. they can be confusing at first, but because you are working in something of type Scotty () (which is ScottyT Text (ReaderT Config IO) ()) you can use lift to get to the ReaderT Config, and if ScottyT derives MonadReader you should be able to use ask or asks directly to get at the ReaderT Config
21:19:52 <geekosaur> that type means the ReaderT Config is already passed in (these things are functions with hidden parameters)
21:20:02 <geekosaur> @unmtl ReaderT Config IO
21:20:02 <lambdabot> Plugin `unmtl' failed with: `ReaderT Config IO' is not applied to enough arguments, giving `/\A. Config -> IO A'
21:20:05 <geekosaur> whoops
21:20:08 <geekosaur> @unmtl ReaderT Config IO ()
21:20:08 <lambdabot> Config -> IO ()
21:20:13 <lispy> There are many ways to learn about monad transformers, I liked this one when I was starting out: https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf
21:20:18 <mac10688> lol I'm trying to finish the MonadTransformers Chapter of Haskell book
21:20:29 <geekosaur> the unmtl plugin won't know ScottyT because it's not defined in mtl
21:21:44 <joe9> cereal seems to have less dependencies compared with binary
21:25:24 <glguy> jazzycats: Yeah, that wasn't intended for your assignment.
21:35:12 <lispy> glguy: data Object cs = forall a. All cs a => Object a, how do I read that?
21:35:26 <lispy> glguy: I looked up All, it seems to be gathering the constraints of cs
21:41:19 <joe9> how are bytestrings of haskell stored (big endian or little endian)? I have a haskell bytestring that I want to convert to little endian format using cereal. There is a putByteString . But, I am not sure in format it will be putting the data
21:41:30 <Zemyla> Is there a Haskell equivalent to the perldiag page, a comprehensive list of errors the compiler or RTS can return?
21:42:21 <EvanR> joe9: how you serialize a bytestring is up to you, but prior to that point you are looking at Word8's
21:42:30 <EvanR> which dont have endianness
21:42:45 <mac10688> https://stackoverflow.com/questions/40066909/readert-static-environment
21:43:02 <mac10688> if anyone knows the answer to what a static environment to a monad means
21:43:04 <EvanR> what putByteString does.... good question
21:43:33 <EvanR> actually, no that still doesnt involve endianness
21:43:40 <joe9> EvanR: I have this data type https://paste.pound-python.org/show/koovYSceSwzKdbESM2Rw/
21:43:44 <EvanR> byte buffers are byte-oriented
21:43:56 <joe9> EvanR: I know what to do with the Word32's (get/putWord32le)
21:44:08 <lispy> Zemyla: I think there used to be, but it's probably a decade out of date :)
21:44:13 <EvanR> yeah so 4 bytes in your bytestring, the format is your choice
21:44:13 <joe9> EvanR: so, little endian then?
21:44:19 <geekosaur> mac10688, it's just a parameter under the hood
21:44:28 <geekosaur> see the @unmtl I did earlier
21:45:13 <EvanR> joe9: its a bit roundable to go through Word32
21:45:13 <geekosaur> ReaderT is quietly passing the "environment" (in your case Config) to every function that has a type ReaderT Config ... (or a monad transformer over that type)
21:45:19 <EvanR> roundabout
21:45:20 <joe9> EvanR: Where do I specify that format? the bytestring holds a string value. so, can I assume that it will be in little endian format?
21:45:33 <EvanR> no, you sound confused now
21:46:04 <joe9> the field twWnames is a list of Strings
21:46:14 <EvanR> Strings are list of Char
21:46:32 <EvanR> then what
21:46:41 <joe9> EvanR: I do not want to convert to String. After I read the big bytestring, I could leave it as a list of bytestrings or convert it to a list of Text
21:46:56 <EvanR> so the bytestrings have, like ascii digits in them?
21:47:05 <mac10688> oh ok geekosaur, I didn't realize that. I bet once I understand that, I'll know how to get the Config I want so bad lol
21:47:09 <joe9> EvanR: yes, "root" , "usr" , etc.
21:47:19 <geekosaur> I told you how to get it. What was unclear?
21:47:28 <EvanR> ok, so where is your question about endianness coming from
21:48:01 <joe9> EvanR: I am reading all this data using cereal and I can do getByteString to read into a bytestring.
21:48:17 <joe9> But, I am not sure how haskell stores bytestring (little endian?)
21:48:22 <EvanR> its byte by byte, from beginning to end, no endianness
21:48:43 <EvanR> endianness only refers to encodings of Word16, Word32, Word64 as bytes
21:49:00 <joe9> oh, ok, cool. so, a simple put/getByteString is what I need. Thanks.
21:49:10 <EvanR> sounds right
21:50:45 <joe9> if you are representing a name such as "usr", etc and you are reading it as a bytestring, Would you have the haskell data type a byteString or would you prefer Text as it is a Text'ual name
21:51:13 <EvanR> depends
21:51:35 <EvanR> what your API is expecting, whether you need to do anything with the raw data besides dump it into another socket
21:52:25 <joe9> mostly storing it in state or writing to another socket aftre processing
21:52:46 <EvanR> if the processing involves text processing... might want Text
21:52:48 <joe9> or, maybe writing to logs, when debugging is on.
21:52:59 <Zemyla> Yeah, I'm going through strings from a simple program, and there are errors like "freeHaskellFunctionPtr: not for me, guv!"
21:53:09 <Zemyla> Which is something that definitely needs an explanation.
21:53:14 * hackagebot relational-query 0.8.3.2 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.3.2 (KeiHibino)
21:53:16 * hackagebot jsaddle 0.5.2.0 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.5.2.0 (HamishMackenzie)
21:53:18 * hackagebot hspec-expectations 0.8.2 - Catchy combinators for HUnit  https://hackage.haskell.org/package/hspec-expectations-0.8.2 (SimonHengel)
21:53:22 <EvanR> writing to logs, that counts as "dumping to a socket"
21:53:28 <joe9> EvanR: with Text procesing, you mean splitting on a ',', etc?
21:53:50 <EvanR> you might be able to get away with splitting on ',', (ord ',')
21:54:01 <EvanR> if your data is definitely valid
21:54:08 <joe9> that is the most text processing I can think of.
21:54:42 <EvanR> even if you dont convert to Text i would probably run it through UTF8 validation before doing anything
21:55:10 <joe9> EvanR, why?
21:55:28 <EvanR> you dont care if invalid data gets through?
21:55:51 <lispy> Zemyla: that's an odd one. Not much on google, even
21:56:17 <EvanR> Zemyla: you didnt trigger that error right...
21:58:00 <Zemyla> EvanR: Nope, browsing through strings <some small executable I made>.
22:01:58 <geekosaur> mac10688, the point is that at the time your function :: Scotty () is run, it already has the Config passed in from outside. you do not *create* the Config there, you would do that where you invoke scotty
22:06:13 <joe9> EvanR: can I override instances this way? https://paste.pound-python.org/show/WOvgQAlT95ZXLuFCIeOX/ if I can do that, I can let generics of Serialize derive the get/put for the datatype, correct?
22:07:50 <geekosaur> mac10688, http://stackoverflow.com/questions/26065765/how-to-get-readert-to-work-with-another-monad-transformer
22:08:12 <mac10688> thank you geekosaur , reading that now
22:08:42 <geekosaur> that shows how to start scotty with your config. you then use ask or asks in app to access the config that is passed in
22:09:56 <EvanR> joe9: seems right
22:10:03 <joe9> EvanR:  I would need a newtype to do that. That would complicate things further.
22:10:16 <EvanR> but. thats not as flexible as specifying it in the instance for Tcreate
22:10:33 <EvanR> Word32 has a default instance?
22:10:52 <joe9> EvanR: It does, and it uses getWord32be
22:11:43 <EvanR> network byte order
22:11:50 <EvanR> makes more sense ;)
22:12:14 <joe9> https://paste.pound-python.org/show/BVBdMsSvY0zXFdJi2eU8/
22:17:57 <lifter> I'm aware of a common pattern when it comes to writing a long function signature across multiple lines: "f :: a -> b -> ..." can be written "f :: a" on the first line, "-> b" on the second line aligning "->" w/ "::". What is typically done for a function that has a typeclass restriction and "=>"?
22:18:47 <geekosaur> same thing works, you can also break a multiple component constraint at commas
22:19:13 <lifter> Does the typeclass restriction appear on the first line, as in "f :: (Ord a)" and then "=>" appears on the next line horizontally aligned to "::"?
22:19:15 <grantwu> I have a list of values and a predicate.  I want to separate the list into contiguous sequences for which the predicate holds and have the ones in the sequence which fail the predicate come out one by one
22:19:23 <grantwu> I assume I want some sort of... takeWhile?
22:19:56 <jle`>     :: (Monad m, Num a)
22:20:00 <grantwu> meh, I should just write a plain recursive function that uses takeWhile
22:20:00 <jle`>     => a
22:20:03 <jle`>     -> b
22:20:19 <lifter> jle`: Yeah ok, thanks
22:20:25 <geekosaur> lifter, the form shown in http://hackage.haskell.org/package/scotty-0.10.2/docs/Web-Scotty-Trans.html works
22:20:57 <lifter> geekosaur: Cool, thanks!
22:21:37 <jle`> lifter: i've also stoppoed upping the :: ( ... ) on the same line as the name
22:22:25 <jle`> so that you can copy/paste easier, and also so that changing the name doesn't require you to re-align everything
22:22:44 <lifter> Ah yeah, I can see that
22:23:48 <lifter> Another question: I sometimes let the compiler tell me the type sig of a function I've written. I often see "forall" in the compiler's signatures. But it seems that in most (all?) cases I can leave out the "forall" and the compiler doesn't complain. Are there guidelines for when to put an explicit "forall" in a sig?
22:24:24 <jle`> lifter: for the most part i only put it if i need it for scoped type variabl
22:24:25 <jle`> es
22:24:49 <lifter> jle`: in which case the compiler will complain if you leave it out?
22:25:15 <jle`> yeah.  or well, it's more that the type signature means something different
22:25:25 <lifter> ah
22:25:30 <lifter> hmm
22:25:56 <lifter> Honestly I don't really understand the purpose or need of forall. Maybe I should read up on it.
22:26:16 <jle`> if you have any type signatures in helper functions or any where in the function body, the type variables you use would not refer to the type variables of the top-level signature
22:26:31 <jle`> foo :: a -> b -> a
22:26:45 <jle`> and you had a helper function inside, go :: a -> b ..., etc., the 'a' doesn't refer to teh same a at the top level
22:26:54 <jle`> the the compiler will often complain
22:27:24 <jle`> in this case, you need to explicitly scope the type variables in foo, as foo :: forall a b. a -> b -> a
22:27:36 <lifter> ah
22:27:48 <lifter> how interesting, so we're talking about type variables shadowing other type variables
22:27:51 <jle`> so yeah, basically you should use the explicit forall if you watn to refer to the type variable later in inside the definition of function
22:27:54 <jle`> yeah
22:28:05 <lifter> ok!
22:28:07 <jle`> using forall introduces the 'a' into scope so that you can use it later in the function
22:28:13 <lifter> cool
22:28:21 <jle`> but, it's kind of annoying that it shows up in the haddocks though
22:28:26 <jle`> because the user shouldn't really need to care
22:28:49 <lifter> yeah it seems to show up fairly often and in most cases seems redundant
22:29:15 <jle`> because of the fact that the forall shows up in the haddocks makes me avoid using it if i don't need it
22:31:49 <dolio> If it were required to always use forall, we might get fewer questions from confused people here.
22:35:44 <jle`> some have suggested that we teach haskell from the start with making people do explicit foralls so it won't be confusing later
22:39:30 <lifter> If we had a book that teaches what forall is it would be an improvement. Maybe Haskell From First Principles does...
22:40:12 <lifter> I read LYAH and RWH but I don't think either mentioned it
22:40:37 <LordBrain> hmm i'm skeptical that this confusion is really there
22:41:06 <geekosaur> well, it's reallynot a beginner thing normally. and it's somewhat unfortunate that ghc throws it in your face
22:41:20 <LordBrain> under certain circumstances the interpretter ghci prints forall
22:41:26 <LordBrain> sometimes it doesnt
22:41:36 <mac10688> geekosaur, I think I got the config now. config <- lift ask. 
22:41:46 <LordBrain> i think depending on how it was linked or interpretted
22:42:07 <geekosaur> mac10688, yes, as I told you a couple hours ago in my first response 
22:43:19 <mac10688> geekosaur, yeah I was just letting you know I understand now. I'm a little slow
22:44:06 <geekosaur> well, yu strike me as a beginner. frameworks like scotty are not ideally suited for beginners, at least if you go beyond the basic 'scotty myApp'
22:44:56 <mac10688> I'm just following the chapters in the Haskell Book written by Chris Allen and Juli Moronouki
22:46:05 <mac10688> I've been at this for 2 years now. I still have blank spots though. I just have to keep going
22:47:38 <grantwu> mac10688: you can do it
22:48:38 <lifter> This is interesting. I have a handful of pattern synonyms (as in the PatternSynonyms extension) with foralls... taking out those foralls made the compiler quite unhappy
22:50:52 <lifter> er...
22:50:55 <lifter> on sec
22:50:58 <lifter> one sec
22:52:16 <lifter> yeah for example I have this pattern of type "forall a b. (a, Maybe [b])" and if I remove the "forall" the compiler says "Not in scope: type variable ‘a’"
22:53:16 * hackagebot hspec-meta 2.3.2 - A version of Hspec which is used to test Hspec itself  https://hackage.haskell.org/package/hspec-meta-2.3.2 (SimonHengel)
22:54:10 <lifter> ahh maybe not I'm really confused
22:56:15 <ab9rf> but are you metaconfused?
22:56:35 <lifter> gosh probably
23:05:54 <geekosaur> rank-N confused, probably :)
23:06:03 <geekosaur> or at least rank-2
23:47:33 <grantwu> Is there a way to like
23:47:38 <grantwu> Get case fallthrough in cases
23:48:01 <taktoa> pattern matches (including in case expressions) normally have fallthrough?
23:48:10 <grantwu> oh
23:48:26 <grantwu> what I meant is that... actually nvm this makes no sense
23:48:44 <taktoa> like in case ... of { X -> ...; Y -> ...; } if X fails to match, Y will match
23:49:04 <taktoa> I'm guessing that you're looking for something like guards
23:49:29 <taktoa> for a while I didn't realize you could use guards in definitions with multiple patterns
23:50:08 <taktoa> *definitions/case expressions with multiple cases
23:50:16 <taktoa> w/e
23:50:30 <grantwu> http://lpaste.net/5293221337446219776 is my code
23:50:50 <grantwu> urgh... no, I actually do need separate cases
23:50:51 <taktoa> okay, and what do you want to do
23:51:37 <grantwu> let me write it out with the duplication first
23:51:51 <taktoa> good idea
23:53:17 * hackagebot hspec-core 2.3.2 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.3.2 (SimonHengel)
23:53:19 * hackagebot hspec-discover 2.3.2 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.3.2 (SimonHengel)
23:53:21 * hackagebot hspec 2.3.2 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.3.2 (SimonHengel)
23:53:30 <fred-fri> can anyone explain this? http://pastebin.com/9b28jGPW
23:53:42 <taktoa> grantwu: ping me (i.e.: say "taktoa") when you finish that
23:54:09 <ongy> :t readLn
23:54:11 <lambdabot> Read a => IO a
23:54:17 <geekosaur> fred-fri, you need to specify a type, otherwise ghci is defaulting it to ()
23:54:26 <geekosaur> (although a compiled program will default it to Integer)
23:54:53 <ongy> putStrLn takes a String, so it's trying to parse it to String
23:55:09 <geekosaur> oh, right
23:55:26 <geekosaur> but readLn uses read, so it has to be a *quoted* string
23:55:31 <geekosaur> use getLine instead
23:56:21 <grantwu> taktoa: http://lpaste.net/4159607776714162176
23:57:00 <geekosaur> > read "bla bla" :: String
23:57:02 <lambdabot>  "*Exception: Prelude.read: no parse
23:57:08 <taktoa> grantwu: let me chew on that for a few minutes
23:57:21 <geekosaur> > read "\"bla bla\"" :: String
23:57:23 <lambdabot>  "bla bla"
23:57:24 <fred-fri> cheers
23:57:30 <grantwu> taktoa: Redundancy is in the first 2 and last case
23:57:53 <Xnuk> > read . show $ "bla bla"
23:57:55 <lambdabot>  *Exception: Prelude.read: no parse
23:58:10 <Xnuk> > (read . show $ "bla bla") :: String
23:58:12 <lambdabot>  "bla bla"
23:58:12 <geekosaur> *that* one is defaulting to ()
23:58:26 <geekosaur> > read . show $ "()"
23:58:28 <lambdabot>  *Exception: Prelude.read: no parse
23:58:32 <geekosaur> hm, ir not
23:58:45 <geekosaur> oh, wrong order for that :p
23:58:50 <geekosaur> maybe past my bedtime
23:59:54 <fred-fri> getLine >>= putStrLn works fine
