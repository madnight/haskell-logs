00:00:51 <Sinestro> It's ~1500 items, so I'd think so
00:01:26 <EvanR> yeeahh i dunno about that
00:01:39 <Sinestro> Looking at my profiler, it takes it from 2 seconds to 600 ms of actual my-code time... that could just be the profiler not getting it
00:02:06 <Lokathor> unless it's 1500 "huge" items, that doesn't sound like enough to bother
00:02:30 <EvanR> if its taking 2 seconds thats a lot
00:02:47 <EvanR> are you using +RTS -N2
00:02:54 <EvanR> and -threaded
00:02:57 <Sinestro> That's 2 seconds without threading
00:03:13 <Sinestro> It takes 12 seconds trying to use parallel_ from parallel-io
00:03:23 <EvanR> try async
00:06:42 <Sinestro> I just tried monad-par, and I managed to get only a slight decrease in speed. Maybe it's screwing up the vector library's fusion and that's enough to hurt?
00:08:08 <Sinestro> Maybe something lower level is the solution... Split the vector into n equally sized chunks, spawn n threads, let it rip
00:08:19 <Sinestro> I might be getting too smart for my own good
00:08:20 <EvanR> oh i figured thats what you were trying
00:09:32 <Sinestro> Nah, I was trying to get clever about how I was splitting it up
00:09:42 <Sinestro> Looking more at the profiling, I think the cleverness was the problem
00:10:52 <lpaste> allenj12 pasted “How is this ordered?” at http://lpaste.net/297389
00:19:00 * hackagebot record-syntax 0.1.1 - A library for parsing and processing the Haskell syntax sprinkled with anonymous records  https://hackage.haskell.org/package/record-syntax-0.1.1 (NikitaVolkov)
00:29:01 * hackagebot record-preprocessor 0.1.1 - Compiler preprocessor introducing a syntactic extension for anonymous records  https://hackage.haskell.org/package/record-preprocessor-0.1.1 (NikitaVolkov)
00:34:12 <piyush-kurur> Lokathor: if you are interested in working for  pull request for raaz please let me know may be by joining #haskell-raaz. Going for lunch now.  
00:34:49 <Lokathor> afraid i don't really have the time for it :/
00:35:34 <piyush-kurur> Lokathor: no problems
00:39:02 * hackagebot record-preprocessor 0.1.1.1 - Compiler preprocessor introducing a syntactic extension for anonymous records  https://hackage.haskell.org/package/record-preprocessor-0.1.1.1 (NikitaVolkov)
00:43:15 <ongy> what's the easiest way to get a modify function on a record? Lens?
00:44:44 <liste> ongy: is the record modification syntax OK, eg. "data Rec = Rec { field1 :: Int, field2 :: Char }" and "myRec { field1 = 42 }" ?
00:45:09 <ongy> that's a set/write thing. I need modify
00:45:53 <liste> so Rec -> (Field -> Field) -> Rec ?
00:46:00 <ongy> yes
00:46:18 <Lokathor> in general, that sounds like a lens
00:46:21 <Sinestro> I've officially given up :/
00:46:49 <Lokathor> ongy, if you want to write it for a specific field on a specific record you can also just write the func
00:46:50 <Sinestro> At best, with `async`, I managed to get down to 4x overhead from parallelism
00:47:18 <Axman6> so, say I had a type, such as newtype PlainTextSecrets = PlainTextSecrets Text, and I wanted to make sure it could never have say a Binary instance, what would be the best way to do that? thinking about actually defining the instance as something like instance Binary PlainTextSecret where put = error "NO!" {-# WARNING "You are using the Binary instance for PlainTextSecret, you should never do
00:47:25 <Axman6> this" #-} - would that work?
00:48:36 <Lokathor> Axman6, you should... that is... i mean if you have to.......
00:49:09 <glguy> adding the runtime error instance is worse than no instance
00:49:12 <Lokathor> why must you ensure that it never gets a Binary instance? I mean if others are going to they can just newtype over your newtype so
00:51:43 <delYsid> ongy: Idris can do field updates, record { field $= func } rec
01:00:07 <ertes> ongy: lens
01:02:58 <ertes> Sinestro: just firing up four threads (make sure you compile with -threaded), each on a chunk of the array, should work…  if it doesn't, maybe your algorithm finishes too quickly, or the algorithm is non-uniform in its running-time and one chunk takes longer than the other
01:04:47 <cocreature> Sinestro: are you actually running on multiple threads? you need to pass "+RTS -N" and compile with -threaded as ertes explained
01:04:54 <damping> Does anyone know a good free online Haskell development environment?
01:05:02 <ertes> Sinestro: another issue may be that with too many threads you pass the threshold where some or all of the CPU caches become useless, but that should only happen, if individual threads work on a huge chunk of data at once
01:09:17 <damping> Also, as it's possible to access a machine remotely via VPN and SSH, is there a server which will simply provide ghci instead of an OS terminal via ssh?
01:10:30 <ertes> damping: if you have SSH access, you can bypass the shell:  ssh host ghci
01:11:29 <damping> Like a browser based version of ghci which I can use a server to vend to localhost
01:11:43 <ertes> damping: oh, and "free", "good" and "online" sounds like a triangle:  free, good, online, choose two =)
01:12:00 <damping> Free good
01:13:40 <ertes> Sinestro: oh, and if it hasn't been recommended already, i'll do it now:  you should read The Book:  http://chimera.labs.oreilly.com/books/1230000000929
01:14:00 <Sinestro> I've been reading it now
01:14:13 <damping> One that could allow me to provide a good free online Haskell development environment online, which I could password protect, or access via vpn...
01:14:21 <damping> Online
01:15:29 <ertes> damping: i think FPComplete has (had?) something like that: an in-browser IDE for haskell…  i don't know whether it's free though, probably not
01:15:59 <damping> Lie that but in that can be installed via cabal
01:16:04 <damping> Like*
01:16:41 <damping> I doubt i can access the fp complete source
01:17:14 <Sinestro> ertes: I think I just have to accept that I've somehow managed to make triangle rasterization not parallelize, and then... Dunno. Go cry I think. I know it is trying because playing with the -N value changes the speed, it's just at best 3.3x slower than a single thread.
01:17:58 <ertes> Sinestro: are you using +RTS -N, as cocreature said?
01:18:03 <Sinestro> It's either a cache-doesn't-like-sharing-big-chunk-of-memory issue or it's trying to do something too safely
01:18:16 <damping> It's just a short webpage capturing stdIO right?
01:18:37 <Sinestro> `stack exec -- lil-render +RTS -N2`
01:18:43 <cocreature> Sinestro: could you show the relevant parts of your code?
01:19:39 <ertes> Sinestro: are you triangles actually large enough that it matters?  parallelisation doesn't really pay off for 200 pixels, but it definitely pays off for 100000 pixels
01:21:21 <lpaste> Sinestro pasted “My terrible renderer” at http://lpaste.net/297495
01:21:37 <Sinestro> It's not within-the-triangles, I already realized that was a bad idea. That's the dispatching bit
01:22:47 <ertes> Sinestro: is that even possible?  as soon as you do something like a depth test, the threads will hate each other
01:25:18 <Sinestro> Why? It just does an only-write-if-my-Z-is-bigger check per pixel with no inter-thread communication (the tight loop is in C) and unless Instruments is entirely wrong, that's not where the slowdown is coming from. It's entirely either Haskell internals or pthreads that are bogging it down.
01:25:24 <Sinestro> It'll be eventually right no matter what
01:26:26 <cocreature> Sinestro: are you sure that screenTriangleForFace, fragmentShader and drawFilledTriangle all allow multiple threads to operate at the same time and don’t have a lock inside?
01:27:03 <damping> What's wrong with opengl?
01:27:50 <ertes> if threading makes things worse by a small factor, that usually indicates that the threads block each other, so yeah, perhaps there is a lock
01:28:05 <cocreature> threadscope can be useful to look at
01:28:15 <ertes> also haskell threads and pthreads don't cooperate well…  if the C side is already using threads, consider not using haskell threads
01:28:19 <damping> You want to be able to call graphic card methods so you need hardware bindings which opengl provides
01:28:27 <ertes> (not for this part that is)
01:29:35 <Sinestro> damping: Why do you climb mountains? Because they're there! I'm well aware of OpenGL, I just don't want to use it for fun this time. See how far I can get. ;)
01:30:00 <ertes> writing a renderer is fun =)
01:30:57 <Sinestro> It's not using pthreads, the C side of things is just looping through the pixels and testing the edge functions 
01:31:07 <damping> You are gong to write blas? Don't you need to eg use cuda bindings?
01:32:03 <tdammers>  I can actually think of a few reasons not to use OpenGL
01:32:27 <tdammers> headless rendering without having to put a GPU in your server just so you can, well render things
01:32:37 <ertes> ah, ok…  well, i don't have much experience with the FFI (i would have written that part in haskell), but that much i can say:  you need to make the FFI aware that C functions don't mind being parallelised by the haskell run-time
01:32:47 <Sinestro> damping: You seem to think this is far more serious than it is. Things like BLAS are a bad idea when 4x4 is the biggest matrix you see anyway, if I recall... I've got a Vulkan-based engine in Haskell on my to-do list later, but for now I'm playing around with CPU rendering
01:33:00 <ertes> tdammers: if you do headless rendering, you probably want a GPU anyway =)
01:33:02 <cocreature> Sinestro: are your ffi calls marked as unsafe?
01:33:16 <tdammers> ertes: depends on the purpose
01:33:50 <tdammers> ertes: e.g., I have this idea for an online game that is mostly textual / GUI, but would involve small snippets of rendered imagery
01:33:57 <Guest69924> Well cpu is kind of slow even for small things 
01:34:07 <Sinestro> ertes: I tried to, but I remember that it was incredibly slow for some reason. I think I should rewrite this code from scratch, I did it as pretty much the first actual program I wrote when I was learning Haskell and, revisiting it a year or so later... It shows.
01:34:37 <tdammers> ertes: the render output doesn't have to be high-quality, it's just an illustrative GUI element, and I really wouldn't want to stick expensive h/w in my server just for a rendering a few tiny and relatively unimportant images
01:35:07 <tdammers> (of course offloading the rendering to the client entirely would also be a very viable option)
01:35:17 <ertes> Sinestro: if you use the .Mutable interface of any of the Vector flavours, it should be close to C speed…  i even managed to outperform C a few times, but for most algorithms it's slightly slower
01:35:30 <Sinestro> cocreature: They are not, because part of the point is to write shaders in Haskell, so the rasterizer (in C) calls back into Haskell to get the color value at a point
01:35:40 <Sinestro> It's all Mutable, yeah
01:36:08 <tdammers> in fact, three.js is probably what I'll be using, if I ever get around to building that thing
01:36:08 <cocreature> Sinestro: hm I’m not sure what the impact of safe ffi calls on parallelism is but it might be something worth looking into
01:36:38 <ertes> Sinestro: however, having everything in haskell can help parallelise the code a lot, and that may be enough of a win
01:36:45 <damping> What's the least overhead to put a pixel to the screen? Does it need something like wxwindows?
01:37:02 <ertes> damping: depends on the context
01:37:21 <allenj12> is multiplying an Int by an Integer supplied by prelude?
01:37:24 <ertes> if you have nothing, and you need to render to X11, the least overhead is connecting to the X server, creating a window, etc.
01:37:28 <cocreature> if you just need a window and an opengl context, sdl does the job pretty well
01:37:40 <ski> allenj12 : use `fromIntegral' to convert the `Int' to `Integer'
01:37:43 <jophish> allenj12: no, you'll need to convert one to the type of the other first
01:38:07 <ertes> if you have an OpenGL context, the overhead is to create shaders, buffers, arrays and then render
01:38:10 <allenj12> ski: thanks
01:38:11 <damping> So you need to use opengl then?
01:38:27 <Sinestro> I'm rendering into the backing Pixbuf of a GTK window
01:38:33 <ertes> if you're writing a DOS program, you pretty much just poke the video memory directly
01:38:55 <damping> That sounds good
01:39:06 <ertes> (i really enjoyed writing 320x200 graphics stuff under DOS when i was a kid…  it was so easy) =)
01:39:48 <damping> Can a Haskell program do that?
01:39:48 <tdammers> ^ same.
01:40:16 <tdammers> damping: I believe you'd need some minimal FFI to access the hardware
01:40:22 * ski did a little 320*200 graphics on C64
01:40:35 <tdammers> damping: apart from the problem of compiling Haskell against plain DOS, that is
01:40:50 <Sinestro> Hugs had DOS support apparently
01:40:56 <Sinestro> according to Google
01:41:05 <damping> Why is a foreign language required?
01:41:05 <ertes> damping: haskell programs can write to video memory, but they can't run under DOS…  the run-time system would already exhaust most of what bill gates thought was enough memory for everybody and everything =)
01:41:52 <Sinestro> Ooooooh
01:42:05 <damping> I'm on Windows so I care about dos now?
01:42:08 <tdammers> ertes: that's really more a limitation of 16-bit addressing mode than DOS itself
01:42:35 <Sinestro> Consulting "Parallel and Concurrent...", it seems that spawning multithreaded FFI stuff from the main thread is a very bad idea
01:42:46 <ertes> tdammers: yeah, i never got why they didn't simply use 32 bit addressing
01:42:53 * ski recalls far pointers in Borland C
01:42:58 <tdammers> ertes: binary backwards compatibility
01:43:07 <jophish> It shouldn't be toooo hard to set up an opengl/vulkan program mapping some memory to a texture and rendering that fullscreen every frame
01:43:12 <jophish> then you can just poke that memory
01:43:14 <ertes> tdammers: that doesn't seem to break
01:43:54 <tdammers> ertes: well, actually, it was possible to use 32-bit mode in DOS at some point IIRC - it's just that DOS itself used 16-bit mode
01:44:00 <Sinestro> jophish: Pretty much what I'm doing but with GTK, actually
01:44:05 <tdammers> ertes: and you had to do all the low-level stuff yourself
01:44:40 <damping> Jophish, I wrote something like that recently, but your just rewriting a subsection of opengl essentially
01:44:58 <ertesx> tdammers: that doesn't seem to break; jophish: sure, but you need quite a bunch of initialisation stuff before you can do that
01:45:45 <ertesx> CS, DS, ES, FS, GS, aaaaaaaand…
01:45:47 <jophish> ertesx: yeah, it depends if one is versed in GL or not. It should mostly be some first or second tutorial stuff besides mapping the memory
01:45:49 <ertesx> SS of course!
01:46:47 <sbrg> If I have a function: isLarge x | x > 9000 = True | x < 9000 = False, ghc seems to correctly detect that the guards are not exhaustive. If I replace the latter guard with <= 9000, it still (incorrectly) complains about being non-exhaustive, while replacing the last condition with `otherwise` makes it stop complaining. Is this a bug, or just a limit of the exhaustiveness checker or some such?
01:47:00 <sbrg> I know it's a rather dumb example, but regardless
01:47:14 <jophish> sbrg: it's not a problem GHC can solve generally
01:47:29 <sbrg> yeah, I figured that it wasn't an easy problem to solve
01:47:40 <jophish> it could be that you define a (weird) instance for Ord which always returns False or something
01:48:36 <ertesx> sbrg: GHC doesn't even understand that you're checking an ordering there…  all it sees are two booleans, each of which may be False
01:48:48 <ertesx> it wants one of them to be True unconditionally
01:48:53 <damping> You could use Either
01:48:53 <ertesx> > otherwise
01:48:55 <lambdabot>  True
01:49:12 <ruski_> hi all. i've implemented conduit into a program but i still run out of memory, even though online resources claim reduced memory usage by conduit. does anyone have a resource on how it limits memory usage? it just seems to be dropped but never exactly clarified
01:50:47 <ertesx> sbrg: for cases like this you could avoid guards altogether and use the 'compare' function instead
01:51:03 <ertesx> case compare x y of GT -> …; _ -> …
01:53:00 <sbrg> ertesx: Yeah, it's a pathological example I was only looking at because of some article I read re. property-based testing. 
01:53:15 <sbrg> I would never write that function like that, and the example itself is kind of dumb, even in the context of the article.
01:56:02 <Axman6> ruski_: the answer to that question will be problem specific, can you share the code? merely using conduit does not guarantee constant memory usage if you still do thing which cause high memory usage
01:56:32 <Sinestro> I've spent more time digging through the profiler, and it's definitely doing something very strange with locking somewhere...
01:57:07 <ruski_> ok Axman6, give me a moment
02:00:19 <sbrg> Sinestro: perhaps ltrace can help you confirm that
02:00:53 <ruski_> Axman6: http://sprunge.us/PMQN
02:02:47 <ruski_> Axman6 all it does really is count the frequency of occurrence of elements in a list.
02:03:24 <ruski_> only the file is massive, so i go over the amount of memory that i have to work with.
02:04:05 <Axman6> yeah using BS8.getContents looks like a real code smell - you should probably be reading that in using conduit
02:04:21 <Axman6> you're not really using conduit at all here
02:04:37 <Axman6> there's probably some sort of stdin Producer which you should be using
02:05:51 <Axman6> there's also probably either a version which returns all lines from stdin, or a conduit which will split accept ByteStrings and return ByteStrings which are the individual lines
02:06:57 <Axman6> ruski_: so, is it counting the occurances of each line?
02:07:14 <ruski_> yeah i just followed code from a guide and thre wasn't a whole load of exposition as to what it was actually doing.
02:07:18 <lyxia> ruski_: getContents here is getting all of the file in memory at once
02:07:18 <ruski_> yes
02:08:06 <ruski_> ok, it'd make sense. would hGetContents be more sensible to use in this case, or should input go into conduit using some conduit type?
02:08:28 <ruski_> sourceFile, or something
02:08:56 <ruski_> then pack into BS8?
02:09:55 <Axman6> one sec, trying to find the right partd
02:09:58 <Axman6> parts*
02:10:05 <ocramz> hi all
02:10:22 <Axman6> so you probably want sourceFile from https://hackage.haskell.org/package/conduit-extra-1.1.13.3/docs/Data-Conduit-Binary.html
02:10:39 <Axman6> then you can use lines from the same module to split into lines
02:10:56 <Axman6> then you just need a sink which folds into a Map 
02:10:57 <ocramz> what does it mean exactly when a package is flagged as non-portable? it's not about operating systems I guess; does it concern compilers other than GHC ?
02:12:21 <ruski_> is there an equivalent that doesn't require me to explicintly provide a file? since the executable would be run from shell like ./Countlines < file.txt
02:12:28 <ruski_> **explicitly
02:13:17 <Axman6> if you use sourceHandle you can provide a handle, and then use the stdin handle from System.IO (IIRC) when the specified file is "-" or something
02:22:19 <Axman6> ruski_: something like this should do what you want (I haven't tested it but it should show the idea: http://lpaste.net/297590)
02:23:30 <ruski_> thanks! i'll try it out and see how it goes
02:24:51 <Axman6> hopefully you can understand how conduit is supposed to be used there (i haven't used conduit for a while, but the way you were using it was essentially a very complicated way to loading the whole fine into memory and pretending it was streaming)
02:25:26 <Axman6> you might want to read https://www.schoolofhaskell.com/user/snoyberg/library-documentation/conduit-overview as well
02:26:34 <Axman6> hmm, annoyingly that doesn't seem to show how to work with files
02:27:34 <quchen> What’s a “fixit” in Trifecta?
02:27:39 <Sinestro> For anyone who wants to know: It turns out that calling from Haskell -> C -> Haskell like I'm doing can only be done from one thread at a time without causing contention. :/
02:30:40 <Sinestro> I get to dive down a whole other adventure soon, since my next step was going to be vectorization, and I've found out about the various primops that kinda support it
02:30:43 <Sinestro> This is gonna be awful.
02:32:33 <ruski_> thanks Axman6 i had an idea it must have been to do with how i was reading files from stdin, but it's nicer to hear from people who know. hadn't done any haskell till last week.
02:39:58 <mikail_> Hi, what is a mathematical example of a HOF?
02:41:21 <ski> mikail_ : derivative ? "big-sigma" sum ?
02:41:40 <Faucelme> mikail_: A "differential operator" in Calculus. Maps a function to its derivative.
02:59:11 * hackagebot hdo 0.2 - A Digital Ocean client in Haskell  https://hackage.haskell.org/package/hdo-0.2 (abailly)
03:04:32 <mikail_> Faucelme, good one
03:04:43 <mikail_> I was struggling to find an example
03:05:37 <ertesx> mikail_: anything that says "for all f"
03:19:20 <mikail_> What kind of languages features are not translatable or fit into the lambda calculus?
03:19:31 <mikail_> exceptions?
03:21:52 <[exa]> mikail_: well, all features are translatable thanks to the equivalence to other computation models
03:22:32 <[exa]> mikail_: and if you count pure lambda calculus, actually almost no features are "fit", except function abstraction and application :D
03:23:15 <[exa]> not the case with haskell though
03:26:03 <mikail_> exa, yes. the book I am reading says that some languages provide features which not translatable but Haskell is a language which is pure in that it only provides features which are fully translatable.
03:26:43 <mikail_> say we take Scala or even Ocaml as an example, which features do they provide which are impure in terms of this?
03:26:49 <mikail_> mutability?
03:28:09 <ruski_> Axman6 i tried the method you've suggested and it's still running out of memory
03:28:12 <[exa]> mikail_: mutability can be "translated" to haskell, by switching environments etc. There's lot of tooling that allow you to handle that sanely
03:29:24 <mikail_> so what is an example of a language feature which is not directly translatable?
03:29:50 <Axman6> ruski_: you might need to use a strict Map (Data.Map.Strict) 
03:30:09 <ruski_> is default map lazy?
03:30:23 <Axman6> yes
03:31:09 <ruski_> let's give it a shot
03:31:53 <tsahyt> So for the last few days I've been writing low level/raw bindings to a C library. As a convention it returns a bool on every function that might fail and returns it's actual output parameters in pointers that it takes as arguments. Are there any benefits at all to keeping this convention in the raw haskell bindings over introducing a MonadThrow constraint and rewriting the types to something sane that
03:31:55 <tsahyt> reflects on what the functions actually return?
03:32:30 <tsahyt> I'd be doing this anyway in the high level wrapper, but I was wondering whether I should pull this transformation down to the raw binding level (which isn't really that raw anymore afterwards)
03:33:43 <ruski_> Axman6 made some more progress but still ran out
03:34:35 <tsahyt> going further from there, many functions take some array and its length as input. if I was to transform this into say a list (or any traversable) instead, should I do this at the low level API or reserve it for a high level wrapper?
03:34:51 <tsahyt> basically my question boils down to where I should draw the line between providing a low level API and providing one that doesn't suck
03:35:31 <hpc> it depends
03:35:46 <hpc> generally users only really care about the high-level api
03:36:22 <tsahyt> hpc: then it becomes more a matter of how much pain I can avoid in writing the high level api by making the low level one better to work with?
03:36:23 <hpc> unless there's something it can't do that the lower-level one can (which usually shouldn't happen except for unsafe combinations of api calls)
03:36:31 <hpc> yeah
03:36:53 <tsahyt> I think I'll draw the line at where performance might get compromised then.
03:37:11 <tsahyt> and reserve any monadic interfaces and whatnot for high level too
03:37:25 <maerwald> tsahyt: that line depends on the use case
03:37:41 <maerwald> for some things you can't build a useful high-level API
03:37:47 <maerwald> at least not a generic one
03:38:10 <tsahyt> it's a reasonably specific application, it should be possible to write something nice. but I don't know exactly what that would look like yet
03:38:32 <tsahyt> but I'll worry about that once I've got a working LL one
03:38:45 <tsahyt> I've got some ideas, which basically boil down to "Monads"...
03:40:21 <maerwald> I mostly try to not diverge too much from the way low-level functions propagate failures, at least if I can't fully predict the way they might fail at runtime. So I'd rather add exceptions, instead of transforming them
03:40:56 <maerwald> also makes debugging less annoying
03:41:58 <tsahyt> maerwald: but that's what I want to do. Almost every function returns a bool, which the programmer would have to check. if it returns false, something went wrong and there's an error stored in some stateful structure. what I want to do is check this, and throw an exception in the case of failure.
03:42:13 <tsahyt> basically the same mechanism, I just want to abstract the manual checking away
03:42:27 <tsahyt> this frees up the return type to reflect on what's documented as an out parameter in the API
03:43:18 <maerwald> hard to say, since you're not telling what function it is
03:43:41 <tsahyt> any of the 140ish in here https://github.com/tsahyt/clingo-haskell/tree/master/src/Clingo/Raw
03:44:12 <maerwald> if you're just writing bindings, don't try to be smart
03:44:22 <maerwald> just do it the naive way
03:44:33 <tsahyt> there's nothing smart about that imo
03:45:07 <maerwald> I prefer if the haskell binding has the (almost) the same type signature as the C function
03:45:22 <maerwald> anything else, I can build myself on top of it
03:45:34 <tsahyt> I'll build something on top of it either way
03:46:03 <maerwald> sure, so provide the unchanged binding and your abstraction, which can be pretty much anything
03:50:38 <tsahyt> maerwald: so a low level api that manually requires you to provide pointers to store the return values is preferable?
03:51:51 <tsahyt> rather than changing foo :: Foo -> Ptr Bar -> IO Int to say foo' :: (MonadIO m, MonadThrow m) => Foo -> m Bar?
03:52:05 <tsahyt> that should say IO CInt actually
03:52:35 <tsahyt> I'd say there's still a 1:1 correspondence to the underlying C API
03:53:58 <TipPerson> why does: "let l = [1..9]" and then "[last l] ++ init l" work, but when I define "func l = [last l] ++ init l" I get an error when using "fun [1..9]"? error is Variable not in scope: func :: [Integer] -> t
03:55:28 <TipPerson> oh nevermind I'm retarded
03:55:53 <TipPerson> I loaded up the wrong hs without realizing
04:03:47 <tsahyt> maerwald: I guess I could always just export the actual FFI bindings (generated by foreign import ccall ...) in addition to my low level version for the users who really need that level of control
04:04:34 <tsahyt> but after looking through the library examples I still don't see a single usecase for that. every single API call is wrapped in an if to handle error conditions
04:09:38 <maerwald> tsahyt: well, you're already making a choice of using mtl and specific classes (like MonadThrow) which people might not want
04:10:31 <tsahyt> maerwald: a choice like that has to be made in every library though
04:11:43 <maerwald> library yes, bindings not
04:12:30 <maerwald> and it causes problems (e.g. in the gtk+ bindings)
04:12:46 <maerwald> so exposing both levels seems better to me
04:13:15 <Axman6> there's a big advantage to having bindings have a very similar API to the original library, and that is that the documentation can be translated over
04:46:09 <ertes> @let oven = unfoldr (\x -> guard (x > 0) >> pure (toEnum (96 + mod x 27), div x 27)) . subtract 5738518 . foldl' (\s c -> 27*s + fromEnum c - 96) 0 :: String -> String
04:46:11 <lambdabot>  Defined.
04:46:16 <ertes> > oven "lunch"
04:46:19 <lambdabot>  "pizza"
04:47:07 <kori> ertes: thats...
04:47:15 <hpc> magnificently contrived
04:47:29 <kori> well done, well done
04:48:53 <opqdonut> base 27 arithmetic
04:49:28 <ertes> how can a pizza oven be contrived?
04:49:40 <kori> oven "test"
04:49:42 <kori> whoops
04:49:44 <kori> > oven "test"
04:49:46 <lambdabot>  ""
04:49:51 <kori> ┐('~'; )┌
04:50:01 <ertes> well, it's a pizza oven =)
04:50:13 <kori> could be a test oven, who knows
04:50:35 <Rarrikins> > oven "zzzzz"
04:50:38 <lambdabot>  "gflep"
04:50:38 <ongy> ertes: are you using those examples in a course or book?
04:51:11 <ertes> i'm just fooling around, and @pl and :t got old =)
04:52:13 <Rembane> > oven ertes
04:52:14 <lambdabot>  error: Variable not in scope: ertes :: String
04:52:18 <Rembane> :(
04:52:21 <Rembane> > oven "ertes"
04:52:23 <lambdabot>  ""
04:52:37 <Rembane> My carreer as an evil witch came to an abrupt halt.
04:54:40 <opqdonut> > let encode = fst . head . readInt 27 (const True) (\c -> fromEnum c - 96); decode x = reverse $ showIntAtBase 27 (\i -> toEnum (i + 96)) x "" in decode (encode "lunch" - 5738518)
04:54:43 <lambdabot>  "pizza"
04:56:40 <tdammers> > oven << "pizza"
04:56:42 <lambdabot>  error:
04:56:42 <lambdabot>      • Variable not in scope: (<<) :: (String -> String) -> [Char] -> t
04:56:42 <lambdabot>      • Perhaps you meant one of these:
04:59:32 <liste> > filter (/= "") [oven [a,b,c,d,e,f] | a <- ['a'..'z'], b <- ['a'..'z'], c <- ['a'..'z'], d <- ['a'..'z'], e <- ['a'..'z'], f <- ['a'..'z']]
04:59:35 <lambdabot>  ["igmfq","jgmfq","kgmfq","lgmfq","mgmfq","ngmfq","ogmfq","pgmfq","qgmfq","rg...
05:00:12 <Axman6> > replicateM 5 ['a'..'z']
05:00:15 <lambdabot>  ["aaaaa","aaaab","aaaac","aaaad","aaaae","aaaaf","aaaag","aaaah","aaaai","aa...
05:00:38 <liste> > filter (/= "") . map oven $ replicateM 5 ['a'..'z']
05:00:44 <lambdabot>  mueval-core: Time limit exceeded
05:05:21 <ertes> liste: replicateM for lists is very slow
05:09:07 <tsahyt> what about things like memory management? Some C functions take an array, i.e. const pointer and a size_t, which they are guaranteed not to modify or free. should low level bindings provide the same interface again or abstract that into a suitable haskell type?
05:09:54 <tsahyt> seeing as this would not add any dependencies or force the user into a specific path, I don't think it's quite the same as the exception abstraction I was talking about before
05:13:16 <ertes> @let repL n = foldr (\xs -> (>>= \ys -> map (: ys) xs)) [[]] . replicate n
05:13:19 <lambdabot>  Defined.
05:13:24 <ertes> > repL 20 "01"
05:13:27 <lambdabot>  ["00000000000000000000","10000000000000000000","01000000000000000000","11000...
05:13:48 <ertes> far better than replicateM
05:14:09 <ertes> > replicateM 20 "01"
05:14:11 <lambdabot>  ["00000000000000000000","00000000000000000001","00000000000000000010","00000...
05:14:38 <M2tias> > repL 20 "01" !! 1000
05:14:40 <lambdabot>  "00010111110000000000"
05:14:44 <M2tias> > repL 20 "01" !! 100000
05:14:46 <lambdabot>  "00000101011000011000"
05:17:49 <ertes> hmm, i must be confusing something
05:18:20 <ertes> > (head (repL 2 [0..]), head (replicateM 2 [0..]))  -- both work
05:18:22 <lambdabot>  ([0,0],[0,0])
05:19:45 <ertes> ah, it was filterM and foldM…  applicative usage of lists is actually fine
05:33:59 <codehectic> hey everyone
05:34:52 <codehectic> Haskell beginner here. May I know why when I run "take 10 . filter neg . enumFrom $ -5", it makes the GHCi hangs?
05:35:13 <codehectic> neg is a filter function for negative numbers.
05:35:32 <ertes> codehectic: enumFrom (-5)  -- this is an infinite list that starts negative, but becomes positive
05:35:44 <ertes> codehectic: 'filter' doesn't know that it will never become negative again
05:35:54 <ertes> so it keeps searching through that infinite list
05:36:22 <codehectic> Oh
05:36:32 <codehectic> That makes sense.
05:37:23 <ertes> codehectic: note that you can write (enumFrom (-5)) as [-5..]
05:37:51 <ertes> that's exactly what [-5..] desugars into
05:38:05 <codehectic> Okay
05:38:28 <codehectic> but why does "take 5 . filter even . enumFrom $ 5" works fine?
05:38:58 <codehectic> I mean, how does the compiler know when to stop?
05:39:18 <ertes> codehectic: it doesn't…  you tell it when to stop by using (take 5)
05:39:21 * hackagebot servant-matrix-param 0.3.1 - Matrix parameter combinator for servant  https://hackage.haskell.org/package/servant-matrix-param-0.3.1 (jkarni)
05:39:37 <ertes> > takeWhile (< 30) (filter even [5..])
05:39:39 <lambdabot>  [6,8,10,12,14,16,18,20,22,24,26,28]
05:39:47 <srhb> codehectic: Because the filter actually produces five elements in this case
05:40:07 <srhb> codehectic: Whereas it did not produce 10 in the other case.
05:41:13 <codehectic> Oh!
05:41:36 <codehectic> Thanks guys, you are really helpful!
05:41:42 <ertes> codehectic: haskell is less about what you construct and more about what questions you ask
05:42:09 <ertes> codehectic: [1..]  -- this is not anything of substance (it doesn't live in memory, it doesn't compute, …)
05:42:25 <ertes> only by asking a question you're starting to compute:  take 5 [1..]
05:42:52 <codehectic> So [1..] actually goes to infinity?
05:43:07 <codehectic> But the compiler never actually constructs it in memory?
05:43:16 <srhb> > take 10 [1..]
05:43:18 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:43:19 <srhb> Evidently not!
05:43:44 <ertes> codehectic: it's easier to understand if you actually look at the definition of [1..]
05:43:51 <ertes> [x..] desugars to (enumFrom x)
05:44:15 <ertes> and enumFrom x is (roughly) defined as:  enumFrom x = x : enumFrom (succ x)
05:44:21 * hackagebot hw-json-lens 0.0.0.1 - Lens for hw-json  https://hackage.haskell.org/package/hw-json-lens-0.0.0.1 (haskellworks)
05:44:24 <ertes> where 'succ' is the successor function
05:45:36 <codehectic> and so it keeps appending
05:45:38 <ertes> codehectic: the concept of "asking a question" in haskell is called pattern-matching…  if you match (enumFrom 1) against (x : xs), then it will match, because enumFrom 1 = 1 : enumFrom 2 (by definition)
05:45:55 <ertes> that gives you x = 1, xs = enumFrom 2
05:46:04 <ertes> and you see, the question was answered in finite time
05:46:48 <codehectic> I see
05:47:34 <codehectic> Now I'll get back to the book, but thanks again for answering ertes!
05:47:42 <ertes> go ahead =)
05:50:50 <abbradar> Hi all! I'd like to use a monad analogous to Error String, that is, Either String with a sensiful `fail`. However, Error is deprecated and it's recommended to use Except, which just uses underlying monad's `fail` (which is `error` in case of Either). I can define it by myself but I'd like to know if there's something already recommended first. Is there?
05:50:59 <piyush-kurur> TIL: arc4random is an attractive source for psrg available not just on bsds
05:51:19 <piyush-kurur> I am planning to use it as the default on raaz. any thoughts?
05:51:44 <Axman6> abbradar: you probably want something like throwError from MonadError
05:51:49 <Axman6> :t throwError
05:51:51 <lambdabot> MonadError e m => e -> m a
05:52:08 <abbradar> Axman6: the reason I want there to be sensible `fail` is that I can be lazy with mattern-matching
05:52:13 <abbradar> p*
05:52:30 <Axman6> don't do that =)
05:53:00 <abbradar> Of course the error won't make any sense for the user but at least it'll fail gracefully and I can see what has gone wrong (it's supposed to happen only when things are quite broken but not quite to just crash)
05:53:40 <ertes> piyush-kurur: why not something like chacha20?
05:55:01 <piyush-kurur> ertes: arc4random uses chacha20 inside despite the name
05:55:46 <piyush-kurur> the man page says that: arc4 in arc4random should be now read as "A replacement call for" random
05:55:47 <ertes> piyush-kurur: ah, i see…  is that a portable assumption?
05:55:58 <lyxia> abbradar: I would also advise against using fail and advertise that your computations can fail via a MonadError constraint instead.
05:55:59 <piyush-kurur> ertes: not yet but soon will be
05:56:17 <ertes> piyush-kurur: then it sounds reasonable to me
05:56:20 <piyush-kurur> ertes: I plan to give it as a flag and use it as default on openbsd
05:56:31 <Axman6> piyush-kurur: mind if I ask the background of raaz? seems it's reimplementing a lot of things which already exist in packages in cryptonite, is that correct?
05:57:17 <piyush-kurur> Axman6: yes but raaz is more opinionated and will be only implementing a fraction of the primitives in cryptonite
05:57:45 <piyush-kurur> Axman6: See also http://cse.iitk.ac.in/users/ppk/posts/2016-07-30-Why-another-cryptolibrary.html
05:58:03 <abbradar> lyxia: you mean MonadExcept? MonadError is deprecated and also ErrorT (which implements it) defines non-`error` fail
05:58:28 <lyxia> uh.. right
05:59:04 <lyxia> The implicit fail on pattern matching binds is just asking for trouble
06:00:19 <piyush-kurur> ertes: just to clarify arc4random is used as the system prg which inturn calls the getrandom or whatever is the platform specific call
06:00:39 <tsahyt> In the spirit of bindings and how the sdl2 package handles this I think I'll leave my raw bindings actually raw. There's another recurring pattern throughout the library. Almost all functions are called with some handle to an "object" as the first argument. is there some sane way to abstract this away?
06:00:40 <piyush-kurur> it also avoids opening the /dev/urandom which is a good thing.
06:00:51 <tsahyt> I suppose I can carry it around in a monad
06:01:12 <ertes> i see
06:01:16 <abbradar> But, well, at this point I'm very lazy to write error messages for each place (it's converting a complex tree from a parsed file into more structured data, with lots of matches) but want this to be both 1) debuggable (pattern matching error including lines is good enough) and 2) non-`error` (so that I can output error gracefully, skip loading this file etc.)
06:02:21 <ertes> i don't think there is anything particularly wrong with pattern-match fails in do-notation, but 'fail' shouldn't be part of Monad
06:02:29 <abbradar> Of course
06:02:36 <abbradar> But we do have MonadFail now
06:03:13 <Axman6> piyush-kurur: thanks for the link
06:03:18 <ertes> :t do Nothing <- Just (); const ()
06:03:20 <lambdabot> error:
06:03:20 <lambdabot>     • Couldn't match expected type ‘()’ with actual type ‘Maybe t0’
06:03:20 <lambdabot>     • In the pattern: Nothing
06:03:31 <ertes> :t do Nothing <- const (Just ()); const ()
06:03:33 <lambdabot> b -> ()
06:03:37 <ertes> hmm?
06:03:56 <ertes> that should have been a type error then
06:04:18 <ertes> or is ((->) e) a MonadFail?
06:04:20 <abbradar> :i MonadFail
06:04:22 * hackagebot Lazy-Pbkdf2 2.1.0 - Lazy PBKDF2 generator.  https://hackage.haskell.org/package/Lazy-Pbkdf2-2.1.0 (Ofenhed)
06:04:34 <ertes> nope, it isn't
06:04:38 <abbradar> oh... I thought it'd be GHCi's :i
06:04:50 <abbradar> I think `fail` is still in Monad
06:04:55 <abbradar> but now they plan to remove it someday
06:04:57 <ertes> ah, the change hasn't happened yet
06:05:03 <abbradar> we are in the transition period right now
06:05:31 <ertes> once it's over i'll be a lot more comfortable using partial patterns in do-notation
06:05:46 <ertes> because it's a useful feature
06:05:58 <piyush-kurur> Axman6: you are welcome. I myself am exploring cryptography so no expert here.
06:06:18 <abbradar> ertes: Indeed. For now I'm artificially limiting myself to use pattern matches only for Maybe and for IO
06:06:33 <abbradar> Just so that I won't accidentially step on `error`
06:07:01 <ertes> why isn't Either String a MonadFail?
06:07:19 <ertes> or even:  (IsString e) => Either e
06:07:37 <abbradar> Good question! I think it's because `fail` still needs be defined for all `Either`s
06:07:43 <abbradar> because `fail` is still in Monad
06:07:50 <lyxia> It might be once fail goes out of Monad
06:08:16 <abbradar> BTW, are there any concrete plans w.r.t. removing it?
06:08:24 <abbradar> Like, in 8.2 or stuff
06:08:25 <quchen> Yes.
06:08:26 <quchen> No.
06:08:47 <quchen> Yes to removing it, no to 8.2. There are definite plans to get rid of it, but not as fast as 8.2.
06:08:54 <quchen> We’ll be very careful not to introduce breakages.
06:09:13 <abbradar> I figured out that much ~_^. I can imagine extensive code breakages possible
06:09:14 <ertes> are there plans to make Semigroup a superclass of Monoid?
06:09:44 <quchen> Not sure, ertes. There are many people in favour of that, but I’m not participating in the discussions.
06:09:57 <amx> https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
06:10:02 <quchen> 8.2 might have opt-in warnings to notify you when monads define fail but are not instances of MonadFail.
06:10:02 <abbradar> So, back to my original question. Is there something similar in behaviour to Either String with proper `fail` in some library now? Something like ErrorT but not deprecated.
06:10:14 <quchen> 8.4 might nag some more, maybe as opt-out.
06:10:21 <quchen> But don’t quote me on those numbers.
06:10:28 <quchen> Might be GHC 9 that actually does the switch.
06:12:00 <quchen> abbradar: See this section for more information. 
06:12:00 <quchen> https://prime.haskell.org/wiki/Libraries/Proposals/MonadFail#Transitionalstrategy
06:13:25 <abbradar> quchen: thanks!
06:15:15 <isBEKaml> IIRC, Applicative is already a super class to Monad, right? Was that the same release as the Foldable proposal?
06:15:27 <abbradar> (question about a monad with desirable instances still persists...)
06:16:11 <quchen> isBEKaml: Yes, GHC 7.10 made Applicative a superclass of Monad.
06:16:33 <isBEKaml> quchen: thanks
06:18:55 <lyxia> abbradar: I haven't heard of any besides the deprecated Error
06:20:53 <abbradar> lyxia: it's a pity D: well, I can use Maybe for now and move to a custom monad for this convertion code later
06:20:55 <abbradar> thanks anyway!
06:21:40 <quchen> abbradar: I suggest you don’t try to fix standard libraries so you can write unclean draft code easier. These things are forgotten to be cleaned up very easily in the end.
06:22:55 <quchen> abbradar: What I like to do is use a module to define my own placeholders like "UNDEFINED" types and so on, and then mark that module as deprecated. I can then safely use placeholders because they all come from one loudly warning place.
06:23:48 <quchen> For incomplete patterns, I’d use a pattern match a la "case foo of Right r -> …; Left l -> myError l"
06:24:02 <quchen> … and not simply "Right r <- foo"
06:26:02 <abbradar> quchen: Hm, but I don't think I'd mind if this would be left in the end. I can of course write a big bunch of error messages like "key 'x' is not found" but they won't even always be more informative than pattern matching errors and are meant only for me, so the amount of work is too big for too little gain IMHO.
06:26:22 <abbradar> On the other hand, maybe I want to make some kind of DSL so that more senseful error messages would be generated...
06:26:33 <abbradar> quchen: great idea about a deprecated module!
06:26:46 <quchen> You *never* want incomplete pattern match failures.
06:27:11 <quchen> Those expose code internals, like where the pattern was in your code.
06:27:29 <quchen> You also don’t want to swallow them, because they should never happen.
06:27:52 <tsahyt> I just had a case yesterday where I had to swallow them
06:27:54 <quchen> When they do happen, make sure to make them crash your program as loudly and early as possible in your first test.
06:28:04 <tsahyt> to be fair this was when marshalling C structs with unions to sum types
06:28:16 <abbradar> quchen: yes, exposing code internals is a problem -- noted
06:28:18 <quchen> You do not want to fail gracefully with pattern match errors. :-)
06:28:39 <tsahyt> agreed. it's one of the few times where using error is appropriate imo
06:29:00 <tsahyt> in my case this can only happen when the struct that is being marshalled is invalid to begin with, indicating an error in the C library
06:29:10 <tsahyt> there's no sane way to recover from this
06:30:01 <abbradar> quchen: but in this case I think I want to fail gracefully after all. To give you context -- I convert a huge wild tree parsed from a structured file format, and if the file is broken, well, that can happen -- but I want to debug later what's wrong with this file
06:31:09 <quchen> Sounds like you want some sort of validation. That sort of thing is common with e.g. syntax trees, because those tend to have a lot of implicit invariants.
06:31:12 <abbradar> and because there are many places which can go wrong because of invalid data writing proper messages for each place is a great amount of work
06:31:40 <abbradar> quchen: Exactly! So I essentially validate by pattern-matching
06:32:10 <abbradar> For example, I expect arrays at certain places, and some pre-defined dictionary values at others
06:32:25 <abbradar> (like, "x", "y" and "z" should be in this dictionary)
06:32:49 <quchen> Anyway, I said everything I had to say about this. You can ignore my advice, and if it works, come back and correct me. In that case, at least keep what I said at the back of your head. :-)
06:34:01 <abbradar> quchen: Of course. Thank you for your advise! I'll think more about this before commiting to my way
06:34:24 * hackagebot language-dockerfile 0.3.5.0 - Dockerfile linter, parser, pretty-printer and embedded DSL  https://hackage.haskell.org/package/language-dockerfile-0.3.5.0 (yamadapc)
06:34:39 <grantwu> It seems like you are basically writing a parser
06:35:10 <abbradar> grantwu: not quite, if by parser you mean "[Token] -> Tree"
06:35:20 <abbradar> rather, "Tree1 -> Tree2"
06:35:25 <abbradar> (sans possible errors)
06:36:58 <abbradar> Full disclosure -- I have a parser for DirectX model file format, which gives you a tree of various nested "templates" (slang for data types) with values somewhere inside
06:37:17 <abbradar> and I want to extract actual models, vertices, points etc. from this tree
06:37:39 <quchen> Sounds like a parsing problem indeed.
06:39:12 <abbradar> Hm, maybe (I usually call thing a "parser" when it deals with a stream of tokens, not traverses a tree, but I may be wrong with my definitions)
06:40:08 <quchen> “File format” sounds like you’re reading in a file, and convert it to a tree.
06:40:18 <abbradar> quchen: yes, but that's already done
06:40:21 <quchen> “String -> X” is what parsers do.
06:40:22 <quchen> Oh.
06:40:26 <abbradar> so now I have a somewhat structured tree
06:40:33 <abbradar> and now I want to convert it to a much more structured tree
06:41:04 <abbradar> So there's lots of code like
06:41:22 <abbradar> VCustom (DV dataMtx) <- M.lookup "frameMatrix" (dataValues dat)
06:41:42 <abbradar> (it's in Maybe monad)
06:42:54 <abbradar> A good analogy: I already have a JSON parser but now I want to convert a JSON tree to my actual data structures
06:44:55 <quchen> Do you *need* to be monadic? If Applicative is enough, validation might be a good option. It’s a form of Either that does not abort after the first error. Instead, it tries to coninue as much as it can.
06:45:10 <quchen> It’s a simple definition, https://github.com/quchen/stgi/blob/a82bc5c4f1acc2a4644344bdef1f604d330365ed/src/Stg/Util.hs#L36-L56
06:45:33 <abbradar> quchen: yeah, I know about applicatives and I'm not really sure I need monads... I need to look through the code
06:45:49 <abbradar> quchen: I usually have several "when"s with additional checks here and there so I choose Monad by default
06:46:17 <abbradar> but getting all the errors in the tree at once might be worth it
06:46:42 <abbradar> (I can also isolate those checks inside monadic "sub-blocks" I think... interesting)
06:48:33 <mikail_> In Lambda calculus, what is alpha equivalence?
06:49:15 <lyxia> it's equality up to renaming of bound variables.
06:49:22 <quchen> ?loadlpaste http://lpaste.net/298095
06:49:22 <lambdabot> Unknown command, try @list
06:49:28 <quchen> ?lpaste http://lpaste.net/298095
06:49:28 <lambdabot> Haskell pastebin: http://lpaste.net/
06:49:35 <mikail_> er, in laymen terms pls?
06:49:37 <quchen> Heh. What’s that command again?
06:49:45 <quchen> mikail_: "renaming variables"
06:50:09 <mikail_> quchen, could you give me an example pls?
06:50:14 <quchen> \x -> x   is the same as   \y -> y    by alpha equivalence
06:50:16 <Axman6> mikail_: (\a -> f a) === (\b -> f b)
06:50:32 <mikail_> why is it important?
06:50:46 <tsahyt> is Text the appropriate type to represent source code?
06:50:55 <osa1> can anyone here build benchmark targets of containers: https://github.com/haskell/containers/blob/master/containers.cabal I think I'm missing something because I feel like they're impossible to build because libraries like `binary`, an older version of `containers` etc. will always be system-wide installed
06:51:13 <Axman6> tsahyt: probably, particularly if it's a language whose files can be UTF-8
06:51:42 <tsahyt> well in the C library it's a char*, so I guess not
06:51:45 <abbradar> quchen: I like this, thanks! But why isn't it a Monad?
06:51:52 <tsahyt> unless they do something weird with that underneath
06:51:55 <quchen> ?letlpaste 298095
06:51:58 <lambdabot>  Defined.
06:51:59 <abbradar> (not MonadFail)
06:52:00 <quchen> abbradar: ^
06:52:05 <quchen> > run
06:52:08 <lambdabot>  ValFailure "7 is not even.9 is not even."
06:52:12 <quchen> Tadaa.
06:52:32 <quchen> > traverse evenValidation [2,4,6,8]
06:52:34 <lambdabot>  ValSuccess [2,4,6,8]
06:52:36 <abbradar> Nice! (BTW, lambdabot has much more up its sleeve than I thought)
06:52:43 <sham1> Well tsahyt, char* can represent UTF-8 since char* is just a string of bytes (a bytestring if you may)
06:53:29 <sham1> So Text is an appropriate type as it is textual data
06:53:39 <quchen> abbradar: Had I used the standard "Either" behaviour, that program would just have reported that 7 is not even.
06:53:45 <abbradar> Anyway, IIUC I can define a Monad for it, I just won't get nice (get all the errors) property, correct? (it's not like I actually want to lose it, I just verify my thoughts)
06:53:55 <Axman6> mikail_: if you're writing an evaluator for lambda calculus, expressions like (\a -> ... (\a -> ...a...) ... a) can perhaps be problematic, if you can rename the inner a's it can make life a lot easier
06:54:21 <Axman6> but I'm sure there are more important reasons why it's important too
06:54:44 <abbradar> so, in "a <|> (b >>= c)" I would only get errors for b or for c, but always for a
06:54:46 <mikail_> ok thanks
06:55:19 <tsahyt> sham1: ok, thanks
06:55:55 <quchen> abbradar: I think there is no Monad for (Validation e) because of the laws.
06:55:56 <sham1> I think that the common consensus nowadays is to use Text whenever you need to manipulate text
06:57:10 <lpaste> Vadim pasted “Monoid for custom Option” at http://lpaste.net/298114
06:58:12 <vadimich> Hi, I am having some type issues when creating a Monoid instance for a custom redefined Option
06:58:34 <vadimich> it is a bit of a newbie question i guess
06:58:37 <lyxia> mempty should be of type Optional a, you gave it an a.
06:59:04 <vadimich> lol, the answer came in too fast!
06:59:17 <vadimich> thank you
06:59:18 <Axman6> mempty = Only mempty (though that seems like a pretty strange implementation)
06:59:21 <sham1> Also, is that a unicode maths character in that code
06:59:29 <Axman6> does that obey the monoid laws?
06:59:36 <lyxia> it should be Nada
06:59:37 <Axman6> no
06:59:38 <vadimich> it is unicode 
07:00:01 <sham1> No wonder it looked so weird
07:00:08 <Axman6> Nada `mappend` mempty = Only mempty, so it's not a valid monoid
07:00:13 <vadimich> but if i invoke mempty :: String I will get ""
07:00:29 <vadimich> sorry - got it
07:00:45 <vadimich> I overlooked it
07:00:57 <lyxia> Nada <> Nada = Nada
07:01:04 <lyxia> Nada <> Only x = Only x
07:01:19 <lyxia> (Nada <>) = id
07:05:19 <lpaste> abbradar pasted “instance Monad Validate” at http://lpaste.net/298130
07:05:42 <abbradar> quchen: ^. I got lazy with writing out all the cases but it seems to me that all three laws hold 
07:05:49 <abbradar> However, I'm a novice in proofs
07:06:20 <quchen> abbradar: (<*>) = ap fails
07:06:48 <abbradar> quchen: Ah, damn
07:06:52 <quchen> :-)
07:06:56 <abbradar> quchen: I forgot about those
07:07:20 <quchen> So did I, until I saw that paste ;-)
07:07:37 <tsahyt> When abstracting a lot of low level functions of the form MonadIO m => Handle -> Foo -> m Bar, does it make sense to provide a monad that carries the handle around?
07:07:45 <tsahyt> it'd basically just be a glorified reader I suppose
07:08:17 <lyxia> yes it does
07:09:21 <tsahyt> lyxia: the downside I can see is that providing a concrete monad for this means that it'll be harder to use the library in arbitrary monad stacks
07:09:45 <tsahyt> well arbitrary with IO at the bottom
07:10:24 <abbradar> quchen: Well, okay, I can always do `data Validate err a = Failure err | Success (Either err a)`
07:10:41 <abbradar> A bit clunky but should both save the laws and do the job of introducing data dependencies
07:11:00 <abbradar> TBD: rename `Success` ^_^
07:12:33 <lyxia> tsahyt: you could provide the Handle via a typeclass. MonadHasHandle m => ...
07:12:43 <lyxia> or just MonadReader Handle m => ...
07:13:17 <tsahyt> I'd prefer the former because you can only have one MonadReader afaik
07:14:09 <hongminhee> Hi! I have a question about Haskell associated types.
07:14:10 <tsahyt> would ResourceT be suitable for this?
07:14:28 <tsahyt> the handle gets created at some point, and must be destroyed later. so it is like a resource in that respect
07:14:45 <hongminhee> Is there any way to constraint to associated types to be an instance of a typeclass?
07:15:42 <hongminhee> I want to make an associated type of a typeclass I made to always be an instance of Show
07:15:46 <tsahyt> hongminhee: I think you can always use the associated type in a constraint on your functions
07:16:06 <lyxia> tsahyt: it solves the problem of releasing resources, but Handle does that automatically when it is garbage colleted.
07:16:27 <lyxia> or does it not?
07:16:29 <tsahyt> lyxia: it does not, I am wrapping around a C library here
07:16:47 <tsahyt> hence this design to begin with, as it's written in an OO style
07:17:12 <tsahyt> so really what I'm trying to find out is how to translate this OO style into something that works well in a functional setting
07:17:24 <tsahyt> ideally without incurring much overhead
07:17:45 <tsahyt> the good part is that there's no inheritance going on in this library
07:18:02 <hongminhee> tsahyt: thanks!
07:18:29 <Welkin> OO and haskell do not mix
07:18:39 <tsahyt> Welkin: I still need this library
07:19:09 <infandum> Simple questions: "fmap (f . g) xs" traverses xs ONCE, correct?
07:19:38 <tsahyt> hongminhee: note that this only disallows the use of types not being part of this typeclass in those functions, not the definition of such associated types
07:20:37 <Welkin> infandum: yes, and you can write it just as well as `fmap f . fmap g` and list fusion will take care of it for you
07:20:41 <tsahyt> Welkin: but this particular use of OO isn't all that bad I think. there's no inheritance. just constructors, destructors, and decomposition.
07:20:52 <tsahyt> I think it should be possible to write a decent interface around it
07:21:07 <hongminhee> Indeed.  But your advice saves me anyway.  😃
07:21:21 <infandum> Welkin: Great, that was my next question. Then "filter p . fmap f $ xs" also traverses the list once, right?
07:22:16 <Welkin> yes, it should
07:22:37 <tsahyt> are there any articles on designing high level FFI bindings?
07:22:41 <infandum> Welkin: Then does "mconcat [take 1 xs, fmap f xs]" traverse once or twice?
07:22:46 <tsahyt> before settling for anything I'd really like to evaluate my options here
07:23:05 <javjarfer> Hi, anyone knows why this code generated by GHC need the second type annotation?  http://pastebin.com/fRB4dktg
07:23:11 <infandum> Welkin: In my mind I can totally traverse that once, but does GHC do that?
07:25:28 <lyxia> javjarfer: Does it need it?
07:25:35 <ph88> hey guys i'm implementing Uniplate.Direct for my types (and succeeded) .. but now i have a polymorphic type. How can i implement Uniplate for, for example  data Foo a = Foo a  ??   https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Direct.html
07:26:12 <Phillemann> I'm looking for an article, I think it was by Dan Piponi. It was about composing stuff and monoids and showed that with monoids, when you combine two "a", you get another "a" instead of a "b" which is then not composable with further "a"s. Does somebody know the article I'm looking for?
07:26:43 <tsahyt> Phillemann: I remember something like that, but from a stackoverflow answer I think
07:26:59 <Phillemann> Ah yes, could be.
07:27:32 <javjarfer> lyxia, well I assumed it need it, It doesn't? I'm going to check it...
07:27:46 <lyxia> ph88: the same way you do with non-recursive types I suppose
07:28:43 <lpaste> Vadim revised “Monoid for custom Option”: “Monoid for custom Option” at http://lpaste.net/298114
07:29:10 <lpaste> Vadim revised “Monoid for custom Option”: “Monoid for custom Option” at http://lpaste.net/298114
07:30:31 <ocramz> hi there
07:31:20 <vadimich> Sorry for overlooking Only mempty
07:31:26 <vadimich> here is the new code 
07:31:27 <vadimich> http://lpaste.net/298114
07:31:39 <lyxia> But it's not a monoid.
07:31:41 <ocramz> under what conditions does Hackage build docs? i.e. I've uploaded a package 26 hours ago and it's still marked "docs pending". This is taking much longer than previous versions of the same package, and I've added very little so it makes no sense
07:31:57 <vadimich> lyxia - thank you 
07:32:10 <vadimich> i will figure out the monoid rules
07:32:22 <vadimich> but at this moment i am looking to solve the type issue
07:32:25 <vadimich> if you can help please
07:32:35 <lyxia> vadimich: don't annotate mempty
07:32:44 <vadimich> why not?
07:32:45 <ph88> lyxia, i can do the definition of uniplate and biplate for the polymorphic type. But the biplate function also needs an instance for (Uniplate a) .. but all the "a"s i passed already have a uniplate defined for it .. but still it wants to make sure there is a implementation for all possible a's (theoretically) .. at least i think this is the problem
07:33:27 <lyxia> ph88: Did you define Unplate a => uniplate (Foo a) instead of simply Uniplate (Foo a)
07:33:41 <lyxia> ph88: The second one is what I meant
07:33:55 <ph88> lyxia, i didn't add constraint Uniplate a =>
07:34:26 <vadimich> lyxia it did work - please explain the magical magic here
07:34:46 <lyxia> vadimich: mempty :: a  means  mempty :: forall a. a,  it's a different type variable from the a in the "instance  Monoid a => Monoid (Optional a) where".
07:34:56 <ph88> lyxia, that worked .. however i thought it would also fix a bunch of other errors and it did not, so i still have to investigate the remaining compiler errors
07:35:27 <lyxia> vadimich: if you want to refer to the same type a, you need the ScopedTypeVariables extension
07:35:28 <vadimich> @lyxia - thank you 
07:35:28 <lambdabot> Unknown command, try @list
07:35:36 <ph88> lol
07:35:46 <vadimich> i will read about forall and ScopedTypeVariables
07:38:13 <javjarfer> lyxia, indeed it's needed. But I can't use that type, because GHC.Types doesn't export it, I assume that its only for internal use
07:40:11 <lyxia> javjarfer: what happens if you remove it?
07:41:00 <javjarfer>  Couldn't match representation of type b0 with that of a_a2nd0' -> ExceptT ParseError (State B.ByteString) a_a2nd0 arising from a use of GHC.Base.coerce
07:41:20 <javjarfer> lyxia, GHC isn't able to fully resolve that type
07:42:28 <lyxia> oh I see
07:43:04 <lyxia> the occurences of a_a2nd  are in fact the same variable.
07:44:23 <lyxia> so you need to coerce from   a -> Foo a    to   a -> Parser a
07:44:29 * hackagebot hslogger-reader 1.0.2 - Parsing hslogger-produced logs.  https://hackage.haskell.org/package/hslogger-reader-1.0.2 (alex_bates)
07:44:46 <bollu> :t many
07:44:48 <lambdabot> Alternative f => f a -> f [a]
07:44:54 <bollu> how is many defined?
07:45:01 <Tuplanolla> @src many
07:45:01 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:45:10 <lyxia> javjarfer: without the type annotation, you the argument of coerce would have type (forall b. b -> Foo b)
07:45:29 <lyxia> javjarfer: while its result is expected to be (a -> Parser a) for a rigid a.
07:45:54 <lyxia> javjarfer: and the compiler cannot deduce here that b should be instantiated with b.
07:45:57 <lyxia> with a.
07:46:06 <Tuplanolla> Use `:i many` in GHCi and go look at the source code of the module it reports, bollu.
07:46:15 <bollu> oh, thanks
07:47:41 <Tuplanolla> If you want documentation that is synchronized with the package versions you have installed, enable Haddock in ~/.cabal/config and look inside ~/.cabal/share/doc, bollu.
07:47:51 <bollu> ooh, cool, thanks!
07:47:54 <ph88> i'm using a list of sum types, but actually this is not the right structure for my problem, because each option of the sum type can be more than 1 time in the list. What structure could i use to indicate some things can be there or not there (like on/off) ?
07:48:49 <lyxia> ph88: how is a list not suited for that
07:49:11 <lyxia> [False, False], False is twice in the list
07:49:15 <lyxia> and True is not.
07:49:51 <javjarfer> lyxia, oh! I see! nice, thanks you. I was looking of how GHC was doing the deriving of Applicative for a Parser type, but it looks like it is using some magic behind, with the use of PtrRepLifted
07:50:05 <Tuplanolla> Are you describing a multiset, ph88?
07:50:15 <bollu> 	why are the applicative laws so ugly? :(
07:50:21 <bollu> is there really no nice way to write it out?
07:50:34 <Welkin> bollu: you are here too?
07:50:40 <bollu> isn't it supposed to be a monoid of endofuctors under day convolution?
07:51:02 <bollu> Welkin: yeah, I'm mostly on #haskell, I'm learning emacs for intero
07:51:02 <bollu> Welkin: and ##math
07:51:26 <lyxia> javjarfer: I don't know what PtrRepLifted is but I didn't need to in order to understand how deriving works.
07:51:40 <bollu> does anyone know of a pretty way to derive applicative laws?
07:51:44 <Welkin> intero?
07:52:00 <bollu> Welkin: yeah, it's this package for haskell for emacs that works. it uses stack
07:52:14 <bollu> Welkin: https://github.com/commercialhaskell/intero
07:52:29 <bollu> like, I can't remember applicative laws in their current form.
07:53:11 <javjarfer> lyxia, well, with your explanation now I see how is doing this deriving, but I can't do the same without the use of that internal type I can't access, that is why I said it is using magic
07:53:31 <lyxia> bollu: Gurkenglas mentioned associativity of <.> some weeks ago, (<.>) :: f (a -> b) -> f (z -> a) -> f (z -> b), as a potential alternative.
07:54:13 <bollu> lyxia: that and..?
07:54:40 <lyxia> javjarfer: you don't need to annotate a_whatever with its kind.
07:55:44 <bollu> lyxia: complete list of laws? and how is that associativity? that is composition
07:56:26 <lyxia> bollu: Associativity of that operator was meant to replace the "associativity" of <*>
07:56:39 <bollu> lyxia: ah
07:56:51 <ph88> lyxia, i want to annotate some other type with versions, so i have data Version = V1 | V2 | V3 .. some things support only V1, some other V1 and V2, some other V1 and V3 ... but in the list i can put: [V1, V2, V1] where the last V1 is nonsense because i already have V1 in the list !
07:56:52 <Tuplanolla> Do you mean the composition law, lyxia?
07:56:58 <ph88> Tuplanolla, i don't know what a multiset is
07:56:58 <lyxia> "composition law" right
07:57:04 <Tuplanolla> Yeah, it's terrible.
07:57:16 <Tuplanolla> @hackage multiset
07:57:16 <lambdabot> http://hackage.haskell.org/package/multiset
07:57:33 <Tuplanolla> That's a multiset, ph88.
07:57:37 <lyxia> bollu: I don't know how the other laws would be improved though.
07:57:38 <ph88> alright thx
07:58:21 <ph88> Tuplanolla, in the description what does this mean? "can contain multiple copies of the same key"
07:58:24 <bollu> lyxia: can't you use the day convolution way of writing down applicative for better laws?
07:59:04 <Tuplanolla> It's an error, ph88. It should say "like a set, but it can contain multiple copies of the same element".
07:59:12 <lyxia> bollu: Uh, it's not something I'm familiar with :(
07:59:41 <bollu> lyxia: ah, damn, Neither am I, but I was ekmett's talk where he defines it that way
08:00:06 <ph88> Tuplanolla, what do you mean with multiple copies of the same element ?
08:00:43 <bollu> ph88: a set can't have repeated elements. Like, {3, 3} doesn't make sense
08:00:54 <bollu> but in a multiset, you can ask "how many copies of this element exists"?
08:01:03 <bollu> whereas in a set, you can only ask "does this element belong or not"?
08:01:28 <Welkin> okay
08:01:30 <Tuplanolla> Also `MultiSet a` ~ `Map a Int`, ph88.
08:01:37 <ph88> you make it sound like i want a set and not a multiset
08:01:45 <tsahyt> is there some general version of MonadHasFoo classes?
08:01:50 <Welkin> so a multiset is just a Map with the value set to the number of times it appears
08:02:26 <lyxia> bollu: is that talk online? I'm curious
08:03:14 <bollu> lyxia: yes, it was. It was on google where he derives a "contravariant applicative"
08:03:14 <bollu> lemme look it up quick
08:03:33 <tsahyt> I suppose what I'm looking for is something along the lines of MonadHas a m, such that I could write constraints of form MonadHas Foo m
08:03:54 <tsahyt> which is a lot like reader, but the functional dependency prohibits having MonadReader a m and MonadReader b m at the same time
08:04:33 <bollu> lyxia: here you go! https://www.youtube.com/watch?v=cB8DapKQz-I
08:05:23 <ph88> Tuplanolla, i don´t understand why you advice me multiset and not set
08:05:27 <lyxia> bollu: cool thanks!
08:06:13 <bollu> lyxia: also, thank you for making me fall in love with haskell :) IIRC, it was you who did `fmap fmap fmap` where I asked "how do I add 1 to each element of [[1, 2], [3, 4]]" back when I was just starting out :P
08:06:22 <c_wraith> tsahyt: classy lenses have stuff like that.
08:06:25 <sdx23> how would I use -fllvm within a stack project on debian jessie (only llvm 3.5 and 3.8 available, apparently it'd need 3.7 ?)
08:06:36 <javjarfer> lyxia, I don't understand, so what I need to do? Also I have been able to use the "PtrRepLifted" because the expose "Type" that is "type Type = TYPE PtrRepLifted"
08:06:57 <Tuplanolla> Oh, I thought you wanted the opposite, ph88. A set works then.
08:06:59 <tsahyt> c_wraith: but that just generates classes, right?
08:07:12 <sdx23> (forgot: it's ghc 8.0.1)
08:07:13 <javjarfer> lyxia, and this time I get this error, Couldn't match representation of type a_a2nd0 with that of a_a2nd arising from a use of GHC.Base.coerce
08:07:21 <tsahyt> so there's no general class that is parameterized over the type that the monad "has"
08:07:38 <c_wraith> tsahyt: no, it uses a single class and generates instances
08:08:14 <ph88> Tuplanolla, what´s even "the opposite" ?
08:08:25 <tsahyt> c_wraith: where can I find this? google directs me to Control.Lens.TH, but it seems to generate classes
08:09:16 <Tuplanolla> Just the opposite of your statement "each option of the sum type can be more than 1 time in the list", ph88.
08:09:19 <lyxia> javjarfer: pure = coerce (pure :: a -> InnerM a) :: forall a. a -> MyM a   also turn on ScopedTypeVariables.
08:09:31 * hackagebot data-msgpack 0.0.5 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/data-msgpack-0.0.5 (iphydf)
08:09:38 <ph88^> lyxia, so for the remaining errors i made a small test case showing 1 of such errors, could you take a look? the error is at the bottom https://paste.fedoraproject.org/460302/73217061/
08:10:02 <ph88> Tuplanolla, then i don´t understand the difference between multiset and a list
08:10:18 <Tuplanolla> A multiset doesn't have an order, ph88.
08:10:26 <ph88> ah right
08:10:48 <Tuplanolla> I think it also has to be finite.
08:11:05 <lyxia> ph88: the error location is not right
08:11:20 <javjarfer> lyxia, omg that was ScopeTypeVariables, wish I had a clapping gif here. Thanks you
08:11:25 <c_wraith> tsahyt: ah, you're right.  It does generate classes.  But it still solves your problem, as far as I can tell.
08:11:32 <ph88^> lyxia, you are right it should be line 25 i think
08:11:57 <bollu> Mu ~= Fix?
08:12:04 <lyxia> ph88^: there is no "it = aeis test" in that file
08:12:04 <bollu> is Mu just Fix at the type level?
08:12:30 <ph88^> lyxia, afaik it is a value automatically created by ghci when evaluating code
08:12:44 <c_wraith> bollu: There are several ways to write type-level fixed points.  Fix is always the same one.  Mu sometimes is the same, sometimes isn't - but it is always a fixed point.
08:12:55 <bollu> hm, ty
08:13:29 <ph88> is Data.Set.fromList the normal way to create a Set ? seems a bit of a waste to create a linked list first
08:13:29 <lyxia> ph88^: ah I did not register the <interactive>...
08:13:48 <lyxia> ph88: why does aeis require a Biplate from Identifier
08:14:00 <lyxia> and why don't you implement it?
08:14:33 <bollu> what's an f-w algebra? I know that an algebra is f a -> a where f is a functor
08:16:39 <nevere> What does the '|' in this class declaration mean? class Monad m => MonadReader r m | m -> r where
08:16:59 <phadej> nevere: FunctionalDependencies
08:17:15 <phadej> m determines r, that helps with type inference
08:17:32 <c_wraith> nevere: it means that r isn't an independent variable.  For any choice of m, there is only valid type r
08:17:41 <c_wraith> only *one* valid type r
08:20:41 <ph88^> lyxia, 1) i figured out what the type of aeis should be with trial and error. eventually i got ghci to infer the right type for me (forgot how i actually did that). Without the type annotation the code does not compile though. This worked for plating on monomorphic types. But now i have NonTerminal which is a polymorphic type. 2) i didn't implement directly the biplate between LogicalName and Identifier because in the real code LogicalName can also be 
08:20:41 <ph88^> something else than Identifier (that is the reason why NonTerminal is polymorphic). I was hoping with the polymorphic implementation of biplate of NonTerminal on line 32 and 33 that it would cover all possible instances of this biplate. It would suck to manually implement all the possibilities of a and defeat the purpose of using polymorphic code. Note that the docs https://hackage.haskell.org/package/uniplate-1.6.12/docs/Data-Generics-Uniplate-Direct.html 
08:20:42 <ph88^> say that those functions only implement monophoric instances .. but the documentation also indicate that it should be possible to make a uniplate/biplate implementation of polymorphic instances .. it just doesn't tell how ..
08:21:17 <c_wraith> It does a bit more than just helping with inference - it also makes it a compile error to provide definitions with the same m and different r types.  (If it didn't, it wouldn't really help with inference)
08:23:09 <lyxia> ph88^: Hm, I'm starting to get an idea of what you're trying to do.
08:23:14 <ph88^> good :P
08:23:45 <javjarfer> lyxia, GHC impress me more every day, It's amazing how It can lift and construct all of those types automatically
08:24:05 <ph88^> years of exercise to do that kind of lifting
08:24:34 <danharaj> never miss lambda day
08:25:05 <sham1> do you even lift
08:26:11 <c_wraith> tsahyt: what you want, more precisely, will be present in a future version of GHC.  see https://github.com/ghc-proposals/ghc-proposals/pull/6  (But because that's in the works, no one is really reimplementing exactly that, especially since it's more of a pain without the compiler automatically generating them)
08:27:24 <lyxia> ph88^: well you're using a newtype, so it needs its own instances
08:28:40 <lyxia> ph88^: What is he actual LogicalName
08:28:41 <tsahyt> c_wraith: ah right, I forgot that this was basically the same thing.
08:29:13 <lyxia> ph88^: LogicalName a = LN (NonTerminal a) ?
08:29:45 <mikail_> exit
08:33:44 <nevere> How can I use a class constraint that uses a multi parameter typeclass? 
08:34:25 <lyxia> Can you be more specific?
08:34:29 <c_wraith> nevere: I'm not totally clear what you mean by that
08:35:00 <pavonia> -XMultiParamTypeClasses?
08:35:16 <c_wraith> pavonia: that should only be needed to declare one, not to use it
08:35:35 <nevere> c_wraith: My doubt is that since it involves more than one type variable, how is it supposed to use in  a class constraint of the form (Num a) => a -> a-> a..
08:36:01 <c_wraith> nevere: you just provide more type variables
08:36:22 <glguy> nevere: Doubt a b => a -> b -> c
08:36:23 <nevere> c_wraith: But how are they matched?
08:36:29 <c_wraith> nevere: they just are
08:37:07 <c_wraith> What's a simpler example of an mptc?
08:37:16 <c_wraith> I want to avoid something using higher-kinded type variables.
08:38:05 <nevere> c_wraith: I mean, how are they matched to the class definition? Should they be in the same order as it is declared in the typeclass declaration?
08:38:15 <lyxia> coerce?
08:38:44 <c_wraith> nevere: yes, type arguments are positional
08:38:49 <c_wraith> nevere: just like function arguments
08:39:00 <ph88^> lyxia, yes but Identifier does have it's own instance. LogicalName itself is not polymorphic. In my grammar all non-terminals are wrapped in NonTerminal. So you get  (NonTerminal LogicalName (NonTerminal Identifier (Terminal SomeTerminalToken)))
08:39:16 <nevere> c_wraith: Yes. makes sense. Thankyou.
08:40:00 <c_wraith> I'm having some difficulty using DuplicateRecordFields.  I can't figure out how to specify which one I mean.
08:40:25 <c_wraith> Ah.  Hmm.  Finally found a case that works.
08:40:29 <c_wraith> Man, these things are picky.
08:40:57 <ph88^> lyxia, at some point monomorphisation must happen right? I only have 1 level of polymorphism on the type level ..
08:43:16 <lyxia> ph88^: I didn't understand. NonTerminal has kind * -> *
08:43:23 <ph88^> yes ?
08:44:10 <lyxia> well you wrote something where it should have type * -> * -> *
08:44:25 <ph88^> on which line did i write that ?
08:44:32 <lyxia> and I don't get what you said about monomorphisation.
08:44:45 <lyxia> ph88^: (NonTerminal LogicalName (NonTerminal Identifier (Terminal SomeTerminalToken)))
08:45:20 <ph88^> of the first NonTerminal, the first * is LogicalName the second * is (NonTerminal Identifier (Terminal SomeTerminalToken))
08:45:41 <ph88^> ah yes that's wrong indeed
08:45:42 <ph88^> i see
08:46:04 <ph88^> (NonTerminal (LogicalName (NonTerminal (Identifier (Terminal SomeTerminalToken)))))
08:46:07 <ph88^> it's this
08:46:23 <c_wraith> Ah, I've figured out why TypeApplications doesn't work with DuplicateRecordFields - it's because there isn't a type variable in play to indicate the record type.  (That's part of the future extension)
08:46:41 <ph88^> lyxia, i typed that wrong in chat, the types should be correct though
08:47:17 <lyxia> ph88^: if NonTerminal is going to wrap everything why not make it part of LogicalName as I did
08:47:33 <lyxia> and as you started to do, though it wasn't polymorphic yet
08:47:55 <lyxia> LogicalName a = LN (NonTerminal a)
08:48:33 <ph88^> what good would that do ?
08:48:44 <lyxia> shorter types?
08:49:28 <ph88^> but i would have to instanciate LogicalName with the right a .. this is now encapsulated in the definition of LogicalName
08:49:36 <ph88^> this is better in my opinion
08:50:13 <ph88^> also i don't want LogicalName to take all possible "a"'s ..
08:50:38 <lyxia> Does that go against my point
08:50:52 <lyxia> what is "this"
08:51:01 <lyxia> a monomorphic LogicalName?
08:51:05 <ph88^> yes !
08:51:32 <lyxia> Then what you wrote makes no sense because LogicalName currently expects no type argument
08:51:44 <lyxia> So I'm still confused.
08:51:52 <ph88^> i can see why you are confused
08:51:57 <lyxia> You can't write LogicalName (NonTerminal ...)
08:52:50 <ph88^> i wrote it .. it works .. just not with Uniplate and Biplate
08:52:58 <lyxia> and in any case you have to write an insstance of Biplate explicitly
08:53:15 <lyxia> it might rely on the instance of  NonTerminal to implement though
08:53:27 <ph88^> i'm doing monomorphic -> polymorphic -> monophorphic .. so that i don't have to duplicate the code that is now polymorphic
08:53:42 <ph88^> this is the definition in my "real" code of LogicalName:    newtype LogicalName = LN (NonTerminal Identifier) deriving (Eq, Show, Generic)
08:54:50 <lyxia> instance Biplate  LogicalName Identifier where biplate (LN x) = let (a, b) = biplate x in (a, LN . b)
08:55:13 <lyxia> ph88^: I have no idea what you mean with these arrows "monomorphic -> polymorphic -> monophorphic"
08:55:26 <ph88^> the arrow mean down the type tree
08:55:41 * lyxia shrugs.
08:55:43 <ph88^> sorry about the arrows :/
08:57:00 <ph88^> lyxia, your code works
08:57:15 <lyxia> Yay
08:57:25 <ph88^> why is this needed ??
08:57:50 <lyxia> Because that's in the type of aeis
09:01:37 <ph88^> lyxia, type of aeis doesn't mention LogicalName
09:02:32 <ph88^> isn't this still monomorphic code??  instance Biplate LogicalName Identifier where
09:03:15 <lyxia> I'm not sure how you expect that to be polymorphic
09:03:36 <lyxia> but it reuses the code you wrote for NonTerminal.
09:04:19 <lyxia> ph88^: It mentions Identifier, and LogicalName is involved because you are applying aeis to one.
09:05:21 <ph88^> what about   instance Biplate LogicalName (NonTerminal a) where   ?
09:06:02 <jg__> hi all. I have the following parser: http://bit.ly/2e46Mki . I'd like to change 'parse :: [PosToken] -> [Command]' to 'parse :: Context -> [PosToken] -> [Command]' where 'Context' would be just an array of bindings that the parser has already seen. Does anyone know how to do that? There's a terse note about it in the docs (section 2.1) but i'm still not sure how to implement it in Happy
09:06:26 <lyxia> ph88^: Why would you want that
09:06:57 <ph88^> lyxia, then i don't have to implement instance Biplate LogicalName for each as
09:07:38 <lyxia> ph88^: I don't understand your logic, and that won't help you use aeis like you were trying to...
09:07:49 <ph88^> lyxia, this is interesting ... by trial and error i commented out instances which apparently where not even used !! you can see how i'm confused because i implemented a lot of things unnecessary it seems  https://paste.fedoraproject.org/460328/32521014/
09:08:22 <lyxia> well I can't tell since I can't see all of your code
09:09:42 <ph88^> lyxia, the code i just pasted is a fully working test code .. this is a test to see how i should implement things back into my "real" code .. which has basically the same type but is cluttered with a lot of noise
09:10:37 <lyxia> ph88^: For what a do you need an instance of Biplate LogicalName a
09:11:46 <lyxia> There is just one function here which uses Biplate, it's aeis, and it instantiates the second argument to Identifier
09:13:07 <ph88^> hey hey i'm just trying to wrap my head around what this biplate actually requires for implementation. And when it's different from my expectations i try to figure out what is the new meaning of the working implementation, other than "it type checks" and also why the expectations i made are apparently wrong
09:16:42 <ph88^> the way i apparently have to implement biplate is to implement it for each "start point" to each "end point" .. i thought i would only have to implement it from one node to the child node. See here what happens when i create a new root node ExtraWrapper https://paste.fedoraproject.org/460329/77325704/
09:18:01 <vandenoever> is there a pure way to deflate in Haskell (e.g. ByteString -> Maybe ByteString)? pure-zlib clashes with zlib (both are Codec.Compression.Zlib)
09:18:28 <ph88^> so when i have types  A ..> B ..> C ..> D ..> E ..> F ..> G ..>  and i want to modify G from all of the above i have to implement Biplate A G, Biplate B G, Biplate D G .. and so on. And then when i want to modify F i have to implement Biplate A F, Biplate B F, and so on ...
09:18:40 <ph88^> ..> is indication for child node in tree
09:20:41 <EvanR> vandenoever: it should be possible to 1) wrap zlib with pure FFI calls and 2) in such a way to make the decoded data (even richer than ByteString data) lazily drive the decompression and decoding
09:20:48 <EvanR> but i guess youre asking if this has been done already for you
09:21:01 <ph88^> worst thing is .. this is not even catched by GHC .. it will compile and then when i run my functions it just says "No instance for blabla arising from a use of blabla"
09:21:41 <vandenoever> EvanR: ideally sure :-)  and actually pure-zlib has done it, but unf it clashes with impure zlib
09:21:48 <lyxia> ph88^: This is definitely catched by GHC
09:22:01 <vandenoever> Ambiguous interface for ‘Codec.Compression.Zlib’: it was found in multiple packages: pure-zlib-0.4 zlib-0.6.1.1
09:22:31 <EvanR> but do you mean clashes
09:22:48 <EvanR> two packages call things the same thing?
09:22:53 <ph88^> lyxia, i reload code with :r it's interpreted and no error https://paste.fedoraproject.org/460331/14773261/
09:23:10 <EvanR> that pretty much spells "you cant use both of those packages"
09:23:14 <vandenoever> EvanR: yes, see 'Ambiguous interface' error i pasted above
09:23:18 <vandenoever> EvanR: right
09:23:38 <EvanR> ambiguous interface, not sure i know about that error
09:23:57 <EvanR> do you need to use both packages for some reason?
09:24:03 <lyxia> ph88^: but the error you get afterwards is not a runtime error. GHC typechecks your program "aeis someName" and fails
09:24:20 <ph88> why is this not typechecked on :r  ?
09:24:30 <vandenoever> EvanR: yes, the pure one can only decompress
09:24:32 <lyxia> because it's not in your script
09:24:41 <ph88> aaah i see
09:24:42 <ph88> ok
09:24:47 <ph88> be back in ~45min
09:25:40 <EvanR> thats pretty terrible
09:25:53 <EvanR> (that theres two libs, not both perfect, on the same names)
09:29:36 * hackagebot mysql 0.1.2.1 - A low-level MySQL client library.  https://hackage.haskell.org/package/mysql-0.1.2.1 (paulrouse)
09:33:33 <EvanR> vandenoever: you might want to see if theres an add-on for pipes or conduit which does compression
09:33:43 <EvanR> they seem to have lots of add ons and im sure some deal with compression
09:35:23 <lyxia> vandenoever: there is a GHC extension for ambiguous interfaces
09:36:42 <lyxia> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#package-qualified-imports
09:39:18 <vandenoever> EvanR: ok, i can try, the compression is a dep from another lib, so might be tricky (using yesod)
09:39:29 <vandenoever> lyxia: ah, nice to know, i'll look into it
09:45:02 <tabaqui1> does anybody work with ginger?
09:45:22 <tabaqui1> can i pass into template json map without decoding?
09:45:48 <tabaqui1> cause it's fields have different types and i don't know them all
09:46:06 <tabaqui1> so i just want to pass them in
09:49:48 <grazie> I define the following func in ghci, receive error message Data constructor not in scope (for both Zero and Succ):   let { nat2int Zero = 0; nat2int (Succ n) = n + nat2int n }
09:50:04 <grazie> do I have to import something to use Zero and Succ?
09:50:20 <jle`> grazie: you have to at least define it first
09:50:21 <sham1> Depends
09:50:23 <jle`> somewhere
09:50:30 <jle`> those aren't standard data types
09:50:42 <jle`> data Nat = Zero | Succ Nat, maybe?
09:50:43 <EvanR> i.e. not in prelude
09:50:59 <grazie> jle` thank you. the book I'm using doesn't tell me that
09:51:04 <jle`> yeah, and there isn't any canonical package that defines them either
09:51:12 <monochrom> Where did you heard Zero and Succ? That place ought to say. If not, never read that irresponsible author again.
09:51:25 <jle`> it's not really a type that you'd expect to see without clarification
09:51:37 <jle`> it's not a standard type from any common library
09:52:32 <jle`> your book might as well define a function let { foo Cow = "moo"; foo Asparagus = "five" }
09:52:43 <grazie> The author does define this: data Nat = Zero | Succ Nat 
09:52:44 <jle`> and not say anything about what type has Cow and Asparagus
09:52:57 <jle`> grazie: ah, so you'll need to define that type if you want to use it
09:53:12 <monochrom> yeah you have to include that code
09:53:13 <jle`> you can define it in ghci by just typing 'data Nat = Zero | Succ Nat'
09:53:29 <grazie> jle` I did (just now) but then when I defined the func after, I got the error :  • No instance for (Num Nat) arising from the literal ‘0’     • In the expression: 0       In an equation for ‘nat2int’: nat2int Zero = 0
09:53:29 <jle`> grazie: it's not as if ghci can magically read your book and import the definition from the pages :)
09:54:00 <jle`> it looks like nat2int might have a typo
09:54:08 <jle`> it should be nat2int (Succ n) = 1 + nat2int n
09:54:13 <grazie> jle`:  the author could be more explicit about certain things
09:55:14 <jle`> but yeah, your Nat type isn't defined in any commonly established libraries, so it's likely that the book intended for you to define it in ghci/whatever file you write, or at least that nat2int was never meant to be tried out by the reader
09:55:21 <grazie> ok, thank you for your help
09:55:24 <jle`> np!
09:55:42 <EvanR> well i made a non trivial free monad. is there a way to allow the user of this monad to use another monad internally, like State or Random while also accessing the free monads API
09:56:12 <jle`> grazie: you could submit a correction for that typo too if you're up for it :)  that's a pretty critical typo haha
09:56:45 <grazie> ok, I will
09:57:07 <EvanR> runFreeT :: FreeT f m a -> m (FreeF f a (FreeT f m a)) hmmmm
09:58:12 <EvanR> i feel like i cant do it because my interpreter would have to negotiate their chosen monad in some way, which it cant do in general
09:58:16 <tabaqui1> well, fine
09:58:18 <tabaqui1> so
09:58:31 <tabaqui1> can i just create some like aeson dictionary
09:58:43 <EvanR> yep
09:58:43 <tabaqui1> but with Map String (anytype)
09:58:46 <tabaqui1> ?
09:59:01 <tabaqui1> it's not haskell way, but
09:59:06 <EvanR> anytype that has a ToJSON instance
09:59:40 <tabaqui1> of course
09:59:47 <glguy> tabaqui1: http://hackage.haskell.org/package/ginger docs up
10:00:04 <tabaqui1> glguy: yeah, i've read 'em
10:00:20 <tabaqui1> no words json/aeson/yaml inside
10:02:25 <tabaqui1> glguy: ah, maybe this...
10:02:34 <tabaqui1> toGVal Value
10:05:51 <PhsShft> how do you write a functor instance for a binary tree? data BinaryTree a = Leaf a | Node (BinaryTree a) (BinaryTree a)
10:06:36 <EvanR> you put deriving(Functor) ;)
10:06:53 <PhsShft> wait you can do taht 
10:07:06 <EvanR> yeah, but is this homework? i doubt itd be accepted
10:07:26 <EvanR> do you have the type signature for fmap written down for this type?
10:07:31 <PhsShft> it’s an excise on the book
10:07:53 <PhsShft> nope, but I’m trying to understand functor better
10:08:03 <EvanR> thats the first step
10:08:05 <ongy> then you should do it yourself, to learn it. Can you ask a more detailed question, where you are hanging?
10:08:43 <tabaqui1> btw what means
10:08:52 <tabaqui1> data Foo = Bar !Int
10:08:59 <tabaqui1> ?
10:09:13 <ongy> That the Int is a strict argument
10:09:21 <tabaqui1> so simple?
10:09:22 <EvanR> its a data type with one constructor, the one constructor has one component of type Int
10:09:35 <tabaqui1> it's just strictness?
10:09:35 <EvanR> and the component is marked strict with !
10:09:49 <tabaqui1> hm, ok, thx
10:11:12 <PhsShft> http://lpaste.net/298627 will this work?
10:11:37 <EvanR> you should load it into the computer!
10:11:51 <EvanR> then try fmapping stuff
10:11:59 <PhsShft> kk
10:12:00 <PhsShft> haha
10:12:35 <EvanR> its kind of hard to mess up a functor implementation
10:12:39 <Boomerang> PhsShft: You should probably change "instance Functor Tree" into "instance Functor BinaryTree"
10:12:48 <PhsShft> yea i noticed that 
10:12:49 <EvanR> if its messed up, itll look very funny
10:13:11 <PhsShft> what’s the deriving(Functor) thing, can you always do taht for Functor?
10:13:19 <S11001001> PhsShft: good job
10:13:24 <S11001001> PhsShft: and no
10:14:31 <S11001001> PhsShft: it works pretty well for "normal" datatypes, but more exotic (yet still quite useful) datatypes won't work with it
10:15:09 <EvanR> it works for GADTs though, which is good
10:16:54 <mizu_no_oto_work> PhsShft: Functor is one of those things where it's hard to have an incorrect implementation that still typechecks that's not obviously wrong
10:17:38 <PhsShft> lol I feel that writing haskell is fun in the fact that if it complies it bascially works
10:18:01 <sham1> Until you run into stuff like exceptions
10:18:08 <sham1> In which case it can become a pain
10:18:34 <EvanR> "if it compiles it basically works" is the ideal
10:18:45 <EvanR> theres plenty of ways to muck this up in haskell though
10:19:11 <mizu_no_oto_work> Depends on the kind of code you're writing - it's not hard to write type-correct numeric code that accidentally uses + instead of *
10:19:17 <EvanR> we just recognize that its mucking up, unlike in more dynamic languages
10:19:36 <EvanR> which consider lack of a checker to be a feature not a bug
10:19:38 <mizu_no_oto_work> But there's a lot of mistakes that are easy to make in other languages that you can prevent via the typechecker, definitely.
10:20:20 <Cale> It's so much nicer to have a machine tell you all the things which need to be changed in response to a refactor
10:20:30 <EvanR> ^
10:20:31 <Cale> that once you get used to that, it's really hard to go back to anything else
10:20:32 <jophish> instance Functor (Pair Int) where fmap f (Pair n x) = Pair (n + 1) (f x)
10:21:04 <jophish> instance Functor [] where fmap f (x : xs) = f xs
10:21:39 <jophish> these probably fall under obviously wrong though
10:21:44 <Cale> You can actually keep your code reasonably nice in the face of chaotic changes in specification -- maybe not always functional pearl paper nice, but nice enough.
10:21:57 <sham1> But there are still some places where Haskell's types won't save ya
10:22:07 <Cale> Certainly, yes.
10:22:17 <sham1> Even in places that are supposed to be pure code
10:22:21 <sham1> *cough* head
10:22:22 <Cale> It doesn't completely eliminate the need for testing.
10:23:20 <mizu_no_oto_work> jophish: those are obviously wrong, imo
10:23:33 <kadoban> Would anyone have recommended reading on understanding what https://hackage.haskell.org/package/memoize-0.8.1/docs/src/Data-Function-Memoize.html#memoFix is doing, why that works? Also interested in memoization techniques in general
10:23:39 <EvanR> heads a pretty bad example
10:23:58 <sham1> How so
10:24:04 <EvanR> i never use it
10:24:18 <sham1> Indeed, because it is broken
10:24:23 <EvanR> there are situations where types cant help you, but you clearly need to do it
10:24:23 <nshepperd> hah
10:24:40 <sham1> And stuff like for instance file IO
10:24:43 <nshepperd> jophish: that functor instance for list doesn't typecheck
10:25:08 <jophish> oh yeah,
10:25:15 <jophish> map f xs; then
10:25:43 <Cale> I use head, but only in certain idioms
10:25:52 <Cale> Things like  map head . group . sort  are fine
10:26:26 <sham1> Yeah, while the function itself is not used because of its fatal flaw, it still highlights something eerie
10:26:32 <nshepperd> soon we'll have -XDependentTypes, and we can have a safe 'head' accepting a proof that the list is nonempty
10:26:41 <sham1> Oh nice
10:26:55 <nshepperd> I hope :>
10:27:01 <EvanR> there are worse cases where you need a PHD to come up with the dependent types to explain what youre doing
10:27:32 <Cale> nshepperd: haha, maybe
10:27:35 <sham1> I mean, for a language promoted by having the type system indicate error states, there are a lot of stuff that just does not do that
10:27:38 * nshepperd probably wouldn't actually use a 'head' that required manufacturing proof
10:27:46 <nshepperd> too much work
10:28:07 <mizu_no_oto_work> kadoban: AFAIK, memoization in Haskell basically takes advantage of lazily evaluating a data structure - for example, a lazily generated array, map or binary tree.
10:28:11 <Cale> sham1: Well, usually it's not optimal to put the *entire* specification in the types, even in languages where you *can* do that.
10:28:27 <EvanR> in idris head has an auto proof argument, so in simple cases you dont have to actually write that part
10:28:43 <Cale> It's a matter of taste how much information about correctness goes in the types
10:29:09 <Cale> and well, there's always NonEmpty in Haskell if you want a safe head function.
10:29:24 <sham1> It's not just head though
10:29:27 <sham1> There's more
10:29:28 <kadoban> mizu_no_oto_work: Yeah, I'm fairly clear on doing it manually, but ... not familiar with this trick or doing it in general.
10:29:30 * ongy just uses listToMaybe as safe head
10:29:37 <sham1> Also, that
10:29:39 * hackagebot pandoc-citeproc 0.10.1.4 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.1.4 (JohnMacFarlane)
10:29:46 <EvanR> Maybe doesnt give you a safe head at all
10:29:56 <jophish> ongy: also headMay from the 'safe' package
10:29:59 <EvanR> in the cases were talking about where head would go
10:30:04 <Cale> sham1: Well, in Haskell we have fix, so to some extent, it's a bit of a moot point trying to get everything to be safe.
10:30:14 <Cale> You can always not terminate.
10:30:38 <sham1> Like
10:30:48 <Cale> So, one of the things we could do is further restrict the use of recursion, but there are cases in which that's obnoxious and going to get in your way.
10:31:05 <Squarism> Can use uncons instead of head
10:31:12 <Cale> Passing around fuel parameters and using proofs of boundedness of computation and such is great, but it is extra work.
10:31:12 <mizu_no_oto_work> kadoban: notice that there's `instance (Eq a, Bounded a, Enum a, Memoizable b) ⇒ Memoizable (a → b)` in that file.
10:31:14 <ongy> EvanR: it's not safe though the Maybe, but I think it's way better than head
10:31:25 <EvanR> not in cases where Nothing is impossible
10:31:39 <sham1> Let's take for instance openFile
10:31:40 <EvanR> now its just a performance drain
10:32:06 <sham1> It has a type signature
10:32:06 <Cale> Oh, and yeah, IO does nothing to encode the states in which filehandles can be.
10:32:07 <thoughtpolice> Yeah, but there's sort of a sizeable difference between willingly non-terminating and using 'error' somewhere deep in a library and getting bit by it because something was violated, to be honest. We don't have to go all the way to talking about general recursion to admit "some partial functions really shouldn't be partial"
10:32:16 <thoughtpolice> 'fix' is a bit of a cop-out response.
10:32:16 <sham1> :t openFile
10:32:19 <lambdabot> error: Variable not in scope: openFile
10:32:21 <kadoban> mizu_no_oto_work: Right. That part starts to make sense. I think the most confusing part is the actual memoFix construction there? I ... don't get what that is or why or what it's doing xD
10:32:27 <sham1> Fail
10:32:46 <kadoban> Which might not actually matter, but I'm afraid to use this thing without understanding what it's doing or any restrictions it may have.
10:32:47 <sham1> Anyway, how am I supposed to know from anywhere that it will for instance throw isDoesNotExistError
10:32:55 <mizu_no_oto_work> kadoban: have you seen 'fix f = f $ fix f' before?
10:33:08 <Cale> thoughtpolice: Oh, sure -- it's just we should be as cautious about using error as we would be about writing  let x = x in x
10:33:08 <sham1> There is no way for me to see it, I just have to know that
10:33:22 <EvanR> writing let x = x in x is probably not that much of a concern
10:33:31 <glguy> sham1: It's documented to do so https://hackage.haskell.org/package/base-4.9.0.0/docs/System-IO.html#v:openFile
10:33:37 <Cale> EvanR: It would be if we left out things like error and undefined, maybe.
10:33:39 <sham1> That's the point
10:33:48 <EvanR> but writing a non trivial algorithm with recursion that either you might mess up, or is to be used in a way by a user who might mess up, thats a concern
10:33:49 <sham1> I actually have to activly look at the documentation
10:34:04 <sham1> I cannot just let the types guide me
10:34:10 <Cale> sham1: There are people and libraries who are better about this than others.
10:34:11 <glguy> sham1: The goal isn't for types save you from having to read documentation to know what something does
10:34:28 <EvanR> Cale: what i mean is, writing error "meh" isnt really the concern either
10:34:31 <sham1> At least I can get a hunch
10:34:42 <glguy> sham1: Did you have a question?
10:34:51 <sham1> Like no
10:34:54 <sham1> Umn
10:34:55 <sham1> No
10:35:06 <Cale> EvanR: Well, there's also the concern that there are more occasions on which we need to write something like error "impossible case" than we'd like to have.
10:35:16 <Cale> (because we don't have dependent types)
10:35:17 <sham1> It was just me going on a little bit of a minirant
10:35:45 <EvanR> yeah writing it because youre supposed to write it, because its impossible, thats fine
10:35:46 <Cale> But! Sometimes it's easier this way than the dependently typed safe way, even once you account for the development cost of bugs.
10:35:51 <Cale> It's a complicated problem.
10:35:56 <EvanR> accidentally putting an error in the code isnt the concern
10:36:10 <EvanR> accidentally writing a non terminating algorithm is a concern
10:36:16 <Cale> But we would very much like to have that part of the safety spectrum better represented in Haskell.
10:36:41 <younder> satefy spectrum?
10:37:10 <thoughtpolice> Yeah, I mean, there have been libraries where exceptions are put into type signatures for a while, but they're largely unpopular it seems because they tend to involve a lot more boilerplate, or require large inferred types, and contexts get larger as the combination of different states expands. That said, the exception story isn't great for a number of
10:37:10 <thoughtpolice> reasons besides this.
10:37:22 <Cale> I mean the spectrum of how much information about the behaviour of the programs gets encoded in the types
10:37:27 <younder> Coukd you be more concrete?
10:37:35 <kadoban> mizu_no_oto_work: Briefly ... I should probably look it up and try to understand.
10:38:04 <mizu_no_oto_work> > let _fib = fix (\fib n -> case n of { 0 -> 1 ; 1 -> 1; n -> fib (n -1) + fib (n - 2) }) in _fib 5
10:38:07 <lambdabot>  8
10:38:13 <mizu_no_oto_work> kadoban ^
10:38:17 <Cale> Where on one end, pretty much no information is encoded by the types, and you have something like Data.Dynamic, and on the other end, a complete specification of what it means for the program to be correct is in the types, and your program includes its own proof of correctness.
10:38:40 <younder> Computer safety is notoriously difficult. How do yo guarantie that safety of you code if you can't wouch for he libraries you use.
10:38:41 <thoughtpolice> younder: The example I just gave is one. You can encode exceptions in plenty of fancy ways with types for example, to make sure they're handled, but this all has a tradeoff in how much boilerplate it is, how much work it is to maintain for you and users, etc. It's traditional "engineering" tradeoffs.
10:38:42 <mizu_no_oto_work> kadoban: memoFix allows you to memoize that kind of definition of fib
10:39:04 <EvanR> younder: require only "safe haskell" approved libs! ;)
10:39:05 <Cale> There's a vast amount of design space between those extremes, and Haskell is *not* on the far end.
10:39:09 <kadoban> mizu_no_oto_work: Seems pretty magic xD I'll try to grok fix first I guess ... hmm.
10:40:03 <mizu_no_oto_work> kadoban:  https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion is probably helpful
10:40:09 <Cale> younder: I'm thinking of things like CompCert (written in Coq) for example, as being farther out than what's reasonable in Haskell.
10:40:50 <younder> EvanR: 99 % or more of the code I use is OS browser or compiler. You guaranteee it is all bug free because it is haskell approved?
10:40:56 <Cale> We can specify a lot about our programs in Haskell's type system, and it's much more reasonable to do so than in most programming languages people actively use to write production software
10:41:07 <kadoban> Ya, that looks better that what I googled up to start with
10:41:10 <Cale> But we don't really get the full extent of what's possible here.
10:41:13 <EvanR> younder: i imagine 100% of that 99% isnt "safe haskell"
10:41:41 <younder> EvanR,  Mee too
10:41:45 <EvanR> talking about the safe haskell extension
10:42:26 <younder> Your systems are about as safe as my typing ;)
10:42:38 <EvanR> so
10:42:51 <grantwu> So what is your point, younder 
10:42:55 <Cale> younder: There's no reason to think it's bug free, but there are wide classes of bugs which we *can* eliminate using what's available in Haskell's type system
10:43:09 <EvanR> technology aside, studying these systems that require a termination argument is really mind blowing, and makes you realize how many more things in real life can go wrong (before they actually do)
10:43:15 <younder> So you live in a Haskell mocrocosm. 
10:43:20 <Cale> younder: and that *does* save a lot of development effort in the real world
10:43:31 <grantwu> younder: Yes... in #haskell we write haskell programs.
10:43:35 <Cale> (as someone who spends all day writing Haskell programs for a living)
10:43:42 <ongy> I thought safe haskell is about code I can run without worries on my machine, not safety in the software engineering sense
10:44:05 <grantwu> Obviously we use programs in other languages.  Obviously we depend on them in our Haskell programs too
10:44:08 <dolio> Worries about what?
10:44:12 <Cale> Safe Haskell is a weird notion of safety.
10:44:16 <mizu_no_oto_work> kadoban: also, https://en.wikipedia.org/wiki/Fixed-point_combinator#Lazy_functional_implementation
10:44:24 <younder> Cale, Then sesign the whole OS, the windows system, the browser. Otherwise the libraries ou use WILL ge you :(
10:44:29 <dolio> The only worry it saves you from is unsoundness of the type system, I think.
10:44:34 <NikolajK> How does Haskell vs. Ada compare in terms of writing save programs?
10:44:35 <ongy> dolio: It doing any IO, which could compromise the system in various ways
10:44:45 <dolio> That is not what safe Haskell is.
10:44:47 <Cale> younder: I mean, they might, but there are often workarounds for their issues.
10:45:02 <EvanR> also curious about the relative "safety" of Ada
10:45:25 <Cale> younder: Like, for example, javascript and the behaviour of browsers is generally screwy, and yet we write web applications in Haskell and are relatively shielded from their nonsense.
10:45:27 <kadoban> Thanks
10:46:03 <dolio> I'm not sure Safe Haskell even addresses memory safety.
10:46:05 <Cale> younder: (Often because luite heroically already worked around most of the problems)
10:46:13 <jchia_> I find that occasionally add type annotation to a '<-' line in a do block to make the types of my intermediate values clear and to get simpler error messages if there's a type error. Is this a good practice?
10:46:40 <grantwu> younder: What is your point, exactly... you haven't said anything that we don't know already
10:46:52 <EvanR> jchia_: i get the same experience, by adding type sigs to stuff in a where block
10:46:52 <grantwu> Are you trying to make some sort of argument, or are you learning here
10:47:05 <younder> Cale: Javescrips is sandboxed. And THAt is the easy solution. 
10:47:22 <EvanR> especially with rankN types, the inferrence algorithm sometimes seems to go insane and give you a nonsense message
10:47:39 <Cale> younder: It isn't about being 100% formally correct for me, it's about being sufficiently correct and making the right tradeoffs with regard to correctness in order to optimise development effort in solving the real problems we want to solve with the software we write.
10:47:42 <ongy> dolio: at least if I call it in a non IO context, I hope. They did it for the test system in my course
10:47:42 <younder> Go all OS and sndbox and compatementalize like Zen oS
10:47:55 <grantwu> Javascript sandboxing doesn't even address the same sort of thing that Haskell attempts to address
10:48:07 <Cale> younder: Being 100% formally correct comes with pretty hefty initial costs.
10:48:20 <grantwu> Running untrusted Haskell is likely to be just as dangerous if not more dangerous than running untrusted Javascript
10:48:23 <dolio> ongy: Yeah, that much you can probably rely on, I guess. Because unsafePerformIO defeats type soundness.
10:48:25 <younder> Cale, Indeed
10:49:30 <younder> grantwu, No it is all due to sandboxing. Nodejs is inhenetly unsafe. As is EVERY programming language
10:49:37 <EvanR> Cale: i surmise in the far future, we will have named development methodologies which intentionally do things with less precision and more uncertainty to increase development producivity ;)
10:49:38 <Cale> younder: Haskell usually gives a reasonable part of the spectrum to work with, in between proving everything and letting everything fail at runtime.
10:50:07 <grantwu> younder: What is "it"?
10:50:07 <Cale> But sometimes we'd like to have a little more safety, and there are places where Haskell becomes a bit painful then.
10:50:13 <EvanR> we could call it "wrong is better"
10:50:17 <grantwu> What are you claiming?
10:50:37 <dfeuer> Someone this weekend pointed out that it would be really helpful to offer both Int32Map and Int64Map on all architectures. We currently have 32-bit code for 32-bit machines and 64-bit code for 64-bit machines. Any tips on giving him what he (very reasonably) wants without too much maintenance cost?
10:50:57 <Cale> dfeuer: hmmm
10:51:06 <younder> IF ALL THE CODE IS NOT MATHEMATICALLY VERIFIED WE ARE NOT SURE OF IT
10:51:14 <Cale> dfeuer: GHC's inability to specialise data declarations strikes again
10:51:17 <younder> clear enough
10:51:22 <grantwu> younder: Okay, sure.  We know that.  Next point?
10:51:23 <EvanR> turn off cruise control for cool
10:51:32 <younder> will do
10:51:46 <Cale> younder: But there might still be many things we *are* reasonably sure about with regard to *how* it will fail.
10:51:58 <dfeuer> Cale, yeah.... I suspect we could probably do it by generating whole modules with CPP, but we'd have to be pretty careful. Among other things, import Prelude hiding (Int).
10:52:06 <dolio> backpack?
10:52:25 <dfeuer> dolio, how intrusive will that be?
10:52:30 <Cale> younder: If we can eliminate the most time-consuming persistent sources of bugs, that's still pretty good!
10:52:32 <dolio> No idea.
10:53:03 <dfeuer> I've heard of backpack, but I've never looked at the details. I gather it's a bit of a mess from a class coherence perspective?
10:53:23 <dolio> dfeuer: Here's another question, if you could have Int64Map on both, how much worse would that be than not having Int32Map?
10:53:36 <younder> Cale,  My hereoes are the designers of he space shutle code. The ad the most effective team for eliminatiting errors in code.
10:53:41 <Cale> younder: For example, one of the main sources of bugs in developing web applications is often just making sure that the frontend and backend are communicating correctly -- it was frequently the case before we switched to doing everything in Haskell that the JSON being produced by one side and what was expected on the other would get out of sync, resulting in a bug.
10:53:46 <dolio> Like, does Int64Map degenerate to Int32Map if you only use the lower 32 bits?
10:53:52 <younder> You might want to study why ;)
10:54:06 <grantwu> younder: Are you here to troll us?
10:54:20 <EvanR> wake up sheeple
10:54:21 <Cale> younder: Now we just have the same module doing all that (in fact the parsers and generators of all the JSON are machine constructed from the type definitions)
10:54:39 <kadoban> younder: Having a very skilled team, a good budget, and no a ton of time is indeed a great way to reduce bugs. That's not very practical in the real-world for most projects though.
10:54:41 * hackagebot BitStringRandomMonad 0.1.0.0 -   https://hackage.haskell.org/package/BitStringRandomMonad-0.1.0.0 (Ofenhed)
10:54:43 <younder> No, I am not troling you
10:54:45 <bollu> Cale: can I quiz you on some of the free/cofree construction?
10:54:48 <Cale> and that same code is used on the frontend and backend, so there's much less potential for screwing it up
10:55:02 <grantwu> younder: Do you have something novel to contribute to the discussion?
10:55:03 <dfeuer> dolio, well, an Int64Map has twice as many bits to deal with, and on 32-bit architectures will (I believe) use FFI for every arithmetic operation.
10:55:21 <Cale> Just by construction, and the fact that types have to match.
10:55:35 <younder> grantwu,  I have contributed what I will for now
10:55:44 <dfeuer> I don't know how big the slowdown would actually be.
10:55:57 <grantwu> younder: No, you've contributed nothing...
10:56:26 <Cale> I can make some change on the backend, and eventually (or usually almost immediately), I will need to change the code which is in common between our frontend and backend, and then that will propagate into type errors in the frontend, and by the time I've fixed up the errors, the app is usually working -- at least, there are no *communication* bugs of that sort.
10:56:59 <younder> grantwu, Haskell centric is not good enough. We live in a hetrogenous programming environment.
10:57:04 <Cale> and the typechecker is helping me all the way along
10:57:27 <grantwu> younder: This isn't #how-to-fix-software-in-21st-century, this is #haskell
10:57:29 <thoughtpolice> dfeuer: Backpack has some tradeoffs with the way classes are done (things may type check individually but later fail at link time due to overlapping instances). But it could be used to solve this because you would just specialize a generic signature to some concrete implementation. So it would probably work well in this case.
10:57:58 <tabaqui1> i have pure function, and fromJust inside it
10:58:05 <younder> grantwu: Agreed, but you have to see the whole picture
10:58:06 <tabaqui1> of course it failed with error
10:58:07 <thoughtpolice> dfeuer: But it's pretty new so unless you want to commit yourself to dealing with that, it's probably not worth it.
10:58:13 <shapr> younder: are you here to talk about Haskell?
10:58:20 <tabaqui1> which instruments i could use to inspect stack?
10:58:38 <shapr> younder: this channel is Haskell-centric
10:58:50 <EvanR> tabaqui1: fromJust strikes again
10:59:03 <dfeuer> thoughtpolice, so I'd be able to write one data declaration, and it would use different types depending on what type the package is parameterized over, or something? Would that mean having to break up containers into multiple packages?
10:59:13 <tabaqui1> EvanR: of course! how can i debug it?
10:59:21 <agocorona> use safeFromJust
10:59:28 <dolio> Oh, hmm.
10:59:32 <mizu_no_oto_work> younder: Haskell isn't trying to be provably bug-free.  You might check out e.g. Agda for work on that sort of thing.
10:59:32 <EvanR> do you have an argument for why it cant be Nothing ? if so, its wrong so debug that
10:59:34 <ongy> :t safeFromJust
10:59:36 <lambdabot> error: Variable not in scope: safeFromJust
10:59:43 <EvanR> if not, dont use fromJust
10:59:53 <agocorona> safeFromJust :: Maybe a -> Maybe a
10:59:54 <younder> You broght up security, I am a hetrogenous progammer, I code in 40 languages. Most importanly is how it all works together.
10:59:58 <EvanR> lol
11:00:02 <tabaqui1> i cannot skip it
11:00:08 <thoughtpolice> dfeuer: It's very analagous to ML signatures and modules, so you've got the right idea. No, you wouldn't have to split up your package. Containers can provide both a signature AND concrete implementations of the signature. Users choose what concrete implementation to instantiate the signature with.
11:00:12 <Cale> younder: Maybe you should try programming in fewer languages at a time
11:00:16 <Cale> :)
11:00:23 <thoughtpolice> You could also just have a package that has signatures, and no concrete implementations.
11:00:34 <tabaqui1> EvanR: it's not just incorrect input data
11:00:44 <thoughtpolice> Or just a package that's concrete instantiations of a signature in some other package.
11:00:48 <EvanR> tabaqui1: i was serious with my advice
11:00:49 <tabaqui1> EvanR: there is a bug in my problem and i want to find it
11:01:04 <Cale> younder: It is significantly easier to get everything to work together if you stick to a smaller number of languages, or at least have a coherent plan from the outset for how they'll work together.
11:01:14 <younder> Cale, I do one at a time. like all of you. But in linux we have a multiverse
11:01:16 <EvanR> apply your argument for why its not nothing to your code going backwards from where fromJust is used
11:01:18 <tabaqui1> EvanR: fine, i've used fromMaybe and refactor whole of my code to find a bug?
11:01:23 <EvanR> no
11:01:36 <dfeuer> thoughtpolice, could one package use both the Int32Map and Int64Map instantiations of containers? Would it end up recompiling Data.Sequence, Data.Map, etc., for both?
11:01:47 <dfeuer> I probably need to read this more.
11:02:02 <EvanR> though once you find the bug, you might end up having to refactor anyway
11:02:13 <EvanR> fromJust problems can be pretty nasty
11:02:19 <thoughtpolice> dfeuer: Yes. You can instantiate a single signature multiple times, even in a single module. The reason this is sound is because signature instantiations are named, but instances are not.
11:02:21 <mizu_no_oto_work> younder: Yes, untyped communication systems between components are commonly a cause of bugs, like with that one mars lander where one system was talking in metric and another in imperial.
11:02:21 <shapr> younder: perhaps the Haskell FFI would interest you?
11:02:34 <tabaqui1> EvanR: i know, but i cannot use print $ show here
11:02:48 <EvanR> tabaqui1: well, you can put a print in pure code with Debug.Trace
11:02:48 <shapr> younder: Or maybe servant, with its ability to produce both server and client code from a type?
11:02:51 <thoughtpolice> After all, if you instantiated a "Regex" signature with "String", and then did that again but with "ByteString" -- you'd technically have two regex implementations, after all. And they would have different types.
11:03:02 <tabaqui1> EvanR: oh, just what am i looking for
11:03:04 <tabaqui1> thanks
11:03:22 <younder> Cale, Agreed. I strick with Python, Common Lisp, C++, Haskell, and occasionaly some perl. These days. That's 5
11:03:25 <dfeuer> thoughtpolice, I'll have a look, but some folks will probably object to using such extensions....
11:03:47 <thoughtpolice> dfeuer: I do not believe you would need to recompile anything. It's more of a link time choice; when you program against a signature, it creates a "hole" which is later filled in by the particular instantiation choice.
11:03:54 <thoughtpolice> "link time"
11:03:57 <dolio> Yeah, I'm not sure if this is a near term solution.
11:04:02 <younder> Oh I forgot JavaScript so 6
11:04:12 <dfeuer> dolio, was that for me?
11:04:12 <mizu_no_oto_work> younder: which is a rather good argument for trying to write your components in a single language, so you can share code (with e.g. servant) to make communication more strongly typed
11:04:18 <thoughtpolice> And no, I wouldn't recommend shipping it to people. But it's probably a point in the design space worth exploring, at least.
11:04:20 <dolio> Especially for such a central library.
11:04:22 <dolio> dfeuer: Yeah.
11:04:42 <dfeuer> Yeah.... OTOH, trying to make this work with CPP feels very fragile.
11:04:45 <thoughtpolice> In time as we understand Backpack better, we'll see how to use it for these kinds of things.
11:05:00 <dolio> Yeah CPP seems like a bad idea.
11:05:03 <thoughtpolice> Because it very much changes up how we'd commonly structure a lot of things.
11:05:24 <younder> mizu_no_oto_work, But right now I am working on mathML 3.0 for a blink core (cromium browser) and they all write their caode in C++
11:05:28 <thoughtpolice> Containers -- or something like it -- is actually probably a very good test case for how such things might want to work.
11:05:52 <Cale> younder: At my work, it's pretty much all Haskell, with some bits of SQL, and to a much lesser extent, Javascript (we compile Haskell to Javascript and occasionally have to FFI to some JS library).
11:05:59 <mizu_no_oto_work> dfeuer: how much has to change between the Int32 and the Int64 other than the types?
11:06:02 <dfeuer> dolio, well, there currently *is* CPP around the word size stuff, but making that affect the types could be a bit tricky.
11:06:03 <Cale> Oh, and nix, if that counts.
11:06:24 <younder> Cale, Lucky you
11:06:45 <younder> I wish I could do all my work in Haskell too
11:07:17 <dfeuer> mizu_no_oto_work, well, IntMap is made of bitty operations, and some of those involve, e.g., finding highest set bits. So there's some.
11:07:39 <shapr> younder: It's certainly productive, what have you written in Haskell?
11:08:02 <Cale> It's pretty nice. For one of our clients, we've basically constructed a competitor to Slack, but with more features, with 7 developers and less than a year (we started in February, and our first beta users are coming on next week)
11:08:12 <dfeuer> In theory, we could use data families and genericky stuff, but again, a lot of people will object, and it could take a lot of work to get everything to specialize right.
11:08:26 <thoughtpolice> dfeuer: FWIW ezyang wrote a good tutorial on it here when you want to read it -- http://blog.ezyang.com/2016/10/try-backpack-ghc-backpack/
11:08:33 <thoughtpolice> It was merged into HEAD pretty recently.
11:08:42 <shapr> Cale: is that open source?
11:08:44 <dfeuer> Thanks, thoughtpolice.
11:08:46 <thoughtpolice> It should give you a pretty solid idea of what to expect.
11:09:00 <Cale> shapr: No, but the foundational parts of it are.
11:09:00 <younder> shapr,  the Formula compiler. But it hasn't been published (or completed) yet
11:09:15 <Cale> shapr: reflex and reflex-dom for example
11:09:25 <dolio> Yeah, a type family 'Map k' specialized to k might work, but that could almost be its own thing.
11:09:39 <dolio> And I don't think it would solve your code duplication problem (which is what backpack might solve).
11:09:42 <exio4> Cale: what was the previous Haskell experience of those developers?
11:09:54 <shapr> younder: what does it compile? I found six or seven compilers named "formula" in a google search.
11:10:10 <Cale> exio4: It varies widely. Everyone had *some* experience, but some are pretty new.
11:10:31 <thoughtpolice> Yeah, but that Cale guy is a pretty good ace in the hole.
11:10:37 <Cale> :D
11:10:37 <thoughtpolice> From what I've heard.
11:10:39 <Cale> hahaha
11:11:32 <Tuplanolla> Does Slack need a proprietary competitor?
11:11:42 <younder> I have a LOT to learn about  Haskell. It's mysteries of Category Theory sometimes defy me. I am a matheatician, but from before category theory  became so popular. I am struggeling to keep up
11:11:44 <Cale> But yeah, everyone on our team is a very good developer regardless.
11:12:06 <shapr> younder: you can be productive without learning category theory, but it is really fun.
11:12:29 <shapr> younder: are you reading one of the recently published Haskell books?
11:12:32 <Tuplanolla> I don't know if you're in charge, Cale, but that sounds a little strange.
11:12:45 <Cale> Tuplanolla: Well, we just build what our clients want.
11:12:51 <younder> shapr,  Ihave have read Real world Haskell
11:12:59 <Tuplanolla> Can't argue with that.
11:13:11 <Cale> Tuplanolla: But the emphasis here is more accountability for things that are discussed in chat. So it ties in with some task management stuff
11:13:25 <shapr> younder: I'm reading Haskell from first principles at the moment. Have you tried that one?
11:13:26 <bollu1> younder: which branch of math?
11:13:34 <Cale> and there are features like surveys and the ability to bundle sets of messages together and save and share those
11:13:52 <bollu1> Cale: every time I hear about obsidian, they seem so cool :) 
11:14:06 <Cale> which they hope to use to make it more of a persistent store of communication that can be relied on in the same way that people use email
11:14:22 <Cale> Oh, and it ties in with email, so you can send an email from chat, and the response will come back in-line
11:14:53 <younder> shapr,  I have also read  "the haskell road to mathematics programming and logic"
11:15:03 <shapr> oh, that one is COOL!
11:15:39 <exio4> Cale: I guess the project took its time at first, but now that everybody is quite comfortable with the code, it's much easier? 
11:16:34 <Cale> exio4: That's also pretty true... well, our clients had a lot of weird issues with designers. Things have been going *much* more smoothly after they fired the previous design team and got a new one.
11:16:53 <younder> shapr,  and that's about it. It's all about experiencing the language, now
11:17:01 <Cale> But also familiarity with reflex-dom has probably improved markedly.
11:18:18 <younder> sharpr: 'Haskell from first principles' no I havn't tried that one
11:18:50 <Tuplanolla> What branch of math did you work on, younder?
11:19:19 <Cale> http://www.cs.nott.ac.uk/~pszgmh/pih.html Graham Hutton's book also looks pretty good
11:19:55 * glguy is still patiently waiting for that book to arrive which was supposedly being released in September
11:19:57 <Cale> I haven't had a chance to read the new edition, but the old one was decent
11:20:17 <exio4> Cale: I like how that works, it's basically what I expected from a Haskell project :p
11:21:13 <younder> Tuplanolla, differential geometry
11:21:59 <younder> Tuplanolla, but lately more compuatioal logic
11:22:24 <younder> computational
11:22:46 <Cale> exio4: Most of the time, we've been keeping up with things -- it's only been toward the very end that the designers have finally gotten ahead of us. So it's been a lot of doing stuff that we know we'll want with a janky frontend (just to make sure the backend is in place), and then fixing it up when we get designs.
11:23:02 <Cale> exio4: It's much nicer if the design team is out in front of us.
11:23:45 <exio4> where do I need to sign up for getting a fun job like that? :P
11:23:52 <Cale> (I also think it's kind of crazy that they're still having to design things with like a week left to go before we'll be showing it to people, but such is life :)
11:24:52 <Cale> exio4: I don't know if we're hiring right now, but ryan.trinkle@obsidian.systems is the guy to talk to about it :)
11:25:04 <exio4> oh, nice
11:25:20 <Cale> exio4: Generally we want to expand, we just need to find enough new clients to give us work to hire people to do
11:25:21 <younder> Tuplanolla, I am having a lot of trouble with the book 'Categorial logic and type theory' those grobendick fibred categories have the best of me for now. Welll.. More work to be done
11:26:10 <Cale> exio4: and we also work with our clients to hire Haskell programmers to work directly for them
11:26:57 <exio4> Cale: I guess the issue might be that it is US-based
11:27:17 <younder> Tuplanolla, grothendick 
11:27:23 <vandenoever> turns out i dont want 'pure-zlib' either. it calls 'error' https://github.com/GaloisInc/pure-zlib/blob/master/src/Codec/Compression/Zlib.hs
11:27:24 <Cale> exio4: We do have a few people working remote (myself included)
11:27:26 <Tuplanolla> Grothendieck, younder.
11:27:54 <Cale> exio4: but depending on where, the meeting times might mess with your sleep schedule... :)
11:27:54 <younder> Tuplanolla, , Yes I find it impossible to spell, aparently
11:27:59 <shapr> me too!
11:28:03 <shapr> That G guy
11:28:23 <Tuplanolla> It's a bit tricky.
11:28:25 <exio4> Cale: ah, didn't know they hired remote! and I guess the meeting times will be just fine, I am on Argentina, UTC-3 :P 
11:28:46 <younder> Tuplanolla, I think of him as 'Biggus Dickus' ;)
11:29:43 <Cale> (and his name doesn't have an ö in it, oddly enough)
11:33:32 <Yobokies> hi
11:34:12 <sham1> hi
11:34:43 <Yobokies> can anyone show me how i can write the following code in a better way?
11:34:51 <Yobokies> check input = ((length input) == 26) && ((head input) == '#')
11:35:25 <Yobokies> suppose i have loads of && clauses
11:39:49 <Cale> Yobokies: Well, if you have lots of && clauses, it becomes nicer to use 'and', which takes a list of Bool values
11:40:05 <sbrg> Yobokies: if you have a lot of different functions all of which have the same type, you can put them all in a list, and then use `and` as suggested.
11:40:40 <sbrg> > and $ map ([1,2,3] $) [(\l -> length l == 26), (\l -> head l == 1)]
11:40:42 <lambdabot>  error:
11:40:42 <lambdabot>      • Couldn't match expected type ‘([Integer] -> Bool) -> Bool’
11:40:42 <lambdabot>                    with actual type ‘[Integer]’
11:41:32 <Cale> btw, you might consider something like:
11:42:00 <Cale> check ('#':xs) | length xs == 25 = True
11:42:05 <Cale> check _ = False
11:42:18 <Cale> or even putting the condition on the right of the = sign
11:42:37 <Cale> (what's best depends on what the conditions are, whether there would be other matching...)
11:42:53 <sbrg> > and $ map ($ [1,2,3]) [(\l -> length l == 26), (\l -> head l == 1)] -- this should work
11:42:55 <lambdabot>  False
11:42:59 <sbrg> and so it did
11:43:21 <Cale> and . map f  is the same as  all f
11:43:35 <Tuplanolla> That reminds me: is there a canonical `lengthBeyond :: Int -> [a] -> Bool`?
11:43:36 <sbrg> see, even better!
11:44:00 <Yobokies> anyone know how to remove all the "has joined #haskell" clutter so i can read the real messages :P?
11:44:12 <johnw> Yobokies: that all depends on your client
11:44:13 <Cale> Tuplanolla: no, but I usually test whether the list is empty or not after dropping n elements
11:44:16 <sbrg> Yobokies: depends on your client. most clients have some way of disabling it.
11:44:32 <Tuplanolla> That's a good way.
11:44:33 <johnw> Cale: that's a nice way
11:45:05 <et09> http://lpaste.net/1812530500183523328 i'm trying to piece together a TCP server which'll receive messages and then separate them into chunks based on a termination character (\x0D for reference).  i'm kind of stuck in "talk conn".  i took someone's advice in this channel to convert the socket into a stream, but then i'm wondering, does the commented out talk function (copy and pasted from 
11:45:11 <et09> Network.Socket.ByteString docs) block execution somehow?  
11:46:37 <et09> Stream.socketToStream in there 
11:47:15 <et09> this is a little advanced for me :-O
11:49:17 * ski has never bothered to strip away the join and part/quit messages
11:49:40 <EvanR> you look silly continuing to talk to someone who has disconnected ; )
11:49:48 <ski> that too
11:50:03 <amx> et09: I believe said someone was me, and yes, recv is blocking as you can see in the documentation for the module
11:50:27 <Tuplanolla> Pidgin has that solved: everyone who leaves gets italicized in the history.
11:51:03 <EvanR> it modifies history?
11:51:14 <Tuplanolla> Only for display.
11:51:16 <EvanR> oh the chat
11:51:19 <EvanR> interesting
11:53:05 <et09> oh i think i get it...so S.null means the peer closed the connection?
11:53:26 <et09> wow
11:54:02 <Mateon1> Hi, is there a generic "zipWith" for arbitrary amounts of arguments? AKA, ([a] -> b) -> [a] -> b
11:54:02 <Mateon1> Hoogle doesn't say so
11:54:08 <Mateon1> Sorry, I got something wrong
11:54:57 <EvanR> et09: more insight to recv, send, and general socketry can be found in the man pages
11:55:12 <et09> yeah i'm reading through Beej's guide 
11:55:12 <ski> Mateon1 : `([a] -> b) -> [[a]] -> [b]' ?
11:55:19 <Mateon1> I have an ([a] -> b) and want to turn some [[a]] -> [b]
11:55:26 <EvanR> i found man pages way more helpful than Beej
11:55:35 <et09> got it 
11:55:36 <Mateon1> ski: Yep
11:55:56 <ski> @type \f ass -> map f (transpose ass)
11:55:58 <lambdabot> ([a] -> b) -> [[a]] -> [b]
11:56:38 <ski> > map sum (transpose [[0,1,2],[3,4,5],[6,7,8]])
11:56:39 <Mateon1> Thanks
11:56:40 <lambdabot>  [9,12,15]
11:57:27 <ski> > getZipList ((\x y z -> x + y + z) <$> ZipList [0,1,2] <*> ZipList [3,4,5] <*> ZipList [6,7,8])
11:57:29 <lambdabot>  [9,12,15]
11:57:40 <ski> Mateon1 : ^ might be nicer, depending
11:57:45 <Mateon1> ZipList?
11:58:05 <Mateon1> Anyway, I am reading multiple files and need to compare token by token
11:58:31 <ski> > [x + y + z | x <- [0,1,2] | y <- [3,4,5] | z <- [6,7,8]]  -- parallel list comprehension, note multiple `|'s
11:58:33 <lambdabot>  [9,12,15]
11:59:10 <Mateon1> ski: Note that the last 2 suggestions have a set number of lists, I didn't know about parallel list comprehension though, so +1 for that
11:59:28 <ski> s/set/definite/
11:59:34 <ski> ok
12:00:14 <ski> > transpose [[0,1,2],[3,4,5],[6,7,8]]
12:00:17 <lambdabot>  [[0,3,6],[1,4,7],[2,5,8]]
12:00:29 <ski> > transpose [[0,1,2,4],[3,4,5],[6,7],[9],[]]
12:00:32 <lambdabot>  [[0,3,6,9],[1,4,7],[2,5],[4]]
12:01:07 <ski> > transpose [[],[0],[1,2],[3,4,5],[6,7,8,9]]
12:01:10 <lambdabot>  [[0,1,3,6],[2,4,7],[5,8],[9]]
12:01:26 <Mateon1> The files are expected to have same amount of tokens, so this won't be any issue
12:06:26 <et09> amx: so now my hesitation is how to mimic this behavior with io-streams
12:09:45 * hackagebot data-msgpack 0.0.6 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/data-msgpack-0.0.6 (iphydf)
12:11:05 <EvanR> et09: have done this sort of socket streaming processing with just regular recursion before
12:11:20 <et09> i was considering that too 
12:11:36 <et09> but the stream abstraction seems super nice AFAIK
12:11:46 <EvanR> in which case you might want to look at pipes or conduit
12:14:58 <EvanR> heh this is interesting
12:19:46 * hackagebot minisat-solver 0.1 - High-level Haskell bindings for the MiniSat SAT solver.  https://hackage.haskell.org/package/minisat-solver-0.1 (PeterSelinger)
12:21:14 <zariuq> buttbutter, we are here too :p 
12:22:02 <buttbutter> Haha
12:25:16 <johnw> are there any Haskell authors whose performance would benefit from a differently optimized version of the bytestring library?
12:26:32 <MichaelK> Hi, is it possible to find whether a template haskell expression typechecks? All I want is whether it typechecks, I don't want to use it for anything after.
12:26:58 <osa1> does anyone know why docs for this version of fgl did not appear yet: http://hackage.haskell.org/package/fgl-5.5.3.0 status says "docs pending"
12:27:25 <johnw> osa1: someone was just wondering about doc generation in #haskell-infrastructure
12:27:39 <MichaelK> osa1: there was (and probably still is) a bug in hackage where the docs don't render in the latest version. 
12:27:45 <osa1> :O
12:28:01 <MichaelK> (sometimes)
12:28:02 <osa1> MichaelK: you mean latest version of packages don't have docs?
12:28:30 <MichaelK> osa1: for a number of packages. last time I uploaded, I had to do some trick to reupload them so they'd show up
12:28:41 <MichaelK> but it was a while ago (some months)
12:31:54 <hopla> Hello all, I am going to generate random AST to test a compiler. Typical task is to take a random int and select a Expression from a simple ADT (like Binary BinOp Expr Expr | Prefix PrefxOp Expr | ...). Would you think there is a better way than just doing random 0 = ... then random 1 = ... In particular, I would like to make it robust when I add new Expression constructors. Not sure I am clear  :-) 
12:32:13 <MichaelK> hopla: are you using QuickCheck?
12:33:03 <MichaelK> then you can make an Arbitrary instances for the AST types and let it generate them for you
12:33:50 <hopla> MichaelK: I just googled it. I am not aware of it. I am reading it now.
12:35:31 <MichaelK> hopla: Let's say you have `Expr = Plus Expr Expr | Lit Integer`. You can do: `instance Arbitrary Expr where arbitrary = oneof [return Plus <*> arbitrary <*> arbitrary, return Lit <*> arbitrary]`
12:36:32 <shapr> QuickCheck is THE BEST
12:37:10 <hopla> MichaelK: OK. I am reading the hackage doc.
12:37:11 <MichaelK> hopla: Then testing evaluation would be you have something like `testExpr :: Expr -> Bool` and then `quickCheck testExpr` will do the generation and test case organization
12:37:35 <MichaelK> ok
12:38:17 <hopla> MichaelK: My case is a random program generator. I am testing robustness of the compiler against ICEs not correctness of the transformations. Just to explain a bit :-)
12:38:37 <MichaelK> hopla: so mostly making sure it doesn't crash?
12:41:02 <hopla> MichaelK: Yes. This is a compiler (unrelated to Haskell and written in C++). I am creating a Haskell program to produce random inputs (correct or not depending on what I want to test) and test robustness. Haskell is clearly a good choice for many obvious reasons. I was wondering how to have a robust and future proof ADT constructor selection.
12:41:50 <hopla> MichaelK: Basically, the choice must always be total (of course) but with no fallthrough so I do not forget to test something I just added.
12:42:13 <lispy> shapr: property based testing is awesome, but some of the other quickcheck clones have nice features. Like smartcheck.
12:42:22 <shapr> smallcheck
12:42:32 <MichaelK> hopla: cool. this should work well then. how are you throwing errors?
12:42:41 <lispy> shapr: https://hackage.haskell.org/package/smartcheck
12:43:18 <amx> et09: you already managed to get the two Streams. You can use the streams API now and do not need to mess with Network.Socket anymore
12:43:32 <hopla> MichaelK: no error. I just pretty print the program and run it externally from Python scripts. The Haskell program generator is just a standalone pretty-printing random programs.
12:43:40 <lispy> shapr: this is actually probably the interesting bit: https://github.com/leepike/SmartCheck#synopsis
12:43:56 <lispy> shapr: the short version is that it's much, well, smarter about finding minimal counter examples
12:46:17 <hopla> MichaelK: Thanks a lot for the advice. I am looking at quickcheck now.
12:47:42 <ski> lispy, interesting
12:50:22 <MichaelK> hopla: Ahh. Then you can use `sample' :: Gen a -> IO [a]` to generate a list of values. If you'd like a hand with the instances, I'd be happy to give you a hand since I'm working on a similar problem, but the language I'm generating is Haskell :p
12:55:06 <et09> ok so i'm reading the stream, i get that conceptually, this is lazily evaluated. i can theoretically map against the stream, as separated by some ascii value (\x0D) and fork off some IO for each segment, as they come in
12:55:17 <et09> but what does that look like? 
12:56:04 <hopla> MichaelK: The IO part is not particularly good for my case. But it looks like I can just use unGen and do a bit more on the extraction side. It looks quite cool.
12:56:09 <et09> not even a map really, more like a ruby .each .. i don't need the return value 
12:56:11 <et09> afaik
12:58:55 <MichaelK> hopla: why not the IO part?
13:02:16 <hopla> MichaelK: I am not sure TBH. I need to see what I want but since the language is C based and mix stmt / expression / declarations, I would need to maintain a bit of semantic while randomly interleaving stmt/expression stmt or declarations and maintain scoping. This smells a lot like I would need to have some MonadState somewhere so I can push/pop things (like variable) as I want. Having the IO in the middle of that is a bit crap.
13:03:08 <hopla> MichaelK: My initial take was to have an infinite list of random values generated upfront and then use it a more stateful computations. I don't think this is a problem with quickcheck anyway :-)
13:03:34 <MichaelK> hopla: have you looked at monad transformers? You can do stuff like add non-IO state to the IO monad like `StateT myState IO value`
13:03:57 <MichaelK> and if you want state without IO, you can do `StateT myState Identity`
13:04:10 <MichaelK> I hope I'm not making this overcomplicated
13:04:39 <grantwu> Can't you just use State
13:04:45 <hopla> MichaelK: I would just prefer to keep it simple, yes :-). QUickcheck looks just fine honestly and the IO part is super small. The rest looks quite interesting :-)
13:04:59 <MichaelK> though I'm not sure why you don't want to use IO when generating expressions, since it sounds like you'll be using IO to output the program anyway?
13:05:49 <hopla> MichaelK: I really just build a random AST. The final printing is a one-time shot at the end. 
13:07:53 <MichaelK> hopla: then IO just for generation shouldn't be a problem. you can use something like `do randomASTs <- sample' arbitrary; mapM_ myASTPrinter randomASTs`
13:08:31 <MichaelK> or more succinct: `sample' arbitrary >>= mapM_ myASTPrinter`
13:08:53 <hopla> MichaelK: yep, this is just perfect :-)
13:12:20 <hopla> MichaelK: Actually, I just saw Gen is a monad itself. So, I can build values depending on other values. Thanks for the help! It makes sense :-)
13:13:54 <EvanR> you dont need monads to build values depending on other values !
13:14:26 <MichaelK> hopla: cool. no problem :) also, that's what I was doing with my example. If you have `BinOp :: Expr -> Expr -> Expr`, you can do `return BinOp <*> arbitrary <*> arbitrary :: Gen Expr` to generate a BinOp with filled in arbitrary arguments
13:15:07 <hopla> EvanR: I can take the output of a first Gen to get another Gen. Like I generate random types and then random variables from that random types and then random expression using those variables. 
13:15:23 <EvanR> return BinOp <*> arb <*> arb = BinOp <$> arb <*> arb = LiftA2 BinOp arb arb
13:15:51 <MichaelK> EvanR: good catch
13:16:15 <EvanR> er liftA2
13:17:11 <MichaelK> EvanR: do you know why the Q monad doesn't have something like `qTypeOf :: ExpQ -> Either TypeError TypeQ`?
13:17:49 <MichaelK> I'm trying to quickCheck type families
13:19:03 <EvanR> you want to infer the type of an expression during TH ?
13:19:45 <MichaelK> I really just want to make sure it type checks
13:20:23 <MichaelK> or simpler, check that something like `Fam a ~ 'True => ()` typechecks
13:20:49 <EvanR> i image the type checking operation is :: ExpQ -> TypeQ -> Maybe TypeError
13:21:03 <EvanR> either way i dont know if TH can do this
13:21:17 <MichaelK> If I just make a DecQ, I don't think I can do stuff conditionally if it errors
13:24:51 * hackagebot http-pony-transformer-http 0.1.0.3 - Transform raw TCP stream to a basic HTTP type  https://hackage.haskell.org/package/http-pony-transformer-http-0.1.0.3 (JinjingWang)
13:24:53 * hackagebot hw-succinct 0.1.0.1 - Succint datastructures  https://hackage.haskell.org/package/hw-succinct-0.1.0.1 (haskellworks)
13:29:51 * hackagebot RNAlien 1.2.4 - Unsupervized construction of RNA family models  https://hackage.haskell.org/package/RNAlien-1.2.4 (FlorianEggenhofer)
13:30:36 <hopla> MichaelK: so, chaining random definitions of types and variables and statements but I may still need to use a StateT on top of Gen as you said to handle scoping rules (basically, updating the symbol table while opening / closing scope). It makes all sense. Using generate is not a problem by itself since it will happen only once to get the entire AST. Thanks for all!
13:31:04 <gleber_> https://github.com/tensorflow/haskell - Google just released Haskell bindings for TensorFlow
13:33:23 <MichaelK> hopla: no problem, I'm happy you're figuring it all out
13:35:42 <et09> what's the best way to create an empty bytestring
13:36:20 <osa1> et09: empty
13:39:09 <et09> ah
13:39:52 * hackagebot semdoc 0.1.0 - Evaluate code snippets in Literate Haskell.  https://hackage.haskell.org/package/semdoc-0.1.0 (iphydf)
13:41:30 <et09> http://lpaste.net/5013756787682181120 ok, if anyone wants to correct my 30 noob assumptions
13:43:21 <et09> the type signature stuff with monads makes me dizzy
13:46:09 <et09> (edited)
13:46:26 <glguy> et09: There isn't a ByteString typeclass
13:46:39 <glguy> or is there?
13:46:41 <et09> *gulp*
13:47:16 <monochrom> I missed that, haha
13:47:25 <glguy> iterateStream :: (ByteString a) => a -> a -> IO () ; should be ; iterateString :: ByteString -> ByteString -> IO (), most likely. GHC will tell you when you try to load that module
13:48:02 <glguy> (initial uncertainly due to not having inspected your imports for some non-standard source of such a typeclass)
13:48:48 <glguy> Consider: Num a => a -> ... and  Int -> ...
13:49:10 <glguy> In one case the argument's type is 'a' except not just any a, but one where the constraint Num a is satisfied
13:49:24 <glguy> Num a is a constraint, not the actual type of the argument
13:49:47 <glguy> and Int isn't a constraint, it's the type of machine-sized integer values
13:49:51 <et09> oh as in a class of types 
13:49:55 <glguy> so it similarly wouldn't make sense to put it on the left side of a =>
13:50:08 <et09> right
13:50:22 <et09> what is the typeclass(s) of ByteString
13:50:38 <koz_> et09: IsString, Show, Eq, I guess?
13:50:39 <et09> oh i see
13:50:42 <glguy> There are lots of typeclasses in general
13:50:42 <et09> right right
13:51:05 <glguy> This isn't like a class hierarchy in an OO language
13:51:08 <et09> my other concern was, can i actually operate on the stream like i'm doing? and if so, is it wise?
13:51:14 <et09> yeah i remember
13:51:45 <glguy> I don't know the System.IO.Streams module, so I can't speak to that
13:52:15 <monochrom> does the program seem to work for you? that's the first litmus test.
13:52:51 <et09> i'll check by having it dump out console output
13:52:57 <et09> output to console 
13:53:16 <Jet4Fire> Hello!
13:53:28 <lambdabot> Hello.
13:54:43 <et09> i get 'parse error on input 'iterateStream' for line 29 
13:55:07 <et09> oh indentation
13:55:51 <monochrom> an ounce of empirical test is worth a pound of philosophical dissertation
13:56:25 <glguy> Ugh, now I have to remember the number of ounces in a pound
13:56:32 <monochrom> 16
13:56:47 <et09> 6.51984723 × 10-5 m3 / kg
13:57:04 <glguy> OK, so philospohical dissertation doesn't have its own funny unit, that's good :)
13:57:10 <monochrom> I need to know because I go to steakhouses and I need to know what "12oz ribeye" means :)
13:57:55 <monochrom> well, also McDonald's and what "quarter pounder" means relative to "12oz ribeye"
13:58:38 <monochrom> so, you would also conclude that McDonald's doesn't use a funny unit? :)
13:58:55 <glguy> Perhaps it's the quarter pounder and not quarter *pound* so they can claim definition #2 in my dictionary: A person or thing that pounds something
13:59:11 <Tuplanolla> Is a quarter pounder not a coin press?
13:59:19 <monochrom> haha
14:00:29 <EvanR> youre all off topic. and fired
14:00:38 <et09> i did stack install io-streams, is that not enough to make runhaskell recognize it :-o
14:00:39 <glguy> You can't fire me; I quit.
14:01:09 <monochrom> runhaskell doesn't know what's in your sandbox. you need to use a certain stack command.
14:01:15 <glguy> et09: If you're stacking, you have to stack everything, did you prefix stack on your runhaskell invocation?
14:01:18 <monochrom> and I don't know which because I don't know stack.
14:02:13 <hvr> glguy: is "stacking" a new term you just coined? :)
14:02:19 <monochrom> we need less stack evangelism and more stack tech support.
14:02:44 <Clint> we need more libraries in stackage
14:03:12 <hvr> monochrom: there's also  #haskell-stack for premium stack tech support
14:03:25 * sm sees quite a bit of stack support now 
14:04:00 <Welkin> premium?
14:04:01 <Welkin> wtf?
14:04:32 <Welkin> I started using nix with cabal lately
14:04:38 <sm> deluxe support. They have carpets in the waiting room
14:04:44 <Welkin> used to use stack
14:05:00 <monochrom> I prefer tea and dessert to carpet in the waiting room.
14:05:21 <sm> no carpets in here! but also, less waiting
14:05:25 <maerwald> Clint: why?
14:05:28 <monochrom> I used to use cabal 0.16. Now I use cabal 1.24.
14:05:43 <Clint> maerwald: to lessen dependency hell
14:06:21 <maerwald> that's largely a myth stack users seems to keep telling
14:06:24 <johnw> It's a wonder that those who have visited cabal heaven never speak of it
14:06:28 <Clint> maerwald: i'm not a stack user
14:06:43 <et09> i thought i just read "Clint Mansell"
14:06:44 <hvr> johnw: it's a one way street, obviously
14:07:07 <sm> maerwald: that's not true, but I'm not going to argue with you
14:07:08 <hvr> or rather trip
14:07:30 <monochrom> Anyway, recently I did the following glorious evil experiment on packages. I made up a library "janos" with 2 versions, and a library "batman" to depend on janos (and I built it against the older janos).
14:07:58 <Welkin> zipper: habari
14:08:09 <monochrom> janos-1 contains C code "int getnum(void) { return 0; }" and the corresponding Haskell foreign import of it.
14:08:11 <maerwald> sm: can you build darcsden without stack?
14:08:17 <monochrom> janos-2 contains C code "int getnum(void) { return 1; }" and the corresponding Haskell foreign import of it.
14:08:23 <zipper> Welkin: haha mzuri sana
14:08:29 <zipper> Welkin: What a surprise
14:08:40 <monochrom> batman is only one version and simply re-exports janos-1's Haskell stuff.
14:08:49 <Welkin> zipper: I only know a few words :P
14:08:50 <maerwald> sm: answers: no. Which, imo, is an indication that projects that rely on stackage are in poor shape for everyone else.
14:08:50 <amx> et09: you must remember that you need to read from the Stream, not the ByteString. A ByteString is what you get for each read
14:09:01 <maerwald> the rest works perfectly fine
14:09:01 <kyren_> I'm using a function in a TH splice that in turn uses a foreign import, all of this is inside the same cabal package, and I get linker errors during compilation, is this expected and bad juju and I should just put the stuff using foreign imports in a separate package or am I doing something wrong
14:09:08 <et09> does InputStream wrap ByteString
14:09:10 <sm> maerwald: yes, of course you can. If the maintainer is any good, anyway
14:09:17 <zipper> Welkin: Still it's cool that you know words outside your lang.
14:09:17 <maerwald> sm: no, you can't. I tried.
14:09:30 <zipper> Welkin: Might you have been on a podcast lately?
14:09:36 <maerwald> and after 2 hours I gave up, because apparently no one is really testing it against latest hackage state
14:09:36 <Tuplanolla> How does this story end, monochrom?
14:09:37 <et09> http://lpaste.net/5013756787682181120 current code
14:09:38 <sm> are you basing your view of stack on one bitrotted package ?
14:09:43 <sm> darcsden is not maintained
14:09:50 <Welkin> zipper: nope
14:09:53 <monochrom> Now load both janos-2 and batman (which brings in janos-1) in GHCi, or write a program that imports both and ask ghc to compile and link (don't tell cabal-install, it's no fun). What will happen to getnum? :)
14:09:54 <johnw> is the jhc author here?
14:10:05 <maerwald> sm: I thought you're the maintainer? :o
14:10:07 <zipper> Welkin: Oh nvm ;)
14:10:20 <glguy> et09: Instead of guards on   something and not something, better to have guards on  something and otherwise
14:10:27 <Welkin> zipper: I like learning different languages though
14:10:38 <hvr> monochrom: a heisenberg  binary digit?
14:10:39 <glguy> monochrom: I'd expect them to collide
14:10:41 <monochrom> (cabal-install is no fun because it simply bans janos-2. But ghc doesn't)
14:10:49 <sm> maerwald: yes, and I'm doing a crappy job of it :)
14:10:50 <hvr> monochrom: erm.... s/heisenberg/schroedinger/
14:10:58 <glguy> monochrom: and to create a linker error, is that not the case?
14:11:00 <maerwald> my point is: whenever there is so-called "cabal hell", it's either because of bitrot or because people don't care about hackage
14:11:44 <sm> and I'm saying that's wrong. There are many other causes (less now than in the past)
14:11:44 <hvr> ...and I'd like to point out that if there's compilation error cabal hell.... ppl should inform hackage trustees!
14:11:55 <zipper> Welkin: There was a person with such qualities here https://www.functionalgeekery.com/episode-67-hardy-jones/
14:12:04 <sm> and you won't experience many of them unless you have used it over a long time or supported many different users of it
14:12:14 <maerwald> sm: I'm not trying to be offensive, but I think the convenience of stackage in packages like darcsden which have a huuge dependency tail, can lead to more bitrot than without stackage
14:12:18 <monochrom> I think when I did this experiment 10 years ago, there was a linker error when static linking (and ghc did not offer a dynamic story back then).
14:12:58 <monochrom> Today, there is no linker error, static or dynamic. ld does a silent arbitration. It's a binding arbitration, literally :)
14:12:59 <sm> maerwald: no problem, I can see that can be a contributing piece in the big hellish picture
14:13:13 <sm> but what you said seemed to oversimplify
14:13:17 <glguy> monochrom: Related to your story is the new "trick" of putting the definition of getnum in a header file and marked as "inline" and then use the CApiFFI extention to import it so that you get package-version specific name mangling
14:13:33 <sm> and put way too much blame on that one issue (and stack)
14:13:36 <monochrom> In the static case, ld chooses one version of getnum and impose it.
14:13:52 <maerwald> sm: oh, I usually start more dramatic than things actually are ;) 
14:14:09 <hvr> glguy: even better yet iirc: 'static inline'
14:14:27 <glguy> sounds right
14:14:41 <hvr> to make sure there's no exported symbol
14:14:45 <glguy> Probably more import that it's static than inline, actually
14:14:53 <hvr> yep
14:15:18 <hvr> I just need to remind myself what the gnu vs c99 pitfall was re inline semantics
14:15:54 <sm> maerwald: nice that you acknowledge it :)
14:16:15 <hvr> glguy: but you still want static inline, because capiffi generates a wrapper C function; so static inline removes any overhead you'd incur by capiff
14:16:32 <monochrom> the dynamic case though is really interesting.
14:17:25 <monochrom> (keep in mind dynamic linking leads to dynamic loading and both are loaded.) If you call C getnum directly, one version is chosen consistently.
14:18:05 <kyren_> when evaluating template haskell, does any code from the current module get executed interpreted?  I think I have a really poor idea of how this all works and why it's not working here
14:18:24 <monochrom> If you call C getnum indirectly, for example by going through the Haskell getnum proxy first, the choice is local, i.e., janos-1's Haskell getnum calls janos-1's C getnum, similarly for janos-2.
14:19:20 <monochrom> And so now "ghc -O0 -dynamic" vs "ghc -O1 -dynamic" is going to give you different results. Because -O0 tends to have indirect calls, -O1 tends to inline and call C getnum directly.
14:19:44 <Tuplanolla> I don't like this story.
14:20:41 <monochrom> let me post my package files so you can play with it
14:23:02 <monochrom> under http://www.vex.net/~trebla/tmp/janos/
14:23:30 <monochrom> On Windows, you still get the best result "linker error: too many getnum's"
14:23:58 <monochrom> but now linux's ld and GHC linux version (x86-64) are very very forgiving
14:24:54 * hackagebot semdoc 0.1.1 - Evaluate code snippets in Literate Haskell.  https://hackage.haskell.org/package/semdoc-0.1.1 (iphydf)
14:26:20 <heebo> i saw some haskell that baked my noodles recently, still dont understand , if i produce a gist can someone explain?
14:26:39 <lyxia> maybe
14:27:56 <fnurglewitz> fromJust lyxia
14:27:57 <lyxia> How do you bake noodles, is that good?
14:28:37 <heebo> it is very bad..... Im especially upset because i thought i knew haskell reasonably well
14:28:58 <lyxia> fnurglewitz: Variable not in scope: fromjust :: Maybe a -> t0
14:29:15 <lyxia> s/j/J
14:29:42 <Cale> heebo: Which code?
14:30:06 <heebo> Cale just looking for it now
14:32:32 <acowley> Firmware for a noodle baker, presumably
14:33:19 <Cale> acowley: Sounds like a scenario from Shenzhen I/O :)
14:33:31 <acowley> Mine's written in idris so the cooking method can depend on the particular noodles used rather than just the type of noodle.
14:33:33 <kyren_> sorry for asking again, my google fu is completely failing me, is there just a rule that you cannot use a foreign import function in template haskell in the same module?
14:34:13 <ongy> kyren_: you generally can't use functions from the same module in a splice
14:34:23 <kyren_> er, sorry! not module, package, said the wrong word
14:34:26 <acowley> kyren_: I was not aware of any FFI/TH restriction. TH has its staging thing, but I didn't think it impacted FFI.
14:34:28 <Cale> kyren_: There's a staging thing, where the things used in template Haskell splices have to come from above the splice.
14:34:59 <acowley> "staging thing" is now official jargon
14:35:10 <kyren_> I have some haskell that wraps xxhash written in C
14:35:17 <kyren_> in a separate module obviously, but the same package
14:35:35 <kyren_> later on, I use some template haskell that uses the xxhash functions
14:35:36 <Cale> haha
14:35:51 <kyren_> compiling results in a linker error
14:35:56 <acowley> Interesting, so GHC needs to run the FFI-using code and can't link it
14:35:57 <Cale> kyren_: hmmm
14:36:29 <ongy> kyren_: can you show us the linker error?
14:36:37 <kyren_> I have a VERY poor understanding of how all this works, so I would totally accept like.. don't do that.. as an answer
14:36:39 <kyren_> sure!
14:36:56 <acowley> It seems pretty plausible that this scenario would be tricky
14:37:22 <lyxia> I wonder what happens if you use a global IORef (obtained via unsafePerformIO) with template haskell
14:37:30 <lyxia> Is it reset for each module?
14:37:49 <kyren_> http://sprunge.us/cJJT
14:37:50 <lyxia> Does your computer launch missiles in your shed?
14:37:57 <acowley> depends on the color
14:37:59 <ongy> I hope the missiles launch
14:39:06 <kyren_> if I put the same code in another package that depends on it, works fine
14:39:54 <kyren_> it makes a kind of sense, because I can't (afaik) say to cabal, hey this .c file is associated with this .hs module, if you need the .hs module you also totally need this .c file as well
14:39:55 * hackagebot imm 1.1.0.0 - Execute arbitrary actions for each unread element of RSS/Atom feeds  https://hackage.haskell.org/package/imm-1.1.0.0 (koral)
14:40:10 <ongy> kyren_: I would guess it's a problem with GHC not linking the C library in in the TH linking
14:40:15 <kyren_> but maybe cabal compiles all the c files first?
14:40:19 <kyren_> yeah that's what I figured
14:40:33 <heebo> aha found it. tis but two short lines so forgive me
14:41:09 <heebo> forever a = let a' = a >> a' in a'
14:41:09 <heebo>  
14:41:15 <heebo> actually it is one line
14:41:33 <heebo> i mean really i dont understand why that compiles
14:42:10 <EvanR> why wouldnt it
14:42:27 <kyren_> forever a = (a >> a >> a >> a >> a >> ...)
14:42:31 <monochrom> it's a bit hard to explain why legal code is legal.
14:42:51 <EvanR> because its unillegal
14:43:12 <monochrom> It's like I have to go through the whole syntax and type system of Haskell with you first. And then I can prove that the code is legal and you have enough background to agree with the proof.
14:43:16 <acowley> illlegal?
14:44:06 <EvanR> its law of exluded middle, its legal of its not illegal
14:44:12 <heebo> its using the let binding in the body and result
14:44:13 <acowley> You can say something about how it can work operationally
14:44:29 <heebo> the excluded middle is dangerous
14:44:33 <kyren_> so this linker error, is this the kind of thing that deserves some kind of bug report, or should I put the xxhash functions in a separate package and go on with my life
14:44:35 <EvanR> let is recursive by default in haskell
14:44:40 <monochrom> I can do that. It will take 36 hours at the rate of cdn$60 per hour. I also accept 0.1 bitcoins per hour.
14:44:49 <acowley> kyren_: Both
14:44:59 <kyren_> nice answer
14:45:01 <EvanR> im not sure if there is an unrecursive let
14:45:04 <ongy> kyren_: I'd say both. Workaround for now, but report
14:45:08 <acowley> kyren_: Even if its not a bug, its usefuly to record the fact that you could have used more robust TH linking
14:45:27 <monochrom> recursion is legal in Haskell
14:45:30 <EvanR> > let ones = 1:ones in ones -- heebo 
14:45:33 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:45:34 <acowley> I apologize for the missing apostrophes there :(
14:45:43 <monochrom> or more precisely, self-references are legal in Haskell
14:46:02 <heebo> EvanR somehow thats easier to accept, im starting to grok
14:46:10 <monochrom> even "z = z+1" is legal. (it just isn't useful.)
14:46:23 <ReinH> But it can be!
14:46:24 <kyren_> this will be my first time reporting something on the ghc trac, I'm scared
14:46:37 <ReinH> it's useful with lazy natural numbers
14:47:16 <monochrom> "f = False && f" is also something you should play with
14:47:30 <kyren_> anyway, thank you for all your help
14:47:43 <heebo> hold on but a' is never passed nor defined
14:47:57 <EvanR> it is defined
14:48:05 <EvanR> by the let
14:48:30 <heebo> oh i see, sorry thinking aloud
14:49:03 <monochrom> you should use empirical observation to refute your mental model, not your mental model to refute empirical observation.
14:49:23 <monochrom> The empirical observation is that (forever (putStrLn "hello")) does something useful.
14:49:32 <EvanR> imagine trying to determine what a' is by successive approximation, start with the base case ⊥
14:49:41 <EvanR> which is the worst approximation of anything
14:49:45 <monochrom> it doesn't stop, but it still does something useful, and it doesn't just hang there.
14:49:53 <EvanR> a' = ⊥
14:50:03 <EvanR> plug that into the equation to get a better approximation
14:50:08 <EvanR> a' = a >> ⊥
14:50:10 <monochrom> So now all you need to do is to invent a mental model that agrees with the empirical observation.
14:50:16 <EvanR> plug that into the equation to get a better approximation
14:50:22 <heebo> non terminating, but haskell keeps trying thanks
14:50:22 <EvanR> a' = a >> a >> ⊥
14:50:23 <monochrom> As opposed to cherishing an old, obsolete mental model
14:50:35 <heebo> http://parametricity.net/b/2012/04/24/the-devil-of-the-excluded-middle/
14:50:58 <EvanR> the actual value is the limit of this exercise
14:51:18 <monochrom> why are you still worrying about the excluded middle?
14:51:31 <monochrom> as opposed to actually listening to EvanR's explanation?
14:52:31 <RouxTheDay_> Can anybody explain to me the magic of `sequence`? I know what it does, but I have no idea *how* it does it. Like if someone asked me to implement Sequence, I'd be at a complete loss, anybody have an explanation for how sequence works, or an example implementation of sequence?
14:52:57 <johnw> @src sequence
14:52:57 <lambdabot> sequence []     = return []
14:52:57 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:52:57 <lambdabot> --OR
14:52:59 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:53:00 <ReinH> :t sequence
14:53:02 <lambdabot> (Traversable t, Monad m) => t (m a) -> m (t a)
14:53:25 <johnw> the first definition is the most illuminating
14:53:28 <ReinH> :t traverse
14:53:30 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:55:10 <RouxTheDay_> Oh nice, it's not the generalized form that I was looking for but I think from that I can figure out the more general form, thanks!
14:55:23 <ReinH> :t traverse id
14:55:24 <lambdabot> (Traversable t, Applicative f) => t (f b) -> f (t b)
14:56:10 <heebo> EvanR can you use that technique for evaluating all values?
14:56:24 <EvanR> you can use that to figure out what any recursive definitions mean
14:56:25 <heebo> monochrom: I just remembered an old story about the excluded middle , thought it would be nice, I understood EvanR's explanatino
14:56:54 <RouxTheDay_> ReinH: Just making sure I understand here, is `traverse id` the same as `sequence`, but more general because all Monads are also Applicatives?
14:56:59 <EvanR> which comes up a lot in haskell
14:57:37 <ReinH> sequence has a monad constraint for historical reasons
14:57:40 <heebo> EvanR seems a lot like a newtonian method for finding fixed points
14:57:40 <ReinH> :t sequenceA
14:57:42 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
14:57:47 <EvanR> heebo: yep
14:58:10 <RouxTheDay_> Coool, thanks ReinH!
14:58:29 <EvanR> heebo: just like newton, the approximation may not actually get any better than ⊥
14:58:30 <ReinH> RouxTheDay_: you might ask yourself what else a function with that type *could* do
14:59:06 <RouxTheDay_> ReinH: You mean with the type of `sequence id`?
14:59:11 <RouxTheDay_> sorry
14:59:13 <RouxTheDay_> traverse id?
14:59:18 <ReinH> the type of traverse id or sequenceA, yes
14:59:46 <heebo> EvanR: I've just had a moment of programming clarity , thank you!
15:01:21 <heebo> EvanR: Given all FP collapses into one expression, all expression evaluation is some form of fixed point approximation. 
15:01:58 <EvanR> evaluation is another story
15:02:16 <EvanR> we were only expanding the definition, basically elaborating
15:03:31 <heebo> ok expression is some form of fixed point approximation, which isnt guaranteed to converge, as cited by Godel
15:04:12 <ReinH> Let's not throw Godel around carelessly
15:04:22 <heebo> lol
15:04:29 <heebo> .....that makes me sad
15:07:28 <novak`> How to browse source code of core libraries from Emacs? I want to see implementation of even function e.g.
15:08:02 <ReinH> You can browse the docs from hackage in eww or etc
15:10:24 <novak`> ReinH: No any more pleasant way? If I could browse by own libs simply with `M-.` why would browsing other libs be more complicated than that?
15:10:58 <grantwu> You would need to download the sources
15:11:39 <glguy> novak`: If you've installed the documentation locally and you're including syntax highlighted source in the documentation you've built, then you can browse it locally, too
15:11:47 <heebo> yes , it would be nice , perhaps some kind soul could upgrade haskell or intero to locate the source and browse.... not sure if its possible. Clojure allows this
15:12:14 <EvanR> well haddocks can be built locally for all installed packages
15:12:19 <EvanR> and that has source links
15:12:40 <EvanR> but i can see why you couldnt be arsed to leave your editor
15:13:21 <heebo> would be nice to hit a keybinding and have some doco appear in a buffer though :-/
15:13:32 <EvanR> i use :doc in idris a lot
15:15:19 <ReinH> I was restricting myself to things that work today, agree it would be nice to have.
15:16:21 <novak`> glguy: Yes, I could browse that source but I'm like used to browse code in my Editor. :D
15:17:42 <heebo> good weekend project and maybe not too difficult to implement
15:18:08 <heebo> brb
15:19:37 <monochrom> GHC does not retain source code after compilation. This is especially visible after you have built and installed a library. The library files have lost all the source code.
15:19:39 <epsilonhalbe> hey I have a question regarding stackage/stack: I will have to write a project at work but the setup is so that I have no access to the internet, I can pre-build a linux-vm to work on but I have to download "everything" in advance - is there a way to make an "offilne" copy of say stackage/lts-7.4 ?
15:20:10 <epsilonhalbe> and how big would that be?
15:20:47 <kadoban> epsilonhalbe: I think you'd want to look at the docker stuff in stack. There's docker containers you can get that have like, all of stackage I believe.
15:21:24 <epsilonhalbe> kadoban: you mean there is a docker image available with all of stackage pre-installed?
15:21:31 <epsilonhalbe> that would be great
15:21:47 <kadoban> I believe so, yeah. I haven't looked in quite a while, I don't really use the docker stuff.
15:22:01 <athan> Is there a way to use Win32 CPP macros to test if you're on a windows environment, in... windows only? :v
15:22:10 <athan> oh sorry, in a .cabal file
15:22:32 <athan> from what I see, testing if you're in Win32 forces the Win32 package dependency or something :s
15:23:34 <epsilonhalbe> kadoban: me neither - but this job has to be off line as there are sensitive customer data in the same sandbox where I am developing so no internet -
15:24:16 <kadoban> Ya. I mean you'll want to test it first I guess, but it should work.
15:32:33 <epsilonhalbe> kadoban: I have to get a clue how it works before that!
15:32:54 <epsilonhalbe> but thanks - I am off to bed - will investigate some more tomorrow
15:32:58 <kadoban> Heh, yeah. Good luck
15:44:59 * hackagebot irc-conduit 0.2.1.1 - Streaming IRC message library using conduits.  https://hackage.haskell.org/package/irc-conduit-0.2.1.1 (barrucadu)
15:46:18 <kadoban> I'm still trying to understand https://hackage.haskell.org/package/memoize-0.8.1/docs/Data-Function-Memoize.html . Does anyone know with the memoFix ones ... for every pattern of recursion, is that still going to be effective? If I memofix f x = f something + f somethingElse, etc., whatever weird patterns I can come up with, am I guaranteed that at most n calls will be made to f itself, if only that many unique x's are ever used? Or something close to 
15:46:20 <kadoban> that maybe?
15:47:36 <alx741_> guys, how could I list/know all the contents of a module; lets say: System, it has System.Hardware. How can I know all the modules System and System.Hardware contains? (Tried Hoogle with no success)
15:47:44 <lyxia> kadoban: That sounds about right
15:49:05 <glguy> alx741_: There's no way to know all of the modules that start with System. ; they are spread across many packages. Some packages can even define the same module (in different ways)
15:49:08 <kadoban> alx741_: You'd usually look in a particular package. So you'd look up what package contains the module(s) you're talking about, and there's an index for that package that lists all of the other modules (and what's in each)
15:49:20 <kadoban> Also that ^
15:51:07 <Cale> alx741_: modules don't contain other modules
15:52:00 <Cale> alx741_: However, they may re-export other modules. If you look at the haddock documentation, you'll see those listed...
15:52:08 <kadoban> lyxia: Okay, thanks. Now I just need to understand how.
15:52:27 <alx741_> I'm still messing up the packages and modules relations. Given the example System.Hardware.SerialPort, System would be a package, SerialPort a module, and what about Hardware?
15:52:27 <Cale> e.g. http://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Map.html re-exports the contents of Data.Map.Lazy
15:52:33 <Cale> (but not Data.Map.Strict)
15:53:44 <glguy> alx741_: No, the package appears to be "serialport" (given a quick Google search), the module is "System.Hardware.SerialPort"
15:54:10 <Cale> alx741_: '.' just happens to be a valid character in the name of a module
15:54:15 <glguy> alx741_: That particular package (serialport) only defines a single module, but any particular package can define zero or more modules
15:54:44 <Cale> alx741_: ghc will use those dots to help locate the .hs file for the module when building things, but apart from that, there's really no relationship
15:54:54 <Cale> Different packages can name their modules whatever
15:55:00 * hackagebot hw-xml 0.0.0.1 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-xml-0.0.0.1 (haskellworks)
15:55:02 * hackagebot lightning-haskell 0.1.0.2 - Haskell client for lightning-viz REST API  https://hackage.haskell.org/package/lightning-haskell-0.1.0.2 (cmoreside)
15:55:10 <Cale> and just because there's X.Y.Z, it doesn't mean that there must be an X or an X.Y
15:55:45 <Cale> (or that if they exist, that they have anything to do with X.Y.Z)
15:56:09 <alx741_> ooh! I thought there was some kind of hierarchy there
15:57:03 <alx741_> because of the dots
15:57:17 <alx741_> That's why I can't list the "contents" of System.Hardware, I was mistaken about that
15:57:48 <alx741_> Now it's clearer. Thanks guys!
16:00:00 * hackagebot glob-posix 0.1.0.0 - Haskell bindings for POSIX glob library.  https://hackage.haskell.org/package/glob-posix-0.1.0.0 (rdnetto)
16:00:02 <jppianta83> join #haskell-br
16:00:36 <Tuplanolla> Does `fgl` have functions to find the initial and terminal nodes of a graph?
16:04:06 <c_wraith> Tuplanolla, I'm not seeing anything about sources or sinks in its documentation 
16:04:52 <c_wraith> Tuplanolla, but it's pretty easy to do anyway.. if a node has no incoming edges, it's a source. if it has no outgoing edges, it's a sink. 
16:05:08 <Tuplanolla> Yes.
16:15:01 * hackagebot glob-posix 0.1.0.1 - Haskell bindings for POSIX glob library.  https://hackage.haskell.org/package/glob-posix-0.1.0.1 (rdnetto)
16:16:29 <Tuplanolla> This is probably the best way: `initial gr = filter ((== 0) . indeg gr) (nodes gr)`
16:16:53 <Tuplanolla> I don't know if I should call it `sources` though.
16:20:01 * hackagebot Grafos 0.1.0.0 - Grafos Haskell  https://hackage.haskell.org/package/Grafos-0.1.0.0 (jppianta83)
16:34:39 <EvanR> i ended up in a funny situation where fix is actually the right thing to use
16:37:51 <EvanR> to run a view, you need to provide it with a table, which is a function. to implement the function you need to be able to run views
16:41:47 <EvanR> you can accidentally code yourself into a knot that fix can untie
17:00:27 <eacameron> Hey quiet channel: I'm looking for a blog/talk that touches on how to speed up recursion by re-encoding it with...church encoding? I can't remember...which is probably why I can't find it. Does anyone have an idea of why my mind might be trying to remember?
17:00:45 <hiptobecubic> I used fixed for an iterative optimizer once. worked out pretty well
17:00:55 <hiptobecubic> fix*
17:02:06 <monochrom> No, I don't think church encoding speeds up recursion, or anything at all speeds up recursion.
17:02:06 <eacameron> *what my mind
17:02:06 <eacameron> hiptobecubic: That may have been it. I wasn't aware of recursion schemes when I saw the talk so I may have remembered incorrectly.
17:02:09 <eacameron> Is there a talk about doing that kind of transformation? Essentially encoding folds directly.
17:02:55 <monochrom> fix is still recursion itself rather than an encoding.
17:03:21 <monochrom> Overall I don't think what you have in mind exists.
17:03:32 <eacameron> monochrom: The use case was for short, finite loops where recursion is not the best representation from a performance perspective, at least as long as the compiler must actually perform recursion to achieve it.
17:04:51 <eacameron> I.e. I recall Gabriel Gonzalez encoding folds without recursion and for his use case it made a difference in speed
17:05:10 <monochrom> OK, then you can search his blog
17:05:32 <jle`> eacameron: the point of that was that manipulating functions was nicer when you have them in a non-recursive style
17:05:46 <jle`> so you can combine, sequence, etc. functions in a nicer way
17:06:24 <jle`> you represent your folds in a non-recursive way, and you can manipulate those folds in a nicer way than you could normally
17:06:36 <jle`> in the end, you still have to use recursion to "run" the folds
17:06:55 <jle`> but building them up, creating complex folds from simpler, primitive folds using fold combinators, was the advantage
17:07:37 <eacameron> jle`: Oh I see...that sounds about right. But I distinctly recall a discussion about performance...oh well. I think you're right anyhow.
17:07:51 <jle`> for example, it's not super easy to get 'sum' and 'sum . map (**2)' to run together on one traversal of a list
17:08:00 <eacameron> aha! yes.
17:08:01 <Axman6> monochrom: I reimplemented part of Bos' statistics library using foldl, and it is always faster than theboriginal code from Bos, with identical results
17:08:16 <Axman6> @hackage foldl-statistics
17:08:16 <lambdabot> http://hackage.haskell.org/package/foldl-statistics
17:08:21 <eacameron> That was the advantage. You can get fuse them easily without recursion.
17:08:29 <jle`> but if you had a non-recursive encoding of 'sum', then you can combine them to run together on one traversal
17:09:31 <jle`> i feel like if you wrote out the "combined" fold by hand, there shouldn't be any difference in performance
17:09:51 <jle`> but working with foldl lets you compose and combine complex folds from "primitive" simple folds in a neat way
17:10:20 <jle`> you could write out the single-traversal fold by hand, that is.  and it should probably have the same performance
17:10:25 <jle`> (if it doesn't, i'd be concerned)
17:10:31 <Axman6> lmap (**2) sum is the equivalent to sum . map (**2)
17:10:34 <jle`> but building the single-traversal fold by hand is not fun
17:10:46 <jle`> Axman6: lmap (map (**2)) sum
17:10:56 <Axman6> no
17:11:03 <jle`> unless you mean the first sum to be the foldl sum, and the second sum to be the prelude sum
17:11:10 <eacameron> jle`: Yes precisely. You're exactly right and that was the point. The performance gain only that you can maintain the best performance without sacrificing composition
17:11:15 <Axman6> lmap applies **2 to the input to sum
17:11:20 <Yobokies> how can i traverse through a list of numbers, add two to them and 'remember' the new list of numbers recursively?
17:11:20 <jle`> Axman6: yes, but
17:11:23 <jle`> :t lmap (**2) sum
17:11:26 <lambdabot> (Foldable t, Num c, Floating (t c)) => t c -> c
17:11:29 <jle`> ^
17:11:31 <jle`> it squares the list
17:11:33 <jle`> not the elements in the list
17:11:43 <Axman6> no...
17:11:50 <Axman6> rmap (**2) would do that
17:11:52 <jle`> > lmap (**2) sum [1..10]
17:11:56 <lambdabot>  error:
17:11:56 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M660713342379...
17:11:56 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
17:12:04 <Axman6> I'm talking about foldl's sum
17:12:09 <jle`> yeah
17:12:12 <Axman6> :t lmap
17:12:14 <lambdabot> Profunctor p => (a -> b) -> p b c -> p a c
17:12:31 <Axman6> it applies the function to each value passed into the fold
17:12:34 <jle`> yes, so, it's a bit confusing to use both foldl's sum and Prelude's sum in the same sentence
17:12:37 <jle`> without qualifying them :o
17:12:43 <Axman6> this is true :P
17:13:02 <jle`> if you're talking about foldl's sum, lmap (**2) sum is not sum . map (**2)   -- the latter doesn't typecheck
17:13:35 <Axman6> lmap (**2) F.sum ~= Prelude.sum . map (**2)
17:14:14 <Axman6> ANYWAY, the most awesome thing about folds is they compose horizontally using applicative
17:14:34 <eacameron> jle`: monochrom: Axman6: #haskell never disappoints. My memory has been revived. Thank you. Does anyone know a library that takes advantage of this? foldl?
17:14:41 <jle`> foldl is the canonical one yes
17:14:46 <Axman6> eacameron: yep
17:14:57 <jle`> but it only takes advantage of it for folds in the Foldable sense
17:15:06 <eacameron> jle`: Oh?
17:15:14 <jle`> not sure if there's a general one for a more general recursion-scheme sense of folds/catamorphisms
17:15:46 <jle`> yeah, foldl applies this stuff to the realm of stream processing
17:15:56 <jle`> so you can compose stream processors in a nice way
17:16:11 <jle`> but it's not a general composition-of-catamorphisms library
17:16:24 <Axman6> I'm not even sure what that would look like
17:16:36 <Axman6> how do you generalise maybe and foldr?
17:16:40 <eacameron> jle`: Oh I see...I barely grok catamorphisms anyway... :/
17:16:51 <Axman6> :t maybe
17:16:53 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:16:53 <jle`> it sounded like your original line of thinking was talking about this
17:16:54 <Axman6> :t foldr
17:16:55 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
17:16:56 <Axman6> :t bool
17:16:57 <lambdabot> a -> a -> Bool -> a
17:17:11 <jle`> eacameron: that's why i bring it up
17:17:12 <Axman6> these are all examples of catamorphisms
17:17:43 <Axman6> they have arguments corresponsing to each constructor
17:17:50 <eacameron> jle`: I'm learning about them now actually...so my mind is all garbled
17:18:20 <Axman6> bool False True = id, foldr (:) [] = id, maybe Just Nothing = id
17:18:24 <eacameron> Axman6: Interesting. Didn't realize that.
17:18:39 <Axman6> it's a pretty powerful idea =)
17:19:02 <eacameron> Axman6: so in each case you can pick an "algebra" for composition?
17:19:04 <jle`> your original question sounded like you were looking for a general way of representing recursive functions in a non-recursive way that can be useful for performance/manipulation ... in that sense, the foldl library only supports a limited slice of that general idea
17:19:14 <EvanR> interesting, floating point does have actual subtraction for a few different reasons. that is, "given x and z, produce a y such that x + y = z"
17:19:18 <EvanR> does NOT have
17:19:38 <EvanR> i was thinking there would be an interesting way to somehow satisfy this equation
17:19:44 <jle`> does it have actual addition, in any case?
17:19:56 <EvanR> i only got as far as defining actual subtraction
17:19:59 <jle`> by any sensible definition of addition? :P
17:20:11 <eacameron> jle`: You make a good point. That's a helpful distinction to know about. Thanks.
17:20:13 <EvanR> + above is float +
17:20:50 <jle`> you could enumerate over the entire float space
17:20:55 <jle`> and see if there's a y that satisfies it?
17:21:09 <jle`> shouldn't be too tricky on modern hardware
17:21:23 <EvanR> (it would be tricky due to the number of floats)
17:21:32 <EvanR> but we already know the answer is "no"
17:21:58 <EvanR> dont w?
17:22:09 <jle`> what, there are only ~4 billion of them? :p
17:22:14 <EvanR> Double
17:22:23 <jle`> oh thought you were talking about Float
17:22:47 <jle`> then yeah, that gets complicated
17:22:51 <EvanR> either way
17:23:00 <Axman6> just run it on two cores and you'll be sweet!
17:23:01 <Axman6> >_>
17:23:21 <jle`> <_<
17:23:33 <EvanR> (>_>) . (<_<) = id
17:23:36 <jle`> EvanR: yeah, there won't always be an y s.t. x + y = z
17:23:54 <mikeplus32> hm, why does template-haskell GadtC have a list of Name rather than just the one like NormalC?
17:23:55 <EvanR> thats so shitty!
17:24:24 <jle`> for example, x = Inf, z = 3
17:24:35 <EvanR> well, yes, but even for finite
17:24:41 <mikeplus32> i can only ever find one Name in the list given different looking GADTs
17:25:44 <EvanR> > 3 + (3 - 1e308)
17:25:46 <lambdabot>  -1.0e308
17:25:58 <EvanR> > 3 + (1e308 - 3)
17:26:00 <lambdabot>  1.0e308
17:26:08 <EvanR> wait
17:26:11 <Axman6> wut
17:26:29 <Axman6> Br4eaking News: Haskell solves all the problems of IEEE754
17:27:21 <EvanR> > 1e308 + (3 - 1e308)
17:27:23 <lambdabot>  0.0
17:27:25 <EvanR> ok
17:27:34 <EvanR> Axman6: i keep waiting
17:28:28 <EvanR> subtract two numbers very far apart, the answer is meaningless
17:28:37 <EvanR> subtract two numbers very close, the answer is meaningless
17:29:27 <EvanR> what they expect us to do
17:29:50 <Tuplanolla> Pose meaningless questions.
17:30:17 <Axman6> use KBN arithmetic
17:30:23 <Tuplanolla> Physicists are use floating-point numbers a lot. Maybe this tells us something about them.
17:33:01 <EvanR> Tuplanolla: about which, ill just assume both
17:33:02 <verement> Axman6: what is that?
17:35:06 * hackagebot ghcjs-dom-jsffi 0.5.0.1 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.5.0.1 (HamishMackenzie)
17:35:08 * hackagebot ghcjs-dom 0.5.0.1 - DOM library that supports both GHCJS and GHC  https://hackage.haskell.org/package/ghcjs-dom-0.5.0.1 (HamishMackenzie)
17:35:32 <MarcelineVQ> mikeplus32: data T a where T1,T2 :: a -> T a
17:36:07 <acowley> Wow, I didn't know that was valid
17:40:53 <Axman6> verement: https://en.wikipedia.org/wiki/Kahan_summation_algorithm
17:42:19 <Axman6> verement: basically when computing the sum (or other operations) you keep track of the error and at the end you add/subtract that from the result
17:42:50 <verement> Axman6: thanks
17:43:41 <Axman6> adds some overhead but can lead to much high precision
17:45:56 <MarcelineVQ> mikeplus32: to have a look at what that results in you can: runQ [d| data T a where T1,T2 :: a -> T a |]
17:52:44 <javjarfer> Anyone knows why if I have a function of this type: "liftS :: State B.ByteString a -> Parser a", and I use it inside a function with type "many :: Parser a -> Any", GHC automatically infers that "a" inside of liftS is of type "Parser Any"?
17:53:12 <Axman6> what is Any here?
17:53:37 <Axman6> and what's the type of the thing you're passing to liftS?
17:53:47 <javjarfer> Axman6, just any type no matter which one it is
17:54:27 <Axman6> so, if you have many (listS (undefined :: State ByteString Int)) it complains?
17:54:34 <Axman6> liftS*
17:55:49 <javjarfer> Axman6, I'm passing to "liftS" the function "get" from StateMonad
17:56:07 <javjarfer> Axman6, sorry about forgetting that
17:56:19 <Axman6> so something of type State ByteString ByteString?
17:56:49 <javjarfer> yes, but it infers that it's something of State ByteString (Parser Any)
17:57:01 <Axman6> that doesn't sound right
17:57:19 <javjarfer> no... not at all
17:58:34 <Axman6> can you share the code?
17:58:51 <javjarfer> of course, I'm going to paste it in a pastebin
17:58:53 <javjarfer> one second
17:59:12 <Axman6> @where lpaste
17:59:12 <lambdabot> http://lpaste.net/
18:03:35 <javjarfer> Axman6, omg... so late, sorry, I was missing a " ' " and I was calling the wrong function... 
18:04:48 <javjarfer> Axman6, then GHC was correctly inferring that a variable "p" should be a "Parsing a" because the use of this wrong function, sorry
18:05:29 <javjarfer> Axman6, time to bed, thanks you
18:22:06 <hello> need help for password cracker tool - > excel sheet is password lock 
18:22:21 <sbrg> wrong channel. good luck with that, though.
18:23:27 <lispy> I heard someone made a minecraft mod using ghcjvm
18:23:53 <lispy> I wonder if this will inspire a .NET backend for ghc as well
18:31:52 <Welkin> god no
18:35:16 <hellertime> any frequent users of the milena library on the channel tonight?
18:53:18 <ertes> is there a constraint that is never satisfied for which i can write a custom error message?
18:53:42 <ertes> like:  Error "You violated blah" :: Constraint
18:55:31 <glguy> ertes: Yes as of GHC 8
18:55:47 <glguy> ertes: http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-TypeLits.html#t:TypeError
18:56:19 <EvanR> double post this question: anyone know the "proper" way to end a gloss program, if any
18:56:21 <ertes> glguy: perfect! thanks
18:57:54 <ertes> EvanR: throw an exception, i guess
18:58:13 <ertes> using Graphics.Gloss.Interface.IO.*
18:58:17 <jle`> huh, ShowType :: k -> ErrorMessage
18:58:26 <glguy> EvanR: I think the answer is "Press ESC" :)
18:58:36 <jle`> bizarre
18:58:45 <EvanR> heh
18:58:57 <EvanR> ESC is disabled when you do playIO 
18:59:03 <glguy> Oh
18:59:15 <EvanR> do that you can use it for your own purposes
18:59:44 <ertes> yeah, you can't really exit gloss programmatically
19:00:12 <EvanR> i noticed that if the main thread ends but you started gloss in another thread, it gets into a borky state
19:00:12 <ertes> "you can't" is a common theme with loss
19:00:14 <ertes> *gloss
19:00:15 <EvanR> so thats out
19:00:37 <ertes> ah, now i know what "gloss" stands for:  generality loss
19:00:54 <EvanR> exitSuccess from the main thread kills everything...
19:01:00 <EvanR> for me at least
19:01:05 <ertes> EvanR: you can catch it
19:01:10 <EvanR> catch what?
19:01:17 <glguy> It looks like in my last gloss game I required the user to close the window to quit
19:01:20 <ertes> exitSuccess throws an exception
19:01:38 <EvanR> with playIO, the close button on the window is disabled! 
19:02:21 <EvanR> ertes: what would i do after catching it?
19:02:28 <glguy> That must have changed in the last few years; I'm pretty sure I've quit my game before :)
19:02:41 <EvanR> this is OSX dunno if that has anything to do with it
19:02:50 <EvanR> glguy: what did gloss tell you when the user pressed X
19:03:58 <glguy> You mean the window close  button?
19:04:17 <ertes> EvanR: catchJust … (playIO …) (\_ -> pure ())  -- only catch ExitSuccess, and just ignore it
19:04:18 <EvanR> yeah, did it just work
19:04:36 <EvanR> ertes: ... how would this help close the program ? lol
19:04:36 <glguy> I think it used to just close... I'm trying to get it updated to build again so I can see what happens
19:04:50 <ertes> EvanR: then you can throw the exception from within your game logic
19:05:03 <ertes> for example on a certain key event
19:05:54 <ertes> that's the only way i see to escape the gloss
19:06:27 <EvanR> so catch ExitSuccess that i threw myself, so i could throw it again
19:06:49 * EvanR wonders if that would loop
19:07:07 <ertes> it wouldn't, and if you're just going to throw it again, you might just as well not catch it =)
19:07:16 <EvanR> ... i know
19:07:46 <ertes> it might be better to just make your own exception type:  GameQuit
19:08:02 <ertes> playIO … `catch` (\GameQuit -> pure ())
19:08:16 <EvanR> let me try to throw a different exception from main thread and see if it has same effect
19:08:33 <ertes> (yes, i know those parentheses are redundant)
19:10:30 <EvanR> it prints to stderr before ending, when i throw userError
19:10:39 <EvanR> exitSuccess just ends without a message
19:10:42 <EvanR> so ill just use that
19:17:39 <glguy> EvanR: Pressing ESC exits for me still
19:19:05 <EvanR> with playIO ?
19:19:20 <glguy> Oh, I'm using "game"
19:19:28 <EvanR> doesnt work for me, which agrees with the docs
19:19:43 <glguy> OH, and Game uses playIO
19:20:30 <EvanR> i didnt notice the pure game api `play'
19:20:38 <EvanR> i wonder if i could use that
19:21:27 <glguy> Or just figure out how I got it to turn back on using the current version of gloss and playIO
19:22:02 <glguy> OH, I found it
19:22:05 <glguy>   | k == quitButton   = exitSuccess
19:22:16 <EvanR> alrighty
19:22:39 <glguy> I was searching for Esc at first
19:24:00 <glguy> Commit a35d9bdcd41f1a04cd269eaf063151fa3d55a779: "Add quit button now that gloss doesn't provide one" from November 2015
19:26:43 <EvanR> play is interesting for giving you no way to use IO
19:28:05 <EvanR> which would make sense as long as its a silent singleplayer game ;)
19:28:14 <EvanR> without the ability to save
19:29:39 <glguy> Doesn't have to be single-player as long as you're both at the same computer
19:29:57 <Welkin> civilization has a mode like that
19:30:04 <Welkin> where you can take turns for all the players
19:30:14 <Welkin> so you can play a game with many people on the same machine
19:30:48 <glguy> I made an implementation of the "Yinsh" game in Gloss that works for local multiplayer (there's a branch with networked multiplayer)
19:31:43 <EvanR> its hard to imagine a video game without sound though
19:31:52 <EvanR> the only one i can think of is chips challenge for windows
19:31:58 <glguy> http://imgur.com/a/gjJPX
19:32:13 <EvanR> looks interesting
19:33:35 <glguy> If you're curious https://github.com/glguy/Yinsh
19:33:47 <glguy> You can see my "sweet" token flipping animations :)
19:34:36 <glguy> The rules are pretty simple. The description of the game on BoardGameGeek covers it https://boardgamegeek.com/boardgame/7854/yinsh
19:40:29 <EvanR> pretty cool, i noticed the multiplayer ninja game before
19:44:50 <mikeplus32> anyone have luck with hsc2hs on ubuntu 16.10? https://wiki.ubuntu.com/SecurityTeam/PIE seems to break a lot including stack https://github.com/commercialhaskell/stack/issues/2712 (resolved)
20:10:15 * hackagebot vault-tool 0.0.0.1 - Client library for HashiCorp's Vault tool (via HTTP API)  https://hackage.haskell.org/package/vault-tool-0.0.0.1 (BitConnor)
20:12:44 <lilred> 41
20:15:15 * hackagebot vault-tool-server 0.0.0.1 - Utility library for spawning a HashiCorp Vault process  https://hackage.haskell.org/package/vault-tool-server-0.0.0.1 (BitConnor)
20:16:13 <grantwu> What is the difference between haskell.org and haskell-lang.org ?
20:17:28 <geekosaur> politics, apparently :/
20:18:06 <grantwu> -_- They don't even look that different
20:19:16 <c_wraith> haskell-lang was created by the commercial haskell group because they were unhappy with the non-commercial emphasis in the original
20:19:58 <jle`> oh and stack not being the first option on the downloads page
20:21:05 <jle`> it's the super awkward culmination of a long history of rising tension
20:22:03 <EvanR> non-commercial emphasis?
20:22:14 <EvanR> commercial non-emphasis?
20:24:35 <EvanR> non commercial-emphasis
20:26:48 <mjhoy> is anyone playing around with the cabal nix-like dependency management feature?
20:39:33 <neonfuz> Generally is it encouraged to use cabal for any haskell project?
20:39:46 * dmj` uses cabal
20:39:57 <EvanR> cabal is all i ever knew
20:40:17 * hackagebot postgresql-simple-opts 0.1.0.0 - An optparse-applicative parser for postgresql-simple's connection options  https://hackage.haskell.org/package/postgresql-simple-opts-0.1.0.0 (JonathanFischoff)
20:40:19 * hackagebot postgresql-simple-opts 0.1.0.1 - An optparse-applicative parser for postgresql-simple's connection options  https://hackage.haskell.org/package/postgresql-simple-opts-0.1.0.1 (JonathanFischoff)
20:40:45 <dmj`> neonfuz: cabal and nix go hand-in-hand
20:41:16 <cdsmith_> neonfuz: Depends on who is doing the encouraging?  I use cabal for everything, and it works fine for me.  Other people have a knack for running into its wrinkles...
20:42:16 <dmj`> neonfuz: also, try 'cabal new-build'
20:42:22 <cdsmith_> cabal new-build is also awesome.  I just tried that yesterday.  Haven't established the habits to feel comfortable yet, but it seems great.
20:42:33 <EvanR> i figured i would improve the accuracy of my time delta accumulator for accumulating the deltas coming from gloss, with kahan summation. but after converting from Float to Double, kahan does absolutely nothing
20:42:50 <EvanR> i.e. gloss has already mangled the accuracy for you
20:43:26 <EvanR> (why did it pick Float...?)
20:48:18 <jle`> neonfuz: i use stack for the most part
20:48:50 <neonfuz> also how do you guys pronounce cabal
20:48:58 <neonfuz> like kah-ball, or like cable
20:49:04 <MichaelK> is it possible to generate Haskell code containing TH brackets using TH?
20:49:08 <EvanR> like cabal
20:49:16 <jle`> neonfuz: like the english word
20:49:31 <neonfuz> is cabal an english word?
20:49:38 <jle`> it is :D
20:50:18 * hackagebot postgresql-simple-opts 0.1.0.2 - An optparse-applicative parser for postgresql-simple's connection options  https://hackage.haskell.org/package/postgresql-simple-opts-0.1.0.2 (JonathanFischoff)
20:50:23 <jle`> the english word probably influenced the choice of name
20:51:10 <neonfuz> k, yeah
20:51:14 <neonfuz> I see
20:53:18 <Welkin> cabal is a yiddish word
20:55:35 <neonfuz> jle`: so how is stack different than cabal, does it use cabal?
20:55:44 <johnw> it uses the Cabal library
20:55:56 <johnw> which is to be distinguished from the cabal-install CLI tool that also uses that library
20:56:00 <neonfuz> k
20:56:09 <johnw> both use the same backend, so to speak
20:56:21 <johnw> stack just adds managing of a local package store, project-local GHC, etc.
20:56:46 <fool> Hi
20:56:46 <johnw> after cabal-install's new-build support comes out, I imagine there will be much more overlap between the two feature sets
20:56:58 <EvanR> any reason why putStrLns from a single thread would appear on stdout out of order
20:57:13 <EvanR> in ghci
20:57:13 <fool> I'd like to hear your curried cauliflower recipes
21:00:20 <EvanR> and its the main thread!
21:01:47 <glguy> EvanR: Sounds fishy
21:01:57 <EvanR> indeed
21:03:06 <dmj`> EvanR: code or it didn't happen
21:03:51 <neonfuz> does nix-os work well with haskell development? does anyone here use it?
21:04:31 <dmj`> neonfuz: nixpkgs works well, yes
21:04:39 <johnw> neonfuz: extremely well
21:04:55 <johnw> but you have to invest
21:05:04 <neonfuz> I've been considering switching to nixos anyways, currenty I use gentoo
21:05:10 <EvanR> http://lpaste.net/300527
21:05:13 <johnw> should be a nice switch for you then
21:05:24 <neonfuz> apparently on gentoo they suggest you add the haskell overlay to portage and then to just use portage instead of cabal, but that sounds weird to me
21:05:37 <EvanR> ignore that paste... it could be explained in another way
21:05:40 <EvanR> fixing
21:05:40 <mjhoy> neonfuz: nixos is very cool, but it does take a bit of learning.
21:05:47 <johnw> neonfuz: I almost never interact with cabal
21:06:45 <EvanR> yep, its going in the other branch... might be whats happening
21:07:32 <EvanR> its interesting that the render callback in the "time passing" callback in gloss are randomly interleaved
21:07:49 <EvanR> and that*
21:08:01 <EvanR> i guess makes sense since you specify the rate of the time passing
21:13:56 <EvanR> note the self, randomly omitting some of the prints will make it look out of order
21:18:56 <orion> Are there any robust implementations of either consensus or gossip protocols in Haskell?
21:20:19 * hackagebot postgresql-simple-opts 0.1.0.3 - An optparse-applicative parser for postgresql-simple's connection options  https://hackage.haskell.org/package/postgresql-simple-opts-0.1.0.3 (JonathanFischoff)
21:20:21 * hackagebot postgresql-simple-opts 0.1.0.4 - An optparse-applicative parser for postgresql-simple's connection options  https://hackage.haskell.org/package/postgresql-simple-opts-0.1.0.4 (JonathanFischoff)
21:22:54 <Chobbes> neonfuz: the Haskell overlay is kind of a pain. It makes dependency resolution incredibly slow, and often there are conflicts.
21:23:55 <Chobbes> I use it for xmonad and the like, but stack / cabal for most anything else.
21:30:18 <buttons840> would something like MVar (Map a (MVar b)) ever make sense?
21:32:13 <Cale> Yes, though if it's all the same, MVar (Map a b) often does better anyway
21:34:39 <johnw> one thing that MVar (Map a (MVar b)) can do is that later, after the lookup, you could directly modify the MVar b
21:34:54 <johnw> think of it like a pointer into the value side of the map
21:36:17 <buttons840> john that's what I'm expecting, I'll rarely add new "keys" to the map, but will frequently update the values i'm working with
21:36:32 <buttons840> also, different parts of the code will be working with different keys and values
21:36:39 <johnw> now, you can still do something similar with closures
21:36:57 <johnw> instead of returning a 'b', return a pair of a 'b' and a function that, given a 'b', updates the map at that position
21:37:18 <johnw> (and also, now we're getting into lens territory)
21:42:39 <neonfuz> Chobbes: yeah, is it really necessary for xmonad?
21:44:11 <geekosaur> not necessary in the sense that it will break, but distribution installs know how to integrate it into distribution-installed display managers etc.
22:02:31 <neonfuz> alriht
22:02:34 <neonfuz> alright*
22:25:17 <Lokathor> so, i think what i want is, newtype Curses a = Curses (StateT CursesRecord IO a)
22:26:16 <Lokathor> does that look saneish?
22:30:31 <EvanR> well..... StateT record over IO  is really ReaderT record of IORefs (or non IORefs) over IO
22:31:27 <EvanR> allows more flexible access since we have IO available
22:32:09 <Lokathor> hmm, i had thought that you could just make a MonadIO instance and then people could liftIO the things they need
22:32:27 <EvanR> thats yet another thing
22:32:43 <EvanR> you have MonadIO either way
22:33:13 <Lokathor> well, the important elements i want to capture are: (1) Curses needs correct startup and shut down to happen, which should be done by the library not the user, (2) curses has some data it manages which should be handled automatically not by the user, (3) the user should be able to do their own IO if they want
22:33:56 <EvanR> so the user doesnt see how you do it, i was just remarking on the pros and cons of how you do it
22:33:56 <Lokathor> so for part 3, MonadIO and lifting seems to be the way to go
22:34:21 <EvanR> ReaderT record of IORefs to implement it can also be MonadIO
22:34:27 <Lokathor> hmm
22:34:35 <Lokathor> and what part is the advantage of the IORefs?
22:34:51 <EvanR> or MVars or TVars
22:34:54 <EvanR> or a mixture
22:35:06 <EvanR> or no vars, they could be constants
22:35:18 <Lokathor> I think if you're trying to display to the screen across more than one thread perhaps you need to have your head checked :P
22:35:24 * hackagebot amazonka 1.4.4.1 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.4.4.1 (BrendanHay)
22:35:25 <EvanR> youd be able to access them with the relevant support instead of having to do a record update
22:35:46 <EvanR> and ReaderT has less to implement than StateT
22:35:50 <EvanR> and might be more efficient
22:35:58 <Lokathor> well, but i don't know what "the relevant support" means
22:36:09 <EvanR> i mean the IORef api, MVar api
22:36:13 <Lokathor> oh
22:36:22 <Lokathor> like modifyIORef' and stuff
22:36:27 <EvanR> basically StateT doesnt have any advantage when its a transformer over IO
22:36:36 <EvanR> that i can see
22:37:47 <Lokathor> so, newtype Curses a = Curses (ReaderT (IORef CursesRecord) IO a)
22:38:06 <EvanR> the CursesRecord would contain the IORefs that are relevant
22:38:11 <EvanR> for fields you want to update
22:38:18 <Lokathor> ohhhh
22:39:03 <Lokathor> newtype Curses a = Curses (ReaderT CursesRecord IO a) ;; data CursesRecord = CursesRecord { screenSize :: IORef (Int,Int), ... }
22:39:06 <Lokathor> like that?
22:40:26 <EvanR> thats the ticket
22:40:44 <Lokathor> hmm
22:41:10 <EvanR> then you might not need any lenses to update fields
22:41:23 <Lokathor> and the IORefs work properly even in a reader?
22:41:29 <EvanR> they work in IO
22:41:41 <EvanR> remember IORefs are immutable! hehe
22:41:52 <EvanR> as are MVars and TVars
22:41:52 <jle`> Lokathor: Reader is not magic
22:42:00 <jle`> Lokathor: it's the same as passing an argument
22:42:12 <Lokathor> uh, hmm, i guess they're just like an address
22:42:13 <jle`> so you could just have type Curses = IO
22:42:22 <jle`> and use CursesRecords -> IO a
22:42:23 <Lokathor> and the memory at that address is what changes
22:42:39 <jle`> yeah, you could even pass it in as an explicit argument and it'd be the asme thing
22:42:44 <EvanR> address implies some space of locations... here they are really just object names
22:42:52 <EvanR> unique names
22:42:58 <Lokathor> i remember once having a problem of sorts because i had ended up with, i think it was TVar inside TVar, and then it got complicated
22:43:06 <Lokathor> and then the updates didn't actually update anything
22:43:29 <EvanR> yeah these names are critical to comprehending stuff like TVar in a TVar or MVar in a IORef
22:43:46 <EvanR> hmm.. or Ref A inside Ref B inside Ref C which is inside Ref A...
22:44:07 <Lokathor> I think what i had done was that I had a TVar in a TVar, and then i pulled out the inner TVar, updated it, and then didn't write it back to the outer layer
22:44:10 <EvanR> (that might not be possible)
22:44:12 <Lokathor> and then other threads didn't see the updates
22:44:33 <EvanR> that shouldnt matter
22:45:24 <Lokathor> i know that it conceptually shouldn't have mattered, but it didn't work, and i think it was bitemyapp and possibly even yourself who puzzled over it before i just rewrite it from scratch without nested TVars
22:45:37 <Lokathor> rewrote*
22:45:37 <EvanR> in fact if you updated the outer one, that might cause other people to not see updates to the previous inner one anymore
22:45:49 <EvanR> since they now see a different TVar
22:46:01 <Lokathor> well maybe that was the soruce of the bug
22:46:14 <Lokathor> don't nest your TVars, is what i learned
22:46:24 <EvanR> if they are looking at it through the outer one
22:47:27 <EvanR> for a language with a rich model of these "spots to put stuff" look at Monte
22:48:22 <Lokathor> jle`, i knew the reader ~ argument part
22:48:52 <Lokathor> what i wasn't sure on was if there was like, uh, "versions" of an IO ref that get passed along and shadow each other you might say
22:48:59 <Lokathor> and that the reader would get stuck with only the first version
22:49:05 <EvanR> its always the same IORef
22:49:26 <EvanR> unless you do like... its an IORef (Record of IORefs)
22:49:30 <EvanR> which ive seen people try
22:50:12 <Lokathor> "address implies some space of locations" is an interesting statement
22:50:36 <EvanR> yes the space is irrelevant so should be occams razored ;)
22:50:53 <EvanR> like worrying about the encoding of Chars in a String
22:51:06 <Lokathor> interesting viewpoint
22:51:29 <Lokathor> I dunno, to me, "it's always pointing to the same spot, you're just sometimes changing what's at the spot" is the simplest explanation
22:51:58 <Lokathor> but perhaps that's only the simplest to a Java/C style of thinking
22:51:58 <EvanR> i think "spot" has more going on than what it is, which is a mutable cell
22:52:03 <jle`> fwiw i think of it like a pointer in C
22:52:05 <EvanR> the cell is physically moving around
22:52:18 <EvanR> so "spot" is implying something you cant rely on
22:52:25 <Lokathor> ah, it is moving?
22:52:26 <EvanR> since theres no way for you to rely on it, you can safely believe in it
22:52:32 <EvanR> but i dont like that
22:52:52 <EvanR> also the physically moving around isnt something you can rely on either
22:52:55 <Cale> The spot is the IORef itself :)
22:53:06 <EvanR> so really, just dont even believe anything!
22:53:29 <EvanR> the address of a location that is moving around.... not usually how its taught in school ;)
22:53:43 <EvanR> but the earth does turn
22:53:43 <Lokathor> "A Discordian is Prohibited of Believing what he reads." -Pentabarf, Rule 5
22:54:27 <Lokathor> guys I'd love to continue this, but I have to go watch a movie with Jeff Goldblum, https://en.wikipedia.org/wiki/The_Adventures_of_Buckaroo_Banzai_Across_the_8th_Dimension
22:54:37 <EvanR> i heard hes quite friendly in person
22:54:43 <EvanR> tell him i said hello
22:55:02 <Lokathor> EvanR, this ReaderT of a record with IORef data in it is all very new, but i'll ponder it while at work tommorrow
22:56:26 <Cale> Why have a reader for a record of IORefs when you could have a reader for a record of actions which ultimately manipulate IORefs in various ways? :)
22:56:54 <EvanR> jle`: something funny about the C pointer analogy... there was a pretty bad bug in idris which caused values the runtime was working on to suddenly moving, since a given internal call could trigged the gc...
22:57:21 <EvanR> so i think whoever wrote that code had the same idea ;)
22:57:30 <jle`> :o
22:57:51 <EvanR> it exhibited as randomly caused an RNG to sometimes not be reproducible, sometimes not
22:58:31 <jle`> sounds like the best kind of bug
23:15:27 * hackagebot from-sum 0.1.2.0 - Canonical fromMaybeM and fromEitherM functions.  https://hackage.haskell.org/package/from-sum-0.1.2.0 (cdepillabout)
23:30:29 * hackagebot pandoc-citeproc 0.10.2 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.2 (JohnMacFarlane)
23:35:41 <cow_2001> So I have listened to Twobraids talk about a CSS for languages
23:35:54 <cow_2001> you guys have stylish-haskell
23:36:13 <cow_2001> python gots yapf
23:36:25 <cow_2001> golang has gofmt
23:36:30 <cow_2001> etc
23:36:57 <cow_2001> maaan they drop like flies
23:38:44 <orion> hmm
23:39:10 <MarcelineVQ> there's also hindent, stylish-haskell is less invasive iirc
23:40:21 <orion> So, Scotty defines a Monad called "ScottyM" in which you define the various routes for your application. I want to keep my routes for API version 1 in a separate source file than the routes for API version 2. Is this possible?
23:40:22 <cow_2001> so... what's the feasability of a css for x-langs?
23:40:34 <cow_2001> feasibility
23:41:43 <cow_2001> each user would have their own css for displaying, but the code repo would acxept only one css
23:42:32 <cow_2001> reject pull requests of failing style checked code
23:43:08 <cow_2001> eeeek
23:43:29 <liste_> orion: yes, it's possible
23:44:00 <liste_> orion: basically, you'd define version1 routes in one file, version2 routes in another, and then merge them in a third file
23:44:23 <orion> liste_: Would the merging process simply be: combined = version1 >> version2 ?
23:44:39 <liste_> orion: yes
23:44:49 <orion> Nice. I'm glad my intuition was right on that.
