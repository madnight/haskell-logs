00:00:56 <grantwu> Hrm, I may need to drop down to a single loop to get exponential backoff
00:01:57 <bollu> Cale: between the free monoad and coffee comonad, it is the pairing between functors that make it work, right?
00:02:05 <bollu> Cale: so in a sense, it's not 1-1
00:02:07 <bollu> Right?
00:02:13 <bollu> Between language to interpreter
00:02:18 <ab9rf> (Bean a) => Coffee a
00:03:06 <Cale> bollu: I have no idea what that's supposed to mean -- perhaps I'm missing some context in this conversation.
00:03:28 <bollu> Cale: oh. Right. Um, In the free DSL cofree interpreter pattern
00:03:33 <bollu> Cofree* 
00:03:56 <bollu> The pairing between the interpreter and the DSL is because of the Pairing type class we implement, right?
00:04:09 <bollu> So the pairing is not one-to-one between language and interpreter?
00:04:24 <bollu> So if I hand someone the interpreter, they can't "reverse-engineer" the language?
00:04:29 <Cale> huh? What type class?
00:05:12 <ReinH> Cale: http://dlaing.org/cofun/posts/free_and_cofree.html
00:05:13 <bollu> Pairing? 
00:05:27 <ReinH> class (Functor f, Functor g) => Pairing f g where
00:05:27 <ReinH>     pair :: (a -> b -> r) -> f a -> g b -> r
00:05:32 <Cale> Yeah, sorry, there's no way I could know which blog post you were reading :P
00:05:47 <ReinH> Luckily I was around the last time this came up.
00:05:49 <bollu> Cale: ah :) I thought it was part of the general theory, sorry 
00:06:22 <ReinH> Cale: The Pairing class comes from Dan Piponi iirc
00:06:25 <bollu> ReinH yeah, so the pairing is not unique right? So if I hand the interpreter to someone they can't reverse engineer the language? 
00:07:41 <srhb> grantwu: Ergh, apparently I disconnected from my irc bouncer, but you got the operator wrong. it's sec - last_sec < 5
00:07:47 <srhb> (If you wanted to print Hello World every 5 seconds)
00:08:30 <srhb> imo it's much clearer to do this kind of thing verbosely with recursion.
00:08:48 <grantwu> srhb: Yeah, I already fixed it
00:08:51 <srhb> OK :)
00:09:01 <grantwu> Urgh
00:09:20 <grantwu> I pulled in wreq.  ghc-mod told stack to start building it in the background.  I OOM'd.
00:10:23 <bollu_> ReinH: sorry, DCs
00:10:23 <EvanR> if it werent for the infinite-memory-surpression conspiracy
00:10:27 <bollu_> DCd *
00:10:36 <bollu_> Yeah, so, is it right to say the the pairing isn't one one?
00:10:51 <bollu_> And that inverting an interpreter to re derive the language is "hard"?
00:10:54 <EvanR> the ram cartel 
00:10:55 <grantwu> Is there a way to tell ghc-mod not to randomly build things in the background?
00:11:19 <Cale> Well, there's always "turn off ghc-mod" :)
00:12:07 <ReinH> I think a pairing between f and g is some form of adjunction
00:12:46 <bollu_> Really? Hm, does that aid you in reversing?
00:13:23 <bollu_> Like, is there an algorithm to derive the other side of the adjunction?
00:13:29 <ReinH> If f is left-adjoint to g, I think you get a pairing from g to f for free.
00:13:38 <bollu_> Hm, I see. 
00:13:38 <Cale> hmm
00:13:47 <ReinH> But I don't think the pairing uniquely specifies either side
00:14:18 <bollu_> ReinH: how do I verify the fact?
00:14:29 <bollu_> Like, I want to prove that it's not I verticals for an idea I have
00:14:36 <bollu_> Invertible*
00:15:00 <ReinH> Oh, there it is in an older version of adjunctions http://hackage.haskell.org/package/adjunctions-0.6.0/docs/src/Data-Functor-Zap.html#zapAdjunction
00:15:08 <ReinH> Seems to require strength
00:15:24 <bollu_> What's strength? 
00:15:27 <ReinH> I don't know how you would prove that.
00:15:37 <ReinH> It's on that page
00:15:45 <bollu_> I see. Thank you
00:15:51 <bollu_> Uh, it's some categorical condition?
00:15:57 <Cale> It seems like you're pretty stuck if you don't have strength
00:16:02 <ReinH> Yes, that you get for free in Haskell
00:17:11 <bollu_> Wait, if you don't have strength you can't write he pairing? 
00:17:32 <bollu_> Or it's that it is not invertible if it has strength? 
00:17:37 <Cale> I'm pretty sure -- at least, it's not obvious to me at all how to proceed without it
00:17:41 <bollu_> Internet speed is way too slow to load web pages >_<  
00:18:34 * hackagebot fay-simplejson 0.1.3.0 - SimpleJSON library for Fay.  https://hackage.haskell.org/package/fay-simplejson-0.1.3.0 (Lupino)
00:19:54 <ReinH> If you don't have strength, you can't derive a pairing from an adjunction.
00:20:13 <bollu_> I see
00:20:21 <ReinH> At least, there's no obvious way to do so
00:20:21 <bollu_> But do I need an adjunction to have a pairing?
00:20:38 <ReinH> I don't think I've seen one yet that isn't
00:20:41 <bollu_> Like, can 2 functors be part of a pairing without an adjunction?
00:20:44 <bollu_> I see, damn 
00:20:53 <ReinH> But that shouldn't be taken to constitute a proof
00:21:09 <bollu_> Hm, so that means that the DSL and the Interpreter functors are adjoint?
00:21:11 <ReinH> Or rather, I haven't seen a pairing between two functors that are not adjoint
00:21:20 <bollu_> Okay, but, adjoints are not unique, right?
00:21:23 <ReinH> But that doesn't mean there isn't one
00:21:28 <bollu_> Right, ofc 
00:21:28 <Cale> Well, what are the laws for the pairing to satisfy?
00:21:48 <bollu_> Are pairings unique? Which reduced to are adjoints unique?
00:22:12 <Cale> If there are no laws, then any two copointed functors will have a pairing
00:22:15 <ReinH> Adjunctions are unique up to unique isomomrphism
00:22:25 <bollu_> Ahh fuck
00:22:39 <ReinH> Again, I'm not sure that this says anything about pairings
00:22:44 <bollu_> Hm, so an interpreter will always have a unique language? 
00:22:47 <bollu_> Hm, I see 
00:22:57 <Cale> and functors having multiple points will not have unique pairings
00:23:24 <ReinH> Perhaps it just says that the most obvious pairings are between adjoint functors
00:23:24 <Cale> er, multiple copoints :)
00:23:39 <bollu_> Okay, now, like, is there a process that will let me derive the other pair of the adjunction? Like, given a f, can you always get a g that is left / right adjoints to it if you know that it exists?
00:23:43 <bollu_> Constructive process?
00:24:01 <Cale> I don't think there's an obvious way in general
00:24:30 <bollu> Cool, but can I make a hardness proof?
00:24:34 <EvanR> cryptographic category theory, hide half your adjunction
00:24:36 <Cale> Perhaps
00:24:43 <bollu> Yes that's what I want to do 
00:24:50 <bollu> I want to use this for homomorphic encryption 
00:25:06 <bollu> EvanR: too crazy? :)
00:25:08 <Cale> Start by noticing that you can encode pretty general optimisation questions in the form of asking for an adjoint
00:25:09 <EvanR> "one way adjunction"
00:25:14 <ReinH> The only way I know to construct an adjunction is when given a monad
00:25:44 <bollu> Hm, that would be by using kleisli? 
00:25:52 <bollu> Cale: go on please :)
00:26:16 <Cale> There are two adjunctions that each monad arises from: the Kleisli one and the T-algebras one.
00:26:30 <Cale> (The Eilenberg-Moore one?)
00:26:33 <bollu> Cale: ellenberg Moore? 
00:26:40 <bollu> Elinberg* ah 
00:26:50 <bollu> Right, okay 
00:26:52 <ReinH> There are two constructions.
00:26:59 <ReinH> Oh, Cale said it
00:27:00 <bollu> So how does this relate to optimisation? 
00:27:42 <bollu> Hm, can you guys tell me what to read exactly to try and construct of non invertibility of this adjunction?
00:27:46 <ReinH> (Yes, given by the Kleisli category and the Eilenberg-Moore category)
00:28:07 <ReinH> How do you know you're talking about an adjunction?
00:28:12 <ReinH> I thought you were just talking about a pairing.
00:28:30 <bollu> ReinH: yes, but I think the DSL and the interpreter functors are
00:28:38 <bollu> Adjoint to each other * 
00:28:40 <bollu> I'm not sure
00:28:45 <bollu> Okay, assuming it's just a pairing?
00:28:48 <Cale> bollu: Well, you can work out the details -- take some ordered sets, consider them as categories, and figure out what an adjunction means there
00:29:15 <bollu> What's an ordered set? 
00:29:53 <Cale> So a set X together with some relation <= which is at least reflexive and transitive, but if you like it can also be antisymmetric and total.
00:30:06 <bollu> Ah, I see 
00:30:43 <Cale> You can turn such a thing into a category where there's a unique arrow x -> y whenever x <= y
00:30:57 <bollu> Cale: so it's somewhat like poset?
00:31:09 <Cale> A poset is an example of what I mean
00:31:15 <bollu> Ah, okay 
00:31:37 <Cale> A preorder at least
00:31:40 <bollu> Hm, okay. I'll try this. 
00:31:51 <Cale> But maybe it helps to start with totally ordered sets like the real numbers
00:32:59 <bollu> Cale: why that category in specific?
00:33:09 <bollu> and you want me to create a pairing and see if it is invertible? 
00:33:21 <Cale> I'm not talking about pairings, just adjunctions
00:33:35 <Cale> What is an endofunctor on the real numbers (as an ordered category)? Well, it's some function f such that whenever x <= y, so that there is an arrow x -> y, there needs to be an arrow f(x) -> f(y), so we'd better have f(x) <= f(y)
00:33:56 <Cale> So functors are monotone functions -- what does it mean to have an adjunction?
00:35:02 <Cale> Suppose we have some function g: R -> R, then asking whether it has a left adjoint is asking whether we can find some f such that whenever x <= g(y), we'll have f(x) <= y
00:35:07 <bollu> It means that we are able to take (a -> f b) -> g a -> b? I'm more familiar with the two natural transformations version to identities 
00:35:11 <Cale> (and vice versa)
00:35:20 <bollu> Right 
00:36:21 <bollu> I can't see an obvious way to do this directly, is there? Just given f? 
00:37:02 <grantwu> argh, the library that does what I want has no docs
00:37:16 <Cale> grantwu: Which library?
00:37:30 <grantwu> geojson
00:37:41 <bollu> Cale: is there?
00:37:59 <Cale> https://hackage.haskell.org/package/geojson-1.3.0
00:39:13 <Cale> bollu: Well, given f, it's the other way around, whenever f(x) is bounded above by y, we want to choose g(y) such that it's bounded below by x (and in such a way that the resulting function is monotone)
00:43:23 <Hijiri> Cale: does it require axiom of choice?
00:43:35 <Cale> Maybe in some cases
00:43:53 <Cale> But in general, depending on what f is, perhaps not.
00:45:04 <jle`> 1;0c/b 30
00:45:26 <bollu> Cale: yes but the choice isn't unique right?
00:47:51 <Cale> bollu: Well, if a functor has two right (or left) adjoints, those are naturally isomorphic
00:48:42 <Cale> So there's something going on here to make the choice a bit difficult :)
00:51:11 <Cale> (but yeah, that's not quite uniqueness)
00:51:51 <Cale> Er, actually
00:53:34 <Cale> What does that mean here? Our left adjoints are monotone maps R -> R, and so for each x in R, there must be an isomorphism F(x) -> F'(x), which will have an inverse F'(x) -> F(x)
00:53:36 * hackagebot persistent-relational-record 0.1.0.0 - relational-record on persisten backends.  https://hackage.haskell.org/package/persistent-relational-record-0.1.0.0 (TakahiroHimura)
00:53:56 <Cale> So we'll have both F(x) <= F'(x) and F'(x) <= F(x), and so F(x) = F'(x)
00:54:14 <Cale> So it's real uniqueness in this case
00:54:52 <Cale> (because the ordering on the reals is antisymmetric)
00:57:14 <Cale> If I recall correctly, thinking a bit about what f needs to be (given g) or vice versa, an optimisation problem of sorts (minimising or maximising the values of the given function over a certain domain) falls out.
00:59:16 <bollu> Cale: ah 
01:06:02 <grantwu> How can I find a stackage lts snapshot that contains a particular version of a package?
01:08:09 <grantwu> I really should've used Python for this ;-;
01:12:04 <EvanR> lets really hope "shoulda used python" doesnt become a haskell meme
01:12:25 <grantwu> haha
01:12:32 <grantwu> Let's start it!
01:12:39 <EvanR> that would be deeply troubling
01:13:11 <grantwu> Do you have 10 stackage tabs open, searching for the latest snapshot that lets you use vector==0.10.* ?
01:13:17 <grantwu> Shoulda used python
01:13:46 <kadoban> grantwu: Why not just 'stack init' based on your .cabal file?
01:14:12 <grantwu> hrm, does that do what I want
01:14:23 <kadoban> Maybe
01:14:53 <grantwu> I thought that was for taking an existing package and making it work with stack
01:15:20 <kadoban> It attempts to build a stack.yaml consistent with an existing package
01:15:48 <kadoban> So it should usually give you a snapshot that is consistent with the version bounds you've picked.
01:16:20 <grantwu> well, what I did was note that stack solver always seemed to fail with vector
01:16:40 <grantwu> so I manually found the latest snapshot that had vector==0.10.* then ran "stack solver --update-config"
01:17:30 <grantwu> And I ended up needing to add more extra-deps
01:18:14 <kadoban> Ya, maybe init wasn't helpful advice for your case then
01:18:32 <grantwu> One thing I was kind of confused about was
01:18:37 * hackagebot haskdogs 0.4.5 - Generate tags file for Haskell project and its nearest deps  https://hackage.haskell.org/package/haskdogs-0.4.5 (SergeyMironov)
01:18:44 <grantwu> I wasn't sure what lower bounds to put for the other packages I was using
01:19:06 <grantwu> What I ended up doing was decrementing all the most significant version number
01:19:13 <grantwu> But... I'm not sure that's what I wanted
01:20:30 <slack1256> any standard setup for testing compatibility with different combination of versions on libraries?
01:20:45 <slack1256> or should I compile on each setup myself?
01:22:51 <grantwu> Urgh - there doesn't seem to be any breaking changes in vector-0.11.0.0
01:23:09 <grantwu> It is rather obnoxious that the package specifies a dependency on the 0.10.* series
01:38:32 <ashishnegi> hi.. what does it mean that "types doesn't unify" ?
01:39:26 <jle`> ashishnegi: unification is the process of picking potential values for type variables so that two type expressions become equivalent
01:39:38 <jle`> ashishnegi: for example, [a] and [Char] unify when you set a ~ Char
01:40:01 <jle`> (Int, Maybe a) and (Int, b) unifiy when you set b ~ Maybe a, for any a
01:40:02 <ashishnegi> so.. it helps in "type inference" ?
01:40:10 <jle`> it's actually a part of type inference, yes
01:40:18 <ashishnegi> cool.. thanks
01:40:23 <jle`> when types don't unify, it means that there isn't any possible value of type variables you can pick so that the two types are eqivalent
01:40:33 <jle`> for example, (Int, a) and [Char] won't unify
01:40:36 <jle`> no matter what you pick for 'a'
01:40:48 <jle`> try out values of 'a', like Bool, String, Char, Double, etc.
01:41:00 <jle`> you won't find any value of 'a' that would make (Int, a) and [Char] be the same
02:33:07 <pokalyis> Vyn 
02:33:21 <Vyn> @let b n = 2 ^ (floor $ logBase 2 (fromInteger n))
02:33:22 <lambdabot>  Defined.
02:33:30 <Vyn> map b [1..15]
02:33:33 <Vyn> > map b [1..15]
02:33:34 <lambdabot>  error:
02:33:35 <lambdabot>      Ambiguous occurrence ‘b’
02:33:35 <lambdabot>      It could refer to either ‘Debug.SimpleReflect.b’,
02:33:41 <Vyn> Just a sec
02:33:43 <Vyn> @undef
02:33:43 <lambdabot> Undefined.
02:33:58 <Vyn> @let bbb n = 2 ^ (floor $ logBase 2 (fromInteger n))
02:34:00 <lambdabot>  Defined.
02:34:03 <Vyn> > map bbb [1..15]
02:34:05 <lambdabot>  [1,2,2,4,4,4,4,8,8,8,8,8,8,8,8]
02:34:18 <Vyn> pokalyis: Okay, this function "rounds down" to the nearest power of 2
02:34:29 <Vyn> Now
02:35:18 <Vyn> @let ratPair n = (1 + 2 * (mod n $ b n), 2 * b n)
02:35:19 <lambdabot>  .L.hs:160:31: error:
02:35:19 <lambdabot>      • Couldn't match expected type ‘t1 -> t1’ with actual type ‘Expr’
02:35:19 <lambdabot>      • The function ‘b’ is applied to one argument,
02:35:28 <Vyn> @let ratPair n = (1 + 2 * (mod n $ bbb n), 2 * bbb n)
02:35:30 <lambdabot>  Defined.
02:35:31 <Vyn> Right
02:35:41 <Vyn> > ratPair [1..15]
02:35:43 <lambdabot>  error:
02:35:43 <lambdabot>      • Couldn't match expected type ‘Integer’
02:35:43 <lambdabot>                    with actual type ‘[Integer]’
02:35:49 <Vyn> Gaah
02:36:24 <Vyn> Hold on
02:36:33 <Vyn> > [(1 + 2 * (mod n $ bbb n), 2 * bbb n) | n <- [1..15]]
02:36:35 <pokalyis> Vyn Use map? 
02:36:36 <lambdabot>  [(1,2),(1,4),(3,4),(1,8),(3,8),(5,8),(7,8),(1,16),(3,16),(5,16),(7,16),(9,16...
02:36:44 <Vyn> Oh yeah, forgot map >.<
02:37:23 <Vyn> pokalyis: There! Those are the numerators and denominators of the sequence we want. I didn't divide just to make it obvious
02:37:35 <Vyn> pokalyis: So actually the sequence we want is
02:38:51 <Vyn> obtained by dividing those
02:39:18 <pokalyis> Vyn Interesting, i'll see if I can replicate it on paper and then in != Haskell.
02:39:23 <pokalyis> Thanks! 
02:40:29 <Vyn> pokalyis: Was interesting
02:40:47 <Vyn> pokalyis: If we divide those, we get: [0.5,0.25,0.75,0.125,0.375,0.625,0.875,6.25e-2,0.1875,0.3125,0.4375,0.5625,0.6875,0.8125,0.9375]
02:40:52 <Vyn> Which is exactly what we want
02:41:13 <pokalyis> That looks correct
02:42:02 <pokalyis> Hehe, looking at my notes I must say I was close
02:44:00 <Vyn> Yeah, and I'm surprised I didn't get it sooner. Somehow I wasn't looking at it properly before, though I already had the basic idea
03:06:35 <Adluc_> Hello, what is most sane way to convert Decimal –> Double? Solution I came up with looks terrible : fromRational $ toRational (Decimal 0 100)
03:12:25 <jmorris> is there a way i can do this (https://github.com/joshua-morris/cryptopals/blob/master/set1/HexToBase64.hs) so that it returns a string not a Data.ByteString.Internal.ByteString
03:13:33 <srhb> Adluc_: Seems fine to me. If you want to do something more sane mathematically, you'll have to pattern match and do it yourself.
03:14:13 <Adluc> srhb: Thanks :)
03:19:12 <brbblnch> hi
03:20:40 <brbblnch> I'm trying to use the "ReadP" parser and have a grammar with a piece of the form "Term ::= Term …", so I did something along the lines of `parseTerm = do x <- parseTerm …` but now I just figured out why my computer didn't like that very much; I believe it starts a loop. 
03:21:49 <brbblnch> so, I don't really recall the best way to avoid that. I could rewrite the grammar so that Term doesn't start with itself
03:30:29 <Forlorn> Hi, how can I do pattern matching in ghci?
03:30:30 <Forlorn> like
03:30:31 <jle`> brbblnch: yup, this problem is about left-recursive grammars, and is actually a general parser problem bigger than just ReadP/Haskell parsers
03:30:46 <Forlorn> `let f 1 = 2; f 0 = 0;` ?
03:31:15 <jle`> brbblnch: if you google "left recursion parsing" you'll get a couple general solutions for rewriting your grammar to accomodate this :)
03:31:21 <jle`> Forlorn: what happens when you try?
03:31:38 <jle`> Forlorn: it seems to work for me
03:33:06 <Forlorn> jle`, oh, it works, I made a beginner mistake
03:33:17 <Forlorn> let f x = ...; f 0 = 0;
03:33:33 <Forlorn> the last pattern match will be redundant.
03:33:37 <jle`> yup, '...' is not allowed
03:33:41 <jle`> oh, yeah, that too
03:34:15 <Forlorn> `...` is just my notation for the code
03:34:25 <Forlorn> that is irrelevant atm
03:35:10 <Forlorn>  /* i.e */ if (a) { /* ... */ } else { /* ... */ }
03:35:31 <jle`> ah yeah, just thought i was looking for a syntax error and i didn't see any in your code
03:36:19 <jle`> so i thought that if that code gave you errors, it'd have to be from "..."
03:36:48 <recurss> [recursion-schemes] [Show1] Hi, I can't show my Fix AST values anymore due to recursion-schemes change: https://github.com/ekmett/recursion-schemes/commit/206a8368fcd271ff7942a64f135b8c8782aa2739
03:37:01 <recurss> anyone knows how to autogenerate Show1 instances?
03:37:14 <recurss> Could not deduce (Data.Functor.Classes.Show1 AST)
03:40:59 <jle`> fwiw i've always written mine by hand
03:42:23 <recurss> but in the past I just did data AST t = ... deriving (.. Show ..) and everything just works
03:42:30 <jle`> recurss: actually, if AST has a Show instance, you can write one with a small amount of boilerplate
03:42:33 <recurss> seems like a downgrade?
03:42:54 <recurss> aha, cool. any example?
03:43:17 <jle`> you might be able to get away with show1 = show, etc.
03:43:43 <jle`> if AST isn't a fancy GADT
03:43:47 <recurss> aha, will try. thanks!
03:44:41 <jle`> if that doesn't work, upload AST's definition (or a simplified version) and we might be able to help use the auto-derived Show instance to give you an easy Show1 instance
03:45:10 <LordBrain> is there a target date for a new haskell standard?
03:45:22 <recurss> thanks a lot jle!
03:46:22 <LordBrain> target decade really
03:47:39 <lpaste> bollu pasted “continuation-existential-question” at http://lpaste.net/316009
03:47:52 <jle`> LordBrain: i wouldn't hold my breath.  the common status quo consensus is that a new standard isn't useful or necessary
03:48:04 <jle`> s/useful/helpful
03:48:05 <LordBrain> oh thats interesting in itself
03:48:08 <bollu> quick question on existentials:http://lpaste.net/316009
03:48:17 <bollu> why does my definition of the (|>) on Cont not work?
03:48:37 <bollu> I think it is because the "r" is hidden inside the Cont, I cannot assume the "r" that _I_ want in the instantiation of |>
03:48:39 <bollu> correct?
03:49:00 <jle`> bollu: yes, the ((a -> r) -> r) inside 'Cont' is a single specific 'r'
03:49:05 <jle`> like, Int or Bool
03:49:20 <jle`> bollu: but the type signature of (|>) implies that the user can pick whatever 'r' they want
03:49:26 <bollu> jle`: no, it doesn't right? my GADT does not expose which one it is? so it is existential?
03:49:32 <bollu> oh, okay
03:49:47 <bollu> you're saying that it can be _anything_ like Int or Bool, and it'll still be an instance of Cont a?
03:49:48 <jle`> bollu: yes, if you have a value of "Cont a", it has an ((a -> Something) -> Something inside
03:49:57 <bollu> I see
03:50:16 <jle`> and every value of Cont a has a single specific concrete/actual type there, for Something
03:50:22 <bollu> I see
03:50:33 <bollu> and I cannot observe it because the GADT hides it
03:50:45 <bollu> hm
03:50:51 <jle`> yeah, it's not in the type parameter
03:51:07 <jle`> but, maybe you want (forall r. (a -> r) -> r) instead
03:51:13 <jle`> that might be what you wanted in the first place
03:51:16 <brbblnch> jle`: Yeah, I recall it being a problem, but thought that using a parser that wasn't just "1 look ahead" or something it would work
03:51:22 <bollu> jle`: okay, one more question: in a GADT, is a type that is in the constructor but not in the final "concrete" type that is created  is always existential?
03:51:37 <bollu> like, if I have a -> b -> c -> d -> .. Something a
03:51:37 <jle`> a (forall r. (a -> r) -> r) can be instantiated as any 'r' in the future
03:51:43 <bollu> will b, c, d, .. always be existential?
03:51:45 <bollu> jle`: ohh
03:51:52 <jle`> yes
03:51:59 <bollu> jle`: so that is Rank2 right?
03:52:05 <bollu> wow, Rank2 != existential?
03:52:07 <jle`> yes, that's a Rank2 type
03:52:16 <jle`> rank2 types can be used to implement existential types
03:52:18 <jle`> but they're different things
03:52:22 <bollu> I see
03:52:32 <jle`> you could even write that in non-gadt form
03:52:38 <bollu> jle`: do tell
03:52:44 <jle`> data Cont a = Cont (forall a. (a -> r) -> r)
03:53:02 <jle`> because (forall a. (a -> r) -> r) is just a normal type of any normal expression
03:53:10 <jle`> s/any/a
03:53:17 <brbblnch> jle`: If the parser wasn't like ll(1), it would work, yes?
03:53:43 * hackagebot casr-logbook-html 0.0.3 - CASR 61.345 Pilot Personal Logbook HTML output  https://hackage.haskell.org/package/casr-logbook-html-0.0.3 (TonyMorris)
03:53:47 <bollu> ah
03:53:48 <bollu> hm
03:54:01 <bollu> why is the forall a. inside the constructor?
03:54:04 <jle`> brbblnch: i'm not sure of the specifics.  but for something like ReadP, if your grammar is left recursive, you'll never find a base case for your recursion
03:54:15 <brbblnch> mmh, that's bad
03:54:18 <jle`> bollu: it's a part of the type of the value inside
03:54:32 <jle`> it's not a special property of the constructor
03:54:41 <brbblnch> I chose ReadP because it seemed easier (more like what I was used to) than parsec or things like that
03:54:47 <jle`> it's just that the constructor has a value of type (forall r. (a -> r) -> r)
03:55:07 <jle`> brbblnch: you're going to have problems with left-recursive grammars than parsec and libraries like that too, remember
03:55:13 <bollu> jle`: oh okay. Is this not valid syntax: data Cont a = forall a. Cont ((a -> r) -> r)
03:55:26 <jle`> bollu: that's something else
03:55:36 <bollu> jle`: yes, so can you tell me the difference?
03:55:37 <jle`> you probably meant forall r. Cont ((a -> r) -> r) though, right?
03:55:57 <jle`> yeah, forall r. Cont ((a -> r) -> r) means that Cont holds a value of type ((a -> r) -> r) for a specific r
03:56:28 <jle`> but Cont (forall r. (a -> r) -> r) just means that Cont holds a value of type (forall r. (a -> r) -> r)
03:56:33 <bollu> jle`: why is it a specific r? 
03:56:39 <jle`> just like 'Cont a' means that Cont holds a value of type 'a'
03:56:47 <jle`> bollu: that's just the syntax
03:56:53 <bollu> jle`: I see. 
03:56:53 <jle`> there is no deeper "why"
03:56:56 <jle`> that's what it means :)
03:56:59 <brbblnch> jle`: Ok, I don't remember, but I can't just rewrite the "presentation" of my grammar, while still maintaining it, and being able to parse it normally ,right?
03:57:03 <bollu> jle`: so shouldn't it be called exists r. ...
03:57:07 <nevere> Is there a Haskell code formatter that work?
03:57:15 <bollu> jle`: data Cont a = exists r. Cont ((a -> r) -> r)?
03:57:24 <bollu> like, forall is a strange thing to call it, no?
03:57:26 <jle`> bollu: that's an arguable position
03:57:30 <bollu> jle`: go on
03:57:31 <jle`> i'm on your side
03:57:46 <bollu> jle`: is there anyway to make sense of the syntax?
03:57:48 <jle`> or well, that actually would make more sense as Cont (exists r. (a -> r) -> r), too
03:57:55 <nevere> I tried hindent, but it breaks for some source files..
03:57:59 <bollu> jle`: because I have a feeling that the next time I see this I'll be as confused
03:58:05 <jle`> bollu: having "forall" as the syntax there is arbitrary, yes.
03:58:15 <jle`> i'm not the hugest fan of that arbitrary keyword choice
03:58:26 <jle`> brbblnch: i'm not sure :O i don't know too much about this
03:58:32 <bollu> jle`: I see. so there's no mathematical meaning of it?
03:58:37 <jle`> bollu: but, 'forall' can make sense under a specific interpretation
03:58:41 <brbblnch> jle`: Ok, thanks!
03:58:42 <jle`> where you pattern match against Cont
03:59:04 <jle`> if you pattern match on 'Cont', then you have to handle it in a way that works "for all" r
03:59:16 <bollu> jle`: ah
03:59:28 <jle`> er, maybe that's why people say forall?  i'm not sure
03:59:34 <bollu> jle`: so it's "hidden from you" which one it actually is just like the GADT syntax?
03:59:35 <jle`> i guess you can say that Cont also works "for all" r
03:59:40 <bollu> I see
03:59:49 <jle`> the constructor Cont works for all r, i guess?  idk
03:59:54 <jle`> i think it's an awkward keyword too
04:00:00 <jle`> that's just the haskell we have
04:00:01 <brbblnch> jle`: Isn't the "forall" similar to what System F has?
04:00:53 <jle`> hm i'm not sure of the direct comparison, i don't have too much epxerience w/ system f
04:02:07 <nevere> How can I get stack install to install the latest version of a program. I am trying to install the latest version of hindent.
04:02:11 <jle`> bollu: but yeah, you can think of Cont (forall r. (a -> r) -> r) as just normal non-special constructors that contain values of RankN types, but forall r. Cont ((a -> r) -> r) as special syntax for existential constructors
04:02:22 <bollu> I see
04:02:24 <bollu> thank you
04:02:31 <bollu> I keep getting confused with it though
04:02:38 <bollu> okay, lemme go play around :)
04:02:39 <jle`> bollu: because (forall r. (a -> r) -> r) is actually a common type for your average normal run-of-the-mill values
04:03:07 <jle`> @let imNormal :: forall r. (Int -> r) -> r; imNormal = ($ 10)
04:03:08 <lambdabot>  Defined.
04:03:13 <jle`> > imNormal show
04:03:15 <lambdabot>  "10"
04:03:25 <jle`> so Cont imNormal :: Cont Int
04:03:40 <jle`> (assuming Cont (forall r. (a -> r) -> r))
04:04:08 <jle`> imNormal's type isn't even RankN
04:04:13 <bollu> hm right
04:04:17 <jle`> well, it's RankN for n = 0, heh
04:04:20 <jle`> *1
04:14:36 <Vyn> bollu: I finally got the formula
04:15:02 <Vyn> @undef
04:15:02 <lambdabot> Undefined.
04:15:04 <Vyn> @let bbb n = 2 ^ (floor $ logBase 2 (fromInteger n))
04:15:05 <lambdabot>  Defined.
04:15:19 <Vyn> > [(1 + 2 * (mod n $ bbb n), 2 * bbb n) | n <- [1..15]]
04:15:21 <lambdabot>  [(1,2),(1,4),(3,4),(1,8),(3,8),(5,8),(7,8),(1,16),(3,16),(5,16),(7,16),(9,16...
04:15:34 <Vyn> bollu: Those are the pairs representing the required fractions
04:15:42 <bollu> how did you even arrive that ? -_^
04:15:47 <bollu> must have been quite an adventure
04:16:07 <Vyn> Just listed the terms and the pattern emerged
04:16:18 <bollu> I see
04:16:35 <Vyn> Is there an easier way to "round down to the nearest power of 2"?
04:16:48 <Vyn> Rather than taking the log and then again exponentiating?
04:18:19 <bollu> Vyn: http://stackoverflow.com/questions/2679815/previous-power-of-2
04:18:42 <bollu> or you round up and divide by 2
04:20:47 <Vyn> bollu: Ah, sort of non-mathematical solutions
04:20:57 <Vyn> bollu: I'll let pokalyis worry about that part then
04:20:58 <Vyn> Thanks!
04:21:37 <bollu> Vyn: :D yes
04:23:21 <pikajude> is there a preexisting library i can use to write a throttling system for my bot
04:23:48 <pikajude> like, i want to measure if i have received X events in the last Y ms
04:24:08 <unclechu> hi there. I wonder if there's some bindings for xtest extenstion for X11? https://www.x.org/releases/X11R7.7/doc/libXtst/xtestlib.html
04:24:41 <ertesx> pikajude: you can use a TBQueue together with a reader that threadDelays before each read
04:24:48 <ertesx> pikajude: (stm package)
04:25:08 <pikajude> a tbqueue, you say
04:25:13 <ertesx> pikajude: (or better use registerDelay instead of threadDelay)
04:25:29 <pikajude> ooh, a bounded queue
04:26:06 <pikajude> hmm. but how would I use registerDelay
04:26:19 <pikajude> you always have good suggestions ertesx but i never use stm so i don't understand them
04:29:24 <implementation> then that's a good occasion for learning stm. it's a very, very useful library and not hard to use.
04:29:50 <pikajude> so would the reader be in a separate thread, taking things out of the queue?
04:30:04 <pikajude> and if the writing thread detects the queue is full, that's when the throttle limit is considered reached
04:30:10 <pikajude> right?
04:32:23 <implementation> the writing thread doesn't care about throttling at all, and the reading thread just repeatedly fetches one message from the queue, sends it, and waits a moment before repeating.
04:32:35 <pikajude> sends it to what
04:32:48 <pikajude> ohhhh
04:32:53 <pikajude> ok, i messed up
04:32:58 <pikajude> i'm not trying to do throttling. i want to do flood detection
04:34:41 <ertesx> pikajude: slowlyTake d q = do dv <- registerDelay d; atomically (do readTVar dv >>= check; readTBQueue q)
04:34:50 <pikajude> no, i'm not doing throttling
04:35:35 <ertesx> what do you mean by flood *detection*?  do you want a system for alerts, or just a system that can't be flooded?
04:35:56 <ertesx> i'd generally go for flood *prevention* and not bother *detecting* it
04:35:59 <pikajude> i want to write code to do something when user X has sent Y messages in Z seconds
04:36:13 <ertesx> ah, well, that's a different story =)
04:36:15 <pikajude> well, usually, you have to detect whether it's happening to prevent it
04:36:20 <ertesx> no, you don't
04:36:28 <pikajude> so should the bot just guess?
04:36:30 <pikajude> i don't follow
04:36:46 <ertesx> let's say you create a TBQueue with a limit of 10
04:37:07 <ertesx> one thread uses slowlyTake in an infinite loop to read once a second
04:37:48 <ertesx> if the other threads write so quickly that the limit is reached, they start blocking
04:37:53 <pikajude> ok, so what i said originally was right
04:38:26 <ertesx> (or they use tryWriteTBQueue and then report something to the user like: "sorry, i can't queue your message, because apparently i'm being flooded right now")
04:38:45 <pikajude> yeah
04:39:03 <pikajude> tryWriteTBQueue doesn't exist
04:39:21 <pikajude> neat, i'll do that
04:39:23 <ertesx> oh, of course
04:39:37 <pikajude> although instead of a queue couldn't I just track it in an int?
04:39:44 <pikajude> since presumably the queue would be full of ()
04:39:47 <ertesx> it's:  atomically (True <$ writeTBQueue q x <|> pure False)
04:39:56 <ertesx> that's tryWriteTBQueue =)
04:40:52 <ertesx> it would be the same code complexity, but the Int has the disadvantage that it's disconnected from its own meaning, if that makes any sense
04:41:17 <pikajude> whereas what does a queue full of () mean
04:41:48 <amx> I don't follow that definition, how can that work if writeTBQueue blocks
04:41:50 <ertesx> well, i suppose you could use a semaphore
04:42:20 <amx> don't you just need isFullTBQueue?
04:42:23 <ertesx> amx: STM makes it work: (x <|> y), since the x blocks, STM tries the alternative transaction y
04:42:47 <amx> ah right
04:43:08 <ertesx> pikajude: https://hackage.haskell.org/package/stm-2.4.4.1/docs/Control-Concurrent-STM-TSem.html
04:43:09 <amx> "orElse"
04:44:21 <pikajude> ok, so instead of writeTBQueue, it'd be waitTSem
04:49:08 <ertesx> pikajude: as an STM exercise you could import Control.Concurrent.STM hiding (TSem, newTSem, waitTSem, signalTSem), and make your own implementation (that you later just swap out for the official one, once it works)
04:49:23 <ertesx> all you need is TVar
04:54:45 <sm> morning all
04:56:32 <sm> I wonder if the minimal installers at http://haskell.org/downloads include (new-ish) alex and happy
05:02:11 <amx> I don't think so
05:04:40 <sm> thanks
05:07:22 <amx> only did a quick grep through the mac installer, so don't stake your life on it
05:08:06 <sm> here's me trying to write reliable install instructions using cabal: https://gist.github.com/simonmichael/b2d794eea437158e680f7d2d9f7d4806
05:08:45 <sm> any way to simplify ?
05:09:29 <madknight> sm, provide a install bash script
05:09:59 <sm> that's an idea, though platform-specific
05:10:53 <madknight> sm, provide .sh and .bat then you should reach most platforms :)
05:10:53 <sm> would the script also install cabal-install ?
05:10:59 <amx> why install alex and happy globally?
05:11:19 <sm> amx: seems best practice, they're needed for many packages
05:13:39 <sm> I think a reliable script of this kind is a lot of work
05:14:33 <sm> the trouble is, there are a *lot* of ways to get setup in various situations, but not really one way that always works
05:14:39 <hansihe> there must be a better way to structure something like this, suggestions? https://gist.github.com/hansihe/a908ab2adcacc2bf3567f11f748ffa42
05:15:48 <lyxia> Returning Just a on Just a, and something else on Nothing is what (<|>) does
05:16:03 <lyxia> and the second case is a bind
05:17:47 <hansihe> thanks!
05:18:01 <lpaste> lyxia pasted “to hansihe” at http://lpaste.net/316071
05:18:46 * hackagebot pringletons 0.4 - Classes and data structures complementing the singletons library  https://hackage.haskell.org/package/pringletons-0.4 (andrewthad)
05:20:13 <hansihe> thanks, I am still getting used to using monads
05:28:25 <lpaste> recurss pasted “Problems with Show1” at http://lpaste.net/316083
05:29:58 <suppi> in pipes, how can i convert a `Producer a m b` to `m ([a],b)`?
05:31:28 <recurss> jle`: I posted my AST here with a short description, would you mind having a look? http://lpaste.net/316083
05:44:52 <Stuart> Hi I have exercise in the haskell book on the ReaderM 
05:45:05 <Stuart> I have implemented the Reader monad
05:45:38 <Stuart> but it gets to the end and apparently have to implement some code ReaderM which they have left out
05:45:47 <Stuart> or I have missread it
05:46:14 <Stuart> How do I implement the following code using ReaderM https://github.com/bitemyapp/shawty-prime/blob/master/app/Main.hs
05:46:37 <Stuart> or where do I start
05:46:42 <bollu> is there someway to "see" how loeb works?
05:46:56 <Rembane> Stuart: By replacing all the arguments you don't want to pass with a Reader.
05:47:34 <Rembane> Stuart: So instead of f :: StupidArgument -> ... -> Result, you get: f :: ... -> Reader SomekindofState Result
05:48:03 <Rembane> Stuart: Where SomekindofState probably is a record datatype 
05:48:45 <ph88> are these stats normal for a program run?  https://paste.fedoraproject.org/464694/77831686/
05:52:44 <Stuart> Rembane: Apparently it is Database connection
05:52:52 <Stuart> and I am supposed to use ReaderM
05:52:58 <Rembane> Stuart: Cool, put it as the Context in the Reader.
05:53:21 <Stuart> What is ReaderM
05:53:28 <Stuart> It is some transformer
05:54:14 <Stuart> They talked about ReaderM and Reader and you don't use Reader in Issolation
05:55:23 <Rembane> Stuart: Do you have a link to that material?
05:56:23 <Stuart> The haskellbook is http://haskellbook.com/
05:56:51 <Stuart> It maybe a pdf on the internet
05:57:00 <Rembane> Cool
05:57:08 <Stuart> The code is https://github.com/bitemyapp/shawty-prime/blob/master/app/Main.hs
05:57:38 <Rembane> :t Reader
05:57:40 <lambdabot> error:
05:57:40 <lambdabot>     • Data constructor not in scope: Reader
05:57:40 <lambdabot>     • Perhaps you meant one of these:
05:57:45 <Rembane> Meh
05:58:02 <sham1> :t ReaderM
05:58:03 <lambdabot> error:
05:58:03 <lambdabot>     • Data constructor not in scope: ReaderM
05:58:03 <lambdabot>     • Perhaps you meant one of these:
05:58:09 <Stuart> I am just looking for copy 
05:58:10 <sham1> D'oh
05:58:13 <Stuart> on the internet
05:58:15 <Rembane> So, https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html
05:58:33 <Rembane> There's a version of the Reader monad.
05:59:01 <Stuart> I was looking at this
05:59:04 <sham1> Monad transformers, assemble
05:59:15 <sham1> ... me a computation
05:59:20 * Clint squints.
05:59:20 <Stuart> r is the reader and m is the modified environment
05:59:46 <Rembane> Stuart: Indeed
06:00:10 <Stuart> What prime mean exactly
06:00:13 <Stuart> i.e r'
06:00:23 <Stuart> I always see it
06:00:34 <Rembane> Stuart: A new r.
06:00:41 <Rembane> Stuart: Or another version of r
06:00:57 <sham1> Is there actually an advantage of using a Reader versus a State
06:01:15 <Rembane> sham1: Yes, it is less powerful, so you can reason about it more easily.
06:02:52 <Stuart> Rembane: thanks
06:03:07 <Rembane> Stuart: No worries. :)
06:03:31 <ertesx> :t Lunch
06:03:33 <lambdabot> Let me guess
06:03:38 <ertesx> :t Pizza
06:03:39 <lambdabot> Do you ever eat something other than pizza ? (?)
06:04:22 <Rembane> :t Sushi
06:04:24 <lambdabot> error: Data constructor not in scope: Sushi
06:04:26 <Rembane> :D
06:07:27 <ph88> oh lambdabot has easter eggs ^___^
06:07:31 <icosane> @pl \g -> \i -> \x -> g x i
06:07:31 <lambdabot> flip
06:08:31 <ph88> @pl \g i x -> g x i
06:08:31 <lambdabot> flip
06:08:43 <ph88> why the extra arrows ?
06:09:29 <icosane> @pl \x -> f a x b
06:09:29 <lambdabot> flip (f a) b
06:11:15 <sham1> Time to flip it
06:17:15 <ph88> my program can run with only a 3K stack size, does that mean it's without space leaks ?
06:18:34 <icosane> I don't know much haskell, but if it can run with that low amount of memory, it is probably ok, although maybe it actually does have space leaks.
06:18:39 <ph88> dmwit, are you around ?
06:19:08 <ph88> it works with 900 bytes stack size even
06:20:11 <Istanbul_Sea> hello
06:20:26 <ph88> hi
06:20:38 <icosane> Eh, that's a very low amount. If it can run with that amount of memory, haskell probably does dynamic memory allocation or you made a mistake (i.e., 900 megabytes instead of 900 bytes)
06:21:30 <ph88> well i think it will allocate a lot on the heap, but the stack seems to be ok
06:21:54 <ph88> in a guide i read that 1K is typical .. so my 900 bytes seem ok too
06:22:12 <ph88> so this is my program .. when i put iterations on 10000 i run out of memory .. any suggestions on what i can do here?? https://paste.fedoraproject.org/464712/14778336/
06:24:41 <ph88> on line 53 .. this should be evaluated (\x -> stats <$> (replicateM iterations $ algo <$> getBits x))   before another number from mapM is used on the same line
06:24:52 <ph88> otherwise it will take too much space on the heap i think
06:24:59 <icosane> Eh, that's too complicated haskell for me. I can write and understand small haskell programs, but this is a bit too much for me. A common cause of space leaks seems to be lazyness, maybe adding some strictness annotations will work for you.
06:25:30 <ph88> ye some bang patterns right ?
06:25:33 <lyxia> ph88: stats is leaking. 
06:25:40 <ph88> how can you tell ?
06:26:15 <lyxia> It thunks the three components, and keeps the counts list until the three are evaluated.
06:27:03 <James123> Is there any built-in function that removes the first occurence of x from a list e.g. f 1 [2,1,3,1,5,1] gives [2,3,1,5,1] ?
06:27:21 <Tuplanolla> Yes, `delete`.
06:27:30 <ph88> what do you mean "keep the count list" ? shouldn't it have access to the count list when it still need to evaluate the min, avg and max ?
06:28:46 <James123> Tuplanolla: Perfect! Thank you
06:29:16 <icosane> If I understand correctly (I don't really understand the code you gave me), *all* the elements of the list are kept in memory. From my limited understanding I would infer that all these random numbers take memory.
06:29:16 <ertesx> ph88: it doesn't have easter eggs (as far as i'm aware) =)
06:30:15 <lyxia> ph88: The problem is that the min, avg and max are not evaluated together
06:30:25 <ph88> icosane, yes bit after i calculate min, avg and max the original list can be garbage collected
06:30:42 <icosane> I was just going to say that (lyxia) (Maybe you should compute avg, max and min together (computing them of a list of random numbers is what you were doing, right?))
06:30:42 <lyxia> ph88: you first plot all the mins at line 70, but then avg and max are not evaluated yet
06:30:54 <ph88> aaahh
06:31:02 <lyxia> ph88: so you still have to hold on to all the lists you have produced
06:31:11 <ph88> jesus
06:31:15 <ph88> how could i have known that ?
06:32:14 <ph88> and i guess the usual fix here is putting some ! somewhere? or what approach would be good to fixing this problem ?
06:32:28 <ertesx> ph88: the fix is to use a single fold
06:32:58 <ph88> ah you mean that minimum and maximum and sum each have their own fold ..
06:33:01 <ertesx> ph88: if you refer to a name multiple times, its underlying thunk is shared
06:33:15 <ph88> so i guess a single fold is even more performant as well !
06:33:18 <Tuplanolla> > permutations [1 .. 3] & \ it -> sort it == it
06:33:19 <Tuplanolla> Why does this not hold? It seems like a bug, because generating permutations while maintaining lexicographic order shouldn't be any harder.
06:33:21 <lambdabot>  False
06:33:34 <ertesx> ph88: yeah, it will be…  just use foldl'
06:33:43 <ph88> ertesx, were you refering to any name in particular ?
06:33:51 <ertesx> ph88: or a composable folds library like 'foldl'
06:34:01 <ertesx> ph88: no, any variable name
06:34:11 <ertesx> (\x -> f x x)  -- used twice, so shared
06:34:19 <ertesx> let x = … in f x x  -- used twice, so shared
06:34:33 <ertesx> any value that has a name and is used more than once will be shared
06:34:42 <ertesx> i.e. kept in memory
06:34:44 <ph88> ertesx, and you choose foldl' strict version over foldr for performance ?
06:34:56 <lyxia> you'll also need to change the way stats is being applied
06:35:08 <ph88> why is that ?
06:35:09 <ertesx> ph88: i choose foldl', because this is a left fold
06:35:28 <ertesx> foldr is for right folds
06:35:41 <ertesx> (or, as i like to call them, *folds*)
06:35:46 <ph88> as i understood you can get the same results with left and right fold
06:36:08 <ph88> for things like summing the list
06:36:31 <sham1> There are still computations where it being left vs right fold matters
06:36:39 <ertesx> you can and will for associative functions, but this isn't just about the result itself, but about computing it
06:36:40 <lyxia> ph88: you are passing the output of replicateM to stats, but the result of that is not evaluated until after runAlgo finishes.
06:37:33 <ertesx> foldl' will compute the result by computing iteratively…  it's a stateful computation
06:37:58 <ph88> lyxia, ah you mean i can incrementally compute min, max and sum and have to reserve less space ?
06:38:13 <suppi> how can i identify the last element in a stream in pipes?
06:38:13 <ph88> of course i can not calculate average .. but i can do that in an extra step i guess
06:38:45 <ertesx> suppi: you can't in general
06:38:45 <lyxia> suppi: I don't think you can.
06:38:58 <suppi> :(
06:39:03 <lyxia> use conduits!
06:39:19 <ertesx> suppi: but you could use an underlying state monad or just use the pipes-parse idiom
06:39:34 <sham1> Semantically, does the consept of the last element even make sense with a stream
06:39:40 <suppi> ertesx: can you elaborate?
06:39:52 <ertesx> suppi: the former is: Producer a (StateT a m)
06:40:04 <ertesx> suppi: the latter is: StateT (Producer a m) m
06:40:28 <ertesx> the latter gives you "left-overs"
06:40:39 <ertesx> and the former gives you, well, state =)
06:40:42 <hansihe> is there an efficient way to view something like a Word64 as 8 Word8s?
06:41:05 <ph88> lyxia, how can i make it so that the intermediate result of runAlgo is evaulated? I can not use replicateM anymore ?
06:41:08 <suppi> more concretely, i am saving a few pieces to write at the end of the stream but can't seem to identify the end
06:41:35 <ertesx> hansihe: if there is, libraries like binary and cereal probably do that, so check out their serialiser for Word64
06:42:10 <lyxia> ph88: I was thinking of something like    (...) >>= \counts -> return $! stats counts   instead of   stats <$> (...)
06:42:13 <suppi> i thought i could use `next` for that but i'm not sure
06:42:15 <ertesx> hansihe: alternatively look into the ghc-prim library or the GHC.* modules in base
06:42:38 <lyxia> ph88: assuming you fixed stats to evaluate its values before returning the tuple
06:42:48 <ertesx> suppi: you just want to append something to a stream?
06:43:07 <suppi> ertesx: yes, basically
06:43:08 <ph88> still working on stats
06:43:13 <ertesx> suppi: (>>) is the append operator
06:43:21 <lyxia> ph88: but using a fold would be even better
06:43:42 <ertesx> suppi: myStream >> yield blah >> yield blubb  -- myStream with blah and blubb appended
06:43:45 <ph88> lyxia, a fold to replace replicateM ?
06:43:58 <suppi> it's data i saved in a state monad in a pipe while processing the stream
06:44:26 <ertesx> suppi: do myStream; x <- get; … yield (f x) …
06:44:38 <ertesx> suppi: (>>=) is the more general append operator
06:44:49 <lyxia> ph88: Yeah
06:45:03 <ph88> alright i'll look into that as well then ^^
06:45:07 <ph88> i noticed that foldl takes a starting value .. but i want behaviour like foldl1 where the starting value is the first item .. but this brings a problem: the returned value by foldl1 has to be in the same shape as the value that is being folded
06:45:23 <lyxia> maybe not technicaly a fold, I'm not sure.
06:45:48 <ph88> well let me first get working on stats and the rewrite to stats counts
06:45:48 <ertesx> ph88: what else would its type be?
06:45:56 <ertesx> well, you could do something more general
06:46:22 <ertesx> but it's equivalent to just mapping over the list and then fold1ing
06:46:28 <ph88> ertesx, Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a   return value of type a, folded value of type b
06:46:45 <ertesx> ph88: yeah, but if the starting value is a list item…
06:46:49 <ph88> Data.List foldl1 :: (a -> a -> a) -> [a] -> a    now return and folded value have to be both a
06:47:12 <ph88> yes but i want to do a small calculation on the starting value first
06:47:33 <ertesx> you could probably have something like:  (a -> r) -> (r -> a -> r) -> NonEmpty a -> r
06:48:10 <ertesx> but you'll have to write that one yourself
06:48:24 <Tuplanolla> That reminds me of a certain encoding, ertesx.
06:48:25 <ph88> consider this list: [4,1,8] now i want min max average, as starting value i need to convert 4 to (4, 4, 4)  and then in my function i do   \(a,b,c) x -> (minimum [a,x], b + x, maximum [c,x])]
06:48:27 <lyxia> ph88: algo1 also seems to be building big thunks: "Algo1 (zeros_left # found) (assert (inspect ==. nil) inspect) (cnt2 + 1)"
06:48:41 <lyxia> These fields are not evaluated untl much later
06:48:48 <ph88> eh correction: i will compute sum first before i do average
06:49:18 <ertesx> ph88: ideally find a minimum/maximum value
06:49:22 <Tuplanolla> You pass in `nil`, `cons` and a list...
06:49:27 <ertesx> ph88: i mean a bottom/top value
06:49:36 <ertesx> like minBound and maxBound, if your type is Bounded
06:49:42 <suppi-> ertesx: i basically did: `do { s <- flip execStateT [] $ forever (lift await >>= process >>= lift . yield); traverse yield s }`
06:49:49 <ertesx> ph88: then you can use regular foldl'
06:49:54 <lyxia> ph88: by the way: maximum [a, x] = max a x
06:50:04 <ertesx> Tuplanolla: hmm?
06:50:13 <suppi-> but it doesn't seem to work
06:50:44 <ph88> ertesx, i have to find the max inside of the fold, so i need a starting value .. perhaps i can just take 1 of the list calculate the tuple and then just use foldl' ?
06:51:06 <ph88> lyxia, ok thanks for noticing the big thunks there .. i will check them too .. i'd be interested to know how i can spot something like this myself
06:52:04 <ertesx> ph88: the idea is that in general 'min' and 'max' are semigroups, but you are adding a top and bottom element (respectively) to turn them into monoids, so you can use foldl'
06:52:29 <ph88> ????
06:53:02 <ertesx> ph88: sum = foldl' (+) 0  -- associative binary function (+) and its identity element (0)
06:53:17 <Rembane> ertesx: Is the 0 in that example the bottom value?
06:53:20 <ph88> if i put 0 there it would mess up the results
06:53:24 <ertesx> product = foldl' (*) 1  -- again
06:53:45 <Rembane> ph88: Why?
06:53:58 <ertesx> ph88: yes, because 0 is not the identity element of min/max in general…  that's the top/bottom element of the particular type (and it may not exist at all)
06:54:41 <ertesx> ph88: example:  minimumWord8 = foldl' min (255 :: Word8)
06:54:47 <ph88> Rembane, because the minimum would always be 0
06:55:06 <Rembane> ph88: Indeed, then you could use MIN_INT.
06:55:13 <Rembane> ph88: Or foldl1
06:55:18 <Rembane> :t foldl1
06:55:20 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
06:55:28 <ertesx> (the point is to avoid foldl1)
06:55:32 <Rembane> Darn. :D
06:55:39 <ph88> ah yes that's one approach ^^
06:55:40 <mpickering> just another reminder how much of a disaster FTP was
06:55:49 <Rembane> What's FTP?
06:55:59 <ertesx> File Transfer Protocol
06:56:04 <ertesx> ;)
06:56:50 <suppi-> ertesx: sorry to bother but, any ideas? :(
06:57:06 <ph88> stat (a,b,c) x = (min a x, b + x, max c x)     stats (x:xs) = foldl' stat (x, x, x) xs
06:57:10 <ph88> this seems to work too
06:57:24 <ertesx> mpickering: why do you think it's a disaster?
06:57:36 <lyxia> ph88: uh you're still returning constructors without forcing their fields
06:58:16 <ph88> lyxia, eh i thought foldl' being strict would force the fields ?!
06:58:36 <mpickering> ertesx: The same reasons everyone else does. 
06:58:43 <ertesx> suppi-: the code you've shown so far seems fine…  you can use a state monad within a pipe, and you can append some elements at the end by simply yielding more
06:58:51 <mpickering> > length (2, [1])
06:58:53 <lambdabot>  1
06:58:53 <ertesx> suppi-: so you got the general idea right
06:59:02 <ertesx> mpickering: i don't, so what are the reasons?
06:59:10 <lyxia> ph88: It forces the topmost constructor, which is (,,) here, and is what stat returns immediately
06:59:14 <suppi-> ertesx: yet it doesn't work
06:59:50 <mpickering> Foldable is a poor abstraction and it makes the language more difficult to learn for beginners as all these common functions have these types with complex constraints
07:00:09 <Tuplanolla> It would've probably been less bad with a complementary `PreludeForBabies` proposal, mpickering.
07:00:17 <mpickering> + bugs such as taking the length of a tuple
07:00:22 <ph88> lyxia, ah ok i didn't know that about foldl' i always thought that strictness would resolve all the underlying things too. But only ! do that ?
07:00:33 <lyxia> no it has the same issue
07:00:34 <mpickering> Well, why not a PreludeForExperts proposal  :)
07:00:49 <Tuplanolla> That would be fine too.
07:01:00 <ertesx> mpickering: yes, Foldable is a questionable abstraction, but it is useful, and i'm in favour of the generalisation
07:01:01 <ph88> lyxia, how can i force a b and c ?
07:01:31 <Cale> I'm not sure I like Foldable, but I don't have any problem with length (x,y) being 1
07:01:39 <ertesx> yeah, exactly
07:01:45 <mpickering> experts know about the PreludeForExperts but beginners don't know about SimplePrelude
07:01:46 <Rembane> A tuple is not something with a length imo.
07:01:52 <lyxia> ph88: let a' = min a x ; b' = b + x ; c' = max c x in a' `seq` b' `seq` c' `seq` (a', b', c')
07:02:01 <ertesx> the length *should* be 1, and it's more important that beginners understand *why* it's 1 instead of just taking Foldable away from them
07:02:03 <Cale> I *do* like Traversable, and the Traversable instance for pairs is important in my daily life
07:02:09 <mpickering> I don't like it because it causes bugs in my program when I am refactoring. 
07:02:18 <ertesx> it's like: "beginners don't understand functors, so we need this bullshit separation between map and fmap"
07:02:25 <mpickering> Yes, Traversable is good
07:02:26 <ertesx> i never agreed with treating beginners like infants
07:02:47 <Cale> and if you think about what the Traversable instance for pairs does, it's obvious why the length of a pair is 1
07:03:03 <mpickering> ertesx: I teach first year undergraduates who have never programmed before and there are much more fundamental problems to get over
07:03:07 <Cale> (or even just the Functor instance)
07:04:48 <ertesx> mpickering: i understand where this is coming from, but it's not something to hide/remove, it's something that needs to be explained
07:05:47 <mpickering> it is explained in due course but you have to deal with it from day 1 
07:05:58 <lyxia> ph88: I don't know what you need to learn to be able to spot and fix such things. It's a shame. :/
07:06:02 <Tuplanolla> I've found that students have more trouble with syntax than any of the basic concepts.
07:06:16 <icosane> If ph88 still needs some help on the statistics thing (I didn't follow the discussion for a while), you need something like this to generate the min, max and average: summary (currentMin, currentMax, currentAverage) totalLength [] = (currentMin, currentMax, currentAverage)
07:06:16 <icosane> summary (cmin, cmax, caverage) totalLength x:r =
07:06:16 <icosane>   summary (min r cmax, max r cmax, caverage + x/totalLength) totalLength r
07:06:16 <icosane> (Probably needs tsome strictness annotations, though)
07:06:30 <ph88> lyxia, alright time will tell i guess ^^
07:06:49 <mpickering> It just seems an extremely poor tradeoff to force on all users when you can use whatever prelude you want if you know what you're doing. 
07:07:47 <ertesx> mpickering: there is a cost associated with using a different prelude…  i really think 'length' should not be a list function
07:07:51 <ph88> icosane, https://paste.fedoraproject.org/464745/78364441/
07:08:12 <mpickering> ertesx: What is the cost?
07:09:09 <Cale> Having spent over a decade using the language while length was a list function, I honestly don't think it makes a huge difference
07:09:41 <ertesx> mpickering: everybody who wants to read your code now has to learn that other prelude and its potentially different semantics
07:09:49 <Cale> The fact that it *might* be a list function means that you're still not going to want to use it in its general form.
07:10:13 <ertesx> mpickering: for the most basic, fundamental things that is…  there is some value in having a common prelude that most of the community agrees upon
07:10:19 <ertesx> s/upon/on/
07:10:35 <ertesx> Cale: good point
07:11:36 <ertesx> so yeah, Foldable is still not a great abstraction, but it's the one we're stuck with for now
07:12:38 <mpickering> So things like traverse and fmap are good because when you call them on a value they act uniformly in a predictable way. length just produces an integer so when I use it I want to be sure of the type of the thing I am applying it to
07:12:53 <mpickering> fmap and traverse also have more than 1 argument which makes sure all the type variable agree
07:13:12 <mpickering> (I know you can implement length using traverse)
07:13:31 <ertesx> Foldable could be that way, if it only included foldl', foldl and foldr
07:13:46 <ertesx> and perhaps fold and foldMap
07:14:15 <mpickering> I just see Foldable as a way of overloading a bunch of function names in an ad-hoc fashion
07:14:28 <ertesx> and honestly i like to pretend that it does only include those
07:14:47 <ertesx> yeah, that's pretty much exactly what it is
07:15:20 <mpickering> But we somehow in this situation where it has made it's way into the base libraries whilst most people are against "lawless typeclasses" 
07:15:24 <mpickering> another paradox I fail to understand
07:17:06 <ertesx> is this really about laws?  i think type classes make sense as soon as you have at least two instances and one generic function defined in terms of the class
07:17:20 <ph88> lyxia, in case you are curious how i incorporated your suggestions: https://paste.fedoraproject.org/464756/14778369/ seems a bit less readible but i think it's ok if i get performance back ^^
07:17:38 <ertesx> we have a lot of lawless type classes in base…  sure, they don't correspond to a well understood algebraic structure, but they are nevertheless useful
07:17:46 <ertesx> like Bits
07:18:30 <mpickering> I'm not arguing against them. I'm trying to understand the contradiction in the community where people advocate algebraic type classes but support Foldable 
07:18:55 <suppi-> I'm trying to append data to stream from 'pipes' after the stream ends. i've tried this but it doesn't work. anyone have any idea how to do this? `do { s <- flip execStateT [] $ forever (lift await >>= process >>= lift . yield); traverse yield s }`
07:19:27 <lyxia> ph88: I'd also replace length lst with iterations
07:19:29 <ertesx> suppi-: you need to stop awaiting at some point
07:19:49 <suppi-> ertesx: yeah, but how do i know when the stream ends?
07:19:54 <ertesx> suppi-: but pipes doesn't have a built-in concept of "end of stream"
07:20:00 <Cale> mpickering: Well, Foldable does have a bunch of laws, it's just they don't make it very close to unique
07:20:12 <lyxia> ph88: or if you don't want to rely on a statically known length, add a counter in stat
07:20:14 <suppi-> ertesx: so basically i'm fucked?
07:20:18 <Cale> mpickering: From foldMap, you get basically everything else...
07:20:48 <Cale> mpickering: but then you need some kind of laws for foldMap to satisfy, and those are harder to come by
07:20:52 <ertesx> suppi-: basically you need a way to communicate the end…  if anything in the pipeline finishes, the whole pipeline finishes
07:20:59 <mpickering> Cale: are you talking about the free theorems? 
07:21:04 <ph88> lyxia, why didn't i think of that -___- :P
07:21:27 <suppi-> ertesx: i just don't know how to do that.
07:21:33 <Cale> mpickering: I'm talking about the implied laws which are equivalent to the default definitions of the other methods of the class.
07:21:39 <ertesx> suppi-: one simple way would be to wrap the input stream in Maybe and yield a final Nothing
07:21:40 <ph88> lyxia, i also made some adjustments here on line 7 10 and 11  https://paste.fedoraproject.org/464767/77837258/
07:21:53 <ertesx> suppi-: it's ugly, but it's the simplest way
07:22:02 <ertesx> suppi-: the more sophisticated way involves the pipes-parse library
07:22:29 <ertesx> suppi-: pipes-parse is basically "conduit in terms of pipes"
07:22:29 <suppi-> ertesx: damn, i've been totally going at this the wrong way.
07:22:33 <suppi-> ertesx: thank you very much
07:22:34 <lyxia> ph88: It would be nicer to make the fields of that datatype strict.
07:24:39 <ertesx> mpickering: i prefer algebraic classes over ad-hoc ones, but i never viewed Foldable as an algebraic class…  i always viewed it as ToList
07:25:13 <ph88> didn't know i could do that ^^
07:25:47 <ph88> so i just put this   data Algo1 = Algo1 !Found !ToInspect !Cnt deriving (Show)
07:26:05 <ertesx> mpickering: the reason i like Foldable is that it has this property that there are countless instances *and* many useful generic functions
07:26:10 <lyxia> ph88: yes!
07:26:25 <ertesx> mpickering: it's pointless for every data structure library to expose its own 'sum' and 'product' and whatnot…  this stuff is handled by Foldable
07:26:33 <ertesx> 'length' is really just a bad example
07:26:39 <ertesx> 'sum' is a better one
07:26:53 <ertesx> (if it were implemented in a useful way)
07:29:31 <ertesx> so my proposal would be: fix Foldable already!  that means: move all the generic functions (yes, even 'length') out of the class and write sane implementations for them
07:30:22 <ph88> my algorithm is embarrassingly parallel, i will try to exploit this ..
07:30:50 <ph88> my program is lagging my music :/
07:30:57 <ph88> quite heavy
07:31:05 <hpc> ertesx: that extra stuff already has default implementations
07:31:18 <hpc> ertesx: but are inside the class so you can write more efficient versions for particular data types
07:31:23 <ph88> it didn't get faster (not that i was expecting that) .. but so far it's still running with 10K iterations and no crash yet :D
07:33:39 <ertesx> hpc: yes, and that's a problem…  they should be efficient by default
07:33:53 <ertesx> hpc: do you think that replicateM belongs into the Monad class?
07:34:11 <hpc> there doesn't exist a single efficient implementation for every type
07:34:51 <ertesx> hpc: i'd challenge that…  for which type is (foldl' (+) 0) *not* the most efficient implementation of 'sum'?
07:35:06 <ph88> lyxia, uf no it still runs out of memory on the heap :/
07:36:05 <lyxia> ph88: I think you still need to convert stats <$> (...) to (...) >>= \counts -> return $! stats counts
07:36:12 <ph88> oh ye forgot that !
07:36:22 <hpc> ertesx: can you say for sure that foldl' is efficient for every Foldable?
07:37:01 <hpc> the burden of proof is on the generalization, not finding counter-examples
07:37:19 <hexagoxel> :t (<$!>)
07:37:20 <lambdabot> Monad m => (a -> b) -> m a -> m b
07:37:31 <hexagoxel> lyxia, ph88: ^
07:38:10 <ertesx> hpc: i don't really think that 'sum' has to prove to be the most efficient implementation…  it should be predictable and well understood
07:38:15 <hpc> (you are probably right, but you still need to justify it)
07:38:27 <ertesx> hpc: that's why i suggest moving 'length' out of Foldable as well
07:38:34 <lyxia> hexagoxel: oh yeah, nice one!
07:38:39 <ertesx> hpc: it's useless that it *can* be O(1)
07:38:58 <Rijndael> Hi. wow what a large community!
07:39:02 <ertesx> if you use 'length' you shouldn't ever assume that it could be O(1)
07:39:22 <Tuplanolla> Why would I use `length` if it's not?
07:39:51 <ertesx> Tuplanolla: in some cases counting is indeed what you want to do
07:40:01 <Rijndael> What Haskell is most well-suited for?
07:40:16 <Tuplanolla> That's quite rare, ertesx. I usually only need it with `Vector`, `Seq` and such.
07:40:18 <sham1> General programming
07:40:21 <ertesx> Rijndael: hi!  it's a general purpose language, so for most things =)
07:40:23 <hpc> ertesx: moving length out of Foldable makes the Array instance bad
07:41:08 <sham1> You can do anything in Haskell that you can do in any other language, you just need to think about it differently
07:41:26 <ertesx> Tuplanolla: the 'length' of Vector and Seq aren't counting though…  i find it unsafe to rely on Foldable's 'length' to get their lengths
07:41:47 <hpc> why is it unsafe?
07:41:52 <Tuplanolla> I can understand that.
07:42:26 <ertesx> hpc: because "it's efficient" is an assumption – an implementation detail
07:43:00 <hpc> it's an implementation detail of Data.Vector.length too
07:43:24 <hpc> what's the difference between documenting "this special length is O(1)" and documenting "this instance of generic length is equal to this special O(1) definition"
07:43:38 <ertesx> yes, but that one couldn't potentially be O(n) due to its semantical ties to some particular class
07:43:49 <jmcarthur> ertesx: a problem with your (foldl' (+) 0) example is that its efficiency depends on both the container and the Num instance
07:43:54 <Rijndael> What a fucking large community! 
07:43:55 <Rijndael> What a fucking large community! 
07:43:55 <Rijndael> What a fucking large community! 
07:43:56 <Rijndael> What a fucking large community! 
07:43:56 <Rijndael> What a fucking large community! 
07:43:57 <Rijndael> What a fucking large community! 
07:43:59 <Rijndael> What a fucking large community! 
07:44:00 <Rijndael> What a fucking large community! 
07:44:13 <jmcarthur> lol
07:44:19 <sham1> loop
07:44:46 <implementation> ertesx: you can have a data Polar = Polar phi abs; then (+) :: Polar -> Polar -> Polar would probably be something like p1 + p2 = toPolar (toCartesian p1 + toCartesian p2); thus, the resulting definition of sum you provided would expand like sum [p1,p2,p3] = toPolar (toCartesian (toPolar (toCartesian (toPolar (toCartesian 0 + toCartesian p1)) + toCartesian p2)) + toCartesian p3); which is obviously less efficient (look at all the 
07:44:47 <LordBrain> thankyou ircopers
07:44:47 <implementation> conversions!) than just sum xs = toPolar (sum $ map toCartesian xs)
07:44:50 <hpc> ertesx: you're sacrificing the ability to think generically about the Foldable instance as being the most appropriate definitions of what they do
07:44:54 <ertesx> i'll take that as a signal to stop this discussion for today, because i really want to get some other stuff done now =)
07:45:18 <hpc> in order to think about Foldable as having the same intentional definition
07:46:20 <hpc> (as in https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions, not "deliberate")
07:46:32 <ertesx> anyway, we're past limbo…  the current Foldable has taken a direction i don't quite *agree* with but certainly can *live* with
07:46:32 <Tuplanolla> It may be foldable, but it's not tearable.
07:49:18 <ertesx> implementation: it could be argued whether using Polar was a good decision in the first place…  similarly if the majority of what you're doing is summing, then using the LogFloat representation is a bad idea =)
07:49:20 <jmcarthur> I'm kind of with ertesx on this one. I'm not as comfortable trusting the functions in type classes are overridden to be efficient as I am trusting functions outside of type classes that I know the library author had to think about explicitly.
07:49:57 <ertesx> implementation: but that's beside my point…  my point is just what jmcarthur said…  i don't ever use 'sum', because it's not trustworthy
07:50:02 <jmcarthur> So I prefer to use, for example, Vector.length rather than Foldable.length
07:50:32 <ertesx> and having to look into the implementation of an instance is not worth my time…  i'll just use whatever the library module provides
07:50:53 <ertesx> in other words: 90% of Foldable is useless for me
07:51:01 <implementation> ertesx: sure, but it's a counter-example for (foldl' (+) 0) being the most efficient implementation of 'sum' in general.
07:51:04 <ertesx> or better: 90% of Data.Foldable is
07:51:07 <implementation> you wanted one, you got one
07:51:07 <jmcarthur> And in practice when I need the length of a container I basically always know what type of container it is, so there is no polymorphism benefit to using Foldable.length.
07:52:02 <ertesx> implementation: and i thank you for that, but the counterexample is actually useless, because you can't specialise 'sum' on any particular *Num* type
07:52:24 <ertesx> implementation: it's not a counterexample where 'sum' being in Foldable would make a difference
07:53:52 <jmcarthur> Further, when I do need the polymorphism, it means I'm probably happy with the naive O(n) length anyway.
07:54:23 <ertesx> jmcarthur: and if not, there is stuff like mono-traversable (with its own share of problems, of course)
07:55:27 <jmcarthur> A thought: If sum were a function of Num then it could choose whether it prefers left-associated, right-associated, or balanced (or at least balanced-ish) folds over any Foldable based on the Num instance.
07:55:52 <jmcarthur> And it could do the projection tricks mentioned by implementation.
07:56:07 <hpc> but what if Foldable/Traversable instances were consistently good, and then we had things like generic fourier transform libraries that used them instead of Array/Vector/[]?
07:56:09 <jmcarthur> Oh, it can't.
07:56:14 <jmcarthur> Foldable doesn't require Functor
07:56:26 <ertesx> i wouldn't mind if Foldable required Functor
07:56:34 <hpc> didn't it used to?
07:56:35 <Monoide> hello, I am struggling with an «indentation or mismatched brackets error» that I can't see: http://pastebin.com/Bv28p5ca
07:56:41 <Monoide> would anyone have a look and help me :s ?
07:56:44 <jmcarthur> I'm trying to think of any instance that isn't also a Functor.
07:56:46 <ertesx> oh, i take that back
07:56:53 <ertesx> having Set foldable is quite nice
07:56:56 <jmcarthur> Ah
07:57:17 <hpc> Monoide: what line is the error on?
07:57:22 <ph88> how can i check if a string is numeric and get back a Maybe Int  ?
07:57:23 <lyxia> Monoide: you can't finish a do block with a let.
07:57:40 <lyxia> ph88: readMaybe?
07:57:42 <Monoide> the second line of the first list
07:57:48 <ertesx> Monoide: you have quite a few syntax errors in there
07:58:10 <Monoide> I guess I have :s
07:58:13 <ertesx> Monoide: first make sure that you don't use tabs, if you do…  next let bindings need to line up vertically
07:58:14 <hpc> variables start with lower-case letters too
07:58:26 <Monoide> there should not be any tab
07:58:40 <hpc> your let block is mis-aligned
07:59:05 <suppi-> anyway to use `decode` with `Producer (Maybe ByteString) m ()` instead? :\ (`decode` from here: http://hackage.haskell.org/package/pipes-csv-1.4.3/docs/Pipes-Csv.html )
07:59:06 <hpc> the first 'N' in NonIdle ... should line up with the first 'I' in let Idle ...
07:59:37 <Monoide> right
07:59:48 <ertesx> Monoide: finally make sure you actually do something after that 'let'
07:59:54 <Monoide> I return something
08:00:00 <Monoide> let stuff in return thing
08:00:11 <hpc> ah, it's not in the paste
08:00:27 <Monoide> oh indeed, my bad, there is on more line:
08:00:33 <Monoide> in return $ little_computation
08:00:56 <ertesx> Monoide: if you're using 'in', it needs to be indented in relation to the do-block
08:00:57 <hpc> you might need to remove the "in", let in do-blocks is slightly different
08:01:04 <hpc> or indent it, yea
08:01:07 <ertesx> Monoide: but note that you can go without 'in', because it's a do-block
08:01:23 <Monoide> I think I need to review part of the Haskell indentation
08:01:35 <Monoide> I am not that positive I actually understood it well
08:01:49 <ertesx> Monoide: it's usually pretty natural…  if the indentation makes sense to your eyes, it probably makes sense to the compiler, too =)
08:01:56 <hpc> you might need to indent your lists too, after that first line
08:02:04 <Monoide> thank you very much, I'll come back to you if I am still struggling
08:02:09 <hpc> they might be parsing as individual lines instead of continuations of the previous one
08:02:11 <Monoide> how should I ident it ?
08:02:27 <hpc> [ foo,
08:02:30 <hpc>   bar,
08:02:31 <hpc>   ...
08:02:33 <hpc> or something like that
08:02:51 <hpc> something further in than the '['
08:02:52 <ertesx> yeah, please do it like hpc…  that comma-first style hurts my eyes =)
08:02:52 <Monoide> I read that Haskell style is more [ stuff1\n , stuff2 \m , etc
08:02:59 <ph88> this looks a bit odd  is this the right way to work with arguments?  https://paste.fedoraproject.org/464925/78397421/
08:03:11 <ertesx> Monoide: no, it's "some haskellers' style"
08:03:20 <hpc> Monoide: that's not really a preferred style, some people just do it as a hack to make line editing easier
08:03:31 <Monoide> okay
08:04:00 <hpc> it's occasionally convenient but as you become better at haskell you'll find it's not ever really needed
08:04:06 <hpc> but that's for later
08:04:13 <ertesx> ph88: i would pattern-match
08:04:26 <ertesx> ph88: main = do args <- getArgs; case args of …
08:04:55 <Monoide> ok hpc , thank you very much for your review, I am going to debug my code and I'll come back if needed :)
08:05:08 <hpc> ph88: base includes a nicer argument parser as well: https://hackage.haskell.org/package/base-4.9.0.0/docs/System-Console-GetOpt.html#v:getOpt
08:05:19 <hpc> ph88: and there's even nicer versions floating around hackage
08:05:40 <ph88> jeez how nice can it get? :p
08:05:51 <ertesx> ph88: applicatively super-nice =)
08:06:22 <ertesx> and even genericly applicatively hyper-nice =)
08:06:41 <implementation> any library recommendations?
08:06:52 <hpc> https://hackage.haskell.org/package/optparse-applicative -- this one's pretty neat
08:07:10 <ph88> cool, i'll check it ^^
08:07:22 <ertesx> and this one is a nice helper library: https://hackage.haskell.org/package/optparse-generic
08:07:37 <ertesx> define a type and say: "do what i mean"
08:07:53 <sm> also cmdargs and docopt
08:08:22 <lyxia> I never remember the doc structure of optparse-applicative, what functions are in what module.
08:09:00 <implementation> looks very nice
08:09:05 <lyxia> it is
08:10:46 <hpc> the only way it could get even better than automatic --help is some sort of freaky TH that generated manpages at compilation
08:10:54 <hpc> or something
08:11:40 <ertesx> using deep learning to write the text for you?
08:11:54 <hpc> haha
08:12:20 <hpc> or a genetic algorithm
08:12:30 <hpc> the fitness function is posting the docs to facebook and seeing what gets more likes
08:13:02 <kadoban> Lol, ow.
08:13:13 <ertesx> issue #1: put useful text into the man-page instead of ASCII art of a kitty
08:13:37 <kadoban> This is going to end up in acme-* isn't it?
08:13:45 <ertesx> solution: run the genetic algorithm between 2 PM and 4 PM between monday and thursday
08:14:34 <implementation> ertesx: won't work, since the world has a lot of timezones.
08:14:35 <hpc> kadoban: i hope so
08:14:46 <sm> but seriously, we actually really need more tools/best practices in this area
08:14:54 <hpc> implementation: it'll use the current locale, or pacific time on windows
08:15:07 <hpc> (also no DST on windows)
08:15:41 <sm> easy, flexible and redundancy-free declaration of opts, cli help, man pages, web docs etc.
08:15:44 <implementation> hpc: doesn't help if the facebook audience comes from all over the world
08:16:19 <hpc> sm: you think base will accept api-changing patches to the getopt module?
08:16:42 <hpc> sm: getting that stuff built into every ghc install would be pretty great
08:16:50 <sm> hpc: depends how many packages use it and how big the benefits are I guess
08:16:57 <sm> agreed
08:17:11 <Clint> man pages would be epic
08:17:42 <hpc> cabalized manpages :D
08:18:19 <sm> I am generating man pages & other doc formats with pandoc, which is totally separate from opts and cli help
08:18:20 <hpc> maybe do it like perl does, where you can do man Foo::Bar and it just works
08:18:25 <ertesx> implementation: facebook will make up for that
08:18:26 <hpc> for any module
08:18:55 <sm> yes, we should mimic whatever perl and ruby do for a start
08:19:00 <ertesx> it doesn't really let you communicate with the world…  it locks you up in your own personal bubble
08:19:51 <braulio--> hello!
08:20:19 <braulio--> I am trying to use the type system to restrict the effects of the IO monad
08:20:52 <braulio--> I have this `Screen` type defined as `newtype Screen a = Screen { runScreen :: IO a } `
08:21:32 <braulio--> I have that type in the Screen module, and am not exporting the type constructor
08:21:58 <braulio--> I am just exporting some functions like `putChar :: Char -> Screen ()`
08:22:16 <braulio--> I believe this is a common practice in haskell
08:23:02 <braulio--> It is easy to see that this Screen type is just the IdentityT transformer monad applied to the IO monad
08:23:05 <lyxia> It's better to export the type, without its term-level constructor.
08:23:26 <braulio--> what do you mean by term-level constructor?
08:23:43 <braulio--> I think that's what I'm doing, exporting the type but not the constructor
08:23:50 <lyxia> the constructor that you use to build values, as opposed to the one used to build types.
08:24:17 <joneshf-laptop> Anybody know where I can find the Automata library Aran Donohue mentions in the monad reader 16: https://themonadreader.files.wordpress.com/2010/05/issue16.pdf ? The reference link http://workshop.arandonohue.com/Automata/ is dead and I can't find it in the wayback machine.
08:24:18 <braulio--> uh ok, I see
08:24:41 <kirillow> is there like a rule of thumb for when to use pattern matching and ADTs instead of just passing functions that implement what you want to happen for control flow purposes?
08:24:45 <hpc> braulio--: something else slightly evil someone can do is:
08:25:00 <hpc> evil = (putChar 'z') { runScreen = launchMissiles }
08:25:13 <lyxia> braulio--: newtype A a = B (IO a)  we usually call A a type constructor, and B a constructor, maybe value constructor is better to disambiguate.
08:25:13 <hpc> so you probably want runScreen to not be a record accessor
08:25:31 <braulio--> ok I see
08:25:36 <sham1> Launch ze missiles
08:25:38 <hpc> braulio--: so for your purposes it'd be
08:25:45 <hpc> newtype Screen a = Screen (IO a)
08:25:54 <hpc> runScreen (Screen a) = a
08:25:58 <hpc> and the export list would be
08:26:04 <hpc> (Screen, runScreen, other stuff)
08:26:17 <braulio--> cool, I hadn't thought of that
08:26:25 <hpc> Screen on its own exports the type constructor, Screen(Screen) would export the data constructor as well
08:26:25 <braulio--> you are awesome, thank you
08:26:43 <hpc> Screen(..) exports all data constructors and record fields
08:26:51 <braulio--> well, my question was about the Identity transformer monad
08:27:03 <ertesx> joneshf-laptop: if you can't find what you're looking for, you may be able to use 'machines' as a substitute…  it defines a few automaton types
08:27:08 <braulio--> I wanted to implement Screen in such a way that I could use the IdentityT monad instances
08:27:21 <braulio--> instance*
08:27:33 <braulio--> but without exporting the data constructors
08:27:36 <lyxia> hpc: does it matter how runScreen is defined if you export it as (Screen, runScreen, ...) ?
08:27:37 <ertesx> kirillow: not sure what that means…  can you paste an example of both?
08:27:49 <hpc> lyxia: don't remember
08:28:20 <hpc> braulio--: you should be careful about that, even skipping past the question of how you would do it
08:28:33 <ertesx> kirillow: you mean using Bool as opposed to (forall r. r -> r -> r)?
08:28:39 <hpc> braulio--: for instance, suppose you wrote a MonadIO instance (which would be easy)
08:28:44 <hpc> :t liftIO
08:28:46 <lambdabot> MonadIO m => IO a -> m a
08:29:05 <hpc> braulio--: that would let someone put arbitrary IO into your Screen type, ruining the restricted effects
08:29:49 <braulio--> hpc of course, my question is about how I could use IdentityT without ruining the restricted effects
08:30:22 <joneshf-laptop> ertesx, Thanks. I think machines is too powerful for what Im looking for. Maybe I'm missing something though.
08:30:46 <ertesx> joneshf-laptop: i haven't read the article, but it also exposes some really simple things like .Mealy
08:31:14 <braulio--> hpc I would like to avoid implementing the Functor, Applicative and Monad instances because those implementations are already done in IdentityT
08:31:48 <exio4> braulio--: you can derive them (GeneralizedNewtypeDeriving) 
08:31:49 <braulio--> but the problem is, I don't want the users of Screen to be able to lift arbitrary IO actions
08:31:52 <hpc> just write them imo, they're really easy
08:31:52 <ertesx> braulio--: newtype Screen a = Screen { runScreen :: IO a }  deriving (Applicative, Functor, Monad)
08:32:24 <braulio--> awesome
08:32:25 <hpc> or use that language extension
08:32:56 <braulio--> is GeneralizedNewtypeDeriving a "safe" extension? would you recommend it?
08:33:23 <ertesx> braulio--: well, it literally copies the instances, so yeah
08:33:25 <braulio--> I've seen there are some extensions that haskellers normally prefer not to use
08:33:30 <Clint> GND is great
08:33:36 <kadoban> braulio--: It's one that gets used a lot, yeah.
08:34:45 <exio4> braulio--: it has been used to break the type system in the past (and hacks like "roles" have been added to fix that) - it's still normal to use it though 
08:34:58 <braulio--> ok, thank you all very much
08:34:59 <ertesx> braulio--: none of the extensions are really *unsafe*, but some of them can make type checking or instance resolution undecidable (in other words the compiler might not actually *fail* to type-check your code, but rather it "timed out" in a sense)
08:35:24 <joneshf-laptop> ertesx, wait, are moore/mealy regular languages?
08:36:29 <ertesx> joneshf-laptop: i don't know, but is this about parsing regular languages?  if yes, you may be able to use whatever the regex-tdfa* packages use
08:36:39 <braulio--> cool
08:36:54 <Fairy> Is there any online tutorial for dealing with Arrays in Haskell? I'm trying to use Data.Array and I'm hitting a literal brick wall, I can hardly get anything to work
08:37:14 <ertesx> Fairy: do you need multi-dimensional arrays?
08:37:56 <Fairy> Not sure what a multi-dimensional array means :S
08:38:13 <ertesx> Fairy: an array with indices that aren't just numbers
08:38:22 <ertesx> like pairs of numbers
08:38:44 <Fairy> I don't, no
08:39:06 <joneshf-laptop> ertesx, Fair point. I'm not really looking for regex in the PCRE sense though. more the CS definition of regular language
08:39:10 <ertesx> Fairy: then i think you'll find the API of 'vector' a lot easier
08:39:54 <kirillow> ertesx: https://gist.github.com/anonymous/791481ecd4b5664c5cadadfe7ed4b298 (can't think of a better example)
08:39:57 <Fairy> That doesn't really help me understand how to use Data.Array, though - I'm trying to learn
08:40:25 <Rembane> Fairy: Have a look at Data.Vector.
08:40:34 <srhb> People are hard of hearing today... :-P
08:40:47 * Rembane is late to the party, and reads too few lines of backlog.
08:41:04 <ertesx> Fairy: if you insist on the array library, this one might help: https://en.wikibooks.org/wiki/Haskell/Libraries/Arrays
08:43:13 <Fairy> thanks ;)
08:43:31 <Monoide> thank you hpc and ertesx , I fixed my problem :)
08:43:48 <Monoide> (I correctly compute the CPUusage of my computer just by reading /proc/stat ;p)
08:43:54 * hackagebot period 0.1.0.5 - Parse and format date periods, collapse and expand their text representations.  https://hackage.haskell.org/package/period-0.1.0.5 (alkar)
08:44:12 <ertesx> kirillow: it mostly depends on whether the choices are closed
08:44:47 <ertesx> kirillow: HaveDrink is an abstraction with the application as a special case, while HaveDrinkAlt is specifically the application, if that makes any sense
08:45:04 <ertesx> kirillow: in other words the question is: "are All, One and No the only options?"
08:45:27 <ertesx> or rather: "does it benefit me to *know* that they are the only choice?"
08:46:01 <ertesx> and at the opposite end: is the abstraction (HaveDrink) too general?  can i benefit from a more domain-specific language?
08:46:19 <ertesx> HaveDrinkAlt is highly domain-specific
08:48:16 <kirillow> ertesx: the first "end" makes a lot of sense to me. But what do you mean by "domain-specific"?
08:49:01 <amx> there is also the question whether you want the caller or the callee to decide what to do
08:49:27 <amx> jdegoes what something about the binary case some time ago: https://github.com/jdegoes/jdegoes.github.io/blob/master/_posts/2016-07-16-destroy-all-ifs.md
09:01:32 <ertesx> kirillow: HaveDrink, the abstraction, has nothing to do with drinks or ordering…  it's an abstraction for string functions of strings
09:02:55 <kirillow> Aah!
09:03:47 <ertesx> kirillow: if you receive a HaveDrink, you don't know anything about that value…  it may be 'reverse' or (const "the lambda, the lambda and the name, name, name, name…")
09:04:14 <ertesx> if you receive a HaveDrinkAlt, you know it can really only be one of three things
09:04:19 <ertesx> that's super-specific
09:05:57 <younder> a type being named as a verb.. hrm
09:32:03 <umib0zu> Hey all does anyone work on the hackage-server?
09:32:29 <sm> umib0zu: they hang out in #hackage
09:32:42 <umib0zu> I’ll ping them. Thanks sm
09:57:27 <jmcarthur> I'm looking for a mutable bag implementation with something like a doubly linked list representation for O(1) additions and deletions. I'm having trouble finding anything decent. Does anybody know of one?
09:57:44 <jmcarthur> I basically just need addition, deletion, and iteration.
09:58:23 <younder> I have a question concerning the use of IVar's  outside of runPar.  http://lpaste.net/316333
09:59:36 <jmcarthur> younder: Doesn't look like anything has happened along those lines: https://hackage.haskell.org/package/monad-par-0.3.4.8/docs/Control-Monad-Par.html#v:runPar
10:19:02 <Monoide> I do have another question, I created a new type, with
10:19:13 <Monoide> data Stuff = Stuff lots_of_lines
10:19:30 <Monoide> is there a canonical way to make a Stuff object from a list ?
10:20:21 <Tuplanolla> How do you want that to work?
10:20:44 <Boomerang> Are all the fields of Stuff of the same type?
10:20:45 <Monoide> let's make a simple example: data Stuff = Stuff int int
10:20:52 <Monoide> let's make a simple example: data Stuff = Stuff int Char *
10:21:12 <Monoide> no, first example, same type indeed, Stuff Int Int
10:21:19 <Monoide> I do have l == [3, 4]
10:21:27 <Boomerang> Since you can't have lists with different types inside your second example is not possible
10:21:32 <Monoide> I would like to create something of type Stuff from this list
10:21:36 <Tuplanolla> Lenses might provide a way to do this.
10:21:54 <younder> From RWH we have the JSON parser. Something along those lines?
10:22:35 <Monoide> Tuplanolla: ok I am going to have a look at Lenses, ty
10:23:41 <Boomerang> you could make a simple function to do that: construct :: [Int] -> Stuff; construct [a,b,c] = Stuff a b c
10:23:55 <Boomerang> (That's for a Stuff Int Int Int)
10:24:08 <Monoide> but I have around 15 fields
10:24:19 <Monoide> I am not sure i want to do construct [a, b, c, d, ...]
10:24:26 <Monoide> but indeed it is what I had so far
10:25:13 <Tuplanolla> This might also be possible with generics.
10:26:23 <joneshf-laptop> Oh! I think i might get it. Moore/Mealy are more useful as a construct than DFA/NFA/RE because they give some output value as they are running, and they can give a value at the end.
10:26:26 <joneshf-laptop> Is that right?
10:28:27 <haskell284> hey guys, when we say deriving (Show) or deriving (Shoe, Eq) etc. after defining data, what does that mean?
10:28:59 <lyxia> joneshf-laptop: they're also not restricted to finite state machines
10:29:10 <ab9rf> haskell284: it tells the compiler to synthesize Show and Eq instances for the type you just defined, using standard rules for doing so
10:30:50 <Tuplanolla> Is there a command to show the generated source code?
10:31:00 <haskell284> ab9rf: so when we have deriving Eq, we can compare the data.When we have Show, that means we can print the data??
10:31:00 <Tuplanolla> I recall something like that existing.
10:31:04 <MarcelineVQ> generated from what?
10:31:11 <lyxia> joneshf-laptop: oh, I was saying that only looking at the types, though the underlying formal concept are finite state machines... nevermind.
10:31:45 <Tuplanolla> From `deriving`, as ab9rf said, MarcelineVQ.
10:31:47 <ab9rf> haskell284: basically, yes. 
10:32:43 <MarcelineVQ> oh,-ddump-deriv
10:33:01 <Tuplanolla> Oh, that was it.
10:34:14 <ab9rf> haskell284: Eq only allows for comparisons for equality. if you want to compare more generally, you need Ord
10:34:35 <haskell284> ab9rf: Can you give an example that prohibits doing sthm with defined data type if we don't do deriving (Show)? I especially want to see how deriving (Show) helps that I have been doing without even knowing.
10:36:09 <ab9rf> haskell284: all that deriving Show does is make the "show" method available, allowing you to convert values of that type into strings
10:37:29 <ab9rf> the ghci repl automatically calls show on the result of each computation requested, so if you use the repl to compute a value that isn't an instance of Show, you get an annoying error message instead of the result youw ant
10:38:01 <ab9rf> in compiled code, you really only need Show instances on things that you might want to convert to text in order to display them or to use in some other way
10:44:12 <EvanR> Show in retrospect is a bit of a pain in the ass
10:44:48 <EvanR> its supposed to form an inverse with Read so you get a serialization mechanism that no one recommends using
10:45:06 <EvanR> its for debugging but it would be more useful if everything had some sort of debug output
10:45:23 <EvanR> its decidedly not for pretty printing
10:47:01 <sm> ab9rf: which if you'll be debugging, is pretty much everything :)
10:47:51 <sm> but pretty-show kind of saves the day, as it prettifies "standard" Show output
10:48:42 <Tuplanolla> The `Read`--`Show` thing feels like a lazy attempt at attracting Lisp folks.
10:48:49 <EvanR> yeah
10:49:16 <ab9rf> sm: yip
10:49:50 <EvanR> a lot of simple data types, for demonstration are deriving one class, Show
10:49:59 <ab9rf> i find that i don't derive Show until i need to debug on that type :)
10:50:09 <EvanR> or anything that contains it...
10:50:32 <monochrom> the irony of show is that it works perfectly for pretty-printing numbers for humans
10:50:32 <EvanR> -XAutoDeriveShow
10:51:07 <ab9rf> auto-deriving show just makes your resulting compilatins take a tiny bit longer :)
10:51:25 <monochrom> and then there is a subtle psychology of programmers about "if it suits number types, it suits all types"
10:51:27 <EvanR> no it wont
10:51:48 <monochrom> "because afterall what other types are there anyway except numbers and chars"
10:52:06 <ab9rf> after all everyting is a number anyway!
10:52:14 <Tuplanolla> Is there a type class for converting the entire program into a big natural number?
10:52:17 <EvanR> i guess it does have to check that all these types cant have a show instance anyway... better idea derive show for those anyway, "<the typeable output>"
10:52:35 <ab9rf> Tuplanolla: that's what the compiler does
10:52:39 <monochrom> Turing used to maintain the code for that type class
10:53:15 <ab9rf> from one standpoint, the source code is just one really big number, ahd the compiler is a complicated algorithm for turning it into a different really big number
10:53:16 <monochrom> "w00t so now questions about programs become questions about numbers!"
10:53:32 <EvanR> from more than one standpoint
10:53:42 <EvanR> you can encode many things in many ways into the numbers
10:53:45 <cite-reader> "First encode all programs in the Goedel numbering,"
10:54:13 <kadoban> "Then figure out how to type that weird o with the dots" ... a much harder problem.
10:54:21 <ab9rf> they're already encoded in the Unicode numbering :)
10:56:29 <monochrom> the Gödel number of Gödel is 2^71 * 3^246 * 5^100 * 7^101 * 11^108
10:56:47 <monochrom> Exercise: is it a prime number? :)
10:57:13 <cite-reader> Hold on let me get my general number field sieve
10:57:14 <EvanR> obv not
10:57:27 <kadoban> monochrom: I hope not
10:58:08 <monochrom> hehe I love the general number field sieve
10:58:32 <Tuplanolla> Does Haskell have an implementation of it?
11:05:04 <Cale> Better exercise: Is its successor a prime number?
11:05:19 <Tuplanolla> I know what to suggest the next time someone asks for a project idea.
11:05:25 <ab9rf> heh
11:06:19 <Tuplanolla> Risch integration is another one, but it's not suitable until we have the basis to build it on.
11:06:20 <EvanR> Cale: no
11:06:26 <Cale> Correct :)
11:06:36 <orion> Adding support for linear types would be a great weekend project.
11:06:37 <EvanR> \o/
11:06:40 <Monoide> answer: no
11:06:50 <Monoide> oups someone got it faster ;(
11:07:15 <implementation> how did you find out?
11:07:19 <EvanR> dont ask me why though, the computer said so
11:07:24 <Cale> It's divisible by 13
11:07:50 <Monoide> Cale: no
11:08:03 <kadoban> Ya, "is it prime?" is a bad question, you gotta make people give you at least one factor, otherwise it's too easy to guess "no" and be right most of the time ;)
11:08:14 <Monoide> yes, sorry *
11:08:37 <Monoide> euh, no* :d
11:14:01 <heebo> lo
11:14:37 <heebo> can anyone run the following code and tell me what results they get for a Map vs Associated list performance comparison
11:15:09 <heebo> https://github.com/gregnwosu/haskellbook/blob/master/chapter28/src/mapcompare.hs
11:15:38 <heebo> because my results show lookups for associated lists being faster than maps according to criterion , which is not what i expected
11:16:09 <Cale> Monoide: It's 13 * 2255939627193095515490640...923076923076923076923077, this second factor is not prime, but I can't extract a factor from it in a timely fashion.
11:16:18 <EvanR> heebo: well, you first have to construct the Map
11:16:31 <EvanR> which involves traversing the whole list of key value pairs
11:16:35 <kadoban> heebo: Well, the Map thing is doing all of the work the list thing is doing, and more, isn't it?
11:16:58 <EvanR> for a fair comparison construct the map completely then test
11:17:10 <heebo> kadoban: and more?
11:17:12 <Monoide> Cale: I get that it is 11 modulo 13
11:17:22 <Monoide> maybe we are not looking at the same number ;)
11:17:33 <Cale> 2^71 * 3^246 * 5^100 * 7^101 * 11^108 + 1
11:17:43 <Monoide> the successor of the «Gödel» number is divisible by 13 indeed
11:17:52 <Monoide> but it is not the successor of a divisible by 13 number
11:17:53 <kadoban> heebo: Same as what EvanR is saying I believe, but ... building the Map is extra work. And for only one lookup it can't really pay for itself.
11:17:59 <mauke> > (2^71 * 3^246 * 5^100 * 7^101 * 11^108 + 1) `rem` 13
11:18:01 <lambdabot>  0
11:18:11 <Cale> oh, clearly 2^71 * 3^246 * 5^100 * 7^101 * 11^108 is not divisible by 13
11:18:18 <Cale> We're staring at its prime factorisation
11:18:18 <EvanR> i figured Criterion is doing the test many times
11:18:19 <Monoide> oh my bad, I read «is it the successor of a prime number»
11:18:26 <mauke> > (2^71 * 3^246 * 5^100 * 7^101 * 11^108) `rem` 13
11:18:28 <lambdabot>  12
11:18:29 <EvanR> but if each time its building a new mpa, thats silly
11:20:01 <Cale> The predecessor of 2^71 * 3^246 * 5^100 * 7^101 * 11^108 is harder to factor
11:20:15 <heebo> pairList should be cached no?
11:20:16 * hexagoxel realizes that fmap and mapM unify after it broke stuff after refactoring. meh.
11:20:24 <Cale> (but it is also not prime)
11:20:56 <Monoide> Cale: yes, I actually couldn't find any factor in a reasonable time
11:21:09 <Monoide> but it is really easy to get that it is not a prime neither
11:21:45 <EvanR> heebo: arrange for the Data.Map to be "cached"
11:22:07 <EvanR> let m = fromList hugeList in bench ...
11:22:21 <heebo> EvanR thanks
11:22:50 <EvanR> and test strict vs lazy Map
11:23:05 <EvanR> then test HashMap hehe
11:24:58 <haskell284> what does deriving (Enum) do?
11:25:28 <EvanR> numbers the constructors
11:26:52 <adelbertc> out of curiosity are there any explorations into having the MTL-y classes (Monad{Reader, Writer, State, Error}) separate from Monad but still having laws with them? I think you can do it with Reader where you say `local id ask = ask`, but doesn't look like you can do it with Writer State or Error
11:27:05 <haskell284> :EvanR what happens if we don't use deriving (Enum)? can you show or refer to an example?
11:28:01 <EvanR> then you cant use Enum operations
11:28:06 <kadoban> haskell284: Without that, it won't be an instance of the Enum typeclass. The Enum typeclass provides "succ" (get the next value from a current one) "pred" (get the previous value from a current one), and toEnum/fromEnum which converts between an Int and an Enum a
11:28:27 <kadoban> Oh also allows you to use the uhm [blah .. whatever] sugar and other stuff.
11:28:36 <Cale> haskell284: Enum lets you use the [x..y] and associated list syntaxes, toEnum, fromEnum, succ and pred
11:28:58 <haskell284> Cale: Thanks.
11:29:03 <Cale> Mostly, I tend to think of the main bit being the list syntax sugar
11:29:22 <EvanR> toNum and fromEnum...
11:29:31 <EvanR> toEnum
11:30:03 <kadoban> It still annoys me that toEnum and fromEnum use Int :-/ Though it probably never matters.
11:30:10 <haskell284> As I'm learning, I see if I don't associate what I learn to some practical usage then I forget.That's why decided to learn the usage along with theory.
11:30:28 <kadoban> Seems like a very good idea.
11:30:29 <EvanR> heres one place it matters
11:31:00 <Cale> kadoban: In one sense it can't matter because you'll be limited in the number of constructors allowed for a type long before you'll run out of Int values.
11:31:05 <haskell284> And you guys are always here so I'll keep bothering along my learning experience :)
11:31:07 <EvanR> > toEnum (fromEnum maxBound + 1) :: Int
11:31:09 <lambdabot>  error:
11:31:09 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘fromEnum’
11:31:09 <lambdabot>        prevents the constraint ‘(Enum a0)’ from being solved.
11:31:11 <Cale> But in another sense, it can cause other things to have type Int by accident
11:31:19 <EvanR> Int is Enum ;)
11:31:21 <Cale> and that can result in loss of precision
11:31:29 <EvanR> and so is Integer
11:32:28 <kadoban> Hmm, that's true, not like you're going to have a .hs file that's 20 GB of just constructors, so it's not going to come up too often, heh.
11:32:54 <Cale> > maxBound :: Int
11:32:55 <lambdabot>  9223372036854775807
11:33:17 <Cale> ^^ Even harder to hit the limit on a 64 bit machine
11:34:06 <EvanR> > fromEnum 9223372036854775808
11:34:08 <lambdabot>  -9223372036854775808
11:34:10 <Cale> Though yeah, Integer is an instance of Enum, and it doesn't really behave too well
11:34:18 <kadoban> Yeah :-/
11:34:39 <kadoban> > succ 9223372036854775808
11:34:40 <lambdabot>  9223372036854775809
11:34:46 <ph88> there was somewhere a blog or page about concurrent and parallel programming .. and then in the later sections it even talks about gpu programming .. does someone know the link ?
11:34:49 <EvanR> breakin the law brekain the law
11:35:08 <kadoban> ph88: This? http://chimera.labs.oreilly.com/books/1230000000929/index.html
11:36:25 <ph88> ah yes i believe that's it !
11:37:11 <ph88> nice that it is also written by someone with authority
11:38:20 <ab9rf> RESPECT MAH AUTHRITAH
11:39:07 <mauke> > abs minBound :: Int
11:39:09 <lambdabot>  -9223372036854775808
11:39:11 <ph88> :D
11:39:25 <kadoban> mauke: Haha
11:39:27 <EvanR> jeebus
11:40:01 <EvanR> is that normal ?
11:40:05 * EvanR tries C
11:40:19 <mauke> you used to be able to crash ghci with SIGFPE by doing minBound `div` (-1) :: Int
11:40:29 <ab9rf> heh
11:40:37 <hpc> EvanR: that result is equal to 0 - (-9223372036854775808)
11:41:13 <kadoban> mauke: That's just amazingly horrible stated that way, the abs thing. Quite an expression.
11:44:01 * hackagebot rattletrap 0.1.4 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-0.1.4 (fozworth)
11:45:15 <EvanR> i see the same thing in C
11:45:23 <EvanR> abs is broken!
11:45:47 <ertesx> blame Int for having more negative numbers than positive numbers
11:46:13 <EvanR> if it was the other way around, abs would work, but i might be even more confused
11:46:41 <cite-reader> Yeah, we should be using sign-and-magnitude representations. "But then you have two zeroes" shoosh.
11:47:58 <kadoban> Having two zeros isn't too too bad. But 2s complement really simplifies some operations in nice ways :-/
11:48:49 <ertesx> newtype Co a = Co { fromCo :: a }; instance (Num a) => Num (Co a) where Co x + Co y = x + y - 1; …; fromInteger x = Co (1 - fromInteger x)
11:50:59 <ertesx> whoops…  there is a Co missing
11:51:07 <ertesx> Co x + Co y = Co (x + y - 1)
11:51:13 <ertesx> Co x * Co y = Co (x + y - x*y)
11:54:44 <EvanR> what form of dark magic are we looking at
11:56:33 <ertesx> i'm just making things worse
11:57:26 <yulax> i have a question
11:57:46 <yulax> in this task we are given the following:
11:59:40 <yulax> http://paste.debian.net/hidden/f19e151c/
11:59:53 <yulax> this is a type Fruit where we have oranges and apples
12:01:08 <yulax> we have a task "isBloodOrange" where we work out if a fruit is a blood orange
12:01:10 <yulax> here:
12:02:47 <pavonia> yulax: How is a blood orange defined?
12:02:57 <yulax> http://paste.debian.net/hidden/2b6e365f/
12:03:13 <yulax> (sorry for the long gap between messages, my client went strange)
12:03:52 <pavonia> Okay, what's the question?
12:03:53 <yulax> the error is Parse error on pattern: fruittype
12:04:12 <cite-reader> Yeah, because you're trying to destructure an Int.
12:04:18 <cite-reader> That's not going to work really well.
12:04:49 <yulax> all right, my question is, how can we sort between types so that false is raised when i put in Apple?
12:04:59 <ertes> yulax: have you written the 'not' function?
12:05:07 <pavonia> yulax: You can't use a variable to match on a constructor like this, you have to handle both cases separately
12:05:15 <ertes> yulax: not :: Bool -> Bool
12:05:23 <ertes> yulax: if not, write it now
12:05:30 <ertes> call it myNot
12:06:41 <Clint> what the
12:06:46 <yulax> right
12:06:49 <yulax> not is written
12:07:09 <yulax> what is the relevance to the task, i wonder?
12:07:41 <ertes> yulax: so, given your implementation of not, compared to the way you tried to implement isBloodOrange, you would have written it like this:  not x | x == False = True; otherwise = False
12:08:02 <ertes> yulax: but i'm pretty sure you wrote it this way:  not False = True; not True = False
12:08:08 <ertes> s/not/myNot/ of course
12:08:23 <ertes> do you see the relevance?
12:08:31 <yulax> ertes: yes, that is how i wrote it.
12:09:24 <Clint> yulax: are you passing a Fruit to isBloodOrange?
12:09:25 <ertes> yulax: you don't *compare* against constructors (isBloodOrange (x y z) | x == …), you *match* against them (isBloodOrange (Orange variety n) = …
12:09:26 <ertes> )
12:09:42 <yulax> i sort of see - i could write if something is not the right variety and type, then false>
12:09:44 <yulax> ?
12:11:10 <ertes> yulax: are you familiar with Maybe?
12:11:26 <yulax> ertes: Maybe?
12:11:31 <ertes> the type
12:12:08 <yulax> i don't understand what you are referring to, sorry.
12:12:30 <ertes> ok, then nevermind…  first of all, did you fix the type signature; cite-reader told you what's wrong with it
12:14:17 <polo> Hi, In my following code, I'm always getting "combat too long" but I should get other String values as well.It's in "t1Turn" and "t2Turn" functions.http://lpaste.net/294377
12:16:34 <yulax> right, so i shouldn't be destructuring Ints.
12:17:53 <yulax> i see, i should be doing this for apple as well as orange
12:18:42 <ertes> yulax: no, before you change anything else, fix line 1
12:18:45 <ertes> the type signature
12:18:52 <yulax> (not *this*, but i should be making the function take specific paths for Fruit that is Apple and Fruit that is Orange etc..
12:19:06 <michalrus> Hey, I can’t seem to find an analogue of the `info` function from ScalaTest in Tasty/HUnit. What it does is simply outputting a given String to the terminal under current test’s name. What would be the best way to do this?
12:20:05 <SrPx> Is there any common name for the type of things with an initial state and a way to update that state based in a type of actions? data Foo state action = Foo {init :: state, next :: state -> action -> action}
12:20:09 <joneshf-laptop> michalrus, have you tried hayoo/hoogle?
12:20:56 <mauke> polo: tl;dr
12:20:57 <heebo> so it seems that  lookup  on an associative list is faster than map for lists that arent small, I guess the compare operations start to add up together with the inability to prefetch memory....., the hashmap implementation is faster than associative lists for larger lists however
12:21:01 <joneshf-laptop> ertes, That was an incredible analysis of how to explain the pattern matching concern!
12:21:03 <heebo> still im surprised
12:22:00 <polo> mauke: t1; dr means?
12:22:03 <ajf> Can you relocate a cabal sandbox without it blowing up?
12:22:08 <michalrus> joneshf-laptop: Hayoo not, Hoogle yes, but I have no idea what to type in. THere’s `assertString` with a correct type, but it fails the whole test.
12:22:26 <Tuplanolla> How about "pointed state transformer", SrPx?
12:23:01 <michalrus> joneshf-laptop: got it from Hayoo, thank you. :)
12:23:07 <michalrus> `testCaseInfo`.
12:23:22 <SrPx> Tuplanolla couldn't find anything on Google about that? I'm asking if it is a common pattern and if there is a better way to represent it (e.g., is there any relation between this and FRP? Monads?)
12:23:45 <joneshf-laptop> michalrus, Great!
12:24:02 <ertes> joneshf-laptop: was that literal or sarcastic? ;)
12:24:21 <joneshf-laptop> ertes, literal
12:24:27 <mauke> polo: too long; didn't read
12:24:44 <Tuplanolla> I don't know if there's a common name for it, but that's the one I'd use, SrPx.
12:25:03 <joneshf-laptop> ertes, I didn't see how you were going to connect `not` to their problem. But then you did it!
12:25:03 <c_wraith> SrPx: looks like a moore machine
12:25:04 <ertes> SrPx: sounds like automata to me…  slight relation to FRP (FRP being a way to implement automata, and automata being a way to implement FRP)
12:25:17 <ertes> joneshf-laptop: ok, thanks =)
12:25:33 <c_wraith> SrPx: https://hackage.haskell.org/package/machines-0.6.1/docs/Data-Machine-Moore.html  looks vaguely like one of these
12:25:40 <polo> mauke: It didn't read too long for you?
12:25:43 <EvanR> just read the push pull FRP paper again, not much to do with automata ;)
12:26:05 <ertes> EvanR: event scans are basically automata
12:26:14 <ertes> and AFRP is FRP based on automata
12:27:57 <kosmikus> polo: there are lots of stylistic issues with your code. but one problem seems to be is that with your code, "runTurn x y == y"
12:28:02 <joneshf-laptop> SrPx, do you actually have `data Foo s a = Foo { init :: s, next :: s -> a -> a}` or do you have `data Foo s a = Foo { init :: s, next :: s -> a -> s}`? if the former, I'd love to know more details about it.
12:28:12 <joneshf-laptop> SrPx, I don't think i've seen that approach yet.
12:28:13 <kosmikus> polo: so nothing ever changes
12:28:21 <EvanR> automata arent composable at all
12:28:24 <kosmikus> polo: except for the combat turn counter to increase
12:28:26 <ertes> SrPx: also i think the type of 'next' is wrong
12:28:48 <ertes> SrPx: pretty sure you meant:  next :: action -> state -> state
12:29:01 <SrPx> ertes woops yep
12:29:02 <EvanR> and you usually dont have things happening in between automata steps 
12:29:04 <ertes> EvanR: the automaton arrow composes automata
12:29:14 <ertes> mealy machines to be precise
12:29:28 <EvanR> yeah thats an entirely different thing 
12:29:38 <joneshf-laptop> EvanR, what do you mean by composable?
12:29:43 <EvanR> state machines have nothing to do with composable continuous animations
12:29:45 <SrPx> joneshf-laptop but that makes no sense 
12:30:06 <EvanR> joneshf-laptop: you cna take 2 things and put them together to get a third thing in a non trivial way
12:30:17 <EvanR> (and then take them apart again easily)
12:30:37 <c_wraith> Decomposable isn't a required part of composable
12:30:49 <c_wraith> I mean, it's really hard to disassemble an IO action. :P
12:30:53 <joneshf-laptop> yeah
12:30:56 <ertes> or even just a sum
12:30:58 <EvanR> it isnt, th efree monad sense
12:31:08 <ertes> 10 has no relation to 3 and 7
12:31:14 <joneshf-laptop> EvanR, and what do you mean by automata?
12:31:18 <EvanR> adition isnt composition in this sense 
12:31:25 <ertes> it isn't?
12:31:30 <EvanR> in the haskell sense , you want to be able to take stuff apart again and rearrange it
12:31:38 <c_wraith> Even the free monad sense doesn't end up in a pleasant place, because you end up in existential land, never knowing what your concrete types were.
12:31:56 <ertes> EvanR: sometimes, sure, but i wouldn't make that a mandatory requirement of *composability*
12:32:11 <EvanR> if you combine two state machines by rewriting each table carefully, there is no going back, maintenance wise
12:32:14 <ertes> to me things like Category, Monad and Monoid are composition
12:32:38 <ertes> and none of these allow decomposition
12:32:54 <EvanR> yes, the free monoid is the most composable because you can see what happened and analyze it
12:33:02 <EvanR> and rearrange it
12:33:19 <c_wraith> EvanR: not in Haskell!  In Haskell, the real free monoid is an existential.
12:33:26 <EvanR> eh?
12:33:33 <c_wraith> :t foldMap
12:33:34 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
12:33:55 <EvanR> nah, if you are giving an arbitrary list of A, you can see all the details
12:34:04 <EvanR> not some arbitrary view of a list
12:34:08 <c_wraith> EvanR: not if the list is infinite, and you have to consider that in haskell
12:34:41 <c_wraith> EvanR: when you do, you find that forall m. Monoid m => (a -> m) -> m  is the free monoid in a
12:34:47 <EvanR> infinite data shouldnt be considered a reason to dump this idea of composability
12:35:20 <ertes> you're talking about something much stronger than composability
12:35:33 <ertes> do you think IO is not composable?
12:35:42 <S11001001> EvanR: http://comonad.com/reader/2015/free-monoids-in-haskell/
12:36:48 <S11001001> cc dolio
12:39:10 <EvanR> so when you talk about composabilit in a library, you dont think about your sourc e code collapsing into a view of itself that you cant come back from
12:39:33 <EvanR> this tends to happen in imperative languages , and it turns projects into a big ball of mud
12:39:46 <ertes> c_wraith: i didn't know that, thanks for the link!
12:39:57 <c_wraith> ertes: S11001001 gave the link. :)
12:40:02 <ertes> whoops
12:40:16 <c_wraith> But yeah, that's the article, I was thinking of.  So thanks to S11001001 for digging it up. :)
12:40:31 <ertes> c_wraith: thanks for telling me that [] is not the free monoid constructor
12:40:34 <ertes> S11001001: thanks for the link
12:40:34 <ertes> =)
12:40:48 <S11001001> :]
12:41:04 <ertes> just today in the earlier discussion about Foldable i actually made the mistake to refer to Foldable as the ToList class =)
12:41:31 <ertes> EvanR: i don't really think of composability as a source language feature, but as a feature of the DSL
12:41:40 <ertes> with no *direct* source code relationship
12:42:54 <younder> I suppose could say composabillity is what category theory is all about.
12:43:04 <ertes> it's a matter of building complex meaning from simple parts, and to some extent equational reasoning about it
12:43:16 <ertes> s/simple/simpler/
12:45:45 <amx> data SL a = Empty | SL a :> a  -- where is (:>) coming from?
12:46:04 <c_wraith> amx: it's being defined right there
12:46:09 <c_wraith> amx: as an infix data constructor
12:46:14 <amx> awesome
12:46:22 <amx> never seen that before
12:46:37 <c_wraith> amx: yeah, any operator starting with : is considered a data constructor
12:46:57 <c_wraith> amx: just like values with names starting with capital letters are data constructors
12:49:14 <EvanR> ertes: these are not good arguments for thinking of FRP as mealy machines
12:50:30 <EvanR> infinite lists arent good reasons to limit the interpretation of the word composable to an assoc typed binary operation which may or may not be reversible or analyzable
12:50:33 <Philonous> @paste
12:50:33 <lambdabot> Haskell pastebin: http://lpaste.net/
12:51:19 <EvanR> gem install whatever isnt really composable, you do it and the project is stuck at whatever th original designer decided was the only way you could use the code
12:51:32 <Philonous> I'm getting a pretty weird warning about non-exhausting pattern matches in the presence of guards: http://lpaste.net/316443 
12:51:42 <c_wraith> EvanR: Ok, let's all agree the property you want is nice.  But let's also agree on terminology.  Composable means something specific.  What you are describing is stronger.
12:51:44 <EvanR> you can instlal however many gems you want, but it wont be composable
12:51:46 <Philonous> Should I report this as a bug in GHC or is this somehow expected?
12:52:04 <c_wraith> EvanR: Composable means "you can put things like this together to get a thing like this"
12:52:11 <c_wraith> EvanR: nothing about dissassembly.
12:52:14 <EvanR> c_wraith: i dont agree that "composable" means something specific
12:52:15 <Tuplanolla> It's not a bug, Philonous.
12:53:01 <EvanR> state machines still arent composable in any way weve seen so far
12:53:03 <Philonous> Well, first of all, I'm not matching #i, but Int, and second the values it gives are actually matched, so I'm surprised
12:53:46 <EvanR> OOP objects are composable, but they end up in balls of mud anyway
12:53:58 <EvanR> so i think theres something else besides "put things in a bag togther"
12:54:08 <c_wraith> EvanR: sure they are.  It's easy to compose machines that act like arrows from a -> b and b -> c into a machine that acts like an arrow from a -> c.  That's the category instance on everything in Machines
12:54:15 <Tuplanolla> It's possible to perform exhaustiveness analysis on this piece of code, but not in general, Philonous.
12:54:23 <ertes> EvanR: hmm?  the composability stuff isn't related to the FRP note i made earlier (and no, i don't think of FRP as mealy machines, because that would be non-sensical…  mealy machines are one possible way to implement FRP though, which is precisely what AFRP is)
12:54:49 <Philonous> Tuplanolla, Well, at the very least, the warning message is really bad. 
12:55:21 <EvanR> i reacted to "FRP is related to machines, you can implement machines with FRP"
12:55:46 <EvanR> and based on my reading of this paper here, it seems totally unrelated
12:56:03 <ertes> EvanR: asssociativity is a very important notion when it comes to composability, because it enforces a kind of "locality"
12:56:41 <ertes> composition cannot discriminate between the individual parts in any "unnatural" way
12:57:08 <EvanR> if its important, then seems like you want to call the property of your library "associatable"
12:57:20 <EvanR> but we dont, because we like the othe rword more
12:57:27 <ertes> i want to call it "semigroup(oid)"
12:57:39 <MarcelineVQ> Philonous: It is oddly specific, my error isn't quite the same but it's equally arcane,  "Patterns not matched: p where p is not one of {1}" it's because you used 1 as your second case and 1 doesn't have constructors in the same way as other datatypes, I would think
12:57:41 <EvanR> yeah so then we get more specific
12:57:53 <ertes> "composability" is an informal notion, which is probably the reason we're arguing about it here
12:57:57 <EvanR> but haskell wiki and general talking confirms composable is more general than that
12:58:01 <EvanR> or more vague
12:58:11 <MarcelineVQ> as in, there isn't a data Int = 1 | 2 | 3 | 4 ...
12:58:25 <Tuplanolla> I don't think that's the problem, MarcelineVQ.
12:59:02 <ertes> i actually think of (+) on Integer as composition…  you don't have to agree about it, of course
12:59:58 <EvanR> not in the library sense
13:00:58 <Tuplanolla> This is also nonexhaustive, regardless of order: `f x | isJust x = 1; f Nothing = 0`
13:01:04 <EvanR> doing that loses information, you need to do work to reverse it, like cryptaanalysis
13:01:11 <Philonous> Ah, I# is the Int data constructor
13:01:15 <geekosaur> yes
13:01:24 <geekosaur> and I'd say this is a bug, yes
13:01:55 <Tuplanolla> Why? You could express the halting problem inside a pattern guard.
13:02:04 <ertes> EvanR: you can't reverse it, and yes, composition is very commonly a lossy operation…  just look at the original "composition":  (.) on functions
13:02:10 <geekosaur> at a guess, the exhaustiveness checker was written with an unwarranted assumption that the more specific ones would come first
13:02:25 <geekosaur> (probably not deliberately, just someone not considering all the possibilities)
13:02:51 <EvanR> ertes: heh, yeah, . you look at it, it consists of the original two functions together ;)
13:03:17 <EvanR> perhaps not after optimizations though
13:03:33 <ertes> EvanR: f . g tells you nothing about f and g
13:03:34 <Tuplanolla> How would you check that, geekosaur?
13:04:07 <ertes> EvanR: in fact (.) is incredibly similar to (+)
13:04:13 <EvanR> f . g x = f (g x)
13:04:13 <hpc> it tells you their type begins with (->) :P
13:04:22 <hpc> *types
13:04:36 <EvanR> nothing mysterious going on
13:04:38 <ertes> EvanR: yes, that's the definition (modulo a minor typo)
13:05:33 <ertes> EvanR: but if i give you a function h = f . g and ask you to tell me something about f (which means: write a function that takes the h and extracts some information about f), you will find that task unsolvable
13:06:13 <EvanR> its a different issue that functions are opaque, composition or not
13:06:29 <EvanR> if functions had structure you could even programmatically tell something about f
13:06:46 <geekosaur> Tuplanolla, the point is that it's reporting it in a confusing way, not that it's expected to handle all cases
13:06:56 <MarcelineVQ> Tuplanolla: Yes but it's not trying to tell you about GHC internals, I just meant the weirdness of the error is likely caused by matching on Int
13:06:57 <EvanR> from h
13:06:58 <Tuplanolla> Oh, that I can agree with.
13:07:08 <ertes> is it?  if you look at the source code and see 3 + 7, of course you know how that 10 came to be, but you can't write a function that receives 10 and extracts information that would even hint at the original 3
13:07:19 <geekosaur> if you reorder the cases, you get a more sensible warnin
13:07:27 <geekosaur> and that is the bug
13:07:34 <ertes> and (.) is just the same for functions…  you can look at code and tell all sorts of things, but you can't look at a *function* and do that
13:07:45 <MarcelineVQ> fwiw the error isn't anything like that on my ghc in either order
13:08:02 <geekosaur> what version?
13:08:20 <MarcelineVQ> 8.0.1
13:08:22 <geekosaur> I get that warning with 7.10. 8.0 completely redid the exhaustiveness checker, so this may well already be fixed
13:08:58 <geekosaur> (remember that 8.0.1 was delayed for months because the rewritten checker had exponential performance)
13:10:04 <Philonous> geekosaur, Btw, any thoughts on https://github.com/xmonad/xmonad/pull/53 ? :)
13:11:19 * geekosaur hasn't looked yet n the grounds that days when he can think straight enough have been few and far between of late :/
13:12:32 <Philonous> geekosaur, Oh, sorry to hear that. It's not urgent, just didn't want it to get lost in the sands of time :)
13:17:27 <ph88> hi guys, can anyone explain this sentence "The operations are too fine-grained here to use a simple parMap or parList as we did before; the overhead of the parMap will swamp the parallelism" in http://chimera.labs.oreilly.com/books/1230000000929/ch03.html
13:20:31 <cite-reader> What do you find confusing?
13:20:44 <Philonous> ph88, parMap creates a spark for every element of the list. If the work to be done on each element is small, the overhead for parallelizing them is greater than the performance you gain from parallel evaluation
13:23:12 <ph88> ok thx
13:23:13 <ph88> back later :)
13:29:29 <slice> Is there any data structure in Haskell that can do `elem` faster than `elem n [n..]`?
13:29:55 <lyxia> True
13:30:04 <hpc> what part of the expression [n..] do you want this other data structure to capture?
13:30:23 <hpc> also i assume you meant elem n [m..]?
13:30:27 <slice> hpc: not literally [n..]
13:30:56 <geekosaur> slice, the context in which you need this may matter
13:30:58 <slice> hpc: I just mean: I have a loop. Each time I go through the loop I create a new list: oldList ++ [newItem]
13:31:08 <geekosaur> urgh
13:31:10 <Philonous> slice, It depends. You can always use a set for O(log n) lookup
13:31:26 <geekosaur> slice, that arrangement is close to pessimal
13:31:49 <geekosaur> if nothing else, consider reversing the list.
13:31:54 <slice> geekosaur: for `elem []`, yeah
13:32:21 <slice> geekosaur: I mean. All I need to do is end my recursion when my list has a duplicate item.
13:32:28 <geekosaur> but depending on what exactly you're trying to do, there is Seq or Set or you can find types appropriate for ranges etc.
13:32:30 <sbrg> slice: what are you trying to solve? there are a bunch of different data-structures that give you faster lookup than linked lists(= haskell lists). 
13:32:30 <slice> geekosaur: is Data.Set best for this?
13:32:33 <geekosaur> that sounds like you want Set
13:33:35 <geekosaur> but if you have a number of consecutive ranges, iirc there are packages for efficient operations involving ranges
13:33:39 <slice> geekosaur: and `member`?
13:34:31 <sbrg> Data.Set.member is O(log n)
13:40:17 <slice> Since all my items are integers, Wouldn't it be faster to have an array and only set the indices I want to (True).
13:40:23 <slice> and the rest to False
13:40:36 <slice> Then just lookup that index in the array
13:45:15 <monochrom> that depends on how large your array is. recall that if your array is larger than your cache, you will incur main-memory slowness too.
13:45:54 <slice> monochrom: right
13:45:57 <slice> good
13:46:22 <monochrom> give up all hope. it is a lose-lose situation. :)
13:46:49 <monochrom> but IntMap and HashMap Int are good starting points
13:47:36 <monochrom> err, are there IntSet and HashSet?
13:47:51 <cite-reader> There's IntSet, at least.
13:47:56 <monochrom> yes, there are. start with them instead.
13:52:51 <ph88> phileas, how do i find out what is a good granularity ?
13:53:43 <sbrg> ph88: experimenting is probably the easiest way. 
13:56:10 <slice> What is the equivalent of a Rust vector in Haskell?
13:56:30 <Welkin> you mean like a C++ vector?
13:56:34 <cite-reader> It sorta depends on what parts you want.
13:56:34 <Welkin> never heard of a rust vector
13:56:52 <cite-reader> (Yes, Rust's vectors are quite similar to C++ std::vector.)
13:56:58 <Welkin> just use Vector
13:57:07 <Welkin> there are different types
13:57:21 <ph88> Welkin, rust is a programming language
13:57:22 <Welkin> Storable, Mutable, and standard (immutable)
13:57:29 <Welkin> ph88: yeah, I am not familiar with it though
13:57:45 <slice> Sets cut my run time down by half, but it's not nearly fast enough.
13:57:58 <slice> as fast as my rust code*
13:58:15 <slice> pretty interesting
13:58:17 <sbrg> slice: post your code, maybe?
13:58:27 <ph88> slice, used Vector.Unboxed for highest performance
13:58:51 <kadoban> slice: Tried IntSet ? (no idea what you're doing in particular)
13:59:47 <slice> http://lpaste.net/316456
14:01:24 <chris___> Does anyone know of a function like `FilePath -> Text.XML.Document` where `type FilePath = String`?
14:01:55 <slice> kadoban: IntSet is just slightly faster than Set
14:02:20 <slice> ph88: maybe I'll try that next. I need to learn what these are for.
14:02:33 <monochrom> where does Text.XML.Document come from?
14:02:41 <kadoban> slice: Is there an easy description of what this is computing?
14:02:52 <sbrg> project euler IIRC?
14:02:55 <slice> kadoban: https://projecteuler.net/problem=74
14:02:59 <Welkin> slice: unboxed types are proimitive types (like in c)
14:03:01 <srhb> chris___: Sounds like you want FilePath -> IO (Maybe Text) and then Text -> Maybe Text.XML.Document -- just compose those.
14:03:15 <srhb> chris___: To give you something to search for. :)
14:03:22 <Welkin> slice: you can skip the unobxing/reboxing step so it is faster
14:04:31 <ertes> why do i dislike the array library so much?
14:04:50 <monochrom> I will need to open your brain for that.
14:05:06 <srhb> chris___: It looks like it's already in the library you're using... http://hackage.haskell.org/package/xml-conduit-1.4.0/docs/Text-XML.html#v:readFile
14:05:08 <slice> monochrom: better not open it. could b a pandorabox
14:05:22 <monochrom> then I'll sandbox it :)
14:05:27 <slice> monochrom: *phew*
14:05:36 <ertes> my brain is coinductive anyway
14:06:13 <chris___> Ah yes I've tried that but get an error as I'd like to parse HTML rather then XML. I should have mentioned that.
14:07:26 <chris___> srhb: I'm able to get Document via a web request, but I'd like to get it directly from a file instead. 
14:10:34 <ertes> chris___: xml-conduit can only deal with XHTML, but the xmlhtml library can handle HTML, too
14:11:41 <ertes> chris___: since you're trying to parse HTML i assume that the markup is not under your control…  the tagsoup library can be extremely useful in that case
14:11:52 <ertes> it can handle all kinds of "almost-XML" and even "almost-HTML"
14:13:45 <chris___> Text.HTML.DOM.readFile is what I needed :) many thanks. 
14:14:07 <lpaste> miscyb pasted “curl ftp” at http://lpaste.net/316458
14:14:22 <miscyb> i'm trying to use the libcurl binding
14:14:40 <miscyb> but my files are coming out wrong when I download them with this
14:14:49 <miscyb> they are far too small and are missing stuff
14:15:02 <ph88> slice, what kind of performance are you getting at the moment ?
14:15:05 <miscyb> has anyone had success with this lib
14:15:36 <Welkin> miscyb: is the http content-type header set properly?
14:15:51 <miscyb> what should it be set to?
14:15:56 <slice> ph88: 17 seconds
14:15:59 <Welkin> I know I had this problem with uploading my files to my server recently using multipart/form-data
14:16:03 <slice> ph88: rust one runs in .73 seconds :-/
14:16:09 <slice> ph88: I really don't understand
14:16:13 <Welkin> I was missing the "boundary" attribute in the header, so the files were corrupted
14:16:27 <miscyb> Welkin: hmm i'll have to see what that does
14:16:30 <ph88> slice, use Unboxed types and you will give less pointers to resolve
14:16:52 <miscyb> i also tried this C example and it worked fine
14:16:54 <miscyb> https://curl.haxx.se/libcurl/c/ftpget.html
14:17:03 <miscyb> i'm pretty sure they do almost the same thing
14:17:24 <chris___> Does IRC have anything like channels / categories / groups? Or is everything just in this channel?
14:17:43 <kadoban> chris___: Ya, IRC has channels xD
14:17:58 <younder> Theres a math cannel but I find most of the knowlege here
14:18:04 <ph88> slice would you like some comments on your pasted code ?
14:18:10 <chris___> kadoba: I meant like sub channels :P
14:18:14 <JuanDaugherty> chris___, your client should have a search function
14:18:19 <miscyb> Welkin: looking it up, I don't think boundary is what I need because I'm not doing multipart
14:18:31 <kadoban> chris___: So like, stuff related to haskell you're looking for? Yeah, there's a few
14:18:42 <JuanDaugherty> irc networks do not otherwise categorize channels that i've seen
14:19:06 * hackagebot brick 0.12 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.12 (JonathanDaugherty)
14:19:20 <geekosaur> you will often see related channels with common prefixes (so #haskell, #haskell-game, ...)
14:19:32 <JuanDaugherty> i.e. in xchat list of channels, you should also be able to do in the channel for the network connect
14:20:07 <younder> chris___, Did you mean news groups? (They have sub categories)
14:20:18 <JuanDaugherty> (if your client doesn't have a channel search)
14:20:40 <JuanDaugherty> there are maybe 20-30 haskell channels
14:20:57 <JuanDaugherty> and all here, dunno of other networks with hs irc
14:21:25 <JuanDaugherty> but prolly at least 1
14:21:54 <monochrom> hierarchical organization is not as useful as people wish. in the end it is no better than a flat list. the newsgroups acknowledge this reality by allowing you to cross-post to several newsgroups.
14:22:07 <chris___> oops
14:22:25 <JuanDaugherty> you have an ipv6 host dual stacked?
14:22:36 <slice> Welkin: when using Vector.Unboxed, do I want a vector the size of the number of items, adding the next item at each index (1,1234), (2,4567) etc.
14:22:39 <monochrom> Haskell and Java acknowledge this by imposing no relation between, for example, Control.Monad and Control.Monad.State
14:23:14 <slice> Welkin: or do I want the size to be to a large limit and use the numbers as indices and True/False (1234, True), (0, False)
14:23:26 <monochrom> in fact Haskell goes one step further by allowing "import Control.Monad as X; import Data.Set as X"
14:23:55 <slice> Welkin: The latter seems like it would perform better, but hat would that limit look like? Is a vector of 1000+ (False)'s going to be slow?
14:23:56 <younder> monochrom, How is this a good thing? Are you saying a flat directory system is just as good as one with directories?
14:24:38 <Tuplanolla> Have you ever tried organizing your files?
14:24:52 <Tuplanolla> It's completely impossible once you have enough.
14:25:50 <daey> i understand that in lambda calculus something like this is not allowed : f(1) = 1; f(1) = 2; but isnt that exactly what a random function does/requires to work?
14:26:17 <monochrom> Yes.
14:26:17 <pikajude> yeah we use IO for that
14:26:25 <ph88> > read $ show 2
14:26:28 <lambdabot>  *Exception: Prelude.read: no parse
14:26:34 <ph88> why is it doing that ?
14:26:43 <pikajude> because read defaults to ()
14:26:45 <pikajude> > read "()"
14:26:49 <lambdabot>  ()
14:26:51 <glguy> ph88: Because you didn't both specifying what type it should be reading
14:26:55 <monochrom> > read (show ())
14:26:57 <lambdabot>  ()
14:27:15 <ph88> ah ok
14:27:30 <Koterpillar> daey: random is not a function in {lambda calculus, Haskell, mathematical} sense
14:27:57 <ertes> younder: i have long dispensed with mail "folders", because that's just an unnatural way to organise my mail
14:28:10 <ertes> younder: now i use a tag-based system (using notmuch)
14:28:16 <ph88> how do you map a list over a value? so that [1,2] becomes [[1],[2]] ?
14:28:33 <Tuplanolla> I wish there was a tag-based filesystem.
14:28:36 <ertes> younder: and for the most part i don't even bother tagging my mails
14:28:49 <monochrom> "Data".Functor and "Control".Applicative shows you a fundamental dilemma of hierarchical grouping
14:29:00 <fr33domlover> Tuplanolla, you can sort of have that if you use semantic desktop
14:29:11 <fr33domlover> although today's solutions are far from really being there
14:29:13 <cite-reader> > map pure [1, 2] :: [[Int]]
14:29:15 <lambdabot>  [[1],[2]]
14:29:22 <fr33domlover> still worth a glance i suppose
14:29:29 <Tuplanolla> Let's see it.
14:29:38 <younder> So you mean you need a directad graph anyhow?
14:30:13 <monochrom> If you despise my pessimistic flat-list suggestion nonetheless, may I suggest that directed acyclic graph is at least better than trees.
14:30:16 <ph88> slice digits x = map (\y -> read [y] :: Int) $ show x
14:30:39 <slice> ph88: that's what's slowing it?
14:30:44 <ph88> yes i think so :P
14:30:45 <sbrg> i doubt it
14:31:02 <ph88> slice try removing cap and change list to [1..]
14:31:45 <slice> ph88: Hold on I'm trying to get vectors working
14:31:49 <monochrom> And this is why I brought up cross-posting in newsgroups and "import Control.Monad as X; import Data.Set as X". When you do that, it means you are wanting a directed acyclic graph where two parent nodes point to the same child node.
14:32:07 * younder thinks directed graphs and tag systems are isomorphic
14:32:15 <monochrom> Actually at some point you will be able to talk me into dropping the "acyclic" part too.
14:32:28 <monochrom> Yes sure.
14:32:50 <monochrom> The invention of tagging shows that tree is not enough.
14:32:59 <ph88> slice, digitFactChains len = filter (\x -> Set.size (genChain x) == len - 1) [1..]    try this too
14:33:03 <glguy> monochrom: Can we have multiple edges between the same nodes in this structure?
14:33:14 <monochrom> Look, if you agree "tree sucks" we're in perfect agreement.
14:33:16 <ertes> > unfoldr (\x -> if x > 0 then Just (swap (divMod x 10)) else Nothing) 51743
14:33:18 <lambdabot>  [3,4,7,1,5]
14:33:48 <monochrom> yeah eventually I may want multiple edges too
14:34:28 <Tuplanolla> Does infinity enter the picture at any point, monochrom?
14:34:29 <ertes> slice: i'd use this one
14:34:40 <glguy> monochrom: hyperedges?
14:34:45 <fr33domlover> more generally edges can be tagged, and then each edge represents a tuple in a relation
14:35:01 <monochrom> No, I am only thinking of finite collections.
14:35:06 <Tuplanolla> Come on; I thought you were cool.
14:36:00 <ertes> slice: also get rid of (!!) and use an unboxed vector with (!)
14:36:05 <monochrom> OK! An inaccessible-uncountable-ordinal-many channels on IRC! How do you organize that many channels?
14:36:29 <younder> glguy, Either things are related, or they are not. So so connect related things with labeled vertices.
14:36:35 <monochrom> "Hilbert's IRC network"
14:36:38 <younder> arrows
14:37:41 <ertes> i think hilbert's IRC network is countable
14:38:11 <slice> ph88: using read/show made it slower
14:38:34 <ph88> slice 17 seconds seems way to slow even for list instead of vector
14:38:47 <ertes> slice: another thing to notice is that rust probably uses machine-sized integers
14:38:55 <ph88> as i see it you are just calculating 10 numbers
14:38:56 <ertes> slice: if you don't specialise, haskell will use Integer
14:39:15 <slice> ertes: so I should be converting to Int?
14:39:21 <slice> ertes: or specify type dec?
14:39:27 <sbrg> just annotate with Int
14:39:28 <ertes> slice: not converting, but specialising
14:39:43 <slice> ph88: if you remove cap it never ends it will go forever
14:39:50 <ertes> slice: you can leave your functions non-specialised, but at the final use site, you need to pick a type
14:40:28 <ertes> slice: like in your main action:  main = print (digitFactChains 1000000 60 :: Whatever)
14:44:45 <slice> ertes: specifying Int doesn't make it faster :-(
14:45:36 <slice> ertes: as for the unboxe vector: how do I count the length of the vector? I have to specify the length as 60 since that's my max chain size.
14:45:48 <slice> ertes: and I fill it with 0s: Vec.replicate 60 0
14:46:14 <slice> ertes: then as I generate my chain, I go up an index: 1 = 1234, 2 = 5678, etc.
14:46:17 <slice> ertes: right?
14:46:33 <slice> ertes: and that should be faster than Set.member?
14:50:26 <ertes> slice: i didn't suggest replacing the Set by a vector, but you're doing a list index using (!!)
14:50:50 <slice> ertes: oh. I think it was someone else who suggested it.
14:50:55 <slice> ertes: my bad
14:51:09 <slice> ertes: that might help but I'm not sure it's the cause of the slow-down
14:51:20 <ertes> slice: i suggested using a vector instead of a list for the one case where you currently use (!!)
14:51:50 <slice> ertes: I'll give that a shot too, thanks
14:51:51 <ertes> slice: i don't know either, but an unboxed vector will certainly be *much* faster than a list with indexing
14:52:02 <ertes> if you do that lookup a lot, it will pay off
14:52:56 <ertes> (also if you switch to Int, consider switching from Set to IntSet, which is very often twice as fast as Set Int)
14:53:51 <ertes> slice: these are all little things that may not make much of a difference on their own, but they add up
14:57:48 <ph88> slice, hows it going ?
15:00:14 <polo_> why am I getting error in pattern matching?   armyChecker x:xs y:ys   | life (attackedPokemon x y) <= 0  = ys    | otherwise    = y:ys  
15:00:28 <ph88> what error are you getting actually ?
15:00:34 <sdx23> polo_: (x:xs) and so on
15:00:35 <monochrom> need parentheses. (x:xs). (y:ys).
15:00:44 <ph88> error: pokemon escaped  ?
15:00:54 <monochrom> heh
15:01:15 <Yobokies> anyone know why i can't divide? fromIntegral num1 / fromIntegral num2 
15:01:19 <Yobokies> ERROR: No instance for (Fractional Int) arising from a use of ‘/’
15:01:22 <polo_> ph88: error: parser error on pattern matching
15:01:40 <ph88> Yobokies, put ( ) / ( )
15:01:51 <Yobokies> okay let me see
15:02:09 <ertes> ph88: no, Yobokies's code is fine
15:02:09 <monochrom> The Day of Needing More Parentheses.
15:02:20 <slice> ertes: Trying to use an unboxed vector: `digitFacts = Vector.fromList [1,2,6,24]`
15:02:20 <monochrom> oh oops, yeah.
15:02:27 <slice> ertes: but I get: Ambiguous type variable ‘a0’ arising from a use of ‘Vector.fromList’
15:02:37 <slice> ph88: not well. Can't seem to get it down any further.
15:02:38 <monochrom> The cause is elsewhere. Post complete verbatim unabridged code.
15:02:39 <ertes> Yobokies: not enough context to answer
15:02:55 <ertes> Yobokies: but most likely you're trying to use the result as an Int, which doesn't work
15:02:58 <ph88> slice, maybe [1,20] :: [Int]
15:03:33 <slice> ph88: worked!
15:03:38 <slice> unfortunately it's no faster...
15:03:39 <ph88> cool
15:03:46 <ph88> paste what you have now
15:03:48 <ertes> slice: which vector module are you using?
15:03:57 <slice> ertes: Data.Vector.Unboxed
15:04:17 <ertes> slice: did you try the IntSet suggestion?
15:04:24 <ph88> i think Vector.fromList is the normal vector, no ?
15:04:26 <monochrom> Every day is the Day of You Need to Post Complete Code.
15:04:47 <slice> ertes: I am using IntSet for the chains and Unboxed Vector for the factorials
15:04:50 <Yobokies> ph88 it still didn't work No instance for (Fractional Int) arising from a use of ‘/’     • In the expression: (fromIntegral num) / (fromIntegral total)
15:04:53 <monochrom> Every year is the United Nation Year of You Need to Post Complete Code.
15:05:01 <ertes> slice: ok, now would be a good time to paste code =)
15:05:25 <polo_> I have "data Trainer = Trainer {chief::String, warriors::[Pokemon]}  deriving (Show, Eq)" and the I defined a function: "ttackedTrainer  T1 T2 = Trainer (chief T2)  (armyChecker (warriors T1) (warriors T2))" but i'm getting T1 T2 not in scope.
15:05:31 <ertes> Yobokies:
15:05:44 <ertes> > fromIntegral (5 :: Int) / fromIntegral (2 :: Int) :: Double
15:05:46 <lambdabot>  2.5
15:05:47 <ertes> > fromIntegral (5 :: Int) / fromIntegral (2 :: Int) :: Int
15:05:48 <Koterpillar> polo_: uppercase is for values
15:05:49 <lambdabot>  error:
15:05:50 <lambdabot>      • No instance for (Fractional Int) arising from a use of ‘/’
15:05:50 <lambdabot>      • In the expression:
15:06:01 <Koterpillar> polo_: uppercase is for *types*, sorry; values start with lowercase
15:07:06 <ph88> Yobokies, i think the error is not in that part of the code
15:07:08 <ertes> Yobokies: you can go from most fractional types to Int by rounding
15:07:08 <fr33domlover> uppercase is for type and value constructors
15:07:25 <Yobokies> ph88 yeah i just verified that bit is correct
15:07:31 <Yobokies> but my code isnt workin hmm
15:07:34 <ertes> Yobokies: i.e. by using 'ceiling', 'floor', 'round' or 'truncate'
15:07:36 <slice> ertes: http://lpaste.net/316469
15:07:51 <ertes> alright, i'll stop wasting my time being ignored
15:08:14 <ph88> Yobokies, maybe put    round $ (fromIntegral num) / (fromIntegral total)
15:08:50 <Yobokies> i need the decimal value
15:09:08 * hackagebot Chart 1.8.1 - A library for generating 2D Charts and Plots  https://hackage.haskell.org/package/Chart-1.8.1 (TimDocker)
15:09:10 * hackagebot Chart-cairo 1.8.1 - Cairo backend for Charts.  https://hackage.haskell.org/package/Chart-cairo-1.8.1 (TimDocker)
15:09:12 * hackagebot Chart-gtk 1.8.1 - Utility functions for using the chart library with GTK  https://hackage.haskell.org/package/Chart-gtk-1.8.1 (TimDocker)
15:09:15 * hackagebot Chart-diagrams 1.8.1 - Diagrams backend for Charts.  https://hackage.haskell.org/package/Chart-diagrams-1.8.1 (TimDocker)
15:09:41 <Yobokies> Is it possible to do something like type MyType = (Char, Num)
15:09:48 <ertes> slice: it would be really helpful if you could add type signatures to all top-level definitions
15:09:56 <ph88> Yobokies, yes i think so
15:09:57 <Yobokies> so the type of number is inferred?
15:09:59 <slice> ertes: sure
15:10:44 <hpc> Yobokies: you're trying to hide a bunch of "Num a =>" from your type signatures?
15:10:47 <ertes> slice: (feel free to just copy-paste what GHC infers)
15:11:00 <ph88> Yobokies, eh actually for Num you should use   Num a => (Char, a)
15:11:11 <slice> ertes: yep
15:12:46 <Yobokies> ph88 hmm i get ciphers.hs:8:23: error: Not in scope: type variable ‘a’
15:13:24 <Yobokies> when i do type MyType Num a => (Char, a)
15:13:37 <slice> ertes: updated it: http://lpaste.net/316469
15:14:09 <ertes> slice: did it become faster/slower after adding type signatures?
15:14:17 <monochrom> "Num a => (Char, a)" is unlikely to do what you think. In fact, it likely does the opposite, literally.
15:14:30 <Tuplanolla> Small change, slice: replace `div` and `mod` with `quotRem`.
15:14:31 <slice> ertes: lemme run again
15:14:41 <ertes> slice: (i'd assume that it didn't, but sometimes GHC is full of surprises)
15:14:41 <monochrom> It is opposite because you think "the provider chooses" but the fact is "user chooses".
15:15:45 <slice> ertes: it didn't change
15:16:25 <slice> ertes: here's the rust solution that runs in .73 if you know any rust: https://github.com/JacksonGariety/euler.rs/blob/master/src/solution_074.rs
15:16:43 <slice> ertes: it's pretty simple. I feel like I'm doing basically the same thing here I am there.
15:16:51 <glguy> slice: My Haskell solution to 74 runs in 0.5 seconds on *my* computer
15:17:02 <ph88> hurray ! we beat rust !
15:17:14 <ph88> now at parMap ftw
15:17:18 <ph88> add*
15:17:22 <Yobokies> ph88 i dont think its possible with type
15:17:30 <ertes> slice: is that the same algorithm?
15:17:46 <ph88> Yobokies, yeah monochrom just mentioned something about that .. maybe post your full code ?
15:18:00 <slice> ertes: yes
15:18:03 <monochrom> Every year is the United Nation Year of You Need to Post Complete Code.
15:18:18 <slice> glguy: can I see it???
15:18:35 <sbrg> slice: how fast is your haskell solution now? 
15:18:43 <monochrom> We need more people to say it out loud with me in harmoney: You need to post complete code.
15:18:55 * sbrg chants "Post complete code"
15:18:57 <monochrom> And refuse to give further "answers" until then.
15:19:09 * hackagebot mysql 0.1.4 - A low-level MySQL client library.  https://hackage.haskell.org/package/mysql-0.1.4 (paulrouse)
15:19:14 <hpc> have you tried turning it off and on again?
15:19:16 <ph88> would be cool if iHaskell had collaboration build in :)
15:19:49 <monochrom> Yes! I should try turning off and on #haskell again!
15:20:00 <ertes> slice: i'm not entirely sure about that…  if nothing else, the rust version uses different data structures
15:20:38 <sbrg> slice: one example of ertes' point is that you have constant time lookup for the precomputed digit factorials in rust, but O(n) for the list equivalent in haskell
15:20:49 <sbrg> granted, the list only has length 10, but it might matter
15:20:55 <sbrg> (or are you using vector for that?)
15:20:55 <ertes> sbrg: the list thing is gone
15:20:57 <sbrg> ah
15:21:08 <ertes> it's an unboxed vector now
15:21:10 <lpaste> glguy annotated “12 seconds -O2” with “using mutable vectors for memoization” at http://lpaste.net/316469#a316477
15:21:20 <slice> Tuplanolla: using a reverse unfold quotRem I found makes it slow :-/
15:21:26 <slice> Tuplanolla: idk about quotRem
15:21:41 <slice> sbrg: 12 secs
15:21:49 <sbrg> kk
15:22:01 <ertes> slice: quotRem vs. divMod on Int should make no noticable difference
15:22:17 <ertes> i don't know if using divMod vs. div and mod makes one though
15:22:43 <slice> sbrg: I think it does matter since I'm doing it x a million
15:22:47 <ertes> generally i'd try to use divMod, if possible
15:23:12 <slice> sbrg: I'm trying to get constant time lookup in haskell, but using a very large array makes it much, mcuh slower
15:24:28 <slice>   ertes okay. divMod it is.
15:24:33 <polo_> Hello, I am very close to end my homework after three days of work(some of you may recognize the pokemon problem ;)) I have a very specific problem.I wrote it here:http://lpaste.net/294377 .Please sb help me with the last step.
15:24:55 <ertes> slice: try glguy's code (it's annotated)
15:25:25 <slice> ertes: he's taking a different approach
15:25:58 <slice> glguy: I'm inferring from the title that you're memoizing the chain results to get speed rather than speeding up lookup time
15:27:01 <glguy> slice: If you don't memoize any of the results at all, then it took 2.5 seconds on my computer
15:27:15 <slice> glguy: oh. interesting
15:29:22 <slice> glguy: on line 28 you're breaking your recursion when you get the number you started with.
15:29:46 <glguy> no
15:30:21 <slice> glguy: how do you know when to cut the chain, then?
15:31:37 <glguy> When you find a number that is its own loop or a number that you know the chain length of you're done
15:33:19 <ertes> slice: i'm trying to understand the rust code…  it's totally naive, right?
15:34:18 <ertes> the only optimisation it uses is the factorial table
15:34:24 <polo_> Please someone take a look: http://irc.lc/freenode/haskell
15:36:25 <onintza> At the risk of asking something really obvious, what is the meaning of "<-"?
15:37:11 <pikajude> it's part of do notation
15:37:13 <polo_> onintza :  a<- b means a belongs to b
15:37:29 <pikajude> wait, what?
15:37:31 <Tuplanolla> That's nonsense, polo_.
15:37:43 <glguy> onintza:  which tutorial or reference are you using to learn Haskell?
15:37:55 <monochrom> I agree with glguy's question.
15:37:56 <pikajude> GHC converts "do a <- b; c" to "b >>= \ a -> c"
15:37:59 <onintza> Why does "x <- xs" iterate over all the elements of "xs"?
15:38:17 <polo_> Tuplanolla : Sorry that's what I thought.
15:38:20 <geekosaur> oh, list comprehension?
15:38:29 <onintza> geekosaur: or in a do
15:38:38 <geekosaur> because that is how the list monad is defined
15:38:46 <geekosaur> it does not do the same thing in, say, IO. or Maybe
15:39:08 <onintza> but how does <- use that definition
15:39:54 <geekosaur> @src [] (>>=)
15:39:54 <lambdabot> xs >>= f = concatMap f xs
15:40:06 <geekosaur> and <- turns into >>=
15:40:17 * onintza needs some time to digest that
15:40:20 <geekosaur> which for lists means it turns into concatMap
15:41:03 <onintza> oh, right
15:41:13 <geekosaur> and concatMap is literally (concat . map), so it maps a function over a list to produce a list of lists, then concatenates those lists to get the final list
15:41:16 <onintza> thanks all!
15:42:50 <onintza> there is nothing as profound as functional programming :þ
15:44:00 <kori> onintza: it's allllllllllllllllllllll syntax sugar
15:44:37 <monochrom> logical conclusion: there is nothing as profound as syntax sugar
15:45:11 <kori> monochrom: actually: there's nothing as profound as the lambda calculus
15:45:13 <kori> but close enough
15:45:36 <polo_> Please can someone at least give me a direction?http://lpaste.net/294377
15:45:38 <onintza> amazing how a series of rewrites is computation
15:46:21 <Koterpillar> polo_: what are the types of all this? I don't think this will compile at all
15:46:28 <monochrom> You can use rewriting to execute imperative programs, too.
15:46:47 <monochrom> When you do that, you will find that "call stack" is also unnecessary.
15:47:19 <polo_> Koterpillar : it compiles so far. I defined the types.
15:47:21 <monochrom> (In practice, you will still prefer a "call stack" because it is faster.)
15:47:46 <monochrom> The related lesson is that the C standard actually doesn't require a call stack.
15:47:59 <slice> ertes: it's possible that calling structs are memoized in rust by default
15:48:19 <slice> ertes: wait nvm
15:48:26 <slice> makes no sense
15:52:41 <Tuplanolla> Trying to beat Rust at number crunching sounds like a feeble effort.
15:53:50 <geekosaur> I don't think "feeble" is the word you wanted there. possibly "futile" (but then I would ask you to prove it)
15:54:04 <slice> Tuplanolla: but it's 30x slower!
15:54:29 <slice> Tuplanolla: I'm trying to figure out how it can be that rust can do it so quickly without memoization.
15:54:55 <slice> Tuplanolla: if the rust solution ran in ~4 seconds I would be unsurprised
15:55:10 <Tuplanolla> That difference seems quite big indeed.
15:55:32 <kuribas> Is rust as good as C/C++?
15:55:50 <cite-reader> That's a hell of a loaded question.
15:56:13 <kuribas> as _fast_ as C/C++?
15:56:53 <c0dehero> why shouldn't it be?
15:57:03 <glguy> It's not on topic at least
15:57:33 <slice> kuribas: whoa too soon
15:57:39 <slice> kuribas: fast. yeah.
15:57:48 <c0dehero> i'm pretty sure it should be at least as fast if not faster
15:58:01 <slice> it is faster in some cases iirc
15:58:07 <kuribas> because C++ compilers have a lot manhours and commercial support.
15:58:29 <glguy> To clarify, you'll need to take your Rust, C, C++ discussion to another channel
15:58:33 <c0dehero> making use c being low level to make programs faster than their rust equivalents is hard and most likely a waste of time
15:59:38 <Tuplanolla> What we really need is Haskell machines.
16:00:44 <ertes> slice: one immediate improvement i can think of is to use unfoldr instead of 'digits'
16:00:45 * geekosaur wonders if anyone has rerun dons's old benchmarks in the past 10 years
16:00:58 <ertes> slice: that allows the whole factDigitSum function to fuse into a single loop
16:01:08 <geekosaur> used to be that ghc -O2 -fllvm produced faster code than gcc -O2 for purely numeric operations
16:01:20 <geekosaur> but ghc and gcc have both changed a lot since then
16:01:21 <kuribas> glguy: I didn't start the rust topic
16:02:21 <kuribas> glguy: And I'd like to know haskell peoples opinion on rust, since it's a somewhat functional language.
16:02:44 <Koterpillar> "somewhat functional" is a nice definition
16:03:45 <kuribas> C has so much legacy that it's hard to replace.
16:04:01 <kuribas> Most languages have a FFI in C.
16:04:47 <glguy> kuribas: Sure, it's something one might want to know, it's just not on topic in this particular channel
16:12:24 <ertes> slice: one immediate improvement i can think of is to use unfoldr instead of 'digits'; that allows the whole factDigitSum function to fuse into a single loop
16:12:41 <slice> ertes: aha!
16:12:54 <ertes> slice: like this: digitFact = foldl' (+) 0 . map (factTable Vu.!) . unfoldr (\x -> if x == 0 then Nothing else Just (swap (divMod x 10)))
16:13:26 <ertes> in general avoid writing list functions recursively
16:13:54 <Tuplanolla> Now `MonadComprehensions` to the rescue: `digits b = unfoldr (\ n -> [swap (n `quotRem` b) | n /= 0])`
16:14:21 <ertes> yeah, you can also use 'guard'
16:14:42 <ertes> \x -> do guard (x /= 0); pure (swap (divMod x 10))
16:14:52 <hpc> > let digits b = unfoldr (\ n -> [swap (n `quotRem` b) | n /= 0]) in digits 16
16:14:54 <lambdabot>  error:
16:14:54 <lambdabot>      • Couldn't match expected type ‘Maybe (a1, b1)’
16:14:54 <lambdabot>                    with actual type ‘[(b1, b1)]’
16:15:08 <hpc> bah, lambdabot you're no fun
16:15:18 <Tuplanolla> Our robotic maiden doesn't have the extension on.
16:18:07 <slice> ertes: what exports swap?
16:18:12 <slice> tuple
16:18:28 <slice> ertes: whoa that was it
16:19:24 <geekosaur> @where hayoo
16:19:24 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
16:19:31 <geekosaur> ^ one-stop shop to answer questions like that
16:19:47 <ertes> slice: as in, now the haskell version is on par with the rust version?
16:20:04 <slice> ertes: it's twice as fast
16:20:26 <Tuplanolla> Firefox has this strange feature where it spontaneously removes Hayoo's keyword from the search engines whenever I put one in.
16:20:35 <ertes> slice: great =)
16:20:43 <slice> ertes: I re-ran the rust example on this computer and it's twice as slow. So 1.5 secs for the rust example.
16:20:48 <Tuplanolla> I wonder why.
16:20:56 <slice> ertes: with your code it runs in 7.5 secs
16:21:08 <slice> ertes: makes more sense that rust would be about that much faster I guess
16:21:08 <ertes> ah
16:21:23 <ertes> i thought now the haskell version is twice as fast as the rust version =)
16:21:36 * geekosaur just keeps a tab open on hayoo :p
16:21:38 <slice> rust was able to do that optimization itself I'll bet
16:21:45 <geekosaur> (yes, I use it that often)
16:21:52 <ertes> slice: could you give me the rustc command i need?
16:22:00 <slice> ertes: no, unfortunately
16:22:11 <slice> ertes: rustc -O main.rs
16:22:24 <slice> ertes: then `time ./main 074`
16:22:37 <slice> ertes: main is in the repo
16:24:04 <cite-reader> Interestingly, `rustc -O` is equivalent to `rustc -C opt-level=2`, _but_ if you compile with Cargo the release profile selects an opt-level of 3.
16:24:30 <cite-reader> I have no idea how significant the difference between opt-level=2 and opt-level=3 is.
16:26:03 <ertes> slice: i'm pretty sure IntSet is the main bottleneck
16:26:13 <slice> ertes: yeah it def is
16:26:21 <ertes> slice: so the rust version is most likely as fast as it is, because it uses a mutable data structure there
16:26:57 <slice> ertes: right :-(
16:27:04 <slice> ertes: but there has to be some structure out there
16:27:36 <slice> in haskell to do it faster
16:29:34 <slice> the question is why is it slower with unboxed vectors
16:30:17 <sweater> Dear all, in untyped lambda calculus this is legal and evaluates to `b b`: `(\x y -> x y y) (\a -> a) b`, in Haskell, if we have b :: (t -> String) with implementation, say, `\_ -> "meow"`, we'll get t ~ (t -> String) when we try to evaluate the initial function.
16:30:57 <Cale> sweater: yes.
16:31:27 <sweater> However `id b b` typechecks and returns "meow". I wonder if there is a way to trick GHC to evaluate like beta-reduction.
16:32:14 <sweater> I sounds really stupid, I guess, but I don't understand the steps of type inference here.
16:33:19 <sweater> Oh, ok, I got it.
16:33:40 <Cale> The main thing you need to notice is that you're using b (or y) polymorphically
16:33:42 <sweater> No I didn't.
16:34:08 <Cale> GHC will never infer that a type variable ought to be a polymorphic type
16:34:27 <Cale> But you can insist anyway with the RankNTypes extension and explicit type signatures
16:35:11 <sweater> Aha, so when I specify (say, with ScopedTypeVariables) that t in b is `a -> String`, I get the same infinite inference, becuase on the next step it'll try to infer a polymorphic type, thus resulting in an infinite type, yes?
16:37:20 <Cale> > (\(x :: forall t. t -> String) -> x x) (\v -> "hello")
16:37:22 <lambdabot>  "hello"
16:37:49 <sweater> Makes sense!
16:37:59 <sweater> Thanks, sorry, infinity is hard. Thank you, Cale.
16:40:36 <monochrom> that's evil.
16:40:42 <monochrom> err no, that's fun. :)
16:43:18 <Cale> sweater: and yeah, usually it's going to assume that x has some specific type and try to discover what that is through unification
16:43:47 <Cale> So, when it sees that x is applied to some argument as part of a function application, well, that means whatever type x has, it had better be of the form a -> b
16:43:53 <Cale> for some types a and b
16:44:12 <Cale> and then whatever its argument is had better have type a
16:44:32 <Cale> and so it looks at its argument and finds x there, and so a had better be equal to a -> b
16:45:07 <Cale> which if you try to solve it naively means that the type looks like ((... -> b) -> b) -> b
16:45:12 <Tuplanolla> Would things break if it inferred higher-rank polymorphic types?
16:46:23 <Cale> There's just no good algorithm for doing that -- the solutions are not unique in general, and a lot of the time when you have one of these infinite types, it's actually an error in the program, so you wouldn't want it to try.
16:47:09 <Tuplanolla> It destroys occurs checks?
16:48:40 <geekosaur> consider that the most common case for that error is that someone did ... | condition_a = x | condition_b = xs
16:48:58 <geekosaur> do you really want it inferring a higher rank type?
16:49:49 <Cale> Tuplanolla: A lot of them, yeah.
16:49:57 <Cale> Tuplanolla: (look what we just did above)
16:50:38 <Cale> There was a really good post on the mailing list at one point which went over a bunch of obvious typos that could happen in a piece of code and the occurs checks that would result
16:50:59 <Cale> I think maybe by Ashley Yakeley?
16:51:10 <Cale> Could be wrong about that
16:51:28 <Tuplanolla> It's not like I was planning to do useful work instead of fighting the type checker.
16:51:46 <Cale> I'm having a hard time getting Google to find old mailing list posts
16:52:06 <x1f577> Anyone know of a way to extract raw text from arbitrary files in haskell? I'm looking for something like Apache Tika for haskell or one of the easily interoperable languages like C/C++
16:52:37 <Tuplanolla> Kaboom: http://article.gmane.org/gmane.comp.lang.haskell.cafe/17105
16:52:39 <jle`> x1f577: what do you mean by arbitrary files?
16:52:49 <jle`> "foo.txt" and "bar.xt" ?
16:52:57 <jle`> s/bar.xt/bar.txt
16:53:08 <x1f577> jle`: .docx .pdf .ppt .txt .xlsx .BLAH
16:53:12 <jle`> or do you mean arbitrary file types
16:53:17 <jle`> ah
16:53:18 <x1f577> jle`: file types, my apologies.
16:53:47 <x1f577> im currently running apache-tika as a server and extracting text that way, but id rather do it natively
16:54:15 <Cale> Is that like glorified "strings"
16:54:21 <Cale> or does it do something fancier
16:54:50 <Cale> ah, much fancier
16:55:00 <Cale> Yeah, you're unlikely to find that. Pandoc would be the closest thing
16:55:13 <x1f577> Cale: are you talking to me?
16:55:23 <Cale> yeah
16:55:54 <monochrom> pandoc turns text into various file formats, not treasure-hunting various file formats for text.
16:56:12 <Cale> Right
16:56:33 <Cale> But depending on what formats you're especially interested in, it might help you.
16:56:40 <monochrom> but all is not lost. Bird taught us how to invert a function.
16:57:07 <x1f577> im doing some NLP work, and id like to build an index of a user's files from the raw text extracted from them
16:57:19 <monochrom> I once made a joke to explain the purpose of Bird's inversion technique.
16:57:31 <Welkin> neurolinguistic programming?
16:57:37 <Welkin> like, pickup?
16:57:54 <sbrg> natural language processing, I gugess
16:57:56 <sbrg> -g
16:58:22 <x1f577> natural language processing
16:58:27 <monochrom> I happened to have a staple remover on my desk, so I picked it up and explained to my friend, "so by this technique you do algebra on this staple remover, and you derive a stapler".
16:58:32 <Welkin> 19:54 < x1f577> Cale: are you talking to me?
16:58:37 <Welkin> nice taxi driver reference
16:59:03 <x1f577> Welkin: lol :)
17:00:47 <x1f577> i might be able to get pandoc to do what i need
17:02:37 <EvanR> hrm. the free monoid blog post has inspired me to define more types by this newtype universal property technique
17:03:48 <EvanR> newtype FM a = FM { unFM :: forall m . Monoid m => (a -> m) -> m }
17:06:01 <EvanR> come up with the final interface first, then "it doesnt matter what you do next" as far as implementation goes
17:08:40 <x1f577> whats the best way to call a java library from haskell?
17:08:54 <xa0> to not.
17:08:57 <EvanR> with inline java
17:09:28 <Neurergus> what package provides EitherT?
17:09:29 <Cale> x1f577: Build an executable around it and execute it in a separate process
17:09:30 <Cale> ?
17:09:43 <Cale> It's pretty hard to FFI to stuff that runs on the JVM
17:09:52 <EvanR> https://github.com/tweag/inline-java#readme
17:10:09 <EvanR> hehe
17:10:12 <cite-reader> Neurergus: transformers.
17:10:21 <Neurergus> well
17:10:26 <cite-reader> I think? Wait
17:10:27 <Cale> EvanR: whoa, wtf
17:10:35 <Neurergus> this computer appears to have StateT but not EitherT
17:10:47 <EvanR> getting hard to keep track of all the haskell java stuff going on !
17:10:56 <cite-reader> Oh I'm sorry, I was thinking of ExceptT.
17:11:30 <EvanR> theres also java-bridge which is older
17:11:38 <EvanR> it involves a Java monad
17:11:48 <Cale> http://hackage.haskell.org/package/EitherT-0.2.0/docs/Control-Monad-Trans-Either.html
17:12:03 <Cale> oh, wait sorry http://hackage.haskell.org/package/either
17:12:16 <Cale> dangit hoogle
17:12:24 <Neurergus> ah, thanks
17:13:34 <Cale> Hoogle should know that when there's a package by Edward Kmett and one which is not by Edward Kmett, you probably want the former.
17:13:45 <Neurergus> haha
17:14:42 <geekosaur> what of the other one's by oleg kiselyov? :p
17:14:46 <geekosaur> *if the
17:16:12 <Cale> If it's by Oleg, the people who are interested in it will have already copied the code out of his mailing list posts.
17:16:53 <ajf>     parse error on input ‘<-’
17:16:55 <ajf>     Perhaps this statement should be within a 'do' block?
17:16:58 <ajf> this is within a do block
17:17:11 <ajf> is there something obvious which might be wrong?
17:17:20 <ajf> the preceding line is a let
17:17:33 <geekosaur> is it, though? (a) indentation (b) other things introduce layout which puts the context not in the actual do
17:17:35 <geekosaur> @paste
17:17:38 <lambdabot> Haskell pastebin: http://lpaste.net/
17:18:08 <ajf> http://lpaste.net/5937982966088073216
17:18:16 <ajf> line 9 is the syntax error
17:18:45 <ajf> oh, it needed double-indenting
17:19:15 <ajf> ew, but it works
17:19:25 <geekosaur> yes, env starts at the same level as getSession so it took that line as a new binding within the let
17:19:33 <ajf> yeah
17:25:12 <ertes> slice: i've done a few experiments of my own
17:25:25 <slice> ertes: with mutable vectors? he he
17:26:27 <ertes> slice: indeed…  i've tried a hash table (from the hashtables library) and a custom binary-search-based approach
17:26:54 <ertes> slice: the latter is the fastest so far
17:26:59 <slice> ertes: how fast?
17:27:16 <ajf> is there a shortcut for a <- something; return something
17:27:22 <ertes> slice: ~3x the run-time of the rust version
17:27:24 <ajf> wait, that's just `something`, right?
17:27:28 <dyreshark> ajf: yup
17:27:36 <slice> ertes: without memoization!?
17:27:40 <ertes> slice: yeah
17:27:41 <ajf> too much procedural programming recently, I guess ^^
17:27:45 <slice> ertes: damn
17:27:49 <slice> ertes: have an lpaste?
17:28:05 <ertes> slice: it's still far slower than i'd like it to be…  sure, gimme a second
17:28:23 <jle`> ajf: that's do something; return something
17:28:30 <jle`> ajf: or something $> something
17:28:33 <jle`> it's not just 'something'
17:28:53 <jle`> > do a <- Just 10; return (Just 10)
17:28:58 <ajf> jle`: huh?
17:28:59 <lambdabot>  Just (Just 10)
17:29:00 <ajf> oh
17:29:03 <ajf> sorry, I miswrote
17:29:04 <jle`> > Just 10
17:29:05 <dyreshark> oh, i misread
17:29:09 <jle`> see, they're different :)
17:29:09 <lambdabot>  Just 10
17:29:14 * hackagebot configurator-ng 0.0.0.1 - The next generation of configuration management  https://hackage.haskell.org/package/configurator-ng-0.0.0.1 (LeonSmith)
17:29:14 <ajf> I meant a <- something; return a
17:29:17 <jle`> oh
17:29:20 <jle`> yeah that's just 'something'
17:29:21 <ajf> sorry!
17:29:37 <whatever> hi
17:29:41 <jle`> no need to apologize :)
17:32:02 <jle`> hi!
17:35:47 <ajf> I'm happy, I finally understand wai-session
17:36:00 <ajf> Haskell libraries are often poorly documented, which is a pain
17:36:12 <ajf> on the other hand, from the type signatures alone, you can eventually figure out how they work
17:36:27 <ertes> slice: https://github.com/esoeylemez/snippets/blob/master/pe74.hs
17:36:47 <ertes> slice: i paid attention not to change the algorithm, but make it as fast as possible
17:36:54 <jle`> ajf: yeah, there seems to be a cultural thing where people are willing to just let their types be the only documentation
17:37:01 <jle`> but, it doesn't actually work as good documentation v.v
17:37:04 <slice> ertes: right that's the real puzzle here. memoization is like a cop out
17:37:12 <jle`> "at least" it works better than other languages, i guess, heh
17:37:19 <ertes> slice: it's still not *quite* the same algorithm, because the rust version most likely uses a hash table
17:37:32 <ertes> slice: i found that the hashtables library is actually slower than my binary search trick
17:37:51 <ertes> slice: i'm sure with a better hash table implementation the haskell version can match the rust version
17:37:57 <slice> ertes: that's a good improvement. smae logic
17:39:01 <slice> ertes: what is runST?
17:40:03 <ajf> jle`: in this case, there was sample code
17:40:10 <Welkin> slice: escapes ST
17:40:15 <ajf> but understanding the sample code was very difficult, because it used a lot of concepts I didn't know
17:40:21 <ajf> not Haskell ones, just framework stuff
17:40:35 <ertes> slice: ST is like IO restricted to mutable variables, so runST can be used to embed such an action into a pure expression
17:41:13 <ertes> > runST (do v <- newSTRef 0; writeSTRef v 5; readSTRef v)
17:41:17 <lambdabot>  5
17:41:44 <ertes> slice: this 'v' is an actual mutable variable, not a simulated one
17:42:22 <exio4> (basically safe unsafePerformIO because it happens to be a restricted IO :p)
17:42:34 <slice> ertes: this is a really strange use of Haskell!
17:42:55 <slice> ertes: can't believe it though
17:43:37 <ajf> aaaa
17:43:48 <ajf> turns out you cannot, in fact, move a cabal sandbox without it exploding
17:43:48 <ertes> slice: i think ST is really useful…  you can also use it to create immutable vectors by first creating a mutable one and writing to it (see 'create')
17:43:55 <ajf> I guess I need to make it reinstall everything again
17:44:12 <Welkin> ajf: try using stack or nix
17:44:21 <Welkin> I stopped using sandboxes long ago
17:44:24 <Welkin> so did most people
17:44:27 <slice> ertes: I was going down the same path. never got that far.
17:44:36 <Welkin> ajf: also, you can fix it in your cabal sandbox config
17:44:39 <ajf> Welkin: I ought to, though I wonder if they suffer from the same problem
17:44:39 <Welkin> forgot the nam of the file
17:44:40 <slice> ertes: what a puzzle
17:44:45 <ajf> Welkin: that doesn't fix it, alas
17:44:51 <Welkin> you can just edit the path
17:45:05 <Welkin> I have done it before I think
17:45:14 <ajf> Welkin: I did. actually, it did it for me, this time. but there's apparently some residual absolute paths somewhere else
17:45:21 <ertes> slice: it's still too slow for my taste, but i guess we have to live with it, until someone writes a faster hash table implementation
17:45:23 <ajf> because now cabal can't find any packages
17:45:28 <Welkin> ajf: my recommendation is to use stack or nix
17:45:34 <ajf> yeah, I should switch
17:45:57 <ertes> slice: rust probably has some über-optimised hash table implementation, because in an imperative language those are prevalent
17:46:01 <slice> ertes: amazing to see functional programming do this kind of work
17:46:07 <slice> ertes: right
17:46:25 <EvanR> have you tried HashMap Int ?
17:46:44 <ertes> EvanR: IntSet, and it's way slower than the current one
17:47:08 <EvanR> erm
17:47:21 <EvanR> i guess that means no
17:47:54 <EvanR> HashSet Int supposely outperforms IntSet on lookup, update
17:47:59 <ertes> EvanR: i'm assuming that you mean HashSet Int, because HashMap Int :: * -> *, and IntSet is basically the same thing as HashSet Int
17:48:10 <EvanR> no its not
17:48:10 <ertes> does it?
17:48:19 <ertes> let me try
17:48:38 <slice> ertes: your code runs in about 6 seconds on my girlfriend's macbook. you compiled with GHC -O2, right?
17:48:39 <EvanR> big endian patricia tree vs hash mapped vector trie
17:48:54 <geekosaur> ajf, absolute paths in the package.conf.d, then cabal sandbox hc-pkg recache
17:49:01 <slice> ertes: SetInt runs in about 7.7secs on this machine
17:49:10 <geekosaur> (files under the package.conf.d dir that is)
17:49:16 <exio4> what about the rust version? slice 
17:49:48 <slice> exio4: 1.5s
17:50:00 <exio4> that's quick
17:50:05 <slice> yeah
17:50:15 <ajf> geekosaur: ah, okay. I didn't know that, I'll try to remember that for next time
17:50:25 <slice> on my 2013 macbook it runs in .78 secs
17:50:25 <ajf> (I'm just reinstalling everything)
17:50:39 <ertes> slice: -O2 -fllvm
17:51:15 <EvanR> if anyone can drop in HashSet Int for this im curious to see how it compares, and if somehow people are overlooking HashMaps
17:51:33 <slice> ertes: still 6.1s
17:51:52 <exio4> slice: did you -fforce-recomp ?
17:52:07 <ajf> thank you all for your help today!
17:52:24 <slice> exio4: no, but it's still 6.1s
17:52:36 <ertes> EvanR: HashSet Int takes about 4/3 times as long as IntSet
17:52:50 <exio4> slice: weird :/
17:52:59 <EvanR> whats the workload like?
17:53:19 <ertes> insert, member, insert, member, …, size
17:53:37 <ertes> it's a similar workload to 'nub'
17:53:37 <slice> I guess that's about 4x slower than rust
17:53:59 <ertes> slice: you can get an additional boost by using -funfolding-use-threshold=1000
17:54:15 <ertes> slice: but that's almost going into desparation territory =)
17:54:24 <ertes> (it makes the inliner more aggressive)
17:54:25 <EvanR> did you try increasing the heap size or something, to make GC happen less often
17:54:46 <EvanR> or check if gc is the bottleneck
17:55:12 <slice> ertes: that gets it to 5.4s
17:55:46 <ertes> i can see one final way to improve this, but that requires some major refactoring
17:56:00 <ertes> reuse the array instead of creating it for every candidate
17:56:14 <ertes> but since the rust version doesn't do that, i didn't do it either
17:56:53 <slice> ertes: I think I'll try that when I get back from dinner
17:56:55 <EvanR> is the rust version using mutable vectors
17:57:27 <slice> ertes: I just don't want to memoize it, really, because that's how most people solve the time issue and it's not really relevant to euler
17:57:35 <slice> EvanR: yeah
17:57:42 <slice> EvanR: but se are we
17:57:44 <slice> so*
17:58:01 <EvanR> haskell mutable vectors are outperforming IntSet ?
17:58:11 <slice> EvanR: by a couple seconds, yeah
17:58:20 <EvanR> thats good... i thinkk
17:59:02 <EvanR> if gc is happening a lot during the 6s, then you might want to tweak it to use more memory
17:59:28 <EvanR> if the computation is expected to complete in around 6s, you could just not do any gc
18:00:53 <EvanR> (er, nevermind that. 6s might mean 6G allocated)
18:01:08 <ertes> EvanR: i'm not really familiar with rust, but i'm sure it uses a hash table rather than an array
18:01:32 <ertes> EvanR: unfortunately the hash table implementation i tried (the hashtables library) was slower than the binary search via vector-algorithms
18:01:48 <EvanR> i have heard hashtables library is underwhelming
18:02:05 <geekosaur> the hashtables library is the ancient horrible one there for backward compatibility, isn't it?
18:02:43 <EvanR> i saw a blog post bragging about optimizations to it, posted a few years ago
18:03:47 <EvanR> http://gregorycollins.net/posts/2011/06/11/announcing-hashtables
18:03:54 <EvanR> cuckoo hashing
18:04:24 <eacameron> Is there a way to "fmap" a function into a quasiquoter and get back a new quasiquoter? For example, I have a interpolation QQ called "text" I want to make a new QQ that just turns that into IsString a.
18:04:28 <Cale> Yeah, before that, it was just horrible -- slower than Data.Map in practically all cases, and with a worse interface. It was basically kept around because of some old code in GHC that used it.
18:04:48 <Cale> I don't know how it's held up since that refresh
18:06:53 <joneshf-laptop> Is there a way to encode higher rank types without the extension? Say I wanted `data Foo = forall a. Foo (a -> Bool)` or something.
18:07:24 <geekosaur> eacameron, not directly since a quasiquoter is a record of functions. http://hackage.haskell.org/package/template-haskell-2.8.0.0/docs/src/Language-Haskell-TH-Quote.html#quoteFile might give you some ideas though
18:07:32 <Cale> joneshf-laptop: That would be an existential
18:07:48 <Cale> joneshf-laptop: Higher rank is if the forall is inside the type of the field.
18:08:16 <EvanR> data b = Foo { forall a . a -> b } does this require Rank2 ?
18:08:19 <joneshf-laptop> Cale, cool. In that case, is either possible?
18:08:27 <Cale> joneshf-laptop: Since you can't recover which type 'a' is, you might as well just make that a Bool constant, because the only value you'll ever be able to pass to the function is undefined
18:08:28 <EvanR> data b = Foo { unfoo :: forall a . a -> b } does this require Rank2 ?
18:08:46 <eacameron> geekosaur: Excellent resource! This sounds like it could be a tiny lib worth making.
18:09:10 <Cale> joneshf-laptop: Similarly, for the higher rank case, a polymorphic function of type forall a. a -> Bool has to be a constant function.
18:09:16 <EvanR> data Foo b ... :(
18:09:23 <Cale> So you might as well just make it a Bool again
18:09:30 <ertes> is there an alternative to hashtables?
18:09:43 <EvanR> HashMap...
18:10:03 <joneshf-laptop> Cale, I don't fully understand. Do you have some time to elaborate on why that is?
18:10:31 <ertes> EvanR: a hash table alternative
18:10:36 <geekosaur> joneshf-laptop, because if it can take literally any type a, it cannot know what it has received
18:10:43 <Cale> joneshf-laptop: So, the type of the constructor in the existential case is Foo :: forall a. (a -> Bool) -> Foo
18:11:15 <Cale> joneshf-laptop: So when you pattern match on this value, you unpack a function whose type is (a -> Bool) for some unknown type a
18:11:16 <EvanR> ertes: whats the important part that HashMap doesnt satisfy?
18:11:25 <geekosaur> mutability, presumably
18:11:31 <EvanR> ah
18:11:33 <geekosaur> which is the one thing Data.HashTable had
18:11:38 <EvanR> mutable hash table
18:12:16 <Cale> joneshf-laptop: Since there's nowhere that you could get a value of type a, and no way of discovering which type a is, the only thing you could pass as an argument is something which could have any type whatsoever -- these are in short supply.
18:12:20 <ertes> i really just wanted to see how well a *good* hash table implementation would perform
18:12:28 <EvanR> Data.HashTable.ST.Cuckoo did you try 
18:12:35 <ertes> yeah, i did
18:12:39 <ertes> it's worse than all the others
18:12:43 <EvanR> D:
18:12:55 <ertes> i aborted it after 35 seconds
18:13:19 <EvanR> did you initialize it to the proper size or something
18:13:25 <ajf> I need a function (a -> b) -> IO a -> IO b, do I use <$> or <*> (subjective opinions wanted)
18:13:26 <ertes> yeah
18:13:34 <Cale> joneshf-laptop: (basically just expressions whose value is _|_)
18:13:57 <Cale> joneshf-laptop: In the higher rank case, the constructor has type (forall a. a -> Bool) -> Foo
18:14:01 <ertes> ajf: i only have an objective one:  see which of those fits the type
18:14:08 <ajf> both
18:14:15 <ertes> ajf: not quite
18:14:32 <ajf> oh I misread
18:14:33 <Cale> joneshf-laptop: A function whose type is (forall a. a -> Bool) can't discover which type its argument has, and so can't inspect it in any way: it must ignore it.
18:14:36 <ajf> okay
18:14:43 <ajf> do I get <$> from Functor or Control.Applicative
18:14:56 <ertes> ajf: you get it from Prelude
18:14:56 <Cale> (well, it can use seq on it, but that's a complication which is barely worth mentioning)
18:15:19 <ertes> ajf: it's in the Functor class (see :i (<$>)
18:15:21 <ertes> )
18:15:25 <EvanR> ertes: did you try Data.HashTable.ST.Basic
18:15:37 <ertes> EvanR: yeah, that one gave the best performance
18:15:39 <joneshf-laptop> Cale, OKay. I think I'm starting to get it. Thanks!
18:15:57 <ertes> EvanR: but still slower than my mutable Set Int simulation
18:16:09 <joneshf-laptop> So what if it we add more information to the constructor?
18:16:26 <joneshf-laptop> `data Foo = forall a. Foo (a -> Bool) a`
18:16:31 <joneshf-laptop> where would that put us?
18:16:31 <ajf> ertes: oh… apparently it is in prelude, my bad!
18:16:38 <ajf> hoogle didn't show me that
18:16:59 <ertes> ajf: in GHCi you can ask where names come from using :i
18:17:05 <EvanR> ertes: and in that blog post, they do 1G heap size flag
18:17:06 <ertes> (as long as they're in scope)
18:17:07 <ajf> ertes: neat
18:17:30 <joneshf-laptop> It seems like we know what type `a` is, since we supply it, yes?
18:18:21 <jle`> what exactly are you asking about that data type?
18:18:33 <jle`> how many values of type Foo there are?
18:18:49 <jle`> there really only are effectively two values of type Foo
18:19:06 <jle`> or, all values of type Foo are isomorphic to one of two values
18:19:46 <joneshf-laptop> jle`, originally I wantd to know if you could encode higher rank types without using the extension. I offered an example for an existential instead, was corrected, asked for more explanation and here we are. :)
18:21:17 <EvanR> joneshf-laptop: you could use GADTs extension, which effectively gets you either one
18:21:33 <EvanR> when you use GADT syntax
18:22:30 <joneshf-laptop> I'm not against using the extension. I want to know if it's possible without it.
18:22:40 <joneshf-laptop> even ifits just in a restricted form.
18:22:41 <EvanR> well, it is, GADTs
18:22:43 <EvanR> heh
18:22:49 <ajf> thanks again
18:23:16 <EvanR> or do you mean without any extensions
18:23:30 <joneshf-laptop> Yes
18:23:55 <joneshf-laptop> Just plain haskell 98
18:24:05 <ertes> slice: minor boost by switching to Int32 from Int, which apparently the rust version does, too
18:24:24 <ertes> i'm assuming that "u32" stands for unsigned 32-bit integer
18:24:52 <jle`> joneshf-laptop: and what RankN type would Foo be representing?
18:25:09 <jle`> i do'nt think you can do it in haskell98  .... existential types aren't in haskell98 either, btw
18:25:18 <jle`> RankN types make type inference undecidsable
18:25:25 <jmnoz> can someone point me to a function that converts a couple of different format of strings containing date times to a standard time type?
18:25:27 <jle`> and haskell98's type system is decidable
18:25:44 <jle`> *has decidable type inference
18:25:58 <jle`> so it makes me believe that you can't construct RankN types using only the haskell98 type system
18:26:23 <joneshf-laptop> Im not married to `Foo`, any data type is fine for this example.
18:27:09 <EvanR> jmnoz: look in the time package
18:27:11 <joneshf-laptop> Like perhaps there's some trick in mind with how defunctionalization lets you encode higher order functions in a language with no support for it.
18:27:29 <slice> ertes: lmk when you update /snippets on github
18:27:34 <joneshf-laptop> it's restricted, obviously, but could be used in a case by case basis.
18:28:00 <EvanR> joneshf-laptop: rankN delays the choice of types for a polymorphic function, without it you have to decide at the use site
18:28:11 <joneshf-laptop> jle`, that sounds fair. 
18:28:13 <slice> ertes: I'm trying to compile w llvm 3.7 as suggested
18:28:13 <EvanR> and you have to list all the type variables you use in a data type
18:28:19 <EvanR> i dont see a way to do it 
18:29:25 <joneshf-laptop> EvanR, let's talk more about delaying choice.
18:30:08 <EvanR> in HM... you just dont
18:30:31 <EvanR> if you use polymorphic function f somewhere, then youre committing to a type
18:31:04 <joneshf-laptop> EvanR, could we use some type as a place holder?
18:31:19 <joneshf-laptop> and later convert it to a polymorphic type?
18:31:31 <EvanR> you can choose some monotype, and you cant go back
18:31:35 <jle`> joneshf-laptop: for a closed universe of types, you could simulate one
18:31:58 <jle`> if your only types are Int and Double, then (forall a. a -> Bool) is (Int -> Bool, Double -> Bool)
18:31:59 <joneshf-laptop> jle`, sum them all together?
18:32:10 <jle`> or yeah, (Either Int Double -> Bool)
18:32:23 <joneshf-laptop> Hmm.
18:32:27 <jle`> but actually then Either Int Double would be a type heh
18:32:31 <EvanR> thats not exactly the same thing
18:32:46 <EvanR> now you have two functions that do different things
18:32:52 <jle`> oh yeah, that's true
18:33:21 <jle`> i guess we need a better example function to talk about then, because (forall a. a -> Bool) is essentially just Bool
18:33:35 <joneshf-laptop> Okay. that's fine. what's a better one?
18:33:38 <jle`> so, you could simulate (forall a. a -> Bool) in haskell98 as (() -> Bool)
18:33:47 <jle`> hooray
18:34:37 <jle`> how about (forall a. [a] -> Int), maybe?
18:34:42 <EvanR> dont laugh, () -> Bool is how you indicate there are side effects! 
18:34:51 <EvanR> (in other languages)
18:34:54 <jle`> lol
18:35:24 <joneshf-laptop> Okay. let's go with that.
18:35:34 <jle`> i suppose that (forall a. [a] -> Int) can be simulated with [()] -> Bool, too
18:35:37 <jle`> wow we're on a roll
18:35:39 <joneshf-laptop> beh
18:36:09 <Koterpillar> forall a. [a] -> Int -> [a]
18:36:18 <jle`> ok now that's a bit more interesting
18:36:24 <EvanR> thats a regular polymorphic type
18:36:55 <jle`> yeah, but imagine a function that takes a (forall a. [a] -> Int -> [a]) as an argument
18:37:23 * joneshf-laptop is imagining
18:37:32 <jle`> foo :: (forall a. Int -> [a] -> [a]) -> String -> [Bool] -> (String, [Bool])
18:37:38 <jle`> foo f xs ys = (f xs, f ys)
18:37:58 <EvanR> that works
18:38:11 <joneshf-laptop> erm, what?
18:38:14 <EvanR> missing the integer argument
18:38:19 <joneshf-laptop> yeah
18:38:23 <joneshf-laptop> anyway, i get it.
18:38:40 <jle`> oops
18:38:43 <jle`> yeah
18:38:58 <EvanR> if you move the forall a to the top, then either f i xs or f i ys are ill typed
18:39:12 <EvanR> since f cant be both Char and Bool at the same time
18:39:17 <joneshf-laptop> sure
18:39:18 <EvanR> cant take*
18:39:29 <jle`> so how to simulate using haskell98 types
18:39:30 <joneshf-laptop> So, can you encode that in haskell 98?
18:39:32 <jle`> i don't think you can
18:41:00 <jle`> im sorry
18:41:33 <jle`> hm
18:41:37 <jle`> maybe you can
18:41:39 <joneshf-laptop> If we rewrite it as `foo :: (Int -> [A] -> [A]) -> String -> [Bool] -> (String, [Bool])` and have isos (`A -> Char`, `Char -> A`) and (`A -> Bool`, `Bool -> A`), we coul do something, right?
18:42:10 <jle`> if you have those isos, then you'd have an iso between char and bool
18:42:19 <Koterpillar> with those isos, you can do much more interesting things
18:42:20 <jle`> so like, what?
18:42:35 <joneshf-laptop> Koterpillar, such ash?
18:42:47 <jle`> an iso between Char and Bool, for instance
18:42:52 <EvanR> you want a Char -> Any, and an Any -> Char
18:42:53 <joneshf-laptop> :)
18:42:54 <Koterpillar> foo f xs ys = (f ys, f xs)
18:42:55 <jle`> which is crazy talk
18:42:56 <EvanR> but the And -> Char cant be done
18:43:01 <EvanR> Any
18:43:05 <Koterpillar> joneshf-laptop: so yes, what jle` said
18:43:37 <jle`> joneshf-laptop: i suppose you could encode (forall a. [a] -> [a]) using a monomorphic data type.  in which case, you could deconstruct it and instantiate it for any 'a' you want
18:43:38 <joneshf-laptop> I was imagining `type A = Either Char Bool`
18:43:39 <EvanR> you can have Char -> Any and Bool -> Any
18:43:59 <jle`> joneshf-laptop: there's no iso between A and Bool in that case
18:44:00 <EvanR> jle`: how?
18:44:23 <jle`> well, for example, there are only a coupel functions (forall a. Maybe a -> Maybe a)
18:44:28 <EvanR> joneshf-laptop: now its less type safe and not even as general
18:44:29 <jle`> you could definitely encode them
18:44:40 <joneshf-laptop> jle`, EvanR oh right!
18:44:47 <jle`> i can only think of a couple.  (\_ -> Nothing), and id
18:44:53 <EvanR> jle`: for list though
18:44:56 <jle`> so (forall a. Maybe a -> Maybe a) ~ Bool
18:45:05 <jle`> yeah, so we might be able to think of one for list
18:45:07 <slice> ertes: compiling with llvm37 takes it down to 3.5s
18:45:31 <ertes> slice: we're getting closer =)
18:45:33 <jle`> er, not that it's equivalent to Bool, but that you can encode one as Bool
18:45:50 <jle`> and decode it
18:46:10 <jle`> i feel like ther eshould be a similar encoding for lists
18:46:14 <EvanR> theres a very large number of [a] -> [a] functions ;)
18:46:22 <jle`> it'd be a recursive type ofc
18:46:31 <EvanR> like encoding Nat -> Nat 's
18:46:47 <EvanR> at this point, were certainly not being polymorphic
18:47:02 <jle`> yeah, but all you'd need is fromEnc :: MyEncoding -> (forall a. [a] -> [a])
18:47:19 <EvanR> that uses a rankN type
18:47:22 <jle`> then foo :: MyEncoding -> [Char] -> [Bool] -> ([Char[, [Bool])
18:47:23 <ClaudiusMaximus> ertes, slice - are you allowed to memoize in a large but finite lazy Data.Array ?
18:47:29 <jle`> EvanR: no, that's not rankn
18:47:33 <jle`> er well, it's rank1
18:47:43 <EvanR> oh
18:47:52 <EvanR> tricky
18:47:55 <jle`> foo f xs ys = (fromEnc f 10 xs, fromEnc f 3 ys)
18:48:12 <ertes> slice: new version is pushed
18:48:21 <EvanR> encodings of functions like that as data structures is really useful
18:48:25 <jle`> (if f :: Int -> MyEncoding)
18:48:26 <ertes> slice: it should perform noticably faster
18:48:31 <EvanR> i wish there was a book on it or something
18:48:37 <EvanR> or that i knew of it
18:48:59 <slice> ClaudiusMaximus: that probably goes beyond the rust example
18:49:02 <ertes> ClaudiusMaximus: we aren't really allowed to memoise at all, because that would change the algorithm
18:50:29 <slice> ertes: 3.3s
18:50:46 <slice> the ride keeps speeding up
18:51:19 <EvanR> jle`: you can also define a function you want locally in a let, which makes it polymorphic.... except monomorphism restriction.... also wait why do we care about H98
18:51:48 <jle`> just joneshf-laptop thinking about it for fun presumably
18:52:04 <ClaudiusMaximus> slice, ertes - shame, i get about 1.2s with my implementation
18:52:10 <joneshf-laptop> jle`, have fun, half serious
18:52:52 <joneshf-laptop> It'd be nice to encode higher ranks in elm from time to time, even if it is extremely limited.
18:53:22 <slice> ClaudiusMaximus: I just wanted to know why the rust one was fast, really
18:54:07 <jle`> but yeah, this looks like it'd have to be done on an ad-hoc bases for different types
18:54:17 <jle`> there's no drop in replacement
18:54:20 <joneshf-laptop> that's totally fine
18:54:23 <joneshf-laptop> ad expected
18:54:46 <joneshf-laptop> jle`, EvanR you've given me something to think about, thanks!
18:54:51 <EvanR> encoding functions as data structures has other uses
18:54:59 <ertes> slice: another minor optimisation pushed
18:55:00 <EvanR> would be nice if there was cool syntax for it
18:59:40 <ClaudiusMaximus> ertes, slice - here's my implementation anyway http://lpaste.net/316456
19:01:08 <ClaudiusMaximus> got a link to the rust version?
19:01:22 <ClaudiusMaximus> i came in late
19:02:40 <tnks> I see some libraries double up the constraint (Monoid e, Semigroup e), because Haskell still has some legacy in Prelude on this matter.
19:03:47 <tnks> I wasn't forcing Semigroup to be defined in addition to the Monoid if I was using mempty and mappend.
19:04:10 <tnks> just as a convenience to the library users and to reduce boilerplate on my end.
19:04:15 <tnks> but is that a bad idea?
19:07:10 <slice> ertes: 3 seconds. nice
19:09:16 <slice> ClaudiusMaximus: won't compile
19:09:29 <slice> not in scape: a :: Array i0 Integer
19:09:48 <slice> ClaudiusMaximus: rust: https://github.com/JacksonGariety/euler.rs/blob/master/src/solution_074.rs
19:10:02 <ClaudiusMaximus> slice: woops, that should be table
19:10:19 <ClaudiusMaximus> slice: sorry, was cleaning it up with nicer names and forgot to check...
19:10:28 <ClaudiusMaximus> slice: thanks for the link
19:12:17 <slice> ClaudiusMaximus: memoizationn makes it really fast. That's def the way to go solving the problem. I wrote the rust one in april and struggled to get it under a second. I remember it was implementing an iterator for a struct with the link and the whole chain sped it up dramatically
19:12:21 <ertes> slice: another push
19:12:44 <ertes> slice: another noticable improvement
19:13:49 <slice> ertes: wow 2.3 seconds. It's just slightly slower than rust now. what happened this time?
19:15:46 <ertes> read the commit messages =)
19:15:57 <jmcarthur> Oh, are we playing with a microbenchmark?
19:18:40 <Axman6> yeah, we need links
19:21:02 <jmcarthur> Is it Euler 74?
19:24:40 <Yobokies> can anyone tell me why my function doesn't work? It should return false if duplicates are found:
19:24:49 <Yobokies> invalid :: Cipher -> Bool   
19:24:55 <Yobokies> invalid [] = False
19:24:56 <Yobokies> invalid (h:t) = if (elem h t) && (notElem h ['A'..'Z']) then True else invalid t
19:25:25 <ertes> slice: and the final improvement for today
19:25:45 <ertes> jmcarthur: yeah, but restricted to be the same algorithm that a particular piece of rust implements
19:25:50 <Yobokies> it seems if i remove the && notElem part it works fine..
19:26:07 <l_zzie> are you intending to allow duplicates of A-Z?
19:26:12 <Koterpillar> Yobokies: (||) or (&&)?
19:26:16 <l_zzie> because that's what that code does
19:26:20 <l_zzie> yeah, maybe you mean ||
19:26:25 <Yobokies> not intending to allow dups
19:26:27 <ertes> jmcarthur: this one: https://github.com/JacksonGariety/euler.rs/blob/master/src/solution_074.rs
19:26:50 <Koterpillar> Yobokies: "if h occurs in t, AND it's not a capital latin letter"
19:27:00 <l_zzie> Yobokies, so that code says "if this character is in the rest of the string and it's *not* in A-Z, return True"
19:28:14 <ertes> slice: that last commit i'm not a big fan of, because it makes digitFact a lot uglier
19:28:48 <Yobokies> l_zzie thats right
19:28:59 <Yobokies> its invalid if it is not in A-Z
19:29:13 <l_zzie> Yobokies, that's the opposite of what I said
19:29:18 * hackagebot text-zipper 0.8.2 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.8.2 (JonathanDaugherty)
19:29:35 <slice> ertes: after benchmarking for a while everything ends up where .. go .. where .. go
19:29:55 <Yobokies> l_zzie not in a-z -> return true
19:30:13 <l_zzie> Yobokies, yeah. that's the opposite of what I said your code does
19:30:33 <slice> ertes: the binary search works great though. great piece of code.
19:30:40 <l_zzie> Yobokies: imagine a venn diagram with "A-Z" and "in the rest of the string" as two circles.
19:30:41 <Yobokies> l_zzie oh XD 
19:30:50 <l_zzie> Yobokies, your code does "return True on the overlap"
19:31:09 <l_zzie> Yobokies, what you want is "return true on anything of either of the circles"
19:31:16 <Yobokies> ah
19:31:33 <Yobokies> l_zzie how though
19:31:45 <Yobokies> OR?
19:31:55 <l_zzie> yeah, I think that will do what you want
19:32:09 <Yobokies> ive tried it but it doesnt work?
19:32:24 <Yobokies> i see how it makes no sense to use an AND now so i thought it would work
19:33:02 <l_zzie> what code do you have now, and what results are you getting?
19:33:04 <ertes> slice: yeah, i do that "= go … where go = …" thing a lot =)
19:33:36 <Yobokies> l_zzie ok its magically decided to work
19:33:43 <l_zzie> haha
19:33:54 <l_zzie> often that happens to me when I forget to reload code
19:33:57 <Yobokies> l_zzie i think haskell is trolling me
19:34:22 <Yobokies> l_zzie thats probably what it was
19:34:37 <Yobokies> l_zzie thanks for wording it out before, it helped a lot
19:34:59 <l_zzie> no problem
19:35:16 <l_zzie> for trickier boolean conditions imagining things as a venn diagram often helps me
19:36:48 <ertes> slice: what's really interesting is that binary search is mostly a bad idea…  i'm pretty sure that a good hash table implementation would actually be in par with the rust version, if not even outperform it
19:37:14 <ertes> s/in par/on par/
19:37:53 <l_zzie> binary search is just a weird hash anyway
19:38:27 <slice> ertes: Haskell doesn't have one. What a shame.
19:39:18 * hackagebot semiring-num 0.1.0.0 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.1.0.0 (oisdk)
19:46:14 <cdsmith> So... I am writing a function foo :: (a -> a) -> IO (), and I want to know whether the parameter is the identity function.  Some false negatives are okay: I don't care whether I recognize (+ 0) or other more complicated identities.  For a *given* input, I can find out with unsafePtrEquality#.  Is there an answer that works for all inputs?
19:47:34 <l_zzie> no.
19:47:40 <geekosaur> cdsmith, no
19:47:42 <l_zzie> but you could enforce it on a type level
19:49:26 <EvanR> you could use a different type than a -> a
19:49:31 <cdsmith> Hmm, that's a definite no?  I was hoping there would be some trick...
19:49:58 <cdsmith> I'm not trying to enforce anything.  Just find out, so I can use a more efficient approach and avoid some network traffic.
19:50:14 <EvanR> you cant use pointer equality because anyone can write as many identity functions as they want in whatever way
19:50:19 <Nachtgespenst> A solution to that would involve solving the halting problem, wouldn't it?
19:50:21 <l_zzie> cdsmith, do you know the type a?
19:51:13 <l_zzie> cdsmith, alternatively, you could reorganize the code to not use id.
19:51:20 <EvanR> cdsmith: if instead of a -> a you defined a type EndoFun a and the only way to construct identity was via one of the constructor options, thne you could do it
19:51:35 <l_zzie> and use a Maybe (a -> a) instead
19:51:39 <EvanR> and the user would be limited to whatever they could write using EndoFun
19:51:49 <cdsmith> I do not know the type a, no.  And yes, of course a generally solution would be impossible, which is why I asked about a solution that has some false negatives
19:52:03 <EvanR> you can also do
19:52:23 <l_zzie> I guess you could do something terrible with bottom
19:52:25 <EvanR> data EndoFun a = IdentityFun | NotNecIdentityFun (a -> a), this has false negatives
19:52:38 <EvanR> which is equivalent to the Maybe above
19:52:42 <cdsmith> l_zzie: yes, "something terrible with bottoms" is exactly what I'm looking for
19:53:02 <l_zzie> cdsmith, do "f undefined". if it doesn't throw, it's likely id
19:53:03 <cdsmith> I cannot change the types.  It's better to just give up on the idea than make the types different
19:53:06 <EvanR> if you define the category instance for that, then id would be IdentityFun
19:53:29 <grantwu> doesn't this break with const 1
19:53:37 <cdsmith> l_zzie: but that's not true.  It can be (const x), where x is any value of type a
19:54:07 * geekosaur doesn't know of anything you could do with bottoms. but id is polymorphic, so something evil with recognizing a pointer to it would have false negatives for many things but would recognize id :: a -> a itself.
19:54:18 <glguy> l_zzie: evaluating id undefined would "throw"
19:54:42 <l_zzie> you need a seq too, probably, yeah
19:54:45 <EvanR> cdsmith: have you looked at StableNames
19:54:55 <geekosaur> no, seq won't help here
19:55:03 <l_zzie> won't it?
19:55:06 <glguy> l_zzie: no, this solution has doesn't help
19:55:12 <cdsmith> EvanR: I'm already using them, actually!  But, that still requires checking each possible input separately, right?
19:55:12 <l_zzie> ok. never mind
19:55:16 <glguy> just didn't*
19:55:21 <geekosaur> either the result is lazy and ypou get a thunk, or it is strict and throws for id
19:55:30 <EvanR> cdsmith: input? you check the stable name of the function
19:55:35 <geekosaur> (but *might not* throw for *some* non-id)
19:55:43 <l_zzie> oh, I see.
19:55:53 <EvanR> cdsmith: since this is IO, you dont even unsafePerformIO
19:56:14 <geekosaur> depends on whether they can accept some non-id as id, vs. missing some identities that are not id
19:56:29 <EvanR> get stable name of id, get stable name of input, compare
19:56:34 <EvanR> it might be a false negative
19:56:46 <ertes> Nachtgespenst: a general solution would
19:57:34 <l_zzie> cdsmith, can you have a typeclass on a?
19:57:40 <cdsmith> EvanR: Oh.  Okay, sure... But, alright, I am a little more picky than that.  The input is unlikely to be precisely id BY NAME.  It's more likely that someone defined f 0 y = y ; f 1 y = 42, and then I want to check the property for (f 0)
19:57:50 <cdsmith> l_zzie: Nope, no constraints on the type
19:57:55 <geekosaur> then you lose
19:58:08 <l_zzie> ^
19:58:16 <Cale> Actually, you could do something...
19:58:18 <cdsmith> Okay, thanks!
19:58:20 <EvanR> cdsmith: huh... now youre talking about decidable extensional equality
19:58:36 <EvanR> whats the actual problem
19:59:51 <Cale> There might be something you can do with unsafePerformIO
19:59:58 <cdsmith> EvanR: the problem is that in an educational multiplayer game framework, when the user moves the mouse, I want to know whether I need to transmit the event to the server so it's visible to all other players.  But I don't know the other players' game state.
20:00:17 <Cale> hmm
20:00:30 <EvanR> since its IO, you probably dont need unsafePerformIO
20:00:47 <EvanR> but the requirements here seem on the impossible side of too vague of an optimization
20:01:18 <l_zzie> yeah, I would look for something lower-level
20:01:30 <Cale> EvanR: Well, I mean, you can possibly use unsafePerformIO to tell if the function evaluates its argument
20:01:32 <ertes> cdsmith: what makes you need to transmit it?  how do you decide?
20:01:57 <EvanR> Cale: if they ends up being the problem were really trying to solve
20:02:00 <Cale> The tricky bit is separating the point at which the function has done its work from when you start evaluating its result
20:02:09 <EvanR> if that*
20:02:10 <Cale> id after all, is a strict function
20:02:13 <cdsmith> ertes: I want to send it, if there's any chance that it could make a difference.  (Getting it wrong in the direction of sending too many updates is okay, though; which is the answer to the undecidability bit)
20:02:36 <l_zzie> what are you sending?
20:02:40 <EvanR> Cale: im not sure we even got to the point where they want to detect if the function is strict or not
20:02:48 <cdsmith> l_zzie: mouse coordinates for a UI event
20:02:51 <ertes> cdsmith: are you trying to reduce bandwidth usage?
20:02:54 <EvanR> but thats an interesting side topic
20:02:56 <cdsmith> ertes: yes
20:03:22 <l_zzie> cdsmith, can you wrap it all in something that says "if the mouse coordinates aren't different, don't do anything"?
20:03:24 <Cale> But id is sort of, the laziest strict function -- it doesn't evaluate the argument for you, it just hands it back and tricks you into doing that instead.
20:03:29 <jmcarthur> All I can think of is to see if the function is strict. If it's not strict, it's not id. But this isn't helpful for you.
20:04:22 <ertes> cdsmith: and what's the strategy?  send if moved a certain distance from the last transmitted point?
20:04:32 <Cale> If there's a way we can detect the boundary between the unknown function starting and finishing its evaluation, and the moment at which the argument is evaluated, then we'd be able to detect id.
20:04:35 <EvanR> heh, strictness detection by empirical evidence
20:04:42 <cdsmith> Cale: I was thinking along these lines.  So I can build a bottom value b, and make a stable name for it, then evaluate`f b`.  But, then I need to force it exactly one level deep.
20:04:47 <EvanR> maybe ghc should use that
20:04:52 <Cale> However, I don't know whether this is quite doable in GHC...
20:05:29 <Cale> In particular, it's hard to take f x and tell when "f is done"
20:05:42 <cdsmith> Cale: Yes, precisely
20:05:48 <jmcarthur> It's probably doable with a little cmm or something, but I can't say what that should look like.
20:06:12 <cdsmith> Oh yeah, before we get TOO low-level, I should mention I want it to work with GHCJS
20:06:16 <jmcarthur> ah...
20:06:20 <Cale> ah haha
20:06:51 <cdsmith> Normally, that's surprisingly not a problem, though.  I'm already using lots of StableName and StaticPtr tricks with GHCJS
20:06:54 <jmcarthur> I don't understand the stable name idea.
20:07:04 <jmcarthur> Stable names aren't guaranteed to be the same before and after evaluation.
20:07:15 <EvanR> jmcarthur: the original question was "check if the argument 'is id'"
20:07:27 <EvanR> and "false negatives are ok"
20:07:32 <EvanR> thus, stable names
20:07:39 <EvanR> and whenever you use stable names, you evaluate first of course
20:07:47 <cdsmith> Yes... but I needed a slightly broader meaning for "is id" :(
20:07:55 <jmcarthur> I understand that. However, at least in plain GHC (don't know about ghcjs), stable names actually change upon evaluation.
20:08:01 <EvanR> and whenever you use stable names, you evaluate first of course
20:08:09 <EvanR> and "false negatives are ok"
20:08:11 <jmcarthur> Ah.
20:08:18 <jmcarthur> Aha
20:08:34 <jmcarthur> I was still in the "detecting strictness" line of thought.
20:08:36 <EvanR> if that was the actual problem, itd be solved ;)
20:08:53 <ertes> you could make strictness assumptions about the function
20:09:25 <jmcarthur> cdsmith: Broader how? Things like   f x = x + 1 - 1  ?
20:09:54 <ertes> or force its result using NFData
20:10:24 <cdsmith> Mmm actually, the type a fairly commonly contains infinite lists... so NFData is a bad idea
20:10:33 <EvanR> oh a is not any type?
20:10:38 <cdsmith> jmcarthur: that one is fine to not detect
20:10:44 <cdsmith> My code is polymorphic in a
20:10:54 <cdsmith> But my students' code is not... and I know what they tend to do
20:11:36 <cdsmith> In particular, at some point, I hand them an infinite list of random numbers, and they often want to keep it. :)
20:11:37 <ertes> i think the whole thing is a bad idea, because you're deciding semantics based on something that should be undecidable
20:12:00 <ertes> it has a similar wrongness feel to it as observable sharing
20:12:04 <cdsmith> ertes: I'm not changing semantics in the *big* picture (where the network is just an implementation detail)
20:12:05 <Cale> There are cases where I could imagine this sort of hackery could be quite useful for performance reasons
20:12:17 <EvanR> i know that wrongness feel
20:12:28 <jmcarthur> I am not totally opposed to this idea. It's "wrong" but not crazy.
20:12:40 <jmcarthur> Or maybe I should say it's crazy but not wrong?
20:12:42 <jmcarthur> :)
20:13:05 <EvanR> as long as the program still works, you can do whatever you want!
20:13:23 <ertes> it's definitely "wrong", but the real question is whether this couldn't be solved simply by actually communicating that piece of information
20:13:26 <jmcarthur> Maybe there's something that can be done on the js side.
20:13:36 <EvanR> ertes: i suggested that first
20:14:05 <EvanR> but that *would* be kind of intrusive for being a "transparent" optimization
20:14:29 <l_zzie> I still think the best place to implement this would be below the application layer
20:14:38 <ertes> that's why i asked for the strategy earlier
20:14:56 <l_zzie> "is it a mouse move packet? is it the same as the last mouse position? if so, drop it"
20:15:03 <cdsmith> I'm fighting very, very hard to not make the client API more complicated.  I'd rather just eat the performance loss than do that
20:15:29 <ertes> the packet thing sounds reasonable, and it doesn't make the API more complicated
20:16:01 <jmcarthur> My understanding is that this would make the API more complicated because it would need to be able to tell what type a is.
20:16:17 <jmcarthur> (But maybe a Typeable constrain wouldn't be asking too much?)
20:16:20 <jmcarthur> *constraint
20:16:38 <ertes> at some point you need to know enough about 'a' to build a network packet, don't you?
20:17:04 <jmcarthur> Ah, you're suggesting that this function is the wrong place for the optimization.
20:17:07 <EvanR> thats whats weird, the a -> a
20:17:09 <ertes> at that point you probably know at least how to compare
20:17:17 <ertes> yeah
20:17:21 <cdsmith> jmcarthur: I created a whole new Prelude to eliminate all type classes... so I can't add a type class now. :(
20:18:07 <jmcarthur> I've come around to the idea that maybe this should just be a protocol optimization.
20:18:57 <jmcarthur> Of course, perhaps that makes no sense. Hard to guess.
20:19:58 <cdsmith> Okay, thanks for all the input!  Sounds like I was right to be stuck :)
20:20:15 <cdsmith> I can just not worry about this one
20:24:20 * hackagebot semiring-num 0.1.0.1 - Basic semiring class and instances  https://hackage.haskell.org/package/semiring-num-0.1.0.1 (oisdk)
20:29:25 <Cale> cdsmith: what did type classes ever do to you?
20:29:53 <cdsmith> Cale: Made error messages suck
20:30:31 <cdsmith> Cale: This is for my middle school classes -- age 11-13 or so.
20:30:42 <Cale> ahh
20:34:51 <pikajude> a Prelude without typeclasses...
20:34:55 <pikajude> so, do notation is out then
20:36:19 <PhsShft> when I try to run my test file, it gives me  The IO action ‘main’ is not exported by module ‘Main’  
20:36:24 <PhsShft> what’s the problem here?
20:36:51 <grantwu> What does your Main module export?
20:37:15 <PhsShft> http://lpaste.net/316547
20:37:24 <Cale> PhsShft: You probably have an extraneous module declaration
20:37:24 <PhsShft> this is the header for my codefile
20:37:37 <Cale> Yeah, you need to call it Main
20:37:40 <Cale> Not Lab3
20:37:59 <Cale> You may also just remove the module declaration
20:38:10 <PhsShft> i see
20:38:16 <PhsShft> thank you
20:38:22 <PhsShft> it fixed my problem
20:38:35 <cdsmith> pikajude: right, no do notation in student code.  I can use it, though!
20:39:00 <Cale> If you really need to import this stuff from somewhere else, there's a compiler flag --main-is which you could use to set it to Lab3.main if you wanted
20:39:18 <Cale> But usually you just do without the module declaration on your main program source file.
20:39:19 <pikajude> thing1 `thenIO` thing2
20:39:29 <Cale> (because it's rare to want to import that stuff elsewhere anyway)
20:59:21 * hackagebot text-zipper 0.8.3 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.8.3 (JonathanDaugherty)
21:00:53 <knx32542> I am looking to creating a GUI program using Qt. However, this being my first excursion into GUIs, there is an overwhelming amount of options. Do you have any recommendations for Qt in haskell?
21:01:52 <knx32542> Among the options I saw mention of variants such as Qt Quick and qml, and I am not yet clear what the differences are.
21:10:13 <ab9rf> i didn't realize qt was still around
21:10:21 <ab9rf> i've never liked Qt much
21:10:48 <EvanR> qt is its own OS almost
21:11:01 <EvanR> and because its C++, bindings are a pain
21:11:13 <ab9rf> i seem to recall that it requires a metacompiler, as well
21:11:37 <ab9rf> it also has a checkered history, having been owned by nokia for several years
21:13:18 <ab9rf> qtah is an incmplete binding, per its author
21:13:28 <nitrix> ab9rf: QMake (the .moc files)
21:13:40 <EvanR> knx32542 is gone, but i would have suggested 3 penny gui
21:14:33 <ab9rf> nitrix: i got into a rather nasty snitfit with one of qt's developers back in the late 90s
21:15:24 <nitrix> ab9rf: They pulled it off, but it's an absurd idea.
21:16:52 <nitrix> Presumably, there are things that are just meant to be usable and convenient; rather than principled and beautiful :]
21:22:52 <pie_> whooa, just thought to check some statistics
21:22:59 <pie_> more people in here than the python channel
21:25:14 <ab9rf> so?
21:25:26 <pie_> *shrug*
21:25:43 <pie_> friend just said "that's because haskell is impossible to use, and python/c/c++ are easy and intuitive." :(
21:26:07 <EvanR> sounds like youre being trolled
21:26:14 <pie_> probably half joking
21:26:18 <pie_> ab9rf, well it shows people are interested :)
21:27:06 <EvanR> i buy that those are easy and intuitive
21:27:28 <EvanR> im imagining the feeling of something being easy and intuitive not having anything to do with other things
21:28:40 <EvanR> segfaults runtime errors incomprehensible object layouts... ive been there and i still felt like it was all easy and intuitive
21:28:46 <Cale> The idea that C++ is more intuitive than Haskell has a fair amount of irony to it.
21:29:11 <ab9rf> C++ is more intuitive than haskell when you already know C++ and do not know Haskell
21:29:22 <Cale> You could fit the Haskell Report the GHC User's Guide and a whole lot of papers several times over in the space of the C++ specification.
21:29:29 <pie_> people get taught/find imperative stuff not functional
21:29:54 <pie_> Cale, heh.
21:30:15 <EvanR> easy and intuitive are feelings rather than technical features
21:30:25 <ab9rf> as someone who used to teach intro to CS, i must assert that i've spent many hours exlpaining that "a = b + 1" does not make a equal to b+1 for all time.
21:30:29 <jmcarthur> Something is true, therefore C++ is easy and intuitive.
21:30:32 <EvanR> C++ mechanisms and specifications are cold hard facts
21:31:21 <ab9rf> at least some students have to be beaten out of the functional interpretation
21:31:30 <jmcarthur> C++ was easy and intuitive, but I just incremented it, so I don't even know anymore.
21:31:35 <pie_> ab9rf, oh the irony
21:31:39 <EvanR> lol
21:33:02 <EvanR> python is easy and intuitive, that is built into the culture
21:33:09 <EvanR> why didnt haskell think of that
21:33:19 <jmcarthur> I knew something felt a bit off about us.
21:33:32 <pie_> im kinda sorta starting to learn haskell
21:33:55 <pie_> my main issue, or at least what i feel my main issue is, is that its easy to come up with imperative algorithms but i cant really do functional algorithms
21:34:35 <jmcarthur> In other news, I just saw in my history that somebody was asking about GUI stuff because they were overwhelmed by the number of options. Never thought I'd see the day.
21:34:38 <EvanR> when i first looked up haskell, the wikipedia page for it said that it was difficult to implement new monad instances
21:34:44 <Cale> pie_: If you have an imperative algorithm which mutates some variables but doesn't do I/O, there's a mechanical way to translate it into a functional progrma
21:34:58 <pie_> Cale, hm.
21:35:00 <jmcarthur> Mechanical, but not very informative.
21:35:15 <Cale> pie_: What you can always do as a last resort is to turn each point of control in the imperative program into a function, and the mutable variables in scope there into function parameters
21:35:16 <EvanR> bad marketing
21:35:33 <grantwu> Just convert it into SSA form :^)
21:35:35 <Cale> pie_: Then have the functions apply each other to new arguments according to the control flow and how the variables are updated
21:35:42 <pie_> Cale, ah yeah makes sense
21:35:53 <Cale> pie_: This will initially result in a mess, but it's a mess *of equations*
21:35:53 <grantwu> I guess this is what Cale is describing
21:36:20 <EvanR> also itll be recursive equations right
21:36:21 <Cale> So, you can start simplifying those equations like you would simplify algebraic equations in highschool
21:36:28 <EvanR> isnt that an issue for the optimizer
21:36:29 <Cale> EvanR: If there are any loops, yes
21:36:32 <jmcarthur> Ah, I was expecting him to mention simulating pointers.
21:36:37 <ab9rf> Cale: i have some ANCIENT fortran code that does some evil nonsense with an array that i've been meaning to try to conviert to a functional algorithm
21:37:19 <jmcarthur> EvanR: The optimizer seems to do pretty well with a set of mutually tail recursive functions.
21:37:30 <EvanR> mkay
21:37:33 <Cale> Yeah, it's not so much for the optimiser's sake
21:37:56 <Cale> You just might want to try simplifying them for your own understanding, and to work your way towards a more reasonable functional program
21:38:45 <jmcarthur> I find that the trickiest algorithms to port from imperative style involve arrays and/or pointers.
21:38:54 <grantwu> heh.
21:39:02 <grantwu> the trickiest parts to SSA involve arrays and pointers...
21:39:14 <pie_> varargs :P
21:39:16 <jmcarthur> The array case can be difficult but rewarding once you figure out how to make it more functional.
21:39:33 <jmcarthur> Pointers are sometimes just crazy and you end up with pointers or something like them in the end anyway.
21:39:52 <Cale> Sometimes, depending on how the pointers get used, you can just use values.
21:40:04 <jmcarthur> A notorious example is union-find.
21:40:09 <Cale> Or variables rather
21:40:26 <Cale> But that's sort of tricky
21:41:03 <jmcarthur> I really like porting dynamic programming problems because they are often really nice to express with knot tying.
21:41:26 <Cale> And yeah, for dynamic programming stuff, you can use lazy arrays
21:41:30 <Cale> and recursion
22:19:43 <qweqwe> hey
22:20:14 <grantwu> Hello
22:21:29 <qweqwe> just checking out this channel, heard about it from some random site
22:21:42 <sham1> Welcome
22:21:56 <qweqwe> i am into c programming, is their any major difference between c and haskell?
22:22:55 <grantwu> Yes
22:23:36 <Rotaerk> heh
22:23:39 <Axman6> there are very few similarities between C and Haskell in fact
22:23:50 <grantwu> They are different in almost all aspects while still both being programming languages
22:24:46 <Koterpillar> C lets you shoot yourself in the foot in runtime, while Haskell shows you horrible images* of what would have happened at compile time
22:24:54 <Koterpillar> *half-screen error messages
22:25:06 <qweqwe> great! so tell me what is haskell really used for? (forgive my curiosity and stupidity)
22:25:38 <Koterpillar> probably as wide range of applications as C
22:25:59 <Axman6> anything and everything
22:25:59 <sham1> Haskell is used for general programming
22:26:37 <Axman6> I write webservices in Haskell, lots of data processing. lots of people like writing compilers in it. used quite heavily in the financial industry
22:26:56 <sham1> So you can do almost everything C can in Haskell
22:27:57 <qweqwe> cool
22:36:07 <qweqwe> JOIN #rindia
23:01:11 <seafood> What’s a good HTTP client these days (not HTTP server)
23:01:21 <seafood> I mean, what is a good HTTP client library.
23:02:04 <grantwu> I heard wreq is okay; I haven't actually used it yet but it seems ok
23:02:23 <grantwu> s/it seems ok/the api docs seem pretty good/
23:04:29 <seafood> Okay. Any other options?
