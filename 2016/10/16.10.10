00:03:27 <magneticduck> effectiveness in programming languages seems like a hard problem to metricize
00:04:26 <EvanR> the more money youre spending on development, the more effective it is
00:04:31 <EvanR> at doing something
00:04:45 <EvanR> such as reducing the debts of the employees
00:06:03 <ertes> i still think that emacs and vim with the right extensions are nothing short of "IDEs"
00:06:38 <EvanR> its not an IDE because you cant point and click on stuff
00:06:56 <ertes> that's a rather useless definition of IDE
00:07:01 <magneticduck> EvanR: well, you don't generally get more out of a programmer by paying them over a certain baseline
00:07:04 <EvanR> im serious
00:08:07 <ertes> i'll talk about emacs, but the same applies to vim:  emacs is a "development environment", and haskell-interactive-mode adds the "integrated" part
00:08:43 <EvanR> since strictly defining development environment and integrated clearly misses some points, we have to find out what that point is
00:09:23 <ertes> i don't think there is a point…  any *useful* definition of "IDE" will include emacs/vim + extensions
00:09:28 <EvanR> i believe the difference is that when eclipse or atom pop up, the user believe its an IDE because the first thing they do is navigate the menus or press the "play" buttons with the mouse
00:09:36 <magneticduck> EvanR might just be pointing out that most computer users want buttons
00:10:00 <EvanR> what does that have to do with the expansion of "IDE", nothing
00:10:26 <ertes> EvanR: it's just that most things that sell themselves as "IDEs" have those fancy UI traits
00:10:36 <EvanR> super users are placated by having key combos, and we have the status quo
00:10:45 <ertes> just like many windows users will think of a "shell" as something with buttons
00:11:16 <magneticduck> (emacs supports buttons)
00:11:18 <EvanR> as i recall, a shell on windows is a completely graphical environment, zero commands
00:11:23 <ongy> windows users think of shells? :)
00:11:27 <ertes> "it has a run button, so it's an IDE" ~ "it has a parent-directory button, so it's a shell"
00:11:28 <EvanR> vim and emacs both have GUIs but they dont count
00:11:28 <magneticduck> petition: button-mode
00:11:52 <ongy> vim gui...
00:12:56 <ertes> it's the usual problem with vaguely defined terms =)
00:13:10 <ongy> I'm surprised that the vim gui is more than the xdg thing I set for folders: term -c vim
00:13:23 <EvanR> with families of GUI apps people get into a mode where they expect 4 or 5 particular things, dont read the manual, and manage to get stuff done
00:13:41 <EvanR> if you go rewrite it to make it a better app, it better have those 5 things people have come to expect, and theyll never use the rest of the things
00:13:42 <ertes> but i find the "IDE = stupid click-GUI" definition useless and would rather prefer something that lets me distinguish my emacs configuration from "just an editor"
00:14:02 <EvanR> with vim and emacs, you cant discover anything like that or expect anything, its 100% read the manual
00:14:17 <magneticduck> definitions aside, an IDE that caters to the public at large does have to have buttons
00:14:24 <EvanR> if you want to make a new editor like vim or emacs, you can do whatever you want, your users will read the manual and be smart
00:14:37 <ertes> that's not quite true…  emacs has a menu that is enabled by default, and the help system is structured in a context-sensitive manner
00:14:47 <EvanR> they wont expect anything in particular, except maybe a plugin to make it exactly like vim
00:14:52 <ertes> vim certainly is more traditional: "RTM!"
00:15:26 <EvanR> i opened the help system in emacs
00:15:34 <EvanR> but i couldnt navigate it or close it ;)
00:15:53 <magneticduck> it took me an afternoon to learn to use emacs well enough to start learning it
00:16:21 <ertes> EvanR: press C-h, then look at the minibuffer…  it tells you everything you need to know to understand the help system =)
00:16:45 <EvanR> i guess idris mode hide that part of the minibuffer
00:17:38 <magneticduck> when I learned emacs, I spent a few days reading through the elisp manual because I felt like I needed to learn it 'from the fundamentals'
00:17:47 <ertes> (it tells you to press ? to see all options, offering you, among other things, a help on help)
00:18:19 <suppi> saurabhnanda: I had a horrible experience with Java in my previous company. it was a fresh project 
00:18:20 <magneticduck> at a certain point I realized that emacs is a hodge-podge of elisp from 1990 and it would take about 2 years to understand everything
00:19:32 <suppi> ran for about a year with JavaFX. development slowed down significantly the more we worked on it. i felt crushed by callbacks and mutable state. it was quite slow to respond to boot
00:20:12 <suppi> i was a student at the time btw. work with more experienced programmers than me
00:20:56 <magneticduck> hey, what happened to Forth
00:21:18 <suppi> i understand that this is anecdotal as well though
00:23:10 <EvanR> forth is so old
00:23:33 <EvanR> everyone is on fifth now
00:23:58 <JuanDaugherty> joke?
00:24:05 <M2tias> joke.
00:24:15 <JuanDaugherty> ty
00:24:46 <magneticduck> colorforth was a leap ahead of its time; I'm still waiting for other languages to start being colorful
00:25:16 * JuanDaugherty thought java was a joke when i first heard of it c. '95, that and numerous others have taught me to ask
00:25:28 <suppi> EvanR: not sure that's maybe go up by a factor of something 
00:25:43 <ertes> forth?  that platform-agnostic assembly language?
00:26:09 * JuanDaugherty bets nobody has heard of MINT (Hendry, et. al.)
00:26:11 <suppi> that's -> about that.
00:27:25 <magneticduck> oh, and how are those revolutionary languages that don't use text-based source doing? 
00:28:40 <JuanDaugherty> you mean like labview/G? not so good but it's a complex time
00:28:41 <magneticduck> it seems ~likely that there's a more optimal solution to the problem of 'creating, editing and displaying structured information with a computer' than 'how about a bunch of rows of characters' 
00:29:03 <JuanDaugherty> actually NI/labview is doing OK
00:29:15 <magneticduck> (on the other hand, the 'rows of characters' solution seems to be doing fairly well)
00:29:27 <JuanDaugherty> but graphical programming per se not so much
00:29:35 <magneticduck> JuanDaugherty: I think there are others, including one that integrates Haskell
00:30:02 <JuanDaugherty> as a special case of things that are there in pieces but don't gel to widespread cultural use
00:30:27 <JuanDaugherty> which is not the case for G/NI which has a trapped and lucrative market
00:30:34 <ertes> magneticduck: our programming patterns are mostly 2D, and text is a versatile medium for 2D-structured information…  i don't see myself using 3D patterns any time soon
00:30:41 <JuanDaugherty> some of the most aggressive lock-in i've ever seen
00:30:56 <EvanR> magneticduck: re: likely something better than "rows of characters"--    nahhhhh
00:31:11 <magneticduck> EvanR: oh, how about .. columns of characters?
00:31:26 <EvanR> otoh lisp people have said balanced parenthetical trees of characters
00:31:35 <EvanR> for pretty much ever
00:31:39 * JuanDaugherty has thoughts on this for a new human interlingua based on principles similar to hanzi and hangul
00:32:14 <EvanR> personally it should be n-dimensional hypercubes of characters
00:32:52 <EvanR> of course, ascii characters
00:33:19 <magneticduck> here we are http://www.luna-lang.org/ and http://www.lamdu.org/
00:34:20 <magneticduck> I give luna an A for making me feel excited, and lamdu a B for making me feel like it might enter producting at some point
00:34:28 <magneticduck> s/producting/production
00:34:45 <EvanR> Traditional software development is broken by design
00:34:49 <EvanR> i knew it
00:35:25 <EvanR> hmm, graphics + text seems interesting
00:35:30 <ertes> "to learn the internals of this code, just head to the hypersphere over there" – "i've been doing that for ages!"
00:35:56 <EvanR> graphics makes your screen look sort of like minority report / iron man, while you can actually see what youre doing on the right
00:36:00 <magneticduck> there are certainly a lot of design decisions in the modern world that were locked in at an earlier stage of technology
00:36:06 <JuanDaugherty> https://www.quora.com/What-variants-of-Hermann-Hesses-The-Glass-Bead-Game-are-in-existence also relevant
00:36:31 <magneticduck> on one hand, these designs (text-based source code, keyboards, etc) seem to be very effective and have been time tested
00:36:46 <magneticduck> on the other hand, it seems unlikely that there isn't some better way of doing them
00:37:17 <ertes> there is certainly a better programming medium than text for a race more advanced than humans…  it's like dreaming of flying cars…  the human mind can barely handle 2D streets without crashing
00:37:48 <EvanR> magneticduck: the blurb about category oriented... that was funny until it literally mentions dependent types, on a brochure 
00:38:03 <EvanR> they might be on to something
00:38:10 * hackagebot pomohoro 0.1.2.4 - Initial project template from stack  https://hackage.haskell.org/package/pomohoro-0.1.2.4 (kqr)
00:38:12 * hackagebot ip2location 8.0.3 - IP2Location Haskell package for IP geolocation.  https://hackage.haskell.org/package/ip2location-8.0.3 (ip2location)
01:38:12 * hackagebot libroman 3.1.1 - Use Roman Numerals as a Numeric Datatype (sort of)  https://hackage.haskell.org/package/libroman-3.1.1 (ahakki)
01:38:14 * hackagebot ip2location 8.0.4 - IP2Location Haskell package for IP geolocation.  https://hackage.haskell.org/package/ip2location-8.0.4 (ip2location)
01:44:27 <koz_> Is there defined Rational -> Rational -> Rational division?
01:45:01 <lyxia> Isn't it /
01:45:12 <koz_> lyxia: I'm never sure anymore. :P
01:45:31 <sdx23> :t (/)
01:45:34 <lambdabot> Fractional a => a -> a -> a
01:45:49 <liste> :t (%)
01:45:51 <lambdabot> Integral a => a -> a -> Ratio a
01:46:09 <liste> (1 % 2) / (2 % 3)
01:46:16 <liste> > (1 % 2) / (2 % 3)
01:46:19 <lambdabot>  3 % 4
01:48:37 <EvanR> % is the smart ctor for rationals (or ratios)
01:48:43 <EvanR> / is division
01:49:14 <EvanR> in a field
01:50:52 <merijn> > 2 / 3 :: Rational
01:50:55 <lambdabot>  2 % 3
01:52:05 <EvanR> Infinity :: Rational
01:54:38 <EvanR> > toRational (1/0 :: Double) 
01:54:40 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
01:59:09 <koz_> Could someone help me understand how to do this? http://lpaste.net/251850
02:01:26 <merijn> koz_: tbh, I don't quite understand what you mean there
02:02:07 <koz_> merijn: The final result of that function will be an m (MVPair), where m is an instance of MonadRandom.
02:02:12 <merijn> What's the types of randomTable and makeRep, for example
02:02:37 <koz_> However, to call P.makeRep, I need something of the form (Int, Int) -> MVPair.
02:02:48 <koz_> Now, I'm *already* in a MonadRandom in this function.
02:04:18 <koz_> (randomTable :: MonadRandom m => Int -> m T.Table, and makeRep :: (a -> m a) -> (a -> o) -> m a -> RepParams o m a)
02:05:16 <merijn> "But this expects something that isn't in a MonadRandom" <- what do you mean by that?
02:05:35 <koz_> The second argument to makeRep needs to be an (a -> o).
02:05:45 <koz_> What I have is an (a -> m o), where m is a MonadRandom.
02:06:40 <koz_> What I'm used to dealing with is 'need an o, have an 'm o''.
02:06:42 <merijn> I don't understand what makeRep is doing, but the conclusion from what you've written is: "you're boned"
02:06:58 <merijn> What is 'o'?
02:07:09 <koz_> In this case, or in general?
02:07:16 <merijn> In this case
02:07:33 <koz_> In this case, a is (Int, Int) and o is MVPair.
02:07:57 <merijn> Why does the conversion from (Int, Int) to MVPair require a monadic operation?
02:09:13 <koz_> merijn: Hold on, I think I know where I messed up. THanks!
02:09:39 <merijn> I mean, the simple answer to "understand how to do this?" is "you don't". So the real question would be figuring out how to do what you want in a different way, but tbh I don't quite understand what you want :)
02:13:20 <koz_> merijn: It's OK - I got how to do it.
02:13:33 <koz_> I basically had to split off the state using MonadSplit, and then feed that into the computation.
02:13:39 <koz_> I *thought* there was a way.
02:14:20 <EvanR> dude theres so many monad transformer classes going on
02:14:32 <koz_> EvanR: They're pretty neat.
02:14:42 <EvanR> as long as youre having fun ;)
02:16:43 <koz_> EvanR: I am. Slowly losing my mind, but in a fun way. :P
02:38:13 * hackagebot cabal-src 0.3.0.2 - Alternative install procedure to avoid the diamond dependency issue.  https://hackage.haskell.org/package/cabal-src-0.3.0.2 (MichaelSnoyman)
03:28:37 <koz_> Why can my code not saturate my cores...
03:28:58 <koz_> I can't get this thing at more than ~50% of core usage.
03:29:16 <tdammers> I/O bound?
03:29:28 <koz_> tdammers: Unlikely, given I only do a tiny bit of I/O at the very end.
03:30:15 <cocreature> koz_: threadscope can sometimes be useful to figure this out
03:30:31 <cocreature> koz_: you are compiling with -threaded and setitng -N right?
03:30:33 <opqdonut> or perhaps +RTS -s, and spark stats
03:31:03 <tdammers> cache? RAM?
03:32:12 <koz_> cocreature: Yes, -N4 actually.
03:32:33 <koz_> opqdonut: I've been checking on spark stats - I seem to consume everything.
03:32:58 <opqdonut> well then I guess you should create more sparks?
03:33:07 <opqdonut> 4 cores? have you tried a higher -N?
03:33:22 <cocreature> if you can’t saturate 4 cores a higher -N won’t help :)
03:33:22 <koz_> opqdonut: I thought you're meant to set -N to the number of cores you have?
03:34:24 <opqdonut> if there's some overhead or blocking stuff, a slightly higher N can help
03:34:52 <opqdonut> anyway it's an easy thing to rule out
03:38:14 * hackagebot bookkeeper 0.2.3 - Anonymous records and overloaded labels  https://hackage.haskell.org/package/bookkeeper-0.2.3 (jkarni)
03:38:16 * hackagebot servant-auth 0.2.0.0 - Authentication combinators for servant  https://hackage.haskell.org/package/servant-auth-0.2.0.0 (jkarni)
03:38:18 * hackagebot servant-auth-server 0.2.0.0 - servant-server/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-server-0.2.0.0 (jkarni)
03:38:20 * hackagebot servant-auth-client 0.2.0.0 - servant-client/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-client-0.2.0.0 (jkarni)
03:38:22 * hackagebot servant-auth-docs 0.2.0.0 - servant-docs/servant-auth compatibility  https://hackage.haskell.org/package/servant-auth-docs-0.2.0.0 (jkarni)
03:38:23 <koz_> I think I'll set this thing to profile overnight and see what it says in the morning.
03:38:25 <koz_> I'm tired...
03:43:25 * hackagebot servant-matrix-param 0.3 - Matrix parameter combinator for servant  https://hackage.haskell.org/package/servant-matrix-param-0.3 (jkarni)
03:47:33 <koz_> :t traverse
03:47:36 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:49:10 <koz_> For parTraversable, am I right in assuming that you should be able to replace 'traverse' with 'parTraversable strat' for some strat and it'll work?
03:49:18 <koz_> Because I'm not having much success with that at the moment...
03:50:04 <nshepperd1> koz_: is your program gc bound
03:50:18 <koz_> nshepperd1: How would I be able to check this?
03:50:23 <nshepperd1> Because that's shared among cores..
03:51:11 <nshepperd1> Uh, there's some kind of gc profiling you can do i think but i have no idea how
03:53:25 <cocreature> iirc "+RTS -s" gives you a "productivity" value
03:53:30 <cocreature> and gc times
03:59:13 <koz_> Could someone help me parallelize 'traverse' using Control.Parallel.Strategies?
03:59:17 <koz_> I'm a bit confused.
03:59:51 <koz_> I have '(n,v) <- unzip <$> traverse theNeedful ts', and I wanna do the mapping part of 'traverse' in parallel, but I'm not sure how to write this...
04:07:19 <x1n4u> is ther someway i can make RedisCtx m f => Data.ByteString -> m (f (Maybe Data.ByteString)) to RedisCtx m f => Data.Text -> m (f (Maybe Data.Text)) with encodeUtf8 and decodeUtf8
04:07:58 <x1n4u> for get
04:08:20 <riaqn> hello, I 'm looking for method to convert Ptr to Uarray.
04:08:32 <riaqn> or can I?
04:10:27 <riaqn> I wonder if I actually sent the messages.
04:12:00 <lyxia> x1n4u: If you also assume Functor f, you can apply (fmap . fmap . fmap . fmap) decode, for some   decode :: ByteString -> Text   of your choice.
04:12:26 <lyxia> riaqn: you did
04:12:30 <x1n4u> lyxia: thanks 
04:15:11 <ongy> looking at that, why is https://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array.html for [a] not Traversable a?
04:18:03 <lyxia> ongy: What is a
04:19:26 <ongy> type variable for the list content in the doc e/(i,e)/(i,a)
04:23:10 <lyxia> I don't get what you're asking about. Traversable a doesn't typecheck if a is supposed to be the second parameter of Array.
04:24:09 <lyxia> Why do you mention [a]
04:26:04 <enthropy> koz_, what happens with the strategy "traverse rpar"?
04:31:06 <ongy> I think I confused Foldable and Traversable
04:31:29 <ongy> and not for the content of the array, but the functions building it
04:38:16 * hackagebot toolshed 0.17.0.2 - Ill-defined library.  https://hackage.haskell.org/package/toolshed-0.17.0.2 (AlistairWard)
04:38:18 * hackagebot textlocal 0.1.0.0 - Haskell wrapper for textlocal SMS gateway  https://hackage.haskell.org/package/textlocal-0.1.0.0 (psibi)
04:38:20 * hackagebot period 0.1.0.4 - Parse and format date periods, collapse and expand their text representations.  https://hackage.haskell.org/package/period-0.1.0.4 (alkar)
04:38:22 * hackagebot factory 0.2.2.1 - Rational arithmetic in an irrational world.  https://hackage.haskell.org/package/factory-0.2.2.1 (AlistairWard)
04:39:05 <M2tias> is Learn You a Haskell writer still here?
04:42:04 <merijn> M2tias: He hasn't been around for several years
04:42:10 <M2tias> figured
04:42:36 <M2tias> are you the guy quoted on the No Starch page of his book? :D
04:43:00 <M2tias> oh, no, nvm. you have realname on irc
04:50:10 <larsm> :vsp
05:21:12 <puregreen> a question about haskell-mode (or hasktags, I'm not sure): has anybody stumbled upon a problem when after a while all tags in the TAGS file become duplicated? here's a piece of the TAGS file to show what I'm talking about: http://lpaste.net/3206642795309694976
05:24:47 <muzzle> hi, how can I work with timezones like 'Asia/Jakarta' in Haskell?
05:25:03 <puregreen> muzzle: use the tz package
05:25:09 <puregreen> @hackage tz
05:25:10 <lambdabot> http://hackage.haskell.org/package/tz
05:25:43 <Profpatsch> I think I remember something about an extension or a trick so that `(\True -> Just "foo") False` will actually return Nothing instead of crash.
05:25:51 <Profpatsch> Is that just my imaginations
05:26:00 <Profpatsch> s/s^/?^/
05:26:36 <Rembane_> Profpatsch: You can use maybe or one of it's sister functions from Data.Maybe to do that.
05:26:58 <Profpatsch> s:s/s\^/?\^/:s/s\$/?\$: :)
05:27:13 <Rembane_> Profpatsch: Fire ze missiles?
05:27:48 <Profpatsch> I’m kind of relieved I did that replacement-replacement correctly.
05:27:59 <Profpatsch> The replacement-replacement-replacement would have been hard.
05:30:27 <muzzle> puregreen: thx
05:30:30 <muzzle> that looks suitable
05:38:17 * hackagebot protolude 0.1.8 - A sensible set of defaults for writing custom Preludes.  https://hackage.haskell.org/package/protolude-0.1.8 (sdiehl)
05:38:19 * hackagebot fishfood 0.0.1.6 - Calculates file-size frequency-distribution.  https://hackage.haskell.org/package/fishfood-0.0.1.6 (AlistairWard)
05:42:28 <lyxia> Profpatsch: \ ~True -> Just "foo"
05:43:38 <lyxia> ah I didn't read correctly
05:44:07 <lyxia> do { True <- False ; Just "foo" }
05:45:39 <mauke> needs more return
05:46:11 <lyxia> but then it looks like javascript :(
05:49:07 <Tuplanolla> Also `join [Just "foo" | True <- return False]`.
05:49:24 <Tuplanolla> Not that it's any better.
05:49:57 <mauke> :t \x -> guard x >> return "foo"
05:49:59 <lambdabot> (Alternative m, Monad m) => Bool -> m [Char]
05:51:03 <lyxia> mfilter (const False) (Just "foo")
05:51:15 <poi> :t gard
05:51:17 <lambdabot> error:
05:51:17 <lambdabot>     • Variable not in scope: gard
05:51:17 <lambdabot>     • Perhaps you meant ‘guard’ (imported from Control.Monad.Writer)
05:51:54 <poi> :t guard
05:51:56 <lambdabot> Alternative f => Bool -> f ()
05:55:11 <Tuplanolla> > ["foo" | True <- return False] :: Maybe String -- I meant to write this.
05:55:13 <lambdabot>  error:
05:55:14 <lambdabot>      • Couldn't match expected type ‘Maybe String’
05:55:14 <lambdabot>                    with actual type ‘[[Char]]’
05:55:53 <Tuplanolla> Turn on your MonadComprehensions.
05:57:13 <mauke> > ["foo" | False]
05:57:15 <lambdabot>  []
06:00:30 <riaqn> I find that, using hsc2hs, I don't need to write C anymore.
06:00:57 <riaqn> any C can be rewritten in Haskell in similar style and efficiently.
06:01:32 <riaqn> All foreign import you need is those from C standard library, and posix, etc.
06:02:27 <mauke> FFI can't handle macros, variadic functions, struct values
06:03:08 <merijn> mauke: FFI can handle macros now! :D
06:03:20 <merijn> mauke: Have a look at GHC's capi FFI :)
06:38:18 * hackagebot large-hashable 0.1.0.2 - Efficiently hash (large) Haskell values  https://hackage.haskell.org/package/large-hashable-0.1.0.2 (StefanWehr)
06:38:20 * hackagebot yi-rope 0.8 - A rope data structure used by Yi  https://hackage.haskell.org/package/yi-rope-0.8 (DmitryIvanov)
06:38:22 * hackagebot wai-middleware-static 0.8.1 - WAI middleware that serves requests to static files.  https://hackage.haskell.org/package/wai-middleware-static-0.8.1 (ryanglscott)
06:51:48 <ggVGc> how would I do this with prisms? https://gist.github.com/31d89d51ae9d61309f1d9ccbc6bd9f6e
06:53:17 <lyxia> list comprehension would be shorter
06:54:38 <ggVGc> thanks
06:54:39 <ggVGc> :)
06:54:52 <ggVGc> I always forget to use list comprehensions
06:55:40 <jle`> ggVGc: you can write f using preview and prisms on your SeqOn/SeqOn type if you have them i suppose
06:55:48 <jle`> > preview _Left (Right "hello")
06:55:51 <lambdabot>  Nothing
06:55:52 <jle`> > preview _Right (Right "hello")
06:55:55 <lambdabot>  Just "hello"
06:56:04 <jle`> if that was what you're asking for
06:56:31 <ggVGc> jle`: hm, but I also wanted to extract the value
06:56:51 <ggVGc> ah
06:56:56 <ggVGc> with mapMaybe it'd work out
06:57:02 <ggVGc> I thought there was a way without mapMaybe
06:57:08 <osa1> hmm so if I declare multiple functions in one like (e.g. `x, y, z :: X -> Y`) I can't document them.. right?
06:57:58 <jle`> ggVGc: yeah, traversals preserve container size
06:58:01 <lyxia> osa1: not individually I'm afraid
06:58:20 <osa1> https://www.haskell.org/haddock/doc/html/markup.html#idm140354810917952 doesn't mention it
06:59:10 <lyxia> ggVGc: you could use the traversal as a fold
07:00:14 <jle`> oh yeah, if your target is just going to be a list anyway
07:01:28 <lyxia> > [Left 'a', Right ()] ^.. traverse . _Left
07:01:31 <lambdabot>  "a"
07:10:41 <ggVGc> what am I doing here? does it make sense? https://gist.github.com/627efe16ed980fcc34e5ec4ef3050cf8
07:10:47 <ggVGc> should I be using a type class?
07:10:50 <ggVGc> or something else?
07:11:29 <cocreature> ggVGc: you could use MonadState if you want
07:11:34 <ggVGc> I'm trying to generalise step so it can handle a single sequencer or a group of sequencers
07:12:55 <dramforever> TH Question: is the number in Language.Haskell.TH.Syntax.NameFlavour, NameU [1] guaranteed to be unique? Or do I have to compare the name anyway?
07:13:00 <dramforever> [1]: https://hackage.haskell.org/package/template-haskell-2.11.0.0/docs/Language-Haskell-TH-Syntax.html#v:NameU
07:14:11 <dramforever> Um... What about this: Can two 'NameU's ever get the same 'number'?
07:15:43 <marzist> Hello!
07:16:29 <cocreature> hey marzist 
07:17:25 <marzist> so does anyone use haskel at a job or anything?
07:17:46 <delYsid> Is it expected that I see "ghc-prim-0.4.0.0:GHC.Prim.Constraint" as last thing when doing :k in ghci?
07:17:48 <enthropy> dramforever, should be unique if the "instance Quasi Q" follows the one for IO https://github.com/ghc/packages-template-haskell/blob/master/Language/Haskell/TH/Syntax.hs#L87
07:18:01 <delYsid> What does it mean, why does it have to look so ugly?
07:18:17 <cocreature> delYsid: I think it’s that ugly if Constraint is not imported
07:18:37 <tdammers> marzist: yes, quite a few people here do. I have myself, but am not currently.
07:19:00 <enthropy> the library code for newName seems to not reference any actual operation for the Q instance
07:19:12 <delYsid> cocreature: I was guessing that, just wondering what it is, because I dont remember having seen it ever prior to 7.10
07:19:34 <cocreature> delYsid: it’s the kind of typeclass constraints
07:20:15 <enthropy> ghc's source code probably has some special case for newName
07:20:29 <delYsid> cocreature: So it indicates to me that there is a constraint, but doesnt show it... doesnt look very useful to me.
07:20:53 <dramforever> delYsid: It means in a hidden package ghc-prim, version 0.4.0.0, module GHC.Prim, there's a kind called Constraint
07:20:53 <marzist> tdammers: that's pretty interesting. what is haskell usually used for in such senarios?
07:21:03 <cocreature> delYsid: well you are viewing the kind not the type? it’s just like :k Maybe will show you * -> * and not Maybe
07:21:36 <dramforever> i.e. the kind of stuffs like (Monad Maybe), (Num Int), (MonadState Int (State Int)), etc. (last one is IIRC)
07:21:58 <tdammers> marzist: don't know what's "usual"; I used it for an automated compliance checker for websites - you'd feed it a URL, and it would start up a phantomjs browser, simulate a typical user interaction against the website, collect some stats, and then present a report
07:22:14 <tdammers> marzist: I still use Haskell for rapid prototyping, it's a great thinking aid fo rme
07:22:24 <dramforever> Why that is a kind is an implementation detail, and whether its exposure is a feature or a bug, well, is subjective
07:23:28 <dramforever> enthropy: But what if I got the variable from a [| ... |] quote?
07:23:55 <marzist> tdammers: that's a pretty creative way to use haskell. I should try using it in my enviroment more
07:24:54 <merijn> dramforever: FYI Constraint is also in GHC.Exts
07:25:13 <merijn> dramforever: Which is the place you're supposed to get extension specific imports
07:25:20 <merijn> GHC.Prim is primitive compiler voodoo :)
07:26:07 <dramforever> That's true, but see above for context.
07:27:05 <merijn> Context is hard >.>
07:28:01 <dramforever> Forget about that. I guess I'll just use the Eq/Ord instances on Name and hope things work alright
07:29:27 <delYsid> I wrote my first 60 lines of library code, and surprisingly, it looks useful (to me :-).  Comments welcome, github.com/mlang/braille-parsers (src/Text/Parser/Braille.hs)  reading parsers code finally made me sort of understand why and how to use typeclasses to produce generic interfaces for various backends, pretty cool!
07:30:44 <geppettodivacin> delYsid: GitHub says the repo is empty. :-\
07:30:52 <geppettodivacin> Did you push?
07:30:53 <delYsid> gah
07:31:24 <delYsid> fixed
07:38:20 * hackagebot regexdot 0.12.0.1 - A polymorphic, POSIX, extended regex-engine.  https://hackage.haskell.org/package/regexdot-0.12.0.1 (AlistairWard)
07:38:22 * hackagebot regexchar 0.9.0.14 - A POSIX, extended regex-engine.  https://hackage.haskell.org/package/regexchar-0.9.0.14 (AlistairWard)
07:38:24 * hackagebot Cartesian 0.6.0.0 - Coordinate systems  https://hackage.haskell.org/package/Cartesian-0.6.0.0 (SwiftsNamesake)
07:38:26 * hackagebot yi 0.13.1 - Yi editor  https://hackage.haskell.org/package/yi-0.13.1 (DmitryIvanov)
07:38:28 * hackagebot yi-core 0.13.1 - Yi editor core library  https://hackage.haskell.org/package/yi-core-0.13.1 (DmitryIvanov)
07:43:30 * hackagebot yi-frontend-pango 0.13.1 - Pango frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-pango-0.13.1 (DmitryIvanov)
07:43:32 * hackagebot yi-frontend-vty 0.13.1 - Vty frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-vty-0.13.1 (DmitryIvanov)
07:43:34 * hackagebot yi-ireader 0.13.1 - Yi editor incremental reader  https://hackage.haskell.org/package/yi-ireader-0.13.1 (DmitryIvanov)
07:43:36 * hackagebot yi-keymap-cua 0.13.1 - Cua keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-cua-0.13.1 (DmitryIvanov)
07:43:38 * hackagebot yi-keymap-emacs 0.13.1 - Emacs keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-emacs-0.13.1 (DmitryIvanov)
07:46:36 <Xnuk> whois --
07:48:40 * hackagebot yi-keymap-vim 0.13.1 - Vim keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-vim-0.13.1 (DmitryIvanov)
07:48:42 * hackagebot yi-language 0.13.1 - Collection of language-related Yi libraries.  https://hackage.haskell.org/package/yi-language-0.13.1 (DmitryIvanov)
07:48:44 * hackagebot yi-misc-modes 0.13.1 - Yi editor miscellaneous modes  https://hackage.haskell.org/package/yi-misc-modes-0.13.1 (DmitryIvanov)
07:48:46 * hackagebot yi-mode-haskell 0.13.1 - Yi editor haskell mode  https://hackage.haskell.org/package/yi-mode-haskell-0.13.1 (DmitryIvanov)
07:48:48 * hackagebot yi-mode-javascript 0.13.1 - Yi editor javascript mode  https://hackage.haskell.org/package/yi-mode-javascript-0.13.1 (DmitryIvanov)
07:53:07 <Xnuk> Is there anyone who uses Yi as main editor (especially for Haskell) ?
07:53:50 * hackagebot tce-conf 1.3 - Very simple config file reading  https://hackage.haskell.org/package/tce-conf-1.3 (DinoMorelli)
07:58:52 <Denommus> hi
07:59:37 <Denommus> any of you guys have used transcient? What do you guys think?
08:01:11 <c_wraith> I tried transient once.  I thought the base idea is good, but the execution isn't production-ready
08:01:21 <c_wraith> It doesn't work with cabal
08:01:36 <c_wraith> (All sorts of incorrect upper bounds)
08:01:45 <agocorona> author here
08:02:14 <agocorona> it compiles in hackage, so it must compile with cabal I think
08:02:36 <c_wraith> it compiles when you upload it
08:02:42 <c_wraith> Not a month later
08:02:54 <c_wraith> Because it doesn't have correct upper bounds
08:03:25 <agocorona> that's the old battle of upper bounds. 
08:05:28 <c_wraith> The ghcjs integration also doesn't really work with cabalized projects.  Some of that is cabal's fault - it needs the ability to specify compilers for particular targets.
08:06:01 <c_wraith> But if you manually work around that, you discover that it has no idea how to find js output when generated by cabal
08:07:15 <JonReed> Hi, is there a way to iterate over all Symbol values of a type family constructing a value level list? Let's say I have a `type family MyFamily (a :: Symbol) :: *; type instance MyFamily "hello" = Int`. Then I want to get a list ["hello] from MyFamily, which represents all existing instances of MyFamily. 
08:08:51 <JonReed> So, when I new instance is added, then that list would be updated. So adding `type instance MyFamily "new" = Bool` would give ["hello", "new"]
08:09:12 <c_wraith> JonReed: *maybe* with template haskell.  I don't know if you can reify a type family.
08:12:00 <agocorona> I think the cabal nighmare of upper bounds can be solved  by using the dependency versions of the sucessful hackage compilation. But this may be too complicated since it has not been tried
08:12:30 <hvr> agocorona: that's an often heard suggestion... but it sadly won't work in general
08:13:00 <agocorona> It should work with a little of extra effort in most of the cases. IMHO
08:13:26 <hvr> agocorona: the devil's in the details
08:13:47 <hvr> agocorona: it will only work for the simplest cases
08:14:02 <hvr> but hackage is far from that "simple" domain
08:14:09 <agocorona> In general it won't work , but this is not a math 
08:14:26 <hvr> agocorona: well, you're free to knock yourself out at trying it :-)
08:14:45 <hvr> if it turns out it works, we can use it
08:15:14 <agocorona> Why not add this as an option?
08:15:51 <agocorona> It would work better than the other option: making you figuring out the correct dependencies during hours or days
08:16:46 <hvr> agocorona: that's the fallacy here: you only end up wasting time figuring out the correct deps if the bounds weren't added in the first place
08:17:12 <hvr> agocorona: that's what I often have to do as a hackage trustee and it's *much* harder to revers engineer missing bounds
08:17:21 <agocorona> hvr that collide with Stack and I want to use both
08:17:45 <hvr> agocorona: well, stack collides with hackage then
08:18:13 <hvr> agocorona: but really, Stack can simply ignore the valuable information that semantic versioning and version bounds provide
08:18:26 <monochrom> I don't think stack or stackage collides with hackage. I think you are misinterpreting stack or stackage.
08:18:29 <hvr> agocorona: we don't have to cripple hackage & cabal just for Stack's sake
08:19:13 <hvr> monochrom: I don't think it collides either
08:19:16 <c_wraith> Looks like reify doesn't work on type families
08:19:34 <hvr> monochrom: in fact, stackage ought to be a set of solution points of hackage
08:19:53 <c_wraith> Oh, have to use reifyInstances
08:20:15 <monochrom> yeah, that's my understanding of stackage too
08:20:19 <hvr> monochrom: since hackage encodes more the more powerful meta-data, while stackage picks single instances that are solutions in that space
08:20:46 <agocorona> how not if stackage don't want upper bounds and hackage need them?
08:21:15 <monochrom> where can I read that stackage doesn't want upper bounds?
08:21:31 <c_wraith> "GHC internal error: ‘Foo’ is not in scope during type checking, but it passed the renamer"  wow
08:21:36 <tdammers> stackage just has fixed versions, doesn't it
08:21:39 <monochrom> actually, where can I also read that hackage needs upper bounds?
08:21:45 <tdammers> it's stack that prefers to not have upper bounds,
08:21:47 <c_wraith> I wonder if this is fixed later
08:22:10 <tdammers> the idea being that without upper bounds, future versions are more likely to keep resolving
08:22:16 <Tuplanolla> Could a solution exist that doesn't require version numbers?
08:22:19 <monochrom> does stack absolutely reject upper bounds? or does stack simply grunt about it?
08:23:09 <agocorona> monochrom:  that detail does not matter, the fact is that this forces two different version policies
08:23:30 <Tuplanolla> I had this passing thought of interfaces themselves determining the version.
08:23:34 <agocorona> and the net result is confusion
08:23:44 <monochrom> That is not detail. That is premise/assumption.
08:24:01 <hvr> monochrom: hackage says on its frontpage that packages are to comply w/ the PVP; the PVP is basically semantic versioning; semantic versioning requires accurate version bounds
08:24:01 <monochrom> I always only question the premises.
08:24:17 <hvr> monochrom: you may be interested in http://pvp.haskell.org/faq
08:24:39 <monochrom> hvr, does the hackage server actually enforce it?
08:25:14 <hvr> monochrom: no, it's not enforced for social reaons
08:25:19 <agocorona> stack can figure out how to fit versions.  I think that cabal can do it too but for some reason it does not want to add a bit of intelligence or flexibility to do that
08:25:49 <dcoutts> agocorona: sorry, what does that mean?
08:27:02 <agocorona> It means that some options can make things easier like for example, a option --use-hackage-sucessful-dependencies
08:28:06 <agocorona> and not wait for a paper from phill Wadler that solves it all in all cases
08:28:25 <dcoutts> I see, you mean fixing version constraints to match reality
08:29:03 <agocorona> reality is a word that I like very much
08:34:45 <monochrom> hvr: I now remember one more reason to not enforce. Even when programmatically enforced, people will just add "base < 10" like dons did. :)
08:35:26 <dcoutts> monochrom: you may recall that we didn't add that requirement for PVP reasons, it was to help with the base 3 -> 4 transition
08:35:42 <c_wraith> It still proves the point, though. :)
08:35:51 <dcoutts> that point, yes
08:36:06 <dcoutts> though it's related, the reason base 3 -> 4 broke everything is that there were no upper bounds
08:36:27 <dcoutts> so we could not tell which packages were going to need base 3 vs those ones that would need base 4
08:36:54 <agocorona> I personally can not predict the future. At most I can assume what a build program can assume: that the next major version may break my code. But If a program can figure it out, Why I HAVE to tell HIM?
08:36:56 <c_wraith> Oh, that's right..  there were a couple versions of ghc that had parallel versions of base
08:38:09 <dcoutts> agocorona: because writing that program is hard, it's not need completed yet, and two it's not true in general, though it does cover most cases
08:38:21 * hackagebot squeeze 1.0.4.12 - A file-packing application.  https://hackage.haskell.org/package/squeeze-1.0.4.12 (AlistairWard)
08:41:45 <dcoutts> need/been
08:42:14 <agocorona> then, supposing --use-hackage-sucessful-dependencies is doable, this one would not be difficult to implement   --use-last-minor-version-from-hackage-sucessful-dependencies
08:47:43 <glguy> monochrom: The solution to these base < 10 bounds is to always bump your major versions to one past the largest upper bound on hackage rather than just incrementing them on change
08:47:49 <glguy> (which could explain HTTP's version)
08:50:46 <dolio> I thought that HTTP's version was becasue it used to have YYYY.MM.DD versioning, and then they switched to semantic versioning.
08:51:22 <glguy> I was joking, I don't think anyone actually does what I said
08:51:37 <monochrom> haha
08:57:00 <Denommus> c_wraith: can I just use nix instead of cabal? :-P
08:58:28 <agocorona> glguy: but you joke is illustrative about the meaning of upper bounds (or the lack of it)
09:00:08 <Aruro> is it possible to install latest ghc-head with stack?
09:00:17 <Aruro> to check out backpack
09:03:09 <agocorona> upper bound IMHO in a write-once repository like hackage has little sense. It is a tradition useful only when you can write back the cabal a time later, to add the upper limits
09:03:21 <dcoutts> agocorona: no, it's not write once
09:03:38 <dcoutts> you can do exactly that, revise the constraints later to match reality
09:04:16 <glguy> When a versions come out of a dependency that a package is compatible with, we will update the upper bound accordingly
09:04:39 <agocorona> But theory is not the same than practice:  Who does it?
09:04:54 <glguy> Lots do; you can see the revisions list
09:05:00 <dcoutts> agocorona: you can edit the .cabal file on hackage after a release, for packages you maintain. Plus hackage trustees can do it for all packages
09:05:05 <glguy> maintainers and trustees
09:05:29 <glguy> Not everyone abandons their packages upon upload to hackage
09:06:38 <agocorona> glguy:  on the contrary abandoning is adding a upper bound. Maintaining is adding a new version that will have the same upper bound problem
09:07:22 <glguy> No, that's not the case. When a new version of a dependency comes out and is verified to work with an existing package a maintained package will have that information recorded in a revision to its hackage metadata
09:07:59 <monochrom> that is not my understanding of "abandon"
09:08:53 <glguy> I consider a version to be abandoned when it no longer builds because the maintainer didn't bother putting upper bounds on and the dependencies have since advanced and the maintainer neglects to update the metadata
09:09:38 <glguy> which then breaks all packages depending on that version of the package
09:09:48 <agocorona> It is clear that there aro two different cultures in Haskell
09:10:17 <maerwald> only two?
09:10:45 <MarcelineVQ> "Those who fit this analogy and those who don't"
09:11:03 <monochrom> :)
09:11:04 <maerwald> I think the only thing haskellers agree on is "type safety" :P from then... it goes everywhere
09:11:54 <monochrom> It is not clear to me that two or more different cultures imply so much fundamental conflict that you have to choose sides.
09:12:20 <maerwald> yes, let's escalate this: everyone choose a side now!
09:12:28 <monochrom> In fact, my lurking observation is that it is clear to me that you don't have to choose sides, you can satisfy many sides at once.
09:12:31 <MarcelineVQ> I'm on team green
09:12:58 <monochrom> a whole lot of packages are on both hackage and stackage, and work pretty well through both cabal and stack.
09:13:40 <monochrom> the two conventions may have some conflict, but clearly not great enough to be mutually exclusive.
09:14:09 <monochrom> so if you claim mutual exclusion, I would want to see strong evidence. not just "IMO".
09:14:33 <glguy> the gap is bridged in large part by the trustees that clean things up
09:22:17 <agocorona> I would caricaturize it so sorry: one is waiting for a paper from Phil Wadler to do something. The other get whatever it finds useful and clutter everything with bad ideas from other languags 
09:23:35 <agocorona> and there is very little in the medium term
09:24:13 <Malkrith> What are monads?
09:24:57 <bob_twinkles> burritos =P
09:24:59 <glguy> Types that support implementations (>>=) and return that support the documented "monad laws"
09:25:02 <dmj`> Malkrith: monoids in the category of endofunctors
09:25:02 <bob_twinkles> more seriously, an interface
09:27:49 <Gurkenglas> Wouldn't Monad be the interface and monads the instances?
09:28:28 <monochrom> agocorona, I cannot use your sentence to explain edwardk's lens library. It is not waiting for Wadler (because it has already happened), it is not chalk full of ideas from other languages (good or bad), and it is not little (it is "one" library if you count that way, but it has such huge impact that everyone talks about it).
09:31:27 <Denommus> Malkrith: monads are types with an associated "join" and "return" functions, and these functions must follow some laws
09:31:57 <Gurkenglas> monochrom, you could call ekmett basically phil wadler so he doesnt have to wait for his own papers (now lets look up who this wadler guy is)
09:32:09 <Denommus> Malkrith: a monad is always an applicative functor (which has an "ap" and a "pure" functions, that also must follow some laws), and an applicative functor is always a functor (which has an "fmap" function, which also follows some laws)
09:33:05 <ania123> hi all
09:34:13 <ania123> if I have a type system where type inference is not decidable, would be it reasonable to design a type programming language using this type system?
09:34:59 <agocorona> monochrom: I don´t see the huge undertaking on lenses (don´t kill me, please)
09:40:24 <srhb> ania123: Lots of languages don't have type inference. They're not all unreasonable.
09:40:33 <srhb> ania123: (I don't think I understand what you're _really_ asking)
09:42:53 <ania123> srhb: all typed language implements type inference, is not?
09:43:51 <sshine> no.
09:43:57 <ania123> no?
09:44:09 <sshine> not all typed languages have type inference.
09:44:10 <jophish> ania123: lots of languages require explicit annotations
09:44:21 <jophish> even Haskell lots of the time
09:44:34 <ania123> if a language does not have decidable type inference
09:44:45 <srhb> ania123: I would wager the inverse is true. Most typed languages do not have type inference.
09:44:46 <ania123> how type of expressions is assigned?
09:44:47 <ania123> for example
09:45:01 <ania123> if foo is a function of type t->r
09:45:09 <ania123> and  arg is of type s
09:45:19 <jophish> ania123: the compiler tries to find a type, and might not halt while compiling 
09:45:22 <jophish> (is one possibility)
09:45:22 <ania123> how can we chachek wthere f arg is well typed
09:45:23 <ania123> ?
09:45:35 <sshine> ania123, TypeScript doesn't have much type inference. :)
09:45:40 <srhb> ania123: "Yes."
09:46:00 <srhb> ania123: It's a good question, the answer depends on the language. :)
09:46:02 <ania123> I am asking more theretical point of view
09:46:33 <jophish> It's possible to make GHC not terminate during type checking using UndecidableInstances or UndecidableSuperClasses
09:46:41 <ania123> ski, are you here? you like types :)
09:46:45 <srhb> ania123: Are you sure you're asking about inference? In many cases, and in many languages, we can check if something is well-typed without having type _inference_
09:47:20 <ania123> srhb: let assume we have a polimorphyc regular type system
09:47:28 <sshine> ania123, well, all programming languages deviate in their explicitness from formal semantics. so you might say there's kinds of inference on vaguely specified languages, but actual type inference as decided by a well-formulated type inference algorithm isn't necessary for a programming language to have types.
09:48:03 <ania123> I am asking from theretical point of view
09:48:11 <ania123> if a type system is not decidable
09:48:29 <sshine> ania123, what's the question again?
09:48:36 <ania123> and include such type system in a prorgamming language, how types of expressions ar einferried 
09:49:31 <ania123> foo : t-->r and arg : s  where t and s are regular expressions 
09:49:38 <ania123> over variables and symbols
09:50:24 <ania123> in general we do not have algorthm to check whether s<<t, and hence we can not say foo arg is defiend or not...
09:50:27 <sshine> ania123, your sentences seem a little fragmented. I'm not sure I understand what you're saying about decidability.
09:51:01 <sshine> ania123, that depends on the type system.
09:51:09 <sshine> ania123, and what "s<<t" means.
09:51:34 <ania123> I mean, if we do not have algorthm which takes two types t and r and decided whetehr t is a subtype of r
09:51:45 <ania123> << is a subtype relation
09:51:47 <sshine> ok
09:51:49 <sshine> then...
09:52:32 <zyhn> being decidable is not a prerequisite for being useful.  e.g. java
09:52:48 <sshine> and having an algorithm is not the same as the problem being decidable or not.
09:53:27 <ania123> sshine: if we have decidibility, we can check whether t<<s holds! we do nto care solving of it!
09:53:37 <erisco> what does decidable mean if it does not mean having an algorithm?
09:53:56 <sshine> ania123, so you're talking about some kinds of type systems that are undecidable. and you're talking about some PLs having type inference. and then?
09:54:19 <sshine> erisco, I mean, having an algorithm /= being able to have an algorithm
09:54:23 <srhb> I think something is getting lost in translation. I'm not sure we all agree what type *inference* means.
09:55:05 <sshine> srhb, surely that is inferred!
09:55:10 <srhb> :P
09:55:41 <ania123> I am thinking, about static adn dynamic type systems, if I have an undecidable type inference,  what is a better to consider static or dynamic type ssytems?
09:55:49 <monochrom> and then, the halting problem is solved! :)
09:55:52 <srhb> ania123: What do you mean by type inference? And sorry if I'm mistaken about that definition being the problem.
09:56:13 <monochrom> static is always better than dynamic
09:56:31 <ania123> about type inference i mean, we have systaematic way to infer types fot each expression 
09:56:53 <srhb> That didn't help much but sounds vaguely right. Oh well. :)
09:56:57 <ania123> if a type ssytem is not decidable statically, can be it decidable dynamically?
09:57:16 <erisco> I don't know what significance dynamic types have in this context
09:57:24 <sshine> ania123, what's a dynamic type system? do you mean unityping?
09:57:41 <erisco> the answer is that the problem doesn't change
09:57:46 <ania123> https://en.wikipedia.org/wiki/Type_system#STATIC
09:57:50 <erisco> it doesn't matter if you run it at runtime or run it at compile time
09:57:55 <ania123> her eu can find what is static and dynamic types
09:58:28 <ania123> erisco: are you sure about it?
09:58:37 <erisco> yes
09:58:40 <monochrom> there are sentences not decidable, not even dynamically
09:59:21 <sshine> ania123, static typing is preferred. this is simply knowing you got problems sooner rather than later. should the presence of type inference somehow affect this?
09:59:22 <monochrom> If I send you programs and ask even just "which of them terminates? which of them don't?", you're hosed.
09:59:47 <Denommus> is it possible to implement a palindrome parser in something like parsec?
09:59:49 <monochrom> You're welcome to try static analysis. You're welcome to simply test-run. Either way you're hosed.
10:00:05 <monochrom> You're welcome to mix static and dynamic techniques and you're still hosed.
10:00:24 <ania123> erisco: I have found some papers, where they are convincing that static type system converted into dynaimc type solves such problems...
10:00:43 <erisco> well you are being far too crude with your assessment
10:00:48 <srhb> What does that even mean?
10:01:25 <sshine> I think the halting problem is an attitude problem! I mean, the proof is simply nosiness! "I'll give you back a program that wraps around your program." is kind of like giving someone their christmas present from last year back in new wrapping. nobody appreciates it.
10:01:31 <erisco> in certain situations, based on specifics, there may be some affected problems
10:02:12 <monochrom> sshine, I don't understand the "nosiness" part.
10:02:37 <ania123> erisco: may I pm you for a second?
10:02:40 <sshine> monochrom, sorry, that was a wrong translation.
10:02:57 <sshine> monochrom, I was thinking cheekiness in my own language.
10:03:10 <monochrom> yes
10:03:34 <erisco> "static typing", "dynamic typing", "type inference" … these are vague, far too vague to be drawing conclusions such as "undecidable static typing problems can be solved dynamically"
10:03:43 <erisco> what type systems are we talking about? what problems are we talking about?
10:04:22 <monochrom> sshine: Do you have a better proof or disproof? :)
10:04:30 <ania123> erisco: are you aware about constrained types?
10:04:43 <sshine> monochrom, no, and I also did once pass on a present I couldn't use to someone else.
10:04:49 <sshine> monochrom, I'm part of the problem.
10:06:04 <erisco> ania123, types which have propositional constraints?
10:06:59 <ania123> any constraints,...
10:07:34 <erisco> ania123, the difference between static and dynamic checking can be this: statically you are trying to verify a "for all", i.e. showing it always happens or never happens
10:07:59 <erisco> ania123, at runtime you can merely check that the particular case you're dealing with satisfies
10:08:33 <erisco> but these are different problems with different implications
10:08:45 <erisco> so it isn't that the problem became easier at runtime, it is that you are solving a different problem
10:09:28 <erisco> you may be okay with a runtime check because the bigger disaster is reading or writing out of array bounds
10:09:45 <erisco> i.e. it is worth letting the program crash with a runtime exception
10:10:59 <erisco> the cost to statically verify the array access could be too high, or impossible with existing tools
10:11:49 <erisco> costs in development time, possibly compile time … consider that liquid Haskell can take minutes to compile a file, for example
10:14:03 <erisco> the problem with dynamic checking like this is that you encounter all the problems live
10:14:25 <erisco> there is no indication a priori that something is wrong
10:36:40 <ggVGc> why am I getting type errors here? https://gist.github.com/40dccffb03405d0382717016c82634a1
10:38:23 * hackagebot plot-gtk-ui 0.3.0.2 - A quick way to use Mathematica like Manipulation abilities  https://hackage.haskell.org/package/plot-gtk-ui-0.3.0.2 (sumitsahrawat)
10:38:29 <glguy> ggVGc: Because SeqRunnerState ind st a doesn't match st
10:39:27 <ggVGc> oh wait
10:39:29 <glguy> ggVGc: You need to put (f ind v state) back into  the runnner
10:39:30 <ggVGc> hah yeah, I was being stupid
10:39:31 <glguy> _sq field
10:39:34 <ggVGc> glguy: thanks!
10:39:49 <ggVGc> I've gotten dizzy from all this generic programming
10:39:59 <ggVGc> also pretty sure I have no idea what I'm doing
10:40:18 <shapr> ggVGc: means you're learning stuff :-) GOOD JOB!
10:40:27 <shapr> at least, that's what I tell myself when I get frustrated :-P
10:40:52 <ggVGc> well, it's doing what I want so far, but I'm pretty sure I'm reinventing some already created general concept
10:40:55 <ggVGc> that exists as a library
10:41:03 <ggVGc> but I'm gonna finish it and then ask here so someone can tell me what I did
10:42:03 <shapr> ggVGc: sometimes I have to reinvent/rediscover that general concept before I am able to understand it.
10:42:36 <ggVGc> yep
10:42:51 <ggVGc> Ihaven't been able to articulate what I want to make, so I figured I just have to build what I can first
10:43:02 <ggVGc> to get further help from someone
10:43:05 <quangl> hi
10:45:12 <byorgey> hi quangl 
10:46:44 <shapr> quangl: written any cool code?
10:48:34 <quangl> ya man
10:48:34 <GLM> How can I pass multiple header values to a wreq request>
10:48:42 <quangl> but not in haskell
10:49:02 <quangl> was trying to get a grip on the power of haskell
10:49:17 <EvanR> ggVGc: yeah, its easy to get carried away with engineering
10:49:23 <quangl> im a javascript formally .net 
10:49:42 <quangl> i just want to know what haskell can do
10:49:47 <EvanR> next time i try a huge app, ill try to do things with less framework
10:49:54 <ski> ania123 : hmm ?
10:50:06 <ania123> yes
10:50:16 <ania123> you like types :)
10:50:31 <ggVGc> EvanR: I just wanted a specific thing to work, and I haven't known how to. I'm still at "sequencing sequencers with sequencers"
10:50:34 <ania123> did you read what i posted above?>
10:50:36 <ggVGc> but I got something oging now1
10:50:38 <ggVGc> !
10:50:45 <EvanR> Fix Sequencing
10:50:50 <erisco> quangl, it is syntactically richer, statically typed, more generic than any .NET statically typed language
10:51:00 <srhb> GLM: & header "foo" [] & header "bar" [] & header .... ?
10:51:06 <ggVGc> EvanR: this works now, https://gist.github.com/7689f18644ee416108fd50fed64fe511
10:51:16 <srhb> GLM: Er, prepend defaults or whatever your options are.
10:51:20 <ggVGc> but I feel I've done it in a very roundabout way
10:51:38 <ggVGc> and I should probably have a state monad instance or something
10:51:43 <ggVGc> but I don't know anything about that
10:51:52 <GLM> srhb: I'm able to do it with a single argument but not with multiple
10:51:57 <ggVGc> so I'm explicitly passing around states and interfaces
10:51:58 <aesadde> Hi guys, I just have a quick question since I couldn't find anything online. Is the nofib suite still being developed or is it static/dead? 
10:52:03 <srhb> GLM: Oh, really. lpaste ?
10:52:12 <EvanR> ggVGc: whoa whoa whoa...
10:52:12 <srhb> GLM: Also I bet you didn't forget .~ like I just did :P
10:52:21 <ski> ania123 : yes. but i'm not quite sure i got the question
10:52:34 <EvanR> ggVGc: let _ = step singleRunner
10:52:39 <GLM> where mandatoryHeader = header "version" .~ ["1.0"] & ("dsa" .~ ["DW"])
10:52:43 <ggVGc> EvanR: that's just my test code
10:52:47 <ggVGc> to see that it compiles
10:52:51 <ski> ania123 : perhaps you were confusing the *inference* rules of a type system with whether we're doing type *inference* or type *checking* ?
10:52:52 <srhb> GLM: Needs more header
10:52:54 <EvanR> ok, so thats not doing anything
10:52:56 <ggVGc> yeah
10:53:04 <ggVGc> EvanR: those lines are just to make sure my types line up
10:53:09 <GLM> srhb: What does that mean?
10:53:10 <erisco> quangl, all code is written to be functional, and so you can use equational reasoning everywhere
10:53:16 <ski> (the use of the word "inference" is different, in those two cases)
10:53:21 <erisco> structural induction
10:53:22 <srhb> GLM: ... & (header "dsa" .~ ["DW"])
10:53:42 <srhb> GLM: Also I think it should be fine to drop those inner parens. :)
10:53:46 <ania123> 1) if subtype relation is undecidable, how can I infer types of certain expressions?
10:54:02 <ggVGc> EvanR: is this an indication of some generalisation I should be making? https://gist.github.com/126c17b9be0a889981a4fff8ed1a6ec0
10:54:19 <ggVGc> the runnerstate is holding both a state and an interface to interact with the state
10:54:40 <erisco> subtype relation is not undecidable
10:54:45 <ggVGc> I feel there's already a generalisation over this
10:54:59 <EvanR> ggVGc: well, you can hide this st more if you want
10:55:00 <erisco> there is not enough information in the conjecture
10:55:06 <EvanR> and no not really
10:55:09 <ggVGc> EvanR: what would I gain from it?
10:55:10 <erisco> what is the type system?
10:55:14 <ggVGc> hide it with a state monad instance?
10:55:17 <EvanR> no
10:55:19 <ania123> I mean, let assume i have a type system where for any function f: t->r and a: s , I can not infer wthere f a  is a well typed expression, since I do not have procedure to decide s<<t
10:55:32 <GLM> srhb: I had that before but it was giving me an error.
10:55:45 <quangl> so is it like prolog?
10:55:46 <erisco> why do you not have this procedure?
10:55:46 <EvanR> ggVGc: all your operations use a st, and 1 returns a new one
10:55:49 <srhb> GLM: Hmm, what error? I'll whip out the lens docs, I don't work with it often.
10:55:59 <EvanR> ggVGc: first, do you want to be able to access it at all from outside the object?
10:56:04 <ania123> if I construct a language and include the type system, does it matter I do type check statically or dynamically?
10:56:23 <ski> quangl : in some ways, yes, in some ways, no
10:56:30 <ggVGc> EvanR: I don't think so
10:56:31 <erisco> you cannot conclude it is undecidable until you know what the type system is
10:56:35 <ania123> erisco: because there is no algorthm which decides it
10:56:36 <EvanR> then you can simpify this interface
10:56:38 <EvanR> ill lpaste
10:56:42 <ggVGc> thanks!
10:56:44 <GLM> srhb: I think the parens might matter. It was breaking when on the same line but when I split them into where statements, it works
10:56:50 <EvanR> (if you did want to access it, its not that bad either, ill show you)
10:56:52 <erisco> how do you know there is no algorithm?
10:57:21 <srhb> GLM: Oh ok. :)
10:57:22 <ania123> i have an parrticualr type ssytem, as i told you, types constructed over variables, symbols and regular operators
10:57:39 <erisco> what is a "regular operator"?
10:57:52 <ania123> t::= x|a|t.t|t+t|t*
10:58:10 <ania123> there is not algorthm tod ecide
10:58:11 <erisco> what are these? regular language?
10:58:13 <ania123> t1<<t2
10:58:31 <ania123> these are regular expressions
10:58:34 <erisco> for regular language you can decide if one language is a subset of another
10:58:37 <ania123> they generate regualr langauges
10:58:59 <quangl> oh wow
10:59:02 <ania123> yes, you decide, but as you see this languages contain variables
10:59:04 <quangl> that sounds cool
10:59:06 <ania123> for it 
10:59:17 <ania123> you can not decide in general
10:59:34 <quangl> because prolog seems cool but its not really good for making things 
10:59:44 <srhb> GLM: I can't reproduce that. `defaults & header "foo" .~ ["foo"] & header "bar" .~ ["bar"]` WFM
10:59:47 <quangl> mayb for an expert system controller
10:59:52 <EvanR> ggVGc: http://lpaste.net/252165
10:59:59 <ania123> we say t1<<t2 if there is a substitition sigma such that l(t1 sigma) \subseteq l(t2 sigma)
11:00:04 <quangl> so can haskell be asked questions in logic?
11:00:08 <quangl> deduction?
11:00:21 <GLM> srhb: I was using & to combine the headers and then passing that to the main opts & header. Would that do the same thing?
11:00:22 <erisco> ania123, is there proof of that?
11:00:36 <ania123> proof of whar?
11:00:54 <erisco> that it is undecidable with variables
11:01:00 <srhb> GLM: (&) is just reverse function application, so that sounds like your issue :)
11:01:06 <ania123> there are many works about it
11:01:07 <Malkrith> I am not sure I understand still
11:01:10 <ania123> with many restrictions
11:01:14 <Malkrith> But I will give it time 
11:01:22 <srhb> GLM: Er, flipped I should say. It doesn't unapply. ;-)
11:01:31 <GLM> srhb: Is there a non-reverse form of that? I was hoping to make a megaHeader and then pass in a single argument
11:01:40 <srhb> GLM: Yes, ($)
11:01:58 <delYsid> Yesterday, I had a strange insight into monadic computations.  Monads are <drumroll, phew, I know> a way to hide function arguments.
11:01:58 <GLM> Thanks
11:02:09 <EvanR> ggVGc: does that make sense
11:02:18 <srhb> GLM: I don't think that's what you want though.
11:02:26 <lispy> delYsid: they can be used that way
11:02:40 <erisco> ania123, can you defer checking? i.e. defer until no variables
11:02:58 <ania123> erisco?
11:03:09 <ania123> did not get question
11:03:18 <lispy> delYsid: but I wouldn't equate monads with hiding function arguments.
11:03:23 <erisco> okay well lets make sure the problem is clear
11:03:37 <srhb> GLM: but notice that each bit of (header _ .~ _) :: Options -> Options
11:03:40 <erisco> I will use 't' to mean the token t
11:03:43 <srhb> GLM: So you can compose them with (.) :)
11:04:00 <ania123> ok
11:04:24 <delYsid> lispy: I know it is not quite fitting... I realized this when comparing pure and monadic functions without arguments.  The former is really a constant, but the latter carries a computation.
11:04:30 <GLM> srhb: That's exactly what I needed. Thanks for the help.
11:04:41 <srhb> GLM: You're welcome. 
11:04:52 <EvanR> ggVGc: the idea is that SeqObj is an OOP interface, different things with different kinds of state can implement it and be accepted to the same place
11:05:16 <mnoonan> delYsid: how does Maybe fit that mold?
11:05:25 <srhb> GLM: (Now you might even consider sticking them in a list and folding that with composition...)
11:05:27 <erisco> I can see why  't'*x ⊆ 't'+x   or some such problem is more complicated, but is there proof that such problems are undecidable?
11:05:57 <GLM> srhb: Hopefully I won't have that many headers but I'll think about it
11:06:00 <erisco> that is the first order of business
11:06:10 <srhb> GLM: :)
11:06:12 <EvanR> erisco: time to get the more precise problem description
11:06:21 <ania123> http://www.math.muni.cz/~kunc/math/slides.pdf
11:06:33 <delYsid> mnoonan: It doesn't :-)
11:06:39 <mnoonan> fair enough :)
11:06:45 <erisco> do you have a slide number ania123?
11:06:46 <shapr> delYsid: that's certainly one thing they can do, a monad can be plumbing to carry something around with you.
11:07:51 <shapr> Could be readable state, writable accumulation
11:08:15 <delYsid> mnoonan: I guess my next question would be: Is there a conceptual thing that distinguishes simple monads like Maybe, from those that somehow take an input when "run"?
11:08:52 <ania123> actually I do not know whetehr it is udnecidable, but I am confident until now ther eis not alg which takes two regular langage and decides whetehr there is a inclusion
11:08:57 <EvanR> delYsid: no
11:09:27 <ania123> i mean, ther eis not alg which takes t1 and t2 and decide l(t1) \subseteq l(t2)
11:09:34 <EvanR> the idea that there is leads to a lot of misunderstanding of monads
11:09:34 <ggVGc> EvanR: yeah, thanks
11:09:40 <erisco> ania123, free of variables there is such an algorithm. I do not know what the result is with variables
11:09:40 <ania123> I did not find any research related to it
11:09:43 <ggVGc> EvanR: but, it feels wrong to do this kind of OOP thing in haskell
11:09:52 <ggVGc> but I don't know another way
11:09:55 <EvanR> this kind of OOP is best kind of OOP
11:10:01 <ski> delYsid : in some sense, `maybe :: o -> (a -> o) -> Maybe a -> o' is a "run" function for `Maybe'
11:10:06 <erisco> ania123, but lets say it is undecidable with variables, though we do not know
11:10:07 <shapr> FOP? Function Oriented Programming?
11:10:14 <EvanR> ggVGc: you were already doing it, i just simplified the interface there
11:10:18 <EvanR> and made it more general
11:10:24 <ania123> erisco: for sure, it is prety use to check whether one automata is included to another
11:10:37 <erisco> ania123, we do know it is decidable when free of variables, so what we can do is defer type checking until all variables are removed
11:10:38 <ania123> it is very easy to simullate and chekc it
11:10:46 <ggVGc> EvanR: yeah, I know, but the reason it took me a long time to get to this, was becuase I was trying to find another way to do it, but gave up
11:11:10 <EvanR> head bashing is good
11:11:16 <ania123> erisco: how can we be sure, that all variables will be removed?
11:11:20 <erisco> this is a more… surprising type system but static nonetheless
11:11:36 <erisco> well that is trivial, you just look at the type expression and see that there are no variables
11:11:45 <mnoonan> ania123: am I misunderstanding what you are saying? If X and Y are regular languages, X - Y is just X \cap Y^c, and you can compute \cap and ^c.
11:12:12 <EvanR> ggVGc: do you get how to generate these objects and hide the st ?
11:12:35 <EvanR> i updated it with more options http://lpaste.net/252165
11:12:47 <delYsid> ski: Yes, but maybe doesn't take any additional input for "running" the Monad, like runState or runReader do.
11:12:55 <ania123> erisco: how can we make sure taht variables always vanish ?
11:13:36 <ania123> for example if we have f : t1->t2  and a : r , how can I decide f a  is well typed or not?
11:13:47 <erisco> you don't "do" stuff with variable types, they are concrete
11:14:12 <erisco> main :: IO ()   putStrLn :: String -> IO ()  and so on
11:14:16 <ania123> yes, but we have polimorfism in general and hence variable types
11:14:24 <EvanR> ania123: check if r is a subtype of t1
11:14:27 <erisco> you are missing the point
11:14:37 <ania123> EvanR: how?
11:14:39 <erisco> say I have a function such as  \f x -> f x
11:14:45 <EvanR> with your type system's algorithm, they exist
11:14:47 <ski> delYsid : what do you mean, `maybe' above takes two additional arguments ?
11:15:01 <ania123> and?
11:15:09 <erisco> this has type  (a -> b) -> a -> b
11:15:20 <ania123> what is a and b?
11:15:23 <erisco> we don't check this until 'a' and 'b' have been applied
11:15:30 <erisco> they are variables
11:15:40 <EvanR> rather than saying subtyping is undecidable, at least explain how your version of subtying differs from industry standard stuff, which exists
11:15:47 <erisco> so we might check (String -> Int) -> String -> Int works
11:16:07 <ania123> wait please
11:16:12 <ania123> what is a type of f?
11:16:15 <ania123> of x?
11:16:21 <erisco> so similarly, you may have  't'*x ⊆ 't'+x   but this is unchecked
11:16:28 <erisco> it is checked once x is applied
11:16:33 <erisco> see also C++ templates
11:16:58 <erisco> are you familiar with Haskell ania123?
11:17:05 <ania123> little
11:17:53 <erisco> the type of f is a -> b and the type of x is a
11:18:08 <EvanR> see my latest article on subtypes and quotient types: https://goo.gl/oy8Zjc ;)
11:18:13 <erisco> we can infer this variable form from the expression
11:18:35 <erisco> now, I do not know what your inference rules are for these regular languages, but it would be similar
11:19:04 <erisco> there are variable forms which you can infer, but you may be unable to check the variable constraints
11:19:21 <erisco> yet you can check them once the variables are applied, and so you defer until then
11:19:22 <ania123> \f x -> f x
11:19:38 <erisco> this will be an effect like C++ templates where you can declare whatever nonsense you want
11:19:39 <ania123> what is type of f here?
11:19:45 <erisco> it only causes problems when you try and instantiate them
11:19:49 <erisco> also known as error novels :P
11:20:08 <erisco> the type of f is a -> b
11:20:19 <ania123> type of x?
11:20:23 <erisco> a
11:20:30 <ania123> type of \f x -> f x?
11:20:38 <erisco> (a -> b) -> a -> b
11:20:40 <EvanR> :t \f x -> f x
11:20:45 <lambdabot> (t -> t1) -> t -> t1
11:20:46 <ania123> strnge
11:21:06 <ania123> i expectded : b->b
11:21:19 <EvanR> it takes two 
11:21:24 <erisco> are you familiar with lambda calculus?
11:21:29 <ania123> ah
11:21:35 <ania123> sorry
11:21:37 <ania123> i confused
11:21:38 <Tuplanolla> You should look into how types are inferred in DHM, ania123. It's very simple up to unification.
11:21:40 <ania123> you are right
11:21:43 <ania123> sorry
11:22:04 <ania123> erisco
11:22:12 <Malkrith> Is there some article that will give me a basic run down of the type description system?
11:22:12 <ania123> how did u infdered
11:22:14 <ania123> b?
11:22:21 <ania123>  (a -> b) -> a -> b
11:22:23 <ania123> last b 
11:22:25 <ania123> here
11:22:29 <erisco> f x :: b
11:22:31 <EvanR> Malkrith: like, all ways to define types in haskell?
11:22:33 <ania123> how?
11:22:41 <ania123> u have type inference
11:22:42 <ania123> which says
11:22:50 <ania123> f: a--> b and x : a
11:22:52 <erisco> because   f :: a -> b, x :: a ---> f x :: b   i.e. modus ponens
11:22:52 <ania123> then
11:22:55 <ania123> f x : b
11:22:57 <ania123> how?
11:23:04 <erisco> that is just how it works, that is the law of the land
11:23:11 <ania123> right
11:23:13 <ania123> but
11:23:19 <ania123> if i have a similar rule
11:23:24 <Malkrith> I don't understand why add :: Integer -> Integer -> Integer is the way it is 
11:23:27 <EvanR> use less enter key
11:23:44 <ania123>  f: t1->t2  and  a : r  and r<t2
11:23:45 <ania123> then
11:23:51 <ania123> f a : t2
11:23:54 <EvanR> Malkrith: so you want an explanation of type signatures?
11:24:00 <Malkrith> Yes
11:24:04 <Malkrith> More or less 
11:24:10 <EvanR> to understand that one, use more parentheses
11:24:11 <ania123> my problem is to decide r<<t2
11:24:16 <EvanR> add : Integer -> (Integer -> Integer)
11:24:18 <ania123> err
11:24:19 <erisco> ania123, did you mean if r<<t1 ?
11:24:20 <ania123> t1
11:24:23 <EvanR> its a function that returns a function
11:24:24 <Malkrith> I am coming from a very C like language 
11:24:25 <ania123> right
11:24:29 <Malkrith> So I am... Struggling 
11:24:39 <Malkrith> But slowly getting bits and pieces 
11:24:47 <EvanR> thats equivalent to add :: (Integer, Integer) -> Integer, which takes a tuple
11:25:00 <EvanR> but the other version, the curried version, is more convenient
11:25:12 <ania123> so, i can not construct expressions form existinge xpressions
11:25:18 <ania123> since I can not calculate types
11:25:48 <Hanslo> Hello all, is anyone here familiar with Snap framework?
11:26:38 <erisco> ania123, right, well your rule is different, presumably. I am guessing it looks something like  f : G ⊢ t1 → t2,  a : H ⊢ r  --->  f a : G, H, r ⊆ t1 ⊢ t2   where the turnstile separates constraints from types
11:26:43 <dmj`> Hanslo: yes
11:27:15 <JuanDaugherty> Hanslo there's a snap channel, #snapframework I think
11:27:32 <erisco> also account for variable hygiene
11:28:06 <erisco> if  r ⊆ t1  is undecidable in the variable form then you can defer until the variables are applied … this means problems are encountered later rather than earlier
11:28:16 <ania123> what is that? type constraints?
11:28:36 <EvanR> erisco: i dont understand what you mean by later, what is "non variable form"
11:28:36 <erisco> but if you are not sure if it is undecidable then maybe you should focus there first
11:28:57 <Hanslo> dmj': Thanks, Im getting an error while building my project (after running $cabal install). I'm getting an error saying that 'mempty' is not in scope. I tried ghci's suggestions to fix the error and they didnt seem to work. Could I be missing a package possibly? 
11:29:18 <erisco> EvanR, free of variables, eventually they will be instantiated so that you can do something with them, such as print a value or something
11:29:30 <Hanslo> This error is coming from the Site.hs
11:29:34 <EvanR> erisco: they will be?
11:29:49 <erisco> EvanR, it is a less appealing type system, like C++ templates as I said, but it is a solution if the variable forms are undecidable but the constant forms are
11:30:01 <dmj`> Hanslo: what version of base are you on? Try importing Data.Monoid
11:30:04 <EvanR> if you check the definition of the list map function, its still going to have variables, the generalize step adds a forall there
11:30:15 <ania123> erisco: will be back in 5 min
11:30:24 <erisco> :t map
11:30:27 <lambdabot> (a -> b) -> [a] -> [b]
11:30:27 <EvanR> it doesnt make sense to me that you cant type check something in isolation
11:30:37 <erisco> what variable is left over?
11:30:48 <EvanR> its forall a b . (a -> b) -> [a] -> [b]
11:30:58 <Hanslo> dmj': version 7.6.3
11:30:59 <erisco> yes, and? what variable is left over?
11:31:08 <EvanR> what?
11:31:19 <ryantrinkle> if i have {-# RULES "f/g" forall x. f (g x) = f x #-} and the core looks like let a = g x in case f a of ...
11:31:42 <ryantrinkle> er, actually, there's a lambda around the case
11:31:59 <ryantrinkle> let a = g x in (\z -> case f a of ...)
11:32:09 <erisco> I am saying that the variable forms are not checkable
11:32:12 <EvanR> :t map id
11:32:13 <lambdabot> [b] -> [b]
11:32:14 <ryantrinkle> is there a fundamental reason that rule can't/won't fire, or can it just not happen to find it?
11:32:16 <EvanR> checked
11:32:38 <erisco> I don't know what you're trying to say
11:32:40 <EvanR> variable forms being checkable is the whole point
11:32:44 <erisco> neither of us are talking about Haskell's type system
11:32:53 <EvanR> what are you guys talking about then?
11:33:11 <Hanslo> dmj': that worked. Thanks 
11:33:19 <erisco> some type system involving regular languages with variables and constraints on these variables
11:33:28 <dmj`> Hanslo: cool
11:33:35 <EvanR> is that system documented somewhere?
11:33:53 <erisco> I do not know
11:34:09 <erisco> and I am not sure how you type data with regular languages, but maybe that is not the objective
11:34:11 <dmj`> Hanslo: btw, 7.6.3 is a tad dated. I'd recommend 7.10 / 8.0
11:34:14 <mnoonan> erisco, ania123: you might be interested in this paper of mine: https://arxiv.org/abs/1603.05495
11:34:30 <dmj`> Hanslo: if you use stack it should handle all that for you
11:34:38 <dmj`> it will download ghc, etc.
11:34:55 <mnoonan> its on inferring types for machine code, but it uses a fairly flexible subtype constraint system
11:35:38 <EvanR> mnoonan: that looks pretty awesome
11:36:17 <erisco> mnoonan, thanks
11:36:35 <mnoonan> EvanR: thanks!  I think the idea behind the type system could be useful in high-level languages too, but I work in binary analysis, so.. :)
11:36:59 <erisco> binary analysis… either its right or its wrong
11:37:30 <mnoonan> erisco: well that's easy, it's always buggy and wrong
11:38:23 <erisco> field closed
11:38:24 * hackagebot parsec-free 3.1.11.3 - Parsec API encoded as a deeply-embedded DSL, for debugging and analysis  https://hackage.haskell.org/package/parsec-free-3.1.11.3 (JohnWiegley)
11:38:26 * hackagebot hsinstall 1.4 - Install Haskell software  https://hackage.haskell.org/package/hsinstall-1.4 (DinoMorelli)
11:40:32 <erisco> the relation x : T becomes "if x has a type, it has the form T" in the deferred checking
11:41:14 <erisco> meaning that if x : T, it could be that T has no inhabitants
11:48:12 <ggVGc> EvanR: yeah, thanks :) I got distracted by real world communications
11:48:24 <EvanR> never heard of em
11:48:39 <ggVGc> EvanR: actually, I already had in mind that I should  do what you just showed me
11:48:42 <ania123> erisco: still here? 
11:48:47 <ph88> hi guys, in my program i get an exception and i can't figure out why. When i do a trace  https://paste.fedoraproject.org/447872/25251147/  and get the input value and then run it through the funtion myself it works without a problem .. what am i missing here ?
11:48:58 <ggVGc> EvanR: I've just had this feeling the whole time that I'm going about this the wrong way, but I guess not
11:49:56 <EvanR> ggVGc: well this is OOP and it can work, its pretty verbose even in haskell, the implementation definitions
11:50:17 <EvanR> how to structure a big interactive app is still up in the air, FRP ?
11:50:31 <EvanR> lets just rename FPR to FPR? ;)
11:50:52 <ph88> what are you making ggVGc ?
11:52:23 <ania123> erisco: it is not clear for me, without type inference alg, how we can assign types
11:52:54 <erisco> ania123, type inference and type checking are different things
11:53:09 <ania123> i need to infer type
11:53:16 <ania123> of an expression
11:53:23 <ania123> is not it type inference?
11:53:36 <erisco> ania123, but even so, I gave you a possible rule for assigning a type to application
11:53:50 <ania123> could you please paste it again
11:54:29 <erisco> f : G ⊢ t1 → t2,  a : H ⊢ r  --->  f a : G, H, r ⊆ t1 ⊢ t2   where the turnstile separates constraints from types
11:55:07 <erisco> you have to account for variable hygiene as well
11:55:39 <ania123> r\subseteq t1
11:55:43 <ania123> is constraint there
11:55:56 <ania123> which we do not know whether holds
11:55:58 <ania123> ok?
11:56:04 <erisco> as well as whatever is in G and H
11:56:20 <erisco> well, you don't know if it undecidable
11:56:28 <erisco> but assuming it is, then you can defer the checking like I suggested
11:56:49 <ania123> how did u suggested
11:56:55 <ania123> sorry I coonfused again
11:57:03 <erisco> you do not check variable forms, you only check constant forms
11:57:10 <ania123> if we reach it
11:57:24 <ania123> but, it can happen also, we will never reach variable free forms
11:57:26 <ania123> then?
11:57:38 <erisco> then you're asking the impossible
11:58:02 <erisco> but if you're doing IO then you're likely not left with variables
11:58:14 <erisco> you print String and Int and so forth, not Maybe a's
11:58:47 <ania123> ok
11:58:49 <ania123> thx
11:59:25 <EvanR> erisco: when you make a library, you probably want to type check it before someone tries to download it and use it
11:59:26 <erisco> you could also devise a system where the programmer can provide a proof
11:59:40 <erisco> yes, yes you probably do EvanR, there are problems with it
11:59:53 <EvanR> like, if its ill typed used one way, but well type used another way
11:59:57 <EvanR> does that make any sense
12:00:00 <erisco> it becomes more like a macro system
12:00:22 <erisco> it makes as much sense as C++ templates, it behaves similarly
12:00:53 <EvanR> still not sure what ania123 is getting at, so not sure if its equivalent to C+ or not
12:01:22 <erisco> well the thought is that the type checking is undecidable, though we do not know certainly
12:01:37 <EvanR> whether its undecidable is undecidable apparently
12:01:45 <erisco> maybe devise a different type system if that is so
12:02:44 <EvanR> F# has subtyping and inference
12:02:53 <erisco> but types are not regular languages
12:03:10 * EvanR lost there
12:03:33 <erisco> that is what a type is in this system, a regular language with constrained variables
12:04:15 <erisco> I do not know how you make use of these types … it is strange to me how you would give usual data such a type
12:04:45 <erisco> I did something similar but the grammar was for trees, not sentences
12:06:31 <ania123> a : H ⊢ r
12:06:42 <ania123> what ":" denotes here?
12:06:58 <mnoonan> "has type"
12:07:11 <erisco> "has type", or if we're talking in the deferred system then I described it as "if it has a type, it has this form"
12:07:26 <ania123> G and H are contexts
12:07:29 <ania123> is not?
12:07:42 <erisco> they are bunches of constraints
12:07:55 <ania123> ok
12:08:14 <ania123> context plus constraint
12:08:18 <EvanR> i usually see a:H in some context G |- something
12:08:25 <ania123> variable type declarations are also there
12:08:27 <ania123> is not?
12:08:54 <erisco> I used the turnstile to separate the type from the constraints, somewhat like => in Haskell … it is not meant to be the same thing as in sequent calculus or other systems
12:09:02 <EvanR> if something is just `r' thats a little vague
12:09:22 <ania123> ok
12:11:41 <ggVGc> ph88: a midi sequencer environment, kind of. I already have a working program that I use to make some music, but I am now revisiting it to implement my original idea that I gave up early on because of wanting something concrete first. Basically I want to generalise "sequencing" so that everything can be build out of sequencers seqeuencing eachother in different ways
12:11:59 <ggVGc> but a major part of it is also making a usable UI for it all, that runs on midi controllers rather than computer screens
12:12:05 <ggVGc> that part I've already done a lot of
12:12:10 <ggVGc> but the implementation is very non-generic atm
12:12:26 <ggVGc> so trying to go back and generalise everything so I can implement some more advanced features
12:14:25 <NickHu> How is the ghc backpack different/more desirable than typeclasses?
12:15:08 <pikajude> i'm reasonably sure it's supposed to make dependency resolution easier
12:16:41 <pikajude> specifically, I think it's supposed to mitigate cabal hell
12:16:50 <ania123> erisco: one more question... does it simplifies things wrt subtype decision  if I use static or dynamic types?
12:17:02 <pikajude> i've heard a lot of positives about the ocaml module system, which backpack emulates, although I'm not sure what specifically they like about it
12:17:11 <hvr> pikajude: how can it make dep resolution easier?
12:17:26 <pikajude> hvr: i'm just repeating what i've vaguely heard in blog posts and /r/haskell posts
12:17:46 <dazednconfused> does anyone here try solving programming contest questions in haskell?
12:17:53 <pikajude> as I'm not a backpack expert, I should probably stop contributing :)
12:18:10 <dazednconfused> i'm just starting out with haskell and even performing simple tasks like reading in inout seem so hard
12:18:34 <pikajude> dazednconfused: haskell isn't a great scripting language out of the box
12:20:08 <EvanR> the pile of imports required to do stuff
12:20:26 <EvanR> you could make a single module which imports all of it
12:20:52 <ania123> erisco: one more question... does it simplifies things wrt subtype decision  if I use static or dynamic types?
12:21:10 <dazednconfused> https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=62
12:21:14 <srhb> dazednconfused: It's great, at least if you're allowed to use arbitrary libraries. :)
12:21:44 <srhb> dazednconfused: The ICFP contest usually have a few very neat Haskell solutions. :)
12:25:10 <Denommus> backpack seems cool
12:27:07 <erisco> ania123, the only significance I am aware of is that dynamically you can just test the particular case at hand, rather than statically trying to prove all of them
12:27:58 <ania123> aha
12:28:06 <pikajude> I'm trying to install ghc HEAD right now to try it out
12:29:04 <erisco> so you might have "this works for numbers less than 3", and you might try to prove this statically which could be difficult
12:29:15 <erisco> i.e. you're trying to prove that the only possible numbers given are less than 3
12:29:34 <erisco> dynamically on the other hand you can test if the particular given number is less than 3
12:29:54 <erisco> a static failure is the refusal to compile, whereas a dynamic failure is the crashing of the program
12:30:39 <EvanR> works for numbers less than 3, use Fin 3 ;)
12:30:55 <EvanR> to index array of size n, use Fin n
12:31:22 <EvanR> stuff like this in idris works surprisingly well
12:38:26 * hackagebot twitter-feed 0.2.0.10 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.10 (jpvillaisaza)
12:38:45 <JonReed> How can I check enforce that `Nat` is `Elem` of `[!`
12:39:04 <JonReed> How can I check enforce that `Nat` is `Elem` of `[5, 5]` with singletons library?*
12:39:49 <JonReed> For example I have: `type MySings = '[Sing 5 ]; testFunction :: ((Elem s MySings) ~ 'True, Sing n ~ s) => s -> (); testFunction _ = ();
12:40:31 <JonReed> This compiles, but does not work if I try to to use it like:   let t = testFunction (u :: Sing 5)
12:41:13 <JonReed> Are there any examples of using Singletons library?
12:42:21 <JonReed> My goal it so have a function that checks a type (like Nat or Symbol) is inside a type list and fails to compile if that is not the case. 
12:43:33 <ggVGc> EvanR: man that's real nice
12:43:41 <ggVGc> getting rid of the st type variable
12:43:51 <ggVGc> simplified a lot of the rest of the code
12:44:08 <JonReed> Almost everything I try for this case using singletons compiles by fails when it's used. E.g. using testFunction gives: Couldn't match type `(Sing 5 :== Sing 5) :|| 'False' with 'True;
12:44:33 <EvanR> ggVGc: yeah i imagined passing that around and in each time was hellish
12:44:40 <JonReed> And there is like no information about how to use it :O
12:52:31 <JonReed> I like how it says, "Expected type `Proxy 5` got `Proxy 5`": http://lpaste.net/252244
13:01:09 <johnw> if i have a GADT constructor such as PalphaNum   :: P.Stream s m Char => (Char -> r) -> ParsecF s u m r, is there any way during case analysis to "recover" that constraint?  I'm trying to do something like: case x of PalphaNum k -> PalphaNum k, but it fails because it doesn't infer the constraint holds in the new construction, even though it must holds if I haven't changed 's' or 'm', right?
13:01:31 <ggVGc> is there a better way to do this? https://gist.github.com/a6741260940a299d5a39315dabd43ace
13:02:29 <EvanR> is that Either a a ?
13:02:44 <EvanR> :t catLefts
13:02:46 <lambdabot> error: Variable not in scope: catLefts
13:03:03 <EvanR> :t lefts
13:03:05 <lambdabot> [Either a b] -> [a]
13:03:25 <lyxia> johnw: It should hold indeed.
13:03:32 <EvanR> and you could use bimap to fmap over it
13:03:33 <mnoonan> ggVGc: I think I'd write the predicates "isSeqOn" / "isSeqOff" and just use filter instead of those functions, personally
13:03:59 <ggVGc> mnoonan: yeah, but it's a combination of filter and extracting the held value
13:04:09 <ggVGc> making it Either would be fine I guess
13:04:14 <mnoonan> oh, sorry, I missed that
13:04:29 <EvanR> well your version is simpler really
13:04:47 <EvanR> you just have to implement the support yourself, DerivingFunctor at least exists
13:06:07 <erisco> fmap fromLeft . filter isLeft
13:07:10 <EvanR> @src lefts
13:07:10 <lambdabot> lefts x = [a | Left a <- x]
13:08:19 <johnw> lyxia: oh, wait, it's working.  I was misreading the location of the error.  My actual problem is completely legimitate: I'm applying a transformation of 'm', but the transforamtion doesn't not specify naturality wrt Stream
13:08:33 <johnw> s/not//
13:10:19 <johnw> so much for MFunctor, since I can't plumb through that "proof"
13:15:04 <ertes> :t D i n n e r
13:15:05 <lambdabot> P i z z a
13:15:35 <EvanR> im-pasta-ble
13:21:57 <dmj`> how do you do that conditional import based on package version using cpp again
13:21:58 <erisco> :t L u n c h
13:21:59 <lambdabot> error:
13:22:00 <lambdabot>     Data constructor not in scope: L :: Expr -> Expr -> Expr -> t0 -> t
13:22:01 <dmj`> min_version, etc
13:22:54 <erisco> doesn't sound too tasty
13:25:39 <dmj`> ah, #if !(MIN_VERSION_exceptions(0,4,0))
13:27:01 <o`connor> does stack use its own gcc?
13:27:26 <o`connor> I'm getting : Linking .stack-work/dist/x86_64-linux/Cabal-1.24.0.0/build/dk/dk ...
13:27:29 <o`connor> /usr/bin/ld: cannot find -lgmp
13:28:13 <o`connor> but gcc works fine outside stack
13:29:00 <hvr> o`connor: the problem is that stack uses its own ghc
13:29:25 <o`connor> hvr: if stack uses its own toolchain, why is it broken? Is this a bug in stack?
13:29:55 <hvr> o`connor: that's the problem: it only comes with half the toolchain
13:30:08 <ggVGc> wow, I think I abstracted at the wrong level
13:30:11 <ggVGc> :((((
13:30:24 <ggVGc> oh well
13:30:26 <hvr> o`connor: ghc is managed by stack, while gcc isn't
13:30:32 <ggVGc> maybe I just needed two abstraction levels
13:30:47 <hvr> o`connor: hence you may not get all C headers & libs you need
13:31:55 <o`connor> hmm, ok
13:31:56 <hvr> o`connor: whereas with ghc as as a system package it pulls in the core dependencies it needs to operate
13:31:57 <mnoonan> o`connor: you probably just need to install gnu mp globally
13:32:37 <hvr> o`connor: I wouldn't call it a "bug" in stack, as more a design issue
13:33:17 * hvr goes back packaging ghc
13:33:35 <o`connor> mnoonan: so, I had gmp installed in ~/.nix-profile/lib/, but it didn't find it
13:33:42 <o`connor> apt-get worked
13:38:27 * hackagebot calculator 0.4.1.2 - A calculator repl, with variables, functions & Mathematica like dynamic plots.  https://hackage.haskell.org/package/calculator-0.4.1.2 (sumitsahrawat)
13:48:45 <haskell315> hey guys, I have a newbie question: since function application is right-associative in haskell, why does "map (+3) [1,2,3]" work (shouldnt that be the same as "map ((+3) [1,2,3])"?) but it doesn't if I add a sum in front?
13:49:08 <hpc> other way
13:49:24 <hpc> map (+3) [1,2,3] is (map (+3)) [1,2,3]
13:49:44 <hpc> and sum map (+3) [1,2,3] has sum applied to map first, then (+3), then [1,2,3]
13:50:01 <haskell315> oh, duh, well then it makes much more sense, thanks :)
13:50:01 <hpc> ((sum map) (+3)) [1,2,3]
13:50:23 <KasparP> Hi, can anyone help me out with the following: http://pastebin.com/BT1av0X4
13:52:01 <KasparP> have been struggling with this for hours
13:55:11 <jchia_1> question about Data.Vector.Algorithms.Search: Based on what they return, it seems that all the functions in this module are read-only. For example, I think binarySearch et al can be implemented in a read-only manner. So, why do they take MVector (mutable) instead of regular Vector? When I write code to use these binarySearch to search a regular vector or a sorted list (which will need to be converted to a vector), I suppose I need to use the ST monad or som
13:55:45 <lyxia> KasparP: what language is this
13:56:12 <KasparP> lyxia, haskell
13:57:41 <adnelson> hi guys, does anyone know of a library which provides attoparsec (or parsec) parsers for an email address? such that I can compose them with other parsers?
13:57:53 <lyxia> KasparP: in haskell pealkiri means title?
13:58:01 <johnw> so you mean, a full RFC-822 e-mail address parser?
13:58:06 <KasparP> Oh, the language is Estonian :) 
13:58:20 <adnelson> johnw: sure, although it doesn't have to be airtight, but if it could be then yeah
13:58:34 <adnelson> I was just hoping I wouldn't have to roll my own
13:58:48 <lyxia> KasparP: I don't understand what the assignment is asking.
13:58:54 <johnw> adnelson: http://hackage.haskell.org/package/hsemail-1.7.2/docs/Text-ParserCombinators-Parsec-Rfc2822.html#g:11
13:59:50 <adnelson> johnw: sweet, thanks! I'll need to figure out what this CharParser thing is... but that's a great starting point
14:01:01 <KasparP> lyxia, basically "raamatSeeriaAutorid theReturnOfTheKing" is  entered, then the function should return all of the author's name's that have contributed to the book series in one string.
14:01:10 <KasparP> in this case there is only one author
14:02:52 <lyxia> but you have just three books in your library
14:03:17 <KasparP> Yes, it's just an an example
14:03:23 <lyxia> I mean, this one example is not really helpful.
14:04:59 <lyxia> oh Ramaat is recursive... I see.
14:06:03 <KasparP> right :)
14:06:43 <lyxia> you just need to get all the authors seeria. Since seeria is a list of books, you can first write a function that gets you the author(s) of one book, and then map it over seeria.
14:08:02 <koz_> Could someone help me parallelize this better? http://lpaste.net/252359
14:09:28 <KasparP> lyxia, thanks! Will try.
14:15:26 <dcoutts> pikajude, NickHu: no, backpack doesn't really have that much to do with dependency resolution
14:15:35 <pikajude> that's what i was afraid of
14:17:07 <dcoutts> it's a module system extension with similar goals to ML modules, but done at the package level (and with somewhat different semantics to ML modules)
14:18:39 <dcoutts> it allows packages to abstract over some of their module imports from other packages (using module signatures)
14:19:09 <dcoutts> and then instantiate multiple different ways
14:21:00 <utdemir> Please help me. It's been half an hour and I still couldn't find a simple `set :: Position -> Value -> Matrix -> Matrix` function in repa or hmatrix.
14:23:15 <utdemir> I just want to write a simple flood-fill algorithm. There should be a safer way instead of `Vector (Vector Int)`.
14:24:09 <Tuplanolla> If you're using Repa, you want to `traverse` instead of mutating individual cells within `ST`, utdemir.
14:25:10 <koz_> Tuplanolla: Do you know much about parallel? I need some help with it.
14:25:41 <Tuplanolla> No, koz_.
14:25:59 <utdemir> Tuplanolla: I can't model the algorithm on my head that way. What do you suggest for mutating individual cells? 
14:26:12 <koz_> Tuplanolla: :(
14:27:16 <miniBill> I'm trying to use Applicative do in ghc 8.0.1, but it still asks for a monad instance. The code is (x <- p; xs <- q; pure $ x : xs) 
14:27:41 <koz_> miniBill: If you use do-notation, it translates to Monad.
14:27:44 <koz_> (I think)
14:27:51 <koz_> You need ApplicativeDo for that.
14:28:08 <lyxia> miniBill: can you paste the whole code and error
14:28:19 <koz_> Alternatively, write it as (:) <$> p <*> q
14:28:21 <Tuplanolla> If you're working with `Thing`, look for functions that have a type like `Thing a -> (forall s. ST s (MThing s a)) -> Thing a`, utdemir.
14:29:17 <Tuplanolla> For example `Vector` has `freeze`, `thaw` and `create`.
14:31:20 <utdemir> Tuplanolla: Thanks. I think I'll cast Repa array to Vector back and forth. 
14:31:39 <miniBill> koz_: I'm using ApplicativeDo
14:31:44 <miniBill> koz_: yeah, that's a possible desugaring
14:31:53 <miniBill> lyxia: let me paste it somewhere
14:35:11 <jle`> miniBill: i'm getting an Applicative constraint for my 8.0.1 ghci
14:35:48 <miniBill> jle`: http://rextester.com/PUOQ21991
14:35:51 <miniBill> lyxia: http://rextester.com/PUOQ21991
14:36:32 <jle`> hm
14:36:44 <jle`> oh
14:37:00 <jle`> if i do pure $ x:xs, i get Monad, but if i do pure (x:xs), i don't
14:37:10 <miniBill> lol
14:37:15 <jle`> i think it might be because ApplicativeDo isn't very smart
14:37:21 <jle`> it looks for `pure _` pattern at the end probably
14:37:31 <jle`> but instead you provided ($) pure (x:xs)
14:37:35 <lyxia> time for a bug report
14:37:37 <miniBill> I get monad with the online paste
14:37:45 <miniBill> lyxia: yay! =(
14:37:55 <miniBill> lyxia: I do or you do?
14:37:56 <jle`> and the $ doesn't inline until *after* the ApplicativeDo analysis
14:38:05 <miniBill> jle`: ooooh... ouch
14:38:12 <jle`> maybe we would just need to get ($) to inline before the ApplicativeDo transformation
14:38:20 <jle`> miniBill: in general, it wouldn't touch `f pure x`
14:38:23 <jle`> only `pure x`
14:38:32 <miniBill> jle`: http://rextester.com/TOCL75177
14:38:40 <lyxia> What one more exception for ($).
14:38:53 <jle`> oh, hm
14:38:57 <miniBill> lyxia: http://rextester.com/TOCL75177
14:39:00 <miniBill> it's not ($)
14:39:39 <jle`> miniBill: maybe try giving test an explicit type signature?
14:40:02 <miniBill> jle`: nah
14:40:02 <jle`> still kinda weird
14:40:13 <miniBill> indeed
14:40:21 <miniBill> it's a textbook example of applicativedo
14:40:30 <jle`> indeed
14:40:32 <hexagoxel> afaik these issues with ApplicativeDo are known to the maintainers.
14:41:07 <miniBill> hexagoxel: do you know how can I contact them so I can know if I need to report?
14:41:20 <miniBill> anyway, in the meantime I'll probably (:) <$> p <*> q
14:41:34 <lyxia> miniBill: it compiles here...
14:41:37 <hexagoxel> it only sees an App of pure and _ as ApplicativeDo. and ($) is an InfixOp. The issues rather is that ($) is _not_ special-cased..
14:42:04 <miniBill> lyxia: it doesn't here... anyway, I'll <$>
14:42:20 <miniBill> hexagoxel: it doesn't work, event without $
14:42:24 <lyxia> liftA2!
14:43:16 <miniBill> lyxia: yeah, better, thanks
14:43:18 <jle`> miniBill: might it be an issue with the online compiler?  does it work as a source file?
14:43:26 <rhart> Trying to work on a problem for my functional programming class. The problem is here https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=62 .Can anyone give an suggestions/hints for how to go about just solving it with brute force? My initial idea was just a list comprehension of all the different permutations each triangle could be but that doesn't work since it doesn't check all triangle orderings
14:44:06 <miniBill> jle`: my problem is with a source file [and the equivalent of "test" do have a type annotation]
14:45:21 <jle`> try test :: Applicative f => f a -> f [a] -> f [a]; test p q = x <- p; xs <- ps; pure (x:xs) ? it seems to work on ghci for me
14:47:46 <miniBill> jle`: can you provide a copypastable fragment?
14:48:10 <jle`> i'm doing :t \p q -> x <- p; xs <- p; pure (x:xs)
14:48:29 <jle`>   :: Applicative f => f a -> f [a] -> f [a]
14:48:45 <jle`> er, there is supposed to be a do there
14:48:52 <dibblego> I think you want a s/p/q in there as well
14:49:42 <jle`> indeed
14:50:18 <miniBill> jle`: I get monad
14:50:24 <miniBill> GHCi, version 8.0.1:
14:50:27 <jle`> eve with :set -XApplicativeDo ?
14:50:37 <miniBill> whops
14:50:47 <miniBill> applicative in ghci
14:51:34 <miniBill> anyway, gnight
14:51:39 <miniBill> thank you very much
14:51:42 <jle`> night!
14:51:46 <jle`> hope this gets resolved :)
14:52:01 <lyxia> miniBill: it's been fixed in HEAD alreadt
14:52:15 <lyxia> https://ghc.haskell.org/trac/ghc/ticket/11835
15:00:27 <jle`> lyxia: the problem still happens when they do pure (x:xs)
15:03:02 <lyxia> oh. uh...
15:05:20 <lyxia> rhart: perhaps you can use permutations :: [a] -> [[a]]
15:12:35 <delYsid> Fascinating talk https://www.youtube.com/watch?v=3U3lV5VPmOU  I wish I could see the slides
15:17:49 <koz_> Could someone help me understand why I'm having parallelism issues? I'm getting initially high activity, then it 'slumps' very quickly.
15:20:34 <rhart> lyxia: i was trying to do it with permutation and permuting the list i have representing each triangle but i couldnt get the ckmbknations working in a way i wanted. the issue is i couldnt get it to try all the orderings of triangles  any thoughts on how to fix this?
15:20:44 <koz_> Also, could someone tell me about NFData? I'm trying to use 'parMap rdeepseq', but then I get an error message that m (Int, Int) lacks an NFData instance, where m is an instance of MonadRandom.
15:21:53 <lyxia> rhart: I don't understand what you mean, permutations gives you all orderings of elements of a list.
15:24:17 <lyxia> koz_: NFData is a typeclass for datatypes you can fully evaluate, basically just made of constructors.
15:24:32 <koz_> lyxia: Does this even make sense for a monadic computation, though?
15:24:38 <lyxia> It doesn't
15:25:11 <koz_> lyxia: OK, so I should just use 'parMap rseq' then?
15:26:09 <lyxia> why are you trying to force a monadic value
15:26:24 <delYsid> > unfoldr (\b -> if b == 0 then Nothing else Just $ b `divMod` 10) 1210
15:26:27 <lambdabot>  [121]
15:26:50 <koz_> lyxia: I'm trying to understand why my parallel computation slumps.
15:26:53 <delYsid> hmm, I dont quite have the correct termination condition yet
15:26:56 <koz_> I was suspecting unwitting laziness.
15:27:31 <koz_> Also, lyxia: Could you help me diagnose an issue I'm having? Profiling tells me 98-odd percent of my allocations occur in a simple catamorphism. Could you help me understand why?
15:28:58 <lyxia> koz_: sequence . parMap rseq  this doesn't look good. You don't want to force the (m whatever) action, but the value that you obtain after running it.
15:29:32 <koz_> lyxia: So what would you recommend instead?
15:29:43 <koz_> I've never tried to do something like this with monadic computations.
15:31:28 <koz_> lyxia: Let me re-paste the code I've got.
15:31:56 <rhart> so for each triangle there are 3 permutations of the order of the digits they can take. i then tried to use a list comprehension to get all combinations of the sets of triangles  the issue i was running into is that lets say i number the triangles 1,2,3,4,5. with how i was doing the comprehension the order of the triangles would always be 1,2,3,4,5 when this doesnt always give the correct answer. is there a wau to fix this with list comprehensions or 
15:31:56 <rhart> should i look at doing it another way?
15:32:16 <koz_> lyxia: http://lpaste.net/252507 <-- this is what I have now.
15:32:48 <delYsid> > reverse $ unfoldr (\b -> if b == 0 then Nothing else Just $ swap $ b `divMod` 10) 123
15:32:51 <lambdabot>  [1,2,3]
15:33:40 <lyxia> koz_: I think it would be simpler if doTheNeedful did not run in MonadRandom.
15:33:49 <pikajude> so wait, how ARE backpack signatures different from typeclasses?
15:34:18 <koz_> lyxia: How would I do that?
15:34:19 <delYsid> Can I avoid the reverse there? Or, IOW, why is there no unfoldl in Data.List?
15:34:35 <Tuplanolla> You probably want `quotRem` there, delYsid. Try a negative number.
15:34:37 <delYsid> nah, that was not quite right.
15:34:51 <lyxia> koz_: pass it the StdGen explicitly
15:34:58 <Tuplanolla> Even in general `divMod` is the odd one out.
15:35:14 <lyxia> koz_: produce 100 StdGens in a list
15:35:21 <lyxia> koz_: then use parMap
15:36:19 <koz_> lyxia: I'll try that - thank you!
15:37:52 <lyxia> rhart: I meant to use permutations on the list of triangles
15:37:57 <lyxia> rhart: not on each triangle
15:38:26 <lyxia> rhart: you don't want to apply permutations on each triangle anyway because that gives you 6 permutations
15:38:31 * hackagebot brick 0.11 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.11 (JonathanDaugherty)
15:38:33 * hackagebot event-transformer 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/event-transformer-0.1.0.0 (SchellScivally)
15:40:42 <delYsid> > reverse $ unfoldr (\b -> guard (b /= 0) >> return (swap $ b `quotRem` 10)) 123
15:40:45 <lambdabot>  [1,2,3]
15:44:37 <Tuplanolla> > reverse $ unfoldr (\ n -> [swap (n `quotRem` 10) | n /= 0]) 123
15:44:40 <lambdabot>  error:
15:44:40 <lambdabot>      • Couldn't match expected type ‘Maybe (a, Integer)’
15:44:40 <lambdabot>                    with actual type ‘[(Integer, Integer)]’
15:45:06 <Tuplanolla> Why doesn't lambdabot have MonadComprehensions on?
15:45:36 <Tuplanolla> It's such a dandy extension.
15:46:02 <delYsid> oh, ghc *has* monad comprehensions?
15:46:07 <lyxia> it's annoying to write one-liners with it
15:46:18 <lyxia> or does it default to lists?
15:46:20 <Tuplanolla> Yes! Try that one with it, delYsid.
15:47:13 <Tuplanolla> It defaults to lists, lyxia.
15:48:48 <delYsid> Tuplanolla: Very cool!
15:49:58 <delYsid> I recently saw a talk which mentioned idiom brackets in the context of ghc, have they landed already as well?
15:50:36 <rhart> lyxia: I was doing it on each individual triangle because they can be rotated. I was only using the indicies of the list for a valid rotate though. Thinking about it now though I can maybe take the list comprehension I had and then doing permutations on that list to give all combinations of the triangles.
15:50:40 <Tuplanolla> I'd also like to point out that not using `reverse` is the morally correct choice. The least significant digit (whose magnitude is always known) is always the first element in the list (whose index is always known).
15:51:14 <koz_> lyxia: Thank you so much - that did it!
15:51:30 <lyxia> Tuplanolla: I don't get list like behavior in ghci if I don't annotate it.
15:52:10 <lyxia> I don't even know what "defaulting" means for MonadComprehension
15:52:34 <Tuplanolla> You're right, lyxia. I did the dumb thing and used list in my test.
15:53:35 <Tuplanolla> Running `[x | x <- return 2]` works in GHCi for similarly silly reasons.
15:53:48 <lyxia> it thinks it's IO
15:54:03 <Tuplanolla> Yeah.
15:58:39 <koz_> lyxia: OK, now the weird allocation question. The allocations and work all happen in 'evaluate': http://lpaste.net/252507 . Could you help me understand why this is happening, because it doesn't seem to make a lot of sense.
16:00:17 <Axman6> koz_: that implementation of meanR is really bad, it will ensure that you completely allocate everything passed to it. you should be doing the sum and count in a single fold
16:00:27 <Axman6> (both implementations)
16:00:36 <koz_> Axman6: Good point. I shall address this.
16:00:57 <Axman6> take a look at the foldl package to see how you can write this really nicely with a single pass
16:01:04 <lyxia> Uh, I'm not sure I'm qualified enough to figure this one out.
16:01:30 <Axman6> (would look something like: fold (sum / fromIntegral <$> length) xs
16:01:54 <Axman6> also, take a look at my foldl-statistics package ;)
16:02:00 <koz_> Axman6: Can't I just fold into a pair, then % together?
16:02:46 <Tuplanolla> You should probably change to an online mean, which is also more numerically stable, koz_.
16:03:17 <koz_> Tuplanolla: My mean computation uses Rational, so I don't see how numerical stability is a problem.
16:03:30 <Tuplanolla> Oh, carry on then. I only glanced at the code.
16:04:10 <Tuplanolla> It's probably time to call it a day.
16:04:53 <koz_> Axman6: Is your 'mean' good on the issue that you've said mine was bad on?
16:08:07 <Gurkenglas> koz_, yes folding into a pair and %ing together is effectively what those packages do
16:08:40 <Gurkenglas> "fold ((/) <$> L.sum <*> L.genericLength) xs"
16:10:14 <koz_> Gurkenglas: Ah, OK.
16:10:18 <koz_> I shall fix that then.
16:10:28 <koz_> Gurkenglas: Could you help diagnose my weird allocation issue?
16:10:58 <Gurkenglas> (L. refers to the qualifier of the Control.Foldl import)
16:11:16 <Gurkenglas> Whoops, should be L.fold there instead of fold
16:14:11 <Gurkenglas> koz_, how do you know the allocations happen in evaluate?
16:15:50 <Gurkenglas> Hmm I wonder if ekmett had a reason for not putting a catamorphism in Cofree
16:19:56 <koz_> Gurkenglas: Profiling.
16:20:10 <koz_> Gurkenglas: The reason in that for general Cofrees, catas are not guaranteed to terminate.
16:20:29 <Gurkenglas> Same for Frees
16:20:40 <koz_> In my case, I can be sure of that, though.
16:20:50 <koz_> (because Atom forms a base case in Operator)
16:21:43 <Gurkenglas> That doesn't gurantee termination, what about coiter neg
16:21:46 <Gurkenglas> *coiter Neg
16:22:52 <Gurkenglas> wait, that's wrong, let me try again
16:24:09 <Gurkenglas> coiter (Neg . (+1)) 0
16:28:33 <koz_> Gurkenglas: coiter isn't a cata.
16:28:40 <koz_> (it's an ana)
16:29:13 <Gurkenglas> Yea, but "coiter (Neg . (+1)) 0" produces something that evaluate does not halt on
16:30:35 <koz_> Gurkenglas: OK, sure, but I'm not planning on calling that any time ever. :P
16:30:52 <koz_> (the only way to make a Formula is to randomly generate it, followed by a sequence of mutations)
16:36:16 <koz_> Is there no sort function for Vectors?
16:36:33 <dmj`> koz_: vector-algorithms
16:36:38 <koz_> dmj`: Thanks!
16:36:59 <dmj`> koz_: what kind of vector are you using
16:38:10 <koz_> dmj`: Vector Int.
16:38:28 <dmj`> koz_: I have a quicksort for that
16:39:37 <dmj`> koz_: you won't need an extra dep.
16:39:43 <koz_> dmj`: That'd be nice!
16:41:17 <dmj`> koz_: https://gist.github.com/dmjio/523519929ff2c0f3eb655dbb86f43fe6
16:44:05 <koz_> dmj`: Thanks!
16:44:33 <dmj`> koz_: cheers
16:47:15 <koz_> dmj`: Did you mean the MVector from M or from MV?
16:47:20 <koz_> (or does it not matter?)
16:49:33 <Axman6> koz_: yes, my mean is good, and works in a single pass
16:49:51 <koz_> Axman6: OK, thanks for letting me know.
16:51:02 <dmj`> koz_: I think you can safely ignore that import (MV)
16:51:23 <dmj`> Mutable and Unboxed is what we want
16:52:11 <koz_> dmj`: OK, thanks!
16:53:00 <Axman6> koz_: obviously those only work on Doubles though (which may or may not be fine for your purposes). the results should be about as accurate as possible for Doubles though
16:59:37 <jle`> koz_: it's actaully better than folding into a tuple because tuples in haskells are lazy, so you leak space
16:59:47 <jle`> koz_: (regarding the foldl library)
17:00:29 <jle`> but even if you folded into a custom strict tuple, the foldl library helps you by letting you write your code more concisely and meaningfully, and lets you avoid boilerplate
17:00:38 <jle`> which is pretty much 75% of haskell abstractions :)
17:00:54 <jle`> s/much/much like
17:01:06 <athan> Exceptions "leak" up to the parent thread of a forked thread, don't they?
17:01:08 <jle`> *composability
17:01:20 <jle`> athan: if they aren't caught, i think
17:01:25 <jle`> er wait, no.
17:01:26 <athan> Wouldn't they cause execution to halt if the parent thread was in a loop?
17:01:31 <athan> jle`: That's what I would think :s
17:01:39 <jle`> it might just kill the forked thread
17:01:47 <athan> oh crud, shoot
17:01:49 <jle`> and the parent wouldn't be any the wiser
17:01:53 <athan> thanks jle` :)
17:01:57 <jle`> np
17:06:58 <Myrl-saki> why are all physics library outdated.
17:07:50 <Koterpillar> physics is timeless
17:07:58 <jle`> tell me about it
17:08:09 <Myrl-saki> jle`: about it.
17:08:12 <jle`> when i did my physics degree in undergrad we all had to work with fortran libraries
17:08:25 <jle`> and that was in like 2012
17:08:39 <jle`> well, to be fair, fortran libraries age very well
17:09:11 <hpc> it's the keith richards of programming languages
17:09:24 <hpc> every time you write a web framework in a language, it takes a year off its life and gives it to fortran
17:10:48 <Axman6> jle`: yeah you're be surprised how much fortran we rely on in scientific code which no one notices is there.
17:11:53 <Axman6> hmm, surprised to find out that PROJ.4 was rewritten in C in 1985
17:12:30 <Axman6> I'd love to reqrite it in Haskell... but time and need
17:14:12 <Malkrith> Pretty sure Haskell is also not as fast 
17:16:45 <jle`> you'd be surprised! :O
17:30:14 <Axman6> there's no reason Haskell code shouldn't be fast for this sort of thing, particularly if we compile with LLVM
17:30:56 <jmcarthur> There are reasons. For example, there are practical limitations to the amount of manpower devoted to making the compiler good at this sort of thing.
17:38:34 * hackagebot parsec-free 3.1.11.4 - Parsec API encoded as a deeply-embedded DSL, for debugging and analysis  https://hackage.haskell.org/package/parsec-free-3.1.11.4 (JohnWiegley)
17:39:53 <Axman6> jmcarthur: there's plenty of manpower devoted to make LLVM good at these sorts of things though. 
17:40:06 <jmcarthur> But GHC doesn't necessarily generate good LLVM.
17:44:29 <Axman6> that's true, but there are some optimisations that should mitigate that somewhat, like the SLP vectoriser
17:52:49 <johnw> so, parsec-free is making it really easy to debug parsec parsers...
17:53:58 <Axman6> wow... ParsecF is massive
17:54:03 <johnw> yep
17:54:06 <johnw> that's the magic
17:54:51 <volhovm> Hello! Is there any decent article about database support?
17:55:02 <volhovm> Wiki is outdated imho
17:55:05 <Koterpillar> volhovm: what do you wish to learn?
17:55:19 <volhovm> what frameworks are there at all
17:56:21 <volhovm> https://wiki.haskell.org/Applications_and_libraries/Database_interfaces
17:56:32 <volhovm> Something like that, but maybe with comparison of them.
17:56:42 <volhovm> and what approach is most widely used
17:57:05 <johnw> volhovm: I don't think any particular approach has "won" yet
17:57:09 <volhovm> i'm mostly using acid-state for all the projects, but it's time to grow :)
17:57:25 <johnw> persistent is one you could start with, or esqueleto, or postgreqsl-simple
17:57:36 <Axman6> there's quite a few I've used in a the last few years, persistent is useful if you need to have relatively easy migrations, and esqueletto makes it fairly nice to write queries in. powtgres-simeple and sqlite-simple are great for lots of things where you know the SQL you need to write and that's all you need. hasql is pretty great if you just need postgres support, seems to be really fast
17:57:50 <Axman6> acid-state is pretty cool
17:58:06 <dmj`> acid-state \o/
17:58:56 <volhovm> thank you, that's a nice point to start
17:59:42 <Axman6> I've only just started playing with hasql, but I'm quite liking it. it has a reputation for being the fastest postgres client library
18:00:03 <Axman6> but takes some getting used to, makes some pretty opinionated decisions
18:00:09 * Axman6 -> lunch
18:00:11 <dmj`> postgresql-typed is another, albeit lesser known
18:00:22 <dmj`> but uses hasql's binary protocol
18:00:25 <dmj`> iirc
18:22:33 <Tehnix> volhovm: Doesn't give that much, but I generally like to check out http://haskelliseasy.readthedocs.io/en/latest/#sql
18:23:00 <Tehnix> Persistent is quite easy and nice with type safety, and esqueleto for more advanced usage (joins etc)
18:23:56 <volhovm> Alright, that's an important remark
18:24:03 <hackrilege> hi! anyone can take a look at this material and discuss the presented zippers? http://lpaste.net/252794
18:29:16 <hackrilege> *tumbleweed*
18:45:49 <athan> Anyone here know how to re-throw exceptions thrown by a `forkIO`'d process?
18:47:28 <glguy> http://hackage.haskell.org/package/async-2.1.0/docs/Control-Concurrent-Async.html#g:8
18:49:30 <riaqn> athan: more context please?
18:50:33 <athan> riaqn: I'm trying to relay an exception thrown in a child process - I can see the errors being printed to stdout for some reason though
18:50:53 <athan> glguy with the save :) thank you!!
18:52:14 <bitemyapp> athan: slave-thread too
18:52:19 <bitemyapp> depending on what you want.
18:53:21 <athan> :o
18:54:50 <geekosaur> is this actually a process or a thread?
18:54:59 <geekosaur> they are very different things
18:55:14 <athan> geekosaur: Just a thread
18:55:31 <athan> it... uh... watches a file, parses it, and if "ERROR" is in one of the lines, it throws an exception :D
18:56:09 <monando> Anyone here?
18:56:27 <koz_> monando: Sure am.
18:57:00 <monando> did you see lpaste.net/252794
18:57:03 <monando> ?
18:57:40 <monando> I was fishing for suggestions or comments
18:59:33 <monando> I'm not sure what intuition you have with zippers, i hope it makes sense
19:02:13 <athan> Would `System.Directory.removeFile` ever continue execution before the file is removed from the filesystem? :(
19:03:11 <monando> I don't understand what you mean?
19:03:47 <monando> "Continue execution"?
19:04:19 <athan> monando: the dual to blocking :)
19:04:36 <athan> i.e., `removeFile` should block until the file no longer exists
19:04:44 <monando> I see
19:04:48 <athan> (in the IO monad)
19:05:46 <monando> Have you observed it returning without removing a file out returning a permission error?
19:05:54 <Koterpillar> does that imply doing a sync()?
19:06:05 <monando> Or*
19:06:27 <athan> hmm... :s not sure
19:07:27 <geekosaur> sync() is itself not synchronous...
19:07:36 <monando> Id guess it would throw an error like file does not exist or something, and only return once the file was removed. I guess it's down to the OS
19:08:07 <pikajude> isn't sync() for file contents?
19:08:57 <geekosaur> you're thinking of fsync
19:09:20 <pikajude> that would make sense
19:10:32 <Tehnix> Hmm, using stack with docker, has anyone else gotten stuck on `..Linking .stack-work/dist/x86_64..`? Or can it just take *very* long to complete?
19:10:33 <geekosaur> also sync() is a very heavy hammer, and has a good chance of negatively affecting every process on the system that operates on files
19:11:17 <geekosaur> haskell libraries, especially when built with split-objs as base usually is, stress the linker significantly
19:11:34 <geekosaur> make sure you're using gold instead of binutils ld
19:14:01 <monando> I was talking about using Free [] as a Zipper. I wrote lpaste/252794 as background...
19:14:53 <monando> Oops I ment lpaste.net/252794
19:15:45 <monando> I'm a bit confused about the use of the additional type parameter to ZipperN...
19:16:43 <monando> Anyone have any ideas?
19:22:53 <jchia> style question: I have a function f that uses a simple helper function g. Nowhere else is g used. Is it OK to define g within f using let/where instead of outside at the same level as f? Any performance implication?
19:24:46 <monando> jchia, if g is useful only in that function then define it with restricted scope using let or where, otherwise it may be helpful to define it at top level incase it can be used in other functions
19:31:58 <monando> The idea of using Free [] As a zipper was to hold various nestings to facilitate fast navigation in the style of dlist
19:32:44 <monando> Also I wanted to discuss the following type
19:33:02 <glguy> You should chat with zell and hackrilege and others about that type when they get back, they're always going on about it
19:33:23 <monando> I am both of those users
19:33:44 <glguy> OK, then you could talk to yourself about it
19:35:32 <MarcelineVQ> :>
19:35:47 <burrino> Sorry, got disconnected
19:35:58 <burrino> What were you saying?
19:37:11 <burrino> data Lunch f a = Lunch (Free (Compose f Lunch) a)
19:37:45 <burrino> (burrino) data Lunch f a = Lunch (Free (Compose Lunch f) a)
19:37:52 <burrino> That one
19:38:37 * hackagebot yahoo-finance-api 0.2.0.0 - Read quotes from Yahoo Finance API  https://hackage.haskell.org/package/yahoo-finance-api-0.2.0.0 (cdepillabout)
19:39:51 <burrino> Or maybe it's, data Free2 f a = Free2 (Free (Free f) a), this one I can use the inner Free as a Zipper and make infinite nesting of it with the outer Free
19:41:00 <burrino> Honestly rather not talk to myself about it really that's why I'm using the irc
19:44:10 <burrino> Suggestions on how to engage participation also appreciated
19:48:12 <burrino> I guess id like top eventually make a library people will use, so suggestions from the community are really essential, if approach exists elsewhere it's redundant, and if it's not clear how it's a useful approach, discussion will help me communicate this better. It seems faster in some common use cases than standard libraries
19:50:22 <burrino> Also there are some aspects I can't quite pin down, i hope that other people's better experience of lens and other libraries I'm not so familiar with could yield fruitful reflection
19:51:40 <burrino> The use of a type parameter such as Int to direct navigation (construction and destruction) seems like it should be a broader field that I'm not aware of
19:52:36 <burrino> I guess i should use type level Int so that e.g. The number of nestings of the Free structure can be provided to the contained type
20:17:41 <ashishnegi> hi.. i am trying to use `Network.Wai.Middleware.Gzip` https://hackage.haskell.org/package/wai-extra-3.0.17/docs/Network-Wai-Middleware-Gzip.html#t:GzipSettings
20:18:11 <ashishnegi> i want to create `(Gzip.GzipSettings Gzip.GzipCompress Gzip.defaultCheckMime)` but GzipSettings constructor is  not exported
20:18:31 <ashishnegi> and i can not find any function in docs to create it.. Am i missing something ?
20:18:56 <Koterpillar> ashishnegi: it's an instance of Default, so use the record update syntax
20:19:08 <ashishnegi> oh.. :)
20:21:17 <ashishnegi> Koterpillar: thanks that works.. :) is this kind of thing common in haskell apis ?
20:21:46 <Koterpillar> that is a pattern to future-proof the type
20:22:05 <Koterpillar> for example, if a new version adds gzipFancyParameter, your code using the constructor will stop working
20:29:43 <johnw> burrino/hackrilege/redbarron/monando/zell: it's time to leave the channel alone with your questions about this free zipper construction.  If you want to make such a thing, make it.  There is no more reason to talk about it here.
20:29:54 <burrino> Ok
20:29:57 <burrino> Sorry
20:29:59 <johnw> thank you
20:31:06 <burrino> Thanks for clearing that up, I wasn't sure what was going on
20:31:50 <burrino> Would you like to see it when it's finished?
20:32:01 <johnw> sure, feel free to PM me
20:32:28 <burrino> Thanks, at least that gives me reason to push forward
21:06:02 <bollu1> how do I use ekmett's zipper package?
21:06:06 <bollu1> the types don't make much sense
21:08:09 <bollu> lens + zipper is just confusing :P
21:08:10 <bollu> https://hackage.haskell.org/package/zippers-0.2.2/docs/Control-Zipper.html
21:08:20 <bollu> some help figuring out how to use it?
21:08:21 <bollu> or a paper?
21:08:28 <johnw> do you need it?
21:09:05 <bollu> johnw: do I need zippers? yes. Do I need kmett's implementation, not necessarily, but it seems cool
21:09:19 <johnw> there are lots of examples on that page; try them out, play with them
21:09:24 <bollu> johnw: I'm rewriting this: https://github.com/bollu/cellularAutomata
21:09:32 <edwardk> they used to be part of the lens package even
21:09:45 <glguy> The zippers package suffers from being a bit too typed which makes it hard to use on recursive types
21:10:05 <glguy> you should be comfortable with lens generally before exploring zippers
21:10:21 <koz_> What is the easiest way for me to have incremental writing to a file? The normal IO way waits till everything is done before writing and eats memory.
21:10:39 <johnw> koz_: um, what?
21:10:40 <bollu> glguy: ah, damn
21:10:47 <johnw> the normal IO way is to write what you tell it to write, when you say to write it
21:10:51 <bollu> glguy: I've played around with lens, but I don't fgrok it
21:10:56 <bollu> grok*
21:11:22 <bollu> glguy: I haven't found a reason to heavily use lenses yet,,
21:11:43 <koz_> johnw: Maybe I'm using the wrong primitive. What is the correct way to say 'write some Text to a file without truncating the file'?
21:11:54 <glguy> appendFile
21:12:04 <koz_> glguy: OK, thanks. I *was* using the wrong primitive...
21:13:15 <glguy> bollu: Yeah, if you don't undrstand them it'll be hard to see where to use them
21:13:36 <bollu> glguy: I mean, I think I get the general gist of why one would want them, and I've played around with them
21:13:42 <bollu> glguy: watched kmett's talk as well
21:13:48 <bollu> glguy: but, like, I dunno. 
21:14:06 <bollu> glguy: I've used them once or twice for heavy JSON navigation
21:14:32 <johnw> I would say, don't use them just to use them; the day will come when you're writing tons of boilerplate and someone will point out "lenses would reduce this down to 2 lines", and then the lightbulb will come on pretty brightly
21:15:19 <johnw> too often people reach for feature X "because X", and then come away thinking it's too hard or useless because the motivation wasn't right yet
21:15:50 <nshepperd1> Looks like the standard list zipper per that zippers package would be [a] :>> a?
21:16:53 <dmj`> navigating recursive structures is great with lens, but if your ADTs are flat... then record wild cards would probably suffice
21:17:08 <johnw> i usually reach for lens first because of maps containing records
21:17:10 <nshepperd1> And you would use leftward, rightward, focus as the main accessors?
21:17:31 <johnw> or State with a record as the state
21:17:51 <johnw> State (Map a MyRecord) is just brilliant with lens :)
21:17:54 <bollu> johnw: lens helps with State because of the "imperative looking" operators right? += and all
21:18:11 <dmj`> yes, setters in a state monad are /very/ convenient
21:18:15 <glguy> nshepperd1: Yeah, basically. That works out because you can load the whole list into the zipper at once with a single within traverse
21:18:49 <bollu> glguy, johnw I'm trying to simplify this: https://github.com/bollu/cellularAutomata/blob/master/src/Cellular.hs#L49 It's a zipper on a circular lis
21:18:51 <bollu> list*
21:19:12 <bollu> would using lens / zippers help?
21:19:20 <johnw> sorry, never needed zippers
21:19:32 <glguy> bollu: What would help would be not using Vector
21:19:57 <bollu> glguy: uhh, okay.. why not?
21:20:06 <bollu> glguy: I wanted O(1) random access
21:20:20 <glguy> because it'll make a zipper that's slow to move forward and backward
21:20:53 <bollu> glguy: I see
21:21:18 <dmj`> someone needs to make some lenses for ghcjs-base 
21:21:57 <dmj`> JSString, Object, JSVal, JSArray need lens love
21:22:20 <bollu> glguy: what else?
21:22:30 <dmj`> maybe lenses don't work for ffi types tho :/
21:23:17 <nshepperd1> Hum, zippers on a circular buffer huh
21:23:25 <bollu> nshepperd: yes
21:23:50 <bollu> nshepperd: I'm using it to write a comonad for a finite cellular automata (finite grid that wraps around)
21:23:55 <EvanR> if you had a circular buffer you wouldnt need a zipper
21:24:06 <EvanR> unless the zipper contains the indexes and you dont feel like doing math
21:24:21 <nshepperd1> And you need to be able to efficiently edit the focused element?
21:24:26 <bollu> nshepperd: yep
21:24:43 <bollu> EvanR: it was a "how do I encode this" exercise :) 
21:24:59 <nshepperd1> If you didn't, i would suggest a vector and an Int index
21:25:01 <EvanR> O(1) lookup and immutable update
21:25:28 <bollu> nshepperd: yes, but that's.. boring :P
21:27:05 <nshepperd1> Boring and efficient :)
21:27:07 <EvanR> faster lookup for a zipper, hold 2 elements at a time, in a pair
21:27:17 <EvanR> even faster, 3
21:27:31 <EvanR> now, generalize this to a list of focused elements
21:27:51 <EvanR> now you have best of both worlds
21:28:51 <bollu> EvanR: :wait, you're not serious, right?
21:28:58 <nshepperd1> EvanR: what?
21:29:57 <EvanR> [1,2,3] (4,5) [6,7,8]
21:30:06 <EvanR> [1,2] (3,4) [5,6,7,8]
21:30:15 <EvanR> take the obvious conclusion
21:30:34 <bollu> EvanR: no, like, how does that help?
21:30:43 <nshepperd1> Off the top of my head i would say a Data.Sequence could serve as your circular zipper
21:31:10 <bollu> nshepperd: ooh, did not know of the library
21:31:11 <bollu> neat
21:31:24 <ReinH> A regular zipper is fine, you get amortized constant time left and right.
21:31:26 <nshepperd1> O(1) push / pop from each end to move left and right
21:31:40 <ReinH> Why do you need random access for a zipper anyway?
21:32:15 <ReinH> You don't need to access both ends.
21:32:24 <ReinH> Two lists is fine
21:32:46 <bollu> ReinH: hm, right
21:33:13 <ReinH> There's one in package somewhere
21:33:15 <nshepperd1> For a circular buffer?
21:33:26 <ReinH> In hackage
21:33:28 <ReinH> Yes
21:33:54 <nshepperd1> You need to reverse the other list when you get to the end
21:34:12 <ReinH> Yes, thus amortized constant time.
21:34:33 <nshepperd1> I guess that's still amortised constant if you make sure to place yourself in the middle whenever that happens
21:34:34 <ReinH> But better constants
21:34:41 <nshepperd1> Yeah
21:35:07 <ReinH> Short list, reversing is fast. Long list, reversing is infrequent.
21:35:35 <bollu> soo.. recommendation?
21:35:48 <ReinH> Have you seen the thing Ed and I did?
21:36:06 <bollu> ReinH: no, I haven't
21:36:08 <ReinH> @google Edward kmett cellular automata
21:36:10 <lambdabot> https://www.schoolofhaskell.com/user/edwardk/cellular-automata
21:36:11 <bollu> ReinH: (which one)?
21:36:29 <nshepperd1> Might need some proactive reversal to take care of persistence
21:36:31 <bollu> ReinH: oh the article? yes, that's what made me learn what a comonad is in the first place
21:36:35 <ReinH> Ok
21:36:46 <nshepperd1> Or, just use a standard bankers deque
21:36:58 <nshepperd1> That makes sense
21:36:58 <ReinH> You might also try a Vector and an Int pointer
21:37:03 <edwardk> that was a fun article series
21:37:16 <bollu> nshepperd: 
21:37:21 <bollu> nshepperd: what's bankers deque?
21:37:39 <ReinH> @where okasaki
21:37:40 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
21:37:46 <ReinH> There are some packages
21:38:13 <bollu> ahh, guess today is the day I finally read about how finger trees work
21:41:38 <nshepperd1> So, recommendation: data CircularZipper a = C (Dequeue a) a?
21:42:29 <bollu> nshepperd: that would work, yes?
21:42:53 <nshepperd1> Move left / right by pushing / popping from different ends of the dequeue, and you can use something like https://hackage.haskell.org/package/dequeue-0.1.12/docs/Data-Dequeue.html for the dequeue which is implemented as just two lists
21:43:16 <bollu> nshepperd: okay, thanks
21:43:23 <bollu> appreciate all the help :)
21:43:46 <nshepperd1> That's what i would try anyway :)
21:46:14 <bollu> nshepperd: also, right now, I have a 1d zipper and a 2d zipper
21:46:27 <bollu> nshepperd: can I inductively define the n'th level based on the n-1th type?
21:46:42 <bollu> nshepperd: s/define/ecndoe
21:46:44 <bollu> encode*
21:49:42 <EvanR> infinity zipper, sounds good
21:50:28 <EvanR> a zipper to zipper through all your zippers
21:52:20 <nshepperd1> You can have zippers of zippers, sure
21:53:36 <EvanR> how about this
21:53:37 <bollu> nshepperd: no, I mean
21:54:48 <bollu> EvanR: go on
21:54:59 <EvanR> lets say you have a zipper, but both sides are infinite and youre not expecting to "modify" anything. and you want to scroll back and forth, which will evaluate and increase memory usage. is there a way to "trick" the garbage collector into sometimes forget parts of that chain and revert them to thunks
21:55:12 <EvanR> ;)
21:55:26 <EvanR> sort of like turning a boiled egg back into a raw egg
21:56:11 <EvanR> the point being to trade off space for time 
21:56:49 <EvanR> in fact a general mechanism to undo computation would be cool
21:57:18 <ezrios> does QSem provide any fairness guarantees, like MVar?
21:58:44 <nshepperd1> EvanR: i think the primitive you need there is forkThunk :: a -> (a, a)?
21:59:02 <EvanR> yes
21:59:07 <nshepperd1> Which has been suggested at some point, i think
21:59:26 <bollu> what does that do?
21:59:29 <bollu> forkThunk?
21:59:40 <EvanR> you could fork thunks to generate the list elements, but put them in weak pointers
21:59:43 <Koterpillar> AFAIK after the thunk is evaluated, there's no information to recreate it
22:00:15 <EvanR> if you see the pointer empty (with unsafePerformIO) then fork thunk again
22:00:17 <jle`> would you consider if/then/else syntax in haskell to be syntactic salt
22:00:19 <jle`> i say yes
22:00:40 <EvanR> also, would forkThunk need IO
22:01:45 <nshepperd1> Koterpillar: yeah, so you need to hold a copy of the old thunk somewhere
22:03:07 <nshepperd1> I suppose it can be forkThunk :: a -> IO a
22:03:29 <MarcelineVQ> Would StaticPtr be relevant to the subject?
22:03:36 <nshepperd1> So your two copies are the original and the output there
22:04:08 <Axman6> johnw: so what's the advantages of using parsec-free? how does it help debug things?
22:04:15 <johnw> I'll show you
22:04:26 <johnw> https://gist.github.com/d3e9dbbbd2860de1054687601015da86
22:04:55 <johnw> I have a grammar, without any tracing statements, and I'm trying to track down an error due to incorrect backtracking (and the fact that I just learned that A <|> B doesn't try B if A has consumed any input)
22:05:11 <johnw> all you do is change your parsec dependency in .cabal to parsec-free.  None of the API needs to change
22:05:26 <johnw> then you use "parseTestLog False" instead of parseTest, and you get the kind of output I just pasted
22:05:46 <johnw> it makes it easier to see "what parsec was thinking"
22:05:59 <Axman6> yeah right, pretty handeh!
22:06:09 <Axman6> how's performance compare?
22:06:19 <johnw> I imagine it's absolutely abysmal
22:06:24 <Axman6> heh
22:06:24 <johnw> this is a development tool, not a production one
22:06:53 <dmj`> johnw: that is sweet
22:07:54 <johnw> terms printed in (parens) indicate parsers that failed, which are usually non-fatal, but you get to see them
22:10:41 <dmwit> jle`: https://media.giphy.com/media/oAkR5RcDyLzG0/giphy.gif
22:13:08 <jle`> :p
22:13:32 <EvanR> arent these "memes" supposed to come with subtitles
22:14:19 <johnw> Axman6: I imagine you could use this for performance debugging, though.  For example, build an evaluator that counts how deep/often failed "try" blocks are for typical inputs in one's own parser
22:15:48 <johnw> i should also have it print when the right-hand side of <|> is ignored due to consumed input
22:30:28 <anohigisavay> hi
22:31:56 <anohigisavay> do i have alternatives to whamlet? i don't want to pull in the entire yesod beast for a simple template engine
22:32:28 <Koterpillar> you don't have to use yesod for hamlet
22:34:16 <anohigisavay> Koterpillar: really? i see the whamlet quasiquoter comes from yesod-core
22:35:38 <anohigisavay> actually i have no experience with yesod. i just want a template engine that gets me strings insteand of Html or Widget stuff which i have no idea what they are
22:36:38 <Koterpillar> maybe you found an old version? http://hackage.haskell.org/package/shakespeare
22:37:22 <Koterpillar> https://github.com/yesodweb/shakespeare/blob/master/Text/Hamlet.hs#L295
22:37:44 <anohigisavay> Koterpillar: wow that's cool. thanks :)
22:37:46 <geekosaur> I suspect whamlet is designed to integrate hamlet with yesod; shakespeare has several other quasiquoters
22:37:55 <geekosaur> hamlet, shamlet, etc.
22:38:03 <Koterpillar> same suspicion 
22:38:12 <anohigisavay> geekosaur: ahh i see
22:38:42 * hackagebot fadno-xml 1.0.3 - XML/XSD combinators/schemas/codegen  https://hackage.haskell.org/package/fadno-xml-1.0.3 (spopejoy)
22:38:44 * hackagebot parsec-free 3.1.11.5 - Parsec API encoded as a deeply-embedded DSL, for debugging and analysis  https://hackage.haskell.org/package/parsec-free-3.1.11.5 (JohnWiegley)
22:38:46 * hackagebot cryptonite-openssl 0.2 - Crypto stuff using OpenSSL cryptographic library  https://hackage.haskell.org/package/cryptonite-openssl-0.2 (VincentHanquez)
22:42:30 <bollu> given the free DSL type, how do you figure out the interpreter type?
22:43:08 <lpaste> bollu pasted “free-cofree” at http://lpaste.net/253223
22:43:12 <bollu> ^
22:46:16 <Rarrikins> Getting the sum of the digits of a large Integer is a LOT faster using show to get each digit than using quotRem.
22:46:40 <johnw> bollu: google for "free cofree interpreter"; several good articles about that question
22:46:59 <Axman6> that's not super surprising, the imeplementation of Show for Integers is liukely using GMP and probably quite fast
22:47:41 <bollu> johnw: I did actually, but none of the seem to explain very well how they arrived at the exact interpreter typ
22:47:44 <bollu> e*
22:48:18 <johnw>  read them again, and try some simple exercises in code
22:48:26 <EvanR> bollu: delete the type sig and use the inferencer? ;)
22:48:47 <bollu> EvanR: ;)
22:48:57 <bollu> johnw: very well, thanks
22:52:34 <dmj`> ghcjs-base's export function is awesome
22:52:46 <dmj`> https://github.com/ghcjs/ghcjs-base/blob/master/GHCJS/Foreign/Export.hs#L45
22:56:56 <bollu> johnw: okay, I think I got it
22:57:13 <bollu> johnw: we need something that takes the current state, and returns the new *interpretation functions*
22:57:17 <bollu> johnw: orrect?
23:01:56 <johnw> bollu: I wasn't thinking about the problem, sorry
23:03:53 <bollu> johnw: ah, okay
23:06:33 <Squarism> some told me not to use hoogle
23:06:43 <Squarism> ...that there is a better alternative
23:06:46 * dmj` gasps
23:06:53 <johnw> Squarism: the best hoogle is a local hoogle :)
23:06:59 <EvanR> local hoogle er ^
23:07:05 <johnw> https://hub.docker.com/r/jwiegley/hoogle-local/
23:07:09 <johnw> that's what I use
23:07:14 <Squarism> oh ok
23:07:31 <srhb> Squarism: Or some combination of the various hoogleses in the wild + hayoo
23:07:33 <srhb> Works too!
23:08:18 <Squarism> but if you search for something you dont have then?
23:08:55 <srhb> Then you know that youj can get it. :P
23:25:35 <firstdayathaskel> hello strangers, I want to learn haskell
23:25:48 <liste> hello firstdayathaskel 
23:26:04 <Maxdamantus> How does it feel to be a thaskell?
23:26:07 <firstdayathaskel> http://learnyouahaskell.com/introduction#about-this-tutorial
23:26:10 <firstdayathaskel> is this any good?
23:26:24 <johnw> firstdayathaskel: I liked it
23:26:44 <firstdayathaskel> I'm new to FP
23:26:59 <Axman6> some people really like it, some don't. You should try #haskell-beginners for the most up to date advice (but stick around in here too, lots of people who will help)
23:27:25 <firstdayathaskel> so I went through Quora and felt haskell is prolly the best FP language to learn for a beginner
23:27:58 <firstdayathaskel> Thx Axman
23:28:12 * Maxdamantus has never really liked learning technical things by reading books.
23:29:51 <Axman6> ezyang: Hello! I was thinking last night about what backpack might be useful for, and realised that something HaLVM might be an excellent usecase - being able to parameterise things like the network stack make writing interoperable code much easier (I think)
23:30:07 <ezyang> Yes, that seems quite likely; just look at MirageOS! 
23:30:22 <bollu> does every adjunction between f and g give a pairing f g?
23:30:40 * hvr is hoping to make http libraries replacable
23:30:43 <Axman6> would this be a good example usecase? AFAIR, at the moment anything that does networking in HaLVM needs to be written on top of the HaLVM networking libraries, so you can't really reuse code
23:31:20 <bollu> I think the answer is yes (adjunctions give pairings) but I'm not able to reason it out
23:31:43 <johnw> what do you mean by "pairing"?  Not every f is adjoint to every g
23:32:39 <bollu> johnw: no, I mean, given f is adjoint to g, we can always implement pairing:  (this pairing https://gist.github.com/queertypes/c1464518e554341bf578#file-freecofree-hs-L152)
23:32:40 <ezyang> Yes. The goal is that you could swap out the HaLVM library with a more conventional one 
23:32:41 <ezyang> then BOOM you have a userspace executable you can run 
23:33:00 <Axman6> have you spoken to anyone at Galois about this?
23:33:04 <ezyang> Not yet. 
23:33:20 <bollu> Axman6: Galois is writing backpack?
23:33:31 <Axman6> I'd be very curious to see how that conversation went =)
23:33:44 <Axman6> bollu: no, ezyang is, but galoid are writing HaLVM
23:34:16 <bollu> Axman6: hoooly crap, neat
23:34:18 <ezyang> I mean, it seems like an obviously good idea, but it probably doesn't make sense for HaLVM to do anything until they are moving onto newer GHC 
23:34:37 <bollu> Axman6: I'd applied for an internship at Galois last time. I got rejected at the last round. Applied again this year. It's like, dream company :)
23:37:08 <johnw> bollu: Pairing is also known as the Day convolution (https://hackage.haskell.org/package/contravariant-0.6.1.1/docs/Data-Functor-Day.html). See also https://bartoszmilewski.com/2016/01/.  That might give you more to search about.
23:37:45 <Axman6> ezyang: that's true I guess. might make a compelling reason to update though
23:38:05 <bollu> johnw: I see, thanks, lemme read up
23:38:44 * hackagebot markdown 0.1.15 - Convert Markdown to HTML, with XSS protection  https://hackage.haskell.org/package/markdown-0.1.15 (MichaelSnoyman)
23:38:46 * hackagebot fadno-braids 0.0.5 - Braid representations in Haskell  https://hackage.haskell.org/package/fadno-braids-0.0.5 (spopejoy)
23:38:47 <lush> hey! I try to use a library that I wrote within a new project with Stack. How do I make my other modules visible to my new Projects? 
23:38:48 * hackagebot parsec-free 3.1.11.6 - Parsec API encoded as a deeply-embedded DSL, for debugging and analysis  https://hackage.haskell.org/package/parsec-free-3.1.11.6 (JohnWiegley)
23:39:25 <Axman6> lush: you can specify paths in the stack.yaml file. check the stack docs
23:40:39 <hvr> ezyang: btw, I can imagine that backpack may help with bridging ghc/ghcjs/ghcjvm arch specifics
23:41:02 <Axman6> ezyang: in your blog post, you don't mention classes at all, though it seems like what you've implemented there could quite easily implemented using (lawless) classes
23:41:39 <bollu> johnw: "Groups were originally introduced in terms of actions on vector spaces" - based on G -> Aut(V) ?
23:41:45 <johnw> bollu: actually Pairing makes even the result of the function existential, which makes it looser than Day
23:41:53 <Axman6> I wouldn't mind seeing some information about why this is different/what the tradeoffs are
23:42:10 <bollu> johnw: what do you mean by that?
23:42:22 <ezyang> Axman6: This came up in the Reddit thread 
23:42:22 <johnw> Day f g a vs. Pairing f g
23:42:40 <ezyang> https://www.reddit.com/r/haskell/comments/56rkfl/try_backpack_ghc_backpack/d8m41dh 
23:42:52 <ezyang> Happy to debate more. To be clear, if you *can* use a type class, please do! 
23:42:59 <ezyang> Backpack is for the cases when you can't. 
23:44:44 <Axman6> ezyang: thanks, I'll take a look when I've got a bit more time.
23:44:59 <bollu> johnw: interesting, I finally found out what "lax" in "lax monoidal functor" means :)
23:47:48 <ezyang> Axman6: The short version is, sometimes you (1) have too many types for a type class to be convenient, (2) your types are ambiguous, (3) you need to parametrize over something other than a type, (4) need to compositionally grow your typeclass as you need more things, (5) want the perf to be as good as the non-typeclass thing 
23:49:21 <bollu> johnw: tried reading the thing on tambara modules. I understand all of them "separately", but, well, him bringing it together is mind bending
23:49:34 <bollu> johnw: I'll spend some more time on it
