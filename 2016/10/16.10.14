00:42:18 <susewu[m]> http://matrix.org/_matrix/media/v1/download/matrix.org/mnGWrjOYWWPVvxvdOTxluJYx - 我的第二個公告.jpg (169KB)
00:44:44 <Axman6> yeah I don't think I'm going to click that
00:48:06 <l_zzie> hey, I've been out of the loop for a while. did we ever decide on a network abstraction?
00:48:29 <Axman6> what do you mean?
00:49:10 <l_zzie> last time I was involved there were pipes / iteratees / some other stuff
00:49:15 <l_zzie> with protocol libraries written for each
00:49:23 <l_zzie> usually incomplete and not inter-compatible
00:49:48 <Axman6> pipes and conduit are the two main streaming libraries I guess
00:50:01 <l_zzie> is one a clear winner?
00:50:07 <Axman6> no
00:50:15 <Axman6> both have their pros and cons
00:50:21 <l_zzie> ok, that's what I was wondering. ty
00:50:45 <jerry[m]> Test
00:54:42 <susewu[m]> @jerry:matrix.org: test 
00:55:17 <Axman6> jerry[m]: susewu[m] please do not use this channel as an IRC testing ground.
00:56:39 <susewu[m]> copy that
00:59:14 <jerry[m]> Sorry
01:17:45 * int-e sighs... why would socat crash?
01:21:28 <pikajude> just got lazy, if it's like any other cat
01:24:12 <jophish> lyxia: it must be some pretty old code not to have Functor a superclass of Monad
01:24:49 <int-e> @botsnack
01:24:57 <lambdabot> :)
01:28:03 <ReinH> yay!
01:28:07 <ReinH> :t ()
01:28:15 <lambdabot> ()
01:28:18 <ReinH> yay!
01:28:39 <pikajude> :t (   :)
01:28:49 <lambdabot> a -> [a] -> [a]
01:28:58 <pikajude> it's totally a smiley face if you ignore half of it
01:29:22 <int-e> This may happen again, in which case I'll take the socat out and let lambdabot use plain text IRC again.
01:32:10 <fps> is there a way to tell 'stack new' a project name different from the directory name?
01:32:20 <fps> *package name
01:34:14 <puregreen> “stack new FooPackage --bare” will create a package in the current folder
01:34:20 <puregreen> without creating a FooPackage folder
01:34:25 <fps> puregreen: oh, cool, thanks
01:35:15 <int-e> Uh, well that certainly doesn't help: Sigaction(SIGSEGV, &act, NULL); (found in https://gitlab.labs.nic.cz/turris/openwrt-packages/blob/08f637ce32f1638df50f512b5563127e76050dc0/net/socat/patches/502-infinite-segfault.patch)
01:37:29 <int-e> (The socat child was hanging in an infinite loop, and this explains why. Anyway, I guess this is not really a #haskell topic even though it affected lambdabot.)
01:39:30 <ongy> int-e: why does lambdabot need a child? I would asume it does network stuff in the process
01:40:29 <int-e> ongy: The socat is in there for connecting through SSL, which lambdabot doesn't support by itself.
01:42:03 <int-e> ongy: and it's not a child of lambdabot anyway... there's a main socat process that forks a child that handles each connection. Let's pretend I never wrote "child" there ;-)
01:43:15 <ongy> sounds rather terrible to me. But I guess there's a good reason for it
01:44:32 <elliptic00> Hi, anyone know how to use shell(bash) environment variables in GHCI console?
01:45:01 <elliptic00> I try to :cd $mypath, it does't work
01:45:24 <ongy> elliptic00: https://hackage.haskell.org/package/base-4.9.0.0/docs/System-Environment.html#v:getEnv
01:49:42 <fps> hmm, what are best practices in stack projects? should the library just be named "Lib"? seems awfully generic "_
01:49:44 <fps> :)
01:54:38 <ReinH> Same as other Haskell projects.
01:54:42 <ReinH> Look on hackage for examples
01:54:52 <ReinH> Lib is never the best name for a module.
01:55:14 <ReinH> But it's generated example code, of course it's generic.
01:55:40 <fps> that's what i thought. i'm a haskell newb, so i wondered if there was some extra magic namespace around it so the resulting module in the end would be like project-name.Lib or similar, which woulde make a little more sense :)
01:55:51 <fps> i changed it to a more descriptive name now..
02:05:55 <lyxia> jophish: It was to submit a PR to a library that compiles with old GHC. Since I don't feel like installing one locally I have to wait for travis to complain.
02:13:32 <ENN13> efnet news epsiode 13 https://youtu.be/gvX41zoyBy0 <- give it a listen before it gets removed ! Brought to you by Jason Bandy.
02:25:32 <chpatrick> is there a library that provides Eq2, Show2, Show3, ShowN... with TH?
02:27:36 <lyxia> Oh hello chpatrick o/  I don't know the answer to your question though.
02:34:22 <chpatrick> o/
02:40:53 <jophish> chpatrick: https://hackage.haskell.org/package/deriving-compat-0.3.3/docs/Data-Eq-Deriving.html
02:41:06 <jophish> oh, you want ShowN
02:43:35 <kuribas> What's a good place to ask for contributors?
02:44:11 <srhb> Here and the subreddit?
02:44:55 <kuribas> ok :)
02:45:34 <kuribas> contributors welcome https://github.com/kuribas/haskell-truetype
02:47:11 <kuribas> The intersection of typography and haskell enthousiasts seems pretty small.
02:47:29 <kuribas> I guess most people are font-users, not font-makers.
02:48:10 * hackagebot servant-db 0.2.0.0 - Servant types for defining API with relational DBs  https://hackage.haskell.org/package/servant-db-0.2.0.0 (NCrashed)
02:48:12 * hackagebot servant-db-postgresql 0.2.0.0 - Derive a postgres client to database API specified by servant-db  https://hackage.haskell.org/package/servant-db-postgresql-0.2.0.0 (NCrashed)
02:50:21 <jophish> kuribas: is it similar to fontyfruity?
02:50:59 <kuribas> fontyfruity is concerned with reading fonts, my library with reading/writing.
02:51:10 <jophish> gotcha
02:51:49 <kuribas> Actually writing in the first place.
02:52:09 <kuribas> But could be useful for doing things like changing fonts, interpolating, etc...
02:52:43 <kuribas> Or changing coding, ...
02:58:53 <puregreen> what's the abbreviation for “constraint”?
02:59:37 <puregreen> (or not quite an abbreviation, but something like “cxt” – context, “tyvar” – type variable)
03:01:32 <ENN13> efnet news epsiode 13 https://youtu.be/gvX41zoyBy0 <- give it a listen before it gets removed ! Brought to you by Jason Bandy.
03:04:01 <Axman6> @where ops
03:04:01 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
03:04:22 <Axman6> second time ENN13 has been in here spamming
03:04:54 <M2tias> what's with it?
03:38:53 <ocramz> there
03:38:56 <ocramz> hi
03:39:26 <ocramz> Is there a process for transferring maintainership of a package? I wrote to haskell-cafe hoping someone will pick it up
03:40:24 <puregreen> ocramz: well, once somebody picks it up you just add them to the maintainers group on Hackage, I think
03:40:32 <puregreen> (what package, by the way?)
03:40:51 <ocramz> network-multicast
03:41:06 <yulax> hi folks
03:41:22 <yulax> i am trying to re-implement the splitAt function.
03:42:03 <puregreen> ocramz: here's the link where you'll be able to add the new maintainer: http://hackage.haskell.org/package/network-multicast/maintainers/edit
03:42:39 <ocramz> puregreen: thanks, but in fact I'm the one who should be added; the current maint doesn't have time for it anymore
03:42:53 <yulax> https://paste.debian.net/875301/
03:43:13 <puregreen> ahhh, I thought “hoping someone will pick it up” meant that you wanted to transfer maintainership of *your* package
03:43:31 <ocramz> yeah sorry, the other way around :)
03:43:46 <puregreen> https://wiki.haskell.org/Taking_over_a_package
03:44:17 <yulax> i get some funny types; zip appears to return `[(a, a)]' as opposed to the desired `([a],[a])'
03:44:41 <yulax> i am looking for some hints as to what i could do instead
03:45:22 <ocramz> > :t zip
03:45:25 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
03:45:32 <ocramz> uh
03:45:32 <puregreen> :t zip
03:45:35 <lambdabot> [a] -> [b] -> [(a, b)]
03:46:05 <lyxia> :t unzip -- yulax?
03:46:08 <lambdabot> [(a, b)] -> ([a], [b])
03:46:41 <lyxia> You don't want to use zip here though
03:46:44 <lyxia> just (,)
03:47:03 <kuribas> yulax: defining in terms of take/drop is a bit cheating.  Try defining it recursively :)
03:47:30 <yulax> right will do
03:48:12 * hackagebot live-sequencer 0.0.5 - Live coding of MIDI music  https://hackage.haskell.org/package/live-sequencer-0.0.5 (HenningThielemann)
03:48:14 * hackagebot servant-db 0.2.0.1 - Servant types for defining API with relational DBs  https://hackage.haskell.org/package/servant-db-0.2.0.1 (NCrashed)
03:48:16 * hackagebot live-sequencer 0.0.5.1 - Live coding of MIDI music  https://hackage.haskell.org/package/live-sequencer-0.0.5.1 (HenningThielemann)
03:48:18 * hackagebot servant-db-postgresql 0.2.0.1 - Derive a postgres client to database API specified by servant-db  https://hackage.haskell.org/package/servant-db-postgresql-0.2.0.1 (NCrashed)
03:48:41 <yulax> #==#
03:49:00 <yulax> ##########
03:49:04 <yulax> sorry
03:59:48 <paul0> hi
03:59:52 <ocramz> hi paul0
04:00:09 <paul0> how can I define a field called "type" for a new data?
04:00:19 <ocramz> you can't :D
04:00:25 <ocramz> get creative
04:00:41 <paul0> I need to parse a JSON, and it has a "type" field
04:01:09 <paul0> but "type :: Text" doesn't work
04:01:56 <lyxia> Give it a non-keyword name.
04:02:19 <paul0> http://pastebin.com/raw/5fyBz3nv
04:02:36 <MrElendig> and please use a sane pastebin like ptpb, bpaste, gist
04:02:55 <ocramz> @paste
04:02:55 <lambdabot> Haskell pastebin: http://lpaste.net/
04:03:11 <paul0> sure
04:03:53 <paul0> lyxia: how this non-keyword name works?
04:03:54 <lyxia> paul0: modify the Options argument of the generic JSON decoder.
04:04:06 <paul0> lyxia: how? I'm new to haskell
04:04:16 <lyxia> paul0: the problem with your definition is that "type" is a keyword.
04:04:21 <lyxia> so you give it another name.
04:04:28 <lyxia> lemme write something
04:04:30 <paul0> but the field name is "type"
04:10:24 <Xnuk> type'
04:12:21 <paul0> http://lpaste.net/258978
04:12:26 <paul0> seems to be working now
04:12:39 <paul0> Xnuk: I used "_type", I guess it has the same effect
04:13:27 <lpaste> lyxia pasted “paul0” at http://lpaste.net/258979
04:13:59 <lyxia> oh, does it drop the underscore when you encode it?
04:14:38 <paul0> lyxia: no, the output is: Trade {date = 1476442377, price = 2103.9, amount = 6.66228e-3, tid = 325941, _type = "buy"}
04:15:12 <lyxia> that's not a JSON encoding.
04:15:51 <paul0> just decoded this from a json source
04:16:05 <lyxia> encode it back
04:16:14 <paul0> lol
04:16:40 <lyxia> you will get {..., "_type" : "buy"}
04:16:53 <lyxia> but I guess if you're just parsing that works...
04:18:52 <paul0> lyxia: http://lpaste.net/258980
04:19:04 <dramforever> Question: I don't quite get type signatures like this: (Something a => b) -> b. What do they mean?
04:19:29 <dramforever> (More generally, what does it mean to have a constraint *not* accompanying the (maybe implicit) forall?)
04:19:53 <ertes> dramforever: the argument to that function is a value of type 'b' that receives an extra piece of knowledge: that another type 'a' is a Something, so you can use the Something interface on values of type 'a'
04:20:39 <ertes> (to express the value of type 'b' that is)
04:21:00 <dramforever> yeah you are totally right, constraints are like arguments
04:21:17 <paul0> lyxia: thanks for your help, I was stuck in this for months, today I decided to come here to ask for help :)
04:21:21 <paul0> haskell is not for newbies heh
04:22:57 <ocramz> paul0 we all start as newbies
04:23:07 <ocramz> ^ platitude right there
04:23:15 <ertes> dramforever: yeah, with the difference that you don't get to pass them explicitly…  argument selection is done by instance resolution
04:24:18 <ertes> dramforever: (with one useful exception: equality constraints)
04:24:43 * dramforever sees that it's nothing too special but still got confused
04:26:15 <dramforever> ertes: So what about this: What's a good motivating example?
04:26:57 <ertes> dramforever: i can't think of a good example for class constraints, but for equality constraints:  CPSed GADTs
04:27:29 <ertes> non-CPSed:  data MyType :: * -> * where MyInt :: Int -> MyType Int; MyString :: String -> MyType String
04:27:59 <dramforever> CPSed GADTs with class constraints can be a thing, you know
04:28:26 <ertes> CPSed:  newtype MyType a = MyType { fromMyType :: forall r. ((a ~ Int) => Int -> r) -> ((a ~ String) => String -> r) -> r }
04:29:00 <ertes> yeah, i just never found myself using a non-existential with a constructor-specific constraint
04:29:09 <ertes> it may be useful, but it hasn't been for me
04:29:10 <dramforever> Great example!
04:31:08 <dramforever> Actually, I'm thinking maybe that explains the signature Integer -> (KnownNat n => a) -> a
04:31:36 <ertes> hmm?  looks like there should be a 'forall' and a proxy
04:32:01 <ertes> you may be interested in the reflection library for a more generic version of that pattern
04:32:41 <dramforever> yes yes yes that's about what I was talking about
04:32:57 <dramforever> Like http://hackage.haskell.org/package/reflection-2.1.2/docs/Data-Reflection.html#v:give
04:33:40 <ertes> ah, that's why the lack of forall is weird
04:33:44 <ertes> it's because Given is weird =)
04:33:45 <dramforever> but reflection is a piece of ekmett magic I daren't touch for now :P
04:33:48 <ertes> better don't use it
04:34:55 <ertes> reflection is actually pretty straightforward:  you use 'reify' to lift a value to a type, then you use 'reflect' to get the value back from the type
04:36:02 <ertes> reify x (\(_ :: Proxy n) -> …)  -- within that lambda the type 'n' represents the value 'x' in the sense that (reflect (Proxy :: Proxy n)) will return x
04:37:32 <dramforever> I understand it as something like passing values as constraints
04:37:57 <fred-fri> http://pastebin.com/U4Q10Xrp the final line doesn't work because the ints are inside maybes, what the most idiomatic way of adding them?
04:38:19 <ertes> dramforever: it's literally just constructing a type that is in one-to-one correspondence to a certain value
04:38:33 <dramforever> uh, yeah
04:38:46 <dramforever> That's all I have to say, actually
04:38:52 <mettekou> :t liftA2
04:38:53 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:39:05 <mettekou> fred-fri: That is an option.
04:39:34 <mettekou> :t liftA2 (+) (Just 5) Nothing
04:39:36 <lambdabot> Num c => Maybe c
04:39:48 <dramforever> Another option is just check n once
04:40:09 <ertes> dramforever: there are some values that are type-bound, and reflection allows you to accomplish that…  simple example: the modulus in modular arithmetic
04:40:24 <ertes> dramforever: (+) :: (Reifies n Integer) => Mod n -> Mod n -> Mod n
04:40:25 <dramforever> if n < 1 then Nothing else Just (an unchecked loop)
04:41:50 <dramforever> ertes: That's amazing actually, let me think a bit
04:42:05 <ertes> dramforever: the reason you would want the modulus to be a *type* argument (rather than a field) in this case is that it should really be the same for both arguments and the result
04:42:11 <ertes> the modulus is inherently type-bound
04:42:19 <ertes> newtype Mod n = Mod { residue :: Integer }
04:42:35 <dramforever> same could go for vector/matrix dimensions
04:42:41 <ertes> yeah, exactly
04:43:05 <fred-fri> mettekou, im afraid im too noob to understand what the line would actually look like, would you mind spelling it out?
04:43:13 <ertes> Linear.V from the 'vector' library does exactly that actually
04:43:28 <dramforever> liftA2 (+) (nthFibo (n-1)) (nthFibo (n-2))
04:43:45 <mettekou> fred-fri dramforever: Indeed.
04:44:21 <ertes> fred-fri: review the type of liftA2:  (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
04:44:37 <ertes> fred-fri: now replace 'f' by Maybe:  (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c
04:44:44 <dramforever> ertes: excuse me, but, huh?
04:44:44 <ertes> fred-fri: does that make a bit more sense?
04:45:18 <fred-fri> my brain
04:45:19 <ertes> dramforever: https://hackage.haskell.org/package/linear-1.20.5/docs/Linear-V.html
04:45:24 <fred-fri> but yes
04:45:33 <ertes> fred-fri: does 'fmap' for Maybe make sense?
04:45:48 <ertes> fmap :: (a -> b) -> Maybe a -> Maybe b
04:45:50 <dramforever> oh you didn't mean mean the 'vector' package. Thanks I'm looking
04:46:00 <ertes> dramforever: oh, sorry…  my bad
04:46:05 <fred-fri> yeah i understand how if i had a single maybe int if i fmapped an addition eg of 1 it would increase the int inside the maybe or it would do nothing
04:46:24 <ertes> fred-fri: you may think of fmap as liftA1
04:46:37 <fred-fri> i see
04:46:59 <dramforever> and this time if you have two 'Just's it will add them together, otherwise it's Nothing
04:47:08 <fred-fri> cool
04:47:51 <fred-fri> but gais. isnt it better to imperatively null check both values and return null or the added value? trololol
04:48:13 * hackagebot yesod-static 1.5.0.5 - Static file serving subsite for Yesod Web Framework.  https://hackage.haskell.org/package/yesod-static-1.5.0.5 (MichaelSnoyman)
04:48:15 * hackagebot network-multicast 0.1.2 - Simple multicast library  https://hackage.haskell.org/package/network-multicast-0.1.2 (ocramz)
04:48:21 <dramforever> define 'better' and we'll try to answer
04:48:29 <fred-fri> "worse"
04:48:51 <ertes> :t \mx my -> if mx /= Nothing then (if my /= Nothing then Just (fromJust mx + fromJust my) else Nothing) else Nothing
04:48:53 <lambdabot> (Num a, Eq a) => Maybe a -> Maybe a -> Maybe a
04:48:57 <dramforever> then yes, null checker *is* better (a.k.a worse)
04:49:17 <ertes> :t liftA2 (+)
04:49:19 <lambdabot> (Applicative f, Num c) => f c -> f c -> f c
04:49:19 <fred-fri> coming from java, i just started with haskell and im already appreciating it
04:49:41 <ertes> fred-fri: the liftA2 variant is better…  because it has less constraints on the type =)
04:50:55 <dramforever> and it goes back to this problem in the code: the very fact that you *need* to check for 'Nothing's
04:51:28 <ertes> ok, i was just counter-trolling, but more seriously: use liftA2, if only for the profound experience of figuring out that 'f' doesn't need to be Maybe =)
04:51:43 <ertes> > liftA2 (+) [1,2,3] [10,20,30]
04:51:46 <lambdabot>  [11,21,31,12,22,32,13,23,33]
04:51:51 <fred-fri> mind blown
04:51:56 <dramforever> Wait a bit, I'll try to give a better fibo (for some other definition of 'better')
04:54:36 <lpaste> dramforever pasted “fibo” at http://lpaste.net/259004
04:54:54 <dramforever> fred-fri: ^ I would prefer this
04:55:08 <fred-fri> what does go mean
04:55:20 <ertes> fred-fri: 'go' is explained in the code
04:55:26 <ertes> look for "go ="
04:55:36 <ertes> or rather "go … ="
04:56:18 <fred-fri> cheers
04:56:39 <dramforever> oh yeah maybe you haven't learned about that yet
04:56:43 <dramforever> got it now?
04:58:10 <dramforever> Actually, did you know that you can literally write this: ?
04:58:11 <dramforever> go 1 = 1
04:58:13 <dramforever> go 2 = 1
04:58:20 <ertes> (they're gone)
04:58:27 <dramforever> Ah
04:58:40 <dramforever> my bad for disabling join/quit messages
04:59:14 <ertes> ERC has this nice feature that displays join/part/quit only for people who have been active recently =)
04:59:36 <ocramz> I'm using ERC as well
04:59:48 <ocramz> emacs ftw
05:00:58 <ocramz> can someone explain me the semantics of MonadPlus? can we use it e.g. to run an action recursively and return on failure?
05:01:38 <ertes> ocramz: are you defining a monad or using one?
05:01:51 <ocramz> I'm working with MonadState
05:02:07 <ertes> StateT by itself is not an Alternative/MonadPlus
05:02:19 <ocramz> I was wondering whether I can break a cycle earlier using a test predicate
05:02:23 <ocramz> using typeclasses
05:02:39 <ertes> you can, but your monad has to support it
05:03:03 <dramforever> Sounds more like MonadError to me
05:03:05 <ocramz> I see only Maybe, [] and IO have MonadPlus instances in base
05:03:08 <dramforever> :t catchError
05:03:10 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
05:03:15 <dramforever> :t throwError
05:03:17 <lambdabot> MonadError e m => e -> m a
05:03:19 <ocramz> dramforever: no, it's not an error, rather a convergence condition check
05:03:38 <ertes> ocramz: do you want to "fail" or short-circuit with a value?
05:03:41 <dramforever> exception as control flow?
05:03:55 <ocramz> ertes: the latter
05:03:57 <dramforever> Do you mean something else?
05:04:12 <dramforever> hmm
05:04:28 <ertes> ocramz: i've used ContT for that, but most of the time i'd consider that an abuse
05:04:31 <ocramz> I'd like a `runStateUntil`
05:04:51 <ertes> :t ContT . const . pure
05:04:52 <lambdabot> Applicative m => r -> ContT r m a
05:05:06 <ertes> you could call that function 'abort' or 'exit'
05:05:17 <ocramz> uhm
05:05:30 <dramforever> uhm
05:05:46 <ocramz> I have to meditate on this. Thanks ertes
05:07:16 <ertes> @let abort = ContT . const . pure
05:07:18 <lambdabot>  Defined.
05:08:11 <ertes> > flip evalState 0 . flip runContT return . forever $ do x <- get; if x < 10 then modify (1 +) else abort x
05:08:13 <lambdabot>  10
05:08:36 <ertes> 'abort' breaks out of the 'forever' using a continuation effect
05:09:06 <ocramz> I'll turn into pointful first ^_^
05:09:35 <ertes> abort result = ContT (\k -> pure result)  -- ignore the continuation 'k' and just return
05:10:08 <ocramz> yep, starts making sense now
05:13:47 <ertes> :t \x0 -> ContT (\k -> let again x = ContT (\_ -> k (again, x)) in k (again, x0))
05:13:49 <lambdabot> forall k (r :: k) (m :: k -> *) a t. t -> ContT r m (t -> ContT r m a, t)
05:14:00 <ertes> @let label x0 = ContT (\k -> let again x = ContT (\_ -> k (again, x)) in k (again, x0))
05:14:01 <lambdabot>  Defined.
05:14:13 <ertes> @let goto = id
05:14:15 <lambdabot>  Defined.
05:14:46 <ertes> > flip runCont id $ do (blah, x) <- label 0; if x < 10 then goto blah (x + 1) else return x
05:14:48 <lambdabot>  error:
05:14:48 <lambdabot>      Ambiguous occurrence ‘label’
05:14:48 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.label’,
05:14:53 <ertes> d'oh
05:15:02 <ertes> @let label_ x0 = ContT (\k -> let again x = ContT (\_ -> k (again, x)) in k (again, x0))
05:15:03 <lambdabot>  Defined.
05:15:06 <ertes> > flip runCont id $ do (blah, x) <- label 0; if x < 10 then goto blah (x + 1) else return x
05:15:08 <lambdabot>  error:
05:15:08 <lambdabot>      Ambiguous occurrence ‘label’
05:15:08 <lambdabot>      It could refer to either ‘Lambdabot.Plugin.Haskell.Eval.Trusted.label’,
05:15:16 <ertes> > flip runCont id $ do (blah, x) <- label_ 0; if x < 10 then goto blah (x + 1) else return x
05:15:17 <lambdabot>  10
05:15:25 <anonymous_boon_x> hey
05:15:36 <ocramz> ertes: yep
05:15:39 <dramforever> mindblown, confirmed
05:15:57 <ocramz> dramforever: all day every day, with this language.
05:16:36 <ertes> but that's all ContT really is:  a super-fancy goto =)
05:16:49 <ertes> GotoT =)
05:16:53 <ocramz> a less-arbitrary goto
05:17:13 <anonymous_boon_x> i have a question, how can I hack something, but stay anonym?
05:17:20 <dramforever> A monad transformer that allows you to take control flow in your own hands, I suppose
05:17:34 <ocramz> anonymous_boon_x : wat
05:18:37 <ertes> anonymous_boon_x: this is #haskell (read that name carefully, you probably misread it first)
05:18:53 <anonymous_boon_x> so that nobody /leave
05:21:00 <tabaqui> is there a function that can easy convert int to bool list
05:21:11 <tabaqui> like 000101 = [False False False True False True]
05:21:17 <tabaqui> ?
05:21:35 <ertes> tabaqui: no predefined one, but you can easily write it in terms of 'unfoldr' and Data.Bits
05:22:26 <tabaqui> ertes: ah, unfoldr
05:22:35 <tabaqui> never heard about it, thanks
05:33:55 <ocramz> ertes: the function you suggested has this signature: evalStateUntil
05:33:56 <ocramz>   :: (c -> Bool)
05:33:56 <ocramz>      -> ContT c (StateT c Data.Functor.Identity.Identity) a -> c -> c
05:34:21 <ocramz> is (StateT c Identity) equal to (State c) ?
05:34:29 <lyxia> yes
05:35:36 <ocramz> lyxia: k, thanks
05:42:56 <ertes> ocramz: i…  wouldn't really write an extra function for that
05:44:58 <ertes> ocramz: in fact i would keep my use of ContT as local as possible…  if you need it only inside one loop of an otherwise larger State, you can just runContT somewhere inside it
05:45:30 <hpc> indeed
05:45:43 <ab9rf> please hide all ugly monads :)
05:45:45 <hpc> while not exactly the same, ContT has a lot of the same "control flow is now complicated" issues as goto
05:45:51 <ertes> ocramz: like that:  runState (do …; runContT myAbortableAction return; …) s0
05:46:01 <hpc> and tightly scoping it keeps you from going crazy further down the line
05:46:29 <ab9rf> "Abuse of the Continuation monad can produce code that is impossible to understand and maintain."
05:47:26 <hpc> well nothing's impossible to understand and maintain
05:47:39 <hpc> at the very worst, you figure out what you wanted it to do and start over with something simpler :P
05:48:42 <ertes> hpc: trying to learn TYPO3 really challenges that notion =)
05:49:12 <hpc> oh, that's easy
05:49:15 <hpc> just start over with drupal
05:49:29 <ertes> sure, it's PHP, so you don't expect it to be easy in the first place, but it shows you just how bad things can get =)
05:49:31 <hpc> (and then when drupal is unmaintainable, start over with joomla, and then start over with wordpress, and then start over with ...)
05:49:50 <hpc> you're talking to the author of acme-php :P
05:49:55 <hpc> i know how bad it gets
05:49:59 <ertes> hehe
05:51:56 <sm> morning
05:54:19 <sm> I guess that test was successful.. the first conduit in https://haskell-lang.org/library/conduit ran in a constant 150M, while main = print $ sum [1..10e7] ate all 8G and unrecoverably froze my mac, requiring a power off
05:54:45 <ab9rf> heh
05:57:15 <hpc> it's kind of unfortunate that sum/product don't have nice performance characteristics for that use case
05:58:46 <sm> also it makes me wonder what happened to our 60 years of work on memory management..
05:59:30 <ahihi> does that happen even with -O2?
05:59:51 <sm> probably not, I was about to try that but.. :)
06:06:08 <ertes> {-# HISTORY_WARNING sum This function is stupid. Do not use it. #-}
06:06:44 <sm> ahihi: yes, it does
06:07:11 <ertes> sm: use foldl' (+) 0
06:07:44 <ertes> for some reason sum is defined in terms of foldl and was never fixed
06:08:05 <StoneToad> o_O
06:09:48 <athan> ertes: Holy tamole, still?! I thought it was foldl' or something
06:09:51 <athan> or used the monoid
06:09:53 <kuribas`> > Vector.sum $ Vector.enumFromN 0 10e7
06:09:55 <lambdabot>  error:
06:09:55 <lambdabot>      Not in scope: ‘Vector.sum’
06:09:55 <lambdabot>      No module named ‘Vector’ is imported.error:
06:09:58 <sm> isn't the OS supposed to kill off misbehaving programs ? disappointed by OSX here
06:10:00 <opqdonut> -O2 fixes sum
06:10:11 <opqdonut> or at least used to when I last tried it
06:10:14 <kuribas`> > import Data.Vector
06:10:17 <lambdabot>  <hint>:1:1: error: parse error on input ‘import’
06:10:27 <kuribas`> > Data.Vector.sum $ Data.Vector.enumFromN 0 10e7
06:10:28 <ertes> i wouldn't rely on it
06:10:31 <lambdabot>  error:
06:10:31 <lambdabot>      Not in scope: ‘Data.Vector.sum’
06:10:31 <lambdabot>      No module named ‘Data.Vector’ is imported.error:
06:10:35 <athan> sm: It can be hard to bound the consumable memory / scheduable cpu usage of a process in my experience
06:10:45 <athan> SIGKILL is always in my trigger hand
06:10:58 <ertes> sm: you can start your program with +RTS -M512m or something like that to get a safeguard
06:12:09 <ertes> sm: you can also export the environment variable GHCRTS=-M512m to apply it to all haskell programs, but keep in mind that it then also applies to most dev/build tools
06:13:50 <sm> ertes: good tips
06:16:13 <athan> :O ertes++
06:16:59 <kuribas`> sm: http://lpaste.net/259029 runs in 1.5 sec on my machine
06:17:25 <kuribas`> sm: vector has better fusion rules than list.
06:18:50 <ab9rf> sm: likely osx has stupid default limits for the interactive user
06:20:04 <ab9rf> if you do that on a linux box and have memory unlimited, the OS out-of-memory killer will start nuking stuff at semi-random.
06:20:15 <kuribas`> sm: with foldl' on list it runs 0.3 seconds slower.
06:20:27 <ab9rf> if yuo have a process memory limit, though, that limit will prevet you from htting the OOM killer
06:22:45 <ertes> in other words:  linux sucks just as much as OS X when it comes to edge cases =)
06:23:59 <JuanDaugherty> except for the thing with the bosses
06:26:24 <kuribas`> why do I get Not in scope: ‘getInt16be’
06:26:44 <kuribas`> I have "import Data.Binary.Get"
06:27:20 <sm> when built with ghc 8 rather than ghc 7, osx seems to handle it better - the system stays responsive while swapping
06:27:50 <kuribas`> doesn't make any sense...
06:28:44 <puregreen> kuribas`: maybe you use older binary?
06:29:29 <kuribas`> puregreen: I have Build-depends: base >= 3 && < 5, binary >= 0.8.4.0, bytestring > 0.10.0, containers >= 0.5.3, ghc >= 7.8.3, time > 1.4.0, vector >= 0.10
06:30:09 <puregreen> okay, then it's weird
06:30:26 <ab9rf> ertes: esepcially if you run big memroy sucking processes as the root user, the oom killer doesn't know which one to kill. although i think in that cases it makes a weighted random seleciton based on the pricess size, so if it's one runaway, the runaway is the ont that gets murdered
06:30:28 <puregreen> no idea, sorry
06:33:23 <kuribas`> puregreen: yeah, really weird...
06:38:08 <ertes> ab9rf: i don't think the OOM killer has *ever* done the right thing for me
06:39:29 <ertes> usually when my system starts swapping during development i instinctively start holding alt+sysrq, in most cases followed by B
06:40:02 <ertes> in some rare cases SAK (alt+sysrq+K) rescues it
06:41:07 <Benzi-Junior> I haven't been able to find anything like this yet but, is there a library of conversion functions for the word types 
06:41:25 <ertes> Benzi-Junior: fromIntegral?
06:42:40 <Benzi-Junior> ertes: if I have 4 word8 and want to concatenate them to make a word 32
06:42:51 <ertes> ab9rf: ironically haskell programs that go mad should be super-easy to detect, because they are not only using the most memory, allocating at the highest pace, but they even use the most virtual memory (they use the entire address space, which most other programs don't do)
06:43:14 <ertes> Benzi-Junior: ah, you have to do that manually, e.g. by using Data.Bits
06:43:37 <Benzi-Junior> ok thanks
06:43:39 <ertes> Benzi-Junior: fromIntegral x0 .|. shiftL (fromIntegral x1) 8 .|. …
06:45:05 <Benzi-Junior> ertes: mmm sounds like such an efficient way of going about that
06:45:12 <lpaste> kuribas pasted “not in scope getInt16be” at http://lpaste.net/259043
06:45:24 <sm> kuribas: your vector example is about 5 times quicker than the conduit 
06:45:46 <kuribas> Can anyone spot the error?  http://lpaste.net/259043
06:46:03 <pchiusano> question was the 'Mio' IO manager improvements folded into GHC at some point? http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
06:46:41 <kuribas> sm: yeah, it generates a single loop using vector fusion.
06:48:03 <sm> kuribas: is Data.Binary.Get definitely coming from the binary package ? you could :i in ghci
06:48:16 * hackagebot vgrep 0.1.3.0 - A pager for grep  https://hackage.haskell.org/package/vgrep-0.1.3.0 (fmthoma)
06:48:41 <sm> and is it definitely a recent version ?[stack/cabal exec --] ghc-pkg list binary
06:51:29 <kuribas> hm... /usr/local/bin/ghc --make [...] -package-id binary-0.7.1.0-783c7cab22399c29ff765faff74c6ab [..]
06:51:41 <sm> ha
06:52:46 <sm> ertes: re super-easy.. yes it's pretty damn obvious to a user watching activity monitor or top which process should be killed :)
06:53:16 <tabaqui> what's the difference between aeson and json package?
06:53:17 <kuribas> I DID specify binary >= 0.8.4.0
06:53:35 <sm> kuribas: in all sections of the cabal file ?
06:53:54 <kuribas> there is just one section
06:55:12 <kuribas> "Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure."
06:55:12 <kuribas>  
06:55:19 <puregreen> tabaqui: json is outdated, uses less efficient types, has less instances
06:56:02 <kuribas> "package bin-package-db-0.0.0.0 requires binary-0.7.1.0"
06:56:05 <kuribas> what is this??
06:56:18 <sm> kuribas: sounds like you need a fresh sandbox/better build plan
06:56:54 <tabaqui> puregreen: it's unstable? or slow?
06:56:56 <sm> or newer ghc version perhaps
06:57:18 <puregreen> tabaqui: slow
06:57:48 <tabaqui> puregreen: ok, i'll use aeson then
06:57:51 <puregreen> tabaqui: aeson is the defacto JSON parsing library in Haskell, choosing it over json is pretty much a non-brainer
06:57:52 <tabaqui> puregreen: thx
06:59:47 <kuribas> what is bin-package-db?
06:59:53 <kuribas> why does my package require it?
07:06:48 <kuribas> shitty haskell package management.
07:07:26 <sm> kuribas: I guess it's a GHC thing. The main thing is to avoid that warning you got. Are you using stack ? a cabal sandbox ?
07:07:38 <kuribas> no and no
07:07:57 <kuribas> does stack solve these issues?
07:09:16 <sm> kuribas: yes I believe so
07:12:03 <kuribas> sm, hm, it seems ghc doesn't support the new binary
07:13:29 <sm> kuribas: ghc 7.8 is too old for the current tools
07:14:21 <sm> https://haskell-lang.org/get-started is an easy way to get newer stuff
07:48:18 * hackagebot shellmate 0.3.4 - Simple interface for shell scripting in Haskell.  https://hackage.haskell.org/package/shellmate-0.3.4 (AntonEkblad)
07:48:20 * hackagebot shellmate-extras 0.3.4 - Extra functionality for shellmate.  https://hackage.haskell.org/package/shellmate-extras-0.3.4 (AntonEkblad)
07:48:48 <danilo2> Hello guys! Is there any standard operator in haskell which works like >>= but returns the result of first computation, not the second one ?
07:49:26 <Rembane_> danilo2: Are you searching for =<< ?
07:50:53 <danilo2> Rembane_: no, I'm looking for equivalent of something like f >>== g, where >>== would be defined as (>>==) f g = do {fv <- f; g fv; return fv}
07:52:48 <Rembane_> danilo2: Does it need to be on the Monad typeclass or will the Applicative do?
07:52:58 <Rembane_> danilo2: 'cause I think <* might do what you want
07:53:28 <danilo2> Rembane_: no, <* does not passes arguments between one evaluation and the other
07:53:47 <danilo2> look at its type, te type determines its monad
07:54:40 <amx> danilo2: wouldn't your (>>==) only make sense in IO?
07:54:44 <sm> kuribas: any luck ?
07:55:03 <kuribas> sm, still compiling ghc ...
07:55:13 <kuribas> sm: I'll let you know tomorrow :)
07:55:14 <danilo2> amx: no, why? In any State'like monad it makes perfect sense
07:55:29 <amx> right
07:56:16 <sm> kuribas: I guess you want to compile everything yourself, or you're on an unusual platform, eh
07:56:24 <kuribas> linux mint
07:56:53 <kuribas> the one from the distro is very old
07:56:59 <tabaqui> how can i manually parse json list?
07:57:04 <Rembane_> danilo2: Then I'm at a loss.
07:57:04 <sm> that's debian-based, right
07:57:05 <tabaqui> i cannot found function like .:
07:57:21 <tabaqui> so i need Foo 1 "abs" from [1, "abs"]
07:57:25 <ski> s/State'like/non-commutative/
07:57:33 <sm> wouldn't https://docs.haskellstack.org/en/stable/install_and_upgrade/#linux work
08:05:25 <cocreature> kuribas: if you are on mint you can probably use hvr’s excellent ppa https://launchpad.net/~hvr/+archive/ubuntu/ghc which includes about all the ghc versions you could want
08:05:53 <kuribas> cocreature: nice, thanks!
08:06:40 <jophish> kuribas: the nix package manager is also an option, the learning curve is much steeper than using a ppa however
08:06:41 <sm> that's another way to get ghc, but kuribas needs stack more I think
08:08:28 <sm> unless it is stack that's choosing to compile ghc on mint
08:08:42 <tabaqui> ah, fine, i've found
08:15:36 <place> I'm new to Haskell (and programming in general) and don't understand some of my code. Is it okay if I paste it here?
08:15:54 <phadej> place: use e.g. http://lpaste.net/
08:17:02 <phadej> freenode has quite tight spam limits :)
08:17:19 <place> Thank you
08:17:27 <place> So I'm writing a rudimentary note program
08:17:29 <place> http://lpaste.net/6577030965376319488
08:17:32 <place> Here's the question
08:17:48 <tabaqui> is there alike curry function but with more fields in result
08:17:52 <tabaqui> ?
08:18:08 <place> editTitle with m => length list returns Nothing even though:
08:18:11 <place> getNote m list = Nothing
08:18:14 <place> Just (_, c) doesn't match Nothing
08:18:18 <tabaqui> like curry3 :: (a -> b -> c -> d) -> (a, b, c) -> d
08:18:18 <place> replace is called with content that doesn't exist
08:18:24 <place> How is that possible?
08:19:04 <phadej> tabaqui: that would be uncurry3
08:19:40 <phadej> tabaqui: utility-ht looks promising, https://www.stackage.org/lts-7.3/hoogle?q=uncurry3
08:20:26 <phadej> place: compile with `-Wall` and compiler will tell you!
08:20:55 <tabaqui> phadej: well, it has curry3, but actually i need curry5)
08:20:59 <phadej> (spoiler: indeed it doesn't match, it's not exhaustive)
08:21:47 <tabaqui> phadej: hm, it has a very simple implementation, i could just copy it
08:21:57 <phadej> tabaqui: I'd say that you have a code smell, haven't work with over 3-tuples almost never
08:22:04 <kuribas> place: not an answer, but if you are doing indexing in a list, you are better of using a vector or IntSet.
08:22:28 <phadej> kuribas: better not to introduce too much stuff to beginners
08:22:31 <phadej> at once...
08:22:44 <kuribas> uhm, okay...
08:22:51 <phadej> first get it to work, then get it better.
08:24:18 <phadej> place: but you can totally do like
08:24:30 <ski> place : use `case' in `editTitle' as well
08:24:39 <phadej> > let Just x = (Nothing :: Maybe Int) in "foo"
08:24:41 <lambdabot>  "foo"
08:24:51 <phadej> but if you really use x, it will crash
08:24:55 <phadej> > let Just x = (Nothing :: Maybe Int) in x
08:24:56 <lambdabot>  *Exception: <interactive>:3:5-35: Irrefutable pattern failed for pattern Just x
08:26:18 <ski>   editTitle title n list = case getNote n list of
08:26:22 <ski>     Nothing          -> ...
08:26:24 <ski>     Just (_,content) -> ...
08:27:50 <sm> place: as a general tip, when code isn't behaving like you expect, you can try running increasingly smaller pieces in GHCI until you see the problem
08:28:11 <ski> place : in your pasted code, you didn't say what should happen when `getNote n list' was `Nothing', you were just assuming that that wouln't happen (because you used `Just (_,content) = getNote n list')
08:28:32 <ski> .. as you noticed, it can in fact happen
08:30:05 <place> I'm sorry for the delay...
08:30:14 <place> Yeah, I noticed very quickly D:
08:30:31 <place> Um, I think I got -Wall working but the compiler didn't actually tell me
08:30:45 <place> It did tell me about something else though which was useful but doesn't relate to the question
08:34:01 <agocorona> Hi, what is the best library to manage HTTP headers?
08:35:01 <joncol> Is it possible to use `where` in typeclass instance definitions?
08:35:23 <joncol> Or should I go with let there to avoid the nested where-where?
08:35:26 <place> sm, ski: The confusing part is that code that is supposedly incorrect still manages to deliver the correct result across the entire domain
08:35:37 <EvanR> joncol: i use nested wheres all the time
08:35:50 <EvanR> that is, 2
08:36:00 <EvanR> up to 2 levels of indentation
08:36:40 <joncol> Ah, cool, it works, I just failed when I tried to indent.
08:36:42 <ski> place : it does not deliver correct result when the `Int' isn't in the correct range
08:37:17 * ski wouldn't hesitate to nest `where's thrice or more, in case it helps
08:37:31 <geekosaur> it should, since let/where are always lazy and the result is not inspected if the splitAt is empty
08:38:49 <geekosaur> it's not ideal since that arrangement looks like action at a distance, but seems to me it should work
08:39:10 <ski> oh, right. because `replace' will give `Nothing' in the same situations
08:39:54 <sm> ski: but frice is right out
08:40:05 <Digit> reading https://felipec.wordpress.com/2013/11/04/init/ that "very first init" in ruby there, could there be an equivalent in haskell?  that makes a haskell init seem very simple.  could it launch ghci instead of a term?   that all it'd take to have my computer boot to pure haskell and nothing else?  :O  :3  i've gone too far havnt i.
08:40:08 <ski> @wn frice
08:40:11 <lambdabot> No match for "frice".
08:40:38 <place> Oh, so it splits the list and only in the second case alternative will it evaluate the where clause? 
08:40:40 <sm> from http://english.stackexchange.com/questions/6798/is-there-a-word-for-four-times-as-much-analogous-to-once-twice-and-thrice 
08:40:49 <place> I guess that'd make sense
08:40:58 <place> geekosaur, what would the ideal way look like?
08:41:00 <puregreen> quarce quince
08:41:20 <geekosaur> place, ski showed you earlier with the case
08:42:27 <geekosaur> place, you are seeing laziness in action. and why it can be confusing even to experienced Haskellers (one becomes accustomed to pattern matches being strict by default, but a where turns into a let and let is lazy pattern matching by default)
08:42:42 <place> I oversaw that...
08:42:59 <place> That's what it looked like at first actually
08:43:10 <geekosaur> [14 15:25:56] <ski>   editTitle title n list = case getNote n list of
08:43:20 <place> I tried to shorten it and got really confused...
08:45:57 <place> I've read some stuff about partial functions
08:46:02 <place> In math, you could do this
08:46:09 <place> f : R\{0} -> R
08:46:09 <place> f(x) = 1/x
08:46:18 <EvanR> thats a total function
08:46:22 <place> Yeah
08:46:32 <place> But in Haskell, you apparently can't do that
08:46:41 <EvanR> it wouldnt be that concise no
08:46:52 <EvanR> unfortunately
08:46:52 <place> Is there a particular reason why...?
08:46:52 <ski> because you can't express `|R\{0}' as a type
08:47:29 <ski> (in Haskell)
08:47:49 <ski> (in e.g. Agda, it works fine)
08:47:54 <EvanR> with dependent types, which haskell doesnt have, you can also pass in evidence that the argument is some distance away from zero, then the function will be well defined
08:48:20 * hackagebot shake-pack 0.2.0 - Shake File Pack Rule  https://hackage.haskell.org/package/shake-pack-0.2.0 (LukeHoersten)
08:48:22 * hackagebot xls 0.1.0 - Parse Microsoft Excel xls files (BIFF/Excel 97-2004)  https://hackage.haskell.org/package/xls-0.1.0 (harendra)
08:48:24 <EvanR> potentially
08:48:58 <shirt> how do i error handling with "conduit" library? let's say i want to do something like (Data.Conduit.Combinators.map (+1)) but with the added condition that if the number 0 is encountered, then signal an error.
08:49:00 <shirt> is the best way to use mapM instead of map, and then use throwIO for errors?
08:49:50 <EvanR> im thinking an attempt to formula a theory of reals in haskells type system would be intractible
08:50:27 <dmj`> shirt: depends on if you're in IO
08:51:31 <shirt> dmj`: the goal is to avoid that, since i don't really need IO. in my case, the pure "map" combinator works perfectly except for any way to report an error
08:51:42 <shirt> (... apart from using "error")
08:51:52 <shirt> (... which i am guessing is not a good idea?)
08:52:01 <sbrg> shirt: Why not use something like Maybe or Either to indicate the possibility of an error?
08:52:06 <dmj`> shirt: what errors do you intend on receiving
08:52:26 <sbrg> oh, sorry, didn't read backlog
08:53:21 <EvanR> place: actually, in special cases you can reimplement an entirely new type which does what you want. like (a,[a]) is as good as the type of non empty lists. and sign*x*b^n is as good as a subset of reals which cant be zero
08:53:45 <shirt> i am reading in a sequence of bytes, and want to map each one to the appropriate ASCII Char. but a byte with an invalid value is encountered then i need to signal an error
08:55:08 <sbrg> well, that can still work with Maybe/Either, but you'd have to handle that appropriately downstream. or you could use a transformer over the conduit monad so that you can report the error(like Writer)
08:56:19 <shirt> i prefer not to handle maybe/either downstream. i want downstream to get a simple sequence of characters
08:56:52 <sbrg> there is also the option of simply silently ignoring the invalid byte, but whether that is horrible depends on your application
08:57:40 <ggVGc> catch(AnyError){return ;} <-- winning
08:57:42 <shirt> i notice that Data.Conduit.Zlib.ungzip uses "MonadThrow"
08:59:08 <place> EvanR: I'm afraid I don't fully understand but I have to leave
08:59:18 <place> Thanks for the help
08:59:19 <ggVGc> ^ me every day
08:59:29 <place> And have a nice day, everyone...
08:59:32 <ggVGc> later
09:03:33 <kuribas> sm: succes!  I didn't use stack or sandboxes.
09:14:08 <ph88> geekosaur, i made a new discovery
09:14:32 <geekosaur> ... yes?
09:15:07 * Clint nods.
09:15:18 <ph88> geekosaur, https://ghc.haskell.org/trac/ghc/ticket/12696#comment:8  bottom of ticket
09:16:09 <ph88> why would the put exception throwing code in there .. and where was it called
09:16:34 <ph88> perhaps i can modify the code of this library to change "without stack trace" to "with stack trace" and then recompile
09:17:33 <geekosaur> o.O why is it using generics
09:18:09 <ph88> my code ?
09:18:13 <ph88> because i use uniplate
09:18:25 <geekosaur> oh, right.
09:20:05 <ph88> geekosaur, this SO issue pretty much describe what i'm doing in and why i choose uniplate  http://stackoverflow.com/a/20171291/1833322
09:20:27 <ph88> i'm not using the universeBi function but the transformBi function
09:21:23 <ph88> this is also curious https://hackage.haskell.org/package/uniplate-1.6.12/docs/src/Data-Generics-Uniplate-Internal-Data.html at function sybChildren it expects an exception and then says "but all exceptions are caught later on" .. i guess some weren't caught ?!
09:21:37 <ph88> because i noticed this function was in the trace
09:24:01 <geekosaur> ph88, I think someone in #ghc pointed out that the things you were doing for testing interfere with that catching
09:24:26 <geekosaur> in particular, ghci is a debugger and will intercept all exceptions. and -xc fires whether or not an exception is eventually caught or not
09:25:25 <geekosaur> (the -xc one will still be caught but you will see the exception instead of it being hidden)
09:26:05 <ph88> so pretty much those exceptions are part of normal operation ?
09:27:27 <geekosaur> ph88, yes
09:27:38 <geekosaur> generics have to "cheat"
09:30:17 <ph88> alright makes sense
09:30:32 <ph88> when i disable -fbreak-on-exception and run my program normally it doesn't terminate
09:30:39 <ph88> so i suspect it's the same issue as this one https://github.com/ndmitchell/uniplate/issues/9
09:30:53 <ph88> geekosaur, do you think the ghc ticket is still valid ?
09:31:26 <geekosaur> I think it should produce a better exception message still, yes
09:31:52 <sm> kuribas: great
09:32:03 <ph88> geekosaur, alright i'll leave it open then
09:32:18 <geekosaur> when even internals folks aren't entirely certain what (THUNK_2_0) means (and it takes scrambling about to get even that far), you have an exception reporting issue.
09:32:33 <geekosaur> you should add a comment noting that the scope of the ticket is just this issue of poorly reported exceptions
09:39:38 <ph88> ok
09:41:25 <ph88> geekosaur, do you know all this generic stuff is it actually still performant? can it do enough on compile-time ?
09:42:52 <geekosaur> ph88, I understand generics from a theoretical POV but have yet to actually use them in Haskell.
09:45:10 <joncol> I'm trying to make a simple "compiler" that reads a Graphviz .dot file and builds up an AST, after which this AST is pretty printed as a nice PlantUML diagram. But I have a question: the input data is badly formatted (could not be loaded by the existing graphviz lib). The nodes sometimes occurs /after/ the edges that refer to them. I want to have an edge be a product type of two Nodes and a Label. This 
09:45:16 <joncol> would be easy if the nodes came first, then I could just place them in Parsec user state as I parsed them. But as it is now, I don't know how to solve this cleanly... Any suggestions?
09:47:22 <JuanDaugherty> have two passes, one that gets a good AST, and a second that does stuff with it
09:48:04 <joncol> JuanDaugherty: Ah... Of course.
09:48:08 <joncol> :)
09:48:21 * hackagebot hylolib 1.5.3 - Tools for hybrid logics related programs  https://hackage.haskell.org/package/hylolib-1.5.3 (GuillaumeHoffmann)
09:48:23 * hackagebot vgrep 0.1.4.0 - A pager for grep  https://hackage.haskell.org/package/vgrep-0.1.4.0 (fmthoma)
09:48:23 <hpc> that's more or less how compilers work
09:48:25 * hackagebot hackernews 1.0.0.0 - API for Hacker News  https://hackage.haskell.org/package/hackernews-1.0.0.0 (DavidJohnson)
09:48:27 * hackagebot simple-vec3 0.2 - Three-dimensional vectors of doubles with basic operations  https://hackage.haskell.org/package/simple-vec3-0.2 (DmitryDzhus)
09:48:34 <hpc> turning a thing into another thing is hard, so put something between the things
09:48:36 <hpc> repeat until easy
09:51:59 <ongy> that's pretty much what all applications do
09:52:50 <joncol> So what's a nice representation of the intermediate result? Should I keep a separate set of datatypes for results that are not "done"?
09:54:34 <hpc> depends
09:54:42 <hpc> sometimes it's a datatype, sometimes it's a whole other language
09:55:04 <hpc> (at least for compilers)
09:55:28 <joncol> hpc: Do you have an example of such an intermediate language?
09:55:45 <hpc> so, ghc
09:56:10 <hpc> there's an AST somewhere in a ghc-* package for the language as ghc understands it
09:56:16 <hpc> including all language extensions
09:56:45 <hpc> stuff happens to it as an AST at that stage, and ultimately it gets compiled to a language called core
09:56:53 <hpc> which i don't have any examples of offhand
09:57:13 <hpc> it reads a lot like haskell, but has explicit strictness/non-strictness, significantly reduced polymorphism, etc
09:57:41 <exio4> but Core has no typeclasses, explicit types, case is always strict (pattern matching always evaluates)
09:57:41 <hpc> it also has an AST, and a bunch of stuff happens with that, and that gets passed to a backend
09:58:02 <hpc> the native backend for the architecture, or the llvm backend, or until recently the via-c backend
09:58:14 <hpc> well, "recently"
09:58:53 <hpc> not sure if it's still there, but at one point there was a stage where it got compiled to a custom C called C--
09:59:11 <geekosaur> core -> cmm -> stg -> backend
09:59:24 <hpc> ah that's it then
09:59:25 <geekosaur> well, the cmm / stg thing is not that straightforward
09:59:27 <exio4> geekosaur: hm, I think that's the wrong order
09:59:31 <joncol> std = ?
09:59:35 <joncol> *stg
09:59:36 <byorgey> joncol: so, to be more explicit, one idea would be to make two AST types: one which explicitly represents all the possible syntax that you expect to see, including out-of-order edges etc., so writing a parser for it is straightforward
09:59:39 <hpc> stg = spineless tagless g machine
09:59:41 <exio4> more like core -> stg -> cmm -> backend :p 
09:59:44 <geekosaur> stg is the evaluation/reduction engine
09:59:52 <byorgey> joncol: then have a function to translate that AST into a simpler, normalized AST.  Then finally pretty-print that.
10:00:10 <geekosaur> and exio4 is closer, yes, but it' actually more like the two are intertwined: the stg is represented as cmm
10:00:41 <hpc> anyway, compilers are like ogres
10:00:44 <hpc> they have layers
10:00:47 <hpc> (and sometimes they stink)
10:00:53 <geekosaur> stg is not itself a language or an AST, at this level it's a code generation strategy. cmm is the generated code using that strategt
10:01:25 <geekosaur> although once generated you can treat it as a pattern in the target language/representation
10:02:19 <joncol> byorgey: OK, so for instance, in my case where I have edges that refer to yet non-existant nodes, I would have an "IntermediateNode" type that just had a Text (String) reference to the node? And then, during "normalization" I would replace that with the actual Node?
10:03:02 <Tuplanolla> Is there a way to target GHC Core without having to carry the weight of the Haskell compiler yet?
10:03:04 <geekosaur> or whatever kind of handle you have for the node-to-come, yes
10:03:39 <joncol> Sweet, thanks.
10:04:36 <geekosaur> joncol, this is standard way to handle any kind of forward reference. compilers arre a good example here because forward references happen quite often
10:05:26 <hpc> iirc you can pass core back into ghc to finish compilation, if you have some kind of separate way to output core
10:05:42 <hpc> i wouldn't even bother unless core happened to be a suitable intermediate language
10:06:04 <geekosaur> external core is dead
10:06:10 <hpc> ah, nvm then
10:06:10 <geekosaur> but then external core was never internal core
10:06:24 <geekosaur> and I don't think internal core can be sourced from anywhere but earlier compiler stages
10:06:36 <joncol> geekosaur: OK, I don't have much experience with having to deal with this.
10:06:45 <Tuplanolla> That's a shame.
10:06:53 <geekosaur> (and can't be, the design doesn't allow it. extcore was created specifically because of that.. .but wasn't maintained)
10:09:16 <geekosaur> Tuplanolla, I can actually imagine some hacks involving .hi files...
10:09:32 <geekosaur> however that'd be really fragile
10:10:18 <geekosaur> ultimately I think extcore could be resuscitated, but (a) it can't be the same as standard Core (b) someone has to actually take ownership and keep it working; extcore was removed because it was severely bitrotted and nonworking
10:15:07 <NemesisD> i've got some code that has a function like `modify` from State that adds some state for the duration of a given monadic action. i noticed if I run it with `forever` it doesn't leak memory but does with explicit recursion
10:15:07 <vsimen> hi, anyone knows how sequence function is implemented for list monad ? 
10:15:32 <allenj12> how do you get the type of something in a do block using a <- ? for example I have contents <- lift $ listDirectory path . but Im new to haskell and wanna check the type of contents in the do block even tho I can easily get the type of the rhs
10:15:37 <mauke> @src sequence
10:15:37 <lambdabot> sequence []     = return []
10:15:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:15:37 <lambdabot> --OR
10:15:37 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:15:46 <c_wraith> vsimen, same way it's implemented for every other monad. 
10:15:57 <NemesisD> my intuition here which may be wrong is that forever sequences each trip through the loop, so trip 1 adds some state, then loop 2 starts with the original state and does that again. how would i achieve this with explicit recursion?
10:16:03 <allenj12> i also have ghci with the file loaded
10:16:24 <vsimen> mauke, c_wraith thanks 
10:17:02 <NemesisD> in other words, with forever its like modify addState inner >> modify addState inner >> ... but with explicit recursion its like modify addState (modify addState ( .... inner))
10:18:40 <NemesisD> i guess my explicit recursion could literally be implemented as modify addState inner >> go inner
10:18:50 <vsimen> where can I look for implementations myself without using this lambdabot ? 
10:19:11 <cocreature> NemesisD: that’s pretty much what forever does :)
10:19:13 <cocreature> @src forever
10:19:13 <lambdabot> forever a = let a' = a >> a' in a'
10:19:31 <kadoban> vsimen: hackage is probably the best place. @src here is actually quite terrible, it's full of lies
10:19:33 <geekosaur> vsimen, hoogle.haskell.org or hayoo.fh-wedel.de
10:19:39 <cocreature> iirc the let is some clever trick that I forgot
10:19:40 <NemesisD> cocreature: so they're actually *semantically* different. in the forever version of the code state won't accumulate
10:19:42 <kadoban> vsimen: There's "Source" links in hackage that will show you.
10:20:05 <NemesisD> so you'll observe different states in both versions
10:20:11 <cocreature> NemesisD: what do you mean by “won’t accumulate”?
10:20:21 <cocreature> NemesisD: it might be helpful if you show us your sourcecode for explicit recursion
10:20:27 * geekosaur is constantly looking stuff up on hayoo and following the package or source link...
10:21:51 <NemesisD> cocreature: if i have go inner = modify addState (inner >> go inner), each time it loops, the state inner has will keep growing, however go inner = forever (modify addState inner), each time inner is called it will only see state where addState was called once
10:22:35 <NemesisD> so if addState was succ and state was an int, the first version each time inner is called the number would keep incrementing. in the forever version if it started at 0, inner's state will always be 1
10:22:59 <PhsShft> how do I convert a string to all upper case? I find Data.Char.toUpper , but do I have to go through each char in the string?
10:23:19 <cocreature> NemesisD: how is that supposed to typeCheck? modify only takes one argument
10:23:45 <PhsShft> do i have to do map? or is there a better way?
10:23:59 <mauke> PhsShft: map toUpper, if you only care about ascii
10:23:59 <allenj12> PhsShft: whats wrong with map?
10:24:05 <geekosaur> PhsShft, most of us would say map *is* the better way
10:24:12 <PhsShft> kk
10:24:14 <geekosaur> think compositionally, not monolithically
10:24:20 <NemesisD> cocreature: that's what i get for going off script. s/modify/local/ from Reader
10:24:31 <PhsShft> just thought there might be a builtin toUpper for strings
10:24:31 <geekosaur> why should there be N different functions that are all internally map sometingElse yourString?
10:24:47 <geekosaur> possibly "reinventing" map locally
10:24:55 <NemesisD> cocreature: or withState if you like
10:25:03 <geekosaur> also keep in mind the compiler usually optimizes the map away
10:25:07 <Tuplanolla> Aren't there characters that expand to multiple characters during case conversion?
10:25:20 <allenj12> if the type of something is Control.Monad.Trans.Class.MonadTrans t => t IO [String] what will be the type of the argument when i bind(>>=) it to a function
10:25:23 <geekosaur> Tuplanolla, for that you need the locale aware stuff in Data.Text, yes
10:26:09 <geekosaur> because it's far worse than just "characters that expand to multiple characters"; it depends on the selected locale and it can depend on the context
10:26:23 <geekosaur> (Arabic is an example of context dependence although toUpper is not applicable there)
10:26:37 <PhsShft> ok…
10:26:50 <cocreature> NemesisD: if you use local in a loop, it seems like you really want State instead of Reader and modify. but going back to your original question, yes they are semantically different
10:27:06 <allenj12> to elaborate if I have a Control.Monad.Trans.Class.MonadTrans t => t IO [String] >>= \whatsThis -> :t whatsThis would be?
10:27:06 <geekosaur> which means it's not anywhere near as simple as just toUpper if you need to go that route
10:27:41 <ski> allenj12 : a `[String]' ?
10:27:51 <Tuplanolla> Boy, I sure love locales.
10:28:02 <allenj12> ski: so it strips it of both t and IO?
10:28:03 <ski> allenj12 : the monad being `t IO'
10:28:21 <allenj12> ski: i forgot that t IO is one monad!
10:28:24 <allenj12> thank you
10:28:26 <ski> np
10:28:47 <glguy> allenj12: In this case you'll have a type-error because MonadTrans t isn't enough to know that Monad (t IO)
10:29:58 <allenj12> ski: is there an easy way to check that in the repl? I tried but since >>= is expecting the t IO b, it is hard to just print the type
10:31:02 <ski> allenj12 : perhaps using the debugger, not sure
10:31:19 <allenj12> glguy: weird I dont get a type error
10:31:36 <ski> allenj12 : you probably have more information available in your context
10:32:54 <allenj12> ski: alright as long as there is not some dumb way im missing, can get your brain tangeld up if your not use to them :D
10:33:07 <allenj12> types can *
10:48:23 * hackagebot ngx-export 0.2.1.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.2.1.0 (lyokha)
10:48:25 * hackagebot yi 0.13.2 - Yi editor  https://hackage.haskell.org/package/yi-0.13.2 (DmitryIvanov)
10:48:27 * hackagebot yi-core 0.13.2 - Yi editor core library  https://hackage.haskell.org/package/yi-core-0.13.2 (DmitryIvanov)
10:48:29 * hackagebot yi-frontend-pango 0.13.2 - Pango frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-pango-0.13.2 (DmitryIvanov)
10:48:31 * hackagebot yi-frontend-vty 0.13.2 - Vty frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-vty-0.13.2 (DmitryIvanov)
10:49:37 <Unicorn_Princess> i don't get it, how does having a foldMap instance get you foldr and foldl for free? like, how would you implement foldr and foldl by having only foldMap?
10:50:32 <johnw> Unicorn_Princess: that's actually a fun exercise :)
10:50:36 <puregreen> Unicorn_Princess: you can look at default implementations in the source of Data.Foldable to find out
10:50:47 <puregreen> or you can do the fun exercise if you want to, yeah
10:50:57 <Unicorn_Princess> ...maybe by making a monoid instance with a mappend that's left or right associative?
10:51:04 <Unicorn_Princess> hm
10:51:15 <johnw> Unicorn_Princess: hint: think about Endo
10:52:15 <roconnor> @djinn ((a,c) -> d) -> ((b,c) -> d) -> (Either a b, c) -> d
10:52:15 <lambdabot> f a b (c, d) =
10:52:15 <lambdabot>     case c of
10:52:15 <lambdabot>     Left e -> a (e, d)
10:52:15 <lambdabot>     Right f -> b (f, d)
10:52:42 <Unicorn_Princess> if that;s the hint, i'll hold off on doing this fun exercise till i learn about endomorphisms, thanks :)
10:53:33 * hackagebot yi-fuzzy-open 0.13.2 - Fuzzy open plugin for yi  https://hackage.haskell.org/package/yi-fuzzy-open-0.13.2 (DmitryIvanov)
10:53:35 * hackagebot yi-ireader 0.13.2 - Yi editor incremental reader  https://hackage.haskell.org/package/yi-ireader-0.13.2 (DmitryIvanov)
10:53:37 * hackagebot yi-keymap-cua 0.13.2 - Cua keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-cua-0.13.2 (DmitryIvanov)
10:53:39 * hackagebot yi-keymap-emacs 0.13.2 - Emacs keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-emacs-0.13.2 (DmitryIvanov)
10:53:41 * hackagebot yi-keymap-vim 0.13.2 - Vim keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-vim-0.13.2 (DmitryIvanov)
10:54:39 <dazednconfused> hi room
10:54:52 <dazednconfused> beginner in haskell here :)
10:54:54 <srhb> Hello dazednconfused.
10:55:02 <dazednconfused> i have a question
10:55:09 <srhb> Simply ask. :)
10:55:27 <dazednconfused> i'm having trouble thinking "functionally"
10:55:45 <sbrg> anyone installed ghcjs via stack recently on ghc8? integer-gmp is failing to build during the ghcjs boot phase. 
10:55:54 <dazednconfused> how can i go about writing a solution to problems such as this? https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=62
10:56:00 <allenj12> dazednconfused: Im new to haskell too, but used other functional like languages like clojure scala etc..
10:57:14 <dazednconfused> if i think in imperative languages, i can use a two-dimensional array, iterate over each triangle, rotate triangles and compare edges easily as i have a global and mutable variables
10:57:48 <dazednconfused> but solving such problems in haskell seem near impossible for me. i'm sure there is a way, it's just that i'm unable to think in the required way
10:58:16 <allenj12> dazednconfused: my general thought process would be in haskell specifically to start by creating a data or multiple of to contain your problem. then simply right functions to start checking rules.
10:58:19 <srhb> dazednconfused: It's hard to give completely general advice, but consider a function argument
10:58:35 <srhb> dazednconfused: You can always model "mutation" by recursively calling some function and altering the argument.
10:58:43 * hackagebot yi-language 0.13.2 - Collection of language-related Yi libraries.  https://hackage.haskell.org/package/yi-language-0.13.2 (DmitryIvanov)
10:58:45 * hackagebot yi-misc-modes 0.13.2 - Yi editor miscellaneous modes  https://hackage.haskell.org/package/yi-misc-modes-0.13.2 (DmitryIvanov)
10:58:47 * hackagebot yi-mode-haskell 0.13.2 - Yi editor haskell mode  https://hackage.haskell.org/package/yi-mode-haskell-0.13.2 (DmitryIvanov)
10:58:49 * hackagebot yi-mode-javascript 0.13.2 - Yi editor javascript mode  https://hackage.haskell.org/package/yi-mode-javascript-0.13.2 (DmitryIvanov)
10:58:51 * hackagebot yi-snippet 0.13.2 - Snippet support for yi  https://hackage.haskell.org/package/yi-snippet-0.13.2 (DmitryIvanov)
11:00:13 <dazednconfused> allenj12: i thought of that. a list of lists would fit my 6 triangles. but that's about as much as i could get to
11:00:33 <allenj12> dazednconfused: are you trying to solve, or create this problem/game
11:01:23 <dazednconfused> the solution is already available online. it's just that if i look at the solution in any imperative language, it seems easy. it's just hard for me to do this in haskell
11:01:32 <srhb> dazednconfused: I would probably start by implementing primitive operations
11:01:36 <dazednconfused> problem here: https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=62
11:01:43 <srhb> dazednconfused: Like swapping two triangles, and rotating a triangle.
11:01:47 <dazednconfused> solution in java here: http://www.icpc-midcentral.us/archives/2000/triangle/triangle.java
11:01:53 <srhb> dazednconfused: Instead of trying to think out a complete solution at first.
11:02:11 <srhb> So you need a Hexagon type and some primitive operations.
11:02:26 <allenj12> dazednconfused: can you briefly explain the solution here
11:02:36 <vsimen> can somebody explain me how ($ 3) has type  Num a => (a -> b) -> b and ($) has type (a -> b) -> a -> b ? 
11:03:25 <ongy> vsimen: the ($) is used in a section here, so the argument on the right will be the second argument to the function, not the first
11:03:33 <ongy> :t elem
11:03:34 <lambdabot> (Foldable t, Eq a) => a -> t a -> Bool
11:03:40 <ongy> :t (`elem` "Hi")
11:03:42 <lambdabot> Char -> Bool
11:03:44 <allenj12> :t ($)
11:03:46 <lambdabot> (a -> b) -> a -> b
11:03:53 * hackagebot th-typegraph 0.35.1 - Graph of the subtype relation  https://hackage.haskell.org/package/th-typegraph-0.35.1 (DavidFox)
11:03:58 <dazednconfused> if you look at the solution link, it's pretty obvious. he takes a triangle array, calls a function to start matching with the 0th and 1st triangle. there are additional functions to rotate and match sides
11:05:40 <srhb> vsimen: Expanding the section may be clearer, `($ 3)` is the same as `(\f -> f $ 3)`
11:05:42 <rnd> http://lpaste.net/8851678364398780416 can't find how to fix this, error is in description, im mixing up lists with matrices somewhere, may anyone know how to solve this?
11:06:33 <srhb> rnd: The first two equations have element : list
11:06:37 <srhb> rnd: The last equation has element
11:07:15 <geekosaur> rnd, the pattern [x] is a list with one element whose value is x
11:07:58 <geekosaur> you probably just want x there
11:08:18 <rnd> thanks
11:08:26 <rnd> worked!
11:12:00 <rnd> after all i found i could all that way easier...: mostrarMatrizDesdeColumna n = map (drop (n - 1))
11:12:04 <rnd> XDD
11:12:58 <vsimen> ongy, srhb, thanks got it, reread the section wiki 
11:14:15 <ReinH> [x] = x:[] on both sides of the =
11:14:27 <ReinH> (as a pattern and as a constructor)
11:25:59 <pie_> what do you guys think about rust?
11:27:46 <Sonolin> is there any way to use guards and/or match multiple matches in a "case" expression?
11:28:13 <hpc> pie_: it'll have a hard time supporting chrome because it prevents oxidization in iron
11:28:17 <johnw> case (a, b, c) of (pat, pat, pat) -> ...
11:28:33 <monochrom> haha hpc
11:28:44 <johnw> and yes, you can use guard patterns, etc.
11:29:06 <Sonolin> ah ok... I guess to use guards I'd just refer to the variable on the left side of -> ?
11:29:17 <Sonolin> so something like case a of a | a == test -> ... 
11:29:20 <pie_> hpc, :'D
11:29:52 <Tuplanolla> It's ugly, but will probably end up in many places, pie_.
11:30:40 <geekosaur> Sonolin, just deconstruct as needed in the pattern? can you provide an actual use case that we can work with, instead of having to come up with examples without knowing what you're actually trying to do?
11:31:41 <Sonolin> actually, I think I'll just be explicit and match each one on separate matches
11:31:45 <Sonolin> but good to know for the future
11:32:03 <ongy> pie_: I like the general idea, last I looked into it I deemed it "not ready" though. Also I think they should have gone a different route with the syntax (though I get why they didn't)
11:32:14 <Sonolin> (I was just wondering if I could do something like "case t of Type1 OR Type2 -> " simple enough)
11:32:53 <geekosaur> that looks like a thinko somewhere. it's always going to be one type. do you mean data constructors?
11:33:08 <geekosaur> (and indeed there is no way to do an or-pattern with data constructors)
11:33:16 <JuanDaugherty> so the js ghcjs generates runs server side?
11:33:23 <pie_> im not familiar with it but i just found a job opportunity in embedded dev (well on paper anyway) and my curiosity piqued (they want C, but i figured id look into rust a little)
11:33:32 <srpx> Instead of having different languages with different type systems, can't those typing rules that look like logic statements somehow be expressed on the language in a generic way and then you'd be able to use any flavor of logic as your type system as a first-class thing?
11:34:09 <pie_> ongy, yeah a lot of things seem in flux. Tuplanolla is that the haskell in you speaking? ;P
11:34:29 <pie_> ongy, people seem to say good things though so im rooting for it, and for it to mature
11:34:40 <hpc> this probably belongs in -blah
11:34:46 <Tuplanolla> Yes, although syntactically Haskell is pretty ugly too, pie_.
11:35:02 <pie_> hpc, didnt know thats a thing
11:35:24 <geekosaur> JuanDaugherty, that's up to how you use it
11:35:31 <hsk3> !seen Cale
11:35:35 <pie_> goto blah; :P
11:35:42 <geekosaur> you can certainly run it client side, although it ends up being pretty big with the runtime
11:35:52 <pie_> Tuplanolla, versus what? lisp?
11:35:57 <pie_> just wonderin
11:36:08 <Tuplanolla> Sure.
11:36:18 <JuanDaugherty> runtime? you mean the server side stuff?
11:36:43 <JuanDaugherty> i.e node
11:37:24 <geekosaur> no. ghcjs-generated javascript requires a largeish runtime because it aims to be as close to the haskell semantics as possible, whereas things like elm assume native JS behavior is "good enough"
11:37:42 <geekosaur> node is used as part of processing TH at compile time, not at runtime as I understand it
11:38:04 <JuanDaugherty> js doesn't normally involve any runtime other than the standard ecma engine in a user agent
11:38:11 <pikajude> yeah, ghcjs actually has all the RTS registers represented in javascript and everything
11:38:15 <pikajude> it's ridiculous
11:38:53 <geekosaur> JuanDaugherty, yes that is correct. *but* ghcjs does not just assume bare JS "does the right thing", so it has a large library of helpers that enforce Haskell data semantics instead of native JS data semantics
11:39:09 <JuanDaugherty> ah, i c
11:39:24 <geekosaur> conceptually it's no different from pulling in e.g. jquery. practically, enough helpers are needed that the library is much larger than jquery
11:39:29 <ReinH> ghcjs's generated javascript includes a GHC-compatible runtime that is executed by the client.
11:40:00 <ReinH> Other options do not, but this restricts them in various ways.
11:40:17 <JuanDaugherty> yeah and js frameworks are frameworks, not standalone snippets, still "runtime" is jarring
11:41:01 <pikajude> yeah you can't really use js frameworks generally
11:41:32 <ReinH> JuanDaugherty: I mean, Ember's template language includes machine code and a virtual machine.
11:41:32 <JuanDaugherty> you mean with ghcjs?
11:41:47 <ReinH> It's just another execution context.
11:41:57 <bollu_> given a free monad and a cofree comonad, it is the pairing that determines interpretation, correct?
11:42:00 <ReinH> s/template language/rendering subsystem
11:42:02 <bollu_> so if I give one party the free monad
11:42:08 <bollu_> and the other party the cofree comonad
11:42:19 <bollu_> can they automatically figure out the pairing?
11:42:24 <bollu_> without me explicity giving it?
11:44:43 <ReinH> bollu_: the only requirement is that a Pairing instance exist, which can be created by either party.
11:48:25 * hackagebot th-context 0.24 - Test instance context  https://hackage.haskell.org/package/th-context-0.24 (DavidFox)
11:48:27 * hackagebot legion 0.5.0.1 - Distributed, stateful, homogeneous microservice framework.  https://hackage.haskell.org/package/legion-0.5.0.1 (taphu)
11:48:29 * hackagebot convert-annotation 0.2.0.0 - Insert synopsis here  https://hackage.haskell.org/package/convert-annotation-0.2.0.0 (GregorySchwartz)
11:57:27 <allenj12> is it wrong I think this a weird way of writing this function? http://pastebin.com/8S57HXhF countEntries
11:58:39 <allenj12> the main reason being were using a do, so in the first line we create an 'IO [String]' then lift it to 't IO [String]' then just to strip it all away
11:59:32 <allenj12> wouldnt a better way to write a function that we dont have to do all these extra transformations with? or is it normal
12:03:52 <ongy> I would just return a IO [(FilePath, Int)], I don't really see why you are using writer here
12:04:07 <allenj12> ongy: it was apart of real world haskell as an example
12:04:57 <allenj12> ongy: i was just curious if it was common to do this sort of manipulation of types to keep everything nice instead of writing in a pattern that more represents what you wanna do
12:11:07 <hue_> hue
12:11:08 <hue_> hue
12:11:10 <hue_> hue
12:11:13 <hue_> hue
12:11:15 <hue_> hue
12:11:20 <monochrom> \∩/
12:11:43 <hue_> hue
12:11:46 <hue_> hue
12:11:49 <hue_> hue
12:11:51 <hue_> hue
12:11:53 --- mode: ChanServ set +o monochrom
12:11:54 <hue_> hue
12:12:25 --- mode: monochrom set +q hue_!*@*
12:12:34 --- mode: monochrom set -o monochrom
12:12:49 <hueheu> hue
12:12:51 --- mode: ChanServ set +o monochrom
12:13:02 --- mode: monochrom set -q hue_!*@*
12:14:30 --- mode: monochrom set -o monochrom
12:15:00 <hue_> https://www.youtube.com/watch?v=vqiePnTXpNE this is song good
12:15:04 <allenj12> is there any good projects that need to be done in haskell, or need contributers?
12:15:09 --- mode: ChanServ set +o monochrom
12:15:25 --- mode: monochrom set +q *!~north@*
12:15:36 --- mode: monochrom set -o monochrom
12:16:36 <Unicorn_Princess> allenj12: a haskell implementation of the tox messenger and/or protocol would be neat
12:17:53 <Unicorn_Princess> although the list of stuff that needs to be done well, and could be done in haskell, is pretty big...
12:18:02 <lpaste> Fairy pasted “No title” at http://lpaste.net/8207076800598114304
12:18:19 <allenj12> Unicorn_Princess: interesting, never seen tox before. I might look into that. I need a good project to really get to know haskell :P. problem is I also need to continue looking for a job :D
12:19:30 <Fairy> I'm having HUGE issues understanding what I'm supposed to do in the following task: http://lpaste.net/8207076800598114304 is anyone able to look at it and attempt to explain it to me? I feel almost completely and utterly lost as to what the question even is (Relevant parts are translated to English to the best of my ability)
12:22:33 <mauke> Fairy: what's the first thing that's unclear?
12:23:01 <allenj12> also is there a place to look for haskell jobs? A man can dream?
12:23:54 <Fairy> mauke: The closest thing is lookupMem and addToMem, I have no idea how to implement it - however, the deeper issue is that I don't understand how this structure is supposed to "work"
12:25:11 <mauke> it's supposed to be a kind of map
12:25:46 <Fairy> Yes, but I don't understand how I'm supposed to store it. :S
12:25:51 <mauke> given a mem, you can look up a key (keys are integers) or add a new element (which returns the key it was stored under)
12:26:31 <Fairy> I understand that part - it's the rest that's completely alien to me :S
12:26:34 <mauke> do you have experience with other programming languages?
12:27:12 <Fairy> Yes, I'm proficient with Java
12:27:23 <mauke> ok, that might be part of the problem :-)
12:27:31 <mauke> this is going to be fun
12:27:57 <Fairy> well, I like it when my bf says those words >_>
12:27:57 <Tehnix__> allenj12: there probably also are a lot of APIs that would be nice to have in Haskell
12:28:04 <mauke> the map is represented as its own lookup function
12:28:22 <mauke> i.e. the second component of the Memory tuple implicitly stores everything
12:28:30 <allenj12> Tehnix__: any in particular? 
12:29:35 <mauke> Fairy: try to implement lookupMem. where do you get stuck?
12:30:19 <Tehnix__> allenj12: off the top of my head mailchimp (there are some halfly done ones), aaannd I can't seem to remember what I was in need of a couple of days ago
12:30:37 <Tehnix__> I know there are some missing.. ugh, now that annoys me
12:31:47 <allenj12> Tehnix`: lol its alright. mailchimp api seems interesting and a good start.
12:31:50 <Tehnix`> There are also other things like CMS and ecommerce projects for the masses (ala wordpress and magento), have been a few CMS tries, but nothing viable
12:32:20 <Tehnix`> Although currently I wouldn't know how to solve extendability in a as user friendly way as they do :/
12:33:01 <Fairy> mauke: lookupMem :: Memory -> Integer -> Maybe Ast; lookupMem (num, mem) int = mem int
12:33:05 <ongy> allenj12: I don't feel like wrapping an api is a good idea for a first haskell project. Simply because you will spend most of the time doing IO things, or thinking around quirks of the library, but I don't have any better idea
12:33:06 <Fairy> something like this? :S
12:33:18 <mauke> Fairy: yes, that looks perfect
12:33:54 <Tehnix`> ongy: I think it's a nice way to get some familiarity with HTTP requests and JSON (AESON) at least :)
12:33:56 <mauke> if you're feeling particularly cheeky, you can also define it as: lookupMem = snd
12:34:07 <Tehnix`> But yeah, probably a lot of work that is sorta the same
12:34:38 <Tehnix`> Which would probably lead to thinking about code reuse and abstracting things
12:34:41 <Fairy> mauke how would that work?
12:35:00 <allenj12> well if it helps, my background is cognitive science which at my school was computer science with a focus on AI. my masters thesis was on making computational models of emotion contagion in crowds, I have experience in classical AI, machine learning, formal logic, etc... I have lately kinda have wanted to get into more async programming
12:35:11 <ongy> Tehnix`: I have come to the point that I just wanted to strangle the library implementors for things they did :) things I wouldn't even like in a C project, that played really badly with haskell....
12:35:13 <mauke> Fairy: let's try to use it in an expression: lookupMem (n, m) k
12:35:30 <Fairy> mauke ohh no, I got it, didnt recodnize snd as a function
12:35:30 <mauke> Fairy: because lookupMem = snd, that becomes: snd (n, m) k
12:35:36 <mauke> ah, ok
12:36:17 <Tehnix`> allenj12: my background is web dev/network programming, so I'm a bit biased in my suggestions, towards that end ^_^
12:36:31 <Fairy> mauke hang on, you've helped me a lot already - lemme see if I can get the rest done ;)
12:36:42 <Tehnix`> ongy: for API libraries?
12:36:42 <mauke> sure :-)
12:37:03 <allenj12> Tehnix`: makes sense haha :D
12:37:41 <ongy> Tehnix`: what exactly would "API library" be? compared to normla libraries
12:37:45 <Tehnix`> allenj12: with your background though, http://www.datahaskell.org might be worth checking out
12:39:12 <puregreen> how do people test their TH code?
12:39:15 <puregreen> (if at all)
12:39:17 <Tehnix`> ongy: I guess more or less convenience wrappers around making HTTP requests in the correct format the API expects. Like `updateMember mail fields` would (in mailchimps case) md5 the mail put it at the end of the endpoint, convert the values to JSON and send a PATCH request etc
12:39:43 <allenj12> Tehnix`: seems promising :D.
12:42:02 <Rembane_> Xandaros: Indeed. On the other hand partial from functools isn't that bad.
12:43:37 <ongy> Tehnix`: that sounds like something I would rather make in haskell than wrap an existing library, just to avoid doing to much FFI. Though it sounds like something that would be easy to wrap
12:44:01 <haeue> muhammad was misled by satan
12:44:06 <haeue> same as modern jews
12:44:10 <ongy> the one I got angry with was pulseaudio. I don't think I put to much rage into my comments, but the code may show a bit of my dismay
12:44:12 <haeue> also
12:44:13 <haeue> hue
12:44:29 <haeue> though im not truly sure in the jews part
12:44:49 <csauce> ...what an interesting time to join the channel
12:45:05 <EvanR> its a spammer, ignore
12:45:11 <haeue> no its a real human being
12:45:18 <haeue> i am, that is
12:45:21 <haeue> i mean
12:45:21 <grantwu> @ops
12:45:21 <lambdabot> Maybe you meant: pl oeis docs
12:45:23 <haeue> i am a human being
12:45:32 <ReinH> @where ops
12:45:32 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
12:45:50 --- mode: ChanServ set +o geekosaur
12:45:55 <haeue> https://www.youtube.com/watch?v=eM7Atvvx4yc this song is pretty good
12:45:58 --- mode: geekosaur set +b *!*plant@87-121-128-45.bulsattv.com
12:45:58 --- kick: haeue was kicked by geekosaur (haeue)
12:46:35 <haeue> would you not agree?
12:46:41 <Tehnix`> ongy: Oh, I didn't mean wrapping any library, it was more to follow their API documentation and implement it from there. Think we're on the same page now :)
12:46:51 <haeue> pls no bully
12:46:53 <geekosaur> persistent bugger
12:46:58 <geekosaur> you're the bully
12:47:10 <geekosaur> take over whatever channel you want for your own selfish purposes
12:47:18 --- mode: geekosaur set +b *!*plant@146.247.2.221
12:47:19 --- kick: haeue was kicked by geekosaur (haeue)
12:47:19 <ongy> Tehnix`: I think that sounds way better for a learning project aswell
12:47:20 <csauce> FINISH HIM!
12:47:55 <EvanR> he only has 48 more proxies 
12:48:06 --- mode: ChanServ set +o monochrom
12:48:07 <haeue> i will show you my secret sauce
12:48:16 --- mode: monochrom set +q *!~plant@*
12:48:20 --- mode: monochrom set -o monochrom
12:48:27 * hackagebot pipes-protolude 0.1.0.1 - Alternate Prelude for the pipes ecosystem  https://hackage.haskell.org/package/pipes-protolude-0.1.0.1 (mckeankylej)
12:49:18 <geekosaur> probably for the best until they evade that too
12:49:28 <geekosaur> because it's all about them and evasion is their self-given right
12:49:41 <ongy> they did before, it was north@
12:50:11 <csauce> I wonder if IRC has anything like shadow-banning? that'd make it pretty simple
12:51:07 <hexagoxel> (your second proxy would immediately tell you if your first was shadow-banned)
12:51:45 --- mode: ChanServ set +o mauke
12:52:30 <csauce> oh yeah...
12:54:35 <monochrom> does shadow-banning mean the banned user joins a fake channel? because I just thought of that idea a few minutes ago.
12:54:56 <ongy> rather they join the real one, and irc tells them the messages arived, but just drops them
12:55:20 <monochrom> ah ok, that's no better/worse than my +q :)
12:55:35 <csauce> they also receive messages from other users
12:55:41 <ongy> joining fake channel would be rather easy to tell if the traffic is quite different
12:55:49 <EvanR> if they know they are +q they migh try to evade
12:55:51 <hexagoxel> well the difference to +q is that they cannot see the +q state.
12:56:03 <csauce> but they have no idea whether they're just being ignored or if they're shadow-banned. More of a Reddit thing, but it's easier to set up proxies on IRC.
12:56:10 <monochrom> yeah, I then imagined going out of one's way to fake other users and traffic :)
12:56:44 <csauce> I mean, for a channel like this it could just re-run the logs from a conversation a long time ago (assuming there were some logs) and make believe :D
12:56:58 <EvanR> shadow trolling, fake angry responses from other people yeah
12:57:14 <monochrom> also, did you know: IRC servers do not acknowledge or echo your messages. This is already normal operation.
12:57:28 <monochrom> (It is your client that echoes your messages.)
12:57:46 <monochrom> (Try using telnet to do IRC. You'll see.)
12:57:49 <ongy> some? I think without the self-message capability there's no echo at all. Not sure about acknowledge
12:58:13 <pikajude> this can be very confusing when trying to write an IRC -> any other service proxy
12:58:29 <monochrom> ah ok, there is this new-fangled self-message capability? my knowledge of IRC is from 20-years-old docs.
12:59:06 <pikajude> slash from the RFC
12:59:17 <mauke> when you're +q, you normally get an error response when speaking
13:00:18 <monochrom> yikes
13:00:36 <mauke> but #haskell is +z so that doesn't apply
13:00:47 <EvanR> you can send messages to yourself, but thats not what monochrom is talking about
13:00:51 <monochrom> oh OK neat
13:01:38 <ongy> oh it's echo-message http://ircv3.net/specs/extensions/echo-message-3.2.html self-message was the znc one
13:04:59 <monochrom> I posit that geekosaur's very harsh words are more effective than all the technical +b's and +q's we've tried. :)
13:05:49 <Fairy> mauke: it would appear I still don't understand what I'm doing :S implementing addToMem seems like voodoo magic, I feel absolutely clueless :S
13:05:51 <geekosaur> that would surprise me actually. most people have infinite ability to rationalize their own actions as pure and good and others as attacking them
13:06:08 <haeue> no seriously sorry
13:06:10 <haeue> i won't do this again
13:06:23 <pikajude> there's an easy way to guarantee that
13:07:55 <mauke> Fairy: would you know how to do it with type Memory = (Integer, [(Integer, Stt)]) ?
13:09:33 <Fairy> mauke: I feel stumped by the idea that I'm somehow supposed to use an existing Memory to create a new a new Memory that holds the original Memory values plus a new one
13:09:57 <Fairy> mauke: if it were a list, it'd be easy
13:10:24 --- mode: mauke set -o mauke
13:10:36 <mauke> Fairy: how would you implement addToMem with a list?
13:11:29 <ReinH> ban evasion is banworthy, no?
13:11:45 <ReinH> geekosaur: ^
13:11:59 <monochrom> yeah but we're lazy
13:12:02 <ReinH> heh
13:12:10 <monochrom> or rather, I'm lazy
13:12:15 <pikajude> haeue needs to force the issue
13:12:21 <geekosaur> they already left in any case. and, yes, ban evasion merits a ban --- but it incorporates its own failure mode, you end up playing whack-a-mole
13:14:19 --- mode: geekosaur set -o geekosaur
13:14:39 <nitrix> Hi. Does anyone have recommendations to detect quickly if, given a spatial 2D grid, where you can place blocks that connects on their edges, if it's possible to detect if removing a block is going to break the shape structure into two new shapes.
13:15:12 <nitrix> I've found out that my problem is a simplification of graph biconnected components, and I'm trying to achieve better than O(n) complexity.
13:15:33 <allenj12> does anyone here have an opinion on Shen?
13:15:46 <alercah> nitrix: I don't think you're going to improve the asymptotic bound
13:16:00 <alercah> assuming n is the number of vertices
13:16:05 <nitrix> I have complete freedom on the bookkeeping data and willing to make it ridiculously high if it means O(1).
13:16:10 <allenj12> just curious really, seems like it could actually enforce the properties of a say a monad_cat 
13:16:19 <allenj12> monad*
13:16:20 <nitrix> alercah: I think typical complexity is O(|V| + |E|) ?
13:16:26 <MarcelineVQ> nitrix: are you aware of convex hulls?
13:16:26 <alercah> nitrix: sounds about right
13:17:00 <nitrix> MarcelineVQ: Last time I talked about my problem, they were mentioned but I didn't explore further.
13:17:21 <nitrix> I need to mention, the shape can have holes in it.
13:17:26 <monochrom> Shen is cool. That's my opinion.
13:17:32 <nitrix> MarcelineVQ: I think that's why I ruled out convex hulls.
13:18:21 <EvanR> allenj12: it seems interesting, but the type checker isnt exactly sound
13:18:40 <Tuplanolla> I can imagine some optimizations, but I reckon you won't be able to improve the worst case, nitrix.
13:18:48 <allenj12> EvanR: how so?
13:19:12 <EvanR> the rules are written with arbitrary lisp code
13:19:20 <nitrix> Tuplanolla: I had a cool idea too with perimeters, but it does fall back to a worst case of O(n), for example, an O-ring.
13:19:29 <EvanR> so whatever worries we usually have about the type checker looping... are real
13:19:42 <nitrix> Tuplanolla: If you break the ring, you still have a complete shape, but cutting further, you have to traverse the entire ring.
13:20:15 <ocramz> what Num's are not Enum's ?
13:20:16 <Tuplanolla> Yes. I had a square connected through the center in mind too, nitrix.
13:20:18 <ocramz> Complex numbers?
13:20:37 <EvanR> morally, Double
13:20:39 <Tuplanolla> Floating-point numbers shouldn't be, ocramz.
13:21:06 <allenj12> EvanR: interesting, any hope for it in the very distant future?
13:21:42 <EvanR> hope? theres almost no documentation on it or its predecessor, so you cant even gauge if the author still has interest in it
13:21:48 <nitrix> MarcelineVQ: Tuplanolla; What happens if I don't allow holes within shapes? Does the situation improves to the convex hull thing? What's the complexity of that one?
13:22:09 <ocramz> Tuplanolla : because Enum's are isomorphic to integers ?
13:22:11 <allenj12> EvanR: yea im loooking at that now :(
13:22:30 <geekosaur> ocramz, essentially yes
13:23:20 <Tuplanolla> When I first encountered the instance, I thought the increments would be the smallest ones possible based on the representation.
13:23:36 <ocramz> Tuplanolla: that also seems natural
13:23:54 <ocramz> but in floating point precision the increments are all different in magnitude
13:24:09 <ocramz> no, sorry, erase line above
13:24:19 <EvanR> it doesnt really have increment
13:24:40 <Fairy> mauke: addToMem (index, memList) stt = (index+1, ( (index, stt) : memList ) )
13:24:56 <EvanR> but there is something called machine epsilon, either way useless for what Enum normall does
13:25:38 <Fairy> (I might be in the field picking flowers right now, for all I know :S)
13:25:53 <ocramz> Double's are bounded
13:26:11 <ReinH> Enum is a lying liar, fwiw
13:26:16 <EvanR> is it?
13:26:39 <EvanR> NaN violates the definition of sup and inf
13:26:40 <mauke> Fairy: ok, good. that's similar to the function version, except you have to effectively pre-apply lookup
13:27:51 <pikajude> does Enum specify whether enumFrom should return an increasing list
13:27:55 <mauke> Fairy: except you need to wrap the whole result in (index, ...)
13:28:19 <mauke> because you're supposed to return a pair of (Integer, Memory)
13:29:02 <mauke> Fairy: template: addToMem (index, memFun) stt = (index, (index+1, \k -> ...))
13:29:09 <EvanR> i would rethink double as a locale with 2 disconnected components, -infinity to +infinity, and 1 point NaN somewhere else
13:29:19 <EvanR> and because of NaN its a poset
13:29:37 <ab9rf> yeah, nan is a bodge
13:30:28 <geekosaur> NaN is not a single value
13:30:54 <EvanR> justification?
13:31:00 <geekosaur> there are distinct signaling and non-signaling NaNs, and NaN values can carry hardware or implementation specific information about the cause
13:31:00 <ab9rf> there are two NaNs
13:31:20 <ab9rf> NaN can also have a sign, although the sign is supposed to be irrelevant
13:31:31 <geekosaur> using the latter is nonportable, but can be helpful in debugging
13:31:49 <ab9rf> NaNs can contain payloads as well, the interpretation of which is implementation dependent
13:32:57 <ab9rf> there are 2^24 different single-precision NaN values
13:33:00 <EvanR> are these different NaNs observable by haskell?
13:33:33 <ReinH> per spec, all NaNs are different
13:33:34 <ab9rf> i don't know enough about haskell's implementation to say
13:33:41 <erisco> 1, 2, FILE_NOT_FOUND
13:33:50 <EvanR> by different, do you mean not equal
13:33:50 <ab9rf> i'm not sure how many double precision NaN alues, but it's likely larger
13:33:56 <EvanR> > (0/0) /= (0/0)
13:33:58 <lambdabot>  True
13:34:00 <geekosaur> not in the standard library but there are add-in libraries that expose this, I think
13:34:15 <pikajude> we should just have Double_ReallyANumber and Double_NotANumber
13:34:28 <ReinH> EvanR: Not the same, for the only definition of same we have.
13:34:31 <EvanR> that seems to violate referential transparency
13:34:37 <ReinH> How?
13:34:47 <geekosaur> bindings to the C functions that check various internal things, select signaling vs. nonsignaling behavior in the FPU, etc.
13:34:59 <EvanR> ReinH: shouldnt x == x ?
13:35:07 <Fairy> mauke: I don't think I follow :S
13:35:09 <ReinH> What does that have to do with referential transparency?
13:35:16 <erisco> == is user defined
13:35:27 <EvanR> ... nevermind ==...
13:35:31 <geekosaur> per the IEEE spec, no NaN is equal to any other NaN
13:35:47 <ReinH> > (0/0) < (0/0)
13:35:50 <lambdabot>  False
13:35:51 <EvanR> shouldnt you be able to convert let x = (0/0) in (x,x) to ((0/0),(0/0)) can back
13:35:51 <ReinH> > (0/0) > (0/0)
13:35:54 <lambdabot>  False
13:35:58 <ReinH> They are incomparable
13:36:12 <mauke> Fairy: do you understand the template but you don't know what you should replace '...' with, or do you not understand what I've written so far?
13:36:34 <ab9rf> it's likely that on most platforms 0/0 is the same NaN every time it's evaluated
13:36:34 <EvanR> theres only one term possible result of (0/0), its not non deterministic
13:36:39 <ReinH> > compare (0/0) (0/0) -- wah wah
13:36:41 <lambdabot>  GT
13:36:46 <ab9rf> haha
13:36:46 <ReinH> Ord is also a lying liar.
13:36:58 <Fairy> mauke: It's pretty much exactly what I got so far, but what I should replace '...' is a complete mystery
13:37:00 <EvanR> == is a pretty bad notion of sameness anyway
13:37:13 <hpc> data Ordering = LT | EQ | GT | IEEE_FLOATS_ARE_TERRIBLE
13:37:17 <geekosaur> yes, ghc's handling of NaN is incorrect, we know this. IEEE754 semantics don't map cleanly onto Haskell
13:37:28 <geekosaur> not if you're doing it strictly per spec
13:37:50 <erisco> can't we just have programs crash instead of getting NaN
13:37:59 <ab9rf> erisco: platform-specific
13:38:05 <Fairy> mauke: addToMem (index, memFunc) stt = (index, (index+1, \index -> Just stt ) )        is what I wrote initially, but this makes no sense (in addition to being very wrong)
13:38:05 <pikajude> > take 3 [(0/0)..]
13:38:07 <lambdabot>  [NaN,NaN,NaN]
13:38:09 <pikajude> wow, that's crazy
13:38:10 <EvanR> given a particular bitvector for NaN, i have a hard time swallowing "its not the same. as itself"
13:38:16 <erisco> no, it shouldn't be platform specific, that is awful
13:38:23 <mauke> Fairy: in the '...' part you're effectively in the lookup operation and someone's just asked you for the value at key 'k'
13:38:38 <erisco> no more than I'd want a platform-specific list filter, or fmap
13:38:58 <ReinH> If you can observe that "sameness", you violate the spec
13:38:59 <ab9rf> erisco: some but not all FPAs have an "throw exception instead of producing NaN", but how you enable that mode and which operations it applies to will vary
13:39:13 <EvanR> the spec sounds illogical
13:39:20 <ReinH> It is not.
13:39:31 <EvanR> well, i assume it doesnt say "its not the same as itself"
13:39:40 <pikajude> it does
13:39:42 <EvanR> just that the relation says something
13:39:42 <Tuplanolla> It sounds like something a physicist would design.
13:39:45 <erisco> compiler backend writers will have to figure it out
13:40:02 <ReinH> The spec says that NaNs are incomparable.
13:40:08 <EvanR> right
13:40:14 <ReinH> If you somehow make them comparable (by observing some notion of "sameness"), you violate the spec.
13:40:26 <mauke> Fairy: do you want another hint?
13:40:31 <ab9rf> at least haskell avoided the isanity around pow by not implementing it
13:40:37 <ReinH> The point is that regardless of representation, NaN /= NaN always
13:40:43 <ab9rf> the way pow handles NaN is freaky
13:40:45 <ReinH> that's how NaN is intended to work
13:41:09 <Fairy> mauke: given that my current understanding boils down to "...what? :S", yes please :(
13:41:11 <EvanR> that makes sense
13:41:33 <ab9rf> ReinH: the spec states that comparisons of NaN numbers should cause an exception
13:41:36 <geekosaur> EvanR, the spec is a compromise between the mathematical needs of a number of groups. the result is self-consistent but decidedly strange
13:41:40 <EvanR> but its silly to continue past that and then say "there are many NaNs..." implying some identity 
13:41:46 <ReinH> ab9rf: I don't believe that it does.
13:42:04 <ReinH> non-reflexivity is a perfectly reasonable property for a relation
13:42:07 <hpc> there are many bitfields that can represent NaN
13:42:11 <ReinH> It's just jarring when we call that relation "equality"
13:42:17 <mauke> Fairy: addToMem (index, memFun) stt = (index, (index+1, \k -> if k == index then ... else ...))
13:42:22 <ab9rf> ReinH: IEEE 754 requires an exception if the result of the operation is not another IEEE 754 number that can be NaN
13:42:31 <geekosaur> and contains things like the multiple NaN values for debugging purposes, wich for non-debugging purposes need to be treated as the same NaN but can be introspected for the debugging info
13:42:39 <ReinH> ab9rf: Isn't that different from what you said?
13:42:41 <EvanR> ReinH: call it that, and then extend its meaning to sameness
13:42:47 <mauke> Fairy: i.e. we're in the lookup operation, someone's just asked for the value under key 'k', and we've checked whether the requested key is equal to 'index'
13:42:55 <ReinH> EvanR: I don't know what that means.
13:43:01 <mauke> Fairy: what do we need to do next?
13:43:10 <Tuplanolla> Why do floating-point numbers even need equality?
13:43:34 <EvanR> you have an ordering, so that usually comes with an equality
13:43:43 <ReinH> You don't have an ordering, as I have shown.
13:43:49 <ReinH> You have a partial ordering.
13:43:52 <EvanR> .... 
13:44:05 <ReinH> since, again, NaNs are incomparable
13:44:34 <hpc> you should just read the spec
13:44:40 <hpc> the language will make more sense that way
13:44:48 <Tuplanolla> I'd prefer a floating-point specification that allows the exact value to vary within an interval, even between accesses.
13:44:51 <hpc> (the language of the spec, that is)
13:44:55 <EvanR> as i said before its a partial ordering
13:45:14 <EvanR> which is an ordering
13:45:18 <ReinH> But then you said "EvanR> you have an ordering, so that usually comes with an equality"
13:45:28 <ReinH> Which only makes sense if you mean "total order"
13:45:29 <EvanR> partial orderings also come with equality
13:45:36 <ReinH> No, they don't.
13:45:37 <EvanR> that is what makes them different from preorders
13:45:59 * EvanR politely asks ReinH to read the spec for partial orders, while knowing full well he knows what it is already
13:46:01 <ReinH> what makes them different from preorders is antisymmetry
13:46:12 <EvanR> uh huh?
13:46:17 <EvanR> which says
13:46:27 <EvanR> read the spec
13:46:29 <ReinH> lol
13:46:29 <EvanR> itll make more sense
13:46:33 <ReinH> I know what antisymmetry is
13:46:39 <joe9> need some advice, please? I am writing a 9p server. Instead of writing all the directory/file handling stuff manually, Can I reuse ZipperFS or some such filesystem library in haskell?
13:46:40 <ReinH> it doesn't imply that partial orders have a total equality operation
13:46:41 <EvanR> read the secp
13:46:52 <ReinH> I didn't tell you to read the spec
13:47:01 <ReinH> I have read the spec.
13:47:12 <EvanR> i havent been talking about "operations"
13:47:16 <EvanR> only relations
13:48:02 <ReinH> ...
13:48:09 <nitrix> Tuplanolla: MarcelineVQ I actually solved the problem in a more interesting way.
13:48:10 <EvanR> the equality referred to by partial orders is an equivalence relation
13:48:28 * hackagebot load-balancing 1.0.1.0 - Client-side load balancing utilities.  https://hackage.haskell.org/package/load-balancing-1.0.1.0 (taphu)
13:48:30 * hackagebot convert-annotation 0.2.0.1 - Convert the annotation of a gene to another in a delimited file using a variety of different databases.  https://hackage.haskell.org/package/convert-annotation-0.2.0.1 (GregorySchwartz)
13:48:32 * hackagebot legion-extra 0.1.0.2 - Extra non-essential utilities for building legion applications.  https://hackage.haskell.org/package/legion-extra-0.1.0.2 (taphu)
13:48:50 <MarcelineVQ> nitrix: A list of blocks that have only two connecting blocks?
13:49:10 * byorgey thinks ReinH and EvanR are talking past each other
13:49:19 <nitrix> Tuplanolla: MarcelineVQ Since this game happens in space and velocity is relative, I decided you can modify a ship, add and remove blocks arbitrarily, even breaking the ship into two ships, and it'll still be considered a single ship.
13:49:22 <EvanR> agreed
13:49:32 <ReinH> Yes, partial orders have partial equality
13:49:46 <ReinH> which doesn't argue against anything I have said
13:49:52 <nitrix> MarcelineVQ: Tuplanolla Until, a change in velocity happens, in which case, I traverse the ship once, O(n), detect the detached parts and mark those as new ships.
13:49:55 <EvanR> i think youre confusing ordering and equality, or decidable either one
13:50:04 <ReinH> I'm pretty sure I'm not.
13:50:11 <EvanR> what is "partial equality" ?
13:50:18 <nitrix> Thus I pay the O(n) cost only once, when it's necessary, after a batch of updates were done.
13:50:22 <ReinH> The equality relationship you describe is not defined for all pairs
13:50:29 <ReinH> only those for which a <= b and b <= a
13:50:36 <EvanR> its not defined for all pairs anyway
13:50:41 <ReinH> i.e., (a,b) and (b,a) must both be in the relation
13:50:55 <joe9> found this, https://hackage.haskell.org/package/FileSystem , but am not sure if there is anything better out there.
13:50:59 <EvanR> (1,2) doesnt exist
13:50:59 <Tuplanolla> Shouldn't you prefer consistent and predictable performance over savings if you're working with a game, nitrix?
13:51:04 <ReinH> And NaN is not part of the relation at all
13:51:05 <joe9> is ZipperFS better than using the FileSystem package?
13:51:15 <ReinH> so your arguments about equality don't affect NaN
13:51:30 <Tuplanolla> Carmack has talked about this recently, nitrix.
13:51:38 <byorgey> in order to define a partial order you must already have an underlying equality in mind.  Otherwise you can't even state the antisymmetry law.
13:52:16 <EvanR> you agreed its a partial order, but now it seems you should disagree on the basis that equality doesnt work the way you want... which im still not understanding
13:53:06 <ReinH> I'm still not sure what point you're trying to make about partial orders
13:53:29 <ReinH> There is no number n for which (n,NaN) or (NaN,n) is a member of the partial ordering relation
13:54:12 <ReinH> Which implies that there is also no number n for which n == NaN is true.
13:54:25 <EvanR> i introduced a different organization of the Double values (that we can see normally), which obviously ignores all current typeclass instances for Double, which obviously contradicts whatever specs, which we do anyway, and you havent referred to this so it doesnt matter
13:54:26 <ReinH> This includes NaN.
13:54:36 <EvanR> in which case there is a partial order for real
13:54:58 <ReinH> The partial order we were already talking about is not fake
13:55:01 <EvanR> er floats
13:55:07 <EvanR> er "for real" meaning "for serious"
13:55:09 <nitrix> Tuplanolla: The thing is, you're paying the O(n) cost regardless, I'm just avoiding to compute it at every single modification done on the structure, and only when the health of the structure is relevant.
13:55:28 <ReinH> It just doesn't include NaN, which is what the spec says.
13:55:45 <Tuplanolla> I guess that's fine then, nitrix.
13:55:52 <EvanR> if it doesnt include NaN why is it partial?
13:56:03 <EvanR> if youre restricting to non NaN
13:56:09 <EvanR> (non NaN not strictly making sense)
13:56:11 <nitrix> Tuplanolla: Thus, it'll allow me to perform tons of updates to a ship, and when the ship's velocity changes, and updates were performed, I can recompute that it got broken into multiple parts and mark some of those parts a new ships that'll move indenpendently of one another.
13:56:26 <ReinH> Why am I being asked to defend claims I never made?
13:56:35 <ReinH> it's partial *because* it doesn't include NaN
13:56:39 <geekosaur> I think you are confused. you can't remove NaN from Double, therefore there is a partial ordering relation that excludes NaN
13:56:53 <Tuplanolla> It seems that you both understand what the issue is, but keep disagreeing.
13:56:55 <ReinH> NaN is a member of the set
13:56:55 <nitrix> Tuplanolla: It's ehm.. I guess it's... lazy physics?!
13:57:01 <nitrix> Is that a thing :P Lazy physics?
13:57:01 <ReinH> but NaN is not a member of the relation
13:57:02 <EvanR> if NaN is in the domain, then your equivalence relation doesnt exist
13:57:19 <ReinH> "My" equivalence relation?
13:57:27 <EvanR> the one you need for antisym
13:57:41 <ReinH> Why not?
13:57:51 <EvanR> because it doesnt obey the laws
13:57:57 <EvanR> x=x
13:58:03 <puregreen> is there a way to make `[|foo + bar|]` resolve to something if `foo` and `bar` aren't in scope?
13:58:09 <ReinH> What is "it"?
13:58:27 <ReinH> x=x is not a law
13:58:35 <EvanR> its a guideline?
13:58:57 <hpc> it's official, IEEE floats are governed by the pirate's code
13:59:48 <EvanR>  💀
13:59:51 <EvanR> x=x
13:59:54 <ongy> puregreen: do you want a replacement? or what would you want to happen?
13:59:56 <ReinH> You're the one claiming there's an equivalence relation and then, apparently, using that claim to prove that there's an equivalence relation
14:00:08 <ReinH> NaN /= NaN
14:00:21 <EvanR> i disagre with both the premise and conclusion of that
14:00:22 * byorgey thinks EvanR and ReinH should stop
14:00:36 <byorgey> you're not communicating, you're just filling up the channel.
14:00:52 <EvanR> ok
14:01:24 <byorgey> IRC is not a good medium for these sorts of discussions that hinge on being very precise and pedantic with definitions etc.
14:01:46 <hpc> technically it's not being pedantic if the distinction is useful
14:01:48 * hpc ducks
14:02:20 <ReinH> I'm not really sure what the point of the argument even is
14:02:30 <byorgey> ReinH: another good reason you should stop. =)
14:02:33 <byorgey> hpc: fair point.
14:02:34 <ReinH> Indeed.
14:02:44 <ReinH> hpc: now you're just being pedantic
14:03:24 <hpc> ReinH, byorgey: you're both right ;)
14:04:28 <Fairy> mauke: addToMem (index, memFunc) stt = (index, (index+1, \x -> if x == index then Just stt else memFunc x ) )          crud that took me way more time than it should have
14:04:43 <mauke> nice
14:04:52 <puregreen> ongy: I'm generating migration instances with TH, but for simplicity let's say I want to generate the following: “a = 0; b = a; c = 2*a + b” by calling “generate [[|0|], [|a|], [|2*a+b|]]”. Neither `a`, `b` or `c` exist at the moment of call, but by the time `[|a|]` is parsed, `a = 0` will be already available – or rather it *should* be available, but I haven't found a way to add a declaration to the environment
14:04:52 <puregreen> inside a Q call
14:05:21 <ph88> does someone know an alternative to uniplate ?
14:05:45 <puregreen> in fact, currently “generate [[|0|], [|a|], [|2*a+b|]]” fails at the parsing stage because `a` and `b` aren't in scope, without even a chance to start executing
14:06:09 <Fairy> mauke: Thanks A LOT for your help! <3
14:06:18 <puregreen> I want to somehow change this. Currently my only options seem to either be reimplementing a Haskell parser or using haskell-src-meta or something
14:07:53 <geekosaur> sounds like you are hitting the staging restriction, and there may not be a fix
14:08:35 <mauke> Fairy: you're welcome!
14:08:45 <lispy> ph88: there's a few. like multiplate. Also, there was an example for lens that reimplements one of the generic programming libraries (uniplate?)
14:09:53 <ReinH> lens has Plated
14:10:03 <ReinH> which I have used to do similar things
14:10:41 <ongy> puregreen: if I'm not terribly mistaken you can look things up in the splices context instead of the TH code context, though that isn't with quasi quotation and may not work if it's generated in the same splice
14:10:54 <lispy> I remember there being a bit of buzz about Plated because it was more efficient
14:11:19 <ReinH> It was easier to use, at least.
14:11:27 <ReinH> and already in lens
14:13:08 <ReinH> Then again, once you add a lens dependency half of hackage is already installed anyway >_<
14:13:18 <ab9rf> heh
14:14:00 <Tuplanolla> :t confusing
14:14:02 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
14:14:04 <Tuplanolla> "Is lens confusing?" "No; lens has confusing."
14:14:45 <Sonolin> any reason why matchRegex is dropping unicode text (and everything afterwards)?
14:15:22 <Sonolin> is Text.Regex not unicode friendly?
14:15:40 <lispy> Sonolin: it would help to have an example
14:15:55 <geekosaur> Sonolin, some of the backends are not (or not necessarily) UTF8
14:16:16 <geekosaur> the pure Haskell one is. the one that uses OS libs is only as UTF8 safe as the OS libs are
14:16:43 <Sonolin> hmm ok I'm on Linux (using Posix I'm assuming)
14:16:53 <Sonolin> just tried lpaste but looks like its down atm
14:17:04 <Sonolin> my regex: mkRegex "<a [^>]*href=\"[^\"]*/([0-9]+)\"[^>]*>([^<]+)"
14:17:24 <geekosaur> Text.Regex.Posix will depend on the OS libs being UTF8 safe, yes. I think last time someone checked the default Linux libs were not UTF8 safe
14:17:35 <Sonolin> ah ok
14:17:58 <Sonolin> actually I might be able to get away not using regex for this part (the name at least)
14:17:59 <geekosaur> I think that time they ended up using one of the pcre libs on hackage, after verifying that they had a UTF8 aware build of the PCRE libs
14:19:43 <geekosaur> the pure-Haskell backend (Text.Regex.TDFA) is slower but reliably UTF8 aware
14:19:54 <Sonolin> oh nice... good to know
14:20:16 <Sonolin> I think I'll just use regex for the ID part in the link, and use tagsoup to strip the A tag
14:20:23 <Sonolin> probably more maintanable anyway
14:20:41 <EvanR> a parser might be more maintainable still
14:20:52 <isovector> hey all! i'm working with some spooky type-level stuff, and ghci keeps renaming my types
14:21:07 <Sonolin> you mean as in making this function a Parser itself?
14:21:19 <isovector> `Dict \\ (Sub Dict :: () :- c (h ('Left a1)))` complains about `Could not deduce: c (h ('Left n0)) arising from a use of ‘Dict’`
14:21:30 <EvanR> instead of using regex to validate or "parse" something, you could use an attoparsec parser for example
14:21:35 <isovector> it's renamed `a1` => `n0`. is there some way to stop this from happening?
14:21:37 <Sonolin> ah I see
14:22:01 <Sonolin> yea I'll look into that, something to think about
14:22:19 <EvanR> in applicative form you could get it to be around the size of a regex, i think. if you spelled out each regex operation by name
14:22:46 <EvanR> (oh yeah, theres regex-applicative)
14:22:53 <geekosaur> isovector, not with the information you have provided. ghc is correct here, you have not specified your types precisely enough and it cannot unify them as specified, so it is renaming to reflect that.
14:23:15 <Sonolin> well I'll probably use tagsoup for now, already in the project anyway... this should really be an API endpoint but still holding out for that
14:23:16 <geekosaur> ScopedTypeVariables used correctly *might* help; it depends on what exactly you are doing
14:23:18 <geekosaur> @paste
14:23:18 <lambdabot> Haskell pastebin: http://lpaste.net/
14:27:17 <isovector> geekosaur: https://gist.github.com/isovector/1e9e6eecb216c9a5cea6215b13c1ebcd honestly it'd be hard to add more type annotations :)
14:27:53 <geekosaur> adding them can actually make it worse, since it could infer the correct types otherwise. if you do have to add them, though, then this may well be scoped type vars material
14:29:59 <geekosaur> oh, urgh. that is nasty (and beyond my limited type hackery)... the type vars you need to scope aren't in the top level signature, are they
14:30:44 <geekosaur> the problem being that the a1 in the first signature is not the a1 in the second signature, and a forall won't help there because it would limit the scope even more instead of extending it
14:31:14 <geekosaur> in fact having the type sigs prevents them from unifying as ghc thinks you are explicitly saying they are different!
14:31:31 <geekosaur> btu I have no idea how you correct that in this case :(
14:31:51 <geekosaur> maybe you can add a1 to the top level forall and it will do the right thing...
14:32:00 <isovector> geekosaur: that's interesting. thanks for the tip :)
14:33:32 <Tuplanolla> Is it possible to add `forall a1.` to the signature of `s1`?
14:33:40 <carls> 1
14:33:48 <Tuplanolla> I didn't try it, but I feel like that should work, isovector.
14:33:52 <geekosaur> it won't
14:34:06 <geekosaur> that was what I meant by "a forall won't help there because it would limit the scope even more instead of extending it"
14:34:16 <geekosaur> only foralls at the top level will do the right thing
14:35:03 <Tuplanolla> Huh, that sucks. Do you have to mention `a1` in the top level signature if you add it in?
14:35:41 <geekosaur> that's my worry as well, which is why I said "maybe ... it will do the right thing"
14:35:55 <Tuplanolla> :t id :: forall a b. a -> a
14:35:57 <lambdabot> a -> a
14:35:59 <geekosaur> because I don't see what else would. but this probably needs the type level heavy hitters around, not just me
14:36:21 <Tuplanolla> At least it seems that `b` was forgotten there.
14:37:11 <Tuplanolla> One option would of course be to add a `Proxy` parameter and quantify over its type.
14:37:47 <Tuplanolla> :t const id :: forall a b. Proxy b -> a -> a
14:37:48 <lambdabot> forall k a (b :: k). Proxy b -> a -> a
14:48:30 * hackagebot stb-image-redux 0.1.0.4 - Image loading and writing microlibrary  https://hackage.haskell.org/package/stb-image-redux-0.1.0.4 (sasinestro)
14:48:32 * hackagebot legion-discovery 0.2.1.0 - Initial project template from stack  https://hackage.haskell.org/package/legion-discovery-0.2.1.0 (taphu)
14:48:34 * hackagebot active 0.2.0.12 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.12 (BrentYorgey)
14:48:36 * hackagebot force-layout 0.4.0.6 - Simple force-directed layout  https://hackage.haskell.org/package/force-layout-0.4.0.6 (BrentYorgey)
14:49:44 <erisco> the premise of singletons is simple, but the library seems hopelessly obscure
14:54:12 <c_wraith> fwiw, the authors of the package hope to replace it with type system extensions. :) 
14:55:37 <c_wraith> ... at last report, that's expected to land around 8.6... so far in the future... 
14:57:17 <erisco> AI will have replaced our jobs by then
14:58:02 <nitrix> kadoban: I'm going with the O(n log m) strategy, except, `m` is the amount of blocks the ship has, and `n` is the amount of modifications performed since the last run of the algorithm.
14:58:35 <nitrix> kadoban: I'm keeping a list of modifications performed and only run DFS floodfill from those.
14:58:44 <erisco> I am hijacking the type system as a variable substitution engine… that's fun
14:58:56 <nitrix> This way I necessarily catch all segments possibly created.
14:59:05 <c_wraith> isn't that the point of things like HOAS? 
15:01:02 <erisco> higher-order asymptotic solenoids?
15:01:42 <c_wraith> close! 
15:01:51 <c_wraith> higher order abstract syntax. 
15:02:21 <nitrix> I'm gonna start strapping higher-order to everything now.
15:02:30 <nitrix> High-order coffee. Higher-order shower.
15:02:56 <erisco> mm, haven't looked at that in a long time… I forget
15:03:04 <nitrix> Higher-order-dunning-kruger.
15:03:06 <geekosaur> higher order *abstract* coffee
15:03:15 <nitrix> :O
15:03:31 <nitrix> Is there a Java joke?
15:03:33 <nitrix> :P
15:04:06 <erisco> higher-kinded polymorphic coffee coming soon
15:04:35 <nitrix> Oh I'm on the wrong channel.
15:04:43 <nitrix> Sorry for the unusual noise.
15:05:37 <erisco> I figured you meant to be on #onomatopoeia
15:07:03 <erisco> lol
15:09:08 <ab9rf> mmm, polymorphic coffee
15:10:10 <ski> is it nontrivially homeomorphic to itself ?
15:11:13 <ab9rf> no, but the cup it's in is nontrivially homeomorphic to a wide variety of breakfast pastries
15:14:56 <lilred> What´s a good environment for writing LaTeX? I´d like something with a live preview pane ideally
15:15:11 <lilred> (alternatively: which channel would be a better place to ask?)
15:15:34 <erisco> c_wraith, I haven't a need for any values though
15:15:53 * ski blinks
15:16:04 <erisco> Haskell will unify types but won't do similarly for values
15:16:32 <erisco> so you can have  a -> a -> a  for example and it will unify whatever you provide
15:16:39 <Tuplanolla> The real question is why LuaTeX exists, but HaskellTeX does not.
15:16:42 <erisco> but if you have  \x x -> x  this is just an error
15:16:57 <Tuplanolla> I'm completely sick of LaTeX as a programming language.
15:17:06 <ongy> lilred: there's #latex. Otherwise I would mostly consider it offtopic and point to -blah
15:17:12 <erisco> and == is not the same thing either
15:17:35 <erisco> so if you have expressions with holes in them, this unifying fits in perfectly
15:17:58 <PhsShft> I just wrote really redundant code, can someone take a look and walk me through simplifying it?
15:18:03 <PhsShft> http://lpaste.net/260674
15:18:06 <PhsShft> it’s not very long
15:18:26 <erisco> so I can write the rules for constructing propositions, for example, and it works out splendidly
15:18:39 <PhsShft> I just feel like I’m always writing the exact same code, which is not very good sign in haskell
15:18:45 <ab9rf> PhsShft: i don't see how you'd simplify that
15:19:08 <ski> PhsShft : remove all the `@'-patterns
15:19:11 <ab9rf> PhsShft: other than by establishing a Polygon type
15:19:17 <ab9rf> yeah, the @ patterns are unneeded
15:19:26 <erisco> though I have to be a bit careful because it is more powerful than I actually want in the system
15:19:40 <ab9rf> Triangle and Quadrilateral are both instances of a more generic Polygon
15:19:43 <ski> possibly factor out the branches into separate (helper) functions
15:19:46 <erisco> in which case, singleton values help because the inferred types are okay
15:19:47 <ab9rf> but you might not want to have generic Polygons
15:20:08 <nitrix> You actually can.
15:20:11 <nitrix> `on`
15:20:15 <PhsShft> :ab9rf  I’m required to do shapes seperatly, I’ll remove the @ patterns
15:20:36 <ab9rf> PhsShft: any thought to use a typeclass here?
15:21:01 <PhsShft> :ab9rf for different shapes?
15:21:14 <ab9rf> eh, it would require a different approach, nevermind me
15:21:40 <ski> (perhaps a type class for lattices would be nice here ?)
15:21:58 <erisco> propAnd . (propT △ (propNot . propT))  gives  Rule () (Prop' (And' T (Not' T)))
15:22:29 <ab9rf> it would let you add additional geometric primitives without having to rewrite a big ugly case somewhere
15:23:41 <erisco> so I think it is quite possible to have a rudimentary proof system this way
15:27:37 <Fairy> Given that   lookupMem :: Memory -> Integer -> Maybe Stt      and     lookupCtx ctx "var"    returning   Just 0     am I correct in assuming that      lookupMem mem (lookupCtx ctx' "var")     is a nonsensical statement?
15:28:55 <ski> correct
15:29:22 <ski> use `case' (e.g.)' to handle the `Nothing' and `Just n' cases
15:30:02 <joe9> Any library recommendations to represent a file-system-like data?
15:30:02 <ski> (or a separate function defined by pattern-matching, or `maybe', or `fmap', or `(>>=)' ..)
15:30:04 <joe9> please?
15:30:07 <Fairy> Can I make lookupMem accept Maybe Integer without changing it's type declaration?
15:30:22 <ski> only by changing how you call it
15:30:24 <joe9> I am reading on Zipper for that. Not sure if there is anything better out there?
15:30:41 <geekosaur> lookupCtx ctx' "var" >>= lookupMem mem
15:31:05 <ski> e.g. `fmap (lookupMem mem) (lookupCtx ctx' "var")' will get you a `Maybe (Maybe Stt)'
15:31:14 <Fairy> I've never seen >>= before
15:31:16 <ski> if you wanted a plain `Maybe Stt', then what geekosaur said
15:31:27 <ski> @src Maybe (>>=)
15:31:27 <lambdabot> (Just x) >>= k = k x
15:31:27 <lambdabot> Nothing  >>= _ = Nothing
15:31:51 <ski>   lookupMem mem =<< lookupCtx ctx' "var"  -- might read more nicely. it's the same thing, though
15:32:00 <joe9> Data.Tree?
15:32:47 <ski> Fairy : but the most explicit way, is to use `case', or a separate definition with pattern-matching
15:33:24 <ski>   case lookupCtx ctx' "var" of
15:33:30 <ski>     Nothing -> ...
15:33:31 <ski>     Just n  -> lookupMem mem n
15:33:35 <erisco> Data.Tree should work
15:33:36 <Fairy> It's extremely frustrating when the lecturer provides you with a task full of mistakes :S
15:33:50 <ski> if you use `(>>=)' as above, it'll behave the same as if `...' there was `Nothing'
15:33:50 <erisco> yeah, well, real jobs can be like that too ;)
15:34:02 <Tuplanolla> You can hand in an errata with your answer, Fairy.
15:34:08 <geekosaur> often even more so
15:34:08 <erisco> "make it pop"
15:34:39 <ab9rf> sometime syou can use <$> to get useful rsults in situatin like this
15:35:00 <ski> Fairy : `(>>=)' is a function that's useful for "chaining" potentially-"failing" functions, like your `lookupCtx' and `lookupMem'
15:35:26 <ski> Fairy : any "intermediate" `Nothing' result will "short-circuit" the chain. otherwise it'll continue
15:35:29 <ab9rf> Fairy: i think some instructors do that on purpose
15:35:57 <ab9rf> both Maybe and Either are good for that sor tof thing
15:36:10 <ski> Fairy : `(>>=)' is actually more general, part of this type class called `Monad', but you probably needn't worry that much about that for the moment ..
15:36:47 <Fairy> ab9rf: I'm relatively certain that isn't the case here. I usually enjoy those tasks, but with my current task, I'm spending more time trying to figure out what's expected of me, rather than what I should actually do to solve it
15:37:24 <ReinH> Welcome to programming, it will be like this for the rest of your life.
15:37:50 <Fairy> :)
15:38:06 <ab9rf> Fairy: figuring out what you are expected to do sounds like 90% of my job back when i worked for a living
15:38:19 <Tuplanolla> It's even better when you're the one with expectations you don't understand, Fairy.
15:38:47 <ab9rf> you never get assignments to "write a hunk of code to do <some easily explained technial thing>"
15:39:17 <erisco> though both with a job and self-employment you are being charged for the privilege of confusion
15:39:26 <erisco> are not being charged
15:39:26 <ab9rf> it's "figure out a way to compute the net future value of an income stream using this amortization schedule and the following set of assumptions"
15:40:27 <ab9rf> or "find the least expensive way to get this box of widgets to Seattle before Tuesday at 11am"
15:40:28 <erisco> or my favourite… "make a score for how good the thing is"
15:41:40 <Fairy> I actually get giddy thinking about that last one
15:41:47 <ab9rf> or the related, "given a set of things, pick the best one" (where "best" is unspecified)
15:42:04 <erisco> what thing, sir? "you know, the sales". do you want revenue? profit? quantity of sales? "yeah, use all of them"
15:42:44 <monochrom> maximize their revenue, but minimize their profit
15:42:58 <Fairy> "Give me a team of 6 people and six months, we'll make our own, surely we can do better than what the alternatives provide"
15:43:04 <ab9rf> erisco: i've been asked to solve the traveling salesman problem at least three times
15:44:30 <erisco> I recommend a salesperson for each city, reducing travel costs to zero.
15:45:02 <monochrom> Oh, I do have a great slogan for supporting that.
15:45:27 <monochrom> "Salespersons are revenue centres. So if you hire more of them, you're maximizing revenue!"
15:45:54 <ab9rf> a surprisingly large set of real work problems turn into knapsack problems
15:46:24 <erisco> you mean how to deal with the moldy sandwich you left in?
15:46:35 <monochrom> that's knapsnack :)
15:46:39 <ab9rf> anyhow, it's pretty much a slice of real life experience to be given a problem that requires more work to figure out what you're being asked to do than to actually do it
15:47:23 <erisco> receiving a fully detailed technical specification has… never happened to me
15:47:38 <ab9rf> my first "real" job i was hired to improve performance on a webapp they were running. i fixed it on the second day.
15:47:43 <ab9rf> by adding an index.
15:47:54 <erisco> they were using MySQL
15:48:26 <ab9rf> it was a content indexing engine, and they were searching the content abstracts but weren't indexing the abstracts
15:48:31 * hackagebot publicsuffix 0.20161014 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20161014 (wereHamster)
15:48:40 <ab9rf> so it took FOREVER to actually traverse the entire content database
15:49:15 <Fairy> That was like the first thing they taught us in SQL, lol
15:49:17 <ab9rf> two comamnds (one to tell it to index that property, anther to force a rebuild) and it was about 98% faster
15:49:25 <erisco> should have just bought more RAM
15:49:55 <monochrom> no, download more RAM :)
15:50:13 <ab9rf> you will never get a technical specification of a problem that is any use at all
15:50:30 <ab9rf> "Write an app that can detect when a bird shits on my car."
15:50:57 <erisco> that's easy
15:51:01 <monochrom> OTOH, if the cause is a dumb quadratic-time algorithm you should download more CPUs and map-reduce instead.
15:51:07 * ski . o O ( "outsource bandwidth" )
15:51:10 <erisco> first we add bird droppings to the Internet of Things
15:51:23 <ab9rf> use nanobots to inject RFIDs into the birds
15:52:15 <ab9rf> i'm reminded of the guy with the internet-enabled kettle that crashed his network when he tried to set it up
15:52:17 <monochrom> No, just change it to "write an app that can detect when a bird shits on my car, with only 98% accuracy".
15:52:28 <erisco> what is the point of the cloud if you cannot quadratically scale up
15:52:33 <kadoban> erisco: Even easier, just make it a daily report: "Yes, a bird shat on your car today." You don't even need to change the text at all, it's always true.
15:52:37 <monochrom> Then your app can simply say "no" and it will have 98% accuracy.
15:53:26 <ab9rf> plus,you have plausible deniability "sir, i think that's a bug splat. bug splats are not covered by this application, see the terms of service, apragraph 17(b)."
15:53:27 <erisco> kadoban, park under less trees perhaps. Maybe monochrom can help you out
15:53:39 <kadoban> I solve the problem by not having a car.
15:53:45 <Tuplanolla> You could also make it report "yes" and sell it with an extra feature that cleans the shit too.
15:54:36 <erisco> "I can't even see it, thank goodness I have this app!"
15:57:27 <erisco> how can you encode structural induction in a proof system
15:57:49 <erisco> somehow you have to quantify all the ways to make something
15:57:57 <PhsShft> for the use of “case of”, can do do multiple cases in one line? for example:   case a of a=x || y -> something
15:58:09 <ski> separate branches with `;'
15:58:09 <erisco> and then have a way to show you've demonstrated all the ways
15:58:27 <PhsShft> sry, bad example
15:58:34 <PhsShft> let me rephrase it 
15:58:51 <PhsShft> for the use of “case of”, can you do multiple cases in one line? for example:  case a of x || y -> something
15:58:57 <ski> > case lookup "foo" [("foo",2),("bar",3)] of Nothing -> "Sorry"; Just n -> "Ok : " ++ show n
15:58:59 <lambdabot>  "Ok : 2"
15:59:01 <ski> > case lookup "baz" [("foo",2),("bar",3)] of Nothing -> "Sorry"; Just n -> "Ok : " ++ show n
15:59:03 <lambdabot>  "Sorry"
15:59:23 <erisco> I suppose this isn't Haskell… what channel then
15:59:35 <erisco> -offtopic likely
15:59:41 <erisco> or is it -overflow
15:59:44 <ContessaTP> I can help you with structural induction erisco
15:59:54 <monochrom> erisco: I think it can be expressed directly instead of encoding. You add a rule corresponding to the typing rule of a catamorphism (aka fold, aka foldr if list is an example)
16:00:13 <erisco> join me on #haskell-overflow
16:00:18 <ContessaTP> ok
16:00:29 <Lotophagist> what's going on there?
16:00:48 <PhsShft> :ski are you talking to me?
16:00:59 <ski> PhsShft : i was
16:01:21 <Fairy> if I have some data type that holds only one value (for example: Number Integer), is it possible to write a generic function that given an arbitrary type, returns its value? SomeType Integer -> Integer
16:01:24 <PhsShft> oh so you just use “;”
16:01:27 <PhsShft> i see
16:01:53 <ski> Fairy : istr there's something like `Copointed'
16:02:02 <ski> Fairy : otherwise, see `extract' in `Comonad'
16:05:39 <isovector> Fairy: use a GADT?
16:06:43 <mauke> Fairy: no, because the shape of a type says nothing about the shape of its values
16:23:43 <Hanslo> Does $ and <$> have the same meaning? I haven't had luck of finding any documentation on it yet.
16:25:17 <ab9rf> no
16:25:18 <juri_> not at all.
16:25:24 <ab9rf> $ is just the same as . but with different fixity
16:25:38 <ab9rf> <$> is an almost entirely different beest
16:26:12 <ab9rf> ignore me, i'm too tired to type sensibly.
16:26:29 <ab9rf> $ is function application with different fixity, not .
16:26:49 <Hanslo> Ah ok, this is going to lead me to a sequence of questions because I am also unfamiliar with . as well 
16:26:59 <ski> `$' is not the same as `.'
16:27:21 <Hanslo> I stumbled upon <*> and <$> and I was wondering if there is any documentation on it I may have missed
16:27:21 <ski> @type ($)
16:27:22 <ab9rf> ski: my son is yelling at me about things i don't understand, i'm not exactly operating on all barrels right now
16:27:23 <lambdabot> (a -> b) -> a -> b
16:27:23 <ski> @type (<$>)
16:27:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:27:33 <ski> @type (<*>)
16:27:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:27:39 <ski> @type (=<<)
16:27:40 <lambdabot> Monad m => (a -> m b) -> m a -> m b
16:27:54 <ab9rf> those last three are all fairly well related to one another
16:28:01 <ski> Hanslo : those two belong to the type class `Applicative'
16:28:29 <Hanslo> ski: Thank you, i will look into it 
16:28:44 <ski> Hanslo : are you familiar with `Monad' ?
16:28:56 <ski> Hanslo : how about `Functor' ?
16:29:40 <Hanslo> I have a very vague understanding of both of them. 
16:30:02 <ski> `(<$>)' is exactly the same thing as `fmap'
16:30:18 <Hanslo> ah ok, that I understand
16:30:25 <joncol> OK, so I tried making my first (very simplistic) 2-phase compiler (converting ugly graphs to nicer graphs). I am a bit unsure if the result is idiomatic. Especially the second pass and representation of the intermediate data structure. If anyone would like to take a look, I put the code at https://github.com/joncol/graph-converter. It's 285 lines. Any feedback welcome! I'm trying to learn...
16:30:28 <ski> `liftM', though being related to `Monad', does the same thing
16:30:50 <ski> `(<*>)' is similar to the `ap' operation for `Monad's
16:30:53 <ski> @src ap
16:30:53 <lambdabot> ap = liftM2 id
16:30:59 <ski> @type ap
16:31:01 <lambdabot> Monad m => m (a -> b) -> m a -> m b
16:31:31 <ski> basically, every instance of `Monad' is also an instance of `Applicative' (and thus also of `Functor')
16:31:42 <ski> (but not necessarily in the other direction)
16:32:35 <Tuplanolla> You overuse `try` and would probably be better off with Megaparsec, but other than that, it looks good at a glance, joncol.
16:32:51 <Hanslo> ski: ah! ok, thanks for pointing me in the right direction. 
16:33:19 <joncol> Tuplanolla: OK, thanks!
16:33:31 <joncol> Megaparsec > Parsec?
16:34:14 <Tuplanolla> It's an improvement.
16:35:21 <ski> Hanslo : `liftM3 f ma mb mc' is the same as `liftA3 f ma mb mc' is the same as `f <$> ma <*> mb <*> mc' (is the same as `pure f <*> ma <*> mb <*> mc')
16:37:32 <erisco> @quote ski Hanslo : `liftM3 f ma mb mc' is the same as `liftA3 f ma mb mc' is the same as `f <$> ma <*> mb <*> mc' (is the same as `pure f <*> ma <*> mb <*> mc')
16:37:32 <lambdabot> No quotes match. I am sorry.
16:37:39 <erisco> d'oh
16:37:59 <haskell282> So say I have a monad transformer, something like MaybeT IO a, is there a way to make that showable the same way Maybe a would is showable?
16:38:02 <ski> `@remember' ?
16:38:12 <erisco> Done.
16:38:35 <ski> @ghc
16:38:35 <lambdabot> Urk! Inventing strangely-kinded void TyCon: :t{tc a5gUj} (* -> *) -> * -> *
16:38:53 <erisco> the ski-Hanslo factoid
16:38:56 <erisco> @quote ski Hanslo
16:38:56 <lambdabot> ski says: Hanslo : `liftM3 f ma mb mc' is the same as `liftA3 f ma mb mc' is the same as `f <$> ma <*> mb <*> mc' (is the same as `pure f <*> ma <*> mb <*> mc')
16:39:17 <dmwit> haskell282: Not really. IO actions can't be shown.
16:39:53 <erisco> liftM3 needs to go away now
16:39:54 <dmwit> ?quote ski
16:39:54 <lambdabot> ski says: ("unique among types, `Void -> X' has its own charm. tourists should definitly pay a visit")
16:40:32 <dmwit> delightful
16:41:44 <dmwit> joncol: You might like
16:41:48 <dmwit> ?hackage graphviz
16:41:48 <lambdabot> http://hackage.haskell.org/package/graphviz
16:42:23 <joncol> dmwit: Yes I looked at that, and tried to load my files with it, but I only got parse errors.
16:42:44 <haskell282> dmwit: darn, that makes sense. Thanks tho :)
16:42:55 <dmwit> joncol: Interesting! Perhaps it's worth trying to cook up a minimal example and sending in a bug report.
16:43:37 <ski> @quote until.I.do
16:43:37 <lambdabot> WalterBright says: I'm uncomfortable programming in languages I haven't written a compiler for, as I don't understand them until I do.
16:44:18 <joncol> dmwit: Yes, I don't really know the .dot language too well. It might very well be my dotfiles that are wrong. But I think I got `dot` to work and graphviz bailed.
16:44:40 <joncol> I'll look into it.
16:46:16 <neonfuz> I don't understand why foldr and foldl's arguments are in the order that they are in
16:46:34 <neonfuz> does foldr actually have to find the last element of a list before beginning execution? Why does foldr work on infinite lists?
16:46:43 <ski> it does not
16:47:10 <ski> > foldr (+) z [a,b,c]
16:47:12 <lambdabot>  a + (b + (c + z))
16:47:20 <ski> > foldl (**) z [a,b,c]
16:47:22 <lambdabot>  ((z**a)**b)**c
16:48:05 <ski> the rough idea is that the state in the `foldl' case comes from the left, and the "state" in the `foldr' case comes from the right
16:48:13 <neonfuz> how do you get lambda bot to show that output?
16:48:24 <ab9rf> neonfuz: lambdabot is clever
16:48:24 <neonfuz> can I do that with ghc?
16:48:27 <ski> i just type `> ' in front of an expression to evaluate
16:48:33 * hackagebot legion-discovery-client 0.1.0.0 - Client library for communicating with legion-discovery.  https://hackage.haskell.org/package/legion-discovery-client-0.1.0.0 (taphu)
16:48:39 <ab9rf> neonfuz: lambdabot's code is on hackage
16:48:55 <geekosaur> neonfuz, expanding computations like that is the simple-reflect package on hackage
16:49:18 <ski> @hackage simple-reflect
16:49:19 <lambdabot> http://hackage.haskell.org/package/simple-reflect
16:49:23 <ski> neonfuz ^
16:50:13 <ski> neonfuz : `foldl' doesn't work on infinite lists, because it's tail-recursive
16:50:32 <neonfuz> does foldl?
16:50:45 <ski> neonfuz : `foldr' *can* work on infinite lists, in case the argument function is non-strict in the "state" input
16:50:59 <ski> @src foldl
16:50:59 <lambdabot> foldl f z []     = z
16:50:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:51:10 <ski> it's tail-recursive, yes
16:51:43 <ski> it'll insist on running 'til the end of the list, before yielding back a useful result (`z')
16:51:54 <ski> @src foldr
16:51:55 <lambdabot> foldr f z []     = z
16:51:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:52:18 <ski> `foldr' otoh will hand over control to `f', to decide whether the recursive call should actually be performed (demanded/forced)
16:52:20 <neonfuz> where do these sources come from?
16:52:35 <ski> hand-written snippets for a few common operations
16:53:46 <ski> @where src
16:53:46 <lambdabot> The fixed database for the `src' lambdabot command is at <https://github.com/lambdabot/lambdabot/blob/master/lambdabot/State/source>
16:55:08 <RouxTheDay> Is there a guide to setting up lambdabot locally?
16:55:56 <monochrom> > foldr (||) undefined (repeat True)
16:55:58 <lambdabot>  True
16:57:18 <monochrom> foldl will give you an infinite loop. laziness will not help. laziness is just a bunch of boring rules rather than "let me be a smart mathematician".
16:58:01 <monochrom> however, those boring rules do explain why foldr (||) has much better luck
17:07:10 <monochrom> wait what? haskell platform minimal is only 30MB less than haskell platform full (230MB)?
17:07:56 <Tuplanolla> @pl \ x -> f (g x) x
17:07:56 <lambdabot> f =<< g
17:08:42 <elrikdante> Hi all: I'm trying to get rid of the annotated line: http://lpaste.net/260998
17:09:08 <elrikdante> I'm not sure if I can rewrite the sort in a way that helps me get rid of that case.
17:09:42 <elrikdante> without it the commented out search in main will fall into a loop
17:09:59 <monochrom> I think that the [x] case is necessary and you cannot get rid of it.
17:11:25 <elrikdante> got it thanks monochrom
17:11:56 <grantwu> You could avoid generating the empty case
17:12:19 <grantwu> eh, nvm, that makes no sense
17:12:32 <elrikdante> np, thanks anyways
17:13:02 <monochrom> actually I wonder if your quicksort needs an [x] case too
17:14:57 <elrikdante> I awlays pack pivot into the middle, so the left and right branches would be appended empty, eg: [] ++ [pivot] ++ [].  any idea what an input that would break it would look like?  so input that generates (pivot:[])
17:15:50 <monochrom> oh interesting, it works fine
17:16:02 <monochrom> @type span
17:16:04 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
17:16:16 <monochrom> I think you can use span instead of two filters
17:16:26 <monochrom> no, span is not right
17:16:29 <monochrom> @type break
17:16:31 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
17:16:43 <elrikdante> nice!
17:16:47 <monochrom> > break (< 10) [1, 11, 2, 22]
17:16:49 <elrikdante> break would be excellent
17:16:49 <lambdabot>  ([],[1,11,2,22])
17:16:56 <monochrom> no, break is wrong
17:17:03 <elrikdante> but it wouldn't partition correct
17:17:07 <monochrom> @type partition
17:17:08 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
17:17:12 <elrikdante> maybe if the list was already sorted?
17:17:20 <monochrom> > partition (< 10) [1,11,2,22]
17:17:22 <lambdabot>  ([1,2],[11,22])
17:17:27 <monochrom> partition is the one
17:17:30 <elrikdante> perfect
17:17:51 <monochrom> break and span correspond to takeWhile and dropWhile
17:22:09 <elrikdante> @type takeWhile
17:22:11 <lambdabot> (a -> Bool) -> [a] -> [a]
17:22:16 <elrikdante> @type break
17:22:18 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
17:22:26 <monochrom> elrikdante: Here is the reason your bsearch needs an [x] case: you split lst into two parts, not three parts. If lst has length 1, then one part still has length 1, ad infinitum.
17:23:45 <grantwu> wait, in the [x] case will the x be chosen as the pivot
17:23:56 <elrikdante> then I probably need a minBound on my branchSize
17:25:20 <monochrom> you do have a notion of "pivot" but you let it survive in the right part.
17:25:31 <elrikdante> @monochrom: I get what you're saying now, I'm mixing my quicksort logic with my bsearch logic
17:25:31 <lambdabot> Unknown command, try @list
17:25:32 <monochrom> or the left part. I don't know which.
17:26:34 <elrikdante> It's no biggie, thanks for helping me drop the filters
17:36:18 <dazednconfused> how do i get a list of integers from a string? ["12 13 14", "14 15 16"] to [[12,13,14], [14,15,16]]
17:36:52 <dmwit> > map (map read . unlines) ["12 13 14", "14 15 16"] :: [[Integer]]
17:36:55 <lambdabot>  error:
17:36:55 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
17:36:55 <lambdabot>        Expected type: [String] -> [String]
17:37:00 <dmwit> > map (map read . unwords) ["12 13 14", "14 15 16"] :: [[Integer]]
17:37:02 <lambdabot>  error:
17:37:02 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
17:37:02 <lambdabot>        Expected type: [String] -> [String]
17:37:05 <ski> too many `map's
17:37:08 <monochrom> Can I solve the simpler problem from "12 13 14" to [12,13,14] instead?
17:37:27 <dazednconfused> sure
17:37:42 <dmwit> oh lol
17:37:44 <monochrom> > map read (words "12 13 14") :: [Int]
17:37:45 <dmwit> > map (map read . words) ["12 13 14", "14 15 16"] :: [[Integer]]
17:37:46 <lambdabot>  [12,13,14]
17:37:47 <lambdabot>  [[12,13,14],[14,15,16]]
17:38:07 <monochrom> and yeah you were not thinking when you introduced "unlines" for no reason
17:39:03 <ski> > replicateM 3 (StateT (reads :: ReadS Integer)) `runStateT` "12 13 14"
17:39:06 <lambdabot>  [([12,13,14],"")]
17:43:33 <alercah> nitrix: did you get an answer, by the way?
17:43:42 <alercah> nitrix: I thought about your problem on the way home
17:44:17 <alercah> you can obviously precompute the answer for "is X a cut-vertex" and store it on X
17:45:49 <elrikdante> is `seq` the only way to inline this assertion?: s.com] has quit [Quit: My MacBook Pro has gone to sleep. ZZZzzz…]
17:46:06 <elrikdante> http://lpaste.net/260998#line29
17:47:13 <elrikdante> I guess sinces is a pure function I have to interleave it into the evaluation
17:47:44 <johnw_> you can just assert it:
17:47:52 <johnw_> assert (isSorted lst) $ case compare ...
17:48:13 <elrikdante> oh jeez.  I was getting syntax errors
17:48:21 <monochrom> @type assert
17:48:22 <elrikdante> that's what that second arg is for
17:48:23 <lambdabot> Bool -> a -> a
17:48:41 <ski>   bsearch x lst | assert (isSorted lst) False = error "unreached"  -- perhaps something like this ?
17:48:55 <monochrom> I'm pretty sure you're suppose to write: assert (isSorted lst) (case compare pivot x of ...)
17:49:23 <monochrom> read the doc of assert to see why and what assert means
17:51:36 <elrikdante> awesome, thanks again
18:02:37 <csauce> I have a question about types, what is the difference between something like: data Context = forall g. RandomGen g => Context { contextRng :: g }
18:03:10 <csauce> and: data Context = Context { contextRng :: forall g. RandomGen g => g }
18:03:52 <csauce> The second one is totally not valid, even with RankNTypes, the first compiles for me
18:04:08 <csauce> but logically, I feel like they should mean the same thing?
18:04:33 <mauke> the first one is an existential type
18:04:46 <johnw_> the second one would need impredicative types, I would think
18:05:21 <mauke> Context :: (RandomGen g) => g -> Context
18:05:43 <dolio> No, the second one needs RankNTypes or PolymorphicComponents.
18:06:00 <csauce> which the compiler alerted me to, just trying to figure out the difference in meaning
18:06:04 <mauke> it wraps a fixed but unknown type (that is an instance of RandomGen) g into Context
18:06:14 <mauke> the second one is polymorphic
18:06:45 <mauke> Context :: (forall g. (RandomGen g) => g) -> Context
18:07:10 <csauce> ohh, so is the second one kind of like if I wrote: data Context g = Context g (with the constraint of course)
18:07:13 <mauke> you need to give it a value that is somehow in all possible types g
18:07:54 <csauce> so it's nonsense, only bottom could possibly fit there?
18:08:45 <mauke> depends on RandomGen, I think
18:08:55 <mauke> :t mempty
18:08:56 <lambdabot> Monoid a => a
18:09:05 <mauke> that has a similar shape
18:09:50 <mauke> ah, there's nothing like that in RandomGen
18:10:44 <csauce> okay - I think the existential type is what I'm looking for anyhow (and it compiles)
18:10:57 <johnw> dolio: ah, I see the difference now
18:11:27 <monochrom> impredicative is when you write like "Maybe (forall a. a)" directly
18:11:31 <johnw> exactly
18:11:32 <johnw> Context (forall g. RandomGen g => g)
18:11:47 <johnw> as a type, not as the definition of the constructor
18:12:04 <bollu> Curry Howard can only correspond to intuitionistic logic, right!
18:12:05 <bollu> ?*
18:12:06 <lambdabot> Maybe you meant: v @ ? .
18:12:48 <bollu> Like, I can't take a theorem in some arbitrary logic and try to encode it as types? It has to be happening in an intutionsitc setting?
18:13:20 <dolio> No.
18:13:49 <bollu> dolio: that was for me? 
18:13:53 <dolio> Yes.
18:14:07 <bollu> So, how to I encode an arbitrary logic into types?
18:14:38 <johnw> bollu: in the Wikipedia page, it lists several logis it has been related to
18:14:41 <dolio> Different logics just correspond to different type theories.
18:14:50 * monochrom grins. In 20 yes-no questions or less...
18:15:17 <dolio> Most stuff I've seen on classical logic involves non-determinism.
18:16:19 <dolio> Pierce's law, ((a -> b) -> a) -> a is a type of call-with-current-continuation.
18:16:32 <dolio> Pierce's law is equivalent to excluded middle.
18:17:13 <dolio> And ((a -> ⊥) -> ⊥) -> a (double negation elimination) is a similar continuation operator, sometimes called 'control'.
18:17:30 <neonfuz> so cabal can be used on both local and system wide packages?
18:17:36 <dolio> Although there's more than one continuation operator named 'control'.
18:18:50 <jdreaver> If I have a project with a library and test suite, and I set "ghc-options: -O0" *just* for the test suite, the library will still be -O1 right?
18:19:09 <jdreaver> That is, the tests are linked against an -O1 library
18:19:25 <jdreaver> I'm just double checking to make sure I'm not missing anything
18:19:35 <dolio> Pretty sure.
18:20:03 <dolio> The library isn't compiled separately for the tests.
18:21:57 <jdreaver> That's what I thought, thanks! Side note: I wish stack had something like --ghc-test-options instead of having to edit cabal files :P
18:26:29 <johnw> jdreaver: you can always directly include the modules from your library into the test
18:26:47 <johnw> jdreaver: I do that sometimes, in case I want to have internal modules never be exposed from the library, but still import'able in the tests
18:27:51 <julianleviston> Is there something wrong with haskell.org? half the time it tells me it can’t establish a secure connection..
18:28:11 <johnw> there's been a certificate issue recently
18:28:16 <julianleviston> scratch that, all the time now.
18:28:39 <johnw>  I'm not sure what the current status is. The last time we were looking at in #haskell-infrastructure, none of us could reproduce it.
18:28:53 <johnw> it just worked for me here again
18:29:17 <julianleviston> hm. irrespective of browser, it’s throwing an error
18:29:52 <erisco> maybe a domain in the chain is messed up
18:30:01 <johnw> can you try: optional s_client -connect haskell.org:443
18:30:11 <johnw> and then pastie the result in #haskell-infrastructure?
18:30:12 <julianleviston> I’m on MacOS Sierra… works on non-sierra
18:30:20 <johnw> s/optional/openssl
18:31:01 <ReinH> Sierra changed some trusted root certs
18:31:30 <ReinH> And also https://support.apple.com/en-us/HT206871
18:31:38 <geekosaur> sqlite3 ~/Library/Keychains/*/ocspcache.sqlite3 'DELETE FROM responses WHERE responderURI LIKE "%http://ocsp%.globalsign.com/%";'
18:31:48 <johnw> the other person who reported problems said it only happened on Microsoft Edge for them
18:32:03 <julianleviston> johnw: I don’t know what you mean by by your “can you try: “ line.
18:32:21 <johnw> at the Terminal, run the command: openssl s_client -connect haskell.org:443
18:32:26 <geekosaur> this should fix it immediately for safari; chrome needs to be restarted afterward. don't know about firefox
18:32:27 <johnw> it should show you all the certificate details
18:32:38 <johnw> and try geekosaur's thing
18:32:48 <julianleviston> johnw: oh… you said optional rather than openssl… :)
18:32:51 <julianleviston> gotcha
18:33:05 <geekosaur> then said [15 01:29:58] <johnw> s/optional/openssl
18:33:12 <johnw> :)
18:33:16 <geekosaur> I assume autoincorrect
18:33:56 <julianleviston> yep. Just saw that :)
18:34:23 <julianleviston> johnw: you want me to paste that result into an IRC channel!?
18:34:32 <johnw> use a pasting service plz
18:34:32 <geekosaur> @paste
18:34:32 <lambdabot> Haskell pastebin: http://lpaste.net/
18:35:19 <PhsShft> How can i use haskell to generate solution to certain function? say I want to compute the two intersection points of a line y=mx+b0 and a parabola y1= a(x-b)^2 +c ?
18:35:43 <PhsShft> just an example for finding solution to function would be good
18:36:01 <julianleviston> PhsShft: just write a function.
18:36:26 <hpc> you can solve it algebraically for any m, b0, a, b, c
18:36:33 <hpc> and then write something that just asks for those numbers
18:37:03 <johnw> PhsShft: you can use sbv for that
18:37:15 <PhsShft> im asking this cu
18:37:17 <PhsShft> cuz
18:37:28 <PhsShft> i heard about somethign called List Comprehensions, would that make things easier ?
18:37:39 <monochrom> No.
18:37:40 <hpc> not in this case
18:37:59 <PhsShft> ok… so how is list comprehension used?
18:38:21 <hpc> an example:
18:39:01 <hpc> > [(a, b) | a <- [1..5], b <- [10..20], (b `rem` 3) == 0]
18:39:03 <lambdabot>  [(1,12),(1,15),(1,18),(2,12),(2,15),(2,18),(3,12),(3,15),(3,18),(4,12),(4,15...
18:39:55 <hpc> at each step you have a discrete list, and specific ways of transforming them to get a result
18:40:05 <PhsShft> ok…
18:40:12 <hpc> in your case you don't have a list, as the solution is going to be in terms of real numbers
18:40:44 <hpc> if you could somehow guarantee that you're only getting problems with integer solutions within a certain range, you could write a list comprehension that brute-forces it
18:40:49 <hpc> but that'd be terrible ;)
18:41:19 <hpc> (or solutions that are aligned with some fixed precision, like the tenths or hundredths place)
18:42:17 <PhsShft> :hpc ok, so here is the actual problem im trying to solve: finding out whether a line segment intersects with a porabola
18:42:44 <PhsShft> :hpc i guess i cannot use list comprehension to brute force it 
18:42:53 <hpc> yeah, just do it algebraically
18:43:01 <PhsShft> since the point needs checking is not intergers
18:43:05 <PhsShft> yea
18:43:51 <amalloy> even if it were integers you wouldn't really want to call f and g on every possible integer
18:43:55 <PhsShft> but that gives me a really ugly solution, i need to first figure out where the line the segment is on intersects with the parabola, and then see if these points are on the segment
18:44:01 <julianleviston> @ReinH thanks for the support doc. Will be useful for the company I work in, too. :)
18:44:01 <lambdabot> Unknown command, try @list
18:44:18 <julianleviston> ReinH: thanks for the support doc - will be useful for the company I work in.
18:44:19 <ReinH> julianleviston: yw, also prepending a @ wakes the bot
18:44:27 <hpc> it's actually pretty simple
18:44:36 <PhsShft> any thought anyone? to determine whether a line segement intersects with a parabola 
18:44:49 <hpc> you're looking for values of x where y = y1
18:45:04 <jdreaver> johnw: Just saw your messages from earlier about internal modules. That sounds interesting, thanks!
18:45:06 <ReinH> As hpc said, there's an algebraic solution. You can implement that solution in Haskell.
18:45:11 <hpc> so substitute the definitions of y and y1, and mx+b0 = a(x-b)^2+c
18:45:15 <julianleviston> ReinH: yeah, sorry - too much flowdock… been a while since I’ve been on here.
18:45:28 <hpc> and keep working it out from there
18:45:48 <PhsShft> yea i got it just wondering whether there is a better way
18:46:55 <hpc> in this case it's a pretty much perfect solution as far as correctness and performance
18:47:02 <PhsShft> cuz you get x to be (m-b + ((b-m)^2-4a*(c-b0))^0.5)/(2*a) and then you get to test whether it’s on the segment
18:47:11 <hpc> for being elegant, that depends on how the requirements for the function might change in the future
18:47:21 <hpc> which i couldn't say, since this seems rather specific
18:47:58 <hpc> PhsShft: oh, there's also two solutions for x
18:48:04 <hpc> potentially
18:48:05 <PhsShft> hpc: yea 
18:48:32 <PhsShft> i just need to test whether they’re in range of the segment’s x coodinates 
18:48:44 <hpc> anyhoo, i think that's all the ways a particular choice of design can be better or worse
18:48:45 <julianleviston> Can happy build a haskell parser to be used in my own code?
18:48:49 <hpc> functionality, or ability to be changed
18:48:50 <PhsShft> just look really ugly to me lol
18:48:53 <julianleviston> that’s like… what it’s for, right? :)
18:48:55 <hpc> and this i wouldn't expect to ever need to change
18:50:42 <ReinH> julianleviston: Yes, and yes.
18:52:10 <byorgey> julianleviston: if you just want a Haskell parser, you can use the haskell-src-exts package.
18:52:44 <ReinH> I'm not sure if "haskell parser" means "a parser for the Haskell language" or "a parser I can use in a Haskell program"
18:53:01 <julianleviston> hehe :) sorry...
18:53:32 <byorgey> good point, I missed the other possible reading.
18:53:34 <julianleviston> I’d like to be able to parse text as Haskell AST… because I’d like to write a kind of structural editor…. I looked at the source for Leksah briefly… 
18:54:15 <byorgey> julianleviston: ok, yes, then you probably want to start by trying haskell-src-exts.  Building your own parser with happy would be a *lot* of work.
18:54:18 <julianleviston> … but it didn’t seem to actually do that, it just defers to a different library for its syntax stuff
18:54:45 <hpc> a haskell AST, or an AST implemented in haskell?
18:54:48 <julianleviston> byorgey: yeah, I’ve looked at haskell-src-exts a long time ago… good reminder, thank you :)
18:55:04 <julianleviston> hpc: AST of haskell language, not an arbitrary AST written in Haskell
18:55:23 <julianleviston> hpc: byorgey has the right idea.
18:55:23 <hpc> ah k ;)
18:55:36 <hpc> yeah definitely
18:55:51 <hpc> the ghc libraries have some pretty great stuff
18:55:56 <julianleviston> byorgey: it’s going to be “fun” ;-)
18:56:55 <geekosaur> re "defers to a different library", haskell-src-exts is a Haskell parser implemented as parser combinators, so it uses a parser combinator library (parsec, I think) and builds its own combinators on top of that
18:58:06 <julianleviston> geekosaur:  I was talking about Leksah.
18:58:23 <geekosaur> ah, that probably uses h-s-e for its parser
18:58:36 <geekosaur> easier than having to write its own, easier than trying to use ghc-api to parse
18:58:39 <julianleviston> as far as I could see it didn’t even parse particularly.
18:58:45 <geekosaur> (which could be done, but ugh)
18:58:50 <byorgey> geekosaur: actually, I think haskell-src-exts rolls its own parser monad & combinators, it doesn't depend on any other parser combinator library
18:59:09 <riaqn> Hey guys, I find myself spend most of my time waiting for hackage document to be loaded in my browser.
18:59:12 <riaqn> any suggestions?
18:59:28 <julianleviston> riaqn: local cached page?
18:59:43 <riaqn> julianleviston: firefox has cache, I assume?
18:59:44 <byorgey> riaqn: that seems like a strange way to spend your time.  maybe you should go outside more.
18:59:50 <byorgey> ;-)
19:00:02 <julianleviston> riaqn: simpler than that, just save the page. :)
19:00:20 <julianleviston> byorgey: so sarcastic ;-)
19:00:46 <riaqn> julianleviston: but I usually can't predict the package page I'm to browser today. So I prefer automatic cache.
19:01:40 <julianleviston> riaqn: in that case it’s more a “how do I cache webpages” question than a haskell question. Google searches will no doubt help here…
19:03:05 <MarcelineVQ> hmm, how about "How can I build the documentation for a large selection of haskage packages, locally on my computer?" what's the answer to that question?
19:03:27 <riaqn> julianleviston: I was expecting   some offline ways to browser hackage packages documents.
19:03:45 <MarcelineVQ> let's say for the sake of example, lens and the dependencies for it
19:03:47 <julianleviston> ahhh sorry I didn’t understand that from your question.
19:03:54 <julianleviston> … because what if it goes out of date?
19:04:16 <julianleviston> http://stackoverflow.com/questions/9454793/haskell-offline-documentation
19:04:30 <julianleviston> ^ that seems to answer your question (first hit on googling “offline hackage")
19:04:31 <riaqn> julianleviston: it's OK as long as it matches the package version I'm using.
19:07:58 <riaqn> julianleviston: thanks that helps!
19:08:07 <julianleviston> awesome :)
19:09:03 <julianleviston> byorgey: so this is pretty awesome… I understand this *so much more* compared to when I first looked at it… https://hackage.haskell.org/package/haskell-src-exts-1.18.2/docs/Language-Haskell-Exts-Syntax.html#t:Exp
19:18:16 <sanitypassing> hi, I have another silly question: how would I remove the title from the dynamicLog PP so that it is only showing workspaces and active layout?
19:23:16 <jvanbure> is there a nicer way to put a Maybe into an ExceptT rather than maybe (throwError "blah") pure aMaybeValue?
19:23:18 <geekosaur> see the description of the ppOrder element, which shows how to remove the layout
19:23:26 <geekosaur> sanitypassing, ^
19:23:33 <sanitypassing> okay, will do! thanks!
19:23:51 <geekosaur> layout is 2nd, title is 3rd, so remove the 3rd element instead of the second
19:25:46 <riaqn> julianleviston: from what I understand, hoogle only redirect you to the web page of that function?
19:29:47 <PhsShft> I have a function taht returns (Double, Double), is there a way for me to use the double inside the tuple seperatly?
19:30:56 <PhsShft> i can just do (x1,x2) = fuction
19:30:59 <PhsShft> and use x1, x2?
19:33:21 <geekosaur> in a let, yes
19:34:42 <ab9rf> you can also use fst or snd to extract one or the other
19:36:01 <PhsShft> can i use it after a “where"
19:36:47 <amalloy> try it and see
19:37:04 <PhsShft> it works :)
19:38:35 <PhsShft> also I’m thiking of a clever way to acheive the following: I have four numbers, a, b,x0,x1, what would be a expression that return True when either x0 or x1 is inbetween a and b
19:38:49 <PhsShft> not knowing whether a > b or b>a
19:40:37 <PhsShft> I’m currently doing min of 4 numbers not being x0 or x1 && max of 4 numbers not being x0 or x1
19:40:49 <PhsShft> any better idea? 
19:43:22 <EvanR> you could do
19:43:29 <EvanR> :t between
19:43:30 <lambdabot> error: Variable not in scope: between
19:43:52 <EvanR> x0 `between` a b || x1 `between` a b
19:43:56 <PhsShft> thx
19:43:56 <EvanR> and define between
19:44:03 <PhsShft> yea...
19:45:49 <EvanR> oh you said "clever" and i read "clearer"
19:45:58 <bollu> Doli 
19:46:25 <bollu> Dolio: thanks, that helps! So, well, you can encode every logic using types? 
19:47:53 <dolio> Every logic corresponds to a type theory. But different logics correspond to different type theories.
19:49:51 <grantwu> If we put a RWS monad over Except, and use Data.Dynamic for all the types
19:50:25 <grantwu> er, no, Map.Map String Dynamic
19:50:28 <grantwu> Is this the Python monad :D
19:52:33 <julianleviston> riaqn: there are instructions on how to have an offline hoogle on that page, I’m pretty sur.
19:52:45 <jvanbure> grantwu: yes
19:52:50 <jvanbure> ;P
19:58:43 <ab9rf> PhsShft: you might want to consider that often "clever" is not "better"
19:58:59 <EvanR> grantwu: youd need a monad which breaks scoping rules and lambdas
19:59:28 <PhsShft> :EvanR I took your advice, and the code is more readable now. I guess I was gonna say clearer 
19:59:45 <ab9rf> clearer beats clever any ol day
20:05:28 <grantwu> EvanR: heh
20:06:32 <EvanR> hhhwhat
20:06:48 <EvanR> i need glasses.. thought you said huh
20:11:17 <Costar> hi all
20:21:29 <joe9> EvanR I pm'ed you. I need some advice on haskell data structures and just wanted to check with you.
20:24:46 <grantwu> Wait... so apparently if you use record syntax when constructing a value
20:24:49 <grantwu> And you leave out a field
20:25:08 <grantwu> Reading the missing fields gets an undefined
20:25:57 <grantwu> Why is this the case?
20:29:36 <MarcelineVQ> What should be in spots that haven't been defined?
20:30:33 <grantwu> Could we verify that no fields are missing at compile time?
20:30:44 <mniip> :t \xs ys -> traverse (\x -> map ((,) x) ys) xs
20:30:46 <lambdabot> Traversable t => t a -> [b] -> [t (a, b)]
20:31:05 <MarcelineVQ> I think there's a compiler warning for it
20:31:11 <mniip> hmm
20:31:49 <ab9rf> -fwarn-missing-fields in ghc
20:32:20 <grantwu> oh, lol
20:32:23 <jvanbure> ab9rf: thanks lol
20:32:56 <ab9rf> see also -fwarn-incomplete-record-updates, which covers a vaguely related matter
20:33:25 <MarcelineVQ> iirc the warning should be on by default, if you want it to be an error you'll need to set a flag
20:33:36 <ab9rf> yeah, it is on by default
20:33:40 <joe9> Is there a haskell library implementing the simple file system described here http://learnyouahaskell.com/zippers
20:33:48 <joe9> using FSCrumb, etc.
20:34:11 <joe9> I need a datastructure for such a simple file system
20:34:12 <ab9rf> you can promote all warnings to errors with -Werror
20:34:32 <joe9> It would be nice if I can even index (like the inode number) into such a file system.
20:34:38 <joe9> any suggestions, please?
20:35:17 <ab9rf> i'd forgotten about all the bad art in lyah
20:35:36 <ab9rf> joe9: i rather doubt there is
20:35:59 <ab9rf> although it wouldn't be that hard, i suppose
20:37:53 <joe9> ab9rf: The zipper seems to be a pretty popular concept. So, I am wondering if there is some kind of derivative of that structure as  a library.
20:38:10 * ski . o O ( "derivative" )
20:39:06 <ski> @google The derivative of a regular type is its type of one-hole contexts
20:39:07 <lambdabot> http://strictlypositive.org/diff.pdf
20:39:07 <lambdabot> Title: The Derivative of a Regular Type is its Type of One-Hole Contexts
20:41:43 <joe9> ski, is there a library package on hackage for this?
20:41:56 <ski> i don't recall
20:44:22 <joe9> ski, I am trying to do this in haskell. https://gist.github.com/845603f675c0a0c7d09eb52e0f230480 . It is implementing a simple file system (and, walk it in response to the 9p2000 messages). The key is that it has a tree like data structure represented as a list of lists. and, they have an inode-like index to refer to any file/dir in the hierarchy.
20:46:28 <joe9> I feel that a zipper would be a good fit for this. But, I am not sure how to represent the list of inode-like number table within the zipper. I would probably need a zipper data structure and a list (or, vector) data structure.
20:46:37 <joe9> ski, Does that make sense?
20:47:49 <MarcelineVQ> mniip: What are you up to :>
20:48:08 <mniip> you don't wanna know
20:49:30 <mniip> MarcelineVQ, http://tcpst.net/cs8j
20:49:57 <mniip> hmm it got cut off
20:50:03 * ski isn't really familiar with inodes
20:50:10 <ab9rf> ski: interesting paper
20:50:22 <joe9> ski, it is just numbers
20:50:29 <joe9> ski, like an index
20:50:51 * ski is also not far from asleep
20:52:08 <geekosaur> hint, the "i" in "inode" means "index"
20:53:22 <geekosaur> there's a table indexed by inumber, and a root directory (on unix this is inode #2; originally, 0 was the superblock and 1 the inode table itself)
20:53:34 <mniip> MarcelineVQ, http://tcpst.net/dyh3
20:54:08 <mniip> I believe this statement is equivalent to p^2-4q >= 0
20:54:23 <Maxdamantus> which afaik is contrary to a zipper FS.
20:54:32 * Maxdamantus hates inodes.
20:54:35 <ski> (the discriminant of the quadratic equation ?)
20:54:39 <mniip> yes
20:54:58 * Maxdamantus wishes they didn't exist in POSIX and that btrfs were properly hierarchical.
20:55:01 <mniip> we transform 'exists x. x^2+px+q=0' into a statement not involving x
20:55:03 <grantwu> I'd like to report a ghc-mod memory leak somehow...
20:55:09 <mniip> using tarski's algorithm
20:55:19 <jvanbure> it used up all of grantwu 's memory
20:55:22 <jvanbure> and swap
20:55:23 <jvanbure> lol
20:55:33 <jvanbure> it was using 1TB of vmem
20:55:58 <ski> mniip : sounds like fun
20:56:00 <jvanbure> grantwu's console is still unresponsive so i'm typing this for him
20:56:06 <grantwu> I'm back!
20:56:09 <jvanbure> lol
20:56:41 <mniip> ski, looking for a nice way to contract this
20:57:22 <mniip> the fun part is
20:57:35 <mniip> we could use the very same algorithm we just implemented for that
20:58:12 <mniip> e.g, P | Q(x,y,z) = P if not exists x y z. Q(x, y, z)
20:58:24 <mniip> and the latter is a thing we can check :D
20:58:42 <MarcelineVQ> jvanbure, grantwu: it has a github page which is probaly the place for reports
20:59:00 <jvanbure> MarcelineVQ: thanks, we'll take a look
20:59:03 <MarcelineVQ> It's not neccesarily a mod issue though if it's something ghc would choke on too
20:59:19 <mniip> likewise, P(x, y, z) | Q(x, y, z) = P(x, y, z) if not exists x y z. P(x, y, z) `xor` Q(x, y, z)
20:59:20 <MarcelineVQ> So be sure to try and build the same thing directly
20:59:37 <ab9rf> jvanbure: that's not a leak
20:59:58 <jvanbure> ab9rf: can't tell if joking
20:59:59 <ab9rf> jvanbure: there's a warning in the GHC 8 release notes that it will appear to use 1 TB of virtual memory, but it's not actually doing so
21:00:02 <jvanbure> o
21:00:06 <jvanbure> wot
21:00:18 <jvanbure> still
21:00:21 <jvanbure> it was using
21:00:32 <jvanbure> 100% of his physical memory
21:00:42 <MarcelineVQ> ​> unlines jvanbure
21:01:00 <ab9rf> is that a ghc bug, or a bug in the program you wrote?
21:01:06 <jvanbure> lol sorry
21:01:18 <grantwu> The program I wrote wasn't executing...
21:01:19 <ab9rf> runaway memory usage is a common enough thing in buggy haskell code
21:01:34 <jvanbure> ab9rf: we weren't running it, would trying to compile a buggy program do that?
21:01:39 <geekosaur> but ghc-mod is not running the program, it is parsing it and doing typechecking
21:01:43 <ab9rf> that might be a ghc bug then
21:01:56 <geekosaur> could be a ghc-api bug, could be a bug in ghc-mod itself
21:02:08 <ab9rf> yeah, lots of opportunties for bugitude
21:02:13 <geekosaur> or haskell-src-exts or something else that ghc-mod uses
21:02:23 <ab9rf> plenty of blame to go around :)
21:02:41 * ski . o O ( higher-order blame tracking systems )
21:22:20 <pikajude> file an issue against the maintainer!
21:23:58 <ski> you take issue ?
21:24:15 <pikajude> #1478: Maintainer produces buggy code
21:24:33 <ski> @ghc
21:24:33 <lambdabot> bindings for unlifted types aren't allowed
21:28:00 <nshepperd1> pikajude: closed wontfix (infeasible)
21:29:41 <Qria> hello from haskell korea meetup~~
21:32:30 <grantwu> Qria: o/
21:32:56 <Qria> \o
21:33:12 <Xnuk> \o/
21:35:14 <TommyC> 한국애 하스컬 쓰는 사람들있어요? 헐...
21:35:35 <glguy_> Sorry, this is an English language channel
21:35:38 <TommyC> :3
21:35:47 <TommyC> Was replying to the haskell korea meetup thing. ^_^
21:35:51 <glguy_> I know
21:36:45 <Qria> wooping 8 people came!
21:38:17 <Rotaerk> wait, there are 8 people who know haskell!?
21:38:26 * Clint squints.
21:38:38 <ReinH> ski: Blame for all!
21:39:38 <ReinH> Rotaerk: Are you aware of how many people are in this channel?
21:39:45 <TommyC> Most of us are bots.
21:39:47 <TommyC> Like myself.
21:40:07 <Rotaerk> yea I just assumed they weren't *real* people
21:42:32 <Costar> TommyC: North Korea ?
21:43:42 <TommyC> Costar: No, I don't think North Koreans except Kim Jong Il have internet access.
21:44:09 <Rotaerk> Best Korea probably has their own best programming language too
21:44:19 <Costar> TommyC: He is dead... Probably no.
21:44:45 <TommyC> I meant 은 (Un). ^_~
21:44:50 <Costar> TommyC: Haha
21:45:08 <Costar> TommyC: jk. Greetings!
21:45:51 <TommyC> Ty. I'm not at the convention, although I wish I was.
21:47:49 <Costar> Do Koreans use Haskell a lot?
21:47:53 <Costar> uses
21:48:02 <TommyC> No.
21:48:41 <TommyC> Korean Universities teach Java to start because OOP is for 1337 hax0rz and C/C++ later down the line.
21:48:42 * hackagebot legion-extra 0.1.0.3 - Extra non-essential utilities for building legion applications.  https://hackage.haskell.org/package/legion-extra-0.1.0.3 (taphu)
21:48:44 * hackagebot legion-discovery 0.2.1.1 - Initial project template from stack  https://hackage.haskell.org/package/legion-discovery-0.2.1.1 (taphu)
21:49:26 <Qria> TommyC: https://www.youtube.com/channel/UCoR15nfhyKUL8IFm9shnl9A/live
21:50:11 <TommyC> \o/
21:50:41 <Costar> TommyC: Here in Brazil too. Im lecturing in my university this year. They gave me a syllabusless course, so im trying to teach Haskell.
21:51:02 <TommyC> Costar: What's the class?
21:51:07 <TommyC> Qria: Is that you typing? :3
21:51:55 <Qria> nope, the guy typing and talking is much sexier than me
21:52:27 <Costar> Korean is hard
21:52:33 <Costar> Kanji with circles
21:52:42 <TommyC> "Haskell community is gentle and kind."
21:53:41 <TommyC> Costar: It's not too bad, it's a real alphabet so once you learn that and grammar the rest is just looking up words in a dictionary.
21:54:19 <Zemyla> @let don't :: (Applicative m) => m a -> m (); don't _ = pure ()
21:54:20 <lambdabot>  Defined.
21:55:05 <ertes> @let please = id
21:55:07 <lambdabot>  Defined.
21:55:08 <Zemyla> Is there a package that provides this?
21:55:14 <ertes> Zemyla: acme-dont
21:55:27 <ertes> oh, well, it's Monad for that one
22:01:15 <EvanR> joe9: whats up
22:01:45 <Zemyla> ertes: Well, it doesn't have a github page, and with the ApplicativeDo extension, we need an Applicative don't.
22:03:32 <ertes> it's about time it gets added to Prelude
22:04:21 <EvanR> what about comonadic t'nod
22:04:52 <Zemyla> We need to standardize comonadic od first.
22:05:28 <ertes> what would t'nod even od?
22:05:28 <EvanR> the other way around
22:05:44 <EvanR> since its the dual typeclass we standardize things in the wrong order
22:08:28 <ReinH> ertes: heh, for shells I like alias computer,=sudo so I can say computer, apt-get install nginx
22:09:58 <ertes> ReinH: i always have a file called "-rf *" in my home directory =)
22:10:05 <ertes> touch -- "-rf *"
22:11:05 <EvanR> dont look down the barrel of a gun
22:12:57 <ertes> "are you sure we should steal their technology?  those earthlings certainly are weird creatures…  they infect their own computers with viruses and create misleading files for no sensible reason"
22:13:46 <EvanR> they write programs which output their own code
22:14:01 <EvanR> clearly the intelligence is minimal
22:15:24 <Zemyla> Actually, being able to make something that describes itself sounds like a pretty decent signifier of sapience.
22:16:38 <EvanR> crystals are pretty good at it
22:16:39 <ertes> "they made this huge, computer network ultimately to jerk off and exchange cat pictures"
22:21:45 <grantwu> Urgh, the issue with ghc-mod happened again...
22:22:09 <fred-fri> noob with a basic syntax question http://pastebin.com/MgCicYFB
22:22:23 <EvanR> http://pastebin.com/raw/MgCicYFB
22:23:02 <EvanR> if you want to match a single element list do
22:23:11 <EvanR> f [x] = ...
22:23:30 <Xnuk> @hoogle listToMaybe
22:23:32 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
22:23:32 <lambdabot> CorePrelude listToMaybe :: [a] -> Maybe a
22:23:32 <lambdabot> Agda.Utils.Maybe.Strict listToMaybe :: [a] -> Maybe a
22:23:56 <EvanR> alternatively whats the question
22:24:13 <fred-fri> cheers
22:25:34 <fred-fri> i know making the function types explicit is good practice, but do you usually write the signature by hand or do you use whatever is generated by :t
22:25:59 <ertes> fred-fri: i usually write the type signature before i write the implementation
22:26:11 <fred-fri> I noticed :t usually has a different idea about the types for my functions than I do :)
22:27:05 <ertes> fred-fri: one reason may be that :t reports the most generic type it can infer
22:27:17 <ReinH> I find that it's harder to write functions if I don't know what type they should be.
22:28:20 <fred-fri> ertes, yes, in some cases :t is overly generic for the purposes of the function and i use a more restrictive type like eg int instead of any number type
22:28:45 <fred-fri> so its kind of use your judgement on that i guess?
22:28:46 <ertes> fred-fri: you should get used to using the generic types
22:29:13 <ertes> fred-fri: not every single time, but if in doubt you should write the generic type
22:29:46 <ertes> in the cases when you want a more specific type, you'll know that you want them for a specific reason
22:29:52 <fred-fri> agreed
22:30:13 <fred-fri> like nthFibo i dont want it to accept floating point types
22:30:24 <ertes> why?
22:30:38 <fred-fri> intuitively it just doesn't seem to make sense to me
22:30:52 <fred-fri> "what is the 1.22313423525 th fibonacci number" seems nonsensical
22:31:00 <ertes> ah, you mean for the argument
22:31:05 <ertes> sure, that one should be integral
22:31:17 <fred-fri> glad i got that right
22:32:09 <orion> Hey, anyone have problems compiling GHC 8.0.1 on FreeBSD 11.0-RELEASE? I'm getting this error: rts/posix/OSMem.c:158:5: error: #error USE_LARGE_ADDRESS_SPACE needs MAP_NORESERVE
22:32:25 <fred-fri> BTW this channel is great, i really appreciate the friendly advice to stupid beginner questions
22:32:42 <orion> The MAP_NORESERVE flag was removed in 11, as documented here: https://reviews.freebsd.org/D848
22:43:43 <EvanR> ertes: good question, what is the minimal thing required by the construction of the fib sequence
22:43:49 <EvanR> addition?
22:43:57 <EvanR> semigroup?
22:44:28 <EvanR> magma
22:45:50 <ertes> EvanR: you can generalise in a few directions
22:45:51 <EvanR> ah, and pointed so you have a starting point
22:46:31 <ertes> for example the closed form formula requires a number field for the result, but allows the argument to be any real number (or even something more general)
22:46:59 <ertes> so you can actually make sense of the "π-th fibonacci number"
22:47:16 <EvanR> thats more like an extension of the standard one
22:47:23 <ab9rf> i was thinking that when that was up there earlier
22:47:33 <ab9rf> i think uyou can even have the i-th fibonacci number
22:47:40 <ab9rf> i think the formula is evaluable for complex values
22:47:41 <ertes> yeah
22:47:57 <ertes> if you want to experiment with it, feel free to generalise the 'fib' function here: https://github.com/esoeylemez/snippets/blob/master/FibNF.hs
22:48:00 <ab9rf> although i don't know if the resulting value has any meaning
22:48:24 <ertes> probably…  similar to how the gamma function has meaning in some contexts
22:48:32 <Myrl-saki> ertes: IIRC, I was the one who introduced that idea. :3
22:48:44 <ertes> Myrl-saki: which one?
22:49:01 <Myrl-saki> The fibonacci one.
22:49:08 <ertes> which one exactly? =)
22:49:16 <EvanR> you invented the fibonacci sequence?
22:49:59 <MarcelineVQ> It was less impressive before they invented the numbers above 100
22:50:03 <Myrl-saki> ertes: The fibonacci one using reflection. IIRC, I was asking here how to do the formula using the golden ratio without using floats.
22:51:04 <ertes> Myrl-saki: the code is actually pretty old…  i put it on github as a response to some question or discussion here…  maybe that was you =)
22:51:21 <Myrl-saki> ertes: Yeah. I have a feeling that was me. c:
22:52:21 <Myrl-saki> Really though. That's pretty neat.
23:08:07 <fred-fri> whats the best way to import Map? I've seen a lot of different versions, including this two-line one http://pastebin.com/DGfDXmuE
23:09:52 <Rarrikins> fred-fri: A common one is import qualified Data.Map as M
23:10:05 <Rarrikins> fred-fri: That shortens the part you need to put in front of function names.
23:10:25 <lyxia> fred-fri: I like the one you pasted.
23:10:25 <fred-fri> so then you do eg M.fromList?
23:10:34 <Rarrikins> fred-fri: Yep.
23:11:02 <fred-fri> Rarrikins, I do like the shortness but it does become a bit less declarative
23:11:16 <Rarrikins> fred-fri: It's no problem to do it with Map.
23:11:20 <ongy> the two line version has the advantage that you have the types without any fuzz around, since those (unlike the functions) don't overlap with other modules. It's pretty similar for Data.ByteString
23:11:59 <fred-fri> in the two line version, how do you call eg fromList?
23:12:07 <fred-fri> just Map.fromList ?
23:12:27 <lyxia> yes
23:12:48 <fred-fri> (just realized I should avoid using the word just unless actually referring to the type Just)
23:14:04 <grantwu> Just isn't a type, I think
23:14:15 <EvanR> M.fromList is pretty idiomatic, people will know
23:14:17 <grantwu> Maybe is a type
23:14:28 <EvanR> T.pack, BS.length, etc
23:14:36 <Clint> Maybe is not a type
23:14:41 <grantwu> :C
23:14:50 <EvanR> depends on who you ask
23:14:52 <grantwu> Maybe a is a type?
23:15:01 <TommyC> Maybe may be a type.
23:15:02 <lyxia> just use syntax to distinguish code from English, write in markdown for example :)
23:15:03 <glguy> no, Maybe is a type
23:15:06 <jvanbure> Maybe is a type constructor
23:15:10 <jvanbure> ?
23:15:34 <glguy> it's a type constructor like Bool is
23:15:54 <jvanbure> glguy: Bool is a concrete type, what do you mean?
23:15:54 <glguy> these are different categories of things
23:15:59 <EvanR> the ontological status of all these things is hazy
23:16:06 <Clint> i'm not even real
23:16:13 <Rarrikins> Duuuuude
23:16:20 <glguy> it helps to read the Haskell Report
23:16:42 <EvanR> when you say Bool what are really referring to, its an absent referent
23:16:46 <glguy> Bool is a type with kind *, Maybe is a type with kind * -> *
23:17:36 <glguy> there are type constructors and type variables
23:23:06 <vsimen> hi, is there a better way to transform a [Char] to Data.Text then foldr Data.Text.cons Data.Text.empty string ?  
23:23:25 <glguy> jvanbure: it might help to consider that both Just and True are data constructors, the constructor part has to do with being a capitalized things you can pattern match than the type of the thing
23:23:45 <glguy> the same holds for type constructors 
23:24:03 <jvanbure> glguy: makes sense
23:24:36 <ongy> vsimen: Data.Text.pack?
23:25:43 <vsimen> ongy, thanks
23:26:10 <vsimen> has the right declaration 
23:34:41 <bollu> How do I added a custom deriving() rule? 
23:34:49 <bollu> Like, I want to implement this 
23:34:56 <bollu> If you have a type that is a functor, say f 
23:35:13 <bollu> Now you do newtype monof = f a 
23:35:27 <bollu> You can automatically derive monofunctor on the monof 
23:35:36 <bollu> Because you know that it came from a functor 
23:35:47 <bollu> That's been newtyped and then monomorphised(is that a word) 
23:35:55 <bollu> But this doesn't exist right now
23:35:58 <bollu> So I want to write the rule 
23:36:07 <bollu> For the derive to happen automatically 
23:36:10 <bollu> How do I do this?
23:37:04 <shanemikel> Haven't really done this, but I think you're looking for "Generics"
23:37:06 <shanemikel> https://wiki.haskell.org/GHC.Generics
23:37:20 <bollu> Thanks for the pointer!
23:37:21 <bollu> This seems fun :)
23:38:41 <MarcelineVQ> not quiiiite sure what you're after, are you aware of the GeneralizedNewtypeDeriving extension?
23:38:51 <cocreature> if your class has a default implementation for all methods (which can be based on generics) you can enable -XDeriveAnyClass and derive it
23:48:47 * hackagebot repa 3.4.1.2 - High performance, regular, shape polymorphic parallel arrays.  https://hackage.haskell.org/package/repa-3.4.1.2 (BenLippmeier)
23:50:59 <ph88> lispy, ah thx multiplate, where can i find the example with lens though ?
23:54:24 <EvanR> i find myself writing some crunchy code to read one-number-per-newline from a file to get the last number, unless theres no terminating newline then second to last
23:54:46 <EvanR> attoparsec says it will accumulate the entire input even if you parse incrementally
23:55:24 <EvanR> damned if i do damned if i dont
23:57:17 <EvanR> and "lines" conveniently ignores a single trailing newline
23:57:52 <EvanR> shoulda used perl
