00:07:39 * hackagebot diagrams 1.4 - Embedded domain-specific language for declarative vector graphics  https://hackage.haskell.org/package/diagrams-1.4 (BrentYorgey)
00:07:39 * hackagebot SVGFonts 1.6.0.1 - Fonts from the SVG-Font format  https://hackage.haskell.org/package/SVGFonts-1.6.0.1 (BrentYorgey)
00:12:34 * hackagebot envelope 0.2.0.1 - Defines generic 'Envelope' type to wrap reponses from a JSON API.  https://hackage.haskell.org/package/envelope-0.2.0.1 (cdepillabout)
00:27:35 * hackagebot multifile 0.1.0.1 - create many files from one  https://hackage.haskell.org/package/multifile-0.1.0.1 (AlanHawkins)
00:32:35 * hackagebot multifile 0.1.0.2 - create many files from one  https://hackage.haskell.org/package/multifile-0.1.0.2 (AlanHawkins)
00:37:35 * hackagebot envelope 0.2.1.0 - Defines generic 'Envelope' type to wrap reponses from a JSON API.  https://hackage.haskell.org/package/envelope-0.2.1.0 (cdepillabout)
00:52:36 * hackagebot hylide 0.1.4.1 - WebGL renderer for livecoding shaders with Hylogen  https://hackage.haskell.org/package/hylide-0.1.4.1 (sleexyz)
01:05:57 <tsahyt> This C library provides a data structure that can be queried using several functions taking keys. every key can refer either to a map, an array, a value, or an empty cell. Rather than providing the low level accessors like this I think it might be nicer to return an appropriate ADT. How does laziness affect this? If I lazily populate say a Map in IO, won't the values depend on when I actually evaluate them?
01:06:05 <tsahyt> assuming that the underlying C structure can mutate that is
01:07:03 <merijn> tsahyt: Not if you query stuff in IO
01:07:42 <merijn> tsahyt: IO enforces sequencing of events, so "IO (Map Foo Bar)" actually executes all IO FFI calls you do before returning a Map
01:09:13 <tsahyt> merijn: so when I have a function StateHandle -> IO (Map Key Double) that builds a lazy map using IO actions, it won't actually be evaluated lazily?
01:09:41 <tsahyt> that doesn't seem quite right either. I remember using laziness to manage resources in a distributed system a while ago. calls were only made when the computations that followed needed the data
01:10:00 <merijn> tsahyt: The map will be build lazily, but assuming you use IO to call FFI functions to build that, the IO actions are guaranteed to have completed before the map can be returned
01:10:44 <tsahyt> I'd use FFI functions to generate both the keys and query the values at the keys
01:11:05 <merijn> tsahyt: People seem to always get laziness and IO mixed up in weird ways
01:11:29 <merijn> tsahyt: "foo >>= f" <- foo's IO always finished before 'f' starts evaluating
01:12:07 <tsahyt> Maybe it's a lack of caffeine but I'm confused right now. what if f doesn't need anything from foo?
01:12:15 <tsahyt> and what was all this discussion about lazy IO about then?
01:12:27 <jle`> tsahyt: what about putStrLn "hello" >>= (\_ -> getLine) ?
01:12:32 <merijn> tsahyt: Lazy IO is stuff that uses unsafeInterleaveIO internally
01:12:44 <merijn> tsahyt: The standard thing for IO is *not* lazy
01:12:45 <jle`> tsahyt: getLine doesn't start until after putStrLn "hello" finishes executing
01:12:53 <jle`> despite not needing the result of putStrLn "hello"
01:13:02 <merijn> tsahyt: readFile uses unsafeInterleaveIO internally to "read on demand"
01:13:15 <tsahyt> and thus I was enlightened.. sorta
01:13:23 <merijn> tsahyt: If you are not using unsafeInterleaveIO then all IO *must* complete before the next IO starts
01:13:28 <jle`> or, say, forever (threadDelay 1000) >>= (\_ -> putStrLn "hello")
01:13:35 <tsahyt> now I just need to figure out why my on-demand DHT lookups worked
01:13:36 <jle`> that'll never reach putStrLn
01:13:45 <tsahyt> because thinking about it like that, it shouldn't have
01:13:47 <tsahyt> but it did
01:14:10 <merijn> what's DHT mean?
01:14:14 <tsahyt> distributed hash table
01:14:37 <tsahyt> I wrote a chord ring implementation on top of cloudhaskell and a DHT on top of that once
01:14:58 <ongy> what are their usecases? I have seen them for torrents, and I think tox uses them
01:15:02 <tsahyt> the DHT would manage resources for a distributed ray tracing system
01:15:05 <merijn> All IO being lazy would be horrible and confusing o.O
01:15:49 <jle`> ongy: i think amazon uses them for their media
01:15:58 <tsahyt> the idea was that you have a lot of render nodes and a master node that can use these for raytracing tasks. texture and model data gets stored in a distributed fasion and each node queries just what they need
01:16:08 <tsahyt> it worked, but now I'm not sure why
01:16:21 <merijn> tsahyt: What would make it not work?
01:16:34 <ongy> is your code public?
01:16:36 <tsahyt> let me dig up the code and see what exactly I did. I might be misremembering
01:16:45 <tsahyt> ongy: no, it was just a uni project. nothing fancy
01:16:58 <jle`> ongy: for example, all pictures of products might be stored across several different data centers, and finding out which data center the picture of a specific shirt i want to buy would be looking it up on a dht
01:17:21 <ongy> ok, got to read into it when I have time
01:22:37 * hackagebot yesod-form 1.4.8 - Form handling support for Yesod Web Framework  https://hackage.haskell.org/package/yesod-form-1.4.8 (MichaelSnoyman)
01:23:27 <tsahyt> merijn: what if I filter such a map immediately, even before binding it? say M.filter predicate <$> generateMap? is IO for the rest of the map still done?
01:25:30 <merijn> tsahyt: Functor/Monad laws :) "foo >>= \x -> return (f x)" is "fmap f foo" :)
01:25:36 <merijn> tsahyt: i.e., yes
01:26:08 <tsahyt> ah right, so this can't swallow up any side effects then
01:26:33 <merijn> tsahyt: Correct
01:28:13 <tsahyt> the more I think about this, the more sense it makes to figure out whether I can somehow just provide lenses for this structure
01:30:58 <tsahyt> is there a notion of a lens that can only view?
01:33:29 <merijn> tsahyt: Yes, Getter
01:34:21 <merijn> And Fold, I suppose
01:34:26 <tsahyt> that might make at least some sense as an interface
01:34:35 <merijn> Both of those can only extract, not update
01:34:37 <tsahyt> but I'm not happy to pull in the entirety of lens for it tbh
01:34:48 <tsahyt> then again, since it's all just type synoynms, I might not have to
01:34:49 <merijn> tsahyt: You can export lenses without depending on lens
01:34:52 <tsahyt> exactly
01:34:55 <merijn> tsahyt: I assume the same applies to Getter
01:35:01 <merijn> Try #haskell-lens for help there
01:35:02 <tsahyt> yeah it's a type Getter = something
01:43:56 <koz_> tsahyt: You can just write an ordinary function. If someone wants a Getter, they can feed it to 'to'.
01:44:23 <koz_> (or at least I *think* it's called 'to')
01:44:34 <koz_> No, wait, I think it's 'of'.
01:44:47 <jle`> it is indeed called to
01:45:05 <koz_> jle`: Shows that I should trust first instincts.
01:45:05 <jle`> > view (to fst) (1,2)
01:45:08 <lambdabot>  1
01:45:20 <koz_> jle`: I'm surprised you didn't break out all the infix operators.
01:45:33 <jle`> i usually use lens w/o operators
01:45:38 <koz_> > (to fst) .~ (1,2)
01:45:40 <jle`> it reminds me of fmap, traverse, normal functions, etc.
01:45:41 <lambdabot>  error:
01:45:41 <lambdabot>      • Could not deduce (Contravariant Identity)
01:45:41 <lambdabot>          arising from a use of ‘to’
01:45:47 <koz_> Whoops, wrong one...
01:45:50 <koz_> jle`: Me too.
01:45:57 <koz_> I find it much more readable that way.
01:46:19 <tsahyt> but can I write a Getter for something that only makes sense in IO? I.e. get something that's dependant on the state of this C library?
01:46:26 <jle`> > (1,2) ^. to fst   -- fwiw
01:46:29 <lambdabot>  1
01:46:38 <koz_> tsahyt: What's the type of this, if you were to write it as a normal function?
01:47:01 <jchia> under ClassyPrelude/MonoTraversable, is there a better way to get an empty IntMap/Map/HashMap other than (fromList [])?
01:47:07 <tsahyt> something like Handle -> IO Value
01:47:14 <jchia> i mean (mapFromList [])
01:47:15 <tsahyt> parameterized over a key too
01:47:25 <tsahyt> so Handle -> Key -> IO Value or something along those lines
01:47:27 <koz_> jchia: mempty?
01:47:35 <koz_> They're all Monoids IIRC.
01:48:00 <jchia> koz_: cool, didn't think of that
01:48:26 <koz_> tsahyt: So why not just provide that as a function?
01:48:39 <koz_> If people want a Getter out of (a curried form of) that, they can just make one using 'to'.
01:49:01 <koz_> There's not a whole heap of point to exporting Getters only.
01:49:24 <tsahyt> koz_: because there's often a whole traversal of the structure involved until you actually end up with a value. you get the root key from the library, check what type (map, array, value) it is, then query on from there, getting keys back until you run into something that's a value, and then you can query that
01:49:31 <tsahyt> it strikes me as rather painful
01:49:49 <tsahyt> whatever solution I end up with doesn't have to be lenses, I'm just contemplating the idea
01:49:59 <koz_> tsahyt: It might help a little if we knew what the structure was.
01:50:14 <koz_> Lenses can help you navigate through something like that, but I'm not too sure exactly what you're rocking with here.
01:50:51 <tsahyt> this is the C API. it's a statistics object for a solver that you can use as a library https://potassco.org/clingo/c-api/current/group__statistics
01:51:43 <tsahyt> so far my "high" level binding only makes sure that the handle makes sense, i.e. things are allocated etc, and changes the signatures such that exceptions are thrown and return values are actually return values, and does away with the memory management
01:52:08 <koz_> tsahyt: Do I understand correctly that you're trying to shovel through the result, which is basically a type-tagged tree?
01:53:11 <tsahyt> yes that's roughly what it is. I just want to provide a reasonable way to the user to traverse these statistics
01:53:34 <koz_> tsahyt: OK, so what you actually want is a whole *heap* of Getters, each fetching differently-tagged substructures.
01:53:45 <koz_> Now, obviously, they won't always be valid, amirite?
01:53:53 <koz_> (i.e. you might 'miss')
01:54:01 <tsahyt> yes, all of these functions in my bindings can throw exceptions
01:54:07 <tsahyt> for invalid keys for example
01:54:18 <koz_> In that case, you're probably looking at a Traversal, not a Getter. Getters don't miss.
01:54:27 <tsahyt> but as long as you don't make keys up (which can be prevented statically) but only obtain them from the library, the exceptions shouldn't happen
01:54:35 <koz_> While a Traversal can return anywhere from zero results upward.
01:54:57 <tsahyt> koz_: but in principle, the fact that this is calling IO code doesn't prevent the use of lenses then?
01:55:15 <koz_> The IO and the lensing are unrelated here.
01:55:24 <koz_> You do the IO thing, it spews results, and then you lens over the results, right?
01:56:02 <tsahyt> as in querying everything first and then providing a result object?
01:56:09 <tsahyt> I want the IO to happen as it must
01:56:18 <koz_> And it will.
01:56:23 <koz_> Let me try and explain a little differently.
01:56:34 <koz_> Suppose I wanna get the length of a list.
01:56:44 <koz_> > length [1,2,3]
01:56:47 <lambdabot>  3
01:56:57 <koz_> Now, suppose instead of [Int], I have Maybe [Int].
01:57:08 <koz_> > length <$> (Just [1,2,3])
01:57:10 <lambdabot>  Just 3
01:57:18 <koz_> Note how the function I use is still the same?
01:57:26 <tsahyt> yes
01:57:42 <koz_> So you should write your lensy thing as if you were working on just the result, IO be damned.
01:57:56 <koz_> Then you lift that into the IO-based computation that yields said result in the first place.
01:58:41 <tsahyt> so I would write lenses on some suitable ADT then that I define for it
01:58:46 <koz_> Correct.
01:59:20 <tsahyt> but to create said ADT, IO will have to be performed and from the discussion above I thought that the whole thing will be built up, rather than just the parts that are needed
01:59:39 <koz_> Yeah, you perform the IO action, and it returns 'IO WhateverYourSpecialTypeIs'.
02:00:04 <koz_> Then, you write operations that take a WhateverYourSpecialTypeIs and return whatever you feel like getting.
02:00:04 <tsahyt> the question is, will this be fully evaluated by the time the user can even begin using it?
02:00:15 <koz_> It doesn't have to be.
02:00:40 <koz_> That's to do with how you define the ADT and the operation that constructs it, on the basis of the C code you call.
02:00:53 <koz_> However, I'm *guessing* that the C code that does your statistics magic isn't gonna give you a lazy result.
02:01:01 <tsahyt> then what if the statistics underneath change? say I have one half evaluated, leave it. the solver does some stuff and the statistics change. now I look into another part of the statistics. the object will then be "temporally inconistent"
02:01:18 <koz_> If the statistics underneath change, then you have a different ADT.
02:01:29 <koz_> Since each result is the result of running the solver on a particular set of statistics, no?
02:02:12 <koz_> Let me see if I understand correctly. Does the C solver basically do all the solving for any set of statistics at once?
02:02:23 <koz_> Or can you do a range of 'solver things', each one giving different kinds of answer?
02:02:32 <tsahyt> the statistics are a side-effect. they're just statistics about the solver.
02:02:47 <tsahyt> e.g. how many operations have been performed and stuff like that
02:03:08 <tsahyt> you can obtain a handle for them before even starting solving. in theory I think you could monitor solver progress that way too
02:03:23 <koz_> That sounds like a stream to me.
02:03:59 <tsahyt> the way I think of it is just some mutable key-value store (with tree properties) that's lying somewhere in memory
02:04:37 <tsahyt> I guess you could say it's a stream of immutable stores
02:05:14 <koz_> That sounds more like a State monad than anything, then.
02:05:27 <koz_> Since every time you have it do a Thing, it also changes some state.
02:06:12 <tsahyt> yes unfortunately it's all full of side effects
02:06:34 <tsahyt> I end up with a MonadIO constraint on pretty much every single function
02:07:10 <tsahyt> but the API only provides well defined interfaces to this state. in this particular case it's all read-only too. there's another similar thing for solver configuration too
02:07:39 * hackagebot protolude 0.1.9 - A sensible set of defaults for writing custom Preludes.  https://hackage.haskell.org/package/protolude-0.1.9 (sdiehl)
02:07:51 <tsahyt> in the case of configuration, values can be changed as well, although no new keys can be created as far as I can tell. I haven't looked into that part much yet
02:08:14 <koz_> tsahyt: You could always just keep as much of the state as possible in the State part of your monad, and have some ADT represent *that*.
02:08:24 <koz_> And then simply write against the State instead of IO.
02:08:46 <koz_> I mean, I'd love to help, but I'm not completely understanding the exact nature of what this C thing is, sorry...
02:09:12 <tsahyt> I don't have an explicit state part of my monad. in fact I don't really have MY own monad to begin with. I've been avoiding it to enable users to use whatever monad stack they want while interfacing with the solver
02:09:49 <tsahyt> I can make sure that handles aren't passed outside of their scope (lifecycle) using rank-2 types instead
02:10:12 <tsahyt> and as long as I make it impossible to create a handle or key etc out of thin air, it should all be consistent.
02:10:23 <koz_> tsahyt: That sounds like ST, then.
02:11:03 <tsahyt> yes, what I'm using is somewhat like ST. I have a function like withSolver :: (MonadIO m, MonadCatch m) => (forall s. SolverHandle s -> m r) -> m r
02:11:28 <tsahyt> so you can pass in an action in a monad of your choice as long as it can catch exceptions, which I need to wrap everything up properly in case of error
02:11:35 <tsahyt> and you get a handle to work with the solver inside of that scope
02:12:18 <tsahyt> any derived objects that could be used with the solver API also carry an s parameter
02:12:39 * hackagebot protolude 0.1.10 - A sensible set of defaults for writing custom Preludes.  https://hackage.haskell.org/package/protolude-0.1.10 (sdiehl)
02:12:49 <tsahyt> all that only work within the context of the solver that is
02:14:06 <koz_> tsahyt: And you wanna use lenses for the operations on the handle, because of complex query structures.
02:14:27 <koz_> So why now just write them against the handle, and have them be of the form s -> r.
02:15:31 <tsahyt> this is what it looks like right now. far from finished or polished of course http://lpaste.net/2919322844850552832
02:16:15 <tsahyt> the Raw.* versions are 1:1 bindings to the corresponding C functions
02:17:01 <tsahyt> marshall1 is a utility function that takes some Ptr a -> IO Bool to an IO a, throwing an exception if the Bool was false. this is because the API returns things into ptrs most of the time
02:21:03 <koz_> So it's the 'Statistics s' that you wanna be able to pick apart with lenses, right?
02:21:38 <tsahyt> yes, that's the handle that the API gives me. it's completely opaque though
02:21:57 <koz_> If it's completely opaque, I'm not sure how you believe lenses will help you any.
02:22:40 * hackagebot intero 0.1.19 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.19 (ChrisDone)
02:23:21 <tsahyt> I mean the representation is opaque. I have all these functions to look into it.
02:23:38 <tsahyt> my knowledge of lenses is very limited though, so I might be asking something that is obviously impossible
02:23:49 <koz_> OK, so then why do you need lenses? These functions seem to do everything you need them to.
02:24:01 <tsahyt> koz_: because I'm looking for a composable interface
02:25:29 <tsahyt> there's probably some way to massage the types here such that composition with (>=>) is less painful
02:25:30 <koz_> Give me an example of what you want to be able to do, given the functions you've just pasted.
02:25:51 <koz_> The thing is, all of your functions consume the Statistics object.
02:26:19 <koz_> So I'm not sure what kind of composability you seek.
02:27:12 <tsahyt> I'd like to be able to describe a path through this object. say root .. arrayAt 10 .. mapAt "foo" .. value
02:27:17 <tsahyt> for some suitable composition operator
02:27:30 <koz_> OK, so what you want is that Statistics s is your State.
02:27:46 <ertesx> tsahyt: these are all getters…  if all you have is getters, there is really no point in making them lenses
02:28:05 <tsahyt> ertesx: there's a second such interface in this API in which things can be set as well
02:28:33 <ertesx> tsahyt: for things that can set lens/traversals start to make sense
02:28:41 <koz_> tsahyt: The arrayAt operation doesn't actually give you a Statistics object to dig into it further.
02:28:45 <koz_> s/into it/into
02:28:54 <koz_> You just get a SKey.
02:29:15 <tsahyt> koz_: I can write functions that pass on the handle on top of the existing ones
02:29:27 <koz_> It just really looks like you want Statistics s to be a State monad thing.
02:29:45 <koz_> Because ultimately, you operate mostly on SKeys and Naturals, and the Statistics s just sits there.
02:30:25 <tsahyt> it looks more like a reader to me tbh. it's just a reference to something after all
02:30:39 <koz_> tsahyt: You just mentioned that setting is possible in this API.
02:30:55 <ertesx> tsahyt: does "setting" mean "S -> S" or rather "S -> IO ()"?
02:31:08 <tsahyt> ertesx: unfortunately not
02:31:13 <tsahyt> it's S -> IO ()
02:31:21 <ertesx> tsahyt: then lenses can't help you anyway
02:31:33 <koz_> That *definitely* sounds like State. And what ertesx said - it breaks the lens laws.
02:31:52 <ertesx> it doesn't even break the lens laws…  it just simply doesn't fit the type
02:31:53 <tsahyt> ok, then I'll pursue something else for that
02:32:19 <ertesx> tsahyt: you can let the user choose which state abstraction (ST or IO) to use by using something like the 'primitive' package
02:32:25 <ertesx> but that's about all you can do
02:32:25 <koz_> I would seriously say - make Statistics s a state, and staple MonadState onto your monad. That'll actually get you most of the compositionality you seek.
02:32:50 <koz_> Because then, everything yielding SKeys can be chained further.
02:32:54 <tsahyt> that's certainly a good way to fix this
02:33:01 <koz_> tsahyt: It seems the most logical to me.
02:33:20 <tsahyt> but that would mean that a user of the library couldn't have his own state transformer, wouldn't it?
02:33:28 <joneshf-laptop> Is there a type that's like a list but you might have one element in it be different. Like `[Either () a]` and you want to ensure at most one `Left ()` exists in the list?
02:33:33 <tsahyt> because s is uniquely determined by m in MonadState
02:33:40 <koz_> tsahyt: Yes, but this is an issue with mtl.
02:33:47 <koz_> You'd need explicit lifts to get around that one.
02:33:59 <koz_> You can investigate extensible-effects if this is something that makes you lose sleep at night.
02:34:14 <koz_> joneshf-laptop: Does that element have a specific position?
02:34:19 <koz_> Or could it be anywhere ever.
02:34:30 <joneshf-laptop> koz_, the latter
02:34:34 <ertesx> tsahyt: many bindings are split into two parts: a "raw" part, which is a stateful API, and a high-level part, which is a pure wrapper that uses unsafe stuff and makes sure that things are copied on update
02:34:50 <koz_> joneshf-laptop: I would define that as a custom datatype, with the distinguished element, its position, and everything else.
02:34:52 <joneshf-laptop> but the order of where it is is important
02:34:55 <tsahyt> ertesx: I do very much the same here. The raw bindings themselves are just much much worse.
02:35:02 <tsahyt> and the high level ones aren't all that high level yet
02:35:05 <koz_> This means your list can't be empty, but it gets you the rest of what you want.
02:35:08 <ertesx> tsahyt: one option would be to leave C land immediately and translate everything into a haskell structure, which works, as long as you don't need to call C functions anymore, once you have all the data
02:35:25 <tsahyt> ertesx: problem with that is that the data changes on the C side
02:36:20 <ertesx> sounds like every C library on the planet =)
02:36:32 <tsahyt> yes, it's not exactly the pinnacle of elegance
02:36:33 <ertesx> you could look into what other bindings do
02:36:40 <tsahyt> to be fair, as far as C libraries go this one is decent
02:36:52 <joneshf-laptop> koz_, distinguished element, that sounds google-worthy. Thanks!
02:36:53 <koz_> joneshf-laptop: Something liek this: http://lpaste.net/306660
02:37:19 <joneshf-laptop> sure
02:37:26 <joneshf-laptop> makes sense
02:37:31 <joneshf-laptop> koz_, thanks!
02:37:43 <tsahyt> the more immediate problem with making this compose nicely is really that I have no way to tell whether a key points to an array, or a map, or a value.
02:37:49 <tsahyt> and I don't think I can even statically enforce this
02:38:02 <tsahyt> not without some wizardry anyhow
02:38:13 <koz_> Can't you make SKey a sum type, and pattern-match?
02:38:26 <tsahyt> koz_: what would I do in the case of failure?
02:38:43 <koz_> data SKey a = AnArray a | AMap a | AValue a | OhCrap ?
02:38:50 <tsahyt> say I do root .. arrayAt 10, but root points to a map
02:38:50 <koz_> Or use Maybe.
02:38:55 <ertesx> well, learn the invariants of the library
02:39:06 <ertesx> then you can do some of that using phantom types
02:39:08 <jchia> Char is a unicode character, correct? When something like System.Process.CreateProcess uses a String, i.e. [Char] to do some system stuff which inherently deals with ByteString (at least on Linux), how do they convert from String to ByteString for the system?
02:39:35 <ertesx> jchia: in most cases using your locale
02:39:39 <tsahyt> maybe might even be the sanest option
02:39:57 <koz_> tsahyt: You can also use the MonadError instance you've already got there to signal stuff exploding.
02:40:05 <koz_> But yeah, Maybe works.
02:40:19 <ertesx> tsahyt: make sure your low-level and raw bindings are complete and don't need to change anymore, then it's a matter of building a sane high-level API onto a low-level *haskell* API
02:40:27 <tsahyt> maybe for failing lookups is fairly standard
02:40:49 <koz_> tsahyt: You may want more elaborate error messages - I dunno whether this is what this API needs or not.
02:40:53 <tsahyt> ertesx: yes, in reality I'm just procrastinating here. those are all things I should think about later on.
02:40:55 <ertesx> (low-level = with Ptrs and stuff, raw = just rather direct state manipulations, but in haskell, not C-in-haskell)
02:41:03 <koz_> Either Text WhateverMyResultTypeIs could work too.
02:41:20 <koz_> (and that's essentially what MonadError Text cashes out into)
02:41:31 <tsahyt> koz_: for some errors that are thrown I just catch them and return Maybes instead directly, because it's absolutely clear why and how they would fail (aside from bad allocs, that can always get thrown by the API)
02:41:44 <koz_> joneshf-laptop: If you wanna be a really smart cookie, write a Functor instance for that type. :)
02:42:12 <koz_> tsahyt: Yes, but you may as well use Either Text Whatever then. Or define an error sum type.
02:42:24 <tsahyt> ertesx: I've so far did pretty much what sdl2 does. Raw is truly Raw, now I'm building something on top. For the most part this isn't too bad so far, but this particular part still looks like mangled C
02:42:41 * hackagebot teeth 0.2.0.2 - Dental data types  https://hackage.haskell.org/package/teeth-0.2.0.2 (jophish)
02:44:03 <tsahyt> I think I'll just continue getting rid of pointers and other ugliness for now and then readress whatever problems remain. large parts of it look pretty decent by just fixing the most obvious C-isms.
02:44:38 <jchia> ertesx: I think I'm using UTF-8. Does that mean the String gets encoded as UTF-8 and handed to the OS? What if my locale is using an 8-bit encoding, e.g. en_US.iso88591?
02:44:51 <tsahyt> thanks for the help koz_!
02:45:00 <ertesx> tsahyt: make the API *safe* first, then make it stateless and/or static
02:45:01 <koz_> tsahyt: You're welcome - I just hope it was actually helpful.
02:45:09 * koz_ is a Haskell noob.
02:45:49 <tsahyt> at least I know not to pursue things that won't work now
02:45:59 <ertesx> jchia: i can only speak for linux, but a haskell program has blown up in my face in the past with a run-time exception because of (in my case) decoding errors
02:46:18 <koz_> tsahyt: My personal experience with lenses has taught me this: every time I decide to use lenses, they end up showing me why my work doesn't need lenses.
02:46:33 <tsahyt> sounds familiar
02:46:35 <ertesx> jchia: so if it can't do the conversion, it will probably throw an exception
02:47:01 <ertesx> jchia: you could just try it out of course
02:47:11 <jchia> ertesx: I'm targeting Linux. So maybe internally I should use ByteString to make such situations impossible?
02:48:01 <ertesx> jchia: i wouldn't
02:48:27 <ertesx> ByteString is not encoding-aware
02:49:00 <jchia> unpack it into String using latin1, use String to make CreateProcess, pass to createProcess. This way, there are no weird characters
02:49:19 <ertesx> koz_: i rarely use lenses myself, but i do use traversals a lot
02:49:56 <ertesx> jchia: this way you have locked out every user, who uses UTF-8
02:50:16 <ertesx> jchia: in the cases when a haskell program blows up, it *should* blow up
02:50:31 <ertesx> and the user should fix their locale
02:51:18 <jchia> ertesx: I'm targeting Linux for my own use. When you say blow up, you don't mean that I get a failure in IO, but a run-time crash, correct? I would think that createProcess should fail instead of crash if I give a weird string as an input. I should probably experiment and see.
02:53:27 <ertesx> jchia: you get an exception
02:53:39 <ertesx> jchia: in general you will only see such an exception, if you hardcode a path
02:53:42 <jchia> ertesx: That's not so bad if i catch it
02:54:11 <ertesx> jchia: if all paths the program handles are actually given by the user (configuration files, command line args, etc.), then you should actually never see such an exception
02:54:40 <ertesx> they mostly happen when you hardcode paths or path segments, and you include uncommon characters
02:55:11 <jchia> ertesx: Why? The user could give bad configuration. Do you mean I should have already filtered out the bad user input?
02:55:31 <ertesx> jchia: in that case the configuration file will fail to decode
02:55:37 <ertesx> which is the right thing to happen
02:55:54 <ertesx> (or command line arg or environment variable or…)
02:57:41 * hackagebot json-bytes-builder 0.2 - Direct-to-bytes JSON Builder  https://hackage.haskell.org/package/json-bytes-builder-0.2 (NikitaVolkov)
02:58:06 <jchia> sounds right
03:27:43 * hackagebot json-bytes-builder 0.2.1 - Direct-to-bytes JSON Builder  https://hackage.haskell.org/package/json-bytes-builder-0.2.1 (NikitaVolkov)
03:36:09 <jchia> does anyone use fgl? How do I update the label of some edge or vertex?
03:36:50 <a3gis> Hi! I am writing a short program for playing with Fields (from mathematics). To this end, I have written a typeclass "Field" which contains the standard operations. I would like to implement the fields "Zp" (intgers mod a prime) in a generic way. Right now I have to define every type and instance manually (e.g. data Z2 = Z2 Int, ...). I would like to do something like "data Z p = Z p Int ...). This would be possible with dependent types, but I am wonde
03:36:50 <a3gis> ring if there is *some* way to achieve a similar goal in haskell, whether it be with a GHC extension or with another approach
03:38:53 <iphy> "cabal sdist" fails to add my benchmark modules
03:40:47 <fizruk> a3gis: did you see this? http://hackage.haskell.org/package/modular-arithmetic-1.2.1.1/docs/Data-Modular.html
03:41:05 <bartavelle> is there a name for rosetree-like structure that are "data Tree a = Tree a (Set (Tree a))" (Set instead of List)
03:41:09 <bartavelle> ?
03:41:30 <bartavelle> (or just sets of sets, like Tree () )
03:41:58 <iphy> any idea how to make "cabal sdist" include the benchmark modules?
03:42:22 <iphy> this is my cabal file: https://github.com/TokTok/hs-msgpack/blob/master/data-msgpack.cabal#L91
03:42:43 * hackagebot data-msgpack 0.0.7 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/data-msgpack-0.0.7 (iphydf)
03:42:52 <a3gis> fizruk: I did not, thanks! I will check the source code to answer my question
03:44:35 <fizruk> a3gis: it's pretty straightforward, you don't need fully dependent types for that, just going from type-level Nat to term-level integers (which Nat can with natVal)
03:45:51 <fizruk> iphy: you can try extra-source-files, I guess
03:46:00 <iphy> fizruk: hm.. okay
03:46:27 <fizruk> not sure why it does not include benchmarks in sdist
03:52:44 * hackagebot data-msgpack 0.0.8 - A Haskell implementation of MessagePack  https://hackage.haskell.org/package/data-msgpack-0.0.8 (iphydf)
03:57:59 <Profpatsch> Fuuzetsu: What do you have against Sayaka-chan?
04:02:44 * hackagebot wiring 0.5.0 - Wiring, promotion and demotion of types.  https://hackage.haskell.org/package/wiring-0.5.0 (seanparsons)
04:12:03 <ph88^> is it possible to use GHC.Generics to write a transform function that traverse a graph of different types and only does something to the matched type ?
04:19:50 <jophish> wait, that's odd, what's the constraint for DeltaParsing doing here: https://hackage.haskell.org/package/trifecta-1.6/docs/Text-Trifecta-Combinators.html#v:rend
04:20:40 <merijn> jophish: Rendering includes a reference to the location
04:20:51 <merijn> jophish: How would you expect to create that without DeltaParsing?
04:21:06 <ertesx> a3gis: i suggest not using TypeLits (and thus not the modular-arithmetic package), but instead using the 'reflection' package, which has TypeLits as a special case, but is a lot more generic
04:21:50 <jophish> merijn: this is a method in DeltaParsing itself though
04:22:04 <merijn> jophish: oh, you mean in the docs
04:22:29 <merijn> jophish: For some reason the type inside the class explicitly writes it
04:22:33 <merijn> So I think oversight?
04:22:38 <jophish> and ghc8.0.2 barfs on it :)
04:22:42 <jophish> https://gist.github.com/a30476ad9aabbbf17e937bf7a5c3bb23
04:23:24 <merijn> Rightfully so, I think
04:23:32 <merijn> I think it's a bug that it worked before
04:24:10 <ertesx> a3gis: https://github.com/esoeylemez/snippets/blob/master/FibNF.hs ⇐ here is an example for abstracting number fields over the additional root
04:24:23 <jophish> merijn: ghc generates invlid code. It should at least tell me it's not possible to derive
04:24:58 <a3gis> ertesx: awesome, thanks!
04:35:59 <tabaqui1> what means
04:36:02 <tabaqui1> #{enum HWND, castUINTPtrToPtr
04:36:04 <tabaqui1>  , hWND_BOTTOM    = (UINT_PTR)HWND_BOTTOM
04:36:06 <tabaqui1> }
04:36:08 <tabaqui1> in hsc code?
04:36:15 <tabaqui1> what means # exactly
04:42:46 * hackagebot servant 0.9.1.1 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.9.1.1 (jkarni)
04:42:48 * hackagebot servant-server 0.9.1.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.9.1.1 (jkarni)
04:42:50 * hackagebot servant-client 0.9.1.1 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.9.1.1 (jkarni)
04:42:52 * hackagebot servant-docs 0.9.1.1 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.9.1.1 (jkarni)
04:42:54 * hackagebot servant-foreign 0.9.1.1 - Helpers for generating clients for servant APIs in any programming language  https://hackage.haskell.org/package/servant-foreign-0.9.1.1 (jkarni)
04:46:03 <jophish> I've opened a bug https://ghc.haskell.org/trac/ghc/ticket/12768
04:46:03 <jophish> report
04:57:47 * hackagebot blazeT 0.0.3 - A true monad (transformer) version of the blaze-markup and blaze-html libraries  https://hackage.haskell.org/package/blazeT-0.0.3 (johannesgerer)
05:01:08 <dmwit> tabaqui1: Have you tried reading the Fine Documentation?
05:02:50 * hackagebot blazeT 0.0.4 - A true monad (transformer) version of the blaze-markup and blaze-html libraries  https://hackage.haskell.org/package/blazeT-0.0.4 (johannesgerer)
05:06:25 <tabaqui1> dmwit: ah, yeah, i've alread found it thx
05:06:39 <tabaqui1> there are few mentions of # in haskell
05:06:57 <dmwit> Yes, that # is not Haskell. =)
05:07:47 * hackagebot jsaddle-dom 0.5.0.1 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.5.0.1 (HamishMackenzie)
05:08:47 <tabaqui1> actually haskell does have #
05:09:00 <tabaqui1> well, ghc does
05:09:23 <tabaqui1> but it doesn't relate to my case
05:09:45 <dmwit> Right. I was careful to say "that #".
05:09:58 <tabaqui1> anyway i cannot build cross-ghc cause gcc it stupid thrash, and clang has other reasons
05:10:26 <dmwit> Oh, dang. Cross-compilation can be tough, yeah.
05:11:09 <tabaqui1> have you done it before?
05:11:35 <dmwit> I spent a bit of time trying to get an ARM cross-compiler. But the funding dried up before we really succeeded.
05:11:49 <dmwit> I doubt I'll have anything intelligent to tell you about whatever problems you're facing.
05:14:28 <tabaqui1> well, at least
05:14:50 <tabaqui1> which compiler used you?
05:15:00 <tabaqui1> cause ghc 6.2 cannot deal with simple construction
05:15:11 <tabaqui1> const int a = 5; static int b[a];
05:16:11 <dmwit> I think we were trying to modify 7.8.
05:16:36 <tabaqui1> *oh not ghc
05:16:39 <tabaqui1> gcc of course
05:16:52 <dmwit> oh, uh
05:16:54 <tabaqui1> i'm trying clang now
05:17:02 <dmwit> gcc 4.8-ish?
05:21:06 <phanimahesh> how can I repair my stack cache?
05:21:28 <phanimahesh> I messed with it directly and ghc-pkg check says a couple of packages are broken
05:21:44 <phanimahesh> but couldn't find how to fix it
05:22:10 <phanimahesh> I'd rather not have to rebuild all of the cache, is there a way to fore-rebuild just the affected packages?
05:30:57 <rcschm> hi i am looking for an example code for haskell hllist.  any pointer is appreciated.
05:32:49 * hackagebot telegram-bot 0.5.1.0 - Telegram Bot microframework for Haskell  https://hackage.haskell.org/package/telegram-bot-0.5.1.0 (akru)
05:34:02 <kuribas> Are records with partial accessor functions considered bad practice?
05:35:13 <srhb> kuribas: I think partial functions are almost always bad practice, but I can't think of a reason to ever have partial accessors. What's your use case?
05:36:19 <kuribas> srhb: I'm reading a truetype font, which has specific tables based on the type of font (truetype, bitmap, opentype).
05:36:28 <kuribas> And also common tables.
05:38:21 <ashishnegi> hi.. can i get some information about the data structures that Haskell implements internally for list/vector/map ? immutable ds are different from normal ones..
05:38:23 <kuribas> So the TruetypeFont type has common accessors (head, cmap, ...) and specific (cff, glyf, ...)
05:38:49 <kuribas> ashishnegi: what do you mean?  A list is internally a list...
05:39:12 <kuribas> ashishnegi: a vector is an array, and a map (from Data.Map) a balanced tree.
05:39:59 <kuribas> ashishnegi: but you normally don't need to worry about that.
05:40:39 <kuribas> Unless you use Data.Vector, which can sometimes illiminate the intermediate vector.
05:40:57 <ashishnegi> kuribas: there are some "functional-data-structures" that optimize time/space complexity while updates are made.. 
05:41:13 <ashishnegi> okasaki functional ds
05:41:37 <kuribas> ashishnegi: time/space complexity is usually written in the API documentation.
05:42:19 <ahihi> re: partial accessors, I prefer to structure my types so that records are distinct non-sum types
05:42:25 <ahihi> which can then be wrapped in sum type variants
05:42:49 * hackagebot ghcjs-dom-jsffi 0.5.0.2 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.5.0.2 (HamishMackenzie)
05:42:51 * hackagebot ghcjs-dom 0.5.0.2 - DOM library that supports both GHCJS and GHC  https://hackage.haskell.org/package/ghcjs-dom-0.5.0.2 (HamishMackenzie)
05:47:49 * hackagebot diagrams-graphviz 1.4 - Graph layout and drawing with GrahpViz and diagrams  https://hackage.haskell.org/package/diagrams-graphviz-1.4 (BrentYorgey)
05:47:51 <kuribas> ahihi: right
05:49:45 <ahihi> it does add some verbosity and perhaps naming awkwardness, but IMHO totality is more important
05:49:59 <kuribas> ahihi: I could abuse a typeclass to create general accessors...
05:50:16 <merijn> kuribas: That doesn't sound like nice design
05:50:23 <kuribas> lol
05:51:08 <kuribas> like Class GenericFont a where {head :: a -> HeadTable; ... }
05:51:30 <kuribas> merijn: it would save me from name the same table differently.
05:54:38 <kuribas> isn't that what typeclasses are for?
05:56:07 <merijn> I would say that people tend to overuse typeclasses
05:56:52 <kuribas> I'll get "head :: SfntFont f => f -> HeadTable", seems pretty usefull...
06:00:00 <kuribas> merijn: what harm can it do?
06:00:51 <merijn> Tends to result in more boilerplate, less readable types
06:02:04 <suppi-> hello, I'm reading data from a CSV file using cassava but have discovered it is too slow to parse it. any ideas how I can boost the speed of the parseRecord function? I only need one data type that has a few Int32, a few Int64, one Text and two Scientific
06:03:26 <suppi-> Alternatively I can try to get the data in binary format but I'm unsure how to parse it to my data type
06:04:34 <nz`> /
06:05:03 <hal_> Is SDL2 still the way to go for simple LPCM playback?
06:05:39 <Boomerang> suppi: binary format would be fast if you're really after speed: https://hackage.haskell.org/package/cereal
06:05:47 <Boomerang> *faster
06:06:46 <suppi-> Boomerang, I'm getting the data from postgres btw, using the COPY feature
06:07:18 <suppi-> this: https://hackage.haskell.org/package/postgresql-simple-0.5.2.1/docs/Database-PostgreSQL-Simple-Copy.html
06:08:13 <Boomerang> You could use a small Opaleye layer on top of postgreql simple, but it might be a bit overkill if you're really just after some Int32..
06:10:02 <suppi-> Boomerang: what do you mean?
06:10:30 <Boomerang> opaleye is a library to have typed interaction with postgresql database
06:12:15 <Boomerang> suppi-: Have you taken a look at what the Bytestring returned inside a CopyOutResult looks like? Do you have to make a separate request for every row?
06:13:10 <suppi-> Boomerang: kind of. but i couldn't make much sense of it. it looks something like this: https://www.postgresql.org/docs/9.2/static/sql-copy.html
06:13:40 <suppi-> in the examples section
06:14:15 <suppi-> I'm not exactly sure if i get a row each time or more though
06:14:33 <kuribas> suppi-: cassava is supposed to be "high performance".
06:15:18 <suppi-> kuribas: perhaps i can try to speed it up by doing something special to a specific data type?
06:16:01 <kuribas> are you doing something special?
06:16:05 <suppi-> or maybe even change the format of my data type, like to a vector or something
06:16:40 <suppi-> kuribas: just reading a lot of data
06:18:14 <kuribas> strange, parsing csv isn't that complicated
06:24:19 <Boomerang> suppi- do you need to have postgresql "copy" your data out, this could be the bottleneck since the copy feature is meant to write to a file. Whereas if you make a simple query it might be faster.
06:24:22 <suppi-> thanks anyway, kuribas and Boomerang 
06:24:35 <Boomerang> the query function documentation does say: "When processing large results, this function will consume a lot of client-side memory. Consider using fold instead."
06:24:50 <suppi-> Boomerang: not sure i understand
06:25:34 <Boomerang> so maybe use the fold function to make your request. What was the purpose of doing a copy in the first place? Does it have other benefits I am unaware of?
06:26:39 <suppi-> the copy is quite fast and combined with pipes uses very little memory. the csv parsing is most definitely the bottleneck.
06:28:59 <Boomerang> The fold function https://hackage.haskell.org/package/postgresql-simple-0.5.2.1/docs/Database-PostgreSQL-Simple.html#v:fold seems to deal with the memory part by lazily applying the function you supply to every row of the result. Which is exactly the same interface you would get after the copy except you don't have to parse the results manually
06:29:42 <suppi-> Boomerang, well, fromRow is quite slow as well
06:29:57 <Boomerang> Fair enough
06:30:43 <Boomerang> Out of curiosity, how many rows would you be parsing on average?
06:31:26 <suppi-> 10m? 20m? something like that
06:31:58 <Boomerang> That's a decent amount ^^
06:32:40 <kuribas> merijn: I created a subtype OpentypeTables for the common tables, that seems a bit cleaner design.
06:41:36 <autopawn> ?
06:45:55 <eze> is there a function that takes an string and returns a Boolean indicating if it is a Double or not?
06:47:23 <jophish> eze: you might be interested in readMaybe
06:47:24 <jophish> :t readMaybe
06:47:25 <lambdabot> error: Variable not in scope: readMaybe
06:47:52 <jophish> t Text.Read.readMaybe
06:47:52 <jophish> :t Text.Read.readMaybe
06:47:52 <lambdabot> Read a => String -> Maybe a
06:48:15 <vise890> hi all. I am moving my types in a Types.hs . My Ord instance for one of the types depends on functions defined in its own module. So right now I'm stuck with a circular dependency. What should I do? orphan instances? I'm very new...
06:48:20 <eze> jophish: That sounds good enough
06:48:20 <jophish> eze: this returns "Just someDouble" if there is exactly one parse
06:48:37 <eze> jophish: Thanks
06:48:38 <tabaqui1> when i'm trying to make static build, i get this error
06:48:41 <jophish> no problem
06:48:44 <tabaqui1> /usr/bin/ld: cannot find -lffi
06:48:52 <tabaqui1> but i definitely have libssl.so
06:48:56 <tabaqui1> in /usr/lib
06:49:02 <tabaqui1> *libffi.so
06:49:17 <tabaqui1> what am i doing wrong?
06:50:27 <Rembane> vise890: Are you moving your types from some files into the Types.hs file?
06:50:46 <jophish> tabaqui1: this might be useful https://www.reddit.com/r/haskell/comments/2s6mw4/trying_to_compile_a_haskell_program_statically/
06:52:04 <grantwu> Wow that bug is super unhelpful
06:52:27 <grantwu> Perhaps reopen it if you can repro against recent Fedora?
06:53:29 <vise890> Rembane, yes i am
06:54:58 <vise890> i'm refactoring a codebase. The type in question is a "Todo" type. and its Ord instance depends on the completion status of the Todo and its priority..
06:56:50 <tabaqui1> jophish: it looks like libffi is not static itself
06:56:57 <tabaqui1> damn, thanks anyway
06:58:44 <novak`> Is there anyone experienced with haskell-mode for Emacs?
07:00:02 <Rembane> vise890: I usually move all the functions I need for my instance declarations into Types.hs, but I have a nagging suspicion that this isn't best practice.
07:01:14 <vise890> hmm yea that smells a bit to me Rembane 
07:02:51 <vise890> I think I'll move the type and instance declarations back to their module and import it and re-expose the types in Types.hs
07:03:01 <OutlawStar> is there a reason why haskell testframework would hide my putstln from me?
07:04:10 <Boomerang> If your Todo type doesn't depend on the other types from Types you could have your Todo declaration with the functions needed in Types.Todo and then reexport the Todo type in Types
07:07:49 <OutlawStar> for w/e its working now. so nvm...
07:12:08 <vise890> Boomerang, that's exactly what I am gonna do!
07:12:29 <Boomerang> :)
07:15:25 <vise890> ok other question. if i make a newtype Priority = Priority Char is the wrapping/unwrapping all over the place the right thing to do? are there other ways?
07:16:12 <Rembane> vise890: newtype Priority = Priority { getPriority :: Char } is a quite nice way to do it.
07:16:25 <Rembane> vise890: Which of course doesn't mitigate the wrapping/unwrapping.
07:16:42 <Rembane> vise890: Another way is to just create a type alias depending on how typ safe you want to be.
07:17:16 <vise890> i need an Ord instance (priority A is "larger" than pri B)
07:17:55 <grantwu> I think you can use GeneralizedNewtypeDeriving
07:18:10 <vise890> I like the record approach Rembane 
07:18:35 <vise890> grantwu, let me have a look at it
07:19:37 <vise890> grantwu, and then derive IsChar?
07:19:59 <grantwu> Uh... Ord?
07:20:17 <grantwu> Can you not reuse the Ord instance for Char
07:20:26 <vise890> no because it's the other way around
07:20:37 <vise890> A > B 
07:20:51 <grantwu> you want to flip the total ordering provided by the Ord instance for Char?
07:21:10 <vise890> yes
07:21:27 <grantwu> Oh, hrm, never mind, I don't know of a great way of doing that
07:21:38 <vise890>   compare (Priority p1) (Priority p2) = flip compare p1 p2
07:21:53 <grantwu> well yeah, that.
07:21:56 <vise890> all right cool, no worries .. i'll go back to coding. Thank you all!
07:22:00 <grantwu> I don't know of a way that doesn't involve you writing code
07:22:19 <vise890> grantwu, i'll be all right! writing code it is
07:23:36 <Rembane> vise890: Why do you use Char to model a priority btw?
07:36:56 <jophish> There's also Data.Ord.Down
07:36:56 <jophish> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Ord.html#t:Down
07:37:26 <jophish> although using Char for this seems a little strange
07:42:56 * hackagebot rattletrap 0.1.0 - Parse and generate Rocket League replays.  https://hackage.haskell.org/package/rattletrap-0.1.0 (fozworth)
08:01:25 <roconnor> I want to deserialise a stream of data into a growable sequence of element with random access to that sequence.
08:01:37 <roconnor> what is a good data structure / library for this?
08:03:11 <roconnor> Data.Sequence?
08:06:53 <volhovm> Hi guys! Can someone please explain why ByteString's IsString is broken?
08:06:58 <volhovm> http://pastebin.com/0kSfGDfE
08:21:04 <glguy> volhovm: ByteString's IsString instance is for latin1 encoded strings. It's intended for specifying bytes, not text
08:22:05 <jophish> I'm a little surprised it has an IsString instance at all
08:22:58 * hackagebot hledger-lib 1.0.1 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.0.1 (SimonMichael)
08:23:00 * hackagebot hledger 1.0.1 - Command-line interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-1.0.1 (SimonMichael)
08:23:02 * hackagebot hledger-ui 1.0.1 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-1.0.1 (SimonMichael)
08:25:48 <volhovm> glguy: i find it illogical. IsString a means that what's inside quotes is represented in 'a''s datatype in the same way. What if i want to get exactly byte sequence of unicode chars?
08:26:05 <glguy> Unicode characters don't have a byte sequence
08:26:17 <dolio> Do you think every Num instance except Integer is broken, too?
08:26:35 <srh> There are worse IsString interfaces
08:26:54 <sham1> Also, in Unicode, the term "character" is left ambiguous as different codepoint combinations can mean different things to different people
08:26:55 <dolio> And every And every Fractional instance except Rational?
08:27:01 <dolio> Oops.
08:29:27 <sham1> Isn't there a SQL library where the queries have IsString instance?
08:29:37 <dolio> Wouldn't surprise me.
08:29:54 <sham1> To be fair, for a SQL query, it makes more sense
08:30:02 <volhovm> glguy: my source file has encoding though.
08:30:53 <tabaqui1> I'm trying to compile static package with hsopenssl, but get a lot such errors
08:31:05 <volhovm> glguy: but i've got your point, thanks
08:31:10 <glguy> volhovm: The source file encoding is only used to get the file into GHC, it doesn't have anything to do with the meaning of your string literals
08:31:10 <tabaqui1> /usr/lib/gcc/x86_64-pc-linux-gnu/6.2.1/../../../../lib/libssl.a(s3_both.o): In function `ssl_cert_type':
08:31:12 <tabaqui1> (.text+0xa83): undefined reference to `X509_certificate_type'
08:31:30 <tabaqui1> I have static openssl, and with simple C code it works fine
08:31:50 <tabaqui1> oh, hm, not fine
08:42:59 * hackagebot zim-parser 0.2.1.0 - Read and parse ZIM files  https://hackage.haskell.org/package/zim-parser-0.2.1.0 (robbinch)
08:46:37 <DrEntropy> instance Functor ((->) a) .... this is only defined in GHC ?  I mean it is not in the Haskell 2010 report.  Does it depend on some GHC extension to the standard?
08:47:52 <glguy> No, implementing that instance doesn't depend on an extension
08:51:03 <glguy> tabaqui1: The X509 symbol comes from libcrypto, not libssl, so you might check that you're linking against all the libraries you're using
08:51:08 <DrEntropy> Ok thanks
08:54:07 <tabaqui1> glguy: oh, well, looks like all missing symbols are from libcrypto
08:54:11 <tabaqui1> thanks!
08:54:15 <quangl> hey
08:54:28 <quangl> is there a way to get rid of all the ping timeout messages and ?
08:54:45 <tabaqui1> glguy: nope, i have libcrypto.a
08:55:10 <glguy> quangl: In IRC? You'll have to ask on the IRC channel for whatever client you're using
08:56:03 <Clint> tabaqui1: is this openssl 1.1?
08:59:37 <glguy> quangl: On my client I collapse those to look like this http://imgur.com/a/ClCdA
09:00:30 <quangl> howd u do that?
09:00:34 <quangl> i am using floe
09:02:27 <glguy> It's the default behavior on my client, I've never heard of floe though. Looking at a screenshot it doesn't have that many settings, so you just just look through them for one to hide joins and parts
09:03:05 <quangl> which one are u using?
09:03:21 <glguy> http://hackage.haskell.org/package/glirc
09:04:39 <quangl> wait im on windows
09:04:58 <glguy> Bummer :(
09:05:03 <quangl> glirc is a console IRC client with an emphasis on providing dynamic views into the model of your IRC connections.
09:05:06 <quangl> what does that mean
09:05:17 <quangl> sounds cool but idk what its saying
09:05:44 <glguy> Lots of clients treat the chat windows as message buffers where output is written to
09:06:00 <glguy> so if you list the bans, for example, the bans are just added to the bottom of the window view
09:06:17 <glguy> or if you search for messages the results are added to the bottom
09:06:28 <quangl> not sure what u mean by that
09:06:32 <quangl> like another window?
09:06:45 <glguy> No, like mixed in with the chat messages permanently
09:07:13 <glguy> if you ignore someone it only affects new messages getting added, if you unignore them it only affects new messages they write
09:07:28 <quangl> ok.   dont all irc do that?
09:07:40 <glguy> that's what glirc doesn't do
09:08:18 <quangl> well why dont u want it to do that
09:08:28 <infandum> let xs = [1..10000]; res <- sequence $ (\a b -> return a) <$> xs <*> ys              results in a stack overflow. Why?
09:08:43 <quangl> i think i might switch to this
09:08:44 <quangl> https://dev.adiirc.com/boards/6/topics/195?r=207
09:08:54 <quangl> i mean it looks nice
09:09:05 <glguy> It disrupts the chat view to run other commands and information is lost
09:09:08 <quangl> i just need an irc with a transparent background so i can see it while doing other things too
09:09:22 <infandum> Isn't the IO monad strict, so it computes the list in the bind as it goes?
09:09:29 <quangl> so i need always on top and transparent 
09:09:34 <quangl> do u know one that does that?
09:09:48 <glguy> quangl: I don't use Windows
09:10:47 <fr33domlover> quangl, you can use any text based client with a terminal emulator that supports transparency
09:11:06 <quangl> ok
09:11:16 <quangl> so do u have a brand i should choose?
09:12:30 <fr33domlover> quangl, popular text based irc clients are weechat, irssi, ERC in emacs... and popular terminal emulators are probably GNOME terminal, whatever KDE's equivalent is, rxvt, XFCE terminal...
09:12:59 <fr33domlover> (but I'd give a try to glirc with pleasure)
09:13:00 * hackagebot json-bytes-builder 0.2.1.1 - Direct-to-bytes JSON Builder  https://hackage.haskell.org/package/json-bytes-builder-0.2.1.1 (NikitaVolkov)
09:13:22 <amx> quangl: if you are on windows the classic choice is mIRC
09:13:25 <Sose> I'm not sure what'd be good on windows
09:13:37 <lpaste> glguy pasted “for infandum” at http://lpaste.net/307459
09:13:46 <Sose> I use cygwin + tmux + weechat
09:13:48 <fr33domlover> (1) install GNU/Linux distro (2) pick from the list above :P
09:13:59 <glguy> infandum: If that's what you meant (assumes s/ys/xs) then I can't reproduce your stack overflow from just the code you've provdied
09:15:42 <infandum> glguy: What about in ghci?
09:16:12 <fr33domlover> infandum, i think if the list is consumed gradually it's because Haskell is lazy, not because of IO being anything
09:17:56 <quangl> or i go back to mirc
09:18:15 <infandum> glguy: Running the code you posted with stack ghc test.hs resulted in a stack overflow for me
09:18:46 <infandum> fr33domlover: I just found this: http://neilmitchell.blogspot.com/2015/09/making-sequencemapm-for-io-take-o1-stack.html
09:18:49 <quangl> wtf
09:18:52 <infandum> I guess I'll try out their version
09:18:56 <quangl> its got a 30 day valuation
09:18:58 <quangl> omg
09:19:40 <MarcelineVQ> it pretty much always has, you could still use it after it 'runs out' though, at least back in the day
09:20:13 <MarcelineVQ> hexchat is the superior windows option though
09:20:26 <quangl> ya mirc is ugly
09:20:32 <quangl> i remember why i quit using this
09:21:24 <quangl> i need one that looks like im a hacker
09:21:32 <quangl> like black with transparent background
09:21:36 <quangl> and always on top
09:21:47 <quangl> not white with modal windows
09:21:48 <dolio> If you're not going to talk about Haskell related stuff, take the discussion somewhere else.
09:22:08 <quangl> but people here are helping me
09:22:25 <amx> #haskell-offtopic
09:23:01 * hackagebot http-reverse-proxy 0.4.3.2 - Reverse proxy HTTP requests, either over raw sockets or with WAI  https://hackage.haskell.org/package/http-reverse-proxy-0.4.3.2 (MichaelSnoyman)
09:29:10 <infandum> weird, the function methods they were talking about isn't in extras
09:29:13 <infandum> when they say it is
09:33:01 * hackagebot json-bytes-builder 0.2.1.2 - Direct-to-bytes JSON Builder  https://hackage.haskell.org/package/json-bytes-builder-0.2.1.2 (NikitaVolkov)
09:38:02 * hackagebot withdependencies 0.2.4 - Run computations that depend on one or more elements in a stream.  https://hackage.haskell.org/package/withdependencies-0.2.4 (SimonMarechal)
09:43:02 * hackagebot json-bytes-builder 0.3 - Direct-to-bytes JSON Builder  https://hackage.haskell.org/package/json-bytes-builder-0.3 (NikitaVolkov)
09:48:02 * hackagebot stratosphere 0.2.0 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.2.0 (jdreaver)
09:52:41 <cic> hm, i'm looking for a zip function for maybe, i.e. something like Maybe a -> Maybe b -> Maybe (a, b). is there a standard function that does this? i didn't find anything on hoogle.
09:53:43 <monochrom> you may like liftA2 (,)
09:54:38 <jophish> or the zip class http://hackage.haskell.org/package/keys-3.11/docs/Data-Key.html#v:zip
09:56:39 <cic> ah, liftA2 (,) is probably the right thing to do here ... thanks.
09:59:49 <ineb> what does (==x) mean?
10:00:06 <Welkin> equal to the value of x
10:00:11 <ineb> ty
10:00:21 <Welkin> it is infix partial application
10:00:58 <Welkin> `(== "dragons")` is the same as `\a -> a == "dragons"`
10:01:35 <ineb> this makes sense
10:03:03 * hackagebot hamsql 0.9.0.0 - Interpreter for SQL-structure definitions in YAML (YamSql)  https://hackage.haskell.org/package/hamsql-0.9.0.0 (quabla)
10:05:45 <roconnor> Oh, monad fail is a thing now!
10:06:10 <monochrom> where? where?
10:06:39 <roconnor> base-4.9.0.0:Control.Monad.Fail
10:06:41 <glguy> monochrom: See http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad-Fail.html
10:06:43 <roconnor> at the very least
10:06:52 <monochrom> w00t
10:06:57 <glguy> It has a link to the proposal page for the phase in process
10:07:05 <roconnor> hah, I guess i'm not the only one surprised
10:08:06 <kuribas> :t liftM (,)
10:08:08 <lambdabot> Monad m => m a -> m (b -> (a, b))
10:08:13 <kuribas> :t liftM2 (,)
10:08:15 <lambdabot> Monad m => m a -> m b -> m (a, b)
10:08:35 <kuribas> liftA2 is liftM2?
10:08:43 <monochrom> yes
10:08:43 <Tuplanolla> The other way around, kuribas.
10:08:54 <kuribas> I see
10:09:20 <roconnor> kuribas: I often name that as (<×>)
10:09:27 <kuribas> liftM and friends are becoming legacy right?
10:09:47 <kuribas> :t (<*>) (,)
10:09:49 <lambdabot> (a1 -> a) -> a1 -> (a1, a)
10:09:58 <roconnor> I call it the Tholian operator.
10:10:15 <kuribas> wait that's a cross...
10:10:28 <kuribas> :t (<×>) (,)
10:10:30 <lambdabot> error:
10:10:30 <lambdabot>     • Variable not in scope: (<×>) :: (a0 -> b0 -> (a0, b0)) -> t
10:10:30 <lambdabot>     • Perhaps you meant one of these:
10:11:03 <roconnor> I mean I define (<×>) = liftA2 (,)
10:11:13 <kuribas> ah :)
10:11:20 <c_wraith> kuribas, liftM is sticking around as it's useful to use it as simple definition of fmap when making the Functor instance. 
10:11:52 <c_wraith> kuribas, liftM2 or more, on the other hand, isn't so handy. 
10:12:02 <kuribas> I use it sometimes
10:12:30 <kuribas> or you mean because of liftA2?
10:13:00 <Vtec234> Hello, do I need additional configuration to get ghc-mod working with stack? I have it installed through stack but it can't find the libraries I use in my project.cabal
10:13:35 <ggVGc> I have two questions. 1. How can I fix the ambiguity of getRunnerLength and 2. is this an abuse of type classes, and what should I be doing instead? https://gist.github.com/de59a8492eb00eab33ca3721e676d033
10:13:39 <roconnor> I also usually define x <+> y = Left <$> x <|> Right <$> y
10:13:57 <c_wraith> I mean liftM still has value as an independent definition from liftA or fmap. liftM2+, on the other hand, provides no utility that liftA2+ don't. 
10:14:03 <MarcelineVQ> Vtec234: try it with `stack exec -- ghc-mod`
10:14:10 <kuribas> c_wraith: right, but you could define the Functor fmap for the monadic type as well.
10:15:41 <Tuplanolla> What ambiguity, ggVGc?
10:16:22 <Vtec234> Oh nvm that, but thanks. It's a problem with working directories since my files are outside the project directory
10:16:26 <ggVGc> Tuplanolla: https://gist.github.com/bcb323b1def8942ceb3730a0b9070745
10:16:44 <c_wraith> ggVGc, fundep? 
10:17:09 <Tuplanolla> Seems like that would help.
10:17:37 <c_wraith> ggVGc, if the functional dependency | st -> a makes sense, it'd fix the problem. 
10:18:04 * hackagebot hledger-irr 0.1.1.9 - computes the internal rate of return of an investment  https://hackage.haskell.org/package/hledger-irr-0.1.1.9 (JoachimBreitner)
10:21:54 <ggVGc> c_wraith: thanks
10:22:18 <ineb> whats the precedence here? x == y || ys x
10:22:32 <c_wraith> ineb, you could ask ghci
10:22:53 <c_wraith> ineb, but == has higher precedence. 
10:23:13 <c_wraith> ineb, oh, and function application has the highest precedence. 
10:23:36 <kuribas> why wouldn't haskell accept getRunnerLength :: st -> Maybe Int?
10:23:43 <ineb> c_wraith: interesting, thanks.
10:23:43 <kuribas> it doesn't depend on a?
10:23:48 <c_wraith> (x == y) || (ys x) 
10:24:17 <c_wraith> kuribas, yes. it needs to know both the types of st and a to select an instance 
10:24:41 <kuribas> ah right
10:24:48 <c_wraith> kuribas, functional dependencies are a way of telling it how to select an instance with less information 
10:26:53 <c_wraith> ghc 8 provides some new tools, if a functional dependency doesn't work. you can allow ambiguous types, then use explicit type application to specify which you mean. 
10:30:57 <roconnor> Ah no, it finally happend.  Two monads I want to combine, but neither one has a transformer form.
10:31:25 <Tuplanolla> Can one quasiquote expressions with free variables?
10:31:29 <roconnor> Control.Unification.STBinding and Data.Serialize.Get.Get
10:31:59 <c_wraith> Tuplanolla, you mean quasiquote in the lisp sense? 
10:32:22 <glguy> Tuplanolla: Yes
10:32:27 <Tuplanolla> I was thinking of demonstrating ineb's operator precedence like this: `runQ [e| x == y || ys x |]`
10:32:31 <glguy> Prelude Language.Haskell.TH> $(stringE . show =<< [| f x y |])
10:32:31 <glguy> "AppE (AppE (UnboundVarE f) (UnboundVarE x)) (UnboundVarE y)"
10:32:41 <c_wraith> Tuplanolla, because haskell has a thing called quasiquoting in which that question makes no sense. :) 
10:34:10 <Tuplanolla> I get errors when I run that, glguy.
10:34:56 <Tuplanolla> "Not in scope: 'x'" and others to be more specific.
10:36:03 <daey> i figured out that i can print all commandline arguments via "mapM_ print args". but how can i do the following "mapM_ print readFile(args)" i.e. print the content of all files which names were passed as an argument
10:36:46 <glguy> Tuplanolla: Maybe it's new in GHC 8
10:37:24 <daey> by my logic atm i would do something like mapM_ print mapM readfile(args) :P
10:39:27 <Clint> daey: you're trying to implement /bin/cat ?
10:40:29 <daey> Clint: no i only want to loop through a list of files and apply functions to each of them. in c i would simply put a loop around my existing program and change the file name each iteration
10:40:58 <c_wraith> daey, you are on the right track, but you're not following types closely enough.. 
10:41:00 <Clint> daey: and what is the function you want to apply to each file
10:41:14 <Tuplanolla> You could do that with `forM_ args $ \ arg -> ...`, daey.
10:42:42 <Squarism> i need a database for my app and ive mainly worked with mysql. i found "mysql-simple" and "hdbc-mysql" packages, but none seem to have any significan userbase. Am i missing the goto package for this?
10:48:27 <adimit> Squarism: if I want databases in Haskell, I usually use persistent.
10:48:54 <Squarism> adimit, that a package i guess?
10:48:58 <adimit> It abstracts from the actual database almost completely, and you can just work with data types.
10:49:36 <adimit> Squarism: yes, that's a package. It does a lot of magic, though, which can sometimes be a bit hard to get to work. It's very pleasant to work with, but don't expect being able to query your db on a low level. Persistent is very high level.
10:49:55 <adimit> So, especially if you're working with an existing database, persistent might not be your first choice.
10:51:15 <nitrix> Hey. If I have multiple IORefs containing the same other IORef, does that second IORef gets collected only once all the other IORef have been changed to point to something new?
10:53:41 <nitrix> I guess my question is, does GHC knows to look at an IORef's value and recognise that the value is another IORef and maintain the other IORef alive?
10:54:24 <nitrix> And would it automatically collects it once all the other references to it are eliminated.
10:55:10 <monochrom> yes to all
10:55:27 <nitrix> monochrom: Then I have a funny idea >:3
10:55:43 <c_wraith> there's nothing really special there, except that the gc can see through reference types. 
10:56:19 <dolio> It would be pretty bad if things didn't work that way.
10:56:27 <monochrom> yeah, GC has perfect knowledge of who points to whom at run time
10:57:00 <monochrom> the only thing it doesn't know is whether your intention is the same or not
10:57:01 <nitrix> Yeah. So, then my assumption was good. Which means, I actually have a really nice clever implementation possible for memo tables.
10:58:37 <nitrix> I'm still on my quest to build cells, but it's for a lazy relational system.
11:01:04 <Tuplanolla> I just wrote an 80-line `ST` mess with lots of imports and didn't get a type error or a wrong result. Is this real life?
11:01:12 <grantwu> Or is this fantasy?
11:01:35 <nitrix> Caught in a landslide...
11:01:48 <Tuplanolla> I didn't even know it's possible to import `Vector` without having it clash with `Prelude` at least once.
11:06:01 <EvanR> nitrix: it looks into IORefs, TVars, etc but not Weak 
11:06:43 <EvanR> i havent come up with a really nice use of Weak though
11:06:57 <nitrix> Gotcha. I do have some experience with Weak, but I don't like the end result.
11:07:30 <nitrix> EvanR: It's for memoization shinanigans like I'm doing, but even that I'm unhappy with.
11:08:16 <nitrix> Hope it'll make sense once I'm done :) thanks EvanR, c_wraith, dolio, monochrom :P
11:14:09 <yulax> hi all
11:16:49 <yulax> i have a problem
11:17:41 <yulax> i have been asked to write a function, called takeUntil, which is in the format takeUntil :: String -> String -> String
11:18:10 <yulax> it performs take on some string until it gets to the string specified,
11:18:37 <yulax> e.g. takeUntil "e ch" "a fine chicken" 
11:18:49 <yulax> would produce "a fin"
11:19:09 <yulax> the problem is, i am unable to work out how to start.
11:19:35 <EvanR> this can be solved with a recursive algorithm
11:19:52 <EvanR> the key being, assume you already have the problem solved, and use it somehow to solve the problem
11:20:04 <EvanR> or assume you solved a subproblem
11:20:25 <EvanR> this is a good way to begin :D
11:20:45 <yulax> i thought about running take on strings that get one character shorter each time, until the head of the next term in the list is the string i am searching for ("e ch" in the example)
11:21:22 <EvanR> are you allowed to use any preexisting functions on strings
11:21:57 <EvanR> such as isPrefixOf
11:22:03 <frankpf> hello #haskell, I'm interested in using haskell for a small company project and I'm wondering whether or not it is the right choice
11:22:27 <frankpf> basically, it's a server that receives and sends HTTP POSTs, and it also must connect to (and manipulate) a MongoDB instance
11:22:28 <yulax> EvanR: oh, i wrote my own version of that; this was the second task.
11:22:35 <EvanR> great
11:22:39 <frankpf> so it's really basic stuff
11:22:44 <Tuplanolla> What answer are you expecting, frankpf?
11:22:56 <frankpf> my question is: do you think haskell is a good choice for that and, if so, where would be a good place to start?
11:22:57 <yulax> EvanR: i will try using that in my function
11:23:49 <frankpf> (keep in mind I'm a complete beginner, I don't have any experience with monads yet, etc.)
11:23:56 <maerwald> frankpf: my rule of thumb is: if you ask the question, then the answer is no
11:24:08 <grantwu> what?
11:24:12 <grantwu> maerwald: why would that be true?
11:24:25 <frankpf> I'm thinking this would be good because it's a really small project
11:24:30 <frankpf> would probably be less than 100 lines of python
11:24:33 <maerwald> using haskell in company environment is a huge commitment, unless you already have a team of haskellers, in which case you would not ask that question
11:24:35 <mmaruseacph2> is there a way to tell stack to only run one benchmark suite instead of all?
11:24:54 <Tuplanolla> You can suffer those 100 lines rather quickly, frankpf.
11:25:24 <frankpf> I don't think it's a huge commitment in this case given the scope of the project
11:25:48 <mmaruseacph2> frankpf: try it, I'm working now at a company which started as using Rust and gradually switched over Haskell
11:25:55 <maerwald> frankpf: don't take that too lightly, someone else will have to maintain it later
11:26:24 <maerwald> you can't just tell a js developer "take a week off and learn haskell". So you either have a team already or you don't. Don't "try" it.
11:26:29 <maerwald> do it properly, or not at all
11:26:55 <grantwu> I'm curious how maerwald thinks companies should adopt haskell
11:27:10 <grantwu> Like, are they supposed to just hire a team of haskellers?
11:27:20 <grantwu> Or should you just know Haskell before you start the company
11:27:27 <maerwald> grantwu: you start projects without having a team to do it? :o
11:27:36 <maerwald> interesting approach
11:28:04 <maerwald> if you have a php project and none of your developers have ever done php... it doesn't matter. You learn it in 2 hours.
11:28:23 <maerwald> that's not the case for haskell, so you need a little bit more strategic positioning
11:28:24 <grantwu> You try it out on small things.
11:28:41 <maerwald> if you have an R&D department maybe
11:28:49 <grantwu> That's what IMVU did.
11:29:06 <grantwu> https://chadaustin.me/2016/06/the-story-of-haskell-at-imvu/
11:29:08 <sclv> i think the difficulty is overstated
11:29:15 <maerwald> I don't think so
11:29:18 <sclv> if you know haskell and want to write simple services in it
11:29:20 <sclv> just do it!
11:29:21 <grantwu> "We started by, during the next hack week, forming a small team of everyday engineers to learn Haskell and work on a feature."
11:29:24 <sclv> (i also speak from experience)
11:29:28 <maerwald> me too
11:29:37 <sclv> if you want to adapt haskell for a big project and team you need to be cautious
11:29:39 <grantwu> So yes they started with nobody knowing Haskell
11:29:48 <sclv> but just reaching for it for small services and growing out knowledge gradually
11:29:52 <sclv> with increasing buy-in
11:29:59 <sclv> is a very viable strategy that people have also done with success
11:30:03 <maerwald> grantwu: great, you found a success story on the internet ;)
11:30:09 <monochrom> I will just point out the obvious tautology that I was not born with Haskell knowledge.
11:30:15 <maerwald> you can find one for probably anything
11:30:15 <sclv> the only reason you need to make an all-in buy-in early
11:30:22 <sclv> would be if management imposes it
11:30:56 <sclv> small projects can always be rewritten worse case
11:31:02 <sclv> and small maintenance if you document well is ok
11:31:07 <maerwald> the jump from zero to haskell company is bigger than from zero to, say, a random js development house. You'll be surprised if you underestimate that
11:31:08 <monochrom> I will then point out a pretty useful model that a company is just like a bigger person.
11:31:08 <sclv> even for a not-first-language for many
11:31:25 <sclv> but you're just having "a small haskell service" not being "a haskell company"
11:31:32 <sclv> you can go in many paths to the latter
11:31:33 <thoughtpolice> Plenty of our clients don't have "R&D departments". Many of them are ordinary programmers in a variety of contexts, from small to large projects. The main distinguishing difference is that these companies have some people who know Haskell.
11:31:34 <ongy> also depends a bit on the environment. I would love to use haskell at my uni job, but the people working with everything change often, and only a few know haskell
11:31:36 <sclv> but incremental is fine!
11:31:42 <maerwald> sclv: you're committing resources
11:31:50 <thoughtpolice> You don't need to create fake goalposts. You can just say it: Haskell has a smaller talent pool and generally much smaller buy in. That's it.
11:32:13 <maerwald> thoughtpolice: agreed
11:33:03 <JuanDaugherty> haskell is the advanced lang of this time and as such has a much higher profile than those that were in that position in the past
11:33:17 * maerwald checks the Tiobe index
11:33:24 <JuanDaugherty> comparing it now to say smalltalk in 1985
11:33:49 <maerwald> 0.522%
11:33:50 <sm> yikes, that doesn't end well
11:33:55 <JuanDaugherty> and yeah it's pretty high on tiobe, like 20 or something a few years back
11:33:59 <maerwald> 34
11:34:10 <maerwald> just slightly ahead of Prolog
11:34:17 <JuanDaugherty> the different lisps add up to more i think
11:35:02 <JuanDaugherty> was thinking 40 but thought that was too low, prolly was then
11:35:08 <yulax> i will admit 
11:35:12 <frankpf> the thing is, this is a small service that will not need heavy maintenance. In the worst case scenario, if I leave the company and nobody understands the code, it could be rewritten in another language using the existing documentation
11:35:15 <frankpf> that would take 2 evenings max
11:35:19 <yulax> i am utterly flumoxed by this one
11:35:35 <monochrom> go ahead and do it
11:36:15 <maerwald> frankpf: oh, someone thought that way here too... small project, his favorite language was Scala with a lot of weird libraries... now I'm the only one who understands the code
11:36:17 <monochrom> for all I know, my endorsement carries 0% weight, your supervisor's endorsement carries 100% weight.
11:36:51 <maerwald> frankpf: because the rest doesn't do FP at all :o 
11:36:54 <dmiles> i m thinking R&D depts are turning to Haskell shops?
11:37:11 <frankpf> maerwald: how small?
11:37:12 <maerwald> (although I don't consider Scala FP, but...)
11:37:23 <maerwald> dunno, 10k LOC?
11:37:36 <JuanDaugherty> dmiles yeah it could be that pervasive
11:37:38 <dmiles> oh actually the last R&D depts i worked at did use Scala
11:37:47 <frankpf> maerwald: this one would be ~100 LOC 
11:38:30 <dmiles> i had no interest in learning scala .. so i wrote java code in scala syntax :) now if they were diong Haskell i would have bothered to want to learn it
11:39:42 <maerwald> if you want to know why scala sucks, do a simple task: google how to write a _real_ enum in scala :P
11:39:43 <dmiles> i left becasue the new stuff we were inventing was still going to be lightyears behind the previous R&D job 
11:40:00 <maerwald> then you know why the language is misdesigned
11:40:18 <dmiles> is the Enum problem the same problem as Java?
11:40:18 <maerwald> 20 blog posts, 30 SO answers, all different
11:40:29 <maerwald> pick one you like
11:40:37 <maerwald> (and all suck)
11:41:13 <dmiles> (the problem in Java is the system does stupid back flips to make valid bytecode)
11:41:32 <dmiles> (to simulate how an Enum should work)
11:42:06 <EvanR> by enum are we talking about C enum ?
11:42:16 <dmiles> whenever i wrote Scala i always decompiled it with Jad and Procylon to see what was going on.. every time i was horified
11:42:33 <APic> ,o0(Note to Self: Decompile less.  ;)))
11:42:57 <dmiles> it was the same manner of type-wanking to workarround the JVM
11:43:08 * hackagebot Slides 0.1.0.9 - Generate slides from Haskell code  https://hackage.haskell.org/package/Slides-0.1.0.9 (darwin226)
11:43:23 <dmiles> that is for every class it make an singlton instance that everything had to pass thru
11:43:42 <EvanR> dont look at how functions are implemented in clojure
11:43:55 <EvanR> the answer may horrify you
11:44:11 <EvanR> its ok because "the jvm is really awesome at optimization"
11:44:11 <dmiles> is it that it gets the sybol instance and dispatches over it?
11:44:44 <dmiles> erm in clojure it passes function calls thru an envrionmnet awaresymbol?
11:45:11 <dmiles> erm in clojure it passes function calls thru an "environmnet aware symbol"?  
11:45:23 * EvanR waits for this question to reach its limit point
11:45:34 <dmiles> i studied Rich Hickeys .net compiler and that is what it did
11:45:48 <EvanR> wth is an environment aware symbol o_O
11:46:15 <dmiles> it allows you to redefine the trampoline site and creates lexical bindings to pass 
11:46:34 <EvanR> ah i did not know about that ability
11:46:41 <alexv111> Is there a name for a Tree which nodes has type `a` and leafs has other type `b`? `data Tree a b = Node a [Tree a b] | Leaf b`
11:47:00 <dmiles> intially its to at least find the trampoline .. (so it can lazilly resolve the method)
11:47:44 <dmiles> then after its found and the call params are decided.. it converts the callers parameters to make the callee happy
11:48:03 <EvanR> ok i am sufficiently horrified
11:48:05 <dmiles> this is mitigated thru the Sybmol object
11:48:07 <EvanR> lets go back to haskell
11:48:22 <dmiles> hehe
11:48:59 <dmiles> Scala was so bad at the caller to callee relationship .. it wascreating class level support bjects that were overkill
11:49:19 <dmiles> want so bad at the caller+callee reeltionship
11:49:29 <dmiles> damn sorry *WASNT* 
11:50:08 <dmiles> i am startign to analize the Haskell JVM compiler a bit 
11:50:54 <dmiles> though just seeing what i can steal :(
11:53:08 <dmiles> though i might have to actualyl support Haskell code in CYC instances.. that is the real goal to
11:54:58 <dmiles> just due the the fact that R&D depts of the future are going to be the kids that graduate knowing Haskell
11:56:47 <Malkrith> I like Haskell for filtering 
11:57:33 <joe9> need some advice, please? I have a haskell library that uses a Context https://github.com/joe9/9pserver/blob/master/Network/NineP/Context.hs#L133 . I want to use this library from a program that has it's own state. What is the haskell design pattern to merge the State into the library's context?
11:58:02 <joe9> I think xmonad has a field for User Data
11:58:11 <joe9> I am not sure if that is the recommended approach though.
11:59:11 <maerwald> what does "merge" mean?
11:59:23 <maerwald> and why would you?
12:00:47 <joe9> maerwald, https://github.com/joe9/akb/blob/master/app/Main.hs#L68 is how I am calling the library server function.
12:01:15 <joe9> maerwald:  I need to thread the state of this calling program  through the functions of the library.
12:01:25 <joe9> maerwald: does that make sense?
12:02:01 <maerwald> that sounds like a function argument
12:03:30 <joe9> yes, the library's function argument. Should I leave that as a type variable in the library function definition?
12:04:14 <maerwald> why not
12:04:36 <dmiles> EvanR: actually tough i rather hear what you found wrong witht eh scala compiled from
12:04:41 <maerwald> do stuff the easy way, refactor only when it gets annoying
12:04:41 <joe9> makes sense. Thanks.
12:05:05 <maerwald> e.g. don't invent monad stacks before you actually need them
12:05:25 <maerwald> haskellers tend to over-engineer :P
12:05:59 <EvanR> dmiles: parse failure, partial result: i think you got the wrong guy
12:06:33 <dmiles>  <EvanR> dont look at how functions are implemented in clojure  <- i assumed you looked
12:07:34 <dmiles> (i looked not at the jvm clojure but the .net clojure so i assumed it was simular .. but wondered what exactly the issue was)
12:08:31 <EvanR> i dont know anything about scala
12:08:52 <larryba> hi. why doesn't % take precedence over function call? it would be a lot neater to write func 1%3 2%3 over func (1%3) (2%3)
12:09:14 <EvanR> well
12:09:14 <joe9> maerwald: can I pm you? there are 2 options I have before me and I want to get an expert opinion
12:09:16 <dolio> No operators take precedence over function calls.
12:09:20 <EvanR> func 1 % 3 2 % 3
12:09:25 <monochrom> because % is not a special case
12:09:27 <t0by> so
12:09:29 <t0by> what do you call a computer scientist with a love of moatoarspoarts?
12:09:48 <EvanR> usually clever use of whitespace isnt a conventional way to make haskell code more readable
12:09:54 <EvanR> func 1 % 3 2 % 3 -- so this is what people see
12:09:55 <monochrom> I call that someone who needs to move to #haskell-offtopic
12:10:02 <maerwald> joe9: I'm not an expert
12:10:20 <joe9> maerwald: that's ok. you know more than me.
12:10:20 <maerwald> asking here will make it more likely an expert will answer :P
12:10:20 <larryba> EvanR I don't care about spaces. 1%3 denotes a number
12:10:28 <EvanR> 1 % 3, yeah
12:10:33 <EvanR> a smart constructed rational
12:10:35 <larryba> it is not an operator, like +, it is a number constructor
12:10:41 <EvanR> it is an operator
12:10:42 <t0by> O_o
12:10:51 <EvanR> :% would be a ctor
12:10:53 <larryba> isn't it a data constructor?
12:10:54 <Malkrith> It's totally an operator 
12:11:00 <dmiles> what is the answer t0by ?
12:11:05 <EvanR> > 1 :+ 1
12:11:08 <lambdabot>  1 :+ 1
12:11:24 <t0by> dmiles: a c.a.r. hoare.
12:11:30 <monochrom> even list constructors don't receive special VIP treatment. you don't write like tail 1:2:[]
12:11:32 <EvanR> f 1 :+ 1 2 :+ 2
12:11:36 <t0by> how is % not an operator.
12:11:41 <t0by> or rather
12:11:45 <larryba> don't dwell on it too much
12:11:49 <t0by> what makes you think % is not an operator.
12:11:51 <EvanR> (f 1) :+ (1 2) :+ 2
12:11:59 <yulax> i was not sure how to solve the function takeUntil, so instead i implemented dropUntil (the equivalent task equivalent to drop).
12:12:06 <t0by> honest question, the reason is probably something I don't know which I should know.
12:12:06 <yulax> here is my code
12:12:08 <yulax> http://paste.debian.net/hidden/0f51fbe2/
12:12:25 <larryba> why can't we write constructors with higher precedence than function calls
12:12:28 <yulax> it throws up some weird behaviour though
12:12:37 <yulax> i have pasted an example.
12:12:47 <joe9> is this valid? https://paste.pound-python.org/show/GHJX5RU8yKmMVtk0Mzzd/
12:12:58 <dmiles> t0by: :)
12:13:12 <joe9> https://paste.pound-python.org/show/y3xt8Ut3gpmS35juiHly/ is all the data structures being used.
12:13:26 <ongy> yulax: becuase you are doing weird things
12:13:30 <joe9> maerwald: if I want to add a user state component to dWrite on line 52
12:13:32 <yulax> yes i know
12:13:33 <ongy> what do you expect the take to do? in line 4
12:13:49 <monochrom> larryba: don't dwell on it too much
12:13:56 <EvanR> larryba: the interaction of function application and operator precendence is kind of part of haskell... i dont see what you see when you write f 1 + 2 3 + 4
12:13:57 <yulax> well, the logic is that it is taking everything after the pattern match
12:14:10 <joe9> maerwald: I would have to change the data definitions of Details on line 44 and the definition of FSItem in the 2nd line.
12:14:23 <maerwald> joe9: does the function need to change the state?
12:14:25 <larryba> EvanR + is not a constructor
12:14:27 <maerwald> or is this just input
12:14:32 <joe9> maerwald: yes, it does.
12:14:33 <EvanR> larryba: ok, replace that with :+
12:14:37 <EvanR> still doesnt make sense
12:14:47 <larryba> what is :+?
12:14:51 <EvanR> :t (:+)
12:14:53 <lambdabot> a -> a -> Complex a
12:14:56 <joe9> maerwald:   , dWrite :: Fid -> Offset -> ByteString -> FidState -> FSItem s -> s -> u -> IO (Either NineError Count, s, u)
12:14:59 <ongy> yulax: you are taking (length ys + <something >0>) from ys, so that's ys
12:14:59 <EvanR> ctor for Complex
12:15:13 <joe9> maerwald: the 'u' is what I am referring to as the user state or user data.
12:15:25 <joe9> maerwald: the 's' is the library's context.
12:15:46 <larryba> EvanR it doesn't make sense because you're used to the rules, which don't make sense
12:15:55 <maerwald> if this is a single-threaded program I'd probably be lazy and mess around with IORef since you're already inside IO
12:15:57 <EvanR> i am used to the rules
12:15:58 <ongy> and the string you check in the guard is (y:ys) not ys, which is why you lose the first char
12:15:58 <joe9> maerwald: or , https://paste.pound-python.org/show/XkvRCzSkDvAzkxoTLHq9/ I can change the library Context with a cUserData field
12:16:07 <EvanR> at least we have rules
12:16:26 <larryba> :+ defines a complex number, so as far as i can see it should take precedence over everything else
12:16:33 <dolio> Why?
12:16:35 <EvanR> f 1 :+ 2 3 :+ 4
12:16:40 <maerwald> which means you wouldn't neet state monad or anything, but would pass IORef around and just modify it
12:16:45 <EvanR> gibberish
12:17:00 <joe9> maerwald: yes, that seems an easier solution. less changes.
12:17:10 <joe9> maerwald: is it a good practice to use IORef's?
12:17:13 <EvanR> f1 :+ 23 :+ 4
12:17:16 <EvanR> :D
12:17:22 <EvanR> who needs whitespace
12:17:27 <maerwald> joe9: I don't know, depends on the use case
12:17:40 <ongy> EvanR: I think the lexer
12:17:41 <monochrom> > foldr(+)0[1,2,3]  -- who needs whitespace indeed
12:17:43 <lambdabot>  6
12:17:50 <larryba> EvanR, it is gibberish because you deliberately made it look like gibberish. f 1:+2 3:+4 is perfectly readable
12:18:02 <EvanR> f1:+23:+4
12:18:09 <EvanR> looks good, ship it
12:18:14 <monochrom> (logical conclusion: space is not the function application operator)
12:18:25 <larryba> and easier to write than f (1:+2) (3:+4)
12:18:36 <larryba> EvanR that is gibberish regardless of how haskell interprets it
12:19:00 <EvanR> no youre gibberish regardless of how haskell interprets it! so there
12:19:17 <larryba> and your mother is a whore
12:19:17 <monochrom> could you two move the debate elsewhere?
12:19:17 <larryba> :-D
12:19:38 <monochrom> and please don't do that.
12:19:39 * EvanR returns to care about what haskell interprets
12:20:01 <larryba> i think we didn't even need the debate. "it's just one of those rules that makes no sense but it's just an inconvenience" would have sufficed
12:20:32 <dolio> It makes exactly as much sense as your rule.
12:20:33 <EvanR> taking that seriously, youre saying removing whitespace between stuff and an operator should increase precedence
12:20:49 <EvanR> i.e. "binds tighter" is taken visually serious
12:20:50 <Tuplanolla> I wouldn't mind that.
12:20:51 --- mode: ChanServ set +o monochrom
12:20:57 <monochrom> Seriously, are you people done?
12:21:32 <larryba> monochrom, you should relax a bit
12:21:40 --- mode: monochrom set +b *!*@h27.47.138.40.static.ip.windstream.net
12:21:40 --- kick: larryba was kicked by monochrom (larryba)
12:21:44 <monochrom> Anyone else?
12:22:12 --- mode: monochrom set -b+b *!*@h27.47.138.40.static.ip.windstream.net $a:larryba
12:22:24 <t0by> monochrom, I am not trying to get banned as well, but can I ask something?
12:22:30 --- mode: monochrom set -o monochrom
12:22:32 <monochrom> yeah
12:22:39 <joe9> maerwald: just thinking about it, if the function does not change the state, it could just be a function argument, correct?
12:22:40 <Tuplanolla> It doesn't sound any more controversial than semantically significant indentation.
12:23:19 <maerwald> joe9: yeah, but if you need to change it, you either need to return it (e.g. tuple), use an abstraction like state monad (or similar) or... if you're already inside IO, you can be lazy and switch to IORefs
12:23:50 <EvanR> when you put it like that no, but i had to explain it as such for it to make sense. basically taking the trolls point away and reclaiming it
12:23:59 <t0by> monochrom, I didn't try to follow the discussion, but is there any reason outside of the your-mother line that larry got banned? I sense that you didn't approve of the conversation as a whole, but why, specifically?
12:24:11 <t0by> * s/I didn't try to follow the discussion/I tried but gave up/
12:24:32 <yulax> i made a better solution. can you folks comment on it please? http://paste.debian.net/hidden/f30267eb/
12:24:33 <monochrom> heh
12:24:35 <maerwald> isn't there a channel for meta-discussions?
12:24:43 <joe9> maerwald: In a situation like this, (not this particular instance), when the library has the event loop, what is the recommended approach to structure the library's context?
12:25:26 <monochrom> OK, it's a combination of both "I am so right, just admit it" and "you need to relax" and continuing a counterproductive monologue after I asked to stop.
12:25:50 <t0by> I see, thanks.
12:26:21 <maerwald> joe9: you could switch to mtl, but then you got a lot of liftThis liftThat
12:26:22 <monochrom> each individual point alone doesn't deserve a ban, but I don't stick to separating them.
12:26:23 <t0by> Speaking of actually productive monologues - does anybody happen to know of a good resource for the uninitiated about implementations of concurrency and synchronization constructs in haskell?
12:26:29 <ongy> yulax: does it do what you want? I don't see any problems
12:26:47 <amx> t0by: http://chimera.labs.oreilly.com/books/1230000000929/index.html
12:27:14 <t0by> amx, mind you, I want to know how the primitives are implemented *in* ghc
12:27:14 <johnw> yes, that book is by far the best
12:27:23 <t0by> Not how to *write* concurrent programs in haskell.
12:27:27 <t0by> If I am making any sense.
12:27:56 <johnw> t0by: http://blog.ezyang.com/2011/02/all-about-mvars/ is one resource
12:28:17 <dmj`> t0by: the rts folder in the ghc repo is another
12:28:21 <Tuplanolla> Is this discussed in the awkward squad paper?
12:28:28 <t0by> Reason: I am taking a course with a long title that can be summed up as "runtime support for concurrency" and I have to do a presentation about how stuff is implemented in a language of my choice. Naturally, I though of haskell.
12:28:44 <t0by> dmj`, johnw, amx: thanks
12:28:52 <amx> the book also shows how the primitives are built up
12:28:55 <yulax> ongy: yes, i'm just wondering if someone might suggest a more elegant solution...
12:28:58 <t0by> amx excellent
12:29:04 <yulax> thanks tho
12:29:58 <amx> yulax: does your version work by now?
12:30:05 <ongy> yulax: the only thing I see is that http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html#v:stripPrefix may make it a bit nicer
12:30:06 <yulax> amx: yes, thanks!
12:30:19 <dmj`> SkipChan is an underrated concurrency construct
12:30:40 <amx> > let f pattern list = take 1 $ filter (isPrefixOf pattern) (tails list) in f "foo" "asdffoobarlala"
12:30:43 <lambdabot>  ["foobarlala"]
12:30:59 <yulax> ongy: the aim of the exercise is to write these functions myself, alas...
12:31:01 * dmj` writes the SkipChan-in-base-proposal
12:31:08 <yulax> but i am learning
12:31:22 <yulax> albeit somewhat more slowly than i would like
12:31:31 <EvanR> the skipchan referred to in the MVars docs doesnt seem very widely applicable...
12:32:01 <t0by> amx: sorry, *where* is it that it talks about how stuff is implemented in the runtime?
12:32:12 <t0by> I am grepping aggressively the index, but no luck
12:32:31 <EvanR> a situation where you have a "high speed" streaming source where you intentionally want to chew cpu doing nothing most of time to reduce latency
12:32:47 <quangl> hi guys
12:32:50 <quangl> what does ... mean?
12:33:13 <meditans> quangl: do you mean .. ?
12:33:34 <haskell612> why does State have kind * -> * -> *? The definition is type "State s = StateT s Identity" so I don't understand why it's not * -> *
12:33:38 <EvanR> i can see that mattering on an embedded device, which haskell doesnt run on
12:34:13 <mtn_> haskell612, Isn't it taking two kinds and returning one?
12:34:14 <meditans> as I recall, ... might be an operator in Lens.Plated, thoug
12:34:27 <EvanR> though i may soon eat my words with these $1 tiny things more powerful than my 2005 gaming rig
12:34:43 <Tuplanolla> @hoogle ...
12:34:46 <quangl> what $1 tiny things?
12:34:46 <lambdabot> Control.Lens.Operators (...) :: (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
12:34:46 <lambdabot> Control.Lens.Plated (...) :: (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
12:34:46 <lambdabot> Numeric.Interval (...) :: Ord a => a -> a -> Interval a
12:35:08 <quangl> what is control lens operators
12:35:13 <haskell612> mtn_ so why it's not State s m = ...?
12:35:26 <mmaruseacph2> guys, only one weekend left until the deadline for HCAR. Though, given that I have to work on my thesis, I guess I can take late submissions next week :)
12:35:33 <EvanR> mtn_: it takes two types and returns one
12:35:59 <mtn_> EvanR, Oh right, thanks for correcting that
12:37:10 <monochrom> quangl: Perhaps you should tell us the context of where you saw "...", and then people won't need to guess things irrelevant to that context.
12:38:15 <amx> t0by: AFAIR there is nothing about the runtime system, but you build up the more complex concurrency constructs from the basic ones
12:38:24 <amx> e.g. chans from mvars
12:39:29 <t0by> amx: I see, thanks. That's only partially interesting to me.
12:39:39 <t0by> (Not to sound ungrateful, mind you)
12:39:46 <t0by> I wonder if the spj paper is a good start
12:39:51 <haskell612> oh wait I got it, StateT s m a, I forgot the a 
12:40:13 <quangl> i saw it in react code
12:41:14 <monochrom> haskell612: there is a Haskell restriction about type synonyms. If you defined "type X s m a = ...", you would not be allowed to say things like "instance Monad (X s m)". The rule says "your definition has 3 parameters, I want to see all 3 at all use sites".
12:41:54 <monochrom> So the definition has to drop the "a" to allow "X s m" to be legal at use sites.
12:42:19 <haskell612> I was looking at the type definition of 'State' which is type State s = StateT s Identity
12:42:35 <monochrom> oh OK, forget my "m".
12:43:25 <monochrom> If you define "type X m a = ...", you will not be allowed "instance Monad (X m)". The computer wants all 2 parameters.
12:48:12 * hackagebot git-annex 6.20161027 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20161027 (JoeyHess)
13:08:13 * hackagebot colonnade 0.4.7 - Generic types and functions for columnar encoding and decoding  https://hackage.haskell.org/package/colonnade-0.4.7 (andrewthad)
13:17:58 <nitrix> monochrom: That's interesting. I thought that was just being being "clever" and doing some form of eta-reduction of type synonyms.
13:18:11 <nitrix> s/being being/people being/
13:23:24 <codedmart> Is this a bad idea? Client having an MVar WebsocketState and WebsocketState being [Client]? https://gist.github.com/codedmart/8fdb8b901fa58f16955436b13e711975
13:25:00 <codedmart> I will be passing a Client around and would like to have access to the MVar WebsocketState.
13:27:47 <willbeing> quit
13:30:58 <ph88^> hey guys, i need a list or array of bits .. what type would be the fastest ?
13:31:21 <ph88^> bits as in 0, 1 or False, True
13:31:26 <monochrom> Int
13:31:41 <ph88^> is that 64 bits ?
13:32:29 <monochrom> Int64 is ensured 64 bits. Int is 64 or 32 depending on 64-bit GHC or 32-bit GHC
13:32:33 <mmaruseacph2> you mean Word, Word8, Word64?
13:32:43 <monochrom> make it Word64, yeah
13:32:44 <mmaruseacph2> to clearly say which width you expect
13:33:00 <monochrom> the sign bit could get annoying
13:33:14 * hackagebot pandoc-citeproc 0.10.2.2 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.2.2 (JohnMacFarlane)
13:33:18 <ph88^> i was more thinking along the lines of 15.000 bits
13:33:28 <jle`> Word1
13:33:35 <mmaruseacph2> afaik Word* just ignores it
13:33:51 <mmaruseacph2> (where * is the glob expression, there's no such type with just a * there)
13:34:41 <jle`> forall N. WordN
13:34:54 <mmaruseacph2> 15 bits will still take a machine word anyway
13:35:06 <mmaruseacph2> at least one
13:35:44 <monochrom> Data.Vector.Unboxed's Vector Bool is also worth considering. It is packed bits.
13:35:56 <ph88^> not 15 bits, 15 thousand bits
13:35:58 <dolio> No it isn't.
13:36:34 <dolio> There's an issue for adding a packed bit vector.
13:36:53 <mmaruseacph2> oh, 15k bits, my bad
13:36:54 <monochrom> yikes. does the vector library have any packed bits?
13:36:58 <Tuplanolla> Usually, ph88: if you want less time, `Vector Int`; if you want less space, bits in each `Word` of `Vector Word`; if you want a compromise, `Vector Int8`.
13:37:05 <dolio> Not yet.
13:37:09 <monochrom> darn.
13:37:15 <mmaruseacph2> I was wondering why you chose to have 3 decimals after it, but didn't think you actually meant the thousands
13:37:23 <EvanR> ph88^: a lazy ByteString could implement an infinite stream of bits!
13:37:26 <monochrom> OK, go GMP and use Natural :)
13:37:38 <Hanslo> I'm having trouble importing posgresql, ErrorMsg: Could not find module `Database.PostgreSQL.Simple' , anyidea how to trouble shoot this?
13:37:45 <ph88^> less time, i have enough RAM
13:37:55 <dolio> Leaning toward not making `Vector Bool` packed, too, I think.
13:38:06 <ph88^> so i heard quite a few suggestions, but not sure which one to pick
13:38:19 <mmaruseacph2> try all and benchmark using conduit?
13:38:21 <dolio> And instead using a newtype or something for the packed version.
13:38:37 <mmaruseacph2> (I mean, that's what I'd do)
13:38:40 <ph88^> eh i just like 1 suggestion to get started, i havent even started this program yet :/
13:39:07 <Tuplanolla> Start from the compromise and see if you need some adjustments, ph88.
13:39:26 <ph88^> Vector Bool seems nice because Bool is a nice representation
13:39:58 <Tuplanolla> That should do nicely; just use the unboxed `Vector`.
13:40:03 <EvanR> round up to 16384, then use 256 Word64s
13:40:41 <joe9> Data.Vector.Unboxed is awesome. I noticed a big performance boost when I switched to it.
13:40:55 <EvanR> in an unboxed vector, yeah
13:41:28 <mmaruseacph2> yeah, like having the same algo use 24s for boxed vectors and only 1 for unboxed
13:42:57 <monochrom> you know how space and time are not always in competition. If you use more space, you use more time too (once for writing that much space, and once more for GCing over bigger space)
13:43:28 <EvanR> space and time could collude against you and gang up
13:43:28 <Rembane> Memory map could be a nice datastructure too. Just use bits in it and become best friend with Data.Bits.
13:45:44 <mmaruseacph2> as always, benchmark to see if your application scenario benefits from using a particular data structure
13:53:15 * hackagebot hledger-web 1.0.1 - Web interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-web-1.0.1 (SimonMichael)
13:53:17 * hackagebot hledger-interest 1.5 - computes interest for a given account  https://hackage.haskell.org/package/hledger-interest-1.5 (PeterSimons)
13:55:12 <PhatMac> hello all
13:55:15 <ph88^> hi
13:58:16 * hackagebot titlecase 0.1.0.3 - Convert English words to title case  https://hackage.haskell.org/package/titlecase-0.1.0.3 (PeterSimons)
13:58:56 <EvanR> hrm... should be english-titlecase
13:59:12 <ph88> after i do stack install and put a new package in my cabal file how can i load this package into ghci so that i don't have to close ghci ?
14:00:33 <monochrom> I think you don't run ghci directly. You go through stack again. I don't know the exact command.
14:00:49 <Rembane> ph88: stack ghci
14:01:05 <Rembane> ph88: And just reload as usual with :r et. al.
14:01:18 <ph88> i just tried that, didn't work
14:01:42 <monochrom> give me a typical module name from that package.
14:01:49 <mmaruseacph2> stack repl
14:01:52 <Tuplanolla> I think you need to restart GHCi when you install packages.
14:01:53 <mmaruseacph2> or stack exec ghci
14:02:01 <monochrom> but I'm going to suggest "import <module name>"
14:02:20 <mmaruseacph2> and yes, you still need to restart when you install, it needs to load the state of env again
14:02:30 <monochrom> the point being it is not going to be ":load <whatever"
14:03:07 <mmaruseacph2> ":m +module" is what I think monochrom thinks about
14:03:31 <ph88> https://paste.fedoraproject.org/462067/76021831/
14:03:52 <monochrom> yeah but "import" is more well-known. (I would say ":module +<module name>" 10 years ago)
14:04:16 <monochrom> basically there is a pretty long subtle story about :load vs {:module, import}
14:04:24 <ph88> o_O
14:04:25 <mmaruseacph2> I didn't know about import
14:04:32 <geekosaur> iit's been there since 7.2
14:04:46 <geekosaur> ph88, ghci loads the package database on startup and never again
14:05:01 <geekosaur> if you install a new package, it will not be seen until you restart ghci
14:05:04 <ph88> alright ^^
14:05:07 <monochrom> "import" was introduced along with "w00t you can 'data X = X' at the ghci prompt now!" back then when they were new-fangled additions that totally horrified me
14:05:27 <ph88> i never even heard of haskell during that time :p
14:05:31 <ph88> i always used import, didn't understand why there was still :m  ..
14:05:44 <monochrom> actually how many years ago was 7.2?
14:05:54 <monochrom> (I was making up the number "10")
14:05:56 <geekosaur> for us ancient folk who need time to change our habits :p
14:06:05 <geekosaur> (although I adapted quickly enough...)
14:06:15 <dolio> Less than 10, definitely.
14:06:17 <geekosaur> (but there may well be ghci scripts that still use :m)
14:06:23 <dolio> Closer to 5 probably.
14:06:31 <ph88> i have some questions about this page https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed.html
14:06:42 <ph88> why is there Vector Vector Bool ?
14:06:48 <mmaruseacph2> now that I know about it I realize there are only 2 or 3 cases where I could have used it instead of :m -<everything> :m +<what I need>
14:07:21 <Tuplanolla> Note the `data family` part, ph88.
14:07:49 <ph88> i'm just vaguely aware of data family .. even though i've read at least 5 pieces explaining the matter and some pieces double -____-
14:08:05 <Tuplanolla> Now's your chance to build some intuition.
14:08:15 <ph88> exactly
14:09:19 <monochrom> "import" and ":module" each have features the other lacks.
14:09:29 <mmaruseacph2> they do, I saw
14:09:46 <kuribas> ph88: to have unboxed vector of Bools?
14:09:49 <geekosaur> 9 Aug 2011 was 7.2.1
14:09:50 <monochrom> "import qualified A.B.C as D (x,y) hiding (z)" does not have a :module equivalent.
14:09:54 <ph88> lol funny opposite of cons is named snoc
14:10:06 <geekosaur> so almost exactly 5 years
14:10:11 <mtn_> EvanR (or anyone else)  To clarify my earlier mistake, kind would be like * -> * or *, etc., and each * would be a type, right?
14:10:37 <EvanR> * -> * is a kind
14:10:38 <monochrom> ":module A.B.C" and ":module - X Y Z" do not have an "import" equivalent. ("import X" does a ":module + X", not ":module X")
14:10:41 <geekosaur> in simple cases, yes
14:10:44 <EvanR> Int is a *
14:10:45 <mmaruseacph2> mtn_: yes, but you can also have Kinds where you get a string instead of *
14:10:48 <geekosaur> :k StateT
14:10:50 <lambdabot> * -> (* -> *) -> * -> *
14:11:05 <mtn_> mmaruseacph2, what do you mean by that?
14:11:09 <Tuplanolla> That's a roundabout yes, mtn_.
14:11:17 <ph88> is Vector Bool gonna use 1 byte per boolean ??
14:11:29 <EvanR> ph88: probably much more
14:11:31 <ph88> i get that notion by seeing:  data Vector Bool = V_Bool (Vector Word8)
14:11:33 <ph88> o_O
14:11:41 <ph88> that's so inefficient
14:11:47 <ph88> it should pack bits into bytes
14:11:49 <mmaruseacph2> > :k Monad
14:11:49 <mmaruseacph2> Monad :: (* -> *) -> Constraint
14:11:51 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
14:11:53 <Tuplanolla> That gives you faster access, ph88.
14:11:57 <c_wraith> ph88, it's far worse than that if you're using a standard boxed vector. 
14:12:20 <mmaruseacph2> or using DataKinds extension, mtn_ 
14:12:32 <ph88> ok but if they are packed i can access 8 bits at once
14:12:33 <EvanR> ph88: every Bool value (well.. all two of them) is a separate heap object containing a few bytes of stuff
14:12:51 <EvanR> each vector element is a pointer, which is 8 bytes wide
14:12:52 <mtn_> mmaruseacph2, Gotcha thanks!
14:12:59 <c_wraith> ph88, but if you're looking at unboxed vectors, as you appear to be, then they used the representation that benchmarked the fastest on random access. 
14:13:22 <Tuplanolla> You'll have to do the packing manually or use a specialized vector type if you want bits, ph88.
14:13:27 <kuribas> ph88: there are also bitvectors.
14:13:36 <ph88> alright, ill just roll with this for now ^^
14:13:52 <c_wraith> ph88, if you want a different access pattern than random access, you probably want a different structure. 
14:13:56 <dolio> I'm not sure there were benchmarks involved in choosing 8 bits per boolean.
14:14:17 <dolio> But there are other reasons to prefer it, too.
14:14:35 <dolio> And reasons not to.
14:15:49 <grantwu> Isn't there this? https://hackage.haskell.org/package/bv-0.4.1/docs/Data-BitVector.html
14:15:51 <EvanR> i am now curious how many bytes each thing in each box uses in different data types
14:16:49 <c_wraith> EvanR, it's like a word for the constructor,  and then a word for each argument to the constructor. 
14:17:21 <ph88> Couldn't match expected type ‘Int’ with actual type ‘Word8’     In the first argument of ‘Vector’, namely ‘(1 :: Word8)’     why can't i force type here ?
14:17:50 <jle`> ph88: 1 is indeed a Word8
14:17:53 <kuribas> :t (1 :: Word8)
14:17:54 <lambdabot> Word8
14:17:57 <jle`> but you're giving a Word8 to something that wants an Int
14:18:07 <jle`> so maybe try (1 :: Int)
14:18:21 <c_wraith> ph88, iirc, the first argument is the length. 
14:18:23 <jle`> or just '1', and let type inference do its job :)
14:18:47 <c_wraith> wait, I got confused. 
14:19:06 <ph88> oh offset, length, underlying byte array
14:19:15 <c_wraith> I was thinking of one particular function (fromList),  but that message.. 
14:19:28 <c_wraith> why are you using Vector's constructor? 
14:19:38 <c_wraith> that's a great way to break things. 
14:20:07 <mmaruseacph2> always fromList
14:20:14 <ph88> i was just trying to get an unboxed vector of booleans
14:20:26 <grantwu> ph88: Did you see the thing I linked?
14:20:28 <mmaruseacph2> try fromList [True, True, False]
14:20:48 <forgetful> :t fromList [True, True, False]
14:20:48 <ph88> grantwu, yes i found it, i can try ti
14:20:51 <lambdabot> (Item l ~ Bool, IsList l) => l
14:21:12 <Tuplanolla> :t Data.Vector.Unboxed.empty :: Data.Vector.Unboxed.Vector Bool
14:21:13 <mmaruseacph2> :t Data.Vector.Unboxed.fromList [True, True, False]
14:21:13 <lambdabot> Data.Vector.Unboxed.Base.Vector Bool
14:21:15 <lambdabot> Data.Vector.Unboxed.Base.Vector Bool
14:21:40 <eacameron> Is there a type-level version of $?
14:21:40 * mmaruseacph2 thinks lambdabot should include the user it's responding to in the output
14:21:42 <codedmart> I might have missed the answer if there was one. Is there anything wrong with doing this -> https://gist.github.com/codedmart/8fdb8b901fa58f16955436b13e711975?
14:21:43 <younder> But a boolean is still pretty big. What about a bitvector?
14:22:06 <eacameron> So I can do ExceptT Error :$ ReaderT Config :$ LoggingT Text :$ IO
14:22:28 <EvanR> younder: theres only ever at most 2 boolean objects in the runtime
14:22:54 <mmaruseacph2> yes, but the pointers to them take a lot of space
14:23:00 <EvanR> its the references yeah
14:23:16 <EvanR> so its not the bool that is big really
14:23:17 <c_wraith> EvanR, sort of true. an unevaluated thunk that will result in a Bool is also possible. 
14:23:17 * hackagebot diagrams-rubiks-cube 0.2.0.1 - Library for drawing the Rubik's Cube.  https://hackage.haskell.org/package/diagrams-rubiks-cube-0.2.0.1 (TimBaumann)
14:23:26 <EvanR> or that
14:23:37 <ph88> is bitvector also unboxed ?
14:23:53 <glguy> eacameron: Nothing standard, but you can define type f $ x = f x. You'll need TypeOperators and will want PolyKinds
14:24:19 <glguy> Prelude Control.Monad.Trans.Reader> type f $ x = f x; infixr 0 $ --- Prelude Control.Monad.Trans.Reader> :kind ReaderT Int $ ReaderT Int $ IO --- ReaderT Int $ ReaderT Int $ IO :: * -> *
14:24:20 <eacameron> glguy: Cool. Yah that's what I did. But I seems like it should be in standard...
14:24:47 <younder> EvanR,  with a bitvector I can fit 64 boolean values in a single 64 bit word. (It is used for graph encodig in fes. optimizing compilers)
14:25:33 <mmaruseacph2> I always get confused reading code with at least one of {PolyKinds, TypeOperators, DataKinds}
14:25:42 <mmaruseacph2> maybe I just need to practice more
14:26:04 <monochrom> I survived DataKinds :)
14:26:44 <mmaruseacph2> younder: no one denies that using bitvectors is better for memory layout, but some applications just don't need that level of lexical complexity required to manipulate the bitvectors
14:26:47 <EvanR> younder: so the savings are 1/2 (64x) from the use of a Word64, and 1/2 (another 64x) from unboxing and getting rid of the 64bit pointer to each one
14:27:07 <EvanR> so thats a savings of 4096x!
14:27:32 <glguy> I don't think that's how savings works
14:27:42 <EvanR> dont think, call now
14:27:51 <acowley> I'll take two
14:27:58 <monochrom> I think EvanR is creating a joke.
14:28:02 <c_wraith> it's like compound interest for RAM
14:29:15 <monochrom> I'm going to out-bid you by using LZW to fit 64 bits into 48 bits.
14:29:23 <ph88> wow the bitvector package looks really good !
14:31:01 <PhatMac> bit wars!
14:31:03 <EvanR> that would be good because then you can 16 trits
14:32:17 <mmaruseacph2> pack everything into qubits
14:33:46 <monochrom> qubits are hard to debug
14:34:24 <Tuplanolla> Do we have a joke package where all the bits are packed into a single `Integer` and if not, why does it have to be so?
14:34:59 <monochrom> haskell debugging (in the gdb sense) is merely difficult and unfinished. qubit debugging (again in the gdb sense) is physically impossible
14:35:33 <mmaruseacph2> Jeff Dean is able to debug qubits (one of those Jeff Dean things, like the Chuck Norris ones)
14:35:44 <monochrom> heh
14:36:38 <mmaruseacph2> finally, my benchmark finished
14:36:42 <mmaruseacph2> 4 hours of runtime :o
14:37:22 <c_wraith> was it fast? :) 
14:37:24 <monochrom> that is some extreme benchmark
14:37:41 <mmaruseacph2> this is just preliminary work
14:37:46 <monochrom> only organic chemistry rivals that kind of time scale
14:37:48 <mmaruseacph2> but I guess I went too far with the db size
14:38:18 * hackagebot hledger-ui 1.0.2 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-1.0.2 (SimonMichael)
15:01:07 <younder> I am a little confused about the relation between cabal and stack. I read the cite doc, but is stack just easier to use to setup projects or does it add features to make it easier to port?
15:02:44 <nitrix> younder: cabal-install uses hackage. stack uses stackage.
15:03:36 <nitrix> younder: stackage is a repository for packages that's versioned under major release number snapshots. Their goal is to try to provide long term versions of packages that are known to work well together.
15:03:55 <mmaruseacph2> stack allows you to have a project consisting of multiple hackage packages (that you develop) and build them at once
15:04:15 <mmaruseacph2> also, it used to be the only tool not rebuilding the same package for each sandbox/snapshot
15:04:25 <mmaruseacph2> but now afaik cabal doesn't rebuild too
15:05:34 <nitrix> younder: stack also supports multiple different compiler versions per project nicely, the isolation is clean, the sandbox is created automatically for you; it's overall very nice to use.
15:10:00 <mgsloan> Also it can use hackage, it just tends to be that stackage snapshots are sufficient for most people's uses.
15:13:34 <younder> mgsloan, Would that be under the third-party section in the .yaml?
15:14:03 <mmaruseacph2> under extra-deps
15:15:31 <thoughtpolice> One thing that caught me off guard with Stack recently is that extra-deps are put in your .stack-work. I found this annoying when it turns out I did 'stack init' and it resolved almost all of my deps to Hackage, then I 'git clean'd. A bit of an annoying rebuild.
15:16:38 <thoughtpolice> Now that Cabal/GHC have enough support for it, it'd be nice if Stack could use some kind of global build cache and "Do The Right Thing" in those cases, the way new-build does. Although new-build doesn't get away scott free here, either (there are cases where it does local builds, and doesn't put them in the global cache)
15:17:05 <thoughtpolice> mgsloan: Does this sound viable/worth-a-bug-report?
15:17:17 <nitrix> I think point, I almost want to blame the person using `git clean`.
15:17:23 <nitrix> It does what it says on the thin.
15:17:32 <nitrix> *at this point
15:17:35 <thoughtpolice> new-build handles this case perfectly fine.
15:17:46 <thoughtpolice> So no, I don't buy that at all.
15:17:49 <monochrom> scott-free is more advanced than church-free (joke)
15:18:35 <nitrix> No idea what new-build or scott ares.
15:18:54 <mmaruseacph2> new-build is the new cabal build system
15:18:58 <thoughtpolice> Now, if you have a local dep on the filesystem, it's very sensible to put the build artifacts in .stack-work (because e.g. you may have foo-1.2.3 with special patches, so it's sensible to keep that out of the global cache). But if it's a dep that Stack resolved from Hackage, it should be quite possible to globally cache that build.
15:19:09 <Welkin> what
15:19:13 <Welkin> new cabal?
15:19:14 <mmaruseacph2> which doesn't require the same package being rebuilt multile times when it is used in multiple sandboxes
15:19:26 <mmaruseacph2> new build system of cabal's
15:19:30 <Welkin> just use nix
15:19:31 <mmaruseacph2> cabal's new built system
15:19:32 <nitrix> Your issue seems to be with a misuse of git. `git clean`, if the folder was properly ignored with .gitignore, should not touch that folder.
15:19:37 <thoughtpolice> Welkin: No.
15:19:38 <Welkin> no need for cabal sandboxes
15:19:47 <Koterpillar> nitrix: git clean has an option to clean that too
15:19:48 <thoughtpolice> nitrix: OK, I'll agree to disagree, whatever.
15:19:58 <mmaruseacph2> scrott free I think is just an expression
15:20:00 <nitrix> Koterpillar: Yes, but it's not enabled by default.
15:20:00 <mmaruseacph2> *scott free
15:20:13 <nitrix> Koterpillar: `git clean` on its own should do the right thing, as expected by thoughtpolice.
15:20:23 <nitrix> Had he configured a .gitignore file.
15:20:46 <thoughtpolice> I regularly use 'git clean' and 'git clean -xfd'. Neither of these address the point I was making at all. It's a red herring. It would be the exact same problem if I did 'rm -rf .stack-work'.
15:20:51 <Tuplanolla> Scot-free, mmaruseacph2.
15:21:06 <mmaruseacph2> that one
15:21:34 <nitrix> thoughtpolice: Of course rm -rf .stack-work, wherever that folder is located, is going to force you to rebuild everything.
15:21:53 <nitrix> thoughtpolice: The problem isn't the rebuilding or the location, it's you deleting .stack-work.
15:22:26 <thoughtpolice> Again, agree to disagree. I find it quite amazing that it's so hard to understand the basic complaint about my point, but I guarantee you I still see it as a problem. A minor one.
15:22:41 <mmaruseacph2> deleting .stack-work would still cause a rebuild of your package
15:23:14 <nitrix> thoughtpolice: I think you just caugh off by surprise by a git misusage.
15:23:17 <thoughtpolice> That's OK. I'm fine with that. What I don't want it is also rebuilding the 8+ other things the resolver picked from Hackage, when there's no reason to and the exact versions are fixed.
15:23:19 <mmaruseacph2> on the other hand, copying extra-deps to a common place, outisde project might return us back to the days of dependency hells
15:23:23 <thoughtpolice> nitrix: No, I'm not. You can drop it. Thanks for playing.
15:23:38 <eacameron> Question: If you define type f $ a = f a in a module...how do you export it?
15:23:41 <codedmart> Does anyone have a good example of StateT and ReaderT being used together. I would like to glance at it as a reference.
15:23:46 <nitrix> thoughtpolice: Assuming the .stack-work is located elsewhere, how does it prevents you for rm -rf - ing it ?
15:23:57 <nitrix> It's not the root of the problem.
15:24:01 <mmaruseacph2> when package A that you specify on extra-deps with one version is not the good version for another package you specify in another extra-deps from another problem
15:25:23 <thoughtpolice> I'm going to assume you don't understand my point, so I'll reiterate it. Stack picks extra-deps from hackage, say foo-1.2.3. I do 'stack build'. It builds foo-1.2.3, then my package. I remove .stack-work. Now it rebuilds foo-1.2.3, because the build was cached there. There's no reason to do this anymore, because the exact version and its dependencies are
15:25:23 <thoughtpolice> fixed. Stack can use the same strategy cabal new-build does, which is reminiscient of the model Nix uses to pick dependencies, while avoiding rebuilds.
15:25:42 <ggVGx> why do I need UndeciableInstances here? https://gist.github.com/621cb83ec4f33a6cbddbdb27113bdfa7
15:26:38 <geekosaur> the context does not play a part in instance selection
15:26:43 <nitrix> thoughtpolice: Having it cached there or elsewhere makes no difference as you're not supposed to be touching that folder. If it got erased by your `git clean`, it's because of a git accident of yours with the .gitignore file.
15:26:50 <thoughtpolice> This way, foo-1.2.3 from hackage never needs to be rebuilt. If the solver, due to a change in Stackage snapshot, detects a change, then it can rebuild it. Just the same way new-build would. My point is that GHC/Cabal-the-library allow a more flexible model here, where deps are identified with their hash.
15:26:50 <thoughtpolice> It would be nice if Stack had some of this functionality, to avoid rebuilds EVEN MORE OFTEN than it already does.
15:27:10 <nitrix> Deleting the cache, anywhere it might be located, is going to have the same effect. new-build or not. 
15:27:14 <daey> is String == [Char] ?
15:27:31 <nitrix> daey: type String = [Char]
15:27:35 <Koterpillar> nitrix: thoughtpolice: I think a more pointed example would be _sharing_ foo-1.2.3 between two projects with the same dependencies
15:27:38 <daey> ty
15:27:52 <Koterpillar> nitrix: thoughtpolice: the issue isn't that the cache is deleted, it's that it is not shared
15:28:09 <ph88> in monads i can do   (first, second) <-  is this also possible to do for pure functions in a where or let clause ?
15:28:11 <nitrix> Koterpillar: I agree. I'd much rather discuss this than the non-problem thoughtpolice has.
15:28:14 <thoughtpolice> Yes, that's basically the easiest way to put it.
15:28:23 <Koterpillar> ph88: yes
15:28:26 <EvanR> ggVGx: for a given Runner (MultiRunner r) (Int, a), it doesnt know what a to pick given MultiRunner R
15:28:31 <thoughtpolice> nitrix: *Sigh*, you can drop the insistence on being right-at-all-costs
15:28:42 <mmaruseacph2> ph88: yes, you can let (a, b) = f x in (b, a)
15:28:43 <thoughtpolice> Nobody cares, least of all me.
15:28:50 <ph88> oki
15:29:12 <nitrix> thoughtpolice: Can you please come to #haskell-ops?
15:29:18 <ggVGx> EvanR: right, so what are my options here?
15:29:24 <thoughtpolice> nitrix: No.
15:29:42 <ggVGx> EvanR: also, am I in this situation because of misusing type classes? And if so, what would be more reasonable?
15:29:46 <EvanR> probably
15:30:04 <EvanR> what are you trying to do, object oriented programming where each thing has a state type?
15:30:21 <eacameron> For what it's worth thoughtpolice is right. You can't safely share packages between projects that don't necessarily have the same resolver. Stack puts extra deps in the local .stack-work for a reason...so they aren't shared.
15:30:21 <EvanR> did the record-with-hidden-state-in-the-constructor-closure not work out somehow
15:30:45 <eacameron> But hopefully that will change with cabal new-build. :D
15:31:33 <Rumia> I think I have asked this before, but is there such a thing as CoApplicative? And if not, why not?
15:31:38 <thoughtpolice> eacameron: FWIW, new-build is more part of cabal-install. But the basic support is all in GHC/Cabal itself, maybe a bit low level. cabal-install is a library now though, so splitting off some of new-build (once it's complete) into its own library may be worth it for doing so.
15:32:30 <eacameron> thoughtpolice: Ah neat. Yah it would be great if stack didn't have to hack together the package sharing thing that it has now. resolvers could just be different views of the same GHC pkg db.
15:32:44 <nitrix> thoughtpolice: We need a discussion and it cannot happen here.
15:32:45 <ggVGx> EvanR: I am still doing my sequencer thing.. The idea is to have a framework of "Runners" that I can combine to build up the structure I want, currently forming the structire of a "Track". I'll paste my current usage if you want
15:33:20 <ggVGx> EvanR: https://gist.github.com/32e7105c024cf7a205dbc3ee155e01c6 | https://gist.github.com/1966ce6b3a65fc8565aaed15995c264a | https://gist.github.com/d87f4840a68b1d4438a5fab9ae1ddef7 | https://gist.github.com/8b44f9048331e9fb4db568db32d16667
15:33:48 <ggVGx> EvanR: those are the four main parts, the first paste being the Track module, which is the module using the runners to build up the concrete thing I want to use
15:33:56 <EvanR> combining things is cool, so you potentially have the opportunity to come up with some algebraic language to talk about combining runners
15:34:01 <thoughtpolice> eacameron: They could share the same cache but maybe that's not the best idea, it could end up weird?
15:34:12 <ggVGx> EvanR: I was passing dictionaries with functions for each runner before, but I realised that's basically just doing type classes by hand
15:34:13 <EvanR> but then you probably want to dynamically replace them at runtime too
15:34:31 <ggVGx> I'm not at all where I want to be yet, but this is the best I got so far
15:34:32 <EvanR> its the other way around
15:34:50 <eacameron> thoughtpolice: I may misunderstand what you mean by that, but I think that's basically what stack does right now. But it still needs to build separate GHC pkg dbs for every resolver.
15:34:51 <EvanR> type classes is just passing dictionaries of functions around, only less functionally
15:34:52 <thoughtpolice> nitrix: No. My discussion with you is over -- move on.
15:34:58 <ggVGx> it works currently, but I seem to be using more advanced techniques than I should be, and it feels too rigid still
15:35:01 <EvanR> since dictionaries arent first class
15:35:17 <thoughtpolice> eacameron: Oh, I meant ordinary cabal-install and stack sharing the same one. In terms of like, just stack, yeah every resolver could always just use one big cache
15:35:18 <EvanR> ggVGx: yeah, the records were not as reigid
15:35:19 <EvanR> rigid
15:35:24 <ggVGx> yeah, but I had some issues with the records of functions which were solved when I made a type class
15:35:25 <EvanR> your st parameter doesnt need to exist
15:35:29 <thoughtpolice> And could even put all extra-deps in that cache, too.
15:35:34 <EvanR> like what issues
15:35:35 <ggVGx> Hm, why not?
15:35:49 <EvanR> with the records, your st is hidden from the outside world
15:36:01 <ggVGx> I can't remember atm. But something made me want to use a type class instead. I was probably wrong
15:36:10 <EvanR> heh
15:36:31 <ggVGx> oh, I was doing the objects with hidden st before, and that wasn't working the way I wanted to either, because I couldn't serialise the tree easily
15:36:33 <ggVGx> which I can now
15:36:42 <EvanR> you can serialize
15:36:51 <EvanR> we discussed that :D
15:36:54 <ggVGx> well, now I just derive Generic and Binary
15:36:56 <eacameron> thoughtpolice: I think it does not do that because you can override build flags, etc. in extra-deps which are apparently not being properly tracked.
15:37:10 <EvanR> ... well you can still use generic and binary
15:37:27 <thoughtpolice> eacameron: Yeah, so new-build even tracks flag choices too, so that's all totally doable since it's actually part of the logic of the solver.
15:37:37 <ggVGx> EvanR: I also have lenses into the Track tree. How would I do that with a hidden st?
15:37:52 <thoughtpolice> Flag choice obviously affects install plan, which in turn changes the overall calculated "build hash", etc.
15:38:10 <EvanR> ggVGx: i cant say without knowing what the track tree is
15:38:36 <ggVGx> EvanR: basically, the combination of "Runners" builds the "evaluation model" of something sequenced at various levels. But the data of this model needs to be editable at any point
15:38:38 <ggVGx> which it is now
15:38:40 <eacameron> thoughtpolice: Cool. Yeah my guess is that stack sort of took a short-cut that allows some level of sharing between well-known package sets (lts & nightly) but for arbitrary configurations it really needs all the work of cabal new build.
15:38:48 <ggVGx> EvanR: the track tree is that DriverRunner in the first paste
15:39:26 <EvanR> when you have a bunch of heterogenous objects, the only way it makes sense to talk about "all of them" is through a common interface
15:39:29 <ggVGx> What I mean is this, https://gist.github.com/2bb5b2e64aa8ab27e4d9e49effee7abe
15:39:39 <thoughtpolice> eacameron: I believe stack already can do some forms of what new-build had, e.g. it does take flags into account I believe, but yeah this would let it avoid rebuilds in even more cases like extra-deps. I'm not sure if it's worth it if it only fixes extra-deps, but it could maybe make other things easier too.
15:39:43 <EvanR> and the tricky part is coming up with that common interface
15:39:46 <ggVGx> that's the tree of combined runners
15:39:55 <EvanR> but the escape route is you dont need 1 common interface, you can have more than 1
15:40:27 <eacameron> thoughtpolice: do you know if the stack team plans to simplify the sharing mechanism to just use cabal new-build for GHC-8 and on?
15:40:44 <eacameron> In that case I can totally see extra-deps getting included in the cache
15:40:56 <ggVGx> EvanR: the only common interface I need is how to "execute" runners, which I have now defined as the type class Runner
15:41:05 <EvanR> and whats the type of execute
15:41:15 <ggVGx> but it feels like the type class is bringing me too much externsions etc. so it feels like I'm out of line
15:41:28 <EvanR> whatever you did with type classes, you can do without them
15:41:36 <thoughtpolice> eacameron: No I have no clue, I was hoping maybe mgsloan would have an idea if it was interesting to them. Like I said, the GHC/Cabal support is somewhat low level the way Cabal uses it IIRC, so it may not be very nice to build on at the moment, and new-build is still WIP
15:42:06 <ggVGx> EvanR: so, my only way to get out of this UndecidableInstances situation is to not use type classes here?
15:42:19 <thoughtpolice> And if it only fixes a few edge cases, those may be easier to just fix directly. new-build is essentially a total rewrite so reusing it in Stack would surely be a large change in general; obviously not every improvement is always worth its weight.
15:42:25 <EvanR> i dont believe that your only common interface is how to use runners
15:42:28 <EvanR> er, execute
15:42:44 <EvanR> you have this type classes here which is causing problems
15:42:47 <eacameron> thoughtpolice: I see. Well I'm sure it will come eventually...but they do still have to support resolvers that don't have access to new-build so it would need to keep the old logic around almost indefinitely.
15:43:10 <thoughtpolice> Then again, a big part of new-build is the new UI. If it's only package database magic nonsense, that might be a pretty small part of the story.
15:43:35 <eacameron> thoughtpolice: And with new build...the competition gets a bit hotter. :P
15:44:07 <ggVGx> EvanR: when you say "common", what are you referring to? I mean "common" as in "what runners need to know about eachother". For outside usage I need to have the flexibility of accessing each runners state directly. E.g each of them needs to also have their own interface that's accessible
15:44:12 <ggVGx> which is the case now
15:44:21 <ggVGx> and that interface is currently implemented as lenses into their data
15:44:26 <EvanR> each other? no
15:44:44 <EvanR> yes im talking about "outside"
15:44:55 <thoughtpolice> eacameron: It's still missing plenty but it works pretty well so far. I'm also a really big fan of how fast the no-op build is, and it turns out that feature is really important to me.
15:45:07 <EvanR> which is what i think your class is talking about
15:45:28 <ggVGx> EvanR: but I don't think that generalisation exists
15:45:35 <ggVGx> I tried finding it
15:45:38 <thoughtpolice> eacameron: My Shake build system has a stack.yaml, but only so my editor can do some fancy stuff. The actual build is done with new-build, because I wrap the Haskell executable in a shell script, and the shell script compiles the build system, on-demand with new-build.
15:45:43 <EvanR> maybe thats why the type class isnt type checking xD
15:45:50 <eacameron> thoughtpolice: I believe it...especially when you have an init script that rebuilds on every invocation.
15:45:58 <eacameron> thoughtpolice: Hah...that's exactly the case I was imagining.
15:46:01 <thoughtpolice> eacameron: So having an extremely fast no-op build is very important, it's less than 1/10th of a second, especially in this case.
15:46:07 <eacameron> thoughtpolice: I did the same thing but with stack once...it was slow.
15:46:13 <EvanR> ggVGx: "how to fix undecidable instances" seems like a big XY problem here
15:46:21 <ggVGx> yeah, fair
15:46:35 <thoughtpolice> Yes, this is also how Hadrian (new GHC build system) works, and new-build is recommended for that. It'd be nice to make 'stack build' a no-op too.
15:46:45 <thoughtpolice> I've already saved probably hundreds of seconds! Hundreds.
15:46:48 <ggVGx> I wish I could clearly express what I'm after so someone could swoop in and tell me the easy path to it
15:46:57 <eacameron> thoughtpolice: Hundreds of seconds folks!
15:47:13 <eacameron> thoughtpolice: And for what you charge per hour...I imagine that's an amazing deal.
15:47:14 <EvanR> ggVGx: yes, earlier i was like, type synonyms with cool names aside, where is ggVGx's diagram for how he things this application is supposed to work
15:47:43 <Welkin> ggVGx: does your uml diagram commute?
15:48:15 <EvanR> ggVGx: ive gotten pretty far stepping back and taking account of the actual final operations necessary for each piece
15:48:38 <EvanR> then realizing they are special cases of something and can be uniformized with partial functions
15:48:40 <eacameron> thoughtpolice: ;)
15:48:42 <thoughtpolice> eacameron: It's offset by the fact you have to type /the/full/path/to/the/executable/in/a/deep/directory, because 'cabal new-run' doesn't exist yet. :)
15:48:46 <EvanR> er, partially applied functions
15:49:10 <eacameron> thoughtpolice: You win some you lose some. At least typing is more fun.
15:49:27 <ggVGx> EvanR: the backstory is that initially I just built a naive concrete version of everything, since I knew I couldn't find the generalisation I thought I wanted. Then I got to a working prototype, but during development I noticed multiple times I was essentially reimplementing slightly different versions of very similar ideas. Like, a note sequencer turns notes off and on, and a track turns note sequences on and off.
15:49:35 <mmaruseacph2> I sometimes use ghc-options: -o name_of_exec and that makes the exec be generated in local dir
15:49:40 <ggVGx> So I've been trying to build a framework where I can just combine these building blocks
15:49:51 <mmaruseacph2> so no need to type /the/full/path/to/it
15:49:54 <ggVGx> but it turned out harder than I imagined
15:50:13 <EvanR> yeah language for building cool things from parts, but then you want it dynamically reconfigurable
15:50:49 <EvanR> at that point you might have to settle for less type safety
15:50:55 <EvanR> like, more sum types
15:51:08 <mmaruseacph2> that, if you don't mind seeing a "Warning: 'ghc-options: -o' is not needed. The output files are named automatically" warning each time you do a build
15:51:15 <ggVGx> I'm not sure it needs to be dynamically reconfigurable
15:51:21 <ggVGx> at least that wasn't an initial goal
15:51:22 <EvanR> at runtime?
15:51:27 <ggVGx> yeah, I don't need that
15:51:35 <EvanR> oh youre talking about the internal guts now
15:51:55 <EvanR> refactoring
15:51:58 <ggVGx> right
15:52:27 <EvanR> i see now why you might want to try type classes
15:52:38 <EvanR> luckily you can git revert ;)
15:54:41 <ggVGx> EvanR: well, but, it does work with UndecidableInstances enabled, which tells me there should be a way to do my types so that it works without it
15:55:19 <ph88> is it possible to define a data type in the scope of a function ?
15:55:33 <Welkin> no
15:56:47 <mmaruseacph2> you can make a new module which contains that function and the data type and only export the function
15:56:47 <ertes> that's: no =(
15:56:52 <mmaruseacph2> ^ as a workaround
15:57:42 <ph88> ah right ^^
15:57:55 <ertes> ph88: you could also just define the type and not export it
15:58:22 * hackagebot hledger-diff 0.2.0.6 - Compares the transactions in two ledger files.  https://hackage.haskell.org/package/hledger-diff-0.2.0.6 (gebner)
15:58:30 <DrEntropy> Does anyone else use haskell and python and keep trying to quit python using :q ?  :)
15:58:47 <Welkin> I try to quit everything using :q
15:58:51 <ertes> DrEntropy: i'd quit both by ^D
15:58:56 <Welkin> I started using Ctrl + D
15:59:01 <Welkin> because of lua
15:59:02 <DrEntropy> Ah good idea 
15:59:06 <ertes> because of…  everything
15:59:40 <ertes> gp, maxima, shells, your favourite REPL, …
15:59:42 <DrEntropy> Cool, I didn't post that to learn anything, but i did :) #haskell is awesome :)
15:59:53 <DrEntropy> :q   (j/k :)
15:59:53 <ph88> i made this small algorithm but i get an error about ceiling i don't know why  https://paste.fedoraproject.org/462090/60914514/
16:00:44 <ertes> ph88: ceiling only works on fractional types
16:01:02 <ph88> i thought since i use div it would become fractional
16:01:23 <ertes> ph88: nope, 'div' is integer division
16:01:45 <ph88> i wanted a division so that 5 / 2 = 2.5
16:01:53 <ertes> ph88: then you wanted (/)
16:02:10 <ph88> No instance for (Fractional Int) arising from a use of ‘/’
16:02:13 <ph88> i tried that
16:02:20 <ph88> that error led me to belief i should use div instead :/
16:02:33 <ertes> because 'len' is an Int, but you can convert it to the desired type by using fromIntegral
16:02:37 <ph88> maybe if i put a type signature on 2 ?
16:02:41 <ph88> alright
16:02:49 <ertes> > fromIntegral (5 :: Int) / 2
16:02:51 <lambdabot>  2.5
16:03:00 <Welkin> > "habari"
16:03:02 <lambdabot>  "habari"
16:03:31 <Welkin> that is the one things that is annoying when using haskell
16:03:34 <Welkin> even still
16:03:56 <Welkin> last night I spent a lot of time converting between String and Text and lazy ByteStrings and strict ByteStrings
16:04:25 <Welkin> I should probably have used classy-prelude for that
16:04:27 <ertes> the former is a problem (String should go away), but the latter isn't
16:04:30 <Welkin> or, mono-traversable
16:05:11 <dmj`> @package string-conversions
16:05:12 <lambdabot> http://hackage.haskell.org/package/string-conversions
16:05:14 <codedmart> Can you have a `ReaderT (MVar [Int]) IO`? As in when `modifyMVar` happens does that work?
16:05:15 <dmj`> ^ Welkin
16:05:45 <dmj`> codedmart: sure why not, you'll have to liftIO of course
16:06:16 <codedmart> dmj`: I guess I was thinking it was fine, but was questioning it still.
16:06:21 <codedmart> Thanks!
16:06:38 <ertes> codedmart: i'd question it, too
16:06:44 <ertes> not its possibility, but its utility
16:06:59 <dmj`> codedmart: I won't ask 'why' you'd want :] 
16:07:02 <dmj`> that*
16:07:44 <codedmart> Well I am probably being dumb.
16:07:53 <codedmart> I am playing with websockets.
16:08:32 <dmj`> codedmart: you're not dumb, a lot of people don't even know what a websocket is
16:08:57 <codedmart> And each time a new person connects I create a Client and add it to my WebsocketState which is [Client]. I am using MVar WebsocketState.
16:09:01 <ertes> i hope that will never become the threshold =)
16:09:23 <dmj`> ertes: :]
16:09:30 <codedmart> But don't I need that `MVar WebsocketState` anytime I need to modify it?
16:10:09 <codedmart> dmj`: Am I thinking about this wrong?
16:10:11 <Koterpillar> yes, but you just have to ask
16:10:21 <ertes> codedmart: you do, so you'd depend on that MVar, in other words: you write functions of that MVar
16:10:39 <coleman> Can someone explain the difference between cabal and stack?
16:10:40 <ertes> codedmart: "you do" as in: you do need the MVar
16:10:46 <coleman> Advtanges/disadvantages?
16:10:51 <codedmart> ertes: As in I don't need Reader?
16:11:16 <codedmart> Still new to MVar.
16:11:21 <ertes> coleman: currently cabal-install is a command line interface to cabal and a semi-package manager similar to what other languages have…  stack is a full deployment solution
16:11:42 <ertes> codedmart: Reader(T) is just functions with implicitly passed arguments
16:11:52 <coleman> ertes: so stack uses cabal as a dep manager?
16:12:19 <ertes> coleman: i doubt that it uses cabal-install…  more likely it uses the cabal library
16:12:24 <Koterpillar> coleman: yes, but cabal is a library, cabal the tool is properly called cabal-install
16:13:16 <ertes> coleman: if you're using linux, you should probably just use cabal-install…  you will know when you need something like stack
16:13:16 <dmj`> codedmart: MVar fiddling is trickly, I'd wrap MVar operations into a haskell data type, and expose it like an API, using a closure
16:13:28 <codedmart> ertes: OK is this a dumb idea to do it like this? https://gist.github.com/codedmart/8fdb8b901fa58f16955436b13e711975
16:13:48 <codedmart> dmj`: Do you have an example I can glance at. If not no worries.
16:13:48 <coleman> what's the difference between cabal repl and ghci?
16:14:10 <ertes> codedmart: i'd dispense with the WebsocketState type and use [Client] directly
16:14:30 <geekosaur> cabal repl ensures that the sandbox is available to ghci, builds things as necessary so they will be available, and may preload modules for you
16:14:30 <Koterpillar> coleman: cabal repl runs ghci with your packages
16:14:31 <codedmart> ertes: OK but the idea? 
16:14:37 <coleman> Koterpillar: awesome
16:14:39 <coleman> thanks
16:14:41 <codedmart> Is that considered ok to do?
16:14:51 <ertes> codedmart: i'm not sure what the idea is…  so far you have just defined a type =)
16:15:21 <codedmart> I just mean having MVar [Client] inside each Client?
16:15:49 <ertes> codedmart: can't tell, because i don't know what you're using that MVar for
16:16:04 <ertes> and "mState" isn't really a helpful name =)
16:16:07 <coleman> Koterpillar: can I make cabal automatically add dependencies to the .cabal file?
16:16:09 <dmj`> codedmart: yea, one sec
16:16:43 <Koterpillar> coleman: no, I don't think so; stack can do a similar thing but not quite; what's your use case?
16:16:51 <coleman> Koterpillar: convenience
16:17:16 <coleman> Koterpillar: I ran `cabal install primes` but when I do `import Data.Numbers.Primes` it says I need to add it to my .cabal file
16:17:17 <codedmart> ertes: This is my basic trial so far. https://gist.github.com/codedmart/8b2fe6375fa4ad88604a07d2c0cef54b
16:17:45 <ertes> coleman: if your workflow includes GHCi, you can probably write a short script that uses 'ghc-pkg' to generate the dependencies, but i wouldn't bother
16:17:51 <Koterpillar> coleman: you don't have to run cabal install, it'll figure it out
16:17:55 <coleman> ertes: okay, thanks
16:18:11 <Koterpillar> coleman: cabal/stack repl, that is
16:18:12 <dmj`> codedmart: you still here?
16:18:17 <codedmart> Yup
16:18:23 <dmj`> http://lpaste.net/309011
16:18:30 <dmj`> so we have this 'Box' 
16:18:37 <dmj`> you can think of it as holding your websocket connections
16:18:44 <dmj`> but for now it's just a Box of Things (Strings)
16:18:45 <coleman> Koterpillar: I don't think I'll dive into stack yet.
16:19:01 <coleman> Koterpillar: I'm still working through euler problems and such
16:19:09 <ertes> codedmart: you have an insane amount of indirection there, like this one:  newWebsocketState = []
16:19:12 <dmj`> codedmart: an MVar is created and the reference to it exists inside the closure
16:19:21 <dmj`> so it doesn't get GC'd
16:19:26 <codedmart> ertes: Hey I didn't say it was good :)
16:19:47 <dmj`> codedmart: you bring the functions into scope /and/ using RecordWildCards
16:20:03 <dmj`> which makes them look like nice IO functions of some API
16:20:19 <dmj`> modifyMVar_ will take a put quickly, so no deadlocks, and read should be non blocking
16:20:46 <ertes> codedmart: and i'm not saying it's bad…  i'm giving suggestions to make the code more concise and readable =)
16:21:13 <dmj`> codedmart: voila
16:21:19 <codedmart> Oh yeah I forgot to remove that from your suggestion of removing WebsocketState.
16:21:34 <ertes> coleman: stack is optional…  you will never *need* it (i've never used it myself)
16:21:37 <codedmart> dmj`: So you can have deleteThings as well, etc, etc
16:21:49 <codedmart> dmj`: I like that thanks! I am going to give that a try.
16:23:02 <dmj`> yes
16:23:04 <dmj`> it's snazzy
16:23:13 <dmj`> mvar recipes
16:23:32 <dmj`> cooking with concurrency
16:28:27 <EvanR> hrm im looking for laws that a MonadState must follow
16:29:05 <johnw> how can I change the mode of a file handle from ReadWrite to just Write?
16:30:46 <ertes> EvanR: something like (modify (f . g) = modify f << modify g)?
16:31:25 <ertes> get >> c = c;  put x >> put y = put y
16:33:03 <monochrom> johnw: I have a feeling it can't be done.
16:33:20 <coleman> I'm using haskell-mode and, since I switched the process type from `stack repl` to `cabal repl` I get: "variable not in scope: main" even though I do have a main definition
16:33:34 <johnw> monochrom: I'm starting to get that same feeling
16:33:37 <coleman> runhaskell myfile.hs works just fine
16:33:46 <johnw> just found optimizeForBatch, though, so not a total loss :)
16:34:14 <EvanR> ertes: good one
16:34:36 <ertes> coleman: you need to call the module Main
16:35:07 <ertes> EvanR: also make sure that get, modify, put interact
16:35:35 <ertes> get >>= put = pure ();  modify f = get >>= put . f;  …
16:36:14 <ertes> EvanR: you can probably define all those laws in terms of 'state', and then just make sure that 'get', 'modify', 'put' are defined in terms of that one
16:36:16 <EvanR> well im breaking that one ;)
16:36:36 <coleman> ertes: I'm in an interactive repl though. Shouldn't I be able to run any defined method?
16:36:37 <EvanR> but for posterity what would the laws be using state ?
16:36:58 <ertes> coleman: if you loaded it into GHCi, then yeah
16:38:04 <coleman> ertes: must be a problem with my haskell-mode config
16:41:39 <monochrom> coleman: I'm wondering if you need to do an explicit C-c C-l of the file that has your main.
16:42:33 <xcmw> Do type level functions exist in haskell? Something like \type -> String or \type -> Maybe type or \type -> (String -> type)
16:43:02 <monochrom> I know that if your process type is just "ghci", you have to. (I always do.) And I bet 70% chance that "cabal repl" is still yes.
16:43:55 <monochrom> a weak form of type-level function is type families.
16:44:35 <monochrom> However, your 3 examples can be done more elementarily.
16:44:59 <monochrom> (\type -> String) can be done with "type X t = String"
16:45:09 <monochrom> (\type -> Maybe type) is simply "Maybe"
16:45:23 <monochrom> (\type -> String -> type) is "(->) String"
16:46:00 <monochrom> actually "type X t = String" doesn't do a lot
16:46:29 <Rumia> Why?
16:46:51 <monochrom> instead if you tolerate a data constructor, "newtype C t = MkC String" goes a long way.
16:47:12 <monochrom> Because you cannot then write "instance Monad X" for example.
16:47:45 <monochrom> actually that is not a good example of what you can't do, since you never think of doing that anyway.
16:47:58 <Rumia> Well not Monad.
16:48:25 <monochrom> but the idea is that you can't say "X" alone. You have to provide a parameter.
16:48:26 <johnw> it wouldn't be a monad anyway
16:48:34 <johnw> since your C is just Const String
16:50:55 <xcmw> Maybe and (->) String work, but just string fails
16:51:26 <xcmw> Type synonym ‘X’ should have 1 argument, but has been given none
16:51:36 <johnw> xcmw: Const String is takes any type to something that represents a String
16:51:44 <johnw> as does monochrom's C wrapper
16:51:59 <monochrom> that is why X is not very useful
16:55:08 <xcmw> I see. Would type families allow me to get rid of MkC?
16:57:27 <xcmw> johnw: What is Const? Where is it? I get Not in scope: type constructor or class ‘Const’
16:57:37 <johnw> I believe it's in Control.Applicative
16:57:54 <johnw> newtype Const a b = Const { getConst :: a }
16:58:03 <monochrom> also Data.Functor.Const
16:58:42 <johnw> it's one of those types that's Applicative if a is a Monoid, but that is never a Monad
16:59:15 <xcmw> It works now. Thanks.
17:04:52 <nshepperd> Const could be a monad couldn't it? the instance would just be weird and conflict with Applicative
17:05:16 <johnw> nshepperd: no, it cannot be; 4 of the laws pass, but the 5th is not possible
17:06:40 <nshepperd> oh, return a >>= f = f a, of course
17:08:19 <nshepperd> the best monad is data Unit a = Unit
17:09:49 <Welkin> I thought it was IO
17:11:40 <monochrom> that is the ultimate monad
17:11:54 <Myrl-saki> Identity?
17:12:34 <Myrl-saki> nshepperd: Errr
17:12:43 <Myrl-saki> Hmmm
17:13:15 <Welkin> you might be able to visit Io one day
17:13:18 <Welkin> some day
17:13:56 <nshepperd> 'monads are like rocky moons'
17:14:07 <Myrl-saki> nshepperd: If Const a can't be a Monad, Unit shouldn't be able to either, right?
17:14:23 <Myrl-saki> Const () <-> Unit
17:14:45 <ggVGx> I've got a record of functions for which I've defined a Monoid instance, and I believe it is a Monoid. How could I write tests for it?
17:14:55 <EvanR> thats no moon... ad
17:15:00 <ggVGx> e.g how can I prove that it actually is a monoid
17:15:09 <ggVGx> when I can't define an Eq instance for it
17:15:12 <ggVGx> since it's a record of functions
17:15:15 <nshepperd> Myrl-saki: the problem with Const is that you can't get the output of 'f a :: Const r b' if you don't have an a
17:15:25 <johnw> Myrl-saki: in that case, the 'a' is known, so it's actually possible
17:15:39 <EvanR> ggVGx: stuff can be Monoids without being Eq
17:15:39 <nshepperd> Myrl-saki: it works with Unit, because you can just use Unit :: Unit b
17:15:43 <EvanR> (in haskell)
17:15:48 <ggVGx> EvanR: yes, but how can I test it
17:15:55 <EvanR> test as in unit test?
17:15:55 <nshepperd> Myrl-saki: so actually yeah you could do instance Monad (Const ()) :D
17:15:57 <ggVGx> yes
17:16:10 <Myrl-saki> nshepperd: oh
17:16:11 <EvanR> same way you test functions/
17:16:48 <EvanR> you apply functions to stuff and see what stuff comes back
17:19:14 <xcmw> I tried using type families but still get Type family ‘QQQ’ should have 2 arguments, but has been given 1. Looks like Const is the best option.
17:27:51 <ggVGx> what's the use of the Applicative instance of Maybe?
17:28:06 * Clint squints.
17:30:02 <Tuplanolla> > (*) <$> Just 42 <*> Just 13
17:30:05 <lambdabot>  Just 546
17:30:12 <pavonia> It's quite useful sometimes if you need to get the results of several Maybe values into a new one, or fail if one value is Nothing
17:31:33 <ggVGx> ah, right.. It's useful when the Maybe contains a function
17:31:59 <ggVGx> I was thinking about things like maybeSomething <*> maybeSomethingElse <*> maybeAnotherThing
17:32:05 <ggVGx> which doesn't make sense to do
17:32:20 <Tuplanolla> The name serves as a hint.
17:32:26 <ggVGx> hah
17:32:28 <ggVGx> fair
17:32:30 <ggVGx> thanks
17:58:17 <ggVGx> could I do something like this with a list comprehension too? https://gist.github.com/1a8e105049cc3007e6d22de18d951d86
17:59:59 <monochrom> yes!
18:00:24 <ggVGx> how?
18:00:25 <monochrom> [ [x, y, z, (x*y)] | x <- [1,2,3], y <- [3,4,5], z <- [0] ]
18:00:34 <ggVGx> oh, right
18:00:40 <monochrom> err, maybe a bit off
18:00:43 <monochrom> > [ [x, y, z, (x*y)] | x <- [1,2,3], y <- [3,4,5], z <- [0] ]
18:00:46 <lambdabot>  [[1,3,0,3],[1,4,0,4],[1,5,0,5],[2,3,0,6],[2,4,0,8],[2,5,0,10],[3,3,0,9],[3,4...
18:00:50 <ggVGx> well, and concat
18:00:51 <ggVGx> I guess
18:00:59 <monochrom> OK, then it is a bit off.
18:01:08 <ggVGx> yeah, that was my conclusion also
18:01:22 <ggVGx> thanks
18:01:46 <monochrom> Oh! I see what's going on. Yeah, concat is the simplest to fix mine.
18:02:07 <monochrom> No! There is a purely comprehensional way!
18:02:17 <ggVGx> I'm curious :)
18:02:27 <monochrom> > [ t | x <- [1,2,3], y <- [3,4,5], z <- [0], t <- [x, y, z, (x*y)] ]
18:02:30 <lambdabot>  [1,3,0,3,1,4,0,4,1,5,0,5,2,3,0,6,2,4,0,8,2,5,0,10,3,3,0,9,3,4,0,12,3,5,0,15]
18:02:48 <ggVGx> aha!
18:02:52 <ggVGx> I didn't know you could do that
18:02:58 <ggVGx> thanks
18:03:31 <monochrom> monadically I'm translating [a,b,c,d] into the equivalent "t <- [a,b,c,d]; return t"
18:03:55 <ggVGx> ah yeah, right
18:03:58 <ggVGx> that makes sense
18:04:14 <monochrom> And basically you want to see the "do { whatever; return blah }" format because then it's [ blah | whatever ].
18:04:38 <ggVGx> yeah I was just playing around with the monad instance of list to get used toit
18:04:41 <ggVGx> since I never ever use it
18:12:43 <coleman> Would someone look at my solution to the euler partitioning problem?
18:12:45 <coleman> https://gist.github.com/JacksonGariety/1b74561efa8c235a17b7787e028b4245
18:13:27 <coleman> Wondering if there's anything obviously wrong with it. 008.txt has the number broken into lines. The main method just strings them into an array of Ints.
18:13:34 <coleman> list*
18:15:39 <c_wraith> coleman: why concat . lines?
18:15:56 <coleman> c_wraith: to get rid of the \n characters
18:16:08 <c_wraith> why not filter isDigit?
18:16:24 <c_wraith> It's way clearer what you mean.
18:17:08 <coleman> c_wraith: is that in a package?
18:17:18 <coleman> Variable not in scope: isDigit
18:17:24 <c_wraith> it's in base, but you'll need to import Data.Char
18:17:42 <monochrom> > concat (lines "10\n20\n")
18:17:45 <lambdabot>  "1020"
18:18:00 <monochrom> > concat (lines "102\n0\n")
18:18:03 <lambdabot>  "1020"
18:18:16 <monochrom> do you need to tell the difference between 10\n20 and 102\n0 ?
18:18:22 <coleman> monochrom: nope
18:18:28 <c_wraith> Looks like the input is just a long list of digits.
18:18:31 <coleman> monochrom: the \n are just there from copy/pasting euler.net
18:18:55 <monochrom> ok good to hear
18:19:32 <monochrom> is your program fast enough?
18:20:14 <coleman> monochrom: yeah even with the I/O it's 0.01 msecs
18:20:16 <c_wraith> All told, your program looks like the logic is right, even if it's slightly non-idiomatic.
18:20:17 <coleman> secs
18:20:26 <c_wraith> What problems are you having?
18:21:13 <coleman> c_wraith: I'd like it to be more idiomatic :-)
18:21:20 <coleman> c_wraith: I'm just learning.
18:21:53 <monochrom> I wonder if I should replace your read . (:"")
18:22:21 <monochrom> the alternative is (\x -> ord x - 48)
18:22:22 <c_wraith> yeah, just use digitToInt
18:22:33 <monochrom> oh, digitToInt is better
18:22:37 <c_wraith> Or Data.Char.digitToInt
18:23:24 <coleman> awesome
18:23:29 <coleman> that's much nicer
18:23:30 * hackagebot flat-mcmc 1.1.1 - Painless general-purpose sampling.  https://hackage.haskell.org/package/flat-mcmc-1.1.1 (JaredTobin)
18:23:49 <monochrom> lastly, I don't like brute-forcing, but I am too lazy to understand the problem to think up a good algorithm
18:23:59 <c_wraith> You could keep a sliding window
18:24:13 <c_wraith> Along with a stack of the last 13 values
18:24:25 <c_wraith> The problem is ultimately a brute force problem
18:24:32 <c_wraith> All that does is reduce the constant factors
18:24:46 <coleman> monochrom: right there's no algorithm here other than the one I have
18:25:06 <coleman> monochrom: I could optimize it only by caching the products of the subsets (12, 11, 10, 9, etc.)
18:25:16 <coleman> I'm not sure there's any other way to get the solution.
18:25:24 <c_wraith> You could improve constant factors by keeping a stack of the values currently multiplied.
18:25:41 <c_wraith> When you push a new number in and multiply, pop the old one and divide
18:25:45 <c_wraith> *oldest
18:25:56 <c_wraith> err, that's a queue, not a stack
18:25:59 <coleman> c_wraith: yeah that's a good way to do it
18:26:07 <coleman> c_wraith: but the performance really would be the same
18:26:20 <coleman> c_wraith: the number should be way longer
18:26:37 <c_wraith> I think it would improve constants, but it's not really slow anyway
18:27:24 <c_wraith> laziness is going to keep all the intermediate lists in nursery generation.  It should all go pretty fast.
18:27:56 <coleman> c_wraith: how would I go about keeping that stack do you think?
18:28:26 <coleman> c_wraith: I'm coming from scheme, so I'd probably just pass it as an argument through the recursion
18:28:52 <c_wraith> Amusingly, the best way is to just traverse the list twice in parallel
18:29:28 <coleman> c_wraith: ?
18:30:02 <c_wraith> give me a few minutes.  I don't think I can explain it better than that without writing it up
18:30:24 <coleman> c_wraith: I'm going to grab dinner. Back in 30.
18:43:57 <c_wraith> Oh.  He's really very gone until he finishes dinner.
18:46:35 <c_wraith> coleman: http://lpaste.net/309277
18:47:51 <coleman> c_wraith: wow cool
18:48:02 <coleman> c_wraith: so go is its own sub-defintiion? You call it?
18:49:18 <monochrom> a local definition. also a helper. (but sometimes you put helpers outside.)
18:50:04 <coleman> haskell is a new world for me in terms of syntax. so many constructs
18:50:11 <c_wraith> that one could have been outside, it doesn't use anything from its enclosing scope. 
18:50:22 <c_wraith> it just felt very unuseful to have standalone. 
18:51:05 <coleman> c_wraith: why call it 'go'?
18:51:15 <c_wraith> tradition
18:51:41 <c_wraith> Recursive, locally-scoped helpers are traditionally called "go" if they do the majority of the work of a function.
18:52:42 <c_wraith> coleman: I did one slightly advanced thing in there, in throwing the seq in.  But I felt like I was being irresponsible if I left it out, even if it doesn't matter in your use case.
18:52:46 <c_wraith> coleman: that seq just prevents a huge buildup of thunks if you ignore a lot of values in the list.
18:52:48 <monochrom> Haskell has many constructs not in other languages, and drops many constructs present in other languages.
18:53:11 <coleman> thanks guys
18:53:17 <coleman> learned a lot tonight
18:53:26 <coleman> esp c_wraith 
18:53:27 <monochrom> For example local procedures and functions like this were in Algol and Pascal, then dropped by C, then Haskell reinstated it.
18:53:38 <c_wraith> I've got to go for a walk now.  If you have any further questions..  well, monochrom appears to be up to answering them. :)
18:53:44 <coleman> :-)
18:54:36 <EvanR> that may merely be an illusion
18:55:32 <EvanR> i believe C now has local function definitions
18:55:43 <monochrom> And on the other hand, Haskell drops pointer arithmetic and Duff's device
18:56:18 <EvanR> at least theres a module to do pointer arithmetic. C has no functional programming library
18:59:47 <geekosaur> gcc readded local functions as an extension some years back
19:02:15 <dolio> Does the C standard actually guarantee that Duff's device works?
19:02:58 <geekosaur> yep
19:03:35 <geekosaur> not by name, but it guarantees the interleavable semantics of switch
19:07:10 <dolio> I guess the part that surprises me the most is that it's syntactically valid.
19:12:08 <tibbe> anyone have a link to a haskell definition of System F lying around?
19:12:17 <tibbe> (i.e. expressed as Haskell data types)
19:40:07 <dolio> tibbe: Do you mean an implementation of System F in Haskell?
19:40:19 <tibbe> dolio, yes
19:40:27 <tibbe> I guess GHC it's it
19:40:45 <tibbe> but it's not the clearest of expositions and it adds Fc
19:40:47 <tibbe> I believe
19:41:06 <dolio> http://hub.darcs.net/dolio/pts
19:43:34 * hackagebot mwc-probability 1.2.2 - Sampling function-based probability distributions.  https://hackage.haskell.org/package/mwc-probability-1.2.2 (JaredTobin)
19:44:32 <tibbe> dolio, thanks
19:45:16 <dolio> No problem.
20:25:30 <Rurik> What is MkNum on slide #26? https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/ECOOP-July09.pdf
20:26:26 <mmaruseacph2> is just an example of a type constructor
20:26:49 <glguy> MkNum is a *data* constructor in those examples
20:27:00 <glguy> Num in that example is a type constructor
20:27:18 <Rurik> so it is generated by the compiler somewhere?
20:27:50 <Costar> Hey all
20:28:17 <glguy> Rurik: it doesn't actually generate a user-visible data  Num a = MkNum ...
20:28:47 <Rurik> I see
20:28:48 <glguy> That slide "How type classes work" is trying to explain how it works in terms of making a new datatype for the dictionary
20:28:54 <mmaruseacph2> *data*, yep, I should not type while watching youtube Haskell talks
20:33:02 <Costar> I have tried to compile a module that uses repa. And i got Couldn't figure out LLVM version! and ghc: could not execute: opt. I have used stack in a mac and i have installed llvm. Anyone knows about this?
20:34:37 <mmaruseacph2> what does `which opt` say?
20:35:35 <Costar> mmaruseacph2: i tried to compile with this in my cabal -Odph -rtsopts -threaded -fno-liberate-case -funfolding-use-threshold1000 -funfolding-keeness-factor1000 -fllvm -optlo-O3
20:36:28 <isovector> heya. does anyone have any experience with evaluating code at runtime via `hint`?
20:36:48 <mmaruseacph2> just type "which opt" in the terminal (without the quotes) and give me the output, please, Costar 
20:37:26 <Costar> mmaruseacph2: nothing
20:38:09 <mmaruseacph2> umm, that means it is not properly installed
20:38:24 <Costar> mmaruseacph2: i have used brew
20:38:24 <mmaruseacph2> or, at least, it is not in your path
20:39:18 <Costar> mmaruseacph2: do you know how to configure the path for this case?
20:40:28 <mmaruseacph2> https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=4&cad=rja&uact=8&ved=0ahUKEwi6m8rQyfzPAhXqqlQKHaSyDcQQFggzMAM&url=http%3A%2F%2Fwww.isi.edu%2F~pedro%2FTeaching%2FCSCI565-Spring15%2FProjects%2FProject1-LLVM%2FLLVMInstructions-MacOSX10.9.pdf&usg=AFQjCNHotbU9RR3zHbY5t85hqh8Pl0UWaw&sig2=yKrt8xYkf9jsNfEU34LPaw
20:40:35 <mmaruseacph2> damn, link too long
20:41:12 <Costar> mmaruseacph2: thank you!
21:01:19 <axelmagn> Hi all
21:01:31 <axelmagn> wondering if you can help a newbie out
21:02:05 <Koterpillar> definitely, but not unless they ask/explain
21:02:11 <geekosaur> ask your question...
21:02:28 <axelmagn> I just finished Learn You a Haskell, and am thoroughly excited.  I want to start a small side project in haskell, so I was wondering where I should look for a contemporary toolchain
21:02:47 <axelmagn> e.g. package management, build tools, etc.
21:03:05 <Koterpillar> 'stack' is a good choice
21:03:10 <zomg> Stack seems to be the du jour tool atm
21:03:22 <axelmagn> ok, cool!  thanks so much.  I'll go check it out.
21:06:06 <EvanR> contemporary haskell
21:06:23 <EvanR> this is the next thing after concurrent haskell
21:06:28 <Koterpillar> {-# LANGUAGE Contemporary #-}
21:08:52 <Welkin> zomg: I used stack before I got started with nix
21:11:03 <axelmagn> Koterpillar: having trouble finding info on contemporary haskell.  is there a place I can read about that?
21:11:44 <Koterpillar> it's not about a place, it's about time!
21:11:44 <EvanR> well, the latest GHC docs go over everything that exists, but its somewhat dry if you dont already know what everything is
21:11:57 <EvanR> theres the Haskell report
21:12:08 <EvanR> this is pretty readable and goes over standard haskell
21:12:52 <EvanR> if you only know LYAH, the haskell report might be a good dose of medicine to take
21:13:28 <EvanR> before you get into the extensions and stuff, you should probably try writing programs yourself with standard haskell
21:13:33 <axelmagn> EvanR: gotcha.  Totally thought "Contemporary" was a language extension I hadn't hear of and _needed_ in my life.
21:13:41 <EvanR> no it was a joke
21:14:00 <Koterpillar> needing it and it existing are different things...
21:14:09 <EvanR> a hilarious one i might add
21:14:50 <mmaruseacph2> Costar: did it work?
21:14:59 <mmaruseacph2> sorry, I'm not experienced in mac intricacies
21:16:51 <mmaruseacph2> Haskell report is HCAR? :P
21:17:16 <EvanR> thats actually a good point
21:18:11 <EvanR> axelmagn: for contemporary haskell stuff, the haskell communities and activities report (from last may) seems to contain a lot of cool stuff
21:18:23 <EvanR> https://wiki.haskell.org/Haskell_Communities_and_Activities_Report#The_thirtieth_edition_.28May_2016.29
21:18:48 <mmaruseacph2> ^_^, thanks EvanR 
21:19:54 <axelmagn> EvanR: Thanks, I'll give it a looksie
21:33:32 <mjhoy> why is it Data.Monoid and not Control.Monoid?
21:34:19 <Clint> mjhoy: why would it be Control.Monoid?
21:34:32 <mjhoy> err, i don't think I understand "Control".
21:34:44 <EvanR> more like why is it not Data.Monad
21:35:01 <EvanR> or Data.everything
21:35:22 <Koterpillar> ^ ++
21:36:03 <EvanR> then you could drop the Data. as understood and wed suddenly have a lot less typing to do
21:36:07 <EvanR> until they invent a haskell IDE
21:37:37 <mmaruseacph2> Leksah? or something built on haskell-ide-engine?
21:37:47 <mmaruseacph2> though I still get to use Vim for everything, it rocks
21:39:13 <nitrix> I bought haskellcode.com today; with in mind to revive FP Haskell Center.
21:39:22 <nitrix> It's a big one man project though.
21:40:15 <kadoban> What's FP Haskell Centor?
21:41:13 <nitrix> kadoban: Used to be a project by fpcomplete.com (authors of stack), where you could clone your projects and work on this online IDE which was designed specifically for Haskell.
21:41:40 <nitrix> Auto-completion, builds, etc. I'm taking it a notch further with collaborative editing.
21:41:48 <kadoban> Oh that, cool. I never used it 'cause by the time I knew about it it was closing down, but it looked neat.
21:41:50 <EvanR> so, github + editor
21:42:13 <EvanR> well github has an editor, but this would have been a usable editor
21:43:21 <EvanR> (yes you can literally edit code on github and create a pullrequest right there, like freakin wikipedia)
21:43:48 <nitrix> The text editor is already a solved problem. The backend part which broadcast the diffs is also solved too by Google (an algorithm called diff-match-patch).
21:44:17 <nitrix> So I think it's fairly realistic.
21:44:47 <EvanR> was there some kind of kickstarter for it? i didnt even know it had progressed that far
21:45:50 <nitrix> It's fast when you can re-use existing work :D
21:46:11 <EvanR> what was the existing editor?
21:46:26 <nitrix> EvanR: Ace, which was developed for c9.io
21:46:50 <nitrix> It has emacs and vim (near perfect emulation) too. It's very cool.
21:48:31 <nitrix> We'll see how it goes c:
21:49:36 <EvanR> sounds like a game changer
21:51:40 <nitrix> It's what originally kept me playing with Haskell and now I miss it. I occasionally send links to coderpad.io on #haskell-beginners, which I'm sure a lot of work went into it, but it's not the same.
21:58:52 <eshan> /window scroll_up
22:00:03 <Lokathor> scenario: the user commands your library to display a Char value that it can't possibly display. What is your response?
22:01:00 <Koterpillar> rewrite the library
22:01:28 <Axman6> Lokathor: that probably depends on what "display" means
22:01:39 <Koterpillar> and what kind of library it is
22:02:00 <Lokathor> the library is an FFI wrapper around curses. it's not particularly feasable to get people to update their curses implementations
22:02:14 <Lokathor> and ncursesw is also... of dubious value
22:02:31 <Axman6> maybe you can print "�" (that may not show up - see https://en.wikipedia.org/wiki/Specials_(Unicode_block)) 
22:02:50 <Axman6> Lokathor: anything wrong with the current curses libraries?
22:02:59 <Axman6> I found brick pretty fun to play with
22:03:20 <Lokathor> well, ncurses only lets you reliably use the printable ascii. to use ncursesw you have to do some extra weird stuff
22:05:01 <Lokathor> technically they're allowed to send a CInt to the function in question, but it's unreliable for things that aren't printable ascii
22:05:35 <Lokathor> so, rendering anything else as a '?' is what i'll probably do, unless someone has some giga clever alternate plan
22:07:44 <geekosaur> worse than that, as for some curses libraries things with higher bits set are taken as attributes
22:08:18 <Lokathor> also true
22:26:44 <coleman> can anyone explain what's wrong with line 6 here?
22:26:46 <coleman> http://lpaste.net/309745
22:26:51 <coleman> I feel like I'm perseverating
22:27:08 <Lokathor> do you mean isInt n
22:27:25 <Lokathor> oh
22:27:25 <coleman> Lokathor: nope
22:28:22 <Lokathor> well what do you want to have happen
22:28:23 <Lokathor> and what oes
22:28:25 <Lokathor> does*
22:28:41 <coleman> It won't compile. The compiler points to `isInt` but its not
22:28:42 <Axman6> not sure what other problems there are, but the Fractional a => doesn't make any sense because you don't mention a in the type at all
22:28:47 <coleman> Lokathor: I just want it to compile
22:29:19 <Koterpillar> paste the error message
22:29:21 <coleman> It should print (b * a * (n - b - a))
22:29:29 <coleman> but there's a serious type issue
22:29:44 <coleman> if line 6 becomes: `isInt b = b` it compiles
22:29:56 <coleman> but if its `isInt b = a * b` it throws the error
22:30:04 <Koterpillar> paste the error message
22:30:14 <Lokathor> ah
22:30:16 <Lokathor> you're using /
22:30:21 <coleman> /home/coleman/Git/euler.hs/009.hs:16:15: error:
22:30:24 <coleman>     • Couldn't match expected type ‘Double’ with actual type ‘Int’
22:30:26 <coleman>     • In the expression: b * a
22:30:27 <coleman>       In an equation for ‘specialTriplet’:
22:30:30 <coleman>           specialTriplet n
22:30:32 <coleman>             | isInt b = b * a
22:30:33 <coleman>             | otherwise = specialTriplet (a - 1)
22:30:36 <coleman>             where
22:30:37 <coleman>                 a = quot n 3
22:30:39 <coleman>                 b = ((fromIntegral n ^ 2 / 2)
22:30:41 <coleman>                      - (fromIntegral n * (fromIntegral a)))
22:30:43 <coleman>                     / (fromIntegral n - fromIntegral a)
22:31:25 <Axman6> coleman: a) never paste more than ~3 lines on IRC
22:31:51 <Axman6> b) when you want help and you're getting an error, always include the error with the code when you're pasting it to something like lpaste
22:31:59 <dmj`> @paste
22:32:00 <lambdabot> Haskell pastebin: http://lpaste.net/
22:32:02 <coleman> Axman6: will do, thinks
22:32:04 <Lokathor> basically what it's saying is that you can't just multiply an Int and a Double together
22:32:14 <Lokathor> > (3 :: Int) * (4.5 :: Double)
22:32:17 <lambdabot>  error:
22:32:17 <lambdabot>      • Couldn't match expected type ‘Int’ with actual type ‘Double’
22:32:17 <lambdabot>      • In the second argument of ‘(*)’, namely ‘(4.5 :: Double)’
22:32:17 <coleman> Lokathor: ah
22:32:27 <coleman> Lokathor: should I just use fromIntegral everywhere?
22:32:30 <coleman> seems odd
22:32:33 <Axman6> no
22:32:33 <Lokathor> well
22:33:01 <Lokathor> what are you trying to do
22:33:06 <Lokathor> in the abstract sense
22:33:13 <Lokathor> is what i want to know, before we can give much more advice
22:33:31 <Lokathor> i don't know what specialTriplet should be computing
22:34:04 <EvanR> you certainly cant multiply an Int and Double together, and its not even haskells fault
22:34:09 <coleman> Lokathor: euler problem 9
22:34:18 <Lokathor> can you link that?
22:34:19 <EvanR> in other languages they convert one or the other to the other for you
22:34:30 <EvanR> for better or worse
22:35:00 <coleman> https://projecteuler.net/problem=9
22:35:26 <coleman> There's a brute force on the haskwell website, but I'm trying to translate my scheme version into haskell
22:36:06 <coleman> https://github.com/JacksonGariety/euler.scm/blob/master/009.scm
22:36:48 <Lokathor> ah ha
22:37:03 <Lokathor> the (integer? foo) bit... doesn't translate well to Haskell i'm afraid
22:37:35 <coleman> Lokathor: damn
22:37:42 <Lokathor> so what i'd do is convert the input into Double, do all the math in Double, and when you need to check if a thing is an integer you make a helper function for that
22:37:43 <Axman6> it might help you if you put some more types in, you're trying to use Ints and Doubles and vide versa all over the place, and you're very unlikely to get the answer you want that way, even if it does return something
22:37:56 <EvanR> integer?
22:37:59 <Axman6> using fromIntegral blindly everywhere will just make it even more confusing
22:38:20 <EvanR> true or false if a number is a whole number?
22:38:25 <Lokathor> EvanR, i'm going to assume it's a Num a -> Bool func that sees if the number is an integer value
22:38:46 <EvanR> you know what happens if you assume
22:39:03 <Lokathor> you become Donald Trump, yes, i know
22:39:10 <sdrodge> You make an ass out u and mptions
22:39:20 <sdrodge> *out of
22:39:28 <EvanR> told you
22:40:04 <Lokathor> EvanR, were you the one that wanted to see the Curses thing if i made it?
22:40:24 <EvanR> yes, but not tonight
22:40:38 <Lokathor> it's fine
22:40:39 <coleman> Lokathor: basically, the solution on the haskell wiki is pretty slow and uninteresting. You can do it faster this way, but I really don't know a thing about number types in haskell
22:40:39 <Lokathor> it's not even done
22:40:52 <EvanR> coleman: glad you asked!
22:41:11 <Lokathor> the first thing to know is that they never auto-convert between types
22:41:17 <coleman> EvanR: that was for Lokathor
22:41:19 <coleman> ?
22:41:25 <EvanR> coleman: https://github.com/haskellcats/haskell-numbers
22:42:06 <Lokathor> coleman, for example, in many languages you can multiply the int 3 and the double 4.5, but under the hood the 3 is secretly promoted into a double form and then double multiplication is performed
22:42:13 <Lokathor> in haskell, that automatic conversion isn't a thing
22:42:32 <coleman> Lokathor: I guess my question about that is: why do I have to do `fromIntegral` every time I ref the variables?
22:42:45 <EvanR> you dont
22:42:52 <EvanR> only if you need to convert
22:42:54 <coleman> Lokathor: I tried using it in the vriable defintion, but
22:43:00 <coleman> it didn't wokr
22:43:02 <coleman> work*
22:43:17 <Lokathor> the types of most math operations in haskell need two values of the same type, so the way you'd do it would be something like
22:43:25 <Lokathor> converting once, and then using the converted form
22:43:36 <EvanR> or start with the same types in the first place
22:43:42 <coleman> Lokathor: it says "cant match float with actual type int"
22:44:03 <Lokathor> however, while the converted form can be any number of forms, it still has *a particular* form, so you still can't mix and match
22:44:05 <coleman> Lokathor: even if I say `n = fromIntegral z`
22:44:22 <Lokathor> well it can pick the type for n based on how you use it, but it still can only pick one type
22:44:32 <Lokathor> so you can't use n with both ints and doubles after that, or it will be upset
22:44:46 <coleman> okay. time to do homework
22:44:52 <coleman> *sigh*
22:45:00 <EvanR> huh
22:45:05 <EvanR> what happened to let polymorphism
22:45:27 <coleman> thanks for the help
22:45:34 <EvanR> > let n = floor 3.14 in (n,n) :: (Int,Integer)
22:45:36 <lambdabot>  (3,3)
22:45:38 <EvanR> awesome
22:45:41 <nshepperd> it's the monomorphism restriction
22:45:46 <EvanR> oh :(
22:46:01 <Lokathor> coleman, try it again using only doubles and you'll have a lot better success I think
22:46:06 <Lokathor> maybe on another day
22:48:49 * hackagebot fay-simplejson 0.1.1.0 - SimpleJSON library for Fay.  https://hackage.haskell.org/package/fay-simplejson-0.1.1.0 (Lupino)
22:53:44 * hackagebot bake 0.5 - Continuous integration system  https://hackage.haskell.org/package/bake-0.5 (NeilMitchell)
22:54:54 <Lokathor> say that i have some value, and i want to make it into an array index (eg: 0 through N-1)
22:55:08 <Lokathor> it seems that both mod and rem allow negative outputs
22:55:36 <Lokathor> so what's the efficient math to make it so that an input is always 0 through N-1 (assuming that N >= 1)
22:55:50 <kadoban> > (-1) `mod` 5
22:55:52 <lambdabot>  4
22:56:12 <Lokathor> > -3 `mod` 12
22:56:14 <lambdabot>  -3
22:56:25 <Lokathor> oh
22:56:25 <Lokathor> ohhh
22:57:46 <kadoban> Hehe, yeah, that crazy operator :-/
22:58:44 * hackagebot quickcheck-report 0.1.0.0 - Customizable reports for quickcheck properties  https://hackage.haskell.org/package/quickcheck-report-0.1.0.0 (SimonHudon)
23:01:00 <Lokathor> http://lpaste.net/309834 whee
23:05:12 <Lokathor> whoops
23:05:43 <Lokathor> http://lpaste.net/309850 is more like it
23:11:59 <EvanR> i am getting a very annoying overlapping instance error
23:13:25 <Lokathor> https://github.com/Lokathor/fullainth/blob/master/lib/Terminal/Hexes.hs
23:13:35 <EvanR> http://lpaste.net/309873
23:14:46 <EvanR> it makes me think somehow the library instances for monad state are smarter than me and already work
23:14:54 <EvanR> but that seems highly unlikely given my type
23:15:17 <EvanR> i realize i have no idea what the overlapping one from Control.Monad.Trans.Free is even saying
23:16:37 <EvanR> it just happened when i tried to use Int as the state ... () and Picture worked...
23:17:56 <EvanR> instance (Functor f, MonadState s m) => MonadState s (Control.Monad.Trans.Free.FreeT f m)
23:18:00 * EvanR thinks very hard
23:19:42 <EvanR> nvm also fails on ()
23:21:52 <EvanR> MonadState anything Identity
23:21:55 <EvanR> brilliant
23:26:32 <EvanR> attempting to newtype my way out of it
23:26:54 <Lokathor> high quality last words
23:29:36 <coleman> Lokathor: got it! Needed to do: isInt (realToFrac b)
23:30:20 <coleman> and it's so fast.
23:30:38 <coleman> 0.00 secs
23:31:01 <Lokathor> one day you'll learn the secrets of unboxed values
23:31:07 <Lokathor> and you'll make it so fast it runs in negative time
23:31:16 <coleman> 0_0
23:31:26 <EvanR> :t isInt
23:31:29 <lambdabot> error: Variable not in scope: isInt
23:31:33 <coleman> Lokathor: how do I turn my answer from exp notation into an int?
23:31:42 <coleman> EvanR: isInt x = x == fromInteger (round x)
23:34:49 <Lokathor> i don't know
23:34:53 <Lokathor> that's why i said stick to doubles :P
23:35:27 <coleman> Lokathor: Can I modify RealFrac to Double maybe?
23:35:39 <Lokathor> :t realFrac
23:35:41 <lambdabot> error:
23:35:41 <lambdabot>     • Variable not in scope: realFrac
23:35:41 <lambdabot>     • Perhaps you meant ‘realToFrac’ (imported from Prelude)
23:35:47 <Lokathor> :t realToFrac
23:35:49 <lambdabot> (Real a, Fractional b) => a -> b
23:35:57 <EvanR> coleman: try the Numeric module for formatting numbers as text
23:36:07 <coleman> the solution: http://lpaste.net/309934
23:36:38 <coleman> EvanR: ah good idea
23:36:47 <EvanR> or printf
23:38:46 * hackagebot portable-template-haskell-lens 0.1.0.0 - Lenses for the AST of Template Haskell 2.11 and Template Haskell < 2.11  https://hackage.haskell.org/package/portable-template-haskell-lens-0.1.0.0 (SimonHudon)
23:38:48 * hackagebot HsHTSLib 1.3.2.0 - High level bindings to htslib.  https://hackage.haskell.org/package/HsHTSLib-1.3.2.0 (kaizhang)
23:56:54 <coleman> EvanR: I just had to round
23:57:30 <coleman> the number is unchanged because I only used the fraction in order to extract the integral number
