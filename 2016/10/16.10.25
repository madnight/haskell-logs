00:07:37 * hackagebot from-sum 0.1.2.0 - Canonical fromMaybeM and fromEitherM functions.  https://hackage.haskell.org/package/from-sum-0.1.2.0 (cdepillabout)
00:07:37 * hackagebot pandoc-citeproc 0.10.2 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.2 (JohnMacFarlane)
00:27:02 <meditans> hi, I'm having a strange error when trying to boot ghcjs, here http://lpaste.net/300928
00:27:20 <meditans> it's related to the integer-gmp haddocks, it seems to me
00:27:43 <meditans> has anyone encountered that before (it doesn't seem the same error present in the issue tracker)
00:28:15 <meditans> also, I'm confident that the stack.yaml file I'm using is correct because I use it in another computer and it builds fine there
00:34:57 <joncol> What's a good way of collecting all characters *not* parsed by a Parsec parser? I'm making a parser for docx files (converted to Markdown by Pandoc as an intermediary step). But the data is dirty, and lots of chunks of text can be skipped in between successful parses of objects (medical exam questions). So I want to collect all the data that thus was thrown away to make sure that it didn't contain 
00:35:04 <joncol> "hidden" questions.
00:42:48 <amalloy> parsec is not going to magically throw away text it doesn't recognize. it will fail to parse. if you want a successful parse, you'll have to add soem rules for handling whatever you think is junk, in which case you'll already have the junk itself handy and won't need to do anything special to collect it
00:47:01 <tdammers> the only challenge there is designing your data structures to accommodate for the collected junk
00:47:16 <tdammers> you can use Parsec's ad-hoc state monad features for that though (the "user state" part)
00:47:36 <tdammers> it's not very elegant, but I believe this would be a valid use case, because the junk data is something you want to collect "on the side"
01:07:36 <joncol> Good ideas, thanks
01:09:32 <hvr> mikeplus32: what problem is there with hsc2hs? I haven't seen any problems so far on 16.10
01:20:42 <hf> hello
01:21:06 <hf> hello
01:21:25 <srhb> hf: hello
01:21:46 <srhb> hf: feel free to just ask your Haskelly question before waiting for people to greet you -- there are too many people in the channel for that to be viable :-)
01:22:37 <hf> vape nation
01:23:43 <hf> refweqefgwhqwerhfgjhl;pio[
01:23:45 <hf> 'ytil;'/
01:23:47 <hf> ???????????
01:23:51 <hf> hello i want to hack
01:24:19 <srhb> Oh well...
01:24:21 <hf> hack school
01:24:25 <hf> big hack
01:24:38 <hf> how??
01:25:57 <hf> LET^S BE FRIENDS
01:26:02 <hf> SARAH !!
01:26:15 <hf> YOU REALLY HIOT!
01:26:40 --- mode: ChanServ set +o Cale
01:26:54 --- mode: Cale set +b *!*@gateway/web/freenode/ip.46.55.167.132
01:26:55 --- kick: hf was kicked by Cale (hf)
01:26:59 --- mode: Cale set -o Cale
01:27:49 <ongy> I wonder how hard it would be to get haskell code to run after remote code execution is possible. Download all of the RTS to run a script?
01:54:12 <hvr> mikeplus32: I'm running 16.10 myself; and you may want to use bindists specifically built & packaged for ubuntu 16.10: https://launchpad.net/~hvr/+archive/ubuntu/ghc
01:56:47 <stobix> Heh. 's been too long since I was here last. How did I invoke the bot again? :)
01:57:40 * stobix just realized the topic. 
01:57:45 * stobix rtfm's
02:01:52 <sham1> o/
02:02:40 * hackagebot word24 2.0.1 - 24-bit word and int types for GHC  https://hackage.haskell.org/package/word24-2.0.1 (winterland)
02:02:42 * hackagebot mysql-haskell 0.6.0.0 - pure haskell MySQL driver  https://hackage.haskell.org/package/mysql-haskell-0.6.0.0 (winterland)
02:04:22 <ertesx> i'm looking for a language that can replace shell scripting that is *not* haskell
02:04:29 <ertesx> any ideas?
02:04:44 <ertesx> ideally typed, but at least functional
02:04:56 <merijn> ertesx: Let me know when you find it :p
02:05:03 <oherrala1> what's wrong with haskell?
02:06:33 <merijn> oherrala1: Spawning processes is a bit annoying
02:06:54 <stobix> merijn: well, then open up an erlang shell. Spawning processes will be easy.
02:07:10 <ertesx> oherrala1: it has a cost, so what merijn said, and also sometimes installing a gigabyte of extra stuff is a hard sell (think VMs or docker images)
02:07:16 <stobix> (As for everything else, though...)
02:07:20 <implementation> but that has nothing to do with the language. with the right library, it may be easy in haskell too
02:07:21 <merijn> stobix: I don't mean erlang processes
02:07:32 <oherrala1> merijn; Turtle doesn't help with that?
02:07:42 <ertesx> (although i can probably do with a smaller dependency graph by using static linking)
02:07:48 <stobix> merijn: you _could_ spawn an os process from an erlang process.
02:08:07 <merijn> stobix: Sure, but I can do so from Haskell too. I'm saying it's not convenient enough :)
02:08:32 <tsahyt> I'm sure you could hack something up with purescript and nodejs, but then you'd effectively be writing shell scripts in js
02:08:38 <sham1> For scripting you could also sue something like Python
02:08:53 <sham1> s/sue/use/
02:09:00 <implementation> if you like lisp: most scheme-interpreters are pretty lightweight...
02:09:23 <stobix> merijn: ⟪spawn fun() -> os:cmd("letmespawn") end.⟫ problem solved. ;)
02:09:33 <merijn> sham1: Python isn't functional, or typed
02:09:34 <tsahyt> there's also typed racket, but I don't know how well it fares at scripting tasks
02:09:40 <sham1> Well, it is typed
02:09:44 <merijn> sham1: Also, spawning processes from python is also a pain
02:09:47 <sham1> Just not statically
02:10:05 <ertesx> sham1: i really want a functional language
02:10:12 <ertesx> and no, python is not functional
02:10:17 <sham1> It is not
02:10:18 <merijn> sham1: It's really not. It has runtime tagging, which is generally useless. Considering the umpteen times I've had to waste hours finding trivial type errors these past months
02:10:45 <ertesx> i thought of using chicken scheme
02:10:59 <ertesx> is erlang any good?
02:11:05 <ertesx> i haven't used it for anything serious
02:11:24 <tsahyt> ertesx: what about racket?
02:11:25 <merijn> ertesx: I like the design of Erlang (well, except for it's lack of typesystem)
02:11:31 <merijn> ertesx: But the syntax is horrid
02:12:18 <stobix> ertesx: it depends on what you want it for. I've used it extensively, and although I lack the haskell currying, it is a nice language to use if you want to have a gazillion processes communicating with eachother.
02:12:21 <ertesx> racket could work too, especially since it has a typed dialect…  i'd check if it has polymorphism first though
02:12:31 <ertesx> stobix: systems stuff mostly
02:12:38 <ertesx> managing services, moving files around, etc.
02:13:12 <ertesx> maybe i'll just use PHP
02:13:22 <stobix> oh. Well, you could make erlang script files that could do that. The real strengths of erlang comes from being a daemon though.
02:13:36 <ertesx> don't worry, i'm just joking =)
02:13:45 <stobix> PHP is a great way to shoot yourself in various body parts you didn't know you even had.
02:14:54 <ertesx> erlang seems to have a similar footprint to haskell though, so it's not really an improvement in this particular case
02:15:24 <stobix> I'd say that their footprints look very much different indeed. Maybe they are similar in size, but certainly not in shape.
02:16:55 <grantwu> Eh, all the same after a bit of rain
02:17:30 <stobix> One thing you can do in Erlang that I don't know you can do in haskell: Have a binary tree where you can use any and all valid types as keys.
02:18:21 <grantwu> data.dynamic?
02:18:41 <stobix> grantwu: does that give you a total ordering of all types?
02:19:13 <grantwu> I guess not
02:19:19 <grantwu> I'm sure you can hack it somehow with unsafe
02:19:27 <stobix> haha! Yeah, I guess.
02:19:35 <grantwu> sorry, I've been up for way too long.
02:19:55 <grantwu> and now I need to write programs in a language I've never used before.
02:19:59 <stobix> Not sure if haskell would like everything to be an instance of Ord, though, but it might be me not being skilled enough Haskellwise.
02:20:18 <stobix> grantwu: been there, done that. 
02:20:27 <stobix> My language was javascript. I cried blood.
02:21:01 <ertesx> i could do something crazy: try idris
02:21:55 <grantwu> stobix: Well, prolog is a different kind of wtf
02:22:05 <stobix> (search result 1 for "idris": An ancient prophet mentioned in the Qur'an.) Yep. Seems crazy enough.
02:22:12 <grantwu> "I change the order of the clauses and my program now terminates? wat?"
02:22:22 <stobix> grantwu: haha, yeah.
02:22:31 * stobix kinda tried prolog once.
02:22:57 <ertes> stobix: i'm assuming that you already know, but in case you don't: http://www.idris-lang.org/
02:23:26 <ertes> thing is: if i can sell erlang, i can probably sell haskell, in which case i'll prefer haskell
02:23:30 <stobix> ertes: Actually I don't, but I managed to google it. :)
02:24:14 <stobix> The way I see it, haskell is all cool and shiny and stuff, but in erlang I write code that I actually understand half a year later.
02:24:16 <ertes> the most realistic options so far are chicken and racket
02:24:28 <ertes> stobix: hmm?  i do that with haskell
02:24:58 <stobix> ertes: I have way too much fun with haskell. ;)
02:25:09 * stobix really just needs to get into it more, probably.
02:26:35 <stobix> Speaking of languages, I played around with newlisp for a while. Found a new kind of loop: let the function add stuff to itself mid execution until the condition is reached.
02:27:33 <ertes> (: distance (-> pt pt Real))  ; wow, that's ugly, but yeah, it's still scheme after all
02:27:41 * hackagebot PPrinter 0.1.0 - A generic derivable Haskell pretty printer  https://hackage.haskell.org/package/PPrinter-0.1.0 (iamzhenyi)
02:28:12 <ertes> oh…  actually, what about SML?  there are still maintained implementations, aren't there?
02:28:48 <grantwu> Well, somewhat.
02:28:54 <grantwu> but SML as a scripting language?
02:30:37 <ertes> (: my-id (All (a) (-> a a)))  ; that's even half-way reasonable…  a lot more reasonable than in many other languages
02:30:53 <opqdonut> hehe prefix :
02:31:28 <stobix> ...oh, is that a type declaration?
02:31:33 <opqdonut> yeah
02:32:08 <stobix> Heh. Nope, not painfull at all. Nope.
02:33:00 <opqdonut> would be less of an eyesore if it was "ann" or "type" or something like that instead of just ":"
02:33:43 <ertes> well, it's scheme…  i don't find the everything-prefix limitation to be as useful as lispers do…  there is no inherent reason why you shouldn't be able to *write* scheme using infix forms
02:34:18 <ertes> but i could live with it
02:34:32 <stobix> ertes: Can't you? In lisp you could macro away stuff like that.
02:35:49 <ertes> stobix: "stuff like that"?
02:36:05 <kori> I've come to like prefix more than infix only because of paredit
02:36:09 <kori> paredit is great
02:36:53 <stobix> ertes: I imagine you could write e.g. (foo : some -> stuff ) and have a macro turn it into (: foo (-> some stuff)) under the hood if you wanted to.
02:37:10 <stobix> eh, probably (typedef foo : some -> stuff), but still
02:39:40 <ertes> kori: you can have something like paredit with haskell…  the yi editor has that
02:39:50 <ertes> at least partially
02:40:06 <ertes> stobix: that sounds super-unsafe
02:40:17 <kori> ertes: mmh
02:40:26 <kori> i haven't gotten around to using haskell yet
02:40:49 <ertes> kori: there was also structured-haskell-mode for emacs, but i don't know if it's still maintained
02:42:18 <stobix> ertes: oh, why?
02:42:35 <ertes> stobix: intuitively
02:43:00 <tsahyt> is a ForeignPtr guaranteed to be finalized before the program exits?
02:43:08 <ertes> it's like having TH turn my valid haskell syntax into other valid haskell syntax that means something completely different
02:43:09 <stobix> ertes: ah. Good thing intiution is always sound. ;)
02:43:14 <ertes> tsahyt: no
02:43:18 <tsahyt> shit
02:43:27 <tsahyt> that might cause problems :/
02:44:04 <grantwu> I mean, SIGKILL...
02:44:07 <ertes> tsahyt: you could maintain a pool of values
02:45:49 <ertes> tsahyt: withStuffPool :: (forall s. (Reifies s StuffPool) => IO (Stuff s) -> IO r) -> IO r  -- makes sure that all Stuff finalisers run just after the given action completes, passing it a newStuff function
02:45:54 <ertes> the rank-2 type makes sure that you can't leak a Stuff
02:46:11 <ertes> and Reifies is from the reflection library
02:46:35 <tsahyt> hmm, that might be useful as a general pattern
02:47:26 <tsahyt> the problem I'm dealing with is that this C library I'm wrapping has you create a control object (handle) and tear it down eventually. you can derive specialized handles from it and work with them, as long as the original handle still exists.
02:48:04 <tsahyt> so I want to prevent those things leaking out into an environment where free has already been called
02:48:28 <tsahyt> but since I've got multiple things to manage a single foreignptr wouldn't do anyhow
02:49:25 <merijn> tsahyt: So, what you really want is linear types, which unfortunately we don't have yet :)
02:49:34 <tsahyt> I suppose so
02:49:46 <tsahyt> but an ST-style rank-2 wizardry solution might just work
02:50:12 <tsahyt> I'd just rather not have a specialized monad for it, as I'd like the user of the library to be able to run this on top of any monad stack as long as it satisfies MonadIO
02:50:36 <ertes> "yet" =/
02:50:59 <merijn> ertes: What's wrong with that? I'd love linear types
02:51:19 <tsahyt> explicit handle (opaque of course) passing seems like the saner solution than either restricting the user to one particular monad that I set up, or doing some MonadHasHandle typeclass stuff
02:52:30 <tsahyt> on a related note, is there a decent solution to denote what exceptions can be thrown in a function? Ideally something that works nicely with MonadThrow/MonadCatch
02:52:58 <merijn> tsahyt: Sadly doesn't really exist
02:54:42 <tsahyt> ertes: what's the Reifies for?
02:58:36 <ertes> merijn: yes, me too!
02:58:48 <ertes> merijn: that's why i'm sad about that 25-year-old "yet" =/
02:59:31 <ertes> tsahyt: 'reify' and 'reflect' form the two halves of reflection:  respectively going from a value to a type and back
03:00:12 <ertes> tsahyt: reflection lets you construct a type the represents a value (reify), and then, given that type, get the value (reflect)
03:01:18 <ertes> in this case you might consider not only using 's' as a phantom type, but you could let it carry the pool…  that way you can construct new Stuffs from existing ones without going through 'newStuff' (the only thing that otherwise knows about the pool)
03:01:42 <ertes> note: nothing about that construction uses global mutable memory…  the pool is actually local to each instance of 'withStuffPool'
03:05:24 <tsahyt> really I've just got one Stuff though
03:05:43 <tsahyt> all other things that must not leave scope are derived from this one Stuff, but need not be freed explictily
03:08:40 <tsahyt> Maybe implementing an ST-like base monad would work well, which carries the master handle and uses rank-2 types to make sure that you can't smuggle any handles out of it
03:09:43 <notdan> hej
03:09:56 <tsahyt> basically like this, but with the monad carrying what I need https://www.vidarholen.net/contents/junk/catbag.html
03:14:03 <tsahyt> using something like this, can I write something like foo :: Monad m => (forall s. DerivedHandle s) -> Foo -> m Bar?
03:14:17 <tsahyt> the derived handle itself can only ever be created in an appropriate monad
03:15:55 <tsahyt> looking through ST again, the forall really only exists on runST. so is it enough to have this guard in place only at the place of entrance/exit?
03:16:16 <ertes> tsahyt: in that case you don't need any of the reflection/newStuff stuff
03:16:27 <ertes> tsahyt: withStuff :: (forall s. Stuff s -> IO r) -> IO r
03:17:34 <ertes> just add a phantom type and forcefully call the finaliser just before 'withStuff' completes
03:17:35 <tsahyt> ertes: and I can have a function Stuff s -> DerivedStuff s in there and be sure that DerivedStuff s doesn't leave the context too, right?
03:17:44 <ertes> tsahyt: yes
03:18:02 <ertes> 's' can never leave the scope of that function (because it can't unify with 'r')
03:18:32 <tsahyt> that could work. it doesn't even require me to provide a specific Monad. I think this might be the least restrictive solution for users then
03:18:55 <ertes> yeah…  all you require is IO
03:19:28 <tsahyt> but it'd work just as well with (MonadIO m, MonadYadaYada m) => (forall s. Stuff s -> m r) -> m r
03:19:31 <ertes> tsahyt: however: if withStuff runs in an extra thread and the main thread exits, finalisers may still not be called
03:19:34 <tsahyt> unless I'm missing something
03:19:47 <ertes> you need to make sure that all threads using withStuff exit cleanly
03:20:06 <ertes> (e.g. use 'wait' from the 'async' library)
03:20:31 <tsahyt> but that's a general problem with threads I think, because the runtime doesn't wait on exit
03:20:39 <ertes> MonadIO doesn't work
03:20:44 <tsahyt> why not?
03:20:54 <ertes> you need something like MonadBaseControl or MonadCatch
03:21:10 <tsahyt> ah good, because MonadCatch is something that I wanted to use anyhow
03:21:15 <ertes> to implement withStuff you need 'finally'
03:21:42 <tsahyt> ah right, in case of exceptions
03:22:27 <Galt> Hi... I am a bit new to Haskell.... I wanted to ask if there are any good IDEs that I can use to ease practice in Haskell?
03:22:43 <ertes> Galt: which editor are you used to?
03:23:21 <tsahyt> the other big thing I'm unsure about how to do in this library is that the C API uses callbacks quite a bit. it's a solver that runs asynchronously, you can register callbacks with it to modify how it operates. These callbacks utilize state, i.e. they take some void* userdata, which they may modify. Is there some accepted pattern how to deal with this in Haskell?
03:23:47 <Galt> I normally work with Java and for that I use Vim for editting and build on command line. I also use Eclipse sometimes.
03:23:48 <gargawel> Galt: the standard response is "use Atom" or (preferably) "Emacs/Spacemacs with Intero"
03:24:20 <ertes> Galt: vim is fine for haskell
03:24:22 <gargawel> the former is easier to use, but the latter offer the best user experience by far w/ automagic code-completion, feedback from the compiler, etc.
03:24:34 <ertes> gargawel: what?  that's a super-non-standard response!
03:24:39 <tomjaguarpaw> Why can I no longer load my local projects with -i<whatever> in GHCi?
03:24:44 <tomjaguarpaw> Has something changed in GHC 8?
03:24:55 <gargawel> ertes: Vim is fine, but is nowhere close to an IDE
03:25:20 <phanimahesh> yet
03:25:20 <gargawel> ertes: that's quickly becoming the consensus, it seems
03:25:21 <ertes> gargawel: "it seems" =)
03:25:28 <gargawel> that's the response for people asking for an IDE, not a text editor
03:25:30 <gargawel> may I add
03:26:07 <gargawel> ertes: see yesterday's reddit thread, for example: https://www.reddit.com/r/haskell/comments/58oqdi/cant_get_an_ide_to_work/
03:26:30 <Reisen> Is there a way I can automatically re-export all modules from another module without explicitly listing them? I.E, I know I can create a .cabal file with build-depends X, then do reexported-modules: X, X.A, X.B, etc
03:26:42 <Galt> ertes: I guess there may be plugins that I can add to Vim to help me out. gargawel, I do accept that Emacs may be a better IDE than Vim is but I personally don't have much experience with it :(
03:26:43 <gargawel> and it's quite undeniable Emacs is getting the most work on IDE-like support in Haskell-land
03:27:15 <liste> gargawel: what Atom are there for Haskell development and what do they do?
03:27:30 <tsahyt> Galt: what features are you looking for in vim?
03:27:43 <gargawel> liste: https://atom.io/packages/ide-haskell ?
03:28:05 <gargawel> Galt: ^ as well
03:28:06 <liste> gargawel: yeah, I've looked into that
03:28:16 <Galt> tsahyt: Autocompletion if there are standard libraries/modules, directly being able to access GHCI, etc
03:28:18 <gargawel> I am not sure I understand your question
03:28:56 <liste> Galt: syntastic (syntax checking) + neco-ghc (autocomplete) + ghcmod-vim (type introspection etc) work well for me as Vim plugins for Haskell dev
03:29:01 <tsahyt> Galt: neco-ghc in conjunction with ghc-mod can do autocompletion decently. 
03:29:51 <Galt> liste, tsahyt: Will check these out! Thanks a lot
03:30:18 <Galt> gargawel: The Atom text editor with the Haskell plugin sure looks cool!
03:30:31 <ertes> Galt: the most popular editors/IDEs are probably still emacs and vim…  atom seems to have some popularity as well
03:30:41 <gargawel> Has ghc-mod been updated to support GHC8 ?
03:30:56 <ertes> Galt: i can't help you with vim, but emacs with haskell-mode and haskell-interactive-mode is pretty much a full IDE
03:31:08 <ertes> with interpreter integration and everything
03:31:20 <ertes> i know that vim can do something like that as well (using ghc-mod i think)
03:31:32 <MarcelineVQ> liste: ide-haskell, language-haskell, and optionally haskell-ghc-mod are a nice setup for atom. atom's main flaw that I've noticed is that it chugs on large enough files, or large pastes. gargawel: ghc-mod works with ghc 8
03:32:02 <gargawel> MarcelineVQ: good to know :-) Last time I checked, it hadn't, but that was a while ago
03:32:09 <ertes> Galt: there is also the alternative intero for emacs, but that one is hardcoded to use stack
03:32:21 <ertes> so i don't recommend it
03:33:08 <Galt> ertes: I can understand why vim/emacs are popular. They are in my opinion the most productive editors. I was mainly looking at autocompletion since I am not yet familiar with what Haskell already offers.
03:33:37 <ertes> Galt: if you're talking about auto-completing symbols that are in scope, emacs and vim both give you that
03:33:46 <tsahyt> FWIW I hardly ever need autocompletion in Haskell for some reason
03:34:09 <ertes> if you're talking about something like intellisense, that's trickier…  i don't know of any working solutions
03:34:18 <ertes> (would be nice to have though)
03:34:42 <tsahyt> type-sensitive autocompletion would be nice
03:35:12 <ertes> Galt: but i think the most important feature is being able to query the type system quickly and responsively, which does work in at least emacs and most likely vim
03:36:28 <ongy> I fail at setting up neco-ghc, but from what I gather it should be somewhat intelligent autocomplete in vim
03:37:23 <phanimahesh> neco-ghc is cool. for what little haaskell I wrote, vim was good enough
03:37:37 * liste is building leksah (Haskell IDE) atm to try it out, maybe it'll be viable in the future
03:38:24 <gargawel> Leksah is the Hurd of Haskell editors ;-)
03:39:36 <Galt> ertes: I was talking in a sense similar to IntelliSense... Eclipse/IntelliJ/Netbeans offer that for Java and it is pretty useful for newbs.
03:41:03 <gargawel> Galt: it is somewhat easier for object-oriented languages to provide this kind of experience
03:42:12 <gargawel> "object.<Ctrl+Space>" makes sense to get a list of all methods for an object, "<?> someValue" doesn't
03:42:33 <merijn> gargawel: Clearly you haven't looked at Lamdu yet :p
03:42:47 <merijn> Although it seems on hiatus again
03:43:30 <Galt> gargawel: Yeah... That makes sense... 
03:43:30 <gargawel> *harder* doesn't mean *impossible* ;-) I've looked at lamdu, but not very long
03:43:37 <ongy> gargawel: fildName <Ctrl+Space> could make sense to suggest the viable variables in scope though
03:43:58 <gargawel> ongy: yes, clearly ; but it won't help you to find a function name
03:44:17 <gargawel> that's the #1 usecase for Intellisense & co
03:44:25 <ertes> Galt: the problem is that haskell doesn't offer OO accessor syntax, but functions/accessors are always written using regular application syntax:  f x
03:44:37 <Galt> How about this.... Say for a function Char.toUpper, I can type Char. and it will help me find my functions in Char scope... 
03:45:01 <Galt> I don't know if I am understanding this right.
03:45:04 <tsahyt> I'm pretty sure neco-ghc does this
03:45:04 <gargawel> would that require importing all modules qualified ?
03:45:08 <Vyn> John?
03:45:12 <ertes> Galt: for intellisense to work, you would have to type 'x' first, infer its type, then see what function types that are in scope unify with that type
03:45:37 <ertes> Galt: which is currently poorly supported by GHC, but even if it were well supported, you get a *lot* of useless stuff
03:45:53 <ongy> then I will have to put more effort into neco-ghc. Anyone have neco-ghc with plug running?
03:45:55 <jophish> This sounds like a job for typed holes
03:45:58 <ertes> so i'd question whether intellisense in haskell/FP would be as useful as it is in an OO language
03:46:31 <Galt> ertes: Hmm... Seems like a reasonable argument.
03:46:38 <ertes> in an OO language there is the "member" relationship between types and functions
03:46:47 <ertes> which doesn't exist in haskell
03:47:47 <liste> though tools like Hoogle would enable features never seen in IDEs
03:48:05 <liste> maybe a different kind of "intellisense"
03:48:24 <Galt> ertes: So what I understand from this is that I can create an analogy where haskell is more of a bag full of functions of different type and java (or OOPLs) is more of a collection of small pouches of functions.
03:48:42 <ertes> Galt: yeah, you could say that
03:49:17 <ertes> Galt: we still create small pouches of functions, but not by relating them to types, but to modules
03:49:19 <tdammers> I believe part of the reason why intellisense is successful is because the languages that rely heavily upon it require so much redundant code
03:49:33 <Galt> Finding the correct function from a bag full of functions is harder than from a bunch of pouches when I know the pouch it belongs to.
03:49:50 <black0range> is it possible to derive Generic1 outside module whera a datatype is defined? 
03:49:53 <ertes> Galt: not really…  haskell is designed in a way that you will probably never have a problem finding the function you need
03:50:00 <ertes> Galt: remember that haskell is not an OO language
03:50:32 <ocramz> anyone knows why Hackage is not building docs these days? 
03:50:41 <ertes> tdammers: intellisense provides this exploration-based programming style:  "i know i have to do something to x, so i'll just type `x.` and let the IDE tell me what i can do with it"
03:50:43 <ocramz> what enchantment do I need to make it build my haddocks?
03:51:21 <jophish> ocramz: Hackager been very good at this :/ It's best to upload them manually with 'cabal upload --doc'
03:51:23 <Galt> ertes: How can I find the function I need in Haskell?
03:51:36 <jophish> Hackage has not been*
03:51:49 <Galt> ertes: Apart from Googling and looking at the docs that is... 
03:52:00 <ocramz> jophish : thanks
03:52:05 <ocramz> does stack have that option too?
03:52:08 <ertes> ocramz: feel free to steal my workflow for uploading docs: https://github.com/esoeylemez/skeleton/blob/skeleton/Makefile#L16-L41
03:52:09 <liste> @hoogle (a -> b) -> [a] -> [b] -- Galt
03:52:13 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
03:52:13 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
03:52:13 <lambdabot> GHC.OldList map :: (a -> b) -> [a] -> [b]
03:52:29 <ertes> ocramz: you need to replace the nix stuff with cabal/stack stuff, but other than that it should work OOTB
03:52:41 <ocramz> thanks ertes I'll look into it
03:52:41 <Galt> liste: What just happened?
03:52:50 <liste> Galt: that's a tool that finds the function I need (:
03:52:54 <ertes> Galt: in general you will just know…  i can't explain it
03:53:02 <liste> Galt: it looks up functions by type signature
03:53:13 <Galt> liste: This bot can be used in Vim/Emacs as well?
03:53:19 <ertes> Galt: if all else fails, yeah, hoogle, but i've never needed it once in my life
03:53:50 <liste> Galt: yes, it's available as a library, standalone executable etc
03:53:55 <Galt> ertes: I believe you are talking about the point where I become a bit more familiar with Haskell.
03:54:10 <Galt> liste: Does look useful... Will surely check it out.
03:54:40 <ertes> Galt: possibly yeah, but it's not by virtue of just memorising everything, but rather the way we abstract in haskell
03:55:02 <ertes> you will either know which function you need, or you will know where you'll find it
03:55:42 <Galt> ertes: That would be so amazing once you get to that stage...
03:56:08 <ahihi> I have many years of haskell experience and I still find hayoo (similar to hoogle) very useful
03:56:14 <ahihi> but then my memory is not flawless
03:56:17 <Galt> One final question: I completed reading through LYAH, any recommendations on what next?
03:56:41 <ertes> Galt: yeah, write a program =)
03:56:45 <ongy> find something to work on. IMO that's the best to get familiar with things
03:57:02 <Reisen> Is there a way to wildcard export in reexported-modules? Or something equivelent? Such as, "reexported-modules: base:*"
03:57:20 <ongy> and maybe ghc language extension documentation, just to have seen things, so you remember them when you are stuck on something
03:57:25 <Galt> ertes: xD
03:57:33 <tsahyt> can a haskell program leak memory by losing a StablePtr?
03:57:50 <tsahyt> and if yes, what happens when it was passed to C, lost on the Haskell side, and C frees it? I suppose that'd be a big problem
03:58:36 <Galt> How easy is it for a beginner to get into open source projects in Haskell? I am talking about the complexity of the projects.
03:58:38 <ertes> tsahyt: i'd expect yes, because that's kind of the point of StablePtr
03:59:26 <tsahyt> then this doesn't look like a workable solution for my callback problem either
03:59:34 <merijn> Galt: Easier than other languages, imo
03:59:53 <merijn> Galt: With many languages you find yourself wondering "wait, where does this variable/whatever come from?"
04:00:04 <Galt> merijn: Cool... Then I guess I should start working in that direction as well.
04:00:10 <merijn> Galt: Haskell, being purely functional, means no side effects and all variables passed in explicitly
04:00:20 <Galt> merijn: Brilliant
04:00:41 <ertes> Galt: i suggest making your first project your very own, simply to see how everything works, including cabal, GHC, etc.
04:00:45 <merijn> Galt: So generally I find it easier to find my way in, but most open source projects do require some sort of minimal familiarity with common libraries
04:01:00 <ertes> Galt: writing your first own .cabal file is an important milestone
04:01:02 <merijn> Galt: (i.e. monad/applicative, mtl, containers)
04:01:28 <ertes> Galt: (or letting cabal-install generate it for you and adjusting it)
04:02:00 <Galt> ertes: Hmm... Yep. Will take note of that as well.
04:02:23 <Galt> Anyways... Thanks a lot folks. It is great to get involved with this amazing community!
04:24:17 <damian_> hey guys... I have a mlt stack... something like "newtype App a = App {runApp :: StateT AppState (ExceptT AppError (ML.LogT AppLoggingEnv IO)) a}"
04:24:28 <damian_> but I want some function that actually run the whole app in the IO monad... some function with type App a -> IO a, I have the function already.. not sure what is the naming convention for that kind of function
04:25:09 <athan> damian_: Usually `runApp` :)
04:25:13 <tsahyt> runAppIO?
04:25:16 <athan> or something like that
04:25:35 <damian_> right.. but runApp is in the record signature of the App newtype
04:25:38 <damian_> that is what I am asking
04:25:42 <damian_> runAppIO... like it
04:25:49 <damian_> not sure there was any convention for that or not
04:26:49 <athan> ^^
04:27:33 <athan> <insert exploitive here>, System.FilePath.isAbsolute "/some/thing" on Windows returns False :(
04:28:09 <damian_> thanks
04:28:35 <tsahyt> does anyone here have experience wrapping C libraries that utilize stateful callbacks?
04:29:00 <tsahyt> i.e. callbacks that take a pointer to some user data
04:29:33 <athan> tsahyt: Like a foreign pointer or something?
04:29:43 * athan doesn't actually have experience
04:29:49 <tsahyt> the data exists on the haskell side, so I think it should be a stableptr
04:30:02 <tsahyt> the problem is that the C API doesn't provide anything for when the data can be free'd
04:30:15 <Athas> Are any compilers than GHC using C--?
04:30:21 <athan> hmm I think so, but really you'd just copy the data then return it back, wouldn't you?
04:30:37 <athan> because you can't tweak haskell values from a pointer due to purity
04:31:05 <athan> iirc GHC solves the freeing on its own
04:31:16 <tsahyt> well yes I'd have functions that end with Data -> (Data, a), or something stateful like that and do the wrapping into a ptr where I pass this all through FFI
04:31:20 <athan> because you're leaving scope something something >.>
04:31:44 <athan> that sounds right tsahyt
04:31:49 <tsahyt> but the problem I see is that eventually it won't be called again, and now I have a StablePtr dangling in nowhere
04:32:00 <tsahyt> and the data behind a StablePtr is guarenteed not to be GC'd
04:32:05 <tsahyt> so I technically end up with a leak
04:32:22 <tsahyt> ideally of course the C API would also take a callback to clean up the userdata
04:32:24 <tsahyt> but it doesn't
04:33:03 <merijn> Athas: Not really, llvm has basically supplanted C--, also note that GHC does not use C--
04:33:05 <athan> this is what foreign pointers are for tsahyt
04:33:12 <merijn> Athas: It uses Cmm, which is loosely based on C--
04:33:22 <tsahyt> athan: but it expects this to be done by the caller
04:33:30 <tsahyt> athan: the library doesn't free it either
04:33:37 <athan> isn't that fine?
04:33:45 <athan> GHC solves how to free foreign pointers
04:34:13 <MarcelineVQ> knowing nothing about the ffi: can you bracket what you're doing with the pointer so you know when it's safe to free it by virtue of the bracket closing?
04:34:14 <merijn> tsahyt: StablePtr is only really for Haskell values, not C pointers
04:34:31 <tsahyt> merijn: but that's what I need. I need some haskell values that can be worked on by the callback
04:34:34 <Athas> merijn: right, I imagined something like that was the case.
04:34:36 <tsahyt> the callback is a haskell function after all
04:34:38 <merijn> tsahyt: ok
04:35:05 <merijn> Athas: So the real answer is "As far as I'm aware, there isn't a single compiler, including GHC, that uses C--" :p
04:35:19 <athan> tsahyt: http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html#id655309
04:35:21 <merijn> tsahyt: But the C API doesn't take a free callback?
04:35:32 <tsahyt> merijn: nope, that's the problem.
04:35:49 <merijn> tsahyt: And you never know when the C API is done with your callback?
04:35:54 <tsahyt> I'm actually thinking about writing a feature request. this seems like a major oversight
04:36:12 <tsahyt> merijn: it can be called arbitrarily often for the entire lifecycle of the things managed by the library
04:36:43 <merijn> tsahyt: I don't see how you could write leak-free code using this API (and I don't mean just haskell, you can't even write leak free C using this...)
04:36:43 <tsahyt> it's a logic programming solver. for example there's an onModel callback that gets called whenever it finds another model. I can't predict how many of those there are, or when it will be called.
04:36:59 <tsahyt> merijn: well the C examples just keep track of the userdata pointer themselves
04:37:14 <tsahyt> or just use data on the stack for it
04:37:17 <merijn> tsahyt: How can they free them when you don't know when the API is done?
04:37:23 <merijn> tsahyt: o.O
04:37:47 <tsahyt> well eventually you can free the whole solver object and after that it's definitely done
04:38:01 <merijn> tsahyt: So what's stopping you from doing the same?
04:38:13 <tsahyt> the search for something that requires less manual intervention
04:38:25 <merijn> tsahyt: You
04:38:30 <tsahyt> yes
04:38:31 <merijn> You're shit outta luck :)
04:38:37 <merijn> (preemptive enter)
04:39:00 <tsahyt> I might need ertes' storage pool suggestion after all
04:39:01 <merijn> tsahyt: Any "less manual" solution will involve FAR more work than just sucking it up and freeing it manually
04:40:06 <hackrilege> mmmm free solver object
04:40:08 <tsahyt> delegating manual freeing to the user is not an option imo. but I think I can abstract it away, provide just one way to create such user data values, register them, and free them when possible
04:40:14 <athan> just hit it with a hammer
04:40:36 <tsahyt> alternatively, tell the authors of this library
04:41:30 <hackrilege> Stone kind of virtual machine?
04:41:39 <hackrilege> Some*
04:43:00 <hackrilege> Are you making C like malloc?
04:43:25 <tsahyt> hackrilege: I'm just writing bindings to a library
04:43:28 <hackrilege> And garbage collector by the sounds of it
04:43:44 <tsahyt> not at all
04:44:58 <hackrilege> I thought you said you didn't want the user to have to unallocate the memory, which sounds like garbage collection to me...
04:46:04 <tsahyt> hackrilege: I just wanted to leverage GHC's garbage collection. having to deal with memory management in FFI bindings isn't anything out of the ordinary. Providing a user facing API that requires manual memory management in Haskell is rather ugly imo
04:46:44 <hackrilege> Yes, I don't see why you would have to
04:47:46 * hackagebot partial-handler 1.0.2 - A composable exception handler  https://hackage.haskell.org/package/partial-handler-1.0.2 (NikitaVolkov)
04:48:32 <tsahyt> hackrilege: I don't have to, I'm just looking for the nicest way to handle this
04:49:03 <SShrike> Someone sell Intero to me, why should I use it over ghc-mod?
04:49:56 <athan> SShrike: I don't technically use either, my editor does, but I've heard it's far more accurate, and is better suited to the problem
04:49:56 <hackrilege> I wonder how the values can be unallocated via ffi calls if you want the ghc garbage collector to do it, maybe just implement some common high order functions (prelude classes) with the correct deallocation... Maybe that messes up with laziness somehow, I can't tell...
04:50:00 <athan> also builds easier
04:50:26 <athan> iirc ghc-mod uses cursor positions excessively or something, while intrero leverages GHC's understanding or something
04:50:33 <athan> ... or smething
04:51:25 <SShrike> Haha, I'll look into it more
04:51:34 <SShrike> Just trying to get past the buzzwords/hype
04:52:04 <athan> act now and you can get rid of your buzzhype FREE
04:52:39 <athan> for only a picosecondly subscription of semantic obsession
04:57:24 <ertes> SShrike: note that there is haskell-interactive-mode, too
04:57:25 <tsahyt> hmm. so when I have a StablePtr (MVar Foo), and I deref it, put something else into the MVar, is the pointer still valid? I.e. does it now point to the modified mvar?
04:57:33 <tsahyt> or in other words, does an MVar stay in the same place?
04:57:54 <ertes> where does all the sudden intero hype come from?  i feel like it's haskell-interactive-mode, except that it locks you into stack
04:58:17 <sbrg> SShrike: I'm just using haskell-mode without intero-mode, and it works more than fine. however, I do believe there are some features that intero is better at, like jumping to definition and such. I intend to integrate it into my workflow
04:58:43 <ertes> use haskell-interactive-mode!  it comes with haskell-mode, you just need to enable it
04:58:52 <cocreature> tsahyt: afaik that should work, i.e. it should point to the modified mvar
04:59:13 <tsahyt> good, so between that and a storage pool for the needed pointers, this should work without leaking
04:59:58 <tsahyt> cocreature: the contents of the MVar it self are memory managed though, right?
05:00:24 <tsahyt> it's really strange to think about haskell in this way. I gotta say I'm not very fond of writing FFI bindings...
05:01:18 <cocreature> tsahyt: not sure if I understand what you are asking. if nothing references a value it will eventually be deallocated. an mvar is just one of the things that can reference it. putting it in a stableptr doesn’t make a difference
05:01:46 <tsahyt> good. I just wanted to make sure that there's no nasty surprise there.
05:01:56 <merijn> cocreature: Well, it does, in the sense that stableptrs do much more than guaranteeing liveness
05:02:05 <tsahyt> really the sanest solution is to nicely ask for free-ing callbacks
05:02:17 <tsahyt> or at least why they don't exist
05:02:43 <hackrilege> You can remove elements from a list...
05:02:53 <merijn> tsahyt: The StablePtr guarantees that the MVar itself doesn't move
05:03:23 <tsahyt> merijn: but the thing "in" it is just referenced by the MVar, and acts like any other haskell heap object, right?
05:03:49 <merijn> tsahyt: It should, yes
05:04:52 <merijn> tsahyt: Although we're now at implementation level details that you might wanna verify on the mailing list/in #ghc :)
05:04:55 <MarcelineVQ> tsahyt: If such callbacks are useful and there aren't other ways to do what you're after you could post it as a feature request on the ghc trac, you should at least get a good reason why it's not a thing that way.
05:05:09 <merijn> MarcelineVQ: This is not a GHC problem
05:05:19 <merijn> MarcelineVQ: This is a problem in the C API of the library he's using
05:05:43 <hackrilege> I could write a function which alters e.g. The n in take n, so the list is still alive. Even if it will not be referenced, that can be changed.
05:06:19 <MarcelineVQ> I see, I must have misunderstood what tsahyt's asking for then
05:06:29 <tsahyt> I don't really see a way how GHC could solve this. I either have to manually keep track of the stableptrs, or let them leak, or require the user to handle it.
05:06:39 <merijn> MarcelineVQ: His problem is that the C API doesn't take a "free" callback to free the GHC allocated stuff
05:07:11 <merijn> MarcelineVQ: So he can't rely on the C library to free his StablePtr, the same way in C you'd be unable to let that library call free() for you
05:07:18 <tsahyt> or require my german colleagues to implement a free callback
05:07:22 <[exa]> Hm guys. Is there any reasonable situation where I'd need type variables of kind other than * in an explicit typing declaration?
05:07:26 <tsahyt> and with require I of course mean "ask nicely"
05:07:40 <merijn> [exa]: Depends on your definition of reasonable? :)
05:08:27 <hackrilege> Functors?
05:08:59 <MarcelineVQ> merijn: interesting thank you
05:09:00 <[exa]> merijn: seen used somewhere for a good purpose :]
05:09:10 <merijn> [exa]: I've used them a bunch of times
05:09:20 <hackrilege> Monad Transformers...
05:09:41 <[exa]> Oh my, stupid question.
05:09:45 <hackrilege> Recursive types
05:09:46 <merijn> MarcelineVQ: GHC already has, for example "freeStablePtr" and if you foreign export that and pass it to a C API as a callback I don't see why it wouldn't work :)
05:09:47 <[exa]> Monad m => a-> m a
05:10:04 <joncol> Is it expensive to repeatedly put Chars at end of Text?
05:10:24 <merijn> [exa]: Oh, I was thinking of *kind* annotations, not just type variables.
05:10:34 <merijn> [exa]: For type variables you definitely need kinds other than * :)
05:10:41 <cocreature> joncol: yes, appending to a Text is O(n) where n is the length of the Text
05:10:45 <merijn> joncol: Yes
05:11:00 <jophish> joncol: you may be interested in https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Lazy-Builder.html
05:11:03 <[exa]> merijn: that's also a good question, is it used somewhere in actual explicit typing?
05:11:33 <hackrilege> Is what used?
05:11:33 <merijn> [exa]: More rarely, GHC can usually infer the kind just fine. But in some obscure corner cases it might not be able to
05:12:04 <[exa]> joncol: I'd simply reverse the string internally (just as with finger pattern)
05:12:25 <merijn> [exa]: Imagine this contrived example: "data Foo m = Foo; foo :: Foo m -> m a" <- this would (normally) not work, since the type variable in the data declaration defaults to kind *
05:12:41 <merijn> [exa]: So you might need "data Foo (m :: * -> *) = Foo" explicitly to make it typecheck
05:12:47 <merijn> Well, kind check, I suppose :)
05:13:08 <[exa]> merijn: oic. The kinds of variables are not fixed in 'data' statements?
05:13:09 <merijn> [exa]: But those cases are kinda rare in my experience
05:13:40 <merijn> [exa]: They are, but are usually inferred. i.e. "data Bar f x = Bar (f x)" infers 'x :: *' and 'f :: * -> *'
05:13:42 <hackrilege> They are fixed if they are used explicitly
05:13:54 <[exa]> I was hoping to solve this stuff by having the programmer explicitly state that 'data Foo m :: * -> * -> *' = ....
05:14:08 <joncol> Both cons and snoc are O(n) for Text, right? So reverse wouldn't work? I'll look into Builder, thanks jophish.
05:14:16 <jophish> np :)
05:14:23 <merijn> [exa]: You can explicitly annotate kinds like that if you use the KindSignatures extension :)
05:14:40 <merijn> [exa]: My second example of "data Foo (m :: * -> *) = Foo" is perfectly fine with that extension
05:15:00 <joncol> [exa]: What's finger pattern?
05:15:46 <hackrilege> A rose tree?
05:15:49 <[exa]> joncol: reallocation prevention. E.g. if you append to a list, you need to reallocate everything, but if you change the beginning of the list, tail stays the same. Solution: reverse the list. Also applies to tree structures etc.
05:16:10 <merijn> [exa]: Or use a DList for appending :)
05:16:17 <[exa]> yep.
05:16:48 <hackrilege> Or a zipper...
05:16:51 <merijn> Or more generally, codensity transform :)
05:17:02 <hackrilege> ??
05:17:09 <merijn> hackrilege: Zippers don't automatically give you cheap appending
05:17:42 <hackrilege> If you use [[]] as your zipper it does
05:17:54 <merijn> codensity transformation is DList generalised to recursive data structures other than lists
05:18:05 <ph88> anyone know how i can get syntax highlighting in ghci ?
05:18:38 <[exa]> merijn: seems that annotation in data patterns solves it for me, thanks for consultation!
05:18:46 <merijn> [exa]: np :)
05:18:51 <tabaqui1> where can i find list of target platforms for compiling ghc
05:19:03 <tabaqui1> i want a cross-compiling actually
05:19:09 <[exa]> one more question, about naming
05:19:19 <tabaqui1> but cannot find how to pass windows amd64 in
05:19:28 <merijn> tabaqui1: Consult: https://ghc.haskell.org/trac/ghc/wiki/Platforms
05:19:49 <tabaqui1> merijn: thank you
05:19:50 <[exa]> if I have 'data X a b c  = Y a b | Z a c', the X is most correctly called a "type constant" and Y and Z are "data constructors", right?
05:20:11 <tabaqui1> why they cannot add a link from building and cross-compiling pages?
05:20:17 <gargawel> [exa]: X is a type constructor ;-)
05:20:38 <[exa]> so it is only 'type/data constructor'?
05:20:44 <merijn> [exa]: I would say X is a type constructor and Y and Z are data constructors
05:20:45 <gargawel> for every types a, b, c, "X a b c" is a type
05:20:58 <[exa]> I'm getting confused from THIH, they sometimes call something "type constants"
05:21:06 <gargawel> so you may see X as a function from types to types of "kind": * -> * -> * -> *
05:21:13 <merijn> [exa]: What's THIH?
05:21:20 <[exa]> Typing Haskell In Haskell
05:21:27 <merijn> [exa]: Oh
05:21:34 <hackrilege> We have type synonyms
05:21:38 <[exa]> implementing a type system and that's the only tangible material I've found
05:21:40 <merijn> [exa]: That's because when you *parse* a type constructor you treat it as a constant
05:21:43 <gargawel> Well, "X Int Int Int" would be a type constant
05:21:47 <gargawel> if you wish
05:21:54 <[exa]> oh so.
05:22:18 <[exa]> yay. makes a bit bit more sense now.
05:22:29 <gargawel> I don't know THIH, they may have a peculiar teminology that I don't know of, though
05:22:39 <exio4> @src (^)
05:22:40 <lambdabot> x ^ 0            = 1
05:22:40 <lambdabot> x ^ n | n > 0    = f x (n-1) x
05:22:40 <lambdabot>   where
05:22:40 <lambdabot>     f _ 0 y = y
05:22:40 <lambdabot>     f x n y = g x n
05:22:40 <merijn> [exa]: To your typechecker a type constructor is just an opaque label with a specific kind
05:22:42 <lambdabot> [3 @more lines]
05:22:58 <merijn> gargawel: I would say "X Int Int Int" is not a type constant, tbh
05:23:05 <merijn> It's simply a type
05:23:09 <sasd> what are some lambda calculus concepts that are good to know before learning FP?
05:23:17 <gargawel> Well, I've never heard of "type constants" before :D
05:23:27 <athan> simply typed lambda calculus sasd :)
05:23:35 <merijn> sasd: tbh, (untype) lambda calculus only has a few concepts, i.e. function application and abstraction :)
05:24:11 <merijn> gargawel: On the term level you tend to have constants, variables and expressions (which are basically built up from application of constants, variables and other expressions)
05:24:19 <sasd> reading https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus
05:24:39 <[exa]> sasd: Barendregt. :D
05:24:57 <sasd> by the way, which is harder? lambda calculus or FP? if the former, I might as well jump to FP
05:25:00 <merijn> gargawel, [exa]: Similarly you can consider the type level to consist of "type constants, type variables, and types" Where types are built out of applications of type constants, type variables and other types
05:25:55 <gargawel> merijn: Yes, I know. I was trying to make sense of what a "type constant" could be. I guess they call "type constants" built-in "atoms" such as Int or ()
05:26:07 <merijn> [exa]: During parsing you, usually, want to distinguish constants which are, like variables, atomic, but special in the sense that they are obviously *not* variables :)
05:26:17 <sasd> oh dear. I look at https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus. I am lost. this is hard
05:26:18 <implementation> sasd: FP and lambda calculus is two sides of the same coin ...
05:26:25 <gargawel> You may also call a closed term a constant...
05:26:26 <merijn> sasd: Wikipedia is notoriously terrible for this sorta thing
05:26:49 <sasd> no wonder it's been said that having haskell on the resume makes one look smart. 
05:26:55 <merijn> sasd: A good intro book to both lambda calculus AND types would be Types and Programming Languages, which your university library should have
05:26:58 <[exa]> sasd: you might want to specify where do you want to get, or what would you like to learn
05:27:09 <athan> lambdabot: Let's get some learnin!
05:27:23 <athan> @type 5 -- sasd
05:27:25 <lambdabot> Num t => t
05:27:37 <athan> @type 5 :: Int
05:27:40 <lambdabot> Int
05:27:46 <athan> > 5 + 1
05:27:49 <lambdabot>  6
05:27:55 <athan> @type 5 + 1
05:27:57 <lambdabot> Num a => a
05:28:04 <implementation> :k Num Int
05:28:05 <lambdabot> Constraint
05:28:17 <athan> @type (+)
05:28:19 <lambdabot> Num a => a -> a -> a
05:28:31 <sasd> can I just learn FP without knowing lambda calculus? Those symbols just scare me off
05:28:32 <athan> @type (+1)
05:28:34 <lambdabot> Num a => a -> a
05:28:46 <athan> sasd: You should check out the haskell book imo :)
05:28:53 <athan> from first principals
05:29:03 <athan> it's been very sucessful with people who don't have much bg
05:29:16 <[exa]> oh god, there are kinds of typeclasses.
05:29:28 <merijn> [exa]: :)
05:29:29 <athan> s/very/perty darn :v
05:29:32 <merijn> [exa]: Of course!
05:29:34 <liste> sasd: maybe a programmer-centric introduction could work? https://zeroturnaround.com/rebellabs/what-is-lambda-calculus-and-why-should-you-care/
05:29:43 <merijn> [exa]: "Monad :: (* -> *) -> Constaint" :)
05:29:45 <sasd> i know this is a haskell channel. May I ask if it is possible to learn FP using more conventional languages like python or javascript?
05:29:45 <implementation> sasd: of course you can. but it's the same concepts. If you understand Haskell, you understand lambda calculus. If you understand typed lambdas, you understand Haskell. The only real difference is the syntax.
05:29:55 <athan> [exa]: Wait until we get typeclasses of constraints >:D
05:30:18 <merijn> [exa]: The fact that typeclasses have kinds should make you happy! It's nice and consistent!
05:30:28 <implementation> :k Constraint
05:30:30 <lambdabot> *
05:30:40 <ph88> hey guys here on slide 6 http://www.slideshare.net/Rickasaurus/ghc-23201134 is a hoogle command, i try to put that in my .ghci file, but how do i use it correctly ?
05:30:44 <merijn> implementation: You're running afoul of TypeInType now :)
05:31:01 <merijn> implementation: Logically Constraint doesn't have a kind, it *is* a kind, like * is a kind
05:31:10 <athan> :k k => p :- k
05:31:13 <lambdabot> error: Not in scope: type variable ‘k’
05:31:13 <lambdabot> error: Not in scope: type variable ‘p’
05:31:15 <lambdabot> error:
05:31:15 <[exa]> sasd: well, question is basically if you're currently attendinf a computer-science-theoretic course on some university or not. if you are, you should have had some formal course of logic; Barendregt's book is a very good reading then. If not, "Learn yoursefl a haskell" (google) is a very gentle introduction imho.
05:31:17 <athan> :D
05:31:23 <implementation> merijn: I know, but I like this :)
05:31:25 <merijn> implementation: Traditionally the "kind" of a kind is called a Sort (of which GHC used to have exactly one, called BOX)
05:31:38 <merijn> So you'd have "* :: BOX" and "Constraint :: BOX"
05:31:40 * [exa] goes like 'NEIN'
05:32:00 <[exa]> I will only support singleparameter typeclasses. :D
05:32:16 <MarcelineVQ> ph88: have hoogle installed, generate the database for it, then you'd type in ghci :hoogle [a] -> Int
05:32:22 <[exa]> anyway, it's good to see how they implemented this stuff
05:32:29 <merijn> [exa]: tbh, multiparameter typeclasses aren't any messier
05:32:31 <sasd> i'm an engr. learning haskell as a hobby. the calculus I know deals with rate of change, not logic. 
05:32:58 <M2tias> sasd: yes, it's not lambdacalculus
05:33:00 <M2tias> +" "
05:33:05 <athan> sasd: it's logic actually
05:33:11 <merijn> [exa]: "Monad :: (* -> *) -> Constraint" whereas "MonadState :: * -> * -> Constraint"
05:33:13 <athan> it's a calculus - a system for caluclation
05:33:26 <athan> the one you were thinking of is the calculus of infinitesimals
05:33:28 <joehillen> [exa]: MultiparameterTypeclasses with FunctionalDependencies are super useful
05:33:43 <liste> sasd: the `calculus' with integrals etc is just one form of calculus that happened to be become "the" calculus
05:33:50 <[exa]> sasd: well, this deals with a change in computation
05:34:19 <[exa]> joehillen: any free example?
05:34:37 <athan> [exa] mtl lol
05:34:43 <athan> so not Free :V
05:35:59 <[exa]> ......... :] k
05:36:09 <ph88> MarcelineVQ, is the database only for the packages i have installed or for all the packages on stackage ?
05:36:29 <athan> Ooh here's a good one:
05:36:35 <MarcelineVQ> idk, you'd have to look at hoogle's docs
05:37:26 <MarcelineVQ> I would assume it's just base by default
05:37:26 <athan> class Does (p :: k -> Constraint) (a :: k) where; fulfill :: p a => ()
05:37:28 <athan> :D
05:37:53 <sasd> is it easy to find jobs with Haskell? Besides the proof that one is high intelligent.
05:37:59 <sasd> highly
05:38:10 <athan> return :: Does Monad m => m a
05:38:13 <jle`> btw, you don't need to be smart to use haskell :o
05:38:20 <ph88> i´m trying to color ghci and i found this command:   ghci 2>&1 | HsColour -tty    how can i do   stack ghci    with HsColour ?
05:38:29 <athan> sasd: I've been living out of my car for 2 years :|
05:38:32 <sasd> jle`: haha. don't be humble
05:38:33 <athan> I'm not that smart
05:38:34 <jle`> haskll actually gives yo the most benefit when you aren't smart.
05:38:47 <jle`> i program haskell because i am not smart enough to actually program a maintainble C++ database
05:38:48 <M2tias> jle`: Learn You a Haskell gets a bit tough at the end with Monads
05:38:51 <liste> sasd: not in general, the Haskell jobs seem to be in very specific areas
05:38:51 <jle`> s/database/codebase
05:38:56 <[exa]> sasd: it transforms the way you look at conventional programming languages; will force you to write oneliners and make all your C++ source compile for hours as a result of typesystem exploitation. :D
05:38:59 <sasd> anyone can learn imperative programming. FP, not many
05:39:07 <jle`> not sure if that's true
05:39:09 <M2tias> sasd: I highly doubt that
05:39:26 <liste> sasd: very specific niches*
05:39:26 <jle`> fp isn't any trickier than imperative... most people learn to think functionally naturally and have to be taught imperative thinking
05:39:29 <[exa]> sasd: you know FP from math classes. The trick of getting that to work imperatively is hard
05:39:57 <jle`> sasd: honestly, you have to be extremely smart to program maintainable codebases in imperative languages with implicit side-effects
05:40:07 <jle`> side-effects flying everywher eleft and right, how do you even keep track of anything
05:40:14 <merijn> jle`: Word
05:40:14 <jle`> you have to manage an entire complex network in your mind
05:40:24 <jle`> especially if there aren't any types, you basically have to act like a typechecker every time you do anything
05:40:28 <jle`> in haskell, you're free to be dumb
05:40:42 <jle`> you're free not not worry about implicit side effects coming from everywhere, and not to worry about keeping complex dependencies and types in your head
05:41:21 <jle`> i program haskell because i want to not have to be clever
05:41:45 <jle`> not have to be a genius to write maintainable code
05:42:27 <ph88^> i'm trying ghci with HsColour but it's acting weird https://paste.fedoraproject.org/460654/99301147/  how can i get it to work correctly ?
05:42:43 <joehillen> jle`: preach it!
05:44:45 <merijn> jle`: I program haskell because I want my cleverness to only occasionally be required :p
05:45:02 <jle`> :p
05:45:51 <jle`> programming in any imperative language feels like a time bomb
05:46:00 <jle`> haskell is so much less stressful
05:46:32 <jle`> haskell is a language i can program at 3am
05:46:39 <tdammers> haskell is really the easiest programming language under my belt
05:46:43 <merijn> jle`: While drunk!
05:46:47 <jle`> mhm, lol
05:46:50 <sasd> jle`: to be honest, one reason I'm learning haskell is to prove to others I'm smart. ironic you're telling the opposite
05:47:03 <jle`> ironic that people would think you are smart for knowing haskell!
05:47:06 <tdammers> and that is not sarcasm
05:47:16 <merijn> People who wanna look smart masochistically claim that writin C++ is the only way to do things :)
05:47:22 <sham1> People think you are smart for knowing haskell because it is so "complex"
05:47:39 <sham1> To be fair, everything is complex when your paradigm is completely different, so...
05:47:42 <tdammers> people think you are smart because statistically speaking, "knows haskell" and "seems smart" correlate
05:47:56 <tdammers> sham1: no, everything is difficult when your paradigm is different
05:48:07 <jle`> maybe it's because people who are smart learn easier languages becuase they know how to get the job done
05:48:10 <tdammers> sham1: but because easy /= simple, difficult /= complex
05:48:13 <sham1> Also, academic language makes people see the correlation between smarts and usage
05:48:39 <sham1> They are not equal
05:48:46 <sham1> But there are people who will say that they are equal
05:49:23 <tdammers> I believe the correlation is easily explained because people who are not smart are generally more inclined to solve problems through boring repetitive manual labor; when you're not very intelligent, or not a good abstract thinker, that is in fact the best strategy
05:49:25 <sham1> Is there acually a language where you actually have to be smart to be able to code with it
05:49:28 <athan> I casually get blitzed on the marijuanas and stomp on my keyboard in this weird ritual, but out comes glorious software somehow
05:49:31 <[exa]> Anyway, the thing with Constraint kind and so, are there some reasonable constraints that prevent the resulting system from becoming calculus of constructions?
05:49:52 <tdammers> and as long as that is how you can be the most effective/efficient, learning a tool like haskell doesn't make much sense
05:50:05 <tdammers> sham1: malbolge
05:50:07 <merijn> [exa]: Yes, no types depending on terms :)
05:50:24 <athan> [exa]: I think sysemFC_pro abuses coercions a lot
05:50:32 <athan> so it can get away without totality and stuff
05:50:35 <tdammers> sham1: and, arguably, PHP, but the intersection of "people smart enough to code in it" and "people who enjoy coding in it" is pretty much empty
05:50:36 <athan> but I honestly have no idea
05:51:17 <jle`> you have to be smart to code php properly probably
05:51:28 <jle`> assembly
05:51:28 <athan> I hope DataKinds gets _full_ promotion across a codebase though
05:51:44 <jle`> C/C++ too once you get past simple programs and have to maintain them
05:51:49 <athan> so I can evaluate a Show 1 type into a typelit string! :D
05:51:55 <sham1> C has a lot of verbosity
05:52:03 <sham1> A LOT of verbosity
05:52:27 <athan> javascript pretends like it's sane
05:52:34 <sham1> You know what they say, C brings the portability of assembly with the readability of assembly
05:52:39 <[exa]> merijn: oh so Thanks!
05:52:45 <athan> that's basically its only job
05:53:51 <merijn> [exa]: Tbh, by the time you write code that makes you ask questions like this it's often much simpler to just write your code in a dependently typed language directly >.>
05:55:09 <[exa]> merijn: yep
05:55:39 <tdammers> you have to be very smart to write code in PHP in a somewhat responsible fashion
05:55:44 <tdammers> which is why nobody does it
05:56:12 <[exa]> ....ever seen perl?
05:56:22 * [exa] ducks
05:57:55 <tdammers> perl looks ugly, but other than that, it looks like par-for-the-course, at least within its intended niche
05:58:23 <tdammers> I have no particular grudge against perl
06:01:14 <[exa]> tdammers: from this perspective the ugliness seems like a positive language feature; you can do even worse stuff in Perl than in PHP, but it's so ugly that only responsible people care to learn&use it.
06:01:28 <[exa]> nevermind. :D
06:05:12 <phanimahesh> hahahah. that's a good way to put it.
06:07:21 <sham1> Perl and PHP are great ways to make yourself irreplecable
06:09:50 <danilo2> Hello guys! What is the difference between Proxy and Proxy# ?
06:10:16 <jle`> Proxy a has two inhabitants for any 'a', but Proxy# has only one
06:10:50 <sham1> I thought you were going to say that the other one has a number sign on it
06:12:14 <[exa]> oh my, data constructors can be partially applied.
06:12:30 <opqdonut> [exa]: they're just functions
06:12:49 <danilo2> jle`: What do you mean by inhabitans here?
06:12:54 <opqdonut> danilo2: values
06:13:00 <cocreature> values of that type
06:13:02 <[exa]> best way to realize things the hard way is to implement them
06:13:08 <jle`> danilo2: if i have a value of type 'Proxy Int', it can be 'Proxy' or _|_
06:13:09 <phanimahesh> [exa]: What's the point of not being able to apply them partially?
06:13:20 <jle`> danilo2: but _|_ is not an inhabitant of Proxy# Int
06:13:35 <danilo2> jle`: ah, perfect! Thanks for the clarification!
06:13:35 <jle`> danilo2: well, my answer is actually slightly facetious, sorry
06:13:48 <danilo2> jle`: now its perfect clear, thank you!
06:13:57 <jle`> danilo2: because Proxy can be _|_, it needs a runtime representation
06:14:10 <jle`> so Proxy Int has to be carried around at runtime
06:14:16 <jle`> but Proxy# doesn't have to have one
06:14:17 <[exa]> anyway, I understand why the type constructors need to be differentiated from type variables by Capital letter, is that the same for classes (that are used in a syntactically predicable manner)?
06:14:31 <[exa]> (also for data constructors)
06:14:32 <jle`> Proxy# has no runtime representation or overhead
06:14:43 <danilo2> jle`: very interesting. I thought Proxy would be cut down during compilation
06:14:55 <jle`> semantically, it can't be
06:15:05 <jle`> because there are two inhabitants, and you need to be able to distinguish between the two
06:15:14 <danilo2> jle`: youre right, I just didnt though about it
06:16:12 <merijn> [exa]: Generally you don't actually need to distinguish type variables lexically, but it's easier to read for humans
06:19:23 <[exa]> merijn: ok, thanks
06:37:47 <ongy> is there a reason to use Proxy over Proxy# then?
06:40:36 <danilo2> ongy: I think the new way is not to use proxy anywhere ant use AmbiguousTypes together with the @ syntax
06:44:17 <nshepperd1> Proxy can still be eliminated like any other constructor when inlined
06:46:20 <nshepperd1> Like (case Proxy of Proxy -> foo) = foo, if i understand how ghc does such things
06:46:47 <tdammers> and otherwise, a RULE would also take care of it
06:47:37 <infandum> Is anyone familiar with haskellr? Why does running "sequence $ (\a b -> [r| cor.test(a_hs, b_hs) |]) <$> xs <*> ys" result in a stack protection overflow for the R side of things? Isn't it all on a single thread?
06:48:06 <infandum> for large xs ys
06:48:39 <ab9rf> probably too many thunks on the stack
06:48:57 <infandum> but it's an R exception, not a haskell one
06:49:03 <ab9rf> hm, dunno then
06:49:18 <infandum> oh, maybe it's that too many R processes (unevaluated) were started?
06:49:28 <ab9rf> maybe
06:49:31 <nshepperd1> I don't think I'd use Proxy# normally. Because it's unboxed it won't unify with (a :: *)
06:49:34 <infandum> I wonder how to do it then
06:49:43 <infandum> is there a strict version of that?
06:50:03 <nshepperd1> :k Proxy#
06:50:05 <lambdabot> error:
06:50:05 <lambdabot>     Not in scope: type constructor or class ‘Proxy#’
06:50:05 <lambdabot>     Perhaps you meant ‘Proxy’ (imported from Data.Typeable)
06:50:11 <nshepperd1> Aw
06:51:18 <ab9rf> infandum: it's possible that it's creating thunks containing partially evaluated R invocations and there are too many of them
06:51:28 <infandum> possibly
06:51:43 <infandum> ab9rf: Is there a way to evaluate one before the next?
06:51:48 <infandum> >>= style
06:51:52 <ab9rf> i have no idea how r-inline expands the [r|...|] structure
06:51:58 <infandum> nor do I :(
06:54:04 <ab9rf> i found it
06:54:29 <infandum> what are they doing?
06:54:36 <ab9rf> converts the R stttement to a parse tree, and then applies the parse tree to the arguments
06:56:26 <infandum> hmm
06:57:58 <infandum> ab9rf: On their page, they have rexp which doesn't evaluate https://tweag.github.io/HaskellR/docs/evaluating-r-expressions.html
06:58:15 <infandum> I want to maybe try that but it appears to be missing in H
07:00:04 <ab9rf> the other possibility is that the R code is generating too much output 
07:00:12 <ab9rf> R values are pinned in R's heap until GHC releases them
07:01:01 <ab9rf> you may need to do something to transform the values generated by the R code into objects that are native to GHC's heap so that GHC releases them and lets R's GC collect them
07:01:20 <infandum> ab9rf: It *shouldn't*, maybe, I dunno. I'm using that code where xs and ys are random lists of lists, so each one has 10000 random lists of length 40
07:01:51 <ab9rf> infandum: i'm just guessing based on reading the docs on github
07:02:06 <infandum> mhm
07:02:43 <infandum> ab9rf: So wouldn't a strict evaluation of each element, like a loop, solve the problem?
07:03:30 <mantovani> What that function in haskell that you put a pattern and the how many times you want to apply it ?
07:03:56 <mantovani> like: 2,4,6,8
07:04:04 <infandum> ?
07:04:05 <jle`> you could write one
07:04:09 <mantovani> I know
07:04:14 <mantovani> I want to show to a friend this function
07:04:17 <mantovani> is in the haskell core
07:04:23 <mantovani> I used many times but I don't remember the time now
07:04:31 <infandum> iterate?
07:04:31 <mantovani> it is in the real world haskell
07:04:55 <mantovani> yes!
07:04:56 <mantovani> thank you
07:05:01 <infandum> :t iterate
07:05:02 <lambdabot> (a -> a) -> a -> [a]
07:05:05 <StoneToad> one of the enumFromTo functions?
07:05:19 <mantovani> no
07:05:22 <mantovani> is another one
07:06:18 <jle`> > take 4 (iterate (*2) 2)
07:06:20 <lambdabot>  [2,4,8,16]
07:06:25 <jle`> > take 4 (iterate (+2) 2)
07:06:27 <lambdabot>  [2,4,6,8]
07:07:00 <mantovani> you don't put the pattern function, you put the pattern numbers and it create "generate the function" and return the next ones
07:07:14 <amx> you don't mean list comprehensions?
07:07:35 <mantovani> let me see it, 4 yers without write a single line of haskell
07:07:38 <mantovani> without*
07:08:35 <amx> > [2,4..]
07:08:37 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
07:09:09 <jle`> > [2,4..10]
07:09:11 <lambdabot>  [2,4,6,8,10]
07:09:14 <mantovani> yes
07:09:32 <mantovani> thank you
07:11:32 <infandum> [100,71,..0]
07:11:41 <infandum> wha
07:11:43 <liste> > [100,71,..0]
07:11:46 <lambdabot>  <hint>:1:9: error: parse error on input ‘..’
07:11:51 <liste> > [100,71..0]
07:11:53 <infandum> [100,71..0]
07:11:54 <lambdabot>  [100,71,42,13]
07:11:54 <infandum> hehe
07:12:02 <infandum> I do that way too often for my own good
07:13:04 <NextHendrix> [2,4,8..256]
07:14:58 <jle`> it doesn't infer patterns in general
07:15:10 <jle`> it just uses the difference between the first two numbers :o
07:18:55 <ab9rf> it's only limitedly clever :)
07:19:44 <ab9rf> it's not like it looks up the sequence so far at OEIS and uses the best match theer
07:21:36 <ab9rf> there is, however, the oeis package, which will do that for you :)
07:21:51 <liste> does it have an offline copy of OEIS
07:22:12 <ab9rf> i doubt it
07:22:42 <ab9rf> there's also the issue that a lot of the sequences at OEIS are known to only a few elements
07:22:52 <ab9rf> or are exceedingly expensive to compute
07:25:17 <et09> how should a Just a / Nothing case be handled?
07:25:18 <c_wraith> Heh.  does OEIS have the busy beaver function?
07:25:21 <et09> abstractly]
07:25:39 <jophish> c_wraith: https://oeis.org/A028444
07:25:59 <ab9rf> yes, but only to five elements
07:26:13 <c_wraith> et09: depends on context.  Sometimes via functor/applicative/monadic interfaces, sometimes with helpers like maybe, sometimes with a case expression...
07:26:44 <et09> i'm trying to read from a stream and handle the possible outcomes
07:26:53 <c_wraith> et09: heck, sometimes with the Foldable interface..  traverse_ is kind of awesome with Maybe values
07:27:26 <et09> there are three...segment termination from the stream (which means a hand off and a continued parsing), segment continuation, and stream termination
07:27:53 * hackagebot configurator-ng 0.0.0.0 - The next generation of configuration management  https://hackage.haskell.org/package/configurator-ng-0.0.0.0 (LeonSmith)
07:28:12 <Cale> et09: With regard to your question just before, you know about case expressions right?
07:28:38 <Cale> case ... of Nothing -> ...; Just x -> ...
07:28:55 <et09> well, in every other language, yes
07:29:08 <Cale> ah, okay
07:29:32 <Cale> Well, in Haskell, they let you pattern match on the various possibilities for an expression
07:29:39 <et09> beautiful 
07:38:53 <tsahyt> with regards to all the "never use String" stuff, is FilePath still the right type to use for file paths?
07:39:18 <c_wraith> tsahyt: "never use String" is bad advice.
07:39:47 <tdammers> there is no right type to use for file paths
07:39:57 <tdammers> "file path" is an ill-defined contradictory concept
07:40:00 <EvanR> use FilePath until they fix it
07:40:02 <tsahyt> then FilePath it is
07:40:06 <c_wraith> tsahyt: despite that, FilePath is a bad type for file paths.  It assumes there's a standardized mapping from unicode to file paths, and that all file paths can be represented with unicode.  both of those are wrong.
07:40:13 <tdammers> at least FilePath signals programmer intent
07:40:32 <EvanR> when they fix it, itll still be called FilePath and youll be in like jim
07:40:36 <EvanR> (wishful thinking)
07:41:02 <tdammers> when they fix it, and it's still called FilePath and a type synonym but now for something that isn't String, your entire codebase will blow up
07:41:27 <tdammers> but again, there is no correct type for file paths
07:41:28 <EvanR> if you treat it like a String definitely
07:41:50 <EvanR> dont do that
07:41:54 <__monty__> c_wraith: Can you give an example of file paths that can't be represented with unicode?
07:42:26 <EvanR> path to these japanese songs here whose filenames are encoded in shift-jis
07:42:35 <c_wraith> __monty__: unix filepaths can be any sequence of bytes tthat is terminated with \0
07:43:11 <tdammers> in that sense, ByteString would be a better representation than String or Text
07:43:13 <c_wraith> __monty__: There's no reason that sequence of bytes has to mean anything semantically like characters at all
07:43:18 <tdammers> but then, some other filesystems *do* use Unicode
07:43:44 <EvanR> tdammers: abstract FilePath proposal so the representation could use ByteString or whatever behind the scenes
07:44:04 <EvanR> for performance
07:44:19 <tsahyt> talking about ByteString, is Text or ByteString more appropriate for processing of source code?
07:44:30 <jophish> tsahyt: depends on what source code
07:44:34 <tdammers> tsahyt: depends on the language
07:44:38 <tsahyt> jophish: answer set programming
07:44:52 <c_wraith> tsahyt: for reading from disk, bytestring.  For processing, however the language is defined.
07:45:07 <c_wraith> tsahyt: Is the language defined in terms of characters or bytes?
07:45:26 <tsahyt> characters, it's a human readable language
07:45:30 <c_wraith> tsahyt: and if it's defined in terms of characters, is an encoding to bytes specified, or are you going to have to guess?
07:45:45 <c_wraith> that doesn't mean it's not defined in terms of bytes.
07:45:58 <c_wraith> Things like C are defined in terms of bytes, not characters.
07:46:00 <et09> http://lpaste.net/5013756787682181120 this is giving me " • Couldn't match expected type ‘IO ()’ with actual type ‘()’
07:46:03 <et09> on line 41
07:46:18 <et09> not sure what the mistake is
07:46:23 <jle`> et09: each of the cases returns an IO action
07:46:26 <jle`> () is not an IO action
07:46:33 <jle`> you probably want a no-op IO action that returns ()
07:46:35 <joehillen> et09: return ()
07:46:39 <jle`> in which case, you can use "return ()"
07:46:46 <et09> ah
07:46:53 <jle`> 'return x' is a no-op IO action whose result is just x
07:47:02 <et09> interesting
07:47:07 <c_wraith> :t return
07:47:09 <lambdabot> Monad m => a -> m a
07:47:15 <jle`> return is provided by the IO type to let you describe IO no-ops :)
07:47:19 <c_wraith> Note that return isn't a keyword, like many languages.  It's just a function.
07:47:31 <c_wraith> And it doesn't do control flow.  It just does value wrapping
07:47:36 <tsahyt> c_wraith: is defined over an alphabet of ascii characters not equivalent to defined as bytes?
07:47:38 <et09> my question to myself this morning was 'are monads functions', and i decided yes 
07:47:45 <et09> is that wrong
07:47:52 <EvanR> :k Monad
07:47:53 <c_wraith> et09: Monads are not functions.
07:47:53 <lambdabot> (* -> *) -> Constraint
07:48:03 <et09> alright
07:48:07 <c_wraith> et09: a Monad is a type
07:48:27 <tsahyt> I thought it was a typeclass
07:48:30 <c_wraith> et09: IO is a monad.  IO is a type that happens to support a particular interface.  But the instance is the type, not the value.
07:48:41 <c_wraith> Err, not *any* value.
07:49:02 <jle`> well, monads are functors, so they are functions in a loose sense.  but definitely not in a Haskell sense
07:49:10 <c_wraith> tsahyt: a typeclass is just a predicate on types.  A type is either part of the type class, or it isn't.
07:49:24 <EvanR> lets not get even looser ;)
07:49:35 <__monty__> tsahyt: ASCII carries semantics while bytes don't necessarily carry the same semantics.
07:49:36 <et09> now i have: main.hs:42:45: error: • Couldn't match expected type ‘x’ with actual type ‘BSC.ByteString’
07:50:06 <et09> ‘x’ is a rigid type variable bound by an expression type signature: forall x. x at main.hs:42:54
07:50:08 <tsahyt> __monty__: all I want is provide an interface to a C function that takes strings
07:50:13 <c_wraith> et09: Haskell's type system doesn't do type variables.
07:50:14 <tsahyt> which represent source code
07:50:19 <jle`> et09: what do you think (accum :: x) does?
07:50:20 <c_wraith> et09: err, doesn't do subtyping
07:50:21 <joehillen> et09: your "otherwise" case there is impossible
07:50:45 <c_wraith> et09: If you specify a type variable, it means "any type"
07:50:53 <c_wraith> et09: "and the *caller* gets to choose"
07:50:56 <et09> the idea was to concatenate accum with x
07:51:07 <et09> in the case where x is "just something" but not "just termchar"
07:51:07 <c_wraith> Oh, then you don't want ""
07:51:09 <c_wraith> err. ::
07:51:11 <c_wraith> I can't type
07:51:26 <c_wraith> That's an ml-ism
07:51:33 <jle`> et09: what is the concatenation function you want to use?
07:51:33 <c_wraith> You have ml experience by any chance?
07:51:40 <jle`> whatever it is, it's not named "::"
07:51:44 <et09> idk.. ++ ?
07:51:45 <et09> i forgot
07:51:50 <c_wraith> :t (++)
07:51:50 <jle`> et09: we can't answer that :D
07:51:52 <lambdabot> [a] -> [a] -> [a]
07:51:52 <c_wraith> :t (:)
07:51:54 <lambdabot> a -> [a] -> [a]
07:51:57 <joehillen> There are no other possible results for "x" than "Just termchar" and "Nothing"
07:52:00 <jle`> et09: look up the API/docs of that type you are using
07:52:32 <jle`> it probably has a name, but that name is not (::)
07:53:35 <et09> how do i unwrap the just then 
07:53:44 <__monty__> tsahyt: Well, I can't really be of help but Foreign.C.String sounds like what you need.
07:53:47 <ab9rf> pattern match
07:53:53 <joehillen> et09: also, "otherwise" is only a keyword for guards. You don't use it in case statements
07:54:15 <Xsavior> Hi. I'm wondering if Monads are used to hide the type of something you passing to a function. In other words: wrap some value in a function (aka a monadic value) and then wrapping that monadic value in a function. Does that now allow you to pass that value to any function that can accept as an argument: a function that returns a function. Is that the point of Monads? To pass any value to functions that accept: functions that 
07:54:15 <Xsavior> return functions? I'm trying to understand the point of the Monad. 
07:54:22 <jle`> et09: joehillen is saying that you only need two branches, Just termchar -> and Nothing ->
07:54:30 <tsahyt> __monty__: I don't think plain String is the best way to represent source code though. I want to provide a decent representation to the user of the library after all
07:54:42 <jle`> Xsavior: that is definitely not the point of any monad i know
07:54:52 <et09> that doesn't sound right jle` .  termchar is the termination character
07:55:08 <Xsavior> jle`: oh. ok. thanks for the answer.
07:55:13 <ab9rf> Xsavior: monads are not about hiding types
07:55:14 <et09> there are other characters read from the stream that aren't Nothing 
07:55:33 <et09> or technically i think it's reading single char ByteStrings
07:55:37 <jle`> et09: 'termchar' is a type variable there
07:55:40 <joehillen> et09: notice that you're not using "termchar" in your "Just" branch
07:55:42 <jle`> er, a pattern variable
07:55:42 <ab9rf> Xsavior: in haskell, not all functions are of the same "type"
07:55:43 <__monty__> tsahyt: Yeah you're right the user facing side probably should be something different. What does your library do?
07:55:51 <ab9rf> a function that returns an int is not the same type as a function that returns a char
07:55:53 <jle`> et09: 'Just termchar -> ' matches on any input
07:55:58 <Xsavior> ab9rf: I'm glad I got that bad thinking cleared up.
07:56:00 <et09> oh.  yikes
07:56:07 <kadoban> Xsavior: Monad is just a pattern that comes up in quite a few places. I'd just memorize the types of (>>=) and return, and then use a few of them practically for a while. Eventually any mystery will disappear.
07:56:09 <tsahyt> __monty__: wraps the API to an answer set solver. this particular part allows loading of programs into the solver.
07:56:10 <jle`> > (\x -> case x of Just termchar -> termchar*2) (Just 10)
07:56:12 <jle`> ^ et09 
07:56:12 <lambdabot>  20
07:56:24 <EvanR> Xsavior: note that functions can return functions normally, no monads necessary
07:56:27 <et09> yeah got it.  but then how do i test against termchar
07:56:30 <jle`> > (\x -> case x of Just foobarbaz -> foobarbaz*2) (Just 10)
07:56:32 <lambdabot>  20
07:56:42 <jle`> et09: your library might have a predicate
07:56:44 <jle`> isTermChar
07:56:49 <jle`> your you can use == ?
07:56:52 <jle`> s/your/or
07:57:16 <joehillen> case is fine too
07:57:16 <Xsavior> kadoban: EvanR ab9rf jle` thanks 
07:57:27 <__monty__> tsahyt: Sounds like a DSL'd be the most agreeable interface.
07:57:48 <jle`> case x of Just c | isTermChar c -> ...
07:58:00 <jle`>                    otherwise -> ...
07:58:05 <jle`> * | otherwise
07:58:16 <tsahyt> __monty__: it'd certainly be worth consideration. I think there's another function which takes an AST for that.
07:58:25 <et09> what about the Nothing (or the non-term chars)
07:58:36 <tsahyt> but I also want to be able to pass plain source code, which might be loaded from disk
07:59:45 <infandum> With the foldl library, how can I have "sink" combine with "list" to ultimately have ((a -> m b) -> [a] -> m [b])?
08:00:00 <jle`> et09: you can also have Nothing as another case
08:00:16 <jle`> Just c | isTermChar c -> ... | otherwise -> ...; Nothing -> ...
08:01:41 <__monty__> tsahyt: For loaded source code I think string is fine unless you want to provide functions to alter it.
08:02:10 <et09> are those guards?  
08:02:20 <joehillen> jle`: you should put that in an lpaste. it's confusing on one line
08:02:22 <jle`> infandum: er, what are you expecting to use the foldl library for?
08:02:37 <infandum> jle`: A strict map
08:02:40 <jle`> infandum: because you can just use traverse/mapM for that
08:02:41 <infandum> mapM
08:02:54 * hackagebot http-client 0.5.3.3 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.3.3 (MichaelSnoyman)
08:03:09 <infandum> jle`: yeah, but there are no strict versions of those that I saw
08:03:12 <jle`> you don't need the foldl library to have (a -> m b) -> [a] -> m [b]
08:03:31 <jle`> what do you expect from a strict mapM ?
08:03:33 <mizu_no_oto_work>  infandum: why do you want a strict map function?
08:03:36 <jle`> what does that mean?
08:03:44 <infandum> mizu_no_oto_work: My issue above
08:03:47 <infandum> way above
08:03:55 <infandum> the many many [r| |]'s
08:04:10 <infandum> I want to evaluate each one
08:04:14 <jle`> not sure how the foldl library would help you there
08:04:17 <infandum> rather than build them all up
08:04:35 <infandum> It was worth a shot
08:04:43 <infandum> as nothing else is working haha
08:07:26 <et09> http://lpaste.net/5013756787682181120  ok, now this gives me: main.hs:52:24: error: • Couldn't match expected type ‘IO a0’ with actual type ‘BSC.ByteString -> IO ()’ • Probable cause: ‘BSC.hPutStrLn’ is applied to too few argum
08:08:33 <kadoban> et09: It probably is? What arguments is hPutStrLn supposed to take? I would imagine at least a handle and a bytestring
08:08:37 <et09> i look at the fn type there, it's hPutStrLn :: Handle -> ByteString -> IO ()
08:08:47 <et09> what is a handle :-O
08:09:05 <kadoban> et09: You probably don't want hPutStrLn. There should be a putStrLn, no?
08:09:10 <EvanR> access to files and sockets goes through handles
08:09:16 <et09> oh.  sheesh
08:09:17 <et09> ok
08:09:20 <infandum> jle`: Just curious, why do you think it wouldn't work?
08:09:21 <et09> yup
08:09:28 <jle`> if you want to print to stdout, you can just use putStrLn
08:09:33 <jle`> or you can use hPutStrLn stdout i think
08:09:39 <EvanR> stdout :: Handle
08:09:48 <EvanR> putStrLn = hPutStrLn stdout
08:09:49 <jle`> infandum: because foldl doesn't have anything to do with strict mapM's ?
08:09:54 <kadoban> A handle is how you choose where you're writing to (stdout, stderr, a file, whatever)
08:09:59 <jle`> they're unrelated subjects, heh
08:10:09 <jle`> infandum: you might as well ask if foldl would help you with solving sudoku
08:10:33 <jle`> i'm not even sure what a strict mapM would entail
08:10:34 <infandum> jle`: Well I imagined it as a strict fold, then I noticed that foldl HAS a list FoldM so I figured hey, that could work
08:11:11 <EvanR> it seems weird to directly associate folds with maps
08:11:21 <EvanR> sure one can be implemented with the other, but thats not what it is
08:11:25 <et09> (omg i think it works)
08:11:29 <infandum> EvanR: yeah, but again there are no strict maps
08:11:29 <infandum> mapMs
08:11:31 <infandum> I mean
08:11:47 <EvanR> > map undefined
08:11:50 <lambdabot>  error:
08:11:50 <lambdabot>      • No instance for (Typeable a0)
08:11:51 <lambdabot>          arising from a use of ‘show_M554424180997661056425565’
08:11:53 <jle`> it's not even clear what you would expect from a strict mapM
08:12:03 <jle`> infandum: maybe you want the monad to be stricter?
08:12:04 <EvanR> guess not
08:13:00 <infandum> I wouldn't know how to do that
08:13:18 <jle`> it'd be an issue of the monad you're talking about, not with mapM per se
08:13:30 <jle`> mapM has no say in the strictness properties of your monad instance
08:13:41 <jle`> that's up to the monad and how it implements bind
08:14:01 <infandum> :/
08:14:04 <EvanR> it seems funny that lazy is the opposite of strict, though they arent in the same universe of discourse... but its embedded in all our stuff, strict fields, lazy fields, strict Map, lazy Map
08:14:05 <infandum> oh
08:14:32 <EvanR> strict monads, lazy monads
08:15:01 <EvanR> even strict I/O, lazy I/O (getting more abusive here)
08:15:13 <infandum> so I'm out of luck it seems
08:15:20 <infandum> that's weird though, I should be limited by this
08:15:39 <infandum> why wouldn't I be able to run a million computations?
08:15:39 <infandum> grah
08:15:43 <EvanR> huh?
08:15:46 <Kuros> is eager evaluation the same as strict evaluation?
08:15:56 <EvanR> theres no strict evaluation
08:16:06 <nshepperd> call-by-value
08:16:09 <jle`> infandum: you could write a mapM for your specific monad that took advantage of your monad's API
08:16:18 <jle`> that is "stricter", maybe
08:16:22 <jle`> depending on what you mean
08:16:28 <infandum> jle`: The monad is way above my level, but I could check it out
08:17:02 <jle`> infandum: the monad might offer an API/functions to control execution
08:17:31 <Kuros> hm https://en.wikipedia.org/wiki/Lazy_evaluation says "The opposite of lazy evaluation is eager evaluation, sometimes known as strict evaluation"
08:17:40 <EvanR> thanks wikipedia
08:17:59 <Kuros> :I
08:18:09 <EvanR> the more i know, the wronger wikipedia gets! :D
08:18:27 <Kuros> yeah i can imagine
08:19:17 <nshepperd> wikipedia seems pretty accurate there?
08:19:29 <EvanR> a function is strict if necessarily f ⊥ = ⊥
08:19:37 <nshepperd> it is sometimes known as strict evaluation
08:19:44 <nshepperd> even if that terminology is wrong
08:19:57 <EvanR> i guess so
08:20:31 <jle`> 'wrong'
08:20:59 <EvanR> that terminology may explain the preponderance of stuff called strict in haskell
08:21:34 <EvanR> well here we are wondering what strict mapM means 
08:22:16 <nshepperd> all that stuff called strict in haskell is pretty much 'correct' usage of the term though
08:22:54 <EvanR> strict Map as opposed to lazy Map ?
08:23:10 <nshepperd> 'data Foo = Foo !Int' → 'Foo ⊥ = ⊥' → 'first field of Foo is strict'
08:23:24 <EvanR> strict ByteString
08:23:48 <nshepperd> Map.insert k ⊥ mp = ⊥
08:23:51 <EvanR> IO is a strict monad
08:24:28 <fbergmann> 1/exit
08:24:30 <EvanR> non lazy I/O is strict
08:24:59 <nshepperd> ByteString.pack (replicate 100000 'a' ++ ⊥) = ⊥
08:24:59 <EvanR> as in strict package
08:25:04 <johnw> what does it mean for IO to be strict?  What is the 'f' in question, such that f ⊥ = ⊥?
08:25:28 <EvanR> ⊥ >>= f i guess
08:25:42 <johnw> return ⊥ = ⊥?
08:25:54 <EvanR> > return undefined :: IO Int
08:25:57 <lambdabot>  <IO Int>
08:26:00 <EvanR> baw
08:26:03 <johnw> for it to be a "strict monad", I think both would need to be strict
08:26:31 <EvanR> thus, IO is non strict!
08:26:41 <johnw> rather, I think strictness applies to functions, not to type formers
08:27:09 <EvanR> that be more predictable terminology
08:27:55 * hackagebot feed-gipeda 0.3.0.0 - CI service around gipeda  https://hackage.haskell.org/package/feed-gipeda-0.3.0.0 (sgraf812)
08:31:57 <nshepperd> ⊥ >>= f = ⊥ seems closer to what is usually meant by 'strict' in a monad, but not sure
08:33:05 <grazie> what exactly is happening in this func (see image) when return (x:xs) happens (versus return []) http://imgur.com/a/Fo9UZ
08:33:28 <grazie> is return (x:xs) necessary for the recursion or is it necessary for what?
08:33:58 <grazie> similarily, why is return [] used when x is the newline?
08:34:06 <nshepperd> usually the fun is with lazy monads, which let you do something useful with a monadic value before you've evaluated the whole tree of binds
08:34:09 <nitrix> > don't $ do { putStrLn "Hello World!" }
08:34:11 <lambdabot>  <IO ()>
08:34:32 <nitrix> I'm having so much fun looking at the acme packages :3
08:34:51 <nitrix> Kudos to safeCoerce :: a -> Maybe b and safePerformIO :: IO a -> Maybe (IO ())
08:35:04 <EvanR> lol
08:35:19 <sham1> "safePerformIO"
08:35:29 <sham1> So just a normal IO computation
08:35:32 <nitrix> safePerformIO = Just . don't
08:35:40 <phadej> I have still to write a patch to acme-php
08:35:50 <phadej> haven't found time yet :(
08:35:53 <tom7942> grazie: return wraps your value in the IO monad
08:35:55 <tom7942> :t return
08:35:56 <lambdabot> Monad m => a -> m a
08:36:26 <tom7942> getChar :: IO String
08:36:34 <grazie> tom7942: ok, but why does it need to return (x:xs) in one case, but return () in the other?
08:36:56 <phadej> ah, it was https://github.com/Bodigrim/acme-php-types
08:37:02 <sham1>  Actually
08:37:11 <tom7942> err getChar :: IO Char
08:37:22 <sham1> return just wraps any value into any Monad
08:37:31 <nitrix> phadej: "types".
08:37:36 <delYsid> pure
08:37:42 <tom7942> grazie: you're going to get a character, and if it's a newline, return IO empty list
08:38:02 <sham1> pure it is
08:38:07 <tom7942> else, get a string, and return the character you got and the string appended
08:38:08 <phadej> nitrix: :) well, we do that kind of stuff for eDSLs ;)
08:38:23 <grazie> ok, thank you tom7942
08:38:57 <EvanR> grazie: do you mean return [] ?
08:39:04 <nitrix> It bothers me how how they are trying to hard to make their unified type system glorified. They built this gigantic dynamic classification and pretend they're types :(
08:39:05 <tabaqui1> merijn: so, you're among the ghc developers?
08:39:27 <grazie> EvanR: it wasn't clear to me why it's return () in one case and return (x:xs) in the other? What is the final return? http://imgur.com/a/Fo9UZ
08:39:41 <EvanR> grazie: yeah thats [] not ()
08:39:45 <EvanR> square brackets
08:39:49 <EvanR> sharp corners there
08:39:55 <EvanR> its blurry in the picture
08:40:00 <grazie> yeah, sorry about that
08:40:08 <voldyman> why does haskell prefer commas on new lines? couldn't find it anywhere
08:40:08 <grazie> but it's clearer now thanks to what Tom said
08:40:22 <sham1> Umn, who is making you create your own getLine
08:40:45 <grazie> sham1 it's a book for learning haskell, just a demo (I think)
08:41:22 <EvanR> grazie: its a recursive function, which means you can read each case in isolation to understand what it would do hypothetically (if you getLine and they typed nothing but enter, the result is [] (empty string)) but also it makes sense as a base case of the recursion
08:42:22 <grazie> EvanR: I was having trouble understanding the relationship of the return (x:xs) to the recursion...for example, was the return (x:xs) necessary for the recursion to take place, or is the return (x:xs) the final result?
08:42:34 <EvanR> its the "final result"
08:42:40 <EvanR> so is return []
08:42:48 <EvanR> but all final results are valid intermediate results
08:42:49 <grazie> i.e. is the return (x:xs) the final result after all the recursion's done ---ok, got it now
08:42:59 <nitrix> x:xs is the final result, which is your original `x` plus, `xs` which will be obtained by recursively calling getLine again.
08:43:17 <grazie> so xs <- getLine is the recursive call
08:43:25 <EvanR> yes
08:44:38 <grazie> In a function like this (split (x:xs) = ([x],xs) : [(x:ls,rs) | (ls,rs) <- split xs]) it's clear to me that the tail xs is part of the recursive call but I wasn't used to the do syntax yet
08:44:43 <infandum> EvanR: Wait, with the strict map again, why is that so crazy? I just realized that I do it frequently with pipes and it works wonderfully.
08:46:04 <Xsavior> I've heard people say that the IO monad is a trick to keep Haskell pure? How is it a trick? You are changing state in a "pure functional" language. Is it not simply just labelling that this "pure language" will now behave in an impure way?
08:46:26 <EvanR> theres no state involved
08:46:40 <nitrix> Xsavior: You've been misinformed. It's neither a "trick", nor a "hack". It's actually very principled.
08:46:41 <EvanR> IO is just an (abstract) type with combinators
08:47:05 <EvanR> it doesnt do anything until you feed a complete IO program to the runtime
08:47:33 <tom7942> grazie: yeah, for your purposes now you can just imagine that <- strips the monadic part of the type and return puts it back on
08:47:59 <grazie> tom7942 that makes sense
08:48:12 <EvanR> you can imagine haskell like the C preprocessor, the C preprocessor doesnt *do* anything, it just transforms C preprocessor code into C code
08:48:23 <nitrix> Xsavior: I also want to correct "the IO monad" as it's very important here. IO is just a type. The "magic" you're seeing is from the monad, and monads aren't magical at all once you learn about them. They're just very powerful.
08:48:37 <m1dnight1> I have a data type Exp, that is the AST for my toy language. I want to translate it (python-like) to the STLC. What is the best way to do this? I guess I need to have a traversal that has access to the parent node.
08:48:40 <maerwald> EvanR: heh, nice analogy
08:48:43 <m1dnight1> Should I resort to manual traversal?
08:48:50 <EvanR> which you can then run (compile and run, or just interpret with your C interpreter!)
08:49:24 <byorgey> m1dnight1: why do you need access to the parent node?
08:49:24 <tom7942> grazie: do is syntatic sugar for nested >>=, see http://learnyouahaskell.com/a-fistful-of-monads#do-notation for a brief intro
08:49:29 <Xsavior> EvanR, nitrix: thanks. More for me to ponder...
08:49:33 <m1dnight1> http://hastebin.com/locumigato.vbs <- This is the data strucure.
08:49:52 <m1dnight1> Oh, I meant siblings I realised, while typing this out.
08:50:27 <m1dnight1> Because I figured I should translate function top-level defs into a let and put the rest of the program in the body of that let
08:50:30 <m1dnight1> but maybe I don't need to do that
08:51:23 <Xsavior> EvanR, nitrix: except that there is a change of state. How is the Hasekll program immune to this? It just printed something to the console, for example.
08:51:32 <byorgey> m1dnight1: does FDef define a function name with arguments?
08:51:37 <m1dnight1> Yes, it does
08:51:44 <m1dnight1> name, argnames, body
08:51:45 <byorgey> m1dnight1: how do you ever call a function?
08:51:53 <m1dnight1> I don't, yet. :D
08:51:57 <byorgey> ok, fair enough =)
08:52:01 <m1dnight1> I want to do it breath first 
08:52:19 <johnw> Xsavior: also, when we use the word "pure", we mean that the type of each function communicates something meaningful about its semantics, unlike languages whose types are only one part (maybe even the least part) of what a function does at runtime
08:52:30 <nitrix> Xsavior: As a harmless lie for now, I'd say that happens "outside" of Haskell.
08:52:32 <m1dnight1> Maybe I do have enough with Uniplate. I'm going to try.
08:53:19 <nitrix> Xsavior: You're building an IO computation by defining what its inputs are, what happens to the results, and you recombine those computations with other computations to make more complicated ones, but nothing has happened yet.
08:53:28 <byorgey> m1dnight1: I think you should be able to do it in a straightforward recursive way.  So sure, uniplate should work, though it seems a bit overkill
08:53:49 <nitrix> Xsavior: In the end, you end up with one large `IO ()` as your program, and then, it's being executed and the effects are carried out.
08:53:57 <m1dnight1> Yeah, that's the point, though. I need an excuse to go from "I know basic haskell" to "I know this library and that library"
08:54:13 <m1dnight1> They seem quite arcane to me now, and I want to fix that ;)
08:54:19 <tom7942> IO is really describing the entire state of the runtime "world" right?
08:54:20 <sham1> Build a webapp
08:54:26 <JonReed> Hi, how does ghc-mod look for packages? I'm trying to use it inside shell.nix. ghc compiles the file fine, ghc-pkg list shows package as well, but ghc-mod check anything that has those dependencies.
08:54:36 <EvanR> Xsavior: the printing happens when you feed the complete IO program to the runtime system
08:54:41 <tom7942> meaning there's a quite a bit of state hidden behind the IO
08:54:54 <EvanR> tom7942: no
08:55:11 <tom7942> :(
08:55:16 <nitrix> tom7942: IO's actually just a token to maintain referential transparency.
08:55:26 <EvanR> uhg
08:56:21 <Xsavior> nitrix, EvanR: so it's only "pure" before runtime?
08:56:24 <ania123> I got respond, could you correct me again?
08:56:25 <ania123> With pleasure. If you want to see other parts of Georgia instead of Kakheti, for example Borjomi, Bakuriani or Gudauri, it is up to you. I can tell you, one day I am in your service and I can drive where you and Lela decide. 
08:56:58 <EvanR> Xsavior: all functions are pure in haskell, evaluating them has no side effects. even functions like putChar :: Char -> IO ()
08:57:12 <EvanR> putChar 'c' is just a program to put a char
08:57:14 <nitrix> Xsavior: Evaluating Haskell is completely pure, executing it isn't.
08:57:28 <EvanR> i would think pure is a property of functions
08:57:32 <EvanR> and not IO programs
08:58:00 <Xsavior> EvanR, nitrix: that's a big piece of the puzzle right there.... thanks again.
08:58:50 <nitrix> Xsavior: putStrLn "Hi!" is an `IO ()`, which when you execute it, will carry out the side-effects of printing Hi!, but then also evaluate the computation and produce the value of type `()` it promised.
08:58:57 <EvanR> to see why pure or impure non-functions are weird, consider a program in the list monad being "executed"
08:59:48 <EvanR> you dont get side effects, you get the intended effects, the non deterministic computation
09:00:25 <EvanR> is it pure? we dont have to ask if it just doesnt apply
09:00:28 <nitrix> I don't know why I always say side effects when I mean to say effect.
09:00:29 <lpaste> Qfwfq pasted “Is this an appropriate implementation of constructive falsehood? An exercise of Pfenning's expects me to have one.” at http://lpaste.net/301892
09:01:34 <Qfwfq> I don't see any harm in the fixpoint(?) as we'll never encounter a term.
09:01:51 <Qfwfq> But it seems a little gross, anyway.
09:02:02 <johnw> the fixpoint here is actually the meaning of Void's only inhabitant: ⊥
09:02:14 <johnw> you could also do it using "undefined" or a call to "error"
09:02:51 <glguy> Qfwfq: With EmptyCase turned on you might write: abort x = case x of {}
09:02:51 <__monty__> nitrix: You seem to be saying putChar is pure because it always evaluates to IO () but it just so happens the runtime outputs the character?
09:03:16 <EvanR> putChar 'c' doesnt evaluate to IO (), but thats what the result's type is
09:03:21 <johnw> __monty__: what putChar evaluates to, and what the runtime does with that evaluated action, are two separate considerations
09:03:51 <Qfwfq> Ooh, LambdaCase gives me '\case {}' without any warnings.
09:03:52 <johnw> one of the beautiful things about Haskell is that way that it makes us think about evaluation as apart from execution
09:04:23 <Qfwfq> I prefer the clarity of that specification.
09:04:25 <EvanR> programs are data
09:04:55 <Xsavior> EvanR, nitrix, johnw: very informative.
09:04:57 <johnw> another aspect of the distinction: programs are always finite; execution might be infinite
09:05:34 <johnw> it's the difference between the fibonacci algorithm, and the fibonnaci sequence
09:06:27 <orion> Why doesn'
09:06:29 <Qfwfq> :-)
09:06:35 <EvanR> (hmm but data streams might be infinite)
09:06:43 <EvanR> so not all data are programs
09:07:10 <orion> Couldn't any data be interpreted as a program?
09:07:13 <JonReed> What mechanism ghc-mod use to find packages? Why ghc and ghci compile the file and ghc-mod check fails to load an interface of a package?
09:07:26 <EvanR> "a data structure is just a stupid programming language"
09:07:59 <glguy> __monty__: Consider: let x = putChar 'c' in x >> x; this builds an action that when executed prints two c's. This works because x is an action that prints 1 c, and but chaining it with itself via >> we get an action that prints 2
09:08:18 <glguy> __monty__: but merely applying putChar to 'c' isn't printing anything itself
09:09:29 <nitrix> __monty__: That's a crude simplified explanation. The real story is distinguishing between denotational vs. operational, looking at evaluation and the execution of Haskell programs, but you have the main idea.
09:10:09 <dolio> EvanR: Did someone actually say that?
09:10:13 <EvanR> let x = putChar 'c' in x >> x; is actually really good example...
09:10:22 <tabaqui1> has anybody tried to cross-compile ghc?
09:10:27 <EvanR> dolio: yes, thats a bill gosper quote
09:10:28 <tabaqui1> from linux for win
09:10:29 <dolio> It's kind of a category error.
09:10:53 <tabaqui1> i get this error when trying i686 or x86_64 mingw:
09:11:05 <tabaqui1> error: storage size of ‘test_array’ isn’t constant
09:11:08 <tabaqui1> in Types.hsc
09:12:00 <tabaqui1> /usr/bin/x86_64-w64-mingw32-gcc -v
09:12:02 <tabaqui1> gcc version 6.2.1 20160830 (GCC) 
09:12:20 <nshepperd> i'll have infinite programs if I want!
09:12:26 * nshepperd sticks it to the man
09:12:51 <EvanR> dont try it!
09:13:01 <nshepperd> sh < /dev/urandom
09:13:24 <EvanR> and that was the last we heard of nshepperd 
09:13:38 <dolio> Boy, that reminds me of a language someone posted on r/programming way back in the day...
09:13:50 <nitrix> __monty__: All along, you're defining your program as this `main` computation. It might do a lot of things, recombine other things, even pass some `IO ()` as argument to other functions; they aren't evaluated yet. And they aren't evaluated yet because they aren't being executed yet.
09:13:52 <dolio> That was bragging about how every sequence of characters was a valid program, unlike most other languages.
09:14:23 <nshepperd> heh
09:14:37 <EvanR> was he talking about PHP ?
09:15:00 <dolio> No. It was some 'concatenative' language.
09:15:54 <dolio> But one that never became very popular for probably obvious reasons.
09:15:57 <ph88> hey guys, i have put this https://paste.fedoraproject.org/460866/47741205/ in my .ghci file to get colors in ghci .. it works nicely .. just that the printed values are shifted a few spaces to the right. How can i debug this?
09:16:16 <__monty__> nitrix: Is this because of the lazy semantics or is it specific to how the runtime handles IO?
09:16:31 <nitrix> __monty__: Once your execute `main`, then it'll force the evaluation of the necessary bits. What keeps it `pure` is that, denotationally, those computations that have effects are never losing this `IO` classification which requires your code to eventually make it bubble up to your `main`. You'll be unable to do anything of type `IO a` inside another context that isn't itself `IO a` other than passing the
09:16:31 <EvanR> not that obvious, it coincides with how "easy" some languages that did get very popular are
09:16:32 <nitrix> computation around.
09:17:02 <dolio> Well, it was obvious if you saw their example programs, which looked like randomly generated passwords.
09:17:03 <maerwald> __monty__: no, the runtime is implementation defined
09:17:23 <Boomerang> I'd like to have a type safe TH lift, is this a bad idea? "liftT :: Lift a => a -> Q (TExp a); liftT = unsafeTExpCoerce . lift"
09:17:27 <ph88> here is a small example of the output https://paste.fedoraproject.org/460868/12180147/ notice that the 2 and the ¨hello¨ shifted to the right by 4 spaces
09:17:33 <EvanR> oh
09:18:03 <nitrix> __monty__: It's a collaboration of a couple things. The type system is responsible for the purity; the lazy evaluation is responsible for us having to draw the line between evaluation vs executation (were in other languages, they'd just be the same thing).
09:18:28 <dolio> Like, you might think J kind of looks obtuse, but somehow it's much worse when it's a jumble of lower and uppercase letters as well.
09:19:21 <EvanR> nitrix: now youre mixing lazy evaluation, the interleaving of evaluation and execution during runtime, and just "evaluation" all into one...
09:19:46 <byorgey> I think it's hilarious how proponents of concatenative languages claim they are even more functional/higher level than FP languages, since function *composition* is fundamental instead of function application.  It sounds nice until you realize that it really just turns into an imperative program manipulating an implicit stack.
09:20:25 <nitrix> EvanR: I am.
09:20:40 <sham1> To be fair, everything turns into an imperative program ;)
09:21:17 <nitrix> EvanR: But I did explain which does what, when and from also both perspective (semantically and operationally).
09:21:27 <nitrix> Feel free to make your corrections, I'll listen.
09:21:35 <EvanR> nitrix: this is all a lot just to get to the point of being able to call the runtime execution "pure"
09:21:41 <byorgey> sham1: =)  everything is *compiled* to an imperative program.  That's not the same thing as saying the *semantics* is necessarily imperative.
09:21:59 <sham1> I know
09:22:06 <EvanR> which is either isnt at all, or else doesnt even make sense to say
09:22:07 <et09> http://lpaste.net/5013756787682181120 gives me 'main.hs:38:10: error: • Couldn't match expected type ‘Int’ with actual type ‘Maybe Int’ • In the pattern: Just c In a case alternative: Just c -> Just $ BSC.splitAt c In a stmt of a 'do' block: case i of { Just c -> Just $ BSC.splitAt c Nothing -> Nothing }
09:22:18 <nitrix> EvanR: I highly doubt you can say the runtime execution is pure by any definition of "pure".
09:22:31 <dolio> Just wait until I get my reduceron.
09:22:45 <glguy> How long of a wait are we talking about here?
09:22:51 <nitrix> et09: So you might've misunderstood me.
09:22:59 <nitrix> EvanR: * ^
09:23:04 <sham1> glguy, as long as needed
09:23:06 <byorgey> dolio: =)
09:23:10 <dolio> Dont' hold your breath.
09:23:18 <EvanR> nitrix: its a lot to explain why functions are pure
09:23:29 <nitrix> We didn't stop there.
09:23:41 <dolio> Maybe they have the FPGA code available, not sure.
09:23:46 <et09> i get the feeling i'm writing maybeSplit incorrectly
09:23:47 <EvanR> and its a lot to explain why putChar 'c' (not a function) is pure (what does it mean for something thats not a function to be pure)
09:24:24 <nshepperd> it may not be pure, but it sure isn't impure
09:24:37 <EvanR> its not even impure
09:24:45 <sham1> a computation that has the world state implicitly passed and implicitly returns the new world state. Also known as IO
09:24:48 <nitrix> The type system is sufficient for that. But then one have to wonder how the effects are actually carried out if the type system ensures the purity.
09:25:03 <nitrix> So evaluation and executation came into the picture.
09:25:17 <nitrix> But I feel I'm just repeating myself to someone that didn't listen.
09:25:28 <nitrix> It'd be more interesting to hear your point of view and see if they differ.
09:25:33 <EvanR> its not even a lie to say this happens in not haskell, which i said
09:25:54 <dolio> sham1: That model has problems.
09:26:16 <sham1> ?
09:26:29 <nshepperd> unsafeForkUniverse :: RealWorld -> (RealWorld, RealWorld) :)
09:26:55 <EvanR> so what the type system does or doesnt do, doesnt matter
09:27:19 <nshepperd> (it's unsafe because you never know what might happen when mess with cosmic forces)
09:27:27 <dolio> sham1: Why is `forever (putStrLn "Hi")` different from `\_ -> undefined` in that model?
09:27:58 * hackagebot vector-builder 0.1 - Vector builder  https://hackage.haskell.org/package/vector-builder-0.1 (NikitaVolkov)
09:28:06 <sham1> Umn
09:28:10 <sham1> Let me think about it
09:28:20 <sham1> Are we assuming both are being called?
09:29:11 <dolio> I don't think that matters, really.
09:29:24 <dolio> Those are supposed to be different, though, right?
09:29:28 <sham1> Well I think it does
09:30:01 <et09> http://lpaste.net/5013756787682181120 can't get this maybeSplit function right
09:30:02 <EvanR> the model is supposed to IO-as-some-pure-function-or-realworld, so who eventually calls it doesnt matter
09:30:07 <EvanR> of-realworld
09:30:12 <et09> kinda making educated guesses here
09:30:18 <orion> EvanR: What's so hard about pure functions
09:30:29 <dolio> I mean, if they do something different when you call them, then they must be different functions, right?
09:30:40 <sham1> Indeed
09:30:48 <dolio> Something observably different.
09:31:03 <sham1> They are different
09:31:09 <sham1> in that regard
09:31:39 <dolio> Well, that's kind of problematic.
09:31:53 <sham1> I just fail to see the point
09:32:48 <sham1> Maybe elaborate a little?
09:32:58 * hackagebot mysql-simple 0.4.0.0 - A mid-level MySQL client library.  https://hackage.haskell.org/package/mysql-simple-0.4.0.0 (paulrouse)
09:32:59 <EvanR> orion: a few fundamental things, unless you unpack the terminology to mean "just a regular function as in math". but the terminology itself exists because people are thinking of something completely else by default, so its hard
09:33:00 * hackagebot vector-builder 0.1.1 - Vector builder  https://hackage.haskell.org/package/vector-builder-0.1.1 (NikitaVolkov)
09:33:19 <dolio> forever m = m >>= \_ -> forever m; (m >>= f) w = uncurry f (m w)
09:34:40 <mahdi> Hey, I have a large text in a single line and I want to write it to a file, it seems the default behavior of `writeFile` is using `LineBuffering` which causes out of memory error, so I want a function to write by chunks instead of lines and I wrote this: https://gist.github.com/mdibaiee/862360bba6dc95f17d2231b9ef3617f3 but I get `out of memory` errors again, I guess I'm doing something wrong
09:36:59 <dolio> forever m w = (m >>= \_ -> forever m) w = uncurry (\_ -> forever m) (m w) = forever m (snd (m w))
09:37:34 <sham1> a-ha
09:38:06 <dolio> So, forever just calls itself in a loop, so the least fixed point definition is going to be denotationally the same as \w -> undefined.
09:38:24 <dolio> Unless the denotation of functions contains side effects.
09:38:36 <dolio> But the whole point is to not have that.
09:40:47 <sham1> Like in the end, IO is a lot of smoke and mirrors that lets us have IO while working with stuff like lazy eval and our types
09:41:23 <dolio> Well, there are specifications of IO where infinite structures like that don't collapse.
09:41:33 <dolio> Just, functions passing around a token aren't one.
09:42:50 <dolio> Even if you imagine that token is 'the world'.
09:43:44 <sham1> Hmm
09:43:57 <dolio> `forever m` could be an infinite tree.
09:45:10 <dolio> putStrsForever = PutStrLn "Hi" putStrsForever
09:45:26 <sbrg> What is the correct way to use `stack path` to add the appropriate paths to your PATH environment variable? Using it in .bashrc or .zshrc will run it every time you open a new terminal, which can be slow and also outputs a message. 
09:45:56 <dolio> Not much of a tree, but...
09:47:09 <lyxia> mahdi: how is your string defined? 
09:48:49 <mahdi> lyxia: `show someDataInstance`
09:49:08 <__monty__> nitrix, EvanR: Still thinking about this. Does the following make sense? putChar is pure because all it does is take a Char and return an IO () which has similar semantics to () since you can't differentiate between IO ()'s from within the language. The runtime is special in that it can differentiate between IO ()'s and perform effects accordingly.
09:49:22 <tsahyt> is there such a thing as a Signed class? i.e. something that can differentiate between positive and negative values or similar?
09:49:37 <glguy> Num has signum
09:49:49 <lyxia> mahdi: perhaps it's not lazy enough for chunking to be useful 
09:50:05 <tsahyt> glguy: but the other operations of Num don't make much sense on this type
09:50:49 <glguy> tsahyt: If you have more constraints to your question you'll have to elaborate them
09:50:53 <mahdi> lyxia: I was thinking about the same thing, but is there any way to make it more lazy? I tried using `ByteString.Lazy.Char8.pack`, but no luck (I didn't really expect it to work)
09:51:08 <tsahyt> glguy: I mean a class that really just encapsulates the idea of something being either positive or negative
09:51:29 <glguy> Nothing standard
09:51:32 <mahdi> lyxia: My guess is strings are lazy on line level, so each line has to be evaluated for you to work with it
09:51:33 <tsahyt> ok thanks
09:51:40 <__monty__> tsahyt: Ord, kind of...
09:51:59 <tsahyt> __monty__: wouldn't that require some notion of 0?
09:52:01 <lyxia> mahdi: uh, strings are just lists... 
09:52:12 <tsahyt> i.e positive is equivalent to > 0, negative = not . positive
09:52:45 <mahdi> lyxia: hmm, you're right, and it's weird
09:53:22 <lyxia> mahdi: I'm not sure what you can do though... You might want to paste a more complete example. 
09:53:27 <__monty__> tsahyt: It presupposes that there's an identifiable point where negative turns into positive. You could still do this for Z\0.
09:54:08 <__monty__> (>= 1)
09:54:18 <lyxia> mahdi: I have to go though, let someone else take a look. 
09:55:48 <mahdi> lyxia: alright, thank you
10:04:21 <mutantmell> Does MonadError have any laws?  The hackage docs don't list any
10:11:32 <tsahyt> :hoogle a -> a -> m Bool
10:11:37 <tsahyt> @hoogle a -> a -> m Bool
10:11:40 <lambdabot> HIndent.Pretty withCaseContext :: MonadState (PrintState s) m => Bool -> m a -> m a
10:11:40 <lambdabot> Text.XML.HXT.DOM.Util toMaybe :: Bool -> a -> Maybe a
10:11:40 <lambdabot> Data.Maybe.HT toMaybe :: Bool -> a -> Maybe a
10:13:31 <x1f577> is ther a simple ufw rule i can use to open up access to the dns servers defined in /etc/resolv.conf?
10:13:52 <x1f577> provided that i've set the defaults to deny for everything else
10:14:15 <tsahyt> so this C library defines a type A and a function AIsEqual that is roughly like A -> A -> Bool, but executing it still depends on state because A is really just a reference.
10:14:44 <tsahyt> so technically it's more like A -> A -> IO Bool
10:15:14 <tsahyt> I'd like the define an Eq instance. as long as the references are defined (they provably are, otherwise the call cannot be made), this is "morally" pure
10:15:26 <tsahyt> how awful is it to actually define an eq instance like that?
10:16:24 <tsahyt> I get the same situation for Ord
10:16:51 <et09> haskell is sure cool
10:17:32 <johnw> tsahyt: so you want to define an equivalence that's not necessarily equality?  Haskell's Eq is rather loose (having no laws defined by the report), so it's hard to argue that what you want to do is wrong.  I'd just ask why you want to use Eq to do this.
10:17:43 <tsahyt> johnw: It is equality
10:17:58 <tsahyt> the function returns true if and only if the symbols behind those references are equal
10:18:01 <johnw> ah
10:18:11 <johnw> you mean, it's an equality that you don't test directly, but know indirectly?
10:18:26 <tsahyt> but the library doesn't give me access to the actual symbol, and doing equality via references is necessarily impure because it depends on the state of the library
10:18:44 <tsahyt> basically, yes. the library does the lookups, performs an equality check, and returns the result
10:18:58 <johnw> then I suppose the burden is on you to guarantee this invariant
10:19:07 <johnw> but if it's always true, this it sounds like equality
10:19:39 <tsahyt> I can make sure that the user cannot define references arbitrarily but only get them through the library, and through rank-2 types I can assure that they never leak out into a scope where they might not be defined
10:19:56 <tsahyt> so I suppose I can prove that there's nothing fishy going on
10:20:05 <tsahyt> I guess I'm just afraid of unsafePerformIO
10:20:09 <athan> Is there a way to include the Win32 package dependency _only_ on windows? :s
10:20:19 <athan> idk if I can use a CPP #ifdef in a .cabal file
10:20:22 <johnw> athan: yes, using an os check and CPP
10:20:26 <athan> :O!
10:20:29 <athan> thanks johnw!!
10:20:32 <johnw> you do it with an os(windows) flag or something in .cabal
10:20:34 <johnw> i forget the exact syntax
10:20:45 <athan> oh right! I forgot too :|
10:20:47 <athan> thanks :)
10:20:54 <johnw> oh, it is that
10:21:10 <dmj`> athan, johnw: can probably avoid cpp if you use the hs-source-dirs trick
10:21:31 * johnw wonders what this trick is...
10:21:43 <pikajude> have you prepared the necessary sacrifices?
10:21:43 <hvr> johnw: switch hs-source-dirs based on flags or os()
10:21:51 <dmj`> "This one weird trick to to avoid CPP, C programmers hate him"
10:22:10 <dmj`> what hvr said
10:22:19 <athan> dmj`++
10:22:25 <kirillow> why cant a function of type `a -> a` return anything but the very same value? 
10:22:40 <johnw> kirillow: because it doesn't know how to create a value of any type 'a'
10:22:51 <johnw> the only thing it can possibly do is hand back the same value it was given
10:23:00 <dmj`> athan: if impl(ghcjs) hs-source-dirs: ghcjs-src; build-depends: ghcjs-base else hs-source-dirs: ghc-src; build-depends: webkitgtk
10:23:03 <hvr> johnw: works for main-is too
10:23:11 <johnw> hvr: thanks!
10:23:13 <Tuplanolla> "What does everything have in common? Nothing."
10:23:27 <hvr> Tuplanolla: bottom
10:23:44 <hvr> (if you refer to 'forall a . a'
10:23:57 <Tuplanolla> It's a philosophical question.
10:24:00 <dmj`> athan: you can also have a hs-source-dirs: common-src, where both projects share it
10:24:23 * dmj` wonders if you can just add as many hs-source-dirs locations as you want
10:24:28 <athan> dmj`!!! That's actually really nice
10:24:40 <dmj`> athan: yea, reflex does this
10:24:41 <dolio> Or is it?
10:24:54 <athan> oh boy... I might actually enjoy dev on windoughs!
10:25:09 <johnw> "wind blows"
10:25:15 <dmj`> M$
10:25:27 <dmj`> cygwin is kind of cool
10:25:57 <dolio> If you can whittle the OS-specific stuff to just things that require completely separate implementation, it's okay.
10:26:23 <dmj`> athan: as long as your build process can build both at the same time, then you'll know if you did it right
10:27:21 <dmj`> athan: I'd use vagrant, have a shake script that compiles your project on 2 os's, windows is real
10:27:30 <dmj`> vagrant-windows*
10:27:46 <damian_> I am using http-conduit and I want to unittest some function that are returning HTTP.Response... is there any easy way to create a HTTP.Response so I can unit test my code?
10:28:25 <et09> omg.. i just wrote my first legit haskell program
10:28:49 <ongy> et09++, what did you write?
10:28:57 <EvanR> et09++
10:29:02 <yulax> tell us
10:29:03 <dmj`> et09++
10:29:04 <et09> it's a specialized TCP server for a stupid protocol used in healthcare
10:29:04 <yulax> share it
10:29:09 <EvanR> how does the karma work
10:29:11 <dmj`> et09: code or didn't happen
10:29:27 <et09> http://lpaste.net/5013756787682181120
10:29:37 <ongy> healthcare? sounds like a bunch of fun
10:29:52 <et09> it's not, this is the most antiquated thing we have to support, give or take
10:29:59 <et09> this is basically just a proxy 
10:30:01 <EvanR> @karma et09 
10:30:02 <lambdabot> et09 has a karma of 2
10:30:08 <EvanR> ongy's didnt count
10:30:17 <dmj`> @karma dmj`
10:30:18 <lambdabot> You have a karma of 4
10:30:20 <Tuplanolla> @karma lambdabot
10:30:20 <lambdabot> lambdabot has a karma of 32
10:30:27 <yulax> i know people who still support 4.4bsd-lite
10:30:56 <dolio> EvanR: Heh, I was just checking that.
10:31:50 <ongy> is karma channel local?
10:31:58 <dolio> No.
10:32:01 <EvanR> it seems lambdabot local
10:43:41 <orion> If two data structures are both Monads, is there a law which allows each of them to be converted/expressed in terms of the other?
10:44:56 <EvanR> there may or may not be a monad homomorphism from one to the other
10:45:16 <EvanR> and for two monads that have the same functor, they are both specializations of the free monad for that functor
10:46:46 <Cale> So basically "no" :)
10:47:24 <EvanR> would able to be expressed as each other imply some kind of isomorphism
10:48:06 <Lokathor> you can usually stack each on top of the other
10:48:10 <johnw> orion: consider Maybe and Either e
10:48:14 <Lokathor> but expressing them in terms of each other sounds odd
10:48:32 <Cale> Or lists and IO
10:49:58 <Cale> Monads can in general be pretty different and unrelated to one another
10:50:32 <Lokathor> all we know for sure is that they're somehow like a burrito, in an unspecified way
10:51:20 <mutantmell> consume :: (MonadBurrio m) => m a -> m ()
10:51:24 <srk> is there a shortcut for a <- someAction case a of Nothing -> exitFail Just -> rest of the program?
10:51:57 <johnw> I think: Just a <- someAction
10:52:01 <srk> looks like should be doable with maybe monad but how to provide error messages
10:52:35 <Lokathor> srk, might want to write that helper yourself if you want the error messages
10:52:39 <EvanR> you dont stack monads on top of each other, transformers map one monad to another
10:54:00 <Lokathor> you'll have to speak more to the difference you're trying to distingush there
10:57:05 <orion> Is it possible to write a config file in Haskell and have it compiled at runtime?
10:57:17 <johnw> orion: using TH, sure
10:57:20 <orion> (I mean, I'm sure it's possible)
10:58:03 * hackagebot sparse-linear-algebra 0.2.0.9 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.0.9 (ocramz)
10:58:13 <srk> looks like javascript is catching up https://github.com/folktale/data.maybe
10:58:16 <Tuplanolla> It's quite unpleasant in comparison to, say, Scheme, orion.
10:58:44 <dmj`> srk: heh
11:02:55 <monochrom> wait, TH is run at compile time, not compile at run time...
11:03:09 <johnw> oh, right
11:03:11 <johnw> I misread
11:03:19 <johnw> you'd have to do what ghci does
11:03:31 <EvanR> haskell JIT
11:04:34 <orion> Ah, I guess it's not worth it.
11:06:08 <dmj`> srk: it's easier just to ffi into little js snippets to eek out speed, than to write js itself
11:06:48 <dmj`> plus chrome's debugger is /awesome/
11:07:11 <srk> dmj`: yeah, I wouldn't write js anyway, only compile
11:11:31 <mpickering> Does anyone know why optparse-applicative decided to remove the <> export in the latest release?
11:12:07 <EvanR> my high level language is too slow, need to escape into javascript to write a fast loop
11:12:09 <phadej> changelog says: Export Semigroup instances for types which are also Monoids. Removes mempty synonym (<>) export, as it clashes with Semigroup exports. 
11:12:31 <dmj`> EvanR: samesies
11:12:40 <sham1> When Javascript is faster than the language you would otherwise use, something is wrong
11:12:49 <EvanR> lol
11:13:18 <mpickering> phadej: I don't understand that, what clashes exactly?
11:13:26 <mpickering> Is the semigroup class method called <> or something?
11:13:44 <phadej> yeah, Data.Monoid has own (<>) = mappend
11:14:48 <EvanR> yep the Semigroup method is called <>
11:14:58 <ryantm____> Is it possible to splice a type literal into a template haskell quasi quotation? Here's an example setup that doesn't work using the OverloadedLabels example code in the GHC users guide: https://gist.github.com/ryantm/e96ee809e92f5445e1c7d292d8ccdcb7
11:15:05 <phadej> I'm not sure whether that alias will be deprecated in base4.10 or 4.11
11:15:07 <mpickering> couldn't they have exported the new <> to avoid breaking code?
11:15:31 <EvanR> you cant have (<>) = mappend and (<>) be the semigroup method at the same time
11:16:23 <phadej> yeah, it could broke the code if people have import Data.Monoid
11:16:32 <Cale> Well, you can, if you want to qualify them, but that's disgusting :)
11:16:45 <Tuplanolla> Isn't `<>` in Prelude now?
11:16:51 <EvanR> nope
11:16:51 <phadej> Tuplanolla: not in Prelude
11:16:55 <mpickering> right but they should be the same definitions so I'm wondering why they removed the mappend export but didn't export <> from semigroups
11:17:07 <Tuplanolla> I didn't even realize.
11:17:25 <phadej> mpickering: you could get clashes, ambigious use of <>
11:17:39 <phadej> some probably use import Data.Monoid to get mconcat
11:17:49 <phadej> as optparse-applicative didn't exported that
11:17:55 <Cale> Perhaps they ought to re-export Semigroup's -- I sort of wish I were on that version of optparse-applicative for the code I wrote yesterday, but I'm not going to bother writing nix overrides to get it.
11:18:13 <phadej> https://github.com/pcapriotti/optparse-applicative/pull/216 has Huw's comments
11:18:14 <mpickering> which is better than breaking everyones code for such a widely used library
11:18:18 <Cale> (I just ended up defining (<+>) to be the (<>) from Data.Monoid)
11:18:34 <infandum> EvanR: In case you're curious I think I solved it. I think I just needed to use runRegion on each R call and it hasn't (yet) died!
11:19:09 <Cale> (Since the code I was adding commandline options to already used Semigroup's (<>) everywhere, and the version of optparse-applicative in nix apparently still only has a Monoid instance)
11:19:39 <phadej> mpickering: But they did bump major version, to indicate something major happened!
11:20:08 <phadej> mpickering: and their test-suite broke if they re-exported <> from semigroup
11:20:43 <phadej> hard to say now which way would been less painful. I personally don't like re-exports
11:22:39 <mpickering> Well it took 30 seconds of maintenance so I should complain less
11:30:59 <EvanR> i see the spoon package can "run" an expression and semi reliably convert an error into a Nothing
11:31:26 <EvanR> i see it doesnt tell you what went wrong, and nobody talks about this lib anymore, so i wonder whats better
11:31:48 <jophish> haha, because spoons have handles
11:32:28 <EvanR> oh Handler i see
11:34:00 <EvanR> still doesnt give you the exception
11:34:34 <dolio> Giving you the exception would be more impure.
11:34:47 <EvanR> ah
11:35:27 <jle`> spoon because it spoonfeeds you it, i think
11:35:50 <jle`> hi everyone
11:35:54 <jle`> why isn't there a strict foldl1
11:36:39 <osa1> there is
11:36:44 <jle`> oh, it only exists for Data.List
11:36:48 <jle`> what about for Foldable's in general
11:37:08 <jle`> [revision of question] why isn't there a strict foldl1 generic over Foldable
11:37:51 <EvanR> not sure why i thought spoon was supposed to evoke eggs, since you can catch eggs with a spoon
11:38:24 <EvanR> you do throw eggs, but evaluating an expression is like boiling an egg, but it might crack before hand
11:38:56 <EvanR> im probably hallucinating
11:43:07 <jle`> maybe you're onto something
11:44:13 <dmj`> sounds eggspressive
11:44:42 <joe9> is there a better way of writing this function: https://paste.pound-python.org/show/BTSNpDYGiSiy5GOB8iad/ ?
11:44:59 <joe9> i could probably use map.
11:45:33 <dmj`> joe9: maybe a list comprehension
11:45:43 <joe9> dmj`:  ok, Thanks.
11:45:46 <Tuplanolla> Start with this, joe9: `if elem Stat.Authentication mode then (Qid.Authentication :) else id`
11:46:01 <jle`> joe9: you can use filter maybe
11:46:03 <sham1> :)
11:46:17 <jle`> er, mapMaybe
11:46:49 <jle`> mapMaybe _ [Stat.Temp, Stat.Authentication, Stat.ExclusiveUse ...]
11:47:24 <jle`> or you can just map _ mode if taht works
11:47:43 <joe9> jle`: looks like mapMaybe is meant to do this.
11:47:57 <jle`> yes, but it has to use 'elem' every single time
11:48:10 <jle`> maybe you can mapMaybe or map mode directly
11:48:12 <jle`> and handle each element in mode
11:48:26 <joe9> oh, ok. map seems straightforward too.
11:48:37 <dmj`> sham1: I'd use 'guard'
11:48:41 <EvanR> fmapMaybe is changing my life right now
11:48:45 <dmj`> er, joe9
11:48:49 <jle`> fmapMaybe?
11:48:51 <sham1> :)
11:48:57 <jle`> i love 'wither' :)
11:49:06 <EvanR> fmapMaybe :: (a -> Maybe b) -> f a -> f b
11:49:27 <jle`> what is f constrained to be?
11:49:35 <sham1> Probably Functor
11:49:40 <jle`> not possible with functor
11:49:46 <johnw> EvanR: sounds like that KleisliFunctor article
11:49:51 <sham1> You sure?
11:49:57 <EvanR> functors not necessary or sufficient
11:50:00 <jle`> sham1: prove me wrong :)
11:50:05 <sham1> Nah
11:50:08 <johnw> http://elvishjerricco.github.io/2016/10/12/kleisli-functors.html
11:50:12 <sham1> Don't feel like it
11:50:12 * EvanR reads that
11:50:24 <jle`> sham1: what i mean was, try to implement it with Functor ^^
11:50:38 <jle`> EvanR: looks like 'mapMaybe' from witherable :)
11:50:41 <jle`> @hackage witherable
11:50:41 <lambdabot> http://hackage.haskell.org/package/witherable
11:51:34 <EvanR> yeah i knew about witherable
11:52:14 <EvanR> but it requires dot dot dot Foldable
11:52:25 <jle`> hm?
11:52:39 <EvanR> Traversible requires Foldable
11:53:02 <jle`> ah, didn't realize that witherable required traversable
11:53:13 <sham1> Umn, yeah
11:53:18 <jle`> it really should only need Functor shouldn't it
11:53:27 <jle`> why the traversable constraint?
11:53:33 <sham1> a fmapMaybe is kind of not possible without having a Maybe f b
11:53:38 <EvanR> no, the typeclassopedia explains why "filterable" stuff doesnt make sense
11:53:51 <EvanR> except maybe with traversible
11:54:00 <EvanR> well plus some other stuff
11:54:17 <jle`> but, its laws only involve Functor
11:54:25 <jle`> oh, they involve Applicative
11:54:25 <EvanR> traverse f ≡ wither (fmap Just . f)
11:54:53 <EvanR> so its trying to say that mapping to just is like traversing
11:55:17 <Lokathor> what space keyboard do you have where  ≡ is on it?
11:55:25 <EvanR> command V
11:55:31 <Lokathor> :3
11:55:38 <jle`> fair, i'll look into the kleisli functors to see what instances make sense for that and not for witherable :)
11:55:54 <younder> EvanR, but map is parellizable
11:57:12 <joe9> https://paste.pound-python.org/show/nSx4nMmrB8r1YdQViJ5i/ seems easier to understand too
11:57:37 <EvanR> younder: by mapping i mean fmapping
11:59:00 <Tuplanolla> Since we're already flipping, joe9: `flip mapMaybe mode $ flip lookup [...]`
11:59:58 <Tuplanolla> I usually avoid `$`, but it's not nice when your parentheses stretch over the whole kingdom.
12:00:21 <joe9> Tuplanolla: you have a point.
12:00:24 <sham1> Yeah, this ain't lisp
12:01:39 <tdammers> IMO the main benefit of $ lies in the . . . . $ idiom, not so much the avoiding of parentheses
12:02:03 <tdammers> and really, I wouldn't mind ( . . . ) much either
12:02:24 <EvanR> "Of course, it could also prove to be no more useful than m alone, which would be disappointing, but ultimately unsurprising."
12:02:46 <EvanR> haskell category theory in a nutshell xD
12:03:20 <EvanR> (the monad implied by the adjuction of kleislifunctor and cokleislifunctor)
12:03:48 <tdammers> sometimes, unsurprising disappointment can be oddly satisfying
12:04:46 <ertes> like bad coffee
12:05:09 <tdammers> nah
12:05:12 <tdammers> bad coffee is just bad
12:06:02 <ertes> "by mapping i mean fmapping": every time someone uses "fmap" in its progressive form, i feel like it's one edit-distance away from a disaster
12:06:54 <sham1> What do you mean by progressive form in this
12:06:55 <hexagoxel> class Fuctor => ...
12:07:26 <ertes> sham1: "fmapping"
12:07:41 <ertes> a progressive tense
12:07:46 <sham1> oh
12:13:21 <sbrg> I always pronounce `fmap` with the `m` silent
12:13:35 <johnw> I pronounce it with all four letters silent
12:13:43 <sham1> I just pronounce it fmap
12:14:08 <ertes> for me it's just "map"
12:14:08 <acowley> I pronounce it <$>
12:14:25 <sham1> "less-than dollar larger-han"
12:14:25 <sbrg> "left angle bracket dollar sign right angle bracket"
12:14:29 <sham1> Okay then
12:14:44 <dmj`> "flap-map" for me
12:15:00 <EvanR> Flunctor
12:15:10 <zipper> Hey can anyone tell me why I'm getting this:
12:15:18 <sham1> Don't ask to ask
12:15:18 <zipper> > toEnum (120 :: Int)
12:15:20 <zipper> *** Exception: Prelude.Enum.().toEnum: bad argument
12:15:20 <lambdabot>  *Exception: Prelude.Enum.().toEnum: bad argument
12:15:33 <zipper> Yet `toEnum` takes an Int
12:15:40 <ertes> so johnw is the concise, sham1 is the trivial, acowley is the groovy, and sbrg is…  uhm…
12:15:41 <Tuplanolla> Guess the return type, zipper.
12:15:47 <zipper> Char
12:15:53 <acowley> > toEnum (120::Int) :: ()
12:15:55 <EvanR> you guessed wrong
12:15:55 <lambdabot>  *Exception: Prelude.Enum.().toEnum: bad argument
12:16:11 <dmj`> "Flappicative"
12:16:16 <sbrg> johnw: so how do you convey the meaning? body language?
12:16:29 <sham1> wtry this
12:16:31 <sbrg> I should come up with an fmap dance. 
12:16:35 <EvanR> dmj`: i see more flacme packages on the way
12:16:37 <sham1> (toEnum 120) :: Char
12:17:05 <sham1> Fmap is funny to pronouncer
12:17:10 <Tuplanolla> That'll go well with SPJ's pattern matching dance, sbrg.
12:17:12 <acowley> I'd work really hard to incorporate the use of flappicative in my code
12:17:12 <sham1> s/pronouncer/pronounce/
12:17:14 <zipper> hmm why do I have to tell the interperter the return type yet it's in the type signature?
12:17:18 <sbrg> Tuplanolla: that exists?!
12:17:22 <zipper> Kinda confused by this
12:17:29 <Tuplanolla> Have you seen his lens talk, sbrg?
12:17:33 <sbrg> nope
12:17:38 <sham1> Well the signature of toEnum is...
12:17:41 <sham1> Actually, let's see
12:17:42 <acowley> zipper: You told it the type of hte argument
12:17:44 <sham1> :t toEnum
12:17:45 <EvanR> zipper: what type signature?
12:17:46 <lambdabot> Enum a => Int -> a
12:17:51 <EvanR> oh
12:17:51 <sham1> There
12:17:58 <zipper> ohhhhh
12:18:01 <zipper> `toEnum :: Enum a => Int -> a`
12:18:06 <EvanR> toEnum always takes a Int, you dont have to tell it
12:18:07 <zipper> It doesn't say Char
12:18:09 <Tuplanolla> He walks across the stage into a crouching position, pretending to match patterns, sbrg. Several times, even, if I remember correctly.
12:18:09 <sham1> You need to tell which Enum you want it to be
12:18:17 <zipper> I thought it said Char because it did in this book
12:18:22 <sham1> Well Char is an "instance" of Enum
12:18:23 <dmj`> EvanR: flackage might crash
12:18:27 <sbrg> Tuplanolla: I need to show this to my students
12:18:42 <Tuplanolla> We have much to learn, sbrg!
12:18:46 <sham1> Instance in quotes because it has slightly different connotations in other places
12:19:05 <EvanR> no quotes necessary
12:19:08 <zipper> Ok and how could you tell from that error where my problem was?
12:19:12 <EvanR> instance Enum Char where...
12:19:19 <zipper> `*** Exception: Prelude.Enum.().toEnum: bad argument`
12:19:21 <zipper> ??
12:19:30 <EvanR> it was trying to convert to an ()
12:19:31 <acowley> Can't believe we haven't done Haskell charades at a Haskell meetup before
12:19:35 <sham1> It didn't know what to convert to
12:19:38 <EvanR> (why did i use `an' there, i dont know)
12:20:07 <acowley> zipper: Familiarity with the use of things with a polymorphic return type, and the "()" part
12:20:07 <EvanR> > toEnum 0
12:20:09 <lambdabot>  ()
12:20:14 <dolio> Oonit?
12:20:20 <ertes> we're mappin' and fappin', stabbin' and rappin'…  with lists and functors, lenses and quantors…  we the haskell crowd!
12:20:22 <zipper> acowley: Ok familiarity :)
12:20:35 <sham1> Haskell screw
12:20:37 <sbrg> > [()..]
12:20:39 <lambdabot>  [()]
12:20:43 <sbrg> huh, 
12:20:47 <sbrg> TIL.
12:20:54 <acowley> zipper: Yes, and being confused by Enum reflects well on you
12:21:04 <zipper> acowley: Well how?
12:21:05 <acowley> zipper: That it says it will give you an "a" for *any* Int is silly
12:21:08 <ertes> s/we the/we're the/
12:21:10 <sbrg> ertes: oh god
12:22:02 <sham1> The Haskell Screw. The S is silent
12:23:05 * hackagebot cplex-hs 0.5.0.0 - high-level CPLEX interface  https://hackage.haskell.org/package/cplex-hs-0.5.0.0 (stefanjhlk)
12:23:07 * hackagebot iconv-typed 0.2.0.0 - Type safe iconv wrapper  https://hackage.haskell.org/package/iconv-typed-0.2.0.0 (AlfredoDiNapoli)
12:23:09 <acowley> zipper: The honest type is Enum a => Int -> Maybe a, which perhaps makes you think a bit more about what it can be doing.
12:23:41 <EvanR> the safe enum package
12:24:00 <sham1> toEnum, +1 to my list of unsafe Prelude functions
12:24:32 <ertes> and the most ambiguously named ones
12:24:59 <acowley> zipper: So, if you said toEnum 120, and the type defaulted to (), you'd get Nothing :: Maybe ()
12:25:51 <ertes> > mempty -- i think haskell should never default to ()
12:25:53 <lambdabot>  ()
12:26:06 <ertes> also i'm pretty sure there was a time when it didn't
12:26:32 <joe9> protolude avoids that, I think.
12:26:44 <EvanR> it does seem rather useless
12:26:56 <EvanR> as we have seen it doesnt result in fewer error messages
12:26:59 <ertes> i can see where the utility comes from (example: forever c), but i'd be comfortable writing type signatures in those rare cases
12:27:03 <Tuplanolla> It's really fun to QuickCheck something and have it tested with a hundred `()`s.
12:27:55 <sham1> I imagine there being a lot of problems fixable with a custom Prelude alone
12:28:05 * hackagebot jvm 0.1.2 - Call JVM methods from Haskell.  https://hackage.haskell.org/package/jvm-0.1.2 (MathieuBoespflug)
12:37:05 <hackrilege> What are the functions of the producer and consumer class and in what module do i find them?
12:38:38 <cocreature> hackrilege: are you talking about some producer/consumer typeclass? if so which package is that supposed to be from?
12:38:53 <hackrilege> And what's a codensity transformation?
12:40:08 <hackrilege> Maybe it's pipes or streams i saw it in, I was wondering if it was a general concept
12:40:30 <cocreature> pipes has a Producer and a Consumer type(alias) but not a typeclass
12:41:04 <hackrilege> Isn't it just push and pull?
12:41:38 <cocreature> the underlying machinery in pipes is a bit more complex since you can do bidirectional communication both upwards and downwards a pipe
12:42:39 <hackrilege> push :: a -> f a -> f a; pull :: f a -> (f a,a)
12:43:38 <hackrilege> Yes I remember pipes had a nice biditectionality it used in 'for', but I should check
12:44:43 <hackrilege> Bidirectionality*
12:45:29 <cocreature> hackrilege: that pull type doesn’t work because the producer could have finished. also I don’t see how you would express a pipe that takes values transforms them and then outputs them again. it seems like your push interface expects that you already know what to push to whereas you usually want to write a standalone pipe and then later decide what to connect it to
12:46:47 <Xsavior> "Monads gave them (Haskell users) a loophole in the function contract" -Douglas Crockford. Anyone care to elaborate what he is saying? YOUTUBE LINK: https://youtu.be/dkZFtimgAcM?t=9m13s
12:47:03 <EvanR> oh geez
12:47:51 <acowley> I could guess that he means that functions with type t -> m t can do things that functions of type t -> t can't do.
12:48:02 <Xsavior> EvanR: yes. I'm back... :) From your reaction I'm guessing you're not a fan this statement...
12:48:20 <EvanR> loop holes imply somehow defeating the spirit of some rule
12:49:11 <EvanR> haskell does have such loopholes, like using unsafePerformIO
12:49:18 <acowley> Yes, and that connotation is backwards, imo. Capturing the effect in the type means we can once again work with values of type t -> m t as functions because we know their type!
12:50:16 <cocreature> hackrilege: fwiw http://www.haskellforall.com/2014/11/how-to-build-library-agnostic-streaming.html describes some solutions on how to write code that works with all kinds of streaming libraries. so in some sense it is more general than using _only_ pipes.
12:50:35 <hackrilege> Ah cool
12:50:48 <cocreature> but I think it can only create producers iirc
12:51:21 <cocreature> for consumers you might want to look into the foldl library
12:51:25 <johnw> acowley: yeah, types are a bit like lego shapes: they exist so you know at a glance which pieces can be meaningfully fit together to make a sound structure.  The richer the shape language, the fewer things you can build, but the chances of an unsound building likewise decrease.  With no shape language, you have silly putty, and are left to your own artistic abilities.
12:53:13 <Xsavior> johnw: Are you implying that you can have a function that does not specify what type is returned?
12:53:21 <Xsavior> In Haskell
12:53:27 <johnw> Xsavior: in other languages, sure; I didn't mean that about Haskell
12:53:52 <acowley> It's like using unsafePerformIO in Haskell to get a simpler type for your function
12:54:23 <EvanR> at that point you might not even have a proper function anymore
12:54:30 <EvanR> which is why it would be a loophole
12:54:36 <acowley> Yeah
12:55:42 <younder> EvanR, So the type system isn't "bullet proof" then?
12:55:47 <acowley> Cursory contact with Haskell gives the impression that Haskell has somehow rationalized IO with fancy math. But what we actually do is protect our precious functions!
12:56:10 <johnw> younder: with -XSafe it's allows fewer bullets to strike
12:56:56 <johnw> but even with -XSafe it doesn't require all functions to be total; so the type may say it returns an Int, but it might not do so before the heat death of the universe
12:57:38 <WilJR> what are you (anyone) using Haskell for?
12:57:44 <EvanR> gamez!
12:57:52 <hackrilege> Chemistry
12:57:55 <younder> johnw, good enough, I didn't expect it to sollve the halting problem (which is impossible)
12:57:59 <ab9rf> chemistry games!
12:58:02 <ab9rf> (i wish)
12:58:07 <WilJR> haha cool
12:58:12 <WilJR> any examples I can see_
12:59:32 <EvanR> not really
12:59:34 <hackrilege> I thought it was basically mu and nu this consumer generator business
13:00:59 <hackrilege> Can I do more with pipes than I can with fixed point hylomorphisms?
13:01:24 <johnw> yes, you can have effects
13:01:46 <johnw> a fixed point hylomorphism is not going to query postgresql row by row as you draw out the results
13:02:39 <hackrilege> If I use select and lift as in the article then dont I get an analogy to ana and cata but for monad transformers?
13:02:42 <younder> johnw, As long as you stick with the subset of functions that a) either stop after n steps, or b) each step return a expression simpler than you started with. You should be safe
13:03:59 <EvanR> thats two ways to argue that an algorithm will end
13:04:22 <johnw> accessibility is another, tarksi's theorem
13:04:40 <johnw> tarski
13:04:49 <hackrilege> Converges sufficiently...
13:05:22 <younder> johnw: this one https://en.wikipedia.org/wiki/Tarski%27s_undefinability_theorem ?
13:05:42 <johnw> http://mathworld.wolfram.com/TarskisFixedPointTheorem.html
13:06:09 <younder> johnw, thx
13:07:21 <hackrilege> Exists n st forall e, x, (iterate f x)!!n < e
13:09:22 <younder> johnw, This fixed point theorem seems straight out of recursion theory.
13:10:49 <younder> johnw, The wikipdedia article seems more enlightening though
13:11:41 <younder> Too bad IRC doesn't unerstand mathML. or we could paste math
13:12:45 <Tuplanolla> younder: http://mathb.in/
13:12:53 <younder> \bigvee P = \bigvee \{ x \in L \mid x \le f(x) \} as the greatest fixpoint of f
13:14:08 <younder> OK http://mathb.in/96994
13:15:05 <younder> Tuplanolla, No exactly ideal is it?
13:16:07 <younder> Anyhow latex is a damn sight more redable than mathML
13:16:08 <Tuplanolla> Not when you don't use the math mode.
13:19:15 <younder> I suppose you all know of MathJax (if not check it out)
13:19:40 <Tuplanolla> It powers that website too.
13:20:26 <younder> Tuplanolla, I get it. I am not using it right. I'd beter read the instructions
13:20:49 <Tuplanolla> Just sprinkle some `$` fairy dust. There's a preview on the right.
13:21:03 * Fairy hides.
13:21:10 <EvanR> so, while were complaining about pretty much anything. free monads and type synonyms result in some horrible error messages :( http://lpaste.net/302375
13:22:10 <EvanR> i can read it because ive been looking at the matrix too long
13:22:21 <EvanR> but i cant say the same for users of the code
13:22:46 <Tuplanolla> For a very long time I only read the line and column numbers, EvanR.
13:22:53 <Tuplanolla> That's usually enough.
13:23:22 <EvanR> (the message could really really be a lot worse)
13:23:46 <EvanR> do you think its reasonable to reimplement some internal stuff without transformers in order to improve error messages?
13:24:04 <Tuplanolla> No.
13:25:55 <ph88^> hello !
13:31:57 <younder> Tuplanolla, We try again http://mathb.in/96998
13:32:31 <Tuplanolla> I take it you have never used LaTeX, younder.
13:32:57 <younder> Tuplanolla, I have, but I have't used it for a while
13:33:01 <Tuplanolla> You can enter and exit math mode with `$`.
13:33:28 <younder> Tuplanolla, on you wan't the text outside the $
13:33:37 <Tuplanolla> You don't need to bother now.
13:33:46 <Tuplanolla> I just wanted to show you that this tool exists for longer math things.
13:34:21 <younder> Tuplanolla, like this http://mathb.in/96998
13:35:00 <younder> http://mathb.in/97000
13:35:27 <younder> sigh well let's move on
13:36:39 <EvanR> moving on
13:43:08 * hackagebot ascii-cows 0.0.2.0 - A collection of ASCII cows. Moo.  https://hackage.haskell.org/package/ascii-cows-0.0.2.0 (passy)
13:44:39 <byorgey> haha https://github.com/passy/cows-hs/blob/master/src/Cows/All.hs
13:49:35 <younder> ASCII art, haven't seen that for a while
13:49:59 <Tuplanolla> Now when someone asks me what Haskell is good for...
14:13:09 * hackagebot extra 1.5.1 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.5.1 (NeilMitchell)
14:15:22 <Welkin> how can I represent Either in javascript?
14:15:25 <Welkin> o.o
14:15:31 <ph88^> where can i find infos about the default keyword ?
14:15:50 <Welkin> all of the ways I can think of seem messy
14:16:16 <glguy> ph88^: Haskell 2010: Section 4.3.4
14:16:30 <ongy> Welkin: check what ghcjs produces?
14:16:35 <Welkin> { right: null|somevalue, left: null|somevalue }
14:16:40 <ongy> but I guess that's messy outside the ghcjs RTS aswell
14:16:49 <ph88^> glguy, oh i just found this too https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#class-default-signatures
14:17:29 <glguy> ph88^: That's separate from the standard Haskell default keyword
14:17:44 <younder> Welkin, the JSON lib should do that for you
14:18:18 <younder> Welkin, Real world Haskell has some code too
14:18:33 <dmj`> Welkin: with null
14:18:43 <Welkin> younder: I am writing this in plain javascript, interfacing with Elm
14:18:51 <ph88^> glguy, oh two default keywords .. that's rather confusing
14:18:52 <Welkin> dmj`: lol dmj` that is for Maybe
14:19:28 <dmj`> var either = { left : null, right : 'foo' };
14:19:53 <Welkin> dmj`: that is what I thought, but it seems bad
14:20:34 <dmj`> if you're in js, then you're already bad, if you want fast reuse declarations, do mutable things
14:20:42 <dmj`> use loops
14:20:59 <Welkin> it's the js ffi for elm
14:21:18 <dmj`> never used it
14:23:48 <mandeep> hi all. im interested in learning haskell, but before i dive in i was wondering if the ghc compiler still had speed issues
14:23:50 <ongy> does JS have useful enums? { constructor : Left|Right, value: 'foo' }. not sure which would be better 
14:24:06 <ongy> speed issues?
14:24:15 <dmj`> mandeep: yes, it's too fast at times
14:24:33 <mandeep> dmj`: wasnt there a time when it was really slow?
14:25:50 <dmj`> mandeep: are you talking about compilation speed?
14:25:52 <mandeep> yes
14:25:56 <mandeep> compile times
14:26:09 <dmj`> depends on how large your project is, you can always break things down into packages
14:27:01 <mandeep> dmj`: have compile times improved in the last year or so?
14:27:57 <geekosaur> winder if they are talking about the exhaustiveness checker bug in 8.0.1rc1
14:28:02 <geekosaur> not even a release version
14:28:10 * hackagebot Rasterific 0.7 - A pure haskell drawing engine.  https://hackage.haskell.org/package/Rasterific-0.7 (VincentBerthoux)
14:28:12 * hackagebot svg-tree 0.6 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.6 (VincentBerthoux)
14:28:14 * hackagebot rasterific-svg 0.3.2 - SVG renderer based on Rasterific.  https://hackage.haskell.org/package/rasterific-svg-0.3.2 (VincentBerthoux)
14:29:04 <dmj`> mandeep: what are you comparing it to?
14:29:17 <dmj`> mandeep: like, define 'slow'
14:29:22 <Tuplanolla> It takes some neglect, but you can still get GHC to spend a minute compiling a Repa module with the LLVM backend, mandeep.
14:29:50 <younder> Yes, the Haskell compliler is slow
14:30:06 <mandeep> dmj`: im not really comparing it to anything. the only compiler i have experience with is rust's, but i dont think that is a fair comparison
14:30:14 <mandeep> Tuplanolla: i see
14:30:30 <ongy> iirc with optimization rust compiler is really slow
14:30:36 <younder> I assume we are talking GHC
14:30:41 <mandeep> ongy: i havent experienced it yet, but maybe
14:30:47 <mandeep> younder: yep
14:31:38 <dmj`> mandeep: once you reach over a certain number of modules it can be, but at that point you have CI setup for your project I assume :] 
14:31:56 <mandeep> dmj`: good point :)
14:33:10 * hackagebot asciidiagram 1.3.2 - Pretty rendering of Ascii diagram into svg or png.  https://hackage.haskell.org/package/asciidiagram-1.3.2 (VincentBerthoux)
14:33:19 <dmj`> mandeep: builds are asynchronous
14:34:17 <younder> mandeep, use ghci for testing small changes rather that recompile the whole thing
14:34:48 <younder> mandeep, the emacs setup works pretty well
14:35:15 <mandeep> younder: that i heard about ghci. i use sublime personally and i bet there is a haskell setup for it
14:35:19 <mandeep> thanks*
14:38:10 * hackagebot amqp-worker 0.2.0 - High level functions for working with message queue  https://hackage.haskell.org/package/amqp-worker-0.2.0 (seanhess)
14:40:04 <DrEntropy> Is the haskell package (minimal) good to use for learning? Or should I use stack? It seems like stack is a bit more heavy weight.
14:40:35 <DrEntropy> I am not sure what to recommend any more :(
14:40:59 <dmj`> haskell platform?
14:41:08 <fr33domlover> DrEntropy, should probably use stack these days, afaik
14:41:38 <fr33domlover> it's not heavy, it's just a binary executable you can install
14:41:44 <fr33domlover> and it can then download GHC for you
14:41:48 <younder> DrEntropy, on ubuntu sudo apt install hasklell-platform, seems a good starting point. 
14:42:24 <DrEntropy> I use stack.. question is for newbies, should I recommend stack or the minimal platform for people wanting to learn. Seems like platform is more straightforward for workign through most books. 
14:42:34 <younder> DrEntropy, you really need Cabal
14:43:05 <glguy> DrEntropy: Once someone has the minimal platform they'll have stack and cabal-install available. Even when only using stack that's important because it enables the --solver functionality in stack
14:43:15 <fr33domlover> DrEntropy, bitemyapp has a githu8 repo with instructions for all the popular distros
14:43:20 <DrEntropy> good point glguy
14:43:24 <fr33domlover> iirc the general advice is to install stack
14:43:33 <fr33domlover> it's very very easy to use
14:43:41 <DrEntropy> ok stack it is  :) 
14:43:44 <younder> other than that the code has moved from darcs to github
14:46:04 <drninjabatman> hello! Could someone explain to me why the type variables are out of scope in this example? https://gist.github.com/9c7bb45464ea0135f279010116d10f12 
14:46:14 <drninjabatman> I am getting "Couldn't match type ‘m1’ with ‘(->) a1’"
14:46:38 <dcoutts> DrEntropy: most books assume most basic libs are already installed already, and either don't cover package management at all or cover it later on, so yes I'd say for most books having a basic haskell-plaform is the way to go. It allows learning about packages a bit later.
14:47:22 <drninjabatman> oh it's a language extension
14:47:25 <drninjabatman> damn
14:47:27 <Koterpillar> drninjabatman: do you want to flip (>>=)
14:48:36 <keutoi> @type (=<<)
14:48:38 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:48:49 <keutoi> @type (>>=)
14:48:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:49:17 <keutoi> drninjabatman: you are flipping arguments
14:49:26 <drninjabatman> that's also correct, I was trying to reproduce a simple example of an error that was resolved by enabling ScopedTypeVariables
14:49:55 <drninjabatman> thnx guys, sorry for not googling carefully enough
15:12:37 <GreenObsession> kidd on fire in #DataHoarder breaking it down large style #DataHoarder
15:24:37 <johnw> GreenObsession: relevant to #haskell how?
15:28:12 * hackagebot amqp-worker 0.2.1 - High level functions for working with message queues  https://hackage.haskell.org/package/amqp-worker-0.2.1 (seanhess)
16:01:21 <pikajude> might be a dumb question
16:13:14 * hackagebot type-operators 0.1.0.4 - Various type-level operators  https://hackage.haskell.org/package/type-operators-0.1.0.4 (Shou)
16:22:35 <EvanR> there are no dumb questions, only dumb people
16:24:32 <Welkin> does it make sense to upload a file using application/octet-stream instead of multipart/form-data ?
16:25:11 <heebo> i think most people use multipart
16:25:16 <Welkin> multipart/form-data encodes the file data as application/octet-stream anyway it seems
16:25:39 <zomg> changing the encoding from the typical one might affect any frameworks handling the file upload on the server
16:25:43 <zomg> beyond that not sure if it really makes any difference
16:25:46 <Welkin> I can't handle multipart/form-data in servant...
16:26:32 <Welkin> so I could upload the file first using octet-stream, then get the resulting url where it was uploaded and add that to the other metadata in the next post request as plain json
16:26:59 <Welkin> not sure if this is a bad way to do it
16:27:09 <Welkin> rather than submitting all the form data at once
16:53:15 * hackagebot alex-tools 0.1.1.0 - A set of functions for a common use case of Alex.  https://hackage.haskell.org/package/alex-tools-0.1.1.0 (IavorDiatchki)
16:54:46 <jle`> i need to draw random values from a large vector
16:54:56 <jle`> is it smart to just dump them into a priority queue with random weights
16:54:59 <jle`> this can't go wrong right
16:55:20 <Rembane> jle`: A Data.Vector vector?
16:55:38 <Welkin> use Random to get a random index
16:55:51 <ab9rf> jle`:only if you expect to use most or all of them
16:55:55 <Welkin> you can maintain a "visited" Set
16:56:49 <ab9rf> if you only expect to use a small number of them, and if you can access any given element in constant or near-constant time, it'll be cheaper to pick them randomly as needed
16:56:50 <jle`> Rembane: yup
16:57:16 <jle`> hm
16:57:23 <jle`> but then i'd have to maintain the list of visted indices
16:57:44 <ab9rf> which is why it's cheaper if you DO expect to visit most or all of them to do the PQ
16:57:45 <jle`> i actually intend to eventually use them all
16:57:57 <ab9rf> if you intend to visit all of them, the PQ is cheaper in the long run
16:58:20 <jle`> maybes but the idea of keeping a pqueue in memory is a little frightening
16:58:26 <jle`> s/keeping/keeping and forming
16:58:30 <ab9rf> you pay up front to build the PQ 
16:58:40 <jle`> true
16:58:44 <jle`> i might be scared for no reason
16:58:54 <ab9rf> otherwise, you have to have a visited-indexes set, which costs as much in space
16:58:54 <jle`> my vector fits into memory so the pq can't be that much bigger right
16:59:00 <ab9rf> and will cost more in time
16:59:31 <ab9rf> a good pq imple,entaiton is only like 4 words per element
16:59:42 <jle`> true
16:59:48 <jle`> i'm clearly overthinking things :)
17:00:49 <ab9rf> no, you're not
17:01:13 <ab9rf> the correct choice depends on your use case and you have to think that out to make the right choice
17:01:47 <jle`> it's unlikely this will be a bottleneck in my algorithm, so maybe i am overthinking this in this specific case :o
17:02:09 <jle`> but i appreciate the insight :)
17:02:29 <ab9rf> PQs are often a very reasonable choice :)
17:04:59 <jle`> alternatively i could just shuffle the vector in place and traverse it linearly
17:08:34 <ab9rf> shuffling will cost as much as building the pq
17:11:18 <jle`> true
17:12:09 <Rembane> jle`: Do you need to preserve the vector or can you destroy it?
17:12:53 <jle`> i can destroy it in principle
17:15:55 <Rembane> jle`: I was going to suggest doing some nifty hackery with Maybes, but I think a PQ is the right way to go or just shuffle the data and turn it into a list if you can justify the time it takes.
17:16:12 <jle`> yeah i'll just do the pqueue unless there are problems
17:16:17 <jle`> but thanks!
17:22:55 <heebo> i thought vector does some clever stuff not to avoid rebuilding the underlying array if you remove elements
17:23:23 <heebo> you may find that removing elements has little performance impact , or am i thinking about the wrong data structure?
17:23:44 <glguy> heebo: It can only do clever stuff if you drop from the beginning or the end of the vector allowing it to reuse the underlying array
17:25:00 <Clint> glguy: is it intentional that glirc fails to build without alex&happy installed?
17:25:34 <glguy> It's known that you have to have all the build-tools available to build it
17:26:18 * Clint squints.
17:27:15 <glguy> I don't really understand the question. At least one of its dependencies uses alex and happy to generate lexers and parsers
17:28:37 <Clint> glguy: okay, but it doesn't have a direct dependency on alex or happy and it expects TOOL_VERSION_whatever to be set
17:28:57 <glguy> glirc itself doesn't depend on alex or happy
17:29:35 <Clint> and if they are not installed it chokes on compiling those
17:30:30 <glguy> Yeah, you'll fail to build when you try to build the dependencies and don't have the build-tools that the dependencies declare available
17:31:33 <Clint> glguy: right, if i have the dependencies intalled and i don't have alex and happy installed it fails to build because it is expecting them to be there even though it isn't going to use them
17:31:39 <glguy> no
17:31:52 <Clint> i.. just ran into this the hard way
17:31:57 <glguy> If the dependencies are already installed them glirc doesn't care if alex or happy are availble
17:32:04 <Clint> it does
17:33:31 <glguy> ah, I see how that could happen
17:33:37 <Clint> glguy: chokes on https://github.com/glguy/irc-core/blob/v2/src/Client/Options.hs#L129
17:33:50 <glguy> Yeah, just got to that point
17:34:10 * Clint shrugs.
17:35:32 <glguy> pushed
17:39:31 <glguy> Clint: Why were you building it?
17:43:17 * hackagebot glirc 2.20.1.1 - Console IRC client  https://hackage.haskell.org/package/glirc-2.20.1.1 (EricMertens)
17:43:57 <Clint> glguy: i couldn't build anything newer than 1.1.5 until recently
17:48:17 * hackagebot tianbar 1.1.1.1 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-1.1.1.1 (AlexeyKotlyarov)
17:48:19 * hackagebot wolf 0.2.11 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.11 (markfine)
17:55:12 <athan> Hi everyone, anyone here know if async has the capability to kill its own thread?
17:55:20 <athan> er, an async thread
17:55:58 <athan> I'm naively using `forever` to spark a loop, now I need to break it :x
17:56:31 <glguy> throwIO
17:57:01 <athan> glguy: I just wouldn't use `link`?
17:57:06 <athan> thanks again :)
17:57:37 <pavonia> Isn't the cancel function what you want?
17:57:52 <athan> would using `myThreadId` and `threadKill` cause issues, you think?
17:58:04 <athan> pavonia: I'd like to use it inside the async closure
17:58:13 <athan> so something like `async $ forever $ do
17:58:16 <athan> er
17:58:21 <pavonia> Ah
17:58:27 <athan> self <- myThreadId; killThread self
17:58:38 <athan> but I'm not sure if killing threads screws with async internally
18:02:27 <Welkin> does that count as suicide?
18:04:46 <zq> what's the fixity of `function` calls?
18:05:03 <Welkin> what?
18:05:10 <Welkin> you mean function application?
18:05:17 <zq> sure
18:05:18 <Welkin> there are no function calls
18:05:28 <Welkin> it has the highest precedence
18:05:45 <athan> Welkin: :)
18:05:48 <athan> ):*
18:05:54 <Welkin> athan: lol, creepy
18:05:55 <athan> zq: super super tight
18:06:55 <zq> Welkin: i don't hink so
18:07:13 <zq> i seem to remember that infix-style application has lower precedence
18:07:28 <zq> which is what i'm asking, which is why i asked with backticks in the first place
18:07:40 <athan> zq: Backticks associate right, iirc
18:07:49 <athan> and are very wide, but not as wide as $
18:08:03 <zq> which is 7
18:08:18 <zq> maybe pay more attention to the backticks next time
18:08:27 <athan> ?
18:08:31 <athan> rofl wow
18:09:44 <glguy> athan, the answer for editing a thread is throw IO
18:10:10 <athan> glguy: But what if I'd like to `link` with other exceptions I'd like to throw? :(
18:10:50 <Welkin> what was his problem?
18:11:56 <glguy> that's fine
18:12:05 <athan> herp, okay so I could do something like this:
18:12:12 <glguy> exceptions are hire asunc killed threads too
18:12:30 <athan> `link myAsyncThread `catch` (\e | isIOError e -> pure ()) or something!
18:12:32 <athan> sweet, okay
18:12:35 <athan> thanks glguy :)
18:13:58 <geekosaur> @tell zq provided you are through with your mad: same as any infix. default 9, and you can use infix N `func`
18:13:58 <lambdabot> Consider it noted.
18:14:08 <geekosaur> er
18:23:18 * hackagebot pure-zlib 0.5 - A Haskell-only implementation of zlib / DEFLATE  https://hackage.haskell.org/package/pure-zlib-0.5 (AdamWick)
18:28:11 <geekosaur> @tell zq also consider that it's not that uncommon to use `` as code quotes the way various Markdown variants do, so you do need to clarify
18:28:11 <lambdabot> Consider it noted.
18:53:20 * hackagebot pipes-interleave 1.0.0 - Interleave and merge streams of elements  https://hackage.haskell.org/package/pipes-interleave-1.0.0 (BenGamari)
19:11:55 <glguy> ?tell athan undeclared operators default to infixl 9
19:11:55 <lambdabot> Consider it noted.
19:12:13 <khouli> hi people
19:12:21 <lambdabot> Hello.
19:15:32 <khouli> I'm a beginner with a question for the pros: what's the right way to wrap a C library that has getters and setters for an opaque pointer type? (the pointed to type can be copied)
19:17:48 <joe9> I want to run some IO tests after acquiring a socket https://github.com/joe9/9pserver/blob/master/test/Server/Tests.hs#L44 just want to check if it is possibel.
19:18:07 <joe9> I could just make all the tests into assertions and one big IO function.
19:18:12 <joe9> but, that would be ugly.
19:18:26 <joe9> Is it possible to have something like an IO TestTree or such with Tasty?
19:31:40 <dmj`> I see the docs mention SkipChan in Control.Concurrent.MVar, but it doesn't seem like there is a corresponding module for it
19:32:26 <supadupa> hello, was trying to write a simple logic tree execution model with caching and shortcircuiting and i gave up and ended up writing it in py3 for the moment. however i really want to see if i can replicate it in haskell. i have the model down and it works but i'm not sure how to implement the memoization nor the logging
19:32:30 <dmj`> proposal: Control.Concurrent.SkipChan
19:34:05 <supadupa> what type classes / patterns or whatever should i look into?
19:34:57 <grantwu> https://github.com/Gabriel439/post-rfc/blob/master/sotu.md says Haskell is best in class for writing compilers but
19:35:07 <grantwu> Being in the process of writing one I'm kind of not sure
19:35:14 <supadupa> this is the code in py btw http://ideone.com/SSau8a
19:35:29 <grantwu> Graph transformations are kind of icky in Haskell
19:35:43 <grantwu> A lot of the existing literature is phrased in imperative terms
19:35:55 <grantwu> Isn't GHC written in a somewhat imperative style?
19:36:29 <dmj`> grantwu: the runtime system would be
19:36:48 <Cale> Well, the runtime system is written in C, so...
19:37:17 <grantwu> No, I meant the actual compiler
19:37:30 <grantwu> I seem to remember someone saying that in this channel
19:37:30 <dmj`> it's written in haskell so probably not imperative style
19:37:39 <Cale> But for the rest of GHC, well, there's mutation going on in a lot of places, but I'd hesitate to say that it's not written in a functional style
19:37:46 <Cale> There's also a lot of pattern matching.
19:38:32 <pavonia> supadupa: Maybe have a look at the monad-logger package
19:38:35 <Welkin> software is all about writing to memory locations... so at some point, it's imperative
19:38:41 <Cale> heh
19:39:01 <Cale> No, it's all about getting electrons to move around in particular patterns
19:39:03 <supadupa> pavonia: i think i just solved that part by just using trace :grin:
19:39:28 <supadupa> im more worried about memoization, in OOP its really easy because each node can store its own value
19:39:42 <supadupa> mmm maybe i can use an either 
19:40:38 <supadupa> wait nvm, that wouldn't work. the idea is that the same node can be in different parts of the tree and you want to execute at most once
19:40:48 <Cale> supadupa: Generally for memoisation, you can use something like a constant table which is computed lazily
19:41:06 <supadupa> right.. its a bit ugly
19:41:16 <Cale> I think it usually turns out quite nicely.
19:41:46 <supadupa> im having a hard time picturing it.. i pass the cache around everywhere? and need to come up with some hash func too
19:41:56 <grantwu> You usually pay a log(n) tax, no?
19:42:14 <Cale> But it depends on how well you're able to control/understand the algorithm you're memoising -- if it's something like arbitrary client code, you might need some scheme using weak references.
19:42:26 <Cale> grantwu: Depends on what you mean by that...
19:42:43 <Cale> I mean, you can really just build an Array a lot of the time.
19:43:17 <Cale> Or: look at Data.MemoCombinators
19:44:51 <grantwu> Aren't non-mutable arrays expensive to update?
19:45:22 <ab9rf> grantwu: why would you say that?
19:45:23 <Cale> Why would you need to update?
19:45:35 <grantwu> If you use it as a memo table?
19:45:40 <ab9rf> there's no update
19:45:40 <Cale> You just set all the entries to the expressions you want to memoise
19:45:48 <ab9rf> you just replace an unevaluated thunk with an evaluated one
19:45:52 <supadupa> i still dont like the idea of a table :[
19:45:53 <ab9rf> that's not an "update"
19:45:59 <Cale> and there *is* an update of sorts, but it's just the one which is done by the lazy evaluator
19:46:13 <grantwu> Okay, that's not at all what I had in mind, but okay
19:46:26 <Cale> The first time any entry in the table is computed, it will be replaced by the final computed value (behind the scenes)
19:46:37 <ab9rf> grantwu: you have to stop thinking about this the way you would in an eager, procedural language. :)
19:46:38 <Cale> and on subsequent accesses, it won't need to be
19:46:45 <grantwu> ab9rf: ...
19:47:14 <Cale> supadupa: Well, what would you do in the OO setting?
19:47:16 <grantwu> What if you can't make an array of unevaluated thunks?
19:47:36 <ab9rf> such as?
19:47:45 <Cale> supadupa: If you want to just have an expression which gets computed lazily as part of many separate records, that's also quite doable...
19:48:18 <supadupa> only instantiate a node once, then use references. each node computes its value and when asked again pulls from its memoized evaluation
19:48:34 <Cale> Well, yeah, lazy evaluation will just do that for you
19:48:36 <grantwu> What if f x depends on other xs?
19:48:38 <ab9rf> supadupa: that's remarkably easy to implement
19:48:44 <supadupa> well i don't see how i would get single instances though
19:48:50 <grantwu> er rather, f x depends on f x' for some other x'
19:49:08 <glguy> grantwu: That's fine, you just look up (f x') in the table, too
19:49:18 <supadupa> Cale: lazy will make it evaluated only if needed.. but if evaluated again it will.. evaluate it again, no?
19:49:19 <ab9rf> as long as they're not mutually recursive
19:49:21 <glguy> The harder part is when the function's argument is something you can't enumerate, like a socket
19:49:26 <Cale> supadupa: no.
19:49:30 <ab9rf> but if they are you'll ahve problems in any case :)
19:49:36 <grantwu> glguy: Okay, so once you computer f x, you want to store the result in your table, right?
19:49:51 <grantwu> *compute
19:50:06 <supadupa> i don't get it, so everything is memoized by default?
19:50:11 <Cale> supadupa: The other part of lazy evaluation is that any single variable, and any field of a data constructor, will be evaluated at most once, and the results of that evaluation shared between the uses.
19:50:11 <glguy> grantwu: You put the expression (f x) into the table. It gets computed if it is later needed
19:50:18 <Cale> supadupa: Not *everything*
19:50:25 <lyndon> Does anyone know how to split a machine into two sources (in machines library)?
19:50:26 <ab9rf> no, only what you program it to memoize
19:50:28 <Cale> supadupa: Only variables, and the fields of data constructors.
19:50:45 <ab9rf> oh, lazy evaluation
19:50:49 <Cale> supadupa: Functions are not memoised by default, because that would result in nothing ever being garbage collected.
19:50:50 <supadupa> let me paste some code
19:50:52 <lyndon> I want to use a Tee, but have it draw from one split source
19:51:47 <supadupa> http://lpaste.net/7521878514425921536
19:51:57 <grantwu> Sometimes you don't want to pay the cost of a thunk per memotable entry, though
19:52:35 <ab9rf> grantwu: how so?
19:52:35 <Cale> grantwu: that's true, but you can build stuff that extends the table dynamically :)
19:52:44 <grantwu> ab9rf: Thunks cost memory?
19:52:58 <ab9rf> grantwu: so use a Map and only insert keys for values you've actually evalauted.
19:53:07 <supadupa> ok so basically, i would want that to only print once
19:53:13 <grantwu> ab9rf: And you're paying for log n access time
19:53:21 <Cale> supadupa: Okay, let's try memoising this using Data.MemoCombinators
19:53:27 <ab9rf> grantwu: you are with the OO solutiojn as well
19:53:37 <grantwu> ab9rf: How so?
19:53:37 <supadupa> i checked that pkg, didnt find the doc
19:53:45 <ab9rf> grantwu: a cache?
19:53:52 <ab9rf> same penalty
19:54:18 <supadupa> nvm found it
19:54:18 <ab9rf> i suppose you can bound it if you use a fixed-sized cache but then you can't guarantee that you won't recompute
19:54:20 <grantwu> As I understood supadupa's thing, he was just using pointers to objects
19:54:26 <jle`> is there some type of 'arr' for foldl's Fold ?
19:54:33 <ab9rf> but you can do that in haskell with a memo as well, it's just vaguely harder
19:54:36 <jle`> mapping :: (a -> b) -> Fold b a
19:54:48 <ab9rf> because you're intentionally coding it to be stupid :)
19:54:51 <jle`> er, mapping :: (a -> b) -> Fold a b
19:55:08 <jle`> kind of like 'arr' from Control.Arrow
19:55:24 <jle`> mapping f = purely (:) [] f, i suppose
19:55:36 <grantwu> Who is intentionally coding something to be stupid...?
19:55:44 <jle`> er wait no
19:56:24 <ab9rf> in any case, this all smells like premature optimization
19:56:40 <ab9rf> write the code to be correct first, then make it fast
19:56:53 <jle`> mapping f = Fold (:) [] f, but it'd be nice if this was a thing
19:58:01 <ab9rf> jle`: lambdabot doesn't like Fold (:) []
19:58:21 <jle`> :t Fold
19:58:22 <lambdabot> Fold s a -> ReifiedFold s a
19:58:30 <jle`> er, where is that from?
19:58:33 <ab9rf> no idea :)
19:58:55 <grantwu> The last time I thought something was premature optimization, I ended up using 16 GB of memory -_-
19:59:05 <grantwu> I really do need to submit a bug report to Megaparsec, sigh
19:59:26 <jle`> @let data Foldl a b = forall x. Foldl (x -> a -> x) x (x -> b)
19:59:27 <lambdabot>  Defined.
19:59:39 <jle`> @let mapFold f = Foldl (:) [] f
19:59:41 <lambdabot>  .L.hs:184:19: error:
19:59:41 <lambdabot>      • Occurs check: cannot construct the infinite type: a ~ [a]
19:59:41 <lambdabot>        Expected type: [a] -> [a] -> [a]
19:59:47 <jle`> oh
20:00:12 <jle`> maybe what i'm thinking of is not possible
20:00:26 <jle`> now that i think about it
20:01:18 <jle`> i see the light
20:01:40 <ab9rf> is there a roadrunner running in front of it?
20:02:31 <jle`> maybe, it's still a little hazy
20:02:31 <supadupa> Cale: im not sure i understand how to use it, I tried sticking Memo.Bool and im getting some type errors I don't get
20:02:43 <lpaste> Cale pasted “Memo table for tree structure” at http://lpaste.net/302716
20:02:50 <Cale> supadupa: ^^
20:03:09 <Cale> supadupa: It's somewhat non-obvious unless you read the source code for the library and understand the trick that it uses
20:03:23 <Cale> You might want to first look at the implementation of 'bool
20:03:28 <Cale> 'bool' or 'either'
20:03:54 <Cale> The definition of memoTreeNode might seem fancy, but it's quite mechanical
20:04:35 <supadupa> its not fancy at all.. its quite hideous :P
20:04:38 <Cale> What we're doing is making use of the fact that once computed, the functions which occur as arguments to table will remain in a computed state.
20:04:39 <supadupa> thanks, i'll take a look
20:04:53 <Cale> (because they are bound to variables)
20:05:16 <Cale> memoTreeNode will memoise any function of a TreeNode argument
20:05:22 <supadupa> i was trying to stick Memo to each of the pattern matching branches instead of the function as a whole
20:05:50 <supadupa> but memo works at the function level, makes sense
20:06:45 <Cale> Memo.list will take a memoizer for functions of values of some type, and turn it into a memoizer for functions of lists of values of that type
20:07:49 <Cale> So you can sort of exploit the mechanism of lazy evaluation to memoise almost any function (so long as you can decompose the domain nicely)
20:09:16 <Cale> Of course, this whole mechanism is of questionable value here -- doing lookups in the table is going to be more expensive than recomputing this function sometimes.
20:12:45 <Cale> Now, if you really wanted to, there are other, more low-level schemes for, e.g. noticing that those occurrences of some_leaf are pointing at the same thing
20:12:48 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/System-Mem-StableName.html
20:12:53 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/System-Mem-Weak.html
20:13:11 <nitrix> https://hackage.haskell.org/package/extensible-effects
20:13:18 <nitrix> Whao, extensible effects looks amazing.
20:13:57 <nitrix> Anyone with experience with them can related to monad transformers and how they compare?
20:14:07 <nitrix> To me it seems like a huge, huge improvement.
20:14:08 <johnw> the paper about it does a comparison
20:14:36 <nitrix> johnw: I know what I'll read tonight :]
20:15:16 <Cale> nitrix: It's... okay I suppose?
20:16:28 <xkapastel> i don't know if this is the right place to ask, but does anyone have information on how to encode typechecking/type inference as a probabilistic program?
20:16:52 <supadupa> Cale: i changed Leaf to take another parameter (a String, to use as ID) and now I can't get memo to work.. tried changing the LeafN to use Memo.memo2 but it doesn't really typecheck
20:16:52 <Cale> xkapastel: Trivially, as one would any deterministic program?
20:17:19 <xkapastel> Cale: i was hoping to replace the use of unification with probabilistic primitives
20:17:58 <roboguy`> xkapastel: as in, unification could succeed/fail incorrectly sometimes?
20:17:58 <ab9rf> i don't understand why you would want to do typechecking probabalistically
20:18:33 <ab9rf> except, i suppose, in order to provide "best effort" solutions to NP-hard or uncomputable typechecking problems in bounded time
20:18:49 <supadupa> ah i think i know what's wrong, nvm
20:18:50 <xkapastel> http://okmij.org/ftp/kakuritu/logic-programming.html makes an argument for using probabilistic programming instead of logic programming, and solves several classic logic programming puzzles w/ a probabilistic programming library
20:18:59 <xkapastel> i was wondering if this could be extended to more of the usual uses of logic programming
20:19:12 <Cale> supadupa: You'd want something like (Memo.memo2 Memo.bool (Memo.list Memo.char) (\b s -> f (Leaf b s))
20:19:19 <supadupa> exactly
20:19:24 <ab9rf> but i'd still be left with the nagging suspicion that the program isn't provably correct and could well just spit out random nonense
20:19:44 <xkapastel> you don't write must javascript i take it ;)
20:19:46 <xkapastel> much*
20:19:50 <ab9rf> xkapastel: not if i can help it :)
20:20:13 <ab9rf> it's been almost a decade since i touched javaspit
20:20:59 <xkapastel> "Logic variables, unification, and its WAM compilation strategy naturally emerge as a ``mere optimization'' of the Herbrand universe enumeration.", but oleg doesn't do anything like type inference on this page
20:21:12 <Cale> xkapastel: I suppose it might be helpful if there would be cases where you could somehow rapidly come to a definite conclusion that something will never typecheck, but only provide a probabilistic result in the case where it does, for instance.
20:21:21 <supadupa> fantastic
20:21:31 <supadupa> thanks a lot for the help @ Cale 
20:21:36 <Cale> supadupa: no problem :)
20:22:11 <roboguy`> my first instinct is that type checking is one of the last things I'd want to be probabilistic, but it also feels like I might be missing some potential that could exist in that
20:22:20 <supadupa> i'll still use the python version to show the mock to my boss (since it would be implemented in java).. but implementing this in haskell was a really nice excercise
20:22:21 <Cale> supadupa: This kind of thing might not scale in an ideal way, and might not always get you 100% of the performance you want, but it's a nice hammer to be able to apply quickly to things.
20:22:33 <supadupa> gotcha
20:22:44 <Cale> Of course, you can still do the imperative thing in Haskell -- it's just... that's no fun :)
20:22:51 <xkapastel> huh, maybe i was wrong about oleg not doing it: http://okmij.org/ftp/kakuritu/type_inference.ml
20:23:17 <umib0zu> Hi all. I’m having a problem installing a package using cabal. I get an error saying it can’t find the package within a specified range cannot be found.
20:23:35 <umib0zu> how do I debug this? I go on hackage and there exist package versions within that range
20:24:30 <johnw> it may be that it can't use any version within that range, because of version dependencies from other packages
20:24:53 <Cale> umib0zu: which package?
20:25:27 <umib0zu> Cale alex. I’m trying to run an cabal install on the hackage-server
20:26:24 <Hijiri> looks like I won't be able to contrast liquidhaskell with theorem proving languages anymore http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2016/09/18/refinement-reflection.lhs/
20:26:27 <Cale> Well, there must be some coherent story about it! :)
20:27:07 <umib0zu> Am I allowed to post error outputs?
20:27:14 <Cale> lpaste.net
20:27:20 <Koterpillar> @where paste
20:27:20 <lambdabot> Haskell pastebin: http://lpaste.net/
20:28:25 <umib0zu> Cale http://lpaste.net/302735
20:29:06 <Cale> umib0zu: ohhh
20:29:14 <Cale> umib0zu: Try just installing alex beforehand
20:29:59 <Cale> umib0zu: Cabal isn't good at executable dependencies.
20:30:47 <Cale> umib0zu: unless it's already installed?
20:30:54 <umib0zu> not likely
20:31:04 <umib0zu> I’m also doing this in a sandbox assuming it will work
20:32:37 <umib0zu> ah this might be the haskell version I’m using
20:33:04 <umib0zu> http://lpaste.net/302736
20:33:14 <umib0zu> it’s asking for something related to haskell 98
20:33:34 <umib0zu> is this a version issue with the compiler I’m using?
20:36:43 <joe9> Is it possible to start an async thread redirecting it's stdout and stderr?
20:37:01 <Axman6> no, those handles are application specific
20:41:54 <joe9> Axman6: other than having to redirect to a logger thread, is there a better way of doing the redirection of stdout and stderr https://github.com/joe9/9pserver/blob/master/test/Spec.hs#L19?
20:42:23 <joe9> Axman6: I am writing some tests to test out my server process which generates output (traceShowId, etc) to help in debugging.
20:43:00 <joe9> Axman6: if it was for the main app, then I would happily write the logger thread and the related code. but, it would be cumbersome to do it for tests.
20:43:07 <joe9> Axman6: Any suggestions, please?
20:45:45 <sgronblo> Shouldn't it work to specify the location of the docker-compose.yml file with -f when running docker-compose up?
20:47:09 <Axman6> joe9: if you're specifically after logging, then you should use a logging framework such as fast-logger, which does pretty muche xactly what you're describing
21:08:26 * hackagebot curryrs 0.2.0 - Easy to use FFI Bridge for using Rust in Haskell  https://hackage.haskell.org/package/curryrs-0.2.0 (mgattozzi)
21:09:24 <jle`> hi everyone
21:09:59 <jle`> how can i represent unification with a certain constructor as a constraint? (when using data kinds)
21:10:43 <jle`> for example, data N = Z | S N, is there any way i can get a constraint that there exists some m s.t. (n :: N) ~ S m ?
21:10:56 <jle`> or do i just have to write a dummy typeclass
21:13:09 <jle`> ooh i got it
21:26:00 <lyndon> I'm considering using Bound to implement an EDSL that has to be able to be parsed/serialized easily, but I want the language to be able to express side-effects as well as pure expressions
21:26:01 <orion> What does ~ mean?
21:26:21 <lyndon> Is there an example of using Bound to express effectful programs?
21:27:09 <RADONE> Hey guys 
21:27:15 <lyndon> Would it be as simple as adding a "Do" term to the lambda-calculus example?
21:27:32 <sham1> Hi RADONE 
21:28:11 <jle`> orion: it creates a constraint that constrains that both sides are the same type
21:28:22 <RADONE> I am beginer in haskell, and got stupide error that I cannot understand
21:28:33 <jle`> @let safeCoerce :: (a ~ b) => a -> b
21:28:34 <lambdabot>  .L.hs:178:1: error:
21:28:34 <lambdabot>      The type signature for ‘safeCoerce’ lacks an accompanying binding
21:28:36 <jle`> oops
21:28:41 <jle`> @let safeCoerce :: (a ~ b) => a -> b; safeCoerce = id
21:28:41 <sham1> :P
21:28:43 <lambdabot>  Defined.
21:28:52 <jle`> RADONE: post it and we'll look at it :)
21:28:54 <jle`> @where lpaste
21:28:54 <lambdabot> http://lpaste.net/
21:29:07 <RADONE> thanks JLE:
21:29:44 <RADONE> I have this simple file.hs
21:29:51 <RADONE> halve list =   let size = length list   round (size/2)
21:30:20 <sham1> For one, you might want to have a in there
21:30:22 <sham1> As in
21:30:33 <sham1> let size = length list in round (size/2)
21:30:47 <RADONE> and got error with round
21:30:48 <RADONE> error: parse error on input ‘round’
21:31:10 <RADONE> (oups sorry for the formatting) 
21:31:46 <sham1> Mind pastebinning that code so we may inspect it ourselves
21:32:14 <RADONE> https://gist.github.com/anonymous/c28e17e67537b35c02311704cd978633
21:32:59 <sham1> Yeah
21:33:08 <sham1> the correct line of code would be
21:33:22 <bollu> Quick question about hom functor:
21:33:24 <sham1> halve list = let size = length list in round(size/2)
21:34:21 <johnw> how about: size `div` 2
21:34:33 <johnw> avoid the needless floating-point value
21:35:13 <sham1> That would also work
21:38:48 <RADONE> nice didn't know the use of `div`
21:42:29 <RADONE> but still the line you gave didn't work /notice sham1
21:42:59 <RADONE> I am using `div`
21:43:31 <Koterpillar> RADONE: what does your code look like now?
21:47:55 <RADONE> https://gist.github.com/anonymous/cc579515768783af8f75208dd8a13a81
21:48:15 <johnw> "n ="
21:50:26 <RADONE> yep <johnw> 
21:50:29 <RADONE> https://gist.github.com/anonymous/0e2038221b77f74b5b7dafcbe645aa05
21:51:00 <RADONE> @johnw
21:51:00 <lambdabot> Not enough privileges
21:51:19 <johnw> btw, that function already has a name :)
21:51:29 <Koterpillar> RADONE: does that compile now?
21:51:49 <RADONE> yes Koterpillar
21:51:51 <RADONE> thanks 
21:53:02 <RADONE> (Johnw it's an exercice from Programming in Haskell 2nd Edition)
21:53:35 <RADONE> What is the name of this function I am curious to see the source code
21:57:29 <johnw> well, the one I'm thinking of takes the location to split at (hint, hint) as an argument; yours chooses the middle of the list
21:57:34 <johnw> so I don't think it actually exists in that form
22:05:14 * dmj` <3 skip chans
22:10:44 <lyndon> Does anybody know what stack lts is required for bound to work?
22:18:28 * hackagebot bitcoin-payment-channel 0.6.0.0 - Library for working with Bitcoin payment channels  https://hackage.haskell.org/package/bitcoin-payment-channel-0.6.0.0 (runeks)
22:19:41 <Lokathor> http://lpaste.net/302852
22:19:46 <Lokathor> why would haddock crash like this?
22:20:11 <Lokathor> the file in question looks like this: https://github.com/Lokathor/fullainth/blob/master/lib/UI/Curses.hs
22:23:10 <Cale> Lokathor: what happens if you remove the | from the comment block immediately preceding that?
22:24:37 <Lokathor> oh cripes that's probably it
22:24:38 <Lokathor> let's see
22:25:01 <Cale> Lokathor: I think only certain declarations are allowed to be documented in that way. For structural documentation, you can give an explicit export list and add comments to that like in https://www.haskell.org/haddock/doc/html/ch03s04.html
22:25:40 <Lokathor> yeah it works now. And I don't need the comment to be haddocked i suppose
22:28:02 <Lokathor> i'm gonna try and make the better version that uses types to disallow illegal states :3
23:24:50 <Ainieco> hello
23:25:30 <Ainieco> is it possible to use ghci-ng with ghc 8.0.1?
23:25:43 <Ainieco> seems line ghci-ng is fairly outdated, are there alternatives?
23:26:36 <MarcelineVQ> idk, the docs say at the top "NOTE: The feature-set of ghci-ng-10.0.0 has been merged back upstream and is therefore available in GHCi 8.0 proper!" :>
23:27:03 <Ainieco> > Dependencies array, base, bytestring, containers, directory, filepath, ghc (>=7.8 && <8)
23:27:05 <lambdabot>  <hint>:1:19: error: parse error on input ‘,’
23:27:10 <Ainieco> > ghc (>=7.8 && <8)
23:27:12 <lambdabot>  <hint>:1:15: error: parse error on input ‘<’
23:27:16 <Ainieco> MarcelineVQ: ^
23:28:47 <Ainieco> hm, seems like https://github.com/chrisdone/ghci-ng leads to https://github.com/commercialhaskell/intero now
23:30:28 <MarcelineVQ> It may be possible to build ghci-ng by downloading the source and relaxing the upper bound on ghc in the cabal file, but the line at the top seems to be saying it's redundant since ghc8's ghci will do what this does
23:31:14 <Ainieco> oh, i didn't read the line properly
23:31:19 <Ainieco> MarcelineVQ: my apologies
23:31:37 <orion> Is it possible to easily convert a "Request -> (Response -> FooAppEnv ResponseReceived) -> FooAppEnv ResponseReceived" to exactly the same thing, but with "FooAppEnv" replaced with "IO"?
23:31:54 <MarcelineVQ> I'd have been more specific but I've not actually used ghci ng at all
23:31:55 <orion> Given that FooAppEnv derives MonadIO./
23:36:55 <jle`> i was about to define a type synonym for a constraint that a type is both Floating and Real
23:36:59 <jle`> and i was going to call it FloatReal
23:37:02 <jle`> but then i realized
