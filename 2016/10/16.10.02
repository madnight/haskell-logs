00:44:07 <Myrl-saki> ertes: hold works on rec..
01:10:29 <Myrl-saki> ertes: I found another symptom.
01:11:02 <Myrl-saki> ertes: I changed the definition of holdFor and it started working.
01:11:44 <jluttine> Hi, I'm new to haskell and I'd like to understand one thing: How are typeclasses and their inheritance (e.g., Monoid, Functor, Applicative, Monad) better than using interfaces and inheritance for instance in Java/C++/Python? If we use interfaces, inheritance and immutable objects in object oriented programming, isn't it practically the same thing? Of course, Haskell syntax is extremely convenient.
01:12:35 <Myrl-saki> :t max
01:12:36 <lambdabot> Ord a => a -> a -> a
01:17:39 <mauke> jluttine: that applies (sort of) to simple stuff like Show
01:17:50 <mauke> jluttine: for more interesting cases consider Eq and Read
01:17:55 <mauke> and Bounded
01:18:49 <mauke> (==) :: (Eq a) => a -> a -> Bool
01:19:02 <mauke> this type signature ensures that the two arguments have the same type
01:19:30 <mauke> read :: (Read a) => String -> a
01:19:45 <mauke> here the result type determines which implementation of read to use
01:21:07 <Rarrikins> Another good feature is that you can easily specify a requirement for multiple typeclasses on a type at the same time. In something like Java, you'd have to use something ugly like instanceof to check all but one of the interfaces.
01:22:28 <Rarrikins> You can also add typeclass implementations to types you didn't write.
01:23:32 <mauke> you can write, say, (Num a) => ... [a] ...
01:23:40 <mauke> and you know all elements of that list have the same type
01:25:27 <fractalcat> writing instances for types you didn't write is generally not a great practice though - wrap the library type in a newtype first, then implement the instance for your newtype.
01:25:59 <mauke> why?
01:26:16 <mauke> it's fine if you're the author of the class
01:27:26 <fractalcat> mauke: it is fine if you're the author of the class. just wanted to clarify as Read, Show et cetera were being used as examples.
01:31:40 <rmrfroot> jluttine: coming from python, for me, one important practical difference is that in Haskell I also know what kind of effects a function has, besides the type of it's output. For example if I have a function that takes a String and splits it up into a list of Strings, I know what that function can't modify the state of the program somehow. It only can modify the input I gave it. In python I can have a function that says it does the same
01:31:40 <rmrfroot> thing, but it can also modify members values in the object or even touch the filesystem. It's just no way I can be sure, unless I see the actual source code. 
01:33:33 <koz_> Yep, the descriptiveness of Haskell's type system is pretty amazing.
01:33:55 <koz_> It allows for a level of abstraction other languages can only dream about.
01:37:17 <koz_> I'm using a record to store function parameters (six now, but many more yet to come). Is there an alternative? Constructing this thing is already a PITA, and it's only gonna get worse.
01:47:07 <fractalcat> koz_: if possible, split the function up into bits which need fewer parameters. sometimes you need to use a record; one thing which can make it easier is using a default value which can be modified using record constructors, like e.g., Request in http-client.
01:47:21 <fractalcat> defaultFoo :: Foo
01:47:27 <fractalcat> defaultFoo { fooBar = baz }
01:48:47 <koz_> fractalcat: I'll try and think of how best to do that, then.
01:56:29 <DenisL> Hi, everybody!
01:57:25 <DenisL> it's been told by functional gurus that's mainstream languages are way behind functional ones in therms of ideas.
01:58:23 <DenisL> for example. garbage collection 60x, higher-order functions - 40 years ago etc...
01:59:10 <DenisL> mainstream languages just recently starts to accepting ideas which were developed quite a while ago 30-50 years from now.
01:59:29 <DenisL> Philip Wadles likes to mention it in his talks
01:59:58 <DenisL> and others gurus also
02:00:51 <DenisL> does anybody follow me? I have a question regarding all this.
02:01:00 <koz_> DenisL: What's your question?
02:02:38 <DenisL> what ideas developed just now (in the present time) which looks promising and we will need another 40 years to make them widespreading
02:02:40 <DenisL> ?
02:03:00 <koz_> DenisL: Free monads, probably.
02:03:06 <koz_> Lenses too, I'd guess.
02:03:14 <DenisL> like lambdas (were developed by Church in 40x and only now languages starts to accept it
02:03:44 <koz_> DenisL: Lambdas have been around for a very long time in many languages. If you refer to the mainstream, that can change at the drop of a hat.
02:03:50 <jle`> hm, it's hard to really say
02:04:05 <jle`> it's hard to predict even past a few years
02:04:18 <yarou> if x != null && if y != null && z != null, then ...
02:04:41 <yarou> swift still has this paradigm btw
02:04:52 <DenisL> but academisc predict that higher order functions is quite useful back in the LISP time
02:05:25 <jle`> DenisL: a lot of new haskell ideas often are just explored and then found out to be not useful or not a good road
02:05:28 <lpaste> koz_ pasted “jle`: Is there a better way to do this?” at http://lpaste.net/237107
02:05:45 <jle`> a lot of things that might look good in theory
02:05:52 <yarou> lambdas have been around since javascript lel
02:06:05 <yarou> func keyword is lambda
02:06:09 <koz_> yarou: A *lot* longer than that.
02:06:17 <jle`> what is nice about Haskell is that it's a nice place where language ideas and features can be tried out and tested and mature over the course of several years
02:06:35 <yarou> koz_, ok, ALGOL whatever 
02:06:48 <jle`> so, talking about things that are being developed *just now* (within the past month or so?) might be the wrong question
02:06:58 <yarou> who actually used ALGOL in prod, probably not many ppl
02:07:02 <jle`> or it might be hard to answer, heh
02:07:05 <jle`> in a meaningful way
02:07:16 <koz_> yarou: I'm pretty sure various flavours of Lisp also had lambdas.
02:07:25 <koz_> And those *were* used 'in production', whatever the hell *that* means.
02:07:37 <DenisL> just now means it a couple of decades )))
02:07:44 <jle`> oh, ah
02:07:55 <jle`> heh, things move a lot faster than that in haskell heh
02:07:56 <yarou> koz_, clojure is the only production lisp i know of
02:08:16 <jle`> things that have been maturing over the past couple of decades is something that you could probably answer in a meaningful way
02:08:20 <koz_> yarou: Sure, and back in the 80s, things were *very* different.
02:08:22 <jle`> well, Haskell itself isn't even two decades old lol
02:08:32 <jle`> er, wait
02:08:34 <jle`> yes it is
02:08:35 <yarou> koz_, i was born in the 80s, so i don't pretend to know what madness happened back then :p
02:08:36 <jle`> i'm old v.v
02:08:45 <koz_> You know, small companies like Symbolics.
02:08:56 <koz_> yarou: Then stop making claims about the history of computing. :P
02:09:11 <DenisL> yarou: Autocad has a lisp as a scripting language since very beginning i guess
02:09:14 <koz_> (I was born in the 80s as well, but I don't pretend like all history of 'production languages' began at my teenage years)
02:09:25 <koz_> DenisL: Also, small governmental organizations like NASA. :P
02:09:35 <yarou> i consider Java a production language tbh f a m 
02:09:57 <koz_> jle`: I think Haskell is as old as I am.
02:10:04 <int-e> it does produce a lot of pain
02:10:08 <koz_> (it kinda began in '87, no?)
02:10:46 <yarou> the problem is that desktop coders freeze when it comes to embedded
02:11:26 <yarou> they write their shit as if it has unlimited memory
02:11:29 <yarou> unlimited power
02:11:34 <yarou> unlimited cpu, etc
02:11:36 <koz_> yarou: Recent habit, I assure you.
02:11:45 <yarou> koz_, probably :)
02:11:52 <koz_> yarou: *Certainly*.
02:12:51 <DenisL> so, free monads, lenses
02:12:59 <DenisL> π-calculus maybe, no?
02:13:11 <DenisL> any other ideas or theories?
02:13:39 <yarou> goto label
02:13:51 <DenisL> )))
02:14:08 <DenisL> in functional programmig it's called continuations, isn't it?
02:15:02 <yarou> sure, even ruby has call/cc 
02:15:39 <koz_> And Scheme had those way before that. :P
02:28:48 <jle`> is there any way i can see what parameters TypeApplications is expecting for a given function and in what order?
02:33:50 <rmrfroot> anyone with HaLVM /join #linux
02:33:53 <ahihi> jle`: you'd think ghci would have a way to always show foralls in type signatures... but I can't find it
02:34:01 <jle`>  :i seems to help
02:34:27 <rmrfroot> sorry, what I wanted to say was "anyone with HaLVM experience that can tell me why it will only run on XEN?"
02:34:39 <rmrfroot> Then I wanted to join the #linux channel :P 
02:36:39 <rmrfroot> I thought the idea of VMs was that they don't care what hypervisor was running them, hence the "virtual" part of the name
02:53:14 * hackagebot doctemplates 0.1.0.1 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.1.0.1 (JohnMacFarlane)
03:06:40 <haasn> rmrfroot: Each hypervisor has its own way of creating virtual devices
03:39:47 <jonkri> OK, bug found... so using DATE 'today' when creating a view "hardcodes" the date into the view. :> Should I use now()::date instead?
03:41:09 <ongy> jonkri: are you sure you wanted to ask that in this channel?
03:41:30 <jonkri> ongy: Oh, thanks. :) Thought I was in #postgresql. :)
03:45:17 <wuerdo> max 'a' '1'
03:45:37 <wuerdo> why does " max 'a' '1' " give the answer as 'a' ?
03:46:36 <lyxia> because the code point of 'a' is greater than the code point of '1', I guess
03:47:02 <Dongstein> it gives me l
03:47:08 <Dongstein> 'l'
03:47:44 <lyxia> > max 'a' '1'
03:47:47 <lambdabot>  'a'
03:48:06 <lyxia> > max 'a' 'l'
03:48:06 <wuerdo> > max 'a' 'l'
03:48:09 <lambdabot>  'l'
03:48:09 <lambdabot>  'l'
03:48:14 <lyxia> first
03:48:19 <wuerdo> Haha
03:48:30 <trampi> >max 'a' '1'
03:48:33 <Dongstein> oh, that's a one
03:48:38 <trampi> > max 'a' '1'
03:48:40 <lambdabot>  'a'
03:49:10 <wuerdo> So what's happening here? 1 is of type class Num, which is also in Ord...?
03:49:18 <trampi> 'a' -> 97; '1' -> 49
03:49:20 <lyxia> > ord <$> "1al"
03:49:22 <lambdabot>  [49,97,108]
03:50:03 <lyxia> wuerdo: you're confusing 1 the number and '1' the character
03:50:35 <wuerdo> How is Haskell able to order the characters 'a' and '1'?
03:52:14 <mauke> > [' ' ..]
03:52:16 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
03:53:12 <lyxia> standards like ASCII and Unicode assign numbers to characters, because in the end a machine deals with numbers in the form of bytes.
03:53:15 * hackagebot doctemplates 0.1.0.2 - Pandoc-style document templates  https://hackage.haskell.org/package/doctemplates-0.1.0.2 (JohnMacFarlane)
03:54:26 <wuerdo> Okay thank you
03:54:32 <Dongstein> how do I figure out what a data constructor does in GHCI
03:55:16 <lyxia> Dongstein: show its type :t Constructor
03:55:46 <Dongstein> it just tells me it's not in scope
03:56:05 <Dongstein> wait
03:56:18 <lyxia> okay, then you must first import a module that exports it.
03:56:23 <wuerdo> whats the difference between value constructors and data constructors again?
03:56:57 <lyxia> wuerdo: I think they refer to the same thing
03:57:48 <lyxia> data constructors are sometimes contrasted with type constructors
03:58:25 <lyxia> The former construct runtime values, the latter construct types.
04:34:35 <jluttine> do i need to use (or can i use) something like virtualenv in python with haskell? or what is the correct haskell way of dealing with different environments? i don't quite understand how "stack install ..." works.. it installs the package to my local home directory but what if i sometimes want to use ghci to play with package X and sometimes with package Y, and these packages have conflicting dependencies?
04:35:19 <jluttine> how ghci knows what i want? i'd expect i need to activate some environment first
04:35:54 <srhb> jluttine: afaik Stack works by modifying which packages are in the ghc pkg-db for a given project
04:36:10 <srhb> jluttine: Where the packages are actually located is less important, and they're kept in one place in order to avoid duplication.
04:36:59 <jluttine> srhb: ok, that's nice. if i run ghci outside any project, how does it know which packages are available?
04:37:26 <NickHu> Stack keeps a global environment too jluttine 
04:37:35 <srhb> jluttine: In a similar vein I use Nix to spin up various ghc versions with various packages enabled. It looks basically like: nix-shell -p "pkgs.haskell.packages.ghc801.ghcWithPackages (pkgs: with pkgs; [ lens aeson ])"
04:37:44 <NickHu> There's also the separate cabal environment too.. It's a big historical headache
04:39:01 <srhb> NickHu: The old style cabal sandboxes are local to the project, aren't they?
04:39:05 <srhb> ie. no sharing.
04:39:05 <jluttine> so if i just run "stack install foobar" outside any project then foobar will be install to my global environment? but if i'm inside some project directory, then it'll be installed only for that project?
04:39:40 <NickHu> srhb: I was talking about ~/.cabal
04:39:47 <srhb> jluttine: That sounds about right, though I'm not entirely sure if you can actually modify the project local packages on the fly like that, or only via the stack setup. (I don't use Stack)
04:39:51 <srhb> NickHu: Ah :)
04:40:23 <srhb> There's also cabal-installs new-build which _does_ share globally.
04:41:35 <jluttine> srhb: ok, thanks
04:41:43 <jluttine> got ihaskell notebook working.. <3
04:41:46 <srhb> jluttine: There are many options! :-)
04:42:01 <jluttine> oh, wait, didn't.. :(
05:44:46 <Darwin226> If I have a class `class C (syms :: [Symbol])` and I define an instances for both '[] and (sym ': syms) is there a way to write a function that uses this class but doesn't have it in it's context?
05:44:53 <Darwin226> Since every possible instance is defined
05:51:51 <jluttine> can i somehow reset my global stack environment?
05:53:17 * hackagebot patat 0.1.0.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.1.0.0 (JasperVanDerJeugt)
05:56:16 <lyxia> Darwin226: nop
05:56:45 <Darwin226> lyxia: I'm guessing the same reasons why you can't discard typeable?
06:01:03 <ashishnegi> hi.. i am trying to run this code https://github.com/ashishnegi/sanskell/blob/master/ui/GenerateElm.hs#L7  this is giving me `GenerateElm.hs: Prelude.undefined` this code tries to generate `Elm` code from `Servant api` at https://github.com/ashishnegi/sanskell/blob/master/src/Sanskell/Api.hs#L24
06:01:06 <ashishnegi> can someone help ?
06:02:45 <ashishnegi> i think problem might be in - toElmType of Either : https://github.com/ashishnegi/sanskell/blob/master/src/Sanskell/Api.hs#L72
06:04:14 <dagda1> can anyone help me with this code
06:04:17 <dagda1> https://gist.github.com/dagda1/f4446bfcf6cd902253f98647c3078703
06:04:41 <dagda1> first of all is the type declaration saying a tree can either have a leaf or a node
06:06:41 <srhb> dagda1: Yes?
06:06:54 <dagda1> and these do not exist in Haskell already?
06:07:04 <dagda1> I mean there is no Node or Leaf class 
06:07:10 <dagda1> or type I mean
06:07:24 <srhb> dagda1: Node and Leaf are both value constructors, not types.
06:07:57 <dagda1> srhb: interesting, I have not heard of this
06:08:03 <srhb> dagda1: Tree is a type, and there are many Tree types available in packages, but not in the base library.
06:08:38 <dagda1> I am really confused by this line addNewMax (Node x t1 Leaf) = Node x t1 (Node (x+1) Leaf Leaf)
06:08:44 <dagda1> I know it is pattern matching
06:08:50 <srhb> dagda1: That's right.
06:09:00 <dagda1> but I don't understand what it does on the right hand side of the equals
06:09:15 <srhb> dagda1: Makes a Node.
06:09:27 <dagda1> and does execution stop at this point?
06:09:42 <srhb> dagda1: There is no recursive call, if that is what you mean.
06:09:47 <dagda1> or it is returned to the calling code
06:10:14 <dagda1> srhb so that would be the result of calling addNewMax
06:10:45 <srhb> dagda1: applying addNewMax to a node where the right-hand tree is a leaf, yes.
06:10:56 <dagda1> srhb: great thanks
06:11:04 <dagda1> I need to look into value constructors
06:11:36 <srhb> You probably already know about them (they're the thing you pattern match on) but probably never heard that name
06:11:42 <srhb> They're also called data constructors.
06:11:42 <BernhardPosselt> hi, ive got a path like /some/path/test.zip and i want to split that into ['/some/path/test.zip', '/some/path', '/some'] whats an elegant way to do that :)?
06:14:58 <dagda1> how is my best way of logging these function, use a do block and putStLn?
06:18:27 <srhb> dagda1: That would massively alter its type. What do you want to log?
06:18:43 <srhb> dagda1: If it's just for debugging, you can perhaps use Debug.Trace.trace, but be aware that it's unsafe.
06:18:59 <dagda1> srhb the node values at each recursive call
06:19:23 <srhb> dagda1: How is that different from just inspecting the end result?
06:20:45 <dagda1> srhb I did not realise I would get a representation from the bound variable
06:29:46 <lyxia> BernhardPosselt: fmap joinPath . reverse . tail . inits . splitPath
06:30:03 <BernhardPosselt> lyxia: wow, thanks :)
06:31:09 <Microtrauma> lyxia, can u help me too?
06:32:10 <lyxia> Microtrauma: what is your question?
06:32:30 <Microtrauma>  ++ has a bigger priority than : ?
06:33:08 <Microtrauma> i tried to reimplement ++
06:33:25 <Microtrauma> and i dont know why (x:xs) +!+ ys = x : xs +!+ ys works
06:33:41 <Microtrauma> i invented +!+
06:33:44 <lyxia> Well you can see their precendence with :i (++) and :i (:) in ghci
06:33:57 <lyxia> infixr 5 ++    infixr 5 :
06:34:27 <Microtrauma> so they have the same priority
06:34:34 <lyxia> Microtrauma: by default operators have high priority
06:34:40 <lyxia> you have to set it explicitly
06:35:14 <Microtrauma> lyxia, why does (x:xs) +!+ ys = x : xs +!+ ys work?
06:36:56 <Microtrauma> its part of my ++ clone 
06:36:57 <lyxia> Microtrauma: if you don't set the precedence level of +!+ it defaults to infixl 9
06:37:09 <lyxia> so it binds tighter than : which is infixr 5
06:37:25 <lyxia> x : xs +!+ ys = x : (xs +!+ ys0
06:37:30 <lyxia> s/0/)
06:37:32 <Microtrauma> i typed :i (+!+) and i got nothing
06:38:20 <Microtrauma> lyxia, is it possible to find the priority of a user defined symbol?
06:38:23 <lyxia> then it means it's infixl 9
06:38:45 <Microtrauma> so when there's no output it means its 9?
06:39:09 <lyxia> yes. That's the default.
06:39:28 <Microtrauma> can i have it displayed even though its the default?
06:39:40 <Microtrauma> its a setting in ghci?
06:39:48 <lyxia> I don't know
06:39:55 <Microtrauma> thanks anyway
06:40:27 <lyxia> Almost any information about ghc and ghci can be found here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/index.html
06:40:49 <lyxia> It's quite dense though so it might be of limited use until you master more of haskell
06:41:00 <Microtrauma> im a beginner
06:41:17 <Microtrauma> and on the haskell-beginners channel there was no one available
06:44:24 <lyxia> this channel is also open to beginners so you're free to ask your questions here if you get no answers on -beginners
06:46:21 <Microtrauma> then why haskell-beginners?
06:49:02 <lyxia> I don't know. Maybe it helps when this channel gets active.
06:49:29 <Microtrauma> no overflow :D
06:50:35 <angerman> can I fold records? E.g. data X = X Int; foldl ? [X 1, X 2, X 3] (X 0) == X 3
06:51:02 <alercah> angerman: yes, of course
06:53:18 * hackagebot rl-satton 0.1.2.1 - Collection of Reinforcement Learning algorithms  https://hackage.haskell.org/package/rl-satton-0.1.2.1 (SergeyMironov)
06:53:20 * hackagebot jsaddle 0.5.0.0 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.5.0.0 (HamishMackenzie)
06:53:22 * hackagebot rl-satton 0.1.2.2 - Collection of Reinforcement Learning algorithms  https://hackage.haskell.org/package/rl-satton-0.1.2.2 (SergeyMironov)
06:53:24 * hackagebot hi 1.2.0.1 - Generate scaffold for cabal project  https://hackage.haskell.org/package/hi-1.2.0.1 (DaisukeFujimura)
06:54:14 <angerman> alercah what's the function I'm looking for?
06:54:43 <lyxia> angerman: what is that fold supposed to do
06:55:13 <alercah> angerman: it depends on what you're trying to do with the fold, of course
07:09:18 <maerwald> is there an IRC channel for the haskell.org website?
07:14:40 <hexagoxel> maerwald: i'd go with #haskell-infrastructure
07:19:05 <lodin-> Doesn't "foo :: (Eq (f a), Functor f) => f a -> f b -> Bool" imply "Eq (f b)" if not using FlexibleInstances? "foo _ fb = fb == fb" does not type check, but why? What am I missing?
07:19:31 <alercah> no, it doesn't
07:19:45 <alercah> why would it?
07:20:40 <hpc> a counterexample is pretty easy to construct
07:20:51 <byorgey> Eq (f a)  is not the same as   (forall a. Eq (f a)).  The former only means there is an Eq instance *specifically* for the type a.
07:20:54 <hpc> imagine f = Maybe, a = FilePath, b = Handle
07:21:04 <byorgey> and sadly, the latter is impossible to write in Haskell.
07:21:36 <hpc> or even b = (IO Handle)
07:21:51 <hpc> foo maybePath (fmap openFile maybePath) typechecks
07:22:18 <hpc> but you certainly can't compare (f b) values for equality in that case
07:24:01 <bennofs> byorgey: well, there is the contraints package with the Forall constraint...
07:24:44 <lodin-> hpc: Sorry, I'm new, but when defining the the instance of Eq for Maybe then you need to need to have Eq (Maybe a), so how can Maybe FilePath be Eq but not Maybe Handle? Ah, is it because you can have different contexts on a in the instance definition?
07:25:02 <hpc> yep
07:25:14 <lodin-> Great. That's what I was missing. :-)
07:25:44 <lodin-> Thanks.
07:26:20 <Myrl-saki> Trying to figure out how to cross compile to Windows using Nix. :s
07:40:26 <jluttine> when running `stack setup`, can i specify which resolver i want? i tried `stack setup --resolver=lts-6.15` but still it wrote `resolver: lts-7.2` into `~/.stack/global-project/stack.yaml`
07:53:19 * hackagebot jsaddle-dom 0.4.0.0 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.4.0.0 (HamishMackenzie)
07:53:42 <erisco> tell me something interesting
07:53:49 <Myrl-saki> erisco: SOMETHING INTERESTING
07:53:50 <Myrl-saki> HUEUHUEHUKEEN
07:54:19 <erisco> en Haskell svp
08:06:58 <erisco> instance (Bounded a, Enum a, Eq b) => Eq (a -> b)  should be a thing
08:07:29 <erisco> maybe without Bounded to be even more adventurous
08:12:10 <erisco> > not == not
08:12:13 <lambdabot>  True
08:12:45 <erisco> > not == (&&) True
08:12:47 <lambdabot>  False
08:14:57 <Myrl-saki> :t not
08:14:58 <lambdabot> Bool -> Bool
08:15:12 <Myrl-saki> :t xor
08:15:13 <lambdabot> Bits a => a -> a -> a
08:15:17 <Myrl-saki> Hmmm
08:15:47 <Myrl-saki> > id == (&&) True
08:15:49 <lambdabot>  True
08:15:55 <Myrl-saki> but how
08:16:14 <Myrl-saki> > const False = (&&) False
08:16:16 <lambdabot>  <hint>:1:13: error:
08:16:16 <lambdabot>      parse error on input ‘=’
08:16:16 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
08:16:18 <Myrl-saki> > const False == (&&) False
08:16:21 <lambdabot>  True
08:16:50 <erisco> > id == all . repeat 3
08:16:52 <lambdabot>  error:
08:16:53 <lambdabot>      • Couldn't match expected type ‘(t0 a0 -> Bool) -> a0 -> Bool’
08:16:53 <lambdabot>                    with actual type ‘[Integer]’
08:17:09 <erisco> > id == all . replicate 3
08:17:15 <lambdabot>  error:
08:17:19 <lambdabot>      • Couldn't match type ‘[t0 a0 -> Bool]’ with ‘a0 -> Bool’
08:17:21 <lambdabot>        Expected type: (t0 a0 -> Bool) -> a0 -> Bool
08:17:42 <Myrl-saki> Hmmm
08:17:55 <Myrl-saki> That should be true.
08:18:00 <lyxia> byorgey: Performance-wise a hand written Boltzmann sampler is actually getting crushed by Feat until the size reaches about 4k constructors. It's quite sad.
08:18:38 <erisco> > not == all not . replicate 3
08:18:40 <lambdabot>  True
08:18:44 <Myrl-saki> Oh.
08:18:57 <Myrl-saki> > id == and . replicate  3
08:18:59 <lambdabot>  True
08:19:20 <erisco> see, what great fun this could be
08:20:47 <Hafydd> > const True == (|| True)
08:20:49 <lambdabot>  True
08:20:57 <Hafydd> > const True undefined
08:20:58 * Robin_Jadoul is trying to report a GHC bug, but getting a 500 error when trying to log in
08:20:59 <lambdabot>  True
08:21:05 <Hafydd> > (|| True) undefined
08:21:07 <lambdabot>  *Exception: Prelude.undefined
08:22:06 <glguy> Robin_Jadoul: Try in #haskell-infrastructure or #ghc perhaps. As a data point I was able to log in just now
08:22:14 <Robin_Jadoul> glguy: OK
08:24:30 <erisco> > let (+) = (+) :: Word8 -> Word8 -> Word8 in (+)1 == (+)1 . (-)1 . (+)1
08:24:36 <lambdabot>  mueval-core: Time limit exceeded
08:24:49 <erisco> really? oO
08:27:57 <erisco> > (+)(1 :: Word8) == (+)1 . (-)1 . (+)1
08:28:00 <lambdabot>  False
08:28:06 <erisco> not sure what was wrong with the other one
08:28:18 <hexagoxel> (+) was defined recursively?
08:28:20 <erisco> oh, right, let is recursive, heh
08:28:43 <erisco> where's my let rec
08:30:59 <erisco> > (id &&& (-)1) (minBound :: Word8)
08:31:01 <lambdabot>  (0,1)
08:31:06 <erisco> isn't that fun?
08:31:21 <erisco> oh, operator order, heh
08:32:05 <hexagoxel> > (id &&& subtract 1) (minBound :: Word8)
08:32:08 <lambdabot>  (0,255)
08:32:14 <erisco> -1 doesn't work so why not (-)1, whoops
08:37:36 <lunaryorn> Hello. What's the state of the art library for (cryptographic) random number stuff in Haskell?  I'd like to take random samples from a potentially large but finite list
08:37:47 <lunaryorn> hackage isn't really helpful, has lots of outdated libraries
08:39:20 <Dongstein> lunaryorn depending on how many samples you need you can just seed a psuedorng
08:40:17 <lunaryorn> that'd be perfectly fine for my purpose, but what pseudo RNG library could I use?  I didn't find any that has a convenient "sample" function…
08:41:19 <MarcelineVQ> random-fu has a sample and was fairly easy to use iirc http://hackage.haskell.org/package/random-fu-0.2.7.0/docs/Data-Random.html
08:41:24 <Dongstein> just make a function that picks an index with a scaled random number
08:42:11 <Dongstein> I was interested in doing some random variable for markov chain based stuff
08:52:09 <glguy> /exit
08:52:47 <glguy> That was weird, vty got out of sync with the terminal
08:55:38 <lunaryorn> Dongstein Oh well, I could write that myself for sure, but that sort of misses the point of my question, doesn't it?
08:56:35 <Dongstein> someone's probably done all the hard work already
08:56:51 <Dongstein> of having good psuedorng algorithms
08:57:03 <Dongstein> there's a good section in knuth's book though
09:22:20 <saurabhnanda> ANNOUNCING: Paid + remote internships at Vacation Labs (Goa, India) -- https://www.vacationlabs.com/haskell-internship/
09:55:56 <YellowOnion> this is strange, stack can't find a module, no typo's, nothing, cabal has the package listed, I'm confused :\
09:56:33 <glguy> That's too bad :(
09:59:17 <YellowOnion> ahh ok, package version is wrong.
10:01:01 <Myrl-saki> find .
10:01:03 <Myrl-saki> err
10:03:50 <YellowOnion> and for some reason refused to update it.
10:13:30 <YellowOnion> alright, lets stick with the package versions in the lts I picked, that might help :P
10:14:55 <YellowOnion> so whats the proper way to embbed type safe links from servant in blaze-html?
10:30:10 <juri_> What's the deal with criterion? they need to do a release soon, so i can stop telling the users using my dev-tip that they have to compile criterion from github first.
10:31:11 <johnw> juri_: I think asking the criterion maintainer would be more effective than saying it here
10:32:57 <YellowOnion> toValue . show $ safeLink feels wrong... but it works. and I can't find a better method.
10:37:44 <intothem1untains> I have some data type Ta = Ca | Cb Tb, do you know of some neat way to filter [Ta] for Tas constructed with Cb and get their inner Tb?
10:38:16 <Tuplanolla> This sounds like a job for lenses, intothem1untains.
10:38:27 <lyxia> [ tb | Cb tb <- tas ]
10:38:31 <intothem1untains> I wouldn't want to define some isCb, fromCb
10:38:37 <drdo> intothem1untains: Why don't you just use Maybe?
10:38:43 <intothem1untains> oh, wow, lyxia, really nice
10:38:53 <intothem1untains> drdo: still, i would have the same question
10:38:55 <drdo> Ta = Maybe Tb
10:39:31 <lyxia> with maybe there is asum or catMaybes
10:40:30 <intothem1untains> hm
10:40:37 <intothem1untains> I like my types to be descriptive though
10:41:03 <johnw> intothem1untains: lenses would make what you're asking for easy
10:41:18 <johnw> xs ^.. _Cb . _Tb
10:41:42 <johnw> you'd just need to $(makePrisms Ta) first
10:41:54 <johnw> oops: xs ^.. _Cb . _1
10:43:41 <intothem1untains> johnw: but introducing a whole library and TH just for that seems a bit of overkill
10:44:06 <erisco> the linker will get rid of the excess
10:44:11 <johnw> you just asked for a neat way, not both neat and compact :)
10:44:44 * EvanR neat and non compact... an infinite chess board
10:46:11 <EvanR> i have the distinct feeling that cabal build followed by cabal install is silently rebuilding the entire thing
10:48:38 <glguy> EvanR: cabal install is a one-stop-shop, if you want to proceed after a cabal build you need: cabal copy; cabal register
10:48:48 <EvanR> ok
10:53:24 * hackagebot yi 0.13.0.2 - Yi editor  https://hackage.haskell.org/package/yi-0.13.0.2 (DmitryIvanov)
10:53:26 * hackagebot yi-core 0.13.0.2 - Yi editor core library  https://hackage.haskell.org/package/yi-core-0.13.0.2 (DmitryIvanov)
10:53:28 * hackagebot yi-frontend-pango 0.13.0.2 - Pango frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-pango-0.13.0.2 (DmitryIvanov)
10:53:30 * hackagebot yi-frontend-vty 0.13.0.2 - Vty frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-vty-0.13.0.2 (DmitryIvanov)
10:53:32 * hackagebot yi-ireader 0.13.0.2 - Yi editor incremental reader  https://hackage.haskell.org/package/yi-ireader-0.13.0.2 (DmitryIvanov)
10:54:29 <joe9>  Haskell FFI How do i add a const qualifier?  https://paste.pound-python.org/show/J0Og1AGU22tMPsVeQ9gh/ is my haskell function, this is how I am calling the haskell
10:54:29 <joe9>        function https://paste.pound-python.org/show/9xK8ajcfa9hI4QnlcOQX/  [10:53]
10:54:34 <joe9>  any suggestions on how I can pass along the const qualifier when calling the haskell function?
10:54:54 <johnw> there is no const in your paste
10:55:20 <joe9> xkb_keymap_mod_get_index(struct xkb_keymap *keymap, const char *name)
10:55:23 <joe9> is the calling function
10:55:36 <johnw> what you do mean then by "pass along"?
10:55:46 <johnw> "const" has no representation either in the C symbol name, or on the Haskell side
10:55:54 <joe9> johnw: line 2 of the first paste.
10:56:02 <johnw> I see Word32 there
10:56:23 <joe9> johnw: https://paste.pound-python.org/show/9xK8ajcfa9hI4QnlcOQX/
10:56:43 <johnw> let me ask a different way: why do you want to "pass along" const?
10:56:46 <joe9> johnw: THanks for checking on this. THis is how I am calling the haskell function
10:57:27 <joe9> johnw: I cannot change this definition: xkb_keymap_mod_get_index(struct xkb_keymap *keymap, const char *name) -- you mean just copy *name to a local variable and pass that along?
10:58:00 <johnw> what I mean is: const does not matter to the FFI
10:58:16 <johnw> Haskell uses the C bindings, so treating it as just "char *" is perfectly fine
10:58:34 * hackagebot yi-keymap-cua 0.13.0.2 - Cua keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-cua-0.13.0.2 (DmitryIvanov)
10:58:36 * hackagebot yi-keymap-emacs 0.13.0.2 - Emacs keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-emacs-0.13.0.2 (DmitryIvanov)
10:58:36 <johnw> const only matters when comparing mangled C++ symbol names, which the Haskell FFI does not do
10:58:38 * hackagebot yi-keymap-vim 0.13.0.2 - Vim keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-vim-0.13.0.2 (DmitryIvanov)
10:58:40 <ClaudiusMaximus> it matters to some extent, because exposing with char * will break when called with a const char * argument
10:58:40 * hackagebot yi-language 0.13.0.2 - Collection of language-related Yi libraries.  https://hackage.haskell.org/package/yi-language-0.13.0.2 (DmitryIvanov)
10:58:42 * hackagebot yi-misc-modes 0.13.0.2 - Yi editor miscellaneous modes  https://hackage.haskell.org/package/yi-misc-modes-0.13.0.2 (DmitryIvanov)
10:58:58 <ClaudiusMaximus> it will be a compile error on the C side
10:59:00 <joe9> johnw: oh, ok, just trying to avoid this message: https://paste.pound-python.org/show/Tm8gSGYRFuvfZbUUQa4h/ it is a C question now, correct?
10:59:08 <johnw> ClaudiusMaximus: you don't ever "expose it as char*" on the C side
10:59:14 <johnw> you simply link to it as "char *" on the Haskell side
10:59:35 <johnw> aha
10:59:40 <joe9> ClaudiusMaximus: johnw, you are correct, it is an error: https://paste.pound-python.org/show/iSCg28AjaKS8tPpFNdBx/
10:59:41 <ClaudiusMaximus> johnw: well you want to declare the prototype somewhere, and that declaration would need a const to be able to be called with a const argument
10:59:54 <johnw> you want to make a Haskell function that takes a char* visible to C code that wants a const char* to silence a compiler warning
11:00:07 <johnw> then either cast, or provide a wrapper function that casts
11:00:10 <ClaudiusMaximus> johnw: so it's not really a haskell question, unless the ffi export has a mechanism to generate C header files
11:00:15 <johnw> ClaudiusMaximus: right, I understand now
11:00:17 <johnw> this is a C question
11:00:52 <johnw> you cannot, using the Haskell FFI, cause the exported function type to use const, as far as I know
11:01:38 <joe9> johnw: ClaudiusMaximus: so, the answer is to put it in a local variable and call the haskell function using the local variable, correct?
11:01:42 <johnw> this would actually be trivial using a newtype wrapper, all we'd have to do is mark the type like ConstPtr CString or something, and then educate the exporter
11:01:51 <johnw> but there is no such support in base as far as I know
11:01:56 <johnw> joe9: that, or cast
11:02:31 <erisco> (pod)
11:03:05 <joe9> johnw: ClaudiusMaximus: Thanks, https://paste.pound-python.org/show/ywbcUF9MVWFhkw86hfyg/
11:03:38 <joe9> that does not work https://paste.pound-python.org/show/hit9IQC8mlvDLCyqK3El/
11:03:44 * hackagebot yi-mode-haskell 0.13.0.2 - Yi editor haskell mode  https://hackage.haskell.org/package/yi-mode-haskell-0.13.0.2 (DmitryIvanov)
11:03:46 * hackagebot yi-mode-javascript 0.13.0.2 - Yi editor javascript mode  https://hackage.haskell.org/package/yi-mode-javascript-0.13.0.2 (DmitryIvanov)
11:03:51 <joe9> let me check on the C programming channel
11:04:03 <erisco> mercy be upon you
11:04:21 <johnw> joe9: cast, don't assign to a local; you'd need to cast even to make the local assignment!
11:05:34 <intothem1untains> A simple way of mapping a two level nested list [[]]?
11:05:44 <intothem1untains> Would map . map work here?
11:05:59 <johnw> map (map f)
11:06:09 <zell> Could anyone help introduce me to Control.Monad.Catana or help me understand which other modules can be used to provide this functionality
11:06:10 <johnw> so, yes
11:06:19 <intothem1untains> ok!
11:06:38 <hvr> :t map . map
11:06:39 <lambdabot> (a -> b) -> [[a]] -> [[b]]
11:09:08 <leshow> hey guys, got a question. If i have a type data Id a = MkId a
11:09:32 <zell> Can I pass patterns as arguments?
11:09:32 <leshow> i can write a funciton like mkId :: Id (a -> a); mkId = MkId $ /x -> x
11:09:42 <leshow> if i have somehting like
11:09:52 <leshow> data Product a b = Product a b
11:10:11 <leshow> i can write the type mkProduct :: Product (a -> a) (b -> b)
11:10:20 <leshow> but when i go to write the body of that funciton i cant seem to get it right
11:10:32 <leshow> i had mkproduct = Product $ \a b -> a b
11:10:42 <leshow> but ghc doesnt like that
11:10:48 <glguy> leshow: \a b -> a b makes a single value
11:10:59 <glguy> and then applies the first parameter to the second
11:11:07 <glguy> You need two separate functions
11:11:23 <joe9> johnw: but, there is no way I can add a const to the haskell ffi function definition generated?
11:11:29 <leshow> mkProduct = Product $ \a -> a $ \b -> b ?
11:11:35 <glguy> leshow: Stick to ()s
11:11:52 <zell> :t (id,id)
11:11:53 <lambdabot> (a -> a, a1 -> a1)
11:11:53 <glguy> f $ g $ x -- means   f (g x)
11:11:58 <leshow> mkProduct = Product (\a -> a) (\b -> b)
11:12:02 <EvanR> joe9: are you asking about c binding code generators?
11:12:10 <EvanR> that generate C code
11:12:18 <leshow> that makes sense, thanks glguy 
11:12:25 <lyxia> zell: maybe take a look at pipes and conduit
11:12:40 <joe9> johnw: I think this is what you are talking about : http://stackoverflow.com/a/16775684 the 3 rd option
11:13:11 <zell> Thanks lyxia
11:15:34 <joe9> johnw, that worked. Thanks.
11:16:20 <johnw> yep, exactly
11:17:00 <johnw> you can just perform the cast directly in your call:   return skb_keymap_mod_get_index(keymap->initial_state_index, (char *)name);
11:19:11 <zell> Is there a higher order concept behind pipes? The documentation focus on use rather than implementation
11:19:21 <johnw> zell: what would you like to know?
11:19:34 <johnw> and what exactly do you mean by "a higher order concept"?
11:19:42 <johnw> if you mean, a data structure that holds function closures, then yes
11:20:21 <zell> Well I don't really understand what means; pipes gives you all three features: effectful, streaming, and composable programming.
11:20:38 <zell> And how this is achieved under the hood
11:21:06 <zell> "Function closures"?
11:21:11 <EvanR> effectful: your components can have side effects
11:21:27 <EvanR> streaming: the components consume input incrementally, and output incrementally
11:21:39 <EvanR> composable, you can mix and match components that are compatible at their ports
11:21:47 <erisco> if you want to know how it is implemented that is one question. If you want to know what it is, that is a different question
11:22:43 <zell> The documentation communicates what it does (or is) but I don't want to have to pluck the essence from the source if it can be phrased simply
11:23:01 <johnw> zell: it can be phrased simply, but first I have to know what our common terms are
11:23:07 <erisco> there are some properties, I believe three or four operators that each form a Category
11:23:18 <erisco> there are also a few illustrative diagrams in the documentation
11:25:12 <erisco> http://hackage.haskell.org/package/pipes-4.2.0/docs/Pipes-Tutorial.html is quite thorough
11:25:17 <zell> Currently it seems understanding pipes or function closures is equivalent, but I understand neither...
11:25:48 <erisco> johnw was being facetious
11:25:52 <johnw> I actually was not
11:25:58 <zell> It's thorough in describing it's api, not in communicating the underlying principal, which seems to be closures
11:26:09 <johnw> what pipes are, underneath, is very simple. in fact, it's too simple.  If you just "say what it is", it won't mean much
11:26:29 <EvanR> it occurs to me that if youre not familiar with closures it might be difficult to accept and embrace some libraries which dont really require you to know that stuff
11:26:52 <johnw> The true core of 'pipes' is the fixed-point of a request/respond functor: https://github.com/jwiegley/notes/blob/master/PipesFreeT.hs#L27
11:27:29 <johnw> that type is what pipes v2 actually used, but later moved away from due to efficiency concerns
11:27:42 <zell> I know that a group operation must not produce a value outside the group or it isn't closed...
11:28:17 <zell> I like FreeT thanks
11:30:16 <zell> Ouch my neurons
11:31:01 <EvanR> if youre truly curious about how a thing is implemented, then you just should read the source
11:31:28 <zell> I don't know why everyone thinks 4 parameters is cool
11:31:39 <johnw> zell: ?
11:31:46 <erisco> I don't know how you derived that belief
11:32:11 <zell> newtype Proxy has 6, that's just shocking
11:32:22 <johnw> I find the bidirectionality of pipes to be a dubious feature
11:32:27 <johnw> i've never once used it, and it complicates the library
11:32:44 <johnw> some days I wouldn't mind a simplified, unidirectional fork
11:33:15 <johnw> i mean, the high-level syntax doesn't even really expose the capability
11:33:17 <leshow> is there a way to gather a sum type into a list
11:33:20 <zell> Is that what's upsetting me? Are there twice as many parameters than if it were not bidirectional?
11:33:20 <leshow> like if the type is
11:33:28 <johnw> zell: it would remove 2 of them
11:33:31 <leshow> data Thing = One | Two | Three
11:33:38 <leshow> [One, Two, Three]
11:33:47 <leshow> rather than explicitly writting that list out
11:33:50 <johnw> leshow: you could do that with template haskell easily
11:33:58 <leshow> is there any other way
11:33:58 <johnw> it gets harder if there are type variables
11:34:03 <grantwu> Can't you do something with enum
11:34:04 <johnw> probably with Generics too
11:34:08 <leshow> well in this case there are no type variables
11:34:09 <johnw> yeah, or enum in this specific case
11:34:20 <zell> {..}¿
11:34:42 <lyxia> > [minBound .. maxbound] :: Bool
11:34:44 <lambdabot>  error:
11:34:44 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘[t0]’
11:34:44 <lambdabot>      • In the expression: [minBound .. maxbound] :: Boolerror:
11:34:49 <lyxia> > [minBound .. maxbound] :: [Bool]
11:34:52 <lambdabot>  error:
11:34:52 <lambdabot>      • Variable not in scope: maxbound :: Bool
11:34:52 <lambdabot>      • Perhaps you meant ‘maxBound’ (imported from Prelude)
11:35:18 <leshow> > [minBound .. maxBound] :: Bool
11:35:20 <lambdabot>  error:
11:35:20 <lambdabot>      • Couldn't match expected type ‘Bool’ with actual type ‘[t0]’
11:35:20 <lambdabot>      • In the expression: [minBound .. maxBound] :: Bool
11:35:21 <EvanR> johnw: is conduit a simplified one directional version
11:35:37 <johnw> EvanR: conduit drops bidirectionality, but adds two new features that makes it even MORE complex
11:35:45 <EvanR> heh
11:36:06 <zell> > enumFrom False
11:36:08 <lambdabot>  [False,True]
11:36:10 <johnw> and then there is the 'streaming' library, which is also beautiful
11:36:17 <lyxia> zell: ooooooh
11:36:32 * lyxia gives a cookie to zell.
11:36:34 <johnw> it's unidirectional, and just uses FreeT to effectually stream elements
11:36:35 <erisco> > [minBound..maxBound] :: [Bool]
11:36:37 <johnw> @hack streaming
11:36:37 <lambdabot> http://hackage.haskell.org/package/streaming
11:36:37 <lambdabot>  [False,True]
11:37:07 <EvanR> streaming, cool
11:37:08 <johnw> for a given subset of their functionality, these three libraries are both isomorphic and compatible
11:37:32 <erisco> both apples and oranges and pears are fruit
11:37:38 <EvanR> 
11:37:39 <zell> It's only me that's incompatible...
11:37:43 <johnw> zell: lol! :)
11:38:23 <laudiacay> hey, my teacher gave us a practice assignment where one of the problems is declaring a type unsugaredly. The original declaration was like "type Standings = [(String, Int, Int)]". I have "type Standings = ((,,) String Int Int) : []" right now, and I'm getting a parse error on the colon.
11:38:47 <johnw> you can't have ": []" there
11:38:52 <johnw> and (,,) I don't think will work either
11:38:52 <laudiacay> I've tried all sorts of parentheses arrangements, does anyone have any tips for other stuff to try? Please don't give answers
11:38:54 <erisco> what do you think : is?
11:39:00 <laudiacay> erisco: cons, right?
11:39:02 <johnw> type Standings = ((,) ((,) String Int) Int)
11:39:07 <erisco> yes, and what is cons?
11:39:14 <johnw> oops, sorry
11:39:16 <laudiacay> johnw: that's not what GHC.tuple says....
11:39:19 <glguy> johnw: No, (a,b,c) isn't going to go into two (,)
11:39:26 <glguy> [a] is the same as [] a
11:39:28 <grantwu> tuplesections?
11:39:29 <laudiacay> erisco: sticking something to the front of a list, right?
11:39:30 <johnw> oh, right
11:39:35 <erisco> laudiacay, it is a value
11:39:40 <laudiacay> oh shit duh thanks man
11:40:29 <laudiacay> erisco: "type Standings = [] ((,,) String Int Int)" :) thanks
11:41:46 <laudiacay> also, erisco, is there an equivalent to fjdskl :: Int in ghci?
11:41:50 <leshow> if i have 2 lists and i want to generate a new list that represents all possible combinations of both lists, i'd normally do [(a,b)|a<-xs,b<-ys] is there any other way to do that?
11:41:52 <zell> type S a b c = [].(,,)
11:41:57 <leshow> other than just writing it with do notatoin
11:42:01 <leshow> notation*
11:42:07 <EvanR> > 4 :: Int
11:42:09 <lambdabot>  4
11:42:22 <erisco> laudiacay, you can write just that, or if you want to know the type of something you can use :t x
11:42:34 <laudiacay> erisco: i want to make the variable have that type
11:42:45 <laudiacay> I got "not in scope: 'fdsafda'
11:42:58 <lpaste> tippenein pasted “refactoring out a bug in "gsub"” at http://lpaste.net/238275
11:43:00 <erisco> let abc :: Int; abc = undefined   or in the new ghci you can omit the "let"
11:43:04 <laudiacay> like, you know how at the top of an hs file you'll put var1 :: Int or something?
11:43:15 <laudiacay> oh you need the ;
11:43:30 <leshow> i suppose i could liftA2 (,,) xs ys
11:43:36 <leshow> any other way?
11:43:42 <leshow> or (,) rather
11:43:44 <erisco> or you put it on two lines, though I cannot remember how to do multiline entry in ghci
11:43:51 <laudiacay> yeah me neither
11:43:52 <tippenein> I wrote some bad code. Any ideas on refactoring it? http://lpaste.net/238275
11:43:53 <laudiacay> thanks :)
11:44:17 <tippenein> everytime I cut corners I bury myself
11:44:29 <erisco> ah, you use :{ to start multiline mode
11:44:57 <laudiacay> oh cool thanks
11:45:13 <lyxia> tippenein: if you write Nothing -> Nothing, you can use fmap instead
11:46:20 <erisco> or do notation
11:46:49 <tippenein> even when I'm casing a pattern?
11:47:12 <Tuplanolla> What was the proposal called that allows you to pass lambdas or do blocks as arguments without ($)?
11:47:13 <erisco> do matched : grouping <- regexMatch t reg
11:47:39 <Cale> Tuplanolla: ArgumentDo
11:48:12 <glguy> Yes please
11:48:24 <Tuplanolla> Thanks, Cale. Did it make its way into GHC 8 yet?
11:48:29 <tippenein> cool, that's more readable
11:48:46 <erisco> > T.replace "" "" "hello world"
11:48:48 <lambdabot>  error:
11:48:48 <lambdabot>      Not in scope: ‘T.replace’
11:48:48 <lambdabot>      No module named ‘T’ is imported.
11:48:52 <Cale> Tuplanolla: ghc --supported-languages | grep ArgumentDo  says no
11:48:55 <erisco> > Text.replace "" "" "hello world"
11:48:57 <lambdabot>  error:
11:48:57 <lambdabot>      Not in scope: ‘Text.replace’
11:48:57 <lambdabot>      No module named ‘Text’ is imported.
11:49:02 <Tuplanolla> Damn it.
11:49:05 <Cale> (I'm on 8.0.1)
11:49:12 <tippenein> erisco: yeah... my use of partial functions is deplorable
11:49:23 <Cale> Tuplanolla: The standard thing to do is just to put a $ before the do
11:49:29 <grantwu> http://lpaste.net/238281
11:49:34 <grantwu> Why won't this compiler?
11:49:34 <Cale> (or the lambda)
11:49:38 <grantwu> er, compile
11:49:51 <Cale> It's literally just eliminating a couple characters :)
11:49:55 <erisco> can you import things with lambdabot?
11:49:55 <Tuplanolla> Yeah, but "don't $ do" looks stupid.
11:50:01 <lyxia> grantwu: you must give a name to the constructor of the record
11:50:37 <lyxia> grantwu: it's also good practice to paste error messages with incorrect code
11:50:44 <geekosaur> ArgumentDo is not in and not currently planned; the discussion stalled with no action
11:51:13 <grantwu> lyxia: Thanks
11:51:24 <erisco> > Data.Text.replace "" "" "hello world"
11:51:26 <lambdabot>  error:
11:51:27 <lambdabot>      Not in scope: ‘Data.Text.replace’
11:51:27 <lambdabot>      No module named ‘Data.Text’ is imported.
11:51:34 <erisco> it just worked in pm =\
11:51:46 <erisco> though I asked for the type, not to evaluate it
11:52:00 <geekosaur> right, they're different
11:52:01 <Cale> Yeah, when you ask for types, it'll let you access more stuff.
11:52:05 <glguy> Tuplanolla: That feature was abandoned, even if it did sound wonderful and work great in other languages similar to Haskell
11:52:16 <Cale> :t Unsafe.Coerce.unsafeCoerce
11:52:18 <lambdabot> a -> b
11:52:40 <EvanR> wait, we have unsafeCoerce here?
11:52:44 <erisco> ah, okay, it aborts if the string is empty, I see
11:52:53 <Cale> EvanR: You can ask for the *type* of unsafeCoerce
11:52:58 <geekosaur> siiiigh
11:53:00 <EvanR> oh
11:53:23 <EvanR> all your base was about to belong to us
11:53:25 * hackagebot interlude-l 0.1.0.7 - Prelude replacement based on protolude  https://hackage.haskell.org/package/interlude-l-0.1.0.7 (darwin226)
11:53:27 * hackagebot hamsql 0.8.0.0 - HamSql  https://hackage.haskell.org/package/hamsql-0.8.0.0 (quabla)
11:53:32 <tippenein> erisco: the assumption I'm making is that t is not ""
11:53:37 <Cale> geekosaur: Do you happen to know what it stalled on?
11:53:46 <erisco> you do not make that assumption, you test for it on line 39
11:53:50 <Cale> geekosaur: I assume some fiddly syntax details?
11:54:02 <glguy> Lack of sufficiently loud community support https://phabricator.haskell.org/D1219
11:54:24 <EvanR> > Unsafe.Coerce.unsafeCoerce "rm -rf /" :: IO ()
11:54:26 <lambdabot>  error:
11:54:26 <lambdabot>      Not in scope: ‘Unsafe.Coerce.unsafeCoerce’
11:54:26 <lambdabot>      No module named ‘Unsafe.Coerce’ is imported.
11:54:31 <opqdonut> ha
11:54:37 <geekosaur> there was about an equal amount of "ugh no" and "gimme!"
11:54:53 <tippenein> ah, found it. this awful line of code is wrong -     addition = headMaybe $ fromMaybe [] $ tailMaybe $ T.split ((==) '\1') rep
11:55:15 <geekosaur> EvanR, the point of that was to demonstrate that @type has access to more than @run does
11:55:19 <tippenein> obviously that's awful
11:55:26 <geekosaur> I feel like this is going to just loop...
11:56:12 <erisco> tippenein, I do not see any particularly pleasant way to rewrite line 39
11:58:50 <tippenein> line #35 is the _actual_ problem
11:59:14 <tippenein> it's doing a split on \1 but there isn't necessarily one in the replacement..
11:59:28 <erisco> what is headMaybe
11:59:59 <glguy> Sounds like a version of listToMaybe that isn't in base
12:00:05 <tippenein> headMaybe :: [a] -> Maybe a
12:00:11 <zell> What's Control.Monad.Morph doing?
12:00:17 <erisco> oh, the safe version of head
12:00:22 <tippenein> same as headMay from that package I decided not to use
12:00:34 <erisco> what is tailMaybe?
12:00:51 <erisco> drop 1 that dies on empty lists?
12:01:15 <erisco> I didn't word that how I meant
12:01:44 <tippenein> tailMaybe (_:xs) = Just xs
12:02:45 <grantwu> Why does https://hackage.haskell.org/package/enummapset-0.5.2.1/docs/Data-EnumSet.html need DeriveDataTypeable?
12:03:12 <zell> :t Control.Monad.Morph.generalize
12:03:14 <lambdabot> Monad m => Identity a -> m a
12:03:51 <glguy> grantwu: In order to derive Typeable (on older GHCs)
12:04:33 <erisco> my energy is too low to hunt through docs for the types of all the things involved
12:04:46 <grantwu> I see
12:04:48 <zell> I guess I get frustrated when I don't understand why an approach such as this Identity Monad...
12:05:04 <grantwu> glguy: So if I don't actually need Typeable, I'm fine
12:05:04 <byorgey> lyxia: hah, wow, I would not have guessed that
12:05:21 <glguy> grantwu: Sure, if you don't need typable you don't have to derive it
12:05:33 <glguy> But that seems a bit circular to be what you're asking
12:07:11 <erisco> tippenein, fix up regexMatch and matchWithReplace to use fmap or do notation and we can go from there
12:08:24 <erisco> fmap (fmap decodeUtf8) (match r (encodeUtf8 t) [])
12:10:37 <grantwu> urgh.
12:10:57 <grantwu> I want to use EnumSet but there isn't a sensible definition of toEnum
12:11:14 <zell> Why do we need streams or pipes if we have foldable and unfoldable?
12:11:24 <johnw> zell: "effects"
12:11:35 <johnw> producing values one-at-a-time
12:11:36 <zell> lame
12:11:54 <zell> It's huge
12:11:55 <johnw> imagine you query database and the answer is a million rows; you'd rather handle a row at a time, rather than require a memory buffer big enough to hold the entire answer at once
12:12:40 <johnw> the poor man's way of doing that is with continuation functions, aka callbacks, that are called once for each answer; well, pipes simply abstracts that notion and turns it into a library based on composition of pipe segments
12:13:02 <zell> Ok so it abstracts the recursive nature of cata and ana?
12:13:04 <johnw> but at its core, it's just callbacks
12:13:15 <grantwu> is there any alternative to EnumSet that does what I want? (i.e. there's a natural "key" I can use for elements I want to store, but the key dosn't uniquely determine the element_
12:13:16 <johnw> cataM and anaM, technically
12:13:33 <zell> Nice, at least I get it now.
12:13:46 <johnw> zell: so long as you consider the "structure" to be just any old computation
12:13:52 <zell> Sounds like it should be about 20 lines...
12:14:05 <johnw> cataM folds over a tree structure; a pipe might generate its values procedurally, with no internal "structure" that is being folded over
12:14:15 <erisco> or  match ~> id ~> encodeUtf8 ~> ($[]) ~> (id ~> decodeUtf8)  I think
12:14:16 <zell> Hmm
12:14:30 <johnw> but *conceptually* there is indeed a similarity here
12:14:50 <zell> So it's about generating a datatype on the fly...
12:15:11 <johnw> zell, kind of; it's like enforcing fusion by giving you full control over the pipeline
12:15:17 <erisco> I mean  ($[]) ~> fmap decodeUtf8  at the end there
12:15:37 <johnw> it's the presence of effects that muddy the waters here
12:15:53 <zell> I mean something like Free but with arbitrary nested types?
12:15:57 <johnw> for a pipe over Identity, a properly written data type, with proper fusion rules, could achieve the same desired effect
12:16:01 <johnw> FreeT, not Free
12:16:20 <johnw> can't forget those effects in 'm', it's sort of the whole point
12:18:33 <erisco> (match ~> id ~> encodeUtf8 ~> ($[])) ~> fmap decodeUtf8
12:19:14 <erisco> no no -.-
12:19:49 <erisco> I am just going to give up XD too tired
12:21:46 <zell> Is it like unfoldM :: Monad (m a -> n a-> n a) -> a -> m a -> n a ... Or something...
12:21:53 <zell> ?
12:22:12 <Tuplanolla> You blew it by not calling m b, zell.
12:23:11 <dmwit> grantwu: What's EnumSet?
12:23:36 <grantwu> dmwit: https://hackage.haskell.org/package/enummapset-0.5.2.1/docs/Data-EnumSet.html
12:23:51 <zell> I was just altering the parameterized type...
12:24:06 <dmwit> grantwu: Perhaps this is a dumb question, but... what about EnumMap instead?
12:24:09 <zell> Oops
12:24:23 <Tuplanolla> You could've had a `b a -> n a -> n a`, zell.
12:24:33 <zell> (zell) Is it like unfoldM :: (Monad m, Monad m)  => (m a -> n a-> n a) -> a -> m a -> n a ... Or something...
12:24:54 <dmwit> grantwu: Pull out the part that `Enum` makes sense on into its own type.
12:25:15 <zell> Oh your comment was about spelling the word banana... That wasn't really what i was getting at...
12:25:32 <erisco> (id ~> encodeUtf8 ~> (fmap decodeUtf8 . ($[])) match
12:25:36 <zell> Trying to understand about hyloM
12:25:46 <erisco> but I suspect something better on the end there
12:26:10 <johnw> zell: I think you're choosing the hard way of getting at what pipes do; you're going to be hard-pressed to fit the whole concept into just cataM and anaA
12:26:28 <zell> Not really familiar with Monad Transformers, but I guess it's just some Coyoneda
12:26:44 <johnw> that statement didn't really make sense to me...
12:27:10 <grantwu> dmwit: I guess... but I often need the two parts together and to implement your suggestion I basically need to pass around this map
12:27:28 <zell> I mean about (m a -> n a) rather than (m a -> m b)
12:27:32 <grantwu> Or I could just store the part that enum cares about
12:27:50 <dmwit> grantwu: What are "the two parts", and why would passing around a map be any worse than passing around a set?
12:27:53 <erisco> (id ~> fmap decodeUtf8) (id ~> encodeUtf8 ~> ($[])) match
12:28:52 <zell> What more than hyloM do I need? Composition?
12:29:20 <johnw> zell: I think you should start playing around in code at this point; we're going too far without enough foundation
12:29:39 <zell> The idea at the heart seems to be generators and consumers which likes hyloish to me
12:29:52 <johnw> ok, prove that it is in code
12:30:01 <grantwu> dmwit: The context is that I want a set of lvals, where each lval is a virtual register with a type
12:30:08 <Tuplanolla> Can't you do absolutely anything with `hyloM` or am I missing the point?
12:30:28 <zell> Hmm, I was wondering how to do that...
12:30:35 <grantwu> dmwit: Lval has an Int (basically a virtual register id) and a type
12:30:36 <zell> I'll try
12:30:49 <grantwu> I need sets of Lvals to represent which lvals have been declared in a particular scope
12:31:15 <grantwu> Wait, no I don't, scope checking happened in a previous pass
12:31:19 <erisco> that aint right
12:31:28 <zell> Idk, maybe composing hyloM operations can be handled nicely out something, I can't quite get it
12:31:32 <erisco> you have to skip over all the arguments again
12:31:53 <zell> or*
12:31:53 <johnw> zell: hyloM wouldn't apply to pipeline segment, but only to the entire pipeline.  "runEffect" is similar to hyloM
12:32:12 <johnw> so, by itself, hyloM doesn't give you the very thing that makes pipes useful: composition of pre-built segments
12:32:34 <johnw> a Producer is akin to anaM, and a Consumor to cataM
12:33:08 <grantwu> In any case - I only deal with a set in this single compiler pass, but I need the lvals later
12:33:25 <Zemyla> Is there a reason newMVar can't be run outside of IO safely?
12:33:29 <erisco> (id ~> encodeUtf8 ~> (id ~> fmap decodeUtf8) ($[])) match
12:33:29 <zell> With the recursion abstracted away
12:33:35 <erisco> not terribly pleasant, but okay
12:33:47 <johnw> a Pipe is almost the opposite of hylo: rather than cata . ana, it's ana . cata
12:34:09 <zell> Oh, i think i get it, so by not using recusion the hylo can be segmented
12:34:22 <dmwit> grantwu: Right. So what I'm saying is why not use a Map from virtual register ID to Lval, with an invariant that the Lval you reach from ID x has ID x.
12:34:24 <johnw> i'm not sure what you mean by "not using recursion"
12:34:26 <erisco> could add another combinator perhaps
12:34:54 <dmwit> grantwu: ...specifically, an EnumMap, not a Data.Map.Map
12:34:57 <zell> An outer product?
12:35:09 <johnw> zell: don't know what that means either
12:35:11 <ongy> Zemyla: what would the type be for that?
12:35:13 <dmwit> grantwu: Presumably if your ID's are essentially Int's, it will be easy to write an Enum instance for them.
12:35:13 <johnw> zell: again, code is the next place for this
12:36:19 <Zemyla> ongy: Hmm, yeah, good point. If it were run by itself outside of IO, then the compiiler could merge identical newMVar calls.
12:36:30 <grantwu> dmwit: I understand what you're saying - I'm just saying it's a heavyweight approach.  Where before I could write a function that only took an Lval, I now need two parameters, the map and the virtual register ID
12:36:33 <erisco> x ~>$ g f = g . f x  I think, infixr
12:37:03 <erisco> then  id ~> encodeUtf8 ~>$ [] ~> fmap decodeUtf8
12:37:09 <dmwit> grantwu: Surely before your function would at least need an Lval and an EnumSet or similar.
12:37:18 <dmwit> grantwu: Now you need an Lval and an EnumMap. That doesn't seem much worse to me.
12:37:31 <zell> If an inner product (n `dot` m) is <n| |m> then an outer product is |n><m|
12:37:44 <dmwit> grantwu: Then you look up the Lval's ID in the EnumMap.
12:37:56 <grantwu> dmwit: No, I only need an lval and EnumSet in this particular compiler pass
12:38:02 <grantwu> Later passes do not need an enumset or an lval
12:38:10 <grantwu> er
12:38:12 <grantwu> or an enummap
12:38:16 <zell> Using bra ket notation for transposing vectors...
12:38:40 <dmwit> grantwu: My confidence in my understanding of your description has just dramatically dropped.
12:39:17 <grantwu> I'm not sure I described it very well.
12:39:23 <dmwit> grantwu: Perhaps it would help for you to put together a little paste containing the operations you wish you had.
12:39:42 <dmwit> grantwu: Or some code describing what you plan to do. Or something.
12:40:44 <grantwu> I have a compiler due in... two days, and I can very easily get what I want by just using a normal set :/
12:40:49 <grantwu> So forgive me for not doing that
12:41:23 <padre_angolano> уъ уъ!..
12:42:07 <erisco> conal, what do you think?
12:42:54 <dmwit> grantwu: No problem. If you decide you want help/suggestions at some point in the future, we'll still be here. Good luck on your assignment.
12:55:04 <ph88> when i import a data type can i add deriving stuff to it ?
12:55:42 <hpc> look at standalone deriving
12:57:37 <lpaste> tippenein revised “refactoring out a bug in "gsub"”: “refactoring out a bug in "gsub"” at http://lpaste.net/238275
12:57:48 <tippenein> erisco: ^ slightly better
12:58:01 <tippenein> the examples work now :confettiball:
13:03:23 <zell> Ok I made a paste; paste.net/238398
13:04:01 <zell> (zell) Ok I made a paste; lpaste.net/238398
13:05:36 <Utena> Hey so, I'm a complete haskell newb, but using ghc, it gives an error I can't find a ling for in the form of "<filename>:<number>:<number>"  the numbers dont' seem to tightly confrorm to my source file... what do those numbers mean?
13:05:56 <erisco> let ($~>) x g = (g .) . ($x); infixr 1 $~>;
13:05:59 <erisco> that one actually works
13:06:15 <pikajude> :t \ x g -> (g .) . ($ x)
13:06:17 <lambdabot> a1 -> (b -> c) -> (a1 -> a -> b) -> a -> c
13:06:38 <zell> What is this!?
13:06:51 <erisco> a companion to ~>
13:07:09 <zell> :t (~>)
13:07:11 <lambdabot> error:
13:07:11 <lambdabot>     • Variable not in scope: ~>
13:07:11 <lambdabot>     • Perhaps you meant one of these:
13:09:51 <erisco> @let (~>) f g = (g .) . (. f); infixr 1 ~>
13:09:53 <lambdabot>  Defined.
13:10:00 <erisco> @let ($~>) x g = (g .) . ($x); infixr 1 $~>;
13:10:01 <lambdabot>  Defined.
13:10:03 <tippenein> what's a clean way to throw out the Left of an Either for a Nothing ?
13:10:08 <zell> :t \ a b f -> a <=< mapM f <=< b
13:10:09 <lambdabot> (Traversable t, Monad m) => (t b -> m c) -> (a -> m (t a1)) -> (a1 -> m b) -> a -> m c
13:10:19 <tippenein> I'm just using a case, but it seems more than needs
13:10:23 <erisco> :t (*2) ~> [] $~> Just
13:10:25 <lambdabot> Num b1 => (b1 -> [t] -> a -> a1) -> b1 -> a -> Maybe a1
13:11:50 <grantwu> tippenein: https://hackage.haskell.org/package/either-4.4.1.1/docs/Data-Either-Combinators.html
13:11:55 <grantwu> or const
13:12:14 <zell> johnw are you still here?
13:12:53 <tippenein> grantwu: *brent rambo thumbs up*
13:13:46 <erisco> hm, seems to have a flaw
13:15:04 <glguy> :t find (const True) :: Either a b -> Maybe b
13:15:05 <lambdabot> Either a b -> Maybe b
13:15:16 <erisco> :t (*2) ~> [] $~> Just
13:15:17 <lambdabot> Num b1 => (b1 -> [t] -> a) -> b1 -> Maybe a
13:15:19 <erisco> fixed it
13:15:34 <erisco> > (1 $~> 1 $~> (*2)) (+)
13:15:37 <lambdabot>  4
13:15:49 <erisco> conal, how about that one
13:17:03 <erisco> ($~>) x g = g . ($x)
13:20:57 <erisco> :t \x g -> g <<< (flip app x)
13:20:58 <lambdabot> b1 -> (b -> c) -> (b2 -> b1 -> b, b2) -> c
13:21:18 <kaol> Say I have (,) <$> Just 1 <*> (liftA2 (,) (Just 2) (Just 3)) which would give Just (1,(2,3)). How would I do it if I had Just (1,2) instead of Just 2 and Just 3 and would like to get Just (1,2,3)? In other words, what would "something" be in (,,) <$> (Just 1) something (Just (2,3)) to get Just (1,2,3)?
13:22:12 <pikajude> kaol: you'd need (a,b) -> c -> (a,b,c)
13:22:20 <pikajude> so, not (,,)
13:22:31 <erisco> I shouldn't be using flip there
13:22:43 <pikajude> (\ (a,b) c -> (a,b,c)) <$> (Just 1) <*> (Just (2, 3))
13:22:51 <pikajude> whoops, I have the arguments backwards
13:22:53 <pikajude> but you get the idea
13:24:01 <kaol> pikajude: I think I get the idea. Thank you.
13:28:23 <stoogenmeyer> hi folks
13:29:16 <stoogenmeyer> I was wondering, what would be a good book to get into haskell? About a year ago I went through learn you a haskell.. I really liked it but was bothered by the fact that there were no actual exercises.
13:29:40 <dagda1> how do I reference nam e in a data type like this data Person = Person { name :: String }
13:30:01 <eScumpaPoarta> stoogenmeyer, im a beginer and i use https://en.wikibooks.org/wiki/Haskell
13:30:08 <stoogenmeyer> At the time I also went through a certain CS course that was recommended.. I did like it as I felt like the exercises were challenging and useful, but remember that towards the end of it I got a little frustrated as it seemed that the exercises contained some errors and it kind of threw me off
13:30:25 <EvanR> dagda1: well `name' is then an accessor for Person to get a String
13:30:28 <EvanR> name myPerson
13:30:33 <eScumpaPoarta> you can find it as pdf too
13:31:34 <stoogenmeyer> eScumpaPoarta: oh nice.. that looks pretty thorough, are you just going through it reading and coding at the same time?
13:31:45 <eScumpaPoarta> yes
13:31:55 <eScumpaPoarta> its the best book i found so far
13:32:01 <stoogenmeyer> I'm looking for something that will help me get into using haskell for more practical projects rather then as fun exploration in my spare time
13:32:24 <eScumpaPoarta> that book is quite useful if ure a beginner
13:32:59 <JoshPrice247> Hello everyone, i noticed something minor that needs to be added to the the wiki. Is this a good place to tell someone?
13:34:02 <stoogenmeyer> eScumpaPoarta: also, mind if I ask, what's your dev environment like?
13:34:05 <EvanR> stoogenmeyer: good question, thats not well covered by any books. except for the quasi ancient Real World Haskell
13:34:22 <EvanR> even then i dont know if its really about practical projects
13:34:45 <stoogenmeyer> EvanR: yea, I've considered it but saw some fairly bad reviews saying its not worth the time
13:34:49 <eScumpaPoarta> stoogenmeyer, for now, i use ghci and vscode
13:34:50 <EvanR> thats something you just need to do yourself, get the cabal or stack docs, look at how real packages are structured
13:35:07 <stoogenmeyer> Yep.. I guess the best way is just by doing
13:35:13 <eScumpaPoarta> u need the basics first imho
13:35:41 <EvanR> for learning "the basics" of haskell thats another story, you can check out bitemyapp's github page on that
13:35:44 <stoogenmeyer> That's something I feel I have for the most part.. At least to a point where I could start being somewhat productive
13:35:46 <EvanR> @where learnhaskell
13:35:47 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:36:41 <stoogenmeyer> yep haha, about a year ago did learn you a haskell and cis194.. I'll take a look at the other suggestions. thanks
13:37:20 <glguy> I think that someone looking for a Haskell project as something to learn from modifying, and who is asking on IRC might like messing around with my IRC client
13:37:45 <eScumpaPoarta> i heard haskell is very good to build parsers
13:44:47 <stoogenmeyer> I was wondering if people here who work professionally with haskell.. do you use it for basically everything? Or are there certain cases where you use a different language?
13:49:32 <Cale> stoogenmeyer: I work professionally with Haskell. I would use it for *nearly* anything...
13:50:09 <thoughtpolice> stoogenmeyer: I don't use it for literally everything (C, etc). But the vast majority of things (+90%), yes. Even for 'weird' things like writing build systems (or more recently, a small 16-bit CPU that is compiled to Verilog.) Obviously, some level of that just comes from familiarity, not just awesomeness or anything.
13:50:15 <thoughtpolice> (Although awesomeness is a factor)
13:50:47 <stoogenmeyer> thoughtpolice: sounds like interesting things
13:50:48 <Cale> stoogenmeyer: If your code has to run on a very small machine, something like a microcontroller, you wouldn't want to use Haskell directly for that, but you might use a Haskell program to *generate* the code that will run on the microcontroller.
13:51:45 <thoughtpolice> (Also, I mean awesomeness on part of Haskell. I'm not particularly awesome)
13:52:03 <thoughtpolice> stoogenmeyer: http://shakebuild.com && http://clash-lang.org, for those particular weird examples.
13:52:20 <Cale> stoogenmeyer: I've been working with Obsidian Systems, we write web applications entirely in Haskell -- with the backend using snap and postgresql bindings and compiling to native code with ghc, and the frontend using reflex-dom and compiling to javascript with ghcjs
13:52:28 <EvanR> thoughtpolice: dont lie
13:52:28 <Tuplanolla> The few times I've programmed professionally, I've used Haskell more to direct my thoughts rather than produce things in Haskell, stoogenmeyer.
13:52:41 <Welkin> hola
13:52:46 <stoogenmeyer> oh wow, clash - that is super interesting
13:53:17 <Welkin> thoughtpolice: thanks for that servant issue on github yesterday
13:53:20 <thoughtpolice> EvanR: rumors of my coolness are greatly exaggerated
13:53:23 <Welkin> it was just what I was trying to do
13:53:26 <Welkin> haha
13:53:28 <thoughtpolice> Welkin: np
13:54:07 <Cale> stoogenmeyer: It's really nice that as you carry out some refactor, or add a new feature, type errors can propagate between the frontend and backend via a bunch of code which is shared between them. So you don't end up with very many mismatches between what either side is producing and the other is expecting.
13:55:31 <Cale> (which is like 90% of the bugs in most web applications)
13:55:36 <stoogenmeyer> Cale: That is a nice thing. This is a case where those specific components share code for their data models..?
13:55:43 <Cale> yeah
13:56:44 <stoogenmeyer> gotta go. thanks, nice talking to you guys.
13:56:54 <eScumpaPoarta> does haskell have a nice future ahead?
13:57:33 <Cale> eScumpaPoarta: I think its future is pretty secure.
13:57:47 <ph88> how can i change two members of a record to a new value ?
13:59:12 <zell> Clash-Lang looks amazing
13:59:13 <Cale> ph88: someRecord {field1 = x, field3 = y}
13:59:26 <Welkin> what is clash-lang?
13:59:50 <zell> http://www.clash-lang.org/
13:59:57 <thoughtpolice> It turns GHC from a compiler from Haskell -> Assembly to Haskell -> Verilog, pretty much.
14:00:27 <thoughtpolice> It's not an embedded language like Lava, or any DSL. It's the real deal, the same GHC. It merely has a few restrictions
14:00:47 <thoughtpolice> (So it's really more accurate to call it "A haskell" or something rather than "Haskell", since you can't use some forms of e.g. recursion)
14:00:51 <zell> Google says; Verilog, standardized as IEEE 1364, is a hardware description language (HDL) used to model electronic systems. It is most commonly used in the design and verification of digital circuits at the register-transfer level of abstraction.
14:01:41 <zell> Can't you compile to verilog using ghc?
14:02:32 <zell> Or is there something special about clash instead of Haskell for designing device architectures?
14:02:51 <thoughtpolice> No. Clash requires a much different compilation pipeline with many different optimizations than what "normal" Haskell code you would execute on a CPU needs. Also, not everything you write in Haskell is synthesizable to Verilog - this is part of the 'restrictions' I mentioned.
14:03:20 <zell> You can't have recursive circuits?
14:03:48 <zell> I guess I'm over my head
14:03:52 <thoughtpolice> No, you can. You just can't do certain forms of value level recursion explicitly.
14:03:57 <Welkin> zell: you can't program in a HDL like you do in javascript
14:04:04 <Welkin> every if must have a matching else
14:04:08 <Tuplanolla> This reminds me of Conal's work on applications of Cartesian closed categories, thoughtpolice. Is it even close?
14:04:09 <Welkin> and other things
14:04:49 <thoughtpolice> zell: For example, you CAN say something like "z = register 0 (z + 1)", which is a circuit that has state, and outputs the numbers 0, 1, 2, 3, 4, etc on every clock tick. This form of recursion is allowed.
14:05:02 <eScumpaPoarta> are there any fp languages in the same league as haskell?
14:05:16 <zell> Ocaml?
14:05:42 <zell> Haskell is strongest
14:05:43 <thoughtpolice> What is not allowed is doing things like "go 0 z = z; go n = ... do something ... in go (n-1) z", where you have explicit recursion that the compiler cannot prove terminates in a finite number of steps.
14:06:31 <byorgey> eScumpaPoarta: Racket, Clojure, F#, Scala, Agda, Idris, ...
14:06:37 <zell> Ok, probably finite circuits sound good
14:06:39 <thoughtpolice> Tuplanolla: Probably, somehow. There is a definitely a categorical approach to talking about circuits. Many things sort of admit this, and you can see it in CLaSH.
14:07:11 <eScumpaPoarta> i did mention "in the same league"
14:07:14 <zell> byorgey, which of these are rigidly typed?
14:08:32 <zell> I don't think Scala is much like the fp of Haskell, I guess rigid typing is the key to this difference... Idk
14:08:55 <thoughtpolice> Tuplanolla: Like, there is a thing in CLaSH called "bundle" and "unbundle", which basically allow you to turn things of type "(Signal a, Signal b)" into "Signal (a, b)", and unbundle does the inverse. This kind of identity is very "obvious" for circuits in a sense.
14:09:06 <byorgey> zell: if you don't think Scala is rigidly typed, then I don't know what you mean by "rigidly typed"
14:09:17 <eScumpaPoarta> by "in the same league" i meant highly appreciated and used 
14:09:20 <zell> Neither do I, i think that's the problem
14:09:39 <byorgey> eScumpaPoarta: all of those are highly appreciated and used.
14:10:16 <thoughtpolice> Tuplanolla: Which sort of gives me the impression there's some sort of commutative diagram describing how this all commutes and formalizes such an intiution. Or whatever mumbo jumbo fancy words people use to say that!
14:10:31 <Tuplanolla> Yes, fancy words!
14:10:39 <eScumpaPoarta> byorgey, is there any fp language invented in post 80s thats not highly appreciated and used?
14:10:53 <zell> :t traverse
14:10:55 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:11:12 <byorgey> eScumpaPoarta: I'm sure there are lots, that no one has ever heard of
14:11:40 <Tuplanolla> You could make one more in an afternoon, eScumpaPoarta.
14:12:03 <eScumpaPoarta> naah, im too tired and amazed by haskell purity
14:12:09 <Tuplanolla> Not being appreciated is not a particularly difficult goal to reach.
14:12:18 <zell> lol
14:12:48 <EvanR> blinded by the light
14:16:31 <zell> Can you run Haskell programs complied to prolog in other languages? Would this be more simple than translating Haskell to e.g. C, supposing a C library exists to run the compiled prolog
14:17:16 <zell> If this approach is feasible, has it been implemented?
14:17:31 <Koterpillar> zell: this is hardly simpler - so many moving parts!
14:17:53 <Koterpillar> you can already link Haskell to C, so why bother with Prolog?
14:17:57 <zell> Is there a better common language than prolog to compile to?
14:18:15 <Koterpillar> to do what?
14:18:21 <zell> Because I want to link to some crazy language
14:18:28 <Welkin> zell: Ook?
14:18:45 <zell> Eg, Android java
14:19:04 <Koterpillar> ...you already can run Haskell on Android
14:19:10 <zell> And run on a different architecture
14:19:34 <zell> Koterpillar, no you can't, not without emulating linux
14:20:19 <zell> Id rather use an internal prolog compiler than an internal Linux kernal
14:20:54 <Koterpillar> there's also a project for a JVM backend
14:21:00 <Koterpillar> this should help when it's done
14:21:15 <Welkin> who would even use it?
14:21:19 <Welkin> just for android?
14:21:20 <zell> If you have a working project which gets Haskell to run on Android I would love to see it. All the ones i know are bitrotten
14:21:32 <Clint> doesn't git-annex?
14:21:48 <ph88> is there any way to get the type of a function in the where-clause ?
14:21:57 <zell> Lol Welkin, get a smart phone, you can fly to work on them
14:22:21 <Welkin> zell: what?
14:22:27 <Koterpillar> zell: does a Haskell to Prolog translator exist?
14:22:28 <zell> ph88 no, it's not visible at top level
14:22:52 <Rarrikins> ph88: If you mean declaring it, just put it on the line just above the definition.
14:23:05 <zell> I don't know why you think Haskell on the fastest growing OS isn't a serious priority
14:23:19 <Welkin> zell: it's not o.o
14:23:26 <ph88> i'm not sure what should be the correct type
14:23:35 <Koterpillar> zell: fastest-growing? https://xkcd.com/1102/
14:23:42 <Welkin> it's a locked down system anyway
14:23:52 <Rarrikins> ph88: You can make it a top-level function instead and work it out from there, then move it back.
14:23:54 <Welkin> if you want to get any distribution
14:23:57 <Koterpillar> Welkin: so are a lot of others, unfortunately
14:23:58 <hexagoxel> ph88: tried a typed hole in the signature?
14:24:04 <zell> Just change the indentation so it's visible at top level
14:24:15 <Koterpillar> zell: it would be nice, yes, make it happen please?
14:25:08 <hexagoxel> moving to top-level won't be possible with the exact same signature in general
14:25:08 <zell> So, are there better language than prolog to compile to and from?
14:25:09 <Koterpillar> zell: whether you build it via a Prolog or Smalltalk or both, you'll get the deserved fame
14:25:17 <Koterpillar> zell: JVM
14:25:18 <ph88> hexagoxel, yes i think so .. but then it starts about typeclass stuff
14:25:36 <zell> So it's done already
14:25:43 <Welkin> 17:24 < zell> So, are there better language than prolog to compile to and from?
14:25:47 <Welkin> this should be quoted
14:25:55 <hexagoxel> ph88: so then _ => whatever -> you -> got -> already
14:25:56 <Koterpillar> zell: underway, I think it compiles a Hello World or something
14:26:10 <Welkin> @remember zell <zell> So, are there better language than prolog to compile to and from?
14:26:10 <lambdabot> I will never forget.
14:26:17 <zell> Rrg
14:26:43 <zell> That's not what I want to be remembered for
14:26:46 <Welkin> haha
14:26:54 <Welkin> it's such a weird thing to ask
14:27:06 <zell> Jvm was a good answer
14:27:30 <Koterpillar> zell: it's kind of offtopic, but why do you think Prolog is a good intermediate language?
14:27:42 <zell> I guess I want the smallest thing... Would stgm work?
14:28:01 <Tuplanolla> Just mov, zell.
14:28:08 <Koterpillar> zell: I don't think that's a bad idea either
14:28:16 <zell> Koteepillar, other users here have worked with it, i perceived that it wad in vogue
14:28:36 <zell> Was*
14:28:44 <Welkin> prolog is a language used in AI classes
14:28:53 <hexagoxel> ph88: i don't think at top level you'd get more information than what wildcards for the whole type and the constraints would provide. not completely certain though.
14:28:58 <Welkin> I've never seen it used in a real project before
14:29:02 <Koterpillar> Welkin: so is LISP
14:29:09 <zell> https://en.m.wikipedia.org/wiki/MOV_(x86_instruction)
14:29:11 <Welkin> Koterpillar: which one?
14:29:16 <Koterpillar> Welkin: there was an email service written in Prolog
14:29:59 <Koterpillar> mulisp was what I got
14:30:06 <Koterpillar> why mulisp I have no idea
14:30:24 <zell> So if we are designing architectures, i thought prolog would have a simpler compiler to a simple architecture
14:31:10 <Koterpillar> zell: now I think about it, isn't Prolog similar to stg with backtracking?
14:31:14 <zell> Mov is far too large
14:31:18 <Welkin> doesn't ghc compile from haskell -> core -> stg -> c-- -> machine code ?
14:31:30 <zell> I think it used too
14:31:47 <zell> Or something like that
14:32:10 <zell> I have no idea about prolog or stg
14:32:38 <Koterpillar> O_o
14:32:47 <zell> Koterpillar, what did you mean when you said Haskell runs on Android?
14:33:00 <zell> Ghc produces an exe, not an apk
14:33:16 <Koterpillar> https://wiki.haskell.org/Android
14:33:22 <Clint> zell: https://git-annex.branchable.com/install/Android/
14:33:31 <Koterpillar> you can cross-compile
14:33:52 <lolisa> Hello, I had finished the theorem for free paper. I wonder in what way is it 'used' in programming?
14:34:07 <Koterpillar> zell: https://github.com/sseefried/open-epidemic-game
14:34:13 <zell> Can I run ghc on got annex?
14:34:29 <Koterpillar> zell: no
14:35:04 <Koterpillar> zell: running compiled code on Android and having a compiler on Android are different things
14:36:44 <erisco> Haskell, powered by Android
14:36:46 <zell> I wish to develop on and deploy to Android, add I do on Windows and Linux
14:36:57 <zell> As*
14:37:14 <erisco> it is a nightmarish proposition
14:37:25 <Koterpillar> zell: I'm guessing developing on Android will be easier with a Debian chroot or something
14:37:41 <erisco> do you really want to funnel things through JNI to interact with Android facilities?
14:37:52 <erisco> not to mention you are stuck using Android APIs anyways
14:37:55 <lordcirth> lolisa, what do you mean?
14:38:26 <zell> At the moment I got ghc working on Android using proot, which does not require rooting, via gnuroot-debian which is since depreciated
14:38:36 <Welkin> why would you want to run haskell on android so badly?
14:38:50 <Welkin> wait...
14:38:56 <Welkin> you are running ghc on android?
14:38:56 <zell> I only have a phone
14:39:04 <Welkin> why
14:39:07 <lolisa> lordcirth, like, it is really cool to know property of value base on type, but how do we beneifit from it in the end? For example, does GHC use parametricity to optimize?
14:39:20 <zell> Because the future Welkin
14:39:22 <erisco> are you saying you are talking to us with your phone?
14:39:26 <zell> Yes
14:39:44 <zell> Always, hence stupid typos from swype
14:39:46 <Koterpillar> zell: get a VDS or something
14:39:50 <lordcirth> Phones-only is hardly the future for programmers
14:39:55 <Welkin> ew
14:39:56 <Welkin> hell no
14:40:07 <Koterpillar> zell: and a keyboard, while you're at it
14:40:22 <Welkin> keep your walled garden that doesn't run anything but fart apps
14:40:31 <lordcirth> Yeah, if you had a cloud server somewhere, and a keyboard, you could do ok.
14:40:53 <ongy> zenphone?
14:40:57 <Welkin> you could put together a decent PC for a hundred dollars or less o.o
14:41:03 <erisco> but the screen is so small
14:41:10 <Welkin> even get used peripherals
14:41:35 <erisco> I found I needed three displays, so I can't imagine XD
14:41:41 <zell> I would like to write a cloud vds that pools mobile resource to support a Haskell ide. The server and farm should run on Android without root and be written in Haskell
14:41:42 <Welkin> why would you *only* have a phone as a programmer?
14:41:43 <lordcirth> zell, why do you only have a phone?  Money, minimalism, what?
14:42:07 <Koterpillar> zell: this is an awful idea but go ahead by all means
14:42:10 <zell> Yes I was homeless for nearly the last 2 years
14:42:25 <lordcirth> zell, you want to farm GHC compilation across Android devices?  Fun project...
14:42:33 <zell> Still got plenty of Haskell done!
14:42:39 <Tehnix> Hmm, too bad the fpco editor isn't really a thing anymore :(
14:42:46 <zell> Thanks to my trusty smartphone
14:42:47 <Tehnix> (in the case of only mobile)
14:43:14 <Koterpillar> zell: invest your time in something paid-for, and get an x86 machine
14:43:36 <zell> Anyway, the dino community are reluctant to participate in such cutting edge projects!
14:43:45 <Koterpillar> zell: this will be more productive than trying to get distributed Haskell on Android via Prolog
14:43:53 <zell> Haskell on Android should be 3 years old by now
14:44:11 <Welkin> why would any compiler run on android?
14:44:19 <Koterpillar> Welkin: because someone wrote it
14:44:21 <Welkin> it's not even made for that
14:44:25 <zell> I thought jvm had been decided upon...
14:44:44 <Rarrikins> zell: Decided upon by whom?
14:44:46 <Koterpillar> zell: whatever, my advice stands
14:44:52 <zell> You just before
14:44:59 <lordcirth> Welkin, Few things we use computers for today were designed for originally.
14:45:12 <Koterpillar> zell: I suggested JVM, I didn't volunteer to implement it
14:45:34 <erisco> lets say you can write Android apps in Haskell, who is going to use this? I am not suggesting no one uses it, but does it compensate for the effort?
14:45:41 <Rarrikins> zell: You can write it however you want to. It's possible to run native code on Android as well, though there's the issue of different hardware platforms like x86 vs ARM.
14:45:49 <erisco> it is a bit of a catch-22, but that's just how it is
14:45:59 <zell> Rather than running a Linux kernel I wanted a Haskell OS, but the only solution uses XEN which is bare metal so unsuitable for an unrooted phone
14:46:01 <Welkin> erisco: he is not talking about a haskell -> android compiler... he is talking about running ghc inside of android
14:46:11 <Koterpillar> ooooh unikernel now
14:46:29 <Welkin> compiling haskell apps to run on android would at least be sensible
14:46:31 <erisco> well that is easier, except for interacting with the compiler
14:46:34 <Rarrikins> zell: You're not going to get much help here because the things you propose seem useless.
14:46:46 <erisco> is there an ARM backend for GHC?
14:46:50 <Welkin> no
14:46:53 <Koterpillar> erisco: GHC runs on ARM
14:46:54 <Rarrikins> zell: For example, the Android OS is fine for just about everyone.
14:46:57 <Welkin> really?
14:46:57 <erisco> well, some android is x86
14:47:08 <Koterpillar> GHC runs fine on ARM and compiles to ARM
14:47:26 <zell> erisco, would you buy ghc for Android from the play store? You can monetise your apps then, releasing them in the play store
14:47:27 <erisco> you can run native code on Android with JNI
14:47:28 <ongy> imo distcc-ish support in GHC sounds quite nice. And if it's somewhat reasonable to get it running on android, that's just an added bonus 
14:47:35 <erisco> the problem is then how you are going to interact with the compiler
14:47:42 <erisco> you'd have to build a Java application for it
14:47:51 <Koterpillar> zell: you don't have to compile on Android
14:47:56 <Welkin> you would need to port emacs to android too then
14:47:59 <zell> Right, or compile to jvm
14:48:11 <Koterpillar> Welkin: vim on android exists...
14:48:16 <erisco> zell, are you running GHC on Android or compiling for Android? these are completely different things
14:48:19 <Welkin> ew, you expect me to use vim?
14:48:25 <Clint> they have emacs too
14:48:45 <zell> If you do compile on Android then you can develop in Haskell for mobile platforms on mobile platforms
14:48:57 <Koterpillar> zell: no one wants that
14:49:00 <erisco> yes, but it is two different tasks, just to be clear
14:49:28 <zell> Im running Haskell in a Linux kernel written in java compiled to Android
14:49:30 <erisco> wrt building Android applications with Haskell it sounds like a miserable idea
14:49:47 <erisco> they can barely get the Java right
14:49:49 <Koterpillar> zell: good on you, but your target market is nil
14:49:55 <zell> This community sucks
14:49:57 <erisco> how are you going to keep pace with bindings through JNI for Haskell
14:49:58 <zell> Goodbye
14:50:22 <Welkin> haha
14:50:23 <EvanR> so much for java making everything easy circa 1990
14:50:27 <erisco> well I have developed on Android for a while and this is just how it is XD
14:50:53 <Tuplanolla> So much for 3 billion devices running Haskell.
14:50:55 <erisco> have wished for something other than Java myself
14:50:58 <Welkin> erisco: I have not developed on andoird, but I have developed for ios, and it is a pain in the ass, mostly to build and submit
14:51:09 <ongy> fuchsia may be comming
14:51:16 <EvanR> more like, java making devices across the board equally shitty to develop on
14:51:19 <maerwald> wtf just happened
14:51:21 <erisco> best I have seen is Xamarin which is .NET on mobile
14:51:32 <ongy> imo android is a bit more usable than ios for dev, not sure about deploy to playstore
14:51:36 <Welkin> maerwald: zell wanted to know about porting ghc to run on android
14:51:40 <erisco> they are a sizable company now owned by Microsoft
14:51:49 <erisco> and even they have a hard time keeping it straight
14:52:01 <maerwald> Welkin: sounds like a broken workflow
14:52:14 <Welkin> maerwald: his problem is he only has a phone
14:52:21 <maerwald> -.-
14:52:26 <EvanR> yes it sounded like they wanted to use emacs to develop haskell apps directly on the phone
14:52:29 <Welkin> his solution is to port ghc to android and compile accross multiple phones in the cloud
14:52:36 <Welkin> instead of the simpler solution of getting a pc
14:52:37 <Koterpillar> Welkin: no, they have a phone and an attitude
14:52:51 <Rarrikins> They'd mentioned that they were homeless, so I assume the reason for all that was because laptops were unaffordable.
14:53:03 <Welkin> homeless people have laptops o.o
14:53:09 <maerwald> Welkin: in fact, yes
14:53:12 <Welkin> they can get them free, or super cheap, too
14:53:14 <Welkin> people donate them
14:53:16 <maerwald> there was a blog post about it once
14:53:22 <Rarrikins> Yeah, some do, but if you start out without one, it can be hard to get one.
14:53:29 * hackagebot eventstore 0.13.1.6 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.13.1.6 (YorickLaupa)
14:53:29 <Koterpillar> Welkin: it's hard to keep a laptop from being stolen?
14:53:31 <erisco> "there was a blog post about it once"
14:53:31 * hackagebot xkbcommon 0.0.3 - Haskell bindings for libxkbcommon  https://hackage.haskell.org/package/xkbcommon-0.0.3 (AukeBooij)
14:53:33 * hackagebot purescript 0.10.1 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.10.1 (PhilFreeman)
14:53:41 <erisco> @quote <maerwald> there was a blog post about it once
14:53:41 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
14:53:45 <maerwald> erisco: yes, a journalist made a "collection" or something
14:53:48 <erisco> @remember <maerwald> there was a blog post about it once
14:53:49 <lambdabot> I will remember.
14:53:49 <maerwald> I can look for it if you want
14:53:56 <Welkin> erisco: you did it wrong
14:53:57 <maerwald> with pictures
14:54:01 <Welkin> @quote maerwald 
14:54:01 <lambdabot> No quotes match. My mind is going. I can feel it.
14:54:05 <erisco> I just like the generality of the statement ;)
14:54:06 <Welkin> @quote <maerwald> 
14:54:07 <lambdabot> <maerwald> says: there was a blog post about it once
14:54:10 <Welkin> see?
14:54:17 <erisco> Welkin, that is how my IRC client copies the text
14:54:26 <erisco> and to my benefit it lets me get the exact quote I want
14:54:29 <erisco> @quote medfly>
14:54:29 <lambdabot> medfly> says: and at work I have a slightly less large dump because I don't want to accidentally have naked ladies show up
14:54:30 <erisco> see
14:54:33 <Welkin> oh
14:54:39 <Welkin> is medfly still around?
14:54:39 <maerwald> erisco: thanks for putting my sentence out of context then
14:54:54 <Tuplanolla> @quote says:
14:54:54 <lambdabot> lambdabot says: LoganCapaldo says: that quote is so awesome I'd @remember it again if it weren't already remembered
14:55:13 <ongy> nice one
14:55:13 <erisco> maerwald, all my @remember's are quote mined, sorry, but not sorry
14:55:20 <EvanR> Welkin: no. thanks Welkin 
14:56:11 <ongy> I think the idea of distributed GHC is nice. distcc seems to get it done with C, how high is the chance it's reasonably doable with haskell?
14:56:26 <maerwald> distcc is often broken
14:57:05 <EvanR> http://stackoverflow.com/questions/10323419/is-there-a-distcc-like-tool-for-ghc
14:57:45 <ongy> ah nice. I will have to look into setting that up then
14:58:01 <lolisa> @quote <ongy>
14:58:01 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
14:58:10 <Welkin> @quote ongy
14:58:10 <lambdabot> No quotes match. You speak an infinite deal of nothing.
14:58:16 <Welkin> @quote lolisa
14:58:16 <lambdabot> No quotes match.
14:58:20 <Welkin> @quote EvanR 
14:58:20 <lambdabot> EvanR says: ruby, cobol of the 2000s
14:58:25 <ongy> I have not said anything remember worthy yet
14:58:36 <erisco> I shudder to think what is on there for me
14:58:38 <erisco> @quote erisco
14:58:38 <lambdabot> erisco says: <erisco> let me tell you a little bit about how markets work <erisco> disclaimer is that I know nothing about markets
14:58:58 <erisco> vapid, sounds about right
14:59:08 <lolisa> @quote <EvanR>
14:59:08 <lambdabot> roconnor says: writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in
14:59:08 <lambdabot> haskell ;) <kmc> that's a pretty good summary
14:59:31 <lolisa> @quote incorrect
14:59:31 <lambdabot> roconnor says: writing incorrect programs in Haskell is hard. but writing correct programs is hard in every langauge. therefore, writing code in Haskell is hard. <EvanR> everything is hard in
14:59:31 <lambdabot> haskell ;) <kmc> that's a pretty good summary
15:00:10 <lolisa> @quote just a monoid
15:00:10 <lambdabot> No quotes for this person.
15:00:21 <erisco> well that's a nice feely wheely description, but it aint hard to write incorrect programs in Haskell
15:01:17 <EvanR> @forget EvanR
15:01:17 <lambdabot> Incorrect arguments to quote
15:01:22 <erisco> there are two stories
15:01:40 <EvanR> @quote EvanR < EvanR> @forget EvanR
15:01:40 <lambdabot> No quotes match. Do you think like you type?
15:01:46 <EvanR> @remember EvanR < EvanR> @forget EvanR
15:01:46 <lambdabot> Done.
15:01:52 <erisco> one story is that Haskell is more busywork, though largely that is because of static versus dynamic typing and conversion rules and so forth
15:02:06 <erisco> and that's true
15:02:10 <Koterpillar> EvanR: meta
15:03:23 <EvanR> erisco: large amounts of type definitions and tedious derivable support can be metaprogrammed with TH
15:03:29 <ongy> I'll look into distcc tomorow good night
15:03:29 <erisco> the other story is that Haskell lets you make less mistakes
15:03:47 <ph88> this is nice http://stackoverflow.com/a/14955676/1833322 .. is it possible to use the "old" value when updating the record though ?
15:03:50 <EvanR> if the only saving grace is that youre not doing the same stuff over and over, rather, you dont feel like what youre doing can be done by a program 
15:03:59 <erisco> in that respect it is not more difficult, you are just wrong
15:04:15 <Koterpillar> ph88: updateFoo x = x { c = c x + 1 }
15:05:10 <erisco> EvanR, well, there are things you may do in dynamic languages especially with data structures that require much more work statically
15:05:27 <Koterpillar> ph88: also, look at lenses
15:05:47 <maerwald> EvanR: TH...
15:05:49 <erisco> you have to start solving problems a bit differently, which requires more definitions and more parts
15:06:39 <maerwald> the most widely used language isn't even a dynamic one
15:06:50 <erisco> C?
15:06:58 <maerwald> java
15:07:09 <EvanR> i was going to suggest adult language
15:07:11 <erisco> how do you measure? by LoC or programs or installations or what?
15:07:17 <maerwald> tiobe index
15:07:28 <kaste> doesn't really make a difference for your argument
15:07:29 <EvanR> number of mentions on the internet
15:07:30 <kaste> neither is dynamic
15:07:56 <EvanR> yeah, java is the best dynamically typed language
15:07:59 <maerwald> I just don't think the "static vs dynamic" thing is the main difference here
15:08:26 <erisco> "There are 25 search engines that are used to calculate the TIOBE index."
15:08:26 <Welkin> the most widely used language is javascript
15:08:31 <Welkin> because you have no choice
15:08:37 <Welkin> unless you compile to javascript
15:08:39 <erisco> I wouldn't measure it by number of pages that mention it
15:08:44 <Welkin> for some reason, people are scared of that
15:09:01 <erisco> if you consider installations, I think C makes up most of firmware, and that makes up most installations
15:09:22 <maerwald> doesn't matter for the argument
15:09:36 <Welkin> no, of people writing in the language
15:09:50 <erisco> I don't see how popularity relates to the difficulty debate
15:10:04 <maerwald> I can code a lot of stuff in statically typed java without being required to think a lot
15:10:08 <erisco> the number of professionals? meh
15:10:13 <Welkin> no...
15:10:14 <maerwald> so "not being dynamic" isn't the thing here
15:10:20 <Welkin> what is a "professional"?
15:10:30 <erisco> someone paid for the skill
15:10:43 <Welkin> who are they paid by?
15:10:45 <EvanR> someone who gets paid
15:10:49 <erisco> what, are you going to qualify every person who has written even just one program in a language?
15:11:03 <maerwald> and... derailed
15:11:05 <maerwald> fascinating
15:11:06 <erisco> that means the most popular language is the one standardised in the most schools, likely
15:11:23 <erisco> and everything to do just with how many people have written something with it, not how much they write
15:11:27 <Welkin> no
15:11:31 <EvanR> erisco: so visual basic...
15:12:17 <Welkin> if this was Civ, we could choose the world religio-- I mean the world programming language
15:12:36 <Welkin> like how I spread Linuxism, and then passed a law to make it the world religion
15:12:38 <erisco> maerwald, would you have to think any more doing the same thing in Haskell?
15:12:51 <maerwald> yes
15:12:56 <erisco> why is that? what are you writing?
15:13:28 <EvanR> haskell requires thought by definition, as soon as it doesnt, TH ;)
15:14:34 <erisco> Java has less sophisticated types and so there is less you can do, but for what you can do there is no particular difference I can discern between Java and Haskell
15:14:45 <erisco> other than it is syntactically more burdensome in Java
15:15:05 <Welkin> sure, yuo can pretty much do anything in any language
15:15:07 <Welkin> but at what cost?
15:15:07 <EvanR> its true java and haskell have similarities outside the language
15:15:11 <Welkin> and some things you cannot do
15:15:16 <Welkin> like fix the type system
15:15:17 <EvanR> but only some
15:15:56 <maerwald> erisco: 1. algorithms often are expressed imperatively, 2. effects are explicit in the types, which is a huge design constraint
15:16:12 <erisco> except for oddities like exceptions, return, break, continue … there isn't much surprise in statements
15:16:50 <EvanR> having to fix insanely written java/php/whatever before moving on is a design constraint
15:17:05 <erisco> well, I do not know what "imperative" means, this seems to mean something different every time I hear it
15:17:46 <EvanR> on imperative algorithms, i forgot about those ;)
15:17:54 <EvanR> worst case use an IO program
15:18:17 <erisco> but wrt mutability and procedural / structured programming … well, if you find that easier than I suppose missing them is harder
15:18:54 <maerwald> I'm not going to explain "imperative", that's silly
15:19:09 <maerwald> and it's not about whether someone finds it easiert to program in some paradigm
15:19:21 <erisco> well I thought that was the discussion
15:19:29 <maerwald> it's about whether complicated algorithm pseudo-code is written in imperative-style or not
15:19:41 <maerwald> and if you have to reverse-engineer it
15:19:50 <maerwald> which may not be trivial
15:20:10 <erisco> to me, imperative means you are describing how to achieve a goal from parts, whereas declarative is atomic, i.e. one part
15:20:14 <Tuplanolla> It's funny how pseudocode is often written with numbered steps and go-to, much like recipes in a cookbook.
15:20:39 <erisco> so I can, for example, declaratively tell you "sort the list"
15:20:52 <EvanR> maerwald: understanding insanely written fortran before moving on.... actually just dont worry about it and use it as is
15:21:14 <erisco> or I can tell you "take the first element of the list, then partition the remaining elements … and so on"
15:21:25 <erisco> imperative
15:21:27 <maerwald> I am not talking about trivial list operations
15:21:59 <maerwald> https://pdfs.semanticscholar.org/bfc5/05f3134419041fa84194e01a274b17df5987.pdf try this in idiomatic haskell
15:22:03 <erisco> i.e. "what to do" (declarative) versus "how to do it" (imperative)
15:22:22 <EvanR> "sort the list" is imperative mood, "the sorted list" is not
15:22:38 <EvanR> declarative is "what stuff is"
15:22:41 <erisco> well I don't know where this discussion is going now
15:23:03 <maerwald> try this in idiomatic haskell without resorting to external libraries: http://www.flipcode.com/archives/The_Half-Edge_Data_Structure.shtml
15:23:16 <erisco> the average person isn't implementing cryptographic algorithms
15:24:01 <maerwald> or this one: https://en.wikipedia.org/wiki/Polygon_triangulation
15:24:26 <erisco> what features make it challenging?
15:24:46 <maerwald> I already told you: the pseudo code is imperative and so is the idea of the algorithm
15:24:54 <EvanR> maerwald: this appears to be a graph
15:25:07 <maerwald> EvanR: yeah, I've implemented it
15:25:29 <EvanR> the "idiomatic" (though seems really unpopular) way is to tie the knot
15:25:30 <maerwald> it's a lot more work
15:25:30 <Koterpillar> maerwald: "imperative" means State, Free, Cont, IO in the worst case
15:26:13 <EvanR> no worst case would be if we didnt have do notation for that ;)
15:26:27 <Koterpillar> maerwald: sure, for some definition of "a lot"
15:26:49 <EvanR> maerwald: well ive made a few things way more ridiculous than that structure in C++, and its a lot of work
15:26:56 <EvanR> because segfaults
15:27:09 <erisco> maerwald, well I don't know then, I'd have to understand the problems well first before I could assess the difficulty
15:27:23 <maerwald> aha
15:27:42 <Cale> maerwald: That kind of pure (i.e. no/limited I/O) imperative pseudocode tends not to be too difficult to translate into a functional style
15:27:45 <erisco> a solution presented procedurally is not necessarily difficult to make functional
15:28:17 <EvanR> basically maerwald should give up and agree that functional programming is a breeze
15:28:31 <maerwald> Cale: I was talking about idiomatic haskell, translating that into ST/IO isn't idiomatic to me and gives zero benefit. Exceptions are things where the algorithm in it's very nature is "imperative"
15:28:36 <erisco> often they are accumulating data in some data structure, be it a stack or queue or some such, and such accumulation is not difficult to make functional
15:28:52 <EvanR> maerwald: is that what you did?
15:28:57 <Cale> If you're completely lost and want to brute force it, just take each point of control in the imperative program and turn it into its own function (which will compute the result of the function from that point onward) -- each mutable variable becomes a function parameter, and these functions apply each other to new arguments according to the control flow and how updates happen.
15:29:05 <maerwald> EvanR: did what?
15:29:15 <EvanR> is that how you implemented the structure with IO?
15:29:15 <Cale> This will initially result in a mess - but it's a mess of equations, so you can immediately begin simplifying it.
15:29:22 <maerwald> EvanR: no
15:29:27 <EvanR> ok good
15:29:44 <EvanR> you know what would be cool, a fortran monad
15:29:52 <EvanR> like the basic monad, only serious
15:29:55 <maerwald> Cale: my point is... if you want to write haskell and not blindly translate stuff, thing are harder when you look at algorithmic problems
15:29:56 <Cale> and once you've done this a couple times, it'll become obvious that you can skip a lot of steps
15:30:24 <maerwald> because most resources just point to imperative (often even C-style) pseudo-code
15:30:29 <EvanR> it would help translating fortran algorithms, perhaps it could serve as a DSL for actual fotran
15:30:33 <EvanR> targeting
15:30:42 <Cale> and it'll be easier to just see these loops and write some corresponding functional code down -- of course, really *nice* functional code tends to require a better understanding of what's being computed
15:30:49 <erisco> I am not convinced it is harder in principle, but that many examples are written procedurally, yes, it is less convenient
15:31:10 <maerwald> I disagree
15:31:14 <Cale> But you can at the very least get to the point where you have a couple recursive functions with a bunch of arguments
15:31:37 <maerwald> in the usual oldschool imperative style you can mix effects almost randomly, without restrictions
15:31:42 <maerwald> in haskell, you can't
15:31:59 <Cale> Um, well, which effects do you need?
15:32:05 <EvanR> unless you make a dedicated monad with those "random" effects
15:32:09 <Cale> If you want actual I/O effects, you should just use IO
15:32:14 <maerwald> Cale: I know
15:32:23 <erisco> in Haskell you know effects are not mixed in randomly, and what a simplification that is!
15:32:31 <maerwald> Cale: I feel like you didn't get my argument
15:32:34 <Cale> If you just mean "updating variables" -- well, function parameters can be updated, simply by applying a function recursively.
15:32:46 <maerwald> you are all telling me things I already know
15:32:53 <maerwald> I know there is an IO monad
15:33:03 <erisco> so it cuts both ways, and thus I am not convinced it can be said one way or another, but you can have a familiarity or preference
15:33:10 <maerwald> no
15:33:15 <maerwald> that wasn't my point
15:33:51 <EvanR> when i think of java, i think that at any point i can do IO, or update variables, or array elements
15:34:16 <EvanR> you cant just do that in haskell... unless its IO
15:34:27 <EvanR> so just stay in the IO the whole time ;)
15:34:34 <maerwald> for algorithmic problems, it's most of the time easier to be able to randomly mix effects (without type representation) and have direct memory access, in order to express a solution. I'm only talking algorithmic solutions, not proper program design
15:34:39 <erisco> having written programs, once upon a time, with lots of mutability, it did not enable any new simplicities
15:34:42 <erisco> none that I can remember
15:34:56 <EvanR> maerwald: right i think a fortran monad could help here
15:35:03 <erisco> on the other hand I recall be surprised many times
15:35:34 <EvanR> towards numeric haskell
15:36:01 <erisco> a nice thing was that I could write a debug print anywhere with ease
15:36:06 <maerwald> so when you implement polygon triangulation in haskell, you very likely will find it pretty annoying to go the IO-route
15:36:11 <maerwald> and the functional route is hard too
15:36:54 <EvanR> is it really non-annoying to solve in C++ ?
15:36:56 <erisco> debugging generally feels better
15:37:02 <maerwald> EvanR: I don't do C++
15:37:14 <erisco> I have never successfully used a tool to debug Haskell other than my own wetware
15:37:32 <Cale> EvanR: Is *anything* really non-annoying to solve in C++?
15:37:57 <EvanR> your homework 
15:38:00 <EvanR> nevermind
15:38:22 <maerwald> so basically, 9 out of 10 algorithms that I tried have been harder in haskell... the result was in ~70% of the cases more pleasing though
15:38:44 <maerwald> (half-edge was not)
15:38:55 <erisco> what if the solutions were presented functionally to begin with
15:38:58 <erisco> what is being compared?
15:39:15 <EvanR> polygon triangulation seems non trivial enough to warrant a careful function algorithm rather than pointer pureé
15:39:17 <maerwald> erisco: in that case, it's still pretty easy to implement in java/C++/python
15:39:47 <erisco> did you change the solution to be meaningfully not functional?
15:40:26 <maerwald> I don't even know why I have to argue so long for this
15:41:09 <erisco> it seems to me we're talking about programmer preference and familiarity
15:41:11 <EvanR> mesh simplification, give me my IntMaps ;)
15:41:27 <erisco> the point of static versus dynamic is you measurably have to write more code
15:42:04 <erisco> and you measurably can have programs compile & run dynamically that would not compile statically
15:42:23 <maerwald> again: java is static too
15:42:35 <erisco> so regardless of your aptitudes, you are hit with more work and more problems
15:42:42 <EvanR> i would have though static means writing less code in the long run
15:42:51 <EvanR> since more stuff can be written for you
15:43:13 <erisco> well, may be so, seems quite variable
15:43:27 <erisco> with particular language features
15:43:36 <maerwald> I've written proper dynamic code and it takes longer than static code, because I do more manual checks and write a LOT more tests
15:43:42 <erisco> for example, implementing memberwise equality in C# is a huge PITA, whereas in Haskell is trivial
15:44:08 <erisco> C# is not dynamic, granted ;)
15:44:25 <maerwald> and then I do a lot of debugging. Dynamic languages are harder, not easier
15:44:40 <erisco> well maybe you are doing it wrong maerwald :P
15:44:49 <maerwald> I don't think so
15:45:04 <erisco> what you are supposed to do is do a Google for a package that already solves the problem
15:45:20 <erisco> then you write in a bit of code to duck tape it on
15:45:29 <maerwald> yes, I did that for a js based ftp server, ended up reading the ftp RFC and filing bugs for ~5 libraries
15:45:30 <erisco> you run it, and if it works a couple times, you're done
15:45:47 <maerwald> because they were all broken
15:46:01 <erisco> yes, well, the point of static code whining about more problems is because some of us care
15:46:05 <erisco> not everyone does
15:46:42 <erisco> a lot of libraries are hopelessly borked… I know
15:47:39 <erisco> the authors did not read the spec, they just wrote something from memory of how they thought it worked
15:48:00 <erisco> and it was passable for the product they were making, and so there you have it
15:50:21 <maerwald> my point was: we already have a lot of statically typed languages that are still far easier than haskell. What makes haskell challenging is that it naturally forces you to think functionally (while most of the rest of the world does not, including papers about algorithms etc)
15:50:53 <maerwald> and not just functionally, but also "now deal with effects on type level too"
15:53:30 * hackagebot photoname 3.2 - Rename photo image files based on EXIF shoot date  https://hackage.haskell.org/package/photoname-3.2 (DinoMorelli)
15:53:32 * hackagebot ghcjs-dom-jsffi 0.4.0.0 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.4.0.0 (HamishMackenzie)
15:53:34 * hackagebot ghcjs-dom-jsaddle 0.4.0.0 - DOM library that supports both GHCJS and GHC using jsaddle  https://hackage.haskell.org/package/ghcjs-dom-jsaddle-0.4.0.0 (HamishMackenzie)
15:53:36 * hackagebot ghcjs-dom 0.4.0.0 - DOM library that supports both GHCJS and GHC  https://hackage.haskell.org/package/ghcjs-dom-0.4.0.0 (HamishMackenzie)
15:55:45 <kaste> fwiw I think you make a very good argument maerwald 
15:56:16 <EvanR> maerwald: which i like, a large complex application benefits from being deliberate about how its going to "do effects"
15:56:33 <EvanR> a particular self contained algorithm doesnt need to worry about that
15:56:38 <maerwald> EvanR: sure, but it also makes it harder to initially design and write up the prototype
15:57:04 <kaste> well if you were to do it proper in other languages you would do it too
15:57:20 <xocolatl> are there any (public) big projects besides ghc and pandoc?
15:57:21 <EvanR> im having success right now with describing the interface with types
15:57:23 <kaste> for a larg sized project teams often forgo the effort and then regret it in the long run
15:57:29 <maerwald> kaste: not to that extent since you can't model effects like that on most languages
15:57:38 <maerwald> you just develop your own "carefulness" about it
15:57:49 <kaste> yes
15:57:53 <EvanR> once thats done, then im clearly guided toward the prototype
15:57:59 <kaste> that's a good thing(tm)
15:58:30 <EvanR> maerwald: im modeling a card game, and also pong, but theres no IO
15:58:44 <EvanR> but its still a complete picture
15:59:08 <maerwald> kaste: I actually like the idea of a language stack: on the lower-level you have a deeply imperative-style language, on the next level a functional (but still rather easy) language for more abstraction... and on the last level you have an utterly strict functional language with SMT solver capabilities
15:59:31 <maerwald> there's currently something like that actually, but rather experimental: C# => F# => F*
15:59:32 <kaste> or even logical on top
15:59:56 <zv> if only there were some sort of lisp like language that every SMT solver already used...
15:59:59 <maerwald> F* is more like idris where you can actually prove stuff
16:00:07 <maerwald> and it compiles to F#
16:00:13 <maerwald> so interoperability is sort of given
16:00:22 <EvanR> yeah im using idris and going to js
16:00:51 <maerwald> kaste: while haskell is sorta between F# and F*, but neither of those
16:02:34 <zv> since you are all in the business of FPLs with SMT capabilities
16:02:58 <zv> why not try out zv's hit new emacs major mode: https://github.com/zv/z3-mode
16:03:09 <zv> be sure to star it, otherwise i won't look like an open-source guru.
16:03:46 <zv> you get it all! Lisp, SMT formula, Constraint Solver! All in the familiar domain of Emacs 
16:04:18 <maerwald> kaste: and such a programming stack wouldn't force one language on the whole team, e.g.: 1. C# for GUI, 2. F# for internal API abstraction, 3. F* for cryptographic API ... and that also resembles the difficulty level imo
16:04:25 <maerwald> but I'm moving slowly towards OT :P
16:04:58 <kaste> probably left T about five minutes ago :P
16:05:02 <kaste> but I like your idea
16:05:03 <maerwald> :o
16:05:33 <kaste> not sure we are even that far off from that world
16:06:33 <maerwald> somehow, I find it more appealing than having one language for all purposes. Rather have a family of languages that are highly interoperable
16:06:48 <maerwald> with different set of features/properties though
16:06:49 <EvanR> domain specific languages for stuff makes sense, because that means you figured out what you actually want to do
16:07:10 <EvanR> industrial languages were designed to do "uhm whatever C could do, possibly slower"
16:07:18 <EvanR> was the design goal
16:10:16 <EvanR> but every task has some most perfect language to use for it
16:10:31 <EvanR> even haskell might not be it!
16:12:21 <ertesx> Myrl-saki: trying to reproduce the 'rec' problem
16:12:34 <ertesx> Myrl-saki: in such a way that i understand where it comes from
16:13:14 <ertesx> Myrl-saki: if you have any extra information, please let me know…  also feel free to file a bug report so it's official
16:14:11 <ertesx> EvanR: haskell is the perfect language for everything…  EVERYTHING!!!!11
16:16:12 <dmiles> i'd like someone to write a prolgo interp in haskell that runs as fast as one written in C
16:16:32 <ertesx> dmiles: that's probably not even that difficult
16:17:44 <dmiles> the reason i want it is i found some optimizations that are annoying to code from C.. maybe not so much from Haskell
16:17:44 <tippenein> ho knows how fast this one is https://hackage.haskell.org/package/prolog
16:18:10 <dmiles> right now i have to maintain C code :(
16:18:38 <tippenein> hat prolog package on hackage has been abandoned. Perhaps you can foster it
16:18:50 <tippenein> that*
16:19:11 <ertes> EvanR: what's your experience with idris for JS?  would you recommend it for small projects?
16:19:18 <ertes> i long thought i should give it a try
16:19:25 <EvanR> i just tried it yesterday
16:19:32 <EvanR> it works (tm)
16:19:35 <ertes> i see
16:19:51 <EvanR> but theres a lot of marshalling code to write 
16:20:03 <EvanR> and i checked on automating that with elab reflection
16:20:06 <EvanR> it works (tm)
16:20:10 <dmiles> tippenein: well someone hopefully will one day.. i have too many projects already :(
16:21:01 <dmiles> tippenein: though if i had proof of performance i'd switch but it'd take too long getting such proof.. i mean i might be unfair and naive agaisnt that impl
16:21:33 <ertes> EvanR: what kind of "(tm)" is that?  the "it breaks in some places, but works in most" kind or the "it works well, but there is a lot of engineering to do"?
16:21:45 <tippenein> haha, yeah. It's also undocumented like most other haskell repos
16:22:16 <EvanR> it means i did the minimum possible amount of testing to try something, and it worked. but have yet to do anything extensive like get non trivial data to actually show up in a canvas element or something
16:22:32 <dmiles> tippenein: i find documentation confusing normally i am bad i have 10k line libs all over with no comments or docs .. :))
16:23:00 <Zekka> dmiles: I'd probably default to assuming it's not as fast -- emphatically without having tested it
16:23:06 <EvanR> or experience non trivial calculations go not turtle slow in generated javascript code
16:23:08 <dmiles> tippenein: its like to add english (i am english native) is like adding a forign language to confuse peopel
16:23:17 <Zekka> it looks like a pretty naive implementation
16:23:33 <ertes> i see
16:23:44 <EvanR> lots of double negatives
16:23:44 <dmiles> Zekka: yeah.. tryign to unniavify it would take tooo long
16:26:22 <poopman12> I had a Stack question if anyone is able to assist.
16:27:51 <ContessaTP> I'm not at all experienced with Stack (although I have used it) but I can try
16:27:56 <ContessaTP> poopman12 ^^
16:30:47 <Cale> poopman12: did you already ask it, or what?
16:30:58 <jle`> poopman12: best to just ask your question :)
16:37:28 <poopman12> I have a couple different internal projects which reference each other.  The only way I've seen to do it is to add the directories to the "projects" element in the stack.yaml config.  But that's just gonna build what happens to be there at the time.  I was hoping I could publish versioned builds locally like someone would publish to stackage. stack.yaml has an entry "extra-package-dbs", so it appears I can add a local folder ther
16:38:53 <Koterpillar> poopman12: you can refer to them via git
16:39:15 <poopman12> That's correct but then I give up numbered versioning, right?
16:39:16 <Koterpillar> poopman12: then you'll have to specify which commit to use
16:39:22 <Koterpillar> yeah
16:39:55 <jle`> yeah, i do this and reference them by commit hash
16:40:42 <poopman12> Does that become a frustration point when you're looking at a config while debugging and you want to see if a package is significantly out of date, but all you see is a commit hash?
16:41:00 <jle`> i'm not sure what the frustration would be
16:41:07 <jle`> what else would you see besides a commit hash?
16:41:13 <jle`> you can't see the actual repo from the config file
16:41:16 <Koterpillar> a tag?
16:41:29 <Koterpillar> that would help quite a lot
16:41:29 <jle`> *you can't browse the actual files form teh config file
16:41:40 <poopman12> Well I think the ideal would be an actual version label 
16:41:40 <jle`> ah
16:41:50 <jle`> i think you can reference by git tag, and you can name your tags after version numbers
16:42:33 <jle`> so that's essentially the same thing as requiring exact versions :)
16:43:29 <poopman12> I was hoping it would work seamlessly like it does like the public packages on stackage, where you just specify a version label.  Then you can just see what the actual version you're using is, and how it compares to other versions, instead of just knowing that your version is or is not the exact same by comparing hashes.
16:43:47 <poopman12> I see on stackage's website that they sell custom stackage installations for commercial use so maybe that's how companies do it
16:44:20 <poopman12> But perhaps you're right that tagging or just referencing hashes is the best way to do it in an individual's case
16:44:21 <jle`> hm, i think just using tags would be similar?  you can specify that you waht "v0.1.5"
16:44:26 <jle`> s/waht/want
16:45:00 <poopman12> Correct, I believe that would be equivalent; just a bit more manual and therefore possibly introducing errors (tagging the wrong version)
16:45:32 <jle`> hm yeah, instead of it being made automatically from the cabal file, you mean?
16:45:51 <poopman12> right
16:46:08 <Sonarpulse> with explicit type application
16:46:19 <Sonarpulse> a thing, is there any plans for ExplicitTypeAbastraction?
16:46:40 <Sonarpulse> \@a (x :: a) -> x ?
16:46:42 <poopman12> and of course one can write a tool to do that - i was just surprised this problem was unique to me
16:47:26 <poopman12> thanks for your respones jle` and Koterpillar
16:48:42 <Koterpillar> poopman12: fyi 'bumpversion'
16:49:12 <jle`> np!
16:51:07 <poopman12> checking it out. thanks.
16:53:32 * hackagebot jsaddle 0.5.0.1 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.5.0.1 (HamishMackenzie)
16:53:34 * hackagebot jsaddle-hello 2.0.0.0 - JSaddle Hello World, an example package  https://hackage.haskell.org/package/jsaddle-hello-2.0.0.0 (HamishMackenzie)
16:53:36 * hackagebot ghcjs-dom-hello 3.0.0.0 - GHCJS DOM Hello World, an example package  https://hackage.haskell.org/package/ghcjs-dom-hello-3.0.0.0 (HamishMackenzie)
16:53:38 * hackagebot bytestring-progress 1.0.7 - A library for tracking the consumption of a lazy ByteString  https://hackage.haskell.org/package/bytestring-progress-1.0.7 (AdamWick)
16:53:40 * hackagebot shelly 1.6.8.1 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.8.1 (GregWeber)
17:10:37 <centrinia> Can modules be generalized to allow for non-Abelian vectors?
17:15:31 <User451> hi boogereater
17:21:09 <athan> Does a function exist `bind :: Handle -> Handle -> IO ()`?
17:21:27 <athan> I'm not sure if it's the right idea but my plan is to bind the stdout handle of one process to another
17:22:05 <geekosaur> no, theres no magic to copy one handle to another
17:22:09 <Koterpillar> like pipe()?
17:22:25 <athan> Like, there's no concept of `assignStdout :: Handle -> IO ()`, so a `merge :: Handle -> Handle -> Handle` wouldn't work
17:22:36 <athan> hmm okay geekosaur
17:22:39 <athan> I think so Koterpillar!
17:22:44 <geekosaur> if you want to interconnect them, you want to create a pipe for one and UseHandle it in the next
17:22:55 <centrinia> http://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-IO-Handle.html#v:hDuplicateTo 
17:22:56 <athan> I'm just triyng to relay the outputs to the stdout of my current process
17:23:25 <geekosaur> maybe just let them inherit
17:23:29 <grantwu> ghc-mod is driving me insane
17:23:37 <grantwu> It complains about an empty where statement I've already commented out
17:23:47 <athan> geekosaur: The child process is make from System.Process :\
17:23:52 <geekosaur> yes
17:24:03 <geekosaur> the default is to inherit the parent's stdout
17:24:17 <athan> thank you centrinia :) brilliant
17:24:39 <centrinia> I just used Hoogle. -_-
17:24:50 <geekosaur> and no, I suspect that is not what you want
17:24:52 <athan> geekosaur: Well, I realize that's the default. I'd just like finer grain control. hDuplicateTo is the ticket :)
17:25:14 <geekosaur> yes, it will "duplicate to". meaning, your stdout becomes the output of that process (which is open for read)
17:25:25 <geekosaur> so you lose the ability to do any output
17:27:29 <grantwu> http://lpaste.net/238717 code won't parse... can anyone tell me why
17:27:47 <geekosaur> what is finer grain control
17:28:10 <athan> geekosaur: Oh shoot that's unfortunate
17:28:20 <athan> wouldn't it be called hReplaceTo if that were the behavior?
17:28:26 <athan> or something :s
17:28:36 <geekosaur> it's just expanding the names of the unix system calls
17:28:38 <Koterpillar> grantwu: does one of {let, where} want to be indented even more?
17:28:56 <grantwu> Koterpillar: Uh... I dunno?
17:29:10 <Koterpillar> grantwu: let.. in and where are separate constructs
17:29:12 <grantwu> indenting the let doesn't work
17:29:16 <geekosaur> grantwu, _ is not legal there unles syou turned on type holes, I suspect it is parsing a pattern because it saw _
17:29:28 <grantwu> geekosaur: Which _?
17:29:33 <geekosaur> "in _"
17:29:45 <grantwu> I replaced all the _ with undefined and it's still broken
17:29:55 <grantwu> indending the where also doesn't work
17:31:01 <grantwu> ._.
17:31:12 <grantwu> It turns out there was a random "where" 100 lines down after comments
17:31:45 <geekosaur> it's parsing here
17:31:47 <geekosaur> ah
17:32:55 <grantwu> sorry
17:32:58 <athan> geekosaur: There's no way to listen to the write events of a handle? :\
17:33:15 <geekosaur> isn't that called reading?
17:33:17 <athan> like `onLine :: Handle -> (String -> IO ()) -> IO ()
17:33:28 <athan> geekosaur: but that blocks and throws exceptions
17:34:41 <geekosaur> I... cannot understand how you think filehandles work
17:36:20 <alercah> athan: a handle doesn't have events
17:36:30 <geekosaur> your onLine is done by forking a thread in a read-write loop, and if you're just dumping the result to stdout then how does this differ from letting it inherit stdout?
17:36:48 <alercah> handles are not objects like in an object-oriented language
17:38:01 <geekosaur> a filehandle is a wrapper around a file descriptor, which is a token you hand to the (windows or unix) kernel and it hands you available data back, or returns an error which haskell rethrows as an exception
17:38:06 <geekosaur> there are no "messages"
17:47:17 <athan> hmm, it probably wouldn't be too hard to fudge a event-like system though, like what you were saying geekosaur
17:47:24 <athan> I mean, it would probably react off timeouts or something
17:47:41 <athan> but thank you, I really need to learn more about these systems
17:47:47 <athan> and alercah! thank you!
17:48:02 <geekosaur> there is one, it is in the ghc runtime and it assumes that you use threads to read data
17:48:31 <geekosaur> and it uses select/poll/epoll to detect data available
17:48:46 <geekosaur> so you want to undo that and replicate it in your own preferred form in haskell, then
17:48:58 <geekosaur> and then find out that that still does not give you what you want
17:49:37 <geekosaur> because it still doesn't autoplumb everything; something has to move data from point a to point b, it does not move itself
17:51:11 <alercah> athan: under the hood, a handle is just a number
17:51:38 <alercah> the kernel maintains the association of file descriptors to what they're actually connected to
17:51:55 <geekosaur> (linux has a splice syscall that sort of does what you are looking for with some kinds of file descriptors; if you try to use it for "I don't understand pipe, turn these two separate descriptors that i have my end of into a pipe connecting the other ends" it just looks at you funny
18:09:38 <ertes> athan: i highly recommend that you read part II (starting with chapter 7) of The Book: http://chimera.labs.oreilly.com/books/1230000000929/
18:13:45 <ni291187> Hey guys
18:13:54 <Koterpillar> hello
18:14:04 <ni291187> Can somebody help me with Ram scrapping or sniffing or how to get data of a Pos machine
18:14:15 <grantwu> This is #haskell
18:14:15 <Koterpillar> ni291187: not on this channel
18:14:19 <geekosaur> another person wjho thinks #haskell means #hackers
18:14:33 <centrinia> That really doesn't make sense. -_-
18:14:35 <Koterpillar> maybe in some strange leet-speak?
18:14:42 <geekosaur> or possibly thinks irc means hackers
18:14:43 <centrinia> We don't go that low level. -_-
18:14:46 <ni291187> korter which Channel
18:14:55 <ertes> never noticed the small edit distance between "haskell" and "hackers" =)
18:15:09 <ni291187> Lol somebody told it me
18:15:14 <Koterpillar> I don't know
18:15:15 <ni291187> this channel so Not my fault
18:15:39 <EvanR> hakserr
18:15:54 <ni291187> but nobody could help me here ?
18:16:04 <ertes> ni291187: even if, it's off-topic here
18:16:19 <ni291187> Hmm Kk
18:16:38 <ni291187> sorry then :)
18:16:44 <ertes> but if you're interested in learning to program in a good language, you're at the right place =)
18:17:05 <ni291187> Yes i know ;)
18:17:30 <ni291187> but i have Some other things to learn as you can see :)
18:17:51 <ni291187> thanks Anyways
18:18:45 <centrinia> > editDistance "haskell" "hacker"
18:18:47 <lambdabot>  3
18:20:32 <koz_> Is there such a thing as a cofunctor?
18:20:40 <benzrf> there are contravariant functors
18:20:55 <benzrf> which are "co" in the sense that you are swapping the domain for its dual
18:21:15 <benzrf> but in general functors are parameterized over two categories, so it's not necessarily clear what you should be using the dual of
18:21:40 <EvanR> obv you reverse both sets of arrows in the def of functor and get...
18:21:44 <EvanR> the same thing you started with
18:21:45 <hpc> would it be cofmap :: (f a -> f b) -> (a -> b)?
18:21:47 <jle`> koz_: see http://hackage.haskell.org/package/cofunctor
18:21:57 <koz_> hpc: Yeah, that's what I thought too.
18:21:58 <jle`> oh wait
18:22:06 <jle`> wrong lonk
18:22:13 <EvanR> https://hackage.haskell.org/package/acme-cofunctor
18:22:17 <jle`> https://hackage.haskell.org/package/acme-cofunctor
18:22:19 <jle`> yeah that's the one heh
18:22:27 <jle`> in particular, https://hackage.haskell.org/package/acme-cofunctor-0.1.0.0/docs/Data-Cofunctor.html
18:22:47 <koz_> jle`: Lol.
18:22:53 <hpc> <3 acme
18:22:57 <jle`> it switches 'a' and 'b', so cofmap :: (b -> a) -> (f b -> f a)
18:22:58 <koz_> However, hpc was thinking what I was thinking.
18:23:12 <koz_> The idea is that you have (f a -> f b) -> (a -> b).
18:23:15 <benzrf> so you mean replacing Cat with Cat^op?
18:23:41 <benzrf> nah, that still doesn't make sense
18:23:47 <jle`> koz_: are you asking if such a concept exists, or if that concept could be meaningfully called a cofunctor?
18:23:58 <koz_> jle`: Well, both I guess.
18:24:29 <ertes> @package contravariant
18:24:29 <lambdabot> http://hackage.haskell.org/package/contravariant
18:24:55 <jle`> contravariant is a bit different, isn't it?
18:25:18 <ertes> yeah
18:25:18 <jle`> it's :: (a -> b) -> (f b -> f a)
18:25:29 <ertes> i'm just mentioning it in case you didn't see it
18:25:39 <benzrf> koz_: generally speaking, it makes sense to talk about a "cofoo" if "foo" is a type family indexed by categories
18:25:41 <benzrf> (kinda)
18:26:06 <benzrf> koz_: so "comonad" makes sense, because "monad" is something that you apply to some category to get the type of monads on that category
18:26:20 <benzrf> but "cofunctor" does not make sense, because "functor" is not something you apply to a category to get the type of functors on that category
18:26:33 <benzrf> unless you mean "endofunctor" - but coendofunctors end up being exactly the same thing
18:26:38 <koz_> benzrf: OK, that makes sense, actually.
18:26:44 <benzrf> hence acme-cofunctot
18:26:45 <koz_> And Haskell functors are all endofunctors.
18:26:46 <benzrf> *functor
18:26:49 <ertes> koz_: are you sure you're not looking for natural transformations?
18:26:49 <benzrf> oh good :)
18:27:00 <koz_> ertes: No, I was just idly musing.
18:27:16 <koz_> (I'd finally grasped [or thought I had] the co-thing while doing some bus reading)
18:27:19 <benzrf> koz_: in particular, a cofoo on C is defined as a foo on C^Op
18:27:26 <athan> thanks ertes :)
18:27:31 <benzrf> so a comonad on Hask is just a monad on Hask^Op
18:27:34 <ertes> ((F a -> F b) -> (a -> b)) sounds more like you're going from F to Id in some way
18:28:18 <benzrf> a coendofunctor on Hask is an endofunctor on Hask^Op - check for yourself that endofunctors on Hask^Op correspond exactly to endofunctors on Hask
18:28:24 <benzrf> or just for any category
18:28:41 <ertes> it's a regular functor *into* Hask from:  type C a b = F a -> F b
18:29:06 <ertes> so no "co" going on there, as far as i see
18:29:40 <koz_> OK, thanks for that - I clearly still have much to learn.
18:29:48 <benzrf> koz_: one thing that *is* interesting is -
18:30:00 <benzrf> you can have a co functor-into-Hask
18:30:09 <benzrf> so a functor-into-Hask on Hask is an endofunctor on hask
18:30:20 <benzrf> a co-functor-into-Hask is a functor from Hask^Op to Hask
18:30:23 <ertes> koz_: functors like that can't be represented as standard Functor, but there is a more expressive functor class in the 'hask' library
18:30:32 <benzrf> aka a contravariant functor - which *is* interesting
18:30:53 <koz_> benzrf: OK, thanks - that was enlightening.
18:30:56 <benzrf> np :)
18:31:02 <benzrf> bbl
18:31:34 <koz_> I really wish there was a 'Category theory illustrated in Haskell programs' book. I've tried reading some category theory, but even with my training, I found it hard to follow.
18:32:13 <EvanR> man haskell is way more complicate than CT
18:32:35 <EvanR> lots of weird gotchas specific to haskell and haskell syntax
18:33:08 <ertes> koz_: so far my most successful learning attempt was to implement CT in agda…  but it's obviously not the cheapest option =)
18:33:30 <koz_> ertes: No, indeed not. The main reason I wanna learn this stuff is so I can follow half the stuff Ed talks about.
18:33:34 <koz_> (well, Ed + some others)
18:33:51 <koz_> Because I find I get things when I have the right formal understanding, but obviously, that requires proper scaffolding.
18:33:55 <koz_> Which I obviously don't have yet.
18:34:48 <EvanR> one idea, a CT textbook that includes examples of what its talking about in terms of haskell, in addition to the usual abstract algebra or topology based examples
18:34:53 <ertes> koz_: it's probably different from learner to learner, but for me learning works best either by looking at many examples i can relate to, or by formulating the model myself in a rigorous manner
18:35:16 <EvanR> or logic
18:35:27 <koz_> EvanR: That would be awesome.
18:35:34 <koz_> ertes: For me, I need it in formal terms.
18:35:45 <koz_> I never understood much maths until it was formulated to me in terms of logic and sets.
18:35:56 <koz_> (to give an example)
18:36:25 <koz_> This is why I find category theory inherently very appealing, but at the same time, I'm also finding it very difficult to follow for some reason. Maybe I'm using the wrong textbook?
18:37:01 <ertes> koz_: you're probably just not *using* it…  think of CT as a kind of module system, but for math instead of programming
18:37:24 <EvanR> see also type theory
18:37:42 <koz_> ertes: I think I'll just give it another look once I've done this boring refactoring.
18:37:45 <ertes> koz_: it's not even really a "theory"…  it's a formalism…  a language
18:37:50 <koz_> I also read some stuff on recursion schemes, and that stuff's *amazing*.
18:38:04 <koz_> I actually had a question about that.
18:38:29 <koz_> So, in order to use (for example) catamorphisms, we need an Algebra, which is f a -> a where f is a Functor, right?
18:38:45 <ertes> yeah
18:38:58 <koz_> Now, when looking at free monads, I found something saying that we don't even need Functor for that - we can use Lan g Identity (IIRC).
18:39:23 <koz_> Is the same true of Fix-related stuff like cata, ana and so on?
18:39:31 <ertes> that sounds like something out of the freer paper
18:39:56 <koz_> ertes: Yes, I think so. I read that on http://okmij.org/ftp/Computation/free-monad.html#freer
18:40:20 <grantwu> gy;s dg
18:42:31 <ertes> koz_: good question…  seems related to the Mu and Nu representations of Fix here: https://hackage.haskell.org/package/recursion-schemes-5/docs/Data-Functor-Foldable.html#g:2
18:42:50 <ertes> they still have a Functor constraint, but chances are that 'cata' can be written without it
18:42:58 <grantwu> oops
19:14:58 <clueless> http://lpaste.net/238789 could someone help me see why I am having some identation errors?
19:15:40 <geekosaur> that's not actually an indentation error, it's a confused compiler because you forgot "otherwise =" on the final one
19:16:19 <geekosaur> so it parsed the whole thing as a guard expression and then threw an indentation error on the following thing because it was still looking for the =
19:17:05 <clueless> ahhhh
19:19:34 <athan> Hey all - does hGetContents block / stay "open" on an open stdout handle?
19:19:54 <athan> s.t. any more incoming data from the stdout is relayed without needing to re-issue hGetContents
19:20:04 <geekosaur> it "stays open" as long as you have not consumed the entire lazy list
19:20:18 <geekosaur> but I think you are again confused about what is actually happening
19:20:46 <athan> hmm, that's strange. I can see intermittent data being relayed
19:21:03 <athan> I've basically done do {xs <- hGetContents foo; putStrLn xs}
19:21:29 <athan> but it's staying open, and I can see text being printed intermittently - in accordance with the data being sent from foo
19:24:13 <glguy> sounds normal
19:24:59 <athan> hm, right on
19:26:09 <clueless> Okay, http://lpaste.net/238789 could someone explain to me why my type declaration is giving me some error?
19:26:21 <clueless> please I'm pretty confused by Haskell
19:27:26 <lordcirth> clueless, please paste the error too
19:27:30 <glguy> your function says it returns a list of integers and doesn't
19:28:04 <lordcirth> Oh, yeah it returns Integer
19:28:05 <clueless> glguy: how could I declare so that it may return a list of integers (in the otherwise case) 
19:28:34 <lordcirth> clueless, you can't return Integer in one case and [Integer] in another
19:28:43 <lordcirth> You can return a list of 1 Integer, if you like.
19:29:14 <clueless> lordcirth: what about in the cases where i return an error
19:29:46 <lordcirth> clueless, your otherwise case returns a list, just change "num == 1 = list !! num" to " num == 1 = [list !! num] "
19:31:18 <clueless> lordcirth: whats the difference with Int and Integer?
19:33:31 <lordcirth> clueless, Int is platform size - if you're on a 64bit computer, they are 64bits.  Integer is unbounded
19:36:32 <clueless> lordcirth: sorry if Im being to specific, but I can't make my code work, it says that it cant match certain types with parts of the code, coudl you please take a look into my code? http://lpaste.net/238789
19:37:07 <Koterpillar> clueless: this is not how you refer to functions
19:37:22 <Koterpillar> clueless: f(x, y) from C, etc. is f x y in Haskell
19:37:38 <Koterpillar> clueless: in your case: prefix (num - 1) list
19:41:36 <clueless> Koterpillar: thanks for the input, totally missed that, but i still cant get it to run
19:41:40 <clueless> even with that change
19:44:27 <Clint> clueless: what are you trying to do in the otherwise?
19:44:50 <petercommand> I think he is trying to append to the end of the list
19:45:14 <clueless> Clint: return a recursive list that consists of all the numbers before the given element + the given element
19:45:48 <petercommand> If you want to append to the end of the list, maybe try Data.Sequence
19:46:47 <petercommand> It has an O(1) insertion operation that append to the back of the list
19:47:00 <petercommand> ref: https://hackage.haskell.org/package/containers-0.5.8.1/docs/Data-Sequence.html
19:47:28 <EvanR> another data structure that has O(1) append to the end is using a regular list backwards!
19:47:55 <petercommand> yeah, ofc :D
19:48:23 <petercommand> and reverse the list later
19:48:42 <EvanR> or dont ;)
19:48:42 <petercommand> It will be amortized O(1)
19:49:05 <petercommand> :)
19:49:23 <EvanR> hmm
19:49:40 <EvanR> so theres amortized O(1) queue that you periodically reverse
19:49:52 <EvanR> i wonder if something like that could work as a 2-ended list
19:49:59 <Clint> clueless: well, your code doesn't do that
19:49:59 <EvanR> like an inside out zipper
19:51:35 <EvanR> if you run out of either side, cut it in half
19:51:44 <EvanR> and reverse one
19:52:08 <EvanR> haw haw ahw ;)
19:53:35 * hackagebot NameGenerator 0.0.0 - A name generator written in Haskell  https://hackage.haskell.org/package/NameGenerator-0.0.0 (pommicket)
19:53:37 * hackagebot NameGenerator 0.0.1 - A name generator written in Haskell  https://hackage.haskell.org/package/NameGenerator-0.0.1 (pommicket)
20:03:11 <andromeda-galaxy> so, I asked some questions on ##categorytheory a few days ago to do with modelling some categorical phenomena in haskell, as best as is possible (since categorical models in haskell are a bit difficult to get right), but haven't heard anything. Does anyone know of a more active venue for discussing category theory as applied to Haskell?
20:07:48 <agustin> aaaaa
20:38:51 <umib0zu> hi all. how does stack resolve import statements? I’m trying to run a test file using stack, but it complains that it’s failing to load an interface. I have the standard src/MyModule.hs file, and in my tests folder, I have test/MyModule/MyModule.hs.
20:39:22 <umib0zu> what’s good practice when defining these test files?
20:39:42 <umib0zu> I think test/MyModule/MyModule is wrong, but I’m not sure what else to do
20:53:37 * hackagebot hsinstall 1.0 - Install Haskell software  https://hackage.haskell.org/package/hsinstall-1.0 (DinoMorelli)
20:57:45 <joe9> how do you enter binary numbers into haskell code? 0b00?
20:58:09 <grantwu> I believe there is a BinaryLiterals pragma
21:00:20 <EvanR> joe9: theres a package with quasi quoters for that
21:01:23 <EvanR> well at least one: https://hackage.haskell.org/package/binary-literal-qq
21:02:11 <grantwu> It says to use the BinaryLiterals pragma at the top...
21:02:38 <EvanR> oh
21:07:26 <joe9> EvanR: grantwu. BinaryLiterals worked well. Thanks.
21:37:31 <jle`> @let {-# LANGUAGE BinaryLiterals #-}
21:37:33 <lambdabot>  Defined.
21:37:36 <jle`> > 0b0100101
21:37:38 <lambdabot>  error: Variable not in scope: b0100101
21:37:51 <jle`> hm
21:45:19 <EvanR> i found a page about exact real computation, dunno if any of you are this guy, but i havent seen this one before http://www.cs.bham.ac.uk/~mhe/research.html
21:45:50 <EvanR> not sure that exact real calculator in haskell is either of the ones we use on hackage or not
21:46:40 <grantwu> I really wish Haskell had refinement types.
21:47:14 <grantwu> I find myself making fewer IRs than truly necessary because it's such a pain to basically copy a ton of type definitions
21:47:21 <grantwu> Change one thing to encode an invariant
21:47:28 <grantwu> and then write a ton of boilerplate to convert
21:48:32 <jvanbure> @grantwu it's ok bb
21:48:32 <lambdabot> Unknown command, try @list
22:09:23 <Myrl-saki> ertes: Hey. are you here rn?
22:51:37 <johnw> grantwu: have you tried LiquidHaskell yet?
22:53:33 <koz_> What's the normal practice of 'lenses that can fail', if there is one? What I mean is that I wanna have a lens set which can fail if given bad values (into an Alternative, say).
22:53:39 * hackagebot helm 1.0.0 - A functionally reactive game engine.  https://hackage.haskell.org/package/helm-1.0.0 (ZackCorr)
22:53:41 * hackagebot publicsuffix 0.20161003 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20161003 (wereHamster)
22:54:00 <Koterpillar> koz_: Traversals?
22:54:02 <Koterpillar> :t ix
22:54:03 <koz_> I thought I wanted something like 'Alternative f => Lens s (f s) a a', but that doesn't seem to be what I want.
22:54:04 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
22:54:37 <koz_> Koterpillar: I assume that gets unconditionally work, but *set* operations can fail.
22:54:45 <koz_> I think that Traversals assume both can fail.
22:55:17 <koz_> (also, the kind of type horrors 'Lens s (f s) a a' left me with are mad)
22:55:29 <koz_> (this is the first time I've run into cases where GHC just gave up trying to typecheck things)
23:00:55 <grantwu> johnw: Nope
23:00:58 <grantwu> johnw: I know it exists but lik
23:01:01 <grantwu> *like
23:01:16 <grantwu> "A modest subset of the language is currently supported (monads recently included!…)" is not something i want to deal with
23:02:03 <liste> grantwu: where's that quote from?
23:04:47 <koz_> Koterpillar: Could I be missing something if I'm using microlens instead of lens to try and do what I want?
23:05:21 <Koterpillar> koz_: sorry, no idea beyond what I suggested
23:12:05 <grantwu> liste: http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/
23:23:27 <lpaste> koz_ pasted “Confused about lenses with Alternative” at http://lpaste.net/239082
23:23:40 <koz_> Guess I'll just leave this here and hope.
23:55:09 <srhb> I think it may just be for data constructors
23:55:12 <srhb> Woops
