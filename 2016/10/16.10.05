00:07:36 * hackagebot clock-extras 0.1.0.2 - A couple functions that probably should be in the 'clock' package  https://hackage.haskell.org/package/clock-extras-0.1.0.2 (JonathanFischoff)
00:07:36 * hackagebot pptable 0.2.0.0 - Pretty Print containers in a tabular format  https://hackage.haskell.org/package/pptable-0.2.0.0 (gdevanla)
00:08:19 <laudiacay> hi, i have a function of type Integer Integer Bool, and I want to test it with every combination of Integer arguments choosing from integers -n to n. I then want to fold all the bools together... how would I do this"
00:08:23 <laudiacay> ?
00:09:26 <liste> laudiacay: type Integer -> Integer -> Bool ?
00:09:33 <laudiacay> liste: yeah sorry
00:09:49 <liste> laudiacay: a list comprehension would be the most clear probably
00:10:24 <laudiacay> i think i'd do foldr (&&) [] (map intintbool (list of tuples i guess))
00:10:50 <laudiacay> liste: ok ill look it up :)
00:10:50 <liste> > let f :: Integer -> Integer -> Bool; f a b = a > b in and [f x y | x <- [-10..10], y <- [-10..10]}
00:10:52 <lambdabot>  <hint>:1:98: error: parse error on input ‘}’
00:10:58 <liste> > let f :: Integer -> Integer -> Bool; f a b = a > b in and [f x y | x <- [-10..10], y <- [-10..10]]
00:11:01 <lambdabot>  False
00:11:48 <liste> :t and
00:11:50 <lambdabot> Foldable t => t Bool -> Bool
00:13:49 <laudiacay> liste: so I got a HELL of an error from this 
00:13:51 <laudiacay> foldr and [] (map testmod [(x,y)|x<-[-10..10], y<-[-10..10]])
00:14:21 <laudiacay> by the way testmod :: Integer -> Integer -> Bool
00:14:31 <liste> laudiacay: and doesn't need foldr, it's already a fold itself
00:14:42 <liste> if you want to use foldr, use (&&)
00:14:53 <laudiacay> oh shit i didnt know that cool
00:14:59 <laudiacay> so I do and [] (map thing)?
00:15:05 <liste> laudiacay: you don't need a map
00:15:14 <liste> the list comprehension already does the mapping
00:15:32 <laudiacay> oh i could put the testmod inside that lmao
00:15:34 <liste> though you can use it if you want
00:16:24 <laudiacay> liste: how would i exclude zero from the list of y's?
00:16:39 <laudiacay> i'm testing a weird division and modulo implementation for my CS class
00:16:53 <laudiacay> and tbh the test cases they gave us were shite
00:17:34 <liste> > [(x, y) | x <- [-3..3], y <- [-3..3], x != 0 && y != 0]
00:17:35 <laudiacay> oh i could just like unite [-10..-1] and [1..10]
00:17:36 <lambdabot>  error:
00:17:36 <lambdabot>      Ambiguous occurrence ‘&&’
00:17:36 <lambdabot>      It could refer to either ‘Data.Bool.&&’,
00:17:38 <laudiacay> oh
00:17:43 <liste> > [(x, y) | x <- [-3..3], y <- [-3..3], x != 0, y != 0]
00:17:46 <lambdabot>  error:
00:17:46 <lambdabot>      • Variable not in scope: (!=) :: t -> Integer -> Bool
00:17:46 <lambdabot>      • Perhaps you meant one of these:
00:18:04 <liste> there seems to be a nasty && defined somewhere
00:18:05 <EvanR> below the fold: /=
00:18:12 <liste> EvanR: good point
00:18:44 <neonfuz> laudiacay: remember your function takes in Integer -> Integer, not (Integer, Integer)
00:18:54 <neonfuz> thats why (map testmod [... didn't work
00:18:56 <laudiacay> neonfuz: i fixed that :)
00:19:01 <laudiacay> i now have another issue :(
00:19:18 <laudiacay> the bit where i am dividing by zero
00:19:25 <liste> > [(x, y) | x <- [-3..3], y <- [-3..3], x /= 0, y /= 0] -- laudiacay here, used != by accident
00:19:27 <lambdabot>  [(-3,-3),(-3,-2),(-3,-1),(-3,1),(-3,2),(-3,3),(-2,-3),(-2,-2),(-2,-1),(-2,1)...
00:19:38 <laudiacay> liste: ohhhh
00:19:47 <laudiacay> i forgot how weird ineq is in this language
00:20:03 <liste> it's weird in other languages
00:20:08 <EvanR> its more like how it looks in math
00:20:17 <liste>  /= looks more like ≠
00:20:26 <liste> != doesn't look like ≠
00:20:28 <neonfuz> ! being not is a c thing
00:20:42 <EvanR> also ~
00:20:47 <EvanR> ~= ;)
00:21:01 <laudiacay> OMFG IT WORKED!!!! i just had a random parenthesis hanging out in the list comprehension
00:21:02 <neonfuz> idk what I think about (True > False) == True in haskell
00:21:11 <laudiacay> and also my modulo function works :)
00:21:29 <EvanR> you dont like that ordering?
00:21:41 <laudiacay> we implemented peano arithmetic.... for integers instead of naturals... and with euclidean division rather than floor division
00:21:43 <laudiacay> it was hellish
00:21:45 <pavonia> != actually looks like putting more emphasis on the equality
00:21:52 <EvanR> incredibly equal
00:22:01 <EvanR> more equal than others
00:22:13 <phanimahesh> I remember my professor calling it ofcourse equal to
00:22:37 <grantwu> !!= for when you urgently need something to be equal
00:22:44 <neonfuz> EvanR: no I think its an okay ordering, but it has some odd implications that other languages don't have
00:22:47 <grantwu> main !!= correct_compiler
00:22:58 <EvanR> neonfuz: huh... like what
00:23:08 <neonfuz> actually now that I think about it, I might be wrong
00:23:10 <EvanR> also that would be the same thing in C
00:23:15 <phanimahesh> grantwu: That would be so awesome.
00:23:20 <grantwu> phanimahesh: :P
00:23:23 <neonfuz> the thing is in many other languages true is really just 1, and false is really just 0
00:23:26 <EvanR> (1 > 0) == 1
00:23:54 <neonfuz> EvanR: well yes, but there isn't true in c, there are only truthy values
00:23:58 <EvanR> i dunno about many but... C
00:24:03 <neonfuz> so (-1 > 0) == 1 in c aswell
00:24:13 <EvanR> i dont think so...
00:24:19 <neonfuz> wait
00:24:22 <M2tias> :D
00:24:26 <neonfuz> I mean (-1 > 0) != 1
00:24:31 <neonfuz> but -1 is still true
00:24:38 <neonfuz> lol
00:24:40 <EvanR> !!-1
00:24:46 <neonfuz> !!-1 == 1
00:24:55 <neonfuz> !!5 == 1
00:25:13 <EvanR> welcome to the jungle
00:25:21 <grantwu> This behavior is actually annoyingly difficult to get in assembly iirc
00:25:24 <neonfuz> oh I remember what the weird thing I was thinking is
00:25:28 <neonfuz> if you compare lists
00:25:31 <grantwu> wait no I think you xor with 1
00:25:34 <neonfuz> [1,2] > [1]
00:25:39 <neonfuz> becaus 2 > [] I guess
00:25:47 <neonfuz> (I know thats not exactly it, but still)
00:25:48 <EvanR> grantwu: it was, until you remembered xor
00:25:51 <grantwu> > [1, 2] > 1
00:25:54 <lambdabot>  error:
00:25:54 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘>’
00:25:54 <lambdabot>        prevents the constraint ‘(Ord t0)’ from being solved.
00:25:55 <grantwu> er
00:25:58 <grantwu> > [1, 2] > [1]
00:26:01 <lambdabot>  True
00:26:05 <neonfuz> see
00:26:08 <grantwu> Huh... how oes that work exactly
00:26:18 <grantwu> Are lists instances of Ord?
00:26:20 <ahihi> it's just lexicographical order
00:26:27 <EvanR> Ord a => Ord [a]
00:26:28 <neonfuz> when one list runs out of elements, the other is greater than it
00:26:32 <grantwu> oh, that's... super convenient
00:26:41 <grantwu> makes String compare work too
00:26:47 <grantwu> but String is bad, etc. etc.
00:26:49 <M2tias> "work" :D
00:26:52 <neonfuz> so a longer string is greater than a shorter string
00:26:59 <EvanR> "Haskell" > "PHP"
00:27:01 <grantwu> oh wait, no
00:27:04 <EvanR> > "Haskell" > "PHP"
00:27:06 <lambdabot>  False
00:27:07 <grantwu> that's wrong
00:27:08 <neonfuz> (if the values match up until the end)
00:27:09 <EvanR> lol
00:27:20 <grantwu> Or at least, that's the opposite of what you'd expect from lexicographical order
00:27:20 <neonfuz> > "abcde" > "abc"
00:27:23 <lambdabot>  True
00:27:36 <M2tias> > "Haskell" > "C++"
00:27:37 <neonfuz> its just a corner case that I didn't know about and it tripped me up at first
00:27:38 <lambdabot>  True
00:27:45 <M2tias> > "Haskell" > "Php"
00:27:47 <lambdabot>  False
00:27:53 <EvanR> i think we just found the new universal measure of programming language value
00:27:55 <pavonia> > all (< "PHP") ["Haskell", "C++", "Java"]
00:27:57 <M2tias> Php is the greatest
00:27:58 <lambdabot>  True
00:28:05 <M2tias> pavonia: wtf
00:28:16 <EvanR> PHP > *
00:28:41 <EvanR> clearly haskell's comparison needs work
00:28:43 <Sose> > "Quick Basic" > "PHP"
00:28:45 <lambdabot>  True
00:28:56 <neonfuz> php a best
00:29:00 <liste> at least lambdabot got that right
00:29:02 <neonfuz> quick basic a best
00:29:14 <neonfuz> > "R" > "Quick Basic"
00:29:16 <lambdabot>  True
00:29:24 <M2tias> > "Python" > "R"
00:29:26 <neonfuz> > "Scala" > "R"
00:29:28 <lambdabot>  False
00:29:30 <lambdabot>  True
00:29:40 <M2tias> > "Ruby" > "Scala"
00:29:42 <lambdabot>  False
00:29:50 <EvanR> having 'Z' be greater than 'A' seems weird
00:29:53 <M2tias> > "PHP" > "Scala"
00:29:56 <lambdabot>  False
00:29:59 <neonfuz> > "Matlab" > "Haskell"
00:30:01 <lambdabot>  True
00:30:08 <EvanR> the best grade you can get is clearly a Z
00:30:18 <EvanR> grade Z
00:30:18 <neonfuz> lol
00:30:31 <EvanR> A is the worst
00:31:24 <neonfuz> > "Verilog" > "Scala"
00:31:25 <EvanR> when you sort a list to get the top 10
00:31:26 <lambdabot>  True
00:31:28 <Sose> > "Ä" > "Z"
00:31:30 <lambdabot>  True
00:31:31 <EvanR> you have to go all the way to the end of the list? lol
00:31:40 <neonfuz> yes
00:31:54 <EvanR> the top 10 are at the bottom
00:32:06 <neonfuz> ?
00:32:16 <neonfuz> so the list is already somewhat sorted?
00:32:17 <M2tias> > "VHDL" > "Verilog"
00:32:19 <lambdabot>  False
00:32:22 <grantwu> > "AMD64" > "Haskell"
00:32:25 <lambdabot>  False
00:32:27 <neonfuz> M2tias: lol
00:32:42 <neonfuz> M2tias: lowercase letters a best
00:32:49 <EvanR> grantwu: apples and oranges
00:32:54 <EvanR> result voi
00:32:55 <EvanR> d
00:33:05 <ahihi> the type system has failed us!
00:33:05 <neonfuz> > "MIPS" > "haskell"
00:33:08 <lambdabot>  False
00:33:18 <neonfuz> > "mips" > "Haskell"
00:33:20 <EvanR> the type system failed to stop lambdabot spam
00:33:20 <lambdabot>  True
00:33:29 <M2tias> neonfuz: why people use VHDL or Verilog? some even port their stuff from one to the other
00:33:53 <neonfuz> lol idk much about either tbh
00:34:19 <EvanR> i use VHDL for web apps, VHDL on Velodromes
00:34:27 <grantwu> > "Verilog" > "SystemVerilog"
00:34:29 <lambdabot>  True
00:34:49 <grantwu> lambdabot hath spoken, it's time to go retro with our HDLs
00:35:26 <EvanR> PHDL, PHDL hardware description language
00:37:57 <tdammers> > "hamburgers" > "burritos"
00:38:00 <lambdabot>  True
00:38:08 <tdammers> > "burritos" == "monads"
00:38:11 <lambdabot>  False
00:38:15 <tdammers> who would have thought
00:38:19 <neonfuz> > "ZZZ" > "Haskell"
00:38:21 <lambdabot>  True
00:38:22 <neonfuz> https://esolangs.org/wiki/ZZZ
00:38:29 <EvanR> its only correct when you use lowercase
00:38:32 <neonfuz> lambdabot has spoken
00:38:39 <neonfuz> we must all switch to ZZZ
00:39:55 <EvanR> we should all go to sleep?
00:40:04 <neonfuz> I know I am
00:40:09 <neonfuz> (for real lol)
00:40:12 <neonfuz> night
00:41:17 <neonfuz> you know, the real reason why I got caught off guard by "abc" < "abcde" is because I'm used to javascript
00:41:41 <laudiacay> how would you implement map with a right fold without using a lambda....
00:41:49 <neonfuz> in javascript with corner cases like this, where one string is longer than the other and all preceeding characters match for example, they might just return something else to notate that
00:42:06 <neonfuz> but with haskell it has to be either true or false, so they just make a sane choice about which it should be and that is the way it is
00:42:31 <laudiacay> i dont even know how to do this....
00:42:40 <lyxia> > foldr ((:) . (+1)) [] [1,2,3]
00:42:43 <lambdabot>  [2,3,4]
00:42:44 <neonfuz> laudiacay: uhh, by having the accumulator be a list you're building up?
00:42:48 <EvanR> neonfuz: thats not even what happens in js
00:42:57 <laudiacay> OH DUH
00:43:07 <laudiacay> thanks lyxia you're awesome
00:43:11 <neonfuz> EvanR: is it not, huh, idk
00:43:11 <laudiacay> that makes a lot more sense....
00:43:16 <EvanR> "abc" < "abcde" ===> true
00:43:16 <lyxia> Does it
00:43:33 <neonfuz> EvanR: well in the first place you can't do things like "abc" < "abcde" in js, because that would just compare the references
00:43:40 <neonfuz> and its that way with most c like languages
00:43:42 <laudiacay> lyxia: yeah, we did . in class, I just forgot about it. so much so fast.
00:43:49 <EvanR> on strings is comparing lexicographically
00:43:56 <neonfuz> laudiacay: what class is this for btw?
00:43:58 <neonfuz> like what level of cs
00:44:08 <EvanR> javascript strings are unusually value-based
00:44:10 <laudiacay> neonfuz: honors intro computer science
00:44:19 <neonfuz> hmm
00:44:22 <laudiacay> we have like... these exercise practice problems, not for credit
00:44:25 <neonfuz> my intro cs class is java and it sucks so much
00:44:27 <laudiacay> and they're soooo hard
00:44:34 <neonfuz> is your uni good?
00:44:38 <laudiacay> neonfuz: dude yeah that was my first 2 CS classes in high school
00:44:40 <neonfuz> I wish mine had haskell classes
00:44:41 <laudiacay> i think it's ok
00:44:47 <laudiacay> university of chicago
00:44:53 <laudiacay> we're theory heavy tbh
00:45:08 <neonfuz> oh dude I know someone taking cs at uni of chicago
00:45:10 <EvanR> neonfuz: yeah, java and js are pretty different
00:45:34 <neonfuz> EvanR: yeah I know
00:45:58 <EvanR> basically some of their concrete syntax is the same
00:46:03 <laudiacay> neonfuz: what's their name/year?
00:46:14 <EvanR> and the word object is spoken a lot in both
00:46:16 <neonfuz> EvanR: I've done professional JS and java development before
00:46:37 <neonfuz> laudiacay: mia, not sure the year
00:46:45 <neonfuz> (not sure if I should say last name)
00:46:56 <laudiacay> dont think i know a mia
00:46:57 <neonfuz> EvanR: btw I'm going to UWM (milwaukee)
00:46:58 <EvanR> all that means is you got paid
00:47:05 <laudiacay> probably not itd be rude
00:47:06 <EvanR> not that you know they are different ;)
00:47:08 <neonfuz> laudiacay: ^
00:47:11 <neonfuz> oops*
00:47:22 <neonfuz> EvanR: true :P
00:47:26 <laudiacay> just on FB there are 4 mias at uchicago
00:47:27 <neonfuz> no but I do know a lot about both languages
00:47:28 <laudiacay> that i see
00:47:42 <ohsix> is there a haskell repl
00:47:47 <neonfuz> and how they are fundamentally different
00:47:56 <Insanity_> That reminds me of this thing I've read some time ago
00:48:03 <Insanity_> Java :: Javascript <-> Car :: Carpet
00:48:16 <laudiacay> http://termbin.com/5u6t
00:48:23 <laudiacay> any opinions on this hot mess
00:48:24 <EvanR> good one
00:48:29 <neonfuz> how js is pretty much scheme, but useless because you don't really have lists with good methods, and can't actually take advantage of any of the nice parts like objects really being hash maps because of a lot of BS
00:48:33 <laudiacay> i'm under a week into haskell please do not judge
00:48:53 <EvanR> js is pretty much scheme, with almost none of the features of scheme except closures
00:49:12 <neonfuz> EvanR: yeah pretty much lol
00:49:23 <Insanity_> neonfuz: 'useless' is not a term I would use
00:49:30 <EvanR> but the closures is a big deal, setting it apart from other popular languages at the time
00:49:45 <neonfuz> Insanity_: very extremely limited use compared to something like scheme
00:49:47 <Insanity_> If you do anything related to web development you'll encounter javascript in one way or another
00:49:57 <Insanity_> it runs servers (node)
00:50:27 <neonfuz> Insanity_: I'm not saying JS is useless, I'm saying they give you nice things like hashmaps built into the language, but they're useless because you can't use them with arbitrary keys securely, because of key conflicts
00:50:43 <Insanity_> neonfuz: my bad, misunderstood you
00:51:10 <EvanR> hashmaps built into the language is possibly a bad idea
00:51:17 <ohsix> huh neat, i see lambdabot in fedora haskell packages :D
00:51:21 <EvanR> for performance 
00:51:28 <tdammers> EvanR: what, why?
00:51:39 <neonfuz> EvanR: why?
00:51:44 <neonfuz> hashmaps are amazing
00:51:47 <EvanR> because youll mostly just use that, even if its not the best particular mapping structure to use
00:51:50 <neonfuz> they are at the core of most major projects
00:52:04 <EvanR> you might even use it as an array, if you didnt have arrays built in too
00:52:17 <neonfuz> EvanR: oh I have some bad news for you...
00:52:19 <tdammers> EvanR: as long as there are other ways to do it, I don't see a problem. It only gets bad when bastard hashmaps are your *only* built-in data structure (PHP)
00:52:20 <EvanR> better have different choices of structures to use for different problems
00:52:22 <neonfuz> javascript arrays are hashmaps
00:52:40 <laudiacay> hey ok does anyone understand why this won't compile? http://termbin.com/uh4a
00:52:49 <EvanR> i doubt javascript arrays are literally hashmaps
00:52:51 <neonfuz> (in practice many interpreters still treat them as true arrays if they can)
00:52:57 <neonfuz> EvanR: they are, though ^
00:53:05 <EvanR> ehm......
00:53:11 <neonfuz> you can have arbitrary keys in arrays
00:53:20 <EvanR> you can have properties
00:53:22 <neonfuz> var array = []
00:53:30 <neonfuz> arr["FOO"] = 5
00:53:35 <neonfuz> array*
00:53:42 <tdammers> neonfuz: you're mistaken there; you can have arbitrary keys in *objects*, and arrays happen to be a subtype of objects
00:53:43 <neonfuz> lol its been too long since I've programmed in js
00:53:59 <neonfuz> tdammers: well yeah
00:54:05 <tdammers> but the array part, i.e., using integers as indexes, isn't hash-map-like at all
00:54:24 <neonfuz> tdammers: so then are the arbitrary keys in the objects not part of the array then?
00:54:44 <tdammers> they are part of the array object, but they do not use the array's array functionality
00:54:53 <tdammers> the array part is really a dynamic array
00:55:23 <neonfuz> oh alright
00:55:33 <neonfuz> I was told that they were literally hashmaps by people
00:55:39 <tdammers> no
00:55:46 <tdammers> they're dynamic arrays (a.k.a. "vectors")
00:55:48 <neonfuz> (though again, I know that most interpreters would try to optimize this to not be the case)
00:55:54 <tdammers> http://lpaste.net/242588
00:56:11 <neonfuz> tdammers: ah I see
00:56:11 <tdammers> particularly, they're not sparse, and they're ordered
00:56:13 <EvanR> more like interpreters try to fool you into thinking arrays are objects if you look at them the right way
00:56:24 <EvanR> like getting their keys
00:56:25 <neonfuz> EvanR: yeah lol
00:56:32 <grantwu> EvanR: I mean that is why I love Python... as an interviewing language
00:56:36 <neonfuz> well actually arrays really are objects
00:56:48 <tdammers> it's really just syntax sugar, in that you can use [] access with integers to access the array part, and with strings to access object properties
00:56:52 <neonfuz> anyways I need to actually sleep, nn all
00:57:07 <EvanR> yeah integer keys... but fields cant be integers
00:57:10 <EvanR> only strings
00:57:20 <neonfuz> also I hate how inconsistent the array functions are 
00:57:44 <neonfuz> like, push and pop mutate the array while many other operations like map don't
00:57:47 <EvanR> if you demand the keys youll get string versions of the integers
00:58:06 <neonfuz> if everything either did or did not mutate it would be good
00:58:24 <neonfuz> (if everything mutated it might be a bit irritating, but better than it being inconsistent)
00:58:37 <EvanR> either way its p. bad
00:58:43 <neonfuz> (what I'm really asking for is for everything to not mutate the original array though)
00:58:45 <neonfuz> yea
00:59:20 <EvanR> the classic mentality is that the more memory you overwrite the more efficient
01:00:02 <Sose> well I think "pop" and "push" make more sense when they do mutate the array
01:00:22 <ohsix> oh hurp, so new, ghci is right there
01:03:30 <tdammers> neonfuz: http://ramdajs.com/
01:04:31 <neonfuz> yeah ik about that
01:04:57 <tdammers> I've used it a lot in the recent past, and the disappointment was very mild
01:05:04 <tdammers> which is more than you can say about the alternatives
01:05:06 <neonfuz> Sose: yeah I don't remember exactly what it was that I was running into, but the thing was, the only way to do what I wanted to do was with the mutable version of that function, and there was on non mutating version
01:05:24 <laudiacay> any ideas? anyone?
01:05:29 <neonfuz> tdammers: yeah if I use JS a lot soon I'll give it a try
01:06:22 <neonfuz> laudiacay: uhh you can't multiply [] and something
01:06:30 <laudiacay> oh shti
01:06:36 <jle`> is there a rules for realToFrac to be id if it's Double -> Double ?
01:06:37 <neonfuz> did you perhaps mean 1?
01:06:44 <tdammers> laudiacay: it generally helps to read the compiler erros in detail
01:06:55 <laudiacay> tdammers: i did :( I don't understand them yet really
01:07:03 <neonfuz> laudiacay: it takes some getting used to reading them, but you'll get the hang of it
01:07:04 <jle`> hm it looks like there's a RULES for fromIntegral for Int -> Int
01:07:08 <laudiacay> also neonfuz i get that that means more parentheses
01:07:11 <jle`> but why not realToFrac
01:07:23 <laudiacay> neonfuz: but i thought function associations bound to the left?
01:07:26 <tdammers> laudiacay: splitting up your code and type-annotating the parts often helps
01:07:42 <laudiacay> so I need (foldr (*)) [] l?
01:08:05 <laudiacay> it's still saying homework4.hs:2:21: error: parse error on input ‘::’
01:08:19 <tdammers> product' :: product ::
01:08:29 <laudiacay> lol
01:08:32 <tdammers> change that to product' :: 
01:08:36 <laudiacay> i wish this wasn't due tomorrow
01:08:42 <laudiacay> i can't even focus my eyes rn
01:08:54 <laudiacay> thank y'all for putting up w my stupid
01:08:57 <tdammers> what you need is sleep then
01:09:07 <neonfuz> you have 2 :: in that line
01:09:11 <neonfuz> why do you?
01:09:15 <laudiacay> i also need to get into grad school and this starts by getting this homework in on time
01:09:16 <neonfuz> >product' :: product :: 
01:09:28 <laudiacay> neonfuz: found that one... but now we are back to another error in line 3
01:09:51 <neonfuz> why is your accumulator a list
01:09:54 <neonfuz> shouldn't it just be a number?
01:10:01 <laudiacay> wait oh
01:10:04 <laudiacay> it should be 1....
01:10:06 <neonfuz> and because the unit number for multiplication is 1, it should be a 1
01:10:10 <laudiacay> i'm just used to putting [] there
01:10:14 <neonfuz> yeah
01:10:47 <tdammers> I'm pretty sure the compiler error says something about expecting an 'a' for the second argument of foldr, but having found a '[a0]' or something
01:10:49 <neonfuz> you know you can write type annotations after the fact most of the time too
01:11:07 <laudiacay> tdammers: yeh... it just didn't make sense at the time
01:11:16 <laudiacay> neonfuz: what do you mean?
01:11:18 <tdammers> another thing you can do is play type puzzle
01:11:20 <tdammers> :t foldr
01:11:23 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
01:11:24 <tdammers> :t (*)
01:11:26 <lambdabot> Num a => a -> a -> a
01:11:33 <laudiacay> oh true...
01:11:53 <tdammers> so if you want to fit (*) into the first argument of foldr, you get :: (a -> a -> a) -> a -> t a -> a
01:12:04 <tdammers> because (*) demands both operands to be the same type
01:12:04 <neonfuz> tdammers: if the functions are really simple, or when I'm just starting to write one very often times I write the function before the type of the function
01:12:07 <laudiacay> ohhh
01:12:37 <tdammers> foldr's type also demands that the return value is the same type as the second argument
01:12:43 <neonfuz> laudiacay: I go back and write the type declarations and stuff before of course, not later in the file
01:13:02 <tdammers> neonfuz: in fact, GHC can do that for you with type holes
01:13:13 <neonfuz> you can even write a function, and then :t on it to see what ghc thinks it is
01:13:38 <neonfuz> though sometimes the type signature it gives you isn't perfect, sometimes you want to be less general
01:13:45 <neonfuz> tdammers: type holes?
01:14:01 <tdammers> you can put _ in the type signature for the parts you're too lazy to figure out, and GHC will report the types for those "holes"
01:14:06 <neonfuz> crap I need to actually sleep
01:14:14 <neonfuz> tdammers: thats cool
01:14:27 <laudiacay> neonfuz: i try to, just i dont always get them yet :(
01:14:31 <neonfuz> sounds like agda
01:14:33 <tdammers> > let f x = x * 2 :: _ in f 3
01:14:35 <lambdabot>  error:
01:14:35 <lambdabot>      • Found type wildcard ‘_’ standing for ‘t1’
01:14:35 <lambdabot>        Where: ‘t1’ is a rigid type variable bound by
01:14:46 <tdammers> aww, cut off
01:15:00 <neonfuz> lol
01:16:40 <tdammers> there's also a similar but different strategy to go the other way around, writing just the type signature and an 'undefined' placeholder, just to see if the types fit together
01:27:14 <ongy> I'm thoroughly confused by this error: https://travis-ci.org/Ongy/monky/builds/165167874 in the 7.6.3 build I get a link error (during template haskell linking) that a symbol is missing, in the other tests I get no error. The same symbol is used for all ghc versions though
01:43:09 <lush> hey everyone. I played around with Parser Combinators and tried to implement a relatively simple Parser Library (hardly influenced by Parsec *g*).. I implemented a simple json parser with that library and now I wanted to ask for some feedback (with focus on the parser library). I'd say I still be a haskell-beginner and I'm not sure whether I should implement things differently
01:43:16 <lush> https://github.com/tholzschuh/parser/tree/master/src
01:43:35 <lush> It'd be really nice if someone has some time to look over my code :)
01:47:15 <neonfuz> lush: lol whats up with the Main.hs file
01:47:17 <neonfuz> its just hello world
01:47:41 <lush> neonfuz: aah yeah it is still the cabal output, I used the parser only from ghci so far
01:47:46 <lush> *stack output
01:55:42 <jle`> lush: looks solid to me
01:56:09 <jle`> if i didn't know any better i would think it was the source of an actual library
01:57:45 <jle`> lush: be aware that the backtracking semantics and implementation you have for <|> is commonly known to be inefficient
01:58:24 <jle`> well, your implementation is good, the behavior is what people have abandoned these days for the most part
01:58:35 <lush> jle`: thank you very much! 
01:58:45 <jle`> if you want an exercise, you can try implementing a non-backtracking <|> and a "try" combinator
01:59:05 <jle`> but other than that, the style and implementations seem pretty solid to me
01:59:15 <lush> I think I dont quite understand whats the problem with my <|> instance or what "alternative" implementation is possible
01:59:35 <jle`> btw, you can have type signatures in your typeclass definitions with the InstanceSigs pragma
01:59:45 <jle`> so you can uncomment lines like https://github.com/tholzschuh/parser/blob/master/src/Parser.hs#L17
02:00:49 <jle`> lush: for your current implementation of px <|> py, if px fails, the parser will backtrack to where it started trying to parse px and then begin parsing py
02:01:45 <jle`> for non-backtracking parsers, for px <|> py, when px fails, the parser will attempt to parse 'py' at the point where px failed
02:03:29 <lush> Do you mean that pY will start again from the first input instead of "str" which is the remaining string after pX?
02:03:36 <lush> if it fails
02:04:24 <lush> jle`: ?
02:06:14 <jle`> ah sorry, i misspoke
02:06:36 <jle`> for non-backtracking behavior, for px <|> py, py is tried only if px failes without consuming any input
02:07:29 <jle`> so running (string "hello" <|> string "world") will succeed on "world", but fail on "hworld". but try (string "hello") <|> string "world" will succeed on both
02:07:31 <lush> aaah so if it consumes input it will return the error along the remaining string
02:07:39 <jle`> yes
02:07:49 <lush> ok I see so I have to add try if I want my current behaviour
02:08:09 <lush> or better: If I add try it will behave as it does right now
02:08:21 <lush> ok that sounds relatively simple, ty :-)
02:08:48 <jle`> np :) i've never actually tried implementing a non-backtracking parser, i just know that people usually use them because they're much more efficient than backtracking parsers
02:08:50 * jle` shrugs
02:09:06 <lyxia> abusing try destroys performance though
02:09:24 * bartavelle doesn't know how to write a non-backtracking parser that is more performant than a backtracking one
02:09:28 <jle`> yeah, being able to assume "not try" by default is what gives non-backtracking parsers their boost in the first place
02:10:01 <bartavelle> is there a fast non-backtracking parser on hackage ?
02:10:33 <jle`> lush: but, regarding your original code, the implementations and styles look solid and for the most part they're written in a way i'd expect an experienced haskeller to write them
02:10:47 <bartavelle> (also I don't understand why a backtracking parser can't be fast in the absence of <|>, which probably proves I don't know how to write a non-backtracking one)
02:11:04 <lush> jle`: thank you very much, I'm glad to hear
02:12:09 <jle`> implementing those functions working with that parser type, i mean.  some of the more popular libraries use their own Parser types, but the nice thing about monadic/applicative parsers is that you don't need much to make a convincing and useful demonstration, heh
02:13:03 <jle`> by that i mean you don't need a fancy implementation of a Parser type, you just need what you have there :)
02:13:15 <merijn> bartavelle: What speed issues are you running into with, e.g. attoparsec?
02:13:37 <jle`> it's so simple yet so powerful :)
02:13:56 <lush> lyxia: will using try really bring that much overhead compared to m the backtracking solution? I don't really see where.. isn't it just an extra "Left" layer in case it fails?
02:14:06 <bartavelle> merijn, I wrote my own (simpler) parsers to get better memory/speed than attoparsec a couple times, but it's fast enough. I am just wondering if there is a non-backtracking parser that is faster, and how
02:14:13 <merijn> bartavelle: The main issue with writing fast parsers with parser combinators is not so much a parser issue, but a protocol issue. For fast parsing you want to spend as much time as possible just blitting known size byte chunks
02:15:16 <grantwu> bartavelle: I have no experience with this, but I thought this might be interestin: https://github.com/tsurucapital/parsergen
02:15:22 <bartavelle> merijn, agreed, I just wonder what situation makes the non-backtracking case slower by adding an alternative instance
02:16:26 <merijn> bartavelle: I don't think it should, tbh?
02:16:36 <jle`> non-backtracking parsers have an Alternative instance, it's just that <|> behaves differently than for backtracking parsers
02:17:36 <bartavelle> jle`, I see how that can make it faster, but I don't see the cases where this instance is practical (or even lawful?).
02:17:57 <jle`> x <|> empty = x, and empty <|> x = x
02:18:11 <bartavelle> hum, then it's probably lawful :)
02:18:26 <jle`> and x <|> (y <|> z) = (x <|> y) <|> z
02:19:18 <bartavelle> I think this one should hold too
02:19:27 <bartavelle> (if you do it the way I have in mind)
02:20:00 <merijn> bartavelle: Simple, this just requires that "foo <|> bar" cannot start with the same prefix. i.e. you have to be able to commit to a branch up front
02:20:35 <bartavelle> merijn, yeah that's the case with parsec without "try"
02:21:29 <bartavelle> ok I am convinced, now I'll have to check if you gain anything in practice by making it non backtracking
02:21:53 <lush> can someone explain to me why adding try will bring noticeable performance issues?
02:22:11 <bartavelle> lush, because you'll need to allocate something to "remember" where you were
02:22:38 <lush> But won't the backtracking variant do that as well?
02:22:45 <bartavelle> yes it would
02:22:58 <bartavelle> "try" is only useful for non-backtracking parsers
02:23:04 <bartavelle> I think?
02:23:11 <lush> really?
02:23:18 <lush> then mine is useless right now :')
02:23:44 <bartavelle> if <|> backtracks, then try is useless, that's why you won't find it in attoparsec
02:24:01 <merijn> lush: try *is* backtracking
02:24:07 <lush> I thought that lyxia said non-backtracking + try is worse than backtracking
02:24:10 <merijn> bartavelle: attoparsec does have try :p
02:24:18 <bartavelle> really !?!
02:24:23 <merijn> bartavelle: But it's a no-op for parsec compatibility :)
02:24:27 <bartavelle> oh :)
02:24:40 <lush> aaah ok so I'm right.. I guess I misunderstood lyxiathen
02:24:41 <bartavelle> learn something every day!
02:25:15 <merijn> bartavelle: The advantage is that for simple parsers (if your lucky) you can just change your import to attoparsec and use the exact same code :)
02:25:33 <jle`> or just write to the typeclasses in the parsers package hehe
02:26:40 <merijn> jle`: But then you depend on like 3 different parsers by default :\
02:26:41 <lush> but if try is useless for backtracking parsers I guess I have used it sometimes in Json.hs although I didn't need to...
02:26:48 <lush> guess I'll have to check on that :')
02:27:07 <merijn> Anyway, backtracking is bad for performance in general :)
02:27:33 * hackagebot haskell-tools-ast 0.2.0.0 - Haskell AST for efficient tooling  https://hackage.haskell.org/package/haskell-tools-ast-0.2.0.0 (lazac)
02:27:35 * hackagebot haskell-tools-ast-gen 0.2.0.0 - Facilities for generating new parts of the Haskell-Tools AST  https://hackage.haskell.org/package/haskell-tools-ast-gen-0.2.0.0 (lazac)
02:27:37 * hackagebot haskell-tools-ast-fromghc 0.2.0.0 - Creating the Haskell-Tools AST from GHC's representations  https://hackage.haskell.org/package/haskell-tools-ast-fromghc-0.2.0.0 (lazac)
02:27:39 * hackagebot haskell-tools-prettyprint 0.2.0.0 - Pretty printing of Haskell-Tools AST  https://hackage.haskell.org/package/haskell-tools-prettyprint-0.2.0.0 (lazac)
02:27:41 * hackagebot haskell-tools-ast-trf 0.2.0.0 - Conversions on Haskell-Tools AST to prepare for refactorings  https://hackage.haskell.org/package/haskell-tools-ast-trf-0.2.0.0 (lazac)
02:32:43 * hackagebot haskell-tools-cli 0.2.0.0 - Command-line frontend for Haskell-tools Refact  https://hackage.haskell.org/package/haskell-tools-cli-0.2.0.0 (lazac)
02:32:45 * hackagebot haskell-tools-refactor 0.2.0.0 - Refactoring Tool for Haskell  https://hackage.haskell.org/package/haskell-tools-refactor-0.2.0.0 (lazac)
02:32:47 * hackagebot haskell-tools-demo 0.2.0.0 - A web-based demo for Haskell-tools Refactor.  https://hackage.haskell.org/package/haskell-tools-demo-0.2.0.0 (lazac)
02:33:11 <jle`> i wonder if it's really important to separate all of those into separte packages
02:34:09 <jle`> project looks neat though :)
02:34:27 <merijn> jle`: Especially if all their versions are in sync :p
02:38:02 <lyxia> I think it looks better than a package with 100 modules.
02:38:32 <merijn> lyxia: What's the use, though? Besides stressing the dependency solver
02:38:39 <ongy> factoring out cli and web frontend sounds good to me aswewll
02:43:21 <lyxia> hmm good question
02:52:43 <lush> jle`: couldn't I use the State Monad to defined my Parser type as well? I'm thinking about implementing it as an MonadTransformer as well to better understand them 
02:52:54 <lush> *define
02:56:00 <jle`> lush: your parser type and its intstances are equivalent to `StateT String (Either String) a`
02:56:37 <jle`> what you might gain from a `type Parser = StateT String (Either Error)` refactor is that all of your instances are written for you
02:57:12 <jle`> implementing skipMany, option, etc. would almost be identical
02:57:34 <jle`> you'd just replace any 'Parser' constructor you have with the 'StateT' constructor, and you can reuse pretty much all of your code :)
02:57:47 <lush> jle`: perfect, that is what I wanted to hear ^^
02:58:06 <jle`> oh wait
02:58:08 <lush> jle`: really StateT?
02:58:16 <jle`> this is incorrect
02:58:23 <lush> I thought something like: type Parser a = State String (Either String a)
02:58:44 <jle`> `StateT String (Either Error)` would be String -> Either Error (a, String)
02:58:51 <jle`> lush: that can't be a Functor, Monad, etc.
03:00:22 <jle`> you'd have `type Parser = ExceptT Error (State s)`
03:00:36 <jle`> that would give you the proper Monad/Applicative/Functor/Alternative etc. instances
03:01:18 <lush> ok so I first have to check out the Except monad/monadT
03:01:56 <jle`> and you'd replace your "Parser" data constructor with:
03:02:23 <jle`> parser :: (String -> (Either Error a, String)) -> Parser a
03:02:26 <jle`> parser = ExceptT . state
03:02:33 <jle`> just to wrap it up in the newtype wrappers
03:02:47 <jle`> i probably should have let you figure that out yourself :)
03:02:58 <jle`> i'll let you figure out how to implement 'parse' then, heh
03:03:07 <jle`> but it's basically just unwrapping and wrapping newtype wrappers
03:03:43 <jle`> ExceptT e m a is m (Either e a), and State s a is s -> (a, s)
03:03:54 <jle`> so ExceptT e (State s) a is `s -> (Either e a, s)`
03:04:35 <jle`> which is exactly your Parser type
03:05:43 <jle`> oh, there's one difference in the instances
03:05:58 <jle`> for px <|> py, if both py and px fail, the error will be the concatenation of the two errors from px and py
03:06:32 <jle`> the <|> you wrote earlier will just return the error from py
03:07:36 <jle`> concatenating-the-errors is the behavior of the Alternative instance for ExceptT e m :)
03:09:04 <lush> ok thank you very much!
03:09:07 <lush> I will look into that
03:09:24 <lush> it sounds pretty interesting how my complete Parser Type is just a special case of some general Monads
03:09:42 <lush> (I'm a student of mathematics, I truly love generalization :D)
03:15:00 <jle`> factoring types is fun :)
03:15:25 <bollu> lush: ooh, neat :) pure math?
03:16:26 <lush> jle`: yeah it is ^^
03:16:33 <lush> bollu: yup pure maths ^^
03:17:49 <lush> btw I often thought that Programming did not _really_ help me understanding math. Haskell tought me this is not always true :D
03:18:55 <bollu> lush: neat!
03:19:01 <bollu> lush: I'm a comp sci student who dabbles in math
03:19:39 <lush> comp sci = Computational Science?
03:19:43 <jle`> lush: haskell has been a good lens for me too :)
03:20:21 <lush> jle`: pun intended?
03:20:26 <lush> ^^
03:21:36 <lush> bollu: guess for me it is the other way around .. although I started with programming first I later ended up preferring math instead 
03:21:42 <jle`> :p
03:24:56 <bollu> lush: haha, beat
03:25:01 <bollu> lush: no, computer science :)
03:25:19 <bollu> lush: though we get to augment our course a lot. I think I'll be taking a crypto + ML heavy course
03:25:22 <bollu> they seem to be the most fun
03:26:48 <lush> bollu: lol Computer Science... that was to obvious xD
03:27:09 <lush> ML the language ML?
03:27:58 <lush> I'll encounter some Category Theory in a lecture about algebraic topology in the upcoming semester. I hope I'll get a better categorical understanding of some haskell concepts from it ^^
03:28:00 <bollu> lush: machine learning :)
03:28:10 <lush> bollu: aaah^^
03:28:45 <bollu> lush: neat! I've wanted to study algebraic topology for a while now. I know a little but (fundamental group, some homology) but it's a far cry from categorical ideas
03:31:06 <lush> bollu: fundamental groups and homology aren't that basic anymore I guess.. I don't know much of them at the moment (only the basic ideas, nothing really rigorous)
03:31:16 <lush> But I'm a huge fan of Topology ^^
03:32:08 <bollu> lush: heh, I like algebra more
03:33:38 <cocreature> I’m trying to unpack a strict field of type Maybe Integer in a record via an unpack pragma but ghc prints a warning "Ignoring unusable UNPACK pragma". what are the reasons why this could be unusable?
03:33:56 <merijn> lush: I have sad news for you :p
03:34:02 <lush> bollu: yeah I really like Algebra as well. I will also attend my first higher Algebra couse besides Lineare Algebra 1&2
03:34:05 <lush> merijn: ? :/
03:34:06 <jle`> can you even unpack a Maybe Integer ?
03:34:27 <cocreature> jle`: well obviously I can’t but I thought I could :)
03:34:36 <merijn> lush: Category Theory has very little applicability to haskell concepts, or rather, you can apply it, but only if you jump through convoluted hoops :p
03:34:54 <merijn> lush: Haskell concepts would benefit more from lambda calculus/type theory :)
03:35:03 <jle`> cocreature: you might be interested in https://ghc.haskell.org/trac/ghc/wiki/UnpackedSumTypes
03:35:08 <cocreature> jle`: oh right I can’t unpack sum types I forgot about that
03:35:11 <cocreature> jle`: thanks!
03:35:17 <jle`> np!
03:35:24 <cocreature> oh great I forgot that UnboxedSums has been merged
03:35:28 <cocreature> looking forward to that
03:35:32 <jle`> the page explains some reasons why
03:35:41 <lush> merijn: :// ^^
03:35:41 <jle`> oh i didn't realize that either :O
03:35:51 <jle`> ghc 8.2 is going to be lit
03:36:21 <lush> merijn: still.. I like category theory even if it doesnt help me with haskell, so not that much of a deal :D
03:36:28 <bollu> lush: "higher" in the sense of groups, rings, fields? or more than that?
03:36:44 <jle`> also can we get that anonyms unboxed sum syntax for anonymous sums in general
03:36:44 <bollu> lush: I'm actually taking a number theory course right now. The learning curve is off the roof
03:36:46 <jle`> that'd be great
03:36:52 <merijn> lush: Sure, category theory is nice, I'm just trying to help rid the world of "haskell == category theory" myth :p
03:36:58 <bollu> lush: we're doing AKS primality testing next class. I'm excited but dreading it
03:40:18 <ttfh> I know nothing about category theory, but have still managed to write some haskell programs
03:40:23 <lush> bollu: base group theory, some ring theory and then mainly Galois theory first (Algebra 1) after that I'll attend a couse on non-commutative ring theory to further go into AlgNumber Theory of AlgGeometry
03:40:50 <lush> bollu: nice, I looked in some algebraic number theory (very basic, p-adic numbers) in a seminar
03:41:24 <lush> merijn: I didn't want to say that haskell == cat theory, I just thought that knowing category theory can help understand haskell concepts and maybe vice versa
03:42:37 <bollu> lush: woo, neat
03:42:57 <bollu> lush: I want to do algebraic geometry grothendeick style (I can never get his name right)
03:43:11 <bollu> lush: I've had some contact with "classical" algebraic geometry, It was pretty cool
03:46:33 <lush> bollu: nice, I don't really understand anything of AlgGeo at the moment.. although I want to look into classical AlgGeo as well
03:46:52 <lush> modern algebraic geometry is just too advanced at the moment.. ^^
03:59:48 <vapid> > round 0.5
03:59:50 <lambdabot>  0
04:00:13 <oherrala> > round 1.5
04:00:15 <lambdabot>  2
04:04:28 <aleator> > round 2.5
04:04:31 <lambdabot>  2
04:04:43 <aleator> > round 3.5
04:04:46 <lambdabot>  4
04:05:45 <Sose> 2.5 -> 2; 3.5 -> 4?
04:06:02 <merijn> Sose: Yes
04:06:09 <aleator> Rounds towards even. Which is sensible
04:06:36 <merijn> It uses banker's rounding (which IEEE754 specifies as the default rounding mode for floating point numbers)
04:06:45 <merijn> Which, indeed, rounds towards nearest even
04:07:20 <Sose> I see, interesting
04:07:22 <merijn> As a result half of all .5 numbers get rounded up, and half get rounded down, avoiding rounding bias
04:08:14 <merijn> Sose: Else a larger number of floats would get rounded up than down, on average
04:08:30 <merijn> Of course at the cost of biasing your data to contain slightly more even numbers than odd ones
04:09:01 <Myrl-saki> lol
04:10:02 <Sose> :D
04:27:36 * hackagebot wrecker 0.1.3.1 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-0.1.3.1 (JonathanFischoff)
04:27:38 * hackagebot wrecker 0.1.3.2 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-0.1.3.2 (JonathanFischoff)
04:27:40 * hackagebot wrecker 0.1.3.3 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-0.1.3.3 (JonathanFischoff)
04:37:34 <kqr> 11:06 <merijn> It uses banker's rounding (which IEEE754 specifies as the default rounding mode for floating point numbers)
04:37:45 <kqr> merijn, what does "default" mean in this case
04:41:15 <merijn> kqr: You can change the rounding mode and lots of other floating point settings in the hardware
04:41:46 <merijn> kqr: Default means "unless specifically switched to a different mode, that's what the hardware uses"
04:43:38 <kqr> ah
04:51:58 <ggVGc> so, my program crashed with a division by zer
04:52:08 <ggVGc> how do I find out any information about where it happened
05:00:30 <srhb> ggVGc: Use traceStack or something similar
05:00:37 <sjakobi> Hi! Does anyone know how to configure spacemacs to hindent with 4 spaces?
05:00:44 <srhb> ggVGc: Actually, read this: https://simonmar.github.io/posts/2016-02-12-Stack-traces-in-GHCi.html
05:02:30 <ggVGc> yeah, I did.
05:02:31 <ggVGc> okay
05:02:48 <ggVGc> problem was this bug is not easily reproducible
05:03:00 <ggVGc> guess I'll rebuild and run with stack traces enabled until it happens again
05:03:01 <ggVGc> thanks
05:09:30 <srhb> ggVGc: maybe some quickcheck and assert might help.
05:13:15 <NickHu> Does <*> associate to the left?
05:13:47 <srhb> NickHu: You can ask ghci with :info or :i 
05:13:57 <srhb> ie. :i <*>
05:14:05 <NickHu> srhb: Cool, thanks
05:49:28 <stevenxl> I'm reading the book Learn You a Haskell, and they used the term "as-pattern" to describe a pattern match in a function where you deconstruct the argument, but also keep a reference to the entire argument. Is the term "as-pattern" something specific to Haskell, or would it apply to other functional languages?
05:50:36 <srhb> stevenxl: I've seen it in the Nix expression language as well at least.
05:50:50 <stevenxl> srhb: Thanks! 
05:50:52 <ahihi> it's more general. in ocaml the syntax literally uses the keyword "as"
05:52:11 <ahihi> e.g. "x :: xs as list" for haskell's "list@(x:xs)"
05:52:44 <stevenxl> Oh. I see. Very similar to what you'd do in SQL (for the OCaml version)
05:57:08 <AleXoundOS>  Hi. Is it possible to create a shared library using Stack with it's dependencies linked statically?
05:59:54 <Guillaum> hi there. I'm playing a bit with Text.Megaparsec and there is no `chain` function such as in Parsec. Apparently we are supposed to use the `Text.Megaparsec.Expr` module, but for learning purpose I want to write my own expression parser. I'm unable to understand how it is done inside the `Expr` module and I'm always running inside infinite loop because of the left recursion of my grammar. Do you have any 
06:00:00 <Guillaum> pointer / insight to help me?
06:22:21 <NickHu> Actually, because applicative sequencing has no choice, doesn't that make <*> associative?
06:24:23 <hpc> :t (pure (+) <*> Just 5) <*> Just 10
06:24:25 <lambdabot> Num b => Maybe b
06:24:36 <hpc> :t pure (+) <*> (Just 5 <*> Just 10)
06:24:37 <lambdabot> Num a => Maybe (a -> a)
06:24:45 <hpc> it's not even remotely associative
06:25:02 <hpc> in fact i am surprised that typechecked
06:25:36 <merijn> hpc: wut
06:25:42 <merijn> hpc: I'm pretty sure it's associative
06:26:01 <hpc> it can't be
06:26:17 <hpc> i just demonstrated a scenario where a <*> (b <*> c) /= (a <*> b) <*> c
06:26:31 <hpc> the types aren't even the same
06:26:35 <merijn> Ah, it's kinda associative, bu not quite
06:26:39 <merijn> u <*> (v <*> w) = pure (.) <*> u <*> v <*> w
06:26:45 <NickHu> Associativity when fully applied..?
06:26:52 <hpc> ah yeah
06:27:03 <NickHu> Is there a name for that property?
06:27:24 <merijn> NickHu: The one I pasted is one of the applicative laws, not sure it has a name, though
06:28:33 <NickHu> merijn: in typeclassopedia it is described as "composition law"
06:34:38 <Gurkenglas> pure (.) <*> u <*> v <*> w = liftA2 (.) u v <*> w. I wonder how this "composition law" relates to let (<.>) = liftA2 (.) in (f <.> g) <.> h = f <.> (g <.> h)
06:35:56 <hpc> :t liftA2 (.)
06:35:58 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
06:36:12 <hpc> that's a snazzy little definition
06:38:35 <Gurkenglas> (In fact, maybe that typeclassopedia entry should be rewritten using that, looking at how it's currently saying that the reader should just convince himself the tricky composition law is right)
06:41:06 <NickHu> Gurkenglas: is <.> defined anywhere in the standard libraries?
06:42:02 <Gurkenglas> Nope in fact it appears semigroupoids abuses it http://hayoo.fh-wedel.de/?query=%3C.%3E
06:42:22 <Gurkenglas> Doesn't mean you shouldn't use it! Just define it as a oneliner somewhere
06:42:31 <hpc> also filepath
06:42:44 <Gurkenglas> Eh, that's IO, who needs that anyway
06:44:51 <Gurkenglas> (and <*> should have been called <$>, and <$> should have been called $>, and < and > to the sides of operators should have been made syntax for "that side of the operator is lifted")
06:46:47 <Gurkenglas> (and I'm not sure about this but maybe you could even have < > not modify fixity as an expression of some functor/applicative law)
06:50:21 <moonythedwarf> moo
06:52:11 <ongy> is there a reason to use 'fromInteger . toInteger' over fromIntegral?
06:53:08 <shapr> fromIntegral can bite you sometimes
06:53:29 <ongy> do you have an example when?
06:53:55 <Gurkenglas> http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Real.html#fromIntegral how? Inlining?
07:00:03 <shapr> ongy: I know it can truncate values sometimes, I don't remember more details off the top of my head.
07:07:45 <linoge> I'm quite sorry about the question I'm about to ask, but bear with me.
07:08:48 <linoge> I came to know what functional programming was this year. I love it, I embrace it. I've spent months learning Haskell and Lisp in my free time. I've taken time to read about category theory and I really like the way you use math to model your programs.
07:09:24 <linoge> And I've come to the point where I ask myself, why is Lisp so commonly considered 'superior' to Haskell.
07:10:10 <tdammers> linoge: idk, is it?
07:10:14 <merijn> linoge: It's only commonly considered that among smug lisp weenies :p
07:10:23 <tdammers> linoge: my impression is that lispers mainly consider lisp more "practical" than Haskell
07:10:54 <linoge> I've seen talks and slides where people consider Lisp to be more abstract than Haskell.
07:11:00 <tdammers> it's basically the old typed vs. untyped battle, taken to sophisticated levels
07:11:34 <tdammers> the disadvantage of a typed language like Haskell is that you have to make the types check out
07:11:49 <srhb> Oh, joy, a language rant, complete with pre-emptive apologies!
07:12:00 <linoge> No man, I mean, really.
07:12:14 <tdammers> the disadvantage of an untyped language like Lisp is that you still have to make the types check out, but there is no tooling to verify your reasoning, and no formal language to write things down in
07:12:54 <tdammers> seriously though, lisp's unitypedness has some advantages
07:13:30 <tdammers> I think both languages strike different local optima
07:14:11 <tdammers> the whole untyped thing only really works well when it's done radically, and then the highly dynamic nature makes up for the absence of typed thinking aids
07:14:21 <tdammers> and vv., a strong type system has to be strong enough to pull its weight
07:14:38 <linoge> That's quite what I wanted to know ^^.
07:14:52 <linoge> I mean, it's quite confusing from a begginer standpoint.
07:14:54 <tdammers> Java, for example, sits in a weird spot that way, and its dynamic features and its type system are equally disappointing
07:21:23 <Gurkenglas> Is there any type in which exist five values a-e with these properties: a is less or more defined than any other value; a is less defined than b and c and more than d and e; b and c have no definedness relation; d and e have no definedness relation?
07:22:39 <moonythedwarf> what would be the correct type for LinkLoc (Location a b c d) (Location e f g h) = (Location a b c (f:d),Location e f g (b:h)) if Location is a type of Area?
07:23:50 <srhb> moonythedwarf: That doesn't parse. Did you mean linkLoc ... = ... ?
07:24:39 <srhb> moonythedwarf: If so, linkLoc :: Area -> Area -> (Area, Area)
07:24:59 <Gurkenglas> ghci could have told you that, though: Load up the file and do :t linkLoc
07:30:44 <ania123> http://pastebin.com/eYpSFVDf
07:30:52 <ania123> can one tell me why I get this error?
07:31:39 <ongy> because haskell expects && as and operator
07:32:11 <ongy> why it is a lexical error and not a symbol not found I'm not sure
07:34:21 <ania123> ongy: did not get, sorry
07:34:37 <ania123> where is &&?
07:35:40 <ania123> http://pastebin.com/xpEkQB0N
07:39:23 <ongy> oh sorry, it's not the ∧ in your first paste, it should be http://www.fileformat.info/info/unicode/char/2019/index.htm then (the quotes)
07:39:42 <ongy> have you copied the code from somewhere?
07:48:22 <lpaste> lush pasted “State Monad?” at http://lpaste.net/243167
07:48:39 <lush> Is that the correct way to implement the State Monad?
07:50:41 <puregreen> is there any reason why Data.Foldable doesn't export foldl1'?
07:54:36 <Cale> lush: looks right to me.
07:55:20 <Cale> lush: Usually I wouldn't bother with implementing <*> and fmap separately, you can write the Monad instance and then just fill in fmap = liftM and (<*>) = ap
07:55:44 <Cale> But it's probably instructive to do it once regardless :)
07:59:05 <ania123> ongy
07:59:06 <lush> Cale: thank you! I know, I just wanted to try writing them seperate :-P it is easier to implement fmap and if I'd  fail that there'd be no chance for me to implement it as a monad ^^
07:59:08 <ania123> thanks
07:59:10 <ania123> http://pastebin.com/fW4pXMQU
07:59:14 <ania123> could you please see it
08:00:15 <ania123> ah, even is builting function
08:00:16 <ongy> ania123: the problem is that a function with the name "even" is already defined. There's the implicit include of Prelude, which has an even function. You can either call your function differently (myEven) or hide thie import. I suggest the first option
08:00:17 <ania123> clear
08:08:56 <moonythedwarf> moooo
08:27:40 * hackagebot servant-quickcheck 0.0.2.1 - QuickCheck entire APIs  https://hackage.haskell.org/package/servant-quickcheck-0.0.2.1 (jkarni)
08:27:42 * hackagebot tree-view 0.5 - Render trees as foldable HTML and Unicode art  https://hackage.haskell.org/package/tree-view-0.5 (EmilAxelsson)
08:29:07 <roconnor> Does wren hang out here?
08:30:50 <geekosaur> sometimes
08:32:16 <roconnor> ah
08:33:15 <roconnor> wrengr_away: I'm trying out unification-fd.  Idea: safeFreeze :: Traversable t => (forall v. UTerm t v) -> Fix t
08:34:28 <tabaqui> hi all
08:34:48 <tabaqui> does anybody know, how i can include external file in binary with ghc?
08:35:10 <tabaqui> without template embedFile
08:35:29 <tabaqui> like resource file in MS
08:45:29 <SrPx> Is a type system without subject reduction useless as a programming language?
08:45:39 <tdammers> tabaqui: why can't you use embedFile?
08:47:07 <geekosaur> tabaqui, I don't know of anything "canned". on win32 there should be access to resource functions in the Win32.* stuff
08:48:00 <geekosaur> on posix-ish systems, support will depend on available support for each system's object file format (ELF is mostly fine for this, Mach-O more problematic)
08:55:24 <hpc> SrPx: maybe you could do some linear typing shennanigans with it?
08:55:50 <hpc> it does seem like something you would always expect to have
08:56:00 <SrPx> hpc: I don't understand what you just said...
08:56:42 <byorgey> SrPx: what exactly do you mean by a type system without subject reduction?
08:56:55 <byorgey> you mean there is a reduction relation on terms which does not preserve types?
08:57:09 <ania123> http://pastebin.com/bJ5xuJ1p
08:57:14 <ania123> can one tell me problem?
08:57:18 <hpc> byorgey: that's how i read it as well
08:57:40 <byorgey> ania123: greater than or equal to is   >=,  not =>
08:58:24 <ania123> still problem
08:58:25 <ania123>  test.hs:2:33: error: parse error on input ‘?’
08:58:55 <srhb>  /urlselect 
08:58:57 <srhb> Woops
08:58:59 <ania123> http://pastebin.com/qU6dXEx8
08:59:12 <srhb> ania123: Your minus looks suspect.
08:59:16 <byorgey> ania123: you have a Unicode minus
08:59:24 <SrPx> byorgey: exactly
08:59:59 <byorgey> SrPx: there's no problem with it being a programming language, it just seems useless as a type system
09:00:03 <srhb> ania123: It's -, not −
09:00:23 <tabaqui> tdammers: cause hsopenssl hasn't function to read ca from bytestring, only from file
09:00:23 <ania123> ok. thx
09:00:29 <SrPx> byorgey: why it is useless as a type syste?m
09:01:17 <tabaqui> geekosaur: what is canned? yeah, C coders told me already about resources, but I didn't found it in hackage
09:01:20 <byorgey> OK, useless is too strong.
09:01:24 <byorgey> SrPx: for a programming language, typically you want the type system to rule out programs which will go wrong at runtime.
09:01:38 <geekosaur> "canned" basically means "nobody already sis it for you and put it on hackage"
09:01:40 <byorgey> SrPx: typically the way you show that depends on subject reduction.
09:01:42 <geekosaur> *did it
09:02:15 <srhb> geekosaur: "not canned"* :-)
09:02:18 <byorgey> SrPx: but I suppose you could have a weaker sort of theorem that says "the type of a term might change but it will only change in certain prescribed ways", so you know it won't go wrong
09:03:02 <SrPx> byorgey: I see what you mean, interesting.
09:03:18 <geekosaur> sorry yes, vanned means it's already on haclage waiting for you
09:03:20 <geekosaur> sigh
09:03:37 <monochrom> hehe
09:03:57 <monochrom> need direct connection from brain to computer
09:04:05 <ongy> tabaqui: depending on how fast and portable you have to have it, you could also file an issue/PR and wait for that to go pulbic (IMO you should eiter way)
09:05:41 <glguy> tabaqui: It looks like openssl itself expects a file rather than HsOpenSSL specifically
09:06:11 <geekosaur> wont help when brain shifts gears mid-sentence
09:06:46 <tabaqui> glguy: yeah, hsopenssl use c calls from openssl, but it still has other functions that work with strings
09:07:28 <glguy> tabaqui: Only where openssl supports that
09:08:03 <glguy> tabaqui: Anyway, you can add data files to your cabal package and access the installed paths for those files with the Paths_<package>.hs module and `getDataFileName'
09:08:15 <geekosaur> in any case, there is no simple portable way to embed and access a file like that. what glguy suggested is better
09:09:55 <tabaqui> this binary will be sent to clients, i don't want to pack it in archive with supporting stuff
09:10:25 <ongy> tabaqui: are you bound to a platform?
09:10:37 <nitrix> What's the other word opposite of contravariant, not the shortened covariant one?
09:10:45 <tabaqui> ongy: actually ms windows, but i'm coding at linux
09:11:41 <tabaqui> ongy: and i know that windows exe can contain resource file inside and access it like an external file
09:12:00 <srhb> nitrix: ? covariant is the opposite of contravariant.
09:12:18 <nitrix> There's another term for it that isn't shortened to `co`.
09:12:58 <srhb> nitrix: As in a ___variant functor which is synonymous to covariant functor?
09:13:04 <mnoonan> nitrix: are you thinking of the abominable usage of "invariant"?
09:13:10 <nitrix> srhb: Yes.
09:13:12 <nitrix> mnoonan: No.
09:13:56 <mnoonan> I've never seen anything other than "co" to fill in that blank, and it isn't short for anything else. It just means "together".
09:13:57 <Cale> nitrix: "Functor" without qualification tends to mean "covariant functor"
09:14:42 <Cale> A contravariant functor is just one which happens to have as its domain (or equivalently its codomain) the opposite category of the one you'd usually be thinking of.
09:15:09 <tabaqui> glguy: look at contextSetPrivateKey and contextSetPrivateKeyFile
09:15:16 <nitrix> I must be confused. I could swear there was another term, but I guess co and contra are the ones.
09:15:31 <dcoutts> tabaqui: right, in principle you can link with resource files and then use the win32 api to get at them
09:15:41 <tabaqui> glguy: they both use external file, but hsopenssl can call first using pointer
09:16:02 <dcoutts> tabaqui: you can list resource files in the link command in the .cabal file, but there's no special support in cabal for it
09:16:03 <glguy> call first what?
09:16:08 <tabaqui> dcoutts: is there a proper library?
09:16:34 <geekosaur> the problem might be testing that on linux (then again the problem there is knowing that it's actually working the same on both)
09:16:50 <dcoutts> tabaqui: I'd check the win32 lib to see if it covers that bit of the windows api, otherwise I'd check hackage, and finally just use the FFI to bind the windows functions
09:16:54 <tabaqui> glguy: hsopenssl provide contextSetPrivateKey that accept pointer to X509 and calls ssl_ctx_use_certificate
09:17:00 <srhb> nitrix: complement is sometimes used where dual could equally be used. I've never seen it with functors though.
09:17:14 <glguy> tabaqui: Yeah, but that's not related to CA certificates
09:17:17 <tabaqui> dcoutts: thanks, i'll look 'em
09:17:19 <Cale> i.e. if you have categories C and D, then a functor F: C -> D sends an arrow a: X -> Y in C to an arrow Fa: FX -> FY in D. A contravariant functor would then be some G: C^op -> D, which means that if you have some a: X -> Y in C as before, this is an arrow Y -> X in C^op, and so the functor G would send it to Ga: GY -> GX.
09:17:48 <tabaqui> glguy: but what the difference? openssl provides functions that can be called with file or pointer
09:17:52 <glguy> no
09:18:04 <tabaqui> glguy: so functions dealing with ca could send pointer too
09:18:06 <glguy> That's not obviously the case for the CA certificate list
09:18:29 <glguy> You need to look at the documentation for openssl and find that function first
09:18:34 <glguy> I don't know that it exists
09:18:52 <ongy> I'm thoroughly confused by this error: https://travis-ci.org/Ongy/monky/builds/165192882 in the 7.6.3 build I get a link error (during template haskell linking) that a symbol is missing, in the other tests I get no error. The same symbol is used for all ghc versions though
09:20:08 <nitrix> srhb: I think it's just confusion. I did go through a lot of material in the last hours so I probably just misclassified a term somewhere mentally.
09:20:19 <nitrix> srhb: It'll fix itself up naturally (:
09:20:56 <tabaqui> glguy: oh, you're right, they're different functions
09:21:10 <tabaqui> glguy: i should find another way
09:21:32 <nitrix> Do people ever use contravariant functors in practice though? Other than edward k?
09:22:41 <nitrix> It seems really niche to me. I tried wrapping my head around the cute odd/even rule to figure out if the function in the data type results in a covariant or contravariant functor, but it's still very ambiguous to me.
09:23:00 <glguy> tabaqui: Take a look at what HsOpenSSL-x509-system does
09:23:09 <glguy> tabaqui: seems like they have a way to load strings into the certificate store
09:23:36 <glguy> tabaqui: They use contextGetCAStore, and then add X509 certificates to it
09:23:55 <drdo> nitrix: Don't worry about category theory for programming in Haskell
09:24:23 <nitrix> drdo: I'm learning both in parallel.
09:24:31 <nitrix> drdo: Not as a prerequisite.
09:24:36 <glguy> tabaqui: https://github.com/redneb/HsOpenSSL-x509-system/blob/master/OpenSSL/X509/SystemStore/Win32.hsc
09:26:23 <geekosaur> ongy, that might well be a bug in the bytecode linker that only happens on 7.6.3. I know there are similar bugs in specific release versions on OS X and Windows
09:30:52 <tabaqui> glguy: that's strange cause i've alredy tried with contextGetCAStore
09:31:03 <ongy> ah, missing information. I have a debian jessie system here, which has 7.6.3 from the repo, where it works
09:31:33 <ongy> The cabal version is different there, but I upped the version on travis to the same cabal 7.8 uses, so I doubt that's the cause.
09:32:48 <tabaqui> glguy: oh, uhm, but it works
09:33:10 <tabaqui> glguy: presence effect, no doubt
09:33:20 <tabaqui> glguy: thanks anyway
09:44:10 <roconnor> Is there shorthand for {-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}
09:44:12 <wrengr> roconnor: I do hang out here; mostly during business hours
09:45:15 <roconnor> wrengr: cool.  I'm just trying to get my type-inference program to compile.  Who knew I could write type inference in 2 hours!
09:45:15 <glguy> roconnor: Yes, {-# LANGUAGE DeriveTraversable #-}
09:45:21 <wrengr> roconnor: yeah, that might work for freezing. It's been a while since I looked at unification-fd, so would have to check
09:45:29 <wrengr> :)
09:48:10 <wrengr> roconnor: there is one outstanding maybe-bug with the way unnification-fd does lazy cyclicity-checking. If you have unifications that're unrelated to the funal goal, there might be a chance we don't check them for cycles. I've yet to come up with any examples of it, but someone brought it up as a potential concern and I' haven't proved it impossible yet
09:49:58 <roconnor> Hmm.  My expermental code does full type annotation, so should pick up on every variable.
09:50:29 <roconnor> well, maybe not quite every variable.
09:50:53 <wrengr> yeah. Even when trying to come up with examples where the maybe-bug would actually be triggered (if it exists) I couldn't find any last time I looked
09:50:55 <roconnor> should be fine.  The annotations are supposed to obstesively construct a Coq term.
09:51:41 <roconnor> http://pauillac.inria.fr/~fpottier/publis/fpottier-elaboration.pdf was my main reference.
09:52:00 <roconnor> I was surprised that STBinding is a Monad.
09:52:24 <roconnor> Pottier definitely uses something that is only Applicative.
09:52:33 <wrengr> supposing it does happen, it's not entirely clear whether it should be called a "bug" in a lazy setting imo; sorta like how we don't care if your program has bottoms if we never need to force them
09:53:08 <roconnor> Yes.
09:53:29 <roconnor> If all the types I need to annotate a term to satify Coq are loop-free, that seems like it should be good enough.
09:54:44 <wrengr> I suppose I could try to generalize things from Monad to Applicative if anyone has some nice instances that are currently forbidden
09:55:52 <roconnor> It's not a problem for me.  unification-fd has this explicit applyBindings command, which Pottier doesn't have.
09:55:57 <roconnor> That seems to be a key difference.
09:56:59 <wrengr> the library mostly came from cleaning up the code for my MSE thesis (and throwing away all the interesting(-to-me) bits along the way, for simplicity) because I'd noticed that noone else seemed to have published a unification library yet. Definitely doesn't claim to be the final story on the topic
09:58:28 <wrengr> roconnor: fwiw, I've implemented http://research.microsoft.com/en-us/um/people/simonpj/Papers/higher-rank/putting.pdf using unification-fd. It's surprisingly little code once you factor out the unification parts
09:58:55 <wrengr> been meaning to write a blog post about it, but, well...
10:01:33 <dmwit> unification-fd was very fun to use the one time I needed unification.
10:19:58 <vinnie92> @pl \f g x y -> f (x ++ g x) (g y)
10:19:59 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
10:20:20 <vinnie92> @pf \f g x y -> f (x ++ g x) (g y)
10:20:20 <lambdabot> Maybe you meant: pl bf
10:20:40 <vinnie92> @bf join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
10:20:41 <lambdabot>  Done.
10:20:49 <vinnie92> @pl join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
10:20:49 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
10:25:17 <neonfuz> Can I get some feedback on my brainfuck implementation? https://github.com/neonfuz/haskell-brainfuck
10:25:36 <neonfuz> I'm new to haskell, started ~19 days ago
10:25:57 <roconnor> I'll have to figure out how to use UFailure after lunch I think.
10:26:55 <lispy> neonfuz: the record selectors like xaxis are partial functions
10:27:10 <lispy> neonfuz: try making a Keyboard value and then using xaxis on it
10:27:13 <Fairy> I have a String "Hello345for", I want to return a list ["H", "e", "l", "l", "o", "345", "f", "o", "r"], ie. each individual character as a string, with the exception of numbers, how do I go about doing that?
10:27:35 <maerwald> lispy: that's fine if it's internal API only
10:27:42 * hackagebot aws 0.14.1 - Amazon Web Services (AWS) for Haskell  https://hackage.haskell.org/package/aws-0.14.1 (AristidBreitkreuz)
10:27:58 <lispy> neonfuz: Pretty much anytime you make a sum type like Event you'll want to avoid directly making the alternatives be records.
10:28:18 <neonfuz> Fairy: could use a fold with a list accumulator and isNumber
10:28:28 <neonfuz> actually thats probably not the best
10:28:51 <maerwald> lispy: why would that be?
10:28:57 <neonfuz> lispy: you referring to my set implementation? I used pattern matching to make it shorter
10:29:16 <lispy> neonfuz: I'm looking at your brainfuck you just linked
10:29:27 <lispy> https://github.com/neonfuz/haskell-brainfuck/blob/master/Tape.hs#L22
10:30:04 <lispy> maerwald: Not sure I understand the question are you asking: why should we avoid partial functions or why does mixing sum types and records lead to partial functions?
10:30:32 <maerwald> lispy: partial functions can be fine, yes, especially for internal API
10:30:50 <neonfuz> lispy: wait lmao that isn't supposed to be in there
10:30:59 <lispy> yeah, it's deadcode :)
10:31:14 <neonfuz> lol oops, I was just showing something how it worked and accidentally left that in there
10:31:16 <neonfuz> gonna remove that now
10:31:24 <lispy> neonfuz: so maybe a different suggestion, add a .cabal file and add a -Wall flag to your build :)
10:31:42 <lispy> neonfuz: BTW, did what I said about partial record selectors make sense though?
10:32:46 <neonfuz> hold up I'm experimenting
10:32:47 <cheater> @hoogle :<:
10:32:50 <lambdabot> Data.Comp.Multi.Ops type (:<:) f g = Subsume (ComprEmb (Elem f g)) f g
10:32:50 <lambdabot> Data.Comp.Multi.Sum type (:<:) f g = Subsume (ComprEmb (Elem f g)) f g
10:32:50 <lambdabot> Data.Comp.Ops type (:<:) f g = Subsume (ComprEmb (Elem f g)) f g
10:33:00 <cheater> hey guys, what is :<: in this code? https://gist.github.com/raulraja/13a8a8789f9b70a1535ea4d44dfb1777
10:33:11 <lispy> neonfuz: another suggestion, I like to put types on all my top level definitions. So in this case, I would add types for runProgram and newMem
10:33:11 <maerwald> wrapping such record selectors in Maybe or similar just because isn't really useful. You should do that if you expose that stuff or if there are definitive reasons you gonna confuse them for your internal API
10:33:37 <neonfuz> lispy: yeah I didn't even export the Event type
10:33:50 <neonfuz> lispy: so what you're saying is I can't use xaxis on a Keyboard, I know that
10:34:04 <maerwald> then don't bother :P
10:35:05 <lispy> neonfuz: My advice to any haskell programmer is do what you can to avoid partial functions. You'll save yourself time later.
10:35:29 <geekosaur> cheater, it's an infix typeclass, see line 38
10:36:07 <lispy> In this case you could write data Event = Keyboard KeyData | Joy JoyData, and then make KeyData and JoyData the records.
10:36:28 <maerwald> I advice to avoid partial functions when you can't be sure they are used correctly. For your own internal API, you often can and it also makes things easier and doesn't clutter your internal API with Maybe types.
10:36:35 <lispy> You'd still get your nicely named fields but now you can't crash your program by calling xaxis on an event
10:38:14 <cheater> geekosaur: oh, that defines it, ok, thanks
10:39:04 <maerwald> and now you've introduced subtyping, next step is to use lens :P
10:42:56 <cheater> how come it's GetAllCats ([String] -> k) ? what does the k do? getAllCats returns m [String].
10:44:17 <cheater> i have a feeling it's something related to the fact that the [String] ends up in some monad, but i'm not sure.
10:48:06 <neonfuz> lispy: Can you explain more? Where do I use partial functions?
10:48:53 <neonfuz> lispy: and yeah that seems like a good suggestion to add type annotations to all my top level functions
10:49:21 <lispy> neonfuz: You weren't calling partial functions in the code I looked at, but you did create one when you made the Event type
10:50:12 <neonfuz> lispy: wait, how did I?
10:50:50 <lispy> neonfuz: Here is an exmaple: http://lpaste.net/243404
10:51:15 <dfeuer> Oh boy.
10:51:32 <dfeuer> carter, I've done some benchmarks on that reading thing....
10:51:59 <dfeuer> We're talking  693 nanoseconds versus 4.728 microseconds. And it also fails fast.
10:52:01 <carter> And?
10:52:10 <dfeuer> :D
10:52:14 <carter> Ok. Could you share those benchmarks
10:52:17 <carter> Good work
10:52:18 <neonfuz> sorry class is ending lol, brb
10:52:29 <carter> dfeuer: sorry I've been slow on prs
10:52:42 <adelbertc> o/ carter long time no talk
10:53:11 <carter> adelbertc: you at box or am I mixing folks up ?
10:53:17 <adelbertc> yep still at box :-)
10:53:23 <adelbertc> i just dropped off IRC for about a year or so
10:53:27 <adelbertc> recently came back on
10:53:56 <dfeuer> carter, I've only written some of the basics of this so far. Basically, I can handle Word-like things. I'll have to fill out the rest before I can put together any sort of PR. Changing the definition of Text.Read.parens to be lazy is necessary for the fast failure and *also* seems to have a very nice performance impact.
10:54:51 <dfeuer> The overall theme is: Look for what you actually want instead of looking at what's there and then seeing if it's what you wanted.
10:54:57 <carter> adelbertc: add the OTHER. Channel
10:55:12 <dfeuer> Because if it's not what you want, then you don't *care* what it is.
10:55:40 <dfeuer> This is very much unlike a normal parsing situation, of course.
10:55:48 <dfeuer> but Read isn't a normal parsing situation.
10:55:49 <carter> dfeuer: ok. Btw: on the monad ste stuff I would prefer if it were a single indirection data decl instead of a new type
10:56:16 <dfeuer> carter, no. That makes no sense at all. Coercion to/from Any has been officially approved forever.
10:56:30 <carter> No. no my point
10:56:32 <dfeuer> No one will fuck with it ever.
10:56:39 <maerwald> neonfuz: haskell doesn't have useful refinement types, so people often go crazy with avoiding partial functions. I disagree on that however, to some extent.
10:56:41 <lispy> neonfuz: I updated the paste with an example of what I'm talking about to avoid the partial selectors: http://lpaste.net/243404
10:57:08 <carter> dfeuer: I want it for different reasons. Also avoiding that allocation is never going to be the bottleneck
10:57:16 <dfeuer> carter, why do you want it then?
10:57:31 <dfeuer> If I want to screw you over with unsafeCoerce, I can *always* do so.
10:57:36 <lispy> maerwald: you don't need refinement types to do a better job than haskell records in this case. Ocaml does a nicer job on this example
10:57:51 <dfeuer> By reading your source code and then copying your type definition and using mine in place of yours.
10:57:54 <carter> dfeuer: stop arguing :). You are saying true things
10:57:55 <maerwald> lispy: I wasn't talking about this case
10:58:07 <carter> But that's not the reason
10:58:20 <dfeuer> OK, so what's the reason?
10:58:38 <carter> dfeuer: lemme collect my thoughts. Also about to hop on subway
10:58:43 <dfeuer> Later.
10:59:41 <maerwald> however, I think it's one of the major reasons haskellers avoid partial functions
10:59:45 <carter> Roughly it has to do with wanting to a) stuff an optional stack trace in b) support some funky regionT style nested stuff in a nice way
11:00:25 <carter> And I want to be able to kind talk about commutative stacks of st like things with different life times?
11:00:28 <dfeuer> carter, I see your data and raise you a newtype parameterized over a functor (or something; I'll have tot look at the details)
11:00:49 <carter> dfeuer: true, but then that leaks everywhere
11:01:08 <dfeuer> But I NEVER believe in slowing down code now to allow for some vague thing later, when I can always slow it down later instead.
11:01:17 <dfeuer> There's nothing hard about slowing it down later if you want.
11:01:30 <carter> David: it's the exception path
11:01:50 <dfeuer> Exceptions aren't always exceptional.
11:01:52 <carter> But you make a valid point
11:02:02 <dfeuer> In an STE context, they might *rarely* be.
11:02:11 <dfeuer> Anyway, later!
11:02:29 <carter> In st / ste monad style aborts are a total bail out
11:02:52 <carter> I agree with ExceptT and such you're absolutely right
11:02:59 <neonfuz> lispy: alright, though I still don't exactly understand why that is better, is it just to not clutter the scope?
11:03:08 <dfeuer> Sure, but that doesn't make them unusual in the context of the rest of the program.
11:03:11 <dfeuer> (necessarily)
11:03:11 <carter> Maybe I should try to figure it the regionSTE things
11:03:14 <dfeuer> Anyway, later!
11:03:28 * dfeuer wants to finish this Read thing.
11:03:50 <neonfuz> lispy: ohhhh, also because its safer because you can't call xaxis on Keyboard for example
11:03:57 <carter> Yah.  But rest of the program isn't the issue. Ohhh. Yiu don't want the extra indirection in the handler
11:04:02 <carter> Ttyl
11:04:03 <neonfuz> but you still have to unwrap the Event type
11:04:07 <dfeuer> Right, that.
11:04:09 <karanlearnshaske> why doest this not work please - http://lpaste.net/243434
11:04:16 <carter> Saying that would have helped
11:04:23 <carter> But gotcha
11:05:19 <maerwald> neonfuz: yeah, it forces overhead on you. The same when you use a safe version of 'head', although you know the input can't be empty
11:06:03 <karanlearnshaske> i get Occurs check: cannot construct the infinite type: a0 = [a0]
11:06:17 <maerwald> you can't tell haskell that's the case (for a regular list type), so people either wrap stuff in safe functions that return Maybe or construct yet another type as in "non-empty list"
11:06:56 <maerwald> both is silly for internal API that can be statically proven to be correct
11:10:23 <ph88> lyxia, are you around ?
11:11:32 <neonfuz> lispy: but doesn't your example also have partial functions?
11:11:45 <geekosaur> karanlearnshaske, look at the type of (:)
11:11:49 <geekosaur> :t (:)
11:11:50 <lambdabot> a -> [a] -> [a]
11:12:10 <ph88> any suggestions if i can refactor this function in a nicer way ?   https://paste.fedoraproject.org/444297/56909901/
11:12:47 <lispy> neonfuz: Which function is partial?
11:13:20 <neonfuz> aren't a and b still partial functions?
11:13:42 <lispy> Nope, check their type
11:13:45 <neonfuz> oh wait, it throws an exception rather than crashing? What is the difference in your version from mine
11:13:59 <neonfuz> oh, so it would fail to compile rather than fail at runtime?
11:14:05 <lispy> The difference is when the problem occurs. statically vs. at run-time
11:14:08 <neonfuz> THAT makes sense
11:14:15 <neonfuz> alright, you didn't make that clear to me earlier
11:14:21 <lispy> Sorry!
11:14:23 <neonfuz> I thought they were both runtime errors
11:14:24 <neonfuz> its fine
11:14:46 <neonfuz> (also I got partially applied functions and partial functions mixed up in my head lol, though I didn't say anything untrue about partial functions)
11:15:12 <neonfuz> that really is nice though, gives you compile time checking
11:20:19 <lispy> neonfuz: the main reason I make a big deal out of this example is to drive home the point that sum types + records results in partial functions. I think that's an important (but often unexpected) lesson for beginning haskellers.
11:20:40 <lispy> How you use that information is up to you.
11:30:00 <isd> Hey all. I have use of a function that could be defined as: \maybeF x -> case maybeF of { Nothing -> x; Just f -> f x }. This has to be defined in a common library somewhere, but I'm not finding it. Any pointers?
11:30:24 <hydPaz> :t maybe
11:30:27 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:30:52 <Fairy> I'm trying to remove whitespace, while at the same time grouping numbers together and I can't seem to get it to work in one pass :S "hi53 is 2" needs to become ["h", "i", "53", "i", "s", "2"]   I was suggested folding to solve this but I cant seem to figure out how I'd do that :S
11:38:40 <jle`> > groupBy isDigit "hi53 is 3"
11:38:42 <lambdabot>  error:
11:38:42 <lambdabot>      • Couldn't match type ‘Bool’ with ‘Char -> Bool’
11:38:42 <lambdabot>        Expected type: Char -> Char -> Bool
11:39:07 <jle`> > groupBy ((==) `on` isDigit) "hi53 is 2"
11:39:09 <lambdabot>  ["hi","53"," is ","2"]
11:39:18 <jle`> hm
11:45:36 <ertesx> Fairy: remove whitespace first, then use recursion
11:46:04 <ertesx> Fairy: a bare fold won't do it, because it gives you no context (you need the last element as well as the current one)
11:46:19 <ReinH> A fold can give you context.
11:46:45 <Fairy> ertesx: Isn't there a more sensible way of doing it? I don't wanna go over the list multiple times
11:47:04 <ertesx> Fairy: alternatively you can use preprocessing (e.g. a zip), so that the fold gives you the information you need, but that gets ugly very quickly
11:48:39 <ReinH> You can write a fold that produces both the last character seen and the result and then take only the result.
11:49:17 <ReinH> A fold that keeps track of some context and then eventually throws it away is a commonly used device
11:49:28 <ReinH> You'll find it all over Bird's algorithms
11:52:58 <ertesx> ReinH: i don't see a way to do it with foldr without using pre-/postprocessing
11:53:01 <neonfuz> lispy: yeah thanks for pointing that out, obviously compile time errors > run time error
11:53:09 <ReinH> ertesx: ok, one sec
11:53:15 <ph88> does someone have some advice on a possible refactoring of this function?  https://paste.fedoraproject.org/444297/56909901/
11:53:45 <ertesx> ReinH: i can think of ways that involve a tuple result, but that again requires post-processing
11:53:54 <neonfuz> lispy: and thanks for the suggestions
11:55:38 <ReinH> ertesx: Yes, it requires post-processing.
11:56:01 <ReinH> e.g., applying snd to the result
11:56:14 <dfeuer> edwardk, I can make common Read instances upwards of seven times as fast: https://ghc.haskell.org/trac/ghc/ticket/12665#ticket
11:56:21 <ReinH> But the fold does produce the result, it just also produces something else.
11:56:38 <dfeuer> :D
11:56:41 <ReinH> And this is a very common way to use fold
11:58:45 <edwardk> dfeuer: that is definitely a discussion worth having =)
11:58:50 <ertesx> ReinH: i can't remember a single time i've done that with a foldr =)
11:59:08 <ReinH> ertesx: it's very common if your name is Richard Bird.
11:59:15 <ertesx> it leads to similar mindfucks as mfix =)
11:59:26 <ReinH> I don't agree :)
12:00:07 <edwardk> i use the fold with an extra bit of context and discard the thing i needed during the stepping function with fst/snd all the time
12:00:08 <ReinH> I think it leads to materially different—and much more tractable—mind fucks.
12:01:17 <edwardk> if you package a right fold as data Fold a b where Fold :: (r -> b) -> (a -> r -> r) -> r -> Fold a b   that little bit of 'discard stuff at the end' functionality is the key to this thing being an instance of pretty much every interesting class
12:01:25 <ertesx> perhaps it's time to become richard bird then…  but not today…  it's probably one of those patterns that you didn't know you wanted until you started using them =)
12:01:36 <ReinH> :)
12:01:50 <edwardk> same with left folds or monoidal folds, etc.
12:02:09 <dfeuer> edwardk, the basic problem is that the classic lex/parse split makes *no sense whatsoever* in the context of Read. We can always win by (essentially) having the parser tell the lexer what it wants.
12:02:15 <ReinH> It's almost like you've done that and made a package for it
12:02:26 <edwardk> dfeuer: sure
12:02:27 <ertesx> edwardk: i always thought of that as: "because it gives you Functor"
12:02:30 <edwardk> ReinH: almost =)
12:03:24 <karanlearnshaske> hi
12:03:32 <karanlearnshaske> i am trying to debug this
12:03:34 <karanlearnshaske> http://lpaste.net/243532
12:04:27 <dfeuer> karanlearnshaske, what's it supposed to do? What's it do?
12:05:09 <dfeuer> karanlearnshaske, also, your variable name suggests that you think arr is an array; it most certainly is not.
12:05:30 <dfeuer> karanlearnshaske, oh, I see. Your bug is in fn. You wanted  fn = sumDigits . filter odd
12:05:57 <dfeuer> Or   fn xs = sumDigits $ filter odd xs
12:06:05 <dfeuer> Or    fn xs = sumDigits (filter odd xs)
12:06:25 <karanlearnshaske> why i cant use '.'
12:06:54 <dfeuer> karanlearnshaske, you can. You just can't use it the way you used it.   (.) is for *composing* functions.  filter odd arr  is not a function; it's a list.
12:07:13 <karanlearnshaske> oh ok
12:07:15 <karanlearnshaske> sorry
12:07:16 <dfeuer> filter odd, however, is a function, and you can compose it with sumDigits using    sumDigits . filter odd
12:07:31 <karanlearnshaske> thank you
12:07:33 <dfeuer> Remember:   (f . g) x = f (g x)
12:07:40 <karanlearnshaske> yes
12:08:29 <dfeuer> karanlearnshaske, I typically start writing everything out in the long form, then introduce things like (.), and then decide whether the result is more or less readable...
12:09:08 <ReinH> Until one gains an intuition for where/how to use (.), this would certainly be preferable to guessing about whether you should use it.
12:09:27 <ReinH> And is also the thing that you would do if you wanted to gain said intuition
12:09:32 <hydPaz> buffer #ybden 
12:09:39 <hydPaz> ... damn it, missed a /. Sorry!
12:11:19 <karanlearnshaske> trying to debug this parse error - http://lpaste.net/243540
12:12:56 <hydPaz> karanlearnshaske: The first and second definitions of `sumDigits` in that where block should be aligned
12:13:21 <hydPaz> Also: You shouldn't be using tabs, they make aligning things much more complicated
12:13:45 <karanlearnshaske> yike
12:14:06 <karanlearnshaske> ok thank you . they were looking aligned in sublime but were not
12:14:52 <ggVGc> "they looked aligned but weren't" is exactly why we don't use tabs
12:15:16 <ggVGc> becase if your editor renders a tab as 4 spaces, and you have 4 spaces on another line that looks aligned
12:15:23 <ggVGc> but it's not the same
12:15:56 <ggVGc> because a tab is actually 1 whitespace, and 4 spaces are 4 whitespaces
12:17:11 <karanlearnshaske> weird if i use tab and it looks aligned - then it should have been...
12:17:23 <karanlearnshaske> i checked again 
12:17:35 <karanlearnshaske> and again it was looking align but wasnt
12:17:40 <hydPaz> look at the lpaste you posted, they loomk ridiculously misaligned
12:18:21 <karanlearnshaske> yes that looks maligned
12:18:36 <hydPaz> s/mk/k/
12:18:40 <karanlearnshaske> what happened was - i had used tab + space 
12:18:53 <karanlearnshaske> and it became deceiving
12:19:06 <karanlearnshaske> should stick with space
12:20:52 <nshepperd1> Heh, maligned - appropriate
12:23:14 <roconnor> is Show1 a derivable class?
12:24:44 <ReinH> ggVGc: A tab is treated as exactly 8 spaces by GHC
12:24:51 <ReinH> not as one.
12:25:05 <ggVGc> ah, sorry
12:25:24 <ReinH> But your argument is still valid
12:34:12 <ertesx> i've written an implementation of 'group' in terms of post-processed foldr…  it wasn't as much of a mindfuck as i thought it would be, but still, the recursive version is a lot cleaner
12:36:48 <ertesx> https://gist.github.com/esoeylemez/4c41523f7fc6a04a323ce85e0104a868
12:41:19 <erisco> johnw, your op is showing
12:41:54 <ph88> ertesx, i don't know what that is, but looks nice :p
12:42:34 <ertesx> ph88: it's an implementation of 'group' (with a slightly different type)
12:42:40 <ertesx> > group "aabccccccd!!!"
12:42:43 <lambdabot>  ["aa","b","cccccc","d","!!!"]
12:43:28 --- mode: johnw set -o johnw
12:43:33 <dfeuer> WTF.
12:44:51 <dfeuer> valInteger in https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Text.Read.Lex.html is a serious Wat.
12:46:14 <int-e> looks perfectly reasonable to me.
12:46:49 <dfeuer> int-e, see https://ghc.haskell.org/trac/ghc/ticket/12665 for what I'm thinking about broadly.
12:47:54 <int-e> (except that maybe it should be a bit lazier... doable, would require some effort though)
12:47:57 <dfeuer> int-e, I bet that we can do better by starting off with a much bigger radix as I mention in a comment there, and then I'm thinking maybe switch from a top-down approach to a bottom-up one. 
12:48:52 <erisco> ertesx, I think you can simplify that
12:49:05 <erisco> let me see… I did something similar early this year
12:51:27 <dfeuer> I don't know exactly how to do that bottom-up thing, but I'm thinking a stack.
12:52:21 <ertesx> @let take2 = uncurry (++) . foldr (curry (pure *** fst)) mempty
12:52:25 <lambdabot>  Defined.
12:52:28 <ertesx> > take2 "abcde"
12:52:32 <lambdabot>  "ab"
12:52:34 <erisco> mm, seems so … not sure about generalisation to Foldable but this seems unimportant
12:52:39 <erisco> seeing as lists and Foldable are the same thing
12:52:45 <dfeuer> Not quite.
12:52:57 <dfeuer> (erisco)
12:52:57 <ertesx> erisco: Foldable is a fancy ToList
12:53:08 <dfeuer> Mh.
12:53:26 <erisco> yes, that is why I am not so compelled to wonder how to make this Foldable
12:53:32 <erisco> since you can just fromList and toList it anyhow
12:54:08 <ertesx> erisco: Foldable is *not* a FromList though
12:54:11 <int-e> dfeuer: oh I see what's wrong with the present code... indeed it should be chunking first and then do the bottom up merging (which is basically just a classic binary fold, with a subtle parity issue)
12:54:52 <dfeuer> int-e, what's the parity issue? I don't understand quite what the current code is doing; I just see that it has an unpleasant shape.
12:55:04 <erisco> no? I suppose not
12:55:12 <erisco> what type did you manage with your group?
12:55:25 <int-e> dfeuer: to model it, note that there's a monoid with (n1,b1) <> (n2,b2) = (n1*b2 + n2, b1*b2), in which you can combine digits in base b (d,b) to their full number...
12:56:30 <dfeuer> int-e, my intuition suggests that we want a helper function that produces an Integer and also reports how many digits it consumed so we can know how to value the preceding digits; I think this function will likely take some sort of digit stack, but I'm not sure.
12:56:32 <int-e> dfeuer: the parity issue is that when you convert 1 2 3 4 5 by combining pairs starting from the beginning, you end up with 12 34 5, the last digit still being in base 10 rather than 100.
12:56:39 <dfeuer> Ah.....
12:56:53 <dfeuer> That is annoying.
12:57:49 <erisco> ertesx, you've got list as well, okay then ;)
12:58:02 <ertesx> erisco: hmm?
12:58:02 <erisco> > group []
12:58:05 <lambdabot>  []
12:58:14 <dfeuer> int-e, I don't understand your monoid. Explain?
12:58:31 <ertesx> erisco: i only made mine a bit less boolean-blind by using NonEmpty
12:58:33 <erisco> ertesx, for your group
12:58:49 <ertesx> myGroup :: (Eq a) => [a] -> [NonEmpty a]
12:59:58 <int-e> dfeuer: it's really a mixed base representation property: if you have digits d1 followed by d2 in bases b1 and b2, respectively, then you can combine them into a single digit d1*b2 in base b1*b2 without changing the number's value.
13:00:25 <int-e> dfeuer: I mean d1*b2 + d2, of course.
13:00:35 <dfeuer> int-e, I don't quite understand yet. Can you give an example?
13:01:09 <johnw> erisco: boolean-myopic?
13:01:25 <int-e> dfeuer: the 12 34 5 is a mixed base representation of 12345, with bases 100, 100 and 10 for the digits; we can combine the last two digits in one in base 1000, ending up with 12 345.
13:01:48 <dfeuer> int-e, what's that win us?
13:02:09 <erisco> I have to dig up the NonEmpty stuff… give me a minute
13:02:31 <erisco> where is the package
13:02:43 <erisco> it is an ekmett thing iirc
13:02:45 <int-e> dfeuer: note that I'm not suggesting to use this monoid in the final implementation, but as a clean mathematical way of capturing the parity issue.
13:02:53 <johnw> erisco: semigroup
13:03:01 <ertesx> erisco: base since 4.9
13:03:21 <ertesx> (≥ GHC 8)
13:04:30 <ertesx> erisco: if you replace every instance of (x :| xs) by (x : xs), you get the regular 'group'
13:04:33 <int-e> dfeuer: My hope is that one could use the standard binary fold (of type Monoid a => [a] -> a, combining the list in pairs until a singleton list is left) and iteratively derive code that does not recompute all the 10^2^n powers that turn up several times.
13:04:50 <erisco> yes, I am just simplifying it
13:05:07 <ertesx> the main difference is the kind of constructor smiley and that 'head' is total
13:05:48 <erisco> here it is: https://gist.github.com/erisco/5dc67a5adccc3e50e545b6d3198dd171
13:06:07 <erisco> based on the similar answer I gave here: http://stackoverflow.com/a/35367835/260584
13:06:13 * dfeuer actually has to run away now to get ready to go see a show. Bye all! int-e, please feel free to comment on the ticket, or to send me an email, or whatever.
13:06:51 <ertesx> erisco: thanks, indeed…  the information is already included in the recursive result
13:07:19 <erisco> ertesx, what information?
13:07:48 <erisco> NonEmpty sure doesn't Show as nicely, ouch
13:08:54 <erisco> you could do  group :: (Foldable t, Eq a, Monoid m) => t a -> m (NonEmpty a)  I think
13:08:56 <ertesx> erisco: i mean the information i encoded as the extra Maybe…  didn't occur to me that it's already there
13:09:12 <ertesx> that looks like a type error
13:09:15 <ertesx> kind error
13:09:31 <erisco> it is… Alternative then
13:09:43 <erisco> the "stick it together" class appropriate to the kind :P
13:10:15 <ertesx> erisco: can you?  but then you need the extra Maybe
13:10:34 <felko> hey, i'm looking for a tutorial on comonads. I'm pretty familiar with the theory but i'd like to see it in action, with, for example, the Store comonad, anyone got resources on that ?
13:10:37 <ertesx> because you can't pattern-match on Alternative in general
13:11:02 <ertesx> felko: how about an exercise?
13:11:20 <felko> ertesx: sure
13:12:11 <erisco> :t foldr ((<|>) . pure) empty -- ertesx
13:12:12 <lambdabot> (Alternative f, Foldable t) => t a -> f a
13:12:41 <ertesx> felko: write this function:  blur :: (Fractional a) => Store (V2 Int) a -> a
13:13:03 <erisco> > (foldr ((<|>) . pure) empty) [1,2,3] :: [Int]
13:13:04 <ertesx> felko: it should compute a blurred version of the value at the selected point
13:13:05 <lambdabot>  [1,2,3]
13:13:09 <lispy> felko: https://www.doc.ic.ac.uk/~dorchard/publ/codo-notation-orchard-ifl12.pdf
13:13:24 <lispy> felko: and maybe also: https://www.cl.cam.ac.uk/~dao29/drafts/monad-or-comonad-orchard11-draft.pdf
13:13:28 <ertesx> felko: (V2 is from the 'linear' library)
13:13:50 <erisco> ertesx, i.e. if you can write it with lists you can convert it to Alternative
13:13:58 <felko> ertesx: ok, thanks, i'm not doing it right now but maybe tomorrow
13:14:08 <erisco> whether you can dodge the intermediate list… *shrug* less interesting question :P
13:14:08 <ertesx> erisco: yeah, that's true
13:14:45 <felko> lispy: i read a few of those articles, but is there any way to use codo notation with GHC ?
13:15:13 <felko> lispy: oh right, with TH, i remember now
13:15:42 <ertesx> felko: you can write multiple such functions, then apply them in sequence to stores that represent media using (=>>) or (=>=)
13:16:36 <ertesx> that way you can do audio/image/video processing, for example
13:19:49 <felko> ertesx: am i supposed to take the nearby values and do some kind of average function and then applying the result to the given point ?
13:20:09 <erisco> what variation of arrow will they come up with next?
13:20:28 <johnw> behold, the worra
13:21:14 <felko> erisco: are you familiar with arrows ?
13:22:10 <erisco> I have some knowledge on Arrow, but I was referring to =>>, =>=, ->, <-, <-<, >->, >=>, >>, <<, >>>, <<<, and the list goes on
13:22:25 <felko> oh ok
13:22:46 <Gurkenglas> foldr ((<|>) . pure) empty = asumMap pure, except asumMap doesn't exist :/
13:22:55 <MarcelineVQ> ↹
13:23:23 <erisco> ~> being a favourite lately, and I came up with $~> a couple days ago
13:23:24 <ReinH> Gurkenglas: foldr (f . g) z = foldr f z . fmap g
13:24:15 <felko> i'm goind to try tomorrow the blur thing, i'll come back if i'm stuck
13:24:15 <felko> bye
13:24:53 <Gurkenglas> :t alaf Alt foldMap pure -- barring asumMap = alaf Alt foldMap
13:24:54 <lambdabot> (Alternative g, Foldable t) => t b -> g b
13:25:24 <ReinH> asum . fmap pure
13:25:30 <erisco> is pointless not good enough? does it have to be done without parentheses too?
13:25:46 <Gurkenglas> ReinH, Functor is not a superclass of Foldable
13:27:45 * hackagebot hedis 0.9.4 - Client library for the Redis datastore: supports full command set,  pipelining.  https://hackage.haskell.org/package/hedis-0.9.4 (k_bx)
13:27:47 * hackagebot lmdb-high-level 0.1 - Higher level API for working with LMDB  https://hackage.haskell.org/package/lmdb-high-level-0.1 (andrewthad)
13:32:26 <erisco> I wonder if there is anything to that idea
13:36:07 <ph88> does someone have some advice on a possible refactoring of this function?  https://paste.fedoraproject.org/444297/56909901/
13:37:36 <erisco> qc2 parser_prop replay  could this return an Either instead?
13:38:29 <erisco> ast_in = maybe "no input" (show . zeroPos)
13:39:51 <erisco> replay = (show . usedSeed &&& usedSize) fl
13:40:46 <tag> it'd be nice to not mix camelCase and snake_case
13:41:24 <erisco> transformOut = tfComment . aeis . zeroPos
13:42:40 <monochrom> enhanced_CamelCase
13:42:49 <ph88> erisco, what would be the benefit of an Either on qc2 parser_prop replay  ?
13:43:32 <erisco> you can then probably make use of EitherT
13:43:50 <erisco> this might also work with parseSource parser (T.toStrict src_Text)
13:44:00 <ph88> why though ?
13:44:11 <erisco> you were asking for refactorings
13:44:45 <erisco> if you have an op that either succeeds or fails it is usual to represent this with Either
13:44:58 <erisco> or degenerately Maybe, if one side doesn't yield extra data
13:45:32 <erisco> having done so you can sequence operations which may fail, aborting as soon as one does
13:49:48 <ph88> erisco, ah i see .. but Failure is misleading .. there are actually 6 different cases here .. i may choose to implement the others differently later
13:50:08 <erisco> Either Error a  Error is some data type to represent your failures
13:50:15 <erisco> so this can have 6 cases if you wish
13:51:03 <erisco> @pl \f g h x -> f (g x) (h x)
13:51:03 <lambdabot> liftM2
13:51:07 <erisco> of course
13:51:41 <ph88> what's pl ?
13:51:45 <sbrg> pointless
13:51:46 <erisco> parser_prop = liftA2 (==) (fmap transformIn . Right) (transformOut (parseSource parser) . T.toStrict . printSource)
13:52:29 <erisco> I also have  ((id ~> transformIn) Right ~> transformOut (parseSource parser) . T.toStrict . printSource ~> id) (==)  where ~> is from Type.Compose
13:52:36 <erisco> or is that Control.Compose
13:52:49 <ph88> don't think i'm gonna use that last one bcz of readability
13:53:10 <erisco> well if you don't want pointless I don't see why you went half-way on it
13:53:56 <erisco> also  fmap transformIn . Right  is   Right . transformIn
13:54:09 <ph88> alright
13:54:36 <ph88> if i change   transformOut ast = tfComment $ aeis $ zeroPos ast  to  transformOut = tfComment . aeis . zeroPos   i get errors all over the place
13:54:42 <erisco> you can write   parser_prop x = (Right . transformIn) x == (transformOut (parseSource parser) . T.toStrict . printSource) x
13:55:31 <lush> If I'd have something like Parser a = StateT String [] a, would it be possible to implement a Parser that tries different "Parsing Strategies" at once that may work and kick them out of the list if they fail? Such that if the language is "well defined" it will always result in a singelton list with the right Parser Result if the "Code" was valid? 
13:58:05 <Rembane> lush: That seems possible, but what do you need the State-monad for?
13:58:59 <jdreaver> Has anyone had a problem with stack randomly deciding it needs to reinstall git dependencies from stack.yaml?
13:59:59 <jdreaver> I'm trying to integrate optimize our CI using caching, and stack is called a few times throughout the build. Sometimes it just decides it wants to rebuild a random git dependency when nothing changed.
14:00:04 <lush> Rembane: I though of something like Parser a = State String a
14:01:46 <Rembane> lush: So the state of the computation is the String it is parsing?
14:02:08 <lush> Rembane: yup
14:03:12 <Rembane> lush: Then you could just use a String as argument to your parser and skip the State monad altogether.
14:06:05 <lush> Rembane: but what if a parser may only consume some input?
14:07:05 <Rembane> lush: Return (String, a)
14:07:12 <Rembane> lush: Where the String is the remaining String.
14:07:50 <Rembane> lush: OTOH, this is basically the definition of State, so I think it is more about personal taste than something else. :)
14:08:20 <lush> Rembane: wouldn't that bloat my code? I thought using state here will help me because I don't need some pattern matching
14:09:06 <Rembane> lush: A bit, humhum...
14:09:32 <lush> Rembane: a bit? :')
14:10:07 <ph88> erisco, can i ask you something else about that function ?
14:11:17 <Rembane> lush: Indeed. It struck me that a parser has a tendency to chain operations, so a chain :: (String, a) -> (String, a) -> (String, a) might be very useful, but then we basically got >>= from Monad, so go for the State approach. 
14:14:28 <codedmart> How does keep-alive work in Socket? Does the socket send a keep-alive at certain intervals? If so how often? Which option sets the interval?
14:14:42 <lush> Rembane: thank you very much, I was just trying to understand some examples where I could use the StateT Monad
14:15:26 <sssilver> Hey, does anyone here know Haskell?
14:15:35 <grantwu> I would hope so.
14:15:58 <lush> sssilver: nice question :D
14:16:12 <Rembane> lush: No worries, I think one of the best ways to learn about StateT is to first build something that doesn't use it but should and then convert it to use StateT.
14:16:23 <Rembane> lush: If you want your parsers to take twice the time to implement. :)
14:16:37 <lush> Rembane: I already implemented one without using State :P
14:17:24 <Rembane> lush: Good. :)
14:18:06 <sssilver> I need a flavor of Haskell with manual memory management, is this an option?
14:18:33 <grantwu> No  
14:18:37 <grantwu> What do you actually want?
14:18:43 <grantwu> i.e. what is your ultimate goal
14:18:53 <jvanbure> sssilver: you could look into ATS, it has linear types :)
14:19:04 <sssilver> the ultimate goal is to push a billion vertices around at least sixty times a second
14:19:17 <EvanR> haskell can do that
14:19:24 <EvanR> for some value of a billion
14:19:24 <johnw> sssilver: you can always use the Haskell FFI to manage memory blocks yourself
14:19:26 <grantwu> What do you mean by "push" a billion vertices around
14:19:27 <EvanR> ^
14:20:19 <jvanbure> how would you get that to work even with C
14:20:41 <Tuplanolla> It's a good question what we'd have to give up for manual memory management.
14:20:52 <jvanbure> if you need n*60GiB/sec of memory throughput
14:20:56 <jvanbure> you might be out of luck
14:20:57 <EvanR> not much, FFI
14:21:22 <grantwu> Also consider that a billion vertices 60 times per second is more than one vertex per cycle
14:21:34 <EvanR> SIMD ;)
14:21:36 <grantwu> You are probably in the realm of GPGPU
14:22:07 <sssilver> grantwu sorry, that's a poetic way of saying I am considering my options for making a real time 3D rendering engine
14:22:21 <sssilver> and Haskell looks great, but I can't afford the GC lags
14:22:28 <grantwu> Then you need to go to the GPU
14:22:40 <grantwu> sssilver: Consider investigating Rust?
14:22:50 <jvanbure> or C++
14:22:58 <sssilver> grantwu yes Rust is great and it's my #2 choice, but somehow Haskell feels more elegant
14:23:07 <sssilver> C++ is too bloated for my taste
14:23:35 <jvanbure> C++, despite being not "cool" or "hip" probably has some of the best support you'll even find
14:23:39 <jvanbure> *ever
14:23:54 <ph88> :r
14:23:56 <sssilver> yeah, I understand that. 
14:23:58 <EvanR> sssilver: theres a few projects like this in haskell, for example lambdacube
14:24:03 <jvanbure> especially for interacting with graphics cards
14:24:15 <jvanbure> also it has manual memory management
14:25:10 <johnw> sssilver: it's easy to confine what you're looking for down to an empty set; you're going to have to accept certain tradeoffs
14:25:15 <jasonm> hi. why does this work
14:25:19 <jasonm> > 2.5 :: Fixed E12
14:25:21 <lambdabot>  error:
14:25:22 <lambdabot>      Ambiguous occurrence ‘Fixed’
14:25:22 <lambdabot>      It could refer to either ‘Data.Fixed.Fixed’,
14:25:30 <jasonm> but this doesn't: sqrt 2 :: Fixed E12
14:25:41 <jasonm> No instance for (Floating (Fixed E12)) arising from a use of `sqrt'
14:25:45 <geekosaur> jasonm, because numeric literals are polymorphic
14:25:47 <geekosaur> :t 2.5
14:25:49 <lambdabot> Fractional t => t
14:26:12 <jasonm> emphasis is on why doesn't sqrt work
14:26:12 <geekosaur> Fixed has a Fractional instance. it does not have a Floating instance
14:26:19 <jasonm> hmm
14:26:24 <geekosaur> transcendental functions require Floating
14:26:32 <jasonm> is there a bigfloat library
14:27:46 * hackagebot partial-isomorphisms 0.2.2 - Partial isomorphisms.  https://hackage.haskell.org/package/partial-isomorphisms-0.2.2 (schernichkin)
14:27:48 * hackagebot hsinstall 1.1 - Install Haskell software  https://hackage.haskell.org/package/hsinstall-1.1 (DinoMorelli)
14:27:48 <monochrom> (but sqrt is not transcendental, just irrational :) )
14:27:55 <geekosaur> sorry, yes
14:28:07 <EvanR> sqrt for Fixed would be nice
14:28:08 <geekosaur> @hackage numbers
14:28:08 <lambdabot> http://hackage.haskell.org/package/numbers
14:28:15 <EvanR> i blame the class hierarchy
14:28:40 <geekosaur> > sqrt (2.5 :: CReal)
14:28:41 <monochrom> you could go through Double and then round to Fixed
14:28:43 <lambdabot>  1.5811388300841896659994467722163592668598
14:28:48 <EvanR> could
14:29:02 <EvanR> but thats 5x more code than sqrt 2
14:29:03 <jasonm> nice
14:29:46 <ph88> if i have a Maybe on the IO level and and i want to give a default for the Nothing case what could i put there ?
14:29:53 <ph88> putStr "Nothing"  ?
14:30:09 * Clint squints.
14:30:33 <monochrom> I don't understand "Maybe on the IO level". Write the actual verbatim type.
14:30:35 <EvanR> more types please
14:30:38 <jasonm> :t maybe
14:30:40 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:30:48 <SrPx> If a Haskeller would design a blockchain such as Ethereum, what would its approach to the EVM be? EVM is a virtual machine like the JVM which runs primitive instructions such as ADD and MUL, each one with a set cost, that runs on the blockchain.
14:30:48 <jasonm> ^^ maybe
14:30:51 <geekosaur> depends on what youre doing with it
14:31:14 <SrPx> The EVM has a very imperative nature. I wonder if there would be a functional equivalent for it?
14:31:50 <SrPx> The obvious issue is that one can't assign a fixed cost to the operation of evaluating a term on functional languages...
14:32:17 <monochrom> try the STG machine
14:32:37 <EvanR> 1 reduction = $1
14:33:16 <limeburst> Is this the right place to ask questions regarding Ivory? =)
14:33:27 <geekosaur> you're building programs for what amounts to a CPU embedded in the network. perhaps Atom should be your inspiration
14:33:30 <geekosaur> @hackage atom
14:33:30 <lambdabot> http://hackage.haskell.org/package/atom
14:33:46 <johnw> limeburst: I'd think so
14:33:47 <SrPx> monochrom: if you designed Ethereum in particular, would you use STG as a replacement for the EVM?
14:34:16 <geekosaur> if you wanted to design a functional blockchain, STG is probably the abstraction to start with, yes
14:34:29 <limeburst> johnw: good!
14:34:57 <monochrom> I don't know Ethereum. But I would learn from the STG machine, among other things.
14:34:57 <limeburst> I want to index into an Ivory array with a variable
14:35:27 <SrPx> I really should learn more about the STG, can it be used for non-lazy evaluation? Any friendly introduction suggestion?
14:36:27 <geekosaur> SrPx, it's a graph reduction engine. you would normally only use that for lazy evaluation
14:36:29 <limeburst> Can I cast an integer variable to Ix to use it as an index?
14:36:40 <hpc> haskell doesn't have type casts
14:36:46 <geekosaur> limeburst, that's ... confused
14:36:56 <geekosaur> you can't "cast". you can't "cast" to a typeclass
14:37:19 <monochrom> Ix is not a type. But both Int and Integer are already instances of Ix. You should need do nothing, if you were coding it right.
14:37:21 <geekosaur> and Int already has an Ix instance
14:37:29 <geekosaur> so what error are you seeitng?
14:38:38 <limeburst> Couldn't match expected type ‘Ix 6’ with actual type ‘Ref ('Stack s1) ('Stored Uint8)’
14:38:59 <limeburst> 'Stored Uint8 is a local variable used as a counter
14:39:25 <ph88> trying to figure out why a parse error occurs on line 13  https://paste.fedoraproject.org/444436/03524147/
14:39:32 <geekosaur> that Ix can't be the standard one...
14:39:39 <limeburst> Since its range must be known statically at compile time I thought I'd mod 6 it and cast to Ix 6
14:39:42 <limeburst> geekosaur: Ivory
14:40:02 <geekosaur> and, that's type level
14:40:07 <hpc> and still not a cast
14:40:18 <limeburst> sorry :P
14:40:26 <limeburst> hpc: https://github.com/GaloisInc/ivory/blob/c28b2b6c1cdaf92885598b7a72d02b4ef7cfc30a/ivory/src/Ivory/Language/Array.hs#L76
14:40:35 <geekosaur> so you are not converting to anything, also you have bigger problems I think, with that type
14:41:00 <geekosaur> ph88, because line 10 is nonsense
14:41:03 <limeburst> I don't have a concrete understanding of the terminology
14:41:11 <geekosaur> drop the extra "let"
14:41:14 <limeburst> Apologies
14:41:47 <geekosaur> you're already *in* a let, making another one at the level of let bindings wouldn't do anything even if it were legal
14:44:29 <isd> When adding version bounds to dependencies in my .cabal, how strict do I need to be with the version numbers? Are packages supposed to follow semver, or is there another convention I should be aware of?
14:45:05 <ph88> good spot geekosaur !
14:46:00 <dmj`> isd: http://pvp.haskell.org/
14:46:17 <glguy> isd: No, packages don't follow semver, they follow the Haskell PVP, generally ^
14:46:43 <isd> glguy: thanks
14:49:28 <Jello_Raptor> There's a thing I see here and there, that lets you define a default applicative instance for monad, among other similar things
14:50:35 <Jello_Raptor> is that an implemented extension?
14:50:50 <johnw> I don't yet know what the "thing I see" means
14:51:03 <monochrom> Where can I see it?
14:51:25 <geekosaur> isd, semver doesn't quite work because ghc cheats in the name of performance
14:51:35 <monochrom> Or is it one of those Heisenwebsites that cannot be found again?
14:52:08 <geekosaur> (it exposes internals that semver assumes shouldn't be visible and therefore affect versioning, in the name of cross-module inlining)
14:58:10 <isd> geekosaur: interesting. Is there somewhere I could read about that?
14:58:33 <stooge> hey folks.. I'm working on a project euler question (12).. part of the question is about finding the divisors of a number.. I think the way I'm doing it is really inefficient and because of that my program never terminates. Can someone confirm that's indeed the inefficent part? http://lpaste.net/243781
14:59:15 <isd> Also, why is major two parts?
15:00:10 <glguy> isd: To distinguish major library changes from simply removing a definition or changing the type or an existing definition
15:02:09 <isd> Ok. I don't see that described in the pvp doc; I assume it's just not part of the spec because the boundary there is somewhat subjective?
15:02:15 <geekosaur> isd, I don't know if there is anywhere that pulls it all together. I actually have a note to someday write it up since I haven't found a reasonably complete description anywhere else (someday)
15:03:46 <glguy> isd: some packages use it to indicate compatibility across a particular set of packages that are closely maintained
15:03:47 <geekosaur> lots of ghc trac tickets, lots of references in cabal and stack repo histories (since a large chunk of both tools is trying to get builds to behave in its presence)
15:04:16 <glguy> so that within that set the packages can depend on each other with a constraint on the first number
15:04:27 <isd> makes sense.
15:09:53 <monochrom> @type find
15:09:55 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
15:14:20 <EvanR> btw speaking of !!x in C, !! is a monad
15:14:33 <Jello_Raptor> aha, found them <SrPx> The obvious issue is that one can't assign a fixed cost to the operation of evaluating a term on functional languages... 
15:14:46 <Jello_Raptor> err, https://ghc.haskell.org/trac/ghc/wiki/InstanceTemplates 
15:14:53 <Jello_Raptor> did anything come of these? 
15:38:14 <Davehkiin> What is haskell
15:38:32 <monochrom> a programming language
15:38:36 <dmwit> ?tell stooge Yes, `divisors` can be sped up a lot with a smarter algorithm.
15:38:36 <lambdabot> Consider it noted.
15:38:37 <hpc> baby don't hurt me
15:38:40 <hpc> no wait, that's love
15:38:53 <Davehkiin> What is Haskell primarily useful for?
15:39:00 <monochrom> the topic line has websites you can read
15:39:05 <dmwit> ?tell stooge There are several other opportunities for improvement, as well.
15:39:05 <lambdabot> Consider it noted.
15:39:21 <hpc> look at haskell.org
15:40:37 <another_> ok guys so I herd your all pretty groovy
15:40:44 <another_> so...
15:40:51 <another_> whats the deal with Haskell?
15:41:00 <hpc> we're occasionally known to even be downright tubular
15:41:16 <monochrom> there is no deal.
15:41:18 <Davehkiin> Tubular Bells - Mike Oldfield
15:41:20 <Davehkiin> NOw there's a tune
15:41:23 <Desu> another_: it is glorious
15:41:28 <Hafydd> Davehkiin: it is primarily useful for writing programs.
15:41:36 <hpc> another_: you can read about the language from the links in the topic
15:42:03 <Davehkiin> Hafydd, for writing fully fledged programs? or for parsing information?
15:42:07 <monochrom> but there can be duets
15:42:08 <Hafydd> Davehkiin: the former.
15:42:44 <another_> so what would I use haskell for?
15:42:45 <Davehkiin> Hafydd, interesting. I've never developed an application.
15:43:14 <Tuplanolla> How about everything, another_?
15:43:21 <geppettodivacin> another_: Haskell is a general purpose language, so you can use it for writing basically anything.
15:43:38 <Davehkiin> Do I start with the Haskell Platform?
15:43:57 <dmwit> The minimal install of the Haskell Platform is one good choice for beginners.
15:44:11 <grantwu> Davehkiin: https://github.com/bitemyapp/learnhaskell
15:44:19 <Davehkiin> dmwit, guess what i'm downloading on your reccomendation
15:44:22 <Davehkiin> dmwit, you guessed it.
15:46:09 <another_> ok...
15:51:02 --- mode: ChanServ set +o glguy
15:51:02 --- mode: glguy set -bqo *!*@*AlvaroMolina *!*@*/ip.185.89.248.21 glguy
15:57:01 <Squarism> theres no common basetype for tuples? 
15:57:13 <glguy> There's no common base-type for anything
15:58:29 <Squarism> or.. i want to define a function with one argument with type : all tuples with an integer in its first dimension
15:59:02 <grantwu> I don't think you can really do that
15:59:21 <hiptobecubic_> Maybe via hlist and type trickery or something?
15:59:23 <geekosaur> tuples are anonymous sum types. there's no common basis. there are ways to hack it in some cases with typeclasses, but usually you do not want to be using tuples in the first place
15:59:36 <glguy> anonymous product types*
15:59:49 <Squarism> like fkn :: (Int,a1, .. , aN) -> (SomeOtherType,a1, .. , aN) 
15:59:57 <geekosaur> sorry right I have the proposal for anon sums on my min
16:00:06 <geekosaur> also apparently my mind is stuck again :/
16:00:16 <glguy> Did you try turning it off and on again?
16:00:17 * grantwu applies WD-40 to geekosaur's mind
16:00:22 <lordcirth> geekosaur, why not use tuples?  Should we always make custom datatypes instead?
16:00:23 <jle`> Squarism: yeah, there isn't any abstraction like that for the native tuples in haskell
16:00:35 <jle`> Squarism: but you can get something for some custom tuple types
16:00:37 <Squarism> BUT I WANT THERE TO BE!!
16:00:38 <ContessaTP> What problem are you trying to solve Squarism? Maybe there's a way to reformulate it to avoid making a function of this form
16:00:38 <Koterpillar> Squarism: _1 lens?
16:00:40 <jle`> like 'hlists'
16:00:40 <Squarism> =d
16:00:42 <Squarism> =D
16:00:55 <hiptobecubic_> Although I think the better way to handle this is to figure out why you want to do this and then do it more betterer
16:00:59 <geekosaur> lordcirth, the main use for tuples is things like createProcess that need to return more than one thing. pretty much all other uses are better handled with specific types
16:01:34 <Squarism> ContessaTP, probebly.. this was my initial idea though
16:01:59 <hiptobecubic_> can't lenses do this, actually? What about composing _1 with whatever it is, ~% or something
16:02:26 <hiptobecubic_> then you write the function on integers and not "integers in the first position of a tuple" and just apply it as needed
16:02:34 <Koterpillar> I agree with what geekosaur said though, you don't need tuples
16:02:46 <jle`> yeah, lenses can do this, but the actual haskell mechanism that it uses is typeclasses
16:02:57 <jle`> _1 just uses a typeclass for things that have a "first field"
16:03:05 <glguy> and there aren't instance of Field1 for all 63 or so tuple types, just the first handfull
16:03:08 <jle`> and it provides instances for the standard tuples
16:03:10 <jle`> mhm
16:03:15 <hiptobecubic_> Sure, but not in an adhoc mess, which is undoubtedly where Squarism is coming from
16:03:18 <jle`> so it's as vanilla haskell as you can get for the most part
16:03:42 <glguy> Field1 is vanilla except for the 4-parameter typeclass with fundeps
16:03:49 <Squarism> hiptobecubic_, can you sense my spagetti over the internet?
16:03:57 <jle`> glguy: oh yeah, except that, heh
16:04:08 <hiptobecubic_> Squarism, I can see it peeking out of your pockets.
16:04:20 <Squarism> =D
16:04:22 <Gurkenglas> Squarism, maybe you want to look at _1 from lens
16:04:37 <hiptobecubic_> i don't think that's what they really want to do
16:04:55 <hiptobecubic_> I think they want to figure out what this function actually *means* and write that
16:05:10 <hiptobecubic_> with appropriate input types and output
16:05:19 <Gurkenglas> Oh wait you mentioned _1 already, nevermind then ._.
16:06:00 <Squarism> Gurkenglas, thanks.. but im really working in elm atm, and it comes with much of the core haskell ideas. If its not core, its not in there. Like it has uncurry1,2,3... 
16:06:18 <hiptobecubic_> Doesn't elm not have typeclasses at all?
16:06:40 <geekosaur> I thought recent elm had them, but maybe in a limited form
16:06:43 <Squarism> Correct, it hasnt
16:07:04 <jle`> we are all typeclasses deep inside
16:07:36 <hydPaz> There's still an open issue on the Elm repository regarding implementing typeclasses.
16:07:36 <buff3r> hah
16:10:02 <dmj`> jle`: sounds like an existential crisis
16:20:48 <Squarism> What about this: Lets say i have fkn1 :: Point -> X -> Y AND fkn2 :: Int -> Point. How can i compose those to arrive at fkn3 :: Int -> X -> Y ?
16:26:21 <geekosaur> you are probably better off doing that explicitly
16:26:58 <geekosaur> @pl \a x -> fn1 x (fn2 a)
16:26:59 <lambdabot> flip fn1 . fn2
16:27:12 <geekosaur> guess that's not *too* terrible...
16:27:59 <Squarism> oh ok
16:28:00 <augur> i quite love memotries and loeb spreadsheets
16:28:55 <geekosaur> actually I gt those reversed, I think
16:29:01 <geekosaur> @pl \a x -> fn1 (fn2 a) x
16:29:02 <lambdabot> fn1 . fn2
16:29:07 <geekosaur> ok, even better
16:29:20 <EvanR> augur: loeb sheets?
16:29:55 <Squarism> geekosaur, thanks 
16:30:01 <augur> EvanR: memoization via knot-tying, basically
16:30:05 <geekosaur> still, in general when composing with additional parameters to come later, many useful cases turn out to be really horrid to do with simple composition
16:30:32 <geekosaur> I rarely bother in those cases, just be explicit. if only because I have to figure out what it's doing again 6 months down the road >.>
16:30:52 <geekosaur> it does not pay to be too clever
16:31:09 <Squarism> geekosaur, im still at the stage i might havent learnt all the obvious tricks
16:31:41 <EvanR> augur: sounds pretty cool
16:32:00 <augur> EvanR: a canonical example:
16:32:06 <augur> fibs = [ f n | n <- [0..] ]
16:32:06 <augur>   where
16:32:06 <augur>     f 0 = 0
16:32:08 <augur>     f 1 = 1
16:32:10 <augur>     f n = fibs !! (n - 2) + fibs !! (n - 1)
16:32:11 <Squarism> good to know what is and not possible so to speak
16:32:36 <hpc> Squarism: obvious is obvious until suddenly it isn't ;)
16:33:08 <augur> EvanR: this relies crucially on the fact that haskell is lazy, notice :)
16:33:25 <geekosaur> also, obvious to whom? ekmett's obvious is not obvious to most other haskellers >.>
16:33:53 <augur> it's basically a way to build dynamic programming memo tables by taking advantage of laziness
16:34:12 <EvanR> that builds a regular list of fibs doesnt it
16:34:31 <EvanR> what is the gain
16:34:44 <Squarism> geekosaur, sadly, in this case my parameter list is sort of long so it feels a bit cumbersome to do this manually for something that looks "composable"
16:34:49 <hpc> it's defined in terms of itself, so you don't have that massive recomputation cost
16:35:02 <EvanR> but theres a few fibs like this floating around
16:35:26 <EvanR> i guess im wondering about a less trivial example ;)
16:35:36 <augur> EvanR: the gain is that you never recompute. notice that f n makes reference to the list, not to f
16:35:58 <augur> EvanR: also notice that f is defined, otherwise, like the inefficient definition of fib
16:36:00 <EvanR> oh, is the f accelerated
16:36:01 <glguy> Is The "gtk" package (and by proxy ThreadScope) abandoned? http://matrix.hackage.haskell.org/package/gtk
16:36:15 <EvanR> i was thrown off because you cant get to f from outside
16:36:25 <EvanR> so... whats the point
16:36:54 <augur> EvanR: there's a way to define a more general framework for this, tho, that makes it super cute
16:38:25 <geekosaur> glguy, that looks like the usual problems with the build tools
16:40:33 <geekosaur> more specifically you need to preinstall gtk2hs-buildtools; it can't be done as a dependency because there is currently no way to specify a Setup.hs dependency without some weird stuff
16:40:36 <EvanR> i have a question, im trying to define a 5x5 "multiplication table", and writing out the 25 cases is annoying
16:40:50 <EvanR> is there a way to display the table in a list and cause it to be "memoized" as a function
16:41:06 <geekosaur> I think the most recent (unreleased?) cabal has a hack, and cabal new-build has a better solution
16:41:39 <bob_twinkles> EvanR: there's always templatehaskell
16:41:46 <EvanR> noooo
16:41:49 <monochrom> yes, "f x y = (list !! x) !! y" is one way, using a list. you could also use an array, a vector, etc
16:41:51 <geekosaur> but there hasn't been a gtk2hs release incorporating the hack, and the hackage builder can't be told to preinstall a dep so it's there at Setup.hs time
16:41:52 <bob_twinkles> heh, figured =P
16:42:10 <EvanR> !! !!, thats not really memoizing is it
16:42:11 <hiptobecubic_> EvanR, monochrom if the point is to be fast, don't use nested lists
16:42:30 <hiptobecubic_> just make a map from (x :: Int, y :: Int) -> whatever
16:42:38 <monochrom> you could also use an array, a vector, etc
16:42:38 <EvanR> a vector probably makes sense
16:43:07 <augur> EvanR: in particular, you use this fun little combinator:   loeb fs = let xs = fmap ($ xs) fs in xs
16:43:40 <geekosaur> and cabal doesn't install deps before Setup.hs because one of the things Setup.hs can do is add dependencies
16:43:42 <hiptobecubic_> If you use array, you can do 2d indexing without any tricks i think
16:43:42 <augur> fs :: f (f a -> a)   is an f-structured collection of accessors -- that is, functions which, given some f a, will compute for you a value of the right type
16:44:10 <monochrom> you could use the Morton Z order for your 2D array
16:44:14 <augur> EvanR: the idea is, you have in each f position some accessor that can compute for you the value of that position, given the whole f structure of values (hence the knot tying)
16:44:49 <augur> its super cute
16:44:54 <geekosaur> this has been a topic of active discussion recently in #hackage btw
16:45:25 <hiptobecubic_> monochrom, the array knows its dims and will handle the indexing for you. No need to get fancy unless you're worried about locality
16:45:46 <monochrom> but we should always worry about locality
16:45:58 <monochrom> OK, maybe s/always/90% of the time/
16:47:01 <EvanR> for a 5x5 table... i wonder if anything matters ;)
16:47:09 <EvanR> or to what extent anything matters
16:47:31 <monochrom> well, often we prefer Data.Vector to Data.Array for more utilities and better performance. but then Data.Vector requires doing our own 2D->1D indexing.
16:47:58 <monochrom> yes, 5x5, it's why list is not too shabby
16:47:59 <EvanR> also my five elements are simple enum ctors
16:48:15 <EvanR> is fromEnum super high performance to get Ints
16:48:29 <monochrom> I don't know
16:49:06 <monochrom> but it looks like you can't escape from any translation from your ctors to numbers
16:49:10 <EvanR> i need the fastest possible multiplication table of all time monochrom, the fate of the universe depends on it
16:49:27 <monochrom> I don't know how to get the fastest possible
16:49:38 <monochrom> actually, I know. fab your own ASIC.
16:49:38 <EvanR> maybe a quantum computer
16:49:55 <EvanR> a right, combinational logic
16:50:00 <monochrom> and 2nd fastest: program your own FPGA
16:50:15 <monochrom> using Haskell at all comes down to about the 15th fastest.
16:50:49 <EvanR> it really makes you wonder with all the unknown advanced technology of the TNG enterprise computer, how fast could they honestly compute something as simple as a 5x5 multiplication table
16:51:25 <EvanR> or if they took the hit and used haskell for everything since its not worth it
16:51:59 <bob_twinkles> depending on on what you're doing an ASIC might be slower than doing the math on the CPU; there's always some latency involved in external communication
16:52:45 <EvanR> cpu does win out on latency... or does it since the more complex they get the more internally bureaucracy they have adding latency
16:52:48 <MarcelineVQ> you can also just guess, 1/25 chance ain't so bad
16:52:59 <hiptobecubic_> I still vote array
16:53:20 <hiptobecubic_> it will even handle the mapping of your ctors to ints behind the scenes for indexing
16:53:21 <EvanR> MarcelineVQ: i actually was going to take that seriously until i realized how do you pick a random 1 in 25...
16:53:23 <MarcelineVQ> in fact... lookup x = 5
16:53:28 <MarcelineVQ> could be the way to go
16:53:29 <EvanR> ah
16:53:34 <EvanR> thats the fastest one there
16:53:46 <hiptobecubic_> you can do     table ! (ctor1, ctor2)  and be good to go
16:53:59 <monochrom> I heard that the new CPUs are programmable too.
16:54:05 <hiptobecubic_> lookup = const 5 also works :)
16:54:41 <EvanR> ill go with list due to the performance cost of my importing and remembering Array
16:55:05 <hiptobecubic_> Run an apache lambda and do jsonrpcs 
16:55:35 <monochrom> program a raspberry pi to do the multiplication. connect it to your PC by USB.
16:55:58 <monochrom> (enterprise wisdom: outsource it)
16:56:05 <hiptobecubic_> It has perfectly good gpio pins
16:56:19 <glguy> geekosaur: I'll have to check my gtk2hs executable, but I was getting a type error during compilation in Haskell code
16:56:55 <EvanR> which i already did (way before internet died) works
16:57:07 <EvanR> time for quickcheck
17:03:07 <hodapp> hmmmmm. Do people have a preferred library for spinning up a simple web UI?
17:03:33 <hodapp> I haven't used servant enough to know if it handles matters like this well
17:05:07 <buff3r> hodapp: servant is for rest apis 
17:05:34 <hodapp> that's sort of the idea that I had, but wasn't certain if it was *just* REST APIs
17:05:45 <buff3r> ah gotcha
17:05:55 <hodapp> a REST API is overkill for what I'm going for now
17:05:58 <Koterpillar> it can make JS bindings for its APIs
17:06:01 <Koterpillar> but not an UI
17:06:02 <buff3r> hodapp: elm is pretty popular right now
17:06:14 <buff3r> for UIs..it is haskell-inspired
17:09:40 <redmq> i want to see a monad transformer stack that lets you writes frontend and backend code in the same codebase, as though you're just calling functions.. 
17:09:50 <hodapp> ack! I totally forgot about Yesod
17:10:04 <EvanR> redmq: so theres reflex-dom
17:11:12 <buff3r> that'd be interesting
17:11:42 <redmq> EvanR: reading ... https://obsidian.systems/reflex-nyhug/#/step-21
17:12:17 <hodapp> I'm reading https://wiki.haskell.org/Web/Frameworks...
17:13:22 <hodapp> maybe one of these frameworks will make me not hate web programming. maybe.
17:14:57 <EvanR> redmq: also ask Cale, who has something like what youre saying built and running
17:15:10 <EvanR> hodapp: unlikely
17:15:43 <hodapp> I'm considering using Haskell for some of the scripting crap I'm doing now in Python, and throwing a web UI on top of that (it's an application where security is kind of a joke anyhow)
17:15:55 <hodapp> haven't ever done scripting in Haskell, though I know things like Shelly and Turtle exist
17:16:41 <EvanR> how do we write posets in haskell, lte :: A -> A -> Maybe Bool ?
17:18:31 <Myrl-saki> EvanR: i'm starting to think that I should not write the game physics in FRP.
17:18:38 <redmq> EvanR: reflex-dom is pretty awesome.
17:18:48 <monochrom> I think you don't need the Maybe there
17:19:06 <redmq> it's not backend too, though, as far as i could tell 
17:19:18 <monochrom> if x,y are incomparable then you can just have both "lte x y" and "lte y x" being False.
17:19:50 <Myrl-saki> monochrom: I disagree.
17:19:52 <monochrom> it is "compare" that would need Maybe Bool
17:20:08 <EvanR> hurh
17:20:10 <monochrom> err no, it is "compare" that would need Maybe (LT | GT | EQ)
17:20:18 <EvanR> ah compare
17:20:45 <EvanR> redmq: like i said ask Cale, they have backend too
17:21:10 <redmq> Cale: boo ^
17:23:37 <hiptobecubic_> EvanR, how do you decide if things are comparable?
17:23:46 <hiptobecubic_> Can it be done before attempting the actual comparison?
17:24:41 <lordcirth> hiptobecubic_, well the function should have (Ord a) => etc type
17:24:46 <hiptobecubic_> Although it sounds kind of like just regular Ordering would work
17:24:59 <lordcirth> oh, nvrm
17:25:10 <hiptobecubic_> Things are not uncomparable, they are just neither greater than nor less than some other things, no?
17:25:47 <lordcirth> hiptobecubic_, he's talking about partially-ordered sets, where, if I understand correctly, they can be incomparable in some sense.
17:25:50 <hiptobecubic_> So modulo this thing, Eq just means they are in the same spot in the ladder
17:26:19 <EvanR> its EQ, GT, LT, or not comparable
17:26:20 <hiptobecubic_> So suppose you have some diamond like   A < (B|C) < D
17:26:36 <hiptobecubic_> Is B really not equal to C there?
17:26:40 <EvanR> there not in the same spot on a ladder, but in different branches yes
17:26:50 <monochrom> B is really not equal to C there.
17:27:05 <EvanR> you can say they are on different ladders
17:27:16 <monochrom> check that this is compatible with partial order axioms.
17:27:22 <lordcirth> EvanR, so you're using Maybe Ordering to represent this>
17:27:23 <lordcirth> ?*
17:27:23 <lambdabot> Maybe you meant: v @ ? .
17:27:23 <hiptobecubic_> So perhaps just define your own POrd class
17:27:29 <EvanR> lordcirth: well, i am now
17:27:41 <EvanR> i was asking what youd do
17:27:43 <hiptobecubic_> or go with Maybe Ordering
17:28:03 <EvanR> like is it even useful
17:28:04 <lordcirth> a POrd seems a bit cleaner. Both work tho
17:28:31 <EvanR> as prevalent as posets are in haskell lore
17:28:32 <hiptobecubic_> Well the problem with POrd is that it can't have an Enum instance anymore
17:28:44 <hiptobecubic_> or not a sensible one
17:28:53 <EvanR> i have an enum instance, but it doesnt have anything to do with the ordering
17:29:41 <hiptobecubic_> not for your type, for the new Ordering type that includes "can't do no orderin'"
17:29:48 <hiptobecubic_> So really, don't do that. Just use maybe
17:30:02 <hiptobecubic_> Maybe seems most sensible to me
17:30:09 <EvanR> you could say Enum only implies that the values are enumerable in some way
17:30:53 <EvanR> the question is what Bounded means
17:31:03 <hiptobecubic_> Enum doesn't imply Ord some how? You have succ and pred
17:31:27 <EvanR> nope
17:31:28 <hiptobecubic_> I guess it doesn't technically, but it feels like it does
17:31:42 <EvanR> it implies some ordering, the order of the image of the numbers
17:31:49 <EvanR> but
17:32:13 <hiptobecubic_> I'm saying it provides a mapping from values to ints and ints have ord
17:32:19 <EvanR> yes
17:32:34 <EvanR> now Bounded really does mingle with Ord
17:32:39 <EvanR> morally
17:32:46 <hiptobecubic_> so it's weird not to have that be a ... what's the word... isomorphism? natural zygomorphimation?
17:33:13 <Axman6> cocontrazygometamorphad
17:33:20 * hiptobecubic_ got his Haskell degree from a mail order catalog
17:33:52 <EvanR> hiptobecubic_: imagine you had a lattice of regions which may or may not be contained in each other, and its finite or countably infinite in size, then you could number them, but however you do it, that wouldnt play nice with this containment ordering
17:34:25 <EvanR> it necessarily looks like a random connect the dots coloring book
18:06:19 <pikajude> on my machine, round (1/0) comes out to a 309-digit number in ghci. what rules govern what number it is?
18:07:57 <pikajude> oh, it's max double + 1
18:09:30 <pikajude> why isn't Double Bounded?
18:12:52 <c_wraith> I have lots of questions about instances for Double.
18:13:26 <c_wraith> Though I can at least understand why that instance is missing.  is maxBound the maximum finite value, or positive infinity?
18:13:34 <pikajude> one of those two!
18:13:39 <geekosaur> yeh, I;'d think Inf is the reason
18:13:43 <ania123> succ x = x + 1
18:13:44 <pikajude> one could argue Infinity doesn't really count as a bound
18:14:02 <ania123> here x is a pattern?
18:14:07 <c_wraith> > (1/0) - 1
18:14:09 <lambdabot>  Infinity
18:14:21 <jle`> if positive and negative infinity work, then the Monoid instance for Max would work :)
18:14:27 <pikajude> > fromIntegral (round (1/0) - 1)
18:14:30 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
18:14:35 <ania123> succ x = x + 1
18:14:36 <jle`> s/infinity work/infinity are the bounds
18:14:39 <ania123> here x is a pattern?
18:14:43 <jle`> mhm
18:14:46 <EvanR> if Bounded has laws, then NaN breaks those laws
18:14:47 <c_wraith> ania123: It's a pattern that matches anything
18:14:48 <jle`> it's a pattern that matches all
18:14:53 <geekosaur> ania123, all parameters are patterns. here it is a pattern with a specific type, and that limits what it can be
18:15:09 <geekosaur> but within the constraints of the type, it matches any value
18:15:17 <jle`> > foldMap Max [1,9,3,10] :: Max Double
18:15:20 <lambdabot>  error:
18:15:20 <lambdabot>      Not in scope: type constructor or class ‘Max’
18:15:20 <lambdabot>      Perhaps you meant ‘M.Map’ (imported from Data.Map)
18:15:21 <ania123> x can match with any data, if we are in untype setting
18:15:21 <EvanR> if Bounded ha no laws, why do we even care the instance is missing ;)
18:15:22 <ania123> ok?
18:15:34 <jle`> ania123: x matches any validly typed input, of course
18:15:46 <jle`> @let import Data.Semigroup
18:15:48 <lambdabot>  Defined.
18:15:50 <jle`> > foldMap Max [1,9,3,10] :: Max Double
18:15:53 <lambdabot>  error:
18:15:53 <lambdabot>      • No instance for (Bounded Double) arising from a use of ‘foldMap’
18:15:53 <lambdabot>      • In the expression: foldMap Max [1, 9, 3, ....] :: Max Double
18:15:55 <c_wraith> My biggest problems with instances for Double are the Enum instance.  I think the existing instance is basically useless.
18:15:57 <jle`> > foldMap Max [1,9,3,10] :: Max Integer
18:15:59 <lambdabot>  error:
18:15:59 <lambdabot>      • No instance for (Bounded Integer) arising from a use of ‘foldMap’
18:15:59 <lambdabot>      • In the expression: foldMap Max [1, 9, 3, ....] :: Max Integer
18:16:02 <jle`> > foldMap Max [1,9,3,10] :: Max Int
18:16:05 <lambdabot>  Max {getMax = 10}
18:16:05 <jle`> sorry
18:16:07 <jle`> yay
18:16:35 <jle`> foldMap Max should work for Double if onyl Double was Bounded w/ negative and positive infinity
18:16:43 <ania123> conceptually, how it wirks? when i want to cumpute succ 5, the compiler tries to solve a matching problem succ x << succ 5 which returns matcher x-->5
18:16:52 <ania123> does it works in this way?
18:17:02 <ania123> like inference in prolog?
18:17:03 <c_wraith> ania123: it's a pattern that matches anything, so matching it does no work.
18:17:13 <c_wraith> ania123: it just assigns a name to the value
18:17:32 <jle`> ania123: succ = (\x -> x + 1), so succ 1 = (\x -> x + 1) 10 = 10 + 1 = 11
18:17:50 <jle`> ania123: if you see 'succ x' anywhere, you can just "replace" it with "x + 1"
18:17:52 <c_wraith> ania123: the pattern has to have constructors in it for pattern-matching to do something.  (Or the special cases for Strings, Characters, and numeric types)
18:18:27 <jle`> @let instance Bounded Double where minBound = -1/0; maxBound = 1/0
18:18:28 <lambdabot>  Defined.
18:18:30 <ania123> do you know prolog?
18:18:35 <c_wraith> ania123: it's a far more mechanical process than anything in prolog.
18:18:37 <jle`> > foldMap Max [1,8,3,10] :: Max Double
18:18:39 <lambdabot>  Max {getMax = 10.0}
18:18:40 <c_wraith> ania123: it just matches structurally.
18:18:48 <c_wraith> ania123: it doesn't do any logic or backtracking
18:18:58 <ania123> in prolog
18:19:08 <c_wraith> it's not like prolog
18:19:12 <geekosaur> haskell is not prolog
18:19:34 <ania123> ok
18:19:37 <ania123> thx :)
18:19:38 <jle`> there is very little in common between haskell and prolog
18:20:05 <c_wraith> haskell's *type* system acts somewhat like prolog, sometimes.
18:20:07 <jle`> besides maybe that you edit both in a text editor of some sort
18:20:07 <ania123> neg False = True
18:20:15 <ania123> here False is a pattern
18:20:18 <ania123> is not?
18:20:31 <jle`> yes, it's a pattern that binds no variables
18:20:33 <c_wraith> > let f (x:xs) = f x in f []
18:20:36 <lambdabot>  error:
18:20:36 <lambdabot>      • Occurs check: cannot construct the infinite type: t1 ~ [t1]
18:20:36 <lambdabot>        Expected type: t1 -> t2
18:20:45 <c_wraith> "Occurs check" should remind you of prolog
18:20:54 <ania123> False is a pattern or neg False is a pattern?
18:21:01 <ania123> which ine is pattern?
18:21:05 <ania123> False
18:21:06 <ania123> ?
18:21:12 <ania123> neg False?
18:21:18 <jle`> False is the pattern
18:21:24 <ania123> ok
18:21:28 <ania123> is True pattern
18:21:28 <ania123> ?
18:21:36 <ania123> neg False = True
18:21:41 <jle`> no
18:21:41 <ania123> here is True pattern?
18:21:47 <ania123> aha
18:21:57 <ania123> so, pattern is just argument of a function
18:22:26 <jle`> ania123: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
18:22:32 <geekosaur> simple irrefutable patterns are
18:22:45 <geekosaur> more complex patterns, well, in a sense they also are, but they're also more
18:22:48 <geekosaur> foo x = ...
18:22:54 <jle`> you can think of it as syntactic sugar for
18:23:00 <jle`> neg x = case x of False -> ...; True -> ...
18:23:33 <geekosaur> foo (MyA _ (MyB x (Just (MyC {x = foo})))) = ... -- complex pattern, still 1 argument
18:23:40 <jle`> patterns in haskell are a way of binding variables and inspecting constructors
18:24:01 <jle`> > [ x + y | (x,y) <- [(1,2),(3,4),(5,6)] ]
18:24:04 <lambdabot>  [3,7,11]
18:24:27 <jle`> here we use the pattern (x,y) to match on the values (1,2), (3,4), and (5,6), in order to get 1 and 2, 3 and 4, and 5 and 6 out of them each
18:24:45 <jle`> > let f (x,y) = x + y in f (10,4)
18:24:47 <lambdabot>  14
18:24:53 <jle`> there the (x,y) pattern is used to get 10 and 4 out of (10,4)
18:25:07 <jle`> and also it confirms that the (,) constructor was used
18:25:28 <jle`> that part is a bit redundant because (,) is the only "non-bottom" constructor that something of type (Int,Int) can have
18:25:39 <jle`> but if there were other constructors for (Int,Int), pattern amtching can be used to distinguish them
18:26:48 <jle`> when you go more into haskell you find that there are there values of (Int,Int) that aren't created using the (,) constructor, so you can even think of pattern matching as distinguishing between those, too :)
18:27:57 <jle`> in the case of your 'neg' example, you're using pattern matching to distinguish between the two main constructors of Bool, False and True.  so if you have a value of type Bool, it was created using either the True or the False constructor, and patterns let you distinguish which
18:28:06 <Cale> EvanR: The only reflex backend stuff which exists thus far is basically server-side rendering of your frontend, so you can send a static version of the page, and have it become live once the client has actually loaded the JS
18:28:42 <Cale> We've mostly been getting by with Snap and websockets.
18:29:08 <Cale> (though the logic on the backend is now getting quite complicated, and I'd really like to start putting reflex to use there)
18:32:17 <ania123> jle`: thx
18:39:07 <jasonkuhrt> Hi, would someone be willing to help me refactor my FromJSON instance? https://gist.github.com/jasonkuhrt/1b378eca6433b8d7c9d06c359869d269. This is my first time working with Aeson/Parser/Lens and I think my current solution regarding the validation could be a lot better.
18:50:24 <EvanR> can i test that a quickCheck test should fail
18:50:45 <EvanR> i guesss it might not find the arbitrary values on which it fails
18:52:45 <lordcirth> EvanR, you could write a fuzzer?
18:54:21 <EvanR> a who
18:54:29 <grantwu> a fuzzer.
18:54:35 <grantwu> A fuzzy animal like a cat
18:54:48 <EvanR> o
18:54:50 <EvanR> o_O
18:54:58 <grantwu> it rubs you, making you feel better, making you find bugs
18:55:00 <Cale> lordcirth: That's... that's what QuickCheck is...
18:55:24 <lordcirth> Ah
18:55:25 <grantwu> No, a fuzzer is just something that generates random inputs and checks if something fails
18:55:36 <Cale> expectFailure :: Testable prop => prop -> Property
18:55:38 <grantwu> I think some fuzzers are smarter though
18:55:49 <EvanR> i see it now
18:56:01 <Cale> QuickCheck generates random inputs and checks if something fails...
18:56:03 <lordcirth> Yeah, many try things like the max bound, min, negative, etc
18:56:14 <grantwu> Like, I don't think QuickCheck can do the thing that AFL does where it attempts to search through all the control flow paths with genetic programminng
18:56:26 <lordcirth> grantwu, AFL? That's pretty cool!
18:56:38 <grantwu> http://lcamtuf.coredump.cx/afl/
18:56:51 <EvanR> awesome
18:57:11 <EvanR> lordcirth: correct... quickcheck can do that
18:57:12 <grantwu> lordcirth: Yeah, this was *really* impressive: https://lcamtuf.blogspot.com/2014/11/pulling-jpegs-out-of-thin-air.html
18:57:20 <Cale> No, it doesn't do anything like that. It just constructs random inputs of increasing size until it finds something that fails, and then it tries to shrink that input via a bunch of ad-hoc rules
18:57:53 <EvanR> oh uh, whats this shrink thing
19:02:00 <Cale> EvanR: When QuickCheck finds a counterexample, it tries to simplify it for you -- the instances of Arbitrary can define a function which takes some value and produces a list of potential shrinks
19:02:19 <Cale> EvanR: and it'll try those and see if it can find one which also fails the test
19:02:27 <Cale> (and if so, it'll recursively try again)
19:03:49 <EvanR> so the faiing test is simpler
19:03:55 <EvanR> the failing case
19:03:59 <EvanR> is more digestible
19:10:21 <x1f577> How can I turn a 'Digest a' from cryptonite/cryptohash into an ASCII string?
19:10:22 <Cale> Yeah, the hope is that you can look at what it failed on and have some idea of what actually went wrong
19:14:10 <Cale> x1f577: I think you'll have to use the fact that it's an instance of ByteArrayAccess. There's a function 'convert' which looks like it'd do the trick.
19:14:24 <Cale> x1f577: You could use that to get a ByteString
19:16:36 <x1f577> Cale: i must have missed that function..
19:16:38 <x1f577> thank you
19:16:41 <Cale> (and then if it needs to be ASCII, I suppose you could base64 encode that)
19:20:56 <x1f577> Cale: got it. it works, thanks
19:27:52 * hackagebot HsOpenSSL 0.11.2.3 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.2.3 (VladimirShabanov)
19:27:54 * hackagebot separated 0.1.2 - A data type with elements separated by values  https://hackage.haskell.org/package/separated-0.1.2 (TonyMorris)
19:35:47 <ania123> it is bit strange that haskell allows only linear patterns, is not?
19:47:47 <Cale> Some rationale for this is described in SPJ's book "The Implementation of Functional Programming Languages"
19:48:00 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
19:49:14 <grantwu> What is a linear pattern?
19:49:34 <Cale> See "4.2.7 Repeated Variables"
19:49:49 <Cale> A linear pattern is one in which any variable to be bound may occur at most once.
19:50:58 <ania123> Cale, why is such restrictions in haskell?
19:51:45 <ania123> ah, you gave me link.. is there any practicale reason? any example?
19:51:58 <grantwu> There might be one in the link
19:52:05 <Cale> He gives an example there of how the interaction with lazy evaluation can be a bit weird
19:52:13 <grantwu> However the book is yuuuuge (41MB for the PDF) so I can't tell you atm
19:52:20 <Cale> The DJVU is smaller
19:52:29 <ania123> ok :)
19:52:40 <grantwu> Okay but then I need a djvu viewer
19:52:59 * geekosaur knows that regexes with backreferences are harder to deal with than those without (this is roughly equivalent)
19:53:00 <ania123> grantwu: you should have it :)
19:53:03 <Cale> He gives the example of
19:53:08 <Cale> nasty x x True = 1
19:53:11 <Cale> nasty x y z = 2
19:53:49 <Cale> You might think that if we apply  nasty bottom 3 False, this would result in nontermination, since we have to compare bottom with 3
19:54:23 <Cale> However, if we compiled this definition by transforming it to use a conditional equation:
19:54:35 <Cale> nasty' x y True | x == y = 1
19:54:40 <Cale> nasty' x y z = 2
19:54:58 <Cale> Then the bottom doesn't get evaluated any longer.
19:55:16 <Cale> and then there's stuff like
19:55:20 <Cale> multi p q q p = 1
19:55:26 <Cale> multi p q r s = 2
19:55:44 <Cale> Do we compare the first and 4th arguments first, or the second and third?
19:56:02 <Cale> It's important to have some convention, because it affects termination behaviour
19:56:10 <Cale> But the convention seems a bit arbitrary.
19:59:13 <tswett> I'm wondering what GADTs correspond to in category theory.
19:59:16 <tswett> Consider this GADT:
19:59:18 <Cale> So I suppose the original Haskell committee also decided to sidestep those issues by only having linear patterns (unlike in Miranda)
19:59:29 <tswett> data MyInteger where MakeMyInteger :: Integer -> MyInteger
19:59:30 <Cale> and nobody complained enough for an extension to GHC to ever happen :)
20:00:03 <Cale> That isn't actually a GADT
20:00:19 <tswett> It's not? I must be forgetting something.
20:00:39 <geekosaur> it's gadt syntax, but it has no need for an embedded existential
20:00:40 <Cale> It's using the GADT notation, but it's not defining any data constructors which specialise type arguments
20:01:00 <tswett> Ah. So it's a valid GADT; you're just saying that it could be written as an ordinary ADT. Right?
20:01:05 <Cale> yeah
20:01:05 <geekosaur> yes
20:01:12 <tswett> So, I see two categories and two diagrams there.
20:01:40 <tswett> There's the category of external objects used in the GADT. That has only one object, which is Integer.
20:01:46 <EvanR> i heard non linear patterns were considered harmful
20:02:35 <tswett> There's the category of all objects used in the GADT, with arrows being the data constructors. There are two objects there (Integer and MyInteger) and one non-identity arrow (MakeMyInteger :: Integer -> MyInteger).
20:02:48 <tswett> Um... call that first category E, and that second category G.
20:03:06 <tswett> There's the diagram of E in G, where we specify that "Integer" in E corresponds to "Integer" in G.
20:03:19 <tswett> And there's the diagram of E in Hask, where we specify that "Integer" in E corresponds to "Integer" in G.
20:03:57 <Cale> http://www.cl.cam.ac.uk/~mpf23/papers/Types/gadtif.pdf
20:04:19 <tswett> What the GADT gives us, then, is a diagram of G in Hask, which commutes with the other two diagrams, and such that...
20:04:28 <tswett> Lemme take a look at that.
20:04:42 <Cale> looks relevant, but I haven't actually read it
20:20:01 <tswett> Cale: well, I looked through the paper.
20:20:57 <tswett> I'm not sure whether that's what I'm after or not. I'd have to do some more studying.
20:21:09 <tswett> Thanks for the link.
20:24:43 <Cale> tswett: Yeah, I dunno. You might also want to have a look at stuff on how inductive families get translated into category theory. https://ncatlab.org/nlab/show/inductive+family has a bunch of references
20:25:06 <Cale> I'd expect GADTs to be treated rather similarly -- they're pretty much inductive families which are indexed over a universe of types
20:26:28 <Cale> (But I don't understand it well enough myself to attempt to give a coherent explanation :)
20:39:46 <tswett> My goal here is to try to figure out how to extend the concept of a natural numbers object in two ways.
20:40:27 <tswett> First, to extend it to other inductive datatypes besides natural numbers. So, also a "booleans object", a "lists of natural numbers object", a "binary trees object", and so on.
20:41:16 <tswett> And second, to see how the same generalization applies to "parameterized natural numbers objects" as defined here: https://ncatlab.org/nlab/show/natural+numbers+object
20:42:02 <tswett> The neat thing about "parameterized natural numbers objects" is that they let you construct primitive recursive functions.
20:42:31 <tswett> I want to figure out how to extend the same construction to primitive recursive functions over other datatypes.
21:18:17 <tswett> Here's a tangential question.
21:18:32 <tswett> This blog post talks about the Kan extension type constructors Ran and Lan: http://comonad.com/reader/2008/kan-extensions/
21:19:03 <tswett> Are there easy examples, like how to define Maybe or [] as Kan extensions?
21:26:53 <tswett> What prompts everything I've said today is that I noticed that the data required for specifying a GADT is similar to the data required for specifying a Kan extension.
21:27:44 <tswett> And that you get something similar out.
21:29:10 <tswett> With a Kan extension, you specify three categories A, B, and C, and two functors X : A -> C and F : A -> B, and you get a functor R or L : B -> C, and a natural transformation.
21:30:02 <tswett> Likewise, with a GADT, you specify two categories A and B (the category C is always Hask) and two functors X : A -> C and F : A -> B, and you get a functor B -> C.
21:30:40 <tswett> But if a GADT were just a Kan extension in the obvious way, then this would be a legal GADT:
21:30:51 <tswett> data MyType where MyConstructor : MyType -> Integer
21:32:19 <EvanR> "being a kan extension in the obvious way"
21:32:30 <EvanR> yep
21:33:34 <EvanR> tswett: for completeness sake, where to where does that natural transformation go
21:34:18 <tswett> EvanR: in the case of GADTs? I don't know if GADTs give you a natural transformation or anything similar.
21:34:31 <EvanR> in the summarized version of kan extensions
21:34:46 <EvanR> from R to something
21:34:55 <EvanR> or
21:35:23 <tswett> Ah. It goes from RF to X if it's a right Kan extension; from X to LF if it's a left Kan extension.
21:57:30 <EvanR> what is this notation {F,G}
22:58:36 <sshine> tswett, thanks for the link. kmett surely writes in a comprehensible way.
23:05:00 <jle`> i like how stack lets me compile old projects without worrying
23:05:06 <jle`> thank you stack
23:06:01 <jle`> stack++
23:06:44 <mgsloan> :D Yay stack!  Down with mutable state!
23:07:07 <sshine> or as they say, modify (+1)
23:07:48 <mgsloan> Well, I'll allow karma to mutate, that is quite fine ^_^
23:08:47 <sshine> I always thought karma was fixed.
23:09:03 <mgsloan> Only if you believe in predestination!
23:15:55 * hvr likes how he can accomplish that with cabal since version 1.20
23:17:25 <jle`> hvr: bravo to cabal team too :)
23:21:30 <piyush-kurur> jle: stack and cabal, as far as I see it has two purposes.
23:22:03 <piyush-kurur> stack is like debian releases (although more frequent) and cabal is like arch linux
23:22:41 <piyush-kurur> you can get some of stacks pinning by just putting in the appropriate constraints in a cabal.config file
23:23:17 <piyush-kurur> but yes stack is easier to use as it can also install the appropriate ghc version and stuff like that
23:27:31 <srhb> piyush-kurur: Depends on your use case. And I think you meant "Stackage lts" is like Debian releases. :)
23:27:56 * hackagebot hookup 0.1.0.0 - Abstraction over creating network connections with SOCKS5 and TLS  https://hackage.haskell.org/package/hookup-0.1.0.0 (EricMertens)
23:29:48 <mgsloan> hvr: Sure, you can achieve it, but how hard is it to achieve?
23:29:52 <mgsloan> It is certainly not the default
23:30:11 <hvr> and it definitely shouldn't be the default!
23:30:20 <mgsloan> Well, on that we disagree.
23:30:27 <mgsloan> I prefer reliability to be a default.
23:30:29 <hvr> yeah, and that's why there's cabal and stack :)
23:30:33 <mgsloan> Yup!
23:31:05 <hvr> one is more powerful, and the other one is more enterprisey/reproducible
23:31:20 <mgsloan> Haha, I like how you use the term enterprisey
23:31:32 <mgsloan> Why do you think it is enterprisey? I don't see any FactoryFactories in our codebase
23:31:41 <srhb> mgsloan: :P
23:31:55 <mgsloan> One is "powerful", whereas the other comes with a swiss army knife of everything you need to do haskell dev
23:32:20 <srhb> I don't know if it feels enterprisey to me. I'm scared that it's causing lock-in, at least if people aren't aware that some of us do prefer other solutions over Stack. :)
23:32:32 <mgsloan> I think you would really like stack if you tempered your philosophical hard-lining
23:32:34 <srhb> I think it's a great tool that many people enjoy, mind. I'm just terrified by the echo chamber.
23:32:50 <srhb> mgsloan: Me or hvr?
23:32:57 <mgsloan> hvr!
23:33:01 <hvr> mgsloan: heh, by enterprisey I mean the UI focus of what I'd expect enterprise users to want; which I'd expect a curated LTS by default to be
23:33:04 <srhb> Ok :)
23:33:25 <mgsloan> srhb: Understandable.  We are not trying to create lock-in.  I would rather be locked in to a tool I can understand and help people with
23:33:34 <mgsloan> With Cabal, there's no telling what is going on in someone's environment
23:33:37 <mgsloan> So it is very hard to help them
23:33:52 <hvr> mgsloan: and by powerful I mean the more general flexible solver-centric design space cabal is exploring
23:33:54 <srhb> mgsloan: My issue is that making Stack and Nix work together is... Not easy.
23:34:02 <srhb> mgsloan: While cabal-install works very well with nix :)
23:34:06 <mgsloan> hvr: Sure, and we wrap Cabal's solver so that you can use it at the right times
23:34:25 <hvr> we just disagree what "the right times" are :)
23:34:38 <mgsloan> srhb: I see, you should give us bug reports.  I think it is because nix-pkgs was following stackage, and then they decided that was not the way forward
23:34:49 <mgsloan> hvr: Right, I don't like my packages moving out from under me all the time while developing
23:34:58 <srhb> mgsloan: I might re-issue some, the previous ones were basically closed wontfix
23:34:58 <mgsloan> I prefer to make conscious decisions about package versions
23:35:06 <srhb> I do hope one day it becomes a common frontend :)
23:35:13 <srhb> That would be a niche I could see Stack shine in.
23:35:22 <mgsloan> srhb: Oh, sorry about that, we'd love to have great nix support
23:35:26 <hvr> mgsloan: for that you have now 2 freezing levels with cabal; either full freeze or just index-state freeze (or both)
23:35:29 <mgsloan> We have quite a bit of nix specific code
23:35:30 <srhb> mgsloan: That's good to hear!
23:35:37 <mgsloan> hvr: Ok, but how do you tell your users to do that?
23:35:45 <mgsloan> "Read the docs" doesn't work so well for cabal
23:36:04 <hvr> mgsloan: well, by extending cabal's UI to give more hints
23:36:29 <mgsloan> Yes, that is a successful approach that stack has taken - always give users next steps and advise when needed, directly in the output
23:36:40 <mgsloan> People really like it when their tool works with them
23:36:41 <hvr> mgsloan: if cabal were to not use solving by default, we'd run into the problem that people would care even less about version constraints
23:36:57 <hvr> mgsloan: since everything would just work with stackage, so why bother with version ranges
23:37:26 <mgsloan> So basically, you're telling me we should put up with our tools causing problems for us all the time..?  So that we feel that whip of cabal hell, and update our version ranges by hand?
23:37:29 <hvr> which in turn would also make 'stack solver' useless
23:37:40 <mgsloan> Because to me that is an insane thing to ask of hobbyists and industry developers alike
23:37:55 <mgsloan> I think this PVP discipline is a negative meme within the community
23:38:02 <mgsloan> We need automation not punishment -_-
23:38:09 <hvr> mgsloan: those problems are only cuased by those who actively fight the PVP
23:38:25 <mgsloan> LOL, more like people that don't care about it as much as you
23:38:25 <hvr> mgsloan: I'm not talking about punishment, I'm talking about incentive
23:38:34 <mgsloan> Cabal hell is certainly punishment
23:38:59 <mgsloan> If your package system relies on cultural incentives to work properly, then it is fundamentally broken.
23:39:02 <hvr> mgsloan: inflicted by one set of people on other innocent users
23:39:16 <mgsloan> Cabal hell came way before stack, it's been there from day 1
23:39:27 <hvr> mgsloan: well, so you're suggesting a police state which enforces those rules?
23:39:41 <mgsloan> The experiment doesn't seem to be working, so we have an alternative experiment
23:39:47 <mgsloan> Which people seem to really really appreciate
23:40:06 <hvr> mgsloan: the experiment isn't done yet; the situation is improving with cabal, you just don't seem to notice
23:40:08 <mgsloan> I am suggesting that you are attempting to enforce a police state on packages
23:40:31 <hvr> mgsloan: where am I doing it? :-)
23:40:33 <mgsloan> The situation is improving, I just don't care, because it seems like more of the same.  I do watch the repo
23:41:33 <mgsloan> Ok, I will dig up some links, brb
23:41:35 <hvr> mgsloan: we're not rejecting packages on hackage which don't follow the PVP
23:42:05 <hvr> (that would imho be enforcing if we did)
23:42:08 <mgsloan> You created a gnarly PVP battle on my announcement of the store package, which I was quite proud of
23:42:11 <mgsloan> https://www.reddit.com/r/haskell/comments/4l3y9f/store_a_new_and_efficient_binary_serialization/d3k7aqe
23:42:34 <mgsloan> (I was proud of the package, not the battle)
23:42:40 <hvr> mgsloan: sorry for that; I was frustrated at the time about another incident
23:42:42 <mgsloan> It sucked to have the attention needlessly diverted to PVP
23:42:48 <mgsloan> Instead of my package
23:42:48 <piyush-kurur> oh god: I hope I did not start a holy war. I like both stack and cabal and no this is not a general policitically correct statement
23:43:07 <mgsloan> That is ok piyush-kurur, I think it is healthy to have this discussion
23:43:27 <piyush-kurur> i really mean it. stack and cabal are both useful. I find both of them useful.
23:43:30 <mgsloan> I think hvr and I are both relatively calm about this and both interested in Haskell being the best thing around
23:43:48 <hvr> there's just different ways to rome
23:43:54 <mgsloan> hvr: That is ok, it is not a big deal! :)
23:44:09 <cocreature> I’m pretty happy that we have both stack & cabal. I regularly switch between them depending on which one is best for my particular usecase
23:44:30 <mgsloan> cocreature: Is it possible that "stack solver" can help with that? :D
23:44:40 <mgsloan> Uses cabal-install for dep solving :D
23:44:42 <hvr> I'm quite positive that a pure stackage way would work out too, but with totally different tradeoffs
23:44:46 <piyush-kurur> as a developer when doing travis builds for example I find cabal more useful for the reasons hvr said
23:44:56 <piyush-kurur> as a deployer I would like stack instead
23:45:31 <cocreature> mgsloan: sort of but when I want solving I usually find cabal easier to use. also uploading docs is a usecase that is simply not possible with stack at all so I _have_ to use cabal for this
23:45:37 <hvr> otoh, pure cabal solving works out just as well; I almost never run into cabal hell myself
23:46:14 <hvr> and there's little traffic on the  hackage-trustees issue tracker, so ppl can't have that many cabal hell issues
23:46:28 <cocreature> annoyingly cabal new-build also doesn’t support building & uploading docs so I have to use regular sandboxes
23:46:39 <piyush-kurur> hvr: I did not mean that cabal cannot be used as a deployer. I just meant it is easiest to use stack (some one else has done the curating for me)
23:46:50 <mgsloan> cocreature: Interesting, thanks for the feedback!  We certainly have plans for doc upload.  Still lots of things to do for stack
23:46:54 <hvr> cocreature: yeah, 'new-haddock' is desperatey needed to complete that upload-docs-by-default thingie
23:47:14 <mgsloan> hvr: Is it possible that the lack of traffic is from people using stack?  Honest question
23:47:49 <hvr> mgsloan: hard to tell... I still see lots of cabal-install traffic in hackage's logs (and not from the travis cluster)
23:48:01 <cocreature> mgsloan: well the last time I asked if the person that has assigned the doc upload to themselves has any intention on working on it soon or if it’s up for grabs I have been ignored. (I don’t have time right now anyway to implement it but at that point I had time)
23:48:10 <hvr> so I have to assume that there's still a significant amount of cabal users out there
23:48:13 <mgsloan> It would be interesting to collect the requisite statistics!  We haven't put time into analyzing popularity
23:49:13 <hvr> which reminds me to finish up that script for feeding real download counts into hackage
23:49:18 <hvr> from the CDN logs
23:49:55 <hvr> mgsloan: btw, do you know if hackage.fpcomplete.com has logs with the UA field?
23:50:29 <mgsloan> One indication of popularity may be issue tracker activity.  Stack has a total of 2089 issues, cabal has a total of 2678.  So about 80% the number of issues, in about 1.5 years of existing
23:51:05 <mgsloan> hvr: Not sure, I will inquire!
23:51:12 <ReinH> I mean, number of issues might track with other things too
23:51:42 <mgsloan> Right, like number of problems!  We only have 60 issues marked bug, and 
23:51:45 <hvr> could also mean that ppl have more expectations in stack than cabal, and bother to file issues ;-))
23:51:49 <mgsloan> I'm pretty sedulous with labeling issues
23:52:10 <mgsloan> True, stack has a bigger scope than cabal-install, and people appreciate that  
23:52:57 <hvr> otoh, cabal's issue tracker gained ~150 new tickets in a short time specifically about nix-local-build
23:53:03 <piyush-kurur> mgsloan: I think the existence of stack and cabal is actually a healthy thing
23:53:16 <piyush-kurur> for example I do not think too much about the C compiler
23:53:19 <mgsloan> Err, I mean 60 open issues marked bug.  Total bug issue count is 243
23:53:35 <mgsloan> piyush-kurur: Indeed I agree!  Stack would not have been possible without cabal
23:53:40 <piyush-kurur> I use whatever version is available on the system that I work
23:53:54 <mgsloan> Heck, lets face it, the community as it exists now, and all the industrial adoption, would not have been possible without cabal
23:53:55 <hvr> ...and stack actually accelerated cabal dev ;-)
23:53:57 <piyush-kurur> this is because is C is more or less stable
23:54:05 <mgsloan> hvr: Yes, competition is healthy!
23:54:30 <hvr> we're now actively competing with stack for beginners and advanced users
23:54:32 <piyush-kurur> Haskell is innovating at a blazing speed and that means people are doing all kinds of cool things
23:54:40 <hvr> while we're focusing on powerusers first
23:54:59 <piyush-kurur> naturally packages change, their API change etc
23:55:51 <piyush-kurur> as a package developer I like cabal
23:56:03 <piyush-kurur> cabal-install I mean
23:56:29 <piyush-kurur> if my package is breaking in a cabal install build then that means I have made too many assumptions
23:56:37 <piyush-kurur> I need to fix it.
23:57:07 <hvr> well, the cabal specification was driven by the 'no dependency untracked' mantra
23:57:21 <piyush-kurur> hvr: totally agree
23:57:29 <hvr> i.e. to come up with a declarative way to specify all direct deps
23:58:03 <hvr> which then needs something like semantic versioning in place to complement 
23:58:10 <piyush-kurur> hvr: though I would like to know how much of it can be automated
23:58:12 <dmiles> is there any Haskell on the JVM being actively developed?
23:58:21 <piyush-kurur> dmiles: Frege ?
23:58:26 <srhb> dmiles: There was a summer of Haskell project
23:58:35 <hvr> piyush-kurur: quite a lot, but the main problem is detecting for an algorityhm whether it's in the automatable domain
23:58:38 <srhb> dmiles: I haven't yet heard the results of any of them.
23:58:49 <srhb> dmiles: https://github.com/rahulmutt/ghcvm
23:58:51 <dmiles>  Frege it might be then
23:58:58 <srhb> Frege is not Haskell
23:59:03 <dmiles> oh then no
23:59:11 <hvr> piyush-kurur: semantic versioning is needed because it isn't a purely mechanical thing yet
23:59:34 <dmiles> hrrm so maybe it will be https://github.com/rahulmutt/ghcvm
23:59:43 <hvr> piyush-kurur: we can't encode enough of the contract in the types, so we can't decide yet whether an API is indeed comaptible
