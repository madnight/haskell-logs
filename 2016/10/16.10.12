00:30:29 <janika13> http://i.imgur.com/pLMgOr8.jpg
00:30:37 <janika13> why would you ban me 4 saying haskell is useless
00:30:41 <janika13> if mr. haskell man said the same?
00:39:15 <phanimahesh> janika13: #haskell banning someone for saying haskell is useless? That's unthinkable.
00:40:32 <janika13> ye
00:40:39 <janika13> no criticism allowed
00:40:48 <janika13> you're like north korea
00:40:57 <janika13> http://i.imgur.com/pLMgOr8.jpg
00:40:59 <phanimahesh> Are we talking about the same channel?
00:41:04 <janika13> cats are better than dogs
00:41:06 <grantwu> I'm confused
00:41:34 <grantwu> What are we talking about?
00:41:44 <koz_> grantwu: Left Kan extensions.
00:41:53 <koz_> Aren't they great?
00:42:05 <grantwu> I... don't know what they are
00:42:19 <phanimahesh> Me neither. :(
00:43:16 <koz_> I'll let Ed explain: http://comonad.com/reader/2008/kan-extensions/
00:45:43 <dibblego> janika13: Stop it.
00:46:06 <grantwu> koz_: That blog post confused me.
00:46:21 <koz_> grantwu: Same to me, on a first, second and third reading.
00:46:26 <janika13> dibblego: are you on haskell-offtopic?
00:46:27 <koz_> After a fourth one, it began to make sense.
00:46:32 <dibblego> janika13: no.
00:46:49 <janika13> ;_;
01:15:22 <m1dnight_> Is there a tool that recompiles .lhs to .hs and vice versa?
01:21:16 <magneticduck> if my latest plan succeeds, a post titled "Declarative and Deterministic Linux Desktop Ricing with Haskell" should appear on HN in about a month
01:22:52 <magneticduck> I was writing a tool in nix but got fed up with the lack of type safety, so now I'm writing a DSL in Haskell to generate nix
01:23:21 <rmrfroot> magneticduck: that sounds really interesting (NixOS and Haskell user here)
01:24:34 <magneticduck> my initial idea, which I've had for about a year, was to write a system in nix that let people share linux ricing configurations
01:25:43 <magneticduck> I've been sketching it out for the last two days and it looks nice so far... but it needs more Haskell ;)
01:26:35 <sdx23> magneticduck: what do you refer to by "ricing"?
01:26:42 <magneticduck> this is a prototype I drew up a year ago https://github.com/magneticduck/nix-rice
01:26:53 <rmrfroot> magneticduck: cool :) i will have a look
01:26:59 <magneticduck> sdx23: configuring all the bits of software that make up a WM/DM
01:27:56 <magneticduck> rmrfroot: my newest iteration has a more carefully thought design -- that nix-rice repository is more of a proof-of-concept that I wrote to see how r/unixporn would react :P
01:28:20 <sdx23> magneticduck: mh, your website is down
01:29:17 <rmrfroot> magneticduck: damn, this is exactly what i need :O
01:29:46 <magneticduck> everybody needs it, they just don't know yet! :)
01:30:51 <sdx23> not sure. I've always been sceptical to nix
01:31:09 <rmrfroot> magneticduck: i was just implementing this the other day for my desktop, but my implementation is very simple and well... shitty :P
01:34:23 <rmrfroot> magneticduck: actually, it's just a nix configuration that sets up i3 with my config and slick with a background image. so using your proposed solution is very compelling
01:34:40 <rmrfroot> sdx23: anything particular you are sceptical about in regards to nix? 
01:35:32 <rmrfroot> slick = slim, can't spell for my life
01:36:49 <magneticduck> the core of my design is to organise ricing into the configuration and composition of various classes of components
01:37:28 <magneticduck> e.g., a user picks a window manager, and sees that the window manager is parameterized on a 'terminal' -- so we go to the documentation and pick some terminal, which in turn requires a color scheme ..
01:38:59 <sdx23> rmrfroot: i have concerns about the concept of splitting everything up into its own environments. Maybe I failed to understand some key point in there. Not sure I can restate the problem correctly, but if you take e.g. working on a haskell project with vim, using hdevtools/hlint/ghc-mod you want to make sure, that vim finds them but also the right version (that corresponds to the specific ghc
01:39:05 <sdx23> version used in the project)
01:39:42 <rmrfroot> magneticduck: so you can create different constraints for different classes of components? sounds like a good idea 
01:40:06 <magneticduck> I'm trying to make the design 'flat' -- everybody can define anything anywhere, from component classes (say, a user wants to define a class of components representing configuration for his obscure terminal emulator), components, and presets, all of which are transparent, documented / indexed, and overridable
01:41:34 <magneticduck> the ideal would be to have a core library of predefined recipes for a large number of components in one directory, and everybody's own ricing configurations expressed as a natural extension to this library 
01:42:53 <sdx23> How to resolve this? A vim environment for every project (also make sure the vim plugins interfacing the binaries correctly; for some ghc-mod versions this has to be done manually)? A project with dependencies to the development tools you use? Some other way? At some point I've concluded, that distributions are just there to give an single environment of applications and libraries working
01:42:59 <sdx23> together properly.
01:43:02 <magneticduck> horizontal transfer would be encouraged: everybody's best ricing configuration could be transferred to the core library with painless PRs
01:43:17 * hackagebot stb-image-redux 0.1.0.0 - Image loading and writing library based on stb_image and std_image_write  https://hackage.haskell.org/package/stb-image-redux-0.1.0.0 (sasinestro)
01:58:35 <rmrfroot> sdx23: alright, i think i understand what you mean. i have not encountered that problem myself, since i have my editor and it's plugins setup globally, then i have an isolated environment only for the projects tools and libraries. i don't use any dev tools that needs to be compatible with a tool inside the isolated environment. but i can understand your concern! 
01:59:08 <rmrfroot> magneticduck: like how spacemacs does with it's "layers"?
02:04:58 <rmrfroot> sdx23: you still use your .vimrc in your home dir while inside a isolated environment (aka nix-shell), so i would probably setup a project specific .vimrc that extends the user .vimrc and only sets up the plugins with the right paths, then have the user start vim inside the nix-shell.
02:32:35 <jophish> magneticduck: I'm interested in the haskell DSL too :)
02:42:46 <mstruebing> is pointfree always better? if i have a function forexample: lowerCase :: String -> String \n lowerCase input = map toLower input, what would be worse than lowerCase = map toLower? isn't the first variant more readable?
02:42:58 <m1dnight_> Readability is key
02:43:10 <merijn> mstruebing: Always? No.
02:43:19 * hackagebot stb-image-redux 0.1.0.1 - Image loading and writing microlibrary  https://hackage.haskell.org/package/stb-image-redux-0.1.0.1 (sasinestro)
02:43:20 <m1dnight_> In this case it is, imo.
02:43:21 * hackagebot stb-image-redux 0.1.0.2 - Image loading and writing microlibrary  https://hackage.haskell.org/package/stb-image-redux-0.1.0.2 (sasinestro)
02:43:23 * hackagebot textlocal 0.1.0.3 - Haskell wrapper for textlocal SMS gateway  https://hackage.haskell.org/package/textlocal-0.1.0.3 (psibi)
02:43:25 <cocreature> m1dnight_: pointfree is definitely not better. in your example I personally find it more readable but just chose what you find more readable
02:43:29 <liste> mstruebing: no, it isn't always better. but in your case, I think map toLower is more readable
02:43:30 <merijn> mstruebing: Although I would consider "map toLower" better than "map toLower input"
02:43:49 <m1dnight_> cocreature: that's what I mean. If it makes your code more readable it's better. But often times it makes it more confusing.
02:46:04 <merijn> mstruebing: I think the pointfree style just feels unnatural due to not being used to it
02:46:46 <mstruebing> okay thx guys
02:46:57 <merijn> mstruebing: Consider something like "map (map toLower) listOfStrings" which is a lot more readable, imo, then "map (\input -> map toLower input) listOfStrings"
02:47:17 <tdammers> the advantage of point-free code is that the reader doesn't have to process intermediates as variables
02:47:32 <tdammers> we can instead think in terms of composed functions
02:48:11 <merijn> mstruebing: And when you start composing things, this just becomes the case more so
02:48:22 <tdammers> let strToLower input = map toLower input in map strToLower listOfStrings -- This is how you might write it in pointful style
02:48:51 <tdammers> the advantage of pointful style, here, is that by naming strToLower, you get an extra explanation opportunity
02:49:04 <tdammers> you can tell the reader what the mapped function is supposed to do (lowercase a string)
02:49:28 <tdammers> OTOH, defining strToLower itself in point-free style, like so:
02:49:37 <tdammers> let strToLower = map toLower
02:49:56 <tdammers> is probably better, because explicitly naming the second argument doesn't add any explanatory value here
02:50:49 <tdammers> if you write it in English, "given a string str, strToLower maps the toLower function over str" doesn't make things any clearer than "strToLower maps the toLower function over a string"
02:51:29 <tdammers> and just like the plain English examples, the code examples also have similar mental overheads
02:52:33 <tdammers> especially when you try to keep in memory what strToLower *is*: "strToLower means map toLower" takes less mental overhead than  "strToLower is a function that takes a string and maps toLower over that string"
02:54:02 <grantwu> I've been trying to formulate some guidelines for what's readable pointfree code.
02:56:13 <grantwu> What I have so far is (feel free to offer counterexamples) Composing functions that need to take more than one argument is bad, flip is almost always bad, partial application of . is bad
02:56:58 <lyxia> it's not so bad if you consider that (.) is fmap IMO.
02:56:59 <merijn> grantwu: Depends, I agree flip isn't very readable, but writing it out is often more work than just writing 'flip f" inline
02:59:01 <cocreature> I always use flip on runReader and runState
02:59:10 <mettekou> I find `flip` useful when the first argument to a function is a monadic action and the second is not.
02:59:25 <mettekou> It lets me write the do-block at the end.
03:00:31 <tdammers> yes, but there are also good arguments to be made for putting the action first
03:00:36 <tdammers> especially for monads like State
03:00:46 <grantwu> dammit, I distracted myself again.
03:01:03 <tdammers> e.g. when you're writing a library, and your public API is just Thing -> Thing, but you use State Thing internally
03:01:04 * grantwu will read discussion later
03:02:05 <mettekou> tdammers: Of course, but I was referring to cases where I fully apply the function, mainly for internal use.
03:02:37 <tdammers> sure
03:02:43 <tdammers> I tend to use flip there myself
03:02:58 <tdammers> OTOH, I am pretty grateful for things like forM, even though it's just flip mapM
03:03:24 <tdammers> forM items $ \item -> do
03:03:37 <tdammers> "for items as item, do ..."
03:03:44 <tdammers> almost imperative :x
03:07:34 <danza> weird that `for` is `flip traverse` though, rather than `flip map`
03:07:50 <ggVGc> why is it weird?
03:08:08 <danza> because we said that `forM` is `flip mapM`
03:08:32 <koz_> Is there any way I can write an alias for several typeclass constraints?
03:08:38 <mettekou> danza: Yes, but mapM is the monadic version of traverse.
03:08:51 <mettekou> :t mapM
03:08:51 <ggVGc> yeah
03:08:52 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
03:08:56 <mettekou> :t traverse
03:08:57 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:09:02 <danza> :t map
03:09:04 <lambdabot> (a -> b) -> [a] -> [b]
03:09:09 <ggVGc> danza: both for and forM is about also doing effects
03:09:10 <ggVGc> map is not
03:09:14 <ggVGc> is my understanding
03:09:23 <tomjaguarpaw> That is weird
03:09:30 <danza> hum ... than why isn`t `forM` `flip traverseM`?
03:09:37 <tomjaguarpaw> It should be forA
03:09:43 <tomjaguarpaw> And for should be for functors
03:10:18 <danza> it's probably due to history. I guess that traverse is supposed to be the new map
03:13:29 <sdx23> koz_: just another typeclass?
03:14:33 <jophish> koz_: take a look at ConstraintKinds
03:14:52 <jophish> essentially: type MyConstraint a = (Num a, Eq a)
03:15:27 <koz_> jophish: That's awesome! I'll definitely make use of those.
03:15:56 <jophish> np
03:18:47 <koz_> I think the standard response to most things here seems to be 'There's an extension for that'. :P
03:19:47 <sdx23> do I miss something with: class (Num a, Eq a) => MyContraint a --?
03:20:12 <jophish> It's a shame there's no "ExtensionKinds" extension so we can have {-# LANGUAGE KitchenSink #-}
03:22:37 <jophish> sdx23: you also need to write 'instance MyConstraint a where'
03:24:14 <sdx23> jophish: thank you.
03:26:00 <sdx23> jophish: oh, and I think it's good there's no such thing. At some point it's only confusing/tedious to learn yet another synonym.
03:49:54 <nathyong> is there any interactive debugger for Haskell?
03:50:12 <cocreature> nathyong: ghci includes a debugger
03:50:37 <cocreature> but tbh I don’t think a lot of people use it
03:55:12 <nathyong> wonder how it works..
03:56:14 <nathyong> cocreature: this looks really good
03:56:15 <nathyong> thanks
04:00:12 <cocreature> I tend to just go for printf debugging :)
04:03:38 <DataDrake> Hi, has anyone seen an error like this before? http://hastebin.com/buwuyasopi.bash
04:07:44 <mpickering> What is your setup DataDrake ?
04:08:37 <DataDrake> mpickering, Setup.hs or the configure step?
04:09:26 <rmrfroot> DataDrake: i think he means what platform you are running on, if you are using cabal or stack, etc
04:09:55 <DataDrake> this is a vanilla ghc-8.0.1 build. not using cabal
04:11:52 <DataDrake> this is the command sequence I'm using to run the build: http://hastebin.com/ixasuradep.tex
04:13:30 <rmrfroot> DataDrake: can you find the missing packages when doing `ghc-pkg list`?
04:14:34 <DataDrake> yeah, I think the problem is that the libraries are suffixed with -ghc-8.0.1
04:15:19 <DataDrake> i.e. libHSQuickCheck-2.9.1-3eKpVeTqxDb9N3aKjKJS8O-ghc-8.0.1.so
04:28:50 <m1dnight_> I'm trying to fix the tab warnings ni Alex but it seems to be kind of a pita. Is there something I should know about? I'm looking at templates/GenericTemplate.hs and the indentation is really weird.
04:32:13 <wz1000> Does this exist somewhere? class Reify k (a :: k) where reify :: Proxy a -> k
04:34:53 <ashishnegi> Has anyone tried `lmax disruptor` for solving concurrency problems in haskell ? given that haskell biggest codebases are in financial low latency worlds..
04:36:06 <sdx23> ashishnegi: are they? I'd be interested in details.
04:37:00 <ashishnegi> sdx23: Are you asking about financial low latency.. ? or `lmax disruptor` ?
04:37:14 <sdx23> ashishnegi: the former
04:37:14 <ongy> consistently low latency is hard with the GC, so I would be interested in your source on that aswell
04:38:09 <ashishnegi> sdx23:  https://donsbot.wordpress.com/2016/01/18/haskell-developer-roles-at-standard-chartered-london-singapore/
04:38:40 <ashishnegi> ongy: i should not say `low latency` but around the same domain..
04:39:02 <sdx23> I think it interesting nevertheless, thank you
04:39:33 <ashishnegi> ongy: java also has GC and `lmax disruptor` is written in java..
04:39:54 <__monty__> I was wondering what resources on haskell are recommended nowadays? Looking for something on the level of Real World Haskell but I've heard that it's dated even though it's still linked on r/haskell for example.
04:40:13 <ashishnegi> __monty__:  use `haskell from first principles`
04:40:58 <ashishnegi> ongy: also i am not sure about what their approach around GC is.. but one thing they do is `high cachable code`.. single thread writer ; small objects.
04:43:22 * hackagebot stb-image-redux 0.1.0.3 - Image loading and writing microlibrary  https://hackage.haskell.org/package/stb-image-redux-0.1.0.3 (sasinestro)
04:43:40 <merijn> ashishnegi: Who says the haskell codebases in the financial world are in low latency?
04:44:08 <ashishnegi> merijn: i corrected myself.. sorry for saying that.. but that was not my main point.
04:44:39 <merijn> AFAIK most haskell applications tend to be "high throughput" rather than "low latency" and GHCs GC is pretty good at high throughput
04:44:53 <ashishnegi> `lmax disruptor` is written in java.. and java has GC .. so we need to revisit argument about `haskell can not be used in low latency becuase of GC` 
04:45:50 <merijn> ashishnegi: No one says "haskell cannot be used in low latency", it's more "haskell is rather inconvenient/requires lots of careful consideration to be used for low latency, so it's not recommended"
04:46:52 <ashishnegi> low latency always requires lot of careful consideration .. whatever language
04:47:09 <merijn> True
04:47:27 <merijn> But the GHC GC is not very controllable
04:47:40 <merijn> And it's stop-the-world, which is a big no-no for low latency
04:48:11 <merijn> If GHC had a runtime more akin to Erlang then it'd be much easier
04:48:21 <ashishnegi> merijn: this is a good point.. is GC alrogithm swappable in GHC ? i think jvm has that..
04:48:25 <merijn> But that sorta GC/runtime design doesn't play well with laziness
04:48:29 <ongy> is the java GC not stop the world?
04:48:36 <merijn> ashishnegi: Theoretically or practically?
04:48:37 <ab9rf> ongy: no, it 's not
04:48:43 <ab9rf> at least most of the time
04:48:45 <merijn> ongy: Some are, some aren't
04:48:48 <__monty__> ashishnegi: I'm looking at reviews and comments about the book. It seems to be targeted at someone learning haskell from scratch. I'm rather looking for a more advanced text like RWH. Is RWH still the goto resource for this?
04:49:07 <ab9rf> there are dozens of JVMs and even Snoracle's JVM has severeal different GCs that uyou can choose from
04:49:12 <merijn> ashishnegi: Theoretically you can swap out GHC's GC, practically the rest of GHC makes a lot of assumptions about how GC works, afaik
04:49:20 <merijn> ashishnegi: So I don't think it's really practical
04:49:32 <ashishnegi> __monty__: sorry.. i would not be the right person for advance stuff ? what topics are you considering to understand now ?
04:50:29 <merijn> ashishnegi: The problem is that haskell threads have shared memory, which is not a problem from a correctness point of view (everything is immutable), but it's an implementation issue, because currently I can communicate an unevaluated thunk to another thread
04:50:56 <merijn> ashishnegi: Or really, the unevaluated part doesn't matter
04:51:34 <__monty__> ashishnegi: Nothing specific, just want to check what gaps I have in my knowledge.
04:51:44 <merijn> ashishnegi: If you can share heap values between threads AND you have a move+wipe style GC then you have to pause all threads to move potentially shared data
04:51:44 <tdammers> it does matter in the sense that things can get evaluated in unexpected contexts
04:52:13 <merijn> ashishnegi: Erlang solves this by only allowing communication by value (i.e. duplicating a value when sharing with another thread), which means every thread can GC independently
04:52:55 <merijn> ashishnegi: The downside is that the "move+wipe" allocator is *REALLY* good at throughput in the presence of lots of garbage (which is exactly what you want in a lazy language because you have a lot of garbage)
04:53:41 <merijn> ashishnegi: So to keep the move+wipe we'd have to institue copy-by-value semantics for sharing data between threads, which doesn't work for, e.g. infinite data structures like [1..]
04:53:55 <tdammers> frankly, if I were to design a system under such constraints, and I'd be using GHC Haskell, then I'd probably split things up at the process level
04:54:11 <merijn> ashishnegi: And coming up with a good solution that gets best of both worlds is 1) hard and 2) unlikely to be backwards compatible with Haskell as it currently exists
04:54:52 <merijn> ashishnegi: So while designing a 95% haskell language that is suitable for low-latency is certainly a realistic goal, it seems unlikely that such a design can be retrofit into GHC or Haskell as it currently is
04:55:02 <ashishnegi> merijn: these are all good points.. but i would also like to explain `lmax disruptor` way.. ( at least the way i understood it.. )
04:56:10 <merijn> ashishnegi: Which all can be summarised as answer to your initial questions of: Can you do low latency in Haskell? and Can you swap out GHC's GC? As "I wouldn't do it" and "Not really"
04:56:39 <merijn> ashishnegi: A more realistic idea would be to use Haskell to create an (E)DSL for low latency code and generate C from that
04:58:04 <merijn> Lots of people are working on queues/work partitioning that's NUMA/cache friendly (what I get from scanning the lmax disruptor site that's basically what they did, write a NUMA/cache friendly queue system)
04:58:38 <merijn> I would not be surprised if a carefully designed system by a group of HPC programmers is much faster than the usual Java queue stuff
04:59:03 <ashishnegi> they have `lock free` circular queue implementation. 
04:59:49 <ashishnegi> this is main paper.. http://lmax-exchange.github.io/disruptor/files/Disruptor-1.0.pdf 
05:01:44 <Fairy> I wrote some simple code, and I'm wondering if there's any good way to improve it without losing functionality? http://pastebin.com/uBd4bxQW Is there a better way to write the parse function here?
05:02:28 <merijn> ashishnegi: The idea doesn't seem particularly ground-breaking (I'm just skimming their stuff here), the hard part about this stuff is getting the implementation right and fast :)
05:03:24 <ashishnegi> true.. 
05:03:35 <phadej> Fairy: that's perfectly good code (using vertical space will make it readable though)
05:04:07 <ongy> Fairy: I would use newlines instead of ';' for readability. And replace the error message with "List was to short in parseCon"
05:04:16 <merijn> Also, I'd use where over let
05:04:25 <Fairy> I'm having real issues with that, any time I try to space things out, Haskell complains
05:04:29 <lpaste> merijn pasted “Fairy” at http://lpaste.net/255288
05:04:37 <merijn> Fairy: ^^
05:04:42 <ongy> Fairy: what are you using to edit your code?
05:04:42 <merijn> Fairy: Are you using tabs?
05:04:45 <phadej> Fairy: and if you use parse :: [String] -> (Maybe Item, [String]), you don't need to `error`
05:05:01 <Fairy> I use tabs, yes
05:05:11 <merijn> Fairy: Then your tab width is probably wrong
05:05:20 <merijn> Fairy: Tabs == indent to nearest multiple of 8
05:05:40 <merijn> Fairy: If you use a different tab width your code is not going to compile
05:06:09 <Fairy> if the error is hit, something bad happened earlier in the code
05:06:23 <merijn> Fairy: I also recommend reading: https://en.wikibooks.org/wiki/Haskell/Indentation
05:06:25 <delYsid> Tabs are evil
05:06:45 <phadej> Fairy: error is in 99.9% cases the wrong thing to do
05:07:13 <phadej> in Haskell "earlier" is very vague :)
05:07:24 <phadej> > head [1, error "foo"]
05:07:26 <lambdabot>  1
05:07:38 <Fairy> I mean that the error should _never_ occur, its just there for testing, really
05:07:39 <phadej> we use this for good
05:08:23 <merijn> phadej: I mostly use stuff for evil
05:09:02 <phadej> Fairy: "should never occur" is the famous last words. In your case there isn't an invariant making an `error` justified
05:09:42 <phadej> it's not obvious that `parse` have be given a list of 6 elements at minimum
05:09:47 <phadej> (from the type, e.g.)
05:10:31 <phadej> merijn: so you work at FinTech? :)
05:12:49 <merijn> phadej: No, but I hang in mostly HPC circles these days :)
05:13:11 <merijn> Oh, I only just made the connection to evil, rather than the lmax discussion >.>
05:13:23 <merijn> No, that's just my parttime hobby of planning world domination
05:30:08 <ocramz> hi all
05:31:35 <ph88> hi guys, in my program i get an exception and i can't figure out why. When i do a trace  https://paste.fedoraproject.org/447872/25251147/  and get the input value and then run it through the funtion myself it works without a problem .. what am i missing here ?
05:32:50 <ocramz> I'm instrumenting my lib for profiling: `stack build --profile` and `stack test --ghc-options "+RTS -h -RTS"`. I'm puzzled because the ghc.hp output file is just a few lines long and seems to not have measured anything: `JOB "ghc"
05:32:51 <ocramz> DATE "Tue Oct 11 16:44 2016"
05:32:51 <ocramz> SAMPLE_UNIT "seconds"
05:32:51 <ocramz> VALUE_UNIT "bytes"
05:32:53 <ocramz> BEGIN_SAMPLE 0.000000
05:32:57 <ocramz> END_SAMPLE 0.000000
05:33:01 <ocramz> BEGIN_SAMPLE 0.030080
05:33:04 <ocramz> END_SAMPLE 0.030080`
05:33:32 <ocramz> anyone can provide pointers?
05:35:48 <int-e> https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/profiling.html#profiling ... probably needs -prof -fprof-auto?
05:36:06 <merijn> int-e: Maybe stack --profile is supposed to do that?
05:36:17 <int-e> merijn: maybe, I don't know.
05:42:18 <Shou> stack --profile is indeed for that
06:43:25 * hackagebot cplex-hs 0.4.0.4 - high-level CPLEX interface  https://hackage.haskell.org/package/cplex-hs-0.4.0.4 (stefanjhlk)
06:43:27 * hackagebot git-annex 6.20161012 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20161012 (JoeyHess)
07:08:39 <michaelt_> > (-50 `div` 8)
07:08:42 <lambdabot>  -6
07:08:42 <michaelt_> > (-50 `div` 8) :: Int
07:08:44 <lambdabot>  -6
07:09:02 <michaelt_> :t (-50 `div` 8)
07:09:03 <lambdabot> Integral a => a
07:09:26 <michaelt_> :t (-50 `div` -8)
07:09:27 <lambdabot> error:
07:09:28 <lambdabot>     Precedence parsing error
07:09:28 <lambdabot>         cannot mix ‘div’ [infixl 7] and prefix `-' [infixl 6] in the same infix expression
07:09:36 <michaelt_> :t (-50 `div` 8)
07:09:38 <lambdabot> Integral a => a
07:09:48 <michaelt_> :t (-50 `div` 8)
07:09:50 <lambdabot> Integral a => a
07:09:53 <michaelt_> > (-50 `div` 8)
07:09:55 <lambdabot>  -6
07:09:57 <Tuplanolla> What are you trying to do, michaelt_?
07:09:57 <ab9rf> yay for weird parsing rules for -
07:09:59 <michaelt_> > ((-50) `div` 8)
07:10:00 <Gloomy> Hi :)
07:10:01 <lambdabot>  -7
07:10:07 <michaelt_> right
07:10:25 <michaelt_> sorry, some of that above was suppose to be private for lambabot. Apologies
07:10:36 <Tuplanolla> Just enable NegativeLiterals.
07:10:44 <Gloomy> Why does this not work?
07:10:56 <Gloomy> pack l = foldl (\acc x -> accumulate (acc x)) [[]] l
07:11:10 <Gloomy> It keeps complaining that I apply foldl to too few arguments
07:11:24 <Tuplanolla> For good measure enable NumDecimals too.
07:11:28 <sdx23> :t foldl
07:11:30 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
07:11:41 <ab9rf> what's accumulate?
07:12:05 <michaelt_> Tuplanolla: apologies, again; all of that was meant for lambdabot, I was answering a question in haskell-beginners...
07:12:06 <Gloomy> ab9rf Just a function I defined later, it returns a list of lists of the same type
07:12:28 <ab9rf> we can't help you if we don't know how undefined terms are defined
07:12:42 <Gloomy> Hmm, I actually thought I was currently posting in haskell-beginners. This is all confusing ;-)
07:13:07 <ahihi> (acc x) looks suspicious, because acc is going to be a list
07:13:26 <Tuplanolla> Those are good extensions anyway.
07:14:16 <Gloomy> http://pastebin.com/HW4fMGLz
07:15:17 <ab9rf> i think you've used parentheses incorreectly in there
07:15:20 <Gloomy> I'm not done yet, just wanted to see how it worked so far - I would understand if it complained that I wasn't exhaustive in accumulate but I don't get the current error?
07:15:25 <Cale> Gloomy: btw, it's helpful if you also post the error message. You may also prefer to use lpaste.net since that has better Haskell support
07:16:07 <ab9rf> you probably want "(accumulate acc x)" rather than "accumulate (acc x)"
07:16:15 <ab9rf> also, your definition of accumulate makes me itch
07:16:40 <Cale> Yeah, 'length' is typically something to be avoided at all costs.
07:16:55 <Cale> length xs takes O(length xs) time to evaluate
07:16:57 <ab9rf> using guards instead of pattern matching there is.... 
07:17:16 <ab9rf> you can use pattern matching to match on a single element list
07:17:20 <Cale> and yeah, you're incurring an Eq constraint for nothing, by doing equality testing...
07:17:28 <ab9rf> accumulate [[]] x = [[x]]
07:18:07 <ab9rf> that took, ter's no need for the Eq constraint
07:18:11 <ab9rf> just pattern match
07:18:15 <ab9rf> accumulate [[e
07:18:15 <ahihi> there also seems to be equality testing on elements
07:18:22 <ahihi> so it's not for nothing
07:18:28 <ab9rf> no, you can get that with pattern matching
07:18:49 <ab9rf> i think 
07:19:40 <Gloomy> ab9rf Oh. Damn, I'm still not used to the order of evaluation in haskell. That solved the problem, as for guards, I tried to use pattern matching before but it was a nightmare because of how head and tail return different types depending on wether it's an empty list/ a singleton / more
07:19:49 <ab9rf> also acc !! 1 returns the second element of acc, !! is 0-indexed
07:19:51 <ab9rf> > [1,2,3,4,5] !! 0
07:19:53 <lambdabot>  1
07:20:07 <Cale> Gloomy: head and tail don't do that, but also, you shouldn't use head and tail, just pattern match
07:20:20 <Cale> :t head
07:20:21 <ab9rf> head and tail do not return different types depending n whether the list is a singleton or not
07:20:21 <lambdabot> [a] -> a
07:20:25 <Cale> :t tail
07:20:26 <lambdabot> [a] -> [a]
07:20:57 <ab9rf> if length acc == 1, then acc !! 1 will error
07:20:57 <Cale> Haskell is statically typed, and not dependently typed. There's no way for the type of the result of a function to depend on the *value* of its input.
07:21:11 <Gloomy> > tail [[3]]
07:21:13 <lambdabot>  []
07:21:28 <Gloomy> > tail [[3],[4]]
07:21:30 <lambdabot>  [[4]]
07:21:31 <Cale> Gloomy: did you expect something different there?
07:21:40 <ab9rf> :t tail [[3]]
07:21:40 <osa1> I'm looking for a Writer-like monad that uses an "insert one element" function ((:), Data.Set.insert etc.) instead of mappend. does anyone know a library for that?
07:21:41 <lambdabot> Num t => [[t]]
07:21:48 <ab9rf> :t tail [[[3],[4]]
07:21:50 <lambdabot> error:
07:21:50 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
07:21:55 <ab9rf> :t tail [[3],[4]]
07:21:56 <lambdabot> Num t => [[t]]
07:22:00 <ab9rf> same type
07:22:22 <ab9rf> (confusingly polymorphic because i used numeric literals)
07:22:53 <delYsid> Does emacs (haskell-mode?) have anything to view the definition (source) of a function/typeclass/data-type without using an external browser?
07:23:00 <Gloomy> ab9rf But how is [] of type [[t]] ?
07:23:50 <ab9rf> :t []
07:23:51 <lambdabot> [t]
07:24:10 <ab9rf> Gloomy: [[t]] is a specialization of [t]
07:24:35 <Gloomy> Hmm, haven't heard about that yet. 
07:25:11 <Cale> Gloomy: No matter what type of lists you have, there is always an empty list
07:25:24 <Cale> Even an empty list of lists
07:25:26 <ab9rf> the empty list is an instance of every list type
07:25:38 <Gloomy> so [] == [[]] ?
07:25:41 <ski> no
07:25:55 <ab9rf> no, [[]] is a list containing one element
07:26:02 <ab9rf> > length [[]]
07:26:02 <ski> > (length [],length [[]])
07:26:04 <lambdabot>  1
07:26:04 <lambdabot>  (0,1)
07:26:24 <Cale> > head [[]]
07:26:26 <lambdabot>  []
07:26:29 <Cale> > head []
07:26:31 <lambdabot>  *Exception: Prelude.head: empty list
07:26:50 <Gloomy> Hmm ok it's becoming clearer. Thank you everyone :-)
07:27:11 <Gloomy> Going to try writing that function with list comprehensions then, see what comes out
07:27:38 <ab9rf> i'm not exactly sure ewhat you're trying to do, but i suspect accumulate will be much simpler when written with pattern matching
07:27:55 <ab9rf> and i am fairly certainy you can eliminate that Eq constraint
07:29:23 <Gloomy> The constraint is there just because our prof asks us to writ them out for clarity. And the goal here is to convert a list (ex [1,2,2,2,3,3,3,3])  into a list of lists where every sublist contains duplicate elements (thus [[1],[2,2,2],[3,3,3,3]]
07:30:02 <Gloomy> (the list we get is sorted)
07:30:54 <Gloomy> ab9rf : "accumulate will be much simpler when written with pattern matching" - isn't pattern matching what I was doing ?
07:31:04 <ab9rf> Gloomy: no, you were using guards
07:32:28 <Gloomy> They seem to say it's just a different syntax for the same thing ? https://www.haskell.org/tutorial/patterns.html 
07:32:36 <ab9rf> they're not the same thing
07:37:39 <asthasr> Quick q: would you guys say that it is true that arrows are "out of fashion" in Haskell?
07:37:46 <asthasr> And if so, are there any overviews as to why?
07:37:55 <asthasr> (working on some discussion materials)
07:38:27 <ph88> in my program i get an exception and i can't figure out why. When i do a trace  https://paste.fedoraproject.org/447872/25251147/  and get the input value and then run it through the funtion myself it works without a problem .. what am i missing here ?
07:39:44 <geekosaur> asthasr, arrows were never really in fashion. there was obviously at least one abstraction in them looking for a way to express itself... in fact there were two: Applicative and Control.Category
07:41:18 <asthasr> geekosaur: Is there an overview of how they map to arrows?
07:42:02 <geekosaur> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf is some of it
07:42:05 <nutnut> how to keep the system stack always up-to-date ?
07:42:15 <nutnut> do people run stack upgrade from time to time?
07:43:12 * hvr doesn't :-)
07:43:26 * hackagebot svg-builder 0.1.0.2 - DSL for building SVG.  https://hackage.haskell.org/package/svg-builder-0.1.0.2 (jeffreyrosenbluth)
07:43:28 * hackagebot ngx-export 0.2.0.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.2.0.0 (lyokha)
07:44:13 <ab9rf> if it ain't broke, don't fix it
07:45:05 <shapr> nutnut: I do that, and I change my resolver to the latest every few weeks.
07:59:07 <sm> morning all
08:03:19 <sm> nutnut: I stack upgrade when a new release is announced. I change my global resolver to the latest lts, and I update project resolvers, when the benefit seems to outweight the rebuilding cost
08:05:18 <sm> projects using a nightly resolver are updated monthly at most, using the first snapshot of the month
08:12:23 <sm> ertesx: thanks for the advice yesterday, I'll be trying it next time
08:15:25 <jophish> We use nix for all our dependencies. We have a "Known working" snapshot of nixpkgs which we use for development. We also have our build farm running a set of builds with the latest version of nixpkgs from github to give us some early warning of things which might break
08:15:37 <jophish> nixpkgs itself follows (more or less) stackage lts
08:16:03 <sm> and.. not to rehash yesterday's discussion, but if someone asks me "why exactly should I not use error(/errorWithoutStackTrace) for termination with console output ? It's the easiest and least boilerplatey way and it works perfectly", what's the answer ?
08:16:58 <jophish> sm: if it works prefectly then do it. The problem is that it might not continue to work perfectly as the program gets larger
08:17:04 <c_wraith> sm: It won't work in larger programs - ones that actually handle exceptions.  For small programs, eh, why not?
08:17:46 <sm> that's what I'm unclear on, how might it fail in larger programs ?
08:18:00 <sm> if I'd known that I wouldn'a done it
08:18:03 <c_wraith> larger programs tend to actually handle exceptions
08:18:44 <jophish> additionally, notifying the programmer of the error handling scheme in the types is very useful
08:19:52 <Tuplanolla> There's no problem in handling exceptions in, say, a repl, but it usually requires a certain way to structure your code.
08:21:01 <Tuplanolla> It's rather unpleasant to have more than one layer handling exceptions like that.
08:21:59 <sm> can we break this down for, uh, this haskell beginner that's asking ? Using error and also handling exceptions in the same program is bad ? ok. A concrete example of it failing is.. 
08:23:10 <Tuplanolla> The core problem is that, while you can throw exceptions anywhere, you can't catch them anywhere.
08:23:46 <Tuplanolla> Consider how an out-of-memory exception would work.
08:23:47 <c_wraith> sm: using error to terminate a program is bad when you want to use that same code in a program that isn't allowed to just fail.
08:24:06 <c_wraith> sm: and as programs get bigger, they tend to be less-allowed to just fail.
08:24:52 <sm> c_wraith: ok, using error makes code hard to reuse, I get that
08:25:24 <c_wraith> sm: and especially in ways that show up as programs get more sophisticated.
08:25:48 <ongy> I would also argue that it's just bad style. I would compare it to forcing a segfault in C for termination (maybe a bit to far)
08:26:31 <c_wraith> int p = *NULL;
08:27:01 <ongy> I did *(int*) = 0. I should fix that at one point....
08:27:22 <Tuplanolla> If you've ever used OpenCV's C bindings, you should know how nice it is for OpenCV to call `abort` on every error condition.
08:27:24 <ongy> *(int*)0 = 0 of course
08:27:28 <c_wraith> Funny thing about that - the compiler is allowed to do all sorts of crazy things as a result of having that code.  C is terrifying.
08:28:01 <c_wraith> It is even legally allowed to remove the segfault in certain cases.  Undefined behavior -> just pretend it wasn't there!
08:28:35 <ongy> isn't it just "well, that's undefined. Now anything can happen"? But iirc 0 itself is not guaranted to be outside of memory area
08:28:51 <Tuplanolla> The file being read has an incompatible format? Time to abort!
08:29:24 <sm> if we assume a simple executable, never to be reused, growing large and using exceptions in places, but still also using error for simple termination cases. Will error stop working ? Will the exception handling cases stop working ? 
08:29:56 <puregreen> `error` is just a shortcut for throwing the UserError exception
08:30:03 <sm> bob beginner needs a concrete example
08:30:05 <c_wraith> sm: only if you add exception handling at some point
08:30:15 <sm> otherwise all the advice sounds hollow
08:31:18 <c_wraith> sm: that's why I said "go ahead, it's fine.  Until it isn't."  Let bob beginner discover the point at which it isn't fine himself.
08:31:47 <sm> I feel we should be able to describe that point clearly, if it's real
08:32:15 <c_wraith> I dunno.  I think it's one of those things you just have to learn from experience.
08:32:40 <{AS}> How do you generate an integer less than k with quickcheck?
08:33:33 <puregreen> choice (0,k-1)
08:33:41 <{AS}> thanks
08:33:52 <ongy> I think if you are really careful and have error in mind you should be able to get it to work. It's just a really easy way to introduce bugs and makes testing (or debugging) really annoying
08:37:30 <sm> well, I guess that bob guy will get it clear with more experience. Thanks, all
08:38:34 <me> cout<<"hey"<<endl;
08:39:11 <Guest11479> k
08:39:34 <Guest11479> hello?
08:40:45 <puregreen> is there any benefit to using explicit import lists for all unqualified modules? I'm currently working at a project where we do it and it's kinda annoying and I don't understand how it helps but maybe it's just my inexperience showing
08:41:52 <lyxia> it helps knowing where your identifiers come from
08:42:19 <osa1> omg array package is so annoying. does anyone know any wrappers that make it easier to work on arrays when your indices are always 0-based integers?
08:42:34 <puregreen> Vector
08:42:41 <puregreen> @hackage vector
08:42:41 <lambdabot> http://hackage.haskell.org/package/vector
08:42:42 <osa1> no I need same array type
08:42:45 <puregreen> oh well
08:42:55 <osa1> I can't use another type because of other libs I use
08:43:23 <osa1> I guess I'll just write my own wrappers. ugh.
08:43:28 * hackagebot font-awesome-type 0.1 - A Font Awesome data type enumerating all icon classes  https://hackage.haskell.org/package/font-awesome-type-0.1 (SeanLeather)
08:46:49 <eklavya> can someone having experience with ghcjs/compile to js ecosystem tell me how I can use Haskell for react native apps?
08:51:13 <puregreen> osa1: if you do find any library after all, please ping me
08:51:44 <osa1> puregreen: I already implemented my own type synonym with wrapper functions that I need
08:51:50 <puregreen> okay
08:52:29 <osa1> puregreen: I may make it a package if I need a larger API but currently all I need is 4-5 functions
09:06:52 <hololeap> :t let f = (/) :: Float -> Float -> Float
09:06:53 <lambdabot> <no location info>: error:
09:06:53 <lambdabot>     not an expression: ‘let f = (/) :: Float -> Float -> Float’
09:07:21 <hololeap> :t f = (/) :: Float -> Float -> Float
09:07:23 <lambdabot> error:
09:07:23 <lambdabot>     parse error on input ‘=’
09:07:23 <lambdabot>     Perhaps you need a 'let' in a 'do' block?
09:07:40 <phadej> :t let f = (/) :: Float -> Float -> Float in f
09:07:42 <lambdabot> Float -> Float -> Float
09:08:08 <hololeap> :t let f a b = a / b :: Float -> Float -> Float in f 1 2
09:08:10 <lambdabot> error:
09:08:10 <lambdabot>     • No instance for (Fractional (Float -> Float -> Float))
09:08:10 <lambdabot>         arising from a use of ‘/’
09:08:19 <hololeap> why does the second one fail?
09:08:38 <phadej> a / b is just Float
09:09:52 <hololeap> :t let f a b = a / b :: Fractional a => a -> a -> a in f 1 2
09:09:53 <lambdabot> error:
09:09:53 <lambdabot>     • Couldn't match expected type ‘a2 -> a2 -> a2’
09:09:53 <lambdabot>                   with actual type ‘t’
09:10:23 <hololeap> :t let f a b = a / b :: Fractional a => a -> a -> a in f
09:10:25 <lambdabot> error:
09:10:26 <lambdabot>     • Couldn't match expected type ‘a2 -> a2 -> a2’
09:10:26 <lambdabot>                   with actual type ‘t1’
09:11:43 <geekosaur> combining the type signature that way doesn't do what you intend
09:11:57 <geekosaur> :t let f :: Fractional a => a -> a -> a ; f a b = a / b in f
09:11:58 <lambdabot> Fractional a => a -> a -> a
09:13:01 <EvanR> that was sort of a unfriendly thing about haskell when i started, you couldnt do the "completely obvious" x = 3 in the repl like every other language
09:13:30 <ania123> && is logical and
09:13:36 <ania123> how is logical or?
09:13:39 <EvanR> ||
09:14:29 <sm> EvanR: agreed
09:14:57 <EvanR> only later did i learn that ghci is basically like a do block
09:15:14 <MarcelineVQ> you can go x = 3 now
09:15:17 <EvanR> and haskells top level is not like a sequential mutable env
09:15:20 <sm> GHCI could insert the let for you
09:15:27 <EvanR> wut really
09:15:31 <MarcelineVQ> rly
09:15:47 * EvanR waits for the adoption to skyrocket
09:15:54 <geekosaur> 8.0.1 already does
09:16:20 <c_wraith> ghci isn't really a big do block anymore. 
09:16:50 <c_wraith> now you can define data types, instances.. all sorts of things that aren't valid in a do block. 
09:17:23 <c_wraith> now it's just a haskell interpreter with some special rules for handling IO values. 
09:17:25 <sm> MarcelineVQ, geekosaur: I see, you're right! great
09:18:12 <sm> I prophesy.. there will be a great.. oh wait, that already happened
09:18:23 * EvanR can now be curmudgeony and activate "old school restrictive mode" which doesnta llow that stuff
09:18:35 <EvanR> like vi mode
09:19:29 <sm> we could use more exciting blog posts breaking down all the cool new stuff
09:19:40 <EvanR> right
09:20:10 <EvanR> will all bloggers willing to do this please step forward
09:20:24 <EvanR> *everyone but one person steps backwards*
09:21:18 * sbrg tries "x = 3" in ghci
09:21:20 <sbrg> mind blown
09:21:51 <EvanR> 7.10 ,_.
09:22:08 <sbrg> it will be hard to unlearn the habit of using `let`.
09:22:24 <phadej> I still think it's a do block
09:23:28 <geekosaur> it stopped being a do block when they added import in 7.2
09:23:57 <phadej> yeah, I still struggle with "how it could possibly work" :)
09:24:12 <phadej> but it's convenient
09:25:00 <sbrg> it is. I have taught haskell(TA) for two years in a row now, and almost all the students keep forgetting `let` in the beginning. 
09:25:25 <sbrg> so it'll save me time and effort
09:25:42 <sbrg> (effort of explaining kind of how ghci works and why let is needed to a bunch of people that have never touched haskell)
09:26:26 <EvanR> right, and why is it really needed
09:26:32 <EvanR> there was no good answer
09:27:01 <EvanR> having let x = 3 floating in space doesnt make much sense
09:27:13 <sbrg> no, but usually one would say it's kind of like a do-block, but that doesn't really work very well when people don't know what that is yet, heh.
09:27:19 <EvanR> at least in do notation its desugared to let in
09:27:26 <sbrg> true
09:28:04 <EvanR> it kind of feels like having if x then y, without an else ;)
09:28:43 <sbrg> yeah, I see what you mean. 
09:29:48 <geekosaur> it was never needed. someone wrote it that way and nobody looked at it again
09:30:07 <sbrg> really?
09:30:26 <geekosaur> I often feel like ghci was a contrib that someone gave the ghc devs and they're not quite sure what to do with it >.>
09:31:03 <geekosaur> (considering I am involved with some projects where that exact thing happened, and with similar results)
09:33:00 <Cale> Waaaay back when, ghci was easy to explain because it only took expressions and :-commands
09:33:29 <Cale> and people have been making the language that it parses fancier over time
09:34:53 <sm> they sure have
09:35:09 <sbrg> i dig it
09:36:04 <sbrg> ghci is IMO one of the best things about writing haskell. of course, there are some things I wish were handled better like persisting stuff across reloads and stuff. but I know those aren't quite straight-forward to solve in all cases, so I'm patient.
09:36:23 <EvanR> color
09:36:29 <sbrg> yeah, that would be nice as well
09:36:46 <geekosaur> there's been discussion of the persistence across reloads issue and it's actually quite nasty
09:37:12 <sm> chris done and others made it work, no ?
09:37:46 <sbrg> maybe some automatic pretty-printing and such. but many cool features would probably make force it to shed its chains and leave the terminal since it isn't exactly rich in expressive power.
09:38:11 <sbrg> s:force::
09:39:14 <ongy> or go from readline interface to some fancy curses interface
09:39:31 <EvanR> sbrg: ruby, clojure, none of these had to leave the terminal
09:39:39 <sbrg> eh. but i think ghci uses haskeline, not readline
09:39:43 <sbrg> unless that changed
09:39:46 <EvanR> well, clojure repl is not exactly a good example of a good repl but
09:39:55 <EvanR> all these repls are fine in the terminal
09:40:04 <sbrg> EvanR: I'm haven't used either language. what cool features do they have that ghci doesn't?
09:40:14 <EvanR> all the stuff we just said
09:40:18 <sbrg> oh
09:40:27 <EvanR> also idris repl has all the stuf we just said
09:40:38 <EvanR> especially pretty printing without Show instances
09:40:55 <sm> >:/
09:41:14 <sm> we are behind
09:41:19 <EvanR> everything is an expression, and you wrote the expression, so you can show it
09:41:25 <EvanR> it looks like what you wrote
09:42:15 <EvanR> values are red, types are blue ;)
09:43:36 <sm> who can bring these god-like UI powers to the Haskell masses ?
09:44:34 <EvanR> replmanmanmanman
09:44:54 <sm> GHCI is managed as an offshoot of GHC still, I guess
09:46:19 <EvanR> yes any project to make a better repl will need to know GHC
09:46:26 <Tuplanolla> It's especially nice how ghci, bash, octave-cli, maxima and all other things work slightly differently.
09:47:18 <EvanR> apparently its not common to use another repl as inspiration, its your special snowflake
09:47:23 <Tuplanolla> I can't send ^W^W^<^<^Y to each and expect the same result.
09:47:58 <geekosaur> although ghci-ng was split off onto a hackage project some time back in an attempt to jumpstart ghci development
09:48:08 <geekosaur> (it has led to a few improvements)
09:48:43 <geekosaur> but, ghc-related dev has always had the problem that you really need to mindmeld with the Commentary before you can even get started :(
09:51:11 <EvanR> sounds vaguely cabalistic
09:54:08 <dmj`> cana-cabalistc
09:58:00 <athan> dmj`: ca-ballin'
10:00:57 <clintm> In dons's haskellexchange video, he talks about describing things in AST's and how much they use a system of compilers and interpretors for many problems.  I'm trying to get started learning more about this approach but I'm curious if any of you know of any good examples of this in practice?
10:01:22 <EvanR> link to this video?
10:01:51 <clintm> http://bit.ly/2dkPy3T
10:02:01 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/ -- there's a talk here with more about that approach
10:02:19 <clintm> awesome!  Thanks, Cale.
10:02:43 <Tuplanolla> This would be a great time to check the codependencies of the `free` package, if that's a word.
10:02:51 <Cale> (I don't know what was in dons' talk though)
10:03:19 <Tuplanolla> (What do you call a dependency in the other direction?)
10:03:37 <clintm> It's about halfway through, as I remember.
10:04:09 <clintm> Right about 32:19
10:05:32 <EvanR> Tuplanolla: dunno. maybe its like a | b, a divides b, theres no other word for it
10:05:46 <EvanR> a depends on b
10:06:24 <EvanR> a dependency exists, this seems weaker wording, but thats life
10:07:28 * dmj` really wishes QuickCheck would add a default Arbitrary implementation 
10:07:41 <Tuplanolla> My little category theorist nominates "codependency".
10:08:24 <EvanR> b codepends on a
10:08:44 <EvanR> spooky
10:08:49 <osa1> what are my options for efficiently updatable functional graphs? containers' Data.Graph doesn't allow easy or efficient updates
10:09:04 <osa1> I need to 1) add new edges 2) update node attributes
10:09:17 <ongy> what would that be? b is a prerequisite to a?
10:09:20 <osa1> is IntMap my gbest option?
10:09:21 <EvanR> adjacency set?
10:09:43 <osa1> EvanR: so an IntMap IntSet ?
10:09:50 <EvanR> two IntMaps, the index both ways of who is connected 
10:10:29 <elfeck> hello, can someone tell me how to unfuck template-haskell indention in haskell-mode (emacs)
10:10:37 <EvanR> but that only allows 1 edge between vertices
10:10:49 <osa1> that's OK for my use case
10:10:56 <Tuplanolla> Yes, ongy. Just reverse all the arrows. By the same logic a coconut is a nut.
10:11:00 <EvanR> IntMap [Int]
10:11:02 <EvanR> x2
10:11:11 <Tuplanolla> Prerequisite is a good word though.
10:11:50 <osa1> EvanR: do you know a library that implements this for me? e.g. with functions like addEdge and some commonly used algorithms (traversals etc.)
10:12:02 <EvanR> Tuplanolla: ive heard people say "depends on" for that
10:12:17 <EvanR> calculus depends on algebra
10:12:24 <EvanR> not the other way around
10:12:46 <c_wraith> osa1, there is fgl. it does a lot of things. 
10:13:27 <c_wraith> @hackage fgl
10:13:27 <lambdabot> http://hackage.haskell.org/package/fgl
10:15:11 <osa1> that API though
10:15:28 <c_wraith> I've use fgl. it's pretty easy. 
10:15:31 <Tuplanolla> It's fine.
10:15:44 <c_wraith> it provides a lot of tools, and you don't have to use most of them. 
10:16:12 <osa1> OK no it looks good I'll give it a try.
10:20:51 <athan> dmj`: I really want some kind of standard deviation for Arbitrary :v
10:23:03 <hololeap> is there a command line tool (or ghci command) that does roughly the same thing as hoogle, but only for available libraries on the system?
10:23:23 <puregreen> hoogle
10:23:29 <puregreen> (it can be installed offline)
10:23:36 <puregreen> (and used as a command-line tool)
10:23:43 <hololeap> cool
10:25:09 <dmj`> athan: I'm using basic-sop
10:25:38 <dmj`> but it requires generics-sop for the `Generic` type
10:26:42 <dmj`> athan: QuickCheck should merge quickcheck-instances and have a default Arbitrary implementation :] 
10:28:13 <kosmikus> dmj`: the Arbitrary instance in basic-sop isn't terribly good
10:32:20 <dmj`> kosmikus: Just attempting to round-trip some json, not using recursive structures or anything like that.
10:33:07 <kosmikus> yes, should be good enough for that
10:50:53 <Malkrith> So functors 
10:51:12 <Malkrith> Is there a simple fucnctor implementation I can look at?
10:51:25 <jay72> what do you mean by simple functor implementation?
10:51:40 <cocreature> Malkrith: you can look at instances of the functor typeclass
10:51:48 <cocreature> Malkrith: e.g. the one for lists is quite simple
10:51:56 <Malkrith> Alright
10:51:58 <Tuplanolla> They're all simple.
10:51:59 <geekosaur> @src Maybe fmap
10:51:59 <lambdabot> fmap _ Nothing  = Nothing
10:51:59 <lambdabot> fmap f (Just a) = Just (f a)
10:52:00 <cocreature> and most likely you already know it :)
10:52:04 <Malkrith> lists is also a monad right?
10:52:08 <cocreature> yep
10:52:13 <Malkrith> Alright
10:52:17 <Malkrith> I will look there
10:52:37 <dmj`> data Id a = Id a; instance Functor Id where fmap f (Id x) = Id (f x)
10:53:51 <jay72> newtype Identity a = Identity a
10:53:52 <Malkrith> Though giving me things like `fmap f (Just a) = Just (f a)` isn't maybe that helpful if only because I am in the process of figuring out what that stuff means
10:53:58 <PhsShft> how do you write an instance for an ordered pair?
10:54:01 <jay72> instance Functor Identity where
10:54:10 <jay72> fmap f (Identity x) = Identity (f x)
10:54:11 <PhsShft> like instance (Ord x, Ord y) => Ord (Pair x y), how would you define <= ?
10:56:29 <EvanR> with the dictionary ordering
10:56:45 <kuribas> How can bytestring index be O(1), if it's not an array or vector?
10:56:46 <EvanR> if x1==x2, compare y1 and y2
10:57:03 <Cale> PhsShft: I would write  instance (Ord x, Ord y) => Ord (Pair x y) where compare (P x y) (P x' y') = compare x x' <> compare y y'
10:57:14 <puregreen> kuribas: what do you mean? a bytestring is an array
10:57:19 <PhsShft> :Cale does <> do?
10:57:23 <PhsShft> what does <> do?
10:57:26 <Cale> PhsShft: Ordering has a really useful Monoid instance
10:57:30 <Cale> In this case,
10:57:40 <Cale> EQ <> y = y
10:57:49 <Cale> x <> y = x
10:58:02 <Cale> i.e. if the first comparison is EQ, then we take the result of the second
10:58:16 <Cale> otherwise, we use the result of the first comparison (be it LT or GT)
10:58:19 <kuribas> puregreen: if it's an array, how can it support streaming?
10:58:37 <PhsShft> where i can look up on  < > ? or is it just < combined with >?
10:58:38 <EvanR> strict ByteString cant, unless you stream chunks of them
10:58:41 <Cale> no
10:58:50 <Cale> It's from Data.Monoid
10:59:00 <Cale> You can't put a space in the middle
10:59:07 <PhsShft> Thanks… I’ll look it up
10:59:13 <PhsShft> yea I was trying to make it look nice
10:59:14 <PhsShft> got it
10:59:16 <PhsShft> thx
10:59:19 <geekosaur> it's the infix form of Data.Monoid.mappend
10:59:24 <Cale> It's implemented separately for various types
10:59:42 <Cale> along with a constant called mempty
10:59:47 <geekosaur> a Monoid is a type that has an identity and a way to combine things
10:59:47 <puregreen> kuribas: if you're talking about lazy bytestrings, they don't have O(1) index
10:59:56 <kuribas> puregreen: ok, I see.
10:59:58 <puregreen> “O(c) ByteString index (subscript) operator, starting from 0.”
11:00:01 <Cale> and it's required to satisfy (x <> y) <> z == x <> (y <> z)
11:00:07 <puregreen> ‘c’ is amount of chunks, I think
11:00:15 <Cale> and  mempty <> x == x  as well as  x <> mempty == x
11:00:38 <Cale> So it's just sort of "combine these things in the obvious way, depending on the type"
11:00:46 <Cale> For lists, it's concatenation, for instance
11:00:55 <Cale> For functions, it combines elementwise
11:01:01 <PhsShft> That seems very useful
11:01:06 <Cale> or, pointwise if you like
11:01:22 <PhsShft> I’ll look it up, thank you :Cale 
11:01:33 <EvanR> monoids are really crucial to pretty much life the universe and everything
11:02:35 <shapr> truly
11:03:41 <geekosaur> yeh, monoids are the sort of thing nobody thinks about because they're "things just work"
11:04:03 <mizu_no_oto_work> It's probably also worth noting that mappend and mempty aren't really good names.
11:04:33 <shapr> mizu_no_oto_work: suggest another breaking change?
11:04:34 <Cale> They aren't the worst names ever, since lists are the free monoid
11:04:41 <Cale> But I agree
11:04:45 <shapr> I'm enjoying the results of the earlier breaking changes.
11:05:03 <Cale> <> is certainly an improvement over mappend
11:05:08 <Malkrith> What is the signature of IO Int?
11:05:27 <EvanR> <> and ε ;)
11:05:31 <Cale> Malkrith: IO Int is the type of IO actions which if you run them, will produce an Int result.
11:05:33 <kuribas> puregreen: Bytestrings and lazy Bytestrings are different types, right?
11:05:43 <Malkrith> But...
11:05:59 <Malkrith> It was like, Maybe a or something when we talked about it earlier
11:06:03 <EvanR> kuribas: yes
11:06:04 <Cale> Malkrith: (each time you run them, you may get a different result, and may cause your computer to do just about anything)
11:06:27 <Cale> Malkrith: Sorry, I missed the earlier conversation, so I have no context.
11:06:45 <Malkrith> We were talking about what an IO Int could return 
11:07:03 <Malkrith> Like undefined :: IO Int
11:09:22 <Cale> Malkrith: Well, undefined is always an option, but it's not a terribly interesting one.
11:09:47 <infandum> I've been using the HTTP library forever. I just recently noticed that there exists higher level libraries like servant and wreq and to an extent pipes-http. Which library do you all recommend?
11:09:52 <EvanR> > Nothing <> Just 'a'
11:09:54 <Cale> Malkrith: a more interesting example of an IO Int is something like  readLn  (specialised)
11:09:54 <lambdabot>  error:
11:09:54 <lambdabot>      • No instance for (Monoid Char) arising from a use of ‘<>’
11:09:54 <lambdabot>      • In the expression: Nothing <> Just 'a'
11:10:02 <EvanR> > Nothing <> Just "a"
11:10:05 <lambdabot>  Just "a"
11:10:13 <EvanR> ok good
11:10:28 <Malkrith> > :t IO Int
11:10:32 <lambdabot>  <hint>:1:1: error: parse error on input ‘:’
11:10:33 <Cale> Try entering   readLn :: IO Int   at the ghci prompt
11:10:45 <Cale> IO Int is a type, so it doesn't have a type, it has a kind
11:10:50 <Cale> :k IO Int
11:10:50 <Malkrith> Oh...
11:10:51 <lambdabot> *
11:10:54 <Malkrith> Right
11:11:27 <Cale> Its kind is *, which is the kind of types that have ordinary values in them.
11:12:10 <Malkrith> I couldn't find what was looked at yesterday
11:12:20 <infandum> :k IO a
11:12:22 <lambdabot> error: Not in scope: type variable ‘a’
11:12:45 <infandum> :k IO (Maybe Int)
11:12:46 <lambdabot> *
11:12:51 <Cale> :k IO
11:12:52 <lambdabot> * -> *
11:12:56 <infandum> ah that was it haha
11:13:15 <infandum> :k []
11:13:17 <lambdabot> * -> *
11:13:19 <infandum> coo'
11:13:28 <infandum> thought I was crazy for a second
11:13:39 <EvanR> :t []
11:13:40 <lambdabot> [t]
11:13:44 <EvanR> :sort []
11:14:22 <Malkrith> So IO Int is sort of like Maybe Int
11:14:45 <EvanR> both are functors, both are monads
11:14:48 <EvanR> etc
11:15:10 <monochrom> have the best of both worlds. IO (Maybe Int) and Maybe (IO Int)
11:15:29 <EvanR> (IO <> Maybe) Int
11:15:36 <erisco> MaybeT IO Int
11:15:43 <Malkrith> What does <> mean?
11:15:55 <EvanR> you should be asking what <>'s type is
11:15:57 <monochrom> have more than best of both worlds. IO (IO (Maybe (IO Int)))
11:16:22 <osa1> I'm lost in the API docs ... can fgl "transpose" a graph? (reverse edges)
11:16:23 <Malkrith> That's what I asked
11:16:24 <Malkrith> Just in a different way
11:16:24 <EvanR> :t (<>)
11:16:26 <lambdabot> Monoid m => m -> m -> m
11:16:29 <Malkrith> :t (<>)
11:16:30 <lambdabot> Monoid m => m -> m -> m
11:16:31 <Malkrith> Oh
11:16:39 <EvanR> brilliant
11:16:49 <Malkrith> So Maybe <> IO produces Maybe IO?
11:16:51 <Tuplanolla> :k Fix IO
11:16:53 <lambdabot> error:
11:16:53 <lambdabot>     Not in scope: type constructor or class ‘Fix’
11:16:58 <EvanR> Malkrith: you cant actually do that
11:17:24 <Malkrith> > (Maybe <> IO) Int
11:17:26 <lambdabot>  error:
11:17:26 <lambdabot>      • Data constructor not in scope: Maybe :: t0 -> t
11:17:26 <lambdabot>      • Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)error:
11:17:28 <EvanR> but if f and g were both :: a -> a, then you could do Endo f <> Endo g
11:17:39 <EvanR> Maybe and IO are both * -> *
11:17:49 <Malkrith> So if they have the same... what is it
11:18:02 <Malkrith> Starts with an m I think
11:18:11 <EvanR> a -> a, its an endomorphism
11:18:38 <Malkrith> Morphism was what I was looking for 
11:18:52 <Malkrith> Is it an Endomorphism because it self-describes?
11:19:04 <EvanR> because it comes back to itself
11:19:20 <Malkrith> So it maps to itself
11:19:31 <monochrom> I think that this line of pursuit is getting to fantasy land.
11:19:32 <EvanR> the monoid operation <> there is .
11:19:49 <EvanR> import Control.FantasyLand
11:20:03 <geekosaur> because it maps from a given type (not value) to the same type. but I'm not sure this is a productive line of thought...
11:20:35 <Malkrith> I don't think of these things as values
11:20:35 <Malkrith> Just rather vague things
11:20:41 <ertesx> good even, people of #information-overload
11:20:44 <ertesx> evening
11:21:05 <geekosaur> indeed
11:21:36 <EvanR> good, ertesx you can explain cofree to Malkrith 
11:21:36 <Malkrith> I am... slow to piece all of this together
11:21:53 <Malkrith> But the more I have these conversations the more I learn 
11:22:04 <ertesx> Malkrith: you should pick one of those topics and learn it in isolation
11:22:26 <Malkrith> It's hard to pick topics when said topics pull in the other topics 
11:22:27 <EvanR> Malkrith needs to jack into the matrix and learn "kung-fu"
11:22:38 <monochrom> EvanR, I find your jokes and digressions to be sidetracking, distracting, and disruptive. I ask you to stop doing this.
11:23:13 <ertesx> Malkrith: it's possible, but sometimes in haskell you have to be a bit determined and say: "let me learn this first!" =)
11:23:18 <ertesx> in #haskell i mean
11:23:34 <Malkrith> I like how people explain things here though 
11:23:56 <Malkrith> It's easier to grasp things when you pull in other things which in turn builds understanding of those as well
11:27:15 <lpaste> ghorn pasted “No title” at http://lpaste.net/256097
11:27:31 <ghorn> why does this loop the type checker ^ ?
11:27:58 <infandum> osa1: Yes it can. Check out Data.Graph.Inductive.Basic
11:28:02 <infandum> osa1: grev
11:28:11 <EvanR> ghorn: what is Split Foo ?
11:28:24 <EvanR> which is what it eventually tries to do
11:28:27 <geekosaur> doesn't that last definition match everything?
11:28:38 <ghorn> I was hoping Split Foo = Foo, the last instance of the closed type family
11:28:39 <osa1> infandum: nice, thanks
11:28:58 <geekosaur> (not "everything except ...")
11:29:13 <infandum> osa1: fgl is a fantastic library
11:29:41 <EvanR> what happens if you disable UndecidableInstances, what error do you get
11:29:59 <geekosaur> anyway anything that requires UndecidableInstances is a big red flag that you are inviting typechecker loops
11:31:30 <ghorn> the error is on `Split (a b) = Split (a :*: b)`, veriables k,k occur more often in Split (a :*: b) than in the instance head
11:32:00 <EvanR> so it cant ensure termination by shrinking
11:32:26 <osa1> infandum: it really is. although I'm having a little bit of problem right now because of the restriction that you have to add nodes before edges (I was accumulating a graph...)
11:32:45 <osa1> so I guess I need to collect all the edges in a list and then add them after the loop
11:34:10 <EvanR> it might be an issue with the kind being infinite
11:35:11 <ph88> in my program i get an exception and i can't figure out why. When i do a trace  https://paste.fedoraproject.org/447872/25251147/  and get the input value and then run it through the funtion myself it works without a problem .. what am i missing here ?
11:38:23 * geekosaur would add Debug.Trace.traceShow at key points...
11:38:58 <geekosaur> also what is the exception?
11:38:59 <ph88> geekosaur, i had traces before but i didn't understand them
11:39:17 <ph88> i don't what is the exception .. it doesn't say
11:39:21 <ph88> i only know what is in that paste
11:39:32 <ReinH> It doesn't say?
11:39:35 <geekosaur> for that matter, what is the actual code? there is not a lot here to go on
11:39:51 <ReinH> What *does* it say?
11:39:57 <ph88> Stopped in <exception thrown>, <unknown>    _exception :: e = _
11:40:04 <ph88> that doesn't really tell me anything
11:40:09 <ph88> it's line 2 and 3 in paste
11:40:27 <infandum> osa1: Why? Can't you add the nodes as you add the edges?
11:40:45 <osa1> infandum: I only know labels sometime later
11:43:02 <infandum> osa1: Then label them later?
11:44:06 <osa1> infandum: for that I'd need to maintain a Map Node Label, I'd rather accumlate a [LEdge ...]
11:45:01 <infandum> But then it's impossible to have a network without nodes...
11:45:11 <infandum> well I guess it's the null network
11:45:15 <infandum> but other than that
11:46:04 <osa1> it'd be nice if I had a GraphBuilder type that allows invalid states like edges to non-existant nodes. then a function GraphBuilder -> Graph could validate
11:47:02 <infandum> But if there's no structure to it, then why not analyze your edges and then when you're ready for the network create the network?
11:48:20 <osa1> I'm not sure what you mean by structure, but this is all about how I iterate my data to generate a graph. in each step I have a "continuation" node and I generate an edge to it. at this point I don't know this continuation's label so I can't add it just yet.
11:51:03 <infandum> ah, I see. Although I'm not sure why you wouldn't know the label. Otherwise you could fold over your data to iterate the generation of the graph
11:53:49 <ph88> geekosaur, ReinH this is the related code  https://paste.fedoraproject.org/449135/47629839/
11:54:51 <ph88> the first 3 functions are uniplate
11:55:08 <ph88> what is the value causing the exception ??
11:57:17 <geekosaur> I think I want to know what happens if you run this with runhaskell instead of in ghci
11:57:23 <geekosaur> since that should at least print the exception
11:57:32 <geekosaur> and it's really hard to know what is going on without that
11:57:56 <ph88> geekosaur, i use stack .. i can try to run it with profiling information ... one moment
11:58:21 <ph88> this is my build command:  stack build --ghc-options '-O0 -rtsopts -fprof-auto -fprof-auto-calls' --executable-profiling
11:58:34 <ryantm__> Is there a reasonable definition for a MonadPlus instance of the Q monad?
11:59:33 <ryantm__> I guess actually just the Alternative instance, since that is all that is needed.
12:00:00 <ph88> geekosaur, i'm trying to get profiling information so i can see the exception .. but i'm doing something wrong again .. https://paste.fedoraproject.org/449142/98753147/
12:00:36 <geekosaur> stack --RTS exec ...
12:00:54 <geekosaur> the problem is that RTS opts don't obey the --, so the stack command itself is trying to run with -xc
12:02:05 <puregreen> hm, surprisingly, I ran `stack exec blah -- +RTS ...` just a minute ago and it passed the options to `blah`, not to `stack`
12:02:24 <ph88> yes it's strange because it worked before for me as well (i checked my zsh history)
12:02:28 <geekosaur> odd
12:02:35 <puregreen> try “stack exec echo -- +RTS”
12:02:47 <ph88> echo ?
12:03:06 <ab9rf> it's a mindless program that just repeats whatever you say to it
12:03:21 <geekosaur> the thing is that the only way to stop a Haskell program from eating +RTS is to provide a C main() that hides the RTS options from hs_init()
12:03:25 <ph88> puregreen, that gives: +RTS
12:03:30 <geekosaur> and I don't think stack does that
12:03:46 <puregreen> ph88: this means that stack doesn't receive the +RTS
12:04:02 <ab9rf> stack is properly passing +RTS to the called program
12:04:04 <geekosaur> interesting. maybe they fixed the runtime to stop RTS processing too on --
12:04:21 <ertesx> the RTS stops on --
12:04:25 <geekosaur> so then I don't know what is wring unless it's not passing the -fprof-* options on
12:04:43 <ertesx> try without the "--"
12:05:02 <geekosaur> which... hm. I think technically what you did is wrong, you should be using --library-profiling or something like that instead of trying to push them into ghc-options
12:05:11 <geekosaur> but I don't know what stack is doing on that level
12:05:21 <ph88> ertesx, i try   stack exec vhdl +RTS -xc   but no go
12:05:35 <ertesx> ph88: no, try echo again, but without "--"
12:05:53 <ph88> ertesx, that prints an empty line
12:05:56 <ertesx> i'd expect to see a blank line
12:06:02 <ertesx> yeah…  stack eats RTS options
12:06:09 <ph88> geekosaur, i build with --executable-profiling
12:06:10 <geekosaur> that one is passing the RTS option to stack, yes
12:06:13 <MarcelineVQ> why shouldn't it
12:06:54 <geekosaur> ph88 do you have *any* libraries there though? ghc is weird about it, you need all libraries including any associated with the executable to be profiled. (which ugh)
12:07:08 <ertesx> it should…  it's just another haskell program after all…  so you need to use "--" to pass RTS options to the executed program
12:07:20 <geekosaur> (...also I am running into cognitive issues again, urgh)
12:08:03 <ph88> geekosaur, what do you mean do i have any libraries?  .. i remember when i did stack build with all those options just mentioned it started rebuilding all dependencies
12:09:09 <ph88> what else can i try ?
12:10:30 <ph88> https://paste.fedoraproject.org/449149/62994011/
12:10:32 <ertesx> BTW, a less well known feature of the RTS is that it also reads an environment variable ("GHCRTS" IIRC) for RTS options…  you can just pass them to every haskell program by setting it:  GHCRTS="-M512m" cabal exec …
12:10:42 <ph88> i think it accept the RTS and xc now but something went wrong with the build ?
12:11:32 <ph88> when i try to build with -prof that also doesn't work see previous paste on line 72  https://paste.fedoraproject.org/449142/98753147/
12:12:12 <hololeap> i'm confused about the nature of Rational. when I do :i Rational in GHCI, i get almost no info, but it appears to be part of Enum, Num, Fractional, etc. just by the way it behaves
12:13:18 <ph88> it's the vicious circle of "must build with -prof" <--> "can not use -prof use --executable-profiling instead"
12:13:31 <geekosaur> hololeap, what it should tell you is that it's a type alias for Ratio Integer
12:13:36 <ph88> i can't possibly be the only one with this issue
12:13:42 <geekosaur> the rest of the information therefore is under ":i Ratio"
12:14:10 <hololeap> ok i see now
12:19:03 <infandum> In wreq, how can you have a nested FormValue? Like, "listval" := ["opt1" := 3, "opt2" := "cheese"]?
12:19:18 <infandum> Without resorting to defining the JSON type
12:19:27 <infandum> because I could just do that
12:19:38 <infandum> but it would take longer
12:19:50 <puregreen> infandum: "listval" := object [...]
12:20:18 <puregreen> I think
12:21:56 <geekosaur> hololeap, and the reason it doesn't do that for you is that what is correct depends on the type alias. sometimes the right response there for some type would be :i Integer. sometimes you need to look closely at both. occasionally (type functions) you get another redirection and have to understand the type function to know what to look at next
12:22:06 <infandum> puregreen: Where is object from?
12:22:24 <puregreen> no, I'm wrong, `FormValue` doesn't have an instance for JSON so it won't work
12:22:30 <infandum> nevermind
12:22:38 <infandum> oh
12:22:39 <infandum> :(
12:23:08 <infandum> It's weird, it should be able to nest. Because it's converted to a string anyways...
12:24:03 <puregreen> you can try converting it to a string manually with renderFormValue
12:24:15 <infandum> yeah I literally just realized that haha
12:24:19 <infandum> I wonder if it'll work
12:26:45 <puregreen> infandum: well, did it?
12:26:49 <puregreen> (I'm curious)
12:32:47 <ab9rf> huh. it seems that i had the idea for reactive programming back in 1994. too bad i couldn't figure out how to make it work. :)
12:37:31 <hololeap> i'm trying to understand implicit type conversion a little better. i'm trying to define a function f x y = enumFromThenTo x (x + 0.001) y :: (Enum a, Real a) => a -> a -> [Rational]
12:37:48 <hololeap> it doesn't work unless i explicitly use toRational on x and y
12:38:10 <geekosaur> yes. there is no implicit type conversion. there are polymorphic literals
12:38:14 <geekosaur> and *only* literals
12:38:41 <hololeap> bummer
12:47:45 <MichaelK> Hi, am I missing something or is `type family F a b = d | d a -> b, d b -> a` still not supported with TypeFamilyDependencies?
12:51:15 <quangl> omg
12:51:20 <quangl> im doing the user guide
12:51:30 <quangl> trying to get the helloworld to run
12:51:40 <quangl> but whats up with all these stack things ?
12:51:44 <quangl> like stack build 
12:51:49 <quangl> stack exec
12:51:53 <quangl> stack test
12:52:12 <quangl> but it doesnt run?  and it just keeps going on .  then u have to change the yaml file?
12:52:23 <quangl> is this how you get hello world to run?
12:52:44 <lyxia> what user guide 
12:52:50 <quangl> https://docs.haskellstack.org/en/stable/GUIDE/
12:53:38 <monochrom> I would just install GHC, then "ghc -c helloworld.hs" to obtain an executable.
12:53:46 <quangl> ok
12:53:47 <monochrom> err, delete "-c"
12:53:55 <quangl> how come it doesnt just say that
12:54:25 <monochrom> But people say "installing GHC by myself is too hard, I'll let stack do it for me".
12:54:31 <hololeap> what is the fixity of an "infixed" function like `div`?
12:54:34 <monochrom> I do think that they now have two problems.
12:55:09 <monochrom> because you are reading a guide from haskellstack.org
12:55:20 <MarcelineVQ> hololeap: 7 in div's case, type :i div in ghci to check
12:55:38 <monochrom> If you read a guide on microsoft.com, they won't tell you to just buy a mac, will they?
12:55:39 <MarcelineVQ> infixl 7 specifically
12:55:46 <quangl> so stack sucks?
12:55:57 <quangl> haskellplatform is better?
12:55:57 <hololeap> ok, i defined a function "pow" and it appears to have higher fixity than (*), so what is it by default?
12:56:02 <MarcelineVQ> 9
12:56:04 <monochrom> no, but it is a whole world of its own
12:56:05 <hvr> quangl: it's more like Stack is overkill for an hello world
12:56:07 <hololeap> ok, thanks
12:56:40 <monochrom> I prefer the haskell platform. I think it's simpler at the beginning. But people disagree with me.
12:56:56 <Tuplanolla> The thing is that Stack is project-oriented, quangl. Learning isn't usually a single coherent project.
12:57:00 <quangl> ok ill try haskell platfrom
12:57:06 <ryantm__> quangl:  try stack runhaskell helloworld.hs
12:57:14 <ertesx> quangl: i wouldn't recommend stack to beginners, but its website certainly makes it look like it's "the" tool for marketing purposes
12:57:53 <shapr> Sometimes I miss the days before cabal, where you just had a bunch of Haskell source files in a directory.
12:58:10 <shapr> And then I try to build something with many dependencies, and I remember why I like the (new?) tools.
12:58:13 <monochrom> just to be fair, if you read a guide on apple.com, they won't tell you "just buy any PC/laptop/tablet that comes with windows", will they?
12:58:13 <quangl> ok that seems to be doing something
12:58:23 <quangl> says populating index cache
12:59:03 <Fairy> if I have a function that takes a list   test a   , is it possible to read said   a   in terms of   (x:xs)   without doing lambda to nor declaring   test (x:xs)   ? if that makes sense
12:59:06 <quangl> haskell is good for making a kind of AI like expert system chat bot?
12:59:14 <monochrom> no
12:59:31 <ertesx> quangl: languagewise yes, economically no (you need to write lots of stuff yourself at this point)
13:00:25 <quangl> what do u mean write alot of stuff on yourself as opposid to what in another language?
13:00:29 <monochrom> the fire in the eyes of inspired beginners needs to be watered
13:00:39 <ryantm__> quangl: consider looking at https://hackage.haskell.org/package/lambdabot
13:01:04 <quangl> http://learnyouahaskell.com/chapters
13:01:10 <quangl> do u think i should do this ?
13:01:22 <Fairy> Yes, you should.
13:01:22 <geekosaur> there is *no* language where AI chat bots are a matter of just hook the right modules together and boom
13:01:47 <ertesx> quangl: for other languages many AI-related libraries are readily available…  if you don't mind reimplementing them (or writing bindings to existing C libraries), haskell is fine, but it's not economical
13:02:08 <ertesx> s/not economical/the most economical/
13:02:09 <monochrom> no, I think there is, but you need to steal Siri's source code first :)
13:02:47 <geekosaur> although there are the eliza and meta-eliza things: relatively simple things can confuse simple users into thinking there is advanced AI, and relatively simple things can confuse programmers into thinking they are harnessing advanced AI >.>
13:02:53 <dolio> Siri is a chat bot?
13:03:03 <monochrom> yes
13:04:08 <monochrom> if a certain movie is to be believed, you could even ask "what is your gender" and it would answer properly.
13:04:27 <quangl> well i need something simple
13:04:38 <quangl> because i am trying to build it myself
13:04:39 <dolio> Oh, so you need to steal the fictional source code, not the real code.
13:04:43 <monochrom> if it can do "a/s/l" it totally qualifies as a chat bot :)
13:04:52 <ertesx> what is the proper answer?
13:04:56 <ertesx> "of what gender do you want me to be?"?
13:05:14 <Fairy> "I want you to be Blue, mmm."
13:05:16 <monochrom> no, I mean it would answered directly "male" or "female". I forgot which it actually chose.
13:05:56 <monochrom> it would give a direct answer, none of those let-me-play-vulcan-logician weaseling
13:06:09 <quangl> well im pretty good at javascript
13:06:28 <quangl> do u think the same thing like haskell does can be designed the same way in javascript?
13:06:35 <quangl> like the same design in the program
13:06:43 <ertesx> quangl: not even close
13:07:08 <quangl> i mean the same functional structure not the tooling like typechecking
13:07:34 <Fairy> You can design pretty much whatever you like in Javascript, if you want it to be a simple chatbot, that's certainly possible.
13:07:42 <ertesx> quangl: neither that, because the type system plays a major role in code structure (mostly due to type classes)
13:07:51 <ertesx> quangl: also we heavily use laziness
13:08:18 <quangl> doesnt javascript do laziness too?
13:08:22 <ertesx> quangl: and as another difference we have first-class IO, which adds another functional layer that is difficult to express in JS
13:08:31 <quangl> cause its not comipled
13:08:34 <ertesx> quangl: not the way haskell does…  you basically have to emulate it
13:08:47 <quangl> ya i know
13:08:48 <monochrom> you won't reuse much of your javascript knowledge for haskell. at most you could reuse lambda, but even then you will be deleting the "return" word.
13:08:50 <quangl> that what i mean
13:08:55 <ertesx> compilation has nothing to do with it…  haskell has both a compiler and interpreter, and in both cases is lazy
13:09:01 <infandum> puregreen: As I was trying it, I realized that it would make the line so giant that it's not worth it
13:09:16 <quangl> ok
13:09:21 <infandum> because you would need to use it for each pair in the nest
13:09:24 <quangl> well i guess i have to do the tutorial
13:09:40 <ertesx> quangl: note that laziness is not an optimisation, but a composability feature
13:09:48 <monochrom> "function (x) { return (x+1); }" becomes simply "\x -> x + 1". No "return".
13:10:07 <monochrom> and that's about the only thing you can keep. you need to forget everything else.
13:10:16 <Fairy> quangl: I'm coming from a Java background, and learning Haskell (even moderately) took a lot of effort, and I still very much consider myself a newbie
13:10:20 <ertesx> > (take 3 . dropWhile (< 500) . filter even . map (^2)) [1..]
13:10:22 <lambdabot>  [576,676,784]
13:10:49 <ertesx> quangl: this code uses laziness to find the first three even squares that are greater than or equal to 500
13:11:10 <ertesx> as you see it's a programming pattern, and we use it a lot
13:11:31 <quangl> javascript has filter and map
13:11:43 <ertesx> quangl: but it doesn't have [1..]
13:11:45 <ertesx> > [1..]
13:11:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:12:16 <ertesx> you can emulate it, but it's not going to be pretty
13:13:01 <pikajude> generators in ES7:?
13:13:04 <pikajude> that's one way
13:13:17 <quangl> doesnt it?
13:13:18 <quangl> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
13:13:19 <ertesx> yeah, that might work, but generators don't compose very well
13:13:24 <quangl> isnt that the spread operator?
13:13:46 <pikajude> nah that's the enumFrom operator :)
13:13:47 <ertesx> quangl: no, [1..] is an infinite list
13:15:05 <infandum> puregreen: Ah, I got it! Instead of using FormValue, which tries to make an object...just make the object!
13:15:06 <quangl> ok
13:15:15 <quangl> cant i use a while loop?
13:15:28 <infandum> puregreen: So for each nest, use object, and instead of ":=", use ".=" and voila, it works!
13:15:32 <pikajude> you'd have to write a generator that produces that list
13:15:53 <ertesx> quangl: you can, but as a haskell programmer you shouldn't…  the list-based variant is a lot more composable and maintainable
13:15:55 <pikajude> in haskell you can pass around theoretically really big pieces of data, but the computations necessary are only done once you force their results
13:15:56 <infandum> puregreen: And it's concise!
13:16:11 <infandum> I love it when people use standards, everything works out
13:16:24 <infandum> or at least make it compatible with standards
13:16:35 <quangl> ok
13:17:19 <ertesx> quangl: read the "." as "after doing", and you will instantly understand how the code works and how to change it to do more/less/other things
13:18:12 <quangl> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator
13:18:14 <quangl> so that?
13:18:35 <quangl> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator#An_infinite_iterator
13:18:37 <quangl> rather
13:18:43 <pikajude> yeah except in javascript you have to write all the generators yourself
13:18:54 <quangl> ok
13:19:06 <ertesx> quangl: it's still not the same thing, because you still have to use loops, and they don't compose
13:19:20 <ertesx> with laziness you can use regular list functions
13:19:40 <ertesx> they aren't a special language feature, but literally just list functions
13:20:14 <hpc> the closest thing to a special language feature in haskell's [] is simply the fact that it's named []
13:20:16 <jg_> so, does Free really replace Monad & solve the monad transformer composition problem? How do you compose effects with Free?
13:20:31 <hpc> if that didn't exist, it'd be data List a = Nil | Cons a (List a)
13:20:35 <shapr> Also, you can walk several branches of lazily built multidimensional data at the same time with no extra work.
13:20:47 <Cale> jg_: uh, it doesn't solve it any more or less than monad transformers do
13:20:58 <ertesx> jg_: it doesn't replace Monad (not every monad is a free monad, and you still need Monad for the interface)
13:21:06 <Cale> jg_: Free monads are just another way of deferring the specification of how operations behave
13:21:39 <quangl> ok
13:22:16 <bitonic> is there a name for representing matrices as `newtype Matrix a = Matrix (Int -> Int -> a)`?
13:22:28 <ertesx> quangl: remember that we're talking about lists right now…  laziness works across the board, for everything, so your recursive tree traversals compose just as naturally as your list processing functions
13:22:31 <ReinH> final encoding might be one
13:22:40 <Cale> So you can write actions in a free monad, and then write various interpreters for those by taking a function f a -> IO a (for instance) and turning that into a function Free f a -> IO a
13:22:42 <EvanR> ertesx: ive run into issues using words other than "function composition" for (.), because in other langauges apparently people think reverse function application is function composition
13:22:53 <EvanR> in both cases you have "and then"
13:23:31 <ertesx> EvanR: yeah, my explanation wasn't fully precise and was only meant to demonstrate a concept
13:23:34 <jg_> right. So i still have to define how the effects compose myself in this interpreter definition?
13:23:49 <bitonic> ReinH: ah right, that is related I guess
13:24:02 <byorgey> bitonic: I might also call it an "extensional" encoding
13:24:05 <bitonic> I quite distinctly remember an evaluation of this technique for matrices, but can't find it now
13:24:08 <ertesx> jg_: you may want to play around with the 'freer' library
13:25:12 <ertesx> jg_: don't jump to conclusions though…  it has its shortcomings that only become apparent when you try to use it for larger things…  if anything i'd *combine* them with monad transformers
13:25:59 <ReinH> bitonic: or denotational design, although that might more accurately be type Matrix a = Nat -> Nat -> a (or equivalent newtype)
13:26:27 <bitonic> Let me ask a more direct question: does anybody know of an evaluation of the performance of this style for matrices?
13:26:30 <ReinH> ofc you might prefer to encode the dimensions in the type as well, so that you, e.g., multiplication is type safe.
13:26:42 <ReinH> bitonic: Well, that depends entirely on how the function is constructed.
13:27:02 <ReinH> It's a denotation for a matrix, it doesn't necessarily imply a particular implementation. You might use Array indexing under the hood.
13:27:07 <EvanR> an n x m matrix is perfectly denotational
13:27:23 <ReinH> EvanR: can matrices have negative dimensions?
13:27:26 <bitonic> ReinH: well the trade off here is between avoding intermediate results and recomputing more than necessary. E.g., when doing matrix multiplication, you have to be careful not to recompute the values that you need
13:27:29 <EvanR> nope
13:27:31 <ReinH> Ok, so Int is wrong.
13:27:41 <ReinH> EvanR: Or were you making a different point?
13:27:42 <EvanR> sure
13:27:45 <ertesx> jg_: one major shortcoming (but that's mostly a fault of the 'freer' library, not the concept) is that you can't do…  let's call it…  "spontaneous monad transforms"…  example:  you can't just evalStateT within an existing monad
13:28:01 <ReinH> EvanR: Sure, I was referring to Conal's style
13:28:02 <EvanR> i was responding to matrix = a function 
13:28:05 <ReinH> Right.
13:28:06 <EvanR> me too
13:28:08 <ReinH> Ok.
13:28:15 <bitonic> So what I mean is: did anybody research how to implement matrices in this form efficiently, and if they are faster than just using a V.Vector under the hood
13:28:26 <bitonic> Since using this style it's very easy to implement fusion
13:28:28 <ReinH> bitonic: That form doesn't have an implementation, is my point.
13:28:31 <ReinH> It's a specification.
13:28:36 <ReinH> You still have to write such a function.
13:28:40 <EvanR> functions arent always the best but he tends to lean towards them at any cost ;)
13:28:41 <ertesx> bitonic: you may want to study repa
13:28:52 <ReinH> And how you write that function will determine its efficiency.
13:29:00 <ertesx> bitonic: it has a "delayed array" representation that doesn't actually compute anything, but is actually just a function
13:29:12 <bitonic> ReinH: ...OK. Did anybody write matrices in this style, with a fast implementation, and with an evaluation of the pros and cons?
13:29:15 <ertesx> bitonic: then you "realise" such an array to an actual array, and that's when computation happens
13:29:31 <ReinH> One disadvantage is that functions are opaque, so they are impervious to user optimizations (term rewriting, etc)
13:29:37 <bitonic> ertesx: that's right -- I vaguely remember some writeup on this style, and when is best to realize, etc.
13:29:56 <bitonic> Clearly one needs to be careful to realize the right amount
13:29:57 <Cale> jg_: It is important to specify how they compose in general. There isn't an obvious way.
13:30:01 <bitonic> ertesx: I'll look at repa
13:30:07 <ReinH> bitonic: Yeah, so repa is probably your best bet for pragmatics
13:30:14 <EvanR> ReinH: also, if the denotation were Fin n -> Fin m -> a, that still doesnt mean you have to implement it with a function
13:30:30 <ReinH> EvanR: Yes, I believe I just said that three times ;)
13:30:48 <ReinH> Well, I said something slightly different.
13:30:49 <Cale> (if there were an obvious way, then any two monads would commute and the composite of monads would be a monad already)
13:30:56 <EvanR> i must have misunderstood, implementing matrices with functions because thats the denotation
13:31:01 <ertesx> bitonic: you may even want to use repa and get parallel computation for free =)
13:31:09 <ReinH> Which is that the even if that type is your denotation, the type still needs *an* implementation.
13:31:19 <bitonic> ertesx: we're kinda evaluating what to use for numerical code after some not-ideal experiences
13:31:45 <ertesx> bitonic: going from a realised ("unboxed") array to a "delayed" array (i'd really just call those functions) is a free operation
13:31:53 <ertesx> so you can just represent your matrices as delayed arrays
13:31:54 <ReinH> EvanR: But that implies that, once you decide on an implementation, you can use it directly rather than only providing its abstracted interface via that type.
13:32:00 <bitonic> We are using a typed layer on top of hmatrix right now but the code is unwieldy at times (hard to debug bugs, etc.)
13:32:10 <bitonic> ertesx: right, so repa does not really do the realization for you?
13:32:12 <EvanR> ReinH: what, how does it imply that
13:32:21 <EvanR> wouldnt that defeat the point
13:32:32 <ertesx> bitonic: it does, but you have to do it explicitly…  i think the functions are called computeS and computeP
13:32:38 <ertesx> (serial and parallel resp.)
13:32:40 <ReinH> EvanR: If I choose to use an array under the hood to implement my Int -> Int -> a, I can just expose the array itself.
13:32:47 <EvanR> o_O
13:32:49 <ReinH> And the matrix operations can take arrays.
13:32:57 <M60452[m]> fdgdfg
13:33:09 <ertesx> bitonic: also i think carter was working on something more efficient, but i don't know if it ever became a library
13:33:10 <bitonic> ertesx: right. I think we're lacking a library in Haskell that does this automatically -- I don't really want to care. I think eigen essentially does that
13:33:13 <EvanR> Int -> Int -> a is one thing, and if you provided an array directly isntead, you would go out of bounds
13:33:36 <EvanR> and the interface is totally different
13:33:36 <ReinH> EvanR: You would with Int -> Int -> a as well
13:33:53 <EvanR> not if Int -> Int -> a is "really a function"
13:33:56 <ertesx> bitonic: that would require the library to read your mind unfortunately (or solve the halting problem), because it needs domain-specific information to know when it's best to compute
13:33:57 <ReinH> I already said I would prefer to restrict the dimensions via types
13:34:03 <ReinH> I was just using the example provided
13:34:06 <EvanR> also i came into this at the Nat part so
13:34:09 <ReinH> Ah.
13:34:30 <bitonic> ertesx: libraries can make choices that work in the common case. It's a best effort thing. Eigen works really well and makes choices in that sense
13:35:01 <EvanR> you pick function denotations if you expect to be just applying it to stuff
13:35:12 <ReinH> Well, or to guide implementations
13:35:23 <EvanR> but more powerful function-like things can do other things like map certain stuff backwards
13:36:02 <ertesx> bitonic: well, sure, but computing is as simple as applying computeP…  if getting the best possible performance is not your main concern, you can just apply computeP after every other array operation
13:36:34 <ertesx> bitonic: going back and forth between delayed and unboxed arrays is kind of a common thing in repa
13:37:04 <EvanR> like invertible matrices
13:37:19 <EvanR> and then you have conals memotries thing
13:37:46 <bitonic> ertesx: what I'm asking for is a study of these styles, with suggestions on when to use what
13:38:22 <ReinH> EvanR: Right, probably we should be doing everything with profunctors. ;)
13:38:46 <ReinH> Or adjunctions.
13:38:56 <ertesx> bitonic: i'm not aware of any, sorry…  as i said, carter was doing a lot of work in the area of data-parallel arrays, so you may learn something from him (or even get a better library recommendation than repa)
13:39:12 <bollu> ReinH: "…we should be doing everything with profunctors..."?
13:39:16 <ReinH> Functions are especially useful for categorical reasoning in Haskell because they carry internal homs.
13:39:54 <EvanR> function types carry internal homs? or
13:39:59 <ReinH> EvanR: yes.
13:40:01 <EvanR> trying to unpack that
13:40:13 <ReinH> Hask(X,Y) <=> x -> y
13:40:21 <ReinH> er X -> Y
13:40:22 <ertesx> bitonic: the only thing i can tell you from personal experience is that functions are really cheap to the point that i would go with the functional representation *by default*, unless i need extra structure
13:40:54 <cheater> for a developer, is ecc memory at all necessary? will it improve the stability i experience?
13:41:03 <ReinH> or, forall x.y. Hask(x,y) <=> x -> y
13:41:33 <EvanR> right
13:41:38 <ReinH> EvanR: This is why, e.g., the Category and Adjunction typeclasses use the internal hom representation of categories and adjunctions, respectively.
13:41:54 <ReinH> It falls out naturally from the fact that Hask is closed
13:42:07 <ReinH> (Platonic Hask, that thing which is apparently totally not a real category)
13:42:22 <bitonic> cheater: I like ECC memory. There's already so much that can go wrong with computers, it's nice to exclude one source of chaos 😌
13:43:41 <cheater> right, but are there actual reasons to use it?
13:43:44 <ertesx> cheater: imagine that you encrypt something and in the middle of the key derivation function somewhere a bit flips
13:44:08 <cheater> ertesx: i think our imagination can come up with a lot of stuff - i'm looking for data
13:44:11 <ertesx> now your ciphertext is basically a string of random bits =)
13:44:14 <eell> Should I learn haskell? What is it good for? I know some JAVA, C, and Python.
13:44:30 <shapr> cheater: I recently read that at 128gb of ram, the probability of random bit flips due to cosmic rays makes ECC worthwhile
13:44:32 <cheater> eell: yes, you should. it's good for everything!
13:45:01 <erisco> it is good for impressing friends at parties
13:45:14 <cheater> shapr: but aren't those bit flips mostly going to be somewhere in a website's html or the latest episode of black mirror?
13:45:29 <bitonic> eell: Haskell is good if you want to make a lot of money in fintech but a bit over the hill as a language if you ask me
13:45:31 <eell> Oh yes, the parties, and the friends I have
13:45:33 <eell> haha
13:45:41 <shapr> bitonic: over the hill?
13:45:52 <monochrom> ECC was hot 15 years ago. Then what happened: Fraudulent PC sellers lied about "I have put in ECC", and no one could tell the difference objectively.
13:46:03 <ertesx> eell: try this: ask here whether learning python is a good idea, and at the same time ask in #python whether learning haskell is a good idea =)
13:46:17 <EvanR> heh
13:46:25 <eell> lel
13:46:49 <shapr> eell: I recommend learning both!
13:47:09 <eell> "Is learning Python a good idea"
13:47:34 <shapr> eell: yes!
13:47:34 <ertesx> i recommend learning python…  not to write python code, but to be able to read about 90% of server-side code nowadays
13:47:41 <ggVGc> no, learning anything is a waste of time. In a decade everyone will know everything through instant cloud lookups
13:47:42 <eell> I'm having to learn a lot of python at the moment
13:48:11 <eell> as an interface to do data analysis and use C code in the background
13:48:11 <johnw> that 90% sounds like a completely bogus number ;)
13:48:23 <hpc> i recommend learning python in order to know how good you have it in a language with types
13:48:36 <shapr> hpc: hah! That's my daily experience :-/
13:48:49 <bshelden> Also learn Scala to find out why it's important to go all the way.
13:48:52 <ggVGc> hpc: Python has pretty strong types... just not static
13:48:53 <ggVGc> !
13:48:55 <ertesx> johnw: the number is satirical =)
13:49:02 <hpc> merijn was having some bad times with it last week too
13:49:19 <hpc> ggVGc: that's the worst combination!
13:49:25 <ertesx> learn scala to see how *not* to be inspired by haskell
13:49:32 <cheater> monochrom: do you believe there is a reason to use ecc if i'm a haskell programmer?
13:49:38 <monochrom> No
13:49:48 <hpc> i consider perl's type system to be safer than python's
13:50:02 <hpc> because there are fewer surprises at runtime that could have been caught at compile time
13:50:13 <monochrom> I am willing to believe "128GB RAM" may be a reason to. But "haskell" is not.
13:50:24 <hpc> (it's certainly marginal, but perl does have a slight edge)
13:50:44 <monochrom> or "my RAM clock speed is 5GHz" could also be a reason.
13:50:49 <ReinH> monochrom: but is Haskell a reason to have 128GB RAM? >_<
13:51:01 <ertesx> ReinH: yes!
13:51:05 <monochrom> No.
13:51:14 <ReinH> Yes! Or also no!
13:51:20 <ReinH> I mean, like you need a reason
13:51:21 <monochrom> Instead, that whole-program optimizing ML compiler may be.
13:51:33 <ongy> I need a reason for more ram? that's news to me
13:51:34 <ReinH> monochrom: Well, compiling lens is a reason to want at least 8GB.
13:51:43 <ReinH> esp. with TH turned on
13:51:52 <kaste> hpc: https://youtu.be/gweDBQ-9LuQ yeah
13:51:55 <monochrom> I still remember 20 years ago when the MLton said "you just need 128MB"
13:52:02 <ertesx> using a long-running GHCi session is also a reason to want at least 4 GiB
13:52:16 <ertesx> using three of them at the same time…  you get the idea
13:52:18 <monochrom> 8GB is not 128GB
13:52:32 <ReinH> monochrom: Yes, but one can extrapolate...
13:52:43 <dmj`> is it possible to add a js-sources block in a test-suite?
13:52:47 <monochrom> my desktop has 12GB but it is still not 128GB and I don't think I have ECC
13:53:13 <bitonic> eell: Haskell is also good if you want to ramp up towards a dependently type language like C++
13:53:22 <bitonic> (just kidding, you should totally learn Haskell)
13:53:50 <eell> Unfortunately all these CompSci definitions (ie dependently type) are lost on me
13:54:06 <EvanR> true haskell can harden you to be able to do C++
13:54:12 <ReinH> a dependently typed language like what
13:54:13 <ertesx> eell: don't worry about it…  you should learn haskell =)
13:54:24 <ReinH> monochrom: keep extrapolating :p
13:54:27 <monochrom> you know what, I am agnostic to ECC vs not-ECC. But if you buy ECC, make sure you're buying real ECC, not the fraudulent kind where they give you non-ECC and claim to be ECC
13:54:35 <eell> Do you mean how C is very specific on type definition, etc?
13:54:36 <ReinH> Which, I mean, how do you do that.
13:54:53 <monochrom> I just wanted to note that 15 years ago it turned out to not matter.
13:55:08 <ertesx> eell: haskell is a good language to know, even if you only ever use it for your own projects
13:55:21 <monochrom> I learned from history and I am doomed to helplessly watch it repeat again.
13:55:29 <ongy> monochrom: I think the rowhammer attack showed that ECC matters in some cases
13:55:37 <bitonic> ReinH: C++ is great at types dependent on values, like numbers
13:55:45 * bitonic misses eigen in Haskell
13:55:46 <eell> Well it has a nice ring to it. Where should I get started. Do you recommend any courses
13:56:04 <monochrom> oh! yeah, I heard of rowhammer too.
13:56:57 <ertesx> eell: this should be a good introduction: http://www.cs.nott.ac.uk/~pszgmh/pih.html
13:57:02 <monochrom> But the thing is if you prescribe ECC you need to know how to open up the computer and check that you're really getting it. Some sellers can be really fraudulent.
13:57:30 <hpc> kaste: ah yes, CGI - that bug may be 20 years old but CGI has been known by the community to be bad for just as long
13:57:31 <ertesx> eell: there are also some free resources of varying quality…  you can try the following:  the haskell wikibook, real world haskell, learn you a haskell
13:57:38 <hpc> kaste: all you have to do is somehow also know this, and you'll be fine
13:57:47 <hpc> ;)
13:57:56 <ongy> monochrom: I'm pretty sure the bios (or efi these days) tells you about whether it's ecc
13:58:02 <monochrom> How much you need ECC can change over time. How hard the sellers try to screw you does not change over time.
13:58:22 <ongy> and iirc linux also does somewhere. So unless the ECC is not ecc from the ram manufacturer it should be visible somewhere in software
13:58:25 <bollu> mother fucking god, failure to list of successes is so beautiful
13:58:29 <bollu> you can parse in like 30 LOC
13:58:31 <bollu> what the fuck
13:58:33 <bollu> it's so elegant
13:58:36 <eell> thanks ertesx. I'll also try to check my library
13:58:50 <bollu> how does something so adorable have the right to exist? argh!
13:59:12 <bollu> like, I've known the idea for a while, but this is the first time I've sat down and implemented it
13:59:14 <ertesx> eell: these: https://en.wikibooks.org/wiki/Haskell, http://learnyouahaskell.com/, http://book.realworldhaskell.org/
13:59:23 <monochrom> ongy: If you buy a built PC from one vendor, that vendor can also get their hands on the BIOS too, no?
13:59:34 <ReinH> bollu: Wadler's pretty smart eh
13:59:45 <bollu> ReinH: yes
14:00:09 <monochrom> But of course if Linux can do the test too, you can trust that test, it's your copy of Linux.
14:00:23 <ReinH> modulo trusting trust, ofc
14:00:29 <bollu> where is <|> defined? I'm too sleepy to hoogle
14:00:35 <hpc> Alternative
14:00:40 <EvanR> fix trusting
14:01:00 <puregreen> bollu: Control.Applicative
14:01:01 <ongy> monochrom: I think the test in linux just askes the bios (or is it a special CPU register?). But this is getting a bit long for off topic
14:01:15 <monochrom> well yeah I'm not going to sound paranoid about 3rd-order scamming schemes such as "Dell may be intercepting your internet to give you abridged Linux downloads"...
14:01:22 <ertesx> eell: also hang around here…  #haskell is a great resource for learning haskell (most of the time)
14:01:29 <bollu> puregreen: ty
14:01:37 <dcoutts> shapr: that marks you out as an oldie ;-)  pre-cabal eh?
14:03:16 <bollu> what's the semantics of <|> on parsers? if both work, use both? or short-circuit?
14:03:21 <bollu> which one is law abiding?
14:03:32 <bollu> I think short circuit, right?
14:03:36 <Tuplanolla> The first one is favored, bollu.
14:03:44 <EvanR> > Nothing <|> Just 'c'
14:03:46 <lambdabot>  Just 'c'
14:03:57 <EvanR> > Just 'a' <|> Just 'c'
14:03:59 <lambdabot>  Just 'a'
14:04:02 <dcoutts> doesn't it depend on the parse lib?
14:04:10 <Cale> Both are law abiding.
14:04:11 <ab9rf> no, <|> always favors the left 
14:04:13 <ertesx> bollu: for applicative parsers you can do both, but most parser implementations do left-catch
14:04:22 <Cale> and yeah, it depends on the library
14:04:29 <ertesx> monadic parsers get no choice though:  it's left-catch
14:04:35 <Cale> hm?
14:04:41 <dcoutts> ReadP does both
14:04:45 <dcoutts> and it's monadic
14:04:51 <Cale> ReadP is symmetric, Attoparsec is symmetric
14:04:59 <bollu> Cale: from what law?
14:05:03 <ertesx> hmm?  i'm thinking of left-dist Either, which is not a monad
14:05:16 <ertesx> instance (Monoid e) => Applicative (Either e)
14:05:17 <bollu> Cale: like, prove to me that it's forced to be left-catch
14:05:25 <bollu> ertesx: ^
14:05:29 <bollu> wrong person :)
14:05:33 <ab9rf> hm, yes, hyou're right
14:05:39 <ab9rf> it is implementation dependent
14:05:54 <ab9rf> i recall running into this when i swtched a parser from parsec to attoparsec once
14:06:08 <ertesx> bollu: we may have different notions of "both", so perhaps it would be best to show some code =)
14:06:26 <bollu> ertesx: right now, I'm doing left catch :) in that, if left fails, then return right
14:06:33 <Cale> Well, the canonical simple parser implementation is
14:06:37 <bollu> ertesx: but I could also do both left and right and then merge the outputs
14:06:48 <ertesx> bollu: "merge" how?
14:06:50 <Cale> newtype Parser a = P { String -> [(String, a)] }
14:06:57 <ertesx> bollu: return both?
14:07:07 <Cale> and for that, you have  P f <|> P g = P (\s -> f s ++ g s)
14:07:16 <bollu> ertesx: yes, (++) the lists
14:07:30 <Cale> (typically)
14:07:40 <bollu> Cale: so what if you want short circuiting behaviour?
14:08:01 <Cale> P (\s -> case f s of [] -> g s; ps -> ps)
14:08:02 <ab9rf> bollu: use a combinator that doesn't look at the right value if the left value satisfies
14:08:22 <ertesx> ok, there was a misunderstanding then…  i consider even the (++) semantics "left-catch"
14:08:33 <Cale> That's not left catch though...
14:08:37 <Cale> That's distributive
14:09:24 <Cale> i.e. (x <|> y) >>= f = (x >>= f) <|> (y >>= f)
14:10:08 <ertesx> yeah, it is…  i had a parser definition that wasn't a monad though, and it was because of the way i combined errors
14:10:23 <ertesx> that's why i'm thinking of left-dist Either
14:12:36 <bollu1> uh, I DC'd from the channel
14:13:01 <bollu1> so, from what I gather, the choice is for <|> to do "both" when the parsing style is applicative, and short circuit when monadic?
14:13:17 <ertesx> bollu1: not necessarily
14:13:40 <EvanR> in what sense does it do both?
14:14:18 <EvanR> if you mean, it might try the second one, that sounds like short circuit
14:14:24 <bollu1> EvanR: in the sense of (++) - concatenates after trying both
14:14:42 <bollu1> ertesx: so, what do you pick?
14:14:44 <EvanR> in what case does <|> act like (++)
14:14:46 <ertesx> bollu1: it's best that you implement the semantics you want and verify the laws
14:15:11 <monochrom> Text.ParserCombinators.ReadP does the equivalent of (++) and is monadic.
14:15:12 <bollu1> ertesx: in the "combine together without short circuiting" case
14:15:21 <bollu1> ertesx: precisely, I don't know the laws behind Alternatice
14:15:24 <bollu1> Alternative*
14:15:24 <ertesx> bollu1: it seems that the reason my parser wasn't a monad was because of the way i handled *errors*, not results
14:15:48 <ertesx> but it's at least 3 years ago
14:41:27 --- mode: ChanServ set +o glguy
14:42:58 <Hijiri> I just noticed that "const" has the same character count as "\_ ->"
14:43:37 * hackagebot happstack-authenticate 2.3.4.6 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.4.6 (JeremyShaw)
14:43:40 <glguy> > map length ["const 1", "\_->1"]
14:43:42 <lambdabot>  <hint>:1:26: error:
14:43:42 <lambdabot>      lexical error in string/character literal at character '_'
14:43:50 <glguy> > map length ["const 1", "\\_->1"]
14:43:52 <lambdabot>  [7,5]
14:44:42 <Tuplanolla> > map length ["const 1 2", "(\\_->1)2"]
14:44:44 <lambdabot>  [9,8]
14:45:05 --- mode: ChanServ set +o Cale
14:45:08 <glguy> in that case use "pure"
14:46:25 <erisco> let k = const
14:47:51 <EvanR> why are we +oing
14:48:16 <ongy> EvanR: global notice about service maybe unavailable
14:48:27 <EvanR> oh
14:49:00 <ongy> they are doing a lot of work on the network lately
15:01:33 <jle`> @tell bollu1 the laws for Alternative are pretty simple, they're actually the same laws for Monoid, if you are familiar with those :)
15:01:33 <lambdabot> Consider it noted.
15:02:11 <jle`> Hijiri: yeah, for a while i was trying to push to get sections to work so i could pass in (\_->) where a function would expect 'const'
15:02:52 <jle`> head = foldr (\_->) undefined
15:19:13 <plakband> Does anyone know of a Yampa IRC channel?
15:19:44 <plakband> I know some other frameworks have onve but I can't find one for Yampa
15:19:58 <hiptobecubic_> Is yampa still alive?
15:20:09 <hiptobecubic_> I haven't really heard about it since Frag
15:20:50 <EvanR> it exists
15:20:58 <plakband> Is Yampa deprecated?
15:21:00 <EvanR> you might get the most help from #haskell-game
15:23:09 <plakband> EvanR: Is Yampa especially suited for games? I'm not working on a game, it looked like a decent all-round FRP framework?
15:23:43 <EvanR> i thought it was for games, "Yampa Arcade"
15:23:49 <EvanR> though i havent seen anything that used it
15:27:18 <EvanR> i mentioned #haskell-game because theres a variety of FRP experts in there, on different libs
15:28:53 <plakband> EvanR: I'll give that a try, thanks
15:35:40 <codedmart> I all the sudden started getting this when I `stack build` -> http://lpaste.net/256484
15:47:51 <codedmart> Nevermind I see I am dumb.
15:52:05 <the_2nd> looking for nice example usages of the free monad
15:52:22 <the_2nd> saw a blog entry somewhere using it for a DSL, but can't find it anymore
16:00:16 <Gurkenglas> I remember being annoyed by the amount of people posting those to the subreddit so https://www.reddit.com/r/haskell/search?q=%22free+monad%22+dsl&restrict_sr=on&sort=relevance&t=all
16:04:51 <the_2nd> Gurkenglas, thanks
16:11:16 <sigrlami> how to get full raw request in Servant?
16:30:33 <Guest51457> @pl 3
16:30:34 <lambdabot> 3
16:30:55 <Guest51457> @pl \x -> mod x 2 == 0
16:30:55 <lambdabot> (0 ==) . flip mod 2
16:43:39 * hackagebot distributed-process 0.6.5 - Cloud Haskell: Erlang-style concurrency in Haskell  https://hackage.haskell.org/package/distributed-process-0.6.5 (FacundoDominguez)
16:43:41 * hackagebot distributed-process-tests 0.4.7 - Tests and test support tools for distributed-process.  https://hackage.haskell.org/package/distributed-process-tests-0.4.7 (FacundoDominguez)
16:43:43 * hackagebot sqlite-simple-errors 0.4.0.0 - Wrapper around errors from sqlite-simple  https://hackage.haskell.org/package/sqlite-simple-errors-0.4.0.0 (jmc41493)
16:46:37 <Hafydd> Did @pl just assume that == is symmetric?!
16:47:02 <Koterpillar> it seems so
16:48:11 <lordcirth> Are there cases where == isn't?
16:48:12 <grantwu> It should be, shouldn't it?
16:48:20 <grantwu> lordcirth: I mean you can make an instance which isn't
16:48:33 <lordcirth> grantwu, but that would be horrifying
16:48:41 <grantwu> But I feel like that is on you
16:49:15 <nshepperd1> I'm sure there are cases, but if you write one you deserve lambdabot breaking your code
16:49:26 <Koterpillar> interestingly http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Eq.html#t:Eq does _not_ list the laws
16:49:34 <grantwu> Koterpillar: I think there is a bug for that
16:50:09 <lordcirth> Reminds me, a friend once showed me that in C, foo[5] was the same as 5[foo] due to pointer addition.  He then said that if I ever did that in code he had to read he would break my fingers.
16:50:20 <grantwu> Koterpillar: https://sites.google.com/site/thefaceofamazon/
16:50:32 <grantwu> er..
16:50:35 <grantwu> https://ghc.haskell.org/trac/ghc/ticket/12519
16:50:59 <grantwu> As far as mispastes go, that one was pretty tame
16:51:23 <ertesx> don't confuse symmetry with commutativity though
16:51:25 <Koterpillar> where does it talk about the laws?
16:51:49 <ertesx> C's [] is commutative (a[b] = b[a]), while (==) is (should be) symmetric (x == y → y == x)
16:51:50 <grantwu> Koterpillar: I mean, I assume that once the haddock bug gets fixed
16:52:01 <grantwu> The laws will be there
16:52:07 <grantwu> Well hrm
16:52:14 <Koterpillar> ertesx: this is the same as (x == y) == (y == x)
16:52:28 <grantwu> I guess laws are usually documented in the typeclass and not under the methods?
16:53:48 <Koterpillar> I would have thought so
16:54:33 <Hafydd> @pl \x -> x == x
16:54:33 <lambdabot> join (==)
16:54:38 <ertesx> Koterpillar: but (x == y) == (y == x) is a value, not a theorem
16:54:55 <ertesx> s/theorem/proposition/
16:55:07 <ReinH> Symmetry and commutativity are very nearly the same thing
16:55:23 <Koterpillar> AFAIR you can override operator[]
16:55:32 <kadoban> Not in C
16:55:33 <nshepperd1> Anyway, only a monster would use flip (==) in real code
16:55:39 <ertesx> they differ in subtle ways, and i'd say you have to suffer from boolean blindness to view them as the same
16:55:59 <erisco> :t liftA2 (==) <$> (==) <*> flip (==)
16:56:00 <lambdabot> Eq a => a -> a -> Bool
16:56:06 <ertesx> nshepperd1: do you write (filter (== 3)) or (filter (3 ==))? ;)
16:56:40 <Hafydd> The difference doesn't seem very subtle to me: symmetry is a property of relations, while commutativity is a property of algebraic operations.
16:56:54 <nshepperd1> ertesx: it depends if I've had my coffee that day :>
16:57:19 <ReinH> And relations are...
16:57:50 --- mode: glguy set -o glguy
16:58:51 <Hafydd> A relation (in Haskell terms) is a function r :: a -> a -> Bool, while an algebraic operation is :: a -> a -> a.
16:58:54 <ReinH> Both are Cartesian pairs. The main difference is that commutativity is closed.
16:58:57 <ertesx> Commutative f = ∀ x y → f x y ≡ f y x;  Symmetric R = ∀ x y → R x y → R y x
16:59:46 <ertesx> notably symmetry doesn't actually involve equality, and for good reason
17:00:02 <Hafydd> ReinH: what is a "Cartesian pair"?
17:00:21 <nshepperd1> That definition of symmetry could just as well use biimplication
17:00:50 <ReinH> An element of a 2-ary Cartesian product
17:01:21 <Hafydd> ReinH: what element of which Cartesian product is (==)?
17:01:31 <ReinH> Symmetry is a property if (a,a) -> b while commutativity is a property of (a,a) -> a
17:01:55 <ReinH> http://math.stackexchange.com/questions/803614/commutative-vs-symmetric
17:02:30 <ydl> is there a memoization scheme in Haskell that uses an O(1) time access structure? basically something using a data structure as efficient as a hashtable? all the solutions i have seen are functional (great!) but use data strcutures with O(n) (lazy lists) or O(log n) (lazy trees) access time. i am fine with unsafePerformIO/ghc specific hacks. since the functions to be memoized are true pure functions (memoization is an implementation
17:02:30 <ydl> detail) i don't want to have them live in a monad of any sort. 
17:03:00 <ertesx> but this whole discussion is actually moot, because Eq is not the class of equivalence relations, but the class of blind decision procedures
17:05:35 <ReinH> Hafydd: I don't see how my argument entails such a claim about (==)
17:06:19 <Hafydd> ReinH: you said "both are Cartesian pairs," presumably talking about both relations and algebraic operations.
17:06:38 <kadoban> ydl: Did you try the O(lg n) ones and they were actually too slow? Not sure how best to express this, but ... at this level of detail, I question how much asymptotic notation is actually useful. I can give arguments why it's not, if interested.
17:07:04 <Hafydd> ReinH: so it follows that (==) is "a Cartesian pair".
17:07:26 <ReinH> I don't see how that follows
17:07:35 <ertesx> Hafydd: whether (==) is a decision function or an equivalence relation, (==) is in both cases a function
17:08:12 <grantwu> ydl: http://t0yv0.blogspot.com/2009/01/haskell-memoization-with.html this looks like it might be helpful?
17:08:41 <Hafydd> ReinH: perhaps you meant: "both relations and algebraic operations are subsets of Cartesian products," which is true according to some constructions.
17:09:01 <yulax> hej folks
17:09:07 <ReinH> Yes, it was worded poorly.
17:09:31 <yulax> i have a problem to solve, and i dont know how the types work
17:09:33 <yulax> https://paste.debian.net/hidden/77af2e92/
17:09:59 <yulax> essentially, the task regards the caesar cypher
17:10:14 <erisco> how do you prevent space leaks with memoisation
17:10:14 <ydl> kadoban: what do you mean asymptotic notation is not useful? this is the way you talk about the characteristics of datastructures, i know no other way
17:10:24 <ertesx> yulax: you claimed that the result of that function is a Char
17:10:40 <ertesx> yulax: but in line 4 you want it to result in something that is not a Char
17:10:43 <yulax> ertesx: yes, it gives a corresponding character
17:10:49 <yulax> yea
17:10:54 <erisco> the only reasonable way is with something like a Monad
17:11:28 <ertesx> yulax: so either the type is wrong, or the implementation is wrong…  which one depends on what you actually had in mind
17:12:02 <Axman6> yeah that code doesn't type check
17:12:03 <ertesx> yulax: a caesar cipher is just a rotation by a key…  ideally you would write it for single characters (not lists), then just use 'map' to lift it to lists
17:12:23 <ReinH> kadoban: once you fix n to your current problem size, everything is constant
17:12:31 <ertesx> yulax: example type: caesar :: Int -> Char -> Char
17:12:32 <yulax> ertesx: it looks up a corresponding character in a given cilher
17:12:51 <ertesx> yulax: so this is more generally a substitution cipher
17:13:07 <yulax> so i have already got a list 
17:13:36 <kadoban> ReinH: Exactly.
17:13:45 <ertesx> yulax: ok, say you want to encrypt 'v'
17:13:56 <ertesx> yulax: your substitution table includes ('v', 'e')
17:13:59 <yulax> like https://paste.debian.net/hidden/1b6eaa59/
17:14:03 <ertesx> yulax: what should the result be?
17:14:05 <ReinH> But often we care how our solutions scale too
17:14:10 <yulax> i already give this to the func
17:14:33 <yulax> and then, when i want to look up a char in that list i use this function
17:15:13 <yulax> this isn't meant to be creating a cipher table
17:15:28 <yulax> it is looking up a corresponding char on the table
17:15:38 <yulax> and i get a type erre
17:15:42 <yulax> for instance
17:15:55 <Axman6> yulax: you're returning a list of characters though, look at like 4
17:16:01 <Axman6> (:) creates a list
17:16:05 <yulax> right
17:16:05 <ertesx> yulax: that's the same thing…  even if you're trying to implement caesar, the function lookUp is (should be, once the error is fixed) a table-based substitution function
17:16:07 <ydl> grantwu: interesting, but i think this function might create an unbounded number of cacheRefs for recursive f. something of that sort might be promising though
17:16:28 <Axman6> so you're returning snx x : lookUp c xs, which is not a single character
17:16:59 <ertesx> yulax: now answer the question:  lookUp 'v' (makeKey 1) = ?
17:17:01 <Axman6> yulax: so, onve you've found the substitution, why do you keep looking through the list by calling lookUp again?
17:17:17 <yulax> ok it works by removing the : and anything after
17:17:38 <yulax> thanks everyone!
17:17:45 <Axman6> yulax: do you understand why it works?
17:17:47 <ertesx> yulax: do you understand why it works now and didn't work earlier?
17:17:52 <yulax> yes
17:17:56 * Axman6 great minds
17:17:58 <yulax> i understand
17:17:59 <ertesx> hehe
17:18:19 <ertesx> it's almost like #haskell is a superhive of swarm intelligence
17:18:48 <Axman6> we are one under lambda
17:19:08 <ertesx> we see the groupoid
17:19:19 <yulax> it checks if the character is in a given 1st term in a tuple in a list of tuples, and if so prints the corresponding second term
17:19:32 <yulax> if not, it tries the next tuple
17:19:50 <Axman6> almost, it doesn't print anything though
17:21:30 <ertesx> @let letter l c | isAsciiUpper c = (\x -> chr (mod x 26 + ord 'A')) <$> l (ord c - ord 'A') | isAsciiLower c = (\x -> chr (mod x 26 + ord 'a')) <$> l (ord c - ord 'a') | otherwise = pure c
17:21:32 <lambdabot>  Defined.
17:21:52 <ertesx> > (traverse . letter +~ 13) "Hello World!"
17:21:54 <lambdabot>  "Uryyb Jbeyq!"
17:22:49 <Axman6> @let l337cryp70h4x = letter
17:22:50 <lambdabot>  Defined.
17:23:21 <Axman6> remember, we need to give things meaningful names so java developers can understand
17:24:02 <ertesx> i don't see "business" or "enterprise" in that name though
17:25:03 <Axman6> @let l337cryp70h4xFactoryDelegateSingleton = letter
17:25:04 <lambdabot>  Defined.
17:25:29 <nshepperd1> With an encryption function like that my bank details are sure to be safe
17:26:24 <Axman6> yes, because you can choose any SafeEncryptionParameter from zero up to and including 26!
17:26:43 <c_wraith> triple rot-13
17:26:54 <c_wraith> It worked for DES!
17:26:58 <ertesx> @let businessEnterpriseChunkFacade n l = go where go [] = pure mempty; go xs = liftA2 (<>) (l pfx) (go sfx) where (pfx, sfx) = splitAt n xs
17:27:00 <lambdabot>  Defined.
17:27:00 <Axman6> prime numbers are not advised, because they don't have enough factors to be safe
17:27:07 <ReinH> I recommend 26
17:27:28 <Clint> 26 is my favorite prime number
17:27:39 <ertesx> > (businessEnterpriseChunkFacade 5 . ix 0 . l337cryp70h4xFactoryDelegateSingleton +~ 13) "Hello Business People!"
17:27:41 <lambdabot>  "Uello Busiaess Ceoplr!"
17:27:47 <ReinH> Chosen by fair dice roll, guaranteed random
17:27:53 <kadoban> 27 is my favorite prime
17:27:55 <red13> i wrote a nice program which finds the factors of a prime number if you want Axman6
17:27:55 <ertesx> vijavaenere
17:27:58 <c_wraith> @let factorLargePrime :: Integer -> [Integer] ; factorLargePrime x = [x]
17:27:59 <lambdabot>  Defined.
17:28:36 <ReinH> c_wraith: surely this will vitiate the crypto community
17:28:39 <red13> my computer uses prime basis instead of binary
17:29:08 <ReinH> Binary is a prime basis
17:29:29 <red13> ReinH, those guys dont mess around, they hack your keyboard and screen mostly. banks using ipads are not secure
17:30:24 <ertesx> why did i write that function in such a stupid way?
17:30:41 <red13> 011 * 7 = 077
17:30:42 <ertesx> it's getting laid
17:30:43 <ertesx> late
17:30:49 <ertesx> wow, i really need to sleep
17:32:30 <Axman6> XD
17:34:00 <red13> how to monetize a haskell program, is possible?
17:34:30 <jle`> presumably the same way you'd monetize any other program?
17:34:51 <Axman6> red13: I get paid to write haskell programs, does that count?
17:35:01 <jle`> if you wrote the same program in two different languages, and wanted to monetize the program, then the language isn't the important part
17:35:02 <red13> other languages can be released on play store, i wondered if there was a way haskell programs could be marketed
17:35:05 <jle`> it's what the programs do :o
17:35:05 <cath__> I have a stack project that pulls some commits from github repo.  Once every 4 compiles or so, it decides that some local files have changed (they haven't) and proceeds to reclone and compile everything.  Anyway to tell it not to do this?
17:35:19 <red13> Axman6, you lucky
17:35:43 <Axman6> cath__: talk to it very sternly and say "stop it, you're being silly"
17:35:50 <Axman6> it probably won't help but it will feel good
17:36:02 <jle`> red13: haskell programs can be sold anywhere other programs can be sold, for the most part
17:36:13 <cath__> I've done so in harser terms than that.  it doesn't help
17:36:19 <red13> i cant compile using adk so cant release on play store
17:36:21 <Axman6> (also #haskell-stack might be a bit more helpful)
17:36:26 <cath__> thx
17:36:28 <red13> apk*
17:36:49 <jle`> red13: you can write it to javascript & html5 and just release it as a thin wrapper over a webpage 
17:37:03 <jle`> red13: but also some people have had success compiling haskell to jvm for android app store too
17:37:08 <red13> can i get a link?
17:37:29 <jle`> haskell compiles to javascript too :o
17:37:38 <jle`> and you could use something like phonegap
17:37:39 <ertesx> > blocks n l = foldr (liftA2 (<>) . l) (pure []) . unfoldr (\xs -> do r@(_:_, _) <- pure (splitAt n xs); pure r)
17:37:41 <lambdabot>  <hint>:1:12: error:
17:37:41 <lambdabot>      parse error on input ‘=’
17:37:41 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
17:37:41 <jle`> http://phonegap.com/
17:37:44 <ertesx> @let blocks n l = foldr (liftA2 (<>) . l) (pure []) . unfoldr (\xs -> do r@(_:_, _) <- pure (splitAt n xs); pure r)
17:37:46 <lambdabot>  Defined.
17:37:47 <red13> i found ghcvm but it wast clear if it worked with gradle
17:37:50 <Axman6> actually, Manueal's Haskell for Mac is a good example of monetising Haskell
17:38:04 <ertesx> > (blocks 3 . ix 0 . letter +~ 13) "Hello world!"
17:38:06 <lambdabot>  "Uelyo joryd!"
17:38:08 <ertesx> better
17:38:25 <ertesx> though that one almost looks like code golf
17:38:35 <Axman6> Manuel's*
17:39:39 <RouxTheDay> What is +~? Couldn't find it on hoogle
17:39:56 <Koterpillar> RouxTheDay: something from lens?
17:39:58 <c_wraith> RouxTheDay: it's part of lens
17:39:59 <jle`> it's from lens
17:40:03 <red13> phonegap looks pretty good, has anyone managed to use it with haskell?
17:40:06 <Axman6> :t (+~)
17:40:07 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
17:40:12 <jle`> (+~ n) is the same as (%~ (+n))
17:40:16 <jle`> ... if that helps
17:40:19 <RouxTheDay> Ty ty
17:40:28 <RouxTheDay> Haha it doesn't, but I'll look that other one up
17:40:29 <Axman6> it's ++ basically (from C et al.)
17:40:41 <ertesx> more like +=
17:40:46 <Axman6> uh, yes
17:41:06 <ertesx> @let leftComponent = _1
17:41:07 <lambdabot>  Defined.
17:41:07 <red13> C+~
17:41:09 <jle`> RouxTheDay: if you think of (blocks 3 . ix 0 . letter) as a way to modify parts of "hello world", then `%~ f` lets you apply 'f' to the parts you're modifying
17:41:17 <ertesx> > (leftComponent +~ 5) (15, "blah")
17:41:19 <lambdabot>  (20,"blah")
17:41:31 <ertesx> RouxTheDay: does this example make sense?
17:41:32 <jle`> (blocks 3 . ix 0 . letter) modifies every third letter as if it were its ASCII code for the most part
17:41:52 <RouxTheDay> :t ix
17:41:53 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
17:42:06 <jle`> so `(blocks 3 . ix 0 . letter) %~ (+13)` adds 13 to the ascii code of every third letter
17:42:08 <red13> > (\(a,b)->(a+5,b)) (15, "blah")
17:42:11 <lambdabot>  (20,"blah")
17:42:50 <RouxTheDay> Ah okay, that makes a certain amount of sense
17:43:02 <jle`> > (blocks 3 . ix 0 %~ toUpper) "hello world how are you"
17:43:04 <lambdabot>  "HelLo WorLd How arE yOu"
17:43:41 * hackagebot sqlite-simple-errors 0.5.0.0 - Wrapper around errors from sqlite-simple  https://hackage.haskell.org/package/sqlite-simple-errors-0.5.0.0 (jmc41493)
17:44:00 <RouxTheDay> What's the purpose of ix?
17:44:14 <jle`> 'ix 0' focuses on the first item
17:44:29 <jle`> "blocks 3" lets you operate on chunks of 3 items in the list
17:44:36 <jle`> 'ix 0' focuses that to the first item in those chunks of 3
17:44:48 <jle`> 'letter' focuses that to the item's ascii code
17:44:48 <ertesx> > (leftComponent . leftComponent +~ 5) ((1, 1), (1, 1))
17:44:50 <lambdabot>  ((6,1),(1,1))
17:45:06 <jle`> > (ix 0 %~ negate) [1..10]
17:45:08 <lambdabot>  [-1,2,3,4,5,6,7,8,9,10]
17:45:09 <RouxTheDay> > (leftComponent . rightComponent +~ 5) ((1, 1), (1, 1))
17:45:11 <lambdabot>  error:
17:45:12 <lambdabot>      • Variable not in scope:
17:45:12 <lambdabot>          rightComponent
17:45:18 <RouxTheDay> :(
17:45:21 <ertesx> @let rightComponent = _2
17:45:22 <lambdabot>  Defined.
17:45:24 <RouxTheDay> > (leftComponent . rightComponent +~ 5) ((1, 1), (1, 1))
17:45:24 <ertesx> RouxTheDay: try again
17:45:26 <lambdabot>  ((1,6),(1,1))
17:45:36 <red13> [ if mod i 3 ==0 then toUpper x else x|(x,i)<-zip "hello world how are you" [0..] ]
17:45:41 <red13> > [ if mod i 3 ==0 then toUpper x else x|(x,i)<-zip "hello world how are you" [0..] ]
17:45:43 <lambdabot>  "HelLo WorLd How arE yOu"
17:45:57 <ertesx> RouxTheDay: (the real names are _1 and _2…  i just gave _1 the alias "leftComponent")
17:46:25 <c_wraith> Who's runnint lambdabot these days?  Is it still int-e?
17:46:29 <ertesx> > (_1 . _2 +~ 5) ((1, 1), (1, 1))
17:46:32 <lambdabot>  ((1,6),(1,1))
17:46:35 <ertesx> c_wraith: yeah
17:47:13 <RouxTheDay> Thanks guys, that was a nice first step into lenses, sorry for turning this into haskell-beginners for a minute ;)
17:47:28 <c_wraith> RouxTheDay: lenses aren't a beginner topic. :)
17:47:28 <ertesx> this is haskell-beginners, among other things =)
17:47:47 <red13> i feel out of my depth
17:48:18 <c_wraith> int-e: can we get -XTypeApplications enabled in lambdabot 
17:48:21 <jle`> red13: yes, this beginner topis are on-topic for this channel :)
17:48:29 <jle`> * RouxTheDay 
17:48:37 <jle`> that's one of the reasons this channel was originally created for! :D
17:48:47 <c_wraith> int-e: (uh, that was intended to be a polite request, not a demand.  I failed my punctuation check.)
17:49:20 <jle`> @let {-# LANGUAGE TypeApplications #-}
17:49:21 <lambdabot>  Defined.
17:49:26 <jle`> :t fmap @Maybe
17:49:27 <lambdabot> error:
17:49:27 <lambdabot>     Pattern syntax in expression context: fmap@Maybe
17:49:27 <lambdabot>     Did you mean to enable TypeApplications?
17:49:28 <ertesx> i think of lenses as my non-deterministic scalpel for values…  i don't need it often, but when i do, it's a real virtue =)
17:49:30 <jle`> i tried
17:49:31 <c_wraith> wait, @let does that now?
17:49:39 <jle`> well, it doesn't complain
17:49:52 <jle`> but it might just be adding it as a comment at the end of the file
17:49:56 <ertesx> c_wraith: it does pretty much anything you want
17:49:58 <c_wraith> looks like it
17:50:04 <jle`> so like, of course L.hs compiles, becuase it's just a comment
17:50:05 <ertesx> anything it considers safe
17:50:14 <jle`> but it doesn't move it to the top of the file i think, heh
17:50:17 <ertesx> @let import System.IO.Unsafe
17:50:19 <lambdabot>  .L.hs:138:1: error:
17:50:19 <lambdabot>      System.IO.Unsafe: Can't be safely imported!
17:50:19 <lambdabot>      The module itself isn't safe.
17:50:26 <red13> i should have learned c++ i cant get a job with haskell and all the c++ job offers are really nice but they expect insane levels of experience of wierd c++ trickery, eg for revending market data
17:50:33 <jle`> but i feel like i remember @let with language pragmas working in the past, so maybe i'm wrong
17:50:34 <c_wraith> ertesx: but it sitll has to be careful to put the line in the right spot.  imports go before definitions, etc
17:50:45 <c_wraith> ertesx: if it doesn't put language pragmas at the top, they don't do anything
17:50:45 <jle`> :t [ 10 | False ] :: Maybe Int
17:50:46 <lambdabot> error:
17:50:47 <lambdabot>     • Couldn't match expected type ‘Maybe Int’
17:50:47 <lambdabot>                   with actual type ‘[Integer]’
17:50:58 <jle`> @let {-# LANGUAGE MonadComprehensions #-}
17:50:59 <lambdabot>  Defined.
17:51:01 <ertesx> c_wraith: i think it has done that for many years, but i could be wrong
17:51:01 <jle`> :t [ 10 | False ] :: Maybe Int
17:51:03 <lambdabot> error:
17:51:03 <lambdabot>     • Couldn't match expected type ‘Maybe Int’
17:51:03 <lambdabot>                   with actual type ‘[Integer]’
17:51:10 <jle`> hm
17:51:25 <jle`> i feel like this used to work
17:51:38 <c_wraith> ertesx: it's evidently not currently working
17:51:57 <ertesx> @let import System.Mem
17:51:59 <lambdabot>  Defined.
17:52:00 <ertesx> :t performGC
17:52:02 <lambdabot> IO ()
17:52:47 <c_wraith> ertesx: I mean with language pragmas.
17:52:48 <red13> how good at haskell do you have to be to get a job in haskell, do you have to know all about lenses and other advanced haskell concepts?
17:53:07 <ertesx> :t Just id :: Maybe (forall a. a -> a)
17:53:08 <lambdabot> error:
17:53:08 <lambdabot>     • Illegal polymorphic type: forall a. a -> a
17:53:08 <lambdabot>       GHC doesn't yet support impredicative polymorphism
17:53:16 <ertesx> @let {-# LANGUAGE ImpredicativeTypes #-}
17:53:18 <lambdabot>  Defined.
17:53:18 <jle`> red13: you probably just need to show a couple of solid projects
17:53:19 <ertesx> :t Just id :: Maybe (forall a. a -> a)
17:53:20 <lambdabot> error:
17:53:21 <lambdabot>     • Illegal polymorphic type: forall a. a -> a
17:53:21 <lambdabot>       GHC doesn't yet support impredicative polymorphism
17:53:26 <ertesx> c_wraith: you're right it seems
17:53:37 <jle`> ertesx: it seems like it's just adding the pragmas as if it were a normal comment at the end of L.hs
17:53:42 <jle`> @let -- hello
17:53:43 <lambdabot>  Defined.
17:53:50 <jle`> @let -- im in ur source codes
17:53:52 <lambdabot>  Defined.
17:53:53 <ertesx> @undef
17:53:53 <lambdabot> Undefined.
17:53:56 <ertesx> @let {-# LANGUAGE ImpredicativeTypes #-}
17:53:56 <lambdabot>  Defined.
17:53:59 <ertesx> :t Just id :: Maybe (forall a. a -> a)
17:54:00 <lambdabot> error:
17:54:00 <lambdabot>     • Illegal polymorphic type: forall a. a -> a
17:54:00 <lambdabot>       GHC doesn't yet support impredicative polymorphism
17:54:03 <ertesx> hmm
17:54:08 <geekosaur> still at the end of the pristine L.hs
17:54:09 <ertesx> i guess the file doesn't start empty
17:54:11 <red13> what constitutes a solid project in haskell? i cant seem to release haskell to market so i cant see how it could be used
17:54:20 <geekosaur> yes, there's a sizeable chunk in it initially
17:54:27 <c_wraith> No, L.hs is initialized by copying Pristine.hs
17:54:37 <jle`> i feel like it used to move language pragmas to the top
17:54:42 <c_wraith> red13: web servers are common
17:55:03 <red13> i tried using yesod a while back but it was kinda clunky
17:55:18 <c_wraith> There are simpler things that don't require their own build tool to install
17:55:31 <red13> hmm
17:55:37 <jle`> or their own library ecosystem hue hue
17:55:38 <ertesx> red13: you shouldn't base your business model around haskell (unless you want to make money by selling specifically something haskell-related, which is probably a bad idea anyway)
17:55:55 <red13> its just its the only language i can write in or read
17:56:10 <ertesx> red13: first figure out what kind of service you want to provide, then see if you should implement it in haskell
17:56:33 <ertesx> red13: nothing wrong with that…  you still need to decide what you want to sell
17:56:39 <red13> well its just a proof of concept so i guess anything would be ok
17:57:11 <fred-fri> https://www.schoolofhaskell.com/school/advanced-haskell/functors-applicative-functors-and-monads is it idiomatic haskell to collect user input, do a bunch of logic on the input wrapped in maybe, and then in *the end* spit out "invalid user input" if it turns out the input wasnt there/invalid? isnt it better to check if its there/valid first, fail fast if not, and then continue doing logic with the unwrapped value?
17:57:50 <ertesx> fred-fri: if you use Maybe properly, it will fail early
17:58:06 <Axman6> Maybe can only succeed if everything succeeds
17:58:19 <fred-fri> im referring to the code in the tutorial
17:58:34 <red13> the only thing i need is ghc, so i cant thik of a product i would like to release to play store other than ghc
17:58:50 <red13> but thats impossible for me
17:59:17 <red13> if it existed i could clone some ancient games which would be fun
17:59:28 <Koterpillar> red13: using Haskell for compiling to Android is possible, but requires the knowledge of more than just Haskell.
17:59:37 <red13> thats the problem
17:59:41 <red13> i dont have that
18:00:01 <fred-fri> some input is collected, a number of things are done to the input wrapped in a maybe, and then in the end either the result or "invalid input" is printed
18:00:27 <red13> this was the closest thing i could find; https://gist.github.com/rahulmutt/355505bce57c7c2cffd7d4cf5edddad4
18:00:31 <Koterpillar> red13: That's usually obtained by reading books, attending courses and experimenting.
18:00:42 <ertesx> fred-fri: think about it: if you map over a Nothing, surely nothing can happen, right?
18:00:43 <nshepperd> I would use Either rather than Maybe since 'invalid user input' without any details as to what was invalid is pretty unfriendly
18:00:43 <sm> red13: basically nobody is doing haskell on android, I would pick an easier platform
18:00:53 <c_wraith> red13: I mean, I have one (very dumb) haskell app that is entirely hosted by a free static service.  (It demonstrates minimal ghcjs functionality).
18:01:09 <red13> its a shame after 10 years of programming haskell i need to start learning another language as a noob just to use haskell the way i want to
18:01:22 <ertesx> fred-fri: regardless of what you do with the Maybe-value, even if it's the most expensive operation you can think of…  if it's a Nothing, the result is immediately Nothing
18:01:27 <fred-fri> ertesx, I understand that
18:01:42 <fred-fri> it just seems counterintuitive to me to not check first and fail fast if so
18:01:51 <ertesx> fred-fri: you do that
18:02:00 <ertesx> you just don't do it explicitly
18:02:08 <ertesx> > fmap (+ 1) (Just 5)
18:02:09 <lambdabot>  Just 6
18:02:15 <fred-fri> because doing so would be imperative?
18:02:20 <ertesx> fmap does (has to do) the check
18:02:31 <c_wraith> No.  Because doing so would be verbose and repetitive
18:02:32 <ertesx> no, but because the check has to happen anyway
18:02:47 <ertesx> think how you would implement the mapping, if 'fmap' weren't there
18:02:53 <fred-fri> right
18:03:03 <red13> what do you mean about the static service c_wraith? i can upload to hackage and people can obtain it from that, or i can write an app in a server and host that... thats as simplle as just writing a web page...
18:03:34 <jle`> what's a nice way to implement splitAt, but counting from the end of the list?
18:03:42 <ertesx> red13: haskell and android aren't particularly great friends unfortunately (mostly because android isn't really friendly to anything that doesn't run on the JVM)
18:03:50 <c_wraith> red13: I mean I used a static html hosting service to host the ghcjs output.  (Just some html and javascript)
18:03:54 <jle`> splitAtEnd 3 [1..10]  ==> ([1..7], [8,9,10])
18:04:07 <red13> estrex, did you see ghcvm?
18:04:11 <ertesx> red13: but at the same time in this day and age you really need to know more than one language
18:04:26 <ertesx> red13: nope…  i'm only familiar with GHCJS
18:04:35 <red13> c_wraith, why did you use js and not eg yesod?
18:04:57 <c_wraith> red13: because they're entirely unrelated.
18:05:10 <red13> estrex, it does seem a lot of the projects around now use ffi
18:05:13 <c_wraith> red13: js runs in the web browser.  yesod runs on the web server.
18:05:33 <ertesx> red13: side note:  type "ert", then press tab =)
18:05:46 <red13> oh yeah sorry i got confused, yesod needs js and html to vend lol
18:06:07 <red13> ertesx: nice
18:07:09 <red13> does anyone have a link to a functioning android haskell project i could try and build?
18:07:54 <ertesx> i think if you search for "haskell android opengl cube", something should come up, but it's a very old demo of compiling haskell to native code and using the android NDK
18:08:12 <red13> cool ill report back soon, thanks
18:08:16 <ertesx> alternatively you can go the GHCJS+cordova (a.k.a. "phonegap") route
18:08:35 <red13> i would love a walkthrough
18:08:43 <red13> i doubt i could make one
18:08:48 <ertesx> note: it's nothing more than a tech demo…  don't expect to do anything fancy with it, and don't even expect it to still work with modern GHC
18:08:49 <Koterpillar> red13: https://github.com/sseefried/open-epidemic-game
18:09:08 <Koterpillar> red13: not mine, no support whatsoever
18:09:40 <red13> awesome, more options = more chance i can make one work
18:09:45 <red13> thanks
18:10:03 <ertesx> personally if i were to develop for android, i'd most likely try GHCJS+cordova
18:10:21 <ertesx> sounds to me like the variant that is most likely to work
18:10:38 <dmj`> you could try to do the react native approach
18:10:43 <red13> never seen docker before, looks fancy
18:11:01 <ertesx> or even ditch writing a phone app and provide a web site instead
18:11:48 <red13> if i knew how to bypass yesod or use another server i probably would do that
18:12:21 <red13> djm' what is the react native approach?
18:13:17 <ertesx> we have quite a few web frameworks…  if you don't like yesod, try one these (the list is far from exhaustive):  happstack, scotty, snap
18:13:29 <dmj`> servant
18:13:41 <Koterpillar> kind of not a framework
18:13:47 <Koterpillar> but still, try it :)
18:13:55 <dmj`> for some definition of 'framework'
18:14:13 <red13> i know this is bad, but all i want is a machine emulator, ie a screen and the mouse etc.
18:14:14 <dmj`> red13: it's possible to communicate with a native process from a web view (browser) on the phone
18:14:15 <ertesx> well, servant is probably more for HTTP APIs than actual web pages you would visit with a browser
18:14:33 <dmj`> ertesx: why? 
18:15:54 <ertesx> dmj`: intuitive reason…  it seems to focus on that and wants you to do the usual plumbing associated with "pages" yourself, like forms
18:16:16 <red13> i mean, if i wrote a webpage or an app, i would just have the pixels as [[(Double,Double,Double)]] and have a TVar for mouse position, left right click and then i guess id end up writing things like buttons myself
18:16:20 <ertesx> i'm sure it's possible, but snap probably gets you there quicker =)
18:17:18 <red13> for me this is more simple than learning another interface since im very confortable manipulating lists. also then my haskell program is very simple, just linear algebra on the displayed image essentially
18:18:17 <dmj`> ertesx: I've used both, in snap and servant, you can use blaze / lucid the same way. Template it the same, etc.
18:18:37 <red13> perhaps the OpenGL interface actually is the best way for me to go in this repect
18:19:02 <dmj`> ertesx: you can use digestive functors too
18:19:17 <ertesx> dmj`: i should give it another shot then
18:19:26 <red13> i have no idea how to 'iteract with a native process' so i think ill give that one a miss
18:22:22 <dmj`> ertesx: I would
18:30:08 <red13> its a same i was trying to use ghcvm, but i guess docker or phonegap are probably better... it seems like a unified approach from within haskell should be available before too long, not quite sure what it will look like but it seems to be a bunch of cross compiling and ffi stuff, wich certainly isnt my bag
18:30:17 <red13> shame*
18:34:59 <red13> argh! docker is paywalled
18:35:17 <red13> that epidemic game approach isnt an option. ok ill try phonegap
18:35:26 <Koterpillar> red13: docker is FOSS
18:35:34 <Koterpillar> red13: what OS are you on?
18:35:38 <red13> windows
18:35:42 <red13> 10
18:35:55 <Koterpillar> https://docs.docker.com/docker-for-windows/
18:36:37 <Koterpillar> but again, phonegap is likely easier
18:36:44 <red13> how strange... i got confused by https://www.docker.com/pricing
18:36:50 <red13> thanks Koterpillar
18:38:13 <red13> "hyperV is not available on home editions"
18:38:15 <red13> ...
18:38:52 <Koterpillar> well
18:39:51 <red13> Important Notes:
18:39:51 <red13> Docker for Windows requires 64bit Windows 10 Pro
18:39:59 <red13> *angry face*
18:40:50 <Koterpillar> well, you can either throw your computer out of the window, or vice versa
18:42:16 <Koterpillar> anyway, if you want to continue with Docker, install a Linux VM; if you want PhoneGap, install that, but again, something or other might be better supported on Linux anyway
18:42:25 <red13> its ok anonymous will fix the issue
18:43:36 <red13> i guess with a clean vm i can present a completed self contained build.. ok
18:45:17 <red13> i get the feeling i people didnt partition all thier work into proprietary solutions windows would have fallen by now...
18:46:18 * Koterpillar can't remember the last time seeing more than 1 Windows computer anywhere
18:47:22 <red13> all the machines in the chemistry department here are windows
18:47:34 <red13> bit off topic sorry
18:52:02 <grantwu> I'm a bit confused - how do you plan on using PhoneGap with Haskell? ghcjs?
18:52:52 <red13> i have no idea, it was someone elses suggestion, i plan to find out
18:53:28 <dmj`> that's probably a lot of ffi bindings
18:53:41 <grantwu> I mean you can compile Haskell to JS right
18:54:01 <red13> i know you can but personally i never have
18:59:43 <red13> restart required, adios
19:04:21 <xocolatl> "Yesod’s flagship web server, Warp, is the fastest Haskell web server around. When these two pieces of technology are combined, it produces one of the fastest web application deployment solutions available."
19:04:34 <xocolatl> are there any large-scale examples available?
19:04:53 <xocolatl> some kind of benchmark?
19:05:08 <grantwu> There's http://www.yesodweb.com/blog/2011/03/preliminary-warp-cross-language-benchmarks
19:05:17 <grantwu> It's a bit outdated
19:06:54 <xocolatl> I guess what I'm asking for are examples of successful (=high traffic) websites that use yesod
19:07:09 <xocolatl> as opposed to django or sumsuch
19:07:22 <grantwu> There's https://github.com/yesodweb/yesod/wiki/Powered-by-Yesod
19:07:37 <grantwu> But yeah, this is a problem in general with the Haskell ecosystem, as far as I've noticed
19:07:48 <grantwu> It's hard to point to large scale software projects in Haskell
19:09:07 <xocolatl> pandoc is the only mainstream haskell project I'm personally aware of
19:09:25 <xocolatl> and that's still a niche project
19:10:08 <chreekat> it's easy to point to the buildings that *house* large scale software projects, but the code never leaves those walls
19:10:47 <dmj`> xocolatl: xmonad
19:11:01 <grantwu> dmj`: That's not a website
19:11:14 <geekosaur> xmonad is neither a website nor a non-niche app
19:11:29 <geekosaur> (it's a niche in a niche in a niche..)
19:11:34 <dmj`> grantwu: you want like a large-scale haskell website?
19:12:03 <geekosaur> I imagine they exist because fpcomplete has customers. I don't think anyone is talking though
19:12:26 <osa1> does anyone know if I can have multiple disjoint graphs in a single fgl graph? I can't see why that would be a problem when I look at the API but just to make sure ...
19:12:48 <grantwu> dmj`: I mean, that's what xocolatl wanted
19:12:48 <geekosaur> (this is sadly normal for big companies. they tend to insist their names not be mentioned)
19:13:13 <grantwu> Doesn't Standard Chartered have their own fork of Haskell
19:13:15 <grantwu> Mu or something
19:13:39 <xocolatl> I promise this is not trolling:  do you think haskell is good as a general-purpose language?  (so far in my hobbyist studies, it is not; but I deeply want it to be)
19:14:16 <red13> it has places it falls down massively, but places where it excels.
19:14:17 <benzrf> xocolatl: broadly speaking? yes
19:14:29 <xocolatl> benzrf: glad to hear it
19:14:51 <pikajude> no, THIS is broadly speaking: y  e  s
19:14:51 <benzrf> but i think there's more variance in its suitability across applications, than in most other mainstream languages
19:16:15 <xocolatl> all of my pet projects have failed miserably.  either because haskell is not a good fit, or because I wasn't able to figure it out.  probably the latter
19:16:30 <red13> higer order programming, lazy evaluation and strict typesystem are faultless, but its percolation is sub optimal
19:16:53 <red13> xocolatl what were you trying to write?
19:17:02 <benzrf> lazy eval is not faultless
19:17:16 <red13> ! oh no !
19:17:29 <xocolatl> red13: many things in many domains, nothing professionally
19:17:35 <red13> what!?
19:17:46 <red13> what specifically were you trying to write?
19:18:57 <red13> troll
19:19:34 <xocolatl> red13: a simple database repl for postgresql (akin to the official psql); tic tac toe with alphabeta; an nntp server (for personal use, not for usenet scale); several other things.  please do not call me a troll
19:19:52 <red13> sorry
19:20:00 <benzrf> red13: plz dont call people trolls
19:20:11 <benzrf> it makes people with legit questions afraid to ask
19:20:49 <EvanR> whats great about #haskell is everyone is so friendly all the time
19:21:00 <red13> some trolls subjected me to targeted harassment which has led to me being under some kind of millitary house arrest which is actually grating on me pretty badly. im hyper sensitive to their constant stalking.
19:21:21 <xocolatl> benzrf: it's okay because I know I'm not trolling, but haskell is by far the most difficult (and most interesting) thing I've ever attempted in programming
19:21:33 <benzrf> :)
19:21:47 <benzrf> xocolatl: do keep in mind that learning haskell from other languages is a lot like learning programming to begin with
19:21:56 <benzrf> (unless your other languages are Idris or Purescript)
19:22:16 <xocolatl> problem is I don't remember learning programming to begin with
19:22:20 <benzrf> so - if you think about trying to do projects as a beginning programmer - you may find that it's pretty similar to this
19:22:22 <benzrf> oh. hehe
19:22:25 <xocolatl> my dad taught me 6502 assembly
19:22:29 <benzrf> nice!
19:23:17 <xocolatl> I still remember being jealous of 6511 because it had TXY and TYX
19:23:44 <benzrf> i dont even know what that means :D
19:24:02 <grantwu> Hey, there's a whole family of ML languages you've left out there benzrf :P
19:24:03 <xocolatl> and I don't understand arrows, so we're even
19:24:12 <benzrf> grantwu: still fairly different
19:24:15 <benzrf> xocolatl: nobody uses arrows, cmon
19:24:21 <xocolatl> I don't know
19:24:25 <xocolatl> it's things I read about
19:24:28 <red13> :t (>=>)
19:24:29 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:24:36 <Koterpillar> :t (&&&)
19:24:38 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
19:24:58 <Koterpillar> ((2 *) &&& (1 +)) 3
19:25:02 <Koterpillar> > ((2 *) &&& (1 +)) 3
19:25:02 <Guest19117> what's the working directory that stack runs the interpreter and executables in?
19:25:03 <red13> i was going to do Arrows with benk
19:25:04 <lambdabot>  (6,4)
19:25:20 <Koterpillar> Guest19117: stack does not change the current directory
19:25:27 <Guest19117> K
19:25:36 <Guest19117> Koterpillar: thanks, I'll give that a try
19:26:25 <red13> :t ((2 *) &&&)
19:26:27 <lambdabot> Num b => (b -> c') -> b -> (b, c')
19:26:55 <red13> what happened to the arrow constraint!?
19:27:13 <Koterpillar> red13: it got defaulted to (->) by the first argument
19:27:17 <Koterpillar> *resolved
19:27:22 <Koterpillar> *whatever
19:28:26 <red13> but (->) ony has 2 arguments
19:28:38 <red13> i mean, (*2) does
19:28:53 <Koterpillar> no, (* 2) has one argument
19:28:54 <red13> you know what i mean
19:29:01 <red13> it retruns one too
19:29:02 <Koterpillar> :t (* 2)
19:29:04 <lambdabot> Num a => a -> a
19:29:12 <Koterpillar> so its type is (->) a a
19:29:24 <Koterpillar> and there's an instance Arrow (->)
19:29:27 <red13> aha
19:29:36 <Koterpillar> so instead of Arrow b c it became (b -> c)
19:30:00 <red13> what other Arrow instances are good?
19:30:38 <Koterpillar> *** out of bounds: knowledge of Arrow exhausted
19:30:52 <red13> lol ok, im an expert in them now
19:31:29 <Koterpillar> aha, monadic functions
19:31:34 <xocolatl> are there any other self-learners here, or did everyone learn haskell at school?
19:31:54 <EvanR> i learned it at work
19:32:01 * Koterpillar learned by reading books
19:32:10 * JuanDaugherty is self taught
19:32:11 <red13> i did 1 semester as an optional course while learning physics
19:32:23 <xocolatl> so I'm just dumb then :D
19:32:45 <red13> as it was my first language i got a lot of experience since then
19:33:47 <xocolatl> EvanR: what do you do?
19:34:16 <red13> haskell winning @ #haskell
19:36:00 <EvanR> back then, PHP
19:36:14 <xocolatl> you learned haskell doing php?
19:37:48 <EvanR> while doing php
19:38:18 <red13> epic last convo b4 the bomb drops
19:41:26 <red13> +
19:48:30 <minn> Cabal fails to install many packages trying install Idris. Trying to install them individually gives this error: <http://lpaste.net/256779>. Do I need to start patching up the source files, or is this a problem on my end?
19:49:17 <EvanR> that doesnt look good
19:49:57 <EvanR> try removing distributive if you already have it, cabal update and then cabal configure
19:50:02 <EvanR> also use the latest git of idris
19:51:29 <minn> I'll give that a shot. Thanks for the advice :)
20:18:10 <erisco> are you not entertained?
20:18:34 <systemfault> erisco: That must be written in CAPS.
20:20:56 <Costar> hi all
20:21:05 <koz_> Hi Costar!
20:33:58 <cheater> hi, does anyone here understand volterra kernels?
20:35:18 <cheater> i am implementing something based on them and i'm not sure if i'm missing any assumptions
20:46:45 <hololeap> how come  "main = (readLn :: IO String) >>= print"  gives me "user error (Prelude.readIO: no parse)" after i type a line?
20:47:29 <Koterpillar> hololeap: it tries to _parse_ a Haskell representation of a string
20:47:38 <Koterpillar> hololeap: try entering "hololeap" with quotes
20:47:46 <hololeap> oh, i gotcha
20:47:47 <Koterpillar> > read "\"hololeap\""
20:47:49 <lambdabot>  *Exception: Prelude.read: no parse
20:47:51 <erisco> :t getStrLn
20:47:52 <lambdabot> error:
20:47:53 <lambdabot>     • Variable not in scope: getStrLn
20:47:53 <lambdabot>     • Perhaps you meant one of these:
20:47:54 <Gurkenglas> Is there an O(log n) oneliner for \n -> iterate (\v -> map (sum . zipWith (*)) a) x? (Computing A^n*x)
20:47:59 <erisco> well it is something like that
20:48:14 <EvanR> > read "\"abcdef\"" :: String
20:48:16 <lambdabot>  "abcdef"
20:48:18 <Gurkenglas> oops, \n -> iterate (\v -> map (sum . zipWith (*)) a) x !! n
20:48:24 <Koterpillar> I wonder what mine defaulted to
20:48:28 <EvanR> ()
20:48:36 <Koterpillar> > read "()"
20:48:38 <lambdabot>  ()
20:48:41 <EvanR> very handy
20:48:48 <monochrom> getLine
20:50:03 <erisco> is that right Gurkenglas? v is not used
20:50:24 <Gurkenglas> gosh darnit \n -> iterate (\v -> map (sum . zipWith (*) v) a) x !! n
20:50:32 <Gurkenglas> thats what i get for writing pointful code
20:50:39 <erisco> what does it do
20:50:51 <Gurkenglas> Computes A^n*x
20:51:03 <grantwu> Gurkenglas: Are you looking for parallel scan?
20:51:17 <grantwu> wait, no, that's still linear work
20:51:27 <erisco> is that A^(n*x) ?
20:51:53 <Gurkenglas> (A^n)*x, A is a matrix, x is a vector
20:52:15 <erisco> ah
20:53:02 <elrikdante> Hello any idea on use patterns to prevent bracket from releasing my resource before the first IO acion is done?: http://lpaste.net/256785
20:53:18 <joe9> I am thinking of using HFuse for a haskell project to generate/use a synthetic filesystem (similar to how 9pfs architecture). I hear horror stories about fuse. Just want to check if any haskell folks have any experiences to share?
20:54:07 <nitrix> joe9: It's pretty much de facto solution for linux vfs stuff.
20:54:09 <Koterpillar> :t bracket -- elrikdante
20:54:11 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:54:25 <Koterpillar> elrikdante: looks like you've mixed up the arguments
20:54:53 <elrikdante> is my IO c supposed to handle resource cleanup?
20:54:57 <joe9> nitrix: ok, Thanks. happy with it? used it?
20:55:01 <Koterpillar> elrikdante: no, c is your result
20:55:13 <elrikdante> LOL
20:55:14 <Koterpillar> so: bracket open close action
20:55:49 <nitrix> joe9: Yeah. I also knew a lot less Haskell at the time and still managed to get stuff done.
20:55:49 <elrikdante> excellent I was telling myself lies.
20:56:01 <elrikdante> thanks Koterpilar:
20:56:49 <nitrix> joe9: I personally am looking to port another C library to Haskell, which is suposed to abstract both fuse and Dokkan (with a wrapper on top of dokkan to simulate fuse)
20:56:56 <nitrix> This way it works on both linux and windows.
20:57:02 <joe9> nitrix: Thanks, good to know. I do not know why but there is a lot of negativity surrounding fuse. I am not sure if it did not have a good beginning..
20:57:43 <nitrix> It's... it's as good as it gets user-space wise. Otherwise you're writing your own driver.
20:57:50 <nitrix> Or kernel stuff.
20:58:44 <elrikdante> Sweet: works fine now http://lpaste.net/256785
20:58:49 <nitrix> joe9: I think the negativity was to get it working in the first place. That thing stirred up a lot of stuff.
21:01:27 <joe9> nitrix: I pm'ed you. Do you have a few minutes to help, please?
21:04:34 <joe9> Even HFuse does not have a commit for the last year. Not sure if that is because it does not need any or if it is not being maintained.
21:08:03 <geekosaur> the userspace side of fuse doesn't change a lot, most fuse updates are to deal with kernels
21:08:57 <elrikdante> ?
21:11:49 * Maxdamantus wonders why people use bindings to libfuse anyway.
21:12:25 <Maxdamantus> The API there always seems wrong to me, and it doesn't really seem to relate to the protocol.
21:13:28 <joe9> Maxdamantus: What do you recommend?
21:13:54 <Maxdamantus> Well, the library just talks a streaming protocol wint userspace.
21:14:16 <Maxdamantus> You can implement that with anything that handles POSIX IO.
21:15:10 <Maxdamantus> there's also 9P, which has at least been the primary public interface for a few decades, and it still seems fairly reasonable.
21:15:30 <joe9> Maxdamantus: I am debating between 9pfs and fuse
21:15:56 <joe9> Maxdamantus: but, unfortunately, diod seems to be the reference implementation on linux
21:16:34 <joe9> Maxdamantus: no diod haskell bindings if you want to write a 9p server
21:16:38 <Maxdamantus> Mm, I haven't really liked any of the 9P libraries either.
21:16:59 <Maxdamantus> I started writing a 9P library in Haskell a few years ago.
21:17:12 <joe9> Maxdamantus: There is Network-NineP package
21:17:22 <ania123> hi all
21:17:30 <ania123> is here english native speaker?
21:17:46 <joe9> Maxdamantus: but, that has many warnings and I get the feeling that it is still in prototyping phase.
21:17:48 <Maxdamantus> Yeah, I saw that. I think my thing is slightly higher-level and theoretically more abstract.
21:18:04 <dmj`> ania123: yes, many native english speakers are here
21:18:15 <joe9> Maxdamantus:  HFuse seems to be more mature and fuse seems to be more highly regarded in the linux world compared to 9pfs
21:18:18 <Maxdamantus> http://github.com/Maxdamantus/hsstyx
21:18:27 <Koterpillar> ania123: as well as many who are not
21:18:44 <Maxdamantus> there's at least one bug with the directory listing combinators.
21:19:06 <ania123>  We study the semantics of CLP and show its application in membrane computing.
21:19:14 <ania123> is it correct wrt english?
21:19:19 <Maxdamantus> and it still doesn't erally have all the ones it probably should have, so you kind of need to understand the protocol.
21:19:35 <Koterpillar> ania123: this is not a channel for help with English though
21:19:44 <ania123> i know
21:19:50 <ania123> but here are smart ppl :)
21:20:20 <EvanR> maybe youd be interested in hiring some of them?
21:21:07 <dmj`> ania123: sounds very correct wrt english
21:21:44 <ania123> thx
21:43:46 * hackagebot yackage 0.8.1 - Personal Hackage replacement for testing new packages.  https://hackage.haskell.org/package/yackage-0.8.1 (MichaelSnoyman)
23:10:22 <Bmw-x1> https://ng-developer.itch.io/nitrux
23:12:00 <Koterpillar> Bmw-x1: is this written in Haskell?
23:12:06 <hololeap> since all monads are applicative, why have return and pure functions? they seem to do the same thing
23:12:16 <Koterpillar> hololeap: historic reasons
23:12:53 --- mode: ChanServ set +q *!*@2.237.171.7
23:13:22 <Koterpillar> ...maybe it was in Haskell
23:14:52 <johnw> hololeap: if it could all be recreated anew, there'd be no return function
23:15:59 <vega_> Hi there =]
23:17:32 <glguy> Koterpillar: whatever language it was written in, joining and pasting a bare link to a shopping page is spam
23:42:35 <kadoban> Is there anything new that's replaced repa for doing potentially parallel, efficient operations on 2D arrays of data? Making sure repa is still a decent choice.
23:46:46 <minn> I just want to make sure I have the steps correct. To install cabal locally without an existing cabal installation: (a) install cabal locally with the --user and --enable-library-profiling flags; (b) install cabal-install locally by running bootstrap.sh. For whatever reason, cabal-install repeatedly fails to build: missing dependencies, missing files in downloaded packages, etc. Am I doing something wrong?
23:48:31 <minn> This is essentially what the documentation for cabal and cabal-install suggest doing. Am I supposed to be resolving all these dependencies before building cabal-install, or something?
23:50:05 <jle`> kadoban: repa is still the big player i think
23:50:11 <jle`> i haven't heard of anything else
23:50:16 <kadoban> Cool, thanks.
23:50:23 <jle`> but maybe ask in the datahaskell group
23:50:34 <kadoban> Hmm, good idea
23:59:41 <hololeap> when would (/=) ever be defined as something other than "(/=) a b = not (a == b)"
