00:00:52 <srhb> Anyone using propellor? How does one change the remote user and use sudo instead of root-ssh?
00:15:00 <jakub_> hi, I am looking for mapT :: (m a -> m a) -> t m a -> t m a, and I came up with mapT f = ((lift . f . return) =<<) which unfortunatelly doesn't do what I wish. I want f to be applied to the contained monad, this however puts `f` after evaluating the contained monad... Is there a way how to implement my `mapT` generally for any MonadTrans t or some subclass of MonadTrans?
00:17:28 <jakub_> on one hand it seems like an analog of functor fmap just for transformers (and thus it would make sense if it was actually easy to do) but on the other hand I fear it is not possible
00:20:28 <ski> @hackage mmorph
00:20:28 <lambdabot> http://hackage.haskell.org/package/mmorph
00:20:55 <ski> jakub_ ^
00:23:02 <jakub_> ski: am I right in assuming you suggest `hoist` to be what I am looking for?
00:23:31 <ski> possibly
00:23:52 <ski> @type mapReaderT
00:23:54 <lambdabot> forall k k1 (m :: k -> *) (a :: k) (n :: k1 -> *) (b :: k1) r. (m a -> n b) -> ReaderT r m a -> ReaderT r n b
00:23:59 <ski> @type mapWriterT
00:24:01 <lambdabot> (m (a, w) -> n (b, w')) -> WriterT w m a -> WriterT w' n b
00:24:05 <ski> @type mapStateT
00:24:07 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
00:24:59 <ski> @type \f -> ((lift . f . return) =<<)
00:25:00 <lambdabot> (MonadTrans t, Monad (t m), Monad m1, Monad m) => (m1 a -> m b) -> t m a -> t m b
00:25:03 <jakub_> mapReader etc are not what I want
00:25:07 <ski> ok
00:36:01 <lpaste> koz_ pasted “Is this kind of abstraction possible?” at http://lpaste.net/240734
00:46:43 <liste> koz_: doesn't that break lens laws?
00:47:32 <liste> namely "view l (set l b a)  ≡ b"
00:48:32 <koz_> liste: ... damn.
00:48:47 <koz_> I thought I was doing something awful.
00:48:57 <koz_> liste: Is there a more sensible way to do what I seek to do?
00:49:03 <liste> koz_: a Prism
00:49:21 <koz_> liste: Sorry, but I don't follow how I would use a Prism for this.
00:49:25 <koz_> Could you show me?
00:51:28 <liste> koz_: wait a sec, I don't think a Prism is enough
00:51:42 <liste> Prism is like a partial Iso, what you need is a partial Lens
00:52:14 <koz_> liste: Yes, that's exactly what I want. Does such a thing even *exist*, though?
00:59:06 <koz_> liste: ... wait a sec. Do I want a Traversal?
01:01:08 <koz_> But how do I actually construct one? There's no seeming function like 'lens'.
01:02:05 <liste> koz_: define a function ":: Applicative f => (a -> f b) -> s -> f t "
01:02:18 <liste> that's Traversal s t a b
01:03:44 <koz_> liste: So in my case, I would need a 'Traversal MutParams MutParams Int Int', and it just *happens* to use Alternative when I wanna do updates?
01:03:54 <koz_> (sorry, *some* Alternative)
01:04:10 <lyxia> doesn't the putGet law only apply if the domain and codomain of the lens are the same
01:06:18 <koz_> lyxia: Now I'm really confused. Is what I'm doing OK, or *not* OK?
01:06:26 <koz_> (i.e. do I need a Lens or a Traversal here?)
01:06:28 <lyxia> l :: Lens s t a b, view l :: s -> a, set l :: b -> s -> t, view l (set l b a) only typechecks if s ~ t.
01:06:45 <liste> so then the first one was good (:
01:07:50 <koz_> liste and lyxia: OK. So now, can I actually do what I wanna do here somehow? http://lpaste.net/240734
01:07:57 <lyxia> I don't know how to generalize the law. The lens doc don't, they just mention that s t a b "cannot vary fully independently".
01:08:08 <koz_> lyxia: I'm reading the Ed article linked there.
01:08:31 <koz_> It actually seems to address the idea of what I'm trying to do.
01:09:37 <puregreen_> lyxia: when I asked about that, I was told that if the law doesn't typecheck, it counts as “fails the law”
01:10:11 <lyxia> oh...
01:10:29 <koz_> puregreen_: But then why even have 's t a b' parameters?
01:10:36 <puregreen_> see http://comonad.com/reader/2012/mirrored-lenses/
01:10:42 <koz_> puregreen_: I'm reading it right now.
01:10:49 <lyxia> that sounds restrictive
01:11:16 <puregreen_> basically we want this: type LensFamily outer inner = forall a b. LensFamily (outer a) (outer b) (inner a) (inner b)
01:11:37 <puregreen_> this is what we try to achieve with Lens s t a b
01:12:14 <koz_> puregreen: So that brings us back to 'the lenses I wanna write are bad'?
01:13:33 <koz_> Like, I'm genuinely a bit confused at this point, and would like to be enlightened.
01:14:23 <puregreen> I never really got satisfactory answers for my questions about “what exactly would happen if I break lens laws”
01:14:44 <puregreen> so I don't know, sorry
01:15:10 <lyxia> I think it is an open question actually.
01:16:14 <lyxia> even lens breaks the laws for improved convenience
01:16:54 <koz_> lyxia: Could you give me an example?
01:21:17 <lyxia> Oh I was thinking of filtered which is not quite a pure Lens thing.
01:21:39 <puregreen> filtered cunningly sidesteps the question of laws by not having “Traversal” in its type
01:22:03 <lyxia> I see.
01:26:04 <lyxia> Let's invent our own thing. GuardedLens s a = forall f g. (Functor g, Alternative f) => (a -> g a) -> s -> g (f s)
01:28:54 <koz_> I think I'm just going to email Ed.
01:29:09 <koz_> Lens is his baby, he might know something we don't.
01:29:35 <bartavelle> there are popular bad prisms
01:29:50 <bartavelle> the _XML or json prisms for example, as they reformat the input on changes
01:30:05 <lyxia> ew
01:30:16 <bartavelle> well, they are super useful though :)
01:30:44 <ecthiender> I'm writing a simple console game. To have keyboard inputs right now I'm using getChar to get inputs. But now I want to detect arrow keys. It seems like the arrow keys are not single characters. So getChar doesn't work with them. How do I go about it?
01:31:17 <ecthiender> Searching on the internet seems to point to use haskelline or readline. But I don't actually want any readline support.
01:32:27 <bartavelle> ecthiender, can't you keep using getChar by recognizing character sequences ?
01:33:04 <ecthiender> bartavelle, I see. You mean I keep reading getChar until I get all the characters correspond to an arrow key?
01:33:55 <bartavelle> ecthiender, that, or use a dependency of some sort that does this job for you
01:34:21 <ecthiender> Hmm. Something like ncurses library you mean?
01:34:27 <bartavelle> yeah
01:34:38 <bartavelle> never used it though, so I am not sure it's really nice to use ...
01:35:16 <ecthiender> Hmm. I was building this really simple Sokoban game. I was wondering if I can do it w/o any external library.
01:36:30 <srhb> ecthiender: Mostly all the libraries that deal with this in a nicer way than base use base to do so. So yes, but you'll have to reimplement. :) There's nothing wrong with just grabbing stdin and parsing it yourself though.
01:37:02 <koz_> OK, emailed Edward. Will share his wisdom when I get a response.
01:37:06 <koz_> (assuming anyone wants to know)
01:37:15 <ecthiender> Yep. Cool. I don't mind reimplementing. I'm learning Haskell actually. So maybe I will gain some more insight.
01:37:23 <lyxia> koz_: please do!
01:37:53 <koz_> I wonder how many emails like mine Ed must get every day...
01:39:20 <ecthiender> So what would be the basic idea? Any pointers would be appreciated.
01:39:51 <bartavelle> ecthiender, when you get a key, check its code to see if it's a simple keyboard entry, or the start of a sequence
01:40:00 <bartavelle> if it's a sequence, getChar some more
01:40:17 <ecthiender> bartavelle, how do I know if its a sequence?
01:40:31 <ecthiender> bartavelle, is there any docs on this stuff?
01:40:49 <bartavelle> I would go for ncurses source code ;)
01:40:59 <MarcelineVQ> it'll probably start with ^
01:41:07 <ecthiender> Hmm.. I see..
01:41:26 <MarcelineVQ> you can see some examples with something like replicateM 10 getChar in ghci and press some keys
01:41:38 <blac0range> are there any clean way to convert any tuple to a pointer that works as an c array?
01:42:39 <ecthiender> MarcelineVQ, what is replicateM? Sorry I'm quite new to all this stuff..
01:42:58 <koz_> :t replicateM
01:43:00 <lambdabot> Applicative m => Int -> m a -> m [a]
01:43:02 <MarcelineVQ> it repeats an action
01:43:24 <ecthiender> Ah I see. Thanks!
01:43:30 <koz_> replicateM i f repeats the action f a number of times equal to i, stuffs them in a list, and gives it back to you.
01:43:32 <MarcelineVQ> I ​picked 10 there because it seems to smash in some \ESC chars if a press gives it more than one result which is mangling the output
01:44:01 <MarcelineVQ> key buttons seem to be 4 chars, on my terminal anyway
01:44:21 <ecthiender> I see I see. Thanks guys, some insight coming through.
01:45:07 <ecthiender> Also, I tried to figure out where the ncurses source lives from here: https://hackage.haskell.org/package/ncurses . But seems like the author's website is down.
01:46:34 <bollu> is haskell referentially transparent?
01:47:29 <bollu> I actually realised I don't understand how IO respects referential transparency
01:47:32 <sbrg> In Haskell you can write referentially transparent functions yes.
01:47:40 <sbrg> it doesn't. or rather, you can't assume it does.
01:48:08 <koz_> bollu: IO is a description of a computation, not its execution.
01:48:16 <bollu> sbrg: okay, so, then, how does "IO help separate pure from impure" ? It doesn't except for the fact that you have no function strange :: IO a -> a?
01:48:24 <bartavelle> ecthiender, ncurses source code isn't easy to parse at all :)
01:48:24 <m1dnight_> launchMissiles() :>
01:48:24 <koz_> Basically, everything we do when we talk about IO is describing what we want done, not actually doing it.
01:49:10 <bollu> koz_: yes, I used to believe this, but I don't think I do anymore. Because, the description being the same doesn't guarantee that on execution, it yields the same value
01:49:38 <sbrg> no, but no one has said that it does
01:49:51 <bartavelle> bollu, it pretty much is certain it won't
01:50:26 <bollu> sbrg: no one says that IO allows us to separate pure from impure? or...?
01:50:44 <bartavelle> it won't yield the same result
01:50:47 <comerijn> bollu: The point is that differing executions are not observable during Haskell *evaluation*
01:51:03 <comerijn> bollu: And thus, can't impact the purity of *evaluation*
01:51:08 <sbrg> No, no one says that because the "descriptions are the same" the return value will be the same. the point of IO is basically the opposite
01:51:09 <lyxia> a value of type IO a is a program. The program stays the same.
01:51:11 <bollu> comerijn: are you merjin? :) 
01:51:15 <bollu> sbrg: right, exactly
01:51:23 <cocreature> bollu: _evaluation_ is referentially transparent. _execution_ is not
01:51:29 <bollu> cocreature: ahh
01:51:36 <sbrg> that's a nice way to put it
01:51:37 <koz_> merijn: Does comerijn write code, and merijn write de?
01:51:41 <bollu> cocreature: can you define "evaluation" for me?
01:51:49 <cocreature> so putStrLn "Hello world" will always evaluate to the same computation
01:51:55 <bollu> cocreature: IO () ?
01:51:57 <merijn> koz_: comerijn turns bugs into working code and merijn turns working code into bugs
01:52:07 <cocreature> but when you execute that computation it can return different results
01:52:09 <koz_> merijn: So bugs are a category?
01:52:17 <sbrg> but is merijn defined in terms of comerijn or the other way around then?
01:52:20 <sbrg> which came first?
01:52:27 <bollu> sbrg: mutually recursive definition? :)
01:52:39 <cocreature> bollu: sorry I don’t have a precise definition
01:52:43 <merijn> bollu: A computation of type "IO ()", yes
01:52:43 <koz_> sbrg: It's a free monad. We inject the right functor to get the semantics.
01:52:46 <bollu> cocreature: okay, but, what do we gain from this? you can't equationally reason, can we?
01:53:13 <merijn> bollu: We can, because now "map print foo" doesn't break referential transparency
01:53:46 <merijn> bollu: We can proof that "map print [1..10] !! 3" is equal to "print 2", because of map being pure
01:53:54 <bollu> merijn: ah
01:53:55 <merijn> s/proof/prove
01:53:57 <bollu> merijn: I see
01:54:31 <cocreature> evaluation happens before execution. so you can reason that something evaluates to the same action
01:54:33 <bollu> merijn: okay, but, well, how does the type of print being IO () help? Why can't it just be () ? (I'm asking only in the context of equational reasoning)
01:54:35 <merijn> bollu: Because the evaluation of that expression is pure. The (eventual) execution of the resulting IO is not
01:54:52 <koz_> bollu: It also means anything that touches it has to be in IO as well.
01:55:06 <koz_> So we *force* a separation between effectful and effectless stuff at the type level.
01:55:46 <merijn> bollu: Well, how do you enforce the IO doesn't happen during evaluation if you don't know whether "()" is some computation that does IO, instead of merely ()
01:56:01 <bollu> merijn: no, no, I'm asking what impact does ithave to referential transparency?
01:56:16 <bollu> I've written enough haskell code to see the usefulness and awesomeness of IO
01:56:24 <merijn> bollu: Well, when does the IO part of print happen when "print :: Show a => a -> ()"?
01:56:26 <bollu> merijn: equational reasoning*
01:56:29 <ahihi> map print [1..10] !! 3 is print 4, not 2 ;p
01:56:41 <bollu> I was wondering how having IO helps in equational reasoning
01:56:46 <merijn> ahihi: I was counting from 0, because I'm dumb :)
01:57:01 <merijn> bollu: Yes, I'm getting to that, eventually :)
01:57:07 <bollu> merijn: ah, okay, go on :)
01:57:59 <merijn> bollu: So the first question is "when does the IO part happen with that signature?", clearly not when it runs, because then I'd obviously break referential transparency, since "map print [1..10] !! 3" would immediately print all numbers, right?
01:58:05 * hackagebot language-puppet 1.3.2.1 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.3.2.1 (SimonMarechal)
01:59:09 <[exa]> Hi everyone. I'm trying to solve a problem with kinds from TypingHaskellInHaskell -- how do I know what kind does a type constructor or a variable have, when I parse it out of the source?
01:59:29 <koz_> :k Maybe
01:59:31 <lambdabot> * -> *
01:59:40 <koz_> :k Maybe Int
01:59:41 <lambdabot> *
01:59:45 <[exa]> yup
01:59:58 <koz_> :k RWST
02:00:00 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
02:00:10 <koz_> ^ Best. Kind. Ever.
02:00:10 <[exa]> yeeep. :D
02:00:14 <bollu> merijn: right
02:00:49 <koz_> [exa]: You can do that in GHCi.
02:01:01 <merijn> bollu: But if I don't do it immediately, how do I track that the "()" value of "map print [1..10] !! 3" should print something?
02:01:22 <[exa]> koz_: well, I don't have ghci, I'm implementing another kindof-compiler with haskell-like type system
02:01:28 <bollu> merijn: hm, okay. you.. can't
02:01:42 <koz_> [exa]: So was your question 'how do I tell as a person what the kind of something is?'.
02:02:26 <[exa]> Yes. Suppose I have a explicitly typed binding, like a=b ;  a :: Constructor a b c
02:02:38 <[exa]> how do I know the kinds of type vars a,b,c
02:02:56 <bollu> merijn: so, you're saying having the IO allows to tag it as "expression with side effect"?
02:03:00 <merijn> bollu: So IO does two things: 1) keep track of value that have some effect associated with it (implicitly reminding you that they can be executed at some point)
02:03:25 <merijn> bollu: Well, I would say that IO is "a value with effect" (because side-effect implies something happening "to the side", i.e. not tracked), but yes
02:04:02 <[exa]> best guess is to pre-parse the constructors and wildly guess their kinds, but again, if I have 'data Something a = Constructor a | Con2 a a', how do I know that 'a' has kind *, but not e.g. *->* or so
02:04:15 <merijn> bollu: The second thing that IO does is provide a "DSL" (if you will) for combining/manipulating results of/composing effectful values
02:04:31 <merijn> bollu: Which is exposed through the Functor/Applicative/Monad interfaces
02:05:07 <bollu> merijn: I was getting to that - I don't think monads are the most illuminating algebra for IO
02:05:13 <bollu> merijn: how did the community come to the conclusion?
02:06:05 <merijn> bollu: Historical trivia: Haskell did not, initially, use a monadic approach to Monads
02:06:29 <bollu> merijn: it used to use streams, right?
02:06:29 <ski> (s/Monads/I\/O/)
02:06:41 <grantwu> Is there a... good way to keep GHC memory usage down
02:06:41 <bollu> merijn: I personally like FRP better I think, with what little I've used of it.
02:06:47 <merijn> bollu: It use a "String -> String" type for main, where it convert a (lazily generated) input string into a lazily generated output String. Turns out the IO approach was much nicer
02:06:56 <ski> @type interact
02:06:58 <lambdabot> (String -> String) -> IO ()
02:06:58 <bollu> merijn: huh, I see
02:07:00 <merijn> bollu: FRP was invented like a decade after IO
02:07:19 <merijn> bollu: And it's still not crystallised enough to be a reasonable replacement for IO :)
02:07:23 * ski . o O ( `main :: [Response] -> [Request]' )
02:07:26 <grantwu> I need to keep GHC memory usage below 2 GB
02:07:37 <grantwu> Because the autograding machines for this compiler class are t2.smalls
02:07:48 <merijn> bollu: Incidentally, the original Wadler paper had some nice simple exampls on what makes the Monad interface appealing
02:08:10 <merijn> bollu: It's very readable for even beginners: http://roman-dushkin.narod.ru/files/fp__philip_wadler_001.pdf
02:08:12 * ski . o O ( Eugenio Moggi )
02:08:24 <merijn> ski: Also, life pro-tip for you :)
02:08:26 <bollu> merijn: cool, thanks
02:08:44 <merijn> ski: s/ syntax of vim/sed/ed/etc. allows arbitrary separators
02:08:55 <merijn> ski: So s#Monads#I/O# works :)
02:09:01 <bollu> merijn: I've used a decent amount of Haskell now, and I was just thinking back that I don't really understand how IO as a monad helps, philosophically ;)
02:09:07 <bollu> merijn: wait, what?
02:09:09 <bollu> merijn: :O
02:09:09 <grantwu> (on AWS)
02:09:13 <bollu> merijn: seriously?
02:09:15 <merijn> bollu: Yes
02:09:20 <ski> merijn : it's in my passive memory :)
02:09:43 <merijn> bollu: Sed uses whatever character that follows the 's' as separator. It's really nice to use # when dealing with stuff containing /'s :)
02:09:55 <bollu> merijn: wow
02:10:00 <bollu> merijn: holy shit
02:10:14 <bollu> merijn: why has no one told me this so far? :P
02:10:15 <koz_> bollu: Yeah, it's mind-blowing.
02:10:25 <merijn> bollu: You didn't think to ask? ;)
02:10:33 <grantwu> holy shit
02:10:35 <grantwu> TIL
02:10:37 <merijn> More people should learn sed, it's powerful :)
02:10:38 <koz_> s,mind-blowing,mind-shattering
02:10:44 <koz_> I agree with merijn.
02:10:56 <bollu> merijn: a nice tutorial for it?
02:11:03 <bollu> merijn: I've always just whipped out python / turtle
02:11:05 <koz_> bollu: Read the GNU sed manual.
02:11:09 <bollu> koz_: uhhh
02:11:10 <koz_> It's actually pretty easy.
02:11:14 <merijn> bollu: http://www.grymoire.com/Unix/Sed.html
02:11:14 <koz_> (and fairly brief)
02:11:25 <merijn> koz_: That page is far nicer than man pages :)
02:11:46 <merijn> bollu: Incidentally, philosophically speaking the Monad interface doesn't help thinking about IO at all
02:11:52 <merijn> bollu: You're absolutely right about that
02:11:54 <koz_> merijn: I didn't mean 'man sed'. I meant the actual GNU sed manual, like, the one online.
02:12:12 <bollu> wow, thanks
02:12:20 <merijn> bollu: It's more that IO, as conceived in Haskell, just happens to support the Monad interface
02:12:48 <merijn> bollu: You could easily have "composeIO :: IO a -> (a -> IO b) -> IO b", etc. directly and know nothing about Monads and Functors
02:12:48 <koz_> merijn: Could you help me understand the distinction between Fix and Free? They both seem to do similar things.
02:12:57 <bollu> merijn: exactly! I'm teaching haskell right now, and I'm not able to find a nice way to introduce IO
02:13:13 <merijn> koz_: Free has a terminal value, Fix is infinite
02:13:15 <bollu> koz_: Fix is fixpoint lifted to types, you can't "terminate it". Free can be "chopped off"
02:13:46 <ski> koz_ : `Free f a = Fix (\r -> a + f r)'
02:13:46 <bollu> koz_: also, used for different things. Free f gives you a monad for any functor f. Pretty sure fix f doesn't do that
02:14:06 <koz_> bollu: As I understand it, Fix is meant to encode recursion schemes.
02:14:29 <merijn> bollu: I think a lot of beginner confusion comes from mixing 3 things: 1) Monads (i.e. typeclasses), 2) do notation, 3) IO
02:14:38 <merijn> bollu: Which get rolled into 1 big blob of confusion
02:14:51 <bollu> merijn: yes, I'm not even going to show do-notation
02:14:52 <koz_> What merijn described *definitely* happened to me.
02:14:57 <bollu> merijn: (not right now, anyway)
02:15:02 <bollu> merijn: I was thinking of showing >> and >>=
02:15:08 <merijn> bollu: My personal advice would be: Cover typeclasses in depth first. Including Monad (but not IO!) so just List, Maybe, etc.
02:15:30 <merijn> bollu: Cover IO next, using >>= and >> explicitly *everywhere* the usual lambda notation for >>= works
02:15:40 <bollu> merijn: yep yep, I was doing concrete typeclass instances till now. We encoded our first typeclass today (instantiated Eq, Show and Functor)
02:15:44 <merijn> bollu: Then explain do notation last, when people can write stuff using >>= and >>
02:16:06 <bollu> merijn: unrelated: does s in vim send data to sed?
02:16:09 <merijn> bollu: This wikibook chapter is good: https://en.wikibooks.org/wiki/Haskell/do_notation
02:16:16 <merijn> bollu: No, but vim uses compatible syntax
02:16:22 <bollu> merijn: cool
02:16:33 <merijn> bollu: Incidentally, both vim and sed take their syntax from ed commands
02:17:16 <bollu> merijn: also, I'm finding it hard to set good exercises to the class on Functor, Applicative, etc. I mean, "implement instances for <x> <y> <z> " is hardly fun. I've been trying to find cool examples I've seen of these typeclasses
02:18:05 <ski> koz_ : `Free' takes a "tree layer" functor, and a "base/leaf/element" type, and gives a data type where a value is either a leaf, or a layer of recursive instances of this data type
02:18:07 <merijn> bollu: tbh, I don't really know about "cool" instances, I mean they're just not that cool and hard as they first appear :)
02:18:41 <merijn> bollu: I like having people implement Functor/Applicative/Monad for "data Const k a = Const k" and have them figure out how they can manage the corresponding laws
02:18:43 <koz_> Also, I'm sad that RandT is not an instance of PrimMonad.
02:19:04 <ski> koz_ : so if the layer functor is `Two', defined as `data Two a = Pair a a', then `Free Two a' will be a binary tree with `a' leaves
02:19:07 <koz_> It *massively* complicates implementing what I want using mutable vectors.
02:19:26 <koz_> ski: Ah, OK, that makes sense.
02:20:07 <bollu> merijn: yeah, the Monoid m => Applicative (Const m) is a little bit of a mindfuck the first time :P
02:20:14 <ski> koz_ : the "leaf" is `return' for this monad. can you figure out `join' ?
02:21:01 <ski> koz_ : otoh, `Fix' doesn't take a "leaf" type at all, just a functor (typically)
02:22:43 <koz_> ski: Hold on. So 'm' in this case is 'Free Two', making join in this case Free Two (Free Two a), right?
02:22:51 <koz_> Wanna make sure I have the type understood.
02:22:57 <ski> where did `m' come from ?
02:23:07 <ski> oh, the type of `join'
02:23:11 <koz_> ski: join :: m (m a) -> m a
02:23:11 <ski> yea, sure
02:23:21 <koz_> I'm just trying to specialize it so I get wtf I'm doing, lol.
02:23:30 <ski> so you'll have to get from that to `Free Two a'
02:23:40 <ski> (or `Free f a', for any `f' with `Functor f', really)
02:24:12 <koz_> ski: Hmmm, this is a bit tricky.
02:24:21 <ski> (hopefully `instance Functor f => Functor (Free f)' should be simple .. right ?)
02:24:37 <bollu> merijn: I also feel very impostor syndrome
02:24:50 <bollu> merijn: like, idk, I don't think I understand "advanced haskell" well enough to teach it
02:24:50 <koz_> ski: One thing at a time... I need to figure out the join function first. :P
02:24:56 <bollu> to teach haskell*
02:24:58 <ski> (recall that if you have `fmap' and `join' (satisfying certain laws), you can recover `(>>=)')
02:25:19 <koz_> bollu: Nobody ever understands anything well enough to teach it. I'm teaching algorithm design, and I'm dreading the next part (dynamic programming) for exactly the same reason.
02:25:31 <ski> (it just so happens that it's often (not always) easier to first implement `join', before `(>>=)')
02:26:02 <bollu> koz_: haha, I suppose. 
02:26:05 <merijn> bollu: The further you get, the more clueless you feel ;)
02:26:11 <bollu> merijn: that's what I tell myself ;)
02:26:35 <koz_> merijn speaks the truth.
02:26:40 <koz_> (in all things)
02:26:45 <koz_> (all hail our new overlord)
02:26:50 <merijn> bollu: tbh, I think one of the main problems with people reading, e.g. Haskell papers for the first time is feeling helpless and confused and only understanding like a quarter and going "well, I must be to dumb"
02:26:50 <sshine> bollu, I've been a TA four times in a course that spends 50% of the time on Haskell, and I still consider myself very much a novice. it's hard not to when there's an even horizon of knowledge in the field. :)
02:26:58 <bartavelle> koz_, easy, dynamic programming is when you use Data.MemoCombinators ;)
02:26:58 * ski . o O ( Dunning-Kruger )
02:27:12 <ski> bartavelle : .. or lazy arrays
02:27:13 <merijn> Meanwhile us academics have just gotten used to the eternal feeling of confusion and not understanding stuff and just bluffing through anyway :p
02:27:19 <koz_> bartavelle: Lol. You've clearly never met my students. :P
02:27:26 <bartavelle> ski, certainly :)
02:27:27 <koz_> merijn: Wow... I thought it was just me...
02:27:52 <sshine> ski, or just impostor syndrome. I have the impression that Dunning-Kruger is pseudo-science.
02:27:55 <merijn> I once read a paper from Conor McBride for my literature study. It was a 24 page paper
02:28:06 <TimLau_> Hi ?
02:28:12 <srhb> TimLau_: Hi.
02:28:13 <koz_> TimLau_: Greetings!
02:28:15 <ski> Lo TimLau_
02:28:21 <merijn> I read 500 pages, including his thesis and 5 years later I *still* barely understand half that paper
02:28:21 <TimLau_> Thx
02:28:33 <koz_> merijn: Which paper was it?
02:28:35 <TimLau_> ?
02:28:36 <bollu> I'm so glad others feel the same way
02:28:39 <merijn> koz_: A view from the Left
02:28:44 <TimLau_> Thx
02:28:53 <merijn> koz_: Jokers to the Left, Clowns to the Right is even worse
02:28:56 <koz_> merijn: I'll have a look at it, some time.
02:29:03 * ski . o O ( Locus Solum )
02:29:12 <koz_> merijn: Could you help me rewrite something into using mutable vectors?
02:29:14 <tdammers> https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect#Supporting_studies
02:29:17 <bollu> I actually wanted to TA for algorithms before I came to college, then I came to college.. we have people who participated in ACM ICPC worlds and IOI. 
02:29:17 <merijn> koz_: I understand the high-level point of what he's describing/doing, but the actual implementation/explanation? <- completely fucking lost :p
02:29:22 <koz_> I have no clue where to even *begin*.
02:29:23 <tdammers> so not completely pseudoscience
02:29:29 <bollu> though I did get to TA for math
02:29:31 <bollu> idk
02:29:35 <koz_> bollu: I've TAd for both.
02:29:37 <MarcelineVQ> ah epigram
02:29:38 <koz_> (several times)
02:30:04 <merijn> MarcelineVQ: I feel like I actually understand a bunch of the stuff about Epigram, since his thesis is pretty readable :)
02:30:07 <bollu> koz_: considering the others in college, I don't think I'm at their level _at all_ when it comes to algorithms. I feel confident about math and FP though
02:30:46 <merijn> koz_: I've never really used mutable vectors in Haskell, so I'm not sure I'd be much help :p
02:31:03 <bartavelle> koz_, I did use mutable vectors ... what it is that you wanna do ?
02:31:05 <koz_> merijn: OK. I figured you might know, because I haven't a clue in ${HELL}.
02:31:11 <koz_> bartavelle: Let me link you.
02:31:22 * bartavelle doesn't want to be linked
02:31:50 <koz_> ld bartavelle
02:31:56 <bartavelle> :)
02:32:16 <koz_> bartavelle: http://lpaste.net/240918 <-- I wanna rewrite the 'ev' function to use mutable vectors inside.
02:32:21 <koz_> I'm not sure how to even begin.
02:32:41 <bollu> merijn: also, I don't undestand ST very well either
02:33:37 <bartavelle> koz_, obviously, you'll need to use the functions in Data.Vector.Mutable, which *should* not be too hard
02:33:44 <bartavelle> then you'll need to run that computation you described
02:33:53 <bartavelle> usually that's with runST
02:34:05 <koz_> bartavelle: I'm having trouble building up the computation, mainly.
02:34:07 <bartavelle> koz_, lemme look at your actual problem
02:34:08 <bartavelle> ok
02:34:19 <merijn> bollu: The "Lazy Functional State Threads" paper is also very readable :)
02:34:38 <bollu> merijn: link please
02:34:59 <merijn> bollu: https://www.researchgate.net/profile/Simon_Peyton_Jones/publication/2295326_Lazy_Functional_State_Threads/links/0046351edd5bb96287000000.pdf
02:35:07 <koz_> Like, for example, I assume the type I'll be dealing with will be something like 'RandT g (STVector s a)', right?
02:35:14 <merijn> bollu: Incidentally, "scholar.google.com" is very good at finding papers, including free versions of the PDF
02:35:39 <bollu> merijn: ohh, thanks! I usually libgen for papers
02:36:00 <bartavelle> koz_, getRandomR is a problem indeed
02:36:10 <koz_> bartavelle: Yeah, that's what's stumping me.
02:36:10 <bartavelle> well, probably not
02:36:13 <bartavelle> humm
02:36:18 <bartavelle> lemme try to build it first :)
02:36:24 <koz_> bartavelle: Thanks!
02:36:50 <bartavelle> what's import Data.Evolutionary.EV.Params ?
02:36:56 <koz_> bartavelle: Let me link you again.
02:37:30 <lpaste> koz_ pasted “No title” at http://lpaste.net/240929
02:37:46 <koz_> bartavelle: ^
02:46:20 <bartavelle> koz_, ok, so here is a way to convert the compete function : http://lpaste.net/541899489774927872
02:46:27 <bartavelle> I'll try to convert the others before lunch
02:46:40 <bartavelle> note that you don't return a new vector, so the return type is m ()
02:47:12 <koz_> Yeah, we're modifying in-place.
02:47:33 <koz_> I guess we have to resort to PrimMonad m there instead of MonadRandom m ... why?
02:50:03 <bartavelle> http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Mutable.html
02:50:14 <bartavelle> all functions here are in PrimMonad
02:50:24 <bartavelle> I'll see how to get rands in a moment
02:50:36 <koz_> bartavelle: We could do it via StateT
02:50:40 <koz_> (since that's an instance)
02:50:57 <koz_> (it's just annoying)
02:53:29 <bartavelle> koz_, or you can pass a lazy infinite list of random numbers
02:54:07 <koz_> bartavelle: So 'cash out' the randomness immediately and just pass it around to everything?
02:54:13 <koz_> (like, in the main 'ev' function)
02:54:37 <koz_> Wouldn't that still need to be maintained as a StateT though?
02:54:52 <koz_> (since we'd have to keep track of it after every function it's fed to)
02:54:56 <bartavelle> koz_, I don't think there will be a problem with keeping the random monad
02:55:06 <koz_> bartavelle: Oh? That's good then.
02:55:14 <bartavelle> you'll just have to lift the calls for the VM stuff
02:55:51 <koz_> bartavelle: Ah, I see.
02:56:20 <koz_> It's a pity there's no generateM for mutable vectors, though.
02:57:00 <bartavelle> koz_,  VM.replicateM (pop p) (gen p)
02:57:44 <koz_> bartavelle: Will that work? RandT is not an instance of PrimMonad.
02:58:06 * hackagebot rl-satton 0.1.2.4 - Collection of Reinforcement Learning algorithms  https://hackage.haskell.org/package/rl-satton-0.1.2.4 (SergeyMironov)
02:58:08 * hackagebot megaparsec 5.1.1 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-5.1.1 (mrkkrp)
02:58:12 <bartavelle> oh, you need randt in there :/
02:58:16 <bartavelle> hum
02:58:25 <koz_> bartavelle: See why I'm having issues? :/
02:58:30 <bartavelle> yes, obviously
02:58:50 <koz_> I mean, I could probably do it with StateT instead, but I've been told by several people on this chan that this is Doing It Wrong(tm).
02:58:53 <bartavelle> but
02:59:17 <bartavelle> you don't really need to have RandT in the call to replicateM_
02:59:17 <koz_> s/chan that/chan said that
02:59:20 <bartavelle> lemme see
03:00:30 <bartavelle> you can decouple stuff
03:03:22 <koz_> bartavelle: Do you know where PrimState comes from?
03:03:51 <Myrl-saki> Errr
03:03:54 <Myrl-saki> Guys
03:04:10 <bartavelle> koz_, Control.Monad.Primitive
03:04:16 <Myrl-saki> Is there a scan which goes on both directions
03:04:22 <Myrl-saki> If that's even possible
03:04:54 <Myrl-saki> It's monad-related, if that changes anything.
03:05:15 <koz_> Myrl-saki: I don't quite follow what you mean by that.
03:05:29 <Myrl-saki> Let's start with the type.
03:06:06 <koz_> bartavelle: Thanks! Looks like I'll need to add a dependency to the .cabal.
03:06:32 <Myrl-saki> :: (MonadFix m, Traversable t) => (a -> a -> a -> m a) -> a -> a -> t a -> m (t a)
03:07:05 <Myrl-saki> Wait.
03:07:16 <Myrl-saki> Let me gist what kind of things it should do.
03:07:17 <bartavelle> koz_, working around MonadRandom is annoying :)
03:08:05 <koz_> bartavelle: I know! I couldn't figure it out either...
03:08:28 <bartavelle> you can always write an orphan instance for it
03:08:57 <koz_> bartavelle: For RandT?
03:09:01 <koz_> Or for something else?
03:09:03 <bartavelle> RandT
03:09:14 <Myrl-saki> Hmmm...
03:09:23 <Myrl-saki> Actually, I may have crapped out on the type there.
03:10:02 <koz_> bartavelle: That seems really painful.
03:10:16 <koz_> I think I'll skip on using mutable vectors - it seems too much like hard work.
03:10:20 <koz_> Thanks anyway, bartavelle!
03:10:37 <bartavelle> koz_, well it's not a lot of work ... if you don't have that RandT stuff
03:10:48 <bartavelle> koz_, writing the orphan instance is trivial
03:10:55 <bartavelle> it's just ... bad
03:11:09 <lyxia> A good type is worth a thousand examples.
03:11:11 <koz_> bartavelle: It's OK - I'll leave this problem on the back burner for now.
03:11:18 <bartavelle> good luck then!
03:11:37 <koz_> bartavelle: Thank you! I'm gonna have a fun time writing encodings for logic formulae... :/
03:12:20 <Myrl-saki> koz_: https://gist.github.com/3fa38efc12e4d74b003c62f032d5a6c8
03:13:33 <Myrl-saki> Maybe an alternative version with only https://gist.github.com/306fbdea40353378778395ede9d40b77
03:15:16 <lyxia> Myrl-saki: do you mean f y' x z'
03:15:28 <MarcelineVQ> :t \f x y -> traverse (f x y)
03:15:29 <lambdabot> (Traversable t, Applicative f) => (t1 -> t2 -> a -> f b) -> t1 -> t2 -> t a -> f (t b)
03:15:30 <Myrl-saki> lyxia: Yeah. Thanks. You get the idea. :D
03:16:13 <lyxia> Myrl-saki: I think using different type variables for the input and the output may help better to figure out what's going on.
03:16:39 <Myrl-saki> lyxia: I'm not exactly sure if there's a way to make it typecheck without doing this though.
03:16:55 <Myrl-saki> Hmm
03:17:01 <Myrl-saki> I thin k I see.
03:17:02 <lyxia> I think this is possible   :: _ => (b -> a -> b -> m b) -> b -> [a] -> b -> m [b]
03:17:25 <Myrl-saki> https://gist.github.com/5abe346977cf6f1bd36423fb5c3a16c3
03:17:59 <Myrl-saki> MarcelineVQ: Hmmm..
03:17:59 <[exa]> I've probably came to a reformulation of my above question:
03:18:03 <Myrl-saki> MarcelineVQ: That doesn't sound too correct.
03:18:08 <Myrl-saki> MarcelineVQ: Though the type *does* match.
03:18:58 <[exa]> Do all parameters of data constructors have kind *? If not, is there an (counter?) example?
03:19:24 <Myrl-saki> BTW, I'm working with Arrows, so that can also change somet hings.
03:19:36 <Myrl-saki> monadic arrow? Kleisli? Not sure what to call it.
03:21:38 <Fairy> To people who understand an object-oriented language and Haskell - how do you compare it to Haskell in terms of difficulty?
03:22:12 <Myrl-saki> Hmmm
03:22:16 <koz_> lyxia: I got an answer from Ed.
03:22:21 <koz_> I'll just paste it real quick.
03:22:25 <liste> @let data ReallyMaybe = Really Maybe -- [exa]
03:22:26 <lambdabot>  .L.hs:162:27: error:
03:22:26 <lambdabot>      • Expecting one more argument to ‘Maybe’
03:22:26 <lambdabot>        Expected a type, but ‘Maybe’ has kind ‘* -> *’
03:22:58 <Myrl-saki> Oh wait...
03:23:23 <koz_> lyxia: http://lpaste.net/241008
03:23:25 <Myrl-saki> Ugh. Typing is hard.
03:23:42 <Fairy> I remember never really having any serious issues learning Java, yet with Haskell it's a pretty huge chore getting into it all :S
03:25:14 <Insanity_> maybe because you have prior experience with Java
03:25:21 <Insanity_> and you tend to model haskell after it
03:26:03 <[exa]> liste: oh, thanks a lot. Cool how it reduces to this simple test.
03:26:28 <liste> [exa]: I'm looking for a real answer atm, I'm sure I saw it somewhere in the report
03:29:26 <Myrl-saki> Okay
03:29:39 <[exa]> liste: that would be great. THIH is not very verbose about where to actually get kinds for 'data'-declared stuff etc.
03:29:50 <Reisen> With a list of data, [x1, x2, x3, x4, x5], how can I map a monad action over this where the monad action is chained. I.E, equivelent to doing:  do; r1 <- action x1; r2 <- action x2; r3 <- action x3; ...; pure [r1, r2, r3, ...]
03:29:52 <Myrl-saki> lyxia: koz_: With less generalization, this is exactly what I need. https://gist.github.com/Myrl/5abe346977cf6f1bd36423fb5c3a16c3
03:29:57 <Reisen> Feeling a bit silly thinking about this
03:30:11 <Myrl-saki> lyxia: koz_: I have a feeling that a recursive definition would work.
03:30:14 <merijn> :t foldM
03:30:16 <lambdabot> (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
03:30:24 <merijn> Reisen: ^^
03:30:40 <Reisen> merijn but that would look more like r1 <- action x1; r2 <- action x2 r1; ... am I wrong?
03:30:41 <merijn> Reisen: oh, wait
03:30:49 <merijn> Reisen: Aren't you just asking for mapM?
03:30:50 <[exa]> liste: my non-functional view of this is that data constructors should contain actual data, not meta; thus only * should be acceptable
03:30:57 <merijn> :t mapM
03:30:59 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
03:31:02 <merijn> aka
03:31:05 <merijn> :t traverse
03:31:07 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
03:31:11 <Reisen> merijn I think mapM would execute the action on each piece of data, but it wouldn't thread the state along for example if I were to run the state monad accross
03:31:12 <ski> Reisen : perhaps you also need a `concat' in there ?
03:31:23 <Reisen> It would run each one with the same start state
03:31:32 <lyxia> Myrl-saki: It's much easier if you just need it for lists.
03:31:35 <merijn> Reisen: You're using State?
03:31:45 <merijn> Reisen: mapM for State does exactly what you want
03:32:08 <Myrl-saki> lyxia: Mhm.
03:32:37 <Myrl-saki> Maybe we can call this dconcat.
03:32:40 <Reisen> merijn, maybe I'm crazy, here's what I get if I define, say,     f x = \s -> (x, s)
03:32:52 <Myrl-saki> For doubly concat.
03:32:54 <Myrl-saki> Dunno.
03:33:27 <Reisen> Wait
03:33:55 <Myrl-saki> lyxia: After giving it more thought, it's getting really really clear.
03:33:58 <Reisen> No yeah, if I run mapM f [1, 2, 3] $ 0, the output will be [(1, 1), (2, 1), (3, 1)]
03:34:11 <Reisen> I.E each action is fed the state 0 
03:34:28 <Reisen> But I'm looking to thread that state along so that the end result looks like [(1, 1), (2, 2), (3, 3)]
03:34:34 <merijn> Reisen: Because that's not the State monad, that's "(->) r" aka Reader
03:34:55 <merijn> Reisen: Also, your 'f' doesn't actually update the State
03:35:08 <Reisen> Meant to put (x, s + 1)
03:35:12 <Reisen> But I see your point
03:35:40 <merijn> > runState (mapM (modify (+1)) [1,2,3]) 0
03:35:42 <lambdabot>  error:
03:35:43 <lambdabot>      • Couldn't match type ‘()’ with ‘StateT s Identity b’
03:35:43 <lambdabot>        Expected type: a0 -> StateT s Identity b
03:35:43 <liste> [exa]: didn't find it, but I think only *'s (and maybe the GHC kinds?) are valid as constructor parameters
03:35:49 <merijn> hmmm
03:36:11 <merijn> > runState (mapM (\x -> modify (+1) >> return x) [1,2,3]) 0
03:36:14 <lambdabot>  ([1,2,3],3)
03:36:55 <Reisen> Right, I see where I was going wrong, thanks merijn 
03:36:55 <merijn> > execState (mapM (\x -> get >>= \s -> put (s+1) >> return (x, s)) [1,2,3]) 0
03:36:58 <lambdabot>  3
03:37:07 <merijn> hmm, wrong one
03:37:13 <merijn> > evalState (mapM (\x -> get >>= \s -> put (s+1) >> return (x, s)) [1,2,3]) 0
03:37:15 <lambdabot>  [(1,0),(2,1),(3,2)]
03:37:18 <merijn> There we go
03:37:30 <Reisen> Yup, that's it
03:37:50 <Reisen> Thanks, confused myself with the \s->(,) sillyness
03:41:34 <SlashLife> Does Haskell have semantic whitespace? Or how long does a "where" block run?
03:41:59 <merijn> SlashLife: https://en.wikibooks.org/wiki/Haskell/Indentation
03:42:34 <Myrl-saki> lyxia: Hey, you there?
03:42:36 <SlashLife> Oh, cool. Thanks. *reads*
03:43:47 <lyxia> Myrl-saki: I'm working on it!
03:43:59 <Myrl-saki> lyxia: I realized something.
03:45:44 <lyxia> did you
03:45:47 <Myrl-saki> lyxia: https://gist.github.com/Myrl/c03663d8da69def97f3e09b1b127faa6
03:45:54 <Myrl-saki> And then iterate using that.
03:46:25 <Myrl-saki> Iterate, kinda.
03:47:02 <Myrl-saki> Still requires some other code such as re-appending the x..
03:47:10 <Myrl-saki> s/x./d/
03:48:44 <Myrl-saki> lyxia: What do you think?
03:49:16 <lyxia> Unfortunately I don't know arrows sufficiently to desugar that
03:51:07 <Myrl-saki> lyxia: Just consider `-<` to be `$` and `<-` to be `let =`
03:55:08 <M2tias> why not $?
03:57:59 <lyxia> I dunno, that still leaves me confused.
04:00:03 <MarcelineVQ> What is the desired outcome?
04:00:35 <MarcelineVQ> Rather, what is this intended to be doing and used for?
04:03:31 <Myrl-saki> lyxia: xD
04:04:09 <koz_> lyxia: In case you missed it - Ed replied, and apparently we're all wrong.
04:04:22 <koz_> Lenses or Traversals don't solve the validation problem, and nor should they.
04:04:28 <lyxia> koz_: Yeah I saw it, thank you :)
04:04:53 <koz_> lyxia: That basically means I don't need to use lenses. It's how it always happens - every time I think I need them, it turns out I don't.
04:05:00 <koz_> Makes me wonder if GuardedLenses could be made a thing.
04:05:09 <koz_> (although I'm not sure if that'll work)
04:06:54 <lyxia> I think the (s -> a, s -> b -> t) pair is still a useful thing to have even if you can't say anything about it in general.
04:23:27 <AleXoundOS> Is it possible to create a shared library using Stack with it's dependencies linked statically?
04:24:11 <dominik> Hi, is it not possible to use standalone deriving for the Read class with GADTs?
04:24:21 <dominik> or am I just using it incorrectly?
04:29:53 <lyxia> dominik: the docs indicate it's possible. But not for all GADTs
04:30:57 <dominik> lyxia: sorry, somehow I was disconnected. I just saw your first answer.
04:31:13 <lyxia> You can't show   T :: a -> T ()   for instance.
04:31:21 <lyxia> I only wrote what you saw.
04:31:55 <dominik> hmm, in my case I'm facing trouble with Read
04:32:27 <dominik> which somehow cannot be derived for the GADT in the above snippet.
04:32:34 <lyxia> okay, it's the same issue though.
04:32:46 <lyxia> Where is that snippet?
04:34:21 <dominik> lyxia: http://lpaste.net/241043
04:34:52 <dominik> only the standalone deriving for Read fails here.
04:35:15 <dominik> the other two derivings work, which makes me wonder.
04:35:16 <lyxia> okay
04:36:13 <lyxia> oh it's not possible to derive Read, because the type of the parsed value would depend on the value of the input String.
04:36:29 <ski> dominik : you should be able to remove the context on those instances ..
04:37:12 <dominik> ski: ok, thanks. But the Read class can still not be derived.
04:37:20 <ski> it might still be possible to (separately) derive `Read (Page FilePath)',`Read (Page (FilePath,FilePath))',`Read (Page ())'
04:37:56 <ski> for reading any `Page', `Read' can't be used. something like a `Read1' could be constructed, i suppose
04:40:25 <ski>   class Read1 f where readsPrec1 :: Int -> Read1 f
04:40:38 <ski>   type Read1 f = String -> [(exists a. f a,String)]
04:40:41 <ski> basically
04:41:09 <ski> one could imagine `instance Read (Exists Page)', though
04:44:19 * ski . o O ( `readsPrec1With :: Int -> (forall a. f a -> String -> o -> o) -> o -> o' )
04:45:14 <dominik> ski: hmmm, I fear I'm not completely following.
04:46:22 <somaReve1> The "class" is "interface" in java and "instance" is "class" in java, am i right?
04:47:11 <hpc> there's a lot of stuff around java's OO which isn't present in haskell even for type classes, so it's hard to make that comparison
04:47:50 <hpc> but if you squint in exactly the right way the comparison is alright i suppose
04:48:23 <hpc> "instance" would be more like "implements" though
04:49:01 <hpc> really it's closer to being just a principled form of operator overloading
04:49:48 <hpc> in "class Foo a where bar :: X a", bar is an overloadable definition
04:50:31 <hpc> each instance provides its own definition which must match the specification (in-language with the type signature and other semantic stuff, out of language with any laws documented for Foo)
04:50:48 <hpc> if X is Maybe, we might have
04:50:54 <hpc> instance Foo Int where bar = Just 0
04:51:00 <hpc> instance Foo String where bar = Just ""
04:51:05 <hpc> instance Foo () where bar = Nothing
04:51:29 <hpc> the real type of bar is Foo a => Maybe a
04:51:33 <ski> somaReve1 : not really ..
04:51:40 <hpc> and it can be used with a type of Maybe Int, Maybe String, or Maybe ()
04:51:47 <hpc> with different definitions for each
04:52:02 <ski> dominik : have you seen existentials yet ? higher-rank ?
04:53:00 <hpc> unlike java, type classes don't have subtyping or inheritance, and you can do quite a few things which java doesn't support
04:53:10 <dominik> ski: not really.
04:53:22 <ski> somaReve1 : note that it's *types* like `Int',`Bool', which are instances of classes, like `Eq',`Show'. unlike in OO parlance where we talk about *values* being instances of a class
04:53:37 * ski smiles at dominik
04:53:46 <dominik> :D
04:54:25 <hpc> really i would just avod the comparison altogether, as what bits of understanding carry over are totally arbitrary and you'd spend just as long memorizing the differences as just learning it from scratch
04:54:44 * ski seconds
04:56:28 <hpc> i think once you learn type classes on their own without comparison to other things, you'll find they're conceptually not that complicated
04:57:01 <hpc> though getting there can sometimes require a frustrating change of mindset
04:58:27 <ski> dominik : would you like me to go over the basics of it (and related topics) ?
04:59:06 <dominik> ski: that would be awesome, if you don't mind
04:59:28 <ski> first, i'd like to reaffirm polymorphism, if you don't mind
04:59:55 <dominik> I know what that is :-)
05:00:06 <ski> yes, but do you know how `forall' works ?
05:00:23 <dominik> well, I guess id :: forall a. a -> a
05:00:40 <dominik> says that the id function works on concrete _all_ types a
05:00:58 <ski> and do you know the difference between `foo :: forall a. ([a] -> [a]) -> Bool' and `bar :: (forall a. [a] -> [a]) -> Bool' ?
05:01:07 * ski nods
05:02:13 * ski looks at dominik
05:02:15 <dominik> I know the second one is a Rank2 type, but I don't know what makes it more expressive.
05:02:28 <ski> well, first, consider again e.g.
05:02:38 <ski>   take :: Int -> [a] -> [a]
05:02:44 <ski> which really is just a shorthand for
05:02:47 <ski>   take :: forall a. Int -> [a] -> [a]
05:02:57 <ski> it's the `forall' part here which signifies polymorphism
05:03:08 <dominik> ok
05:03:13 <ski> specifically, that `forall' occurs first means that `take' is a polymorphic value (here a function)
05:03:25 <ski> `bar' above would *not* be a polymorphic function
05:03:48 <ski> it would be a *monomorphic* function, that is expecting/*requiring* a polymorphic (callback) *argument*
05:04:05 <dominik> ohhh. 
05:04:20 <ski> `foo' can be called with both `id',`reverse',`("hello " ++)' as arguments
05:04:27 <ski> @type ("hello " ++)
05:04:29 <lambdabot> [Char] -> [Char]
05:04:43 <ski> `bar' can't be called with the last one, only the former two of those three
05:05:10 <dominik> I see, that makes sense
05:05:17 <ski> see how the position of the `forall' signifies exactly what is to be polymorphic
05:05:28 <dominik> yes
05:06:32 <ski> btw, just to get it clear. `[a] -> [a]' does in no way mean the same thing as `forall a. [a] -> [a]' (in that case, the type of `bar' would be the same as `([a] -> [a]) -> Bool', which is (the short form) for the type of `foo' .. which is patently false)
05:07:18 <ski> if there's unquantified variables in a type *signature*, that further aren't already in scope before the signature, *then* an implicit `forall' is inserted *just* after the `::' in the signature
05:07:30 <ski> that's the rule for when `forall's are inserted
05:08:01 <ski> but for now, it'd probably be easier if you forgot completely about `forall' being elidable in some cases (for convenience) ..
05:08:10 <dominik> ohh, ok. 
05:08:38 <ski> (one example of "already in scope" would be `fmap :: (a -> b) -> f a -> f b' in `Functor'. here `f' is already in scope from `Functor f')
05:10:13 <ski> anyway, `poly :: forall a. ..a..' means that for every specific type `T' we replace `a' (consistently) with in `..a..' (taking care not to replace unrelated locally bound variables named `a', shadowing the outer one) yielding `..T..', then that is *a* possible type of `poly'
05:10:19 <hpc> sidenote, forall behaves in some ways like a type-level lambda (though in haskell it's not quite exactly that)
05:10:36 <hpc> so in fmap :: forall a b. (a -> b) -> f a -> f b, a and b are bound variables and f is free
05:10:43 <ski> in short, `poly :: forall a. ..a..' means that for every type `a', `poly' *can* have (or be used with) type `..a..'
05:11:06 <hpc> (but that probably won't be important for this)
05:11:18 <dominik> ski: yes, I understand this.
05:11:56 <ski> (yes, `fmap' as a method of `Functor f' is not polymorphic in `f' (though in `a' and `b') .. however, as a standalone function, it is polymorphic also in `f', but with the head of the class declaration as an added constraint : `forall f a b. Functor f => (a -> b) -> (f a -> f b)')
05:12:01 <ski> good
05:13:00 <ski> now, the point with existentials is that we have a similar quantifier, like `abstr :: exists a. ..a..' (but this time an existential quantifier, not an universal one)
05:13:12 <ski> where `abstr :: exists a. ..a..' means that there is *some* (hidden/opaque/forgotten/abstract) type `a' such that `abstr' has type `..a..'
05:13:35 <ski> a silly example is
05:13:43 <ski>   silly :: Bool -> exists a. [a]
05:13:59 <ski>   silly False = ["Two","strings"]
05:14:11 <ski>   silly True  = [2,3,5,7]
05:14:21 <dominik> ok
05:14:34 <ski> note that `exists a. [a]' is the type of lists where all elements have type `a', for some unknown type `a'
05:15:07 <ski> while `[exists a. a]' would be the type of lists, where for *each* element, there *exists* some type `a' (not necessarily the same for each element), with that element having type `a'
05:15:38 <ski> now, go back to a minute to
05:15:44 <dominik> but Haskell doesn't have the latter lists, right?
05:15:55 <dominik> because lists must be monomorphic, or not?
05:16:34 <ski> (so far, i'm talking theory, i'll get back to how one expresses such things currently. still, each element of a list of the latter type has *a* single common type, namely `exists a. a' itself ! :)
05:16:38 <ski>   take :: forall a. Int -> [a] -> [a]
05:17:14 <ski> in Haskell, you can't introspect on `a' inside `take', meaning that `take' will have to treat the list elements as opaque, can't depend on which values they are
05:17:31 <ski> can only shuffle them around, drop them on the floor, duplicate reference to them
05:17:50 <ski> can't conjure up an `a' from nothing (except by `error', `undefined', and infinite loops ..)
05:18:25 <ski> this is known as parametricity. it's good for being able to reason more easily about polymorphic (often higher-order) library operations
05:18:37 <dominik> yes, I understand this.
05:18:41 <ski> @free reverse :: [a] -> [a]
05:18:42 <lambdabot> $map f . reverse = reverse . $map f
05:19:06 <ski> expresses that it doesn't matter if you apply a per-element transformation before or after you `reverse', since `reverse' can't depend on the elements
05:19:23 <ski> now, parametricity also shows up for existentials
05:19:45 <ski> in particular, it means that we can never look at the elements of a list of type `exists a. [a]'
05:19:58 <ski> the only thing we can do with such a list is to check the cons cells, e.g. counting its length
05:20:18 <ski> (we could also force the list elements, as in the polymorphic case, but not more)
05:20:43 <dominik> yes, that makes sense. After all we don't know what type a we're deaaling with in `exists a. [a]'
05:20:47 <ski> also, `exists a. a' is even more useless
05:20:55 <ski> it's basically equivalent to just `()'
05:21:11 <ski> so `[exists a. a]' is basically `[()]', written more convolutedly
05:21:18 <ski> however, consider the type `exists a. (a,a -> a,a -> String)'
05:21:36 <ski> we have a triple `(x,f,s)'
05:21:47 <lyxia> the commas make this hard to parse
05:21:58 <dominik> ski: this looks like the naturals
05:22:01 <ski> we know that the type `a' in the respective types of `x',`f',`s' (namely `a',`a -> a',`a -> String') are the *same* (unknown) type `a' in each case
05:22:09 <ski> yep, basically
05:22:28 <ski> so we can feed `x' through `f' a number of times, then to `s' to inspect the result
05:22:38 <dominik> yes, this all makes sense.
05:23:01 <ski> you could use `exists q. (q,a -> q -> q,q -> Maybe (q,a))' as an abstract type for queues of elements of type `a'
05:23:13 <ski> where the actual implementation of `q' is hidden behind the existential
05:23:24 <ski> (existentials are related to abstract data types, as you can imagine)
05:23:45 <dominik> ok
05:23:54 <ski> well, to be precise, as an abstract type for *operations* on queues of elements of type `a'
05:24:43 <ski> (the component of type `q' would be the empty queue that you start with .. as opposed to the "current" queue .. the latter way is the OO way, the former is the ADT way. there are some qualitative differences to these *styles* of using existentials)
05:25:25 <ski> hopefully, you now have a basic idea of existentials, at least
05:25:27 <ski> now, some logic equivalences
05:25:39 <dominik> ski: yes, I understand existentials
05:25:40 <ski> `... -> (forall a. ..a..)' is equivalent to `forall a. (... -> ..a..)'
05:25:46 <ski> so, e.g.
05:25:56 <dominik> but, how are they encoded with foralls as Haskell has only foralls?
05:25:57 <ski>   take :: Int -> (forall a. [a] -> [a])
05:26:04 <ski> is another way to state the signature of `take'
05:26:12 <ski> dominik : coming to that in a bit :)
05:26:25 <ski> (that's why i started talking about equivalences)
05:27:19 <ski> the above equivalence can be thought of as "`flip'ping" argument order, between an ordinary (explicit) argument (of type `...), and an (implicit) type argument (being the type `a', of some kind, perhaps `*')
05:28:17 <ski> (if passing types to polymorphic operations were explicit in Haskell, then it'd be actual flipping. but now it's implicit. which is also why we can use both those signatures for `take', rather that just claiming that one is isomorphic to the other)
05:29:08 <ski> btw, in case it wasn't clear, for this equivalence to be valid, `a' should not be free in `...'
05:29:12 <ski> dominik : ok ?
05:30:26 <dominik> yes, this makes sense.
05:30:51 <ski> fwiw, there's also an equivalence between `(...,exists a. ..a..)' and `exists a. (...,..a..)', with a similar condition of `a' not being free in `...'
05:31:31 <ski> (corresponding to rearranging `(x,(a,y))' into `(a,(x,y))', with `a' being a type, in the explicit version (not Haskell))
05:32:02 <ski> now, the one i really wanted to mention is between `(exists a. ..a..) -> ...' and `forall a. (..a.. -> ...)'
05:32:06 <ski> this means that
05:32:11 <ski>   length :: forall a. ([a] -> Int)
05:32:14 <ski> is the same thing as
05:32:20 <ski>   length :: (exists a. [a]) -> Int
05:32:29 <ski> if you ponder on that, it should make sense
05:33:00 <ski> it suffices for there to *exists* a type `a' such that the argument has type `[a]', for `length' to be able to be applied to that argument, yielding a result of type `Int'
05:33:24 <ski> the other view is that, for every type `a', `length' can accept an argument of type `[a]', yielding a result of type `Int'
05:33:48 <ski> dominik : ok ?
05:35:37 <dominik> ok (even though now I'm not _that_ assured anymore :D)
05:35:49 <ski> hm, i should mention that in the "explicit type-passing" version, this equivalence corresponds to *currying/uncurrying*
05:36:26 <ttfh> hello, haskell heroes
05:36:30 <dominik> (I mean we're starting to leave my type-level comfort zone now.. :-))
05:36:32 <ski> something of type `(exists a. ..a..) -> ...' can be *thought* of as taking a pair of a type `a', and a value of type `..a..', as argument
05:37:12 <ski> while something of type `forall a. (..a.. -> ...)' can be *thought* of as taking first a type argument `a', then returning a function that will take an argument of type `..a..'
05:37:31 * ski hopes that's reasonably ok, for now
05:37:33 <ski> however, there's no such simple way to reformulate `... -> (exists a. ..a..)', nor `(...,forall a. ..a..)', nor `(forall a. ..a..) -> ...' (the latter can, using *classical* logic, be rephrased as `exists a. (..a.. -> ...)', but that doesn't work in *constructive* logic, which we're using here, for computational reasons)
05:38:12 <ski> "interesting" uses of `exists' are at the end of `->'s (and also inside other type constructors, e.g. representing collections, &c.)
05:38:44 <ski> just as "interesting" (higher-rank) uses of `forall' are at the start of `->'s (and inside other type constructors)
05:39:22 <dominik> ok, 
05:39:26 <dominik> i see
05:39:32 <ski> there's actually one way to reformulate `... -> (exists a. ..a..)', which is useful
05:40:12 <ski> i'll mention the key idea there first, then move to how to actually *encode* `exists' in Haskell
05:40:40 <ski> it happens that `...' is equivalent to `forall o. (... -> o) -> o' (`o' not free in `...')
05:40:56 <ski> consider `hidden :: forall o. (Int -> o) -> o'
05:41:19 <ski> the argument is that `hidden' *has* to be of the form `\k -> k (...)', for an expression `...' of type `Int'
05:41:29 <ski> `hidden' doesn't know what type `o' the caller will pick
05:41:46 <ski> and it has to return a value of type `o', which it can only get from its argument, by supplying an `Int'
05:42:08 <ski> it could call `k' several times, with a `let', but only one of them could end up as the answer, so the others would be dead code
05:42:16 <ski> dominik : does that make sense to you ?
05:43:05 <ski> (`k' is in this context called a continuation. this is related to Continuation-Passing Style, and the `Cont o' monad (and more to the `CoDensity' monad))
05:44:08 <dominik> ski: yes that makes sense
05:44:11 <ski> good
05:44:25 <ski> (i could here mention that `...' is also equivalent to `exists s. (s,s -> ...)' .. you can chew on that if you like. i'll not use it further here)
05:45:25 <ski> ok, so you can't type `exists a. ..a..' in current Haskell implementations (well, you can in LHC, iirc, but only to the left of `->'s, which is a trivial occurence, as indicated above, so ..)
05:45:34 <ski> so, you need to *encode* it
05:45:41 <ski> there's basically two ways
05:46:51 <ski> one is via defining a new data type. this way could be called "existential data (constructor)", though it's sometimes known (improperly) as "existential (data) type" (the real existential type would be `exists a. ..a..', which as mentioned, we can't write (currently, perhaps in future ..))
05:47:46 <ski> so, consider
05:48:02 <ski>   data QueueOps a = MkQO (exists q. (q,a -> q -> q,q -> Maybe (q,a)))
05:48:24 <ski> this is what we'd like to write, but we can't, so we'll massage this a bit into something we *can* write
05:48:51 <ski> if we could write the above, then we'd have the following data constructor signature
05:49:07 <ski>   MkQO :: forall a. (exists q. (q,a -> q -> q,q -> Maybe (q,a))) -> QueueOps a
05:49:25 <ski> and by one of the equivalences above, this is equivalent to
05:49:38 <ski>   MkQO :: forall a q. (q,a -> q -> q,q -> Maybe (q,a)) -> QueueOps a
05:49:51 <ski> and if we permit ourselves to curry the data constructor, then this becomes
05:50:02 <ski>   MkQO :: forall a q. q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> QueueOps a
05:50:20 <ski> we could declare this data type using "GADT"-style syntax, as
05:50:25 <ski>   data QueueOps a
05:50:27 <ski>     where
05:50:31 <ski>     MkQO :: forall a q. q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> QueueOps a
05:50:39 <ski> (`forall' there actually optional)
05:50:47 <ski> or, using the old BNF-inspired style :
05:51:06 <ski>   data QueueOps a = forall q. MkQO q (a -> q -> q) (q -> Maybe (q,a))
05:51:21 <ski> note that the data constructor `MkkQO' is *polymorphic* in `q'
05:51:47 <ski> what's strange here is that `q' doesn't occur in the result type `QueueOps a' (though `a' does, which is a normal parameter to the data type)
05:52:15 <ski> so, applying `MkQO' to some argument will *hide*/*forget* the type `q' used in the argument, leaving no trace of it in the result type
05:53:10 <dominik> ohhh, woow. And that's how the forall inside MkQO eventually leads to an existential (e.g., when we pattern match), right?
05:53:15 <ski> so that, when matching on a pattern `MkQO (empty,enqueue,dequeue)' of type `QueueOps Int' say, we have no idea which `q' was used. so `q' is abstract/opaque to us, when pattern-matching
05:53:38 <ski> dominik : yes, the key is the equivalence of `(exists a. ..a..) -> ...' to `forall a. (..a.. -> ...)'
05:54:13 <Tuplanolla> I sense someone has an urge to write a blog.
05:54:45 <ski> note that, even matching on the (statically known to be the) *same* value, will yield, to the type system, *distinct* `q's (aka "skolems" or "rigids")
05:55:21 <ski> (if you wonder about that, i could elaborate. otherwise i'll skip that now)
05:56:13 <dominik> ski: awesome, I see how this last logical equivalence between exists and forall works.
05:56:15 <ski> anyway, we say that `MkQO' is an "existential data constructor"
05:56:32 <ski> note that you can have many data constructors for a data type, some "existential" in this sense, and some not
05:56:42 <ski> so it's really about the data constructor, not the data type per se
05:57:28 <ski> (but often (not always), there's only a single data constructor. hence people often tend to say "existential data type")
05:58:16 <ski> hm .. should i add the complication of type classes right now, or should i go over the other *encoding* of `exists' first ? any wish ?
05:58:38 <ski> Tuplanolla : i don't blag :)
05:58:57 <dominik> ski: the other encoding :-)
05:58:57 <Tuplanolla> Now's as good a time to start as any, ski.
05:59:08 * ski would rather refrain
05:59:12 <ski> dominik : *nod*
05:59:35 <ski> so, i mentioned that the type `...' being equivalent to `forall o. (... -> o) -> o'
06:00:25 <ski> instead of directly computing a value of type `...', we wait for a continuation function of type `... -> o', which we promptly pass our "result" to (and then give *that* as the real result), instead of yielding our result in the direct/normal way
06:01:11 <ski> *if* we remove the `forall o.' part here, either using `o' also in other places in a larger type signature, or replacing `o' with some (more) specific type, then one can do lots of fun/strange tricks with this idea (continuations)
06:01:36 <ski> however, as long as we insist of the `forall o.' there, we can't express any more "weird" stuff than what we already can with `...'
06:01:42 <ski> ok
06:01:56 <ski> so, consider now the type `exists a. ..a..' that we want to encode
06:02:17 <ski> according to the above, that is equivalent to `forall o. ((exists a. ..a..) -> o) -> o'
06:02:57 <ski> which, by the other equivalence we used above, in the "existential data constructor" encoding, is equivalent to `forall o. (forall a. ..a.. -> o) -> o'
06:03:04 <ski> (note how this is rank-2)
06:03:15 <ski> this is the CPS encoding of `exists'
06:03:33 <ski> consider something like
06:04:00 <ski>   foo :: Foo -> (exists a. (a -> a,a -> String,[a]))
06:04:10 <ski> according to the above encoding, we can reformulate this as
06:04:40 <ski>   fooWith :: Foo -> (forall a. (a -> a) -> (a -> String) -> [a] -> o) -> o
06:06:15 <ski> instead of calling it like `..(foo myFoo)..' (possibly using `let' or `case' to deconstruct the triple, e.g. `..(case foo myFoo of (f,s,xs) -> ..f.s.xs..)..'), you call it like `..(fooWith myFoo (\f s xs -> ..f..s..xs..))..'
06:06:46 <ski> so you explicitly pass the consumer function as the continuation argument to `fooWith', instead of directly looking at the result
06:07:38 <ski> (with the existential data constructor encoding, you'd commonly use it like `..(case foo myFoo of MkQEx (f,s,xs) -> ..f..s..xs..)..')
06:08:04 <ski> there's roughly the same amount of syntactic overhead, in each case
06:08:39 <dominik> ok. I liked the data constructor encoding better somehow
06:08:44 <ski> sometimes the CPS version is a bit nicer, though .. especially if you're not interested in storing your existential stuff in a data structure, but only interested in communicating it to the caller
06:09:22 <ski> if you want to store in data structures, or pass around without deconstructing into parts, then the existential data constructor version is usually to be preferred
06:09:53 <ski> (and people normally think of that encoding. however, i wanted to emphasize that it's just *one* encoding, and that the other one mentioned can also be useful)
06:10:15 <ski> some more points
06:10:25 <ski> i think i'll take the type class part first
06:10:35 <ski> consider `forall a. C a => ..a..'
06:11:17 <ski> we can conceptually think of this as a function taking a type `a', yielding a function that takes "evidence" that `C a' holds, before yielding a result of type `..a..'
06:12:03 <M2tias> Tuplanolla: he doesn't need to write a blog post. he could just copy and paste
06:12:16 <ski> here, the evidence for `C a' can be thought of as a record of the implementations of the methods of `C', for `a', iow from the `C a' instance (possibly implied, e.g. `Show [Int]' coming from `Show Int' and `forall a. Show a => Show [a]')
06:12:38 <ski> dominik : are you familiar with this way of thinking of type class constraint evidence ?
06:14:07 <dominik> ski: one thing I didn't exactly understand is why type `...' is equivalent to forall o. (... -> o) -> o'. I know that the latter has to be the term `\k -> k (...)', but why are the types equal then?
06:15:51 <ski> well, if you know that the value of the latter type (`forall o. (... -> o) -> o') is `\k -> k (...)', then you can convert this, by first picking the type `o' to be the type `...', then pass `id' as argument (plugging into `k'), yielding the result `...'
06:16:10 <ski> in the other direction, you take the value `...' of type `...', and wrap it up in `\k -> k (...)'
06:16:28 <ski> and clearly, these two translations, in opposite directions, are the inverses of each other
06:16:38 <ski> hence you have a bijection (or isomorphism)
06:17:04 <dominik> ski: ah, I see. Ok :-)
06:17:14 <ski> the only part which one might doubt is that every value of type `forall o. (... -> o) -> o' is actually of form `\k -> k (...)', for some value `...' of type `...'
06:17:43 <ski> (but parametricity buys us that. if we had unrestricted "reflection/introspection", then this would probably break)
06:17:58 <ski> anyway, type class dictionaries
06:18:06 <ski> @src Eq
06:18:06 <lambdabot> class Eq a where
06:18:06 <lambdabot>     (==), (/=) :: a -> a -> Bool
06:18:06 <chpatrick> have you guys ever got segfault when using hmatrix with multiple threads?
06:18:11 <chpatrick> it's probably some kind of let floating issue
06:18:13 <ski> correponds to
06:18:17 <ski>   data EqDict a = MkEqDict {eq :: a -> a -> Bool,neq :: a -> a -> Bool}
06:18:19 <ski> and
06:18:22 <ski> @src Functor
06:18:22 <lambdabot> class Functor f where
06:18:22 <lambdabot>     fmap :: (a -> b) -> f a -> f b
06:18:26 <ski> correponds to
06:18:28 <ski>   data FunctorDict f = MkFunctorDict {fmap :: forall a b. (a -> b) -> f a -> f b}  -- note that the `fmap' field here is polymorphic, because the corresponding method of `Functor' is polymorphic (as opposed to the case for `Eq')
06:18:52 <ski> via this translation, `forall a. Eq a => ..a..' becomes `forall a. EqDict a -> ..a..'
06:19:37 <dominik> ok, I see.
06:19:54 <ski> (and in the general case, you *do* need to pass around evidence at run-time, like this, or some equivalent fashion. this is because of (a) "polymorpic recursion" (in Haskell98 even, not used that often, but handy when needed); and (b) because of existentials)
06:20:04 <ski> ok, so
06:20:39 <ski> the point now is that `(exists a. C a *> ..a..) -> ...' is equivalent to `forall a. (C a => (..a.. -> ...))'
06:21:10 <ski> or even just that `(C a *> ..a..) -> ...' is equivalent to `C a => (..a.. -> ...)'
06:21:31 <dominik> what's that *> ?
06:21:41 <ski> a value of type `C a => ..a..' demands the *user* to provide evidence of `C a', before being able to be used as having type `..a..'
06:22:06 <ski> a value of type `C a *> ..a..' will itself *provide* evidence of `C a', together with a value of type `..a..'
06:22:22 <ski> `=>' is typically used with `forall', and `*>' typically with `exists'
06:22:48 <ski> `C a => ..a..' is like a function from an instance dictionary, to a value of type `..a..'
06:23:03 <ski> `C a *> ..a..' is like a *pair* of an instance dictionary, and a value of type `..a..'
06:23:37 <ski> (but since type class evidence is implicitly propagated, you don't see such functions and pairs explicitly)
06:24:20 <ski> `*>' is syntax i invented (not implemented in any Haskell implementation, afaik), to be able to talk more clearly about this stuff
06:24:42 <ski> (the `*' is supposed to remind you of (type) product, as in the pair type)
06:25:07 <ski> anyway, there are cases where one'd use `=>' without a `forall' just before
06:25:13 <ski> and similarly for `*>' and `exists'
06:25:25 <ski> anyway, an example
06:25:42 <ski>   data Showable = forall a. Show a => Wrap a
06:25:44 <ski> gives
06:25:57 <ski>   Wrap :: forall a. Show a => a -> Showable
06:25:58 <ski> aka
06:26:05 <ski>   Wrap :: (exists a. Show a *> a) -> Showable
06:26:37 <ski> so we can write `[Wrap False,Wrap 42]', having type `[Showable]', encoding `[exists a. Show a *> a]'
06:27:14 <ski> if we had a real `exists', then `[False,42]' would be expected to have type `[exists a. Show a *> a]'
06:27:31 <ski> so, there's some overhead here in the syntax, in that we have to explicitly wrap with `Wrap'
06:27:33 <crobbins> *> does exist
06:27:36 <crobbins> (*>) :: Applicative f => f a -> f b -> f b
06:27:46 <ski> yeah .. but that's not type-level
06:27:55 <crobbins> oh i see what you mean
06:28:00 <crobbins> carry on
06:28:02 <crobbins> :D
06:28:10 <ski> (iirc, it didn't exist when i made the above syntax up ..)
06:28:54 <ski> if you try constructing valued of `exists a. ..a..', using the CPS encoding, then you'd also get similar syntactic overhead
06:29:00 <ski> s/valued/values/
06:29:47 <ski> in the CPS encoding, one'd use `forall o. (forall a. Show a => ..a.. -> o) -> o', as expected
06:30:54 <ski> if one wanted a list, then one'd probably prefer `forall o. (forall a. Show a => [..a..] -> o) -> o' to `[forall o. (forall a. Show a => ..a.. -> o) -> o]', given a choice (the latter is probably slightly more powerful)
06:31:32 <ski> anyway, i wanted to close with emphasizing a certain duality
06:32:48 <ski> a *consumer* (caller,user) of a value of type `forall a. ..a..' may pick any `a' they like, while the *producer* will have to be prepared for any choice of `a', being polymorphic in `a'
06:33:07 <ski> (the producer aka callee, or implementor)
06:33:45 <ski> a *producer* (callee,implementor) of a value of type `exists a. ..a..' may pick any `a' they like, while the *consumer* (caller,user) will have to be prepared for any choice of `a', being polymorphic in `a'
06:34:01 <ski> dominik : makes sense ?
06:36:28 <dominik> ski: yes
06:37:21 <ski> @where existential-antipattern
06:37:21 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
06:37:44 <ski> you might want to check out that ^ to not use existentials when they're not called for, though
06:38:05 <ski> e.g. `exists a. Show a *> a' is basically `String', so you might as well simplify it to that
06:38:51 <ski> any `exists a. ..a..' where `a' is only used covariantly/positively in `..a..' is basically `Fix (\a -> ..a..)', iow a recursive data type
06:39:44 <ski> (aka `mu a. ..a..' (for technical reasons, that should say `nu', not `mu'. in Haskell, there's no practical difference, only a conceptual one of intended meaning))
06:40:05 <Franciman> Hello, I have OverloadedStrings on. I get an error on this literal "o"
06:40:15 <Franciman> It says Char is not an instance of IsString
06:40:19 <Franciman> why's that?
06:40:43 <ski> perhaps you meant `["o"]' ?
06:40:52 <dominik> ski: Wow, 105 minutes of explanation. You've made existentials much clearer to me. Thanks a lot, you're my hero! I need to read over it again though, to digest it well.
06:40:56 <Gurkenglas> No, that's the wrong way round ski
06:41:06 <Franciman> ski, no I have this string in my code "o"
06:41:08 <Gurkenglas> You put "o" in a place where a Char belongs Franciman
06:41:14 <Franciman> oh
06:41:16 <Franciman> ok thanks
06:41:31 <ski> oh, i suppose
06:41:38 <Franciman> you were right. Thanks a lot
06:42:41 <ski> dominik : there's some other equivalences that sometimes are used, like `mu r. ..r..' being `forall r. (..r.. -> r) -> r', `nu s. ..s..' being `exists s. (s,s -> ..s..)'
06:43:11 <Gurkenglas> We need better support for showing all the possible places where the types inferred might start mismatching with the types the programmer expected
06:43:37 <ski> dominik : for `f' with `Functor f', `f b' is `forall a. (a -> b) -> f b', `f a' is `exists a. (f a,a -> b)' .. (`Yoneda f b' and `Coyoneda f a')
06:44:08 <ski> dominik : .. but i'll refrain from going into them at this time, since this is probably enough to stomach
06:44:15 <Gurkenglas> Like, he probably wouldn't have had to ask here if the compiler said that the function to the left of the "o" expects a Char
06:44:40 <ski> Gurkenglas : type error slicing would be really nice
06:44:56 <Gurkenglas> Does some other language have it already?
06:45:17 <dominik> ski: yes, definitely :-)
06:45:30 <dominik> ski: thanks a lot!
06:45:36 * ski bows
06:46:55 <mnoonan> I always imagined keeping around enough information to localize type errors would offset the efficiency of unification.. not true?
06:46:58 <Gurkenglas> Oh hey you just gave me a keyword to google http://www.macs.hw.ac.uk/~jbw/papers/Haack+Wells:Type-Error-Slicing-in-Implicitly-Typed-Higher-Order-Languages:SCP-ta.pdf
06:47:12 <mnoonan> it seems similar to replacing unification with subtyping
06:47:15 <ski> Gurkenglas : for (iirc, part of) SML, "Skalpel: A Type Error Slicer for SML" <http://www.macs.hw.ac.uk/ultra/skalpel/>
06:49:59 <Gurkenglas> mnoonan, here's a simple algorithm for it: After a type mismatch, have it add an annotation directly at the mismatch that makes the expected and actual types equal, so that the type error must change (but cannot go away as we just restricted the compiler even more)
06:51:32 <mnoonan> hm, interesting
06:52:57 <Gurkenglas> I guess what the compiler could do is, whenever there are multiple possible places for a mismatch, take a mismatch position roughly in the middle and present the user with the two types it inferred for it based on which side is correct, and asks him to say which he meant that place to have
06:54:04 <ski> type error slicing returns a set of locations, all of which (to the knowledge available to the type checker) contribute to the type error, and including all such locations
06:54:27 <ski> at least one of them has to be changed, in order to avoid the type error (if possible)
06:55:17 <ski> (so for effectiveness, one'd probably prefer integration with editor/IDE)
06:56:17 <Gurkenglas> And to combine that with my idea, hovering over any such location produces a tooltip with the two inferred types, and selecting one silently annotates the place with the type selected, recompiles, and removes "half" the locations
06:56:42 * ski nods
06:57:06 <ski> (incremental/adaptive computation might be useful here ..)
06:57:17 <Gurkenglas> -computation+compilation?
06:57:31 <ski> as the special case desired here, yes
06:57:44 <ski> @where adaptive
06:57:44 <lambdabot> "Adaptive Functional Programming" by Umut Acar,Blelloch,Harper in 2002 (POPL) at <http://www.umut-acar.org/publications/popl2002.pdf> and in 2006 (TOPLAS) at <http://www.umut-acar.org/publications/
06:57:44 <lambdabot> toplas2006.pdf>
06:57:45 <ski> @where incremental
06:57:45 <lambdabot> "Monads for Incremental Computing" (Functional Pearl) by Magnus Carlsson in 2002 (ICFP) at <http://www.carlssonia.org/ogi/papers/icfp-2002.pdf>,<http://www.carlssonia.org/ogi/Adaptive/>,in Hackage
06:57:45 <lambdabot> at <http://hackage.haskell.org/package/Adaptive>
06:58:20 <ski> (iirc, attribute grammars are also relevant for that)
06:59:03 <ski> (Guy Blelloch, and Robert (Bob) Harper, i.e.)
06:59:12 <Gurkenglas> Include Cheat Engine in ghc, take a snapshot of the compiler state just before it tried to infer that type, reload it once the annotation is supplied
06:59:44 <ski> this seems to be headed near SWANK :)
07:01:13 <ski> (where Emacs communicates with the Lisp implementation (like for some Common Lisps, or some Schemes), incrementally modifying the internal state of the Lisp image in the running process)
07:01:14 <Cale> Gurkenglas: I kinda want that for a dependently typed language, where it'll say "I can't unify these", and then you have the opportunity to put in a proof of their equality. :)
07:01:54 <Cale> (perhaps more fun than writing complicated transports)
07:02:07 <ski> ("transports" ?)
07:02:25 <Gurkenglas> isomorphisms, I'm betting
07:03:47 <ski> (complicated as in how to apply it at the right point, or genuinely complicated ?)
07:04:29 <Cale> transport being the thing which gets you a map P x -> P y based on a proof p : x = y
07:04:47 * ski nods
07:05:07 <ski> (though i'm more used to seeing that called `subst')
07:05:13 <Cale> ah, yeah
07:05:27 * ski should reread the directed 2-dimensional type theory paper
07:05:51 <ski> (any other paper you'd suggest, in addition to the book ?)
07:07:00 <Cale> I dunno... well, there was an interesting one recently about a two-level type theory: https://arxiv.org/abs/1604.03799
07:08:08 <Cale> The book is really good as far as intro material goes
07:09:06 <Cale> If you want to learn more classical homotopy theory alongside it, I would recommend Ronald Brown's book "Topology and Groupoids", since it does things the nice categorical way.
07:09:31 <Cale> (he's actually responsible for the introduction of groupoids as a tool in homotopy theory)
07:23:22 <ski> Cale : nice, ty
07:26:53 <ski> (hm, local lib (only) has "Nonabelian algebraic topology : filtered spaces, crossed complexes, cubical homotopy groupoids", by same author)
07:29:48 <Cale> hmm, sounds interesting, but definitely more advanced
07:30:43 * ski figured
08:00:12 <onepunchtee> hi
08:00:28 <lyxia> hi
08:14:48 <x1f577> Is there a way to use persistent with pre-defined types? Meaning, a way to generate the necessary classes from an existing "data Blah = MkBlah { ... }' type?
08:17:24 <Joss> Hi
08:17:39 <Joss> I need some help
08:18:13 <Joss> Whats is the difference between (/10) 200 and (/) 10 200
08:18:31 <Joss> Im trying to understand curried on haskell but im so confused 
08:19:07 <lyxia> (/10) is the same as (\x -> x / 10)
08:19:08 <x1f577> (/10) 200 = 200 / 10
08:19:29 <x1f577> (/) 10 200 == 10 / 200
08:19:51 <Joss> I already know that because result but why us that
08:20:04 <x1f577> same thing for strings: (++) "hello" "world" = "helloworld"
08:20:14 <x1f577> same thing for strings: "hello" ++ "world" = "helloworld"
08:20:17 <fractalsea> Do you understand what `(/) 10 200` is?
08:20:19 <geekosaur> taking an operator and wrapping it in () turns it into a function.
08:20:29 <x1f577> putting parenthesis around an infix operator makes it prefix
08:20:45 <x1f577> geekosaur's response is more accurate, i think
08:20:47 <Joss> Yes, / divided first argument by second argument 
08:21:08 <geekosaur> adding the argument for one side of the operator yields a section: (/10) is \x -> x / 10. (10/) is \x -> 10 / x
08:21:48 <Joss> Oppppsss 
08:21:52 <geekosaur> and it is still a function, not an operator, so the missing parameter follows it as a function argument
08:23:00 <fractalsea> (/10) has applied the 10 as the denominator, and it returns a function that takes the numerator as the parameter 
08:23:14 * hackagebot hjsonschema 1.2.0.0 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-1.2.0.0 (seagreen)
08:23:16 * hackagebot HsOpenSSL 0.11.2.1 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.2.1 (VladimirShabanov)
08:23:28 <fractalsea> If you did (10/) then 10 is the numerator, and it is a function that takes the denominator as the parameter
08:24:36 <Joss> Actually / is the divide function where first argument is divided by.If you see its  
08:26:27 <Joss> Second argument. When you try to curriend (/) function just surround it with () in thst way >  let dividebyeten = (/) 10 
08:36:56 <Joss_> I understand that space is applied argument to a function
08:37:34 <Joss_> but...what does (/10) without space mena?
08:37:50 <Tuplanolla> It's just sloppy writing, Joss_.
08:38:34 <monochrom> space is not applying argument to a function. space is one way (out of many) to separate tokens.
08:39:13 <monochrom> instead, token juxtaposition is function application
08:39:56 <monochrom> for example "(sin)4" is another way to separate the two tokens "sin" and "4". and they are still juxtaposed, so you are still looking at function application
08:40:01 <monochrom> > sin 4 = (sin)4
08:40:03 <lambdabot>  <hint>:1:7: error:
08:40:03 <lambdabot>      parse error on input ‘=’
08:40:03 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
08:40:06 <monochrom> > sin 4 == (sin)4
08:40:10 <lambdabot>  True
08:40:42 <Joss_> oww
08:40:44 <Joss_> so
08:41:03 <monochrom> "(/ 10)" and "(/10)" are the same thing, and it is section syntax. the space is optional because the token separation can be done with or without space here.
08:41:48 <Joss_> How I should understand partially applied of function??
08:41:56 <monochrom> It is important to use empirical evidence to correct your mental model, not your mental model to correct empirical evidence.
08:42:55 <monochrom> There are two ways.
08:43:15 <monochrom> If you are type-oriented, you learn types like "Int -> Bool -> Char".
08:43:40 <Joss_> yes
08:43:56 <monochrom> If you are value-oriented, you learn terms like "\x -> \y -> if even x && y then 'c' else 'd'"
08:44:29 <Joss_> no, the first point of me is more easy to me...
08:44:35 <Joss_> type-oriented
08:45:21 <monochrom> OK, so suppose "f :: Int -> Bool -> Char" which also means "f :: Int -> (Bool -> Char)". And suppose "x :: Int".
08:45:38 <monochrom> Then the consequence is "f x :: Bool -> Char". Done. It's just logic.
08:45:47 <Tuplanolla> > Data.Function.id.Data.Function.id.id$2
08:45:50 <lambdabot>  2
08:46:11 <quchen_> Good gracious.
08:46:13 <monochrom> People give it a name "partially applied function" but you don't need it. You just follow the logic to its logical conclusion.
08:47:14 <monochrom> People also write a lot of essays as though there is much deep wisdom about it. They are just mystifying basic logic.
08:47:43 <Joss_> Ok. Lets see when I have for example compare function and I desired compare any number with 100 I think in function like  compareWithHundred = compare 100 
08:48:01 <lgstate> https://github.com/sweirich/pi-forall/blob/2014/version1/src/TypeCheck.hs#L67 <-- what does the '->' mean?
08:48:13 <Joss_> then if I do compareWithHundred 89 it should result LT
08:48:19 <Joss_> but
08:48:38 <Joss_> no, it result GT and that is not correct
08:48:47 <monochrom> I thought you wanted the type story not the term story.
08:48:55 <Tuplanolla> It's a ViewPatterns thing, lgstate.
08:49:16 <monochrom> If you wanted the value story, you should not lie.
08:49:18 <lgstate> I have heard of view patternsn
08:49:45 <shirt> is there a config file library that is type safe (similar to optparse-applicative)?
08:49:48 <Tuplanolla> Here's more, lgstate: https://ocharles.org.uk/blog/posts/2014-12-02-view-patterns.html
08:50:40 <Cale> Joss_: compare x y produces (a representation of) the comparison which would be successful if you put it in between x and y
08:50:52 <Cale> So compare 100 89
08:50:57 <Cale> 100 is greater than 89
08:51:02 <Cale> --> GT
08:52:04 <Joss_> Cale, I know but it follow and order of arguments
08:52:07 <Cale> Joss_: You can flip compare if you want to invert the ordering.
08:52:34 <monochrom> we are following order
08:52:55 <Cale> flip compare 100 89 -> compare 89 100 -> LT
08:52:59 <monochrom> compareWithHundred 89 = (compare 100) 89 = compare 100 89. You have no choice.
08:53:25 <stevenxl> Hi folks. I'm using ghci's REPL. but when I type the `doubleMe x = x + x`, I get an error. 
08:53:39 <stevenxl> Parse error on input "=".
08:53:50 <monochrom> in ghci you have to add "let " in the front.
08:53:51 <Cale> stevenxl: Which version of GHC? Only very recent ones won't complain at you there
08:54:03 <stevenxl> version 7.10.3
08:54:17 <monochrom> But I still recommend putting your code in a file and using :load and :reload
08:54:21 <Cale> Yeah, anything older than 8 won't let you make declarations without prefixing them with 'let'
08:54:34 <stevenxl> Yup. that was the problem!
08:54:35 <stevenxl> thank you 
08:54:39 <Cale> and yeah, the right thing to do is just to put your code into a file anyway
08:54:45 <Joss_> Yes, the better way is use :load or :l for simply
08:55:04 <stevenxl> OK I'll do that (:l and :r
08:55:06 <monochrom> you will want a file because you will want to use a real editor of your choice
08:55:11 <Cale> I usually just pass the filename I want to load on the commandline to ghci, and then :r to reload
08:55:59 <Cale> Also, you never know when you might actually end up wanting to keep the stuff that you wrote :)
08:56:18 <Joss_> How I can create a function that take a number and compare it with 100, its put 100 in second argument?
08:56:47 <Cale> Joss_: That's what I was demonstrating with flip compare
08:57:04 <chpatrick> :t (`compare` 100)
08:57:06 <lambdabot> (Ord a, Num a) => a -> Ordering
08:57:15 <monochrom> There are about 4 ways.
08:57:17 <chpatrick> let f = (`compare` 100) in f 50
08:57:23 <stevenxl> monochrom / Cale: I'm convinced. I'm just used to the REPL being throwaway, but I think in Haskell thats a bit different. The "prototype" code can often me used in production. 
08:57:25 <chpatrick> > let f = (`compare` 100) in f 50
08:57:27 <lambdabot>  LT
08:58:14 <monochrom> "f y = compare y 100" is not too shabby either.
08:58:29 <monochrom> You can also use lambda. (\y -> compare y 100).
08:59:32 <monochrom> There are many ways and you will see all of them if you learn Haskell systematically rather than incidentally.
08:59:51 <monochrom> In fact, learn some basic lambda calculus systematically. Then Haskell is not far away.
09:00:41 <Joss_> I know man. But in my book specific in partially applied of a function I have this example and Im so confused
09:00:47 <monochrom> To some extent Haskell just add more syntax, for example "(/ 10)" is syntax for "(\x -> x / 10)".
09:01:22 <monochrom> Use intuition for maximum confusion. Use logic for zero confusion.
09:02:09 <Joss_> Heres is the book
09:02:11 <Joss_> http://learnyouahaskell.com/higher-order-functions#curried-functions
09:02:50 <Joss_> there is compare 100 used in bad way for teach
09:07:26 <nitrix> Joss_: What confuses you? I don't see `compare` being used in a "bad way" there.
09:09:32 <monochrom> "(/ 10)" is not under the same syntax rule as "compare 10"
09:09:45 <Joss_> Notice that They are using compare 100 like a partially function to compare ANY number with 100 , compare x 100, no compare 100 x.
09:09:54 <monochrom> "(/ 10)" is section syntax, "compare 10" is still ordinary function application syntax.
09:10:21 <monochrom> "compare with" is ambiguous English to begin with.
09:10:30 <Joss_> yes
09:11:02 <monochrom> but code is precise. "compare 100 89" is only one thing.
09:11:25 <monochrom> Meta-lesson: do not trust "meaningful" names either.
09:11:36 <nitrix> Joss_: compare 100, is a function expecting one argument to be compared with 100 and it yields an Ordering.
09:12:01 <nitrix> Joss_: If you can narrow the problem to the part the confuses you, I can try to walk you through.
09:12:12 <monochrom> The beauty of standards is there are so many conflicting standards to choose from. The beauty of meanginful names is that there are so many conflicting meanings to choose from.
09:12:38 <Joss_> Yes nitric, and this missing argument is place in second position right?
09:12:44 <monochrom> "compareWithHundred" has two meanings. actually about five meanings.
09:13:05 <nitrix> Joss_: What do you mean, missing argument?
09:13:18 <monochrom> Does it mean "\x -> compare 100 x"? Does it mean "\x -> compare x 100"? Does it mean "\x -> 100 > x"? The possibilities are endless.
09:13:21 <Joss_> Maybe im confused cause im dealing with Prolog too :(
09:14:16 <monochrom> No, you are reading the sloppy English "compare with hundred" and think you know what the author means, then infuriated when you find out the author means something else.
09:14:22 <nitrix> `compare` is a function that "expects two arguments". `compare 100` is a function that "expects one argument". The example is defining the function `compareWithHundred` to be equivalent to `compare 100` which it is.
09:15:34 <monochrom> You should instead cut English some slack and use code to clarify English, not use English to clarify code.
09:15:41 <nitrix> monochrom: Langustic aside, I'm fairly certain it's function extensionality and partial application that confuses him at the moment. Not the name of compareWithHundred.
09:16:00 <geekosaur> ^
09:16:00 <nitrix> linguistic*
09:16:07 <monochrom> But he already knows what's "compare 100 89"
09:16:26 <martinr-> connect 46.101.93.232/9999
09:16:33 <martinr-> oops
09:17:04 <martinr-> nobody saw that ip address ^
09:17:07 <ReinH> Consider not using that book
09:17:35 <nitrix> If you feel your nitpicking is useful, go ahead, but I see someone struggling on more basic fundamentals, partly because they're using LYAH to learn .
09:17:57 <nitrix> Joss_: I'm available on #haskell-beginners if you have some free time.
09:18:37 <Joss_> Using partially applied functions how I can create a function that take number and compare it againts 100... compare 4 100 LT, compare 200 100 GT
09:19:18 <grantwu> How well do you understnad partially applied functions in general?
09:19:28 <nitrix> Joss_: Without checking, what would you expect the type of `compare` to be?
09:19:28 <grantwu> :t (+2)
09:19:30 <lambdabot> Num a => a -> a
09:19:32 <monochrom> Don't use partially applied functions for that.
09:19:51 <grantwu> monochrom: Judging from the wording I'm assuming this is a homework exercise
09:20:04 <monochrom> At least, not for now. Write out the full "f x = compare x 100" and be done.
09:20:09 <Joss_> compare say what relation holds between two arguments
09:20:32 <monochrom> You can use "flip" but then you have to learn "flip" too.
09:21:04 <Joss_> thanks monochroom
09:21:15 <Joss_> that helps me keep calm 
09:23:15 * hackagebot wrecker 0.1.3.0 - An HTTP Performance Benchmarker  https://hackage.haskell.org/package/wrecker-0.1.3.0 (JonathanFischoff)
09:42:12 <AleXoundOS> Hi. Is it possible to create a shared library using Stack with it's dependencies linked statically?
09:44:52 <laudiacay> anyone have tips on plugins for haskell in vim? I'm specifically looking for v nice syntax highlighting :)
09:51:53 <cocreature> laudiacay: I’m not a vim user so I can’t help you directly but http://www.stephendiehl.com/posts/vim_2016.html should be useful
09:52:15 <Joss_> People
09:52:20 <laudiacay> cocreature: thanks dude
09:52:38 <Joss_> for my mac...what is the best  client for freenode?
09:53:44 <johnw> better to ask in a channel like #freenode, there are lots of options
09:55:30 <Joss_> Don't worry :D
09:55:55 <johnw> check your PM :)
09:58:26 <laudiacay> so cocreature could you help me with another issue? for my class I'm doing a sort of problem where we have to turn a function definition that uses another function definition inside a where using an if/then/else into something using guarded statements
09:58:39 <laudiacay> and I'm not really sure how this is supposed to work
09:59:24 <cocreature> laudiacay: could you paste an example on http://lpaste.net? I’m not sure I understand the problem
10:00:09 <laudiacay> cocreature: so the exercise is at http://cmsc-16100.cs.uchicago.edu/2016/Lectures/04-natural-recursion.php, number 4.1, and I'm currently formatting my code for you to look at
10:01:11 <laudiacay> cocreature: here's the code: filter' is the one the teacher gave us, and filter'' is my shitty attempt that ghci dislikes. http://termbin.com/vcec
10:04:11 <cocreature> laudiacay: I would recommend to just write your code in a file and then run ":l filename.hs" in ghci to load it. the syntax accepted by ghci is slightly weird and understanding why something is not accepted can be a bit frustrating at the beginning
10:05:14 <MarcelineVQ> in this case it'll be a vague parse error
10:05:45 <cocreature> laudiacay: oh you simply forgot the equality sign after "otherwise"
10:06:44 <cocreature> laudiacay: also where is usually put on a separate line but that’s a purely stylistic issue, e.g. http://lpaste.net/241451
10:07:09 <laudiacay> cocreature: oh lmao ok
10:07:11 <laudiacay> also thanks a ton
10:07:48 <laudiacay> cocreature: are you using two spaces there?
10:08:19 <cocreature> laudiacay: that’s fairly common in haskell :)
10:10:05 <laudiacay> cocreature: hmmm my teacher always says 4. Is there like an ongoing debate or is he just dumb?
10:10:26 <MarcelineVQ> just preference
10:10:28 <laudiacay> also cocreature http://termbin.com/i6mv
10:11:03 <cocreature> laudiacay: I think 2 spaces is slighlty more common but 4 is also seen pretty often so you can really choose what you prefer as long as you’re not contributing to a project that has already chosen one style
10:11:05 <JazzyEagle> hey, if anyone has some time, can someone look into what I'm doing wrong with the irc-client lib?  Trying to implement an autoreconnect, and not only is it not reconnecting, but now it seems to be taking a lot longer to connect the first time.  Source can be found at https://notabug.org/jazzyeagle/OSMBot/src/reconnect, file with the reconnect code is in src/OSMBot.hs
10:11:10 <laudiacay> I ran filter'' (==2) [1..5] with this: http://termbin.com/ibws and got the error above
10:11:20 <JazzyEagle> Thanks in advance.  :)
10:11:23 <laudiacay> cocreature: oh ok :) 4 then because I like how spaced out it looks
10:12:23 <laudiacay> I get that error on filter'' but not filter. super weird.
10:12:53 <MarcelineVQ> your foldr' hasn't been given a list to work with
10:13:08 <MarcelineVQ> it's missing it's final argument I mean
10:13:13 <laudiacay> MarcelineVQ: I thought eta-reduction worked here?
10:13:15 <laudiacay> or...
10:13:34 <MarcelineVQ> not with (x:xs) there :>
10:13:37 <laudiacay> oshit
10:13:38 <laudiacay> duh
10:14:03 <laudiacay> MarcelineVQ: lol i forgot that I had added that earlier
10:16:16 <laudiacay> and now for a stupid question! when I run vim on an .hs file, I get the error ghcmod: ghc-mod is not executable!
10:16:30 <lpaste> MarcelineVQ pasted “laudiacay” at http://lpaste.net/241477
10:16:43 <laudiacay> I used the stephendiehl vim stuff from earlier
10:17:33 <laudiacay> MarcelineVQ: i like it :P
10:21:02 <MarcelineVQ> I don't use vim so I can't be specific but it's likely you don't have the ghc-mod executable on your path
10:21:41 <MarcelineVQ> If you build it, depending how you built it, it's possibly in your ~/.cabal/bin folder
10:23:17 * hackagebot gll 0.4.0.2 - GLL parser with simple combinator interface  https://hackage.haskell.org/package/gll-0.4.0.2 (ltvanbinsbergen)
10:23:19 * hackagebot language-c-quote 0.11.7 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.7 (GeoffreyMainland)
10:25:00 <MarcelineVQ> ah I see, that page uses stack, in that case it'l be in your ~/.local/bin directory which you'll need to add to your path
10:46:45 <Boomerang> Hello, I'm looking for a function with the following type: (a -> m (f b)) -> t a -> m (f (t b)), no luck on hoogle so far. It's similar to traverse but I can't figure out how to make it work.
10:48:46 <hpc> that's still traverse
10:48:48 <hpc> :t traverse
10:48:49 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
10:48:58 <hpc> for the special case of f = m :.: f
10:49:04 <c_wraith> yeah, that's traverse. you'll just need to compose m and f
10:49:10 <hpc> Applicatives always compose
10:49:24 <c_wraith> see Data.Functor.Compose
10:49:24 <Boomerang> How do I compose them?
10:49:32 <hpc> search for (:.:)
10:49:42 <Boomerang> Alright I'll check it out, thanks
10:50:18 <hpc> or if your base is new enough, i suppose Compose
10:50:37 <hpc> i forget how base versions correspond to ghc versions
10:53:50 <JonReed> Hi, is there an easy way to fine tune folds. Like folding two elements at a time like {a1, a2, b}, {a3, a4, b} or two elements with a previous element {a1, a2, b}, {a2,a3, b}]? 
10:54:19 <EvanR> yeah, you can zip a list with itself before folding
10:54:47 <EvanR> > let a = ['a'..] in zip a (tail a)
10:54:49 <lambdabot>  [('a','b'),('b','c'),('c','d'),('d','e'),('e','f'),('f','g'),('g','h'),('h',...
10:55:40 <JonReed> EvanR: That's perfect. Thx!
10:55:43 <EvanR> Data.List.Split has a chunksOf so you can chunk the list into twos 
10:57:01 <hpc> @quote aztec
10:57:01 <lambdabot> alpounet says: map succ/pred is a scandinavian name generator or what? ... well, scandinavian and aztec
10:57:05 <hpc> @quote aztec
10:57:05 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
10:57:14 <hpc> > zip`ap`tail $ [1..5]
10:57:16 <lambdabot>  [(1,2),(2,3),(3,4),(4,5)]
10:57:18 <hpc> :D
10:59:11 <EvanR> that one had slipped my mind, thx
11:02:00 <vapid> hi dan64
11:47:11 <koz_> Anyone who's responsible for MonadRandom - is there any way we could have RandT have a PrimMonad instance?
11:47:25 <koz_> It would make what I'm trying to do right now about 1e10% easier.
11:48:43 <lyxia> koz_: it's got a github repo
11:49:54 <koz_> lyxia: Oh, derp. I'll make an issue.
11:49:57 <hpc> or write it yourself
11:50:02 <hpc> the general pattern of those instances is:
11:50:06 <hpc> instance PrimMonad m => PrimMonad (IdentityT m) where type PrimState (IdentityT m) = PrimState m primitive = lift . primitive {-# INLINE primitive #-}
11:50:13 <hpc> well, with newlines
11:50:20 <koz_> hpc: I'll just send a PR then.
11:50:51 <hpc> actually it looks like all of them are like that lol
11:51:12 <lyxia> well it's not necessarily a good idea actually, introducing a dependency just for an instance
11:51:52 <lyxia> where is PrimMonad defined?
11:51:55 <koz_> primitive is hardly a huge dependency.
11:51:57 <koz_> lyxia: primitive.
11:52:20 <hpc> primitive depends on ghc-prim
11:52:34 <glguy> you can add the instance to your newtyped RandT locally
11:52:35 <johannes__> How can I produce the function f x = \x -> (.) . (.) . (.) $ x and even more iterations of (.) . without typing it by hand?
11:52:39 <johannes__> only with TH?
11:52:51 <johannes__> sorry: f x = (.) . (.) . (.) $ x
11:52:53 <hpc> i wouldn't depend on primitive for anything not ghc-specific
11:55:31 <koz_> glguy: I guess I could, but it seems to be an oversight the MonadRandom authors might wanna correct, since it makes using RandT with mutable vectors a real PITA.
11:55:41 <koz_> Oh well, I'll look into it later.
11:55:47 <koz_> It's a performance, not a semantic, concern.
11:57:25 <Cale> Heh, it's funny hearing a comment like that about something that I wrote as an example of how to specialise StateT and threw onto the Haskell wiki :)
11:58:44 <hpc> and to think if you had published a package instead, this bug would be all your fault
11:58:55 <hpc> clearly the wiki is the correct way to share code
11:58:56 <hpc> ;)
12:01:54 <lyxia> johannes__: I canùt see a shortcut for that.
12:01:59 <lyxia> can't
12:04:44 <koz_> Cale: Well, I tried using StateT for random state, and was told by several people that I was Doing It Wrong (tm) and should use RandT instead.
12:15:56 <dmwit> :t \x -> (.) $ x
12:15:58 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:16:01 <dmwit> :t \x -> (.) . (.) $ x
12:16:02 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:17:29 <dmwit> johannes__: You could probably make a typeclass with an associated type that did that.
12:18:15 <dmwit> johannes__: class DeepCompose (n :: Nat) where type DeepComposition n; deepCompose :: proxy n -> DeepComposition n -- or something
12:18:59 <johannes__> ok interesting
12:34:00 <AleXoundOS> Hi. Is it possible to create a shared library using Stack with it's dependencies linked statically?
12:44:46 <chenyu> :info (</>)
12:45:19 <grantwu> :i (</>)
12:50:19 <chenyu> how could i do hoogle search with stack?
12:50:43 <grantwu> chenyu: stack install hoogle?
12:51:53 <chenyu> grantwu: installing, and how to do the search? I didn't find any info in stack docs
12:52:01 <grantwu> It gives you a binary
12:52:59 <grantwu> You shouldn't be looking in stack docs for hoogle stuff
12:53:33 <grantwu> Hoogle is just a haskell package that stack happens to support installing
12:54:48 <chenyu> grantwu: well, at first, I just want to hoogle in my emacs instead of switching to browser, after a research I found that stack can do it. So I think maybe that helps
12:55:07 <bollu> hey guys
12:55:15 <bollu> I'm trying to compile this: https://hackage.haskell.org/package/quipper
12:55:22 <grantwu> I'm not aware of any benefits stack has for emacs integration
12:55:22 <bollu> it seems to rely on an old version of base
12:55:32 <bollu> so, like, waht's the process to try and bring it up to dte?
12:55:55 <grantwu> chenyu: Perhaps you were looking at intero?
12:56:06 <grantwu> chenyu: Intero is a tool which interacts with stack
12:56:55 <chenyu> grantwu: interesting, taking a look
12:56:59 <chenyu> grantwu: thx
12:57:41 <pigeont> hallo
12:57:46 <pigeont> hi
12:57:58 <pigeont> I have a question ,what mean => in haskell?
12:58:17 <pigeont> need help. thx....
12:58:28 <bollu> pigeont: in which context? in general I suppose it means something along the lines of <assuming stuff here> => <I can derive stuff here>
12:58:31 <grantwu> pigeont: Do you have an instance of where it's being used
12:59:24 <pigeont> Yes. I am very new and the normal context e.g.
13:00:53 <pigeont> Foo :: (Integer a) => a -> a
13:01:00 <Clint> class constraint
13:01:05 <cheater> i think you mean "Integral"
13:01:17 <cheater> and foo would be lower-case not capitalize
13:01:18 <cheater> d
13:01:25 <pigeont> A, okay, 
13:01:36 <pigeont> a .okay 
13:01:38 <Clint> :t fromIntegral
13:01:39 <lambdabot> (Num b, Integral a) => a -> b
13:01:51 <cheater> pigeont: so basically if you see something like       foo :: (SomeProperty a) => a -> a
13:01:54 <pigeont> very thx. So that is called class constraint?
13:02:08 <cheater> then it tells you that a implements the property called SomeProperty
13:02:21 <cheater> for example, in your case, foo :: (Integral a) => a -> a
13:02:37 <cheater> this means that foo takes a single argument of a certain type, and returns that same type
13:02:52 <cheater> and what's on the left of => tells you about the shape of that type
13:03:04 <cheater> in this case, it tells you that it's something similar to an int
13:03:31 <pigeont> Aha, awesome
13:03:36 <cheater> "Integral" is the class. what's on the left of => is the constraints.
13:03:37 <pigeont> so say if I have
13:05:14 <pigeont> foo :: (Baz v) => v -> v, means v is of type Baz, duck typing ?
13:06:29 <grantwu> It is how Haskell does ad-hoc polymorphism yes, which duck typing also lets you do
13:06:41 <grantwu> But in a disciplined way, preventing type errors
13:07:43 <pigeont> Okay. I have heard some thing more that confused me....
13:07:59 <pigeont> haskell is left most outer most evalution
13:08:10 <pigeont> so called lazy evaluation
13:08:22 <grantwu> what do you mean by left most outer most evaluation?
13:08:24 <pigeont> But if I have Squar x = x * x
13:08:46 <pigeont> Haskell will just do once, but not twice, 
13:08:51 <pigeont> I give you a link
13:08:55 <pigeont> second...
13:10:31 <NickSeagull> Hi there! :)
13:11:25 <pigeont> https://videoag.fsmpi.rwth-aachen.de/pub/12ss-funkprog/12ss-funkprog-120416-1080p.mp4
13:11:30 <pigeont> 05:01
13:11:32 <pigeont> this time
13:11:35 <pigeont> actually
13:11:54 <pigeont> the eager evalation is better than left most outer most
13:12:25 <pigeont> but the thether said that haskell will just do once,  it will just calculate once x
13:12:36 <pigeont> that is called lazy evaluation
13:12:54 <pigeont> so I think haskell will internaly cache that x, right?
13:13:33 <grantwu> I understand that presentation as saying that eager evaluation is where you evaluate the innermost expressions first, and then from left to right
13:13:37 <grantwu> I think that is essentially correct
13:14:06 <grantwu> Haskell doesn't specify a left to right order, and evaluates things from outside in
13:14:09 <pigeont> Ah, okay
13:14:35 <pigeont> your second sentence confused me?@grantwu
13:14:54 <grantwu> which sentence? " I think that is essentially correct" ?
13:15:13 <pigeont> haskell does't do that? outer most left most, but lazy evaluation, 
13:15:20 <pigeont> this "askell doesn't specify a left to right order, and evaluates things from outside in"
13:15:37 <pigeont> so LAZY EVAL != LEFT MOST OUTER MOST
13:15:43 <grantwu> Correct
13:15:48 <grantwu> I think you misunderstood the slide
13:16:00 <pigeont> That means haskell internally cache such x?
13:16:02 <grantwu> Eager eval is left most outer most
13:16:09 <pigeont> somehow and somewhat cache that x
13:16:12 <grantwu> Yes, you could say that
13:16:22 <pigeont> egar is left most inner most
13:16:28 <pigeont> I think
13:16:31 <pigeont> not outer most
13:17:07 <grantwu> Correct that is the most common semantics for eager evaluation
13:17:22 <grantwu> Like, you could do right to left, that's just a minor detail
13:17:37 <pigeont> Okay, 
13:17:46 <pigeont> I understand it now 
13:18:29 <grantwu> pigeont: that said, even in an eager language
13:18:38 <grantwu> X might still be evaluated once
13:19:05 <grantwu> The compiler might notice that x is a pure expression
13:19:14 <grantwu> This is called common subexpression elimination
13:19:50 <grantwu> Because all safe functions are pure in Haskell, the we can essentially always safely perform this optimization
13:20:43 <pigeont> okay, common subexpression elimination, it heard cool...
13:21:09 <pigeont> So it is a common technology used in Compiler for optimization?
13:23:04 <Cale> Actually GHC does very little CSE
13:23:36 <grantwu> Hrm... Really?
13:23:56 <Tuplanolla> Finding the optimal substitutions is really difficult even in restricted cases: https://en.wikipedia.org/wiki/Addition-chain_exponentiation
13:23:58 <Cale> The one case where it will do CSE, which doesn't show up much in user-written code, but may happen as a result of other things the compiler does, is when you have nested case expressions with the exact same scrutinee, it will only evaluate the scrutinee once.
13:24:32 <Cale> Basically, CSE is a really good way to create space leak headaches in general, and so the compiler is extremely conservative.
13:24:43 <grantwu> Huh, I see
13:24:49 <Cale> As a somewhat extreme case, consider something like:
13:24:59 <Cale> combinations [] = [[]];
13:25:09 <hpc> because of laziness, if you unify two of the same expression you can accidentally carry that around for longer than expected
13:25:21 <Cale> combinations (x:xs) = map (x:) (combinations xs) ++ combinations xs
13:25:27 <hpc> because the would-be-unevaluated half of it has a larger scope
13:25:41 <hpc> er, larger lifetime
13:26:12 <Cale> As written, each combination can be computed once, and immediately becomes garbage as we consume the resulting list
13:26:52 <Cale> However, if we were to do common subexpression elimination, like  combinations (x:xs) = let cs = combinations xs in map (x:) cs ++ cs
13:27:20 <Cale> Then cs doesn't start to become garbage until we're halfway through the list of 2^n combinations
13:28:06 <Cale> So this results in consuming all your memory, and will also likely be slower due to all the allocation that needs to be done.
13:28:29 <grantwu> so in spare x = x * x
13:28:33 <grantwu> Is x going to be evaluated twice?
13:28:44 <Cale> no, because it's a single variable
13:28:51 <grantwu> oh, right
13:29:07 <Cale> Any work done to evaluate the expression bound to a variable will be shared amongst the occurrences of the variable
13:29:07 <grantwu> pigeont: So, ignore everything I said about Haskell doing CSE
13:29:25 <koz_> I figured this might be a god place to ask, even though it's not strictly about Haskell: Does anyone know of any literature on parallel topological sorting? The problem is in NC^2, so that implies that a parallel algorithm *can* exist.
13:29:43 <pigeont> okay...
13:29:55 <pigeont> What if squar( 12 - 1)
13:29:58 <Cale> *You* can do common subexpression elimination safely (up to performance concerns), but the compiler generally won't because understanding the time/space tradeoffs is hard.
13:30:28 <Cale> So, that'll become  let x = 12 - 1 in x * x
13:30:43 <divVerent> koz_: wait, you say it's worst case O((log k)^2)? For average case I see it... but what if the whole graph is a single linked list?
13:30:51 <divVerent> Well, probably depends on how you want your output to be organized.
13:31:23 <Cale> and the fact that * demands the evaluation of its first argument will mean that x is evaluated to 11, once, and will already be evaluated by the time * matches its second argument.
13:31:41 <koz_> divVerent: NC^2 means it can be computed in O(log^2 (n)) on O(n^k) processors.
13:31:58 <koz_> I might wanna read Cook's original paper on this, but I was curious if someone had constructed a *practical* algorithm.
13:32:13 <divVerent> koz_: that part I understand
13:32:28 <divVerent> but yes, just reading up on it
13:32:37 <divVerent> it's "cheating" by using a nonstandard output format
13:32:58 <koz_> divVerent: Let's assume for now that output format is not important.
13:33:16 <koz_> (this is an exploration of a weird idea, and I just wanna see if this roadblock can be cleared before I go further)
13:33:29 <divVerent> my point was, for the formats I could think of, I just can't get below O(n) :)
13:33:54 <divVerent> but yes, if you ignore that and e.g. rather define "node N contains output's Nth element", then yes, O((log n)^2) will totally work
13:36:53 <koz_> divVerent: I'll see if anyone cites Cook's original paper. Maybe that's where the algorithm lives.
13:40:17 <divVerent> well, the 2-line description on Wikipedia is already a sufficient algorithm description for me :)
13:40:47 <koz_> divVerent: Oh derp. I need to coffee before I read. :P
13:41:00 <divVerent> essentially: you solve the longest path problem first (log(n) matrix multiplications, each tking log(n) parallel steps)
13:41:15 <divVerent> and then find some sorting algorithm to sort by the output of the first operation
13:41:36 <divVerent> I ddidn't read how these work, but parallel sorting algorithms in O(log n) exist
13:41:37 <koz_> Hmm. Thanks divVerent - that's given me somethign to think about and work through.
13:41:51 <grantwu> I think merge sort might be logn span?
13:42:16 <divVerent> which is funny, as that means that when parallelized, toposort is MORE expensive than sort
13:42:18 <pppiiiggg> like red black sorting
13:42:26 <pppiiiggg> I mean red black tree
13:42:34 <divVerent> while in serial computations, toposort is O(n) and sort is O(n log n)
13:42:47 <divVerent> where n = length of input, i.e. V+E
13:43:50 <koz_> divVerent: I'll think on my idea some more and see whether this actually works at all. Then, implementation and firing it through an 8-core machine.
13:44:11 <Gurkenglas> :t ($>) -- even after https://github.com/lambdabot/lambdabot/commit/1d1ed3e7980081c9f356f8d2fd8ca2771c0ed4f4
13:44:12 <lambdabot> error:
13:44:12 <lambdabot>     • Variable not in scope: $>
13:44:12 <lambdabot>     • Perhaps you meant one of these:
13:44:23 <divVerent> I doubt it'll perform any good on just 8 cores :)
13:45:04 <koz_> divVerent: I don't have a mightier testing rig available.
13:45:06 <divVerent> try trolltoposort: each vertex spawns a thread that waits for its incoming vertices to output their value :)
13:45:32 <divVerent> but clearly O(n) if the graph degenerates to a list
13:46:51 <divVerent> koz_: my point is, the matrix multiply approach uses too much total complexity to be worthwile
13:47:06 <divVerent> you can still try implementing it - but it barely has practical applications, is what I'm saying
13:47:11 <divVerent> interesting to do it is
13:47:51 <koz_> divVerent: Yeah, it certainly does complicate things.
13:48:11 <koz_> But I'll work on the idea some. I might actually *have* an application, bizarrely-enough.
13:48:14 <koz_> *If* this works.
13:48:23 <koz_> I don't wanna discuss it more until I've properly thought about it, though.
13:48:28 <koz_> This is like, a crazy 3am idea. :P
13:48:47 <divVerent> at the very least, you're going to do log(E) multiplications of ExE matrices
13:48:51 <lpaste> Vandelay pasted “grammar parsing... help!” at http://lpaste.net/4296927982930362368
13:49:47 <Vandelay> obvious noob is obvious
13:50:05 <divVerent> that alone has serial complexity (and thus "power consumption" complexity) of O(n^2.3 log n)
13:50:40 <divVerent> koz_: so here's my point - if you really need lowest possible latency at any cost in megawatts and machines, and have big graphs
13:50:43 <divVerent> then this is gonna help you
13:51:13 <koz_> divVerent: Thanks - you've given me a lot to think about!
13:51:52 <Gurkenglas> Vandelay, is your program not compiling or does it have incorrect behavior?
13:52:08 <divVerent> like, I could imagine a MMORPG to possibly have use for such an algorithm and implementation
13:52:12 <Vandelay> @Gurkenglas it has incorrect behaviour
13:52:13 <lambdabot> Unknown command, try @list
13:52:31 <lambdabot>  @ is for commands
13:52:38 <divVerent> and of course, once you get it to work, practical tuning is going to be fun as well :)
13:52:56 <Vandelay> for 1 + 2; I should have [(MathCall "+" [IntValue 1,IntValue 2]),""]
13:53:18 <Gurkenglas> Vandelay, what do you have instead? What is parseMain?
13:53:29 <divVerent> given parallel "normal" sorting is a well treated problem, I doubt you'll get something much better than e.g. was shown in Terasort
13:53:51 <Vandelay> [(MathCall "+" [IntValue 2,IntValue 2]),""]
13:53:52 <divVerent> for the toposort part - read up on parallel matrix multiplication, not sure how well treated that is nowadays regarding practical performance
13:54:10 <divVerent> given PageRank depends on that, that may get you some papers with practical info about this
13:54:24 <Vandelay> Gurkenglas: its where i call ReadP_to_S and do error handling
13:55:52 <koz_> divVerent: Isn't matrix multiplication embarassingly parallel, though?
13:56:33 <glguy> Vandelay: You're not using the `expr' parameter in parseExpr69Opt
13:56:37 <divVerent> yes, the hard part is that naively it needs all-to-all distribution
13:56:52 <koz_> divVerent: Yeah, that's true.
13:56:55 <Gurkenglas> glguy, he is in line 13
13:56:56 <bollu> which backend for diagrams can generate gifs?
13:56:57 <divVerent> theoretically it's indeed easy
13:57:05 <divVerent> practical tuning to make it actually fast is the hard part
13:57:05 <glguy> Gurkenglas: No, that's not relevant
13:57:17 <glguy> It's the other branch
13:57:27 <koz_> divVerent: Yeah.
13:57:28 <Gurkenglas> Vandelay, are you sure parseMain calls readP_to_S? Line 28 calls both readP_to_S and parseMain
13:58:03 <glguy> Vandelay: You seem to have twisted parseExpr69Opt to inline parseExpr69 instead of deferring to it, which is complicating your logic here
13:59:08 <roconnor> Do people have a favourite/recommended libary for Unificaiton or Constraint Solving?
13:59:16 <glguy> Vandelay: If instead you had parseExpr69Opt :: ReadP (Maybe Expr) you could put the MathCall "+" logic into parseExpr69
14:01:08 <lpaste> glguy annotated “grammar parsing... help!” with “something like this (annotation)” at http://lpaste.net/4296927982930362368#a241804
14:01:09 <byorgey> bollu: the Rasterific and cairo backends can both generate gifs
14:01:13 <Vandelay> hmm
14:01:34 <byorgey> bollu: also, feel free to join #diagrams
14:02:54 <Vandelay> @Gurkenglas parseMain handles some other stuff which are currently working as expected, the issue is with parseExpr69 or parseExpr69Opt 
14:02:54 <lambdabot> Unknown command, try @list
14:03:05 <glguy> Vandelay: That last paste was for you
14:03:12 <bollu> byorgey: are either of them fast?
14:03:20 <bollu> byorgey: I'd ideally like to generate mp4 or something
14:03:21 <Vandelay> let me look, thanks!
14:03:27 <bollu> byorgey: right now, I'm using cairo and it's slooow
14:03:33 <bollu> byorgey: for this: https://github.com/bollu/cellularAutomata
14:03:35 <glguy> Vandelay: it uninlines parseExpr69 from parseExpr69Opt and along the way doesn't forget to use the initial expression from expr69
14:03:52 <glguy> roconnor: I don't have a favorite; I've seen https://hackage.haskell.org/package/unification-fd used
14:03:55 <bollu> byorgey: also, has anyone written a webgl backend using reflex-dom?
14:04:07 <bollu> byorgey: I know I should join #diagrams, but ..college :)
14:04:24 <byorgey> bollu: I don't know how the speed of the Rasterific backend compares to cairo
14:04:40 <byorgey> bollu: I don't understand, what does college have to do with anything?
14:04:51 <bollu> byorgey: time on hobbies is limited :P
14:05:17 <bollu> byorgey: can I generate an MP4 or something? I primarily want some video format that is fast and doesn't take ages to render
14:05:29 <ph88> i don't understand this error, any pointers ?  https://paste.fedoraproject.org/443629/61509014/
14:05:30 <Vandelay> glguy: thanks, ill try it out
14:05:32 <byorgey> bollu: oh, it's not like we all sit around chatting in #diagrams all the time... usually it's pretty quiet.  I just meant it is a good place to ask questions where they are more likely to be seen.
14:05:51 <bollu> ah, I see
14:05:52 <bollu> cool then
14:05:58 <byorgey> bollu: there's currently no way to directly render to mp4
14:06:15 <bollu> byorgey: damn. Okay, assuming I wanted to write said module
14:06:19 <bollu> byorgey: how'd I go about it?
14:06:30 <byorgey> bollu: I don't know of any webgl backends using reflex-dom, that sounds cool
14:06:51 <byorgey> bollu: let's continue in #diagrams
14:06:55 <bollu> byorgey: sure
14:10:56 <roconnor> glguy: thanks. Looking into it.
14:13:46 <bollu>    weird build bug (through stack): Could not find module ‘Data.Vector.Strategies’ There are files missing in the ‘vector-strategies-0.4@vecto_CXFpmzMRl3CEXjIZDHLF8l’ package,
14:20:23 <lpaste> Tuplanolla pasted “Pragma Panic” at http://lpaste.net/241827
14:20:41 <Tuplanolla> Can someone try whether this happens with GHC 8?
14:21:51 <glguy> Tuplanolla: compiles on OS X + GHC 8.0.1 at -O2 without panics
14:21:58 <glguy> and then produces a <<loop>> at runtime
14:22:08 <Tuplanolla> You're not supposed to compile it, glguy.
14:22:35 <glguy> ok, well it also loads in GHCi
14:22:50 <glguy> when making flags consistent: warning:    -O conflicts with --interactive; -O ignored
14:22:52 <bollu> how do I nuke stack and start afresh?
14:23:04 <bollu> I'm getting an error that it's not able to find Data.Vector.Strategies
14:23:16 <Tuplanolla> Thanks. Time to go hunt for it in the bug tracker then.
14:23:22 * hackagebot hats 0.1.0.1 - Haskell client for the NATS messaging system  https://hackage.haskell.org/package/hats-0.1.0.1 (PatrikSandahl)
14:23:24 * hackagebot glpk-hs 0.5 - Comprehensive GLPK linear programming bindings  https://hackage.haskell.org/package/glpk-hs-0.5 (JeanPhilippeBernardy)
14:23:26 * hackagebot opml-conduit 0.6.0.1 - Streaming parser/renderer for the OPML 2.0 format.  https://hackage.haskell.org/package/opml-conduit-0.6.0.1 (koral)
14:23:42 <bollu> ghci is able to find it
14:23:44 <bollu> "stack ghci" is not
14:24:36 <bollu> also, how do I wrap this type using the FFI? https://github.com/symengine/symengine/blob/master/symengine/cwrapper.h#L345
14:25:20 <Tuplanolla> It seems to have been fixed, here: https://ghc.haskell.org/trac/ghc/ticket/10549
14:29:33 <Socah> https://www.youtube.com/watch?v=mlHs1uJDdEY
14:30:12 <glguy> bollu: foreign import ccall vecbasic_new :: IO (Ptr CVecBasic) -- assuming you have a CVecBasic type, which might be an empty data type if you don't plan on marshaling it in
14:30:37 <bollu> glguy: oh, cool, I can make it empty
14:30:50 <bollu> glguy: I was a tad worried that maybe keeping it empty would fuck with alignment or something
14:31:14 <glguy> bollu: Alignment only matters if you're allocating new ones, not pointing to existing ones
14:31:28 <Darwin226> Hey guys. Is there a law broken by defining (Just _) `mappend` (Just _) = Nothing?
14:31:44 <bollu> glguy: right, makes sense
14:35:09 <Aruro> Darwin226: negative Just?
14:35:35 <Darwin226> Aruro: What do you mean?
14:35:52 <glguy> Darwin226: mappend needs to be associative
14:36:13 <Darwin226> glguy: Sure, but I don't see how this makes it not associative
14:36:40 <Aruro> Darwin226: -a+a = 0
14:37:01 <Habib> does anyone know a way I can pass two monadic arguments to a function using do notation, no brackets surrounding each do expression, and no where or let bindings?
14:37:07 <Darwin226> Aruro: I'm still not sure what you mean. Monoid doesn't need an inverse
14:37:54 <Habib> So far I've got
14:37:55 <Habib> ```
14:37:56 <Habib> index = layout
14:37:58 <Habib>     $ do
14:37:59 <Habib>         H.meta ! A.name "encoding" ! A.content "UTF-8"
14:38:01 <Habib>     $ do
14:38:02 <Habib>         H.h1 "Title"
14:38:03 <Habib>         H.h2 "Subtitle"
14:38:04 <Habib> ```
14:38:09 <glguy> Darwin226: (Just 1 <> Just 2) <> Just 3 would be Just 3
14:38:15 <Aruro> Darwin226: nevermind :) there are no checked laws in haskell, so u should not worry
14:38:17 <glguy> Darwin226: Just 1 <> (Just 2 <> Just 3) would be Just 1
14:38:36 <ph88> i don't understand this error, any advice ?  https://paste.fedoraproject.org/443629/61509014/
14:38:40 <bollu> glguy: oh, why does Just have an absorbing semigroup semantics on it?
14:38:53 <Darwin226> glguy: Hah, didn't even think to try with all three being a Just. Thanks
14:39:42 <glguy> bollu: Darwin226 proposed an alternate structure
14:40:30 <bollu> glguy: oh, okay. this is not in prelude, right..?
14:40:34 <Aruro> Darwin226: u want to define Just _ + Just _ = 0 for all Just or just special ones?
14:40:45 <glguy> bollu: What isn't?
14:41:12 <glguy> The thing Darwin226 made up just now?
14:41:56 <Darwin226> Aruro: I just didn't see why my definition broke the Monoid laws. glguy gave an example
14:42:20 <bollu> glguy: yes
14:42:31 <glguy> bollu: No, that hasn't made it into base yet
14:43:18 <bollu> glguy: cool
14:44:20 <bollu> also quick question
14:44:27 <bollu> how do I "learn" liquidHaskell
14:47:14 <lyxia> ph88: what are the types of anyChar and manyTo
14:48:05 <ph88> anyChar :: (M.Token s ~ Char, MonadParsec e s m) => m Char
14:48:11 <ph88> manyTo :: Alternative f => f a -> f [a] -> f [a]
14:50:09 <ph88> lyxia, ^
14:51:53 <lyxia> ph88: do you have overloadedStrings on?
14:51:58 <ph88> yes
14:52:52 <lyxia> then the compiler cannot deduce the type of stream you want to use
14:53:07 <lyxia> which is that s0 variable
14:53:48 <lyxia> annotate the input string with a type
14:53:59 <lyxia> String for example
14:55:39 <ph88> lyxia, i try annotating it like this:  https://paste.fedoraproject.org/443656/75618104/
14:57:27 <lyxia> ph88: now it's the error type that's ambiguous
14:57:39 <lyxia> give a type signature to test
14:58:08 <ph88> not sure where i should place that
14:58:24 <lyxia> test :: blahblah
14:58:33 <lyxia> just above its definition
14:59:05 <ph88> ok i try this:  test :: Either (M.ParseError M.Dec Char) [Char]
14:59:18 <ph88> same error still ^^
14:59:27 <lyxia> you flipped the arguments of ParseError
14:59:39 <ph88> ups sorry not same error, forgot to save file before reloead ^^
15:00:02 <ph88> it works now o_O
15:00:26 <lyxia> good
15:01:02 <ph88> my manyTo function works :P
15:01:05 <ph88> thanks lyxia 
15:01:09 <lyxia> yw
15:23:23 * hackagebot threads-extras 0.1.0.2 - Extends the threads package with a bounded thread group  https://hackage.haskell.org/package/threads-extras-0.1.0.2 (JonathanFischoff)
16:23:24 * hackagebot geoip2 0.2.1.1 - Pure haskell interface to MaxMind GeoIP database  https://hackage.haskell.org/package/geoip2-0.2.1.1 (ondrap)
16:23:26 * hackagebot HsOpenSSL 0.11.2.2 - Partial OpenSSL binding for Haskell  https://hackage.haskell.org/package/HsOpenSSL-0.11.2.2 (VladimirShabanov)
17:06:36 <jle`> i wonder if i can get type families like type Plus1 n = n + 1 to be considered injective by GHC
17:06:43 <jle`> . o O ( hmm ... )
17:06:44 <Joss> How many parameters have this type declaration ..... function :: (Integral a) => a
17:07:11 <jle`> Joss: it's a value with one type parameter
17:07:34 <jle`> *it's the type of a value
17:07:57 <Joss> what do u mena?
17:08:01 <Joss> *mean?
17:08:04 <glguy> and it's not a function, so it doesn't have any function parameters
17:08:24 <glguy> jle` is saying it has one type variable, `a'
17:08:35 <glguy> and it's not a function, so it has no function parameters
17:08:48 <jle`> yeah, the value itself isn't a function, so it doesn't have any arguments
17:08:50 <Joss> of course...but any argument
17:08:52 <Joss> right?
17:08:54 <jle`> kind of like x = "hello"
17:08:58 <jle`> x is not a function, it's a value
17:09:02 <jle`> and has no arguments/parameters :)
17:09:04 <Joss> thanks
17:10:02 <jle`> no problem!
17:10:24 <Joss> flip function is higher order function right? now, its definition says that flip flipped the firsts two arguments of a function
17:10:46 <verement> @src flip
17:10:46 <lambdabot> flip f x y = f y x
17:11:09 <Joss> in fact, its type's a -> b -> c) -> b -> a -> c
17:11:19 <Joss> 8a -> b -> c) -> b -> a -> c
17:11:23 <Joss> (a -> b -> c) -> b -> a -> c
17:12:26 <Joss> If I use flip with a function that need 4 parameters will I have the correct answer?
17:13:03 <Joss> I understand that flip just take a function and this function have two parameters no more....is that right?
17:13:22 <Koterpillar> you'll flip the first two parameters of that function
17:13:28 <verement> :t flip (,,,)
17:13:29 <lambdabot> b -> a -> c -> d -> (a, b, c, d)
17:13:42 <Koterpillar> @let add4 a b c d = a + b + c + d
17:13:44 <lambdabot>  Defined.
17:13:49 <Koterpillar> :t flip add4
17:13:50 <lambdabot> Num a => a -> a -> a -> a -> a
17:45:12 <rui> for an expert, what's more readable?
17:45:24 <rui> f x = fun2 . fun1 x
17:45:28 <rui> or the pointfree
17:45:40 <rui> f = (fun2 .). fun1
17:48:15 <geekosaur> even experts will avoid the latter, in my experience
17:48:28 <rui> Great
17:49:05 <ReinH> The second one is awful. The first one is fine.
17:49:49 <rui> Wonderful
18:27:29 <Philippa> evenin' - I'm out of practice at doing stuff with type classes and want to do something very mildly "dirty", anyone up to lending me a hand?
18:27:58 <Philippa> I've got an applicative and a small number of resources that I've got with-style binding functions for in it. I've got access to the inside of the applicative's implementation
18:28:40 <Philippa> I'd like to write a function that does the with calls for a series of resources for a function with a type of the form resource -> resource -> ... -> SpecificApplicative whatever
18:29:12 <Philippa> which obviously needs a type class because it's type-directed term generation, but yeah
18:29:31 <Philippa> can't remember the ins and outs of the current mechanisms. Actually, still more used to fundeps if I'm honest
18:32:43 <Philippa> the basic structure's inductive with no overlap between the base case and the function one at least, should I be able to get it to Just Work if I do the obvious?
18:36:34 <geekosaur> channell
18:36:35 <geekosaur> er
18:36:38 <geekosaur> channe;
18:36:41 <geekosaur> sigh
18:36:50 * boj pats geekosaur on the head
18:36:52 <geekosaur> channel's been surprisingly dead the past hour or so
18:36:59 * geekosaur is ... not having a good day
18:37:37 <grantwu> :/
18:40:46 <shapr> oh hai geekosaur 
18:40:58 <shapr> LET'S HEAR IT FOR HASKELL, w00t!
18:41:41 <shapr> but srsly, hodapp's recent Haskell Embedded blog post got me interested all over again: http://haskellembedded.github.io/posts/2016-09-23-introducing-ion.html
18:41:44 <lgstate> w00t when ghcjs is easy to install from sourced
18:41:58 <shapr> and I bought an Arduboy and I want to create games for it in Haskell
18:42:54 <Hermit> rui: even if at some point you develop a keen sense to read point free style, it's not worth it... really. It's hard to mantain and adds a mental overhead that would be better used in solving actual problems than basking in obscurity
18:43:31 <shapr> I enjoy doing point-free sometimes
18:44:13 <Hermit> so do I, but after 2 years, I've read some complex point free I crafted myself, and it took me a while to figure out wtf was going on
18:44:13 <Philippa> I find point-free is useful if I'd be spending most of my token count on the function parameters otherwise
18:44:31 <Philippa> not because it's inherently simpler, but because if the pattern is unusual you see that much real fast
18:44:37 <Hermit> (code 2 years old)
18:45:43 <Philippa> yeah, so the lesson there is "don't write complex point-free stuff without decomposing it into something that makes sense"
18:46:18 <Philippa> but it's much, much better at highlighting if two parameters out of eight got swapped in a call than pointed style
18:46:25 <grantwu> I personally like to write functions with all their parameters listed explicitly, but with intermediates elided sometimes
18:46:46 <hodapp> shapr :)
18:47:25 <hodapp> one of these days, maybe YOU will get to write a post on that blog!
18:47:57 <c_wraith> Philippa: hey!  You gonna be hanging out here again these days?
18:49:26 <Philippa> c_wraith: tbh, mostly just here for the one tip. Still playing fighters?
18:50:20 <c_wraith> Philippa, yeah, but I don't want to go way off topic. also, have to run. :) 
18:50:30 <Philippa> (I'm not managing to get matches online for KOF XIV and don't have the spare spoons to show up to tournaments in person alas, though they're happening in what's reasonable distance for me given crashspace - oh, and videos I've seen have some really cringy "...you don't know your character, do you?" moments)
18:50:32 <Philippa> heh, fair!
18:52:00 <lpaste> Vandelay pasted “parsing dilemma” at http://lpaste.net/3985547166117527552
18:53:04 <Vandelay> the IDent is a typo :)
18:53:09 <csauce> Does anyone know if Haddock has a doc-comment syntax for GADT style declarations? I can't seem to find it anywhere and am getting a parse error using the normal --|
18:53:35 <csauce> trying to document a data constructor I mean, not the type
18:55:12 <geekosaur> Vandelay, you don't; that is not a type. those are *data* constructors, the same way 5 or Just "a" are data constructors
18:56:10 <rui> Hermit: I see, thanks
18:56:18 <Vandelay> it's late and I probably explained it poorly. I don't want to change the data type, just want to make it return
18:56:29 <Vandelay> *constructor*
18:57:35 <Hermit> I'm trying to solve a networking problem in haskell, wonder if someone could throw me a pointer. I'm writing a telnet client, the connection is unreliable and so is the server process. At this point I'm struggling trying to detect failure as soon as possible. For the connection itself, I've been trying to mess with the low level networking stack, but I have yet to find a way to send empty packets to check
18:57:37 <Hermit> the ACK (timeout after 10 seconds or so). Regarding telnet failure... well... I'll have to manage sending AYT and filtering the output at the beginning of the processing chain (I don't like it, but I have yet to find a better way). I'd appreciate any help
18:58:08 <Hermit> rui: :¬)
18:59:27 <rui> Hermit: hard to anticipate what "mental overheads" go away with practice and which don't
18:59:36 <boj> Hermit: which part of all that is the actual problem?
18:59:38 <geekosaur> Hermit, streams (TCP) don't have null packets except at the lowest level which is not exposed to you. protocol messages (IAC sequences) are the way to go
19:00:06 <geekosaur> and you need to "filter" / act on those anyway
19:00:30 <boj> oddly i was doing roughly the same thing over the weekend, but as geekosaur pointed out you have to write your own sequences
19:00:43 <geekosaur> Vandelay, I'm not understanding ... which si probably my fault; brain is not doing its thing quite right today
19:00:57 <Hermit> geekosaur: yeah, I meant IAC AYT for telnet check, problem is: it just blurts "[yes]" in the middle of any other output that's being transmitted
19:01:38 <geekosaur> Hermit, yes, AYT is not the thing to use (it's not a ping check, it's emulation of an ancient physical terminal mechanism)
19:03:27 <Hermit> boj: I meant, it's better to focus in solving whatever you are trying to solve with your code, than trying your hand at writing code in a style that demands more effort and even makes it less readable
19:04:18 <Hermit> geekosaur: I thought of using just IAC NOP, but then the only activity the connection gets is a TCP ACK 
19:04:24 <Hermit> which I can't see
19:04:24 <boj> Hermit: sorry, i was referring to the telent thing, but i think i got it :)
19:04:38 <geekosaur> one trick might be to send a command to set something you already have set correctly (e.g. IAC DO ECHO when already in echo mode, or DONT instead of DO if you aren't)
19:05:42 <Hermit> geekosaur: rfc 854 states that no party has to reply to a setting already in place. I could unset it and then set it though
19:06:04 <Hermit> actually, parties MUST NOT reply to settings already in place
19:06:10 <Hermit> (just rewording)
19:06:23 <geekosaur> sgh, right
19:08:01 <Hermit> it doesn't feel right, but it's still cleaner than AYT
19:08:09 <Hermit> at least, easier to handle
19:08:30 <Philippa> grr, the first time I try using ApplicativeDo and it doesn't seem to be using the *> operators I cut out of place in the previous version of the code
19:09:27 <Philippa> which'd be a minor issue except there's no monad instance
19:10:35 <Philippa> admittedly it's a transformation I never asked for back in the day, but still...
19:11:13 <Philippa> (including no pure bit on the last line, because it's all fed into a <$ )
19:11:32 <Hermit> geekosaur: hmm hmp, indeed, toggling ECHO could do the trick. At some point I thought of reading vars from the server, but I haven't tried it out yet.
19:12:17 <geekosaur> actually I'd wonder if you can send something like a dummy envar setting (presuming the other end supports it)
19:12:50 <geekosaur> ....even if it doesn't you should get back IAC WONT NEW-ENVIRON
19:13:00 <Hermit> right
19:14:01 <Philippa> okay, who should I send the slightly embarrassed "uh, could ApplicativeDo handle this too?" request to?
19:14:09 <Philippa> (it'd be a lot less embarrassed if I were just about anyone else)
19:14:10 <geekosaur> your biggest problem might be that apparently windows telnet, both server and client, are prone to crash on anything they don't understand
19:14:29 <Hermit> It'd be wonderful if I could do something like  IAC SB AYT IAC NOP SE  and then have the server reply every AYT with NOP
19:14:51 <geekosaur> Philippa, I don't think there's any reason to be embarrassed. ApplicativeDo has a lot of moving parts, was remarkably difficult to put together, and edge cases are pretty much expected
19:15:23 <Philippa> geekosaur: I wrote the original (much weaker) proposal, that's the reason :-)
19:15:31 <monochrom> oh hehe
19:15:52 <geekosaur> even so. what went in was rather more complex than initially expected
19:15:56 <Philippa> yeah, definitely
19:16:09 <Philippa> and this edge case is one I didn't cover at the time
19:16:36 <Philippa> (do {f; g; h} wanting to become f <* g <* h)
19:17:02 <Philippa> (or... yeah, okay, in this situation you've got an arbitrary order to pick re which thing to return and it wants to be *> for best-effort consistency)
19:17:29 <Philippa> remind me: do we have *> = >> ?
19:17:36 <Philippa> (as at least an intended law)
19:19:05 <Philippa> I mean, I'm actually writing a typechecker and losing the *> helps shed one more layer of line noise from what's otherwise transliterated typing rules
19:32:20 <glguy> Philippa: Yes, we have *> = >> as a law for Monads
19:33:51 <Philippa> glguy: yeah, this is definitely a bug then - if you applied that to the /old/ behaviour I'd get the right thing
19:34:21 <Philippa> (that is, used the original do desugaring with *> for >>)
19:35:47 <glguy> Yeah, ApplicativeDo is known to miss a number of obvious cases; you might check ghc-HEAD to see if your issue has been resolved
19:36:26 <Philippa> more trouble than I've got the energy for right now, I'll leave it on a FIXME list on my end for now
19:36:37 <Philippa> I mean, I'm glad it's at least a thing at all?
19:37:01 <glguy> I'd rather have it not exist than its current form
19:42:31 <Philippa> anything that you're certain can't be fixed without starting from scratch, or just "I don't want people writing code with it when it may be about as stable as impredicative types were?"
19:44:01 <glguy> I'd rather that they didn't repurpose `do' for and used another keyword for it; and then waited to add it to GHC until it was finished
19:46:38 <Philippa> another keyword for strictly applicative code would be good, yeah. I get why the overlap is what eventually got pushed for though
19:47:10 <Philippa> admittedly I think I lean more to "alet" than "ado" these days, with an explicit "in" if you're sticking to the <$> <*> <*> form
19:47:29 <Philippa> (but I'd want an ado for when I just want the effects)
19:55:44 <geekosaur> well, at least impredicative types appear to be on the way out finally
19:55:49 <alercah> YAY
19:56:18 <geekosaur> (replaced by explicit foralls with visible type application --- much more verbose, but you don't have to wonder what will happen)
20:00:17 <Philippa> geekosaur: do we get to have impredicative types so long as we're explicit about them?
20:00:22 <joe9> I cannot find a pokeCString. I have a C function that calls into Haskell with the parameters: int xkb_keysym_get_name(xkb_keysym_t ks, char *buffer, size_t size) . In haskell land, I have to copy a String/Text until size characters into (char * buffer). Any suggestions on how to do it, please?
20:00:29 <Philippa> or just two orthogonal changes?
20:00:34 <geekosaur> that's the idea, yes
20:00:56 <joe9> I can only find a withCString. But, that would mean that I would need a shim in C to copy the data from the haskell temp buffer to the char * buffer
20:01:17 <geekosaur> be explicit rather than hoping that the ad hoc stuff will do what you wanted
20:01:55 <geekosaur> maybe if someone comes up with a consistent impredicative type theory, they can come back. the current mess, there's no theory at all and therefore no guarantee that it will do anything sensible
20:02:39 <dolio> There are consistent impredicative inference algorithms.
20:03:05 <dolio> They're just very different from what GHC does.
20:04:11 <Philippa> which is the case with a lot of the more fun things you could do with a type system these days - Haskell's showing its age
20:04:33 <ohsix> hi, i'm practically new to functional programming and haven't done anything with haskell yet, but the mention of inference algorithms made me think of a style/taste question, are probalistic data verboten/not very 'functional', like say a bloom filter
20:04:37 <geekosaur> joe9, I feel like that's in the area of pokeArray? (for String at least)
20:04:50 <dolio> Well, most of them don't do half of what GHC does, either.
20:05:15 <geekosaur> for Text you'd probably have to talk with the text package's maintainer
20:05:37 <grantwu> ohsix: https://hackage.haskell.org/package/bloomfilter
20:06:43 <Philippa> dolio: sure. But often when you try to synthesise them into something that's in the same ballpark as GHC you find you'd have to give up something we have related to typeclasses and/or associated types for it to work. Often something subtle
20:07:23 <dolio> Impredicativity is something you have to design the algorithm around, and GHC's algorithm is designed to not work with impredicativity. So trying to hack it in afterwards doesn't work.
20:08:16 <dolio> Not because it's old, but because that was the decision they made.
20:08:44 <Philippa> sure - when I say "showing its age", I mean partly the legacy of design decisions we really can't walk back
20:08:59 <Philippa> sometimes, we just didn't collectively understand part of the design space at the time
20:09:33 <Philippa> (cf the mess we kinda have because we didn't realise the relationship between MLish modules and type classes)
20:10:22 <dolio> The mess where ML modules preclude type classes and suck because of that? :)
20:10:23 <grantwu> Philippa: Can you expand on that last part
20:10:32 <joe9> geekosaur: ok, Thanks.
20:10:39 <grantwu> robert harper doesn't seem to think ML modules preclude type classes...
20:11:38 <geekosaur> grantwu, implementation details, I think, not theoretical restrictions
20:12:13 <geekosaur> there's some funny stuff going on in there ("emergent behavior" not considered originally) and some of it is now too entrenched to alter without causing a lot of breakage
20:12:23 <grantwu> ah
20:12:30 <grantwu> Is this stuff written down anywhere?
20:12:53 <geekosaur> there might be something on the ghc wiki. some of it is in random discussions in haskell-cafe
20:13:13 <Philippa> one of the things that's definitely a bust is that you can't do the equivalent of ML module initialisation
20:13:37 <Philippa> (or generativity by and large)
20:14:29 <Philippa> that's stuff that can be fixed in a new language that knows they're mostly the same thing at the outset, though you want to distinguish between signatures and classes still on the basis that classes specifically have the type-tuple->instance thing
20:14:58 <Philippa> (you can still have implicit module stuff, but you don't want to lose access to that uniqueness/coherence property if you can avoid it)
20:18:08 <dolio> I think almost every case of combining the two tosses that out the window as a matter of course. Which isn't surprising, since just about every other implementation of 'type classes' in other languages also does so, before they even worry about modules.
20:19:36 <Philippa> dolio: yeah. I mean, I know how to not do it, but everyone does it
20:20:12 <Philippa> now, I'm told I can't have the 1:1 thing in a sufficiently dependently-typed language anyway, but that's a different matter
20:20:30 <Philippa> (and one where I should prod the person in question for more of an explanation another time)
20:20:59 <Philippa> then again, I've managed to sell some people on quantifying over classes that share a signature being desirable
20:22:29 <dolio> I can think of reasons, but it's mostly the type of thing type classes do being at odds with uniformity axioms people assume about type theory.
20:23:29 * hackagebot riak 1.1.1.0 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-1.1.1.0 (lambda_foo)
20:23:31 * hackagebot separated 0.1.1 - A data type with elements separated by values  https://hackage.haskell.org/package/separated-0.1.1 (TonyMorris)
20:23:53 <Philippa> the thing I end up wanting them for in the long run is as a central point to access a distributed decision from
20:24:20 <Philippa> which tends to be a very different line of thinking from the angle most people are approaching from
20:33:58 <Philippa> anybody around now who's good enough with typeclasses to help me pull off the dirty hack I want, btw?
20:34:30 <Philippa> (I basically want: you know how to fill in one parameter, fill in all the parameters of this n-ary function until you hit the thing at the end that has a specific type constructor)
20:34:52 <Philippa> (not the abstract version, the concrete one where I've got the individual function and the target type constructor fixed)
20:35:21 <geekosaur> hm. isn't that a variant of the printf hack? I am pretty sure there are several varieties of those in the wild
20:36:08 <Philippa> it should be, yeah. I guess if nobody can recommend a clean one...
20:37:17 <geekosaur> intermediates (PrintfType m, ...) => m  -> Something -> m, end PrintfType m => m -> EndType -> ResultType
20:38:28 <geekosaur> shouldn't have used PrintfType there since I'm doing something different than it does
20:39:02 <Philippa> aaah. In my case, EndType and ResultType are the same
20:39:14 <geekosaur> but same idea just recognizing a specific type as the terminal. if it needs to be a distinct *data* constructor then I think you have an issue unless you can reflect it into type level
20:39:37 <geekosaur> shouldn't matter, the key is EndType being distinct from any Something
20:39:47 <geekosaur> so that you have an end case
20:40:04 <geekosaur> and that's just straightforward typeclass resolution
20:40:06 <Philippa> sure. I mean, I may be having an issue about which order I need to stack the with calls in/which exact form of composition I want instead
20:40:53 <Philippa> it's a with-pattern situation
20:41:29 <Philippa> so I should probably rearrange an example or two from the form I had without this so I can see what I should be doing, I guess
20:41:53 <Philippa> ...oh, right. Think I've figured it out
20:43:19 <Philippa> nope. But I've at least understood the problem better
20:43:35 <joe9> geekosaur: Thanks. the pokeArray is what I needed.
20:44:07 <Philippa> tl;dr: I need to look at the type structure a bit more carefully because the with actions and the end are in an applicative
20:53:36 <x1f577> Anyone care to weigh in on exceptions best practices? When the potential errors of a function go beyond Just/Nothing, I question whether to create a sum type that wraps the possible outcomes or to create a new exception that gets thrown. Any opinions?
20:54:00 <grantwu> x1f577: Have you looked into Either/Except/ExceptT?
20:54:58 <x1f577> grantwu: yes, very much so. in fact im pretty well versed with those, MonadThrow/MonadCatch, and the standard Control.Exception methods. I'm looking to essentially compare thoughts with others
20:55:17 <grantwu> oh, okay, then you know more than me :P
20:56:09 <x1f577> grantwu: i dont know about that! how do you like to handle functions that could error beyond Just/Nothing? Do you like using except/either and a new "error" type to be placed in the "Left"?
20:56:46 <grantwu> I really haven't done much with error handling
20:57:03 <grantwu> I think in my current project, which is actually my first project, we just stick strings in the Except
20:57:22 <Philippa> okay, got it typechecking
20:57:30 <grantwu> It's a compiler that doesn't need good error messages (school project) so we only need the simple thing of "terminate on first error"
20:58:34 <x1f577> grantwu: after reading this article https://www.schoolofhaskell.com/user/commercial/content/exceptions-best-practices a while back I became wary of ExceptT/Except
20:59:13 <x1f577> grantwu: fair enough. at my undergrad I had to write a Pascal compiler in haskell with pretty lax requirements.. it was interesting to say the least
21:00:10 <grantwu> It seems like this article seems to mainly not like ExceptT on top of IO
21:01:54 <x1f577> grantwu: ahh i didnt realize you were using except to model exceptions in pure functions.. in that case its beautifl
21:02:16 <x1f577> but the whole ExceptT m thing makes me feel a bit uneasy
21:02:23 <Axman6> x1f577: I've been fond of the idea of using Either ConstomErrorType a, which allows you to quite easily wrap several things which can fail, so if you use libraries A and B which define AErrors and BErrors, then you would have MyErrors = AError AError | BError BError | WibbleNotSnubbed | NotEnoughWidgets Int. I feel there should be some mechanism where you can say that MyErrors contains AErrors
21:02:29 <Axman6> and BErrors, and define say... class HasErrors a b where liftE :: Either b c -> Either a c, and have instance HasErrors MyErrors AError where liftE = either AError Right ...
21:02:43 <Axman6> but I've never used this in practice really
21:03:10 <grantwu> yeah :P the one instance of ExceptT we have is for "this code doesn't typecheck/variable use before declaration"
21:03:25 <grantwu> after that phase, everything should compile
21:04:18 * Axman6 maybe should've picked better names
21:04:47 <x1f577> Axman6: interesting, especially because of the fact that im in a similar AErrors BErrors pickle as the one you describe
21:04:55 <x1f577> Axman6: thanks for the insight
21:05:31 <Axman6> I try to avoid exceptions where possible, because there's nothing in the type system to tell you when they might be thrown
21:06:59 <Axman6> I wrote a thing ages ago which did allow you to track exceptions in the type system: https://gist.github.com/axman6/19adc08a809d919a2efb but I think that type inference might be problematic
21:07:10 <Axman6> might work better using type level sets though...
21:07:41 <grantwu> Isn't this like
21:07:48 <grantwu> What extensible variants are for
21:11:28 <x1f577> Axman6: thats pretty cool looking.. i'm not too familiar with the type-level magic yet
21:12:29 <Axman6> there's not really any magic there, it's just a type class which says in HasErrors a b, errors "thrown" in b can be turned into errors thrown in a
21:12:58 <Axman6> there's be an instance for HasErrors MyErrors BError with the obvious implemntation
22:17:33 <ttfh> morning
22:17:44 <ttfh> any Lens Lawyers here?
22:18:38 <johnw> what has Lens done this time?
22:18:45 <Axman6> probably plenty, but none will take your case without knowing the facts first
22:18:57 <ttfh> It's what I want to do to it
22:18:58 <glguy> GUILTY!
22:18:58 <Axman6> (what's your question?)
22:20:20 <ttfh> so I wrote lenses for Day (from Data.Time) where I can set the year, month and day of the month
22:20:32 <ttfh> using "fromGregorian"/"toGregorian"
22:21:06 <ttfh> this violates the first lens law (I think it's the first)
22:21:27 <ttfh> beause fromGregorian clips the arguments
22:22:00 <Axman6> maybe those should be prisms
22:22:06 <Axman6> or.. traversals. hmm
22:22:25 <ttfh> I've thought about prisms yes
22:22:48 <ttfh> can prisms be declared in a lens-library-agnostic way just like lenses?
22:23:06 <Axman6> I believe so
22:23:20 <ttfh> are there any other lens libraries that implement Prisms besides "lens"?
22:23:27 <Axman6> http://hackage.haskell.org/package/lens-4.13.2.1/docs/Control-Lens-Prism.html
22:23:34 * hackagebot clanki 1.2.7 - Command-line spaced-repetition software  https://hackage.haskell.org/package/clanki-1.2.7 (marcusbuffett)
22:23:36 * hackagebot next-ref 0.1.0.2 - A concurrency primitive for a slow consumer.  https://hackage.haskell.org/package/next-ref-0.1.0.2 (JonathanFischoff)
22:23:38 * hackagebot clock-extras 0.1.0.2 - A couple functions that probably should be in the 'clock' package  https://hackage.haskell.org/package/clock-extras-0.1.0.2 (JonathanFischoff)
22:23:40 * hackagebot pptable 0.2.0.0 - Pretty Print containers in a tabular format  https://hackage.haskell.org/package/pptable-0.2.0.0 (gdevanla)
22:23:40 <Axman6> a prism is just something that looks like forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)
22:23:56 <Axman6> hmmm, seems Choise comes from lens though...
22:24:02 <Axman6> Choice*
22:24:39 <ttfh> So one alternative would be to use a Prism
22:25:34 <glguy> No, Choice comes from "profunctors" http://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor-Choice.html
22:25:41 <Axman6> actually Choice comes from profunctor,
22:26:01 <Axman6> yeah it's annoying the docs for prims dodn't actually day that anywhere
22:26:04 <Axman6> say*
22:26:48 <ttfh> but profunctor seems a small dependency
22:27:25 <Axman6> yeah
22:27:30 <Axman6> much smaller than lens
22:27:44 <glguy> The particular issue is that fromGregorian and toGregorian don't form a proper Iso put together
22:27:52 <ttfh> but then I'm not sure there's any other library implementing Prism anyway, so the I might as well depend on "lens" directly
22:28:15 <Axman6> it'd be nice if there was a lens-core which included all the types, and the TH necessary to automatically generate optics, but without all the other machinery
22:28:16 <ttfh> then*
22:29:52 <ttfh> Axman6: then someone would want to split out the TH into lens-core-th
22:30:22 <liste> ttfh: you can have just profunctor as a dependency to define prisms in your library
22:31:23 <ttfh> I read some comment from ekmett where he explained that he wanted to keep all of "lens" in a single package because it's easier to work with
22:31:47 <glguy> If you write: _Gregorian :: Prism' (Integer, Int, Int) Day
22:31:59 <glguy> then you're not really going to be able to use this to update a day or month of a day
22:32:05 <ttfh> liste: but are there even other lens libraries that define Prism?
22:32:38 <ttfh> liste: if not there's no point *not* to depend on lens
22:32:51 <liste> ttfh: microlens
22:33:17 <liste> though I'm not sure if I'd really call it an "other" lens library
22:33:17 <glguy> microlens doesn't deal in Prisms
22:33:37 <liste> http://hackage.haskell.org/package/microlens-0.4.7.0/docs/Lens-Micro.html#g:7
22:33:41 <ttfh> glguy: it seems it does
22:33:58 <liste> it's a different kind of Prism though
22:33:59 <glguy> However, it's not possible for microlens to export prisms, because their type depends on Choice from profunctors. So, all prisms included here are traversals instead (and you can't reverse them).
22:34:03 <liste> so I guess it doens't count
22:34:05 <glguy> No, it's just not a prism
22:34:09 <glguy> It's just a confusion
22:34:45 <glguy> But anyway, prisms don't really help with the Gregorian problem
22:35:47 <ttfh> glguy: sorry, I don't understand why it wouldn't work
22:36:11 <ttfh> glguy: there would be 3 prisms, year, month and dayOfMonth
22:36:47 <ttfh> oh wait
22:37:24 <glguy> No, that doesn't sound like it would work. The only place that prisms come in would be what I pasted earlier: _Gregorian :: Prism' (Integer, Int, Int) Day
22:37:45 <glguy> but now to combine that with _1, for example, you have to use `re'
22:38:08 <glguy> And then you can get something like: re _Gregorian . _1 :: Getter Day Integer
22:38:34 <ttfh> I see
22:38:35 <glguy> but you can't use that to do something like increment the day by one
22:38:54 <ttfh> and that's what exaclty what I want to do...
22:39:36 <ttfh> So there nothing in "lens" that let me say "set this part of x to y, if possible, otherwise fail"
22:39:37 <glguy> You're better off building an Iso between fromGregorian and toGregorian and documenting that you can't modify dates to create invalid dates
22:39:45 <glguy> and then you can use _1 _2 _3 on that
22:41:56 <ttfh> or drop the lens part alltogether and just have "modifyYear"/"modifyMonth"/"modifyDay" as ordinary functions
22:42:19 <neonfuz> is there really no standard function for checking that a list is at least N elements long with complexity of O(N)?
22:42:51 <Axman6> not really
22:42:58 <neonfuz> doing length list > n has complexity of O(length list), not O(n)
22:43:15 <ttfh> neonfuz: mabe you could "take N" and compare that length with N
22:43:34 <neonfuz> you could do something like not . null . drop (n-1)
22:44:12 <neonfuz> or yeah n == length . take n
22:44:27 <neonfuz> though that would be O(n*2)
22:45:03 <Axman6> what makes you say that?
22:45:25 <Axman6> looks like a single pass to me
22:46:15 <neonfuz> actually yeah, assuming laziness yes
22:46:16 <ttfh> in a strict language it would traverse the list twice right?
22:46:22 <neonfuz> yeah
22:46:33 <neonfuz> is "strict" the opposite of lazy in this context?
22:46:51 <neonfuz> are there even any other major lazy languages?
22:46:52 <Axman6> yes
22:47:03 <neonfuz> ik haskell is probably the biggest
22:47:39 <grantwu> does list fusion really require laziness
22:47:59 <grantwu> I'm pretty sure it's analagous to loop fusion
22:49:06 <ttfh> I thought date/time stuff would be a really good fit for lenses, my code involving date and time calculations always end up very ugly
22:49:26 <Axman6> there is a library for working with time using lenses
22:49:42 <ttfh> with function names like "zoneSeriesTimeToLocalTime" all over the place
22:49:47 <Axman6> https://hackage.haskell.org/package/lens-datetime is what I've used in the past
22:50:50 <ttfh> Axman6: OH
22:51:14 <ttfh> Axman6: And indeed it says "Warning: this is not a proper lens for LocalTime and UTCTime: it only obeys the lens laws if used with valid values."
22:53:07 <ttfh> I was thinking to actually use the clipping *on purpose*
22:53:41 <ttfh> for example, want the last day of the month? set the month to 40!
22:54:06 <geekosaur> grantwu, a more accurate statement is that list fusion relies on things that can be considered pure; Haskell can use laziness to enable purity, and thereby apply list fusion in more contexts than an impure language would safely permit
22:54:06 <Koterpillar> month?
22:54:25 <ttfh> no, dayOfMonth, sorry
22:54:37 <geekosaur> (some compilers for other languages will blithely assume purity, others will require you to annotate things that are to be considered pure to enable such optimizations involving them)
22:55:30 <geekosaur> but laziness and purity are often conflated in the same way that partial application and currying are often conflated
22:55:52 <geekosaur> (or "confused" etc.)
23:07:56 <platz> I think i finally get Reflection now... was confused because it doesn't truly 'allow you declare instances at runtime' - it allows you to use value that is newtype'd to a completely general instance that must be declared normally.
23:09:32 <AIvaroMolina> alllllllvaaaaaaarooooo moooooliiiiiinaaaaaaa
23:13:19 <AIvaroMolina> alllllllvaaaaaaarooooo moooooliiiiiinaaaaaaa
23:13:28 --- mode: ChanServ set +o johnw
23:14:46 --- mode: ChanServ set +q *!*@*/ip.185.89.248.21
23:16:49 <zomg> for a moment I thought this was a wrestling ring with those announcements
23:18:06 --- mode: johnw set +b *!*@*AlvaroMolina
23:21:10 <neonfuz> geekosaur: grantwu: what do you mean by list fusions exactly
23:21:31 --- mode: johnw set +b *!*@*/ip.185.89.248.21
23:22:36 <geekosaur> list fusion is when the Haskell compiler finds that it can fuse generation and consumption of a list, such that it becomes a tight loop and no list is ever created
23:25:23 <geekosaur> the reason this is unsafe without purity is that an impure function could expose part of the list to something elsewhere, forcing the compiler to actually make it so it can be visible
23:30:29 <geekosaur> (or it does so anyway, and anything trying to look at the exposed "list" follows a wild pointer and crashes)
23:32:07 <neonfuz> thats sweet
23:32:27 <neonfuz> yeah I figured that because it can make that guarantee it must be doing that, but I didn't know it was called that
23:32:48 <neonfuz> haskell lists seem to have a lot of properties of generators of other languages
23:33:00 <neonfuz> because laziness etc
23:34:04 <neonfuz> man, I need to read up more on haskell order of operations
23:34:29 <neonfuz> sometimes its hard for me to tell if it would try to apply a function to the next word, or if the function and the word itself would be treated as arguments, etc
23:34:39 <neonfuz> gets more confusing when you throw in composition and $ and stuff
23:35:14 <neonfuz> though it is pretty intuitive, I just have a hard time with some of the more complex scenarios
23:51:19 <raek> neonfuz: I like this explanation: http://www.cs.toronto.edu/~trebla/personal/haskell/lazy.xhtml
