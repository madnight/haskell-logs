00:00:00 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
00:00:02 <lambdabot>  f (f (f z q) v) c
00:00:03 <bollu> niiice
00:00:08 * hackagebot ply-loader 0.4.2 - PLY file loader.  https://hackage.haskell.org/package/ply-loader-0.4.2 (AnthonyCowley)
00:00:13 <bollu> you can actually show Y, that is slick
00:00:14 <benzrf> bollu: y is just called `fix'
00:00:18 <benzrf> from Data.Function
00:00:28 <Vyn> @let integerDefinedNowhereElse :: Int; integerDefinedNowhereElse = 4
00:00:31 <lambdabot>  Defined.
00:00:32 <Vyn> > integerDefinedNowhereElse
00:00:37 <lambdabot>  4
00:00:41 <Vyn> Right
00:01:10 <bollu> benzrf: ah right, I couldn't remember what it was called 
00:01:46 <EEVV> gg haskell http://lpaste.net/294523
00:02:12 <sathish_haskell> Hi friends , I have a question about logging in a REST API , I would be thankful if someone can steer me in the right direction if you dont mind !
00:02:14 <benzrf> EEVV: yes, that's ambiguous
00:02:14 <bollu> EEVV: you're shadowing the Right and Left from Either
00:02:18 <EEVV> I know
00:02:24 <EEVV> haskell should take some context into account
00:02:39 <benzrf> it does
00:02:42 <EEVV> I specified "test" to be a Token, but it still looks at Either
00:02:44 <bollu> sathish_haskell: as a consumer of a rest API or a provider?
00:02:48 <EEVV> like pls haskell wut is dis context
00:02:48 <benzrf> oh
00:03:01 <benzrf> no, that's not a reasonable feature
00:03:01 <sathish_haskell> Provider 
00:03:08 <sathish_haskell> So this is my query -  I am attempting to solve a problem with logging across my REST API. Every request that I get , I try to generate a transactionId , which indicates that a request has come in and I need to respond to the request with a response that contains the transaction Id and the status of the response ( Success / Failure)
00:03:21 <glguy> MarcelineVQ: the type family paste? other?
00:03:22 <benzrf> how do you formally specify how context gets taken into account?
00:03:23 <piyush-kurur> question regarding cabal: I want to check whether the environment is a posix environment or not is there a better way than doing if os(linux) || os(freebsd) || ...
00:03:32 <benzrf> that would make the semantics of name resolution crazy
00:03:37 <MarcelineVQ> glguy: yes the families
00:03:42 <EEVV> benzrf, if it has a type, then yay, if it doesn't "Ambiguous!"
00:04:00 <ertesx> EEVV: Right is predefined
00:04:06 <benzrf> EEVV: how do you define "has a type"?
00:04:12 <ertesx> use another name for the constructors of Token
00:04:13 <EEVV> test :: Token
00:04:15 <sathish_haskell> bollu: my response is of type Either Error (Mapping a)
00:04:18 <EEVV> let the programmer define the type
00:04:28 <benzrf> EEVV: so you're talking about top-level bindings in specific?
00:04:33 <EEVV> but if the programmer hasn't, then shout "ambiguous!"
00:04:48 <sathish_haskell> where  data Mapping a = Mapping { id : String , routing : String , content : a }
00:04:53 <EEVV> benzrf, top level bindings? 
00:05:08 <benzrf> EEVV: top-level definitions, as opposed to something like "let x = 3 in x + 2"
00:06:08 <EEVV> benzrf, I guess you mean not using `let`? Then yah
00:06:37 <benzrf> so - context-based name resolution happens exactly when:
00:07:02 <ertesx> i wouldn't expect that code to work even with a type signature
00:07:23 <hvr> piyush-kurur: one pragmatic way is to build-depends on 'unix'
00:07:23 <ertesx> the problem is not related to types
00:07:36 <benzrf> a name appears on the right hand side of a top-level binding, appearing nested only under applications, and the binding has a type signature?
00:07:42 * hackagebot hw-rankselect 0.7.0.0 - Rank-select  https://hackage.haskell.org/package/hw-rankselect-0.7.0.0 (haskellworks)
00:07:42 * hackagebot ply-loader 0.4.2 - PLY file loader.  https://hackage.haskell.org/package/ply-loader-0.4.2 (AnthonyCowley)
00:08:07 <benzrf> that doesn't guarantee that the ambiguity can be resolved
00:08:15 <benzrf> suppose i say:
00:08:15 <RouxTheDay> Are there valid reasons for a type that in an instance of both Monad and Applicative, to have different behaviors for (>>) and (*>)? 
00:08:22 <benzrf> foo :: Int
00:08:24 <RouxTheDay> s/in/is
00:08:27 <benzrf> foo = func "hello"
00:08:37 <hvr> piyush-kurur: what does the information on whether you're on a posix system give you?
00:08:42 <glguy> RouxTheDay: no, they have to match
00:08:43 <benzrf> EEVV: or wait - do you just mean for data constructors?
00:08:46 <ertesx> @data Blah = False | True  dering (Eq, Ord, Show)
00:08:46 <lambdabot> Unknown command, try @list
00:08:47 <hvr> piyush-kurur: or rather, what depends on that information?
00:08:51 <ertesx> @let data Blah = False | True  dering (Eq, Ord, Show)
00:08:52 <lambdabot>  .L.hs:197:18: error:
00:08:52 <lambdabot>      Not in scope: type variable ‘dering’
00:08:52 <lambdabot>      Perhaps you meant one of these:
00:08:55 <RouxTheDay> RouxTheDay: Is there a law of some sort that says that?
00:08:58 <ertesx> @let data Blah = False | True  deriving (Eq, Ord, Show)
00:09:00 <lambdabot>  Defined.
00:09:00 <RouxTheDay> Oops, glguy*
00:09:02 <piyush-kurur> hvr: to know whether I have /dev/urandom or not
00:09:03 <ertesx> wow…  that was terrible
00:09:05 <ertesx> > True
00:09:08 <lambdabot>  error:
00:09:08 <lambdabot>      Ambiguous occurrence ‘True’
00:09:08 <lambdabot>      It could refer to either ‘Data.Bool.True’,
00:09:24 <Rarrikins> Now you've done it.
00:09:27 <EEVV> benzrf, I mean that if the type was given, then you should know whether to look at Either or not, but if it wasn't given, then look at all the ambiguities you want
00:09:28 <glguy> yeah, it's documented as such in the applicative class
00:09:31 <ertesx> @undef
00:09:32 <lambdabot> Undefined.
00:09:54 <benzrf> EEVV: i understand what you're saying - what i'm asking is, what should the general rule you're proposing be?
00:10:11 <EEVV> benzrf, take the type into account?
00:10:21 <benzrf> the *specific* general rule
00:10:26 <benzrf> not a handwavy description of what the end result is
00:10:26 <RouxTheDay> glguy: will check it out, thanks
00:10:38 <EEVV> benzrf, what do you mean by `rule`?
00:10:47 <EEVV> You want me to list you a bunch 'o productions?
00:10:47 <piyush-kurur> hvr: I can ofcourse write a script to check this out but it is actually a bit painful to have a cabal file that is not a simple build
00:11:16 <benzrf> EEVV: you're suggesting that the language should work differently from how it does - explain how it is that you think it should work, in a way that could be unambiguously translated into the language specification
00:11:43 <EEVV> benzrf, I'm sure I have already explained
00:12:04 <piyush-kurur> hvr: I do not want to depend on unix because I would want to also do something on windows (if and when it comes up)
00:12:18 <benzrf> EEVV: there are a whole lot of different things you could change which would result in what you explained
00:12:45 <benzrf> EEVV: you gave a high-level description of a specific case of what would happen after the change - you didnt specify the exact change
00:12:45 <hvr> piyush-kurur: you can 'if flag(unix); build-depends: unix ...; else; build-depends: Win32 ...
00:13:29 <hvr> piyush-kurur: and have 'unix' be an automatic flag
00:13:31 <EEVV> benzrf, I don't have the understanding of how Haskell's parser works to give you that answer.
00:13:35 <ertesx> i think name resolution could be type-driven in certain cases similar to how Disambigwhatever works
00:13:36 <hvr> piyush-kurur: that's how many packages do it
00:13:40 <benzrf> EEVV: ...what does the parser have to do with it?
00:13:53 <piyush-kurur> hvr: what is an automatic flag?
00:13:53 <benzrf> typechecking is completely unrelated to parsing
00:14:02 <EEVV> benzrf, typechecking is
00:14:06 <sathish_haskell> So I guess my question is , I have a type Either Error (Mapping a) , where data Mapping a = Mapping { id: String , routeId : String , content : String } . And I need to now wrap it with a Transaction -> data Transaction a = Transaction { tId : String , payLoad : a} there by making my response type Either (Transaction Error) (Transaction (Mapping a))
00:14:08 <EEVV> you can walk the tree and check types
00:14:10 <EEVV> easy as that
00:14:17 <hvr> piyush-kurur: a cabal flag that the solver is allowed to toggle to satisfy constraints
00:14:31 <piyush-kurur> hvr: great. That is good
00:14:47 <hvr> piyush-kurur: or you can make it static like in http://hackage.haskell.org/package/process-1.4.2.0/process.cabal
00:14:48 <benzrf> EEVV: ok, but, what i mean is - ok, here's an example of one possible precise specification of how it *could* work:
00:15:12 <hvr> piyush-kurur: i.e. use if os(windows) and assume that windows is the only non-POSIX arch ... whcih is not 100% correct
00:15:35 <ertesx> not sure if there is a lot of value in that, but it sounds possible to me…  not valuable enough that anyone has done it yet
00:16:00 <benzrf> EEVV: "whenever a variable or data constructor appears in an expression, and there is more than one top-level binding with that name - instead of immediately complaining, first try to typecheck it using each of the possibilities, one by one. if exactly one choice results in a well-typed program, then simply use that choice."
00:16:06 <ertesx> similar to OOP: you can have OOP in haskell, but it's not valuable
00:16:15 <benzrf> EEVV: but this is *not* the only change you could make that would result in what you described!
00:16:21 <piyush-kurur> hvr: I too was thing of if !os(windows) as morally equivalent to if posix. Now that others are doing it I think i am fine with it
00:16:36 <piyush-kurur> hvr: s/thing/thinking/
00:17:11 <EEVV> benzrf, why do I need to state my specific change, if there are other, similar, ones? If they have no side-effects, then surely it is suitable... :P 
00:17:20 <hvr> piyush-kurur: unfortunately we don't have a better way yet to declare that kind of dependency
00:17:21 <benzrf> EEVV: well, i'm trying to illustrate a point ;P
00:17:24 <EEVV> lol
00:17:30 <EEVV> you know I'm a noob at haskell?
00:18:00 <piyush-kurur> hvr: there is another interesting bug in raaz that came out due to Debian kFreeBSD
00:18:16 <benzrf> EEVV: any specific change you could come up with to accomplish this will almost certainly either: 1. be too narrowly-applicable to be worth adding as a special case; or 2. make everything 1000x more complicated and unpredictable
00:18:18 <hvr> piyush-kurur: but typically os(windows) is the odd-one-out case, so that covers 90% of use-caseds
00:18:36 <ertesx> i was pretty excited about -XDisambwhatever and -XDuplicatewhatever when i read the release notes of GHC, only to never use either of them ever
00:18:40 <hvr> piyush-kurur: which bug?
00:19:07 <EEVV> benzrf, well this wouldn't really be the second case :P the behaviour is define, as an error would be thrown.
00:19:08 <benzrf> for example, if you did it the way i just described - you get a combinatorial explosion if you use more than a couple of ambiguous names
00:19:10 <piyush-kurur> hvr: the bug is not in cabal but in raaz
00:19:28 <piyush-kurur> I did not file it yet but it is pretty interesting
00:19:32 <benzrf> EEVV: i don't understand what "the behaviour is define, as an error would be thrown" means, sorry
00:19:53 <MarcelineVQ> ertesx: you may find them more useful when OverloadedRecordFields is done, those are just parts of it iirc
00:19:57 <piyush-kurur> the point is that on Debian kFreebsd the os(freebsd) flag is satisfied
00:20:23 <piyush-kurur> but I have been using this to test which platform endian conversion function to use
00:20:31 <bollu> turns out GeneralisedNewtypeDeriving can do the type families derivation..? It can't do it for data declaraions though
00:20:51 <bollu> I guess I at learnt some basic TH
00:20:55 <ertesx> MarcelineVQ: i'm not sure about that…  you can't use it in a library, otherwise you will force pretty much everybody to use those extensions…  and then my executables are usually too small to ever need duplicates
00:20:57 <piyush-kurur> now Debian kFreebsd is freebsd with gnu-userland so I should be using the endian function of gnu (as in linux)
00:21:11 <piyush-kurur> as a result the package was failing in Debin kFreeBSD
00:21:12 <EEVV> benzrf, well the behaviour is defined -- there are only 3 cases: 1) it has a type 2) it has no type, but it isn't ambiguous 3) it has no type and is ambiguous
00:21:21 <ertesx> MarcelineVQ: those really only make sense as standard features…  as extensions they seem pointless to me
00:21:25 <benzrf> EEVV: what is "it" here?
00:21:57 <piyush-kurur> hvr: here is the build https://buildd.debian.org/status/package.php?p=haskell-raaz&suite=sid  
00:22:14 <MarcelineVQ> ertesx: Quite possibly, my experience is limited in that area
00:22:21 <benzrf> EEVV: in your example, `test' is given a type signature, but the thing that's ambiguous isn't `test', it's `Right'
00:22:34 <benzrf> so i don't see how any of those 3 things describe the situation
00:22:38 * hackagebot hw-excess 0.1.0.0 - Excess  https://hackage.haskell.org/package/hw-excess-0.1.0.0 (haskellworks)
00:22:40 * hackagebot hw-string-parse 0.0.0.3 - String parser  https://hackage.haskell.org/package/hw-string-parse-0.0.0.3 (haskellworks)
00:22:40 <EEVV> benzrf, but with the given context, it isn't ambiguous
00:23:01 <benzrf> yes it is - there's more than one thing named `Right'
00:23:05 <EEVV> as we are saying it is a Token, but the compiler still checks if it is Either and disregarding the type
00:23:07 <benzrf> or - what do you mean by ambiguous, then?
00:23:20 <piyush-kurur> hvr: one more thing. Is there nightly build for debian systems where unreleased packages can be built
00:23:27 <benzrf> well no, it doesn't "check if it is Either"
00:23:28 <piyush-kurur> ?
00:23:38 <EEVV> benzrf, ambiguity with context can be resolved
00:23:42 <benzrf> it checks if "Right 2" actually has type `Token'
00:23:52 <benzrf> to do so, it figures out what type `Right' has
00:23:59 <benzrf> but then it realizes that there's more than one thing called `Right'
00:24:10 <benzrf> there's no point where it "checks if it's Either"
00:24:46 <ertesx> this can only work sensibly, if name resolution happens *as part of* type checking…  not sure if GHC's architecture is like that
00:24:54 <EEVV> benzrf, what I'm saying is: it should check the type
00:24:55 <benzrf> exactly
00:24:55 <EEVV> that's it
00:25:04 <benzrf> EEVV: what do you mean by "check the type"?
00:25:16 <hvr> piyush-kurur: IMHO you should really be using 'build-type: autoconf' for your package; you're only going to run into these kind of problems if you rely on cabal's predicates
00:25:17 <bollu> how does one start to read GHC code? it's huge
00:25:23 <bollu> can I print it out? or is it too much?
00:25:23 <hvr> +keep running
00:25:30 <ertesx> example:  data Blah a = Right a
00:25:38 <EEVV> that's what "context" really means in THIS context (contextception)
00:25:54 <ertesx> Right (Right (Right (Right (Right (Right ()))))) :: Blah (Blah (Blah (Blah (Blah (Blah ())))))
00:26:09 <ertesx> if type checking and name resolution are separate, this will explode exponentially
00:26:17 <benzrf> yup, i mentioned that ertesx :P
00:26:22 <benzrf> 03:18 <benzrf> for example, if you did it the way i just described - you get a combinatorial explosion if you use more than a couple of ambiguous names
00:26:24 <hvr> piyush-kurur: btw, how did you get raaz into the debian buildqueue?
00:26:30 <piyush-kurur> hvr: I guess you are right but autoconf is scary.
00:26:30 <EEVV> benzrf, well `test :: Token` ok, test is a Token `test = Right 2` since test is a token, let's check to see if such a constructor matches
00:26:33 <EEVV> BAM it matches
00:26:47 <benzrf> EEVV: what do you mean "let's check to see if a constructor matches"?
00:26:52 <piyush-kurur> hvr: I did not Sean Whitton did
00:26:54 <EEVV> benzrf, . . .
00:27:03 <EEVV> I think you have more years in haskell, than I have days
00:27:07 <EEVV> you surely should understand
00:27:08 <ertesx> EEVV: this sounds really simple…  consider becoming a GHC contributor =)
00:27:23 <benzrf> EEVV: sorry, i'm being kind of deliberately obtuse -
00:27:24 <EEVV> ertesx, I know, it would be great to have such a feature
00:27:28 <benzrf> EEVV: it's a bad habit :|
00:27:37 <EEVV> unless my sarcasm meter isn't calibrated :(
00:27:46 <benzrf> when i say "deliberately obtuse", i mean more like
00:27:58 <bollu> does stack word with sierra now?
00:28:02 <benzrf> I do actually understand what you mean, but only at a sort of intuitive level of how i would do it as a human
00:28:05 <bollu> I'm holding off on installing the update
00:28:11 <ertesx> EEVV: (hint: if it really were that simple, someone would have done it likely, but more likely it would require major refactoring of how GHC works)
00:28:14 <benzrf> i don't understand how it translates into the way haskell works and how you write compilers
00:28:39 <benzrf> but i'm automatically saying "I don't get it" to mean the second case without acknowledging that what you're saying does make sense at a handwavy level
00:28:58 <ertesx> EEVV: GHC has a history of actually adding useful things, so if it doesn't add a useful feature, there is usually a very good reason for it
00:28:58 <benzrf> sorry
00:29:46 <geekosaur> bollu, changes are needed in stack, in Cabal, and in ghc. stack may have made its changes, ghc's and Cabal's changes will be in 8.0.2 (and I believe Cabal is still being nailed down because of backward compatibility issues?)
00:29:58 <bollu> god damn it
00:30:01 <benzrf> EEVV: basically - i can follow the logic of "since test :: Token and we are writing a data constructor application as the definition of test, we know that the data constructor must be one of Token's, so let's see if one has that name"
00:30:31 <benzrf> EEVV: the problem is, i don't see any pleasant way of framing that logic at the level of language specification
00:30:42 <hvr> bollu: ?
00:30:51 <benzrf> the only thing i can think of off the top of my head is to brute force it
00:31:11 <hvr> bollu: you could try to ask Apple not to break stuff so often :-)
00:31:24 <bollu> hvr: :)
00:31:30 <benzrf> OR, implement an extremely special case for precisely when you have a data constructor application on the right hand side of a top level definition
00:31:41 <benzrf> but that would be an ugly thing to add to the language as a single lone convenience
00:31:49 <benzrf> especially when people don't often overlap data constructor names!
00:32:55 <geekosaur> as fart as anyone can tell, Apple put a restriction in object files that makes them more compatible with (probably) watchOS, but that restriction causes problems for ghc. working around that without requiring a hard compatibility break in ghc and Cabal is ... difficult
00:33:04 <piyush-kurur> hvr: does autoconf work in the windows world I am asking because I have never touched a windows based developer machine (even with a 1 meter pole)
00:33:11 <bollu> the restriction was with path lengths IIRC?
00:33:14 <ertesx> that line was a work o fart
00:33:34 <benzrf> @remember <ertesx> that line was a work o fart
00:33:34 <lambdabot> Done.
00:33:39 <geekosaur> the restriction is with the size of the "load commands table"; the number and size of RPATH entries is what's causing problems
00:35:13 <benzrf> EEVV: sorry, is that comprehensible?
00:36:13 <geekosaur> the way ghc was creating RPATH entries for its dylibs was causing a combinatorial explosion in the load commands table, which was fine until Apple clamped a 32KB limit on it in Sierra.
00:36:14 <EEVV> benzrf, yeah
00:36:27 <benzrf> ah, good
00:37:27 <benzrf> are combinatorial explosions what happen when finite graph theorists get vendettas?
00:37:58 <piyush-kurur> hvr: never mind answering I found out that it will not work (cabal docs say so). 
00:38:21 <piyush-kurur> I will have to flag with if os(windows) I guess.
00:39:10 <geekosaur> piyush-kurur, I think autoconf does actually work with windows + msys2 (or windows + cygwin). but not with older msys
00:40:17 <piyush-kurur> geekosaur: One interesting approach would be to use a haskell script for the configure. I guess that would be fine on windows as well (because cabal is already there haskell should be there)
00:40:23 <geekosaur> you really want to be using msys2 anyway because building pretty much anything that isn't Microsoft ecosystem is unreliable at best otherwise
00:41:21 <hvr> piyush-kurur: using haskell to do autoconf's job gets you into other issues
00:41:40 <geekosaur> ...and even if you go Microsoft ecosystem, you can't *find* installed libs unless they're copied to winsys (highly discouraged in win7 and later)
00:41:41 <hvr> piyush-kurur: you'd have to use build-type:custom, which has a lot more problems than autoconf
00:41:52 <geekosaur> and yes, that, very that
00:42:03 <bollu> hvr: I don't remember where I read this, but someone called doing things like this as "having a morphism in the category of problems"
00:42:11 <geekosaur> custom build is its own nightmare
00:42:12 <hvr> lol
00:42:24 <geekosaur> @quote category.of.problems
00:42:24 <lambdabot> merijn says: If you have a problem and you think "I know, I'll use lenses!", you now have morphisms in the category of problems :P
00:42:38 <bollu> ah :) well there you go
00:43:01 * hvr wonders what the morphisms represent in the problem-cat
00:43:09 <ertesx> the only omega-sized category
00:43:11 <piyush-kurur> hvr: I see. I had a  custom build before and I got rid of it because of maintanence problems
00:43:27 <bollu> hvr: problem-transformations. 
00:43:36 <bollu> hvr: no?
00:43:53 <hvr> bollu: so it's really just a single problem which can be transformed into various manifestations? :)
00:44:12 <bollu> hvr: a -> b iff a can be converted to b. Question: is there an arrow from the sub-category of problems NP to the subcategory of problems in P? 
00:44:28 <bollu> hvr: I'd like to imagine a richer structure ;)
00:44:34 <hvr> heh
00:45:15 <bollu> you have a natural functor to the solutions category. given a -> b, you can make Solution a -> Solution b :P
00:45:51 <ertesx> that even sounds halfway sensible
00:46:07 <bollu> it does
00:46:29 <benzrf> bollu: actually, that's probably a contravariant functor
00:46:54 <benzrf> transforming problem a into problem b lets you solve a using a solution for b
00:47:04 <benzrf> so that takes a morphism a -> b to a morphism sol b -> sol a
00:47:15 <bollu> oh yeah 
00:47:23 <geekosaur> until it gives you an ab problem
00:47:34 <ertesx> so even the "halfway" was halfway sensible =)
00:47:36 <bollu> there's also a forgetful functor from sol to prob
00:47:46 <lpaste> koz_ pasted “Need help with monad transformers” at http://lpaste.net/294611
00:48:07 <nwolverson> bollu: think we're all familiar with that one
00:48:17 <bollu> xD
00:48:46 <bollu> now if only we get an adjoint free functor, we can pack our bags and chill out? :P
00:49:54 <ertesx> "hey, check this out!  i found a problem for this guy's solution!"
00:51:11 <benzrf> bollu: i dont think an adjoint functor helps here
00:51:33 <benzrf> that lets you get a type for solutions, but it doesnt give you an inhabitant
00:51:50 <benzrf> actually it doesnt even get you a type for solutions - the solution functor is already what you want
00:52:11 <benzrf> oh, wait
00:52:14 <benzrf> hmmm
00:53:23 <piyush-kurur> hvr: now I have filed an issue here https://github.com/raaz-crypto/raaz/issues/278. I am working on fixing this.
00:56:16 <bollu> benzrf:  why wont therebe an inhabitant?
01:02:20 <geekosaur> I don't read that as "won't be one" so much as "won't help you find one"
01:04:57 <bollu> ah right, I suppose that is true
01:05:13 <bollu> existence isn't enough to compute it, right geekosaur, benzrf
01:07:49 <ertesx> bollu: depends whether you ask a constructive mathematician
01:08:19 <bollu> ertesx: :)
01:08:35 <ertesx> not . not ≠ id
01:09:35 <sm> hello all. Is it normal for intero to build on first viewing a module in every new project, rather than quickly installing a precompiled version ? It's driving me crazy
01:12:40 * hackagebot amazonka-core 1.4.4 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.4.4 (BrendanHay)
01:12:42 * hackagebot amazonka 1.4.4 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.4.4 (BrendanHay)
01:12:44 * hackagebot amazonka-test 1.4.4 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.4.4 (BrendanHay)
01:12:46 * hackagebot hw-balancedparens 0.1.0.0 - Balanced parentheses  https://hackage.haskell.org/package/hw-balancedparens-0.1.0.0 (haskellworks)
01:17:48 <bollu> ertesx: but I can write ((a -> Void) -> Void) -> a!
01:17:55 <bollu> at least I think 
01:18:31 <bollu> > (flip ($)) (a :: Expr)
01:18:33 <lambdabot>  error:
01:18:33 <lambdabot>      • No instance for (Typeable c0)
01:18:33 <lambdabot>          arising from a use of ‘show_M119035715122628733723970’
01:18:36 <bollu> hm
01:19:47 <Rarrikins> Never use show_M119035715122628733723970. It's just a bad idea.
01:20:51 <ertesx> bollu: sure, but that's not the same as 'a'
01:21:18 <ertesx> bollu: also i think you mean:  (a -> Void) -> Void
01:21:23 <bollu> ertesx: ah yes
01:21:44 <bollu> ertesx: hm, okay, I get what you mean
01:24:44 <benzrf> bollu: ach, thats not what i meant
01:24:57 <benzrf> like - `Not' is a contravariant functor, right?
01:25:16 <benzrf> but just because we can get `Not True' as an object, doesnt give us an inhabitant of it.
01:25:32 <bollu> benzrf: hm
01:25:34 <benzrf> the functor doesnt find /solutions/, it finds the things that solutions /inhabit/
01:25:37 <benzrf> anyway bbl
01:25:42 <bollu> benzrf: not is a functor?
01:30:01 <Xnuk> :t not
01:30:03 <lambdabot> Bool -> Bool
01:30:33 <nshepperd1> :k Not
01:30:35 <lambdabot> error:
01:30:35 <lambdabot>     Not in scope: type constructor or class ‘Not’
01:30:43 <nshepperd1> Oh
01:32:41 * hackagebot hw-conduit 0.1.0.0 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-conduit-0.1.0.0 (haskellworks)
01:33:04 <nshepperd1> type Not a = a -> Void
01:33:45 <bollu> an that void
01:33:49 <bollu> ah*
01:33:51 <bollu> that Not*
01:33:54 <bollu> the logic not
01:34:34 <ongy> there's other nots?
01:34:58 <nshepperd1> The curry Howard "not"
01:38:32 <ongy> putting that into google doesn't help :(
01:39:47 <afif> hi guys, I'm new in nhaskel and i have been trying to solve this problem for a long time.Can someone please take a look?http://lpaste.net/294377
01:39:54 <nshepperd1> ongy: there's the value level not (Bool -> Bool) which doesn't come with inhabitants (proofs) or anything
01:39:59 <afif> *haskell
01:42:02 <ongy> afif: what's 'max' in line 23? and look at your recursion in line 24, what's the type of the expression in parenthesis?
01:42:41 * hackagebot amazonka-ec2 1.4.4 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.4.4 (BrendanHay)
01:42:43 * hackagebot amazonka-s3 1.4.4 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.4.4 (BrendanHay)
01:43:11 <afif> ongy: max is supposed to find the max for xs
01:43:40 <ongy> afif: then what's maxList?
01:44:48 <afif> ongy: I defined that in the question.It's supposed to find max of Cons a(Cons b(Cons c..))) list
01:45:33 <ongy> afif: then what's the difference between max and maxList?
01:46:03 <afif> ongy: I thought max is the built in function.
01:46:27 <afif> ongy: maxList will find max of the list, like max but for the Cons format
01:46:46 <ongy> :t max
01:46:48 <lambdabot> Ord a => a -> a -> a
01:47:26 <ertes> afif: let's say that 'max' were a built-in function: why are you bothering to create your own, if you're just resorting to the built-in one?
01:47:34 <afif> ongy: sorry then I should use maximum?
01:47:38 <ongy> max is for 2 elements, not for lists. For a list it would be maximum. But you can't just apply that to your xs, since it's not a list
01:47:41 * hackagebot amazonka-route53 1.4.4 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.4.4 (BrendanHay)
01:48:06 <dibblego> there is no maximum of a list, there is for NonEmptyList though
01:49:05 <afif> Please take a look and help me figure out, I am a newbie http://lpaste.net/294377
01:49:24 <ertes> afif: you can't use any built-in function, and you shouldn't either
01:49:58 <ertes> afif: recursion means that you are going to reuse *your own function*, the one you're defining, on a smaller argument
01:51:03 <ertes> "smaller" can mean smaller in value (numbers), shorter (lists), etc…  the point is that you eventually reach a "base case"
01:51:33 <afif> maxList (Cons a Nil) =  a is my base case?
01:52:12 <ertes> no, your base case is when there is no "smaller" argument, i.e. your zero/empty case:  maxList Nil = _
01:52:42 * hackagebot amazonka-directconnect 1.4.4 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.4.4 (BrendanHay)
01:52:44 * hackagebot amazonka-elasticsearch 1.4.4 - Amazon Elasticsearch Service SDK.  https://hackage.haskell.org/package/amazonka-elasticsearch-1.4.4 (BrendanHay)
01:52:46 * hackagebot amazonka-devicefarm 1.4.4 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.4.4 (BrendanHay)
01:52:47 <dibblego> imo, this exercise is unsuitable for beginners, for exactly this reason
01:52:48 * hackagebot amazonka-elb 1.4.4 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.4.4 (BrendanHay)
01:52:50 * hackagebot amazonka-cognito-sync 1.4.4 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.4.4 (BrendanHay)
01:53:14 <ertes> afif: now let's make your function actually correct: start by writing a type signature…  i want you to write a function that does *not* have an error case
01:53:28 <dibblego> the base-case is actually (Cons _ Nil)
01:53:51 <ertes> afif: maxList :: _fillThisIn
01:54:48 <afif> ertes: maxList :: (Cons x y) -> a-> a
01:54:53 <afif> I'm not sure
01:55:07 <ertes> afif: the type (!) Cons doesn't exist
01:55:54 <afif> eters: but I'm supposed to give a Cons format list and get a maximum number
01:56:26 <ertes> afif: right now we're talking about the *type* of the function…  not which values it takes and returns, but of which types those values are
01:56:32 <ertes> afif: how many arguments does the function have?
01:57:31 <afif> ertes:maxLisx:: (Num a, Ord a)=> [a]->a
01:57:51 <ertes> afif: that's not correct, because you're not using the built-in list type [], but your own List
01:57:52 * hackagebot amazonka-dms 1.4.4 - Amazon Database Migration Service SDK.  https://hackage.haskell.org/package/amazonka-dms-1.4.4 (BrendanHay)
01:57:54 * hackagebot amazonka-elbv2 1.4.4 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elbv2-1.4.4 (BrendanHay)
01:57:56 * hackagebot amazonka-importexport 1.4.4 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.4.4 (BrendanHay)
01:57:58 * hackagebot amazonka-certificatemanager 1.4.4 - Amazon Certificate Manager SDK.  https://hackage.haskell.org/package/amazonka-certificatemanager-1.4.4 (BrendanHay)
01:58:00 * hackagebot amazonka-elastictranscoder 1.4.4 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.4.4 (BrendanHay)
01:58:51 <afif> ertes: That's my problem.I was given customized List by my teacher.
01:59:38 <ertes> afif: that's fine, but then you have to use that type in the type signature as well:  maxList :: (Num a, Ord a) => List a -> a  -- but do you see any particular reason why it has to be a numeric type?
02:00:17 <afif> ertes: no.Then it has to be List type?errr....
02:01:04 <ertes> afif: i mean the elements don't have to be numeric (they could be strings, and you'd be searching for the last string in dictionary order):  maxList :: (Ord a) => List a -> a
02:01:04 <afif> ertes: Ord type only then?
02:01:31 <ertes> afif: however, there is a problem with your function that dibblego has been hinting at:  what's the maxList of the empty list?
02:02:09 <afif> ertes: maxList Nil = error "The list is empty"
02:02:28 <afif> ertes: data List a = Nil | Cons a (List a) deriving Show
02:02:34 <ertes> afif: does your teacher explicitly tell you to write a function that crashes the universe on empty lists?
02:03:02 * hackagebot amazonka-kinesis 1.4.4 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.4.4 (BrendanHay)
02:03:04 * hackagebot amazonka-cloudsearch-domains 1.4.4 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.4.4 (BrendanHay)
02:03:06 * hackagebot amazonka-cloudwatch 1.4.4 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.4.4 (BrendanHay)
02:03:08 * hackagebot amazonka-cloudfront 1.4.4 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.4.4 (BrendanHay)
02:03:10 * hackagebot amazonka-iot-dataplane 1.4.4 - Amazon IoT Data Plane SDK.  https://hackage.haskell.org/package/amazonka-iot-dataplane-1.4.4 (BrendanHay)
02:03:11 <afif> ertes: yes. He said empty or Nil should give error
02:03:59 <ertes> afif: then the type is fine (but your teacher is not)…  in that case the Nil case isn't your base case, but you need a separate base case for singleton lists
02:04:32 <afif> ertes: maxList (Cons a Nil) =  a
02:04:50 <ertes> afif: so first add this type signature above your function:  maxList :: (Ord a) => List a -> a  -- it will help the compiler be more helpful when you get a type error
02:04:58 <ertes> afif: that's correct
02:05:00 <afif> ertes: expected output maxList (Cons 2 (Cons 7 (Cons 3 (Cons 4 Nil)))) -> 7
02:05:23 <afif> maxList (Cons 4 Nil) -> 4
02:05:49 <ertes> afif: now the recursive case, for which you may use the 'max' function apparently…  is that correct?
02:06:47 <afif> ertes: do I have to somehow compare x with xs.
02:07:07 <ertes> afif: either that or use 'max', which just wraps that comparison
02:07:13 <ertes> > max 4 7
02:07:16 <lambdabot>  7
02:07:25 <ongy> I doubt x and xs can be directly compared. What's the type of each?
02:07:43 <ertes> ongy: they can't be…  they are what their names sound like =)
02:07:57 <afif> I get x as Cons x Nil = x
02:08:12 * hackagebot amazonka-elasticache 1.4.4 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.4.4 (BrendanHay)
02:08:14 * hackagebot amazonka-cloudformation 1.4.4 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.4.4 (BrendanHay)
02:08:16 * hackagebot amazonka-ecs 1.4.4 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.4.4 (BrendanHay)
02:08:18 * hackagebot amazonka-marketplace-metering 1.4.4 - Amazon Marketplace Metering SDK.  https://hackage.haskell.org/package/amazonka-marketplace-metering-1.4.4 (BrendanHay)
02:08:20 * hackagebot amazonka-kinesis-firehose 1.4.4 - Amazon Kinesis Firehose SDK.  https://hackage.haskell.org/package/amazonka-kinesis-firehose-1.4.4 (BrendanHay)
02:08:22 <afif> but xs would be something like Cons a(Cons b....
02:08:27 <ertes> afif: let's write this by hand
02:09:16 <ertes> afif: no, actually let's use the 'max' function
02:09:49 <ertes> afif: maxList (Cons x xs) = _fillThisIn  -- the result of this is supposed to be the maximum between x and the elements of xs, right?
02:10:13 <afif> ertes: yes
02:11:00 <ertes> afif: and "the maximum between x (a value) and the elements of xs (a list)" is "the maximum between x (a value) and the maximum (a value) between the elements of xs"
02:11:08 <afif> ertes; but xs would be some Cons a(Cons b(Cons c Nil))) format
02:11:20 <ertes> afif: does that statement make sense?
02:11:58 <afif> ertes: x compare with maximum xs?
02:12:13 <ertes> afif: that's just a statement in words…  does it make sense to you?
02:12:15 <afif> maximum [1,2,3] 
02:12:19 <afif> 3
02:12:34 <afif> so it only applys to [1,2,3] format
02:12:52 <ertes> afif: disregard code…  just read the statement, and tell me if the way i wrote it makes sense
02:12:55 <afif> but I have (Cons 1(Cons 2(Cons 3 Nil)))
02:13:22 * hackagebot amazonka-sts 1.4.4 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.4.4 (BrendanHay)
02:13:24 * hackagebot amazonka-swf 1.4.4 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.4.4 (BrendanHay)
02:13:26 * hackagebot amazonka-kinesis-analytics 1.4.4 - Amazon Kinesis Analytics SDK.  https://hackage.haskell.org/package/amazonka-kinesis-analytics-1.4.4 (BrendanHay)
02:13:29 * hackagebot amazonka-sdb 1.4.4 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.4.4 (BrendanHay)
02:13:30 * hackagebot amazonka-workspaces 1.4.4 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.4.4 (BrendanHay)
02:14:12 <afif> ertes: yes I understand x is a value and xs is values. I will compare x with the max of xs
02:14:53 <ertes> afif: so:  maxList (Cons x (Cons y (Cons z Nil))) = max x (theMaximumOf (Cons y (Cons z Nil)))
02:14:55 <afif> which I ncan do like maxlist x:xs | x > maximum xs  = x | otherwise = maxlist xs
02:15:18 <afif> but my maxList takes Cons a(Cons b....
02:16:49 <ertes> afif: you need to connect the exact words i said to code now
02:17:11 <ertes> "the maximum between xs and the maximum between the elements of xs" translates to:  max x (theMaximumOf xs)
02:17:39 <ertes> where theMaximumOf is some unknown function
02:18:32 * hackagebot amazonka-emr 1.4.4 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.4.4 (BrendanHay)
02:18:34 * hackagebot amazonka-codedeploy 1.4.4 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.4.4 (BrendanHay)
02:18:36 * hackagebot amazonka-cloudwatch-logs 1.4.4 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.4.4 (BrendanHay)
02:18:38 * hackagebot amazonka-codecommit 1.4.4 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.4.4 (BrendanHay)
02:18:40 * hackagebot amazonka-efs 1.4.4 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.4.4 (BrendanHay)
02:20:36 <ertes> afif: maxList (Cons x xs) = max x (theMaximumOf xs)  -- the maximum between x and (the maximum between the elements of xs)…  does this make sense?
02:20:55 <ertes> (where theMaximumOf is still an unknown function)
02:21:28 <afif> ertes: yes. see my updated= http://lpaste.net/294377
02:22:04 <ertes> afif: that looks better, but it's still not correct
02:22:12 <ertes> the code above was an example
02:22:34 <afif> ertes: http://lpaste.net/294377 with new errors
02:23:42 * hackagebot amazonka-gamelift 1.4.4 - Amazon GameLift SDK.  https://hackage.haskell.org/package/amazonka-gamelift-1.4.4 (BrendanHay)
02:23:44 * hackagebot amazonka-elasticbeanstalk 1.4.4 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.4.4 (BrendanHay)
02:23:46 * hackagebot amazonka-apigateway 1.4.4 - Amazon API Gateway SDK.  https://hackage.haskell.org/package/amazonka-apigateway-1.4.4 (BrendanHay)
02:23:48 * hackagebot amazonka-datapipeline 1.4.4 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.4.4 (BrendanHay)
02:23:50 * hackagebot amazonka-support 1.4.4 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.4.4 (BrendanHay)
02:26:27 <ertes> afif: the error is unrelated to the code, but the code is still wrong
02:26:34 <ertes> i gave you enough information to fix it though
02:28:52 * hackagebot amazonka-sns 1.4.4 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.4.4 (BrendanHay)
02:28:54 * hackagebot amazonka-dynamodb-streams 1.4.4 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.4.4 (BrendanHay)
02:28:56 * hackagebot amazonka-cloudtrail 1.4.4 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.4.4 (BrendanHay)
02:28:58 * hackagebot amazonka-opsworks 1.4.4 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.4.4 (BrendanHay)
02:29:00 * hackagebot amazonka-snowball 1.4.4 - Amazon Import/Export Snowball SDK.  https://hackage.haskell.org/package/amazonka-snowball-1.4.4 (BrendanHay)
02:33:36 <ongy> someone likes amazon
02:34:02 * hackagebot amazonka-rds 1.4.4 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.4.4 (BrendanHay)
02:34:03 <ertes> or someone maintains a lot of amazon packages
02:34:04 * hackagebot amazonka-cognito-identity 1.4.4 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.4.4 (BrendanHay)
02:34:06 * hackagebot amazonka-codepipeline 1.4.4 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.4.4 (BrendanHay)
02:34:08 * hackagebot amazonka-ssm 1.4.4 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.4.4 (BrendanHay)
02:34:10 * hackagebot amazonka-ml 1.4.4 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.4.4 (BrendanHay)
02:39:12 * hackagebot amazonka-ses 1.4.4 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.4.4 (BrendanHay)
02:39:14 * hackagebot amazonka-inspector 1.4.4 - Amazon Inspector SDK.  https://hackage.haskell.org/package/amazonka-inspector-1.4.4 (BrendanHay)
02:39:16 * hackagebot amazonka-glacier 1.4.4 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.4.4 (BrendanHay)
02:39:18 * hackagebot amazonka-sqs 1.4.4 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.4.4 (BrendanHay)
02:39:20 * hackagebot amazonka-iot 1.4.4 - Amazon IoT SDK.  https://hackage.haskell.org/package/amazonka-iot-1.4.4 (BrendanHay)
02:43:03 <ongy> all the versions match aswelll
02:44:22 * hackagebot amazonka-ds 1.4.4 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.4.4 (BrendanHay)
02:44:24 * hackagebot amazonka-cloudsearch 1.4.4 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.4.4 (BrendanHay)
02:44:26 * hackagebot amazonka-storagegateway 1.4.4 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.4.4 (BrendanHay)
02:44:28 * hackagebot amazonka-cognito-idp 1.4.4 - Amazon Cognito Identity Provider SDK.  https://hackage.haskell.org/package/amazonka-cognito-idp-1.4.4 (BrendanHay)
02:44:30 * hackagebot amazonka-kms 1.4.4 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.4.4 (BrendanHay)
02:44:49 --- mode: ChanServ set +o dmwit
02:44:49 <harfangk> uh what's going on with the bot?
02:45:02 --- mode: dmwit set +q hackagebot!*@*
02:45:45 <sh0> Hello
02:46:50 <sh0> any faggots online? i wanna make friends
02:47:33 --- kick: sh0 was kicked by dmwit (That language is not appropriate here.)
02:49:24 <sh0> now whos the mother fucker who just kicked me, identify yourself or get nmap'd. you have exactly 3 minutes
02:49:53 --- mode: ChanServ set +o geekosaur
02:50:04 --- mode: dmwit set -v hackagebot
02:50:58 --- mode: ChanServ set +o mauke
02:50:58 --- mode: mauke set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.173.26.242.235
02:51:03 <geekosaur> 0k l33t k1d, surely you can work that out for yourself
02:51:24 --- kick: sh0 was kicked by mauke (the hacker known as 4 chan)
02:51:43 <Vyn> Didn't take three minutes. Good work
02:52:09 <Vyn> One second shy of two minutes, in fact
02:53:24 --- mode: mauke set -o mauke
02:53:53 --- mode: geekosaur set -o geekosaur
02:54:01 --- mode: dmwit set -q hackagebot!*@*
02:54:14 --- mode: dmwit set -o dmwit
02:54:42 * hackagebot amazonka-config 1.4.4 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.4.4 (BrendanHay)
02:54:44 * hackagebot amazonka-cloudwatch-events 1.4.4 - Amazon CloudWatch Events SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-events-1.4.4 (BrendanHay)
02:54:46 * hackagebot amazonka-ecr 1.4.4 - Amazon EC2 Container Registry SDK.  https://hackage.haskell.org/package/amazonka-ecr-1.4.4 (BrendanHay)
02:54:48 * hackagebot amazonka-cloudhsm 1.4.4 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.4.4 (BrendanHay)
02:54:50 * hackagebot amazonka-dynamodb 1.4.4 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.4.4 (BrendanHay)
02:54:59 --- mode: ChanServ set +o mauke
02:54:59 --- mode: mauke set +q *!*@li229-222.members.linode.com
02:55:56 <ews> Is there any way to hide "Loading package ..." at GHCi startup?
02:56:59 --- mode: mauke set -o mauke
02:57:32 <dmwit> I don't think I've seen that message for ages. Perhaps you're on an old version of GHC?
02:57:35 <geekosaur> maybe -v0?
02:58:38 <ews> Thanks, -v0 did the trick
02:58:56 <dmwit> Oh, turns out I have -v0 in my .ghci.
02:59:05 <dmwit> geekosaur++
03:24:59 --- mode: ChanServ set +o mauke
03:24:59 --- mode: mauke set -q *!*@li229-222.members.linode.com
03:26:59 --- mode: mauke set -o mauke
03:32:47 * hackagebot ombra 0.1.1.0 - Render engine.  https://hackage.haskell.org/package/ombra-0.1.1.0 (ZioCrocifisso)
03:50:58 --- mode: ChanServ set +o mauke
03:50:58 --- mode: mauke set -b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.173.26.242.235
03:52:58 --- mode: mauke set -o mauke
03:56:01 <jchia_> How do i properly clean up the stack files in ~/.stack/ and project/.stack-work/ ? I want to clean up old stuff for reason why I want to clean a project a rebuild, also sometimes partly to recover disk space when I update to a new resolver. I manually delete certain directories with the name of old resolvers but it often confuses stack.
04:36:46 <anju> Can someone take a look and help me please? I'm a newbie and I'm struggling with the question long time.http://lpaste.net/294377
04:38:27 <mettekou> anju: Why exactly are you supplying two arguments (of which one is a hole indicated by _) to the recursive call to maxList?
04:39:28 <anju> mettekou: because my expected output :maxList (Cons 4 Nil) -> 4 maxList (Cons 2 (Cons 7 (Cons 3 (Cons 4 Nil)))) -> 7
04:40:41 <geekosaur> maxList takes one parameter, not two
04:40:47 <geekosaur> and what were you expecting the _ to do?
04:41:37 <mettekou> anju: Indeed, just a single argument as geekosaur says, namely the list of which to compute the maximum.
04:42:26 <anju> http://lpaste.net/294377
04:42:55 <anju> my updated : http://lpaste.net/294377 geekosaur, mettekou
04:43:50 <geekosaur> ok, so that brings us to the next problem, which is that you should not be testing xs against Nil there. you handle that on line 19
04:44:03 <geekosaur> do you understand pattern matching?
04:45:03 <mettekou> Indeed, it seems you are struggling with pattern matching.
04:45:49 <anju> geekosaur: I just did it!
04:46:16 <anju> I had problem with pattern matching, thanks guys.
05:04:34 <calloc> How do I make an IO Nothing? :t Maybe (IO ())
05:05:47 <Laurenzo> convice java programmer to use haskell
05:06:39 <calloc> Laurenzo: "or else"
05:07:00 <Laurenzo> :)
05:07:07 <Laurenzo> good one!
05:07:27 <ongy> calloc: IO ()
05:08:24 <ongy> oh, sorry wrong way around
05:08:45 <ongy> do you have to return something that's Maybe (IO ())?
05:09:03 <pyrtsa> `Nothing :: Maybe (IO ())`
05:09:04 <geekosaur> in one relevant sense, yes :)
05:09:41 <geekosaur> although I am wondering if they actually mean a Maybe (IO whatever) or an IO (Maybe whatever)
05:10:03 <calloc> ongy: I was playing with foo = Just putStrLn "foo"; baz = **Nothing**; foo >>= baz
05:11:05 <pyrtsa> calloc: Maybe you mean `baz = const Nothing` if you want that to typecheck.
05:11:12 <ongy> > Just (putStrLn "foo") >>= const Nothing
05:11:15 <lambdabot>  Nothing
05:12:30 <calloc> I was thinking it should print foo.
05:12:53 <ongy> but it doesn't make much sense. When you get Maybe (IO a) it gets annoying :(
05:13:30 <geekosaur> calloc, if it's Maybe *something* then you cannot do IO, you are in the Maybe monad not the IO monad
05:13:31 <ashishnegi> hi.. can someone take a look at http://lpaste.net/295223 ; Hardcoded number 4242 works but .. taking it from the field of newtype is not working.. 
05:13:59 <geekosaur> possibly you wanted MaybeT, possibly you wanted an IO (Maybe *something*)
05:14:44 <ongy> portnumber is Num, so you will have to convert it
05:15:01 <calloc> Will that allow you to conditionally evaluate two IO functions in sequence?
05:15:03 <geekosaur> also the portnumber stuff is annoying...
05:15:20 <geekosaur> (byteswapping magics)
05:15:26 <ongy> ashishnegi: the literal will be converted because of the Num instance, you will have to convert manually for values, I think fromIntegral should work. (a bit clearer)
05:16:07 <ashishnegi> ongy: thanks.. :(
05:17:53 * hackagebot obd 0.2.1.1 - Communicate to OBD interfaces over ELM327  https://hackage.haskell.org/package/obd-0.2.1.1 (hverr)
05:18:12 <geekosaur> calloc, MaybeT would, assuming you also used lift or liftIO when appropriate. but even then I would probably just use a conditional instead of a transformer
05:19:18 <calloc> geekosaur: Would that just be cleaner?
05:19:45 <geekosaur> often yes
05:20:48 <geekosaur> the Maybe / MaybeT monad is useful in some cases but confusing in many cases.
05:23:05 <ongy> MaybeT? I have to try that out
05:33:58 <calloc> So you can't do IO in the Maybe monad because it would be an ambiguous case for the applicative?
05:34:29 <calloc> And MaybeT makes compositions of Monads explicit?
05:37:54 * hackagebot iconv-typed 0.1.0.0 - Type safe iconv wrapper  https://hackage.haskell.org/package/iconv-typed-0.1.0.0 (AlfredoDiNapoli)
05:37:56 * hackagebot xlsx-tabular 0.1.1 - Xlsx table decode utility  https://hackage.haskell.org/package/xlsx-tabular-0.1.1 (KazuoKoga)
05:38:06 <geekosaur> you can only do IO in the IO monad, or (using liftIO or an appropriate number of lift-s) a transformer over IO
05:38:56 <geekosaur> Maybe (IO something) is not an IO context, it is an IO action in pure code that cannot be executed unless it is brought into an IO context
05:39:34 <hpc> technically there's no "IO context" until runtime
05:40:14 <hpc> main is an IO action in pure code, and then some runtime magic executes that, and that would be what you could consider the IO context
05:40:28 <geekosaur> "IO context" as in "you can only do IO in the IO monad, or (using liftIO or an appropriate number of lift-s) a transformer over IO"
05:40:42 <hpc> ah :P
05:40:48 <geekosaur> as opposed to Maybe (something that might be an IO action)
05:42:54 * hackagebot iconv-typed 0.1.0.1 - Type safe iconv wrapper  https://hackage.haskell.org/package/iconv-typed-0.1.0.1 (AlfredoDiNapoli)
05:48:33 <calloc> Thanks for your help, I'm going to keep reading. Do you have any sources in particular that would help develop intuition for this stuff?
05:49:14 <ongy> what stuff? when IO is possible?
05:50:16 <calloc> That and understanding monads. I'm working through learnyouahaskell and tinkering on the interpreter.
05:55:02 <maerwald> don't work on lyah
05:55:07 <maerwald> @where learnhaskell
05:55:07 <lambdabot> https://github.com/bitemyapp/learnhaskell
05:58:27 <hpc> lyah is fine as long as you are aware of its weaknesses and supplementing them elsewhere, but yeah there's definitely better ways to learn
05:58:42 <hpc> (specificially lyah doesn't have exercises, and the tone of the writing isn't for everyone)
05:58:48 <jchia_> Sometimes a useless argument is passed to a function just for the type information, e.g. foo (undefined :: Int). The value is useless but the type matters. Is there another way to do this without using undefined? ClassyPrelude gives warnings about undefined that I'm trying to avoid.
05:59:37 <jchia_> Is there a synonym for undefined?
05:59:38 <hpc> jchia_: (foo :: Something With Int) the-rest-of-the-parameters
05:59:51 <hpc> jchia_: if you can control how foo is defined
06:01:03 <hpc> jchia_: if you really do need that placeholder parameter for some odd reason, consider https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Proxy.html which is made for that purpose
06:01:30 <hpc> instead of (undefined :: Int), you use (Proxy :: Proxy Int), and change foo :: a -> whatever, to foo :: Proxy a -> whatever
06:01:51 <hpc> no more warning, and you've documented that the first argument does nothing but provide type information
06:11:20 <jchia_> hpc: To be clear, I mean something like this: http://lpaste.net/295331 . I barely know anything about proxies. Do they apply for this sort of use case?
06:12:20 <hpc> ah
06:12:32 <hpc> yeah, it'll still apply here
06:12:56 <hpc> change the type of name and what you call it with, and it'll all just work
06:13:46 <hpc> i think there's an even better way to do it, but it's too early in the morning for me to remember what it is ;)
06:14:15 <jchia_> thanks. i'm going to read about Data.Proxy
06:17:49 <sham1> o/
06:27:57 * hackagebot cryptohash-sha512 0.11.100.1 - Fast, pure and practical SHA-512 implementation  https://hackage.haskell.org/package/cryptohash-sha512-0.11.100.1 (HerbertValerioRiedel)
06:34:42 <danilo2> Hello guys! I'm trying to create a function which runs an ST monad and has a context which mentiones this ST. Here is an example which meaning doesnt make any sense, but from the types perspective I've got the same problem:
06:34:53 <danilo2> myTest :: MonadState Int (ST s) => Int; myTest a = runST $ get a
06:35:15 <danilo2> this function does not compile because: "Could not deduce (MonadState Int (ST s0))       from the context: MonadState Int (ST s)"
06:35:18 <danilo2> which is understandable
06:35:49 <danilo2> but is there any way to "fix it". By fixing I mean - allowing this context and its further resolution for any s? 
06:36:04 <danilo2> this will not break any assumptions for ST monad as far as I see
06:39:47 <HeLWorLd> quit
06:42:30 <geekosaur> no, you cannot somehow wish the forall away
06:44:29 <danilo2> geekosaur: hmm, but It should be possible, look, this does not compile: class Foo m a where foo :: m a; myTest :: Foo (ST s) a => a; myTest = runST foo
06:44:41 <danilo2> geekosaur: but If I use class Foo2 a where foo2 :: forall s. ST s a  it does
06:44:46 <danilo2> which again is obvious
06:45:12 <danilo2> the problem is that I want to use the general class and use runST just in one of the implementations
06:45:33 <danilo2> in fact this could be possible if we'll have impredicative contexts I think
06:45:37 <geekosaur> maybe you are trying to look for impredicative types
06:45:42 <geekosaur> which do not work and never really have
06:46:51 <danilo2> geekosaur: I know. Ok here is what I'm looking for. I've got class Foo like described above. I want to have one function which just runs it in ST monad but without specyfying the `a` yet. What can I do ?
06:53:01 <lyxia> you can now so this with AllowAmbiguousTypes and TypeApplications. 
06:53:40 <lyxia> danilo2: What is Foo in reality? 
06:53:45 <James123> I have a string e.g. "abcdef". Is there a built-in function that works like this: f 3 "abcdef" results in ["abc", "def"], f 4 "abcdef" results in ["abcd", "ef"] ? Thank you!
06:54:38 <FBI> James123: there are a few recepies for doing that
06:54:50 <FBI> there is nothing builtin
06:55:03 <pyrtsa> splitAt is pretty close.
06:55:25 <FBI> asuming you want group by #
06:55:30 <FBI> and not just split at #
06:55:42 <danilo2> lyxia: it is a Monad that allow me to manage a graph. It has functions like "getNodes" and the graph could be provided both as a context (in state like monad) or explicitly and then we can use runST to run computations using mutable vectors under the hood
06:56:08 <geekosaur> > chunksOf 4 "abcdef"
06:56:10 <lambdabot>  ["abcd","ef"]
06:56:32 <FBI> bha thought this was #python, too many channels open :p
06:56:58 <geekosaur> (Data.List.Split)
06:57:21 <James123> geekosaur: Excellent! Thanks
06:57:38 <hpc> FBI: just remember, in haskell there's always something built in, except when there isn't
06:57:54 * Clint squints.
07:00:20 <ongy> also what's considered builtin? base?
07:06:59 <sham1> Base is the most built in
07:07:24 <sham1> I'd assume other stuff included with stuff like the Haskell Platform would also be considered
07:14:30 <jophish> James123: What do you expect to happen for: f 3 "abcdefg'?
07:15:17 <jophish> I assume ["abc", "def", "g"]
07:15:19 <James123> jophish, ["abc", "def", "g"]
07:15:26 <jophish> yeah, chunksOf :)
07:28:00 * hackagebot sparse-linear-algebra 0.2.0.7 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.0.7 (ocramz)
07:29:14 <danilo2> lyxia, geekosaur : ok, I found the answer regarding the ST context - it is possible currently in this form: http://lpaste.net/295483
07:42:38 <lesshaste> how do you install whatever this needs? "Could not find module ‘Control.Parallel.Strategies’"
07:42:41 <lesshaste> in ghc
07:43:56 <liste> lesshaste: are you using stack or cabal-install?
07:44:10 <lesshaste> liste,  hmm. I just did sudo apt-get install ghc :)
07:44:16 <lesshaste> I am trying to run someone else's code
07:44:33 <lesshaste> shall I just go for cabal?
07:44:46 <liste> lesshaste: does the project have a stack.yaml/stack.yml or <project's name>.cabal file?
07:44:54 <liste> (or both)
07:45:01 <lesshaste> liste,  no sorry.. it's just some haskell code online
07:46:01 <liste> lesshaste: also, what does ghc --version say?
07:46:17 <lesshaste> The Glorious Glasgow Haskell Compilation System, version 7.10.3
07:46:22 <jmcarthur> Did the ghc package you installed also install a cabal or stack executable?
07:46:25 <lesshaste> I am guessing ... cabal install parallel?
07:46:43 <lesshaste> no I just did sudo apt install cabal-install
07:46:45 <jmcarthur> Ah
07:46:49 <lesshaste> I will try canal install parallel
07:46:53 <lesshaste> cabal
07:46:56 <jmcarthur> Yes, that command will work after cabal update
07:46:57 <lesshaste> unless you tell me not to
07:47:15 <jmcarthur> don't use sudo
07:47:18 <lesshaste> hmm... http://hackage.haskell.org/package/parallel
07:47:34 <lesshaste> doing update
07:47:41 <apriori> hello guys. is there any hints or howto on how to use cabal to fully crosscompile something and all its dependencies using an already available ghc cross compiler?
07:47:52 <apriori> (stack would be ok as well, but I doubt it supports it at all)
07:51:17 <kadoban> I mean, stack will use whatever GHC you tell it to, if you try hard enough. But I'm guessing there's more to it than that?
07:52:14 <apriori> the hard part is build processes invoking, say, e.g. alex 
08:11:32 <sphinxo> How come (,) works for both values eg (,) 1 2 and also in type signatures? 
08:11:41 <sphinxo> eg (Int, Int)
08:13:05 <sm> type signatures language is distinct from values language ?
08:15:13 <sphinxo> where can I find the type signature language? 
08:15:13 <sphinxo> sm: is it defined anywhere?
08:15:37 <kadoban> sphinxo: It just does. Some things about lists also work both at the type and value level.
08:15:51 <kadoban> sphinxo: It's in the haskell report I guess
08:16:56 <tjakway> is there a canonical non-biased Either type?  Like Left/Right except not biased towards Right (so no monad instance)
08:17:04 <tjakway> like Scala's Either type if anyone is familiar with that
08:17:43 <ongy> why would you not want the monad instance? you can just not use it
08:18:04 <tjakway> because when I see Either I automatically assume Left means error
08:18:14 <tjakway> I could do that but I think it would be confusing?
08:18:26 <kadoban> It doesn't always mean error
08:18:35 <tjakway> hrm
08:18:35 <tjakway> okay
08:18:37 <tjakway> thanks
08:18:45 <tjakway> still new to Haskell
08:20:17 <geekosaur> actually that was a point of contention. some things did treat Left as always error.
08:20:27 <geekosaur> there is now Except / ExceptT for that
08:22:35 <sphinxo> can you partially apply a type constructor like (,) in a type sig?
08:22:53 <sphinxo> eg fun :: (,) Int; fun = (,) 1
08:22:58 <geekosaur> (which leaves that "left" often has a negative connotation anyway, but renaming the Either constructors would break too much code and making another type to replace Either seems a bit ridiculous)
08:23:43 <geekosaur> sphinxo, type lambdas are ... problematic, so no
08:24:14 <tjakway> geekosaur: ah.  makes sense.
08:25:03 <lightcolter> Hi, I was wondering something about the Maybe Monoid. In Prelude the Maybe Monoid constrains its content to also be a Monoid (Monoid a => Monoid (Maybe a)). Could this constraint not be weakened to Semigroup? This would help with wrapping Semigroups when you need a Monoid. I think its currently like this for historical reasons, but I am curious that if/when Semigroup would be a superclass of Monoid that his would be possible? 
08:25:22 <sphinxo> is it possible to define the function typeOf in haskell? eg given 1::Int  it returns Int?
08:25:59 <jophish> lightcolter: https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Semigroup.html#t:Option
08:26:39 <lightcolter> @jophish that's exactly what I'm looking for. Kudos!
08:26:40 <lambdabot> Unknown command, try @list
08:26:43 <geekosaur> you can't define it in Haskell. depending on what exactly you mean, we may have it provided though...
08:26:53 <geekosaur> :t typeOf
08:26:55 <lambdabot> Typeable a => a -> TypeRep
08:27:05 <liste> > typeOf (4 :: Int)
08:27:07 <lambdabot>  Int
08:27:34 <liste> it's of little use though, because you know the types statically
08:27:36 <geekosaur> note that types are not values, so you cannot have it actually produce the *type* Int. you can get a representation of the type, which cannot be subsequently used as a type
08:28:16 <geekosaur> and because the compiler has to know types statically, you cannot use it to implement typecase
08:29:19 <geekosaur> (well, there are certain circumstances, but they are more limited than most people trying to emulate the type behavior of non-statically-typed languages are trying to accomplish)
08:29:56 <sphinxo> Oh cool, thanks all
08:35:53 <exio4> geekosaur: you can't implement type case? are you willing to bet?
08:45:11 <jmcarthur> exio4: Can you do it without Typeable?
08:46:18 <exio4> jmcarthur: well, that's harder, but you could always do it with unsafeCoerce and manual tags :p
08:47:06 <jmcarthur> unsafeCoerce and manual tags is just ignoring the static type system and implementing your own dynamic type system, so I would probably disqualify that :P
08:49:41 <exio4> jmcarthur: it would be manual Typeable - and there were no constraints ;) 
08:50:47 <jmcarthur> Yeah, I think it would take a special kind of person to accept a bet with no constraints on what it means to lose the bet.
08:53:00 <nilof> How would I implement a queue in Haskell with O(1) time to append to the end? In scheme I'd use a mutable linked list and append to the end with a sentinel
08:53:50 <kaol> nilof: https://hackage.haskell.org/package/dlist
08:54:10 <ski> geekosaur : .. i don't see how type lambdas are related
08:54:47 <geekosaur> partial application of a type? (not just of the data constructor, but of the tuple *type* constructor)
08:55:56 <geekosaur> granting that in that particular example you could avoid it by eta expansion
08:55:57 <kadoban> nilof: You should check out Purely Functional Data Structures by Chris Okasaki. I believe there's a free version online (his thesis maybe?), I dunno how close it is to the actual book though.
08:56:20 <pavonia> Does dlist support true or amortized O(1) appending?
08:57:09 <kadoban> dlist isn't really a queue, AFAIK. Data.Sequence would be more correct, I think?
08:57:38 <ski> sphinxo : `fun :: (,) Int' is nonsense, since `(,) Int :: * -> *', but the type expression appearing to the right of `::' must have kind `*' (or the kind of unboxed types, `#', though perhaps this is changing, recently)
08:57:56 <EvanR> nilof: the classic data structure is two lists. you prepend to the first to enqueue, and pop from the second to dequeue. if you run out of stuff in the second list, reverse the first list, and the new first list is []
08:58:54 <ski> sphinxo : `(,)' is overloaded (or however you want to express it). in a value expression (or pattern) context, it means one thing. in a type expression (or pattern) context, it means another thing
09:00:07 <ski> nilof : that pair-of-lists is amorticized (sp ?) `O(1)' dequeue
09:00:28 <kadoban> amortized
09:00:31 <ski> ty
09:00:49 <EvanR> gotta love O(1) 
09:00:59 <EvanR> esp when its an arbitrarily large constant factor ;)
09:01:27 <ski> nilof : you might be interested in PFDS, by Okasaki, which goes through more advanced immutable data structures as well
09:01:31 <ski> @where PFDS
09:01:32 <lambdabot> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
09:03:51 <ski> the idea with the pair-of-queues is that around every `n'th dequeuing operation, you'll need to reverse a list having length around `n'
09:04:38 <EvanR> esp if you upgrade it to be a bounded queue
09:05:35 <EvanR> then i guess its really O(1)
09:06:44 <plakband> I'm currently reading images into accelerate arrays using repa-devil's readImage and accelerate-io's fromRepa. Is there another way to do this?
09:07:08 <plakband> repa-devil is actually deprecated for friday, but friday can't produce repa arrays
09:07:27 <EvanR> theres juicypixels-repa
09:09:16 <plakband> I'll give that a try, thanks
09:10:34 <ertes> plakband: if you find a way to go from Ptr or ForeignPtr directly to accelerate, you can avoid the repa roundtrip and use unsafeWith from the Data.Vector.Storable interface with JuicyPixels
09:10:45 <ertes> plakband: JuicyPixels gives you a storable Vector of pixels
09:15:22 <plakband> ertes: That's a good idea, I can probably just port JuicyPixels-repa to accelerate
09:16:12 <Athas> plakband: what are you using accelerate for?
09:18:10 <plakband> Athas: a convolutional neural network
09:19:09 <Athas> Cool!
09:21:17 <plakband> Yeah, it has a lot of tools that make it surprisingly easy :)
09:21:20 <plakband> Why do you ask?
09:30:27 <NickHu> Can someone help me understand why essentially surjective fully faithful (equivalence) functors preserve monomorphism?
09:30:49 <Athas> plakband: I'm just curious about real-world use cases for functional high-performance computing.
09:31:17 <Athas> plakband: I got the impression that neural networks are mostly linear algebra operations.  Is that wrong?
09:31:46 <ski> NickHu : perhaps you could also try asking in ##categorytheory
09:35:22 <ski> NickHu : .. there's also ##math, of course :)
09:35:30 <NickHu> Mm, thanks
09:38:08 * hackagebot ViennaRNAParser 1.3.1 - Libary for parsing ViennaRNA package output  https://hackage.haskell.org/package/ViennaRNAParser-1.3.1 (FlorianEggenhofer)
09:39:44 <plakband> Athas: That's mostly true, you can definitely build sophisticated networks using only matrix multiplications.
09:41:20 <Athas> plakband: right, and what I've been wondering is whether language approaches (like Accelerate) can compete with hand-written linear algebra primitives, if those primitives are all you need.
09:41:38 <Athas> (The implication being that NVIDIA and Intel have already written the primitives for you.)
09:42:30 <plakband> Athas: NVBLAS is somewhat faster than accelerate, but only by a constant factor I think
09:42:49 <plakband> Athas: I'm not sure if it offers stencils, though
09:43:01 <plakband> Athas: Stencils make convolutions really easy, which are essential for a convolutional network
09:43:04 <Athas> I'd be surprised if it did.  Stencils are tricky to do well with a library.
09:43:57 <Athas> plakband: do you have a rough estimate for the size of that constant factor?
09:47:01 <plakband> Athas: I read somehwere that it was around 1.5 for large matrix multiplications
09:47:17 <plakband> But I have never tested it myself
09:48:40 <Athas> plakband: is this with the matrix multiplication defined in Accelerate itself, or with Accelerate just wrapping some library?
09:48:49 <polo> Hi, I'm new to haskell. Please can someone take a look at my question and solution that I did? http://lpaste.net/294377
09:50:19 <kadoban> polo: You can't pattern match on a function like that. You should use Nil and Cons in your patterns
09:50:27 <ski> polo : you can't use an arbitrary function `makeList' in a pattern, only data constructors (both "constants" and functions)
09:51:37 <polo> kadoban: can you mention which line?
09:51:53 <ski> line `34'
09:52:11 <pavonia> polo: Also note that you can't use [] and (:) in your function because that are constructors for ordinary Haskell lists, but you are only working on the new List type in that function
09:52:50 <ski> pavonia : but the intention was that `removeItem :: Eq a => a -> [a] -> [a]'
09:53:13 <pavonia> Oh, these are two functions
09:53:49 <polo> I'm supposed to remove item recursively from makeList [x,y,z] 
09:53:54 <ski> (the idea was to run `makeList' "backwards" for the input of type `List a', to get something of type `[a]', hand that off to `removeItem', getting back a `[a]', then using `makeList' "forwards" to get a final `List a')
09:53:59 <fnurglewitz> pavonia: you can always hide prelude and reuse [] and (:), right?
09:54:11 <ski> (.. and if this was Mercury (or Prolog), then that approach would have worked)
09:54:23 <pavonia> fnurglewitz: I don't think you can use this syntax in custom types
09:54:41 <ski> but in Haskell, you can't run arbitrary functions backwards
09:55:07 <kadoban> polo: I think you have the right idea, basically, but makeList can't be pattern matched. Also you're never testing if anything is equal to x or anything.
09:55:18 <polo> the expected output is :removeList 5 (makeList [3,4,5,6,7,5,5,5]) ->  Cons 3 (Cons 4 (Cons 6 (Cons 7 (Cons 5 (Cons 5 (Cons 5 Nil))))))
09:55:35 <ski> kadoban : they did test .. in `removeItem'
09:55:52 <ertes> (i found some things about the Curry language quite compelling…  it's haskell extended with prolog/mercury-like semantics)
09:55:55 <ski> (there's also another bug in the code)
09:56:06 <kadoban> Oh oh I see, that's two linked functions. I thought it was supposed to be separate.
09:56:08 <ski> ertes : yes. also see Escher
09:56:16 <ertes> (it's not quite "extended haskell", but it borrows a lot from it)
09:56:35 * ski doesn't recall Curry or Escher having modes, though
09:57:15 <pavonia> polo: What is the type of the removeList function?
09:57:19 <ertes> what are modes?
09:58:11 <ski> declarations of a "mode of use" of a predicate (or function), where some arguments are passed as inputs, and in some we expect to get outputs back (assuming there's any solution at all)
09:59:09 <ski> think something like `in' and `out' declarations in Pascal and Ada, except that you can overload your procedures on different `in'/`out' patterns, and you also get a guarantee that all the different overloads share a single common declarative (logical) semantics
09:59:13 <jedai> polo: In fact makeList has nothing to do with your problem, it's just there to allows you to build List easily
09:59:16 <polo> pavonia: removeList x (makeList [x..y]) = makeList [..y]  and makeList has the following output:makeList [3,4,2] = Cons 3 (Cons 4 (Cons 2 Nil))
09:59:27 <ertes> ski: you mean like in prolog?
09:59:39 <ertes> take(N, Xs, Ys).
09:59:48 <ski> also associated with such a mode would be a determinism, which is an abstract interpretation of how many solutions that particular mode of the predicate/function may have
10:00:22 <pavonia> polo: No, I'm asking for the type of the function. It helps for defining it to make yourself clear about the type first
10:00:23 <ski> ertes : yes, for append/3 (`append(Xs,Ys,XsYs)' corresponding to the Haskell `xsys = xs ++ ys') you have modes :
10:00:32 <ski>   :- mode append(in,in,out) is det.
10:00:37 <ski>   :- mode append(in,in,in) is semidet.
10:00:44 <ski>   :- mode append(in,out,in) is semidet.
10:00:50 <ski>   :- mode append(out,out,in) is multi.
10:01:14 <ski> (`det' means a single solution, `semidet' means at most one solution, `multi' means at least one solution. there's also `nondet' for any number of solutions)
10:01:28 <ski> (and that's Mercury mode declarations, fyi)
10:02:08 <ski> so if you call e.g. `append(Xs,Ys,[0,1,2])' it'll compute for you all possible ways of splitting the list `[0,1,2]' into two (so there's four solutions in this case)
10:02:30 <ski> the `(in,out,in)' mode corresponds to `stripPrefix' in Haskell
10:02:55 <ski> (one nice thing about this is that you can get multiple functionality with a single definition of the predicate/function)
10:03:05 <ski> @type stripPrefix
10:03:07 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
10:03:20 <ski> (twp or three lines, in the case of append/3)
10:03:27 <ertes> ski: i see, but i thought at least the 'append' example Curry can actually express
10:03:54 <xuxu> how do you use the -hc compiler flag? do you have to compile the program first before using it?
10:03:55 <ski> probably so. but afaics, there's no static checking of modes (and determinisms)
10:04:11 <ertes> ski: ah, yeah, indeed, Curry doesn't have that
10:04:12 <xuxu> my first attempt at using it was to use ghc -hc -o foo foo.hs
10:04:31 <ongy> what's the best way to symbolize an IO action that can fail? IO (Maybe ())?
10:04:42 <ertes> that's the one beef i had with Curry's design: its inherent partiality in basically everything
10:04:47 <plakband> Athas: I
10:04:51 <ertes> ongy: IO
10:05:01 <ski> (one of the most annoying things about programming in Prolog is when you get "no"/`false' as an answer when you expected at least one solution .. and you have no idea which part of the program failed (and failures, in most cases, propagate "anonymously")
10:05:02 <ertes> ongy: it has Either SomeException built-in
10:05:12 <plakband> Athas: https://github.com/AccelerateHS/accelerate/wiki/CUDA-Benchmarks https://www.reddit.com/r/haskell/comments/2cycqn/how_does_accelerate_performance_compare_to/
10:05:20 <ski> a static mode and determinism system, like in Mercury, helps with this situation)
10:05:51 <ertes> ski: yeah, i understand now…  that's indeed a useful feature
10:05:55 <ongy> ertes: how do I use it?
10:05:55 <ski> ongy : another variant is `MaybeT IO ()'
10:06:03 <ertes> ongy: see Control.Exception
10:06:28 <ongy> so the try catching? Then IO (Maybe ()) is more convinient for my usecase
10:06:39 <ertes> ongy: most notably 'throwIO', 'catch', 'finally' and the very useful helper function 'bracket'
10:07:27 <maerwald> ongy: depends on the use case
10:07:41 <ertes> ongy: why?
10:08:15 <ertes> ongy: IO exceptions are so implicit that i sometimes i wish it would be *less* convenient =)
10:08:19 <ongy> because it actually would be simpler. The failing is a timeout. And only that (from my side, there may be underlying other fail)
10:08:44 <ertes> ongy: is that a timeout induced by concurrency or System.Timeout?
10:08:54 <ongy> I want to handle it right away though, so the exception mechanism doesn't help me. System.Timeout
10:09:16 <ertes> ongy: yeah, then using (>>= maybe _n _j) may be more convenient
10:10:02 <nshepperd1> Could even be a Bool if you don't need any maybe properties
10:10:11 <ski> ongy : if you wanted to "collate" a bunch of such potentially failing operations, before checking for failure, then i'd suggest `MaybeT IO ()', or exceptions, instead
10:11:08 <ertes> ironically Maybe () is sometimes more convenient than Bool
10:11:20 <ertes> reason: 'maybe', if only because it has a less scary type
10:11:25 <kadoban> With Bool you have to remember which one means success too
10:11:32 <ertes> bool :: r -> r -> Bool -> r  -- i find this type super-scary
10:11:37 <ongy> I have a list of servers to try, and will take the first one that doesn't time out. When none of them work, I want to tell the callsite to handle
10:11:49 <MarcelineVQ> kadoban: it's the opposite of if :>
10:12:08 * ski would expect `False' case first, because `data Bool = False | True'
10:12:28 <nshepperd1> Er
10:13:00 <nshepperd1> ertes: heh, that's true. I would never use the bool function
10:13:11 <ski> ongy : maybe `MaybeT IO ()', then, though it's perhaps not worth it. compare and see ?
10:13:29 <ertes> i think IO even has an Alternative instance
10:13:36 <nshepperd1> Unless i was *trying* to write unreadable golfed code
10:14:16 * ski always felt awkward with `Alternative IO'
10:14:26 <ertes> foldr (\s -> (connect s <|>)) (throwIO (userError "your servers all suck!"))
10:14:27 <ski> (discarding an arbitrary exception ?)
10:14:36 <ertes> ski: yeah, me, too
10:14:50 <ertes> i'd go with exception handling
10:15:32 <ertes> foldr (\s r -> connect s `catch` \(MyExceptionType _) -> r) (throwIO (userError "your servers all suck!"))
10:15:35 <ertes> something like that
10:16:59 <maerwald> ongy: can you guarantee that "Nothing" happens only when all servers _time out_?
10:17:41 <maerwald> as in: don't accidentially mix in other failures that can occur
10:18:14 <ongy> maerwald: that's the main reason I don't want to go the exception route. with IO (Maybe ()) I can do that pretty well
10:18:36 <maerwald> huh? it's basically the other way around
10:19:52 <ongy> unless the System.Timout.timeout gives me an exception in it as Nothing, I can see that I only return Nothing when all servers timed out.
10:20:30 <ongy> I guess you overestimate the complexity I am wrapping
10:21:09 <ertes> ongy: if you're going to use System.Timeout, then Maybe is really the best option, because you leave all other exception variants uncaught
10:21:13 <maerwald> I was just pointing out that with IO (Maybe ()) you need to be really sure that you don't accidentially catch more exceptions than you want and push them into "Nothing"
10:21:28 <jophish> I've not been following the discussion: Isn't there a better 'boolean' type than Maybe ()? Something like: data MyResult = MyFailure | MySuccess
10:21:48 <ertes> holger (\s more -> connect s >>= maybe more pure) (throwIO (userError "you know what this one says"))
10:21:54 <maerwald> that's the only pitfall I see with that approach
10:21:55 <ertes> huh?  how'd that happen?
10:22:02 <ertes> s/holger/foldr/
10:22:32 <ongy> I don't catch any exception with this aproach
10:22:55 <ertes> jophish: that's not really "better"…  it's just another Bool
10:23:36 <ertes> jophish: in fact using a MyResult fold would have the same problem as the Bool fold:  myResult :: r -> r -> MyResult -> r
10:23:50 <maerwald> ongy: it's not so much about catching exceptions, but expressing failures
10:25:35 <monochrom> Having two types is better if you want them uninterchangeable; is worse if you want them interchangeable.
10:26:55 <ertes> one of the main reasons i'd like to have -XDependentTypes is Dec
10:27:08 <monochrom> What is Dec?
10:27:46 <ertes> Yes :: p -> Dec p; No :: (p -> Void) -> Dec p
10:28:20 <ertes> Bool + proof/refutation
10:29:44 <ertes> that's the type i'd use basically everywhere, not necessarily with super-formal proofs, but sometimes even just with a pseudo-proof:  you can only get a value of type (Access u r), if the user 'u' has access to resource 'r'
10:30:16 <monochrom> Ah that inspires me greatly. We need a phantomized "data Bool p = False | True". Best of both worlds.
10:31:13 <ertes> ("Dec" stands for "decidable")
10:31:28 <ertes> (or perhaps even "decision")
10:31:52 <monochrom> So for example if you need uninterchangeability, you don't have to invent your own "data MyResult = MySuccess | MyFailure" and remember the names MySuccess and MyFailure. You can just do "data MyResult" and use "Bool MyResult".
10:33:33 <ertes> yeah, that works as a safer Bool, as long as you don't need value-level information
10:35:14 <EvanR> Dec is pretty hardcore, not only do you need to give the evidence for Yes, but evidence against it for NO
10:35:53 <ertes> EvanR: if you don't need evidence for No, you usually don't need something like Dec altogether…  just take an argument of type (Access u r)
10:35:59 <EvanR> a lot of Bool situations probably end up not being so dichotomous afterall
10:36:59 <monochrom> That is pretty tame compared to Integer for which there are infinitely many possbilities, and for each possibility you have to give proof too.
10:36:59 <EvanR> and when it is, i found it hard to actually get this no anti-evidence
10:37:05 <ertes> delete :: (r :: Resource) -> WriteAccess u r -> IO ()
10:37:35 <ski> EvanR : or returning a `Maybe (Access u r)' ..
10:37:45 <EvanR> the equivalent for integer is, evidence for each integer, and for each integer an infinite number of proofs against
10:38:15 <ertes> constructing a refutation is challenging, because (-> Void) is a bit of a brain-teaser, but once you get used to how refutations work, it's actually not much more difficult than the proof
10:38:50 <EvanR> ive been actually trying this stuff, and yes, its more difficult ;)
10:39:05 <EvanR> partially because we dont actually have sane math to talk about most stuff in computers
10:39:11 <ertes> EvanR: maybe i haven't hit such a case yet (in agda though) =)
10:39:31 <ertes> EvanR: maybe also because i tend not to use 'with' very much, so i'm used to the functional style of proofs
10:39:54 <EvanR> its not even the dependent types i think, the issue is the nature of the problems
10:40:49 <ertes> but honestly i'm not even talking about any rigorous mathematical proofs, but just some business logic proofs that boil down to hiding constructors and making only certain APIs be able to construct them
10:41:08 <EvanR> does not having an access record means "does not have access" or does having "does not have access record" mean that, and if so, what does the other thing mean
10:41:25 <EvanR> "does not have access" record
10:41:29 <ertes> login :: u -> Password -> IO (Session u)  -- like this
10:41:51 <ertes> EvanR: a "does not have access" proof doesn't sound very useful =)
10:42:00 <EvanR> its required for Dec
10:42:15 <EvanR> in real life ive been confused by what missing records means
10:42:22 <Tuplanolla> Only a functional programmer would make writing code more difficult in a quest to make less mistakes...
10:42:30 <ski> ertes : "hiding constructors and making only certain APIs be able to construct them" -- so ADTs for factor/quotient ior subtypes ?
10:43:10 <ski> Tuplanolla : well, there's some syntactic salt in Mercury as well, which comes from the logic programming side ..
10:43:40 <EvanR> ertes: seems like, if you did a switch, and one case was "yep, has access" and the other case was "uh, dunno if they access, maybe they do" then you have a correctness problem looming
10:43:45 <ertes> EvanR: yeah, i can see a few use cases like filtering users by whether they have access…  i wrote a 'filter' function a few years ago that could do something like that:  http://lpaste.net/109388
10:44:16 <EvanR> because someone will say wtf why cant i get in, even though i have access
10:44:36 <ertes> ski: hmm?  i don't think so…  they rather act as tokens, and are usually just singleton types (except that they depend on values)
10:44:45 <EvanR> but i do like where you seem to be going with, "lightweight" sanity in your types
10:45:00 <ertes> ski: or which notion of "quotient" do you mean?  i'm thinking of equivalence relations
10:45:52 <ertes> EvanR: yeah, indeed…  require a refutation to actually deny access, and make it a type error not to give either a proof or a refutation
10:45:57 <ertes> that's actually not a bad idea
10:46:40 <ertes> Tuplanolla: honestly i strongly believe that the resulting code would only be *slightly* more expensive to write
10:47:39 <ertes> Tuplanolla: in fact it may even be *easier* to write:  you no longer need run-time checks in all of your APIs, but instead all you do is require a proof of access as an argument (that you just ignore)
10:47:41 <EvanR> currently, you need scientific notation to show how much more expensive it is to write
10:47:47 <xuxu> hGetContents has type Handle -> IO String. i set a breakpoint directly after this link: cc <- hGetContents -- and :t c tells me that c is of type String. why is that?
10:47:53 <EvanR> just going on general programmer skill available
10:47:58 <Tuplanolla> It still seemingly goes against common sense, which is nice.
10:48:48 <EvanR> xuxu: <- tends to do that, you can understand it by going to the desugaring procedure for <-
10:49:23 <EvanR> do{ c <- hGetContents; _ } is hGetContents >>= \c -> _
10:49:30 <xuxu> i am looking into (>>=) now
10:49:30 <EvanR> and >>= is
10:49:32 <EvanR> :t (>>=)
10:49:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:49:39 <EvanR> m a outside, a inside
10:50:26 <xuxu> that's great to know! i don't quite understand why that works
10:50:27 <EvanR> so i guess your breakpoint is "inside"
10:50:32 <xuxu> i'll think on it a i suppose
10:50:38 <xuxu> s/a//
10:51:18 <ertes> xuxu: a way to think of it without desugaring is that "<-" gives *results* names
10:51:37 <ertes> hGetContents h :: IO String  -- an action that produces a String on execution
10:51:55 <ertes> x <- hGetContents h  -- now the result has the name 'x'
10:52:50 <ertes> (oh, and you were actually missing the handle argument above)
10:53:55 <EvanR> i recently was converted to lazyI/O-is-not-evil-ism
10:54:04 <ski> ertes : "which notion of \"quotient\" do you mean?" -- the usual one ? as in set quotients, factor/quotient groups/rings ?
10:54:36 <xuxu> thank you EvanR and ertes
10:54:46 <xuxu> i will dig into the source code and think about it
10:54:58 <ski> ertes : i was asking whether by "hiding ..." you had subtyping ior factor types, via ADTs, in mind, or possibly something else ? should i infer that it's the latter ?
10:56:04 <ski> xuxu : `<-' "executes" an action. in `result <- action', if `action :: M T', with `M' a monad (e.g. `IO'), then `result :: T'
10:56:10 <ertes> ski: actually by hiding i meant: "not exporting" =)
10:56:43 <ski> ertes : ditto :)
10:56:47 <xuxu> actually, where could i find the source for <-
10:57:07 <xuxu> or should i be looking at Control.Monad for >>=
10:57:19 <kadoban> xuxu: <- is sugar for (>>=), so yeah that second one
10:57:24 <xuxu> ski: thanks again
10:57:29 <xuxu> thanks kadoban 
10:57:38 <ertes> ski: login :: u -> Password -> IO (Session u)  -- returns a session witness or throws an exception…  functions can now take the witness as proof that the user is in fact logged in…  (Session u) is a singleton type for all 'u'
10:57:48 <xuxu> er, s/thanks again/ thanks for the extra info 
10:57:48 <ski> Tuplanolla : in Mercury, you can have impure predicates (and functions), but you have to explicitly declare them as such, and every call to such a predicate/function has to be prefixed by `impure' (and obviously it's contagious)
10:57:59 <kadoban> {x <- mx; stuff}    desugars into essentially   mx >>= \x -> stuff
10:58:40 <ski> ertes : ok, i see
10:59:04 <ab9rf> ski: what does declaring a predicate as "impure" do?
10:59:37 <ertes> ski: i'm actually a bit torn about the "hiding" part:  i'd prefer to be able to pattern-match on the witness, similar to how i'd pattern-match on Refl for equalities, but i guess as long as there is no type refinement, hiding is fine
11:00:04 <ski> ab9rf : it allows you to call a predicate/function that's declared `impure' in the definition
11:01:04 <EvanR> ski: does it let you execute IO ?
11:01:16 <ab9rf> ski: that didn't enlighten me, but i'll let it drop as it's off-topic and i can go research it myself :)
11:01:26 <ski> ab9rf : typically, `impure' is intended for FFI stuff, where the idea is that one will then usually write a pure wrapper (most commonly in terms of the `io' state) around those, in Mercury (as opposed to wrapping in the other, usually lower-level, language)
11:02:20 <ski> ab9rf : there's also some language extensions/pragmas which introduce impure stuff (having a global mutable store, for a constraint solver, e.g.)
11:02:33 <ski> EvanR : yes
11:02:48 <ski> ertes : i see
11:03:31 <ab9rf> ski: i am not udnerstanding how this is useful or desirable, but then again i don't understand the design goals of mercury so my lack of understanding is almost certainly grounded in ignorance rather than reasoned judgment :)
11:04:25 <ski> ab9rf : you can sortof compare it to how `unsafePerformIO' is used with FFI in Haskell
11:05:58 <ab9rf> ski: it reminds me also of some aspects of how rust uses types to guarantee memory safety
11:06:51 <ab9rf> i've spent perhaps 20 minutes in my life looking at mercury, though, and i can't say i understand its design
11:07:06 <ski> (the design goals of Mercury are to be a modern logic (and functional) programming language, suitable for programming-in-the-large (so with reasonable efficiency, support for module systems, and static checking of types, modes (and insts), and determinisms. having algebraic datatypes, type classes, parametric polymorphism, existentials, FFI ..))
11:08:35 * ski has pondered a bit on how to borrow the idea of modes for use in a systems programming language
11:08:39 <ab9rf> ski: haven't worked with a logic programming language in over two decades. i wrote a few progarms in prolog back in the late 80s, but was never good at it.
11:10:15 <ski> (oh, and when Mercury was conceived, Zoltan Somogyi was also quite interested in parallel (and declarative concurrent) implementations .. however, that hasn't happened as much, yet, though Boney (in #mercury) did a thesis on that)
11:11:58 <ab9rf> you j ust made me think of the guy who introduced me to the concept of unification
11:12:01 <ski> (declarative concurrency in the sense of CTM (so as in Oz), where you have dataflow/logic variables to communicate and synchronize between different threads of execution. this can't express nondeterministic joining of multiple channels, though, but is still an interesting subclass of concurrency in general)
11:12:02 <ab9rf> bill burdick
11:12:06 <ski> @where CTM
11:12:07 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
11:12:25 <ab9rf> i just found him on google; he works for a game company in toronto now
11:12:52 <ski> is he known for having worked on some interesting system, or writing some interesting paper, or something ?
11:13:36 <ski> (s/as in Oz/as in Oz \(and to some extent also in AliceML, iirc\)/)
11:14:24 <ski> (btw, cf. the `Par' monad in concurrent Haskell)
11:14:26 <monochrom> oh w00t toronto. I can stalk him. :)
11:14:33 <ab9rf> sorry, i misread
11:14:51 <ab9rf> they're in california somewhere, it was just that they announced some game at a toronto game expo
11:14:53 <monochrom> oh, different bill burdick
11:15:03 <monochrom> ah, I see
11:15:23 <ab9rf> there are a lot of bill burdicks
11:15:43 <monochrom> OK, so next time I should go to future game expos in Toronto to find new victims to stalk
11:15:46 <ab9rf> hehe
11:16:40 * ski . o O ( <https://en.wikipedia.org/wiki/Stalk_(sheaf)> )
11:16:43 <monochrom> "oh hi, great game you demoed. did you publish something on logic programming too?"
11:18:13 * hackagebot yi 0.13.3 - Yi editor  https://hackage.haskell.org/package/yi-0.13.3 (DmitryIvanov)
11:18:15 * hackagebot yi-core 0.13.3 - Yi editor core library  https://hackage.haskell.org/package/yi-core-0.13.3 (DmitryIvanov)
11:18:17 * hackagebot yi-frontend-pango 0.13.3 - Pango frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-pango-0.13.3 (DmitryIvanov)
11:18:19 * hackagebot yi-frontend-vty 0.13.3 - Vty frontend for Yi editor  https://hackage.haskell.org/package/yi-frontend-vty-0.13.3 (DmitryIvanov)
11:18:21 * hackagebot yi-fuzzy-open 0.13.3 - Fuzzy open plugin for yi  https://hackage.haskell.org/package/yi-fuzzy-open-0.13.3 (DmitryIvanov)
11:18:49 <EvanR> [Maybe a] -> [a] is called catMaybes, whats a general f (Maybe a) -> f a called?
11:19:31 <EvanR> whats a good name 
11:21:39 <ski> how about .. `catMaybes' ?
11:21:40 <Tuplanolla> How about `catMaybes`?
11:21:45 * ski grins
11:22:25 <ski> (or perhaps with "strip" ?)
11:22:50 <Tuplanolla> I guess you could go the `fmap` route and call it `fcatMaybes` or `fatMaybes`.
11:23:03 <ongy> fatMaybes sounds weird
11:23:03 <EvanR> f isnt any functor though...
11:23:11 * ski . o O ( `slimMaybes'/`trimMaybes' )
11:23:15 <EvanR> catMaybes just doesnt make sense to me
11:23:22 <EvanR> yeah, slim, trim, strip, ok
11:23:23 * hackagebot yi-ireader 0.13.3 - Yi editor incremental reader  https://hackage.haskell.org/package/yi-ireader-0.13.3 (DmitryIvanov)
11:23:25 * hackagebot yi-keymap-cua 0.13.3 - Cua keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-cua-0.13.3 (DmitryIvanov)
11:23:27 * hackagebot yi-keymap-emacs 0.13.3 - Emacs keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-emacs-0.13.3 (DmitryIvanov)
11:23:29 * hackagebot yi-keymap-vim 0.13.3 - Vim keymap for Yi editor  https://hackage.haskell.org/package/yi-keymap-vim-0.13.3 (DmitryIvanov)
11:23:31 * hackagebot yi-language 0.13.3 - Collection of language-related Yi libraries.  https://hackage.haskell.org/package/yi-language-0.13.3 (DmitryIvanov)
11:23:43 <ski> ("slim" sounded more reasonable to me than "fat")
11:24:01 <EvanR> fatMaybes introduces extra Nothings
11:24:23 * ski nods solemnly
11:24:41 <ertes> EvanR: reflex has a class called FunctorMaybe with:  fmapMaybe :: (a -> Maybe b) -> f a -> f b
11:24:51 <ertes> EvanR: fmapMaybe id
11:24:54 <EvanR> interesting
11:25:10 <ertes> might be worth splitting it off into a separate package
11:26:05 <EvanR> so its just a combination of what im talking about fmap
11:26:08 <EvanR> for performance
11:26:19 <EvanR> with fmap*
11:26:23 <jmcarthur> I'm curious what this function (f (Maybe a) -> f a) does.
11:26:32 <EvanR> "depends on f"
11:26:44 <glguy> Similar to the witherable package except that Witherable is TraversableMaybe
11:26:46 <ongy> on what would you do the fatMaybes? Foldable?
11:26:54 <jmcarthur> Sure, but is it in its own type class or based on Foldable or what?
11:27:12 <EvanR> i am just trying to name the operation for my particular f
11:27:15 <jmcarthur> Foldable+Alternative or something, I guess it would be
11:27:20 <ertes> jmcarthur: it's completely unspecified
11:27:30 <jmcarthur> I don't know how to name unspecified things.
11:27:44 <ertes> but a useful specification could certainly be written
11:27:49 <EvanR> which is f a = A -> B -> [a], and its defined with catMaybes
11:28:33 * hackagebot yi-misc-modes 0.13.3 - Yi editor miscellaneous modes  https://hackage.haskell.org/package/yi-misc-modes-0.13.3 (DmitryIvanov)
11:28:35 * hackagebot yi-mode-haskell 0.13.3 - Yi editor haskell mode  https://hackage.haskell.org/package/yi-mode-haskell-0.13.3 (DmitryIvanov)
11:28:36 <jmcarthur> so it's defined as (fmap . fmap) catMaybes?
11:28:37 * hackagebot yi-mode-javascript 0.13.3 - Yi editor javascript mode  https://hackage.haskell.org/package/yi-mode-javascript-0.13.3 (DmitryIvanov)
11:28:39 * hackagebot yi-snippet 0.13.3 - Snippet support for yi  https://hackage.haskell.org/package/yi-snippet-0.13.3 (DmitryIvanov)
11:28:40 <EvanR> yeah
11:28:41 * hackagebot zlib 0.6.1.2 - Compression and decompression in the gzip and zlib formats  https://hackage.haskell.org/package/zlib-0.6.1.2 (HerbertValerioRiedel)
11:29:27 <ertes> sorry, i thought you were talking about FunctorMaybe
11:29:31 <ongy> EvanR: why don't you also call it catMaybes? avoiding colissions?
11:29:38 <jmcarthur> I'm tempted to say just call it catMaybes and require it to be qualified to avoid collisions.
11:29:41 <EvanR> yep
11:30:31 <EvanR> calling all your stuff the same as standard stuff, while being incompatible, and requiring an assortment of new LETTER.something everywhere is going to hurt "niceness" i think
11:30:35 <ski> .. or call it `trimMaybes' but also suppose an alias `catMaybes'
11:30:48 <ertes> i think FunctorMaybe can be more sensible with a bunch of laws like:  fmapMaybe (f <=< g) = fmapMaybe f . fmapMaybe g;  fmapMaybe pure = id
11:31:17 <EvanR> like edk carefully named everything something new in lens
11:31:33 <EvanR> otherwise the large amount of qualified things will make your lens code look terrible
11:32:38 <ertes> even with lenses i tend to leave spaces around (.), and together with syntax highlighting qualified names aren't that bad
11:32:47 <ertes> s/tend to//
11:33:38 <EvanR> X. in front of everything just doesnt make for as impressive example code
11:33:43 * hackagebot unicode-transforms 0.2.0 - Unicode normalization  https://hackage.haskell.org/package/unicode-transforms-0.2.0 (harendra)
11:34:32 <Tuplanolla> It's nice to be able to import pretty much the entire `base` without having to worry about qualifications.
11:34:39 <ertes> the average OO programmer won't find a superficial look at lens code that impressive anyway =)
11:34:58 <EvanR> also each lib exporting a type and expecting to also be qualified for operations amounts to 2 import lines
11:35:12 <ertes> Tuplanolla: yeah, i agree…  like Control.Category, Data.Semigroup, …
11:36:11 <monochrom> on that note, I think I have invented a few coding style for imports.
11:36:46 <monochrom> import Data.ByteString (ByteString); import qualified Data.ByteString as B   -- one single line
11:37:01 <EvanR> (otoh, literally everything in elixir is expected to be qualified, and not with X. with MyLibrary.)
11:37:13 <monochrom> s/a few coding style/a new coding style/
11:37:24 <EvanR> nice trick
11:38:16 <ertes> "dynamically typed" -close tab-
11:40:22 <ski> ertes : from what i hear, Erlang is nicer
11:40:56 <monochrom> Erlang got my "'dynamically type' -close tab-" 15 years ago :)
11:41:21 <monochrom> But on a light note:
11:41:23 <EvanR> i am seeing the utility of this fmapMaybe thing
11:41:27 <monochrom> @quote monochrom erlang
11:41:27 <lambdabot> monochrom says: shae ericsson is shae erisson's evil twin who prefers erlang to haskell :)
11:42:39 <ski> (apparently, the creators of Elixir wanted `=' to (seem to) behave more like assignment, so they decided to allow arbitrary rebinding of variables in a conjunction .. that in itself is a step backwards, imho)
11:42:51 <ertes> ouch
11:42:56 <monochrom> but I do marvel at Erlang's hot swapping and how dynamic typing helps this.
11:43:32 <ertes> monochrom: you can have that *in principle* with haskell and Typeable, too
11:43:41 <monochrom> You look at Haskell and it took dons a PhD thesis to hot swap and then bit-rot since then
11:44:10 <ertes> monochrom: i have a solution for hot-swapping in GHCi to at least speed up development
11:44:14 <ertes> @package rapid
11:44:14 <lambdabot> http://hackage.haskell.org/package/rapid
11:44:27 <ertes> but you cannot use it for production hot-swapping
11:44:58 <EvanR> seems like production hot swapping requires its own separate type system, to make sure your hotswap is valid
11:45:18 <novak`> What do you use to reach symbols documentation in Emacs? My cursor is at elem and I want to see what that function does e.g
11:45:21 <EvanR> and dont try hot swapping that
11:45:35 <ertes> Typeable is fine for the most part, but it's not entirely safe (you need something like a type fingerprint similar to how StaticPtr fingerprints work)
11:45:48 <EvanR> how does typeable help?
11:46:54 <ertes> EvanR: the safety of hot-swapping is bound to type consistency:  you need to make sure that the new code has the same type
11:47:14 <ertes> then a failure is a regular bug in your code, and not a segfault
11:47:25 <ertes> however, types may change themselves, at which point that safety is lost
11:47:27 <EvanR> once you determine its the same type, then what
11:47:37 <ertes> then you swap it out
11:47:39 <EvanR> youre stuck converting through typeable forever?
11:47:49 <ertes> only during swaps
11:48:10 <ertes> you can only swap certain things sensibly like threads and mutable references
11:48:13 <EvanR> typeable comparisons survive restarts?
11:48:26 <EvanR> i.e. type reps are the same among all runtimes
11:48:33 <ertes> they don't fully, because the types are not fingerprinted
11:48:47 <EvanR> sounds insane
11:49:07 <ertes> that's what i mean:  you can't do it safely right now, but you could do it in principle, and the machinery to do it is there for the most part
11:49:14 <ertes> someone just has to implement it in GHC
11:50:45 <nshepperd> if you hot swap a function in GHC does that mean it can't be inlined?
11:51:24 <ab9rf> hotswapping through a change in types would be hard
11:51:27 <ertes> nshepperd: questions like that are the reason why you can't really hot-swap functions, but you can hot-swap IORefs, MVars, threads, etc.
11:51:52 <nshepperd> oic
11:52:31 <ab9rf> ghc's whole compilation environment militates toward monolithiticy
11:53:10 <ertes> i think if you know that a component might be replaced at run-time, you should perhaps design it as a separate process
11:53:28 <nshepperd> that doesn't sound so great
11:53:37 <ab9rf> at least engineer it to pass through a deeply constrained interface that can be made pluggable.
11:54:07 <EvanR> dynamically loaded plugin
11:54:19 <nshepperd> but I think in that case you could use like CloudHaskell's static pointers, and have a thread just waiting on some port for a new value for some MVar and just swap it out
11:54:20 <ertes> yeah, but it's not as bad as it sounds either…  you need some serialisation, because our beloved unix is stringly typed, but other than that it doesn't feel too much different from using a separate thread
11:54:38 <ertes> hopefully some day cloud haskell will make this super-easy
11:54:43 <EvanR> a separate process is a lot more work to set up without some library for it
11:55:06 <ertes> i'd suggest not using a library in that case, but a process manager like s6
11:55:34 <ertes> that yields a design like postfix'
11:55:50 <EvanR> given memory usage concerns, i wonder what separate processes would cost in that respect
11:55:57 <EvanR> i know the OS can share but
11:56:02 <ertes> one advantage of the separate process design is that you can use more fine-grained OS-level access controls
11:56:08 <ab9rf> passing thunks across a pluggability boundary, for example
11:56:38 <EvanR> ab9rf: so you might end up doing serialize-deserialize anyway, even in the same process
11:56:44 <EvanR> >_<
11:56:46 <ertes> EvanR: well, you're not creating such a process per some resource (like per client)…  you still use haskell threads within the process, so it's more like a modularity thing
11:57:00 <nshepperd> can you make a pure value that doesn't update its thunk when evaluated
11:57:01 <ertes> and there is the extra cost of serialisation
11:57:06 <EvanR> ertes: no, but 5 ruby "worker" processes can take 5x memory
11:57:13 <ab9rf> EvanR: well, it's a given that you should expect some overhead in order to demand flexibility even if you do not use it
11:57:45 <EvanR> no!
11:57:46 <nshepperd> then you could do like {-# NOINLINE foo #-}  foo :: Foo -> Bar -> Baz   foo = unsafePerformIO (readMVar fooUpdateable)
11:57:48 <EvanR> no compromises
11:57:53 <ab9rf> heh
11:57:53 <ertes> nshepperd: you can use the function trick:  x :: () -> A
11:58:04 <nshepperd> oh yeah
11:58:12 <EvanR> in haskell we want cake and to eat it too
11:58:28 <ertes> nshepperd: but honestly i'd prefer to read from the IORef every time i use it =)
11:58:44 <ertes> even better: don't hot-swap functions
11:58:53 <nshepperd> so then you could just have any old normal haskell thread waiting for a new hot swap and modifyMVaring it
11:58:54 <EvanR> isnt that kind of one of the whole points?
11:59:12 <EvanR> swap out a different function implementation, fix broken code, etc
11:59:18 <ertes> nshepperd: and hoping that none of the crazy GHC optimisations kick in =)
11:59:22 <nshepperd> yeah I thought the point of erlang was that you could hot swap everything?
11:59:44 <ab9rf> erlang has many points, but that is somewhat one of them
12:00:11 <ertes> nshepperd: after you disabled inlining you might find yourself CSEing, and if not that, you might find that your function is actually shared by virtue of a subtle invisible lambda abstraction:  map (f ())  -- shared
12:00:54 <ertes> map (\x -> f () x)  -- not shared
12:01:18 <nshepperd> ertes: yes that's why I asked, if you can turn off the updating in some more sensible way
12:01:42 <nshepperd> assuming that wouldn't blow up the STG machine entirely in some way
12:01:53 <nshepperd> but I think STG allows non-updating thunks?
12:03:06 <koz_> Could someone help me with this monad transformer question? http://lpaste.net/294611
12:03:14 <nshepperd> i dunno, I guess the most you can hope for is that each independent time you 'name' f in the source it will be read again, which is fine
12:03:16 <ertes> nshepperd: maybe, but…  no…  don't do that…  better structure your application in such a way that components are mutable references, threads or other concurrency things with an identity
12:03:44 <nshepperd> you don't expect a hot swap to occur immediately anyway
12:04:02 <ertes> nshepperd: (\f -> …)  -- god knows how long that f stays in use
12:04:03 <nshepperd> since the old function might actually be in the middle of running
12:04:16 <ertes> nshepperd: and that f might be such a hot-swappable function
12:04:40 <Tazmain> Hi all, is there any good IDE's or syntax highlighters for haskell ?
12:05:08 <ertes> Tazmain: emacs and vim are the most popular, but most popular editors will do at least syntax highlighting
12:05:43 <ertes> Tazmain: emacs and vim probably give you the most complete "IDE" experience with built-in interpreter, type-check-as-you-type, symbol completion and lookup, etc.
12:05:43 <Tazmain> so haskell is old school, or low ui school :D 
12:06:27 <Tazmain> wait is there even a GUI for haskell ?
12:07:13 <ertes> Tazmain: it's not that "low UI"…  i use emacs with haskell-interactive-mode, which does pretty much everything visual studio does for C#, except on-the-fly documentation (which would be nice to have)
12:07:29 <liste> what does "GUI for Haskell" mean?
12:07:34 <liste> there's Haskell for Mac
12:07:40 <EvanR> ertes: except mutable indirection containers with identity is not very nice to code in haskell
12:07:52 <hpc> eclipse just sets particularly weird expectations
12:07:55 <liste> and Haskell has bindings for multiple GUI toolkits: WxWidgets, GTK, Qt..
12:08:02 <Tazmain> as in a GUI library to write GUI applications with haskell 
12:08:46 <Tazmain> wait haskell can bind to Qt, how does that work 
12:08:52 <ertes> Tazmain: haskell has bindings to X11, Win32 and probably whatever OSX uses, and it also has bindings to the most popular platform-independent libraries like GTK+, wx and even Qt
12:08:55 <EvanR> and itll be even less nice if the only reason they are there is for a function that should be taken care of by the system transparently (sort of like how in javascript, they might say "better to just not use blocking threads, explicitly structure everything around callbacks")
12:09:24 <nshepperd> "don't hot swap functions" isn't a very satisfying answer to "how can we implement erlang-style hot swapping"
12:09:31 <cpdean> ertes: hey it took me a while but i finally made a hangman game
12:09:33 <liste> Tazmain: there's also https://atom.io/packages/ide-haskell for Atom fans, and it seems pretty popular
12:09:49 <Tazmain> liste, no thanks, tried that editor came to dislike it. 
12:10:01 <ertes> EvanR: it's nice enough, considering that your "component boundaries" should probably be very sharp anyway, if you want to support hot-swapping
12:10:05 * liste isn't a fan either
12:10:08 <ertes> cpdean: nice =)
12:10:21 <EvanR> ertes: very sharp doesnt need to mean we have to write a bunch more gross code
12:10:33 <cpdean> ertes: i can't for the life of me figure out how to pump a random number into it so it can pick from a list of words but eh
12:11:03 <Tazmain> liste, little off topic but that editor locks the folder it was started from. annoyed the day lights out of me, so I don't use it 
12:11:06 <ertes> nshepperd: yeah, perhaps, but that's the price to pay for haskell's semantics
12:11:29 <EvanR> no! no compromise
12:11:39 <EvanR> non zero sum game
12:11:52 <ertes> nshepperd: but you might consider IORef swapping the kind of swapping erlang does, except that IORefs pretend to be just pure values =)
12:11:55 <nshepperd> and actually I'm fine with 'map foo' holding on to the old version of 'foo' until the end of the map, if you hot swap it
12:12:05 <cpdean> ertes: https://gist.github.com/cpdean/bcfa787ad2cc78adf1ca89c01f0d0b5d
12:12:11 <ertes> nshepperd: hot-swappable functions are inherently impure!
12:12:32 <nshepperd> well, yeah, that's the point
12:12:45 <ertes> if you ask for weird semantics, you get weird semantics =)
12:13:26 <nshepperd> as long as I don't have to get weird syntax as well. or shoehorning the whole program into IO
12:14:03 <byorgey> koz_: you can't write that function
12:14:12 <EvanR> you could define hotswapping as transitively, eventually, hotswapping the entire program
12:14:20 <EvanR> even if an optimization makes that not necessary
12:14:38 <byorgey> koz_: in order to write runEVT you need to pick a concrete implmentation of the monad stack, including a concrete order for the layers
12:14:43 <ertes> cpdean: nice!  now make it so that it actually allows me to win =)
12:15:06 <koz_> byorgey: Ah, I see. Well, I figured I was missing something - turns out that was it.
12:15:16 <byorgey> koz_: in other words there is no way to write runEVT which is polymorphic over the monad, because e.g. the order of the layers matters for how the effects will be handled
12:15:18 <ertes> cpdean: i just played it, and you were too evil: i couldn't win =P
12:15:27 <koz_> So basically just newtype wrap the appropriate stack of WhateverTs?
12:15:55 <byorgey> koz_: sure
12:16:04 <koz_> byorgey: Thanks - I shall do that.
12:16:43 <byorgey> koz_: I mean, what you have so far is fine.  But your runEVT will need to have a type like   Int -> ConcreteEVTMonad (V.Vector a) -> Either Text ...
12:16:44 <ertes> nshepperd: well, consider that you have the whole program in IO in erlang…  but since IO is explicit in haskell it makes you design your application in a way that makes swapping reasonable
12:17:21 <ertes> nshepperd: sometimes hot-swapping a function may be the sensible thing to do, but in that case i'd really like it to be in an IORef
12:17:23 <koz_> byorgey: Well, I had the feeling I needed something like that anyway, so I'll just write it.
12:17:30 <byorgey> ok, sounds good
12:17:50 <cpdean> ertes: wait how should it change?
12:20:17 <ertes> cpdean: i give it the letters of "word", but it doesn't actually "win"
12:20:41 <ertes> it just lets me keep guessing, until i run out of guesses, even though the word is fully revealed
12:20:50 <cpdean> ertes: ah, gotcha
12:21:51 <cpdean> ertes: the rules i was going for is that you can use up a guess getting the word or fishing for a hint. the game terminates when you guess the full word
12:22:23 <ertes> oh
12:22:53 <ertes> now i get it
12:23:06 <ertes> then yeah, it works and everything is fine =)
12:23:11 <cpdean> hah
12:23:46 <ertes> cpdean: now please write type signatures for all top-level definitions
12:23:55 <cpdean> so something i realized i do not understand, is how to read the related documentation around the `random` package to know how to make this thing pick a different word each time
12:23:56 <ertes> it helps readability a lot, so it's a good habit to pick up
12:26:20 <ertes> have you figured out how to generate random numbers?
12:27:32 <ab9rf> heh
12:30:41 <ab9rf> doesn't that depend on which randomizer you're using?
14:31:05 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
14:31:05 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
14:31:09 <ski> (to which i'd like to reply both yes and no. yes, in a sense. no, probably not in the sense you meant)
14:31:29 <monochrom> https://groups.google.com/forum/#!msg/comp.lang.functional/YXnfQ4vUE40/UTNrI90LUhcJ is how I mocked (and still mock) "one idea per line" which is the rationalization of "tmp2 = tmp1 * 4" and the OOP version.
14:31:41 <cpdean> i was saying more the difference between traversing software components versus an well-done fluentapi
14:31:54 <cpdean> when you have side-effects then yeah that's a whole new problem
14:32:06 <monochrom> (oh eventually I mocked loops too!)
14:32:40 <ab9rf> i read that as "flatulent api" at first
14:32:47 <EvanR> one idea per line does have the benefit of increasing the number of lines of code
14:33:25 * hackagebot EntrezHTTP 1.0.2 - Libary to interface with the NCBI Entrez REST service.  https://hackage.haskell.org/package/EntrezHTTP-1.0.2 (FlorianEggenhofer)
14:33:27 * hackagebot pandoc-citeproc 0.10.1.3 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.1.3 (JohnMacFarlane)
14:34:17 <EvanR> cpdean: maybe this could be factored into a discussion of side effects and a separate discussion about hiding implementation details that are supposed to be irrelevant
14:34:18 <monochrom> there are times when "one idea per line" makes sense. but you can do it by just adding whitespace. you do not have to add names.
14:34:22 <jmcarthur> ski: Redundant brackets aren't always bad either. Since Haskell makes it possible for library authors to control operator precedence, it might sometimes be worth it to use brackets to make your code more readable even though the library might actually make it redundant.
14:34:27 <koz_> Could someone please enlighten me what I'm missing about monad transformer use here? http://lpaste.net/296051
14:34:47 <EvanR> cpdean: because on the surface, "no dotting" sounds like anti-composition
14:35:14 <ertes> cpdean: at this point any version is ready…  but you'll have to be patient until i finish my pizza (you could gather/apply more suggestions from the channel) =)
14:35:30 <koz_> ertes: Pizza? Awesome.
14:35:33 <monochrom> in fact adding names has its problem because good names are hard but misleading names are easy
14:35:51 <ertes> yeah…  what would i do without pizza…
14:36:15 <cpdean> EvanR: yeah i'm not sure how far you could go with no dots at all, but at least if you prevent yourself from double-dotting you'll be thinking more about the interfaces between components
14:36:16 <monochrom> furthermore because of author's bias, every author is going to think that their misleading names are good names.
14:36:47 <ongy> outside of syntax, is there any difference between 'maybe f g m' and 'case m of Nothing -> f; Just x -> g $ x'?
14:37:16 <EvanR> cpdean: no double dotting? limited to one dot per line?
14:37:24 <ski> jmcarthur : yes, i sometimes use redundant brackets for emphasis. i suppose i also understand the different library issue, though i'd really prefer having a partial order of precedence
14:37:47 <EvanR> cpdean: x = o1.c1; y = x.c2... ?
14:38:26 <cpdean> EvanR: eh -- more like, impose a restriction on yourself that forces all messages sent to objects be the correct messages to have a body of software do the thing you want it to do
14:38:50 <ski> koz_ : oh, sorry. i didn't read it close enough. what do you like to do with your input `ExceptT Text (StateT StdGen Identity) (V.Vector a)' ?
14:38:51 <MarcelineVQ> ongy: they're the same like that, but you can partially apply the maybe form
14:38:55 <cpdean> if you're sending messages to the components inside a component, the interface is lacking some kind of a feature
14:39:12 <Tuplanolla> At least we're not talking about MATLAB.
14:39:27 <ertes> i was too lazy to go to the store on saturday, so i ended up using emmentaler today instead of mozarella…  i feel deitalianised…  but it's tasty anyway =)
14:39:36 <cpdean> ski: i think this is ready for what you had planned next https://gist.github.com/cpdean/bcfa787ad2cc78adf1ca89c01f0d0b5d#file-guess-hs-L4-L16
14:39:42 <Tuplanolla> Now that's a fantastic programming language.
14:39:55 <ski> ongy : no
14:39:59 <EvanR> cpdean: i think i get it now. this is the "dont access fields, access only methods" and then have a separate method for each field youd like to just expose directly
14:40:01 <ski> (though i'd omit the `$')
14:40:05 <koz_> ski: In that function, I want to use it like 'throwError', but with that monad. The alternative is to implement all the relevant mtl typeclasses for EVResult, which I figure is harder.
14:40:40 <ski> Tuplanolla : please don't remind me of it
14:40:50 <EvanR> cpdean: the assmption being that all objects involved are "software components doing a job" and not actual data
14:41:18 * ski questions "if you're sending messages to the components inside a component, the interface is lacking some kind of a feature"
14:41:34 <EvanR> one big difference between OOP and haskell is we have a lot more actual data, relative to algorithms, i think
14:41:40 <EvanR> more algorithmic information is inherent in data
14:41:42 <cpdean> EvanR: yeah if you have to traverse a structure because your algorithm needs to be doing that then OOP ideas are probably not relevant
14:41:43 <jmcarthur> ski: Agreed. Being able to say "higher precedence than this and lower precedence than this", leaving other possibilities to compiler warnings, would be great.
14:41:57 <jmcarthur> s/warning/errors/
14:42:28 <Tuplanolla> Why does `curry = @(f) (@(varargin) (@(x) @(varargin) f (x{:}, varargin{:})) (varargin));` work, but `function g = curry (f); g = @(varargin) (@(x) @(varargin) f (x{:}, varargin{:})) (varargin); end;` does not, ski?
14:42:42 <ski> cpdean : note that you have a `do' on line `7'. this means that you could possibly add another command after the (currently) single one (starting with `case')
14:43:50 <ski> koz_ : one alternative would be to ignore the input `EVResult a', and return `EvResult (E.throwE x)' .. however, somehow i doubt this is what you want to do, here
14:44:12 * monochrom is evil. leave other possibilities to compiler arbitration! And it's binding arbitration, literally. :)
14:44:13 <cpdean> ski: fixed `do` https://gist.github.com/cpdean/bcfa787ad2cc78adf1ca89c01f0d0b5d#file-guess-hs-L7
14:44:18 <ski> koz_ : i don't understand what "I want to use it like 'throwError', but with that monad" means (nor the rest of what you said)
14:44:41 * jmcarthur realized today that his long-term takeaway from learning about stream fusion is that having an isomorphism between a type that is good for inlining and a type that is good for sharing is a great thing.
14:44:56 <ski> cpdean : nonono. i wanted you to *retain* that `do' (in this case) :)
14:45:14 <cpdean> ski: lol
14:45:28 <cpdean> well it didn't break when i removed it soooo it was redundant?
14:45:35 <koz_> ski: Let me try again. I want to represent a computation which tracks some state (which happens to be RNG stuff), as well as has the potential to throw errors. The monad stack involved (which is the big thing unEVResult returns) is what I want to work with.
14:46:00 <koz_> ski: So I wrapped it up a newtype, and now, I wanna write operations for that newtype such as 'throw an error', 'get a random X' etc.
14:46:15 <koz_> Before, I was working with MTL, but then the result is impossible to work with.
14:47:03 <koz_> Let me paste what I mean.
14:47:25 <ski> cpdean : yes, but for the refactoring i had in mind, you need to keep it (or reintroduce it)
14:47:46 <EvanR> jmcarthur: type that is good for inlining?
14:48:05 <jmcarthur> EvanR: e.g. Stream
14:48:15 <EvanR> right, not sure i understand
14:48:26 * hackagebot mysql-simple 0.3.0.0 - A mid-level MySQL client library.  https://hackage.haskell.org/package/mysql-simple-0.3.0.0 (paulrouse)
14:48:43 <jmcarthur> EvanR: e.g. It is easier to write inlinable functions on Stream than on Vector.
14:48:56 <EvanR> then what is good for streaming
14:48:58 <koz_> ski: http://lpaste.net/296051 <-- I've edited in my old code which should hopefully make what I meant clear.
14:49:09 <jmcarthur> I don't understand what you are asking.
14:49:23 <ski> Tuplanolla : ho can tell ? it's superstition anyway
14:49:24 <EvanR> an isomorphism between a type that is good for "inlining" and a type that is good for streaming
14:49:30 <EvanR> so whats an example of two such types
14:49:30 <Sam_> I've been working on this problem for half of the day.Can someone help me to do it?http://lpaste.net/294377
14:49:38 <jmcarthur> I think streaming is orthogonal to this issue.
14:49:41 <Tuplanolla> I spent some time trying to figure it out, but couldn't, ski.
14:49:49 <EvanR> oh sharing
14:49:49 <glguy> koz_: It looks like your throwing function's type is just wrong
14:49:56 <jmcarthur> Stream and Vector are the canonical examples for stream fusion.
14:49:57 <koz_> glguy: What should it be?
14:50:00 <Tuplanolla> It's great for bugging colleagues though!
14:50:04 <EvanR> Vector would be the one thats good for sharing
14:50:08 <jmcarthur> Right.
14:50:24 <cpdean> ski: so what's the change you have in mind for https://gist.github.com/cpdean/bcfa787ad2cc78adf1ca89c01f0d0b5d ?
14:50:31 <EvanR> why is inlining for Vector hard?
14:50:32 <glguy> koz_: Text -> Whatever a
14:51:08 <koz_> glguy: Oh, OK. Let me try and rewrite that.
14:51:10 <ski> koz_ : i still don't get what you want `liftThrow x act' to do
14:51:18 <jmcarthur> EvanR: Well, imagine any reasonable implementation of fmap on Vectors without using Stream as an intermediate and try to fuse two fmaps.
14:51:35 <jmcarthur> EvanR: The problem is that any definition of fmap is going to need to involve recursion, making it not inlinable.
14:51:50 <jmcarthur> EvanR: But the recursion isn't really the only problem.
14:52:08 <koz_> ski: Never mind - glguy's suggestion worked, and now makes sense.
14:52:13 <jmcarthur> EvanR: The output of one fmap is going to allocate a Vector even if it's only going to be used once with a statically knowable access pattern.
14:52:15 <koz_> I keep forgetting how monadic computations work...
14:52:34 * ski thought they mentioned to koz_ one version ignoring the argument ..
14:52:57 <EvanR> jmcarthur: im thinking of an implementation where it allocates a new vector and loops through generating thunks for each element in some C code
14:53:10 <jmcarthur> How would that help with fusion?
14:53:11 <koz_> ski: You have done - but glguy's suggestion of the type jogged my memory/understanding.
14:53:19 * ski nods
14:53:35 <jmcarthur> If anything C code should make fusion (much) more difficult
14:53:36 <EvanR> well, that is inlinable
14:53:50 <EvanR> so i think the recursion was a tangent
14:53:56 <jmcarthur> And the allocation is already a problem on its own.
14:54:04 <EvanR> thats the real issue
14:54:16 <ski> cpdean : sorry, got busy a bit with several people talking to me (and vice versa)
14:54:29 <jmcarthur> I see what you are pressing on now.
14:54:37 <jmcarthur> It's not even inlinability that's the problem.
14:54:46 <ski> <ski> cpdean : now that we've "pushed" the code as far as we could, in this "direction", i'd like you to revert back to <https://gist.githubusercontent.com/cpdean/bcfa787ad2cc78adf1ca89c01f0d0b5d/raw/9d93d1e5845123f1f9c03c0c087a080df5c2f3dc/Guess.hs> (though keep the changes in `gameStatus' (also, you forgot to get rid of `head' there)), and then try to factor the two calls to `nextLevel'
14:54:52 <ski> cpdean ^ see
14:55:07 <jmcarthur> Even without inlining, avoiding the allocation can be worth it.
14:55:13 <cpdean> factor the calls to nextlevel...
14:55:18 <ski> also
14:55:19 <ski> <ski> cpdean : also, in your previous code, you could have factored the call to `nextLevel' (and then possibly inlined/folded it) .. now it'd harder to do that
14:55:39 <ski> cpdean : yes, removing duplication of code
14:55:43 <cpdean> ski: gotcha, so i should be looking at `nextLevel`
14:55:45 <EvanR> jmcarthur: so fmap on Vectors goes through Stream today?
14:55:53 <jmcarthur> It always has.
14:55:58 <ski> cpdean : no, at `doHangman', where it calls `nextLevel'
14:55:58 <EvanR> groovy
14:56:30 <jmcarthur> It doesn't something even crazier now.
14:56:48 <jmcarthur> It goes through Bundle, which is a bag of representations that the consumer can choose from.
14:56:57 * ski recalls playing around with (implementing) fusion a bit in MetaML
14:57:05 <cpdean> hm..
14:57:48 <jmcarthur> *It does
14:57:48 <ski> cpdean : instead of two branches, ending with the same thing, put the common thing after the whole branching happens
14:58:17 <ski> cpdean : is that enough hinting for you ?
14:58:30 <cpdean> ski: yeah i'll play with it
14:58:43 <cpdean> ski: thanks
14:58:59 <ski> cpdean : also, i pointed at a `do' (which you've removed) for a reason
14:59:53 <ski> jmcarthur,EvanR : .. sometimes i wonder whether one could use something like insts in Mercury to do that kind of stuff more nicely
14:59:54 <cpdean> yeah i figure it goes at the top and the nextLevel once at the bottom
15:00:12 <jmcarthur> I don't know Mercury. What are insts?
15:00:34 <ski> instantiation states. one can also do something like refinement types with them
15:00:59 <ski> however, here i was more thinking of using an inst system to track different ways to implement the same type
15:01:23 <EvanR> i should look into merucry
15:01:27 <EvanR> mercury
15:01:42 <ski> of course, i'd require mode declarations for operations, to specify which implementation (if any) it picks (obviously one can have inst polymorphism)
15:02:23 <ski> Mercury is quite interesting. but it doesn't really have the thing i was thinking about here. but (to my knowledge) the inst system in it gets closest to what i'm looking for
15:03:30 <ski> (fyi, there is a channel #mercury. it's possible to learn it without, but probably easier to learn it, in case you already know Prolog (##prolog))
15:03:57 <koz_> Argh, writing instances for newtypes around complex transformer stacks hurts the brain.
15:05:21 <EvanR> transformer stacks hurts my brain
15:05:42 <koz_> EvanR: Mine too, at least in terms of implementing stuff on them.
15:05:54 <monochrom> wait a second, you should need to even think too much or write much of your own code.
15:06:03 <monochrom> s/should/shouldn't/
15:06:47 <monochrom> If you have "newtype X a = MkX (ReaderT ....)", you pretty much just say that X's >>= calls ReaderT's >>=
15:07:09 <koz_> monochrom: Maybe you can help me then.
15:07:10 <EvanR> ski: i dont know any prolog
15:07:28 <sbrg> prolog is magic
15:07:29 <monochrom> yes there is a bit more than that, but not as bad as rethinking from scratch what >>= means
15:07:54 <monochrom> and yes I offer service for cdn$60 per hour
15:08:09 <monochrom> (actually 1 bitcoin per hour is good too)
15:08:24 <kadoban> xD
15:08:30 <EvanR> $650 and hour, almost had em
15:08:43 <monochrom> oh wait, $650 now?!
15:08:44 <ski> koz_ : can you use `GeneralizedNewtypeDeriving' ?
15:08:46 <ski> otoh
15:08:49 <ski> @quote is.the.solution
15:08:49 <lambdabot> quicksilver says: head-explosion is the solution, not the problem.
15:08:52 <EvanR> unless something is going on with CND vs USD
15:08:52 <koz_> monochrom: http://lpaste.net/296309 ski: I haven't tried.
15:09:11 <cpdean> ski:  wow this would be so much easier if i had a return statement
15:10:20 <ski> EvanR : "Re: [mercury-users] Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-(09|10) at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html> might be interesting
15:10:25 <monochrom> I bought 0.1 bitcoins at cdn$800 and have been waiting decades to sell it at a higher price.
15:10:39 <monochrom> anyway I suppose I'll just ask for 0.1 bitcoins per hour.
15:10:59 <EvanR> 100 millicoins
15:11:20 <monochrom> ooohhh! You have a "Vector a" at the end.
15:11:36 <koz_> Yeah - that's what the computation should yield (if everything goes well)
15:11:37 <cpdean> ski: i thought i could do something like this https://gist.github.com/cpdean/bcfa787ad2cc78adf1ca89c01f0d0b5d#file-guess-hs-L7-L15  but it breaks the base case i had to terminate the game
15:11:45 <ski> in any case, knowing a logic programming language belongs to a proper programming education
15:11:51 <monochrom> what should "return ()" do?
15:12:02 <cpdean> i want to break the control flow
15:12:17 <cpdean> before i had this written to fully go down one branch or the other
15:12:42 <koz_> monochrom: It'd yield a Vector of ().
15:12:43 <cpdean> but now i'm at a loss for how to branch and then have a common function be called at the end, or have one of the branches bail early
15:12:52 <monochrom> what is the length of that vector?
15:12:58 <koz_> OK, point taken.
15:13:00 <koz_> Allow me to amend.
15:13:06 <ski> koz_ : `deriving (MonadState StdGen,MonadError Text)'
15:13:39 <monochrom> I am OK with "Vector is just like finite [], so it's a monad too in the usually expected way"
15:13:54 <koz_> ski and monochrom: Thanks - I hadn't parametrized properly. With that, it falls into place.
15:14:10 <monochrom> in which case return () gives a length-1 vector of (), and >>= is like concatMap
15:14:11 <jmcarthur> Vector is weird in that if you use it in a particular way it behaves like codata.
15:14:56 <jmcarthur> Or at least with optimizations it does.
15:15:21 <ski> cpdean : yes, right. i just noticed that. so either you'd had to check for that first (awkward), or you just skip trying this approach. my main point was that you should be on the lookup for such factorings
15:16:08 * ski has sometimes wanted "fallthrough" in `case'-expressions, in Haskell
15:16:28 <ski> (i started sketching up a system for how it'd work, at one point ..)
15:17:04 <monochrom> wouldn't it be great to have that and create the Frankenstein's monster that is the Haskell-Duff device? :)
15:17:17 <Sam_> Hello, can someone help me please?I'm new in haskell and trying to learn http://lpaste.net/294377
15:17:53 <ski> jmcarthur : i suppose that's the discrepancy between the shared and the inlinable version ..
15:18:14 <Tuplanolla> That's a lot of edits, Sam_.
15:18:39 <monochrom> Sam_, I don't understand the question. What's the question?
15:18:46 <ski> monochrom : well, that's also require entering a loop non-locally/structurally, no ?
15:18:59 <monochrom> I forgot
15:19:47 * ski disbelieves line `23' in Sam_'s paste
15:20:05 <ski> (or line `22', if you prefer)
15:20:28 <cpdean> ski: in an imperative language this idea seems simpler but i feel like this route is not so much for haskell.  would you generally go with my inital approach of having every branch bottom out?
15:20:32 <Sam_> monochrom: http://lpaste.net/294377
15:20:32 <hpc> line 16 has the arguments in the wrong order
15:20:39 <hpc> line 22 probably wants one of the '5's to be a 6
15:20:40 <ski> Sam_ : is the problem that you .. what hpc said ?
15:21:29 <hpc> it's hard to tell from that paste what's desired, but the insert function itself looks correct
15:21:39 <ski> cpdean : <https://gist.githubusercontent.com/cpdean/bcfa787ad2cc78adf1ca89c01f0d0b5d/raw/9738318fab83cf131d7ed8aaca06a73b5e6502f5/Guess.hs> doesn't look that bad to me, either
15:21:54 <monochrom> OK, the question text seems to want "a -> Tree a -> Tree a" rather than "Tree a -> a -> Tree a". You just need to re-order parameters.
15:21:56 <ski> cpdean : however, i believe ertes had an idea for overhauling it all ?
15:22:00 <Sam_> ski: my code works like: insertTree Empty 5 -> Node 5 Empty Empty But I want it to work like: insertTree 5 Empty -> Node 5 Empty Empty
15:22:13 <cpdean> ertes: yeah how should i obliterate this
15:22:19 <Sam_> ski: I made some changes to do that shift but still not working.
15:22:50 <koz_> monochrom: I've managed to rewrite everything, but I'm still having one small snag: http://lpaste.net/296340
15:23:02 <ski> cpdean : oh, if you want to, you could try moving everything (except itself and `main') inside a `where' attaching to `doHangman' (for the version with just one defining equation)
15:23:43 <ski> cpdean : then you could avoid explicitly passing many arguments. this'd be a good exercise, i believe, if you haven't done that kind of thing before
15:24:10 <tom7942> Sam_:  just swap the order of the arguments to your insertTree function
15:24:15 <cpdean> you mean keep everything in lets or wheres instead of passing state into functions?
15:24:32 <ski> Sam_ : you need to change lines `7',`8',`10',`11'
15:24:43 <tom7942> Sam_: or make a new insertTree' = flip insertTree
15:25:15 <ski> cpdean : `where' actually, since you have two guards attaching to the defining equation
15:25:25 <kadoban> Is there a full list of the packages that come with GHC somewhere, anyone know?
15:25:41 <grantwu> Do you mean haskell-platform?
15:25:42 <ski> cpdean : `where'-bindings scope over guards of the defining equation the `where' attaches to. with a `let', you have to be inside an expression
15:25:47 <monochrom> koz_: is there any reason for "ev :: EVParams m a o -> EVComp (V.Vector a)" as opposed to "ev :: EVParams EVComp a o -> EVComp (V.Vector a)"?
15:25:51 <kadoban> I know base, containers, mtl does maybe? Is there more? Naw just GHC itself
15:26:10 <grantwu> Do packages come with GHC o.O
15:26:19 <ReinH> base comes with ghc
15:26:26 <kadoban> Don't they? Oh is base really it? Hmm ...
15:26:27 <glguy> kadoban: https://www.haskell.org/platform/contents.html
15:26:43 <koz_> monochrom: Let me try.
15:26:47 <kadoban> Ah, excellent, thanks glguy
15:27:08 <ReinH> Is the question about GHC or the Haskell platform?
15:27:14 <glguy> ReinH: GHC
15:27:25 <kadoban> GHC, though that page seems to answer it anyway
15:27:28 <koz_> monochrom: That is certainly better, but I still need a PrimMonad instance for EVComp.
15:27:29 <ReinH> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/
15:27:32 <grantwu> Yeah, that page is pretty useful
15:27:39 <grantwu> I should bookmark it
15:27:43 <koz_> I'm not sure how to write one, and GeneralizedNewtypeDeriving won't derive one for me.
15:27:48 <monochrom> the list does separate "from GHC" from "what platform adds"
15:27:53 <glguy> ReinH: The platform link is more useful
15:27:55 <kadoban> (I'm actually trying to figure out wtf I can use on a programming contest website that's ... lax with listing them)
15:28:08 <ReinH> glguy: Fair enough
15:28:15 <monochrom> this is why to hell with meaningful names and meaningful URLs
15:29:03 <cpdean> ski: k so refactor this to eliminate all top-level bindings so that only main is at the top level and shove as much as i can in the where clause
15:29:22 <koz_> monochrom: It fails to derive due to needing 'associated types'. I assume it's the state token type?
15:29:42 <monochrom> https://www.amazon.com/Java-In-20-Years/dp/1107452643/ is another example
15:30:03 <koz_> Oh yeah, and it turns out ExceptT doesn't have a PrimMonad instance...
15:30:07 * koz_ sighs.
15:31:26 <koz_> How does one write instances of PrimMonad anyway?
15:31:26 <glguy> monochrom: This one's weird https://www.amazon.com/hi-monochrom/dp/1107452643/
15:31:38 <monochrom> :)
15:32:40 <ski> cpdean : well, both `main' and `doHangman' on module toplevel, i'd say. but if you prefer only `main' (for the exercise, say), do so. you'll still need to put the other stuff inside a `where' attaching to `doHangman', though
15:34:00 <cpdean> ski: cool i'll see how this goes, thanks
15:34:59 <xcmw> How do you compose a function that returns a monad with one that does not in a pointfree way? & is to <&> as >>> is to what? 
15:35:30 <Koterpillar> xcmw: "returns a monad"? `flip fmap`?
15:36:03 <ski> xcmw : monads are not values, can't be "returned" like that. perhaps you meant "returns a monadic action"
15:36:18 <Koterpillar> @pl flip fmap
15:36:18 <lambdabot> flip fmap
15:36:23 <Koterpillar> @unpl flip fmap
15:36:23 <lambdabot> (\ x y -> fmap y x)
15:36:26 <ski> xcmw : perhaps you're looking for `(>=>)' ?
15:36:40 <ski> hm
15:36:43 <xcmw> f1 :: (a -> m b) f2 :: (b -> c)
15:36:55 <monochrom> that's fmap f2 f1
15:37:23 <glguy> fmap (fmap f2) f1?
15:38:12 <monochrom> err, yeah
15:38:55 <ski> xcmw : if you're looking for `Monad m => (a -> b) -> (b -> m c) -> (a -> m c)', then it's just `(>>>)', if you're looking for (what you said), then `... >>> fmap (...)' will do it
15:41:28 <xcmw> ski: ... >>> fmap ... was what I was looking for. Thanks
15:41:56 <ski> yw
15:42:12 <ski> (depending on the context of that, it might be possible to write it more eloquently)
15:44:42 <Darwin226> Guys please help. Every time I do any template haskell stuff I forget where the haskell syntax quasiqoters are defined
15:44:47 <Darwin226> Where are they?
15:44:53 <Darwin226> It's basically impossible to google
15:45:16 <Koterpillar> http://hayoo.fh-wedel.de/?query=Q ?
15:46:07 <Darwin226> I mean the thing you put in the [| |] brackets
15:46:39 <Koterpillar> oh, well, then which quasi quoters are you after?
15:47:16 <Darwin226> There should be 3 of them
15:47:23 <Darwin226> one for declarations, one for types and one for expressions
15:47:31 <monochrom> GHC user's guide, template haskell chapter?
15:48:35 <glguy> Darwin226: and patterns
15:50:05 <Darwin226> glguy: Yeah. Where are they?
15:51:26 <glguy> In the documentation
15:51:38 <glguy> See monochrom's message
15:53:09 <Tuplanolla> It's in section 9.26.6 of your printed user guide that came with your box of GHC, Darwin226.
15:53:32 <Darwin226> I have to say, I'm super confused
15:54:13 <yulax> Darwin226: there is a manual
15:54:25 <Tuplanolla> Here is a manual: https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#template-haskell-quasi-quotation
15:54:27 <yulax> read it.
15:54:55 <yulax> or if you are on a unixy system, "man ghc" will provide a virtual manual.
15:55:11 <yulax> so useful
15:55:23 <monochrom> but "man ghc" doesn't give you the GHC user's guide. Only some options and a list of more options
15:55:38 <ski> (and ditto for `info ghc')
15:58:30 * hackagebot lambda-calculator 0.5.0 - A lambda calculus interpreter  https://hackage.haskell.org/package/lambda-calculator-0.5.0 (sgillespie)
15:59:07 <Darwin226> Oh. So I don't have to import anything
15:59:37 <Darwin226> I've tried with 'd' before but I guess it didn't work because I only enabled the QuasiQuotes extension
16:12:11 <cpdean> ertes: wait so what was the thing you had planned for that hangman game
16:13:05 <ski> .. that must have been a large pizza
16:16:08 <cpdean> so large
16:22:12 <koz_> Could someone help me write this PrimMonad instance? http://lpaste.net/296488
16:22:23 <koz_> I'm a bit confused how to write a PrimState instance here.
16:25:15 <glguy> koz_: EVComp can't support a PrimMonad instance
16:25:31 <koz_> glguy: I had that suspicion.
16:25:35 <nshepperd> PrimMonad is for things that are "like" IO
16:26:24 <koz_> nshepperd: Well, it basically means I can't write the computation I want using mutable vectors, even though all I really want it to do is to be a monadic computation which includes the chance of error and an RNG.
16:26:33 <koz_> Unless I'm completely off-base.
16:27:12 <nshepperd> it would have to be a EVCompT, then you could use like EVCompT IO or EVCompT (ST s)
16:27:20 <mtn_> Question: I understand that the instance of functor for lists is defined as fmap = map, but how would we define this explicitly if map didn't exist. Recursively just like map?
16:27:22 <nshepperd> to use mutable vectors in it
16:27:43 <koz_> nshepperd: EVCompT (ST s) sounds exactly like what I need.
16:27:58 <Koterpillar> mtn_: it *is* map, so yes, just like map :)
16:28:06 <mtn_> It seems to me that the way map is defined is different from the patter for a functor like Maybe, where you just unwrap. Or is that the whole point? (that for a list, when you unbox, you have to iterate over all the values)
16:28:18 <Koterpillar> you do unwrap with map
16:28:32 * hackagebot sparse-linear-algebra 0.2.0.8 - Numerical computation in native Haskell  https://hackage.haskell.org/package/sparse-linear-algebra-0.2.0.8 (ocramz)
16:28:41 <Koterpillar> list has two constructors, cons (:) and nil ([])
16:28:46 <koz_> nshepperd: I can show you the original code I have. Writing this is severely doing my head in.
16:29:09 <mtn_> Koterpillar: Thanks
16:29:20 <Axman6> mtn_: yes, either explitic recursion or using something like foldr
16:29:23 <Koterpillar> mtn_: data List a = Cons a (List a) | Nil -- can you relate to Maybe now?
16:29:34 <Axman6> fmap f = foldr ((:) . f) []
16:30:34 <mtn_> Koterpillar, Yea, Maybe a = Just a | Nothing, so unwrapping is just a matter of getting a
16:31:01 <mtn_> Koterpillar, whereas the list is defined recursively, so unwrapping involves recursion till we reach the base []
16:31:15 <mtn_> Does that sound about right?
16:32:01 <Koterpillar> well, for your definition of "unwrap"
16:32:24 <Tuplanolla> All algebraic data types admit a unique and mechanically derivable definition of `fmap`, mtn_.
16:32:28 <Koterpillar> though generally, I'm not sure how saying fmap "unwraps" helps
16:33:06 <Koterpillar> to unwrap something, you have to have it _in_ there, which is not the case with all functors
16:33:25 <mtn_> Koterpillar, When would that not be the case?
16:33:56 <Koterpillar> IO, Cont
16:34:02 <lpaste> koz_ pasted “nshepperd: Here's what I'm trying to do” at http://lpaste.net/296513
16:34:45 <Koterpillar> Cont explicitly doesn't _contain_ the value you're fmapping over
16:34:56 <Tuplanolla> Here's one more, mtn_: `newtype Const c a = Const c`
16:35:10 <Koterpillar> well, this is just like Nothing
16:35:13 <glguy> koz_: It looks like IO is a suitable type for that
16:35:37 <glguy> It has error handling, random number generation, and vector mutation
16:36:00 <mtn_> Tuplanolla, Thanks :)
16:37:58 <tobiasBora> Hello,
16:38:32 <tobiasBora> I would like to know if there is a way in ghci to run inside another monad
16:38:36 <Welkin> hello torabora
16:38:54 <Welkin> your question doesn't make sense
16:38:57 <Koterpillar> tobiasBora: do you have a specific one in mind?
16:39:02 <Koterpillar> tobiasBora: all the time?
16:39:08 <tobiasBora> Yes I understand ^^
16:39:12 <tobiasBora> Here is an example : http://hackage.haskell.org/package/hArduino-1.1/docs/src/System-Hardware-Arduino-SamplePrograms-Blink.html#blink
16:39:32 <tobiasBora> the idea is that I want to run programs in monad : withArduino False "/dev/cu.usbmodemFD131" $ do
16:39:50 <nshepperd> koz_: does ExceptT Text IO work there?
16:40:11 <tobiasBora> and then send commands in that monad like "please open the 13 output"
16:40:23 <tobiasBora> "please, now close the 11 output"
16:40:27 <tobiasBora> and do that in real time
16:40:47 <Koterpillar> your question does make sense, but I don't know the answer :(
16:41:01 <nshepperd> koz_: I would guess that either IO or RandT (ST s) should work to provide mutable vectors & random numbers
16:41:57 <tobiasBora> You could say "well run :'withArduino ... $ do open_13_input'", but since the withArduino monad re-init the whole card, it's not really practicle to use.
16:42:04 <Koterpillar> tobiasBora: why don't you want to build an actual program with this?
16:42:51 <tobiasBora> Koterpillar: Because buildind an actual program isn't always easy to debug. I want to be able to open the light when I want, and not when the program wants
16:43:50 <geekosaur> pretty sure you'd have to modify ghci source and rebuild it
16:43:58 <geekosaur> @hackage ghci-ng
16:43:58 <lambdabot> http://hackage.haskell.org/package/ghci-ng
16:44:09 <geekosaur> ^unbundled version so you don't have to rebuild all of ghc
16:44:29 <geekosaur> also you'll probably have to mess with how it handles figuring out how to print values
16:44:42 <koz_> nshepperd: I would prefer RandT (ST s) over IO.
16:46:31 <Clint> tobiasBora: why doesn't the library let you separate the initialization out?
16:46:33 <koz_> nshepperd: So my overall type will be 'ExceptT Text (RandT g (ST s)) a'?
16:47:08 <tobiasBora> geekosaur: is it for me ?
16:47:20 <geekosaur> was someone else asking about ghci?
16:47:44 <monochrom> I have a cunning plan which is inspired by how they said to get rid of withSocketDo in network
16:47:55 <tobiasBora> Clint: I don't know. But this kind of think is quite "hard" to do in haskell I think. I don't understand why it's not possible to combine two monad, instead of nest them.
16:48:41 <tobiasBora> geekosaur: I don't know. They say that they are available in ghc 8.0. I have this version, so what should I do next ?
16:49:23 <geekosaur> usually because there is state of some kind to carry around (in this case I would expect it to be a Handle on the device, and/or state related to a C interface library)
16:50:14 <geekosaur> so you could do it all in IO but now you have to make sure to capture the state from the open and deliver it to all the functions that need it
16:50:30 <geekosaur> usually the withFooDo style is easier and less error prone
16:51:41 <koz_> nshepperd: I came up with this type sig: runEV :: Int -> ExceptT Text (RandT g (ST s)) a -> Either Text a - am I on the right track here?
16:53:34 <monochrom> no, my cunning plan probably isn't correct.
16:53:55 <koz_> @unmtl ErrorT Text (RandT g (ST s)) a
16:53:55 <lambdabot> g -> ST s (Either Text a, g)
16:55:11 <tobiasBora> geekosaur: but I didn't understood how ghci-ng would allow me to use them more easily
16:55:54 <geekosaur> [23 23:43:28] <geekosaur> pretty sure you'd have to modify ghci source and rebuild it
16:55:56 <EvanR> tobiasBora: by "i dont understand why its not possible to combine two monads" can i assume you know of how its possible?
16:56:12 <geekosaur> ghci-ng is just a way to modify ghci without having to rebuild all of ghc
16:56:49 <tobiasBora> geekosaur: You mean that I should write by hand the code to do it ? 
16:57:11 <geekosaur> there is no built in capability. I thought my and other answers were clear on that
16:57:42 <tobiasBora> EvanR: You mean that you can say "let's continue using the current monad, but in addition you can add this and this functions to it ?" ? If it's possible it would allow us to remove all dirty "liftIO" code !
16:58:42 <tobiasBora> geekosaur: All right. Well it seems to be a pretty natural willing to support monad on ghci since all the haskell ecosystem work on monad, but if it's not...
16:58:44 <geekosaur> ...
16:58:48 <Hijiri> it's not obvious that all possible "monadic whatevers" would be compatible with each other
16:59:02 <Hijiri> but what you are asking for sounds sort of like extensible effects
16:59:09 <geekosaur> tobiasBora, EvanR was saying that *you* appear to believe it is arbitrarily possible, and would like to hear your evidence
16:59:22 <ab9rf> now i want a burrito. dammit.
16:59:29 <EvanR> tobiasBora: right, if "monads" equated to "a bunch of commands" that might work, and youd have OOP and it probably wouldnt follow any sort of predictable laws
16:59:44 <EvanR> but yes i still would like to know your way
17:00:14 <haskell983> hi
17:00:16 <ab9rf> EvanR: i read "bunch of commands" as "bunch of comonads" at first
17:00:24 * geekosaur is thinking this sounds a bit like "but of course everything is guaranteed to be OOP underneath even if it pretends to be otherwise, so why don't you expose the mixins?"
17:00:42 <Hijiri> extensible effects essentially turns monadic things into a bunch of commands, the way I understand it
17:01:06 <ski> Koterpillar : .. `Codensity', otoh
17:01:12 <haskell983> Hey guys, quick qs, I was wondering if someone could point me towards some good resources in learning how to write a symbol table in haskell?
17:01:35 <ab9rf> what kind of symbol table? 
17:01:47 <geekosaur> (and in that case I'd like to hear which x86 instruction does a method call considering the potential for multiple inheritance, mixins/roles, etc.)
17:01:51 <haskell983> a symbol table for a compiler for a small language
17:02:03 <haskell983> maps identifiers to some information about the identifiers
17:02:48 <tobiasBora> EvanR: If I'm not wrong (sorry I'm not an expert in haskell at all), the random package is "hard coded" in the IO monad because it's practicle not to add a big monad by hand that would cover all our code.
17:02:48 <EvanR> are extensible effects a viable thing in haskell somehow?
17:02:49 <ski> haskell983 : how about .. `Data.Map' ?
17:02:49 <ab9rf> haskell983: use Map from Data.Map?
17:02:49 <hpc> EvanR: there's a package for it
17:02:49 <hpc> haven't used it but hackage makes it look reasonable
17:02:49 <Hijiri> there was oleg's original haskell eff and then his upgraded eff
17:02:49 <koz_> What am I missing with runST in this? http://lpaste.net/296577
17:02:50 <EvanR> tobiasBora: hmm. the random package definitely includes lots of support for pure RNGs, including monadic. the IO stuff is specifically for randomIO
17:02:51 <haskell983> currently I'm using Data.Map, but i want to also implement lexical scoping
17:02:52 <tobiasBora> geekosaur: I don't say that all monad can be used like this. I say that some of them would like to be, and that it would allow us to write less cheaty code. 
17:02:59 <nshepperd> koz_: that type sig seems like it should work
17:03:28 <ab9rf> there's no requirement to use IO to generate random numbers
17:03:31 <nshepperd> koz_: oh, you can use runST in pointless style
17:03:42 <koz_> nshepperd: Can or can't?
17:03:46 <nshepperd> koz_: er, can't.
17:03:46 <ab9rf> you only need IO if you want either to use the "system RNG" or if you want to capture environmental entropy
17:03:55 <tobiasBora> EvanR: Yes. But how does randomIO works ? Does "random" need to modify the IO monad, or would it be possible to write as many randomIO as I would like to do ?
17:03:58 <koz_> nshepperd: So what *should* it look like then?
17:04:00 <nshepperd> because of rank2 type inference shenanigans
17:04:01 <geekosaur> and randomIO is just a wrapper for storing the PRNG seed in an IORef instead of using MonadState or MonadRandom
17:04:05 <EvanR> randomIO works using IO
17:04:30 <jle`> tobiasBora: randomIO is an IO action that describes the action of getting a random value from the environment
17:04:33 <EvanR> its for getting random numbers "right now and i dont care how"
17:04:35 <nshepperd> koz_: just eta expand that definition: runEV seed xyz = runST $ ... $ ... $ xyz
17:04:42 <ski> koz_ : `runST' is higher-rank, which doesn't mix well with indirect use like that (because of no `ImpredicativeTypes')
17:04:53 <ab9rf> randomIO just uses the IO monad to stash the random state in an IOref. there are other randomizers that will actually capture environmental entropy (e.g. /dev/random on a linux box) but that's not in the standard randomizer.
17:04:54 <koz_> ski and nshepperd: Thanks, I'll try that.
17:05:14 <tobiasBora> EvanR: Yes. But where does the seed is stored ?
17:05:22 * ski 'd  probably avoid all the `$'s
17:05:23 <Hijiri> it does some hacky stuff to make a global IORef
17:05:25 <EvanR> in a hidden part of the IO environment
17:05:25 <ab9rf> tobiasBora: in a secret hidden place
17:05:43 <EvanR> similar to the floating point configuration, stdin, etc
17:05:53 <ab9rf> tobiasBora: you can also make your own seed and either use it directly or overwrite te hidden one
17:06:41 <EvanR> when you want more control over your random numbers you want to get out of randomIO
17:06:51 <tobiasBora> EvanR: And randomIO say "please, add this to the IO environment", of IO already provide something for this package ?
17:06:59 <tobiasBora> *says
17:07:10 <EvanR> no it asks a question to the environment, and the side effect is to update the generator
17:07:12 <ab9rf> tobiasBora: it justs uses an IORef to store the random state
17:07:15 <koz_> nshepperd: I tried eta-expanding, and it still fails.
17:07:18 <koz_> With the same error.
17:07:23 <ski> show code
17:07:28 <koz_> Let me edit.
17:07:31 <Hijiri> tobiasBora: it uses unsafePerformIO (or some related function) to make a static IORef containing the generator
17:08:01 <EvanR> unsafePerformIO is involve i think, but its really not relevant to the idea of "some thing in IO exists you can only access through IO actions"
17:08:27 <Hijiri> I had the impression that tobiasBora was worried that randomness was special-cased into IO
17:08:29 <EvanR> this phenomenon occurs in any monad
17:08:32 <koz_> ski: Edited: http://lpaste.net/296577
17:08:35 <tobiasBora> All right. And why wouldn't it be possible to generalise this to transform any withXXX do $ ... pattern with a more easy to use function ?
17:08:40 <ski> run-time computed modules could be interesting
17:09:04 <ski> koz_ : now refactor away the `.'s in there
17:09:05 <geekosaur> most of us think withXXX *is* the more easy to use function
17:09:05 <EvanR> why would it? im actually asking
17:09:17 <ski> (those were the actual problem)
17:09:20 <koz_> ski: So wait, I just have to do it bracket-wise?
17:09:47 <ski> please do
17:09:50 <EvanR> withXXX is really popular for initialize, do stuff, clean up
17:09:54 <EvanR> not just in haskell
17:09:58 <ab9rf> unsafePerformIO is involved, yes
17:10:17 <ab9rf> unsafePerformIO $ do; rng <- mkStdRNG 0; newIORef rng
17:10:19 <tobiasBora> geekosaur: it's natural in code, but not usable in toplevel
17:10:22 * geekosaur revises initial estimation: this is not an OOP mindset, it's a C mindset
17:10:38 <EvanR> (the fact that unsafePerformIO is involved to support something essentially in IO itself shouldnt be surprising or relevant)
17:11:05 <koz_> ski: Like this? It still errors, just differently: http://lpaste.net/296577
17:11:07 <geekosaur> where strcpy was considered an obviously better way to handle strings than assignment
17:11:17 <tobiasBora> (and I must admit that using liftIO makes me feel that withXXX could be better defined)
17:11:38 <ski> it would perhaps be nice if one could write a marker in an expression, in the toplevel, which opened a new (recursive) toplevel, preferably with variables visible at that marker in scope
17:11:43 <Sam_> Hello guys, there is this last problem.I kind of got this although a little problem.Please take a look.http://lpaste.net/294377
17:11:56 <ski> (something related is already in the debugger, i believe)
17:12:08 <geekosaur> this our buddy again?
17:12:24 <glguy> Hi polo/Ali_/haskell### again
17:12:42 <EvanR> tobiasBora: theres another thing... if your commands were MonadIO constrained, and your monad is a Monad IO monad, you wouldnt need liftIO. though in practice liftIO is a really minor concern. its not cheating in any way.
17:12:54 <EvanR> and if they arent MonadIO constrained, you can write a few wrappers
17:13:00 <ab9rf> Sam_: your findTree doesn't descend the tree
17:13:01 <EvanR> trivial wrappers
17:13:01 <ski> Sam_ : use recursion
17:13:23 <ab9rf> Sam_: it only checks the root node
17:13:24 <nshepperd> koz_: ah, now we're getting somewhere. the s in runEV's type sig needs to be existentially quantified
17:13:36 <koz_> nshepperd: Wait, how do I even?
17:13:58 <nshepperd> koz_: that is, Int -> (forall s. ExceptT Text (RandT StdGen (ST s)) a) -> Either Text a
17:14:02 <ab9rf> koz_: shift right with carry, check carry flag
17:14:08 <ski> glguy : this was also the same ?
17:14:22 <koz_> nshepperd: So should there be a 'forall s .' on the front of that?
17:14:33 <koz_> nshepperd: Oh, wait, never mind, I see it now.
17:14:36 <koz_> So I should use RankNTypes then.
17:14:46 <ski> nshepperd : s/existentially/universally/
17:15:00 <nshepperd> er
17:15:37 <ski> koz_, yep
17:16:14 <nshepperd> well, its existential in the type of runEV, since it's in contravariant position. i think
17:16:23 <nshepperd> but yeah whatever
17:16:42 * ski wouldn't term it like that, but if you say so ..
17:16:53 <koz_> nshepperd: OK, and this should work?
17:17:31 <nshepperd> koz_: I hope so!
17:17:41 <koz_> nshepperd: Well, only one way to find out I guess.
17:17:47 <Sam_> <ab9rf> :  otherwise      =  findTree a (Node b left right)
17:17:58 <ski> (fwiw, you could beta-reduce, or introduce a `let'/`where' there)
17:18:36 <nshepperd> note, runEV here will have the same restriction as runST, in that 'runEV . foo' won't type check
17:18:40 <nshepperd> but that should be ok
17:19:04 <koz_> nshepperd: It's not a huge issue for me. I just mainly wanna be sure it actually works.
17:20:52 <ab9rf> Sam_: that will just loop
17:21:36 <Sam_> <ab9rf> : I'm not sure how to traverse tree in haskell.
17:21:55 <monochrom> tree traversing is not specific to Haskell.
17:22:16 <monochrom> you have a left subtree and you should ask "should I recurse on the left subtree?"
17:22:28 <monochrom> you have a right subtree and you should also ask "should I recurse on the right subtree?"
17:22:36 <Welkin> a tree is a list with two options at each level
17:22:44 <Welkin> er, several
17:22:47 <Welkin> two if it is binary
17:22:47 <monochrom> Haskell or not, you just never consider "let me recurse on the whole tree again"
17:23:04 <EvanR> [Either a b] ?
17:23:32 <cpdean> ski: so i have learned that i have no idea how `where` works
17:23:56 <Clint> keep using it until you do
17:24:10 <cpdean> ski: i thought i could implement it piecemeal on smaller parts of the program to prove that i know how to make it work but i keep getting syntax errors
17:24:24 <cpdean> ski: does it have special rules on IO () functions?
17:24:25 <Welkin> `where` is syntactic sugar for `let ... in` that wraps the entire definition, right?
17:24:27 <EvanR> i didnt get where until i learned that its an attachment to definitions and not expressions
17:24:35 <ski> Sam_ : please don't address people by surrounding their nicknames in angle brackets. it looks like you're quoting something they said (i first thought you were doing this), just write their nickname first in the message, followed by e.g. a comma or a colon, then the message
17:25:27 <ski> cpdean : nope
17:25:44 <EvanR> which explains why you can nest wheres inside wheres but not inside cases
17:25:57 <ski> cpdean : you should be able to make the change in small steps, each type-checking
17:26:17 <ski> Welkin : `where'-bindings also scope over guards
17:26:55 <geekosaur> ...the attachment to definitions was obvious to me; I spotted the consistency module...where, foo = ... where, data ... where (GADTs), class ... where, instance ... where, etc.
17:27:11 * ski isn't even sure what "inside cases" would mean (apart from the obvious interpretation, which obviously is possible)
17:27:43 <EvanR> case foo of {A -> x where x=3; B -> y where y=2}
17:27:43 * ski normally indents the whole body of a module ..
17:28:06 <monochrom> by 3.72983 spaces?
17:28:30 * geekosaur suddenly wonders if where can be attached to lambdas. would be consistent with definitions and case patterns...
17:29:08 <Axman6> Ben Lippmeier's compromise: Use 3 spaces to make everyone happy
17:29:09 <monochrom> go with lambdacase so you can :)
17:29:27 * monochrom now wonders if that's actually true
17:29:49 <EvanR> wait, this works
17:29:53 <koz_> nshepperd: Nope, didn't work.
17:30:07 <EvanR> case 'x' of {'x' -> x where x=1} how is that attached to a definition
17:30:31 <geekosaur> that was what made me wonder about lambdas. in some sense the -> there is the same as the one on \x -> ...
17:30:48 <geekosaur> which *is* an (anonymous) definition
17:31:19 <monochrom> yeah, the Haskell report says no, but you have convinced me that it could easily be a yes, no problem.
17:31:42 <koz_> nshepperd: I tried it in GHCi, with the following: http://lpaste.net/296634
17:31:50 <koz_> s/following/following result
17:32:02 <EvanR>  (\'x' -> x where x=1) 'x' <interactive>:3:12: parse error on input ‘where’
17:32:23 <geekosaur> however I will guess it works in case mainly to simplify desugaring multiple definitions into a single one with a case
17:33:00 <geekosaur> (foo (x:xs) = ... where ...; foo x = ... where ...)
17:33:01 <EvanR> there goes my easy way to explain where where goes
17:33:20 <ski> clearly you can have `case foo of {A -> x where {x = case bar of {B -> y where {y = 2}}}}'
17:33:20 <ski> (or omitting the middle `case' in the obvious way, if you prefer)
17:33:20 <ski> cpdean : .. if you prefer, i could perform the first step, on e.g. <https://gist.githubusercontent.com/cpdean/bcfa787ad2cc78adf1ca89c01f0d0b5d/raw/9738318fab83cf131d7ed8aaca06a73b5e6502f5/Guess.hs> ?
17:33:31 <monochrom> all easy stories are crude approximations
17:34:07 <Welkin> the ant and the grasshopper?
17:34:14 <EvanR> i before e except after c
17:34:15 <Welkin> goldilocks and the 3 bears?
17:35:18 <cpdean> ski: here... i'm trying to figure out why this yields a syntax error https://gist.github.com/cpdean/bcfa787ad2cc78adf1ca89c01f0d0b5d#file-guess-hs-L33-L34
17:35:24 <EvanR> i recall teachers getting away with their stories being not entirely right with the follow up "well theres always exceptions"
17:35:27 <geekosaur> ...or when it sounds like "a" --- English is certainly a suitable language to see how easy ways are oversimplifications :)
17:35:30 <cpdean> it feels just like what i'm seeing here https://wiki.haskell.org/Let_vs._Where
17:36:08 <geekosaur> merge the streams!
17:36:09 <acowley> Does anyone know how the --cppopts passed to c2hs are generated?
17:36:34 <byorgey> koz_: I think you are running into https://github.com/byorgey/MonadRandom/issues/29
17:36:34 <geekosaur> cpdean, you have to indent the where
17:36:41 <monochrom> https://www.xkcd.com/872/  the grasshopper contracts to a point on a manifold
17:36:56 <cpdean> haha
17:36:56 <geekosaur> otherwise it's trying to occupy the same scope as module ... where
17:37:12 <cpdean> geekosaur: nice, thanks
17:37:15 <acowley> I have a problem where there is a --cppopts=-I/nix/store/blah/include passed to c2hs, but blah is a framework, so that's not the right path for headers
17:37:22 <byorgey> koz_: I hope to add such an instance and make a new release of MonadRandom soon
17:37:27 <koz_> byorgey: So I should write an orphan instance?
17:37:55 <koz_> I had a feeling, but I didn't wanna assume in case I missed something.
17:38:32 <byorgey> koz_: for now you can write an orphan instance, sure
17:39:18 <byorgey> koz_: wait, are you the one who opened that issue?  or is  koz_ / kozross just a coincidence?
17:39:19 <koz_> byorgey: OK, will do. Thanks for the help!
17:39:39 <byorgey> sure!
17:41:41 <glguy> If you go by the template-haskell naming, where is attached to a "clause"
17:42:33 <koz_> Yay, it works! byorgey: Yes, that was me.
17:42:49 <koz_> I have to be koz_ on IRC, because someone already took koz without an underscore.
17:43:52 <koz_> byorgey: I am indeed the issue-opener, byorgey (in case you missed it there).
17:45:46 <knupfer> What does the abbreviation ML stand for?  Martin-Löf?
17:46:05 <acowley> meta-language, iirc
17:46:19 <Welkin> MetaLanguage
17:46:27 <EvanR> so MetaML was especially meta
17:46:38 <knupfer> Ok, thanks
17:46:55 <Axman6> fix Meta ML
17:46:58 <acowley> EvanR: Yes, the Meta ML Language was named to clarify the initials
17:47:03 <acowley> :P
17:47:08 <knupfer> Curiously, wikipedia writes nothing about the name.
17:47:41 <monochrom> It was called meta-language because it was meta to a logic. It was a programming language of a theorem prover.
17:48:14 <Axman6> We had a talk about CakeML the other day, and it seems to be very meta, doing things like automatically producing compilers from proofs for languages, including itself, and by construction the compiled compiler implements the language which the proof specifies (I'm probably way off on some of those points...)
17:48:55 <knupfer> Wow
17:49:50 * EvanR goes into the cakeML channel
17:50:21 <Welkin> cakephp?
17:50:27 <Welkin> are they similar?
17:51:02 <geekosaur> one is cake or death, the other is the cake is a lie? :p
17:51:02 <EvanR> i dont think we need to say anything else about cakephp
17:51:19 <Axman6> it has php in the name after all
17:54:31 <cpdean> how would i get these two functions to share the same definition of `nLevel` without it being pulled up to the toplevel? https://gist.github.com/cpdean/bcfa787ad2cc78adf1ca89c01f0d0b5d#file-guess-hs-L11
17:55:08 <EvanR> take the nLevel as an argument? ; )
17:55:15 <cpdean> lol
17:55:34 <glguy> cpdean: Instead of pattern matching in the top-level definition, do it in a case expression
17:55:55 <glguy> then doHangman will have a single clause that can share a single where
17:56:13 <cpdean> glguy: can i case match on multiple args?
17:56:27 <geekosaur> tuple them
17:56:34 <cpdean> all one tuple?
17:57:21 <Axman6> it doesn't look like you need to thought: goHangman theWord guesses maxAttempts = case guesses of [] -> ... (guess:gs) -> ... where nLevel ...
17:57:34 <ski> geekosaur,EvanR : unfortunately it doesn't work for plain lambdas (btw, in SML `case' is sugar for applying a function expression (which naturally supports multiple branches))  
17:58:12 <Axman6> you can also use guards in case statements: ... (guess:gs) | guess == therWord -> ... | otherwise -> ...
17:58:33 <cpdean> hmmm all right i'll try reshuffling it into one expression
17:58:46 <lpaste> ski pasted “moving stuff inside `where'” at http://lpaste.net/296680
17:58:52 <ski> cpdean ^
17:58:54 <geekosaur> ski, yes, EvanR tested it when I asked. which was a pity because it provided a simpler explanation for it working in case expressions than "there to support easier desugaring of multiple equations" :p
17:59:09 <cpdean> oh interesting
18:00:47 <cpdean> i had no idea it could be so simple
18:03:14 <cpdean> ski: what powers the linting stuff at the bottom of lpaste?
18:03:25 <cpdean> "redundant bracket, redundant do"
18:03:26 <Koterpillar> cpdean: looks like hlint
18:03:32 <cpdean> i need this
18:03:50 <Koterpillar> @hackage hlint
18:03:50 <lambdabot> http://hackage.haskell.org/package/hlint
18:04:16 <geekosaur> there should be a link to it at the bottom of the lpaste page too
18:07:36 <drninjabatman> Hello, is there a way to make synonyms for constraints? Eg I have in many places `(Eq a, Ord a, Hashable a, Show a) => ...` Is there a way to make this `(Constrained a) => ...`
18:07:42 <drninjabatman> ?
18:08:58 <pavonia> Doesn't "type Constrained a = ..." work?
18:09:10 <jmcarthur> drninjabatman: Yes. If you use -XConstraintKinds you could say   type Constrained a = (Eq a, Ord a, Hashable a, Show a)
18:09:27 <EvanR> if i use Double infinity to represent the max bound for time, i just realized a side effect will be things that should never wake up actually might when Double saturates
18:09:33 <EvanR> i wonder if minecraft does that
18:09:51 <drninjabatman> Oh yes, I knew I had seen that somewhere! Thnx!
18:09:58 <cpdean> k so ski what do you think ertes was going to suggest i try to do next?
18:10:34 * ski has no idea .. :/
18:11:20 <cpdean> ski: what are you working on now in haskell?
18:15:31 <dolio> EvanR: What would be saturating? Assuming there's adding going on, it seems more likely that the 'current time' would stop increasing at some point.
18:15:43 <dolio> Before you get to infinity.
18:17:50 <EvanR> good point
18:18:17 <EvanR> theoretically time could step is larger and large increments!
18:18:28 * EvanR ignores
18:18:35 <grantwu> Uh... the first link under https://www.haskell.org/haddock/#Examples is a 404
18:18:50 <dolio> Yeah, I think that's what it would have to do to get to infinity.
18:18:57 <dolio> Or start out at a very large time step.
18:19:47 <EvanR> what if i use kahan summation
18:20:27 <EvanR> and if that doesnt work, will enough nested kahan summation get us to infinity with reasonably small steps
18:21:16 <EvanR> this is kind of like 1/zeno's paradox
18:21:36 <Welkin> but time is quantized
18:21:38 <Welkin> so there is no paradox
18:22:04 <Welkin> you can't halve a planck time unit
18:22:18 <EvanR> thats certainly true in folk quantum physics
18:23:42 <geekosaur> time is quantized but there is no agreement as to the quantum
18:24:51 <kadoban> Is it even proven (or widely believed?) that time is quantized?
18:24:57 <EvanR> im in a RWS monad... and i just realized i want to run a subprocedure which writers to a different channel, momentarily
18:25:19 <EvanR> ##physics
18:26:02 <EvanR> i need a PHP monad so i can manipulate output buffer control
18:26:04 <ski> @type mapRWST
18:26:07 <lambdabot> (m (a, s, w) -> n (b, s, w')) -> RWST r w s m a -> RWST r w' s n b
18:26:31 <EvanR> oh 
18:27:07 <EvanR> no, i need the w' 
18:27:18 <EvanR> now not when the whole thing is done
18:27:25 <ski> mhm
18:28:17 <EvanR> could be done by running a new RWS and negotiating the state at the interface
18:28:39 <EvanR> oh no i also need to write to the original channel in the process
18:28:45 <EvanR> monads :|
18:29:22 <EvanR> back to the drawing board
18:30:13 <jmcarthur> Is there some trick to getting GHC to inline non-functions? It's not picking up my INLINE pragma unless I give it a spurious () argument.
18:33:27 <jmcarthur> Or maybe it's a bug? I can't find anything indicating this should be expected.
18:36:16 <nshepperd> > (maxBound, maxBound + 1) :: Float
18:36:18 <lambdabot>  error:
18:36:18 <lambdabot>      • Couldn't match expected type ‘Float’ with actual type ‘(t0, t1)’
18:36:18 <lambdabot>      • In the expression: (maxBound, maxBound + 1) :: Float
18:36:24 <nshepperd> er
18:36:26 <nshepperd> damn
18:36:30 <nshepperd> > (maxBound, maxBound + 1) :: (Float, Float)
18:36:33 <lambdabot>  error:
18:36:33 <lambdabot>      • No instance for (Bounded Float) arising from a use of ‘maxBound’
18:36:33 <lambdabot>      • In the expression: maxBound
18:36:45 <nshepperd> :< nevermind
18:37:00 <EvanR> they decided to not implement a class for floats which would make no sense
18:37:03 <EvanR> for once ;)
18:37:37 <EvanR> but i think you can add one in lambdabot
18:37:57 <EvanR> > succ (1/0)
18:37:59 <lambdabot>  Infinity
18:48:40 * hackagebot hackernews 1.1.1.0 - API for Hacker News  https://hackage.haskell.org/package/hackernews-1.1.1.0 (DavidJohnson)
18:53:48 <Welkin> dmj: really?
18:55:09 <dmj> Welkin: hm?
18:55:19 <Welkin> hackagebot
18:55:30 <dmj`> yea
18:55:41 <dmj`> Welkin: what about it
18:56:15 <Welkin> dmj`: I found it funny
18:57:34 <dmj`> Welkin: heh :] 
19:10:14 <slack1256> Am I the only one with real trouble understanding new libraries? All documentation seems to be "reference docs" instead of tutorial to pick up pace
19:10:39 <Welkin> slack1256: yeah, the biggest problem for haskell
19:10:48 <Koterpillar> and not only
19:10:53 <Cale> slack1256: Which in particular?
19:10:58 <dmj`> slack1256: the types tell a story in a lot of the docs
19:11:22 <slack1256> yeah, but you have to unify the type variables to see who is who.
19:12:22 <slack1256> Is like a theater play were the characters change customes each scenes... and you have myopia
19:12:31 <dmj`> slack1256: which docs in particular?
19:12:59 <slack1256> plus using type classes and not specifying which of the 30+ instances is the one that you should really focus is a sin, plain and simple
19:13:14 <slack1256> Repa recently
19:15:05 <slack1256> Source, Load: Okay I kind understand them. Mmm Target is not clear (*iterates over all posible instances, an see what is in each, then it will make sense*)
19:16:06 <EvanR> i think type class heavy libs/docs are harder than ones with normal types and functions
19:16:36 <EvanR> something about the presentation of it
19:16:39 <Cale> Repa is a bit special in that it also includes some type-level computation with the shapes
19:16:39 <slack1256> Yes
19:17:35 <slack1256> In repa, the shapes are straight forward. The representations (and which instance they meet) is where the meat is
19:18:17 <Cale> Yeah, fair enough
19:18:29 <Cale> http://repa.ouroborus.net/ there are some more tutorials and stuff linked here
19:18:42 * hackagebot vty 5.11.2 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.11.2 (JonathanDaugherty)
19:19:45 <slack1256> heh, 4 days ago, the tutorial links worked. 
19:22:06 <ski> @where repa
19:22:06 <lambdabot> I know nothing about repa.
19:22:21 <ski> @where+ repa REgular PArallel arrays <http://repa.ouroborus.net/>
19:22:21 <lambdabot> Good to know.
19:25:48 * slack1256 thinks lambdabot is kind of adorable
19:31:43 <jvanbure> how does Haddock deal with alex files?
19:48:44 * hackagebot binary-ieee754 0.1.0.0 - Backport ieee754 float double combinators to older binary  https://hackage.haskell.org/package/binary-ieee754-0.1.0.0 (winterland)
19:53:44 * hackagebot vty 5.11.3 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.11.3 (JonathanDaugherty)
20:02:56 <flazz> i just tried the minimal ghc from ghcformacosx.github.io; when opening the app it says it was installed at a stabil location in '/private/var/folders/s3/...' (big long name) is this expected?
20:07:32 <Welkin> flazz: why did you do that?
20:07:42 <Welkin> installing ghc from the bindist on mac is easy
20:07:48 <Welkin> or even easier, use stack
20:07:59 <Welkin> or also easy enough, use nix
20:08:22 <flazz> Welkin: I mved it to /Applicaitons; i nuked that and did a finder based move and it seems ok now
20:08:54 <Welkin> it should not be in /Applications
20:09:18 <ashishnegi> hi..  i am writing a game in Haskell and gameengine is statemonad and easier to test.. but server logic of handling users is `MVar` and a lot of code is in `IO ()`  https://github.com/nilenso/tronkell/blob/master/src/Tronkell/Server/Server.hs What are the strategies that i can follow to move more code out in pure and test some "workflow" ?
20:09:33 <flazz> Welkin: why not, the docs suggest /Applications?
20:10:11 <Welkin> flazz: never used ghcformacos
20:10:16 <Welkin> sounds strange
20:24:12 <EvanR> ashishnegi: good question, I'm not sure if anyone has figured out the best way yet
20:24:24 <EvanR> you could try FRP
20:24:47 <c_wraith> I like free monads.  At which point we're talking about entirely different dimensions of making it pure.
20:25:28 <EvanR> you could also try to come up with a DSL to describe things in a way that mirrors how you think of programming the game
20:25:43 <EvanR> free monads is one way to do that, youll end up with basically an imperative DSL
20:27:04 * EvanR as I hammer on a free monad for a game
20:27:56 <EvanR> ashishnegi: you could also try #haskell-game channel
20:28:46 * hackagebot median-stream 0.3.0.0 - Constant-time queries for the median of a stream of numeric  data.  https://hackage.haskell.org/package/median-stream-0.3.0.0 (jmc41493)
20:38:15 <glguy> vvhvbulhtufbbktjifivljchnukcjtknrtbctngrvvfb
20:38:26 <Koterpillar> nice password
20:38:45 <glguy> it's a time-code... you have 30 seconds left to be me :(
20:40:54 <cpdean> so.. who wants to talk about text editors
20:41:59 <ski> @yhjulwwiefzojcbxybbruweejw
20:42:00 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
20:42:34 * Clint squints.
20:42:48 <Koterpillar> > "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
20:42:51 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
20:42:59 <cpdean> of course
20:43:23 <cpdean> > putStrLn "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
20:43:24 <Koterpillar> > show $ show $ show $ "\\"
20:43:25 <lambdabot>  <IO ()>
20:43:26 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\"\\\"\""
20:43:34 <Koterpillar> > show $ show $ show $ "\"
20:43:36 <lambdabot>  <hint>:1:25: error:
20:43:36 <lambdabot>      lexical error in string/character literal at end of input
20:43:53 <geekosaur> > fix show
20:43:55 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
20:44:00 <Cale> @yhjulwwiefzojcbxybbruweejw
20:44:00 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
20:44:03 <Cale> @yhjulwwiefzojcbxybbruweejw
20:44:04 <lambdabot> Exception: <<loop>>
20:44:10 <Cale> @yhjulwwiefzojcbxybbruweejw
20:44:10 <lambdabot> Just 'J'
20:44:16 <Cale> haha
20:44:28 <cpdean> waht
20:44:40 <geekosaur> a bit of lambdabot ancient history
20:44:44 <geekosaur> @v
20:44:44 <lambdabot> Just 'J'
20:45:05 <Cale> For a brief period of time, the expression you told lambdabot to evaluate was bound to a variable named yhjulwwiefzojcbxybbruweejw
20:45:12 <geekosaur> so an early version of  lambdabot evaluated stuff and bound it to "v" in order to show it. people figured that out and began to abuse it
20:45:20 <geekosaur> so for a while it got renamed to that monster name
20:45:24 <Cale> and by using that variable, you could do recursive shenanigans
20:45:37 <cpdean> lol
20:45:38 <Cale> ah, right, it was v just before that
20:45:40 <geekosaur> current versions generate a name and ensure it's not somehow already in use
20:46:24 <geekosaur> (actually current versions use mueval and it may be even more clever than that)
20:48:39 <monochrom> this is so full of unspeakable magic
20:51:12 <ReinH> Well, clearly at least some of it is speakable.
20:52:50 <ski> > (read . (++ "\\\"") . read . (++ "\"") . read . (++ "\\\"") . read . (++ "\\\"")) "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\" :: String
20:52:52 <lambdabot>  "\\"
20:54:20 <Koterpillar> fix read
20:54:23 <Koterpillar> > fix read
20:54:28 <lambdabot>  mueval-core: Time limit exceeded
20:54:37 <Hafydd> > fix error
20:54:39 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
20:59:43 <geekosaur> ...just not pronounceable :p
22:19:51 <jle`> hi
22:20:09 <jle`> what's the lightest lib i can use just to fetch a simple file over http?
22:20:21 <jle`> i'd normally use wreq but that's kind of heavy
22:21:33 <jle`> oh it looks like wreq is a wrapper over different libraries, and uses http-client for these requests
22:21:46 <clueless> hey guys, question, where is a good place to ask someone about a program I have written in c, besides the ##c channel?
22:23:03 <jle`> clueless: code-review stack exchange?
22:31:24 <clueless> thanks!
22:31:29 <Lokathor> so can you stack more than one reader context up?
22:32:52 <geekosaur> you can stack them up but can only derive MonadReader for one of them. the other you have to reach with lift
22:34:10 <Lokathor> hmm
22:34:45 <Lokathor> what i want is essentially an IO-like type that keeps track of a few extra things, and the actions within that type key off of the tracked values
22:35:38 <Lokathor> there's some FFI data that i want to keep track of on the haskell side of things during the life of the program, which will rarely change
22:35:57 <Lokathor> so it feels like use of Reader and local are what's called for
22:36:50 <glguy> If you're set on using Reader, you can put a record in the Reader with all of the stuff you had in mind to track
22:37:10 <Lokathor> is there a better style to go with here?
22:37:28 <glguy> Or better is to make a newtype specific to your program (which could be a newtype around Reader if you want) which has the behavior your program needs
22:39:38 <Lokathor> hmm
22:39:45 <Lokathor> that thing.. i'm less familiar with
22:40:28 <glguy> records?
22:41:05 <Lokathor> no
22:41:22 <Lokathor> newtyping over IO and then specializing it to a particular situation
22:42:13 <glguy> It's basically the same as wrapping ReaderT around IO and using that
22:46:18 <Lokathor> so like, newtype Terminal a = Terminal { withTerminal :: IO a } ?
22:46:52 <glguy> It would be newtype Terminal = MkTerminal { withTerminal :: InfoStuff -> IO a }
22:47:01 <glguy> It's probably worth trying just using normal functions first, too.
22:47:21 <glguy> The reader layer isn't free
22:47:26 <Lokathor> hmm
22:47:49 <Lokathor> well I can do it all with just IO
22:49:28 <Lokathor> the biggest thing is that i want to be able to call the color controlling functions, regardless of if colors failed to initialize at the start of the program or not
22:49:44 <Lokathor> and if colors failed to init they should just be voided out in the background
22:50:10 <Lokathor> but what's important is that if colors DID fail to init, then those calls can't get through the haskell layer and end up passing into C
22:50:18 <Lokathor> or C will throw a barf
22:51:08 <glguy> That's probably just a matter of having your Haskell code return a Maybe Colors value so that it can use Nothing for when initialization failed
22:52:08 <Lokathor> ah... what? I'm not sure I follow. so the coloring controls are something like: setColor :: Color -> IO ()
22:53:11 <Lokathor> at least currently that's what it looks like, but that could be changed around and stuff. I'm not sure how a maybe would work into it though
22:53:22 <ab9rf> assuming that "setColor" changes the state of some graphics engine somewhere out there, that seem slikely
22:53:31 <glguy> Well, you haven't described what the interface is, so what I said might not apply
22:54:01 <Lokathor> the interface in this case is curses, and ab9rf is correct.
22:54:36 <glguy> So you are going to be in a situation where you have a Color value, but it's not OK to execute a setColor thatValue?
22:55:38 <Lokathor> so you turn on color control with (initColor :: IO Bool), and if you get a False back then it couldn't start up colors for whatever reason
22:55:58 <Lokathor> and if you try to change colors without calling that first, or after you call that but it gave you false, then barf
22:56:34 <glguy> OK, so then do things in that order and record in your application state if colors are turned on
22:56:47 <EvanR> you might want to use OOP for this. that is to say, you have the interface to the colors in a record type: Interface { setColor :: Color -> IO () }
22:56:47 <ab9rf> fmap setColor myColor is what you want
22:57:13 <ab9rf> sorry, no, that requires they be the same monad
22:57:15 <EvanR> the instance of that record only can be gotten from the initialization, and you can get a dummy record, or a working record
22:57:23 <ab9rf> well, no
22:57:27 <ab9rf> you just get a Maybe (IO ())
22:57:31 <EvanR> if you want it to ignore
22:57:32 <ab9rf> which you can ignore
22:57:41 <ab9rf> if myColor is Maybe Color
22:58:08 <ab9rf> then fmap setColor myColor is Maybe (IO ()), and setColor is only called if myColor is not Nothing
22:58:10 <EvanR> that way your code doesnt have to keep checking maybes in one way or another
22:59:05 <Lokathor> uh, so, trying to read out all your stuff intermixed... basicall just change it to be, initColor :: IO (Color -> IO ())
22:59:14 <EvanR> yes! ;)
22:59:59 <Lokathor> i like it
22:59:59 <Lokathor> i think
23:00:05 <Lokathor> now that probably goes in a reader :P
23:00:08 <EvanR> that works great when you know it cant fail after initialization succeeds (cross fingers)
23:00:44 <glguy> Lokathor: presumably your application has some other state, so it just goes alongside that
23:01:09 <Lokathor> glguy, i am attempting to, where possible, seperate the GUI interaction from all other program state
23:01:30 <Lokathor> so that the curses module itself can be taken into other projects easily
23:01:59 <EvanR> i might want to use this curses module, so better get it right!
23:02:17 <glguy> If you're making a library it'll be even more important not to tie things up in a Reader
23:02:29 <Lokathor> oh my last attempt was to go for 100% coverage, and that was insanity
23:02:31 <glguy> so that the users of your library don't have the structure of their programs forced on them
23:02:44 <Lokathor> this attempt is more "the things people will use, based on what i want to use"
23:04:08 <glguy> the terminfo package will be worth looking at
23:04:20 <glguy> It does something similar with terminal capabilities as your looking at with colors
23:04:52 <Lokathor> "provides an interface to the terminfo database (via bindings to the curses library)" yes this sounds very close
23:05:38 <Lokathor> setForegroundColor :: TermStr s => Capability (Color -> s)
23:09:07 <Lokathor> for the record, the "official" docs for curses colors stuff is here https://linux.die.net/man/3/init_color, but it's not what i would describe as entirely precise
23:15:44 <kirillow> Why does `f (x:xs) = x` return the first element in a list?
23:17:06 <c_wraith> kirillow: Do you know how pattern-matching works in Haskell?
23:17:19 <ski> > 7 : [5,3,2]
23:17:22 <lambdabot>  [7,5,3,2]
23:17:36 <Lokathor> x : xs is a pattern match, and in haskell lists are linked lists, so the x is the first element
23:18:00 <ski> `7 : [5,3,2]' is equal to `[7,5,3,2]', `:' adds a single element in front of a list (empty or not), building a non-empty list
23:18:05 <kirillow> So `:` indicates that i want the first element?
23:18:09 <kirillow> in pattern matching?
23:18:19 <c_wraith> kirillow: no.  (:) is one of the two constructors for list
23:18:23 <c_wraith> kirillow: it's just a normal pattern match
23:18:24 <ski> `:' indicates constructing a list from a first element, and a list of remaining elements
23:18:38 <ski> using `:' in a pattern indicates running this process *backwards*
23:18:54 <ski> the evaluation of `f [7,5,3,2]' is as follows
23:19:02 <ski>      f [7,5,3,2]
23:19:07 <Lokathor> another example would be this: f (a,b) = a
23:19:13 <Lokathor> here you're unpacking a tuple
23:19:29 <ski>   =  f (7:[5,3,2])  -- because `[7,5,3,2]' is equal to `7 : [5,3,2]'
23:19:44 <kirillow> AH!
23:19:57 <ski>   =  7  -- because `f (x : xs)' is equal to `x', for any `x' and `xs', in this case `x = 7' and `xs = [5,3,2]'
23:20:12 <kirillow> Thank you!
23:20:36 <ski> btw, note that you can't run arbitrary functions "backwards" in patterns, only data constructors
23:20:44 <ski> e.g. you can't say
23:20:48 <ski>   f ([x] ++ xs) = x
23:21:02 <ski> even though, logically speaking, that characterizes the same function `f'
23:21:37 <c_wraith> kirillow: this is why constructors must be lexically distinct from other value-level identifiers, by the way
23:21:54 <c_wraith> kirillow: True and False are constructors, for instance.  You can tell because they start with capital letters.
23:22:08 <ski> (you will simply get a compile-time error, if you try it, rather than getting an incorrect answer at run-time. pattern-matching in Haskell doesn't support this way of running a general function backwards in a pattern (see Mercury for a language where this is possible))
23:22:08 <c_wraith> kirillow: Infix operators can also be constructors.  The ones that are all start with :
23:22:50 <ski> (i should mention that there's something called "view patterns", with which you can do something similar in effect to "running a function backwards in a pattern", though really you're running a different function forwards)
23:22:54 <kirillow> Very interesting
23:23:12 <c_wraith> kirillow: Things that are constructors can be used to deconstruct values as well as construct them.  That's more or less the core of how haskell does computation.
23:25:46 <ski> data constructors are the core/primary/primitive/canonical forms (or formers) of `data' types
23:27:17 <ski> evaluation of an expression in Haskell relies on being able to reduce the "outermost shape" of the expression to such a data constructor (possibly with not fully reduced/evaluated arguments/components) .. or, failing that, getting into an infinite loop, or aborting the program with a run-time failure (e.g. pattern-matching failure)
23:27:35 <ski> and then you can go on to reduce the components in the same way
23:28:11 <ski> kirillow : btw, note that your `f' will fail, with pattern-matching failure, if passed an empty list
23:30:41 <ski> (btw, i should probably mention that, really, the form `[7,5,3,2]' is syntactic sugar for `7 : [5,3,2]', which is syntactic sugar for (some steps ahead) `7 : 5 : 3 : 2 : []'. `:' associates to the right, so this means `7 : (5 : (3 : (2 : [])))')
23:31:12 <ski> (lists in Haskell are single-linked list)
23:33:03 <piyush-kurur> hi does any one want to help port raaz to windows please let me know
23:33:23 <piyush-kurur> raaz is a crypto library for haskell that I am developing
23:34:27 <piyush-kurur> The relevant issues are https://github.com/raaz-crypto/raaz/issues/281 and https://github.com/raaz-crypto/raaz/issues/280
23:36:16 <Lokathor> piyush-kurur, inline-c makes for easy ffi stuff
23:36:35 <Lokathor> but you still need the C compiler on windows, which is often "glhf" territory
23:36:49 <piyush-kurur> Lokathor: yes I know but I do not have a windows machine and hence cannot test it myself
23:36:57 <Lokathor> oh :(
23:37:26 <Lokathor> well i'm on windows but don't have it setup for ffi stuff and things. I actually do most of my haskell development on a remote linux box
23:38:58 * hackagebot record 0.4.2 - Anonymous records  https://hackage.haskell.org/package/record-0.4.2 (NikitaVolkov)
23:43:40 <EvanR> that feel when the giant case expression has all its cases written
23:43:55 <EvanR> and its like, what else is there to do... uh nothing
23:44:08 <EvanR> which always feels wrong ;)
23:44:13 <Lokathor> and the sinking feeling when you get the warning... case missing
23:44:45 <EvanR> that feel when you get to the last missing case and you realize its impossible because the entire plan is just bogus
23:46:08 <Lokathor> EvanR, regarding the curses thing a little earlier, I think that what I want is to newtype IO as was said, and then have that be a MonadIO so that your non-displaing IO can still happen interleaved with your display adjustments
23:46:32 <Lokathor> but basically it would be like those libs that manage a connection state and build connection actions and then use runConnection $ ...
23:47:13 <Lokathor> i'll have to look into it more later, but if you want to glance at curses as it stands: https://github.com/Lokathor/fullainth/blob/master/lib/UI/Curses.hs
23:54:34 <Sinestro> What's the right way to handle parallelizing a computation that is in the IO monad but doesn't care about order? It's mapping a function that updates a mutable Vector over a list of things that tell it how to update it, but you could shuffle them and get the same result. I tried parallel-io but it adds 16 seconds of pthread_mutex_lock and _pthread_cond_signal to a program that only took two seconds to run on a single core.
23:55:34 <Lokathor> can you do it with non-IO parallel and then dump to IO at the end?
23:59:20 <EvanR> is the amount of data enough to account for the cost of parallizing
23:59:33 <EvanR> parallelizing
