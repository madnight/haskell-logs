00:04:04 <ongy> is there a function in base (or well known package) with '[[a]] -> [a]' that sort of interleaves the lists? example: [[1, 2], [3, 4], [5]] -> [1, 3, 5, 2, 4] 
00:05:49 <Hafydd> ongy: there is concat . transpose.
00:07:06 * Hafydd . o O ( conpose )
00:07:11 <Lucky_0604> no base package, but concat transpose is right
00:08:14 <ongy> looks good. thx
00:27:11 <MarcelineVQ> orion: toIO o r rf = return . runFooAppEnv $ o r (liftIO . rf) where runFooAppEnv is any way you can unwrap a FooAppEnv will convert that function to using IO. it's not super readable though :X I also have no way of testing if that's correct for your use
00:27:47 <MarcelineVQ> :t toIO' (undefined :: Request -> (Response -> FooAppEnv ResponseReceived) -> FooAppEnv ResponseReceived)
00:27:48 <lambdabot> Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
00:35:00 <orion> MarcelineVQ: I think I found what I was looking for: https://hackage.haskell.org/package/wai-transformers-0.0.7/docs/Network-Wai-Trans.html#v:hoistMiddlewareT
00:35:28 <MarcelineVQ> :>
00:36:09 <orion> The hoistMiddlewareT and hoistApplicationT functions take "to" and "from" arguments with types (forall a. m a -> n a) and (forall a. n a -> m a), respectively.
00:37:28 <orion> "to" is simple enough: FooAppEnv a -> IO a :: flip runReaderT env . runFooApp
00:37:45 <orion> However, going from IO a -> FooAppEnv a seems a bit more tricky.
01:08:36 <tsahyt> I think I have found a satisfying solution to my callback problem
01:09:13 <tsahyt> the API itself does nothing with the user data void* other than passing it to the callback when appropriate. so I can safely ignore it and implement user data myself in Haskell.
01:09:40 <tsahyt> for example using and MVar in a closure, which makes some sense because the same callback might get called from multiple solver threads anyhow
01:10:04 <tsahyt> http://lpaste.net/44570142645944320
01:10:10 <tsahyt> this works nicely ^
01:20:58 <SandmanXC> hi! quick question: any reason why ghci says that System.Directory.getFileSize doesn't exist?
01:21:22 <SandmanXC> http://lpaste.net/303012
01:24:54 <jle`> what version of the 'directory' package do you have installed?
01:25:55 <tsahyt> huh, turns out the sdl2 package just lets some function pointers leak too
01:26:03 <tsahyt> for example in SDL.Audio
01:26:38 <tsahyt> actually most of them, freeHaskellFunPtr is only called once in SDL.Time
01:26:44 <SandmanXC> jle`: how can i find out? sorry, i'm really new
01:27:01 <jle`> SandmanXC: how did you install directory/how are you starting ghci?
01:27:42 <SandmanXC> jle`: i installed the Haskell Platform for OS X from the website
01:28:25 <jle`> if you have access to a command line prompt, try
01:28:29 <jle`> ghc-pkg list | grep directory
01:28:36 * hackagebot cake3 0.6.4 - Third cake the Makefile EDSL  https://hackage.haskell.org/package/cake3-0.6.4 (SergeyMironov)
01:29:02 <ocramz> morning everyone
01:29:03 <SandmanXC> it says directory-1.2.6.2
01:29:36 <SandmanXC> the documentation doesn't suggest the function being new
01:30:02 <ocramz> can anyone point me to Haskellers who live in Sweden? I'd like to arrange a meetup/hack meet
01:30:23 <ocramz> specifically on the west coast
01:30:44 <ocramz> I just know a few in Goteborg
01:30:51 <quchen> alexanderb is Swedish I think
01:31:02 <quchen> Not here right now though
01:31:06 <ocramz> thanks quchen, I'll ask him
01:31:17 <Pantsu> ocramz: come visit norway, we have a couple of haskell user groups :p
01:31:47 <ocramz> Pantsu : I will? Oslo is quite close
01:33:39 <jle`> SandmanXC: i'm assuming you imported System.Directory into your ghci session, right?
01:33:39 <Pantsu> hmm aparently there is a meetup group in stocholm too
01:33:43 <Pantsu> http://www.meetup.com/Haskell-Stockholm/
01:33:48 <jle`> SandmanXC: with ghci> import System.Directory
01:33:55 <SandmanXC> yes, i did :module + System.Directory
01:34:27 <jle`> SandmanXC: try :browse System.Directory
01:34:30 <ocramz> Pantsu, yes indeed, but come on, this is the city where QuickCheck was invented, we need one here as well
01:34:36 <jle`> do you see a reasonable list of functions/types that pop up?
01:34:50 <SandmanXC> yes
01:34:51 <quchen> edwardk: Hey Edward. Any chance I could get commit rights in Trifecta to add some documentation? It’s my number one pain point with the library, and I’m currently working on it again, so I might as well write my results down
01:35:15 <quchen> Or would you prefer pull requests nowadays?
01:35:20 <jle`> SandmanXC: do you see 'getFileSize' show up?
01:35:25 <SandmanXC> jle`: no
01:35:26 <quchen> There used to be that joke that one should never ever give you one’s Github account ;-)
01:36:06 <quchen> Also: What is an “It” :-x
01:36:34 <jle`> SandmanXC: http://hackage.haskell.org/package/directory-1.2.6.2/docs/System-Directory.html
01:36:40 <jle`> directory-1.2.6.2 doesn't have getFileSize
01:36:50 <SandmanXC> jle`: alright, i found the docs for my current version, the function must be in 1.2.7.*
01:36:51 <SandmanXC> yeah
01:36:51 <damian_> hello guys! I am using http-conduit and I want to unittest some function that are returning HTTP.Response... is there any easy way to create a HTTP.Response so I can unit test my code?
01:37:06 <jle`> SandmanXC: yeah, they probably should have noted that
01:37:09 <SandmanXC> any hints on how to update it the most easily?
01:37:32 <SandmanXC> i'm trying to get a grip around monads and i wanna build a recursive folder disk size thingy
01:37:43 <jle`> i think in the old days we used to use https://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-Files.html
01:38:33 <jle`> hm, that isn't very user friendly at all
01:39:21 <SandmanXC> i found that package, it looks kinda complicated
01:39:22 <jle`> SandmanXC: ah, you would use getFileStatus to get a 'FileStatus', and then query that with fileSize to get an Int64
01:39:44 <jle`> i'm sure there's a simpler way somewhere else though ><
01:39:49 <SandmanXC> any way i could update directory, preferably without having to build it from source?
01:40:29 <SandmanXC> jle`: i have cabal installed
01:41:03 <jle`> you can write an equivalent function using System.Posix.Files
01:41:13 <SandmanXC> lol, it was just a matter of doing `cabal install directory`
01:41:13 <SandmanXC> i know
01:41:17 <SandmanXC> but i think this should do it
01:41:31 <SandmanXC> thank you so much for your help
01:41:38 <jle`> getFileSize f = fmap (fromIntegral . fileSize) (getFileStatus f)
01:41:41 <jle`> no problem!
01:41:46 <jle`> i'd be careful of 'cabal install' though
01:41:52 <SandmanXC> why?
01:41:53 <jle`> it's not very user friendly and could easily ruin your global configuration
01:41:58 <jle`> it's literally the worst actually
01:42:02 <SandmanXC> lol, i see
01:42:11 <SandmanXC> i thought it was the standard way to get packages and stuff
01:42:20 <jle`> nowadays people use higher level tools like 'stack'
01:42:42 <jle`> 'stack install directory' would be the equivalent, and you'd launch into ghci using 'stack ghci'
01:42:42 <SandmanXC> i think the platform comes with that as well
01:42:51 <SandmanXC> interesting
01:43:01 <SandmanXC> i'll look into that
01:43:17 <jle`> yeah, it's kind of weird that nobody tells you to not use cabal install when cabal install is the easiest way to ruin your global configuration
01:43:17 <MarcelineVQ> there's also a cabal sandbox which was fairly nice when I used it
01:43:20 <Pantsu> cabal sandboxes are not too bad either
01:43:36 <jle`> yeah, cabal sandbox, and there's a new command too that does a good job
01:43:37 * hackagebot cake3 0.6.5 - Third cake the Makefile EDSL  https://hackage.haskell.org/package/cake3-0.6.5 (SergeyMironov)
01:43:41 <jle`> just never 'cabal install' globally, heh
01:43:47 <Pantsu> as for cabal ruining your system, just don't run it as root ever 
01:43:52 <SandmanXC> i'm not
01:44:01 <jle`> not even as root...don't run it globally outside of a sandboxed project, heh
01:44:21 <Pantsu> then you can simply nuke the .cabal when stuff gets too messy or you update ghc
01:44:44 <jle`> yeah, that's the worst case, i used to do that all the time back in the day
01:44:51 <jle`> but now i don't have to, i have multiple versions working side by side with multiple ghc's all managed with stack :)
01:45:13 <jle`> and i don't ever have to worry about messing anything up.  it's the future ._.
01:46:59 <tabaqui1> has anybody tried to cross-compile ghc?
01:47:03 <tabaqui1> from linux for win
01:47:06 <tabaqui1> i get this error when trying i686 or x86_64 mingw:
01:47:10 <tabaqui1> error: storage size of ‘test_array’ isn’t constant
01:47:15 <tabaqui1> in Types.hsc
01:47:21 <tabaqui1> /usr/bin/x86_64-w64-mingw32-gcc -v
01:47:23 <tabaqui1> gcc version 6.2.1 20160830 (GCC) 
01:55:01 <tabaqui1> oh, i had to wait a few minute
01:55:05 <tabaqui1> don't go
01:55:15 <tabaqui1> has anybody tried to cross-compile ghc?   
01:55:17 <tabaqui1> from linux for win    
01:55:21 <tabaqui1> i get this error when trying i686 or x86_64 mingw: 
01:55:29 <tabaqui1> error: storage size of ‘test_array’ isn’t constant  
01:55:35 <tabaqui1> in Types.hsc    
01:55:39 <tabaqui1> /usr/bin/x86_64-w64-mingw32-gcc -v   
01:55:41 <tabaqui1> gcc version 6.2.1 20160830 (GCC) 
02:21:14 <mahdi> Hi, I'm trying to write `show someDataInstance` into a file but I get `out of memory` errors. I tried writing a chunked write but no success whatsoever. Any suggestions on how it should be done? Here is my code: https://github.com/mdibaiee/sibe/blob/rnn/examples/recurrent.hs#L40-L59
02:21:37 <mahdi> I don't want the string to be allocated in memory first and then written to file, I want it to be streamed into file
02:23:32 <lyxia> why is the indentation such a mess
02:24:22 <merijn> lyxia: Looks mostly fine to me?
02:24:38 <merijn> I don't understand why the repeated let's, though
02:24:44 <opqdonut> mahdi: I think BL.pack forces the whole string
02:25:34 <merijn> mahdi: Why not replace the repeated lets on line 16 through 32 with a single let?
02:25:44 <opqdonut> mahdi: if the string returned by "show newr" is lazy enough, just hPutStr'ing it should stream
02:25:55 <lyxia> okay nevermind something weird was happening in my browser
02:26:16 <mahdi> opqdonut: I tried without BL.pack (though I'm using Lazy ByteStrings, so I think it won't force the whole string). here is the older version: https://github.com/mdibaiee/sibe/blob/728df02fbdd6f134af107c098f5477094c61ea76/examples/recurrent.hs#L52-L64
02:26:45 <mahdi> opqdonut: I'm confused over the _lazy enough_ part, how should I know that?
02:26:50 <opqdonut> mahdi: but I think show isn't really meant for stuff like this. you should consider using https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Builder.html
02:27:28 <nesqi> I would like to specify some kind of derive pattern so that I can do:   data MyData = MyData x | MyData y deriving (MyClass)  is this possible and if so, where would a start digging?
02:27:31 <opqdonut> mahdi: lazy enough just depends on the implementation of the show instance. you could for instance check how much memory "print (last (show newr))" uses
02:28:10 <merijn> nesqi: You can't derive like that, but there's 2 alternative solutions
02:28:23 <lyxia> Isn't there DeriveAnyClass
02:28:33 <merijn> nesqi: 1) Write a Template Haskell function that generates the instance for you, like lens does
02:28:33 <mahdi> opqdonut: in that example you are consuming the whole string, but I'm not consuming anything myself, I'm just giving it to `hPutStr`
02:28:54 <merijn> nesqi: 2) Provide a Generic based instance of your class and derive Generic for MyData
02:29:30 <merijn> lyxia: DeriveAnyClass doesn't actually magically generate the instance for you...
02:29:50 <opqdonut> mahdi: yes, and hPutStr is consuming it
02:30:07 <merijn> lyxia: It just means that if you could write "data Bar = Bar deriving (Foo)" instead of "instance Foo Bar"
02:30:07 <lyxia> merijn: Right.
02:30:09 <nesqi> A Generic based instance?
02:30:55 <mahdi> opqdonut: but only a part of it, afterwards it should be freed as there is no more use for that part (I'm dropping it), so it should not grow in memory usage over time
02:31:38 <opqdonut> mahdi: so consider "print (last (repeat 100000 'x'))" this will allocate only one 'x' at a time, garbage collecting the list as it streams along
02:31:58 <opqdonut> mahdi: so it matters how lazy the producer of the String is
02:32:04 <merijn> nesqi: GHC has code for writing generic code, using the Generic instance of a datatype you can access it's abstract structure and implement you functionality using that. Then you can use DefaultSignatures to provide a default implementation for your typeclass using Generic
02:32:10 <merijn> nesqi: See for example: https://hackage.haskell.org/package/binary-0.8.4.1/docs/src/Data.Binary.Class.html#Binary
02:33:02 <merijn> nesqi: Using Template Haskell might be more straightforward, but using Generic is probably easier in some scenarios
02:33:09 <opqdonut> mahdi: since your old implementation of saveRecurrent didn't work, it probably means that "show newr" isn't lazy enough. it constructs the string all at once
02:33:48 <merijn> nesqi: But I don't have a lot of experience using Generic, it also depends on exactly what sorta thing you want to auto-generate
02:34:40 <mahdi> opqdonut: hmm, seems legit. I've never used BS builders before though, do I have to write a Builder for my data type instance manually? Thanks for your help though
02:35:03 <merijn> nesqi: This seems like an ok intro: http://www.stephendiehl.com/posts/generics.html
02:35:12 <merijn> nesqi: Including how to combine that with using DeriveAnyClass
02:35:55 <mettekou> edwardk: If you could find the time to upload the latest version of bound to Hackage, that would be a great help to a lot of us, as evidenced by https://github.com/ekmett/bound/issues/32.
02:43:52 <mrkgnao> :t fromMaybe
02:43:54 <lambdabot> a -> Maybe a -> a
03:03:45 <kqr> does anyone know of a "count :: (Foldable f, Eq a, Num b) => f a -> Map a b" function?
03:07:49 <lyxia> count = Map.fromList . flip zip [0..] . toList
03:08:03 <lyxia> oh wait no...
03:08:18 <lyxia> You want to count elements?
03:08:41 <lyxia> Nevermind.
03:09:24 <kqr> "MultiSet.toMap . MultiSet.fromList" shoudl work
03:13:00 <kqr> well, "MultiSet.toMap . MultiSet.fromList . Foldable.toList" or something I guess
03:13:05 <MarcelineVQ> counting repeated elements?
03:13:17 <kqr> counting how many of each element
03:13:32 <gleber_> kqr: Map.fromList. (id &&& length) . (groupBy `==`) . toList
03:13:33 <MarcelineVQ> :t M.fromAscListWith (+) . flip zip (repeat 1) . F.toList -- but without ord the onus is on you to have it sorted it
03:13:35 <lambdabot> (Foldable t, Num a, Eq k) => t k -> M.Map k a
03:13:55 <gleber_> no, missing map
03:14:09 <gleber_> Map.fromList. (map $ id &&& length) . (groupBy `==`) . toList
03:14:13 <gleber_> :t Map.fromList. (id &&& length) . (groupBy `==`) . toList
03:14:15 <lambdabot> error: parse error on input ‘==’
03:14:29 <gleber_> :t Map.fromList. (id &&& length) . (groupBy (==)) . toList
03:14:31 <lambdabot> error:
03:14:31 <lambdabot>     Not in scope: ‘Map.fromList’
03:14:31 <lambdabot>     Perhaps you meant one of these:
03:14:38 <nesqi> merijn: Thank you! I'll look into which solutions suits me best.
03:15:06 <kqr> Prelude MS Foldable> let count = MS.toMap . MS.fromList . Foldable.toList
03:15:08 <kqr> Prelude MS Foldable> count "AABCCAABBABAAABC"
03:15:10 <kqr> fromList [('A',8),('B',5),('C',3)]
03:15:12 <kqr> like so
03:20:28 <gleber_> :t Map.fromList . (map $ head &&& length) . (L.groupBy (==)) . L.sort . F.toList
03:20:30 <lambdabot> error:
03:20:30 <lambdabot>     Not in scope: ‘Map.fromList’
03:20:30 <lambdabot>     Perhaps you meant one of these:
03:21:03 <MarcelineVQ> lambdabot has that as M.fromList or Data.Map.fromList iirc
03:21:13 <gleber_> indeed, thanks!
03:21:15 <gleber_> :t Data.Map.fromList . (map $ head &&& length) . (groupBy (==)) . sort . F.toList
03:21:17 <lambdabot> (Foldable t, Ord a) => t a -> M.Map a Int
03:21:18 <MarcelineVQ> but sort will require ord
03:21:34 <gleber_> right
03:22:29 <ertesx> kqr: not sure if it pays off to pull in another dependency and a new API just for counting…  i would use: fromListWith (+) . map (, 1) . toList
03:22:30 <MarcelineVQ> > M.fromListWith (+) . flip zip (repeat 1) . F.toList $ "AABCCAABBABAAABC" -- You also have this as an option if you have Ord
03:22:32 <lambdabot>  fromList [('A',8),('B',5),('C',3)]
03:23:48 <ertesx> kqr: the general idea is:  instead of 'f' just use (fWith (+)) (unions) or (fWith min) (intersections)
03:26:00 <kqr> MarcelineVQ, I guess you'll have to have Ord to put it into a map anyway
03:26:40 <MarcelineVQ> I think you don't, but to use most of Map's functions you do, so it ends up the same
03:26:45 <kqr> ah
03:28:11 <ertesx> you need Ord to put a new element into any map that may already have elements
03:28:18 <ertesx> :t M.singleton
03:28:21 <lambdabot> k -> a -> M.Map k a
03:29:36 <kqr> sometimes the generality of haskell functions shock me
03:29:42 <ertesx> > M.fromListWith (+) . map (, 1) . toList $ "AABCCCCDEEFFG"
03:29:45 <lambdabot>  error:
03:29:45 <lambdabot>      Ambiguous occurrence ‘toList’
03:29:45 <lambdabot>      It could refer to either ‘F.toList’,
03:29:50 <ertesx> > M.fromListWith (+) . map (, 1) . M.toList $ "AABCCCCDEEFFG"
03:29:53 <lambdabot>  error:
03:29:53 <lambdabot>      • Couldn't match expected type ‘M.Map k a1’
03:29:53 <lambdabot>                    with actual type ‘[Char]’
03:29:53 <ertesx> uhm
03:29:56 <ertesx> > M.fromListWith (+) . map (, 1) . $ "AABCCCCDEEFFG"
03:29:59 <lambdabot>  <hint>:1:34: error:
03:29:59 <lambdabot>      parse error on input ‘$’
03:29:59 <lambdabot>      Perhaps you intended to use TemplateHaskell
03:30:00 <ertesx> > M.fromListWith (+) . map (, 1) $ "AABCCCCDEEFFG"
03:30:03 <lambdabot>  fromList [('A',2),('B',1),('C',4),('D',1),('E',2),('F',2),('G',1)]
03:30:04 <ertesx> that was horrible…
03:30:05 <MarcelineVQ> :>
03:30:13 <ertesx> sorry =)
03:30:25 <kqr> also not quite correct because it will count A twice if they aren't in sequence
03:30:35 <kqr> oh wait maybe not
03:30:43 <kqr> > M.fromListWith (+) . map (, 1) $ "AABCCCCDEEFFGA"
03:30:46 <lambdabot>  fromList [('A',3),('B',1),('C',4),('D',1),('E',2),('F',2),('G',1)]
03:30:48 <kqr> neat
03:30:54 <ertesx> > let xs = M.fromListWith (+) . map (, 1) $ "AABCCCCDEEFFG"; ys = M.fromListWith (+) . map (, 1) $ "AEEFGGGHIIJ" in M.unionWith (+) xs ys
03:30:56 <lambdabot>  fromList [('A',3),('B',1),('C',4),('D',1),('E',4),('F',3),('G',4),('H',1),('...
03:32:09 <ertesx> @let counts = M.fromListWith (+) . map (, 1) . F.toList
03:32:12 <lambdabot>  Defined.
03:32:42 <ertesx> > M.unionWith (+) (counts "ABABB") (counts "BCCBC")
03:32:44 <lambdabot>  fromList [('A',2),('B',5),('C',3)]
03:33:46 <ertesx> > M.intersectionWith min (counts "ABABB") (counts "BCCBC")
03:33:49 <lambdabot>  fromList [('B',2)]
03:36:12 <kqr> i think I underestimated the API of Data.Map seriously
03:40:27 <merijn> kqr: Almost everyone does :)
03:40:52 <merijn> It's not always very obvious, but very powerful and flexible :)
03:52:15 <nesqi> merijn: According to this StackOverflow http://stackoverflow.com/questions/3864647/how-does-deriving-work-in-haskell support for Generics where taken out.
03:54:38 <merijn> nesqi: That's talking about Generic Classes, but not generics
03:55:21 <kuribas> why is it Data.Foldable, but Control.Monad?
03:55:35 <merijn> nesqi: Also, you should just use the GHC manual, rather than relying on stackoverflow https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/generic-programming.html
03:55:44 <merijn> kuribas: Hysterical raisins
03:55:55 <kuribas> ok
03:56:25 <merijn> kuribas: "Whoo! We've got fancy hierarchical modules, hierarchy all the things!"
03:56:56 <merijn> kuribas: Basically, the entire Data/Control divide/prefix is dumd and you should mostly avoid using them, except, in some cases for consistency with related/existing modules
03:57:21 <merijn> kuribas: See, for example, pipes switching from "Control.Proxy" in early versions to the more sensible Pipes module naming
03:57:28 <kuribas> Data also seems to be a catch-all prefix.
03:58:27 <kuribas> The idea of common namespace prefixes is broken by a lack of structure in the prefixes.
03:59:15 <merijn> kuribas: Yes. Like I said, I would avoid using Control/Data prefixes unless you are, for example writing a new kind of Chan and putting it in Control.Concurrent.NewChan for consistencies sake
03:59:44 <kuribas> merijn: so what should I use for my truetype library?  (currently Data.Truetype)
03:59:58 <kuribas> Typography.Truetype?
04:00:01 <nesqi> merijn: ok, I think I'll go with template haskell. It could be usefull for other things aswell so it's more important to learn about.
04:00:15 <nesqi> thanks again
04:00:31 <merijn> kuribas: Sure, you might even use just TrueType (although you want to avoid squatting "desirable" namespace parts)
04:01:04 <merijn> kuribas: i.e., imagine lens would've used just Lens. On the one hand, that'd be pretty nice, on the other hand, many packages might want to use that module name...
04:01:21 <merijn> kuribas: Font.TrueType or similar might also work
04:01:24 <MarcelineVQ> TrueType.TrueType if you want to avoid 'squatting' a top level
04:02:11 <tsahyt> wouldn't font rendering belong into Graphics?
04:02:13 <kuribas> merijn: on the other hand, people should improve my library, rather than start their own ...
04:02:21 <tsahyt> e.g. Graphics.Font.TrueType
04:02:27 <merijn> tsahyt: He's not doing font rendering
04:02:38 <tsahyt> merijn: ok, then it's not graphics
04:02:42 <merijn> tsahyt: He's generating/changing font files :)
04:02:53 <kuribas> maybe Data.Truetype isn't too bad...
04:03:03 <kuribas> to show it's just a data format...
04:03:15 <tsahyt> Data is like the catch-all category
04:03:34 <merijn> kuribas: Sure, I'm just cautioning against claiming a top level module name that might desirable for other packages too. But I also wouldn't overthink it too much :)
04:04:01 <tsahyt> merijn: I ended up finding a "solution" to the callback thing btw
04:04:10 <merijn> tsahyt: Nice :)
04:04:25 <tsahyt> I just don't use the API's way to do stateful things at all, I can just have an MVar or similar in a closure
04:04:52 <tsahyt> I still end up with leaking function pointers atm though :/
04:04:58 <kuribas> maybe FileFormats.Truetype
04:06:04 <tsahyt> and since my callback types need to be in IO anyway, it's not like I lose purity due to that. I lose purity because the library expects me to mutate state all over the place, which is rather annoying.
04:06:27 <kuribas> merijn: I'm in favour of a standardized namespace, but it should be well thought.  For example in the current proposal there is "Algebra", but not "Math".
04:06:42 <Laurenzo> hahahah...
04:08:26 <tsahyt> kuribas: why not Math.Algebra?
04:08:36 <kuribas> tsahyt: exactly
04:09:32 <kuribas> This guys proposed to eliminate typeclasses: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
04:10:13 <kuribas> Makes me wonder if typeclasses aren't overused.
04:10:37 <kuribas> Since you can often pass the interface functions as argument.
04:10:55 <merijn> kuribas: That's Tekmo and if you read it all you'll see he's not actually arguing that :p
04:11:34 <kuribas> "What I'm about to propose is that all Haskell type class programming can (and should) be implemented purely at the value level using a simple and ordinary code transformation."
04:12:11 <merijn> kuribas: And later on (as I remember) he states he doesn't seriously mean that
04:13:42 * hackagebot hw-eliasfano 0.1.0.0 - Elias-Fano  https://hackage.haskell.org/package/hw-eliasfano-0.1.0.0 (haskellworks)
04:13:44 <mthek> Does anyone here know if there is an EPUB version of the Haskell Language Report 2010?
04:14:10 <merijn> kuribas: Anyway, I don't think Tekmo seriously wants to delete typeclasses. The main point is that beginners tend to invent far too many typeclasses for problems better solved differently
04:14:13 <dmwit> We should replace typeclasses with records. Then we can introduce a `class Default a where def :: a` and have an instance for all the records we pass around (since it's annoying always constructing the record explicitly).
04:14:42 <dmwit> Then you get the best of both worlds: the compiler will construct a default record for you whenever you want, but if you need a different record you can choose it.
04:15:28 <dmwit> mthek: I think there is not. But HTML -> EPUB is an easy conversion that many tools will do.
04:15:47 <mthek> dmwit: thank you, will make a conversion then
04:16:22 <kuribas> :t sort
04:16:24 <lambdabot> Ord a => [a] -> [a]
04:17:03 <kuribas> like sort is redundant, since it's equal to "sortBy comparing".
04:17:08 <kuribas> :t sortBy comparing
04:17:10 <lambdabot> error:
04:17:10 <lambdabot>     • Couldn't match type ‘b -> Ordering’ with ‘Ordering’
04:17:10 <lambdabot>       Expected type: b -> b -> Ordering
04:17:16 * dmwit . o O ( It's not as if using `Control.Lens` instead of `Lens` really does much to solve the problem of "many lens libraries want the name `Control.Lens`". )
04:17:19 <kuribas> :t sortBy compare
04:17:21 <lambdabot> Ord a => [a] -> [a]
04:18:36 <dmwit> For a good example, you have to pick a name Foo where we have both Data.Foo and Control.Foo (or some similar second-level collision).
04:19:08 <kuribas> or namespace by package name...
04:19:47 <dmwit> No, removing the initial `Data.` and `Control.` and `Text.` from every package would have no effect on whether there were inter-package collisions, unless there were *also* second-level collisions.
04:20:12 <dmwit> So to be a good example of why `Data`, `Control`, and `Text` are important, you still need to point to a second-level collision.
04:20:39 <merijn> dmwit: Not if the first level is actually used
04:20:39 <ertesx> kqr: the containers API is one of my favourite APIs…  it understands its utility and use cases, it wants to be as efficient as possible, yet it remains wonderfully minimal and algebraic
04:21:07 <merijn> dmwit: A hypothetical Control.Pipes would collide with the existing Pipes in the pipes package
04:21:30 <dmwit> merijn: Yes, that's a good point. I would squint pretty hard at a package that declared a `Data`, `Control`, or `Text` module, though (other than the `text` package which is already pretty presumptious, but rightly so).
04:22:03 <dmwit> merijn: I wonder, do you have an example of such a collision?
04:22:10 <kuribas> dmwit: well in my example, Graphics.Rendering.Truetype would be different from Data.Truetype
04:22:21 <kuribas> or Graphics.Truetype
04:22:50 <merijn> dmwit: No, I was just pointing out that people shouldn't recklessly claim top level modules for their package without considering others that may want to potentially use that name
04:22:51 <dmwit> kuribas: I might argue that you have the hierarchy backwards.
04:23:09 <dmwit> kuribas: TrueType.Types, TrueType.Rendering, TrueType.Metrics
04:23:59 <kuribas> dmwit: what'rs Truetype.Types?
04:24:04 <dmwit> merijn: Yeah. It's just not clear to me that claiming a second-level module, under the usual `Data`/`Control` hierarchy is functionally different from claiming a top-level module.
04:24:16 <dmwit> kuribas: Your Data.TrueType
04:24:36 <kuribas> dmwit: that would include metrics...
04:24:56 <merijn> dmwit: Ambiguous names can be disambiguated by prefixes, although Data/Control aren't great for that
04:25:04 <merijn> dmwit: I'm not arguing Data.Foo is better than Foo
04:25:07 <dmwit> kuribas: Sure, whatever.
04:26:30 <dmwit> I dunno.
04:26:49 <dmwit> There is a sense in which the top-level bit of the hierarchy is somewhat informative to humans.
04:26:52 <ertesx> merijn: i only do that for very specific things…  "text" is a rather generic word, but if i'd call my web framework…  i don't know…  "Webby", i'd be comfortable claiming the "Webby" module (though personally i'd probably still use "Web.Webby")
04:27:01 <dmwit> It's just -- I can also see the argument that some people make for not having it.
04:27:06 <jmcarthur> Honestly I wish every module path was prefixed with the name of the package containing it. Like PackageImports, but mandatory and nicer looking.
04:27:08 <dmwit> I guess I'm still a bit undecided.
04:27:34 <hackrilege> classes are the most fundamental part of axiomatic inheritance in Haskell
04:27:35 <merijn> ertesx: Sure
04:27:50 <ertesx> in other words: if the word could be found in a dictionary (a general one or a programmer one), don't claim the top-level module
04:27:53 <merijn> ertesx: I was arguing in *favour* of using, e.g. Pipes
04:27:59 <ertesx> oh, sorry
04:28:00 <dmwit> jmcarthur++
04:28:25 <merijn> ertesx: I was just cautioning against claiming top level modules *without considering the "value" of said module name to others*
04:28:27 <ertesx> dmwit: then that was for you =)
04:28:42 <kuribas> dmwit: I am in favour of a standard namespace prefix, but one that is well thought.
04:28:43 <ertesx> ah, ok
04:29:16 <ertesx> none of this would be a problem, if -XPackageImports wasn't an extension
04:29:27 <kuribas> like Data only for CS data structures.
04:29:38 <ertesx> import "pipes" Pipes
04:30:12 <hackrilege> Identifying high order programming patterns and embedding the hierarchy of abstract functions canonically is one of the most useful aspects of Haskell.
04:30:29 <jmcarthur> If PackageImports wasn't an extension I think our module naming conventions would be very different (more terse overall).
04:30:31 <kuribas> and Control for generic typeclasses.
04:30:42 <ertesx> jmcarthur: yeah, and i'd like that
04:30:50 <jmcarthur> I meant it as a good thing.
04:31:01 <ertesx> yeah, i understood it that way =)
04:31:43 <jmcarthur> There's a downside I can imagine some people arguing, which is that the paths would be less discoverable, but IMO the Data.*/Control.* thing is not discoverable anyway.
04:31:55 <hackrilege> It's unfortunate that so many duplicate classes exist... Especially those surrounding iterators.
04:32:13 <ertesx> hackrilege: like which ones?
04:33:38 <hackrilege> Recursion and corecursion in pipe streams fixed point morphisms etc. Generators and consumers in pipes seems to be the same as fold/unfold or  mu/nu
04:33:43 * hackagebot vector-builder 0.2 - Vector builder  https://hackage.haskell.org/package/vector-builder-0.2 (NikitaVolkov)
04:34:20 <hackrilege> I guess the biggest is the Monad Monoid foldable debacle
04:34:22 <ertesx> hackrilege: ah, you mean there are many iteration concepts
04:35:09 <hackrilege> No, these are the same operations expressed in different ways, I can't identify the central classes
04:35:13 <mardden> hi, im just trying in my cli with ghci to execute the function addThree :: Int -> Int-> Int -> Int with addThree xyz = x +y +z like descriped here http://learnyouahaskell.com/types-and-typeclasses#believe-the-type
04:35:28 <mardden> but it tells me the type signature for addThree lack an accompanying binding
04:35:44 <ertesx> hackrilege: i'm not sure i follow…  do you have an example?
04:35:58 <jmcarthur> mardden: sounds like you typoed the name of the function in either the signature or the definition
04:36:04 <hackrilege> Eg a foldable alternative is a monadplus
04:36:21 <mardden> my cli tells me: Prelud> 
04:36:38 <ertesx> mardden: are you defining addThree in GHCi?  or are you loading a source file?
04:36:42 <mardden> im not able to enter the second line "addThree x y z = x + y + z  "
04:36:43 <hackrilege> unfold = duplicate, etc
04:36:47 <jmcarthur> mardden: definitions are by default allowed to exist without corresponding signatures, but signatures are not allowed to exist without corresponding definitions, hence the error message.
04:36:52 <mardden> im typing this just into Prelud>
04:36:55 <jmcarthur> mardden: ah, ghci
04:37:07 <jmcarthur> mardden: There are a few ways around this.
04:37:21 <jmcarthur> mardden: (1) Write this in a file to load in ghci instead of typing it in directly.
04:37:23 <ertesx> hackrilege: Foldable is something distinct, but yeah, Alternative and MonadPlus should be (and are treated as) the same thing with different specialisation
04:37:28 <jmcarthur> mardden: (2) Don't add the type annotation.
04:37:34 <ertesx> hackrilege: in general, avoid MonadPlus and just use Alternative
04:37:41 <jmcarthur> mardden: (3) Separate the signature from the definition with a semicolon in the same line
04:37:51 <mardden> thanks jmcarthur :)
04:37:59 <jmcarthur> mardden: (4) :{ \n <signature> \n <signature> \n :}
04:38:08 <jmcarthur> mardden: (where \n is an actual newline)
04:38:09 <kuribas> hackrilege: do you mean duplicate class methods?  like liftM == fmap, etc
04:38:11 <hackrilege> Am I right in thinking that if a hylomorphism expresses an inner product, that a pipe is an outer product?
04:38:37 <hackrilege> :t duplicate
04:38:37 <kuribas> hackrilege: those are hysterical raisins.
04:38:39 <lambdabot> error:
04:38:39 <lambdabot>     • Variable not in scope: duplicate
04:38:39 <lambdabot>     • Perhaps you meant one of these:
04:39:19 <hackrilege> :t Control.Comonad.duplicate
04:39:21 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
04:39:34 <ertesx> hackrilege: hylomorphisms inner products?  how does that work?  i think hylomorphisms are just compositions of catas and anas
04:40:07 <hackrilege> Right, and a pipe is a composition of ana and cata (inside out)
04:40:08 <jmcarthur> I've been using hindent for a couple months now, and at least with the tibell style I think it's just awful formatting.
04:40:31 <jmcarthur> Does anybody use hindent with a style that doesn't look like it's the output of a hastily written code generator?
04:40:53 <tdammers> jmcarthur: I'm still not using any auto-indenters at all, for any language really
04:41:01 <tdammers> every time I tried, they end up disappointing me
04:41:04 <tdammers> all of them
04:41:37 <jmcarthur> I think autoindenters are often fine. It's more pervasive styling changes that I haven't found a good tool for yet.
04:41:50 <tdammers> well, except maybe those for C# of Java, where the syntax is so redundant that you absolutely don't need to rely on indentation as a means of expression
04:42:10 <jmcarthur> e.g. I use an autoindenter at work that I basically always agree with.
04:42:50 <jmcarthur> Yeah. Many such languages don't even require newlines.
04:43:00 <hackrilege> Which is the bottom level, can't I identify generators and consumers as fundamental and create hylomorphisms out of that?
04:43:59 <jmcarthur> I like the idea of autoformatting a lot. It removes a lot of distracting tedium from coding, and standardizing is great.
04:44:13 <mardden> jmcarthur: (1) works for me thanks, (2) I dont enter the type defention of the addTree function and enter "Prelude> addThree x + y + z" but it tells me addThre,x,y,z is not in scope
04:44:46 <tdammers> I do like the idea too, but at least in languages like Haskell, Python, or JavaScript, which is what I use most the time these days, whitespace seems to convey too much information to throw away
04:44:51 <jmcarthur> mardden: That doesn't fit the format of a definition. You will at least need an '=' character in there somewhere.
04:44:58 <hackrilege> Or foldable and unfoldable, it monad and comonad. Which is the underlying phenomena? How do we organise these hysterical raisins?
04:45:32 <hackrilege> s/it/or
04:46:03 <mardden> jmcarthur: with "Prelude> addThree x y z = x + y + z" i get "<interactive>:1:15: parse error on input `='"
04:48:44 * hackagebot vector-builder 0.3 - Vector builder  https://hackage.haskell.org/package/vector-builder-0.3 (NikitaVolkov)
04:49:08 <MarcelineVQ> mardden: likely in this case that means your ghci version isn't the very latest, so you'll need to write: let addThree x y z = x + y + z
04:50:01 <mardden> great thanks MarcelineVQ ! that works for me
04:52:25 <mardden> is there somehting build in like man functionname?
04:52:43 <mardden> so i can lookup the documentation from cli for example for product
04:53:35 <ertesx> hackrilege: the "fundamental" folds and unfolds are not entirely fundamental:  they are based on algebras and coalgebras, and if you want to know how they work, you might be interested in reading "bananes, lenses, (something else) and barbed wire"
04:53:43 <ertesx> by richard bird
04:54:08 <ertesx> hackrilege: however, those don't account for *effectful* folds and unfolds
04:54:19 <ertesx> what you might call "stream processing"
04:55:40 <ertesx> hackrilege: free monad transformers (potentially with cofree comonad transformers) come closer to the essence of what the fundamental folds and unfolds are
04:56:26 <MarcelineVQ> mardden: I'm not sure, usually I'll look things up on https://www.haskell.org/hoogle/ or http://hayoo.fh-wedel.de/ which let you search for documentation for functions by name but also let you search by type signature
04:56:46 <mardden> thanks MarcelineVQ 
04:57:12 <MarcelineVQ> @hoogle [a] -> Int -- this kind of signature
04:57:12 <lambdabot> GHC.OldList length :: [a] -> Int
04:57:12 <lambdabot> Prelude length :: [a] -> Int
04:57:12 <lambdabot> Data.Edison.Seq.ListSeq size :: [a] -> Int
04:58:00 <ertesx> hackrilege: in other words: there is a trade-off between generality and practicality…  free monads are great, but for the most part, you probably want to do your stream processing with pipes anyway
04:58:17 <ertesx> (or conduit or <insert your favourite streaming framework here>)
05:00:32 <ertesx> hackrilege: this goes far beyond just representing folds and unfolds…  for example: what is a parser?  if you interpret parsers as something that turns something 1-dimensional into something 2-dimensional, you can generalise even the notion of parsers
05:05:02 <ertesx> hackrilege: BTW, if you stay in pure land, you might find the 'recursion-schemes' library interesting
05:05:19 <hackrilege> Thanks
05:07:18 <hackrilege> What's codensity transformation?
05:07:49 <ertesx> it turns a monad into CPS for the sake of right-associating all (>>=)
05:07:59 <ertesx> see the 'kan-extensions' package
05:08:21 <ertesx> Control.Monad.Codensity
05:10:23 <hackrilege> Hey, recursion schemes looks perfect, why are pipes conduit streams etc not written in these terms?
05:10:41 <ertesx> because they are specialised to streams anyway
05:10:57 <ertesx> if you're looking for something more generic, look into free monads
05:11:25 <hackrilege> I wrote duplicate for Free Zipper
05:11:27 <ertesx> i.e. the 'free' package
05:13:08 <hackrilege> http://lpaste.net/194212
05:14:50 <merijn> hackrilege: Do you know DList?
05:15:21 <hackrilege> merijn, yes, and build
05:15:38 <hackrilege> Using that idea leads to [[]] as a Zipper
05:15:45 <merijn> hackrilege: codensity is basically DList generalised to arbitrary recursive datatypes
05:15:53 <merijn> hackrilege: i.e. a CPS representation
05:16:54 <hackrilege> http://lpaste.net/252794
05:17:46 <hackrilege> I can't find links to CPS representations
05:19:02 <hackrilege> Bracketing off subsections...
05:22:24 <hackrilege> Sorry, got disconnected
05:22:59 <hackrilege> I can't find much about how codensity is a generalisation of sequence...
05:23:47 <hackrilege> Just; Asymptotic Improvement of
05:23:48 <hackrilege> Computations over Free Monads
05:27:53 <merijn> hackrilege: huh? I don't understand what sequence has to do with things?
05:28:09 <hackrilege> I thought it was like dlist
05:28:28 <hackrilege> I may be confused
05:28:30 <merijn> I don't understand what DList has to do with sequence either?
05:28:35 <hackrilege> Nvm
05:28:43 <hackrilege> Assume I meant dlist
05:29:03 <hackrilege> How it's codensity the generalisation of dlist
05:29:08 <hackrilege> ?
05:29:34 <hackrilege> (I'm looking for reference material)
05:31:17 <hackrilege> I guess i start by understanding kan extensions...
05:31:39 <merijn> I would actually do DList first, then codensity from the Asymptotic Improvement paper
05:31:46 <merijn> I still don't understand kan extensions
05:31:54 <hackrilege> I know dlist
05:32:50 <hackrilege> It's about ordering the infix dataconstructors
05:33:22 <hackrilege> I don't get how that is related to density
05:33:50 <merijn> DList is a CPS encoding of lists
05:35:31 <hellertime> can hp2ps render the full callsite name? I tried a multi-page render, and it still truncates the callsite names
05:36:28 <ertesx> there was a paper about this somewhere
05:36:32 <ertesx> but i can't remember where
05:36:35 <hackrilege> What does CPS stand for and where can I learn about it?
05:36:42 <merijn> Continuation Passing Style
05:37:07 <hackrilege> And that's more clearly related to codensity?
05:37:32 <ertesx> hackrilege: newtype Codensity m a = Codensity { lowerCodensity :: forall r. (a -> m r) -> m r }
05:37:37 <ertesx> hackrilege: what does this remind you of?
05:37:51 <ertesx> just by looking at the shape of it
05:38:21 <hackrilege> I find; https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Cont.html
05:38:58 <ertesx> hackrilege: yeah, it's very similar to ContT…  in fact (Codensity m) is just 'm', but all results are passed via continuations
05:39:02 <hackrilege> :t return mempty
05:39:03 <lambdabot> (Monoid a, Monad m) => m a
05:39:27 <ertesx> hackrilege: this has one interesting effect:  look at the Monad instance of (Codensity m)
05:39:28 <ertesx> not the implementation
05:39:30 <ertesx> just the instance head
05:39:38 <ertesx> instance Monad (Codensity m)  -- do you notice something?
05:41:00 <hackrilege> The lack of monad constraint on m
05:41:08 <hackrilege> ?
05:41:15 <ertesx> exactly…  (>>=) of Codensity is completely unrelated to the monad m
05:41:36 <ertesx> all uses of m-effects are explicit and in such a way that (>>=) is always right-associated
05:42:06 <ertesx> it's similar to DList, as merijn mentioned:  (.) is completely unrelated to (++)
05:42:25 <hackrilege> Ok
05:42:29 <hackrilege> Nice
05:43:38 <hackrilege> I was using [[]] as a Zipper in the paste, I guess i could use Dlist :+: Dlist or Codensity somehow
05:43:53 <hackrilege> I guess i should get used to using it first
05:44:16 <ertesx> that doesn't sound like a good idea
05:44:27 <hackrilege> Maybe (.) Instead of (++) isn't what I need for zippers, but maybe whatever they make will be cool
05:44:28 <merijn> I'm not sure that even makes sense?
05:44:28 <merijn> ls
05:44:52 <ertesx> hackrilege: the reason is that with a typical zipper use case construction is interleaved with pattern-matching, which makes DList a bad choice
05:45:15 <ertesx> hackrilege: search for "reflection without remorse"
05:45:20 <tabaqui1> has anybody tried to cross-compile ghc?   
05:45:25 <tabaqui1> from linux for win    
05:45:31 <tabaqui1> i get this error when trying i686 or x86_64 mingw: 
05:45:32 <tabaqui1> error: storage size of ‘test_array’ isn’t constant  
05:45:32 <tabaqui1> in Types.hsc    
05:45:34 <tabaqui1> /usr/bin/x86_64-w64-mingw32-gcc -v   
05:45:37 <tabaqui1> gcc version 6.2.1 20160830 (GCC) 
05:45:37 <hackrilege> I thought it just meant the pattern matching was over subsections
05:46:01 <ertesx> hackrilege: i think two lists is fine for a sequence zipper
05:47:14 <delYsid> I have a class CharParsing m => BrailleParsing m, how do I add a MonadReader with a certain env type to that?  Is class (MonadReader (Char -> Maybe Char) m, CharParsing m) => BrailleParsing m, OK, or is it strange to put concrete types in classes?
05:47:27 <hackrilege> No I need Zipper = Free [] for my application
05:48:46 * hackagebot mysql 0.1.3 - A low-level MySQL client library.  https://hackage.haskell.org/package/mysql-0.1.3 (paulrouse)
05:48:53 <hackrilege> So that iterative partitioning like a binary partition tree can be used to rapidly navigate a structure and record navigational changes upon reconfiguration
05:49:09 <hackrilege> ... I'm paraphrasing sorry
05:50:35 <hackrilege> I have to head out, I'll pick this up later agree I have read some of this material
05:50:42 <hackrilege> After*
05:57:53 <joe9> need some advice, please? I have a library (I am calling it from an async thread) whose stdout and stderr, I want to redirect/capture. "silently" captures the global output instead of just the output of the async thread.
05:58:03 <joe9> whereas, io-capture is not working reliably with async
05:58:36 <joe9> just want to check if there is a way to capture the thread's stdout and stderr
05:58:39 <merijn> joe9: There is only one stdout/stderr
05:58:47 <merijn> joe9: You can't "redirect" a libraries output
05:59:06 <merijn> Both are global to your entire process
06:00:23 <joe9> my code is https://github.com/joe9/9pserver/blob/master/test/Spec.hs#L22 merijn. Any suggestions on how I can avoid the output getting scrambled
06:00:39 <ph88^> is it possible to use GHC.Generics to write a transform function that traverse a graph of different types and only does something to the matched type ?
06:00:51 <joe9> I can use a logging library or logger functions. but, these are traceShowId functions used for debugging
06:01:09 <merijn> Define scrambled?
06:01:26 <merijn> ph88^: I think so? Isn't that what uniplate does?
06:02:32 <joe9> merijn: scrambled output: https://paste.pound-python.org/show/O2UqQqmymGm4Nu8Ir1lA/ normal output https://paste.pound-python.org/show/55UYxD55bCWLQZtNBZec/
06:03:54 <ph88^> merijn, yes uniplate does that, but afaik uniplate is not using GHC.Generics
06:04:30 <ph88^> merijn, i wanted to try to implement a function similar to uniplate transformBi with GHC.Generics
06:05:05 <merijn> joe9: The only thing I can think of is printing to files instead of to stdout/stderr
06:05:17 <joe9> merijn:  ok, Thanks.
06:32:30 <joncol> I'm wondering about a small snippet to find the major axis of a 3D vector. I came up with the second version here: http://pastebin.com/8bRyN440, which I like a bit more than the first pyramid of doom. Is there another, simpler/better way?
06:37:20 <ph88^> joncol, try guards
06:37:43 <joncol> ph88^: Ah, always forget about those.
06:39:02 <cobreadmonster> Hello!
06:39:06 <sbrg> joncol: well, the second way is pretty nifty, but you could certainly make it "simpler" by just using something like: foo (x, y, z) = maximumBy (abs . fst) $ zip "XYZ" [x,y,z] or something along those lines.
06:40:46 <sbrg> > let foo (x, y, z) = maximumBy (comparing (abs . fst)) $ zip [x,y,z] "XYZ" in foo (3, 4, 5)
06:40:48 <lambdabot>  (5,'Z')
06:41:27 <ph88^> > let foo (x, y, z) = maximumBy (comparing (abs . fst)) $ zip [x,y,z] "XYZ" in snd $ foo (3, 4, 5)
06:41:28 <sbrg> well, simpler and simpler. they're pretty similar, I guess.
06:41:30 <lambdabot>  'Z'
06:48:49 * hackagebot mywatch 0.2.1 - Web application to view and kill MySQL queries  https://hackage.haskell.org/package/mywatch-0.2.1 (ip1981)
06:56:11 <ertesx> joncol: if you use the 'linear' package, it becomes:  maximumBy (comparing quadrance) . scaled
06:57:24 <ertesx> maximumBy (comparing quadrance) (scaled (V3 1 2 3)) = V3 0 0 3
07:02:24 <Jet4Fire> Hello!
07:03:18 <ph88^> hai
07:08:49 * hackagebot polysoup 0.6.3 - Online XML parsing with polyparse and tagsoup  https://hackage.haskell.org/package/polysoup-0.6.3 (JakubWaszczuk)
07:10:40 <c_wraith> :t partitionEithers
07:10:42 <lambdabot> [Either a b] -> ([a], [b])
07:11:40 <c_wraith> > take 2 . snd . partitionEithers $ Right 1 : Right 2 : Right 3 : Left "?" : undefined
07:11:42 <lambdabot>  [1,2]
07:12:00 <c_wraith> > take 2 . fst . partitionEithers $ Right 1 : Right 2 : Right 3 : Left "?" : undefined
07:12:03 <lambdabot>  ["?"*Exception: Prelude.undefined
07:12:36 <LordBrain> need the IsString there i guess
07:15:02 <piyush-kurur> story of randomness: arc4random about 300 times faster than /dev/urandom on linux
07:16:56 <c_wraith> piyush-kurur: story of randomness: arc4random can be predicted from a small portion of its output. /dev/urandom can't
07:18:01 <piyush-kurur> c_wraith: arc4random does not use arc4 by the way
07:18:08 <piyush-kurur> if that is what you ment
07:18:54 <amx> The arc4random() function uses the key stream generator employed by the arc4 cipher, which uses 8*8 8 bit S-Boxes.
07:18:59 <amx> don't you mean that one?
07:21:31 <piyush-kurur> amx: no arc4 on openbsd and it seems on linux to (via -lbsd) uses chacha20
07:21:31 <nevere> Using Opaleye, How can I insert a custom type like "data Gender = Male | Female", into  the database using Opaleye.Constant as described in this page https://hackage.haskell.org/package/opaleye-0.5.1.1/docs/Opaleye-Constant.html#t:Constant?
07:26:37 <piyush-kurur> amx: i meant arc4random now uses chacha20 (except perhaps on freebsd)
07:27:16 <piyush-kurur> only pain point is that it requires bsdlib to be installed 
07:29:27 <joncol> sbrg: Cool, didn't know about maximumBy
07:33:51 * hackagebot hreader-lens 0.1.0.0 - Optics for hreader package  https://hackage.haskell.org/package/hreader-lens-0.1.0.0 (dredozubov)
07:37:15 <nevere> Why is 'D.Default' and 'Constant' in qutotes in this signature http://lpaste.net/303140?
07:44:25 <et09> is there a 'proper' approach to handle a persistent database connection?
07:44:35 <et09> which may fail intermittently etc?
07:47:42 <sham1> JDBC
07:48:06 <sham1> wait no
07:48:09 <sham1> Scrap that
07:48:12 <sham1> Wrong channel
07:48:39 <c_wraith> et09: nothing magical.  Just use a pool that refills itself when connections die.
07:48:45 <amx> et09: Data.Pool
07:49:31 <et09> i should ask, does Database.Redis (hedis) handle this?
07:50:59 <et09> ah n/m docs answered
07:53:17 <amx> hedis has a dependency on resource-pool, so it probably does the right thing
07:59:49 <et09> not sure i understand OverloadedStrings correctly - it doesn't basically just make strings automagically dyanmically typed to various string types, right?
08:00:02 <ph88^> is it possible to use GHC.Generics to write a transform function that traverse a graph of different types and only does something to the matched type ?
08:00:38 <grantwu> et09: I think it tries to figure it out at compile time.
08:00:48 <et09> it doesn't work in GHCi does it
08:01:51 <amx> et09: it does work in ghci
08:02:11 <amx> ghci -XOverloadedStrings
08:02:43 <et09> nice
08:02:46 <et09> got it
08:02:57 <et09> no more BS.pack for me
08:03:24 <MarcelineVQ> you can also type in a running sessions :set -XOverloadedStrings
08:03:31 <et09> i see 
08:03:52 <MarcelineVQ> it even has tab completion :>
08:03:59 <geekosaur> et09, note that it applies only to string constants
08:04:18 <et09> as opposed to what?
08:04:27 <geekosaur> it will not automagically convert the result of a functon producing a String to a Text for you, for eample
08:04:34 <geekosaur> only string constants like "foo"
08:04:44 <et09> oh i see
08:06:59 <et09> best practice for regex search & replace on ByteString
08:07:00 <et09> ?
08:07:48 <amx> dont
08:07:49 <amx> hehe
08:08:35 <et09> its actually a simple issue, strip any occurence of 1 of 2 characters from the beginning of a string until no longer present... regex not required
08:08:41 <et09> just being lazy
08:09:40 <amx> convert the BS to Text by decoding it with the correct charset, then operate on that
08:11:44 <geekosaur> BS.dropWhile (`elem` ordsToDrop) ?
08:12:48 <et09> geekosaur++ 
08:14:04 <sham1> Bullshit packing can be annoying
08:14:23 <et09> ^ i was just waiting for that
08:16:37 <suppi> anyone knows how can i convert bytestrings coming from postgresql-simple's 'copy' to data types that have FromRow instance?
08:16:55 <grantwu> I think this only works for certain encodings
08:17:24 <grantwu> and fails completely for codepoints not encoded to a single byte
08:18:47 <suppi> grantwu: what do you mean?
08:18:59 * hackagebot pandoc-placetable 0.4.1 - Pandoc filter to include CSV files  https://hackage.haskell.org/package/pandoc-placetable-0.4.1 (mb21)
08:20:06 <geekosaur> I'm confused by this. afaict ByteString is only used for feeding it, never received as output?
08:20:14 <grantwu> suppi: Sorry, in response to geekosaur's idea
08:20:35 <grantwu> suppi: Unrelated to your question
08:20:52 <geekosaur> grwntwu, it's a ByteString. ordsToCopy :: [Word8]
08:20:57 <geekosaur> er, ordsToDrop
08:21:21 <suppi> grantwu: alright. thanks.
08:21:32 <geekosaur> any encoding issues have to be dealt with elsewhere
08:22:27 <grantwu> Right, well, et09 didn't say "I want to drop all occurences of one of 2 Word8s from the beginning of a ByteString", they said "I want to drop... one of 2 characters"
08:23:24 <geekosaur> yes, well, that's going to be their problem regardless :)
08:23:55 <geekosaur> they have to figure out what they really mean by that *before* they get to that point
08:23:59 * hackagebot aivika-transformers 4.5.1 - Transformers for the Aivika simulation library  https://hackage.haskell.org/package/aivika-transformers-4.5.1 (DavidSorokin)
08:24:01 * hackagebot aivika-realtime 0.1 - Soft real-time simulation module for the Aivika library  https://hackage.haskell.org/package/aivika-realtime-0.1 (DavidSorokin)
08:24:12 <grantwu> amx did suggest going through Text
08:24:32 <et09> best practices for nesting two case statements which both have Just/Nothing?
08:24:37 <grantwu> You might be able to hack something together with https://hackage.haskell.org/package/utf8-string-1.0.1.1/docs/Data-ByteString-UTF8.html
08:24:47 <et09> for the result of a fn
08:25:02 <et09> applied to the input of each 
08:25:11 <geekosaur> depends on what you're doing with it. could be a good place to use the Monad instance
08:25:32 <et09> is that...Monad Either?
08:25:36 <geekosaur> or Functor or Applicative, depending
08:25:48 <geekosaur> why would it be Either?
08:26:04 <geekosaur> @src Maybe (>>=)
08:26:04 <lambdabot> (Just x) >>= k = k x
08:26:04 <lambdabot> Nothing  >>= _ = Nothing
08:26:06 <et09> a guess, n/m
08:46:49 <kuribas> :t (<$>)
08:46:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:46:56 <kuribas> :t (<*>)
08:46:58 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:48:05 <kuribas> (+) <$> Just 1 <*> Just 2
08:48:07 <kuribas> > (+) <$> Just 1 <*> Just 2
08:48:10 <lambdabot>  Just 3
08:49:01 * hackagebot servant 0.9.1 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.9.1 (jkarni)
08:49:09 * hackagebot servant-server 0.9.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.9.1 (jkarni)
08:49:09 * hackagebot servant-client 0.9.1 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.9.1 (jkarni)
08:49:09 * hackagebot servant-docs 0.9.1 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.9.1 (jkarni)
08:49:09 * hackagebot servant-foreign 0.9.1 - Helpers for generating clients for servant APIs in any programming language  https://hackage.haskell.org/package/servant-foreign-0.9.1 (jkarni)
08:49:12 <ph88^> what does this do? https://wiki.haskell.org/GHC/GHCi#Hlint
08:50:03 <sham1> It seems to be that it allows you to use hlint from GHCi
08:50:25 <ph88^> for which code though ?
08:50:26 <MarcelineVQ> Mostly it lets you know when you're being more verbose than you need to be
08:52:03 <ph88^> does it give suggestions about the last entered thing ?
08:52:08 <ph88^> or you have to use a command ?
08:53:00 <geekosaur> it defines a :hlint command
08:54:06 <ph88^> and the :hlint command checks the thing entered before it ?
08:54:39 <geekosaur> no, looks to me like it checks the modules currently in scope
08:55:01 <ph88^> ooh
09:00:24 <Welkin> how do I use Network.Wai.Parse to get a file from multipart/form-data?
09:00:31 <Welkin> the docs are confusing and offer no explanation
09:00:46 <Welkin> http://hackage.haskell.org/package/wai-extra-3.0.19/docs/Network-Wai-Parse.html
09:01:28 <Welkin> sinkRequestBody :: BackEnd y -> RequestBodyType -> IO ByteString -> IO ([Param], [File y]) 
09:02:07 <c_wraith> why not http://hackage.haskell.org/package/wai-extra-3.0.19/docs/Network-Wai-Parse.html#v:parseRequestBodyEx? 
09:02:34 <Welkin> either way, I still am not sure how to use anything there
09:02:45 <Welkin> why does lbsBackEnd have 2 ignored parameters?
09:03:00 <Welkin> and what does it produce?
09:03:18 <Welkin> what is with RequestBodyType too?
09:03:25 <Welkin> Multipart ByteString
09:03:31 <Welkin> what is the ByteString supposed to be?
09:04:16 <nevere> What is the term 'haskells' that can be seen in this page https://hackage.haskell.org/package/opaleye-0.5.1.1/docs/Opaleye-Constant.html and why is it called so?
09:05:03 <c_wraith> Welkin, did you look at the expansions of Backend and File?
09:05:24 <c_wraith> those seem like they should answer your questions 
09:05:25 <Boomerang> I think it refers to haskell types as opposed to SQL types (the PG types)
09:05:59 <nevere> Boomerang: what are haskell types?
09:06:34 <geekosaur> ...
09:06:41 <Boomerang> you can see which haskell types correspond to which PG types in the link you sent, look at all the Default Constant instances
09:07:24 <geekosaur> it appears to mean: values, as represented in your Haskell program as opposed to the form PostGres expects to receive. (the whole point of it is to convert between those)
09:07:35 <Boomerang> Taking a simple example, the haskell Bool type corresponds to the opaleye (Column PGBool) type
09:10:14 <et09> geekosaur: the problem mentioned above was "if the suffix exists, delete it, and then if the prefix exists, delete it"
09:10:37 <et09> the return value has to be the string with whatever parts removed
09:15:53 <joe9> any haskell tasty users? How do you redirect the output to a file?
09:19:32 <hseg> Is there any way to define replicate :: KnownNat n => a -> [Vec n a] without using type classes?
09:20:21 <Boomerang> joe9: are you on linux? You could do something like "stack test > test.log" or "stack test | tee test.log"
09:21:17 <joe9> Boomerang: Thanks for the suggestion. I am on linux. https://github.com/joe9/9pserver/blob/master/test/Spec.hs#L21 . My problem is that the main program server that I am running has traceShowId's which are writing to the stdout/stderr.
09:21:35 <joe9> With tasty also outputting to the console, the output  is garbled.
09:21:56 <joe9> I cannot figure out how to get tasty to log to a file or something else so I can cat its contents at the end.
09:22:19 <joe9> the main program cannot be changed as they are just traceShowId's which will be removed later.
09:22:23 <Boomerang> try "stack test &> test.log" to redirect both stdout and stderr to the file
09:22:24 <joe9> Boomerang: Does that make sense?
09:22:47 <Boomerang> Oh you meant without the traceshoIds?
09:22:49 <EvanR> what is this: http://lpaste.net/303471
09:23:06 <EvanR> class Huh z where mapMap :: (forall a . f a -> g a) -> z f -> z g
09:23:29 <joe9> Boomerang: this is how the output is: with stack test &>/tmp/test.log https://gist.github.com/4e78f80004b6dd8d5e2a3220f85d8f35
09:23:46 <joe9> it is because 2 threads are writing to the same stdout channel
09:23:52 <joe9> geekosaur: any thoughts, please?
09:23:57 <hseg> EvanR: Seems to be a Functor-like typeclass, where z is a "Functor" of kind (* -> *) -> k for some k.
09:24:34 <hseg> ... For that matter, is there any way of working with type-level Nats without using typeclasses all over the place?
09:25:19 <Boomerang> joe9: I'm not sure what to suggest, could you disable traceShowIds when testing?
09:26:55 <joe9> Boomerang: https://github.com/feuerbach/tasty/issues/101#issuecomment-76059783 seems to be the answer
09:27:03 <joe9> Boomerang: sorry for the bother.
09:27:46 <Boomerang> hseg: to define your replicate are you using clash-prelude? you could chain repeat from clash prelude and repeat from prelude to get what you want
09:27:56 <Boomerang> hseg: to define your replicate are you using clash-prelude? you could chain repeat from clash prelude and repeat from prelude to get what you want
09:28:11 <Boomerang> (sorry for the repeated send)
09:28:16 <Boomerang> https://hackage.haskell.org/package/clash-prelude-0.10.14/docs/CLaSH-Sized-Vector.html#v:repeat
09:28:24 <hseg> Boomerang: No, I'm just writing a small self-contained script
09:29:02 * hackagebot profiteur 0.3.0.3 - Treemap visualiser for GHC prof files  https://hackage.haskell.org/package/profiteur-0.3.0.3 (JasperVanDerJeugt)
09:29:11 <Boomerang> hseg you can look at the source code to see how it's implemented in the library
09:29:20 <hseg> My thoughts exactly.
09:29:25 <hseg> Thanks for the pointer
09:29:25 <Boomerang> :)
09:31:07 <joe9> Boomerang:  it seems to be a stack issue. When I run it using ghci, it works fine.
09:33:40 <Welkin> c_wraith: still working out some nonsense errors, but thanks for the tip
09:34:40 <et09> can you dip into a module and override something like you can in ruby
09:34:41 <Welkin> • No instance for (Num ByteString)
09:34:50 <Welkin> et09: no
09:36:21 <Welkin> any idea what the issue could be here?
09:36:22 <Welkin> http://lpaste.net/4591564547617193984
09:36:49 <EvanR> et09: haskell tends to stop you from doing anything else besides throwing a terrible plan out and rethinking it entirely ;)
09:37:21 <EvanR> its not amenable to monkey patching
09:39:05 <Boomerang> Welkin I think the literal 86400 isn't a bytestring
09:40:00 <Welkin> thanks Boomerang 
09:40:01 <Boomerang> :)
09:40:07 <Welkin> the ways I was dealing with headers in servant messed me up there
09:40:19 <Welkin> in that case, it is an Int
09:40:39 <Boomerang> You should be able to just put quotes around it and since you're using -XOverloadedStrings it should work
09:40:45 <et09> lol
09:40:53 <et09> fair enough
09:41:18 <et09> you can imagine an occasional time where it's useful i suppose 
09:42:04 <Boomerang> It is sometimes useful to add instances that missing in the original module and you can do that but you get warnings
09:42:49 <kirillow> What would this function look like: co :: (b -> c) -> (a -> b) -> (a -> c)
09:43:08 <Boomerang> :t (.)
09:43:09 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:43:17 * geekosaur smells homework
09:43:25 <Boomerang> oh :o
09:44:09 * kirillow smells working through a book on haskell completely of my own will :D
09:44:19 * kirillow also smells not being really good at it
09:44:46 <EvanR> et09: i try to forget those times
09:45:17 <EvanR> because when someone (you) tries to go back and do another monkey patch next week, or next month, it all explodes in your face
09:45:30 <Welkin> et09: perhaps you would like node and npm
09:45:40 <geekosaur> evidently. of course the point of those questions is for you to work through them and figure out what they mean, not ask the nearest IRC channel to do it for you
09:45:50 * et09 insulted
09:46:09 <EvanR> does node even allow that?
09:46:31 <kirillow> evidently. of course this is what i did. here im stuck however
09:46:57 <grantwu> @help modules
09:46:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:47:02 <grantwu> @help list
09:47:02 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
09:47:05 <grantwu> ...
09:47:07 <Welkin> any idea why I am getting an overlapping patterns warning?
09:47:07 <Welkin> http://lpaste.net/4591564547617193984
09:47:18 <grantwu> Well, I swore lambdabot had a thing to automagically synthesize functions
09:47:33 <Welkin> methodPost/methodOptins are just bytestrings "POST" and "OPTIONS"
09:47:33 <Boomerang> kirillow think about function composition from maths and how you use 2 functions in a row
09:47:42 <Welkin> grantwu: @djinn
09:47:51 <grantwu> @djinn co :: (b -> c) -> (a -> b) -> (a -> c)
09:47:52 <lambdabot> Cannot parse command
09:47:57 <grantwu> @djinn (b -> c) -> (a -> b) -> (a -> c)
09:47:57 <lambdabot> f a b c = a (b c)
09:48:36 <kirillow> the what.
09:48:46 <kirillow> thanks though
09:48:55 <grantwu> hrm
09:48:58 <grantwu> @pl f a b c = a (b c)
09:48:58 <lambdabot> f = (.)
09:49:08 <grantwu> oh shit.
09:49:28 <tdammers> hehe
09:49:46 <tdammers> You Could Have Invented Composition (And Maybe You Already Have)
09:51:19 <Welkin> any idea? http://lpaste.net/4591564547617193984
09:52:02 <Boomerang> Yes Welkin, I think you're not pattern matching on "methodOptions" and "methodPost", you're binding a name to whatever value comes out of the case statement
09:52:06 <daniel-s> Hi. In haskell a functor is a type that is an instance of functor. In this book [1] about category theory it says functors can be used to map between categories. [1] https://www.amazon.com/Category-Theory-Sciences-MIT-Press/dp/0262028131
09:52:17 <daniel-s> Are functors in haskell the same thing as in category theory?
09:54:03 * hackagebot RNAlien 1.2.5 - Unsupervized construction of RNA family models  https://hackage.haskell.org/package/RNAlien-1.2.5 (FlorianEggenhofer)
09:54:11 <kirillow> Aaaaaaaaaaaaaaaaaaah I got it m((( Thanks a bunch!
09:54:17 <Welkin> thank Boomerang, that was it
09:55:11 <lpaste> Boomerang revised “No title”: “Welkin try this” at http://lpaste.net/4591564547617193984
09:55:14 <EvanR> daniel-s: Functors in haskell are endofunctors between Hask and itself
09:55:20 <`^_^v> daniel-s: in the most common interpretation, functors in haskell are endofunctors in the Haskell category
09:55:47 <EvanR> what is Hask, good question
09:57:24 <EvanR> Maybe is a functor, it takes types to types, and fmap maps maps on a to maps on Maybe a
09:58:12 <EvanR> ... maps a -> b's to Maybe a -> Maybe b's
09:58:45 <EvanR> the fact that Maybe a is not in some other category makes it not as general as category theory
09:59:03 * hackagebot pipes-interleave 1.1.0 - Interleave and merge streams of elements  https://hackage.haskell.org/package/pipes-interleave-1.1.0 (BenGamari)
10:08:40 <joe9> Can anyone please help me with this buffering issue? http://dpaste.com/3JW8KXM is the program. output https://paste.pound-python.org/show/ezo1CSBZAPi6RI4ukUh2/
10:09:00 <joe9> I cannot figure out why the putStrLn within the "serve" function do not get written
10:09:11 <joe9> such as line 48
10:18:00 * geekosaur would guess stdout there is not what you expect... but Network.Simple.TCP doesn't seem to redirect them, so don't know what is. (I would suspect it's the socket... try dumping what it receives)
10:18:33 <geekosaur> except that it's not per thread, so... ?
10:20:36 <glguy> joe9: Did you successfully connect to the port that serve was listening on?
10:21:08 <glguy> If not, you'd have to connect to that port to get it to print, if so you might not be executing the same version of the code you're looking at
10:23:24 <joe9> glguy: I am getting this printed " Connection established to 127.0.0.1:5961" , that is making me think that I am connecting to the socket.
10:23:29 <Welkin> this is strange
10:23:53 <Welkin> I am not getting any files when I use parseRequestBody from Network.Wai.Parse
10:24:07 <Welkin> even though I am sending the file as multipart/form-data
10:24:14 <Welkin> when I parse it, I get an empty list
10:25:34 <lpaste> bryan_ pasted “how does head.hs run in constant space?” at http://lpaste.net/303727
10:26:19 <glguy> bryan_: getContents reads the stdin lazily
10:27:05 <bryan_> glguy: but since /dev/zero will never output a newline, isn't the runtime saving up the chunks read so far so that when it does find a newline it can give back the entire "line" read so far?
10:27:28 <EvanR> @src unlines
10:27:28 <lambdabot> unlines = concatMap (++ "\n")
10:27:34 <glguy> bryan_: lines doesn't need to find a newline to start producing a line
10:27:45 <EvanR> @src lines
10:27:45 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:27:47 <joe9> glguy: you are correct, I do not think it is connecting to that port.
10:27:48 <EvanR> :(
10:28:22 <Tuplanolla> :t System.IO.Unsafe.unsafeInterleaveIO -- Let me introduce you to a new friend, bryan_.
10:28:24 <lambdabot> IO a -> IO a
10:28:42 <geekosaur> Tuplanolla, that isn't really the question
10:28:57 <geekosaur> everything there can produce partial output, there is no need for buffering
10:28:57 <joe9> glguy: output https://paste.pound-python.org/show/skWJrrxPW6C8alYf3JyM/ , program: http://dpaste.com/0JR2TJZ . Thanks for the suggestion.
10:29:15 <glguy> > head (head (lines ('a':undefined)))
10:29:18 <lambdabot>  'a'
10:29:34 <et09> what's the preferred AWS suite (if applicable)?
10:29:40 <glguy> bryan_: Observe that lines can produce the first element of the first line without considering the tail of that list
10:31:27 <bryan_> glguy: let's say /dev/foo outputs a newline on the trillionth byte.  what is in the runtime memory on the billionth byte?  what does 'take 10' see on the trillionth byte?  Is the whole line in memory at that point?
10:31:49 <geekosaur> bryan_, it's streaming
10:32:04 <glguy> bryan_: No, the whole line is not required to be in memory since nothing is holding on to the head of the list
10:32:22 <geekosaur> it's not at any point holding data until it sees something. it has a behavior attached to seeing something go by in the stream
10:32:37 <Tuplanolla> I think my suggestion is still useful, geekosaur.
10:32:49 <joe9> glguy: Thanks a lot. I had an earlier un-killed thread that was hogging the socket. Thanks a lot for your help.
10:33:00 <glguy> oh, good to hear, you're welcome :)
10:34:28 <bryan_> geekosaur: so once it sees something go by in the stream, how do the trillion-1 bytes that have gone by get passed along to the function that called lines?  doesn't 'take 10' need the entire trillion bytes of the first line?
10:34:39 <geekosaur> they are streamed
10:35:04 <glguy> > head (take 10 ('a' : undefined))
10:35:07 <lambdabot>  'a'
10:35:07 <geekosaur> you seem to think that at some point it has to have eveything in one place. but your code does not rely on this at all
10:35:29 <glguy> bryan_: Observe that take can produce the first element as soon as it is ready (and it doesn't otherwise hold on to that first element)
10:35:31 <bryan_> ok, let me think on that for a minute
10:35:35 <EvanR> yeah take 10 does not need 10 things if whatever used take 10 didnt use 10 things
10:36:25 <bryan_> so when the "first thing" is ready, which in this case is a trillion byte line, at that point would we need at least 1 trillion bytes allocated by the runtime?
10:36:29 <geekosaur> character comes in -> lines does not see newline, passes it as next char of string being generated -> take 10 has not seen end of that string yet, passes it on -> unlines has not seen end of string yet, passes it -> putStrLn has not seen newline, outputs char
10:36:51 <geekosaur> if a newline ever came in, that process would be altered slightly
10:37:07 <geekosaur> but it never needs to have more than one character around
10:37:37 <Welkin> for some reason my Request body is not being parsed
10:37:38 <glguy> bryan_: If 1 trillion characters were processed, then even more memory than that would be allocated (and freed soon after by the GC) but 1 trillion bytes wouldn't be resident
10:37:47 <EvanR> the first thing is a character, not a line
10:38:29 <bryan_> i see, so the whole head pipeline works in constant space because every element of the chain is working lazily?
10:39:29 <geekosaur> whrn a newline comes in, lines will end the first list, take will check if this is the 10th list it has seen, since it isn't it passes it on, unlines sees end of list and sends a newline on, putStrLn outputs it
10:40:12 <geekosaur> on the 10th newline, lines ends the current list, take will see this is the 10th list and return end of list, unlines will send a newline followed by end of list, putStrLn will output the newline and return to main, main exits
10:40:17 <zipper> is an expression a function that has been applied?
10:40:31 <geekosaur> all of this is done streaming-style, at no point is more than one character needed in memory
10:40:35 <geekosaur> and one list cell
10:40:44 <EvanR> this process is easier if you write down a good way to lazily evaluate the execution
10:40:48 <bryan_> so is it accurate to say that the runtime somehow allows putStr, unlines, take 10 and lines to work 1 character at a time? 
10:40:56 <johnw> zipper: an expression is anything that may evaluate to a term
10:41:02 <EvanR> like, putStrLn drives it, and asks to evaluate enough to get more data 
10:41:12 <geekosaur> yes, this is called streaming (and the mechanism that enables it is list fusion)
10:41:18 <EvanR> which is character by charcter
10:41:26 <PhsShft> I’m trying to make foldMap fold over the first element of the pair instead of the second, http://lpaste.net/303794 I know this attemp is silly can someone take a look?
10:41:50 <geekosaur> laziness is what enables the compiler to fuse the list into a stream that never needs more than one list cell and one character active at any time
10:41:52 <bryan_> ahh, I see. fascinating.  Awesome runtime
10:41:56 <zipper> johnw: I was reading https://wiki.haskell.org/Let_vs._Where
10:42:33 <zipper> johnw: and it seems whatever returns a bool in a guard is not an expression
10:42:41 <geekosaur> well, laziness + purity: it knows that the whole stream until the putStrLn that terminates it is lazy and pure, and therefore can be distilled down to a character pipeline
10:43:01 <johnw> zipper: what makes you say that?
10:43:23 <zipper> johnw: "Because "where" blocks are bound to a syntactic construct, they can be used to share bindings between parts of a function that are not syntactically expressions. "
10:43:25 <bryan_> ok, so lazy IO allows constant space stream processing.  Then pipes-like libs exist to deal with problems of lazy IO, like reasoning about *when* IO will happen?
10:43:44 <zipper> johnw: Then the example is a function with guards
10:43:50 <zipper> *using
10:44:09 <geekosaur> pipes / conduit give you more control over it. one shortcoming of lazy I/O is that getContents can not tell you about input errors; both read error and end of input show up as end of string
10:44:28 <jle`> PhsShft: only things that take type arguments can be Foldable instances
10:44:44 <jle`> PhsShft: so Maybe can be Foldable, but not Maybe Int
10:44:51 <johnw> zipper: I think what it means here is that the where is defining something that spans across multiple function definitions
10:45:08 <johnw> where in the let/case version, the definition spans over an expression
10:45:23 <EvanR> is there a parser lib which runs in constant spacewhen you know you dont need backtracking?
10:45:54 <bryan_> Would it be fair to say that pipes/conduit express a more explicit ordering of stream processing?  Or is lazy IO all we actually need, just as long as we avoid some common pitfalls like reading from handles that have already been closed due to the eval order of the runtime?
10:45:59 <dolio> Parsec?
10:45:59 <johnw> EvanR: you could use parsec-free to apply an evaluator with those semantics, so long as you can codify "don't need backtracking"
10:46:16 <johnw> but yeah, maybe Parsec already does this, since backtracking is never automatically used
10:46:18 <geekosaur> pipes/conduit also let you do things like splitting and combining streams
10:46:23 <EvanR> ah
10:46:35 <johnw> attoparsec is another story
10:46:45 <Welkin> I cannot tell why my request body is not being parsed
10:46:47 <EvanR> yeah attoparsec trades memory for speed
10:46:48 <Welkin> it gets through fine
10:46:56 <Welkin> the raw request data is all there
10:47:11 <bryan_> thanks geekosaur, evanH and glguy
10:47:11 <geekosaur> so, you get stream error handling, and you get the ability to manipulate the streams themselves as well as what is flowing through them
10:47:12 <glguy> The reason that Parsec commits to a branch as soon as some input is consumed on that branch is specifically to efficiently support backtracking
10:47:21 <johnw> bryan_: if lazy IO is used well, what is the harm other than people's opinions?
10:47:37 <EvanR> now i have a better appreciation of Parsecs backtracking policy
10:47:38 <johnw> Welkin: can you show me your parser?
10:47:47 <johnw> Welkin: also, parsec-free was written for debugging exactly these sorts of questions
10:48:16 <johnw> one thing to onet is that, given a <|> b, b is not attempted if a consumed any input
10:48:30 <Welkin> http://lpaste.net/2856927406810202112
10:48:33 <bryan_> johnw: I'm not sure, I think that's what I'm trying to figure out.  Is lazy IO as powerful as the streaming libs, just not as nice to work with, or are the streaming libs fundamentally more powerful than lazy io?
10:48:45 <Welkin> this is with Network.Wai.Parse
10:48:55 <dolio> Lazy I/O is nicer to work with than streaming libs.
10:49:10 <Welkin> relevant section http://lpaste.net/2856927406810202112#line21
10:49:15 <glguy> bryan_: streaming libraries are more invasive but give more control
10:49:42 <johnw> streaming libs can also have wicked memory use patterns, as pointed out by Well-Typed's recent blog
10:49:52 <EvanR> bryan_: if youre worried about random errors in IO, lazy IO will not be good. but even if you are worried, you can evaluate the final result of parsing (with `evaluate') before moving on to avoid a weird error later
10:49:56 <geekosaur> the streaming libs are strictly more powerful because you can control the streams, split streams into multiple output streams that do different processing, merge those streams back into a single stream, etc.
10:50:12 <glguy> https://www.well-typed.com/blog/2016/09/sharing-conduit/
10:50:18 <johnw> glguy: thanks
10:50:21 <EvanR> johnw: wicked good or wicked bad
10:50:36 <dolio> wykyd
10:50:37 <johnw> also, this is required reading: http://comonad.com/reader/2015/on-the-unsafety-of-interleaved-io/
10:50:41 <geekosaur> either; the downside of more control is you need to use more care
10:50:47 <johnw> WKYD is good
10:51:43 <johnw> Welkin: print out the request body and then parse it as a string directly; try to reduce the problem
10:51:47 <geekosaur> or you could end up holding onto something you didn't expect to. on the other hand, the relatively naïve streaming done by list fusion is easily confused; streaming libs can avoid that when used properly
10:52:39 <johnw> the streaming libs cannot do any fusion if you attempt "manual control" (i.e., directly using yield/await)
10:52:53 <johnw> but then again, manual control is something lazy IO doesn't give you at all ;)
10:53:07 <geekosaur> so they can stream more than a simple lazy I/O pipeline might. (list fusion can, IIRC, break down if something doesn't inline, or sometimes when something does inline unexpectedly)
10:53:18 <johnw> although, I guess the list monad, in the presence of unsafeInterleavedIO, is akin to it
10:53:35 <johnw> but then it would need to be ListT, so n/m
10:54:51 <bryan_> I'm writing a parser for an mbox type format: a log of message-like objects.  The file will be very large, containing billions of these message-like objects.  I'll process the messages one at a time, so I won't ever have the entire list of messages in mem.  Does anything I've said so far rule out just using Parsec+lazy io?  Does anything I've said suggest that pipes/conduit is definitely the way to go?
10:54:53 <PhsShft> So I’m a bit confused with Foldable can someone explain to me what can count as a fodable instance? and How would I go about solving this http://lpaste.net/303846
10:54:54 <Tuplanolla> I have a related question. If I make a top-level infinite list that is generated with a lazy `ST` as its backing storage, I get caching. Is there a way to purge this cache somehow?
10:55:11 <jle`> PhsShft: you can parameterize your type
10:55:25 <jle`> the item that foldMap "maps" over is the last type parameter
10:55:58 <PhsShft> I don’t get it…
10:56:06 <jle`> so in newtype Pair a b = P (a, b)   ... if you wanted to make that a Foldable, it'd be Foldable (Pair a), and it'd map over the 'b'
10:56:10 <jle`> which is the second item in the tuple
10:56:44 <EvanR> bryan_: if youre folding the messages, and an error happens in the middle, youll lose everything. If youre streaming results somewhere else, then an error in the middle will terminate things unpredictably
10:56:45 <PhsShft> how can you have Foldable (Pair a) when Pair takes two paras?
10:57:09 <EvanR> so if this is a production thing, lazy IO might not work out for this huge file
10:57:31 <geekosaur> because Foldable is * -> * and therefore wants one parameter for itself
10:57:58 <geekosaur> you cannot use Pair directly because it has two parameters, not one
10:58:12 <geekosaur> but you can use Pair applied to one parameter, and leave the other for Foldable
10:58:14 <bryan_> EvanR: thanks, makes sense
10:58:39 <EvanR> bryan_: so im thinking it would work out if you were folding something not so big and its not a big deal to lose everything
10:59:00 <EvanR> because then you could isolate the code doing the folding appropriately
10:59:05 <PhsShft> so in the body of the instance, do I define foldMap with Pair a ?
10:59:51 <EvanR> and catch the IO error
10:59:51 <bryan_> EvanR: the usual case will be folding over the log and outputting a modified log to a new file, or folding over the log and mutating database state (each log msg contains state mutation statements)
11:00:27 <EvanR> sounds like a use case for pipes (conduit, not what the latest hotness is)
11:00:36 <EvanR> tubes
11:01:29 <geekosaur> PhsShft, actual code needs to use the full Pair
11:01:55 <geekosaur> the instance itself uses only one parameter to Pair because Foldable supplies the other one
11:02:19 <EvanR> bryan_: make sure you can rerun the database updates in an idempotent way... if it fails in the middle however way, youd want to be able to rerun the whole thing without duplicating the first half of work
11:02:22 <geekosaur> but e.g. foldMap for your instance works with a full Pair
11:02:36 <geekosaur> (but has limits on what it can do with the first parameter)
11:02:50 <jle`> PhsShft: look at the type of foldMap
11:02:52 <jle`> :t foldMap
11:02:54 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
11:03:12 <jle`> so, if you had Foldable (Pair a), then t is "Pair a"
11:03:25 <bryan_> EvanR: I was thinking that each log msg would be a separate DB transaction; if log msg 1mil fails, the DB will be in consistent state as of log msg 999k.
11:03:28 <geekosaur> b might have been a better choice there :)
11:03:34 <jle`> heh, true
11:03:49 <jle`> so if you had Foldable (Pair b), you'd have --
11:04:05 <jle`> foldMap :: Monoid m => (a -> m) -> Pair b a -> m
11:04:06 <jle`> right?
11:04:18 <PhsShft> yea..
11:04:29 <jle`> because you have Foldable (Pair b), so t is Pair b, so i'm just plugging Pair b into the signature for t
11:04:32 <jle`> can you write that function?
11:04:37 <jle`> from scratch?
11:04:42 <jle`> foldMap f (Pair x y) = ?
11:04:57 <EvanR> bryan_: sure, but its really nice when you can run msg 999 more than once and not get multiple effects
11:05:24 <bryan_> EvanR: ahh, I see what you're saying
11:05:41 <PhsShft> uhhh
11:05:45 <EvanR> f (f x) = f x ;)
11:06:23 <jle`> bryan_: foldMap f (Pair x y) = ???, you want an 'm', and f is (a -> m), and x is 'b', and y is 'a'
11:06:38 <jle`> *is an
11:07:00 <jle`> er, PhsShft ^
11:07:40 <leshow> if i have a list of [Just 1, Just 2, Nothing] and a function that takes some a, how do map that function to the list? i thought <$>/fmap would do it
11:07:42 <PhsShft> foldMap f (Pair y x)?
11:07:46 <leshow> but it doesnt look like thats correct
11:07:59 <leshow> how do i*
11:08:29 <PhsShft> :t foldMap
11:08:31 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
11:08:58 <PhsShft> foldMap f Pair y ?
11:09:07 * hackagebot glue-common 0.4.9 - Make better services and clients.  https://hackage.haskell.org/package/glue-common-0.4.9 (seanparsons)
11:09:09 * hackagebot glue-core 0.4.9 - Make better services and clients.  https://hackage.haskell.org/package/glue-core-0.4.9 (seanparsons)
11:09:11 * hackagebot glue-ekg 0.4.9 - Make better services and clients.  https://hackage.haskell.org/package/glue-ekg-0.4.9 (seanparsons)
11:09:13 * hackagebot glue-example 0.4.9 - Make better services and clients.  https://hackage.haskell.org/package/glue-example-0.4.9 (seanparsons)
11:09:48 <jle`> PhsShft: you need an equals sign
11:09:53 <jle`> foldMap f (Pair x y) = ?
11:10:05 <jle`> you need an 'm', and f is 'a -> m', and y :: a
11:10:15 <jle`> if you have an 'a', and an 'a -> m', how do you get an 'm'?
11:10:21 <jle`> leshow: fmap twice :)
11:10:23 <PhsShft> f y
11:10:27 <jle`> hooray
11:10:32 <jle`> foldMap f (Pair x y) = f y
11:10:32 <geekosaur> leshow, you would need two of them. one map for the list, one fmap for the Maybe inside it
11:10:34 <jle`> :)
11:10:40 <leshaste> what do I need to install to get Data.Vector.Unboxed ?
11:10:44 <leshaste> I have cabal
11:11:11 <leshaste> cabal install Data  or Data.Vector or Data.Vector.Unboxed don't work
11:11:30 <moongazer> :t
11:11:32 <geekosaur> yes, it doesn't understand package names
11:11:37 <leshow> ahhhhhh damn
11:11:38 <geekosaur> er, module names
11:11:39 <leshow> thanks guys
11:11:41 <geekosaur> it wants package names
11:11:48 <leshaste> which package do I need?
11:12:22 <leshow> i there a usual way, that if you have a list of maybes, to get a list of the unwrapped values, excluding Nothing
11:12:25 <leshow> such as
11:12:31 <leshow> [Just 1, Just 2, Nothing] -> [1,2]
11:12:32 <geekosaur> leshaste, looking up Data.Vector.Boxed at https://hayoo.fh-wedel.de tells me it's the vector package
11:12:38 <jle`> leshow: catMaybes
11:12:48 <geekosaur> er, Data.Vector.Unboxed
11:12:49 <Welkin> it looks like it works using sinkRequestBodyEx with Multipart as the RequestBodyType
11:12:53 <Welkin> that is weird
11:12:58 <geekosaur> so, cabal install vector
11:13:09 <jle`> PhsShft: so, for foldMap, the "f" maps over whatever values are the type of the final parameter
11:13:19 <leshaste> geekosaur, thanks!
11:13:22 <leshow> jle`, thanks
11:13:24 <jle`> so for Pair b a, foldMap maps over all values of type 'a'
11:13:36 <jle`> leshow: so if you want it to map over values of type 'b', you have to swap it
11:13:51 <PhsShft> jle`: I still don’t get it and it gives me the same error message :(
11:14:12 <jle`> PhsShft: can you paste your code?
11:14:20 <jle`> er sorry, my previous comment was for you, not leshow 
11:14:29 <eacameron> Folks, is there a way to provide a customized version of FromJSON that uses my generic parser as the default instead of Aeson's? I don't want to provide an impl for parseJSON for every instance directly.
11:14:44 <PhsShft> http://lpaste.net/303926 :jle` 
11:15:01 <jle`> PhsShft: you need to change how your pair is defined
11:15:07 <jle`> i defined it up earlier
11:15:12 <PhsShft> sry it’s taking too long I didn’t sleep at all last night and it’s now afternoon…
11:15:29 <PhsShft>  Pair a b = P (a, b) ?
11:16:41 <jle`> yes
11:17:00 <jle`> so in that case, because 'b' is the final type parameter of Pair, foldMap will map over the values of type b
11:17:16 <jle`> but if you want to map over the values of type a, then you can make 'a' the final parameter
11:17:23 <PhsShft> but then I ran back to “The constructor ‘Pair’ should have 1 argument, but has been given 2”
11:17:26 <jle`> newtype ReversePair b a = P (a, b)
11:17:48 <jle`> PhsShft: instance Foldable (Pair b) ...?
11:18:09 <PhsShft> yea that 
11:18:26 <jle`> oh, remember that the consutor takes a tuple
11:18:28 <jle`> P (x,y)
11:19:07 <PhsShft> newtype Pair a b = Pair (a,b) 
11:19:30 <jle`> yeah, so foldMap f (Pair (x,y)) = ...
11:19:52 <jle`> or maybe use P so it's less confusing; newtype Pair a b = P (a, b), so foldMap f (P (x,y)) = ...
11:19:59 <PhsShft> oh i see...
11:20:06 <geekosaur> you might actually want to rename one of those, because otherwise you will confuse type level and value level a lot, yeh
11:20:58 <machinedgod> Hi everyone... I, uh, got this output from the compiler... http://lpaste.net/303953
11:21:06 <jle`> so yeah, any Foldable instance for 'Pair a' will map over the b's, the final type parameter.  so if you wanted to map over the a's, you have to make a the final type parameter
11:21:27 <jle`> newtype ReversePair b a = P (a,b)    -- Foldable (ReversePair b) will map over the a's
11:21:28 <PhsShft> :geekosaur :jle` thank you I need to get sleep and read the chapter on foldable again :)
11:22:23 <jle`> no problem!
11:22:29 <srhb> machinedgod: Looks like this? https://ghc.haskell.org/trac/ghc/ticket/12007
11:23:05 <srhb> machinedgod: Assuming you're using those :)
11:23:26 <chrissl> q
11:23:40 <machinedgod> srhb: Hi, this is a crash in 'hgeometry' library - I'm picking it up straight from github with stack.yaml's 'packages' option
11:24:06 <machinedgod> I am trying, for an experiment, to compile without -Wall
11:24:23 <srhb> machinedgod: Well, it's certainly a bug in ghc, the question is whether it's fixed in newer ones. :)
11:25:14 <machinedgod> srhb: Okay... sorry, I never did this before, that's why I came here for guidance. Should I add a new bug, post a message in the link you provided, or just wait?
11:25:33 <geekosaur> that ticket says fixed in HEAD and cherrypicked back to ghc-8.0, so fix should be in 8.0.2
11:25:40 <srhb> machinedgod: Nothing to be sorry about! If that's the bug, it should work in 8.0.2
11:25:56 <geekosaur> alsom, you could get that while compiling code if it's Template Haskell code that triggers it
11:26:11 <machinedgod> Ah :-) Okay, I'm running arch and I assumed I'm on newset version, but ghc reports 8.0.1
11:26:13 <geekosaur> or a quasiquoter
11:26:23 <geekosaur> 8.0.2 has not been released yet
11:26:38 <machinedgod> geekosaur: I can see from the sources that hgeometry uses lenses
11:26:38 <geekosaur> they're still trying to nail down a backward compatible fix for Sierra compatibility
11:27:12 <srhb> machinedgod: Do you know how to trigger it?
11:27:31 <machinedgod> yes, its reproducible 100% on my codebase
11:27:56 <srhb> machinedgod: I wonder if I have a new enough head lying around...
11:28:01 <srhb> Er, ghc head.
11:28:26 <kadoban> xD
11:28:29 <srhb> machinedgod: I think I do, if you want me to test. :) 30th of september.
11:28:33 <machinedgod> srhb: Well, it seems to work just fine if I remove -Wall
11:28:37 <srhb> Okay :)
11:28:59 <geekosaur> that sounds ... odd
11:29:10 <geekosaur> might want to report that after all
11:29:22 <machinedgod> srhb: If you want to clone my code, no problem... otherwise, its as simple as adding package definition for hgeometry in the stack.yaml. I'll cp into lpaste, one moment
11:29:34 <srhb> machinedgod: Either way is fine
11:30:26 <machinedgod> srhb: the stack yaml: http://lpaste.net/303993
11:31:08 <machinedgod> srhb: If it doesn't produce the same panic with -Wall, I'll create a git bundle and send over, just let me know
11:31:37 <srhb> machinedgod: Oh, just compiling hgeometry with -Wall does it?
11:31:44 <machinedgod> srhb: yes
11:32:28 <machinedgod> I'm not sure about all the extensions the library uses, but I know for sure it uses lenses at the very least
11:34:57 <srhb> machinedgod: I can't reproduce it on 8.0.1
11:35:05 <srhb> So, that's fun.
11:35:36 <machinedgod> Okay, I'll create a git bundle for all the code and put on dropbox, give me one minute
11:36:04 <srhb> I just did cabal build --ghc-options="-Wall -fforce-recomp" by the way
11:37:52 <machinedgod> Try this - https://dl.dropboxusercontent.com/u/80655/repo.bundle
11:39:18 <srhb> machinedgod: Ermm.. so git bundle unbundle... what? :-)
11:39:32 <srhb> I've never seen one of these before
11:39:35 * srhb prods it with a stuck
11:39:39 <machinedgod> Lol :-D
11:39:47 <machinedgod> Sorry I'm behind the firewall so I can't open git daemon
11:40:03 <machinedgod> You can clone straigh tfrom the bundle as you'd normally clone from the http or git://
11:40:09 <srhb> Oh!
11:40:12 <machinedgod> Its a master branch
11:40:15 <srhb> TIL
11:44:58 <kirillow> @djinn (a -> c) -> a -> a
11:44:59 <lambdabot> f _ a = a
11:46:40 <kirillow> @pl f _ a = a
11:46:41 <lambdabot> f = const id
11:47:46 <joe9> I want to create a Data.Serialize empty instance. Something that parses to an empty bytestring. https://github.com/joe9/9ph/blob/master/src/Data/NineP.hs#L507 any suggestions on how to do that, please?  I tried mempty but it did not help
11:48:02 <srhb> machinedgod: How exactly are you building this?
11:48:21 <machinedgod> srhb: just 'stack build', that's all
11:48:55 <machinedgod> However, ever since I tried removing -Wall and building successfully once - I tried building twice with -Wall back on and now I can't get it to fail
11:49:02 <machinedgod> 'stack repl' does it, tho
11:49:09 <srhb> You probably need -fforce-recomp as well
11:49:22 <srhb> Not sure about Stack though
11:49:25 <machinedgod> srhb: Ah, thanks, wasn't aware of this option, i tried 'stack clean hgeometry'
11:49:29 <monochrom> -Wall shouldn't cause failure. -Werror does.
11:49:40 <srhb> monochrom: It's a ghc panic, so all bets are off.
11:49:45 <monochrom> oh!
11:55:49 <srhb> machinedgod: Sorry, it takes a long time with Stack.
11:55:53 <srhb> but it's building :)
11:56:36 <machinedgod> srhb: I have no idea what's up then... I'll paste the whole log into the lpaste, gimme a sec, maybe you can see something in it
11:56:47 <srhb> machinedgod: Sorry, I mean, it's still building.
11:56:51 <srhb> It might still fail!
11:57:27 <srhb> As in "that's a lot of dependencies" :-P
11:57:36 <joe9> I have this data type "data Rclunk = Rclunk deriving (Eq, Show) " for which I want to create Data.Serialize (get and put) instance. something like this:  fmap Rclunk (DS.get :: Get ())
11:57:39 <joe9> Is that possible?
11:58:32 <machinedgod> srhb: Well, you know how it is :-D You add eg. juicy pixels and you pull in 30 additional libraries :-D here's my output log: http://lpaste.net/304138
12:00:25 <geekosaur> joe9, not with that data type as written
12:00:34 <geekosaur> fmap requires a data type with a parameter
12:00:40 <zipper> So I have this snippet and on line 14 it says that I've shadowed the pattern match for s http://lpaste.net/8454422373741887488
12:00:47 <geekosaur> data Foo a = ... -- this can potentially have a Functor instance
12:00:59 <geekosaur> data Foo = ... -- this can not have a Functor instance
12:01:01 <lpaste> whittle pasted “IOs wrapped in IOs” at http://lpaste.net/304161
12:01:06 <zipper> Well I honestly don't see my mistake there
12:01:15 <zipper> I see that I did some shadowing
12:01:22 <srhb> zipper: s simply binds s to whatever the value is
12:01:32 <zipper> but it always Loss
12:01:35 <zipper> srhb: Oh
12:01:48 <whittle> I’m so close to getting callAPI worked out in that lpaste, but I can’t figure out where I’m going wrong with the IO actions. 
12:01:57 <zipper> srhb: It doesn't check whether s == beat f?
12:01:59 <geekosaur> the pattern match doesnt even look, it always matches and binds the result to s
12:02:00 <zipper> WOW
12:02:02 <zipper> Jesus
12:02:03 <srhb> zipper: Nope. :)
12:02:14 <zipper> srhb: Ok it does in clojure lol 
12:02:20 <geekosaur> pattern matches match *structure*, not values
12:02:22 <zipper> these things are so ...
12:02:51 <joe9> this compiles https://paste.pound-python.org/show/YsuAV03JzPdr7LJeo4o4/ not sure if it is correct or not though. geekosaur
12:02:54 <geekosaur> (although it cheats for numeric literals)
12:03:23 <zipper> srhb: How would I write that to check for equality without being not elegant?
12:03:24 <geekosaur> oh, right, Serializa, but you are talking fmap... wrong one
12:03:37 <Hafydd> And string literals. And nullary constructors.
12:03:39 <srhb> machinedgod: Paste didn't make me any wiser. I'm no expert either. Whether or not I can reproduce it though, it should probably still be reported. 73/75 :-)
12:03:53 <srhb> machinedgod: And it's on hgeometry now.
12:04:01 * machinedgod holds breath
12:04:04 <geekosaur> I wouldn't say any of those is a cheat; they're still structural. None of them impute an Eq constraint
12:04:25 <geekosaur> which is where it is cheating and making a guard behind your back
12:05:35 <Hafydd> I suppose so... in the absence of extensions.
12:05:41 <srhb> zipper: I don't understand how it would work even if it did what you thought it did. :)
12:05:42 <geekosaur> constructors are structural, and it is the structure and not the value that is checked. likewise Char literals can be treated as structural. numerics can't because numeric literals don't actually exist (they're always calls to fromInteger), so it cheats
12:06:03 <geekosaur> ...althiugh this would also happen with string-typed things if OverloadedStrings is enabled
12:06:49 <zipper> srhb: Better question. How would I write `case boolValue of True -> ... `
12:07:10 <srhb> zipper: if then else?
12:07:16 <srhb> :t bool
12:07:18 <lambdabot> a -> a -> Bool -> a
12:07:27 <defanor> given a flowchart with a ton of "decision" nodes and return values on its leafs, where some paths are cyclic, what would be a nice way to implement it in haskell, while keeping it close to the original flowchart (i.e., easily editable if it will change)? is there some fancy package or idiom to deal with flowcharts?
12:07:35 <geekosaur> joe9, so Serialize is * not * -> *, and that should be possible
12:07:56 <zipper> srhb: Yeah I guess I have to use an if despite not liking them
12:08:15 <srhb> zipper: You can case off a bool if you really want to explicitly match on True or False
12:08:25 <geekosaur> zipper, actually that one works fine --- True is a constructor (initial uppercase)
12:08:26 <joe9> geekosaur: ok, Thanks.
12:08:31 <srhb> machinedgod: No dice. I have no idea what's going on.
12:08:40 <amalloy> zipper: i don't understand what equivalent code in clojure you think would have worked. clojure's pattern matching is less advanced of course, but it shadows just the same as haskell's
12:09:01 <srhb> machinedgod: stack build --ghc-options "-Wall -fforce-recomp" -- just to be safe, and Stack says "Completed 2 action(s)"
12:09:10 * hackagebot precursor 0.1.0.0 - Prelude replacement  https://hackage.haskell.org/package/precursor-0.1.0.0 (oisdk)
12:09:17 <machinedgod> srhb: Can you try 'stack repl' and see if it crashes it?
12:09:23 <zipper> amalloy: Have you seen my code?
12:09:31 <geekosaur> stack repl would trigger the earlier mentioned bug
12:09:31 <amalloy> i saw http://lpaste.net/8454422373741887488
12:09:37 <srhb> machinedgod: Bingo!
12:09:44 <zipper> amalloy: I am checking for a specific value in the pattern part of a case statement
12:09:45 <machinedgod> geekosaur: The one you linked originally?
12:10:19 <geekosaur> srhb linked it, not me
12:10:23 <geekosaur> ghc bug 12007
12:10:24 <amalloy> uh huh, and you claimed that in clojure that pattern match would have checked for equality, which makes no sense to me
12:10:48 <srhb> Yeah, that does make it seem a likely candidate again :)
12:11:17 <zipper> amalloy: Would you mind it if I wrote how I think it would work in clojure?
12:11:20 <geekosaur> amalloy, zipper, which "pattern match"? (cond is not pattern matching...)
12:11:26 <zipper> One sec
12:11:27 <amalloy> that's what i was asking, yes
12:11:47 <machinedgod> geekosaur, srhb: Okay, then I guess its already handled.
12:12:37 <zipper> geekosaur: Oh did I mention pattern matching?
12:12:45 <zipper> I think amalloy is the one who did
12:12:52 <zipper> anyway https://clojuredocs.org/clojure.core/case
12:12:59 <machinedgod> srhb: thanks for your help :-)
12:13:10 <zipper> amalloy: I can check for the return value in the case
12:13:17 <zipper> amalloy: but that is not the point here
12:13:31 <zipper> Just trying to do a simple thing
12:13:32 <geekosaur> zipper, you were talking in the context of pattern matching. "case" probably does values in clojure, not patterns. but Haskell's case is about patterns
12:13:48 <zipper> geekosaur: Yes it does
12:13:56 <zipper> geekosaur: KNow how I can check for values?
12:14:05 <zipper> In something like a case?
12:14:10 * hackagebot heckle 2.0.1.0 - Jekyll in Haskell (feat. LaTeX)  https://hackage.haskell.org/package/heckle-2.0.1.0 (2016rshah)
12:14:19 <zipper> As in using succinct syntax?
12:14:26 <geekosaur> case x of foo | foo == 5 -> ...
12:14:29 <srhb> zipper: There is none. Use == and guards, like above :)
12:14:39 <geekosaur> or see MultiWayIf extension which is a sort of truncated case
12:14:46 <geekosaur> with only guards
12:14:49 <zipper> srhb: I can use guards within guards?
12:15:03 <geekosaur> && or commas
12:15:06 <srhb> zipper: You can just flatten them, or use guards in case.
12:15:12 <srhb> Oh, commas too. I forget.
12:16:24 <zipper> srhb: Ah I get it
12:16:58 <zipper> srhb: http://lpaste.net/8454422373741887488
12:17:19 <zipper> srhb: I'd say it's even better, thanks.
12:18:37 <zipper> Ok good take away case in haskell matches against patterns
12:19:27 <geekosaur> (actually I'm tempted to call MultiWayIf (cond ...)
12:20:25 <dmj`> if I want to save on allocations could converting a sum type to a product type of maybes help with that
12:20:35 <dmj`> my structure is recursive
12:20:54 <dmj`> and each node has a sum type
12:21:51 <dmj`> unpacking doesn't seem to help in this case
12:25:48 <johnw> product type of maybes would have two constructor tags; a sum type would have one
12:29:11 * hackagebot heckle 2.0.1.1 - Jekyll in Haskell (feat. LaTeX)  https://hackage.haskell.org/package/heckle-2.0.1.1 (2016rshah)
12:34:01 <sm> yey, competition for hakyll
12:34:59 <monochrom> will there also be lekyll?
12:37:57 <ph88^> is it possible to use GHC.Generics to write a transform function that traverse a graph of different types and only does something to the matched type ?
12:37:59 <sm> wow, 0.1.0.0 to 2.0.0.0 in 6 days
12:38:56 <johnw> I'm waiting for LaTekyll
12:42:43 <Tuplanolla> That's a convenient timing as I was planning to build myself a new website in the coming months.
12:43:48 <Tuplanolla> "Make sure you format the date as `1 January 2016` otherwise Heckle won't find your post!"
12:44:02 <Tuplanolla> Not with this one though.
12:45:22 <polo> hi guys, I'm working on a problem and getting error. I've posted my original problem with my own solution and error message.I'll appreciate if someone can help me.http://lpaste.net/294377
12:45:57 <grantwu> polo: You want an = after isResistant a d and no | before the first case
12:46:09 <grantwu> wait, no this is a function
12:46:25 <Tuplanolla> The problem is the `|`s in the comparisons.
12:46:27 <grantwu> Uh, I don't think you want guards here
12:46:53 <johnw> ph88^: sounds like a job for uniplate
12:46:54 <polo> grantwu: If I use OR instead then I get out of scope
12:47:05 <geekosaur> guards will work, | does not work as "or", and spaces do not work as "and"
12:47:28 <geekosaur> the or operator is || and it does not work the way you are trying to use it
12:47:29 <grantwu> But can't you at least pattern match on the first thing
12:47:36 <geekosaur> a == Water || a == Fire
12:47:52 <dmj`> johnw: I see, might be all these list comprehensions as well
12:49:21 <geekosaur> in fact you seem to be trying to randomly mix guard and pattern syntax, and an "or" syntax that doesn't work in most languages aside from Icon...
12:49:33 <et09> when your function is 6 lines long and then suddenly it's 1 line long 8-) 
12:51:43 <polo> geekosaur: I'm getting new errors now after doing a == Water || a == Fire
12:51:53 <ab9rf> et09: the real win is when you still understand it afterwards
12:51:56 <polo> geekosaur:http://lpaste.net/294377
12:52:04 <geekosaur> yes, presumably you ignored everything else I said
12:52:09 <monochrom> you haven't addressed "and spaces do not work as "and""
12:52:56 <orion> Tuplanolla: What was convenient timing?
12:53:13 <ab9rf> why not just write that as straight-up pattern matching?
12:53:20 <Tuplanolla> To announce a new version of Heckle, I thought, orion.
12:53:29 <orion> Oh, I've never heard of this package.
12:53:33 <monochrom> yes, I support using pattern matching too
12:53:51 <polo> monochrom: Thanks buddy!
12:53:53 <ab9rf> lookup functions are often best done simply by listing lots of patterns
12:53:55 <et09> i'm getting stressed out reading what you wrote polo 
12:53:56 <grantwu> ab9rf: monochrom: Wouldn't support the ors, I think.  But yeah, as I said before, should pattern match on the d
12:54:09 <ab9rf> grantwu: it'll support the "ors"
12:54:27 <ab9rf> just do isResistant Grass Grass = True and then isResistant Grass Water = True usw.
12:54:35 <grantwu> Okay but that's arguably less clear.
12:54:43 <ab9rf> not really from where i come from :)
12:54:54 <grantwu> It's a bunch more cases
12:55:01 <ab9rf> it's the same nuymber of cases
12:55:05 <ab9rf> just written over a few more lines
12:55:20 <ab9rf> it's not like there's a cartesian product in there anywhere
12:55:27 <monochrom> splitting into more cases is both more clear and less clear. overall it is more or less clear.
12:55:43 <monochrom> by the same argument, not splitting into more cases is also more or less clear.
12:55:47 <jg_> hi all. How do i use pattern matching with pattern guards?
12:55:49 <ab9rf> monochrom: heh
12:55:56 * geekosaur is gad he swallowed coffee before reading IRC...
12:55:59 <geekosaur> *glad
12:56:10 <ab9rf> monochrom: that's definitely quotable
12:56:38 <monochrom> the meta take-away is that this is more or less clearly hair splitting :)
12:56:51 <ab9rf> monochrom: but that's so much FUN!
12:57:11 <monochrom> OK! go on.
12:57:12 <jg_> OCaml has those in the bag, notice the 'when' thingies inside the 'match' expression
12:57:20 <jg_> in https://gist.github.com/jg/55eda08ed86763ed2bcf376caa3c3e9f
12:57:30 <monochrom> hmm, should it be s/go/carry/?
12:57:33 <joe9> this is pretty cool: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/Simple%20examples
12:57:53 <Swartz> is there a linux app for freenode?
12:58:25 <mspo> Swartz: irssi
12:58:31 <pikajude> weechat
12:58:41 <tdammers> also they're called "program"
12:58:50 <Swartz> thanks! mspo
12:58:52 <tdammers> "app" is a word that was invented for selling stuff to stupid people
12:59:04 <monochrom> No.
12:59:08 <tdammers> I second weechat though
12:59:29 <implementation> also: Hexchat, Quassel, Konversation, Pidgin, ...
12:59:40 <implementation> pick what you like
12:59:44 <Welkin> "app" has been used to refer to software applications for decades now
12:59:53 <johnw> Welkin: yeah, I was going to say...
13:00:09 <Welkin> long before the iphone
13:00:35 <monochrom> "app" is short for "application" which was technical jargon --- by programmers, for programmers --- dating back to the Win16 API and the OSI 7-layer network model.
13:01:25 <monochrom> lot of of source code back then, for example, had the identifier "WinApp".
13:01:25 <grantwu> Swartz: Freenode is just one IRC network.  You want an app/application/program/ELF which is speaks the IRC protocol.  See above for suggestions
13:01:29 <et09> hAppStack, just saying
13:01:57 <pikajude> well, tdammers might still be technically correct, depending on your definitions of selling, stuff, and stupid
13:02:03 <johnw> does anyone have experience with JHC?  I'm getting an exception during Boxy WorkWrap that makes no sense to me: https://gist.github.com/dc6170d793399ee41cd505269fdc5a0b
13:02:23 <monochrom> well I dare tdammers to admit "the logical conclusion is that programmers are stupid"
13:02:51 <pikajude> and that you can sell open-source software
13:02:56 <pikajude> which is true, but very inefficient
13:03:06 <orion> That's why you sell support contracts instead.
13:04:02 <monochrom> you should also consider "commision the creation of a piece of software" like people commission music and paintings.
13:05:07 <dolio> monochrom: Programmers are stupid, though.
13:05:11 <dmwit> I will admit that programmers are stupid.
13:05:18 * dmwit high fives dolio
13:05:22 <monochrom> like how a duke paid Beethoven to write a symphony but afterwards everyone could perform it. (but there is also a fee to pay to the publisher of the score.)
13:05:53 <ab9rf> an application is not the same as a program; an application might involve multiple programs as well as other components that are not programs :)
13:05:56 <monochrom> or maybe it was Dvorak rather than Beethoven
13:06:19 <monochrom> oh counting programs is like counting theorems.
13:06:22 <geekosaur> most of the classical composers, really
13:06:32 <dmwit> Programmers, like most other humans, are rushed but effective optimizers that rarely happen to be optimizing the exact same utility function as you are.
13:06:34 <pikajude> i think it may have been qwerty actually
13:06:55 <monochrom> you could say "x+y=y+x" is one theorem, "x+0=x" is another theorem. but then "x+y=y+x and x+0=x" is one theorem too.
13:07:47 <monochrom> if I combine two programs in a highly integrated way (this is subjective but surely there are cases you'll say yes), that becomes one program.
13:09:42 <monochrom> anyway read several textbooks for linear algebra. enjoy how some says "10 axioms" some other says "9 axioms" etc.
13:10:04 <Rembane> Math isn't as formal as it should be.
13:10:17 <dolio> The definition of 'and' is a correspondence between two-theorems and one-theorem.
13:10:20 <et09> you guys, what if the universe and us are like, the same thing
13:10:26 <dolio> That forms an adjunction.
13:15:03 <djrollins> Hey guys, my brain has been thoroughly melted from an example in Haskell Programming from first principles. Anyone know a way of explicitly seeing how expressions expand?
13:15:21 <djrollins> I cannot get my head around what the following is doing:
13:15:40 <djrollins> fibs = 1 : scanl (+) 1 fibs
13:15:52 <EvanR> is it correc tto say that you can't show a give number is BB(7918) with ZFC
13:16:01 <implementation> et09: prolog says 'no'. and when it comes to unification, prolog is always right. http://lpaste.net/4829958614347153408
13:16:03 <djrollins> I know what it produces - but how it evaluates I cannot fathom.
13:16:27 <dolio> EvanR: I think it's way below that now.
13:16:31 <EvanR> djrollins: it takes practice, and is a good exercise to understand lazy evaluation. But I do recall some simulators floating around
13:16:59 <dolio> Like 7918 was the original result, but people have gotten it down to less than 1/4 of that.
13:17:04 <ph88^> johnw, uniplate doesn´t use GHC.Generics afaik, i wanted to make a function similar as transformBi on top of GHC.Generics
13:17:08 <EvanR> dolio: i figured i was looking at an old blog post
13:17:52 <EvanR> but any given such machine-that-searches-for-contradictions-in-zfc, does that mean you cant prove its a busy beaver number of that size with ZFC?
13:18:50 <dolio> Yes, that's the idea. BB(N) where N is the size of the machine is undetermined by the ZFC axioms.
13:19:06 <EvanR> so you need to prove it another way?
13:19:24 <EvanR> no thats not it
13:19:39 <byorgey> djrollins: there used to be a website that would show step-by-step reductions, but I don't know what happened to it
13:19:59 <EvanR> for low N where we know BB(N), its not relevant since its not encoding such a program
13:20:25 <EvanR> dolio: do you know what the lowest is now?
13:20:33 <dolio> It's like 'BB(N) = M' is independent, like the continuum hypothesis.
13:20:52 <byorgey> djrollins: you can kind of do it yourself though.  What's the definition of scanl?
13:21:02 <dolio> Or, for some M, I guess. There are probably some M that aren't independent.
13:21:23 <dolio> EvanR: I haven't really paid attention. I just know that they got it down to like 2000 or 1000 shortly after the paper was published.
13:21:23 <EvanR> the difference seems critical to me
13:21:43 <monochrom> the step-by-step website disappeared because no one hosted it anymore
13:22:17 <monochrom> by I can do it manually upon request. I may ask for a fee for big jobs.
13:22:20 <dolio> And by 'they' I mean people on the internet.
13:23:39 <dolio> EvanR: So, like, we know BB(N) for very small N, so for the independent number K, you'd have BB(K) > BB(3), so presumably BB(K) = BB(3) is determined to be false.
13:24:13 * hackagebot sphinx 0.6.0.2 - Haskell bindings to the Sphinx full-text searching daemon.  https://hackage.haskell.org/package/sphinx-0.6.0.2 (paulrouse)
13:24:13 <EvanR> its strictly increasing right
13:24:51 <djrollins> byorgey, thanks. I'm going go and manually go through the beta reduction now. I'll holla if I get stuck!
13:24:59 <monochrom> but fibs = 1 : scanl (+) fibs is already done in my http://article.gmane.org/gmane.comp.lang.haskell.cafe/23231
13:25:02 <dolio> But there is no M such that 'BB(K) = M' is a theorem (unless ZFC is inconsistent), and there are models that validate 'BB(K) = M' and 'BB(K) = N' for distinct M and N.
13:25:58 <EvanR> K isnt independent though, i think thatspart of the detail here. K has to be number of states of the specially designed program
13:26:33 <dolio> Yes. It is the value of BB(K) that is undetermined.
13:27:06 <dolio> K is just the number of states in a Turing machine described in ZFC that decides something related to the consistency of ZFC.
13:27:07 <EvanR> what kind of model of ZFC lets you know that BB(K) = something?
13:29:17 <dolio> Any model. That's kind of the idea of models.
13:29:34 <EvanR> hmm
13:30:07 <EvanR> you can come up with a model that doesnt contradict ZFC, by just assigning this fact arbitrarily? since its apriori independent?
13:30:24 <dolio> Models of ZFC can't contradict ZFC, otherwise they wouldn't be models.
13:30:45 <EvanR> is modeling constructive?
13:31:10 <dolio> You should read about model theory, probably.
13:31:34 <dolio> The idea is like denotational semantics, though.
13:33:16 <dolio> You have your object theory and a mathematical structure in some meta theory, and there should be some mapping between sentences in the object theory and meta-propositions about your mathematical structure, or something along those lines.
13:34:14 * hackagebot hreader-lens 0.1.1.0 - Optics for hreader package  https://hackage.haskell.org/package/hreader-lens-0.1.1.0 (dredozubov)
13:34:18 <EvanR> probably
13:35:50 <dolio> When you have an undetermined sentence, there are some structures where the sentence maps to something true about the structure, and some where it is false.
13:36:14 <EvanR> is that the definition of undetermined?
13:36:18 <dolio> And Goedel's incompleteness theorem says that every first-order ... theory has undetermined sentences.
13:36:57 <dolio> The busy-beaver thing is just a more concrete example with a problem that seems relatively small.
13:37:47 <dolio> No, undetermined would probably be defined as 'is not a theorem, nor is its negation'.
13:38:21 <EvanR> huh, that sounds like an excluded middle not being excluded
13:38:43 <EvanR> which i never heard of before
13:39:07 <EvanR> not P AND not (not P)
13:39:14 * hackagebot pandoc-citeproc 0.10.2.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.2.1 (JohnMacFarlane)
13:39:20 <dolio> Just because you can derive '|- A \/ ~A' doesn't mean you can derive '|- A' or derive '|- ~A'
13:39:21 <EvanR> nevermind, two different nots
13:40:04 <dolio> The ability to do that is called the 'disjunction property', and is one of the ways people specify which logics are "constructive".
13:40:57 <EvanR> the A here would be "not a theorem"...
13:41:10 <EvanR> guess thats something technical
13:41:23 <dolio> 'A is a theorem' means '|- A' is derivable from no premises.
13:41:38 * monochrom dualizes this and invents "deconstructive logic" and grins
13:42:25 <EvanR> "nothing unreal exists" -- star trek
13:43:44 <dolio> So, you can see why many classical systems aren't constructive, because the incompleteness theorem says there exists an A such that neither '|- A' nor '|- ~A' is derivable, but '|- A \/ ~A' is trivially derivable.
13:44:14 * hackagebot hledger-lib 1.0 - Core data types, parsers and functionality for the hledger accounting tools  https://hackage.haskell.org/package/hledger-lib-1.0 (SimonMichael)
13:45:12 <EvanR> ok
13:45:43 <EvanR> so its broken since you cant seem to go in the forward direction, construct a A V ~A from an A or a ~A
13:46:07 <EvanR> er... you can. but you cant have either
13:46:16 <EvanR> but you can have the latter
13:46:22 <EvanR> yep makes no sense
13:46:59 <dolio> The point of the disjunction property is that to prove 'A \/ B' you're supposed to have proved either 'A' or 'B' as a prerequisite.
13:48:00 <dolio> There's a related property called the 'existence property' which says that to prove 'exists x. P' you should have proved 'P[x := V]' for some particular 'V' as a prerequisite.
13:48:03 <EvanR> and LEM gives it to you even when you cant get A or B
13:48:09 <dolio> Right.
13:48:10 <bollu> are there languages with non-injective constructors?
13:48:22 <dolio> Yes.
13:48:34 <dolio> GHC has non-injective constructors.
13:48:38 <bollu> dolio: which ones? and what's the use case?
13:48:41 <bollu> waiit what?
13:48:43 <bollu> give me an example
13:48:53 <dolio> data E = forall a. E a
13:48:54 <EvanR> type families
13:49:14 * hackagebot hledger 1.0 - Command-line interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-1.0 (SimonMichael)
13:49:16 * hackagebot hledger-ui 1.0 - Curses-style user interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-ui-1.0 (SimonMichael)
13:49:18 <dolio> By parametricity, E x = E y even if x /= y.
13:49:18 * hackagebot hledger-web 1.0 - Web interface for the hledger accounting tool  https://hackage.haskell.org/package/hledger-web-1.0 (SimonMichael)
13:49:20 * hackagebot hledger-api 1.0 - Web API server for the hledger accounting tool  https://hackage.haskell.org/package/hledger-api-1.0 (SimonMichael)
13:49:26 <bollu> dolio: ah, right.
13:49:55 <bollu> EvanR: hm, I'd never thought about defining injectivity on type families. can you expand on that?
13:50:06 <EvanR> i guess its not really constructors
13:50:17 <EvanR> but you can do F Int = Bool, F Bool = Bool
13:50:24 <bollu> EvanR: ah, right, okay
13:50:41 <bollu> EvanR: also, I meant to ask - what is the notion of open versus closed in type families?
13:50:42 <EvanR> which actually matters to type checking, because it cant go backwards
13:50:47 <bollu> and can we force a type family to be injective?
13:51:18 <monochrom> that one is like open vs closed classes. open = everyone can add more instances. closed = no.
13:51:49 <monochrom> or another way to say is instances can be added post-mortem
13:52:19 <EvanR> expostfacto
13:53:44 <EvanR> injective type families were added in GHC 8 i think
13:53:44 <polo> Hi guys, if I have the following data : data Pokemon = Pokemon String Int Int Type | None deriving (Show,Eq) ; and i want to make a data Trainer like this: data Trainer = Trainer String [Pokemon,Pokemon,Pokemon]  deriving (Show, Eq) ; why the list that takes three Pokemon won't work?
13:54:03 <monochrom> you are confusion type and value
13:54:21 <kadoban> polo: The list type doesn't have specified lengths like that.  [Pokemon] would be the type of a list of Pokemon values.
13:54:22 <EvanR> [Pokemon,Pokemon,Pokemon] is wrong, type constructor [] takes 1 argument
13:54:25 <monochrom> a list value can be like [1,2,3] or [1,2] or any length you like
13:54:27 <bollu> EvanR: so it disallows the type family from being non ibjective?
13:54:34 <kadoban> polo: (Pokemon, Pokemon, Pokemon) would be a tuple of exactly 3 Pokemon values
13:54:40 <monochrom> but clearly the type is [Int] not [Int,Int,Int].
13:54:48 <bollu> :t [1, 2, 3]
13:54:50 <lambdabot> Num t => [t]
13:54:51 <bollu> :t [1, 2]
13:54:54 <lambdabot> Num t => [t]
13:54:55 <bollu> ^
13:55:13 <bollu> also, why does GHCi sometimes generate Int versus Integer?
13:55:19 <EvanR> bollu: see TypeFamilyDependenies extension
13:55:31 <EvanR> spelled right
13:55:31 <bollu> this came up a couple weeks back and I didn't know the answer
13:55:31 <bollu> EvanR: thanks
13:55:33 <monochrom> some functions are nailed to Int
13:55:35 <Tuplanolla> It's the monomorphism restriction again, bollu.
13:55:56 <bollu> Tuplanolla: expand on that?
13:56:10 <monochrom> if you say "\n -> take n [(), ()]" that n will be Int because take likes it Int
13:56:46 <Tuplanolla> Here: https://wiki.haskell.org/Monomorphism_restriction
13:56:58 <bollu> monochrom: hm, but this was in something silly where I don't think I was forcing the type. I'll try and get back to you with the exact eample
13:57:16 <monochrom> yes, a reproduction will help
13:57:18 <bollu> Tuplanolla: wow, what, that exists? TIL
13:57:46 <monochrom> but monomorphism plus defaulting should give you Integer rather than Int
13:58:09 <monochrom> so if you get Int you have some function that positively demands it
13:58:51 <xocolatl> anyone use parsec in here?
13:58:57 <Tuplanolla> At this very moment, xocolatl.
13:59:03 <johnw> xocolatl: many of us
13:59:18 <Tuplanolla> (Megaparsec counts.)
13:59:21 <xocolatl> I'm trying to match a timestamp
13:59:51 <xocolatl> not having much luck making it simple
14:00:17 <bollu> Tuplanolla: have you tried out trifecta? It seemed interesting but I didn't know how to get it to work
14:00:19 <monochrom> you should start by writing down the grammar of the timestamp format.
14:00:25 <Tuplanolla> Nope, bollu.
14:00:31 <monochrom> it is not the end but it is a necessary start.
14:00:33 <johnw> bollu: trifecta and parsers are both excellent
14:00:42 <bollu> is the monomorphism restriction still needed?
14:00:45 <Tuplanolla> @hackage trifecta
14:00:45 <lambdabot> http://hackage.haskell.org/package/trifecta
14:00:45 <johnw> the usage should *almost* be identical to parsec
14:00:52 <bollu> like, is it still a "practical" thing to have?
14:00:59 <bollu> johnw: I couldn't find the combinators in the package?
14:01:00 <Tuplanolla> Some people think so, bollu.
14:01:06 <xocolatl> I want something like  do { count 4 digit; char '-'; count 2 digit; ... }  but how do I get the entire match instead of just the last?
14:01:10 <johnw> bollu: they are in 'parsers'
14:01:19 <bollu> johnw: ahhh, damn. I'm stupid :) thanks
14:01:44 <monochrom> x <- count 4 digit; char '-'; y <- count 2 digit; ...
14:01:55 <monochrom> then you will have x and y at your disposal.
14:02:18 <monochrom> you probably need to review your lessons on the do-notation or the >>= operator.
14:02:23 <xocolatl> yuck, I really have to extract everything like that?
14:02:28 <bollu> I still find the converting failure… paper as some freaking "I know kung fu" type thing. it's _insane_ that you can parser in <40loc
14:02:42 <bollu> like, I still feel that the applicative instance of the Parser is magic
14:02:55 <monochrom> I wouldn't call that "extract".
14:03:15 <monochrom> If anything extracts, just by writing down "count 4 digit" you are already extracting.
14:03:33 <Tuplanolla> Have you seen löb spreadsheets, bollu?
14:03:36 <monochrom> the presence of "x <-" just means you care. the absence just means you don't care.
14:03:52 <bollu> Tuplanolla: no, do tell
14:03:59 <xocolatl> I guess a regex is best then
14:04:00 <monochrom> so, make a decision: do you care or not?
14:04:12 <Tuplanolla> bollu: https://gist.github.com/PkmX/182c6c5444b695d9a794
14:04:15 <xocolatl> I care about the entirety of it, not each individual piece
14:04:23 <monochrom> a regex does not spare you from this decision.
14:04:36 <xocolatl> sure it does, it gives me the full match
14:05:31 <EvanR> hmm regex spares you from making decisions...
14:05:37 <EvanR> explains a lot
14:05:57 <monochrom> If you write "[0-9]{4}-[0-9]{2}", it still means you don't care. If you write "([0-9]{4})-([0-9]{2})", it still means you care. You still have to confront the same question, just that this time you use parentheses instead of "x<-".
14:06:16 <bollu> Tuplanolla: I'm a little too sleepy to parse the recursive definition right now, but I'll come back to it tomorrow
14:06:19 <bollu> thanks for the link
14:06:23 <monochrom> Oh you do want to lose the "-" there, don't you?
14:06:33 <ph88^> is it possible to use GHC.Generics to write a transform function that traverse a graph of different types and only does something to the matched type ?
14:07:05 <xocolatl> no, I don't want to lose anything.  it's already in the perfect format to be passed to `read` to get the timestamp
14:07:27 <monochrom> then use readMaybe. you don't even need parsec.
14:07:28 <EvanR> sounds like you dont want to extract anything, just recognize the pattern
14:07:28 <glguy> xocolatl: If you can `read` it, then you should just use Text.Read.readMaybe and read it
14:07:46 <monochrom> What kind of XY problem is this?
14:08:06 <glguy> As far as extracting matches with parser combinators, however, attoparsec has match :: Parser a -> Parser (Text, a)
14:08:16 <xocolatl> it's not any kind of XY problem, I asked to be able to parse a timestamp
14:09:01 <xocolatl> it'll be part of a larger line in a log file
14:09:04 <monochrom> I would use readMaybe or reads and be done. But it's your poision.
14:09:26 <EvanR> parsing a large thing, within yet a larger thing
14:09:37 <EvanR> you need parser combinators
14:10:01 <xocolatl> except then I need to save every character
14:10:02 <Tuplanolla> `system "sed ..."`
14:10:15 <EvanR> huh
14:11:07 <xocolatl> and I don't know if that trifecta link was for me or not but its readme is "This package provides a parser that focuses on nice diagnostics." so based on the quality of the documentation it sucks ass
14:12:41 <Tuplanolla> It still sounds doable with two lines of any parser combinator library.
14:13:21 <bollu> there's some sort of equivalence between type families and functional dependencies?
14:13:26 <xocolatl> the problem is the same problem I always have with haskell: there is no documentation at all
14:13:46 <fr33domlover> bollu, there is some, you can read in the haskell wiki
14:13:58 <fr33domlover> very good docs there about this topic
14:13:59 <EvanR> the wiki probably isnt the best resource at this point
14:14:02 <bollu> I understand GADTs and type families, and I get where we would use functional dependencies (with multi parameter type classes), but, I don't get how the 3 interact
14:14:18 <bollu> yes, I was worried if the wiki was outdated or broken or something
14:14:28 <Tuplanolla> Hackage's Haddock thing is broken at the moment, but you can view the docs of older versions, xocolatl, like this one: https://hackage.haskell.org/package/megaparsec-5.1.1/docs/Text-Megaparsec.html
14:14:35 <fr33domlover> bollu, i read those specific wiki pages and they were good
14:14:38 <EvanR> i.e. its a wiki
14:14:55 <bollu> fr33domlover: link please?
14:16:01 <fr33domlover> bollu, here's one https://wiki.haskell.org/Type_families#Comparing_type_families_and_functional_dependencies
14:16:17 <fr33domlover> bollu, but there's more, try a web search
14:17:01 <sm> good news everyone! hledger 1.0 is released on hackage. I will announce when in stackage, hopefully in a few days. Any testing before then is appreciated!
14:17:20 <fr33domlover> sm, congrats
14:17:38 <johnw> sm: congrats!!!
14:19:25 <bollu> thanks :)
14:20:15 <sm> thanks!
14:20:25 <delYsid> Hmm, is there something like satisfyM, or can I build it?  I'd like to be able to use unexpected inside of the satisfy predicate...
14:21:07 <johnw> delYsid: you could use anyChar and guard
14:21:46 <delYsid> johnw: hah, been there, done that, but then error locations are off by one because anyChar has already consumed the char.
14:21:50 <johnw> do x <- anyChar; unless (P x) (unexpected "foo")
14:23:19 <johnw> how about: do b <- P <$> lookAhead anyChar; unless b (unexpected "foo")
14:23:33 <johnw> then you'll need to consume again if it matches
14:24:17 <delYsid> hmmmm, that would work, but somehow looks hackish.
14:24:43 <johnw> well, you could roll your own parser with mkPT, which gives you complete control
14:25:37 <delYsid> I guess so, but that is definitely overkill.  so lookAhead it will be.
14:26:07 <johnw> if I were to write satisfyM, that's what I'd use to do it, btw
14:26:13 <johnw> to avoid the "double parsing"
14:32:42 <ch3pjw> Hello haskellers! I'm starting to look into the lens library and a lot of the examples are awesome. I'm wondering about trying to look into nested Data.Map objects using `at` and running into some difficulty. Any suggestions?
14:33:24 <johnw> ch3pjw: suggestions about what?
14:33:51 <Welkin> about whether to get the red or greeen curry
14:33:56 <glguy> I'd suggest putting some code that you wrote that didn't do what you thought along with the error message if applicable onto lpaste.net and then asking here
14:33:58 <ch3pjw> Composing `at` to get a value via successive keys from the map
14:34:19 <johnw> ch3pjw: you'll need to be much more specific
14:34:19 <ch3pjw> glguy: ok :-)
14:35:45 <Tuplanolla> Why is currying constraints so unpopular?
14:37:04 <glguy> For one thing you can't do it in standard Haskell
14:37:24 <Tuplanolla> Oh. It would've been nice for `TypeApplications`.
14:38:18 <glguy> Tuplanolla: Why's that?
14:38:58 <Tuplanolla> They have to impose an ordering convention for the type parameters now.
14:39:45 <glguy> TypeApplications doesn't allow you to specify "dictionary" arguments
14:39:54 <glguy> You're still specifying type variables
14:40:38 <glguy> Maybe you have an example of something you'd like to be able to do?
14:41:56 <implementation> for me it's about readability. "Foo a => Bar b => a -> b" looks a lot like "Foo a -> Bar b -> a -> b" (Foo and Bar could be parametrized types rather than constraints) -- in contrast to "(Foo a, Bar b) => a -> b"
14:42:08 <lpaste> ch3pjw pasted “Nested Data.Map and successive lookups with at” at http://lpaste.net/304824
14:42:50 <ch3pjw> glguy, johnw: ^^^
14:43:20 <glguy> ch3pjw: OK: lens doesn't have that built in, but you can build one:
14:44:33 <koz_> I agree with implementation. I bracket-wrap my type constraints, even if I only have one.
14:44:39 <glguy> ch3pjw: You have a bit of a mismatch, however. you're taking a variable length list of keys
14:44:53 <glguy> but at each level the type of thing being looked up is different
14:45:37 <glguy> ch3pjw: If you had a recursive structure where the values contained in the maps were of the same type as the maps themselves you could compose a bunch of at together based on a variable length list, however
14:45:42 <ch3pjw> glguy: Ah, yes. In my code I was thinking of using a recursive sum type
14:46:08 <glguy> ch3pjw: Suppose we were working with the Value type from "aeson"
14:46:14 <ch3pjw> glguy: I think we just said the same thing (but I'm fairly new to this!)
14:46:50 <johnw> > let m = M.fromList [("hello", 1), ("world", 2)] in M.fromList [("a", m), ("b", m)] ^? ix "a". ix "hello"
14:46:53 <lambdabot>  Just 1
14:47:00 <ch3pjw> glguy: I was trying not to use the recursive sum type in my playing around as, perhaps naively, I thought that not using custom types would make thing simpler
14:47:33 <joe9> is there a haskell library for utf32 to utf8 conversions?
14:47:47 <glguy> ch3pjw: In a case as described you could write this:  Prelude.foldr (.) id . Prelude.map key :: [Text] -> Traversal' Value Value
14:48:44 <glguy> joe9: the "text" package can decode UTF-32, and it can encode UTF-8
14:49:12 <shirt> how can i call putStrLn from arbitrary threads without having their output interleaved? is there some global lock that already exists that i can use?
14:49:25 <joe9> glguy: Thanks a lot.
14:49:31 <ch3pjw> glguy: cool, thanks - I'll give it a try :)
14:49:51 <glguy> shirt: No, there isn't such a lock. You'll have to synchronize yourself
14:50:21 <shirt> glguy: bummer thanks
14:50:26 <johnw> shirt: or post your strings to a Chan, and then create a dedicated thread that prints out whatever is posted to that channel
14:51:01 <shirt> johnw: do any of the available logging packages take care of all this for me?
14:52:41 <johnw> shirt: maybe fast-logger; it says it allocates a logging buffer "per capability"
14:53:22 <xcmw> In a function type declaration how can a specify the an argument must have two different types? I have a lens that must work on two different types. I need it to be Getter A B and Getter C D.
14:53:27 <shirt> johnw: awesome thanks
14:54:17 <glguy> xcmw: Either those two types have a single common type that you can use, or if it's a totally different implementation in each case you have to use a typeclass
14:54:47 <EvanR> can you explain two types having a single common type
14:55:12 <glguy> Getter [Int] Int  -- Getter [Char] Char  ---> Getter [a] a
14:55:12 <xcmw> No single common type. The property names of A and C are the same but the types are different.
14:55:51 <glguy> xcmw: Then you'll need a typeclass so you can vary the implementation by the types
14:56:10 <xcmw> glguy: ok
14:56:32 <EvanR> is it important for the names of these two lenses to be same
14:56:38 <EvanR> or are you trying to do something polymorphic
14:56:56 <xcmw> I already have the lens and they work fine
14:57:02 <Tuplanolla> I read his question as a request for the opposite of `~` constraint. I take it such a thing doesn't exist.
14:57:28 <EvanR> because having two names solves this issue in my head
14:58:18 <EvanR> or taking the original question literally, a function whose argument may be either of two types is Either A B -> C
14:59:45 <joe9> glguy: also stumbled upon text-icu . Just want to check if you recommend it.
15:00:01 <joe9> shirt, use a logger thread
15:00:37 <glguy> joe9: Two problems, text-icu introduces an external C library dependency that your users will need to install, it already depends on the text package that already handles this just as well
15:03:29 <Koterpillar> glguy: can I have removeAccents without text-icu?
15:03:46 <glguy> Koterpillar: I'd have to look, I don't know
15:04:02 <Koterpillar> removeAccents = T.filter (not . isMark) . normalize NFD
15:04:19 <Koterpillar> I'd very much like to not hunt for the library versions
15:04:19 <johnw> glguy: "just as well"?
15:04:30 <johnw> i'd be surprised if text was as complete in its Unicode handling as ICU
15:04:41 <glguy> johnw: What do you think the original qusetion was?
15:04:54 <johnw> glguy: conversion of UTF-32 to UTF-8, no?
15:05:03 <glguy> Yeah, there's no special unicode cases there
15:05:07 <johnw> ah, ok
15:05:39 <glguy> (there were a multiple text questions in play, just making sure)
15:06:22 <EvanR> im still not clear in what cases Text is going to mangle something because of the utf16 surrogate thing
15:08:05 <EvanR> pack unpack ...
15:08:32 <EvanR> i wonder if coverting utf32 has that issue
15:11:25 <joe9> glguy: Thanks.
15:12:21 <glguy> EvanR: UTF-32 doesn't include those values
15:12:26 <glguy> "Because surrogate code points are not included in the set of Unicode scalar values, UTF-32 code units in the range 0000D80016..0000DFFF16 are ill-formed."
15:12:51 <EvanR> alrighty then
15:13:09 <glguy> as well as a cap at 0x10ffff
15:13:24 <EvanR> funny ive never actually dealt with utf32 so i dont know how it works
15:13:29 <hpc> moral of the story, never use characters
15:13:36 <hpc> the only universally compatible text format is .png
15:13:49 <Cale> because 1114111 codepoints should be enough for anyone
15:14:11 <EvanR> 1 ... MILLION.. characters
15:14:21 <glguy> Cale: I need at least 1114112
15:14:32 <ReinH> One... hundred... billion dollars
15:14:43 <glguy> (excepting those pesky surrogate pairs)
15:15:14 <johnw> Cale: and yet, I still only get ~9 latin characters to act as subscripts
15:15:16 <Rarrikins> hpc: That doesn't support animated characters!
15:15:40 <Cale> glguy: You're in luck, I was off-by-one
15:15:40 <Koterpillar> so do we just import CSS into Unicode?
15:16:04 <EvanR> > 0x10ffff
15:16:07 <lambdabot>  1114111
15:16:09 <Cale> Koterpillar: kill me
15:16:31 * Koterpillar performs a character injection attack
15:16:41 <johnw> we need a separate codepoint for every cat jpeg
15:16:55 <glguy> Koterpillar: Maybe a "character assassination"?
15:16:57 <johnw> otherwise, future historians won't understand us
15:17:26 * Cale is currently struggling with the fact that some CSS works in Chrome 51 and newer (but possibly not particular builds of 53), but not 50 and older.
15:18:14 <geekosaur> http://languagelog.ldc.upenn.edu/nll/?p=29034 re codepoints
15:18:18 <geekosaur> (wtf)
15:18:50 <EvanR> stick to basics: html 4.01 transitional
15:18:54 <Tuplanolla> I wish just 256 of those millions were set aside for proper line drawing characters. I should be able to draw things in the terminal, because that's what I have to use anyway.
15:19:27 <hpc> ascii line art should be enough for anyone
15:20:02 <Rarrikins> There were box-drawing characters in IBM ASCII, so they'll be there in Unicode.
15:20:07 <EvanR> one red light that always stays on should be enough for anyone
15:21:14 <xcmw> Sorry for not explaining clearly. http://lpaste.net/304951
15:21:16 <Tuplanolla> They're too limited, Rarrikins.
15:21:44 <EvanR> all the asinine lore of computer history has been encoded, including emojis, but there are no proper indic ligatures... which i guess counts as asinine computer lore (ISCII)
15:23:19 <hpc> EvanR: computer history ended in 1987
15:23:24 <hpc> everything since has been "cyber issues"
15:26:25 <geekosaur> of course, they gave us the private use area so ubuntu could do this to us... 
15:26:41 <hpc> that's just a box for me
15:26:47 <geekosaur> (U+F200, in the fallback font on Ubuntu derived systems only...)
15:27:16 <geekosaur> ubuntu wordmark
15:27:22 <hpc> ugh
15:27:41 <geekosaur> with something that might be a registered trademark symbol even
15:27:44 <geekosaur> what even...
15:27:47 <Welkin> what's that?
15:28:05 <orion> ®
15:28:21 <Welkin> lol
15:28:27 <EvanR> OSX has a lot of these
15:28:32 <Welkin> I copied that character into ddg
15:28:39 <Welkin> and it came up with "no results"
15:28:54 <Welkin> but in the sidebar is showed an entry from wikipedia "Private Use Area"
15:28:55 <geekosaur> sure, it's private use area
15:28:57 <EvanR> OSX lets you put / in file names
15:29:06 <geekosaur> not guaranteed to be anything
15:29:12 <EvanR> but its not literally / its a private use character that looks like / on osx only
15:29:19 * hackagebot pandoc 1.18 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.18 (JohnMacFarlane)
15:29:35 <Tuplanolla> I see that thing as a combined down tack with a thin H.
15:29:45 <geekosaur> could be worse, up to 10.6 or so they just swapped colons (os 9 and earlier path separator) and slashes
15:30:17 <Welkin> so they did a colonoscopy?
15:30:36 <Tuplanolla> Oh, it's Korean.
15:31:22 <dmj``> Welkin: off topic?
15:31:35 <hpc> dmj`: just a typesetting pun
15:31:47 <dmj`> hpc: ah, I see now :) 
15:31:59 <hpc> though technically a colonectomy, unless they simply looked at the file paths
15:32:02 <hpc> ;)
15:32:16 <dmj`> heh
15:32:18 <hpc> gotta study them subpixels
15:32:29 <Welkin> dmj`: the channel?
15:32:29 <geekosaur> they're replacing them, so it's colonotomy
15:32:34 <EvanR> how does HashMap deal with collisions?
15:33:06 <Welkin> EvanR: using normal vectors and force calculations
15:33:13 <Tuplanolla> It's this thing duplicated for some reason: ￎ
15:33:16 <monochrom> I think it degenerates to Eq
15:34:38 <EvanR> i see, it has Eq and Hashable constraint on most things
15:34:55 <monochrom> in fact doesn't Hashable already include Eq?
15:35:15 <EvanR> no
15:35:20 <daey> im trying to use Text.Regex.Posix for pattern matching. checking a string for a fixed substring works, but how am i supposed to compare to patterns?
15:35:28 <daey> n = "asdf asdf" =~ "(a-z)+"
15:35:37 <EvanR> (in C# Eq includes Hashable!)
15:35:46 <monochrom> alright
15:35:47 <daey> that obviously checks for the substring (a-z)+ which isnt there
15:36:37 <glguy> daey: (a-z)+ matches  "a-z" and "a-za-z" , etc
15:36:52 <monochrom> square brackets, yeah
15:37:26 <daey> glguy: yes i know how regex works. but in that setting its not interpreted as a regex rule, its simply interpreted as the string it is
15:37:32 <glguy> daey: no
15:37:44 <daey> but it returns []
15:38:04 <glguy> Prelude Text.Regex.Posix> "stuffa-za-zstuff" =~ "(a-z)+" :: String
15:38:05 <glguy> "a-za-z"
15:38:08 <monochrom> consider "a-za-za-z" =~ (a-z)+" to see that the + works
15:38:21 <daey> http://pastebin.com/e5nw2F0G
15:38:40 <daey> well i should see at least a single letter as a result
15:38:57 <glguy> daey: You meant to write this pattern:  "[a-z]+"
15:39:02 <glguy> But you wrote: "(a-z)+"
15:39:04 <orion> hmm
15:39:08 <daey> ah
15:39:29 <orion> Has anyone ever noticed that the "readCertificateStore" function in Data.X509.CertificateStore eats up lots of CPU and memory?
15:39:32 <orion> On Xenial.
15:39:36 <daey> yeah ty :)
15:39:49 <daey> im used to ([]) :p
15:40:28 <monochrom> the lesson is that you need to put in your own [] in order to avoid the output being []
15:40:51 <monochrom> best regex advice ever
15:40:56 <glguy> Ah, right. The regular expression was giving you some square brackets to use
15:42:15 <Bonnie> Its the first time Im confronted with programming, trying to understand haskell!! can anyone help?
15:42:35 <dmj`> Bonnie: yes, you've come to the right place
15:42:49 <Bonnie> thank u dmj
15:43:14 <daey> Bonnie: dont worry i know a few languages, but i still have no idea what im doing in haskell :D
15:43:15 <dmj`> Bonnie: there is also #haskell-beginners as well
15:43:28 <heebo> Bonnie: I recommend haskell programming from first principles aka haskellbook
15:43:38 <Bonnie> ah okay cool!
15:43:50 <maerwald> heebo: is that free?
15:43:54 <Bonnie> i will join haskell-beginners then!
15:43:55 <heebo> it really takes you all the way through from beginner to intermediate
15:44:00 <Bonnie> thank you!
15:44:05 <Tuplanolla> Does the absence of #haskell-experts mean nobody is that good yet?
15:44:08 <heebo> heebo: unfortunately no
15:44:13 <EvanR> #haskell-in-depth
15:44:19 * hackagebot store 0.3 - Fast binary serialization  https://hackage.haskell.org/package/store-0.3 (MichaelSloan)
15:44:21 <daey> Tuplanolla: they all give up after intermediate :P
15:44:21 <jle`> can anybody really say they're an expert in haskell
15:44:31 <heebo> maerwald: unfortunately no
15:44:32 <jle`> there is no skill ceiling in haskell
15:44:35 <maerwald> heebo: did you read it?
15:44:54 <EvanR> expert is a tough one in any language
15:45:06 <heebo> maerwald: yes, ive read quite a few haskell books and this is by far the best in my opinion
15:45:33 <heebo> its also very long, but if you really wanting to learn haskell properly i suggest this book very strongly
15:46:10 <EvanR> are you the author? ;)
15:46:16 <monochrom> you don't need a ceiling to be an expert.
15:46:55 <heebo> lol no , i actually fell out with the authors over lambdaconf(gate)
15:46:56 <maerwald> I usually don't suggest non-free teaching/learning material
15:47:04 <dmj`> expert beginner
15:48:00 <orion> "expert beginner" -- sorry to hear that.
15:49:19 * hackagebot store-core 0.3 - Fast and lightweight binary serialization  https://hackage.haskell.org/package/store-core-0.3 (MichaelSloan)
15:49:48 <daey> what exactly does this line say? n :: AllTextMatches [] String . I know the standard function ?descriptor? with String->String. But that line contains no ->
15:50:30 <monochrom> then it depends on what the type AllTextMatches means.
15:50:42 <jle`> daey: the type of n is AllTextMatches [] String
15:50:53 <EvanR> AllTextMatches is a type constructor being applied to two arguments
15:50:54 <geekosaur> try in ghcxi, after importing Text.Regex.Posix: :i AllTextMatches
15:51:18 <geekosaur> er, in ghci
15:51:19 <daey> jle`: but that would be just a list of strings, from what i can tell
15:51:30 <jle`> daey: it depends on what AllTextMatches is
15:51:47 <jle`> daey: for example, `Either String Bool` is the type Either parameterized by String and Bool
15:52:07 <jle`> 'Map Int String' is the type Map parameterized by Int and String
15:52:23 <jle`> 'AllTextMatches [] String' is the type AllTextMatches, parameterized by [] and String
15:52:25 <EvanR> actually for all i know it could be a type synonym, or a type family
15:52:28 <jle`> so it all depends on what AllTextMatches is
15:52:31 <geekosaur> also, the maze of type aliases used by Text.Regex is still horrifying
15:52:51 <daey> well removing the AllTextMatches results in failure
15:53:00 <EvanR> dont remove it, look it up
15:53:01 <jle`> daey: well, yeah, those are different types
15:53:02 <sigrlami> how can I do 'm a -> IO a' ?
15:53:07 <jle`> "Either String Bool" is different than "String Bool"
15:53:10 <jle`> sigrlami: that depends on what 'm' is
15:53:21 <jle`> daey: do you know about parameterized types, like Either, Map, Maybe?
15:53:24 <sigrlami> some monad
15:53:30 <jle`> sigrlami: it depends on the monad
15:53:42 <johnw> sigrlami: generally speaking, if it's just Monad m, you can't
15:53:42 <jle`> Maybe? Either e? Reader r?
15:54:00 <jle`> it is probably not a very good tactic to look for a polymorphic solution
15:54:08 <jle`> if you know the specific type you want to do it for
15:54:35 <geekosaur> sigrlami, that cannot be done for arbitrary Monad m. that would let you e.g. reinterpret [a] as IO a
15:54:40 <geekosaur> which doesn't make a lot of sense
15:55:00 <EvanR> map return!
15:55:04 <jle`> well, it can be done for arbitrary Monad m, but it probably wouldn't be what you wanted
15:55:13 <EvanR> ah thatd be [IO a]
15:55:21 <johnw> jle`: how's that?
15:55:23 <daey> jle`: no havent seen those things yet
15:55:25 <EvanR> jle`: nope
15:55:58 <jle`> foo _ = throwIO (userError "what are you trying to do")
15:56:05 <jle`> the IO type has constructors forall a. IO a
15:56:06 <EvanR> lol
15:56:17 <EvanR> undefined
15:56:20 <jle`> so it's like [a], Maybe a, Either e a, etc. in that regard
15:56:22 <johnw> once you invoke undefined, you've failed :)
15:56:24 <jle`> it as non-bottom constructors
15:56:31 <jle`> those aren't undefined, those are actual non-bottom IO actions
15:56:52 <sigrlami> what's non-bottom?
15:56:54 <jle`> IO is just a type that has valid non-bottom polymorphic constructors forall a. m a
15:57:01 <jle`> just like [a], Maybe a, etc.
15:57:02 <heebo> run_ 
15:57:05 <EvanR> exitSuccess
15:57:12 <EvanR> ok
15:57:13 <jle`> sigrlami: soemthing like 'undefined'
15:57:18 <sigrlami> ah, ok
15:57:35 <heebo> e.g return . runReaderT 
15:57:39 <johnw> forever $ print "Hi"
15:57:44 <jle`> but throwIO (userError "hello") is a defined, IO action that can be fully evaluated without terminating
15:57:50 <heebo> or sequence runIdentity
15:58:00 <jle`> johnw: yes that too, probably would have been a better example haha
15:58:02 <sigrlami> jle`: ok, if it's my custom monad, can I do something to implement this?
15:58:08 <jle`> sigrlami: it depends on the monad
15:58:17 <jle`> literally every type is different
15:58:26 <daey> is it wrong to think of IO() like an impurity? once something (a function, a variable) had contact with it, it can not become pure again. Meaning it has to stay inside an IO monad?
15:58:28 <EvanR> i dont know if any of this counts
15:58:31 <jle`> that's like, one of the rules of haskell -- different types are different things :)
15:58:34 <EvanR> because you dont run IO
15:58:54 <jle`> daey: i don't think that that's a good way to think about it, but some people say that
15:58:54 <EvanR> you can observe the polymorphic [] and Nothing
15:59:10 <jle`> EvanR: its' not about running, it's about evaluating
15:59:19 <daey> jle`: at least my understanding isnt completely wrong then :)
15:59:34 <heebo> think not how to put m into IO but instead think how to put IO into m
15:59:47 <jle`> heebo: for example, here's an example type:
15:59:54 <jle`> data Foo a = F a
16:00:02 <jle`> er, * sigrlami 
16:00:06 <jle`> and here's how you'd write Foo a -> IO a:
16:00:13 <jle`> fooToIO (F a) = return a
16:00:35 <ertes> daey: a value of type (IO A) is an action that would produce an A
16:00:46 <ertes> daey: that's the most *useful* way to think of IO
16:01:03 <sigrlami> hm, ok, that's the other way to think about, I thought I can always add my own lifting function
16:01:12 <jle`> sigrlami: you can always add your own lifting function
16:01:14 <jle`> by defining it :)
16:01:42 <sigrlami> yes, I thought there is something semi-automatic, but will do hard way
16:01:44 <daey> ertes: but its not possible to convert something like StringIO to String right?
16:01:45 <jle`> sigrlami: btw, there's the MonadIO typeclass from 'transformers' for monads that support a specific type of m a -> IO a
16:01:46 <heebo> jle`: there is an assumption that you can deconstruct it
16:02:01 <sigrlami> ah! that's interesting. thanks!
16:02:03 <jle`> heebo: there's a deeper assumption that you can write it
16:02:07 <jle`> :P
16:02:11 <ertes> daey: that's not only not possible, but it doesn't even make sense:  you can't convert /bin/ls into a list of files, can you?
16:02:13 <EvanR> daey: IO String cant be converted to String, but you can execute it to possibly get a String
16:02:17 <jle`> heebo: it's not writeable for arbitrary types
16:02:20 <jle`> in a nice way
16:02:24 <heebo> jle`: ha yes!
16:02:32 <ertes> daey: one is a program, the other is the program's result
16:02:51 <jle`> sigrlami: so there's liftIO :: MonadIO m => m a -> IO a
16:02:59 <daey> i see
16:03:11 <jle`> sigrlami: and so some monads offer a MonadIO interface as a part of their API
16:03:22 <jle`> sigrlami: check the docs of your specific monad in question to see if they offer it! :O
16:03:29 <EvanR> wait
16:03:36 <EvanR> :t liftIO
16:03:36 <lambdabot> MonadIO m => IO a -> m a
16:03:36 <jle`> oh yeah
16:03:43 <jle`> i'm wrong
16:03:48 <jle`> ;_;
16:04:02 <EvanR> stop: hammertime
16:05:31 <sigrlami> looking at Control.Monad.IO.Class ; liftIO :: IO a -> m a
16:05:43 <sigrlami> yeah
16:06:30 <jle`> so yeah, you'd probably have to write your own if you can, or see if your monad in question offers it
16:06:43 <ertes> daey: a common misconception is that you "get into" IO and then you can never escape, but in reality it's the exact opposite:  you start in IO (your 'main' is an IO action), and you can interleave your action with arbitrary pure code
16:07:07 <Welkin> it's the hotel california
16:07:25 <sigrlami> jle`: class ( Functor m , Applicative m , Monad m , MonadIO m , MonadCatch m ) => MyMonad 
16:07:37 <daey> EvanR: if i understand correctly than readFile is in itself a StringIO() returning function, but by using the <- operator the variable you are saving it to contains a String instead of the StringIO() as the task itself is completed
16:07:54 <ertes> what's StringIO?
16:07:57 <Welkin> lol
16:08:02 <Welkin> daey: <- is not an operator
16:08:18 <Welkin> it is just syntactic sugar for >>= /a -> ...
16:08:37 <EvanR> daey: no
16:08:40 <Welkin> which siply pattern matches on the input to "pull it out"
16:08:52 <daey> just when i thought i got it all right
16:09:02 <EvanR> daey: not sure what youre thinking about with StringIO() 
16:09:06 <Welkin> there is no execution of anything except when you run `main`
16:09:10 <EvanR> its not a valid thing
16:09:15 <Welkin> your entire program is one big expression
16:09:20 * hackagebot wolf 0.2.12 - Amazon Simple Workflow Service Wrapper.  https://hackage.haskell.org/package/wolf-0.2.12 (markfine)
16:09:33 <ertes> daey: readFile :: FilePath -> IO String  -- readFile is a *function* (indicated by the (->))…  if you apply it to a file path, you get as the result an IO String, an action that reads the file
16:10:00 <EvanR> and IO String is not a function
16:10:27 <daey> EvanR: i didnt mean it to be a function
16:10:30 <EvanR> Maybe Int is not a function, [Bool] is not a function
16:10:39 <daey> i just tried to say that readFile returns a IO String
16:10:56 <EvanR> yeah
16:10:57 <ertes> daey: i'm not sure if you meant it that way, but you wording actually sounds right to me
16:10:58 <jle`> s/returns a/is a
16:11:06 <daey> but "variable <- IO String" becomes String in the variable
16:11:10 <ertes> daey: readFile is an (IO String)-returning function
16:11:22 <ertes> it takes a file path and returns an action
16:11:23 <EvanR> daey: yes, since its just sugar for >>=
16:11:27 <EvanR> :t (>>=)
16:11:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:11:34 <heebo> daey: it seems to me you have it clear in your head , but your notation is incorrect
16:11:43 <EvanR> m a going in, (a -> inside the callback
16:11:52 <daey> well the program works so i cant be that far off :D
16:11:52 <EvanR> no m
16:12:12 <Welkin> daey: avoid all of the sugar and write everything you would normally write in do-notation instead using explicit binds
16:12:19 <ertes> daey: note that the "()" does not mean: "call with no arguments"…  () is an actual type
16:12:21 <EvanR> "well the program works so i cant be that far off :D" famous last words :D
16:15:43 <heebo> does anyone find thinking deeply about programs makes everyday conversation seem puerile?
16:16:13 <heebo> i fear im becoming antisocial
16:16:31 <EvanR> they have alcohol for that
16:17:20 <ertes> heebo: you might be a high sensation seeker =)
16:17:45 <Swartz> heebo: yeah alcohol usally fixes that...or you just talk about those programs like a crazy person like i do
16:17:46 <ertes> don't worry, it's not a disorder, and i have that, too =)
16:18:04 <heebo> applyAlchohol  <$> Problem antiSocial 
16:18:43 <RouxTheDay> daey: Bit late here so you've probably already figured it out but this might be somewhat useful: http://lpaste.net/305172 . It's just showing what everyone was saying about (>>=)
16:19:01 <heebo> Swartz: unless theres no one to talk to about it , i guess thats why im on irc
16:19:02 <RouxTheDay> f and g are equivalent
16:19:22 <heebo> ertes: how do i fix that?
16:19:25 <RouxTheDay> g is the "desugared" version
16:19:32 <ertes> heebo: you embrace it
16:19:42 <daey> RouxTheDay: ty. i got that part running already
16:20:05 <RouxTheDay> daey: Ah okay, cool
16:20:11 <heebo> ertes: Alcohol it is then
16:20:19 <ertes> heebo: you can "fix" it by…  you know…  drinking alcohol, but i'm not overly fond of that strategy
16:20:39 <EvanR> its not a sure shot (... hmm stupid puns)
16:20:43 <Swartz> heebo: my only personal rules for drinking are if its beer, funnel it
16:21:26 <daey> Swartz: http://www.germanbeerinstitute.com/images/M%F6nchshof_Schwarzbier_1.gif :p
16:21:56 <EvanR> germanbeerinstitute.com.us
16:22:36 <byorgey> let's move discussion of alcohol to #haskell-blah, thanks
16:23:32 <Swartz> byorgey: sorry bro, sometimes beer just distracts me :D
16:23:47 <byorgey> or #haskell-offtopic or whatever the cool kids are using these days
16:24:03 <byorgey> Swartz: I like beer too, it's just not an appropriate topic for this channel =)
16:24:26 <Swartz> byorgey: noted bro
16:24:31 <EvanR> byo
16:24:53 <heebo> EvanR: bottoms up
16:38:54 <dannyboy> Hello, Haskell beginner here wanting to know where a good place to start learning Haskell is
16:39:21 <sbrg> ?where haskellbook
16:39:21 <lambdabot> http://haskellbook.com
16:39:26 <grantwu> https://github.com/bitemyapp/learnhaskell
16:39:45 <dannyboy> Thanks, I'll look these over
16:39:50 <sbrg> also #haskell-beginners
16:42:48 <shirt> mask $ \restore -> forkIO (restore (putStrLn "hi")) >> pure ()
16:43:03 <shirt> is the use of restore there permitted? what if it is called from the child thread after the parent thread has already terminated?
16:45:22 <Cale> shirt: I think it's legal, but weird and probably almost never what you want
16:45:40 <Cale> It restores the masking state of the new thread to that of the parent thread.
16:46:17 <Cale> But forkIO already does that for you
16:46:46 <Cale> er...
16:47:06 <Cale> Oh, right but that would mean that the exceptions were being masked, and the restore would restore them.
16:47:20 <shirt> yeah, that's my intention
16:47:27 <Cale> yeah, I think it should work fine
16:47:54 <shirt> the line of code i gave is my interpretation of this line from the docs: "Threads created by forkIO inherit the MaskingState from the parent; that is, to start a thread in the MaskedInterruptible state, use mask_ $ forkIO .... This is particularly useful if you need to establish an exception handler in the forked thread before any asynchronous exceptions are received."
16:53:23 <EvanR> shirt: you can also use forkFinally to do that
16:54:40 <shirt> EvanR: ah nice, was not aware of that!
16:58:33 <shirt> why does haskell have this complex async mask system anyway? why not just always be in the "mask" state so that exceptions are only thrown during the "interruptible" points? what can be so urgent to interrupt that cannot bear waiting a few extra cpu cycles?
16:59:19 <geekosaur> there's a thread somewhere on ghc-devs where this evolved in several stages and leaks were found in all the simpler ones
16:59:19 <EvanR> theres a nice paper about this, lookup concurrent haskell
17:00:01 <EvanR> async exceptions turns out to be surprisingly (?) complicated to do right, even java abandoned the idea
17:01:14 <Cale> They're also surprisingly hard to actually use, apart from the fact that giving up killThread would be sad, and if you're going to do killThread right, you might as well do async exceptions the same way.
17:01:48 <Cale> But if you have to maintain code which makes clever use of async exceptions, it's really annoying.
17:02:41 <EvanR> and you do effectively wait a few cycles
17:02:59 <EvanR> the system works fine with 1 thread
17:03:24 <EvanR> unless you use ffi
17:03:28 <shirt> i'm not saying to abandon them totally, just have everything always be in the "masked" state. async exceptions can still happen during all IO operations
17:03:51 <EvanR> then you cant interrupt threads doing long running computations
17:04:29 <EvanR> and whatever attempts to interrupt it is now blocked, and whatever is waiting on it
17:05:02 <EvanR> ctrl C might not work, etc
17:05:10 <shirt> my understanding is that mask only masks exceptions inside pure code (and inside of IO code that doesn't actually do any IO but always returns immediately like readIORef)
17:05:29 <Cale> EvanR: Well, I thought that too, but you could always just unmask that thread first thing if you intended to possibly kill it
17:05:52 <EvanR> if youre blocked on (normal) IO, youll get the async exception even while masked
17:06:01 <EvanR> Cale: which is not equal to "always be in the masked state"
17:06:08 <Cale> The question is whether we'd more often benefit from having the async exceptions masked.
17:06:11 <Cale> (by default)
17:06:23 <shirt> EvanR: right, which is excellent! the situation you mentioned with long running computation of pure code i think is a pretty rare thing
17:06:38 <Cale> You'd still have some way to change the masking state, just the default would be to mask
17:06:41 <EvanR> some code is IO centric and some is cpu centric
17:06:59 <shirt> async exceptions work really well for IO. like you said, in other languages like java it is a horrible mess
17:07:00 <EvanR> you usually expect to be able to cancel processes
17:07:08 <EvanR> unresponsive processes suck
17:07:24 <shirt> EvanR: in 99.9% of cases processes are unresponsive because they are blocked on IO, not CPU
17:07:30 <EvanR> not true
17:07:36 <EvanR> in my experience
17:07:53 <Cale> It's not like you're interactively applying killThread (at least unless you're in GHCi)
17:08:13 <Cale> If you use killThread, you might also want to use unmask then.
17:08:17 <EvanR> it seems like a lot of work to first go enable async exceptions to use them
17:08:25 <EvanR> in code, not a flag
17:08:42 <shirt> EvanR: long running computations will usually do periodic IO anyway
17:09:01 <EvanR> theyre not always blocked on IO
17:09:05 <Cale> Async exceptions *do* make it a whole lot harder to reason about the behaviour of concurrent code, so having them switched off by default might actually be a good idea.
17:09:33 <Cale> I think 99% of the time it wouldn't matter at all
17:09:36 <EvanR> the default is not even a very simple question
17:09:47 <EvanR> because what is the default for? all libraries you install?
17:10:07 <EvanR> libraries you installed after it became the default?
17:10:18 <EvanR> how does your code interactive with code that has a different default
17:10:21 <EvanR> interact
17:10:26 <Cale> It's a language level default -- when you start your program, what is the main thread's exception mask state?
17:10:28 <shirt> Cale: i think the helper functions in Control.Exception (bracket, etc..) make writing async safe code pretty straight forward
17:10:51 <Cale> shirt: They certainly help a bunch
17:10:55 <EvanR> Cale: the main thread, and then it infects all code it spawns? suddenly all assumptions in all libs are out the window?
17:11:00 <Cale> But it is possible to screw up
17:11:26 <Cale> EvanR: forkIO (already) copies the exception mask state of the parent thread
17:11:51 <EvanR> so youre saying, any code which is making choices about async exceptions already makes explicit non default choices
17:11:52 <Cale> Of course, changing this *now* would be potentially a nightmare
17:12:08 <EvanR> and any that doesnt doesnt really care what happens,
17:12:13 <Cale> Because you'd have to audit everything
17:12:45 <EvanR> so im not sure what defaults have to do with code that pretends async exceptions dont exist
17:12:49 <Cale> But if masked had been the default from the outset, it's possible that would be marginally better than what we have.
17:13:15 <EvanR> well System.Timeout would likely not work as well
17:13:19 <Cale> Because masking reflects the desires of code which pretends that async exceptions don't exist.
17:13:27 <EvanR> worse than it already does
17:13:45 <Cale> It could just unmask the exceptions on the thing it runs
17:13:58 <EvanR> Cale: sort of, still getting interrupted on blocked IO (non ffi)
17:14:13 <Cale> Sure...
17:14:25 <EvanR> and not non blocking IO
17:14:49 <EvanR> the difference im not sure most people know about most of the time
17:14:56 <EvanR> since its not really visible
17:15:47 <EvanR> whats a situation where default unmasked causes a problem ?
17:16:42 <Cale> Well, any situation where someone should have masked exceptions because they're making multiple changes to shared state which need to remain consistent, and failed to.
17:17:30 <EvanR> multiple changes to shared state without TVars ?
17:17:34 <Cale> It's hard to always be on guard for that, and consider "what if I get an exception right in between here?"
17:17:40 <Cale> yeah
17:17:49 <Cale> If it's all one STM transaction, you'll be okay
17:17:52 <EvanR> isnt that its own problem, since masked still doesnt save you
17:18:03 <Cale> It can save you...
17:18:20 <EvanR> less likely to mess up
17:18:53 <monochrom> masking saves you from getting aborted in the middle unfinished
17:18:57 <Cale> right
17:19:23 * hackagebot blazeT 0.0.1 - A true monad (transformer) version of the blaze-markup and blaze-html libraries  https://hackage.haskell.org/package/blazeT-0.0.1 (johannesgerer)
17:19:29 <monochrom> locking saves you from getting race conditions with another thread in the middle though you will finish
17:20:02 <EvanR> something makes me think you can never avoid possibly aborting
17:20:10 <EvanR> so you want TVars
17:20:13 <Cale> But... you kind of can?
17:20:36 <EvanR> eh?
17:21:11 <Cale> You can ask the thread which is throwing an exception at you to please wait until you're done, which is what masking does.
17:21:16 <monochrom> freaking out saves you from having to explain what you did wrong :)
17:21:48 <daey> but you should not overplay that joker :p
17:23:01 <shirt> in my function i'm writing, i need two short masks. i can't think of a way to do it without them (stm and locks won't work)
17:23:33 <EvanR> Cale: you can stop that async exception with masks, but i dont know about stopping any sort of abort whatsoever
17:23:53 <Cale> I guess I didn't know what you mean by "abort"
17:24:04 <shirt> but i've written lots of concurrent code and this is the first time i actually need mask. like i said, bracket and friends and STM go a long way
17:24:16 <EvanR> your A B C D (non transational task) never goes past B or C
17:24:49 <shirt> EvanR: are you talking about good old power failure?
17:25:04 <EvanR> maybe
17:25:10 <EvanR> thats one way
17:25:39 <shirt> EvanR: i actually am worried about StackOverflow exception. after some googling it's not clear how it interacts with mask
17:25:47 <EvanR> theres another
17:26:21 <monochrom> I prefer not to consider power off.
17:26:41 <EvanR> out of memory
17:26:58 <shirt> you mean OOM process killer?
17:26:59 <EvanR> C ends up taking a really long time
17:27:26 <EvanR> deadlock
17:27:45 <EvanR> bugs
17:27:57 <EvanR> not OOM process killer
17:29:24 * hackagebot hpio 0.8.0.4 - Monads for GPIO in Haskell  https://hackage.haskell.org/package/hpio-0.8.0.4 (dhess)
17:29:40 <monochrom> If I get OOM, I get aborted sure, but I do not leave my IORefs in an inconsistent state for the rest of the execution to observe.
17:30:06 <monochrom> There is no state left and there is no rest of the execution to observe anything.
17:30:14 <EvanR> IORefs, shared memory, file system semophores
17:30:53 <shirt> monochrom: what if you get StackOverflow exception in the middle of updating your IORefs? now they might be in an inconsistent state.
17:30:55 <EvanR> a non transational log file
17:31:18 <EvanR> basically anything non transactional has an issue if you assume nothing can abort
17:31:19 <shirt> monochrom: writing correct concurrent code with the possibility that StackOverflow might strike at any time seems like mission impossible to me
17:32:05 <shirt> monochrom: or are there strategies with dealing with StackOverflow?
17:32:08 <EvanR> i think its just a matter of identifying the correct universe to live in
17:32:31 <EvanR> if the universe is IORefs and abort means the entire universe aborts, then it seems transactional enough
17:32:44 <monochrom> you know what, StackOverflow is something within my control because I can design code to not cause it.
17:33:00 <EvanR> same answer to bugs and deadlock
17:33:08 <EvanR> but that also answers masking
17:33:26 <EvanR> "just dont mess up"
17:33:57 <monochrom> No, I cannot design code to be free of all bugs. It is not within my ability.
17:34:12 <monochrom> But I can design code to be free of stack overflow. It is within my ability.
17:34:35 <monochrom> Hell, I can also design code to be type correct. It is within GHC's ability to remind me.
17:34:37 <EvanR> the current default settings on stack size make that similar to OOM
17:35:08 <daey> how could i do the following ["asdf","asdf",...] = ["df","df",...] ?
17:35:24 <daey> s/=/=>
17:35:37 <shirt> daey: map (drop 2)
17:35:39 <Welkin> map (drop 2)
17:35:42 <daey> urg
17:35:45 <Koterpillar> > map (drop 2) (repeat "asdf")
17:35:48 <lambdabot>  ["df","df","df","df","df","df","df","df","df","df","df","df","df","df","df",...
17:35:50 <daey> i tried map drop 2
17:35:54 <monochrom> map (const "df")
17:35:54 <glguy> > "df" <$ (repeat "asdf")
17:35:57 <lambdabot>  ["df","df","df","df","df","df","df","df","df","df","df","df","df","df","df",...
17:36:05 <daey> i assumed that works, because map head works as well without ()
17:36:26 <monochrom> wrong analogy
17:36:53 <EvanR> > let ["asdf","asdf","..."] = ["df","df"...]
17:36:56 <lambdabot>  <no location info>: error:
17:36:56 <lambdabot>      not an expression: ‘let ["asdf","asdf","..."] = ["df","df"...]’
17:37:03 <EvanR> in undefined
17:37:34 <shirt> daey: (map (drop 2)) does currying, which is not needed with "head". you should read an intro about currying
17:38:27 <monochrom> "map drop 2" is parsed as "(map drop) 2" not "map (drop 2)"
17:49:25 * hackagebot blazeT 0.0.2 - A true monad (transformer) version of the blaze-markup and blaze-html libraries  https://hackage.haskell.org/package/blazeT-0.0.2 (johannesgerer)
18:31:23 <daey> cmbn :: [String] -> [Int] -> [(String,Int)] this is the correct annotation for takes a List of Strings and a List of Integer and returns a List of Lists containing a String and an Integer, right?
18:32:11 <monochrom> yes
18:32:39 <daey> ty
18:32:58 <Koterpillar> a list of lists?
18:33:02 <Koterpillar> or a list of tuples?
18:33:26 <daey> right tuples
18:33:32 <Koterpillar> daey: a list cannot* contain different things - Strings _and_ Ints
18:33:38 <daey> a list of lists would be [[]]?
18:33:51 <jle`> [[a]]
18:33:54 <Koterpillar> :t [[2, 3], [4, 5]] :: [[Int]]
18:33:57 <jle`> a list of lists of a
18:33:57 <lambdabot> [[Int]]
18:34:04 <Koterpillar> :t [[2, 3], [4, 5 :: Int]]
18:34:06 <lambdabot> [[Int]]
18:34:17 <jle`> :t ["hello","world"]
18:34:19 <lambdabot> [[Char]]
18:36:48 <daey> jle`: why is that [[Char]]?
18:37:00 <jle`> daey: strings are [Char]
18:37:04 <jle`> so a list of strings is [[Char]]
18:37:14 <EvanR> surprised it didnt say [String]
18:37:20 <Koterpillar> > ['c', 'h', 'a', 'r']
18:37:22 <lambdabot>  "char"
18:49:14 <Welkin> this is weird
18:49:19 <Welkin> "Too many lines in mime/multipart header"
18:49:32 <Welkin> error, called at ./Network/Wai/Parse.hs:463:17 in wai-extra-3.0.17-HIrhvsGSSQ0CtsGUsv4N41:Network.Wai.Parse
18:54:52 <daey> http://lpaste.net/305800 what am i doing wrong?
18:55:14 <Welkin> all the things
18:55:20 <daey> :(
18:55:30 <Welkin> I have been doing all the things wrong for days
18:56:14 <Welkin> what is your error?
18:56:16 <Welkin> the code doesn't look right
18:56:36 <Welkin> cmbn [] [] = []
18:56:38 <Welkin> not ()
18:56:45 <daey>  Couldn't match expected type ‘[(String, Int)]’ with actual type ‘()’
18:56:55 <Welkin> also
18:56:56 <daey>  Couldn't match expected type ‘Int’ with actual type ‘[Int]’
18:57:01 <Welkin> when you pattern match
18:57:04 <daey> they keep coming :p
18:57:15 <Welkin> cmbn (x:xs) (y:ys)
18:57:35 <Welkin> right now your are matching a list of lists with at least one element
18:57:51 <Welkin> : is the infix Cons constructor
18:58:02 <Welkin> data List a = Cons a (List a) | Nil
18:58:37 <daey> i thought : concates to the list 
18:58:54 <Koterpillar> > 1:[]
18:58:57 <lambdabot>  [1]
18:58:58 <Koterpillar> > 1:2:3:[]
18:59:00 <daey> i.e. recursive execute the function till nothing is left and attach the results to the output
18:59:01 <lambdabot>  [1,2,3]
18:59:01 <Koterpillar> daey: see this
18:59:28 <Koterpillar> daey: so your patters aren't right
18:59:39 <daey> i figured :p
18:59:48 <Koterpillar> daey: guess what this will print, and then check yourself: [1:[]]
19:00:09 <daey> [[1]]
19:00:14 <Koterpillar> > [1:[]]
19:00:16 <lambdabot>  [[1]]
19:00:26 <Koterpillar> that's your pattern with xs
19:00:31 <Koterpillar> what should it be instead?
19:01:41 <daey> we are talking about exclusively line 3?
19:01:50 <Koterpillar> yes (for now)
19:01:58 <Koterpillar> there's another error on line 2
19:02:06 <Koterpillar> but Welkin pointed it out already
19:02:46 <Koterpillar> actually, they also corrected your line 3, and I'm just trying to explain what does it mean
19:03:05 <Koterpillar> I trust that this is an assignment, and you know that this function exists :)
19:05:35 <daey> urg i used [] because its a list :/
19:05:59 <daey> so i assume i need to do the same for line 2? (even though it works with the line 2 as shown)
19:06:33 <hairy-potter> hello
19:06:39 <hairy-potter> quick question
19:06:47 <hairy-potter> i want to see the definitions
19:06:52 <hairy-potter> definotion
19:06:54 <hairy-potter> definition
19:06:58 <hairy-potter> of the last functor instance
19:07:04 <hairy-potter> how do i get the source
19:07:05 <hairy-potter> ?
19:07:06 <Koterpillar> daey: no, [] is fine
19:07:14 <Koterpillar> hairy-potter: which instance?
19:07:28 <dmj`> hairy-potter: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Monoid.html#line-200
19:07:35 <hairy-potter> Functor Last
19:07:54 <dmj`> hairy-potter: it's derived, you'll need --dump-*
19:08:13 <hairy-potter> --dump?
19:08:15 <hairy-potter> n00b here
19:08:45 <geekosaur> -ddump-deriv
19:09:42 <daey> what is the error in line2?
19:10:08 <Koterpillar> :t ()
19:10:10 <lambdabot> ()
19:10:10 <Koterpillar> :t []
19:10:14 <lambdabot> [t]
19:10:18 <Koterpillar> () is a tuple of zero elements
19:10:22 <dmj`> geekosaur: thanks
19:10:32 <roboguy`> hairy-potter: what do you mean by the last functor instance?
19:10:34 <daey> cmbn [] [] = ()?
19:10:47 <Koterpillar> daey: see above
19:11:11 <hairy-potter> roboguy`: ok never ind about that. I'm trying to grok some stuff around a funciton being a functor
19:11:41 <hairy-potter> so I was trying to compare to other functor instances
19:11:56 <hairy-potter> what's annoying me is the fmap for a functor function instance
19:12:11 <hairy-potter> instance Functor ((->) r) where       fmap f g = (\x -> f (g x)) 
19:12:14 <hairy-potter> the fmap
19:12:24 <hairy-potter> f and g look like functions
19:12:33 <hairy-potter> but where do they come from
19:12:40 <Koterpillar> :t fmap
19:12:41 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:12:44 <hairy-potter> what do they bind to
19:12:46 <hairy-potter> ok
19:12:57 <hairy-potter> so g is (a->b)
19:13:01 <Koterpillar> no, that's f
19:13:08 <Koterpillar> f :: (a -> b)
19:13:20 <Koterpillar> g :: f a, i.e. g :: a -> r
19:13:23 <hairy-potter> sorry yeah
19:13:27 <Koterpillar> err, r -> a
19:13:30 <Koterpillar> which one?
19:13:33 <hairy-potter> errrrr
19:13:42 <Koterpillar> r -> a
19:13:50 <Koterpillar> so g :: r -> a
19:13:58 <Koterpillar> which is the function being a functor
19:14:05 <hairy-potter> so we want to go r->b via r->a,a->b
19:14:23 <Koterpillar> yes, in fact, that's the only way
19:14:49 <hairy-potter> so f is a->b, right?
19:15:04 <Koterpillar> yes
19:15:23 <hairy-potter> is there a way i can d function composition using fmap?
19:15:37 <hairy-potter> explicitly
19:15:42 <roboguy`> hairy-potter: fmap is function composition
19:15:52 <roboguy`> (fmap on functions anyway)
19:16:19 <hairy-potter> roboguy`, I mean rathe than writing f(g x), can I write fmap f g x
19:16:52 <jonnymac> "fmap f g" is the same as "f . g"
19:17:09 <glguy> hairy-potter: Yes, you can write: fmap f g x
19:17:37 <roboguy`> > fmap (+1) (*2) 5
19:17:39 <lambdabot>  11
19:18:33 <hairy-potter> let me try...
19:20:00 <Welkin> wtf...
19:20:12 <Welkin> my files are getting corrupted when I upload them to my server now
19:20:25 <grantwu> That is fun
19:20:31 <Clint> sounds like you should stop doing that
19:20:41 <Welkin> I am uploading them as multipart/form-data
19:20:46 <Welkin> the post request looks fine
19:21:02 <Welkin> I was getting an error from wai about the header being too long
19:21:06 <Welkin> so I removed the length limit
19:21:16 <Welkin> now it uploads but they are screwed up
19:21:24 <EvanR> nothing better than using crap web technology, except re(verse)engineering crap web technology
19:21:27 <Welkin> this wasn't happening before
19:22:01 <hairy-potter> roboguy`: how do I declare functions in the repl?
19:22:31 <geekosaur> let f x = ...
19:22:37 <Welkin> weird...
19:22:42 <Welkin> it works for some files
19:22:43 <geekosaur> or: let f :: typesig here; f x = ...
19:22:44 <Welkin> not for others
19:22:47 <hairy-potter> thanks
19:22:47 <Welkin> something is wrong though
19:22:52 <kadoban> hairy-potter: Note that you usually shouldn't, they go better in files that you then load in
19:22:56 <hairy-potter> needed to bind with a let
19:23:02 <Welkin> has anyone worked with Network.Wai.Parse and multipart/form-data?
19:28:57 <Welkin> does it have something to do with storing the file in memory before writing to disk?
19:29:10 <Welkin> that's the only thing I can think of maybe
19:56:40 <hairy-potter> roboguy`: thanks for the help. If someone wanted, can they define teh functor instance (-> r) fmap as 
19:56:46 <hairy-potter> fmap f g h j x
19:58:08 <dmj`> can you change the executable name based on the compiler in use
19:58:10 <byorgey> hairy-potter: what does  fmap f g h j x  mean?
19:58:14 <dmj`> in cabale
19:58:15 <dmj`> cabal**
19:58:22 <byorgey> hairy-potter: that does not look like a definition.  A definition should have an = sign somewhere.
19:59:28 <hairy-potter>  fmap f g h j = (\x -> f (g (h (j x))))  
20:00:37 <hairy-potter> roboguy`: would something like that be a legal defintion of fmap for functor function?
20:00:54 <byorgey> hairy-potter: no, that would not type check.  for this instance, fmap must have the type  (a -> b) -> (r -> a) -> r -> b.  That means you can define it with at most 3 arguments: one of type (a -> b), one of type (r -> a), and one of type r
20:01:13 <byorgey> hairy-potter: if you give it more arguments that means the type b has to be a function, but the definition is supposed to work for *any* type b
20:01:34 <Welkin> dmj`: ever worked with file uploads before?
20:02:08 <glguy> dmj`: only way that comes to mind is to duplicate the executable section changing one of the names
20:02:15 <hairy-potter> byorgey: ahh yes you're completely right. Would this be legal  fmap f g = (\x y z-> f (g x y z))  
20:02:32 <glguy> and then making each buildable based on the compiler
20:02:56 <byorgey> hairy-potter: no, for a similar reason.  fmap f g  has to give a result of type   r -> b,  but  (\x y z -> ...) is going to have a type like   r -> s -> t -> ...
20:04:27 <byorgey> hairy-potter: fmap f g = \x -> f (g x)  is essentially the *only possible* way to implement it.  The types don't let you do anything else.  You can also write it like  fmap f g x = f (g x)  but that is really the same thing.
20:06:26 <hairy-potter> byorgey: x is a value here, correct? not a function?
20:08:08 <geekosaur> that depends on g
20:08:42 <roboguy`> hairy-potter: functions are values. it is a value and it *could* be a function (it doesn't have to be though)
20:13:13 <hairy-potter> byorgey: so if x could be a value, then why can't we have something like fmap f g x y = f (g (add x y)).... is it because it's type signature would be something like p->p->p -> (r->a) ->(a->b)->(r->b)
20:13:14 <hairy-potter> ?
20:13:38 <hairy-potter> asumming here x y and add x y produce the same type
20:13:44 <geekosaur> because fmap is not allowed to *assume* that it is always a function
20:13:56 <geekosaur> it *could* be. it does not *have* to be, and you are not allowed to require it
20:15:09 <hairy-potter> geekosaur: what is fmap not assuming? 
20:15:38 <geekosaur> ...
20:15:50 <geekosaur> I am wondering if you understand any of what you have been told
20:15:59 <geekosaur> you have proposed an fmap that assumes that it will be given a function
20:17:26 <hairy-potter> geekosaur, I know fmap is given 2 functions f and g. sorry I'm confused as to which function i'm assuming it's being given
20:17:29 <geekosaur> you cannot do that, except when fmap is being defined on functions itself, which is a different thing
20:18:24 <geekosaur> [27 03:12:51] <hairy-potter> ... so if x could be a value, then why can't we have something like fmap f g x y = f (g (add x y))
20:18:35 <geekosaur> this requires that (f g x) be a function
20:18:44 <geekosaur> or at least assumes that it will always produce one
20:18:48 <dfeuer> That's kind of weird ... The P type used to define ReadP has a weird/complicated Final constructor that seems designed solely to support the readS_to_P function.
20:18:51 <geekosaur> fmap's contract does not permit that assumption
20:19:15 <geekosaur> fmap's contract is: fmap :: Functor f => (a -> b) -> f a -> f b
20:19:20 <dfeuer> In fact, I don't think it can do anything else.
20:19:58 <geekosaur> for a given f, you can write an implementation that knows what f is. it cannot know what a and b are, it cannot dictate their shapes (e.g. that one or both is a function)
20:20:41 <geekosaur> the only thing that knows what a and b are is the function parameter (a -> b)
20:21:17 <hairy-potter> geekosaur: i didn't think of it like that. It's clearer now, thanks alot
20:22:06 <dfeuer> I guess the other constructors aren't sufficient to simulate that, because there's no way to know how much of the string the ReadS consumed for each result.
20:22:20 <dfeuer> But why does the interface include that particular conversion at all?
20:26:18 <nate`> >
20:26:56 <hairy-potter> geekosaur: Thank you for explaining in detail. It is alot clearer now why I can't arbitrairly change fmap's signature. Thanks again 
20:26:59 <dfeuer> I guess that could be replaced by a constructor SetState :: String -> P a -> P a, replacing the parser state with the given one. I *think* that would be simpler to implement, but there could be some efficiency cost.
20:27:12 <geekosaur> would anyone notice?
20:27:34 <geekosaur> I mean, it's not like it's the most efficient mechanism to begin with...
20:29:08 <dfeuer> geekosaur, I dunno. I also haven't tried it, so I can't absolutely guarantee that I can get the right semantics. But this Final thing just feels strange in context.
20:48:49 <jchia> I'm using fmap on a partial function to produce a top-level list. I know that the values in the input list are all accepted by the partial function. How do i change the code to avoid ghc warning about partial functions and undefined output? Ideally, i want a compiler error if indeed my input is not accepted by the partial function.
20:49:50 <pavonia> Add an alternative _ -> error "..."
20:50:46 <kadoban> jchia: Do yourself a favor and have the error message to unique enough that you can tell where it came from too, at least so you can search for it.
20:51:09 <kadoban> be unique enough*
20:51:45 <jchia> OK, using error made the ghc warnings go away. Is there a way to force a compilation error instead of a runtime error?
20:51:56 <jchia> in case i have an input that's not accepted by the partial function
20:52:04 <tom7942> warnings as errors?
20:52:24 <kadoban> jchia: I assume you mean the list itself is provided at compile time?
20:52:26 <jchia> i'm fmapping a list of constant values with a partial function
20:52:38 <jchia> yes
20:52:41 <jchia> the values are fixed
20:52:44 <kadoban> I would imagine there's some TH you could do, but I'm not sure.
20:52:47 <jchia> so in principle ghc should be able to tell
20:52:53 <jchia> OK. thanks
20:58:20 <lgstate> "It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures." -- Alan Perlis -- is this quote basically anti-types ?
20:58:55 <lgstate> There's also: "Functions delay binding; data structures induce binding. Moral: Structure data late in the programming process."
20:59:06 <lgstate> which seems to suggest avoiding making data type delcaarations
21:03:09 <grafme> I wanted to use a graph in haskell and seem to be running into some issues. I'm aware that 'tying the knot' is one way to use laziness to get to a graph but the tradeoff seems to be that it can't be modified afterwards. fgl docs say efficiency isn't their top goal. Data.graph also doesn't seem to amenable to quickly change an existing graph. Are there other options?
21:06:59 <kadoban> grafme: I've just done some nonsense with a Data.Map of edges, and other basic constructions, before. You miss out on having some library functions already defined for you though. Or just implicit graphs not really represented by anything.
21:09:14 <grafme> Thank you for replying. The data.map approach was calling out to me as well. It seems like the data.map approach (or similar wheel reinvention) and fgl (which straight up says on page 2 that efficiency isn't of interest) are the only game in town. I really like haskell and i realize that 'rolling my own' isn't the end of the world but it took the wind out of my sails a bit to see that. 
21:10:03 <kadoban> I don't do a lot of graphy stuff, so it's completely possible there's a really nice thing out there. It may depend exactly what your graph is for.
21:11:31 <grafme> It's for a component of an optimization problem. Certainly won't find anything off the shelf for my exact problem but thought I could lean on existing libs a bit.
21:12:05 <grafme> I wanted to mock it up in haskell to get a feel and then probably drop down to C++ after feeling it out
21:29:52 <EvanR> grafme: HashMap Int (HashSet Int) maybe
21:30:29 <EvanR> if its not a lot of links, HashMap Int [Int]
21:38:40 <EvanR> is there a Sequence like data structure which only goes one direction like a list, but is faster than list (and Sequence to make this question non trivial)
21:42:00 <MarcelineVQ> faster for?
21:42:51 <EvanR> uh
21:43:11 <EvanR> push pop, insert, delete, index, take, drop
21:49:12 <kadoban> BST with some augmenting maybe, like size of each subtree?
21:50:00 <dmj`> EvanR: vector
21:51:01 <EvanR> huh really?
21:51:06 <kadoban> "insert" is pretty bad with a vector, and delete
21:51:14 <EvanR> so is push and pop
21:51:20 <EvanR> well not pop
21:51:33 <dmj`> it's bad with a list too
21:52:02 <EvanR> i think insert and delete at index is probably the most critical 
21:52:23 <EvanR> or update at index
21:52:44 <EvanR> guess were back to HashMap
21:52:51 <kadoban> The BST thing is sounding better and better then
21:52:53 <dmj`> yea, that sounds like a tree
21:52:58 <kadoban> HashMap? Hmm.
21:53:35 <dmj`> kadoban: balanced right?
21:53:49 <kadoban> Right
21:54:40 <EvanR> HashMap Int apparently has some serious optimizations which beat the pants off our trees, except for min/max and splitting
21:55:00 <dmj`> IntMap ?
21:55:06 <EvanR> even IntMap
21:55:18 <dmj`> I like IntMap
21:55:19 <EvanR> like, IntMap is limited to 64 levels
21:55:25 <EvanR> but HashMap is limited to 16
21:55:47 <EvanR> actually im probably wrong about IntMap
21:56:12 <EvanR> i need to find some benchmarks
21:56:16 <kadoban> EvanR: Oh do you mean like, insertion/deletion by key? I didn't think something like a HashMap would be ordered either, so I'm not sure about indexing?
21:56:23 <MarcelineVQ> Not that I know much about it but it sounds like you want a finger tree given the number of operations you seem to want to optimize
21:56:32 <EvanR> if Int is the key
21:56:39 <MarcelineVQ> Sequence happens to already be one, but you might want something more specific to your use?
21:56:46 <EvanR> its an "array"
21:57:12 <EvanR> nah i was just wondering if Sequence was two sided on purpose or accidentally ;)
21:57:18 <EvanR> and if giving up one side would help somehow
21:57:24 <dmj`> EvanR: google the 'hashtables' package, it has benchmarks
21:57:56 <kadoban> EvanR: I'm not sure how you index/take/drop on a HashMap.
21:58:00 <EvanR> is hashtables the one everyone was super disappointed about
21:58:14 <EvanR> true, take drop wouldnt wokr
21:58:21 <EvanR> i just threw out a bunch of operations
22:00:10 <dmj`> EvanR: have a simple hashtable implementation, uses boxed mutable vectors and chaining to handle collisions
22:00:24 <sweater> Dear all, I wonder if there is some typeclass that has the following signature `class ??? (f :: * -> *) where | fappend :: a -> f a -> f a`?
22:00:37 <EvanR> dmj`: and the one in that blog with HashMap on it is from the old HashMap package
22:00:47 <EvanR> i am surmising from the year
22:00:49 <EvanR> 2011
22:01:01 <dmj`> ah yea, I remember the new release of HashMap
22:01:24 <EvanR> sweater: so like, "conj"
22:01:36 <sweater> In particular, I need `fappend :: (Foldable f) => a -> f a -> f a` which, for now, I think I'll be implementing for each data type used in the application
22:01:48 <EvanR> i was about to say, what are the laws
22:04:32 <nshepperd> sweater: Alternative does that, sort of
22:04:37 * hackagebot diagrams-core 1.4 - Core libraries for diagrams EDSL  https://hackage.haskell.org/package/diagrams-core-1.4 (BrentYorgey)
22:04:42 <sweater> EvanR: it's hard to formalize laws for this, so I think it doesn't make sense to have a typeclass with this function. But in my application we need to accumulate a`s.
22:05:10 <EvanR> dmj`: those graphs are interesting since they are logarithmic in the size, until he turns on some random flags there i dont recognize and it becomes eventually constant time o_O
22:05:11 <nshepperd> (\x xs -> pure x <|> xs) = fappend for ordinary sequence/list types
22:05:19 <EvanR> even for data.map
22:05:42 <sweater> nshepperd: I was thinking about alternative and lifting first argument
22:05:48 <saulzar> Hmmm. I have a function   'elim :: forall c xs a. (Every c xs) => (forall x. (c x) => x -> a) -> Sum xs -> a'     - however, I get an error about ambiguous type variable c0  (so the c's are not the same apparently). ScopedTypeVariables is on - anyone have a clue what that's about?
22:06:01 <sweater> yeah
22:06:26 <nshepperd> also works for types like Maybe and IO though, where it does something rather different
22:07:03 <EvanR> "Alternative as conj" O_o
22:07:16 <EvanR> thats a new one
22:07:44 <sweater> Well, my `f` is already a Functor and a Monoid, I'll see how painful it will be to make it Alternative.
22:07:58 <sweater> Wait, that's not the same `f`.
22:08:09 <sweater> Anyway, thanks. 
22:08:41 <EvanR> sweater: in the spirit of clojure, where a -> f a -> f a works for the 4 data structures it comes with, and nothing follows any laws whatsoever, you should at least name it conj ;)
22:09:37 * hackagebot diagrams-lib 1.4 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.4 (BrentYorgey)
22:09:38 <sweater> EvanR: hehe, I will :)
22:09:39 * hackagebot diagrams-contrib 1.4 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.4 (BrentYorgey)
22:09:55 <sweater> But hey, they have transducers
22:10:40 <shanemikel> it's so painful watching whats-his-name trying to explain those damn things
22:11:36 <EvanR> heh
22:12:39 <shanemikel> an hour of conveyer belts and luggage metaphors...
22:13:49 <EvanR> if transducers are reducer transformers, then at least the name now makes sense
22:14:03 <EvanR> i wonder if anyone ever explains them like that
22:14:04 <nshepperd> you can even write a law describing the subset of sequence-like alternative types: 'class (Foldable f, Alternative f) => Sequence f where { injection :: (\x -> fold (pure x) = x), iso :: (\k xs ys -> foldMap k xs <|> foldMap k ys = foldMap k (xs <|> ys)) }
22:14:17 <nshepperd> pretending we have dependent types :<
22:14:38 * hackagebot diagrams-cairo 1.4 - Cairo backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-cairo-1.4 (BrentYorgey)
22:14:40 * hackagebot diagrams-gtk 1.4 - Backend for rendering diagrams directly to GTK windows  https://hackage.haskell.org/package/diagrams-gtk-1.4 (BrentYorgey)
22:14:42 * hackagebot diagrams-postscript 1.4 - Postscript backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-postscript-1.4 (BrentYorgey)
22:14:44 * hackagebot diagrams-pgf 1.4 - PGF backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-pgf-1.4 (BrentYorgey)
22:15:05 <nshepperd> oh, that first <|> should be <>
22:16:11 <sweater> nshepperd: I think I'll go down this route, yes. Already started to stare at `(Foldable f, Alternative f) =>` and think :)
22:16:18 <shanemikel> I'm gonna go ahead and pretend I can build ghc, and run your pretend code on it...  I'll send you my results telepathically
22:16:33 <dmj`> proposal: Control.Concurrent.SkipChan
22:17:02 <dmj`> how can Control.Concurrent.MVar talk about it, but then not have it included
22:17:13 <nshepperd> in real haskell you would write '(Foldable f, Alternative f) => Sequence f where {}' and just treat Sequence as a promise that those laws hold
22:19:14 <Squarism> anyone know a cheap deal for hosting a small app with minimal traffic, disk usage, mem usage?
22:19:38 * hackagebot diagrams-rasterific 1.4 - Rasterific backend for diagrams.  https://hackage.haskell.org/package/diagrams-rasterific-1.4 (BrentYorgey)
22:20:22 <dmj`> Squarism: https://www.digitalocean.com/
22:21:19 <Squarism> that was cheap!
22:21:32 <Squarism> dmj`, does it have quality too?
22:21:48 <dmj`> Squarism: let's talk in #haskell-offtopic
22:22:32 <shanemikel> digitalocean is pretty cheap, but use a cdn if you have static content.  I've had latency problems with their servers
22:24:38 * hackagebot diagrams-svg 1.4.1 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.4.1 (BrentYorgey)
22:24:40 * hackagebot diagrams-canvas 1.4 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-canvas-1.4 (BrentYorgey)
22:24:42 * hackagebot diagrams-html5 1.4 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-html5-1.4 (BrentYorgey)
22:28:10 <sss> hello?
22:29:30 <nshepperd> ack
22:29:36 <shanemikel> HELLO, HELLo, HELlo, HEllo, Hello, hello......
22:29:38 * hackagebot diagrams-builder 0.8 - hint-based build service for the diagrams graphics EDSL.  https://hackage.haskell.org/package/diagrams-builder-0.8 (BrentYorgey)
22:29:42 * hackagebot diagrams-haddock 0.4 - Preprocessor for embedding diagrams in Haddock documentation  https://hackage.haskell.org/package/diagrams-haddock-0.4 (BrentYorgey)
22:29:42 * hackagebot diagrams 1.4 - Embedded domain-specific language for declarative vector graphics  https://hackage.haskell.org/package/diagrams-1.4 (BrentYorgey)
22:39:59 <suppi> Squarism: i host gilmi.xyz on budgetvm.com
22:40:36 <Koterpillar> suppi: it expired
22:41:11 <suppi> Koterpillar: what expired?
22:41:40 <Koterpillar> oh, sorry, I mistyled gimli.xyz. Your domain is fine :)
22:42:06 <suppi> yeah a lot of people do that :( no worries
22:42:55 <EvanR> i read it as gimli
22:43:15 <suppi> everyone does apparently 
22:44:02 <suppi> maybe i should buy that as well :p
22:44:39 * hackagebot SVGFonts 1.6.0.1 - Fonts from the SVG-Font format  https://hackage.haskell.org/package/SVGFonts-1.6.0.1 (BrentYorgey)
