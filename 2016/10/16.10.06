00:00:04 <mgsloan> hvr: How would we make it automatic, btw?  One thought I've had would be to analyze .ddump-hi files
00:00:05 <hvr> piyush-kurur: at best we can automatically see in *some* cases that it's *not* compatible
00:00:32 <mgsloan> I think everyone would appreciate a tool that alerted them of specific semantic versioning issues
00:00:34 <hvr> mgsloan: first you'd have to find a way to figure out how to decide whether a function changed its semantics
00:00:48 <mgsloan> Eh, API breakage is far more common
00:00:56 <hvr> mgsloan: detecting merely type-level chagnes is easy
00:01:01 <mgsloan> If they change the semantics, then yes, that version bump is managed in the dev's head
00:01:07 <mgsloan> If it is easy then why don't we do it?
00:01:16 <mgsloan> Where is the tool! I'd love to have this tool
00:01:16 <hvr> because I care more about the semantic aspect
00:01:16 <begriffs> For building my various projects I always use Stack because I can avoid rebuilding dependencies I've already built. However in continuous integration I add a check that cabal-install is able to also build my project just to hopefully ensure that the dependencies are well specified. I run "cabal install --only-d --dry-run"
00:01:23 <hvr> mgsloan: that's the real unsovled issue
00:01:42 <mgsloan> Right, we are considering building this into stack, because we already generate .ddump-hi
00:02:16 <EvanR> karma is immutable on average
00:02:30 <hvr> as a first crude approx, it'd be interesting to assign some kind of function-body hash to a name
00:02:44 <hvr> then we'd be able to detect impl changes
00:03:08 <mgsloan> That would be nice, .ddump-hi files already come with a hash per top level thing, but I don't know the semantics of that hash
00:03:14 <piyush-kurur> hvr: yes that is what I meant. Not a completely fools proof method but something which for example makes sure that the types match
00:03:20 <hvr> or we could have a pragma for assigning version numbers to functions, which the dev has to increment each time he does a significant semantic change
00:03:31 <mgsloan> Yes, I really think APIs are the bigger deal for semantic versioning
00:03:45 <mgsloan> Semantics is interesting, but it is not solvable in general, so why try?
00:04:07 <hvr> mgsloan: there's lots of such things that is not solvable in general, and yet we try with Haskell ;)
00:04:11 <mgsloan> Having something that shows you what changed is good, but that is already achievable with hdiff
00:04:26 <piyush-kurur> now an insidious package might violate the semantics without changing the types but I think most practical situations should be caught as such
00:04:35 <mgsloan> hvr: We have a different approach to trying things with haskell.  We shoot for pragmatic solutions that work well
00:04:54 <mgsloan> Because Haskell's success is not worth risking on going down research paths without a light 
00:05:11 <hvr> mgsloan: hdiff presents the information rather undstructured though; i.e. you get a low-level diff; I'm rather interested in a API-differ level visualtions
00:05:24 <mgsloan> It's true!
00:05:31 <hvr> so think of 'check-pvp'
00:05:43 <hvr> which gives you also the hint, that the impl of function foo has changed,
00:05:49 <hvr> which may affect how bar and doo behave
00:05:51 <piyush-kurur> mgsloan: yes Haskell has become too important now but we also need flexibility to try new things
00:05:56 <Cale> "Because Haskell's success is not worth risking on going down research paths without a light" jeez
00:05:58 <mgsloan> True!  I have an old hacky project to do this, actually.  Check out some examples https://github.com/mgsloan/api-compat/tree/master/examples
00:06:24 <mgsloan> Cale: I know that we disagree on this point, because of your reddit comment.  That is ok, I understand your perspective and I respect it
00:06:25 <Cale> I dunno, I find it painful to see things like that.
00:06:31 <Cale> yeah
00:06:38 <mgsloan> I find it painful to see your views on this as well, we differ here
00:06:56 <hvr> ok, let's agree we cause each other pain ;-)
00:06:57 <mgsloan> Because I know you are a very well respected member of the community, people will look up to you, and believe what you say
00:07:15 <mgsloan> But we can't be right about everything!  Neither can I certainly
00:07:38 <mgsloan> Look, Haskell came out of research.  We all love research here
00:07:47 <hvr> mgsloan: ...and more importantly, it's not black and white; it's not that one party is right and the other is then wrong
00:07:49 <Cale> If you don't go down research paths, you don't end up with anything better ever. All the things which suck just continue doing so.
00:08:13 <mgsloan> But we can't risk community infrastructure that systemically effects the success, on research projects / experiments
00:08:30 <piyush-kurur> mgsloan and hvr: both of you are right or if you want it that way both of you are insanely wrong (choose which ever pleases you)
00:08:56 <ReinH> Why would research projects put community structure at risk?
00:09:05 <ReinH> That just sounds like an incredibly poorly designed research project.
00:09:15 <ReinH> s/structure/infrastructure
00:09:25 <hvr> mgsloan: it's not like 'semantic versioning' is a bleeding edge idea; it's something that's actually getting more traction in other ecosystems
00:09:39 <mgsloan> Sure, but most research projects in academia have crappy codebases (truly not trying to say something indirectly there)
00:10:01 <ReinH> Most research projects stay research projects.
00:10:05 <mgsloan> What I mean is that if research is the goal, then write a paper about it, do the experiment
00:10:15 <piyush-kurur> hvr: I would like sematic versioning. what are the things that I can do now so that I get as much benifit
00:10:20 <mgsloan> But if you foist the research project on people without validation, that is where the problem is
00:10:26 <hvr> mgsloan: of course it has its tradeoffs and issues, but it's more desirable to the alternative and that's why ecosystems are adopting it
00:10:31 <ReinH> Who is suggesting any foisting?
00:10:38 <Cale> Nobody's forcing anyone to use anything.
00:10:58 <mgsloan> hvr says he wants everyone to use pvp constraints on all packages
00:11:12 <ReinH> And that's a research project?
00:11:23 <mgsloan> To me it is, but perhaps that is a bold position
00:11:26 <ReinH> semantic versioning is widely used
00:11:27 <hvr> if it was, I could write papers!
00:11:38 <mgsloan> Hahah, you probably could :)
00:11:42 <piyush-kurur> mgsloan: I would like to do this (use pvp) as much as possible for 
00:11:52 <ReinH> I've had more problems from failures to follow pvp than the converse
00:12:02 <hvr> mgsloan: actually, these guys here http://breakingapis.org/ do something related to writing papers about semver et al
00:12:16 <hvr> but in a more general context
00:12:23 <mgsloan> ReinH: Sure, but that is because the PVP is so hard to follow.  My position is that the onus of picking version bounds shouldn't be on the package maintainer
00:12:55 <ReinH> I'd like PVP to be better, but I'd be hard pressed to believe that some agreed upon versioning convention is worse than none.
00:13:02 <piyush-kurur> mgsloan: but a developer should be aware on what packages he is depending on
00:13:24 <mgsloan> piyush-kurur: Yes, but upper bounds are pessimistic!  They mean I can't build against future versions, even if that would work just fine
00:13:41 <hvr> ReinH, piyush-kurur, Cale: btw, if you have any feedback on http://pvp.haskell.org/faq/ ... I'd be interested to hear
00:13:44 <mgsloan> Picking wide lower bounds means exploring API docs, or sampling the space using my build tool
00:13:55 <mgsloan> It is just too much work to have wide bounds.
00:14:07 <ReinH> mgsloan: When I was in charge of buiding a bunch of Haskell package for work, we had lots of arguments about upper bounds, believe me
00:14:09 <mgsloan> So the response is "well then have tight bounds".  Now I can't get build plans at all
00:14:30 <piyush-kurur> mgsloan: yes upperbounds is a bit of a problem.
00:14:30 <mgsloan> The point is, we have all these arguments and discussions because the premise is broken, IMHO
00:14:46 <hvr> mgsloan: what exactly is the premise?
00:14:49 <piyush-kurur> mgsloan: but I think it has also got to do with how complicated the package is
00:15:14 <ReinH> And for this reason you think we should throw out the rest of PVP?
00:15:23 <piyush-kurur> if it depends on some of the basic packages like base and bytestring etc usually the upper bounds are pretty good
00:15:25 <ReinH> Because upper bounds are tough?
00:15:33 <ReinH> That sounds like a bath water mistake to me.
00:15:44 <mgsloan> hvr: I should have spoken more carefully, what I really mean is there is an assumption that "version bounds declared in package metadata" is a good idea
00:16:03 <mgsloan> I'd prefer something more like a global DB of build and test results, like build-matrix 
00:16:16 <ReinH> Ok, but that's not free.
00:16:19 <mgsloan> And from this global DB, we now have actual data to back up our version bounds
00:16:29 <ReinH> And that labour can't be amortized
00:16:35 <hvr> mgsloan: well, but you run into quite some combinatorial explosion then
00:16:45 <mgsloan> Sure, but it sure beats the manual labor!
00:16:45 <hvr> mgsloan: if all bounds are to be inferred merely by buildbotting
00:16:49 <ReinH> someone has to run and pay for a build matrix
00:16:56 <ReinH> It is manual labor.
00:16:57 <taktoa> https://hydra.nixos.org :)
00:17:00 <mgsloan> hvr: Fine, so we sample the space of configurations.  Still better than me guessing bounds by hands
00:17:14 <hvr> mgsloan: what do you mean by sample?
00:17:38 <Cale> I don't dislike the PVP, but I do find it mildly infuriating that we seem to need upper bounds at a time before the veracity of those upper bounds can really be determined.
00:17:43 <ReinH> If PVP is followed then upper bounds on major versions should be reasonable
00:17:44 <mgsloan> Like skip the minor versions, trust that semantic versioning was followed.  Try every other major version.  I'm sure we can find heuristics, but that is another research problem
00:18:05 <mgsloan> I don't get why we have automated dependency solving but not automated dependency determination
00:18:16 <mgsloan> To me it is automating 1/2 the problem, and that is where the pain is coming from
00:18:19 <ReinH> Because one is much easier than the other
00:18:22 <hvr> mgsloan: ok, but then you're assuming that we take the PVP spec serious
00:18:34 <hvr> mgsloan: as otherwise you can't rely on that structure to exist
00:18:49 <piyush-kurur> hvr: just to repeat the question. currently what is the best solution to get some kind of a check on (1) breaking pvp (2) introducing some unfounded assumption of package versions. Even if the solution is only half good, I would like to use it
00:18:49 <ReinH> mgsloan: How do you suggest we automate dependency determination without a meaning function for version numbers?
00:18:52 <ReinH> i.e., semantic versioning??
00:19:05 <ReinH> By building every point in the space?
00:19:11 <mgsloan> hvr: Here is how I propose that stack solve the PVP problem, and is an example of sampling the space https://github.com/commercialhaskell/stack/issues/2262
00:19:15 <mgsloan> ReinH: ^^^
00:19:34 <hvr> mgsloan: and in order for the declared package version to be PVP-conforming, you have to have to rely on that package to ensure the version number declared is accurate, right?
00:19:38 <mgsloan> Err this is a better link: https://github.com/commercialhaskell/stack/issues/1568
00:19:58 <mgsloan> hvr: Fine yes, we can agree to the discipline, sure!
00:20:19 <mgsloan> We can presuppose that everyone contributing to hackage has gotten smacked in the head with the PVP a few times ;)
00:20:24 <hvr> mgsloan: yeah, that's a fair suggestion, but it samples are super tiny space of the config space, and you end up with lots of dark corners
00:20:39 <mgsloan> Yes, dark corners is why I disagree with version bounds at all
00:20:45 <hvr> mgsloan: that suggestion was fine, if we we limited ourselves to only stackage crosscuts through hackage
00:20:49 <mgsloan> Instead, we need version configurations to be separate from the build metadata
00:20:56 <ReinH> So the suggestion is to make versions less meaningful?
00:21:02 <ReinH> How does that improve the problem?
00:21:20 <mgsloan> hvr: You realize that stack.yaml can act just like a freeze file, right?  Better than a freeze file, I think, because it handles ghc-options and flags
00:21:39 <hvr> mgsloan: recent cabal versions pin down flags too
00:21:56 <hvr> mgsloan: and you can also store extra ghc-options in cabal.project files if you want
00:21:58 <mgsloan> ReinH: I do not understand your questions.  I am not advocating making versions less meaningful.
00:22:10 <ReinH> mgsloan: I understood that you were advocating that people not follow PVP
00:22:12 <hvr> mgsloan: and even more recent versions will also freeze the index while at it
00:22:12 <mgsloan> I am advocating that PVP is broken, semantic versioning is not
00:22:20 <ReinH> Ok
00:22:30 <ReinH> Particular parts of PVP, then
00:22:34 <hvr> mgsloan: but PVP *is* semantic versioning
00:22:44 <ReinH> Because the rest of PVP is about semantic versioning
00:22:44 <mgsloan> Semantic versioning is a subset of the PVP
00:22:59 <ReinH> Yes, and you didn't make it clear (to me) that you agreed with any subset of PVP
00:23:21 <mgsloan> I am not anti PVP, I don't know why that came through in this exchange
00:23:27 <hvr> mgsloan: ok, which part of the PVP is not contained in semver?
00:23:38 <mgsloan> The part where you put version bounds on your dependencies
00:23:38 <Cale> Modest solution: Replace package versions with complete mathematical specifications of the program behaviour. Instead of bounds on version numbers, make it explicit exactly which properties of the library are relied upon.
00:23:45 <hvr> Cale++
00:23:49 <mgsloan> This might just work Cale!
00:23:59 <mgsloan> ;)
00:24:21 <begriffs> Whatever happened to that backpack project for connecting compatible modules?
00:24:21 <cocreature> good luck convincing people to write specifications
00:24:26 <hvr> Cale: except ppl then well be moining about function contracts rather than upper bounds;)
00:24:36 <ReinH> Modester solution: install a bunch of computers into the rooms of Hilbert's Hotel and have them calculate all the version compatibilities for the powerset of all packages and versions.
00:25:22 <EvanR> and have them do it by typing randomly
00:25:29 <ReinH> sure why not
00:25:35 <mgsloan> begriffs: I believe it is WIP, and it is a big part of the changes in cabal these days (new-build and such)
00:25:39 <EvanR> hilberts hotel is awesome
00:25:47 <ReinH> it is
00:26:11 <hvr> mgsloan: well, putting upper bounds on deps is a logical consequence of semantic versioning; without it semver makes no sense
00:26:15 * Maxdamantus feels like the language should be partly responsible for isolating dependencies.
00:26:57 <Cale> Hire infinitely many monkeys to work in the hotel, mashing keys in coqide until all the programs' properties are proven whenever anyone uploads a new version of a package.
00:26:59 <Maxdamantus> If your module doesn't export any types that refer to some other module's types, that other module doesn't need to be a version constraint.
00:27:03 <ReinH> Hypothesis: If semantic versioning were perfectly adhered to then upper bounds would not be problematic.
00:27:11 <hvr> mgsloan: if a package depends on other packages to implement its API, it can't guarantee semantics unless it can rely on its dependencies package's semantics not to have changed
00:27:41 <mgsloan> ReinH: Refutation: Now I can't have a build plan that includes that specific package version, and an upgraded version of that dependency
00:27:44 <Cale> To be honest, I haven't run into much of an issue with upper bounds in a few years now...
00:27:50 <hvr> mgsloan: and for that you have to restrict your dependencies bounds, in order for the package to advertise its own contract
00:27:53 <mgsloan> Unless I just "--ignore-upper" or whatever the flag was
00:27:57 * hackagebot jsonschema-gen 0.4.0.0 - JSON Schema generator from Algebraic data type  https://hackage.haskell.org/package/jsonschema-gen-0.4.0.0 (yuga)
00:27:59 <Cale> But that might be due to the hard work of others
00:28:01 <ReinH> mgsloan: how is that a refutation?
00:28:02 <taktoa> actually that reminds me, there should be a ghc extension that adds syntax for laws in typeclasses, that the compiler may use but is not required to use... such a thing would also be nice for automatic versioning that is stronger than just types but doesn't require undecidable craziness
00:28:28 <mgsloan> ReinH: Because that is a concrete problem you can encounter with perfect adherance to semver
00:28:37 <ReinH> And also without.
00:29:31 <mgsloan> No, without version bounds you have to pick your package versions, any conceivable build plan is allowed without backdoor hacks like --allow-newer
00:29:33 <hvr> mgsloan: http://cabal.readthedocs.io/en/latest/installing-packages.html?highlight=allow-older#cmdoption-setup-configure--allow-newer :-)
00:29:57 <ReinH> I don't see why this is an unsolvable problem.
00:29:59 <mgsloan> Yes, I heard that you added --allow-older, good idea!
00:30:12 <hvr> mgsloan: and we have fine-grained scoping for allow newer/older
00:30:22 <hvr> mgsloan: since it's dangerous to relax it w/o scope sometimes
00:30:23 <mgsloan> ReinH: I don't see how it isn't a direct refutation of your hypothesis
00:30:34 <ReinH> Maybe I'm not understanding you then.
00:30:44 <mgsloan> hvr: Yes, I am planning to add the same to stack! :)
00:30:50 <mgsloan> That is a good solution
00:31:03 <mgsloan> ReinH: I think it is that I am presupposing "cabal install pkg" with no magic flags
00:31:11 <mgsloan> Perhaps that is an unfair thing to presuppose
00:31:21 <ReinH> Can you describe the problem in a different way?
00:31:27 <ReinH> I'm not sure I'm getting it
00:31:45 <bollu> guys, so, we have an operating systems course, where we're given this crazy multithreaded question that we're supposed to do using only one lock
00:31:50 <bollu> I'm frustrated with deadlocks
00:31:57 <bollu> how do I prove a solution is correct?
00:32:01 <bollu> like, mathematically
00:32:07 <bollu> (I'm doing this in C)
00:32:15 <merijn> bollu: With lots and lots of pain
00:32:17 <ReinH> There are a variety of mathematical models of concurrency
00:32:20 <bollu> I though #haskell would know about, well, provably correct programs :P
00:32:25 <bollu> merijn: :(
00:32:31 <bollu> ReinH: okay, what's the simplest model?
00:32:39 <mgsloan> ReinH: A-1.0 has "build-depends: B >= 1.0 && < 1.1".  If I want to use A-1.0 with B-1.1, cabal will prevent me from doing so unless I use --allow-newer
00:32:42 <merijn> muCRL which uses mu calculus is ok for modelling concurrent programs
00:32:50 <bollu> is there a theorem prover for concurrent programs?
00:32:52 <merijn> But formalising programs in it is HARD
00:32:56 <taktoa> rewriting logic is decent
00:33:00 <ReinH> Maybe trace monoids or, equivalently, history monoids
00:33:01 <taktoa> try maude
00:33:12 <bollu> ReinH: what are tose?
00:33:13 <taktoa> or K
00:33:22 <ReinH> https://en.wikipedia.org/wiki/Trace_monoid
00:33:37 <ReinH> See also: https://en.wikipedia.org/wiki/Process_calculus
00:33:47 <bollu> ReinH: thanks
00:33:47 <mgsloan> hvr: Cale: ReinH: and others!  Thank you for the interesting discussion :)
00:34:01 <hvr> mgsloan: well, if 'A' wasn't given clearance by its author being compatible with B-1.1, then it's a risky install-plan
00:34:04 <mgsloan> I need to get on my bicycle and head home, didn't mean to be at the office so late
00:34:06 <ReinH> mgsloan: Yes, but that is literally the thing upper bounds are designed to *prevent*.
00:34:07 <merijn> bollu: mu calculus I mentioned is based on/related to pi calculus/process calculus, btw
00:34:08 <mgsloan> Ok, a little more discussion :)
00:34:20 <taktoa> bollu: from a practical perspective, threadsanitizer or http://www.rise4fun.com/Chalice is probably easiest
00:34:23 <ReinH> If you want to disregard the bounds, you should have to do so explicitly, I don't see the issue with this
00:34:24 <bollu> merijn: I see, I'kll check it out
00:34:43 <bollu> taktoa: yes, that seems nice
00:34:52 <bollu> MSR has so much cool stuff
00:34:54 <mgsloan> hvr: ReinH: Yeah, but what if it would work?  Now we need to go back and retroactively edit a bunch of metadata to allow it
00:35:00 <mgsloan> Hackage does not have good tooling for this usecase
00:35:03 <bollu> https://www.microsoft.com/en-us/research/project/chalice/
00:35:07 <bollu> uhh the page is dead
00:35:08 <hvr> mgsloan: not yet!
00:35:12 <mgsloan> I think hvr knows the pain of curation quite a bit
00:35:36 <mgsloan> hvr: And how long have we had this version bounds system?! Many years it has been going on without a solution to these systemic issues
00:35:42 <hvr> mgsloan: but it's actually less work to relax upper bounds, than to retroactively add them
00:35:50 <mgsloan> People are tired of it, so we're getting off the train and doing a different approach
00:36:06 <hvr> mgsloan: as you typically only care about a few latest major versions' dep bounds you want to relax
00:36:23 <mgsloan> I would truly love to see a good solution to these problems, I look forward to it :D
00:36:24 <ReinH> mgsloan: I think you're moving the problem around a bit rather than solving it
00:36:27 <mgsloan> More power to y'all!
00:36:42 <ReinH> now the pain point is updating stackage with new versions
00:36:54 <mgsloan> ReinH: Certainly, we're designing things so that the problem doesn't exist in the same way that it does with cabal-install
00:36:57 <taktoa> bollu: http://chalice.codeplex.com/
00:37:04 <mgsloan> Now you have full control over your deps, rather than having them change all the time
00:37:06 <ReinH> this requires considerably more coordination than a single package relaxing a single bound.
00:37:19 <hvr> mgsloan: not sure how you can while you have to adhere to hackage guidleines
00:37:25 <mgsloan> Cabal install's approach strikes me as being decidedly masochistic, if one were to personify a piece of software
00:37:32 <ReinH> mgsloan: Now, maybe this is a better place to put the problem!
00:37:32 <hvr> lol
00:37:44 <ReinH> But I wouldn't say you've solved it necessarily.
00:38:08 <mgsloan> hvr: Well if hackage starts rejecting our packages, then we will need to have a different system there too I guess (not a threat, I don't know what we would do)
00:39:06 <ReinH> tbh I usually don't want full control over my deps, I want an expert to make them work for me.
00:39:30 <hvr> mgsloan: I already said we won't reject packages
00:39:31 <ReinH> Whether that's the package maintainer, a hackage steward, or stackage maintainers, I guess I don't care too much.
00:39:42 <ReinH> Most of the time what most Haskell devs want, I think, is for their packages to Just Work together.
00:39:55 <hvr> mgsloan: at least not for PVP violations
00:40:04 <mgsloan> Same here ReinH !  I am just looking to write Haskell code as productively as possible, if that means making new tools, so be it!
00:40:20 <mgsloan> I like writing tools :D
00:40:23 <merijn> If packages were rejected for PVP violations half of hackage would vanish :)
00:40:54 <mgsloan> because IMHO, the PVP is way too much to ask of maintainers
00:41:07 <mgsloan> I wonder how much it discourages potential package authors
00:41:16 <mgsloan> We could be turning away a whole crowd of potential contributors
00:41:37 <hvr> there's a curious effect though: it's like vaccination doesn't need 100% coverage to make population immune
00:42:00 <mgsloan> I think if the PVP were automated, we could reasonably ask for its implementation
00:42:07 <merijn> mgsloan: Sure
00:42:09 <mgsloan> Without that, it seems to me to be an unreasonable request
00:42:11 <hvr> if you have a large enough number of PVP complying package you have a good chance to implicitly cover ranges for those that don't
00:42:12 <merijn> mgsloan: But implementing that is hard :)
00:42:28 <mgsloan> merijn: Right, and solving version constraints is a way more intersting problem
00:43:01 <ReinH> mgsloan: If upper bounds are done in accordance with PVP, i.e., at major versions except for specific needs, and if packages update their major versions only when semantically required, I think the system is workable
00:43:03 <merijn> mgsloan: I agree that strictly enforcing policies like PVP discourages casual "drop and abandon" contributions, but then that's one of the reasons Hackage isn't enforcing anything like that, no?
00:43:05 <Cale> I was going to release a new version of my package but I can't figure out whether to increment the second or third component of its version number. Oh well, I guess I just won't release it. ;____;
00:43:32 <mgsloan> merijn: I dunno, I think that any obstacles you make to contribution will reduce contribution
00:43:38 <ReinH> Bounds can be added automatically, only need to be changed in case something breaks per PVP policy, or in case a new major version is added, in which case new work will already be required to add compatibility.
00:43:47 <ocramz> hullo all
00:43:52 <hvr> merijn: otoh, we're trying to discourage uploading package to hackage which are just personal experiments not useful for anyone other than the package author
00:43:54 <merijn> ReinH: How would you test if something is broken?
00:43:58 <ocramz> anyone having experience with `distributed-process` here?
00:44:00 <merijn> hvr: Sure
00:44:11 <ReinH> merijn: Who is "you" in this case? Or rather, what is their role?
00:44:20 <mgsloan> I really like the punny combo "Hasochism", I think this community prefilters for masochistic programmers like myself
00:44:21 <hvr> merijn: especailly those "EXPERIMENTAL DO NOT USE" packages I've seen
00:44:34 <mgsloan> Going forward, I would prefer that we reduce the required masochism levels
00:44:40 <ReinH> As a package maintainer, I would do whatever I usually do to make sure my program works after something changes.
00:44:45 <ReinH> Compile it, run tests.
00:44:47 <merijn> ReinH: "bounds can be added automatically" <- presumably some automated process tests for bounds and needs to assess whether something is broken
00:44:52 <merijn> ReinH: That assumes tests :)
00:45:13 <ReinH> No, much simpler: check the current version and add an upper bound at the next major version
00:45:49 <mgsloan> Can we handle plebian programmers, not the masochistic crowd, learning haskell and contributing to it?  I think we can, but it will be a very intersting phase of growth from smaller PL community to medium sized
00:46:01 <hvr> merijn: it assumes tests with good enough coverage(!)
00:46:05 <merijn> hvr: Sure, I agree with that. I'm thinking more along the lines of stuff I've written which is "prototype that should work, but not tested enough to be considered robust", rather than "fundamentally broken experiment" :)
00:46:21 <mgsloan> Anyway, I really should be bicycling home right now
00:46:30 <ReinH> mgsloan: and I should be sleeping
00:46:31 <hvr> merijn: just recently I failed epically at test coverage in Cabal's testsuite... missing a big in decode/encodeUtf8 ;-)
00:46:35 <hvr> s/big/bug/
00:46:35 <ReinH> mgsloan: take care
00:46:44 <mgsloan> Thank you all for the interesting conversation.  I hope that y'all did not interpret any vitriol from my bold statements :-)
00:46:53 <hvr> merijn: there was a test in place, but it simply didn't cover the broken code-points
00:46:56 <mgsloan> Because no vitriol is felt on this end! :D :D
00:47:03 <ReinH> :)
00:47:05 <mgsloan> ReinH: You too, get some sleep soon!
00:47:17 <merijn> hvr: :)
00:47:44 <hvr> merijn: and half of the bug was actually lurking in Cabal for long time (but luckily w/o serious effect)
00:47:59 <ongy> for PVP I think suggestions would be agood idea, have cabal scan the exportet functions and say minor/major number change because X was added/Y was removed
00:48:15 <unit73e> hello
00:48:20 <hvr> I just discovered it, because I added the dual function which had a similiar bug
00:48:27 <unit73e> how do I check the implementation of Maybe?
00:48:29 <merijn> hvr: Sounds like the time I discovered the distributed reference counting implementation in our distributed runtime had been broken for, well all 10 years of the projects existence and no one noticed... :p
00:48:30 <ReinH> I would like to be able to override bounds in (transitive) deps from my package, to work around lagging maintenance on packages I don't control.
00:48:44 <jle`> unit73e: there's a link from the haddocks
00:49:03 <ReinH> e.g. foo needs its upper bound bumped but the maintainer is unresponsive and there isn't a hackage trustee in sight, and I just want it to work.
00:49:06 <jle`> unit73e: http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Maybe
00:49:09 <jle`> click "source"
00:49:12 <unit73e> thanks
00:49:21 <merijn> ongy: What if a function was already exported, didn't change types, but changed behaviour? :)
00:49:35 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/Prelude.html#t:Maybe --> click the source link on the right --> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.9.0.0/src/GHC-Base.html#Maybe
00:49:37 <jle`> unit73e: where it says "data Maybe a            ...         | # Source"
00:49:39 <hvr> merijn: ...and could it have caused subtle problems?
00:49:41 <ReinH> also sometimes it's not obvious that the upper bound should be bumped for *everyone*, but I still want to do it for my package.
00:49:56 <jle`> the implementation might be dissapointing :)
00:50:00 <ongy> merijn: if it changed enough for a non patchlevel change I think the maintainer would be aware.
00:50:23 <Cale> unit73e: The implementation is exactly what everyone says it is :)
00:50:27 <jle`> @src Maybe
00:50:27 <lambdabot> data Maybe a = Nothing | Just a
00:50:33 <merijn> hvr: Both use after free and free after use errors :p
00:50:46 <merijn> eh, use after free and never GCing, I mean
00:50:46 <Cale> Another thing you can do, since Maybe is a type, is to :info Maybe inside GHCi
00:51:08 <jle`> is there any reason why there isn't a RULES pragma for realToFrac :: Double -> Double, like there is for fromIntegral :: Int -> Int ?
00:51:16 <jle`> seems like a no-brainer
00:51:17 <ongy> merijn: and that never resulted in any major OOM errors?
00:51:23 <ReinH> Ok, I suspect the Maybe question has been sufficiently well answered.
00:51:24 <Cale> jle`: Are there not?
00:51:29 <jle`> i don't see one
00:51:43 <jle`> i was trying to generalize some code earlier when i looked it up and saw that there wasn't, and gave it up
00:51:51 <jle`> http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Real.html#realToFrac
00:51:52 <unit73e> oddly enough the source is returning an error but thanks. I understood anyway.
00:52:04 <merijn> ongy: No, machines have crazy memory nowadays
00:52:06 <jle`> compare to http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Real.html#fromIntegral
00:52:51 <jle`> i mean, i can imagine situations where (fromRational . toRational) gives a different result than id
00:52:54 <jle`> for Double -> Double
00:53:07 <jle`> but i don't think people would ever ... *rely* on the difference ...
00:53:20 <ReinH> Cale: btw your link won't show the source of Maybe, which is in Data.Maybe :)
00:53:26 <jle`> but maybe it could cause code to give different results down the line
00:53:46 <ReinH> Oh your second one does.
00:54:03 <ReinH> Wait does Data.Maybe reexport it too?
00:54:09 <Cale> ReinH: Yeah, I was explaining how to get to it from there.
00:54:11 <ReinH> lol
00:54:13 <ReinH> ah
00:54:53 <jle`> (fromRational . toRational :: Double -> Double) giving different results than 'id' might be why there's no RULES pragma
00:54:56 <jle`> shame tho
00:55:30 <jle`> well, i probably could have just written my own realToFrac with its own RULES
00:56:04 <Cale> Or you can just add your own RULES
00:56:09 <jle`> you can do that?
00:56:10 <Cale> for realToFrac
00:56:11 <Cale> yeah
00:56:29 <jle`> is it kind of like typeclasses, where if you import a module that has them, then they're global?
00:56:34 <jle`> and you can define orphan RULES ?
00:56:49 <jle`> orphan RULES is kind of a scary concept
00:57:24 <ReinH> jle`: I mean, no one should be surprised when anything involving floats gives different results, including GHC.
00:57:42 <jle`> you could hide a {-# RULES "return/Int->IO ()" return = \_ -> launchMissiles #-}
00:57:57 <jle`> using orphan rules, any package could override an implementation by any other package
00:58:23 <jle`> er, Int -> IO Int
00:58:37 <jle`> i can't believe that it's a thing
00:59:14 <ongy> aren't rules applied at compile time?
00:59:26 <jle`> yeah
00:59:41 <jle`> so if you ever 'return 1' in IO, it might just replace it with an IO action to launch missiles
00:59:49 <jle`> or reformat your hard drive
00:59:59 <jle`> or better yet
01:00:00 <ongy> so you can only overwrite things where you could also just go into the source to override. Or you would have to import something untrusted, which is questionable aswell
01:00:15 <jle`> {-# RULES "main/main" main = launch missiles #-}
01:00:28 <Cale> jle`: That's too obvious. You need to make it something really subtle which will make it look like it's the fault of some other package :)
01:00:44 <jle`> heh
01:01:09 <jle`> yeah, you could have a package that rewrites a random function in 'containers' to be unsafePerformIO launchMissiles
01:01:26 <merijn> {-# RULES "not/not" not = unsafePerformIO (even <$> (randIO :: IO Int)) #-}
01:01:32 <jle`> even worse
01:01:36 <Cale> You could have a package which only does that when you use that function from containers with a function from websockets
01:01:55 <jle`> why are orphan rules even allowed?
01:03:23 <javjarfer> Anyone knows why this Data.Time.Format, choose to return errors instead of Just a Maybe or Either, when it fails??
01:03:52 <Cale> jle`: On occasion, they're pretty useful for hacking the performance of your code.
01:04:21 <Cale> jle`: You can add your own rules for simplifying stuff involving two of the libraries you're using.
01:04:58 <jle`> hm i guess so
01:08:20 <javjarfer> Okay, my bad, they have the Monad.Fail one, all nice, thanks 
01:10:05 <fr33domlover> javjarfer, maybe because time formatting shouldn't fail?
01:11:57 <fr33domlover> (small side note: for trivial but common time formats you can directly extract the parts you need from the UTCTime and then you avoid the format string parsing step (which is also kind of ugly because it's processed at run time while often it's a static known-at-compile-time string...)
01:13:25 <javjarfer> fr33domlover, maybe, but they have the correct approach also, I simply didn't see that function, and when looking the old version, so I said... what a weird thing... when this start becoming Java? But then I came back, and saw they are using Monad.Fail also in the "principal" function, so my bad... 
01:14:25 <javjarfer> fr33domlover, ***when looking the old version I saw that they were using Maybe (typo there)
01:14:43 <merijn> fr33domlover: I have a prototype for partial conversions from compile time strings :)
01:15:01 <merijn> fr33domlover: https://hackage.haskell.org/package/validated-literals <- feedback welcome :p
01:15:31 <javjarfer> fr33domlover, merijn, thanks for the tips, I will check it
01:17:22 <ongy> have you seen the time format stuff in Formatting?
01:17:24 <fr33domlover> merijn, that looks brilliant! but for time formatting i think i'd prefer something like the formatting package i.e. replace the format string with a concatenation of format specifiers
01:17:58 <fr33domlover> ongy, yep :)
01:18:03 <merijn> fr33domlover: Sure :)
01:18:31 <ongy> fr33domlover: look up what it does as implementation
01:18:39 <merijn> fr33domlover: I wrote this to play around with stuff like being able to use string literals for, e.g. ByteString, but still being safe
01:18:40 <ongy> Either I failed to understand it, or I really dislike what they are doing
01:18:42 <fr33domlover> ongy, I did and it just uses C functions
01:18:45 <merijn> fr33domlover: I should update it a bit soon
01:18:56 <fr33domlover> iiirc
01:19:00 <fr33domlover> *iirc
01:20:10 <merijn> btw
01:20:15 <fr33domlover> merijn, it could be awesome for things like parsing config at program startup - instead of 'error' it could fail when building, e.g. if you need to specify a password in config
01:20:22 <fr33domlover> and you specfify it too short etc.
01:20:59 <fr33domlover> of course that's only acceptable if you write config in Haskell itself :P
01:21:06 <merijn> fr33domlover: Right, that's exactly the sorta thing I was thinking about. You want a smart constructor "String -> Maybe Password", but it's a pain (or even impossible) to deal with that signature for compile time constants :)
01:21:43 <merijn> Because then you end up "case smartConstructor "blah" of Just x -> code; Nothing -> {- now what?! -}"
01:23:35 <ongy> I would prefer seeing this with C++ like constexpr, so we can just tell GHC to evaluate the smart constructor at compile time, but this looks nice
01:24:31 <jle`> interestingly enough, the GHC documentation uses optimizing realToFrac as an example of a good situation to use RULES
01:24:36 <jle`> but it doesn't do it itself
01:24:39 <merijn> ongy: I proposed that
01:24:59 <ongy> got any reaction?
01:25:03 <merijn> ongy: But people thought it was a lot of effort and not sure whether it'd be useful, so I was told to implement a prototype first :)
01:25:52 <merijn> I should add some more default instances (like a safe FromString for ByteString!) to it and fix the way you write instances
01:26:16 <merijn> I heard a rumor GHC will Soon (TM) auto-derive Lift instances, which will make this implementation *a lot* better
01:26:28 <ongy> merijn: pls utf8 the String
01:27:02 <merijn> ongy: No, just error on any ByteString containing non ascii :)
01:27:18 <ongy> or that. I guess that's better in this case
01:27:35 <merijn> ongy: It'd basically be the current FromString, except not evil
01:29:26 <ongy> "e.g., fromJust. Since fromLiteral is pure (right?!)" quality documentation :)
01:30:22 <merijn> ongy: You could conceivably implement an impure fromLiteral using unsafePerformIO, but then people are digging their own graves
01:31:26 <merijn> ongy: If you're 'b' type is a Lift instance you actually only have to implement "fromLiteral", I would recommend creating a Lift instance over using hackySpliceValid, since that is for sure more efficient
01:31:32 <merijn> s/you're/your
01:31:53 <merijn> Sounds like Lift derivation is going to be in GHC 8.2
01:33:21 <ongy> merijn: I get it. And I actually like the documentation. But the hacky thing could also be intersting. Have a (expensive?) safe version for fromLiteral and a potentially unsafe but faster during runtime
01:36:23 <merijn> Using two functions would rather defeat the safety :p
01:37:52 <Insanity_> given a list of tuples, what would be the best way to write them to a file separated by newlines? my first thought was converting them to strings so I can use intercalate, but is there a better way?
01:38:01 <Insanity_> > intercalate "\n" ["hello","world"]
01:38:04 <lambdabot>  "hello\nworld"
01:38:09 <ongy> We could check for safety of a string and just have id during runtime. But I guess that would be Lifted either way
01:38:22 <ongy> s/safety/validity/
01:39:09 <ongy> Insanity_: What's the type? [(String, String)]?
01:39:37 <Insanity_> [(String, Integer)]
01:40:15 <ongy> mapM_ (putStrLn . show). Adjust for what you need
01:40:19 <merijn> ongy: That assumes the only use of this TH is to do newtype wrapping :)
01:40:39 <Insanity_> Thanks ongy
01:40:47 <merijn> ongy: The nice thing is that this stuff works even if you turn a literal into an arbitrary complex data structure
01:41:18 <merijn> ongy: You could parse a string into an AST/HTML ADT at compile time using this too :)
01:41:20 <ongy> I know. Though I haven't quite figured out how template haskell for that works. Or how I would write my own Lift instance
01:41:34 <merijn> ongy: Lift is easy, there's an example for Even in the examples
01:41:52 <merijn> ongy: https://github.com/merijn/validated-literals/tree/master/examples
01:42:17 <merijn> Actually, I don't make Even a Lift instance, apparently, I just write the splice directly
01:42:41 <Myrl-saki> ertesx: I don't think I should use FRP for game logic anymore. xD
01:43:36 <ongy> I wonder if this still works https://hackage.haskell.org/package/th-lift-0.7.6/docs/Language-Haskell-TH-Lift.html
01:44:13 <ongy> wait, is that the default? Then Lift instance should just be the deriveLift, right?
01:45:03 <merijn> ongy: That should, yes
01:45:30 <merijn> ongy: But I didn't wanna add a dependency for that since Lift deriving is going to be added to GHC itself :)
01:47:25 <merijn> ongy: If you use that you should only need to specify "fromLiteral", since I use defaultsignatures to provide a default "spliceValid" using Lift
01:47:48 <ongy> https://hackage.haskell.org/package/validated-literals-0.2.0/docs/src/ValidLiterals-Class.html#Validate :(
01:48:10 <merijn> ongy: hmm?
01:48:22 <ongy> No source linked
01:48:59 <merijn> ongy: Yeah, I saw. Not sure on how to make cabal fix that
01:49:30 <merijn> You can check the github repo though, the entire package is like 2 files
01:50:50 <ongy> fr33domlover: https://hackage.haskell.org/package/formatting-6.2.2/docs/src/Formatting-Time.html#fmt I don't think that's a C call btw.
02:00:43 <chenyu> stack is not working on osx sierra :(
02:01:03 <hvr> merijn: as to crazy mem... my current dev workstation has 32GiB... which often hides space leaks... ;-)
02:01:30 <ongy> I have 12 :(
02:02:40 <merijn> hvr: You know what's not fun? (Not personal experience, but a colleague during my internship)
02:02:49 <merijn> hvr: Trying to inspect core dumps on a machine with 5TB RAM
02:02:53 <hvr> ouch
02:03:13 <merijn> "Hold on guys, gdb is loading..." *goes to the gym for 5 hours*
02:03:15 <jasonm> been out of the loop for a while.. is stack recommended these days over using cabal sandboxes
02:03:24 <merijn> jasonm: Depends who you ask :p
02:03:42 <hvr> jasonm: ...and that recommendation may change again in 1-2 years :)
02:04:02 <merijn> jasonm: Especially if you already know cabal/cabal sandboxes
02:04:21 <merijn> jasonm: I've not felt the need to bother learning stack, consindering how comfortable I am working with cabal
02:04:50 <hvr> merijn: I hope cabal new-build won't make you reconsider when it becomes default :-)))
02:04:55 <merijn> jasonm: So it's a matter of "how much difficulty do you have now?" and "how much motivation can you muster to learn another tool" :p
02:05:35 <merijn> hvr: I'm hoping if I procrastinate learning stack long enough, cabal will have fixed the minor issues I have with it by the they get too frustrating :p
02:05:47 <jasonm> are there any other reasons for using cabal sandboxes other than familiarity?
02:05:47 <merijn> s/by the/by the time
02:06:14 <hvr> jasonm: well, cabal sandboxes are going away anyway in the next-gen cabal
02:06:24 <merijn> jasonm: Not really, but otoh, there's isn't really any reason to use stack besides "I have problems with cabal as it is"
02:06:27 <mgsloan> jasonm: None that are substantial.  Stack has a lot of convenience and automation that's missing in cabal
02:06:28 <ongy> they are? any replacemant?
02:06:28 <cocreature> jasonm: yes, some things are impossible with stack atm, e.g. uploading docs
02:06:31 <luite> merijn: is that on x86-64?
02:06:37 <jasonm> hvr oh? what replaces them? 
02:06:37 <merijn> luite: Sparc
02:06:46 <mgsloan> merijn: Perhaps you should give it a try before making that statement :)
02:06:49 <jasonm> hvr stack?
02:06:50 <hvr> jasonm: this:  http://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
02:06:58 <merijn> ongy: Nix like approach, basically EVERYTHING would be sandboxed
02:07:11 <merijn> ongy: Except, like, automatically and without redundancy
02:07:46 <merijn> mgsloan: I can't be arsed learning a new tool that's designed to support a workflow that is the complete antithesis of mine :p
02:07:51 <ongy> sounds nice. I have to finally get the motivation to set up nix in a good way
02:07:55 <tsahyt> hello, I was looking at GHC.TypeLits once more and noticed that it states that this is an internal module and the interface for working with it should be defined elsewhere. However, I can't find any other module in base that actually exports Nats etc. Why is this?
02:08:00 <mgsloan> merijn: Ok, and where did your workflow come from?
02:08:04 <mgsloan> Oh, cabal! :D
02:08:32 <mgsloan> We, and many other industrial users find that stack is crucial to getting things done effectively
02:08:47 <merijn> mgsloan: No, it comes from the fact that I have very small projects, little dependencies and a workflow that's not project based
02:08:51 <mgsloan> If you want to fuss with version constraints and regularly blow away your databases, feel free to use cabal
02:09:01 <mgsloan> Right, if you have small projects anything will work ok
02:09:11 <merijn> mgsloan: Stack wants me to define projects and shit and I can't be arsed with that
02:09:15 <mgsloan> Well maybe not /anything/ but I'm getting tireder and looser with my language
02:09:24 <mgsloan> merijn: Run "stack init". Problem solved
02:09:37 <mgsloan> If you can't be arsed to type that, then yes, switching to stack is too much for youy
02:10:07 <ongy> I tried stack once. It didn't do what I wanted it to do in 5 minutes, I went back to cabal. Pretty sure that was userfault, but cabal worked :)
02:10:17 <mgsloan> ongy: What did you try?
02:10:26 <merijn> mgsloan: And now I first need to: install stack, run init, figure out what that actually did, figure out which commands I'm supposed to use, fix my (currently working just fine) setup of hdevtools to work with it, etc.
02:10:30 <mgsloan> Eh, I suppose it is hard to remember :)
02:10:42 <mgsloan> Please try again, and keep in mind how long you had to spend learning the ropes with cabal
02:10:57 <mgsloan> You cannot expect to learn stack and have it behave the same, it behaves differently, mostly for good reasons
02:11:20 <ongy> mgsloan: I think use the system installed compiler. Not quite sure
02:11:25 <merijn> mgsloan: tbh, I've always found cabal rather obvious and pleasant, considering much of my work involved makefiles (or worse! cmake/autohell)
02:11:53 <mgsloan> merijn: And I have found stack to be a breeze in comparison, but I am naturally biased, I work on stack
02:12:12 <mgsloan> I always have had issues with cabal, it manages very little of your environment (multiple compilers)
02:12:33 <hvr> mgsloan: well, compilers are the concern of the system packager
02:12:43 <hvr> mgsloan: you don't expect a makefile to install gcc for you either
02:12:51 <mgsloan> If you haven't worked on big haskell projects, then yes, you might not run into the rough spots of cabal-install so much
02:13:04 <ongy> though most don't handle multiple versions well. At least to my experience
02:13:11 <mgsloan> We expect to have tools that automate away the concerns of the developer.  That is stack's attitude
02:13:19 <merijn> mgsloan: See, I look at the stack install and I already see it won't work for me, since every single instruction (as usual for most language tools these days, apparently) expect "sudo apt-get"/"sudo yum"/sudo whatever to work
02:13:33 <hvr> well, cabal is closer to the unix philosophy\
02:13:39 <mgsloan> merijn: Ok, use "cabal install stack" bam
02:14:19 <mgsloan> Though, that is dicey.  We have had multiple users come to us with bug reports that don't match normal stack behavior, because cabal decided to use different dependency versions
02:15:00 <hvr> well, then the dep spec wasn't accurate
02:15:01 <merijn> hvr: Maybe that's my objection
02:15:17 <merijn> hvr: I *like* the unix philosophy
02:15:22 <mgsloan> hvr: So you think that stack should be responsible for every single point in the version range? That's absurd
02:15:32 <hvr> mgsloan: nope, it shouldn't
02:15:50 <merijn> mgsloan: Well, you said "it used a different version, that's why it didn't work" <- sounds like wrong versions to me?
02:16:01 <mgsloan> In this case, it was bugs in the packages, so they weren't accompanied by a semantic bump
02:16:06 <mgsloan> At least, IIRC
02:16:24 <mgsloan> merijn: Not wrong versions, just different than the official stack release
02:16:49 <mgsloan> A stack version number is a version for the whole kit-and-caboodle, not just the top of a tree of varying deps
02:16:53 <hvr> mgsloan: there is a of course an issue with packages not doing the required version bumps when they change semantics
02:17:04 <hvr> mgsloan: but that's neither stack's nor cabal's fault
02:17:08 <chenyu> well, as we are talking about stack now, anyone know how to fix the issue on osx sierra?
02:17:17 <mgsloan> hvr: But it is so easy to change semantics.  Is a bugfix a semantics change?  What if it introduces a regression?
02:17:32 <mgsloan> This is why semantic versioning itself is an inexact science, an advisory, not a rule
02:17:38 <chenyu> My stack doesn't work on sierra
02:17:55 <hvr> mgsloan: well that's coincidentally also what  the purescript maintainers ran into
02:18:05 <chenyu> get "dyld: malformed mach-o: load commands size (34520) > 32768"
02:18:10 <hvr> mgsloan: and iirc wanted purescript removed from stackage
02:18:13 <merijn> mgsloan: Right, see you're advice got me looking at the Stack webpage and now I see a mountain of docs I'd have to read on setting up projects, etc. while I'm already happy with the way things work, which I'm absolutely not motivated to read that mountain of text :)
02:18:23 <chenyu> When tring to do any command
02:18:37 <merijn> s/you're/your <- tired
02:18:44 <prtl46> hello, absolute noob here. learning programming currently and was told to check out irc and here i am. Any tips or advice would be greatly appreciated
02:18:44 <mgsloan> chenyu: Not my area of expertise, please post an issue on the stack tracker
02:18:46 <ahihi> chenyu: looks like the same issue as https://github.com/commercialhaskell/stack/issues/2577
02:18:47 <merijn> s/which/which means/
02:19:33 <chenyu> ahihi: yeah, the same
02:19:42 <mgsloan> chenyu: Looks like it is a ghc issue https://ghc.haskell.org/trac/ghc/ticket/12479
02:19:56 <ongy> mgsloan: What exactly does stack do better than cabal? All I know is versions, and "local" compiler versions
02:20:07 <mgsloan> chenyu: If you are building with 8.0 I suggest trying 7.10.3 or 7.8.2
02:21:05 <mgsloan> ongy: Lots! It means that your builds are deterministic by default, and it allows you to specify ghc-options and flags for all of your packages
02:21:17 <mgsloan> It shares packages between snapshots, so you don't need to do much rebuilding a lot of the time
02:21:26 <mgsloan> (ghc-options and flags for your dependencies as well)
02:21:40 <mgsloan> Essentially, stack gives you full control over how your package gets built
02:22:03 <mgsloan> Rather than leaving it up to the solver.  If you want the solver, and sometimes you do, you can use "stack solver" to get cabal to do the constraint solving
02:22:30 <mgsloan> If you don't have a project configuration yet, you can just get one via "stack init --solver".  Then, you will get a minimal frozen config with which to build packages
02:22:41 <mgsloan> Man the list goes on, we've got direct support for docker and nix
02:22:45 <hvr> mgsloan: here's the long discussion in case you missed it: https://github.com/purescript/purescript/issues/2293#issuecomment-249393501
02:22:54 <mgsloan> As containerization technologies for hermetic builds
02:23:16 <hvr> `Incidentally we're trying to discourage people from doing stack install purescriptentirely, because it usually gives you an out-of-date version`
02:23:38 <mgsloan> Cabal leaves it up to you to manage your environment.  Stack manages many of the details of your environment, so much less can go wrong 
02:24:14 <luite> there's also less that can go right ;)
02:25:55 <mgsloan> hvr: Yeah, I shouldn't poke at that particular point, stack doesn't have that nailed yet. I believe this will address the concerns: https://github.com/commercialhaskell/stack/issues/2122
02:26:13 <mgsloan> Bumping to P1 because we have an example where it matters
02:27:05 <hvr> mgsloan: well, as long as it doesn't become mandatory to use the bundled stack.yaml for getting a working build...
02:27:26 <hvr> mgsloan: as that would basically result in packages being uploaded to hackage which don't work with cabal
02:27:28 <mgsloan> It won't, there will also be "stack install --solver purescript", which will use cabal-install to get a build plan
02:27:30 <luite> mgsloan: are there plans to do anything with Cabal's new-build with stack?
02:27:50 <mgsloan> luite: Doubtful, I am worried that if new-build changes everything, then we will need to stick to old Cabal versions
02:28:06 <mgsloan> But new-build is mostly in cabal-install, right hvr?
02:28:19 <mgsloan> If Cabal retains the same CLI we will be safe
02:28:30 <hvr> mgsloan: yes, most of it is in the frontend, with some minor changes in the Cabal API to support it
02:28:44 <hvr> mgsloan: however, Cabal 2.0 is an API breaking release
02:28:48 <hvr> for other reasons
02:28:54 <mgsloan> Cool, so I think that answers the question luite - stack relies on very little of cabal-install, just the solver
02:28:57 <luite> mgsloan: are the approaches incompatible? or is here just not much use for it?
02:29:25 <mgsloan> Not much use for it, since stack does many of the same things, and has for a much of its existence :D
02:29:41 <mgsloan> As hvr said earlier, stack has caused cabal's development to accelerate
02:29:53 <hvr> IOW, it's mostly code-duplication
02:30:14 <hvr> stack and cabal do more or less similiar things, just with a different impl
02:30:32 <mgsloan> Yep, different impl, different philosophies
02:31:00 <srhb> What it stackage in cabal new-build terms? A set of constraints?
02:31:22 <hvr> srhb: yep, it's called more generally "package collections" in cabal's universe
02:31:26 * srhb nods
02:31:27 <mgsloan> srhb: Yes, I have discussed this with duncan and he has some dreams for snapshots that have a set of constraints
02:31:32 <ongy> mgsloan: how hard is it to setup a system where I: Have a single command to start up a list of compiler sandboxes to test compilation? i.e. do what I have travis do for me on my machine? Preferably with container support
02:31:46 <hvr> srhb: but it's basically an extended form of constraints that's being planned
02:31:46 <mgsloan> And the ability to union and intersect etc, boolean operations on these package collections
02:31:54 <mgsloan> Interesting ideas, certainly, I look forward to seeing it happen
02:32:01 <luite> mgsloan: right, I was wondering if this could make them coexist more easily. like share a build cache with non-stack projects if stack sets up a curated environment based on a new-build sandbox
02:32:19 <cocreature> shared build caches would be awesome
02:32:47 <merijn> hvr: I wonder if there's a reasonable way to detect whether flags affect the exported API of a package and disallow uploads of new versions/packages that do this
02:32:54 <hvr> luite: sharing caches would require a common on-disk format
02:33:22 <ongy> merijn: there would be for what I'm doing... I should fix that
02:33:27 <hvr> merijn: only for simple cases I'm afraid
02:33:31 <luite> mgsloan: is it really a different philosophy on how to do things? or actually mostly a difference on what to do first?
02:33:33 <merijn> hvr: That's what I feared :\
02:33:36 <mgsloan> luite: That would be cool! I'd be in favor of such a change if we could be sure that it didn't expose stack to unexpected errors due to issues in the cache
02:33:38 <hvr> merijn: CPP, TH, and all that can make it quite difficult
02:34:00 <ongy> should flags keep all the same functions?
02:34:00 <merijn> hvr: Still, it'd be a start in convincing people to stop freaking doing that >.>
02:34:04 <merijn> ongy: Yes
02:34:12 <mgsloan> luite: I think that "what to do first" is the most important thing.  We have finite time to work on software
02:34:13 <hvr> merijn: it should be possible to implement heuristic detections
02:34:32 <merijn> ongy: Use flags for dependency toggles like, e.g. whether to depend on unix or unix-compat for windows
02:34:39 <ongy> why? If an entire module becomes useless without the flag, why should I have dummy functions that error/missbehave during runtime? That sounds completely wrong to me
02:34:47 <merijn> ongy: You cannot (by design) control flags of your dependencies
02:35:00 <merijn> ongy: That feature/module should not be controlled by a flag
02:35:00 <mgsloan> luite: Like I would prioritize a GHCJS release, but I also understand the value of having full 8.0 support and a more complete ghcjs-base
02:35:06 <luite> mgsloan: right, that was my impression as well
02:35:09 <luite> mgsloan: haha
02:35:09 <merijn> ongy: Your users cannot depend on that flag being enabled
02:35:14 <mgsloan> luite: Actually we should discuss that :D
02:35:35 <mgsloan> I'm keen on trying to make it happen, despite the state of imperfection, GHCJS is definitely ready for use in the real world
02:35:36 <merijn> ongy: So now packages depending on you will just refuse to compile
02:35:38 <luite> mgsloan: after i've given my talk in tokyo
02:35:42 <mgsloan> As is proven by obsidian systems, etc
02:35:45 <luite> which is saturday
02:35:52 <mgsloan> Excellent! That is fantastic :)
02:36:10 <luite> talking about it, i didn't just promise a release :p
02:36:29 <luite> although i do agree that having one would be good
02:36:30 <mgsloan> Haha fair, quite fair!
02:36:31 <hvr> luite: we also still have a minor issue with ghcjs and meta-data on hackage
02:36:49 <hvr> luite: that our meta-data is not expressive enough yet 
02:36:51 <mgsloan> Yes, I think having a release of GHCJS would help people feel confident in relying upon it, and attract more contributors
02:37:06 <ongy> merijn: then what would be the intended way? Fork out another package with a single module for every optional dependencie on some C library that may not be present?
02:37:26 <merijn> ongy: Yes and/or parameterise over it, or just not make it optional
02:37:28 <hvr> luite: i.e. cabal will happily pick a package which requires C FFI support for ghcjs, simply because we can't express the requirement of FFI yet (since ghcjs also advertises FFI support)
02:38:01 <merijn> btw, that's something for the committee to pick up
02:38:19 <merijn> Since the current report requires a C FFI, which seems unreasonable for ghcjs :)
02:38:25 <hvr> merijn: indeed
02:38:33 <luite> hvr: yeah that's a long-standing issue. it does support the C ffi, but requires a JS implementation to be available
02:38:37 <hvr> merijn: it would help if the pragmas were more granular
02:38:55 <hvr> merijn: so you could have one sub-pragma for C FFI, and one for JS FFI
02:39:06 <ongy> merijn: So I have this project: https://github.com/monky-hs/monky In particular the https://github.com/monky-hs/monky/blob/master/Monky/Examples/Sound/Pulse.hs How should I handle a system that does not have libpulse-dev? Which I really don't want to make mandatory since it pulls in x11-common and avahi. Put that single file into another package?
02:39:34 <hvr> luite: and this is gonna get worse with the GHC JVM project
02:39:43 <hvr> luite: then we have 3 FFI flavours ;)
02:40:15 <luite> hvr: one of the things that I'd like to start making more detailed plans for is WebAssembly support, which is more or less in between LLVM and JS as a target
02:40:24 <hvr> yay
02:40:27 <merijn> ongy: Or perhaps move it into the executable?
02:40:49 <ongy> move what into which executable?
02:41:08 <merijn> ongy: afaict it's a tool to do stuff with xmonad, yes?
02:41:32 <luite> hvr: in its current spec it'd require porting the storage manager, but the first version is a tad limited. I hope we can target a slightly later spec after they've added tail calls, multithreading and perhaps managed structs
02:41:33 <hvr> luite: so is WebAssembly looking better now? iirc you weren't that optimistic about WA being a good fit for ghcjs some time ago
02:42:09 <merijn> ongy: So in the executable having Pulse support only makes sense on a system with pulse. But if someone depends on your library they can't enforce your library is built with pulse support, even if they need it
02:42:10 <ongy> not really. It has no real connection to xmonad, but I took the "haskell as a config" from xmonad and it's only really helpful on (tiling) WMs (i.e. not DE)
02:42:23 <mgsloan> Washington state is definitely stoked on GHCJS ;-D
02:42:47 <mgsloan> (WA, heh)
02:43:00 <tsahyt> I've got a phantom parameter on which I can define ordering semantics, and I want to be able to write a function that only takes inputs with a parameter great than something. I think singletons could help me here, but I don't know how to define instances
02:43:17 <tsahyt> where can I read up on how to use singletons for custom types?
02:43:28 <merijn> ongy: Depending on exactly the functionality you want to have, you could use an object like approach in Haskell for this. But it's hard to say
02:44:04 <tsahyt> i.e. I want to use the promoted Ord class (POrd)
02:44:06 <luite> hvr: I talked with someone who gave a WebAssembly talk at ICFP and there is a chance that it might be easier to add certain features to WebAssembly than JS, since they have to be less cautious. Apparently browser vendors are rather reluctant to add JS features that might confuse novice programmers
02:44:56 <hvr> luite: overemphasizing the needs of novice programmers seems to be a common problem... ;)
02:45:43 <luite> hvr: some apparently want tail calls removed since they are not explicit, and being in strict mode can result in stack frames unexpectedly disappearing from stack traces in exceptions
02:45:45 <hvr> (and/or speaking for those)
02:46:13 <hvr> ...or they could make TCs explicit
02:46:41 <hvr> like in some other languages
02:46:46 <mgsloan> I think we really need something like Google Native Client (NaCL).  Once that happens, ideally GHCJS could target it and we wouldn't deal with the non-native slowdown so much, perhaps a bit of a virtualization / emulation layer slowdown 
02:46:46 <merijn> ongy: Although right now it seems only your examples use flags like this, so that should be fine
02:46:51 <luite> hvr: yeah i'm not sure why that didn't happen. I suppose that they want to avoid adding keywords
02:47:13 <mgsloan> So I am much more excited about full-on-native approaches than things like Web Assembly
02:47:21 <hvr> luite: well, new keywords are a backward compat issue probably
02:47:40 <merijn> mgsloan: I'm not, it gives me a heart-attack thinking about the security horrors
02:47:44 <hvr> luite: JS is hard to extend these days thanks to old browsers outliving their purposeful lifetime
02:47:56 <mgsloan> Oh hey, maybe I don't know enough about Web Assembly, looks like Nacl people contributed to it
02:48:38 <merijn> mgsloan: At OPLSS in 2014 one of the guys working on NaCL talked about verifying their sandbox for safety and all the subtle things they completely failed to protect against initially and lord knows how many issues they still haven't thought off
02:48:56 <mgsloan> Well, and there's always rowhammer
02:49:11 <luite> mgsloan: WA has a bit more structure than LLVM, makes it easier to verify, and to translate directly to some lower intermediate language in the JS engine
02:49:35 <hvr> luite: can you easily call out to ordinary JS things from within WA?
02:50:11 <merijn> mgsloan: Turns out that, 1) intel can read non-aligned instructions and 2) completely safe and verified instruction streams can include unsafe instructions when read at an offset, meaning that jumps that ended up reading code at different alignment completely broke all the sandboxing security in NaCL >.> (I think that's fixed now)
02:50:13 <hvr> or can you only call into into WA, but not from WA back into plain JS?
02:50:27 <merijn> mgsloan: But that sorta stuff scares the bejesus outta me when people wanna run native code in the browser
02:50:39 <mgsloan> merijn: Wow!  That's a clever trick
02:50:40 <luite> hvr: it's somewhat more complicated, in the first spec you can't directly reference JS data, but GHCJS could easily emit all the necessary glue code
02:50:43 <merijn> Same with WebGL
02:50:44 <Insanity_> I'm using a haskell splitRegex in two files, one German and one English. The English one runs fine, but the German one says "illegal byte sequence"
02:50:48 <Insanity_> Probably due to the encoding?
02:51:15 <lyxia> probably
02:51:16 <mgsloan> luite: One of the reasons I am excited about GHCJS is that it could probably make the leap to something like Web Assembly once all that stuff gets figured out
02:51:27 <mgsloan> So for now we are taking a performance hit, but in the future, maybe not so much
02:51:46 <ongy> merijn: It's that one and ibus, which has the same problem. I only have the flags because they depend (transitivly) on some C library that I don't want to make mandatory
02:51:48 <merijn> mgsloan: You should look up ROP  (return oriented programming), which is basically "stringing exploit code together from existing bits of code" (rather than injecting it via a buffer overflow), some of this security stuff has mindblowing inventions
02:51:57 <hvr> luite: do you have an estimate if the generated WA code would be more compact than the generated .js code?
02:52:32 <merijn> ongy: Yeah, but they're also not part of your libraries interface. My point is that, if that module was part of the libraries exported modules, then someone depending on your library can't be sure whether that module exists
02:52:36 * hvr is expecting it to be less compact actually
02:52:53 <mgsloan> Assuming that WA code is binary encoded, it must be way more compact.  Compression does very well at compressing GHCJS output, though 20mbs become 2mb downloads
02:53:25 <hvr> mgsloan: otoh, it may be more low-level, like C vs amd64 assembly
02:53:33 <luite> hvr: it's actually not download time that dominates startup overhead in most cases. it shoud be much more efficiently parseable
02:53:35 <ongy> merijn: if it's ever used as real library. That's about as reasonable as using xmonad as library. And both of them are exportet. I do see the problem that comes from it, but I can't really agree that I know a better solution
02:53:59 <hvr> luite: I'm thinking about mobile devices which have to download over slow links :)
02:54:38 <mgsloan> I'm more worried about the mobile device's battery!
02:54:50 <ongy> but that's something I came across the first time I read into cabal. Conditional compilation is lacking. And the cods say so with "We don't want conditional. Cabal does dependencies for you, so just use them" which I somewhat disagree with. And in those 2 cases cabal simply fails
02:54:58 <hvr> luite: and when the .js code gets larger than a native android app.. it's weird :)
02:55:01 <luite> hvr: me too. even fast ARM CPUs take a lot longer to parse and do an initial JIT compile pass than desktop cpus
02:55:30 <luite> hvr: did you see the recent addition of the -dedupe option to GHCJS by the way?
02:55:43 <hvr> luite: yeah, didn't have a chance to try it out yet though
02:56:03 <luite> hvr: SPJ told me that he had an intern look ad GHC's good, and found something similar, the same instruction sequences repeated over and over again
02:56:10 <luite> GHC's code
02:56:11 <luite> argh
02:59:00 <luite> mgsloan: anyway, the number of targets does increase. i'm hoping to get rid of ghcjs-boot at some point, and have cabal new-build, or perhaps stack, initialize these libraries on demand, with a shared build cache
02:59:04 <kuribas> Can I calculate a checksum using Binary?  If I use Put, I can only write the values, but I need to be able to read them back to calculate the checksum.
02:59:21 <luite> mgsloan: so you might have ES2015, ES5, WA32-1.0, WA64-1.0 etc
02:59:55 <lyxia> kuribas: Use Get to read a bytestring.
03:00:11 <mgsloan> luite: Interesting, makes sense!  We'll have to make sure that the build system knows about that
03:00:37 <mgsloan> If you want some help with ghcjs-boot automation, I might be able to lend a hand, I dove into it some back in the day, I think I know what the situation looks like
03:00:48 <lyxia> kuribas: It's simpler to use a fold or a similar recursive traversal of the bytestring.
03:00:54 <lush> hey everybody! :)
03:00:55 <mgsloan> I think switching to submodules or megarepo will help ghcjs-boot quite a bit
03:00:57 <lyxia> kuribas: without Binary
03:01:12 <kuribas> lyxia: so I use Binary only for the subtables?
03:01:20 <hvr> mgsloan: how so? ideally ghcjs-boot wouldn't require any Git access
03:01:26 <kuribas> lyxia: Or is there anything better?
03:01:27 <lyxia> kuribas: what subtables?
03:01:40 <kuribas> lyxia: sorry, truetype subtables.
03:01:43 <mgsloan> Then again, maybe the idea of ghcjs-boot is to allow the kind of flexibility that megarepo / submodules would reduce 
03:02:01 <mgsloan> Ohh sorry, I am thinking of the sdist scripts in ghcjs
03:02:10 <mgsloan> It is a related problem
03:02:11 <lyxia> kuribas: I'm not sure what that is or how it is related to calculating a checksum.
03:02:25 <luite> ghcjs-boot --dev is a bit of a hack i suppose :)
03:02:39 <mgsloan> hvr: We could dive into it, but it's been months if not nearly a year since I've messed with this part of ghcjs
03:03:24 <kuribas> lyxia: well, basicly I need to write a Truetype subtable, then calculate the checksum, as writting in the Truetype Spec.
03:03:41 <kuribas> I need to read back what I wrote...
03:04:12 <lyxia> kuribas: Ah I see.
03:04:58 <kuribas> Or not use Binary at all...
03:06:38 <lpaste> x1n4u pasted Megaparsec build error at http://lpaste.net/4630246509143654400
03:07:16 <x1n4u> I can't build megaparsec 5.1.1 for stache 0.1.7
03:07:43 <x1n4u> i set up a cabal sandbox and tryed to install megaparsec
03:08:15 <x1n4u> is someone else having the same issues
03:08:23 <lyxia> kuribas: The simplest way I can think of is just to write everything and then compute the checksum.
03:09:21 <kuribas> lyxia: right, and then put it again in the Put Monad...
03:10:39 <kuribas> That should work, thanks.
03:11:17 <lyxia> kuribas: If you have stricter memory requirements, a more streamlined way is to run your own monad, where every byte goes through your hash function as you write it.
03:13:28 <kuribas> wouldn't lazyness take care of memory?
03:15:02 <tsahyt> Can someone help me with this? http://lpaste.net/6895397683935051776
03:15:21 <tsahyt> for some reason I cannot generate the singletons for the Ord instance
03:15:34 <tsahyt> The Eq instance works fine
03:15:35 <kuribas> Of course if I "Put" a bytestring, then next time it writes a bytestring, it will have that in memory twice.
03:15:50 <tsahyt> I get the same result when using the singletons TH function
03:16:39 <lyxia> kuribas: Hmm. I guess that may somewhat work if you don't reuse the bytestring that you compute the checksum on.
03:17:59 <puregreen> x1n4u: I shared your build log with the author of stache (and, incidentally, megaparsec too). For now, try compiling with megaparsec-5.0.1
03:18:12 <tsahyt> It also works when I try to merely promote the Ord instance rather than generating singletons
03:18:13 <kuribas> Or I reuse the inner bytestring (containing most of the font data), and discard the outer ones, so they get garbage collected.
03:18:58 <kuribas> Does bytestring have stream fusion, to elimitate intermediate data?
03:19:26 <lyxia> I have no idea
03:20:26 <lyxia> kuribas: it seems not https://github.com/haskell/bytestring/issues/81
03:20:44 <kuribas> :-(
03:21:22 <kuribas> Anyway garbage collection would take care of memory (hopefully), at the cost of some performance.
03:22:52 <kuribas> It's not a bottleneck so it's fine.
03:24:33 <kuribas> "A key feature of lazy ByteStrings is the means to manipulate large or unbounded streams of data without requiring the entire sequence to be resident in memory. To take advantage of this you have to write your functions in a lazy streaming style, e.g. classic pipeline composition."
03:24:56 <kuribas> like writing to a file directly?
03:26:33 <lyxia> No, that would defeat the point of having such a datatype.
03:28:00 * hackagebot monky 2.1.0.0 - A system state collecting library and application  https://hackage.haskell.org/package/monky-2.1.0.0 (ongyerth)
03:28:02 * hackagebot jsaddle-dom 0.4.0.1 - DOM library that uses jsaddle to support both GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-dom-0.4.0.1 (HamishMackenzie)
03:30:23 <kuribas> lyxia: I assume putByteString would simply stream the bytestring if possible.
03:31:00 <unit73e> Hey. How do I combine Just a using (>>=) ? I just need an example.
03:31:08 <lyxia> kuribas: putLazyByteString would
03:31:30 <lyxia> kuribas: there's not much putByteString can do with a strict bytestring.
03:32:16 <lyxia> > Just 14 >>= \x -> if x == 14 then Just (x + 28 :: Int) else Nothing
03:32:19 <lambdabot>  Just 42
03:32:30 <unit73e> Thanks
03:32:47 <unit73e> Ok I get it now. Thanks.
03:32:55 <lyxia> yw
03:33:21 <kuribas> > (+28) <$> Just 14
03:33:23 <lambdabot>  Just 42
03:33:44 <Gurkenglas> > (+28) <$> mfilter (==14) (Just 14)
03:33:47 <lambdabot>  Just 42
03:34:14 <ongy> :t mfilter
03:34:16 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
03:34:17 <lyxia> :)
03:34:31 <kuribas> Gurkenglas: right :)
03:35:37 <kuribas> lyxia: If I put my bytestring in a variable for reuse, don't I need a strict bytestring?
03:36:06 <kuribas> (If that's possible, it seems Put always outputs a lazy bytestring)
03:36:37 <unit73e> Hum I didn't get to <$> yet but seems nice. I'll get there. It's the applicative something right?
03:37:01 <lyxia> I don't see why that would be. Yes, the binary package works with lazy bytestring, there is cereal which provides the same API with strict ones.
03:37:01 <kuribas> unit73e: <$> is fmap
03:38:15 <unit73e> Ok thanks. Seems simple enough.
03:39:00 <kuribas> lyxia: the inner one should be strict, the outer one lazy, but that probably doesn't make any sense...
03:39:06 <kuribas> I'll stick with lazy.
03:40:19 <tsahyt> when using singleton to write fancy constraints, I end up writing something like (BooleanConstraint) ~ True. when the constraint is violated, GHC only tells me that it couldn't match False with True, which is very uninformative. is there a better way to do it?
03:42:38 <hpc> if you get the right line number it shouldn't be that much of a problem
03:43:29 <tsahyt> at least it does tell me "arising from a use of ..." so I can tell which constraint was violated
03:45:21 <kuribas> unit73e: http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor.html#v:-60--36--62-
04:15:44 <nathyong> so STG is supposed to be tagless with a uniform representation
04:16:12 <nathyong> but the representation of closures in the GHC has a field representing the kind of closure it is (whether it is partially applied, whether it is a function, etc)
04:16:45 <nathyong> is this a contradiction, or is the version implemented in the GHC just more up-to-date?
04:19:00 <Kuros-> If i run some expression in ghci that contains some readLn expression deep within it, and ghci complains "no instance for Show .." without ever giving a prompt for the readLn, it's because of lazy evaluation I suppose? It spots the error before the inner readLn expression is evaluated
04:21:46 <pavonia> Kuros-: No, it has nothing to do with laziness, probably a defaulting issue
04:22:08 <liste> Kuros-: no, the "no instance" is a type error, so it's resolved before the code is even executed
04:22:24 <m1dnight_> I have a monadic parser and lexer in Haskell which works, but now Im lost on how I can tokenize only for debugging purposes.
04:22:28 <Kuros-> ah ok
04:22:32 <m1dnight_> Ive been using alex and happy.
04:30:40 <Saizan> nathyong: stg evolved over time, i heard that it's no longer spineless nor tagless, but i don't know the details
04:31:29 <nathyong> hmm, okay
04:31:36 <nathyong> I guess that's the price you pay for performance
04:32:56 <Maxdamantus> Kuros-: note that basically all type errors in Haskell are static.
04:33:27 <Maxdamantus> it's not like Java or something where you can end up with ClassCastExceptions or ArrayStoreExceptions.
04:43:01 <m1dnight_> Okay, I've gotten to the point it returns a single token. But it doesn't show the entire stream.
04:43:14 <m1dnight_> Now I get this: *Parser> runAlex  "+ 5 5" alexMonadScan ==> Right (TokenPlus {position = AlexPn 0 1 1})
05:04:20 <m1dnight_> So Im kind of figuring out how I can make it show all the token.s
05:04:40 <m1dnight_> WHen I look at the Lexer.hs (generated) I don't spot any functinos that return [Token] or m [Token] or anything.
05:08:02 <pavonia> m1dnight_: IIRC, the lexer is in continuation passing style, so you probably have to fold the input stream with the "get next token" function or so
05:09:28 <kuribas> does binary have any error reporting facilities?
05:11:30 <kuribas> hm, fail seems to work.
05:13:30 <m1dnight_> pavonia: Valid point. I found a spot where I can put "trace (show token) $ cont"
05:13:31 <m1dnight_> That fixed it
05:13:40 <m1dnight_> It's nt great, but it's enough for debugging. Thanks for answering!
05:28:02 * hackagebot yesod-bin 1.4.18.6 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.18.6 (MichaelSnoyman)
05:28:19 <ocramz> hullo
05:29:12 <ocramz> has anyone here used `network-transport-inmemory` ? I'd like to simulate a cluster as a set of local processes, is it possible with this?
05:58:55 <agocorona> you can simulate it using normal sockets
05:59:04 <agocorona> more realistically
06:02:35 <agocorona> by having various 'accept' in different threads and sending messages against them in another thread
06:05:21 <qwer483> help
06:06:37 <stevenxl> Hi folks. I thought I had `foldr` down, but apparently that's not the case. I'm looking at the following expression: `foldr (/) 1 [2, 4, 8]`, and that evaluates to 4.0. My understanding of `foldr` is that it iterates on the list starting from the right, and that the combining function accepts the element of the list, then the accumulator. If that's the case,
06:06:37 <stevenxl> wouldn't the accumulator's value proceed as follows ( 8 / 1 = 8), (8 / 4 = 2), (2 / 2 = 1).
06:07:24 <opqdonut> :t foldr
06:07:25 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
06:07:45 <opqdonut> for lists that looks like (a -> b -> b) -> b -> [a] -> b
06:08:06 <cocreature> > 2 / (4 / (8 / 1))
06:08:07 <opqdonut> which means that the _first_ argument to your accumulator comes from the list, and the second one comes from the state
06:08:09 <lambdabot>  4.0
06:08:10 <cocreature> ^ stevenxl 
06:08:35 <opqdonut> so it works like 8/1 = 8, 4/8 = 0.5, 2/0.5=4
06:09:27 <stevenxl> Ah I see. 
06:09:52 <opqdonut> as cocreature demonstrated, the structure of the expression corresponds to the structure of the list
06:09:55 <stevenxl> Thank you!
06:10:12 <cocreature> yw
06:10:20 <opqdonut> we go from 2 : (4 : (8 : [])) to 2 / (4 / (8 / 1)), i.e. replace : with / and [] with the initial value 1
06:10:33 <stevenxl> Yea I just started confusing the accumulator with the element from the list after the first time around. 
06:47:44 <kuribas> is it possible to hide instances from a datatype?
06:48:36 <merijn> kuribas: No
06:48:50 <muesli4> kuribas: only if you don't import the file with the instances
06:49:12 <merijn> kuribas: That's no guarantee
06:49:17 <merijn> eh
06:49:21 <merijn> s/kuribas/muesli4
06:49:35 <kuribas> There are internal to my library, and shouldn't be used.
06:52:55 <dmiles> has anyone use eclipsefp?  i am trying to figure out which eclipse version might work
06:53:17 <dmiles> 3.7 didnt now i am trying 4.2 the problem is a classcastexection
06:53:32 <dmiles> when creatign the editor
06:54:02 <dmiles> here is the installdoc i am using http://eclipsefp.github.io/install.html#extra
06:54:29 <dmiles> Plug-in net.sf.eclipsefp.haskell.ui was unable to load class net.sf.eclipsefp.haskell.ui.internal.editors.haskell.HaskellEditor.
07:01:37 <cocreature> kuribas: make a newtype and dont expose that newtype
07:02:18 <kuribas> ugh, I have many such types...
07:03:29 <cocreature> the alternative solution is to avoid the instance and just explicitely pass a dictionary or something like that. but that doesnt work if you need the instance to interoperate with some thirdparty lib
07:04:38 <kuribas> yeah, newtype would be the best solution
07:09:31 <kuribas> cocreature: I'll use MyDatatypeIntern, then define the typeclasses on them.
07:09:35 <kuribas> thanks
07:09:46 <Xnuk> @hoogle a -> (a -> m a) -> [m a]
07:09:47 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
07:09:47 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
07:09:47 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
07:10:27 <Xnuk> @hoogle Monad m => a -> (a -> m a) -> [m a]
07:10:28 <lambdabot> Control.Monad.HT chain :: Monad m => [a -> m a] -> (a -> m a)
07:10:28 <lambdabot> Control.Monad.Loops concatM :: Monad m => [a -> m a] -> (a -> m a)
07:10:28 <lambdabot> Control.Monad.Extra iterateM :: Monad m => (a -> m a) -> a -> m [a]
07:12:01 <Xnuk> nice
07:25:07 <Insanity_> Is there a native way in Haskell to make a webrequest to retrieve some JSON?
07:25:13 <Insanity_> Or will I need an external library
07:28:05 * hackagebot constrained-categories 0.3.0.1 - Constrained clones of the category-theory type classes, using ConstraintKinds.  https://hackage.haskell.org/package/constrained-categories-0.3.0.1 (leftaroundabout)
07:28:06 <maerwald> there's nothing json-like baked into the language
07:29:31 <c_wraith> Insanity_: there isn't even anything network-like baked into the language.
07:29:40 <c_wraith> Insanity_: however, the wreq library is for exactly that
07:29:44 <c_wraith> @hackage wreq
07:29:44 <lambdabot> http://hackage.haskell.org/package/wreq
07:29:54 <Insanity_> Yeah I found the library :-) was wondering if there was a native replacement
07:29:59 <Insanity_> Thanks maerwald / c_wraith
07:30:07 <Insanity_> I'm assuming to parse the JSON I'll use a library as well
07:30:21 <Insanity_> json/xml, both supported by the rest-service. So whichever is best supported in Haskell?
07:30:34 <c_wraith> I'm pretty sure wreq supports "fetch as json"
07:31:55 <c_wraith> Well, not directly.  But it has a function to convert from its response body format to JSON
07:32:06 <Insanity_> Sounds great, thanks! :-)
07:34:10 <seanhess> I need to build some XML from data types so I can call an API. Is there a library that does this like Blaze or Lucid, but for XML (arbitrary node names / document header)?
07:34:23 <seanhess> Or if that's a bad idea, I'd love to hear what's better. 
07:39:21 <Insanity_> I'll make a perhaps stupid comment here. Are lenses like a "search"? 
07:39:56 <Insanity_> I see this in their documentation for wreq :  r ^. responseStatus . statusCode 
07:40:03 <seanhess> No, not like a search
07:40:10 <Insanity_> Which, if I get it correctly, gets the statusCode out of the responseStatus
07:40:11 <seanhess> that's like r.responseStatus.statusCode in java
07:40:15 <seanhess> yeah
07:40:24 <Insanity_> Search might have been poorly worded by my part
07:41:04 <seanhess> if you mean deep/nested getters and setters, then yes
07:41:23 <Insanity_> I didn't know how to word it, but you wording it like that makes it more clear to me :-)
07:41:35 <Insanity_> And it can be arbitrarily deep?
07:41:44 <seanhess> sure
07:42:03 <Insanity_> Thanks!
07:42:07 <seanhess> no problem!
07:44:26 <Insanity_> Just found out lenses have their own irc channel even. They're pretty important I'm assuming?
07:44:35 <Insanity_> I'm still very much a beginner w/ Haskell
07:44:54 <shapr> Insanity_: you don't need them right away, but lenses are very useful
07:45:16 <seanhess> Yeah, you might want to code without them for a bit. But yes, they are widely used because Haskell's built in records are pretty weak
07:45:46 <tdammers> judgment call, really
07:46:05 <tdammers> lenses mostly fix haskell's records, but you pay a price
07:46:08 <Insanity_> I see, I'll get to them eventually in the book that I'm reading I assume :)
07:46:22 <tdammers> heavy dependency, using TH, bit of a learning curve, longer compile times
07:46:34 <tdammers> crazy types, too
07:50:06 <adnelson> hey guys, how can I pass in a cpp-option which is determined by an environment variable? Basically I want to inspect an environment variable and based on whether it's present, set a CPP flag
07:53:51 <c_wraith> Strange, I think of records almost never when talking about lenses.
07:54:14 <c_wraith> I think of lenses as a uniform data-manipulation toolkit.  Sure, they can do record access, but that's just the tiniest part.
07:55:14 <c_wraith> I don't know of any record access scheme that lets you modify every element of a structure matching particular locations in the structure in a single pass. :)
08:04:10 <puregreen> how can I extract a Word64 from a certain position of a ByteString?
08:05:23 <c_wraith> puregreen: I guess you could do something with binary, if it happens to use the same byte order as you intend..
08:06:25 <lyxia> binary has both a big-endian and a little-endian decoder
08:07:01 <c_wraith> I just was looking at that.  Yes it does.  But if you're using it just for one word64, that's a lot of mental overhead in setting it up.
08:07:17 <c_wraith> I'd look at using binary to parse the whole stream, not just one Word64
08:07:18 <c_wraith> :)
08:07:39 <puregreen> yeah, I need to break a n*8-byte BS into n words
08:08:08 <c_wraith> Oh.  That's as easy as replicateM n getWord64endianness
08:08:20 <c_wraith> If you want them in a list, anyway
08:16:00 <Fairy> Does anyone happen to have working example of a program written in Haskell? Something preferably "simple" but also complete?
08:17:10 <srhb> Fairy: ie. not Hello World?
08:17:23 <srhb> And not Pandoc either?
08:17:43 <Fairy> srhb: correct
08:17:46 <glguy> I've got an irc client you can look at
08:18:23 <Fairy> glguy: I'd love to
08:18:50 <glguy> ?hackage glirc
08:18:50 <lambdabot> http://hackage.haskell.org/package/glirc
08:20:04 <puregreen> Fairy: if you want something quite a bit simpler than an IRC client then I've got a tic-tac-toe game, a maze-drawing program, and a command-line JSONPath implementation: https://github.com/neongreen/haskell-ex
08:20:31 <Fairy> puregreen: ooo, that's probably even better :D
08:21:20 <puregreen> (there are no comments but there are explanations of how the programs work in Slack, PM me if you want to get access to said Slack)
08:22:33 <SrPx> Is anyone aware of any university or anything around here in Brazil with a professor who could help me understanding some type-theory papers? It is really hard to do it all by myself counting only on occasional S.O. questions :(
08:22:34 <Forlorn> Hi, what's the difference between: f :: (a->b) -> a; and g :: a-> b -> a; ?
08:23:10 <SrPx> Forlorn: The former is a function of one argument which receives a function from "a" to "b" and returns "a". The second is a function of two arguments which returns the first.
08:23:17 <c_wraith> Forlorn: the latter is g :: a -> (b -> a)
08:23:30 <SrPx> Forlorn: which returns a value with the first type*
08:23:33 <lush> Fairy: I've got a really simple Parser Library (to build parsers) and a simple program that draws some crazy fractal-ish stuff if you want to look into that.. I'm not a Pro haskel programmer though
08:24:00 <Forlorn> SrPx, c_wraith thank you.
08:24:03 <SrPx> Actually it does return the first element, that is the only thing it can do, right?
08:25:33 <SrPx> Also the first function is not inhabited, right?
08:26:01 <Forlorn> I am confused now.
08:26:53 <Forlorn> How would I define a definition of the former function?
08:27:05 <Forlorn> s/of/for/
08:27:32 <c_wraith> Forlorn: you wouldn't.  as SrPx points out, no (valid) function can have that type
08:27:42 <ggVGc> how can I add a type class constraint to a data declaration?
08:27:44 <Forlorn> Yeah, I noticed
08:27:47 <Forlorn> what about
08:27:52 <c_wraith> Forlorn: But you can easily write a function with a type like (Int -> String) -> Int
08:27:55 <ggVGc> I want a Foo a, where Monoid a
08:27:58 <Forlorn> the signature f :: (a->b)->b.
08:28:06 * hackagebot syntactic 3.6.2 - Generic representation and manipulation of abstract syntax  https://hackage.haskell.org/package/syntactic-3.6.2 (EmilAxelsson)
08:28:27 <Forlorn> c_wraith, is that not possible?
08:28:30 <c_wraith> Forlorn: that also has no (non-bottom, a technical term for what I called invalid) inhabitants
08:28:50 <monochrom> ggVGc: It's best to drop that idea and add the constraints to the relevant functions instead.
08:29:29 <ggVGc> haha
08:29:33 <ggVGc> I was starting to understand that
08:29:39 <ggVGc> monochrom: seems GADTs are the way otherwise?
08:29:55 <monochrom> Yes GADTs can do it, but that's a sledgehammer.
08:30:00 <ggVGc> yep
08:30:03 <ggVGc> thanks
08:30:06 <c_wraith> Forlorn: it's kind of like playing with legos.  "I have these pieces, how can I fit them together?"
08:31:32 <ggVGc> monochrom: going with a comment at the data declaration
08:31:41 <ggVGc> and constraints on functions dealing with it
08:31:43 <ggVGc> should be good enough
08:31:54 <monochrom> yeah. it's how Data.Map does it, for example
08:34:07 <Forlorn> c_wraith, my bad, I tried to simplify a problem and did it incorrectly.
08:34:10 <clever> i'm a bit rusty with haskell, what did i do wrong? http://pastebin.com/rnrezFwT
08:34:26 <Forlorn> c_wraith, this was one of the original problems, which only had one definition, let f :: (b -> c) -> (a -> b) -> (a -> c); f x y = x . y
08:34:53 <Forlorn> I suppose that's the only definition for the signature of f.
08:36:26 <fr33domlover> ongy, maybe i confused it with what the time package does? but it uses Data.Time so my point is valid: it just uses those format strings beind the scenes
08:36:56 <fr33domlover> i meant do what formatting does without going through that format string stuff
08:37:33 <fr33domlover> (which is rare anyway in a language like Haskell, where things tend to be type safe and static when possible)
08:41:59 <clever>     The last statement in a 'do' block must be an expression
08:42:02 <clever>       arcaneChat <- executable toolchain "_build/arcane-chat" qtCore cs
08:42:12 <clever> https://hackage.haskell.org/package/shake-language-c-0.10.0/docs/src/Development-Shake-Language-C-Rules.html#executable
08:43:05 <clever> i'm sure i'm doing something stupid, but i cant see what
08:45:34 <ggVGc> are people using OverloadedRecordFields?
08:47:04 <monochrom> clever: delete "arcane <- "
08:47:19 <bitemyapp> ggVGc: Haven't seen it yet.
08:47:30 <bitemyapp> ggVGc: most people I know that wanted such badly, used classy lenses.
08:47:47 <clever>     arcaneChat <- executable toolchain "_build/arcane-chat" qtCore cs
08:47:58 <clever> monochrom: i got it to compile with this and no type signature
08:48:30 <monochrom> OK, so problem solved?
08:48:34 <clever> yeah
08:49:12 <clever> next issue is to append some BuildFlags, but i need to read the docs more
08:49:29 <ggVGc> bitemyapp: as in using 'makeFields' from Lens?
08:50:22 <ggVGc> ah, makeClassy takes only an underscore
08:50:25 <ggVGc> cool, I'll use that
08:54:19 <Forlorn> What is a principal type?
08:55:08 <ongy> fr33domlover: that's done purely in haskell. I don't like it much, but it's pure, jay
08:55:45 <ggVGc> how can I get around this? https://gist.github.com/1904be17e1d12e09c9b5a9b7dede8016
08:56:00 <clever> monochrom: and stupid mistake #2, http://pastebin.com/rtrahk7S
08:56:15 <clever> monochrom: it appears to be complaining that foo != foo
08:57:18 <clever> monochrom: both qtcore and qtwidgets are of type Action (BuildFlags -> BuildFlags)
08:58:50 <monochrom> ggVGc: I think the error message says that you need MultiParamTypeClasses
08:59:25 <drdo> Forlorn: The principal type of a term is a type such that any other type of such term is a substitution instance of the principal type
08:59:40 <geekosaur> right, and the reason is that the Has... typeclass it generates has a parameter already, so applying it to a parameterized type produces an MPTC
08:59:45 <ggVGc> monochrom: yeah, but then I need FunctionalDependencies, and then it doesn't work anywya, so I figured I was on the wrong path
09:00:47 <monochrom> ah, then I don't know
09:02:58 <clever> monochrom: any idea?
09:03:01 <drninjabatman> hello
09:03:45 <drninjabatman> is there a nice way to do case splitting in haskell-mode like the have in idris-mode and agda2-mode ?
09:04:44 <ggVGc> monochrom: ah, I needed all of these :) https://gist.github.com/202faea8ee9ca3cb43b9d12356818946
09:04:53 <ggVGc> turns out there's some serious type juggling in Lens
09:05:01 <ggVGc> I don't undertand either of these pragmas
09:05:02 <ggVGc> :(
09:05:11 <ggVGc> except TemplateHaskell
09:05:50 <monochrom> The GHC user's guide is a pretty good guide on them.
09:07:00 <ggVGc> yeah, some day I'll dig in
09:07:03 <leshow> hey guys, im ive been staring at this for 10 mins and cant figure out what's wrong with it
09:07:06 <leshow> go ""     = 0
09:07:07 <leshow> go (x:xs) = (if x `elem` "aeiou" then 1 else 0) + (go xs)
09:07:32 <ggVGc> leshow: what's the problem?
09:07:34 <leshow> "could not deduce Foldable t0 arising from a use of elem,
09:07:41 <leshow> i cant figure out what wrong with my function
09:07:49 <ggVGc> leshow: where's your type sig
09:07:58 <leshow> i left it inferred
09:08:02 <ggVGc> try to add it
09:08:17 <leshow> go :: String -> Int
09:08:20 <leshow> doesnt change anything
09:09:13 <leshow> "ambiguous type variable t0 arising from literal "aeiou" prevents the contraint Data.String.IsString from being solved"
09:09:21 <leshow> it's a simple function i dont understand whats going on
09:09:26 <monochrom> works for me. cannot reproduce. your problem is elsewhere
09:09:36 <ggVGc> leshow: what pragmas do you have?
09:09:45 <leshow> OverloadedStrings is on
09:09:46 <ggVGc> leshow: are you using overloadedstrings?
09:09:47 <ggVGc> right
09:09:56 <ggVGc> there you have it
09:09:58 <leshow> what's wrong with that though?
09:10:12 <monochrom> it breaks your code. that's what's wrong.
09:10:19 <Xnuk> x `elem` ("aeiou" :: String)
09:10:22 <ggVGc> leshow: whatever your "aeiou" is being turned into isn't foldable
09:10:23 <ggVGc> it seems
09:10:49 <ggVGc> leshow: why are you using overloadedstrings?
09:10:55 <monochrom> no, it's worse than that. it doesn't know that you want "aeiou" to be String. it doesn't know what it is.
09:11:07 <leshow> that's weird
09:11:17 <ggVGc> it's not werid at all
09:11:19 <ggVGc> imo
09:11:28 <monochrom> Do you actually know what is OverloadedStrings?
09:11:31 <ggVGc> that's basically what OverloadedStrings says
09:11:38 <ggVGc> thta strings are no longer strings
09:11:42 <ggVGc> so the compiler needs more info
09:11:44 <ggVGc> to know
09:11:44 <ertes> does anyone have an idea how to test for memory leaks as part of a test suite?  not the kind of leak that just crashes your program, but the kind that builds up over time in an otherwise responsive program
09:11:50 <leshow> allows you to use Text and String interchangeably without packing and unpacking explicitly
09:11:56 <monochrom> No.
09:11:56 <ggVGc> that's not really it
09:12:39 <ggVGc> leshow: with overloaded strings I could make "hello" turn into Foo (SomeDataType DataHello)
09:12:47 <monochrom> If your idea were true, you would be able to compile this: f :: Text -> String; f x = x
09:13:26 <monochrom> But that f won't compile. Therefore your idea is refuted.
09:13:28 <geekosaur> it's just ike with numbers: OverloadedStrings makes string *literals* polymorphic. It doesn't affect non-literals
09:13:45 <leshow> my idea? it's a guess at what the function of it is
09:13:53 <nshepperd1> It just means your string literals are IsString a => a
09:14:02 <monochrom> Yes, you should always test your guesses.
09:14:15 <ggVGc> leshow: right, well, the misunderstanding of ovelroadedstrings is why you feel this compiler error is strange. Anyway, unless you have a specific need for it, turn it off
09:14:20 <ggVGc> and you won't have an issue
09:14:26 <ggVGc> or add a type specification to your literal
09:14:30 <ggVGc> since you want it to be a string
09:14:41 <leshow> im writing code to do exercises from a book, its not like im just turning pragmas on in produciton and crossing my fingers
09:14:47 <leshow> but thanks anyway
09:15:05 <nshepperd1> It should probably come with a defaulting with String to handle traversals and such...
09:15:14 <ertes> i had the following idea:  establish a notion of "size" (like number of iterations), then run a piece of code with arguments of different "sizes" and record the heap usage  finally attempt to run a straight line through the usage graph  if that attempt succeeds with reasonable error, conclude that there is no memory leak
09:15:25 <monochrom> well then turn it off.
09:15:51 <ggVGc> leshow: making string literals into Text instances is the most common use of OverloadedStrings, but the concept is much more powerful. You can turn string literals into anything with OverloadedStrings if you write the right instance implementations
09:15:52 <leshow> monochrom, i need it for elsewhere ill just pass the type
09:17:28 <dolio> Using linear memory instead of constant might be a space leak, but both are straight lines.
09:17:44 <dolio> Also using log memory isn't a straight line, but linear is.
09:17:59 <clever> monochrom: any clue why using the example just doesnt compile!? http://pastebin.com/KRU13pqZ
09:18:35 <leshow> ggVGc, what kind of instances that dont make sense could you hypothetically write for string/text
09:18:42 <bollu> if I have a library
09:18:50 <bollu> can I package examples along with the library?
09:18:54 <bollu> when I publish to hackage?
09:19:02 <bollu> and also allow the examples to be runnable?
09:20:14 <leshow> and why did it not infer it's a string type in that line, but seemed capable of doing it elsewhere
09:20:45 <monochrom> with type class polymorphism like this, inference is highly dependent of context.
09:20:46 <ggVGc> leshow: define "don't make sense". OverloadedStrings is useful for DSLs
09:22:16 <leshow> i thought you meant you could define instances of strings which were incorrect in some way with the pragma on
09:22:17 <ggVGc> leshow: for example, if I want to define IP ranges or addresses using a small DSL, I could make "192.168.0.*" become an (IPRangeAll "192.168.0") and "8.8.8.8" become (IPEndpoint "8.8.8.8")
09:23:23 <ggVGc> leshow: you can also use it to implement compile time checked printf-style things
09:23:26 <ggVGc> afaik
09:23:50 <ggVGc> maybe I'm wrong about that
09:23:53 <ggVGc> someone else should clarify
09:23:55 <ertes> dolio: uh, yeah  i actually meant: run a straight line, then see if it's constant
09:25:11 <ertes> dolio: i'm planning to write a test framework for that now, and instead of enforcing a certain memory behaviour as "correct", i'll allow the user to specify the expected memory behaviour (constant, linear, etc.)
09:25:11 <nshepperd1> I don't think compile time. It's just a function String -> a
09:25:15 <ggVGc> wyeah
09:25:17 <ggVGc> I just thought about it
09:28:08 * hackagebot modbus-tcp 0.2.1 - Communicate with Modbus devices over TCP  https://hackage.haskell.org/package/modbus-tcp-0.2.1 (RoelVanDijk)
09:33:52 <MarcelineVQ> leshow: it doesn't infer what you expect because your test of x `elem` "aeiou" doesn't gurantee a "aeiou" is [Char] despite x being Char. "aeiou" could be something else like Just Char if such an instance of IsString existed, elem only requires that the 2nd argument has a Foldable instance
09:35:38 <MarcelineVQ> pardon me I mean it could be an instance of Maybe Char if one existed
09:36:04 <leshow> ok that makes sense
09:36:33 <MarcelineVQ> example of a silly Maybe instance if you wanted to play around: instance IsString (Maybe Char) where fromString = fmap fst . uncons
09:36:57 <leshow> ill have to look up uncons lol
09:37:15 <leshow> oh i see, the opposite of :?
09:37:31 <MarcelineVQ> It's (x:xs) for a possibly emply list, where an empty list is Nothing
09:37:45 <MarcelineVQ> > uncons "hello"
09:37:47 <lambdabot>  Just ('h',"ello")
09:37:48 <MarcelineVQ> > uncons ""
09:37:50 <lambdabot>  Nothing
09:38:13 <leshow> is it possible to recursively add different parts of a tuple
09:38:16 <leshow> i have this
09:38:18 <leshow> countVC :: String -> (Int,Int)
09:38:18 <leshow> countVC "" = (0, 0)
09:38:18 <leshow> countVC (x:xs) = (v + (fst countVC xs), c + (snd countVC xs))
09:38:18 <leshow>     where
09:38:20 <leshow>         (v,c) = if x `elem` vowels then (1,0) else (0,1)
09:39:50 <conal> leshow: use sum with uniform pairs instead
09:40:00 <leshow> oh i get it, i need fst $ countVC
09:40:12 <leshow> conal: no idea what a uniform pair is
09:40:14 <conal> leshow: or sum with trees if you want recursive addition
09:40:36 <conal> leshow: data Pair a = Pair a a deriving (Functor, ...)
09:40:48 <conal> leshow: https://hackage.haskell.org/package/uniform-pair
09:41:06 <ski>   countVC (x:xs)
09:41:09 <leshow> lol you wrote this?
09:41:12 <ski>     | x `elem` vowels = (v+1,c  )
09:41:18 <ski>     | otherwise       = (v  ,c+1)
09:41:23 <ski>       where
09:41:25 <ski>       (v,c) = countVC xs
09:41:27 <conal> leshow: yes. 
09:42:41 <leshow> f ~(a :# b)
09:42:41 <conal> leshow: i've often found that my code simplifies and generalizes with i replace (a,a) by Pair a.
09:42:44 <leshow> what does the tilde do
09:42:50 <conal> leshow: lazy matching
09:42:50 <ski> lazy pattern
09:43:02 <leshow> isnt everything lazy by default
09:43:02 <ski> delays pattern-matching until a variable bound by it is forced
09:43:11 <conal> leshow: it matches without having to force any evaluation
09:43:17 <leshow> oh, you get better performance out of that?
09:43:18 <conal> leshow: not everything
09:43:28 <conal> leshow: more importantly, i get termination
09:43:58 <conal> leshow: ... in some recursive contexts that wouldn't terminate with eager (default) matching
09:43:59 <ski> if you match on `~(x:xs)', it's succeed immediately, even if you have an empty list. then it'll fail later, when `x' or `xs' is forced (possibly after the current function has returned long ago)
09:44:43 <leshow> hlint wants me to turn ((v + (fst $ countVC xs, ... into ((+) v *** (+) c)(countVC xs)
09:44:46 <leshow> from control.arrow
09:44:55 <leshow> never seen any of that before
09:45:05 <ski> lazy pattern is mostly used with tying-the-knot, and avoiding doing some heavy computation now, which might not be needed (so can improve space behaviour)
09:45:29 * ski was thinking about showing `(***)' above, but decided against it
09:46:04 <leshow> i dont understand what it's doing
09:46:36 <conal> with uniform pairs, i know that a pair will match a :# b, assuming it's not bottom, but sometimes forcing early leads to non-termination where a lazy pattern allows for termination. it's a pretty esoteric situation. you can ignore the ~ in a first reading.
09:46:54 <leshow> conal, cool
09:46:56 <ertes> does 'performGC' perform a *full* GC in the sense that it's a (more or less) idempotent operation?
09:47:10 <ertes> (from System.Mem)
09:47:13 <ski> @src (->) (***)
09:47:13 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
09:48:07 <ski> @wiki Tying the Knot
09:48:07 <lambdabot> https://wiki.haskell.org/Tying_the_Knot
09:48:33 <ski> @src partition
09:48:34 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
09:48:34 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
09:48:34 <lambdabot>                               | otherwise = (ts, x:fs)
09:49:07 <ski> @let partition' p xs = foldr (select p) ([],[]) xs where select p x (ts,fs) | p x       = (x:ts,fs) | otherwise = (ts, x:fs)
09:49:09 <lambdabot>  Defined.
09:49:24 <ski> > (take 4 *** take 4) (partition even [0 ..])
09:49:26 <lambdabot>  ([0,2,4,6],[1,3,5,7])
09:49:28 <ski> > (take 4 *** take 4) (partition' even [0 ..])
09:49:31 <lambdabot>  (*Exception: stack overflow
09:49:41 <ski> leshow : ^ shows one use of it
09:50:00 <maerwald> tying the knot is an antipattern and only ties a knot in your brain for any non-trivial use case
09:50:26 <ski> (elaborate ?)
09:51:02 <leshow> ski, thanks for the examples
09:52:15 <johnw> maerwald: ??
09:52:25 <ski> in your case, using `fst'&`snd' on the recursive call, or calling it in `where', matching on the pair there, will ensure lazy extraction of the two components, so is comparable to the `partition' above
09:53:04 <Cale> Tying the knot is okay -- it takes a bit of getting used to, but it's no worse than the simplest sort of pointer manipulation that people do when implementing data structures in C.
09:53:17 <ski> (.. however, in your case you're incrementing `Int's, which is a strict operation, so in that sense, it's not comparable with `partition'. the point with `partition' was that it returned a (pair of) list(s), and such are lazy)
09:53:22 <Cale> (i.e. the kind which involves no arithmetic on pointers)
09:53:57 <maerwald> Cale: oh it's worse, because it's implicit, may involve very unintuitive recursion techniques and may silently break without you realizing
09:54:13 <nshepperd1> Eh, you just have to remember that it's just an optimisation for read only infinite values
09:54:27 <ski> (.. the point is that we don't want to force all the recursive calls of `partition' (or `foldr') 'til the end (if any), just to see the first few elements of one of the returned two lists. that's what the lazy pattern avoids, in this case)
09:54:48 <maerwald> Cale: for trivial examples it may seem ok though, for anything else, people should avoid it
09:55:57 <maerwald> even the DList example in the wiki is less trivial than it seems at first glance, if you're really trying to understand the knot
09:56:08 <maerwald> and how the thing flows
09:56:18 <Cale> Certainly if you're not terribly concerned about performance, often you can just represent your graph structure using some sort of Map and be fine.
09:56:29 <Cale> and that will give you more flexibility regarding changes to the structure
09:56:31 <maerwald> for something slightly more complicated than a DList, complexity already explodes
09:58:04 * ski was more thinking about passing output from functions back into them, rather than cyclic data structures
10:00:12 * monochrom keeps calm by never saying "tying the knot". It's just recursion.
10:01:12 * ski . o O ( "untying the knot" )
10:04:37 <ggVGc> am I crap for sometimes using pattern matching on Maybe simply because I think it reads nicer syntactically than 'maybe'
10:04:42 <glguy> nope
10:05:00 <redmq> tying the knot referrs to recursive references in datastructures .. since you can only achieve it at binding time, or using mutation, it's generally not used
10:05:14 <monochrom> "maybe" expands to the exact pattern matching you write anyway
10:05:22 <ggVGc> yeah
10:05:36 <ggVGc> but I've seen a lot of people saying "never pattern match on Maybe"
10:05:40 <ggVGc> but sometimes it just reads way better
10:05:53 <maerwald> useless style philosophy, just keep going and be productive :P
10:06:00 <monochrom> I haven't run into such people. but when I do, I ignore them.
10:06:01 <maerwald> until it actually becomes a problem (or not)
10:06:07 <Tuplanolla> We have this magnificent pattern matching mechanism only to avoid using it.
10:06:18 <yulax> i define a function for a factorial
10:06:22 <Cale> ggVGc: Usually whenever I use the 'maybe' function, I end up replacing it with a case expression later.
10:06:32 <yulax> fac n = (fac (n - 1)) * n
10:06:36 <monochrom> pattern matching vs "maybe" should be decided based on mood, not ideology.
10:06:43 <Cale> Indeed
10:06:47 <redmq> hear hear
10:07:03 <yulax> whene i define fac 0 = 0 and fac  1=1
10:07:07 <yulax> all is good
10:07:09 <Cale> and the bias should be in favour of 'maybe' only in cases where you don't think the code will change much
10:07:19 <yulax> fac 3 = 6 in that case
10:07:29 <maerwald> write up an algorithm that decides for you when to use maybe
10:07:30 <yulax> but when i dont define fac 1
10:07:36 <maerwald> make it a hlint plugin
10:07:39 <yulax> fac 3 becomes 720
10:07:45 <yulax> why?
10:07:55 <Cale> yulax: What? It should be 0 then.
10:07:59 <monochrom> no, write up a randomized algorithm
10:08:36 <glguy> yulax: You can put the code in question on http://lpaste.net
10:08:47 <maerwald> or just give up programming, become a brick layer instead. problem solved
10:08:47 <yulax> fac :: Int -> Int
10:08:49 <yulax> fac 0 = 1
10:08:51 <yulax> fac n = (fac (n - 1)) * n
10:09:01 <Cale> ah, okay
10:09:13 <yulax> it is three lines so no point paste
10:09:28 <yulax> it is really strange behaviour
10:09:36 <glguy> yulax: No, still point paste. When you paste the code doesn't scroll off the screen anad people can add annotations
10:09:36 <monochrom> > let { fac 0 = 1; fac n = (fac (n - 1)) * n } in fac 3
10:09:39 <lambdabot>  6
10:09:45 <ggVGc> alright, another one. I'm writing a function that steps through a SeqData instance and generates Maybe values. Currently I have a 'step :: RunnerState -> (Maybe a, RunnerState)'. Would it be better to make it into a lazy 'run :: SeqData -> [Maybe a]'?
10:09:54 <monochrom> works for me. cannot reproduce your observation. your problem is elsewhere.
10:10:37 <yulax> lol
10:10:43 <yulax> i was doing fac 6
10:10:44 <ggVGc> actually, the 'run' would have to be implemented in terms of a 'step' anyway eh
10:11:00 <yulax> this was a really silly thing of me xD
10:11:13 <yulax> and that is the correct behaviour
10:11:45 <Tuplanolla> Now try fac (-1), yulax.
10:13:23 <yulax> Tuplanolla: yea when i forgot to define fac 0 = 1 it behaved the same
10:13:34 <yulax> an endless pit of weirdness
10:13:53 <monochrom> ggVGc: If you don't know which one is used more yet, have both ready. But later you may find that one of them is used more.
10:15:16 <Cale> yulax: Well, it's not weird, it's just fac (-1) = fac (-2) * (-1) = (fac (-3) * (-2)) * (-1) = ...
10:16:08 <ggVGc> monochrom: yeah, I just realised run is a lot more constrained and there will be utility for being able to keep the state of the runner
10:16:12 <Cale> yulax: In order to finish computing the result, (*) needs to evaluate both its arguments, and without the base case, you'll always have another unevaluated expression of the form fac k there.
10:16:16 <ggVGc> so step will be publically needed
10:28:09 * hackagebot hse-cpp 0.2 - Preprocess+parse haskell code  https://hackage.haskell.org/package/hse-cpp-0.2 (DavidHimmelstrup)
10:28:11 * hackagebot haskell-packages 0.5 - Haskell suite library for package management and integration with Cabal  https://hackage.haskell.org/package/haskell-packages-0.5 (DavidHimmelstrup)
10:33:24 <ggVGc> is there a nicer way to write this? https://gist.github.com/60010d2daeb62d1cbcccd1e77ded3a88
10:35:04 <Tuplanolla> You don't need to compose id, ggVGc. Please add spaces around operators too.
10:36:42 <ggVGc> Tuplanolla: why don't I need to compose id?
10:36:53 <mnoonan> :t Just
10:36:54 <lambdabot> a -> Maybe a
10:36:56 <mnoonan> :t Just . id
10:36:57 <ggVGc> oh, haha
10:36:57 <lambdabot> a -> Maybe a
10:36:59 <ggVGc> I'm dumb
10:37:00 <ggVGc> thanks
10:38:21 <ertes> yulax: your original 'fac' implementation still had a bug though:  fac 0 = 0
10:38:37 <ggVGc> think I like this better though,       .(lastVal %~ (mbThisVal & maybe id (const . Just)))
10:43:19 <dmiles> i've been trying for 5 hours now to isntall EclipseFP :(
10:43:20 <vinnie92> :t head
10:43:22 <lambdabot> [a] -> a
10:43:33 <vinnie92> :t map
10:43:35 <lambdabot> (a -> b) -> [a] -> [b]
10:44:12 <Asido> dmiles, try HaskForce for intellij. did today and worked perfectly: https://github.com/carymrobbins/intellij-haskforce
10:44:29 <dmiles> Asido: ok.. will try
10:44:38 <Asido> dmiles, or here http://haskforce.com/
10:44:56 <maerwald> ggVGc: did you just implement <|> in a very weird way?
10:45:00 <monochrom> EclipseFP is out of date IIRC. It may not interwork with current software.
10:45:21 <maerwald> :t maybe id (const . Just)
10:45:21 <maerwald> :t (<|>)
10:45:30 <lambdabot> Alternative f => f a -> f a -> f a
10:45:30 <lambdabot> Maybe a -> Maybe a -> Maybe a
10:45:39 <dmiles> well all the trouble is building  haskell-generate, BuildWrapper and scian-class-browser
10:47:11 <maerwald> yes you did
10:47:32 <glguy> over lastVal (mbThisVal <|>)
10:47:36 <glguy> untangled!
10:48:02 <dmiles> ok will try the Intellij plugin .. after it work i'll see if i can port
10:48:35 <dmiles> ph btw i do have the EcLiseFP working all bu the wrapper to GHC
10:48:53 <dmiles> the cabal editor and things all work
10:49:14 <dmiles> had to use bvery specific old versions of thengs :)
10:51:05 <dmiles> Asido, community verion of Intellij is fine right?
10:53:02 <Asido> dmiles, if you check pro features they have nothing to do with haskell
10:53:05 <dmiles> oh gawn sorry i justr read the description  "Haskell plugin for IntelliJ IDEA Community Edition" :)
10:54:10 <Asido> it works on any though. all jebrains ide's are intellij with different set of plugins bundled
10:57:36 <ggVGc> maerwald: probably, that's why I asked how I could write it better
10:57:43 <ggVGc> maerwald: where is <|> defined?
10:58:08 <ggVGc> oh, sorry, I missed the :t
10:58:09 <ggVGc> thanks
10:58:20 <ggVGc> I've never actuallyt used Alternative
10:59:35 <maerwald> and there I thought you're training for an obfuscation contest :P
10:59:59 <ggVGc> maerwald: I'm just trying to use haskell practically and learn abstractions along the way
11:00:14 <ggVGc> since I won't get anything to stick if I try to learn the abstractions up front
11:00:19 <ggVGc> so.. one type class at a time
11:00:29 <ggVGc> also, I haven't really used the monad intances of almost anything yet
11:00:32 <ggVGc> basically just Maybe
11:01:06 <ggVGc> anyway, thanks, that's the answer I was looking for when I asked about that line
11:01:18 <maerwald> didn't hlint make a suggestion?
11:01:22 <maerwald> or some other tool
11:01:30 <maerwald> I'd guess they should catch such stuff
11:28:10 * hackagebot debian 3.91 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-3.91 (DavidFox)
11:28:12 * hackagebot debian 3.91.1 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-3.91.1 (DavidFox)
11:31:37 <puregreen> x1n4u: can you report the megaparsec issue to its issue tracker?
11:31:52 <puregreen> https://github.com/mrkkrp/megaparsec/issues
11:48:25 <ph88> hi guys, i have this function that does a quickcheck and prints input and output https://paste.fedoraproject.org/445111/14757796/ input and output appear the same but still the quickcheck is failing, i don't know how to debug this any helpz ?
11:49:37 <jle`> ph88: can you paste the result?
11:49:46 <ph88> sure thing !
11:50:36 <ph88> jle`, https://paste.fedoraproject.org/445115/79805147/
11:53:58 <dfeuer> int-e?
11:54:15 <ph88> ?
11:58:16 <mnoonan> co
11:58:37 <puregreen> x1n4u: nevermind, I got told that a fix is coming
12:00:15 <dmwit_> ?unmtl StateT RunnerState Maybe a
12:00:15 <lambdabot> RunnerState -> Maybe (a, RunnerState)
12:00:25 <dmwit_> ?unmtl MaybeT (State RunnerState) a
12:00:25 <lambdabot> RunnerState -> (Maybe a, RunnerState)
12:10:29 <ph88> jle`, could you make something of it ?
12:11:24 <int-e> dfeuer: hmm?
12:13:21 <dfeuer> int-e, I'm just thinking about how to convert your valInteger thing to start combining chunks while still parsing chunks.
12:13:56 <dfeuer> We start with a ReadP Word or something to parse individual digits, then need a Chunk type with Full Integer and Partial Integer Integer (or some such),
12:14:15 <dfeuer> but then I'm not sure how to interleave recursively.
12:14:56 <dfeuer> By the way, I note an uncanny resemblance between your code and Lennart Spitzner's Data.Sequence.fromList. This seems to be a pattern I need to study.
12:21:13 <int-e> dfeuer: combining chunks while parsing sounds quite unpleasant to me... you'd have to maintain an explicit stack of digits in various bases as you accumulate chunks
12:22:27 <dfeuer> int-e, yeah, that was my vague impression. But shouldn't it dispose of temporary structure more quickly?
12:23:39 <dfeuer> Also: I suspect we may want to write very different code for octal, and almost certainly do for hex. Reading hex we can basically just slurp everything up and then (in effect) perform a shift.
12:24:18 <dfeuer> It should be possible to do something similar with octal, but it'll be messier and surely less important in practice (who writes gigantic integers in octal?)
12:26:10 <dfeuer> int-e, if you think the explicit stack won't pay off in performance, I'll respect that judgement. You know better than I.
12:28:11 * hackagebot Files 0.1.0.0 - File content extraction/rearrangement  https://hackage.haskell.org/package/Files-0.1.0.0 (steven_yhw)
12:28:13 * hackagebot Files 0.1.1.0 - File content extraction/rearrangement  https://hackage.haskell.org/package/Files-0.1.1.0 (steven_yhw)
12:28:15 * hackagebot cabal-debian 4.33 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.33 (DavidFox)
12:29:19 <EvanR> just checking, how does this break referential transparency: 
12:32:23 <EvanR> let new be a term which you apply to a type (rep, or something) and you get back "a new arbitrary value of that type, the only thing you know about it is its not the same as any otherresult of new"
12:34:09 <dfeuer> EvanR, i you have     let n = new T in (n, n), ad you inline, you get (new T, new T), which is different.
12:34:21 <dfeuer> No referential transparency.
12:34:43 <dfeuer> new@T, whatever. Doesn't matter. No good.
12:35:16 <EvanR> right
12:35:47 <EvanR> so invoking new is necessarily context sensitive, or referentially opaque, something like that
12:39:39 <int-e> dfeuer: prototyping: http://lpaste.net/245451 ... actually they have comparible speed, which surprises me a bit.
12:40:07 <dfeuer> int-e, which did you expect to be faster?
12:40:55 <dfeuer> Oh, you probably expected the lazy one to be faster processing a list of integers?
12:41:15 <int-e> dfeuer: my mistake may be that I test a single big number rather than many small ones... 
12:41:20 <dfeuer> What's a Skip about?
12:41:56 <dfeuer> Big numbers is what this particular algorithm is all about, so I dunno if that's a mistake.
12:42:16 <dfeuer> Oh, are you representing the base implicitly?
12:42:19 <int-e> dfeuer: it's a placeholder indicating that a certain base (of the sequence b, b^2, b^4, ...) is not currently in the stack
12:43:11 <int-e> dfeuer: big numbers mean that most of the runtime will be spent in libgmp though
12:43:32 <dfeuer> int-e, that surely suggests Skip !Word !Stack, to indicate how many places are skipped, unless that doesn't end up helping.
12:43:39 <dfeuer> Which it may not.
12:43:40 <dfeuer> Whatever.
12:43:46 <dfeuer> I need to read this new fancy code.
12:44:29 <int-e> dfeuer: note that `step` never counts
12:44:59 <int-e> dfeuer: with a counter, the Skip case would have to check the counter that's there, and allocate a new "Skip" if the counter is not zero.
12:45:14 <dfeuer> Ah.... You never turn a Skip to a Skip....
12:45:16 <int-e> err, one.
12:46:10 <int-e> this feels a bit like the spine of a binomial heap, but we're only inserting stuff
12:47:04 * int-e shrugs
12:48:17 <dfeuer> int-e, in fromStack, are you maintaining parallel stacks of bases and digits? Is there a reason not to merge them?
12:48:55 <int-e> dfeuer: I'm memoizing the bases
12:49:23 <dfeuer> To avoid division?
12:49:28 <int-e> dfeuer: note that the same bs is also passed to every "step".
12:49:58 <int-e> dfeuer: to avoid computing b^2 for every second digit, b^4 for every fourth, and so on.
12:50:25 <dfeuer> Ohhhhhhh........ Yeah, that probably does make sense once the bases get big.
12:50:48 <dfeuer> oh wait, no it doesn't.
12:51:16 <dfeuer> I don't think the bases *ever* get big enough to need an Integer.
12:51:30 <dfeuer> Won't you run out of address space first?
12:51:38 <monochrom> :)
12:51:38 <int-e> dfeuer: they get about half as big (in numbers of digits) as the number being parsed
12:51:53 <dfeuer> Oh wait, I'm thinking sideways.
12:51:55 <dfeuer> Ooops.
12:52:16 <dfeuer> Yeah, you're making good sense.
12:52:49 <EvanR> i use base omega
12:52:55 <EvanR> more space efficient
12:53:11 <dfeuer> EvanR, which omega is that?
12:53:25 <EvanR> the order type of the naturals
12:53:54 <dfeuer> More efficient for writing proofs, I'm sure.
12:54:03 <EvanR> you only need 1 digit
12:55:09 <monochrom> this joke can go out of hand very quickly
12:55:24 <dfeuer> EvanR, well, int-e's algorithm (a reimplementation of one currently in `base`) does end up with just one digit in the end.
12:55:28 <EvanR> foul, ball in hand
12:56:04 <monochrom> what is the algorithm for?
12:56:29 <dfeuer> monochrom, the Read instances for Integer and Natural.
12:56:35 <monochrom> ah!
12:57:17 <dfeuer> The usual multiply-add-multiply-add approach gets expensive when the accumulator gets really big.
12:58:05 <dfeuer> monochrom, the previous implementation worked around this, but in a way that had its own very substantial inefficiencies. int-e's take on it has a much more pleasant shape.
12:58:26 <int-e> dfeuer: anyway I expected the explicit stack to be costly but it appears that it operates at about the same speed, perhaps even a bit faster, as the implicit one using pairwise combination on lists.
12:59:05 <dfeuer> int-e, cool! I would venture to guess that it will pull ahead when the list goes away and digits are being parsed one by one, but only testing will tell.
13:02:09 <dfeuer> bgamari, you need a few more little changes to make that thing build. Sorry :/. Everything I called ReadP. should be R., and the ReadP type needs to be qualified R.ReadP. I think.
13:02:26 <dfeuer> Wrong channel.
13:03:23 <monochrom> so you are messing with Read in two channels concurrently :)
13:03:37 <dfeuer> Yes.
13:03:50 <dfeuer> I'm not reading from concurrent channels, however.
13:03:59 <c_wraith> concurrency and mutability always lead to bugs. 
13:05:10 <dfeuer> monochrom, there's a much simpler Read modification (reimplementing `paren`, which is used in `parens`) that should improve performance across an extremely wide swath of Read instances. I asked in #ghc if someone could try actually pushing it, and bgamari very helpfully did so.
13:05:58 <fr33domlover> i haven't written much haskell relatively, but so far, most of my concurrency use is threads communicating via Chan or threads passing some data via MVar, each use it on its turn... and each resource like a socket has a single thread responsible for it
13:07:32 <fr33domlover> so threads don't share mutable anything, just communicate expicitly when needed
13:10:56 <int-e> dfeuer: err, I did something stupid there... (namely, using foldr instead of foldl')... let me fix.
13:11:25 <dfeuer> int-e, that sounds like an *interesting* mistake.
13:11:35 <EvanR> fr33domlover: makes sense
13:11:42 <dfeuer> (the sort one is pleased to discover one has made)
13:11:59 <EvanR> fr33domlover: however STM can sometimes be more natural, if you think transactionally
13:12:11 <monochrom> dfeuer: neato
13:12:25 <EvanR> concurrency necessarily is about things sharing things, somehow
13:14:34 <ertes> fr33domlover: when you find yourself creating threads mostly for negotation or ensuring certain patterns, you hit a use case for STM
13:14:52 <ertes> ah, it's been already said =)
13:14:55 <dfeuer> EvanR, only interesting concurrency is. "Defragment these three hard drives."
13:21:02 <fr33domlover> ertes, EvanR, to be honest I haven't figured out STM yet. Just looked at some intro, no real tutorials / papers yet. But I want to :-)
13:21:31 <yulax> hmm coming back to the fac function, i added a term otherwise = error "eek choose another number!" for when the number is less than 0
13:21:50 <yulax> however, this message is never displayed
13:22:35 <yulax> actually ignore
13:22:38 <yulax> --
13:22:43 <yulax> never mind xD
13:22:51 <yulax> just me being an idiot again
13:23:10 <glguy> message received after "actually ignore"
13:25:45 <bollu> I don't know where to ask this, so here goes
13:25:53 <bollu> is there a nice way to remember the normal forms in databases?
13:25:55 <dfeuer> int-e, what was the performance impact of that change?
13:25:56 <bollu> It feels really weird
13:25:58 <bollu> the definitions
13:27:04 <dfeuer> bollu, what feels really weird? Normal forms of what?
13:27:29 <bollu> dfeuer: databases, the normal forms
13:27:51 <bollu> dfeuer: I can't intuitively remember the differences between 1NF, 2NF and 3NF
13:27:58 <bollu> is there some cute algebra or something behind it?
13:28:00 <dfeuer> Oh, a database thing.
13:28:01 <ertes> fr33domlover: a memory transaction is a series of operations during which we pretend that all the rest of the universe has gone to suspended animation
13:28:03 <dfeuer> I dunno.
13:28:12 * hackagebot glirc 2.20 - Console IRC client  https://hackage.haskell.org/package/glirc-2.20 (EricMertens)
13:28:14 * hackagebot keysafe 0.20161006 - back up a secret key securely to the cloud  https://hackage.haskell.org/package/keysafe-0.20161006 (JoeyHess)
13:28:21 <ertes> fr33domlover: in other words: all or nothing, and nothing at the same time
13:28:38 <ertes> fr33domlover: and that's basically it
13:29:01 <dfeuer> ertes, how do you mix that in with IO? 
13:29:19 <ertes> dfeuer: hmm?
13:29:26 <dmwit> :t atomically
13:29:28 <lambdabot> error: Variable not in scope: atomically
13:29:41 <dfeuer> ertes, er... I guess IO isn't the point.
13:29:46 <dmwit> :t Control.Monad.STM.atomically
13:29:48 <lambdabot> GHC.Conc.Sync.STM a -> IO a
13:29:52 <ertes> dfeuer: ah, you don't  memory transactions have their own ST-like monad
13:30:20 <dfeuer> ertes, but the references can escape?
13:30:27 <ertes> dfeuer: yeah
13:30:37 <dfeuer> Ah... Yeah, I guess it wouldn't be useful otherwise.
13:31:23 <dmwit> If you want to do IO, you use the transaction to build up an IO action that you run when the transaction is complete.
13:31:45 <dmwit> (Since you can't "roll back" IO actions, it doesn't make sense for them to happen during the transaction with the current implementation.)
13:32:00 <fr33domlover> ertes, people always describe it that way, so simple. but because of that, i don't understand how to choose when to use STM. I mean, what you say sounds like "do multiple operations on an MVar while some lock is on so nobody else can touch it"
13:32:03 <ertes> dfeuer: i found (join . atomically) to be a useful idiom
13:32:37 <dmwit> fr33domlover: Close, except there's no lock. If it turns out two actors tried to touch the MVar at once, only one of them succeeds, and the other is rerun from the beginning.
13:32:42 <ertes> fr33domlover: i use STM when with MVar i would have to create extra threads that do nothing else than negotiate between other threads
13:32:56 <ertes> (or Chan or )
13:33:15 <glguy> in that situation STM is also nice for allowing you to specify a timeout when reading from MVars and Chans
13:33:33 <ertes> fr33domlover: also if you want to react to multiple things
13:33:54 <ertes> example: on thread can't read from two MVars
13:33:58 <ertes> s/on/one/
13:34:09 <glguy> Reading from 2 TQueues with a timeout: https://github.com/glguy/irc-core/blob/v2/src/Client/EventLoop.hs#L76-L79
13:34:14 <fr33domlover> ertes, STM makes it possible?
13:34:32 <ertes> fr33domlover: yeah, and in a rather elegant way, too:  STM is an Alternative
13:34:34 <fr33domlover> sort of like select(2) ?
13:34:38 <glguy> fr33domlover: see the link I pasted
13:35:35 <dfeuer> I don't really get the whole `retry` bit. When would you not want to retry?
13:35:53 <ertes> dfeuer: retry = empty
13:35:58 <ertes> it's the transaction that never succeeds
13:36:00 <glguy> when you're OK with the values you've seen so far and don't want to start over
13:36:01 <dfeuer> And then there's the other weird bit, where you try to do something, and alternatively do something else... Doesn't that get wild?
13:36:06 <ph88> could someone take a look at this function? it does a quickcheck and print input and output (which appear the same) .. but the quickcheck is still failing .. not sure where i made a mistake   https://paste.fedoraproject.org/445111/14757796/   output: https://paste.fedoraproject.org/445115/79805147/
13:36:22 <dmwit> dfeuer: `retry` is only needed when some invariant invisible to the runtime system is unsatisfied.
13:36:40 <int-e> dfeuer: it was a small but not very noticable gain. but I've annotated the paste once more, this time with chunking added in.
13:36:46 <glguy> do x <- readTVar tvar; when (even x) retry; return x
13:36:51 <ertes> dfeuer: example use: you have two threads reading from the same TChan, but one thread should only handle messages for which a certain predicate holds
13:36:55 <glguy> suppose you only wanted to read odd numbers
13:37:06 <dmwit> dfeuer: Retrying when two actions collide is the default; but you could also retry when e.g. you read a negative value from your variable, if you wanted a transaction to only go through when somebody had a positive bank balance or similar.
13:37:07 <fr33domlover> glguy, i see, that's cool! so far i did this by having separate threads for separate input sources and then push all inputs into a single Chan and main thread then loops on readChan
13:37:08 <ertes> dfeuer: atomically (x <- readTChan myChan; check (p x); pure x)
13:37:21 <dfeuer> Huh.
13:37:34 <glguy> fr33domlover: Yeah, that gets sloppy, and doesn't work well with timers
13:37:34 <ertes> dfeuer: where 'check' is predefined:  check b = if b then pure () else empty
13:37:46 <dmwit> ph88: Have you tried minimizing the failure?
13:37:50 <dfeuer> Thanks, dmwit, ertes. I should really try playing around with some of this concurrency stuff in earnest at some point.
13:38:00 <johnw> ertes: isn't that also just "guard"?
13:38:09 <ertes> johnw: yeah
13:38:34 <dfeuer> ertes, check sounds an awful lot like guard. Is there a difference?
13:38:40 <ertes> it's STM-specific though, so maybe it's some optimised version of it
13:38:45 <johnw> check is STM's implementation of guard :)
13:38:47 <dfeuer> Oh, what johnw said.
13:39:32 <dfeuer> ertes, so will that retry until `p` holds, or just fail if it doesn't?
13:39:33 <ggVGc> man, I've been sitting for hours thinking about type signatures and writing function stubs
13:39:40 <ggVGc> trying to come up with what I'm trying to do
13:39:53 <Tuplanolla> Sounds like a good time, ggVGc.
13:39:54 <ertes> dfeuer: transactions can't "fail", they can only retry
13:39:54 <ggVGc> is this the world of haskell dev
13:40:11 <dmwit> ggVGc: Sounds like a place we've all been to, yep.
13:40:12 <ggVGc> Tuplanolla: not sure. It feels like what I want to do is actually quite simple, but I can't wrap my head around it yet
13:40:15 <ertes> dfeuer: i'm pretty sure that something like (atomically empty) just causes an "blocked" exception
13:40:25 <Tuplanolla> Isn't it much nicer to notice mistakes before you even make them, ggVGc?
13:40:38 <int-e> dfeuer: anyway in my experiments this code is approximately the same speed as the code I put into the ticket for small numbers, and, interestingly, slightly faster for big numbers)
13:41:01 <dmwit> dfeuer: (Also keep in mind that "retry" is somewhat smart. It's not polling -- it will only rerun a transaction when some variable that was read by that transaction changes.)
13:41:18 <ggVGc> Tuplanolla: well, I've already implemented most of a project in a quite naive way but it does mostly what I want. Since the start though, I've had the idea of basing it all on a much more generalised concept, and now I'm trying to reimplement the foundation on this generalisation
13:41:26 <ggVGc> but I can't figure out the details of the generalisation yet
13:41:45 <dfeuer> int-e, I expect it's because it disposes of garbage more quickly, instead of letting it get evacuated first. I don't really know, of course.
13:41:51 <Tuplanolla> Oh, well, that should come with experience, ggVGc.
13:42:19 <ggVGc> basically I'm trying to build a graph of sequencers that can trigger each other in useful ways, that is as simple as possible, but powerful enough to build the more complex systems I have implemented currently in more naive ways
13:42:22 <dfeuer> But if retry is empty, how does it know you want to retry and not just fail?
13:42:41 <int-e> dfeuer: http://int-e.eu/~bf3/tmp/D.hs has various versions of the code and some testing functions to toy with. feel free to use, modify etc.
13:42:50 <ertes> dfeuer: you can't "just fail"
13:42:55 <dmwit> dfeuer: To quote Yoda: There is no fail, only retry.
13:43:05 <ggVGc> dmwit: is that really a quote?
13:43:09 <ggVGc> or a paraphrasing :)
13:43:11 <dmwit> ggVGc: no =)
13:43:16 <monochrom> I wonder if "fail" and "have to retry" are synonyms.
13:43:21 <dfeuer> But didn't someone just say that empty will end up throwing an exception?
13:43:24 <dmwit> ggVGc: I think the actual quote is "Do, or do not. There is no try.".
13:43:33 <ggVGc> yeah that sounds more yodaish
13:43:37 <dmwit> dfeuer: I don't think anybody said that.
13:43:41 <ertes> dfeuer: though i think STM has some exception mechanism, your transactions have to eventually succeed, otherwise you should consider that a bug
13:43:44 <ggVGc> or something like "Fail you can not. Only try"
13:43:46 <mauke> dfeuer: no, that was 'atomically empty'
13:43:56 <monochrom> And I wonder why it was not "do, or do not, no try there is".
13:44:19 <ggVGc> I have to say I don't like most of star wars, but I like yoda
13:44:33 <dfeuer> mauke, yeah, that's what I meant. I guess that throws an exception because it doesn't depend on anything and therefore can never do anything but retry?
13:44:33 <ggVGc> wish the yoda training part would have been an entire movie
13:45:04 <ertes> dfeuer: yeah, same thing that happens when you read from an empty MVar that nobody will ever write to (and the RTS detects it)
13:45:18 <monochrom> Yoda would agree to participate in that movie if you gave him more sandwiches :)
13:45:21 <dfeuer> Got it.
13:45:21 <ertes> it's probably even the same exception type
13:45:45 <dmwit> dfeuer: You could of course have `atomically retry` simply infinite loop. Throwing an exception you can catch is just a kindness that GHC does for you out of the goodness of its heart.
13:46:18 <dmwit> dfeuer: Kind of like how `let x = x in x` doesn't infinite loop, even though the semantics says it oughta.
13:47:26 <dfeuer> Yeah.
13:47:33 <monochrom> You can get the same conclusion from the premise "GHC is selfish not charitable".
13:47:42 <ggVGc> I still don't have a clear picture on when it's right to create a type class(and I never have so far)
13:47:48 <ertes> dfeuer: i just confirmed that there are throwSTM and catchSTM, but according to the docs they have nothing to do with the retry/selection mechanism of STM
13:47:50 <dfeuer> dmwit, the operational semantics no one has ever written say it ought to. The denotational semantics say "don't care".
13:48:01 <ertes> STM exceptions really just propagate to IO unless caught
13:48:08 <monochrom> It cuts short some obvious infinite loops because it wants to do less work and still receive the same paycheck you promised it.
13:48:12 <ertes> so yeah, that way you can "just fail"
13:48:14 <dfeuer> Okay.
13:48:26 <dfeuer> *nod*
13:48:47 <Tuplanolla> A good rule of thumb is that you should make a class when you want to impose some laws, ggVGc.
13:49:18 <ertes> Tuplanolla: or a type
13:49:43 <dmwit> ggVGc: "Don't" is probably a pretty good default.
13:49:44 <monochrom> And I add a necessary condition: Don't create a type class until you have at least 3 instances
13:49:53 <ggVGc> dmwit: yeah, that's what I'm doing o far
13:49:55 <ggVGc> so far*
13:49:56 <ertes> newtype ASemigroup a = ASemigroup { sappend :: a -> a -> a }  -- type for associative functions
13:50:13 <Tuplanolla> I purposefully left the "don't" part open, ertes.
13:50:14 <Cale> You make a type class when you want to abstract over how something gets done on a type-by-type basis, i.e. there is a canonical way to do it for any given type.
13:50:49 <Cale> Otherwise, you'd be better off with a record of functions expressing how to perform the operations.
13:51:03 <ertes> Tuplanolla: my point is that there is no inherent connection between "has laws" and "should be a type class"
13:51:15 <dfeuer> You also need to make "auxiliary" type classes for various purposes when doing special stuff.
13:51:16 <ggVGc> so, currently I want to create some kind of network of nodes that all can have different inputs and outputs, but need to be able to know about eachother in a generic way through some core subset of functionality. Something in me wants to make a type class, but also it feels wrong. I should do some kind of record of functions instead right?
13:51:17 <ertes> something that has laws is a structure, and that is very often best captured by a type
13:51:22 <ggVGc> maybe this question is still too vague
13:51:34 <dmwit> It seems a bit vague, yeah.
13:51:40 <ggVGc> something like a simplified VHDL
13:51:44 <ggVGc> is what I'm aiming for
13:51:52 <monochrom> that sounds really like the Arrow type class
13:52:30 <redmq> i just typed `let x = x in x` in ghci and it threw an exception..
13:52:32 <ertes> ggVGc: is it compositional?
13:52:33 <ggVGc> I think I need to write some concrete implementations of communications between some nodes to find out the generalisation
13:52:38 <ggVGc> ertes: yes that's the goal
13:52:45 <dfeuer> For instance, most times you want to use Data.Constraint.Forall, you will end up writing a class that just expresses a constraint in the right format.
13:52:57 <ertes> ggVGc: is there some meta-information that builds up during composition?
13:53:10 <ggVGc> hm, not sure I can answer that right now
13:53:27 <ggVGc> I'm just fumbling atm, and trying to get closer to something that makes it clear what I need to do
13:53:30 <ggVGc> hah
13:53:48 <ertes> ggVGc: in general start by trying to define a monad  if that fails, arrows may be what you need
13:54:00 <dfeuer> Or if you have an indexed type, you may want a class expressing something you can do with the type based on its index. This becomes essential in certain cases, such as when dealing with associated types (which shouldn't exist as they are).
13:54:43 <ertes> ggVGc: or a monoid or a <insert more items that suggest "give us more info!">
13:55:08 <ggVGc> yeah, I'm trying to clarify for myself what this thing actually is
13:55:11 <Guest93726> hi
13:55:56 <ertes> ggVGc: give that thing a type, then identify the ideal composition type  we'll see if it matches any structure that is predefined
13:57:00 <ski> redmq : solving the halting problem ..
13:57:52 * ski . o O ( `newtype ASemigroup a = PromiseSemigroup { ... }' )
13:58:25 <ertes> ski: are you trying to fix our namespaces?
13:58:41 <ski> namespaces ?
14:01:24 <ggVGc> ertes: so, starting from the beginning. I think what I actually want is not as generic as I initially proposed. Basically I want to define a graph of nodes that can be "ticked", and each node either ticks one or several other nodes, or generates an output(a leaf)
14:01:41 <ggVGc> so I guess it's like evaluating an AST basically
14:01:59 <ggVGc> but the result is a new "ticked" instance of the graph
14:02:06 <ggVGc> does this resemble anything?
14:03:20 <ertes> ggVGc: not with more information, e.g. what kind of graph?  DAG?  or even a tree?
14:03:46 <ggVGc> ertes: so, something like this I think, https://gist.github.com/bf19c75db7dd4c34eb3e705dd251d15c
14:04:07 <ggVGc> but I'm not sure if representing it with an ADT like this is good
14:04:18 <ertes> ggVGc: yeah, that looks like an AS-*tree* to me
14:05:08 <ggVGc> the point of all of this is to make nodes parameterised, and have node parameters change based on output from other nodes
14:05:09 <ertes> ggVGc: is this music-related?
14:05:13 <ggVGc> yes
14:05:27 <ggVGc> ertes: it's an attempt to create a sequencer combinator library I guess
14:05:28 <ertes> ok, yeah, that sounds more and more like a monad
14:05:29 <ggVGc> in some sense
14:05:54 <ski> ggVGc : .. reminds me of attribute grammars
14:06:27 <ggVGc> ski: I haven't heard about that before, but a quick wikipedia read does sound similar
14:06:33 <ski> (your node take made me think of synthesized resp. inherited attributes there)
14:06:40 <ski> (s/take/talk/)
14:06:52 <ski> @where UUAG
14:06:52 <lambdabot> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
14:06:55 <JonReed> Am I right to assume that ByteString is the way to represent arrays of bytes (considering that most hash functions and digests want ByteStrings)?
14:07:46 <ertes> JonReed: more or less  one other way to keep an eye on is Vector Word8, where Vector is either from Data.Vector.Storable or Data.Vector.Unboxed from the 'vector' library
14:08:40 <ggVGc> ski: hm, this looks very interesting
14:08:52 <ggVGc> but also like I need to study quite a lot before I can implement what I wanted
14:09:00 <ggVGc> the idea seemed so simple in my head..
14:09:11 <ertes> ggVGc: the simple way may involve just using a free monad
14:10:34 <ski> ggVGc : imho, attribute grammars are nice to know about
14:14:04 <ph88> dmwit, what do you mean minimize the failure? it's a True or False condition ..
14:16:24 <ReinH> It looks like a free monad, or would if it were polymorphic
14:17:36 <ski> (s/polymorphic/parametric/)
14:20:12 <int-e> dfeuer: I added some comments (and mentioned it on Trac)... that's enough for tonight.
14:21:14 <dfeuer> (Thanks, int-e. Good night.
14:22:05 <dfeuer> int-e, based on your preliminary testing, how much faster is your fastest than the current version in base?
14:24:55 <int-e> dfeuer: sorry, I didn't test that; I was too dismayed by the realization that it does the chunking on the wrong end of the merging tree.
14:25:10 <dfeuer> Huh?
14:25:18 <dfeuer> What's wrong?
14:25:51 <int-e> dfeuer: it takes a list of n digits in base b, combines them into digits of base b*b, unless there are fewer than 40 digits left.
14:26:28 <dfeuer> Oh, it does everything wrong. I just wondered how much faster your version was. 
14:26:31 <int-e> dfeuer: but the chunking should be done when the base is small, because only then you're close to machine size words.
14:26:48 <int-e> dfeuer: yeah, will try tomorrow
14:26:53 <dfeuer> Sweet.
14:27:04 <dfeuer> That's why I looked at the code and thought "wrong shape".
14:27:12 <dfeuer> Everything was just wrong.
14:27:32 <dfeuer> So far, yours looks much more reasonable, but I haven't gotten through all of it yet.
14:28:13 * hackagebot hstox 0.0.1 - A Tox protocol implementation in Haskell  https://hackage.haskell.org/package/hstox-0.0.1 (iphydf)
14:28:15 * hackagebot pipes-zlib 0.4.4.1 - Zlib and GZip compression and decompression for Pipes streams  https://hackage.haskell.org/package/pipes-zlib-0.4.4.1 (RenzoCarbonara)
14:29:30 <dfeuer> And I'd also love to see how fast yours is when the chunking is adjusted to the word size and base, but maybe I'll have to wait till I actually integrate that into the parsing code.
14:38:50 <stoogeypoogey> hey all.. how come this won't work in a repl but works fine in a program? http://lpaste.net/245651
14:39:00 <stoogeypoogey> does the repl have some issue with recursion...?
14:39:22 <Rembane> stoogeypoogey: You must add let before definitions in the repl.
14:39:26 <Rembane> > let x = 7
14:39:28 <lambdabot>  <no location info>: error: not an expression: let x = 7
14:39:31 <Rembane> :D
14:40:01 <redmq> what do you mean it doesn't work well in a program? what's happening?
14:40:27 <stoogeypoogey> Oh I see.. How come you need to add let in a repl? something about monad shmonad? (-:
14:40:35 <geekosaur> lambdabot is not a repl; it only speaks expressions
14:40:44 <geekosaur> actually in ghc8.0.1 you don't need the let
14:40:45 <Rembane> stoogeypoogey: Yeah, it's in the IO monad.
14:40:53 <mauke> stoogeypoogey: the repl probably sees it as two separate definitions
14:40:54 <geekosaur> otherwise, ghci pretends to be a "do" in the IO monad
14:40:56 <mauke> with the latter shadowing the former
14:41:05 <Rembane> geekosaur: That explains why lambdabot doesn't like my let. 
14:41:10 <stoogeypoogey> I see. That makes sense. Thanks guys
14:41:23 <geekosaur> ...except it has been sprouting various top level things, so that no longer makes much sense, and is slowly going away
14:41:47 <stoogeypoogey> Wait so how would I be able to do it in the REPL
14:41:53 <stoogeypoogey> Two lines of let don't work either
14:42:07 <geekosaur> let ... ; ...
14:42:20 <geekosaur> sometimes that needs braces, but usually not
14:42:32 <stoogeypoogey> Ok that works. Thanks!
14:42:37 <ertes> stoogeypoogey: GHCi has a (rather awkward) syntax for multi-line definitions
14:42:46 <geekosaur> there is also a multiline mode, but it's a bit painful
14:43:09 <ertes> you can type this:  :{; fac 0 = 1; fac n = n * fac (n - 1); :}  -- read ";" as "new line"
14:43:09 <stoogeypoogey> I guess these aren't often used features
14:43:30 <geekosaur> yeh. the repl is more of a desk calculator than an interactive programming environment
14:43:33 <stoogeypoogey> That's actually not too bad
14:43:37 <ertes> stoogeypoogey: i think at that point you should just write and load a source file instead
14:43:48 <stoogeypoogey> yea I guess you're right
14:43:51 <geekosaur> although it is slowly growing more features, you might be better off looking into thinks like ipython-notebook
14:44:01 <ski> > let fac 0 = 1; fac n = n * fac (n - 1) in fac 5
14:44:03 <lambdabot>  120
14:44:10 <geekosaur> (althugh I am failing to remmber if that has been upgraded to jupyter)
14:44:11 <ski> (you can omit the `in fac 5' part in the interactor)
14:44:14 <geekosaur> er, ihaskell0
14:44:23 <ertes> GHCi is fine as a programming environment, just not on its own  it *really* wants to be integrated into your editor
14:45:12 * ski differentiates GHCi wrt Hugs
14:45:19 <yulax> emacs!
14:45:28 <yulax> but i like emacs separate
14:45:32 <dfeuer> I know I've seen a Void# type in Core, constructed with void#. But I can't seem to find such a thing in GHC.Prim or elsewhere. Is it somewhere, or should I just use Proxy# instead?
14:45:43 <ski> (yulax : GNU Screen)
14:47:12 <ertes> emacs' haskell-mode is so close to agda2-mode  i hope we'll get there some day
14:48:18 <yulax> ski: i use screen it's great. also for detaching weechat on shell server it is good
14:48:45 <ertes> unfortunately with emacs in screen you no longer get a GUI
14:48:47 <MarcelineVQ> dfeuer: MkId.hs in ghc source mentions void#
14:48:58 <ertes> xmonad is better than screen =)
14:49:08 <MarcelineVQ> dfeuer: suggests it's been repalced by realWorld#
14:49:30 <MarcelineVQ> well replaced is probably the wrong word
14:49:30 <dfeuer> MarcelineVQ, ah.... I see.
14:49:59 <dfeuer> They have now  realWorld# :: State# RealWorld, I guess.
14:50:21 <dfeuer> And (apparently much better)  runRW# for ST stuff.
14:50:29 <MarcelineVQ> I'm sure I'm misrepresentig it, it's in here https://github.com/ghc/ghc/blob/master/compiler/basicTypes/MkId.hs
14:51:17 <king85> ciao
14:51:27 <king85> #list
14:51:30 <dfeuer> But my goal is to carefully confuse GHC's full laziness transformation so it won't lift a constant to the top level, because said constant could get *very big*.
14:51:46 <king85> ciao
14:51:46 <mauke> king85: did you mean: !list
14:51:51 <mauke> king85: also, hello to italy
14:52:19 <dfeuer> Might or might not be able to do it with Proxy# (tossing those around can *sometimes* confuse the optimizer enough).
14:52:32 <king85> hello mauke
14:53:44 <mauke> king85: I've been wondering, why do Italians do this? I mean, joining a random IRC channel and typing "!list"
14:53:44 <king85> i forgot how to acess
14:53:57 <mauke> is there a website somewhere that says to do this?
14:54:00 <geekosaur> access what?
14:54:13 <ertes> i think the "!list" stuff is some warez thing
14:54:15 <zomg> !list is an irc piracy thing
14:54:22 <dfeuer> Another possibility might be to use oneShot, but I don't understand it well enough.
14:54:31 <zomg> certain fileserver scripts respond to !list by providing info on how to download things
14:54:45 <ski> !list
14:54:56 * ski awaits response by monochrom
14:55:10 <mauke> I know about that part, but it's always Italians who do it in completely unrelated channels
14:55:11 <king85> !list
14:55:14 <zomg> heh
14:55:20 <mauke> join, "ciao a tutti", "!list", quit
14:55:22 <zomg> maybe italians are corrupt and enjoy their warez
14:55:28 * ski thought it was "ciao a tut.." right
14:55:36 <zomg> tutti frutti more like
14:55:43 <Rembane> Isn't that "not list"?
14:55:49 <Rembane> What is a not list?
14:55:52 <ertes> Rembane: strict list
14:56:04 <ertes> this is haskell, not C
14:56:13 <zomg> Rembane: !list is false
14:56:14 <mauke> what if it's CSS?
14:56:14 <zomg> er
14:56:44 <Rembane> zomg, ertes: Absurd, isn't it?
14:56:55 <ski> a not list is a lazy (additive) pair of a "bottom", and a multiplicative disjunction context holding a non-element, or another non-list
14:56:58 <geekosaur> or youre in ruby/smalltalk/scheme and it means destructive update
14:57:28 <ertes> Rembane: no, it's not Absurd
14:57:48 <Rembane> ski: That's a solid definition.
14:58:19 <ski> (the recursion should be the greatest fixpoint)
14:59:26 <ski> @remember dfeuer But my goal is to carefully confuse GHC's full laziness transformation so [snipped]
14:59:26 <lambdabot> I will never forget.
15:00:00 <dfeuer> ski, I'm looking at int-e's code at http://int-e.eu/~bf3/tmp/D.hs and fearing that it could take some real work to prevent GHC from being "smart" and lifting `bs` to the top level once it knows `b`, which would be awful. Preventing that sort of thing can be ... hard.
15:02:16 <ski> hm .. perhaps there should be a pragma or something for that ?
15:02:28 <dfeuer> Totally unrelatedly, bs should not be a list, but an infinite stream data IS = IS !Integer IS, so the pattern matches in step and fromStack are complete, but that's easily fixed.
15:04:18 <dfeuer> ski, maybe there should be, but there isn't. So I'll have to dig into the Core, and if it does the horrible thing I expect, I'll have to find a way to convince GHC that `bs` depends on the [Int] argument.
15:04:54 <dfeuer> (or, more to the point, that it *could*)
15:07:11 <dfeuer> siterate f seed dep = SI seed (siterate f (f seed) dep)  might do it, where dep is the false dependency.
15:07:25 <ski> mhm
15:07:58 <dfeuer> It passes around an argument unnecessarily, but I guess in this context the cost of that will be minimal.
15:08:33 <dfeuer> Totally minimal.
15:08:42 <dfeuer> If it works.
15:08:59 <christiansen> is there a good way to access local haddock docs from emacs that's aware of imports?
15:09:43 <christiansen> in the past, I've typically just Hoogled/Googled the name that I wanted docs for, but I have some libs where the docs aren't present on Hackage that I'd like to get docs for
15:09:52 <christiansen> Manually browsing the HTML is a bit tiring
15:10:10 <hiptobecubic_> I've had good luck using zeal
15:10:16 <dfeuer> Hi christiansen. I don't know. You might try emailing haskell-cafe if you don't get an answer here.
15:10:24 <hiptobecubic_> or dahs if you're a mac person that likes to pay money for things
15:10:26 <hiptobecubic_> dash*
15:11:12 <christiansen> hiptobecubic_: these don't seem to be a way to open a browser from Emacs...
15:11:18 <christiansen> dfeuer: thanks
15:13:05 <christiansen> hiptobecubic_: it doesn't look like zeal actually looks at my locally-built Haddock anyway
15:13:21 <hiptobecubic_> oh, no zeal requires preprocessing on your part
15:13:24 <hiptobecubic_> but it's not terribly hard
15:13:44 <hiptobecubic_> it's a doc browser that is easy to search and integrates well via a cli
15:14:49 <christiansen> hiptobecubic_: yeah, I was hoping more for something that understood the imports in my file to resolve a source-level symbol to a local Haddock URI
15:15:01 <hiptobecubic_> ah. No. :)
15:15:15 <christiansen> kinda like in Idris or Racket modes
15:15:34 <hiptobecubic_> I'm surprised there isn't such a thing though. There are a lot of filthy emacs lovers in here
15:15:44 <christiansen> there was a thing that did it a few years ago, but it pulled in lots of ghc-mod parts and was super slow to run
15:16:23 <christiansen> wouldn't need to be emacs-specific, something that took a file and a line and column and quickly returned the url would be easy to wrap with elisp
15:16:32 <christiansen> potentially a ghci command, for instance
15:18:26 <christiansen> "stack hoogle" is fairly handy, but still doesn't link to docs pages the way online Hoogle does
15:18:30 <hiptobecubic_> maybe something in ide-backend could work?
15:18:31 <christiansen> is there a way to make it do that?
15:18:42 <glguy> christiansen: Not that this wouldn't be nice to have, but are there particular docs missing on hackage you need?
15:19:02 <christiansen> glguy: it's the Pango and Cairo bindings
15:19:17 <christiansen> that would let online Hoogle solve the problem the old-fashioned way
15:19:27 <christiansen> glguy: hi, by the way :)
15:19:38 <glguy> Hi :) I'll upload docs for those, at least (in a moment)
15:19:48 <christiansen> the Pango and Cairo APIs are pretty complicated, so it takes a lot of head-scratching to use them :)
15:19:56 <christiansen> and thank you very much!
15:20:16 <christiansen> is there some way that I can do the work to fix this myself in the future?
15:20:30 <christiansen> (e.g. building docs locally by hand and sending someone a tarball for review)?
15:20:35 <christiansen> I hate to impose
15:21:02 <glguy> christiansen: To upload documentation you have to be in the maintainers group for a package or the trustees group for hackage
15:21:24 <christiansen> ok
15:24:57 <glguy> In general it's no trouble to upload documentation (run one command) I just happen to have reset my Haskell environment for an unrelated reason, and thus the delay
15:25:38 <christiansen> no worries, it's not like the local docs are unusable
15:25:46 <christiansen> it just takes clicking around sometimes
15:25:49 <christiansen> thanks for doing this!
15:33:51 <joe9> any suggestions on why these modules do not show up as hyperlinks? http://hackage.haskell.org/package/Network-NineP
15:34:29 <joe9> This seems to be a common occurrence these days.
15:36:51 <glguy> christiansen: done
15:37:04 <christiansen> glguy: thanks a bunch!
15:37:26 <glguy> joe9: The doc builder bot can go wrong and many maintainers don't bother uploading docs
15:38:07 <joe9> glguy, it is such a good way to check up on the modules, instead of going to github and read through the module.
15:38:31 <glguy> joe9: Yeah, you'd think more would upload them
15:38:34 <glguy> http://hackage.haskell.org/package/Network-NineP fixed
15:42:18 <joe9> glguy: Thanks.
15:44:39 <jle`> joe9: when that happens i usually hop on over to stackage and read the docs there
15:45:04 <glguy> I'm going to bet Network-NineP isn't on stackage
15:45:28 <jle`> heh, that one might not be, but that's just a general thing i do :3
15:46:43 <Bor0> how can one represent this recursive function in terms of a mathematical recurrence relation? http://pastebin.com/u7Tz33ub. or even better, is there a closed-form expression of it?
15:48:26 <Bor0> I tried something like n/k + log_k(n) but that didn't seem to work
15:48:37 <Bor0> hm, might actually be a multiplication instead
15:49:08 <cheater> is it possible to parse a haskell file that has errors in it, and get a generally pretty good AST other than the place that has the error?
15:49:52 <Tuplanolla> Try -fdefer-type-errors, cheater.
15:50:22 <EvanR> -fdefer-syntax-errors
15:50:49 <Tuplanolla> We're still trying working on that and -fdefer-writing-code.
15:51:07 <cheater> i am thinking about this because i've been talking with someone about the issues one would face if they wanted to build a code editor that edits the AST and not the text
15:51:20 <christiansen> thanks again, glguy 
15:51:23 <cheater> so obviously some .hs files you will want to edit won't be valid haskell because of typos etc
15:51:34 <cheater> and the question is what is the best effort you can do there
15:51:36 <geekosaur> -fdefer-all-errors is a thing, actually
15:52:24 <EvanR> cheater: some of these live coding environemnts (for music) seem to be ok with syntax errors in mid stream
15:52:56 <cheater> right, they just wait till you've edited the file so that it parses again
15:53:00 <EvanR> but its not manipulating ASTs
15:53:01 <Tuplanolla> I think that kind of a thing should remember the previous correct forms and use those to repair the current wrong form, cheater.
15:53:08 <cheater> but here you have the chicken and egg problem
15:53:23 <cheater> you have to be able to parse the file in order to edit it to make it parseable
15:53:39 <Tuplanolla> I don't know how to do that, but I've seen papers on error-correcting context-free grammars.
15:54:01 <EvanR> cheater: a lot of real world data is malformed and people have ways to getting some of it
15:54:10 <cheater> so the best you should be able to do is to isolate the part of the file that isn't parseable correctly, and treat that as a blob of text, while everything before and after is parsed
15:54:16 <EvanR> i dont know if theres any focus on that for code
15:54:26 <cheater> but the question is how the reality of this looks
16:08:51 <Squarism> I have a hard time understanding the purpose of state monad. Why does it have 2 values? 
16:09:28 <grantwu> One of them is the state
16:09:43 <grantwu> The other is the like... "return type" almost
16:09:54 <dfeuer> Crud.
16:10:04 <grantwu> I'm not sure if that's a good description
16:10:25 <EvanR> a program with type State s a, when run, needs a starting state of type s and returns a result of type a (and if you want, the final state)
16:10:36 <johnw> Squarism: think about the usefulness of a function from s -> (a, s), and why it has two types
16:11:03 <dfeuer> ski, my plan is foiled, because in the *real version* the list isn't there. I'm making a parser, and my parser definition doesn't have input to grab and fake dependency one.
16:11:04 <dfeuer> *on
16:11:10 <dfeuer> So I might be screwed.
16:12:28 <Squarism> johnw, maybe it could be updateAndReturnPreviousValue?
16:13:06 <EvanR> it might not return previous value
16:13:29 <Squarism> yeah, Nothing?
16:13:37 <Squarism> as in maybe?
16:13:38 <EvanR> not Nothing
16:13:50 <EvanR> output s could be different from input s
16:14:33 <grantwu> consider some computation which you can solve in a pure manner... now consider another equivalent way of computing the same thing, but which has some internal state
16:15:00 <johnw> Squarism: "previous value"?
16:15:08 <grantwu> if the original function has type a -> b, the equivalent way might look like a -> State Internalstate b
16:15:36 <Squarism> johnw, you asked me for something a useful accomplished with such signature
16:15:51 <johnw> s -> (a, s) says: Given a value of some state type "s", produce a value of type "a" along with another value of the same state type "s"
16:21:34 <Squarism> grantwu, that sort of made some sense to me. 
16:22:14 <grantwu> Squarism: Hope it helps
16:22:41 <grantwu> And then note that there are a bunch of functions that let you extract values from the monad.
16:23:07 <grantwu> runState gives you both the state and the value, evalstate gives you just the value, execState gives you only the state
16:23:57 <johnw> which you can remember with e<VAL>State
16:39:52 <carlosayam> hello, any familiar with Data.Array.Repa?
16:41:53 <carlosayam> In REPA, I was wondering why traverse has as parameters both, the source array and a function that takes as first parameter a function to get elements from the first array...?
16:43:49 <carlosayam> I mean, in REPA, \ix -> arr ! ix, is already a function that returns an element from an array, so why do we need to provide the source array if it is implicit in the third?
16:44:15 <carlosayam> or is REPA doing some additional magic..?
16:46:23 <geekosaur> it lets you take a shaped subsection of the array instead of the whole thing
16:47:13 <glguy> Given: traverse arr transExtent newElem = fromFunction (transExtent (extent arr)) (newElem (index arr)), I dont think it's doing anything more clever than  arr!ix for you
16:47:56 <geekosaur> so you pass traverse an extra parameter which could be id to traverse the whole thing, or a Shape describing some subpart. the traversal is then passed a function which maps the provided index from the selected subset to the whole thing
16:48:44 <glguy> carlosayam: If you don't want to use the form that traverse offers, just call fromFunction :: sh -> (sh -> a) -> Array D sh a directly
16:55:26 * ski . o O ( s/fromFunction/tabulate/ )
16:56:04 <MarcelineVQ> useful related resource https://wiki.haskell.org/Numeric_Haskell:_A_Repa_Tutorial
16:57:32 <carlosayam> thanks all - I've been looking at the REPA tutorial
16:58:37 <carlosayam> I am playing with it, and wanted to implement the wavelet cascade algorithm... if it is not doing any magic, then it is redundant (imo) but I can live with it ...
16:59:14 <carlosayam> geekosaur: I believe the shape transformation is for the target, not the source ...
17:00:22 <ertes> carlosayam: at least it guarantees that you're reading from the same array
17:03:08 <carlosayam> ertes: do you need that because of the monadics computeP and computeS? 
17:03:40 <carlosayam> if so, there is something I still don't get about REPA ... :)
17:07:57 <dmwit> ph88: I mean minimize the code needed to demonstrate the problem.
17:08:28 <dmwit> ph88: This is not just polite to readers here who want to help, but also a very common debugging strategy.
17:08:48 <dmwit> ph88: It's common to be able to isolate your confusion to just a few lines of simple Haskell.
17:09:33 <dmwit> ph88: http://stackoverflow.com/help/mcve goes into some depth
17:27:17 <dfeuer> Oh, duh. I was being stupid.
18:25:36 <mson> How do I declare a type that's a list of tuples? I'm getting parse error from the following: data Adj b = [(b, Int)]
18:25:54 <ertes> carlosayam: if it didn't make sense, just ignore it =)
18:26:04 <Koterpillar> mson: if you want a type synonym, use the type keyword: type Adj b = [(b, Int)]
18:26:16 <Koterpillar> mson: for a distinct type, add a constructor: type Adj b = Adj [(b, Int)]
18:26:54 <ertes> Koterpillar: if you want a distinct type, use the data keyword =)
18:27:01 <Koterpillar> oh, sorry
18:27:11 <ertes> SCNR =)
18:27:11 <Koterpillar> copy-paste :( https://support.apple.com/en-us/HT201229
18:27:20 <mson> The second one (with data) is what I needed, thanks!
18:27:20 <Koterpillar> now where did that come from...
18:27:26 <Koterpillar> data Adj b = Adj [(b, Int)]
18:27:33 <ertes> also in that case better use newtype
18:27:56 <ertes> newtype Adj b = Adj { fromAdj :: [(b, Int)] }
18:28:38 <mson> ok!
18:30:13 <mson> Why do we need a constructor here and not with something like: data Maybe a = Just a | Nothing    ?
18:30:23 <ReinH> mson: Maybe has constructors
18:30:32 <ReinH> Just and Nothing are data constructors.
18:30:39 <mson> Gotcha.
18:31:31 <ReinH> We call Nothing a "nullary" constructor in order to confuse people later when we tell them that nullary functions aren't also a thing.
18:41:56 <grantwu> Hrm
18:42:07 <grantwu> What *are* nullary constructors then
18:42:16 <grantwu> Because non-nullary constructors are functions, right?
18:43:36 <dolio> They wouldn't be confused if they didn't assume that constructors are functions.
18:44:32 <grantwu> Are constructors not functions?
18:44:54 <Koterpillar> they are different
18:44:58 <dolio> Is Nothing a function?
18:45:03 <Koterpillar> for example, you can pattern match on constructors
18:45:24 <grantwu> hrm
18:45:26 <grantwu> :t Nothing
18:45:28 <lambdabot> Maybe a
18:45:32 <grantwu> :t Just
18:45:34 <lambdabot> a -> Maybe a
18:45:42 <grantwu> okay, that works I guess
18:56:44 <mson> I'm trying to copy a code sample into Haskell: data Graph a b = Empty | Context a b & Graph a b  . But I get parse error on &. I think the author is using & to denote some other prelude constructor in Haskell but I don't know what. Can anyone guess?
18:57:13 <dolio> It will work if you use :&
18:57:27 <dolio> Operator constructors must begin with :.
18:57:30 <mson> Huh, it does. Is that because it's being used infix?
18:57:37 <mson> I see I see
18:58:32 <Squarism> anyone know if there are any nice ghcjs examples around?
18:58:48 <Squarism> (ghcjs is very quite, thats why i ask here)
19:00:59 <ReinH> quite so
19:04:09 <mson> Does the interpreter have built in help, like R's ?function ?
19:05:03 <grantwu> :i
19:05:07 <ReinH> :help will tell you about its commands
19:05:11 <grantwu> e.g.
19:05:15 <grantwu> :i fromJust
19:05:33 <grantwu> Isn't lambdabot supposed to respond to that?
19:05:36 <ReinH> lambdabot's version isn't very helpful
19:05:38 <ReinH> @info fromJust
19:05:38 <lambdabot> fromJust
19:05:43 <ReinH> Yeah thanks
19:06:28 <grantwu> doing this at ghci gives
19:06:30 <grantwu> fromJust :: Maybe a -> a  -- Defined in Data.Maybe
19:07:21 <mson> Great, thanks
19:08:25 <grantwu> For more info, you're probably better with hoogle or editor tooling 
19:08:30 <mson> I'm looking for documentation on the :& constructor, but :i doesn't like it and google doesn't pick it up.
19:09:10 <grantwu> do you have more context as to the code?
19:09:39 <mson> Yes, the following: data Graph a b = Empty | Context a b :& Graph a b
19:09:49 <grantwu> I meant like
19:09:51 <grantwu> more than that xD
19:09:59 <mson> :(
19:10:31 <grantwu> oh wait
19:11:16 <grantwu> This is from fgl, is it not
19:11:45 <grantwu> @hoogle (&)
19:11:48 <lambdabot> Data.Function (&) :: a -> (a -> b) -> b
19:11:48 <lambdabot> Control.Lens.Lens (&) :: a -> (a -> b) -> b
19:11:48 <lambdabot> Control.Lens.Operators (&) :: a -> (a -> b) -> b
19:11:48 <mson> I'm reading a paper and it may be from the author of fgl. But I haven't imported fgl.
19:11:59 <grantwu> hrm....
19:12:00 <mson> Wow!
19:12:17 <grantwu> I don't think that's what you want though
19:12:24 <grantwu> https://www.haskell.org/hoogle/?hoogle=%26 gives me a result from fgl
19:12:33 <grantwu> which apparently has no docs on Hackage
19:12:48 <mson> Yup..
19:13:06 <mson> hoogle is great though, hadn't heard of it
19:13:16 <grantwu> there's also hayoo
19:13:33 <grantwu> someone should make a hing :P
19:13:47 <grantwu> altahista.
19:19:56 <Squarism> Does it sound sane to use A channel in a ghcjs app to model some event listener? 
19:25:03 <valetarton> lovin those monads
19:25:49 <EvanR> McMonad's
19:28:59 <ggVGc> so, how can I chaing together stateful computations, where each one has a different state type
19:29:32 <ggVGc> I think I'm supposed to use Arrow, but I can't wrap my head around what I need to do
19:29:34 <EvanR> by making them all have the same state type
19:29:44 <ggVGc> what other option do I have
19:29:49 <EvanR> dont use monads
19:29:55 <ggVGc> okay, what do I do
19:30:19 <ggVGc> EvanR: something like this? https://gist.github.com/2dd3f1165e049e28c165d097827b9314
19:30:27 <EvanR> honestly i dont know, it sounds like you haskelled your way into a corner
19:30:43 <ggVGc> well, I don't know how to model this problem
19:31:00 <ggVGc> I'm about to implement it in a dynamic language so that I can ask someone how I could do it in haskell
19:31:03 <EvanR> it sounds like a solution without a problem, from here
19:31:29 <EvanR> why are those two cases in the same type at all?
19:31:50 <EvanR> i see you are doing an interleaved list
19:31:54 <EvanR> but...
19:32:33 <ggVGc> EvanR: I am trying to create something where I can have sequencers that can trigger eachother, and also trigger a selection from a group of sequencers
19:32:37 <ggVGc> not sure how to explain it well
19:32:43 <EvanR> i remember
19:33:28 <EvanR> so youre trying to represent the triggering network?
19:34:32 <ggVGc> EvanR: so, say sequencer A outputs Ints. I want to connect that to a switch that holds 5 other sequencers, and based on the Int, change the selected one in the switch. And the switch also has another input which when triggered, redirects that trigger to whatever sequencer is selected
19:34:37 <ggVGc> and I want all this to be composable
19:34:40 <ggVGc> EvanR: maybe?
19:34:45 <ggVGc> what's the triggering network
19:34:50 <joe9> any wmii users here? I am currently on xmonad, but, love to check out the 9p architecture and wmii seems to be using it. any experiences?
19:35:25 * EvanR finishes reading that
19:35:46 <EvanR> none of this will be composable if youre expecting to dynamically disconnect and reconnect 
19:36:48 <ggVGc> EvanR: I'm not expecting that. A switch holds a static amount of child sequencers, of which a single one can be active at a time
19:36:58 <ggVGc> anyway, I don't know how to model it at al
19:36:59 <ggVGc> l
19:37:28 <EvanR> static amount, or static children 
19:37:36 <ggVGc> static children
19:38:00 <EvanR> so, the switch can be represented with a record of functions
19:38:17 <EvanR> you construct the switch by providing the 5 sequencers, which are also records of functions
19:39:05 <ggVGc> EvanR: my main issue is, how do I handle the updated states of each node in the graph when sending a trigger through it
19:39:25 <ggVGc> actually, maybe that works out
19:39:29 <EvanR> lets say "trigger" is one of the functions in the switch record
19:39:37 <ggVGc> yep
19:39:55 <EvanR> when you execute it, the switch checks what is selected, then executes the trigger on that sequencer
19:40:07 <EvanR> then the sequencer in question can update whatever internal state it has
19:40:30 <EvanR> thus, "you" dont handle it at all
19:52:37 <cstrahan_> If I have a list of MVars (that I'm treating as mutexes), is there any way I can sort those such that I'm guaranteed that looping over each and acquiring a lock would _not_ deadlock in the presence of other threads doing the same?
19:52:51 <cstrahan_> If this were another language, I might sort by address.
19:53:37 <cstrahan_> ... but Haskell's garbage collector can move things around, so I don't think I can do any pointer shenanigans.
19:54:02 <cstrahan_> The closest thing I can think of is hashing StableNames, but the hashes aren't guaranteed to be unique.
19:54:05 <ReinH> This seems like an XY problem.
19:54:41 * geekosaur thinsk for the specified problem a lock over the MVar list is the right thing --- or TVars --- *but*, what is the actual problem this is seen a solution to?
19:55:44 <EvanR> locking an entire list of mutexes at once o_O
19:55:53 <cstrahan_> For context, I'm playing around with writing an implementation of bounded channels a la Go, and for a `select`, I need to lock on all channels involved in each of the cases.
19:55:53 <ggVGc> haha, yeah I reacted to that too
19:56:24 <ggVGc> EvanR: a mutex to lock the list of mutexes
19:56:27 <ggVGc> nest level tuff
19:56:28 <ggVGc> stuff*
19:57:59 <cstrahan_> I'm afraid that won't work
19:59:38 <dmj`> cstrahan_: sounds like a job for STM
19:59:49 <EvanR> or download a bounded channel package?
20:00:24 <dmj`> TBQueue
20:00:32 <cstrahan_> ggVGc: if I have channels A, B, C, and I have two selects -- one that waits on channels A and B, and the other on B and C -- how would I realize, across call sites, that those two calls two `select` need to share the same mutex (because B is common two both)?
20:01:18 <ggVGc> cstrahan_: I don't think I am the right person to ask :( I've been struggling to abstract over sequencers the whole day and am now giving up
20:01:20 <cstrahan_> TBQueue, sadly, does not give me the semantics I want.
20:02:16 <cstrahan_> `select` is what I'm after, and none of the existing libraries offer it.
20:02:45 <cstrahan_> (There's an open issue for BoundedChan that goes back to over a year ago: https://github.com/GaloisInc/BoundedChan/issues/4)
20:03:06 <EvanR> well there exists a package with unix select in it
20:03:12 <cstrahan_> :)
20:03:27 <EvanR> if thats what you want no reason to reinvent it
20:06:15 <cstrahan_> I appreciate the suggestions, but I'm really looking for (bounded) channel implementation. The `select` from e.g. Linux is for waiting for activity on a set of file descriptors. I'm wanting to be able to synchronize across producers and consumers of Haskell values instead. 
20:06:55 <cstrahan_> Well, not _looking_ for an implementation -- I'm presently writing one just because I think it'd be fun :)
20:07:22 <EvanR> dwarf fortress fun
20:07:34 <cstrahan_> But the only wrinkle left is safely locking each channel participating in each case branch of a select.
20:08:13 <cstrahan_> I hope not -- I wanted to like dwarf fortress, but found it a little too tedious ;)
20:16:54 <fryguybob> cstrahan_: If you control the creation of your MVars you can pair them with a unique value.
20:17:27 <cstrahan_> fryguybob: that's a good idea, and one that I'm giving some thought
20:17:54 <cstrahan_> fryguybob: what would you suggest for creating the unique values?
20:18:36 <fryguybob> cstrahan_: Creating MVars is probably not going to be your bottleneck so a global lock on a unique value store is a starting place.
20:19:08 <fryguybob> Beyond that, capability specific pools of unique values.
20:19:55 <cstrahan_> fryguybob: Interesting. Thanks for the suggestion!
20:20:32 <fryguybob> cstrahan_: https://hackage.haskell.org/package/uniqueid
20:21:26 <joe9> I want to write a wayland client using haskell. I found https://github.com/abooij/sudbury . Any suggestions or alternatives, please?
20:21:32 <fryguybob> (I don't know anything about this particular package, but "splittable unique values" is the right set of names to look for)
20:22:44 <fryguybob> cstrahan_: By the way, what semantics do you want that TBQueue is missing?
20:28:20 * hackagebot HUnit 1.4.0.0 - A unit testing framework for Haskell  https://hackage.haskell.org/package/HUnit-1.4.0.0 (SimonHengel)
20:28:27 <cstrahan_> fryguybob: Is there any way to take a set of TBQueues and (assuming a corresponding recv) wait for the first TBQueue to have a value available or (assuming a corresponding send) wait for the first TBQueue to be non-full?
20:29:29 <cstrahan_> (That is, aside from using the try* functions in a loop until success, but that's a _lot_ of spinning if you end up waiting for a while)
20:30:15 <EvanR> STM doesnt spin like that
20:30:43 <EvanR> it sleeps until something happens to where it possibly wouldnt just spin
20:31:35 <EvanR> nifty as hell imo
20:33:05 <fryguybob> cstrahan_: If you have something like  atomically (pop a `orElse` pop b)  then the transaction will try to get a value from a, if it can't try to get a value from b, if it can't, block the thread until another transaction commits that changes the head of a or b.
20:34:30 <fryguybob> cstrahan_: But it is still a transaction, so if a value comes in to  a  after we have moved on to  b  then the transaction will fail to commit and start over from the beginning.
20:34:44 <fryguybob> cstrahan_: This makes `orElse` left biased.
20:35:56 <cstrahan_> Ah, fairness is something that I don't want to give up.
20:36:34 <cstrahan_> (I really do need to learn me some STM sometime soonish though.)
20:46:00 <joe9> I cannot recall the name of the irc channel where the haskell gui guys hang out?
20:46:07 <joe9> Any recommendations, please/
20:47:45 <joe9> found it, I think it is #haskell-game
20:49:30 <neochronomo> I'm learning haskell for the very first time, and the first script I've written is the following: http://pastebin.com/ZEAX0JUM
20:49:57 <neochronomo> When I use the code in Hugs I can get it to double and quadruple numbers, but for some reason it won't recognize factorial or average. Any ideas?
20:50:26 <Koterpillar> what do you mean by "won't recognize"?
20:50:40 <neochronomo> Koterpillar: "ERROR - Undefined variable "factorial""
20:50:44 <neochronomo> and same for average
20:50:50 <Koterpillar> also, what prompted you to try Hugs?
20:51:04 <neochronomo> My instructor chose it for the course
20:51:08 <Koterpillar> :(
20:51:18 <neochronomo> Is hugs bad?
20:51:59 <geppettodivacin> It's no longer developed, according to their website.
20:52:17 <neochronomo> I noticed it was from 2006, but that's what he chose :P
20:52:32 <EvanR> which means youre using software so perfect, its done
20:53:14 <Koterpillar> neochronomo: http://rextester.com/BOIU25111
20:53:52 <geppettodivacin> neochronomo: Your code looked just fine to me.
20:54:11 <neochronomo> So.. is this Hugs messing up then?
20:54:22 <geppettodivacin> Maybe?
20:55:20 <neochronomo> What would you recommend instead?
20:55:28 <Koterpillar> ghc
20:55:58 <geppettodivacin> ghc is generally considered the standard, and it's still in very active development.
20:56:02 <koz_> If I have something like '(,) <$> pure x <*> y', is there a better way to write it, or is this the best way?
20:56:06 <geppettodivacin> As a bonus, ghc is glorious.
20:56:19 <koz_> I recall something about the applicative laws allowing a different way of saying it.
20:56:47 <neochronomo> Koterpillar: geppettodivacin: I'll give it a whirl
20:58:38 <glguy> neochronomo: It sounds like you simply didn't reload the file, or forgot to save after adding factorial or average
20:59:13 <neochronomo> glguy: I reloaded it
21:00:03 <geppettodivacin> koz_: liftA2 (,) (pure x) y ?
21:00:12 <glguy> Then it's likely that you didn't save, or at least saved a file that wasn't the one reloaded. Hugs is unlikely to have just missed two definitions
21:00:39 <neochronomo> glguy: I saved and reloaded. I even closed hugs and loaded it from scratch
21:00:42 <Koterpillar> koz_: (x,) <$> y 
21:00:59 <neochronomo> glguy: the first two functions worked... so I know it loaded
21:01:00 <koz_> Koterpillar: Thanks - that's what I meant.
21:01:08 <Koterpillar> koz_: TupleSections
21:01:11 <EvanR> :t (,) <$> x *> y
21:01:13 <lambdabot> error:
21:01:13 <lambdabot>      Couldn't match expected type f a0 with actual type Expr
21:01:13 <lambdabot>      In the second argument of (<$>), namely x
21:01:22 <glguy> neochronomo: That just tells you an old version of the file loaded before you added the next two definitions
21:01:28 <koz_> Koterpillar: Just realized.
21:01:37 <Koterpillar> :t ((,) x) <$> y 
21:01:39 <lambdabot> error:
21:01:39 <lambdabot>      Couldn't match expected type f b with actual type Expr
21:01:39 <lambdabot>      In the second argument of (<$>), namely y
21:01:43 <neochronomo> glguy: I added them all at once.
21:01:50 <Koterpillar> :t ((,) x) <$> yyy 
21:01:52 <lambdabot> error: Variable not in scope: yyy :: f b
21:02:03 <Koterpillar> :t \x y -> ((,) x) <$> y 
21:02:10 <lambdabot> Functor f => a -> f b -> f (a, b)
21:02:16 <neochronomo> glguy: the only thing I can think of is that Hugs didn't load the proper library to handle factorial or average for some reason
21:02:26 <glguy> nope, that's unlikely
21:02:34 <glguy> those definitions don't need anything extra loaded
21:02:37 <neochronomo> glguy: then I have no idea
21:02:53 <glguy> Yeah, there's a variable you aren't sharing (and don't know to)
21:03:15 <neochronomo> glguy: that could be as well. I literally started learning an hour ago :P
21:04:43 <neochronomo> are all files in haskell called "modules" or is that something else?
21:04:58 <avalokite> Hello :-)
21:05:35 <avalokite> I feel as though I need to speak with Cale of ReinH 
21:05:57 <koz_> avalokite: What wisdom do you seek?
21:06:18 <EvanR> who doth enter
21:06:22 <koz_> Also, I am certain ReinH is not a place.
21:07:46 <avalokite> koz_: interpersonal; However, if you happen to know of resources where I can learn of how GHC works on the low-level, I'm very much interested to begin this journey
21:08:28 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary
21:08:47 <avalokite> infinite gratitude; take as much as you need geekosaur
21:08:56 <koz_> avalokite: Have you read this? http://dev.stephendiehl.com/hask/#ghc
21:09:48 <geekosaur> also the #ghc channel is good for compiler discussions, although over the past few days theyve been busy prepping ghc 8.0.2 and working out a dynamic linking issue on macOS Sierra
21:10:29 <avalokite> koz_: I have! It's also bookmarked :) Many thanks!
21:10:52 <cheater> hi guys
21:11:08 <neochronomo> glguy: Koterpillar: geppettodivacin: I downloaded GHCi and loaded my file. Same thing, it'll let me double and quadruple, but for factorial and average it gives me this: "Variable not in scope: factorial :: Integer -> t"
21:11:41 <geekosaur> @paste the actual file
21:11:41 <lambdabot> Haskell pastebin: http://lpaste.net/
21:11:45 <glguy> neochronomo: OK, then the file you're loading doesn't have those definition in it
21:11:50 <koz_> Is there a better way of throwing away Falses in a list than 'filter (== True)'?
21:11:57 <cheater> i would like to create a list of Bool. The first element should be True, and then you build the list this way: take what you have now, and duplicate it, negate all elements, and glue it onto the end. then again and again and so on. How would i do this? there must be a simple recursive formula for this
21:12:06 <koz_> Well, more exactly, counting Trues.
21:12:13 <cheater> hmm maybe with fix
21:12:20 <neochronomo> glguy: What do you mean?
21:12:25 <EvanR> koz_: make a counting combinator
21:12:47 <koz_> EvanR: I don't quite get what you mean.
21:12:53 <EvanR> (a -> Bool) -> [a] -> Int
21:13:22 <EvanR> dont construct a new list, just count
21:13:38 <koz_> EvanR: That looks like a fold.
21:13:40 <koz_> Thanks!
21:13:49 <glguy> neochronomo: The file you're loading with Hugs and GHC isn't the one you're pasting to the paste bin
21:13:49 <EvanR> you should use foldl' to implement it yeah
21:14:36 <EvanR> (and dont pass in (== True)) ;)
21:14:51 <cheater> so i tried something like this... fair_share_seq = fix $ \x -> x ++ (not <$> x)
21:14:54 <cheater> but it diverges
21:14:58 <neochronomo> glguy: wait, somehow you're right......... I closed my file and reopened it after saving, and the definitions for factorial and average aren't there. So my document program didn't actually save the file for some reason
21:18:51 <EvanR> neochronomo: jesus saves
21:19:41 <neochronomo> EvanR: [citation needed]
21:20:33 <EvanR> http://listsurge.com/wp-content/uploads/2015/10/jesus_saves_01.jpg
21:27:23 <koz_> OK, I'm not quite following how to use MonadState for a constraint. The idea is that I wanna write a function which finally spits out a computation resulting in a state of (Bool, Bool) and a value of Int.
21:27:29 <ReinH> geekosaur: lol
21:29:16 <EvanR> am i going to hell somehow for picking :->: as a type ctor
21:29:28 <jle`> nah
21:29:33 <EvanR> is it important (looks important)
21:30:35 <koz_> jle`: Could you help me write this signature? I currently have 'MonadState m => (Assignment -> a -> Bool) -> a -> Vector (Assignment, Bool) -> m Int', but I'm clearly missing something here - how do I indicate my state should be (Bool, Bool)?
21:30:38 <geekosaur> looks like an arrow wrapped in "oh god more type hackery"
21:30:48 <geekosaur> >.>
21:31:26 <jle`> :k MonadState
21:31:28 <lambdabot> * -> (* -> *) -> Constraint
21:31:31 <jle`> ^^ koz_ 
21:31:35 <jle`> :t get
21:31:35 <EvanR> we need OverLoaded -> 
21:31:37 <lambdabot> MonadState s m => m s
21:31:42 <koz_> jle`: Sorry, but that didn't really help me any.
21:31:50 <jle`> MonadState has two parameters
21:32:07 <jle`> "get" is an action in MonadState s m that produces an 's', the current state
21:32:16 <jle`> so, 's' is the type of the state
21:32:24 <ReinH> type f :-> g = forall a. f (g a)
21:32:34 <koz_> OK, so I'm returning 'm (Bool, Bool) Int' then?
21:32:54 <jle`> koz_: no, you're returning m Int
21:33:05 <jle`> with the constraint MonadState (Bool, Bool) Int
21:33:07 <jle`> er
21:33:09 <jle`> MonadState (Bool, Bool) m
21:33:27 <koz_> OK, I need FlexibleConstraints.
21:33:36 <koz_> Thanks jle`!
21:34:00 <jle`> mhm
21:34:02 <jle`> no problem!
21:34:22 <koz_> s/Constraints/Contexts
21:34:23 <koz_> Argh.
21:34:30 <jle`> koz_: if you have a MonadState s m => ... constraint, then 'm' is a monad that uses an internal state of type s
21:34:42 <koz_> jle`: OK, that makes sense.
21:34:51 <koz_> I *will* learn this 'monadic programming' thing, I swear!
21:35:29 <jle`> this might be more like, programming for generic monads i guess heh
21:35:42 <koz_> jle`: I thought that's what you're meant to do nowadays?
21:35:52 <koz_> (or at least, I heard Ed say so in a talk he gave recently)
21:35:58 <jle`> you don't have to :o
21:37:58 <koz_> jle`: Should I, though?
21:42:27 <jle`> you can! but i was just saying that this is different than "monadic programming" in general
21:42:43 <koz_> jle`: Fair enough.
21:43:44 <koz_> Also, is there a simpler way to write this? http://lpaste.net/245972
21:44:38 <koz_> (it will get a better name than foo, obviously)
21:47:18 <Clint> koz_: i'd start by put (if res then (True, f) else (t, True))
21:48:27 <koz_> Clint: Oh, derp. Thanks!
21:49:48 <koz_> Clint: Is this better? http://lpaste.net/245972
21:50:37 <geppettodivacin> koz_: I personally appreciated match.
21:50:52 <geppettodivacin> It makes it more readable by giving it a good name.
21:51:31 <geppettodivacin> Also, any reason you wouldn't want to break out the monad into a separate variable? (For the same reason -- self-documentation.)
21:52:02 <koz_> geppettodivacin: Sorry, what do you mean by 'the monad' here?
21:52:10 <geppettodivacin> The do block.
21:52:31 <geppettodivacin> Or, probably better, that entire lambda could be called something.
21:56:15 <koz_> geppettodivacin: I was gonna do the whole thing in a where-bind in a different function anyway. That was just so I could be clear to myself on what the types were etc.
21:57:08 <geppettodivacin> Got it.
21:58:49 <koz_> Yay, I officially *adore* monads.
21:59:36 <Kuros-> that's nice, they've been kicking my ass for weeks
22:00:43 <koz_> Kuros-: Lol, they used to kick mine, but then I got help from jle`, and henceforth, the horizontal surfaces have rotated.
22:00:54 <koz_> s/horizontal surfaces/horizontal storage surfaces
22:01:51 <Kuros-> i'll grok them one day, but monad transformers brings the fight to another level
22:02:14 <koz_> Kuros-: I'm slowly working my way up to that.
22:02:28 <Koterpillar> try extensible effects
22:02:58 <EvanR> indexed monad transformers! comonad transformers!
22:03:14 <EvanR> the fun dont stop
22:03:19 <koz_> When does the feeling of achievement from wrestling monads into shape and making them do your bidding stop?
22:03:49 <EvanR> next thursday, then youll be struggling with profunctors
22:03:51 <Kuros-> after about 5 seconds when your code doesn't even compile
22:04:12 <koz_> Kuros-: Mine compiled file. EvanR: Well, that's worrying.
22:16:46 <JohnnyL> is the alebraic space very wide and deep for haskell? it seems to go on and on.
22:16:53 <JohnnyL> algeraic.
22:16:56 <JohnnyL> shit
22:16:59 <JohnnyL> algebraic.
22:17:00 <JohnnyL> hehe
22:19:39 <JohnnyL> wow ok.
22:20:08 <JohnnyL> so cat /dev/sr0 > image.iso leds to an tiny screen that can't get past the menu.
22:21:54 <ania123> I do not understand example 4.2
22:21:56 <ania123> https://www.haskell.org/tutorial/patterns.html
22:22:13 <ania123> why take1 0 bot	=>	_|_
22:22:13 <ania123> ?
22:23:29 <Koterpillar> ania123: the first equation for take1 tries to compare 'bot' to '[]'
22:23:51 <ania123> yes, but with second eq of take1
22:23:55 <ania123> it has to match
22:24:16 <ania123> if first attempt was not succesfful it should try for second eq
22:24:17 <ania123> no?
22:24:17 <Koterpillar> _before_ the second equation is considered, it tries to match bot to [], which results in _|_
22:24:32 <tippenein> would it be better to run system calls to ffmpeg or hope the ffmpeg-light library has what I'll need
22:24:42 <Koterpillar> and _|_ doesn't backtrack or anything, it's an immediate _|_
22:24:46 <ania123> does system returns such intermediate results?
22:25:10 <Koterpillar> ania123: it doesn't return them...
22:25:18 <ania123> ok
22:25:19 <ania123> thx
22:25:39 <Koterpillar> ania123: when _|_ is matched, the whole expression we're considering becomes _|_
22:25:59 <ania123> clear
22:26:39 <ski> ania123 : it's not that "first attempt was not successful". it's that it get stuck attempting to check the first. we express "get stuck" as "returns `_|_'"
22:27:40 <babu`> emacs intero: is there a fix for "Warning (intero): Couldnt get the Stack project root."?
22:30:54 <ania123> ski, principle of inference here is similar to prolog?
22:30:55 <ania123> no
22:31:03 <ania123> just unification is replaced by matching
22:31:15 <ania123> if we take a function
22:31:17 <Koterpillar> in Prolog, _|_ would be defined as x = x
22:31:38 <Koterpillar> (same thing, actually)
22:31:40 <ania123> foo x = something
22:31:41 <ski> Prolog has bidirectional matching, aka unification. Haskell only unidirectional matching (pattern matching)
22:32:00 <ania123> and we wont to compute foo value
22:32:09 <ania123> x--> value will be genrated
22:32:16 <ania123> and we have goal
22:32:25 <ski> however, *types* are unified in Haskell, in a way similar to values in Prolog
22:32:25 <ania123> something {x->value}
22:32:27 <ania123> no?
22:32:45 <ski> yes
22:32:59 <ski> (s/goal/result expression/)
22:33:05 <ania123> ok
22:33:40 <ski> (type classes are also a bit similar to Prolog predicates. no backtracking for the former, though)
22:34:33 <ski> Koterpillar : `X = X' is equivalent to `true' .. i don't see how that would be related to `_|_'
22:34:51 <Koterpillar> x := x
22:35:02 <Koterpillar> I forgot quite a lot of syntax <_<
22:35:16 <ski> oh, you mean `x :- x.'
22:35:22 <Koterpillar> right
22:35:23 <ania123> x:-x.
22:35:24 <ania123> ?
22:35:30 <ania123> ok
22:35:45 <ania123> x is a consttant here
22:35:46 <ania123> :)
22:36:03 <ski> it's still only a rough correspondence, though
22:36:04 <Koterpillar> well, then disregard this analogy as an incomplete and confusing one
22:36:35 <ski> (since you don't associated computations with expressions (called terms) in Prolog. you associated them with goals)
22:38:54 <mgsloan> babu`: Make sure there's a stack.yaml somewhere
22:43:47 <dmj`> is it possible to have type level floats
22:44:20 <mgsloan> Not directly, dmj`, could simulate them with type level nats
22:44:27 <Koterpillar> floats or rationals?
22:45:01 <ski> unification of rationals could be interesting
22:46:42 * ski . o O ( `2 / x = x / 8' resulting in `x = 2', preferably )
22:48:12 <ania123> ski, pattern in haskell is just argument of function
22:48:17 <ania123> foo arg = ...
22:48:23 <ania123> arg is pattern
22:48:25 <ania123> is not?
22:48:41 <ski> `arg' is a pattern there, yes
22:49:17 <ski> also in `case .. of <pat> -> ...', `<pat>' can be any pattern
22:49:21 <dmj`> mgsloan: ah, thanks.
22:49:29 <dmj`> Koterpillar: specifically float
22:49:47 <ski> (so it doesn't have to be "argument of function")
22:49:54 <dmj`> @def data (...) (a :: Nat) (b :: Nat)
22:49:56 <lambdabot>  .L.hs:185:18: error: Not in scope: type constructor or class Nat
22:49:56 <lambdabot>  
22:49:56 <lambdabot>  .L.hs:185:29: error: Not in scope: type constructor or class Nat
22:50:07 * ski blinks
22:50:49 <dmj`> lambdabot needs some extensions
22:51:24 <dmj`> type Pi = 3 ... 14159
22:52:07 <Koterpillar> I thought it would be more like a list of digits
22:52:33 <ski> would probably be easier
22:53:55 <dmj`> yea but wouldn't be as clear as to where the decimal point starts and ends
22:54:12 <ski> two lists ?
22:54:35 <ski> (the point being that the ordering for the decimals here is the wrong one)
22:55:07 <ski> (by ordering, i don't mean the order in which the decimals are listed in. i mean the ordering on the natural numbers used to represent them here)
22:55:58 <ski> `14159' ought here to be equivalent to `141590' .. but as `Nat's, those have different magnitude
22:56:27 <ski> representing them as `95141' resp. `095141' would at least fix that issue
22:56:55 <ski> (but then the carry will go in the wrong way, for addition, of course. not to mention multiplication)
23:01:45 <dmj`> hmm, I see
23:42:22 <jle`> that feeling when your code unexpectly compiles after a lot less work than you thought it'd take
23:42:29 <koz_> What instances can GHC autoderive for me (modulo appropriate flags)?
23:42:33 <koz_> jle`: Yep, it is *great*!
23:44:09 <srhb> koz_: Aside from the usual suspect, there's Functor, Typeable, Generic, Foldable, Traversable
23:44:16 <srhb> koz_: I can't remember any others off hand
23:44:40 <jle`> Data i think but nobody uses that anymore
23:44:50 <jle`> and then of course it can derive a bunch of random things with GeneralizedNewtypeDeriving
23:44:57 <jle`> most "simple" typeclasses
23:45:02 <jle`> fsvo simple
23:45:08 <srhb> Oh there Ix too. I always forget that.
23:45:31 <ski> `Ix' doesn't belong to the "usual suspects" ?
23:46:02 <srhb> I suppose it does.
23:46:08 <srhb> I've just never used it, really.
23:46:13 <jle`> can it really derive Ix ? that's neat i guess
23:46:38 <jle`> koz_: but with GHC.Generics, a lot of typeclasses can be "derived" on the user-end without needing to hack GHC
23:46:53 <jle`> for classes like ToJSON, FromJSON, Binary, etc.
23:47:56 <dmj`> > from (Just 1)
23:47:58 <lambdabot>  error:
23:47:58 <lambdabot>       Couldn't match type Maybe Integer
23:47:58 <lambdabot>                       with Control.Lens.Internal.Iso.Exchange a b a (Identit...
23:49:22 <ski> `Ix' is one of the things one'd prefer not have to write by hand
23:49:43 <koz_> ski: Yah, I can understand that.
23:53:31 <srhb> The docs say: Derived instance declarations for the class Ix are only possible for enumerations (i.e. datatypes having only nullary constructors) and single-constructor datatypes, including arbitrarily large tuples, whose constituent types are instances of Ix.
23:55:56 <ski> @let data Foo = F Bool Bool deriving (Eq,Ord,Ix)
23:55:59 <lambdabot>  Defined.
23:58:24 <jle`> @let deriving instance Show Foo
23:58:26 <lambdabot>  Defined.
23:58:36 <jle`> > range (Foo False False, Foo True True)
23:58:39 <lambdabot>  error:
23:58:39 <lambdabot>      Data constructor not in scope: Foo :: Bool -> Bool -> aerror:
23:58:39 <lambdabot>      Data constructor not in scope: Foo :: Bool -> Bool -> a
23:58:46 <jle`> > range (F False False, F True True)
23:58:48 <lambdabot>  [F False False,F False True,F True False,F True True]
23:59:50 <jle`> > F <$> range (False,True) <*> range (False,True)
23:59:52 <lambdabot>  [F False False,F False True,F True False,F True True]
