00:00:13 <jle`> oh, lens doesn't even use the built-in 'sequence' from vector, it just converts the vector into a list, sequenceA's the list, and packs it back into a vector
00:00:24 <jle`> sounds kind of wasteful but i guess there's fusion
00:00:36 <jle`> would be a lot simpler if there was just sequenceA/generateA
00:07:41 * hackagebot stb-image-redux 0.2.0.0 - Image loading and writing microlibrary  https://hackage.haskell.org/package/stb-image-redux-0.2.0.0 (sasinestro)
00:07:41 * hackagebot typed-process 0.1.0.0 - Run external processes, with strong typing of streams  https://hackage.haskell.org/package/typed-process-0.1.0.0 (MichaelSnoyman)
00:11:32 <bollu> how do I make a data constructor inside a [d| .. |]
00:11:43 <bollu> I know what the name of the data constructor should be (I have a string)
00:17:59 <ongy> Can I easily expand the Get monad (Monad transformers?) from cereal (or binary)? Because of the format I
00:18:21 <ongy> need to parse, needs me to know the current position in the message at times
00:28:01 <saurabhnanda> geekosaur: so, if I understand it correctly, the aeson generic toJson & fromJson are "inspecting" the objects at runtime? If there is a bug in the genericJSON function then compiler wont be able to catch it?
00:29:51 <saurabhnanda> is there an easy way to apply a type-level function to all fields of a record? here's what I'm trying to do: https://gist.github.com/saurabhnanda/4e5364c460ea455051c4e0c91cfbec63
00:39:59 <ongy> -.- I thought http://hackage.haskell.org/package/pack might be nice, then I took a look at the dependencies. lens? I don't want half of hackage as dependency
00:46:05 <saurabhnanda> Help please: http://stackoverflow.com/questions/40171037/apply-a-function-to-all-fields-in-a-record-at-the-type-level
00:51:36 <bollu> I need to refer to a data constructor to pattern match in template haskell
00:51:47 <bollu> something like \(outer inner) -> inner
00:51:53 <bollu> how the hell do I generate this using TH?
00:52:03 <bollu> the documentation is aggravating >_>
00:53:17 <ongy> saurabhnanda: http://lpaste.net/286858 (the boilerplate is for being compilable). You can do this, but you will have to make it possible in your type defintion. You can then use https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Functor-Identity.html for the "normal" version
00:58:22 <saurabhnanda> ongy: thanks. Taking a look.
00:58:49 <MarcelineVQ> bollu: A lot of the most useful stuff is in the "Constructors lifted to Q" section if you haven't seen them. Do you have a specific example of what you're working on?
00:59:47 <saurabhnanda> ongy: basically I have to define my "base" type to be parameterized over 'f'? Which means that using the base type is going to become a pain!
01:00:02 <saurabhnanda> ongy: is Identity String equivalent to String?
01:00:52 <bollu> MarcelineVQ: yes, I'm trying to derive MonoFunctor
01:01:01 <saurabhnanda> ongy: or is runIdentity (Identity String) equivalent to String?
01:01:03 <bollu> MarcelineVQ: lemme throw up a quick dist
01:05:08 <bollu> MarcelineVQ: https://gist.github.com/bollu/19ac6d663678b4b52f7e5b7059038e4e
01:07:07 <bollu> MarcelineVQ: any ideas how? I don't know how to emit the pattern match destructure (MonoCons fa) 
01:07:37 * hackagebot wai-extra 3.0.19 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.19 (MichaelSnoyman)
01:07:39 * hackagebot udp-conduit 0.1.0.4 - Simple fire-and-forget conduit UDP wrappers  https://hackage.haskell.org/package/udp-conduit-0.1.0.4 (kqr)
01:07:41 * hackagebot hablog 0.4.1 - A blog system  https://hackage.haskell.org/package/hablog-0.4.1 (gilmi)
01:09:10 <bollu> saurabhnanda: don't quote me on this, but Identity String should be equivalent to String, since we have Identity :: String -> Identity String, and runIdentity :: Identity String -> String
01:09:17 <bollu> saurabhnanda: so we get an isomorphism of types
01:09:35 <bollu> since runIdentity . Identity = id
01:09:43 <saurabhnanda> bollu: it's an isomorphism, but a pain to use
01:10:00 <m1dnight_> Im trying to get uniplate to work but ghc says the compiler extension is invalid: DerivingDataTypeable
01:10:07 <m1dnight_> Google literally has 0 results :<
01:10:12 <saurabhnanda> bollu: I can't pass an 'Identity String' to something that expects a String
01:10:45 <m1dnight_> I'm on GHC 8.0.1
01:10:50 <bollu> saurabhnanda: liftM should work, right?
01:11:02 <bollu> > liftM (++ "bar") (Identity "foo")
01:11:05 <lambdabot>  Identity "foobar"
01:11:31 <bollu> :t liftA3
01:11:33 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
01:11:44 <bollu> any of the liftA<x> should be able to lift to identity
01:11:47 <ongy> or fmap, it's a functor. But that's also the reason I didn't put it up on SO as "here's an answer" it's an idea, but it will be rather painful. Also your Omit is basically Maybe, no need to redefine it
01:12:09 <MarcelineVQ> m1dnight_: was it something you typed yourself? DeriveDataTypeable is probaly what you'd like
01:12:47 <bollu> MarcelineVQ: I was wondering if you knew how to emit the pattern match code. I tried using [d| \$(<some Pat function>) -> …|] but it says "syntax error"
01:12:48 <m1dnight_> No, it's straight from the uniplate docs. And I tried that extension already and that breaks. It's supposed to allow me to write data .. deriving(Data, Typeable) but then that gets denied
01:12:54 <m1dnight_> http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm
01:12:56 <m1dnight_> That's the docs
01:17:50 <jophish> m1dnight_: DeriveDataTypeable
01:17:56 <jophish> not DerivingDataTypeable
01:18:06 <MarcelineVQ> $(..) isn't a pattern so it's a syntax error to have it after a lambda slash, additionally d| is for declarations which aren't where lambdas live anyway, they're expressions. I'm not sure how to read what you're working on with the Mono stuff so I don't have much to offer
01:18:29 <m1dnight_> Yes, that's what I tried, but then  deriving (Show, Eq, Data, Typeable) get's rejected. At least, the Data and Typeable classes.
01:18:45 <m1dnight_> I've fixed the Typeable one by importing `Data.Typeable`
01:18:45 <jophish> can you post an error please?
01:18:49 <m1dnight_> Yes, sec 
01:18:53 <jophish> and Data.Data (Data) for data?
01:20:21 <m1dnight_> Ah, that last import fixed it.
01:20:28 <m1dnight_> Damn those docs! :)
01:20:31 <m1dnight_> Thanks for the help guys!
01:20:35 <jophish> np
01:21:25 <m1dnight_> Thanks for the help guys!
01:21:28 <m1dnight_> oops, wrong window
01:22:15 <MarcelineVQ> bollu: Actually I'm wrong, having tried it just now, $(..) is valid there
01:23:16 <MarcelineVQ> nvm, double wrong, had my $ in the wrong spot :>
01:23:45 <saurabhnanda> ongy: they only reason I've defined an Omittable is to make the internal communication clear -- wrapped Maybe's will confuse people. Maybe (Maybe String)
01:24:33 <saurabhnanda> ongy: any extensible records library that can give an easier solution?
01:24:57 <saurabhnanda> ongy: also, can Generics/Data/Typeable take a type-level constructor and return a new type-level constructor at compile time?
01:25:03 <ongy> I don't know. But I can't say it doesn't exist either
01:26:46 <ongy> saurabhnanda: https://wiki.haskell.org/Template_Haskell#Generating_records_which_are_variations_of_existing_records template haskell may be the way to go
01:28:40 <saurabhnanda> there's a wiki for that... 
01:30:41 <saurabhnanda> ...and the wiki went way over my head. 
01:31:09 <ongy> template haskell?
01:32:24 <saurabhnanda> ongy: yep -- they link you shared.
01:33:18 <bollu> MarcelineVQ: yeah it doesn't work
01:33:24 <bollu> MarcelineVQ: so what's the correct way to do this
01:37:59 <MarcelineVQ> I don't know for sure, What are the definitions of Func and Element so I can work on a version of this the compiler will accept?
01:39:02 <bollu> Element comes from mono-traversable
01:39:29 <bollu> Func is any functor. Pick Identity if you want to :)
01:41:14 <MarcelineVQ> alrighty, let's see
01:51:26 <ania123> sorted xs = and [x <= y | (x,y) <- pairs xs]
01:51:36 <ania123> why is needed and here?
01:53:06 <jle`> ania123: have you tried seeing what it does without and?
01:53:18 <ania123> did not
01:53:28 <jle`> what is [ x <= y | (x, y) <- pairs xs ] ?
01:54:20 <ania123> pairs xs returns pairs of adjanet elements of xs
01:54:40 <jle`> and what is [ x <= y | (x, y) <- pairs xs ] ?
01:54:45 <jle`> are you familiar with list comprehensions?>
01:54:59 <ania123> yes
01:55:01 <ania123> I am
01:55:15 <bollu> how do I dump out code being generated by a template haskell expression that is failing?
01:55:22 <ania123> list of elements
01:55:27 <ania123> x<=y
01:56:47 <jle`> ania123: it's not a list of elements
01:56:57 <jle`> or well, not elements of xs
01:57:06 <jle`> it's a list of ... what type are the values in that list?
01:57:10 <ania123> (x, y) <- pairs xs
01:57:14 <ania123> it is a generator
01:57:17 <ania123> which generates
01:57:22 <ania123> pars of its elements
01:57:45 <jle`> and so what are the elements of [ x <= y | (x, y) <- pairs xs ] ?
01:57:48 <jle`> are they ... strings?
01:57:51 <ania123> no
01:57:53 <jle`> doubles?
01:57:54 <ania123> integers
01:57:59 <jle`> not quite
01:58:13 <jle`> in a list comprehension, [ ... something ... | (x,y) <- pairs xs ]
01:58:24 <jle`> every item in the list is the result of "... something ..."
01:58:30 <ania123> sorted :: Ord a => [a] -> Bool
01:58:31 <jle`> every item in the resulting list
01:58:37 <jle`> for example:
01:58:42 <jle`> > [ x*2 | x <- [1..10] ]
01:58:45 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
01:58:48 <jle`> every item in my resulting list is the "x*2"
01:59:00 <jle`> > [ x < 5 | x <- [1..10] ]
01:59:03 <lambdabot>  [True,True,True,True,False,False,False,False,False,False]
01:59:07 <jle`> every item in the resulting list is the "x < 5"
01:59:44 <Glitchy> > [ x <= y | (x, y) <- pairs (1, 2, 3, 4) ]
01:59:47 <lambdabot>  error:
01:59:47 <lambdabot>      Variable not in scope:
01:59:47 <lambdabot>        pairs :: (Integer, Integer, Integer, Integer) -> [((), ())]
01:59:52 <jle`> so, in [ x <= y | (x, y) <- pairs xs ], every item in the resulting list is the "x <= y"
01:59:53 <ania123> ah, i see
01:59:54 <ania123> thx
01:59:55 <jle`> they're bools
02:00:08 <Glitchy> > [ x <= y | (x, y) <- pairs [1, 2, 3, 4] ]
02:00:11 <lambdabot>  error:
02:00:11 <lambdabot>      Variable not in scope: pairs :: [Integer] -> [((), ())]
02:00:12 <ania123> clear
02:00:19 <jle`> it's a list of bools of whether or not each adjacent pair is ordered x <= y
02:00:41 <jle`> Glitchy: i'm guessing that pairs is provided as a part of ania123 's exercise -- it's not a standard library function
02:00:51 <jle`> @let pairs xs = zip xs (drop 1 xs)
02:00:55 <lambdabot>  Defined.
02:00:56 <Glitchy> jle`: Yeah I'd never heard of it, that's why I was trying it :)
02:01:19 <ania123> pairs is defined using zip function
02:01:23 <jle`> > [ x <= y | (x,y) <- pairs [1,4,2,3,10] ]
02:01:26 <lambdabot>  [True,False,True,True]
02:01:46 <Glitchy> That makes sense
02:02:00 <jle`> > pairs "hello"
02:02:03 <lambdabot>  [('h','e'),('e','l'),('l','l'),('l','o')]
02:05:03 <jophish> > (zip`ap`tail) "hello"
02:05:06 <lambdabot>  [('h','e'),('e','l'),('l','l'),('l','o')]
02:05:19 <jophish> @quote zip`ap`tail
02:05:19 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
02:06:48 <ahihi> > (zip<*>tail) "hello" -- shorter!
02:06:50 <lambdabot>  [('h','e'),('e','l'),('l','l'),('l','o')]
02:07:18 <jophish> ahihi: but then lambdabot doesn't get to quote!
02:07:30 <ahihi> :3
02:07:39 * hackagebot cuda 0.7.5.1 - FFI binding to the CUDA interface for programming NVIDIA GPUs  https://hackage.haskell.org/package/cuda-0.7.5.1 (TrevorMcDonell)
02:13:45 <Myrl-saki> Wait, wtf.
02:13:49 <Myrl-saki> Oh.
02:14:13 <Myrl-saki> drop 1 []
02:14:17 <Myrl-saki> > drop 1 []
02:14:19 <lambdabot>  []
02:14:20 <Myrl-saki> > tial []
02:14:23 <lambdabot>  error:
02:14:23 <lambdabot>      • Variable not in scope: tial :: [t0] -> t
02:14:23 <lambdabot>      • Perhaps you meant one of these:
02:14:24 <Myrl-saki> > tail []
02:14:27 <lambdabot>  *Exception: Prelude.tail: empty list
02:14:43 <Myrl-saki> > (zip <*> drop 1) "hello"
02:14:46 <lambdabot>  [('h','e'),('e','l'),('l','l'),('l','o')]
02:15:01 <Myrl-saki> jophish: ahihi: More robust! :3
02:15:09 <ahihi> > (zip<*>tail) []
02:15:12 <lambdabot>  []
02:15:14 <ahihi> not really :)
02:15:14 <Myrl-saki> Oh.
02:15:24 <Myrl-saki> > (zip <$> tail) []
02:15:27 <lambdabot>  error:
02:15:27 <lambdabot>      • No instance for (Typeable b0)
02:15:27 <lambdabot>          arising from a use of ‘show_M126208380266792973630142’
02:15:34 <Myrl-saki> Wait wut
02:15:59 <Myrl-saki> Oh. Right.
02:16:05 <Myrl-saki> <$> == .
02:16:09 <ahihi> :t (zip <$> tail)
02:16:11 <lambdabot> [a] -> [b] -> [(a, b)]
02:16:15 <Myrl-saki> Yeah.
02:16:24 <Myrl-saki> :t (zip =<< tail)
02:16:26 <lambdabot> [b] -> [(b, b)]
02:16:34 <Myrl-saki> > (zip =<< tail) []
02:16:36 <lambdabot>  *Exception: Prelude.tail: empty list
02:16:40 <Myrl-saki> There we go.
02:16:44 <Myrl-saki> > (zip =<< tail) "hello"
02:16:47 <lambdabot>  [('e','h'),('l','e'),('l','l'),('o','l')]
02:16:55 <ahihi> :D
02:17:14 <Myrl-saki> Zip checks the first argument, I guess.
02:17:20 <Myrl-saki> Reminds me of
02:17:24 <Myrl-saki> > fix (0*)
02:17:30 <lambdabot>  mueval-core: Time limit exceeded
02:17:32 <Myrl-saki> >fix (*0)
02:17:47 <Myrl-saki> > fix (*0)
02:17:56 <lambdabot>  mueval-core: Time limit exceeded
02:18:02 <Myrl-saki> Oh wait. They patched that?
02:18:11 <Myrl-saki> > fix (False &&)
02:18:16 <lambdabot>  False
02:18:18 <ahihi> fix (*0) works in my ghci
02:18:18 <Myrl-saki> > fix (&& False)
02:18:28 <lambdabot>  mueval-core: Time limit exceeded
02:18:37 <jophish> fix (^0) -- Myrl-saki: perhaps you're thinking of 
02:18:43 <Myrl-saki> Man. Pattern matching is weird.
02:18:51 <jophish> > fix (^0) -- even
02:18:54 <lambdabot>  1
02:18:58 <implementation_> > swap <$> (zip =<< tail) "hello"
02:19:01 <lambdabot>  [('h','e'),('e','l'),('l','l'),('l','o')]
02:19:18 <quchen> Pattern matching is left-to-right, top-to-bottom. Not really all that weird.
02:19:31 <Myrl-saki> quchen: I know. But it makes equivalent stuff... not equivalent.
02:19:44 <quchen> It enforces ordering, yes.
02:20:23 <Myrl-saki> quchen: The thing about (&& False) and (False &&) made me question my whole life.
02:21:42 <quchen> Many languages have subtle differences in the way && is handled, Haskell is probably one of the less weird ones. Often, && is lazy in its second argument in other languages, which allows you to do silly things if you pair it with impurity.
02:21:57 <Myrl-saki> quchen: Yep.
02:22:04 <quchen> openConnection || error "failed"
02:22:33 <Myrl-saki> quchen: Though, there were apparently some work on concurrent pattern matching..
02:22:47 <quchen> Sure,
02:22:50 <quchen> ?hackage unamb
02:22:51 <lambdabot> http://hackage.haskell.org/package/unamb
02:25:56 <tsahyt_> Hello! I'm binding to a C function that takes a struct as an argument (NOT a pointer to it) for some reason. I've written a storable instance, but GHC tells me that using it in the FFI signature is an "unacceptable argument type in foreign declaration". How can I pass a struct?
02:29:56 <fred-fri> i have this method that accepts a tuple, i want to restrict it so it only accepts a tuple of int, but my attempts to edit the signature fail... http://pastebin.com/AZdSJWWg
02:31:05 <tsahyt_> fred-fri: what's wrong with tscore :: (Int, Int) -> (Int, Int)?
02:31:33 <tsahyt_> or (Num a, Num b) => (Int, Int) -> (a, b)
02:31:41 <fred-fri> gaaah thanks
02:34:40 <fred-fri> ok, another reaaaaally stupid question. given a tuple eg (1, 4), how can i output 1 4
02:35:06 <fred-fri> ive tried putStrLn, print, various combinations of ++ etc
02:35:46 <fred-fri> eg print ((fst scores) ++ " " ++ (snd scores))
02:39:26 <ahihi> fred-fri: putStrLn $ show (fst scores) ++ " " ++ show (snd scores)
02:41:27 <fred-fri> cheers
02:41:55 <ahihi> if you're doing a lot of this sort of thing, you might find one of the printf packages useful
02:43:02 <fred-fri> sounds like something i should look into
02:43:24 <fred-fri> im doing hackerrank challenges and they have lots of stupid requirements in terms of parsin from sysin and printing of various things to sysout
02:45:49 <fred-fri> most of the challenges can be more or less trivially solved by using various existing functions. all you need to do is compose them. as such, i find myself questioning if and how to organise the compositions into functions of my own
02:46:17 <fred-fri> an example: https://gist.github.com/androidfred/2e45c322945f1ae35b3f4a23fe976c16
02:46:33 <fred-fri> having it all in a single line is a bit unreadable
02:47:01 <fred-fri> at the same time, no matter how i slice and dice the composition into "my own" functions, any such organization is more or less arbitrary and just introduces more things to keep track of
02:47:19 <jophish> fred-fri: you might find things easier to use =<< instead of >>=
02:47:19 <fred-fri> so i elect to do things on a single line if possible and comment liberally
02:47:28 <jophish> especially when mixing with .
02:48:05 <fred-fri> jophish, how would you reorganize the line? id be very interested to see
02:49:20 <jophish> fred-fri: so it gets one integer = n, reads n integers and sums them?
02:49:33 <fred-fri> correct
02:50:13 <jophish> I'd probably split the reading of the integers from the calculation (since this is probably something you'll be doing again)
02:54:27 <jophish> fred-fri: something like this perhaps https://gist.github.com/1da20d12f653287f78688ef37844e8f8
02:55:31 <jophish> for something more complex I'd advocate splitting up the IO and the reading to make things easier to test
02:55:34 <fred-fri> that makes absolute sense
03:03:12 <sphinxo> What is the semantic difference between these two type families http://lpaste.net/4520673578366009344 ?
03:13:35 <quchen> sphinxo: The first one gives you a function of kind * -> * -> Bool
03:13:56 <quchen> The second one is more flexible with k -> k -> Bool
03:15:47 <quchen> try “typeEqual Maybe []”, sphinxo 
03:16:47 <sphinxo> quchen: woah
03:17:29 <quchen> It also works with constraints now
03:17:43 <quchen> TypeEqual Applicative Monad
03:18:08 <quchen> TypeEqual (Applicative Int) (Monad Bool)
03:18:14 <quchen> … and so on
03:18:31 * sphinxo mind blown
03:19:18 <quchen> Wait, Applicative Int does not kind-check.
03:20:55 <quchen> sphinxo: You can go one step further and create “k -> l -> Bool”, then you can write
03:21:00 <quchen> TypeEqual Applicative Int
03:21:06 <sphinxo> what is l?
03:21:10 <quchen> Some other kind
03:21:17 <sphinxo> damn
03:21:22 <quchen> type family Equal (a::k) (b::l) :: Bool where Equal a a = True; Equal a b = False
03:21:35 <quchen> Now: Equal :: k -> l -> Bool
03:21:43 <sphinxo> This is so awesome
03:22:14 <sphinxo> and mostly useless, except for a few circumstances
03:22:38 <quchen> It’s not really useless, but the use cases are very limited
03:23:27 <quchen> Tinkering around this stuff is fun, but using it for actual programming has poor return on investment in my experience
03:24:08 <quchen> As dons put it, “Haskell 98 is enough for most things”
03:25:11 <sphinxo> what is an example use case of this kind of stuff @quchen?
03:25:29 <sphinxo> or just a simple example
03:26:26 <quchen> Well, it allows you to push more things into the type system. servant makes heavy use of this sort of machinery, for example.
03:26:42 <sphinxo> oh ok, that's interesting
03:27:01 <quchen> You basically trade an increase in safety for an increase in the difficulty to write these things.
03:27:18 <quchen> For a library, that’s sometimes a good trade: put the burden on the author, not the user
03:27:57 <quchen> Lennart built some DSL to express database relations in Haskell, he talked about this at the 2015 Haskell Exchange
03:30:24 <jophish> There's something very satisfying in Haskell programming when you can put a hole in an expression, have ghc tell you the type and know that there's only one thing you can put in there
03:30:33 <jophish> or at least have a very limited choice about what to put in
03:30:58 <jophish> It's a shame the compiler can't to the last part for you in Haskell
03:31:48 <jophish> of course, this probably requires putting more thoughts into the types like quchen said. It comes down to how much you can reuse that hard work
03:40:26 <ij> How do I make a list of nuples from the neighbour elements from a list with at least n elements? f [1,2,3,4,5] 2 = sloppy syntax: [12,23,34,45]
03:43:00 <clueless> hello guys : http://lpaste.net/287173 so I found this code that tells if the first string is inside the second string, but im trying to make it the other way around.. see if the second string is in the first, can I get some help plz?
03:43:06 <M2tias> ij: f x:y:xs = (x*10 + y) : f y:xs ?
03:43:18 <M2tias> and f [x] = []
03:43:44 <jophish> > (zip`ap`tail) "hello" -- ij
03:43:47 <lambdabot>  [('h','e'),('e','l'),('l','l'),('l','o')]
03:44:02 <jophish> probably not the clearest way of doing it :)
03:44:06 <jophish> but it's memorable
03:44:09 <M2tias> but he wanted nuples
03:45:20 <jophish> > (\l -> zip l (tail l)) "hello" -- ij
03:45:23 <ongy> clueless: have you seen flip?
03:45:23 <lambdabot>  [('h','e'),('e','l'),('l','l'),('l','o')]
03:48:08 <clueless> ongy: I have
03:48:32 <clueless> ongy: would your suggestion just be flip function string1 string2?
03:49:26 <geekosaur> clueless, if you simply tried to swap the parameters, did you also do so in the recursive call?
03:52:04 <clueless> geekosaur: hmm I swapped them in the contain function
03:52:08 <clueless> is that the correct place?
03:54:55 <geekosaur> it is the correct place, but you have to change it in 3 places
03:58:13 <clueless> geekosaur: http://lpaste.net/287173 Im getting an error for 
03:58:16 <clueless> *Superstring> contains "ray" "blueray" *** Exception: Prelude.tail: empty list
03:59:16 <geekosaur> you changed only one of the 3 places... and changed something else not in contains that shouldn't change
04:00:03 <clueless> geekosaur: just to be clear, prefix has to stay exactly the same?
04:00:06 <geekosaur> oh, you didn't do it quite the simplest way, that just scrambles things
04:00:08 <clueless> geekosaur: thnaks btws
04:00:11 <clueless> btw*
04:00:36 <geekosaur> you could do it that way and have to change both contains and prefix, but the change you made to prefix is just wrong
04:01:38 <clueless> geekosaur: no no, no complicated way haha
04:02:16 <clueless> geekosaur: this change is right right?     | contains (tail xs) ys = True
04:02:34 <geekosaur> yes, but now what about the other two?
04:05:31 <clueless> geekosaur: | prefix ys xs = True ?
04:05:54 <geekosaur> no
04:08:09 <voglerr> what does 1=2 do? 1==2 is still False...
04:09:25 <cinnamonbuns> Hello Haskell people! I am using `stack new hspec` but after I build and install, I cannot `import Test.Hspec`, it says `error: Failed to load interface for ‘Test.Hspec’ Use -v to see a list of the files searched for.`
04:10:25 <clueless> geekosaur: Can you help me out?
04:10:32 <ahihi> voglerr: it's matching the value 2 against the pattern 1, which would fail, but since the pattern doesn't bind any names, it's never evaluated
04:10:51 <clueless> any change I make I mostly end up w *** Exception: Prelude.tail: empty list
04:10:57 <ahihi> > let x@1 = 2 in x -- whereas this does fail
04:10:59 <lambdabot>  *Exception: <interactive>:3:5-11: Irrefutable pattern failed for pattern x@1
04:11:03 <cinnamonbuns> Running `stack list-dependencies` shows hspec in the list
04:11:21 <voglerr> ah, I see. thanks
04:13:56 <geekosaur> clueless, so in that code you originally pasted, was that the actual original code?
04:14:20 <geekosaur> because if it is, and it was looking for the second parameter in the first, it was buggy
04:15:09 <humanoyd> Why is there a `Functor m` class constraint in https://hackage.haskell.org/package/transformers-0.5.2.0/docs/src/Control.Monad.Trans.Except.html#line-183 ?
04:15:29 <geekosaur> ...oh, you edited the paste in place instead of annotating
04:15:39 <geekosaur> that does not help
04:16:01 <clueless> geekosaur: the second one... My bad learning to use
04:16:22 <clueless> i changed it back
04:16:42 <geekosaur> I used the revisions feature in lpaste to find the original
04:17:19 <yulax> hi folks
04:18:25 <geekosaur> humanoyd, because before ghc 7.10 Monad did not imply Functor
04:18:27 <yulax> i am trying to define the all function in terms of foldr.
04:19:27 <geekosaur> if you wanted Functor you had to either add a Functor constraint or use liftM (which "recovered" the functor from >>=)
04:20:50 <geekosaur> clueless, the original is still buggy, as it turns out
04:20:58 <yulax> i think this is the wrong way to do it though, so i am trying to come up with something in terms of filter, where if an item fullfills a condition, i perform foldr with a ++ operation
04:21:04 <lpaste> geekosaur annotated “No title” with “No title (annotation)” at http://lpaste.net/287173#a287231
04:21:44 <geekosaur> that changes both contains and prefix in the same way; it could be done without changing prefix, which would be a smaller change but would make prefix inconsistent in usage
04:21:50 <humanoyd> geekosaur: yeah, but even pre-AMP, I don't see what the functor instance is used for...there's no `fmap` in the function body
04:23:26 <geekosaur> humanoyd, but Functor is required for Applicative
04:23:41 <ongy> yulax: using foldr sounds better than something with filter
04:23:59 <geekosaur> even though it's not directly used there, creating the Applicative instance will fail unless you have a Functor instance
04:24:03 <yulax> thanks
04:24:35 <Henson> I'm trying to write a generic function to serialize a data type and add it to a MongoDB database.  I've written FromBSON and ToBSON typeclasses, but am wondering if there's a way to write a ToMongo typeclass in a way that it's able to supply a table name string to me in a generic way.  Simply making a "toMongo" function that returns a string doesn't compile because I'm not using an instance of...
04:25:50 <Henson> a from the class definition "class ToMongo a".  If I were somehow to make that work, it would be sufficient for adding things to the database, but a generic retrieve function wouldn't be able to determine the table from the type that will be extracted without an instance of it to work on.  Any suggestions?  I suspect there are some type extensions I am unfamiliar with that will help here.
04:26:09 <clueless> geekosaur: Before I look exactly at the changes you made, I got this contains "blueray" "ray" False
04:26:34 <geekosaur> hm, I think I made a mistake in trusting your description...
04:26:51 <geekosaur> the function I gave you wants:  contains subString string
04:27:05 <ongy> Henson: the compiler would not know which instance to take the function from. You can make the function take an argument of type a and ignore it in the function
04:27:11 <geekosaur> you are calling it as, and the original seemed to be: contains string subString
04:27:26 <geekosaur> which do you want, and which did you think the original was
04:28:03 <geekosaur> (the original was still buggy, either way; it would fail in some cases with 1-character strings, for no good reason)
04:28:35 <clueless> geekosaur: sorry if I mixed up, I want to be able to contains string substring which I thought (it worked like that) thats what I had in the beginning
04:28:46 <Henson> ongy: so something like "class ToMongo a where toMongo :: a -> String" and in instances have "toMongo _ = "table_name""
04:29:00 <clueless> sorry sorry.. thats what I want, but in the beginning it was working as contains substrins string
04:29:02 <ongy> something like that, yes
04:29:49 <Henson> ongy: or perhaps there's a better way to do this without using typeclasses.  I'm trying to make a generic function to add and extract things from database, and though making a typeclass for things that could be added and extracted is the right way to go, but maybe it's not the right way.
04:30:33 <ongy> Henson: you can transform your typeclass to a Record of functions, which may be nicer here
04:31:26 <arzav> test
04:31:45 <arzav> test
04:31:50 <Henson> ongy: I'm not too sure what that means.  Could you expand a bit on that?
04:32:57 <humanoyd> geekosaur: Would `instance (Functor (ExceptT e m), Monad m) => Applicative (ExceptT e m)` not work?
04:33:02 <hpc> instead of class Foo a where foo :: String -> a
04:33:11 <arzav> test2
04:33:29 <hpc> data Foo a = Foo {foo :: String}
04:33:35 <ongy> Henson: instead of 'class ToMongo a where toMongo :: a -> String ; getName :: a -> String' you have 'data ToMongo a = ToMongo { toMongo :: a -> String; getName :: String }' 
04:33:53 <geekosaur> hm, I think I copied one of the bugs into the reversed one too.
04:34:05 <hpc> er, String -> a
04:34:08 <hpc> or what ongy said
04:35:17 <lpaste> geekosaur annotated “No title” with “No title (annotation) (annotation)” at http://lpaste.net/287173#a287254
04:35:40 <hpc> Henson: it's a rough approximation of what type classes do, but at the value level instead of in the type system with uniqueness constraints and such
04:36:01 <hpc> you get fewer restrictions that way, and in your case you aren't using any of the knowledge those restrictions give you so it works out nicely
04:37:57 <Jero_> how can i start learning haskel
04:38:35 <humanoyd> Jero_: http://learnyouahaskell.com/
04:38:37 <Henson> Jero_: I started with "learn you a haskell for great good", and found it to be an excellent introduction guide.
04:38:38 <hpc> Jero_: there's a few good places to start
04:38:58 <hpc> LYAH is good, though lacks exercises so you need to have some project of your own to try things out with
04:39:02 <hpc> @where cis
04:39:02 <lambdabot> I know nothing about cis.
04:39:08 <hpc> @where cis194
04:39:08 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
04:39:25 <Jero_> thanks hpc
04:39:27 <hpc> this one is also good, and was used to teach classes
04:40:11 <hpc> there's also RWH
04:40:13 <hpc> @where rwh
04:40:13 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:40:38 <Henson> hpc, ongy: would that method help with determining the name of the table if the user is calling the generic function with a certain output type.  A function like "getAllRecords :: a", and when the user calls it as "getAllRecords :: Foo" it's able to see that "Foo" has a certain table name.
04:40:38 <hpc> which has a good back half, covering specific topics in each chapter
04:41:37 <Henson> Jero_: Real World Haskell covers some advanced stuff that LYAH doesn't.
04:41:41 <clueless> geekosaur: I see, thanks a lot, and now I know what u mean by the fail case, 
05:07:43 * hackagebot quickbench 1.0 - quick & easy benchmarking of command-line programs  https://hackage.haskell.org/package/quickbench-1.0 (SimonMichael)
05:08:38 * hackagebot cuda 0.7.5.1 - FFI binding to the CUDA interface for programming NVIDIA GPUs  https://hackage.haskell.org/package/cuda-0.7.5.1 (TrevorMcDonell)
05:08:38 * hackagebot quickbench 1.0 - quick & easy benchmarking of command-line programs  https://hackage.haskell.org/package/quickbench-1.0 (SimonMichael)
05:13:13 <lpaste> MarcelineVQ pasted “bollu th attempt” at http://lpaste.net/287347
05:14:39 <MarcelineVQ> @tell bollu TH attempt for your deriving, should work as an example http://lpaste.net/287347
05:14:39 <lambdabot> Consider it noted.
05:17:37 <fizbin> Is there any guaranteed order between exception delivery and MVar use? That is, if I have an initially empty mvar and in thread A do "throwTo threadB MyException >> putMVar mvar ()" and in thread B do "takeMVar mvar", am I guaranteed that threadB's takeMVar will be interrupted by the exception?
05:18:25 <oherrala> What's the proper way to terminate thread (made with forkIO) inside the thread itself? I'm nested deep inside dos so unwrapping all those to exit the function seems tedious
05:19:22 <oherrala> Something like myThreadId >>= killThread seems to work, but dunno?
05:19:42 <fizbin> oherrala: That's what I was going to suggest
05:22:19 <fizbin> Though if you'll be exiting from inside a pure computation (say, because you used  unsafePerformIO or unsafeInterleaveIO), you might want to consider using throwIO ThreadKilled instead.
05:23:03 <fizbin> The differences between the two are subtle, and only matter if you're buried inside a pure computation, and in that case it may depend on other things which one you want.
05:23:28 <oherrala> pure stuff should stay pure and also avoid exceptions :)
05:24:40 <Skami> Hi ! In the pipes library, is it possible to make request's argument depend on it's result, something like http://lpaste.net/287369. I tried using RecursiveDo, but Proxy does not seem to have a MonadFix instance. 
05:25:22 <Skami> s/request/respond
05:25:49 <fizbin> oherrala: A good philosophy if you can stick to it. In that case, there should be no difference between (myThreadId >>= killThread) and (throwIO ThreadKilled)
05:28:33 * hackagebot ngx-export 0.2.2.0 - Helper module for Nginx haskell module  https://hackage.haskell.org/package/ngx-export-0.2.2.0 (lyokha)
05:30:57 <oherrala> fizbin: sum types are much more fun to work with compared to exceptions
05:34:32 <fizbin> Sure. Another possibility instead of killing the thread or using throwIO is to explicitly do everything that you're now doing deep in nested IO-monad "do"s with "do"s in some other monad that provides a quick way out, like ExceptT () IO or something similar.
05:37:33 <fizbin> For example, I have a computation that can under certain conditions return early and the core of that computation is just: either id id `liftM` runExceptT (runCalculation' input) , where the return type of runCalculation' is ExceptT ResultType IO ResultType
05:51:32 <ertes> is there a program that i can quickly draw commutative diagrams with?  not something like LaTeX, but rather something with a GUI that can replace paper
05:57:57 <jacereda> ertes: have you tried graphviz? not a GUI, but once you get used to it it's quite productive
05:58:42 <ertes> jacereda: yeah, that might work, at least for my personal stuff
05:58:44 <capisce> what's the ~> notation in http://degoes.net/articles/modern-fp-part-2 ?
05:58:49 <sbrg> I use graphviz alot. If you use emacs, you can use it via org-mode, which will let you update the graph, hit C-c C-c (IIRC) and the results are displayed below
05:59:01 <sham1> Where exactly are you meaning capisce 
05:59:18 <capisce> sham1: map1 :: forall f g. (Functor f, Functor g) => f ~> g -> t f ~> t g
05:59:39 <ertes> capisce: i don't know scala, but it looks like natural transformations to me
05:59:56 <ertes> F ~> G  -- a natural transformation (or even monad morphism) from F to G
06:00:21 <ertes> sbrg: nice
06:01:41 <sham1> Yeah, org-mode is awesome that way
06:01:41 <sbrg> the biggest problem is probably layouting, though. you don't have very much control over layout. also, if you want to export it to tikz, there is a dot2tikz script online that I have used which worked pretty well.
06:02:50 <ertes> sbrg: the reason i'll probably not use it is that i'd like to draw diagrams in front of an audience this evening
06:02:58 <sbrg> aah. 
06:03:16 <ertes> i've used inkscape so far, but it doesn't help me at all with diagrams
06:04:17 <ertes> (for me personally diagrams somehow never helped…  it was always easier for me to just look at the equations and how they interact in proofs)
06:38:35 * hackagebot opencog-atomspace 0.1.0.5 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.5 (romanT)
07:06:07 <Regixtry> Hi - I've been playing around with StateT. If you have an existing call structure where the monad you're in changes through the function calls, is it possible to wrap the entire tree of calls in a state, rather than having to `get` and `put` in between the calls?
07:06:25 <Regixtry> The context here is that I want a bunch of tests with hspec that can morph the state of the world as they go
07:07:12 <Regixtry> the `describe` block as one type, the `it` calls then go in to a different monad
07:09:32 <Regixtry> I guess my question boils down to: how do you change the inner monad of StateT with as little boilerplate as possible
07:15:53 <hellertime> Can I dump the cost center profiling using a unix signal? I have a server app that I wish to profile, but it has no true exit operation… just ctrl-c, which seems to prevent the cost profiling from being printed
07:16:17 <hellertime> … oh … wait :)
07:16:26 <hellertime> jumped ahead of myself here didn't I...
07:16:34 <hellertime> … need more coffee
07:24:05 <delYsid> If you were to vote, what are your top 3 idiomatic haskell projects < 1000 SLOC?
07:28:37 * hackagebot opencog-atomspace 0.1.0.6 - Haskell Bindings for the AtomSpace.  https://hackage.haskell.org/package/opencog-atomspace-0.1.0.6 (romanT)
07:36:04 <tabaqui1> i've defined instance method in my data, but cannot export them
07:36:09 <tabaqui1> why could it be?
07:36:20 <tabaqui1> First file:
07:36:32 <tabaqui1> data Foo = Foo {a :: Int, b :: Int}
07:36:41 <tabaqui1> instance Default Foo where...
07:36:44 <tabaqui1> second file:
07:36:51 <tabaqui1> x = def :: Foo
07:37:09 <tabaqui1> and i get error then
07:37:41 <mauke> what error?
07:38:05 <tabaqui1> in first case: Variable not in scope: def :: Prereport
07:38:07 <hexagoxel> tabaqui1: do you import Data.Default in 2nd file?
07:38:23 <tabaqui1> hexagoxel: yeah, i've just thought about it, but
07:38:35 <tabaqui1> second case: No instance for (ToJSON Prereport)
07:38:36 <tabaqui1>         arising from a use of ‘updateDocument’
07:39:07 <mauke> do you have such an instance somewhere?
07:39:20 <tabaqui1> in types file:
07:39:28 <tabaqui1> data Prereport = ... deriving (Generic)
07:39:36 <tabaqui1> instance ToJSON Prereport
07:40:00 <mauke> that should work, then
07:40:06 <tabaqui1> hexagoxel: ok, thanks, import data.default helps
07:40:10 <mauke> instances are automatically exported from modules
07:40:17 <tabaqui1> mauke: i thinks this too, but...
07:41:00 <tabaqui1> but i didn't define actual toJSON methods, i guess it will be generated automatically from deriving (Generic)
07:41:22 <tabaqui1> *think
07:49:16 <tabaqui1> hmm, it looks like my type hasn't other similar type, so i should write my own toJSON
07:49:34 <tabaqui1> i just cannot use generic here
08:03:28 <tabaqui1> ah, i get it
08:03:33 <tabaqui1> stupid library
08:03:43 <tabaqui1> i gonna find and punish it's creator
08:04:04 <shapr> What was the problem?
08:04:05 <tabaqui1> ToJSON class was defined in Database.Bloodhound.Types
08:04:36 <tabaqui1> and obviously i didn't define ToJSON method before
08:04:51 <tabaqui1> cause i did it for Data.Aeson.ToJSON
08:05:58 <tabaqui1> shapr: i got error "no instance for ToJSON Foo" while few strings higher was "instance ToJSON Foo"
08:06:18 <tabaqui1> cause i defined method for class from another library
08:07:18 <shapr> Oh, import shadowing?
08:07:52 <pgiarrusso__> IIRC you can't use identifiers imported from two libraries, but you can have the imports you don't want
08:07:57 <tabaqui1> shapr: yep, but i spent some time to  find it
08:08:18 <shapr> tabaqui1: Isn't there a warning you can turn on to point that out?
08:09:26 <tabaqui1> shapr: dunno, i don't see other warnings
08:09:36 <tabaqui1> shapr: what i have to add in cabal? -Wall?
08:09:51 <shapr> I'd expect that to turn up something, yeah.
08:15:30 <c_wraith> I like to have at least -Wall on my executables.  Possibly my libraries, but it's better not to publish them with -Wall in the .cabal file.
08:18:18 <jophish> c_wraith: you don't publish with Wall?
08:18:27 <tabaqui1> oh, well, Monoid class is in Types too)
08:18:39 * hackagebot sigma-ij 0.2 - Thom polynomials of second order Thom-Boardman singularities  https://hackage.haskell.org/package/sigma-ij-0.2 (BalazsKomuves)
08:18:39 <jophish> I agree one shouldn't publish with Werror
08:19:51 <tabaqui1> is there a function like mapM but passing index into map action
08:20:12 <tabaqui1> like mapM :: (a -> Int -> m a)...
08:20:30 <tabaqui1> *m b
08:20:36 <jophish> tabaqui1: zipWithM f [0..]
08:21:07 <jophish> :t flip zipWithM [0..]
08:21:09 <lambdabot> (Applicative m, Num a, Enum a) => (a -> b -> m c) -> [b] -> m [c]
08:21:27 <sam_> hi
08:21:32 <jophish> hi sam_ 
08:21:55 <sam_> i am facing problem in setting up winghci
08:22:10 <sam_> it does not respond
08:22:19 <sam_> just get freeze up
08:23:06 <sam_> is anyone online
08:23:50 <sam_> hey jophish
08:24:02 <alx741> sam_: are you using some colorizing script? or something like that? if not what is the action that triggers the problem?
08:24:29 <sam_> i am using just window 7
08:25:04 <alx741> does it freeze up when you do something in particular?
08:25:22 <sam_> whenever i just open it
08:25:42 <sam_> after few sec. it shows not responding
08:26:54 <sam_> is there any solution
08:27:12 <sam_> for my problem
08:27:49 <alx741> let my try in a virtual machine. You're using the latest haskell platform, right?
08:33:25 <alx741> s/my/me
08:38:40 * hackagebot sigma-ij 0.2.0.1 - Thom polynomials of second order Thom-Boardman singularities  https://hackage.haskell.org/package/sigma-ij-0.2.0.1 (BalazsKomuves)
08:47:17 <tabaqui1> jophish: ah, zip with int array
08:47:25 <tabaqui1> jophish: looks fine, thanks
08:47:30 <jophish> tabaqui1: exactly
08:47:33 <jophish> no problem
09:05:56 <bobajett> how can I sort ["joe", "bob", "billy"] by string length AND then alphabetically? 
09:06:35 <glguy> > sortOn (\x -> (length x, x)) ["joe", "bob", "billy"]
09:06:37 <lambdabot>  ["bob","joe","billy"]
09:06:50 <ski> @where monoids
09:06:50 <lambdabot> comment on "Monoids? In my programming language?" by Cale in 2008 (or 2009 ?) at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> about a use of `
09:06:51 <lambdabot> instance Monoid a => Monoid (rho -> a)'
09:06:52 <ski> bobajett ^
09:07:27 <glguy> The sortOn version has the advantage of not recomputing the length each comparison which you'd get from comparing length <> compare
09:08:06 <bobajett> glguy: cool! thanks! is sortOn able to compare the returned tuples is that why that lambda function works?
09:08:33 <byorgey> bobajett: well, tuples can be compared, and it works by comparing first on the fst element then on the snd
09:08:33 <ski> yes
09:08:43 <byorgey> sortOn just sorts by whatever is returned by the function
09:09:17 <byorgey> > sortOn reverse ["joe", "bob", "billy"]
09:09:20 <lambdabot>  ["bob","joe","billy"]
09:09:29 <karanlearnshaske> hi room. yesterday i was deciding on gui toolkit to talk to a haskell file.with guidance here - i started using fltk. 
09:09:49 <karanlearnshaske> now i am deciding between fltk and ffi to communicate with haskell 
09:09:55 <karanlearnshaske> or using fltkhs
09:10:09 <karanlearnshaske> any thoughts 
09:10:49 <karanlearnshaske> fltk + ffi versus fltkhs
09:11:01 <sham1> Umn, explain
09:11:08 <sham1> Because it sounds interesting
09:12:11 <karanlearnshaske> @sham1 - me ?
09:12:11 <lambdabot> Unknown command, try @list
09:12:33 <Cale> fltkhs basically consists of low level ffi bindings to fltk, so it'll just save you a bunch of effort
09:13:07 <karanlearnshaske> so i was thinking to use fltk for the ui 
09:13:17 <karanlearnshaske> and then talk to my haskell code file with ffi 
09:13:37 <karanlearnshaske> like a rest api we use for web apps
09:13:59 <karanlearnshaske> we can use elm for frontend and have a rest api for backends 
09:14:02 <karanlearnshaske> in haskell
09:14:32 <karanlearnshaske> similarly fltk on frontend and haskell on backend . and ffi instead of rest api
09:14:37 <karanlearnshaske> i havent used ffi so far
09:15:01 <PhsShft> how do i “ lift “ a function? for example making a function that works on single Maybe values, to work on lists of Maybe values. like  
09:15:02 <PhsShft> mapMaybes :: (a -> b) -> [Maybe a] -> [Maybe b] ?
09:15:37 <byorgey> PhsShft: you can fmap twice
09:15:53 <byorgey> PhsShft: the first fmap  takes  (a -> b)   to   (Maybe a -> Maybe b)
09:16:06 <byorgey> the second fmap takes  (Maybe a -> Maybe b)  to  [Maybe a] -> [Maybe b]
09:16:27 <PhsShft> um.. i see
09:16:28 <byorgey> @type \f -> (fmap (fmap f) :: [Maybe a] -> [Maybe b])
09:16:30 <lambdabot> error:
09:16:30 <lambdabot>     • Couldn't match expected type ‘a1 -> b1’ with actual type ‘t’
09:16:30 <lambdabot>         because type variables ‘a1’, ‘b1’ would escape their scope
09:16:55 <byorgey> @type \f -> fmap (fmap f)
09:16:56 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:17:07 <byorgey> in this case  f1 = Maybe  and  f = []
09:18:41 * hackagebot bitcoin-hs 0.0.1 - Partial implementation of the Bitcoin protocol (as of 2013)  https://hackage.haskell.org/package/bitcoin-hs-0.0.1 (BalazsKomuves)
09:27:41 <Clint> when's the last time anyone heard from felipe lessa?
09:31:13 <tabaqui1> can i "forkIO $ (func sock :: Socket -> a)"
09:31:21 <tabaqui1> or :: Handle -> a
09:31:23 <tabaqui1> ?
09:32:03 <quchen_> tabaqui1: No, that won’t typecheck. What do you want to do?
09:32:03 <tabaqui1> i know that i can pass FD of socket to another thread, but what about socket itself?
09:32:08 <quchen_> You can only fork IO actions.
09:32:26 <tabaqui1> quchen_: i mean, can i pass socket to another thread?
09:32:31 <quchen_> Sure!
09:32:47 <tabaqui1> Good news!
09:32:48 <tabaqui1> thx)
09:33:10 <quchen_> Any value that can be passed somewhere can also be passed to a thread. :-)
09:33:53 <geppettodivacin> So, you may just want to modify your type "forkIO $ (func :: Socket -> IO a) sock"
09:35:38 <tabaqui1> ah, yeah, i wrong about type signature, but question was about ipc
09:38:36 <quchen_> MVars are the simplest way of passing values around between threads.
09:39:17 <quchen_> There’s a bunch of useful stuff in the Control.Concurrent modules in base.
09:44:23 <hsgumby> I have some monadic code (currently uses just the State monad), and would like to add optional logging (only when a compile-time flag is on), but would rather not move it all to IO.  I think Writer might not be what I want (I want the logging to show up as it’s computing, not read it later)—any advice on basically how I could expose /only/ putStrLn to that code?
09:45:50 <hsgumby> (sorry if that is a really basic question)
09:47:08 <geppettodivacin> Due to laziness, Writer actually prints as it goes.
09:47:29 <glguy> writer doesn't print at all
09:47:34 <sham1> ^
09:47:36 <geppettodivacin> Well, technically yes.
09:48:03 <PhsShft> sorry to bother everone again, didn’t quite understand byorgey’s response so ill post the question again
09:48:20 <geppettodivacin> But if you map the print function to the elements of your Writer's result, it should print lazily.
09:48:20 <hsgumby> geppettodivacin: I think using a writer would print as it goes if I’m feeding it into some putStrLn loop “driving” the computation, but I don’t want to structure the code that way
09:48:34 <PhsShft>  How do I write a function that works on single Maybe values, to work on lists of Maybe values. for example 
09:48:34 <PhsShft> mapMaybes :: (a -> b) -> [Maybe a] -> [Maybe b] ?
09:48:42 * hackagebot hablog 0.5.0 - A blog system  https://hackage.haskell.org/package/hablog-0.5.0 (gilmi)
09:48:58 <PhsShft> don’t really know how to use fmap
09:49:08 <sham1> Well, first off
09:49:14 <sham1> You need to access the contents of a list
09:49:21 <sham1> For that you want to use a fmap
09:50:02 <sham1> And it requires a function. In this case the signature needed for that fmap is (Maybe a -> Maybe b)
09:50:14 <joncol_> Is it possible to pass a "value" of kind * -> * (A Functor) to a function using Template Haskell? I want to generate QuickCheck properties using as little repetitious code as possible.
09:50:15 <sham1> Oh look at that, we can make that with fmap f
09:50:29 <sham1> Where f is the function passed to your mapMaybes
09:50:51 <sham1> Looking at the types really help in this situation
09:51:19 <PhsShft> :sham1 I’m a bit confused, what’s the different between fmap and a normal map
09:51:27 <PhsShft> *difference
09:51:30 <sham1> Nothing, as far as List is concerned
09:51:42 <sham1> In fact, AFAIK fmap for List is just map
09:51:46 <sham1> As in: fmap = map
09:51:57 <quchen_> :t Proxy :: Proxy Functor -- joncol_ 
09:52:00 <lambdabot> Proxy Functor
09:52:21 <quchen_> Using TH I’m not sure how, but it should be possible.
09:52:41 <PhsShft> so in this case how do I use fmap ? I do fmap [] ?
09:52:42 <quchen_> Point is, GHC has polykinds now, so TH does as well probably.
09:53:05 <geppettodivacin> :t runWriter
09:53:07 <lambdabot> Writer w a -> (a, w)
09:53:16 <glguy> joncol_: What's an example of a "value" with kind * -> *
09:53:20 <sham1> PhsShft, look at fmap's type signature
09:53:28 <PhsShft> :t fmap
09:53:30 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:53:46 <sham1> Here is a reference implementation
09:53:52 <sham1> fmap . fmap
09:53:57 <sham1> That does exactly what you wish
09:54:00 <sham1> :t fmap . fmap
09:54:02 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:54:29 <Sonolin> :t map . fmap
09:54:32 <lambdabot> Functor f => (a -> b) -> [f a] -> [f b]
09:54:54 <Sonolin> might be a little less confusing to see that type signature (does the same thing as first)
09:55:04 <sham1> Substitute the "f1" for Maybe and "f" for [], and you get (a -> b) -> [Maybe a] -> [Maybe b]
09:55:05 <geppettodivacin> :t mapM_ . snd runWriter . runStateT (state :: StateT s Writer a) $ state :: s
09:55:07 <lambdabot> error:
09:55:07 <lambdabot>     • Expecting one more argument to ‘Writer’
09:55:07 <lambdabot>       Expected kind ‘* -> *’, but ‘Writer’ has kind ‘* -> * -> *’
09:55:13 <sham1> That is indeed a valid point Sonolin
09:55:14 <joncol_> glguy: I have a datatype "Identity a". Identity is a Functor. I want to generate QuickCheck tests (properties) for this functor, but also for other functors. Therefore, I want to create some code that avoids the repetition.
09:55:17 <PhsShft> uhh
09:55:19 <sham1> It might be easier to understand
09:55:21 <geppettodivacin> :t mapM_ . snd runWriter . runStateT (state :: StateT s (Writer String) a) $ state :: s
09:55:24 <lambdabot> error:
09:55:24 <lambdabot>     • Couldn't match expected type ‘(a1,
09:55:24 <lambdabot>                                      Writer String (a3, (s1 -> (a5, s1)) -> m2 a5) -> a0 -> m0 b0)’
09:55:25 <sham1> However, fmap . fmap is more general
09:55:25 <PhsShft> :Sonolin that helps a lot
09:55:34 <joncol_> quchen_: I'll look into Proxy
09:56:01 <quchen_> data Proxy (a :: k) = Proxy
09:56:03 <quchen_> That’s it
09:56:41 <quchen_> Proxy is an instance of pretty much anything that typechecks ;-)
09:57:02 <glguy> If you’re working with TH you don’t need to worry about Proxy. You’ll be passing types using TH’s Type 
09:57:44 <joncol_> I didn't know I could do this without TH, I'll happily avoid learning about that for some more time.
09:57:48 <byorgey> sls
09:59:55 <quchen_> joncol_: What does [t| Functor |] give you?
10:00:04 <quchen_> Shouldn’t that be your value lifted to TH?
10:01:22 <joncol_> I don't even know that syntax. I'm completely unfamiliar with TH.
10:02:09 <quchen_> [| xxx |] takes a Haskell expression and gives you the TH version of it
10:02:29 <quchen_> You can also do this for other things, for types the syntax is [t| xxx |]
10:02:30 <glguy> joncol_: You might start trying to write the test before worry about needing Template Haskell
10:04:36 <geppettodivacin> :t mapM_ putStrLn . snd . runWriter . runStateT (undefined :: StateT s (Writer [String]) a) $ (undefined :: s) -- hsgumby
10:04:38 <lambdabot> IO ()
10:05:01 <quchen_> That should clear things up.
10:05:09 <geppettodivacin> hsgumby: That should be prettied up with extra variables, but it'll print out the log that you're looking for.
10:05:16 <joncol_> This is what I'm doing http://pastebin.com/raw/2LRy9j2j
10:05:31 <joncol_> I want to have several other Functors except from Pair.
10:05:32 <geppettodivacin> hsgumby: And also do it lazily.
10:05:58 <joncol_> And format some strings depending on the Functor (I'm using Tasty)
10:06:52 <glguy> joncol_: OK, just write more lines like this:   quickCheck (functorCompose :: FC Pair Int)
10:07:09 <hsgumby> geppettodivacin: about what I was thinking, but do you know if it buffers all the log lines in memory?  (since they’re pointed to by the writer?)
10:07:44 <sham1> It's kind of nice how with Haskell one gets used to reading right-to-left in this weird manner
10:07:50 <hsgumby> geppettodivacin: it definitely seems like it’d be nicer to expose essentially putStrLn to the monad directly if possible
10:08:14 <glguy> joncol_: That code doesn't appear to define Fun
10:08:25 <geppettodivacin> hsgumby: No, it should print them out as they come and then forget about them, unless you use them somewhere else that it needs them.
10:08:28 <hsgumby> (for context this is perf critical code; and I need to have this all compile out when a logging :: Bool is False)
10:08:55 <geppettodivacin> hsgumby: In retrospect, you should probably be using Text instead of String if it's performance critical.
10:09:18 <joncol_> glguy: Fun is in Test.QuickCheck.Function
10:09:19 <hsgumby> geppettodivacin: well, I should say it’s only perf critical when logging is False ;)
10:10:18 <glguy> joncol_: Your test is already parametric in the type `f', so what’s left to do?
10:10:38 <geppettodivacin> hsgumby: Actually, if you're not printing them, they probably will build up in memory.
10:11:33 <hsgumby> geppettodivacin: I admit I dont understand, but I can’t see how the GC can know they’re unused after they are printed either … each Writer [String] a value should have a pointer to the head of the list, right?
10:13:04 <geppettodivacin> hsgumby: I'm not the best person in the channel to speak on laziness.
10:13:52 <hsgumby> I think it’s not really about lazy evaluation though:  it’s a question of which pointers into the list exist at what time
10:14:31 <absence> can stack list the selected package versions for dependencies?
10:14:39 <hsgumby> geppettodivacin: also, if it’s all based on a pointer to the head of the list in the Writer, logging is going to be O(N^2) there right?
10:15:34 <glguy> hsgumby: You might be confused about all the Writer values have a pointer to the head of the list
10:16:24 <joncol_> glguy: http://pastebin.com/bgNyhNZr This 
10:16:48 <geppettodivacin> hsgumby: I've actually got to go. I know that I leave you in capable hands!
10:16:58 <hsgumby> glguy: yeah maybe; I’m trying to understand a little more now
10:18:03 <glguy> joncol_: You could write this without TH: quickcheck [ functorLaws (Proxy :: Proxy Pair), functorLaws (Proxy :: Proxy Identity) ]
10:18:42 <joncol_> glguy: Cool, thanks!
10:23:22 <spike_> hi guys
10:23:56 <spike_> May I ask here an question?
10:24:03 <ski> you just did
10:24:10 <spike_> ;)
10:24:18 <sham1> Don't ask to ask
10:24:40 <shapr> spike_: how may we assist you?
10:24:43 <hsgumby> glguy: yeah so I guess I might be missing something, but it looks like if I have (for example) Writer [String] Int, each value of that type has to have a pointer to the head of the list of strings
10:24:47 <spike_> However, I need to filter a string, so I can extract all digits
10:24:53 <hsgumby> glguy: because I can repeatedly take values out of the front of the list
10:25:27 <ski> > filter isDigit "t4nk083"
10:25:30 <lambdabot>  "4083"
10:25:45 <jchia_> Right now, Monoid is not yet subclass of Semigroup, but they both have (<>). So, when I import both Data.Semigroup and Data.Monoid and try to use (<>), I get compiler errors about ambiguity. If I use qualification it should work, but then M.<> is quite an eyesore. Any other solutions or workarounds until the SemigroupMonoid proposal gets implemented?
10:26:11 <schoppenhauer> hi. https://ghc.haskell.org/trac/ghc/wiki/LinearTypes ← is this already available as language extension?
10:26:12 <geekosaur> jchia, <+> = M.<> ?
10:26:13 <ski> jchia_ : perhaps define local synonym
10:26:19 <hsgumby> glguy: it would probably help me to see the source for tell (I guess it uses mplus?), but I think it must traverse the whole list too … which would make this basically the worst way to do logging possible … so hopefully I’m still wrong ;)
10:26:20 <geekosaur> schoppenhauer, no
10:26:29 <schoppenhauer> :(
10:26:31 <schoppenhauer> ok thx
10:27:16 <ski> hsgumby : `Writer String' or `Writer (Endo String)' or ?
10:27:46 <hsgumby> ski: we’re talking about Writer [String] at the moment (I don’t know the Endo constructor)
10:27:57 <ski> @src Endo
10:27:58 <sm> absence: do you mean like stack install --dry-run ?
10:27:59 <lambdabot> newtype Endo a = Endo { appEndo :: a -> a }
10:28:48 <ski>   instance Monoid (Endo a) where mempty = Endo id; Endo f <> Endo g = Endo (f . g)
10:29:12 <spike_> Thank you very much. It works :)
10:29:29 * ski didn't get spike_'s question, yet ..
10:29:38 <hellertime> what is an efficient way to concatenate the result of a sequence of IO actions? meaning, I am ending up with an [IO a] and I want an (IO [a])
10:29:52 <quchen_> hellertime: sequence
10:29:57 <dolio> ski: Apparently you did.
10:30:14 <ski> dolio : apart from the first one :)
10:30:17 <quchen_> :t sequence :: [IO a] -> IO [a]
10:30:19 <lambdabot> [IO a] -> IO [a]
10:30:33 <hsgumby> ski: hm is that something you can use to avoid the buffering?  wouldn’t each function have to have sorta it’s “logging continuation” stored for that too?
10:30:55 * ski isn't sure what hsgumby is trying to doing/avoid
10:31:38 <hellertime> quchen_: confirmed thats it :) thanks
10:32:01 <ski> hellertime : if you're already using `map' (or possibly a list comprehension), possibly you could use `mapM' or `forM' instead
10:32:09 <hsgumby> ski: ah sorry, we’re way off in the woods:  my original questioin is I have monadic code (State monad only right now) and I want to add logging controlled by a compile time flag.  Ideally basically the code should be able to embed putStrLn actions but no other IO actions.  So we got sidetracked talking about whether laziness + a WriterT could do what I want (I think it doesn’t because it looks like it’ll buffer the log lines)
10:32:44 <sham1> Do you have it be a command line flag or a compile time one
10:32:51 <hsgumby> basically I want side-effects for debugging ;)
10:32:52 <hellertime> ski: I'm using direct recusion, I want a short circuiting map
10:33:08 <hsgumby> compile time would be ideal—I probably can’t afford it in production
10:33:17 <sham1> Because if you want it to be compile time, you could probably use the preprocessor
10:33:19 <ski> hellertime : not sure what you mean by "short circuiting map"
10:33:26 <hsgumby> (but if we can do it with a runtime flag also I might learn from the example)
10:33:33 <hsgumby> sham1: woah there’s a preprocessor?
10:33:37 <sham1> Yes
10:33:38 <hsgumby> or do you just mean run it through CPP
10:33:40 <ski> CPP
10:33:45 <hsgumby> ouch ;)
10:34:05 <sham1> I am so used to C and C++ that I just call it *the* preprocessor
10:34:15 <hsgumby> are you suggesting basically #ifdef LOGGING put my monad as IO instead of my own state monad?
10:34:37 <sham1> I don't know, ask yourself
10:34:47 <hellertime> ski: I'm trying to convert a `replicateM n <action>` into a form that replicates up to n 
10:35:01 <hsgumby> sham1: well, I can do that, but it seems like a pretty bad solution to me
10:35:05 <ski> hellertime : "up to n" ?
10:36:14 <hellertime> ski: the IO action can fail, and I want to return after the first failed IO action, not after n failed IO actions… if that makes sense (trying to read up to n values from a channel)
10:36:38 <sham1> How would you detect a failed IO computation vs a successful one
10:36:42 <hsgumby> anyway I can probably come up with something better than that; I was just thinking there’d be a semi-standard answer for this ;)
10:36:45 <ski> hellertime : fail in which way ?
10:37:06 <johnw> hellertime: an exception would immediate stop the replication
10:37:15 * ski would perhaps suggest `MaybeT IO' or `ExceptT Foo IO'
10:37:21 <hellertime> throws an exception
10:37:58 <hellertime> johnw: hmm 
10:39:01 <sham1> Is there a rationale beyond just tradition of us not expressing stuff like IO errors via the type system and instead using the exception system
10:39:23 <jchia_> geekosaur, ski: Thanks, I think I'll go with that. I suppose I also have to declare the fixity and precedence manually to match (<>), correct?
10:40:38 <geekosaur> I'd expect so
10:40:49 <johnw> sham1: one example: async exceptions can occur at any time, so the only way to respond to them is with a handler; there's no "return value" to ever check
10:41:03 <sham1> Ah, that's a good point actually
10:41:07 <ski> jchia_ : yes
10:42:03 <ski> sham1 : row types would be preferable for expressing them in the type system, i think
10:42:09 <hsgumby> sham1: ski: ah, I should’ve just googled more.  a small wrapper (with a constant Bool for enabled or not) on Debug.Trace is basically exactly what I want it looks like
10:42:57 <ski> hsgumby : oh, i was thinking of `trace', but you said logging, so i figured you wanted something "more serious"
10:43:17 <sham1> Tracing is still technically logging ;)
10:43:19 <hsgumby> ski: yeah my bad there too (I had been googling about “logging” too without the “debug” or “trace” words ;) )
10:43:45 <ski> sham1 : but for different intents
10:43:47 <hsgumby> but I learned something about Writer (which I’ve still never found a use for …) so that’s good
10:46:27 <geekosaur> me neither fwiw
10:47:39 <ocramz>  hi all,is Hackage down?
10:48:00 <glguy> ocramz: Doesn't appear to be
10:48:06 <sm> I was just wondering if it's being affected by today's dyn ddos
10:49:02 <ocramz> well, the website at least is acting funny, as in DNS-funny. Where is it hosted?
10:49:32 <ocramz> it timeouts
10:49:47 <sm> https://krebsonsecurity.com/2016/10/ddos-on-dyn-impacts-twitter-spotify-reddit/ has details, if you can reach it
10:49:53 <raichoo> ocramz: https://gizmodo.com/this-is-probably-why-half-the-internet-shut-down-today-1788062835
10:50:20 <raichoo> The weather is pretty harsh out there atm :/
10:50:40 <sham1> It also affected Github which was shitty
10:52:05 * ski . o O ( "I hear GitHub is down again. Building a fully decentralized system that relies on a single entity is pretty great." )
10:52:56 <sham1> It's very sad when this happens as Github is pretty much the de facto repository for a lot of people
10:52:57 <glguy> Yeah, it's pretty cool. Even when it goes down my local repository has full functionality and I can pull from people I'm working with directly
10:53:34 <jchia_> Does my importing the same module twice make sense? http://lpaste.net/288480
10:53:39 <ocramz> glguy : how do you do that?
10:54:11 <sham1> Well git clone works wonders for that
10:55:03 <lyxia> jchia_: it's fine
10:55:12 <jchia_> thanks
10:56:00 <ocramz> the Dyn homepage is unreachable too. Aaalright..
10:57:09 <pikajude> so i forget
10:57:12 <pikajude> what does ddosing accomplish?
10:57:27 <sham1> Yes
10:57:42 <ocramz> pikajude: sometimes it's for ransom
10:57:47 <ongy> gibhub works fine for me. Is this old news, or is something caching for me?
10:58:02 <dolio> It's not Haskell news, I can tell you that.
10:58:03 <pikajude> lookup might be cached
10:58:23 <sham1> Well github is up now
10:58:26 <sham1> Although barely
10:58:29 <sham1> For me
10:58:45 <ongy> pikajude: blackmail, corporate competitors and such. nothing good.
10:58:55 <ocramz> where are you @ sham1 ?
10:58:56 <pikajude> oh
10:59:12 <ocramz> here in Sweden I still get timeout on both github and hackage
10:59:38 <sham1> I'm in Finland
10:59:43 <sham1> So it shouldn't be much different
11:00:38 <sham1> Oh, it's down again
11:00:39 <sham1> FFS
11:01:33 <nomeata> I observe that github.com cannot be resolved from within the university of karlsruhe, but from the university of pennsylvania, it does.
11:01:49 <ocramz> sham1 :  "kalasarikannit" during the outage. No sweat ..
11:03:02 <oherrala> ocramz: :D
11:03:21 <sham1> No, I don't drink
11:03:45 <oherrala> I just got back from sauna and someone broke internets while I was there
11:04:10 <ocramz> sorry :D that's about all the Finnish I know
11:04:37 <orion> Github is to Git what Dyn is to DNS -- decentralized systems magically becoming centralized.
11:04:42 <Tuplanolla> I like outages. They make me productive until I run out of offline resources after a few days.
11:05:08 <sham1> The only outage I'd rather not have is on electricity and StackOverflow
11:05:14 <Tuplanolla> Don't forget to install Haddock documentation for your packages.
11:05:16 <sham1> Not in any particular order
11:06:48 <ocramz> does IRC ever go down?
11:07:18 <sham1> Well, if enough netsplits happen, it might as well go down
11:10:52 <streblojr> if the irc network's dns server went down, then people wouldn't be able to connect
11:11:54 <ocramz> damn dns, the weak link
11:12:15 <sham1> Well, if one has the IPs, they could
11:12:45 <ongy> I never disconnect, so that's not a problem :). but dolio is right, this isn't really haskell related, so we should move it to -blah, or -overflow or stop it
11:13:03 <sham1> Agreed
11:17:27 <streblojr> -blah sounds like fun
11:17:54 <sham1> It sounds like a USE flag
11:18:22 <agocorona_> Hi. I have a package in hackage not compiled/build docs for a month. Are there more cases?
11:18:57 <geekosaur> might ask in #hackage or #haskell-infrastructure
11:19:24 <geekosaur> but any more it seems like the builder is always down or behind, I keep running into packages with no docs :(
11:19:26 <agocorona_> thanks
11:20:10 * hexagoxel mentions `cabal upload --documentation`
11:20:27 <geekosaur> also I am not sure if it's always that docs didn't get built, they keep finding cases where cloudflare just isn't updating so the update with the doc links never gets shown to ordinary users
11:21:01 <ocramz> hexagoxel : good idea, thanks
11:21:37 <joncol_> glguy: I had to rush before, but you said that part of the equation for "passing a type constructor" to a function was to use Proxy :: Proxy Pair on the calling side. But how do I use this on the receiving side, to instantiate my functorIdentity to be of the right type?
11:22:24 <shapr> joncol_: how did you end up with that much whitespace at the end of your message?
11:22:24 <agocorona_> hexagoxel:   cabal.exe: unrecognized 'upload' option `--documentation'
11:22:38 <sham1> Wait, people still use cabal?
11:22:45 <sham1> I'm serious about this
11:23:03 <agocorona_> I use both cabal and stack
11:23:05 <joncol_> shapr: Hmm, what?
11:23:12 <hexagoxel> agocorona_: yes you might need 1.24
11:23:17 <geekosaur> yes, despite certain people trying desperately to destroy the competition
11:23:20 <dcoutts> sham1: hah
11:23:21 <MarcelineVQ> geekosaur: quite often these days I go right to stackage so I know the docs will be there when​ I browse, at least for packages that are on there
11:23:34 <shapr> sham1: doesn't stack use cabal?
11:23:42 <dcoutts> sham1: you should try cabal new-build :-)
11:23:58 <geekosaur> so yes, please by all means abet that as much as you possibly can, because the ego of a rock-star dev is more important than you or haskell will ever be
11:24:09 <shapr> ??
11:24:17 <shapr> geekosaur: be nice
11:24:21 <sm> can we please not perpetuate that..
11:24:30 <shapr> sham1: you too, be nice
11:24:43 <sham1> Okay
11:25:19 <shapr> I don't want to have to turn this channel around!
11:25:34 <dcoutts> sham1: but seriously, just fyi, cabal 2.0 will be out in not too long
11:25:42 <sham1> Ah nice
11:25:54 <ocramz> dcoutts: what will cabal 2 feature?
11:25:56 <dcoutts> and if you want to try it now, it's available, lots of people are using it
11:26:33 <dcoutts> ocramz: out with sandboxes, in with projects, and those work nicely (unlike sandboxes)
11:26:36 <sm> maybe cabal 2 could trivially let you select a stackage snapshot instead of hackage 
11:26:54 <dcoutts> that feature may or may not make 2.0
11:27:18 <dcoutts> but using curated subsets of hackage is certainly on the todo list
11:27:55 <dcoutts> in the meantime it's fairly simple to use anyway, just download the file from stackage and add it as your cabal.project.freeze file
11:28:45 <sm> not quite simple enough, but getting close !
11:28:53 <sham1> Welp, time to emerge myself a GHC and co. so I can actually try the new Cabal out
11:28:53 <dcoutts> ocramz: under the hood it uses nix style package management, so we get full sharing between projects, and proper rebuilding of deps
11:29:13 <ocramz> dcoutts: sweet, can't wait to try it out
11:29:38 <dcoutts> ocramz: a preview is available in cabal-install-1.24, with "new-" prefixes on the commands
11:30:38 <dcoutts> that said, the master version has fewer sharp edges
11:30:41 <ocramz> dcoutts: is it documented already?
11:30:46 <dcoutts> yes, in the user guide
11:30:50 <ocramz> great
11:31:02 <dcoutts> https://cabal.readthedocs.io/en/latest/nix-local-build-overview.html
11:34:29 <ocramz> dcoutts: really cool, thanks. I like the idea of the freeze file
11:34:58 <sham1> Am I to understand that the freeze file basically keeps the dependencies at a certain version
11:35:28 <ocramz> and stores cabal flags and language extensions
11:35:28 <dolio> dcoutts: So, I've been meaning to ask something.
11:36:06 <sham1> So it is something similar to the Cargo.lock that is used in the Rust world
11:36:07 <sham1> Nice
11:36:17 <dolio> ezyang helped me figure out a while back that I could use a project file to make debugging vector stuff nicer, because the project can set debug flags in vector (like bounds checks on unsafe stuff).
11:36:47 <dolio> Is there a way to set up the _project_ so that I can toggle between debug mode with a command line flag or something?
11:37:19 <dcoutts> ocramz, sham1: this is more or less just the same as the existing cabal.config file and cabal freeze command. Just renamed to fit the project stuff.
11:37:24 <thoughtpolice> dolio: at the moment I dont' believe so, no.
11:37:57 <thoughtpolice> Now, if you just turn the flag on and off continuously, you'll still get fast rebuilds since the prior versions will stay in the store under ~/.cabal. But it's not configurable with switches yet
11:38:01 <dcoutts> ocramz, sham1: ie yes cabal has supported freezing the deps for ages, it just doesn't force you into doing that
11:38:14 <dolio> Right, I understood that part, and that's huge.
11:38:30 <sham1> That's super nice
11:38:33 <dcoutts> dolio: right, no, not yet. Having conditional and different profiles is on the roadmap though.
11:38:40 <sham1> Makes it even more i
11:38:41 <dolio> Okay, cool.
11:39:06 <sphinxo> Possibly a stupid question, but can you have kinds of kinds?
11:39:14 <sphinxo> Possibly a stupid question, but can you have kinds of kinds?
11:39:49 <dcoutts> sphinxo: yes, and all the way up
11:39:50 <lyxia> They're called sorts.
11:40:14 <thoughtpolice> dolio: Yeah, I hit this myself already, but just the rebuild caching takes a lot of the edge off.
11:40:20 <Tuplanolla> Isn't that types of kinds, lyxia?
11:40:30 <sphinxo> yeah that makes more sense
11:40:36 <Tuplanolla> I'd expect kinds of kinds to go one level higher.
11:40:39 <dolio> thoughtpolice: Yeah, the rebuild part is the major part. Editing the project file isn't that bad.
11:41:05 <c_wraith> sphinxo, ghc 8 has an extension that flattens the entire hierarchy. above types, you have.. types! 
11:41:16 <pikajude> but what's above those?
11:41:22 <c_wraith> types. 
11:41:26 <pikajude> oh, cool=
11:41:28 <thoughtpolice> Turtles. Or maybe the turtles are below. I can't remember.
11:41:41 <c_wraith> turtles are below
11:41:54 <dolio> There's no standard name for stuff above kinds. And 'sort' means something subtly different in a lot of contexts.
11:42:00 <c_wraith> it's turtles all the way down, types all the way up. 
11:42:08 <sphinxo> c_wraith: what's the name of the extension?
11:42:16 <pikajude> At level 1,318, the turtles become types.
11:42:20 <c_wraith> TypeInType
11:42:50 <thoughtpolice> sphinxo: TypeInType. With GHC 8 the heirarchy is basically, values have types, types have kinds like *. And * has its own kind, which is also *.
11:42:58 <Tuplanolla> I guess `TypeOfTypeType` sounded too silly.
11:42:59 <thoughtpolice> So in a sense, it 'bottoms out' when you get to * :: *
11:43:16 <thoughtpolice> Tuplanolla: I mean, it makes sense given the * :: * axiom, IMO.
11:43:36 <thoughtpolice> Well, and the fact that * is now also known as 'Type'.
11:44:18 <sphinxo> woah
11:44:19 <Tuplanolla> I was joking about having to employ the set-theoretic interpretation, thoughtpolice.
11:46:09 <dcoutts> sham1: to answer specifically, yes it fixes the versions and flags of everything. So the idea is you check that into your source control and share it with other people working on the project
11:46:27 <sham1> I approve
11:46:47 <dcoutts> in fact you can do this with the existing cabal freeze, it just works better at the project level
11:46:48 <thoughtpolice> sphinxo: In other languages, the hierarchy does not bottom out this way. In a language like Coq or Agda you basically have an infinitely ascending universe of types, going all the way up -- so Type wouldn't have the kind 'Type'. It would have a more explicit type like 'Type_0 :: Type_1 :: Type_2 :: ..."
11:47:15 <thoughtpolice> sphinxo: So Haskell is a bit unique in this realm.
11:47:17 <thoughtpolice> Tuplanolla: fair :)
11:47:29 <sphinxo> oh interesting thoughtpolice 
11:47:53 <dcoutts> dolio: if you want to help hack, that feature should not be that hard to add
11:48:34 <verement> types all the way up, turtles all the way down
11:48:47 <dolio> dcoutts: I think I have too much other stuff that I should be working on, unfortunately.
11:48:54 <dolio> I just wanted to make sure I wasn't missing something.
11:48:59 <dcoutts> dolio: sure, np
11:50:12 <kosmikus> thoughtpolice: there are two things to consider, actually. whether the levels are syntactically different, and whether there's a hierarchy or not. in Agda + Coq, syntactically all levels are actually the same. in Haskell, you still have terms and types. establishing a hierarchy does not make much sense as long as we don't otherwise try to identify a total / consistent fragment somehow.
11:52:55 <thoughtpolice> kosmikus: Ah yes, that's true -- I suppose I folded those together. I suppose I took it for granted, given that explicit level annotations (or the inability to write functions polymorphic in the level) would be a bit of a chore.
11:54:29 <dolio> Once you try to have infinitely many universes, trying to have each universe in a separate syntactic category is kind of unexplored territory, I think.
11:55:11 <c_wraith> the language just needs an infinite grammar. 
11:55:22 <ongy> sounds like fun to parse
11:55:31 <kosmikus> dolio: that's true :)
11:55:31 <thoughtpolice> Yes, I was about to ask if anyone has ever actually had the infinite universe theory but without the syntactic reuse. I quickly realized the answer is probably "no", because that seems unbelievably painful.
11:55:45 <kosmikus> dolio: but we certainly had 3 syntactically different levels until recently.
11:55:46 <et09> i need to write a server to interface with 'MLLP' (super barebones protocol over TCP/IP with message start and end characters)
11:55:53 <et09> ideally multithreaded etc.
11:56:09 <et09> what would be a good starting point for a tcp/ip server library to use in it
11:56:10 <Tuplanolla> Of note is also the fact that universe levels need not have a total order.
11:56:34 <ongy> et09: you could use the network package (rather lowlevel translation of utility)
11:56:45 <lilred> GitHub down -_______-
11:57:08 <ab9rf> lilred: change DNS providers. github is up, it's your address book that's broken :)
11:57:18 <dolio> Some of the type theories that Agda and Coq come out of also have separate syntactic categories for terms and types, though, despite also having (arbitrarily many) universes.
11:57:32 <sphinxo> What are terms?
11:57:37 <Tuplanolla> Values.
11:57:46 <lilred> ab9rf: only OpenDNS has GitHub up AFAIK, and it´s because they keep stale DNS entries (a security vulnerability)
11:57:51 <sphinxo> oh right
11:58:19 <Tuplanolla> They're usually called terms when types are values too.
11:58:50 <sphinxo> oh cool
11:59:00 <dolio> Well, values can mean something special anyway.
11:59:32 <dolio> Like, maybe `2` is a value, but `1 + 1` is not.
11:59:51 <dolio> The term `1 + 1` denotes the value `2`.
12:00:05 <et09> http://www.catonmat.net/blog/simple-haskell-tcp-server/ i was looking at this @ongy
12:00:34 <ab9rf> lilred: yeah, i know
12:00:49 <ab9rf> lilred: the thing is, github is up. it's just that nobody can find it :)
12:01:15 <sphinxo> so http://lpaste.net/8253557426301698048 does this work for types of kinds?
12:01:39 <ongy> et09: that uses the network package, I think an old version, things may have moved to Network.Socket and Network.Socket.ByteString
12:01:47 <et09> oh.. yikes
12:02:55 <sphinxo> ( with the TypeInType Extension and importing from Data.Kind )
12:03:36 <et09> is there anything higher level?
12:03:38 <thoughtpolice> sphinxo: Yes, in GHC 8 you can use that for both type equality (e.g. Equals Int Int) and kind equality (Equals * *).
12:05:14 <thoughtpolice> It also allows you to do things like promote GADTs into kinds ('GADKs'), not just have type families also work on kinds. Kind equalities were one of the major sticking points that was solved by TypeInType.
12:06:06 <ongy> et09: what features do you expect it to have?
12:06:31 <et09> that's a good question cause i think im misunderstanding something about tcp/ip
12:06:33 <thoughtpolice> (Is it even accurate to call them "Kind equalities" anymore when kinds and types are the same in the core theory?)
12:06:40 <et09> should i be thinking about it entirely as a stream 
12:07:31 <et09> or can i get a server that bundles things as discrete requests ..
12:07:55 <ongy> et09: you should be thinking about tcp. that it's ip based doesn't matter much to you. and yes you should think about it as stream
12:08:12 <sphinxo> thoughtpolice: how do I write Equal * * ? seems to error and say to use TypeOperators and then when I add that extension it still tells me to add the extension?
12:08:45 <thoughtpolice> sphinxo: You probably have to say '(*)' instead, since '*' really is an operator. In fact, the definition of * is now 'type (*) = Type'
12:08:51 <thoughtpolice> Probably easier to just say 'Equals Type Type'
12:09:06 <sphinxo> that works, thanks
12:09:56 <thoughtpolice> (FWIW, with kinds and types being equal, (*) is pretty messy syntactically, which is why 'Type' is the new '*', without the lexical weirdness)
12:10:03 <acowley_> Or the mellifluous TYPE PtrRepLifted
12:10:58 <acowley_> I actually really like TYPE. I hope it pans out to be as useful as it seems.
12:12:00 <et09> so then i have to compile the packets in a socket in memory until i get the end request character?
12:12:09 <et09> that's where im getting tied up, no idea how to do that in haskell
12:12:18 <et09> besides like, idk, recursing through the stream ? 
12:13:12 <thoughtpolice> acowley_: You mean levity polymorphism in general?
12:13:21 <ongy> et09: that's what you will have todo. after each receive you will have to check for the end character
12:13:29 <acowley_> thoughtpolice: Yeah
12:13:33 <et09> interesting
12:15:54 <thoughtpolice> acowley_: I haven't run into any uses of it myself, personally. But then again I'm old and curmudgeony so this isn't surprising, perhaps. All these new fancy features, requiring me to relearn parts of my favorite language! The nerve.
12:16:32 <ongy> et09: you may get a nicer interface to it if you have an incremental parser, but it will still have to check for the end char
12:18:49 <et09> an incremental parser?
12:18:50 <dolio> thoughtpolice, acowley_: Is there a separation of # into unboxed and boxed, unlifted things yet?
12:18:56 <dolio> Because that would be pretty big.
12:19:22 <dolio> Assuming you could do polymorphism over the latter.
12:20:04 <dolio> Then ArrayArray# would be unnecessary.
12:20:37 <dolio> Which is an awful API.
12:23:01 <ongy> et09: something like https://hackage.haskell.org/package/cereal-0.5.3.0/docs/Data-Serialize-Get.html#v:runGetPartial you can feed it ByteStrings at a time to parse. When you use Network.Socket.ByteString.recv (which afaik is recommended) you will get your data as ByteString
12:23:36 <Tuplanolla> Why doesn't this type check?
12:23:37 <Tuplanolla> :t Data.Vector.Unboxed.findIndices (== 0) . Data.Vector.Unboxed.create $ do {v <- Data.Vector.Unboxed.Mutable.replicate 3 0; Data.Vector.Unboxed.Mutable.write v 1 1; return v}
12:23:38 <lambdabot> error:
12:23:39 <lambdabot>     • Couldn't match type ‘m0 (Data.Vector.Unboxed.Base.MVector
12:23:39 <lambdabot>                                  (Control.Monad.Primitive.PrimState m0) Double)’
12:23:44 <thoughtpolice> dolio: I believe so, yeah -- http://hackage.haskell.org/package/ghc-prim-0.5.0.0/docs/GHC-Types.html#t:RuntimeRep
12:24:24 <dolio> Tuplanolla: Looks like it's going to be a complaint about ambiguous m0.
12:24:25 <thoughtpolice> dolio: It's the difference between PtrRepLifted and PtrRepUnlifted IIRC. Int would be the former; ByteArray# would be the latter, for example.
12:25:06 <Tuplanolla> It works if you replace `.` by `$`, dolio.
12:25:26 <dolio> Oh. Then it's an impredicative instantiation problem.
12:25:44 <thoughtpolice> dolio: I do wish RuntimeRep had the nicer definition available here, though, since it just feels much nicer: https://ghc.haskell.org/trac/ghc/wiki/NoSubKinds#AlternativeRuntimeRepchoice
12:26:32 <monochrom> dolio: Go into the doc of GHC.Exts and look for RuntimeRep for much goodies :)
12:27:01 <dolio> Create has type `(forall ...) -> ...`, and you're trying to use (.) which has to do `a = (forall ...)`, but that isn't allowed by GHC's inference algorithm.
12:27:20 <dolio> And (.) isn't special cased like ($) is.
12:27:20 <Tuplanolla> Oh.
12:27:24 <thoughtpolice> "If we did this, we would introduce reallyUnsafeCoerce# or perhaps unsafeCoerce## that was truly unrestricted [for coercions between unboxed and boxed things]." I vote for accursedUnutterableUnsafeCoerce#
12:28:18 <Tuplanolla> Follow-up question: why?
12:29:05 <dolio> monochrom: Oh wow. It's very fine grained.
12:29:48 <dolio> Tuplanolla: Why what?
12:30:09 <Tuplanolla> Why the special casing, dolio?
12:30:23 <thoughtpolice> Tuplanolla: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg18923.html
12:30:35 <dolio> Because 'runST $ ...' is deemed important enough.
12:32:03 <dolio> Someone proposed recently what I think is a nice solution, where you could write stuff like `runST do ...`.
12:32:18 <Tuplanolla> Yes, the `ArgumentDo` proposal.
12:32:19 <dolio> But there was a bunch of complaining about that idea, so it probably won't happen.
12:32:30 <thoughtpolice> Wadler's law strikes again.
12:32:47 <EvanR> interesting: https://hackage.haskell.org/package/persistent-vector
12:32:59 <EvanR> supposedly faster than IntMap
12:33:19 <dolio> IntMap isn't that fast, I think.
12:33:30 <Tuplanolla> Too bad `$` isn't special enough to write `newtype Fix f = Fix $ f $ Fix f`.
12:34:05 <dolio> I forget how much faster edwardk's word map that he was working on was. But I wouldn't be surprised if it were several times faster.
12:35:04 <ski> imho you should also be able to write `foo if ... then ... else ...', `foo let ... in ...'
12:35:20 <EvanR> word map you say
12:35:25 <dolio> Yeah, I like all that stuff.
12:36:11 <dolio> EvanR: I mean, the other thing is that HashMap is faster than IntMap, I think.
12:36:27 <EvanR> for strings, thats what i heard
12:36:38 <dolio> And its hash for Int is like the identity function or something.
12:37:00 <dolio> I think it's faster for Ints, too.
12:37:01 <EvanR> thats... not the greatest hash ive ever heard of
12:37:04 <monochrom> HashMap pulls a different data structure trick than IntMap
12:38:07 <EvanR> IntMap is pretty often suggested in here
12:38:27 <dolio> IntMap isn't terrible. It's better than Map Int, I think.
12:38:54 <geekosaur> it is
12:39:21 <oish> evening
12:39:26 <geekosaur> I think unordered-contaners just hasn't quite gotten the level of ingrained-ness that containers has
12:39:47 <dolio> But HashMap not only uses a different data structure (which may already be better in a lot of cases), I think it's also had a lot more performance tweaking specific to GHC's low level features.
12:39:59 <geekosaur> (esp. since containers used to be part of base, and had IntMap back then too)
12:40:56 <geekosaur> and yes, HashMap got a lot of extra optimization I suspect just because of the lingering taint of Data.HashTable
12:41:30 <hexagoxel> what are the reasons for the flipped versions of (<$>) and (<*>) not having flipped fixity?
12:41:33 <dolio> I mean, also, tibbe maintained both packages for a while, but containers was inherited, and unordered-containers was his personal project.
12:41:33 <agocorona_> HashMap uses hashtables? I don´t think so
12:41:44 <geekosaur> no, it doesn't
12:42:02 <geekosaur> but there was worry about uptake because everyone remembered how terrible HashTable was
12:42:14 <geekosaur> (this *was* a serious and often voiced concern back then)
12:42:23 <agocorona_> ah ok
12:42:41 <dolio> So it's not surprising that he'd be more invested in tweaking out the thing he wrote himself.
12:43:17 <EvanR> so i really should compare performance persistent-vector with HashMap not IntMap
12:43:26 <geekosaur> (many people seem to have falsely believed that any hashed storage was going to suck as bad as HashTable did)
12:43:39 <monochrom> I would attribute HashTable slowness to simply IORef slowness.
12:43:51 <dolio> Probably. I know edwardk was trying to beat HashMap in the benchmarks on the map he was working on.
12:44:05 <dolio> Because he was probably already beating IntMap after the first thing he wrote down.
12:44:19 <et09> ongy: "recv" specifies a length, but the packets may be of indeterminate length (i could hypothetically set a limit at 20mb or something)
12:44:25 <et09> best practices?
12:44:41 <monochrom> Because I once helped speed up a beginner's project by simply replacing an imperatively-minded "loop over mutating an IORef" to "loop over a parameter"
12:45:33 <ongy> et09: you will have to read N times either way, since the stream may be split (that's why we have the incremental parsing). For the size I would either go with a guess, capped by pagesize (4k iirc)
12:45:49 <ongy> s/either//
12:46:24 <thoughtpolice> monochrom: Part of it was also GC interference that made HashTable really bad, too. It was still bad after that was fixed though
12:46:32 <geekosaur> "This function may return fewer bytes than specified"
12:46:47 <et09> i see 
12:46:55 <oish> quick persistent-sqlite question, it seems like I need to run migrations in any function where I speak to the database in order to make the type inferencer happy, or I get The type variable ‘backend0’ is ambiguous • In the expression: runSqlite ":memory:"; is that really the cae or is there some deep magic I can't figure out?
12:47:02 <dolio> Oh yeah. The really old stuff was before card marking of arrays.
12:47:15 <geekosaur> keep in mind that if this is TCP (I missed context) then you are working with a stream and cannot observe packet boundaries; things like recv return whatever is in the receive buffer
12:47:43 <geekosaur> (if it's UDP, then it receives exactly one packet)
12:48:05 <et09> it's TCP 
12:48:56 <et09> ok so in other words, if i hit a termination character specific to this protocol (MLLP), and the received chunk continues after that, i have to move along the completed message and then continue parsing the last one?
12:49:04 <et09> the newest one * 
12:49:11 <ab9rf> recv is guaranteed to return one datagram unless your buffer is too small for one datagarm
12:49:31 <geekosaur> with a datagram socket (UDP), yes
12:49:35 <ab9rf> for tcp a read from the socket will return at least 1 octet if there is data in the buffer, but beyond that you have no guarntees
12:49:37 <geekosaur> et09, yes
12:49:57 <EvanR> another thing about IntMap is it supports unions and intersections, something that doesnt make too much sense for array-like stuff, like Sequence and persistent-vector
12:50:07 <ab9rf> it might return the full buffer, it might return one packet's worth, it mighr return one segment's worth, it might return some other amount as determined by the moods of the OS
12:50:28 <EvanR> so maybe its suggested more often because the range of operations is larger, more like to work without knowing too much about what someone is doing
12:50:31 <et09> man i'm pretty pampered with all the frameworks i've been using
12:50:33 <ab9rf> you have to be prepared to get as much data as the size of the buffer you specify. do not assume that you will receive only one packet at a time
12:50:58 <ab9rf> et09: i wrote a multiprotocol IP library back in 1991 :)
12:51:04 <et09> so the parsing function has to work like a state machine
12:51:05 <amx> et09: I had the same problem recently and used io-streams to create a stream that will return one message of my protocol
12:51:12 <et09> ab9rf: i learned to walk around then, lol
12:52:02 <et09> i see, so that's a little higher level approach
12:52:29 <EvanR> use UDP for messages! ;)
12:52:41 <et09> not my choice sadly'
12:53:10 <ongy> I wouldn't just recommend UDP without some domain knowledge either
12:53:10 <ab9rf> et09: often it's best to consume octets from a buffer, which will then read from the socket whenever the buffer is empty
12:53:12 <geekosaur> but if you use udp then you have to implement your own retransmit etc.
12:53:22 <ab9rf> however, you have to be extremely careful about lookahead behavior
12:53:35 <ab9rf> because tcp reads will (by default) block if there is no data in the os buffer
12:54:01 <EvanR> you dont nec need retransmit
12:54:05 <ab9rf> so if your parser asks for a lookahead and there's no data in either your local buffer or in the OS buffer, a blocking read will hang
12:54:20 <ab9rf> there are solutions to this, but they are complicated
12:54:45 <ab9rf> best appraoch is to ensure that your protocol can tell end-of-message without needing a lookahead
12:54:46 <et09> i.e. call recv with "1" as the 2nd argument over and over ? 
12:54:53 <ab9rf> et09: polling reads are evil.
12:54:55 <ongy> ab9rf: the RTS will do some trickery to do unblocking read
12:55:09 <et09> it's not my protocol, i know the message is terminated with ascii character \whatever
12:55:11 <ab9rf> yeah, i don't kniow how the various haskell socket libraries handle this
12:55:29 <et09> i would prefer doing single byte reads if it's not performance-taxing
12:55:34 <EvanR> spawn a thread and do blocking reads
12:55:36 <ab9rf> et09: if that character can only occur at end-of-message, then your parser can always know that this is an end of read
12:55:44 <ongy> ab9rf: the unthreaded RTS will select befor the read iirc, not sure what exactly the threaded does
12:55:46 <ab9rf> et09: doing single-character reads from the OS is extremely nonperformant
12:56:23 <ongy> ab9rf: careful, that's only true if the other side will wait for an answer, since mutliple messages may be in the buffer
12:56:36 <et09> yeah thats what i thought
12:57:12 <et09> ab9rf:  what is the alternative to polling reads 
12:57:15 <ab9rf> ongy: the risk to mitigate here is a lookahead past end of message. i'm not suggesting throwing away content after end of message
12:57:49 <ab9rf> et09: depends on your application and its operating contenxt
12:58:02 <ab9rf> in a threaded runtime, you may be able to let the reader thread block
12:58:18 <EvanR> that even works in unthreaded
12:58:23 <EvanR> but dont use unthreaded anyway
12:58:30 <ab9rf> if you have a main loop, you would normally use a poll syscall in the mainloop instead of a sleep
12:58:42 <et09> relatively low bandwidth requirements, i'm basically just writing a proxy for this protocol to dump stuff into cassandra 
12:58:44 <ab9rf> (and in a lot of OSs, sleep is just a poll with no FDs selected)
12:59:19 <ab9rf> if yu're just parsing a stream, rather than managing a conversation, you can just use blocking reads 
12:59:44 <EvanR> in haskell you should just always use blocking reads
12:59:49 <EvanR> since we have nice concurrency
12:59:59 <ab9rf> yeah, the haskell runtime should handle this fairly cleanly
13:00:08 <ab9rf> you could maybe get timeleaks if your parser is stupid
13:00:29 <et09> i only have to send a specialized ACK when the message is done
13:00:37 <EvanR> you can even interrupt it with async exceptions (via async library or other ways)
13:00:50 <ongy> how does the threaded RTS handle blocking reads?
13:00:56 <et09> said specialization being context dependent 
13:01:01 <ab9rf> from what uyou're describing, i'd just open a handle, and then use conduits to transform it :)
13:01:04 <ongy> does it block an OS thread?
13:01:25 <et09> i'm understanding about 50% of this -_-
13:01:40 <EvanR> ongy: theres special OS threads dedicated to managing I/O
13:01:43 <monochrom> \∩/ timeleaks
13:01:51 <monochrom> @quote monochrom leak
13:01:51 <lambdabot> monochrom says: Time leaks like an arrow. Syntax rules like a macro.
13:02:21 <et09> a conduit ? 
13:02:27 <ongy> EvanR: so what happens if I do -N1? will it create more than one OS thread? (one for main, one for IO?)
13:02:47 <ab9rf> eh, fuh
13:02:56 <ab9rf> haskell.org is behind the dyn ddos fubar
13:02:59 <EvanR> it only needs 1 for managing the select 
13:03:23 <geekosaur> the threaded runtime is N:M. there are dedicated I/O threads that poll when a Haskell thread is descheduled for I/O; if the resource it waits on becomes active, it will be scheduled on an available OS thread (possibly a particular thread, if created with forkOS)
13:03:34 <ab9rf> Data.Conduit, a nice abstraction for handling data streams
13:03:48 <ab9rf> really useful for ETL applications, which sounds like what you're doing
13:04:19 <ab9rf> gah, i have roofing cement all over my fingers
13:04:22 <ab9rf> that stuff is nasty
13:04:57 <ongy> so how many OS-threads will there be with -N n? n + IO-thread(s)?
13:05:04 <EvanR> "poll" used in this context is sort of ambiguous... is it really polling, is it efficiently waiting without polling, is it literally using the poll syscall
13:05:28 <geekosaur> select/poll/epoll/kqueue/etc.
13:05:31 <et09> ab9rf: don't get that in your eyes or breathe it in 
13:05:32 <geekosaur> syscall
13:05:59 <ydl> is there a way to link in a static c library to a haskell library using the FFI? coupled to this question, is there then a way to use this library from ghci? perferably with stack ghci
13:06:02 <geekosaur> efficient OS level blocking on multiple I/O events, not busylooping in userspace or etc.
13:06:08 <monochrom> Do get that stuff into your eyes. Then you gain the superpower of petrifying people by looking at them. :)
13:07:27 <geekosaur> ydl, certainly with the FFI, although I understand there are complications with respect to ghci on Windows
13:07:59 <geekosaur> which is mostly Windows' fault; it really likes its DLLs
13:08:06 <ydl> geekosaur: that's exactly my usecase :)
13:09:33 <monochrom> change the rules. do not leave the c library as a separate c library. annex the c library into your haskell library.
13:09:39 <geekosaur> basically, ghci is inherently a dynamic load environment, and static libraries will be at a disadvantage. this is relatively easy to work around on POSIX systems, not so much on Windows
13:10:16 <geekosaur> you are better off making a dynamic stub for the static lib, or linking it with whatever (dynamic) lib uses it directly as monochrom suggests
13:10:16 <EvanR> ab9rf: ETL applications?
13:11:49 <ydl> monochrom, geekosaur: is there an example of (preferably portably) actually doing such a thing without rewriting too much code?
13:11:50 <monochrom> a haskell library contains C code. (in your *.cabal file, "c-sources: ...".) the haskell library's DLL will contain both haskell code and that C code.
13:12:16 <monochrom> s/a haskell library contains C code/a haskell library can contain C code/
13:12:51 <ydl> monochrom: but suppose the c library is non-trivial. lots of files/headers/involved compilation.
13:13:07 <monochrom> then my route is a maintenance nightmare
13:14:14 <thoughtpolice> ongy: "Unspecified". -N is not really a 1-to-1 map to OS threads, although it's fairly close. These days you can also scale it up, or down, at runtime, so -N alone can't give you all the knowledge up-front of what threads will be used. The amount of IO threads is also "unknown", because the RTS will create them in a thread pool to handle blocking syscalls.
13:14:15 <geekosaur> there aren't a lot of non-nightmare approaches in that case :(
13:14:39 <ydl> haha agreed :) so the "right" choice in this case is to cave and just compile a dll instead of a static library for the c code? and make sure the dll is in the path when ghci is launched? will the latter be enough for ghci to pick it up?
13:14:39 <monochrom> well, a nightmare only when the C library author is so eager to update the library every so often and you want to keep up :)
13:14:41 <kurt11> What is a simple idiomatic way to trim all trailing zero elements from a list of Ints. So [9,4,0,5,0,0,0] -> [9,4,0,5]
13:15:24 <dcoutts> ydl: using it in ghci pretty much requires a .dll
13:15:26 <ongy> thoughtpolice: how many blocking syscalls does the rts handle? the poll for fds, I guess wait(?) and?
13:15:34 <thoughtpolice> (-N is technically "the number of Haskell Capabilities", which can be thought of as an OS thread roughly, but this doesn't guarantee anything about the capability like its affinity or whatever)
13:15:44 <danharaj> thoughtpolice: fuck you
13:15:48 <dcoutts> ydl: if you have both a .dll and a .a, then ghc can use one for static linking and the other for dynamic/ghci
13:15:56 <Tuplanolla> Are you dealing with digits or are you sure your list shouldn't be reversed in the first place, kurt11?
13:16:01 <amx> > dropWhileEnd (== 0) [9,4,0,5,0,0,0]
13:16:03 <lambdabot>  [9,4,0,5]
13:16:04 <thoughtpolice> danharaj: sup
13:16:07 <geekosaur> ongy, those are the big ones. and wait is mishandled in the non-threaded runtime
13:16:14 <kurt11> @amx: ty! perfect!
13:16:15 <lambdabot> Unknown command, try @list
13:16:17 <danharaj> thoughtpolice: i am accidentally on IRC
13:16:24 <danharaj> may as well make the best of it
13:16:28 <ydl> dcoutts: how? :)
13:16:51 <thoughtpolice> ongy: It can handle as many as you specify. If you have 10,000 outstanding blocking foreign calls, the RTS will create that many. For regular file descriptors, the runtime system does not use blocking OS calls.
13:16:54 <ydl> dcoutts: also is it enough for the dll to be in the path when ghci is launched for it to work?
13:17:03 <noder> Hello, http://lpaste.net/289150 can someone help me establish the logic with my o function second event?
13:17:06 <monochrom> dcoutts: keep in mind this is windows, on which ghci's dynamic story is not quite complete...
13:17:10 <ongy> thoughtpolice: blocking foreign calls as in safe FFI calls?
13:17:21 <noder> basically, combine two string where they are similar
13:17:33 <thoughtpolice> danharaj: oh, you
13:18:02 <danharaj> the last time i was in here regularly, there were only 800 people
13:18:09 <danharaj> then i got a job and haskell became a chore not a hobby
13:18:32 <thoughtpolice> ongy: Correct. An unsafe FFI call that makes a blocking OS call will, in effect, halt the entire RTS. if a blocking call is encountered in a 'safe' call, the RTS moves that call into an OS thread (in its internal thread pool) and suspends the Haskell thread corresponding to it, then moves on.
13:19:05 <dolio> 800. How miniscule.
13:19:18 <thoughtpolice> So very 2006ish.
13:19:20 <danharaj> seriously, well within my dunbar number
13:19:29 <danharaj> back then everyone knew everyone
13:19:34 <ongy> thoughtpolice: that sounds weird, wouldnt the unsafe call only block the current OS-thread?
13:20:10 <geekosaur> ongy, in the threaded runtime, yes, but this still throws thread scheduling off
13:20:20 <thoughtpolice> ongy: No, because eventually the garbage collector will need to run. And to do that, it has to wait for every "Haskell capability" to stop running. If your capability is in a blocking call, it will not return until it is done, meaning in effect, you halt the entire system, because GC cannot start.
13:20:24 <geekosaur> in the non-threaded runtime, you lose
13:20:33 <geekosaur> hm, yes, that too
13:20:42 * geekosaur tries not to think about the GC too much :/
13:21:04 <ongy> so something that blocks for a long time is bad, but going into an unsafe call will not halt my RTS, right?
13:21:10 <nomeata> cdsmith_: hi. are you going to be at Hac-Phi already today, or are you joining tomorrow?
13:21:57 <ongy> what does the nonthreaded runtime do on safe ffi calls then?
13:22:14 <monochrom> ongy: Several Haskell threads are assigned to the same OS thread. If this OS threads also does FFI and blocks, then there are two cases:
13:22:26 <geekosaur> the "nonthreaded" runtime also actually uses I/O threads for this and other things
13:22:36 <monochrom> 1. "safe" FFI call: those Haskell threads are reassigned. Everyone is happy.
13:22:39 <geekosaur> as I understand it
13:22:49 <ongy> ohh, that's good to know. I have code with threadWaitRead littered to prevent blocking in FFI
13:22:50 <monochrom> 2. "unsafe" FFI call: those Haskell threads are screwed.
13:22:57 <thoughtpolice> ongy: It's only bad if it blocks for a long time AND it is in an "unsafe" call. It's OK to block if the call is "safe". If your unsafe call doesn't do anything sneaky like that (say it's just a hash function that's very fast), then no, you're not going to have an issue.
13:23:11 <monochrom> The best part is you usually don't know which Haskell threads are screwed.
13:23:29 <thoughtpolice> Of course, "blocking" is a bit of a misnomer here. If you had an 'unsafe' FFI call that never really 'blocked' on some syscall, but took like, ridiculous amounts of time to run -- it's basically the same problem.
13:23:48 <ongy> I'm mainly trying to grasp how much of this I got correctly from reading wiki (and maybe ghc-doc)
13:24:16 <monochrom> I think you should read mine instead: http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
13:24:51 <thoughtpolice> danharaj: Back In My Day, I installed all my dependencies by hand in the necessary dependency order.
13:25:05 * thoughtpolice couldn't figure out a way to turn that into a clear Overwatch joke, but oh well.
13:25:12 <danharaj> oh you play overwatch?
13:25:44 <dolio> We know you do.
13:25:45 <thoughtpolice> my real name is actually Mei-Ling Zhou, little known fact
13:25:52 <danharaj> do i have a fan club
13:25:56 <danharaj> how much acid did i do last weekend
13:26:14 <danharaj> did i do something stupid
13:27:31 <ongy> so its safe to remove all threadWaitRead I currently use to prevent blocking in safe FFI calls, even if I run the nonthreaded RTS (whcih I shouldn't be doing?)
13:28:31 <geekosaur> if they are tagged "safe" then you aren't accomplishing anything except possibly being slightly kinder to the thread scheduler, which already would deal anyway
13:29:17 <ocramz> o joy, github and hackage are back online
13:30:21 <knupfer> Why is viewl from Data.Sequence not called head and viewr last?
13:30:32 <thoughtpolice> danharaj: fan clubs are out of date, it's all about your number of Twitter followers
13:30:51 <Tuplanolla> Because they give you the rest too, knupfer.
13:31:36 <danharaj> knupfer: that is the style for functions that return an element and "the rest"
13:31:38 <jass> | otherwise  = let o fs ss = fs ++ drop (length $ overlap fs ss) ss      -- is this definition correct?
13:32:07 <danharaj> :t minView
13:32:09 <lambdabot> error:
13:32:09 <lambdabot>     • Variable not in scope: minView
13:32:09 <lambdabot>     • Perhaps you meant one of these:
13:32:12 <jle`> jass: what is it a definition for?
13:32:13 <danharaj> fuck off lambdabot
13:32:21 <danharaj> knupfer: for example, minView, maxView in Data.Map.Lazy
13:32:44 <jass> jle`: http://lpaste.net/289150
13:32:47 <jass> jle`: basically
13:32:59 <jass> but im getting a parse error
13:33:39 <jle`> jass: you need an "in" when you're using let to define an expression
13:33:42 <jle`> let .. in ...
13:33:52 <jle`> otherwise what are you even trying to do?
13:34:01 <jle`> you're trying to return a Str, right?
13:34:34 <jass> jle`: right
13:34:34 <jle`> jass: 'let' works like "let foo = bar in ..."
13:34:48 <jle`> and in the "..", you can use the definitions you provided in the "foo = bar" part
13:34:55 <jle`> in what you wrote, you just defined a function locally
13:35:01 <jle`> but you didn't say what the epxression should actually be
13:35:04 <knupfer> Hm. And why isn't there head and last?  It seems to me more intuitive comming from a list.
13:35:07 <jle`> > let foo x = x * 2 in foo 10
13:35:10 <lambdabot>  20
13:35:24 <knupfer> Are there any advantages of such an api?
13:35:40 <jle`> jass: ^ the epxression is "foo 10", and i'm allowed to use the things i defined in the "let .." part
13:35:57 <danharaj> knupfer: head and last are partial, which is widely considered a mistake
13:36:31 <jle`> viewl also doesn't even fit the definition/type of head
13:36:44 <jle`> if you wanted to make it consistent w/ the list api, you'd call it 'uncons'
13:36:49 <jle`> > uncons [1..10]
13:36:52 <lambdabot>  Just (1,[2,3,4,5,6,7,8,9,10])
13:37:10 <Phyx-> monochrom: dynamic linking should work fine, it's dynamic way that's not there yet, will be soon though
13:37:12 <monochrom> even for lists, head and last are unintuitive because "what if empty?". at least for most usages
13:37:20 <knupfer> danharaj: Yes, but it could have  head :: Seq a -> Maybe a
13:37:30 <jass> jle`: could you please annotate my code? I get what youre saying but ..
13:37:39 <jle`> knupfer: even if you wanted to define a 'head'/'last' for Seq, they wouldn't be viewr/viewl
13:37:47 <jle`> they'd be head :: Seq a -> a
13:37:48 <danharaj> knupfer: it's true that there could be a little bit of sugar, and i personally would have preferred Maybe (a, Seq a) instead of this ViewL data structure.
13:38:10 <danharaj> however viewl and viewr are justified as they are, and perhaps more helpers could be added
13:38:12 <jle`> jass: what do you want me to annotate it with?
13:38:31 <knupfer> jle`: I'd prefer a maybe.
13:38:42 <monochrom> I like the custom ViewL ADT because it's a bit more efficent (and a bit less semantic junk) than Maybe (a, Seq a)
13:38:59 <jle`> knupfer: even if it was head :: Seq a -> Maybe a, that'd be different than viewr
13:39:02 <jass> jle`: how would you  write the function
13:39:08 <jle`> jass: i don't know what the function is supposed to do
13:39:15 <jle`> i don't even know what hte Str type is
13:39:17 <jle`> :'(
13:39:20 <allenj12> how do you upgrade the packages in your stackproj.cabal ? im getting containers-0.5.7.1 must match >=0.5.8.1 last applicable is 0.5.8.1
13:39:23 <knupfer> danharaj: Albeit I dislike partiality, I think there are at least some people which consider it aceptable.  Look at `stimes`, that's worse than head.
13:39:24 <monochrom> Also if your program uses both viewl and viewr, then the two different types ViewL and ViewR guards against an easy-to-make mistake.
13:39:27 <jle`> jass: your problem is that you need otherwise = ..., to return an expression
13:39:34 <jle`> but "let foo = ..." is not an expression
13:39:44 <jle`> you need "let foo = ... in (the result of your function)"
13:39:50 <knupfer> jle`: Why would it be different?
13:40:01 <monochrom> However this is refinement details. The main spirit is you want at the very least something like Maybe (a, Seq a).
13:40:06 <jle`> knupfer: viewr/viewl also returns the rest of the seq
13:40:15 <jle`> so they're more like uncons for lists
13:40:21 <monochrom> Not the old partial-function story of "head and tail".
13:40:29 <danharaj> stimes?
13:40:29 <jle`> they don't return just the first or last elements
13:40:32 <knupfer> jle`: ok, but it's shared anyway, so you could call head and call tail
13:40:49 <monochrom> s/head and tail/a function for head, another function for tail, and a third one for "is it null?"/
13:40:54 <jass> jle`: http://lpaste.net/289150
13:40:55 <jle`> knupfer: sure, i'm just saying that "head" is a bad name for viewr
13:41:01 <knupfer> danharaj: from Semigroup, the coming superclass of Monoid
13:41:01 <jass> jle`: I thought I was on the right track
13:41:06 <monochrom> read my http://www.vex.net/~trebla/haskell/crossroad.xhtml .
13:41:27 <jle`> knupfer: if your argument is that it's consistent with list, then it's actually pretty inconsistent with list
13:41:47 <knupfer> jle`: good point
13:41:47 <jle`> jass: you might be
13:42:02 <jle`> but remember, "let ... in ..." is an expression
13:42:04 <danharaj> being inconsistent with list would be a point in favor to me :p
13:42:05 <jle`> not "let ..."
13:42:08 <jle`> you want to return something
13:42:21 <jle`> but "let ..." does not return a value
13:42:33 <jle`> "let ... in ..." returns a value...the part after the "in"
13:42:43 <jass> jle`: so I get that Im missing the in but 
13:42:57 <jle`> what are you even trying to return in the otherwise case?
13:42:59 <jle`> what is the result?
13:43:23 <imalison> Hi. I installed xmonad-contrib from source, and now when I try to recompile my xmonad.hs I'm getting errors like http://pastebin.com/mCWfWkas
13:43:35 <jass> a list Str with the past strings combined
13:43:43 <jass> eg "fire" ‘o‘ "red" = "fired" "water" ‘o‘ "blue" = "waterblue"
13:43:48 <jle`> then put that after the "in" :)
13:43:51 <imalison> It seems that somehow the version of xmonad that I compiled xmonad-contrib against is different than the version I have globally installed
13:44:47 <imalison> 2 questions: what is the string after the final dash in xmonad-0.12-2GDBWwSJPDc58Xg9q7fgK4?
13:44:47 <jle`> jass: or just get rid fo the let altogether if you don't need it
13:44:55 <jle`> jass: | otherwise = ... (your result)
13:44:58 <imalison> is it a hash associated with the build in some way?
13:45:53 <imalison> Is there a way to make cabal compile with a specific version of a dependency that I supply
13:46:00 <jass> jle`: you mean like thos? | otherwise = fs ++ drop (length $ overlap fs ss) ss 
13:46:08 <dcoutts> imalison: yes
13:46:34 <imalison> dcoutts: to which question?
13:46:54 <dcoutts> imalison: the last one, sorry I should leave this to others, I'm too busy
13:47:21 <dcoutts> imalison: but you can use --constraint='foo == 2.3' or cabal install ./this ./that
13:47:33 <imalison> dcoutts: no I know that
13:47:35 <jle`> jass: if that does give what you want, then yes
13:47:38 <imalison> but this would have to be from source
13:47:54 <imalison> the semver versions of xmonad are the same
13:48:06 <Cale> imalison: Yes, it's a hash associated with the build of that package, and yes you can specify a version. You should try to avoid having multiple copies of the same package installed in the same context if at all possible though.
13:48:17 <geekosaur> the hash is part of the semver, actually. as I told you in email, things are more complex with ghc
13:48:24 <imalison> Cale: I don't have multiple copies installed
13:48:40 <imalison> which is why im confused about why this is even happening
13:48:51 * hackagebot sdl2-mixer 0.1 - Bindings to SDL2_mixer.  https://hackage.haskell.org/package/sdl2-mixer-0.1 (SinisaBidin)
13:49:00 <geekosaur> then you have an xmonad-contrib which is built against an xmonad that is no longer installed
13:49:00 <imalison> Just a quick clarification about where these dependencies get pulled from by cabal
13:49:04 <geekosaur> and may have to remove and reinstall
13:49:09 <imalison> yeah thats fine
13:49:12 <imalison> I've actually done that
13:49:19 <imalison> even after I reinstall I get the same issue
13:49:30 <geekosaur> then there is still something referencing it somewhere
13:49:45 <imalison> so when cabal tries to resolve a dependency
13:50:04 <imalison> and it seems something in .cabal/lib/architecture
13:50:11 <imalison> it should use that package, correct?
13:50:29 <geekosaur> actually when it is resolving those it is using ~/.ghc
13:50:37 <imalison> ahhh okay
13:50:43 <imalison> maybe ive been looking in the wrong place then
13:50:44 <Cale> imalison: ghc-pkg list <packagename>  can tell you what GHC thinks is installed. There are some variants of this for cabal sandboxes and stack.
13:50:58 <geekosaur> the pkg config files under there point back into .cabal, but the control is all from ~/.ghc
13:51:20 <imalison> how can i see that build hash
13:51:31 <imalison> because all i can see with that command is the semver version
13:52:04 <geekosaur> ls ~/.ghc/$version/package.conf.d
13:52:10 <glaukon> SO question about "Truly portable Haskell installation on Windows" http://stackoverflow.com/questions/40185235/truly-portable-haskell-installation-on-windows
13:52:15 <imalison> ahh okay thats inteteresting
13:52:15 <geekosaur> and again, the hash is PART OF the semver
13:52:41 <imalison> well i mean semver stands for semantic versioning
13:52:43 <geekosaur> that is why the hash is there, the semantic version is INCOMPLETE without yhe hash
13:52:55 <imalison> and is a hash really semantic
13:52:56 <geekosaur> you mean base version, or something else that is nto semantic
13:52:59 <imalison> but i take your point
13:53:09 <geekosaur> what does semantic mean to you?
13:53:30 <imalison> like meaningful in and of itself
13:53:38 <imalison> I cant tell just by looking at it
13:53:50 <imalison> if something with some hash precedes something with some other hash
13:54:01 <geekosaur> but the base version is not meaningful in and of itself because it does not fully describe the ABI, which is what drives the semantics of the version
13:54:18 <geekosaur> it does not mean semantically meaningful to you, it means semantically meaningful to the ABI/linkage
13:54:39 <imalison> http://semver.org/
13:54:50 <geekosaur> and the base version without the hash is missing important parts of the ABI (because ghc cheats in the name of performance and exposes internally generated names)
13:55:05 <imalison> anyway, I appreciate your help
13:55:07 <geekosaur> yes, I know what semver is
13:55:48 <imalison> first line from that page: Given a version number MAJOR.MINOR.PATCH, increment the:
13:55:52 <geekosaur> either you have not read the *whole* site and considered how it applies to something like ghc, or you have decided on a short form that might be good enough for some other environments
13:55:55 <imalison> a hash cant really be incremented
13:56:10 <geekosaur> ok, so every environment works exactly like C, noted
13:56:15 <geekosaur> ghc has to be destroyed now
13:56:20 <imalison> geekosaur: not thats not what im saying
13:56:27 <imalison> I don't mean to be adversarial
13:56:32 <imalison> this is really a very technical point
13:56:38 <imalison> im not saying that having hashes is bad or anything
13:56:43 <geekosaur> you cannot put exposed generated names into a major.minor.version
13:56:46 <imalison> I just consider semantic versioning to be like a version number
13:56:52 <monochrom> You need to know how GHC pulls of all its impressive optimizations in order to see why for GHC-built library, version number is still not the whole semantic story.
13:57:02 <geekosaur> ghc has to do this or the code produced is unusably slow
13:57:27 <monochrom> But the short answer is that a library's binary file ends up containing a depended library's binary code, too.
13:57:33 <geekosaur> so for ghc the semantic version is more than major.minor.patch
13:58:09 <monochrom> therefore "containers-4.5 built against base-4" doesn't have the same semantics as "containers-4.5 built against base-3.9999999"
13:58:35 <imalison> monochrom: what do you mean by semantics in this context?
13:58:50 <monochrom> API and behaviour
13:58:55 <geekosaur> we'd love it if it didn't, but doing things the "we can completely describe a semantic version with maj.min.pat" way is too slow when your evaluation strategy is not procedural at heart
13:59:16 <sbidin> I uploaded sdl2-mixer to Hackage, but the online build failed due to Hackage not finding SDL2_mixer in the pkg-config database (sdl2-mixer is a thin wrapper over SDL2_mixer). Is this something I can fix or do I need to upload the documentation manually? Thanks for any help.
13:59:20 <geekosaur> ghc exposes internals for inlining across modules to get performance
13:59:46 <monochrom> Actually if GCC did cross-library inlining, it would enjoy the same semantics mess and suffer the same performance boost, too.
13:59:54 <dolio> Is SDL2_mixer some C library or something?
13:59:54 <glguy> sbidin: Yeah, I wrote a script for that you can use
13:59:58 <geekosaur> sbidin, the latter unless you can talk someone in #hackage into adding the dev libs for SDL2_mixer to the installed OS packages
14:00:03 <sbidin> dolio: Yes.
14:00:04 <monochrom> Why the C compiler writers haven't done that is beyond me.
14:00:17 <glguy> sbidin: https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
14:00:34 <geekosaur> monochrom, they do LTO instead, which is more or less whole-program compilation
14:00:41 <sbidin> glguy, geekosaur: Thanks, I'll give it a try!
14:01:13 <monochrom> Why would programmers not want to suffer performance boost :)
14:01:32 <glguy> sbidin: If you're uploading documentation for your packages it's necessary to have been building it for your dependencies. The best way to be doing that is to have documentation:True in your ~/.cabal/config
14:02:43 <monochrom> (And do not think that "separate compilation" refutes it. The C++ compiler writers long solved that with "pre-compiled headers". GHC simply does the same thing and brings it further.)
14:03:11 <monochrom> (I.e., look at the *.hi files some day.)
14:03:23 <imalison> I'm still not convinced that applying the term 'semantic' to the hash is appropriate
14:03:34 <imalison> but I'll admit that I don't understand everything you are saying
14:03:35 <geekosaur> it is needed to fully describe the ABI. it is semantic
14:03:45 <geekosaur> the semantics of the ABI are not defined in absence of the hash
14:04:00 <geekosaur> semantics does not mean "looks like maj.min.pat"
14:04:05 <geekosaur> that is *syntactic*
14:04:06 <monochrom> If you knwo assembly code, you know what I'm talking about.
14:04:13 <imalison> no its not syntactic
14:04:20 <imalison> because each version has some meaning
14:04:21 <imalison> as in
14:04:42 <imalison> if you change maj that says something about what happened in the code
14:04:50 <geekosaur> to the extent that you do not want a hash there because it doesn't look like the rest, yes your complaint is syntax not semantics
14:05:06 <imalison> no, actually my complaint is  not about how it looks
14:05:19 <geekosaur> the problem is that semantic ABI version depends on compiler generated names that are not the same between compiles
14:05:23 <imalison> its just that the hash doesnt tell you anything in particular about holw the libarary changed
14:05:26 <imalison> its just a hash
14:05:32 <imalison> the hash itself has no meaning
14:05:38 <geekosaur> ok, we are back to "ghc must die"
14:05:42 <imalison> nope
14:05:47 <geekosaur> and arguing in circles
14:05:53 <imalison> I think its fine that ghc uses it as a version number
14:05:55 <EvanR> the hash has a meaning
14:06:00 <imalison> its just not part of the semantic version number
14:06:06 <imalison> what 'meaning' does the hash have?
14:06:07 <geekosaur> te meaning is only permitted to apply to the source code
14:06:21 <monochrom> No, the hash has a meaning, indirectly, and you do not know yet how.
14:06:28 <geekosaur> the hash may be essential to the ABI semantic, but ABI semantics is apparently not semantics
14:06:59 <geekosaur> never mind that the whole reason for semantic versioning is to make the version reflect the ABI semantics faithfully
14:07:07 <monochrom> This is similar to when a typical student in my class cannot distinguish between "problem X can't be solved" from "I haven't solved X yet".
14:07:45 <imalison> I think that you are misunderstanding what im saying
14:08:28 <monochrom> I don't think there is any room for misunderstanding a simple "I claim that the hash has no meaning".
14:08:28 <geekosaur> I am understanding that you object to part of the ABI semantics being called semantics
14:08:35 <Tuplanolla> I'm reminded of sssilver.
14:08:55 <imalison> do people list the hash when they are listing dependencies in cabal?
14:08:59 <monochrom> But you can always retract your statements now.
14:09:25 <monochrom> No.
14:09:32 <imalison> to me the semantic in semver has to do with interdependencies between code libraries
14:09:39 <geekosaur> imalison, cabal and stack exist to try to navigate the shoals caused by the compiler internals being part of the ABI, as expressed by the hash
14:09:54 <monochrom> But do you know source code is not assembly code?
14:10:05 <imalison> monochrom: yes of course
14:10:06 <monochrom> Do you know linkage?
14:10:10 <imalison> yes of course
14:10:12 <geekosaur> imalison, yes, that being defined by an ABI
14:10:36 <monochrom> Have you read assembly code generated by GHC?
14:10:37 <imalison> im not saying anything like what is the point of the hash
14:10:39 <geekosaur> but to you apparently an ABI can always be defined solely by the source code, and the source-to-intermediate mapping is not permitted to participare
14:10:44 <geekosaur> in ghc it does participate
14:10:49 <imalison> no im not saying that at all
14:10:52 <geekosaur> in ghc it MUST participate
14:11:02 <geekosaur> yes, you have repeatedly said that in different ways
14:11:06 <imalison> no I haven't
14:11:09 <geekosaur> and rejected the alternative in different ways
14:11:15 <imalison> you've just chosen to interpret what I'm saying in that way
14:11:26 <youtmon> anyone hear about cyber attack?
14:11:32 <monochrom> yes
14:12:06 <youtmon> where is is sourced from?
14:12:15 <monochrom> I think no one knows yet.
14:13:51 <imalison> monochrom: geekosaur: I appreciate your expertise and I don't understand why this conversation become so hostile, with that said, take a look at this issue from the semver repo: https://github.com/mojombo/semver/issues/162
14:14:03 <imalison> It expalins that semver is exclusively concerned with versioning source code
14:14:12 <imalison> and NOT generated binaries
14:14:12 <geekosaur> then semver cannot apply to ghc
14:14:24 <imalison> okay thats fine
14:14:27 <geekosaur> also they are stupid and will regret the limitation
14:14:27 <imalison> maybe that is all I was saying
14:14:40 <monochrom> I can agree to not say "semantics version" at all.
14:14:41 <imalison> well the issue is about suitably modifying it
14:14:49 <geekosaur> because LTO is already outstripping their arbitrary limitation
14:14:52 <Tuplanolla> Your confusion seems to stem from "semantic versioning" being different from "versioning that is semantic", imalison.
14:15:18 <Tuplanolla> It's unfortunate that they both share the same name.
14:15:39 <imalison> Tuplanolla: can you just clarify what is meaningfully semantic about the hash
14:15:48 <imalison> I understand that its important to uniquely identify
14:15:50 <monochrom> I am down to earth and fine with letting holy names stay as holy names and move on to secular matters that actually matter.
14:16:06 <imalison> but I dont see any meaning in the hash itself
14:16:20 <imalison> to me that is what makes the hash non semantic
14:16:35 <Tuplanolla> Well, the hash doesn't care about your shortcomings.
14:16:38 <monochrom> such as how "containers-4.5 built against base-4" is not going to be compatible with "containers-4.5 built against base 3.99999" no matter what words you use in holy names.
14:16:47 <imalison> Tuplanolla: thats pretty condescending
14:17:18 <imalison> monochrome: yes of course
14:17:25 <imalison> that doesnt make the hash semantic
14:17:31 <imalison> its just indespensible
14:17:36 <imalison> and HAS to be there
14:17:40 <dolio> What does 'semantic' mean?
14:17:41 <imalison> but its not part of the semantic version
14:17:47 <geekosaur> imalison, the relevant semantics are not "semantic to you". they are "semantic to the ABI"
14:17:59 <geekosaur> if you cannot separate these, it will never make sense to you
14:18:15 <monochrom> I don't care about "semantic version", OK? It's a holy name that has nothing to do with the secular matter of GHC-generated code.
14:18:25 <amx> next up: let's discuss the semantics of "semantic" ;)
14:18:25 <geekosaur> and as LTO becomes more complex and more prevalent. this will occur in C and C++ and etc. as well
14:18:30 <imalison> the version itself is still not semantic to the ABI
14:18:34 <imalison> its required
14:18:40 <EvanR> to be semantic to
14:18:49 <ongy> LTO?
14:18:57 <pikajude> link time optimization
14:18:59 <monochrom> I don't even know why someone brought up "semantic version" and "semver.org" to begin with.
14:19:00 <imalison> amx: I mean thats what im trying to do
14:19:04 <Tuplanolla> I'm opening a ticket to rename it to "slurptastic versioning".
14:19:09 <monochrom> They are quite irrelevant.
14:19:11 <geekosaur> "link time optimization" which secretly means "actually doing the compilation/code generation at link time"
14:19:21 <pikajude> "we have the best versioning, don't we, folks?"-versioning
14:19:32 <geekosaur> the compile phase stops at internal representation instead of object code. link time creates all object code
14:19:48 <EvanR> another one is isomorphic javascript
14:19:56 <EvanR> what makes it isomorphic, nothing
14:19:56 <geekosaur> and can inline as it sees fit, etc. basically how C/C++ do what ghc does now
14:20:03 <monochrom> The hash is a hash of types and even some inlined code. Basically the *.hi files.
14:20:04 <ongy> does llvm properly do that yet? I read about it somewhere
14:20:06 <geekosaur> nad has for years
14:20:12 <geekosaur> LLVM is *based* on that
14:20:17 <pikajude> what is nad
14:20:23 <pikajude> google is not helping
14:20:23 <geekosaur> typo for "and"
14:20:27 <monochrom> It is a probabilistic checksum for assembly-level compatibility.
14:20:30 <pikajude> that explains a lot
14:20:36 <Tuplanolla> Try the Urban Dictionary, pikajude.
14:20:48 <monochrom> And I am not going to argue semantics. Literally.
14:20:54 <pikajude> I know what a colloquial nad is
14:21:26 <geekosaur> the whole point of LLVM from the beginning was compiling to an IR and generating native code at link time. but clang became popular with the native code gen happing at the wrong time so it would be "consistent and compatible with" other compilers
14:21:42 <glguy> pikajude: "nad" is a misspelling of "and"
14:21:59 <monochrom> Don't tell me more about semantic versioning because this channel and your xmonad problems are about what GHC does, not what semver.org does.
14:22:01 <geekosaur> that said, codegen from IR has been evolving from the beginning as well and is much better now than it was in early releases
14:22:02 <pikajude> I think we covered that
14:23:02 <geekosaur> mostly because the tech to generate native code from IR has existed since the 1980s but the performance always sucked. the compiler really needs to pass more meta-information to the final codegen, and this is where LLVM is constantly evolving
14:23:13 <imalison> monochrom: I'm fine with that, and I really appreciate your help. I really don't understand all of the hostility though.
14:23:31 <sbidin> /quit
14:23:31 <sbidin>  
14:23:48 <geekosaur> because understanding why the hash IS semantic is core to understanding why you are having conflicts here
14:23:53 <geekosaur> with xmonad linking that is
14:25:24 <monochrom> I am hostile to the Dunning-Kruger effect.
14:25:25 <imalison> can you just tell me what semantic means to you in this case
14:25:29 <imalison> as a word?
14:26:26 <geekosaur> has meaning with respect to some specific usage. in this case, the only relevant usage is the ABI because it controls linking, which is where you are having problems
14:26:45 <geekosaur> meaning *to you* is not the relevant semantic universe
14:27:11 <agocorona> sss
14:27:30 <geekosaur> also, nobody likes this. it would be really nice if somehow it could be made unnecessary.
14:27:47 <dolio> All you have to do is completely rearchitecture GHC.
14:27:49 <EvanR> i think the question what does semantics mean cant be answered due to a well foundedness problem
14:27:55 <geekosaur> but haskell code performance ends up sucking really really badly if you don't expose these internals, and then you have to make that exposure part of the ABI
14:28:10 <monochrom> Yes, simply rearchitecture GHC to Hugs :)
14:28:15 <dolio> Yes.
14:28:20 <imalison> EvanR: you mean like a circularity issue
14:28:26 <dolio> And do jitting at runtime for all your optimization.
14:28:27 <monochrom> Clearly, python and ruby solved the problem that way.
14:29:30 <imalison> geekosaur: I am quite aware of what my issue is here. I actually understand very well what it is
14:29:40 <imalison> but I just happen to think it is a version compatibility issue
14:29:47 <imalison> but not a semantic version compatibility issue
14:30:16 <imalison> it merely has to do with compiler internals, not that the API changed, but that the ABI changed
14:30:55 <EvanR> we can stop calling stuff disputed names... 
14:31:07 <EvanR> describe it how it is, no source code issues exist
14:31:33 <imalison> well can we at least acknowledge that a meaningful distinction can be made
14:31:47 <imalison> and that it makes sense to have versions that reflect those meaningful distinctions
14:35:49 <EvanR> isnt that how it is?
14:48:53 * hackagebot sdl2-gfx 0.2 - Bindings to SDL2_gfx.  https://hackage.haskell.org/package/sdl2-gfx-0.2 (SinisaBidin)
14:50:59 <allenj12> if i have two functions : x :: (Int -> Integer) -> Int -> Integer and y :: (Int -> b) -> (Int -> b) . Shouldnt it be impossible to compose them (y . x)
14:51:54 <allenj12> im looking at the memoize and fib functions in https://wiki.haskell.org/Memoization
14:54:25 <sm> sbidin: thanks for uploading your sdl2 stuff
14:54:45 <monochrom> Let us calculate, not think.
14:55:08 <geekosaur> :t let x :: (Int -> Integer) -> Int -> Integer; x = undefined; y :: (Int -> b) -> (Int -> b); y = undefined in y . x
14:55:09 <lambdabot> (Int -> Integer) -> Int -> Integer
14:55:21 <geekosaur> which is what I would expect
14:55:44 <Tuplanolla> Very Leibniz of you.
14:56:26 <allenj12> thats what I got to, but thats not what I expected, shouldnt the overall return type be (Int -> b) since it is the result of y
14:56:32 <monochrom> To type-check (y . x), first recall (.) is like (B -> C) -> (A -> B) -> (A -> C), where A,B,C are to be determined by x and y.
14:57:13 <monochrom> And it wants B->C to be Int->b from y. Therefore B=Int, C=b.
14:58:14 <monochrom> No. It wants B->C to be (Int->b)->(Int->b), therefore B=Int->b, C=Int->b.
14:59:10 <monochrom> It also wants A->B to be (Int -> Integer) -> Int -> Integer from x. Therefore, A = Int->Integer, B = Int->Integer.
14:59:27 <monochrom> This is compatible with B = Int->b. Therefore, b = Integer.
15:00:09 <monochrom> The result of (y . x) is to be A->C = (Int->Integer) -> (Int->b) = (Int->Integer) -> (Int->Integer)
15:00:22 <monochrom> everything is consistent. done.
15:00:31 <EvanR> fix returns least defined fixed points?
15:00:35 <allenj12> I need to typet his out 
15:00:35 <EvanR> or most defined
15:00:41 <slack1256> @type flip id
15:00:43 <lambdabot> b -> (b -> c) -> c
15:00:50 <monochrom> do not "think". do not use intuition. use rules and logic. calculate.
15:01:27 <monochrom> Haskell does not require you to solve quadratic equations, but it requires you to solve type equations. http://www.vex.net/~trebla/haskell/prerequisite.xhtml
15:02:18 <geekosaur> allenj12, the short version is that the signature on y says that b is specified by how y is used. in this case, y is composed with x, and x requires y to accept Integer there. b is compatible with Integer because it has no constraints claiming otherwise, therefore b is taken as Integer in the composition
15:02:37 <glguy> EvanR: http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Function.html#v:fix
15:03:00 <monochrom> EvanR: least defined
15:03:02 <EvanR> ones is fix (1:)
15:03:09 <EvanR> but isnt ⊥ a fixed point 
15:03:11 <allenj12> geekosaur: but dosnt Y want a full function not just an Integer
15:03:17 * EvanR thinks out loud
15:03:29 <Tuplanolla> What does "least" mean there?
15:03:33 <EvanR> least defined
15:03:42 <geekosaur> allenj, it wants something (Int -> b) for some b. x will supply it with an (Int -> Integer).
15:03:55 <geekosaur> Integer is a perfectly acceptable b
15:04:21 <Tuplanolla> What does "least defined" mean there? Isn't something either defined or not?
15:04:29 <geekosaur> because y does not say what b must be, therefore it is allowed to be Integer
15:05:28 <monochrom> For example, to solve the equation x = x * 0, there are two solutions, bottom and 0. 0 is the most defined solution, but a computer is not going to do that. the computer is dumb and gives you the least defined solution, bottom for this.
15:05:33 <allenj12> geekosaur: im still lost how (Int -> b) can be equivalent to Integer, i think I need to type out what monochrom said
15:05:38 <geekosaur> it's not
15:05:43 <geekosaur> *b* is equivalent to Integer
15:06:02 <geekosaur> this makes (Int -> b) into (Int -> Integer)
15:06:02 <monochrom> You see even I made that mistake in the 1st step :)
15:06:02 <allenj12> but Y want a function with a b not a b itself
15:06:10 <geekosaur> which is what x is providing
15:07:02 <EvanR> > (1:) undefined
15:07:03 <monochrom> y wants (Int->b), x provides (Int->Integer), therefore set b=Integer and everyone is happy.
15:07:05 <lambdabot>  [1*Exception: Prelude.undefined
15:07:06 <EvanR> ah
15:07:25 <allenj12> but x in this case returns an integer
15:07:32 <geekosaur> no
15:07:33 <allenj12> im so confused, I think i just need a minute
15:07:46 <monochrom> 1:bottom is still not a solution to x = 1:x.  Because 1:bottom != 1:1:bottom
15:07:46 <geekosaur> because (a -> b) -> a -> b is the same as (a -> b) -> (a -> b)
15:07:59 <geekosaur> because the function arrow associates rightward
15:08:06 <monochrom> x does not return an integer. this is why intuition is bunk. x returns Int->Integer.
15:08:20 <Tuplanolla> Oh, I see now.
15:08:48 <allenj12> OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
15:08:51 <allenj12> ok
15:09:04 <monochrom> kill all intuition from your brain
15:09:05 <geekosaur> we do the same with map
15:09:09 <geekosaur> :t map
15:09:11 <lambdabot> (a -> b) -> [a] -> [b]
15:09:21 <monochrom> be a robot. I did. life is so much easier afterwards
15:09:30 <geekosaur> which we often treat as (a -> b) -> ([a] -> [b])
15:09:52 <geekosaur> (any time you partially apply map, you are relying on this)
15:09:53 <allenj12> monochrom: robots fail with the wrong rules :D in fact i was taking the return to literally
15:09:54 <monochrom> I have another one inferring the type of (.) . (.) on lpaste. It's a wonder.
15:11:05 <siwica> I am trying to enable font-lock-symbols in Emacs by setting `haskell-font-lock-symbols` to `t`. However I am seeing no changes in how things are displayed. Any hints?
15:11:40 <grantwu> Which version of rem/mod mostly closely matches the behavior of the C version?
15:11:43 <allenj12> geekosaur: thank you so much, I thought I was going crazy haha
15:11:50 <allenj12> monochrom: thank you
15:12:01 <grantwu> (Doing constant propagation for a subset of C)
15:14:37 <dazednconfused> hi room. n00b here. how would i go about writing a function similar to this?
15:14:51 <lpaste> dazednconfused revised “Pseudocode”: “Pseudocode” at http://lpaste.net/289698
15:15:30 <allenj12> geekosaur: so just to be clear tho since were treating the ..Int->Integer as a function instead of just returning Integer, that means that its fib with One argument (currying the rest)?
15:15:36 <dazednconfused> i'm not sure how to handle the return in the case statement and the flags and wCount accumulator
15:15:37 <grantwu> dazednconfused: How much experience with functional programming do you have, and what does that snippet of code actually just solve?
15:16:32 <allenj12> dazednconfused: it might actually be better to start with what you want to do in plain english first
15:16:44 <geekosaur> allenj12, I think you're confusing currying and partial application. currying is part of what enables partial application; the rightward association of the function arrow is another part
15:16:45 <dazednconfused> grantwu: i'm a beginner
15:18:00 <dazednconfused> i'm looking to iterate through a list, set a boolean flag based on the element in the current iteration, return a false if it matches some condition
15:18:05 <allenj12> geekosaur: really? cause fib with one argument does return a (Int -> Integer). So is this some sort of hard equivalence then?
15:18:29 <grantwu> dazednconfused: Uh... try looking at a right fold
15:19:25 <Tuplanolla> That description sounds more like `mapAccumR` to me, grantwu.
15:19:35 <grantwu> Tuplanolla: ...o
15:19:54 <Tuplanolla> I can't read minds though.
15:20:10 <siwica> anybody successfully using haskell-font-lock-symbols in emacs?
15:20:47 <geekosaur> allenj12, I'm not sure what you are talking about. is what a hard equivalence?
15:21:11 <geekosaur> treating ... -> x -> y as ... -> (x -> y) is a hard equivalence, yes
15:21:32 <geekosaur> a -> b -> c -> d -> e is (a -> (b -> (c -> (d -> e))))
15:21:45 <geekosaur> which is what rightward association means
15:21:51 <allenj12> geekosaur: yea, thats why im confused how currying isnt involved
15:21:55 <allenj12> o
15:22:00 <allenj12> maybe I do have them confused
15:22:08 <geekosaur> again, I think you want to distinguish currying and partial application
15:22:25 <geekosaur> :t curry
15:22:27 <lambdabot> ((a, b) -> c) -> a -> b -> c
15:22:44 <geekosaur> currying just flattens a tuple
15:23:00 <allenj12> o weird alright
15:23:02 <geekosaur> partial application is enabled by not having to root around inside tuples, but having them be flat instead
15:23:21 <geekosaur> likewise right association means we can always peel off and partially apply the first parameter
15:23:33 <geekosaur> (and then the second, and ...)
15:24:22 <allenj12> so is what I said true if I altered the terms, that this is enabled because of partial appliction and the fact its rightward associative
15:24:28 <geekosaur> yes
15:24:52 <allenj12> geekosaur: alright great. thanks for setting so much straight :D
15:25:33 <sschlesinger> hello
15:25:53 <geekosaur> it does take a while to get used to thinking this way --- but once you get the hang of it, quite a lot of Haskell suddenly makes a lot more sense
15:27:11 <allenj12> geekosaur: I wonder if there are any other ways to "convert" types like this that I would probably get wrong :P
15:27:12 <geekosaur> (not Haskell-the-language, but actual Haskell code)
15:28:23 <sschlesinger> hey needHelpHaskell, do you needHelp by any chance?
15:28:38 <allenj12> geekosaur: also I find it interesting that the resulting type is experssed in the way supplied and not the way defined.
15:28:54 * hackagebot ShellCheck 0.4.5 - Shell script analysis tool  https://hackage.haskell.org/package/ShellCheck-0.4.5 (vidarhol)
15:29:47 <geekosaur> it can go either direction
15:29:50 <allenj12> :t (y . x) => (Int -> Integer) -> Int -> Integer instead of (Int -> Integer) -> (Int -> Integer)
15:29:53 <lambdabot> error: parse error on input ‘=>’
15:30:41 <needHelpHaskell> yes sschlesinger i am indeed in need of help
15:30:44 <geekosaur> type inference works across an entire expression, and flows as needed. one side effect of this is that, unlike many other languages, you get return type polymorphism (this will become more significant when applied to typeclasses)
15:31:21 <allenj12> interesting
15:31:29 <geekosaur> it's like high school algebra
15:31:46 <grantwu> Is there any work on parallelizing GHC?
15:31:56 <sschlesinger> grand, how may I be of assistance?
15:32:05 <needHelpHaskell> http://pastebin.com/CseYyqZ7 in the bottom function
15:32:06 <sschlesinger> grantwu I think it already is to some extent
15:32:11 <needHelpHaskell> convert
15:32:27 <needHelpHaskell> i am getting errors while calling the script with hugs
15:33:08 <geekosaur> grantwu, there's been a fair amount of work, yes. ask in #ghc for details, but my understanding (which may well be incomplete or out of date) is that things are currently limited by interfaces (as in .hi files)
15:33:33 <needHelpHaskell> what im trying to do: the function takes a String as input and returns only the numbers inside said string, but without leading zeros
15:33:49 <sschlesinger> So what is convert meant to return? and what is extractDigits meant to return? The bug is in the branches of convert
15:33:55 <grantwu> geekosaur: hrm
15:33:57 <sschlesinger> and those are rhetorical questions
15:34:00 <geekosaur> needHelpHaskell, :: is not a typecast like in C
15:34:13 <needHelpHaskell> the function extractDigits already does something similar, but without the leading zeros thing
15:34:25 <needHelpHaskell> geekosaur: thats what i figured
15:34:34 <needHelpHaskell> but googling didnt get me far :/
15:34:37 <geekosaur> :t read
15:34:39 <lambdabot> Read a => String -> a
15:35:29 <geekosaur> the simplest answer, although not necessarily the best one (for one thing, it throws an exception if it can't parse the String into the expected result type)
15:35:51 <needHelpHaskell> lambdabot: where should i put that?
15:36:21 <needHelpHaskell> or geekosaur :-)
15:38:39 * geekosaur is looking at the code and being a bit confused... convert seems to have taken on part of extractDigits' duties, otherwise I'd make it part of extractDigits
15:38:45 <geekosaur> and change the type correspondingly
15:38:49 <sssilver> Tuplanolla ?
15:39:01 <needHelpHaskell> i cant change the types
15:39:12 <needHelpHaskell> those two functions must exist seperately
15:39:37 <needHelpHaskell> this is for an assignment and the functions will be called and tested
15:40:26 <monochrom> I think it is a good idea to point people to where to read the assignment itself.
15:40:30 <geekosaur> yes
15:40:35 <needHelpHaskell> its in german
15:40:41 <monochrom> Students always misinterpret teachers. This is normal.
15:41:06 <geekosaur> if you fully understood the teacher and the assignment, it could be argued that you don't need to be doing it
15:41:24 <needHelpHaskell> haha
15:41:25 <monochrom> People will worry about translation. You don't have to worry about it.
15:42:21 <geekosaur> (also I had my share of incomprehensible TAs back when I was in college)
15:42:33 <needHelpHaskell> ok ill find u the link
15:43:18 <monochrom> It is not just students. Professional programmers keep misinterpreting their own problems too, in the form of getting stuck in one approach and not considering any alternative.
15:43:33 <needHelpHaskell> http://www.complang.tuwien.ac.at/knoop/lehre/ws1617/fp185A03/fp_lu01_161017.pdf
15:43:42 <needHelpHaskell> its on page 3
15:43:44 <needHelpHaskell> on the bottom
15:43:46 <monochrom> Just lurk in any programming channel for a year to see a lot of XY problems.
15:45:06 <allenj12> haskell naming conventions? camelCase, keb-ab, snak_e?
15:45:21 <geekosaur> most people use camelCase, sadly
15:45:23 <johnw> camel is the most common, since that's what the standard library uses
15:45:38 <geekosaur> kebab doesn't work, although ' can be used inside identifiers
15:45:46 <geekosaur> but'who'wants'to'read'this?
15:46:06 <allenj12> geekosaur: thas sad, i really like kebab :(
15:46:11 <monochrom> I do. And Oleg does.
15:46:27 <allenj12> geekosaur: actually that looks pretty good to me
15:46:27 <monochrom> IDon'tWantToReadThis
15:46:38 <Tuplanolla> I want `ArgumentDo` just so I can comment code with `don't do ...`, geekosaur.
15:46:50 <geekosaur> @hackage acme-dont
15:46:51 <lambdabot> http://hackage.haskell.org/package/acme-dont
15:46:55 <geekosaur> :p
15:46:59 <monochrom> I want spatial separation between words, not edge detection based on letter height.
15:47:21 <geekosaur> as for kebab case, I'm always torn between the naturalness and the COBOL flashbacks >.>
15:47:26 <Tuplanolla> Yes, that one.
15:47:30 <sschlesinger> hey guys, I made this small library (https://github.com/SamuelSchlesinger/Gaia) which displays this technique of using equivalent representations in GHC in order to implement abstractions which require two different instances of the same class for one type. I used it for Ring and Lattice classes but I think the technique itself could possibly be of interest. I'm curious if there are examples of using this elsewhere cause I ha
15:49:20 <monochrom> needHelpHaskell: it is most natural for convert to just call extractDigits, then do the rest of going from "502" to 502.
15:49:37 <monochrom> If the prof allows you to use the "read" function, you're done.
15:49:42 <needHelpHaskell> oh yea
15:49:50 <needHelpHaskell> ill try that
15:49:58 <monochrom> If not, a little arithmetic and recursion will solve it.
15:50:12 <needHelpHaskell> is the read function available in hugs98?
15:50:19 <monochrom> yes, it's standard
15:50:28 <needHelpHaskell> okay then i guess it wont be a problem
15:50:57 <monochrom> "a little arithmetic" is actually a tall order for programmers and programming students
15:51:53 <monochrom> basically if they were better at math, they would be attracted to the more profitable engineering school already
15:52:11 <needHelpHaskell> monochrom: how would i use the read function
15:52:14 <needHelpHaskell> or
15:52:24 <needHelpHaskell> wait let me try myself first
15:52:37 <dolio> Mathematicians are well known to be bad at arithmetic.
15:52:53 <sschlesinger> math major here, quite bad at arithmetic
15:52:55 <monochrom> yeah but I'm talking about the "502"->502 kind
15:53:02 <geekosaur> note that, because it is polymorphic, you need to make sure you specify the type you want it at
15:53:25 <geekosaur> e.g. if you use it in ghci without saying what type, it will happily use unit as the type and confuse you
15:53:38 <monochrom> more precisely, I'm talking about "what procedure to do that" kind rather than "do that yourself" kind
15:54:01 <monochrom> I am talking about 50*10 + 2 is how to get 502
15:58:20 <needHelpHaskell> well this didnt work: convert m = read extractDigits m :: Integer   
15:58:33 <pikajude> :t read
15:58:35 <lambdabot> Read a => String -> a
15:58:50 <pikajude> whatever extractDigits is, i don't think you can apply read to it and get a function out
15:59:11 <monochrom> you need parentheses
15:59:11 <geekosaur> needHelpHaskell, `read extractDigits m` wants to pass two parameters to `read`
15:59:22 <monochrom> convert m = read (extractDigits m)
15:59:24 <needHelpHaskell> oh
15:59:32 <needHelpHaskell> ok i thought thats the way it worked in haskell 
15:59:34 <needHelpHaskell> let me try again
15:59:40 <pikajude> since " " is the function application operator :)
15:59:52 <monochrom> also in your case you don't have to worry about adding ":: Integer" because you already have it in your "convert :: String -> Integer"
16:00:19 <needHelpHaskell> wow shit worked
16:00:23 <needHelpHaskell> thanks guys 
16:00:24 <monochrom> space is not actually the function application operator. space is only one way to separate tokens.
16:00:30 <geekosaur> (there are times when that actually makes sense, but read is not one of them)
16:00:40 <monochrom> consider sin(0). no space, still function application.
16:01:24 <monochrom> the moral of the story is that it is token juxtaposition that becomes function application. (restrictions apply.)
16:01:25 <pikajude> good old #haskell 
16:12:14 --- mode: niven.freenode.net set +o ChanServ
16:13:50 <pikajude> :t Int
16:13:52 <lambdabot> error:
16:13:52 <lambdabot>     • Data constructor not in scope: Int
16:13:52 <lambdabot>     • Perhaps you meant one of these:
16:13:56 <pikajude> ok good lambdabot is back
16:18:37 * johnw wonders where bad lambdabot went
16:19:41 <geekosaur> still missing ~200 accounts...
16:28:20 <ongy> it was with me
16:43:57 * hackagebot median-stream 0.1.0.0 - Constant-time queries for the median of a stream of numeric  data.  https://hackage.haskell.org/package/median-stream-0.1.0.0 (jmc41493)
17:03:58 * hackagebot median-stream 0.2.0.0 - Constant-time queries for the median of a stream of numeric  data.  https://hackage.haskell.org/package/median-stream-0.2.0.0 (jmc41493)
17:49:10 <hellertime> I'm playing around for the first time with GHC cost center profiling, but my current profiling run puts most of the execution time in >>= … which isn't all that helpful
17:51:27 <c_wraith> hellertime: sure it is.  It tells you that you either have too much going on in (>>=), or it's getting called too often.
17:52:03 <c_wraith> hellertime: so, what type is it operating at?
17:52:11 <hellertime> its a ReaderT
17:52:27 <c_wraith> That isn't enough to determine how much work it's doing.
17:53:08 <c_wraith> What is the type that unifies with `m' in the type of (>>=)?
17:55:52 <hellertime> I'm not sure exactly. This is someone elses code I'm picking apart
17:56:39 <c_wraith> If it has 3 or more layers of transformers, it's likely the transformer overhead that's making (>>=) take so much of the profile
17:57:02 <hellertime> hmm ok
17:57:44 <hellertime> it looks to be a ReaderT of a ReaderT.. the profile is something like 
17:57:47 <hellertime> main.runA
17:57:51 <hellertime>     >>=
17:57:54 <hellertime>         …
17:57:59 <hellertime>     runB
17:58:11 <johnw> do you have -fprof-auto turned on for all your modules?
17:58:22 <hellertime> where there is a large call stack under the >>=
17:58:45 <hellertime> I built this with 'stack build —profile' and added -fprof-caf to the ghc-options
17:58:51 <johnw> ok
18:00:58 <hedu09> hello?
18:00:59 <hellertime> unraveling a nested transformer stack, this should be interesting… :)
18:03:05 <yulax> hedu09: idle a while, and ask questions...
18:03:12 <c_wraith> hello hedu09.  There's a few people around. :)
18:07:29 <EvanR> whats the best way to do a set of (a,b) where you can index a -> [b], b -> [a], delete by left or right, etc
18:09:17 <c_wraith> EvanR: That's a good question.  There's the two maps approach, but it's fragile and slow.
18:09:49 <c_wraith> EvanR: alternatively, you could think of that as a bipartite graph, and just go heavy-weight and throw something like fgl at it.
18:10:24 <EvanR> hmm
18:11:01 <c_wraith> though fgl isn't optimized for multiple node types
18:11:05 <EvanR> does it help to say a = b
18:11:16 <EvanR> which it will be for me
18:11:26 <c_wraith> then fgl becomes much easier to throw at it
18:11:47 <EvanR> is it very fast? 
18:12:06 <EvanR> or just very fast in comparison to other things at huge data sizes
18:12:17 <c_wraith> It's not great at huge data sizes.
18:12:24 <EvanR> oh
18:12:40 <c_wraith> Its fast representation is IntMap from node id to node data.
18:13:06 <EvanR> does it help to say a = b = Int ;)
18:13:17 <EvanR> in which case sounds like two IntMaps is the same thing as fgl
18:13:20 <c_wraith> Which is usually the faster alternative, but the whole library is designed to be elegant more than efficient.
18:13:28 <EvanR> ok
18:13:31 <c_wraith> No, fgl would be more indirect still
18:13:35 <shanemikel> some kind of order always helps, no?
18:14:46 <shanemikel> EvanR what is this concept of left/right end of a Set?
18:15:32 <EvanR> its an indexed set
18:15:34 <c_wraith> shanemikel: it probably helps to go back to the initial question, which is way easier to understand. :)
18:15:49 <EvanR> of pairs, of Ints
18:16:22 <EvanR> im thinking two IntMap IntSets
18:16:37 <EvanR> or HashMap Int IntSet
18:19:01 * hackagebot hw-prim 0.3.0.5 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.3.0.5 (haskellworks)
18:19:02 <EvanR> oh wow... thers two Data.HashMaps
18:19:11 <EvanR> unordered-containers and hashmap
18:19:16 <c_wraith> use the one from unordered-containers
18:19:22 <c_wraith> in basically all situations. :)
18:20:09 <c_wraith> The hashmap package even says it's deprecated and you should use unordered-containers instead
18:20:49 <EvanR> ah
18:22:17 <EvanR> to delete from this thing... you delete from left index, then for each thing in the deleted set, go delete the index from the right set
18:22:58 <c_wraith> yep
18:23:16 <EvanR> i wonder how SQL systems do it
18:23:33 <c_wraith> SQL uses multiple B+ Trees. :)
18:23:50 <c_wraith> well, database engines do.  usually.
18:24:26 <c_wraith> There's nothing really magical going on in databases, from a CS point of view.  They're just lots and lots of engineering and optimization.
18:25:22 <shanemikel> Don't tell the Orient people that...
18:25:34 <c_wraith> Well, in terms of data representation.  the ACID properties stuff is way more complex, in terms of CS theory needed.
18:26:30 <c_wraith> Two-phase locking?  Easy to understand, performance isn't great.  You want better perfomance?  Well then things get complicated.
18:27:28 <EvanR> well, i dont need all that, just wondering about the fastest way to keep this two way index updated
18:32:31 <EvanR> there might be another data structure which makes updates faster but lookups slower
18:32:32 <shanemikel> Sometimes I feel like persistency is a pain and I miss pointers
18:33:16 <EvanR> i distinctly remember not being able to keep all the insane pointer networks i came up with straight
18:34:11 <EvanR> even now i write C not using dynamic allocation even returning records normally instead of through a output pointer ;)
18:41:28 <acowley> Finding the right balance when writing C is a pretty interesting exercise in self-awareness
18:42:02 <johnw> you could delete a few words from that sentence without harm to the meaning
18:42:26 <acowley> Writing C is self-awareness
18:42:39 <johnw> :)
18:43:30 <acowley> That seems like an almost profound observation about the lack of a type checker. You're a good editor, johnw.
18:44:00 <acowley> You're not by any chance going to be at HacPhi, are you?
18:44:10 <johnw> sadly, no; that's now across the country from me
18:45:11 <acowley> Whereabouts are you? I'm not traveling much with the baby, but just in case I end up anywhere I like to know who to look up!
18:45:25 <johnw> I'm in Sacramento. I'd love to have you over!
18:45:39 <johnw> or see you at one of the many Haskell meetups in the Bay Area
18:46:29 <shanemikel> Are there many?  I'm in Berkeley
18:46:32 <acowley> Thanks! I've never been to Sacramento and would love to visit.
18:46:46 <johnw> shanemikel: east bay, south bay, SF
18:46:47 <shanemikel> Where do I look them up?
18:46:52 <johnw> meetup.com
18:47:04 <acowley> Berkeley is nice, you should host a meetup there!
18:47:51 <johnw> berkeley is hosting one nov 3, I believe
18:48:26 <shanemikel> Oh, cool
18:48:33 <shanemikel> that's great, thanks
18:48:47 <acowley> I really wish I could somehow commute to California without the misery of air travel
18:51:28 <shanemikel> use a persistent structure, you can be in two places at once
18:53:03 <shanemikel> that sounded funnier in my head
18:53:23 <acowley> :P
18:53:38 <EvanR> acowley: i learned to appreciate air travel after taking the train from chicago to SF
18:54:04 <acowley> That's a long way. Philly to Boston by train is really nice, though it sucks up most of a day.
18:54:05 <EvanR> i.e. i didnt know what misery was
18:57:40 <nathanjackson> hello
18:59:29 <shanemikel> I just had a cool idea.. what if there was a sort of data structure that preserved thunks, so you could use mutation in a pure way, and old references would be replaced by the old thunks..
19:00:23 <EvanR> not sure how mutation works into that, but cloneThunk would be nice in order to "undo" computation to save space
19:02:17 <shanemikel> mutation in the same sense as in other languages, where it's unnecessary to rebuild the leading path
19:02:34 <EvanR> how would that be pure?
19:02:53 <EvanR> unless you somehow ensured theres no other references to the mutable object
19:03:25 <shanemikel> by replacing them with their original thunks.. so If they do get used, they would be recomputed
19:04:09 <EvanR> ... so you can only mutate it by writing the same value back ;)
19:04:16 <shanemikel> Sure, it's half baked... obviously it's a complicated thing in reality
19:05:28 * ski thought shanemikel meant replacing the stuff that referenced the object-to-be-mutated by their original thunks
19:05:52 <shanemikel> that's right
19:06:41 <EvanR> ah
19:14:58 <shanemikel> or some kind of a patch system
19:18:01 <shanemikel> No, I suppose that would have more overhead than copying
19:20:32 <EvanR> copying is awesome... thats pretty much all the computer does!
19:23:28 <shanemikel> I suppose you're right.  I was just thinking it might be a way to avoid tricks like "tying the knot" that usually don't even work
19:28:05 <shanemikel> The only way I can think of doing it is assuming the thing could have been mutated whenever it is given as a function argument... Hmm, is that what Rust does?
19:40:13 <laudiacay> hey guys! i have a midterm coming up, and my knowledge is a bit lacking about functors, some syntactic sugar, and data/newtype/type stuff. i have some good resources that i'm reading, but i think some more practice problems might help? what i've done so far of H99 didn't feel as targeted as i wanted. suggestions?
19:40:52 <sahadev> hello all
19:40:59 <laudiacay> like if there was a practice supplement for learn you a haskell that would be AMAZING
19:41:12 <sahadev> is this the right place to ask stack/build questions?
19:42:11 <sm> sahadev: maybe.. there's also #haskell-stack
19:42:56 <sahadev> since you said maybe, I will try anyway :)
19:43:19 <shanemikel> laudiacay, do you have any specific questions?
19:44:05 <laudiacay> shanemikel: not really, just wondering if anyone has recommendations on problem sets. im a super hands on learner and feel like that would be the best way to solidify my knowledge
19:44:30 <sm> https://wiki.haskell.org/Learning_Haskell must have some things
19:44:39 <sahadev> i have an old laptop (running Linux Mint). whenever I try "stack buuld <package>" it would start building the dependencies, I see all four cores busy and then suddenly my laptop powers itself off.
19:45:09 <sm> sahadev: ouch :) getting too hot ?
19:45:16 <sahadev> is there an option that I can use to tell stack to slow it down and not create multiple processes?
19:45:31 <sahadev> sm: it does feel a little hot. but not much.
19:45:52 <sahadev> i see there is a ghc option -j
19:45:52 <sm> stack -j1 build ... I think
19:46:02 <sahadev> ah. ok.
19:46:02 <MarcelineVQ> laudiacay: nicta is hands-on as heck, I'm not sure if it's quite what you're asking for though https://github.com/NICTA/course
19:46:13 <laudiacay> MarcelineVQ: thanks :)
19:46:34 <sahadev> can it be specified in a config file, so it is automatically used?
19:46:57 <sahadev> i looked in the stack docs, but i couldn't find any specific config option.
19:47:03 <sm> ghc-options: I think
19:47:16 <sahadev> ok. i will try that.
19:48:42 <exio4> sahadev: if your laptop overheats or has hardware issues, then avoiding that with -j1 isn't going to be the solution 
19:48:47 <sm> maybe worth opening up that machine and checking for dust
19:49:01 <exio4> sahadev: (cleaning it, changing thermal paste, etc.. would be better options)
19:50:54 <shanemikel> just curious, where are you taking a course that uses haskell?
19:50:59 <sahadev> started again with -j1. if i suddenly disappear, you all know why :)
19:51:32 <sahadev> yeah, i gotta open it up and clean it.
19:57:09 <ski> @where Typeclassopedia
19:57:09 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
19:57:17 <ski> laudiacay ^ ?
19:57:47 <laudiacay> whoaaa whats this? ski 
19:57:56 <laudiacay> looks insteresting, but tl;dr
19:58:09 <ski> did you already see
19:58:14 <ski> @wher CIS194
19:58:15 <lambdabot> Maybe you meant: where where+
19:58:18 <ski> @where CIS194
19:58:18 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
19:58:19 <ski> ?
19:58:27 <laudiacay> no i didnt
19:58:36 <laudiacay> omg this is going to be great
19:58:49 <laudiacay> so much stuff to do tonight
20:00:32 <shanemikel> oh, laudiacay that Typeclassopedia is *essential*.  I totally forgot about that.
20:01:02 <shanemikel> It'd be a good idea to peruse that before you do anything else.
20:01:21 <laudiacay> shanemikel: it looks like a lot, would you mind summarizing what exactly it is?
20:02:32 <shanemikel> It basically describes all the important algebras in Haskell.  Just take a look at the TOC
20:03:21 <shanemikel> It's nice because it's concise and all in one place
20:03:42 <laudiacay> shanemikel: omg sounds great
20:03:45 <shanemikel> Though it is a bit devoid of cartoon drawings
20:03:51 <laudiacay> yeah ADTs i dont think i get 100%
20:04:10 <laudiacay> so this should be great
20:05:51 <shanemikel> The only way to really define something like Functor is to give its interface (typeclass), and the supplementary laws.  That's what makes it abstract, and that's why I referred to it as an algebra
20:08:23 <laudiacay> shanemikel: thanks :DDDD
20:09:00 <sahadev> "stack -j1 build" seems to help.
20:10:10 <sahadev> but, adding "ghc-options: -j1" to ~/.stack/global-project/stack.yaml didn't make a difference
20:10:48 <shanemikel> Of course, writing implementations will help you remember the interface and laws
20:11:02 <krokodil> Suppose I have a record like { size:Int, data:a, data2:b }. I can sort of represent it as a type `SomeRecord a` and make it an instance of Functor
20:11:17 <krokodil> So fmap : (a -> b) -> SomeRecord a -> SomeRecord b
20:11:33 <krokodil> And there are 2 ways for me to do it, for `data` and for `data2`
20:11:33 <EvanR> yep
20:11:49 <EvanR> 3rd way, do both, Bifunctor
20:12:01 <krokodil> Yeah, but what I'm looking for is a generalization
20:12:13 <glguy> krokodil: one you pick the type parameters there won't be two ways
20:12:14 <EvanR> well theres Trifunctor
20:12:25 <krokodil> Python has `with`, which is basically getting "inside" a context, doing stuff, "exiting" the context
20:12:43 <EvanR> you might be looking for lenses
20:12:58 <krokodil> EvanR: well that was anti-climactic
20:14:00 <glguy> krokodil: in your example you seem to have left out the b parameter
20:14:11 <krokodil> it's just I currently have to do lots of packing/unpacking in my code, and I remember using with statements heavily in Python, and Emacs Lisp has lots of context-changing functions like `save-excursion` or `with-current-buffer`
20:14:23 <glguy> one you add it to the type then your Functor instance will be fixed
20:14:53 <krokodil> glguy: you're right, maybe I'm wrong, I'm just trying to grab the vague intuition I just ahd
20:14:54 <EvanR> onData1 :: (A -> A) -> SomeRecord -> SomeRecord
20:14:59 <EvanR> onData2 :: (B -> B) -> SomeRecord -> SomeRecord
20:15:31 <EvanR> which compose nicely
20:15:33 <krokodil> and suddenly I realized that my intuitions around functors and monads being "contexts" are kind of similar to "with" statements
20:15:51 <EvanR> im not sure thats appropriate for either class
20:16:35 <krokodil> So I just wanna know if my intuition is justified and what is the connection between functors and Python's with statements, and how does all of that generalize
20:17:10 <glguy> with in Python appears to be something else related to object lifetimes
20:20:04 <shanemikel> laudiacay, if you're doing Monad, this illustration of the laws in do-notation can really help you see how they relate to procedures http://dev.stephendiehl.com/hask/#monads
20:21:14 <shanemikel> sorry, this is closer http://dev.stephendiehl.com/hask/#do-notation
20:21:33 <EvanR> the intuition for Functor is "generalized map". unwrapping and rewrapping happens in so many other situations, and may not be happening for all functor instances, so i dont think its a good general picture for that
20:22:17 <shirt> how can i check on an executable which version of GHC it was compiled with?
20:22:41 <krokodil> EvanR: do you mean that because of Functor laws, fmap is kind of a "subclass" of unpacking/packing?
20:22:44 <shanemikel> I thought it was a flauta
20:22:56 <EvanR> no, im saying its unrelated
20:23:14 <shanemikel> or taquito
20:25:19 <krokodil> EvanR: I'm talking wishy-washy now, but if I somehow generalize unwrapping/wrapping, what do I get? Can I get some typeclass with nice mathematical features?
20:25:29 <krokodil> Is there any systematic way of unwrapping/wrapping?
20:25:33 <shanemikel> lenses
20:25:51 <krokodil> lenses :)
20:26:05 <thoughtpolice> shirt: ./name.exe +RTS --info
20:26:33 <EvanR> krokodil: yeah, lenses
20:26:56 <shirt> thoughtpolice: thank you!!
20:27:06 <glguy> shirt : yourProgram +RTS --info
20:27:09 <glguy> perhaps
20:27:21 <shanemikel> functor isn't that far from that idea.. when I read `f a` the first thing that comes to mind is some data with an `a` in it.. but you see the analogy breaks down when you consider higher kinded types, or functions
20:27:38 <shanemikel> err... not higher kinds
20:27:41 <EvanR> it breaks down for a lot of possible instances
20:27:50 <shirt> glguy: thanks it works :)
20:29:45 <EvanR> theres a tendency for people learning haskell to select a concrete example of a pattern, and then explain the pattern as that
20:30:43 <EvanR> which would be like showing the type (Char, Bool), and saying pairs are like 1 char and 1 bool together, in that order
20:33:53 <shanemikel> Idk, I really sympathize with that because I do it all the time (not with tuples :b).  but it's good to consciously remind yourself that there is really only two constraints to a Functor, whatever the laws + type checker allows
20:47:37 <lpaste> bollu pasted “template-hask-[d|...|]-confusion” at http://lpaste.net/290505
20:47:46 <bollu> ^
20:48:03 <bollu> template haskell questiona about the exact semantics of [d|…|]
20:48:17 <bollu> in the scope, some expression t :: Type does not work, but $(return t) does
20:48:24 <bollu> what's the semantic difference between the two?
20:48:50 <bollu> so, like, in the example, why am I able to use tnewtype in a raw way, while I'm not allowed to do the same for telem? http://lpaste.net/290505
20:49:43 <bollu> MarcelineVQ: many thanks for the example code :)
20:50:42 <MarcelineVQ> ah good you saw it, was fun to work through
20:51:06 <bollu> :) yes, I got it to work differently (well, same approach, but I pattern-matched)
20:51:24 <bollu> I didn't know about the [p|..|] and [e|…|] quasi quoters
20:51:59 <bollu> here is my version: https://github.com/bollu/cellularAutomata/blob/master/src/DeriveMonoComonadTH.hs#L59
20:52:04 <bollu> I'm cleaning it up right now
20:52:18 <bollu> and I don't understand why the $(…) is needed in some cases but can be omitted in others
20:52:22 <bollu> TH is weird :P
20:52:30 <bollu> more like, I don't understand it
20:53:04 <ski> bollu : i think there's no CSP in TH
20:53:18 <bollu> ski: CSP being?
20:53:19 <ski> Cross-Stage Persistence
20:53:27 <newhoggy> Does anyone know how to get "cabal test" to print teach test as it runs it?
20:53:32 <bollu> ski: um, I don't know what that means. Can you please elaborate?
20:53:56 <ski> iow, `telem' isn't in scope in the "late" declaration `type instance Element (tnewtype) = telem'
20:54:05 <ski> it's only in scope "early" (compile-time)
20:54:28 <bollu> how do I know at what stage what happens? and how does the $(..) help it? does the Q monad "thread" stuff into the future stages or something?
20:54:35 <bollu> does Q*
20:54:43 <ski> hm, oh right, there's also a(nother) typing problem
20:55:10 <jchia_> I'm trying to figure out how Control.Monad.State.Strict imports Data.Foldable.sequence_. I don't see in the source code any mention of Foldable. Could someone help me understand? http://lpaste.net/290506
20:55:23 <ski> even if `telem' were in scope, it would be a value of type `Type', rather than a type (presumably of kind `*')
20:56:13 <ski> otoh, that wouldn't explain why you don't have to do `[d| type instance Element $(return tnewtype) = $(return telem) |]', i suppose
20:56:20 <bollu> wait, so how does tnewtype
20:56:20 <bollu>  work?
20:56:21 <bollu> yea
20:56:24 <bollu> exactly
20:56:30 <laudiacay> hey im a little confused about the type of getLine? if i go "name <- getline", does the "<-" unbox the string out of the IO type thing and assign it to name, so name has the type string?
20:56:30 <bollu> yeah*
20:56:45 <bollu> laudiacay: do you understand how >>= works?
20:56:52 <laudiacay> bollu: nor entirely lol
20:56:53 <ski> perhaps they allow it as a shortcut in that context (type pattern/parameter), but not in a type expression context
20:56:58 <bollu> x <- f is sugar for f >>= \x -> …
20:57:05 <laudiacay> what is >>==
20:57:08 <thoughtpolice> jchia_: Control.Monad.State.Strict re-exports Control.Monad, which re-exports sequence_, which is just a re-export of Data.Foldable.sequence_
20:57:09 <laudiacay> or >>=
20:57:09 <bollu> ski: uh, that's a little strange right?
20:57:22 <bollu> ski: is there someone who works with TH on a regular basis on the channel right now?
20:57:23 <thoughtpolice> jchia_: See the last few lines of the export list, here http://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-State-Strict.html
20:57:38 <bollu> :t (>>=)
20:57:40 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:57:40 <ski> bollu : `$(...)' and `[blah| ... |]' changes stage between run-time and TH-expand-time
20:57:54 <bollu> ski: which one is run-time and which one is TH-expand-time?
20:58:09 <ski> both, but in opposite directions
20:58:13 <bollu> ski: I thought the quasi-quotes was syntactic sugar to make it easier to build the AST?
20:58:28 <ski> yes ?
20:58:38 <bollu> ski: so how can it do it in both directions?
20:59:05 <ski> if `...' is at TH-expand-time, then `$(...)' is at run-time
20:59:06 <bollu> laudiacay: your intuition works in the IO case, but it's good to know what the general principle is. Do you know that list is a monad?
20:59:13 <laudiacay> bollu: oh, crud, i don't understand what monads are yet
20:59:19 <bollu> ski: and in the case of the quasi-quotes?
20:59:20 <laudiacay> that's not been covered yet in my class.
20:59:22 <bollu> laudiacay: ah
20:59:27 <geekosaur> ...but the run time here is compile time, just a different point of compile time
20:59:29 <ski> of `...' is at run-time, then `[blah| ... |]' is at TH-expand-time
20:59:33 <geekosaur> ah, staging
20:59:42 <laudiacay> i'd prefer not to confuse myself until i get functors and types all the way
20:59:48 <bollu> geekosaur: did you see the lpaste?
20:59:55 <laudiacay> is there a way i can understand it without monads and such?
20:59:58 <jchia_> thoughtpolice: got it. what's a simple way to import Control.Monad.State.Strict minus the Control.Monad?
21:00:00 <geekosaur> I did, yes. I don't know TH well enough to know what's going on
21:00:01 <bollu> laudiacay: yes, well, till then, x <- getLine is pretty close to "pull stuff out of IO"
21:00:03 <EvanR> laudiacay: String is not being unboxed from the IO type, this is not a good characterization.
21:00:14 <ski> laudiacay : there is no assignment
21:00:24 <laudiacay> ski: what do you mean no assignment?
21:00:32 <ski> `<-' is not assignment
21:00:38 <ski> (it's "monadic bind")
21:00:43 <bollu> laudiacay: it's more like, IO String is an expression waiting to be "run" in some sense. <- is "run the operation and get the string" if I'm not too far off.
21:00:48 <bollu> geekosaur: I see
21:00:55 <laudiacay> ski: but it is some kind of binding for as far as i need to get it now
21:00:58 <geekosaur> laudiacay, I tend to think of (>>=) as attaching a callback to an IO action. you don't control when the IO action is actually executed, but you can attach a callbacl that will do something when it is
21:01:03 <laudiacay> bollu: ohhh that makes a lot of sense
21:01:08 <ski> laudiacay : yes
21:01:19 <thoughtpolice> jchia_: You have to use either A) qualified imports to import Control.Moand.State.Strict qualified, B) import it, only importing exactly the things you want, or C) import Control.Monad.State.Strict, but hide the definitions you don't want
21:01:24 <geekosaur> so, when execution time comes, *then* your callback has the String
21:01:30 <ski> laudiacay : assignment implies mutability
21:01:34 <geekosaur> (note that evaluation time is not execution time)
21:01:51 <thoughtpolice> jchia_: e.g. "import Control.Monad.Strict.State (State, StateT, runStateT,)" etc etc. Or you can do "import Control.Monad.State.Strict hiding (sequence_, ...)" etc
21:02:09 <thoughtpolice> Those examples correspond to choices B and C, respectively.
21:02:18 <monochrom> yes, I prefer the callback story too. http://www.vex.net/~trebla/haskell/IO.xhtml
21:02:20 <laudiacay> geekosaur: so "when the io action happens, name will become the a coming from the IO a bit
21:02:22 <ski> bollu : `$(...)' is unquote corresponding to the quasi-quote
21:02:29 <jchia_> thoughtpolice: does c) mean hiding each of the items that Control.Monad has, like sequence_?
21:02:43 <ski> monochrom : it's a matter of which stage you're focusing on :)
21:02:43 <jchia_> c) is a lot of stuff to hide
21:02:59 <thoughtpolice> jchia_: No, you can't "hide" the re-export of an entire module I'm afraid.
21:03:18 <geekosaur> so, in some sense a Haskell program produces a value of type IO a, which is a chain of actions for the runtime to perform. you use >>= to attach a new action to the end of the chain
21:03:24 <bollu> ski: hm
21:03:26 <laudiacay> alright i think i am starting to get at least how it is used if not the deeper whatever
21:03:33 <thoughtpolice> jchia_: So you're probably better off with B. You can also do a combination of A and B as well.
21:03:34 <bollu> ski: so it evals the thing inside $?
21:03:42 <bollu> ski: so $(..) takes values to types?
21:03:49 <ski> bollu : and splices the (monadic) result in-place, yes
21:03:50 <monochrom> http://queue.acm.org/detail.cfm?id=3001119 tells a similar callback story about Twitter's Future type in Scala. Note that flatMap is >>=
21:03:52 <jchia_> Is it possible to make a module that reexports Control.Monad.State.Strict hiding Control.Monad (not the things in Control.Monad individually)?
21:04:00 <thoughtpolice> jchia_: e.g. doing "import Control.Monad.State.Strict (State, StateT)" followed by "import qualified Control.Monad.State.Strict"
21:04:02 <geekosaur> this is the trick by which we allow impure actions in a pure programming language: the IO actions themselves are commands to the runtime and are pure/unchanging
21:04:11 <bollu> ski: would looking at Q's implementation be enlightening?
21:04:16 <thoughtpolice> jchia_: Everything explicitly mentioned in the first line can be referred to unqualified. Anything else has to be qualified
21:04:17 <bollu> ski: I want to understand the stages now, I think
21:04:22 <geekosaur> and we attach callback actions to do things
21:04:23 <ski> bollu : i suspect not (i haven't looked at it)
21:04:31 <bollu> ski: yeah
21:04:52 <ski> bollu : knowing a bit about quasiquotation (and possibly macros) in Lisps (or MetaML/MetaOCaml) would probably help
21:05:07 <thoughtpolice> jchia_: This is often the way I do it in these cases -- mention the most common cases with an explicit import list -- such as the types -- so you can refer to them unqualified, and mention everything else using a qualified import.
21:05:09 <geekosaur> if you have worked with CUDA, you're actually doing something similar but the IO action is sent to the GPU instead of the language runtime.
21:05:30 <ski> bollu : i think oleg talks some about CSP .. but i'm not sure how accessible it'd be to newbies
21:05:30 <bollu> ski: I know "of" them
21:05:37 <bollu> ski: lemme check it out
21:06:02 <geekosaur> ...or likewise when writing client-side javascript, you send IO actions to the web server
21:06:09 <bollu> ski: newbies to haskell or newbies to GHC or..?
21:06:32 <thoughtpolice> jchia_: e.g. if I had "import Control.Monad.State.Strict (State); import qualified Control.Monad.Strict.State as S", then I could have a type like "f :: State Int ()" -- but to run it, I would have to say "S.runState" instead of just "runState"
21:06:35 <ski> bollu : newbies to staged programming
21:06:43 <ski> (aka meta-programming)
21:06:48 <bollu> ski: ah
21:06:50 <laudiacay> oh my goodness this <- thing is great. keeping the input away from your pure functions is just so nice
21:06:57 <bollu> lachenmayer: :)
21:07:01 <bollu> laudiacay: welcome to the dark side
21:07:07 * ski smiles at laudiacay
21:07:44 <bollu> oh, I used to do this retarded thing where I used to send IO values everywhere because I didn't know fmap/liftAn and family existed. 
21:07:50 <jchia_> thoughtpolice: OK. I'm having this and similar problems with classy-prelude and thinking of the best way to approach them. classy-prelude, particularly mono-traversible defines some common things in a way that causes ambiguity with other libraries
21:08:08 <bollu> so, well, use the liftAn and stuff
21:08:10 <laudiacay> bollu: shit i didn't realize how much i loved functional programming. i used mathematica which was pretty functional before, but it handled outside input really grossly
21:08:11 <EvanR> <- being visually different from = really helps understanding imperative code, i think
21:08:15 <laudiacay> this is so pretty
21:08:32 <EvanR> better than mathematica, because we have types !
21:08:41 <thoughtpolice> jchia_: Yeah, something like this, or putting all this behind a helper module that you import elsewhere, is probably the way to go.
21:08:51 <geekosaur> (in fact Haskell and Haskell-derived languages such as Elm are increasingly used for client-side web scripting because the Haskell model with IO actions is easier to work with than constantly wrapping things in function(){} to make callbacks)
21:08:53 <bollu> EvanR: math has types too! :P
21:08:57 <ski> (you don't need (static) types, to handle input/output monadically ..)
21:08:57 <laudiacay> EvanR: i dunno if i can commit to better than mathematica but prettier sure :D
21:09:02 <EvanR> it should but often doesnt
21:10:04 <bollu> ski: this is a good plae to start? https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/meta-haskell.pdf
21:10:11 <bollu> place*
21:10:15 <ski> i suppose so (haven't read it)
21:10:20 <thoughtpolice> jchia_: And to answer your other question, yes you could define your own module, MySpecialExports.hs, that did all of this qualified import dance properly and re-exported exactly the things you want. But only using the same basic techniques I mentioned; like I said, you can't do "import Foo hiding (module Bar)" or anything
21:10:44 * ski should get into TH at some point ..
21:10:49 <bollu> ski: cool, will do
21:10:53 <jchia_> thoughtpolice: OK, thanks
21:13:02 <thoughtpolice> bollu: That paper is really only an introduction to Template Haskell itself, in its original form. It doesn't cover more modern things like Typed Template Haskell, and doesn't really address any kind of staging, AFAIK.
21:13:17 <bollu> thoughtpolice: do you have any references for me to follow up on, then?
21:13:19 <thoughtpolice> Geoff has a more recent paper somewhere.
21:13:28 <bollu> thoughtpolice: references on TH are.. scarce 
21:14:47 <thoughtpolice> https://www.cs.drexel.edu/~mainland/projects/metahaskell/ is the more recent work and lead into Typed Template Haskell, IIRC.
21:15:19 <bollu> thoughtpolice: ty
21:15:35 <thoughtpolice> bollu: The typed version is conceptually pretty easy to explain, though. Basically, if you have something like [| not $x |], that might have a type like 'Q Exp -> Q Exp'
21:15:56 <thoughtpolice> But that doesn't actually tell you anything meaningful. I could apply that function to "hello world", a String, and it wouldn't make sense -- it would fail to compile.
21:15:57 <bollu> thoughtpolice: okay, go on
21:16:13 <bollu> thoughtpolice: yes
21:16:19 <thoughtpolice> Typed Template Haskell lets you give '[| not $x |]' the type 'TExp Bool -> TExp Bool'
21:16:44 <bollu> thoughtpolice: one sec: do you have a PDF of the thing? I'm not at uni right now so I don't have ACM access. The PDF link is currenty dead
21:16:47 <bollu> thoughtpolice: I see
21:16:48 <thoughtpolice> That's basically it, in a nutshell.
21:16:52 <bollu> thoughtpolice: it's not part of GHC right now?
21:16:59 <thoughtpolice> The quotations now witness the types of the things they accept, and what they return.
21:17:06 <thoughtpolice> It's been in GHC for a few years now.
21:17:21 <thoughtpolice> https://www.cs.drexel.edu/~mainland/publications/mainland12metahaskell.pdf
21:17:21 <bollu> thoughtpolice: how come the Haskell Wiki doesn't talk about it?
21:17:32 <bollu> all of my types are Q [Dec] and stuff
21:17:33 <thoughtpolice> Because you haven't updated it, yet!
21:17:39 <EvanR> the wiki is kind of deteriorating
21:17:40 <bollu> thoughtpolice: :)
21:17:46 <bollu> thoughtpolice: okay, where do I learn about this?
21:17:54 <bollu> thoughtpolice: are there like, references?
21:18:03 <thoughtpolice> More realistically: it's probably seen very little use. It does allow you to do some fancy things, though. You can use it along with the GHC API to do certain kinds of staging, at least.
21:18:18 <bollu> the list of papers keep increasing >_>
21:18:41 <bollu> it feels so bad for that folder to keep accumulating. My rate of reading is so much slower than my rate of collecting
21:18:44 <bollu> I see
21:18:45 <thoughtpolice> Because like, let's say you had the power function, so it's "TExp Int -> TExp Int -> TExp Int" or whatever. So you could just apply that to one int. That would give you a function of type TExp Int -> TExp Int, with the argument specialized. Then you can pretty print that as Haskell code
21:18:56 <bollu> wait, what?
21:18:58 <thoughtpolice> And just load it back into your executable at runtime with the GHC API. Boom. Staging.
21:19:03 <bollu> oh right, the Q monad has a pretty printer
21:19:10 <bollu> thoughtpolice: okay, what exactly does "staging" mean?
21:19:46 <JuanDaugherty> ready to go
21:20:02 <JuanDaugherty> done enough
21:20:34 <JuanDaugherty> run it up the flagpole and see does anybody salute
21:21:00 * ski assumes thoughtpolice meant `\x -> ...'
21:21:32 <bollu> ski, thoughtpolice: what is the exact definition of "staging"?
21:21:36 <thoughtpolice> bollu: Honestly, it seems like an overloaded term. The best way I can explain it: staging is the ability to utilize the concept of runtime program generation, and execution, in a manner to speed up your programs. For typed languages, we obviously want "typed" staging, so that we can generate programs at runtime that don't go wrong, and that we can use
21:21:37 <thoughtpolice> reliably.
21:21:52 <bollu> I see
21:21:54 <thoughtpolice> Well, not just speeding them up. That's just a popular application.
21:21:59 <bollu> thoughtpolice: have you seen urbit?
21:22:06 <bollu> it has this thing called as "jets"
21:22:06 <ski> bollu : it means keep track of different "stages" "at the same time". roughly "compile-time" (macro-expand-time, or if you will TH-expand-time) vs. "run-time"
21:22:07 <bollu> reminds me of it
21:22:16 <bollu> I see
21:22:22 <bollu> ski: run time as in execution time?
21:22:27 <bollu> ski: as in, ./app time?
21:22:27 <ski> yes
21:22:35 <bollu> hm
21:22:48 <bollu> ski: so in some sense, Haskell does have run-time reflection ish abilities?
21:22:49 <thoughtpolice> Yes, but in a staged language, at the time you run ./app, you may generate and compile and load code further!
21:22:56 <bollu> ah
21:22:57 <bollu> I see
21:23:06 <ski> bollu : with `[| not $(...) |]' the subexpression `...' will evaluate at TH-expand-time, while the application of `not' will happen at run-time
21:23:10 <bollu> doesn't that require the need for GHC or something on the machine you're running the app?
21:23:18 <thoughtpolice> To be fair, you can basically do a shitty version of dynamic loading in every language. But languages that support the notion of staging generally support specializing, generating and running programs as a "first class" feature.
21:23:30 * ski assumes thoughtpolice meant `Int -> TExp Int -> TExp Int'
21:23:32 <thoughtpolice> In MetaOCaml, staging is exposed by just a few simple forms to the programmer.
21:23:34 <bollu> ski: no, that's because the entire AST is grafted and compiled at compile time right?
21:23:40 <bollu> ski: that's not legit "runtime"
21:23:45 <thoughtpolice> ski: Yeah, hand waving a bunch.
21:24:09 <thoughtpolice> Here's the actual example I'm thinking of, with working code:
21:24:10 <thoughtpolice> http://gmainland.blogspot.com/2013/05/type-safe-runtime-code-generation-with.html
21:24:12 <bollu> thoughtpolice: so, okay. Imagination time
21:24:29 <ski> bollu : as thoughtpolice said, there can be multiple stages. "TH-expand-time" and "run-time" are relative terms
21:24:31 <bollu> thoughtpolice: let's say I define a really stupid language with only 0 and increment and equality comparison
21:24:40 <bollu> so subtraction is O(n)
21:24:46 <bollu> can I use template hasell to make this O(1)?
21:24:57 <bollu> that is, check where the subtraction code is, and replace it with "legit" subtraction code?
21:25:04 <bollu> don't change semantics, but change codegen?
21:25:12 <thoughtpolice> Also yes, ski makes an important point that there are multiple stages. For example, your ./app could at runtime generate a program and run it, which generates another program and runs it, which generates another...
21:25:47 <thoughtpolice> This is part of what I meant by "first class" -- there is no limit to the number of stages you can have. And you can "stage" (or generate, then run) any kind of value.
21:25:57 <bollu> I see
21:26:07 <bollu> and haskell supports this?
21:26:21 <bollu> where are the docs for this? GHC at least must have a reference right? can you link me to that?
21:26:26 <bollu> I mean, *something* other than just a paper?
21:26:53 <thoughtpolice> It's two independent features in this case. Hot loading comes from GHC itself. The notion of 'staging' comes from Template Haskell. The overall thing is a combination fo the two.
21:27:00 <thoughtpolice> The example in Geoff's blog is a good place to start.
21:27:10 <thoughtpolice> And the manual does go into the specifics of the Typed Template Haskell forms
21:27:18 <ski> staged power is the classical example
21:27:29 <thoughtpolice> (For Typed template haskell, you use $$ and [|| ||] instead of $ and [| |], so it has slightly different syntax)
21:27:37 <bollu> I see
21:27:39 <ski> a `printf' that analyzes the format at expand-time is another
21:27:49 <thoughtpolice> bollu: But look at Geoff's example and try to understand it -- at the end of the day, you could absolutely keep generating more and more programs at various stages, etc.
21:28:03 <bollu> thoughtpolice: I see. I'll check this out
21:28:09 <thoughtpolice> It's just that systems like MetaOCaml support this very transparently. You could make this easier by just wrapping some of this crap into a library, honestly.
21:28:13 <bollu> thoughtpolice: so the O(n) subtraction thing that I asked about would work?
21:28:20 <thoughtpolice> I'm not sure how much of a library you'd need other than the basics of some code loading, honestly.
21:28:29 <ski> bollu : it might be worth it to look up papers on MetaML and MetaOCaml, if you want a broader view
21:28:42 <bollu> ski: I barely know OCaml, and I don't know ML. Plan on learning it
21:28:59 <bollu> oh, is there anyone who works at Jane Street here on IRC?
21:29:01 <thoughtpolice> Yes, MetaOcaml and MetaML are definitely the "premier" implementations. You probably don't need to know much OCaml to get a feel for it, honestly.
21:29:10 * ski isn't sure to which degree TH quasiquotations have hygien (by default, at least), though
21:29:42 <ski> and as i mentioned, the lisps are prior work
21:29:49 <thoughtpolice> bollu: RE O(n) to O(1) -- maybe you can, I don't know! I might not fully understand the question or even how staging might approach that problem. I'm not an expert at staged programming.
21:29:54 <bollu> I see
21:30:24 <bollu> so, $(Value) -> Type
21:30:34 <bollu> [| …|] is to build AST
21:30:45 <bollu> [|| ||] and $$ $$ let you do first-class staging
21:30:51 <bollu> right?
21:31:10 <thoughtpolice> $$ gives you typed TH quotations. It doesn't implement the code loading part
21:31:33 <bollu> GHC does?
21:31:48 <parsnip> is there any way to keep pandoc from exporting all the `<div>` tags? it makes a messy org-mode output. 
21:31:49 <thoughtpolice> Yes, the GHC API can be used for the dynamic loading part.
21:31:57 <EvanR> "i have this really stupid language with 0, increment, equality, and staged metaprogramming support" ;)
21:31:59 <thoughtpolice> https://github.com/mainland/th-new/blob/master/Language/Haskell/TH/Compile.hs
21:32:12 <thoughtpolice> That's roughly all you need from GHC to support the code loading.
21:32:54 <bollu> EvanR: heh, it'd be cool :3
21:33:15 <bollu> EvanR: have you heard of Nock? Urbit? it's like this minimal language they define, on top of which they have optimisations called Jets
21:33:24 <bollu> EvanR: I was wondering what it would be like to encode it in TH
21:33:35 <EvanR> interesting
21:34:38 <bollu> EvanR: it's crazy, the project.https://github.com/urbit/urbit. Link to nock: https://urbit.org/docs/nock/definition/
21:34:55 <ski> bollu : "Quasiquotation in Lisp" by Alan Bawden in 1999(?) at <http://repository.readscheme.org/ftp/papers/pepm99/bawden.pdf> is a short classic paper on quasiquotation (in the context of Lisp)
21:35:17 * ski smiles at EvanR
21:35:39 <bollu> ski: ? :)
21:36:04 <ski> just adding another paper to your to-read pile :)
21:36:16 <bollu> yeah xD
21:36:35 <bollu> ski, thoughtpolice: thanks a ton! I'll get started on reading this
21:36:36 <bollu> I <3 haskell
21:39:56 <bollu> " My implementation strategy is the same as his: print a Template Haskell expression to a file and compile and load the file" this is hacky, no?
21:41:44 <jchia_> I'm trying to use NonEmpty. A lot of standard functions such as replicateM, deal with regular [a]. Is the standard approach just to use nonEmpty to convert from [a] to NonEmpty a? Should I be concerned about performance and look for other ways, e.g. a replicateM specialized for NonEmpty, if it exists?
21:42:28 <jchia_> I'm calling replicateM with a constant Int, so I know at compile-time that the resulting list is non-empty
21:42:36 <glguy> replicateM *can* return an empty list for Int arguments less than 1, so it's appropriate for it to return a list and not a NonEmpty
21:43:12 <Cale> Well, given that you know which constant you're using
21:43:19 <ski> > replicateM 0 Nothing
21:43:23 <lambdabot>  Just []
21:43:41 <jle`> i'd write a replicateM for NonEmpty
21:43:45 <Cale> You could write something like  liftM2 (:|) x (replicateM (n-1) x)
21:43:46 <jle`> it's not that tricky
21:43:59 <Cale> Or yeah
21:44:01 <jle`> it'd be called replicateMPlusOne, though
21:44:03 <jle`> heh
21:44:08 * hackagebot autom 0.1.0.1 - Generates and displays patterns from next nearest neighbors cellular automata  https://hackage.haskell.org/package/autom-0.1.0.1 (infrared)
21:44:25 <Cale> heh
21:44:26 <jle`> the resulting list has a length one longer than the input
21:44:29 <Cale> It's Traversable even
21:44:39 <Cale> So if you write a replicate
21:44:43 <Cale> you can just sequence
21:45:03 <jle`> replicateMPlusOne n x = (:|) <$> x <*> replicateM n x
21:45:19 <jchia_> jle`: I think it's very troublesome to do this for every function I encounter with the same problem.
21:45:55 <jle`> my philosophy is to isolate the unsafe parts to a module you can verify
21:46:03 <Cale> jchia: Well, that's the price you pay...
21:46:03 <jle`> and then you can work fine with safe functions
21:46:21 <jle`> i wouldn't use nonEmpty directly, i'd rwap it up in safe interface
21:46:23 <Cale> It's basically the price of showing the compiler you really know that the list is nonempty
21:46:39 <jle`> i'd wrap any use of nonEmpty and isolate it into a few certain functions i can verify if i have to
21:46:48 <jle`> and then use those safely
21:47:01 <jle`> there's pretty much no point to using NonEmpty at all if otherwise
21:47:05 <Cale> No need to wrap uses of nonEmpty
21:47:07 <Cale> it's safe
21:47:18 <Cale> It's fromList that's not so safe
21:47:22 <jle`> ah, i meant fromList
21:47:31 <jchia_> is there a hackage library addressing this issue and make it simple to use NonEmpty if you know the size at compile-time?
21:48:21 <Cale> jchia: Apart from what NonEmpty is already doing, I'm not sure what that would mean
21:48:40 <Cale> You mean have the compiler try to prove to itself that the lists aren't empty?
21:48:49 <jchia_> Cale: jle suggested some approach that i was asking whether is available in a library
21:49:00 <Cale> There's stuff like LiquidHaskell -- it's of limited practicality...
21:49:08 <jchia_> writing this myself is a lot of code and a lot of work
21:49:37 <bollu> Cale: I was using liquid haskell once, and I had to prove to it that what I was (!) indexing from a list was valid
21:49:41 <bollu> Cale: I should go back to it sometime...
21:50:45 <Cale> Usually I just don't worry about it a *whole* lot. This kind of property (at least, once it gets to the point of reasoning that lists have at least n elements) just isn't the sort of thing that Haskell's type system is especially good at.
21:51:03 <Cale> If you just need one level of nonemptiness or something, it's really not so bad, if a little clunky
21:51:17 <Cale> Maybe the clunkiness is worthwhile if you're really worried.
21:51:22 <jle`> jchia_: if you know at compile-time then you can use fromList etc., but just know that you're basically telling the compiler to trust you and giving up its help
21:51:26 <Cale> But maybe you're not worried enough.
21:51:27 <jchia_> Cale: What is the benefit of showing the compiler that i really know that the list is non-empty?  Is it reasonable to do NonEmpty.fromList <$> replicateM 5 foo?
21:51:42 <Cale> jchia: I think it's totally reasonable
21:51:51 <jle`> it's reasonable, if you look at every situation where you do it
21:51:53 <Cale> As long as nobody changes that 5 to a 0, you're fine.
21:52:01 <jle`> but that's a good way to write fragile code
21:52:14 <Cale> I mean, you have to decide for yourself how fragile it is.
21:52:20 <jle`> if you do it very often, then that's a lot of lose ends
21:52:24 <ski> > evalCont $ (100 +) <$> callCC (\k -> do (k,n) <- (replicateCC 3 <=< replicateCC 2) (k,1); k (10 + n))
21:52:27 <lambdabot>  161
21:52:30 <Cale> I think something like *that* just isn't fragile enough to really get worried about.
21:52:49 <jchia_> jle: i think the fromList being less than 20 characters away from 5 is rather hard to miss
21:52:50 <Cale> If the 5 was instead, the result of some complicated calculation which I'd have to prove gives a positive result...
21:52:57 <Cale> Then I might worry more.
21:52:58 <jle`> i think it's not a bad thing in isolation, but if you do it a lot and it happens all over your code base, then it starts to get complicated
21:53:08 <jle`> jchia_: that's easy to say
21:53:14 <jle`> right now
21:53:19 <jle`> when you have one instance, and you're coding with a clear head
21:53:23 <ski> @type replicateCC1
21:53:25 <lambdabot> (MonadCont m, Integral i) => i -> (a -> m o, a) -> m (a -> m o, a)
21:53:26 <jle`> and you are a one-person team
21:53:34 <Cale> jchia: I basically agree with you there.
21:53:50 <jle`> it's just one extra thing to keep track of.  it might not be a big deal on its own, but it adds up over time
21:54:29 <Cale> Haskell isn't designed to be total. Totality is good, but to really do totality well, you need at least dependent types, and even then, it's possible to be in a frustrating situation where you'd rather leave details out of the types sometimes.
21:54:36 <jle`> i know that scattering little "trust me here's" throughout a large codebase has bitten me in the past
21:54:44 <jle`> on their own, individually, they are easy to indivudally verify
21:55:01 <Cale> There's a spectrum of this stuff, and some is worse than others
21:55:06 <jchia_> jle: on the other hand, the replicateMPlusOne has the problem of people forgetting about the N+1-ness and committing an off-by-one error
21:55:13 <Cale> btw, if you're ever thinking of using something like head
21:55:16 <jle`> but when you have a lot of them here and there throughout a multiple codebases, and if you are collaborating with people, and if you ever code late at night or in a state where you're not 100%, then that's when things start to slip
21:55:16 <ski> (higher-order) run-time contracts might be nice
21:55:19 <bollu> Cale: why do you need depdendant types for totality?
21:55:21 <Cale> Use (\(x:xs) -> x) instead
21:55:35 <jle`> jchia_: that's also true :o
21:55:50 <Cale> bollu: Because you end up needing to be able to talk about the properties of values at the type level.
21:56:11 <Cale> bollu: and that means you need to be able to parameterise types (acting as predicates) on values
21:56:18 <bollu> Cale: hm, I see
21:56:21 <ski> (in the general case)
21:57:02 <Cale> Yeah, if you take this stuff really seriously... I think perhaps Charity was a total language which wasn't dependently typed...
21:57:09 * ski nods
21:57:29 <Cale> But also it's not like anyone ever used Charity for a serious piece of software.
21:57:33 <bollu> Cale: which is a decent total language to play around with?
21:57:57 <Cale> Coq and Agda, and Idris has an optional totality checker.
21:58:25 <ski> Epigram ?
21:58:28 <bollu> Cale: Coq is a theorem prover, agda is a dependantly typed language
21:58:36 <bollu> Cale: oh, but totality ~= to these?
21:58:53 <Cale> bollu: Coq is also a dependently typed programming language
21:58:53 <kadoban> bollu: I've been having a good time going through http://www.cis.upenn.edu/~bcpierce/sf/current/toc.html (Software Foundations, which uses coq)
21:59:10 <Cale> bollu: and Agda is also a theorem prover (proof assistant?)
21:59:16 <bollu> kadoban: I'm at chapter 4!
21:59:18 <bollu> kadoban: of SF
21:59:22 <bollu> Cale: I see
21:59:28 <kadoban> Nice, I'm about the same place.
21:59:36 <Cale> SF teaches it in a kind of weird order as I recall
21:59:40 <ski> proof assistant, rather, i think (as is Coq)
21:59:49 <Cale> It doesn't show you how to write terms
21:59:49 <bollu> kadoban: I don't really have time right now though for it. I plan on blasting through it over winter break
21:59:53 <Cale> Until fairly late
22:00:03 <ski> (though i suppose tactics in Coq makes it more like theorem provers ?)
22:00:14 <kadoban> Yeah, I went on vacation and lost my place, probably going to have to back up a bit to get going again.
22:00:26 <Cale> Instead, you construct all your proofs using tactics, which construct the programs which are your proofs for you
22:00:45 <Cale> But you *can* just write the programs directly, and they can compute stuff.
22:01:13 <bollu> I see
22:01:14 <kadoban> Cale: Out of curiosity, would you not recommend SF then, or?
22:01:14 <bollu> I didn't know that
22:01:16 <Cale> and if you doubt that serious software can be written in it... well, with enough heroism you can end up with something like CompCert
22:01:43 <Cale> kadoban: I still would recommend it, I just think it's a bit weird.
22:02:00 <Cale> kadoban: I guess you have to choose some order in which to teach things...
22:02:27 <Cale> I'm just a little surprised it hides what's really going on for so long
22:02:40 <kadoban> Heh, yeah. I'll make a note of your text and see what I think when I get to the end, if I make it.
22:03:16 <Cale> I didn't really learn Coq in any usual way
22:03:27 <bollu> Cale: how'd you learn it?
22:03:31 <Cale> I just woke up one day and realised that I already knew how to write Coq
22:03:36 <bollu> Cale: oh yeah, I was wondering how to enable set theory in Coq?
22:03:38 <monochrom> haha
22:03:38 <bollu> -_^
22:03:50 <Cale> after like a decade-plus of functional programming
22:04:22 <bollu> Cale: I wanted to quickly prove a couple of number theory things in Coq for fun. So I was wondering how to enable, well, arithmetic. Or at least set theory
22:04:31 <bollu> I wouldn't mind encoding arithmetic myself :P
22:04:55 <Cale> There's a bunch of stuff in the standard library
22:04:58 <Cale> It's a bit of a mess...
22:05:04 <tam1138> hi there.  i'm trying to create a "newtype Size = Size Integer" so i can declare Size an instance of Monoid and then set mappend = (+), but then I need to also declare Size an instance of Integral, which spirals out of control in also needing Real and Enum.  is there any easy way to say "just extract the Integer and use that for all numeric operations" ?  that is, why can't I just define toIntegral and 
22:05:10 <tam1138> be done?
22:05:11 <Cale> https://coq.inria.fr/library/
22:05:26 <bollu> Cale: hm, I see
22:05:29 <bollu> Cale: have you used LEAN?
22:05:37 <bollu> Cale: they have HoTT apparently. So I want to use it
22:05:58 <kadoban> tam1138: Do you know about GeneralizedNewtypeDeriving?
22:06:26 <Cale> I haven't yet... I looked at it a bit
22:06:44 <tam1138> kadoban: i do not.  is that what i want here?
22:07:40 <kadoban> tam1138: In short it's a language extension, once you turn it on you can just "derive" any typeclass for your newtype that the wrapped type is an instance of. So, like "deriving (Num, Integral, Enum)", etc.
22:08:11 <tam1138> kadoban: i'm reading the docs for it now, it looks like exactly what i want.  thank you!
22:08:18 <kadoban> So you still have to list them all, but you don't actually have to write implementations, which is nice. Sure, 'welcome!
22:09:38 <tam1138> oh yes, that's perfect, thank you again
22:14:09 * hackagebot autom 0.1.0.2 - Generates and displays patterns from next nearest neighbors cellular automata  https://hackage.haskell.org/package/autom-0.1.0.2 (infrared)
22:22:47 <moet> any love for nix here?
22:23:39 <geekosaur> depending on who's around, it ranges between love and terror >.>
22:25:27 <moet> lol.. i'm leaning toward terror.. i haven't been able to build anything in two weeks (since switching to nixos)
22:25:35 <moet> i didn't look before leaping ><
22:26:13 <Cale> geekosaur: I basically have both those emotions the entire time I'm using it
22:26:43 <bollu> Cale: do you use nix?
22:27:08 <Cale> I use nix for all work-related projects
22:27:36 <Cale> as well as anything I use reflex-platform for
22:27:59 <moet> Cale: do you have a little time to help me out with cabal2nix?
22:29:35 <bollu> Cale: you dualboot?
22:29:54 <Cale> No, I just use the package manager
22:30:02 <Cale> You don't need to use nixos to use nix
22:30:32 <Cale> moet: I can't promise you I'll be helpful, but ask away
22:31:11 <moet> i've gotten as far as `cabal2nix . > default.nix` after thinking i had to do this manually..
22:31:17 <Cale> The part of my brain capable of comprehending programming languages without type signatures present has atrophied to the point that I find editing nix expressions to be an infuriating and confusing process.
22:31:18 <bollu> oh, that's interesting
22:31:24 <bollu> Cale: where do I do this?
22:31:49 <bollu> "brew install nix" works?
22:31:53 <moet> and ocharles has a post where he jumps from an expression like what `cabal2nix .` outputs to something slightly different .... https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html
22:31:57 <Cale> bollu: something like that
22:31:59 <moet> but i don't really follow what he's doing...
22:32:41 <Cale> bollu: For a good example, https://github.com/reflex-frp/reflex-platform has a try-reflex script which will install nix for you and use it to get ghcjs and reflex and all the dependencies you'll need to build reflex-dom projects.
22:33:06 <bollu> Cale: oh, so I already have nix? cool :D
22:33:15 <Cale> bollu: yeah
22:33:33 <bollu> Cale: what's the execuatble called?
22:34:43 <Cale> There are a decent series of articles starting here: http://lethalman.blogspot.com/2014/07/nix-pill-1-why-you-should-give-it-try.html
22:34:58 <Cale> which help explain about what nix is, and the expression language and stuff
22:37:33 <Cale> bollu: go into your try-reflex shell, type "nix" and press tab a couple times
22:37:46 <bollu> ah, ty
22:38:06 <Cale> you'll also have cabal2nix
22:38:15 <Cale> and maybe a bunch of other stuff I don't know about
22:38:20 <Cale> heh
22:39:09 <Cale> For the most part, I let Ryan and Ali take care of nix things, but I did learn enough of the syntax of the language to kinda sorta fix things up.
22:39:50 <moet> i have trouble reading the language, mainly because i don't know what all the keywords and builtins do (or are called)
22:40:09 <moet> but `nix-repl` has a `:t` command which helps somewhat for finding out what things are
22:41:45 <moet> Cale: you work at obsidian?
22:41:55 <Cale> yeah
22:43:03 <Cale> Nix is a really good experience when you have someone else take care of configuring stuff for you, because it's very good at replicating environments.
22:45:33 <Cale> (or if you only have to make sufficiently small tweaks to things)
22:48:07 <moet> yes, i've discovered it's pretty reliable.. because when something runs without an error-retcode, it usually does what i wanted
22:48:29 <moet> but getting to that point requires a lot of guessing.. :/
22:48:38 <Cale> bollu: Oh, and btw, if you want to add nix-repl to your try-reflex environment, you can open up default.nix, and scroll down to where you'll see something like "generalDevTools = haskellPackages:" and then a little later, there's a list of packages with stuff like nixpkgs.nodejs etc, you can add nixpkgs.nix-repl to that list.
22:48:56 <Cale> (might be useful if you're reading the pills)
22:48:58 <bollu> Cale: doing it now
22:49:25 <bollu> "pills"?
22:49:57 <Cale> oh, that series of articles I linked
22:49:58 <moet> the link he posted above
22:50:19 <bollu> why does it look like haskell? the config language?
22:50:26 <bollu> is it typed?
22:50:32 <Cale> Nope
22:50:41 <Cale> Well, it's dynamically typed :P
22:50:49 <bollu> xD
22:50:50 <bollu> sad
22:50:58 <Cale> It *is* pure though
22:51:19 <Cale> and has lambdas
22:51:33 <Cale> (which don't look like Haskell lambdas)
22:52:16 <Cale> In fact, that's the main thing which kills me about it -- if it were statically typed, it would be so much easier to learn what the heck was going on
22:52:38 <moet> { argument, set, with, these, keys}: <some expression>
22:54:01 <Cale> Yeah, the named parameters everywhere thing is kind of interesting though
22:54:10 * hackagebot autom 0.1.0.3 - Generates and displays patterns from next nearest neighbors cellular automata  https://hackage.haskell.org/package/autom-0.1.0.3 (infrared)
22:58:30 <moet> i feel like the version of the manual i have with `$ nixos-help` is a cut-down version of what's online.. it's confusing
23:06:47 <grantwu> http://codereview.stackexchange.com/questions/144929/haskell-code-to-verify-credit-number Is the final answer here actually good Haskell style
23:07:27 <grantwu> At the very least it needs more comments
23:08:30 <saurabhnanda> any other solutions to http://stackoverflow.com/questions/40171037/apply-a-function-to-all-fields-in-a-record-at-the-type-level/40171268 ?
23:09:10 <bollu> Cale: ping, I have a yoneda question
23:09:19 <bollu> I understand how Hom(X, -) is a functor from C -> Set
23:09:38 <bollu> now, how do I construct the natural transformation from g :: C-> Set to Hom(X, -)
23:09:54 <bollu> I don't get how to define a component eta_c :: g(c) -> Hom(X, c)
23:10:07 <bollu> anyone?
23:10:17 <laudiacay> i forgot who recommended me the typeclassopedia but wohever you are you are perfect
23:10:27 <laudiacay> this is just what i needed to review for my midterm!
23:10:38 <moet> grantwu: you might turn the nested parens into a . . . $
23:10:40 <saurabhnanda> bollu: do you need a real-life problem to solve with types?
23:10:49 <bollu> saurabhnanda: right now? sure
23:11:22 <saurabhnanda> there: http://stackoverflow.com/questions/40171037/apply-a-function-to-all-fields-in-a-record-at-the-type-level/40171268 :)
23:11:39 <bollu> hahaha, ure
23:11:41 <bollu> sure*
23:11:50 <bollu> um, also, anybody with some help with Yoneda?
23:12:35 <hololeap> i just observed something confusing regarding "unit" as i understand it is called. how do i use the haskell interpreter on this channel? 
23:13:24 <hololeap> > odd 1
23:13:26 <lambdabot>  True
23:13:37 <kadoban> :t True
23:13:39 <lambdabot> Bool
23:13:43 <hololeap> cool
23:13:45 <kadoban> Those two are the usual ^
23:13:54 <hololeap> > mempty (pure "Derp" :: IO String)
23:13:56 <lambdabot>  ()
23:14:03 <hololeap> :t mempty (pure "Derp" :: IO String)
23:14:05 <lambdabot> Monoid t => t
23:14:09 <hololeap> :t ()
23:14:10 <lambdabot> ()
23:14:17 <hololeap> what is going on here?
23:14:36 <kadoban> () is a type as well as a value of that type
23:14:45 <kadoban> (the only value of that type)
23:14:49 <jchia_> I'm trying to use Text instead of String, showb/showt from TextShow instead of show. How efficient is TextShow? For example, how does (showt:: Int -> Text) work? Does it convert Int to String then String to Text? I don't see a TextShow instance for Int, only an instance for Show a, and as I understand, the only way Show a can help is by providing the conversion to String. 
23:15:00 <hololeap> but why would the expression that returns () be polymorphic?
23:15:11 <hololeap> what about () is ambiguous?
23:15:41 <glguy> hololeap: You’re using this: instance Monoid b => Monoid (a -> b) -- Defined in ‘GHC.Base’
23:16:12 <laudiacay> im not sure i totally understand how to implement functor for functions?
23:16:37 <EvanR> laudiacay: this would be a good exercise in following the type signatures
23:17:03 <EvanR> once you do that, its kind of impossible to mess up the implementation
23:17:08 <hololeap> glguy: where did you find that?
23:17:34 <laudiacay> EvanR: it's (a->b) -> (c->a) -> (c->b) right?
23:17:38 <hololeap> wait i found it
23:17:41 <glguy> hololeap: Using the :i command in GHCi
23:17:43 <EvanR> yes
23:17:51 <EvanR> er no
23:18:01 <EvanR> the result type is wrong
23:18:14 <hololeap> glguy: but where am i using that?
23:18:22 <EvanR> actually its right, the ordering of letters confused me
23:18:31 <glguy> 23:13 hololeap        : :t mempty (pure "Derp" :: IO String) 
23:18:37 <EvanR> (b -> c) -> (a -> b) -> (a -> c)
23:18:47 <laudiacay> yeah that kinda makes sense
23:18:58 <EvanR> sure does! ; )
23:18:58 <hololeap> IO "Derp" is (a -> b) ? 
23:19:13 <pavonia> :t mempty
23:19:15 <lambdabot> Monoid a => a
23:19:32 <laudiacay> so like.... fmap f g x = g $ f x?
23:19:51 <EvanR> whats x
23:19:51 <laudiacay> ohwait no
23:20:04 <laudiacay> fmap f g x = f $ g x
23:20:05 <moet> hololeap: you're passing an argument to mempty
23:20:11 <EvanR> right
23:20:18 <hololeap> right, but my question is regarding mempty on an IO String returning something that shows () but is something ambiguous
23:20:19 <laudiacay> x is of type a i think
23:20:26 <EvanR> @pl h f g x = f $ g x
23:20:27 <lambdabot> h = (.)
23:20:36 <laudiacay> g goes from a to b, and f goes from b to c
23:20:49 <EvanR> you got it
23:20:53 <hololeap> it's just confusing is all...
23:21:07 <laudiacay> EvanR: coolio
23:21:15 <hololeap> because i thought that () was a very specific thing in the language. like a singleton of sorts.
23:21:17 <pavonia> hololeap: () comes from type defaulting. You didn't specify a result type, so it defaults to ()
23:21:20 <EvanR> applying one function after the other
23:21:31 <EvanR> youll learn to be like "no! ill compose instead"
23:21:41 <moet> pavonia: sorry, what?
23:21:48 <laudiacay> also EvanR... instance functor (Either e) where
23:22:05 <laudiacay> fmap f (Left a) = Left a and fmap f (Right a) = Right $ f a
23:22:07 <EvanR> f $ g x ===> f . g
23:22:10 <hololeap> pavonia: ok, that definitely explains a lot
23:22:16 <pavonia> moet: Not?
23:22:20 <laudiacay> it typechecks but oh boy do i not know how to test this
23:22:41 <EvanR> how to test it? try fmap (+1) (Right 9)
23:22:57 <EvanR> how to test it? try fmap (+1) (Left "bogus")
23:23:11 <saurabhnanda> any TH gurus who can give an alternative answer to http://stackoverflow.com/questions/40171037/apply-a-function-to-all-fields-in-a-record-at-the-type-level/40171268
23:23:59 <hololeap> glguy: but i am still confused as to where the expression `mempty (pure "Derp" :: IO String)` uses `Monoid b => Monoid (a -> b)`
23:24:38 <glguy> mempty :: Monoid a => a, you picked a to be (IO String -> b)
23:25:28 <kadoban> hololeap: As to your direct question, why lambdabot gives you a result of () when the type is polymorphic like that, that's defaulting rules.
23:25:32 <moet> hololeap: mempty is polymorphic.. when you give it an argument, haskell searches for a satisfactory instance of Monoid (one which takes an argument)0
23:25:45 <moet> kadoban: could you explain about defaulting rules?
23:25:48 <kadoban> I don't think that defaulting rule exists in GHC, like when you compile a file. I'm not sure if it exists in ghci
23:26:25 <EvanR> exists for me in ghci
23:26:45 <hololeap> glguy: but, that's what confuses me, how is (pure "abcd" :: IO String) of type (IO String -> b)? that's a function, right? i don't see how that expression would return a function
23:26:55 <glguy> hololeap: It's not
23:27:04 <glguy> *mempty* has a function type in your expression
23:27:25 <moet> `a b` -- in this expression, a is a function
23:27:29 <kadoban> moet gave a good start. Essentially when you have an expression and there's no context that requires it to be a certain type, it has to pick one. The way it picks is by essentially looking in a list of hard-coded defaulting rules. You can modify them if you like, though honestly I'm not sure how, I've never done it.
23:27:37 <moet> `mempty blah` -- in this expression, mempty is a fnction
23:28:06 <hololeap> but since its in parentheses it should return the result of pure on the argument "abcd" with the given type of IO String...
23:28:18 <hololeap> :t pure
23:28:20 <lambdabot> Applicative f => a -> f a
23:28:26 <glguy> hololeap: the pure is irrelevant
23:28:34 <moet> :t mempty 3
23:28:36 <lambdabot> Monoid t => t
23:28:38 <hololeap> so in those parentheses it should just be an (IO String)
23:28:41 <moet> bleh
23:28:44 <glguy> when you applied mempty to an argument, you used it as a function
23:29:19 <hololeap> mempty *is* a function, but i applied it to IO String, not (a -> b)... this is the part that is confusing me
23:29:19 <moet> can you do iinstance searching in ghci (or in the irc bot?)
23:29:25 <EvanR> somehow i dont think you meant to apply mempty as a function to something
23:29:44 <EvanR> mempty is usually thought of as a non-function value
23:30:07 <hololeap> ok... i was just diving into the language with :t and :i and trying to figure out what functions do :)
23:30:07 <cocreature> if you apply it as a function it’s just "const mempty"
23:30:13 <moet> hololeap: you applied a thing to mempty, meaning mempty :: a -> b (because it's polymorphic, and such an instance exists)
23:30:18 <glguy> hololeap: No, mempty is not necessarily a function
23:30:30 <glguy> You just happen to have used it as one in that case
23:30:39 <glguy> > mempty :: Maybe Int
23:30:42 <lambdabot>  error:
23:30:42 <lambdabot>      • No instance for (Monoid Int) arising from a use of ‘mempty’
23:30:42 <lambdabot>      • In the expression: mempty :: Maybe Int
23:30:48 <EvanR> > mempty <> [1,2,3]
23:30:52 <lambdabot>  [1,2,3]
23:31:15 <glguy> > mempty :: [Int]
23:31:15 <kadoban> mempty is very rarely a function honestly, that instance of Monoid would be far from the first one that comes to mind.
23:31:15 <lambdabot>  []
23:31:15 <moet> :t mempty -- it's polymorphic, and there is an instance for (a -> b) or somesuch
23:31:15 <lambdabot> Monoid a => a
23:32:02 <cocreature> there is an instance for Monoid b => a -> b
23:32:18 <hololeap> glguy: how is mempty used other than a function?
23:32:18 <EvanR> thats a very handy one
23:32:29 <glguy> hololeap: See the example above
23:32:35 <moet> honestly, it would be way easier to answer this question if there was a nice ghci command like :instance which would print out the instance used for a typeclass binding
23:32:57 <glguy> moet: I think this is a more fundamental misunderstanding than just looking at a particular instance
23:33:08 <moet> > mempty :: [Int]
23:33:10 <lambdabot>  []
23:33:15 <moet> mempty :: Striing
23:33:18 <moet> mempty :: String
23:33:22 <moet> > mempty :: String
23:33:24 <lambdabot>  ""
23:33:25 <ab9rf> mempty is a value
23:33:28 <moet> it gives you empty things
23:33:45 <ab9rf> it's not a function (except when you ask it for an "empty function", then you get a value that is a function)
23:33:50 <moet> coupled with `mappend`, it lets you build up collections of things.
23:33:52 <ab9rf> it's a polymorphic value
23:34:01 <moet> > mempty :: Sum Int
23:34:04 <lambdabot>  Sum {getSum = 0}
23:34:07 <hololeap> does this correspond to a downward arrow from the functor to the normal object?
23:34:22 <bollu> it's nice to think of such things sometimes (for me) as () -> a
23:34:25 <hololeap> like F a to a
23:34:25 <bollu> since a ~= () -> a
23:34:31 <glguy> hololeap: No, probably not
23:34:37 <moet> > mempty `mappend` 4 `mappend` 3 :: Sum Int
23:34:40 <lambdabot>  Sum {getSum = 7}
23:34:45 <moet> > mempty `mappend` 4 `mappend` 3 :: Product Int
23:34:47 <lambdabot>  Product {getProduct = 12}
23:34:56 <EvanR> mempty is a pretty terrible way to build up collections of things ;)
23:35:00 <ab9rf> bollu: that's not really harmful, especially since in a pure enviroment a "niladic function" always returns the same thing
23:35:01 <moet> hololeap: it's an identity
23:35:03 <kadoban> hololeap: Are you familiar with monoids in general, the math concept?
23:35:07 <hololeap> you're right... i can see how that wouldn't be true...
23:35:08 <bollu> ab9rf: yeah
23:35:14 <bollu> ab9rf: and sometimes it's cleaner
23:35:23 <moet> EvanR: that was one example; then i gave another- sums and products of numbers (not collections..)
23:35:26 <moet> >>
23:35:32 <hololeap> kadoban: as far as i understand a monoid is a set and a binary operator that takes two a's and returns an a
23:35:40 <EvanR> mempty still wont help there
23:35:43 <moet> :t mempty
23:35:46 <lambdabot> Monoid a => a
23:35:46 <moet> :t mappend
23:35:48 <lambdabot> Monoid a => a -> a -> a
23:36:05 <cocreature> mempty is mostly useful as a basecase in recursion
23:36:17 <hololeap> so i could see how they would chain together
23:36:35 <hololeap> oh, and it has to satisfy three laws, right? just like the monad?
23:36:48 <kadoban> hololeap: A monoid is an associative binary operator together with an identity element. mempty is the identity element (though if that explanation doesn't help, I wouldn't blame you)
23:37:07 <bollu> what's a quick proof of yoneda
23:37:07 <hololeap> kadoban: no that makes sense
23:37:12 <bollu> or a long proof of yoneda
23:37:30 <cocreature> hololeap: well the laws are quite different from monad, but yes there are 3 laws (if you exclude the one for mconcat)
23:37:53 <cocreature> associativity of mappend and that mempty is the left and right identity of mappend
23:37:55 <hololeap> i thought they both had associativity as a law
23:38:07 <ab9rf> so the identity for (a->b) is a function that is, what, bottom for all values in a?
23:38:10 <EvanR> which is funny because to get a monad, you add monoid laws to a functor
23:38:36 <cocreature> well yeah you can view monads as monoids but in practise I don’t think that intuition is very helpful
23:39:05 <EvanR> hehe
23:39:07 <hololeap> i'm honestly trying to use haskell to learn category theory, so i'm trying to understand all the "why's" of the language
23:39:20 <ab9rf> heh
23:39:35 <glguy> ab9rf: no, not bottoms
23:39:36 <moet> hololeap: there be warts that way.. 
23:39:46 <kadoban> From what little I know of CT, I can't imagine that's going to be easy.
23:40:02 <hololeap> yeah, i get a lot of flak for wanting to do that, but honestly it's been working pretty well so far. i learn a lot just with an interpreter and it's an amazing language tbh :)
23:40:32 <cocreature> it’s easier to first learn category theory concepts on their own and then try to get an intuition for them by seeing how they work in haskell
23:40:44 <cocreature> well at least that was easier for me
23:41:21 <hololeap> cocreature: what has been helping me a lot has been thinking about lists, since i know them very intuitively from ruby, and they are apparently monads
23:41:41 <hololeap> in ruby they are a little different because anything can go inside of them
23:41:51 <moet> Cale: do you understand what the parenthetized part of this expression does? `let inherit (haskellPackages) cabal text mtl transformers;`
23:42:30 <cocreature> hololeap: the danger of looking at a specific instance of a concept is that the intuition acquired by doing so doesn’t necessarily carry over to other instances
23:42:57 <moet> ^ this, for the list monad, so hard.
23:43:20 <hololeap> cocreature: but programming is different, since you can apply it to so many concrete concepts. it's really the only thing i have to go off of as far as intuitively understanding logic and abstraction.
23:43:22 <EvanR> list monad is really useful and not that complicated
23:43:26 <cocreature> looking at instances is important and very helpful, just try to look at different instances
23:43:36 <EvanR> but theres no way to extend that example to other monads
23:43:54 <EvanR> except maybe Maybe
23:44:00 <EvanR> which is a list of at most 1
23:44:15 <hololeap> EvanR: i also built the Maybe monad from scratch, just thinking about how it would work. by comparing this and lists, i am starting to understand the pattern behind them
23:44:30 <EvanR> still that doesnt really explain general monads
23:44:47 <moet> EvanR: exactly
23:44:57 <hololeap> but when i learn about general monads, i will have some context already. it will make it much easier
23:45:18 <hololeap> i'm using haskell as a tool, not a teacher :)
23:45:37 <EvanR> yeah you need a tacklebox of examples to ground yourself, but also to provide counterexamples in case you come up with something bogus
23:45:39 <cocreature> hololeap: not necessarily. it can be very hard to get rid of assumptions that you have formed about a certain concept
23:46:17 <hololeap> whatever. i will know how well it worked in the end...
23:46:22 <ab9rf> i still have no real idea what a monad is
23:46:38 <Cale> moet: I think it refers to a set of packages to choose from (as you might have guessed looking at it)
23:46:42 <Mibaz> It's just a monoid in the category of endofunctors. What's the problem?
23:46:47 <Mibaz> ;)
23:47:04 <hololeap> endofunctors being the mapping of a category back onto itself
23:47:06 <moet> Cale: yeah, the inherit keyword takes from the surrounding scope, and adds names to the current scope..
23:47:09 <ab9rf> Mibaz: that i did know, unfortuantely, i don't know what a monoid is and only vaguely understand the concepts of category or enderfunctors
23:47:13 <ab9rf> er, endofunctors :)
23:47:27 <kadoban> I'm a bit fuzzy on what a Monad is, unless I'm allowed to think of it as just something that has (>>=), return, and some pretty natural laws. And I can use quite a few instances well.
23:47:28 <moet> Cale: but the parenthesized thing is confusing.. i guess it dips into that scope for the names?
23:47:35 <Cale> moet: right, and that seems to dig into a particular set, yeah
23:48:00 <moet> Cale: ok.. rubber ducking ty
23:48:01 <geekosaur> kadoban, that *is* what a Monad is
23:48:06 <Mibaz> ab9rf: Nor do I. I can, however, rattle off that good old line at will.
23:48:16 <ab9rf> i'm slowly grasping the relationships between the various concepts in haskell, bt i have no conceptual mapping from them to the broader mathematical concepts
23:48:25 <EvanR> Mibaz: that lines is terrible
23:48:28 <EvanR> line*
23:48:57 <kadoban> geekosaur: Then I guess I'm good to go :)
23:49:24 <ab9rf> so mostly what i've done is erected a firewall between haskell and math, to try to keep what i think i know from haskell from making me think i understand a damn thing about category theory
23:49:31 <bollu> Cale: I'm trying to constuct a natural transformation between Hom(X, -) and g :: C -> Set
23:49:41 <bollu> do you know the explicit mapping?
23:49:52 <bollu> Cale: X \in C
23:50:05 <ab9rf> endofunctors seem like something that the ghostbusters ought to use
23:50:44 <EvanR> capri sun endocooler
23:51:16 <ab9rf> "turn up the endofunctor, they're getting past us!"
23:51:31 <Mibaz> ab9rf: I hear when you become a level 16 endofuntor you get superpowers
23:52:00 <ab9rf> but i already have superpowers
23:52:46 <ski> @quote fusoid
23:52:46 <lambdabot> ciaranm says: a confusion is just the categorical dual of a fusion, which is just a fusoid in the category of brainofunctors
23:52:54 <bollu> is there a ##categorytheory
23:52:56 <bollu> lol
23:53:04 <EvanR> yes
23:53:06 <bollu> ski: wouldn't it be "nfusion"
23:53:16 <ski> i wondered about that, myself
23:53:16 <ab9rf> that should be a cofusion, not a confusion
23:53:30 <ski> would have to ask ciaranm, i guess
23:53:40 <ab9rf> is a ffee another name for a donut?
23:53:52 <EvanR> nice
23:54:23 <ab9rf> not really sure what the categorical dual of a beverage would be
23:54:27 <EvanR> esp since donut is homeomorphic to the thing the coffee inhabits
23:54:51 <hololeap> so, would it be considered OT to ask questions about how haskell relates to category theory?
23:55:02 <ab9rf> hololeap: i wouldn't think so
23:55:09 <ab9rf> you might induce nosebleeds though
23:55:20 <EvanR> from being too high level?
23:55:33 <Mibaz> If I'm not mistaken (noob here) category theory is where a lot of Haskell "design patterns" kinda come from, right?
23:55:35 <EvanR> or because CT is like porn to haskellers
23:55:40 <bollu> guys, yonda proof plz
23:55:42 <bollu> yoneda*
23:55:51 <hololeap> EvanR: :D
23:56:00 <bollu> I know I'm being annoying, but I can't find any proper explanation of the natural transformation :P
23:56:19 <cocreature> @remember EvanR or because CT is like porn to haskellers
23:56:20 <lambdabot> Nice!
23:56:36 <EvanR> hmm context missing
23:56:36 <hololeap> wtf just happened
23:56:56 <cocreature> EvanR: context just makes quotes boring
23:57:10 <EvanR> a natural transformation is a mapping from one functor to another, both the starting and ending functor have to share the same starting and ending category
23:57:26 <EvanR> that follows the naturality laws
23:57:40 <bollu> EvanR: no that's not my problem. I want a natural transformation from Hom(X, -) to some other functor g :: C -> Set (X \in C)
23:57:45 <geekosaur> Mibaz, some of them, not all of them. many of the patterns come from less abstract theories
23:58:12 <bollu> EvanR: i.e, yoneda )
23:58:13 <bollu> :)
23:58:16 <EvanR> uh huh
23:58:26 <geekosaur> and even Monad itself, I am recalling (I think) Wadler saying that it's less a CT monad than a pattern inspired by CT monads that turns out to be useful
23:58:30 <bollu> EvanR: I'm not sure how to construct the natural transformation
23:58:37 <ski> @quote abstract.nonsense
23:58:37 <lambdabot> sorear says: I find it very amusing how Church's abstract nonsense turned out to make for better programming than Turing's real-world metaphors.
23:58:40 <bollu> everyone is like "look where the identity arrow goes"
23:58:52 <bollu> @quote woo
23:58:52 <lambdabot> Korollary says: darcs is free of chemical toxins of big pharma. It's made using all natural herbs and other woo. It's good for you. Cheers.
23:58:56 <bollu> lol what
23:58:57 <hololeap> i have read that a type of (* -> *) that inherits Functor correspond to a functor in CT.  Monad obviously corresponds to monads. what does Applicative correspond to?
23:59:00 <EvanR> bollu: when i did this, i drew a big diagram 
23:59:08 <bollu> heh, of everything?
23:59:18 <EvanR> with C on one side and Set on the other
23:59:18 <bollu> @quote continuation
23:59:19 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
23:59:22 <cocreature> bollu: what is Set (X \in C)?
23:59:39 <bollu> cocreature: just Set. The (X \in C) was an addendum that X is in the category C
23:59:49 <cocreature> ah ok
23:59:49 <ski> s/a type of/a type of kind/,s/inherits/is an instance of/,s/functor/endofunctor on `Hask'/
23:59:56 <bollu> wow there really is a quote for everything here
