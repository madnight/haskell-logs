00:01:40 <grantwu> Hrm... I imagine for lists?
00:02:00 <grantwu> Defining it separately would allow termination in more cases.
00:02:25 <hololeap> i don't understand
00:02:45 <grantwu> wait, nvm
00:03:19 <grantwu> That example doesn't work.
00:03:53 <grantwu> But in general, it's possible that there's a more efficient way of checking if two things differ than if they are equal
00:04:11 <hololeap> gotcha
00:04:15 <grantwu> Or at least, I can't think of a general argument for why this is impossible
00:04:30 <grantwu> I'm clearly sleep deprived so maybe there's an argument :P
00:05:31 <grantwu> Hrm... no, if there was a more efficient way of implementing /=, you would just define a == b as not (a /= b)
00:05:40 <grantwu> Yeah, I don't think there's a good way.
00:05:46 <grantwu> er, reason to define it differently
00:06:12 <grantwu> I don't think there's a mechanism in Haskell to forbid someone from overriding the definition of a typeclass method, though?
00:06:14 <hololeap> i see, but it leaves the option to define == in terms of /=
00:06:27 <grantwu> yeah
00:06:43 <grantwu> clearly we need another language pragma for this :P
00:07:35 <grantwu> (in practice, I think this is just a non problem.)
00:07:39 * hackagebot sqlite-simple-errors 0.5.0.0 - Wrapper around errors from sqlite-simple  https://hackage.haskell.org/package/sqlite-simple-errors-0.5.0.0 (jmc41493)
00:07:39 * hackagebot yackage 0.8.1 - Personal Hackage replacement for testing new packages.  https://hackage.haskell.org/package/yackage-0.8.1 (MichaelSnoyman)
00:08:02 <hololeap> i was just curious since i saw that == and /= were both marked MINIMAL when i did :i Applicative
00:08:37 <lyxia> I don't think there is ever a situation where you would implement (==) and (/=) differently.
00:09:07 <hololeap> but according to a wikibook one is always optional since they are defined in terms of each other. i don't even know how that would be worked out by the compiler :/
00:09:07 <lyxia> simply because they're just a "not" away from each other
00:09:35 <hololeap> being defined in terms of each other, that is
00:09:42 <grantwu> You mean, ever a situation in which you would not implement one in terms of the other?
00:10:23 <hololeap> from the output of :i Applicative, i thought that both definitions were necessary
00:10:35 <hololeap> and i couldn't think of a reason why
00:11:56 <lyxia> I thought we were talking about Eq
00:12:48 <lyxia> grantwu: right
00:13:53 <hololeap> yeah, sorry Eq ...
00:14:09 <lyxia> hm, maybe if the one you implement is recursive there might be a tiny boost in performance by inlining it in the other
00:14:42 <grantwu> is GHC not smart enough to do that optimization on its own?
00:15:20 <lyxia> I don't know actually.
00:15:29 <grantwu> I hope it is
00:15:51 <grantwu> If not, it's time to sprinkle {-# INLINABLE #-} throughout my entire codebase
00:16:32 <lyxia> there are probably much better things to optimize than this
00:17:19 <lyxia> the "not" may be simplified anyway after composing with other functions.
02:21:49 <kuribas> is (*256) implemented as bit shift in ghc?
03:00:17 <__monty__> Are noob questions about stack welcome here?
03:22:31 <liste> __monty__: yes
03:26:56 <__monty__> I have a pretty much empty repo, created via github, that will house my code. As an afterthought I wanted to use stack. My problem is that stack new aborts because the repo directory already exists and stack init doesn't seem appropriate since there's no .cabal file yet. How do I "stack new" on an existing project directory as it where?
03:31:20 --- mode: wilhelm.freenode.net set +o ChanServ
03:37:23 <elfeck> hello, can somone tell me what the prefix-' eg. 'open is in here: https://github.com/agrafix/Spock/blob/master/Spock-api/src/Web/Spock/Api.hs#L27?
03:38:46 <haskell933> newbie question: does anybody know how to solve the 'cabal: Could not resolve dependencies' error on Windows? I'm pulling my hair out
03:41:25 <elfeck> haskell933: cabal is really annoying to handle when used system-wide. Maybe look into cabal-sandboxes or stack
03:42:38 <haskell933> elfeck: the installation guide to the program I'm trying to install says 'Clanki can only be installed through cabal'
03:44:33 <elfeck> haskell933: I have no experience with windows, but you can install it with cabal, but in a sandbox
03:45:05 <haskell933> elfeck: ok thanks, I'll try that
03:45:26 <elfeck> haskell933: so make a folder, go into that folder and call "cabal sandbox init"
03:45:42 <elfeck> haskell933: then try the installing from that folder
03:45:58 <the_bat> Hey guys! I have been learning haskell for last couple of months and have tried my hands writing on writing some simple apps using yesod. I've been looking into some library code but couldn't get anything easily. I keep on seeing some new terms like GADT, typefamilies etc.
03:46:06 <the_bat> for eg, what does this mean: type family Column (f :: * -> *) (a :: *) = r | r -> f a
03:46:06 <elfeck> haskell933: ie "cabal install clanki"
03:46:17 <the_bat> I started learning from LYAH. What do you guys suggest should I should look into for getting something like this.
03:46:31 <Hafydd> the_bat: the GHC manual.
03:46:51 <Hafydd> the_bat: in particular, the section on GHC's extensions to the language.
03:47:11 <Gurkenglas> elfeck, it allows you to write data constructors in types. (I figured out to say that by knowing it has something to do with dependent types, then translating "'" into "<tt>'</tt>" on the page source of https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell , then finding "Option 1: Use ' to write data constructors in types and use ^ to write type constructors in terms. The first of these is already implemented. 
03:47:11 <Gurkenglas> The second is up for debate. Do these operators work only on individual identifiers? Or, can we say f ^(...) to make everything in the ... be treated like a type?"
03:47:14 <the_bat> is it written in a fashion in which a newbie can understand
03:47:38 * hackagebot texmath 0.8.6.6 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.6.6 (JohnMacFarlane)
03:47:40 * hackagebot ghcjs-dom-jsffi 0.4.1.1 - DOM library using JSFFI and GHCJS  https://hackage.haskell.org/package/ghcjs-dom-jsffi-0.4.1.1 (HamishMackenzie)
03:47:42 * hackagebot ghcjs-dom 0.4.1.1 - DOM library that supports both GHCJS and GHC  https://hackage.haskell.org/package/ghcjs-dom-0.4.1.1 (HamishMackenzie)
03:47:44 * hackagebot jsaddle 0.5.1.1 - Interface for JavaScript that works with GHCJS and GHC  https://hackage.haskell.org/package/jsaddle-0.5.1.1 (HamishMackenzie)
03:47:56 <the_bat> I have tried reading many articles but all assume some background. I'm basically getting lost on where to start
03:48:26 <Hafydd> the_bat: some of it isn't, but the Haskell Wiki might have some supplementary material.
03:48:44 <haskell933> elfeck: thanks but that gives me the same error
03:49:08 <elfeck> Gurkenglas: so it's part of the DataKinds extension?
03:49:25 <Hafydd> the_bat: the GHC manual is still a good place to start, because if it isn't listed there, it probably doesn't exist.
03:50:09 <the_bat> okay. so I'll start from there. If I get stuck somewhere, you guys are there to help :)
03:50:12 <elfeck> haskell933: cabal can be a mess. I don't really know since I don't use cabal directly, but try purging anything haskell from your system and start over, using sandboxes/stack exclusively
03:50:19 <Hafydd> So we are.
03:50:19 <the_bat> I've heard haskell people are quite friendly
03:50:32 <the_bat> Thanks Hafydd 
03:50:41 <Gurkenglas> elfeck, *looks up* sounds right, looking at https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell -> "Some notes of name resolving"
03:51:17 <elfeck> Gurkenglas: alright, thanks. 
03:51:24 <Gurkenglas> (found as the first google result for DataKinds, then ctrl-f a few times for ')
04:04:20 <kuribas> is (*256) implemented as bit shift in ghc?
04:08:32 <isBEKaml> kuribas: That's just a partially applied function. What's a bit shift is about there?
04:08:46 <isBEKaml> > let bb = (* 256); bb 2;
04:08:48 <lambdabot>  <hint>:1:23: error: parse error on input ‘;’
04:09:04 <isBEKaml> > let bb = (* 256)
04:09:07 <lambdabot>  <no location info>: error: not an expression: ‘let bb = (* 256)’
04:09:18 <kuribas> isBEKaml: well, supposing it's an integer type
04:13:22 <kuribas> let bb = (* 256) in bb 2
04:13:23 <lpaste> amatos pasted “Doesn't type check” at http://lpaste.net/257577
04:13:32 <kuribas> > let bb = (* 256) in bb 2
04:13:34 <lambdabot>  512
04:14:15 <tabaqui> how i can parse double dict with module Yaml
04:14:17 <tabaqui> if have
04:14:23 <tabaqui> address:
04:14:27 <tabaqui>     host: 123
04:14:31 <tabaqui>     port: 234
04:14:59 <kuribas> > let bb = (shift 8) in bb 2
04:15:01 <lambdabot>  32
04:15:07 <tabaqui> .: method returns Parse t, and i cannot open it like a dict
04:15:36 <amatos> Wondering if someone can help me with this code snippet: http://lpaste.net/257577. Doesn't compile, and I get the error: "Couldn't match type ‘IO (V.Vector SeriesIdentifier)’ with ‘V.Vector b’. I know it's a matter of simply wrapping something to return the monad but I'm a newbie and can't make it work.
04:15:51 <kuribas> > let bb = (flip shift 8) in bb 2
04:15:54 <lambdabot>  512
04:16:01 <kuribas> isBEKaml: ^
04:16:52 <liste> amatos: try replacing RR.filteringMap with (fmap RR.filteringMap)
04:16:54 <liste> :t fmap
04:16:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:19:26 <amatos> liste: I've tried that and doesn't work either: I get another error: I get exactly the same error
04:19:42 <amatos> sorry, I mean I get exactly the same error
04:20:17 <kuribas> amatos: you cannot unify "V.Vector T.Text -> IO (V.Vector SeriesIdentifier)" with "(V.Vector a -> V.Vector b)"
04:20:42 <kuribas> amatos: V.Vector b and IO (V.Vector SeriesIdentifier) aren't the same thing
04:21:59 <amatos> kuribas: right. But shouldn't it be possible to wrap filteringMap so that it works with V.Vector T.Text -> IO (V.Vector SeriesIdentifier)?
04:23:01 <kuribas> amatos: what would you expect to get?
04:23:13 <ocramz> hi all
04:23:55 <kuribas> amatos: qdiaStyleFiltering would need to return IO 
04:24:08 <amatos> kuribas: I would like to have an IO (Filtering SeriesIdentifier)
04:24:17 <ocramz> is there a pre-made abstraction for inspecting N previous `State`s ?
04:24:38 <amatos> I would like qdiaStyleFitering to be an  IO (Filtering SeriesIdentifier)
04:24:41 <isBEKaml> kuribas: Not sure, I haven't really checked those. You can find out with -ddump-asm and comparing the differences. GHC probably does constant folding and converting (*) into bit shift operations. 
04:24:59 <ocramz> something like `MonadState s m => ([s] -> Bool) -> (s -> s) -> m s`
04:25:13 <ocramz> or some other Foldable of s in the predicate
04:25:46 <ocramz> I'm thinking of something to represent a convergence check
04:26:19 <kuribas> amatos: you cannot turn an impure function into a pure one.  You can do the opposite though.
04:28:24 <kuribas> You need something like: filteringMapM:: Monad m => (V.Vector a -> m (V.Vector b)) -> Filtering a -> (m (Filtering b))
04:28:30 <amatos> kuribas: OK. I guess that's why there's map and mapM. 
04:28:44 <kuribas> yes
04:29:52 <amatos> kuribas: thanks.
04:30:51 <elfeck> anyone here using haskell-mode (emacs)? I have trouble with indention and DataKind '-infix notation
04:31:43 <kuribas> elfeck: you should try #haskell-emacs
04:32:11 <elfeck> kuribas: alright, thanks
04:42:29 <hsk3> What is "source-repository" in a cabal file actually used for?
04:43:37 <dcoutts> hsk3: it's listed on hackage, which is helpful for other people. And if you use cabal get -s then people can grab the repo version rather than the tarball
04:43:52 <hsk3> ok cool
04:43:54 <hsk3> thanks
04:47:40 * hackagebot http-pony-transformer-case-insensitive 0.1.0.2 - Tag http headers as case insensitive  https://hackage.haskell.org/package/http-pony-transformer-case-insensitive-0.1.0.2 (JinjingWang)
04:47:42 * hackagebot http-pony-transformer-startline 0.1.0.1 - transform HTTP startlines to tuples  https://hackage.haskell.org/package/http-pony-transformer-startline-0.1.0.1 (JinjingWang)
04:47:44 * hackagebot http-pony-transformer-http 0.1.0.1 - Transform raw TCP stream to a basic HTTP type  https://hackage.haskell.org/package/http-pony-transformer-http-0.1.0.1 (JinjingWang)
04:47:46 * hackagebot http-pony-transformer-http 0.1.0.2 - Transform raw TCP stream to a basic HTTP type  https://hackage.haskell.org/package/http-pony-transformer-http-0.1.0.2 (JinjingWang)
04:47:48 * hackagebot http-pony 0.1.0.4 - A type unsafe http library  https://hackage.haskell.org/package/http-pony-0.1.0.4 (JinjingWang)
05:17:58 <PatrickRobotham>  Is Haskell much good for Data Analysis?
05:23:28 <kuribas> yes
05:24:52 <kuribas> I think python has more libraries and a bigger community for that stuff.
05:34:21 <kuribas> But haskell is fine as well.
05:36:21 <mettekou> kuribas: Is there a reason not to use R in your opinion?
05:40:48 <Denommus> is there a way to get the database to call a function in my application when I have a trigger?
05:41:39 <JonReed> Hi, I'm struggling with something that seems to be so basic. Let's say I have `f :: (HashAlgorithm a) => a -> IO ()`. Then I want to call to have `a' <- read <$> readLine; case a' of Just a -> f a'; Nothing -> return ()`. In other words I if `a` has in instance of Read and an instance of HashAlgorithm then I want to parse a and call `f` with it otherwise do nothing.
05:42:05 <sdx23> Denommus: "the database"?
05:42:37 <JonReed> In other words, if `a` has an instance of `HashAlgorithm` and an instance of `Read` then I want to `read a` and call `f` with that `a`*
05:43:11 <JonReed> where `f` accepts any `a` that has an instance of `HashAlgorithm`
05:43:13 <Denommus> sdx23: say, a RDBMS
05:43:35 <Denommus> sdx23: if a trigger happens, I want a callback to be called in my application
05:43:42 <sdx23> JonReed: you want to promote f into the Maybe Monad?
05:43:42 <Denommus> is there a solution for that?
05:44:17 <hpc> that's a question to ask the channel for whatever RDBMS you are using
05:44:25 <JonReed> sdx23: I'm not sure what you mean. I suspect that it maybe something simple and my brain just glitches.
05:45:00 <hpc> and then once you know what kind of external callbacks the engine supports, you can probably write code in any language that fits it
05:47:06 <JonReed> sdx23: In a sense I want to do `f` if that hash algorithm has an instance, otherwise I want to do something else (like inform a user that string he typed does not match any supported instances).
05:47:41 * hackagebot fixplate 0.1.7 - Uniplate-style generic traversals for optionally annotated fixed-point types.  https://hackage.haskell.org/package/fixplate-0.1.7 (BalazsKomuves)
05:47:43 * hackagebot patat 0.2.0.0 - Terminal-based presentations using Pandoc  https://hackage.haskell.org/package/patat-0.2.0.0 (JasperVanDerJeugt)
05:47:45 <lyxia> JonReed: you can't write code conditionally on whether an instance exists
05:47:45 * hackagebot combinat 0.2.8.2 - Generate and manipulate various combinatorial objects.  https://hackage.haskell.org/package/combinat-0.2.8.2 (BalazsKomuves)
05:48:26 <lyxia> IfCxt exists but it's a hack just for show.
05:49:35 <Denommus> hpc: good point!
05:49:43 <lyxia> JonReed: Read is type oriented, you can't deduce the type of the result from the input.
05:50:39 <JonReed> lyxia: Hm. But let's say I have a function from `String -> Maybe a` which represents read. Then I want to either call `f` if String parsed to supported type or do nothing.
05:51:23 <JonReed> So for each string only one type exists or no type.
05:51:41 <lyxia> you have to write your own parser
05:51:56 <JonReed> lyxia: Yeah, but how to then call `f` dynamically. 
05:52:08 <JonReed> It accepts `HashAlgorithm a`
05:52:28 <JonReed> `HashAlgorithm a => a -> IO ()`*
05:53:13 <JonReed> Where a can be many types. `data SHA256 = SHA256; data SHA512 = SHA512;` etc
05:53:31 <JonReed> and each data has instance of HashAlgorithm 
05:54:45 <lyxia> I would parse into a sum type: String -> Maybe SomeHashAlgorithm
05:55:26 <lyxia> You don't really use the SHA* constructors, do you?
05:56:20 <lyxia> I mean you don't pattern match on them, you're just using their types to dispatch the call to a hash algorithm?
05:56:40 <JonReed> `f` can deal with any `a` that has HashAlgorithm instance. Those contructons come from cryptonite. I want to support any hash function that cryptonite has. 
05:56:49 <JonReed> lyxia: Yeah
05:57:34 <lyxia> I would use empty types for that, data SHA256 ; data SHA512 ... ; f :: HashAlgorithm a => Proxy a -> IO ()
05:58:07 <lyxia> Hm, the type signatures might be somewhat annoying here.
05:58:24 <JonReed> lyxia: No it's okay if it uses proxies. 
05:59:38 <JonReed> lyxia: I'm still a bit confused about how it would work. But I'll try. How would I parse it into Proxy a from a string? symbolVal? 
06:00:04 <lyxia> And so, SomeHashAlgorithm would use existential types, data SomeHA where SomeHA :: HA a -> SomeHA ; data HA a where { SHA256 :: HA SHA256 ; SHA512 :: HA SHA512 ... }
06:02:04 <codedmart> Anyone familiar with using haskell in docker. When I use stack to build my project in docker I end up with a file along like `cc7mP01W`. The all seem to start with `cc` and I get a new one everytime I build.
06:02:48 <lyxia> JonReed: actually this might look better    data SomeHA where SomeHA :: HashAlgorithm a => a -> SomeHA  (without an auxiliary HA type)
06:03:46 <knupfer> How difficult would it be to detect on compiler side whether a function may call undefined or error?
06:03:55 <lyxia> JonReed: Especially if the constructors for the algorithms are there anyway.
06:04:21 <lyxia> knupfer: that's equivalent to the halting problem
06:04:25 <osa1> knupfer: undecidable in general
06:04:33 <osa1> knupfer: but you can certainly apply many static analysis techniques
06:04:53 <knupfer> Why is that equivalent to the halting problem?
06:05:06 <osa1> if <halts> undefined else True
06:05:15 <osa1> if <halts> then undefined else True
06:05:28 <osa1> run your analysis on this expression
06:05:57 <knupfer> Well, I wanted to say which expression uses `undefined` or `error~
06:06:11 <osa1> oh, you mean syntactic check? but that's useless
06:06:21 <knupfer> osa1: Why?
06:06:37 <osa1> knupfer: you can have aliases to undefined or error, or you can pass undefined to an higher order function for example
06:07:23 <osa1> knupfer: if you still want a syntactic check, it's trivial
06:08:43 <knupfer> osa1: I'm dreaming of a language pragma, which wraps every function which could possibly call error or undefined into Maybe
06:08:58 <Philonous> > isLower (toLower '\186') -- is this expected?
06:09:00 <lambdabot>  False
06:09:15 <hpc> > '\186'
06:09:17 <lambdabot>  '\186'
06:09:25 <Philonous> > isLetter '\186'
06:09:25 <osa1> knupfer: what do you transform `map undefined lst` to ?
06:09:26 <ab9rf> does  ([1..] ++ [error "blort"]) ever call error?
06:09:27 <lambdabot>  True
06:09:41 <hpc> > charName '\186'
06:09:43 <lambdabot>  error:
06:09:43 <lambdabot>      Variable not in scope: charName :: Char -> t
06:09:56 <knupfer> osa1: [Nothing...]
06:09:57 <Philonous> It's this one: º
06:10:03 <hpc> @let import Data.Text.ICU.Char
06:10:03 <lambdabot>  .L.hs:122:1: error:
06:10:04 <lambdabot>      Failed to load interface for ‘Data.Text.ICU.Char’
06:10:04 <lambdabot>      Use -v to see a list of the files searched for.
06:10:08 <hpc> :(
06:10:12 <ab9rf> knupfer: that wil seriously blort types
06:10:15 <sdx23> > generalCategory '\186'
06:10:17 <lambdabot>  OtherLetter
06:10:53 <sdx23> other letters can't be made LowercaseLetter, so isLower is false
06:10:55 <knupfer> ab9rf: but only of potentially partial functions
06:11:56 <osa1> knupfer: in addition, error is actually useful when you need to really abort. assertions are useful in functional programming too :)
06:12:02 <knupfer> ab9rf: Well, no. It doesn't ever call error.
06:12:13 <JonReed> lyxia: I'm confused about how to make it work :( I got here so far: http://lpaste.net/257680
06:12:15 <knupfer> osa1: I dislike them :(
06:12:40 <Philonous> Ah, so isLetter is the wrong test to check if something can be made lowercase. thanks
06:12:44 <knupfer> osa1: I'm just furious about the occasional succ True
06:12:47 <osa1> knupfer: you can't prove that all your invariants hold all the time :)
06:13:10 <knupfer> > succ True
06:13:11 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
06:13:28 <osa1> knupfer: arguable that's an API problem
06:13:49 <osa1> knupfer: it could wrap for example and that'd be fine
06:14:06 <knupfer> or wrap it into Maybe
06:14:06 <osa1> arguably*
06:14:12 <osa1> that too
06:14:34 <knupfer> > minimum []
06:14:36 <lambdabot>  *Exception: Prelude.minimum: empty list
06:15:23 <knupfer> There are a lot of functions in the Prelude where I'm wondering a lot about the missing Maybe.
06:16:03 <osa1> yeah so ideally I think we'd have a _maybe variant of most partial functions but we don't at the moment
06:16:25 <jophish> the 'safe' package might interest you
06:16:32 <osa1> yeah I use it
06:16:49 <lyxia> JonReed: you need to write your own read function
06:17:07 <knupfer> jophish: I use it too.  I wanted a way to enforce it and not need to pray whether some library author used error.
06:17:29 <JonReed> lyxia: myRead :: String -> Maybe SomeHA ?
06:17:47 <jophish> I'd consider it a bug in a package if it was possible to get it to reach 'error'
06:18:05 <knupfer> jophish: For me as well, but look at the Prelude
06:18:19 <JonReed> lyxia: No wait that does not sound right... Hm..
06:18:20 <jophish> yeah, I think we all feel the same way :/
06:19:02 <osa1> we need a TotalPrelude free from partial functions :)
06:19:12 <knupfer> osa1: YES!
06:19:23 <knupfer> Well, let's allow recursion.
06:19:26 <osa1> who's creating the git repo :p
06:19:28 <osa1> knupfer: haha right
06:19:44 <knupfer> Another pain point: Int
06:19:54 <osa1> you mean things like 1 / 0 ?
06:20:02 <jophish> or length :: -> Int
06:20:09 <osa1> right
06:20:11 <knupfer> > succ (maxBound :: Int)
06:20:13 <lambdabot>  *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
06:20:16 <knupfer> oh
06:20:28 <knupfer> > maxBound + (1 :: Int)
06:20:28 <osa1> well that'll be fixed in our prelude :)
06:20:30 <lambdabot>  -9223372036854775808
06:20:33 <knupfer> That one
06:20:53 <jophish> I think the Enum class is one of the worst
06:21:04 <knupfer> Int should be exported from, let's say Unsafe.Number
06:21:32 <knupfer> Prelude isn't optimized for performance, but for comfort.  So I don't see a vareason not to use Integer.
06:21:44 <knupfer> s/vareason/valid reason
06:21:52 <lyxia> JonReed: that was right actually
06:23:32 <JonReed> lyxia: Ok. That seems to be working (myRead "SHA256" = Just $ SomeHA SHA256). Thx. I'll not try figure out the rest.
06:23:42 <JonReed> I'll now*
06:24:19 <FransWillem> Hi, I'm having trouble with classes, could anyone take a look at how I can get GHC to understand the "AsTypeSpec" instances are not overlapping here: http://pastebin.com/LJAZBM9z ?
06:25:59 <lyxia> JonReed: It's quite boilerplatey but I don't think of a better way.
06:26:12 <lyxia> can't think
06:26:16 <jophish> FransWillem: GHC won't look at the super classes when checking for overlappingness
06:26:54 <FransWillem> jophish: Any idea how to rewrite this without having to manually write all instances of asTypeSpec for asDottedName instances ?
06:27:09 <knupfer> osa1: https://github.com/knupfer/total-prelude
06:28:03 <osa1> knupfer: cool! not sure if I'll be able to contribute (time limitations) but I'll definitely be watching :)
06:28:37 <jophish> s/superclasses/context/
06:28:59 <jophish> FransWillem: you could use a newtype
06:29:45 <knupfer> osa1: :)
06:30:30 <JonReed> lyxia: Thanks!!! At least now know a way to do it without Template Haskell. I ended it with this: http://lpaste.net/edit/257680
06:31:15 <JonReed> I'll experiment more with it and perhaps try find something with less boilerplate.
06:47:42 * hackagebot resourcet 1.1.8 - Deterministic allocation and freeing of scarce resources.  https://hackage.haskell.org/package/resourcet-1.1.8 (MichaelSnoyman)
06:47:44 * hackagebot pandoc-citeproc 0.10.1.2 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.1.2 (JohnMacFarlane)
06:50:34 <kuribas> mettekou: I don't know R well...
06:51:30 <osa1> uhh why is fgl's (&) not infixr? I can't chain it
06:52:06 <shapr> Is fgl the best/easiest graph library available at the moment?
06:53:18 <lyxia> osa1: should it be infixr
06:53:44 <osa1> lyxia: otherwise you can't do things like `ctx1 & ctx2 & graph`
06:54:04 <osa1> you have to do `ctx1 & (ctx2 & graph)`
06:54:32 <lyxia> o i c
06:55:44 <lyxia> time to PR I guess
06:57:00 <osa1> I'm also a bit confused about (&)'s semantics. if I add a new successor node do I have to manually update the successor to add a predecessor to it?
07:00:03 <lyxia> I think it's taken care of already
07:17:45 <tabaqui> how i can easy construct tuple with many values
07:17:49 <tabaqui> ?
07:18:01 <osa1> tabaqui: by using tuple syntax??
07:18:01 <ongy> (a, b, c, d)
07:18:02 <srhb> tabaqui: "many" as in arbitrarily?
07:18:20 <tabaqui> nono, i want f.e 10 Maybe values
07:18:31 <tabaqui> but don't want to type (Maybe a, Maybe a,...)
07:18:45 <srhb> tabaqui: Those are types, not values, though.
07:18:57 <srhb> tabaqui: Short answer: You can't
07:19:00 <tabaqui> srhb: yeah, right
07:19:25 <tabaqui> srhb: i've seen in some library hack with fold (or maybe scan) functions
07:19:32 <tabaqui> like fold (,) ...
07:19:42 <srhb> tabaqui: Why do you want this, though?
07:19:55 <srhb> Allowing heterogeneity limits your options profoundly.
07:20:17 <srhb> If you just want fixed length and not heterogeneity, perhaps fixed length vectors are a better choice.
07:20:23 <tabaqui> srhb: i'm working with yampa now, and have many SF objects, treating as socket workers
07:20:32 <StoneToad> tabaqui: that gives you nested tuples, ie (a, (b, (c, ())))
07:20:48 <tabaqui> srhb: after event, i should send big tuple to all of them, but some will get Nothing, and some will get Just
07:21:08 <tabaqui> srhb: what is fixed length list?
07:21:37 <tabaqui> ah, and they are not heterogeneous
07:22:39 <tabaqui> maybe templates can help me?
07:37:09 <phadej> is there de-facto package talking about natural transformation, or does every non-trivial package has own definitions for them?
07:38:04 <phadej> e.g. there is https://hackage.haskell.org/package/natural-transformation, but it's not widely used
07:40:16 <osa1> how do I update label of a node in fgl?
07:47:44 * hackagebot distributed-process 0.6.6 - Cloud Haskell: Erlang-style concurrency in Haskell  https://hackage.haskell.org/package/distributed-process-0.6.6 (FacundoDominguez)
07:48:31 <nilof> Out of curiosity, what do Haskellers think of Elm
07:49:01 <srhb> nilof: Haskellers, too, have differing opinions of Elm.
07:58:07 <lyxia> osa1: use match to get the node out, and & to put it back
07:58:23 <osa1> lyxia: I'm doing that but that's annoying. it should have an updateLabel function
08:02:27 <the_2nd> I defined an attoparsec parser for e.g. any text betweeen double quotes. How can I write a new parser, using this one and e.g. only using strings between double quotes not ending with "foo" ?
08:02:58 <the_2nd> Since the normal flow would be dealing with the rest after the quoted text, but I want to use the matched text
08:04:09 <lyxia> osa1: :/ yeah the fgl interface seems very minimal at the moment.
08:05:30 <pavonia> the_2nd: You could run the first parser and inspect its result afterwards, failing if the suffix doesn't match
08:07:37 <Guest75649> Is anybody here using Vim with Haskell that can help me with something?
08:08:19 <tabaqui> Guest75649: what exactly?
08:08:21 <Guest75649> I've tried using hdevtools and vim-hdevtools plugin for linting and type
08:08:28 <Guest75649> Linting works fine with syntastic
08:08:35 <nitrix> joe9: Hey, if you're still here, I've allowed you to PM me.
08:09:01 <tabaqui> nope, i don't use this plugin
08:09:24 <Guest75649> But getting the type returns a error i'll elaborate on if anybody uses the same setup
08:15:23 <lyxia> Maintaining pre-AMP compatibility is annoying. I'm so used to assuming any Monad is a Functor.
08:17:01 <jophish> lyxia: Functor, not applicative?
08:17:09 <csauce> Guest75649, I had a lot of trouble getting set up with hdevtools - instead I went with http://www.stephendiehl.com/posts/vim_2016.html (if you install ghc-mod, make sure you remove hdevtools executable from your path because Syntastic might try to use that)
08:23:24 <lyxia> jophish: that too.
08:25:09 <lyxia> It's common enough to use fmap in a monadic context.
08:25:25 <tabaqui> does anybody know Yampa?
08:26:04 <mettekou> Does anyone have an idea how to implement turn-based games in which moves can have effects which occur on a future turn without creating callback hell in Haskell?
08:26:15 <tabaqui> i want to build SF, that activates if any of two inputs gets event
08:26:57 <tabaqui> mettekou: FRP will save the world!
08:27:01 <lyxia> mettekou: what kind of effect
08:27:41 <Cale> mettekou: It really depends on the situation, but for a turn based game, can't you just maintain something like a Map from future turn numbers to collections of effects of some sort?
08:28:56 <ph88> why doesn't haskell have something like this ? http://fsharp.org/mentorship/index.html
08:29:05 <mettekou> Cale lyxia: It's actually more complicated, the games I'm looking into (mainly Magic: The Gathering) need to register listeners for events.
08:29:26 <mettekou> For example: "when card C leaves the field, do action X".
08:30:08 <mettekou> If I didn't have to deal with the events, I could just implement cards as Kleisli arrows for a MagicT monad transformer.
08:30:25 <tabaqui> mettekou: in first version of similar program i've used priority queue with tasks and scheduler
08:30:30 <tabaqui> but it's a callback hell
08:31:09 <mizu_no_oto_work> mettokou: each card can have a list of Actions, where you have 'data Action = CreateToken Name Power Toughness | DealDamage Amount ...'
08:31:16 <grantwu> what is a MagicT?
08:31:22 <grantwu> oh... nvm
08:31:29 <mettekou> grantwu: Haha.
08:31:29 <tabaqui> in python it was epoll instance that listen next "n" secods for external events and if there is no events, than it calls next task from queue
08:32:08 <mettekou> mizu_no_oto_work: Indeed, but that doesn't deal with them taking place when an event occurs.
08:32:11 <c_wraith> ph88: that'd be pretty cool.  There should be something like that.  It needs a fair amount of work to coordinate, though.  Someone would need to commit to doing it.  In the mean time, there's this channel. :)
08:33:07 <ph88> :)
08:33:16 <ph88> brb
08:34:10 <mizu_no_oto_work> mettekou: to make it more general (i.e. not just a list to fire when the card is removed from play), you could have each card hold onto a Map Trigger Action.
08:34:57 <mizu_no_oto_work> Err, Map Trigger [Action]
08:35:05 <mettekou> mizu_no_oto_work: That is similar to the approach I had in mind, but I wondered if anyone here had a more elegant solution. Nevertheless, that should work fine.
08:35:08 <ph88> geekosaur, are you here? i managed to get a stack trace on exception with the profiling options  https://paste.fedoraproject.org/449610/37286414/
08:38:21 <cath> I've posted this in haskell-stack but haven't received any info.  Could anyone advise?  I quote: I have a stack project that pulls some commits from github repo.  Once every 4 compiles or so, it decides that some local files have changed (they haven't) and proceeds to reclone and compile everything.  Anyway to tell it not to do this?
08:46:46 <knupfer> Is there a reason that NonEmpty uses a list, and not a foldable?
08:46:48 <sm> cath: you may have more luck opening an issue in stack's tracker
08:47:38 <geekosaur> knupfer, because it has to pick one? Foldable is not a type
08:47:46 * hackagebot distributed-process-simplelocalnet 0.2.3.3 - Simple zero-configuration backend for Cloud Haskell  https://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.3.3 (FacundoDominguez)
08:49:31 <knupfer> geekosaur: Why not (|:) :: Foldable f => a -> f a -> NonEmpty a
08:50:33 <geekosaur> it is the type of a non-empty list. I'd suspect excessive polymorphism would just mean you always have to annotate its uses, not that you get to be clever
08:51:27 <Cale> knupfer: Surely it would then have to be at least NonEmpty f a
08:52:09 <Cale> Also, I don't think that constraint buys you much of anything
08:52:10 <knupfer> Cale: Ah, forgot about that.  Perhaps that would be too fancy for the prelude?
08:52:55 <Cale> So it should just be (:|) :: a -> f a -> NonEmpty f a perhaps
08:52:55 <aloiscochard> when running stack locally on a project I keep getting:
08:52:57 <aloiscochard> "setup-Simple-Cabal-1.24.0.0-ghc-8.0.1: unable to decommit memory: Invalid argument"
08:53:01 <dolio> That was proposed.
08:53:03 <aloiscochard> any idea what is the issue?
08:53:11 <aloiscochard> everything actually works though... weirldy
08:53:46 <dolio> The NonEmpty f a thing, that is.
08:53:57 <dolio> Didn't win.
08:53:58 <knupfer> dolio: And why did they default to []?
08:54:07 <knupfer> hm
08:54:41 <dolio> I don't remember. The existing API that was being included already had NonEmpty the way it was, I think.
08:54:58 <dolio> And the change was deemed not good enough to bother.
08:55:07 <dolio> Something like that.
09:01:59 <chpatrick> is it possible to use Data.Constraint.Forall with multiple parameters?
09:02:08 <chpatrick> ie forall a b. p (f a b)
09:02:47 <hsk3> Let's say I do this in my stack.yaml:
09:02:47 <hsk3> ---
09:02:49 <hsk3> packages:
09:02:51 <hsk3>     - location: .
09:02:52 <hsk3>     - location:
09:02:53 <hsk3>           git: https://github.com/myGitHubUser/bytestring
09:02:55 <hsk3>           commit: 2ca401234abcc95f0a1234cf786d42fd0abc39d8
09:02:56 <hsk3>       extra-dep: true
09:02:57 <hsk3> ---
09:02:58 <hsk3> Will Stack now always use this bytestring in my own repository instead of the bytestring on Hackage?
09:03:51 <sm> yes
09:06:45 <hsk3> sm: so it only looks at the package name (not the version) and prefers those given in "location:"?
09:07:27 <sm> hsk3: that's my guess, #haskell-stack might know more.
09:07:49 <hsk3> ok, i'll ask there too.
09:07:54 <sm> or you could test it
09:20:50 <kuribas> I get an error when compiling haste: http://lpaste.net/257712
09:24:01 <infandum> Lenses are a bit confusing. How can I parse, using Data.Aeson.Lens, a JSON value that has basically "object -> object -> [object]"? So far "preview (key "key1" . key "key2" . _Array)" gives me a vector of objects, but all of those objects have the same one key, so how can I just get a vector of strings or even better a maybe value after filtering for a string that is the item?
09:24:37 <infandum> like an "fmap" of "key "key3""?
09:24:41 <infandum> then a filter?
09:24:43 <infandum> all lensified
09:33:22 <a3gis> Hi! Is there a nice way in Haskell to represent an AST which has the following properties: some functions should be able to take an arbitrary AST node as an argument and operate on it. Some functions should be able to take a specific tyep of node (e.g. an operator node) and operate on it, and some functions should be able to take a specific group of nodes (e.g. a Term, which would be either a Variable or a Function) and operate on it
09:33:26 <a3gis> All that in a type-safe manner
09:33:56 <a3gis> Basically I am looking for an equivalent of what inheritance gives you in OOP langs
09:33:56 <grantwu> sounds like you want refinement types :P
09:35:41 <a3gis> grantwu: mmh, I'll take a look, thanks!
09:35:50 <a3gis> is there a less fancy way to achieve it?
09:36:14 <grantwu> I don't know, to be honest :/
09:36:37 <grantwu> Hard to say more without knowing more about this AST
09:37:03 <lyxia> Plated traversals are pretty useful to manipulate ASTs concisely. 
09:38:26 <lyxia> Or recursion schemes. 
09:46:30 <anti-psychiatry> Hi
09:46:49 <anti-psychiatry> Fuck "Israel" !!!!!!!!!!!!!!!
09:47:08 <anti-psychiatry> They attack me with chemicals!!!!!!!
09:47:15 <anti-psychiatry> In my mother home
09:47:18 <infandum> ...
09:47:29 <infandum> Is this #haskell?
09:47:44 <anti-psychiatry> In Ramat Gan
09:47:47 * hackagebot http-conduit 2.2.3 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.2.3 (MichaelSnoyman)
09:48:21 --- mode: ChanServ set +o geekosaur
09:48:29 --- mode: geekosaur set +b *!*50f68b4c@gateway/web/cgi-irc/kiwiirc.com/ip.80.246.139.76
09:48:29 --- kick: anti-psychiatry was kicked by geekosaur (anti-psychiatry)
09:48:39 <MarcelineVQ> It's always something new and interesting with that guy
09:48:47 <geekosaur> they will be back of course with a new IP
09:49:12 --- mode: geekosaur set -o geekosaur
09:56:29 <danza> has anybody here used propellor? Thoughts?
09:57:05 <Cale> I haven't used it, but I looked at it and thought it looked cool
09:57:07 <maerwald> danza: little distro support yet and no runtime tests
09:57:25 <maerwald> the latter is a complicated problem though, not sure if other solutions do that
09:57:43 <maerwald> but it's possible
09:57:53 <danza> what do you mean by runtime tests?
09:58:26 <maerwald> broken configuration, obviously
09:59:42 <danza> hum okay, thanks for the feedback! With which other solutions are you comparing? Ansible? Or Chef/Puppet?
10:07:01 <MajorKong> Hello! Recently found "Learn you a Haskell", gonna dive in. What's the general opinion on that?
10:07:28 <johnw> MajorKong: I thought it was a lot of fun to read
10:07:39 <johnw> it's how I learned functional programming
10:07:54 <geekosaur> it's fun, but you really need some exercises to go with it or you will be left able to read but not write Haskell
10:08:00 <MajorKong> Cool beans
10:08:10 <johnw> heh, I was just typing what geekosaur now said :)
10:08:20 <danza> i loved it and it gave me a lot of passion for learning more
10:08:24 <mmaruseacph2> hi, does anyone know how to get hp2ps on a mac using stack?
10:08:30 <mmaruseacph2> (in case anyone needed that before)
10:08:37 <sm> danza: found it a little underdocumented
10:09:17 <danza> me not ... it's full of doc elsewhere ... it helped me to dive into a complex topic, with a lighthearted approach
10:09:52 <sm> (propellor, I mean)
10:09:52 <geekosaur> mmaruseacph2, hp2ps is tied to and comes with a specific ghc version
10:09:59 <danza> :D
10:10:11 <geekosaur> if you installed ghc via stack then it should have an associated hp2ps (try "stack exec -- hp2ps ...")
10:10:19 <geekosaur> otherwise you can't get it using stack
10:10:31 <mmaruseacph2> I imagined that, but it seems it cannot find it :(
10:11:14 <geekosaur> hm. in that case you probably want to file a stack issue, maybe they are omitting it for some specific reason
10:11:17 <mmaruseacph2> ignore that, typo on my side (did --hp2ps)
10:11:22 <geekosaur> oh
10:11:39 <mmaruseacph2> first tried stack hp2ps then just added -- and didn't look
10:11:40 <geekosaur> the -- there just stops stack from eating options you intended for hp2ps
10:11:56 <shanemikel> I'm having a ssl cert problem with the wiki...
10:12:03 <geekosaur> (gnu style permute options are ... annoying)
10:12:17 <geekosaur> shanemikel, it's the same cert issue they're discussing in #macports
10:12:37 <mmaruseacph2> yep, I know that, I've been using it
10:12:43 <mmaruseacph2> thanks
10:13:10 <shanemikel> geekosaur oh.. this is where I see you
10:13:31 <geekosaur> yeh I had thought this was it but when you mentioned it over there I checked here and didn't see you...
10:14:33 <geekosaur> anyway: if you are on OS X and getting cert verify errors, ugly hackaround is: sqlite3 ~/Library/Keychains/*/ocspcache.sqlite3 'DELETE FROM responses WHERE responderURI LIKE "%http://ocsp%.globalsign.com/%";'
10:14:47 <geekosaur> see https://twitter.com/globalsign/status/786505261842247680
10:15:03 <geekosaur> (Apple caches the bad responses)
10:17:14 <shanemikel> no kidding.. that is ugly
10:29:14 <haskell188> Hi guys
10:29:26 <haskell188> I need to install
10:29:44 <haskell188> graphics ui gtk on mac
10:29:53 <haskell188> but i don't know how to install it 
10:30:29 <haskell188> I already download this package but how to install it? 
10:30:35 <haskell188> :S
10:31:23 <geekosaur> you need to get gtk libs from somewhere (macports/homebrew/fink), then cabal/stack install gtk2hs-buildtools (separately!), then cabal/stack install gtk
10:32:50 <bollu> quick question
10:33:17 <bollu> how does one show the equivalence between applicative parsers and context free grammars? and monadic parsers and context sensitive grammars?
10:33:35 <jay72> that doesn't seem like a quick question
10:34:00 <bollu> well, I was hoping it was written down somewhere
10:34:13 <bollu> intuitively I see how it's true
10:34:15 <bollu> but to prove it
10:34:37 <bollu> I should be able to give a push down automata / CFG and there should be some automated way to generate the applicative parser
10:34:54 <bollu> Cale, johnw, ReinH… ^
10:34:56 <jay72> way over my head :)
10:35:20 <johnw> a monadic parser can vary parsing based on something parsed previously
10:35:37 <johnw> b <- identifier; if b == "foo" then octDigit else hexDigit
10:35:39 <bollu> johnw: yeah, intuitively I understand why :) But I want a proof by construction
10:35:42 <johnw> an applicative parser cannot do this
10:36:04 <haskell188> geekosaur: It means...I need use terminal to do that?
10:36:09 <johnw> then write the proof :)
10:36:09 <c_wraith> bollu, the trivial translation of cfg to parser requires Alternative, not just Applicative
10:36:25 <bollu> johnw: heh, okay
10:36:29 <c_wraith> bollu, once you have that, it really is a trivial translation. 
10:36:29 <bollu> c_wraith: ah, right, for choice
10:36:33 <bollu> I see
10:36:39 <geekosaur> haskell188, yes? nobody has written a gui for haskell package installation
10:36:40 <bollu> c_wraith: you just jot the grammar down?
10:36:48 <c_wraith> bollu, exactly 
10:37:22 <bollu> hm, I see
10:37:25 <jay72> johnw: that was really clear, thanks
10:37:42 <geekosaur> and the 3rd party mac package services are all command line based (there is an old GUI for macports but it doesn't work on post-10.6)
10:38:38 <haskell188> geekosaur: So sorry man, but I still don't know what  I need to do :(
10:39:14 <kuribas> is there a function "([a] -> ([a], [a])) -> [a] -> [[a]]"?
10:39:29 <kuribas> @hoogle ([a] -> ([a], [a])) -> [a] -> [[a]]
10:39:32 <lambdabot> GHC.OldList mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:39:32 <lambdabot> GHC.OldList mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:39:32 <lambdabot> Music.Theory.Duration.Annotation zip_with_kr :: (a -> b -> c) -> [a] -> [b] -> ([c], [b])
10:42:17 <ph88> i have my code here which throws an exception and two different kind of traces with information but i don't understand them or how to debug the exception, can anyone help?  https://paste.fedoraproject.org/449671/14763804/
10:43:53 <johnw> bollu: I think parametricity is all you need to show that in f <*> x, x is unable to vary its action based on either the value or effects from f, whereas in x >>= f, f can vary on both the value and effects from x
10:44:05 <geekosaur> guh, that can't be traced without knowing the names the compiler assigned :(
10:44:07 <johnw> so this is more general than a parsing question
10:44:25 <bollu> I see
10:44:34 <bollu> johnw: what does "parametricity" mean?
10:44:40 <geekosaur> *but* that is not any normal exception. ph88, please file a ghc bug with that paste
10:44:44 <johnw> bollu: actually, in f <*> x it CAN vary based on effects from 'f', just not the value
10:44:52 <johnw> otherwise, State wouldn't work for <*>
10:44:57 <geekosaur> no wonder nobody can figure it out
10:45:07 <geekosaur> it looks like some internal thing
10:45:53 <dmj`> does this look like anything to anyone
10:45:54 <dmj`> class Class o m where f :: o -> m -> m
10:46:00 <johnw> bollu: parametricity here means: the argument types will determine behavior, the more general they are.  A function (forall a. a -> a) can have only one non-⊥ answer for a given input.
10:46:17 <ph88> geekosaur, i wouldn't know what to put in the ghc bug report
10:46:22 <bollu> johnw: ah, okay :) where does the terminology come from?
10:46:25 <johnw> dmj`: that's a semigroup action
10:46:27 <MarcelineVQ> :t ((\(x,y) -> [x,y]) .) -- kuribas: kinda ugly but without knowing what you're after it's hard to be pretty
10:46:28 <lambdabot> (a -> (t, t)) -> a -> [t]
10:46:36 <ph88> i feel defeated .. my first real haskell project is stuck on a ghc bug
10:46:36 <geekosaur> just put the paste. you can't really say anything else, and that's a big part of the bug
10:46:43 <ph88> alright
10:46:45 <geekosaur> it's not saying anything at all useful
10:46:48 <johnw> bollu: https://www.well-typed.com/blog/2015/05/parametricity/
10:46:54 <MarcelineVQ> :t ((\(x,y) -> [x,y]) .) `asAppliedTo` partition even
10:46:55 <lambdabot> Integral a => ([a] -> ([a], [a])) -> [a] -> [[a]]
10:46:59 <ph88> how can i get the currect compiler version ?
10:47:04 <geekosaur> even if it's a bug in your code, it's a bug that ghc is not reporting something useful
10:47:07 <geekosaur> ghc --version
10:47:09 <johnw> dmj`: https://hackage.haskell.org/package/monoid-extras-0.4.2/docs/Data-Monoid-Action.html
10:47:28 <ph88> geekosaur, but i use stack, i think ghc reports the wrong version
10:47:35 <geekosaur> stack exec -- ghc --version
10:47:38 <ph88> oki
10:47:40 <johnw> (or a Monoid action, depending on the constraints)
10:47:42 <geekosaur> (note space after first --)
10:47:48 * hackagebot exinst 0.2 - Derive instances for your existential types.  https://hackage.haskell.org/package/exinst-0.2 (RenzoCarbonara)
10:47:50 * hackagebot exinst-hashable 0.2 - Derive instances for the `hashable` library for your existential types.  https://hackage.haskell.org/package/exinst-hashable-0.2 (RenzoCarbonara)
10:47:52 * hackagebot exinst-deepseq 0.2 - Derive instances for the `deepseq` library for your existential types.  https://hackage.haskell.org/package/exinst-deepseq-0.2 (RenzoCarbonara)
10:47:53 <ph88> still 7.10.3
10:47:54 * hackagebot exinst-bytes 0.2 - Derive instances for the `bytes` library for your existential types.  https://hackage.haskell.org/package/exinst-bytes-0.2 (RenzoCarbonara)
10:47:56 * hackagebot exinst-aeson 0.2 - Derive instances for the `aeson` library for your existential types.  https://hackage.haskell.org/package/exinst-aeson-0.2 (RenzoCarbonara)
10:47:59 <ph88> maybe i should switch to ghc 8 ?
10:48:08 <geekosaur> quite possibly but it's still worth reporting
10:48:20 <ph88> ok
10:48:32 <ph88> how do i tell stack to start using ghc 8 on my project ?
10:48:35 <kuribas> MarcelineVQ: yeah something like that
10:48:49 <jay72> https://twitter.com/parametricity
10:48:49 <bollu> johnw: ty
10:48:53 <geekosaur> edit stack.yaml to set the resolver to one that uses ghc8, or specify the ghc-8.0.1 resolver
10:48:54 <jay72> not too active lately though
10:49:17 <geekosaur> the most recent lts and all nightlies since ghc8 was released use ghc8
10:49:39 <bollu> johnw: in what context is the theory of parametricity developed? type theory? if so, is there a book on it?
10:49:51 <ph88> i use this resolver: nightly-2016-07-07
10:50:05 <grantwu> lts-7.0 works
10:50:11 <johnw> bollu: when we say "parametricity" in this channel, we often mean something along the lines of "the type is general enough that any implementation you find is the proof you seek"
10:50:21 <johnw> bollu: parametricity arises from logical relations
10:50:41 <johnw> see www.cs.bham.ac.uk/~udr/papers/logical-relations-and-parametricity.pdf
10:50:43 <bollu> johnw: "logical relations" in the sense of..? 
10:50:47 <bollu> ooh, ty
10:50:58 <geekosaur> ghc8 was released august-ish so it makes sense that you'd still be getting ghc 7.10
10:51:18 <dmj`> johnw: interesting
10:51:22 <bollu> johnw: okay, so, like, due to using haskell, I've picked up bits and pieces of type theory and lambda calculus and whatnot. But, like, is there a "canonical" book on this stuff?
10:51:25 <geekosaur> ...I think, sigh, trying to recall stuff beyond brainfog :/
10:51:25 <johnw> a logical relation between types A and B is a propositional relation between them.  Where parametricity comes in is that the type establishes a family of relations, such that certain properties must be shared by all possible implementation of that type.
10:52:51 <johnw> that last PDF I linked gives pointers to most of the prior research which established this field
10:53:23 <jay72> echoing what johnw said earlier: https://twitter.com/parametricity/status/570868889619292161
10:53:29 <bollu> johnw: is it still active?
10:54:51 <johnw> is what still active?
10:55:21 <johnw> that field of research?
10:57:08 <dolio> The original idea behind parametricity was that a definition is uniform or all choices of type. The type is just an abstract parameter to the definition.
10:57:26 <dolio> The logical relations stuff tries to give a precise definition of what that idea is.
10:57:54 <johnw> if you search for the OLPSS videos, there has been an ongoing class on Logical Relations for several years now
10:59:19 <bollu> johnw: yes
10:59:28 <bollu> johnw: the field of research
10:59:28 <johnw> OPLSS
10:59:43 <bollu> johnw: also, you mentioned studying haskell from LYAH. So, like, when did you learn haskell?
11:00:19 <johnw> i mostly learned Haskell in 2012, after several failed attempts in years prior
11:01:27 <bollu> @free Int
11:01:28 <lambdabot> Try `free <ident>` or `free <ident> :: <type>`
11:01:35 <bollu> @free x :: Int
11:01:35 <lambdabot> x = x
11:01:37 <ph88> is there a haskell lib that reduce a program to create a minimized test case ?
11:01:39 <bollu> interesting
11:01:50 <bollu> @free x :: [Int]
11:01:50 <lambdabot> $map $id x = x
11:02:15 <johnw> ph88: maybe #ghc would know?
11:04:35 <fryguybob> ph88: This is at least related to what you want: http://dl.acm.org/citation.cfm?doid=2976002.2976003
11:05:55 <ph88> geekosaur, i was actually in the wrong directory ... my program was already on ghc 8.0.1 ^^
11:06:03 <geekosaur> ah
11:06:20 <geekosaur> then definitely report it, although if this turns out to be in HEAD it's going to cause some annoyance >.>
11:06:36 <ertes-t6v> bollu: i would call type theory canonical to develop parametricity
11:07:41 <ertes> bollu: but you can develop it in the context of set theory or other calculi as well…  it's just that with type theory you're already in the context of a programming language due to curry-howard
11:07:55 <bollu> ertes: hm, I see
11:08:01 <bollu> ertes: is there a link to this being done in set theory?
11:08:19 <coconuts_> hi or whatever
11:08:30 <ertes> bollu: none that i know of, but it's really simple: you parametrize over sets
11:08:37 <grantwu> oh no, the topic of discussion in #haskell is converging with the discussion in lecture ;C
11:08:40 <coconuts_> my friends code isnt working
11:08:51 <coconuts_> "hello" :: -> a _\_;|_:|s(a)
11:08:55 <ertes> bollu: sets and operations…  in that sense set-theoretic group theory is an instance of parametricity in set theory
11:09:06 <grantwu> coconuts_: What is your friend trying to do
11:09:07 <bollu> ertes: wait, what?
11:09:07 <glguy> coconuts_: What language is that?
11:09:14 <coconuts_> that is haskell, i think
11:09:17 <coconuts_> it looks likeit anyways
11:09:26 <Tuplanolla> It's not.
11:09:27 <ertes> bollu: if you say, "monoid", you assume no knowledge about what the set or the operation is, only that it's binary and associative
11:09:36 <coconuts_> he needs to put "hello" in a variable named a but then pipe it to stdout
11:09:40 <grantwu> It looks like they took some Haskell tokens and shoved them together
11:09:44 <bollu> ertes: oh, so an algebra over a set is a parametrisation?
11:09:45 <ertes> bollu: (+ identity)
11:09:46 <coconuts_> ah
11:09:49 <coconuts_> not sure then
11:10:08 <grantwu> "pipe it to stdout" seems to imply some sort of shell?
11:10:13 <coconuts_> y
11:10:14 <coconuts_> yes
11:10:39 <grantwu> I would try a different channel then, or asking your friend what exactly they're doing
11:10:47 <ertes> bollu: quantification is often hand-waved over in set theory (unfortunately), but if you try to express monoids in your favourite type-theoretic proof assistant, you will see all the parameters, and some of them are as abstract as you can get: "any type"
11:11:29 <ertes> bollu: together with the fact that you can't pattern-match on types, this gives you parametricity
11:11:53 <bollu> ertes: "together with the fact that you can't pattern-match on types" how does this influence parametricity?
11:11:57 <coconuts_> grantwu, He wants to print a to stdout
11:12:05 <ph88> hmm there are 12695 bugs before me
11:12:06 <grantwu> coconuts_: In haskell?
11:12:09 <coconuts_> Yes
11:12:13 <ertes> bollu: id {a} x = if a == Bool then False else x
11:12:30 <ertes> bollu: this would be a massive break to parametricity
11:12:36 <Tuplanolla> Is `print` too easy, coconuts_?
11:12:47 <coconuts_> he's one of those "low-level" guys
11:12:47 <grantwu> coconuts_: Is there any particular reason he needs to bind "hello" to a variable
11:13:02 <bollu> I see
11:13:16 <coconuts_> grantwu, yeah
11:13:30 <coconuts_> he wants to use it as a register to bind it to a coalicion block
11:13:33 <coconuts_> thats whwat he says
11:13:35 <glguy> coconuts_: Probably better to have your friend join instead
11:13:43 <coconuts_> ill tell him,
11:13:51 <Tuplanolla> You need to reconsider your friendship.
11:15:24 <grantwu> you can do main = let a = "Hello" in putStrLn a, but I doubt that's going to compile to anything different than the simpler form
11:15:58 <coconuts_> He says freenode sucks
11:16:17 <grantwu> Then he should go find some other source of help
11:16:32 <grantwu> And not ask you to bother us
11:16:43 <grantwu> Like, he's not only wasting our time, he's wasting yours
11:16:59 <ertes> bollu: that's why we don't have OOP-style reflection…  parametricity is the kind of reasoning you can do that arises from *lack* of information
11:17:14 <coconuts_> alright thanks
11:17:18 <ertes> if you could dynamically ask for the argument types, this reasoning would no longer be possible
11:18:18 <bollu> ertes: hm, interesting
11:19:09 <petrus> I am writing a Haskell program to filter/process huge (hundreds of Mbytes) log files read either from files or from stdin. For getting in the input I use "loglines <- fmap T.lines (T.hGetContents handle)", (T for Text). That seems to be an IO bottleneck of my program, is there a faster way to do this?
11:19:47 <grantwu> I don't know very much, but I heard Conduit is useful for processing large amounts of data in constant time
11:19:54 <shapr> yeah, I was going to say the same thing
11:20:03 <ertes> petrus: what are you comparing to?  grep?
11:20:14 <johnw> petrus: what you're doing now is the classic reason why libraries like 'pipes' exist
11:20:56 <petrus> ertes, no to the original python script
11:21:02 <ReinH> grantwu: constant space, maybe
11:21:03 <shapr> Pipes needs a lambda shaped Magritte pipe logo
11:21:04 <ertes> petrus: while you should use a stream processing abstraction as others have said, the code you just pasted doesn't look slow to me *per se*
11:21:14 <grantwu> ReinH: Oh... yeah :P
11:21:23 <ertes> s/pasted/showed/
11:21:57 <petrus> reading unicode this way is about 2,5 times slower then python3
11:22:05 <ReinH> Which T is that? Lazy?
11:22:20 <ertes> petrus: ok, then you will likely get the speed of the python program by not using Text
11:22:22 <petrus> ReinH, yes just the lazy
11:22:34 <ertes> oh, and i think lazy Text doesn't actually do lazy IO
11:23:19 <ertes> i'm wrong, it is lazy
11:23:36 <petrus> ertes, not really, also I need to deal with unicode 
11:23:52 <ertes> petrus: first step:  switch to stream processing
11:24:27 <ertes> use either conduit or pipes-text
11:24:54 <ggVGc> can someone recommend a book or other good resource for learning functional algorithms?
11:25:02 <petrus> johnw, etc I don't want to switch to conduit, pipes, yet ...
11:25:15 <johnw> petrus: it could be slow because of how much allocation it's doing, rather than reusing a small buffer step-wise the way a stream processor would do
11:25:16 <dolio> Step two: always follow advice from people who have only seen one line of your program.
11:25:20 <grantwu> have you tried profiling?
11:25:24 <shapr> ggVGc: Okasaki's book is fun, not sure if there's something more recent
11:25:26 <johnw> dolio: lol
11:25:44 <johnw> I guess it depends on the behavior of T.hGetContents here
11:25:45 <shapr> @remember dolio Step two: always follow advice from people who have only seen one line of your program.
11:25:45 <lambdabot> It is stored.
11:25:54 <ggVGc> shapr: cheers, I'll check it out
11:25:56 <petrus> I'd like to understand what's the problem, and keep the dependencies minimal
11:26:02 <ertes> hehe
11:26:09 <johnw> petrus: that's actually quite a laudable goal
11:26:48 <johnw> petrus: perhaps could you download the 'text' library, enable profiling within it (add -prof -fprof-auto to the .cabal file), build your application with profiling, and then see where the time is being spent
11:26:53 <ertes> petrus: unfortunately noone can be told what the problem with hGetContents is…  you have to see it for yourself =)
11:27:15 <grantwu> oh no
11:27:41 <grantwu> hrm, is it because it's read on demand?
11:27:54 <petrus> re: one line of program - I did profiling, I am happy with the processing components bu is surprised with the reed in part
11:28:30 <grantwu> maybe try strace
11:28:52 <ertes> petrus: you could try to implement a processing loop yourself and see how it compares…  it'll most likely be faster
11:29:01 <petrus> johnw, is see extend the profiling into Text ... hmm
11:29:28 <grantwu> I don't know how hGetContents works, what size read syscalls does it issue?
11:31:22 <tabaqui> why i cannot export data constructor?
11:31:26 <tabaqui> i have
11:31:38 <tabaqui> module Foo (bar) where
11:31:44 <johnw> you can export it as Foo (TypeName(bar))
11:31:47 <tabaqui> *module Foo (Bar) where
11:32:00 <johnw> or export them all with Bar(..)
11:32:19 <tabaqui> typename?
11:32:22 <tabaqui> hm
11:32:29 <johnw> by default, if you give only the type name, then only the type and its instances are exported, not the constructors
11:32:48 <monochrom> if you have "data X = Y", you export Y by "module M(X(Y))" or "module M(X(..))"
11:33:02 <johnw> yeah, what monochrom said
11:33:10 <monochrom> if you just say "module M(X)" then Y is not exported
11:33:33 <monochrom> if your type is "data X = X" then you're confusing yourself.
11:34:02 <tabaqui> with double dots it works
11:34:05 <tabaqui> thanks
11:41:31 <[exa]> Hm guys, having studied THIH, haskell report, wiki page on the topic and some random discussion on the nets, I have to ask
11:41:41 <[exa]> what's the monomorphism restriction really good for?!
11:42:09 <srhb> [exa]: The wiki tells you about the sometimes surprising performance implications, does it not?
11:42:13 <geekosaur> preventing an unexpected memory leak
11:42:18 <srhb> [exa]: But other than that, just confusion.
11:42:55 <geekosaur> basically, this is the dark side of the memoization trick
11:44:06 <Tuplanolla> I'd like to see examples of the problem that haven't been constructed with the problem in mind.
11:44:30 <dolio> Even constructed examples sometimes don't actually illustrate the problem.
11:44:46 <geekosaur> nless you already know what to look for
11:44:52 <dolio> Because GHC does optimizations that defeat them.
11:44:54 <geekosaur> in which case you don't need the example
11:45:41 <dolio> Like, if you try a 'fibs = ...' example, I think GHC will factor out the type class parameterization by noticing that the corecursion is at the same type.
11:47:11 <dfeuer> Are Fibonacci numbers actually useful?
11:47:26 <Tuplanolla> I guess I have been really lucky, because I always turn the restriction off, but haven't noticed any of its downsides in three years.
11:47:49 * hackagebot exhaustive 1.1.3 - Compile time checks that a computation considers producing data through all possible constructors  https://hackage.haskell.org/package/exhaustive-1.1.3 (OliverCharles)
11:47:57 <geekosaur> I have actually seen it (in a question raised here!) but only once
11:48:15 <cobra1984> ciao
11:48:19 <geekosaur> possibly it is time for ghc to disable it by default; iirc it already does so in ghci
11:48:21 <cobra1984> !list
11:48:46 <Tuplanolla> That's indeed true.
11:49:00 <dfeuer> It's most likely to be a problem if things don't specialize enough. For instance, if a sufficiently complex numerical function isn't marked INLINABLE and isn't used with Int in the defining module.
11:49:32 <geekosaur> the MR could well be in the same class of haskell98 oopses as fail and overspecialization to lists
11:49:41 <dfeuer> I think it's definitely time to disable it. It was premature optimization from before there was such a thing as an optimizing Haskell compiler, I believe.
11:49:47 <geekosaur> that said, when it *does* show up it's something of a nasty screw case
11:50:20 <dfeuer> It's mostly a nasty screw case in the other direction.
11:50:38 <dolio> The monomorphism restriction isn't a Haskell 98 thing.
11:50:45 <dolio> Some form of it goes back to 1.0.
11:50:54 <dolio> Although it was weirder originally.
11:50:57 <dfeuer> Yeah, back in the dark ages.
11:52:50 <srhb> When functors were still hand cranked.
11:53:07 <dolio> It makes somewhat more sense when your compiler isn't able to work around the problems it's supposed to address, too.
11:53:28 <Tuplanolla> When you had to get out or go all-in with `-fglasgow-exts`.
11:53:36 <dfeuer> If someone wants something like MR, I think it should be much harsher. Anything defined at the top level that's polymorphic and has class constraints should simply be a type error, given -XSpecializationParanoia
11:53:52 <mekeor> Q: is there a package offering a function which parses a string containing an arithmetic expression and returns the result of it? that is, a calculator package? (it should support whole and floating numbers, +,-,*,/,^, and paranthesis at least)
11:54:52 <Tuplanolla> How about `-XTypicalCProgrammer` that turns all polymorphic types into `Int`?
11:55:21 <dfeuer> mekeor, parsing and calculating are quite unrelated.
11:55:25 <dfeuer> Tuplanolla++
11:55:35 <dfeuer> That's hilarious.
11:55:57 <Tuplanolla> Yes, mekeor. Megaparsec has an expression parser for that.
11:56:01 <mekeor> dfeuer: okay. i just want a calculator function :: String -> Number
11:56:10 <dfeuer> Tuplanolla, or maybe just turns all *types* into Int#, and wraps everything in unsafeCoerce#?
11:56:38 <Tuplanolla> That's too sophisticated, dfeuer.
11:57:23 <dfeuer> Tuplanolla, it's not sophisticated; it's super-simple. Everything passes the type checker, and most thing segfault. Just like C.
11:57:40 <dfeuer> :P
11:57:51 <dfeuer> (I know it would actually be hard to implement. But most jokes are.)
11:59:13 <int-e> there should be a few type errors for entertainment... "expected `Int' but got `Int'"
11:59:37 <dfeuer> :)
12:01:39 <Tuplanolla> Off to write a proposal then!
12:01:43 <ReinH> dfeuer: it's annoyingly hard to reason about typeclass polymorphism when doing numerical stuff
12:02:30 <dfeuer> ReinH, that may be, but as far as I can tell, MR doesn't help and explicit type signatures do.
12:02:47 <ReinH> Like, will this generate the slow core that does fromIntegral everywhere or the fast one that uses Int#? Would specialization help?
12:02:52 <dfeuer> Including ScopedTypeVariables.
12:02:53 <Tuplanolla> Does SPECIALIZE help with that?
12:03:03 <ReinH> I think I'm agreeing with you
12:03:06 <dfeuer> OK.
12:03:40 <Tuplanolla> I've never used it, but I'm starting to feel like I should have.
12:03:52 <dfeuer> Although ScopedTypeVariables introduces its own efficiency problems in cases where the dictionary needs to be passed around at runtime
12:04:01 <ReinH> I think it can, haven't fully grokked it yet
12:04:06 <dfeuer> The constant argument transformation isn't always good. :-(
12:04:21 <dfeuer> So you need to turn on ScopedTypeVariables, and then use it judiciously.
12:05:09 * dfeuer hates how some seemingly-aesthetic changes can affect performance substantially.
12:06:22 <ReinH> dfeuer: my use case right now is wanting to abstract over word size and it's frustrating. :)
12:06:58 <dfeuer> :/
12:07:14 <ReinH> I basically have to write the same thing n times
12:07:20 <dfeuer> AFAICT, INLINABLE usually beats SPECIALIZE.
12:07:35 <ReinH> I might try that, thanks
12:08:01 <dfeuer> Yeah, if TH were comprehensible to mere humans, and if it staged its imports like Racket, then that could be a good answer.
12:08:09 <ReinH> Heh
12:08:28 * dfeuer has attempted to understand some TH, but it keeps looking like line noise :-(
12:08:37 <ReinH> Same
12:10:56 <mmaruseacph2> I have somewhere in my code a `liftIO $ quickQuery ...` (using Database.HDBC.PostgreSQL) and if I compile with profiling that returns 0 out of the 1M tuples I was expected to get
12:11:00 <mmaruseacph2> is this a known bug?
12:11:03 <dmj`> and every new GHC breaks TH code :/ in some way
12:12:53 <mmaruseacph2> I should get a minimal version showcasing it and posting it on trac
12:13:03 <maerwald> if you like idiomatic haskell, you don't like TH
12:13:31 <acowley> If I've done a "stack build" of a project, how should I get myself into a GHCi session in which I can import modules from that package without recompiling them as "interpreted"?
12:14:17 <dmj`> I like generics
12:14:22 <dmj`> there, I said it
12:14:23 <mmaruseacph2> acowley: I'm doing stack ghci
12:14:32 <Tuplanolla> TH is one of those things that make me long for Scheme. Interpreting or compiling Haskell at runtime is another.
12:15:02 <dmj`> generics requires you to have an already declared data type though
12:15:03 <acowley> mmaruseacph2: That's what I thought would work. It may be that this package is doing too much funny business
12:15:15 <mmaruseacph2> stack repl then?
12:15:31 <mmaruseacph2> I still don't know the full diferences between the two
12:16:11 <johnw> dmj`: once you like generics enough, don't you then like everything? :)
12:16:46 * Clint groans.
12:22:31 <dominik_> anyone knows why in my WAI application I keep getting the following warp warnings: "Warp: Client closed connection prematurely" ?
12:26:48 <zipper> Anyone know how I can install ghc 7* on arch?
12:27:05 <zipper> and cabal no stack
12:27:11 <tswett> Is there a word for a function whose right-hand side consists entirely of parameters and fully applied data constructors? For example—
12:27:13 <Tuplanolla> Does AUR have it, zipper?
12:27:42 <tswett> f x y z = (Left x, Left y : Right z : x)
12:27:57 <zipper> Tuplanolla: Can't see it
12:28:54 <hexagoxel> zipper: just use the bindist and install libtinfo backwards-compat aur stuff until it works :p
12:28:59 <Tuplanolla> It should, zipper.
12:29:37 <MarcelineVQ> aur/ghc7.10
12:29:55 <MarcelineVQ> also .8 and .4
12:31:37 <Tuplanolla> You should be able to replace PPA with AUR and follow these instructions, zipper: http://users.jyu.fi/~sapekiis/install-ghc/
12:32:13 <zipper> Tuplanolla: Yeah I shall try what I found in the AUR
12:35:22 <shapr> Is FGL still the best graph library for Haskell?
12:35:32 <johnw> shapr: I like it
12:36:00 <grantwu> I think dfeuer said he wished there was something better
12:36:08 <johnw> well, that can always be said
12:36:21 <erisco> and anyone can say it ^.^
12:36:39 <dfeuer> I think it has a lot of good ideas.
12:36:49 <dfeuer> But it lacks polish.
12:37:05 <dfeuer> I think it could use a super-major version bump to a more modern feel.
12:37:06 <shapr> ok, so what's the best tutorial for FGL?
12:37:14 <dfeuer> Dunno.
12:38:55 <dfeuer> It also should take advantage of more IntMap specials, which might well happen.  https://github.com/haskell/fgl/pull/48
12:43:34 <Hard-Dev> The demo is free to download and play! The full version is very very cheap, please buy it! It will payback all my sweat and blood and tears and tribulations...
12:43:34 <Hard-Dev> https://ng-developer.itch.io/nitrux
12:45:10 <MarcelineVQ> If you're serious you should say what a thing is before asking for support for it. You won't get much attention with a blind link. This isn't the place for that anyway though.
12:45:19 <hpc> @where ops
12:45:19 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
12:45:30 --- mode: ChanServ set +o dcoutts
12:46:04 <maerwald> dcoutts: he did that in #freenode too, so he probably gets a proper ban anyway :P
12:46:30 --- mode: ChanServ set +o glguy
12:46:30 --- mode: glguy set +b *!*@2-229-33-39.ip194.fastwebnet.it
12:46:31 --- kick: Hard-Dev was kicked by glguy (spam)
12:46:39 --- mode: ChanServ set -o dcoutts
12:46:41 <glguy> Second time in #haskell
12:47:44 <MarcelineVQ> kinda looks like the dos games I used to play :> slightly higher res
12:47:51 * hackagebot obd 0.1.0.0 - Communicate to OBD interfaces over ELM327  https://hackage.haskell.org/package/obd-0.1.0.0 (hverr)
12:48:10 <dfeuer> Spamming #freenode? That's a hoot.
12:48:21 --- mode: glguy set -bbo *!*521c9b26@*.82.28.155.38 *!*521c9b26@*.82.28.155.38 glguy
12:48:28 <Tuplanolla> I wonder how good the return of investment is.
12:48:37 <erisco> oh, it is a clone of Neverball
12:48:45 <glguy> Dunno, but it's off-topic in #haskell
12:49:07 <dfeuer> But the user still exists, surprisingly.
12:49:24 <erisco> Tuplanolla, pants
12:50:24 <Tuplanolla> Freenode isn't exactly known for people who are easy to trick into buying your garbage du jour.
12:50:51 <ertes> that said, you're still talking about it
12:51:08 <ertes> if they were a troll, they would have been somewhat successful
12:51:13 <hpc> that's the power of advertising
12:51:20 <hpc> this website is going to be the next facebook, i tell you
12:52:17 <bollu> hpc: which website?
12:52:29 <hpc> exactly
12:55:47 <kori> Ha
12:56:54 <sbrg> hpc: now you've gotten people to ask questions about your website. everyone's interested. next step: global market domination. 
12:57:45 <ertes> bollu: congratulations, you've just become everyone…  please represent me faithfully
12:57:54 <geekosaur> "look upon my works, ye mighty, and despair"
12:58:27 <bollu> xD
13:01:39 <ertes> bollu: would you kindly say, "-XGADTs, -XKindSignatures, -XScopedTypeVariables and -XTupleSections must be standard", for me, please?
13:02:41 <glguy> ertes: I think you could potentially get 3 of those
13:02:58 <ertes> glguy: the latter three?
13:03:07 <infandum> What's everyone's opinion on batteries included preludes?
13:03:28 <sm> that's what a prelude is
13:03:32 <sm> batteries
13:03:34 <ertes> infandum: where's your threshold of "batteries included"?
13:03:38 <sbrg> I think we just established that bollu is everyone. so bollu?
13:03:55 <bollu> ertes: multi param type classes? type families? GADTS? :)
13:04:11 <bollu> ertes: what's kind signatures?
13:04:12 <geekosaur> welp. bollu is about to become the target of every language lobbyist out there >.>
13:04:15 <geekosaur> nice knowing you
13:04:37 <ertes> bollu: data F :: * -> * where …
13:04:37 <infandum> ertes: Anything. Anything more than the default prelude
13:05:03 <bollu> heh, I hope to use my newfound power to ask the question: what is applicative category theoretically? monad is monoid of endofunctors, so what's Applicative?
13:05:16 <erisco> and -XIncoherentInstances
13:05:41 <ertes> infandum: as you include more battieries you increase the potential for controversy…  the standard Prelude is controversial already
13:05:44 <glguy> Instead of turning on -XIncoherentInstances, it's better to use the {-# INCOHERENT #-} pragma on particular instances
13:06:48 <ertes> bollu: if you don't know, nobody knows
13:07:08 <bollu> ertes: :P omg please
13:07:21 <ertes> not so great being everyone after all, is it? =P
13:07:57 <laudiacay> so i have a function :: a -> b -> bool. I have a list of a's, and a single b that i need to pass to all of them. How would i get the resulting list of bools?
13:08:21 <ertes> laudiacay: you would use 'map'
13:08:43 <ertes> laudiacay: map (`function` theB)
13:08:44 <pyrtsa> `flip` might help too.
13:08:47 <laudiacay> ertes: yes, i can map the function to the list, but then i have a list of functions 
13:08:52 <laudiacay> ohhhh i forgot about those
13:08:53 <laudiacay> thanks dude
13:09:08 <ertes> laudiacay: or equivalently:  map (\theA -> function theA theB)
13:09:08 <JonReed> Hm, what is normally the way to read fixed size serialized data from a file. I have an instance of Serialize MyData. Now I want to read MyData from a handle. However, ByteString.hGet requires size, which, in a sense, already encoded in the Serialize instance, so do I have to specify the size twice or there is some trick to read only MyData and seek handle automatically afterwards?
13:10:17 <glguy> JonReed: Serialize can work on chunks of data, so you can read the file by chunk as the deserializer tells you that it needs more input
13:10:37 <laudiacay> ertes: slight extension of this... i'm having a parenthesis problem lol! 
13:10:48 <glguy> JonReed: Also you can ask for more data than there is in the file, or you can query how big the file is and load it all at once
13:11:00 <ertes> laudiacay: what do you mean?
13:11:10 <laudiacay> and.(map (\lseg -> intersects lseg a)) lss, where lss is the list of arguments, and intersects is that function i was talking about
13:11:23 <infandum> ertes: Yeah, but it's so much more convenient
13:11:26 <laudiacay> a is the b from the previous example, the argument already in scope
13:11:35 <laudiacay> who shouldn't that work?
13:11:35 <infandum> I don't use them, but I think it would be nice to
13:11:36 <ertes> laudiacay: apply this syntactic rule:  (f x) y = f x y
13:11:44 <laudiacay> ertes: i think i am
13:12:12 <laudiacay> the map is parenthesized together with the lambda, then the list comes after
13:12:15 <ertes> oh, i didn't see the 'and'
13:12:17 <JonReed> glguy: Ok. Thx. I'll try to find the right function in the Serialize package then
13:12:19 <ertes> uhm
13:12:25 <laudiacay> once the map is applied, the and should apply after right?
13:12:33 <JonReed> glguy: I've only used `decode` so far.
13:12:35 <ertes> laudiacay: i think you don't want a dot there
13:12:53 <laudiacay> ertes: should i just parenthesize all the map and list stuff away from the and
13:13:21 <ertes> given the list of booleans, map yourF yourList, you want to apply 'and' to it:  and (map yourF yourList)
13:13:29 <laudiacay> omfg it compiled
13:13:34 <laudiacay> TYSM
13:13:49 <laudiacay> i am still doing the struggle thing with haskell syntax...
13:14:11 <glguy> JonReed: Is this relevant to you: hGetContents :: Handle -> IO ByteString
13:14:28 <ertes> laudiacay: the syntax, while being unconventional compared to other languages, is actually really simple and natural…  there are a few rules you need to learn, then you should be able to parse any haskell program you see
13:15:29 <johnw> is there a good way these days to turn a Haskell 98 program into C?
13:15:51 <sa-begin_>  http://pastebin.com/tfs7cBVD. Is there anyway to avoid type annonation in aPrint a = putStrLn $ show $ k (a::A) ?
13:16:03 <JonReed> glguy: Will it read the bytestring lazily or the whole file into memory?
13:16:49 <erisco> sa-begin, aPrint = putStrLn . show . k
13:16:56 <MarcelineVQ> sa-begin_: don't use the same name for both records? :>
13:16:59 <thoughtpolice> johnw: JHC. Probably works fine if you are only using H98.
13:17:08 <laudiacay> ertes: it
13:17:16 <laudiacay> *it's been 2 weeks, i'm getting there :)
13:17:18 <johnw> thoughtpolice: great, thanks!  I was asked what the easiest way was to turn Coq into C, like this week
13:17:35 <erisco> isn't the aPrint type sufficient for GHC?
13:17:40 <MarcelineVQ> It should know it's an A though is there actually a conflict?
13:18:10 <glguy> JonReed: Depends which one you use, the one for strict bytestrings reads strict bytestrings
13:18:35 <thoughtpolice> johnw: Although, the John's server hosting JHC is down right now. :( I'm not sure if there are any other good methods to extract Coq into C, either directly or indirectly. Maybe if you used Scheme extraction and one of the billion Scheme -> C compilers, too.
13:18:59 <sa-begin_> no. it gives a  Ambiguous occurrence ‘k’ if I remove the the type annotation
13:19:11 <johnw> thoughtpolice: continued in PM...
13:19:20 <erisco> sounds like a lousy extension then
13:19:29 <erisco> also,  aPrint = print . k
13:19:34 <bollu> does Coq have a set theory written in it?
13:19:40 <sa-begin_> MarcelineVQ wasn't the point of extension to allow duplicate record names
13:19:42 <ertes> bollu: type theory
13:19:55 <bollu> ertes: ?
13:20:11 <bollu> ertes: I wanted to encode a couple of things we're doing in my number theory class
13:20:26 <ertes> bollu: what exactly?
13:20:33 <johnw> bollu: several
13:20:36 <bollu> ertes: what I want to encode?
13:20:44 <bollu> ertes: uh, reciprocity and things like that
13:20:54 <ertes> bollu: although it doesn't matter…  any modern proof assistant can handle number theory
13:21:06 <JonReed> glguy: Lazy one. Let's say I'll run lazyDecode on it inside a Conduit. Each time it decodes one MyData and then yields MyData to be processed and does it chunk by chunk. Will it garbage collect the head of the lazy ByteString?
13:21:14 <bollu> ertes: hm, but, isn't peano arithmetic + first order logic undecidablw?
13:21:49 <johnw> bollu: the "omega" tactic and "firstorder" will handle those for you pretty well
13:23:00 <ertes> bollu: i'm not really experienced in FOL, but inductive type theory should handle really any proof on peano numbers
13:23:30 <JonReed> glguy: I mean will it do it in a FIFO style, where it reads one chunk of a lazy bytestring , garbage collects the chunk before it. Or will it eventually accomulate the whole bytestring into memory? 
13:23:36 <bollu> johnw: cool, thanks
13:23:50 <bollu> johnw: is there like a simple tutorial for this? I've only encoded things by myself from scratch
13:23:54 <glguy_> JonReed: If you read a strict bytestring you won't get a lazy bytestring
13:23:57 <bollu> johnw: like, from software foundations
13:24:11 <glguy_> if you want the lazy bytestring behavior you can use that instead
13:24:13 <johnw> bollu: I'm not sure if SF ever uses the more advanced tactics; I'd ask Google
13:25:05 <zq> :t (<=<)
13:25:06 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
13:25:21 <bollu> johnw: hm
13:25:34 <Tuplanolla> SF uses `omega` occasionally, johnw.
13:25:54 <johnw> Tuplanolla: ah, good to know
13:26:08 <Tuplanolla> It's in Hoare and partial evaluation.
13:26:56 <bollu> what theory does z3 use internally?
13:27:01 <bollu> is there a theorem prover that uses HoTT?
13:27:08 <bollu> I want to learn HoTT with a theorem prover
13:27:11 <bollu> is that a stupid goal? :P
13:27:24 <johnw> it's not stupid, but at some point will take you outside of #haskell :)
13:27:25 <Tuplanolla> It's a tedious goal.
13:27:44 <josephle> bollu, you can encode HoTT into proof assistants, although it is tedious
13:27:44 <johnw> there's also #coq, ##typetheory, ##hott
13:27:45 <JonReed> Anyway, I realized that I'll need to encode size of MyData anyway, because I'll want to calculate size and print it later. So, I'll just use hGet for sanity that has explicity argument for the size to read.
13:28:02 <dfeuer> Also #agda
13:28:37 <bollu> josephle: I see. But, like, aren't there proof assistants that start with HoTT?
13:28:46 <johnw> there's CoqHoTT
13:28:53 <Tuplanolla> You should go ask the people who made the Coq plugin for it, bollu.
13:28:55 <johnw> which is an attempt to change the underlying meta-theory of Coq to use HoTT
13:29:07 <bollu> I see
13:29:08 <ertes> apparently there is also this cubicaltt thing, but i have no idea how useful it is
13:29:28 <dfeuer> Isn't a lot of HoTT computational stuff made of open problems?
13:29:32 <johnw> I thought cubicaltt was the "new hotness" for computable approachs to HoTT, but that info may be old already
13:29:35 <maerwald> bollu: do you know about F*?
13:29:36 <ertes> dfeuer: yeah
13:29:41 <bollu> maerwald: no
13:29:52 <thoughtpolice> bollu: Lean has support for HoTT out of the box with a separate standard library, including support for many of the things in e.g. cubicaltt.
13:29:55 <maerwald> bollu: https://www.fstar-lang.org/papers/mumon/paper.pdf
13:30:01 <bollu> doesn't lean have HoTT?
13:30:19 <ertes> johnw: the way i understood it, it also attempts to create a reasonable syntax for HoTT
13:30:45 <thoughtpolice> However, the alternative HoTT prelude doesn't work in the new version, Lean 3, which is seemingly a total rewrite, and where most of the development is. I do know the stable version of Lean is very usable, though.
13:30:57 <bollu> argh, damn
13:31:02 <thoughtpolice> The traditional CIC in Lean 3 does work, though.
13:31:07 <bollu> I tried reading the HoTT book
13:31:16 <thoughtpolice> But I would just use the stable version anyway, lean3 has many, many missing pieces.
13:31:24 <Tuplanolla> That's the way people usually phrase it, bollu.
13:31:35 <bollu> Tuplanolla: ?
13:31:42 <Tuplanolla> You don't read the book.
13:32:00 <bollu> but..?
13:32:01 <Tuplanolla> You try reading it.
13:32:06 <josephle> hahahahaha
13:32:18 <bollu> Tuplanolla: :P Cale's read the entire thing, as have a couple others on #haskell, right?
13:32:26 <dfeuer> josephle = jle` ?
13:32:44 <dmj`> dfeuer: nah
13:32:46 <josephle> dfeuer: this gets asked every so often, but no
13:32:53 <dfeuer> Sorry.
13:33:38 <josephle> bollu: you can try https://github.com/RobertHarper/hott-notes
13:33:50 <josephle> unclear if more approachable than the book
13:34:07 <josephle> but these are the notes for a HoTT class I took a while ago
13:34:19 <bollu> thanks
13:34:36 <ertes> bollu: the HoTT book is surprisingly easy to read actually…  if you want to read it, go ahead
13:35:22 <bollu> ertes: what's the pre-requisites it wants?
13:35:35 <ertes> bollu: basic higher category theory
13:35:50 <bollu> ertes: dang, don't know
13:35:56 <bollu> ertes: okay, how do I get up to speed?
13:35:58 <geekosaur> ...not topology?
13:36:01 <ertes> bollu: then learn it
13:36:04 <ertes> geekosaur: not really
13:36:08 <bollu> ertes: from?
13:36:22 <bollu> ertes: I know more topology than category theory :P
13:36:25 <ertes> bollu: you could use the ncatlab, but they are a bit dense on higher category theory =)
13:37:04 <bollu> ertes: yes :) is there a book?
13:37:11 <ertes> no, it's a wiki
13:37:21 <bollu> ertes: no, I mean, is there a book?
13:37:32 <ertes> i wouldn't know
13:39:20 <knupfer> Is it possible to teach ghc that a type level operator commutes?
13:40:35 <geekosaur> not /per se/. I recall someone working on a ghc plugin that would insert constraints describing it where the type operator was used, though
13:41:20 <knupfer> That sounds good, do you have a link?
13:42:55 <knupfer> This looks great for numeric stuff https://hackage.haskell.org/package/ghc-typelits-natnormalise
13:43:29 <zipper> Hey I need some help with getting monad to inherit from applicative for new GHC here. It's simple question http://lpaste.net/6328336493328728064
13:43:34 <zipper> Please help :)
13:43:51 <dmj`> johnw: late response, but yes, it's all good :)
13:46:36 <geekosaur> no because it came up while they were developing it and ran into an issue... not seeing anyhting obvious on hackage either unless it was part of what you already found
13:46:41 <geekosaur> (natnormalize)
13:46:49 <knupfer> zipper: You have to write an Applicative instance
13:47:24 <zipper> knupfer: Goddamn I just got started on this book I can't remember stuff
13:49:14 <ertes> zipper: if your book is a bit older it may never have told you that you need it
13:49:17 <zipper> ha! Luckily this worked `instance Applicative (SParse a) where`
13:49:21 <ertes> zipper: the requirement itself is rather new
13:49:22 <knupfer> zipper: Well, you don't have to remember.  The error message is quite clear that you need an Applicative
13:49:40 <zipper> ertes: Yeah ghc 8
13:49:47 <ertes> zipper: 7.10
13:49:56 <zipper> ghc 7* refused to run on arch
13:49:59 <knupfer> zipper: This is likely not what you want
13:50:01 <zipper> so I'll just use 8
13:50:14 <ertes> zipper: sure, i mean you need it since 7.10
13:50:28 <zipper> ertes: Oh
13:50:44 <knupfer> zipper: You have to implement `pure` and `<*>`
13:50:55 <zipper> knupfer: I just want cabal build to succeed. I'm sure I'll remember the rest as I go
13:50:58 <zipper> or learn
13:51:47 <knupfer> zipper: Always use the -Wall flag, and correct all warnings
13:52:11 <ertes> or at least -W, if you find -Wall too noisy
13:53:09 <knupfer> I think for the beginning, the more verbose the compiler, the better.  It's your teacher.
13:53:16 <Tuplanolla> Run `ghci -Wall` and try `200 ^ 2 + 375 ^ 2 == 425 ^ 2` for a good experience.
13:53:18 <zipper> They're errors not warnings
13:53:35 <zipper> Imagine having to debug an install in chapter 1 of a book lol
13:53:52 <zipper> or basically figure out typeclasses
13:54:13 <ertes> Tuplanolla: ouch
13:54:54 <ertes> that makes me question whether you'd even want to fix all warnings when you turn on -Wall =)
13:55:20 <ertes> it's like lpaste.net with its obnoxious hlint
14:03:35 <danza> hi all, could anybody point me to existing conventions about how to structure the modules within a package? I am writing an API for Upwork. Should i put the JSON parsing in Upwork.Data?
14:03:44 <ertes> danza: take inspiration from popular libraries like 'vector' or 'aeson'
14:03:48 <ertes> or 'bytestring'
14:04:02 <danza> okay i'll copy from https://github.com/phadej/github
14:04:05 <danza> thanks
14:05:43 <ertes> danza: one thing:  think twice before using 'other-modules' in a library
14:06:05 <ertes> if in doubt, don't use it, but write an .Internal module instead with full exposure
14:06:09 <danza> `other-modules`? I don't even know what that is :P
14:06:33 <ertes> danza: it's for library modules you don't want to expose
14:06:48 <ertes> exposed-modules vs. other-modules
14:07:18 <danza> aha ... well for the moment i don't see a reason not to expose stuff. But yes i've seen the .Internal pattern in the wild
14:08:02 <knupfer> `other-modules` is perhaps not a very clear name
14:08:03 <hvr> danza: one obvious reason is that once you expose something, it's part of the public API with all its consequences
14:08:27 <danza> good point
14:08:54 <ertes> .Internal is a common convention…  people will generally assume .Internal APIs to be unsafe (violating invariants) or unstable (changing/disappearing across versions)
14:09:06 <ertes> better use .Internal than other-modules
14:09:22 <danza> cool, i'll keep that in mind, thanks!
14:09:26 <danza> on a different topic, it would be awesome if Haskell had automatic semantic version detection as Elm
14:09:37 <ertes> what is that?
14:10:17 <danza> are you familiar with the concept of semantic version? Is similar to Haskell version conventions http://semver.org/
14:10:54 <hvr> danza: I asssume elm can only detect type-level changes in APIs?
14:10:58 <ertes> danza: ah, we have the PVP
14:11:00 <ertes> @where PVP
14:11:00 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
14:11:12 <ertes> but i don't know what semantic version *detection* is
14:11:36 <danza> yeah ... so Elm can detect breakages and increments automatically
14:11:58 <ertes> ah, i see
14:12:11 <hvr> danza: I honestly doubt it can detect them reliably; that's a NP hard problem
14:12:28 <hvr> danza: I assume it only detect compile failures?
14:12:30 <ertes> well, review a diff between your last version tag and the version you want to release, before deciding on the version number
14:12:39 <danza> i guess it can detect just obvious changes in the API
14:12:55 <ertes> you'd want to do that anyway in order to write a CHANGELOG, right? =)
14:13:04 <danza> for example if you add a new method, it's a minor change ... if you remove one method or change its type, it's breaking
14:13:34 <ertes> danza: it may be breaking in a way that isn't just "incompatible"
14:13:41 <danza> of course some changes won't be observable ... it can't be fully automated without including a test suite or something more sophisticated
14:13:59 <ertes> for example an API change may make your API more generic and may be fine most of the time, but require extra type signatures in some cases
14:14:06 <hvr> danza: even a testsuite is just scratching the surface
14:14:34 <ertes> bottom line:  you need to diff anyway
14:14:50 * hvr agrees w/ ertes
14:14:51 <danza> yeah it's just handy to have tooling to watch your exposed API
14:15:05 <hvr> danza: fwiw, we do have half-finished API diff tooling
14:15:10 <hvr> http://hackage.haskell.org/package/check-pvp
14:15:15 <danza> ha, nice
14:15:17 <Cale> bollu: If you're having trouble reading the HoTT book, my first piece of advice is to skip to Chapter 1
14:15:21 <hvr> http://hackage.haskell.org/package/check-pvp
14:15:28 <hvr> http://hackage.haskell.org/package/precis
14:15:32 <Cale> (or don't worry if there are things in the Introduction section which make no sense)
14:15:50 <hvr> http://hackage.haskell.org/package/hackage-diff
14:16:15 <danza> the latter is the one updated more recently
14:16:38 <hvr> yeah
14:17:10 <monochrom> w00t half finished. the 50-50 law: the other 50% will take 50% of the time :)
14:17:26 <danza> for some reason these tools didn't take off. They seem handy though
14:18:08 <hvr> danza: I'd like to have some variant of them integrated into hackage
14:18:13 <ertes> monochrom: how does that work?  after all the other 10% take 90% of the time
14:18:13 <danza> they could help preventing some obviously mistake
14:18:39 <hvr> danza: so when you upload a candidate to hackage, you'd get a report which tells if you if you're version increment *seems* sensible
14:19:04 <danza> there would be some times when your version increment is obviously wrong
14:19:18 <danza> versioning can just be proved wrong, like science :D
14:19:26 <hvr> yeah
14:19:49 <Tuplanolla> It would be useful to find the oldest versions of your dependencies that seem compatible, so that you could test that configuration.
14:19:53 <hvr> or in some very simple cases it can be proven right
14:19:59 <ertes> danza: you have a safeguard though (and if you don't already have it, you can easily get it):  write either a bunch of tests or a bunch of examples
14:20:09 <ertes> once they break, you know that you need a major version dump =)
14:20:16 <bollu> Cale: straight to 1, then?
14:20:17 <ertes> s/dump/bump/
14:20:18 <volhovm> Hi! What is the reason between StateT (ReaderT ..) and ReaderT (StateT ..)?
14:20:32 <dmwit_> volhovm: They are the same.
14:20:32 <danza> hum ... i think that such a system would help more package users rather than package authors
14:20:37 <ertes> volhovm: the difference?  they're isomorphic
14:20:41 <dmwit_> volhovm: `ReaderT` commutes with many other transformers.
14:20:48 <volhovm> Alright, thanks. 
14:20:54 <dmwit> ?unmtl StateT s (ReaderT r m) a
14:20:54 <lambdabot> s -> r -> m (a, s)
14:20:58 <danza> package authors can be careful ... package users can't enforce others to be careful ... unless via a similar system
14:21:01 <dmwit> ?unmtl ReaderT r (StateT s m) a
14:21:01 <lambdabot> r -> s -> m (a, s)
14:21:03 <ertes> volhovm: there is an internal argument flip between the two, but they act identically in terms of effects
14:21:14 <hvr> dmwit: is there an overview which transformers commute with which other ones?
14:21:27 <volhovm> Wow, what does unmtl do? :)
14:21:33 <dmwit> hvr: I've never seen such a thing, no.
14:21:43 <volhovm> It's lambdabot feature, i see...
14:21:50 <volhovm> can't get it on standart env
14:21:53 <dmwit> volhovm: It takes an mtl type and strips away all the newtype nonsense to show you just the bare type.
14:21:57 <geekosaur> most mtl monads are type aliases. @unmtl expands the aliases to show you what the actual type looks like
14:22:02 <geekosaur> (roughly)
14:22:21 <geekosaur> (actually they're newtypes, so it's showing you what happens after typechecking when the newtype wrappers go away)
14:26:10 <shanemikel> Can somebody confirm that the wiki is working (no ssl problems), because I'm still having problems
14:26:37 <Xe> https://wiki.haskell.org/Zygohistomorphic_prepromorphisms loads for me
14:26:38 <jle`> volhovm: you can get similar things with :i in ghci
14:26:54 <dmwit> ?unmtl a
14:26:54 <lambdabot> a
14:26:55 <dmwit> ?unmtl of
14:26:55 <lambdabot> Plugin `unmtl' failed with: Parse error: of
14:26:57 <dmwit> wut
14:27:00 <jle`> volhovm: :i ReaderT => ... blah blah ... ReaderT r m a = ReaderT (r -> m a)
14:27:44 <Koterpillar> Xe: http://www.theregister.co.uk/2016/10/13/globalsigned_off/ ?
14:28:02 <geekosaur> shanemikel, basically it works from non-OSX
14:28:10 <geekosaur> mostly
14:28:30 <shanemikel> okay, so even running that sqlite command wont fix it?
14:28:34 <geekosaur> https://www.globalsign.com/en/status/ seems to imply that GS's OCSP server is still throwing the occasional wobbly
14:28:47 <geekosaur> not if it gets another warning the next time it queries
14:29:21 <geekosaur> also that is only for 10.12 (but shou;ld error out if you aren't on 10.12 anyway). there's a different invocation for older OS X
14:29:36 <shanemikel> yeah, I'm on sierra
14:29:57 <geekosaur> hm, the status page says they finally fixed it about 40 minutes ago
14:35:30 <cath> I need to import an operator from another module into an lhs.  For whatever reason, ghc complains that the operator "is not in scope" although it gives it the correct signiture.  It unhelpfully suggsts some prelude operators.  What might be the problem?  My import is like:  import A (type (+>)) 
14:35:56 <erisco> try just   import A ((+>))
14:36:56 <cath> ah, right let me recompile
14:37:08 <jle`> i can't imagine how import A (type (+>)) would compile
14:37:25 <Tuplanolla> How do you import type operators?
14:37:40 <erisco> same way
14:37:52 <dmwit> jle`: https://wiki.haskell.org/GHC/Type_families#Import_and_export introduces `type` as a keyword in import lists
14:37:59 <jle`> oh, neat
14:38:19 <jle`> doesn't it need an extension?
14:38:44 <geekosaur> yes, but several extensions enable it implicitly already
14:38:56 <dmwit> Probably? Additionally, cath has not told us nearly enough to know which, if any, extensions they have turned on.
14:38:58 <jle`> ah
14:40:22 <cath> I understand now.  I was just pattern matching: the module only exports type (+>)
14:40:32 <cath> TypeFamilies,
14:40:32 <cath>         ConstraintKinds,
14:40:32 <cath>         DataKinds,
14:40:34 <cath>         GADTs,
14:40:36 <cath>         MultiParamTypeClasses,
14:40:38 <cath>         FlexibleInstances,
14:40:40 <cath>         FlexibleContexts,
14:40:42 <cath>         TypeOperators,
14:40:44 <cath>         RankNTypes,
14:40:46 <cath>         InstanceSigs,
14:40:48 <cath>         ScopedTypeVariables,
14:40:50 <cath>         UndecidableInstances,
14:40:50 --- mode: ChanServ set +o johnw
14:40:52 <cath>         PolyKinds,
14:40:53 --- mode: ChanServ set +o johnw
14:40:53 --- mode: johnw set +b *!~cath@206.217.117.226
14:40:53 --- kick: cath was kicked by johnw (Kicked)
14:40:53 --- mode: johnw set -o johnw
14:40:55 --- mode: ChanServ set +o dmwit
14:41:04 --- mode: dmwit set -o dmwit
14:41:46 <jle`> i'm so sorry
14:42:00 <geekosaur> did someone notify them what they did wrong and invite them back?
14:43:31 <geekosaur> ...also unban, that was excessive
14:43:32 --- mode: ChanServ set +o geekosaur
14:43:37 --- mode: ChanServ set +o johnw
14:43:38 --- mode: johnw set -b *!~cath@206.217.117.226
14:43:41 --- mode: geekosaur set -b *!~cath@206.217.117.226
14:43:44 <johnw> I banned first, then contacted them by PM
14:43:51 <johnw> banning is just part of my macro :)
14:43:54 --- mode: geekosaur set -o geekosaur
14:43:56 <hpc> heh
14:43:57 <erisco> shoot now, ask questions later
14:44:01 <johnw> pretty much
14:44:20 <cath> ok, well, I have at least some of that figured out.
14:44:42 <Tuplanolla> This happens every day and still some people think IRC doesn't need a successor with better usability...
14:44:58 <erisco> it doesn't, we've seen what that is
14:45:01 <dmwit> I don't think it happens every day.
14:45:06 <erisco> Slack, Discord, Gitter
14:45:20 <johnw> I only saw it because my client was throttling the messages, and no one ever posts with that degree of regularity...
14:45:29 --- mode: johnw set -o johnw
14:45:35 <johnw> the corner of my eye said, "whaa...?"
14:45:46 <geekosaur> it doesn't happen every day and the folks who most need it tend to be the ones who wouldn't use the replacements (that is, the problem is most intractable with command line/curses clients)
14:46:23 <erisco> Slack, for instance, replaces unicode characters such as ☁ with disgusting PNGs. Crimes.
14:46:48 <Tuplanolla> You can't really call proprietary things successors anyway.
14:47:17 <danza> +1
14:47:44 <Koterpillar> erisco: Tuplanolla: they are all "let's entice people to our nonfree platform with these arguably good features"
14:47:44 <erisco> you can add a bot to an IRC channel that bans users if they send messages too quickly
14:47:50 <hpc> slack also keeps centralized logs of everything, which seems weird
14:48:01 <Koterpillar> which seems useful
14:48:16 <hpc> you can't for instance, run an irc server for a company without feeling uncomfortable about business information being on third-party servers
14:48:17 <danza> which seems unrelated :D
14:48:29 <hpc> er, you can
14:48:31 <hpc> but can't for slack
14:48:59 <erisco> maybe espionage is the business model ;)
14:50:11 <danza> well ... i'd argue that Slack has a different target. It's great for bringing everybody on the same page, the techies and the less techies ... within a company. Openness ownership and good engineering are not their problems
14:50:57 <Tuplanolla> All I really want is snippets, integrated file transfers, Markdown formatting and TeX equations.
14:51:05 <Koterpillar> I have a tree-like structure I want to persist to a database and query nicely. Looks like Persistent can get me the models, but nothing like MPTT, is there an extension for that?
14:52:01 <erisco> I tried to send Tuplanolla a file and my client crashed
14:52:06 <Tuplanolla> See.
14:52:08 <chreekat> irc, like email, does need new smart clients. The problem is that most new chat/async messaging clients becoming popular are also throwing away the underlying networks
14:52:40 <Koterpillar> some of the smartness is so awfully easier to do centralized, so it gets done that way
14:52:41 <danza> there is irccloud
14:53:24 <chreekat> yeah, and it's a lot easier to just bulldoze people's houses to build a new road rather than go through the tedium of contacting them first
14:53:52 <erisco> eminent domain, all your base are belong to us
14:53:53 <danza> well ... https://github.com/barrucadu/irc-client
14:54:07 <Toxaris> is there something wrong with the hackage.haskell.org SSL certificate?
14:54:15 <grantwu> Oh yeah, my friend had that issue too
14:54:17 <johnw> Toxaris: has it expired?
14:54:20 <grantwu> @Toxaris
14:54:20 <lambdabot> Unknown command, try @list
14:54:31 <Koterpillar> Toxaris: http://www.theregister.co.uk/2016/10/13/globalsigned_off/ ?
14:55:09 <fazil[m]> hello
14:55:11 <Toxaris> on one of my Windows machines, MS Edge refuses to accept the certificate.
14:55:29 <johnw> Toxaris: can you paste more information in #haskell-infrastructure?
14:55:32 <johnw> i'd be happy to look into it
14:55:37 <Toxaris> Other browsers accept it. It seems to be pretty new and lists a long list of domains.
14:55:45 <geppettodivacin> If I were to map an arithmetic function over a list, for example `map (*2) xs`, what would be the best way to ensure that this operation is strict?
14:56:10 <Toxaris> johnw: ok moving over to #haskell-infrastructure, thanks
14:57:02 <Rarrikins> geppettodivacin: Make a function in a where clause which makes things strict, then use that.
14:57:02 <johnw> Toxaris: glguy reported it to us there at an hour and a half ago, fwiw
14:57:16 <geekosaur> interesting. have been hearing about that on macs a lot today (caching) but this is the first I've heard of it on windows
14:58:08 <geppettodivacin> Thanks, Rarrikins.
14:59:00 <chreekat> Koterpillar: persistent has no support for heirarchical data, not even joins. It's a bit frustrating that way. opaleye and esqueleto at least do relational algebra and/or "sql"
15:01:11 <Koterpillar> chreekat: thanks, I've looked at esqueleto and I might be able to write some combinators for it, but I hoped to avoid that. Looking at the other one...
15:02:47 <Toxaris> We use Slack for coordinating our research group at university. We like the following features: (1) accessible to non-technical staff (2) drag'n'drop upload of images and pdfs (2) editing messages to fix typos (3) reacting to messages by emoticons to signal yes / no / bravo / this was fun (4) decent support for longer messages like this one.
15:04:29 <Toxaris> oh, and I forgot: (0) messages are permanently stored outside the clients, so you see what happened while you were away
15:04:31 <johnw> since this channel is on IRC, we're not going to be changing it to Slack, obviously. :)  If others want to start a Slack group and chat there, that's a different story, but it won't remove this channel from existence anytime soon.  So I'd like to ask the discussion be moved out of channel.
15:04:54 <Toxaris> oh sorry, was not aware anyone proposed that. NO please don't move to Slack, this channel is great and IRC is great
15:05:15 <Toxaris> when I joined, I saw people discussing why anyone would ever use Slack at all, so I figured I could mention why we do
15:05:26 <geekosaur> someone has already set up a slack channel with a one-way gateway
15:05:29 <pikajude> we definitely need to incorporate more emojis into #haskell though
15:05:38 <danza> Toxaris, you can also use irccloud for message permanency
15:05:47 <grantwu> irccloud costs money.
15:05:51 <Toxaris> so does Slack :)
15:05:52 <Tuplanolla> We're hinting that someone should write the Haskell package `irc-but-better`.
15:06:05 <grantwu> Plus getting IRC on mobile is a pain
15:06:13 <sm> Toxaris: that info was useful
15:06:19 <grantwu> I never got TLS to work between weechat-android and my remote
15:06:29 <grantwu> (also, irccloud is unreliable.)
15:06:31 <pikajude> in my opinion, haskell's type system is 🔥 !
15:06:50 <danza> oh that's horrible on my client XD
15:07:14 <erisco> where can you find PHP's explode function in Haskell?
15:07:24 <sm> in the split package
15:07:36 <Toxaris> (actually, I had to disable Slack notifications from my cellphone to stabilize my work-life-balance, so work-IRC on my phone would be a mixed blessing, at best)
15:07:49 <hpc> erisco: unsafeLaunchMissiles
15:08:00 <erisco> oh, it is not on Hoogle, that is why it did not turn up then
15:10:00 <sm> erisco: http://hoogle.haskell.org is better at finding packages
15:11:10 <dmj`> is there such a thing as a heterogenous rose tree
15:11:18 <dmj`> like HList, but HRose
15:11:27 <dmj`> don't see why there couldn't be
15:11:38 <johnw> your index type would need to be a rose tree too
15:11:38 <erisco> init &&& last  seems a bit gross
15:11:41 <monochrom> it's type will be a tree, too.
15:11:53 <monochrom> s/it's/its/
15:12:00 <johnw> HRose (A :: *) (xs :: Tree A)...
15:12:13 <johnw> or just Tree if it the tree itself contains the type too
15:12:28 <monochrom> I don't like these type-level games, so I won't write it. You can write it.
15:12:56 <erisco> (intercalate " " . init &&& last) . splitOn " "
15:13:21 <monochrom> Except for April 1st jokes.
15:13:33 <dmj`> johnw: ah, so it would need to be mutually recursive
15:13:49 <hpc> monochrom: you should write it and make it an acme package
15:14:00 <hpc> monochrom: so if someone else wants to go back and add it as a real package, they feel bad
15:14:09 <johnw> dmj`: each GADT constructor will traverse the type index in the same way, etc.
15:14:14 <monochrom> there are a million other things competing for my time. even for April 1st and/or acme.
15:14:20 <hpc> ;)
15:14:37 <monochrom> I should simply auction off my time to earn some money.
15:15:04 <hpc> downloadmoretime.com
15:15:07 <monochrom> I can fulfill your acme dream but you have to be the highest bidder.
15:15:09 <hpc> sister site to downloadmoreram.com
15:55:45 --- topic: 'https://www.haskell.org | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? https://status.haskell.org | https://downloads.haskell.org'
15:55:45 --- topic: set by glguy on [Fri Aug 05 17:41:47 2016]
15:56:35 <SrPx> osa1: this type system -> http://i.imgur.com/EuVyh3R.png
15:57:04 <osa1> is -o a linear arrow?
15:57:07 <SrPx> I basically want to know how would an experienced language designer turn it into a practical programming language (if it is the case that such a system can be usd for one)
15:59:34 <SrPx> osa1: I think so
16:02:32 <Toxaris> SrPx: oh this language has "type fixpoints", so maybe you can use typed Scott encoding for your datatypes?
16:05:23 <Tuplanolla> I overheard that you don't study this stuff officially, SrPx. May I ask what you do?
16:06:01 <erisco> :t (<*>)((<*>)((pure)(<*>))((<*>)((pure)(pure))(<*>)))((pure)(pure))
16:06:19 * monochrom squints
16:06:34 <monochrom> is that Morse code in Applicative notation? :)
16:06:53 <erisco> it is flip
16:07:02 <monochrom> eek
16:07:13 <monochrom> and lambdabot is away
16:07:15 <erisco> hard to imagine what intuition would lead to that
16:07:40 <SrPx> Toxaris yes that is what I wonder, if I can use scott encodings and recursion. If that is the case, then it couldn't be too hard to program in such a language, could it?
16:07:44 <monochrom> yeah, it's craziness
16:08:01 <Toxaris> erisco: doesn't look like flip's type to me: Applicative f => f (a -> b) -> a -> f b
16:08:04 <SrPx> I'm not sure what the effects of those linear type wizardry would be for programming in practice though.
16:08:06 <erisco> the way I dealt with indexing arguments is to sort of curry them, I called it "lurry"
16:08:21 <erisco> Toxaris, specialise it for functions and you'll see
16:08:36 <Toxaris> oh
16:08:38 <Toxaris> cool
16:09:05 <erisco> I used a program to convert lambda to SK form
16:09:28 <erisco> so if you find the "bracket construction" algorithm, or whatever it is called, intuitive, then I suppose this answer is also intuitive
16:09:37 <SrPx> Tuplanolla: I'm studying computer engineering actually, having a semester full of electronic-related subjects, sadly
16:09:49 <Toxaris> intuitive algorithms can give non-intuitive answers
16:10:13 <erisco> if you "lurry" the arguments then you can index them and the problem becomes much easier http://hackage.haskell.org/package/data-function-tacit-0.1.0.0/docs/Data-Function-Tacit.html
16:10:30 <erisco> but this requires a family of functions to do lurrying, one for every arity
16:10:44 <Tuplanolla> That's funny, SrPx. I'm about to graduate as a physicist, but I have similar programming language theory tendencies.
16:11:23 <Toxaris> SrPx: not sure about recursion. How can a language with clever time bounds support unrestricted recursion? certainly only clever recursion can be allowed, whatever that means
16:11:26 <Tuplanolla> It's quite frustrating at times.
16:11:57 <SrPx> Tuplanolla: well this all started a few years ago when I was unhappy with having to write "for" loops in JavaScript too many times, I thought that was stupid and started looking for better languages
16:12:11 <erisco> so (a -> c -> b) -> (c -> a) -> (c -> b)  is  _1 <*> (_2 <*> _3) <*> _3  :P
16:12:39 <SrPx> I've learned about, lisp, scheme, haskell, then before I could notice I was reading category theory tutorials
16:12:49 <SrPx> I still have to write a lot of fors though
16:13:09 <Toxaris> use jQuery ;)
16:13:20 <SrPx> Toxaris: I agree
16:13:38 <SrPx> Tuplanolla: how did you get here from physics?
16:14:23 <Toxaris> after all, jquery is the lens of JS
16:14:59 <Tuplanolla> I was unhappy with the handwaving, SrPx. I progressed from machine code to C, Java, Scheme, Haskell, Coq, ...
16:15:23 <ertes> jQuery is more the IxSet of JS
16:15:25 <Toxaris> erisco: so can you express your _1, _2 and _3 so that, for example, _3 = _succ (_succ (_succ _zero))
16:15:26 <Tuplanolla> At first it was about building things, but it has increasingly turned into thinking things.
16:16:07 <SrPx> Tuplanolla: I'd like to know the next element of that sequence
16:17:20 <Tuplanolla> Death? The list keeps me busy enough for now.
16:17:46 <SrPx> ouch
16:18:09 <monochrom> clearly there is retirement before death
16:18:33 <Tuplanolla> Seriously though prl and ctt might come up next.
16:19:01 <Tuplanolla> I don't know anything about them.
16:19:01 <Toxaris> most people move towards "writing things" or towards "selling things"
16:19:47 <SrPx> Tuplanolla: Google doesn't help me, what are those?
16:20:16 <Tuplanolla> Oh, proof refinement logic and cubical type theory.
16:21:05 <erisco> Toxaris, that is basically how it is defined, yes
16:21:30 <SrPx> ah, HoTT stuff?
16:22:19 <Toxaris> erisco: oh cool, I feared you mean an ad-hoc family of functions.
16:22:31 <yulax> is it possible to write android apps with haskell?
16:22:41 <Koterpillar> yulax: yes, but hard
16:23:09 <yulax> do the libraries have to be packaged in the app or something?
16:24:06 <erisco> Toxaris, the paths (as I call them) are not ad-hoc, but the type level is
16:24:07 <Tuplanolla> That book is waiting to be read further too, SrPx.
16:24:45 <erisco> Toxaris, wait, no, I am wrong, it is not ad-hoc either ^.^
16:25:29 <SrPx> yulax: ghcjs or purescript + web perhaps, but it would be hard to make something of quality
16:26:08 <erisco> there is just a pain caused by how type classes work… I left a comment on that
16:26:22 <erisco> where so you submit feature requests
16:26:51 <erisco> where do you*
16:41:10 <intothemountains> Is there something like do notation but for >>=?
16:41:47 <johnw> what do you mean?  >>= is just flip (=<<)
16:42:11 <intothemountains> do notation is just 'foldl >>', right?
16:42:36 <Phyx-> erisco: so the compiler? https://ghc.haskell.org/trac/ghc/newticket?type=feature+request
16:42:40 <Phyx-> to*
16:43:21 <intothemountains> johnw: but do notation doesn't fold using =<<, it folds using >>
16:45:44 <intothemountains> oh, sequence does what i want
16:46:33 * Axman6 is so confused, none of that made any sense
16:46:47 * intothemountains is now confused too
16:47:19 <intothemountains> Is do notation just syntactic sugar for joining monads using >>?
16:47:30 <ertes> intothemountains: (>>=) or (>>)
16:47:42 <ertes> (do x <- c; f x) = c >>= f
16:47:56 * hackagebot ec2-unikernel 0.9.2 - A handy tool for uploading unikernels to Amazon's EC2.  https://hackage.haskell.org/package/ec2-unikernel-0.9.2 (AdamWick)
16:47:57 <intothemountains> oh, okay
16:47:58 * hackagebot halvm-web 0.3.0.0 - A simple, static HaLVM web server  https://hackage.haskell.org/package/halvm-web-0.3.0.0 (AdamWick)
16:48:43 <intothemountains> ertes: so if I want to "pipe" some monads, "folfl (>>=) (return x) [monads]" is my best option, right?
16:48:54 <intothemountains> sorry, s/folfl/foldl/
16:49:29 <ertes> intothemountains: you probably want foldr for that sort of thing, but regardless, folds are not actually expressive enough for most interesting "pipes"
16:49:37 <ertes> :t foldr (>=>) return
16:50:30 <intothemountains> Why foldr and why (>=>)?
16:51:07 <ertes> intothemountains: first question: because most monads really want you to use (>>=) in a right-associated way
16:52:03 <Axman6> :t foldr (>>=)
16:52:06 <ertes> second question: try to write a type for the kind of combinator you're trying to write
16:52:15 <Axman6> :t foldr (>=>)
16:52:26 <Axman6> lambdabot is DEAD D:
16:54:50 <ReinH> @src concat
16:54:57 <ReinH> Noes!
16:55:03 <blubbb> /
16:56:03 <ReinH> concat = foldr (++) [] for basically the same reason (and also for guardedness)
16:56:32 <ertes> data ActionList :: (* -> *) -> * -> * -> * where Cons :: (a -> m b) -> ActionList m b c -> ActionList m a c; Nil :: ActionList a a
16:56:55 <ReinH> Also (>=>) and return form a monoid, which is pleasing.
16:57:20 <ReinH> (Actually multiple monoids, one for each monad instance)
16:57:34 <Axman6> huh, so they do, hoiw had I never seen that, and put together "monads are just a monoid in the category of endofunctors"
16:58:00 <ReinH> That is not how they are monoids in the category of endofunctors
16:58:16 <ertes> Axman6: they are just monoids in a similar sense as Endo
16:58:17 <Axman6> :(
16:58:49 <ertes> if you think of categories as monoids on steroids, you can see how Kleisli is a more interesting generalisation of that
16:59:29 <ertes> instance Monoid (Kleisli m a a) where mappend = (.); mempty = id
16:59:38 <ertes> + (Monad m)
17:03:04 <ReinH> Axman6: (m, (>=>), return) is a monoid in the Kleisli category for m in the "monoids are degenerate categories" sense.
17:03:39 <ReinH> that is, each single object in a category is a monoid.
17:04:39 <Axman6> right, ok
17:04:40 <ReinH> that is, fix an object a in the Kleisli m category and you have the monoid ertes describes.
17:06:09 <cpdean> this might be tangentally off-topic, but i'm trying to get some perspective on ocaml and figured haskell people might be better suited to answer this question
17:06:54 <cpdean> i read somewhere that something about the features of haskell's type system make its quickcheck library a lot nicer to use than any of the various ports in other languages
17:07:11 <cpdean> and i found this series someone wrote about F# property tests, with some references to haskell
17:07:13 <cpdean> so..
17:07:15 <cpdean>  are the lessons in this series applicable to ocaml? or are the differences between F#, Haskell, and Ocaml's type systems large enough that you need different strategies in testing and designing software in it? http://blog.ploeh.dk/2016/02/10/types-properties-software/
17:09:40 <erisco> fst :: (a, forall b. b) -> a
17:09:45 <erisco> something like this seems desirable
17:11:53 <ertes> here we go…
17:12:20 <erisco> madness lies that way
17:13:09 <ertes> https://gist.github.com/esoeylemez/fd45a47b5f0d1992c19647a8839d87b4
17:14:20 <erisco> that doesn't help me either actually
17:14:37 <erisco> I thought my problem could be resolve by closed type classes but I am not sure how I thought that now
17:14:46 <erisco> upon revisiting, it seems the problem is something else
17:15:22 <erisco> exists with closed type families so clearly not how I thought
17:15:45 <ReinH> Axman6: do you know what a "category of endofunctors" is?
17:16:32 <Toxaris> cpdean: I only skimmed the articles in the series and I don't know much about Ocaml, but I guess the answer is: the lessons in this series are  applicable to F#, Haskell, and Ocaml.
17:16:37 <erisco> lets say I have   a ~ b => (F a, b)   then what I am after is really that b be constrained according to the cases of F
17:16:38 <Axman6> ReinH: not really, no
17:16:53 <erisco> which hardly makes sense, it would have to be a new constraint other than ~
17:17:17 <ertes> erisco: that wasn' for you…  i was just trying to generalise lists in such a way that intothemountains can encode "pipes" =)
17:17:37 <ertes> i'll leave writing the Category instance as an exercise
17:17:38 <Toxaris> cpdean: the main point of the series seems to be to use algebraic data types to carefully model the domain, which is a key technique in all languages in the ML tradition
17:17:44 <ReinH> Axman6: Start with the category Cat of (small) categories
17:17:53 <ReinH> The objects are (small) categories, the morphisms are functors.
17:18:04 <erisco> the desire is to infer a smallest type
17:18:06 <ReinH> It also makes sense to talk about morphisms *between* functors, natural transformations.
17:18:12 <cpdean> Toxaris: that's reassuring but i thought haskell had something over ocaml
17:18:23 <erisco> whereas Haskell prefers to whine about ambiguity
17:18:47 <ReinH> Now, if you fix a particular object C in Cat, you are talking about functors from C to itself and natural transformations of those functors.
17:19:02 <Shoue> Is there a common typeclass like Functor implementing maps that takes kinds * instead of (* -> *)?
17:19:02 <ReinH> That is, endofunctors on C and natural transformations between them.
17:19:10 <cpdean> Toxaris: and that something about this article would hit on what that difference is
17:19:34 <cpdean> to be honest i'm looking for information about a topic i know very little about
17:19:39 <ertes> cpdean: haskell has type classes, which makes quickcheck *infer* most of the test generators
17:19:53 <ertes> i don't know if OCaml has something along those lines, too
17:20:32 <erisco> (b <= a) => (F a, b)   but this leaves 'a' to be as "big" as you want, not good enough
17:21:02 <ReinH_> Axman6: Sorry, connectivity problems.
17:21:14 <ertes> Shoue: what would the type of its "fmap" be
17:21:16 <ertes> ?
17:21:46 <ReinH_> Axman6: So the category of endofunctors on C is the category where objects are endofunctors and morphisms are natural transformations
17:21:48 <Axman6> ReinH_: any chance we could do this another time? I've got work to do at the moment, but would very much love to learn
17:21:51 <ReinH_> Axman6: sure
17:22:08 <ertes> Shoue: i'm asking not because it's impossible, but because there are actually many possible designs, and you have to pick one
17:23:18 <SrPx> what is that triangle that often shows up on type systems?
17:23:47 <SrPx> This one: ∆
17:23:59 <ReinH_> (This is a specific instance of the idea that a k-degenerate n-category is equivalent to an (n-k)-category)
17:24:07 <erisco> maybe a family of constraints, Min*, takes a closed family F, then fully supplied arguments, such as  Min F a   for F :: * -> *  which gives you the first 'a' that is defined under F
17:24:21 <ReinH_> Or, depending on which notation you pick, a k-degenerate (n+k)-category is equivalent to an n-category.
17:25:06 * erisco shrugs
17:26:13 <cpdean> ertes: what about type classes lets quickcheck create better generators? is it just that you get to leave out boilerplate as a user of the test lib?
17:26:20 <ReinH_> (this is a parenthetical because it isn't really important for understanding what the category [C,C] is.
17:26:22 <ReinH_> )
17:26:29 <erisco> I wouldn't want it to be incompatible with annotating larger types, though
17:26:40 <erisco> I just want inference to take the smallest
17:27:03 <erisco> not really the Haskell way of things … won't even pick an arbitrary type class instance for you
17:27:48 <ertes> cpdean: not *better* generators, but you can write this:  myProp n x = replicate (n + 1) (x :: Char) == x : replicate n x
17:28:43 <ertes> cpdean: haskell's type system will infer that you need an Int generator for 'n'
17:29:14 <ertes> (while for 'x' a type signature was necessary)
17:29:44 <ertes> you will rarely have to tell: "generate random Char here though"…  at most you will have to say, "this is of type Char"
17:30:06 <ertes> s/ though"/" though/
17:30:34 <cpdean> ertes: is 'replicate' a thing provided by quickcheck?
17:30:50 <tom7942> replicate is prelude
17:30:51 <cpdean> sorry trying to parse your example...
17:30:54 <ertes> cpdean: no, it's a simple function from base:  replicate 4 'x' = "xxxx"
17:30:58 <cpdean> ah
17:31:17 <cpdean> what's the colon do in myProp's definition
17:31:35 <tom7942> colon is "cons" for building up a list
17:31:36 <ertes> cpdean: what language are you familiar with?  i'll just translate it
17:31:54 <cpdean> i do a lot of python, have been wanting to get into an ML
17:32:23 <dmj`> cpdean: look no further then, you've come to the right place
17:32:45 <cpdean> dmj`: lol we'll see. i've been trying to learn haskell on and off for like five years
17:33:23 <ertes> what's python's 'replicate'?
17:33:25 <tom7942> 1 : 2 : 3 : [] == [1,2,3]
17:33:45 <cpdean> eh-- translating it into python might not be productive for me understanding it
17:34:04 <cpdean> so myProp is a property that has to be satisfied by the behavior of some other fn right?
17:34:19 <ertes> cpdean: myProp is just a regular function…  it takes an Int and a Char
17:34:36 <cpdean> but its purpose is to describe some kind of relationship right?
17:34:41 <cpdean> " myProp n x = replicate (n + 1) (x :: Char) == x : replicate n x"
17:34:50 <ertes> and returns a Bool that is True, if the property it describes holds for the arguments
17:35:12 <ertes> you give that function to QuickCheck, and it randomly generates arguments to it based on the *types* of the arguments
17:35:21 <cpdean> gotcha
17:35:25 <Toxaris> SrPx: the uppercase greek letter delta?
17:35:56 <ertes> cpdean: simpler example:  myProp x y = (x + y :: Integer) == y + x
17:36:07 <SrPx> Yes, I'm trying to make sense of this http://imgur.com/a/rOIGd
17:36:08 <ertes> cpdean: this function checks whether (+) is commutative for its arguments
17:36:25 <ertes> cpdean: QuickCheck knows that it takes Integer arguments and starts generating random values
17:36:39 <cpdean> oh gotcha
17:36:58 <cpdean> the double-colon marks "y" as an integer, and you can only add integers together?
17:37:14 <Toxaris> SrPx: There, I think the Δ works just like the Γ.
17:37:21 <ertes> cpdean: quickcheck goes as far as to generate random *functions* for you
17:37:27 <cpdean> wut
17:37:34 <SrPx> Like a separate context? Where/how does that show up when implementing? 
17:38:03 <ertes> cpdean: precedence-wise (x + y :: Integer) is read as ((x + y) :: Integer), so i'm writing a type signature for the *sum*, not for y
17:38:06 <cpdean> does it just have a bunch of functions in its back pocket, looking for type signatures that match?
17:38:22 <ertes> cpdean: it has a bunch of recipes it just sticks together
17:38:25 <Toxaris> SrPx: Let's look at the right tensor rule together (the lower-right rule in the "multiplicative rules" section)
17:38:34 <cpdean> ertes: that is some magic
17:38:43 <ertes> cpdean: (randomly of course)
17:38:50 <SrPx> sure
17:38:53 <ertes> cpdean: it's magic and very useful at the same time =)
17:39:06 <Toxaris> SrPx: in the conclusion, the context is Γ, Δ.
17:39:41 <cpdean> ertes: what projects do you use haskell and quickcheck for?
17:39:43 <SrPx> Toxaris: that rule makes sense, but why not just use a single Γ
17:40:05 <ertes> cpdean: i've used quickcheck mostly for arithmetic and data structures
17:40:09 <Toxaris> SrPx: the point of not just writing Γ (as in the usual STLC) is that we want to use Γ in one premise and Δ in the other
17:40:35 <ertes> cpdean: arithmetic properties are the kind of thing that's not well covered by haskell's type system
17:41:55 <Toxaris> SrPx: so in a backwards proof (= when typechecking), we have to choose for each hypothesis whether it should be in Γ and be available to t1, or be in Δ and be available in t2.
17:43:10 <Toxaris> SrPx: This is how affinity is implemented here: You cannot use the same variable in both t1 and t2, because then it would have to be in both Γ and Δ, and then Γ, Δ would have the variable twice, which isn't possible
17:44:04 <Toxaris> so a type checker for this system would have to guess whether it needs the variable in t1 or in t2, and split the context into Γ and Δ appropriately.
17:44:10 <cpdean> ertes: i'm struggling to imagine what sorts of bugs quickcheck finds for you in that context. but i haven't written enough haskell to ever see a bug
17:44:23 <SrPx> Toxaris: that makes sense, let me think a little about it
17:44:39 <ertes> "i haven't written enough haskell to ever see a bug"
17:44:43 <ertes> loved that one =)
17:46:17 <cpdean> ertes: i mean, honestly -- everything are just tiny example snippets too small to see a bug happen
17:46:36 <cpdean> ertes: but i really want to learn an ML enough to work on a big enough project that i can actually feel what the type system does for me
17:47:15 <cpdean> ertes: blogposts and examples from books are only focused on syntax and getting things to print
17:47:19 <EvanR> lived through enough dynamically typed projects big enough to know what the type system does for me
17:47:31 <ertes> cpdean: i don't really think of the type system as a tool that is mostly for preventing bugs
17:47:41 <cpdean> wutt
17:47:46 <tom7942> never worked on dynamic typed projects and never want to 
17:47:56 <cpdean> what else of a purpose is there in a type system then making you not write bad code?
17:48:07 <EvanR> the type system can guide the design of your program
17:48:21 <ertes> cpdean: it's a development tool that helps you flesh out your ideas, not repeat yourself, make the compiler write boring code for you, etc.
17:48:27 <cpdean> i've only ever had a type system tell me what's going wrong, not where i should go
17:48:39 <EvanR> when its a big ball of json, thats gotta be in comments or docs, which invariably get obsoleted
17:48:42 <ertes> cpdean: if lambdabot was here, i could give you a really simple example, but it's apparently out of order right now =/
17:49:03 <Toxaris> cpdean: QuickCheck is a tool for preventing (or at least catching) bugs. QuickCheck is cheaper to use in Haskell because with type classes, quickcheck can include an automatic test case generator that uses types to adapt to the structure of your data. in an untyped language, we could have quickcheck, but we would need to write the testcase generator by hand.
17:49:29 <Toxaris> cpdean: so types and type classes make it *cheaper* to use QuickCheck to find bugs.
17:49:35 <ertes> cpdean: the idea is that through the type system you give the compiler domain-specific knowledge about your code, so it can guide you in many ways
17:49:41 <Toxaris> so types and type classes are a productivity feature here
17:50:10 <cpdean> hmm
17:50:10 <SrPx> Toxaris: wait, so I have to check that the same variable isn't on both contexts when concatenating them when type-checking the tuple?
17:50:25 <EvanR> stop you from writing bad code, dunno about that. but it makes it easier to write the code you think is good
17:50:35 <SrPx> Toxaris: how is that done usually?
17:51:04 <tom7942> keeps you from treating a meter as a foot or inadvertently sign extending something
17:51:14 <Toxaris> SrPx: Hmm? Type-checking goes the other way around (bottom-up in your rules, not top-down)
17:51:37 <EvanR> i havent seen much units-of-measure in haskell, and Int is the convention even if its unsigned ;)
17:51:45 <Toxaris> SrPx: but let's first understand the logical content of the rules (which programs are well-typed) not the operational content (how to typecheck a program).
17:52:07 <ertes> int-e: in case you haven't already been notified, lambdabot is gone
17:53:37 <Toxaris> SrPx: for this, consider: λx . x ⊗ x 
17:53:46 <cpdean> would you say the type system helps you stay organized in a codebase?
17:53:53 <SrPx> Toxaris: t1 ⊗ t2 : A ⊗ B is well typed if on the left context t1 : A and on the right context t2 : B, right?
17:53:59 <SrPx> Toxaris: oh ok, proceed
17:54:01 <ertes> cpdean: not by itself
17:54:26 <ertes> cpdean: abstractions and the module system do that for the most part
17:54:30 <EvanR> cpdean: id say haskells module system enforces a sort of organization... 
17:55:00 <ertes> cpdean: but of course the kind of abstractions you find in haskell are heavily type-driven
17:55:26 <cpdean> what's haskell's module system got over other languages that can store functions in files and folders?
17:55:51 * Toxaris cannot find Unicode linear function arrow :(
17:55:56 <ertes> cpdean: not much, though it is at least a proper module system (as opposed to an "include" mechanism)
17:56:03 <EvanR> that seems like a non sequitur
17:56:24 <cpdean> yeah snap i sure do not know what a proper vs improper module system is
17:56:32 <cpdean> but tangents
17:56:37 <EvanR> the module system isnt much to brag about
17:56:41 <ertes> cpdean: if you want to see a crazy advanced module system, you want to experience that of agda (but it makes you kinda depressed when returning to haskell)
17:56:58 <saml_> how would you express complex enough workflow? when a photo is uploaded, before it can be put into cdn, metadata has to be extracted. it should be reviewed by people that it meets criteria (no porn, no copyright problem..). watermarked thumbnails are generated... etc.   somethings could be done in parallel. some things need to be sequenced.
17:57:05 <cpdean> well i use computers a lot so i'm usually depressed
17:57:09 <SrPx> Toxaris: there is -o
17:57:10 <ertes> agda in general makes you depressed when returning to haskell =)
17:57:12 <cpdean> but anyway
17:57:15 <Toxaris> SrPx: So if we could derive x : A ⊢ x ⊗ x : A ⊗ A, we could type λx . x ⊗ x in the empty context
17:57:18 <EvanR> saml_: UML obv
17:57:32 <saml_> how would you implement this?
17:57:32 <cpdean> so what do you like to work on in haskell?
17:57:40 <saml_> a bunch of HTTP services?
17:57:49 <ertes> cpdean: i generally do everything in haskell
17:57:56 <cpdean> what's the everything?
17:58:16 <EvanR> saml_: perhaps a monolithic webserver app
17:58:17 <cpdean> etl? web services? build tooling?
17:58:20 <Axman6> I make web services, processing geospatial data, general every day tasks
17:58:43 <ertes> cpdean: a lot of systems programming in my case, and i'm interested in machine learning and game development in my spare time
17:58:52 <saml_> why do people not like monolitic webapp?
17:59:03 <Axman6> because they're not micro enough
17:59:09 <saml_> i can see it being a webapp that could possibly use queues
17:59:10 <EvanR> saml_: refugees from PHP
17:59:14 <Zemyla> Okay, question. A cycle-free Applicative parser is equivalent to regexes, right?
17:59:27 <SrPx> Toxaris: sure?
17:59:32 <cpdean> i'm not savvy on what systems programming means... i've heard it mean everything from the internals of postgres to automating dep packages getting installed
17:59:46 <Toxaris> SrPx: Hmm, I was going to say: "But luckily, we can only derive x : A, x : A ⊢ x ⊗ x : A ⊗ A, so to speak". But now I'm not sure that is helpful.
17:59:51 <cpdean> (and its clear that ansible != C)
17:59:56 <Toxaris> SrPx: I mean, you got that already, right?
18:00:17 <ertes> saml_: i've used a monad that is isomorphic (type-wise) to CofreeT to express complicated, delimited workflows
18:00:44 <ertes> saml_: but i haven't done it for a long time, so the library i wrote for it has bitrotted by now…  you can still look at it to get some inspiration though
18:00:56 <ertes> https://hackage.haskell.org/package/continue
18:01:04 <SrPx> Toxaris: I think I did, actually, if by that you mean that having a single context with x:A isn't enough 
18:01:20 <ertes> saml_: if you're lucky it may even still compile
18:01:25 <saml_> thanks ertes 
18:01:59 <Toxaris> SrPx: Maybe the key point is that when we typecheck λx . x ⊗ x, we would start with the λx. So we guess the A and continue with x : A ⊢ x ⊗ x. Now we guess that we need the x : A for the first premise, which we can solve with the Ax rule. But then the x : A is not available for the second premise anymore, so we backtrack and use x : A for the second premise. But then we cannot solve the first premise. So nothing to backtrack to.
18:02:24 <cpdean> ertes: so do you use haskell for systems programming?
18:02:26 <Axman6> cpdean: can you answer the question "what do you write in C++?" or "what do you write in Java?" the answers are very broad, and they're similarly broad in Haskell
18:02:55 <cpdean> i know haskell is general purpose but i just want to learn about how people go about solving problems in it
18:03:08 <EvanR> the best way is to learn by doing
18:03:19 <ertes> cpdean: it's the kind of programming that drives processes (in the "something happening" sense, not the "running executable" sense) on servers
18:03:21 <Toxaris> SrPx: A better algorithm would avoid the backtracking, because if we already used the x : A for the first premise, there is no point in not providing it. But you get the idea that we don't *merge* the contexts of the premises to get the context of the conclusion, but we *split* the context of the conclusion to get the contexts of the premises.
18:03:38 <SrPx> Toxaris: that all makes a lot of sense too
18:04:00 <cpdean> ertes: i'm not sure i follow :\
18:04:01 <ertes> cpdean: solving a problem in haskell for me usually involves making a model or a language for the problem
18:04:22 <ertes> or ideally reuse an existing one
18:04:37 <ertes> cpdean: in other words: your question is too vague =)
18:05:02 <Toxaris> SrPx: One way to implement the idea of "use everything you need for the first premise, and give left-overs to the second premise" can be implemented by having the type checker take a context, use what it wants, and return the unused part of the context together with the type assigned to the term.
18:05:26 <cpdean> agh i know -- i just want people to tell stories about how this tool helped them move more fluently through a problem
18:06:08 <Toxaris> SrPx: compare to many parser combinator libraries where a parser takes a string to parse, and returns the part of the string it didn't consume
18:06:35 <EvanR> cpdean: the first haskell program i wrote read a file of data in, processed it, and spit it into a database, it was really easy because i knew what the steps should have been, they were just list functions, and there was a mysql library
18:06:48 <SrPx> Toxaris: honestly all that you said so far makes complete sense. I'm still having some troupe connecting the pieces, though. Could you tell me how exactly is the type checker structured, overall? I.e., you said I go bottom-up, so (...)
18:06:50 <ertes> cpdean: unfortunately noone can be told what the haskell is…  you have to experience it for yourself =)
18:07:03 <Toxaris> SrPx: have you ever written a type checker?
18:07:04 <EvanR> ertes: no the matrix references, monochrom will yell at you
18:07:14 <ertes> cpdean: seriously though it's much easier to explain in the context of a concrete problem, and i have one for you, if you want to learn it
18:07:45 <ertes> EvanR: hmm…  what else?
18:08:11 <EvanR> how about dark city
18:08:16 <cpdean> ertes: sure, what should i work on?
18:08:29 <SrPx> Toxaris: say, when type-checking t1 ⊗ t2, I would first recursively type check t1, get its context (a) and type, then type check t2, get its context (b) and type? Is that correct?
18:08:34 <Axman6> cpdean: one of the big advantages of using haskell is that you often spend a fair amount of time thinking about the types of the data you need to work with, this can help you build up a much clearer model of what the app will need to do before beginning to write it. some developers dislike thinking before attempting to solve a problem though, and because of this decide Haskell is too hard.
18:08:48 <SrPx> Toxaris: once or twice in my life for the STLC, not much was learned, though
18:09:08 <ertes> EvanR: hmm, while i love that one, none of the quotes work here =/
18:09:20 <ertes> cpdean: the good old hangman game
18:09:25 <ertes> cpdean: a simple command line guess game
18:09:52 <ertes> cpdean: start with the most naive implementation you can think of, and i'll show you how to haskell-engineer the crap out of it =)
18:09:59 <SrPx> ah I also implemented that "simpler easier" system, but again, not much was learned about reading that thing (I don't know its name)
18:10:18 <EvanR> dynamic languages let you start writing code without knowing what youre really doing, and make the cost of giving up and starting over (perhaps with the same result) really low
18:10:19 <cpdean> ugh but i've read that chapter on the io monad like three times and what is even a category
18:10:33 <EvanR> doing that isnt as fun in haskell, you kind of want to get closer to correct the first time
18:10:38 <ertes> cpdean: learn the basics first
18:10:59 <cpdean> the helloworld chapter was surprisingly wordy in learnyouahaskell
18:11:13 <Toxaris> SrPx: Ah I see what you mean. Ok, you could actually do it like this. But usually, the context is not returned by the type checker, but provided as an input.
18:11:14 <EvanR> LYAH is pretty bad
18:11:14 <ertes> cpdean: learn the basic syntax, how to read types, how functions work (both on the value and the type level), etc.
18:11:39 <Toxaris> SrPx: So a typical type checker is a function: typecheck :: Context -> Term -> Maybe Type
18:11:41 <cpdean> but LYAH is so colorful and catchy
18:11:49 <EvanR> yeah, its like why's guide to ruby
18:12:13 <ertes> cpdean: try this one: https://en.wikibooks.org/wiki/Haskell
18:12:23 <ertes> it's not perfect, but good enough
18:12:33 <ertes> learn everything from the "Haskell Basics" track
18:12:34 <cpdean> k
18:12:54 <ertes> and "Elementary Haskell", too
18:13:22 <ertes> once you're done with that, learn this:  https://www.vex.net/~trebla/haskell/IO.xhtml
18:13:32 <geekosaur> wait, if something was talking about IO and mentioned categories, and it was not specifically about Haskell's Monad relates to CT monads, it needs to be shot and its corpse launched into the sun
18:13:32 <ertes> after that You Can Write Programs In Haskell
18:13:34 <SrPx> Toxaris: not sure I understand that typical type checker, why is it like that?
18:13:50 <Toxaris> the ones you wrote where not like that?
18:14:20 <SrPx> Toxaris: don't remember honestly, so long ago
18:14:29 <cpdean> ertes: all right, i'll let you know how it goes, thanks!
18:15:06 <SrPx> I'll look for a STLC type checker now
18:15:14 <SrPx> looking at it will help 
18:15:28 <ertes> cpdean: my pleasure
18:16:51 <EvanR> .oO IO tutorial which only uses Applicative
18:17:18 <EvanR> to throw off the monad tutorial people
18:17:42 <geppettodivacin> EvanR: Does such a tutorial exist?
18:17:52 <EvanR> ive never seen one
18:18:24 <EvanR> but the punchline would be in the comments "what does this have to do with monads" "nothing"
18:18:27 <geppettodivacin> I'm not sure if I'd know a nice-looking way to write IO code with only Applicative.
18:18:47 <shirt> what is wrong with lambdabot?
18:19:14 <EvanR> lots of lets and liftAN's
18:19:19 <Rarrikins> shirt: Circuititis.
18:19:24 <geekosaur> it pinged out several hours ago. no clue
18:19:25 <ertes> geppettodivacin: try to write this one:  getLine >>= putStrLn
18:19:51 <shirt> i rely on lambdabot for his @pl command, is there an online version somewhere?
18:20:16 <ertes> lambdabot's a dude?
18:20:19 <ertes> hmm
18:20:42 <shirt> @pl (\x y -> f (x:y))
18:20:54 <grantwu> shirt: http://pointfree.io/
18:22:16 <shirt> grantwu: awesome! you made that?
18:23:06 <ertes> shirt: you could also learn how to do it…  @pl does a fancy version of the SK transform (a.k.a. abstraction elimination) where (<*>) is S and 'pure' is K
18:23:23 <ertes> (that's where all the liftA* come from when you use @pl)
18:24:01 <ertes> shirt: ironically i found this tutorial to be very helpful: http://www.madore.org/~david/programs/unlambda/#lambda_elim
18:24:23 <grantwu> shirt: What? No
18:24:37 <grantwu> I just knew it existed
18:24:49 <Toxaris> what is the best way to force the spine of a [TVar a]?
18:24:58 <shirt> ertes: cool thanks
18:25:21 <Toxaris> There is no NFData (TVar a). I guess length ... `seq` ... would work, but feels hacky. Is there a standard "forceSpine" function somwhere?
18:26:29 <ertes> Toxaris: something like (foldl' (\r x -> x `seq` r) ())?
18:26:47 <ertes> it gives you an rwhnf-style function for [a]
18:26:52 <ertes> for the spine
18:28:30 <Toxaris> yes something like this... hmm, this might work: foldl' (flip seq) (atomically $ do ... listOfTVars ...) listOfTVars
18:28:48 <EvanR> i was wondering what TVars had to do with this 
18:29:08 <EvanR> to force a spine of a list, it doesnt matter whats in it
18:29:27 <Toxaris> EvanR: ah I first tried deepseq, because I'm also fine with forcing the list contents, but the NFData (TVar ...) instance was missing.
18:29:27 <ertes> Toxaris: but forcing the spine of a list in general sounds like a suspicious thing to do
18:29:52 <EvanR> Toxaris: because generally lists dont have NF (normal form)
18:30:09 <ertes> Toxaris: what are you trying to do?
18:30:09 <EvanR> oh... is that the problem?
18:30:10 <Toxaris> ertes: My (possibly stupid) goal is to keep the computation of the list of relevant tvars out of the dynamic extent of the atomically block
18:30:31 <EvanR> yes thats a weird goal
18:30:45 <ertes> Toxaris: i'm not even sure what that means
18:31:44 <EvanR> you can add an instance of NFData for TVars if you want, they can be evaluated as much as you wish
18:31:59 <EvanR> but this question deserves a reflection on why you want to force stuff
18:32:05 <ertes> well…
18:32:26 <ertes> i would read "No instance for (TVar …" as "you're doing something suspicious"
18:32:31 <Toxaris> oh but adding NFData orphan instances feels even more wrong then forcing lists
18:32:34 <ertes> so it's probably good that there is no such instance =)
18:32:50 <ertes> + NFData
18:33:27 <ertes> Toxaris: so you have an STM transaction that returns a list of TVar
18:33:33 <Toxaris> ertes: no
18:33:46 <Toxaris> I have pure, stateless code that returns a list of TVars
18:34:11 <Toxaris> and then I want to do something to all of them.
18:34:22 <ertes> ok, why would you want to force the spine?
18:35:20 <Toxaris> because I want to avoid reading the first TVar before finishing my stateless computation
18:35:22 <EvanR> furthermore, once you force the spine of that list, you then go into your atomically block and start doing more lazy evaluation to acquire TVars
18:35:22 <EvanR> yes, suspicious
18:35:22 <anks> Hi, how can easily I convert strict bytestring to a datatype?
18:35:22 <anks> or parse rather
18:35:22 <EvanR> Toxaris: maybe you are thinking whatever is in the atomically needs to be especially fast
18:35:34 <haskell961richar> Hello, can someone please help me in understanding why this works in GHCI, but, why does it not compile to an executable? http://lpaste.net/257858
18:35:43 <EvanR> why?
18:35:47 <dmj`> anks: attoparsec
18:35:53 <ertes> Toxaris: does it interfere with something?
18:36:03 <ertes> like I/O?
18:36:03 <Toxaris> EvanR: yes, my (possibly stupid) goal is to avoid too much work between the first TVar read and the end of the atomically
18:36:21 <anks> actually i was looking for something more adhoc .. damn, why does it have to be so hard :|
18:36:42 <ertes> anks: binary? cereal?
18:36:52 <anks> binary uses lazy bytestrings
18:36:53 <EvanR> Toxaris: well this probably isnt worth it, if your block retries, later it will come back with evaluated list nodes and tvars and start over
18:37:05 <ertes> anks: you can convert strict bytestrings to lazy ones
18:37:39 <anks> hmm well thats a solution, what about performance cost?
18:38:11 <ertes> anks: reasonable for most purposes…  in other words: if you're worried about performance, you should benchmark
18:38:18 <dmj`> haskell961richar: ghci probably has an extension enabled that isn't specified in your module or in the cabal file itself
18:38:46 <anks> ok, gonna try it :), thanks
18:38:48 <EvanR> Toxaris: also if you use a regular forM_ loop and inside do atomically on each TVars, itll be equivalent to your foldl idea (assuming you reword it to be correct)
18:39:10 <EvanR> and assuming this list doesnt contain bottoms
18:40:17 <ertes> Toxaris: i'm wondering what algorithm expensively comes up with a list of TVar, and whether that one should be improved instead, for example by using the right data structures
18:41:32 <ertes> Toxaris: another thing to keep in mind is sharing: retrying likely won't do the same work twice
18:42:00 <ertes> (unless the work is part of the transaction, not a computation that was forced by it)
18:42:32 <Toxaris> ertes: yes I got that
18:45:18 <Toxaris> ertes: there is a datastructure full of counters. the algorithm selects few of them for increment. the increment needs to be coordinated. there is not much else going on in the code.
18:45:53 <ertes> Toxaris: the only cases when i would really force a computation that is going to happen anyway is when it would otherwise be building up thunks, or when it interferes with I/O:  do putStr "Starting computation... "; hFlush stdout; let { !x = … }; putStrLn "Done."
18:46:48 <Toxaris> ertes: so even if I would improve the algorithm's implementation, it will still be orders of magnitude slower than the counter increments.
18:47:59 <Toxaris> ertes: hmm? concurrency is all about forcing computations that would happen anyway, because I want to control which thread does them
18:49:31 <ertes> Toxaris: the reason why i find this suspicous is that the spine of the list shouldn't actually even depend on anything
18:49:48 <Toxaris> anyway, you convinced me to ignore that line of thought and just make sure the list of tvars is shared so it is not recomputed on retry
18:50:31 <ertes> you don't have to do that…  as long as a transaction *could* retry, everything it references is still in memory
18:50:35 <Toxaris> ertes: hmm? I essentially do a filter over my datastructure, so the evaluate the spine of the list, I need to evaluate all of the conditions from the filter to see whether there is another element or not
18:50:51 <ertes> ah, sure
18:51:27 <geppettodivacin> ertes: The only way I can get the types to semi make sense is by doing putStrLn <$> getLine, and there doesn't seem to be a join-like function for Applicative.
18:51:44 <ertes> geppettodivacin: you can't write it using Applicative
18:51:46 <Toxaris> "there doesn't seem to be a join-like function for Applicative" Indeed
18:51:55 <geppettodivacin> Ah. Well then.
18:52:14 <Toxaris> Monad = Applicative + join
18:52:19 <ertes> geppettodivacin: i didn't expect you to try this hard…  otherwise i would have hinted at its impossibility…  sorry =)
18:52:41 <geppettodivacin> I suppose that would be why no one has done an IO tutorial with Aplicative.
18:53:08 <haskell961richar> dmj`: ahhh thank you, that was it (it turns out it was missing NoMonomorphismRestriction). I haven't had to use extensions before so I'm curious if enabling them are viewed negatively?
18:53:25 <ertes> geppettodivacin: that would really be just an Applicative tutorial that also happens to apply to IO
18:53:38 <Rarrikins> haskell961richar: No, it's pretty common.
18:53:43 <dmj`> ^
18:54:01 <geppettodivacin> ertes: I learned something about Applicatives in the process. :)
18:54:08 <geekosaur> haskell961richar, some of them are widely used, a few are considered dangerous. we were actually discussing having the monomorphism restriction removed or disabled by default in the next version of the standard, earlier today
18:54:18 <ertes> haskell961richar: using extensions is very common, but using the NoMonomorphismRestriction extension isn't =)
18:54:47 <srpx> What is the meaning of a "!" before a context? http://i.imgur.com/auFYn23.png
18:55:20 <Toxaris> ertes: I guess I should use `let shared = foo bar baz in atomically $ do ... shared ...` instead of `atomically $ do ... foo bar baz ...`, right?
18:55:50 <haskell961richar> oh no :o I think I should read a bit about that feature then
18:56:07 <ertes> Toxaris: if you're only going to refer to 'shared' once in your code, it doesn't do sharing
18:56:39 <ertes> Toxaris: but again: the retryability of transactions already makes sure that values that might be reused are actually kept referenced, so they will not be recomputed
18:56:41 <Toxaris> srpx, I guess it means that each type in the context gets a !
18:57:18 <Toxaris> ertes: but the do notation will put the ocurrence of shared under a lambda
18:57:42 <ertes> Toxaris: that doesn't matter
18:57:52 <ertes> sharing only occurs when there are at least two references
18:58:16 <Toxaris> srpx: then the rule makes sense to me: if we can construct an A out of the stuff in Gamma, we can also construct a source of many As if we actually have a source of many of the things in the context
18:58:25 <srpx> Toxaris: yes that is even explained on the paper, sorry
18:59:18 <ertes> geekosaur: if ScopedTypeVariables finally becomes standard, i'm fine with making NoMMR default…  otherwise please don't…
19:00:31 <geekosaur> that's ... interesting. nobody in the earlier discussion could think of a real-world breakage mode...
19:02:28 <red13> Is ScopedTypeVariables a way to avoid proxy types?
19:02:40 <ertes> geekosaur: i'm not worried so much about top-level definitions, but for local definitions MMR is really useful, most notably because there is no sane *and* standard way to say: "this thing is of the same type as this in the top-level thing"
19:03:11 <ertes> geekosaur: that's why for local definitions i usually prefer to leave out type signatures and let MMR do its thing
19:03:55 <geekosaur> ertes, local definitions have their own thing though (MonoLocalBinds)
19:04:10 <ertes> geekosaur: oh…  then nevermind =)
19:04:36 <red13> Can I get a link, i think I'm a bit behind in this discussion
19:04:57 <ertes> red13: ScopedTypeVariables lets you refer to type variables in a larger context
19:04:59 <MarcelineVQ> ScopedTypeVariables is sliced bread
19:05:23 <ertes> red13: you write a function with a local definition, the local definition's type signature can refer to types bound by the outer function
19:05:49 <red13> I have had problems with that in the past
19:06:45 <ertes> geekosaur: i didn't know that…  in that case i'd actually vote for making NoMMR default, mostly because it makes GHCi a bit easier to use
19:07:14 <grantwu> Doesn't GHCi have NoMMR on by default?
19:07:15 <geekosaur> ghci already has its own hack there, since 7.something
19:07:23 <geekosaur> try ":showi language"
19:07:35 <ertes> hmm, i never noticed that, thanks
19:07:57 <red13> Ghc assigns a new type, while it should use the assignment made at top level, like if I use 'f a' both in the type of a function, and then again in a where clause, it refuses to treat these as the same type... I can't quite remember exactly where it sprang up...
19:08:28 <geekosaur> right that's the usual use case for ScopedTypeVariables (and mark a with a 'forall' in function type sig)
19:09:25 <anks> guys do you know why this simple pipes function allocates around 300mb of ram on 12 mb file? http://lpaste.net/5141286220810158080
19:10:36 <red13> Oh! What's worse is if a function of a class does not use all the parameters of the class, i guess that's what proxy types are about, I can't tell if that's a different issue to this MMR or ScopedTypeVariables stuff...
19:10:39 <anks> it doesn't, actually
19:10:48 <anks> i forgot to recompile
19:10:55 <ertes> anks: yeah, i was really confused
19:11:00 <anks> -_-
19:11:09 <ertes> that one shouldn't really do anything interesting at all
19:11:14 <anks> and it doesnt
19:11:21 <geekosaur> red14, that is unrelated and generally requires something like a proxy
19:11:23 <anks> i want it to parse entire file
19:11:29 <geekosaur> er red13 ^
19:11:41 <ertes> anks: first of all you have to 'yield' the stuff you read
19:12:02 <ertes> otherwise the next stage of the pipeline (stream0FrameDecoder) won't receive anything
19:12:12 <Toxaris> ertes, there can be sharing even if there is only one reference to a variable: http://lpaste.net/257859
19:12:13 <geekosaur> because without either a proxy or a fundep/type family, it can't reliably infer the instance to use
19:12:30 <anks> right
19:12:38 <anks> but
19:12:40 <ertes> anks: next you probably want to use 'forever' in that one
19:12:51 <ertes> otherwise it awaits once and yields once
19:12:56 <anks> hget should yield entire file
19:13:00 <ertes> better use Pipes.Prelude.map
19:13:07 <ertes> anks: where is hGet from?
19:13:21 <geekosaur> @index hGet
19:13:25 <geekosaur> whoops, right.
19:13:28 <geekosaur> System.IO
19:13:38 <anks> dont remember i copypasted it from pipes or pipes bytestring or sthing like this
19:13:52 <geekosaur> unless they're using a different one for some reason (ByteString provides its own iirc)
19:14:08 <ertes> geekosaur: i'm pretty sure it's not the System.IO one
19:14:15 <ertes> otherwise this whole thing would be a type error
19:14:16 <red13> I had used type family's instead of proxy types, but what's fundeps?
19:14:56 <ertes> Toxaris: "reference" is not the same thing as "name"
19:15:10 <geekosaur> red13, functional dependencies. basically telling the compiler that if it knows some of the types in an instance, it can infer others
19:15:18 <ertes> Toxaris: you have multiple references to (expensive ()), one in each list cons
19:15:36 <geekosaur> red13, https://wiki.haskell.org/Functional_dependencies
19:16:36 <ertes> anks: i highly recommend that you use the 'pipes-bytestring' library for the reading part
19:17:33 <ertes> oh wait…  you might be already doing that
19:17:38 <ertes> so that's where hGet comes from
19:17:46 <anks> Yes, it does
19:17:50 <anks> from internals i guess
19:18:05 <red13> That seems like forall
19:18:09 <anks> anyway, the pipe in the middle was faulty
19:18:29 <ertes> anks: yeah, but you can just use Pipes.Prelude.map for that one
19:18:30 <anks> not i recursively calls itself
19:18:38 <anks> oh
19:18:53 <anks> it*
19:19:04 <ertes> anks: whenever you see the pattern (forever (await >>= yield . f)), consider using 'Pp.map'
19:20:06 <Toxaris> ertes: yes, there is one occurrence of shared, but because it is under a lambda, the map will execute it multiple times. Now wouldn't the same problem exist with the retry of an STM transaction? To make sure the expensive expression is not reexecuted with each retry, we give it a name so that the first execution will force and store the value, and later execution will just look the value up?
19:20:39 <geekosaur> red13, no. it's kinda the opposite: for particular type vars on the left of a -> in a fundep, all the type vars on the right will always have specific values. it doesn't say what values, it just lets the compiler safely infer that, for a fundep `a b -> c`, if it knows a and b then c must be some specific type (instead of the default where it is a `forall`)
19:21:18 <ertes> Toxaris: the problem there has nothing to do with lambdas, but with the fact that function applications are never shared
19:21:29 <ertes> Toxaris: f x + f x  -- evaluated twice
19:21:38 <ertes> well
19:21:44 <ertes> not never, but only in certain well understood cases
19:21:59 <ertes> put differently:  GHC doesn't do CSE in general, it only does sharing in general
19:24:45 <geekosaur> red13, althoiugh I note nobody updated that page. there hadn't ever been proof that fundeps were sound so people were leery of standardizing it... and eventually it was proved that it was not in fact completely sound and you can with some work abuse the type system ("derive unsafeCoerce" as it's usually described: make the compiler treat one type as another)
19:25:08 <red13> Is it like exists?
19:25:27 <glguy> geekosaur: Which unsafe coerce was that?
19:26:01 <glguy> The previous problems from fundeps came from GHC not actually checking that they were satisfied when you made an instance
19:26:21 <red13> So fundeps are not dependable or fun...
19:26:28 <glguy> No, they're fine
19:26:41 <red13> But underexposed?
19:26:48 <red13> Unsafecoerce*
19:26:56 <red13> Sorry, autocorrect
19:27:10 <glguy> No, not unsafecoerce
19:27:41 <Toxaris> ertes: but if I replace `\x -> shared` by `const shared`, the behavior changes. So this has to do with lambdas. See updated http://lpaste.net/257859
19:27:46 <red13> Then what is geekosaur saying?
19:28:00 <glguy> Dunno, that's why I asked for clarification
19:28:42 <geekosaur> I am looking for the reference. someone was trying to figure out why there were programs that could be expressed by fundeps but not by type families
19:29:05 <red13> Cool
19:29:05 <ertes> Toxaris: that's because in a very subtle way 'const' actually introduces sharing =)
19:29:36 <geekosaur> and I thought it was more than just a ghc checking bug but an actual weakness
19:29:39 <Toxaris> ertes: well, I would say lambda destroys sharing, but that's really the same thing, right.
19:30:10 <ertes> Toxaris: by passing this value to 'map', you're sharing it: const x = \_ -> x
19:30:17 <ertes> and it in turn shares the 'x'
19:30:39 <red13> I can't see how a implies b could lead to c = d, or however it's communicated
19:32:03 <ertes> Toxaris: a lambda shares its *argument* (under the lambda), but its result isn't shared even if it doesn't actually depend on the argument
19:32:49 <Toxaris> ertes: sure.
19:32:53 <Toxaris> ertes: what I said.
19:34:49 <geekosaur> ok, I'm not finding it *and* I am now vaguely recalling that last time this came up we found that it was in fact not the theoretical issue I keep remembering it as.
19:35:16 <geekosaur> still, I think the theoretical folks still dislike importing Prolog into the type system >.>
19:35:22 <Toxaris> ertes: or more precisely, we can inline let bindings for variables that are used only once without changing operational semantics *as long as there is no lambda between the let and the variable occurrence*
19:36:00 <red13> That seems a bit confused
19:36:00 <MarcelineVQ> geekosaur: was it an issue in the trac or something more broad like the outsidein paper?
19:36:27 <ertes> Toxaris: yeah, that sounds right up to RULES-based optimisations
19:36:29 <geekosaur> it was a discussion on cafe. there may have been a trac issue filed, I don't recall offhand
19:36:41 <geekosaur> probably was if it was found to be a bug in checking
19:37:13 <red13> Was it this? https://groups.google.com/forum/m/#!topic/haskell-cafe/SMvWQD5sKr0
19:37:41 <ertes> Toxaris: i'm not entirely sure if RULES can have 'let' in the LHS
19:37:50 <red13> That's the closest I could find using Google and what you were saying...
19:38:10 <geekosaur> no, not that thread. it specifically started out with trying to implement a working program using FDs using TFs
19:38:52 <Toxaris> yeah I wasn't thinking about RULES here :)
19:39:13 <geekosaur> and finding that the errors they got with TFs were actual type soundness issues that could be used to derive unsafeCoerce using the FD version under certain circumstances
19:39:20 <geekosaur> (involving multiple modules iirc)
19:39:50 <red13> https://mail.haskell.org/pipermail/haskell-cafe/2012-June/101629.html
19:40:02 <red13> That one?
19:40:13 <geekosaur> nope
19:40:17 <Toxaris> ertes: I guess you can trigger additional rules by inlining, so who knows what will happen
19:40:23 <red13> Ok I give up
19:40:33 <ertes> Toxaris: no i mean the choice between writing (let x = y in f x) and (f y) could influence whether some rules fire
19:40:37 <geekosaur> that message actually considers FDs superior
19:40:43 <ertes> Toxaris: yeah
19:41:15 <geekosaur> it took me a fair amount of digging last time. maybe I should trawl my logs
19:41:36 <Toxaris> this choice can even influence whether some rules fire if rules cannot match on let bindings, because a rule might match on `f y` but not on `f x`
19:42:21 <ertes> Toxaris: on the other hand i'd expect GHC to just expand the 'let' before applying rules
19:43:35 <Toxaris> ertes: but there's some heuristics for that, isn't there? or would ghc inline all non-recursive bindings?
19:43:44 <Toxaris> that sounds dangerous ...
19:44:24 <ertes> Toxaris: i mean in this particular case (single reference, no recursion) it seems like a safe thing to do
19:44:43 <ertes> but i really don't know what it does
19:57:20 <red13> All the functions who independent, throw monads about me
19:58:01 <ertes> All your base are belong to us
19:58:11 <MarcelineVQ> but I, being monadic, have only my continuations
19:58:47 <shanemikel> oh no... not another TMR poetry issue
19:59:34 <MarcelineVQ> compose carefully, for you return on my kleisels
20:01:44 <red13> Type family counseling for dysfunctional dependencies
20:04:14 <shanemikel> lol
20:07:55 <ertes> why is that funny?  it has not a single duality joke…  i'm nfused
20:08:22 <mmaruseacph2> @remember red13 Type family counseling for dysfunctional dependencies
20:08:34 <ertes> I will never forget.
20:09:05 <ludat> hi everyone, is there a common template for snap projects? like a stack template
20:09:14 <mmaruseacph2> !remember red13 Type family counseling for dysfunctional dependencies 
20:09:31 <mmaruseacph2> hmm, seems I cannot tell lambdabot to store that quote :(
20:09:33 <ertes> I will never forget.
20:09:50 <ertes> mmaruseacph2: sorry…  i thought my words in the absence of lambdabot would be comforting =/
20:09:55 <ertes> i know it's hard
20:10:27 <red13> > "come in lambdabot"
20:10:35 <mmaruseacph2> oh, fool of a me
20:10:45 <mmaruseacph2> I didn't see lambdabot is not around
20:10:55 <ertes> yeah, it's weird
20:11:06 <red13> It's at a rave
20:11:42 <red13> This is worse than brexit
20:12:06 <Clint> apt-get install lambdabot
20:12:08 <ertes> #haskell without lambdabot is almost like anime without high-school
20:13:26 <red13> It's a foreign worker and is on strike...
20:13:46 <red13> Seriously though, what happened!? How can this be fixed?
20:16:42 <EvanR> thats one way, have someone chnick to lambdabot and reguritate ghci and other utilities
20:18:51 <red13> But why did it go down? Was it ddos by anonymous?
20:20:10 <EvanR> does it need a reason to happen?
20:25:34 <ab9rf> out of kibble error
20:30:18 <Axman6> lambdabot is getting fairly long in the tooth and occasionally needs a nap
20:31:47 <ab9rf> bot years must be shorter than human yaers
20:32:11 <Axman6> much
20:33:05 <Axman6> but also lambdabot has been around for quite a long time, possibly over a decade?
20:33:35 <tmciver> Hello. I have some questions about typeclasses and using instances of them. I'd like to ask about their use in the cryptography lib cacophony in particular. There's a typeclass 'Cipher' here: https://github.com/centromere/cacophony/blob/80adb3c69dd850794b038a95364693d9503a24ce/src/Crypto/Noise/Cipher.hs#L20
20:34:19 <tmciver> And here's a call to the 'cipherEncrypt' function: https://github.com/centromere/cacophony/blob/80adb3c69dd850794b038a95364693d9503a24ce/src/Crypto/Noise/Internal/CipherState.hs#L35
20:35:03 <tmciver> My first question is how can I tell what instance that function is being called on? (there are two instances defined in the lib, I believe).
20:35:30 <Axman6> it can be called on any instance, it will depend on the context which c is being used
20:35:49 <Axman6> that function is generic, in the same was that functions like mapM are
20:36:46 <tmciver> Axman6: so it depends on the context of the call to 'encryptAndIncrement'? (https://github.com/centromere/cacophony/blob/80adb3c69dd850794b038a95364693d9503a24ce/src/Crypto/Noise/Internal/CipherState.hs#L26)
20:37:01 <Axman6> yes
20:37:23 <Axman6> that code can work on any type C which implementes Cipher
20:37:26 <Axman6> s/C/c
20:38:53 <tmciver> Got it. So if I want to call 'encryptAndIncrement' using a particular instance, I'd have to add the appropriate type to the call?
20:39:47 <Axman6> possibly, if it can't be infered from the other results
20:40:27 <Axman6> if you had something that was expecting to use a CipherState AES for exmple, and you passed it the returned CipherState c, then that would mean that c is infered to be AES
20:41:02 <EvanR> what is the convention for a monad that can "fail", dont use fail, dont call the fail action mzero, make up some new name?
20:41:18 <EvanR> convention for naming the action that explicitly fails
20:42:13 <tmciver> Axman6: Thanks.
20:43:00 <dmwit> :t throwError -- EvanR
20:43:14 <dmwit> no bot?
20:43:22 <geekosaur> no bot
20:43:51 <dmwit> bummer
20:44:27 <EvanR> im not planning to catch errors, its not even errors
20:45:06 <tswett> A few hours up, I asked if there's a word for a function whose right-hand side consists entirely of parameters and fully applied constructors. Like this...
20:45:07 <EvanR> and isnt it not recommended to expose functionality as literally the MonadClass method names
20:45:12 <tswett> f x y z = (Left x, Left y : Right z : x)
20:45:33 <tswett> I didn't get a response. I think I'll call those functions "constructor trees".
20:45:44 <Axman6> tswett: possibly smart constructors
20:45:48 <kadoban> tswett: Does it need a name?
20:45:52 <Axman6> but that's a bit more
20:45:53 <EvanR> if it wasnt for Left and Right being "free variables" one way to say it is thats a combinator
20:46:09 <Axman6> it's not really something that's particularly interesting, so likely doesn't have a name
20:46:15 <EvanR> and (,) and :
20:46:32 <tswett> Well, the context would be something like: "This category doesn't contain all functions; the only functions it contains are ____."
20:48:02 * hackagebot sump 0.1.0.2 - A Haskell interface to SUMP-compatible logic analyzers  https://hackage.haskell.org/package/sump-0.1.0.2 (BenGamari)
20:48:04 * hackagebot iproute 1.7.1 - IP Routing Table  https://hackage.haskell.org/package/iproute-1.7.1 (KazuYamamoto)
20:48:06 * hackagebot dns 2.0.7 - DNS library in Haskell  https://hackage.haskell.org/package/dns-2.0.7 (KazuYamamoto)
20:49:50 <EvanR> i wish i could call it fail...
20:50:18 <Axman6> be more dramatic and call it die
20:51:23 <Rotaerk> slashWrist
20:53:45 <EvanR> fail is a much more conventional word i think for this... stupid haskell with its namespace squatting
20:54:20 <EvanR> i went with retry, STM wont make sense here
20:54:28 <dmwit> Axman6: System.Exit.die already exists
20:55:09 <dmwit> You wouldn't want to have two modules with the same name, would you? =P
20:59:04 <bollu> :t runST
20:59:26 <bollu> runST :: (forall s. ST s a) -> a <- how does this work?
20:59:47 <ab9rf> heh
20:59:48 <EvanR> its a rank-2 polymorphic type
21:00:00 <EvanR> because of the placement and scope of the forall s
21:00:02 <bollu> EvanR: because of the enclosed forall s, right?
21:00:28 <EvanR> it means you can only pass in an ST action which accepts any s whatsoever
21:00:29 <bollu> EvanR: okay, here has been my confusion with higher ranked types. When I write id x = x, is the type of id forall x. x -> x?
21:00:37 <EvanR> not accepts, but is parameterized by
21:00:44 <EvanR> yeah
21:01:16 <bollu> okay, now in the case of fmap, is it fmap :: forall f. forall a. forall b, Functor f => (a -> b) -> f a -> f b?
21:01:33 <geekosaur> bollu, but when you pass id as a function to something else, it is no longer a `forall` --- its type "escapes" into the surrounding context
21:01:35 <bollu> in the sense that, the type variables are all universally quantified by GHC, right?
21:01:42 <EvanR> yes, you can also collapse it into forall f a b . 
21:01:43 <dmwit> bollu: So far, so good.
21:01:48 <bollu> geekosaur: yes, it is this distinction that I do not understand
21:02:10 <bollu> so how is this different from, say, fmap :: forall a b, (a -> b) -> (forall f. f a -> f b) ?
21:02:28 <bollu> how does the forall f. on the inside behave like a exists f. to everyone outside?
21:02:39 <geekosaur> so, map :: (a -> b) -> ([a] -> [b]) -- here, the (a -> b) is not and must not be an internal forall; the forall migrates to the top level
21:02:40 <dmwit> bollu: It might help to look at System F (on which GHC's core language was based). In System F, `forall`s must be explicitly introduced and eliminated (in the same way arrows are explicitly introduced -- with lambdas -- and eliminated -- with application -- in the usual lambda calculus).
21:03:10 <geekosaur> in rank-1 types that forall always migrates to the top level
21:03:24 <dmwit> bollu: When you have written enough type abstractions and type applications by hand, you will start wondering: "When can my computer guess the right places for abstractions and applications for me?".
21:03:36 <ab9rf> heh
21:03:41 <bollu> dmwit: because algorithm W?
21:04:23 <dmwit> Algorithm W is one answer to that question, yes.
21:04:41 <bollu> geekosaur: so, well, what exactly does the rank 2 type represent?
21:04:48 <bollu> also, if I had an exists in Haskell
21:04:50 <red13_> That's my new dj name
21:04:53 <bollu> could I write the type of runST as
21:05:11 <bollu> runST :: exists s. forall a. ST s a -> a?
21:05:30 <bollu> because I'm saying that "look, I know that there is some s, but I can't tell you which one"?
21:05:32 <geekosaur> it represents a forall that is inside of parentheses (or other brackets that can limit the scope of a type within them --- but that limit only happens with an explicit forall)
21:05:36 <dmwit> bollu: forall and exists are related by negation in a similar way to how "and" and "or" are related by negation.
21:05:48 <dmwit> bollu: And "going to the left of an arrow" is a bit like negation.
21:05:53 <bollu> dmwit: that is in propositional calculus, no? I don't see how it works here
21:06:05 <geekosaur> thus the (forall a. ST s a) is rank-2 in runST :: (forall a. ST s a) -> a
21:06:26 <bollu> geekosaur: so, how do I think about the scoped forall?
21:06:41 <bollu> geekosaur: like, how do I reason about it?
21:06:43 <dmwit> bollu: What do you mean by "how it works"?
21:06:55 <bollu> dmwit: can you expand on the "going backwards on an arrow" part? 
21:07:02 <bollu> dmwit: I mean, like, mathematically
21:07:03 <geekosaur> er, we both typoed that btw
21:07:09 <geekosaur> its forall s. not forall a.
21:07:42 <dmwit> bollu: Sure. So, you could think of a type `a` as being a theorem in the usual way, by associating values of type `a` with proofs of the theorem.
21:07:59 <geekosaur> this is key; since there is no way to do anything with the "s", it is (a) a phantom type (b) and it cannot escape, since the forall means it cannot be given a type outside of its scope
21:08:17 <dmwit> bollu: Then `a -> Void` is a pretty good type for the theorem "not `a`" -- that is, `a -> Void` is inhabited just when `a` is not inhabited.
21:08:28 <bollu> dmwit: okay, so far with you
21:08:43 <bollu> dmwit: wait, one sec
21:08:54 <geekosaur> which is the trick behind runST: everything is parameterized with this "s" that you cannot access in any way except by it being inferred in types of things in the runST-d code; this ensures anything dependent on that type cannot escape the runST
21:09:03 <geekosaur> so you can hide mutability in there
21:09:03 <bollu> dmwit: when a is uninhabited, how does a -> Void have a member?
21:09:36 <dmwit> bollu: The function pattern matches on the value of `a`. There are no cases in the match, so it is easy to return `Void` from each case. =)
21:10:22 <dmwit> bollu: For a concrete example, you might ask, "Why does `Void -> Void` have an inhabitant?".)
21:10:34 <bollu> dmwit: it's something like it being vacuously trie?
21:10:37 <dmwit> indeed
21:10:42 <bollu> dmwit: because… id :: a -> a?
21:10:50 <dmwit> If you manage to call the function at all, you've already broken something, yeah? =)
21:11:10 <bollu> yes
21:11:15 <geekosaur> there are other uses for rank-2 types, notably when you want to pass a polymorphic function to something and use it at two different types therein. you cannot do this with a rank-1 type; its type would be fixed to one or the other type and the other use would be a type error
21:11:38 <bollu> geekosaur: example of that?
21:11:57 <dmwit> Continuing: The usual equation for relating exists and forall goes like "not (forall x. p x)" is the same as "exists x. not (p x)".
21:12:22 <bollu> geekosaur: so you mean like, if I want a g that uses a  function f, say, a -> a or something, and I want to establish "two different a's" in the same call to g?
21:12:40 <bollu> dmwit: that is the same as the logic one, correct?
21:12:46 <dmwit> Transcribing this to type theory with our above definition of not, we would say `(forall a. P a) -> Void` and `exists a. (P a -> Void)` are very similar types.
21:12:49 <geekosaur> mm, they're not real common, since many of the use cases are already covered by typeclasses (i.e. the simplest use I can think of would basically duplicate `show`)
21:13:18 <bollu> dmwit: I see
21:13:29 <dmwit> bollu: I don't really know what you mean by "the logic one". It's all logic as far as I can tell.
21:13:37 <bollu> dmwit: right
21:13:45 <bollu> dmwit: okay, so now the in the runST example
21:13:54 <bollu> dmwit: can you use a transformation to show that s is existential?
21:14:44 <geekosaur> f :: (forall m. Monoid m => m -> m -> m) {- which might be mappend -} -> Int -> Int -> String -> String -> (Int,String)
21:15:09 <bollu> geekosaur: interesting!
21:15:16 <geekosaur> without the forall, you could not apply the function parameter to both the Ints *and* the Strings; only one or the other
21:15:21 <geekosaur> with the forall, you can use it for both
21:15:25 <bollu> geekosaur: right, right
21:15:55 <geekosaur> of course, it's just mappend here; actual uses I have seen maybe 2 or 3 times since 2006
21:16:16 <bollu> right
21:16:20 <dmwit> bollu: I'm not so sure. There's a funny connection between the `a`s on the two sides of the arrows that makes me not so confident that `s` can sensibly be understood as existential.
21:16:21 <bollu> that's a cute use
21:16:22 <geekosaur> but when it does come up, a rank-1 world can't really handle it
21:16:28 <bollu> dmwit: I see
21:16:44 <bollu> geekosaur: let's say I see a complicated type signature
21:16:54 <bollu> geekosaur: and I want to check if a type variable in it is existential or not
21:16:55 <geekosaur> and I think the cases where it comes up mistly involve phantom types
21:17:19 <bollu> geekosaur: is there some principled transformation I can do / theorem I can / some *mathematical way* to deduce that some type variable is existential in the signature?
21:17:41 <ReinH> Yes, the same one that GHC uses.
21:17:43 <geekosaur> there is a forall that is not at the very start of the signature
21:18:02 <bollu> ReinH: which is that?
21:18:26 <bollu> geekosaur: but I have heard that if you have a rank 3 type, then the "twice nested" forall is a legit forall and not an existential or something like that?
21:18:38 <shanemikel> are you asking for an inference algorithm?
21:18:46 <geekosaur> hm, actually you said existential
21:18:49 <geekosaur> yeh, sorry
21:18:59 <geekosaur> so now you get into covariant vs. contravariant
21:19:23 <bollu> shanemikel: I'm asking for an algorithm that lets me determine if a type variable is existential in a given signature. If that is an inference algorithm, then yes
21:19:26 <bollu> geekosaur: okay, go on
21:19:26 <dmwit> shanemikel: It doesn't sound like it. Inference takes a term and produces a type. bollu is starting with a type in hand.
21:19:29 <ReinH> bollu: https://prime.haskell.org/wiki/ExistentialQuantification
21:20:20 <bollu> geekosaur: also, where can I read about this? book wise
21:20:28 <geekosaur> but here is where I start to get fuzzy, sadly
21:20:31 <bollu> okay
21:20:40 <ReinH> If you're asking why we use a forall instead of an exists, it has to do with Skolem's Theorem
21:20:49 <geekosaur> in particuular I can never remember whether it's the covtariant or contravariant one that is existential >.>
21:20:56 <ReinH> Namely, (∃b. F(b)) -> Int <=> ∀b. (F(b) -> Int)
21:21:10 <geekosaur> which, practically, means which side of an *internal* -> it is on
21:21:19 <bollu> ReinH: isn't there a Void needed there the way dmwit was showing it?
21:21:24 <ReinH> No?
21:21:37 <bollu> ReinH: okay, how do you prove the equivalence?
21:21:48 <bollu> Cale showed this to me once, but it didn't stick
21:21:50 <ReinH> It's Skolem's theorem. Ask him.
21:22:08 <bollu> :)
21:22:11 <ReinH> I mean, he's dead, but you can read his paper where he proved it.
21:22:46 <bollu> ReinH: is it this theorem: https://en.wikipedia.org/wiki/L%C3%B6wenheim%E2%80%93Skolem_theorem?
21:24:34 <geekosaur> bollu, I think http://www.cs.nyu.edu/media/publications/laufer_konstantin.pdf is your starting point?
21:24:42 <geekosaur> there's a different link on the wiki but it's dead
21:25:18 <bollu> "not (not A)" would be either (A -> Void) -> Void (which is useless) or forall r. (A -> r) -> r"? 
21:25:29 <ion> @remember shachaf Typing on phones is scow.
21:25:46 * ion pokes lambdabot
21:25:47 <geekosaur> bot's dead
21:26:08 <ReinH> I think there's a proof in Proofs and Types by Girard
21:26:10 <bollu> ReinH: can you explain the quote I mentioned?
21:26:20 <alercah> bollu: Looking at it typewise, the former says that if you have a proof that, for some b, F(b) is true, then you can prove Int.
21:26:21 <bollu> quote is from here: http://stackoverflow.com/questions/14299638/existential-vs-universally-quantified-types-in-haskell
21:26:38 <bollu> alercah: go on
21:27:10 <ReinH> bollu: How is double negation related to this question?
21:27:16 <alercah> *if F(b) is true
21:27:18 <geekosaur> bollu, I don't know the proof but it's basically the same as de Morgan's theorem applied in the context of types
21:27:19 <alercah> The latter says that for all b, if F(b) is true, then you can prove Int
21:27:58 <bollu> alercah: how is that true?
21:28:11 <ReinH> Perhaps http://stackoverflow.com/a/30009612/2225384 will be useful for understanding the forms of double negation
21:28:26 <alercah> bollu: I'm just reading it. Forall b (if F(b) then Int)
21:28:26 <bollu> alercah: how are they eqivalent?
21:28:45 <ReinH> How are what equivalent?
21:29:05 <bollu> if you have a proof that, for some b, F(b) is true, then you can prove Int. <=> for all b, if F(b) is true, then you can prove Int
21:29:46 <alercah> well the reverse direction is easy
21:30:22 <alercah> since you're given a b for which F(b) is true, you can apply the RHS to get an Int
21:30:53 <alercah> And the forward direction isn't much harder: for any b, if F(b) is true, then you can apply the LHS to get an Int
21:31:47 <bollu> alercah: what do you mean by "apply the RHS" / "apply the LHS"?
21:32:29 <alercah> so for the forward direction, I take the LHS as a premise, right?
21:32:46 <bollu> right
21:32:49 <alercah> so I basically have ((exists b. F(b)) -> Int) -> forall b. (F(b) -> Int)
21:32:51 <bollu> uh, I'll be back in a while
21:32:52 <bollu> college :)
21:32:54 <bollu> sorry
21:33:03 <alercah> uh, I'm going to bed XD
21:33:09 <alercah> .tell bollu going to bed, ping me tomorrow
21:33:28 <alercah> no wait, which is the trigger for tell?
21:34:48 <ReinH> I think Skolemization can be performed by way of Curry-Howard, but I'm not quite sure where this is going.
21:35:27 <alercah> it's not that hard
21:36:18 <ReinH> The usual argument is, given data T = forall a. MkT a, this means we have MkT :: forall a. (a -> T). This means that MkT can be given *any* a, i.e., this is equivalent to MkT :: (exists a. a) -> T
21:36:33 <ReinH> which means that data T = forall a. MkT a <=> data T = MkT (exists a. a)
21:37:00 <shanemikel> yeah, that (exists b. P) => Q <=> forall b. (P => Q) doesn't feel right somehow
21:37:55 <nshepperd1> foo :: ((exists b. F b) -> r) -> forall b. (F b -> r): foo elim fb = elim (fb :: exists c. F c)
21:40:02 <alercah> shanemikel: so given (exists b. P) => Q, we construct the forall b. (P => Q) as follows
21:40:12 <alercah> (entirely informally)
21:41:22 <alercah> we want to show that for all b, P => Q
21:41:36 <alercah> so in other words, (not P OR Q)
21:41:43 <alercah> if not P, then we're done
21:41:58 <alercah> if P, then we have proven exists b. P
21:42:05 <alercah> therefore we can apply the left-hand side's implication to conclude Q
21:42:24 <alercah> conversely, we have forall b. (P => Q) and exists b. P
21:42:40 <alercah> that this implies Q should be quite clear
21:48:03 * hackagebot linear-opengl 0.3.0.0 - Isomorphisms between linear and OpenGL types  https://hackage.haskell.org/package/linear-opengl-0.3.0.0 (BenGamari)
21:48:05 * hackagebot wkt 0.3.1 - Parsec parsers and types for geographic data in well-known text (WKT) format.  https://hackage.haskell.org/package/wkt-0.3.1 (BenGamari)
21:48:07 * hackagebot warc 0.3.0 - A parser for the Web Archive (WARC) format  https://hackage.haskell.org/package/warc-0.3.0 (BenGamari)
21:57:44 <EvanR> what is the latest on MonadFail ?
22:01:57 <EvanR> the proposal fully went through?
22:03:21 <red13> Ok, i have installed lambdabot on a Linux vm. How do I get it to connect to #haskell?
22:04:54 <EvanR> register it as a bot with #freenode
22:05:01 <EvanR> call back in the morning
22:05:45 <ab9rf> morning? you think it'll be that soon?
22:05:57 <ab9rf> my experience is freenode takes about a week to do anything, unless you know who to suck up to
22:06:26 <EvanR> my tactic to stall red13 has clearly been found out
22:06:38 <red13> !?
22:07:55 <red13> Am I missing something here? Is this a joke somehow?
22:08:01 <glguy> Why do we need to replace lambdabot?
22:08:19 <grantwu> Because it's not in the channel
22:08:25 <glguy> forever?
22:08:34 <grantwu> No, but presumably red13 got impatient
22:09:03 <EvanR> we can move the channel to wherever lambdabot went, and it could be the subject of a hilarious vacation adventure movie
22:09:07 <red13> It's due to return?
22:09:24 <grantwu> I think people are working on getting it back, yeah
22:09:38 <grantwu> At least that's what I got from reading the channel?
22:09:44 <grantwu> Something about a hardware or VM failure?
22:10:14 <red13> glguy can you explain? I guess you know...
22:10:42 <glguy> No, I don't run lambdabot. I have no reason to believe that it's not coming back.
22:11:32 <red13> This all seems rather strange
22:12:16 <red13> I'm concerned discontented
22:12:22 <red13> And*
22:12:23 <EvanR> its disappeared before
22:12:45 <glguy> Well, it's safe to move on. int-e will bring it back when he notices and has time to do it
22:13:41 <red13> illuminati confirmed
22:15:03 <glguy> Look on the bright side, instead of flooding the channel with lambdabot error messages everyone can wait until they know wtf they're doing and paste the final result into channel as needed to share something
22:15:43 <red13> Essentially terrorism
22:16:31 <EvanR> if youre giving a haskell presentation, how would you pronounce IO ()
22:16:49 <grantwu> Like this: IO () :^)
22:17:05 <EvanR> it turns out some people mistake () for empty list
22:17:05 <red13> :t ()
22:17:16 <grantwu> IO unit?
22:17:30 <grantwu> IO action returning unit maybe?
22:17:32 <EvanR> "IO unit" eh...
22:17:43 <glguy> I'd say "Eye Oh of unit"
22:17:45 <red13> Blank?
22:18:09 <jle`> i mean, i read IO Int as "IO Int", but i am not sure that's the most helpful way
22:18:17 <EvanR> ive actually fallen back on IO blank before.. but thats idiosyncratic
22:18:40 <EvanR> IO of unit, or IO unit is probably rightest
22:18:52 <jle`> i mean, i call [Int] List-Int
22:19:02 <EvanR> list of int
22:19:07 <red13> "
22:19:08 <jle`> or Int List
22:19:11 <jle`> if i wanted to be ocaml
22:19:54 <EvanR> the place of "of" in ocaml is...
22:20:10 <red13> And Monad m => m a "monad of a"
22:20:53 <red13> So that Monad of Monoids makes sense
22:21:02 <Hafydd> can i have a monad of bees, pls?
22:21:03 <jle`> "Monad of a" i might have issues with
22:21:11 <jle`> by might i mean i do
22:21:22 <red13> What are these issues?
22:21:31 <jle`> monad of a sounds like Monad of a
22:21:51 <jle`> but it's really m of a, where m is a monad
22:21:59 <red13> :t of
22:22:15 <red13> It's just sugar
22:22:16 <EvanR> i see where yalls "of" comes from now, f(x)
22:22:22 <ReinH> So, part of the problem with lambdabot not working is that lambdabot doesn't work.
22:22:25 <jle`> maybe "(some monad) of a", or a-of-some-monad
22:22:47 <ReinH> actually that's pretty much the whole problem.
22:23:08 <EvanR> i guess that tautologically explains that
22:23:24 <jle`> thank you for clarifying
22:23:38 <red13> :t whole > sum parts
22:23:54 <EvanR> with Double, totally possible
22:24:02 <ReinH> So, by "lambdabot doesn't work", what I mean is...
22:24:23 <red13> Not in scope whole, not in scope parts
22:25:11 <red13> My errors are more legible
22:25:30 <red13> I will take place of lambdabot for now
22:25:36 <MarcelineVQ> whole :: Integer, parts :: [Integer]
22:26:58 <red13> *exterminate!! exterminate!!*
22:32:27 <dagda1_> I am using GHCI through stack but whenever I do import Text.ParserCombinators.Parsec I get cannot find module
22:33:43 <okuu> dagda1_: do you have parsec installed, if so, what version?
22:34:09 <dagda1_> okuu no I don't, I thought it was part of the base library
22:34:12 <MarcelineVQ> try stack ghci --package parsec to make sure parsec is around to import
22:37:30 <dagda1_> all good now, great thanks
23:07:39 <liste> 03:13 -!- lambdabot is now known as red13
23:07:42 <liste> what's this?
23:08:09 <liste> oh, seems there's talk about it
23:08:12 <liste> in here
23:12:34 <geekosaur> lb pinged out several hours ago, there was some joking about people stepping into its place
23:13:31 <ab9rf> lambdabot is on sabbatical
23:16:39 <johnw> @pl \x z -> (x >>= \_ -> return (return z)) >>= id
23:16:44 <johnw> ah
23:37:20 <johnw> is there a way to "release" a foreign pointer finalizer?
23:37:36 <ab9rf> what means you by "release"?
23:37:48 <johnw> I'd like to take a block that I allocated with mallocPlainForeignPtrBytes, then disable the finalizer, realloc, and then establish a new free finalizer
23:38:06 <johnw> there's no reallocPlainForeignPtrBytes
23:38:48 <johnw> as an example, ByteString.cons uses memcpy every time you grow the buffer.  If it used realloc, it could avoid the memcpy in cases where the new buffer coincides with the old one.
23:39:24 <ab9rf> that sounds unsafe 
23:39:53 <johnw> yep
23:40:31 <johnw> the other thing I could do is to attach the finalizer to another object containing the Ptr, leaving management of the Ptr up to me
23:41:13 <ab9rf> i'm not aware of any way to remove a finalizer from an foreign  pointer once it has one
23:41:52 <johnw> well, the ForeignPtrContents is just an IORef
23:42:19 <johnw> so maybe I can just modify it to free the new address if realloc changes the location of the buffer
23:42:26 <ab9rf> you could probably forcibly disconnect the finalizer, but that's grossly unsafe :)
23:43:23 <johnw> oh, interesting
23:43:35 <johnw> mallocPlainForeignPtrBytes doc says "internally an optimised ForeignPtr representation with no finalizer is used"
23:44:01 <ab9rf> yes, but i don't think you can use realloc on those pointers
23:44:17 <ab9rf> it's not libc malloc
23:44:53 <johnw> true, it's a newPinnedByteArray#
23:45:36 <johnw> I wonder why this is better than malloc, considering it pays a memcpy cost always
23:48:49 <ab9rf> note alos that plain foreign ptrs do not have finalizers, and cannot have finalizers added
