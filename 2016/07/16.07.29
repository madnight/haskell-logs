00:00:21 <ezyang> yes but now you have to explain what it means to backpropagate a circuit input ;) 
00:00:29 <ezyang> like, the input is literally a circuit 
00:02:59 <lolisa_> We use a pair (a, bpatch), meaning on input a, change output by bpatch. a might be higher order, as in the case of S, does this make sense?
00:03:18 <ezyang> So, I believe the term of art is "higher order recurrent neural network" 
00:04:12 * hackagebot compound-types 0.1.2 - Sum and Product types and such  https://hackage.haskell.org/package/compound-types-0.1.2 (NikitaVolkov)
00:04:16 <ezyang> yes 
00:05:22 <lolisa_> I am skimming the paper, are you sure higher order mean higher order function instead of, like, x*x is second order?
00:07:39 * hackagebot glirc 2.1 - Console IRC client  https://hackage.haskell.org/package/glirc-2.1 (EricMertens)
00:07:39 * hackagebot compound-types 0.1.2 - Sum and Product types and such  https://hackage.haskell.org/package/compound-types-0.1.2 (NikitaVolkov)
00:08:01 <lolisa_> Anyway let me get my second attempt, which open up a can of worms...
00:08:14 <glguy> That's weird, hackagebot is duplicating announcements
00:09:50 <Xpalo> how mature is glirc
00:10:06 <Xpalo> can it supplant irssi
00:10:51 <glguy> Depends on what you need from it. I've been using it for months. irssi can't replace it for me
00:11:06 <glguy> other people might use a different featureset of irssi and it wouldn't work for them
00:11:29 <Xpalo> can it conect to multiple networks?
00:11:32 <glguy> yeah
00:11:41 <ezyang> x*x is still first order 
00:12:56 <Xpalo> i just may check that out then glguy, tho i actually dont use irssi, but i dont have any console client at all on this machine, i use xchat
00:13:09 <Xpalo> i know a lot of people who use irssi
00:13:23 <glguy> irssi is certainly more mature
00:13:33 <glguy> It's probably about the most mature, so that's going to be a high bar
00:14:16 <Xpalo> well i just wanted an idea, like an irc client could just mean some minimal thing for making bots 
00:14:16 <glguy> If you have any questions you can always message me, or join #haskell-irc
00:14:31 <glguy> Oh, it's a full user client
00:25:42 <koz_> lambdabot: > 1 + 2
00:25:48 <koz_> Whoops.
00:32:39 <ertesx> glguy: does it log?
00:33:27 <glguy> No, I log with znc. It wouldn't be hard to make it write to a file, but it doesn't
00:33:49 <ertesx> i'll give it a shot…  not right now, but it sounds interesting
00:34:12 <glguy> OK, even if you don't switch to it I'd still  be interested in feedback
00:34:37 <ertesx> glguy: one thing i immediately notice: you're not using the 'irc' library…  any particular reason?
00:35:24 <ertesx> (i just saw that the last release was in 2014)
00:35:30 <koz_> OK, I'm curious about something. replicateM 3 [False, True] will give me every 3-length pairing of False and True. I wanna do something similar, but instead of one list, I have many lists.
00:35:50 <glguy> ertesx: It doesn't parse everything I need it to, and isn't permissive enough for some of the replies you can get from freenode
00:36:03 <ertesx> i see
00:36:05 <koz_> So for example, if I did thisHypotheticalFunction [[1, 2], [3, 4]], it would spit [[1, 3], [1, 4], [2, 3], [2, 4]].
00:36:16 <koz_> Is there something like this already written?
00:36:26 <ertesx> koz_: sequence?
00:36:35 <glguy> ertesx: It doesn't know about the maximum number of arguments an IRC message can have before the colon is optional, etc :)
00:36:36 <koz_> ertesx: Seriously? Wtf me.
00:36:41 <ertesx> > sequence ["Hh", "eE", "lL", "lL", "oO"]
00:36:43 <lambdabot>  ["Hello","HellO","HelLo","HelLO","HeLlo","HeLlO","HeLLo","HeLLO","HEllo","HE...
00:36:47 <ertesx> koz_: like that?
00:36:50 <glguy> I sit next to the author at work
00:37:07 <lolisa_> > help
00:37:08 <lambdabot>  Not in scope: ‘help’
00:37:23 <koz_> ertesx: Exactly like that!
00:37:33 <koz_> Thank you - I still clearly have much to learn.
00:37:45 <ertesx> glguy: huh?  i practically ate the RFC and wouldn't know that such a limit exists…  did i miss something?
00:38:22 <glguy> ertesx: section 2.3.1 https://tools.ietf.org/html/rfc2812
00:38:37 <ertesx> koz_: replicateM and sequence are like the worst possible implementations of that…  you can probably achieve a lot lazier code by writing them yourself
00:38:40 <glguy> ertesx: and Freenode's ircd knows about the limit
00:38:57 <ertesx> koz_: as a monad [] is often much stricter than necessary
00:39:15 <koz_> ertesx: It's OK - if I need them to be lazier, I can rewrite it. I just realized that this makes much of my code a *lot* shorter.
00:39:15 <ertesx> glguy: ah, not 1459
00:40:18 <ertesx> that's a weird thing to change about the protocol…  like we don't have enough compatibility issues with IRC already
00:40:38 <glguy> yeah, it's goofy
00:40:44 <ertesx> i believe that today it's impossible to write IRC clients
00:40:53 <ertesx> you write freenode clients and ircnet clients and …
00:40:54 <Athas> Are there any good (and accessible in terms of size) examples of well-performing parallel Haskell code?
00:41:18 <Athas> I know many of the libraries and techniques, but I'm looking for applications or nontrivial examples.
00:41:45 <glguy> ertesx: I tried using another IRC parser, it tried to get clever about what valid nicknames or hostnames were, etc
00:42:23 <glguy> ertesx: but servers don't agree on what valid means, so in the end I made my own
00:43:23 <ertesx> Athas: The Book should have loads of them: http://chimera.labs.oreilly.com/books/1230000000929/
00:44:23 <numee> ertesx: would you elaborate on the list monad being "much stricter than necessary" ?
00:44:49 <ertesx> numee: example:
00:45:08 <ertesx> > filterM (const [False, True]) "abc"
00:45:09 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
00:45:23 <ertesx> > subsequences [0..]
00:45:24 <lambdabot>  [[],[0],[1],[0,1],[2],[0,2],[1,2],[0,1,2],[3],[0,3],[1,3],[0,1,3],[2,3],[0,2...
00:45:30 <ertesx> > filterM (const [False, True]) [0..]
00:45:31 <lambdabot>  *Exception: stack overflow
00:45:38 <ertesx> numee: ^
00:46:24 <numee> ertesx: oh I didn't know that. Actually I've written that filterM code just an hour ago...
00:46:47 <ertesx> numee: yeah, use 'subsequences'
00:47:04 <ertesx> there is also a monadic version of 'permutations' using foldM, but it suffers from the same problem
00:47:12 <ertesx> > permutations [0..]
00:47:13 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:47:14 <Athas> ertesx: those are all fairly trivial.  That's why I'm mostly looking for Haskell programs that use them in anger.
00:48:03 <ertesx> [] as a monad makes sense in list-comprehensiony cases
00:48:21 <ertesx> > liftA2 (*) [1,2,3] [10,20,30]
00:48:23 <lambdabot>  [10,20,30,20,40,60,30,60,90]
00:49:32 <ertesx> Athas: well, there is that facebook thing that uses concurrency very aggressively
00:50:21 <ertesx> i forgot its name…  it's a DSL that helps them write abuse detection
00:50:31 <srhb> ertesx: Haxl
00:50:42 <ertesx> Athas: ^
00:50:55 <Athas> Thanks, that might be a good example!
00:51:08 <ertesx> Athas: but it's more about concurrency than parallelism
00:51:08 <srhb> But it's a library, I don't think that Facebook's code using it is publically accessible.
00:51:12 <srhb> Indeed.
00:51:58 <ertesx> Athas: i wrote a parallel search for safe primes, but it uses parallelism in a rather trivial way:  parMap
00:52:00 <Athas> From https://github.com/facebook/Haxl, it seems more oriented towards concurrency than parallelism.
00:52:26 <ertesx> Athas: http://lpaste.net/77575
00:52:35 <ertesx> i hope it still works, but it should
00:53:06 <ertesx> all it does is to search for multiple safe primes in parallel, so a rather easy case of parallelism
00:53:16 <Athas> ertesx: that's also fairly trivial.  I've written a bunch of programs like that too, but I'm curious about how a large-scale performing parallel Haskell program looks (and performs).
00:53:42 <srhb> I can't really think of any available codebases, and I've looked before.
00:53:43 <Athas> Haskell supports several quite effective parallelisation techniques, so there must be at least one real application that actually uses them!
00:53:59 <srhb> Perhaps it might be interesting to contact Galois directly and see if they have something they're willing to share.
00:54:00 <ertesx> Athas: ask me in a year when i've finally written some game code that draws pictures on your screen =)
00:54:07 <srhb> I would imagine they're the sort of people that might have something like that.
00:54:15 <Athas> ertesx: all the parallelism there will be in the OpenGL shaders, won't it?
00:54:48 <ertesx> Athas: no, i'd parallelise the game logic
00:55:31 <ertesx> Athas: in principle it's somewhat trivial as well (iterate over a large array), but those just happen to be the best cases for parallelism =)
00:57:00 <Athas> Repa does have a few reverse dependencies on Hackage, although most of them seem fairly experimental.
00:57:25 <ertesx> the more dependencies you introduce into your code, the less incentive you get to parallelise it:  it becomes harder and the payoff goes toward zero quickly with the danger that you may even end up with more expensive code
00:57:36 <ertesx> (i mean data dependencies, not package dependencies)
00:58:02 <ertesx> so it's not surprising that the best examples of parallelism look trivial
00:58:15 <Athas> Accelerate seems to have very few non-Accelerate reverse dependencies.  Which is a bit strange to me, because Accelerate is a very easy way to get a nice speed boost for simple problems.
00:58:37 <Athas> ertesx: it's not so much that they are trivial, but that they are mostly artificial, or for educational purposes.
00:59:00 <ertesx> Athas: at this point accelerate is pretty much CUDA-only
00:59:11 <ertesx> so people probably only use it in their labs, if at all
00:59:32 <Athas> Yeah, and that code might not be on Hackage.  Still, it might be on Github.  I wonder if I could find it.
01:00:00 <ertesx> Athas: i think, this is one of the rare cases when practical examples don't even look much different from toy examples
01:00:46 <Athas> Hard to say when I can't find any, though...
01:01:37 <Athas> Well, this thing uses Accelerate: https://github.com/kathawala/symdiff
01:01:50 <Athas> Turns out Github code search is quite good.
01:02:26 <ertesx> in my number crunching code (mostly training of logistic regression), it was pretty much just parMap all over the place
01:02:33 <ertesx> (or rather parBuffer)
01:03:12 <ertesx> compute deltas for multiple training samples, then combine…  it's a simple application of parallel foldMap
01:03:18 <ertesx> (what google markets as "MapReduce")
01:04:00 <Athas> Well, sometimes the map-part contains it's own parallelism.  How to deal with that is an important part of the story.
01:04:16 <Athas> With Accelerate, you have to manually flatten it, which is usually fine.
01:04:33 <Athas> But I'd like to see examples of what it takes in practice.
01:04:50 <ertesx> in easy cases you just let the RTS deal with it, in others you introduce a depth argument…  that's how i handled it
01:05:40 <ertesx> if you have a flattening abstraction, that helps, but if not, you limit the depth
01:11:02 <Athas> It's a bit surprising that it's so hard to find code that uses these various facilities in anger.  Whenever I've tried them out, they seemed to work well, at least for simple cases.
01:11:19 <Xpalo> i dont know what you mean by 'in anger'
01:11:24 <Athas> Perhaps parallel programming is just still outside the imagination of the average programmer!  Or perhaps still unnecessary.
01:11:41 <Xpalo> you're trying to find the code in anger, or does in anger apply to the usage of the facilities by the programmers
01:12:03 <vaibhavsagar> http://english.stackexchange.com/questions/30939/is-used-in-anger-a-britishism-for-something
01:12:11 <Athas> Xpalo: being used "for real", that is, not as an experiment, or educationally.
01:12:31 <Xpalo> oh, new expression for me
01:13:23 <vaibhavsagar> yeah, someone used it when talking to me and I was befuddled for months afterwards
01:13:39 <ongy> I think most "real world" applications are more IO oriented, which makes pure parallelism hard
01:15:02 <Athas> ongy: I suspect you are correct.
01:15:18 <Xpalo> man brittish are weirder than i thought
01:15:44 <Athas> In fact, I suspect IO-heavy programs are where Haskell is most widely used, because the performance gap compared to low-level languages matters less.
01:16:41 <Ke> I would think haskell is used in very social structures allow for it
01:17:14 <Ke> you definitely can not use it in a business enterprise company with inexpensive PHP-programmers
01:18:03 <Xpalo> eh... well..... the thing is the high level aspect actually is its own pay off... i mean would you rather have something done quickly and maintainable and more flexible but runs in 2000 microseconds instead of 1000... depending on what you are doing that might add up, but whatever it is you wont notice until later.
01:18:11 <Ke> I would not use haskell in many cases because I consider haskell maintenance heavy
01:18:22 <ertesx> Athas: the problem is that if you optimise prematurely (e.g. in library code), you can introduce cost, because parallelism always makes assumptions about the data dependencies in code
01:18:30 <Ke> there are libs with nice and stable apis, like xmonad, but not everyone likes that
01:18:34 <Xpalo> oh well thats a point too, it is heavy in some ways
01:19:00 <ertesx> Athas: so it's not really surprising that you don't find parallel library code except in libraries specifically for parallelism (accelerate, repa, yarr, …)
01:19:09 <Xpalo> it could get lighter if modules were parameterizable i think
01:19:31 <ertesx> Athas: then you have executable code, but i'm not aware of any haskell program that would really benefit much
01:20:02 <ertesx> Athas: for example i use darcs, pandoc, taffybar and xmonad every day, and none of them would really benefit
01:20:28 <ertesx> Athas: along with a bunch of programs i've written myself, and those also don't really benefit
01:21:36 <ertesx> so to avoid the danger of increased cost due to higher complexity, i tend not to go for the potential 2% gain…  parallelism isn't really a switch you just flip…  it's a heavy optimisation with complexity and trade-offs
01:21:56 <Xpalo> yeah
01:22:13 <Xpalo> i dont think we should give up on having the computer do it for us
01:22:47 <ertesx> and i don't mean engineering cost here…  i specifically mean CPU time
01:23:02 <ertesx> engineeringwise parallism in haskell is rather easy
01:23:10 <ertesx> (in comparison)
01:23:45 <Xpalo> i know a lot of researchers worked on it a long time and didnt get effective truly implicit parallelism, but what is a 'long time'... we just need smart people working on it.
01:23:49 <Xpalo> they're related
01:23:53 <Athas> ertesx: I think Darcs could, maybe.  It's the only one of those that is not pretty IO-oriented or obviously unsuitable (Pandoc).
01:24:18 <ertesx> Athas: i rarely notice CPU peaks with darcs
01:24:30 <Athas> Xpalo: you need parallel languages if you want anything like implicit parallelism.
01:24:44 <Athas> ertesx: didn't it have some expensive merge algorithm?  It's been years since I last used it.
01:24:59 <ertesx> Athas: firing up the OS threads and making them communicate will likely eliminate all the gain you get and make things worse in the end
01:25:18 <Xpalo> fully implicit would mean you write it in whatever language totally sequential, and it figures out when and where to paralellize and how... so i dont see that.
01:25:22 <ertesx> Athas: the merge algorithm is exponential in complexity, but only in edge cases that i've never encountered
01:25:36 <ertesx> Athas: i wouldn't optimise for them at the expense of the average case
01:25:51 <Xpalo> maybe implicit isnt strong enough of a word here for what i mean
01:26:52 <Athas> Xpalo: no, you use a parallel language.  It's the only way to avoid crazy compiler analysis.
01:26:56 <Athas> (And even then, it's still hard.)
01:27:37 <koz_> Is Edward Kmett always some kind of Haskell theory superhero?
01:27:53 <Xpalo> well i'm talking about compiler analysis and transformations itself... perfecting it to some level of not yet obtained awesomeness
01:27:56 <koz_> I'm watching his talk that just came up in my newsfeed, and my jaw just hit the floor.
01:28:15 <Athas> Xpalo: I think the solution is to ditch sequential languages and data structures.
01:28:29 <mniip> koz_. why yes
01:28:39 <ertesx> koz_: he's a heavy user of CT abstractions and shares his ideas and implementations with the community
01:29:03 <ertesx> koz_: you could call that heroic, i guess =)
01:29:17 <koz_> ertesx: CT?
01:29:22 <Xpalo> oh well that may be, but i still think technologically it would be nice if we had smart enough machines to figure out a good 'interpretation' when we say, holodec show me 20th century france
01:29:23 <srhb> Category theory
01:29:26 <mniip> category theory
01:29:32 <koz_> srhb and mniip: Ah, OK.
01:29:33 <ertesx> koz_: or more generally abstract algebra
01:29:43 <koz_> Remind me to one day actually work my way through Awodey's textbook.
01:29:59 <koz_> If this gives me insights half as brilliant as this, I'll be happy.
01:30:13 <koz_> Fucking hell, me and indirect references in grammar...
01:30:23 <koz_> I keep using 'this' to refer to multiple different things in the same sentence.
01:30:48 <srhb> koz_: You need to uniqueness type your this'es. :-P
01:30:49 <ertesx> koz_: most of the time it gives you a language to talk in, not necessarily any crazy insights, but sometimes it does
01:31:19 <Athas> Xpalo: why have a machine try to figure out what we _really_ mean, when we can just say it outright?
01:31:49 <ertesx> Xpalo: that smart enough machine cannot exist in our computing model
01:31:58 <ertesx> Xpalo: it would be uncomputably smart =)
01:32:23 <Xpalo> it only has to do as good as we see on tv
01:32:31 <Xpalo> :)
01:33:17 <Xpalo> anyway, your claim is nothing unless you have a proof
01:33:31 <koz_> ertesx: Well, half the time, being able to describe something correctly is where insights begin.
01:33:35 <koz_> srhb: Yes, I do.
01:34:00 <koz_> ertesx: But then again, I *would* say that, given that my work leans a lot on logic.
01:34:07 <Xpalo> what about the other half of the time...
01:35:38 <ertesx> koz_: absolutely, but there is a downside to it as well, a social one:  it makes you cringe whenever you read something like "ICombinable"
01:35:52 <ertesx> "it's a monoid, you dumbass!  A F*$@ING MONOID!"
01:37:15 <koz_> ertesx: Lol, yes, I already get that.
01:37:18 <koz_> It actually happened today.
01:37:26 <lolisa_> Hi, can anybody give me more insight? I have all my code translated. http://goo.gl/50Tkzg
01:37:45 <koz_> I was teaching a class on data structures and algorithms, and I introduced the students to the idea of recursively processing lists.
01:38:10 <koz_> I then ended up saying to one of the brighter ones that the language they have to work in fails at this relative Haskell, because it doesn't have a way to describe effects as types.
01:38:19 <ertesx> lolisa_: would you mind pasting it on lpaste?
01:38:21 <ertesx> @where lpaste
01:38:21 <lambdabot> http://lpaste.net/
01:38:27 <koz_> It took a *damn long time* to explain why this would be really useful, but in the end, I think they got the reason.
01:38:56 <lolisa_> http://lpaste.net/172683
01:39:14 <LKoen> koz_: not sure I understand your sentence "they have to work in fails at this relative Haskell, because it doesn't have a way to describe effects as types"
01:39:31 <LKoen> what language was the class taught in?
01:40:08 <koz_> LKoen: Java.
01:40:12 <koz_> (not my choice :()
01:40:28 <koz_> Also, there I go with my references again.
01:40:38 <koz_> Fuck, I should be prohibited from using pronouns.
01:41:16 <koz_> Also, is it a natural consequence of using Haskell more to start writing more and more stuff pointfree naturally?
01:41:24 <koz_> (meaning 'without intentionally trying')
01:41:50 <lolisa_> @help
01:41:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:42:05 <LKoen> I've had an algorithm class in pseudo-language where we had to make a distinction between "functions" and "procedures"
01:42:21 <koz_> LKoen: How very 1970s.
01:42:23 <LKoen> "functions" could not have side effects, and "procedures" could not return a result
01:43:09 <Ke> exactly like fortran
01:43:31 <LKoen> that's a bit extremist I think; how would you write something like getLine?
01:43:59 <Ke> hand it a mutable reference and make it a subroutine
01:44:03 <LKoen> well actually it would have worked because procedures were allowed to take something very similar to pointers
01:44:09 <LKoen> yes
01:44:15 <koz_> LKoen: Yeah - basically out-params a la C.
01:44:32 <LKoen> oh yeah, I remember we had to specify that as a type of the param actually
01:44:37 <LKoen> "in", "out" or "inout"
01:44:43 <LKoen> (functions only had "in" params)
01:45:24 <vaibhavsagar> so you could in theory reimplement Forth with procedures in this language
01:45:44 <koz_> LKoen: Interestingly enough, at least one language in actual existence does those exact things with those exact keywords.
01:45:46 <koz_> (Dlang)
01:45:59 <LKoen> I will look that up now
01:46:34 <koz_> (also yay, I used references correctly in that sentence woo)
01:46:44 * ertes got disconnected
02:03:25 <saurabhnanda> any type gurus here?
02:03:29 <saurabhnanda> need help with https://www.reddit.com/r/haskell/comments/4v5pgk/how_to_use_types_to_model_a_tree_invariant/
02:05:37 <koz_> saurabhnanda: The text is removed.
02:05:43 <koz_> I'm not sure what invariant you want to model.
02:27:37 * hackagebot aeson-injector 1.0.2.0 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.0.2.0 (NCrashed)
02:33:34 <daniel-s> Hey
02:37:38 * hackagebot stache 0.1.3 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-0.1.3 (mrkkrp)
03:31:24 <anohigisavay> hi.
03:31:48 <anohigisavay> how to check if a bytestring is a substring of another?
03:31:59 <anohigisavay> can't find related functions in Data.ByteString
03:32:38 <anohigisavay> oh, Data.ByteString.Lazy
03:37:40 * hackagebot gipeda 0.3.1 - Git Performance Dashboard  https://hackage.haskell.org/package/gipeda-0.3.1 (JoachimBreitner)
03:47:50 <slack-haskell> <rizy> a
03:48:12 <Rizy> lol
04:03:08 <danilo2> Hello! Could anybody explain to me why GHC8 is so stupid when solving superclasses constrains? I totally dont get it. Why the constrains have to be much bigger now? 
04:03:55 <danilo2> There is just a note about it in migration guide but without any reason why it is left so: https://ghc.haskell.org/trac/ghc/wiki/Migration/8.0
04:07:37 <koz_> Welp, I just had to use fmap . fmap . fmap . fmap.
04:07:39 <koz_> In actual code.
04:07:55 <Athas> The meaning is clear!
04:08:16 <LKoen> is this an obfuscation contest?
04:08:37 <maerwald> koz_: then your data structures are too complicated
04:09:20 <koz_> maerwald: It's for an intermediate structure.
04:09:36 <koz_> But yeah, it's probably not the best thing.
04:09:44 <koz_> It's a pity I can't write that as <$> <$> <$> <$>
04:13:38 <phadej> koz_: http://hackage.haskell.org/package/composition-extra-2.0.0/docs/Data-Functor-Syntax.html <$$$$>
04:13:39 <Athas> koz_: you can define new operators!  I think <<<<$>>>> would be a wonderful notation.
04:14:07 <koz_> phadej: That's seriously a thing?
04:14:40 <Athas> I think <$$$$> should be of type '(a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e'.
04:14:56 <phadej> Athas: that's liftA4
04:15:24 <Athas> Yes, and I think <$$$$> makes more sense as an alias for that!
04:15:35 <Athas> It should be the brackets that are duplicated, not the application!
04:15:46 <koz_> Athas: Well, you can take it up with the person who wrote composition-extra.
04:15:57 <koz_> Also, where has this library been all my Haskell life?
04:16:06 <phadej> Athas: it doesn't (make sense to have operator version of liftA*)
04:16:20 <phadej> as you write them by f <$> fa <*> fb <*> fc <*> fd
04:16:36 <koz_> Which I actually prefer to liftA*.
04:16:45 <koz_> But maybe I just love the applicative syntax too much.
04:17:09 <phadej> koz_: they have they use too, e.g. (<>) = liftA2 (<>)
04:20:24 <koz_> phadej: Thank you for this awesome library - I will use it often.
04:20:39 <phadej> koz_: it's not mine :)
04:20:52 <koz_> phadej: You showed it to me, though.
04:21:25 <maerwald> that doesn't look pretty
04:21:26 <adarqui> koz_: github.com
04:21:31 <adarqui> i win.. jk, sorry
04:21:36 <koz_> adarqui: I don't even.
04:21:41 <maerwald> but yeah, the alternative is a lens-like library, which might be worse
04:21:58 <koz_> maerwald: I dunno, this doesn't seem to need lenses.
04:22:14 <maerwald> and I wouldn't use them
04:22:27 <phadej> Actually I have needed <$$> myself, but <$$$$> is definitely fishy
04:22:53 <phadej> (are you dealing with huge monad transformers stack?)
04:24:14 <koz_> phadej: Nope nested lists of Maybes.
04:24:21 <koz_> s/Nope/Nope;
04:24:27 <phadej> E.g. in aeson one my need to parse a optional value, so you have  ... <*> (postprocess <$$> obj .= "field")
04:24:38 <phadej> ah, 
04:24:48 <phadej>   ... <*> (postprocess <$$> obj .:? "field")
04:24:56 <koz_> Sorry, nested lists of pairs whose second elements are Maybes.
04:25:14 <phadej> koz_: define a newtype, you'r life would be easier
04:25:28 <koz_> phadej: I may well do that.
04:26:47 <phadej> (in aeson scenario newtype won't help to avoid <$$>, as the postprocess is actually some unwrapper of newtype there)
04:27:44 <phadej> and to conclude f <$$> x is imho better than fmap f <$> x or (f <$>) <$> x or fmap f `fmap` x
04:40:32 <jgzh6> hello, could anyone have a look at the code below and teach me the solution?
04:40:33 <jgzh6> http://lpaste.net/172695
04:45:27 <lieven> jgzh6: do you mean a recursive implementation of map?
04:46:23 <jgzh6> I mean a recursive function that does exactly the same thing as the main function
04:46:37 <jgzh6> using the map fucntion
04:46:48 <lieven> ah that's a fold 
04:47:35 <jgzh6> fold is my enemy too..
04:47:42 * hackagebot compound-types 0.1.2.1 - Sum and Product types and such  https://hackage.haskell.org/package/compound-types-0.1.2.1 (NikitaVolkov)
05:02:43 * hackagebot ekg-bosun 1.0.6 - Send ekg metrics to a Bosun instance  https://hackage.haskell.org/package/ekg-bosun-1.0.6 (OliverCharles)
05:11:15 <runeks> Can anyone explain how a 32-core Google Compute instance can use up 29 cores for over a minute on something that takes my laptop less than 10 seconds to complete? Or is it not unheard of that adding more cores actually slows it down?
05:13:19 <koz_> What is the :bro macro Edward uses in that video?
05:13:24 <koz_> (in GHCi)
05:13:59 <ggole> runeks: there could be a problem of some other kind, but http://aadrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html
05:15:22 <ahihi> koz_: I don't know the video in question, but :bro is shorthand for :browse
05:15:35 <koz_> ahihi: Oh, right. I was wondering.
05:16:24 <ggVGc> man, after doing haskell for most of this year, it feels really weird using parentheses for application rather than grouping..
05:16:27 <ggVGc> doing some Elixir now
05:17:15 <runeks> ggole: It's a web server that spawns a new thread for each connection, and it needs to do a ~0.5 ms signature verification for each request. So I expect this to be very easy to parallelize, as the threads don't need to share data.
05:17:24 <runeks> (that I'm working on)
05:17:52 <runeks> Looks like that guy was trying to speed up a parser
05:18:05 <runeks> That's more of a challenge
05:18:47 <runeks> And it's not a cluster, but a single machine instance with 32 cores
05:19:49 <runeks> ggole: But I probably just need to profile it to see what's going on
05:21:36 <ggole> Oh, a single machine. Hmm.
05:28:14 <ertes> jgzh6: you zip a list with a constant list of bools and then flip the bits…  why don't you just map to a tuple in the first place?
05:29:05 <ertes> jgzh6:
05:29:22 <ertes> > map (\x -> (x, rem x 7 == 0)) [2, 3, 5, 7, 14, 15, 19, 21]
05:29:23 <lambdabot>  [(2,False),(3,False),(5,False),(7,True),(14,True),(15,False),(19,False),(21,...
05:30:53 <ertes> ah, you do that multiple times
05:32:15 <ertes> map (\(x, b) -> (x, b /= (rem x 7 == 0)))
05:32:35 <ertes> > map (\(x, b) -> (x, b /= (rem x 7 == 0))) [(7, False), (14, False), (15, False)]
05:32:36 <lambdabot>  [(7,True),(14,True),(15,False)]
05:32:49 <ertes> (/=) is xor for booleans
05:32:54 <ertes> > True /= True
05:32:55 <lambdabot>  False
05:33:35 <ertes> in do-notation do not use "<-" to make local definitions…  instead use 'let'
05:33:47 <ertes> let second = func 2 zipped
05:42:44 * hackagebot postgres-tmp 0.1.0.0 - Create a temporary database that is deleted after performing some operation  https://hackage.haskell.org/package/postgres-tmp-0.1.0.0 (cocreature)
05:47:44 * hackagebot postgres-tmp 0.1.0.1 - Create a temporary database that is deleted after performing some operation  https://hackage.haskell.org/package/postgres-tmp-0.1.0.1 (cocreature)
05:54:06 <fProgrammer> Quick question: I am trying to use Data.Aeson to decode a json. The issue is: my fieldName in my record syntax differs from key in JSON. How do I map it? Here's the example: http://lpaste.net/172702. I tried manually writing a parser for it, but it throws an error: http://lpaste.net/172704 
05:56:56 <fProgrammer> anyone?
05:57:21 <Rotaerk> fProgrammer, never used Aeson, but it looks like implementing FromJSON is the appropriate way
05:57:40 <Rotaerk> the fact that you get an error isn't an indication that you're approaching it wrong, just that you made a mistake in your implementation
05:57:57 <buglebudabey> fProgrammer in your json you have to name the value entityRelationShipWeight I believe, not "weight"
05:58:17 <buglebudabey> sorry, entityRelationWeight*
05:58:38 <buglebudabey> same naming convention with "type"
05:59:10 <fProgrammer> buglebudabey: sadly, the json which I receive is not in my control, and as you already guessed, I can't use field name "type"  since it is a reserved keyword.
05:59:13 <pavonia> To me the FromJSON instance looks correct
05:59:27 <pavonia> fProgrammer: What error do you get?
06:00:00 <cocreature> fProgrammer: it compiles just fine for me. the error message suggests that the Entity type you’re using in your FromJSON instance has only one field while the Entity type you’re showing in your other paste has two fields. are you sure these are the same types?
06:00:36 <pavonia> Ah, I didn't see the error message, sorry
06:01:19 <fProgrammer> cocreature: Lemme check once again
06:01:48 <cocreature> fProgrammer: if you post a selfcontained complete example it might make it easier for us to figure out what the problem is
06:02:02 <fProgrammer> cocreature: Sorry, it compiles fine, my bad
06:02:26 <cocreature> fProgrammer: great so it’s working now or are you still having a different problem?
06:02:45 * hackagebot raaz 0.0.2 - The raaz cryptographic library.  https://hackage.haskell.org/package/raaz-0.0.2 (PiyushKurur)
06:03:12 <fProgrammer> cocreature: one moment please
06:05:02 <fProgrammer> cocreature: yep it works fine, I am not sure what happened, I just reloaded my ghci. Sorry
06:05:19 <cocreature> fProgrammer: np, glad you were able to figure it out
06:07:35 <fProgrammer> thanks.
06:07:45 * hackagebot cabal-helper 0.7.2.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.7.2.0 (DanielG)
06:30:25 <jgzh6> The algorithm I'm trying to write is https://gist.github.com/billc/1105f7f8ec94508ba82f in haskell
06:30:37 <jgzh6> http://lpaste.net/172695
06:37:46 * hackagebot impure-containers 0.3 - Mutable containers in haskell  https://hackage.haskell.org/package/impure-containers-0.3 (andrewthad)
06:37:57 <pavonia> jgzh6: Your main doesn't typecheck as func doesn't return an IO action
06:38:39 <pavonia> But you could write a recursive function that takes a counter and increases it with every iteration
06:38:52 <pavonia> passing the result list to the recursive call
06:41:41 <jgzh6> <pavonia> I don't seem to be able to make that recursive function. Could you please let me know how to write it?
06:42:41 <pavonia> What have you tried so far?
06:42:46 * hackagebot dot 0.2.0 - Data types and encoding for graphviz dot files  https://hackage.haskell.org/package/dot-0.2.0 (andrewthad)
06:43:38 <mmachenry> Axman6: Maybe this will do what you need: https://hackage.haskell.org/package/graphmod
06:46:14 <jgzh6> http://lpaste.net/172695 this is what I tried so far
06:48:21 <pavonia> jgzh6: There's no recursive function. The function should look somewhat like "lock n list = ... lock (n + 1) (func n list) ..."
06:48:45 <pavonia> Plus the check if you have already reached the 1000 limit
06:51:13 <oolongCat> After going through /r/haskell and wiki.haskell.org I think I am going to start teaching myself Haskell using "Learn You a Haskell for Great Good".  Do you guys/girls think its a good idea for me to use it? I think I am an "alright-ish-kinna-like-you-know.." programmer (:p I use mostly golang and sometimes js at work). 
06:52:50 <vaibhavsagar> oolongCat: http://bitemyapp.com/posts/2014-12-31-functional-education.html
06:53:20 <hpc> also https://github.com/bitemyapp/learnhaskell
06:53:24 <jgzh6> Can't work out how to do recursion
06:53:34 <benzrf> oolongCat: cis194 or haskellbook is better, imo :)
06:53:54 <hpc> the spring 2013 cis194 at least
06:54:17 <hpc> it got weirdly bad in fall 2014
06:54:38 <hpc> (as a general purpose learning tool anyway)
06:56:41 <pavonia> jgzh6: That second part of my example is the recursive call
06:57:32 <jgzh6> ..how do I apply that to solve the question..?
07:00:43 <pavonia> jgzh6: You just have to modify that to stop at n == 1000, it shouldn't be hard to do
07:02:55 <buglebudabey> if i am interested in implementing a language through haskell (that compiles to machine code or assembly) or even making my own OS, but also want to learn the many useful topics in haskell, should i prioritize one over the other, or try to learn each at the same time and marry the two?
07:05:12 <hpc> buglebudabey: if you work on both at the same time, it's pretty natural to switch from one to the other when you hit a roadblock
07:05:15 <ggole> Learning to write a compiler and how to Haskell at the same time would be either enormously painful or enormous fun
07:05:24 <ggole> Or both at once, I suppose.
07:05:30 <hpc> you'll probably find yourself iterating on your compiler a lot
07:05:50 <ggole> Good way to learn a ton of stuff real fast though
07:05:53 <hpc> i would be surprised if you finished it without refactoring every line of code 2 or 3 times
07:06:12 <hpc> having a project helps a ton with learning as well
07:06:43 <buglebudabey> hpc i've sort of already implemented a Core -> GCode compiler but I have a feeling I could refactor it to include useful things like Reader, but I'm also eager to implementing something on stock hardware, but using best practices
07:07:23 <buglebudabey> ggole yeah i just don't want to spread myself too thin, what's learning the finer things in haskell if you don't try to implement them
07:08:56 <benzrf> whats gcode?
07:09:32 <ggole> gcode? The cnc langauge?
07:09:59 <buglebudabey> benzrf ggole have you heard of the G-Machine, or the STG Machine?
07:10:11 <eklavya> the idea of using ExceptT is that I can remain in that monad and keep transforming the results however I want, assuming that every stage resulted in some result and not error and then when I run it, I will either get the final result or the earliest error, am I correct?
07:10:15 <benzrf> i'm only roughly familiar
07:10:26 <benzrf> in fact, more like "mostly unfamiliar, but i know some of the concepts"
07:10:32 <benzrf> *underlying concepts
07:10:43 <ggole> Oh, STG. I thought you were talking about something very different.
07:10:52 <benzrf> buglebudabey: btw - if you're not already using reader, it sounds like you probably haven't gotten very far in learning about practical haskell programming
07:11:03 <buglebudabey> benzrf haskell compiles down to a few intermediate languages, Core, STG, then C--
07:11:17 <benzrf> well, it does in ghc ;)
07:11:18 <buglebudabey> benzrf G was the predecessor to STG and theyre now very different
07:12:05 <jgzh6> I'm completely new to FP..
07:12:10 <buglebudabey> benzrf i'm not already using reader, i still have a lot to learn
07:12:20 <jgzh6> really can't work out recursion and folds
07:12:31 <buglebudabey> jgzh6 want a simple example?
07:12:57 <buglebudabey> jgzh6 there are lots of things that can be 'folded' but the easiest example is probably a list
07:13:07 <jgzh6> I'd like to have a solution to my question http://lpaste.net/172695
07:13:43 <jgzh6> I'm trying to rewrite this https://gist.github.com/billc/1105f7f8ec94508ba82f in haskell
07:15:37 <benzrf> buglebudabey: well, for what it's worth - by "practical haskell programming", i mean something more like "structuring software in haskell well"
07:16:13 <buglebudabey> jgzh6 send me a private message i'll try to help you
07:16:23 <benzrf> like how even once you get the hang of functions, for loops, lists, etc, in javascript, you still need to learn how to actually design programs and use the abstractions well
07:17:06 <buglebudabey> benzrf yeah makes sense, but for me that includes using things like monad and applicative and the rest where appropriate, which i need to learn how to do
07:20:55 <benzrf> yeah, that's what i meant
07:29:19 <ertes> jgzh6: first work out recursion, then work out folds, because the latter is really an abstraction over the former
07:29:34 <ertes> (usually)
07:30:19 <Duff_man> hello
07:31:04 <h0r3b> hello
07:31:28 <ertes> helo
07:33:41 <Duff_man> Why haskell?
07:34:26 <Duff_man> what does it give?
07:34:34 <oherrala> why not?
07:35:03 <Duff_man> oherrala: how useful is it?
07:35:45 <exio4> Duff_man: extremely :)
07:35:45 <oherrala> Duff_man: your questions are vague and general. Haskell is general purpose programming language (like many others) so it's as useful as anything else.
07:36:07 <ertes> Duff_man: that's a very generic question, and i promise that none of the answers will be useful, although it will give you a general idea of the bias of this channel =)
07:36:44 <oherrala> There's lots of hits in google for "why haskell" and "why not haskell"
07:38:39 <Duff_man> its not a general question really. I'm asking for your personal opinions. Why did you choose haskell?
07:39:50 <maerwald> Duff_man: declarative nature (although that concept breaks a lot) and maintainability (1k LOC vs 100k LOC isn't that much different)
07:40:13 <ertes> Duff_man: i switched to it from C++ (and to some extent PHP) about 9 years ago, and i switched to it, because it worked for me and continues to work…  mean reason for me is that it gives me cheap abstractions
07:40:29 <infandum> Question about parallel haskell: I have a big list, say 80,000 elements (this is actually much smaller than the reality but for my toy example this is what I use). Each element contains two vectors. I run a correlation between those two. According to profiling, this is where all of the time and allocation is used up. I have the list generated with (correlate <$> vectors <*> vectors). To parallelize, I put
07:40:32 <infandum> withStrategy (parList rdeepseq) and run with -Nwhatever. However, it's ALWAYS faster with -N1 -- why would this be? 80000 correlations isn't too small grain I wouldn't think...
07:40:33 <ertes> Duff_man: on several occasions i also appreciated cheap refactoring
07:41:22 <alercah> Haskell has cheap refactoring?
07:41:27 <ertes> infandum: parList and parMap really suck on large lists…  use parBuffer instead
07:41:52 <ertes> infandum: it gives you about the same performance, but with different slicing that doesn't require the whole list
07:42:08 <infandum> ertes: I used parListChunk and it also wasn't so great. I didn't quite understand what the documentation was saying about parBuffer, what the Int was exactly
07:42:22 <maerwald> alercah: because of the strict typing basically. Not the tools
07:42:36 <ggVGc> alercah: you don't think refactoring in haskell is very easy?
07:42:43 <ggVGc> and especially safe
07:42:55 <infandum> ertes: I do have the notation right, right? other . functions . withStrategy (parList rdeepseq) $ correlate <$> vectors <*> vectors
07:43:15 <maerwald> ggVGc: tools-wise it's not easy (and don't tell me "sed"), but type-wise it's easy
07:43:17 <ertes> infandum: think of parBuffer as a transposed parListChunk…  i think that's accurate prose to explain it
07:43:17 <alercah> ggVGc: safe, yes. Easy, no.
07:43:32 <Duff_man> wow! very nice
07:43:40 <ertes> infandum: yeah, that looks correct to me
07:44:03 <ertes> infandum: if it's only the correlation you want to parallelise
07:44:19 <maerwald> ggVGc: you also get to the problem that the compiler cannot guide you properly where to _start_ fixing things, so that the compiler errors become less confusing. It just starts somewhere, where the first error occurs.
07:45:21 <ggVGc> yeah, that's true
07:45:23 <infandum> ertes: Yeah, I mean the though was I have a giant list where one function is mapped to it all, so might as well have some threads cut up the load.
07:45:28 <ggVGc> I think you develop a feel for it though
07:45:31 <ggVGc> but yeah, definitely not optimal
07:45:42 <ggVGc> I sometimes get lost in the refactoring and have to backtrack
07:45:44 <ggVGc> which is pretty bad
07:45:47 <ertes> infandum: if you want to make this really cheap, you need to get rid of the list
07:46:04 <infandum> ertes: How?
07:46:09 <ertes> infandum: currently your code probably suffers most from bad memory locality
07:46:13 <infandum> ertes: Is there a faster way to compare all to all?
07:46:14 <maerwald> on some occasions I ended up using a lot of type synonyms for rather trivial things, because those were frequently subject to refactoring
07:46:14 <ertes> infandum: use vectors
07:46:23 <infandum> ertes: It's a list of vectors haha
07:46:37 <ertes> infandum: no, i mean vectors in the sense of the vector library, i.e. arrays
07:46:42 <ertes> @package vector
07:46:42 <lambdabot> http://hackage.haskell.org/package/vector
07:46:50 <mizu_no_oto_work> alercah: I think the argument is that refactoring is easier in Haskell than in many other languages because the compiler tells you exactly what needs to change; you don't need to repeatedly run your tests to make sure you didn't miss anything
07:46:51 <infandum> ertes: But it's from a Map, so there is no Map.toVector
07:47:11 <alercah> mizu_no_oto_work: eh, you still do
07:47:12 <ertes> infandum: there is nothing wrong with going through a list to create the vector
07:47:14 <infandum> ertes: I mean (vectors :: [Vector.Vector]
07:47:19 <infandum> ertes: I mean (vectors :: [Vector.Vector Double]
07:47:22 <infandum> actually
07:47:45 <ertes> infandum: this is pretty cheap:  V.fromListN (M.size xs) (M.elems xs)
07:48:08 <ertes> (or M.assocs or M.keys)
07:48:13 <infandum> ertes: How is that different from V.fromList . M.elems $ xs?
07:48:34 <ertes> infandum: it uses a single large allocation instead of a growing memory region
07:48:51 <ertes> you're telling it upfront how much memory to allocate
07:48:51 <infandum> ertes: Wow, I've been maiking them wrong this whole time
07:49:23 <ertes> infandum: also make sure that you use the right flavour of vectors
07:49:44 <ertes> if you can unbox your stuff, use unboxed vectors; the next best option is storable vectors, and the last resort is boxed vectors
07:50:11 <infandum> ertes: What is the default?
07:50:19 <ertes> Data.Vector is boxed
07:50:34 <ertes> there is really no default…  you get what you import =)
07:50:36 <infandum> And how would having vectors instead of lists change parallelism
07:51:14 <ertes> it doesn't change parallelism, but it does change memory locality, so you get better cache performance
07:51:29 <ertes> that can give a considerable performance boost
07:51:43 <infandum> interesting
07:52:17 <ertes> the next thing you can do is this:  you said that the elements are themselves vectors of doubles
07:52:26 <ertes> do they have a fixed length?
07:52:44 <infandum> ertes: How cheap is V.toList?
07:53:00 <infandum> ertes: What do you mean, the vectors?
07:53:13 <ertes> it's "free" (depends on how you consume the resulting list)
07:53:31 <ertes> the element vectors
07:53:33 <infandum> ertes: Oh shoot, they aren't doubles, they are actually algebraic data
07:53:47 <infandum> ertes: But I can convert them easily with a map before hand
07:54:17 <infandum> The vectors are a fixed length, I don't change them
07:55:48 <ertes> how long are they?  or is that dynamic?
07:56:46 <infandum> ertes: Dynamic
07:56:58 <infandum> depends on the lengths of the input
07:57:23 <Gurkenglas> Does something provide functions like "(Functor f, Applicative g) => f a -> Compose f g a" and "Applicative f => g a -> Compose f g a"?
07:58:48 <ertes> infandum: well, to improve parallel performance and performance in general, the basic idea is to get things as close as possible to each other in memory
07:59:24 <ertes> infandum: which basically means: use as few indirections as possible…  try to get rid of boxes
08:00:01 <ertes> infandum: it's a general rule of thumb for code that does heavy number-crunching
08:00:09 <infandum> ertes: Alrighty. It's a shame that a lot of the elements are algebraic or tuples
08:00:30 <ertes> infandum: tuples have an Unbox instance by default
08:00:52 <Welkin> (# 4, 5) :D
08:00:54 <Welkin> right?
08:00:57 <Welkin> er
08:01:01 <Welkin> (# 4, 5 #) :D
08:01:18 <ertes> infandum: for custom types you can usually write the necessary boilerplate with reasonable effort…  i think there is even a template haskell library that does it for you
08:01:19 <infandum> ertes: oh. Well it's also a shame that I also use sets and newtypes haha
08:01:33 <exio4> newtypes aren't the issue ;)
08:01:38 <ertes> well, if you use recursive types, you're on your own =)
08:02:23 <ertes> one way to get unboxed sets is to use ordered arrays with binary search
08:02:33 <infandum> ertes: Well they aren't recursive, I don't think
08:02:39 <ertes> Set is recursive
08:03:09 <infandum> just like newtype DontConfuseWithAnotherType = DontConfuseWithAnotherType Int
08:03:11 <infandum> for example
08:03:23 <infandum> oh
08:06:19 <infandum> ertes: You seem to know a lot about perfomant haskell--are Tries better structures in general than Maps?
08:06:37 <ertes> infandum: most of the time, but not always
08:07:26 <ertes> and by trie i assume that you mean radix tree (a.k.a. PATRICIA tree)
08:07:28 <infandum> I was looking at Trie implementations, and it was weird how variable they were. Some had Trie.size as O(1) while other had it as O(n)
08:07:38 <infandum> ertes: yeah
08:08:00 <ertes> i think i've only used three trie types
08:08:10 <dolio> It also depends what you mean by "Maps", because tries are an implementation technique for maps.
08:08:39 <dolio> One of many.
08:08:49 <ertes> HashMap, IntMap, bytestring-trie in order of frequency
08:08:55 <ertes> descending
08:11:04 <dolio> It's also difficult to say which data structure is better than another by looking at implementations, because the latter will vary in terms of random optimization tricks that may be applicable to other structures, but haven't been.
08:12:36 <infandum> hmm, I wish there was a giant flowchart of which to use
08:12:55 <infandum> or even better a table of computational complexity for different functions comparing them all
08:13:11 <Welkin> just choose the one that makes sense
08:13:22 <Gurkenglas> Or make code that works with all, then let someone else choos
08:13:23 <Gurkenglas> *e
08:13:34 <Welkin> complexity is just theoretical
08:13:46 <Welkin> how does it actually perform in practice?
08:13:54 <infandum> It's helpful though
08:14:06 <infandum> otherwise you would have to spend a bunch of time testing each one
08:14:14 <ertes> infandum: benchmark on realistic workloads
08:14:15 <Welkin> a lot of that time could be a huge waste
08:14:21 <Welkin> only optimize if you absolutely need to
08:14:36 <infandum> true, true
08:14:45 <ertes> infandum: at some point you get a feeling for which structure will work best, but until then that's really your only option
08:14:51 <infandum> but it *feels* dirty knowing that you *could* do better
08:14:57 <glguy> Welkin, are you optimizing away optimization?
08:15:19 <Welkin> lol
08:15:23 <Gurkenglas> glguy, are you optimizing away optimizing away optimization?
08:15:33 <ertes> infandum: you *could* always do better, but if you think like that, you will go crazy =)
08:15:44 <glguy> Gurkenglas: No way, making it take longer by talking about it
08:15:51 <infandum> Well if it says I'm using 60% time AND allocation on one function, then I should probably optimize it haha
08:15:53 <ertes> you will end up requesting -XInlineAssembly on the GHC issue tracker
08:16:18 <Welkin> lol
08:16:22 <Welkin> reminds me of inline-c
08:16:26 <Welkin> @hackage inline-c
08:16:27 <lambdabot> http://hackage.haskell.org/package/inline-c
08:16:36 <implementation> -XInlineBrainfuck
08:16:55 <ertes> you will end up writing TH code just to get rid of run-time initialisation
08:17:06 <infandum> all of that sounds so painfull
08:17:19 <infandum> I just want even distributions of time haha
08:17:22 <infandum> and lower memory
08:18:17 <ertes> infandum: reducing memory usage is very often a good first step to reduce CPU time by using less pointer chasing and better cache behaviour
08:18:35 <ertes> but that's not a general rule
08:18:46 <ertes> HashMap often performs better than Map, but uses *more* memory
08:18:47 <infandum> it's weird that one function is taking up most of the allocation when it's only looking at one element at a time
08:18:53 <infandum> I bet weird things are going on
08:19:28 <infandum> I wonder if kendall in the statistics package is what the real issue is
08:19:55 <infandum> it's using a "+" with no bang patterns in recursion
08:20:09 <infandum> for an accumulator
08:20:23 <Welkin> infandum: foldl?
08:20:42 <infandum> https://hackage.haskell.org/package/statistics-0.13.2.3/docs/src/Statistics-Correlation-Kendall.html#kendall
08:21:39 <infandum> in merge
08:22:13 <Welkin> an inplace mergesort, haha
08:22:14 <infandum> nevermind, it has bangts
08:22:24 <infandum> whatever, I don't know what I'm talking about
08:23:32 <Gurkenglas> Compose IO ZipList needs combinators.
08:38:16 <haskell564> where is the standard 'fold' function to go from a f-algebra to an evaluation function from Fix f ?
08:41:03 <codedmart> I am working on a web api server. My types have an `id` attribute, but when a new type is created, say User, they don’t have a id yet. They are just sending the other attributes. I have `id` as a `Maybe` field right now, but I would like it to not be `Maybe`. So what are my alternatives? Have a `UserParam` type that doesn’t include the id? Are there
08:41:03 <codedmart> other ideas I am not thinking of?
08:41:14 <notdan> haskell564: maybe in recursion-schemes?
08:41:50 <notdan> haskell564: https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#v:cata
08:43:11 <implementation> codedmart: you could remove the id attribute from the types, and then deal with something like `data UserEntity = UserEntity { getId :: UserId, getData :: User }` where you need the id
08:44:14 <codedmart> implementation: Hmm… not sure I understand how that works. Is `Entity` a persistent thing? I am using rethinkdb.
08:46:15 <implementation> codedmart: yes, persistent uses this idea too. but that doesn't mean one can't do it that way in a non-persistent app
08:49:29 <haskell564> notdan : thanks ! i thought it would be in some base library somewhere...
08:49:41 <codedmart> implementation: OK I will have to look into how that works. Thanks!
08:51:18 <haskell564> a very stupid question : what do you guys use to read irc ? i use a web client, am i inflicting myself some undue pain or is that the standard way to read the haskell irc chatroom ?
08:51:21 <implementation> codedmart: the idea is as simple as the following: Instead of having a type like `data User = User { getId :: Maybe UserId, getName :: String, ... }`, you take `data User = { getName :: String, ... }` (without id), and create an additional type like `data UserWithId = UserWithId { geId :: UserId, getUser :: User }` (oder call it UserEntity, or make it more general, or use a pair, ...)
08:52:10 <haskell564> maybe that's good for the off topic chatroom..
08:52:20 <geekosaur> haskell564, there's at least two different web interfaces (freenode's minimal one, irccloud's more featured one) and there are many non-web clients. I personally use hexchat
08:52:21 <glguy> haskell564: I use my own IRC client
08:52:56 <monochrom> I use hexchat.
08:53:05 <codedmart> implementation: Thanks!
08:53:51 <glguy> http://imgur.com/a/VVyEY current view
09:07:47 <cloudhead> anyone got a nice example of a package with multiple executables depending on the same internal library?
09:11:50 <glguy> cloudhead: Not off the top of my head, but it's not much different than a single executable, just the subsequent ones have different names
09:12:26 <cloudhead> glguy: I know how to configure it, just wondering about package layout
09:13:05 <cloudhead> I guess something like Client/Main.hs  Server/Main.hs  Library/...
09:13:21 <glguy> Yeah, you'll want separate hs-source-dirs:
09:13:29 <glguy> especially between the executables and the library
09:13:59 <cloudhead> oh hmm
09:14:14 <cloudhead> so right now it's actually src/Client src/Server src/Library
09:14:50 <glguy> If your library modules are visible in your executable's hs-source-dirs: then GHC will recompile those modules when it builds the executable rather than use the library
09:15:07 <glguy> which means you'll get multiple, incompatible versions of the types in those modules
09:15:32 <glguy> You'll notice that type class instances are missing and that compilation takes longer
09:16:03 <cloudhead> ahh
09:16:36 <cloudhead> I see, so by using completely separate hierarchies, I ensure proper encapsulation
09:17:08 <ghorn> I have a job posting, I'd love some feedback on it before I post it to haskell-cafe https://gist.github.com/ghorn/05eb51cb9d9e44889811a77d26e872f6
09:24:31 <tito78> primes = filterPrime [2..] 
09:24:31 <tito78>   where filterPrime (p:xs) = 
09:24:31 <tito78>           p : filterPrime [x | x <- xs, x `mod` p /= 0]
09:29:29 <cloudhead> ghorn: seems pretty good - a little confusing to ask for resume/github in the 'Desired' section, should probably be in a 'How to apply' section. Perhaps a bit more about the culture would be nice too, ie: what's it like to work there on a day to day basis
09:30:02 <Gurkenglas> tito78, nice code bro
09:30:32 <ghorn> cloudhead: good points, i will update
09:34:36 <buglebudabey> ghorn as someone who finds this interesting and would consider applying, what do you consider significant experience? i use all your "including.." criteria but can imagine you'd want a more experienced person
09:35:07 <ReinH> ghorn: that's a pretty cool job
09:35:53 <edran> ghorn: You might want to specify whether you are also allowed to take non-US people or not
09:36:04 <ReinH> "unlimited time off" is a red flag, but you ofc you can't change your policy.
09:36:29 <edran> I've often spent a lot of time applying for jobs only to the get rejected based on nationality :/
09:36:57 <edran> s/nationality/citizenship
09:37:07 <ghorn> RienH: I don't understand, why is that a red flag? to be honest I copied the boilerplate section from another job post at the company
09:37:18 <monochrom> People who post job postings on the Internet often forget that they're posting on the Internet.
09:37:30 <ReinH> ghorn: because those policies benefit the employer at the expense of the employee while being spun to appear the opposite.
09:37:35 <monochrom> (Of course, as in, internationally.)
09:37:48 <ghorn> edran: thanks, i will specify
09:37:52 <edran> :)
09:39:05 <monochrom> what does "unlimited time off" mean?
09:39:10 <buglebudabey> i'm sorry if i missed your reply ghorn , i was disconnected
09:39:23 <glguy> monochrom: You're free to quit at any time
09:39:31 <ghorn> buglebudabey: sorry, getting to that
09:39:41 <buglebudabey> ghorn no worries
09:39:47 <ReinH> What that policy actually does is save *the company* ~$2k per employee because they don't, e.g., have to pay out accrued PTO.
09:40:23 <glguy> It puts employees in competition with each other to avoid taking time off because there's no baseline expectation that everyone should be taking
09:40:52 <ReinH> Employees already don't take off enough of their allotted PTO, and there are generally repercussions for taking too much "unlimited" time off, so it doesn't really change things for the employee
09:42:50 <okiharaherbst> hello all, does anyone have any experience with the soap library?
09:43:00 <cloudhead> really depends on the company, re: unlimited time off
09:43:06 <glguy> ?where justask
09:43:06 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
09:43:23 <glguy> Anyway, back to topic
09:43:36 <ReinH> cloudhead: you know what *doesn't* depend on the company? Fixed PTO.
09:43:39 <ghorn> it's a small company and I've personally taken large blocks of time off
09:43:50 <ReinH> You know how much you're getting, and you are guaranteed it by your employment contract.
09:43:51 <glguy> We can continue this time off problem in -offtopic
09:43:55 <ghorn> these days I don't take time off because i want to be at the center of things
09:43:56 <cloudhead> sure, but I'd rather not have my days counted
09:43:58 <ReinH> glguy: l
09:44:07 <ReinH> cloudhead: they are counted, you just don't know the secret number.
09:44:20 <ReinH> glguy: er, "k". The keys are right next to each other.
09:44:51 <cloudhead> by counted I mean, limited :)
09:44:56 <ReinH> Me too.
09:45:13 <ReinH> Try to take 6 months off, see what happens.
09:45:14 <ghorn> currently one guy is spending two weeks in alaska doing bush pilot flying
09:45:21 <monochrom> time to say: what have I done?!
09:45:39 <glguy> You can have unlimited unlimited time off discussions in #haskell-offtopic
09:45:42 <ghorn> monochrom: i came here for advice on mainly the non-boilerplate section
09:45:44 <cloudhead> sure, not 6 months, but definitely more than the standard time off would be feasable
09:45:44 <ReinH> glguy: :D
09:45:47 <glguy> and by unlimited I mean limited
09:45:52 <ghorn> :)
09:45:55 <ghorn> :/
09:46:23 <ReinH> cloudhead: we can continue on -offtopic, but TL;DR: I don't believe you.
09:46:28 <cloudhead> kk
09:47:41 <ghorn> buglebudabey: it's not an entry level posting, we're looking for someone with years of professional SWE experience with either a haskell component or years of non-professional haskell development
09:48:06 <buglebudabey> ghorn i'd specify something like that
09:48:37 <ghorn> thank you, i will edit that
09:48:57 <buglebudabey> ghorn either x years haskell plus C/C++... or x years professional dev + whatever haskell
09:49:51 <ghorn> buglebudabey: I was trying to give guidelines without ruling out an exceptional inexperienced person
09:50:02 <buglebudabey> but that's me
09:50:32 <ghorn> i invite you to apply!
09:51:02 <ghorn> to all: sorry if i derailed the discussion a bit, but thank you for your feedback
09:51:59 <buglebudabey> ghorn i kid, but i think if that's what you were going for then your ambiguity gave me hope i could apply :P
09:55:49 <buglebudabey> does anyone have a good resource for implementing functional programming languages other than the book or tutorial with that title?
09:59:40 <johnw> buglebudabey: you could try Pierce's book on Types and Programming Languages
10:02:16 <buglebudabey> johnw that seems like a great book actually, probably would solidify anyones understanding of haskell, right? do you know of anything similar to that which goes into compiling to assembly like GHC does?
10:02:42 <johnw> to the former question: most certainly; to the latter, I don't know
10:06:49 <vaibhavsagar> buglebudabey: have you seen http://dev.stephendiehl.com/fun/?
10:07:24 <jackhill> johnw: there is Simon Peyton Jones's _Implementation of Function Programming Languageso http://www.worldcat.org/title/implementation-of-functional-programming-languages/oclc/14098924
10:07:39 <buglebudabey> vaibhavsagar yes but he is only on chapter 10 of that book and he doesn't even reach Core until chapter 15
10:07:48 <buglebudabey> vaibhavsagar he's been barely contributing to it lately
10:08:02 <vaibhavsagar> you're right
10:08:12 <vaibhavsagar> it does seem pretty close to what you're looking for though
10:08:20 <buglebudabey> vaibhavsagar wouldn't it be nice :P
10:08:49 <jackhill> vaibhavsagar: oh neat!! yes, if only there were more time in the world
10:08:55 <Gurkenglas> http://lpaste.net/172731 Code review this!
10:22:27 <fragamus> hey can you guys help me set up something that will statefully run through combinations (non-determinism)
10:23:24 <mmachenry1> @Gurkenglas you have a redundant do on line 68 and should use *** on line 92. ;)
10:23:25 <lambdabot> Unknown command, try @list
10:24:39 <fragamus> so that while it is running through combinations it is maintaining some state
10:25:26 <Gurkenglas> Of course, "Just $ (x,y) - fst r". What was I thinking
10:26:03 <Gurkenglas> Oh and yes hlint too
10:27:30 <monochrom> put your combinations in a list. use foldl on it.
10:29:02 <fragamus> monochrom i was thinking more along the lines of monad transformers i am trying to master them
10:29:18 <Gurkenglas> You mean StateT s []?
10:29:25 <monochrom> I prefer to simplify problems.
10:29:33 <monochrom> or maybe I mean simplify solutions.
10:29:39 <fragamus> ah
10:30:15 <Gurkenglas> @let modifyT f = StateT \s -> ((),) <$> f s
10:30:15 <lambdabot>  Parse failed: Parse error: \
10:30:22 <monochrom> StateT s IO is a worthy thing to do and you can likely find a worthy problem that could use it.
10:30:22 <Gurkenglas> @let modifyT f = StateT $ \s -> ((),) <$> f s
10:30:24 <lambdabot>  Defined.
10:30:50 <divVerent> Line 73: onMouse _ = pure (), with onMouse returning StateT S m () - is that usual style?
10:31:00 <monochrom> but "statefully walk through combinations" is just a foldl and has no reason to get StateT involved.
10:31:03 <divVerent> I mean, StateT can never be Applicative without also being Monad
10:31:32 <fragamus> it is a little more involved monochrom
10:31:32 <Gurkenglas> > execStateT (modifyT (\x -> [x, 5*x]) >> modifyT (\x -> [x-1, x+1])) 100
10:31:33 <lambdabot>  [99,101,499,501]
10:32:45 <Gurkenglas> Of course if you aren't going to be using the value slot of StateT s [], you might as well just use foldlM
10:33:11 <Gurkenglas> :t foldlM
10:33:12 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
10:33:24 <fragamus> there is a pruning aspect to this thing based on state
10:33:56 <Gurkenglas> Consider Cofree [] too.
10:34:08 <fragamus> so the non-determinism needs to be interwoven with conditionals based on state
10:34:30 <Gurkenglas> > foldlM (flip ($)) 100 [\x -> [x, 5*x], \x -> [x-1, x+1]]
10:34:31 <lambdabot>  [99,101,499,501]
10:34:47 <Gurkenglas> @let import Control.Comonad.Cofree
10:34:49 <lambdabot>  Defined.
10:36:40 <Gurkenglas> > coiter (\x -> [1..x-1]) 4
10:36:41 <lambdabot>  4 :< [1 :< [],2 :< [1 :< []],3 :< [1 :< [],2 :< [1 :< []]]]
10:38:13 <Gurkenglas> monochrom, i invoked StateT s [], not StateT s IO
10:38:20 <Gurkenglas> or wait do you mean the lpaste
10:40:02 <shapr> Are there any packet editing tools in Haskell? I'd like to modify packets in a packet capture file.
10:40:22 <Gurkenglas> Oh hey I wasn't even using any IO in onMouse and hadn't propagated that up to main yet. lpaste updated.
10:41:54 <Gurkenglas> Should we use State s or Monad m => StateT s m? The first is shorter, the second can be used in monadic operations without modification.
10:41:59 <Gurkenglas> *more monadic
10:42:18 <structuralist> is there a standard module for type-level programming including things like "Fst '(a, b) = a"?
10:42:20 <Gurkenglas> -operations+definitions, I guess
10:42:55 <springer> how would haskell and an frp library work for soft realtime applications such as 3d fluid simulations? too memory intensive or doable?
10:43:51 <shapr> I dunno about frp, but it's totally doable with Haskell
10:45:28 <structuralist> @Gurkenglas: in practice, probably mtl? MonadState s m => ...
10:45:28 <lambdabot> Unknown command, try @list
10:46:38 <structuralist> what do people use for type-level programming nowadays?
10:47:14 <Gurkenglas> Oh right when I try to put MonadState somewhere it says it doesnt know that, if I then import Control.Monad.State.Class I have stuff defined by multiple places, and if I take out the Control.Monad.Trans.State import I cant use gets anymore
10:47:15 <ggVGc> javascript
10:47:17 <shapr> springer: have you seen the various FPS games in Haskell?
10:47:18 <Gurkenglas> What do?
10:47:22 <glguy> structuralist: @ is for bot commands, not addressing people
10:47:36 <Gurkenglas> Also why does gloss take so much cpu, can that be avoided?
10:47:37 <shapr> heh, slack
10:47:50 <structuralist> yeah it's been a while since I've used IRC :)
10:48:09 <ggVGc> shapr: was that a joke or are there actually fps games in haskell?
10:48:11 <ggVGc> that are playable
10:48:23 <shapr> ggVGc: there have been, I haven't checked recently. Someone made a quake clone.
10:48:46 <springer> shapr: yes, at least frag :) 
10:48:53 <shapr> right, frag
10:49:54 <springer> shapr: I guess i'll have to try
10:50:33 <structuralist> Gurkenglas: in general you could make much more use of 'where' clauses
10:50:53 <springer> shapr: i've never done resource intensive programming in haskell, so I thought it was worth asking before trying and finding out it runs super slowly or with huge gc pauses
10:51:00 <Gurkenglas> But then I'd have to name things :c
10:51:26 <shapr> springer: bad code can be written in any language :-)
10:51:34 <shapr> sometimes I write it :-|
10:52:07 <structuralist> I find that good code structure is correlated with ease of naming, so that's not necessarily bad
10:54:00 <Gurkenglas> I find that naming is hard in general, huh.
10:54:31 <Gurkenglas> Easiest when you keep to the kind of stuff you've seen named by other people
10:55:01 <structuralist> also I think it's easier with declarative code than with procedural code
10:55:17 <springer> shapr: yup, that's true. thanks for your help!
10:55:32 <Gurkenglas> Can that be made less procedural?
10:56:27 <structuralist> I would bet so but I can't really tell what it does
10:56:46 <Gurkenglas> http://lpaste.net/5831674485333295104 stack should install those automatically >:c
10:59:48 <Gurkenglas> Okay, walkthrough of http://lpaste.net/172731 : The game state S keeps track of a number of rectangles (by two corners) and whether the mouse is pressed, and if so, what to do with its position whenever it moves
11:00:19 <Gurkenglas> 36 reads the command line argument, 37 loads the serialized [Rectangle] in that file or [] if that fails. 38 is gloss's interface to run a game. 39 are its window settings, 40 the background color, 41 the number of times per second to run 45, 42 initializes a world state to the loaded [Rectangle] and says the mouse starts off unclicked. 43 says how to turn S into a picture, 44 how to let S handle input, 45 what to do each second
11:01:25 <Taneb> > let (i, g) = random (mkStdGen 10) in i --why does this fail?
11:01:26 <lambdabot>      No instance for (Random t0)
11:01:27 <lambdabot>      The type variable ‘t0’ is ambiguous
11:01:27 <lambdabot>      When checking that ‘g’ has the inferred type
11:01:45 <Taneb> (it fails even when the type of i is known)
11:02:00 <Gurkenglas> 43 takes the rectangles, each is piped through 50, 51 makes it green if it covers the whole screen, its drawn as a rectangular shape either way, 43 lets 55 color the as of yet uncolored ones red, blue, white, white, white...
11:02:05 <Taneb> It seems to type g as Random mysteryvariable => StdGen
11:02:46 <Gurkenglas> 44 passes any input to 57 and says that theres no IO happening in there
11:03:06 <Gurkenglas> 45 seruializes the rectangles and puts them into file, autosaving every second.
11:04:03 <structuralist> what is the _sMouse field again?
11:04:41 <Gurkenglas> 58 handles leftclicks. 59 finds all rectangle indices of rectangles the mouse is inside, and the distance from the first corner, using 87
11:05:24 <Gurkenglas> _sMouse, which 33 turns into the mouse lense, is just whenever the mouse is pressed and keeps track of how to handle mouse movement
11:05:49 <Gurkenglas> -lense+lens
11:06:44 <Gurkenglas> 88 uses the trivial 85 to make the first corner represent the upper left one, then trivially computes the coordinates of the mouse within the rectangle
11:06:59 <structuralist> it's a little strange to store a function in the state... I would guess that the range of possibilities for that function could be captured by a smaller, more descriptive type
11:07:22 <structuralist> the data that specify what that function should be
11:07:35 <Gurkenglas> we'll see
11:07:44 <EvanR> or the syntax of a lambda expression
11:10:16 <Gurkenglas> 60 for each found rectangle, which by invariant happens to be at most one, maybe i should encode that in the type, executes 61 on the clicked rectangle, which says "try to drag this rectangle, moving both its corners, such that the point you clicked will be one pixel closer to the mouse"
11:10:46 <takanuva> I got this function http://pastebin.com/58x1Qcpx... is there a more elegant way of writing that? I thought of an applicative, but the second command needs the first to succeed... :(
11:11:21 <glguy> takanuva: You can use do notation
11:11:45 <glguy> do (n,aux) <- tdpl first str; (m, cdr) <- tdpl second aux; return (n + m, cdr)
11:11:55 <structuralist> takanuva: did you forget the base cases?
11:11:56 <Gurkenglas> 62 handles rightclicks. 63 spawns a rectangle at the rightclickedpoint and adds it to the end of the list to preserve indices of earlier rectangles. Hmm that might not be so important anymore in this version. 64 says "try to drag the last spawned rectangle, moving its second corner, such that the second corner will be one pixel closer to the mouse"
11:12:17 <takanuva> structuralist: this code is just an example; I got the base cases done as well
11:12:28 <Gurkenglas> (if I wanted to save those traversals in _sMouse, I'd have to reify them or however thats called)
11:12:34 <takanuva> glguy: great idea!
11:12:36 <glguy> takanuva: Instead of writing:  otherwise -> stuff, you should write: _ -> stuff
11:12:46 <glguy> takanuva: What you wrote is shadowing the definition of otherwise
11:12:57 <glguy> You'll use otherwise as a default guard, not a pattern
11:13:10 <glguy> Pattern | otherwise -> stuff
11:13:12 <Gurkenglas> 65 gets rid of the action the mouse keeps track of when it releases a button.
11:13:18 <takanuva> oh... good to know!
11:14:10 <Gurkenglas> 66 handles mouse movement. 67 takes the mouse action, and if any, applies the mouse position to it, repeats the action until it fails, and promises to the compiler that that means the composition doesnt fail
11:14:45 <Gurkenglas> 68 checks whether the first rectangle is touching the second, 69 checks whether the rectangle that makes us spawn already exists, and 70 spawns a rectangle covering the screen when appropriate
11:15:53 <glguy> Gurkenglas: Maybe just annotate those as comments in your paste
11:15:54 <Gurkenglas> 73 says how to move rectangles. 74 says that we do not care for what the mouse is doing. 81 nondeterministically chooses whether to move along either or both axes.
11:16:18 <glguy> rather than pasting them into channel where they'll be lost and require manual cross reference
11:16:34 <Gurkenglas> That'd make the whole thing at least twice as long. I can read it fine. Is there a way to attach comments without them dispersing the code?
11:16:49 <shapr> springer: will you be recording your discoveries on a blog or twitter or something?
11:16:53 <Gurkenglas> it = the code
11:16:54 <glguy> Gurkenglas: Even if you're doing that temporarily for the purposes of walkthrough
11:17:11 <springer> shapr: not yet at least. maybe if it progresses into something fruitful
11:18:09 <takanuva> glguy: thanks, I completly forgot that do would stop when Nothing was found... also, thanks for the otherwise tip! :)
11:18:29 <Gurkenglas> putting it in there, if im going to discard it afterwards ... makes sense. Ill do that for the remainder
11:21:19 <glguy> Gurkenglas: as far as how to include this kind of content permanently in your source file, I'd suggest naming more things
11:21:32 <glguy> Gurkenglas: Instead of -- this checks the bottom left corner of the rectange
11:21:42 <glguy> let bottomLeftCornerCheck = thecheck,
11:21:52 <glguy> and then use bottomLeftCornerCheck somewhere
11:23:26 <structuralist> Gurkenglas: my advice would be to try writing this without importing anything from Control.*, and try minimizing the average size of your definitions (of types and of terms) rather than the number of them
11:23:47 <structuralist> as a proxy for maximizing clarity
11:23:49 <Gurkenglas> "[19:50] <Gurkenglas> But then I'd have to name things :c"
11:23:58 <glguy> Gurkenglas: Naming things is good
11:24:04 <structuralist> I think that would be a good exercise
11:25:40 <Gurkenglas> Hmm. No lens, no Arrow, no StateT. I mean I can desugar all that stuff but it doesnt sound useful.
11:26:06 <glguy> Getting rid of the arrow stuff will be a good start
11:26:36 <Gurkenglas> Oh hey Im not actually using that, damn you dead imports haskell needs an import manager
11:27:14 <Zemyla> Okay, I have a question: How clever should I be when encoding a data structure for something where performance matters?
11:27:15 <lpaste> glguy annotated “Oh hey I wasn't even using any IO in onMouse and hadn't propagated that up to main yet.” with “Give the reader some structure” at http://lpaste.net/172731#a172759
11:27:36 <monochrom> -ddump-minimal-imports exists
11:27:40 <sleblanc> Gurkenglas: :set -fwarn-unused-imports in ~/.ghci
11:28:01 <glguy> Gurkenglas: How about this for a small example. A few newlines and a bit of alignment and its much easier to show what you're doing
11:28:58 <monochrom> Generally I encourage you to read the GHC user's guide thoroughly.
11:29:12 <glguy> zipWith Color (red : blue : repeat white)
11:29:16 <glguy> or even something like that
11:29:43 <sleblanc> Gurkenglas: (assuming you use GHCi)
11:30:40 <structuralist> Zemyla: that's really vague
11:31:12 <structuralist> any specifics?
11:31:22 <Zemyla> I'm trying to make a rope of characters, which will be a fingertree of either 1-, 2-, or 4-byte character arrays, or groups of loose characters.
11:31:57 <shapr> Zemyla: sounds interesting already
11:33:47 <shapr> Zemyla: in my experience, don't even try to optimize until you've written something that works and is too slow. At that point, use a profiler to discover what's actually slow, then tune that part.
11:35:09 <shapr> Zemyla: also, typeclasses can allow you to completely change your data structures with no impact to the rest of the code.
11:35:30 <Zemyla> I think I can have a chunk be Chunk = Chunk { length :: Word64, offset :: Word64, arr :: ByteArray }, and I've figured out how to use the length and offset fields to store 5 21-bit characters in a field with no associated array, or whether it holds 8-, 16-, or 32-bit arrays.
11:36:16 <Zemyla> shapr: I can also use PatternSynonyms, I think.
11:38:47 <Zemyla> Yeah, I can use PatternSynonyms too.
11:42:13 <Taneb> https://arin.ga/k6T3bu I think this type error shouldn't be happening
11:42:24 <Taneb> Not sure how to get around it or really explain it
11:46:55 <glguy> Taneb: Float isn't going to match the pattern (i,g)
11:47:03 <glguy> err, sorry, I missed the i
11:48:38 <glguy> taneb: the problem is the GHCi has NoMonomorphismRestriction
11:48:42 <glguy> and let bindings generalize
11:50:44 <lyxia> that's one annoying error
11:51:10 <glguy> with the irrefutable pattern match you basically have i = fst (random (mkStdGen 10)); g = snd (random (mkStdGen 10))
11:51:38 <Taneb> glguy, thanks
11:51:42 <Taneb> I guess that makes sense
11:51:59 <glguy> case random (mkStdGen 10) of (i,g) -> i :: Float   works
12:05:42 <Gurkenglas> Dangit I was almost done and now I cant handle the readFile exception without Control.*
12:06:18 <Gurkenglas> Dangit I was almost done and now I cant handle the readFile exception without Control.*
12:06:26 <Gurkenglas> Soz wrong window to Up-Enter
12:27:58 * hackagebot sequor 0.7.5 - A sequence labeler based on Collins's sequence perceptron.  https://hackage.haskell.org/package/sequor-0.7.5 (GrzegorzChrupala)
12:45:13 <Zemyla> Actually, it occurs to me that I may not need to mess with arrays for a first start at a fingertree-based string.
12:45:46 <Zemyla> The basic unit of the fingertree is the node, which holds either 2 or 3 values.
12:46:20 <Zemyla> A Word64 can hold 3 21-bit characters, plus a bit for whether it's actually holding 2 or 3.
12:47:59 * hackagebot dlist 0.8.0.1 - Difference lists  https://hackage.haskell.org/package/dlist-0.8.0.1 (SeanLeather)
12:48:22 <monochrom> nice
12:49:18 <EvanR> monochrom what is the delta < delta thing doing hanging out on the right side of this notation https://ibin.co/2pgooZgVzAxz.png
12:50:08 <Cale> It should probably not hang out on the right like that
12:50:11 <monochrom> I think it means an extra condition you have to check, before using this rule.
12:50:17 <Cale> It should be part of the top line
12:50:34 <EvanR> hrm so you think its stylistic
12:50:53 <Cale> and yeah, given the name of the rule, I would assume that it means something like that Delta is a subsequence of Delta'
12:51:48 <EvanR> also what is |-
12:52:30 <Cale> A |- B means that from (the statement or sequence of statements) A it is possible to conclude B
12:52:31 <monochrom> it separates environment (on the left) and sentence (on the right)
12:52:59 <EvanR> so |- is inline -------- ?
12:53:07 <Cale> kind of
12:53:34 <Cale> Horizontal lines tend to correspond to the application of a single rule
12:53:52 <Cale> whereas |- is sort of the transitive closure of what you can do by applying rules
12:53:58 <EvanR> i noticed it always shows up with and environment on the left
12:54:17 <Cale> But it sort of depends on how you're thinking about everything
12:57:14 <Cale> So (making some assumptions about context) what this rule is saying is that if, from Delta, you can conclude that ρ T contains t, and Delta is a subsequence of Delta', then from Delta', you can conclude ρ T contains t
12:57:23 <Eduard_Munteanu> They are different kinds of implication. For example, G |- x : A // G' |- y : B   but it is not necessarily true that   G |- y : B
12:57:52 <Cale> It's a little weird to see a weakening rule like this with something so specific on the right side of the |-'s
12:58:15 <Cale> and it's also weird to see the Delta <= Delta' off to the right where typically the name of a rule would go.
12:58:40 <EvanR> ive seen stuff out on the right like the before but didnt get it
12:58:45 <EvanR> like this
12:59:03 <EvanR> yes makes sense now, ill just pretend its on top
13:00:46 <Cale> So if you're writing a typechecker, well, you wouldn't bother with this rule, but just for the sake of thought experiment, you can read this bottom to top
13:02:12 <Cale> as saying that if you have context Delta' and want to see that ρ T contains t, you may delete some things from the context, and proceed to check ρ T contains t with the smaller context (and if you succeed, then all is well)
13:02:30 <Cale> with the smaller context Delta
13:03:14 <Cale> (But this is not syntax directed, and is unlikely to be a very helpful thing to do usually)
13:04:40 <EvanR> heh
13:05:00 <EvanR> right, going backwards through these rules gives an algorithm
13:05:04 <Cale> yeah
13:06:45 <EvanR> are there software systems which let you throw a bunch of these rules in and ask it to prove some conclusion
13:07:41 <Cale> Well, there's the programming language Epigram
13:07:56 <dolio> Sometimes going forward gives you an algorithm, too. :)
13:08:38 <dolio> It depends what rules you have for building a tree out of some starting point.
13:09:22 <dolio> For type checking, you start with the bottom term, and can reconstruct the tree above it from just the term.
13:09:38 <dolio> (Sometimes)
13:11:54 <monochrom> top to bottom gives an algorithm for generating all acceptable terms
13:12:02 <dolio> For type classes, you can put your constraint context on the left, and some dictionary passing syntax on the right. And from a top context, the rules for type classes tell you what new contexts to derive on the left, and corresponding internal syntax manipulations on the right.
13:12:20 <dolio> Then going top to bottom tells you how to construct your dictionary passing terms.
13:12:42 <monochrom> armed with that, you can check a term by trying to find your term in the generated list of acceptable terms
13:14:05 <EvanR> for the list to get through everything i guess it needs to be careful about what to do next
13:14:17 <EvanR> or itll go off in some direction never to try anything else
13:15:11 <monochrom> Yes, breadth-first
13:15:14 <EvanR> dolio: left and right of what?
13:15:21 <dolio> |-
13:15:24 <EvanR> oh
13:16:13 <monochrom> breathe-first search: breathe deeply before you dive. dive-first search: dive deeply first before you breathe
13:16:38 <dolio> Eq a, Ord a |- max : a -> a -> a
13:17:00 <dolio> Ord a |- max[eqDict := super ordDict] : a -> a -> a
13:28:00 * hackagebot split-record 0.1.1.2 - Split a big audio file into pieces at positions of silence  https://hackage.haskell.org/package/split-record-0.1.1.2 (HenningThielemann)
13:38:01 * hackagebot youtube 0.2.1 - Upload video to YouTube via YouTube API  https://hackage.haskell.org/package/youtube-0.2.1 (HenningThielemann)
13:42:54 <f-a> say I have an expression like `ma = filter odd [1..10]`, I would really love a way to debug expressions like this
13:43:35 <f-a> if I use :break and then :print in ghci I only obtain stuff like _t7 = (_t8::[Integer])
13:44:16 <monochrom> that seems to mean the thing is unevaluated yet
13:44:49 <glguy> f-a: The point of the :print command is that it doesn't do any extra evaluation, were you hoping to evaluate ma instead?
13:45:42 <f-a> glguy: today I wrote a simple function because I messed up pattern matching end everything was matched in the first pattern
13:46:11 <f-a> I went through it 'mentally' and since it was an extremely simple function I spotted the error, but I wondered about bigger functions
13:46:20 <f-a> usually I use the 'trace' trick
13:46:28 <f-a> but I wondered if ghci could help too
13:47:36 <monochrom> it could, and less damaging than trace.
13:47:56 <f-a> I am all ears monochrom 
13:48:03 <monochrom> THE END.
13:48:26 <sm> maybe monochrom means the ghci debugger ? 
13:48:50 <monochrom> the ghci debugger is less damaging than Debug.Trace
13:48:59 <f-a> hello sm
13:49:12 <sm> it comes with fairly high cognitive overhead, but if you master it then perhaps better than a quick trace
13:49:14 <sm> hello f-a
13:50:47 <koz_> Suppose I have a list that looks like [a_1, a_1, a_1, ... , a_2, a_2, ... , a_n, ... a_n]. How would I find the size of the longest homogenous tail of it?
13:50:47 <sm> but if your code is complex, or you want oversight of multiple runs through it, tracing is pretty effective
13:51:23 <mniip> koz_, last . group ?
13:52:26 <Striking> Does anybody know a way to encode true unboxed union types in Haskell + extensions ala how it's done in Scala here https://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/?
13:53:01 * hackagebot transient-universe 0.3.2 - Remote execution and map-reduce: distributed computing for Transient  https://hackage.haskell.org/package/transient-universe-0.3.2 (AlbertoCorona)
13:53:36 <koz_> mniip: That'd work, thanks!
13:58:34 <nak> hello peoples
13:58:44 <nak> i'm just learning about state monad
13:58:52 <nak> it reminds me a lot of a fold
13:59:15 <nak> there is some stuff that confuses me about it tho
13:59:21 <nak> like evalState vs execState
13:59:49 <nak> what do the two values inside state represent ?
14:00:14 <nak> the first one is like the state value, but what is the second one then ?
14:00:49 <tolt> nak: Looking at State s a, s is the internal state and a is a way of embedding values in the computations
14:00:50 <pavonia> The result of the computation
14:01:23 <lyxia> State s a is a stateful computation, with state type s and result type a.
14:01:32 <maerwald> yeah, another case of poor documentation, file a bug
14:02:18 <nak> can anyone demonstrate *short* examples where execState is useful ?
14:02:20 <maerwald> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#t:StateT -- s and m are documented, but a not
14:03:52 <monochrom> file a bug too for the doc of "[a]" not explaining that "a"
14:04:08 <monochrom> and of "(a,b)" not explaining that "a" and that "b"
14:04:13 <maerwald> wat?
14:04:27 <monochrom> how is that unclear?
14:04:43 <tolt> nak: I don't want to write it out but the difference between execState and evalState is what you're focused on. If you want to use some state and compute something after modifying it that isn't directly the state you've been working on you want to use evalState. ExecState is useful if you want to work on some state, modify it, etc. and then find out what happens after all of that
14:04:46 <nak> i am so not comfortable filing a bug for something i know next to nothing about
14:05:00 <EvanR> whats the meaning of ""[a]""
14:05:23 <nak> tolt ok that kind makes sense
14:05:29 <maerwald> nak: the last paremeter being a "return" thing is sort of a convention, that's why most people don't care I guess. It's still better to document it
14:12:15 <nak> maerwald /me nods
14:14:55 <nak> sort of vague question: when you're using something like State monad or State Transformer, do you usually understand it to the degree where you could implement it yourself with trivial effort? Do you even bother thinking about the implementations? Or do you just say "it's magic" and trust that it works the way it does. i'm just trying to get a sense of my own skill level, i guess.
14:15:34 <nak> i often feel confused, and when i think about things, i have no idea how i would implement them myself. StateT is that for me and it makes me feel pretty stupid
14:15:36 <Rembane> nak: I go the magic route until I get frustrated by State and then I just keep the state as a parameter to all my functions.
14:15:48 <maerwald> haha, exactly
14:16:01 <geekosaur> State monad is just a wrapper for functions s -> (a, s)
14:16:08 <nak> well State is just an example in this case
14:16:11 <Rembane> nak: The interesting part with State is that it's super simple when you know how it works. :D
14:16:14 <geekosaur> not a whole lot there *to* understand "_
14:16:15 <geekosaur> :)
14:16:22 <maerwald> if you are mean about it, State is just silly obfuscation wrapped into the monad API. There's not much going on actually
14:16:30 <Rembane> nak: For what are you using State?
14:16:51 <nak> i'm trying to focus less on State itself, and more just the cycle of not understanding things and feeling stupid
14:17:05 <Rembane> nak: Oh, so State is an example in this case?
14:17:09 <nak> yeah
14:17:26 <Rembane> I go the magic route.
14:17:28 <Rembane> All the time.
14:17:34 <Rembane> Saves me initial time.
14:17:44 <nak> i mean i've been reading about it last night and this afternoon, and i have a *general* understanding of it. i read the implementation and i think "f***, i don't think i ever could've come up with something like this"
14:17:48 <Rembane> And when I get really stuck I have something to show here.
14:18:13 <nak> Rembane but how do you just start using it and trust in the "magic" without understanding it ??
14:18:15 <hpc> eventually you get comfortable enough with it that you can approach it like any other bit of programming
14:18:19 <Cale> nak: I understand it well enough to implement it myself without difficulty, but I've been programming in Haskell for a long time.
14:18:22 <Rembane> nak: It's easy to come up with complex, and nasty things, it's hard to come up with simple and elegant things.
14:18:27 <hpc> learn the API, understand it well enough to not care what happens below it
14:18:37 <Cale> You can get by using State or StateT without knowing how to implement them
14:18:39 <maerwald> or just dump transformers and use something else
14:18:49 <Cale> But also, you can usually get by without needing State or StateT at all
14:18:58 <hpc> until then, the implementation can help with getting to the point of understanding, and especially useful for when you plan on writing your own
14:19:01 <Rembane> nak: I throw it into ghci and see what happens when I prod it in some different ways.
14:19:12 <nak> i see
14:19:13 <hpc> and yeah, in the specific case of State it's not hard to get by without it
14:19:26 <hpc> before you learn State it's more comfortable often to do it explicitly
14:19:28 <Rembane> it's just more boilerplate
14:19:39 <hpc> which helps keep it uncomfortable to do huge chains of stateful computation
14:20:08 <hpc> and eventually you bump up against its limitations and find MVar or IORef more suitable to your problem
14:20:22 <Cale> In fact, I would stay away from monad transformers altogether if possible -- they can be a handy way to implement certain libraries, but you should get really good at structuring things in a parameter-passing fashion before developing a sense for when it would be good to abstract over that.
14:20:26 <hpc> (most of the time, anyway)
14:20:28 <nak> ok well one thing i was trying to do was an asynchronous task queue, where some tasks could could add other tasks to the queue. when i thought about how i'd use State to manage the queue... my brain just melted :(
14:20:46 <maerwald> Cale: also, silly lifting, so annoying
14:21:11 <Cale> Yeah, especially over something like IO, StateT is usually kind of unhelpful
14:21:22 <hpc> nak: if your code is already pretty deep with IO, you should look at something like Chan
14:21:28 <hpc> which is a threadsafe queue
14:21:49 <nak> hpc it was more an exercise for myself to see if i could implement it
14:21:55 <hpc> ah, gotcha
14:21:56 <maerwald> Cale: which is really sad. I tried to do that with freer, it doesn't have the same problem, but a different one, that's even more annoying.
14:24:38 <Cale> maerwald: Well, from my perspective it's not so much sad as totally expected. IO already has lots of facilities for stateful computation, of course adding another layer on top is not going to buy you a whole lot.
14:26:11 <Cale> I would tend to prefer to move in a different direction -- make some IORefs (or other sorts of mutable things), and instead of passing those around directly, pass around IO actions (or functions producing IO actions) which manipulate them.
14:27:39 <Rembane> Cale: Is it like building an EDSL which does what you want?
14:28:03 * hackagebot compound-types 0.1.3 - Sum and Product types and such  https://hackage.haskell.org/package/compound-types-0.1.3 (NikitaVolkov)
14:28:13 <Cale> In the past, I've had it very often turn out to be useful to have done this bit of abstraction over how mutable state gets manipulated. You can easily add logging or various sorts of consistency checks after the fact.
14:28:39 <Cale> Rembane: It's a simple first step in that direction, similar to how StateT is a first step in that direction.
14:28:55 <Cale> But I think it tends to be a better first step to take than immediately applying StateT.
14:29:27 <maerwald> Cale: mh, I usually pass them around as part of a bigger data structure, sth that represents e.g. the whole program configuration (both "pure" and "impure" parts)
14:29:31 <Rembane> Cale: that's cool.
14:29:44 <maerwald> within that I may have Bools and IORefs
14:29:57 <Cale> You can factor out various aspects of what you're doing and collect them out into a record of operations, and if you go far enough in that direction, you end up with basically a free monad
14:30:28 <Cale> (once you've finished abstracting over all the things you ever do)
14:31:10 <Cale> Another thing which is worth noting that it's possible to do is abstracting over the choice of monad in that record's type:
14:31:42 <Striking> Any people around who are really good at messing with types to help me figure out how to implement union types?
14:31:42 <Cale> data Ops m = Ops { getFoo :: Bar -> m Foo, ... }
14:31:53 <Cale> Even if you know that m is really going to be IO
14:32:04 <Rembane> Neat!
14:32:14 <Cale> This lets you write things which are not allowed to do arbitrary IO, but may only use the operations you give them
14:32:28 <Cale> (Monad m) => Ops m -> ... -> m Result
14:33:19 <Cale> Similarly to how e.g. you might write polymorphic code that is constrained by MonadState MyState m
14:33:27 <Striking> that seems like a nice pattern Cale. 
14:34:02 <Zearen> Hey, is there a way to get the type of an expression without ghci ?
14:34:21 <maerwald> restricted IO is more elegant in freer, but it has weird limitations there if you want _multiple_ restricted IO effects
14:34:55 <EvanR> Zearen: yes
14:35:02 <Striking> Zearen: some editors allow you to do it, with some tooling
14:35:16 <Zearen> Can you be more specific ?
14:35:18 <senoj> Zearen: you can try setting up something like hdevtools in your editor
14:35:43 <Zearen> Er... that's going to be tough.
14:35:50 <senoj> Zearen: lookup hdevtools and vim-hdevtools
14:36:09 <Zearen> I'm using a build system other than cabal...
14:36:12 <Striking> depends on what editor you're using to if they have things available
14:36:15 <Striking> Zearen: stack?
14:36:21 <Zearen> I'm using vim.
14:36:24 <Striking> if so it should work fine
14:36:26 <Zearen> No, Bazel.
14:36:34 <Striking> hm, dunno
14:36:34 * sm steps back
14:36:40 <senoj> Bazel?
14:36:54 <Zearen> http://www.bazel.io/
14:37:25 <maerwald> yet another build system?
14:37:29 <Zearen> It's a generic build system used by my company...
14:37:32 <Zearen> Yeah ^^;
14:37:37 <maerwald> like we don't have enough already
14:38:02 <senoj> is it using cabal/cabal-install under the hood?
14:38:03 <sm> Zearen: still don't you use cabal files to describe your code ? or is it just plain ghc ?
14:38:14 <Zearen> It's better suited for cross language stuff and scaling, though...
14:38:15 <shachaf> Please take the build system flame wars elsewhere.
14:38:40 <Striking> I don't think hdevtools needs cabal
14:38:48 <Striking> should be fine with just ghc
14:38:50 <Zearen> sm: Nope, BUILD files as per bazel...
14:39:06 <sm> bazel calls ghc --make or something ?
14:39:25 <Zearen> *shrug* Iunno.
14:39:38 <Zearen> I can go find the output, probably
14:39:42 <ezyang> bazel's philosophy is that it will reimplement as much of the language's build system as necessary to get the scaling to work 
14:39:54 <ezyang> Understandably, this approach has pros and cons 
14:40:04 <maerwald> I'm not sure we should recommend it here
14:40:18 <sm> we're just talking, people
14:40:23 <sm> it's interesting
14:41:38 <Zearen> If I can go get the build artifact, is there a way to load that into ghci directly ?
14:42:18 <ezyang> Zearen: Assuming you can register it to a package database 
14:42:21 <structuralist> Are free theorems are the same as extranaturality (in the sense of https://ncatlab.org/nlab/show/extranatural+transformation)?
14:44:22 <senoj> Zearen: you might be better off doing something like factor the expression whose type you want to see out and try giving it a type annotation
14:44:32 <Zearen> Hmm, there was a tool that did this that someone else wrote, but it broke.  I guess at this point I might as well go fix it...
14:44:37 <senoj> senoj: if you get it wrong, the error msg might tell you useful info
14:44:49 <senoj> you can try using type holes as well
14:45:37 <Zearen> I tried type holes, but the type was too ambiguous for the compiler to come up with anything meaningful...
14:46:14 <sm> yes, add more type annotations perhaps
14:46:19 <Profpatsch> I use nix! (let the build system flamewars start)
14:46:29 <maerwald> it's not a build system
14:46:45 <Striking> nix is more of a package manager
14:47:01 <Profpatsch> hell yeah, here it comes!
14:47:03 <Profpatsch> :D
14:47:10 <monochrom> in fact, let the classification war start.
14:47:20 <Zearen> I'm out.  *Flees*
14:47:35 <Striking> In less inflammatory news, does no one know how I could implement unions?
14:47:44 <glguy> Oh, intentionally starting flame wars sounds bad, I guess I should start some banning
14:47:45 <monochrom> "is nix a builder? is stack a package manager? is ant a configurator?"
14:48:04 <Profpatsch> glguy: Wha- somebody help me!
14:48:11 <maerwald> monochrom: those questions can be answered
14:48:24 * Profpatsch slides back into the shadows
14:50:07 <mniip> are monads burritos
14:50:14 <mniip> are functors conainers
14:50:21 <structuralist> burritos are monads
14:50:24 <Zearen> ^
14:50:26 <Striking> the real questions
14:50:29 <EvanR> containers are burritos
14:50:38 <structuralist> https://www.cs.cmu.edu/~edmo/silliness/burrito_monads.pdf
14:50:39 <EvanR> ntainers are coburritos
14:50:42 <maerwald> mniip: no and no, that was easy
14:50:45 <sm> bah.. newcomer shows up with an unusual build system, #haskell responds with trolling and meta-noise
14:50:50 <Profpatsch> maerwald: What would you say if I told you that I use nix to build nix files from cabal with bash from a Haskell script?
14:51:00 <sm> I want to see a bazel haskell project
14:51:02 <maerwald> Profpatsch: I know about that
14:51:06 <monochrom> ghci is pretty much the only thing that tells you types. the alternative is the ghc api, but note that ghci is a UI over ghc api, they are not different enough for most purposes.
14:51:08 <Zearen> sm: I'm not a newcomer ;)
14:51:17 <shachaf> So do I! I like bazel.
14:51:19 <EvanR> structuralist: hhahahhaa
14:51:24 <shachaf> I propose a bot that bans anyone who says the word "burrito".
14:51:26 <Profpatsch> And then I use those nix files to build my project with nix-shell and cabal. :P
14:51:33 <Profpatsch> maerwald: Are you a wizard?
14:51:42 <EvanR> starting with shachaf 
14:51:42 <monochrom> time to say: what have I done?!
14:51:42 <maerwald> Profpatsch: what do you mean?
14:51:50 <shachaf> I think the whole concept of "a language's build system" is kind of broken. But that's going too far for this channel.
14:52:09 <Striking> don't want to ignite the flames
14:52:23 <Profpatsch> maerwald: You said that you know about that. That leaves me with an obvious question. ;)
14:52:33 <erisco> flames are a consequence of ignition, they are not themselves ignitable
14:52:48 <Striking> erisco: pedant, but what do I expect here
14:52:53 <Striking> s/ignite/stoke
14:52:54 <zlens> is there a nice way to do test-driven-development in ahskell?
14:53:00 <maerwald> shachaf: it's the reason haskell works reasonably well and that half of the distros (including nix) have automated tools to convert cabal definitions into package definitions. That doesn't work for pretty much any other language (like python), because the complexity and diversity of available build systems is just too much.
14:53:03 <Striking> zlens: QuickCheck
14:53:04 * Zearen strongly prefers against flamewars.  Bazel has pros and cons, but regardless of its merits, it's the system she's stuck with.
14:53:09 <Profpatsch> maerwald: I mean it’s on a public github repo, but I didn’t think more than one or two people knew about that stuff.
14:53:19 <zlens> Striking: I'd actually prefer to write hte tests manually
14:53:24 <Zearen> HUnit
14:53:32 <zlens> Zearen: thanks
14:53:37 <maerwald> shachaf: and is wasting thousands of hours of package maintainers every year
14:53:39 <Striking> Yep HUnit works
14:53:51 <Zearen> Also test-framework if you want to use multiple different systems together.
14:53:51 <Striking> though I like QuickCheck because of random testing *shrug*
14:54:02 <sm> there are half a dozen ways to write tests for haskell code, each with their own tradeoffs and tooling
14:54:11 <Striking> Now to lament the lack of responses to my question on union types
14:54:19 <sm> but the "test first" part is up to you
14:54:19 <Profpatsch> maerwald: Ah, you probably mean cabal2nix. I have something way more sinister right here ;) https://github.com/Profpatsch/dohaskell/blob/master/dohaskell.hs#L65
14:54:32 <ezyang> Striking: What kind of unions do you want 
14:54:35 <monochrom> what is union type?
14:54:45 <Zearen> :+:, clearly :p
14:54:46 <Striking> ezyang: Actual unboxed unions
14:55:01 <Striking> I suspect it's possible
14:55:02 <Gurkenglas> set-theoretic unions as opposed to disjoint unions, yes?
14:55:20 <Striking> as long as I can get not + and implemented in the type system
14:55:25 <monochrom> what is unboxed union type? I don't want to learn Scala.
14:55:26 <ezyang> STriking: Like, https://phabricator.haskell.org/D2259 ? 
14:55:28 <Striking> then or n types
14:55:34 <erisco> Striking, what does unboxed have to do with it?
14:55:49 <Gurkenglas> First you'd  have to have a union of types at all.
14:55:57 <monochrom> I don't think Haskell will give you the "not" part.
14:56:08 <Striking> No ezyang because that requires special syntax (|something) instead of just (something)
14:56:15 <Striking> you can't directly assing
14:56:24 <Striking> (it's basically sugar on top of Either and sum types)
14:56:27 <shachaf> ezyang: GHC has unboxed sums now?
14:56:34 <shachaf> ezyang: I've wanted that for years.
14:56:37 <Striking> shachaf: yep, but still not the same as unions
14:56:44 <shachaf> Striking: Yes, but I don't care about those.
14:56:48 <ezyang> shachaf: Yes. 
14:56:51 <shachaf> ezyang: Does it do an equivalent of CPR for sums?
14:56:55 <shachaf> CSPR?
14:56:58 <Zearen> I mean, arguably classes represent disjunction, and (~) is conjunction.  I'm not sure ¬ is possible...
14:57:02 <ezyang> shachaf: You will have to ask osa1 about it ;) 
14:57:33 <Gurkenglas> Wait I think someone hacked together a ¬ on constraints
14:57:33 <Striking> Zearen: I'm almost certain you can construct not, maybe (a -> Void)?
14:57:51 <Gurkenglas> mniip did you do it? Sounds like your kind of think
14:57:53 <Zearen> Ooooh, yeah.
14:57:59 <ezyang> Striking: I think it is unlikely you will be able to get union types (in the sense of union/intersection types) in Haskell 
14:58:17 <Zearen> Well, `id`.
14:58:23 <Striking> ezyang: the type system is fairly extensible, plus Turing Complete
14:58:35 <erisco> but it can't send email
14:58:55 <Gurkenglas> Time for type-level IO?
14:58:58 <monochrom> yeah, how to do IO at the type level?
14:58:58 <Striking> Zearen: id isn't from type a -> Void unless it's Void -> Void, in which case you have a true value, Void is also false
14:59:14 <Striking> monochrom and Gurkenglas: dark magic :P
14:59:21 <maerwald> dependent types?
14:59:25 <Zearen> Well, if you define Void as false, then yes.
14:59:32 <mniip> "The T-image of the morphism 𝑓 performs 𝑓 while wrapped in a tortilla. Depending on the nature of the morphism, this may raise size issues. In the preceding discussion, we have assumed all burritos to be at least locally small."
14:59:34 <mniip> haha
14:59:37 <Striking> Void makes sense as a false,  due to nothing being part of it
14:59:43 <Striking> mniip: genius
14:59:56 <EvanR> monochrom: type providers
15:00:09 <mniip> Gurkenglas, perhaps the ifcxt?
15:00:13 <Zearen> I agree, it just didn't occur to me.
15:00:50 <mniip> 1469829513 [00:58:33] <Gurkenglas> Time for type-level IO?
15:00:58 <mniip> just lift all of GHC.Prim into datakinds
15:01:06 <mniip> an ekmett package will emerge automatically
15:01:07 <Striking> here was my naive try at Not http://paste.ee/p/6xseu
15:01:15 <Striking> but from there I couldn't build or because I can't get and
15:01:16 <maerwald> mniip: or an Oleg paper xD
15:01:20 <Striking> unless I'm missing something
15:01:51 <maerwald> find something obscure -> Oleg has written a paper; find something impossible -> ekmett has written a package
15:02:40 <Zearen> Hours t 21 => If (Time :=: t) (Bool) (Maybe Int)
15:02:42 <Striking> I need to do more Haskell stuff honestly, get good enough at it to publish some interesting packages
15:03:15 <Zearen> "Why is does this code always fail to compile at 9:00 ?"
15:03:25 <monochrom> hehe
15:03:39 <Striking> Zearen: true evil
15:03:44 <senoj> Zearen: b/c the cron job to build it runs at 9:00?
15:03:54 <maerwald> would be funnier if the garbage collector refuses to collect after 9:00 xD
15:04:05 <maerwald> "time to go to bed"
15:04:24 <Striking> also is there a way to check if a value is of a certain type in Haskell? Otherwise Unions are useless
15:04:31 <Zearen> senoj: I'm making fun of the idea of IO at the type level.
15:04:53 <EvanR> Striking: now youre not making sense anymore
15:04:54 <Zearen> Striking: (~) ?
15:05:09 <Zemyla> So what happens if the Haskell garbage collector goes on strike?
15:05:11 <mniip> accursedUnutterableUnsafeInlinePerformIO :: ReadCharOffAddr# NullAddr# 0 RealWorld
15:05:11 <monochrom> senoj: Zearen is referring to his joke code in which it asks about the current time at the type level, so the type is correct or incorrect depending on the clock
15:05:17 <senoj> Zearen: >.<
15:05:20 <EvanR> Striking: any value of a "union type" is that type, so you already know
15:05:21 <maerwald> Zemyla: facebook will definitely file a bug, lol
15:05:41 <shachaf> monochrom: she hth
15:05:41 <monochrom> if GC goes on strike, we simply buy more RAM chips
15:05:49 <Zearen> (monochrom: I'm a woman, FYI ^^;)
15:05:49 <shachaf> er, her
15:05:49 <monochrom> oh!
15:05:50 <Striking> EvanR: unless you want to do operations on certain things differently
15:05:53 <Striking> you could use sum types
15:06:00 <Striking> but that makes passing in a pain with constructors
15:06:21 <Striking> (and if you're refactoring the function to the union, means you have to rewrite all code calling it)
15:06:25 <EvanR> Striking: a C-style union with a tag is basically a sum type
15:06:36 <Striking> yeah I know, I'm talking true type unions
15:06:53 <Striking> a :: Union Int String means a = 1 and a = "Meow" is valid
15:06:59 <mniip> union types as in opposite of intersection types?
15:07:04 <monochrom> I know true type fonts. what is true type union?
15:07:04 <EvanR> since types dont exist at runtime, that sounds pointless
15:07:34 <erisco> EvanR, send the email at compile time, of course, when else?
15:07:55 <mniip> EvanR, point-free
15:07:56 <Striking> EvanR: if I recall correctly, Haskell doesn't have type erasure, if it does then I'd abandon unions all together
15:07:58 <mniip> ftfy
15:08:09 <EvanR> compilers cant escape the "eventually it will be able to send email" anymore than any other program
15:08:12 <Striking> mniip: I will add that to my library of jokes
15:08:23 <EvanR> Striking: it definitely does
15:08:32 <erisco> EvanR, oh sorry I may have been responding to the wrong thing… I added "pointless" to my watch list of terms
15:08:43 <erisco> it seems people don't use this in the sense I was hoping
15:09:09 <monochrom> the Haskell Report probably doesn't require type erasure. but certain GHC does it.
15:09:29 <mniip> you can unerase types to an extent though
15:09:31 <monochrom> as for Hugs I don't know what's the difference between compile-time and run-time
15:09:35 <senoj> Stratege: e.g. newtypes are erased after type checking
15:09:45 <mniip> yeah you can't recover newtypes
15:09:47 <EvanR> type erasure sounds really weird to me, like its a thing you need to intentionally do... 
15:09:47 <Striking> EvanR: hm, sum types are inconvenient though for the reason I described above
15:09:48 <Striking> [17:05] <Striking> (and if you're refactoring the function to the union, means you have to rewrite all code calling it)
15:10:15 <EvanR> Striking: correct, which is a typical source of errors in unchecked code, failing to rewrite parts that are now wrong
15:10:19 <mniip> EvanR, it's a mathematical term
15:10:35 <EvanR> mniip: how would a compiler fail to erase types?
15:10:44 <erisco> Nemerle can send email at compile time, iirc
15:10:52 <mniip> it comes for non-compiler speak
15:11:14 <EvanR> really? java seems to think its a programming language implementation feature
15:11:33 <Striking> EvanR: Though I could see it being used in an API or somesuch
15:11:39 <EvanR> eh?
15:11:47 <monochrom> type erasure existed long before java
15:11:50 <mniip> suppose you have untyped LC reduction rules, and typed LC reduction rules. You can then speak about the process of type erasure and prove the correspondence of typed code to untyped code
15:12:09 <EvanR> oh neat
15:12:31 <Striking> if you have some function a -> b but discover it can also work if you pass in c, you could create a type class for that. Or you could use a union type a | c -> b essentially
15:12:55 <mniip> Striking, typechecking union/intersection types
15:13:07 <mniip> is it at all decidable
15:13:15 <Striking> type classes are a kind of disjunction in effect
15:13:20 <Gurkenglas> Of course the alternative is adding a function c -> b
15:13:25 <Striking> mniip: yep, Scala manages to do it with Hindley-Mindler
15:13:30 <EvanR> if all the things in your union were of the same representation i can see that working out
15:13:36 <Striking> Gurkenglas: different naming though
15:13:49 <Striking> EvanR: without type erasure you could delegate even then
15:14:04 <EvanR> no, its not making sense anymore
15:14:04 <mniip> Striking, by manages you mean the same as GHC managing to do rank 2 typechecking?
15:14:11 <mniip> (i.e it doesn't formally)
15:14:15 <Striking> https://milessabin.com/blog/2011/06/09/scala-union-types-curry-howard/
15:14:36 <Striking> I'm not sure if it's formally, looks so to me, but I'm not that proficient at type system hackery
15:14:57 <EvanR> what is a use case for union types
15:15:28 <Striking> EvanR: Like I said, APIs where you don't want to write a new function for fear of naming creep, nor create a type class
15:16:31 <EvanR> that doesnt sound very safe
15:16:32 <mniip> more ekmett packages
15:16:32 <Striking> On the other hand the idea that you could implement it in Haskell is just interesting, but that's my personal mathematician do it because I can coming out
15:17:11 <EvanR> whats an example function that would work on a union type
15:17:21 <EvanR> without doing a tag check
15:17:40 <monochrom> const
15:17:49 <Striking> monochrom: cheeky, I would've said id
15:17:55 <Striking> anyway, more seriously
15:18:39 <mniip> structuralist, I'm borrowing that
15:18:53 <Striking> getFirst :: Vector a | [a] -> a
15:19:02 <Striking> That seems implementable without a tag check
15:19:07 <mniip> how
15:19:16 <Striking> due to vectors and lists having a similar representation
15:19:25 <EvanR> but they dont
15:19:37 <glguy> But what if they did?
15:19:45 <monochrom> the two "getFirst"s need distinct implementations.
15:20:31 <EvanR> including source code
15:20:35 <Striking> mhm...without type erasure it'd be possible
15:20:35 <monochrom> it is why I suggested const. the only example I could defend.
15:20:36 <Striking> otherwise not
15:20:53 <EvanR> and it would end up being like type directed name disambiguation
15:20:54 <Striking> (you'd have to do a runtime type check, checkable by compile though)
15:21:36 <monochrom> In addition, I do not consider "there is no tag, it is also unboxed, but it carries runtime type information" to be self-consistent.
15:21:37 <Striking> There's also that you could potentially create a library factoring all that out safely to
15:22:29 <Striking> monochrom: depends on what you mean by tag and unboxed. I'm saying that as in when you have to pass the value you don't need a special constructor
15:22:39 <Striking> and no pattern matching for Left or Right (or equivalent of course)
15:23:19 <EvanR> you could make the types check, but i was asking how youd write a function to do anything, and then later perhaps figure out how the heck it would work at runtime
15:23:50 <monochrom> I would stick with type classes for that. plus it's also an open world.
15:24:31 <Striking> sometimes you don't want it open though, in which case you could make PrivClass a superclass of PubClass, but that just seems hackier than union types
15:24:52 <Zearen> Hahahaha, I got indexed-extras to install.  Take that cabal !
15:25:11 <Striking> you could do it with TemplateHaskell and some madness, but the error messages would be abysmal
15:31:28 <Zearen> :: (InOut io () hsOut1 a1, InOut io () hsOut a, Functor io) => IxContT io ((a2 -> b1 -> c) -> r) ((hsOut -> hsOut1 -> f) -> r) (a -> a1 -> b) -> IxContT io (((a2, b1) -> c) -> r) (f -> r) b
15:31:38 <Zearen> Yup, now that thar is type !
15:31:50 <Zearen> (Thanks for the advice, all)
15:32:06 <buglebudabey> whats the lambdabot command for kind
15:32:21 <buglebudabey> :k Functor
15:32:22 <lambdabot> (* -> *) -> Constraint
15:32:27 <buglebudabey> thanks buglebudabey
15:33:04 <hexagoxel> yw
15:33:38 <buglebudabey> :k Functor Maybe
15:33:39 <lambdabot> Constraint
15:34:55 <shachaf> That constraint is perfunctory.
15:34:58 * monochrom fears IxContT
15:35:46 <buglebudabey> perfunctory?
15:35:48 <buglebudabey> does not compute
15:36:05 <monochrom> haha shachaf
15:36:15 <buglebudabey> also, the composition of two functors is still a functor isn't it?
15:36:54 <buglebudabey> shachaf pun processed too late
15:37:13 <c_wraith> quick, someone check Data.Functor.Compose! 
15:38:05 * hackagebot linode-v4 0.1.0.0 - Haskell wrapper for the Linode v4 API  https://hackage.haskell.org/package/linode-v4-0.1.0.0 (eatonphil)
15:38:39 <monochrom> the answer is yes
15:38:39 <buglebudabey> thanks c_wraith 
15:39:02 <buglebudabey> can they be composed without Data.Functor.Compose?
15:39:10 <buglebudabey> or is that a silly question
15:39:19 <c_wraith> sure, but you'd have to do the same thing yourself. 
15:39:33 <c_wraith> and since it's in base, might as well use it. 
15:39:42 <shachaf> What if I want to compose two contravariant functors?
15:40:06 <c_wraith> then you should sit in the corner and think about what you've done. 
15:41:34 <c_wraith> that seems like the same data type should work fine for that, actually. the problem would be communicating the two different ordering of one of each. 
15:41:52 <c_wraith> .. if those even compose. I'm going to bet they don't. 
15:42:34 <c_wraith> hmm. nevermind. those do, but two contra- don't. I'm always so bad with minus signs. 
15:42:51 <fishythefish> https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant-Compose.html
15:43:05 * hackagebot linode-v4 0.1.0.1 - Haskell wrapper for the Linode v4 API  https://hackage.haskell.org/package/linode-v4-0.1.0.1 (eatonphil)
15:43:09 <fishythefish> They'll compose to give you a Functor, yeah?
15:44:03 <monochrom> I'm going to greatly misread two recent lines and compose contravariant with linode
15:44:33 <fishythefish> Yeah, I'm always a bit confused when I paste a hackage link and hackagebot responds
15:46:10 <monochrom> hmm, two wrongs make a right, you probably do get a covariant functor
15:46:18 <shachaf> You do.
15:46:29 <shachaf> But there's nothing wrong about contravariance.
15:46:48 <fishythefish> Covariant is positive, contravariant is negative, composition is multiplication :P
15:46:58 <buglebudabey> is there an example of Functor.Compose being used?
15:48:32 <fishythefish> buglebudabey: anywhere you'd have nested functors and you're tired of fmap'ing your fmaps
15:49:32 <Squarism> if you want to either modify something in a list that match a criteria or if no match ; add to the list - what, probebly, easy approach you take?
15:49:43 <Squarism> should
15:49:51 <buglebudabey> > fmap (fmap (+1) (Just Just 1))
15:49:53 <lambdabot>      Couldn't match expected type ‘Integer -> a -> b’
15:49:53 <lambdabot>                  with actual type ‘Maybe (a0 -> Maybe a0)’
15:49:53 <lambdabot>      The function ‘Just’ is applied to two arguments,
15:50:10 <buglebudabey> > fmap (fmap (+1)) (Just $ Just 1)
15:50:11 <lambdabot>  Just (Just 2)
15:50:42 <buglebudabey> so Compose would be Compose Maybe Maybe Int?
15:51:35 <buglebudabey> > getCompose $ Compose (Just (Just 2))
15:51:36 <lambdabot>  Not in scope: ‘getCompose’    Not in scope: data constructor ‘Compose’
15:51:36 <lambdabot>      Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
15:52:07 <buglebudabey> I don't necessarily see how that's better
15:53:56 <c_wraith> wow, browsing lpaste.net is unusable. 
15:54:57 <c_wraith> buglebudabey, I used Compose in http://lpaste.net/171865
15:55:00 <buglebudabey> Squarism sounds good for a fold or filter
15:56:47 <c_wraith> buglebudabey, that's an example of something that requires composing Functors (well, Applicatives) to work. 
15:57:47 <c_wraith> @let import Data.Functor.Compose 
15:57:49 <lambdabot>  Defined.
15:57:56 <c_wraith> :t getCompose
15:57:57 <lambdabot> Compose f g a -> f (g a)
16:04:46 <Gurkenglas> http://lpaste.net/172778 there we go, refactored into not using any Control.*. Compiler errors were easier to read because no lens, record update syntax is painful and in this version as in the last one I struggled with a bug that made the rectangles just not move
16:05:48 <Squarism> buglebudabey, ok thanks
16:06:12 <buglebudabey> c_wraith i got disconnected after your :t getCompose
16:06:13 <Gurkenglas> *structuralist
16:06:22 <buglebudabey> c_wraith was there anything after?
16:06:50 <c_wraith> buglebudabey, no, I was just checking that I added Data.Functor.Compose to lambdabot properly. 
16:07:09 <buglebudabey> ah, thank you
16:07:32 <structuralist> Gurkenglas: looks a lot better!
16:10:00 <structuralist> you can write colorize as a one-liner with zipWith and repeat
16:10:10 <Gurkenglas> Ooh nice.
16:11:17 <lpaste> Gurkenglas revised “No title”: “colorize oneliner'd” at http://lpaste.net/172778
16:11:48 <buglebudabey> so c_wraith how is Compose useful at all? seems to needlessly wrap a composition in a type constructor and thats about it
16:12:08 <buglebudabey> plus Data.Functor.Compose only comes with one function, can't I just compose them by hand?
16:14:29 <structuralist> Gurkenglas: still not quite sure what this does but I suspect that the function part of your state could be replaced by something as simple as 'Maybe Float'
16:15:37 <structuralist> at a glance the only things that end up there are either 'const id' or a function whose only free parameter is o
16:15:39 <Gurkenglas> structuralist: mouse is only read in line 52, and says what to do with the rectangles when the mouse moves
16:16:06 <structuralist> so could you move the lambda expression there instead?
16:16:22 <Gurkenglas> "move i (\p (p1,p2) -> (p+p1,p+p2)) (\(p,_) -> p + o)" and "move (length rects) (\p (p1,p2) -> (  p1,p+p2)) (\(_,p) -> p)" are pretty different
16:17:31 <Gurkenglas> I would then have to put the Int, (Point -> Rectangle -> Rectangle) and (Rectangle -> Point) parameters of move into S, and Maybe the whole thing because of the const id case
16:18:54 <structuralist> if S only contained Nothing or Just (i, o), could you reconstruct what you need to do on line 52?
16:19:54 <Gurkenglas> Yes, but that would only move the case statement down there, and I'd have to change that again when I want to add another rectangle behavior
16:20:18 <Gurkenglas> While "Point -> Rectangle -> Rectangle" is plenty extensible.
16:21:14 <Gurkenglas> Same goes for downgrading all those Lens stuffs to the types the arguments of move now have, but that was part of the no-Control-challenge ^^
16:25:26 <Gurkenglas> Huh, the lensless version appears to be faster.
16:26:15 <Gurkenglas> How'd that happen? This whole thing doesn't do that much computation anyway, I assumed the hog was gloss
16:26:35 <Gurkenglas> Its like 10 multiplications per pixel the mouse mvoes
16:26:36 <structuralist> putting everything inside IO would also leave more flexibility for later
16:26:50 <structuralist> but that's obviously not great
16:27:42 <Gurkenglas> Putting everything inside Monad m => StateT S m instead of State S leaves flexibility for later, then you can just specialize to IO where you need it
16:35:55 <Gurkenglas> Where does IO get its Alternative instance?
16:37:19 <glguy> Gurkenglas: Hackage -> base -> Control.Applicative -> Alternative -> source link
16:37:21 <Gurkenglas> Oh, Control.Lens, that was a lucky guess. And it appears that just importing it already slows it down, so its probably stack's scripting function's fault. n8
16:38:16 <Gurkenglas> Not in my base version that gloss forces me into :D and now gn8
16:38:27 <maerwald> Gurkenglas: https://github.com/ghc/ghc/blob/master/libraries/base/GHC/Base.hs#L1129 ?
16:39:26 <maerwald> github search is not that bad actually
16:39:29 <maerwald> used to be worse
16:40:30 <x1f577> anyone know of a library to extract text from arbitrary files (for use with search indexes)
16:41:23 <maerwald> "text from arbitrary files" sounds interesting, but I have no idea what it means
16:41:36 <glguy> sounds like the "strings" command or something
16:42:14 <maerwald> like figuring out the "language" or "extension" of a file by fuzzy searches?
16:42:15 <shachaf> Does that extract all the string diagrams?
16:42:34 <glguy> Yeah, that's what it does
16:46:02 <dmwit> shachaf: I have a tool for that which works on 99% of documents. cat >/dev/null
16:46:47 <glguy> Could you send me one of the remaining 1% as an example?
16:47:08 <shachaf> I think you underestimate how many string diagrams there are out there.
16:47:12 <shachaf> They can be very subtle.
16:55:10 <hanDerPeder> is there a good way to get rid of the lambda here? lpaste.net/172819
16:55:39 <hanDerPeder> ** http://lpaste.net/172819
16:56:11 <hanDerPeder> also, would probably be better if i returned the longest element, not it's length
16:56:11 <shachaf> @pl longestElem = foldr (\x y -> max (length x) y) 0
16:56:11 <lambdabot> longestElem = foldr (max . length) 0
16:56:38 <shachaf> You can write that if you want. I don't know that it's clearer.
16:56:58 <shachaf> But getting rid of the y argument would probably be a good start...
16:57:15 <shachaf> Also you should probably use foldl' or something.
16:57:34 <hanDerPeder> right, since it appears on both sides and I don't do anything to it I can just remove it
16:57:39 <shachaf> Also you can write e.g. longestElem = maximum . map length
16:58:34 <shachaf> If you want the item, you can maybe do something like: longestElem = fst . maximumBy (compare `on` snd) . map (\x -> (x,length x))
16:59:04 <glguy> :t length . transpose
16:59:05 <lambdabot> [[a]] -> Int
16:59:44 <shachaf> If you want to be clever about it you can do that.
17:00:44 <hanDerPeder> I haven't grokked Traversable yet :)
17:01:13 <hanDerPeder> shachaf: where's 'on' defined?
17:01:24 <shachaf> @index on
17:01:24 <lambdabot> Data.Function
17:01:29 <shachaf> There.
17:02:07 <hanDerPeder> nice, thanks!
17:02:41 <deank> :t comparing snd
17:02:42 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
17:02:43 <hanDerPeder> the 'pl' funtionality of lambdabot, is that somekind of code simplifier program? does it have a web site?
17:03:17 <glguy> Generally it doesn't simplify code
17:03:28 <shachaf> It has a website: http://hackage.haskell.org/package/pointfree
17:03:40 <shachaf> What it does is remove lambdas. Often it makes code more complicated.
17:03:41 <hanDerPeder> aha, of course
17:07:26 <hanDerPeder> :t map (\x -> (x, length x))
17:07:27 <lambdabot> Foldable t => [t a] -> [(t a, Int)]
17:07:57 <hanDerPeder> how come that works fine in ghci but gives me an ambiguous error when I try to load it from a source file?
17:08:40 <hanDerPeder> without adding a type signature
17:08:42 <shachaf> It would be a syntax error to put that expression in a source file by itself.
17:08:49 <shachaf> So it must not be what you're loading.
17:09:00 <glguy> and with a name it will be the monomorphism restriction
17:09:15 <hanDerPeder> as a named fucntion, foo = map .. (without a type decl)
17:09:52 <shachaf> Then the answer is the monomorphism restriction.
17:10:07 <x1f577> maerwald: i didnt see your message until i scrolled up, my apologies! still around?
17:10:29 <x1f577> essentially turning any file type into a bag-of-words for term frequency vectors and the like
17:10:31 <hanDerPeder> shachaf: thanks, I'll read up on that
17:10:52 <x1f577> with a txt file, its trivial, but with a pdf/xlsx/ppt/blah not so much
17:12:05 <slack1256> Should you use async exceptions for killing lets say a thread per user request?
17:12:33 <slack1256> lets say on a thread that is some long download transfer and the user want it shutdown
17:13:23 <slack1256> inside that thread it uses `bracket' to acquire and release the resources, but that is useful for dealing with synchronous exceptions though
17:14:38 <glguy> As long as your cleanup handlers can't block that's fine
17:15:24 <slack1256> those cleanup handlers aren't the bracket clean up handles of the thread right?
17:15:54 <x1f577> any way to call java code from haskell?
17:15:55 <glguy> the 2nd argument to bracket
17:16:09 <slack1256> Perfect!
17:16:39 <glguy> If they can block (say you're using hClose for example and something could be using the handle) you have to be more careful
17:24:23 <zlens> how do I use ecto with phoenix?
17:24:26 <zlens> wrong channel
17:25:33 <sa1> x1f577: Tweag IO are building inline-java for Sparkle. https://hackage.haskell.org/package/inline-java
17:25:50 <sa1> not ready, as the readme says
17:28:26 <joselin> alguien me enseña como registrarme para entrar a ##unix?
17:28:44 <slack1256> este no es el canal correcto
17:28:49 <joselin> :(
17:28:53 <joselin> donde pregunto?
17:29:17 <slack1256> revisa en google talvez. Deben de tener alguna web principal 
17:30:11 <joselin> :(
17:30:23 <joselin> no encuentro ya busque
17:30:33 <slack1256> Hablame por /msg 
17:33:50 <x1f577> sa1: just saw that.. im looking for a way to run the Apache Tika library :/ know of a native alternative? (it extracts text for search indexing from .pdf, .ppt, .xlsx, any many other files)
17:36:06 <sa1> no, I just knew about inline-java because I'd read about it, haven't needed to call Java.
17:47:26 <joselin181924> amigooooo
17:47:28 <joselin181924> donde estass
17:47:35 <joselin181924> :O
17:47:43 <slack1256> hahaahaha
17:47:49 <joselin181924> :(
18:14:51 <glguy> Joselin181924: this is an English language channel
18:38:10 * hackagebot pokemon-go-protobuf-types 0.1.2 - Haskell types for the Pokemon Go protobuf protocol.  https://hackage.haskell.org/package/pokemon-go-protobuf-types-0.1.2 (RickyElrod)
18:43:56 <slack1256> let her be, I don't even know how she/he came here
19:11:18 --- mode: ChanServ set +o glguy
19:11:18 --- mode: glguy set -bb *!*@webbox222.server-home.org John[Lisbeth]!*@*$##fix_your_connection
19:15:04 --- mode: glguy set -b+b *!*bc817ebe@*.server-home.org *!*@webbox222.server-home.org
19:15:17 --- mode: glguy set -b *!uid25044@gateway/web/irccloud.com/x-iabzwrutnxuxjlqg
19:15:28 --- mode: glguy set -b *!~Lajla@2001:0:5ef5:79fd:8cd:2beb:ae33:eb94
19:16:48 --- mode: glguy set -bb *!~AngryBeer@200.79.251.68nil *!*@248.Red-2-138-165.dynamicIP.rima-tde.net
19:18:12 --- mode: glguy set -bb *!~ircap@14.Red-81-32-230.dynamicIP.rima-tde.net *!*ffwacom@*.lnse1.cha.bigpond.net.au
19:19:02 --- mode: glguy set -b *!*@178-75-174-227.bb.dnainternet.fi
19:21:09 --- mode: glguy set -bb *!*@211.37.105.* *!*@78.185.8.19
19:21:31 --- mode: glguy set +b slack-haskell!*@*$##fix_your_connection
19:24:33 --- mode: glguy set -bb *!*@62.64.58.6 *!*@178.22.51.87
19:25:44 --- mode: glguy set -bb BotchlaOffUrself!*@* *!*wack@120.142.190.*
19:27:01 --- mode: glguy set -b *!*@201.209.74.191
19:29:26 --- mode: glguy set -bb $a:khax *!*@110.77.212.85
19:35:08 --- mode: ChanServ set -o glguy
19:48:06 <joe9> is anyone aware of any haskell libraries that can read a swagger schema file?
19:48:12 * hackagebot language-python 0.5.4 - Parsing and pretty printing of Python code.  https://hackage.haskell.org/package/language-python-0.5.4 (BerniePope)
19:49:39 <ClaudiusMaximus> updated my hgmp thingy to ghc-8, anyone have any feedback?  https://code.mathr.co.uk/hgmp  not on hackage yet.  it's very minimal still, just has helpers so you can FFI with Integer and Rational to GMP code
19:51:53 <tnks> anyone using Nix here?
19:52:18 <tnks> My nix-build is working (pretty sure), and populating /nix/store with a derivation.
19:52:47 <tnks> but when I run nix-build again, it recomputes everything, rather than just reporting the derivation is already made.
19:52:50 <tnks> (confused)
19:59:16 <tnks> oh. . . maybe it's the result symlink getting in the way.
19:59:37 <tnks> yeah, that's all it is.
20:00:21 <tnks> fuck me, I have no idea.
20:00:29 <tnks> maybe it's a temp file from an editor.
20:08:13 * hackagebot language-python-test 0.5.4 - testing code for the language-python library  https://hackage.haskell.org/package/language-python-test-0.5.4 (BerniePope)
20:30:41 <qmm> for stack, why would i need to put hakyll-4.7.1.0 in stack.yml? when would i put something in the project.cabal file? how would that look in the case of this specific version of the hakyll?
20:31:51 <senoj> qmm: if hakyll-$VERSION is not in the stackage blessed list (for your resolver) then you are supposed to add to your stack.yaml to tell stack to look on Hackage for it
20:32:22 <senoj> if your project depends on it, then you have to add it to project.cabal in either case
20:32:36 <senoj> ClaudiusMaximus: that looks nifty, I'll check it out
20:35:11 <glguy> qmm: The .cabal file describes the dependencies of a library and/or executable, the stack.yaml describes the particular workspace you happen to be working in right now
20:46:38 <fragamus> does anyone have a numeric typeclass that includes positive and negative infinity
20:47:34 <fragamus> Like Num but with inf
20:53:20 <cromachina> > 1.0 / 0
20:53:21 <lambdabot>  Infinity
20:53:27 <joneshf-laptop> I wonder why `Float` doesn't haev a `Bounded` instance?
20:53:45 <cromachina> :i (1.0 / 0)
20:53:48 <joneshf-laptop> Is it something to do with iee754?
20:53:54 <cromachina> :t (1.0 / 0)
20:53:55 <lambdabot> Fractional a => a
20:54:09 <joneshf-laptop> or IEEE even...
20:54:34 <joneshf-laptop> or Double I suppose
20:55:27 <cromachina> perhaps because it allows values like Infinity
20:56:39 <joneshf-laptop> Float/Double or IEEE 754?
20:56:49 <geekosaur> inf and nan screw with the idea of bounded, yeh
21:44:07 <dolio> NaN seems like the real problem. Infinities are what would allow it to be bounded.
21:54:16 <lol-icon> Just to be clear: Using DeriveGeneric and StandaloneDeriving, I can totally pwn any sort of data abstraction, right?
21:55:29 <lol-icon> Or is there some limitation on where Generic can be derived, say, no orphan Generic instances?
21:58:21 <senoj> lol-icon: Generic instances can be standalone derived. Your first question does not make sense.
21:58:32 <senoj> lol-icon: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/generic-programming.html
21:59:02 <glguy> No, the question is "Can I use a standalone deriving derived Generic instance on a type from another module for which the data constructors are not exported to access teh data constructors"
21:59:22 <glguy> "lollerskates pwn"
21:59:42 <senoj> ah
22:00:22 <glguy> lol-icon: What happened when you tried?
22:06:01 <qmm> glguy: what do you mean by workspace?
22:06:05 <qmm> 21:34 < glguy> qmm: The .cabal file describes the dependencies of a library and/or executable, the stack.yaml describes the particular workspace you happen to be working in right now
22:07:02 <glguy> qmm: The stack.yaml is just the set of libraries you're using right now, in this workspace
22:07:14 <qmm> can you give me an example of something which might describe the workspace
22:07:45 <nshepperd> lol-icon: '<interactive>:7:1: error: • Can't make a derived instance of ‘Generic (Foo a)’: The data constructors of ‘Foo’ are not all in scope so you cannot derive an instance for it'
22:07:45 <glguy> the workspace might be the set of 3 packages you're developing right now
22:08:10 <glguy> and the specific versions of the packages you want to use that they depend on
22:08:44 <glguy> each of those packages is going to have its own project.cabal file that describe what the dependencies for that particular package are
22:08:52 <glguy> and what version ranges that package can use
22:09:13 <glguy> Maybe your package works with base from 4.7 to 4.9, so that goes in the project.cabal
22:09:22 <glguy> but currently you're using base 4.9, that goes in the stack.yaml
22:09:39 <qmm> that's helpful, thank you
22:10:24 <glguy> someone else using your package might  very well make different choices in their stack.yaml for whatever they're doing
22:10:58 <glguy> hopefully the choices they make are within the set of packages you can support as defined by your upper and lower bounds in your project.cabal
22:33:13 <stuck_> How can I compare the individual digits in a number? e.g. compare 2 and 7 in 27
22:33:44 <shachaf> What kind of answer do you want?
22:34:19 <stuck_> I want to know if their equal, so 2 and 7 would be false but 2 and 2 would be true
22:34:30 <stuck_> they're*
22:35:32 <shachaf> Maybe your question should come with a type signature.
22:36:33 <senoj> stuck_: how about: digits :: Int -> [Int]
22:37:04 <senoj> (you should write this)
22:37:11 <senoj> then index into your result list and compare with ==
22:41:07 <stuck_> That looks like it would work, thanks senoj. It seems digits isn't available on the tryhaskell.org sandbox, I suppose I'll have to install it :)
22:41:29 <glguy> stuck_: The " (you should write this) " part means that you have to write digits
22:41:37 <senoj> stuck_: I didn't mean to imply it's a function you can import and use
22:41:53 <senoj> I meant it should be fairly simple for you to write yourself
22:42:00 <stuck_> ah ok Ivsee
22:42:39 <senoj> someone may have already written this function somewhere, but by the time you find it you could have written your own :)
22:42:54 <lyxia> show works as well
22:42:57 <glguy> > let same [] = True; same (x:xs) = all (x==) xs in same (show 22)
22:42:59 <lambdabot>  True
22:43:02 <glguy> > let same [] = True; same (x:xs) = all (x==) xs in same (show 27)
22:43:04 <lambdabot>  False
22:48:44 <lol-icon> nshepperd: Ah, thanks!
22:50:58 <stuck_> Awesome thanks glguy! I'm attempting some code golf problems with haskell and that's a big help
22:51:19 <pavonia> > map ((<=1) . S.size . S.fromList) ["", "2222", "2722"]
22:51:21 <lambdabot>  [True,True,False]
22:52:57 <joobus> is there a command line way to add a dependency to a project, or do I need to edit the cabal file manually?
22:53:55 <glguy> Manual afaik
23:00:11 <gabbiel> how do I into networking in haskell. its my first language and I need to do some internet stuff
23:02:03 <joobus> i've just run `stack new myproject` and done the initial setup, etc.  I want to add a package as a dependency, but I know that stack uses a snapshot of a whole bunch of packages, so how do I determine the version constraints to add to the cabal file?
23:03:31 <glguy> Joobus , you can look on stackage.org to figure out what version comes in the resolver you're using
23:03:50 <lol-icon> glguy: nshepperd: What still isn't clear to me is - how does GHC know that not all the constructors of a data type have been imported?
23:04:00 <johnw> has anyone written down the extranaturality laws for heterogeneous profunctors?  I'm bad at turning hexagrams into equational compositions
23:04:08 <glguy> Until you've tested it with other versions you can say it works with the major version you're developing against
23:04:41 <glguy> Lol-icon: because it knows what you've imported, it's the compiler
23:05:09 <lol-icon> glguy: But, when I'm type-checking one module, normally I don't need to know all about other modules.
23:05:29 <glguy> You do need to know about the other modules normally, yes
23:05:34 <lol-icon> glguy: The original exporting module needn't even advertise the existence of some constructors.
23:06:33 <glguy> Ghc knows everything in the other modules and the export lists
23:07:30 <lol-icon> Ah, so when I'm typechecking a module Bar that imports a module Foo, GHC doesn't only know what Foo exports, it also knows Foo's internals?
23:07:50 <glguy> The .hi files tell GHC what it needs to know about the other modules
23:08:02 <glguy> It consults these when compiling your module
23:08:54 <lol-icon> I see. And these *.hi files contain more information than just what a module nominally exports, right?
23:13:54 <purelazy> lol-icon: Indeed. It would contain the whole module - as one would expect, plus a list of things (functions/types/etc) visible-from-outside.
23:33:19 * hackagebot namespace 0.1.2.0 - A Generic Haskell library for managing namespaces  https://hackage.haskell.org/package/namespace-0.1.2.0 (xuhao)
23:38:29 <joobus> when stringing a bunch of functions which return monads together, do all functions have to return the same monad type?
23:39:01 <hrumph> no
23:39:08 <hrumph> that's the thing about monads
23:39:22 <joobus> or can I for instance read a file, which returns IO something, then >>= to a thing which returns a Maybe [a]
23:39:40 <hrumph> you don't return IO
23:39:50 <hrumph> IO has to remain consistent throughout the chaining
23:40:12 <joobus> i'll make a paste...
23:40:14 <hrumph> IO monad has type IO x where x can change
23:40:37 <sl5t> remember >>= :: M a -> (a -> M b) -> M b
23:40:37 <hrumph> oh i see
23:41:16 <lpaste> joobus pasted “Pass a file to a Maybe monad function ” at http://lpaste.net/172863
23:42:27 <joobus> sl5t: so then the monad type has to remain the same...
23:42:32 <sl5t> yes
23:42:36 <joobus> k
23:43:32 <hrumph> joobus, i misunderstood your q
23:43:54 <hrumph> the monad type mustn't change, but the data type can vary
23:44:37 <hrumph> the ability to vary the data type is what gives monads their power
23:45:12 <hrumph> before monads people were stuck with stuff like table driven programming where all the functions had to have the same signature
23:46:26 <hrumph> now you just chain together your operations with the monad operator
23:51:08 <shachaf> A monad is not a value :: M A. A monad is the M. It's a type.
23:53:49 <joobus> k, I'm kinda stuck.  I have a function which returns an IO ByteString.  Then I want to use some functions on that ByteString that return a Maybe Whatever, but ghc is complaining when I try to do anything with a maybe in a do block because it is not IO.
23:54:31 <joobus> even if at the end of the do block I use `return $ fromJust aThing`
23:54:41 <Cale> That shouldn't be a problem
23:55:07 <Cale> Here's how to think about it: a value of type IO t is a description of something which could be done to produce a value of type t
23:55:33 <Cale> When you write v <- x inside a do-block and x :: IO t, then v :: t is the result of carrying out the action described by x
23:55:51 <Cale> and the do-block itself is a larger IO action which, as part of its description, says to perform x
23:56:42 <Cale> So you should read "v <- x" like "execute x, and name its result v"
23:57:11 <Cale> If x :: IO ByteString, then v :: ByteString, and the do-block as a whole has type IO t for some t
23:57:40 <saurabhnanda> Can someone be kind enough to give feedback on https://gist.github.com/saurabhnanda/2271b5e1af2af77db9db9f6e14f5c12c
23:57:40 <Cale> (it'll match the type of the last line of the do-block, because the last action's result gets returned as the result of the whole thing)
23:57:54 <saurabhnanda> Want to be sure I'm not missing anything obvious
23:58:00 <saurabhnanda> feel free to comment on the Gist directly
23:58:01 <saurabhnanda> or here
23:59:07 <Sgeo> Am I correct in thinking of the Forget profunctor a -> r as a continuation?
23:59:08 <joobus> Cale: I get that part, but with the bytestring, I then want to "convert" it to a Maybe [a].  So then do I return a `IO Maybe [a]`?
23:59:31 <Cale> joobus: Well, what does converting it entail?
