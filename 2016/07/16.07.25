00:00:56 <joe9> liste, I have a simple .cabal file. Does that mean my ghc environment is messed up?
00:02:19 <liste> joe9: I don't think so. do you use a sandbox?
00:02:32 <joe9> liste, no, I do not think so.
00:03:07 <mniip> hmm this is problematic
00:04:47 <liste> joe9 you should, that way projects don't step on each others' toes
00:05:28 <liste> but cabal repl takes care of configuring ghci for your project, you should use it for projects
00:05:43 <liste> it works with sandboxes too
00:07:41 * hackagebot acme-default 0.1.0 - A class for types with a distinguished aesthetically pleasing value  https://hackage.haskell.org/package/acme-default-0.1.0 (esz)
00:07:41 * hackagebot hlint 1.9.36 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.36 (NeilMitchell)
00:08:43 <glguy> Joe9: you probably have multiple versions of the same package installed and ghci is picking the newer one and cabal isn't
00:09:00 <joe9> glguy: ok, Thanks. I will clean up my ghc environment.
00:13:55 <mniip> hm
00:14:02 <mniip> why is polykinds slacking off...
00:17:00 <pavonia> Is there something like an applicative fold? afoldr :: Applicative f => (a -> b -> b) -> f b -> [f a] -> f b
00:17:39 <jle`> :t \f -> foldr (liftA2 f)
00:17:40 <lambdabot> (Applicative f, Foldable t) => (a -> b -> b) -> f b -> t (f a) -> f b
00:18:58 <pavonia> Ah, liftA2 makes it shorter
00:19:36 <jle`> liftA2 turns a (a -> b -> c) into an (f a -> f b -> f c), which is exactly the folding function that you want for this case
00:20:11 <pavonia> Right, I was using \f g -> af <$> f <*> g
00:28:38 <mniip> hmm
00:28:42 <mniip> I really don't like this
00:28:44 <mniip> 	type Ob (Cartesian k l) x = (x ~ '(Fst x, Snd x), Ob k (Fst x), Ob l (Snd x))
00:40:03 <mniip> data Functor f k l where Fmap :: (k a b -> l (f a) (f b)) -> Fucntor f k l
00:40:42 <mniip> instance Category (Functor f) where type Ob (Functor f) k = Category k
00:40:43 <mniip> :o
00:42:35 <shachaf> a and b are existential?
00:42:42 <mniip> yes
00:42:59 <mniip> shachaf, have you seen the monadic monads paste thing
00:43:05 <shachaf> No.
00:43:25 <mniip> http://lpaste.net/171524
00:45:12 <mniip> I've noticed that PolyKinds is slacking off a bit so a few more classes might need kind annotations
00:47:56 <shachaf> You can probably find something similar in various places.
00:48:19 <shachaf> E.g. https://github.com/ekmett/hask/blob/master/wip/Univariant.hs
00:48:39 <mniip> dammit!
00:49:16 <mniip> I was thinking I was so clever with this associated Ob constraint
00:52:28 <mniip> why does edwardk have to suck the fun out of everything :(
00:57:44 <pavonia> Edward K. The K stands for "Killljoy"
00:58:04 <hvr> any relationship to the Killjoys SciFi show?
01:00:27 <athan> Does anyone here know of a way to break a long constraint context in haddock? Mine keeps pouring off the right of the page :\
01:00:59 <mniip> athan, type synonyms?
01:01:14 <athan> mniip: !!! Great idea! thank you!
01:09:01 <ertesx> athan: might give you an incentive to document your function arguments, because then haddock aligns them vertically
01:09:47 <ertesx> https://www.haskell.org/haddock/doc/html/ch03s02.html#idm140354810892448
01:13:57 <ongy> is there an if variant, that let's me use IO Bool for the decision?
01:16:35 <athan> ertesx: Actually that's what's causing the overflow!
01:16:48 <kadoban> ongy: Do it in a 'do' block, something like   do {x <- iox; if x then whatever else whatever} possibly?
01:16:54 <athan> My constraints are just really massive, see I can't use `-- ^` in the constraint tuple itself
01:17:08 <athan> like `foo :: ( Foo1 x, Foo2 x, Foo3 x ... ) => ...`
01:17:19 <mniip> :t liftM2 bool
01:17:20 <lambdabot> Monad m => m a -> m a -> m (Bool -> a)
01:17:23 <mniip> err
01:17:26 <mniip> :t liftM3 bool
01:17:28 <lambdabot> Monad m => m r -> m r -> m Bool -> m r
01:18:20 <mniip> or like
01:18:29 <mniip> bool foo bar <$> ...
01:18:42 <ongy> mh, looks like I
01:18:46 <ongy> mh, looks like I'll stick with do syntax
01:18:55 <ongy> and I should learn not to hit enter on accident -.-
01:26:50 <jophish> What does @cartazio mean here: https://github.com/haskell/vector/issues/68#issuecomment-234796437
01:36:02 <mniip> shachaf, btw
01:36:36 <mniip> we've conjectured that if a category has all binary product objects and a terminal object then the binary product bifunctor can act as a monoidal product
01:36:53 <mniip> is that so
01:37:47 <jle`> ongy: /b 3
01:37:49 <jle`> ah, sorry
01:38:11 <shachaf> We?
01:38:44 <shachaf> Are you asking whether categorical product makes a valid tensor product for a monoidal category?
01:39:17 <mniip> shachaf, me and alercah
01:39:25 <mniip> and yes
01:39:40 <shachaf> Yes.
01:40:01 <mniip> coproduct + coterminal object is a monoidal category too, right
01:40:27 <shachaf> Yes.
01:40:46 <shachaf> You can see both of those in https://en.wikipedia.org/wiki/Monoidal_category#Examples
01:41:01 <ongy> jle`: buffer 3 or actually a hint for me?
01:41:17 <arianvp> Can I lift  Symbol to  '['Char] ?
01:41:24 <arianvp> I want to do type-level calculations on strings
01:41:42 <arianvp> or not possible?
01:46:28 <jle`> mistake :)
01:46:35 <jle`> ^ ongy 
01:46:52 <jle`> arianvp: you cannot -- Char is not promotable, anyway
01:47:15 <jle`> there are some libraries that ditch Symbol and give you some TH for type-level strings, though
01:51:44 <shachaf> @quote copumpkin monad
01:51:45 <lambdabot> copumpkin says: monads are like monad tutorials
01:52:01 <shachaf> @quote lax
01:52:01 <lambdabot> geheimdienst says: haskell makes hard things easy and easy things a strong lax monoidal endofunctor ...
01:52:13 <shachaf> @quote terminal.bi
01:52:13 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
01:55:40 <mniip> category theory is just categories all the way down isn't it
01:56:04 <shachaf> A monoidal category is just a 2-category with one object.
01:56:41 * mniip can comprehend that
01:57:27 <shachaf> If you want to be picky, I guess it's just a weak 2-category.
01:58:11 <mniip> ok
01:58:14 <mniip> what's a bicategory
01:59:18 <shachaf> A weak 2-category thing.
01:59:49 <mniip> what
02:00:16 <shachaf> https://ncatlab.org/nlab/show/bicategory
02:01:09 <mniip> ok I was mistaken
02:01:13 <mniip> I cannot comprehend that yet
02:02:35 <shachaf> It's simpler than it looks.
02:03:52 <mniip> oh
02:03:58 <mniip> so that's what a 2-category is
02:06:06 <mniip> oh
02:06:15 <mniip> 2-morphisms are only between parallel morphisms, right?
02:07:45 <shachaf> Yes.
02:12:10 <mniip> and a bicategory is an object in what category?
02:13:00 <shachaf> Whatever category you like?
02:13:17 <mniip> "a monad is just a lax functor from a terminal bicategory"
02:13:18 <shachaf> 0 is an object in what category?
02:13:24 <shachaf> Oh, that.
02:13:28 <mniip> they call it terminal so they must be talking about some specific category
02:14:32 <shachaf> The category with the appropriate 2-functors as arrows, I guess.
02:14:58 <mniip> 2-functors?
02:15:11 <Dodecahedrus> Hi, I’ve been programing with Haskell for a while and I want to add IDE-like features to my workflow. I’ve read great things about Intero but I have 0 experience with emacs. My editor of choice is Sublime Text. Is Intero that great? Are there some nice plugins for sublime?
02:15:45 <shachaf> https://ncatlab.org/nlab/show/2-functor
02:15:57 <shachaf> https://ncatlab.org/nlab/show/lax+functor
02:15:59 <athan> Dodecahedrus: I know atom support is pretty nice now, but atom is slow :\
02:16:05 <shachaf> It works out to be what you'd think it would be.
02:16:17 <shachaf> I'm going to sleep.
02:16:30 <athan> Dodecahedrus: There's also begriff's "haskell vim now", if you'd prefer vim instead :D
02:16:39 <shachaf> You go implement adjunctions or limits or something.
02:17:39 * hackagebot nested-routes 7.2.0 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-7.2.0 (athanclark)
02:18:41 <athan> Dodecahedrus: https://ro-che.info/ccc/26
02:19:26 <shachaf> #esoteric has a large database of "X is just Y" definitions.
02:23:22 <Dodecahedrus> athan: I tried atom some months ago, but i really prefer sublime over it. Vim is nice but I usually want more features from my editor. I was thinking going for spacemacs with intero or sublime with some plugin.
02:31:09 <athan> Dodecahedrus: begriff's system plugs in a lot into vim!
02:31:20 <athan> I use spacemacs though and I love it
02:31:35 <athan> you just have to get used to the Space-oriented keystrokes, which are hard to find out at first
02:32:07 <athan> and its sheer awesomeness
02:32:45 <parsnipM_> editor wars are getting really complicated these days ;)
02:36:23 <ent> does anyone use Yi?
02:36:35 <ent> it seemed interesting but it was too much of a pain to set up
02:36:38 <athan> ent: I have, and I really enjoyed it while I did
02:36:50 <athan> it's just... well, yeah. Hard to use haha
02:36:55 <gfixler> reduceList :: (c `Reducer` m) => [c] -> m
02:37:03 <gfixler> what's going on with that constraint?
02:37:12 <gfixler> I haven't seen constraints like that before
02:37:19 <athan> gfixler: o_O is that even legal? Sliced constraints?
02:37:26 <gfixler> no idea
02:37:30 <athan> ...is there a source you can link me to?
02:37:33 <gfixler> it's here: http://comonad.com/reader/wp-content/uploads/2009/07/AllAboutMonoids.pdf
02:37:36 <gfixler> page 12
02:37:39 <gfixler> I get the concept
02:37:49 <gfixler> but the notation seems magical
02:38:04 <athan> Oh well if it's just a pdf and not a .hs file they probably just invented the syntax for their own reasons
02:38:09 <gfixler> I didn't know I could have constraints on 2 things at once
02:38:14 <gfixler> could be
02:38:22 <gfixler> but maybe not
02:38:26 <athan> (unless you actually can :x)
02:38:27 <gfixler> Num a is a constrain
02:38:36 <gfixler> Reducer c m apparently is, too
02:38:39 <gfixler> just on two params
02:38:48 <gfixler> MultiparamTypeClasses or somesuch?
02:39:24 <athan> > let foo :: (Int `MonadReader` m) => m Int; foo = ask; in runReader foo 1
02:39:26 <lambdabot>  1
02:39:29 <athan> :O!!!!!
02:39:34 <gfixler> \o/
02:39:41 <athan> meh brehn
02:39:45 <athan> eet hurts
02:39:47 <athan> ow
02:39:53 <gfixler> are you being struck by lightning now, leveling up?
02:40:31 * athan has the power!!!
02:40:53 <athan> Is there a `Compose` constraint?
02:41:08 <gfixler> seems familiar
02:41:25 <athan> :x I think that would mess with type families or something, their macro-ness instead of being genuine lambdas
02:41:30 <gfixler> Data.Functor.Compose
02:41:33 <athan> but I'm not sure. I know of the compose type
02:41:41 <athan> Yeah, but that's not for constraints
02:41:54 <gfixler> MonadCompose?
02:42:22 <athan> you could do something like this I think: `{-# LANGUAGE ConstraintKinds, TypeOperators #-} type f :o: g = (f,g)`
02:42:29 <athan> ...actually nope
02:42:37 <athan> because application won't work (I think
02:42:40 <athan> er... wait
02:42:56 <athan> type (:o:) f g x = (f x, g x)
02:43:01 <athan> ...maybe
02:43:36 <athan> But this screws with the whole type-alias-are-macros-not-lambdas thing
02:43:47 <athan> and it wouldn't actually work. Hm.
02:44:07 <gfixler> I'll leave you to it. My brain is full.
02:44:07 <athan> ...maybe an empty class?
02:44:26 <gfixler> I'm on low sleep from the Sand Fire
02:44:29 <athan> class (f x, g x) => (:o:) f g x where;
02:44:40 <athan> :) nice sunset?
02:44:49 <gfixler> oh, yes, everything is horribly beautiful atm
02:45:04 <athan> hah, where if you don't mind me asking?
02:45:10 <gfixler> Santa Clarita
02:45:27 <gfixler> the fire is immediately bordering the city, and larger than the city
02:46:24 <gfixler> we're living on Fury Road atm: https://cdn-images-1.medium.com/max/2000/1*H3nD6rNT2o999PxH6HSW5A.jpeg
02:46:33 <athan> wow... so with -XUndecideableInstances and -XMultiParamTypeClasses, `class (f x, g x) => Compose f g x` works :)
02:47:09 <athan> Oh my gosh, that's daugnting
02:47:36 <gfixler> so now what can we do with that class?
02:47:43 <gfixler> publish a paper?
02:47:50 <athan> doubt it
02:47:56 <athan> wait I think mine doesn't make sense anyway
02:48:09 <athan> lol that should be called "both"
02:48:09 <Guest8902> I'd like to use megaparsec to detect statements of the form "a1; a2; a3", which works fine with "sepBy stmt semi", where stmt parses one "a" and semi parses the semicolon. Now I'd like to parse everythign BUT the last part, to have something like "a1; a2; return x", where the last element has to be handled separately. Is this possible?
02:48:13 <athan> `Both`
02:48:28 <athan> it _should_ be something wonky and existential / ambiguous like this:
02:48:51 <athan> class (a `f` b, b `g` c) => Compose f g a c where;
02:48:53 <athan> I think..
02:50:17 <athan> Guest8902: Could you just not follow stmt by semi?
02:50:32 <athan> Or just make it optional? Sorry, I'm not great with parsing
02:50:57 <Guest8902> athan: I'm afraid not, as I did not make the grammar
02:51:54 <athan> Guest8902: You could do something like this, maybe: `sepBy (stmt <|> returnStmt) semi` possibly
02:52:05 <mniip> athan, it used to be doable in ghc 7.6 iirc
02:52:13 <mniip> fundeps were a bit broken
02:52:28 <athan> mniip: Hah! That's fun
02:52:35 <mniip> you could actually create constraint lambdas with something like
02:52:48 <Guest8902> athan: I feared so. Well thank you
02:52:52 <mniip> class (<~) a b c d | a -> c, d -> b
02:52:57 <mniip> instance (<~) a a b b
02:53:42 <athan> Guest8902: Best of luck! I've had to bite the bullet and perform multiple parsing passes often :\
02:53:49 <athan> Maybe Earley might be up your alley?
02:53:59 <mniip> instance (g y z, f x y) => Compose f g (x <~ z)
02:54:39 <athan> mniip: Oh hm! But that wouldn't work today because fundeps need specific instances?
02:54:49 <athan> sorry, monomorphic instances
02:56:28 <mniip> nowadays fundeps dont believe that 'f x y' determines y from x
02:58:55 <athan> *nods*
03:27:52 <lpaste> jgz pasted “Python webscraper to translate into Haskell” at http://lpaste.net/171654
03:28:49 <jgz> Could anyone translate the Python webscraper code into Haskell code?
03:28:52 <jgz> http://lpaste.net/171654
03:29:16 <cow_2001> oh my
03:29:30 <MasseR> jgz: I think that's a bit much :)
03:29:44 <MasseR> We can point you to the right direction instead
03:29:51 <cow_2001> did you read up on some scrapers?
03:29:56 <cow_2001> haskell scrapers
03:30:02 <jgz> Not much
03:30:40 <mniip> it doesn't even respect robots.txt
03:31:02 <jgz> I just started learning Haskell and am trying to understand HS code by translating an example from a Python code.
03:31:10 <cow_2001> i'm woefully ignorant. i hope someone can help you. i'm curious about that as well
03:31:43 <jgz> I think I learn better by analysing examples
03:31:45 <MasseR> jgz: step 1: read urls from text file
03:31:49 <MasseR> :t readFile
03:31:51 <lambdabot> FilePath -> IO String
03:32:12 <MasseR> step 2. For each url fetch the html
03:32:22 <MasseR> You can use for example wreq for it (I did two days ago)
03:32:36 <MasseR> https://hackage.haskell.org/package/wreq
03:32:43 <MasseR> Then you need to parse the html
03:33:30 <MasseR> I used html-conduit / xml-conduit for it, but you could use for example tagsoup
03:35:52 <ongy> can I somehow tell 'cabal haddock' to fail if coverage is not 100%?
03:36:30 <jgz> Is there also a function to delay visiting each webpage, say, 5 seconds?  
03:37:02 <jgz> So visiting & scraping the first page then wait for 5 seconds, and visit the second page.. and so on?
03:38:33 <MasseR> jgz: you can add delay with threadDelay
03:38:35 <MasseR> :t threadDelay
03:38:37 <lambdabot> Int -> IO ()
03:38:57 <jgz> Cool
03:39:08 <jgz> Many thanks
03:43:02 <Gurkenglas_> I'm looking at https://github.com/chrisdone/ircbrowse/blob/master/src/Ircbrowse/View/Browse.hs , specifically tr ! name (toValue anchor) !# (toValue anchor) !. (toValue (eventClass ++ " " ++ focused)) $ do . How do I find out where !. is defined?
03:43:37 <MasseR> https://www.stackage.org/lts-6.9/hoogle?q=(!.)
03:43:57 <MasseR> No wait, there's no exact matches, I read wrong
03:48:00 <Gurkenglas_> (I would usually find the github project the hackage package im reading corresponds to, and use github search, but it doesnt work for things like !.)
03:52:38 <sdx23> Gurkenglas_: git clone, ack -> upstream/snap-app/src/Text/Blaze/Extra.hs 20:(!.) :: (Attributable h) => h -> AttributeValue -> h
04:13:16 <Gurkenglas_> sdx23, "ack"? And how did you know to clone blaze-html-contrib?
04:14:42 <sdx23> Gurkenglas_: "ack" as in "grep" :) And I didn't, it's a submodule I guess.
04:17:57 <Kneiva> r
04:22:43 * hackagebot tcp-streams 0.2.3.0 - One stop solution for tcp client and server with tls support.  https://hackage.haskell.org/package/tcp-streams-0.2.3.0 (winterland)
04:28:12 <Guest8902> I'm having troubles with megaparsec's "between". From what I gathered the following should work but it yields the attached error. Can anyone see an obvious error? http://lpaste.net/171668
04:31:44 <lieven> Guest8902: identifiers should start with letters perhaps?
04:35:25 <Guest8902> lieven: ....goddamnit...
04:35:33 <Guest8902> thanks
04:56:31 <lpaste> pollz pasted “Issue” at http://lpaste.net/171678
04:56:57 <pollz> As stated, the code and the error that it is showing.
04:58:43 <pavonia> What is cis?
04:59:18 <pollz> Floating a => a -> Complex a
04:59:24 <pollz> Cis is cos + j sin
05:00:23 <pavonia> It doesn'T seem to know what the result type is. Did you try giving it an explicit type signature?
05:00:40 <liste> pollz: try 1::Double .. 1000 instead of 1..1000
05:00:46 <pollz> Coo.
05:01:21 <pavonia> :t mod
05:01:22 <lambdabot> Integral a => a -> a -> a
05:01:37 <liste> seems you need a type conversion somewhere
05:02:03 <pollz> liste: That thing crapped some huge error.
05:02:10 <pollz> You want me to paste it?
05:02:24 <liste> pollz: no need
05:02:40 <liste> pollz: mod doesn't work with doubles
05:02:44 <pollz> Ah
05:02:46 <liste> pollz: this works [cis (fromIntegral x) | x <- [y | y <- [1..1000], y `rem` 13 == 0]]
05:03:08 <pollz> No
05:03:12 <pollz> It's giving the same error.
05:03:21 <liste> for me it works at least, in ghci
05:03:24 <pollz> And it isn't running on floats anywhere
05:03:28 <pollz> Oh
05:03:31 <pollz> Wait. Yes. Thanks.
05:03:35 <pollz> I forgot the fromIntegral
05:03:41 <pollz> Danke Schon
05:04:02 <pollz> Over and out.
05:06:07 <carter> jophish: I thought they wanted a shallow copy
05:17:17 <jophish> carter: that's right, he replied confirming that, thanks :)
05:17:32 <sebastian-w_> Hi, anyone knows a explicit implementation of (<*>) in continuation passing style ?
05:18:31 <carter> jophish: I am he
05:18:56 <carter> jophish: but also its a pretty simple thing to do in userland
05:19:57 <jophish> carter: sure, but it's a shame for every user wanting this to have to rewrite it.
05:20:21 <jophish> I think it is above the fairbairn threshold
05:20:24 <carter> How many folks want it! 
05:20:35 <jophish> at least two!
05:20:38 <carter> I thought you wanted to do a shallow wrapper
05:21:05 <carter> Which you can already do. And the. Deep copy that with map
05:21:43 <jophish> I can't remember why I wanted it actually. I think it was probably in converting some list based code to use vectors
05:21:53 <carter> FromLisrt
05:22:18 <carter> I guess it's usesefu
05:23:30 <carter> Useful. But it's not something we need to wire in and we got enough other deeper stuff in the queue.  Granted the queue was slow for a while
05:25:21 <oggy> is there an off-the-shelf way to get the direct dependents (NOT dependencies) of a hackage package?
05:25:47 <carter> Like, it's more important to have some help on improving vectors test suite design
05:27:40 <Guest8902> I'm having a function "constant = parseFloat <|> parseInt" in my megaparsec-parser. This creates problems when having something like a list of integers [1,2,3], where parseFloat fails. I'd think, parseFloat would just give up and let parseInt have it's try. But parseFloat complains loudly about expecting a dot instead of a comma. Can I force the method to fail silently and resume the parsing at parseInt?
05:31:39 <hexagoxel> Guest8902: https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec-Prim.html#v:try
05:34:10 <cjlarose> I'm implementing a heap backed by Data.Array.IArrays. I've found through profiling that my bubbleUp function is a bottleneck. I think this is because though each step of bubbling up, I'm creating a bunch of intermediate arrays and the (//) function just clones the entire array each time. I think what I'd like to do is implement my bubbleUp function by taking an immutable array, converting it into a mutable array, performing
05:34:10 <cjlarose>  all of the necessary mutations, then convert it back to return an immutable array. Does this sound like a good approach? If so, how do I convert an immutable array to a mutable one? Here's my bubbleUp function: https://github.com/cjlarose/hackerrank-solutions/blob/b830e73dd35135e5ad48febd9108093013af57c3/find-the-running-median/Main.hs#L27-L33 
05:37:24 <Guest8902> hexagoxel: exactly what I was looking for. Thanks a bunch!
06:02:36 <tdammers> hmm, I wonder... been working on a parsec parser the past few days, and occasionally it happens that I write things wrong and it ends up in an infinite recursion, eating up all my RAM and then all my swap space and basically requiring a reboot to get the computer back in a working state
06:02:46 * hackagebot hoogle 5.0.2 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.2 (NeilMitchell)
06:02:47 <tdammers> there must be a fairly straightforward way of guarding against that?
06:04:50 <srpx> Hello, can anyone recommend me a quick/simple guide, course, tutorial, reference or anything from which I can learn from, on Linear Logic?
06:05:58 <phadej> tdammers: +RTS -M1G -RTS
06:06:12 <phadej> tdammers: if you are sure 1G of heap should be enough for your process
06:07:08 <tdammers> phadej: if 1G isn't enough, then I've done something wrong
06:07:18 <phadej> tdammers: :)
06:07:23 <tdammers> phadej: it's a parser for creole wiki (don't ask), it shouldn't have to backtrack that deeply
06:08:01 <alercah> mno2: I wasn't conjecturing the monoidal category thing, I was already aware of it heh
06:08:06 <phadej> FWIW: i use those with GHC running on travis (or other quite constrained environments)
06:08:07 <alercah> err mniip 
06:08:33 <tdammers> I should probably make a habit of using them everywhere
06:08:39 <tdammers> considering my reckless habits
06:08:56 <phadej> tdammers: https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/runtime-control.html#rts-options-environment
06:09:02 <tdammers> (ironically, it turns out that I actually do move fast and break things, and Haskell lets me get away with it)
06:09:32 <tdammers> awesome, thanks
06:09:37 <tdammers> that is even more useful
06:10:13 <tdammers> (also, I've never seen the OS kill the process, it just came to a grinding halt)
06:14:22 <Gurkenglas> Where does stack save its globally installed packages? (so i can delete one because I stack installed Safe instead of safe which is something entirely different and now I have name collisions and stack uninstall Safe says it doesn't manage global stuff)
06:14:44 <tdammers> Gurkenglas: somewhere in ~/.stack, I believe
06:15:36 <Gurkenglas> Windows, so you probably mean %appdata%/stack, but I dont know where in there and there are multiple files named safe or Safe or the like and I dont know which to delete
06:15:37 <tdammers> unless you ran stack as root, in which case I have no idea
06:15:45 <tdammers> ah
06:15:53 <tdammers> it's probably best to just nuke the entire .stack dir
06:16:04 <Gurkenglas> o.o
06:16:36 <kadoban> Wait, why do you have to delete it? What are you trying to do that's giving you some conflict?
06:17:04 <tdammers> kadoban: my guess would be two packages that both define the same module
06:17:18 <Gurkenglas> yup http://lpaste.net/7352762549353316352
06:17:25 <tdammers> both have a top-level module named Safe
06:17:47 * hackagebot impure-containers 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/impure-containers-0.1.0.0 (andrewthad)
06:17:55 <tdammers> which means you can't have them both installed into the same environment
06:18:20 <Gurkenglas> Ooh the capital one has a 0.1 after it. If I was gonna nuke it anyway lets see what happens if I delete everything with a "Safe-0.1" in its name
06:18:26 <tdammers> also a good reason to avoid installing things globally, especially with stack
06:18:57 <Guest8902> Which concept does this? "? :: (f -> x -> y) -> t x -> y" (not sure if this is syntactically correct?)
06:18:57 <kadoban> tdammers: In most cases this wouldn't even matter, because usually you have to specify which one you're depending on (like in the .cabal file).
06:19:16 <Gurkenglas> tdammers, but if I install things locally I have to install them again for each project
06:19:28 <Gurkenglas> (and if I do everything in one project thats no different from doing it globally right)
06:19:31 <tdammers> kadoban: yes, but if you manually cabal install something into an environment, it's going to be installed, whether it's in the .cabal or not
06:19:48 <tdammers> Gurkenglas: no, you don't - stack caches packages across projects
06:20:04 <tdammers> it still installs them per-project, but it doesn't recompile if you already have the right version
06:20:21 <tdammers> (has to be the exact same version compiled with the exact same GHC though)
06:20:30 <kadoban> 'stack exec ghc' isn't exactly a usual command :-/ I guess 'stack ghc' isn't going to really help there though.  Gurkenglas: what if you do 'stack dragger.hs --package safe', does that bail with the same error?
06:20:46 <Gurkenglas> so that means i can make a project now and install everything but Safe and it wouldnt take a second?
06:20:50 <mniip> Guest8902, sounds like fold
06:20:52 <mniip> :t fold
06:20:54 <lambdabot> (Foldable t, Monoid m) => t m -> m
06:20:57 <mniip> :t foldMap
06:20:59 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
06:21:23 <kadoban> Gurkenglas: Yes, especially if you use the exact same LTS version as the global one is using.
06:21:27 <Gurkenglas> kadoban, what should i usually be using instead of stack exec ghc?
06:21:48 <Guest8902> mniip: thanks
06:22:07 <kadoban> Gurkenglas: Well if you're just running one .hs file like that, I'd probably use stack in command interpreter mode instead, which is ... let me find the docs link.
06:22:13 <Gurkenglas> http://lpaste.net/7352762549353316352
06:22:21 <Gurkenglas> stack exec ghci, right?
06:22:34 <tdammers> yes, or stack repl
06:22:44 <kadoban> Hmm, that's unfortunate that that doesn't save that.
06:22:47 * hackagebot impure-containers 0.1.1 - Initial project template from stack  https://hackage.haskell.org/package/impure-containers-0.1.1 (andrewthad)
06:22:53 <tdammers> there's a subtle difference between the two, I keep forgetting what it is
06:23:17 <kadoban> Well, stack ghci is different. I was talking about something else
06:23:42 <Gurkenglas> (removing all files with Safe-0.1 in them didnt change nuthin)
06:23:48 <bizarrefish> Hi all
06:24:26 <kadoban> Gurkenglas: https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter Was what I was thinking of for your use-case, but it's probably not going to help get past that error.
06:25:20 <kadoban> I almost always just have a full package kind of thing, with a .cabal file and a stack.yaml. That would definitely save you, but ... then you have to structure you stuff correctly and etc.
06:25:51 <ongy> How can I define the hackage package documentation? Not the module haddock, but the index-page of the package
06:26:08 <ertes> ongy: 'description' field
06:26:50 <tdammers> recently, also having a README
06:27:31 <tdammers> I think
06:27:34 <ongy> thx
06:30:54 <ertes> i can confirm that a README.md file works, if it's listed in extra-source-files, but it does not replace the 'description' field, because that's the content that appears at the top
06:31:30 <ertes> also note that 'description' text uses haddock markup, whereas README.md uses markdown
06:31:56 <ertes> and to make paragraphs instead of empty lines you write lines with a lone dot in them
06:32:47 <ertes> example:  https://hackage.haskell.org/package/rapid-0.1.2/rapid.cabal
06:33:38 <Gurkenglas> The first line in C:\Users\Andreas\AppData\Roaming\stack\global-project\.stack-work\install\61d38230\pkgdb\package.cache is http://lpaste.net/4467719380385398784 , thats ok to delete right?
06:34:05 <Gurkenglas> (and thats the last mention of Safe-0.1 in .stack)
06:35:11 <Gurkenglas> hmm I guess I can just back it up and try
06:35:43 <Gurkenglas> hmm nope "C:\Users\Andreas\AppData\Roaming\stack\global-project\.stack-work\install\61d38230\pkgdb\package.cache: GHC.PackageDb.readPackageDb: inappropriate type (not a ghc-pkg db file, wrong file magic number)"
06:36:07 <Gurkenglas> Why would that have a checksum :(
06:37:27 <Guest8902> well... while it seems like foldMap, I can't get it to work the way I want it to. I have a function "f :: Parser [Kernel]" and I'd like to to get the last Kernel-element from the list inside the parser from the caller. Is that somehow possible?
06:38:19 <Gurkenglas> You want "(a -> b) -> f a -> f b"? That's called fmap or (<$>), as in "fmap last f" or "last <$> f"
06:38:39 <Gurkenglas> "(a -> b) -> Parser a -> Parser b", that is.
06:39:23 <Guest8902> I tried <$> already, but what I actually want is "(a -> b) -> Parser a -> b"
06:40:19 <Gurkenglas> Are you sure you don't want "(a -> b) -> Parser a -> Parser b"? However you wanted to use b (to make a c, say), you can also use fmap on that (b -> c) to get a Parser c
06:40:43 <Gurkenglas> And then you propagate that up to the point where you usually get rid of Parser
06:41:16 <Gurkenglas> (If you had IO instead of Parser, that point would be calling it main)
06:42:41 <Gurkenglas> And if that would have you end up with Parser (Parser d) at some point, you use liftA2 <*> or >>= or join
06:42:58 <Gurkenglas> "liftA2 or <*> or >>= or join"
06:43:26 <Guest8902> I' think so, yes. I have "es <-  last <$> body" and "es" should be of type Kernel, while body is of type "Parser [Kernel]", which gives me a type error
06:43:54 <Gurkenglas> Could you paste your code and your error please? lpaste.net
06:44:00 <Guest8902> sure, one moment
06:45:09 <Gurkenglas> kadoban, couldn't I just nuke the global project but not the shared executables, so reinstalling everything wont need to recompile?
06:46:52 <Guest8902> Gurkenglas: http://lpaste.net/171699 this should be the minimal
06:48:47 <Gurkenglas> And the error?
06:51:28 <Guest8902> woops, right. http://lpaste.net/171702
06:52:48 * hackagebot hasql-cursor-transaction 0.5 - An abstraction for simultaneous fetching from multiple PostgreSQL cursors  https://hackage.haskell.org/package/hasql-cursor-transaction-0.5 (NikitaVolkov)
06:53:21 <Gurkenglas> Oh right. if stmtSeq is Parser [Kernel], then body <- stmtSeq will treat body as [Kernel] in the remainder of the do block and you just want let res = last body
06:54:21 <Gurkenglas> (Also you should be able to do "Just (instructions, res) <- unsnoc <$> stmtSeq")
06:56:31 <Gurkenglas> There should be a language extension that automatically enables all language extensions you're implicitly using
06:57:00 <Guest8902> aah, I see! Yes, that works. Didn't know about unsnoc. Thanks a lot.
06:57:34 <Guest8902> not sure about the latter though. It's a custom DSL
07:01:48 <Gurkenglas> Oh that last line wasnt to you
07:02:01 <Gurkenglas> Its just a general nagging to the public that I do sometimes.
07:02:11 <Gurkenglas> ircbrowse Gurkenglas should
07:06:27 * hexagoxel is implicity using UnsafeCoerceEverything all the time
07:06:50 <carter> Hex hexagoxel really unsafe ptr equality may help you
07:07:48 * hackagebot hasql-cursor-transaction 0.5.0.1 - An abstraction for simultaneous fetching from multiple PostgreSQL cursors  https://hackage.haskell.org/package/hasql-cursor-transaction-0.5.0.1 (NikitaVolkov)
07:07:58 * hexagoxel was just trying to poke fun at Gurkenglas
07:12:48 * hackagebot hasql-cursor-query 0.4 - A declarative abstraction over PostgreSQL Cursor  https://hackage.haskell.org/package/hasql-cursor-query-0.4 (NikitaVolkov)
07:16:20 <Gurkenglas> (Also imports everything that's out of scope. If thats ambigious, use the import list that compiles.)
07:21:27 <hexagoxel> Gurkenglas: i had an auto-generate script to import everything of most deps fully qualified. the heavy downside was that it really slows ghc down when there are 1000 import statements in every module.
07:23:26 <c_wraith> It would be rather nice to be able to re-export modules qualified.
07:24:10 <c_wraith> Then projects could just have a common imports module.
07:31:19 <nitrix> c_wraith: How would you solve the colliding names? By keeping the qualified prefix in the re-export?
07:31:35 <c_wraith> yes.  That's the whole point of what I meant. :)
07:31:36 <nitrix> Then what happens when you have re-exports of re-exports? 
07:31:44 <c_wraith> don't do that. :P
07:32:04 <nitrix> Common.LBS.empty
07:32:13 <nitrix> That strikes me as wrong.
07:32:22 <c_wraith> well then, don't import your common imports qualified.
07:32:27 <c_wraith> Then it's just LBS.empty
07:32:44 <Gurkenglas> hexagoxel, right, make the script import only that which you're using
07:32:47 <nitrix> c_wraith: Well that's just Data.ByteString.Lazy.empty then.
07:33:35 <c_wraith> nitrix: I think you must be interpreting what I'm saying as something entirely different than what I mean.  But I am out of time to explain...
07:35:47 <nitrix> Ultimately, with your method, you'll have to use its common qualified name in your current module.
07:36:30 <nitrix> In the current form, it's nice to avoid qualification in certain modules that aren't very complex.
07:41:26 <nitrix> My point is  import qualified Common as C  then C.F.G.H.x doesn't make usage simpler than what could just be import qualified Foo as H  H.x
07:41:44 <nitrix> If it's available to people, I'm sure it'll happen :/
07:57:50 * hackagebot path 0.5.9 - Support for well-typed paths  https://hackage.haskell.org/package/path-0.5.9 (ChrisDone)
08:09:52 <Gurkenglas> http://lpaste.net/6387338512068247552 <- I can't use one or both or the other of Control.Monad.Trans.State and Control.Monad.State.Class?
08:10:53 <qaw> hey, short question, what is the difference between map and fmap?
08:11:10 <jeltsch> qaw: map is fmap specialized to lists.
08:11:12 <Gurkenglas> map is specialized to lists, fmap also works on Maybe etc
08:11:30 <jeltsch> You could forget about map and always use fmap, because it is more general.
08:11:30 <qaw> oh, okay for functors right
08:11:34 <jeltsch> Yes.
08:11:50 <jeltsch> The existence of two functions (map and fmap) is probably a historical accident.
08:11:57 <qaw> thanks, just want to clear it out, why we have map when we have fmap
08:12:00 <Gurkenglas> (Oh and can I disable that warning?)
08:12:49 <jeltsch> qaw: I think that in ancient times, compilers could not specialize polymorphic functions like fmap to specific types, which made generated code less efficient.
08:12:50 * hackagebot order-maintenance 0.1.1.1 - Algorithms for the order maintenance problem with a safe  interface  https://hackage.haskell.org/package/order-maintenance-0.1.1.1 (WolfgangJeltsch)
08:12:59 <jeltsch> qaw: This is probably why we have map.
08:13:44 <tdammers> I just stumbled upon GHC's rewrite pragma myself
08:13:51 <dfeuer> Is there a Haskell infrastructure mailing list? The #haskell-infrastructure channel doesn't seem to be active at the moment.
08:13:54 <kadoban> I always heard that it was for pedagogical reasons
08:14:38 <dfeuer> qaw, qaw, qaw! The seagull.
08:16:50 <dfeuer> Ping phadej 
08:17:26 <phadej> dfeuer: sorry for stealing all the CI time :(
08:17:35 <Gurkenglas> Your meanyness is meaningless! For qaw is gone.
08:17:42 <dfeuer> phadej, could you at least try to cancel your builds when you see them going south?
08:18:37 <Welkin> seagulls don't make that noise
08:18:40 <Welkin> crows and ravens do
08:19:04 <dfeuer> Gurkenglas, I wasn't being mean.
08:19:41 <sm> Welkin: go on then, how do you spell seagull calls
08:20:13 <Gurkenglas> What lens combinator would turn traverse into traverse_?
08:20:20 <jstimpfle> is there a Data.map equivalent that accepts a custom (dynamic) compare function instead of a (static) Ord instance?
08:20:24 <tdammers> sm: depending on their mood, either "eeeeee", "EEEEEEE", or "E'E'E'E'E'"
08:20:35 <Welkin> seagulls screech
08:21:02 <Jello_Raptor> what is that extension that allows you to implement `Array ()` as `Int` while leaving `Array String` alone? I'm trying to page in some of the stuff I was playing with earlier. 
08:21:16 <kadoban> jstimpfle: It wouldn't usually be a good idea if there was. It'd have to rebuild the entire structure every time the comparison function changes.
08:21:40 <jstimpfle> kadoban, of course it doesnt
08:21:46 <sm> heh, I'm not entirely satisfied with that but we should take it to #haskell-birds
08:22:08 <tdammers> word
08:22:15 <Gurkenglas> Actually the question should be: What'll turn a Traversal' s a into a Traversal s () a ()?
08:22:21 <kadoban> jstimpfle: How else would it operate? Unless you have some fairly strict guarantees about how the possible comparison functions operate ...
08:22:28 <jeltsch> jstimpfle: Still, it would not be a good idea. What would happen if you try to compare two maps that use a different comparison function?
08:23:00 <jeltsch> jstimpfle: The type system could not make sure that you only compare maps with the same comparison function, since this would require dependent types.
08:23:08 <jstimpfle> jeltsch, wouldn't want to compare two maps. Just need a Map k v where k is a "dynamic" type
08:23:26 <jstimpfle> which means i need a dynamic comparison function
08:24:17 <kadoban> jstimpfle: You're familiar with the underlying data structures involved I suppose? How would it even work at the lowest level, without reindexing for every new function?
08:25:17 <jstimpfle> kadoban, I would not intend to change the comparison function of a map. By "dynamic" I mean that it's not fixed at compile time.
08:25:19 <lyxia> Jello_Raptor: type families
08:25:26 <Jello_Raptor> lyxia: thanks :)
08:26:10 <kadoban> jstimpfle: Oh. Then you should be able to do that just with a custom type for k, that includes something specifying what comparison function it's using, I think?
08:26:40 <jstimpfle> kadoban, have thought about that, but I'd rather not like to do that
08:26:53 <jstimpfle> for one, it takes space in every key value
08:27:16 <jstimpfle> the other thing is that it's semantically odd. Think java's a.equals(b) vs b.equals(a)
08:27:44 <kadoban> Yeah it would be semantically pretty weird.
08:28:21 <infandum> I'm a bit confused about pipe processing: What if I wanted the first line of a pipe (from stdinLn for instance) to return a number, then pass that number to the rest of the lines (say add that number to the end of the line) while keeping the first line untouched? 
08:28:36 <infandum> I was thinking along the lines of "take", but that discards the other lines...
08:28:56 <dfeuer> Bah! I need to fix <$ for IntMap too.
08:29:13 <kadoban> jstimpfle: I don't know of one, but it'd be kind of neat to have one. But the data structure itself should avoid having an Ord instance and such, which is a bit annoying.
08:29:28 <kadoban> Not that anyone ever uses those instances anyway I guess, heh.
08:31:33 <Gurkenglas> Is there a "Traversable t => (a -> Bool) -> t a -> Traversal' (t a) a"? (As opposed to the improper "Traversable t => (a -> Bool) -> Traversal' (t a) a")
08:32:04 <jstimpfle> In C++, I think there is no theoretical distinction between these static and dynamic versions. The compiler just looks if the comparison is fixed at compile time and thus an opportunity for optimization.
08:32:23 <Gurkenglas> Actually I guess you could even say "Traversable t => (a -> Bool) -> t a -> Traversal' (t b) b"
08:33:19 <jstimpfle> infandum, I think you have to make more clear what you mean by "pipe processing". The pipes library or some paradigm? Or just a Unix pipe?
08:33:33 <infandum> jstimpfle: Sorry, the pipes library
08:33:49 <Gurkenglas> (It would run the filter function on the second one and remember which ones returned True to traverse of those each time the resulting traversal is used)
08:33:56 <Gurkenglas> *on the second argument
08:33:57 <dmwit> jstimpfle: Proposal: `data KMap v where KMap :: Map k v`, then use `Map TypeRep (KMap v)` and `unsafeCoerce`.
08:34:21 <dmwit> jstimpfle: Alternate proposal: rethink your approach. Dynamic types should not be needed.
08:34:35 <dmwit> jstimpfle: Folks in this channel will be glad to help with API design if you describe enough that it's possible to help.
08:34:56 <kadoban> jstimpfle: I'm not sure it's really a theoretical distinction, it's just ... how Ord works ... and I guess to some extent how typeclasses work. Which ... yeah I guess is kind of theoretical.
08:35:42 <jstimpfle> dmwit, Dynamic types definitely are needed. Yeah I'm thinking about creating a gist or something.
08:35:43 <phadej> Gurkenglas: sorry, you want a `(a -> Bool) -> Traversal' b a -> Traversal' b a` such that result consider only elements satisfying the predicate?
08:35:58 <phadej> *resulting traversal
08:37:21 <jstimpfle> dmwit, it's just that I can't know the type at compile time (it's conceptually a database tuple, represented as a list)
08:38:06 <dmwit> "can't" is an awfully strong claim.
08:38:18 <jstimpfle> dmwit, and even the possible types of the members of each tuple aren't fixed
08:38:24 <Gurkenglas> http://lpaste.net/8849581389566181376 huh? is this that thing with "you cant store traversals"?
08:38:53 <jstimpfle> which means the comparison function has to be inferred at runtime
08:39:41 <Gurkenglas> phadej, I want the result to consider elements in those places which contained satisfying elements on the example data
08:40:17 <jstimpfle> dmwit, "can't" is just an observation. For instance, a database server can't statically know the schema of the tables that users enter at runtime.
08:41:09 <tdammers> doesn't mean you have to go full-on dynamic
08:41:50 <dmwit> jstimpfle: Your conception of "statically know" is more limited than it should be, I think. =)
08:42:46 <dmwit> Or, to say it another way: in Haskell, one need not statically know all the types to have a perfectly well-typed and type-erasable program.
08:43:01 <phadej> > [1..10 :: Int] & traverse . prism' id (\x -> if even x then Just x else Nothing) %~ (*2)
08:43:03 <lambdabot>  [1,4,3,8,5,12,7,16,9,20]
08:43:14 <phadej> Gurkenglas: I'm not sure if I break some laws there
08:43:15 <dmwit> GADTs and polymorphic recursion are heavy hammers.
08:43:29 <phadej> or if there's name for that prism' stuff
08:44:05 <c_wraith> that prism seems valid. 
08:44:08 <dmwit> jstimpfle: N.B. I am carefully not making a recommendation here. But I think you are factually incorrect about what is possible.
08:44:33 <phadej> Gurkenglas: https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Fold.html#v:filtered
08:44:51 <phadej> > [1..10 :: Int] & traverse . filtered even  %~ (*2)
08:44:53 <lambdabot>  [1,4,3,8,5,12,7,16,9,20]
08:45:21 <phadej> indeed there are notes, that one might break laws with different predicates
08:45:30 <Gurkenglas> I want this: "foo even [2,2,6,5,4] %~ (*2) $ [1,1,1,1,1] = [2,2,2,1,2]"
08:46:00 <jstimpfle> dmwit, it's always possible to bend the requirements. All I was saying is that I can't know at compile time what users enter at runtime. But you might want to categorize these inputs (at runtime)
08:46:21 <Gurkenglas> foo would produce Traversals that are always lawful.
08:46:21 <c_wraith> Gurkenglas, I think you might be best off zipping the lists at the start. 
08:46:39 <Gurkenglas> I dont have the second list yet when I produce the traversal
08:47:31 <Welkin> lawful good?
08:47:38 <dmwit> jstimpfle: I can't know what program you will type into GHC. But that doesn't mean GHC should use a dynamic type to represent its AST.
08:47:45 <Welkin> I can't wait to play D&D
08:47:50 <phadej> Gurkenglas: ah, you want traversal based on some list to give you indexes to traverse second list?
08:47:54 <Gurkenglas> ya
08:48:05 <phadej> why didn't you told right at the beginning :)
08:48:14 <Gurkenglas> The type I said did!
08:48:33 <c_wraith> what do you want to do if the input list has fewer targets than the second list? 
08:49:10 <Gurkenglas> (actual usecase: when the user clicks on a rectangle, save which one, even if they change positions later. up to now i save it as an int, but i have the feeling if I transform that into a traversal and then some more transformations later, i can get rid of the whole record type that is currently containing the int)
08:49:22 <dmwit> jstimpfle: Now, you may complain: "The type GHC uses for expressions does not include the type of the value the expression evaluates to." and I will rebut: "Nevertheless, one could design an AST type and a parser which would accommodate that need, WITHOUT dynamic types.".
08:49:41 <c_wraith> Gurkenglas, might you want the lens based zippers instead? 
08:49:42 <Gurkenglas> it doesnt, but those places wouldn't be hit, just as ix 10 does on [1,2,3]
08:50:13 <Gurkenglas> Those assume unchanging data and local access
08:50:29 <jstimpfle> dmwit, would one want? =)
08:50:46 <dmwit> jstimpfle: I am carefully not making a recommendation, because the details of your use are so sparse on the ground at the moment.
08:50:52 <phadej> Gurkenglas: there is `indices`, so you can make that work
08:51:11 <phadej> but I have no idea how easily, or if there's something for that use case already
08:51:19 <glguy> One is likely to want because it's necessary to know the types of data that are possible to know the types of data that one might process
08:51:29 <glguy> and to then process the data
08:51:52 <c_wraith> I'd just write the traversal directly. it's surprisingly easy. 
08:52:57 <phadej> c_wraith: lens is such rich vocabulary, that it's sometimes fun to just try to find the right "words" :)
08:54:12 <phadej> but in this case, if one would like to traverse both lists only once, one probably need to write that traversal by hand
08:54:39 <c_wraith> yeah, but sometimes you wander off into the forest and get lost, when you could have just walked around it pretty quickly anyway. 
08:55:13 <orion> When building a pure Monad transformer, is it usually a good idea or a bad idea to make the base Monad be MonadThrow m => m?
08:55:47 <barrucadu> Depends on whether you want to throw or not
08:55:48 <phadej> Gurkenglas: your type lies abit, you'd like to have `Traversable t => (a -> Bool) -> t a -> Traversal s b`
08:56:02 <phadej> and i forgot primes
08:56:36 <Gurkenglas> What's s?
08:57:04 <c_wraith> should be t, I think. 
08:57:12 <orion> barrucadu: I want to be able to abort the computation if I deem necessary.
08:57:16 <c_wraith> and the b should be a
08:57:22 <x1f577> using conduit, how can i simulate unix's tee command? I have a bytestring source and need to write the bytes to both a file and to a database after further processing of the bytes.
08:57:50 <Gurkenglas> c_wraith, I think you mean the s should be (t a)
08:57:54 <Gurkenglas> but the b should indeed be b
08:58:23 <c_wraith> well, it can't change types. 
08:58:27 <Gurkenglas> (and in that case the s should be t b)
08:58:38 <Gurkenglas> Why not? Only the slots are interesting, not the elements
08:58:45 <Gurkenglas> phadej, [17:32] <Gurkenglas> Actually I guess you could even say "Traversable t => (a -> Bool) -> t a -> Traversal' (t b) b"
08:58:54 <c_wraith> because the slots it doesn't target won't change types. 
08:59:03 <c_wraith> therefore, none can. 
08:59:23 <Gurkenglas> Why not? Someone might run fmap (bar :: a -> b) on it and then use the traversal again
08:59:52 <c_wraith> that's not changing types in the traversal. 
09:00:08 <Gurkenglas> Neither is Traversal' (t b) b
09:00:09 <c_wraith> ah, but I see what you mean. Yeah, a second type variable. 
09:01:27 <c_wraith> this is pretty easy with []. I'm not sure about arbitrary Traversable instances. 
09:01:37 <Gurkenglas> How do I turn Traversal' s a into Traversal s () a ()?
09:02:22 <c_wraith> i think only by making s and a () 
09:02:27 <Gurkenglas> (Traversal s t a b as the argument, I guess)
09:02:59 <c_wraith> since type Traversal' s a = Traversal s s a a
09:03:55 <Gurkenglas> Oh I think I asked that wrong. "How do I turn _a_ Traversal s t a b into _a_ Traversal s () a ()?"
09:07:42 <x1f577> what would be the best way to write a bytestring to a remote sftp server? 
09:09:12 <glguy> Gurkenglas: The answer is probably "no".
09:09:42 <phadej> Gurkenglas: https://gist.github.com/phadej/d8a45605c573511ec30cafb0145dc9fe
09:11:35 <phadej> I don't like that (as one cannot use infinite list to make traversal), but it's best I can come now with
09:12:26 <dfeuer> Ping Cale.
09:12:34 <Cale> hello!
09:13:05 <phadej> most likely one could fold over second list creating a trie for index lookup lazily
09:13:15 <dfeuer> Cale, are you okay with  restrictKeys, withoutKeys :: Ord k => Map k a -> Set k -> Map k a ?
09:13:32 <Cale> Sure
09:14:07 <dfeuer> Cool.
09:14:08 <Cale> Though, I thought it was prettier to produce an endomorphism of Map k a
09:14:16 <dfeuer> :/
09:14:18 <Cale> But I don't really care
09:14:53 <Cale> I guess there might be cases where you have one Map and want to make many restrictions of it
09:14:58 <Cale> In which case, this way is better
09:15:20 <dfeuer> Paterson thought this way more consistent with the argument orders of other things.
09:18:30 <lyxia> Gurkenglas: traverseOf_  ?
09:19:43 <Gurkenglas> Yes! Thank you!
09:21:15 <jstimpfle> dmwit, I created an example at https://gist.github.com/jstimpfle/7a3112459de43d005f317d74c7873f86. Not sure if it helps
09:28:40 <theelous3> __Myst__, 
09:28:42 <theelous3> :D
09:33:13 <__Myst__> theelous3: :D
09:35:05 <Gurkenglas> :t join $ gets $ traverseOf_ (undefined :: Traversal' S a) (undefined :: a -> StateT S m ()) -- Is there a lens-operator-y way to write this?
09:35:06 <lambdabot> Monad m => StateT S m ()
09:38:34 <jmnk> join #haskell-begginer
09:39:40 <Cale> jmnk: There is a channel called #haskell-beginners, however, don't be mislead by the name, beginners and beginner questions are also welcome in this channel.
09:40:11 <jmnk> Cale Thanks for informing. :)
09:42:45 <Jake__> I'm trying to convert a project that uses gtk to Stack. I'm using OS X. I can get it to work if I add `--flag gtk:have-quartz-gtk`, is there a way to add this flag in stack.yaml only when on OS X?
09:47:06 <minib00m> hey guys, i'm learning basics of type families in haskell
09:47:16 <minib00m> and i want to put some constraint on one type family
09:47:23 <minib00m> like in this short snippet: http://lpaste.net/171750
09:47:52 <minib00m> any idea why it doesn't parse? i got parse error on input '=>'
09:47:53 * hackagebot incremental-computing 0.0.1.0 - Incremental computing  https://hackage.haskell.org/package/incremental-computing-0.0.1.0 (WolfgangJeltsch)
09:49:22 <crough> honestly I didn't know you could do that-- thought you had to use classes with associated types for that
09:50:16 <hpc> yeah, i think if it parsed you'd just get ghc expecting Constraint but getting Bool
09:50:36 <minib00m> crough: i'm learning about singletons, but it's getting quite hard 
09:51:00 <crough> Haskell isn't a great language for dependent typing like this honestly :/
09:51:13 <EvanR> i dont understand the :: Bool in the definition of type family :<
09:51:34 <minib00m> EvanR: https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/type-families.html
09:51:34 <crough> It's the kind of the resulting type-- you need datakinds for that
09:51:47 <minib00m> it's like there, but :: * or other type is just Bool :D 
09:52:07 <EvanR> oh, by default you send types to types, but with datainds you can restrict it to send to the kind Bool
09:52:12 <crough> yeah
09:52:18 <crough> so the only results are 'True or 'False there
09:52:57 <hpc> oh, still won't help with the parse error, but the constraint can be ((b :< a) ~ True)
09:53:00 * EvanR waits to see if constraints here also make sense
09:55:05 <hpc> it's entirely possible you just can't put class constraints on a type family
09:55:38 <EvanR> when you have constraints, then it has to find a dictionary for a type
09:55:46 <EvanR> but can kinds have instances?
09:56:21 <shapr> What is the sound of one Kind clapping?
09:56:43 <crough> (k :: *) -> k -> Void, I think
09:57:01 <shapr> crough: dang :-/
09:57:30 <EvanR> maybe you can define a type class on kinds
09:57:36 <EvanR> k -> Constraint
10:02:20 <hpc> class (a :: Nat) :< (b :: Nat)
10:02:23 <hpc> instance n :< 0
10:02:37 <hpc> instance Zero :< Succ n
10:02:52 <hpc> instance (m :< n) => Succ m :< Succ n
10:02:56 <hpc> ?
10:03:32 <hpc> erp, s/0/Zero
10:03:44 <hpc> don't remember if ghc has type-level numeric literals yet
10:04:06 <alercah> it does with PolyKinds
10:06:02 <dfeuer> Hmmm...  Data.IntSet.intersection claims to be O(n+m). I'm wondering if it's really O(min(m,n)). Any guesses?
10:06:37 <mvr_> is the LiberalTypeSynonyms extension considered evil?
10:07:07 <dolio> hpc: Your last case is backwards.
10:07:09 <dfeuer> mvr_, eh.... I dunno about evil, but it doesn't usually accomplish much and I can't see it ever going into the standard.
10:07:40 <dolio> Oh wait, no it isn't.
10:07:46 <dolio> I was thinking it was a family.
10:08:13 <hpc> dfeuer: i think it's right
10:08:20 <dfeuer> hpc, why do you think so?
10:08:27 <hpc> dfeuer: looking at the data definition for IntSet, i can't think of how to do it in min(m,n)
10:08:50 <hpc> oh wait, intersection, not (\\)
10:08:57 <dfeuer> Right.
10:09:11 * hpc goes back to thinking :P
10:10:14 <alercah> if I am writing a conduit-based interface to X
10:10:20 <alercah> should it be conduit-X or X-conduit?
10:10:21 <dfeuer> hpc, it smells like the shorter tests and the intersection1/intersection2 shortcuts should take care of that sort of thing.
10:10:40 <dfeuer> But I don't really know for sure.
10:11:09 <hpc> yeah, because they're both ordered containers
10:11:21 <hpc> and you're just traversing them both at the same time
10:11:58 <hpc> i guess big O is worst-case though so it's possible to construct scenarios where it is n+m
10:12:08 <hpc> like if the first set is sparse and has a very large final element
10:12:17 <dfeuer> hpc, well, that or the documentation is wrong?
10:12:22 <hpc> and the second set is large with a small last element
10:12:27 <dfeuer> Ah.
10:12:37 <dfeuer> So you think maybe it's something more complicated?
10:12:53 <hpc> maybe
10:12:54 <niteria> does anyone know who's maintaining mueval or how to reach Adam Bergmark?
10:12:59 <dfeuer> With a min(max (m,log n), max (n, log m)) or something?
10:13:33 <hpc> i think someone else would have to look more deeply at it maybe?
10:13:38 <hpc> i am not a bad enough dude when it comes to big O
10:14:04 <hpc> and this seems to be one of those cases where you would come up with a family of examples that are really hard, or something
10:14:09 <glguy> niteria: I think you just pinged him
10:14:22 <hpc> of course since it's IntSet, all operations are O(1) anyway
10:14:25 <niteria> glguy: oh hello :)
10:14:27 <mvr_> dfeuer: dang, I was hoping it would let me get away with partially applying type synonyms to save some typing, but it doesn't in my situation
10:14:36 <hpc> IntSet has a finite domain
10:14:44 <hpc> ;)
10:14:48 <niteria> glguy: are you Adam or/and the maintainer?
10:15:03 <glguy> niteria: Neither, I just think you pinged him, his irc name appears to be his last name
10:15:27 <niteria> I see
10:15:36 <niteria> I was happy for a moment there
10:15:50 <glguy> I'm glad I could give you that moment of happiness
10:16:09 <niteria> bergmark: ping?
10:17:54 * hackagebot cmark-sections 0.1.0.0 - Represent cmark-parsed Markdown as a tree of sections  https://hackage.haskell.org/package/cmark-sections-0.1.0.0 (Artyom)
10:19:08 <__Myst__> Is there much difference between (!!) and lookup in terms of speed?
10:19:10 <__Myst__> Rather, efficiency
10:19:39 <__Myst__> Also, should I use chr & ord or toEnum & fromEnum
10:20:22 <glguy> __Myst__: You can use chr/ord when you're specifically dealing with Chars and toEnum/fromEnum when doing something more general
10:20:51 <__Myst__> glguy: I was implying with Chars
10:21:22 <nek0> __Myst__: lookup should be preferred over (!!) because of out of bounds errors resulting in crashes.
10:21:40 <phadej> __Myst__: define "much", obviously (!!) is faster, but only if you know that it's safe. I.e. lookup is faster then manual bound check and !!
10:21:51 <glguy> well, not crashes, but exceptions
10:21:56 <__Myst__> Well I'm only looking up keys I know exist
10:22:00 <__Myst__> Because the dict is prepopulated
10:22:27 <phadej> still, I don't think !! is much faster, it has still to traverse the same Map
10:22:31 <phadej> if you are talking about a map
10:23:14 <phadej> it's less annoying as you don't need to unwrap Maybe, otoh it's more explicit... hardly any performance differences
10:26:29 <__Myst__> Isn't !! O(1)?
10:27:07 <kadoban> __Myst__: Are you talking about lists? No, it's not O(1).
10:27:46 <kadoban> If you're using a list, with keys you know beforehand and expecting O(1) lookup, it sounds a lot like you're doing it wrong. There are other data structures.
10:28:55 <geekosaur> __Myst__, lists are linked lists. You may be looking for Vector. Or Map, or HashMap
10:29:21 <__Myst__> geekosaur: If I want arbitrary keyage, what data structure should I use?
10:29:30 <__Myst__> RIght now I'm just using a [(Key, Value)] list with `lookup`
10:30:09 <geekosaur> that would be Map or HashMap (the former requires an Ord instance, the latter a Hashable; which is better depends on exactly what you're using as keys)
10:30:13 <minib00m> __Myst__: check Data.Map for example
10:30:30 <__Myst__> geekosaur: Chars to Strings
10:35:40 <EvanR> even metter, IntMap String where the key is ord of the char
10:35:46 <EvanR> even better*
10:37:50 <Welkin> > ord 草
10:37:52 <lambdabot>  Not in scope: ‘草’
10:37:58 <Welkin> > ord '草'
10:38:00 <lambdabot>  33609
10:40:34 <minib00m> > ord 'ą'
10:40:36 <lambdabot>  261
10:40:40 <minib00m> cool!
10:47:02 <amf_> is the value MVar in a ReaderT still changeable? and will persist on the next runReaderT? (still grasping monad transfers and how they play out)
10:47:23 <hpc> MVars are mutable
10:47:46 <hpc> the value they reference changes, but they stay the same
10:48:40 <kttr> I can’t seem to wrap my head around what this function does
10:48:41 <kttr> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]
10:48:58 <hpc> what's zipWith'?
10:48:58 <kttr> I understand what zipWith’ does, but there’s way too many layers here
10:49:07 <kttr> zipWith’ = zipWith sorry
10:49:16 <hpc> ah
10:49:31 <hpc> :t zipWith (*)
10:49:32 <lambdabot> Num c => [c] -> [c] -> [c]
10:50:02 <kttr> ok
10:50:14 <kttr> it takes two lists and muliplies them
10:50:17 <hpc> are you familiar with nested applications of map on lists?
10:50:21 <kttr> not yet no
10:50:25 <kttr> should i learn that first
10:50:52 <hpc> i was just going to say they're basically the same thing, hoping that would be easier than explaining ;)
10:51:19 <hpc> so, zipWith f list1 list2
10:51:38 <Welkin> > (map . map (+1)) [Just 5, Just 2, Nothing]
10:51:39 <hpc> applies f pairwise to the elements of list1 and list2
10:51:39 <lambdabot>      Couldn't match type ‘[Maybe a0]’ with ‘a -> b’
10:51:39 <lambdabot>      Expected type: [Maybe a0] -> a -> b
10:51:39 <lambdabot>        Actual type: [Maybe a0] -> [Maybe a0]
10:51:43 <Welkin> oops
10:51:58 <kttr> :hpc right
10:51:59 <hpc> when you have lists of lists of numbers like that
10:52:09 <hpc> you have lists of (lists of numbers)
10:52:14 <Welkin> > (fmap . fmap) (+1) [Just 5, Just 2, Nothing]
10:52:16 <lambdabot>  [Just 6,Just 3,Nothing]
10:52:21 <kttr> OHHH I GET IT
10:52:28 <hpc> so the function you zip them with takes lists and produces a list
10:52:39 <hpc> that inner zipWith is what you're doing to the lists inside the big lists
10:52:45 <kttr> right, i see that now
10:52:49 <hpc> :D
10:52:54 <kttr> thanks
10:53:47 <ExcaliburZero> A slightly nicer way to look at the expression is
10:53:48 <ExcaliburZero> :t (zipWith . zipWith) (*)
10:53:49 <lambdabot> Num c => [[c]] -> [[c]] -> [[c]]
10:54:22 <minib00m> guys, any idea why this type instance http://lpaste.net/171778 needs UndecidableInstances to typecheck?
10:54:46 <minib00m> im getting error in last line
10:55:29 <minib00m> as i see, first argument is always decreasing, second is increasing, so this will terminate, why typechecker says it could not?
10:55:44 <hpc> it might not like that the second argument is increasing?
10:56:38 <minib00m> you are right
10:56:58 <minib00m> when i replace Succ m with just m
10:57:02 <minib00m> it works fine
10:57:04 <fishythefish> fwiw, I'd normally expect Succ n :+: m = Succ (n :+: m)
10:57:19 <the_2nd> Is there some sort of conditioned fmap? I have e.g. objects within a kdTree. each function which does not change the objects positions can just be applied to the objects, while functions changing their position must rebuild the tree
10:57:43 <minib00m> fishythefish: that did the trick
10:57:43 <buglebudabey> would a type class be appropriate here on line 15 so that people could create their own data type to classify text? http://lpaste.net/171780
10:57:55 <minib00m> that's smart, thank you!
10:58:09 <fishythefish> minib00m: no problem :)
11:07:56 * hackagebot hoodle-types 0.4 - Data types for programs for hoodle file format  https://hackage.haskell.org/package/hoodle-types-0.4 (IanWooKim)
11:07:58 * hackagebot hoodle-parser 0.4 - Hoodle file parser  https://hackage.haskell.org/package/hoodle-parser-0.4 (IanWooKim)
11:08:00 * hackagebot hoodle-builder 0.4 - text builder for hoodle file format  https://hackage.haskell.org/package/hoodle-builder-0.4 (IanWooKim)
11:08:02 * hackagebot hoodle-render 0.6 - Hoodle file renderer  https://hackage.haskell.org/package/hoodle-render-0.6 (IanWooKim)
11:12:56 * hackagebot hoodle-core 0.16 - Core library for hoodle  https://hackage.haskell.org/package/hoodle-core-0.16 (IanWooKim)
11:12:58 * hackagebot hoodle 0.5 - Executable for hoodle  https://hackage.haskell.org/package/hoodle-0.5 (IanWooKim)
11:13:52 <buglebudabey> is there a function which automatically makes a list of data constructors given a data type
11:15:02 <kadoban> buglebudabey: If it's an instance of Enum and Bounded, [minBound .. maxBound] works. Otherwise, you likely need TH
11:15:11 <hpc> you likely want Data.Data.Data
11:15:18 <hpc> (yes that's a real thing)
11:15:22 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Data.html#t:Data
11:15:24 <ReinH>  heh
11:15:34 <ReinH> Is this just for debugging?
11:15:35 <kadoban> Not enough Data
11:16:10 <ReinH> fix ("Data."++)
11:16:26 <buglebudabey> I'm make a library where people can create their own labels for text data, and theres a function that uses a list comprehension "[nbH c ws | c <- classes]" where classes are the labels the user defines
11:16:28 <hpc> in a diabolical twist, it was actually Lore impersonating Data.Data.Data for the whole episode!
11:16:29 <buglebudabey> making*
11:16:59 <ReinH> So... let them pass in their list of labels?
11:17:13 <ReinH> Also, how many labels are needed? What if the supply is exhausted?
11:17:33 <kadoban> hpc: Nice
11:17:55 <ReinH> also if you reordered the args to nbH, that's ``map (nbH ws) classes''
11:18:00 <hpc> ah, specifically you want dataTypeConstrs :: DataType -> [Constr]
11:18:08 <ReinH> and that looks like the more natural argument order based on usage anyway
11:18:15 <buglebudabey> hpc pretty much, yeah
11:18:26 <hpc> dataTypeConstrs (dataTypeOf (undefined :: YourThing))
11:19:02 <ReinH> (things that vary more often are often better as later args so that things that vary less can be partially applied)
11:19:28 <buglebudabey> ReinH specifically this is for classifying text data for naive bayes, so i want the user to define their own classes to classify the text they are inputting into the program
11:19:44 <ReinH> Ah. Right. So why can't they just pass in their own list?
11:20:08 <ReinH> That seems better than some magic for enumerating a data type that I, as a consumer, won't undertand.
11:20:14 <buglebudabey> ReinH i just wanted the user to only have to pass in a list of text inputs and a list of corresponding classes to go with it
11:20:32 <buglebudabey> to represent data to teach the algorithm
11:20:37 <ReinH> I still don't understand what's stopping you.
11:21:21 <buglebudabey> ReinH the list of corresponding classes is not a list of all possible classifiers, it's just a list that will be zipped with the text inputs to classify them
11:21:38 <ReinH> Right, so why can't the user just pass that list in?
11:21:40 <buglebudabey> i want a list of all possibly classes because that's what the naive bayes algorithm needs
11:21:50 <ReinH> Why can't the user also pass that in?
11:22:24 <buglebudabey> they can, but i don't want them to have to. All i want them to do is define the data type and it's constructors and then my program can take care of the rest
11:22:32 <ReinH> That sounds hard to use.
11:22:54 <ReinH> What if I want my classes to be a partial enumeration of some type, e.g., String?
11:22:55 <buglebudabey> for the user? it'd be one less step, they're going to have to define that data type anyway
11:23:13 <ReinH> It's hard to use because I, as a user, won't understand what's happening, or how it will behave in any but the most trivial situations
11:23:21 <ReinH> and in those trivial situations, I can just pass in [minBound..maxBound]
11:23:44 <ReinH> Or you can accept an (Enum c, Bounded c) and do it yourself
11:23:45 <buglebudabey> so you suggest just having them pass in a list of all possible constructors?
11:24:30 <ReinH> I think you're going to a lot of extra work to do something that (a) isn't very Haskell-y and (b) provides marginal adde value that is not proportional to the extra difficulty.
11:24:35 <ReinH> s/adde/added
11:24:50 <buglebudabey> what part is not very haskell-y
11:25:08 <ReinH> asking for an enumeration of the constructors of an arbitrary type.
11:25:47 <ReinH> What happens if I pass in an unbounded type by accident?
11:25:50 <ReinH> Does the program fail to terminate?
11:25:57 <EvanR> or a function type
11:26:01 <ReinH> (a type with an unbounded number of values)
11:26:16 <EvanR> instead of arbitrary theres Generic
11:26:34 <buglebudabey> alright, fair. so how can i work around it if the naive bayes needs to know every class the user is using to classify data?
11:26:43 <ReinH> Let them pass in types.
11:26:58 <ReinH> Provide a helper for Enum, Bounded to pass in [minBound..maxBound] for them
11:27:17 <ReinH> let them pass in values, rather
11:27:49 <ReinH> Passing values to functions is Haskelly
11:27:50 <alercah> Is anyone familiar with the use of websockets in haskell around?
11:27:52 <ReinH> we're good at it
11:28:43 <buglebudabey> ReinH so how is passing in a value that is a list of dataconstructors any different?
11:28:49 <buglebudabey> or any less haskell-y
11:30:01 <ReinH> I'm pretty sure that's what I just suggested, unless we mean different things by data constructors. I'm talking about non-function type, fully applied data constructirs, i.e. values of type a for whatever a is in question
11:30:13 <ReinH> if my classifier is a Foo, I'm talking about [Foo]
11:30:52 <ReinH> if my classifier is a data Foo =  Foo String, I don't mean [String -> Foo], and in any event you can't enumerate that in finite time anyway.
11:31:26 <buglebudabey> alright, apologies for the miscommunication on my part. my program is here and i believe i am already doing what you suggest in the runBayes function's third argument, but i'd like to make sure: http://lpaste.net/171780
11:31:41 <ReinH> buglebudabey: nothing to apologize for, I just wanted to be clear.
11:34:07 <bstiles> Does anyone have experience with Brendan Hay's gogol-mail package https://hackage.haskell.org/package/gogol-gmail? I'm struggling to find any good docs on how to create a gmail draft
11:34:33 <ReinH> buglebudabey: as an aside, if you create your own data type for (Class, Probability) and give it an instance Ord that compares on the Probability, you can replace argmax with simply _class . maximum (where _class is your field accessor for the Class).
11:35:31 <ReinH> i.e., data Classified = Classified { _class :: Class, _probability :: Probabiility }; instance Ord Classified where compare = compare `on` _probability
11:35:44 <buglebudabey> ah, very nice
11:35:46 <bstiles> I can see how to create the UsersDraftsCreateResource, but am not sure how to actually send it
11:35:52 <ReinH> on is from Data.Function
11:36:04 <buglebudabey> i will definitely do that
11:36:12 <ertes> buglebudabey: doesn't the set of classes already follow from Material?
11:36:36 <ReinH> Ah, my name is probably wrong, you can pick a better one.
11:36:36 <ertes> if there are any extra classes, their probability is zero anyway
11:38:17 <buglebudabey> ertes their probability is slightly greater than zero, and they are used in the algorithm
11:38:30 <ReinH> buglebudabey: Generally you should use your own data types rather than tuples with type synonyms more. It gives you more flexibility, ability to reuse typeclasses, ability to add strictness, type safety, etc.
11:38:35 <buglebudabey> ertes you can see in the pWordGivenClass function
11:39:25 <buglebudabey> ertes also in the pClass function
11:39:41 <ReinH> e.g., your foldl wants to be a foldl', but that isn't strict enough since tuples are non-strict.
11:40:27 <buglebudabey> ReinH alright I will update those, thank you
11:40:44 <ReinH> buglebudabey: As you can see, I don't have much to offer aside from general code review. I think I've made my case :)
11:41:15 <buglebudabey> ReinH I appreciate all criticism, thank you. If anything else is on your mind i'd love to knw
11:41:38 <ReinH> (proper strictness on your data type will Just Work with Ord, so you can drop the foldl entirely)
11:42:16 <ertes> buglebudabey: i know that the math behind naive bayes is a bit hand-wavy, but any class you have never seen has to have an arbitrary probability…  you probably shouldn't conclude that a document is of a class you've never seen
11:42:44 <ReinH> buglebudabey: prefer pattern matching to checks for null on lists.
11:42:50 <ertes> "this is spam, but actually i have no idea what spam looks like"
11:42:57 <ReinH> Use Maybe to represent failure cases rather than runtime exceptions.
11:43:01 <buglebudabey> ertes good point, i'll see what i can do to change it for classes not listed in the learning data
11:43:34 <ertes> buglebudabey: you can't really do anything about that…  don't classify as something you've never seen
11:43:42 <ReinH> i.e., pClass cl [] = Nothing; pClass cl docs = Just $ ...
11:43:58 <ReinH> with pClass :: Class -> Material -> Maybe Probability
11:44:23 <ertes> buglebudabey: i'd go as far as to say: if a list of classes is given that includes classes not represented by the training data, this should be an error
11:44:47 <ivegotasthma> hello, I installed parsec from stack like so 'stack install parsec' in the global project, eg. home, but the program I'm trying to use it in can't find it. I'm compiling like so `ghc -packages parsec main.hs -o main'
11:45:41 <ReinH> ivegotasthma: if you've installed it with stack then you should use it in stack projects
11:45:42 <buglebudabey> ertes so what if the list that is passed into the third argument of runBayes is just a nub of the list of classes passed in to makeMaterial?
11:45:43 <x1f577> Does anyone here simply NOT use record types? they're always giving me headaches
11:45:43 <phadej> ivegotasthma: stack doesn't install anythng globally
11:45:57 <ReinH> e.g., managed by a cabal file and a stack.yml and built via stack build
11:45:58 <ertes> buglebudabey: then it's redundant information
11:46:03 <kadoban> ivegotasthma: You need to use stack to compile your programs, and 'stack install parsec' is not required for a library.
11:46:26 <ertes> buglebudabey: what's your goal?  to abstract over the set of classes?
11:46:28 <EvanR> x1f577: indeed... but what else is there
11:46:28 <ivegotasthma> hmm, how can I use that library with an outside ghc? Is that possible?
11:46:44 <kadoban> ivegotasthma: The simplest way is something like 'stack --package parsec main.hs' to just run it.
11:46:47 <ReinH> x1f577: That would be a shame, their value outweighs the annoyances. what sort of headaches?
11:46:52 <x1f577> EvanR: data MyRecord = MyRecord A B C D E F G H I J K L
11:47:08 <kadoban> ivegotasthma: If the version of GHC is correct, it'll just use it. Otherwise it'll ask you to let it install a different GHC automatically (in a way that won't screw up your system)
11:47:09 <EvanR> x1f577: well thats an even bigger headache without some template haskell 
11:47:18 <x1f577> EvanR: this is true.. im just venting :D
11:47:29 <buglebudabey> ertes my goal is to have the user pass in data for the algorithm to learn (text samples and their corresponding class), and then when they pass in a text sample, i want the algorithm to classify it based on the data it has
11:47:32 <ReinH> x1f577: That just has strictly less functionality than a record.
11:47:43 <ReinH> since you can still pattern match on records without record syntax.
11:47:44 <ertes> x1f577: "… how i learned to stop worrying and love the name prefixes"
11:47:49 <x1f577> ReinH: oh but its prettier
11:47:59 <ReinH> That line might be prettier.
11:48:03 <ReinH> The use sites, not so much.
11:48:19 <EvanR> even that line is going to be hell on real-named types
11:48:19 <ReinH> foo (MyRecord _ _ _ _ e _ _ _ _ _ _) is not pretty.
11:48:19 <ertes> buglebudabey: first of all, i assume that you want to have this efficient =)
11:48:25 <buglebudabey> ertes of course
11:48:45 <ertes> buglebudabey: your current design will retrain for every single document you present to it
11:48:48 <x1f577> ReinH: yeah that would suck.. though classy lenses with newtype wrappers make it a bit nicer
11:49:08 <ReinH> x1f577: Yes, classy lenses are a nice way to work with records too.
11:49:14 <EvanR> x1f577: the listing of record types fields and what type the fields are, this is specifically something that is 1) missing from all dynamic languages 2) makes using those languages horrible
11:49:14 <ivegotasthma> kadoban: the project I'm trying to build isn't a stack project, should it be? Because it's one file and I was hoping I get away without using a full project structure.
11:49:19 <ReinH> So if you're already using lenses, that's yet another reason to not avoid records.
11:49:29 <buglebudabey> ertes true
11:50:02 <kadoban> ivegotasthma: Note that nothing I said required it to be. If it's a long-running thing, usually you should do a full project setup with a stack.yaml and a .cabal file, but it's not necessary.
11:50:03 <ertes> buglebudabey: a function should be shaped such that the most frequently changing arguments are listed last, so runBayes (which i'd call 'classify') should take the training data first
11:50:16 <ReinH> ertes: lol, I mentioned that.
11:50:21 <ReinH> ertes: <3
11:50:31 <ertes> ReinH: =)
11:50:36 <EvanR> "frequency of a variable" ;)
11:50:37 <ReinH> Great minds or whatever.
11:50:38 <x1f577> I wonder if I could survive using zero records, and only classy lens accessors on newtype type params
11:50:53 <ReinH> x1f577: I mean, if you really want to. I don't see the point.
11:51:06 <kadoban> ivegotasthma: https://docs.haskellstack.org/en/stable/GUIDE/#script-interpreter is for if you want to just make a standalone script. Or what I mentioned above will work in a pinch even, it'll just warn you.
11:51:16 <shapr> buglebudabey: looks like you're writing fun code :-)
11:51:23 <buglebudabey> thank you shapr 
11:51:25 <ReinH> ivegotasthma: is it a cabal project?
11:51:28 <ertes> buglebudabey: and it should be written in the following way:  classify trainingData = f  where computedStuff = …; f sample = …
11:51:52 <Squarism> theres no "fmap" over Left's? 
11:51:54 <ivegotasthma> ReinH: it's a single file in a directory, there's also a makefile.
11:51:54 <ertes> buglebudabey: that way 'computedStuff' can be shared when you partially apply 'classify'
11:52:08 <ertes> buglebudabey: like this:  map (classify trainingData) listOfSamples
11:52:12 <ivegotasthma> kadoban: perfect, thanks
11:52:17 <ReinH> ivegotasthma: So your problem is that your build isn't repeatable. Cabal and stack are both attempts at making haskell builds more repeatable.
11:52:25 <ReinH> If you want your build to be more repeatable, I suggest trying to use them.
11:52:35 <x1f577> ertes: talk to me about your name prefixes.. 2 letters? 3 letters? something else?
11:52:45 <ReinH> Rather than trying to hack around them to do what they do for you.
11:52:56 <buglebudabey> ertes would that locally defined computedStuff be reevaluated each time the classify function is applied to a sample?
11:52:58 <ivegotasthma> ReinH: I think it's a giant overkill for what I'm doing but it might be interesting to explore the tools more.
11:53:13 <ReinH> ivegotasthma: it takes about 15 minutes to cabalize and stackify (?) a build.
11:53:24 <ertes> x1f577: something that's catchy and fun and sounds like the type name without having you spell out the full 20-character name =)
11:53:26 <ReinH> You've already spent more time than that trying to not do so.
11:53:37 <ertes> x1f577: catchy = memorable, so you don't have to look it up every time
11:53:47 <ReinH> You're being penny wise and dollar foolish.
11:53:51 <x1f577> ertes: errrrr thats nots algorithmic enough :(
11:54:02 <x1f577> not*
11:54:18 <ertes> buglebudabey: if you 'share' the application it won't be recomputed
11:54:20 <dolio> Are you allowed to talk about 'overkill' if a makefile is involved? :)
11:54:25 <ReinH> *pound foolish, localization doesn't improve that saying.
11:54:34 <ertes> buglebudabey: like this: let myClassify = classify trainingData in …
11:54:35 <ReinH> dolio: Touche
11:55:30 <ReinH> ertes: Nice catch about sharing by switching argument order, I knew there was a reason I suggested it.
11:55:41 <buglebudabey> ertes alright, thank you - i'll go back and rework this. thank you as ReinH 
11:55:43 <buglebudabey> as well*
11:55:51 <ReinH> buglebudabey: yw
11:56:11 <ertes> buglebudabey: also you need to write it exactly in this shape:  classify trainingData = … where computedStuff = …
11:56:25 <ertes> buglebudabey: don't mention the second argument right there, or you won't get sharing
11:56:56 <ertes> buglebudabey: background:  f x = (\y -> …) where …  -- note how the 'where' block applies to the result of 'f x', not the full application
11:57:53 <ertes> if you write it like this, it will be recomputed for every application of the second argument (which sometimes is what you want, but not this time):  f x y = …  where …
11:57:57 * hackagebot bond-haskell-compiler 0.1.3.1 - Bond code generator for Haskell  https://hackage.haskell.org/package/bond-haskell-compiler-0.1.3.1 (blaze)
11:58:59 <ertes> buglebudabey: as a minor note you should probably switch to HashMap…  for text keys it's almost always faster than Map
11:59:11 <ertes> (but try both just to get an idea of the difference)
11:59:11 <buglebudabey> ertes alright, i didn't know that
11:59:24 <buglebudabey> ertes any way to save what you and ReinH said to refer back to it
11:59:43 <ertes> i think #haskell is publicly logged, but i don't know where
12:00:12 <buglebudabey> alright
12:00:18 <ReinH> buglebudabey: http://ircbrowse.net/browse/haskell
12:01:03 <ReinH> buglebudabey: http://ircbrowse.net/browse/haskell?id=23125410&timestamp=1469473117#t1469473117
12:01:17 <buglebudabey> thanks
12:01:20 <ertes> buglebudabey: next, if your function takes two lists and zips them, it should better take the zipped list in the first place =)
12:01:40 <ertes> see makeMaterial
12:01:58 <tgeeky_> lambdabot is frozen, I take it?
12:02:06 <buglebudabey> ertes not sure what you mean
12:02:12 <ReinH> @type ()
12:02:13 <lambdabot> ()
12:02:15 <tgeeky_> oh
12:02:18 <tgeeky_> lambda-bot is frozen
12:02:21 <ertes> buglebudabey: f xs ys = … zip xs ys …
12:02:21 <ReinH> @botsnack
12:02:21 <lambdabot> :)
12:02:22 <tgeeky_> whoever htat is
12:02:29 <ertes> buglebudabey: better write this:  f xys = …
12:02:32 <ReinH> Something that is not lambdabot :)
12:02:50 <ertes> buglebudabey: f :: [(X, Y)] -> Z  -- rather than [X] -> [Y] -> Z
12:02:58 * hackagebot monky 2.0.0.0 - A system state collecting library and application  https://hackage.haskell.org/package/monky-2.0.0.0 (ongyerth)
12:03:02 <glguy> ertes: The log address is mentioned in the topic
12:03:17 <ertes> ah
12:03:27 <Welkin> > "hola"
12:03:29 <lambdabot>  "hola"
12:03:30 <ReinH> Then you can consider whether (X, Y) deserves reification as a data type.
12:03:31 <buglebudabey> ertes i have to zip the data together at some point, is there a benefit to writing it that way?
12:03:34 <Welkin> it's working fine
12:03:51 <ertes> buglebudabey: yes, documentation of intent and less room for errors
12:04:04 <buglebudabey> ertes alright, will do
12:04:50 <Squarism> maybe an uninterresting question, but what would you say. For an application that could result in a range (say max 20) input errors - is it work to have more than one error type?
12:04:58 <ertes> buglebudabey: currently you can pass arguments to makeMaterial that don't really make sense for it, and it arbitrarily decides to just truncate the longer list
12:05:15 <ivegotasthma> ReinH: huh, awesome, thanks
12:05:15 <Squarism> ...or a hierarchical sum type thingy
12:05:18 <ivegotasthma> kadoban: thanks for the help!
12:05:42 <kadoban> 'welcome
12:05:50 <buglebudabey> ertes ah alright
12:06:41 <greymalkin> I *really* want to use copilot for an embedded application I'm making, but can't seem to find a way to introduce messages from the network layer. Anyone have any advice on this?
12:06:55 <ReinH> Squarism: sums of sums are a thing, and give you a hierarchical error organization.
12:06:58 <Welkin> copilot?
12:07:24 <ertes> buglebudabey: as one final remark, personally i'd reduce the number of type synonyms to zero =)
12:08:02 <buglebudabey> ertes  ReinH mentioned that as well. I didn't know that was bad practice so thatll be the first thing to go
12:08:08 <ertes> buglebudabey: i know, it's easy to think that you're doing your reader a favour by documenting your types by giving them domain-specific names, but really you're just making them look up definitions =)
12:08:56 <ReinH> Also writing your own types increases type safety, lets you create instances, and populates your domain with meaningful vocabulary.
12:09:29 <ertes> the route i'd go down is:  abstract away the types
12:09:29 <ReinH> Anywhere you use a type synonym, at the least consider using a newtype.
12:09:35 <ReinH> They're free.
12:09:41 <buglebudabey> out of curiosity ReinH and ertes how much haskell years do you have in you?
12:09:46 <Squarism> ReinH, i pass them in eithers.. so id be forced to do a fair deal of converting those. Im hesitant it would lead to extra work'
12:09:56 <hpc> how many haskell years are in a dog year? ;)
12:09:59 <ReinH> heh
12:10:04 <ReinH> A half dozen?
12:10:05 <pkmx> What's the go-to library for handling character encodings in Haskell? Say decoding a `ByteString` as Big5 into `Text`?
12:10:13 <ertes> buglebudabey: i started haskell in ~2007
12:10:18 <ReinH> What year is it?
12:10:21 <EvanR> newtypes arent syntactically free
12:10:22 <buglebudabey> 2016
12:10:25 <ReinH> EvanR: shhh
12:10:33 <ReinH> Yeah, about that
12:10:43 <buglebudabey> okay i dont feel so bad now then
12:10:43 <Welkin> buglebudabey: they have 40 years of combined experience in webscale, big data, machine learning AI agile technologies with CORBA and SPA's and the TDDs
12:11:05 <buglebudabey> Welkin do you work with them, is this how you knw lol
12:11:46 <joe9> I want to show LocalTime in this format "%a %b %_d %Y %H:%M:%S" any suggestions on how I can do that, please?
12:11:53 <ertes> buglebudabey: Welkin is our channel jukebox
12:12:14 <buglebudabey> i always leave this chat at night so humbled lol
12:12:25 <Squarism> what is SPA's?
12:12:33 <sleblanc`> :t formatTime
12:12:34 <lambdabot> Not in scope: ‘formatTime’
12:12:42 <Welkin> Squarism: buzzword
12:12:51 <sleblanc`> @let import Data.Time.Format
12:12:53 <lambdabot>  .L.hs:131:1:
12:12:53 <lambdabot>      Data.Time.Format: Can't be safely imported!
12:12:53 <lambdabot>      The package (time-1.5.0.1) the module resides in isn't trusted.
12:13:05 <ertes> oh wait, that's lambdabot 
12:13:07 <ertes> @quote
12:13:07 <lambdabot> fmap says: <ivanm> right, functions <fmap> fortunately lenses subsume that use case
12:13:11 <ReinH> Welkin: and 15 years of GHC 8.0 experience.
12:13:16 <Squarism> i got that
12:13:17 <joe9> sleblanc`: but , formatTime args are different.
12:13:38 <joe9> sleblanc`: I think there should be something more between formatTime ... LocalTime
12:13:41 <pikajude> hi, i'm trying to figure out how to structure my program
12:14:07 <ReinH> I'm not sure which is worse, printf or strftime
12:14:17 <ReinH> pikajude: into files, generally. :D
12:14:18 <pikajude> i'm reading a stream of packets from a socket (using lazy bytestring's hGetContents) but I also want to be able to send messages to that thread from a different thread
12:14:23 <dedgrant> Huh. So I've been looking a bit at the general lawlessness of 'foldMap pure', and more generally looking about to see if anyone had written down some laws with respect to metamorphisms, and lo: https://web.engr.oregonstate.edu/~erwig/meta/
12:14:44 <pikajude> it's something like forever $ do { pkt <- readNextPacket; doThing pkt }
12:14:53 <ReinH> pikajude: Have you read Simon Marlow's free book on parallel and concurrent haskell?
12:14:57 <pikajude> no
12:15:22 <ReinH> You should do that. http://chimera.labs.oreilly.com/books/1230000000929
12:15:35 <ReinH> It has chapters on organizing async communication.
12:15:44 <pikajude> yes, I'm reading through the table of contents now
12:15:49 <pikajude> thanks for the tip ReinH, this will probably be helpful
12:15:53 <ReinH> Chapters written by Simon Marlow are almost guaranteed to be better than IRC :)
12:16:08 <ongy> ReinH: what's a better way to go than strftime?
12:16:11 <ertes> i call that one The Book =)
12:16:12 <ReinH> And if you get stuck you can ask us more specific questions and probably get better answers.
12:16:15 <ReinH> ertes: :)
12:16:27 <ReinH> ertes: has some competition from bitemyapp's book for that title.
12:17:06 <joe9> >localDay
12:17:10 <pikajude> Ooh, interesting
12:17:11 <ertes> ReinH: does it?  they don't sound similar
12:17:23 <ReinH> ongy: Haskell? https://hackage.haskell.org/package/formatting-6.2.2/docs/Formatting-Time.html, to the extent that it doesn't borrow from arcane strftime sigils.
12:17:29 <pikajude> I could have the main program loop instead read from a Chan and have the two threads write to that same Chan
12:17:29 <ongy> verrlara: iirc you asked if it's on hackage: https://hackage.haskell.org/package/monky-2.0.0.0
12:17:33 <ReinH> ertes: well, "The Book" isn't a very specific title.
12:17:46 <ReinH> pikajude: yeah, something like that.
12:17:49 <ertes> ReinH: ah, now i got it =)
12:17:53 <pikajude> That makes more sense
12:17:57 <ReinH> ertes: :)
12:18:08 <pikajude> heavy Chan usage in this project so far
12:18:14 <ReinH> ertes: I mean, I suppose they're both losing that competition to the bible.
12:18:35 <Welkin> I never got a chance to do anything with threads/concurrency yet in haskell
12:18:42 <ReinH> Welkin: do it, it's fun
12:18:52 <ReinH> until you start worrying about exception masking.
12:18:56 <Welkin> I started reading marlow's book a long time ago but never continued
12:19:13 <Welkin> maybe writing a game server will be an excuse to use it
12:19:23 <ReinH> That's like 90% of the value of the async package, tbf: it does masking right for its combinators.
12:19:29 <ReinH> Welkin: yeah probably
12:19:48 <ertes> Welkin: implement your favourite algorithm, parMap it over a list and start your program with these arguments: +RTS -N
12:19:54 <ReinH> single thread-of-control game servers are probably not the best plan
12:19:56 <ertes> Welkin: observe the wonder of haskell =)
12:20:12 <ReinH> Then again, dwarf fortress exists.
12:20:43 <ReinH> But as far as I can tell they've basically just greenspun their own scheduler.
12:21:09 <Welkin> thanks, I'll check out async too
12:21:55 <ongy> ReinH: I'm confused. How do I use it?
12:22:22 <ongy> I do get formatting package in general, just not how to call the time formatter
12:23:14 <joe9> https://two-wrongs.com/haskell-time-library-tutorial
12:24:35 <EvanR> joe9: https://github.com/haskellcats/time-diagram
12:24:36 <ReinH> ongy: it creates a function that you then call with the correct number of args.
12:24:48 <ReinH> Just like other formatters.
12:25:30 <ReinH> where you can pass in one of these types https://hackage.haskell.org/package/time-1.4.2/docs/Data-Time-Format.html#t:FormatTime
12:26:20 <verrlara> ongy: Thank you
12:26:22 <ongy> I failed to see the instances -.- good job me
12:26:57 <ongy> verrlara: feel free to report any problems/suggestions you have and ask questions about it. Until now it only had a userbase of 2, so it might still be a bit weird
12:28:27 <ongy> verrlara: oh and the docs failed on hackage, http://monky-hs.github.io/ is up to date
12:28:51 <ertes> ongy: you can upload the docs yourself, although the process is rather awkward
12:28:58 <Welkin> docs always seem to fail to upload on hackage...
12:29:08 <ReinH> ongy: edwardk's libraries have a script for it iirc
12:29:14 <EvanR> maybe "hackaged" will be a new verb for when docs fail
12:29:17 <ertes> yeah, i have a script, too
12:29:49 <joe9> EvanR , That is cool. Thanks.
12:29:54 <ReinH> Welkin: If you have a few dozen extra spare servers to throw at it and time to maintain them, let the infra team know. ;)
12:30:22 <ReinH> Or, you know, money to support their work.
12:30:31 <ertes> lines 16 to 41 upload docs: http://hub.darcs.net/esz/skeleton/browse/Makefile
12:30:35 <verrlara> Well keep you posted ongy 
12:31:15 <ertes> replace $(nixsh) by whatever build environment you use (nix/stack), or just type the commands directly, if you don't use any
12:31:15 <ReinH> Ideally, tools like stack and cabal would build and upload docs on publish to spread the cost out across the hackage contributor-base.
12:31:47 <ReinH> (automatically)
12:31:57 <Welkin> that seems like the most sensible solution
12:32:04 <Welkin> instead of having remote servers compile the hackage docs
12:32:25 <ongy> manual upload worked
12:32:39 <ReinH> It's a pretty silly setup to have that cost centralized and paid by a small, poorly funded team for basically no reason aside from inertia. And then people complain about docs not being built.
12:32:56 <EvanR> theres gotta be a central reason why they fail to build
12:33:07 <EvanR> and why its hard to fix
12:33:21 <EvanR> it doesnt seem likely that its just too many docs
12:33:26 <ReinH> The machines of hackage contributors can probably spare the cycles...
12:33:34 <EvanR> sure that makes sense
12:33:40 <ertes> EvanR: i'd guess because some libraries are platform-specific, but hackage doesn't abstract over the platform
12:33:58 <ertes> you don't get separate builds for different environments/platforms
12:33:59 <ReinH> EvanR: coordination at that scale is non-trivial, and a small failure rate can easily be amplified.
12:34:08 <EvanR> ertes: right so one hypothesis is that when docs fail for a real reason, maybe they keep getting retried uselessly wasting time
12:34:33 <ertes> i don't think they're retried anyway
12:34:50 <ertes> to be honest i think hackage shouldn't concern itself with building at all
12:35:08 <EvanR> yeah the question goes away if you just drop it and have cabal do it
12:35:14 <ReinH> Yep.
12:35:27 <ongy> mine right now failed on a template haskell file, because of some link error (I think C library a dependency depends on)
12:35:36 <ongy> which is reasonable
12:35:46 <EvanR> that doesnt seem reasonable
12:35:59 <EvanR> why do you have to link to a C library to get haddocks
12:36:39 <dolio> Because that's how the library was written?
12:36:51 <EvanR> but ... you dont get C docs
12:36:52 <ReinH> Because of how cabal builds documentation.
12:37:09 <ongy> on my side it's some template haskell in a file. that seems to force linking during compile and haddock
12:37:10 <EvanR> and docs dont have much to do with executing executables
12:37:16 <ertes> EvanR: if the C dependency is used from TH…
12:37:30 <ertes> haddock has to run TH stuff before it can build docs
12:37:59 <ongy> not that I know of, the template code exists longer than my package depending on the failing one
12:38:00 <ReinH> I think the failure rate on trivial doc builds is pretty low.
12:38:00 <EvanR> well i stand corrected... and flabbergasted 
12:38:02 <ertes> (observe how haddock generates docs for lenses automatically constructed via makeLenses)
12:38:31 <ReinH> EvanR: TH incurs a doc build dependency on building the project proper.
12:38:32 <EvanR> well the docs on mikmod bindings failed to build because of a linker error, but theres no TH to speak of
12:38:41 <ReinH> Because otherwise you aren't necessarily documenting everything.
12:38:46 <EvanR> unless FFI implies TH somehow
12:39:00 <ReinH> I think this is the cause for a large percentage of doc build errors on hackage, but I don't have stats.
12:39:04 <ReinH> I might be able to get them.
12:40:24 <ongy> how well is the documentation build isolated? Running random template haskell sounds dangerous to me
12:40:49 <EvanR> that also doesnt make too much sense yeah
12:40:56 <dolio> haddock also uses stuff from build artifacts that GHC generates, as I recall.
12:41:00 <ertes> monky inspired by conky by ongy
12:41:13 <dolio> So you can't build docs without compiling your files, I think.
12:41:21 <dolio> And that goes for all your .hsc files.
12:41:46 <dolio> So if compiling .hsc files requires doing C stuff, that might explain some things.
12:41:46 <EvanR> compiling files is one thing, linking the final exec...
12:41:54 <ongy> ertes: :) the names! hardest part of writing code
12:42:17 <ReinH> ongy: Well isolated.
12:42:28 <ReinH> ongy: The infra people know what they're doing.
12:44:00 <ertes> ongy: just pick a well recognised anime name – instant user base
12:44:20 <EvanR> keiyurium
12:44:55 <ongy> next time, I should reserve mahouka on hackage....
12:45:07 <dolio> EvanR: "Actually hsc2hs does not output the Haskell file directly. It creates a C program that includes the headers, gets automatically compiled and run. That program outputs the Haskell code."
12:45:18 <EvanR> ;_;
12:46:06 <EvanR> would be nice if C actually was two languages, C preprocessor and C runtime
12:47:31 <jhance__> I started compiling a very large haskell project (~3000 modules, autogen'd) and 2000 modules in something bad happened and stack/ghc got very upset. Now I can't run stack at all due to this:
12:47:41 <jhance__> Running /home/jhance/.stack/programs/x86_64-linux/ghc-8.0.1/bin/ghc --numeric-version exited with ExitFailure (-4)
12:47:52 <jhance__> It does print out 8.0.1 though
12:48:06 <alercah> try deleting it and running stack init again?
12:48:07 <Welkin> you have 3,000 module generated by TH?
12:49:02 <jhance__> Yeah, its alot of protobuffers lol
12:50:06 <ReinH> EvanR: "C runtime"?
12:50:27 <ReinH> jhance__: well, that's... impressive...
12:50:33 <ReinH> You broke GHC.
12:50:52 <ertes> "what's that empty library every program links to?"
12:51:10 <ReinH> What does /home/jhance/.stack/programs/x86_64-linux/ghc-8.0.1/bin/ghc --numeric-version say when you run it directly?
12:51:31 <EvanR> ReinH: "C is a purely functional language"
12:51:51 <jhance__> I hope reinstalling GHC won't make me rebuild 2000 modules...
12:52:00 <ReinH> It almost certainly will.
12:52:01 <prohobo> heheeheheh
12:52:17 <jhance__> welp
12:52:21 <ReinH> See you tomorrow.
12:52:26 <jhance__> then whos to say it won't break again at 2000
12:52:31 <ReinH> No one.
12:52:49 <ReinH> So probably reinstalling GHC without attempting to troubleshoot the issue isn't your best bet.
12:52:52 <ertes> jhance__: GHC has -j, which could help =)
12:53:13 <jhance__> Oh well, I have things to do for the next 2 hours anyhow
12:53:23 <dolio> Help get it to break again faster?
12:53:24 <ertes> make sure you build on a 128 core machine, and that the individual modules are independent of each other
12:53:40 <jhance__> Actually, it did resume nicely
12:53:45 <jhance__> Who knows what happens when it tries to link
12:54:04 <jhance__> Honestly, its quite tempting to spin up an AWS instance
12:54:09 <ReinH> dolio: help GHC not exit on failure and continue compiling futilely for another 1000 modules?
12:54:57 <ReinH> futilely is a much easier word to say than to read.
12:55:18 <jhance__> Its kind of promising that modules are even compiling, because they depend on lens and so the packages being depended on aren't broken by the reinstall
12:55:41 <ReinH> Ok, happy to be wrong about that one.
12:55:52 <ertes> … and after 5 hours and 40000 modules the tests failed
12:56:15 <ReinH> But at least recompilation should be ... oh you're generating everything.
12:56:15 <ongy> machine runs out of ram during link step
12:56:35 <ReinH> ongy: This was a frequent problem for my build servers, actually, back when compiling Haskell projects was literally my job.
12:56:45 <ertes> protobufs must be a delight to work with
12:57:38 <ReinH> ertes: Probably better than the equivalent JSON schema tbf.
12:57:43 <cobreadmonster> ReinH: You had a job working on haskell?
12:57:50 <ReinH> cobreadmonster: yeah
12:58:06 <ReinH> I was the ops and infra team for a haskell startup.
12:58:11 <jhance__> ertes: They are indeed a delight. Some of the code hprotoc generated was completely wrong (importing from the wrong spot)
12:58:19 <cobreadmonster> ReinH: did it grow into a real company?
12:58:26 <ReinH> No, it did what most startups do.
12:58:59 <ertes> becoming a part of google?
12:59:02 <ertes> or facebook?
12:59:11 <ReinH> It ceased to exist.
12:59:19 <ReinH> It shuffled off this mortal coil.
12:59:49 <ReinH> But it wasn't for lack of running servers, I'll tell you that. ;)
13:00:05 <ongy> and cost of servers?
13:00:15 <ReinH> Negligible.
13:11:51 <sleblanc`> Can autocompletion in GHCi sort results left-to-right instead of top-to-bottom? i.e. my shell shows results as (a b c \n d e f \n ----More----) while GHCi lists them as (a g m \n b h n \n ----More----)
13:19:21 <orion> When you're designing a Monad transformer, do you only need to include an ExceptT when you want to catch errors as opposed to when you only want to throw them?
13:20:08 <orion> To put it another way, can you leave out ExceptT and let the non-monad-transformer code do the error handling?
13:21:05 <ReinH> If you want to throw errors, you can use the MonadError or MonadThrow 
13:21:09 <ReinH> ... typeclasses
13:21:29 <ReinH> and abstract over your choice of implementing monad
13:22:05 <phadej> orion: I don't understand, you want to catch errors but you cannot throw/raise them?
13:22:12 <phadej> how's that possible?
13:23:20 <ongy> ReinH: can I not feed a TimeLocale into Formatting.Time formats?
13:23:42 <phadej> ongy: what locale you would use then?
13:23:52 <ReinH> A TimeLocale isn't a time...
13:23:56 <ReinH> Oh, I see.
13:25:12 <hpc> ongy: do you need something nicer than the RFC time formats that end in stuff like +0300?
13:25:30 <orion> phadej: I want to throw errors inside the monad but only catch them outside the monada.
13:25:33 <orion> monad*
13:25:37 <hpc> oh wait, wrong meaning of "locale"
13:25:44 <ongy> hpc: I need (more want) dayOfWeek with my ja_JP locale
13:26:14 <hpc> use FormatTime, it seems: https://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Format.html#v:formatTime
13:26:18 <ReinH> orion: a MonadThrow constraint (and the lack of a MonadCatch constraint) would ensure that, if you are willing to work with the exceptions package's opinions on error handling.
13:26:40 <phadej> orion: I don't understand what you mean by "catch them outside the monad"
13:26:48 <phadej> orion: could you sketch a code you look after?
13:26:57 <ReinH> I assume "the monad" means "a particular action".
13:27:09 <ongy> so I'm back to strftime
13:27:28 <orion> ReinH: Ah, yes that was what I meant.
13:27:34 <ReinH> ongy: you could write your own version of fmt that takes a locale. Look at the source.
13:27:36 <ReinH> http://hackage.haskell.org/package/formatting-6.2.2/docs/src/Formatting-Time.html#fmt
13:28:42 <orion> ReinH: You said, "a MonadThrow constraint ... would ensure that". Constraint on what entity?
13:28:55 <ReinH> orion: the action.
13:29:03 <hpc> ReinH: you'd have to redefine everything in that module based on the new fmt
13:29:50 <orion> ReinH: Ah. So just to confirm: I can create a Monad transformer that can throw errors without needing ExceptT, ErrorT, etc, right?
13:29:51 <ReinH> actionThatMightThrow :: MonadThrow m => m whatever
13:30:06 <ReinH> Of course then you're restricted to working with exceptions
13:30:20 <ReinH> mtl doesn't have a fine-grained enough typeclass for "MonadError that can only throw".
13:30:58 <hpc> is it even possible to have throw and not catch?
13:31:25 <hpc> (assuming no identifiers hidden by module export lists)
13:31:35 <EvanR> even if the computer explodes due to an exception it still "catches fire" :)
13:31:46 <orion> What are the negative consequences of being "restricted" to exceptions?
13:31:52 <hpc> :t maybe
13:31:54 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:32:05 <hpc> :t fromMaybe
13:32:05 <ReinH> With the MonadError machinery? I don't immediately see why not. Put throwError in one typeclass and catchError in another?
13:32:07 <lambdabot> a -> Maybe a -> a
13:32:19 <hpc> even for Maybe, you can use those as try-catch
13:32:24 <emre> Hi, I am following CIS194 and have written a Hanoi function as shown here: http://lpaste.net/4898352824619892736 Why am I getting a pattern match non-exhaustive warning in the second (commented out) case?
13:32:27 <ReinH> orion: you can't work with arbitrary error types like you can with ExceptT.
13:32:49 <hpc> try :: (a -> Maybe b) -> Maybe a -> Maybe b
13:32:56 <hpc> try = maybe Nothing
13:33:11 <hpc> er, not that
13:33:20 * hpc shuffles away in embarassment
13:33:33 <ReinH> emre: integers can be negative.
13:33:42 <ReinH> But I don't think GHC is actually checking that.
13:33:53 <ReinH> It just knows that you have guards, but can't check the exhaustivity of the guards.
13:33:58 <emre> I doubt that's the case. Then the first one would also give a warning?
13:34:09 <ReinH> In the first one, n is any non-zero integer.
13:34:18 <emre> Oh wait, yes!
13:34:20 <ReinH> In the second, GHC can't prove that your guards are exhaustive.
13:34:37 <ReinH> If you are convinced that they are (in fact, they are not), you can ignore the warning.
13:35:18 <emre> Now I modified the n == 0 guard to n <= 0, and am still getting the warning
13:35:23 <ReinH> (Or if you are convinced that the unmatched cases won't be reached, but that incurs a proof obligation on every user of the function)
13:35:27 <ReinH> GHC isn't checking the guards
13:35:40 <ReinH> It is just saying "Ok, you have guards, I can't tell if they are exhaustive, so they may not be".
13:36:01 <kadoban> emre: You should really include the actual error messages/warnings you're asking about when you can.
13:36:07 <kadoban> Just for the future.
13:36:16 <emre> kadoban: I see, thanks for the warning.
13:36:37 <ReinH> The warning is just GHC saying "I dunno, might not be exhaustive."
13:36:54 <ReinH> It happens to be right, but only by accident.
13:37:19 <ReinH> You could replace the guards with | True = ... and | False = ...
13:37:32 <ReinH> GHC will still complain.
13:38:45 <Zekka> (GHC has no feature to look at a guard and figure out what it means -- there's no solution in general to figure out if a group of boolean expressions in Haskell are exhaustive.)
13:39:16 <ReinH> Checking the guards statically is just impossible.
13:40:07 <emre> Is it correct if I claim that all guard expressions not involving 'otherwise' will lead to this warning?
13:40:18 <Zekka> I think ones involving 'otherwise' will also trigger it
13:40:29 <ReinH> Yes, and also those involving 'otherwise'.
13:40:59 <emre> I'm not getting it with http://lpaste.net/4660820732056436736
13:41:18 <Zekka> Hm, maybe there's a hardcoded special case
13:41:31 <ReinH> Ah, perhaps
13:41:31 <Zekka> :t otherwise
13:41:33 <lambdabot> Bool
13:41:36 <Zekka> @src otherwise
13:41:36 <lambdabot> otherwise = True
13:41:42 <Zekka> this is actually how `otherwise` is defined
13:41:57 <ReinH> otherwise is just True, but GHC might handle the token specially.
13:42:04 <sleblanc`> Zekka: I believe there is some internals that make GHC handle it differently
13:42:08 <ReinH> or it might handle True specially
13:42:12 <sleblanc`> what ReinH said
13:42:18 <ReinH> which would make my previous statement incorrect
13:42:24 <Zekka> It looks like there's a special case for one of those things
13:42:36 <Zekka> it would probably be more correct to handle `True` specially
13:42:43 <EvanR> handling True specially would be annoying if it refuses to reduce the expression before optimizing
13:42:49 <ReinH> So, one option is to include an otherwise guard, whether you need one or not.
13:42:49 <hpc> if ghc is feeling particularly fancy, it might be inlining otherwise and seeing that there's a case that's literal True and doing that
13:42:54 <ReinH> Another is to ignore the warning.
13:43:01 * hackagebot hoodle-publish 0.2.1 - publish hoodle files as a static web site  https://hackage.haskell.org/package/hoodle-publish-0.2.1 (IanWooKim)
13:43:03 * hackagebot hoodle-core 0.16.0 - Core library for hoodle  https://hackage.haskell.org/package/hoodle-core-0.16.0 (IanWooKim)
13:43:03 <Zekka> You shouldn't rely on a warning to demonstrate that a problem exists or doesn't exist
13:43:04 <hpc> but probably hardcoded
13:43:11 <hpc> ^
13:43:24 <hpc> understanding > non-fatal compiler output
13:43:50 <Zekka> if you're getting a warning and it's meaningless, first be sure it's meaningless and then you might as well add an `otherwise = error "Impossible case happened: not (x <= 0) and not (x > 0)"`
13:44:23 <orion> ReinH: When you say "arbitrary error types", do you mean types which do not instantiate Exception?
13:44:31 <ReinH> Zekka: by the way, for some comparables that is not an impossible case :)
13:44:48 <ReinH> orion: I think so.
13:44:57 <hpc> > (0/0) <= 0
13:44:58 <lambdabot>  False
13:45:00 <hpc> > (0/0) > 0
13:45:01 <ReinH> Zekka: e.g., Double.
13:45:02 <lambdabot>  False
13:45:13 <Zekka> ReinH: I totally believe you! I would probably also add code that attempts to show x, but I wouldn't want to add a separate Show constraint
13:45:30 <dmwit> > compare (0/0) 0
13:45:32 <lambdabot>  GT
13:45:33 <Zekka> there's not a "show if implements Show, otherwise produce a preset string" function, right?
13:45:36 <dmwit> huh
13:45:44 <dmwit> Zekka: right
13:45:48 <Zekka> Because I'm pretty sure you have to do black magic to do that, but it seems useful enough someone might have done it anyway
13:45:58 <ReinH> dmwit: compare is a lying liar. Alternatively, Ord is broken for numbers that include NaN.
13:46:12 <hpc> Ord is working fine
13:46:14 <ReinH> > 0/0
13:46:15 <hpc> IEEE is what broke
13:46:16 <lambdabot>  NaN
13:46:18 <Zekka> > (0/0) < 0
13:46:21 <lambdabot>  False
13:46:24 <Zekka> > (0/0) >= 0
13:46:26 <lambdabot>  False
13:46:42 <hpc> > (0/0) == (0/0)
13:46:44 <lambdabot>  False
13:46:45 <ReinH> hpc: Well, the Ord instance is incoherent. We can quibble about whose fault that is. ;)
13:47:58 <ReinH> I have seen this paranoid use of otherwise clauses in some codebases, fwiw, so it's not an entirely unreasonable practice.
13:48:07 <ReinH> Some people REALLY don't like warnings.
13:48:23 <dolio> They should turn off warnings, then. :)
13:48:24 <EvanR> or dont want to disable it on a module by module basis
13:48:25 <ReinH> Although people who compile with -Werror are going too far imo.
13:48:43 <ReinH> dolio: Sorry, rephrase: They really don't like code which produces warnings.
13:49:03 <hpc> ReinH: they should stop writing code then :P
13:49:12 <ReinH> hpc: No comment.
13:49:14 <hpc> :D
13:49:23 <emre> ReinH: you cannot exhaust their comments with your guards
13:49:24 <EvanR> if code would produce a warning and warnings are disabled, does anyone hear it?
13:49:40 <ReinH> EvanR: I dunno, is it compiled in a forest?
13:49:50 <sleblanc`> EvanR: as long as no one observes the code, we cannot know
13:49:59 <Zekka> I'd rather get an error saying why I thoguht the case was impossible, than an error saying "guards weren't exhaustive at runtime, moron!"
13:50:16 <Zekka> because sometimes I'll trip that and realize "oh, my expectations were totally wrong!"
13:50:25 <EvanR> "heres why you thought it was impossible" how does that even help ;)
13:50:38 <ReinH> Zekka: And indeed this is why it is not totally unreasonable: humans are sometimes wrong.
13:50:42 <EvanR> "heres why its possible"
13:50:47 <Zekka> Usually the problem model I start with is subtly d ifferent from the problem model I finished with
13:50:48 <hpc> EvanR: it gives you something to grep for at least
13:50:59 <Zekka> So by the time I finish the program I'm no longer making assumptions I started out making
13:51:14 <ReinH> If it weren't for that niggling detail...
13:51:15 <Zekka> That's when I get the most "<X> was not exhaustive" errors
13:51:31 <EvanR> instead of "heres the assumptions you were making" would be better as "heres the assumptions i am making"
13:51:35 <Zekka> sometimes it's not obvious to me what assumption I was making
13:52:00 <Zekka> I would not expect Haskell to give me a good human-understandable explanation of why assuming (>) and (<=) are exhaustive is wrong
13:52:20 <Zekka> Or for it even to be able to derive that
13:56:14 <EvanR> "because LEM"
13:56:23 <Zekka> emre: By the way, heads up -- you may want to special-case initial input of "0"!
13:56:27 <EvanR> or the unavailability of it
13:56:27 <Zekka> er, of `0`
13:56:35 <Zekka> that should probably be rendered as "0", not as ""
13:58:44 <emre> Zekka: Why is that? Returning `[]` for non-positive x seems fine to me.
13:59:27 <dmwit> EvanR: Congratulations, you have just illustrated Zekka's point. For "LEM" to be a sufficient explanation, you have silently assumed that `a > b` is the same as `not (a <= b)`. An assumption which, in this case, turns out to be incorrect...
13:59:36 <Zekka> Oh wait, hold up -- you're producing a list of integers
13:59:43 <Zekka> For some reason I'd thought you were producing a string representation
14:00:11 <EvanR> dmwit: well theres several ways to formalize these ordering relations and im not about to try any
14:00:12 <emre> Zekka: I am producing a list of pairs of two strings
14:00:18 <dfeuer> WAT.
14:00:56 <Zekka> Really? The code I"m lookinga t on lpaste says :: Integer -> [Integer] where 360 produces [3, 6, 0] afaict, and 0 produces []
14:01:09 <dfeuer> There must be some better way than this.
14:01:17 <emre> Zekka: Ooh it's that one. I thought we were talking about Hanoi.
14:01:36 <Zekka> AFAICT Haskell does not attempt to make an assumption about > and <=
14:01:53 <Zekka> its best explanation is that "you thought they were exhaustive, they weren't"
14:01:57 <emre> Zekka: It is just part of an assignment where 0 is asked to produce [].
14:02:18 <Zekka> emre: Yeah, in that case then ignore me.
14:02:30 <Zekka> I'm so used to seeing people use code like this to produce a string, and 0 is a slightly awkward case for it
14:03:13 <Zekka> EvanR: So when you say "What explanation did Haskell make?" it sounds like you're trying to ask Haskell to derive something, because it doesn't sound like it already has
14:04:38 <EvanR> what assumptions did it make
14:05:19 <EvanR> also i font recall seeing warnings about guards about < == and >
14:05:24 <EvanR> i dont*
14:05:32 <hexagoxel> for reasons i would like to put different values of type `Generic a => a` into a Set. do i really need to encode to binary or write my own generic serialization function?
14:05:39 <Zekka> I think that when you're asking what assumptions haskell made in this case, you're talking about a suspicious category of things
14:05:59 <Zekka> When you write a series of guards, all Haskell is guaranteeing is that it translates that to "try the first guard -- if it returns True, do its body" and so on
14:05:59 <EvanR> a suspicious category
14:06:12 <Zekka> The Haskell implementation is not required to make any conclusions about the content of the guards
14:06:23 <hexagoxel> this seems less efficient/more boilerplaty than possible, so i probably am missing something.
14:06:29 <Zekka> as a courtesy, it appears that if no guard is always True, it wlil report a warning
14:06:39 <EvanR> right, so how are guard sequences ever not necessarily non-exhaustive
14:06:56 <EvanR> maybe i never enabled this warning
14:07:00 <Zekka> If one guard is definitely constant True, then the guards are exhaustive. But I don't know what you're responding to
14:07:11 <EvanR> ok thats the only case really
14:07:27 <Zekka> Are you saying "if Haskell decides that your guards are exhaustive, but there's an error and it turns out your guards actually aren't exhaustive, Haskell should explain why it assumed they were exhaustive"?
14:07:50 <EvanR> right now i am saying "how do you get errors or warnings about exhaustivity of guards"
14:08:04 <emre> EvanR: I just turned on -Wall
14:08:06 <Zekka> It looks like at most, Haskell determines if one of your guards is constant value True
14:08:08 <EvanR> orly
14:08:23 <EvanR> sounds annoying
14:08:38 <Zekka> Haskell (or well, GHC specifically) does not appear to inspect them beyond that
14:09:37 <Zekka> AFAICT, since this is a warning, it's not even required to inspect them at all
14:09:40 <dmwit> hexagoxel: `Dynamic` exists
14:11:26 <dfeuer> dmwit, does Dynamic support Ord?
14:12:16 <dfeuer> Nope. 
14:12:20 <dfeuer> So no set for you.
14:12:47 <dfeuer> hexagoxel, why do you want such a set?
14:13:03 <hexagoxel> even if you compare the TypeReps, you have nowhere to get the actual Ord instance.
14:13:43 <EvanR> Generic cant do a generic Ord?
14:13:49 <EvanR> that seems absurd
14:13:59 <dfeuer> hexagoxel, well, you *could* use something like data DynOrd where DynOrd :: (Typeable a, Ord a) => DynOrd, and compare both typerep and value.
14:14:06 <dfeuer> But this is disgusting and seems silly.
14:14:13 <crough> hexagoxel: or just coyoneda embed it https://gist.github.com/crough/1586c6ec23556aa1000170a22e8cdbbe
14:14:14 <hexagoxel> dfeuer: really, i want a Map. the real goal is to get some custom memoization working
14:14:16 <dfeuer> What's the actual context?
14:14:27 <glguy> You can only use Generic to derive Ord if you already have Ord satisfied for all the fields of the type you're deriving it for
14:14:33 <dfeuer> How much do you know about what types will be there?
14:14:37 <glguy> (unless you don't care to compare the fields)
14:15:21 <hexagoxel> custom in the sense that i do not use a default Ord instance of the keys of the memoization function.
14:16:42 <dfeuer> hexagoxel, why do you want to do this? And why a Set? I'm not trying to second-guess you, but I don't see anything good down this particular path.
14:16:51 <dfeuer> There might be some better way around.
14:17:16 <dmwit> crough: That seems like it would perform terribly.
14:17:25 <crough> ehh if you keep checking against it
14:17:34 <crough> however, if you never realize it it's linear
14:18:22 <crough> For building up a lot of fmaps it's pretty ok-- useless if you need to lookup values while you're mapping over it though
14:18:31 <EvanR> dfeuer: hexagoxel opened up with a trump card "for reasons"
14:18:34 <shachaf> ok++
14:18:39 <dmwit> You have a use case for sets where you build it up, query it once, and then completely throw it away?
14:18:44 <dmwit> shachaf: Happy birthday!
14:18:49 <hexagoxel> dfeuer: i'll explain the context some more: i currently need memoization to achieve non-exponential complexity. but now my code spends 90% of its runtime inside `compare`.
14:19:01 <shachaf> dmwit: whoa whoa whoa
14:20:02 <dmwit> I'm too lazy for SSL.
14:20:05 <ReinH> dmwit: Too excited. Tone it down a bit.
14:20:12 <dfeuer> hexagoxel, more context? Where are these things coming from, etc.?
14:20:50 <hexagoxel> (and yes, i know of stable-memo, and implement my algorithm with it, but i could not get it working correctly.)
14:20:53 <shachaf> SSL?
14:21:05 <shachaf> #haskell-offtopic is the one that doesn't require TLS.
14:21:11 <dmwit> oh
14:21:23 <glguy> Where does it stand on SSL, though??
14:21:38 <EvanR> another one bites the dust
14:22:39 <hexagoxel> dfeuer: the comparisons all happen on nodes of this datatype: https://github.com/lspitzner/brittany/blob/stablename/src/Language/Haskell/Brittany/Types.hs#L155
14:23:14 <hexagoxel> oh, s/implement/implemented/ above.
14:23:32 <dfeuer> hexagoxel, ummm... so those are your keys? Why do you need generic stuff?
14:23:58 <dfeuer> hexagoxel, I'm clearly missing something.
14:24:18 <dfeuer> Oh, comparisons are just too expensive?
14:24:22 <dfeuer> Have you tried generic-trie?
14:24:58 <hexagoxel> yes, just too expensive. and O(n²) when you do comparisons on all nodes.
14:25:11 <dfeuer> Did you try generic-trie?
14:25:18 <Zekka> Hm, what data structure are you using that requires each node to be compared to every other node?
14:25:20 <hexagoxel> no
14:25:26 <hexagoxel> will have a look, thanks for the idea.
14:25:28 <dfeuer> That strikes me as considerably more natural.
14:25:35 <dfeuer> glguy wrote that.
14:26:03 <Zekka> Also, have you considered a hashtable? (Disclaimer: I don't know how hashtable implementations look in Haskell and it's possible this will be more trouble than it's worth for you)
14:26:06 <glguy> I don't promise that it's faster than whatever you were doing, but it proves that you can be terribly clever with Generics :)
14:26:14 <dfeuer> Speaking of which, glguy, where are my Array, Sequence, and (maybe?) Vector instances for TrieKey?
14:26:25 <glguy> dfeuer: I didn't see the PR
14:26:41 <dfeuer> glguy, I don't think I submitted one; they just seem like they should be there :P
14:26:43 <kadoban> Zekka: I think they're usually IntMap (which is like a trie) + k -> Int
14:27:03 <Zekka> Oh yeah, so you provide your own to-int mapping and then figure out your own policy to deal with collisions?
14:27:08 <hexagoxel> Zekka: i fear the hash-computation would need to do roughly as much work as `compare` currently needs.
14:27:16 <dfeuer> But I'll be happy to submit some, glguy!
14:27:27 <Zekka> hexagoxel: It probably would, but as the height of your tree increases, the number of comparisons increases (assuming you're using a tree)
14:27:45 <Zekka> you only have to do your hashing once -- minding that work increases again when dealing with a collision
14:27:48 <kadoban> Zekka: Well, it's really Hashable I think, which is at least slightly more fancy than I implied.
14:28:30 * glguy uploads haddocks for that http://hackage.haskell.org/package/generic-trie-0.3.0.2/docs/Data-GenericTrie.html
14:29:36 <Zekka> you can guarantee the number of comparisons is below a certain amount when you use a balanced tree structure of some kind -- with a hashtable structure there are tricks to reduce the worst-case number of probes done, stuff like that, but I'm pretty sure you can't actually bound the number of collisions to worry about
14:29:56 <Zekka> on average with a hashtable you only hash once, and then you don't do *that* many equality checks
14:32:01 <hexagoxel> Zekka: you are right, thanks for the correction. i'll look again if the memo lib can be convinced to use some hashmap.
14:32:19 <Zekka> Disclaimer, I'm not a data structures expert
14:32:27 <Zekka> I just had a problem similar to yours a while ago and a friend swayed me
14:33:18 <hexagoxel> Zekka: sure, i am looking into GenericTrie first anyways :p
14:40:50 <ertes> HashMap does not deal with collisions…  it degenerates to linear search for colliding keys, which is quite terrible
14:41:04 <Zekka> Oh really? That's super unfortunate
14:41:21 <kadoban> That's essentially what hash tables always do.
14:41:24 <Zekka> somebody should implement a better one! (I say this knowing that whoever says "somebody should implement" is the guy who probably should ultimately implement it)
14:41:27 <ertes> given Int's size it wouldn't normally be a problem
14:41:33 <c_wraith> just don't use colliding hashes. solved! 
14:41:44 <ertes> unfortunately Hashable is subject to collision attacks
14:42:07 <c_wraith> I thought it redesigned around that. 
14:42:08 <ertes> so don't use HashMap for applications where untrusted users are in control of the keys
14:42:39 <EvanR> kadoban: ok but HashMap isnt a hash table
14:43:07 <Zekka> Robin Hood hashing, the optimization I used to remember the details of (I don't remember them now) tries to improve the case where there are so many collisions for a key that they run into the table items for a different key
14:43:20 <Zekka> er, collisions for the hash of a given key
14:43:34 <ertes> note: HashMap doesn't grow exponentially in size under attack like hash tables would
14:43:42 <c_wraith> yeah, Hashable has ways to make it collision resistant.. 
14:43:48 <Zekka> I don't know how to deal for the case where there are a large number of keys that actually point at the same position in the table
14:44:05 <c_wraith> it's up to users to take advantage of that, though.. 
14:44:07 <kadoban> EvanR: A fair point, but ... the thing it's based on is as bad in this instance as a HashMap is, so it being a specific complaint about HashMap doesn't make much sense still, right?
14:44:43 <ertes> c_wraith: and it's not easy to do, essentially needing a type-encoded salt
14:44:52 <ertes> you could do it with reflection
14:44:58 <c_wraith> unfortunately, real collision resistance is awkward with purity. 
14:45:18 <ertes> that's not really the problem…  it's easy enough with reflection
14:45:45 <ertes> the problem is that you can't use any of the usual instances
14:45:56 <ertes> which also means that you can't use Generic-based Hashable deriving
14:46:08 <ertes> unless you write wrapper newtypes around every single type
14:46:56 <c_wraith> well, I mean designing it to make it impossible to get wrong. that's awkward with purity. 
14:47:07 <c_wraith> not impossible, but awkward. 
14:49:52 <c_wraith> unlike impure approaches that do things like choosing a random salt at program startup. 
14:51:20 <m0rphism> Is there a way to derive `Eq1` from `Data.Functor.Classes`? I'm playing with the `bound` library for locally nameless bindings, and wonder whether I could get rid of the boiler plate.
14:52:09 <EvanR> maybe there is a way to hide hash values in a way that looks pure but isnt
14:53:06 <c_wraith> you could cheat and do the u
14:53:25 <c_wraith> err. unsafePerformIO in a constant thing. 
14:53:44 <c_wraith> with enough care, it is safe. 
14:54:01 <ertes> c_wraith: it's rather easy, but unfortunately the Hashable class is not designed for that
14:54:03 <EvanR> "u" comes with an unspoken parameter, a proof that what youre doing makes sense ;)
14:54:10 <c_wraith> but it's definitely not ethically pure. :) 
14:54:26 <glguy> m0rphism: Eq1 has a default implemention, does your type work with that?
14:54:30 <ertes> c_wraith: i'd design it like that: class Hashable a where hash :: (Salt s) => a -> Hash s
14:54:40 <glguy> m0rphism:   default (==#) :: (Eq (f a), Eq a) => f a -> f a -> Bool
14:54:48 <ertes> c_wraith: similarly convenient to use, but secure by default
14:55:10 <ertes> the only inconvenience is that you need one reification somewhere near 'main'
14:55:21 <ertes> main = withRandomSalt $ \(_ :: Proxy s) -> …
14:55:48 <c_wraith> how much does that approach hit performance? 
14:56:08 <ertes> c_wraith: as much as passing an extra argument to 'hash'
14:56:30 <ertes> at least if you use the same hack that the reflection package uses
14:56:53 <c_wraith> i suppose that with proper inlining and simplification, it ends up being passing that parameter at runtime. 
14:58:16 <ertes> you don't need special inlining or simplification…  passing that parameter at run-time is exactly what would happen
14:59:16 <m0rphism> glguy: I think we're talking about different `Eq1`s :-) The one from `prelude-extras` has this default instance, the one from `transformers` sadly not.
14:59:29 <c_wraith> I mean to eliminate calls to read the environment.. they'd need to be inclined out. 
14:59:56 <glguy> m0rphism: isn't the one from prelude-extras the one that bound is using?
15:00:16 <c_wraith> err.. inlined. which would just make them id. then simplified. 
15:00:35 <shapr> man, whoever maintains the github api library needs to fix all the broken examples
15:00:38 <shapr> or maybe I need to do it
15:00:44 <ertes> c_wraith: recent GHCs have the Proxy# type, which is like Proxy, but has no run-time representation…  that might be handy
15:00:59 <m0rphism> glguy: Oh, I just realized, that this is true for the version on hackage. But for the version on github this has changed
15:01:18 <m0rphism> glguy: I'm using the one from github as this works with ghc 8.0.1
15:01:20 <c_wraith> ertes, I mean to get the salt from the environment. There's an actual value to get there. 
15:02:00 <m0rphism> glguy: Sorry for the confusion.
15:03:05 <ertes> c_wraith: if the Proxy passing is eliminated, then reflection is pretty much just referring to the dictionary value, so "salt (Proxy# :: Proxy# s)" is actually referring to the hidden argument directly
15:04:51 <ertes> c_wraith: technically what happens is that 'hash' is applied like this: hash salt x = …
15:05:08 <ertes> but 'salt' is a constant function that takes and ignores a dummy argument
15:05:35 <ertes> that's where Proxy# comes in:  a function of Proxy# is technically just a value
15:05:47 <Gurkenglas> http://lpaste.net/8058165229269286912 what was the right was to write stack repl?
15:06:12 <Gurkenglas> (those numbers are just traces no worries)
15:07:07 <quantumtremor> new to haskell - i'm trying to write a program that works with DFAs. Should I be working with Data.Sets of states or just lists of states? There's no clear ordering to states, although I can assign an ordering arbitrarily
15:07:24 <quantumtremor> for reference, I defined Data State = State { name :: String }
15:08:31 <c_wraith> Gurkenglas, did you ever write the Traversal you were talking about earlier? 
15:09:07 <Zekka> quantumtremor: Are you concerned about performance or accuracy to your model?
15:09:20 <quantumtremor> quantumtremor: accuracy yes, performance not really
15:09:21 <glguy> m0rphism: This problem is made for GHC.Generics
15:09:28 <quantumtremor> Zekka: ^
15:09:34 <Zekka> Because neither of those is going to perform all that well, but if your goal is to not have duplicates, a set will work
15:09:40 <Gurkenglas> c_wraith, I talked about multiple things to do with traversals, but traverseOf_ was the solution to one of them
15:09:54 <quantumtremor> Zekka: if I did care about performance, how would I do it?
15:10:17 <Zekka> You'd probably want to somehow represent the collection of transitions as an array in place
15:10:32 <Zekka> I don't know how to coerce Haskell into using this representation though
15:11:04 <ertes> quantumtremor: DFAs have a nice representation in haskell
15:11:15 <Zekka> you'd also probably want to say data State = State1 | State2 | State3...
15:11:37 <Zekka> string operations are mostly not cheap, but that effectively makes Haskell represent states as numbers
15:11:48 <m0rphism> glguy: Seems like you're not the only one with that thought :D https://github.com/ekmett/transformers-compat/blob/master/0.5/Data/Functor/Classes/Generic.hs
15:12:05 <Zekka> It sounds like ertes has a particular representation he thinks is even better though
15:12:22 <ertes> quantumtremor: are you familiar with type variables?  example: have you seen the definition of Maybe?
15:12:26 <c_wraith> Gurkenglas, I was thinking of the one that uses a predicate and a structure to create a traversal for other values with the same structure 
15:12:42 <quantumtremor> ertes: I'm using the 5 tuple definition right now. But yeah, I know about type variables
15:13:34 <ertes> quantumtremor: what is a set in math loosely translates to a type in haskell…  your DFA is pretty much fully defined by a function
15:13:58 <m0rphism> glguy: but again in an unexported module without documentation. Feels like the deriving-traversals thing all over again ;)
15:15:04 <m0rphism> thanks for the help
15:15:07 <quantumtremor>  ertes: this is what I have right now http://pastebin.com/UzHHGuTw
15:15:11 <ertes> quantumtremor: if 's' is the type of states and 'a' is the type of input symbols, then a DFA is defined by a value of type 's' and a function of type (a -> s -> s)
15:15:23 <ertes> quantumtremor: but there are also accept states
15:15:26 <quantumtremor> ertes: right
15:15:29 <c_wraith> Gurkenglas, I think I have a hilarious way to make it work for any Traversable using Data.Functor.Compose 
15:16:07 <ertes> quantumtremor: a DFA in general *could* continue, even after reaching an accept state…  do you need that?
15:16:42 <quantumtremor> ertes: Yes, I'd like it to read the entire input exactly once before terminating
15:16:52 <quantumtremor> I believe that's what my function "accepts" does
15:17:58 <Zekka> FWIW I think your implementation looks pretty good. (not getting into performance, because microoptimization is not usually useful unless somehow you need it)
15:19:12 <Zekka> occasionally folks will represent `delta` as an array or a table, but that will make your code more convoluted and is not idiomatic in Haskell
15:19:30 <ertes> quantumtremor: the idea is to dispense with the state type altogether, because for most applications of DFAs you don't care about the state *values*
15:19:59 <quantumtremor> Zekka: okay cool. This is mostly just to learn a bit about modeling data in haskell.
15:20:16 <Zekka> Minding that you can occasionally write sneaky code using the (a -> s -> s) representation
15:20:18 <quantumtremor> ertes: hmm, I don't understand really. are you saying it should be an implementation detail?
15:20:27 <ertes> quantumtremor: data Dfa a b = Done b | Dfa (a -> Dfa a b)
15:20:39 <ertes> quantumtremor: exactly
15:21:09 <ertes> quantumtremor: instead of a state type, you use a type for accept states only
15:21:10 <Zekka> for instance, (+) is an (a -> s -> s), but Int has infinite members -- so if your (a -> s -> s) is (+), you're not necessarily really simulating a dfa
15:21:21 <ertes> quantumtremor: here 'b'
15:22:21 <ertes> quantumtremor: example DFA that takes integers as input and stops with their sum…  the "end of input" is an extra symbol via Maybe
15:22:54 <ertes> sumFrom s = Dfa (\mx -> case mx of Just x -> sumFrom (s + x); Nothing -> Done s)
15:23:04 * hackagebot fortran-src 0.1.0.1 - Parser and anlyses for Fortran standards 66, 77, 90.  https://hackage.haskell.org/package/fortran-src-0.1.0.1 (DominicOrchard)
15:23:30 <ertes> sumFrom :: Dfa (Maybe Integer) Integer
15:23:37 <ertes> whoops
15:23:41 <ertes> sumFrom :: Integer -> Dfa (Maybe Integer) Integer
15:24:05 <Gurkenglas> c_wraith: Do it!
15:24:29 <c_wraith> Gurkenglas, in a few hours - on my commute home. 
15:25:21 <quantumtremor> ertes: I'm confused. What's the point of having a and b be type variables, for example Integers
15:25:26 <quantumtremor> is sumFrom the delta?
15:27:07 <ertes> quantumtremor: the input type is Maybe Integer (the first type argument of Dfa), so mathematically it's ℤ together with a distinguished "end of input" symbol
15:28:17 <ertes> quantumtremor: the actual state type of this DFA is hidden, but it's isomorphic to (Bool, Integer), so mathematically 2 × ℤ
15:28:46 <quantumtremor> ertes: I can't see the symbol after "2 x", probably font issues
15:28:58 <quantumtremor> Z?
15:29:01 <ertes> quantumtremor: 2 x Z
15:29:02 <ertes> yeah
15:29:46 <ertes> quantumtremor: the easiest way to understand this type is to just play with it =)
15:29:52 <ertes> try to implement a few automata
15:30:56 <quantumtremor> ertes: Right. I'll try implementing it and go from there. Thanks
15:32:13 <ertes> quantumtremor: the shape is mostly the same:  myDfaFrom s = Dfa (\x -> …)  -- based on the input 'x' you decide whether the next state is a Dfa (still going) or a Done (reached an accept state)
15:33:54 <quantumtremor> ertes: so how do I specify the transition function? do I write rules for integers?
15:35:10 <ertes> quantumtremor: let me show you a DFA that stops with the last non-EOF input…  there are no integers involved in this case
15:36:35 <ertes> lastInput x = Dfa (\mx -> case mx of Just y -> lastInput y; Nothing -> Done x)
15:36:46 <ertes> lastInput :: a -> Dfa (Maybe a) a
15:36:56 <joe9> anyone knows how to load javascript files when using servant + lucid. I have serveDirectory on my javascripts folder. But, for some reason, the browser is not even calling / loading the scripts?  http://codepad.org/M1PvlT9j is this the correct way to get javascripts to load?
15:38:52 <Gurkenglas> Does gloss usually take this much cpu?
15:39:18 <dmj`> joe9: the browser automatically fetches the js after the page is delivered
15:41:27 <quantumtremor> ertes: so the string has type of [Maybe y] in your example?
15:43:23 <joe9> dmj`: for some reason, I do not see the call loading javascript in the WebDeveloper console (F12)
15:43:35 <joe9> dmj`: do you have any code snippet loading .js files?
15:43:56 <ertes> quantumtremor: that question is best asked with a certain DFA interpreter in mind, let's call it 'feed'
15:43:57 <zomg> joe9: you need to use a script tag
15:44:06 <zomg> joe9: link is only used for stylesheets
15:44:33 <ertes> quantumtremor: feed :: [a] -> Dfa a b -> Maybe b
15:45:21 <quantumtremor> ertes: just to be clear, a is a Symbol type, and b indicates whether the DFA accepts?
15:45:24 <dmj`> joe9: what zomg said
15:45:24 <ertes> quantumtremor: or even:  feed :: [a] -> Dfa a b -> Dfa a b
15:46:30 <ertes> quantumtremor: both are types, and 'a' is the input symbol type, and 'b'…  imagine that 't' is the type of accept states, so it corresponds to a subset of the state type
15:46:48 <ertes> quantumtremor: imagine there is a function from 't' to 'b'
15:46:59 <ertes> so it's the type of "end states"
15:47:33 <ertes> it could be just the same as the state type 's'
15:47:55 <joe9> zomg, Thanks. dmj` I cannot get the script_ tag to work with src_ . The error messages are confusing as I am new to servant/lucid.
15:48:20 <joe9> zomg, dmj':          script_ . src_ . T.pack $ "http://d3js.org/d3.v3.min.js" tried this.
15:49:01 <joe9>          script_ [  src_ "http://d3js.org/d3.v3.min.js"] tried this: error :  http://codepad.org/PJ5NXk1g
15:50:10 <dmj`> joe9: with script_ [ src_ "http://d3js.org/d3.v3.min.js" ] 
15:50:47 <joe9> dmj' you need "with"?
15:50:59 <dmj`> joe9: yes, see the type, src_ is an attribute
15:51:09 <dmj`> not an element
15:51:53 <joe9> script_ [ src_ undefined ]   :: Lucid.Base.TermRaw [Attribute] result => result
15:52:04 <buglebudabey> ertes would you mind helping me with this type error before i ask you about the edits to my program? http://lpaste.net/171856
15:52:13 <joe9> so I need to figure out how to convert [Attribute] to arg? dmj`
15:52:15 <quantumtremor> ertes: okay, so Just b is accepting and Nothing is rejecting?
15:53:20 <joe9>  dmj`: http://codepad.org/BtPipRaf . I read somewhere that Lenses obfuscates the types. Is this an instance of that?
15:54:18 <dmj`> joe9: nah, these aren't lenses, 'with' is from the typeclass 'With'
15:54:18 <glguy> joe9: No, there are no lens things there
15:55:00 <dmj`> joe9: you use 'with' to annotate elements with attributes
15:55:30 <joe9> dmj' code http://dpaste.com/2CBSXWR , error:  http://codepad.org/AlP8USxM
15:56:10 <ertes> buglebudabey: it would help to know the code that causes it ;)
15:56:10 <glguy> m0rphism: http://hackage.haskell.org/package/deriving-compat-0.3.1/docs/Data-Eq-Deriving.html
15:56:43 <joe9> dmj' does that error make sense to you?
15:57:09 <buglebudabey> ok ertes, here's the whole thing http://lpaste.net/171857
15:57:12 <ertes> quantumtremor: Just means that the DFA actually stopped after the input was fed
15:57:33 <ertes> quantumtremor: Nothing means that even after feeding it the whole list of inputs, it was still a Dfa rather than a Done
15:57:55 <joe9> dmj' when I comment the "with " line  204, the code compiles fine.
15:57:56 <dmj`> joe9: with (script_ []) [ src_ "script.js" ] 
15:59:14 <joe9> dmj'          with (script_ []) [ src_ "http://d3js.org/d3.v3.min.js" ] error: http://codepad.org/APrEdiSJ
16:00:55 <ertes> buglebudabey: in any case the error means that you passed a list to a function that expects a Text
16:01:43 <ertes> buglebudabey: uhm, no, the opposite
16:02:05 <dmj`> joe9: with (script_ mempty) [ src_ "script.js" ]
16:02:08 <dmj`> try that
16:02:36 <joe9> dmj`: That worked like a charm.
16:03:03 <joe9> if you have a few mins , would you mind explaining what is going on here?
16:03:17 <m0rphism> glguy: nice, thanks :)
16:03:17 <joe9> I mean with (script_ mempty)
16:03:58 <dmj`> joe9: Html () is a monoid I believe, 'with' just wraps Html () with [Attribute] -> Html ()
16:04:13 <dmj`> joe9: render it and see if it does the right thing
16:04:22 <joe9> dmj`: ok, Thanks. will have to read up on monoid.s
16:04:49 <dmj`> yes, it's hard to do real world things in haskell w/ knowing functor, applicative, monoid, monad and transformers
16:04:53 <dmj`> w/o*
16:05:04 <joe9> dmj`: yes, it worked fine. I can see the .js loading.
16:05:52 <joe9> I keep reading up the material. After a few months of doing something else, the knowledge goes bust again.
16:06:30 <joe9> one of the frustrating things with haskell. Atleast, haskell code is easy to fix anytime though.
16:06:40 <quantumtremor> ertes: so to take a concrete example, let's say a DFA recognizing (111)^*. In the function "(a -> (Dfa a b))", is that return type a Dfa implicitly in the state of being 1 mod 3?
16:11:59 <dmwit> `Data.Map Data.Aeson> toEncoding (fromList [(3, 4), (5, 6)])` => "[4,6]"
16:12:01 <dmwit> wat
16:13:49 <glguy> dmwit: On my computer "instance ToJSON v => ToJSON (Map String v)"
16:14:56 <dmwit> glguy: From some digging, I think it may be using the (incoherent) `instance (Foldable t, ToJSON a) => ToJSON (t a)`.
16:15:17 <dmwit> Which... seems like a really, really bad instance to have.
16:15:49 <glguy> dmwit: Where's that instance from?
16:16:06 <dmwit> aeson-0.10.0.0:Data.Aeson.Types.Instances
16:16:45 <glguy> I think that might be fixed in the current aeson
16:16:45 <buglebudabey> ok ertes, i tried to take your advice, would you mind checking this revised version? http://lpaste.net/171858
16:18:03 <glguy> dmwit: https://github.com/bos/aeson/issues/349
16:18:07 <dmwit> glguy: guess so: https://github.com/bos/aeson/issues/349
16:18:10 <dmwit> glguy: ...oh
16:18:23 <glguy> You can't just copy my messages back to me, pfft ;-)
16:18:28 <dmwit> hehe
16:24:31 <gfixler> > -1
16:24:33 <lambdabot>  -1
16:24:39 <gfixler> I just realized I don't know how that works
16:24:43 <gfixler> :t (-)
16:24:44 <lambdabot> Num a => a -> a -> a
16:24:47 <gfixler> is it a hack?
16:24:58 <Welkin> > "gfixler"
16:25:00 <lambdabot>  "gfixler"
16:25:01 <glguy> The behavior of - is built into the language
16:25:05 <Koterpillar> > -1 - 2
16:25:09 <gfixler> glguy: I figured
16:25:09 <lambdabot>  -3
16:25:17 <Welkin> you can't use prefix (-)
16:25:19 <Koterpillar> > Just -1
16:25:20 <lambdabot>      No instance for (Typeable a0)
16:25:20 <lambdabot>        arising from a use of ‘show_M15161870987978850293091’
16:25:20 <lambdabot>      In the expression:
16:25:23 <Welkin> you use `subtract`
16:25:35 <glguy> gfixler: See section 3.4 of Haskell 2010
16:25:39 <Koterpillar> it's a hack; there's an extension you can enable so, i.e. Just -1 works
16:25:40 <Welkin> prefix (-) is unary minus
16:25:51 <Koterpillar> > Just (-1)
16:25:53 <lambdabot>  Just (-1)
16:25:57 <gfixler> yeah, just wondered how it worked when (-) already has a type
16:26:14 <Welkin> :t (-) 4
16:26:16 <lambdabot> Num a => a -> a
16:26:21 <Welkin> :t (-) 4 5
16:26:22 <gfixler> built-in makes sense; is kinda gross
16:26:22 <lambdabot> Num a => a
16:26:25 <Welkin> > (-) 4 5
16:26:27 <lambdabot>  -1
16:26:29 <Welkin> what
16:26:32 <Welkin> since when?
16:26:41 <dmwit> since forever
16:26:41 <glguy> Always and forever
16:26:47 <Welkin> I remember that not working
16:26:52 <Welkin> > subtract 4 5
16:26:54 <lambdabot>  1
16:26:58 <gfixler> yeah, subtract is weird
16:27:03 <kadoban> The one that doesn't work so well is:  (-4) 5
16:27:09 <Welkin> oh yeah
16:27:11 <Welkin> that is what it was
16:27:15 <Welkin> using sections
16:27:15 <dmwit> Welkin: subtract is needed for partial application. `(-4)` means `negate 4` not `(-) 4`.
16:27:35 <gfixler> it's enough to make me not want to subtract anything again
16:27:39 <Welkin> :t (-4) 5
16:27:40 <gfixler> only additions from here on out
16:27:41 <lambdabot> (Num a, Num (a -> t)) => t
16:27:43 <glguy> That's probably a rational response
16:27:48 <Welkin> > (-4) 5
16:27:50 <lambdabot>      Could not deduce (Num a0)
16:27:50 <lambdabot>      from the context (Num a, Num (a -> t))
16:27:50 <lambdabot>        bound by the inferred type for ‘e_145’: (Num a, Num (a -> t)) => t
16:27:50 <dmwit> Well, it doesn't mean `(-) 4`, but more importantly it doesn't mean `flip (-) 4`.
16:27:51 <glguy> > 4 + - 5
16:27:52 <lambdabot>      Precedence parsing error
16:27:52 <lambdabot>          cannot mix ‘+’ [infixl 6] and prefix `-' [infixl 6] in the same infi...
16:28:20 <dmwit> gfixler: Yeah. Better skip comments, too, since you need `-` for those as well.
16:28:38 * gfixler is getting a complex
16:28:48 <gfixler> I think they're okay, because -- is just +
16:29:34 <Welkin> > ((flip subtract) 4) 5
16:29:36 <lambdabot>  -1
16:29:46 <glguy> With -XNegativeLiterals you can write:  4 + -5
16:30:41 <sbrg> TIL
16:33:10 <__Myst__> glguy: So why isn't NegativeLiterals a default?
16:35:09 <glguy> I don't know if it was an oversight in the Haskell Report or if there's a good reason that it was written that way.
16:35:50 <glguy> Whoa, and there's -XNumDecimals, I've wanted this for a while and didn't know it was a thing
16:35:53 <glguy> 1e10 :: Int
16:36:21 <glguy> Don't miss out on BinaryLiterals while you're there: 0b0100101
16:36:31 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XNegativeLiterals
16:38:59 <sbrg> there was this thread on reddit (I think) about people's favorite extensions or something like that, but I can't find it
16:39:06 <sbrg> i think it included NumDecimals and BinaryLiterals
16:39:15 <sbrg> I meant to go back to it but .. 
16:39:18 <__Myst__> NumDecimals?
16:39:25 <Welkin> I thought we already had binary literals
16:39:29 <Welkin> > 0b1010
16:39:31 <lambdabot>  Not in scope: ‘b1010’
16:39:34 <Welkin> er
16:39:51 <Welkin> > 0xa
16:39:53 <lambdabot>  10
16:39:55 <Welkin> hm
16:40:05 <Welkin> I thought there was a way to do that
16:47:10 <__Myst__> >Is there any way to have the same function definition but for two patterns?
16:47:13 <__Myst__> Smething like
16:47:22 <__Myst__> f ('x' | 'y') = "xy was inputted!"
16:48:10 <glguy> no, you'll need something like: f 'x' = xyCase; f 'y' = xyCase, or   f x | x `elem` "xy" = ... etc
16:51:29 <__Myst__> glguy: 
16:51:36 <__Myst__> f 'x' = someCode; f 'y' = f 'x'
16:52:04 <glguy> Yeah, if you're careful that can be OK
16:58:00 <ReinH> glguy: do you still use your irc client?
16:58:06 <glguy> Yeah
16:58:13 <ReinH> Just not the haskell highlighting?
16:58:33 <glguy> Oh, I haven't added the syntax highlighting in the rewritten version of it
16:58:40 <monochrom> :)
16:58:41 <ReinH> rewritten version heh
16:58:43 <ReinH> *eh
16:58:49 <ReinH> glguy: that's on your githubs?
16:58:53 <monochrom> the monochromatic version :)
16:58:54 <glguy> I added multiple servers and some other stuff
16:59:02 <ReinH> monochrom: ICWYDT
16:59:05 <glguy> https://github.com/glguy/irc-core/tree/v2
16:59:21 <ReinH> glguy: Nice.
16:59:32 <glguy> I need to update the README for the next release before I drop it on Hackage
16:59:41 <glguy> I spent a bunch of time commenting it Sunday getting ready
16:59:42 <__Myst__> What's the package for the binary operations again?
16:59:44 <__Myst__> Data.Bits?
16:59:45 <ReinH> glguy: I see you aren't using vty-ui or brick.
17:00:46 <ReinH> Do you not care for the widget abstraction or prefer to roll your own or...
17:01:39 <glguy> I haven't found using vty directly to be enough of a burden to want to replace it. My client has a pretty straightforward layout
17:01:52 <glguy> text input at the bottom, a line of information and the rest is the message view
17:02:26 <ReinH>  And you don't need the focus handling stuff, since you only have the one input field.
17:02:44 <Welkin> __Myst__: yes
17:03:13 <glguy> http://imgur.com/a/6X9K9
17:04:02 <obadz> What's the way to read 4 bytes of a bytestring into a Word32?
17:05:58 <ReinH> What do you want to do with the rest of the bytestring?
17:07:34 <ReinH> decode :: ByteString -> Word32 with the binary package
17:08:07 <obadz> ReinH: happy to have this be a readonly op
17:08:12 <glguy> If you care what answer you get you might use getWord32le, getWord32be, or getWord32host http://hackage.haskell.org/package/binary-0.8.4.1/docs/Data-Binary-Get.html#v:getWord32le
17:08:32 <ReinH> endianness, who needs it
17:08:51 <glguy> for a one-off case you might even just index the 4 bytes, convert them, shift them, and add them up
17:09:19 <obadz> using binary sounds right
17:09:24 <obadz> I'm looking at an IPv4 header
17:10:01 <earldouglas> Is there a way to use Hoogle to search all of Hackage?  Seems like haskell.org/hoogle has a limited index.
17:10:27 <ReinH> https://hackage.haskell.org/package/network-ip-0.2.1.1/docs/Network-IP-Addr.html has Binary instances
17:10:29 <obadz> thx glguy / ReinH 
17:10:36 <kadoban> earldouglas: I use the one on stackage.org or hayoo
17:10:42 <sm> earldouglas: or http://hoogle.haskell.org
17:11:16 <earldouglas> Excellent, thanks!
17:11:46 <ReinH> Ofc the stackage one searches all of *stackage*, which is still better than the usual one.
17:12:06 <phadej> except it list results in alphabetical order of package-names
17:12:15 <phadej> which is suboptimal
17:12:22 <earldouglas> I'm not hip enough yet to use stack, so hoogle.haskell.org works for now.
17:12:27 <RyanGlScott> Ah, that's why it takes so long to find foldr when searching ;)
17:12:47 <kadoban> Well, you don't need to use stack for it to be useful, but ya sometimes the versions won't quite match up to what you're using. I've yet to find an important difference.
17:12:48 <phadej> yes, alphabetical case-sensitive one so Z is before a
17:13:08 * hackagebot th-orphans 0.13.2 - Orphan instances for TH datatypes  https://hackage.haskell.org/package/th-orphans-0.13.2 (MichaelSloan)
17:18:28 <Welkin> you can have a local hoogle
17:18:36 <Welkin> I never figured out how to set it up though
17:19:39 <kadoban> I think you just install the executable and then download a database, I know there's a link for the ones from stackage somewhere, but I've never tried them.
17:19:58 <kadoban> Or I'm sure you can build one too, no idea how though.
17:25:17 <gfixler> (a -> b -> c) -> (d -> a) -> (e -> b) -> d -> e -> c
17:25:23 <gfixler> anyone recognize this? hoogle doesn't
17:25:50 <dmj`> :t on
17:25:52 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
17:26:01 <dmj`> not quite
17:26:13 <gfixler> yeah, it's like on with one more conversion function
17:26:25 <kadoban> Not sure that one has a nice name, that I can think of at least.
17:26:42 <Axman6> @djinn (a -> b -> c) -> (d -> a) -> (e -> b) -> d -> e -> c
17:26:42 <lambdabot> f a b c d e = a (b d) (c e)
17:28:08 * hackagebot web-routes 0.27.11 - portable, type-safe URL routing  https://hackage.haskell.org/package/web-routes-0.27.11 (JeremyShaw)
17:28:16 <Axman6> @pl f a b c d e = a (b d) (c e)
17:28:16 <lambdabot> f = ((flip . ((.) .)) .) . (.)
17:28:43 <Axman6> it's almost like bimap
17:28:50 <Axman6> :t bimap
17:28:52 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
17:29:26 <gfixler> ah, yes, close
17:29:37 <gfixler> that's why it felt familiar, I think
17:29:42 <gfixler> was playing with those weeks ago
17:30:27 <gfixler> > bimap fst snd (2,"foo")
17:30:29 <lambdabot>      Couldn't match expected type ‘(a0, d)’ with actual type ‘[Char]’
17:30:29 <lambdabot>      In the expression: "foo"
17:30:29 <lambdabot>      In the third argument of ‘bimap’, namely ‘(2, "foo")’
17:30:39 <gfixler> ah, right
17:30:44 <gfixler> on the elements, not the whole thing
17:31:07 <gfixler> that would also be nice
17:31:30 <gfixler> (a -> b -> c) -> (d -> a) -> (d -> b) -> d -> c
17:31:44 <gfixler> do two different things to the input and merge them somehow
17:31:47 <joe9> Where can I find more details about the With typeclass?
17:34:00 <dmj`> joe9: lucid's haddocks
17:34:09 <dmj`> @package lucid
17:34:10 <lambdabot> http://hackage.haskell.org/package/lucid
17:37:39 <joe9> dmj`: Thanks.
17:40:33 <joe9> dmj`: I am trying to understand the interaction between with and script_ . The script_ takes an arg and returns result, correct?
17:41:33 <c_wraith> @tell Gurkenglas http://lpaste.net/171865
17:41:33 <lambdabot> Consider it noted.
17:43:09 <joe9> dmj' : using with, i can add attributes to basically any element.
17:45:26 <dmj`> joe9: yes, exactly
17:47:21 <Welkin> why lucid over blaze?
17:50:33 <mniip> :t (curry .) . (&&&)
17:50:34 <lambdabot> ((a, b) -> c) -> ((a, b) -> c') -> a -> b -> (c, c')
17:50:57 <joe9> Welkin, seemed that lucid is a progression over blaze.
17:51:10 <joe9> Welkin: dmj' suggestion too.
17:53:34 <buglebudabey> paging ertes 
17:57:14 <fragamus> hey what are the cool kids using instead of monad transformers
17:57:50 <c_wraith> monad transformers. :)
17:58:22 <fragamus> i heard about something else and i promptly forgot what it was called
17:58:28 <Welkin> fragamus: extensible effects
17:58:31 <Welkin> using Free
17:58:35 <dmj`> fragamus: tagged monad transformers
17:58:35 <fragamus> yeah
17:58:48 <fragamus> extensible effects
18:03:10 * hackagebot tcp-streams 0.3.0.0 - One stop solution for tcp client and server with tls support.  https://hackage.haskell.org/package/tcp-streams-0.3.0.0 (winterland)
18:18:10 * hackagebot PPrinter 0.0.1 - A generic, derivable, haskell pretty printer.  https://hackage.haskell.org/package/PPrinter-0.0.1 (iamzhenyi)
18:23:10 * hackagebot minecraft-data 0.1.0.0 - a DSL for generating minecraft commands and levels  https://hackage.haskell.org/package/minecraft-data-0.1.0.0 (JeremyShaw)
18:25:40 <lpaste> YellowOnion pasted “Laziness issues?” at http://lpaste.net/171868
18:26:00 <YellowOnion> Could someone explain why this^ happens
18:39:39 <adelbertc> is there a reason theres no MonadCatch EitherT instance?
18:39:40 <adelbertc> is it lawless?
18:41:52 <adelbertc> ah hm looks like it just doesnt have it on the path
18:43:11 * hackagebot isobmff-builder 0.9.0.0 - A (bytestring-) builder for the ISO-14496-12 base media file format  https://hackage.haskell.org/package/isobmff-builder-0.9.0.0 (SvenHeyll)
18:47:35 <phadej> adelbertc: use ExceptT
19:00:11 <tnks> I'm reading the servant white paper.  What exactly does "open" type classes refer to?  I tried Googling and didn't find hits.
19:00:30 <adelbertc> fancy seeing you here tnks 
19:00:31 <tnks> otherwise, I'll just keep on reading this writeup and see if it's explained in there.
19:00:51 <glguy> This: they are also known as type classes
19:00:59 <glguy> Tnks ^
19:01:16 <tnks> glguy: yeah, what in the world would "closed" type classes be?
19:01:16 <glguy> My phone thinks your name's not a word
19:01:50 <glguy> Ones that's didn't permit additional instances to be written
19:02:05 <tnks> glguy: oh, can Haskell do that kind of thing?
19:02:09 <glguy> No
19:02:11 <geekosaur> not with type classes
19:02:16 <tnks> thankfully.
19:02:18 <geekosaur> type families (ghc extension) can be closed
19:02:41 <tnks> geekosaur: okay, makes sense.
19:03:39 <tnks> I need to internalize type families more to get a better sense for when I might use them, and when they are the wrong abstraction.
19:03:55 <tnks> all variants included.
19:04:27 <tnks> I think I have a rough sense for when associated types come up.
19:04:43 <tnks> but type families can do more than just that.
19:05:17 <tnks> adelbertc: yeah, good to see you here too.
19:07:29 <platz> currently we have "class MonadTrans t where lift :: (Monad m) => m a -> t m a"
19:07:30 <platz> why don't we have "class MonadTrans t where lift :: (Monad m, Monad (t m)) => m a -> t m a" 
19:07:58 <platz> i.e. add a Monad (t m) constraint to make sure "t m a" is a monad as well
19:09:10 <c_wraith> platz: because any standard use of it will fail anyway if that constraint is missing.
19:12:50 <platz> i should try it out and see, but my first thought is that if (t m) is in fact a monad, then it wouldn't fail?
19:13:35 <platz> it might prevent intermediate forms that aren't monad i guess
19:18:18 <dmwit_> platz: Your proposed type doesn't make sure `t m a` is a monad. It only allows the definition of `lift` to use that fact when it's true.
19:19:08 <dmwit> platz: Indeed, after thinking about your question, I'm tempted to ask why the type of `lift` isn't `m a -> t m a` with no further constraints!
19:19:26 <platz> surely the same is true of (Monad m) ?
19:19:30 <dmj`> tnks: open type families can add instances, closed cannot
19:19:49 <dmwit> platz: Yes, it is. See my last message. =)
19:20:13 <platz> very interesting= :)!
19:21:37 <platz> of course I'm only asking because kmett's latest video lead off with a question about MonadTrans, but he went of to do much more interesting things 
19:22:14 <edwardk> platz: that isn't enough anyways
19:22:29 <edwardk> platz: That doesn't say that it works uniformly for all m
19:23:22 <platz> ah, it's not strong enough anyways then
19:23:24 <edwardk> dmwit: m a -> t m a with no constraints means you can't write WriterT or StateT. you need to get under 'm' to do stuff for them
19:24:18 <edwardk> Saying Monad (t m) there would pass in another dictionary, which maybe might be useful, but the writer of the instance here gets to know t concretely, so if Monad m :- Monad (t m) then this gains you no benefit
19:24:35 <edwardk> they still can't derive Monad m :- Monad (t m) from Monad m, Monad (t m)
19:25:37 <edwardk> platz, dmwit: you need Monad m => .. there since m doesn't appear in the class constraint
19:26:22 <edwardk> MonadTrans is (almost) 'Pointed' for the category of monads over haskell, except it doesn't prove the target is a monad
19:26:49 <edwardk> platz: hopefully my follow up talk from zurihac will go up soon
19:27:01 <edwardk> there i decided to rephrase everything in terms of monad homomorphisms
19:27:03 <platz> i enjoyed what was posted so far
19:27:21 <platz> even if i stuggle.. still thought provoking
19:27:28 <edwardk> this rather drastically simplifies the story
19:28:13 * hackagebot email-header 0.4.0 - Parsing and rendering of email and MIME headers  https://hackage.haskell.org/package/email-header-0.4.0 (KyleRaftogianis)
19:31:01 <platz> so in summary Monad (t m) is possible but doesn't add any power to the instance writer, and doesn't allow you to derive Monad m entails Monad (t m), which i think is what is really the goal, because that would give ghc more power
19:37:29 <edwardk> yep
19:37:48 <edwardk> we need Monad m :- Monad (t m) so that i can play the sort of games i play in the talk with tensor
19:37:55 <edwardk> you can't define Tensor with just your addition
19:38:47 <hypoon> Hi all. Do I understand correctly that (!!) is O(N), proportionate to the index?
19:39:03 <dmj`> yes
19:39:08 <ReinH> edwardk: o/
19:39:12 <edwardk> heya
19:39:25 <edwardk> :t (!!)
19:39:26 <lambdabot> [a] -> Int -> a
19:39:28 <edwardk> yep
19:39:42 <ReinH> edwardk: I'm going to try to write a better yi-style finger tree that uses a product monoid of chunk size and line number for the metric.
19:39:45 <edwardk> it is a linked list. you have to follow n links
19:40:46 <hypoon> Ok, that was my understanding exactly. What do I have to sacrifice in order to get O(1)?
19:41:01 <dmj`> purity
19:41:20 <dmj`> unless you use immutable arrays
19:41:22 <dmj`> afaik
19:41:29 <hypoon> I do not need mutability
19:41:32 <geekosaur> actually, you probably want Vector
19:42:00 <dmwit> hypoon: You have to sacrifice cheap cons/snoc. Not much else, I think.
19:42:00 <geekosaur> for most things. (linked lists are "default" because a linked list is the functional programming version of a foreach loop)
19:42:26 <dmwit> hypoon: You can keep cheap cons/snoc if you're willing to get O(log n) instead.
19:42:33 <dmwit> O(log n) indexing, that is
19:42:33 <geekosaur> but in general if you find yourself needing (!!) you should consider Vector
19:43:26 <edwardk> hypoon: infinite lists
19:43:37 <edwardk> hypoon: you can use a skew binary random access list and get O(log n)
19:43:43 <edwardk> you can use a flat array and get O(1)
19:44:36 <hypoon> The stored data type will probably be a function, does that change anything?
19:44:39 <edwardk> https://www.schoolofhaskell.com/user/edwardk/fibonacci/leonardo is an article i wrote that shows a nice new way to build O(log n) random access time lists with O(1) cons
19:45:51 <hypoon> I mean it'll end up something similar to [a -> b] rather than [c].
19:46:22 <edwardk> doesn't really help as the functions can be pretty much anything
19:46:22 <dmwit> doesn't really change anything
19:46:58 <hypoon> Ok. I figured some implementations would be restrictive of the type of value that can be contained.
19:47:10 <platz> and hashmaps would be O(log n) lookup & insert, of course
19:49:37 <hypoon> Is there overhead associated with using Vectors that would make lookups on a relatively short list (~1000 elements?) take longer than using a traditional linked list?
19:50:47 <c_wraith> hypoon: no.  It's bounds-checked, but that still should be many times faster than following a chain of pointers.
19:51:23 <c_wraith> hypoon: however, some version of Vector can store a thunk at a location which may not be evaluated until you demand it later.
19:54:17 <edwardk> hypoon: no. vectors are going to blow the doors off of a list here unless you need cheap cons.
19:54:38 <edwardk> c_wraith: this will be no worse than the list story, however
19:58:17 <hypoon> Ok. In my code, the obvious implementation would be a hashmap, Map (Int,Int,Int) (a->b), but I realized that I can use some cheap computation (bit-interleaving) in a ((Int,Int,Int) -> Int) function that would then produce consecutive numbers, which might as well be the indices in a Vector. Is this a bad idea?
20:00:02 <dmwit> Unusual as it is, Array may be a better interface than Vector for you.
20:01:03 <hypoon> dmwit: Why? I have no experience with either Array or Vector, so I don't know the important use-case differences.
20:01:21 <dmwit> Array has a smattering of sugar to make indexing with types other than `Int` convenient.
20:07:33 <hypoon> dmwit: I'm very concerned with performance. There's not going to be much computationally intensive stuff going on, but it needs to be able to do probably ~1000 of these lookups (plus other stuff) within a 10ms window. Is this reasonably achievable? Obviously it'll be hardware-dependent, but only within an order of magnitude or so.
20:11:45 <hypoon> Everything has overhead, but I just don't know how much. I love the convenience of coding in Haskell, but my understanding of high-performance Haskell is lacking. Normally I'd drop into C at this point and use FFI, but an array of functions isn't nearly as elegant in C.
20:12:18 <hypoon> ...and once again I realize that I'm overusing a certain sentence structure. Sorry for the boring phrasing.
20:13:36 <dmj`> hypoon: benchmark it w/ criterion, but vector is very close to C, esp. if it's in IO/ST
20:13:53 <geekosaur> I think with a 10ms window your biggest problem isn't vector, it's a gen2 gc at the wrong time
20:14:22 <dmj`> hypoon: check out hashtables
20:14:28 <dmj`> @package hashtables
20:14:28 <lambdabot> http://hackage.haskell.org/package/hashtables
20:14:30 <platz> gc in most langs could be 10-50ms
20:15:43 <wobnob> Hi all, does someone know why the :: is required when using maxBound / minBound? eg minBound :: Int8, and in what similar circumstances would one need :: when calling a function?
20:16:00 <dmj`> :t maxBound
20:16:01 <lambdabot> Bounded a => a
20:16:10 <shachaf> It's not needed when you can figure it out from the context.
20:16:18 <shachaf> It's the same situation for functions.
20:16:19 <geekosaur> wobnob, it needs some way to infer which Bounded instance to use. depending on context it may be able to figure it out itself
20:16:51 <wobnob> I see, thanks!
20:17:05 <verement> > maxBound || minBound
20:17:07 <lambdabot>  True
20:17:16 <Zemyla> Anything where the output type isn't inferrable from the input type. toEnum, fromInteger, read, etc.
20:17:20 * geekosaur bets that inferred ()
20:17:39 <Zemyla> > ord maxBound
20:17:41 <lambdabot>  1114111
20:17:41 <geekosaur> oh, no, would be Bool, dug
20:17:43 <geekosaur> duh
20:17:48 <hypoon> geekosaur: ugh... I forgot all about garbage collection. I was going to have multiple processes that communicate through a carefully synchronized protocol such that I shouldn't even need to break communication out into a separate thread... If they don't all GC at the same time, whichever processes *didn't* GC will be left waiting for whichever ones did.
20:18:16 <Zemyla> > decodeFloat maxBound
20:18:17 <lambdabot>      No instance for (RealFloat a0) arising from a use of ‘decodeFloat’
20:18:17 <lambdabot>      The type variable ‘a0’ is ambiguous
20:18:17 <lambdabot>      Note: there are several potential instances:
20:18:26 <Zemyla> Sigh.
20:19:03 <geekosaur> well, you could drop strategic performGC calls into the code, I guess
20:19:06 <geekosaur> @index performGC
20:19:06 <lambdabot> System.Mem
20:19:23 <hypoon> Is there a way to inhibit GC?
20:19:42 <hypoon> (And just take the responsibility upon myself to not run out of memory)
20:20:42 <platz> you can go off-heap with foreign pointers, but you might as well just delegate to ffi at that point
20:21:56 <platz> but I'd want to be sure that GC is truly an issue first
20:22:43 <geekosaur> right, depending on how your program allocates, it may not need to do gen2, and gc in the nursery is really fast
20:23:15 <platz> i've heard good things about ring buffers
20:25:11 <hypoon> geekosaur: can't you recommend any resources where I can read about gen2 gc?
20:25:49 <c_wraith> gen2 collection time is proportional to the number of pointers in the live set.
20:26:14 <c_wraith> At least until the next version of GHC, where compact regions will allow that to be optimized in some uses cases.
20:26:35 <hypoon> geekosaur: that was supposed to say "can", oops. Sorry for the tone.
20:26:45 <geekosaur> argh. my network is sucking really badly (except for IRC which because it's low usage I redirect over the work cellmodem....)
20:27:14 <hypoon> c_wraith: you're over my head :-(
20:27:17 <c_wraith> ever notice how everything good is in the next version of GHC?
20:28:08 <c_wraith> hypoon: which part?  The compact region stuff was just a silly aside
20:28:30 <hypoon> c_wraith: "live set" is unfamiliar terminology
20:28:41 <geekosaur> https://wiki.haskell.org/GHC/Memory_Management https://www.reddit.com/r/haskell/comments/3bx93a/haskellghc_garbage_collection/
20:28:46 <geekosaur> some references in those
20:29:19 <c_wraith> hypoon: the live set is the values that are still reachable via pointers from the GC roots
20:30:45 <c_wraith> hypoon: copying collectors don't care about how much garbage is present in memory - only how much you're still using.
20:39:53 <hypoon> I'm worried that the design of this code is getting extremely complex... perhaps hopelessly complex. This was all going to be tied into functional reactive programming, but for me, that's a headache of its own. I'm a long way from understanding FRP well enough to understand how the GC takes place.
20:44:32 <dmj`> hypoon: have you profiled and benchmarked it?
20:45:27 <hypoon> dmj`: No, I haven't even started coding yet. Still designing.
20:46:03 <dmj`> hypoon: what will your program do?
20:49:44 <hypoon> dmj`: That's a short question with a very long answer. It'll be a game engine server, designed from the ground-up to be scaleable using parallelism and distributed processing.
20:50:29 <Koterpillar> the one from Halting State?
20:50:35 <dmj`> hypoon: ambitious
20:51:20 <hypoon> Koterpillar: I don't know if you're directing that question to me, but I have no idea what you mean.
20:52:01 <Koterpillar> hypoon: "Halting State" is a sci-fi book featuring a game engine server, scaleable using parallelism and distributed processing.
20:52:10 <hypoon> dmj`: I recently returned from a week of hands-on high performance computing seminars. I'm full of ambition.
20:52:30 <hypoon> Koterpillar: Sounds like a book I need to read, haha!
20:53:17 <dmj`> hypoon: is the game going to run in the browser?
20:54:18 <hypoon> dmj`: The seminars were all geared around programming for scientific applications and running the software on high performance clusters (my "day job"), but I think the concepts are applicable to other use-cases.
20:54:29 <hypoon> dmj`: No, at least not initially.
20:54:57 <hypoon> dmj`: Eventually a browser client may be considered.
20:55:02 <ongy> I'm trying to install haskell-vim-now on my laptop and it is always failing while installing GHC with the super useful message "
20:55:11 <ongy> "stack setup failed with error 1"
20:55:25 <ongy> any pointer to what's going wrong?
20:57:46 <dmj`> hypoon: well, haskell is great for concurrency
20:57:57 <dmj`> ongy: did you use the -v flag? Might show more verbose output
20:57:58 <hypoon> ongy: What OS/distribution are you running?
20:58:28 <ongy> dmj`: the haskell-vim-now script does not have a -v
20:58:32 <ongy> hypoon: archlinux
20:58:43 <dmj`> ongy: oh, was assuming stack setup would
20:58:44 <Koterpillar> where is the script?
20:59:11 <Koterpillar> ongy: for archlinux, install haskell-stack and run 'stack setup' yourself, won't hurt
20:59:25 <Koterpillar> sorry, install 'stack'
20:59:28 <ongy> Koterpillar: https://github.com/begriffs/haskell-vim-now it was mentioned in here yesterday. Install worked no another machine
21:08:56 <ongy> ok, that's embbarrassing, of course it was libtinfo missing. And I played around with /tmp size...
21:09:26 <hypoon> dmj`: Concurrency and parallelism are wonderful in Haskell, yes, and even trivial uses net me 700% performance over 8 cores in my day job code. Not bad for quick work. Still, that's very different from the engine I'm designing now.
21:10:36 <hypoon> Anyway, thanks all for the info and suggestions. Koterpillar, thank you for the book suggestion, as well!
21:10:45 <hypoon> Goodnight!
21:12:58 <verrlara> ongy: :O
21:13:02 <verrlara> ongy: DOES THAT WORK?
21:13:32 <verrlara> ongy: vim into haskell ide??!
21:13:45 <ongy> installed on my pc yesterday, so haven't worked with it much yet, but I like it
21:14:03 <ongy> but: it overwrites the current vim-setup (makes backups)
21:14:24 <Koterpillar> looks tasty, but above is one more reason to learn it instead of using it
21:20:14 <ongy> ghc can make good use of my cpu. I haven't seen my laptop overheat often but it's starting to throttle
21:23:49 <mniip> can associated type families be closed?
21:25:37 <mniip> hmm
21:25:56 <mniip> Nat :: (FunctorOf p q f, FunctorOf p q g) => { runNat :: forall a. Ob p a => q (f a) (g a) } -> Nat p q f g
21:25:59 <mniip> makes much more sense
21:29:15 <mniip> edwardk, around?
21:33:18 * hackagebot hgeos 0.1.4.0 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.4.0 (rcook)
21:38:48 <dmwit> hypoon: Fortunately for me, I have not yet had to care much about performance. Unfortunately for you this means I don't know much about absolute speed of many things in Haskell.
21:43:48 <mniip> so wait
21:43:57 <mniip> is everyone replacing fundeps with associated type synonyms now
21:45:49 <glguy> I don't think everyone is, at least. associated types work well for the simpler cases
21:46:23 <alercah> Fundeps can capture some things that associated types can't easily.
21:46:52 <alercah> But associated types can also capture some hings that fundeps can't easily
21:48:39 <pollz> Hello! Every time GHCi does some manipulation on a complex number, it ends up with an imaginary part which is extremely small but not zero (1e-16 or so). Is there any way to set a limit for the precision?
21:48:52 <pollz> The imaginary part is supposed to be zero.
21:49:17 <jle`> pollz: what do you mean by a limit?
21:49:25 <jle`> for the 'Show' instance?
21:49:32 <jle`> *for displaying it on the screen
21:49:33 <pollz> Like below 1e-10 to be taken as zero.
21:49:45 <jle`> like automatic rounding?
21:49:51 <pollz> Yes.
21:49:53 <jle`> taken as zero with respect to what?
21:50:00 <pollz> Taken as 0.0
21:50:02 <jle`> multiplication, addition ... etc.?
21:50:07 <pollz> Yes.
21:50:50 <jle`> any reason why just rounding the answer when you're done wouldn't work?
21:50:55 <pollz> I mean, if I ask it what cis 2*pi is, the imaginary part is zero because the sine is zero, but it actually returns some number times 1e-17
21:51:13 <jle`> yeah, but what are you planning on using the number for in the end?
21:51:56 <pollz> jle`: I am trying to implement FFT and I would like the imaginary parts to be zero rather than this extremely small value. Yes, rounding in the end would work, but how do I round? Should I cast it as a fractional?
21:52:13 * mniip catches edwardk
21:52:25 <Rotaerk> edwardk is an exception?
21:52:33 * edwardk jumps out of the pokeball on the third shake.
21:52:39 <Rotaerk> or that
21:52:49 <edwardk> sup?
21:53:02 <pollz> Hehehe fun Pokepeeps here too.
21:53:13 <mniip> edwardk, in your hask thing, you're using class Category (p :: i -> i -> *) where type Ob p :: i -> Constraint
21:53:23 <mniip> why not type Ob p (a :: i) :: Constraint
21:53:41 <jle`> pollz: maybe you could just check if the imaginary part is within a threshold when it's important
21:53:43 <edwardk> because I need to be able to talk about Ob p       without an argument as a thing in places
21:54:06 <edwardk> lets look at a similar construction in there
21:54:24 <edwardk> class (Functor f, Dom f ~ p, Cod f ~ q) => FunctorOf p q f; instance ...
21:54:34 <mniip> oh
21:54:35 <edwardk> that is because I need to have Ob (Nat p q) = FunctorOf p q
21:54:37 <Rotaerk> pollz, http://stackoverflow.com/questions/12450501/round-number-to-specified-number-of-digits
21:55:11 <edwardk> in general pointwise things run into issues that the things with one fewer argument do not
21:55:43 <mniip> wait
21:55:50 <mniip> Nat p q is the category of functors, right
21:55:54 <Rotaerk> it does strike me as odd if there isn't a standard round-number-to-n-digits function..
21:56:18 <edwardk> yes, i realize i motivated this with an example that goes away if we fully expand Ob f to have another arg ;)
21:57:46 <mniip> edwardk, I came up with some fancy stuff, http://lpaste.net/171524 and then I was very disappointed to find out that you did the same in 2014 :(
21:58:10 <edwardk> heh
21:58:29 <edwardk> yeah, it is a fun pattern. the hask code shows Bifunctor is better as a derived thing though
21:58:43 <mniip> not sure about that
21:58:51 <metl> is there a way to browse packages sorted by all-time downloads (instead of last 30 days?)
21:58:53 <mniip> I had a lot of "fun" making cartesian product work
21:59:01 <metl> http://hackage.haskell.org/packages/top
21:59:10 <edwardk> well if you look at hask the approach is to do 'curried' category theory
21:59:12 <alercah> edwardk: I observed yesterday that the hask code shows that this is best done in a dependently-typed language :P
21:59:26 <dfeuer> Huh. Adding restrictKeys and withoutKeys to Data.Map and Data.IntMap required changes to 12 files.
21:59:31 <mniip>     type Ob (Cartesian k l) x = (x ~ '(Fst x, Snd x), Ob k (Fst x), Ob l (Snd x))
21:59:44 <edwardk> exploiting the fact that everything we can express is sufficiently 'locally small' to instead show that hom is a functor to a functor category, hence all the bifunctor stuff gets built that way
22:00:06 <edwardk> yep
22:00:49 <edwardk> alercah: a reasonable assertion as evidenced by the fact that i put it down and walked away rather than finish Appliative as a monoid in the category of endofunctors with regards to covariant day convolution
22:01:08 <mniip> edwardk, ooh I have that
22:01:12 <edwardk> mniip: anyways the point re bifunctor was that i started with what you have there
22:01:27 <edwardk> but then things like compose are functorial in the last 3 arguments
22:01:37 <mniip>     coassoc = NT $ \(Apply fx (Apply gy hz yzw) xwa) -> Apply (Apply (fmap xwa fx) (fmap yzw gy) (.)) hz id
22:01:37 <edwardk> so you have 2 bifunctor instances, 3 functor instances
22:02:02 <edwardk> but if you model a bifunctor just as a functor to a functor category it is induced by the functor definitions
22:02:04 <edwardk> same for profunctor
22:02:20 <edwardk> so those and contravariant are just given
22:02:26 <mniip> you mean, CxD->E  ~~ C->(D->E)
22:02:42 <edwardk> and every category p can be a functor from p^op -> [ p, Hask ]
22:02:48 <edwardk> yeah
22:02:56 <edwardk> that works because of the whole locally small thing
22:03:13 <edwardk> we can't think a thought 'big enough' that that isomorphism doesn't hold
22:03:52 <edwardk> anyways that stripped out about a third of the code and half the instances once i picked up that observation
22:04:33 <edwardk> we effectively model the arguments that way anyways, (->) :: * -> * -> * does the same thing with kinds
22:04:36 <mniip> also
22:04:47 <mniip> what would be the appropriate "dual" to Apply
22:05:08 <edwardk> Apply is covariant day convolution, you can build contravariant day convolution
22:05:16 <edwardk> i talk about it in my discrimination talk
22:05:41 <edwardk> google tech talk from last year: https://www.youtube.com/watch?v=cB8DapKQz-I
22:05:44 <shachaf> You can also define Day convolution with coproducts instead of products.
22:05:58 <edwardk> the open problem at the end is solved
22:06:07 <shachaf> It doesn't seem very useful, though.
22:06:14 <shachaf> What's the problem?
22:06:29 <edwardk> shachaf:  you can, and it is useful to at least come from coproducts in some situations but mapping onto the product is the only real useful case
22:07:03 <edwardk> there are 4 points in the design space going from Hask^op -> Hask, 2 suck
22:07:24 <edwardk> the problem of productive stable unordered discrimination. to make O(n) online nub
22:07:26 <edwardk> etc
22:07:43 <edwardk> that was resolved by creating the promises package
22:08:01 <edwardk> and then figuring out the more efficient group combinator using that
22:08:43 <edwardk> gershom pointed out to me that the function itself was monotone so there should be a productive way to do it, then i wracked my brain for a month and finally came up with a way to make lazy promises that would work
22:08:54 <shachaf> How productive can it really be?
22:09:15 <edwardk> it generates the most defined function that can exist
22:09:24 <dfeuer> ****ing cabal CI.
22:10:25 <edwardk> consider the grouping of  [(2,1),(1,2),(2,3)] as you inspect each element by equivalence class you get [[1,3],[2]] as the final answer
22:10:39 <edwardk> but after the first element is inspected you get [([1..)..
22:10:41 <shachaf> Oh, right, I see what I was missing.
22:10:57 <edwardk> then [([..),([2..)..
22:10:58 <shachaf> You can produce elements from the second bucket as soon as you see anything that goes in it.
22:11:04 <edwardk> [([1..),([2..)..
22:11:05 <edwardk> yeah
22:11:15 <mikeplus64> just in general, is it better to have lots of small transactions e.g. mapM_ (atomically . writeChan foo); or one large transaction e.g. atomically . mapM_ (writeChan foo) ?
22:11:19 <edwardk> so for instance nub, only needs the head of each list
22:11:29 <shachaf> Right.
22:11:40 <edwardk> mikeplus64: small transactions avoid livelock for this action, but risk it for others
22:11:55 <edwardk> mikeplus64: which action do you want to get screwed over by STM? =)
22:12:00 <shachaf> These promises are like IVars, I guess.
22:12:14 <shachaf> Except not in IO. And putting IVars in IO never seemed to make a lot of sense.
22:12:28 <edwardk> they are ivars with the funny property that they are lazily computed on demand.
22:13:15 <mikeplus64> I'm not sure what an IVar is, I'm out of touch
22:13:17 <edwardk> we have one linear sequence of lazy computation steps in the Lazy monad, and it runs enough of those instructions to fulfill the promise you demand
22:13:30 <edwardk> An IVar is a "promise" in other language vocabulary
22:13:49 <edwardk> i'm being careful to distinguish promises from futures
22:14:15 <edwardk> with futures you have something like an async computation. it can be eager or lazy, but you run the computation, it gives you a final answer and you plug it in
22:14:32 <edwardk> lazy futures are what we call thunks in haskell
22:15:10 <edwardk> with the usual promises you have a mailbox that some process will eventually put the answer into, a write once memory cell
22:15:17 <edwardk> and the ability to block waiting for it
22:15:29 <edwardk> normally this is sort of inherently eager
22:15:51 <edwardk> you have to have some other thread running as you don't know which thread in the program will fulfill the promise
22:16:30 <edwardk> unlike a thunk where the thunk itself captures the computation, and nobody else can tell your thunk what its final answer will be, they can only ask it to compute itself
22:16:46 <edwardk> in the discrimination example using thunks for the equivalence classes would be disastrous
22:17:04 <edwardk> it'd take O(nm) where n is the number of items and m is the number of equivalence classes to fully evaluate!
22:17:10 <edwardk> or it'd have to be offline
22:17:34 <edwardk> but with a form of 'lazy promise' I get that back down to O(n)
22:18:37 <edwardk> here the new quadrant in the lazy/eager future/promise design space comes from the fact that we _can_ know who fulfills a promise if we can't fork but only have a linear sequence of instructions that we pause after fulfilling the promise we need
22:18:44 <davids> Hi, someone could be help me with a install  of xmonad packages?
22:20:13 <edwardk> so    demand :: Promise s a -> a; (!=) :: Promise s a -> a -> Lazy s (); promise_ :: Lazy s (Promise s a); runLazy :: (forall s. Promise s a -> Lazy s b) -> a -- gives a pretty complete API once you add PrimMonad (Lazy s)
22:20:31 <Koterpillar> davids: #xmonad ?
22:20:41 <mankyKitty> Has anyone messed with Data.Conduit.Shell lately ?
22:20:53 <edwardk> demanding is a pure computation, (!=) assigns a value, promise_ creates a promise, runLazy runs a lazy computation with access to the final promise for fulfillment
22:21:33 <glguy> davids mankyKitty: unless you're taking a survey on what people are up to or capable of, you should just ask your questions
22:21:39 <edwardk> the key insight to making grouping work was that i can make a horrible PrimMonad based API
22:22:18 <edwardk> newtype Group a = Group { runGroup :: forall m b. PrimMonad m => (b -> m (b -> m ())) -> m (a -> b -> m ()) }
22:23:15 <edwardk> which says 'tell me how you want me to make an equivalence class in your monad m, which will give me back an operation to add more entries to the equivalence class' and with a side effect i'll give you a way to feed me (a,b) pairs.
22:23:30 <mankyKitty> glguy: Hrmm, survey isn't too far off. In a manner of speaking. :) I'll hold off questions for now though, I just noticed a "still experimental" sticker. Heh
22:23:46 <edwardk> that combined with the power of PrimMonad is enough
22:23:56 <edwardk> since I can pick m = Lazy s
22:24:18 <edwardk> and use the promises machinery and ability to make STRefs to pull off magic
22:24:41 <edwardk> https://github.com/ekmett/discrimination/blob/master/src/Data/Discrimination/Grouping.hs#L193
22:24:56 <davids> Koterpillar: Yes, I trying to install xmonad-contrib package (for install the tiling window manager), but appears this error: haskell-x11-xft: requires ghc=7.10.3-3 My current ghc version is local/ghc 7.10.3-3 The Glasgow Haskell Compiler and I am using the ArchHaskell repositories
22:25:15 <edwardk> Group is contravariant, and lets me do all the generics tricks
22:26:03 <edwardk> once that clicked into place i pretty much collapsed
22:26:07 <davids> I don't know if here is the best site for ask help.
22:26:37 <Koterpillar> davids: I use stack to install xmonad; maybe recompile that package with latest ghc?
22:26:39 <edwardk> davids: there is an #xmonad channel that might be a better resource
22:26:52 <edwardk> i haven't run xmonad in several years
22:28:33 <davids> <edwarks> The link in xmonad site redirect here.
22:30:46 <davids> Koterpillar: I'm trying to install using the steps gives in ArchWiki, Using terminal.
22:30:49 <platz> I know it's explained in parconc but I wouldn't have considered haskell thunks as 'futures' since i thought thunks were lazy but not async
22:31:38 <platz> maybe depends on ones definition of async
22:33:26 <pavonia> Does anyone see a way to resolve the explicit recursion that matches function? http://lpaste.net/171897
22:34:33 <Koterpillar> davids: why do you use ArchHaskell?
22:36:58 <dfeuer> Cale, https://github.com/haskell/containers/commit/1d2807a6e537f1de2e10bfef58d44229e225dc4e
22:38:23 <davids> Is not right?
22:39:00 <Koterpillar> davids: well, seems their packages are broken (lag behind)
22:39:19 <Koterpillar> davids: arch has ghc 8
22:39:34 <dfeuer> GHC 8 is bleeding edge.
22:39:47 <Koterpillar> so is arch
22:39:52 <davids> Oh! I use Manjaro, not Arch.
22:40:13 <lpaste> glguy annotated “How to resolve recursion?” with “How to resolve recursion? (annotation)” at http://lpaste.net/171897#a171898
22:40:30 <Koterpillar> then I can officially say "fix your broken OS", this is not really related to haskell
22:40:35 <Koterpillar> :P
22:40:35 <dfeuer> davids, for Haskell, you should look for installation instructions around haskell.org, not the Arch Wiki.
22:41:39 <davids> Okey, Let me see.
22:45:48 <edwardk> davids: it may, but there are 184 people sitting in the dedicated #xmonad channel right now
22:45:50 <pavonia> glguy: Thank you!
22:49:04 <YellowOnion> How do I run two haskell threads bound to the same OS thread? is this even possible?
22:54:00 <dmj`> YellowOnion: just don't use '-threaded', then all your threads are on the same os thread
22:54:28 <dmj`> :)
22:56:29 <YellowOnion> dmj`, that is very limiting though.
22:57:23 <Cale> @tell dfeuer cool :)
22:57:23 <lambdabot> Consider it noted.
22:58:10 <dmj`> YellowOnion: forkOn might be what you want, where you associate a thread with a capability
22:59:24 <YellowOnion> dmj`, I'm not sure either, the documentation talks about CPU affinity, not OS threads.
22:59:57 <YellowOnion> maybe my best bet is to only call forkOS once and dethread manually the stuff that needs to be bound.
23:00:23 <dmj`> hmmm
23:00:55 <Cale> YellowOnion: forkOS will make a Haskell thread which is bound to a particular OS thread, as far as I'm aware.
23:01:26 <Cale> Which is mainly only useful if it's a requirement of certain foreign libraries.
23:01:53 <YellowOnion> Cale, Indeed, but I want two threads bound to the same OS thread. both calling SDL functions.
23:02:33 <Cale> Can you perhaps just set up a single bound thread which reads IO actions from a Chan?
23:03:26 <Cale> and then you can pass the  writeChan c :: IO () -> IO ()  for that channel around your application to have it run things in the bound thread.
23:04:59 <Cale> If you don't mind the synchronisation, you could even carry the results back.
23:05:15 <YellowOnion> Cale, I guess that works for IO a too? though I don't really need that amount of flexibilty just yet.
23:05:53 <Cale> Well, you'd need something a little fancy if you want it to be polymorphic.
23:06:27 <Cale> But it should be possible...
23:06:55 <Cale> (though no promises it can be done without an unsafeCoerce)
23:08:21 <YellowOnion> Cale, I think I'm just going to have a single loop and write events to a chan for now.
23:30:02 <jle`> hm, how can i make parsers (choce [f1,f2] <*> px) backtrack to f2 if f1 succeeds but px fails?
23:30:09 <jle`> s/choce/choice
23:30:21 <jle`> er, `choice [try f1,f2] <*> px`
23:30:24 <jle`> i'm pretty sure i'm doing this wrong
23:32:11 <mniip> wait, D^C = [C, D] right
23:33:00 <mniip> jle`, choice [f1 <*> px, f2 <*> px], perhaps?
23:33:15 <mniip> is this parsec?
23:33:17 <jle`> boo :'(
23:33:21 <jle`> i think it's attoparsec
23:33:36 <jle`> that's essentailly what i'm doing for now
23:33:49 <mniip> choice $ [f1, f2] <*> px
23:33:51 <jle`> just thought there might be a nicer way
23:33:56 <jle`> oh that's cute
23:33:59 <jle`> do you mean [px]
23:34:01 <mniip> err needs more pure
23:34:02 <mniip> yes
23:37:07 <mniip> hmm, a diagram with two arrows from one object to another is by definition non-commutative, right
23:43:23 <shachaf> Why?
23:44:09 <shachaf> The arrows would have to be equal.
23:44:34 <Cale> Yes :)
23:45:05 <Cale> So if by "two arrows" you mean "two distinct arrows", then yeah, it's not commutative.
23:45:25 <mniip> shachaf, but that makes them one arrow
23:45:37 <shachaf> Well, they'd be labeled two different things.
23:45:43 <shachaf> It's just a graphical way to write the equation f = g
23:46:25 <dmwit> mniip: Would you object to a commuting square with two parallel sides labeled "id"? That's basically the same diagram, and seems like a perfectly cromulent commuting diagram to me.
23:46:25 <mniip> so such a diagram cannot have a limit, right
23:46:43 <Cale> mniip: No, such diagrams have limits quite often
23:47:04 <mniip> but if the diagram doesn't commute then how can a larger (limit) diagram commute
23:47:10 <shachaf> Are you talking about a *commutative* such diagram or just a such diagrams?
23:47:18 <shachaf> People take limits of non-commutative diagrams all the time.
23:47:20 <Cale> The limit of the diagram with two arrows in the same direction between two objects is called an equaliser
23:47:56 <Cale> In the category of sets, it can be realised as the set of points on which the two functions agree
23:48:25 <Cale> (i.e. the set of solutions x to f(x) = g(x)
23:48:26 <shachaf> But it's pretty boring when the diagram is commutative.
23:48:30 <Cale> yes
23:49:41 <dmwit> Cale: Shouldn't that be the limit of the V diagram? X ---f--> Y <--g--- X
23:49:55 <Cale> dmwit: That is the same thing
23:50:33 <shachaf> If you draw the diagram like that I'd be expecting a pullback instead of an equalizer.
23:50:53 <dmwit> Cale: No, the V diagram doesn't require f=g.
23:50:54 <mniip> shachaf, huh?
23:50:58 <Cale> huh?
23:51:05 <shachaf> dmwit: huh?
23:51:28 <shachaf> dmwit: An equalizer generally equalizes two different arrows.
23:51:33 <Cale> dmwit: It's physically the same diagram, it's just you've decided to write the same object twice, which doesn't actually affect anything.
23:52:29 <shachaf> mniip: Anyway, a diagram is just a functor. A commutative diagram is a diagram that factors through a poset.
23:52:33 <dmwit> Cale: I thought that, in such diagrams, one generally agreed that paths that start and end at the same place must be equal. So X with two arrows to Y labeled f and g would require f=g; whereas my diagram would not (because no paths share their endpoints).
23:52:48 <mniip> shachaf, a limit of a diagram requires commutativity
23:52:52 <Cale> dmwit: If you're requiring the diagram to commute
23:53:02 <shachaf> dmwit: I don't think anyone asks diagrams to commute in order to take the limit.
23:53:04 <dmwit> Cale: Surely the limit diagram is required to commute.
23:53:23 * hackagebot random-strings 0.1.0.0 - Generate random strings with specific qualities  https://hackage.haskell.org/package/random-strings-0.1.0.0 (mikehat)
23:53:32 <shachaf> The triangles commute, but that's all.
23:53:33 <Cale> Well, which limit diagram?
23:53:43 <mniip> ah
23:53:46 <mniip> just the triangles
23:54:04 <Cale> I think it would be good to say at this point what the actual condition is
23:54:11 <Cale> and then worry about which diagrams commute
23:54:28 <mniip> "a limit of a diagram F:D→C in a category C is an object limF of C equipped with morphisms to the objects F(d) for all d∈D, such that everything in sight commutes."
23:54:45 <shachaf> Allow me to provide a visual aid: https://twitter.com/copumpkin/status/302960443067101185
23:55:15 <Cale> Given f,g: X -> Y, and equaliser consists of an object E and arrow e: E -> X such that for any object E' and arrow e': E' -> X, there is a unique arrow u: E' -> E
23:55:47 <Cale> oh, let's put in the conditions :D
23:55:53 <dmwit> Okay, I was confused. I am unconfused now.
23:55:54 <shachaf> I don't think there's confusion here about what an equalizer is, just about what a general limit is.
23:56:05 <dmwit> mniip: The wikipedia page is a bit more precise than "everything in sight", and helped me.
23:56:10 <dmwit> https://en.wikipedia.org/wiki/Limit_(category_theory)
23:56:31 <Cale> Given f,g: X -> Y, and equaliser consists of an object E and arrow e: E -> X such that f . e = g . e, and for any object E' and arrow e': E' -> X, for which f . e' = g . e' there is a unique arrow u: E' -> E such that e . u = e'
23:56:40 <shachaf> Anyway this is all much more straightforward when you look at the adjunction view of things.
23:56:59 <shachaf> A cone is a natural transformation from a diagonal functor.
23:57:59 <Cale> I don't know about the adjunction view... but it might be worth mentioning the category of cones
23:59:43 <shachaf> I think that for defining "AxB is a product of A and B", "arrows : E -> AxB are in natural correspondence with pairs of arrows : E -> A, : E -> B" is the most straightforward definition you could ask for.
