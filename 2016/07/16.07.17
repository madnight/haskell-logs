00:03:08 <lpaste> ertes pasted ‚ÄúLighting calculation done in software‚Äù at http://lpaste.net/170102
00:07:36 * hackagebot stackage-curator 0.14.1.1 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.14.1.1 (MichaelSnoyman)
00:07:36 * hackagebot wai-middleware-crowd 0.1.4.1 - Middleware and utilities for using Atlassian Crowd authentication  https://hackage.haskell.org/package/wai-middleware-crowd-0.1.4.1 (MichaelSnoyman)
00:32:31 * hackagebot language-webidl 0.1.2.0 - Parser and Pretty Printer for WebIDL  https://hackage.haskell.org/package/language-webidl-0.1.2.0 (izgzhen)
00:47:32 * hackagebot mongoDB 2.1.0.2 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  https://hackage.haskell.org/package/mongoDB-2.1.0.2 (VictorDenisov)
01:00:29 <lpaste> ertes pasted ‚ÄúLighting + normal mapping + shadow mapping in software‚Äù at http://lpaste.net/170104
01:01:13 <saurabhnanda> what's the best way to memoize a function in Haskell?
01:01:50 <saurabhnanda> I'm trying to memoize DB lookups based on a primary key,  within a single request/response cycle (trying to reduce number of SQL queries)
01:05:26 <jle`> there are a couple of libraries on hackage
01:06:04 <jle`> i think people use data-memocombinators or representable-tries
01:06:51 <saurabhnanda> this one? https://hackage.haskell.org/package/memoize-0.7/docs/Data-Function-Memoize.html
01:07:10 <saurabhnanda> jle`:  will i need to introduce another monad and go around changing function signatures all over again, or is it a drop-in replacement?
01:07:14 <jle`> @hackage data-memocombinators
01:07:15 <lambdabot> http://hackage.haskell.org/package/data-memocombinators
01:07:19 <jle`> @hackage representable-tries
01:07:19 <lambdabot> http://hackage.haskell.org/package/representable-tries
01:08:09 <jle`> should just be a drop-in
01:09:38 <phadej> AFAICS those are for memoising pure functions, it doesn't help to memoise monadic actions, as you want to memoise their resources
01:09:45 <phadej> *their values
01:09:52 <saurabhnanda> how can http://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/Data-MemoCombinators.html be drop-in?
01:10:05 <saurabhnanda> isn't it expecting a Memo table to be passed around?
01:10:30 <jle`> saurabhnanda: if you write a function foo :: Int -> Bool, then 'integral foo :: Int -> Bool' is a memoized version of foo
01:10:31 <saurabhnanda> phadej: jle`: need to memoize DB lookups based on a PK value, over a short request/response cycle
01:11:41 <phadej> saurabhnanda: i.e. you need a cache on top of IO, I don't know whether there is good library for that (I did my own, unpublished)
01:11:54 <cocreature> haxl can do caching but it‚Äôs probably non trivial to move your stuff over to that
01:12:01 <saurabhnanda> jle`: hmm, let me try... how do I clear out the memo-table when the request/response cycle is complete
01:12:14 <saurabhnanda> what's haxl?
01:12:19 <saurabhnanda> cocreature: what's haxl?
01:12:25 <cocreature> https://github.com/facebook/Haxl
01:12:27 <saurabhnanda> phadej: why did you unpublish it
01:12:36 <saurabhnanda> cocreature: ah okay -- the applicative do thingie
01:13:05 <phadej> saurabhnanda: I mean, not-published (yet?)
01:13:11 <saurabhnanda> am I missing something, or is caching/memoization hard in Haskell?
01:13:16 <saurabhnanda> phadej: ah okay
01:13:48 <phadej> no, for monadic caching there is so much flavours that I personally not sure if my approach even suits everyone
01:14:24 <saurabhnanda> phadej: Isn't caching an IO action the most common case? Why not just stick the cache in an MVar and call it a day?
01:14:38 <saurabhnanda> and the action can access the MVar as well, because accessing MVar is also in IO
01:15:47 <phadej> saurabhnanda: well, that's already something. I use http://hackage.haskell.org/package/stm-containers so everything doesn't block on cache
01:16:21 <phadej> saurabhnanda: also I have dynamic container build around stm-containers, so you can stick anything Typeable there
01:17:01 <saurabhnanda> isn't anyone writing simple webapps in haskell? Isn't this a problem that a lot of people are already hitting?
01:17:28 <phadej> http://docs.futurice.com/haskell-mega-repo/servant-cache-0.2.0.0/Servant-Cache-Class.html#v:cachedIO
01:17:54 <phadej> but there are e.g. https://hackage.haskell.org/package/auto-update
01:18:38 <isovector> is there a way to reference an associated type synonym from outside of the defining typeclass?
01:18:53 <phadej> isovector: what you mean?
01:19:18 <saurabhnanda> thanks phadej. That's a lot of reading material for me.
01:19:53 <isovector> i have two functions of the form `A_App -> B_App`, where the difference is _App may or may not exist
01:20:32 <isovector> trying to consolidate this into one function: https://gist.github.com/isovector/48497057a45d8a68cdf220fb45798ce9  
01:20:48 <isovector> the only difference is the type signature and the function `runStoryApp`
01:21:15 <isovector> which itself is identical to `runStory` except for the type signature
01:21:57 <isovector> oh. actually i guess that's super easy. i just fill in `runStory` with its definition and move the constraints. #latenightproblems
01:38:43 <Sonderblade> in haskell, if you didn't 
01:38:53 <Sonderblade> hav the map functio, would you be able to write it?
01:39:30 <boj> Sonderblade: https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#map
01:40:10 <boj> you can click "source" from hackage documentation to see the implementation of everything
01:46:20 <jle`> @src map
01:46:20 <lambdabot> map _ []     = []
01:46:20 <lambdabot> map f (x:xs) = f x : map f xs
01:47:36 <cocreature> :t \f -> foldr (\x acc -> f x : acc) [] -- that‚Äôs also a nice implementation if you already have foldr
01:47:37 <lambdabot> Foldable t => (a -> a1) -> t a -> [a1]
01:47:47 <systemfault> Hmm.. perhaps with a fold: let myMap f =  foldr (\v acc -> (f v):acc) []
01:47:55 <systemfault> Ah :P
01:48:01 <cocreature> systemfault: close :)
01:48:14 <systemfault> :)
01:52:23 <scared> is there a way to use "@src map" from ghci? or a similar command that shows you the source
01:54:23 <Sonderblade> @src map :: (Char -> Char) -> ByteString -> ByteString
01:54:23 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
01:54:50 <shachaf> No.
01:55:00 <shachaf> You can use :i to see which module to look in for the source.
01:55:11 <Sonderblade> does that map overload has source somewhere? i can't find it
01:55:21 <shachaf> ByteStrings don't contain Chars, so that function doesn't make sense.
01:55:40 <shachaf> And Haskell doesn't support overloading of that sort anyway.
01:55:41 <Cale> Sonderblade: Perhaps you're thinking of Data.ByteString.Char8.map
01:56:18 <Cale> http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/src/Data-ByteString-Char8.html#map
01:56:52 <Cale> It's not actually overloaded, just a function with the same name
01:57:05 <Sonderblade> yes, but it just delegates to a B.map
01:57:25 <Sonderblade> i cant find the "B.map" anywhere
01:57:50 <scared> shachaf: yes, :i and :t are what i've been using so far. thanks anyways
01:58:03 <Cale> If we browse to the main Data.ByteString module: http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html
01:58:17 <Cale> and click the source link for map from there, we get: http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/src/Data-ByteString.html#map
01:59:45 <jle`> scared: @src is just a simple string search on a text file on lambdabot's server
01:59:51 <jle`> it doesn't actually find the source of anything
01:59:57 <jle`> it's pretty much the same as quote
02:00:02 <jle`> @quote
02:00:02 <lambdabot> Eiken says: honey badger doesnt care
02:00:45 <scared> jle`: alright, thanks
02:02:11 <Cale> It would be pretty cool for ghci to be able to provide source in cases where it actually happened to be available
02:02:37 <Cale> Still probably wouldn't work in cases like that one without some special provisions...
02:12:37 <izohask> LoggingT / NoLoggingT
02:12:45 <izohask> can I create function
02:13:02 <izohask> that can be easily run with both runLogging and runNoLogging
02:13:20 <izohask> without having to change type signature ?
02:13:49 <izohask> e.g. I have loadInput :: LoggingT IO Integer
02:14:06 <izohask> but I cannot run it with "runNoLoggingT loadInput"
02:14:27 <jle`> what library is this?
02:14:38 <izohask> Control.Monad.Logger
02:14:53 <jle`> yes, but what package?
02:15:03 <izohask> monad-logger
02:15:51 <phadej> izohask: use loadInput :: (MonadLogger m, MonadIO m) => m Integer
02:16:24 <phadej> then you can decide later which concrete implementation (NoLoggingT or LoggingT) to use
02:16:43 <izohask> phadej: great
02:16:46 <izohask> this works
02:16:54 <izohask> thank you , perfect
02:16:58 <phadej> np
03:21:01 <davidkart> hi
03:21:20 <davidkart> I finally factored my mastermind solver. Here, have a look : http://pastie.org/10909681
03:22:16 <lep-delete> can i get this typechecked w/o unsafeCoerce or another indirection? http://sprunge.us/eAZb
03:23:41 <phadej> lep-delete: you'd need a existential type indirection
03:23:54 <lep-delete> yeah that's what i thought
03:23:55 <shachaf> lep-delete: You want to give (ConstB "zero") the type forall x. Test x?
03:24:09 <phadej> as with construct :: Int -> Test x the caller can decide what `x` is.
03:24:29 <lep-delete> i want to make it impossible to create ConstC (ConstC ..) ..
03:24:37 <lep-delete> but i want to work with any Test x
03:25:16 <Cale> data AnyTest = forall x. AnyTest (Test x)
03:25:21 <lep-delete> yes
03:25:31 <lep-delete> but i want to work with Test directly
03:25:34 <lep-delete> no indirection
03:25:35 <Cale> too bad
03:25:37 <lep-delete> yah
03:25:45 <shachaf> The thing you wrote is a type error, though.
03:25:54 <shachaf> That's why it requires unsafeCoerce to make it type-check.
03:25:57 <Cale> Yeah, it doesn't make sense
03:26:07 <Cale> You want an existential
03:26:28 <Cale> You're not trying to say that for any type x, construct will take an Int and produce a value of type Test x
03:26:34 <Cale> Its implementation doesn't really do that
03:26:52 <phadej> lep-delete: separate Test into two types, or inline ConstA and ConstB into ConstCA and ConstCB ?
03:27:25 <lep-delete> problem is all these require another indirection
03:27:45 <lep-delete> in the end i would rather theoretically allow to construct ConstC (ConstC ..) ..
03:27:50 <lep-delete> than to add another datatype
03:27:52 <Cale> I'm not sure why that matters...
03:29:27 <jmi2k1> ?putStrLn
03:29:27 <lambdabot> Unknown command, try @list
03:29:34 <jmi2k1> @list
03:29:35 <lambdabot> What module?  Try @listmodules for some ideas.
03:29:59 <jmi2k1> ?src putStrLn
03:29:59 <lambdabot> putStrLn s = do putStr s; putChar '\n'
03:30:11 <jmi2k1> ?src getLine
03:30:11 <lambdabot> getLine = hGetLine stdin
03:30:17 <jmi2k1> ?src hGetLine
03:30:17 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
03:30:28 <jmi2k1> ?src putStr
03:30:28 <lambdabot> putStr s = hPutStr stdout s
03:33:37 <Cale> lep-delete: But yeah, you could just eliminate the ConstC constructor altogether, and have ConstCA :: Int -> Int -> Test and ConstCB :: String -> Int -> Test
03:35:30 <lep-delete> as i said i'd then just allow it on the typelevel
03:35:35 <lep-delete> would be cleaner
03:35:51 <lep-delete> coz im the one constructing values anyways
03:36:16 <lep-delete> it just would be nice to disallow illegal constructions on the typlevel
03:36:23 <lep-delete> w/o any indirection
03:41:17 <Cale> Allow what on the type level?
03:41:52 <Cale> I'm saying you have just one type Test, and it's just restructured slightly to not have any illegal cases
03:45:51 <lep-delete> making one data-constructor for every valid combination is very ugly
03:46:23 <lep-delete> data Test = ConstA | ConstB | ConstC Test
03:46:40 <lep-delete> i just want it so that ConstC cant be constructed with any ConstC again
03:46:44 <lep-delete> just ConstA or ConstB
03:46:56 <zort> hello, what's the equivalent of rm -rf ~/.ghc on windows, using the cabal that comes with Haskell Platform?
03:49:19 <lep-delete> from my code i know that ConstC will never be constructed with another ConstC
03:49:30 <lep-delete> but i just thought it would be neat to let GHC typecheck it
03:49:43 <zort> I guess it's C:\Users\Eitan\AppData\Roaming\ghc
03:50:03 <lep-delete> if i'd have to introduce any new indirections i would just leave it
03:50:15 <lep-delete> because, as i said i know there wont be an illegal construction
03:59:33 <ongy> is there a haskell package that has more locales than defaultTimeLocale?
04:00:36 <Kimae> can you help me improve my function which recursively lists all files of a directory?
04:00:55 <Kimae> http://lpaste.net/170116
04:02:38 <ongy> Kimae: you have another doesDirectoryExist in line 10, why?
04:04:09 <pavonia> There already is an ifFn
04:04:11 <Kimae> well to destinguish if it's a directory or a file
04:04:12 <pavonia> :t bool
04:04:13 <lambdabot> a -> a -> Bool -> a
04:04:57 <Kimae> oh ok
04:06:06 <cocreature> ongy: I think your best bet is calling locale and parsing the output at least if you‚Äôre on linux or os x like it is down in https://hackage.haskell.org/package/current-locale-0.2.0.1/docs/src/System-CurrentLocale.html#currentLocale. Surprisingly that doesn‚Äôt seem to be packaged up nicely somewhere
04:08:49 <Kimae> ongy: first one is to check if root dir is there. other is to tell directory from file.
04:10:33 <cocreature> Kimae: you should catch the exception when calling getFiles instead of checking if the directory exists. otherwise you suffer from a race condition if the directory is deleted in between
04:12:36 <Kimae> right :)
05:13:52 <tpsinnem> hey -- i was reading this: https://ocharles.org.uk/blog/posts/2016-01-26-transformers-free-monads-mtl-laws.html
05:14:15 <tpsinnem> at the point with "data Sum f g a" etc, there's "deriving (Functor)"
05:14:26 <tpsinnem> i'd like to understand that part
05:14:55 <tpsinnem> will it derive Functor for any 'f' and 'g'?
05:15:15 <tpsinnem> or is there implicitly some dependency of functorness of those parameters?
05:15:27 <alercah> tpsinnem: it would be Functor (Sum f g)
05:15:37 <alercah> since Functor takes a * -> *
05:15:56 <tpsinnem> yeah
05:16:58 <tpsinnem> i'm curious what might be good reading on 'deriving' and what it can do and when
05:17:51 <Maxdamantus> Well, when you do `data Foo a b c = .. deriving Show`, it gives you `Show (Foo a b c)`
05:17:57 <alercah> tpsinnem: this is GeneralizedNewtypeDeriving
05:18:14 <alercah> or DeriveFunctor
05:18:17 <Maxdamantus> (with some constriants)
05:18:19 <alercah> look them up in the GHC manual
05:18:25 <tpsinnem> ok thanks
05:19:18 <tpsinnem> i'm still curious if anyone can say off the top of their heads whether a functor instance in such a case will indeed require f and g to be functors
05:19:37 <tpsinnem> though i can probably figure it out from the docs with a bit of effort
05:20:02 <alercah> tpsinnem: it might, if they are * -> *
05:20:05 <alercah> it won't if they are *
05:20:05 <troydm> I'm trying to run my haskell process as daemon using MissingH package's detachDaemon function on linux 14.04 ubuntu machine and it exists and since it sets /dev/null I can't seem to find the reason why it's not working
05:20:10 <troydm> any suggestions?
05:20:37 <Maxdamantus> troydm: strace?
05:21:09 <troydm> Maxdamantus: tried it but I can't seem to figure out the reason, I'm not good at reading strace logs
05:21:22 <troydm> Maxdamantus: I can dump the output to hpaste 
05:21:41 <Maxdamantus> It's just as a workaround for the /dev/null thing.
05:22:09 <Maxdamantus> unless something is detecting that the output is /dev/null, you'll see whatever writes would normally happen, through ptracing it.
05:23:47 <troydm> here is strace output http://lpaste.net/8644639715003203584
05:24:46 <tpsinnem> ^ crap, apologies -- the text answers my question pretty much right there
05:38:07 <trilog> hey, can I use uncurry in situations like this: foldr (\(t1, t2) -> (=<<) (subst t1 t2))
05:39:21 <ahihi> @pl \(t1, t2) -> (=<<) (subst t1 t2)
05:39:21 <lambdabot> uncurry (((=<<) .) . subst)
05:40:01 <trilog> oh nice
05:40:16 <ahihi> not very readable :)
05:40:18 <trilog> but it is looking very verbose
05:40:18 <trilog> yeah
05:41:23 <ahihi> (=<<) . uncurry subst?
05:42:34 <trilog> thanks, it seems to work :)
05:42:41 <Maxdamantus> :t \subst -> (=<<) . uncurry subst
05:42:42 <lambdabot> Monad m => (a1 -> b1 -> a -> m b) -> (a1, b1) -> m a -> m b
05:48:52 <ongy> Is there a printf version for Data.Text (from text)?
05:53:28 <superlinux> hello. I am trying to "cabal install glade" , and I am getting the error: SetupWrapper.hs:60:49: error:
05:53:28 <superlinux>     Ambiguous occurrence ëexeExtensioní
05:53:28 <superlinux>     It could refer to either ëDistribution.Simple.BuildPaths.exeExtensioní,
05:53:28 <superlinux>                              imported from ëDistribution.Simple.BuildPathsí at SetupWrapper.hs:11:40-51
05:53:28 <superlinux>                           or ëSystem.Directory.exeExtensioní,
05:53:30 <superlinux>                              imported from ëSystem.Directoryí at SetupWrapper.hs:23:1-23
05:53:32 <superlinux>                              (and originally defined in ëdirectory-1.2.6.2:System.Directory.Internal.Configí)
05:55:39 <superlinux> Do you know a gui library that can compile without troubles??? I just want to start writing in haskell
06:00:23 <sm> superlinux: fltkhs maybe
06:03:17 <tpsinnem> handwavey question: in "pipes", is it possible to take a "Pipe a b m r" into a pair of "(Consumer a m r, Producer b m r)" so that from a "(con, prod)" you could pass "con" somewhere and "prod" somewhere, and data passed to "con" would result in corresponding output from "prod"?
06:11:03 <mkloczko> Is there a way to force an expression inside a rewrite rule ? I'd like to have an recusrive rewrite rule: http://lpaste.net/3993867196374712320
06:11:40 <bennofs> tpsinnem: that sounds like a job for pipes-concurrency
06:11:43 <bennofs> https://hackage.haskell.org/package/pipes-concurrency
06:12:20 <bennofs> tpsinnem: you would create an Input and an Output, and then spawn a thread to transform messages from Input to Output using the Pipe
06:13:13 <tpsinnem> bennofs: thanks, i'll look into that
06:16:03 <superlinux> sm, fltk doesnot support arabic language
06:27:06 <Iceland_jack> ongy: 
06:27:09 <Iceland_jack> @hackage formatting
06:27:09 <lambdabot> http://hackage.haskell.org/package/formatting
06:28:58 <Iceland_jack>     format (int%" is "%string) ::
06:28:58 <Iceland_jack>       Int -> String -> Text
06:29:24 <Iceland_jack>     >>> format (int%" is "%string) 10 "Hi"
06:29:24 <Iceland_jack>     "10 is "hi"
06:31:45 <eklavya> I was told here that Handles are threadsafe
06:32:09 <eklavya> but the Parallel and concurrent programming book says "If multiple threads write to a Handle simultaneously, the messages might get interleaved in an arbitrary way."
06:32:30 <eklavya> are they talking about different things?
06:39:21 <ongy> eklavya: iirc one write will finish before another one starts. But the order of your write calls may not be deterministic, which is pretty much implicit with multithreading
06:40:23 <eklavya> ok so the "interleaving" is at message boundary and not at byte level ?
06:40:31 <eklavya> I mean messages won't be mixed
06:40:40 <ongy> I
06:40:42 <ongy> I
06:40:46 <eklavya> the message order is indeterministic
06:40:49 <eklavya> right?
06:40:51 <ongy> ahhh -.- I'm not 100$ sure but from what I have seen
06:42:44 * hackagebot relational-query 0.8.3.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.8.3.0 (KeiHibino)
06:45:48 <tpsinnem> bennofs in case you're interested in me thinking aloud, i suppose what i'd want is a Pipe sandwiched between two such (output,input) pairs, i.e. create an (outputA, inputA) and an (outputB,inputB), connect (fromInput inputA) >-> myPipe >-> (toOutput outputB), run that in another thread, and return (toOutput outputA, fromInput inputB)
06:55:30 <bennofs> tpsinnem: exactly
06:57:51 <asdf1010> guys, a quick question, if you don't mind: why the type of `(putStrLn >> return True)` is `String -> Bool`? shouldn't it be `String -> IO Bool` instead? since `>>` "returns" `m b`
06:58:53 <hpc> (>>) :: m a -> m b -> m b
06:58:58 <hpc> you're applying it first to putStrLn
06:59:09 <hpc> putStrLn :: String -> IO ()
06:59:19 <hpc> or, (->) String (IO ())
06:59:27 <hpc> so m = ((->) String)
06:59:43 <hpc> (>>) :: (String -> a) -> (String -> b) -> (String -> b)
07:00:02 <hpc> return True :: m Bool, or String -> Bool with that particular m
07:00:22 <hpc> so b = Bool, and the final result is (String -> Bool) after you apply those parameters
07:00:31 <asdf1010> hpc: hmm, i wasn't aware of this kind of desugaring `->`
07:00:49 <hpc> it's not desugaring, it's just following the standard unification rules
07:00:57 <asdf1010> hpc: right, ok
07:01:00 <hpc> (which are what runs type checking / inference)
07:01:38 <hpc> you just need to apply putStrLn to something and it'll figure out that m = IO and then it makes more sense
07:02:31 <liste> :t (Just >> return True)
07:02:32 <lambdabot> a -> Bool
07:05:05 <asdf1010> hpc: is there a way to get a `String -> IO Bool` function that always does `return True`? like compose them in some way, i'm not sure; the actual function i'm using (instead of `putStrLn`) takes a hell lot of params; i don't want to spell them all out, i just want to "call" it (gosh, talking about "calling" and "returning" in the context of Haskell makes me anxious) in the... point-free style it's called, right? and mask the `IO ()`
07:05:09 <asdf1010> and `return True` instead
07:06:12 <hpc> @unmtl ReaderT String IO
07:06:13 <lambdabot> Plugin `unmtl' failed with: `ReaderT String IO' is not applied to enough arguments, giving `/\A. String -> IO A'
07:06:18 <hpc> @unmtl ReaderT String IO Bool
07:06:19 <lambdabot> String -> IO Bool
07:06:25 <hpc> that's probably what you want
07:06:58 <liste> :t (\a -> putStrLn a >> return True)
07:06:59 <lambdabot> String -> IO Bool
07:07:04 <Eduard_Munteanu> :t const (return True)
07:07:05 <lambdabot> Monad m => b -> m Bool
07:07:26 <hpc> or just that, it depends on how extensively you need that sort of behavior
07:09:40 <asdf1010> hpc: monad transformers? not quite on that level yet, sadly
07:09:52 <asdf1010> like this? (putStrLn >>= (const (return True))) "foo"
07:10:00 <asdf1010> but "foo" never actually gets printed
07:10:31 <asdf1010> i know about lazy evaluation and stuff, but how do i get the IO action to get executed?
07:10:34 <asdf1010> not sure...
07:10:59 <asdf1010> in other respects, it's a perfect solution
07:11:41 <hpc> what's wrong with putStrLn "foo" >> return True?
07:12:43 <asdf1010> any way to factor "foo" out? so that i get a function which accepts a String and returns IO Bool
07:12:53 <asdf1010> it's much more parameters than a single String
07:13:02 <hpc> :t (\a -> putStrLn a >> return True)
07:13:03 <lambdabot> String -> IO Bool
07:13:40 <asdf1010> hpc: i just don't want to write down the parameters of `putStrLn`
07:13:52 <asdf1010> hpc: but ok, nevermind, guess have to write them down after all
07:13:59 <asdf1010> anyway, thank you everyone!
07:17:49 <bennofs> asdf1010: try putStrLn >=> const (return True)
07:17:56 <bennofs> asdf1010: if you really want that
07:18:43 <bennofs> (although I like \a -> putStrLn a >> return True better from a code clarity POV)
07:20:56 <asdf1010> bennofs: yeah, looks fishy
07:21:31 <asdf1010> bennofs: although it works! so thank you, but probably gonna go with the earlier solution
07:57:46 * hackagebot dlist 0.8 - Difference lists  https://hackage.haskell.org/package/dlist-0.8 (SeanLeather)
08:17:47 <Gurkenglas> :t putStrLn "asd" $> True
08:17:49 <lambdabot> IO Bool
08:34:19 <hc> hi
08:34:32 <hc> i'm trying the example shown at https://hackage.haskell.org/package/persistent-2.0.0/docs/Database-Persist-Types.html#t:PersistValue
08:34:37 <hc> (the PersistField Geo) thingy
08:34:47 <hc> When compiling it together with persistent.th, I'm getting this error:
08:35:20 <lpaste> hc pasted ‚Äúghc-error-persistfieldsql.txt‚Äù at http://lpaste.net/170147
08:35:28 <hc> any hints on resolving this? :)
08:38:12 <joe9> I have an exception file does not exist when some code calls openFile. Is there any way to figure out which code might be making that openFile call?
08:39:00 <joe9> I checked my code and I use System.IO.Strict readFile. But, I do not have any openFile calls in my code.
08:45:28 <hc> ok, solved it by putting the Geo type in s separate file
08:46:02 <Gurkenglas> Proposal: Desugar "a = b" to "let a = b" in do block for less indentation. Proposal 2: Main modules that do not define main are treated as a do block defining main.
08:46:12 <Gurkenglas> *in do blocks
08:49:01 <MarcWeber> http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html Which is the Haskell answer to what might be a problem having too many concurrent connections ? Is this still valid? Does Xen (running on linux itself) solve it (halvm) AFAIK they have memory copying technics to forward packets
08:58:32 <Gurkenglas> Data.Void should have define (Void -> a) -> a
08:58:36 <Gurkenglas> -have
08:59:34 <Gurkenglas> (It transforms foldr id undefined into datavoidshoulddefinethis . foldr1 (.)!)
09:00:34 <Gurkenglas> Waaait no that's (() -> a) -> a my bad.
09:02:12 <Gurkenglas> And that doesn't work either because the folded list is supposed to be [b -> b], not [() -> ()]. How do we get rid of that undefined?
09:05:04 <ertes> MarcWeber: simply using concurrency together with efficient protocol implementations (like snap-server and warp) already gets you closer, but if you use linux, the kernel gets in your way very early:  for some reason it won't let your process have more than 1024 file descriptors
09:05:52 <Gurkenglas> :t ($undefined) -- that kinda looks right, but comes without the gurantee I want that the undefined isn't used... oh, the undefined is a promise that the list to be folded is infinite, that's why you can't get rid of it! Alright.
09:05:53 <lambdabot> (a -> b) -> b
09:06:31 <ertes> MarcWeber: linux is terrible for scalability in general‚Ä¶  one thing you can do to bypass it is to give your application the necessary privileges to implement the network stack yourself‚Ä¶  i think there is an IP implementation somewhere on hackage to take inspiration from
09:07:47 <ongy> I know I have seen (.:) somewhere as extension to (.), but I can't find it. Which package is it in?
09:08:40 <geekosaur> ertes, ulimit -n. on my system the hard limit is 4096 (to go above that you need root)
09:09:07 <geekosaur> there are ways to change this, and on servers one generally does.
09:10:07 <ertes> geekosaur: you probably won't handle 10M connections that way
09:10:38 <liste> @hackage composition -- ongy, at least here
09:10:38 <lambdabot> http://hackage.haskell.org/package/composition -- ongy, at least here
09:11:12 <ongy> liste: thx
09:12:48 * hackagebot mios 1.2.1 - A Minisat-based SAT solver in Haskell  https://hackage.haskell.org/package/mios-1.2.1 (shnarazk)
09:12:50 * hackagebot verbosity 0.2.2.0 - Simple enum that encodes application verbosity.  https://hackage.haskell.org/package/verbosity-0.2.2.0 (PeterTrsko)
09:13:29 <geekosaur> that said, linux does have scalability issues; this isn't really one, it's just unix's history of being a multiuser system where you generally don't want one user to starve others' use
09:21:19 <ertes> geekosaur: i don't see why a kernel can't give a process unlimited FDs on a multi-user system *by default*‚Ä¶  it's giving users unlimited processes and RAM by default, so they can starve others anyway, if they choose to
09:23:29 <geekosaur> processes aren't unlimited, just a fairly high limit tuned for desktop usage. which would also be how the file descriptor limit is tuned, thus making it lower to match expected desktop usage.
09:23:49 <geekosaur> but "of course" you know your use case is the only one that matters and every linux kernel must come tuned for it and nothing else
09:24:54 <geekosaur> (!@##% gnome *will* screw you over if you give it that much rope. kde's database backend has had its "moments" as well.)
09:25:31 <orion> Anyone know of any Haskell packages that can do basic signal processing?
09:26:19 <elpatron> There is something called DSP https://hackage.haskell.org/package/dsp
09:26:54 <elpatron> I've never use it though
09:26:57 <geekosaur> but this is why there are mechanisms to tune these so you can configure something more suitable for servers, where the default is tuned for desktop distributions
09:27:58 <orion> elpatron: Thanks.
09:31:11 <ertes> geekosaur: that's not the point‚Ä¶  my question is: why is there a limit in the first place?  sure, it could catch buggy software, but that suggests that *developers* may want to turn on such a limit‚Ä¶  does the kernel just assume that software is crappy and will run amok with FDs?
09:31:45 <geekosaur> yes and I just gavce you two examples to ignore because they're not relevant to you and therefore not relevant to anyone
09:32:49 * hackagebot pandoc 1.17.2 - Conversion between markup formats  https://hackage.haskell.org/package/pandoc-1.17.2 (JohnMacFarlane)
09:33:38 <geekosaur> the kde one is hopefully historical, but recent. gnome happens often enough to make me wonder if red hat is hiring rejects from the microsoft office dev team
09:34:25 <ertes> geekosaur: calm down, please‚Ä¶  i'm not ignoring anything, i'm just questioning it, because i'm curious as to why such a limit would be the default
09:42:07 <ertes> historically speaking i've seen a lot of C software that would just allocate an array of a predefined size in order to avoid having to deal with allocation‚Ä¶  a lot of C software did that and probably still does
09:42:14 <ertes> "want more of these?  recompile me!"
09:42:27 <ertes> i always imagined the FD limit to be along those lines
09:44:20 <mniip> iirc it is
09:44:30 <mniip> considering the implementation of FD sets
09:46:26 <geekosaur> select() using fixed size bit vectors is the kind of thing you'd expect from grad students in 1980. which is why poll()/epoll()/kqueue/other more modern implementations of the idea that aren't quite as half-assed
09:47:30 <geekosaur> in any case much of the question here is one of history. memory issues were self-limiting when CPUs couldn't address more than 64kB in a process, and process issues self-limiting when fork() took a couple seconds to run on a "fast" computer
09:48:57 <geekosaur> but historically there weren't any such "natural" restrictions on opening files
09:50:01 <ertes> unix was originally a 16-bit cooperative multi-tasking system, right?
09:50:51 <geekosaur> also notable is that back when this stuff was canonified, the only way to up either the user or system hard file limits was to recompile the kernel (and then about half of userspace because aspects of this leaked into braindead apis such as select())
09:51:33 <monochrom> gentoo fans would love that
09:52:37 <geekosaur> it was never cooperative multitasking
09:52:53 <geekosaur> well, possibly in unix v1 or 2, when it was purely research
09:53:52 <geekosaur> but a large part of the point of unix was to translate previously complex preemptive multitasking down to minicomputers (cf. "unix" being a pun on MULTICS)
09:55:15 <ertes> the irony is that it's the *cheap* features (FDs, shared memory) that the kernel developers choose to limit by default, which is telling about the way people write software
09:56:34 <ertes> if kernel devs feel responsible to keep GNOME/KDE software in check, it's very telling
09:58:07 <geekosaur> they feel responsible to try to make sure the system isn't rendered completely unusable. there are limits though (there's a Linus rant around from when Poettering tried to patch the kernel to auto-restart systemd because it had so many crash bugs)
09:59:25 <geekosaur> that said, it's a sad fact that an awful lot of the Linux dev universe lives inside of Red Hat now and pursues its own agenda, effectively forcing it on everyone else
10:02:04 <monochrom> this is how FOSS is paid for.
10:02:40 <Clint> byorgey: https://buildd.debian.org/status/package.php?p=haskell-diagrams-lib
10:02:54 <geekosaur> this said, please note that on linux these things have been tunable from userspace for at least 15 years, and while the kernel comes with defaults, the ones you actually see are set by init/systemd/upstart/whatever and are the responsibility of whover put together your linux distribution
10:03:56 <ertes> i have no idea, which part of my system sets it‚Ä¶  i don't really understand most of my system
10:04:03 <geekosaur> there *are* linux distros out there that come out of the box with more large-server-friendly configs --- but the vast majority of distros default to desktop config, and generally one handles this right after install by adjusting the appropriate config file to make the limits match the expected load.
10:04:13 <ertes> since systemd i understand it even less
10:04:56 <a6a3uh1> @hoogle [a] -> [a]
10:04:59 <lambdabot> Prelude cycle :: [a] -> [a]
10:04:59 <lambdabot> Data.List cycle :: [a] -> [a]
10:04:59 <lambdabot> Prelude init :: [a] -> [a]
10:05:26 <a6a3uh1> @pl \xs n -> take n xs
10:05:26 <lambdabot> flip take
10:05:34 <glguy> a6a3uh1: You can play with lambdabot in /msg
10:05:43 <a6a3uh1> > take 5 [1..]
10:05:45 <lambdabot>  [1,2,3,4,5]
10:08:34 <ertes> in many ways i feel about my linux system today the way i felt about my windows system back in ~2001 when i made the switch‚Ä¶  only difference: i have no idea what to switch to
10:08:58 <hpc> bsd lol
10:09:02 <cocreature> hurd
10:09:23 <monochrom> windows
10:09:36 <a6a3uh1> @hoogle (&&&)
10:09:36 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
10:09:40 * geekosaur keeps wanting to bolt back to freebsd, but hardware support only gets harder all the time with more complex hardware and vendors only writing linux drivers x.x
10:11:09 <geekosaur> ...but for pretty much anything network related *bsd blows linux away without even noticing it
10:11:13 <ertes> FreeBSD doesn't have namespaces‚Ä¶  one of the more useful features of modern linux
10:11:25 <glguy> This might be a #haskell-offtopic discussion
10:12:12 <travism> Anyone read Thinking functionally with Haskell?
10:12:21 <ertes> yeah, and it probably won't have a satisfying conclusion for anyone either, so let's get back to things we enjoy =)
10:12:43 <ertes> > let 2 + 2 = 5 in 2 + 2
10:12:45 <lambdabot>  5
10:16:14 <CindyLinz> Please stop doing this.... XD
10:18:37 <nshepperd_> Gurkenglas: what is foldr id undefined supposed to be?
10:18:45 <tomleb_> When will I be able to start from say a servant app, and add persistent to it by myself ? I use the servant-persistent repo to do it, but I can't understand everything it does and not close to do that by myself
10:19:37 <joe9> geekosaur: everyone keeps talking about bsd networking being better.
10:23:58 <ertes> CindyLinz: me?
10:27:50 * hackagebot genvalidity 0.2.0.0 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.2.0.0 (Norfair)
10:27:52 * hackagebot validity 0.2.0.0 - Validity typeclass  https://hackage.haskell.org/package/validity-0.2.0.0 (Norfair)
10:27:54 * hackagebot genvalidity-containers 0.1.0.1 - GenValidity support for containers  https://hackage.haskell.org/package/genvalidity-containers-0.1.0.1 (Norfair)
10:32:50 * hackagebot genvalidity-hspec 0.2.0.0 - Standard spec's for GenValidity instances  https://hackage.haskell.org/package/genvalidity-hspec-0.2.0.0 (Norfair)
10:32:52 * hackagebot genvalidity-text 0.1.0.0 - GenValidity support for Text  https://hackage.haskell.org/package/genvalidity-text-0.1.0.0 (Norfair)
10:51:38 <Clint> is there a typeclass for things with two different representations?
10:52:32 <ertes> Clint: to do what?
10:53:10 <ertes> > bimap (+ 1) ('a' :) (Left 5)
10:53:11 <lambdabot>  Left 6
10:53:16 <ertes> > bimap (+ 1) ('a' :) (Right " test")
10:53:18 <lambdabot>  Right "a test"
10:53:46 <Clint> ertes: i want to be able to input either representation, get either representation, and only convert when necessary
10:55:25 <ertes> Clint: you can use lenses
10:55:29 <ertes> :t polar
10:55:30 <lambdabot> RealFloat a => Complex a -> (a, a)
10:55:53 <ertes> :t polar_
10:55:54 <lambdabot>     Not in scope: ‚Äòpolar_‚Äô
10:55:55 <lambdabot>     Perhaps you meant one of these:
10:55:55 <lambdabot>       ‚Äòpolar‚Äô (imported from Data.Complex),
10:56:26 <ertes> Clint: one way is to have a data type for one representation and an isomorphism (a special type of lens) for the other
11:00:04 <ertes> Clint: for example you could consider Int to be a different representation for Char (that's not the whole truth, but let's ignore that)
11:00:18 <ertes> > 'a'  -- one representation
11:00:20 <lambdabot>  'a'
11:00:29 <ertes> > 'a' ^. enum  -- the other representation
11:00:33 <lambdabot>      Couldn't match type ‚ÄòInt‚Äô with ‚ÄòChar‚Äô
11:00:33 <lambdabot>      Expected type: Getting a Char a
11:00:33 <lambdabot>        Actual type: (a -> Const a a) -> Int -> Const a Int
11:00:41 <ertes> oh
11:00:52 <ertes> > 'a' ^. from enum  -- the other representation
11:00:54 <lambdabot>  97
11:01:07 <ertes> and you can manipulate in the other representation
11:01:30 <ertes> > 'a' & from enum +~ 1  -- add 1 to the Int representation
11:01:32 <lambdabot>  'b'
11:01:56 <ertes> 'from enum' is an iso lens
11:02:26 <Clint> ertes: and if i only ever use the Int will it never convert to Char?
11:03:01 <ertes> Clint: it will always stay in the canonical representation, if you use this
11:03:22 <Clint> that's sort of the opposite of what i want, i think
11:03:26 <ertes> Clint: but since this is an iso lens, you can declare either representation as canonical dynamically
11:03:30 <Clint> oh
11:03:46 <ertes> > 65 ^. enum  -- if you have an Int, you can go to Char
11:03:48 <lambdabot>  *Exception: Prelude.Enum.().toEnum: bad argument
11:03:57 <ertes> > 65 ^. enum :: Char  -- if you have an Int, you can go to Char
11:03:59 <lambdabot>  'A'
11:04:12 <ertes> > 'A' ^. from enum  -- if you have a Char, you can go to Int
11:04:14 <lambdabot>  65
11:04:17 <yiimi> is there an equivalent for docstrings in haskell?
11:04:29 <ertes> yiimi: haddock comments
11:04:44 <ertes> yiimi: https://www.haskell.org/haddock/doc/html/index.html
11:05:16 <yiimi> wow! thanks ertes 
11:05:44 <ertes> yiimi: that's how the user documentation you find on hackage or locally is generated
11:06:26 <yiimi> ertes: i normally don't find documentation. i usually only find source code 
11:06:59 <ertes> yiimi: example: <https://hackage.haskell.org/package/network>‚Ä¶  if you look in the "Modules" section, you can open the haddock docs for each module, generated from source code comments
11:08:49 <ertes> yiimi: for locally installed packages you need to tell your development environment of choice (cabal/stack/nix) that you want documentation built along with packages you install‚Ä¶  e.g. for cabal-install you just enable "documentation" in ~/.cabal/config
11:09:11 <yiimi> clear
11:09:45 <ertes> yiimi: but i find it easier to just go to the haddocks on hackage‚Ä¶  i even have a keyword bookmark in my browser
11:09:56 <ertes> so i type "p <packagename>" into my address bar
11:12:14 <ertes> > 0 ^. enum
11:12:16 <lambdabot>  ()
11:12:28 <ertes> defaulting chooses ()?
11:12:34 <ertes> i've never seen that one before
11:12:41 <Clint> ertes: i think i want something more like These Char Int with implicit conversion
11:12:55 <geekosaur> LANGUAGE ExtendedDefaultRules
11:13:47 <ertes> Clint: you have to code that yourself‚Ä¶  lenses at least help you to go to the (or really any) alternative representation temporarily
11:14:02 <ertes> ah
11:14:02 <geekosaur> (on by default in ghci (see ":showi language"), and apparently in mueval or lambdabot's instantiation of same)
11:14:30 <Clint> ertes: thanks
11:15:32 <ongy> hm, I have a weird error: https://travis-ci.org/monky-hs/monky/jobs/145385157 (error in linking step)
11:18:20 <geekosaur> that's not exactly linking, except insofar as it's trying to run some template haskell and loading packages to do it... and that symbol looks mangled
11:18:22 <geekosaur> double double_conversion::StringToDoubleConverter::StringToIeee<char const*>(char const*, int, bool, int*) const
11:18:47 <geekosaur> (c++. "joy")
11:19:54 <geekosaur> so it could be library versioning skew in whatever C++ library it's linking with
11:22:46 <ongy> so I'm pretty much out of luck with that dependencie on travis?
11:22:53 <geekosaur> looks like it, yes
11:23:46 <geekosaur> although maybe you'd be able to use an older version of the haskell double-conversion binding? (I have no idea, just guessing)
11:24:26 <geekosaur> but if a newer version of the binding requires a function from a newer version of the C++ dependency, maybe an older version will work with the version available there
11:24:36 <ongy> the dependencie is transitive, and I don't really want to add it explizit. It works in the 7.8 test, so I'll try the multighc thingy, I got a good reason now
11:34:21 <ongy> mh, nope same error
11:36:36 <yiimi> i'm unable to import `Text.Parsec.Token LanguageDef` and i'm not seeing it in tab completion for ghci
11:38:11 <vctr> hey
11:38:22 <liste> hi vctr 
11:38:36 <vctr> hi liste
11:38:47 <vctr> anyone working on fun projects?
11:42:38 <ertes> yiimi: import Text.Parsec.Token  -- to import everything
11:42:51 <ertes> yiimi: import Text.Parsec.Token (LanguageDef)  -- to import the LanguageDef type alone
11:42:52 * hackagebot system-locale 0.1.0.0 - Get system locales  https://hackage.haskell.org/package/system-locale-0.1.0.0 (cocreature)
11:42:54 * hackagebot levmar 1.2.1.6 - An implementation of the Levenberg-Marquardt algorithm  https://hackage.haskell.org/package/levmar-1.2.1.6 (BasVanDijk)
11:50:14 <troydm> what's the best way to get absolute path of the file?
11:52:53 * hackagebot OpenGLRaw 3.2.1.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-3.2.1.0 (SvenPanne)
11:55:16 <ertes> troydm: use the 'directory' package; see for example canonicalizePath from System.Directory
11:55:52 <troydm> ertes: thx
11:58:14 <yiimi> ah! thanks again  ertes 
12:05:14 <ongy> geekosaur: pinning an older version worked, thx
12:21:38 <vctr> test
12:23:11 <cobreadmonster> Is it just me, or is Freenode particularly slow today?
12:23:36 <vctr> not noticing
12:25:39 <geekosaur> freenode is having periodic netsplits on at least some servers
12:26:01 <vctr> hi geekosaur
12:26:48 <nitrix> cobreadmonster: There were 2 netsplits very recently.
12:28:04 <cobreadmonster> geekosaur nitrix: oh, thanks.
12:29:31 <vctr> can intero "go to definition" across multiple files in a project?
12:33:36 <vctr> does anyone use ghcid with emacs? sometimes it gets the frame height correct and sometimes it seems confused.
12:33:52 <cocreature> is uploading docs multiple times for the same version of a package supposed to work (e.g. when you screwed up haddock generation the first time)? I didn‚Äôt get an error on upload but I‚Äôm still seeing the old docs
12:35:04 <geekosaur> cocreature, that might be a question for #hackage
12:35:55 <cocreature> geekosaur: hm right, let me ask over there
12:37:51 <ertes> cocreature: worked for me
12:39:31 <cocreature> ertes: hm okay, maybe the cdn cache still shows the old version
12:42:54 * hackagebot pixelated-avatar-generator 0.1.1 - A library and application for generating pixelated avatars.  https://hackage.haskell.org/package/pixelated-avatar-generator-0.1.1 (ExcaliburZero)
12:43:02 <glguy> cocreature: Things get cached for 24 hours, you can see the new version by adding a ? to the URL
12:43:18 <cocreature> glguy: great thanks!
12:43:56 <cocreature> glguy: is there a reason why a doc upload does not invalidate the cache or has simply no one gotten around to implementing that?
12:44:53 <glguy> No idea
12:45:10 <boris_rh_> hello, can somebody spot what is wrong in this snippet: http://lpaste.net/170240
12:45:19 <glguy> That's a question for the aforementioned channel
12:45:33 <boris_rh_> I have problem with waitForEvent in my app
12:45:57 <boris_rh_> and reproduced it in this small snippet
12:46:46 <boris_rh_> the second entry written to channel is not retrieved
12:47:44 <cocreature> boris_rh_: without showing us the code for waitForEvent it‚Äôs kinda hard to comment on the problem
12:48:03 <boris_rh_> waitForEvent is standard function
12:48:21 <boris_rh_> from Control.Monad.Loops.STM
12:49:07 <geekosaur> "waitFor a value satisfying a condition to come out of a TChan, reading and discarding everything else"
12:49:58 <cocreature> ah damnit, it‚Äôs not in hoogle :)
12:50:02 <boris_rh_> here is source , I guess https://github.com/mokus0/monad-loops-stm/blob/master/src/Control/Monad/Loops/STM.hs
12:54:10 <boris_rh_> I did my own implementation of waitForEvent, that does not use retry and it works fine : http://lpaste.net/170240
12:54:41 <cocreature> boris_rh_: the problem is that waitForEvent does not discard the element but simply retries reading the front of the channel
12:55:00 <cocreature> seems like a weird semantic but that‚Äôs it
12:55:17 <boris_rh_> Thanks a lot <cocreature>
12:55:45 <boris_rh_> but is it bug within waitForEvent then?
12:56:16 <cocreature> not sure if that‚Äôs a bug, it could be the intended behavior
12:56:35 <boris_rh_> at least behavior does not meet documentation, and what is purpose of predicate parameter?
12:57:01 <boris_rh_> how it ever can work if first entry in channel does not match predicate?
12:57:02 <cocreature> a different thread could modify the channel
12:57:53 <cocreature> but the ‚Äúdiscarding everything else‚Äù part of the docs is at least misleading if not blatantly wrong
12:58:22 <glguy> boris_rh_: Another reader could take the first element
12:58:32 <boris_rh_> "blatantly wrong" seems to be more appropriate here 
12:59:11 <boris_rh_> OK, thanks a lot for the explanation
12:59:25 <yiimi> is there a difference between strict and eager evaluation?
13:00:05 <glguy> boris_rh_: Ah, you're talking about this monad-loops-stm package?
13:00:11 <glguy> Yeah, that seems like it's just wrong
13:00:21 <boris_rh_> <glguy>, yes 
13:05:24 <cocreature> is there any package that provides something like strict tuples with only one type parameter? basically I want something like V2,V3,‚Ä¶ from linear but dpending on linear just to get two or three of these types is annoying as it pulls in half of hackage.
13:06:21 <glguy> cocreature: the linear package pulls in most of those packages to provide type class instances. If you don't want the instances those types are simple enough to define locally
13:06:55 <glguy> I don't know whether or not a simpler package provides them
13:07:12 <cocreature> glguy: yeah I guess I‚Äôll just define them myself
13:08:12 <cocreature> I don‚Äôt really like duplicating types that already exist elsewhere but I guess it‚Äôs not that bad
13:12:48 <ksi> hi! i started learning haskell today, so please correct me if i use wrong terminology
13:13:17 <ksi> i have a program generating fibonacci numbers
13:13:37 <ksi> taken from https://wiki.haskell.org/The_Fibonacci_sequence
13:13:56 <ksi> which claims it is the canonical implementation:
13:14:05 <ksi> #!/usr/bin/runghc
13:14:12 <ksi> fibs = 1 : 2 : zipWith (+) fibs (tail fibs)
13:14:20 <ksi> main = putStrLn $ show $ take 30 fibs
13:14:32 <ksi> so far, so good, it works nicely
13:15:05 <ksi> but if i add function declaration:
13:15:07 <ksi> fibs :: Integral n => [n]
13:15:32 <ksi> it slows down greatly and uses a lot of memory
13:15:51 <ksi> this is with ghc-8.0.1
13:16:03 <ksi> what is going on here?
13:16:26 <glguy> fibs :: Integeral n => [n] isn't a function definition, it's a type signature. It's going more slowly because now you're no longer defining a "CAF"
13:16:42 <glguy> instead of defining a single list that gets shared a new one is computed at each use
13:16:53 <glguy> because the list depends on which type fibs is being used at
13:17:49 <glguy> If you declared fibs :: [Int], or fibs :: [Integer] it would be fast because there would be a single type for fibs and so the list could be reused for all cases
13:20:40 <ksi> ok, thanks, i'll try to read about it
13:22:26 <geekosaur> reading about the monomorphism restriction might help. not the restriction itself; that just biases the language toward preferring the shareable version. the justification for doing so is what you're after
13:32:56 * hackagebot env-locale 1.0.0.0 - A (non-forking) interface to the current locale  https://hackage.haskell.org/package/env-locale-1.0.0.0 (ongyerth)
13:32:58 * hackagebot nanovg 0.4.0.0 - Haskell bindings for nanovg  https://hackage.haskell.org/package/nanovg-0.4.0.0 (cocreature)
13:33:00 * hackagebot data-lens 2.11 - Used to be Haskell 98 Lenses  https://hackage.haskell.org/package/data-lens-2.11 (RussellOConnor)
13:44:14 <yiimi> http://pauillac.inria.fr/~levy/confer-2/ppr1/node63.html 
13:44:36 <yiimi> where is can I find Berry's Sequentiality Theorem?
13:45:05 <yiimi> also, i'm not sure which paper is klop's and bethke's, if anyone has a link, i would be greatful
13:52:57 * hackagebot data-lens 2.11.0.1 - Used to be Haskell 98 Lenses  https://hackage.haskell.org/package/data-lens-2.11.0.1 (RussellOConnor)
13:52:59 * hackagebot bson 0.3.2.3 - BSON documents are JSON-like objects with a standard binary  encoding.  https://hackage.haskell.org/package/bson-0.3.2.3 (VictorDenisov)
14:07:57 * hackagebot data-lens-fd 2.0.6 - Lenses  https://hackage.haskell.org/package/data-lens-fd-2.0.6 (RussellOConnor)
14:19:01 <travism> I can't remember where I saw "-:
14:19:05 <travism> oops
14:19:08 <travism> -:
14:19:12 <travism> what exactly does that do?
14:21:31 <geekosaur> it's not a standard operator. hayoo gives me quite the collection of different packages that define one
14:21:47 <geekosaur> http://hayoo.fh-wedel.de/?query=-%3A take your pick >.>
14:22:01 <travism> Oh
14:22:05 <travism> I just remember it from LYAH
14:22:08 <Alcat> Can I somehow turn off messages of who logged in or out?
14:22:24 <Alcat> Because this is getting too much.
14:22:58 <geekosaur> no idea how you'd do it from freenode's web client. many of us use standalone clients that can be configured to ignore joins/parts
14:23:14 <Alcat> Yea, I should get one of those. Suggestions?
14:23:45 <travism> Alcat: irssi
14:24:06 <Alcat> Thanks travism 
14:26:11 <travism> Alcat: np
14:27:58 * hackagebot data-lens-template 2.1.10 - Utilities for Data.Lens  https://hackage.haskell.org/package/data-lens-template-2.1.10 (RussellOConnor)
14:30:01 <ivan__> Test
14:31:01 <ivan__> :q
14:35:43 <numee> Hi, is there a shorter way than `length[1|p]` to represent `if p then 1 else 0` ? (I'm doing code golf)
14:37:18 <RyanGlScott> numee: bool 0 1 p
14:37:19 <dmj`> bool(0)(1)p
14:37:26 <RyanGlScott> Whoops
14:37:30 <sbrg> :t bool
14:37:31 <lambdabot> a -> a -> Bool -> a
14:37:33 <sbrg> :info bool
14:37:40 <sbrg> @info bool
14:37:40 <lambdabot> bool
14:37:42 <sbrg> thanks
14:37:44 <alercah> fromEnum p is one character shorter
14:37:59 <alercah> bool p 1 0 is the same length
14:38:49 <numee> oh there are many... thanks!
14:39:20 <mniip> wow
14:39:23 <mniip> [1|p]
14:39:25 <mniip> that's clever
14:40:01 <ClaudiusMaximus> sum[1|p]
14:40:35 <alercah> ooh, nice
14:41:34 <mniip> numee, might want to see that ^
14:43:16 <numee> mniip, ClaudiusMaximus: wow, that is very likely the shortest possible
14:43:50 <ertes> there is probably a shorter one with lens =)
14:46:38 <ertes> reminds me of the code golf i did for something like 'subsequences' (not exactly the same)
14:46:56 <ertes> > filterM(\_->[1<0..])"abc"
14:46:58 <lambdabot>  ["","c","b","bc","a","ac","ab","abc"]
14:47:58 * hackagebot data-lens-template 2.2 - Utilities for Data.Lens  https://hackage.haskell.org/package/data-lens-template-2.2 (RussellOConnor)
14:48:24 <ksi> glguy: geekosaur: thanks again, also it seems that using #!/usr/bin/runghc -Wall would help me avoid this problem, at least in this case
14:51:52 <numee> ertes: yeah, the list monad is useful especially in golfing
14:51:58 <numee> for example, `replicate n x` can be written as `[1..n]>>[x]`
14:53:42 <ertes> =)
15:09:14 <hexagoxel> [1..n]$>x
15:09:24 * hexagoxel golfing mode engaged
15:09:33 <ertes> > foldM(\x y->zipWith(\l->(++y:l)).inits<*>tails$x)[] "abc"
15:09:34 <lambdabot>  ["abc","bca","cab","bac","acb","cba"]
15:16:12 <vctr> doing a straight port of python -> haskell is weird sometimes
15:16:29 <ryantrinkle> has anyone written a custom filter for hlint?
15:16:49 <vctr> lenses for mutation and pipes for for loops
15:17:50 * ertes doesn't use hlint ‚Äì much disagreement
15:18:26 <ryantrinkle> ertes: any alternatives you like?
15:19:15 <ertes> ryantrinkle: not really‚Ä¶  i just code in my own style and make sure that no -W warnings are left
15:19:49 <ryantrinkle> ertes: yeah, makes sense; i'm trying to improve consistency a bit when multiple contributors are involved
15:20:50 <maerwald> ertes: yeah, a lot of it's warnings are silly
15:21:03 <maerwald> or just plain wrong
15:21:06 <Gurkenglas> :t foldr id -- nshepperd_
15:21:07 <lambdabot> Foldable t => b -> t (b -> b) -> b
15:23:07 <Gurkenglas> Pretty much composition. foldr id undefined promises that one folded function is lazy or the fold is infinite.
15:23:45 <Gurkenglas> Wait no it promises that one is lazy since an infinite composition of strict functions diverges.
15:25:13 <Gurkenglas> (is "promises that" appropriate for "bottoms out unless"?)
15:26:21 <lpaste> ertes pasted ‚ÄúLighting + normal mapping + shadow mapping in software (improved performance)‚Äù at http://lpaste.net/170277
15:27:41 <Gurkenglas> How much sense would a name cata make that evaluates to any of foldr, bool, maybe, etc. based on inference, for any data-defined type?
15:29:23 <Gurkenglas> "class Cata" defined using Text.Printf's technique and implementing a deriving clause. Ana too I guess.
15:30:39 <Gurkenglas> Though Ana doesn't curry as nicely.
15:31:25 <Eduard_Munteanu> ertes, what's the point of codensity there?
15:31:53 <ertes> Eduard_Munteanu: streamline all brackets
15:32:17 <ertes> myResource <- Codensity (bracket acquire release)
15:33:05 <Eduard_Munteanu> Ah, I see cbracket now.
15:38:04 <Gurkenglas> ertes, ">>= maybe (again t') (\_ -> pure ())" <- You want <|>?
15:38:26 <Gurkenglas> (And MaybeT)
15:41:07 <ertes> Gurkenglas: nope
15:41:33 <ertes> Gurkenglas: i want to get a Maybe and just pattern-match on it directly =)
15:41:49 <ertes> (>>= maybe _n _j) is a common pattern for me
15:46:43 <Gurkenglas> (Trying desperately to replace that fix by a list traverse atm)
15:47:40 <Gurkenglas> (the first to find the joke in there within the next 5 minutes literally gets 5$ on paypal from me)
16:04:51 <Gurkenglas> Hmm not too happy with this and dont know if itd even compile http://lpaste.net/408784649246998528 the joke was desperately is a combinator I invented some months ago and showed off here a few times and im trying to use it to replace that fix
16:05:16 <Gurkenglas> (modifyT is the inverse to execStateT, see ircbrowse)
16:09:06 <vctr> in spacemacs haskell mode is there a way to see the type of the variable under the cursor?
16:15:12 <nitrix> Is there a serialization library with versioning built in ?
16:17:10 <RyanGlScott> nitrix: http://hackage.haskell.org/package/safecopy
16:19:48 <nitrix> RyanGlScott: That Migrate typeclass is interesting.
16:19:50 <nitrix> Thanks.
16:22:37 <pavolzetor> Hi, I have asked here about a threading issue with GHCi (not sure if anybody remembers)
16:22:43 <ertes> nitrix: if you use safecopy, you're just one step away from acid-state
16:22:46 <pavolzetor> it runs out I was running different binary
16:22:59 <pavolzetor> (I forgot to rename the executable in cabal)
16:23:15 <pavolzetor> so I am not sure really what the :main command was running
16:23:28 <ertes> Gurkenglas: one way to get rid of 'fix' is to get ContT into the mix‚Ä¶  but that's probably not much of an improvement =)
16:23:56 <pavolzetor> but it now works
16:24:01 <nitrix> ertes: Apriori, I'll prefer acidstate, no dependency on old-time.
16:24:11 <nitrix> old-time doesn't play nice on window builds.
16:24:23 <pavolzetor> we have however hit another problem, where websockets package does not receive any message on windows
16:24:36 <pavolzetor> does anybody run websockets on windows here?
16:25:23 <ertes> :t \x0 -> ContT (\k -> let again x = ContT (\_ -> k (again, x)) in k (again, x0))
16:25:24 <geekosaur> pavolzetor, if it loaded source then it compiled it to bytecode and interpreted that. if it loaded a precompiled object then it linked that using ghci's linker and ran the result, which will be slightly different from running the executable (how slightly depends on a lot of things, including that ghci's linker may not work identically to the system's)
16:25:24 <lambdabot> t -> ContT r m (t -> ContT r m a, t)
16:25:34 <ertes> Gurkenglas: ^
16:26:27 <ertes> vctr: i don't know if it's any different in spacemacs, but in emacs haskell-mode you enable haskell-doc-mode
16:26:30 <pavolzetor> geekosaur, the stack ghci says it is compiling
16:26:43 <pavolzetor> however now I can't reproduce the problem
16:26:56 <nitrix> ertes: Nevermind, that depends on safecopy.
16:27:01 <ertes> vctr: alternatively you can use haskell-interactive-mode, which asks the background GHCi session
16:30:08 <pavolzetor> is there any example of the websockets working in windows?
16:30:23 <pavolzetor> in our case it simply hangs on receiving message
16:30:27 <pavolzetor> on linux it works
16:36:37 <Gurkenglas> ContT is as powerful as fix right
16:38:02 * hackagebot octane 0.13.3 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.13.3 (fozworth)
16:41:25 <hpc> @unmtl Cont a a
16:41:26 <lambdabot> (a -> a) -> a
16:44:47 <Cale> Gurkenglas: no, but callCC is
16:45:19 <Cale> er
16:45:21 <Cale> no wait
16:45:23 <Cale> haha
16:46:22 <Cale> @djinn ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
16:46:22 <lambdabot> f a b = a (\ c _ -> b c) b
16:46:42 <Cale> That's certainly not as powerful as fix :)
16:47:38 <Cale> Yeah, it's just double negation, doesn't get you as much as fix
16:49:26 <mniip> :t cont fix
16:49:27 <lambdabot> Cont a a
16:49:55 <Cale> One sec while I program ContT in Coq and prove the monad laws :D
16:51:40 <nitrix> Is there such thing as Data.Seq but with bounds? As in |> drops the first element in the sequence at the opposite end?
16:52:05 <ertes> nitrix: you can just use 'take'
16:55:20 <ertes> @let label x = ContT$ \k->k(fix$(k.).(,),x)
16:55:21 <lambdabot>  Defined.
16:57:25 <ertes> > flip runCont id $ do (again, (x, y)) <- label (0, 0); if x < 100 then again (x + 1, y + x) else pure y
16:57:26 <lambdabot>      Ambiguous occurrence ‚Äòlabel‚Äô
16:57:26 <lambdabot>      It could refer to either ‚ÄòL.label‚Äô,
16:57:26 <lambdabot>                               defined at /tmp/mueval13651805401540383426.hs:1...
16:57:45 <ertes> @let ertesLabel x = ContT$ \k->k(fix$(k.).(,),x)
16:57:46 <lambdabot>  Defined.
16:57:52 <ertes> > flip runCont id $ do (again, (x, y)) <- ertesLabel (0, 0); if x < 100 then again (x + 1, y + x) else pure y
16:57:53 <lambdabot>      Couldn't match expected type ‚ÄòContT c Identity c‚Äô
16:57:53 <lambdabot>                  with actual type ‚ÄòIdentity c‚Äô
16:57:53 <lambdabot>      Relevant bindings include
16:58:11 <ertes> huh?
16:58:14 <ertes> :t ertesLabel
16:58:15 <lambdabot> t -> ContT r m (t -> m r, t)
16:58:18 <ertes> oh
16:59:09 <ertes> :t \x -> ContT$ \k->k(fix$ContT\_->(k.).(,),x)
16:59:10 <lambdabot> parse error on input ‚Äò\‚Äô
16:59:19 <ertes> :t \x -> ContT$ \k->k(fix.ContT$\_->(k.).(,),x)
16:59:20 <lambdabot>     Pattern syntax in expression context:
16:59:20 <lambdabot>         fix . ContT $\ _ -> (k .) . (,)
16:59:24 <ertes> ok, whatever
16:59:27 <ertes> just use let =)
17:00:17 <ertes> @let myLabel x0 = ContT (\k -> let again x = ContT (\_ -> k (again, x)) in k (again, x0))
17:00:19 <lambdabot>  Defined.
17:00:25 <haskell348> Hey, does the on function has a formal combinator name? Just curious.
17:00:30 <ertes> > flip runCont id $ do (again, (x, y)) <- myLabel (0, 0); if x < 100 then again (x + 1, y + x) else pure y
17:00:32 <lambdabot>  4950
17:00:34 <ertes> finally‚Ä¶
17:00:55 <ertes> haskell348: formal?  you mean symbolic?
17:01:15 <haskell348> yes, like B and I and K
17:02:07 <lpaste> Cale pasted ‚ÄúCoq monad stuff (now with ContT‚Äù at http://lpaste.net/170279
17:02:35 <Cale> Gurkenglas: ^^ that should be good enough to see you can't get fix ;)
17:03:15 <ertes> haskell348: none that i know of
17:04:14 <haskell348> oh, I understand dot operator (.) composition is the B combinator. is that right?
17:12:57 <lpaste> Cale annotated ‚ÄúCoq monad stuff (now with ContT‚Äù with ‚ÄúCoq monad stuff (now with ContT (annotation)‚Äù at http://lpaste.net/170279#a170280
18:10:39 <wagle> anyone recall a paper showing up recently that talked about using approximations instead of full parsing with a compiler to do static analysis?
18:10:48 <wagle> I cant find it again
18:18:26 <kwantam> Yes, Brown et al at ASPLOS
18:18:37 <kwantam> https://web.stanford.edu/~mlfbrown/paper.pdf
18:19:21 <kwantam> ( @wagle ^^ )
18:20:06 <wagle> kwantam++  that was IT!  thankyouthankyouthankyou
18:21:48 <wagle> wow, I hid that url away
18:23:23 <kwantam> :) no problem
18:24:40 <wagle> been looking for it for about an hour now, hence my enthusiasm..  8)
18:25:24 <eflynn> how to find a sublist in haskell
18:25:55 <shachaf> the sublist was in you all along
18:26:18 <glguy> eflynn: Where have you looked?
18:26:24 <Koterpillar> :t isInfixOf  -- eflynn
18:26:25 <lambdabot> Eq a => [a] -> [a] -> Bool
18:26:31 <eflynn> i‚Äôm trying to write it from scratch
18:26:38 <Denommus> eflynn: what do you expect such a function to evaluate to?
18:26:49 <Denommus> eflynn: I mean, what is the type signature?
18:26:59 <wagle> https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm  8)
18:27:03 <eflynn>  (Eq a) => [a] -> [a] -> Sublist
18:27:10 <eflynn> data Sublist = Equal | Sublist | Superlist | Unequal
18:27:10 <eflynn>   deriving (Show, Eq)
18:27:49 <Denommus> eflynn: what you want is an intersection
18:28:29 <eflynn> example: A = [1, 2, 3], B = [1, 2, 3, 4, 5], A is a sublist of B
18:28:34 <Denommus> eflynn: if the intersection is equal to one of the lists, you get a sublist or a super list
18:28:44 <Denommus> eflynn: if it's equal to both lists, they are equal
18:28:54 <Denommus> eflynn: if it's equal to none, they are unequal
18:29:02 <Denommus> I could be wrong
18:29:13 <Koterpillar> Denommus: that's all for sets
18:29:24 <Koterpillar> eflynn: what's [1, 2, 3] `sublist` [3, 2, 1]
18:29:25 <Koterpillar> ?
18:29:42 <eflynn> Koterpillar: order matters
18:29:47 <eflynn> Koterpillar: so Unequal
18:30:06 <Koterpillar> eflynn: run isInfixOf both ways
18:30:08 <Denommus> Koterpillar: is it? https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html#v:intersect
18:30:28 <eflynn> sorry guys i‚Äôm totally new to haskell and very confused
18:30:31 <Denommus> eflynn: ah, if ordering matters than it's isInfixOf
18:30:38 <eflynn> i don‚Äôt want a library function
18:30:51 <maudefi> >
18:30:54 <Koterpillar> eflynn: why?
18:31:11 <Denommus> eflynn: you'll use the library function to implement your function
18:31:17 <Koterpillar> eflynn: if it's an exercise, I would still start with _writing_ isInfixOf
18:31:29 <Koterpillar> and then switch on the result, as Denommus said
18:31:34 <eflynn> Koterpillar: that‚Äôs basically what i want but i don‚Äôt get where to start at all
18:31:45 <eflynn> does haskell have a for loop
18:31:49 <Koterpillar> oh
18:32:06 <Koterpillar> do you want a recommendation for a Haskell introduction book instead?
18:32:21 <Denommus> eflynn: not... exactly. Haskell has many loops, but they're just recursive functions internally
18:32:32 <wagle> eflynn: dont use for, use recursion (but its tricky to wrap brain around)
18:32:48 <eflynn> this shit‚Äôs way too confusing
18:32:50 <sleblanc> also, many uses of for loops can be abstracted by mapping a function
18:33:04 <Denommus> eflynn: it's confusing for the first few months, yes
18:33:09 <wagle> eflynn: walking is confusing at first..  same with bicycle
18:33:34 <Denommus> eflynn: I recommend you to look at the source of isInfixOf and... ask
18:33:42 <Denommus> eflynn: if you don't understand something
18:33:47 <eflynn> Denommus: ok thanks for your patience
18:33:53 <xsperry> @src isInfixOf
18:33:53 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
18:34:11 <xsperry> there you go. now you can implement any :-D
18:34:20 <Koterpillar> :D
18:34:25 <Denommus> I forgot @src existed
18:34:33 <Koterpillar> I wasn't going to spoil it
18:34:54 <wagle> eflynn: no worries, we all ent through this
18:35:01 <wagle> went
18:35:30 <Denommus> this function is so amazingly simple
18:35:51 <Denommus> I usually don't think of using tails, but when I see it properly used I'm impressed
18:36:07 <xsperry> > tails [1,2,3]
18:36:09 <lambdabot>  [[1,2,3],[2,3],[3],[]]
18:36:15 <Koterpillar> you can almost read that definition aloud
18:36:23 <xsperry> yes
18:37:07 <Denommus> "if any needle is prefix of the tails of haystack, the needle is infix of the haystack"
18:37:22 <Koterpillar> err, no
18:37:39 <Denommus> ooops
18:37:40 <Denommus> yeah
18:37:46 <Koterpillar> "If any of the tails of the haystack is prefix of the needle, the needle is infix of the haystack"
18:37:53 <Denommus> you're right
18:37:54 <tom____> Hi guys, am a beginer, and I have a question. Can I ask ?
18:38:00 <Denommus> tom____: of course
18:38:06 <vctr> tom____ go ahead
18:38:07 <Koterpillar> tom____: you just did, keep going :)
18:38:10 <Denommus> Koterpillar: I inverted the operands
18:38:35 <glguy> Koterpillar: No, the other explanation was closer, if *the* needle is a prefix of any of the tails then the needle is an infix of the whole
18:38:36 <tom____> Ty :) . Haha. So, first, sorry for my english (am french). 
18:38:51 <Koterpillar> glguy: yes, sorry
18:39:22 <Koterpillar> glguy: lesson: just use haskell to specify things
18:39:28 <tom____> I'm reading the "Learn You a Haskell for Great Good!" And i've got a trouble in the part 6 with "find the largest number under 100,000 that's divisible by 3829"
18:39:47 <Denommus> I have a friend who uses Haskell code to comment complex and verbose code in other languages
18:39:49 <Denommus> it's funny
18:39:59 <Koterpillar> Denommus: I always want to do this
18:40:08 <Koterpillar> and attach signatures to functions
18:40:08 <tom____> I understand and found the same solution, but am trying to do it in an other way, but i can't :(
18:40:12 <eflynn> ok thanks guys i clearly don‚Äôt know what i‚Äôm doing, i think i‚Äôm going to set it aside for now but i‚Äôll try to read up on it
18:41:02 <eflynn> i mean what is a haystack in haskell?
18:41:07 <eflynn> i have no idea
18:41:09 <Koterpillar> eflynn: that's just a name
18:41:12 <Koterpillar> variable name
18:41:16 <eflynn> oh
18:41:19 <Koterpillar> *value name
18:41:30 <xsperry> variable is fine
18:41:35 <glguy> eflynn: People often talk about finding a "needle" in a "haystack"
18:42:16 <tom____> I'am trying to do something like << filter (flip(mod)3829 == 0) [100000,99999..1] >> but of course doenst work...
18:42:53 <glguy> tom____: You can forget about flip. Use anonymous function:
18:43:01 <glguy> \x -> this that x == the other
18:43:27 <Koterpillar> tom____: check the types as you go
18:43:32 <Denommus> > find (\x -> x `mod` 3829==0) [100000..1]
18:43:33 <tom____> glguy, i didnt read about anonymous fonctions yet... :s
18:43:34 <lambdabot>  Nothing
18:43:39 <Koterpillar> :t (`mod` 3829) -- tom____
18:43:40 <lambdabot> Integral a => a -> a
18:43:44 <Denommus> > find (\x -> (x `mod` 3829)==0) [100000..1]
18:43:45 <xsperry> t > ((== 0) .  `mod` 3829)
18:43:46 <lambdabot>  Nothing
18:43:48 <Koterpillar> :t (== 0) -- tom
18:43:50 <lambdabot> (Eq a, Num a) => a -> Bool
18:43:55 <xsperry> :t ((== 0) .  `mod` 3829)
18:43:56 <lambdabot> parse error on input ‚Äò`‚Äô
18:44:14 <tom____> Koterpillar, I did, but i didnt manage to find the solution :(
18:44:21 <Denommus> > find (\x -> (x `mod` 3829)==0) $ reverse [1..100000]
18:44:22 <lambdabot>  Just 99554
18:44:26 <xsperry> :t ((== 0) .  `(mod` 3829))
18:44:27 <lambdabot> parse error on input ‚Äò`‚Äô
18:44:32 <xsperry> screw it
18:44:42 <Koterpillar> tom____: look at xsperry's hints
18:44:44 <tom____> Is there a solution whitout using " \ " ?
18:44:53 <Koterpillar> there always is
18:44:53 <tom____> ok
18:44:54 <Denommus> @pr (\x -> (x `mod` y)==0)
18:44:54 <lambdabot> Maybe you meant: pretty print-notices protontorpedo pl
18:44:58 <Denommus> @pl (\x -> (x `mod` y)==0)
18:44:59 <lambdabot> (0 ==) . (`mod` y)
18:45:10 <xsperry> s/hints/failures to type after one beer
18:45:13 <tom____> What does the dot mean ?
18:45:21 <Koterpillar> :t (.) 
18:45:22 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:45:30 <Denommus> > find ((0==) . (`mod` 3829)) $ reverse [1..100000]
18:45:32 <lambdabot>  Just 99554
18:45:32 <glguy> tom____: The best answer is the one with the anonymous function here, so it'll be worth learning about that
18:46:00 <Denommus> tom____: ok, this is the solution I liked the most: find ((0==) . (`mod` 3829)) $ reverse [1..100000]
18:46:16 <Koterpillar> > ((+) 1 . (+) 10) 2 -- tom____
18:46:18 <lambdabot>  13
18:46:47 <slack1256> haddocset depends on the GHC-api which is brittle between version
18:46:58 <slack1256> what is the easy way to generate docsets from hackage?
18:47:04 <xsperry> tom____ dot is an infix functions that composes two functions
18:47:24 <xsperry> an infix function*
18:47:54 <tom____> Hmm ok...
18:48:25 <Axman6> > (f . g) x
18:48:26 <lambdabot>      Could not deduce (Show b0) arising from a use of ‚Äòf‚Äô
18:48:26 <lambdabot>      from the context (FromExpr c)
18:48:26 <lambdabot>        bound by the inferred type of it :: FromExpr c => c
18:48:31 <Axman6> > (f . g) x :: Expr
18:48:32 <xsperry> > tail [1,2,3]
18:48:33 <lambdabot>      No instance for (Show b0) arising from a use of ‚Äòf‚Äô
18:48:33 <lambdabot>      The type variable ‚Äòb0‚Äô is ambiguous
18:48:33 <lambdabot>      Note: there are several potential instances:
18:48:34 <lambdabot>  [2,3]
18:48:38 <xsperry> > head [2,3]
18:48:40 <Axman6> -_-
18:48:40 <lambdabot>  2
18:48:54 <xsperry> > (head . tail) [1,2,3]
18:48:56 <lambdabot>  2
18:49:13 <xsperry> makes sense?
18:49:14 <tom____> i've got it now, ty (sry I'm slow... ><  almost 4 am here...)
18:51:18 <Denommus> tom____: everybody begins slowly, don't worry
18:53:53 <tom____> Ok ! It works for me. Thank you very much guys !
18:54:10 <benzrf> hows it goin Denommus
18:54:19 <benzrf> still a lisp fan?
18:54:41 <Denommus> benzrf: not anymore
18:55:04 <Denommus> benzrf: free monads fill most macros usecases anyway :P
18:55:11 <tom____> Could it be done without the composition or the / ?
18:55:42 <benzrf> Denommus: mwahaha
18:56:07 <tom____> the "\"* .
18:56:19 <Koterpillar> tom____: composition is pretty central to Haskell, why?
18:56:20 <Denommus> benzrf: also, the advantage of type systems surpasses the power of macros
18:56:33 <Denommus> benzrf: but now I wish Haskell had a web framework like Ocsigen
18:56:38 <Denommus> (from OCaml)
18:56:52 <tom____> Koterpillar, i'have'nt read it yet. I wanted to do it with only the tools I have. That's why ^^ .
18:56:53 <benzrf> isnt "reverse [1..100000]" like really inefficient
18:57:19 <benzrf> it wastes lazy eval 
18:57:23 <Denommus> benzrf: probably, but it's easily replaceable by something more efficient
18:57:29 <Koterpillar> tom____: I'm pretty sure composition is defined early on
18:57:39 <Denommus> benzrf: I only used it for didactical purposes
18:57:41 <Koterpillar> benzrf: [100000, 999999..1]
18:58:10 <tom____> Koterpillar, yeah maybe, but not yet. I'm only in the 6th part...:s
18:59:19 <benzrf> > [100000, 999999..1]
18:59:20 <lambdabot>  []
18:59:30 <Koterpillar> > [100000, 99999..1]
18:59:32 <lambdabot>  [100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,99...
18:59:32 <xsperry> tom____ write divisibleBy function. pass it to filter
18:59:38 <benzrf> heh
19:00:06 <tom____> xsperry, I want a "one line solution" without any call.
19:00:40 <tom____> I know, am strange... Sorry for this question... x).
19:00:54 <Koterpillar> without... call?
19:00:54 <benzrf> any "call"?
19:02:09 <tom____> Hmm... By call I mean, use a function which is defined elsewhere
19:02:29 <benzrf> that's impossible
19:02:36 <Koterpillar> you do realize haskell is a functional language, right?
19:02:39 <Denommus> well
19:02:41 <Koterpillar> functions are all you have
19:02:46 <tom____> Somethign like : filter (expression am looking for) [the list]
19:02:48 <Denommus> it's possible if you get this function by parameter
19:02:55 <benzrf> tom____: but you're using filter right there
19:03:44 <tom____> yeah yeah of course...hmm...am not clear....
19:04:05 <benzrf> as well as (:)
19:04:34 <Denommus> benzrf: ah
19:04:45 <Denommus> benzrf: I got hired to work with either Haskell or OCaml
19:05:04 <Denommus> benzrf: we actually use Emacs' org-mode to control our tasks in our office
19:05:10 <Koterpillar> tom____: you might be able to use a list comprehension
19:05:33 <benzrf> well, those are just syntactic sugar
19:05:46 <Koterpillar> yeah, but they are introduced in LYAH before ch. 6 and (.) isn't
19:06:20 <benzrf> LYAH :(
19:06:51 <Koterpillar> tom____: is there a language you're more familiar with than Haskell?
19:07:12 <tom____> I did some C eyars ago.
19:07:29 <tom____> But i understand what you're all telling me :) . The probleme is that am not clear.
19:08:25 <tom____> I was just wonderinf if there is a solution near  head (filter ((==0).(`mod`3829)) [10000,9999..]) without an use of the "." or the "\" you were talking.
19:08:38 <Koterpillar> tom____: yes, there is, use a list comprehension
19:08:44 <tom____> But I realy like the "." solution.
19:09:31 <tom____> Again, i wasnt clear enough...
19:09:42 <Koterpillar> > head [x | x <- [10000, 9999..1], x `mod` 8832 == 0]
19:09:44 <lambdabot>  8832
19:09:54 <tom____> I want to find "the expression" in "  head (filter (the expression) [10000,9999..])
19:10:21 <tom____> Koterpillar, yeah, am ok with this solution too :) .
19:10:29 <Koterpillar> tom____: sorry, I give up, short of cheating ($ and related), there's nothing I can think of
19:10:45 <Koterpillar> in C, you would have been asking for a solution without let's say "if" and "for"
19:10:48 <Koterpillar> and "while"
19:11:40 <tom____> Koterpillar, I hope i didnt bothered you ? :s Was just asking if it was possible, cos i struggled for hours now ^^.
19:11:53 <Koterpillar> don't think it is
19:12:37 <tom____> Ok, thank you :) .
19:12:53 <xsperry> its not possible if we ignore three possible solutions already given :)
19:13:59 <Iceland_jack> r/programming: Why Haskell can't solve basic problems
19:14:22 <Koterpillar> Iceland_jack: code golfing ensued?
19:14:42 <Iceland_jack> #haskell has automated code golfing with '@pl'
19:15:09 <Koterpillar> need to combine that with QuickCheck or something
19:15:52 <Iceland_jack> @check \x -> x == x
19:15:53 <lambdabot>  +++ OK, passed 100 tests.
19:16:08 <tom____> Yeah ok, the "." solution is the one i keep.( I tried a lot, Things like : filter ((==)(flip(mod)3829) 0) [list], cos I was hoping it'll return a fuction which work...etc...)
19:16:34 <Koterpillar> tom____: check the type of that expression in the middle
19:16:35 <tom____> Anyway, thanks again to all of you.
19:16:42 <Koterpillar> (hint: it doesn't typecheck)
19:16:53 <Iceland_jack> tom____: If you're starting out with Haskell, try implementing your function from scratch
19:17:00 <Denommus> have you guys ever used MFlow?
19:17:03 <tom____> Yeah, yeah, I did, i type it a bit random there, i mean, i was trying to do things like that ^^.
19:17:13 <tom____> scratch ?
19:17:13 <Koterpillar> tom____: you have (`mod` 3829) :: Int -> Int, and (== 0) :: Int -> Bool
19:17:19 <Koterpillar> tom____: from blank
19:17:30 <Koterpillar> tom____: to combine them, you need (.)
19:17:33 <Koterpillar> :t (.)
19:17:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:18:19 <tom____> Yeah, I looked, i get it now . :). It's strange they dont talk about it sooner. Maybe there's a reason... cos compositon is an usefull function...
19:18:30 <lpaste> joobus pasted ‚ÄúHow do I write the Reader Monad using bind?‚Äù at http://lpaste.net/170290
19:18:41 <Koterpillar> I actually checked LYAH and was surprised it's not there too
19:18:47 <tom____> Koterpillar, yeah, i was struggling to combine them...><...
19:19:03 <joobus> can someone take a look at the paste I just posted?  Trying to figure out the Reader monad.
19:19:18 <Iceland_jack> tom____: You can give it a name
19:19:18 <Iceland_jack>   divBy3829 :: Integer -> Bool
19:19:18 <Iceland_jack>   divBy3829 num = (num `mod` 3829) == 0
19:19:30 <Denommus> joobus: are you comfortable with the concept of monads?
19:19:36 <joobus> i think so
19:19:49 <Koterpillar> joobus: what type do you want mon2 to be?
19:20:04 <ertes> > (div 100000 3829)*3829
19:20:05 <lambdabot>  99554
19:20:09 <tom____> Iceland_jack, yeah I know, but as i said, i was looking for something "in one line". 
19:20:16 <tom____> I quit now.
19:20:22 <Denommus> joobus: ah, you're trying to *write* the Reader monad, right?
19:20:28 <tom____> Ty for your patience and answers.
19:20:29 <ertes> this is not a programming exercise, but a math exercise
19:20:39 <tom____> Bye guys ;) .
19:21:06 <joobus> the book is working the through the Reader monoid/applicative/monad.  It's just starting out with doing the Reader monad with simple functions.  It's my understanding the Reader monad is the monad of function composition?
19:21:31 <Denommus> joobus: do { a <- cap; return $ rev a } is the same thing as cap >>= \a -> return $ rev a
19:21:40 <joobus> i.e. a monad for the type (-> a)
19:21:42 <Denommus> joobus: which is just cap >>= return . rev
19:22:09 <Iceland_jack> @pl cap >>= return . rev
19:22:09 <lambdabot> rev `fmap` cap
19:22:20 <Denommus> joobus: which can usually be rewritten as rev <$> cap
19:22:23 <shachaf> joobus: You should read about how do notation is translated. It's pretty straightforward.
19:22:29 <Denommus> s/usually/always/
19:22:29 <joobus> ah, ok.  thanks Denommus 
19:22:38 <shachaf> Most books and introductions will explain the exact translation.
19:23:23 <joobus> shachaf: I have.  I just thought there was some more clever way this example was supposed to demonstrate
19:24:16 <ertes> joobus: the clever way is by using the laws:  c >>= pure . f = fmap f c
19:24:21 <joobus> the chapter goes through the reader f/a/monad, but never really uses it for anything useful, then says 'actually everyone uses ReaderT most of the time'
19:24:45 <ertes> joobus: the latter is not true
19:25:01 <joobus> ertes: but fmap is for the applicative instance
19:25:06 <shachaf> I would not have high expectations of the examples in that book.
19:25:23 <joobus> the book showed how to do the example as a monoid, then applicative, then as a monad
19:25:38 <joobus> correction: fmap is for monoid
19:25:42 <glguy> joobus: which book?
19:25:56 <joobus> haskellbook.com
19:25:59 <glguy> ohh...
19:26:09 <Denommus> joobus: functor
19:26:16 <Denommus> joobus: monoid is another thing
19:26:21 <joobus> yeah, functor
19:26:33 <ertes> joobus: every Monad is an Applicative, and every Applicative is a Functor, so for every monad fmap is defined‚Ä¶  one thing to note is that historically Functor and Applicative used not to be superclasses of Monad, which was unfortunate, but was changed "recently" (in GHC 7.10, base 4.8)
19:26:35 <joobus> i'm still a nood
19:26:36 <joobus> noob
19:26:45 <joobus> ertes: I know
19:27:02 <Denommus> joobus: I'm glad the book starts from the simpler and most fundamental concept
19:27:14 <glguy> joobus: you're going to have to relearn a lot
19:27:36 <ertes> joobus: in other words, for monads the law always holds, so you can use it for rewriting
19:27:44 <joobus> glguy: is that a criticism of the book?
19:28:06 <glguy> yeah
19:28:30 <joobus> glguy: well this is the 3rd haskell book I'm reading through
19:29:25 <joobus> glguy: utnil what I always get stuck on is actually doing something useful after finishing the books, because they seem mostly to cover the basics, but not program composition.
19:29:46 <glguy> joobus: You'll learn that from writing programs
19:29:50 <joobus> glguy: at least this book has a chapter on monad transformers (haven't gotten to it yet though)
19:29:56 <glguy> and reading them
19:30:11 <glguy> A chapter on monad transformers won't teach program composition
19:30:59 <ertes> joobus: most current introductory materials have the tendency to teach you basically how to overengineer in haskell‚Ä¶  if you want to get stuff done, try using straightforward language features:  functions and IO
19:31:31 <Iceland_jack> No subtitution for getting your hands dirty
19:32:10 <ertes> joobus: i recommend that you just pick something you'd like to do, perhaps even something you've already done in another language, and just implement it‚Ä¶  if you get stuck along the way, #haskell is a very friendly channel =)
19:33:10 <joobus> if I wanted to write a simple web service, with a database connection, which library is best to start with?
19:33:32 <ertes> snap is rather beginner-friendly, and happstack should work, too
19:35:26 <joobus> can those use all the cores of a cpu?  I use python and go at work, and go can take advantage of multiple cores vs single threaded for python.  I know haskell can use multiple cores, but I don't know which web frameworks actually do.
19:35:32 <ertes> there are also some simpler frameworks like Spock, and some minimalist frameworks like scotty
19:36:15 <ertes> pretty much any haskell program that uses concurrency (i.e. pretty much anything that uses the network) can make use of multi-core hardware out of the box
19:36:36 <ertes> it's not a framework feature, but a haskell feature
19:37:21 <joobus> my understanding was anything that used forkIO could, but i don't know enough about how stuff has been implemented in haskell to know at this point.
19:38:04 <ertes> it's not so much about using forkIO, but about how you use it‚Ä¶  even concurrent code can be written in a way that it essentially can't use more than one core at once
19:38:34 <ertes> but threads in web applications are largely independent of each other, so you should get very good core coverage on higher loads
19:40:55 <joobus> k, one other question.  When I write code in other languages, I like to be verbose about logging what is going on in the system.  In haskell, we can only log from the IO monad (I think), but I did come across `trace`, which appears to be a loophole for debugging pure functions.  Is there a way to enable/disable trace without having to go into the code and remove any instance of `trace`?
19:41:22 <Iceland_jack> joobus: You can easily define
19:41:22 <Iceland_jack>     myTrace = trace
19:41:28 <Iceland_jack> and then replace it with a dummy definition
19:41:40 <Iceland_jack> You can use #ifdefs but for many cases that's enough
19:42:26 <ertes> joobus: for debugging IO stuff using IO actions for debugging is fine
19:43:05 <ertes> joobus: but you may find that your development workflow might change with haskell‚Ä¶  you write more self-contained code and test it on the fly
19:43:25 <nitrix> https://hackage.haskell.org/package/NoTrace
19:43:35 <Iceland_jack> joobus: To expand, I can count the number of times I've used trace on one hand
19:44:00 <nitrix> Look at this. It re-exports the same function as Data.Trace. You comment out your Data.Trace import and replace it with Data.NoTrace.
19:44:00 <glguy> Sure, but we don't know how many fingers you might have!
19:44:02 <ertes> Iceland_jack: less than 32 times?
19:44:14 <Iceland_jack> ertes: ;) wise guy eh
19:44:17 <ertes> ;)
19:44:34 <nitrix> Iceland_jack: joobus ^ see above
19:45:01 <Iceland_jack> Didn't know about NoTrace, neat
19:45:06 <ertes> nitrix: that's lovely, but it should really be in 'base' to be useful =)
19:45:08 <joobus> nitrix: thanks
19:45:18 <ertes> otherwise you have a useless dependency most of the time, unless you also introduce a cabal flag
19:45:59 <ertes> i'd rather add the Debug.NoTrace module to my own project and define dummies there
19:46:17 <tnks> is there a "validation" type in some library that has a Semigroup that using the Semigroup of the Success value, rather than stopping at the first Success?
19:46:32 <tnks> I can write my own, but I'll use a library if it's there.
19:46:33 <nitrix> ertes: Yeah, I agree. It'd be really great in base though.
19:46:46 <nitrix> ertes: Who takes decisions like this? A PR on the mailinglist?
19:46:59 <geekosaur> libraries@haskell.org, I think
19:47:02 <ertes> nitrix: i think the libraries mailing list would be a good place
19:47:07 <joobus> last question: for a web app with logging, db connection info, whatever other global state, how do I go about creating a thing that holds the information so this it is accessible from, for instance, all the web threads?
19:47:18 <glguy> tnks: http://hackage.haskell.org/package/validation-0.5.2/docs/Data-Validation.html ?
19:47:38 <ertes> joobus: you pass it as an argument
19:48:33 <tnks> glguy: no, that Validation uses only a (Semigroup e) constraint.  What I want is a constraint using (Semigroup e, Semigroup a)
19:48:44 <ertes> joobus: some larger web frameworks have facilities to pass some of that information implicitly, but everything else you should pass as arguments
19:49:11 <tnks> glguy: but otherwise, a lot of the same instances. . . I guess I might have to newtype?
19:49:29 <joobus> ertes: I think I'll just have to pick a framework and figure out how to do it in that.  thanks for the help ertes.
19:49:53 <ertes> joobus: my pleasure‚Ä¶  really the simplest approaches are often the best in haskell =)
19:52:16 <ertes> example: you want to allocate resources?  you bracket inside a codensity monad transformer over IO
19:52:26 <ertes> joobus: (ignore that)
19:52:37 <geekosaur> heh
19:58:12 <glguy> ertes: You're just hording all the best program structure for yourself!
19:58:18 <glguy> hoarding*
19:59:45 <ertes> glguy: actually i'm not‚Ä¶  i'm relying on a simple trick:  as a haskell programmer your notion/perception of simplicity changes over time
20:00:31 <ertes> so even when they start writing their first MonadBaseControl instance, ‚Ä¶
20:00:33 <ertes> hmm‚Ä¶
20:03:10 <joobus> ertes: how long have you been writing haskell?
20:10:33 <ertes> joobus: since around 2007
20:13:30 <EvanR> imperative programming used to seem so simple, what happened
20:24:02 <benzrf> EvanR: u woke up to the complex semantics of scopes and mutation?
20:25:58 <EvanR> dang, i need a forgetful functor
20:28:53 <Iceland_jack>     free -| beer
20:29:33 <Iceland_jack> that joke makes sense in one more way than you think
20:49:36 <dmj`> template haskell is so tedious
20:51:34 <hodapp> https://github.com/albertoruiz/hmatrix/issues/195 woo, I filed an issue on my hmatrix oddity \o/
20:51:44 <hodapp> I hope that example has pushed it past the possibility of "YOU'RE DOING IT WRONG"
21:31:45 <gleb> Hi guys, why this code doesn't compile? http://pastebin.com/Mi45uXGX
21:32:25 <shachaf> I bet GHC can tell you why.
21:34:03 <gleb> I am trying to use ApplicativeDo extention, but GHC still requires F to be a monad(which is not what I expected), I am trying to understand why
21:35:07 <glguy> gleb: the extension has some omissions, try adding some _ <- to you k's
21:36:12 <kadoban> gleb: IIUC it only matches certain fairly specific patterns, so it doesn't work every time that it could. Not sure that's correct though.
21:36:14 <gleb> wow, that worked, thank you.
22:19:07 <dmj`> is anyone familiar with like a template-haskell-simple package
22:21:10 <glguy> What parts of template haskell are you finding non-simple?
22:27:19 <linoge> Hi, greetings to everyone :).
22:29:41 <dmj`> glguy: it's just not a pleasant API I guess
22:42:14 <nkaretnikov`> is there a monad for raising exceptions that's capable of agregating them?
22:42:23 <nkaretnikov`> similar to what Either [String] a can do
22:42:43 <nkaretnikov`> i think i've seen something like that recently, but i cannot recall what it was
22:43:00 <Iceland_jack> Validation 
22:43:18 <Iceland_jack> https://hackage.haskell.org/package/either-4.4.1.1/docs/Data-Either-Validation.html
22:43:56 <nkaretnikov`> Iceland_jack: right, that's probably it, i recall that it was mentioned by ed in some comment. let me see
22:44:12 <Iceland_jack> ghci> Failure ["Incorrect Key"] <*> Failure ["Error"]
22:44:13 <Iceland_jack> Failure ["Incorrect Key","Error"]
22:44:25 <Iceland_jack> there is also https://hackage.haskell.org/package/validation
22:49:41 <cbro_> hi guys, in Haskell is there a functional way to represent something like an object in OO? like instead of having a class with some properties and methods, I want something like a Category with a functor
22:50:33 <dmj`> cbro_: lenses look like OOP, some people say comonads are like objects
22:51:47 <cbro_> ok
22:51:54 <cbro_> never used them.. can look into them
22:52:09 <shachaf> I don't think either of those is the kind of answer you're looking for.
22:53:00 <Iceland_jack> There are so many ways of going from "object" to Haskell, more context is needed
22:54:57 <dmj`> cbro_: maybe tell us what you're trying to do
23:01:06 <superlinux> hi. 
23:01:45 <superlinux> anyone online here? I am trying to build Qt for Haskell. and I am getting this : Missing C libraries: qtc_core, qtc_gui, qtc_network, qtc_opengl, qtc_tools, qtc_script . I am on debian jessie
23:02:23 <superlinux> qt 5 is already installed.
23:02:24 <cbro_> dmj`: I will have to get back to you on that one.. have to rush out for a bit ..sorry
23:02:28 <Koterpillar> superlinux: on Debian, you'll need to install libqt-*-dev (e.g. libqt-network-dev)
23:02:34 <Koterpillar> superlinux: or perhaps qt-*-dev
23:02:45 <superlinux> ok. God's willing will do.
23:03:17 <Koterpillar> no, _that_ is not a requirement
23:03:56 <glguy> Try prayer first, next install the dev packages
23:04:58 <linoge> Of course, you will have first to choose some God.
23:13:29 <ertes> cbro_: the closest mapping is that what you considered "classes" in OO are now "types"‚Ä¶  you might identify "type" with "semantics"‚Ä¶  subclasses are then values of that type
23:14:25 <ertes> cbro_: so if you had classes Vehicle, Car < Vehicle and Bus < Vehicle before, you now have a type Vehicle with *values* car :: Vehicle and bus :: Vehicle
23:14:42 <superlinux> Koterpillar, they are installed. I did : apt-get install qt5-default. and this drags all Qt5 dev packages. so I don't know what's wrong.
23:15:43 <ertes> cbro_: when translating OO concepts to haskell that's a good start‚Ä¶  with more experience you will probably choose better representations or better APIs
23:15:56 <Koterpillar> superlinux: qt-sdk?
23:16:24 <superlinux> no
23:17:13 <superlinux> Koterpillar, it's the way we install things in debian. I think you know apt-get
23:17:25 <Koterpillar> apt-get install qt-sdk
23:17:44 <Koterpillar> (or apt install nowadays)
23:18:25 <superlinux> Koterpillar, oh right! did not know that package name
23:18:29 <superlinux> thanks
23:18:51 <superlinux> but it mixes between qt5 and qt4. would that make an issue?
23:18:58 <tdammers> cbro_: most naive way to get this is to just have records where some fields happen to be functions
23:20:08 <tdammers> cbro_: you can then add "constructor" functions that take some parameters and wrap them in such a record value; closing over the parameters, and making some of the "methods" return modified copies of your object based on those, allows you to write things that resemble OOP's getters and setters
23:20:55 <tdammers> cbro_: if you want actual mutable state inside your objects, pick one of the stateful monads (IO, ST) and use their mutable primitives (IORef, MVar, TVar) for the mutable fields
23:21:08 <Koterpillar> superlinux: qt5-sdk?
23:31:50 <nkaretnikov`> Iceland_jack: trying out either and validation, either lacks a monad instance, so i cannot do action1 >> action2, validation fails to aggregate errors with _Failure # ["foo"] <*> _Failure # ["bar"] <*> _Success # 7Validation [String] Int
23:32:10 <ertes> cbro_: note: you never *need* mutation‚Ä¶  haskell allows you to design your type to closely match the semantics you're going for
23:32:19 <nkaretnikov`> Iceland_jack: is there a way around that? 
23:32:26 <Iceland_jack> nkaretnikov`: No Monad is the point
23:32:39 <nkaretnikov`> Iceland_jack: wdym?
23:32:41 <Iceland_jack> But you can use the applicative version of (>>)
23:32:41 <Iceland_jack> :t (*>)
23:32:42 <lambdabot> Applicative f => f a -> f b -> f b
23:32:48 <nkaretnikov`> Iceland_jack: ah, yeah
23:32:57 <nkaretnikov`> Iceland_jack: i parsed your sentence incorrectly
23:33:02 <nkaretnikov`> lemme try
23:33:06 <Iceland_jack> nkaretnikov`: If it accumulates the error messages, it cannot be a Monad
23:33:17 * hackagebot aeson-diff 1.0.0.1 - Extract and apply patches to JSON documents.  https://hackage.haskell.org/package/aeson-diff-1.0.0.1 (ThomasSutton)
23:33:59 <nkaretnikov`> Iceland_jack: yeah, yeah, i get that
23:34:11 <Iceland_jack> Making sure
23:34:34 <Iceland_jack> nkaretnikov`: Keep in mind that with `ApplicativeDo' we can use do-notation with Applicatives
23:35:32 <nkaretnikov`> nice!
23:35:45 <nkaretnikov`> Iceland_jack: thanks for the heads up!
23:36:00 <Iceland_jack> You're welcome
23:50:32 <Iceland_jack> For those interested, this is the sum of identity and the constant functor
23:55:06 <Iceland_jack> code from ( http://openaccess.city.ac.uk/1141/1/Constructors.pdf )
23:55:07 <Iceland_jack>     data Lift f a = Return a | Others (f a)
23:55:16 <bollu> Iceland_jack: what is the sum of identity and constant functor?
23:55:28 <Iceland_jack> (this is advanced stuff, completely unnecessary)
23:55:59 <Iceland_jack>     type Validation err a = Lift (Const err) a
23:56:57 <Iceland_jack>     >>> Others (Const ["Error 1"]) <*> Others (Const ["Bug", "Error 2"])
23:56:58 <Iceland_jack>     Others (Const ["Error 1","Bug","Error 2"])
23:57:00 <bollu> Iceland_jack: I'm just curious :)
23:57:16 <Iceland_jack> more info here http://comonad.com/reader/index.php?s=liftm
23:57:50 <ertes> bollu: in a type definition read "|" as "plus"
23:58:49 <ertes> bollu: newtype Identity a = Return a; newtype Constant f a = Others (f a); newtype IdentityPlusConstant f a = Return a | Others (f a)
23:59:08 <ertes> s/newtype/data/  # in the last one
