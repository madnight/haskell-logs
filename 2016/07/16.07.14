00:08:31 <willturner> am i just not thinking haskell-y enough, or is my soln to euler #8 more straightforward than the one given on the wiki http://lpaste.net/898456172766429184 ?
00:09:18 <willturner> took me a while to wrap my head around the given one. not sure if it's written to show off, or if it really would be the desired soln in prod code
00:10:22 <opqdonut> yours is simpler yes
00:10:29 <opqdonut> but it's also slightly wrong
00:10:48 <opqdonut> you do "product . take 13" even on lists that are less than 13 long
00:11:09 <willturner> right, but they will always be less than the bigger one
00:11:12 <willturner> actually not if there's zeroes
00:11:15 <opqdonut> consider a number like, say 1001001001..001
00:11:17 <opqdonut> yeah
00:11:20 <willturner> good catch
00:11:24 <opqdonut> the correct answer is 0, but your code will output 1
00:11:32 <Axman6> concat . lines seems wrong, but I don't know what the code is supposed to do
00:11:36 <opqdonut> this is the reason for the slightly convoluted answer in the wiki
00:11:44 <willturner> so it needs a filter (\ns -> length ns == 13)
00:11:50 <opqdonut> Axman6: that gets rid of line returns :)
00:11:53 <willturner> yeah the txt file is split on multiple lines
00:12:11 <Axman6> oh, I might have been thinking of a different file format
00:12:30 <opqdonut> willturner: or just "take (n - 13) . tails"
00:13:05 <opqdonut> but the wiki solution doesn't use length
00:13:11 <willturner> do i know n?
00:13:12 <opqdonut> which is a strength when the input is really large
00:13:25 <opqdonut> you'd have to compute n separately
00:13:38 <opqdonut> for n=1000 or so it won't matter at all
00:14:42 <willturner> right
00:15:16 <opqdonut> a nicer way to formulate the wiki answer is "transpose . take 13 . tails"
00:15:21 <opqdonut> but there's no transpose in Prelude
00:16:31 <willturner> this tranpose? https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html#v:transpose
00:16:45 <opqdonut> > If some of the rows are shorter than the following rows, their elements are skipped:
00:16:47 <lambdabot>  <hint>:1:9: parse error on input ‘of’
00:16:49 <opqdonut> that's the wrong behaviour
00:16:59 <opqdonut> woops, shouldn't use > for quoting
00:17:11 <opqdonut> you want truncating behaviour, which zipWith has
00:18:21 <willturner> you could filter out those short rows though, and then transpose would do the trick
00:18:34 <opqdonut> yeah
00:19:11 <opqdonut> but if you filter then you can just use "filter (...) . map (take 13) . tails"
00:19:31 <willturner> right
00:19:40 <willturner> that's what i have for my current favored solution
00:20:32 <willturner> alright, thanks for the help opqdonut 
00:30:40 <kosc_> Hello. Is there any haskell code-style checker? (Something like pep8 utility for python code)
00:30:54 <shachaf> kosc_: There is hlint.
00:31:29 <kosc_> shachaf: Thank you, thats exactly what I want.
00:32:37 <anohigisavay> hi. i want to add external dependencies that do not exist in hackage
00:32:54 <anohigisavay> what's a best convention?
00:33:00 <cocreature> anohigisavay: cabal-install or stack?
00:33:24 <oherrala> stack.yaml can point to different things for dependencies
00:33:30 <oherrala> tar ball, git repo, etc.
00:33:31 <anohigisavay> cocreature: what should i say in .cabal file? if forexample it's just another git repo?
00:33:38 <anohigisavay> oherrala: oh cool, thanks
00:33:40 <cocreature> you can’t say it in your cabal file
00:33:46 <cocreature> if you use stack follow oherrala advice
00:33:53 <pollz> Hello, I have one question regarding desugaring the do block, this doesn't seem to work: linesGet path = readfile path >>= (\handler -> lines handler)
00:33:55 <cocreature> otherwise just cabal install the package you’re interested in
00:33:59 <cocreature> or cabal sandbox add-source
00:34:08 <oherrala> condy: http://docs.haskellstack.org/en/stable/yaml_configuration/#complex-package-locations-location
00:34:13 <anohigisavay> cocreature: oherrala: thank you guys :)
00:34:27 <Cale> pollz: It's weird to name the result of readFile path "handler" -- it'll be the string contents of the file
00:34:51 <cocreature> pollz: assuming that’s the lines function from prelude, the problem is that your return type of the lambda is [String] and not IO [String] 
00:34:53 <Cale> pollz: and then the result of that lambda needs to be the action to be taken using those contents.
00:35:09 <cocreature> in this case you can just use fmap
00:35:10 <Cale> pollz: So, what did you want to do with the contents of the file?
00:35:12 <Koterpillar> pollz: lines doesn't return an IO value, you want either of (... >>= return . lines) or fmap lines (readfile path)
00:35:19 <Cale> Just return the lines?
00:37:28 <Cale> Yeah, return v is an IO action which does nothing except to, well, return v, which can be handy at the end of a do-block when you want to produce something other than the result of the previous action.
00:37:47 <Cale> (since the result of the do-block is the same as the result of the last action in it)
00:38:10 <Cale> Or similarly, at the end of a chain of (>>=)'s
00:44:34 <mikeplus64> does a ghc compiled program ever turn a value into a thunk on/during/after gc? or if it needs more memory
00:44:53 <mikeplus64> i.e. de-evaluate it
00:45:32 <Koterpillar> won't the thunk and its closure be lost by that point?
00:45:54 <mikeplus64> i suppose so
00:46:10 <Koterpillar> then it won't be able to
00:46:25 <mikeplus64> keeping every thunk around would use a lot of memory
00:46:56 <Koterpillar> every thunk or every evaluated value?
00:51:07 <Cale> mikeplus64: Yeah, no it never does that. However, what can happen is that the thing goes out of scope, is garbage collected, and then another instance of the same expression comes back into scope (e.g. the next time a function is applied)
00:51:43 <Cale> (and even if the other one wasn't GC'ed yet, if this is happening, it won't share the old result)
00:53:28 <mikeplus64> Cale: i'm thinking about something like in a 'global
00:53:42 <mikeplus64> ' hashmap to the thunks, so that probably doesn't happen here
00:53:54 <Cale> Right, that thing will just remain evaluated forever
00:53:54 <mikeplus64> i guess i'll just explicitly evaluate/de-evaluate it
00:54:10 <merijn> "de-evaluate" what does that even mean?
00:54:11 <Ornedan> Are there any good, recent tutorials for setting up logging?
00:54:13 <Cale> and so if you don't want that, you'll need to move it inward
00:54:31 <Cale> (and be careful that GHC isn't so clever as to move it back out again)
00:56:08 <Cale> Ornedan: I keep planning on writing something quick. The way I like to do it is to pass around a function whose type looks something like  LogLevel -> Text -> IO ()  -- often as part of a record of various configuration that the IO parts of my application will need.
00:56:37 <Cale> and then somewhere close to program initialisation, I might open up a file and write that function locally, using the filehandle which is in scope
00:57:05 <Cale> Or eventually, maybe I have multiple threads, and so the function really becomes something which communicates over a Chan with a logging thread.
00:58:03 <Cale> (by having one thread dedicating to writing the log, you make sure that you don't have multiple threads jamming characters in, resulting in unreadable nonsense)
01:00:03 <Cale> (Oh, and also the desired log level is in scope there too, so you can just filter out the irrelevant messages by doing nothing in that case)
01:00:30 <cocreature> you can also use monad-logger which is sort of like a reader monad around such a function
01:01:04 <Cale> I wouldn't recommend such a thing unless you already have at least one monad transformer which isn't monad-logger
01:01:13 <adarqui> anyone know what library this is? Data.JSString.Text .. it's in a react-flux example
01:01:43 <Cale> adarqui: ghcjs-base?
01:01:54 <Cale> https://github.com/ghcjs/ghcjs-base/blob/master/Data/JSString/Text.hs looks like it
01:02:18 <adarqui> cool thanks!
01:03:49 <Cale> I'm generally of the opinion that you should try to avoid transforming IO as long as possible until you have a pretty clear idea of a fairly comprehensive API you're going to provide in whatever monad it is that's not IO, such that usages of liftIO are going to be minimal.
01:03:56 <Cale> (or nonexistent, if possible)
01:08:23 * hackagebot markov-chain 0.0.3.4 - Markov Chains for generating random sequences with a user definable behaviour.  https://hackage.haskell.org/package/markov-chain-0.0.3.4 (HenningThielemann)
01:13:23 * hackagebot json-rpc-generic 0.0.1.0 - Generic encoder and decode for JSON-RPC  https://hackage.haskell.org/package/json-rpc-generic-0.0.1.0 (KeiHibino)
01:17:37 <clarabella> hi all, a question for the computer science folks: http://cs.stackexchange.com/questions/60556/maximum-cardinality-subgraphs-meeting-a-jaccard-overlap-threshold unfortunately nomody answered. can you give it a shot? thanks!
01:23:23 * hackagebot fortran-src 0.1.0.0 - Parser and anlyses for Fortran standards 66, 77, 90.  https://hackage.haskell.org/package/fortran-src-0.1.0.0 (DominicOrchard)
01:45:31 <adarqui> anyone here good with ghcjs? trying to figure out why I get errors requiring ghcjs-base, in this example: https://bitbucket.org/wuzzeb/react-flux/src/a703682ba55a2891f661e935c6263ab61b62ac6f/example/routing/Router.hs?at=default&fileviewer=file-view-default#Router.hs-26 .... i'm compiling with a stack.yaml which has ghcjs specified etc: http://hastebin.com/goyubepeni.txt
01:48:33 <merijn> adarqui: CPP is not enabled in that module?
01:48:35 <adarqui> hmm i think i might have fixed it.. i added if impl(ghcjs) .. build-depends: ghcjs-base to my blah.cabal in the directory that i'm compiling using ghc.. i had that in the ghcjs directory's .cabal
01:48:44 <adarqui> merijn: ^^ ;f i think i got it with that
01:59:43 <adarqui> 2/win 2
02:22:19 <stobix> Just out of interest: would it be possible to build something monad transform like, but containing two monads instead of one?
02:23:12 <merijn> stobix: What does it mean "to contain two monads", sounds like a single monad that does the same thing as two separate ones :p
02:23:52 <merijn> stobix: If you can build two separate transformers for said monads, then, by definition you can define at least two different versions of a monad that does both things at once
02:24:26 <stobix> merijn: Good question, and maybe at the heart of it all. Lemme think.
02:24:40 <merijn> Since, if FooT and BarT obey the monad transformer laws than both the composition "FooT (BarT m) a" and "BarT (FooT m) a" must be valid monads which, may or may not do the same thing
02:27:33 <stobix> Let's say you have two Foo monads, and you put them into TwoMonadThing (Foo) (Foo) a, being able to liftR or liftL depending on which Foo you want to use
02:28:14 <stobix> What I'm after is having a 'dependency tree' instead of a 'dependency list'.
02:29:53 <srhb> stobix: Normally a monad transformer is a monad as well. TwoMonadThing itself can't be.
02:30:09 <Cale> stobix: How is that supposed to work?
02:30:24 <srhb> stobix: Whether that's a problem for you, I don't know. :-)
02:30:32 <Cale> What's TwoMonadThing [] IO a
02:31:50 <stobix> Hm, so there's no way to make TwoMonadThing be a monad encapsuling two other monads?
02:32:13 <Cale> Not really. The composition of two monads is in general not a monad.
02:32:45 <Cale> Suppose we have monads M and N
02:33:22 <Cale> and suppose we want to make M . N into a monad (not actually Haskell notation, I mean the composite of those type level functions)
02:33:52 <Cale> Then one of the things we need to be able to define is  join :: M (N (M (N a))) -> M (N a)
02:34:46 <Cale> If we had N (M b) -> M (N b) (which would also need to satisfy some conditions in order to make the monad laws work out)
02:34:57 <stobix> ah, yeah, join gets weird...
02:35:02 <Cale> then we could use it to swap the inner N M
02:35:26 <Cale> to obtain M (N (M (N a))) -> M (M (N (N a)))
02:35:38 <Cale> and then use the join for M and the join for N to get where we wanted
02:35:46 <Cale> But in general, that's not going to exist
02:35:52 <eklavya_> does the GHC know that IO is a special type and involves effetcs?
02:36:14 <liste> eklavya_: it doesn't
02:36:35 <eklavya_> which layer is aware of this?
02:36:56 <eklavya_> also if it doesn't know IO is special
02:37:02 <Cale> eklavya_: Not 100% sure what the question means, but it doesn't need to be aware of this in principle. Values of type IO t merely need to *describe* effects
02:37:30 <eklavya_> how does it go about executing it differently than anything else?
02:37:55 <Cale> Well, as a mental model of what an IO type which was more principled than GHC's actual representation would look like
02:38:15 <Cale> We can define something like...
02:38:29 <merijn> eklavya_: IO is not special cased in GHC's typechecker/code generator, if that's what you mean
02:38:45 <Cale> @let data MyIO a = Return a | GetChar (Char -> MyIO a) | PutChar Char (MyIO a)
02:38:46 <lambdabot>  Defined.
02:39:10 <merijn> eklavya_: The implementation of IO is written in GHC haskell (not portable haskell, because it uses GHC primitives which are not portable)
02:39:17 <Cale> Of course, probably we really want a lot more than character-based terminal IO, but hopefully this is enough to start to get an idea, once we implement some operations
02:39:31 <merijn> eklavya_: Although IO *could* have been implemented in portable haskell too, but it'd be slower/harder to optimise during compilation
02:39:35 <Cale> @let myGetChar = GetChar (\c -> Return c)
02:39:37 <lambdabot>  Defined.
02:39:51 <Cale> @let myPutChar c = PutChar c (Return ())
02:39:54 <lambdabot>  Defined.
02:39:58 <Cale> :t myPutChar
02:40:00 <lambdabot> Char -> MyIO ()
02:40:28 <Cale> Now, we can write an interpreter which, if it's written in Haskell will be a little funny, since it'll translate this type into IO
02:41:03 <eklavya_> ok
02:41:04 <Cale> But basically, you can imagine a program sitting in memory, pattern matching on the type and carrying out the effects described in a similar way
02:41:07 <eklavya_> but reading this
02:41:37 <eklavya_> ok so somebody has to know about my MyIO type and actually go and execute the effect, right?
02:42:09 <Cale> Yes, presumably the runtime system
02:42:18 <stobix> Cale: Not sure if I understand fully yet; Why can a monad transformer containing a monad be a monad when a similar thing containing two monads couldn't? Why would the structure of the enclosed thing mess with the properties of the container?
02:42:25 <Cale> GHC doesn't *actually* do it this way though
02:43:13 <eklavya_> so ghc needs to insert the runtime code at some point, doesn't it need to know that IO is about effects for that?
02:43:20 <Cale> It just uses values of function types whose evaluation triggers effects, and there's a bit of careful contrivance with the data dependencies to ensure that the order in which the effects happen will be the one we really want.
02:43:26 * hackagebot makefile 0.1.0.2 - Simple Makefile parser  https://hackage.haskell.org/package/makefile-0.1.0.2 (nmattia)
02:43:50 <eklavya_> so who takes care of that scheduling?
02:44:04 <srhb> stobix: TwoMonadThing m m' _could_ be a monad for some specific m, m'.
02:44:18 <eklavya_> because runtime won't know what I wanted, no?
02:44:27 <srhb> stobix: Specifically you could implement it in terms of transformers.
02:44:33 <srhb> stobix: (Which is useless indirection, of course)
02:44:49 <merijn> eklavya_: Why does it need to know that?
02:45:06 <merijn> eklavya_: It just needs to make sure that it doesn't change the ordering of IO things
02:45:14 <daniel-s> Hi
02:45:25 <daniel-s> If I have "Just 5" how can I do something with it?
02:45:39 <srhb> daniel-s: In many ways! What do you need to do with it?
02:45:45 <eklavya_> merijn: I don't understand any of it so forgive me if it sounds really stupid :P
02:45:45 <srhb> > fmap (+2) (Just 2)
02:45:46 <eklavya_> but
02:45:47 <lambdabot>  Just 4
02:45:50 <Cale> eklavya_: Well, it can generate whatever code it likes. It might just stick a working interpreter for this type into the program at the start. It might just hijack its own evaluation machinery with code that's going to have effects.
02:46:06 <daniel-s> I want access to the 5.
02:46:33 <srhb> daniel-s: What if it's a Nothing instead of Just 5?
02:46:37 <eklavya_> ghc will reorder program execution anyway it likes because everything is just functions and they are referentially transparent, so parallalize at will etc
02:46:40 <boj> daniel-s: you probably want to pattern match with case then
02:46:42 <eklavya_> but not in case of IO
02:46:46 <srhb> daniel-s: You'd usually use maybe, or case with pattern matching.
02:46:53 <eklavya_> so somebody needs to take care of that, no?
02:46:54 <srhb> :t maybe
02:46:55 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:47:11 <srhb> > maybe 0 id (Just 5) 
02:47:13 <lambdabot>  5
02:47:14 <srhb> > maybe 0 id Nothing 
02:47:16 <lambdabot>  0
02:47:20 <maerwald> don't bombard him with functions plz
02:47:21 <eklavya_> Cale: how do we mark that something is going to have effects?
02:47:25 <merijn> eklavya_: Well, you can't reorder arbitrarily
02:47:37 <eklavya_> whenever makes sense
02:47:51 <eklavya_> but extra care would be needed in IO (or not?)
02:48:17 <merijn> eklavya_: Suppose I have "foo :: s0 -> (Foo, s1)" and "bar :: s1 -> (Bar, s2)" I can never run 'bar' before 'foo', right?
02:48:26 * hackagebot makefile 0.1.0.3 - Simple Makefile parser  https://hackage.haskell.org/package/makefile-0.1.0.3 (nmattia)
02:48:28 <eklavya_> yes
02:48:35 <eklavya_> but
02:48:36 <Cale> eklavya_: Basically, what it really uses is something along the lines of  data IO a = IO (() -> ((), a)), but where the ()'s have been optimised down to 0-byte wide things, and the "functions" it uses are dangerous effectful ones, but it arranges the data dependencies so that things will evaluate in the right order, the way we expect execution to occur
02:48:41 <merijn> eklavya_: Because 'bar' relies on something created from 'foo'
02:48:44 <nmattia> ^^ sorry about the noise
02:48:48 <Cale> This is a terrible mental model for understanding IO as a type of course.
02:48:49 <eklavya_> if I don't have a data dependency
02:49:06 <Cale> The monad instance for IO puts all the data dependencies in for you
02:49:16 <merijn> eklavya_: Who says you don't? You could easily implement the IO type to have one? :)
02:49:27 <eklavya_> ohh
02:49:35 <eklavya_> so oh
02:49:35 <Cale> (as well as other IO-related primitive operations)
02:49:43 <merijn> eklavya_: It's just that such tricks are an implementation detail
02:49:52 <eklavya_> so it has an inserted dummy dependency on the previous stage?
02:49:53 <daniel-s> OK. Thanks srhb
02:49:53 <maerwald> it's called RealWorld!
02:50:02 <merijn> eklavya_: Nothing says you *have* to implement it that way, but you can (and GHC does)
02:50:05 <Cale> There's nothing particularly special about the fact that it's a monad either -- it's just whatever operations we use to combine IO actions arrange that the data dependencies are good.
02:50:13 <daniel-s> TBH, I get that I would pattern match, otherwise I don't think I get it.
02:50:16 <merijn> maerwald: I prefer not mentioning the name, it provokes all sorts of bad connotations
02:50:22 <maerwald> heh
02:50:31 <srhb> daniel-s: The whole idea, of course, is to stick in the Maybe context for as long as you can, meaning you don't have to think about the Nothing case. When you finally need to supply a value, then you decide on a defaulting strategy (or failure, or whatever)
02:50:32 <Cale> eklavya_: But yeah, the other model is prettier and easier to think about
02:50:33 <stobix> srhb: So, let's say we build a StateTT s m m', with StateTT being a state monad conaining two states. You're saying that StateTT can only be a monad for specific m, m'?
02:50:33 <maerwald> I don't find that paper from SPJ that bad
02:50:41 <eklavya_> so everything is treated the same
02:50:43 <Cale> eklavya_: (but perhaps harder to make efficient)
02:50:46 <merijn> eklavya_: Incidentally, the paper "Lazy Function State Threads" explains the trick that's used to implement both ST and IO
02:51:01 <Cale> eklavya_: Yeah, by excessive contrivance
02:51:27 <shachaf> i,i contrivariance
02:51:34 <Cale> hah
02:51:41 <merijn> eklavya_: In (GHC) reality both ST and IO are specialisations of an underlying, more primitive, monad
02:51:47 <eklavya_> let me look that up
02:52:07 <eklavya_> and that hooks up in the runtime?
02:52:39 <srhb> stobix: I'm saying that if your type is really a type alias for a monad transformer type, then you trivially have a monad already.
02:52:41 <merijn> eklavya_: I'd say the runtime hooks into that, by defining runtime primitives to match that type :)
02:52:57 <Cale> eklavya_: Well, in *this* view, the evaluator just ends up tripping over the code which causes effects
02:53:04 <merijn> eklavya_: But at some point it becomes hard to decide which way is which when talking about implementations
02:53:44 <Cale> eklavya_: In the other approach I was going to give you, some executor, separate from the evaluator, would be pattern matching the IO action values and carrying out the effects they described.
02:53:48 <merijn> eklavya_: runtime primitives have effect, but GHC doesn't know this. It just has a data dependency that prevents reordering, so the fact that calling runtime code causes effects isn't something it has to care about
02:54:16 <eklavya_> Cale: understood
02:54:23 <eklavya_> merijn: understood
02:54:27 <merijn> eklavya_: So in that sense, IO isn't special, because GHC isn't really aware of the notion of side effects :)
02:54:42 <eklavya_> wow, so simple :P
02:54:45 <eklavya_> a related question
02:54:49 <Cale> I believe Idris does it in a way closer to that algebraic type example
02:55:06 <Cale> Where it has some fairly general constructors that say how to do an FFI call, basically.
02:55:31 <eklavya_> and those are translated while generating code?
02:55:44 <merijn> eklavya_: tbh, the base concept of compilation is rather simple anyway. You just need to look past the aura of magic :)
02:55:56 <Cale> They could be, or if you're a lazy implementor, you just do runtime interpretation.
02:56:13 <Cale> But yeah, why not just interpret at compile time?
02:56:29 <Cale> and just generate code that does what the interpreter would have done
02:56:30 <stobix> srhb: Well, yeah. What I'm trying to build is basically a thing that has liftFirst and liftSecond instead of lift. If this (is possible and) can be seen as a transformer, then it's a monad for sure.
02:56:41 <Cale> which you can then subject to further simplifications
02:56:59 <_gio> hi
02:57:10 <_gio> I was reading here https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#infix-type-constructors-classes-and-type-variables
02:57:31 <eklavya_> I assumed/read/heard that ghc will parallelize where it can automatically, is that true?
02:57:36 <Cale> no
02:57:39 <eklavya_> if I have no dependencies in the do chain
02:57:42 <eklavya_> will it
02:57:44 <eklavya_> oh
02:57:47 <maerwald> Cale: do you actually want simplifications when you are "talking with the RTS" in a more direct manner? That's how I understood you at least
02:58:47 <Cale> maerwald: Well, so long as the program does the same stuff in the end, it might be able to get it done faster if it can avoid producing the data constructors which the executor would then immediately pattern match on
02:58:53 <eklavya_> so even branches of do where there are no dependencies, it won't execute them parallelly?
02:59:00 <merijn> eklavya_: No
02:59:13 <Cale> eklavya_: *Especially* not for IO
02:59:22 <merijn> eklavya_: There's tools that make parallelisation (and concurrency) easier, but GHC doesn't magically do that
02:59:30 <eklavya_> I would swear I had heard it in the GHC 8 features introduction video
02:59:40 <srhb> stobix: Right, which would mean id and lift, or lift and lift . lift, etc...
02:59:53 <srhb> stobix: Anyway, I have to get some lunch.
03:00:02 <merijn> eklavya_: Auto-parallelisation is ridiculously hard to do. Better have programmers do it but give them better tools :)
03:00:07 <Cale> eklavya_: You might be confusing this with the ApplicativeDo feature, which translates the do-notation into Applicative operations where possible
03:00:21 <eklavya_> yeah and while explaining that
03:00:26 <stobix> srhb: Ah. Thanks for your time. Eat good.
03:00:28 <Cale> eklavya_: which means that if you have your own monad that introduces concurrency in the implementation of <*>
03:00:30 <eklavya_> I think concurrent execution was mentioned
03:00:34 <Cale> then you can get concurrency
03:00:51 <Cale> But IO does not, very intentionally.
03:00:54 <eklavya_> oh
03:00:55 <eklavya_> ok
03:00:58 <eklavya_> got it
03:01:37 <_gio> there (my previous link) I read that I can use an infix operator as a type constructor, like: data a :*: b = Foo a b
03:01:53 <Cale> _gio: yes
03:02:34 <_gio> and even here https://prime.haskell.org/wiki/InfixTypeConstructors they say that you can write something like this: data a :+ b = Left a | Right b
03:02:49 <eklavya_> thank you so much for your time Cale merijn :)
03:03:26 * hackagebot microlens-mtl 0.1.9.0 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.9.0 (Artyom)
03:03:46 <_gio> but it does not work. I have to declare the TypeOperators extension to the language to make the compiler happy
03:04:47 <Cale> _gio: That's right, the thing which the manual is describing there is the TypeOperators extension.
03:05:10 <Cale> _gio: This whole chapter of the User's Guide is about language extensions that GHC implements.
03:05:35 <Cale> You're meant to specify which ones you're using in a LANGUAGE pragma at the top of your file, like {-# LANGUAGE TypeOperators #-}
03:05:51 <_gio> yeah...
03:06:10 <eklavya_> I need to write a TCP client, what is the common way of doing that, conduit?
03:06:42 <Cale> eklavya_: As in, not IP?
03:06:50 <eklavya_> yeah TCP/IPv4
03:07:00 <stobix> srhb: basically, whereas lift for a transformer only lifts from one 'heap' of inner monads, so to say, liftFirst and liftSecond from a 'double transformer' would lift the first or second inner monad, respectively. If these inner monads, in turn, are 'double transformers', we can have liftFirst.liftSecond, liftFirst.liftFirst etc instead of just lift.lift.lift..., giving us a tree like structure of inner mo
03:07:06 <stobix> nads. If it is at all possible.
03:07:44 <Cale> There are a bunch of conduit and pipes things for that, but depending on how sophisticated your application is, you might just want to start out without the heavy machinery they provide.
03:07:54 <stobix> (Oh, random line break on too long sentences?)
03:07:55 <eklavya_> no no no
03:08:04 <eklavya_> I defnitely need all the help I can get :P
03:08:23 <_gio> it's a little ambiguous because the TypeOperators extension is cited in the subsequent paragraph (9.4.4)
03:08:24 <eklavya_> I am new to haskell, one problem at a time :D
03:08:26 <Cale> Well... how happy are you dealing with types that have 4 or more type parameters?
03:08:27 * hackagebot microlens-platform 0.3.3.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.3.3.0 (Artyom)
03:08:41 <maerwald> conduit is a mess and has a lot of legacy API
03:08:44 <eklavya_> yeah as long as it's not super hard, no problem
03:08:51 <maerwald> not very friendly for beginners
03:08:59 <eklavya_> maerwald: what do you recommend?
03:09:00 <Cale> I've been programming in Haskell for 15 or so years now, and it's not really so friendly for me.
03:09:07 <maerwald> eklavya_: what Cale said, start without.
03:09:07 <eklavya_> oh
03:09:18 <Cale> http://hackage.haskell.org/package/network
03:09:23 <eklavya_> so the socket API?
03:09:24 <sbrg> I don't feel like conduit is a mess, but I agree that it's not simple to use for beginners
03:09:36 <Cale> uhh... only if you really need it
03:09:50 <eklavya_> yeah I need to take care of frame not being available completely in that
03:10:03 <eklavya_> and I am not sure I can do all that in haskell right now
03:10:08 <eklavya_> that seems ery imperative
03:10:15 <Cale> A lot of the time, you can just get by with listenOn/accept for a server, and connectTo for a client.
03:10:20 <eklavya_> and takes and drops will work or not I don't know
03:10:28 <woffs> (what about http://hackage.haskell.org/package/connection ?)
03:10:44 <Cale> and those give you a Handle which you can use with the stuff in Data.ByteString or whatever to read and write.
03:10:55 <Cale> (see also System.IO)
03:11:14 <eklavya_> and they will manage data retrieval ?
03:11:14 <_gio> ok, thanks
03:11:30 <Cale> and the usual pattern for a server is just to have accept in a tight loop, where every time accept returns, you forkIO a new thread to handle that client.
03:11:33 <eklavya_> I mean can I just say give me a 1024 length chunk and they will wait until it comes?
03:11:41 <Cale> Yeah.
03:11:54 <eklavya_> did I look at the wrong docs again :P
03:11:57 <sbrg> eklavya_: you can assume that what you send will arrive as a whole on the other end
03:12:13 <eklavya_> it said I need to take care of that
03:12:13 <Cale> and because you're handling each client in its own thread, you don't have to worry about blocking IO operations so much
03:12:33 <eklavya_> that I might not get the whole chunk in one go and I need to read again and again 
03:12:42 <Cale> All (or most at least) of the blocking IO in Haskell is really implemented at a lower level using non-blocking IO
03:12:58 <Cale> and the RTS will use select/epoll/kqueue/whatever for you
03:13:36 <eklavya_> ok
03:13:46 <_gio> 👋
03:15:26 <eklavya_> hackage says I should not use send and recv from this package
03:15:26 <eklavya_> http://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket.html#t:ByteString
03:15:38 <eklavya_> but use it from BytString module
03:15:43 <eklavya_> but the link doesn't work
03:16:05 <maerwald> https://hackage.haskell.org/package/network-2.6.2.1/docs/Network-Socket-ByteString.html
03:16:27 <Cale> You're sure you need Network.Socket?
03:16:38 <eklavya_> that's what you recommended?
03:16:40 <Cale> no
03:16:44 <Cale> I said just Network
03:16:54 <eklavya_> :P
03:17:41 <hpc> i was looking the other day and saw that Network was deprecated
03:17:47 <hpc> and connectTo isn't defined anywhere else
03:17:48 <eklavya_> much easier 
03:17:51 <maerwald> Network also uses String, which is just outright wrong
03:17:52 <hpc> seems really weird
03:18:13 <maerwald> String is a plague
03:18:18 <Cale> Well, don't use the part of it which uses String
03:18:18 <eklavya_> maerwald: yeah, why no ByteString?
03:18:24 <muzzle> hi
03:18:25 <Cale> Just open a Handle, and that's all you need
03:18:28 <maerwald> eklavya_: you can use the Handle manually
03:18:33 <muzzle> what does inherent_use mean in biographical profiling?
03:19:08 <Cale> *Especially* don't use Network.sendTo/Network.recvFrom except for silly tests from GHCi
03:19:26 <maerwald> but I usually avoid Handles and use low-level unix stuff instead
03:19:35 <Cale> The Handles are nice though
03:19:40 <eklavya_> handle apis also return String?
03:19:52 <davidkart> ertes
03:20:01 <davidkart> is not there
03:20:07 <Cale> eklavya_: There are Handle-related functions for ByteString and Text, in the appropriate modules in those packages.
03:20:09 <davidkart> I was willing to write a concatMap function.
03:20:17 <daniel-s> dropWhile (\x -> case x of {3 -> True; _ -> False}) [1,2,3,4,4,5]
03:20:17 <davidkart> No, rather a replicateM
03:20:48 <daniel-s> That line doesn't collect any values, where I thought it would collect [4,4]
03:20:51 <Cale> hGet :: Handle -> Int -> IO ByteString -- Read a ByteString directly from the specified Handle. This is far more efficient than reading the characters into a String and then using pack. First argument is the Handle to read from, and the second is the number of bytes to read. It returns the bytes read, up to n, or empty if EOF has been reached.
03:21:05 <maerwald> Cale: actually, I only see the one for Text
03:21:25 <Cale> That's in Data.ByteString
03:21:40 <Cale> It will generally block until it has enough bytes
03:21:44 <hpc> > dropWhile (\x -> case x of {3 -> True; _ -> False}) [1,2,3,4,4,5]
03:21:46 <lambdabot>  [1,2,3,4,4,5]
03:21:57 <Cale> But may return fewer in the case that the Handle closes or something.
03:22:10 <maerwald> I prefer file descriptors :P
03:22:13 <eklavya_> is there a way to differentiate between GHC/libs provided packages and community ones?
03:22:19 <eklavya_> in hackage
03:22:20 <hpc> > filter (\x -> case x of {3 -> True; _ -> False}) [1,2,3,4,4,5]
03:22:20 <Cale> I don't :P
03:22:23 <lambdabot>  [3]
03:22:36 <Cale> eklavya_: hm
03:22:40 <eklavya_> because in the same namespace there are many packages sometimes
03:22:43 <hpc> > filter (\x -> case x of {3 -> False; _ -> True}) [1,2,3,4,4,5] -- daniel-s
03:22:45 <lambdabot>  [1,2,4,4,5]
03:22:53 <eklavya_> and I don't know which one I should use
03:23:15 <Cale> Well, if the maintainer is libraries@haskell.org
03:23:18 <hpc> daniel-s: yours drops while x is 3, starts at 1 which isn't 3, and stops
03:23:27 <Cale> You can be pretty sure it's reasonably well-blessed
03:24:06 <hpc> > dropWhile (<= 3) [1, 2, 3, 4, 4, 5]
03:24:07 <eklavya_> is this the bytestring module http://hackage.haskell.org/package/bytestring ?
03:24:08 <lambdabot>  [4,4,5]
03:24:30 <Cale> Oh, I guess network doesn't actually say that at the cabal level.
03:24:32 <Cale> huh
03:24:43 <Cale> The documentation says that the maintainer is libraries@
03:25:08 <eklavya_> doesn't it say duncan@community.haskell.org ?
03:25:24 <Cale> https://hackage.haskell.org/package/network-2.6.2.1/docs/Network.html -- I was looking here
03:25:37 <Cale> ah, bytestring, yeah
03:26:14 <eklavya_> ok so haskell.org in the email is good enough  :D
03:26:39 <davidkart> Hey buddies, I think I have a problem.
03:26:45 <Cale> For the most part, that's a decent sign :)
03:26:53 <Cale> haha
03:26:59 <eklavya_> thanks Cale maerwald sbrg :)
03:27:14 <davidkart> Can you look at this :first definition : f 1 xs = map(\x->(x:) []) xs ; then look at this one : f 1 xs = map(\x-> [x]) xs
03:27:23 <davidkart> you see the first is not working *at all*
03:27:30 <davidkart> the second is working ok
03:27:59 <davidkart> Why the ':' version is ont working and what should it be don to solve this problem ?
03:28:15 <Cale> @let foo 1 xs = map(\x->(x:) []) xs
03:28:18 <lambdabot>  Defined.
03:28:21 <Cale> > foo [1,2,3,4,5]
03:28:23 <lambdabot>      No instance for (Num [t0]) arising from a use of ‘foo’
03:28:23 <lambdabot>      In the expression: foo [1, 2, 3, 4, ....]    No instance for (Num t0) ar...
03:28:23 <lambdabot>      The type variable ‘t0’ is ambiguous
03:28:31 <Cale> > foo 1 [1,2,3,4,5]
03:28:33 <lambdabot>  [[1],[2],[3],[4],[5]]
03:28:52 <Cale> why the pattern match against 1? :)
03:29:05 <Cale> Well, perhaps this is a base case
03:29:11 <Cale> Anyway, that version seems to work
03:30:09 <Cale> davidkart: Maybe something else was going on, are you sure you were testing the right code?
03:30:44 <davidkart> I don't know. Suddenly after some tweaking it was working
03:30:54 <stobix> Aha! So, my 'double transform' thing wouldn't work, because the 'tree' it would build would essentially try to run all the leaf actions at once. 
03:31:04 * stobix thinks he dinged. Or something.
03:31:28 <davidkart> http://pastie.org/10907043
03:31:30 <stobix> Thanks for the help, Cale , srhb .
03:32:30 <Cale> davidkart: But anyway [x] is way more idiomatic than (x:) []
03:32:34 <daniel-s> thanks hpc
03:32:55 <davidkart> ok
03:33:08 <davidkart> so it needs to be in general I  just put (x:) []
03:33:12 <davidkart> it's ok now it works
03:33:52 <hpc> @check \x -> ((x:) []) == [x]
03:33:54 <lambdabot>  +++ OK, passed 100 tests.
03:33:55 <daniel-s> hpc: I was confused about what dropWhile and filter did.
03:36:19 <davidkart> @let allCodes 1 xs = map(\x-> (x:) []) xs
03:36:19 <davidkart>  @let allCodes n xs= concatMap ( \x->map (x:) (f (n-1) xs) ) xs
03:36:19 <davidkart>  > allCodes 4 [1..9]
03:36:21 <lambdabot>  Defined.
03:37:02 <davidkart> @let allCodes n xs= concatMap ( \x->map (x:) (f (n-1) xs) ) xs
03:37:04 <lambdabot>  Defined.
03:37:11 <davidkart> > allCodes 4 [1..9]
03:37:12 <lambdabot>      No instance for (Show a0)
03:37:12 <lambdabot>        arising from a use of ‘show_M154208151745494095323916’
03:37:12 <lambdabot>      The type variable ‘a0’ is ambiguous
03:37:54 <davidkart> @allCodes n xs= concatMap ( \x->map (x:) (allCodes (n-1) xs) ) xs
03:37:54 <lambdabot> Unknown command, try @list
03:38:00 <davidkart> @let allCodes n xs= concatMap ( \x->map (x:) (allCodes (n-1) xs) ) xs
03:38:01 <lambdabot>  .L.hs:200:1: Warning:
03:38:02 <lambdabot>      Pattern match(es) are overlapped
03:38:02 <lambdabot>      In an equation for ‘allCodes’: allCodes n xs = ...
03:38:08 <davidkart> > allCodes 4 [1..9]
03:38:10 <lambdabot>      No instance for (Show a0)
03:38:10 <lambdabot>        arising from a use of ‘show_M574914206098142277923948’
03:38:10 <lambdabot>      The type variable ‘a0’ is ambiguous
03:38:13 <davidkart> grm
03:38:19 <hpc> you can pm lambdabot
03:38:39 <davidkart> yes I just did.
03:38:42 <davidkart> thanks
03:44:57 <davidkart> it is complicated to write good functions
03:45:12 <davidkart> especially with recursion I had to do pattern matching
03:45:25 <sbrg> yeah, programming is hard
03:45:29 <davidkart> no rather to use guards. Pattern matching didn't work
03:45:37 <davidkart> I suppose it is because of shadowing.
03:46:06 <davidkart> I don't really know why.
03:46:18 <davidkart> > 6**8
03:46:20 <lambdabot>  1679616.0
03:47:09 <davidkart> how do you encode error ?
03:49:22 <liste> davidkart: usually Maybe, Either, ExceptT or IO Exceptions
03:55:31 <eklavya_> how to write hex literals?
03:55:36 <eklavya_> > "\x04"
03:55:38 <lambdabot>  "\EOT"
03:56:08 <eklavya_> is that not how?
03:57:18 <Mon_Ouie> literals of what? Strings? Integers?
03:57:48 <hpc> > 0xdeadbeef
03:57:51 <lambdabot>  3735928559
03:57:51 <eklavya_> hex numbers
03:58:19 <eklavya_> oh
03:58:26 * hpc misses the Num instance that made 0xford = 15
03:58:50 <eklavya_> I need to make a ByteString of some hex literals
03:59:02 <Cale> hpc :)
03:59:26 <Cale> Very parser
03:59:34 <Cale> such lexical analysis
04:00:39 <danza> wow
04:01:11 <Cale> @let instance Num b => Num (a -> b) where fromInteger n x = fromInteger n
04:01:13 <lambdabot>  .L.hs:201:10: Warning:
04:01:13 <lambdabot>      No explicit implementation for
04:01:13 <lambdabot>        ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
04:01:21 <Cale> > 0xford
04:01:23 <lambdabot>      No instance for (Show a0)
04:01:23 <lambdabot>        arising from a use of ‘show_M180111687132937312824428’
04:01:23 <lambdabot>      The type variable ‘a0’ is ambiguous
04:01:34 <Cale> > 0xford :: Integer
04:01:36 <lambdabot>      No instance for (Num ((Char -> Int) -> Integer))
04:01:36 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
04:01:36 <lambdabot>        arising from the literal ‘15’
04:01:57 <hpc> Cale: it's not quite as controversial as the lexical syntax of comments, but i enjoy it nonetheless
04:01:58 <Cale> Oh, did it eat my instance because of the warnings?
04:02:46 <Cale> @let instance Num b => Num (a -> b) where { (+) = liftA2 (+); (*) = liftA2 (*); abs = fmap abs; signum = fmap signum; negate = fmap negate; fromInteger n x = fromInteger n }
04:02:48 <lambdabot>  Defined.
04:02:53 <Cale> > 0xford
04:02:56 <lambdabot>  15
04:02:59 <Cale> there we go
04:03:19 <hpc> easy every time
04:03:31 <merijn> eklavya_: ByteString of hex literals the simplest way is probably just a list of hex literals (assuming they're <=255 :p)
04:03:56 <merijn> wow, wait
04:04:07 <merijn> Is that parsing as "0xf" applied to ord?
04:04:10 <Cale> yes
04:04:30 <Cale> Also, look at that error message in which the compiler quotes 0xf to us as the literal ‘15’
04:04:32 <hpc> well, ord applied to 0xf but yes
04:04:41 <Cale> No, it's the other way around.
04:04:42 <hpc> or... something
04:04:44 <merijn> hpc: No
04:04:47 <Cale> It's 0xf applied to ord
04:04:56 <Cale> 0xf is a function, a constant function
04:04:57 <merijn> "0xf ord" applies 0xf to ord
04:05:03 <merijn> Hence the warning
04:05:08 <merijn> (Num ((Char -> Int) -> Integer))
04:05:13 <merijn> :t ord
04:05:15 <lambdabot> Char -> Int
04:05:18 * hpc can never parse "applied to" correctly
04:05:27 <Cale> Functions are always applied to their arguments
04:05:43 <srhb> out of context, that's a very strange claim. :-)
04:05:53 <Cale> hah
04:07:17 <eklavya_> > 0x12345 :: ByteString
04:07:18 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
04:07:18 <lambdabot>      Perhaps you meant one of these:
04:07:18 <lambdabot>        ‘Data.ByteString.Char8.ByteString’ (imported from Data.ByteString.Char8),
04:07:47 <eklavya_> is that possible?
04:07:51 <mniip> yes
04:07:55 <eklavya_> yay!!
04:08:17 <eklavya_> maybe it's my import then
04:09:05 <merijn> eklavya_: Use ByteString.pack
04:09:24 <merijn> > Data.ByteString.pack [0xff]
04:09:26 <lambdabot>  "\255"
04:09:34 <merijn> > Data.ByteString.pack [0xff, 0x00, 0xf4]
04:09:36 <lambdabot>  "\255\NUL\244"
04:09:54 <eklavya_> merijn: thanks :)
04:10:01 <merijn> :t Data.ByteString.pack
04:10:03 <lambdabot> [Word8] -> Data.ByteString.Char8.ByteString
04:10:18 <merijn> eklavya_: Note that because it's Word8 all entries are truncated to fit into 1 byte
04:10:50 <merijn> Although I think GHC should warn about overflows for literals?
04:11:00 <eklavya_> understood
04:13:11 <mniip> > 0x12345 :: BS.ByteString
04:13:13 <lambdabot>  "\SOH#E"
04:13:26 <merijn> Is that a Num instance of ByteString?
04:13:30 <mniip> yes
04:13:31 <merijn> That's vile
04:13:47 <mniip> > 0x4142434445 :: BS.ByteString
04:13:49 <lambdabot>  "ABCDE"
04:14:20 <hpc> did you just @let that?
04:14:47 <Mateon1> hpc: Not neccesarily. Certain ASCII char ranges are easy to remember
04:14:54 <hpc> i mean the instance
04:14:56 <mniip> yes
04:15:12 <daey> i know im not allowed to use <- as the last operation in a do block. at the same time i need a do block for IO() things. how would i write a function taht returns a text file as a string?
04:15:34 <srhb> daey: You wouldn't.
04:15:43 <daey> o0
04:16:01 <srhb> daey: You stay in IO String, or you have a function that works on a String -> String inside your IO something
04:16:06 <maerwald> daey: x <- getFileContents ; return x -- is the same as just 'getFileContents'
04:16:15 <maerwald> as the last statement in a do-block
04:16:46 <daey> i thought the <- strips the IO() part of IO String away
04:17:01 <maerwald> daey: it's syntax sugar
04:17:05 <srhb> daey: It's just handy syntax, you're really just lifting functions to work on IO values
04:17:11 <maerwald> you should check what >>= etc means
04:17:30 <hpc> daey: "x <- getFileContents" translates to "getFileContents >>= \x ->"
04:17:33 <srhb> @undo do { x <- foo; return (x+2) }
04:17:33 <lambdabot> foo >>= \ x -> return (x + 2)
04:17:40 <hpc> which is not a complete expession
04:17:46 <hpc> and that's why you can't end a do-block with it
04:18:00 <Mateon1> daey: You forget about the arrow, `x <- readFile; return x` is the same as `readFile`
04:18:23 <LACampbell> hello. can a parameter in a type signature be constrained by multiple type classes?
04:18:32 <daey> so once impure always impure?
04:18:34 <srhb> LACampbell: Yes, in parens
04:18:34 <merijn> LACampbell: Sure
04:18:49 <srhb> LACampbell: (Num a, Ord a) => a -- for instance
04:18:52 <hpc> :t \x -> show (x / 2)
04:18:53 <daey> makes sense i guess
04:18:53 <lambdabot> (Fractional a, Show a) => a -> String
04:19:01 <maerwald> daey: s/impure/inside IO/
04:19:10 <merijn> daey: Technically IO isn't impure
04:19:15 <merijn> That's the entire point of having it
04:19:31 <srhb> daey: The type signature of (>>=) is the guarantee
04:19:33 <srhb> :t (>>=)
04:19:34 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:19:35 <LACampbell> ah so that's the syntax. I hadn't run across any examples yet
04:19:57 <daey> srhb: will look into it
04:20:00 <merijn> LACampbell: You can have any number of typeclass constraint on any number of variables in a type :)
04:20:26 <mniip> > (0x4142434445 :: BS.ByteString) + 0x102
04:20:28 <lambdabot>  "ABCEG"
04:20:38 <daey> but just for the understanding. my pure functions are used within the scope of IO() not IO() in the scope of them, correct?
04:20:41 <daey> i assumed later
04:21:02 <maerwald> daey: it's hard to escape from the IO monad (on purpose ofc)... other stuff like State have "runner" functions that execute the state. Executing IO is up to the RTS though.
04:21:21 <Mateon1> daey: Well, not neccesarily. There could be another function that turns `m a -> a`, but there does not exist a safe function of this sort. I think that might break monad laws, but I'm not sure on that
04:22:00 <merijn> Mateon1: No, because there's monads that you can perfectly write "m a -> a" for
04:22:05 <maerwald> :t runState
04:22:06 <lambdabot> State s a -> s -> (a, s)
04:22:08 <merijn> Mateon1: It's just that you cannot write it for ALL monads
04:22:27 <srhb> daey: Anatomy of a simple program is often { x <- get all the IO; let result = doAllTheStuffTo x; putAllTheIO result } where doALlTheStuffTo does no IO at all.
04:22:36 <srhb> daey: And as you see, IO doesn't leak here.
04:23:07 <maerwald> emphasize on "simple program" :P
04:23:15 <srhb> Sure.
04:25:27 <eklavya> I can see the traffic in wireshark
04:25:34 <eklavya> but nothing gets printed in the program
04:25:43 <eklavya> let me create a paste
04:26:07 <sbrg> inb4 buffering problem
04:26:27 <eklavya> http://lpaste.net/169815
04:26:36 <eklavya> sbrg: what's that?
04:26:54 <sbrg> eklavya: what is the response? is it a string? 
04:27:00 <sbrg> I mean, a readable/printable string?
04:27:17 <eklavya> I don't care, right now, I just need to know it worked :P
04:27:25 <sbrg> oh, wait, hGet returns a bytestring I assume?
04:27:30 <eklavya> yes
04:27:34 <maerwald> sbrg: if it wasn't printable, it would be a type error
04:27:52 <sbrg> maerwald: yeah, it was just a brainfart. I was thinking "maybe he's tryign to print binary data"
04:28:10 <merijn> eklavya: What's the values of the ByteString? Are you printing unprintable characters?
04:28:38 <merijn> oh, wait
04:28:43 <maerwald> merijn: afaik the show instance should fix that
04:28:45 <merijn> eklavya: Is the program hanging and nevere xiting?
04:28:46 <sbrg> yeah
04:28:51 <eklavya> merijn: yeah
04:28:55 <merijn> Ding ding ding
04:29:04 <merijn> eklavya: You're probably not receiving 16 bytes?
04:29:14 <merijn> eklavya: hGet blocks until 16 bytes have been delivered
04:29:23 <merijn> If you don't receive 16 bytes...well...
04:29:29 <eklavya> but wireshark says I did
04:29:31 <merijn> Try using hGetSome
04:29:35 <eklavya> and the client even acked that message
04:29:37 <merijn> eklavya: OS level buffering
04:29:39 <sbrg> lol at "hGetSome"
04:29:56 <maerwald> hGetSome :: Duke -> Meltdown
04:29:59 <hpc> you can set the handle to no buffering though, right?
04:30:10 <hpc> data Tattoo = Dude | Sweet
04:30:19 <sbrg> eklavya: try: hSetBuffering yourHandle NoBuffering
04:30:23 <merijn> hpc: Handles sure, but whether that has an effect on sockets I don't know
04:30:26 <sbrg> @hoogle hSetBuffering
04:30:29 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
04:30:29 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
04:30:35 <merijn> tbh
04:30:45 <merijn> I wouldn't use Network but use Network.Socket
04:30:47 <merijn> More control
04:30:49 <hpc> merijn: blech, calling something hDoTheThing when it doesn't operate on Handle :(
04:31:00 <merijn> hpc: It's a handle, just not one backed by a file
04:31:27 <hpc> Handle isn't always backed by a file either
04:31:34 <merijn> hpc: Which is problematic because, while sockets have file descriptors they don't behave the same as file handles
04:31:40 <merijn> hpc: That's my point
04:31:51 <hpc> and that's why it's a socket?
04:32:00 <merijn> hpc: The operations on Handle don't always work the way you expect sockets to respond
04:32:08 <merijn> hpc: connectTo returns a handle, not a socket
04:32:16 <merijn> Hence why hGet works
04:33:05 <eklavya> buffering had no effect
04:33:07 <maerwald> merijn: Network.Socket.Bytestring plz
04:33:21 <merijn> maerwald: Word
04:33:29 * hackagebot camfort 0.800 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-0.800 (DominicOrchard)
04:33:30 <sbrg> eklavya: try removing the hClose -- it may be closing it before it's done receiving or some such? laziness and IO is a bad mix
04:33:43 <merijn> sbrg: No, that makes no sense and is not how IO works
04:33:44 <sbrg> though I'd expect that to give an error
04:33:56 <merijn> sbrg: None of that code uses lazy IO
04:34:05 <sbrg> oh
04:34:22 <maerwald> sbrg: we are not doing nodejs here :P
04:34:35 <merijn> eklavya: Like I said before I recommend using Network.Socket and Network.Socket.ByteString
04:34:59 <merijn> hpc: An exmple of misbehaviour is that Handle wrapped sockets don't allow simultaneous reading and writing
04:35:01 <maerwald> (where that scenario would be well possible)
04:35:17 <eklavya> merijn: but I will have to handle "complete" frame delivery and reception, no?
04:35:23 <eklavya> anything high level in that?
04:35:35 <merijn> hpc: i.e. all hGet and hPut operations are mutually exclusive, since they are mutually exclusive on files. Sockets however allow that
04:35:45 <merijn> eklavya: TCP has no notion of frames or packets
04:35:57 <merijn> eklavya: TCPs only notion is "bytestream"
04:36:08 <merijn> (octet stream, I suppose if we wanna get RFC technical)
04:36:22 <eklavya> I meant, I need it to block until it has the number of bytes I asked for, is that available?
04:36:37 <eklavya> I don't want to have to retry until then
04:37:05 <merijn> eklavya: I'm saying don't do that, because you're not getting the bytes you asked for, so see what you ARE getting
04:37:27 <merijn> You're asking for 16 bytes and not getting them, so the solution is to print whatever you are getting to see what's going on
04:37:36 <eklavya> ok ok
04:37:38 <eklavya> let me change
04:43:26 <eklavya> I needed to send an int more data :P
04:44:23 <eklavya> thanks merijn maerwald sbrg :)
04:45:38 <eklavya> both socket and the high level version worked
04:46:08 <maerwald> whenever I deal with files, I don't want "high-level", at least not what most libraries provide
04:46:54 <eklavya> I am dealing with a TCP connection
04:47:10 <maerwald> yes
04:47:14 <maerwald> and sockets
04:47:26 <eklavya> ok
04:48:48 <eklavya> can I read from one/write from one parallelly on a single handle, is it (this way or generally) thread safe?
05:13:02 <matrium> hi, is it possible to have a unification in a pattern and be able to write "(x, (x, y)) -> " instead of "(x, (x', y)) | x == x' -> "?
05:14:06 <liste> matrium: I think that would be confusing - "why does this suddenly have an Eq constraint?"
05:16:34 <srhb> matrium: They are called non-linear patterns, by the way.
05:19:33 <matrium> srhb: Thanks! seems like there are some good arguments for not having them
05:19:41 <srhb> matrium: Yeah.
05:19:43 <sdx23> Can this even work? Like, you imply there's an Eq instance, but you have no guarantee that it's faithful. So x and x' mustn't be the same, only x == x'. But then, which of them to be used by the compiler?
05:20:29 <srhb> sdx23: It needn't be any different from having the guard and the Eq instance.
05:20:41 <sdx23> er, "need not" of course
05:20:50 <srhb> sdx23: (And it would probably be the least confusing way to implement it, though you could do it in other ways)
05:21:54 <merijn> eklavya: All file operations are threadsafe by default
05:22:11 <merijn> eklavya: Note my earlier remark that Handle's have mutual exclusion for read/write, which is unnecessary for sockets
05:23:09 <sdx23> srhb: it is. You have only one symbol for x in that case. How to decide whether x afterwards is the first or the second one?
05:24:48 <srhb> sdx23: I think if equality doesn't commute, you have bigger issues. :P
05:25:14 <srhb> Or rather, if it isn't symmetrical.
05:27:43 <sdx23> Not symmetrical. x and x' not being actually the same, even though (x == x') == True
05:29:54 <srhb> As long as x' == x == True as well, I'm not sure I see the problem.
05:32:06 <liste> are x and x' required to behave identically if x == x' ?
05:32:24 <liste> (except for maybe performance)
05:33:08 <hpc> @let data Nope = Definitely | Not; instance Eq Nope where _ == _ = True
05:33:10 <lambdabot>  Defined.
05:33:39 <daniel-s> Is there a way to pattern match not on the parameters to a function, but on the results of an expression?
05:33:40 <sdx23> Okay, this maybe somewhat artificial, but let's assume we have CommentInt Int String - an Int with a comment. The (==) instance compares only the Int, as the comment says nothing about the actual value. If I had x = CommentInt 5 "foo" and x' = CommentInt 5 "bar" in "(x, (x', y)) | x == x' -> f x" it's totally clear what happens (= what comment it has afterwards). In "(x, (x, y)) -> f x" not.
05:33:50 <hpc> daniel-s: view patterns
05:34:03 <hpc> daniel-s: or just a case statement
05:35:39 <daniel-s> hpc: I think my problem is simple. I take two parameters, if I get Just something I do one thing, if I get Nothing I do something else.
05:35:43 <srhb> sdx23: If you defined such an Eq instance, I would assume you meant that they are equal in the sense that x == x' anyway.
05:35:50 <daniel-s> It feels that it's something very common in Haskell.
05:35:50 <cocreature> merijn: I don’t think it’s true that handles always have mutable exclusion for read/write. Handle has two constructors one of them being DuplexHandle which has separate locking for read and write
05:36:21 <srhb> sdx23: And that you would expect the fictitious pattern to do the same. But maybe not. :)
05:36:29 <liste> hpc: I mean by convention, not technical enforcement
05:36:45 <liste> hpc: like the monad laws
05:37:09 <hpc> ah
05:37:22 <hpc> the documentation doesn't list any laws at all for Eq
05:37:41 <hpc> but it's pretty reasonable to assume it's reflexive, transitive, and commutative
05:37:55 <hpc> (except when it isnt)
05:38:02 <hpc> > let nan = 0/0 in nan == nan
05:38:04 <lambdabot>  False
05:38:33 <hpc> so i guess no
05:38:38 <tdammers> there's also the law that relates Ord to Eq
05:38:46 <hpc> there's absolutely nothing you can say for certain about all instances of Eq
05:38:55 <daniel-s> I think a case statement is what I was looking for.
05:39:02 <hpc> tdammers: that's more a property of Ord
05:39:08 <tdammers> hpc: yes, true
05:39:42 <tdammers> daniel-s: pattern matching using a case construct works, but you can also use the maybe function
05:39:45 <tdammers> :t maybe
05:39:46 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:40:05 <tdammers> maybe "nothing found" reverse (Just "hello")
05:40:08 <tdammers> > maybe "nothing found" reverse (Just "hello")
05:40:09 <lambdabot>  "olleh"
05:40:14 <tdammers> > maybe "nothing found" reverse Nothing
05:40:15 <lambdabot>  "nothing found"
05:41:24 <daniel-s> Cool. Thanks tdammers
05:41:47 <daniel-s> and hpc
05:42:27 <hpc> @src maybe
05:42:28 <lambdabot> maybe n _ Nothing  = n
05:42:28 <lambdabot> maybe _ f (Just x) = f x
05:43:18 <tdammers> ^ it's literally implemented as pattern matching on Just and Nothing
05:45:11 <anohigisavay> in ghci, how do i add fixity declaration for an infix constructor?
05:48:14 <Cale> anohigisavay: I think you basically don't? Add the declaration to the file in which you defined the type. If you defined the type on the ghci prompt, move its definition into a file and load that.
05:50:11 <anohigisavay> Cale: _(:з」∠)_
05:50:14 <anohigisavay> Cale: thanks :D
05:53:29 <anohigisavay> also wondering, anyone using emacs to write haskell code? my company-ghc doesn't load the modules that i add to build-depends on the fly
05:54:24 <anohigisavay> but syntax check works
06:02:47 <kryo`> hi
06:03:05 <muzzle> is using the SPECIALIZE pragma considered good practice?
06:04:12 <eklavya> > let s = Data.ByteString.pack [0x00, 0x00, 0x00, 0x34]
06:04:14 <lambdabot>  <no location info>:
06:04:14 <lambdabot>      not an expression: ‘let s = Data.ByteString.pack [0x00, 0x00, 0x00, 0x34]’
06:04:33 <eklavya> > Data.ByteString.pack [0x00, 0x00, 0x00, 0x34]
06:04:34 <lambdabot>  "\NUL\NUL\NUL4"
06:04:41 <eklavya> > s = Data.ByteString.pack [0x00, 0x00, 0x00, 0x34]
06:04:43 <lambdabot>  <hint>:1:3: parse error on input ‘=’
06:05:02 <eklavya> >let s = Data.ByteString.pack [0x00, 0x00, 0x00, 0x34]
06:05:06 <Cale> Perhaps you want @let s = ...
06:05:06 <kryo`> Is it OK to use the SPECIALIZE pragma?
06:05:14 <eklavya> Cale: thanks :)
06:05:17 <Cale> Except that s is already in scope
06:05:19 <kryo`> in a library function?
06:05:32 <eklavya> > @let bs = Data.ByteString.pack [0x00, 0x00, 0x00, 0x34]
06:05:33 <lambdabot>  <hint>:1:1: parse error on input ‘@’
06:05:53 <eklavya> @let bs = Data.ByteString.pack [0x00, 0x00, 0x00, 0x34]
06:05:54 <lambdabot>  Defined.
06:06:24 <eklavya> > Data.ByteString.Char8.readInt bs
06:06:26 <lambdabot>  Nothing
06:06:40 <Cale> kryo`: Should be just fine
06:06:50 <eklavya> what am I doing wrong? why isn't the answer Just (34, "")
06:07:18 <Cale> Isn't readInt for reading the text representation of an Int?
06:07:53 <Cale> yeah
06:07:54 <eklavya> it's for bytestring no?
06:08:11 <Cale> the .Char8 module is full of ASCII text related operations
06:08:32 * hackagebot siphon 0.1 - Generic types and functions for columnar encoding and decoding  https://hackage.haskell.org/package/siphon-0.1 (andrewthad)
06:08:34 * hackagebot geolite-csv 0.1.0 - Initial project template from stack  https://hackage.haskell.org/package/geolite-csv-0.1.0 (andrewthad)
06:08:50 <eklavya> what is a good way of reading Bytes, Shorts, Ints from a binary bytestring?
06:09:07 <liste> eklavya: binary and cereal
06:09:17 <liste> https://hackage.haskell.org/package/binary
06:10:03 <eklavya> no docs?
06:10:46 <cocreature> eklavya: go to an older version https://hackage.haskell.org/package/binary-0.8.4.0
06:12:18 <eklavya> thanks Cale liste cocreature :)
06:12:29 <eklavya> this old version docs is a new trick
06:12:44 <eklavya> I wonder if all those packages actually had docs :P
06:13:00 <cocreature> it makes me sad that we don’t manage to upload docs even for fairly core packages such as binary
06:13:39 <hpc> afaict the docs build job just hasn't been running at all for a while
06:13:59 <hpc> since at least march for one of my packages
06:14:09 <Cale> Which package?
06:14:22 <hpc> acme-php
06:14:25 <cocreature> it seems to have gotten better recently
06:14:28 <hpc> status is "Docs pending"
06:14:37 <Cale> wow, yeah
06:14:38 <hpc> (granted it's not an important package at all)
06:15:15 <cocreature> the thing is, if we would just make the upload of docs the default in cabal and stack this would simply not be a problem
06:18:27 <hpc> or if the haskell.org infrastructure worked
06:18:29 <hpc> ideally both
06:18:57 <hpc> a lot of haskell.org has some really baffling decisions behind it
06:19:08 <hpc> like emailing a rarely-checked address to request usernames
06:19:32 <bernalex> pretty much daily /= "rarely"
06:19:32 <cocreature> the docs builder can’t work in all cases. there are packages requiring extra deps and so on. also I simply don’t see the advantage of building this on external infrastructure apart from abusing it as a ci which it isn’t.
06:19:47 <hpc> bernalex: it used to be rarely, it took me months to get my hackage account
06:19:49 <bernalex> although a better way of handling spam is obviously necessary.
06:20:28 <bernalex> I'm a fan of moderating the first post or so. but that requires manpower.
06:20:40 <hpc> cocreature: i just want to be able to use it as an online haddock for things i use
06:21:23 <hpc> lately i have been repeatedly using packages by other people where i have to go way back in time to find accurate docs
06:21:36 <maerwald> cocreature: I just have my docs at github pages automatically built, so when hackage messes up again, users can at least go there
06:21:43 <hpc> fortunately none of them have had major api changes, or i would be pretty well sunk
06:21:46 <cocreature> hpc: sure I want it for that as well, but why can’t the online haddocks be uploaded simultanously with package uploads? then they immediately exist after being uploaded
06:22:46 <cocreature> maerwald: yeah that seems to become more common
06:23:58 <hpc> also, when "cabal check" warns about missing haddock i will start uploading it :P
06:24:47 <hpc> (i would add that check if cabal wasn't such a pain to develop for)
06:25:09 <maerwald> I also like when CPP breaks haddock hyperlinks
06:26:31 <kryo`> what's the memory advantage of using IntMap over regular Map?
06:28:13 <bennofs> maerwald: I just make travis-ci upload docs / package candidates / package releases for my packages
06:28:17 <bennofs> (to hackage)
06:28:28 <hpc> kryo`: performance
06:29:57 <kryo`> hpc there is no advantage in terms of memory?
06:31:47 <hpc> probably not, IntMap itself seems to be defined similarly to regular Map
06:32:44 <hpc> it uses the radix properties of Int to reduce time complexity, according to the docs
06:33:04 <kryo`> thanks hpc
06:38:06 <buglebudabey> could anyone give their opinion on how to abstract these two functions "compileLet" and "compileLetrec"? They and their helper functions seem too similar but not similar enough
06:38:08 <buglebudabey> http://lpaste.net/169822
06:42:48 <zipper> Hey guys can I get some help with this maybe simple thing. https://github.com/nairobilug/nairobi-bot/blob/master/src/Bot/Reputation.hs
06:42:56 <zipper> It won't do simple addition
06:43:13 <zipper> It's been a while since I wrote haskell and my changes won't even typecheck 0.o
06:43:28 <zipper> The idea is from https://github.com/mstksg/auto#a-chatbot
06:47:45 <tdammers> question here; I just changed the string-convert package such that instead of a multi-param class StringConvert a b { s :: a -> b }, I just have s :: (ToString a, FromString b) => a -> b
06:48:24 <tdammers> and then I specialize the pairs of string-convertible types that can be done more efficiently (e.g. lazy <-> strict texts, or the trivial no-op cases) using {-# RULES #-}
06:48:54 <tdammers> this means I can provide efficient implementations, full-blown polymorphism, but I no longer have to use overlapping instances or even multi-param typeclasses
06:49:16 <tdammers> however, this breaks the ability for user code to define efficient instances of StringConvert themselves, because that typeclass no longer exists
06:49:25 <tdammers> is this a good idea?
06:51:03 <eklavya> Data.Binary uses a different type of ByteString than Data.ByteString
06:51:36 <stephenmac7> Is there an simple way using Prelude functions to write a function with the following behavior? [1,2,3,4] -> [[1,2], [2,3], [3,4]]
06:51:40 <eklavya> one's lazy and the other is not apparently 
06:52:05 <stephenmac7> I know I could use a simple recursive function for it, but I feel like that's not the best method
06:52:42 <tdammers> > let f xs = zip xs (drop 1 xs) in f [1,2,3,4] -- almost
06:52:44 <lambdabot>  [(1,2),(2,3),(3,4)]
06:52:48 <opqdonut> > let xs = [1,2,3,4] in zipWith (\a b -> [a,b]) xs (tail xs)
06:52:50 <lambdabot>  [[1,2],[2,3],[3,4]]
06:52:58 <eklavya> > fmap (\x -> [x, x+1]) [1,2,3,4]
06:53:00 <lambdabot>  [[1,2],[2,3],[3,4],[4,5]]
06:53:24 <Denommus> :t drop
06:53:27 <lambdabot> Int -> [a] -> [a]
06:54:10 <stephenmac7> Okay, got it. Thanks!
06:56:11 <eklavya> how to handle situations where the expected arg is lazy type but you have a strict type arg?
06:56:14 <Squarism> i wonder about the emacs/vim culture that seems to be half dominant in haskell world. Ive gotten used to the fantastic IDE intellij. It makes up for alot of java's shortcomings and makes the language alot more useful - just because of the IDE. Haskell beeing typed i cannot see why it wouldnt be possible to create an as good software for it. Yet, there seems to be no big urge for this?
06:56:20 <davidkart> hello
06:56:25 <davidkart> I can't think functional
06:56:31 <davidkart> only procedural
06:56:33 <eklavya> many packages have lazy and strict apis
06:56:46 <tdammers> davidkart: it's an acquired taste ;)
06:56:56 <sdx23> eklavya: what exactly do you want? Data.ByteString comes in both flavors.
06:57:16 <davidkart> Squarism: you are almost true. Good IDE are invaluable (especially with Java).
06:57:18 <tdammers> davidkart: but you *can* think functional, you're just not as comfortable with it, and it's slower because you're not used to approaching problems in functional terms
06:57:43 <tdammers> eklavya: Data.ByteString.Lazy.{to|from}Strict
06:58:24 <bennofs> Squarism: keep in mind that (afaik) being easy to process for tools was one of the design goals of Java, while Haskell's syntax is much more designed to look good to humans
06:58:30 <davidkart> erm I have another problem right now, ghci is taking 1,2G of Ram.
06:58:33 <tdammers> Squarism: it's possible, but the language is good enough to not *require* IDE support anywhere near as much as Java, and so the people who are capable of making such an IDE prefer working on more important projects instead
06:58:34 <davidkart> How can I clear that ?
06:58:57 <davidkart> tdammers: I totally disagree with you
06:58:58 <tdammers> Squarism: iow., the pain isn't strong enough
06:59:29 <tdammers> davidkart: on the "cannot think functionally" thing?
07:00:01 <eklavya> Squarism: davidkart have you used Atom or VSCode
07:00:17 <davidkart> tdammers: as soon as one will have a good all-in-one tool (hoogle, API lookup, framework integration, etc), one can be so much more productive in Haskell. Right now Haskell seems more like an assembly of heteroclit components and it is hard to really be productive with it.
07:00:22 <eklavya> I use VSCode, although Atom's IDE is better for Haskell
07:00:28 <davidkart> (unless you are hacking inclined).
07:00:42 <bernalex> davidkart: there's a huge amount of people who find such tools counter-productive and then some.
07:00:49 <bernalex> I'm included in that group.
07:01:01 <tdammers> davidkart: I'm very productive with Haskell, and I find the collection of loosely-coupled tools more useful than an IDE that bundles them and, for better or worse, strings them together in predefined configurations
07:01:02 <davidkart> bernalex: I am ready to bet than there is an even huger amount of people that disagree.
07:01:05 <bernalex> I absolutely loathe all "I can do everything".
07:01:13 <bernalex> davidkart: in Haskell-land, obviously there isn't.
07:01:31 <bernalex> *"I can do everything" tools. -- I a word.
07:01:33 <davidkart> well at least we know why :) hard to love something that doesn't exist :)
07:01:40 <eklavya> davidkart: did you not like the Atom Haskell IDE
07:01:40 <Squarism> tdammers, List of things i miss.. 1. navigation (search all references, usages, callstack) 2. Refactorings names / locations. 3. Signature change. 4. compiler inspections (red highlighting etc). 5. Stuff i cannot remember. Im sure id be 30% more effective having these at hand.
07:02:09 <bernalex> you can get all of that in emacs.
07:02:17 <bernalex> well, not inspecting a call stack, since there isn't really one.
07:02:32 <Squarism> oh
07:02:35 <davidkart> Squarism: this tools really exist but you have to make your way through the jungle https://everydayadventuresblogdotcom2.files.wordpress.com/2014/09/dsc00696.jpg to get them.
07:02:40 <bernalex> you can get it in vim too.
07:02:44 <davidkart> it's going to be tough.
07:02:51 <tdammers> Squarism: 1. is a bit of a sore spot, but there are decent enough tools to get you 95% there. For me, hasktags alone puts me back in comfort zone, and grep is good enough for the rest. Programming discipline, especially wrt. modules and module exports, goes a long way too.
07:03:23 <bernalex> I've found most refactoring tools to only be making up for the language being stupid.
07:03:27 <tdammers> Squarism: 2. Haskell's type system is good enough to make the "just boldly go ahead, make the change, and see what breaks" approach very viable ("compiler error driven refactoring")
07:03:33 <eklavya> tdammers: there doesn't seem to be a Data.Binary.Lazy
07:03:41 <bernalex> additionally, they seem to lead to increased cargoculting and other horrible practices.
07:03:47 <tdammers> eklavya: no; but there's a Data.ByteString.Lazy
07:03:47 <Squarism> davidkart, haha - explanatory picture!
07:03:51 <davidkart> eklavya: I never tried atom, it's not free
07:04:04 <eklavya> where?
07:04:09 <tdammers> Squarism: 3. Same as 2 - make the change, hit "build", and the compiler will tell you where you need to fix things
07:04:13 <eklavya> it's free AND open source
07:04:18 <bennofs> Squarism: there are a few tools that go in that direction, but it seems that interest is just no big enough yet for someone to develop an integrated solution
07:04:28 <eklavya> tdammers: sorry :P
07:04:30 <tdammers> Squarism: 4: there are vim and emacs plugins for that, but I don't feel a strong need myself.
07:04:45 <bennofs> Squarism: for example, HaRe is a project for haskell refactorings
07:04:50 <bernalex> atom is free software. sublime is the proprietary one. I don't understand why one would use either though.
07:04:55 <davidkart> bennofs: an integrated haskell stack would be lovable, but it's true also for python. There is no « standard all in one tool » like the java IDE.
07:04:55 <bennofs> Squarism: (https://github.com/alanz/HaRe)
07:04:58 <bernalex> I use hare. it's pretty good.
07:05:02 <tdammers> Squarism: personally, I value a snappy editor and certainty at all levels more than instant inline feedback on compiler errors
07:05:11 <bernalex> but I find that 99% of the time, it's pointless
07:05:34 <bennofs> Squarism: for type checking / live error feedback, there is https://hackage.haskell.org/package/ghc-mod or https://github.com/commercialhaskell/intero
07:05:35 <bernalex> you just don't do that whole copypasta write the same crap ten times over ceremony, that you need to do in java
07:05:47 <tdammers> python, I believe, would benefit a lot more from these things, because the language doesn't provide a lot of static reasoning help out of the box
07:05:52 <Squarism> tdammars. Well for 2 and 3 - having to context switch -> console -> read line number -> to editor -> search line number - its just not good enough
07:05:53 <bernalex> if there's any ceremonial crud in haskell, it's usually possible to just derive for free.
07:06:04 <bernalex> Squarism: then don't do that
07:06:16 <bernalex> I have it all in my editor, with squiggly red lines and popups and crap.
07:06:25 <tdammers> Squarism: you can run the build job from within vim, and then have it parse the output into vim's error list
07:06:29 <Squarism> bernalex, what do you use?
07:06:30 <bennofs> Squarism: check out http://commercialhaskell.github.io/intero/
07:06:39 <bernalex> Squarism: ghc-mod and flycheck, amongst other things.
07:06:49 <davidkart> bernalex: usually in java you use teh ide integration to do repetitive and boring tasks.
07:07:00 <bennofs> Squarism: for vim, there is http://commercialhaskell.github.io/intero/
07:07:04 <Squarism> ok.. ill try intero next
07:07:05 <bennofs> Squarism: oops, meant https://github.com/begriffs/haskell-vim-now
07:07:10 <tdammers> davidkart: in Haskell, you use Haskell to do repetitive and boring tasks
07:07:15 <bernalex> davidkart: in haskell, there isn't really an equivalent to those stupid crud tasks
07:07:18 <maerwald> bernalex: some people like tools that are consistent and not broken
07:07:25 <Squarism> oh.. its vim. Then i wont do that
07:07:33 <bernalex> maerwald: I haven't had any breakage in my tools since I set them up
07:07:35 <Squarism> oh no its emacs
07:07:37 <bennofs> Squarism: no intero is emacs, haskell-vim-now is vim
07:08:03 <bernalex> maerwald: and people I know who use eclipse/intellij/whatever (be it at work or as personal preference) complain about those breaking *all the time*.
07:08:12 <davidkart> how do I call garbage collector ?
07:08:13 <bernalex> if you want something that never breaks, do what edwardk does, use vim with no plugins at all.
07:08:19 <tdammers> ^ ++
07:08:24 <tdammers> (is almost what I do)
07:08:42 <bernalex> davidkart: performGC
07:08:45 <bennofs> davidkart: http://hackage.haskell.org/package/base-4.9.0.0/docs/System-Mem.html#v:performGC
07:08:54 <tdammers> caveat: not everyone has a brain of edwarkian proportions
07:09:13 <bernalex> tdammers: the whole point is that with haskell you don't really need to be brainy
07:09:19 <tdammers> bernalex: true
07:09:32 <davidkart> bernalex: I find it hard to believe.
07:09:38 <tdammers> bernalex: takes a while to get used to outsourcing brain resources to the code though
07:09:49 <maerwald> bernalex: you have weird co-workers then
07:09:59 <bernalex> to quote edwardk himself: "I routinely write code in Haskell that I am not smart enough to write."
07:10:17 <tdammers> davidkart: believe it or not, among the half dozen or so programming language I use regularly, I find Haskell to be the easiest
07:10:46 <davidkart> who is edwardk
07:10:48 <bernalex> maerwald: this isn't my coworkers. they all used vim or emacs. this is hundreds of people that I've talked to about programming over ten years.
07:10:58 <maerwald> bernalex: yeah and now guess if other people can understand that code
07:11:06 <bernalex> maerwald: wat
07:11:19 <davidkart> I like being brainy though
07:11:25 <maerwald> I think that was pretty clear
07:11:35 <Squarism> yeah. Choosing tools from what supersmart people use i have a good motivation not to follow. Worked with a national math champion that put LAMP over anything else in 2007.
07:11:43 <tdammers> davidkart: edwardk is Edward Kmett, author of lens, trifecta, and a bunch of other mind-blowing Haskell packages
07:11:44 <bernalex> maerwald: no, it doesn't really follow at all.
07:12:22 <bernalex> Squarism: you shouldn't think of him as being super smart right now; think of him as being super *productive*.
07:13:30 <tdammers> it has been suggested, tongue-in-cheek, to introduce "millikmett" as a unit of programmer productivity
07:13:30 <maerwald> bernalex: it does. if you write code you are not smart enough to write, then it's likely there are not many people that will understand it
07:14:08 <tdammers> maerwald: I don't think that's what he's trying to say with that quote
07:14:17 <bernalex> maerwald: right, you were referring to something earlier, not what I last wrote. but anyway, no it doesn't. I can understand the basics of general relativity fine without being the one that came up with it.
07:14:31 <bernalex> but yeah, tdammers is right
07:14:34 <maerwald> bernalex: I don't see the relation of your analogy
07:14:35 <bernalex> and I've got to go shower
07:14:57 <maerwald> tdammers: maybe not, but I consider that a bad property of haskell
07:15:11 <tdammers> maerwald: I believe what he means is that Haskell allows a programmer to put so much information into the source code itself, and have the compiler guard it for consistency, that you can solve problems that your brain is incapable of understanding as a whole
07:15:34 <bernalex> plus common functional programming idioms: divide & conquer
07:15:41 <tdammers> I don't think that's a bad property of Haskell at all, it's *the* productivity superweapon if you ask me
07:15:55 <maerwald> tdammers: well, when I look at his code, I see the quote in a different light ;)
07:16:04 <tdammers> maerwald: I don't ;)
07:16:07 <bernalex> rest of the quote: "I just break it down into simple enough pieces and make the free theorems strong enough by using sufficiently abstract types that there is only one definition."
07:16:08 <maerwald> good for you
07:16:22 * bernalex >>= shower
07:18:44 <Denommus> bernalex: why are you a monad?
07:18:52 <Denommus> and why is showering a monadic action?
07:19:21 <maerwald> Denommus: it makes a lot of sense, imo
07:20:06 <zipper> Hey can I pattern match a tuple like `(first, second)` ?
07:20:21 <tdammers> a pure shower would take a dirty bernalex and return a cleaned copy
07:20:26 <tdammers> zipper: yes
07:20:54 <tdammers> > case ("foo", "bar") of { ("bar", _) -> "nop"; ("foo", x) -> x }
07:20:56 <lambdabot>  "bar"
07:21:16 <maerwald> tdammers: so he's cloning himself every time he showers?!
07:21:31 <tdammers> maerwald: only when he uses the pure shower API
07:21:49 <tdammers> maerwald: but he's a monad, probably some stack with IO at the bottom, so it's fine
07:21:53 <maerwald> wonder if the shore is lazy and short-circuits. Does it stop automatically when he is clean?
07:21:56 <maerwald> *shower
07:23:18 <tdammers> well, if bernalex is lazy, he might never shower at all
07:25:06 * mekeor is very confused by whether to install things with cabal, stack or apt
07:25:07 <prohobo> showering is a sign of impotence
07:25:17 <maerwald> mekeor: cabal sandboxes
07:26:23 * mekeor just became more confused
07:33:27 <danza> hey all, could you give me some guidance in order to find a `filter` function which is generic? Which type class would provide that?
07:35:08 <danza> i guess ... that a filter could be implemented on any monoid, right?
07:35:41 <danza> on any monoid and traversable
07:37:38 <danza> ... which means simply ... on any Foldable? I am a bit puzzled
07:38:30 <bennofs> :t mfilter
07:38:32 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
07:38:43 <bennofs> danza: mfilter is one way to generalize filter 
07:38:51 <Denommus> tdammers: that makes a lot of sense, indeed
07:39:20 <danza> thanks bennofs ... i didn't expect it to require something like a monad
07:39:23 <tdammers> completely -blah material by now though
07:39:48 <bennofs> danza: there are probably multiple ways to generalize filter
07:40:32 <danza> sure ... in my case i need to operate on a Vector, which in an instance of MonadPlus, so that will do ... thanks again!
07:41:18 <bernalex> maerwald: tdammers: yes, I am cloning myself every time I shower. and every time anything happens, really. the person writing the end of this sentence is not the same as the one who began writing it. this is due to quantum decoherence. let's hope that my taking a shower won't quantum tunnel us to a vacuum state.
07:41:43 <zipper> Hey, I have some code here https://gist.github.com/urbanslug/f91efa76edf2c1fed9ad2e869c7a366b
07:41:43 <zipper> I added the extra value in the tuple
07:41:58 <maerwald> bernalex: I usually just mutate myself in-place
07:42:06 <zipper> so now it seems that I can't call `words` on the second value
07:42:09 <zipper> hmmmm
07:42:47 <bernalex> maerwald: I subscribe to the mwi, in which that's not accurate. maybe it is though. but that would be boring, so I prefer the mwi.
07:44:44 <zipper> I have a really easy question I think here, where I added an extra arg but because I used composition I broke stuff
07:47:23 <lonokhov> Is there a way to turn off haddock warnings for Internal modules? I still want docs generated, but don't care if all binds have docs
07:48:10 <mtesseract> Hi. I have trouble with overlapping typeclass instances. The code snippet reproducing my problem (13 lines) can be found here: http://lpaste.net/169828. I have no idea why my code conflicts with the Ord instance for Rationals.
07:48:14 <merijn> lonokhov: Yes, you simply ignore the warnings? :p
07:48:36 <lonokhov> merijn: but it makes it easier to miss warnings in important modules ^(
07:48:58 <merijn> mtesseract: It doesn't just overlap rationals, that instance overlaps every Ord instance ever
07:49:24 <merijn> mtesseract: Line 12, that can never work
07:49:25 <mtesseract> (What I am trying to do is this: The unit typeclass implements a basic interface for "units" and on top of that there is the DerivedUnit typeclass which specifies that a given Unit is "derived" from some other Unit, i.e. it can be converted.
07:49:41 <merijn> mtesseract: Constraints are not relevant for checking for overlap
07:49:50 <merijn> mtesseract: So you've just written "instance Ord u where"
07:51:06 <mtesseract> I don't fully understand this yet. What is weird: what I have tried there with Ord seemed to typecheck just fine for Eq: instance DerivedUnit b u => Eq (Q u) where ...
07:51:44 <merijn> mtesseract: "Eq (Q u)" doesn't match everything, just values of type "Q u"
07:51:46 <mtesseract> merijn: So, is there a way to define an Ord instance for all types u that satisfy the constraint DerivedUnit b u for some b?
07:51:56 <merijn> mtesseract: No
07:51:58 <mtesseract> merijn: Oh, right, that was silly.
07:52:05 <merijn> mtesseract: At least not straightforward
07:52:29 <mtesseract> Am I using the type system wrong or is that generally seen as something that would be nice to have?
07:52:54 <merijn> mtesseract: Both?
07:53:28 <merijn> mtesseract: I'm trying to see what exactly that's doing, but I'm not sure enough to suggest an alternative
07:53:43 <mtesseract> (I would definitely prefer that over copy-and-pasting the same class implementation for all types such that the constraint DerivedUnit b u is satisfied)
07:55:06 <merijn> mtesseract: I'm trying to see whether you couldn't simply replace your classes with a newtype?
07:56:10 <mtesseract> merijn: In case that helps, I am basicalyl writing a type-safe quantity-conversion library. For this, I need different types for volume units (l, ml, etc.) and mass units (kg, g, lb, ...). But I also need to take into consideration "custom" units, that are not derived in a sane way. That's why I use these two typeclasses. This allows me to write something like: convert :: (DerivedUnit b u, DerivedUnit b u')
07:56:12 <mtesseract> => u -> u' -> Rational. This function cannot fail and computes the scaling factor between two comparable units.
07:56:39 <merijn> mtesseract: FYI, you know a library like this exists already? :)
07:56:54 <mtesseract> merijn: I would be surprised if that was not the case. :)
07:56:54 <merijn> I forgot it's name, though
07:57:19 <merijn> mtesseract: Wouldn't it be simpler to have newtype with a phantom unit class?
07:57:23 <merijn> eh
07:57:28 <merijn> phantom unit type
07:57:30 <mtesseract> merijn: It's a toy project.
07:58:11 <puregreen> mtesseract: you can use default signatures
07:58:20 <merijn> puregreen: No, not for this
07:58:52 <puregreen> hm, okay, then I guess I misunderstood the problem
07:59:36 <merijn> puregreen: He can't add a default signature to an existing class like Ord
07:59:56 <puregreen> ...ouch, right
07:59:57 <mtesseract> merijn: Maybe. I thought typeclasses would be nice for this.
08:03:33 <akegalj> I have problems understanding why aeson decoding behaves like this http://lpaste.net/573284516613849088 . There is `unwrapUnaryRecords` which states "    Hide the field name when a record constructor has only one field, like a newtype.
08:03:45 <nitrix> merijn: Aren't there days where your brain just totally goes off and the abstractions on top of abstractions on top of abstractions seems like a neverending deep hole?
08:03:48 <akegalj> but it doesn't work as expected
08:04:46 <merijn> nitrix: Yes, like, every day
08:04:57 <merijn> nitrix: Actually, I have that problem right now
08:05:01 <akegalj> s/decoding/encoding
08:05:24 <locallycompact> nitrix, all days are like that, but just abstracted over degree of abstraction
08:07:10 <merijn> nitrix: I'm trying to abstract the differences between opencl and cuda and it's a pain in the ass >.>
08:08:53 <puregreen> akegalj: what language extensions do you have enabled? I'm trying to reproduce the issue
08:09:39 <akegalj> puregreen: DeriveAnyClass, DeriveGeneric
08:10:28 <c_wraith> the ghc docs say that TypeApplications require a non-identifier character before the @ to avoid ambiguity.. what ambiguity is that? 
08:10:29 <akegalj> puregreen: but I think problem might be in `SumEncoding`, probably I have to set `sumEncoding` to `ObjectWithSingleField`
08:10:36 <davidkart> can you tell me how you would do pure procedural treatment in haskell ?
08:10:47 <akegalj> puregreen: if it is like that, then documentation is still missleading
08:10:51 <davidkart> For example let a=2; a*2
08:11:07 <c_wraith> davidkart, usually by rewriting to not work that way. 
08:11:18 <puregreen> akegalj: I can't reproduce it
08:11:18 <puregreen> http://lpaste.net/169830
08:11:22 <davidkart> > let a=2; a*2
08:11:23 <lambdabot>  <hint>:1:13:
08:11:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:11:27 <davidkart> > let a=2 in a*2
08:11:29 <lambdabot>  4
08:11:38 <davidkart> :t let
08:11:39 <lambdabot> <no location info>: not an expression: ‘let’
08:11:47 <c_wraith> davidkart, in the exceptionally rare cases it's necessary, use a ref type like IORef or STRef
08:11:52 <akegalj> puregreen: which version are you using?
08:11:53 <puregreen> akegalj: my version of aeson is 0.11.2
08:12:08 <davidkart> a seccussion of let x=2
08:12:11 <mtesseract> davidkart: 'let' is Syntax, not an expression per se.
08:12:11 <davidkart> let y=x*2, etc
08:12:20 <davidkart> it's kind of precuderal
08:12:27 <davidkart> (i'm kind of dyslexic today
08:12:28 <Arguggi> Any idea why stack fails to build when I change nightly versions? (For example from 2016-07-10 to 2016-07-14) I get these errors: http://lpaste.net/6763857013345615872  . This has happened before. Even going back to the original nightly version doens't fix the build failing
08:12:48 <davidkart> it's ok for u
08:12:53 <akegalj> puregreen: we use aeson from lts-6.6 which is..
08:13:05 <davidkart> « stack fails to build » <- seems pretty usual this days.
08:13:19 <puregreen> 0.11.2
08:13:36 <c_wraith> davidkart, Oh, if you just mean sequential updates to a piece of state, you can also use State monad tricks, especially with lens. 
08:13:44 <akegalj> puregreen: yes, thats strange
08:14:03 <akegalj> puregreen: we have few other extension enabled though, but I thought they don't mind
08:14:09 <akegalj> puregreen: but they might
08:16:11 <akegalj> puregreen: thanks for help, we are going to see whats going on here
08:16:41 <puregreen> akegalj: the first thing to do is to load my paste into fresh ghci and check whether you're getting a different result or not
08:17:10 <davidkart> c_wraith : http://memecrunch.com/meme/OH0S/haskell-monads/image.jpg
08:17:32 <puregreen> and after that we'll find out whether something is wrong with my/your aeson or whether something is wrong with your bigger example
08:18:35 * hackagebot stackage-curator 0.14.1 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.14.1 (MichaelSnoyman)
08:18:58 <akegalj> puregreen: yes, we are doing that right now
08:20:13 <davidkart> say you want to compute the integral of (x^2|any function) between 0 and 1 with the rectangle method and (Int :: n) subdivisions. How would it work in Haskell ?
08:20:40 <c_wraith> the thing is, you don't have to (and really shouldn't try to) understand monads before using them. 
08:20:43 <davidkart> I know that in a procedural fashion it's kind of straight forward, you define your vars, then you start iterating from 0 to n.
08:20:56 <shapr> yeah, like you don't need to know the theory of objects before using objects
08:20:57 <davidkart> c_wraith: I can help I like to understand things.
08:21:09 <davidkart> shapr: c_wraith: although it helps
08:21:25 <davidkart> but I'm fine with learning math and theory. I bet it's not even hard if well taught/explained
08:21:27 <c_wraith> davidkart, sometimes you have to let go and absorb information before you can understand it. 
08:21:51 <c_wraith> but anyway, this issue doesn't need that much. 
08:21:52 <mtesseract> davidkart: What is your particular issue with this? Have you had a look at basic FP material?
08:21:54 <davidkart> yes
08:21:56 <davidkart> yes
08:22:11 <davidkart> I know what is a morphism ya know !
08:22:15 <davidkart> :) 
08:22:19 <c_wraith> davidkart, it's just a few list expressions. maybe a couple maps followed by a sum. 
08:22:21 <davidkart> And also what is a bijection :)
08:23:59 <davidkart> Basically the n-wise rectangle method would look like theIntegral f n = sum [ f( x ) / n | x<-[0,1./n,...,(n-1)/n] ]
08:24:24 <davidkart> Basically the n-wise rectangle method would look like theIntegral f n = sum [ f( x/n ) / n | x<-[0...(n-1)] ]
08:24:46 <davidkart> but the list comprehension does not sound mathematical
08:24:48 <c_wraith> you probably shouldn't use floating point values in list ranges. they don't work how you'd expect. 
08:24:55 <davidkart> yes I corrected it
08:25:09 <c_wraith> ah, yes. 
08:25:17 <c_wraith> so.. what's wrong with that? 
08:25:27 <c_wraith> seems easy. 
08:26:13 <davidkart> > let theIntegral f n = sum [ f( x/n ) / n | x<-[0...(n-1)] ] in theIntegral (\x->x**2) 100
08:26:15 <lambdabot>      No instance for (Typeable p0)
08:26:15 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
08:26:15 <lambdabot>        arising from a use of ‘show_M873881454247571959929455’
08:28:07 <marrenarre> Is there any more elegant way to write this?: http://lpaste.net/3181288027108409344
08:29:09 <davidkart> that's not working I told you
08:29:56 <c_wraith> well, yes, you should fix the bugs. but the idea is fine. 
08:30:09 <pavonia> marrenarre: There's readMaybe
08:31:23 <davidkart> I hope someday I will be able to write efficient code that compiles at first try.
08:32:13 <shapr> davidkart: it gets easier!
08:32:46 <shapr> marrenarre: that's really compact, did you use @pl for that?
08:33:01 <shapr> @pl f = getLine >>= maybe f (return . fst) . listToMaybe . reads
08:33:01 <lambdabot> f = fix ((getLine >>=) . (. (listToMaybe . reads)) . flip maybe (return . fst))
08:33:46 <shapr> marrenarre: also depends on your definition of elegant :-)
08:33:57 <marrenarre> shapr: No, my brother (gustavn64) wrote it from scratch.
08:34:16 <davidkart> it's like I am iteratively hard wired
08:34:21 <davidkart> when I am programming.
08:34:52 <marrenarre> pavonia: I can't seem to find readMaybe on Hoogle.
08:35:22 <akegalj> puregreen: when we loaded it with `stack ghci --no-load --no-build` everything worked as in your bin. We will try to figure out what's else going on
08:35:40 <pavonia> marrenarre: It's in Text.Read
08:37:11 <Welkin> marrenarre: use hayoo instead
08:37:21 <Welkin> hoogle only covers libraries included in the platform
08:37:25 <Welkin> hayoo covers all of hackage
08:37:56 <Welkin> http://hayoo.fh-wedel.de/?query=readMaybe
08:39:37 <marrenarre> Oh, so there is no way to write it more elegantly using only standard libraries.
08:40:12 <puregreen> readMaybe is in base
08:40:54 <Welkin> or you can just write your own readMaybe
08:41:03 <Welkin> writing your own functions to wrap others is always a solution
08:41:39 <geekosaur> also I would not waste time on trying to stick to "standard libraries" defined as "those that ship with ghc" because that set is intended to be as minimal as possible
08:41:51 <Welkin> lol
08:41:56 <Welkin> there are no standard libraries, by the way
08:41:59 <Welkin> as geekosaur said
08:42:31 <geekosaur> because ghc's cross-module inlining stuff means anything shipped with ghc is frozen and can not be safely upgraded to new versions
08:43:36 * hackagebot renderable 0.2.0.1 - An API for managing renderable resources.  https://hackage.haskell.org/package/renderable-0.2.0.1 (SchellScivally)
08:43:45 <marrenarre> Oh. Thanks guys.
08:44:14 <Welkin> marrenarre: and Prelude just re-exports other libraries
08:47:48 <SAL9000> How can I ensure that a child process (spawned by createProcess) is killed if GHC exits?
08:49:00 <geekosaur> you can't ensure it in 100% of cases because SIGKILL doesn't give anything a chance to run
08:49:04 <jaspervdj> SAL9000: you probably mean when your program exits instead of when GHC exits?
08:49:21 <geekosaur> sub*processes* are independent by nature
08:49:53 <SAL9000> Yeah, I should clarify -- SIGKILL I don't care about, only exits whether due to signals or falling off the end
08:50:00 <geekosaur> (there are some POSIXisms that can let a cooperating subprocess detect parent exit and shut itself down, but nothing that will ensure a child is killed when its parent is)
08:50:02 <SAL9000> SIGINT, SIGTERM etc.
08:50:22 <SAL9000> well, there are process groups and the like, but I can't ensure that the signal being sent to me is a process group signal
08:51:13 <geekosaur> actually you could use a process group for this, if you add another process level on top
08:51:54 <SAL9000> good point -- I'll have XMonad running on top anyway.
08:51:57 <geekosaur> (grandparent sets new pgrp, spawns parent. parent spawns child and manages it normally. if parent exits with child still running, grandparent reaps it and then kills the pgrp_
08:52:37 <SAL9000> so there's no nice way to (in an IO monad context) register something to run when the main thread dies gracefully?
08:52:54 <SAL9000> whether due to falling off, or a catchable signal
08:53:23 <geekosaur> catchable signals become exceptions, which doesn't count as graceful. uncaught signals never get seen by haskell code, they just terminate the process
08:53:54 <SAL9000> so I'd have to register signal handlers or wrap all of main in a catch block? ew
08:54:17 <SAL9000> I guess there's nothing like Lisp's unwind-protect?
08:54:45 <geekosaur> haskell is not exactly based on an assumption of impurity
08:55:47 <geekosaur> so no, there is no atexit, and no other pretense that exceptions are a "normal" mode of operation  (unwind-protect)
08:56:32 <SAL9000> hm... what about the Resource monad?
08:59:28 <Philonous> SAL9000, `finally' is similar to unwind-protect, but it's just a different sort of catch
09:00:28 <nitrix> I'd use an MVar.
09:02:10 <nitrix> Have two interrupt handlers on sigINT and sigTERM modify the MVar and something in your main react to it?
09:03:20 <SAL9000> makes sense. seems that there's no way around having to wrap main -- I was hoping for something like atexit, unwind-protect or RAII which would let me do this "locally".
09:04:52 <cloudhead> yep that's how I did it in a process runner a while back: `Sig.installHandler Sig.sigCHLD (Sig.Catch $ putMVar childExited ()) Nothing`
09:05:07 <cloudhead> and one for sigTerm
09:06:10 <cloudhead> what do you mean by wrapping main?
09:06:40 <cloudhead> oh nvm, I see
09:06:53 <SAL9000> poor choice of words, perhaps -- I was thinking of equivalents to try {...} finally {...}
09:07:13 <davidkart> how would you do that ?
09:07:18 <davidkart> Please solve my problem
09:07:32 <davidkart> Say the input is a list of numbers [1..n]
09:07:41 <cloudhead> yeah although it wouldn't be too bad to have something like `main = wrap $ do ...`
09:07:44 <SAL9000> in this case I'm trying to figure out how to slap another monad around main which would keep track of the various things I want to do "at exit"
09:08:24 <davidkart> and you want to filter them : for each number x in [1..m], filter numbers in [1..n] that arent multiple of x.
09:08:31 <davidkart> can you tell me how you do that in Haskell ?
09:08:46 <cloudhead> davidkart: a list comprehension, or the `filter` function
09:09:29 <cloudhead> oh these are two lists?
09:10:23 <cloudhead> SAL9000: perhaps something like MonadError?
09:11:07 <SAL9000> cloudhead: I'm not trying to catch errors -- I'm trying to make sure that impure things started by "deep" code get cleaned up properly
09:11:25 <cloudhead> ah I see, they're not errors
09:11:31 <cloudhead> more of a bracket
09:11:39 <schell> wow, there are much cleaner error messages in ghc8 
09:11:52 <cloudhead> SAL9000: have you looked at https://wiki.haskell.org/Bracket_pattern ?
09:12:01 <Welkin> > (\n x -> [a | a <- [1..n] , x `mod` /= 0 ]) 100 5
09:12:03 <lambdabot>  <hint>:1:37: parse error on input ‘/=’
09:12:17 <Welkin> > (\n x -> [a | a <- [1..n] , a `mod` x /= 0 ]) 100 5
09:12:19 <lambdabot>  [1,2,3,4,6,7,8,9,11,12,13,14,16,17,18,19,21,22,23,24,26,27,28,29,31,32,33,34...
09:12:28 <Welkin> dunno if that is what davidkart was looking for
09:12:49 <SAL9000> cloudhead: Will the "last" action run if my program is interrupted by a catchable signal (SIGINT, SIGTERM)?
09:13:07 <nitrix> [y | y <- [1..n], x <- [1..m], y `mod` x /= 0] ?
09:13:48 <nitrix> Nope ._.
09:14:17 <nitrix> I see, that's doing >>=
09:15:33 <nitrix> davidkart: So, your expected result is a list of lists, right?
09:16:08 <cloudhead> SAL9000: hmm, no I don't think it'll catch those as they aren't automatically converted to exceptions
09:16:33 <nitrix> [[1..n] filtered of x=1,  [1..n] filtered of x=2, ...] ?
09:17:28 <ertes> SAL9000: most signals are regular exceptions
09:17:54 <cloudhead> ertes: even sigTERM?
09:17:59 <ertes> even SIGTERM
09:19:36 <SAL9000> okay, so if I have `forkIO $ do {forever $ ... ; putStrLn "Stuff!"}`, will "Stuff!" be printed upon SIGTERM?
09:20:29 <ertes> wait…  SIGTERM may be different
09:20:45 <ertes> SIGINT is definitely an exception by default, i just tested it
09:21:08 <cloudhead> ertes: how did you test it?
09:21:25 <ertes> main = threadDelay 100000000 `finally` putStrLn "bye"
09:22:33 <ertes> weird…  if i send SIGINT, it doesn't print "bye", but if i press ^C, it does
09:22:44 <ertes> i may be mistaken about the way signals are handled
09:22:58 <cloudhead> hmmm
09:22:59 <glguy> ^C doesn't send SIGINT directly iirc
09:23:04 <glguy> there's a related signal
09:24:43 <ertes> d'oh
09:24:50 <ertes> i used 'killall' wrong =)
09:24:59 <ertes> SIGINT is an exception, just sent it via killall
09:26:04 <ertes> interestingly it even works when i pass --install-signal-handlers=no to the RTS, so i have no idea what that flag does
09:26:56 <SAL9000> What happens to non-main threads when the main thread gets SIGINT or similar?
09:27:16 <glguy> When the main thread terminates the program exits
09:27:18 <ertes> SAL9000: when the main thread exits, all threads are killed
09:27:32 <SAL9000> "killed" forcefully, or with an exception?
09:27:36 <ertes> forcefully
09:27:56 <SAL9000> hn. I assume that's not configurable?
09:28:23 <ertes> SAL9000: no, but the 'async' library makes that somewhat convenient to deal with:  use withAsync and wait
09:28:45 <ertes> when killing a thread use 'cancel' and 'wait'
09:30:09 <ertes> :t \action -> bracket (async action) (\xV -> cancel xV >> wait xV)
09:30:10 <lambdabot> Not in scope: ‘async’
09:30:10 <lambdabot> Not in scope: ‘cancel’
09:30:10 <lambdabot> Not in scope: ‘wait’
09:30:25 <ertes> @let import Control.Concurrent.Async
09:30:26 <lambdabot>  .L.hs:46:1:
09:30:26 <lambdabot>      Failed to load interface for ‘Control.Concurrent.Async’
09:30:26 <lambdabot>      Perhaps you meant
09:33:35 <geekosaur> ^C sends SIGINT to the terminal's foreground process group
09:34:03 <geekosaur> you may be thinking of ^Z (sends SIGTSTP which turns into SIGSTOP if not handled, so a SIGTSTP handler can change to a safe state and then SIGSTOP itself)
09:34:23 <glguy> geekosaur: Yup, that's what I was thinking of
09:34:54 <cloudhead> ertes: when I use a sigterm, I get `zsh: terminated  ./test`, no bracketing
09:35:02 <cloudhead> but works with ^C
09:35:07 * ertes was thinking of ^C and SIGINT, but got the syntax of the killall command wrong
09:35:27 <cloudhead> oh so your test showed SIGTERM not to be caught too
09:35:35 <ertes> yeah
09:35:38 <cloudhead> ah ok
09:35:38 <geekosaur> I didn;t think SIGTERM was caught by default by the runtime
09:36:03 <ertes> that's interesting though…  i may have to update some of my code
09:36:34 <cloudhead> yea makes quite a big difference
09:36:44 <geekosaur> you do have to be careful about installing a handler for "all signals" because the runtime does catch --- and use --- some of them, and will break if you replace its handler (notable here, SIGALRM)
09:37:12 <geekosaur> (+RTS -V0 will make it work in that case though)
09:39:09 <glguy> geekosaur: https://ghc.haskell.org/trac/ghc/ticket/850 this mentions that now SIGVTARLM is used in both threaded and non-threaded runtimes. (not that you're wrong about signals being important to the RTS) Do you know if that's changed since?
09:39:32 <geekosaur> sounds more that that has changed since I last looked x.x
09:39:42 * glguy finds https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Signals
09:39:43 <geekosaur> I should not be surprised
09:40:13 <cloudhead> ertes: tracked it down if curious: https://github.com/ghc/ghc/blob/5d98b8bf249fab9bb0be6c5d4e8ddd4578994abb/libraries/base/GHC/TopHandler.hs#L61
09:40:17 <geekosaur> but I think -V0 still prevents the timer alarm from being set or used
09:43:38 <ertes> this works:
09:43:38 <ertes> main = do tid <- myThreadId; installHandler sigTERM (CatchOnce $ throwTo tid (userError "Test")) Nothing; threadDelay 100000000 `finally` putStrLn "bye"
09:43:48 <ertes> geekosaur: any comments on this?
09:45:17 <geekosaur> should be fine, aside from what happens if it takes a while to respond and SIGTERM is sent again (think about running from a job server, including the system one (init/systemd/upstart/whatever))
09:45:25 * geekosaur sucked into a call...
09:46:01 <ertes> yeah, that's fine…  most process managers don't TERM again, they go right to KILL
09:48:02 <ertes> SAL9000: see above
09:49:17 <SAL9000> Thanks! Now to figure out how to fit one of these solutions into the existing (somewhat unwieldy) architecture of taffybar :-)
09:49:55 <ertes> hah!  i thought i'm the only person using it
09:49:56 <geekosaur> so you are running something from taffybar and want it to exit when taffybar does?
09:50:03 <SAL9000> Yeah.
09:50:05 <geekosaur> can/does it read its stdin
09:50:06 <geekosaur> ?
09:50:19 <SAL9000> it writes stdout and will probably die from SIGPIPE when taffybar does
09:50:43 <geekosaur> ah, so don't want to use an input pipe also (things get hairy at that point)
09:51:31 <SAL9000> in case anyone else is interested -- I'm working on i3bar json support for taffybar
09:51:54 <SAL9000> I want to be able to pipe i3status or similar into taffybar, instead of re-inventing the system stats wheel
09:52:02 <SAL9000> ertes: ^
09:52:28 <ertes> ah
09:53:05 <mikail`> Hi, please can I get some advice on whether this is the correct use of typeclasses (http://lpaste.net/169792). The reason I am asking is that each instance will be using the same definition of the call and put functions so it's not really overloading any functions. Thanks.
09:53:27 <SAL9000> ertes: I can't use taffybar's "PollingLabel" as-is because i3status doesn't just stop after one line (and I wouldn't want it to)
09:53:38 * hackagebot varying 0.5.0.2 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.5.0.2 (SchellScivally)
09:56:09 <dustmote> EvanR: dereferencing as in replacing a variable with its value during program evaluation/interpretation
09:56:23 <ertes> SAL9000: i don't have too much experience with taffybar…  just configured it once and since then it's running untouched
09:56:37 <dustmote> glguy: So my AST shouldn't just match the structure of the parser?
09:56:54 <geekosaur> ...the usual trick for status bars run from xmonad is you open it over a pipe connected to its stdin and set the parent (xmonad) side F_CLOEXEC, then either exit or restart (which does exec) will close the write end of the pipe and the read end in the child gets eof
09:56:57 <geekosaur> (still on call)(
09:56:59 <dustmote> glguy: i'd never thought of that.. thanks!
10:07:25 <zomg> Anyone here happen to work at Front Row Education?
10:08:53 <Welkin> lol zomg 
10:08:55 <Welkin> why do you ask?
10:09:23 <Welkin> it's possible
10:10:00 <zomg> Just curious as they seem to be hiring haskell devs :)
10:10:00 <danza> yeah it's a king of odd question for this channel ...
10:10:25 <danza> hehe whoever hires Haskellers gets into the spotlight automatically ... :)
10:10:29 <zomg> they do advertise that some of their employees are "well known"
10:10:41 <zomg> so figured maybe someone here might be "well known" :P
10:11:31 <Welkin> lol
10:11:37 <Welkin> I don't know enyone who works there
10:11:45 <Welkin> so I guess their claim is false
10:11:47 <nitrix> I'm sure we have more "well known" names here than those who work at that company I've never heard.
10:11:48 <Welkin> anyone*
10:13:32 <Welkin> the way slices are typically implemented seems broken
10:13:36 <Welkin> it never made sense to me
10:13:52 <Welkin> slice(0,5) is the interval [0,5)
10:13:56 <Welkin> why not [0,5]?
10:14:30 <Welkin> oops, wrong channel :P
10:16:42 <puregreen> Welkin: “slice(a,b) ++ slice(b,c) == slice(a,c)” seems like a potentially useful invariant to me
10:19:40 <Welkin> hm, I like how Data.Vector implements slice
10:19:49 <Welkin> using the starting index and the length
10:19:54 <Welkin> rather than an ending index
10:20:42 <infandum> How can I update a Matrix in hmatrix? Like change the (2,6) element to 4 for instance?
10:20:56 <Welkin> infandum: look in the docs
10:21:01 <Welkin> it's prbably similar to the vector api
10:21:03 <infandum> I did, I couldn't find it
10:21:21 <infandum> It doesn't need to be mutable, it can return a new matrix with just that on element replaced
10:22:53 <Welkin> hackage.haskell.org/package/hmatrix-0.17.0.1/docs/Numeric-LinearAlgebra-Data.html
10:26:11 <Welkin> really? that package uses unicode characters for function names?
10:26:23 <Welkin> an upside down question mark... how do they expect anyone to type that?
10:26:31 <geekosaur> ¿
10:26:32 <jle`> zipper: what's the error?
10:26:46 <liste> Welkin: compose, ? ? -- ¿
10:26:59 <infandum> Welkin: Yeah, that was nuts when I saw that
10:27:49 <monochrom> ¿how do you use ¿ as an operator?  :)
10:28:06 <infandum> ugh
10:28:11 <ertes> > let (¿) = (+) in 3 ¿ 3
10:28:12 <lambdabot>  6
10:28:26 <liste> ¿maybe that lib was written by someone Spanish?
10:28:50 <Welkin> no, I asked how you type it without using anything special
10:28:54 <liste> do Spanish have ¿ on their keyboard
10:28:59 <Welkin> probably
10:29:07 <ertes> the arithmoi package does that, too, but always provides ASCII variants of the same functions
10:29:07 <heebo> ive put checkers , QuickCheck and hspec into my test-suite cabal
10:29:07 <heebo>         build-dependencies yet , stack test still says 'traversable not in
10:29:07 <heebo>         scope', any ideas?  [18:23]
10:29:10 <heebo>  
10:29:29 <liste> @lpaste -- heebo
10:29:30 <lambdabot> Haskell pastebin: http://lpaste.net/
10:29:49 <liste> heebo: it's Traversable
10:30:09 <heebo> im talking about traversable from checkers
10:30:38 <infandum> Welkin: It looks like the closest thing to do is accum mat const [((2,6), 4)]
10:30:39 <geekosaur> "not in scope" suggests to me you are missing an import, not a package in your cinfig
10:30:44 <infandum> That's pretty silly though
10:31:15 <Welkin> infandum: yeah, I have never worked with hmatrix. I just use a flat array with an indexing expression
10:31:35 <Welkin> hmatrix doesn't look like the easiest thing to work with
10:31:51 <asdf0101> hello everyone! can somebody please help me resolve a couple of particular error handling-related confusions i have? the first question is rather simple: i have a relatively simple pure function, which accepts a couple of `Int`s, and isn't defined if the first `Int` is negative or if the second `Int` isn't divisible by a particular constant. how do i signal that an error occured? would you prefer `error`, `throw`ing a custom excepti
10:32:01 <asdf0101> are there any agreed-upon guidelines?
10:32:17 <Welkin> asdf0101: wrap the result in Maybe
10:32:23 <Welkin> never use `error` in your code
10:32:32 <Welkin> and don't throw exceptions
10:32:34 <infandum> Welkin: accum looks slow though -- it uses map when it should be a simple update
10:32:40 <asdf0101> Welkin: but how would the user know why the function failed?
10:32:49 <Welkin> asdf0101: you can pattern match on the Maybe
10:32:58 <ertes> asdf0101: there is Either String, too
10:32:59 <matrium> or use Either
10:32:59 <Welkin> it is either `Just result` or Nothing
10:32:59 <infandum> Welkin: wait nevermind, the map is for the association list of changes
10:33:06 <Welkin> yeah
10:33:11 <Welkin> actually use Either instead
10:33:25 <asdf0101> Welkin: and the exact reason, like if the first or the second argument was invalid? it's actually a little bit more complicated than that
10:33:54 <Welkin> asdf0101: yes, just write different cases
10:34:26 <asdf0101> Welkin: why shouldn't i use exceptions? i'm genuinely curious
10:34:27 <matrium> data Error = FirstInvalid | SecondInvalid
10:34:33 <geekosaur> if it's a "shouldn't happen", use error. if it's something likely to come up in normal usage and you care only about success/failure, use Maybe. if you need to track how it failed as well, use Either
10:34:37 <matrium> Either Error Result
10:35:10 <asdf0101> ok, thank you guys, now i get the idea of what the approach should probably be
10:35:33 <geekosaur> some languages want you to think exceptions are normal flow control. occasionally those languages even make them fast enough to be tolerable as such. but exceptions are rather heavy, and in Haskell you can only catch then in IO because by definition they are not the normal program flow
10:36:24 <asdf0101> geekosaur: what about the `exceptions` package? i had the impression it generalized IO to any monad. or was it some other package...
10:36:43 <ertes> @let isqrt y | y < 0 = Left "Argument negative." | otherwise = go 0 0 where go x y' = case compare y' y of EQ -> Right r; GT -> Left "not a square"; LT -> go (r + 1) (y' + 2*r + 1)
10:36:44 <geekosaur> it still has to have an IO somewhere underneath
10:36:45 <lambdabot>  Defined.
10:36:51 <ertes> > isqrt 4
10:36:56 <lambdabot>  mueval-core: Time limit exceeded
10:37:13 <geekosaur> exceptions just generalizes exception handling to transformer stacks based on IO
10:37:26 <geekosaur> (which has some nasty edge cases)
10:37:29 <ertes> uh
10:37:31 <ertes> @undef
10:37:31 <lambdabot> Undefined.
10:37:35 <Welkin> lol ertes 
10:37:42 <ertes> @let isqrt y | y < 0 = Left "Argument negative." | otherwise = go 0 0 where go x y' = case compare y' y of EQ -> Right x; GT -> Left "not a square"; LT -> go (x + 1) (y' + 2*x + 1)
10:37:43 <lambdabot>  Defined.
10:37:47 <ertes> > isqrt 4
10:37:48 <lambdabot>  Right 2
10:37:50 <ertes> > isqrt 5
10:37:52 <lambdabot>  Left "not a square"
10:37:53 <ertes> > isqrt (-1)
10:37:55 <lambdabot>  Left "Argument negative."
10:37:57 <davidkart> nitrix, right actually it would be.
10:38:05 <ertes> asdf0101: ^
10:38:22 <ertes> asdf0101: this one uses Either String, but you can also use Either MyErrorType
10:38:31 <asdf0101> ertes: yes, thank you, that looks very nice
10:38:45 <ertes> data MyErrorType = NegativeArg | NoSquare
10:38:46 <geekosaur> but regardless, exceptions cannot be caught in pure code, only in IO (or, with sufficient lifting trickery, monad stacks with IO at the bottom)
10:39:26 <asdf0101> geekosaur: ah... that makes it more clear, thank you
10:39:33 <Henson> geekosaur: so if I am doing some filesystem stuff or executing programs in the unix shell, should I make use of an ExceptT monad and do a bunch of checking inside what I'm trying to do, to make sure things should succeed along the way, or just wrap the whole thing into an exception check?  I'm currently doing the former, but in C++ or Java I'd do the latter because it's easier.
10:40:04 <maerwald> Henson: if you are doing filesystem stuff you are always exposed to exceptions
10:40:38 <Henson> geekosaur: it's still possible that an exception will be thrown along the way, but checking to make sure that files exist, are executable, etc, gives me a lot more opportunity to get fine-grained error responses back, instead of just an IOException was thrown.
10:41:05 <maerwald> Henson: explicitly checking if the file exists is a moot point most of the time, an exception of the low-level unix call will tell you if it does or not
10:41:12 <maerwald> doing that 2-step doesn't make too much sense most of the time
10:41:20 <ertes> i wonder whether we could establish the convention to make error-reporting polymorphic by default
10:41:31 <ertes> i.e. use Alternative rather than Maybe
10:41:54 <ertes> are there other people who would find that useful?
10:42:09 <jle`> Henson: if the IOException type is your problem, you can always just define your own Exception type
10:42:38 <jle`> but checking that your file exists before trying to read it is one of those bad practices that will always come to bite you
10:43:55 <geekosaur> Henson, it does but there are other reasons to not check first. Notably, race conditions which can potentially introduce security issues
10:44:07 <Henson> jle`: but is it better to throw Exceptions out of a function and use a single "try" to catch them higher up, or do use an ExceptT monad and "try" functions inside to catch exceptions.
10:44:10 <ertes> those atomicity bugs are really hard to find…  they hide in the shadows until you least expect it, they give you a little bite you barely notice (somewhere in the log file), and at some point all those little failures make your whole architecture crash down
10:45:03 <jle`> Henson: it depends on the semantics of what you're doing.  but usually for something like IO exceptions, it makes the most sense to let it propagate
10:45:21 <jle`> `ExceptT e IO` should really only make sense if the 'e' comes from "pure" errors
10:45:21 <maerwald> Henson: depends what you are doing
10:45:33 <jle`> not IO exceptions, which are a completely different kind of thing
10:45:51 <asdf0101> and another question guys, if you don't mind: is there a sane way to navigate throw the plethora of ways to do exceptions/failures in Haskell? like throw/throwIO/throwSTM/throwM/throwE/ExceptT/EitherT/error/fail/MonadFail/MonadError/etc. i actually learnt quite a few of them just by looking at the source, but this limited knowledge just evaporates from my head, adding confusion to the already annoying feeling that i'm definitely doi
10:45:54 <asdf0101> i understand that it's hard-to-impossible to provide the reasoning behind every method in an IRC chat, i was just wondering if maybe someone has already done the job and wrote a reference/tutorial
10:46:10 <maerwald> Henson: I hate using transformers and wrapping everything inside Either is silly too imo. I like to catch the stuff I know about and the rest *should* crash my program, since the case is effectively not handled. Using Either/Maybe just hides the issue
10:46:27 <jle`> they require a different kind of handling, and Haskell's IO Exception system is definitely much more well-suited to IO exceptions than Either/Maybe transformers
10:46:45 <ertes> asdf0101: in general use Maybe/Either/[] for pure code, use IO exceptions for IO code
10:47:07 <ertes> asdf0101: the abstractions allow your code to be slightly generic, but we're not sure whether and when it's a good idea…  it depends a lot on the circumstances
10:47:30 <ertes> asdf0101: if in doubt, follow the rule above:  Maybe/Either/[] for pure code, IO exceptions for IO
10:47:53 <ertes> asdf0101: most of the more advanced stuff is about *handling* exceptions, not generating them
10:48:08 <cloudhead> asdf0101: the readme (and library itself) is useful: https://github.com/fpco/safe-exceptions#readme
10:48:12 <ertes> asdf0101: and they become mostly interesting in the context of the heavy monad stacks that some web frameworks like to use
10:48:27 <Henson> wow, thanks for your input, guys.  This will make me rethink how I handle errors in my program.
10:48:34 <ertes> asdf0101: in other words: you will know when you need them
10:48:35 <heebo> http://dpaste.com/2M913SQ
10:48:39 <maerwald> mind that haskell is very poor at knowing if there are uncaught exceptions... it can't
10:48:40 * hackagebot nixfromnpm 0.10.1 - Generate nix expressions from npm packages.  https://hackage.haskell.org/package/nixfromnpm-0.10.1 (thinkpad20)
10:48:46 <heebo> please take a look im a bit stumped
10:50:35 <asdf0101> ertes: yeah, i've heard this advice before, i was just trying to dig through some sources and i'm not on that level yet to keep up with this stuff, find it impossible to "get" why people use on method or another... specifically when it's something more advanced than plain `Maybe`/`Either`/`throwIO`; can't wrap my head around it
10:50:47 <asdf0101> cloudhead: thank you, i will definitely take a look at it
10:51:02 <ertes> asdf0101: do you have experience with monad transformers?
10:51:06 <cloudhead> asdf0101: even if you don't use the lib, the readme can help clear some things up
10:51:50 <asdf0101> asdf0101: not more than reading tutorials... guess part of the problem, huh
10:52:05 <asdf0101> ertes: ^
10:52:13 <maerwald> avoid them if you don't need them
10:52:15 <ertes> asdf0101: then it's not relevant yet =)
10:52:29 <runeks> Is there no way for me to define a "Data.Binary (Maybe MyType)" instance for my own type MyType since the Data.Binary package already has an instance for "Maybe a"?
10:52:38 <glguy> Heebo: did you read the error message?
10:52:38 <ertes> asdf0101: as soon as you use a monad transformer you will know what the problem is
10:52:44 <jle`> runeks: you can use a newtype wrapper
10:53:06 <heebo>  glguy yes, but I dont want Traversable , I want traversable from checkers
10:53:36 <jle`> heebo: do you know what module exports 'traversable' ?
10:53:46 <asdf0101> ok, thank you guys, as supportive and helpful as always
10:53:49 <runeks> jle`: so "newtype MaybeMyType a = MyMaybe (Maybe a)"?
10:53:55 <geekosaur> verify that your version of QuickCheck has that?
10:54:02 <jle`> runeks: newtype MaybeMyType = MyMaybe (Maybe MyType)
10:54:27 <runeks> jle`: Alright. Thanks!
10:54:29 <ertes> asdf0101: oh, and listen to maerwald…  so other than for educational purposes, don't go out of your way to use monad transformers now =)
10:54:45 <jle`> runeks: you'd only need to pop it on/off when serializing, so you can use Maybe MyType as normal for the most part
10:54:46 <asdf0101> ertes: will try my best to
10:55:45 <runeks> jle`: Yeah. There's really no reason to make a generic new Maybe type.
10:56:03 <geekosaur> and fwiw hayoo tells me it's in Test.QuickCheck.Classes and .Checkers doesn't reexport it from .Classes
10:56:16 <glguy> Heebo: then you need to import the module that defines traversable
10:56:41 <jle`> runeks: alternatively you might be able to use the overlapping pragma -- instance {-# OVERLAPPING #-} Binary (Maybe MyType), but that might just be pushing the headache down the line
10:57:12 <jle`> and it's probably a bad idea for maintainability purposes
10:58:13 <cloudhead> ertes: is this general advice, or more for beginners?
10:59:19 <runeks> jle`: Yeah I think vanilla Haskell is to prefer is most cases, at least for maintainability, as you say
10:59:32 <heebo> jle, glguy  It says the same when i import Test.QuickCheck
10:59:42 <glguy> heebo: That module doesn't export traversable, either
10:59:45 <maerwald> cloudhead: use them, if they actually reduce complexity and don't just "look nicer"
10:59:58 <jle`> runeks: it's just that typeclasses are already complex enough as they are, what with their global nature.  throwing in incoherency issues just makes things worse :)
11:00:03 <heebo> https://hackage.haskell.org/package/checkers-0.4.4/docs/Test-QuickCheck-Classes.html
11:00:08 <heebo> i thought it does
11:00:21 <glguy> heebo: You should look in the haddock documentation to figure out what a module exports, or use GHCi and :browse
11:00:23 <cloudhead> maerwald: right, just wondering if there are solid alternatives for composing effects
11:00:35 <jle`> heebo: you can look in the haddocks, too  https://hackage.haskell.org/package/checkers-0.4.4/docs/doc-index.html
11:00:39 <jle`> or hoogle
11:00:40 <maerwald> cloudhead: yes, extensible-effects and freer
11:00:54 <runeks> jle`: What are these incoherency issues? You mean it's hard to read what the code does?
11:01:03 <jle`> runeks: incoherency with resolving typeclasses
11:01:17 <jle`> GHC picking which one to use
11:01:22 <cloudhead> maerwald: thanks will have a look
11:01:23 <jle`> typeclasses are literal magic
11:01:59 <jle`> any time you're doing typeclass tricks, you're playing with fire :)
11:02:20 <runeks> jle`: Seems to me it's a sign that typeclasses need more work. There should be some built-in way to export/import instances.
11:02:43 <monochrom> type class resolution is as simple as Prolog without cut.
11:02:48 <heebo> ok all solved sorry , its in Test.QuickCheck.Classes, blind error
11:03:12 <jle`> runeks: typeclass instances being consistent and global is necessary to hold programs together
11:03:30 <runeks> imports in general in Haskell needs more work, as far as I can see. I spend a lot of time writing import statements, and as far as I can see, that shouldn't be necessary. Someone just needs to write the tooling I guess.
11:03:40 * hackagebot bloodhound-amazonka-auth 0.1.1.0 - Adds convenient Amazon ElasticSearch Service authentication to Bloodhound.  https://hackage.haskell.org/package/bloodhound-amazonka-auth-0.1.1.0 (MichaelXavier)
11:03:42 <jle`> runeks: what do you think would happen if two modules that used the same 'HashMap' accidentally use two different instances of Hashable ?
11:04:34 <runeks> jle`:  I think that's what I mean by "needs more work". importing/exporting instances may not be the answer, though.
11:06:52 <SAL9000> 3> catch (error "foo") (\a -> putStrLn (a :: String))
11:07:09 <SAL9000> can anyone explain why that doesn't work? and I don't mean why lambdabot doesn't evaluate it
11:08:03 <jle`> SAL9000: you need to give GHC a way to know what type of error you are expecting to catch
11:08:11 <glguy> Because String isn't a valid exception type
11:08:16 <Philonous> SAL9000, String isn't an expetion type
11:08:21 <Philonous> exception*
11:08:23 <jle`> oh, i read it backwards v.v
11:08:27 <SAL9000> OK, so how do I catch an error "foo"?
11:08:56 <jle`> i think error "foo" throws an ErrorCall
11:09:06 <Philonous> SAL9000, catch (error "foo") (\e -> putStrLn $ show (e :: ErrorCall))
11:09:40 <SAL9000> Thanks.
11:09:47 <Philonous> Actually, instead of putStrLn and show you could use print
11:09:47 <cloudhead> in general if you're planning on catching, I wouldn't use `error` to throw though
11:10:37 <Philonous> SAL9000, Note that this will _only_ catch exceptions thrown by error (or with ErrorCall)
11:10:39 <maerwald> use ioError
11:10:40 <SAL9000> It's not my code calling `error` :-)
11:10:48 <cloudhead> ok cool :)
11:10:51 <monochrom> colouring is why lambdabot didn't see it at all
11:11:02 <SAL9000> https://hackage.haskell.org/package/json-stream-0.4.1.0/docs/src/Data-JsonStream-Parser.html#parseLazyByteString
11:11:54 <SAL9000> > catch (error "foo") (\a -> putStrLn $ show (a :: ErrorCall))
11:11:56 <lambdabot>  <IO ()>
11:11:57 <Cale> SAL9000: also, lambdabot doesn't evaluate it because your IRC client seems to have stuck some colour codes in at the start of the line.
11:11:58 <cloudhead> that seems like pretty bad practice.. but I'm no expert
11:12:14 <Cale> (but also, it's an expression for an IO action, so the evaluation is pretty boring)
11:12:26 <Cale> Lambdabot never *executes* IO actions.
11:12:39 <SAL9000> too unsafe, I imagine
11:13:02 <cloudhead> well, why does it have a ParseFailed, but not use that instead of throwing error?
11:13:20 <cloudhead> ah nm, it's internal
11:13:23 <SAL9000> it does use it, in other places =/
11:13:31 <jle`> it's also a little inconsistent, because lamdabot normally evaluates expressions
11:13:46 <cloudhead> strange
11:13:55 <jle`> *it'd be inconsistent if lambdabot executed IO actions
11:16:17 <lpaste> SAL9000 pasted “it's not catching...” at http://lpaste.net/169840
11:17:21 <monochrom> I wonder if you should use runParser and loop over ParserOutput values instead
11:17:43 <jle`> SAL9000: what type of error does parseLazyByteString throw?
11:18:08 <davidkart> runeks: you are not the only one complaining about lack of consistent tools 
11:18:13 <SAL9000> loop _ (ParseFailed err) = error err
11:18:19 <SAL9000> jle`: ^
11:18:23 <monochrom> "create a list lazily but the creator may run into problems" is hard to deal with
11:18:30 <davidkart> hello ertes
11:19:18 <davidkart> I did that function : http://pastie.org/10907476
11:19:28 <monochrom> it is a stress test on your knowledge on lazy evaluation. do you want a stress test on your knowledge on lazy evaluation?
11:19:31 <davidkart> :t replicateM
11:19:33 <lambdabot> Monad m => Int -> m a -> m [a]
11:19:51 <SAL9000> monochrom: are you talking about BL.ByteString?
11:20:05 <davidkart> the same built-in function has a weird type. What is a Monad ?
11:20:11 <davidkart> what is m a ?
11:20:12 <monochrom> no, I am talking about parseLazyByteString.
11:20:12 <ertes> cloudhead: i'd say it's general…  monad transformers can be useful sometimes, but they can easily become nuisances you constantly have to work around
11:20:45 <monochrom> (why would I talk about lazy bytestring, which clearly is not the problem?)
11:20:51 <ertes> davidkart: great…  note that you can pattern-match on numbers though
11:20:54 <cloudhead> ertes: yeah that's what I'm finding, and the instance bloat also..
11:21:09 <ertes> davidkart: allCodes 0 xs = [[]]
11:21:19 <SAL9000> monochrom: I want to give the parser a lazy bytestring and get a lazy list back, yes -- in this particular trivial case I can use a non-lazy list (it's one item) but I'll need to use an infinite list later
11:21:32 <cloudhead> ertes: I wasn't aware there were real alternatives though, I'm going to try to refactor my code with extensible-effects, see if it makes things simpler
11:21:50 <ertes> cloudhead: you'll probably find it doesn't =)
11:21:56 <cloudhead> haha
11:22:20 <cloudhead> what's the tradeoff?
11:22:21 <maerwald> cloudhead: freer is the "latest" one, extensible-effects is based on an older paper
11:22:40 <monochrom> there is no real conflict between using ParserOutput and using lazy bytestring. there is only a superficial conflict that can be trivially resolved, if you know well the bytestring library
11:22:42 <maerwald> cloudhead: SEE http://okmij.org/ftp/Haskell/extensible/
11:22:56 <cloudhead> ah ok, it just almost seems "too new"
11:23:10 <davidkart> ertes: oh, yeah, pattern matching seems not that clean to me but I bet it is the same.
11:23:27 <maerwald> cloudhead: why?
11:23:35 <davidkart> I had trouble knowing if the stopping condition should be after or before the definition of the function.
11:23:37 <maerwald> cloudhead: the main problem is most libraries don't use it
11:23:40 <cloudhead> maerwald: I just mean not tried and tested
11:23:47 <maerwald> sure it is
11:23:55 <maerwald> the papers even include performance tests
11:24:00 <ertes> cloudhead: i'd prefer not to comment on this before playing around with it myself, but just from the types it seems that you get a lot of type-level complexity
11:24:20 <maerwald> ertes: freer is much more simple to use imo
11:24:32 <ertes> i'll look into it
11:24:48 <ertes> is it what it name suggests?  free monad-based effects?
11:24:50 <cloudhead> I might just make a toy example then and try both
11:25:17 <maerwald> ertes: it's based on http://okmij.org/ftp/Haskell/extensible/more.pdf
11:25:43 <ertes> maerwald: is it based on free monads?  i'd prefer not to read a full paper right now =)
11:26:21 <maerwald> "Freer is an implementation of Freer Monads, More Extensible Effects"
11:27:45 <ertes> ok, the Eff type also suggests that it's basically free monads
11:28:00 <monochrom> if I know Oleg, it is possible that when he says "freer" he doesn't mean "based on free", but rather "supersedes free"
11:28:50 <maerwald> yeah, free-er says the paper ;)
11:29:04 <dolio> The "freer" means that when you do Church-encoding like free monads, you form the free monad over a type constructor, rather than a functor.
11:29:15 <dolio> Like you applied (co)-yoneda to the type constructor.
11:29:54 <maerwald> what I don't like about freer currently is that using IO effects is somewhat limited and awkward
11:31:44 <ertes> hmm…  as formulated in that library it doesn't seem as generic as monad transformers
11:31:51 <maerwald> ?
11:32:32 <ertes> if you want the same effect twice, for example
11:32:45 <ertes> you probably need to do some wrapping to achieve that
11:33:02 <maerwald> I don't even know what you mean with "twice"
11:33:16 <ertes> StateT A (State B)
11:33:49 <ertes> it uses instance resolution to pick the effect
11:34:02 <ertes> so you don't get to choose, which one you want, unless you define a wrapper type
11:35:49 <dolio> Right, that's like how you can't have (MonadState A m, MonadState B m).
11:35:49 <ertes> i can see how effect *implementors* would benefit from that approach, but *users* probably don't
11:36:28 <ertes> dolio: well, i can refer to an explicit stack without effect classes, which is impossible here
11:36:55 <dolio> Yes, you can do that. But the extensible effect stuff is equivalent to using the mtl classes.
11:37:08 <cloudhead> ertes: you can actually have StateT twice with no wrappers in the transformers solution?
11:37:15 <ertes> dolio: background: i may have a MonadState action, on top of which i put a StateT for some local computation with explicit lifting
11:37:29 <dolio> Or, similar classes. mtl classes have extra stuff in them that don't correspond to extensible effects stuff.
11:37:43 <ertes> dolio: i note this, because it's something i do in practice sometimes
11:38:01 <ertes> freer seems to make that pattern impossible
11:38:04 <ertes> cloudhead: yeah
11:38:35 <cloudhead> ertes: but how would the `deriving` know which StateT to derive?
11:38:38 <dolio> Well, I'm not 100% sure about that being impossible with the classes. You can do local extensions.
11:38:56 <cloudhead> ertes: derive from I mean
11:39:01 <dolio> Although accessing the underlying thing might be dicey.
11:39:14 <ertes> dolio: as far as i see, i'd need to make a wrapper type for the local state, because i don't see any other way to use state actions than through instance resolution
11:39:18 <davidkart> anybody with a gentle introduction to CT ?
11:39:27 <ertes> cloudhead: not sure what you mean
11:39:33 <davidkart> (if possible in relation with FP/Haskell)
11:40:25 <cloudhead> ertes: if you have a type like `Foo (StateT s (StateT s' IO))`
11:40:32 <cloudhead> ertes: and you want to derive MonadState
11:40:37 <notdan> davidkart: Category Theotry for Computer Scientists by B. Pierce
11:40:41 <dmj`> davidkart: conceptual mathematics
11:40:53 <ertes> cloudhead: i'm pretty sure it would derive MonadState for s
11:40:55 <cloudhead> how does it know what state you're referring to when you use `gets` for ex
11:41:16 <cloudhead> right, but then you have to do the second one manually?
11:41:32 <ertes> cloudhead: i'd never write such a type
11:41:40 <ertes> StateT (s, s')
11:42:00 <cloudhead> oh I see
11:42:28 <cloudhead> but then you would need s' to be part of s?
11:42:37 <cloudhead> as in, inside the datatype of 's'
11:42:50 <ertes> cloudhead: this is for local stateful computations…  you have a main monad that has a state component, and in a small part you apply another StateT for a short amount of time
11:43:02 <cloudhead> ok gotcha, yeah
11:43:15 <cloudhead> so you do a runStateT within your other state
11:43:21 <ertes> yeah, exactly
11:43:23 <hexagoxel> cloudhead: MultiState '[s, s']
11:43:31 <cloudhead> was thinking of another use-case
11:44:09 <cloudhead> where more than one of the effects/monads in the stack is a StateT
11:44:20 <cloudhead> or wraps a StateT
11:44:33 <hexagoxel> with `multistate`, if you keep the MultiStateT at a certain position (preferably the top of your other stack) you can easily add a local state.
11:44:34 <ertes> cloudhead: that seems rather useless to have
11:45:02 * hexagoxel disclaims his authorship of multistate.
11:45:43 <cloudhead> ertes: hmm maybe I'm approaching it wrong, but there's two very distinct states in my stack that shouldn't know about each other, so I have two StateTs
11:46:59 <ertes> cloudhead: use one StateT with a tuple/product…  you could even zoom in on one of the states using a lens as you see fit
11:47:07 <cloudhead> they aren't both "bare" though, one is in a newtype and has its own typeclass
11:47:17 <monochrom> if you nest two StateT's, one of them knows the other.
11:47:31 <cloudhead> it knows the typeclass
11:47:57 <cloudhead> like, MonadOtherState
11:48:31 <cloudhead> ertes: but then I can't separate the effects
11:48:46 <cloudhead> the point is that they encapsulate different effects
11:49:24 <ertes> cloudhead: rather than inventing a new state type with a new type class, you should just use wrappers around the regular MonadState
11:49:36 <Sonolin> ^^
11:50:00 <Cale> This kind of thing is exactly why I dislike the term "monad transformer stack" -- if you have to think about all the monads produced along the way to your goal when using monad transformers, you're probably using them in a way which is going to result in awkwardness.
11:50:02 <ertes> cloudhead: as said, you can go as far as to just hide part of the state: withLeft = zoom _1
11:50:35 <synergistics> Why is a library installed with stack not available to be imported in stack ghci?
11:50:35 <Cale> It's not a stack. You start with some monad, you transform it a bunch, and you end up with some monad.
11:51:11 <kadoban> synergistics: 'stack ghci --package whateverpackage' ?
11:51:33 <Cale> Then, hopefully, you do something to clean up the resulting API a bunch, because MonadState is really not an acceptably-designed API for anything in particular.
11:51:47 <kadoban> stack doesn't really have a global installation of libraries, only accidentally, so you might be assuming something has been installed "globally" that isn't.
11:51:48 <synergistics> kadoban: Yea, but what's the reasoning there? If I installed a package, why isn't it available by default?
11:51:59 <EvanR> you want the end result to be a monad that can do X, where X is something understandable. you can implement this directly or maybe with transformers, but if you use transformers thats not supposed to matter in the end
11:52:09 <Cale> EvanR: exactly
11:52:19 <cloudhead> ertes: the outer monad shouldn't have access to the inner's StateT though
11:52:42 <ertes> cloudhead: it "has access", whether you want it or not
11:52:50 <maerwald> Cale: I've barely encountered monad transformers where you didn't have to know about the internals
11:52:57 <maerwald> that's why they suck
11:53:00 <ertes> cloudhead: at least it knows about the other state
11:53:10 <cloudhead> ertes: how so?
11:53:25 <ertes> cloudhead: because it transforms its argument monad
11:53:39 <Cale> maerwald: Well, monad transformers have a place, but they're a bit niche, and you have to take some care to use them appropriately.
11:53:39 <maerwald> ertes: you can do: stateEff :: Eff '[State Int, State Int] String -- btw
11:53:41 <cloudhead> ertes: if the other state is `newtype Foo = Foo (StateT...`
11:54:14 <maerwald> you just get into trouble if both States have state type Int since 'get' then just picks the first effect
11:54:18 <ertes> cloudhead: then you have a type class or some ad-hoc actions to manipulate the "inner" state
11:54:26 <cloudhead> ertes: yes exactly
11:54:33 <ertes> cloudhead: it's not types that have knowledge, but functions
11:54:46 <ertes> and they only know what they expect as arguments
11:54:50 <cloudhead> but those functions are under my control, they don't have to touch the state directly
11:54:54 <ertes> (or instances)
11:55:09 <cloudhead> what I mean is, those functions wouldn't be `get/put/modify`
11:55:13 <maerwald> ertes: so yes, you can have one effect multiple times
11:55:15 <cloudhead> they would be higher level
11:55:24 <Cale> Here's what I recommend you do: forget about monad transformers for a moment, and design the library in the way it's meant to be used.
11:55:47 <cloudhead> Cale: but that ends up requiring transformers :/
11:55:53 <Cale> Then, maybe choose to implement the interface you designed using monad transformers, or maybe implement it directly, but it won't matter at that point.
11:55:56 <ertes> cloudhead: you never *need* transformers
11:56:00 <cloudhead> unless I re-implement reader/state/etc
11:56:08 <Cale> You shouldn't need to expose the fact that you're using monad transformers
11:56:13 <ertes> cloudhead: they are called "tranformers", because they are basically functions that take a monad and produce a monad
11:56:15 <cloudhead> correct, but without them, I'd have to rewrite a bunch of classes
11:56:19 <hexagoxel> you never need 99% of haskell. that is a silly argument.
11:56:20 <Cale> Figure out what the *actual* operations you care about are
11:56:42 <Cale> Hint: they're never 'get' and 'put' -- you can always be more specific than that.
11:56:50 <ertes> StateT A :: (* -> *) -> (* -> *)  -- "i'm a type-level function…  i take a monad, and give you that monad upgraded with state powers"
11:57:36 <cloudhead> Cale: right, but if I do that, I'm just re-implementing prior work?
11:57:42 <Cale> Are you?
11:57:46 <Cale> Which prior work?
11:58:06 <monochrom> API design is never prior work
11:58:13 <maerwald> ertes: http://lpaste.net/169846
11:58:14 <EvanR> if you are following along, the task here will not be reimplementing any prior work
11:58:16 <cloudhead> get/gets/put/modify/local etc
11:58:24 <EvanR> you are implementing something no one has done yet
11:58:39 <Cale> cloudhead: What is this library you're designing?
11:58:41 <cloudhead> right but they will often be wrappers around those
11:58:50 <EvanR> maybe
11:58:51 <cloudhead> it's not a library, I'm working on an application
11:59:11 <Cale> Well, fair enough, what is this library you're designing as part of your application?
11:59:21 <ertes> maerwald: yeah, that looks reasonable
11:59:23 <monochrom> :)
11:59:24 <Cale> If you're constructing a new monad, you should think of it as its own library.
11:59:33 <maerwald> ertes: but yeah, if both are State Int, you are in trouble
11:59:41 <cloudhead> Cale: haha, well I'm working on a small 2d game at the moment
11:59:52 <ertes> maerwald: but it's still awkward design-wise that you have to make sure the types are different…  it relies on the fact that State takes a type argument
12:00:06 <Cale> You should make it self-contained, and it should have a clear API which is usually going to be completely free of explicit uses of monad transformers.
12:00:10 <ertes> maerwald: if you stack a Maybe effect, you're in trouble again
12:00:38 <monochrom> I don't think a lot of programmers have grokked "specification vs implementation" yet.
12:00:42 <Cale> You *might* choose to implement MonadState or MonadReader or something, but usually those aren't really the right thing.
12:00:43 <maerwald> ertes: you can always newtype it
12:00:47 <maerwald> not really a big problem
12:01:01 <cloudhead> Cale: well the game logic needs access to the game state and config, which I've modeled as State and Reader
12:01:14 <Cale> and you'd much rather have either your own type class, or just operations of your specific monad type
12:01:14 <maerwald> and if you end up stracking 4 states into your effect thing, I'm not sure the API is reasonable anyway
12:01:23 <cloudhead> and then it might need access to the graphics/engine
12:01:45 <cloudhead> Cale: so you're suggesting just having one monad
12:01:49 <Cale> yes
12:01:59 <cloudhead> but then I can't compose the effects
12:02:03 <dolio> Having multiple state effects disambiguated only by the type of the state they hold is a pretty bad idea anyway, if you ask me.
12:02:05 <cloudhead> every function has all capabilities
12:02:08 <Cale> Well, you can have more, but if you have more, then they should have coherent names.
12:02:15 <Cale> and purposes
12:02:17 <maerwald> dolio: then use newtypes to make it explicit, done
12:02:29 <ertes> maerwald: it adds at least mental and sometimes literal complexity to a rather basic use case of monad transformers…  now i could of course use Eff for most things and then use a monad transformer for this particular use case
12:02:36 <hexagoxel> btw is there any open-source project using any form of ee?
12:02:43 <ertes> maerwald: but then most of the time i will not benefit from Eff
12:02:45 <cloudhead> Cale: but if I have more than one, I'm back to needing transformers?
12:02:47 <ertes> maerwald: YMMV
12:02:47 <dolio> No, I just wouldn't ever do it.
12:02:49 <dmwit> hexagoxel: What is ee?
12:02:51 <dolio> I don't need a newtype.
12:02:58 <hexagoxel> extensible-effects/freer/..
12:03:07 <Cale> cloudhead: Nope, you can just provide explicit operations which transform an action of one monad to an action of another.
12:03:11 <maerwald> ertes: yes, Eff isn't actually meant to remove transformers, it's just an alternative
12:03:11 <Cale> M a -> N a
12:03:37 <maerwald> ertes: but the papers also present some stuff that's supposedly not possible with transformers too
12:03:41 <maerwald> so it goes both ways
12:03:43 <cloudhead> like a runXX
12:03:46 <Cale> yeah
12:04:01 <dolio> Those papers are probably wrong.
12:04:02 <Cale> Which may or may not be implemented in terms of the 'run' for some monad transformers
12:04:02 <cloudhead> right, hmm
12:04:35 <Cale> Outside of some smallish modules, nobody should need to know whether you're using monad transformers to get the job done
12:04:39 <cloudhead> so I guess the advantage of mtl is I don't have to care about that, I can just call methods of all classes in my stack
12:04:41 <EvanR> so the transformer part is going to be a small percent of the total work either way
12:04:59 <Cale> cloudhead: Yeah, it's just that those methods aren't really the methods you want.
12:05:00 <ertes> maerwald: i'll probably take a look at the paper at some point
12:05:06 <Cale> cloudhead: So it's a bit of a moot point.
12:05:15 <EvanR> the effort require to pull together a "app monad" is really due to the nature of monads
12:05:47 <ertes> i stopped designing "app monads" a long time ago =)
12:05:48 <Cale> cloudhead: The methods you want are much more specific things: What operations on the configuration are you providing access to? What operations on the game state? What graphics API operations?
12:06:08 <ertes> they almost never pay off
12:06:14 <cloudhead> Cale: right, but I'm still not sure how to separate those so that they're composable
12:06:16 <EvanR> ReaderT / env passing over IO or bust
12:06:33 <cloudhead> Cale: what would my monad type look like?
12:06:45 <maerwald> dolio: so you can do `Delimited Dynamic Binding' (ICFP 2006) with transformers?
12:06:56 <Cale> Well, which operations do you have?
12:06:58 <maerwald> or was that jus an ignorable statement
12:07:16 <ertes> cloudhead: i'd like to note that there are abstractions for locally stateful components, if you have a long-running application
12:07:23 <Cale> Let's figure it out
12:07:42 <Cale> Actually, let me introduce you to an alternative of sorts to monad transformers
12:07:50 <Cale> Just so you have another point of reference in the design space
12:07:56 <cloudhead> Cale: say I have three operations, one for each effect: readConfig, modifyState, drawScreen
12:08:57 <cloudhead> ertes: do you mean like the `local` function?
12:09:01 <Cale> Let's imagine for a moment that you started out just using IO directly, and wanted to abstract out the operations which manipulated some IORefs or whatever.
12:09:02 <EvanR> modifyState sounds hard to use
12:09:08 <EvanR> you probably want wrappers
12:09:24 <cloudhead> yep
12:09:33 <cloudhead> EvanR: yeah it's just to simplify for the example
12:09:51 <EvanR> too much simplifying might solve the wrong problem
12:10:03 <cloudhead> heh true
12:10:16 <ertes> cloudhead: no, i mean completely different abstractions:  there is the automaton arrow for time-framed components with local state, and there is FRP for stateful interaction design
12:10:30 <cloudhead> Cale: so then I'd have three IORefs: State, Config, Graphics
12:10:54 <Cale> Well, not the IORefs directly, but operations which manipulated those somehow 
12:11:02 <ertes> cloudhead: those two are mostly interesting for what i like to call "scenes":  a number of different components, each communicating over time, each with local state
12:11:21 <cloudhead> ertes: ohh, right. I know about frp, but didn't really feel comfortable with the idea
12:11:23 <Cale> If we want to be super lazy designers, we can make those operations just "readIORef r" and "writeIORef r" for each of those
12:11:32 <cloudhead> ertes: I'll have a look at the former
12:11:34 <Cale> but probably there are better options
12:11:54 <dolio> maerwald: As much as you can do it with algebraic effects.
12:11:59 <Cale> but let's start with that, okay
12:11:59 <cloudhead> sure
12:12:09 <ertes> cloudhead: IMO the latter is a better option most of the time
12:12:12 <Cale> So maybe we pull out some parameters  (Config -> IO ()) -> IO Config -> GameState 
12:12:14 <Cale> oops
12:12:28 <Cale> So maybe we pull out some parameters  (Config -> IO ()) -> IO Config -> (GameState -> IO ()) -> IO GameState -> ... -> IO ()
12:12:42 <ertes> cloudhead: but it only makes sense in the context of a long-running application (as opposed to a batch application)
12:12:51 <Cale> Of course, that's going to get annoying, so let's bundle them into a data type:
12:13:22 <dolio> maerwald: It's very simple. Eff is a free monad generated by some algebraic effect specifications. When you combine that with Oleg's "finally tagless" stuff, what you get is mtl.
12:13:34 <dolio> The classes are the effect specifications.
12:13:37 <Cale> data GameOperations = GO { setConfig :: Config -> IO (), getConfig :: IO Config, setGameState :: GameState -> IO (), getGameState :: IO GameState }
12:13:52 <cloudhead> *nods*
12:13:53 <maerwald> dolio: I don't really see that, but ok
12:14:09 <Cale> and then we can write actions with types like  GameOperations -> ... -> IO ()
12:14:33 <Cale> Now, suppose we do a really good job of pulling out all the operations we'll ever need.
12:14:41 <maerwald> maybe write a paper if you think Oleg is wrong about everything
12:15:09 <Cale> and we want to express the idea that our action doesn't really use anything except for the blessed game operations
12:15:09 <Cale> We can do this:
12:15:22 <Cale> data GameOperations m = GO { setConfig :: Config -> m (), getConfig :: m Config, setGameState :: GameState -> m (), getGameState :: m GameState }
12:15:52 <Cale> We know that we're going to plug in m = IO, but this type variable means we can forget that fact temporarily
12:16:02 <cloudhead> ok
12:16:04 <Cale> and change our action's type to be something like:
12:16:17 <Cale> (Monad m) => GameOperations m -> ... -> m ()
12:16:24 <cloudhead> yeah
12:16:31 <Cale> at which point it won't be able to do arbitrary IO any more, just use the game operations we provide
12:16:50 <Cale> We can partition the sets of operations into multiple record types if we like
12:17:08 <Cale> and control very finely which parts of the program are allowed to do what
12:17:19 <cloudhead> by passing different dictionaries
12:17:21 <Cale> right
12:17:48 <Cale> But if we don't do that, let's just stick with one dictionary, and move in another direction
12:17:58 <Cale> It might get a little tedious to pass this dictionary around everywhere
12:18:15 <Cale> So what we might do is to define a monad which does this for us
12:18:58 <Cale> newtype Game a = G { runGame :: forall m. Monad m => GameOperations m -> m a }
12:19:30 <Cale> The monad instance for this is pretty easy to write.
12:19:55 <Cale> If we were to go one step further, and abstract over the GameOperations type, we'd end up with: http://hackage.haskell.org/package/free-vl-0.1.4/docs/Control-Monad-Free-VanLaarhoven.html
12:19:59 <cloudhead> hmm why is `m` not on Game?
12:20:18 <EvanR> it wont work for all monads
12:20:20 <Cale> Because the function parameter to the constructor G is required to be polymorphic in m
12:20:44 <Cale> i.e. it's something which isn't allowed to know which monad we eventually choose to run the game in
12:20:56 <Cale> (even if we intend to use IO or StateT blah blah
12:20:58 <Cale> )
12:21:08 <cloudhead> ok I think I get it
12:21:23 <cloudhead> it's an existential type as I understand it?
12:21:24 <Cale> Anyway, this is usually farther than you even usually need to go
12:21:29 <cloudhead> ok
12:21:32 <Cale> Nope, it's a higher rank type
12:21:42 <Cale> You're not picking an m when you apply G
12:21:50 <Cale> You're required to be polymorphic in m
12:22:23 <cloudhead> ohhh
12:22:29 <Cale> (so that whoever calls runGame later will pick the monad)
12:22:36 <cloudhead> gotcha
12:23:18 <Cale> But yeah, start by trying to figure out a really nice set of operations for manipulating the parts of the configuration and game state
12:23:35 <Cale> Finer grained things than just set/get the whole thing
12:23:54 <Cale> Maybe you can even enforce that you won't land in certain inappropriate states somehow.
12:24:10 <EvanR> heh indexed monads?
12:24:22 <Cale> I wasn't even thinking that far along :)
12:24:46 <Cale> Just that by carefully choosing your operations, you can prevent incorrect things from happening.
12:24:53 <cloudhead> sure
12:24:55 <Cale> (some of them anyway)
12:25:53 <cloudhead> so how does this translate to isolating effects
12:26:23 <cloudhead> because so far the `m` is shared amongst all functions
12:26:36 <hexagoxel> Cale: but you would need to also (trivially) implement `getConfigG :: Game Config` etc., or is there some way around that boilerplate?
12:26:51 <Cale> Well, if your functions are polymorphic in the choice of m, then the only effects you're allowed are the ones you pass in.
12:27:19 <cloudhead> oh I see
12:27:34 <EvanR> cloudhead: you mean restricting a function to a slice of Game ?
12:27:34 <cloudhead> but I'd have to use `runGame` for each of them?
12:27:40 <cloudhead> EvanR: yes
12:27:53 <EvanR> interesting idea, you wouldnt be doing that with transformers usually
12:28:00 <cloudhead> ie: this function doens't do graphics, only config stuff
12:28:12 <Cale> hexagoxel: Yeah, kinda. (G getConfig) will be a valid action as it stands, but that's not terribly nice, you probably want to actually do the wrapping if you're going to take that last step.
12:28:16 <EvanR> if you want that fine grained then just passing dictionaries around might be easiest
12:28:34 <EvanR> and really, its pretty easy
12:28:46 <EvanR> this function uses the database, pass in the database connection
12:28:47 <Cale> Yeah, usually I just stop at the "passing dictionaries" bit.
12:30:14 <cloudhead> hmm but that means extra arguments to all functions
12:30:34 <EvanR> cloudhead: basically you dont have to restrict a blob if you dont mush them together in the first place
12:30:53 <EvanR> imagine the type sigs if you figure out how to do this transformer restriction ;)
12:31:07 <Cale> cloudhead: Having those extra arguments for a while is good -- it helps you to see explicitly what the dependencies are, and then once you understand your situation better, you can invent fancier wrapper monads like the Game thing I defined.
12:31:14 <cloudhead> EvanR: the type sigs are great though
12:31:29 <EvanR> it can easily get out of hand
12:31:38 <EvanR> especially since haskell doesnt have dependent types
12:31:46 <cloudhead> (MonadGame m, MonadEngine m) => Arg1 -> Arg2 -> m ()
12:31:56 <dinnu93> :t foldl
12:31:58 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:31:59 <EvanR> there will only be one m normally
12:32:09 <EvanR> so the MonadEngine will not help
12:32:12 <dinnu93> :t Transducer
12:32:14 <lambdabot> Not in scope: data constructor ‘Transducer’
12:32:15 <cloudhead> ?
12:32:20 <Cale> cloudhead: and yeah, of course, this is very similar in nature to just having type classes on an arbitrary monad m, instead of explicit dictionary passing
12:32:23 <EvanR> m = your m monad
12:32:24 <cloudhead> what do you mean only one m?
12:32:32 <EvanR> your app monad
12:32:33 <dinnu93> :t foldl . foldl . foldl
12:32:34 <lambdabot> (Foldable t, Foldable t1, Foldable t2) => (b -> a -> b) -> b -> t (t1 (t2 a)) -> b
12:32:47 <cloudhead> EvanR: there is only one `m`, but it has two constraints
12:32:47 <dinnu93> foldl
12:32:51 <dinnu93> :t foldl
12:32:52 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:33:15 <Cale> cloudhead: But with the explicit dictionaries, you have what is sometimes a slight advantage of being able to implement the whole thing in terms of IO with low overhead compared to all the layers of monad transformer machinery.
12:33:25 <cloudhead> Cale: but does this work with typeclasses?
12:33:43 <EvanR> cloudhead: true... so its equivalent to cale's plan, just makes passing implicit (and less flexible)
12:33:43 <Cale> cloudhead: It can, though you can't typically implement type class operations in terms of an IORef
12:34:08 <Cale> cloudhead: But you could implement them in terms of StateT's operations or whatever.
12:34:09 <cloudhead> EvanR: yeah exactly
12:34:31 <Cale> cloudhead: The point I'm trying to make though is that you should be a bit independent of how your monad is actually implemented
12:34:57 <EvanR> cloudhead: theres another issue here though, if you look at the docs for many libs, they will have a pile of constraints on each function. and its not as easy to figure out what these constraints mean in the docs
12:34:59 <Cale> There's a partition between the external interface you're providing, and how the sausage is actually made.
12:35:43 <EvanR> cloudhead: and in the extreme case of coolAPIEntry :: (19 constraints) => x, this really isnt very nice anymore
12:36:06 <EvanR> we left functional programming and are now in a twilight zone... logic programming?
12:36:16 <Cale> If the StateT GameState (ReaderT Config ...) shenanigans are leaking out into your whole application and you have to care about how many times you're lifting things everywhere, it just becomes a total mess in short order.
12:36:17 <cloudhead> EvanR: yeah true, but it can be cluttered also by having to thread around 19 vars into functions :)
12:36:31 <EvanR> it wouldnt be nearly as complex with params
12:36:51 <EvanR> because passing params is more flexible, you can do grouping, and factoring out of code
12:36:52 <cloudhead> Cale: well I'm not having to do any explicit lifting, thanks to the mtl
12:36:58 <Cale> cloudhead: Note that when you ReaderT transform IO, say, sure, you don't have to explicitly pass that parameter, but now you have to liftIO everywhere.
12:37:11 <Cale> cloudhead: and it's not like it's made your type signatures any less complicated
12:37:16 <EvanR> cloudhead: you would be putting runSubMonad everywhere though
12:37:34 <Cale> So there are tradeoffs
12:37:39 <EvanR> or have wrappers to munge the environments to get that to work
12:38:52 <Cale> Often, I think it's better to start out just passing parameters for a long while until things sort of stabilise and you have a clear picture of which parts of the application need what things, and then you can design better types for things.
12:39:02 <EvanR> runDifferentThing :: (Monad m, Powers m, Monad n, Dull n) => m a -> n a
12:39:16 <cloudhead> Cale: yeah, that's probably a good approach
12:39:21 <EvanR> the total amount of code is ballooning at this point
12:39:34 <Cale> and don't forget, if you're passing the same 19 parameters to everything, you can always bundle those up into record types
12:40:14 <AleXoundOS> Hi. Is it possible to use stack offline? For example, download all packages for lts-6.7, so that stack will read them from hard drive instead of downloading.
12:40:16 <puregreen> what's the easiest way to run some threads and wait until all of them die?
12:40:20 <cloudhead> yeah, but the point is that you're composing them, in reality you probably wouldn't have more than 4 or 5
12:40:27 <EvanR> puregreen: async
12:40:53 <Cale> cloudhead: You should never have any more parameters to pass than you would have type class constraints :)
12:41:18 <cloudhead> yeah, that's my point I guess
12:41:20 <Cale> (they're actually the same thing anyway)
12:41:30 <EvanR> but you cant put constraints into a record
12:41:31 <cloudhead> you don't want to bundle them usually, because then you're defeating the purpose of having them separate
12:41:45 <Cale> EvanR: heh, you can make type synonyms for them though :)
12:41:49 <EvanR> ah right
12:42:01 <Cale> In newer GHCs this works:
12:42:13 <EvanR> ill just retreat back to "19 constraints on each thing, all of which arent well documented or exemplified"
12:42:20 <EvanR> sucks
12:42:24 <cloudhead> I agree
12:42:27 <Cale> type MonadAcceptable m = (MonadFoo m, MonadBar m, MonadQuux m)
12:42:34 <cloudhead> but no one's talking about writing bad code intentionally here 
12:42:57 <puregreen> EvanR: can you help me with the specific function? should I do something like “void $ a `concurrently` b `concurrently` c ...”, or is there an easier way?
12:42:59 <EvanR> im warning against real life libraries that use type classes for parameter passing
12:43:36 <EvanR> puregreen: well, if you spawn N threads and get their n handles, then mapM await on the list will do it
12:43:50 <EvanR> its just an easier way than using a bunch of MVars yourself
12:43:53 <Philonous> In older GHCs you can still say class (MonadFoo m, MonadBar m, MonadQuux m) => MonadAcceptable m, instance (MonadFoo m, MonadBar m, MonadQuux m) => MonacAcceptable m where
12:44:14 <Cale> cloudhead: I think we have this problem at present that in order to teach someone Haskell, you sort of have to teach them about monad transformers, because they're a technique which is used out in the wild, but if I had my way, I might avoid teaching people about monad transformers for as long as possible. :)
12:44:30 <Cale> Since they're like the single most abused technique in Haskell
12:44:42 <sm> that is a bit of a problem
12:44:43 <monochrom> I don't actually see a real difference between passing n parameters and stating n class constraints. classes and parameters can be equally undocumented. classes and parameters take up the same amount of horizontal space in types.
12:44:43 <cloudhead> Cale: right, I'm still kind of torn on whether the record passing solution really is better
12:45:19 <cloudhead> yes ^
12:45:21 <EvanR> monochrom: its worse. when you accept a data type, you can look at the type and then look at what uses or produces this type in the docs
12:45:28 <marrenarre> Is there a more elegant way to write "concat (zipWith f xs ys)"?
12:45:40 <Cale> cloudhead: Mostly I'm just providing you with that to try to suggest that the space of possible designs is larger than what you can get by applying a bunch of monad transformers.
12:45:44 <EvanR> but when its constraints, you have the class, and a list of instances, but not what the instances do
12:46:01 <cloudhead> Cale: yeah, I appreciate that
12:46:09 <Cale> cloudhead: and to clarify that monad transformers shouldn't be a substitute for actually thinking about the design of the API
12:46:24 <cloudhead> Cale: you would wrap all the get/put stuff
12:46:31 <Cale> right!
12:46:41 <cloudhead> I think I'm going to start with that
12:46:55 <cloudhead> because I have the mtl solution working pretty smoothly
12:46:56 <EvanR> and woe be to you if you arent supposed to implement the instances yourself
12:47:01 <EvanR> if you are*
12:47:11 <Cale> cloudhead: and maybe put your transformed monad into a newtype
12:47:15 <cloudhead> but it feels very rigid indeed
12:47:19 <cloudhead> yeah it is
12:47:36 <cloudhead> newtype Game a = Game (ReaderT GameConfig (StateT GameState (EngineT TileType IO)) a)
12:47:39 <Cale> yeah
12:48:28 <cloudhead> the annoying thing is having to change multiple instances every time I add a function to the engine type
12:48:41 <cloudhead> just to lift them through the stack
12:49:00 <Cale> Yeah, you should stick that definition into its own module which doesn't export the Game data constructor
12:49:00 <cloudhead> ie: instance MonadEngine k m => MonadEngine k (StateT s m) where
12:49:31 <Cale> and then implement the operations of your Game monad, maybe requiring some lifting and whatnot
12:49:44 <cloudhead> yeah that's already done, the module just exports runGame
12:49:46 <Cale> but it limits the need to care about how many lifts to just that one module
12:50:28 <cloudhead> exactly
12:51:08 <Cale> and yeah, those lifting instances are kind of why the mtl approach doesn't always scale terribly well
12:51:22 <Cale> Well, usually they're not *too* horrible
12:51:52 <Cale> But theoretically, you need about O(n*m) instances for n transformers and m classes
12:52:06 <EvanR> i have another theory for why transformers are so popular and misused... because they are complicated and people a more comfortable with complexity (until trained to be comfortable with extreme simple stuff)
12:52:10 <cloudhead> yeah that's pretty much it
12:52:20 <cloudhead> it just feels like work I shouldn't have to do
12:52:34 <cloudhead> and it's only acceptable because I'm limiting myself to 3 classes
12:52:35 <EvanR> but theres an order of magnitude difference in normal haskell code and all the support you write to support transformers
12:52:41 <dmj`> tagging monad transformers is a lot more convenient imo
12:52:52 <EvanR> tagging?
12:52:57 <dmj`> http://blog.sigfpe.com/2010/02/tagging-monad-transformer-layers.html
12:53:41 <EvanR> it sort of looks like this blog post is recommending writing normal code directly with transformers
12:53:44 * hackagebot hspec-stack-rerun 0.1.0.0 - Simple project template from stack  https://hackage.haskell.org/package/hspec-stack-rerun-0.1.0.0 (MarkWotton)
12:54:07 <cloudhead> yeah :o
12:54:09 <dmj`> EvanR: sort of
12:54:11 <dmj`> https://int-index.github.io/ether/
12:54:16 <EvanR> and using tags to specify which ... something you mean
12:54:22 <cloudhead> I wouldn't use transformers if it weren't for the mtl
12:54:38 <EvanR> so yeah, complexity
12:54:40 <dmj`> there is a lot of instance ambiguity w/o tagging w/ mtl
12:57:30 <cloudhead> so it's mainly to handle cases with multiple of the same typeclass
12:58:09 <EvanR> you could have many StateTs floating around your "stack"
12:58:18 <cloudhead> I've just used wrappers for that 
12:58:43 <EvanR> the tagging is a surrogate for being able to just name the levels
12:58:54 <EvanR> which you can do in some systems
13:00:41 <cloudhead> right
13:01:40 <jp_rider1> hi. Has anyone used client side authentication with http-client-tls before? 
13:05:18 <glguy> jp_rider1: Is that the question you're interested in?
13:08:45 * hackagebot hspec-stack-rerun 0.1.0.1 - Simple project template from stack  https://hackage.haskell.org/package/hspec-stack-rerun-0.1.0.1 (MarkWotton)
13:10:04 <jp_rider1> yes. I'm trying to add https with client authentication to a library, but I don't see any straightforward way to do so from the docs
13:10:38 <glguy> jp_rider1: OK, because it's not important to have used the http-client-tls package before to know how to do that:
13:10:56 <glguy> My IRC client uses the tls package (which is what http-client-tls also uses). I load client certificates like this https://github.com/glguy/irc-core/blob/master/driver/Connection.hs#L100
13:12:32 <glguy> Also the documentation is online now, if you were looking for it: http://hackage.haskell.org/package/http-client-tls-0.3.0/docs/Network-HTTP-Client-TLS.html
13:16:48 <Arguggi> I'm trying to build the pem package with cabal (https://hackage.haskell.org/package/pem) but I'm getting this error:  cannot satisfy -package-id mtl-2.2.1-6qsR1PHUy5lL47Hpoa4jCM . Can any one else build it?
13:17:23 <synergistics> Do you have to manually add to your dependency list when installing packages with stack?
13:17:57 <geekosaur> that generally indicates a problem with your installation, specifically that some package is referencing a no-longer-installed version of mtl
13:18:19 <geekosaur> "ghc-pkg check" may indicate what's missing/broken
13:18:20 <jp_rider1> ok, so it looks like I need to use the tls package directly? that's somewhat disappointing since library currently uses http-client. I guess I'll need to rewrite things to just use tls
13:18:23 <geekosaur> (should indicate)
13:18:33 <synergistics> geekosaur: Ok, I'll check that now
13:18:37 <glguy> jp_rider1: No, you'll be using the tls library to construct a TLSSettings value
13:18:46 <glguy> jp_rider1: You'll be using http-client-tls to do the rest
13:19:11 <glguy> synergistics: Have you been "force-reinstalling" packages?
13:19:55 <cocreature> synergistics: add it where? you need to add it to your cabal file and then you need to add packages that are not in stackage to extra-deps in your stack.yaml, for the latter stack outputs the missing lines if you try to run stack build
13:20:21 <Arguggi> geekosaur, thanks! ghc-pkg check seems to work
13:20:42 <kqr> is there a way to combine Sources in conduit such that Source m a -> Source m b -> Source m (Either a b)
13:20:46 <geekosaur> hm, if it doesn't report broken packages then something else is wrong
13:21:07 <synergistics> cocreature: Yea, but when I install a package with stack, I have to then add it to my .cabal file as a dependency myself. I was wondering if that meant I was doing something wrong
13:21:12 <glguy> Arguggi: You might need to rerun "cabal configure" if your package database has changed since the last time
13:21:33 <Arguggi> It said "WARNING: cache is out of date: /usr/lib/ghc-8.0.1/package.conf.d/package.cache ghc will see an old view of this package db. Use 'ghc-pkg recache' to fix.", So I ran ghc-pkg recache and now it seems to work
13:21:48 <synergistics> geekosaur: I'm getting a warning that mtl.haddock doesn't exist
13:22:06 <jp_rider1> glguy: ah ok. I missed the `TLSSettings` constructor. i'll give it a try. thanks!
13:22:17 <geekosaur> that one isn't relevant (it's documentation, you get whined at if you didnt build it but local doc building is disabled by default)
13:22:30 <Arguggi> (this was also breaking my stack builds :/ )
13:22:44 <dedgrant> EvanR: "the tagging is a surrogate for being able to just name the levels" <- I think this is a clue. Clumsy syntax is highly obfuscating.
13:23:01 <geekosaur> ...something edited your global package database incorrectly? :/ weird
13:23:13 <gibbers> hey, is there a good list of practice projects that I could use to get better at haskell? I'm hoping to someday write some distributed server stuff with it but all I've done so far is read learn you a haskell
13:23:45 * hackagebot varying 0.5.0.3 - FRP through value streams and monadic splines.  https://hackage.haskell.org/package/varying-0.5.0.3 (SchellScivally)
13:23:53 <zomg> gibbers: why not try to write a basic 1 to 1 socket client/server :)
13:24:01 <zomg> sounds like a good first step towards distributed services
13:24:14 <Arguggi> This has happened a couple of times before, and usually it's just after I change the nightly version in stack.yaml and then rebuild.
13:24:39 <gibbers> zomg: that might be a bit over my skill level, haha
13:24:59 <dmwit> gibbers: There's a tutorial on writing an IRC bot that you might find interesting.
13:24:59 <zomg> won't know til you try it :)
13:25:26 <dmwit> https://wiki.haskell.org/Roll_your_own_IRC_bot
13:25:51 <runeks> How do I ignore 404 and rethrow all other errors with a function like this https://hackage.haskell.org/package/http-client-0.4.27/docs/Network-HTTP-Client.html#v:checkStatus ? I've got the ignore 404 part down...
13:29:31 <gibbers> the main reason I want to learn haskell is I have a python project that I maintain myself that is getting hard to manage because of all the state that is maintained all over the place
13:29:40 <runeks> I can construct a HttpException from the parameters, but I need a SomeException...
13:30:15 <runeks> gibbers: That's exactly why I learned Haskell
13:30:27 <dmwit> gibbers: In that case, I can strongly recommend a stripped-down version of your Python project as a fantastic practice project for Haskell.
13:30:30 <runeks> Too much Python state
13:30:32 <gibbers> the only thing holding it together is a handful of unit tests
13:30:51 <gibbers> runeks: does haskell help with that?
13:31:10 <zomg> Haskell forces you to think more about how you handle state... which may help with that problem :)
13:31:17 <gibbers> I guess I'm asking in #haskell so the answer is probably yes, but I'm curious how lol
13:31:36 <EvanR> the python state is ruled by the python philsopher king
13:31:44 <runeks> gibbers: Enormously. State is hard to accumulate in Haskell. It's all over the place in Python
13:32:10 <dmwit> Bad software engineering is possible in any language.
13:32:14 <dmwit> Including Haskell.
13:32:23 <Denommus> runeks: what do you mean by "accumulate"?
13:32:46 <dmwit> That said, I think there's a lot to say about the Haskell culture -- which extends into the design of its library APIs -- that encourages good software engineering.
13:33:09 <runeks> Denommus: I mean the practice of using variables in most languages comprises accumulating state, while in Haskell that doesn't happen (it's just an alias)
13:33:12 <kqr> new question, forget the old one: is it possible to do a "non-blocking await" with conduit?
13:33:30 <runeks> Denommus: By writing data into variables
13:33:39 <runeks> and reading them back (if they are there) at a later date
13:33:40 <Denommus> kqr: uh, if it's non-blocking it's not an await XD
13:33:58 <Denommus> runeks: ah, yes, I agree. State in Haskell is always explicit
13:34:28 <kqr> Denommus, so the use case is a conduit with a socket as a source and sink, but I want to be able to take action if the source hasn't given me a value in a while
13:34:56 <runeks> Denommus: Exactly. It's hard to forget to leave something somewhere. You leave all sorts of stuff everywhere in other languages. In Haskell it just disappears.
13:35:17 <Denommus> kqr: do you know how to program with FRP? That seems a nice use-case for it
13:35:21 * dmwit . o O ( One should design an esolang where bad software engineering is impossible. However, the compiler takes an awfully long time and a costs lot of money, because it conducts a round of code review with experienced programmers. )
13:35:53 <EvanR> nice
13:36:27 <kqr> Denommus, I guess. I was just thinking maybe I could shoehorn in conduit here to get into the habit of using conduit...
13:36:28 <shachaf> esolang discussion in #esoteric hth
13:36:35 <runeks> gibbers: It's not really Haskell that forces you to separate state and logic though; its the usage of pure functions. And the usage of pure functions is something that necessarily changes your way of coding (if it doesn't, you can't really do much with it).
13:36:46 <dmwit> th, thachaf
13:37:23 <EvanR> @quote church
13:37:23 <shachaf> Is there a programmer so experienced that they can forbid all bad software engineering?
13:37:23 <lambdabot> shapr says: Haskell separates Church and state!
13:37:39 <davidkart> yes
13:37:41 <davidkart> me
13:37:42 <shachaf> I mean, nontrivially.
13:37:43 <davidkart> of course
13:37:55 <runeks> Isn't state in Haskell really just a suspended evaluation of a pure function?
13:38:14 <dmwit> Aren't monads just monoids in the category of endofunctors?
13:38:15 <davidkart> runeks: I believe state has more to do with mutable variable.
13:38:16 <EvanR> i think you need to get more precise with that
13:38:25 <EvanR> theres several notions of state
13:38:37 <runeks> A set of events set in motion but put on hold at certain points, waiting for input
13:38:37 <geekosaur> the state monad is just a wrapper for a function s -> (a,s)
13:38:45 <EvanR> runeks: o_O thats a new one
13:39:03 <davidkart> to me a state machine is a so called mutable variable. Nothing is mutable in Haskell. So you have to think hard to design a mathematically clear program.
13:39:05 <EvanR> thats more like a dialog, which is a free monad
13:39:22 <runeks> With state I mean opposite to logic: something that accumulates data, rather than transforms it into something else
13:39:35 <maerwald> davidkart: sure, you can have IORef, which is mutable
13:39:38 <EvanR> map vs fold?
13:39:48 <EvanR> none of this is getting at the heart of "state" though
13:39:51 <Denommus> runeks: not enforcing purity still multiplies state in the program, though
13:40:04 <runeks> EvanR: What's the heart of "state"?
13:40:14 <EvanR> exercise for the reader
13:40:21 <davidkart> i am not experienced enough with haskell to know about this. « State » in my comprehension is just some kind of object with properties a,b,c, that can have different values.
13:40:24 <yyyyy> what's the difference between the ST monad and State.Strict?
13:40:30 <runeks> The secret of state is that there is no state
13:40:32 <monochrom> what is "state" anyway?
13:40:47 <runeks> It's just a useful abstraction
13:41:06 <dmwit> yyyyy: `State` requires you to declare up front the type of the universe within which your states reside. `ST` lets you dynamically allocate refs to new kinds of state values.
13:41:11 <Denommus> state is everything that's not made explicit in the current context
13:41:27 <monochrom> glad to hear that. so you know an abstraction like this can be, and is, implemented multiple different ways
13:41:33 <EvanR> here are two kinds of state described in a gdoc: https://docs.google.com/document/d/1I0XMYPCet8C88XEbNC2jZETtOEXY8j09xNn0s3p3VM0/edit?usp=sharing
13:41:51 <Denommus> monochrom: well, yes
13:41:58 <davidkart> also bad software engineering may be forecasted at a glance I believe. You don't need to have that much experienc
13:42:04 <dmwit> yyyyy: (Or, concretely: there is `newSTRef` but no `newStateRef`.)
13:42:33 <yyyyy> dmwit: so you could get the same with State.Strict by setting the State to be Dynamic?
13:42:47 <dmwit> yyyyy: You would lose type safety.
13:42:57 <runeks> State is stuff that we want to store for use at a later date, rather than consume right now
13:42:57 <yyyyy> ah, i see
13:43:18 <davidkart> Denommus: i agree with your definition.
13:43:31 <EvanR> runeks: for what its worth, i am dumping each new version of state you generate to a file for posterity
13:43:32 <yyyyy> i don't think i had a case yet where i need to change the type of state midway
13:43:41 <yyyyy> dmwit: thanks for the explanation :)
13:43:49 <davidkart> and it agrees with runeks's one
13:43:54 <runeks> EvanR: Cool!
13:43:56 <maerwald> let's implement duck typing in haskell (Oleg?) xD
13:44:11 <davidkart> that's quite inpure ?
13:44:13 <EvanR> Denommus is describing free variables, or context dependence
13:44:27 <EvanR> which ties in with "pure" functions
13:44:27 <davidkart> Let say a trafic light is typically a state to me.
13:44:32 <geekosaur> didn't acme-php already do that >.>
13:44:39 <davidkart> it is either red, green or orange.
13:44:53 <davidkart> But usually you do this with a type class. That's much better.
13:45:02 <davidkart> no ?
13:45:18 <monochrom> sometimes it's blinking red, and sometimes it's downright black.
13:45:24 <shachaf> dmwit: What are possible monoidal structures for the category of Haskell endofunctors, other than the five I know about?
13:45:24 <EvanR> runeks: more of the story, until an obvious version of state appears, the fact that its so overloaded demands we use other more specific words for what were talking about, such as implicit context
13:45:28 <davidkart> well you can implement it I believe.
13:45:49 <monochrom> so you need an exception handler that says "how look for police direction"
13:46:19 <monochrom> and an exception handler over that that says "if no police around, behave like a stop sign"
13:46:27 <davidkart> if traficLight == Red stop else drive
13:46:28 <maerwald> I feel like we are getting silly :P
13:46:38 <EvanR> davidkart: a type consisting of three colors, this is just a data type rather than a type class
13:46:42 <dolio> shachaf: Shouldn't you know more than 5?
13:46:56 <davidkart> ha sorry not accustomed to haskell terminology. Yes, I was thinking about data types
13:47:04 <shachaf> dolio: Probably. What am I missing?
13:47:16 <dolio> What are the 5 you know?
13:47:20 <davidkart> The fact is with OO you end up with huge set of states.
13:47:35 <gibbers> is there any good async stuff in haskell? something like python's twisted. Like say you want to make a web server that can handle a bunch of tcp connections. Is there an easy way to handle many connections and things like database queries on a single thread?
13:47:36 <davidkart> And then you realize it is just bad engineering design and you go for Haskell instead.
13:47:41 <shachaf> I'm thinking of composition, pointwise product/sum, Day convolution product/sum
13:47:48 <gibbers> or is that too over my head right now and I shouldn't worry about it until I learn the language better?
13:48:09 <shachaf> gibbers: Often you would just use a lot of threads instead.
13:48:19 <EvanR> program runtime state is kind of not what youre trying to get at either, if you consider a running haskell program there are many states
13:48:22 <shachaf> Threads are a pretty good way to do concurrency.
13:48:23 <davidkart> IMHO you need to learn Haskell a new.
13:48:46 <gibbers> isn't there a performance hit once you hit some large number of threads?
13:48:59 <EvanR> thats java
13:49:05 <maerwald> we have green threads
13:49:05 <monochrom> where did you hear that from?
13:49:19 <maerwald> you may spawn 1000 green threads, please
13:49:45 <EvanR> and you dont need pooling for the sake of it, though you might need pooling for managing real world resources
13:49:54 <dolio> shachaf: Doesn't Day technically involve two different tensor products?
13:50:01 <davidkart> actually java can handle >1000 threads well I believe.
13:50:23 <EvanR> well you pool threads in java as a matter of course
13:51:00 <shachaf> dolio: I guess it does.
13:51:06 <erisco> don't async, just block
13:51:26 <gibbers> I don't want to block on something like database queries though
13:51:27 <shachaf> So maybe that makes 7.
13:51:32 <EvanR> gibbers: i think you do
13:51:42 <erisco> that is why you make more threads gibbers :)
13:51:53 <Denommus> EvanR: lexical free variables are explicit
13:51:56 <shachaf> But I vaguely remember some of the Day convolution tensor products not being very interesting. But maybe I didn't think about them enough.
13:52:09 <davidkart> :h
13:52:13 <dolio> Well, you didn't say 'interesting'.
13:52:14 <maerwald> erisco: yeah, to hell with the nodejs approach
13:52:17 <gibbers> otherwise if one user makes a request that takes a lot of time the server is down until that query is handled
13:52:30 <gibbers> erisco: yeah threads would do it :P
13:52:34 <shachaf> gibbers: Why don't you want to block on database queries, if the database is slow?
13:52:54 <shachaf> dolio: That's true.
13:53:02 <monochrom> gibbers, I think you're speaking out of a lot of convention wisdoms that are actually overthrown around here.
13:53:08 <shachaf> OK, any other tensor products than these 7?
13:53:13 <gibbers> shachaf: otherwise if one user makes a request that involves a database query that takes a significant amount of time the server cannot process any other requests until that query is done
13:53:24 <gibbers> monochrom: what do you mean?
13:53:28 <shachaf> gibbers: No, only the thread cannot process other requests.
13:53:31 <erisco> maerwald, amusingly they have "await" now so you can write procedural code with async operations… i.e. await blocks
13:53:46 <EvanR> gibbers: this is the whole point of threads, that they are multiplexed onto one computer 
13:53:51 <gibbers> shachaf: okay yeah then blocking wouldn't matter
13:54:02 <runeks> EvanR: That's sounds reasonable. But I think when most people come and ask about state, the most useful definition is to juxtapose state with logic. Where logic is transformation and state is storage. That seems fairly general to me.
13:54:04 <EvanR> javascript has taught people this is impossible
13:54:08 <monochrom> everything you have said and every refutation you're now hearing.
13:54:16 <gibbers> EvanR: okay cool, good to know. So far most of my networking experience is with twisted which juse does everything in one thread
13:54:24 <EvanR> runeks: i havent even started complaining about this usage of "logic"
13:54:40 <EvanR> well python isnt the most concurrency savvy system
13:54:59 <erisco> well, there is a distinction I am taking for granted as irrelevant here…
13:55:02 <EvanR> at least its not as bad as javascript
13:55:29 <runeks> EvanR: what is there to complain about wrt. the term "logic"?
13:55:39 <gibbers> EvanR: I believe it. That's part of the reason why I want to learn how haskell does concurrency since I'd like to make programs that you can scale by throwing more CPUs at the problem
13:55:59 <EvanR> runeks: state = accumulation, logic = transformation.... hmmm.
13:56:07 <runeks> "transformation" may be a better term, but I think it gets the message across
13:56:12 <gibbers> EvanR: and I have done a bit of real multithreaded C and it's straight up hell
13:56:14 <erisco> the point is that if you write a bunch of statements in a row with "await", or Promise's "then", there is no important difference with having multiple threads and blocking
13:56:23 <EvanR> gibbers: yeah it is, i call that the "pthreads paradigm"
13:56:28 <Denommus> how do you guys think FRP fits structurally in a webdev architecture?
13:56:36 <erisco> x.then(y).then(z) … why not a new thread and then x; y; z;
13:56:39 <EvanR> gibbers: you might want to read the docs for concurrent haskell and Control.Concurrent
13:56:41 <cocreature> synergistics: you should add it to your cabal file and then it will be automatically installed (sorry had to leave for a while)
13:56:47 <Denommus> is it useable together with something like MVC? MVVM? VIPER?
13:56:56 <gibbers> EvanR: Cool, I will
13:56:58 <erisco> well, because threads are traditionally pricey… so make them not! :)
13:57:32 <erisco> schedule a bunch of threads or schedule a bunch of tasks in a thread
13:57:47 <EvanR> Denommus: can i have a MCMXCIX framework
13:57:56 <Cale> Denommus: well, we're using it to build our frontends
13:58:03 <erisco> can't say I really see the reason for the two levels of things which isn't steeped in tradition
13:58:09 <Cale> Denommus: via reflex-frp
13:58:21 <dmwit> yyyyy: Following some sketching and discussion with glguy, I'd like to revise my complaint about `State` with a `Dynamic` state.
13:58:55 <dmwit> yyyyy: You can cook up an API similar to `ST`'s with `State` and `Dynamic`; however, internally it will use some partial functions.
13:59:00 <runeks> gibbers: Your programming experience sounds a lot like mine. I wrote a multi-threaded C program (for the first time) a couple of years ago. At least 25% of the code was mutex/locking stuff. Doing that in Haskel is literally (almost) appending "forkIO $" to whatever you want spread across multiple cores (or using the "spawn" library if you want to limit
13:59:00 <runeks> concurrent threads). 
13:59:02 <davidkart> Did you heard of Elm (the language) ?
13:59:08 <davidkart> it looks a lot like haskell code
13:59:13 <davidkart> is it Haskell ?
13:59:20 <dmj`> davidkart: it's not haskell
13:59:20 <cschnei__> for those who write webapps - what's your deploy environment look like?  docker images? shell scripts to orchestrate? heroku type paas? -- Are there good tools that I should check out?
13:59:24 <dmwit> yyyyy: It is "type-safe" in the same sense `Dynamic` is: one should be able to write a proof (by hand -- not checked by the compiler) that non-type-safe things never happen.
13:59:34 <Cale> Denommus: It works really well -- you basically write code in a monad where the order of actions is basically the order in which things will occur in the DOM, but otherwise it doesn't matter so much which order the actions occur in (since you can use recursion to refer to things defined later)
13:59:36 <dmj`> davidkart: but definitely inspired by haskell
13:59:57 <dmwit> yyyyy: And, with careful API design, one should be able to show that the partiality never happens, either; so, again, the problem here is that things aren't checked by the compiler, not that things go wrong.
14:00:09 <davidkart> Well. Why ppl won't stick with a simple language and write frameworks with it ?
14:00:10 <dolio> shachaf: Is there something like Day convolution, but an end instead of a coend?
14:00:19 <Cale> Denommus: and the widgets produce Events and Dynamics and such that can be used to determine what you're displaying, and what requests are made to the backend and so on.
14:00:22 <gibbers> aah okay I found some info on user threads which answers most of my questions
14:00:42 <dmwit> yyyyy: There will also be a `Typeable` constraint on things stored in ref cells, but that should be a small burden.
14:00:43 <maerwald> davidkart: do you like typeclasses?
14:00:55 <Cale> (widgets may, but don't need to insert things into the DOM, some widgets just do interaction via a websocket or XMLHttpRequests or things like that)
14:00:56 <shachaf> dolio: I don't know. Sounds promising, since people do convolution with all sorts of operators.
14:01:02 <Denommus> Cale: I know how well reflex-frp works, and I really like it
14:01:03 <davidkart> yes pretty much
14:01:10 <maerwald> davidkart: ok, elm does not have them
14:01:10 <davidkart> I like them so much
14:01:14 <EvanR> gibbers: well, the other big thing to know is MVars. this is a way saner synchronization thing than mutices and condition variables
14:01:29 <Denommus> Cale: but my question is more about how it fits together structurally in an overall design
14:01:34 <Cale> Denommus: Eventually we hope to have a better story involving reflex on the backend
14:01:44 <shachaf> dolio: Though I've never seen it with a big pi product.
14:01:47 <davidkart> they are cool
14:01:51 <Cale> So it'll basically take over the architecture of everything :)
14:02:13 <davidkart> they are like java interfaces
14:02:22 <erisco> gibbers, they are working backwards from having one thread, which is why they're scheduling multiple tasks in one thread
14:02:25 <Denommus> Cale: yeah, I wonder how a FRP+continuation-based web framework would work
14:02:29 <davidkart> or maybe java interfaces are like typeclasses
14:02:55 <Denommus> Cale: I think the nearest thing we have nowadays is ocsigen, which is lacking in some fronts
14:03:12 <davidkart> (not sure which way it goes :p)
14:03:18 <Cale> Continuation based webservers are more important when you're not designing the thing to be a single page application.
14:03:37 <EvanR> davidkart: at some point when things get confusing enough... i think the best "final analysis" of type classes is the video "type classes vs the world"
14:04:22 <EvanR> which compares them to java, scala and ML
14:04:24 <Cale> But with the way things are in our setup, it would be really nice to have e.g. a way to make a Dynamic query to the database, and get back a Dynamic result, or an Event of diffs, when transactions commit that cause the results of the query to change
14:04:25 <EvanR> equivalents
14:04:26 <erisco> gibbers, there is also a distinction from OS threads and application threads, and even on the application side not all threads are born equal
14:05:01 <Cale> Denommus: and then use that to indicate that we want to send the client an update on its websocket
14:05:31 <sclv> @tell byorgey https://www.reddit.com/r/haskell/comments/4spdxs/help_combinatorics_species_and_hypergraphs/
14:05:32 <lambdabot> Consider it noted.
14:05:35 <yyyyy> cschnei__: i use supervisord to launch services. they're just binaries copied from the build machine.
14:05:52 <maerwald> davidkart: what I like about elm is that they seem to care about KISS too, unlike haskell (where most of the community cares about correctness, types and strictness only). But in the end, it's slightly too limited.
14:06:05 <Denommus> Cale: I don't know whether I agree with your statement
14:06:24 <yyyyy> dmwit: seems like a lot of trouble just to prove it can be done. maybe it's better to just use ST if types need to change
14:06:31 <yyyyy> right?
14:06:37 <cschnei__> yyyyy: so a CI system / build machine that verifies the build, makes an artifact, then pushes the artifact, and restarts? Do you front it with apache or nginx or similar? And is there an easier way than building it all myself (capistrano type tool that automates parts?)
14:06:38 <davidkart> maerwald: well, apparently they are writing good apps 
14:06:49 <Denommus> Cale: continuation-based development makes communication between front-end and backend more transparent, and can be abstracted as Behaviors/Dynamics/signals/whatever you call them
14:07:16 <maerwald> davidkart: that might be, I'd still prefer purescript over elm any day. They also go somewhat the KISS way, but don't cripple the language like elm.
14:07:41 <Cale> Well, I dunno, maybe we have a different ideas of what "continuation-based" means...
14:07:56 <davidkart> http://people.cs.umass.edu/~jcollard/elmtris/
14:08:39 <Denommus> Cale: I mean, at the end of the day, even with Reflex, you need to explicitly make requests to a server
14:08:51 <Cale> Yes, sure. :)
14:09:15 <yyyyy> cschnei__: simpler than that. there's no CI here. when it passes tests locally it's sent to the server and a `stack build` is issued by SSH, followed by a simple rsync and restart of service on the desired server.
14:09:15 <Denommus> Cale: with continuation-based development that might be abstracted away
14:09:19 <erisco> gibbers, a key distinction is that task schedulers are typically not preemptive, which means they will not interrupt the currently running task
14:09:27 <erisco> gibbers, whereas thread scheduling usually is preemptive
14:09:43 <Cale> Denommus: The way we currently do things is usually to have those requests going over a websocket which just stays open
14:09:43 <Denommus> Cale: in fact, ocsigen *does* that
14:09:49 <dmwit> yyyyy: Well, I think so. =)
14:10:11 <davidkart> purescript is pure haskell also . Seriously you all people look like genious to issue Haskell languages into javascript and then use that in production code.
14:10:13 <yyyyy> cschnei__: i suppose it could be put in a script, but upgrades are not that frequent. i have a streaming service running for months here. it just goes and goes without issue.
14:10:14 <Denommus> Cale: so the backend is also reactive?
14:10:18 <davidkart> That's kind of mystic to me.
14:10:18 <cschnei__> yyyyy: cool. So just some scripts to tie it all together.  I'll probably end up starting w/ that approach. Maybe some commonalities will point themselves out to extract into a tool.
14:10:23 <Cale> It's not written using FRP... yet
14:10:26 <maerwald> davidkart: purescript is not pure haskell 
14:10:27 <davidkart> maerwald: elm seems pretty readable though.
14:10:40 <cschnei__> yyyyy: I'm starting to work on a web app that'll have some very rapid iteration, so deploying being easy is nice
14:10:44 <Cale> But it's about time we started making it do so :)
14:10:56 <Denommus> Cale: what's the benefit of using this approach instead of just encapsulating a request under a Dynamic, like in Reflex.Dom.Xhr?
14:10:57 <davidkart> maerwald: it is a subset at least, I mean it is haskell right ? (a purescript program would run into ghc or not ?)
14:11:04 <maerwald> no
14:11:08 <EvanR> davidkart: well, haskell kind of accelerations the task of making programming languages, either through its features or through its culture
14:11:12 <Zekka> it's closer than Elm but it's not quite the same
14:11:33 <davidkart> So you are telling all this compilers are made with Haskell 
14:11:40 <yyyyy> cschnei__: so far we didn't have a need here. the whole two lines to send, build and restart can be put in a small script and just issued post-commit, maybe.
14:11:51 <EvanR> davidkart: including haskell's compiler ;)
14:11:55 <Denommus> Cale: and making the server see the request as synchronous?
14:11:56 <Cale> Denommus: Well, the backend needs to be able to tell the frontend that things have changed without prompting
14:12:05 <suppi> Haskell /= PureScript /= Elm
14:12:14 <maerwald> davidkart: purescript also just compiles to javascript
14:12:16 <EvanR> /= Frege
14:12:18 <davidkart> that's kind of frightening
14:12:28 <Denommus> Cale: hm, I think I can see where you're coming from now
14:12:30 <davidkart> this people are genius, isn't it ?
14:12:36 <Cale> Denommus: Stuff changes in the database, and the backend gets notified by the DB, and then we determine a patch to send to the frontend
14:12:36 <maerwald> readable javascript, not the kind ghcjs does
14:12:48 <yyyyy> cschnei__: also look out for differing versions of shared libraries. i build on the same version of the distro that runs it. otherwise you could build static with musl, but i never went that far.
14:13:13 <EvanR> davidkart: would you rather write a compiler in C or haskell... 
14:13:20 <Cale> Denommus: and that logic is getting pretty crazy in some cases, so I'd really like to have some FRP-ish library to clean it up
14:13:22 <cschnei__> yyyyy: yeah. build on ubuntu 14.04 or whatever, and run on that.  Thanks for reminding me of that - I'm sure it would have tripped me up
14:13:30 <maerwald> EvanR: like anyone cares if a compiler is fast :P
14:13:30 <Denommus> Cale: so, for instance, instead of having the front-end asking the current state every couple of seconds, the server keeps pushing a new state to the front-end, and this push is abstracted as an Event, which is then encapsulated in a Dynamic, right?
14:13:38 <Cale> yeah
14:13:46 <suppi> the people who wrote ghc/ghcjs/elm/purescript are very good, yes.
14:13:51 <Cale> That last Dynamic being on the frontend
14:13:52 <monochrom> it is true that 30 years ago the first Haskell compiler had to bootstrap from something else
14:13:52 <davidkart> I would rather not but I heard also a lot of people writing DSL with Haskell.
14:13:57 <EvanR> maerwald: well. its kind of critical
14:14:03 <Denommus> Cale: that seems perfect for two-side FRP, indeed
14:14:06 <davidkart> monochrom: and the infant was born
14:14:08 <davidkart> :)
14:14:24 <erisco> monochrom, sacrilege!
14:14:26 <maerwald> EvanR: well, ghc is awfully slow on huge modules, but no one cares
14:14:26 <davidkart> But I believe you need to know your theory to write compilers
14:14:34 <Denommus> Cale: maybe (and this is a huge maybe) even making the continuation-based model I mentioned outdated
14:14:37 <maerwald> and I don't care either
14:14:41 <EvanR> lol
14:14:57 <suppi> i heard the elm compiler is pretty fast
14:15:42 <yyyyy> suppi: that has been my experience so far.
14:15:56 <monochrom> but after a while, you want a language that's easy for traversing and even editting parse trees. and "easy" means both easy to code up and easy to see why you haven't screwed up.
14:16:10 <Denommus> Cale: what do you do if there's a drop on the connection? You have a Dynamic that somehow tries to reopen it every couple of seconds?
14:16:11 <EvanR> davidkart: next stage of the game... idris lets you define custom syntax sugar, and has special "dsl" syntactic support. combined with the dependent types, and other things it does, could turn into an even better language platform
14:16:31 <maerwald> EvanR: did you know edward doesn't like it? :(
14:16:36 <EvanR> who?
14:16:39 <monochrom> and clearly that means either ML or Haskell, 20 years ago as well as today.
14:16:42 <Denommus> Cale: also, how can the database "warn" the backend that a change happened?
14:16:52 <maerwald> EvanR: the one that ends with k
14:17:07 <EvanR> so ;)
14:17:22 <Cale> Denommus: Well, yeah, the frontend will repeatedly try to reconnect every so often
14:17:23 <sclv> he just disagrees with the choices on strictness and implicits
14:17:25 <maerwald> well, once Idris takes off, who will fix all the difficult problems?
14:17:28 <Cale> If it gets disconnected.
14:17:29 <monochrom> and clearly an ML compiler author would choose ML, and a Haskell compiler would choose Haskell. there is no point doing mutual recursion here.
14:17:34 <sclv> its not a "all good" "all bad" question with language design
14:17:48 <EvanR> maerwald: lol... "is your language edk complete"
14:17:49 <Denommus> Cale: forget the last question
14:17:50 <Cale> The way we're currently handling DB notification is just using postgres' listeners
14:17:52 <maerwald> EvanR: haha
14:18:05 <Cale> and basically sending ourselves the notification that we committed changes
14:18:09 <monochrom> well, except on April 1st, I guess.
14:18:12 <Denommus> Cale: ah, no, don't forget the last question
14:18:26 <Cale> But I'd like to have something less ghetto than that
14:18:27 <Denommus> Cale: this approach seems quite cool
14:18:39 <EvanR> monochrom: otoh a haskell written in idris might be cool
14:19:08 <EvanR> once you can write anything at all in idris
14:19:17 <Denommus> Cale: can you somehow ensure typesafety from what is sent by one side and received by the other?
14:19:47 <Cale> Denommus: Well, we're using Aeson to serialise and deserialise things and it's the same module of type declarations.
14:20:13 <Cale> Aeson's instances leave something to be desired in a bunch of cases, and I have half a mind to fork it.
14:20:14 <monochrom> Next April 1st, a joint announcement will be made by the united compiler writers of SML/NJ, OCaml, GHC, and Agda: "from now on GHC is written in OCaml, OCaml is written in Agda, Agda is written in SML/NJ, and SML/NJ is written in Haskell"
14:20:19 <maerwald> well, at least Idris has a language spec, although I'm not sure how complete that is?
14:20:38 <Cale> (Basically, I think the default instances should be identical to the TH-generated ones)
14:20:58 <Cale> Aeson foolishly encodes Maybe types using null for Nothing
14:21:04 <EvanR> maerwald: does it?
14:21:11 <Cale> and just the value with no wrapper for Just
14:21:15 <Denommus> Cale: couldn't you just use, in theory, Read and Show?
14:21:16 <maerwald> http://docs.idris-lang.org/en/latest/reference/index.html
14:21:20 <monochrom> and the Poly/ML people will also announce "we have voted to exit the SML union (PMexit)"
14:21:22 <Cale> which means that Nothing and Just Nothing encode to the same thing
14:21:26 <Cale> Yeah, we could
14:21:30 <maerwald> it says "it documents the language specification"
14:21:33 <Cale> Or even cereal/binary
14:21:49 <Cale> (though it's kind of nice to be able to read what's going over the websocket)
14:21:52 <maerwald> but it doesn't really look very formal
14:22:21 <Denommus> Cale: maybe you could use Read/Show in development and cereal/binary in production
14:22:26 <Cale> yeah
14:22:52 <Cale> It basically doesn't matter what you do at that level as long as you have some consistent way to serialise and deserialise things.
14:22:55 <Denommus> Cale: I forgot to ask, what do you use for backend?
14:23:15 <Cale> We're using Snap, but just barely
14:23:29 <Cale> We could almost get by with Scotty, but there are a few things Snap does that are nice to have
14:25:03 <Cale> I mean, as far as actually serving the application itself is concerned, it's mostly just serving a bunch of static content, and then the part which communicates via a websocket -- so all the fancy URL routing and templating stuff is mostly unused.
14:26:03 <Denommus> Cale: I'll have to reason about it to digest everything
14:26:37 <Denommus> Cale: are you guys using a *single* websocket for everything?
14:26:43 <Cale> per user, yeah
14:26:56 <Cale> You can't really use more than that and have it work reliably, apparently.
14:27:40 <davidkart> what is the goal of the Haskell programming language ?
14:27:47 <Denommus> Cale: how do you separate where each piece of data goes?
14:27:47 <davidkart> (btw, I'm as old as Haskell)
14:27:58 <Denommus> davidkart: being a pure, lazy programming language
14:28:15 <monochrom> I wonder if there is "the" goal, rather than many different ones.
14:28:17 <Cale> Denommus: We presently have this notion of "view selectors" which are values in some monoid which represent all the things which the frontend is interested in receiving information about
14:28:34 <Cale> Denommus: and those are dynamically collected up and communicated to the backend whenever they change
14:29:00 <Denommus> Cale: you basically reinvented routing with a Monoid?
14:29:08 <Cale> It's not really routing...
14:29:31 <Cale> It's like, various widgets in your UI will contribute things to the view selector, based on which data they need to interact with
14:29:34 <Denommus> Cale: well, somehow the data gets redirected to the right function (in the backend) or Dynamic (in the front-end), right?
14:30:24 <Cale> and then that information is provided to the frontend, and the same widget which contributes stuff to the view selector will also provide the widget with a cropped part of the view containing the information it's requesting
14:30:46 <Cale> (the view selector being requested is a Dynamic, as is the view coming back)
14:31:11 <Denommus> Cale: the other approach I see is: there's a single big Dynamic shared state composed of every single existing state Dynamics. Whenever something changes in the local Dynamics, this is sent to the server, and vice-versa
14:31:24 <davidkart> monochrom: at least , it has to be a motivation
14:31:28 <Cale> I'm still not 100% convinced this is the way to go, but it works
14:31:50 <Cale> The view and view selector types can get pretty complicated
14:32:11 <Cale> But yeah, that's an easier way to go
14:32:30 <teurastaja> is there a haskell AI channel?
14:32:31 <Cale> whenever you'd be okay with everything that the user is potentially allowed to see just being communicated to them
14:32:31 <Denommus> it does seem pretty complicated
14:32:41 <davidkart> I mean, look at C. The purpose was to do high level assembler. Look at C++ : it was made to get rid of tedious memory management and have inheritence. What of Java ? Probably an efficient OOP language with safety and static type checking. 
14:32:48 <Cale> it's a lot simpler just to send everything
14:33:12 <davidkart> I would think the motivation behind Haskell is probably to have a pure and formal mathematical language for programming.
14:33:15 <maerwald> davidkart: KISS is definitely not on the goal card ;)
14:33:23 <Denommus> davidkart: well, the motivation for Haskell is being a pure, lazy language
14:33:32 <Cale> davidkart: I guess originally, Haskell was constructed to unify the various research languages used by people who were studying programming languages with non-strict semantics.
14:33:33 <kadoban> davidkart: What's a mathematical language?
14:33:35 <davidkart> ok, but why exactly the lazy ?
14:33:49 <teurastaja> oh i wish i was a haskell expert but then id have to stick to the i686 or the x86_64
14:33:50 <Denommus> davidkart: historical motives
14:34:05 <dedgrant> Has work on TypeInType for GHC 8 motivated any new insight into paths toward impredicative type inference? (Really out of my league, but curious about any new rumblings.)
14:34:14 <davidkart> kadoban: I am sorry I would have mean something like « clear and self explanatory constructs »
14:34:20 <Cale> davidkart: That was part of the entire reason for Haskell to exist -- there were a bunch of smaller lazy functional programming languages, and researchers wanted to standardise a bit on one that they could explore more deeply
14:34:24 <davidkart> (a lot like in mathematics)
14:34:47 <Cale> davidkart: this was back around 1989, mind you
14:34:48 <erisco> kadoban, I'll posit pure, and immutable variables
14:35:13 <Cale> davidkart: There are lots of other reasons for Haskell to exist now.
14:35:56 <davidkart> ok,thank you. So it is research based actually (not that I deem this a bad things). Cale, well, right now, Haskell may justify himself by its various uses in the real world (I would think, yes).
14:36:04 <Cale> yeah
14:36:39 <Denommus> davidkart: Haskell is my favorite language because of how easy it allows me to reason about problems on the real world
14:36:39 <Cale> Originally, it was just "hey, this lazy evaluation stuff is pretty interesting, and we seem to be able to write more composable software with it, let's see where it goes"
14:37:01 <daey> why does this function not return the x first elements of a list? http://lpaste.net/169853
14:37:06 <Cale> davidkart: and trying to figure out if it could be implemented more efficiently and be made really practical
14:37:22 <Cale> (and I would contend that the answer is yes :)
14:37:26 <daey> looks fine to my eyes. but it errors out when i run it/ compiles fine though
14:37:51 <kadoban> daey: The first case is too specific, you're missing some. What about takeInt [1..5] 0  ?
14:38:00 <davidkart> Lazy is good because probably it helps doing algorithms simpler no ?
14:38:33 <Zekka> Most algorithms were not originally designed with lazy languages in mind
14:38:42 <kadoban> daey: You likely should have separate lines for   _ 0   and [] _
14:38:48 * hackagebot periodic 0.1.0.0 - A reliable at-least-once periodic job scheduler backed by redis.  https://hackage.haskell.org/package/periodic-0.1.0.0 (DanielPatterson)
14:38:57 <erisco> there are lots of hoity-toity languages, so I have to give it to the community for pushing the industry
14:38:57 <maerwald> I barely remember any non-trivial algorithm where laziness was particularly helpful
14:39:04 <Denommus> davidkart: whether lazyness is good or bad is debatable to this day
14:39:04 <Zekka> they can be implemented in a lazy language but there is nothing about them that particularly calls for it
14:39:32 <daey> kadoban: not sure what you mean. when the second argument is zero  the function should end. i can see that negative numbers would cause an issue but idc about that
14:40:04 <erisco> maerwald, applicative parsing relies on laziness
14:40:05 <kadoban> daey: That's not what that line is saying though. It's saying that if the second argument is 0 *and* the list is empty, the function should end.
14:40:13 <daey> oh
14:40:22 <mightybyte> Does GHC with -Wall not warn when you have a non-exhaustive pattern match like "[x] <- getArgs"?
14:40:24 <daey> i thought it means 'i dont care about the list'
14:40:29 <maerwald> erisco: I don't consider that an algorithm, but yeah
14:40:36 <Denommus> maerwald: I still don't know how to implement ArrowLoop for a signal function in a language strict by default
14:40:37 <maerwald> in the broader sense probably
14:40:46 <kadoban> daey: Nope, [] will only match an empty list.  _  is always "whatever"
14:41:10 <daey> ah ok
14:41:14 <erisco> maerwald, to me that is like saying sorting isn't an algorithm… okay, it is a class of algorithms
14:41:19 <daey> i thought i have to use [] for lists
14:41:29 <daey> perfect now it works :3
14:41:53 <monochrom> clearly, sorting is a problem, a question; not an algorithm, an answer.
14:41:54 <maerwald> erisco: yeah, I don't consider parsing very algorithmic
14:42:02 <kadoban> Many things in dynamic programming I think are easier with laziness. Though often they're not that hard without laziness either.
14:42:16 <maerwald> erisco: at least the library itself
14:42:25 <maerwald> which can be implemented in 20 LOC or so
14:42:39 <maerwald> it's rather a design pattern to me
14:44:13 <erisco> a fun thing with laziness is you can resolve non-cyclic dependencies trivially
14:44:23 <erisco> unfortunately, detecting cycles is usually the problem you're facing :P
14:44:35 <maerwald> yeah, e.g. half-edge data structure, graph stuff etc
14:45:50 <glguy> mightybyte: It doesn't warn about that because it isn't creating a partial pattern; it's desugaring to a total case
14:45:53 <erisco> is generating primes too trivial?
14:46:39 <cheater> can someone explain to me the concept of sharing in haskell?
14:47:01 <monochrom> generating primes is not trivial
14:47:15 <jle`> cheater: if you have xs = [1,2,3], and ys = 0 : xs, the [1,2,3] is only stored once
14:47:16 <EvanR> and then can someone explain observable sharing (after not instead of)
14:47:23 <cheater> ok
14:47:30 <cheater> this is done in haskell using boxing, right?
14:47:32 <jle`> cheater: it wouldn't re-allocate [1,2,3] just to have ys = 0 : [1,2,3]
14:47:40 <jle`> ys's cons would point straight to xs's [1,2,3]
14:47:44 <cheater> yes
14:48:33 <EvanR> an interesting optimization is that there is only ever one [] in the runtime system
14:48:45 <EvanR> theres a cool program to visualize sharing somewhere..
14:48:49 <erisco> laziness removes concern about evaluation order (except in performance, a different kind of problem)
14:49:10 <erisco> your program is going to do anything it will do it with lazy evaluation, but the same cannot be same of strict evaluation
14:49:47 <erisco> so strict evaluation burdens you with extra considerations, which dirties designs
14:49:50 <EvanR> erisco: can you say that in other words
14:50:08 <maurer> erisco: I'd argue that laziness does not remove concern over evaluation order, purity does that
14:50:24 <maurer> erisco: And with laziness vs strictness you're just trading of worrying about space leaks vs extra evaluation steps
14:50:53 <EvanR> lazy vs eager will also have a difference in programs freezing up or not
14:50:59 <monochrom> by saying "lazy evaluation" you have clearly committed to an order of evaluation.
14:51:12 <monochrom> to abstract away from that, you have to say "non-strict"
14:51:16 <erisco> EvanR, yes that is what I mean
14:51:29 <erisco> monochrom, EvanR I am appealing to normal order from LC
14:51:46 <cheater> is boxing specifically the only way sharing happens in haskell?
14:51:55 <monochrom> by saying "normal order" you have also clearly committed to an order of evaluation.
14:52:07 <erisco> monochrom, yes but it is the most general
14:52:09 <EvanR> actually non-strict vs strict is where the freezing up distinction really is
14:52:39 <monochrom> no, it is not the most general.
14:52:40 <erisco> so if there is a whnf then lazy evaluation will find it, whereas strict evaluation may not
14:52:44 <schell> i’m using ghc8 and have run into an infinite loop in my program (it exits with <<loop>>) - is there a way i can get a stack trace/line number or anything?
14:52:49 <erisco> monochrom, oh? please explain
14:53:05 <monochrom> denied.
14:53:12 <Denommus> Cale: I think reinventing routes is viable
14:53:16 <erisco> monochrom, why :(
14:53:19 <monochrom> cheater, what does "boxing" mean to you?
14:53:25 <EvanR> in fact if there is a normal form, then normal order will find it
14:53:28 <erisco> monochrom, I know you know this stuff
14:54:00 <schell> funny thing is, this loop doesn’t happen in ghc7.10
14:54:05 <cheater> the fact that a data structure can indirectly refer to its members
14:54:17 <erisco> EvanR, whnf is more interesting for Haskell because of lazy data structures… if you required nf for an infinite list you'd be missing out on useful programs
14:54:40 <Denommus> Cale: basically, you'd have some type (maybe like servant's url type) that is associated with a "route" and a dynamic in both the backend and frontend
14:55:06 <EvanR> NF data is still interesting and useful in haskell, and when trying to compare evaluation strategies for a language thats not like haskell
14:55:21 <Denommus> Cale: and then the websocket would be a dynamic that takes the changes together with the route
14:55:33 <Denommus> Cale: does it make sense?
14:55:37 <runeks> EvanR: With regards to logic/transformation versus state/storage, a good analogy would be a camera: a lens transforms incoming light/information into a format suitable for storage by a CCD chip, and the CCD then captures this transformed information and stores it. A logic front-end and a database back-end.
14:56:36 <erisco> maurer, as you may have just gleaned, I am just talking about reaching whnf
14:56:37 <cheater> monochrom: why were you asking?
14:56:39 <Cale> Denommus: hmmm... you mean routes with regard to representing the part of the application the user is viewing?
14:57:08 <EvanR> runeks: there is an analog in circuits, combinational logic (here yet another kind of "logic") has no loops, and implements pure functions. sequential logic has loops which causes the output to depend on the entire history of the input. i.e. the circuit becomes "stateful"
14:57:22 <EvanR> in this case stateful means that repeating the same action gives not necessarily the same results each time
14:57:36 <monochrom> because I was not sure that you know.
14:58:04 <Denommus> Cale: yes
14:58:34 <EvanR> runeks: but expanding from this example into all usages sometimes doesnt work, and if it sometimes coincides with programming folklore, some of those times its totally accidental!
14:58:37 <erisco> maurer, performance (time and space) and side effects are pain points for laziness, I agree
14:59:06 <maerwald> there was a blog where a guy argued laziness is a huge global state
14:59:21 <alercah> lol
14:59:24 <erisco> maurer, on the other hand, it is wonderful to write x *> y as the parser x followed by the parser y without having to worry about whether you've just created a strict infinite loop
14:59:28 <EvanR> think of laziness as an asynchronous immutable array
14:59:37 <EvanR> </bogus>
14:59:55 <erisco> maurer, in other languages you might have to explicitly wrap things in closures to act as thunks
15:00:14 <EvanR> stuff like that is why you need to be careful with what you think "state" is
15:00:33 <erisco> but there are languages with convenient opt-in laziness, so that is another option worth investigating
15:01:13 <erisco> maerwald, lol, well with enough work you can draw parallels with whatever you want I'm sure ;)
15:01:42 <erisco> maerwald, do you have a link?
15:01:43 <EvanR> runeks: heres an interesting version of state... imagine you have a system of differential equations where 's' is the variable. when you solve the equations youll end up with a family of solutions which are partitioned by some parameter, and you can compute the parameter from a given "initial state"
15:01:57 <monochrom> laziness can be implemented by a huge global state, and usually is. cf the heap.
15:02:22 <erisco> and if you think about it, the stack and the heap are just in the huge global state of memory
15:02:25 <EvanR> given an initial state, then you can compute "the state" at any time
15:02:33 <erisco> so really all programs are just a big global state, wow
15:02:34 <EvanR> this situation is decidedly stateless though
15:02:36 <runeks> EvanR: I guess the problem is more with the use of "logic" then. I wasn't aware of the distinction between combinatorial (non-stateful) and sequential (stateful) logic. I'm not sure what term to use other than "pure transformation", then. A prism is a pure transformation of light, while a computer chip can't really be said to be a pure transformation of
15:02:36 <runeks> electricity.
15:02:40 <mightybyte> glguy: It's desugaring to fail?
15:02:44 <monochrom> but I wonder if any rational person go about arguing that computing "is" moving electrons around.
15:03:07 <geekosaur> so is chemistry...
15:03:16 <erisco> how does it go… if you think computing only happens in silicon then you must have sand for brains!
15:03:26 <monochrom> haha
15:03:28 <daey> how can i match list length in this scenario? http://lpaste.net/169855
15:04:15 <EvanR> runeks: i was ignoring the use of "logic", not trying to tie it in with digital logic terminology. but since youre talking about physics now, that means you should consider my other example, of the physical law system and a physical state
15:04:32 <EvanR> you both have full statelessness, and cant escape that everything you talk about "is a state"
15:04:52 <geekosaur> daey: put the second one first, then the other one is diffs _ = []
15:05:09 <runeks> EvanR: Wise words
15:05:31 <runeks> There wouldn't be much to talk about if there weren't state
15:05:43 <EvanR> there is *so much else to talk about*
15:05:57 <daey> geekosaur: so i cant use more complex functions there?
15:06:32 <geekosaur> if you use a guard, you can. but it doesn't make a lot of sense in this particular case, pattern matching is sufficient
15:07:08 <geekosaur> if you must write the case that way (inefficient) then: diffs ys | length ys < 2 = []
15:07:41 <daey>  your solution works, because (x:y:ys) wont match with a list that only has 1 element? but 2elements work fine, i.e ys matches with ''?
15:08:20 <daey> or better phrased x '2' y '1' ys '[]'
15:08:28 <geekosaur> x:y:ys will match any list with 2 or more elements (with 2 elements ys will end up [])
15:08:34 <daey> for [2,1]
15:08:42 <daey> ok
15:08:49 <[Muslim]> hello
15:10:12 <fishythefish> Alternatively, diffs xs = zipWith (-) (tail xs) xs
15:12:42 <fishythefish> Or with diffs xs = zipWith (flip (-)) xs (tail xs) you can do away with the other pattern match
15:12:57 <AleXoundOS> Hi. What would you recommend for ByteString -> Double conversion (without using foreign import atof)?
15:13:23 <monochrom> there is probably something in Data.ByteString.Char8
15:14:04 <AleXoundOS> monochrom, there is readInt, but no functions for floating point conversion
15:14:05 <ggVGc> am I the only one who dislikes defining pattern matched functions as separate function bodies, and always prefer an explicit case instead?
15:14:14 <monochrom> then I don't know
15:14:29 <Koterpillar> ggVGc: I think the compiler agrees with you
15:14:29 <ggVGc> overloaded function names rub me the wrong way
15:14:30 <ggVGc> always have
15:14:34 <EvanR> AleXoundOS: https://hackage.haskell.org/package/double-conversion
15:14:44 <ggVGc> Koterpillar: what does the compiler care?
15:15:08 <Koterpillar> ggVGc: all functions get converted to a series of case statements
15:15:10 <Koterpillar> internally
15:15:19 <ggVGc> ah, yeah, obviously it's only style
15:15:33 <ggVGc> but both in erlang and haskell I really dislike reading one function as multiple definitioms
15:15:35 <monochrom> ggVGc: most of the time you are the only one. however, I am with you on the rare occasions when I have to rename a function.
15:15:59 <Koterpillar> I don't care
15:16:01 <AleXoundOS> EvanR, I see there only "to ByteString" conversions, but not "from ByteString", maybe I'm not seeing something
15:17:02 <EvanR> AleXoundOS: true...
15:17:36 <EvanR> AleXoundOS: https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Read.html
15:17:57 <EvanR> which requires a conversion to text...
15:18:47 <erisco> so how do we qualify state EvanR?
15:19:42 <EvanR> AleXoundOS: ok! double :: Parser Double is attoparsec
15:19:47 <EvanR> in attoparsec
15:20:59 <AleXoundOS> ok, I'll take a look at it
15:21:25 <EvanR> parseOnly double "3.14"
15:22:19 <erisco> EvanR, it seems as though you've suggested that any deterministic system is stateless
15:22:28 <EvanR> right
15:22:53 <EvanR> including quantum physics ;)
15:23:16 <EvanR> so state is an illusion of engineering folklore
15:23:23 <erisco> well, this meaning of state cannot be the same meaning of state as when we talk about stateful programs, such as mutable variables
15:23:40 <EvanR> maybe you missed it but there were like 10 different versions of state
15:23:57 <EvanR> a situation where we just need new words
15:24:25 <erisco> I suppose I have then
15:24:58 <EvanR> so i qualify it as a word overloaded to uselessness
15:27:17 <monochrom> no, I actually think there is only one meaning, and it is the meaning you have said. And it is puny human intuition that can't accept that it's a convenient illusion.
15:28:17 <maerwald> philosophical nonsense mostly imo
15:28:55 <monochrom> for example, what's so special about mutable variables? they're highly optimized things for sure, but you still have a deterministic algorithm.
15:29:07 <AleXoundOS> EvanR, thank you, it works, though there is no Lazy parseOnly
15:29:49 <EvanR> attoparsec does let you pass in input incrementally
15:30:13 <erisco> the narrow meaning, in context of PLs, in context of functions, is that the result is wholly determined by the formal arguments
15:30:34 <erisco> I don't think it is a useless distinction
15:31:20 <EvanR> AleXoundOS: if you are trying to go from a big block of bytes to a lazy list of doubles, you can do it by running the parser for one double over and over on the remaining input
15:31:30 <erisco> that is a rough description… it needs a more careful description
15:32:36 <EvanR> well i can fix your last definition by saying that pure functions are stateless
15:32:51 <AleXoundOS> EvanR, ok
15:32:53 <EvanR> but that doesnt explain what "state" is
15:33:05 <erisco> we're removing equivalences in our language by violating some notation of statelessness
15:33:13 * maerwald imagines a haskell channel where people get kicked for nitpicking :P
15:33:15 <maerwald> probably empty
15:33:30 <EvanR> Haskell -> Void
15:33:51 <monochrom> I don't nitpick.
15:34:22 <erisco> notion*
15:34:23 <daey> why is this functions are stateless such a big topic? isnt that true for pretty much every language? (if i want it to be)?
15:34:45 <erisco> daey, your aside is the kicker
15:34:47 <EvanR> functions that are not stateless kind of doesnt make sense if you start from certain jargon
15:35:08 <daey> erisco: not sure what you mean
15:35:11 <erisco> you may want it to be so, but once you start working with other people's libraries you run into problems
15:36:02 <kadoban> daey: In most languages you have no guarantee at all that what are called functions are stateless. They only will be my accident or if you're very careful. It makes it hard to have any real guarantees about program behavior, especially in the face of optimizations and refactorings.
15:36:28 <monochrom> erisco, your case is important in practice, but it still doesn't escape from "convenient illusion".
15:36:33 <shachaf> Haskell people exaggerate too much.
15:36:49 <erisco> monochrom, illusion in a physical sense?
15:37:01 <travism> what do you all recommend after reading lyah
15:37:12 <Koterpillar> travism: write something
15:37:17 <monochrom> in fact, once you start writing down the semantics of stateful functions, first thing you do is to add one more formal parameter, for the input state.
15:37:21 <travism> Well i have been coding bits and pieces
15:37:28 <erisco> monochrom, for example, languages with mutable variables do not benefit from eta-reduction
15:37:35 <monochrom> no, not in a physical sense, in a mental model sense.
15:37:54 <erisco> monochrom, so this distinction manifests in an abstract way
15:37:55 <EvanR> monochrom: i thought that would be it, which turns state into a subjective knowledge thing, but what if the procedure is "first, choose a random number, then..."
15:38:13 <EvanR> so non deterministic procedure
15:38:14 <daey> travism: xmonad looks like an interesting project, as it is quite small
15:38:15 <jle`> is there any way to still use 'binary' and get around that Double bug?
15:38:18 <monochrom> what is "choose a random number"? I am serious.
15:38:33 <travism> I have programming in haskell by graham hutton and the craft of functional programming 2nd edition. Would one of those suffice?
15:38:36 <daey> no idea how difficult the code is though
15:38:42 <EvanR> it means the output has many possibilities
15:38:44 <travism> daey: I have been trying to go through it slowly
15:38:58 <EvanR> depending on the choice
15:38:59 <travism> Especially StackSet.hs
15:39:07 <erisco> monochrom, uniform distribution and a bunch of other criteria… a manufactured notion of randomness
15:39:28 <EvanR> uniform choice
15:39:36 <monochrom> no, do you use a Geiger counter for the random number, or do you use a PRNG? there is a difference.
15:39:44 <EvanR> the procedure just says to pick one
15:40:17 <EvanR> from some set
15:40:27 <EvanR> finite!
15:40:48 <travism> I was reading that rwh is kind of dated now?
15:40:48 <monochrom> you cannot abstract away from my question.
15:40:58 <EvanR> i guess you can pick one and put that in the place of that statement
15:41:03 <EvanR> like xkcd
15:41:48 <glguy> travism: Have you read through the Haskell Report yet?
15:42:17 <travism> glguy: I haven't yet
15:43:14 <EvanR> yeah, i think that kind of procedure, in spirit is stateful because the result is not necessarily the same each time you do it
15:43:29 <travism> glguy: you talking about the 2010 language report?
15:43:33 <erisco> monochrom, it does seem clear to me though that you can interpret any stateful PL in a stateless PL, and vice versa, so in that sense a distinction is non-existent
15:43:36 <EvanR> but that doesnt imply there is any state
15:43:52 <glguy> travism: Yeah
15:44:08 <travism> glguy: ok cool. I shall start it now! Thanks.
15:44:14 <EvanR> erisco: well in this example youd need at least a non deterministic language
15:44:49 <erisco> but that observation doesn't suggest statelessness is the ultimate truth and more than statefulness is
15:44:55 <erisco> any more*
15:45:11 <EvanR> UltimateTruth : Prop -> Type ?
15:45:17 <lpaste> lambdafan pasted “Either trouble” at http://lpaste.net/169858
15:46:15 <EvanR> erisco: each time you describe some math object, its the same math object. so thats stateless, also its kind of besides the original point and off topic so time for coffee
15:46:19 <erisco> EvanR, well, science likes to break reality down into smaller and smaller pieces. The observation does not support either being smaller, i.e. more fundamental, then the other
15:46:28 <glguy> lambdabot: use pattern matching
15:46:33 <glguy> lambdafan: ^
15:46:47 <lambdafan> glguy ah that simple
15:47:02 <lambdafan> I thought I was going to have to make Alternative instances
15:47:27 <maerwald> erisco: there's also the opposite, science that puts pieces together
15:48:14 <travism> glguy: btw I came across your TwosGame a couple weeks ago. Is there much to be changed for it to work with base 4.9?
15:48:50 * hackagebot hw-prim 0.0.3.2 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.3.2 (haskellworks)
15:48:52 <glguy> travism: probably not, I'll look
15:49:44 <erisco> EvanR, but is that preference or necessity?
15:49:55 <travism> Cool
15:51:25 <glguy> travism: I pushed a commit for it to build on GHC 8
15:52:38 <monochrom> erisco: I now agree with you that the stateless story is no more fundamental than the stateful story. but I still like to do beta, eta, and Leibniz, so I will really like the stateless story.
15:53:31 <erisco> monochrom, true that ;)
15:54:21 <monochrom> in fact, "I can't do Leibniz to this function" is less informative than "I can do Leibniz to this function after I add back such-and-such parameters and I don't need other extra parameters"
15:54:42 <travism> Well it builds, but dislikes my terminal or something lol
15:54:51 <monochrom> "cannot do" is always less informative than "can do but after exactly what modifications?"
15:56:05 <glguy> travism: It works for me in Apple's Terminal.app and in XTerm-7.6.0(324)
15:58:48 <maerwald> works in sakura
15:59:18 <travism> hmm, using Xterm(325) on linux. Ill just play with it on my mac.
16:02:38 <EvanR> monochrom: uh what is Leibniz
16:03:23 <maerwald> https://en.wikipedia.org/wiki/Leibniz-Keks ?
16:03:35 <EvanR> ah
16:07:47 <travism> Yeah works perfect on mac. Dang, this is cool. Will be nice when I can make stuff like this. 
16:10:20 <glguy> travism: that program mostly exists as a demo in how the machines library works, but you might start by adding a feature to it
16:10:34 <glguy> modifying it would be a start toward understanding how to make your own
16:11:06 <travism> Ah yeah. I think I will work on that
16:12:28 <maerwald> looks overcomplicated
16:13:04 <maerwald> @hackage machines
16:13:04 <lambdabot> http://hackage.haskell.org/package/machines
16:13:41 <nshepperd_> leibniz equality?
16:14:14 <maerwald> oh god, and the types
16:14:15 <maerwald> no thanks
16:17:03 <EvanR> maerwald: if you think thats bad, check out my microtubes 
16:20:23 <erisco> are we having an obscurant penis measuring contest?
16:20:41 <mekeor> is it advantageous / beneficial / convenient for haskellers to use NixOS?
16:22:05 <erisco> I won't win, but here is my submissions… I just want to plug my stuff :P http://hackage.haskell.org/package/data-function-tacit-0.1.0.0/docs/Data-Function-Tacit.html
16:22:32 <EvanR> oh yeah
16:22:42 <erisco> it uses a type family so it has to at least win a participation award
16:22:56 <EvanR> does your library qualify for acme
16:23:02 <maerwald> mekeor: the nix package manager has built-in support for doing "sandbox like stuff" if you will. But most of the time, plain cabal sandboxes are enough and they work everywhere.
16:23:05 <erisco> probably :P
16:23:37 <erisco> it takes a sensible thing to the point of absurdity
16:23:56 <maerwald> and if you _really_ need more then cabal sandboxes, there is stack
16:24:05 <maerwald> not sure what you need another layer of sandboxing for
16:24:13 <Koterpillar> maerwald: your OS
16:24:21 <Koterpillar> nix package manager != nixOS
16:24:29 <maerwald> Koterpillar: I am aware of that.
16:24:30 <Koterpillar> I don't use nixOS but I might try it
16:24:36 <maerwald> and I was talking about the nix PM.
16:24:56 <Koterpillar> mekeor: I don't see a specific advantage in nixOS for Haskell users
16:24:58 <mekeor> maerwald: i see, cool
16:25:16 <maerwald> Koterpillar: also, I doubt you don't use NixOS.
16:25:29 <maerwald> nixpkgs is part of NixOS
16:25:37 <maerwald> unless you use nothing of that...
16:25:49 <Koterpillar> maerwald: I don't use nix
16:26:05 <Koterpillar> unless the Arch packages are somehow built from nix?
16:26:11 <maerwald> ah, I misread
16:27:08 <ertes> mekeor: NixOS and haskell+nix are pretty much orthogonal
16:27:27 <ertes> mekeor: whether you use NixOS is a UX/administrative decision
16:28:08 <maerwald> ertes: if you use nix, chances are high you also use NixOS (nixpkgs). I don't know of any other popular package set for nix.
16:28:29 <Squarism> what should i learn if i keep writing this : Left l -> Left l ... in order to modify a right value
16:28:36 <ertes> mekeor: NixOS and nixpkgs are not the same thing
16:28:46 <ertes> if you use nix, you probably use nixpkgs, but not necessarily NixOS
16:28:47 <maerwald> ertes: nixpkgs is part of NixOS
16:28:47 <Welkin> Squarism: fmap over the Either
16:28:53 <mekeor> ertes: i don't understand what you mean by "NixOS and haskell+nix are pretty much orthogonal"
16:28:55 <mekeor> ertes: i would have understood "nix(os) and haskellare pretty much orthogonal"
16:29:03 <Welkin> > fmap (+1) $ Right 2
16:29:05 <lambdabot>  Right 3
16:29:15 <ertes> maerwald: but you can use nix+nixpkgs on e.g. CentOS, something i do right at this moment in time
16:29:22 <maerwald> I am aware
16:29:23 <Welkin> > fmap (+1) $ Left "Error"
16:29:25 <lambdabot>  Left "Error"
16:29:27 <Squarism> Welkin, hmm.. so fmap only affects right? 
16:29:27 <maerwald> that's still using the NixOS ecosystem
16:29:46 <Welkin> Squarism: that is how the Functor instance for Either is defined
16:29:53 <Squarism> okey
16:30:01 <ertes> mekeor: in haskell development nix has a similar role to stack, just more generic
16:30:10 <Welkin> Squarism: it is helpful to look at the source for these libraries
16:30:12 <Welkin> it heped me learn a ton
16:30:16 <Welkin> helped*
16:30:21 <ertes> mekeor: i find it useful
16:30:38 <Squarism> Welkin, will do that! thanks
16:30:41 <maerwald> mekeor: it's just not worth changing the distro for, haskell/GHC works fine everywhere
16:30:42 <ertes> mekeor: NixOS is unrelated to that…  you could develop haskell with nix on other distributions
16:31:02 <maerwald> and it's also not required to use nix in order to be productive with haskell
16:31:42 <mekeor> ertes: i see. aight. thanks
16:32:03 <ertes> mekeor: one reason to use nix is to get precompiled packages (so you don't have to compile that huge framework you're using yourself), and easy compiler switching ("use GHCJS for this one", done), as well as reproducibility
16:32:25 <maerwald> there are tons of ways to achieve reproducibility :)
16:36:44 <mekeor> ertes: i actually tried nixos once and i got confused whether to install packages using nix or cabal-install... :D ~ that's the only thing i remember from that time
16:36:44 <mekeor> ertes: but yea, according to your explanations, nix definetly has some advantages for haskellers. but not too big ones. also stack is getting there, too, isn't it?
16:37:22 <mgsloan> Stack also integrates with nix or docker, so you can use those for reproducibility of the non-haskell parts of your setup
16:37:28 <maerwald> I consider it simply redundant, unless you like nix for other reasons.
16:37:54 <maerwald> use whatever you like, there are enough ways to make haskell work
16:38:32 <maerwald> mgsloan: yeah, and you can combine it with stuff like propellor, which takes care of the configuration reproducibility
16:39:33 <maerwald> which is why I find that "I can haz reproducible config" argument in nix silly. You can have that with any distro
16:40:04 <mgsloan> Well, question is how efficiently you can switch reproducible config
16:40:26 <mgsloan> (+ using multiple configs simultaneously)
16:40:28 <ertes> the reason i use nix is that it's simple:  it's a single concept that handles everything
16:40:36 <maerwald> mgsloan: pretty easy with docker
16:40:42 <maerwald> and I am sort of distro-agnostic
16:40:54 <r_rios|pc> I need help to Google the >>= operator
16:40:57 <maerwald> it's rather trivial to switch the base distro in a well-defined docker image
16:41:04 <ertes> r_rios|pc: try hoogling it
16:41:14 <erisco> trying hayooing it
16:41:42 <monochrom> why argue. do the best of both worlds: docker and nix.
16:41:42 <mgsloan> maerwald: Yeah, there are certainly many approaches, and many tradeoffs for each
16:41:59 <r_rios|pc> erisco: thx :D
16:42:15 <maerwald> monochrom: more redundancy plz :P
16:42:39 <monochrom> I considered adding virtualbox to the mix, too.
16:42:52 <maerwald> yes, I was about to say
16:43:16 <ertes> mekeor: you caused a flamewar =)
16:44:33 <mgsloan> I like the idea of nix too (dabbled a little).  There could be a lot of gain from basing stack on nix, however one of the goals is to support windows.  It'd be interesting to see if nix-on-windows is sufficiently good, but I doubt it
16:44:37 <fishythefish> Is it laziness that causes Haskell types to have CPO-based semantics rather than Set-based?
16:44:37 <maerwald> monochrom: and I hope you configure the vm via vagrant
16:44:43 <fishythefish> Or is evaluation strategy a separate issue?
16:44:47 <mekeor> oops ¯\_(ツ)_/¯
16:45:00 <ertes> lack of windows support is pretty much the only drawback of nix
16:45:17 <maerwald> mgsloan: "basing stack on nix"?
16:45:46 <nkaretnikov> ertes: what about being a programming language without much documentation?
16:46:03 <nkaretnikov> ertes: where does the manual explain how to override a package?
16:46:06 <monochrom> fishythefish: the cause is non-strictness specified in the Haskell report. it is true that laziness is a popular implementation.
16:46:14 <maerwald> it's good tools like nix are distro-agnostic and they should be. Everything else would be terrible
16:46:19 <maerwald> errr, stack
16:46:20 <fishythefish> monochrom: yeah, forgive the conflation of nonstrictness with laziness :)
16:46:32 <ertes> nkaretnikov: the nixpkgs manual does, as far as i know, but yes, i agree…  the language is terrible in many ways
16:46:35 <nkaretnikov> maerwald: the truth is that everything is terrible ;)
16:46:40 <maerwald> no
16:46:54 <nkaretnikov> maerwald: okay, what's not terrible?
16:47:14 <maerwald> "everything is <add random word>" -- Albert Einstein
16:47:17 <maerwald> oh, probably true
16:47:18 <mgsloan> maerwald: Yeah, I bet a fair amount of stack could be simplified by just using nix mechanisms.  The build result caching and such
16:47:47 <maerwald> mgsloan: well, I hope that doesn't happen
16:47:59 <maerwald> would be another reason against using stack
16:48:04 <ertes> maerwald: why?  you don't use stack anyway ;)
16:48:10 <maerwald> sure, for deployment
16:48:16 <fishythefish> monochrom: so a loose summary is that strictness forces everything to be evaluated, giving us Set-based semantics, whereas nonstrictness allows bottoms to be guarded by constructors, giving CPO semantics?
16:48:58 <maerwald> when I deploy something I want the state to be as defined as possible
16:49:09 <maerwald> so using docker + stack makes sense
16:49:39 <ertes> mgsloan: are you a stack developer by any chance?
16:53:13 <monochrom> fishythefish: function spaces are rich CPOs too, whether the language is strict or non-strict. now add "first-class functions": you can receive function parameters in addition to "basic data so basic that the CPO is flat even if you use a CPO" parameters. so you would rather go all CPOs uniformly, even if data types give you flat CPOs.
16:53:58 <mgsloan> ertes: Yes
16:54:35 <mgsloan> maerwald: When I'm developing something I also want the state to be as defined as possible :)
16:55:02 <maerwald> mgsloan: I want to test against the latest hackage state, so I am sure my dependencies are correct and not clouded by a pseudo-package manager
16:55:38 <maerwald> and cabal sandboxes do rather fine there
16:56:21 <ertes> you never test against the latest hackage state
16:56:28 <maerwald> nitpicking
16:56:47 <ertes> no, it's not
16:56:54 <fishythefish> monochrom: ah, that makes sense. I guess the Set/CPO distinction is moot if all your domains are flat?
16:58:05 <maerwald> blubb
16:58:26 <monochrom> yes
16:58:49 <fishythefish> okay, awesome
16:58:50 <fishythefish> thanks :)
16:59:21 <ertes> your "cabal update" becomes "nix-channel --update"…  you're not minute-perfectly at the latest snapshot, but very close
16:59:37 <ertes> i don't mind being off a few hours or days that much
17:00:52 <ertes> and if there were a package i'd need the bleeding edge of, i'd cabal2nix it manually…  but that has never happened
17:06:08 <fishythefish> monochrom: I'm reading something that distinguishes between data and codata, and defines `data [a] = a : [a] | []`. It says if types are sets, you get finite lists (I agree) and if types are CPOs, you get both finite and infinite lists (I disagree)
17:06:40 <fishythefish> Don't you get finite lists either way, since the type is inductive? The former is eagerly evaluated and the latter is lazily evaluated, but you don't get infinite lists
17:07:09 <monochrom> I'll answer with a tautology. if types are CPOs, you get what CPOs the types say.
17:08:54 <fishythefish> hm
17:09:24 <monochrom> saying "I have CPOs" doesn't say how tall the CPOs are.
17:10:05 <monochrom> (a flatter CPO is closer to strict data. a taller CPO is closer to nonstrict data. there are infinitely many choices.)
17:10:32 <r_rios|pc> I'm confused by operator >>=. If I do something like map (2 *) $ map (2 *) [1, 2, 3], I'll get [4, 8, 12], as expected. But, if I do map (2 *) [1, 2, 3] >>= (map (2 *)), I get a compilation error
17:10:47 <r_rios|pc> Does it mean what I think it means?
17:10:58 <Welkin> 3CPOs?
17:11:01 <Koterpillar> r_rios|pc: what do you think it means?
17:12:52 <fishythefish> That makes sense to me, but I thought regardless of choice in strictness, the least fixed point of 1 + A * X can only give you finite lists [A], not infinite ones
17:12:53 <r_rios|pc> Koterpillar: expr1 >>= expr2 will call expr1 and pass its result as an argument to expr2
17:12:53 <r_rios|pc> Which should be equivalent to expr2 (expr1)
17:12:53 <monochrom> there are two kinds of "+"s and two kinds of "*"s over CPOs. you know that?
17:12:53 <fishythefish> r_rios|pc: Not quite. What's the type of >>=?
17:12:56 <monochrom> and the two kinds correspond to strict data (e.g., (:) is strict) vs nonstrict data (e.g., (:) is nonstrict)
17:13:07 <monochrom> and it all gets a bit messy
17:13:27 <fishythefish> monochrom: Didn't know that. I've only "studied" CPOs in type theory while reading https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
17:13:34 <fishythefish> But I'm trying to learn more
17:14:16 <r_rios|pc> fishythefish: forall a b. m a -> (a -> m b) -> m b. It is a monad, I think
17:14:48 <fishythefish> r_rios|pc: The function itself isn't a monad, but it has the constraint (Monad m)
17:15:09 <fishythefish> In any case, do the types match up with your attempted use of (>>=)?
17:15:22 <r_rios|pc> No
17:15:36 <r_rios|pc> I think I was using it for the wrong purpose
17:15:40 <monochrom> >>= specialized to [] has type: [a] -> (a -> [b]) -> [b].  Now you need to do your own type inference to see why your expression is a type error.
17:15:51 <r_rios|pc> I thought it was something like F#'s |>
17:16:22 <r_rios|pc> Thanks
17:17:03 <fishythefish> r_rios|pc: I don't know much F#, but I think |> corresponds to `flip ($)`, or (&) from Data.Function
17:20:22 <fishythefish> monochrom: I've been trying to grok the data/codata distinction while keeping it mentally separate from the strict/nonstrict distinction, because I understand that those are different things.
17:20:35 <fishythefish> I was just wondering how the set/CPO distinction fits in
17:20:50 <r_rios|pc> I just wanted to do map (2 *) [1, 2, 3] |> map (2 *) instead of map (2 *) $ map (2 *) [1, 2, 3], because the former gives a clearer idea of data transformation -- as in, I'm getting an array, mapping it, then mapping it again
17:21:47 <monochrom> for data vs codata, you do least fixed point vs greatest fixed point, and IIRC both in a set theory setting.
17:21:58 <r_rios|pc> (I hope I made myself clear)
17:22:19 <fishythefish> Right, okay
17:22:21 <monochrom> but Haskell doesn't do that. Haskell does least fixed point with CPO and a lot of nonstrictness
17:22:39 <fishythefish> Right
17:22:46 <fishythefish> Perhaps I should work in a different language for understanding this stuff
17:23:14 <r_rios|pc> What I'm asking for is basically just syntactic sugar
17:23:15 <fishythefish> > map (2 *) [1, 2, 3] & map (2 *) -- r_rios|pc 
17:23:16 <lambdabot>  [4,8,12]
17:23:34 <r_rios|pc> Ah! That seems like what I want
17:23:40 <ertes> r_rios|pc: (>>=) for lists is concatMap with flipped arguments…  the "list monad" is the "list comprehension language"
17:23:44 <fishythefish> That's the (&) operator from Data.Function I mentioned
17:23:52 <erisco> > (map (2 *) . map (2 *)) [1, 2, 3]
17:23:54 <lambdabot>  [4,8,12]
17:25:07 <r_rios|pc> erisco: Of course, that seems like the cleanest option
17:25:30 <jle`> r_rios|pc: note that map f . map g is map (f . g)
17:25:58 <jle`> but i'm sure that what you have shown us is just a simplified example :)
17:26:31 <r_rios|pc> Of course
17:26:45 <r_rios|pc> I'll pastebin the full example shortly
17:27:22 <erisco> jle`, well along those lines, may as well map (4 *) ;)
17:30:41 <erisco> my guess is there is a rewrite rule for that as well
17:31:16 <r_rios|pc> I'm failing to write my function properly with dot composition
17:31:18 <monochrom> no, I don't think we have arithmetic rewrite rules.
17:31:28 <erisco> I mean for the functor equivalence
17:31:42 <monochrom> then don't write with dot composition first. do it later, not earlier.
17:32:04 <erisco> though I guess this is map, not fmap
17:32:27 <r_rios|pc> monochrom: Yeah, it worked without dot composition, so I must be doing something wrong
17:32:29 <r_rios|pc> Just a sec
17:34:32 <r_rios|pc> No dot composition, compiles and runs fine: http://lpaste.net/169868
17:35:29 <Zekka> r_rios|pc: My prediction would be that this function will be harder to understand, with your current argument order, if you write it with dot composition
17:35:42 <r_rios|pc> With dot composition, fails:"http://lpaste.net/169869
17:36:11 <monochrom> you reversed the order
17:36:26 <Zekka> I don't know if dot composition would be winning you anything if you hadn't reversed the order, mind
17:36:28 <r_rios|pc> Isn't that the idea?
17:36:29 <monochrom> f (g x) = (f . g) x   not (g . f) x
17:36:32 <jle`> f (g (h x)) is (f . g . h) x
17:36:34 <fishythefish> And you'll need a $ to separate currentUserTags at the end
17:36:35 <r_rios|pc> Ah
17:36:45 <Zekka> he's used parens for that, fishythefish 
17:36:56 <fishythefish> Zekka: Oh, derp
17:37:10 <Zekka> I don't think anything is wrong with your original version
17:37:12 <jle`> @src (.)
17:37:12 <lambdabot> (f . g) x = f (g x)
17:37:36 <r_rios|pc> Sorry, I think I wasn't paying attention :s
17:37:42 <fishythefish> By the way, `Set.map (\(upVotes, downVotes) -> upVotes - downVotes)` can be shortened to `Set.map (-)`
17:37:56 <fishythefish> Whoops, missed a `curry` in there
17:37:57 <Zekka> fishythefish: close, you could use (uncurry (-))
17:38:06 <r_rios|pc> I want to reverse the order of the calls
17:38:07 <Zekka> but I still don't think that's clearer
17:38:25 <jle`> r_rios|pc: having functions being applied in normal order is more idiomatic haskell, anyway
17:38:26 <fishythefish> r_rios|pc: You want function composition to go in the other order?
17:38:38 <r_rios|pc> jle`: Oh, OK
17:38:47 <Zekka> it's common for people to define x & f = f x
17:38:54 <Zekka> I don't know if this is in the stdlib right offhand
17:38:54 <fishythefish> Zekka: It's in Data.Function
17:39:02 <fishythefish> See above
17:39:05 <r_rios|pc> So, & it is
17:39:17 <jle`> reverse function composition is strongly against the normal haskell style, except for in certain contexts
17:39:21 <erisco> it goes right-to-left, learn to accept this and your Haskell life will be easier
17:39:37 <fishythefish> r_rios|pc: If you'd like, but function composition is more common in Haskell than pipelining
17:39:46 <jle`> r_rios|pc: i recommend getting used to common haskell idioms if you want to write haskell other people can read
17:39:48 <erisco> only because all the code has been written this way
17:39:51 <jle`> and also learn how to read haskell code
17:39:52 <Zekka> Well, a lot of code looks like "I have x, and want to see what x looks like after doing f, g, and h to it"
17:40:03 <fishythefish> erisco: Yes, but also to parallel mathematical syntax
17:40:16 <fishythefish> Not saying they couldn't have gone the other way, but there is reason for it
17:40:17 <Zekka> h . g . f $ x is in reverse order from the series of steps as you thought of them
17:40:23 <Zekka> just because math did something doesn't mean that thing is right
17:40:34 <jle`> it's not just math
17:40:37 <fishythefish> ^
17:40:42 <jle`> it's the same in any programming language, too
17:40:48 <jle`> foo(bar(baz(x)))
17:41:01 <erisco> Zekka, reading left-to-right is also a learned convention, you know this yes?
17:41:13 <Zekka> erisco: Wow, we're all speaking English, a language written left-to-right
17:41:15 <jle`> it doesn't come from math, it comes from just normal function application
17:41:24 <shachaf> Not in Forth.
17:41:26 <erisco> when I think of these steps I think of them right-to-left in function composition notation
17:41:40 * mjrosenb is at least somewhat sure that function application popped up in math first.
17:41:41 <erisco> this is because I've learned to read it right-to-left… it is a surmountable problem
17:41:41 <Zekka> Yes there's subjectivity here, and obviously if you get used to doing it the way Haskell does it, you can do it that way
17:41:48 <Zekka> I personally prefer doing it the way Haskell does it
17:42:03 <kadoban> erisco: Reading it isn't particularly the problem for me. Writing it is ... tedious as hell.
17:42:08 <Zekka> But very many languages have a convention for writing things left-to-right instead for basically this reason -- when you write a list of steps in a language like English, you usually write them left-to-right, top-to-bottom
17:42:13 <Zekka> I think Kadoban's point is also valid
17:42:26 <r_rios|pc> jle`:  I like pipe-ing things, but I guess I can get used to normal function composition, if it's the true Haskell way
17:42:28 <jle`> in the end, if you plan on writing code that other people can read and also being used to reading other people's code, it's best to get adapted to the normal idioms
17:42:36 <Zekka> you will notice that many languages let you write x.baz().bar().foo()
17:42:45 <Zekka> r_rios|pc: keep in mind: do not do things a certain way just because people tell you to do them that way
17:43:03 <Zekka> if you've got the choice, convince yourself that what you're doing is right for actual reasons before settling on it
17:43:04 <r_rios|pc> Zekka: Sure, but conventions do exist for a reason
17:43:11 <Zekka> there are actual reasons Haskell's notation is right, but imho they fail in a lot of cases
17:43:14 <jle`> you're free to write your code however you want, but you're basically siloing off a style that nobody else can read and making it hard to get used to reading anybody else's code :p
17:43:44 <jle`> correct vs. incorrect might not be a big issue here, yea
17:43:45 <r_rios|pc> If it's conventional to write normal composition instead of piping in Haskell, I see no reason not to
17:44:04 <Zekka> fyi, after the amount of stuff conventional haskell programmers intentionally do to make their code hard to read, they can deal with one little deviation on your part!
17:45:06 <Zekka> oh dear, I've learned monad transformers and traversables and lenses and all the hard things that people say "hey it's really not that hard" but I can't deal with one little break in convention that someone came up so he could write his sequence of steps in left-to-right, top-to-bottom order, the way his natural language of choice happens to do
17:45:20 <dedgrant> This is related to function application versus function (type) connective associativity, no?
17:45:50 <dedgrant> So we can read both the applications and types in the same direction?
17:45:53 <Zekka> dedgrant: Someone who reads more than me could probably tell you, but that sounds like a very abstract concept and this is a very simple problem
17:45:56 <mjrosenb> Zekka: import Prelude hiding (($)); x $ f = f x; -- that's one little deviation, right?
17:46:06 <r_rios|pc> In any case, here's what I ended up with: http://lpaste.net/169872
17:46:11 <Zekka> mjrosenb: It's a way bigger break with convention imho, but yeah
17:46:49 <Zekka> r_rios|pc: fwiw, I don't like it that currentusertags is now buried in there -- have you considered "currentUserTags & Set.map (\tag->..."
17:46:51 <kadoban> mjrosenb: Adding a new thing is different than confusing reusing and changing an existing thing.
17:47:07 <jle`> r_rios|pc: fwiw, chaining (&) like that is basically the same thing as reverse function composiiton/application order
17:47:27 <jle`> but yeah, f x & g & h is usually written as x & f & g & h
17:47:40 <Zekka> http://lpaste.net/6602181610961895424 <- your code rewritten to use that style
17:48:16 <Zekka> fwiw, I doubt there is a person participating in this discussion who would not have immediately been able to read your code written with (&)
17:48:29 <erisco> I'm no proponent of conventions, but this seems like a trivial battle
17:48:30 <Zekka> but there are certainly a lot of hypothetical people who can handle everything else in Haskell, but couldn't possibly understand (&)
17:48:38 <Zekka> Hypothetical people are the harshest critics!
17:48:47 <erisco> it is like we're arguing about where braces should go
17:49:01 <Zekka> erisco: I'm expressing the strong opinion that having a strong opinion about this is goofy
17:49:09 <mjrosenb> Zekka: I *hate* hypothetical people.
17:49:10 <lpaste> jle` annotated “fitness.hs” with “fitness.hs (annotation)” at http://lpaste.net/169872#a169873
17:49:45 <monochrom> nobody is hypothetical
17:49:46 <jle`> r_rios|pc: that's how you might do it normally in both normal and reverse order.  the first order is still prefered, but, yeah
17:50:02 <Zekka> I might be coming off as a defender specifically of (&), but really I'm just being a little bit of a troll about "it's a break from convention, we can't stand that" / "it's not the way math did it" / "there are certain identities that are prettier to write if you always follow the convention that you don't like in this case"
17:50:18 <Zekka> there are a million little breaks from convention in Haskell and a staggering amount of horrible naming
17:50:20 <dedgrant> Zekka: Just thinking of 'f :: a -> b -> c' corresponding to 'f a b c' is all
17:50:27 <jle`> r_rios|pc: (the paste above)
17:51:02 <Zekka> dedgrant: Oh, why didn't you say so? Yeah, that's true.
17:51:07 <dedgrant> :)
17:51:21 <Zekka> (although it really corresponds to "f a b")
17:51:31 <dedgrant> Ah right ty
17:52:09 <r_rios|pc> jle`: I know, I was just showing what I ended up with by piping
17:52:14 <erisco> Zekka, well I don't know if that is really what anyone is saying, it certainly isn't what I am saying
17:52:39 <r_rios|pc> More refinements: http://lpaste.net/169874
17:52:48 <Zekka> erisco: jle` made a comment that imho was a little bit extreme
17:52:53 <erisco> Zekka, recommending to a newcomer that they take the opportunity to learn the idioms, to their benefit of reading idiomatic code, is a good idea
17:53:01 <r_rios|pc> I agree
17:53:02 <Zekka> fishythefish imho made similar comments
17:53:09 <Zekka> erisco: I certainly agree with that, yeah
17:53:30 <Zekka> When I got started with Java, though, there were a lot of little horrible conventions I didn't understand and lots of people followed them
17:53:52 <Welkin> yeah, java is terrible
17:54:07 <Welkin> I do find lens-heavy code hard to read
17:54:11 <Welkin> but that is because I don't use lens
17:54:12 <Zekka> and I really wish I would have had someone mentioning "just FYI, it doesn't matter if you offend any hypothetical people"
17:54:31 <dedgrant> I am hypothetically offended.
17:54:43 <erisco> well, we can all admit there are no deep insights offered by right-to-left over left-to-right
17:54:48 <Zekka> I'm a little bit high-strung today, by the way, so sorry about that
17:54:56 <dedgrant> Existentially offended? more like
17:55:02 <Zekka> I have been reading and making corrections to code that was written to an exacting styleguide
17:55:03 * r_rios|pc watches the discussion he unintetionally spawned in awe
17:55:12 <Zekka> it also was specified in incredible depth
17:55:26 <Zekka> the specs are all wrong, there are tests for things the compiler can check, and the style isn't helping
17:55:54 <Zekka> probably a week of man-effort was put into making the files I had to touch look like the code quality was excellent
17:55:57 <slack1256> Welkin: Don't like lens or don't like lens operators?
17:56:09 <Welkin> hola slack1256 
17:56:16 <slack1256> I thought I didn't like them, but using view/set/over/preview has helped a lot
17:56:17 <Welkin> I just don't have a need for it yet
17:57:08 <slack1256> Hola, mucho gusto!
17:57:12 <Zekka> it is very interesting to me that someone can write the following: "@Test(expected = TestFailed.class) public void test_x() { /* test y */ z(); throw new TestFailed(); }"
17:57:14 <erisco> r_rios|pc, we're just trying to keep our elitism in check :P
17:57:46 <Zekka> so today I've been dealing with an astonishingly high level of wrong, all in one place, enabled by people who followed conventions while completely ignoring their spirit
17:58:31 <Welkin> Zekka: your first mistake is... java
17:58:44 <Zekka> Welkin: Java is not Java's worst problem imho
17:58:56 <Zekka> the Java language is extremely verbose but I don't think it's wrong per se
17:59:17 <Zekka> I think Java's problem is this -- someone comes up with ap attern, makes it very complicated, writes a lot of docs, establishes a cult of personality, and all of a sudden there's secret sauce behind the pattern
17:59:24 <Zekka> we can't really look behind the cover and understand it because we might lose the secret sauce
17:59:34 <Zekka> it's not just messaging, it's *Akka* messaging! That's so much better than messaging!
17:59:39 <Zekka> we can't hope to understand it by ourselves!
17:59:57 <Welkin> well, they come up with these stupid "patterns" because the language doesn't support first-class functions
18:00:01 <Zekka> So it's like "software quality" has been redefined into this intense, mad race to get to the point where it's too complicated  for you to understand, give Java consultants your money
18:00:09 <Welkin> and other faults in the language
18:00:27 <Zekka> Welkin: I think that's part of it -- if you are not extremely disciplined, you can easily write Java that makes things seem incredibly more complicated than they actually are
18:00:56 <Zekka> it is an excellent language if you want to be an obscurant and your chosen tool is code size
18:01:33 <Zekka> I still could not tell you what Spring does or why people use it
18:01:36 <Zekka> But it has the secret sauce
18:01:39 <Zekka> We can't write apps if we don't use Spring
18:01:56 <nshepperd_> the secret sauce is that if it wasn't a pattern people might start to wonder why they have to wrap objects inside objects inside objects in order to paper over java's type system
18:02:04 <Zekka> Oh, we're doing networking? Of course we have to use netty
18:02:10 <Zekka> other networking libraries don't do the magic things Netty does for us
18:02:15 * slack1256 think this probably should move to -blah or -offtopic
18:02:21 <Zekka> slack1256: You're probably right
18:03:11 <Zekka> thank you for dealing with my lack of restraint today =)
18:20:05 <reddyMonster> test
18:43:28 <pavolzetor> hi, I am writing a proxy and forkIO does not seem to spawn a thread in GHCI
18:43:39 <pavolzetor> is tihs a bug of feature? how to enable threading in GHCI
18:43:46 <pavolzetor> if I run stack exec executable it works
18:44:36 <alercah> did you pass -threaded?
18:45:09 <glguy> pavolzetor: You'll have to be more specific about what didn't work
18:45:18 <pavolzetor> stack ghci +RTS -threaded ?
18:45:29 <glguy> No, that won't do anything
18:45:31 <alercah> you need --ghci-options
18:45:32 <pavolzetor> it just blocks and the forked thread is also blocked
18:45:39 <alercah> I think?
18:46:32 <pavolzetor> I tried stack ghci --ghci-options=-threaded
18:46:35 <pavolzetor> and it did not help
18:47:00 <glguy> ghci is already using the threaded runtime afaict
18:47:31 <pavolzetor> hmm
18:47:37 <pavolzetor> then it is not working properly
18:47:39 <glguy> and GHCI already supports forkIO
18:47:42 <mgsloan> Yeah, I can fork a thread without passing any special options to ghci
18:47:44 <glguy> so you'll have to give us more information
18:48:19 <ertes> pavolzetor: try this to verify for yourself:  forkIO (threadDelay 1000000 >> putStrLn "yes")
18:49:11 * geekosaur wonders if they are doing something that requires the main thread
18:50:40 <glguy> or at least a bound thread, which GHCi doesn't use by default
18:52:00 <pavolzetor> ertes
18:52:04 <pavolzetor> does not print anything
18:52:26 <ertes> that's interesting
18:52:39 <glguy> What version of GHC on which platform?
18:53:07 <pavolzetor> it should wait a second right?
18:53:13 <pavolzetor> ghc 8.0.1
18:53:15 <glguy> and are you sure you didn't just miss it, it prints on the same line as the following prompt
18:53:36 <ertes> pavolzetor: does it print a thread id?
18:53:42 <pavolzetor> http://lpaste.net/575819616765345792
18:53:45 <pavolzetor> cabal file
18:53:54 <pavolzetor> no, I do not print the id
18:54:25 <ertes> pavolzetor: when you type the expression at the GHCi prompt, does it answer with a line like "ThreadId 126"?
18:54:26 <Koterpillar> pavolzetor: paste your GHCi session
18:54:30 <glguy> The cabal file won't matter, you should be able to test this by simply running GHCi on its own
18:54:37 <Koterpillar> starting from the line where you ran GHCi
18:55:27 <pavolzetor> yes, in ghci it prints that
18:55:42 <pavolzetor> my ghci session is literally ":main"
18:56:30 <pavolzetor> http://lpaste.net/4842387803025178624
18:57:07 <pavolzetor> it is my first networking code :)
18:57:20 <Koterpillar> I mean like this: http://lpaste.net/3445049682517032960
18:57:40 <pavolzetor> koterpillar, that works
18:57:54 <Koterpillar> what works?
18:57:55 <pavolzetor> my session is boring "stack ghci"  and ":main"
18:58:12 <pavolzetor> the forkIO (threadDelay 1000000 >> putStrLn "yes")
18:58:19 <Koterpillar> oh
18:58:27 <pavolzetor> but the code I pasted, there it does not print the "yes"
18:58:32 <Koterpillar> (11:51:43) pavolzetor: does not print anything
18:58:55 <pavolzetor> I mean in the code I pasted
18:58:58 <Welkin> what's with all the excitement over Freer and extensible effects?
18:59:12 <Koterpillar> pavolzetor: that suggest the problem isn't GHCi
18:59:18 <pavolzetor> http://lpaste.net/4842387803025178624
18:59:26 <pavolzetor> why does it work with stack exec ?
19:00:04 <boj> pavolzetor: can you restate your problem?
19:00:11 <pavolzetor> I have to run
19:00:17 <pavolzetor> I will try to catch up when I get home
19:00:19 <geekosaur> sigh
19:00:20 <pavolzetor> the problem is
19:00:27 <Koterpillar> pavolzetor: can you replace your main with forkIO (threadDelay 1000000 >> putStrLn "yes") "\
19:00:28 <pavolzetor> stack ghci and :main does deadlock
19:00:30 <Koterpillar> pavolzetor: can you replace your main with forkIO (threadDelay 1000000 >> putStrLn "yes") ?
19:00:40 <Koterpillar> and run it with ":main"
19:00:42 <pavolzetor> stack exec works without hickup
19:01:02 <boj> pavolzetor: ok, so trying to execute your code in ghci is a problem, but with stack exec not?
19:01:41 <glguy> Pavolzetor, if it doesn't work when you put the code after zmq's accept connection then that suggests it's a zmq related issue
19:02:11 <pavolzetor> Koterpillar: that works
19:02:18 <pavolzetor> bobj, exactly
19:02:23 <Koterpillar> pavolzetor: then it's still not a GHCi issue
19:02:40 <boj> indeed
19:02:50 <pavolzetor> ok, I will file a bug
19:02:51 <Koterpillar> at least not "threads don't work in GHCi"
19:03:00 <pavolzetor> it was just pretty confusing
19:03:03 <pavolzetor> thanks
19:03:04 <pavolzetor> :q
19:03:05 <Koterpillar> pavolzetor: please do! But first, find a minimal test case
19:03:16 <pavolzetor> ok, after the hackathon ends ;)
19:03:22 <ertes> is it a bug?
19:03:25 <Koterpillar> in the process you mind find out what the issue is
19:03:40 <Koterpillar> ertes: not likely, but when they try to minimize it, they'll find the answer
19:03:49 <pavolzetor> take care
19:08:35 * geekosaur is going to guess zmq requires thread local state and/or otherwise expects to be in the main thread
19:10:19 <geekosaur> hm, except that that should be not a problem with recent ghci versions. perhaps see if their ghci supports --no-ghci-sandbox
19:11:36 <glguy> Ghc 8 doesn't run :main in a bound thread when I tried
19:13:14 <geekosaur> yes, I noticed --no-ghci-sandbox is gone. but supposedly 7.10 got rid of the bound thread yet it still had the no-sandbox option...
19:28:05 <glguy> Individual ØMQ sockets are not thread safe except in the case where full memory barriers are issued when migrating a socket from one thread to another. In practice this means applications can create a socket in one thread with zmq_socket() and then pass it to a newly created thread as part of thread initialization, for example via a structure passed as an argument to pthread_create().
19:28:16 <glguy> http://api.zeromq.org/4-0:zmq
19:28:28 <glguy> Also I uploaded the zeromq4-haskell documentation http://hackage.haskell.org/package/zeromq4-haskell-0.6.5
19:28:58 * hackagebot ini-qq 0.1.0.0 - Quasiquoter for INI  https://hackage.haskell.org/package/ini-qq-0.1.0.0 (kseo)
19:30:15 <geekosaur> pavolzator left
19:31:10 <exio4> woah, that's news, the last I used/checked ZeroMQ, zmq3 was new and only available on rolling releases :O
20:02:03 <travism> y'all think the same way bobby fischer studied chess can be applied to programming?
20:02:57 <slack1256> who is bobby fischer
20:03:13 <travism> greatest chess player of all time
20:03:30 <slack1256> nice
20:04:15 <travism> Yeah, they say he read about 10x as much as he played, and obsessed over it. Basically read every book, magazine in his time about it as well.
20:05:12 <hodapp> hrmph. One call to 'accum' in hmatrix - inside of a function that's called several million times - causes a space leak that is pretty horrendous
20:05:53 <hodapp> which is sad, because that's the only way that I know of of updating a matrix
20:13:59 <hodapp> but, I suppose the bigger issue is that I have rising memory usage in an iterative algorithm that should have no reason to keep anything around from iteration to iteration except for a constant amount of state...
20:15:20 <geekosaur> travism, there's a fair amount of stuff in Haskell that will only really make sense when actually used, not just read about
20:16:45 <geekosaur> at least, that's what I found; I was reasonably well read (and could read Haskell code but not really write it, especially idiomatically) but needed to actually start working with code to get the rest of the way
20:22:07 <travism> geekosaur: yeah that's true.
20:23:40 <geekosaur> (this was also back when the main tutorial was the "Gentle Introduction". otoh I could already read SML code)
20:25:16 <sm> travism: how did he learn ? playing street chess in the park ?
20:25:31 <sm> oh, you said
20:25:59 <sm> in the movie it was all from playing with the hoodlums in the park
20:26:50 <travism> Lol yeah, he was just obsessed with it basically.
20:29:00 <slack1256> I don't think obsessiviness is a good trait for intelectual persuits actually
20:29:07 <slack1256> it makes greats stories though
20:29:58 <travism> slack1256: Just out of curiosity how do you think obsesseiveness effects it?
20:32:36 <slack1256> at least the type of obsessiviness I usually see, it really narrow your focus when dealing with problems.
20:33:20 <slack1256> When some lateral thinking could really help
20:33:57 <travism> slack1256: I thought a lot of talented programmers, etc.. had an obsessive personality to some extent. I mean I think you really have to, to be able to dedicate the time required to master something. IMO.
20:34:14 <travism> slack1256: Ah, yeah that's true.
20:36:04 <slack1256> Also there is the psychology of the obsessed person, that can make them not deal well with failed paths and stuff
20:36:50 <slack1256> but that is more of a personal thing
20:37:24 <slack1256> you really should _know_ you are separated from your work to be able to receive critisism ;-)
20:37:36 <travism> Yeah
20:39:00 * hackagebot persistent-template 2.5.1.4 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.5.1.4 (GregWeber)
20:46:37 <nshepperd_> learn haskell by writing street haskell with hoodlums in the park
20:47:29 <hodapp> BRILLIANT!
20:47:39 <travism> haha
20:58:15 <hodapp> hmmm, does anyone happen to know of some good guides on writing efficient iterative numerical algorithms in Haskell?
20:58:26 <carter> Benchmarks
20:58:39 <carter> And benchmarks. 
20:58:47 <hodapp> right now benchmarks are telling me that I have space leaks out the wazoo
21:01:54 <peddie> hodapp: I've redone the innermost loops to use ST in the past once I have a pure version to test against, it can help a lot
21:02:09 <hodapp> I was looking at ST
21:02:46 <hodapp> what I do know is that at every single iteration of this algorithm, only certain pieces of data are needed, and anything else is completely irrelevant
21:02:47 <peddie> hodapp: I don't recall whether hmatrix has an ST interface, but fortunately they're just Storable vectors under the hood . . . 
21:03:03 <hodapp> so I'm trying to track down the source of the horrible space leaks my implementation has
21:03:04 <carter> Monad STE is the shit ;)
21:03:12 <carter> Also use monad Prim
21:03:21 <carter> I mean prim monad
21:03:28 <peddie> hodapp: hm, OK, I have less experience tracking down space leaks, maybe someone else can help more
21:03:43 <hodapp> peddie: well, a rewrite in ST might just solve them, who knows
21:03:46 <carter> Profile all the ways
21:03:52 <carter> Did you try profiling? :)
21:04:00 <hodapp> carter: profiling is mostly just confirming for me that I have space leaks out the wazoo
21:04:11 <hodapp> it's not telling me why memory usage grows steadily with the number of iterations
21:04:12 <hodapp> just that it does
21:07:03 <peddie> hodapp: if you can post your code, someone might be able to help pinpoint the leak more easily
21:07:37 <hodapp> I might do that tomorrow after I get some sleep; the code's a mess right now
21:07:52 <hodapp> it might be apparent later that some tail-recursion can't happen, or something
21:09:29 <peddie> cool, get some rest :)
21:29:02 * hackagebot servant-router 0.8.1 - Servant router for non-server applications.  https://hackage.haskell.org/package/servant-router-0.8.1 (willfancher)
21:34:02 * hackagebot ltext 0.1.1 - Higher-order file applicator  https://hackage.haskell.org/package/ltext-0.1.1 (athanclark)
21:58:20 <slack1256> fix (04107:)
21:58:30 <slack1256> does that look highlighted?
21:58:55 <Koterpillar> yes (Pidgin)
21:59:06 <slack1256> Nice!
22:00:27 <Cale> That'll seem cool right up until you want to use lambdabot
22:00:30 <Cale> ;)
22:03:30 <slack1256> yes, that I was thinking
22:03:37 <slack1256> plus other clients maybe see gibberish
22:03:56 <ludat> I see it colored too (weechat)
22:04:09 <kaictl> only really, really bad clients will see gibberish.
22:04:16 <ludat> may I ask how did you do that?
22:04:37 <kaictl> ludat: in weechat, ^c^b
22:04:51 <kaictl> iirc...
22:04:59 <kaictl> 3 foo bar
22:05:20 <kaictl> oh, well that makes it bold. it might be ^cc 3foo bar
22:05:57 <ludat> lel
22:06:59 <ludat> c15dwadwa
22:07:20 <ludat> 01color?
22:07:32 <Koterpillar> nope
22:07:42 <geekosaur> black on black, here
22:07:47 <ludat> it's grey :P
22:08:03 <ludat> 05better?
22:08:44 <geekosaur> ...one "interesting" think you'll run into with color is that all the terminal color codes are twisted by the old IBM PC CGA display, where half the colors were just the other half + bold
22:09:25 <slack1256> on irc-core (haskell) it is /hs for formatting haskell code
22:10:04 <slack1256> geekosaur: that irrespective of configuring xterm for 256 colors?
22:11:21 <geekosaur> xterm with 256 colors uses a different scheme, yes. but many programs then can't *use* the 256 colors because they only know about the ANSI X3.64 set with its CGA underpinnings :/
22:12:26 <geekosaur> (programs that uses curses *can* use the 256 colors... but mostly don't because they "know" terminals can only use the base 8 colors + bold versions and don't check the actual number of supported colors or make the calls to enable curses to access them)
22:13:11 <geekosaur> (partly this is curses' fault for implementing colors as hackily as it did)
22:19:03 * hackagebot pandoc-crossref 0.2.2.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.2.2.0 (lierdakil)
22:27:23 <slack1256> Anybody with an idea of how type-classes will interact with backpack?
22:28:38 <JuanDaugherty> http://plv.mpi-sws.org/backpack/ that?
22:29:04 * hackagebot pandoc-crossref 0.2.2.1 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.2.2.1 (lierdakil)
22:30:28 <JuanDaugherty> sec. 5 is about type classes
22:34:28 <slack1256> oh future-work
22:34:47 <slack1256> although the Ghc-wiki page seems more down to earth
22:35:12 <eklavya> I need to read a number and then read that many bytes from a byteString, I am using Binary package, in the get monad do chain how do I take num bytes and return a byteString?
22:35:27 <eklavya> do
22:35:28 <eklavya>     len <- get :: Get Int16
22:35:39 <eklavya> now there is no byteString reference to take from
22:40:33 <geekosaur> hm? you're in the Get monad, you should be able to do another get
22:41:27 <eklavya> geekosaur: but how much?
22:41:39 <eklavya> how do I tell it to only get num bytes?
22:43:34 <eklavya> sorry I didn't realize just how stupid that was :P
22:43:35 <dibblego> get >>= \len -> replicateM len getWord8
22:43:42 <eklavya> I can get num "bytes"
22:43:47 <eklavya> yeah
22:44:00 <eklavya> thanks :)
22:44:24 <geekosaur> (sorry I'm also in a discussion in another channel...)
22:48:12 <Digit> is there a way to get ghci to not present numbers like 1.5015015015015015e-7 as that's very unreadable to me, n very error prone as i try to convert it quickly to a more readily useable form.   maybe that way works for the sorta maths nerds more typically attracted to haskell, but it's driving me crazy
22:48:22 <dibblego> Text.Printf#printf
22:49:33 <geekosaur> otherwise ghci is just using the Show instance, which is not very flexible
22:50:22 <geekosaur> you might be able to do something clever with -interactive-print https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghc-flag--interactive-print
22:50:37 <dibblego> printf "%0.4f" the number
22:52:09 <Cale> > showFFloat (Just 3) 1.5015015015015015e-7 ""
22:52:11 <lambdabot>  "0.000"
22:52:27 <Cale> > showGFloat (Just 3) 1.5015015015015015e-7 ""
22:52:28 <lambdabot>  "1.502e-7"
22:52:45 <dibblego> @type showGloat
22:52:46 <Cale> Digit: ^^
22:52:47 <lambdabot>     Not in scope: ‘showGloat’
22:52:47 <lambdabot>     Perhaps you meant one of these:
22:52:47 <lambdabot>       ‘showFloat’ (imported from Numeric),
22:53:17 <Cale> showFFloat (Just 5) pi ""
22:53:19 <Cale> > showFFloat (Just 5) pi ""
22:53:20 <lambdabot>  "3.14159"
22:54:05 * hackagebot pandoc-citeproc 0.10.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.10.1 (JohnMacFarlane)
23:44:06 * hackagebot fgl 5.5.3.0 - Martin Erwig's Functional Graph Library  https://hackage.haskell.org/package/fgl-5.5.3.0 (IvanMiljenovic)
23:44:08 * hackagebot fgl-arbitrary 0.2.0.2 - QuickCheck support for fgl  https://hackage.haskell.org/package/fgl-arbitrary-0.2.0.2 (IvanMiljenovic)
23:55:35 <Digit> o_O  no idea how to make use of what i've been told.
