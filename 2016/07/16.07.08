00:18:13 * hackagebot solga 0.1.0.1 - Simple typesafe web routing  https://hackage.haskell.org/package/solga-0.1.0.1 (PatrickChilton)
00:32:19 <milesrout> I think I want the opposite of a free monad
00:32:37 <johnw> enter the chained monad!
00:33:22 <milesrout> or maybe I don’t, I can’t tell
00:33:36 <johnw> more description would help
00:33:54 <milesrout> yeah I’m trying to work out how to describe it best
00:39:01 <mniip> Cofree?
00:39:41 <johnw> it's hard to intuit what the questioner wants in the complete absence of information, isn't it :)
00:39:44 <nshepperd> an expensive monad
00:40:23 <milesrout> johnw: be patient please
00:40:49 <mniip> proprietary monad?
01:03:14 * hackagebot stgi 1.0.1 - Educational implementation of the STG (Spineless Tagless  G-machine)  https://hackage.haskell.org/package/stgi-1.0.1 (quchen)
01:23:15 * hackagebot netlink 1.0.0.4 - Netlink communication for Haskell  https://hackage.haskell.org/package/netlink-1.0.0.4 (ongyerth)
01:28:50 <asante> I want to play around with quipper on my xubuntu. As quipper needs ghc 7.8 I can not use the newer ghc version distributed via apt. Whats the best way to install an older ghc on ubuntu linuxes? compile from source, or are there apt repositories, where I can get ghc from?
01:29:02 <Jinxit> stack
01:39:17 <asante> Jinxit: can you give me a pointer how to install old ghc versions with stack? stack setup && stack ghci says, its using ghc-7.10 (the one from my path)
01:41:30 <Jinxit> docs will know that better than I do
01:41:36 <Jinxit> all I know is you can select the version somehow
01:41:45 <dexterph> you have to change the resolver
01:41:49 <dexterph> if you use lts-2.22 for example
01:41:52 <dexterph> https://www.stackage.org/lts-2.22
01:42:00 <dexterph> basically just find a resolver which uses 7.8.x
01:42:45 <dexterph> e.g. stack install --resolver=lts-2.22
01:42:47 <dexterph> sorry
01:42:54 <dexterph> stack setup --resolver=lts-2.22
01:43:05 <asante> stack setup 7.8.4 seems to do the trick
01:43:10 <dexterph> great
01:50:01 <asante> but the --resolver is needed to choose the correct version for stack ghci then.
01:50:08 <asante> thanks dexterph & Jinxit
02:26:20 <adarqui> ertesx: splitting everything out from one big module, to separate modules, sped up the haskell build from 2+ minutes to ~30seconds
02:26:23 <adarqui> nice
03:33:19 * hackagebot type-level 0.3.0 - Type-level programming library  https://hackage.haskell.org/package/type-level-0.3.0 (ugeorge)
03:33:21 * hackagebot yst 0.5.1.1 - Builds a static website from templates and data in YAML or  CSV files.  https://hackage.haskell.org/package/yst-0.5.1.1 (JohnMacFarlane)
03:42:07 <Undreren> Hi
03:43:07 <lyxia> Undreren: hello
03:51:26 <ertesx> adarqui: yeah, GHC prefers small modules
03:51:57 <ertesx> adarqui: i try to keep my packages small as well these days
03:52:58 <ertesx> and one reason i don't like 'persistent' much is that i don't like having many types or the OO principle of "have a type for each piece of data you handle"
03:54:39 <merijn> ertesx: Any recommendations for SQLite libraries for people with similar opinions? :p
03:59:27 <bergmark> merijn: you can avoid that with opaleye
04:01:03 <merijn> bergmark: Hackage docs says that that targets postgres?
04:01:17 <bergmark> https://hackage.haskell.org/package/opaleye-sqlite
04:02:50 <dramforever> ertesx: Sounds like if you are focusing on querying the database rather than just CRUD-ing things, persistent-style libs are unsuitable
04:04:24 <merijn> hmmm, that looks more complicated than I'm looking for
04:04:39 <merijn> I'm actually ok (would prefer, even?) writing my own SQL
04:04:59 <cocreature> merijn: in that case, are you looking for something like sqlite-simple?
04:05:01 <Undreren> > sum . map (2^) . filter even $ [1..10]
04:05:03 <lambdabot>  1364
04:05:54 <Undreren> What happens if a pass the lambdabot an expression that is too big? Or an IO action?
04:06:13 <merijn> Undreren: lambdabot doesn't allow IO actions
04:06:21 <merijn> and too big it just times out
04:06:22 <cocreature> and it has a timeout
04:06:29 <Undreren> ok, cool
04:06:36 <osa1> re
04:06:44 <Undreren> I was just wondering ;)
04:06:47 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100000000 -- is this big enough?
04:06:53 <lambdabot>  mueval-core: Time limit exceeded
04:06:57 <merijn> It is :)
04:07:07 <merijn> or
04:07:17 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- output truncation
04:07:19 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:07:22 <Undreren> let fibs = scanl1 (+) $ 0 : 1 : fibs in fibs
04:07:33 <Undreren> >let fibs = scanl1 (+) $ 0 : 1 : fibs in fibs
04:07:40 <merijn> needs > and a space
04:07:46 <Undreren> > let fibs = scanl1 (+) $ 0 : 1 : fibs in fibs
04:07:47 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:08:03 <Undreren> > let fibs = scanl1 (+) $ 0 : 1 : fibs in filter odd fibs
04:08:04 <merijn> Undreren: lambdabot also responds to privmsg, btw if you wanna experiment
04:08:05 <lambdabot>  [1,1,3,5,13,21,55,89,233,377,987,1597,4181,6765,17711,28657,75025,121393,317...
04:08:12 <ertesx> merijn: not sure, if i'd had to access SQLite DBs, i'd probably just use sqlite-simple
04:08:22 <ertesx> although i like what i've read about opaleye
04:08:43 <Undreren> > let fibs = scanl1 (+) $ 0 : 1 : fibs in length . takeWhile (<10^8) $ fibs
04:08:45 <lambdabot>  40
04:08:45 <Boomerang> > let f = 0 : scanl (+) 1 f in f
04:08:47 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:09:00 <ertesx> dramforever: persistent may be perfect for CRUD-style applications, but my applications usually have a data *semantics* associated with them =)
04:09:02 <merijn> ertesx: I'm just writing a quick web scraper that should dump properties into a db, so complexity is overkill :)
04:09:19 <ertesx> dramforever: one that's more interesting than "fetch this value at this index"
04:09:43 <merijn> Actually, maybe I just want a key value store...
04:09:55 <ertesx> merijn: maybe you just want a directory of files
04:10:04 <merijn> ertesx: Most definitely not :)
04:10:20 <merijn> ertesx: I have a couple of 100k entries and I wanna query them :)
04:10:30 <dramforever> Hmm...
04:10:35 <ertesx> merijn: if you have a monoid morphism from a list of text lines to whatever the actual data representation is, then files work very well =)
04:10:47 <ertesx> merijn: at least as an intermediate store
04:10:56 <dramforever> Sounds like persistence is trying to make the database disappear
04:11:07 <dramforever> from an API point of view
04:11:11 <dramforever> *persistent
04:12:17 <ertesx> one thing i like about 'persistent' is automatic database init and migration
04:12:50 <ertesx> i'd like to have that, but without everything else it comes with
04:13:20 * hackagebot stache 0.1.0 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-0.1.0 (mrkkrp)
04:13:22 <ertesx> recently it even made me consider using one of those schemaless databases, but i quickly returned to PostgreSQL
04:14:22 <merijn> I like the notion of automatic migration for acid-state too, but it's not really suited for database work ;)
04:14:26 <merijn> s/;)/:)
04:15:14 <ertesx> maybe because it's not a database to begin with =)
04:15:27 <merijn> ertesx: I know, but many people are confused :p
04:16:19 <nomeata> whois svp_
04:16:40 <dramforever> What about http://hackage.haskell.org/package/esqueleto?
04:16:44 <nomeata> Is Sven Panne here by any chance?
04:17:09 <dramforever> It looks like a SQL DSL for persistent
04:18:17 <ertesx> dramforever: i can't help it; esqueleto gives me this feeling of irony
04:20:56 <dramforever> What feeling specifically? Or just a strange feeling?
04:22:04 <ertesx> persistent: "use databases without SQL!"
04:22:15 <ertesx> esqueleto: "you, know…  hmm…"
04:23:01 <dramforever> Ah
04:30:16 <Undreren> ??
04:30:53 <Undreren> preflex: quote biglama
04:59:18 <M2tias> https://www.quora.com/Homework-Question-How-do-I-write-a-program-that-produces-the-following-output-1/answer/Rafal-Szymanski-1
05:03:21 * hackagebot nested-sequence 0.1 - A list-like data structure with O(log(n)) random access  https://hackage.haskell.org/package/nested-sequence-0.1 (BalazsKomuves)
05:05:48 <ongy> When I have an IO function get's some huge struct with IO then purely transforms that into something more usable and then returns that, is the pure part still lazy, or will IO break that?
05:06:26 <Rotaerk> M2tias, lol
05:07:50 <M2tias> a lot of other solutions in the thread as well, check it out
05:07:50 <srhb> ongy: "It depends" -- it's probably all pure, and if you're using lazy IO, your entire program can be lazy.
05:08:33 <Undreren> ongy: the "pure" part? The transformation function?
05:08:39 <ongy> yes
05:09:36 <Undreren> ongy: I think srhb is right, it's all lazy, 
05:09:37 <ertesx> ongy: IO execution is strict, but evaluation is not
05:09:45 <ongy> ok, thanks
05:09:55 <ertesx> ongy: IO is only strict as far as it's necessary to know what effects should happen
05:11:07 <srhb> ertesx: What?
05:12:02 <ertesx> undefined <$ getLine >> putStrLn "Blah"
05:12:18 <ertesx> reads a line, then prints "Blah"
05:12:30 <ertesx> undefined <$ getLine >> undefined  -- reads a line, then crashes
05:12:59 <srhb> ertesx: I don't think that was the question.
05:13:05 <srhb> But I may be mistaken.
05:13:06 <ongy> :t <$
05:13:08 <lambdabot> parse error on input ‘<$’
05:13:10 <srhb> :t (<$)
05:13:12 <lambdabot> Functor f => a -> f b -> f a
05:14:14 <ertesx> it is highly related…  if fmap weren't lazy or if (>>=) would be strict in the passed value, this wouldn't work
05:14:57 <ertesx> pure undefined >>= const (putStrLn "Same idea.")
05:16:26 <ongy> ertesx: it is related but I don't think most people that have to ask would understand your answer
05:16:30 <srhb> Yes, I suppose it makes it _possible_ to avoid introducing strictness, but it certainly doesn't guarantee it.
05:16:56 <srhb> I think the question was, conceptually, "can I read a file lazily and process it lazily" :-)
05:17:25 <srhb> ongy: But only you know. :-P
05:18:22 * hackagebot sfnt2woff 0.1.0.0 - A command line tool to convert TrueType/OpenType fonts to WOFF format  https://hackage.haskell.org/package/sfnt2woff-0.1.0.0 (kseo)
05:18:28 <ertesx> i may have misunderstood the question…  lazy I doesn't usually occur to me to be a thing anymore =)
05:18:33 <ertesx> (not a typo)
05:18:37 <arianvp> 11
05:18:45 <Undreren> Isn't lazy file reading possibly a huge space leak?
05:18:53 <srhb> Undreren: Only if you do it wrong. :)
05:18:55 <ertesx> it's a huge lot-of-things =)
05:19:00 <Undreren> lol
05:19:03 <ongy> It's not a file, and I want the IO to be strict just processing lazy
05:19:13 <ertesx> lazy O is fine, but lazy I asks for trouble in many cases
05:19:26 <Undreren> srhb: How do you correctly read a file lazily? :D
05:19:26 <srhb> I like lazy I... But I realize a lot of people have forsworn it.
05:19:33 <ongy> how would lazy O be "evaluated"?
05:19:43 <ertesx> srhb: there are just better ways that are mostly just as convenient
05:20:07 <srhb> ertesx: For most cases I need, I haven't found them to be anywhere near as convenient. Plus I haven't had issues with it so far, so I think it's just fine. :)
05:20:18 <ertesx> ongy: (putStr (c : cs)) would be evaluated similar to:  putChar c >> putStr cs
05:20:27 <cocreature> “I haven’t had issues so far” <- famous last words
05:20:34 <ertesx> hehe
05:20:56 <srhb> cocreature: Or maybe I'm competent enough to switch to another solution if problems with lazy IO arise for me. :)
05:21:33 <ertesx> srhb: if it works for you, that's fine…  but know that stream I/O, after climbing the learning curve, is just as convenient, sometimes even more =)
05:21:36 <ongy> I want to use X, but X might be a problem, so I don't use X. Oh, X never was a problem for me
05:22:22 <srhb> ertesx: I know how to utilize pipes, conduits, ...
05:22:44 <srhb> Why is it I'm assumed to be stupid just because I can make lazy IO work for most of my use cases? :-P
05:23:24 <ertesx> srhb: i'd never assume that, and "because I can make lazy IO work …" is not the reason
05:23:44 <ertesx> this is: "I haven't found them to be anywhere near as convenient"
05:24:28 <srhb> ertesx: OK, I'm done discussing this with you.
05:31:06 <mtesseract> Hi
05:32:46 <srhb> mtesseract: Hi :)
05:38:45 <lpaste> aphorisme pasted “Type inference and GADTs (existential types?)” at http://lpaste.net/169301
05:38:47 <maerwald> behavior of lazy IO is semi-defined
05:39:36 <aphorisme> I though I have a good intuition about type inference in hindley-milner. But when GADTs come into play my intuition goes to waste. What am I getting wrong here? (see lpaste post).
05:41:05 <opqdonut> aphorisme: when you pattern match a GADT, the types get narrowed (I think that's the term)
05:41:33 <opqdonut> aphorisme: so in the equation "printT (Snapshot i x) = ...", you'll have f = Flag1
05:41:47 <opqdonut> aphorisme: and in the other equation, f = Flag2
05:42:21 <aphorisme> so basically it is a special case; it is a different type inference when GADTs are present?
05:42:31 <opqdonut> well yeah
05:42:49 <opqdonut> you can test this e.g. by having functions flag1ToString :: Flag1 -> String and flag2ToString :: Flag2 -> String and using these instead of show in the definition
05:43:16 <opqdonut> see the last bullet point on https://downloads.haskell.org/~ghc/6.6/docs/html/users_guide/gadt.html
05:44:04 <aphorisme> Is this something which is captured by System F?
05:44:56 <opqdonut> not sure
05:46:54 <aphorisme> thanks   : ). The link was gold already.
05:50:50 <mtesseract> I'd like to become more familiar with the Haskell/GHC resource semantics. For this, I'd like to clarify my understanding of (among other things) tail call optimizations/stack frames or generally speaking: the GHC execution model. I know what a tail call is syntactically, but it seems that a syntactical tail call is not the only kind of recursion GHC optimizes away. e.g.: the standard fac function
05:50:52 <mtesseract> (http://lpaste.net/169302) also seems to run in constant memory, although it's not a tail call (syntanctically, at least). Where is this behaviour documented? The Haskell report doesn't seem to specify this. Also, I would have the quoted fac function to generate a lot of unnecessary thunks on the heap. Also this does not seem to be the case.
05:51:10 <merijn> mtesseract: Tail calls are not a very sensible notion in haskell
05:51:28 <merijn> mtesseract: GHC doesn't use a function callstack at all
05:51:47 <merijn> mtesseract: No callstack means there's no need to optimise tail calls to avoid overflowing it
05:52:06 <merijn> mtesseract: In other words, depending on your point of view ALL haskell functions are ALWAYS tail calls, or none of them are tail calls
05:53:15 <merijn> mtesseract: As for thank allocation, I would expect GHC to see through your factorial function (it's rather trivial) and the strictness analyzer would unpack everything into a tight inner loop
05:53:32 <mtesseract> merijn: where is this documented? I'd like to understand how GHC does not need/use a function call stack.
05:53:50 <merijn> mtesseract: As a starting point I recommend the STG paper and then the fast curry one
05:54:17 <merijn> oh, bollocks
05:54:17 <mtesseract> Thanks.
05:54:25 <merijn> the link for the STG paper seems to have died...
05:54:30 * merijn kicks MS Research
05:55:16 <mtesseract> Are you saying there is no way at all to overflow the stack in the GHC runtime?
05:55:43 <merijn> You can certainly overflow *A* stack in GHC, just not a function call one, because it doesn't exist
05:55:50 <merijn> mtesseract: https://www.semanticscholar.org/paper/Implementing-Lazy-Functional-Languages-on-Stock-Jones/297e4586ec4ebcd5a26ab713af9ae95d2d0763f6/pdf
05:55:54 <merijn> That's the STG one
05:56:02 <mtesseract> Cool, thank you.
05:56:14 <merijn> And making a fast curry: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.134.9317&rep=rep1&type=pdf
05:56:48 <mtesseract> merijn: You mean, I can overflow a stack that e.g. I implement on my own, occupying heap memory?
05:56:57 <mtesseract> (sure)
05:57:02 <merijn> No, there's a pattern match stack, which can be overflown
05:57:19 <mtesseract> Ah
05:57:39 <mtesseract> that's what you mean by 'a stack'.
05:57:43 <mtesseract> I see.
06:09:33 <dracula`> .
06:13:23 * hackagebot ghc-typelits-extra 0.1.2 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.1.2 (ChristiaanBaaij)
06:23:23 * hackagebot ghc-typelits-natnormalise 0.4.2 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.4.2 (ChristiaanBaaij)
06:27:57 <vktl> with cassava, how do i decode to a tuple if a csv has only one column?
06:28:26 <vktl> since since tuples have to have at least two values I can't specify the type as:
06:28:39 <vktl> Either ErrType (Vector (T.Text)))
06:28:50 <vktl> because (T.Text) is not interpreted as a one-element tuple
06:29:12 <Axman6> Maybe Text would probably work
06:31:12 <vktl> do you mean like Either Err (Vector (Maybe T.Text))) ?
06:31:40 <vktl> I don't think that works because Maybe doesn't have a FromRecord instance
06:33:47 <vktl> ack spacemacs frozen again. super crashy lately :(
06:34:25 <glguy> http://hackage.haskell.org/package/cassava-0.4.5.0/docs/Data-Csv.html#t:Only
06:34:30 <glguy> Vktl
06:34:47 <vktl> ah
06:35:00 <vktl> *thumbs up*
06:35:20 <ij> How could I synchronize two processes that share a resource? 
06:35:30 <glguy> MVar
06:36:13 <shock_one> Hi. I have a function `a -> m b`. Is there some function to map over results (like `b -> c`) and return a wrapper for my initial function? This function I'm looking for should return `a -> m c`
06:36:38 <ertesx> shock_one: \f -> (fmap f .)
06:36:58 <ertesx> :t \f -> (fmap f .)
06:36:59 <lambdabot> Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
06:37:22 <ij> glguy, How would the two processes know of each other's MVar?
06:37:53 <ertesx> ij: they would be functions of MVar
06:38:07 <ertesx> ij: or do you literally mean "processes"?
06:38:08 <glguy> Oh, actual system processes? Not MVar :)
06:38:17 <ij> yes, actual processes
06:38:48 <ertesx> ij: in that case it's highly system- and resource-specific
06:39:00 <ij> I was thinking a mmaped page would work, if I could allocate an MVar in it.
06:39:04 <ertesx> what's the shared resource?
06:39:58 <shock_one> Thank you, ertesx.
06:40:12 <ij> ertesx, Does the type of the shared resource change anything?
06:40:15 <ertesx> ij: sharing an MVar isn't possible, but you can certainly create an MVar-based abstraction over a FIFO or any other IPC construct
06:40:47 <ertesx> ij: well, processes can share a number of things of different natures:  file descriptors, memory, etc.
06:41:10 <ertesx> and the things they can share differ from platform to platform as well
06:42:36 <ij> I don't think it matters. But ok, I get that there's no straightforward solution.
06:42:56 <ertesx> the straightforward solution is to use pipes or sockets together with a serialisation library
06:44:44 <ertesx> ij: if you want to follow that route, you may want to check out the network-transport library
06:44:45 <ij> I guess I was thinking about locking more than the sharing part, because if I have locks, sharing is never a problem
06:44:58 <ertesx> or, if you want to go all the way, check out distributed-process (a.k.a. cloud haskell)
06:45:05 <ertesx> oh
06:45:35 <ertesx> for locking you can simply use file locking…  it's the usual approach
06:47:41 <mtesseract> merijn: The paper "Implementing lazy functional lanaguages on stock hardware: the Spineless Tagless G-machine" claims that STG uses a push/enter model (not the eval/apply model) but recent GHC documentation says that GHC uses eval/apply (https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution). Intersting. It seems they have changed the execution model in the not so distant past(?).
06:48:24 <merijn> mtesseract: Both papers are not completely up to date with current GHC, but they're a good starting point
06:48:27 <ertesx> ij: there is the multi-platform package 'filelock'…  use that one if it works, otherwise you can use the 'unix'/'Win32' packages
06:49:16 <mtesseract> merijn: (this wasn't meant as a point of criticism, just as an obseveration)
06:49:20 <merijn> Warning about network filesystems and locking :)
06:56:15 <Khamal> hey, i have a beginners question. haskell wiki told me i could ask here. so here it goes: when declaring a newtype e.g. newtype IntList = IntList [Int] for typesafety reasons, how to I correctly use prelude functions like map on it? e.g. a = IntList [1,2,3]. map (*2) a. Do I have to redefine every prelude function I want to use on this newtype? Or do I define a lift function (lift :: ([Int] -> [Int] -> IntList -> IntList))? Thanks :)
06:57:11 <ertesx> Khamal: you define a 'lift' function
06:57:32 <ertesx> Khamal: call it liftIntList, because 'lift' is already taken =)
06:58:03 <ertesx> Khamal: you could also benefit from naming the field:  newtype IntList = IntList { fromIntList :: [Int] }
06:58:14 <ertesx> then:  liftIntList f = IntList . f . fromIntList
06:59:06 <PyroPeter> hello. how many spaces should I use for indentation?
06:59:18 <sm> two
07:00:02 <frontendloader> Did you mean: How many tabs should I use for indentation?
07:00:15 <ertesx> Khamal: as a final remark, if you don't specialise to Int right away, you get most of the functionality for free, if you want it (requires a bunch of extensions):  newtype MyList a = MyList { fromMyList :: [a] }  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
07:00:27 <Khamal> ertesx: thanks. i read somewhere that lift functions are bad coding style. Is there no way to make haskell understand, that my new type has the same properties as a list or a list of Ints, so that prelude functions would work out of the box?
07:00:53 <PyroPeter> I would have been all for tabs in the past, but I finally realised that one should use spaces as a curtesy for all those people who don't know how to set up their editor properly (aka. idiots)
07:00:58 <ertesx> PyroPeter: two, four, six, eight…  for some reason we all seem to agree that it must be a multiple of two =)
07:01:38 <lyxia> there exist three spacers out there though
07:01:40 <ertesx> PyroPeter: in haskell there are reasons to prefer spaces even without that assumption
07:01:50 <Khamal> ertesx: does this only work when i don't specify Int? Shouldn't that also be possible when i do specify?
07:02:06 <iphy> has anyone tried to get test coverage on C code to work?
07:02:07 <ertesx> Khamal: the way to make haskell understand that your type is basically just [Int] is to use [Int] =)
07:02:09 <PyroPeter> ertesx: which? is there a detailed write-up on that somewhere?
07:02:17 <maerwald> ertesx: erm
07:02:18 <maerwald> no
07:02:32 <jackhill> I use spaces and don't think I'm an idiot (and don't think name calling is called for (heh))
07:02:32 <iphy> if I pass --coverage to cc-options and ld-options, I get one 14587779232007237709.gcno file
07:02:33 <maerwald> there might be a good reason for a newtype e.g. smart constructor
07:03:02 <maerwald> Khamal: you can just make instances of functor, traversable etc
07:03:12 <ertesx> Khamal: it's only possible for types with a type argument
07:03:13 <maerwald> I think ghc can derive them with some GHC extension for newtypes?
07:03:25 <maerwald> ah, he has no argument?
07:03:40 <maerwald> I think there's a ghc extension too, no?
07:03:42 <PyroPeter> jackhill: I didn't say that all people using spaces are idiots
07:03:45 <ertesx> Khamal: MyList Int from the type safety perspective, is just as good as IntList anyway, and as a bonus, it makes mapping functions tell more through types
07:04:00 <ertesx> Khamal: (that's call parametricity, which is generally considered a good thing)
07:04:10 <ertesx> Khamal: and no, lifting is not evil…  we do it all the time
07:04:17 <ertesx> even lenses are just a clever form of lifting
07:04:29 <ertesx> PyroPeter: in haskell you benefit from non-uniform indentation levels
07:04:37 <jackhill> PyroPeter: I guess my point is more that if someone is in this channel that does fit your criteria, I don't want them to be insulted. We are enriched by their presence.
07:05:23 <PyroPeter> yes, you are probably right
07:05:36 <jackhill> :)
07:05:44 <PyroPeter> excuse me, I tend to be a bit harsh
07:06:28 <ertesx> be cynical instead…  people love cynics =)
07:07:35 <sm> no! be argumentative!
07:07:49 <vktl> what's an efficient way to filter a vector of records into a vector of records such that the remaining records have a field value that is within a set?
07:08:21 <vktl> naively doing filter (\x -> member (accessor x) setVariable) vectorOfRecords
07:08:31 <Khamal> ertesx: I just want to give the type a context so the type can't be confused with a normal [Int].
07:08:45 <ertesx> vktl: looks fine to me
07:08:46 <vktl> is super slow because the setVariable is large (~ 20,000 values) and the vectorOfRecords is also large (~30,000 values)
07:09:02 <vktl> ertesx it's too slow as is
07:09:28 <ertesx> vktl: are you using Set?
07:09:32 <vktl> yes
07:09:55 <ertesx> vktl: you could try switching to IntSet or HashSet (from unordered-containers)
07:09:59 <vktl> Set and the member field is text
07:10:02 <merijn> vktl: Would it be possible to map items to Int?
07:10:09 <ertesx> vktl: oh yeah, definitely go with HashSet
07:10:23 <mjrosenb> vktl: you can probably get more efficent if the vector is sorted based on accessor x.
07:10:33 <ertesx> Khamal: yeah, using a parametric newtype will help
07:10:48 <ertesx> Khamal: List Int is just as different from [Int] as IntList
07:11:51 <ertesx> vktl: if that doesn't help, you should try to turn your filtering into a partitioning…  that gives you an exponential boost
07:12:14 <vktl> hah, HashSet works without modifying any code! that's great. still too slow though :(
07:13:19 <vktl> mjrosenb how would sorting the vector help?
07:13:28 <ertesx> vktl: if you can construct vector in such a way that your filtering is essentially just a takeWhile, you get that boost
07:13:39 <ertesx> vktl: that's probably what mjrosenb meant, too =)
07:14:02 <athan> When `exitSuccess` or `exitFailure` are called in a forked thread, is the behaviour just set to... echoing the exception?
07:14:17 <mjrosenb> ertesx: vktl: yup.
07:14:26 <vktl> merijin: I could but it would take some bookkeeping boilerplate to keep the mappings straight
07:14:46 <ertesx> vktl: if the property is monotonic (flips from False to True at some point in the vector), you can reduce the problem to binary search
07:14:47 <athan> if so, what would be a good tool for sending non-polling signals in between threads? I'm thinking stm, but I am not sure
07:14:55 <vktl> merijin may do that, but I'd rather not introduce a bunch of types and code for optimization if there's a cleaner way to do it.
07:15:05 <mtesseract> Khamal: If you don't like the "MyList Int" approach, you could also implement e.g. an Functor instance for your newtype, instead of using a lift function.
07:15:23 <athan> (that way my child thread can tell my parent thread "kill me! :c")
07:16:06 <ertesx> mtesseract, Khamal: in the MyList Int approach, the Functor instance (along with others) comes for free, which is the point of using it =)
07:16:37 <mtesseract> ertesx: I agree with you.
07:16:47 <ertesx> @let newtype MyList a = MyList { fromMyList :: [a] }  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
07:16:49 <lambdabot>  Defined.
07:16:57 <ElMoloko> So what's the deal with haskell-lang.org?  and the corresponding new subreddit?  Seems...unnecessary
07:17:12 <ertesx> > fmap (+ 5) (MyList [3,4,5])
07:17:14 <lambdabot>  MyList {fromMyList = [8,9,10]}
07:17:17 <ertesx> > sum (MyList [3,4,5])
07:17:18 <lambdabot>  12
07:17:50 <ertesx> you can even use list syntax with some more extensions =)
07:17:52 <ertesx> @undef
07:17:52 <lambdabot> Undefined.
07:17:59 <ertesx> @let newtype MyList a = MyList { fromMyList :: [a] }  deriving (Eq, Foldable, Functor, IsList, Ord, Show, Traversable)
07:18:00 <lambdabot>  .L.hs:156:51:
07:18:00 <lambdabot>      Can't make a derived instance of ‘IsList (MyList a)’:
07:18:00 <lambdabot>        ‘IsList’ is not a derivable class
07:18:14 <Khamal> mtesseract, ertesx: thanks :) I'm not really sure how to do what you described though. Would i first declare a parametric newtype MyList a = Mylist [a] deriving (...) and then a type IntList = MyList Int?
07:18:25 <vktl> this is one ecosystem gap that needs filling. tabular vector-of-record data-framey manipulations are not great to work with..
07:18:55 <maerwald> Khamal: yeah and then you can even go further and make a smart constructor that ONLY lets you create MyList Int
07:19:02 <maerwald> and not expose MyList constructor
07:19:10 <ertesx> Khamal: you could do that, but personally i'd just write MyList Int
07:19:11 <mtesseract> Khamal: well, you can do that, but note that 'IntList' and 'MyList Int' can be used interchangeable.
07:19:33 <ertesx> Khamal: too much indirection makes your code harder to read
07:20:12 <maerwald> only if the abstraction is not hidden
07:20:54 <ertesx> Khamal: if a function only takes MyList Int, there is no reason to force people to construct MyList Int…  all that is necessary for safety is to make sure that the function receives only MyList Int, and the type system does that
07:21:13 <ertesx> allow people to construct MyList Integer and then fmap fromInteger over it
07:21:21 <ertesx> otherwise you just make them pull their hair out
07:21:44 <athan> ElMoloko: It won't load for me :\
07:21:55 <athan> haskell-lang.org I mean. Haven't seen that one before
07:22:18 <ElMoloko> athan: https://haskell-lang.org/
07:22:29 <ElMoloko> and the subreddit /r/haskell-lang
07:22:31 <vktl> i kind of wonder if i should be using a record of vectors for this stuff instead of a vector of records...
07:22:33 <glguy> haskell-lang is on topic in its own special irc channel
07:22:54 <Khamal> maerwald, ertesx: alright, i think i understand. maerwald what is this smart constructor you were talking about?
07:22:59 <athan> glguy: ? hrm
07:23:05 <ElMoloko> glguy: Oh, sorry :O  I'll go there to learn what's up then
07:23:06 <vktl> hey they finally broke off that haskell-lang thing
07:23:18 <ertesx> Khamal: "smart constructor" really just means "function that produces a value in some restricted fashion" =)
07:23:29 <vktl> oh great https://haskell-lang.org/ and https://www.haskell.org/
07:23:31 <iphy> ghc compiles C code into some temporary directory with files named like ghc_1.s
07:23:46 <ertesx> Khamal: intList :: [Int] -> MyList Int  -- that's a smart constructor
07:23:48 <iphy> I want to compile the C code with test coverage, which outputs ghc_1.gcno files next to them
07:24:00 <Khamal> ertesx: ah ok, easy enough :)
07:24:06 <athan> isn't there a historic alternative haskell channel?
07:24:12 <iphy> how do I get those files back in the place where they should be?
07:24:12 <vktl> i totally get why the industry crowd gets pissed at the cabal cabal, but this is also going to be super confusing for beginners
07:24:27 <Khamal> maerwald, ertesx: thank you very much :)
07:24:40 <glguy> vktl: That's not a universal opinion of the "industry crowd"
07:24:51 <benjwadams> are there libs in Haskell similar to Python's Pandas?
07:25:21 <benjwadams> i.e. dataframes/data manipulation
07:25:21 <merijn> benjwadams: It would help if you described what this python library does
07:25:37 <vktl> glguy roughly... i consider myself more aligned with the "industry crowd" tbh... because well, i'm in industry
07:25:48 <ertesx> vktl: a record of vectors may be faster, unless you bothered to write an Unbox or Storable instance for your Record type
07:25:52 <vktl> benwadams there's frames. but my experience with it hasn't been great.
07:26:14 <benjwadams> sort of sql-like functionality, tables with typed columns, group by, aggregate calculations
07:26:28 <ertesx> vktl: but if your records have many fields, you get terrible memory locality anyway
07:26:43 <vktl> to some extent, lens is sort of filling the dplyr space in terms of working with structure
07:26:50 <benjwadams> I really want to use Haskell for some work projects but the utility of some of the Python data science libs is just too great for me to drop them
07:27:26 <benjwadams> unfortunately i don't feel i have the chops to write some FFI stuff myself
07:27:35 <vktl> benjwadams i'm in a similar position. i use haskell at cost. some things are awesome, but the dataframe manipulation stuff is a pain point for sure
07:28:10 <vktl> you think you can kind of pull it off with <$>, filter, but it's easy to hit rough patches where things aren't efficient.
07:28:18 <ertesx> vktl: since writing Unbox instances is a nightmare, i'd prefer to write Storable instances =)
07:29:04 <vktl> benjwadams watch the space though, I think things are moving in the Haskell for data science world
07:29:20 <merijn> benjwadams: tbh, the FFI is pretty easy to use
07:29:27 <benjwadams> Would definitely be nice to see.
07:29:30 <merijn> benjwadams: Assuming you have some C background
07:29:40 <benjwadams> Only a teeny tiny bit
07:29:51 <vktl> merjin it is relatively easy, even easier with inline-c. but it's not something that you want to be reaching for when doing a one-off data analysis
07:30:01 <benjwadams> haven't really done anything nontrivial in C
07:30:27 <benjwadams> How about Haskell for web apis?
07:30:29 <merijn> benjwadams: It's more of a do you understand things like: object files, linking, symbols, etc.
07:30:41 <vktl> benjwadams i'm working on some of my own contributions. i think haskell could leapfrog python/R in some domains, like web-based data visualization
07:31:21 <benjwadams> merijn: only a bit.  I've played around with gdb tracing through programs, etc
07:31:22 <vktl> benjwadams web dev is great. if you're new, avoid the old monoliths like yesod and snap.
07:31:48 <benjwadams> when i looked two years ago, yesod was newish seeming?
07:31:51 <vktl> jump into the lightweight frameworks. i got started with Scotty / Spock, but now am doing more things in Servant
07:31:58 <vktl> gotta get to work
07:32:13 <mtesseract> vktl: what do you consider to be wrong with Yesod?
07:32:40 <vktl> benjwadams one thing i'm (and a few other people) are working on are libs do use the js visualization ecosystem (plotly, d3) for haskell datavis
07:33:08 <vktl> mtesseract too much monolithic template haskell magic. it's not obvious how to compose chunks of template haskell
07:33:33 <vktl> i actually do use bits of it in conjunction with Servant or Spock - particularly julius because there aren't many options when it comes to js templating.
07:33:38 <athan> How are exceptions propogated through forked threads?
07:34:10 <athan> From what I've seen, each thread independently handles them and is not propogated through to the parent; at least calling ExitSuccess won't kill the parent thread
07:34:14 <vktl> whereas when I use Spock and Servant, I can easily/transparently see how things compose.
07:34:23 <athan> vktl: Elm!!
07:34:40 <vktl> for example declaring endpoints as a monad or type vs. a big hunk of quasiquote
07:34:45 <athan> mtesseract: TemplateHaskell :\
07:34:52 <athan> that's my only gripe, but I don't use it really
07:34:54 <Khamal> ertesx: one last thing. when i declare the newtype MyList i the following error: Can't make a derived instance of ‘Foldable MyList’ . So i added {-# LANGUAGE GeneralizedNewtypeDeriving #-}. But i still get an error, because that apperently doesn't work for foldable. am i missing something? snd error is: Can't make a derived instance of ‘Traversable MyList’        (even with cunning GeneralizedNewtypeDeriving):        You need D
07:35:02 <vktl> athan: yeah i keep flirting with elm, ghcjs, and purescript
07:35:10 <glguy> athan: If you want a better story for exceptions across threads you should look into the "async" package
07:35:15 <athan> vktl: elm has been awesome for me
07:35:22 <vktl> but it's not clear what will win out and after some fiddling I retreat back to javascript
07:35:35 <athan> glguy: I've been staring at it, I'm not sure if it has what I need :\
07:35:54 <athan> Or how about this, how do I interrupt a blocked thread?
07:35:57 <ElMoloko> vktl: I've started using purescript, and it seems more haskell-y than Elm.  How does ghcjs compare?  If I'm doing front-end dev
07:35:58 <vktl> my pages are often for one-off datavis and i'm not sure i'm at the scale where elm would payoff
07:36:14 <athan> like one that's waiting on `getLine`
07:36:24 <vktl> and it seems like elm could plausibly be superceded by ghcjs entirely (at least for my use cases)  within 2 years
07:36:28 <glguy> athan: You can kill the blocked thread with killThread
07:36:31 <Khamal> ertesx: and giving context for the parameter is apperently deprecated...
07:36:46 <ElMoloko> vktl: I thought ghcjs wasn't really in active development anymore
07:36:47 <athan> glguy: What if the blocked thread is the `main` thread? :s
07:36:56 <vktl> elmoloko: the getting-up-and-running story for ghcjs needs work. it sucks to have to download a github repostiroy and rename the project to get going
07:36:58 <bernalex> vktl:since you're in #haskell, I suggest you use ghcjs, and contribute lots upstream. :)
07:37:07 <glguy> Then you'll kill the program doing that. If that's undesirable, don't block the main thread on getLine if you need to be able to kill it
07:37:21 <vktl> elmoloko: oh no it's very active as far as i can tell. reflex + ghcjs demos look very promising (look up the boston hasklell youtube video)
07:37:23 <bernalex> ElMoloko: I don't think that's true.
07:37:34 <athan> glguy: Wait... does `main` have a default ThreadId?
07:37:44 <athan> but okay I think I get the jist
07:37:57 <ertesx> Khamal: i expected GHC to tell you what you need, but apparently it doesn't when GND is on
07:37:58 <bernalex> vktl: personally, I was quite excited about elm, but now I'm decidedly not excited about elm. purescript is nice in so many respects, but ghcjs has the advantage of just being pure haskell.
07:38:03 * athan gets his coding gauntlets
07:38:12 <ertesx> Khamal: you need: DeriveFoldable, DeriveFunctor, DeriveTraversable
07:38:15 <vktl> vernalex i'm waiting for it to stabilize and get to the "just work" phase, then i'll be all over reflex-dom/ reflex/ghcjs
07:38:24 <ertesx> Khamal: and in fact you don't need GND
07:38:39 <bernalex> vktl: I was in the same camp, which was why I was looking a lot at purescript. I read their book, and wrapped my head around it. it looks very nice.
07:38:45 <athan> vktl: Yeah, the build system in elm is sub-par unfortunately, but it's got really nice performance imo
07:38:57 <glguy> athan: I don't know what default ThreadId is
07:39:00 <bernalex> vktl: my solution in the end, though, was to... not do web development. in retrospect, I'm pleased with this decision.
07:39:01 <Khamal> ertesx: ah alright :)
07:39:02 <ertesx> Khamal: Eq, Ord and Show are all derivable by standard, and the extensions i mentioned enable deriving for the respective classes
07:39:12 <vktl> bernalex yeah. purescript is too breaky still, i have a job that i need to get stuff done at. 0.91 broke the whole ecosystem, which is okay with me, but it does mean i cannot be using it for work yet
07:39:17 <ElMoloko> bernalex: vktl: Oh, sweet.  I don't know why I thought that then.  Haskell running on the JS VM is exactly what I've wanted.  Purescript seems very close but just different enough to be annoying for me when switching back and forth
07:39:19 <athan> glguy: Like how init has a default PID of 1 :)
07:39:54 <bernalex> athan: I thought the elm tooling was quite nice. my gripes were on a language design level. I find elm rather offensive.
07:39:55 <vktl> bernalex in terms of user experience and certain ecosystem aspects (like data visualization though), there's just no alternative unfortunately
07:39:55 <glguy> No, there's no well-known ThreadId for it
07:39:58 <glguy> You have to pass ThreadIds around if you need them
07:40:00 <athan> Just use frege and then google's java -> js compiler! :D
07:40:20 <bernalex> vktl: ... javascript?
07:40:21 <vktl> i'm praying ghcjs will catch up to my needs within a year or so...
07:40:33 <Xandaros> vktl: I was actually surprised about how few things I had to change to get my project to work on 0.91 (purescript)
07:40:51 <Xandaros> ghcjs is simply awesome, but generates ginormous code
07:40:52 <athan> bernalex: elm-package isn't well maintained in my eyes. What do you find offensive about the language?
07:40:54 <vktl> bernalex as alternative to ps/ghcjs/elm? yeah that's what i'm going with now
07:41:00 <athan> And are you speaking of version 0.16?
07:41:21 <vktl> xandaros the problem isn't MY code being changed. the problem is all the dependencies i'm pulling in being broken, like purescript-d3
07:41:29 <bernalex> athan: "people are stupid, so we mustn't confuse them by having useful features, or using appropriate language"
07:41:32 <vktl> purescript-flare was broken for a while
07:41:53 <Xandaros> vktl: Well - stay on the old version for a while and use upper version bounds :P
07:41:53 <vktl> anyway, it's fine, i get that young languages can't be to rigid
07:41:58 <bernalex> athan: they are optimising for javascript converts and their first week of adopting the language. which means things like ad-hoc polymorphism don't exist, because they think people are too stupid to get it.
07:42:05 <vktl> but it just means i can't use it
07:42:05 <athan> bernalex: I definitely see that :\ it's pandering to the crowd
07:42:23 <athan> nor guards haha
07:42:27 <vktl> xandaros well... it sucks writing a bunch of code knowing it's already broken :(
07:42:30 <Xandaros> I personally use ghcjs for my web projects and I'm quite happy with it. But as I said - code is giant
07:42:55 <bernalex> athan: language designers like that treat hkr like they used to treat first class functions in the '80s and '90s. "no, people are too stupid to get it, mustn't confuse people."
07:43:18 <athan> I've at least found it to be fast :\
07:43:32 <athan> I'm actually hoping to make a port of elm some day
07:43:33 <vktl> hkr?
07:44:14 <athan> Call it birch, catchphrase "birch please!"
07:44:28 <Xandaros> vktl: What's your complaint about ghcjs?
07:44:33 <ElMoloko> athan: haha Frege is fun...but unbearably slow, all the times I've used it.  I tried using it for some enterprise JVM stuff and was laughed out of the room
07:44:50 <athan> :( ow, sorry to hear ElMoloko 
07:45:06 <bernalex> athan: oh, it is fast. and compared to javascript, it's a *much* nicer language. and if it gets truly stable and adds a nice tools and packaging story, it demolishes javascript. it will even be a better choice than purescript and ghcjs if it does well in the tooling and packaging department.
07:45:08 <hpc> you could make it like that polite dialect of cobol where every command is prefixed with "please"
07:45:10 <athan> Dang, and I heard some good things about it
07:45:13 <hpc> "wood you kindly"
07:45:16 <bernalex> vktl: higher kinded ranks.
07:45:39 <athan> bernalex: :)
07:45:44 <bernalex> ElMoloko: there's a hsoc project for pure haskell on jvm
07:45:46 <vktl> xandaros the setup experience isn't great. to get going i used to have to cloen a github template project and change the project name
07:45:53 <vktl> then there's this awkward nightly versioning thing
07:45:53 <athan> Yeah I actually asked for existential quant. and they just kinda stared at me
07:45:59 <maerwald> Xandaros: primary goal of ghcjs is to produce unreadable monster output
07:46:01 <maerwald> :P
07:46:03 <athan> through.. a chat room..
07:46:04 <Xandaros> github template project?
07:46:15 <chindy> how would a generic Tailrecursive legnthOfList function in haskell look like ?
07:46:19 <ElMoloko> bernalex: do you have a link? genuinely curious
07:46:30 <vktl> gotta get to work for now... but would love to talk later
07:46:34 <bernalex> ElMoloko: no. I just read the emails about it.
07:46:44 <Xandaros> vktl: What Github template project?
07:46:56 <athan> chindy: lengthOfList [] = 0; lengthOfList (_:xs) = 1 + lengthOfList xs
07:47:01 * athan right?
07:47:06 <vktl> xandaros  a while ago there was like a reflex-starter project
07:47:10 <athan> er
07:47:15 <bernalex> ElMoloko: https://www.reddit.com/r/haskell/comments/4kp6zg/summer_of_haskell_2016_accepted_projects/?st=iqduve6p&sh=2ef2de23
07:47:16 <vktl> (note i'm using stack)
07:47:16 <chindy> athan,  that does not look tailrecusrive to me
07:47:21 <bernalex> ElMoloko: "GHCJVM".
07:47:23 <Xandaros> vktl: That's entirely optional, though. I set up my own reflex project
07:47:35 <vktl> anyway, gotta run for now
07:47:36 <vktl> ttyl
07:48:04 <ElMoloko> bernalex: oh nice, prominent mentors for that :)
07:48:08 <athan> > getSum $ foldMap (Sum . const 1) "something funny"
07:48:10 <lambdabot>  15
07:48:28 <athan> chindy: I'm not sure if you can make it "tail recursive" in the sense you avoid pattern matching
07:49:36 <athan> thanks glguy btw! Always helping whenever I see you :)
07:50:51 <chindy> no but i got what i found... was wondering how you can do an ocaml like let-in in haskell... aparently the where construct is what i was looking for
07:51:12 <glguy> athan: You're welcome
07:51:38 <ertesx> i really wouldn't want to use GHCJS without nix
07:51:50 <ertesx> perhaps it's a smoother experience with stack
07:52:06 <ertesx> but plain GHCJS…  i wouldn't even know how to install it
07:52:27 <maerwald> ertesx: cabal install
07:52:56 <hpc> my experience with stack so far has been that if stack is capable of doing it, it's smoother than the alternatives
07:53:01 <hpc> but you get put on rails a bit
07:53:06 <dolio> How is an OCaml let-in different from a Haskell let-in?
07:53:36 <mnoonan> dolio: ocaml's let isn't recursive, I think
07:53:42 <ertesx> maerwald: i prefer not having to compile that one
07:53:53 <maerwald> aha
07:54:01 <dolio> Oh, yeah, that's true.
07:54:22 <dolio> I'm not sure why that would matter in this case.
07:54:32 <luite> ertesx: it's not as impossible as it used to be, especially if you get one of the snapshots that includes the libraries (you can build one by running 'cabal sdist' or get one from http://ghcjs.luite.com/ )
07:54:33 <mnoonan> just the only difference I could think of :)
07:55:14 <luite> ertesx: the ghc-8.0 branch is a bit unstable though
07:55:18 <ertesx> luite: i still prefer not to do that…  compiling GHC or any similarly sized codebase is off-putting enough =)
07:55:20 <luite> since it's very new
07:55:41 <luite> ertesx: yeah nix is very useful for that still, and for having reproducible build environments in general
07:55:49 <ertesx> luite: BTW, while you're here…  do you think, output sizes will shrink in the foreseeable future?
07:55:57 <luite> yes
07:56:34 <athan> holy tamole async is way more awesomer than I thought
07:57:14 <luite> ertesx: that'll be my main focus for a while once the ghc-8.0 branch is in workable state
07:57:32 <ertesx> luite: any estimations on how small it can get?  and how well does dead code elimination work currently?
07:59:03 <luite> ertesx: dead code elimination is already pretty good for the haskell bits. the main improvements should come from getting rid of the ridiculous amount of duplication in the generated code and a better way of dealing with names
08:00:18 <ertesx> i see
08:00:49 <luite> ertesx: although i've been thinking of adding a profile guided lazy loading mode, where the code is split into a part that's loaded immediately to let the app show the first results, and the remainder (possibly multiple parts), loaded in the background
08:01:34 <ertesx> luite: that would be awesome…  on firefoxes on smaller hardware the initialisation time is noticable
08:03:27 <luite> ertesx: definitely, other js engines too. but i think there's still enough to be gained from general code generator improvements. the profilign step would add extra complexity to the build process
08:04:29 <luite> but i'm taking a possible future addition of lazy loading into account when making the current improvements to the code generator and prettyprinter
08:05:56 <Xe> What would be the haskell analogue to https://godoc.org/strings#SplitN ?
08:06:12 <ertesx> luite: i'm looking forward to it =)
08:06:25 <bollu1> quick question guys
08:06:43 <bollu1> if I have a project (cabal) that builds both a library and an executable
08:06:50 <bollu1> can I upload only the libtaty?
08:06:52 <bollu1> onto hackage?
08:06:58 <ertesx> Xe: for text strings there is 'split'
08:07:01 <ertesx> :t T.split
08:07:02 <lambdabot>     Not in scope: ‘T.split’
08:07:03 <lambdabot>     Perhaps you meant one of these:
08:07:03 <lambdabot>       ‘S.split’ (imported from Data.Set),
08:07:06 <bollu1> I want to only upload the library to hackage, with docs and everything
08:07:10 <ertesx> :t Data.Text.split
08:07:11 <lambdabot> (Char -> Bool) -> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
08:07:14 <bollu1> but I don't want the executable (I'm using the executable locally)
08:07:25 <bollu1> I don't want the exe to be uploaded to hackage*
08:07:42 <bollu1> so when I build the cabal tarball, can I control what goes into it?
08:07:59 <ertesx> Xe: there is also splitOn, if you want to split on substrings
08:08:17 <ertesx> Xe: the other features aren't necessary, as you get them by virtue of laziness (use 'take', etc.)
08:08:17 <geekosaur> only source goes into it, not generated libraries/executables
08:08:39 <bollu1> geekosaur: right, but I don't want the source code of the other executable I'm building to go into hackage?
08:08:47 <bollu1> geekosaur: I want only the library related files
08:09:16 <ertesx> bollu1: if you don't want the source code to go on hackage, make a separate package for the executable
08:09:25 <geekosaur> then you'd need to switch out the cabal file to one that doesn't have the executable stanza. or that
08:09:25 <bollu1> ertesx: ah, so that's the only way?
08:09:27 <bollu1> ertesx: bummer
08:09:30 <ertesx> bollu1: if you just don't want it to build by default, you can have that with a flag
08:09:45 <bollu1> ertesx: I see. I'll try it out
08:09:47 <ertesx> oh yeah, geekosaur's solution works, too
08:09:53 <bollu1> geekosaur: how do I do that?
08:10:23 <geekosaur> manually?
08:10:43 <ertesx> bollu1: you can just comment out the exectuable stanza before uploading
08:10:49 <ertesx> (before sdisting rather)
08:10:53 <bollu1> geekosaur: :) oh right. I thought there was some tooling support
08:10:55 <geekosaur> if it is not yet clear, you are asking for something that the build infrastructure does not support
08:11:13 <bollu1> geekosaur: right, when you spell it out exactly it makes sense I guess
08:11:24 <bollu1> geekosaur: so recommendation is to split it out right?
08:12:27 <geekosaur> yes
08:12:39 <ertesx> bollu1: make a separate file or comment the executable section out
08:22:56 <JordiGH> What's going on with haskell-lang.org?
08:23:00 <JordiGH> Are people angry with each other?
08:23:14 <alercah> probably
08:23:27 * hackagebot safe-exceptions 0.1.2.0 - Safe, consistent, and easy exception handling  https://hackage.haskell.org/package/safe-exceptions-0.1.2.0 (MichaelSnoyman)
08:23:34 <mattro> JordiGH: drama brewing
08:23:41 <mattro> i'm putting some popcorn on now
08:23:53 <JordiGH> Popcorn with brew?
08:24:08 <TheMystic> JordiGH: ohai
08:24:11 <Xe> ertesx: yes, but i want to say like `splitN "7:net_cls,net_prio:/" ":" 2` and have the result be everything after the second colon even if a colon is present after the second one
08:24:34 <JordiGH> TheMystic: What's going on, man?
08:24:39 <JordiGH> Is there tension, stability?
08:24:50 <maerwald> JordiGH: what do you mean?
08:25:00 <JordiGH> Do Haskeller Lives' Matter? Do all Hacker Lives Matter?
08:26:23 <ertesx> Xe: ah, i see…  you could use dropWhile and uncons twice
08:26:31 <ertesx> @let import qualified Data.Text as T
08:26:32 <lambdabot>  .L.hs:121:1:
08:26:33 <lambdabot>      Data.Text: Can't be safely imported!
08:26:33 <lambdabot>      The package (text-1.2.1.3) the module resides in isn't trusted.
08:26:37 <ertesx> seriously?
08:26:55 <JordiGH> Wait, is this about using Stack instead of cabal?
08:27:29 <maerwald> it's an annoying debate
08:28:19 <JordiGH> I use apt myself.
08:28:21 <shapr> JordiGH: it's all good
08:28:28 <ertesx> Xe: let f = fmap snd . T.uncons . T.dropWhile (/= ':') in f >=> f
08:28:33 <shapr> JordiGH: people making awesome things with Haskell
08:28:35 <JordiGH> I'm old and I like old software.
08:28:38 <JordiGH> So, apt.
08:28:46 <shapr> JordiGH: You writing any cool Haskell code at the moment?
08:28:48 <ertesx> Xe: 'f' drops everything up to the first ':', and you just apply it twice
08:28:53 <TheMystic> its appearance on hacker news will no doubt help the situation</sarcasm>
08:28:54 <ertesx> up to and including
08:28:55 <JordiGH> shapr: Cool in my eyes.
08:29:01 <shapr> JordiGH: ooh, what is it?
08:29:09 <JordiGH> A Newton fractal generator.
08:29:14 <shapr> wow, that sounds very cool
08:29:15 <JordiGH> Well, just the data.
08:29:17 <Xe> ertesx: ineresting
08:29:21 <JordiGH> Still haven't figured out how to visualise it with Haskell.
08:29:24 <shapr> JordiGH: is your code on github?
08:29:28 <JordiGH> I don't use git.
08:29:31 <JordiGH> So, no.
08:29:34 <shapr> is your code on darcshub?
08:30:05 <JordiGH> I use hg. But I haven't published this fractal generator yet. It's in my home computer. Your interest has made me think perhaps I should publish it later.
08:30:43 <shapr> JordiGH: I would like to see it, are you using parallel libs or CUDA or OpenCL or anything?
08:30:46 * S11001001 high-fives JordiGH
08:31:12 <JordiGH> No, newton fractals are not very resource-intensive. At least, the naïve one that doesn't zoom in isn't.
08:31:29 <athan> accelerate :|
08:31:43 <JordiGH> I've never tried to understand what kind of dark magic Xaos does. Its source code even says you shouldn't try to undersand it and has a ASCII dragon art to keep you away.
08:31:56 <shapr> athan: I got it to build with stack, but I couldn't get accelerate-examples to build
08:32:15 <athan> shapr: noooooo :( I'll have to mess with it
08:32:35 <ertesx> what is haskell-lang.org?  is someone trying to split the community?
08:32:52 <shapr> athan: my new laptop has a somewhat powerful nvidia card, so I want to try accelerate's cuda backend
08:33:04 <athan> I have been leering at it for years, finally have enough chops to work with it I think
08:35:00 <athan> :) CUDA powered typechecking...
08:35:13 <shapr> athan: that would be SO COOL
08:35:29 <athan> CUDA port of GHC :|
08:35:41 <shapr> ok now you're getting crazy
08:40:36 <JordiGH> I misremembered, no ASCII dragon: https://github.com/xaos-project/XaoS/blob/master/src/engine/formulas.c#L27
08:41:03 <JordiGH> shapr: I work on Octave, so my whole goal is to make sure we can compute freely. nvidia works against that.
08:41:23 <JordiGH> CUDA >:|
08:41:32 <shapr> JordiGH: yeah, I see what you mean, OpenCL is friendlier
09:05:16 <bernalex> shapr: hiya! how are you?!
09:05:23 <bernalex> ertesx: yes.
09:07:19 <ertesx> bernalex: yes?  remind me…
09:07:40 <bernalex> ertesx: RE: the last thing you said.
09:07:58 <ertesx> ah
09:08:17 <ertesx> short-term memory of a cat =)
09:08:28 * hackagebot wai-transformers 0.0.7 - Simple parameterization of Wai's Application type  https://hackage.haskell.org/package/wai-transformers-0.0.7 (athanclark)
09:12:59 <athan> Anyone here ever get the "threadWait: invalid argument (Bad file descriptor)" message / non-hazardous exception when using `forkIO`?
09:16:39 <maerwald> bernalex: who?
09:17:37 <bernalex> maerwald: I'm not sure what you are referring to.
09:17:53 <maerwald> bernalex: the last thing you said
09:19:04 <bernalex> maerwald: the last thing I said was explaining to ertesx what I was replying to. are you thinking about the actual reply? if so: the usual people. but I don't really think it's worth discussing in here.
09:20:14 <maerwald> bernalex: ah, I see, https://github.com/haskell-lang/haskell-lang/graphs/contributors
09:23:11 <nitrix> How complicated would it be to get superclasses in Haskell?
09:23:22 <athan> nitrix: ??
09:23:26 <nitrix> More precisely, make Semigroup a superclass of Monoid.
09:23:38 <athan> I thought that was part of 8.0! >:O
09:23:47 <nitrix> Oh realy!?
09:23:50 * nitrix checking
09:24:29 <dfeuer> How does NOINLINE affect strictness analysis? It kind of smells like the strictness analysis ignores strictness of things marked NOINLINE. Is that so?
09:25:19 <dfeuer> nitrix, no, it's not yet. But there's a roadmap.
09:25:50 <dfeuer> 8.0 got Semigroup in base. I think something else is happening in 8.2, and it should all be finished by .... 8.4, maybe?
09:26:13 <athan> nitrix: Hmm... https://ghc.haskell.org/trac/ghc/ticket/11139
09:26:22 <athan> I think they're looking for backwards compatability for now
09:26:31 <dfeuer> But really, can anyone help with this strictness analysis question?
09:26:37 <athan> dfeuer: Oh wow! That's a step at least
09:26:39 <nitrix> Crazy.
09:26:44 <nitrix> athan: Thanks
09:26:54 <athan> :)
09:28:48 <athan> maerwald: Those are some big names :|
09:28:58 * athan sidejabs haskell ninjas
09:34:39 <ElMoloko> oh man ghcjs actually works
09:34:46 <ElMoloko> i can build things off hackage
09:34:50 <ElMoloko> this is amazing
09:36:15 <Xe> ertesx: what is that pointful?
09:36:39 <Xe> i have been trying to work it out by hand for a while
09:36:48 <Xe> and all I got was `fmap (snd . T.Uncons . T.dropWhile) (/= ':')`
09:36:51 <c_wraith> :t join @[]
09:36:52 <lambdabot> Pattern syntax in expression context: join@[]
09:37:06 <c_wraith> ...  lambdabot really needs that extension
09:37:32 <jle`> is lambdabot on 8.0 yet?
09:37:48 <c_wraith> I don't even know if it's got that.
09:38:18 <jle`> :t foo True
09:38:19 <lambdabot>     Not in scope: ‘foo’
09:38:19 <lambdabot>     Perhaps you meant ‘for’ (imported from Data.Traversable)
09:38:23 <jle`> looks like a 7.8 error message
09:39:04 <jle`> 8.0 would have said "Variable not in scope: foo :: Bool -> t"
09:39:16 <c_wraith> what happened to 7.10? :P
09:39:40 <jle`> *7.10 :p
09:40:07 <Tene> @pointful fmap (snd . T.Uncons . T.dropWhile) (/= ':')
09:40:07 <lambdabot> fmap (\ d -> snd ((T.Uncons) (T.dropWhile d))) (\ a -> a /= ':')
09:40:12 <Tene> Xe: ^
09:40:32 <Xe> Tene: TIL
09:40:56 <saurabhn_> (yesod + cabal newbie alert) -- here's my cabal file with a build error: http://lpaste.net/169315 Individual files compile in intero/emacs. But 'stack build' is unable to complete the build due to weird package missing errors.
09:41:08 <saurabhn_> any pointers on how to fix this?
09:43:58 <Khamal> Is there a recursive map datastructure? Like newtype RecMap a = Map a RecMap. It's kind of like a tree. Is there a name, or an implementation for that?
09:44:01 <sm> joining #haskell-blah with erc or webchant.freenode.net gives: Only users using SSL could join this channel ?
09:44:14 <maerwald> sm: join #haskell-offtopic instead
09:44:27 <maerwald> it doesn't force silly things on users and is community-driven
09:44:42 <JordiGH> Wait, does that work? Freenode's ircd can ensure that only SSL connections come in?
09:44:46 <sm> oh. Drama in the overflow channels too. :)
09:44:59 <JordiGH> Encryption isn't silly. :-(
09:45:12 <JordiGH> sm: Why *aren't* you using TLS?
09:45:24 <JordiGH> All you have to do is connect to a different port number.
09:45:29 <bernalex> JordiGH: lol yeah encrypting traffic to and from public chat channels is imperative
09:45:45 <JordiGH> bernalex: Why wouldn't you do it?
09:45:53 <JordiGH> There's no reason not to encrypt.
09:45:54 <c_wraith> bernalex: encrypting traffic to and from irc is quite useful, though.
09:45:56 <sm> JordiGH: can you say how to do that, with erc or webchat.freenode.net ?
09:46:13 <bernalex> JordiGH: well, one reason is so that lambdabot works.
09:46:19 <JordiGH> sm: Hm, I don't know about erc.
09:46:20 <c_wraith> Khamal: depending on your use case, something like Cofree might be what you're looking for.
09:46:32 <athan> Anyone here ever get the "threadWait: invalid argument (Bad file descriptor)" message / non-hazardous exception when using `forkIO`?
09:46:56 <JordiGH> bernalex: You mean nobody's implemented TLS for lambdabot?
09:47:05 * sm is shocked, shocked
09:47:26 <JordiGH> sm: M-x erc-tls; irc.freenode.net 6697
09:47:48 <sm> JordiGH: thanks! I'll give it a try 
09:48:55 <c_wraith> Khamal: the type you specified is a bit odd - it doesn't quite fit into Cofree neatly, though it can be squeezed in uncomfortably.
09:49:08 <c_wraith> Khamal: so I'm curious what information you want at each level.
09:49:57 <Khamal> c_wraith: I'm trying to build a location tree. Something like 'world' -> ('america', 'eu', 'asia'), 'eu' -> ('france', 'germany'), 'germany' -> ('munich', 'berlin', 'hamburg'). Which is a tree with unique children. so chilren should be a set not a list. or i think a recursive map should work too. any idea what i could use?
09:51:24 <c_wraith> Khamal: Hmm.  is there any chance you'll ever want to annotate your nodes with additional information?
09:52:13 <Khamal> c_wraith: not really. but what are you thinking of?
09:53:42 <c_wraith> Cofree (Map k) v gives you a tree with nodes distinguished by name at each level, and each node is decorated with some additional info of type v
09:54:19 <c_wraith> (that's from Control.Comonad.Cofree in the free package)
09:54:55 <c_wraith> I guess the root is also decorated with a v value
09:55:56 <Khamal> hm could be useful. but i'm not really a fan of the overhead :/
09:56:13 <c_wraith> The overhead is mostly in the form of lots of useful instances. :P
10:03:43 <Khamal> c_wraith: wow the cofree documentation looks super complex
10:04:17 <c_wraith> Khamal: Well.  yes.  The idea to even look into it came out of category theory.  There's a lot of category theory in its documentation because of that.
10:05:05 <c_wraith> Khamal: Fortunately, it's not all that complicated to use.  It's a pretty simple data type with a few helpful functions and instances.
10:05:30 <c_wraith> Khamal: And the monad instance.  Which is weird and not at all helpful for nearly any use case. :)
10:05:41 <shachaf> i,i pretty simple codata type
10:06:12 <c_wraith> sure.  but haskell conflates them, so I will continue to beligerantly conflate them as well
10:06:23 <Khamal> c_wraith: I'm afraid I'm too dumb to get how to use it. I haven't really understood what monads are yet. Let alone comonads.
10:07:02 <c_wraith> Khamal: Ah, if you want to stay maximally simple, just use the newtype you started with.
10:07:22 <ertes> c_wraith: i have a pull request against 'free' that would make the Monad instance very useful, but it never got merged
10:07:44 <ertes> c_wraith: the way to make it useful is to replace the 'Alternative' context by a 'Plus' context
10:07:59 <ertes> now Cofree and CofreeT are generic "reentry" monads
10:08:01 <c_wraith> ertes: changing an instance's semantics is a dangerous operation.  I can see why it wasn't accepted, even if it's clearly better.
10:08:11 <ertes> c_wraith: it's not a change in semantics
10:08:24 <c_wraith> Oh.  Then I don't know. :)
10:08:56 <ertes> Plus is more generic than Alternative, allowing things like Map and HashMap to be instances
10:09:13 <Khamal> c_wraith: but then i'll have to define instances for folable traversable and functor, won't i?
10:09:39 <c_wraith> Khamal: that type can't be any of those anyway.
10:09:52 <c_wraith> Khamal: because Map operations place an Ord restriction on the key type
10:10:05 <c_wraith> Khamal: and those classes don't allow that
10:10:46 <ertes> c_wraith: to see that in action, see my old 'continue' library…  it allows you to write interactive applications in an interaction style, even when the underlying protocol is delimited like HTTP or e-mail
10:11:46 <Khamal> c_wraith: you're right, are there unordered map operations? the order shouldn't really matter, should it?
10:11:50 <EvanR> Map can be Foldable Traversable and Functor
10:12:05 <c_wraith> EvanR: not a recursive map of the type Khamal initially defined
10:12:16 <c_wraith> EvanR: because its only type variable is the key type
10:12:42 <c_wraith> Khamal: Not to guarantee uniqueness at each level.  The best you can do without that guarantee is a list
10:12:45 * EvanR checks what Khamal is talking about
10:13:02 <c_wraith> newtype RecMap a = Map a (RecMap a)
10:13:08 <c_wraith> err.
10:13:15 <c_wraith> newtype RecMap a = RecMap (Map a (RecMap a))
10:13:39 <ertes> Fix (Map a)?
10:13:48 <c_wraith> Oh, that would do it.
10:14:00 <Khamal> what?
10:14:08 <c_wraith> I guess that type *can* be Foldable
10:14:14 <c_wraith> Just not Functor or Traversable
10:14:19 <ertes> it can't be
10:14:43 <ertes> Cofree can be Foldable, and a custom type can be
10:14:55 <EvanR> hehe Khamal wants a Map k (Set k) and c_wraith suggested Cofree ;)
10:15:05 <ertes> hah
10:15:09 <ertes> sounds like a graph
10:15:11 <EvanR> and were getting into category shit
10:15:12 <c_wraith> EvanR: no, recursive.  Not just two levels
10:15:54 <EvanR> ah the example didnt indicate that
10:17:05 <ertes> hmm, going back and reading the problem description i'm not sure either whether what Khamal needs has to be recursive
10:17:12 <EvanR> Fix (Map k)
10:17:30 <ertes> s/has/it/
10:17:44 <Khamal> it's not really a graph, it's more like tree with unique children
10:18:03 <ertes> Khamal: what does that mean?
10:18:05 <EvanR> or the RecMap newtype, thats what i woulda thought of
10:18:09 <c_wraith> trees are just graphs where all nodes have an INCOUNT < 2
10:18:29 <EvanR> its not a graph because "america" at one level isnt the same america lower down
10:18:36 <ajf> to whoever told me of using the ExceptT monad transformer yesterday or perhaps the day before, thank you
10:18:40 <Khamal> no, graphs can have cycles.
10:18:54 <c_wraith> right, acyclic with low incounts.
10:18:57 <ertes> Khamal: "unique" as in "found nowhere else in the map"?
10:19:13 <EvanR> among children
10:19:18 <Khamal> ertes: no unique at each level
10:19:31 <samba1_> I have an IO action that takes no parameters and returns either Success or Failure, with no further information needed. For the sake of argument, let's say it just randomly returns Success or Failure like a heads or tails. Doesn't matter.
10:19:32 <EvanR> unique at each level doesnt sound like the right description
10:19:35 <samba1_> I'd like to run this repeatedly until a Success is received. So, I was thinking of how to do that. Alternative jumps to mind, but Success | Failure doesn't have the right kind to be an Applicative, and IO isn't a MonadPlus so I can't wrap the whole thing in WrapMonad.
10:19:39 <c_wraith> labeled edges! :P
10:19:39 <samba1_> Monoid (or even just Semigroup) is pretty much a *-kinded Alternative, so I could make Success | Failure an instance of one of those, but then once it's wrapped in IO I lose it and have to do some rigamarole to get under the covers. I can no longer do something as simple as sconcat / mconcat [list, of, succeeding, or, failing, actions]. I could wrap up the whole thing in a newtype which is also a Semigroup and does the IO bit (Wrapper 
10:19:46 <samba1_> I've made it work with an ExceptT IO, with the inner bit just being Either () (). But I feel I should be able to move from a pointless Either () () to something better like Success | Failure.
10:19:46 <shachaf> Haskell trees can be cyclic.
10:19:50 <samba1_> And yes, I'm probably overthinking this and could just do this with a foldM and a case statement, but I feel I should be able to use some of this typeclass plumbing.
10:20:02 <ertes> Khamal: like a "rose tree"?
10:20:05 <shachaf> By which I mean infinite, of course.
10:20:07 <ertes> (i hate that name)
10:20:19 <EvanR> a rose tree with unique children
10:20:35 <Khamal> EvanR: yup you're right. 
10:20:58 <Khamal> like a Tree a = Node a (Set (Tree a))
10:21:19 <EvanR> thats not right either
10:21:26 <Khamal> is it not?
10:22:11 <EvanR> maybe it is right... though its weird to compare the whole subtree
10:22:16 <ertes> i'm back to Fix (Map a)
10:22:33 <ertes> :k Fix
10:22:34 <lambdabot> Not in scope: type constructor or class ‘Fix’
10:22:35 <EvanR> i figured you meant just the sibling strings are unique
10:22:42 <Khamal> EvanR: right again
10:22:58 <ertes> @newtype newtype Fix f = Fix { fromFix :: f (Fix f) }  deriving (Eq, Ord, Show)
10:22:58 <lambdabot> Unknown command, try @list
10:22:59 <Khamal> ertes: what is Fix?
10:23:03 <ertes> @let newtype Fix f = Fix { fromFix :: f (Fix f) }  deriving (Eq, Ord, Show)
10:23:04 <lambdabot>  .L.hs:156:25:
10:23:05 <lambdabot>      No instance for (Eq (f (Fix f)))
10:23:05 <lambdabot>        arising from the 'deriving' clause of a data type declaration
10:23:16 <c_wraith> samba1_: I don't think you really get anything out of most classes for that case.  Just write the recursive loop.  use the monad-loops package and its whileM or untilM functions
10:23:36 <ertes> Khamal: wait, i'll define it in privmsg
10:23:39 <EvanR> Khamal: Fix is another way to say newtype RecMap k = RecMap (Map k (RecMap k))
10:23:45 <johnw> wouldn't Fix (Map a) only allow you to encode structure, but never leaves?
10:23:56 <c_wraith> johnw: that's what wanted..  a structure of keys.
10:24:45 <ertes> johnw: a "leaf" is just a key with an empty target map
10:25:34 <ertes> Khamal: ok, there it is
10:25:38 <ertes> @src Fix
10:25:39 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
10:25:42 <ertes> oh, come on
10:25:51 <Khamal> thanks, for the help btw. i've been thinking about a data structure for this the past two days, but i can't seem to come up with something satisfying
10:25:53 <ertes> newtype Fix f = Fix { fromFix :: f (Fix f) }
10:26:26 <ertes> Khamal: if you look at the essence of that definition, you will find:  Fix f ≃ f (Fix f)
10:26:49 <ertes> Fix (Map k) ≃ Map k (Fix (Map k)) ≃ Map k (Map k (Fix (Map k)))
10:26:50 <ertes> etc.
10:27:01 <ertes> Fix (Map k) ≃ Map k (Map k (Map k (Map k …
10:27:12 <Khamal> i'll have a closer look at this
10:27:17 <johnw> indeed, if you start with f x = x, then swap to x = f x, then set x = fix f, you get fix f = f (fix f)
10:28:26 <ertes> Khamal: practically speaking you will have to wrap and unwrap the Fix stuff, but it basically gives you an infinitely recursive Map
10:29:39 <ertes> @let fmFromList = Fix . M.fromList
10:29:41 <lambdabot>  Defined.
10:30:18 <ertes> @let fmLeaf x = M.singleton x (Fix mempty)
10:30:19 <lambdabot>  Defined.
10:30:51 <EvanR> the Map here is really for the unique constraint, if you consider this one of the kinds of constraints you have to ensure through care instead of technology, its as simple as a rose tree
10:31:14 <EvanR> in SQL i dont think you have the ability to say this constraint, but otherwise its pretty easy
10:31:59 <ertes> one drawback of SQL is that you can't traverse
10:32:05 <EvanR> if it simplifies other stuff enough, then dropping techno guarantees of constraints might be good
10:32:29 <c_wraith> ertes: some database engines provide extensions that allow recursive queries.
10:33:32 <Khamal> we are currently doing recursive sql querys in my database course at uni :)
10:34:17 <hpc> are recursive queries different from nested queries?
10:34:29 <c_wraith> yes
10:34:42 <Khamal> yes
10:34:46 <hpc> crazy
10:35:33 <frontendloader> if you mix the two together
10:35:38 <frontendloader> CYA RAM
10:38:29 <Khamal> ertes: doesn fm in fmLeaf stand for Fix Map?
10:40:59 <cheater> hello
10:41:24 <cheater> i don't understand how fix (and mfix) work, could someone help me figure this out?
10:41:38 <johnw> fix is much easier to begin with
10:41:44 <cheater> i bet
10:41:57 <johnw> it calls a function, passing that function itself as the first argument
10:42:06 <johnw> so, fix f becomes f (f (f (f (f ...))))
10:42:23 <johnw> the only way it ends is if `f' decides not to use that argument, or uses it lazily
10:42:28 <ertes> hpc: recursive queries basically give you 'fix' for SQL
10:42:48 <ertes> Khamal: yeah
10:43:03 <c_wraith> I've only ever used mfix in IO, and mfix in IO is a terrible hack.  :)
10:43:21 <hpc> ertes: yeah, was just reading up on them
10:43:27 <ertes> cheater: when you write "fix (\r -> stuff)", then "r" is just the same as "stuff"
10:43:28 <hpc> they seem neat
10:43:37 <hpc> mysql doesn't have them but everything else does lol
10:43:52 <EvanR> "r" is the same as (\r -> stuff)
10:44:00 <ertes> cheater: example: fix (\x -> 1 : x), now x = 1 : x
10:44:02 <hpc> no, r = stuff
10:44:12 <EvanR> er
10:44:18 <ertes> cheater: so that's 1 : 1 : 1 : 1 : …
10:44:25 <hpc> fix (\x -> expr) is the same as (let x = expr in x)
10:44:46 <nitrix> That might sound like a strange requirement, but is there a convenient syntax to initialize all the fields in a record by the same value?
10:44:56 <nitrix> The value in question is overly polymorphic exactly for that purpose.
10:45:04 <EvanR> nitrix: the Applicative instance? pure?
10:45:06 <ertes> nitrix: if your record type is of a certain shape, you can use 'pure'
10:45:26 <nitrix> Currently, it looks like    Sources <$> newAddHandler <*> newAddHandler <*> newAddHandler ...
10:45:30 <nitrix> It's a litle repetitive.
10:46:01 <ertes> nitrix: if Sources is both Traversable and Applicative, you can just write:  sequenceA (pure newAddHandler)
10:46:08 <cheater> hm
10:46:10 <johnw> cheater: a normal function using fix can do the same work as a recursive function not using fix
10:46:12 <EvanR> which definition of fix makes fix (\x -> stuff) implies x = stuff obvious
10:46:33 <ertes> EvanR: fix f = let x = f x in x
10:46:49 <ertes> that's also the base definition, because it has better sharing than the obvious definition
10:47:11 <hpc> a sometimes more clear definition is
10:47:19 <hpc> fix f = f (fix f)
10:47:24 <EvanR> so fix converts lambda arrows to equal signs ;)
10:47:48 <johnw> EvanR: wut?
10:47:49 <c_wraith> as I said in another channel this morning..  fix is begging the question, wrt Curry-Howard
10:47:58 <hpc> the first definition shows the relationship between fix and recursive let-definitions
10:48:04 <cheater> why doesn't this converge? fix (\x -> let out = 1+1/x in if (x - out) < 0.001 then x else out)
10:48:04 <EvanR> \x -> stuff ==> x = stuff
10:48:24 <ertes> cheater: here is a nice way to make practical use of 'fix' to see what i mean:  main = fix $ \again -> do putStrLn "Hello again!"; again
10:48:28 <hpc> the second definition makes it easier to expand expressions in your head
10:48:44 <ertes> cheater: 'again' in that example refers to everything after '->'…  so it just refers to the program
10:49:05 <cheater> i don't know what ";" means there
10:49:06 <EvanR> @src forever
10:49:06 <lambdabot> forever a = let a' = a >> a' in a'
10:49:08 <cheater> oh it's in do
10:49:08 <cheater> ok
10:49:16 <hpc> cheater: that function is always strict in x
10:49:28 <cheater> how do i make it non-strict?
10:49:35 <c_wraith> You can't, with that definition
10:49:44 <c_wraith> It has to examine its input to determine its output
10:49:47 <cheater> yes
10:49:57 <cheater> the idea is if there's another definition that does something like this
10:50:32 <ertes> cheater: you can't have a running variable that way
10:50:46 <EvanR> so thats a continued fraction, its necessarily infinite because you cant check the final value to decide to stop
10:50:46 <ertes> cheater: fix (\again x -> …) x0
10:51:08 <ertes> cheater: now 'again' is a function that takes the next x
10:51:21 <ertes> and x0 is the initial value
10:51:41 <EvanR> theres a better way than using fix for this, it turns out you can write any loop with fix, but its not always the most clear
10:51:46 <ertes> > fix (\again x -> if x < 10 then x : again (x + 1) else []) 5
10:51:48 <lambdabot>  [5,6,7,8,9]
10:52:11 <EvanR> you can use takeWhile and iterate
10:52:16 <ertes> but as soon as variables are involved, you better write a regular function =)
10:52:38 <ertes> or that
10:52:52 <EvanR> er dropWhile
10:52:54 <cheater> but i wish to build a continued fraction
10:52:55 <ertes> 'fix' is mostly useful for quick hacks or the 'again' trick in monadic loops
10:53:22 <EvanR> cheater: it sounds like you were trying to get a final answer
10:53:26 <EvanR> which is a double
10:53:35 <cheater> a continued fraction is exactly in this form: see that's what i don't get
10:53:37 <cheater> err
10:53:51 <cheater> a continued fraction is exactly in this form: johnw > so, fix f becomes f (f (f (f (f ...))))
10:53:58 <EvanR> in which case you can build a list of approximations and examine which approximation is good enough
10:54:18 <EvanR> Doubles arent lazy enough for that
10:54:19 <ertes> cheater: that's a fine definition for a mathematician, but to a computer it's a disaster =)
10:54:26 <c_wraith> cheater: if you need to stop applying f at some point, fix doesn't work so well
10:54:44 <cheater> i don't, the continued fraction is infinite
10:54:56 <c_wraith> Well, then, the computation runs forever
10:54:58 <EvanR> dont use Doubles, build the fraction structure itself
10:55:00 <c_wraith> since Double is a strict type
10:55:03 <cheater> 1+1/(1+1/(1+1/( ... )))
10:55:21 <ertes> CReal could support that
10:55:23 <ertes> if you're patient
10:55:30 <cheater> why "patient"?
10:55:36 <c_wraith> CReal is slow. :)
10:55:36 <ertes> because it's slow
10:55:48 <EvanR> exact-real however is pretty fast
10:55:52 <c_wraith> It's implementation isn't the greatest for this use case, anyway.
10:55:55 <ertes> is it still loaded in lambdabot?
10:55:55 <c_wraith> *Its
10:55:58 <ertes> > 0 :: CReal
10:55:59 <lambdabot>  0.0
10:56:02 <ertes> lovely
10:56:07 <cheater> what's CReal? why is it so slow?
10:56:11 <EvanR> cheater: data Expr = One | Plus Expr Expr | Slash Expr Expr
10:56:12 <ertes> > fix (\r -> 1 / (1 + r)) :: CReal
10:56:16 <lambdabot>  mueval-core: Time limit exceeded
10:56:20 <ertes> nope
10:56:27 <ertes> i think it's underspecified
10:56:36 <c_wraith> ertes: I don't think CReal is lazy enough anyway
10:56:44 <c_wraith> ertes: it's not an interval-based representation
10:56:55 <ertes> i thought it's just a map from indices to digits
10:57:08 <EvanR> you might be thinking of exact-real
10:57:10 <ertes> that could be lazy enough, though it probably doesn't know where to stop
10:57:19 <ertes> @src CReal
10:57:19 <lambdabot> Source not found. Just try something else.
10:57:35 <EvanR> (@src is a text file of example defs)
10:57:43 <Cale> ertes: It's a function from n to a rational approximation within 1/2^n iirc
10:57:45 <ertes> i remember something like (Int ->), but maybe that wasn't CReal
10:57:56 <ertes> ah
10:57:56 <EvanR> Cale: thats exact-real
10:58:18 <EvanR> two packages define CReal
10:58:34 <ertes> i can't even remember which one the other one was
10:58:39 <Cale> data CReal = CR (Int -> Integer)
10:58:54 <Cale> Where the Integer there is the numerator, it seems
10:59:07 <Cale> fromInteger n     = CR (\p -> n*2^p)
10:59:25 <ertes> that's a weird representation
10:59:40 <ertes> actually no
10:59:46 <ertes> but it's definitely not lazy enough
10:59:47 <EvanR> there are a lot of real number representations, but most of them are even worse for performance
11:01:44 <ertes> > fix (\r i -> if i > 0 then 1 / (1 + r (i - 1)) else 0) 100 
11:01:45 <lambdabot>  0.6180339887498948
11:02:04 <EvanR> cheater: using that Expr data type, you can write the continued fraction the way you want, and you can create a sequence of approximations by traversing the resulting structure
11:02:19 <EvanR> or print it out
11:02:38 <ertes> > iterate (\r -> 1 / (1 + r)) 0
11:02:39 <lambdabot>  [0.0,1.0,0.5,0.6666666666666666,0.6000000000000001,0.625,0.6153846153846154,...
11:02:47 <ertes> > drop 100 $ iterate (\r -> 1 / (1 + r)) 0
11:02:49 <lambdabot>  [0.6180339887498948,0.6180339887498948,0.6180339887498948,0.6180339887498948...
11:02:53 <ertes> better =)
11:03:01 <EvanR> but to get a "final answer" there are better ways ^
11:03:13 <EvanR> ertes: better not try to go too far!
11:03:23 <EvanR> the wheels will fall off Double
11:03:32 * hackagebot cereal-io-streams 0.0.1.0 - io-streams support for the cereal binary serialization library  https://hackage.haskell.org/package/cereal-io-streams-0.0.1.0 (MichaelXavier)
11:03:34 <ertes> to get a final answer, you better use math than haskell =)
11:03:56 <nitrix> Couldn't match type `ghc-prim-0.5.0.0:GHC.Prim.Any' with `String'
11:04:00 <nitrix> ;-;
11:04:02 <ertes> EvanR: i don't think the answer changes in this case
11:04:10 <ertes> > drop 100000 $ iterate (\r -> 1 / (1 + r)) 0
11:04:12 <lambdabot>  [0.6180339887498948,0.6180339887498948,0.6180339887498948,0.6180339887498948...
11:04:22 <ertes> it just loops over the same value
11:04:27 <EvanR> nice
11:04:47 <nitrix> How do I make something of the Any type?
11:04:55 <nitrix> GHC.Prim.Any
11:04:59 <EvanR> with unsafeCoerce
11:05:04 <nitrix> Not the Data.Monoid one.
11:05:05 <c_wraith> nitrix: what version of GHC?
11:05:06 <EvanR> which you probably arent trying to do
11:05:21 <nitrix> EvanR: Ah. So I'm probably missing a library function that does this for me.
11:05:28 <c_wraith> In more recent versions, Any is a kind-polymorphic 0-argument type family
11:05:29 <EvanR> is that ghci?
11:05:34 <nitrix> Yeah, GHCi.
11:05:38 <EvanR> you probably didnt specify the type of the constant
11:05:53 <c_wraith> Oh, some versions of GHCi said things were of type Any when it meant "they're polymorphic"
11:05:53 <nitrix> I didn't. Let me try.
11:06:00 <c_wraith> Try to get off of those versions of ghc
11:06:11 <c_wraith> I think that was 7.8?
11:06:26 <nitrix> EvanR: It inferred the type properly though. Yep, even with the type annotation, still no luck.
11:06:39 <EvanR> o_O
11:07:13 <c_wraith> nitrix: then in your version of ghc, Any is a magical type that unifies with anything.  Try using a more recent GHC, where Any is better-behaved.
11:07:14 <ibrahim> hello people
11:07:31 <sm> hello ibrahim 
11:07:32 <nitrix> c_wraith: I have 8.0
11:07:55 <nitrix> It's got to be a bad manipulation.
11:07:59 * EvanR suddenly decides not to upgrade
11:08:02 <c_wraith> nitrix: then Any is a 0-argument poly-kinded type family that unifies with any type whatsoever
11:08:06 <ibrahim> i can successfully run a program with 'runGhc src/Main.hs -threaded' but cabal run gives "user error (RTS doesn't support multiple OS threads (use ghc -threaded when linking))"
11:08:18 <ibrahim> i have added
11:08:19 <ibrahim>   ghc-options:         -threaded
11:08:26 <ibrahim> but it doesn't seem to effect
11:08:29 <ibrahim> any ideas?
11:08:35 <c_wraith> ibrahim: don't use runGHC
11:08:38 <glguy> ibrahim: You give the -threaded argument to ghc, not runghc
11:08:40 <c_wraith> ibrahim: compile
11:08:50 <geekosaur> you might need to cabal clean
11:08:53 <c_wraith> ibrahim: like with cabal build
11:09:01 <geekosaur> hm, cabal run.
11:09:11 * geekosaur just doesn't use that...
11:09:32 <ibrahim> oh, cabal clean solved :D 
11:09:34 <ibrahim> thank you!
11:09:47 <xtreak> Hi. I thought of making the IRC logs searchable and collect the code sent to lambda bot so that the many examples are saved on a daily basis. Any thoughts on this or some one has done this earlier?
11:10:04 <einheit> I've asked this on #haskell-lens, but haven't gotten an answer yet. Can I use Control.Lens.Zoom to work with "overlapping" state? I want to zoom from StateA -> StateB where StateB shares one or more fields with StateA. Evaluating a zoomed StateB computation inside a StateA computation would update the shared fields. Hopefully this paste will do a better job of explaining: http://lpaste.net/169317
11:10:50 <jackhill> xtreak: there is http://ircbrowse.net/browse/haskell
11:11:00 <jackhill> I don't know if that does what you want
11:11:28 <ertes> einheit: looks fine to me…  'zoom' really just gives you a view to the same state through an optic
11:12:09 <c_wraith> einheit: it may require an unlawful lens..  You can write unlawful lenses.  They just don't behave nicely in certain cases.
11:12:31 <xtreak> jackhill: Thanks. It looks interesting
11:12:51 <roconnor_> einheit: when zooming in on B from A, you need B to be a substructure of A, which is exactly when there exists a lens from A to B.
11:13:21 <c_wraith> roconnor_: when there exists a *lawful* lens from A to B.  :P
11:14:15 <geekosaur> jackhill, I think the point is the collection. but, public pastes to lpaste are browseable already
11:14:37 <roconnor_> einheit: imagine if b :: State B () updated the value of qux based on the contents of baz (e.g. toEnum).
11:14:53 <einheit> roconnor_: that's the thing, there's no lawful lens from A to B. B shares some fields with A, but may have non-shared fields too
11:14:55 <roconnor_> einheit: how could you zoomWith b in state A.
11:15:45 <einheit> roconnor_: That's why my hypothetical `zoomWith` takes a function to construct the B state from the shared A-field
11:15:46 <roconnor_> imagine if b = do { v <- use baz; qux .= toEnum v }
11:16:00 <roconnor_> ah
11:16:26 <augur> is /u/dalastboss here?
11:16:52 <lpaste> glguy annotated “Control.Lens.Zoom with "overlapping" states” with “hacking zoom to work like this” at http://lpaste.net/169317#a169320
11:17:03 <einheit> After thinking about it some more, I think I would also need to provide a Lens from B to the shared field as well, so that zoomWith knows how to read the updated state in B and write it back to A
11:17:34 <glguy> einheit: You can do this. I'd recommend a lot of comments around the definition and use of the thing reminding that it's not actually a lens
11:19:07 <roconnor_> einheit: okay, Well it is sensible I guess.  One can zoom into the common fields, and then wrap a second StateMonad layer around it containing the extra fields.
11:19:38 <roconnor_> einheit: when you runState on the outer StateMonad that is where you fill in the initial values for the extra fields.
11:19:53 <roconnor_> einheit: then a pair of StateMonads is isomorphic to a singleStateMonad on a pair.
11:20:23 <roconnor_> einheit: In principle the operations you want seems sensible.
11:21:08 <roconnor_> einheit: you intuition about needing a second Lens seems correct to me.
11:22:44 <ph88^> hey guys, can anyone help me get the syntax right for this IO monad ?   https://paste.fedoraproject.org/389043/46800212/
11:22:55 <ph88^> it's about Text.Megaparsec
11:23:16 <ph88^> i just want to be able to handle ParseError myself ..
11:23:16 <einheit> roconnor_: Thats encouraging :) glguy's suggestion looks like it may work, the unlawful lens might let me cut some corners. Of course, it's not ideal.
11:24:00 <einheit> roconnor_: but if the state is (field_from_A, fields_unique_to_B) then thats iso. to my B state
11:24:16 <sm> ph88^: what does the error say
11:24:50 <ph88^> parse error on input ‘=’
11:24:50 <ph88^>     Perhaps you need a 'let' in a 'do' block?
11:24:50 <ph88^>     e.g. 'let x = 5' instead of 'x = 5'
11:25:02 <ertes> einheit: what are you trying to do anyway?  there aren't many use cases for unlawful lenses
11:25:32 * geekosaur notes that parse is an IO action, and must be used with (>>=) or the <- notation. but *that* error sounds like indentation bit you first, even though it looks right in the paste
11:25:43 <kadoban> ph88^: do {res <- parseTest (rawData <* eof) "whatever"; case res of {Left _ = print "foo"; Right _ = print "bar"}  or something
11:25:50 <roconnor_> einheit: hmm, the problematic bit is that the purpose of a lens is to forget about some fields, but in your case you need to set inital values for these "forgotten" fields.
11:25:52 <kadoban> Not sure though.
11:25:55 <sm> ph88^: for one thing, use -> not = in case clauses
11:26:08 <geekosaur> oh, right, missed tat >.>
11:26:12 <kadoban> Oh hah yeah taht too
11:26:13 <einheit> I'm writing a simulator for a turn-based card game. There's a global GameState, and for each players turn, I create a TurnState. The TurnState shares one field with the GameState (a supply of available cards), I want my actions in my State TurnState to be able to modify the larger State GameState
11:26:16 <geekosaur> probabluy where that error came form then
11:26:48 <roconnor_> einheit: so your "second lens" should be really an isomorphism between (newFields, commonFields) and B
11:26:51 <jle`> any reason why there's no aplicative traversal for Data.Vector.Storable? is it just not possible?
11:26:54 <ph88^> kadoban, i still get the same error with the code you provided
11:27:08 <ertes> einheit: so you want to introduce extra state for a section of the stateful code
11:27:09 <kadoban> Yeah gotta use -> like others said, I missed that part
11:27:32 <ertes> einheit: if yes, these problems are orthogonal and should be solved separetely
11:27:50 <glguy> jle`: It would not be possible to provide an implementation of traverse
11:28:04 <ertes> einheit: withExtraState :: s' -> StateT (s, s') m a -> StateT s m a
11:28:08 <Khamal> ertes: can you explain your fmLeaf function? how do i use it? and what does this structure have to do with monoids?
11:28:29 <glguy> jle`: Storable vectors don't support an operation with the type that traverse has
11:28:36 <ertes> Khamal: well, Map is a family of union monoids
11:28:59 <ertes> Khamal: you can construct arbitrary maps using singletons, unions and empty maps
11:29:05 <roconnor_> einheit: the normal way of doing this would be to have a large game state with all player; zoom onto the first player's state * common state, then, after returning from the zoom, then zoom into the second player's state * common state.
11:29:21 <ertes> > M.singleton 1 'a' <> M.singleton 5 'b' <> M.singleton 6 'c'
11:29:22 <lambdabot>  fromList [(1,'a'),(5,'b'),(6,'c')]
11:29:52 <ph88^> kadoban, now i get this  https://paste.fedoraproject.org/389045/46800255/
11:29:55 <ertes> (it's even reasonably efficient)
11:30:13 <einheit> roconnor_: I have something like that already, let me make another paste with the actual data types from my game
11:30:32 <ertes> Khamal: fmLeaf constructs such a map with no further submaps
11:30:40 <kadoban> ph88^: Looks like the args to parse aren't what you think they are?
11:31:01 <ertes> > fmFromList [(1, fmLeaf 2)]
11:31:03 <lambdabot>      Couldn't match expected type ‘Fix (Data.Map.Map k)’
11:31:03 <lambdabot>                  with actual type ‘Data.Map.Map Integer (Fix f0)’
11:31:03 <lambdabot>      In the expression: fmLeaf 2
11:31:04 <ph88^> oh yes i swapped them
11:31:15 <ertes> > fmFromList [(1, Fix (fmLeaf 2))]
11:31:16 <lambdabot>  Fix {fromFix = fromList [(1,Fix {fromFix = fromList [(2,Fix {fromFix = fromL...
11:31:46 <ertes> Khamal: you can use (<>) to combine leaves
11:31:58 <ertes> > fmLeaf 1 <> fmLeaf 2 <> fmLeaf 3
11:31:59 <lambdabot>      No instance for (Show (f0 (Fix f0)))
11:31:59 <lambdabot>        arising from a use of ‘show_M12927388566020939605977’
11:31:59 <lambdabot>      The type variable ‘f0’ is ambiguous
11:32:17 <ertes> > Fix (fmLeaf 1 <> fmLeaf 2 <> fmLeaf 3) :: Fix (Map Integer)
11:32:19 <lambdabot>      Not in scope: type constructor or class ‘Map’
11:32:19 <lambdabot>      Perhaps you meant ‘Data.Map.Map’ (imported from Data.Map)
11:32:29 <ertes> you get the idea
11:33:05 <ph88^> kadoban, now i get this https://paste.fedoraproject.org/389046/46800274/
11:34:45 <kadoban> ph88^: What is the actual type of parse? What is this from, parsec or one of the others?
11:34:48 <sm> ph88^: parse is a pure function
11:35:00 <sm> http://hoogle.haskell.org/?hoogle=parse%20%2Bmegaparsec
11:35:02 * geekosaur thought it was the IO one, sorry
11:35:18 <ph88^> kadoban, it's from https://hackage.haskell.org/package/megaparsec-5.0.0/docs/Text-Megaparsec.html
11:35:19 <kadoban> Oh, just use let res = parse ...   then, yeah. Yeah I thought it was IO too.
11:35:41 <kadoban> Or if you want you can skip the let and just put it in the first part of the case, up to you.
11:36:37 <ph88^> oki
11:36:45 <roconnor_> einheit: sorry, I'm heading out for lunch now.
11:36:47 <roconnor_> good luck.
11:37:08 <einheit> roconnor_: thanks for the ideas
11:37:32 <Khamal> ertes: thanks, i think i got it :)
11:39:13 <Khamal> ertes: but shouldn't it be lhLeaf x = Fix $ Map.singleton x (Fix mempty)?
11:40:23 <ph88^> kadoban, it's working now without errors, i get foo .. but now i want to do this https://paste.fedoraproject.org/389049/03165146/ with ParseError .. but don't know where to start .. should i try to match on all constructors ?
11:42:12 <kadoban> ph88^: Yeah I mean the obvious way to start would be to pattern match the different constructors you're interested in.
11:42:38 <ph88^> how can those constructors be lower case even o_O
11:42:55 <ph88^> errorPos errorUnexpected etc ..
11:43:07 <Khamal> ertes: no, nvm i was wrong
11:43:29 <ph88^> Or maybe i have to match only on NonEmpty and Set  ?
11:44:35 <kadoban> ph88^: Those aren't constructors, they're parts of the record syntax thing. So errorPos  should be of type :: ParseError t e -> NonEmpty SourcePos  or something
11:44:51 <kadoban> It's a function that lets you deconstruct the ParseError, essentially, same with the rest.
11:45:32 <ph88^> i've no experience with records ^^
11:45:51 <kadoban> ph88^: If you just ask ghci for the type of each of them and do a little playing it should become clearer.
11:46:56 <geekosaur> if you define data Foo { foo :: String } then you get a function foo :: Foo -> String for free
11:49:39 <puregreen> is there any way to display a huge structure (value) as a tree/something in haskell-mode for emacs?
11:50:08 <puregreen> or at least, I don't know, reformat a region?
11:50:20 <ph88^> kadoban, got it working :) now i have to think a bit how to do the rest
11:51:18 <ph88^> in ghci can i do   :r  and  main   in one command ?
11:52:10 <geekosaur> not directly but you could probably make one with :def in a .ghci file
11:53:05 <c_wraith> @ask umib0zu is http://lpaste.net/169324 what you were looking for yesterday?
11:53:05 <lambdabot> Consider it noted.
11:53:07 <sm> puregreen: in a haskell-mode buffer ? wouldn't that mean integrating the ghci debugger ?
11:53:37 <c_wraith> errr.
11:53:43 <c_wraith> @ask umib0zu is http://lpaste.net/169324 what you were looking for yesterday?
11:53:43 <lambdabot> Consider it noted.
11:53:48 <sm> if you mean in a repl buffer, pretty-show formats values with "standard" Show instances nicely
11:53:53 <c_wraith> I'm bad at text.
11:54:50 <ph88^> how do i get from Word to Char or Text ?
11:55:02 <c_wraith> via an encoding
11:55:16 <ph88^> T.pack ?
11:55:32 <c_wraith> No, that's [Char] -> Text
11:55:34 <srhb> ph88^: :def rmain const (return ":reload\nmain") with regards to the :r main bit
11:55:43 <geekosaur> @index chr
11:55:43 <lambdabot> GHC.Char, Data.Char
11:55:46 <geekosaur> :t chr
11:55:48 <lambdabot> Int -> Char
11:56:12 <kadoban> ph88^: Nice
11:56:13 <geekosaur> which then requires fromIntegral or fromEnum to go Word8 -> Int
11:57:20 <geekosaur> to Text it would be T.pack . (:[]) -- make it a 1-element list, then pack it to a Text
11:57:34 <puregreen> sm: repl buffer, yeah, but how would I import pretty-show without adding it to the sandbox?
11:57:52 <c_wraith> and all that is assuming that your Word represents a unicode codepoint
11:58:09 <puregreen> geekosaur: or T.singleton
12:00:03 <ph88^> geekosaur, i get as output "foo \ENQ" i expect "foo 5"
12:00:07 <geekosaur> as with the chr one, I was assuming they meant Word8. if they did not, then they first need to figure out encoding
12:00:14 <geekosaur> ph88^, that's the Show instance
12:00:40 <geekosaur> oh, wait. you don't want to convert a character, you want to render a number in decimal?
12:00:47 <ph88^> ye
12:00:54 <geekosaur> for String it'd be `show`
12:01:36 <ph88^> ye that works
12:02:41 <ph88^> hhmm i try to do newline with \n and i get a literal \n o_O
12:03:09 <c_wraith> are you inspecting your results with ghci?
12:03:15 <c_wraith> it calls print implicitly, which uses show
12:03:19 <EvanR> > text "\n"
12:03:21 <lambdabot>  Terminated
12:03:26 <srhb> lambdabot: :o
12:03:28 <EvanR> o_O
12:03:30 <c_wraith> if you want to examine what a String really is in ghci, use putStrLn
12:03:31 <geekosaur> in ghci, use putStrLn
12:03:33 <geekosaur> heh
12:03:47 <geekosaur> > text "ö"
12:03:49 <lambdabot>  ö
12:03:51 <geekosaur> hm
12:03:56 <c_wraith> :t text
12:03:58 <lambdabot> String -> Doc
12:03:58 <geekosaur> guess it just doesn't like newlines
12:04:10 <Clint> who does, really
12:04:24 <LKoen> > text "hello\nworld"
12:04:25 <lambdabot>  hello
12:04:26 <lambdabot>  world
12:04:49 <Iceland_jack> > text (intersperse '\n' "hello")
12:04:51 <lambdabot>  h
12:04:51 <lambdabot>  e
12:04:51 <lambdabot>  l
12:04:56 <EvanR> i just realized how little sense "newline character" makes
12:05:06 <geekosaur> prettyprinter lib must be trying to figure out indentation or something
12:05:11 <c_wraith> Control characters are special things
12:05:17 <c_wraith> in-band signaling
12:05:40 <EvanR> right but weve almost gotten rid of all that in practice...
12:05:45 <sm> puregreen: you'd need pretty-show in your sandbox.. why not ?
12:06:09 <c_wraith> Not when all of our textual formats still use in-band signaling in practice. :)
12:06:18 <EvanR> yeah, for newlines
12:06:19 <geekosaur> that said, out of band newlines are worse because you often don't get to specify where they're put (probably nobody here remembers dealing with text in fixed-length-record filesystems...)
12:06:45 <EvanR> ["hello", "world"]
12:06:48 <puregreen> sm: can you even add a package to the sandbox without adding it to the .cabal file?
12:07:02 <sm> sure, just cabal/stack install it manually
12:07:03 <puregreen> (which would be very inconvenient to do every time I want to inspect a value)
12:07:26 <ph88^> c_wraith, eh no .. i just want to print to console, i use print
12:07:44 <c_wraith> ph88^: well, still using print, which calls show, which escapes newlines
12:07:56 <c_wraith> ph88^: so use putStrLn if you want to not escape a string
12:08:00 <Welkin> damn it
12:08:01 <Welkin> o.o
12:08:05 <Welkin> how do I go up the stairs in nethack4?
12:08:22 <puregreen> Welkin: wrong channel, I guess
12:08:29 <puregreen> sm: sorry, I phrased it vaguely. I can add a package to the sandbox, but as far as I remember GHCi will complain if I try to import any module that isn't in the .cabal file
12:08:30 <geekosaur> ph88^, `print` will call `show` on every value, including String values, thereby rendering characters outside 0x20-0x7e in escape sequence format
12:08:34 <EvanR> geekosaur: well, i regularly transmorph text with more-than-one-newline-in-a-row into list of text-with-no-newlines then display it as paragraph elements
12:08:40 <ph88^> ooh i see
12:08:44 <EvanR> that seems saner
12:09:26 <geekosaur> EvanR, it's still a stream format instead of a record format, you just have more complex delimiters (HTML) :p
12:10:07 <geekosaur> and HTML markup is very much in-band control
12:10:09 <EvanR> yeah the concrete syntax, still a bane of existence in any language
12:10:13 <sm> puregreen: maybe so, you might have to add -package pretty-show when starting the repl then. I have it in the cabal file
12:10:42 <sm> I use it for --debug output
12:11:41 <sm> Welkin: <, of course!
12:22:17 <ph88^> how can i make a string with a variable number of spaces? maybe something simpler than  concat $ take 5 $ repeat " "   ??
12:22:29 <ph88^> 5 is the variable
12:22:40 <glguy> replicate
12:23:29 <ph88^> glguy, replicate gives list of strings so i still need to do concat ..
12:23:57 <srhb> ph88^: If replicate aString gives you a list of strings, what might it do on the component strings are made of?
12:23:58 <glguy> nope, don't replicate a strinh
12:24:14 <srhb> :t replicate
12:24:15 <hexagoxel> @src String
12:24:15 <lambdabot> type String = [Char]
12:24:16 <lambdabot> Int -> a -> [a]
12:24:37 <shapr> Anyone hacking on corrode? The literate markdown doesn't play well with my emacs haskell-mode, is there a fix for syntax highlighting?
12:25:11 <ph88^> glguy, ah i have to replicate the char, yes right :)
12:26:37 <ajf> how do I tell cabal to build with -Wall?
12:27:01 <glguy> cabal configure --ghc-options=-Wall
12:28:09 <ajf> I see, thanks
12:31:07 <ph88^> this code works, any suggestions to make it more haskell idiomatic?  https://paste.fedoraproject.org/389070/80062181/
12:34:44 <sm> you can tidy a little, but it's idiomatic
12:36:11 <ph88^> what could i tidy ?
12:36:13 <sm> I'd tend to move the Right and input binding to the top to keep the clauses adjacent and avoid tailing dedents
12:36:19 <sm> trailing
12:36:46 <lpaste> glguy pasted “first pass for ph88^” at http://lpaste.net/169329
12:37:21 <glguy> ph88^: There's a start at tidying
12:38:05 <ph88^> eh that's nice ^^
12:38:32 <glguy> avoid large monolithic definitions and trying to name as much as possible with make the code easier to navigate
12:39:36 <quchen_> Did I miss something, has literate markdown landed in GHC already?
12:39:50 <quchen_> This makes use of it: https://github.com/jameysharp/corrode/blob/master/src/Language/Rust/Corrode/C.md
12:43:54 <sleblanc> Why doesn't IntSet have a Functor instance?
12:44:08 <shachaf> Because it's a kind error.
12:44:28 <sleblanc> due to Ord?
12:44:49 <sleblanc> oh
12:44:55 <glguy> No, because IntSet :: *
12:45:00 <sleblanc> IntSet :: *
12:45:03 <sleblanc> yes
12:45:29 <ajf> huh, you can't have a Functor on * ?
12:46:25 <geekosaur> Functor requires * -> *
12:47:08 <johnw> if you find yourself wanting a "Functor on *", you might be thinking of a lens traversal
12:47:50 <ajf> oh I see now
12:47:59 <ajf> you couldn't implement fmap on an IntSet
12:49:55 <ajf> because it's (a -> b) -> f a -> f b
12:50:17 <ajf> oh, the type itself requires a `* -> *`, ah
12:50:54 <c_wraith> and you just quickly walked yourself through using type signatures to determine kinds, and kind-matching types. :)
12:51:01 <JordiGH> Y'know how functors and monads are supposed to satisfy certain laws? But Haskell isn't Coq, so it's not like the compiler ensures those laws are obeyed. This always has bugged me a little. How do people deal with it?
12:51:12 <c_wraith> JordiGH: file bug reports on bad instances
12:51:17 <ajf> c_wraith: yep :)
12:51:26 <c_wraith> JordiGH: it's a social contract. :)
12:51:26 <JordiGH> c_wraith: How do I know if there's a bug?
12:51:35 <sleblanc> JordiGH, alternatively, use Idris
12:52:03 <c_wraith> ajf: There's one final step - what does the structure of the definition of functor imply about the types a and b?
12:52:21 <sleblanc> from any a to any b
12:52:23 <sleblanc> ?
12:52:42 <sleblanc> and in my instance, IntSet is Key -> Key
12:52:47 <ajf> c_wraith: that they're of the kind * -> * ?
12:52:58 <ajf> oh no
12:53:00 <ajf> er
12:53:02 <c_wraith> ajf: I think my question was too indirect.  :)
12:53:35 * hackagebot publicsuffix 0.20160708 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160708 (wereHamster)
12:53:46 <ajf> hmm, I don't know what it implies about a and b
12:53:46 <quchen_> :t \f -> asum . fmap f -- is there a predefined function for this?
12:53:48 <lambdabot> (Functor t, Foldable t, Alternative f) => (a1 -> f a) -> t a1 -> f a
12:54:38 <c_wraith> ajf: with Functor defined how it is, what does that mean about how instances must treat values of types a and b?
12:55:06 <ajf> as interchangeable?
12:55:42 <c_wraith> Hmm.  I was going for something like total opacity.  It can't vary its behavior depending on the types in any way.
12:55:55 <ajf> that also came to mind
12:55:58 <c_wraith> The instance is looked up based only on the type f
12:56:10 <c_wraith> a and b are ignored when selecting the instance.
12:56:14 <ajf> right
12:56:18 <c_wraith> That's actually very powerful
12:56:32 <c_wraith> It means you know a huge class of things fmap can't do.
12:56:42 <ajf> heh
12:56:51 <c_wraith> It's important! :)
12:57:29 <ajf> why does Haskell have both map and fmap?
12:57:47 <geekosaur> historical reasons
12:58:02 <geekosaur> or, the haskell98 committee thought that a polymorphic map would be "too confusing"
12:58:04 <c_wraith> people were convinced no one could learn haskell if map's type talked about Functors and didn't ever mention lists
12:58:26 <ajf> ah, that's what I remembered
12:58:35 * hackagebot parameterized-data 0.1.6 - Parameterized data library implementing lightweight dependent  types  https://hackage.haskell.org/package/parameterized-data-0.1.6 (ugeorge)
12:58:51 <c_wraith> (From what I've seen, most people learning the language prefer fewer special cases, not more)
12:58:58 <ajf> yeah
12:59:05 <sleblanc> @src map
12:59:05 <lambdabot> map _ []     = []
12:59:05 <lambdabot> map f (x:xs) = f x : map f xs
12:59:16 <JordiGH> @src fmap
12:59:17 <lambdabot> Source not found. There are some things that I just don't know.
12:59:26 <JordiGH> Even the bot's confused by fmap.
12:59:27 <geekosaur> even so, consider that people get confused with FTP's length working on Maybe
12:59:28 <ajf> IIRC isn't (.) also a special-case like this
12:59:44 <c_wraith> JordiGH: fmap has a different implementation for every type.  It can't fit into @src's database. :)
12:59:51 <geekosaur> no, @src is a hand-crafted database that is rarely updated and sometimes even wrong
12:59:52 <JordiGH> I always thought (.) should bind tighter than application.
12:59:59 <geekosaur> @src fmap []
12:59:59 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:00:02 <c_wraith> ajf: yes, (.) is a special case of fmap
13:00:16 <geekosaur> @src [] fmap
13:00:16 <lambdabot> fmap = map
13:00:16 <c_wraith> JordiGH: nah, it's really nice to mix (.) with partial application without parens
13:00:39 <JordiGH> weirdo.
13:00:51 <sleblanc> take10drop10 = take 10 . drop 10
13:00:53 <ajf> there's an even more powerful one IIRC that could replace both (.) and fmap
13:01:20 <c_wraith> there are multiple ways of generalizing fmap.  That's the problem with that - they aren't compatible
13:01:21 <sleblanc> well, drop10take10*
13:01:36 <ajf> yeah
13:02:13 <c_wraith> ajf: by the way, I wrote a bit about why it's useful to define classes on type constructors on stack overflow - https://stackoverflow.com/questions/29463811/any-advantage-of-using-type-constructors-in-type-classes/29471935#29471935
13:04:00 <ajf> c_wraith: interesting, thanks
13:08:36 * hackagebot bitx-bitcoin 0.9.0.1 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.9.0.1 (tebello_thejane)
13:11:49 <Peaker> it appears someone did something to haskell's phabricator and it spams everyone about their age old commits. I totally forgot I had done all that cleanup work on cabal :)
13:12:04 <c_wraith> Peaker: it was thoughtpolice 
13:12:16 <thoughtpolice> Guilty as charged.
13:12:27 <thoughtpolice> That shouldn't be happening, although some GHC related ones might occur...
13:12:38 <Peaker> for a moment there I thought: "someone is committing with my name on things? Uh oh"
13:12:47 <JordiGH> What's going on with FPcomplete and haskell-lang.org?
13:13:04 <aupiff> yeah, is this a community fork?
13:13:15 <Peaker> JordiGH, I think they lost hope that their input will be properly considered in haskell.org so made a new entrypoint to compete with it
13:13:26 <Peaker> I think it's just a website fork?
13:13:32 <JordiGH> They're just unhappy about website design?
13:13:36 <JordiGH> That's all?
13:13:46 <JordiGH> Why #haskell-lang and r/haskell-lang too?
13:14:01 <aupiff> they kept the layout, the color scheme, etc. of haskell.org
13:14:01 <Peaker> JordiGH, not the (HTML-ish) design but the recommendations.. e.g: recommending "cabal" for newbies and not "stack"
13:14:17 <Peaker> JordiGH, r/haskell-lang is just a subreddit to discuss the new website, not a new subreddit for Haskell
13:14:30 <ajf> haskell-lang seems like an attempt to fork
13:14:30 <Peaker> And I suppose the IRC channel as well? But I'm not sure about that
13:14:31 <JordiGH> Sure has a funny name if that's the intent.
13:14:35 <sm> JordiGH: those are for discussing the site. And this has been unclear
13:14:42 <thoughtpolice> Peaker: Are you getting any more commits?
13:14:46 <thoughtpolice> Er, emails, etc.
13:15:37 <Peaker> thoughtpolice, I am resetting my password, it says "current algo: Nothing", "best algo: bcrypt".. ??
13:15:55 <c_wraith> I think that means "holy crap, set a new password promptly"
13:16:37 <thoughtpolice> That means nothing to me? You're going to have to take a screenshot or something. Also, it should always be using bcrypt.
13:17:03 <c_wraith> I suspect "Nothing" might be the case after you've reset your password
13:17:10 <thoughtpolice> Possibly.
13:17:14 <c_wraith> as in, you don't even have a password at that point.
13:17:47 <Peaker> it's only talking about the algorithm used for my password prior to the reset? OK then :)
13:18:07 <Peaker> thoughtpolice, I think I got just a single burst of spam about Nov 12 commits to cabal, and that's it
13:18:09 <thoughtpolice> Uh, no. It should always be using bcrypt...
13:18:27 <thoughtpolice> If you just reset your password, you wouldn't be able to tell, but Phabricator can tell you what you're currently using and what's the best available.
13:18:49 <thoughtpolice> Right now I'm looking at my account settings, which says 'bcrypt'. Considering it's been included in PHP, I'm pretty sure what c_wraith is saying is basically correct.
13:19:06 <thoughtpolice> It just shows oddly misleading information during the reset, or whatever.
13:34:26 <dmwit> JordiGH: Generally with hand-written proofs; often of the form "X is a monad, and T is a monad transformer, so X T is a monad without further argument".
13:34:38 <dmwit> s/X T/T X/ of course
13:34:56 <JordiGH> dmwit: Why can't the compiler do that?
13:35:07 <geekosaur> sometimes they're initially written in Agda with proofs, then translated (manually, or by having the agda compiler generate Haskell code)
13:35:39 <dmwit> JordiGH: Because the proofs of "X is a monad" and "T is a monad transformer" can be, in general, arbitrarily hard.
13:36:11 <JordiGH> Gödellianly hard?
13:37:26 <alercah> JordiGH: yes
13:37:55 <alercah> it's a straightforward reduction
13:38:49 <JordiGH> I would have thought that the "X is a monad" part would be given, as it would start from known monads.
13:39:15 <dmwit> known how?
13:39:22 <JordiGH> IO is known.
13:39:26 <dmwit> Is it?
13:39:37 <JordiGH> ghc can assume it is.
13:39:47 <dmwit> Yes. And it assumes it is... because of a hand-written proof.
13:39:59 <barrucadu> There are more monads than just IO, most of which are not just variants on IO
13:40:08 <hpc> there's a lot of really fun arguments floating around about which encodings of IO obey the Monad laws and which don't
13:40:22 <alercah> given a turing machine M and input tape T
13:40:25 <JordiGH> Uhm, are you turtling me all the way down here? Do machines ever know anything because in the end it's just high voltage or low voltage in a circuit?
13:40:28 <hpc> or under which notions of IO actions being equal
13:40:46 <alercah> construct a monad I_{M,T} where all operations run M on T until it halts, then act as the identity monad
13:41:15 <dmwit> JordiGH: To be honest, I think I've lost track of your actual goal. I am certainly not intentionally turtling you.
13:41:16 <cheater> hello, is it valid to call the "<-" arrow in do syntax "bind"?
13:41:30 <dmwit> cheater: I think that's a fine name for it.
13:41:36 <JordiGH> dmwit: Maybe I should just look at Coq or Idris if I really cared about this.
13:41:45 <Iceland_jack> cheater: some say "draw from", bind is fine
13:41:51 <cheater> i say "comes from"
13:42:09 <hpc> COMEFROM is a totally different operation ;)
13:42:17 <aupiff> i say "do bind"
13:42:35 <barrucadu> JordiGH: If I define my own completely new type and give it a Monad instance, how can the compiler figure out that it is a law-abiding monad?
13:42:35 <cheater> so for you x <- foo is pronounced "x do bind foo"?
13:42:38 <dmwit> ?wiki pronunciation
13:42:38 <lambdabot> http://www.haskell.org/haskellwiki/pronunciation
13:42:59 <Welkin> lol
13:43:01 <JordiGH> lol
13:43:10 <Welkin> SPJ pronounces that as "x from foo"
13:43:31 <aupiff> I suppose I should adopt SPJ's version of that, then
13:43:36 * hackagebot digits 0.3.1 - Converts integers to lists of digits and back.  https://hackage.haskell.org/package/digits-0.3.1 (HenryBucklow)
13:43:44 <cheater> yeah
13:43:46 <aupiff> I don't like "from"
13:43:58 <JordiGH> barrucadu: If your monad is defined in a particular way by using a transformer?
13:44:42 <cheater> i mean for me <- is the same as the "epsilon" that's written \in in LaTeX
13:44:47 <barrucadu> JordiGH: Well, if your monad is T M, for T and M which are known to be a monad transformer and a monad, then that's easy. But what if it's not that form?
13:44:53 <aupiff> well, if I just think of monads generally in terms of the list monad, it's ok.
13:45:00 <dmwit> JordiGH: There are certainly third-party libraries that provide new monads not defined in terms of the (say) `mtl` transformers.
13:45:12 <JordiGH> dmwit: I was more concerned about not accidentally instantiating a Monad but not actualy making it a monad.
13:45:13 <aupiff> cheater: it is when you think of lists, sure.
13:45:30 <JordiGH> barrucadu: Then the compiler can't say either way.
13:45:40 <dmwit> JordiGH: I don't understand your last sentence to me.
13:45:58 <JordiGH> deriving Monad where not actually a monad, oops
13:46:12 <JordiGH> A mistake that the compiler can't catch.
13:46:16 <dmwit> JordiGH: Monad can't be derived by GHC as far as I know.
13:46:28 <JordiGH> Whatever it's actually called when I create monads of my own.
13:47:11 <JordiGH> instance? I forget.
13:47:18 <kadoban> Writing an instance, or instantiation I guess, yeah.
13:47:36 <JordiGH> I thought you could derive more stuff in ghc with some -Xoption
13:47:42 <dmwit> JordiGH: Right. And I am saying that writing a Monad instance that is not the result of applying a transformer to another monad sometimes does happen, even outside of the common base libraries.
13:48:04 <dmwit> JordiGH: So the rule "it's a monad if it's one of these known transformers applied to one of these known monads" is not sufficient.
13:48:18 <kadoban> JordiGH: There's like GeneralizeNewtypeDeriving, but that only lets you derive them when the thing you're wrapping already has them. There's also magic for Functors I think, but I forget what that one is called.
13:48:35 <dmwit> kadoban: I believe his comment about deriving is a red herring for this discussion.
13:48:41 <JordiGH> dmwit: Yeah, I'm not saying that should be the only way to make monads because it's the only way that ghc could possibly test. I'm just saying that it seems like a really weird way to introduce bugs in a language that tries to make it hard to do forbidden things.
13:48:43 <kadoban> Probably, yes.
13:48:57 <cheater> aupiff: what i was getting at was, i call that epsilon "comes from"
13:48:59 <sleblanc> DeriveFunctor ?
13:49:08 <cheater> so x \in N would be "x comes from N"
13:49:12 <ptech> Anybody involved with the GHC Phabricator online?
13:49:21 <JordiGH> ptech: Got a lot of emails did you?
13:49:24 <dmwit> JordiGH: Okay. So we are back where we started. The answer to "how do you know if your instance satisfies the required laws" is "you prove it by hand". That is the state of the art.
13:49:36 <JordiGH> dmwit: Isn't Coq the state of the art?
13:49:36 <Welkin> lol
13:49:45 <dmwit> Coq is a different language...
13:49:46 <Welkin> isn't this covered in the typeclassopedia?
13:49:52 <ptech> JordiGH: Apparently I committed something, but I didn't, and I don't think I should have been able to commit the thing I did
13:50:00 <JordiGH> dmwit: Well, Idris has some coqlike features?
13:50:00 <Welkin> you can define monad instances that do not satisfy the monad laws, so you need to check it yourself
13:50:07 <dmwit> Idris is also a different language.
13:50:15 <sleblanc> ptech, wow, what a quantum state you're in
13:50:35 <JordiGH> dmwit: Right, so the state of the art is higher than you said it is, because there is more art under the sun than is dreamed of in your Haskellian philosophy.
13:50:36 <kadoban> I'm sure if the way you want to prove what you need to prove uses an assistant tool, like coq, that'd be fine. I'm not personally all that familiar with coq though.
13:51:05 <dmwit> JordiGH: I was under the impression that you were asking about Haskell. After all, this is #haskell.
13:51:14 <JordiGH> I'm asking why can't Haskell get better.
13:51:21 <JordiGH> If others are better.
13:51:33 <geekosaur> ptech, ask in #ghc
13:51:42 <dmwit> JordiGH: For all the reasons dependently typed languages suck: performance when you're passing types around all the time suffers, and programmer time rockets up in an unscalable way.
13:51:49 <geekosaur> they just upgraded Phabricator and it's pulling in unexpected stuff
13:52:05 <kadoban> JordiGH: I think the extra power needed to be able to prove the right stuff would be a *big* change. So it's kind of like asking why all languages aren't the same, a bit.
13:52:17 <JordiGH> Yeah, admittedly writing in Coq is even more work than writing in Haskell.
13:52:37 <thoughtpolice> ptech: Yes, sorry. That was due to a bug from an upgrade; I hope you didn't get spammed very hard.
13:52:57 <geekosaur> JordiGH, there *is* work on adding dependent types. it's going slowly and carefully because of the problems dependent types bring
13:53:08 <JordiGH> geekosaur: Oh, interesting.
13:53:21 <thoughtpolice> ptech: It might have looked like you committed something but it's just really 'importing' a commit from another place, so it gives the appearance of 'you authored this thing'
13:53:29 <geekosaur> but, when it comes down to it, dependent types have some very high costs, and the question is whether the costs are worth it
13:53:39 <sleblanc> can one use liquidhaskell to prove class instance laws?
13:53:47 <geekosaur> in enough cases to justify them
13:59:45 <qinusty> I'm about to ask a question which will get a lot of very opinionated answers, I am aware of this. I just finished my first year at University and am looking to get into developing more with Haskell and various other languages. Is it worth me picking up Emacs?
13:59:58 <benzrf> qinusty: if you want to
14:00:10 <benzrf> it's probably worthwhile to pick up either emacs or vim
14:00:20 <benzrf> or even both, if you feel like it
14:00:28 <qinusty> See my issue is, Seeing all of the tools used with emacs/vim for development just makes things look more efficient
14:00:35 <kadoban> qinusty: Depends what else you're using, but yeah emacs seems like a good tool for a lot of people.
14:00:39 <qinusty> I'm trying plugins for Atom, Sublime etc atm.
14:00:55 <benzrf> i personally use vim
14:00:56 <qinusty> But they're lacking a lot in functionality 
14:01:20 <dedgrant> qinusty: FWIW I learned emacs as a result of working with Haskell. It was my path of least resistance.. I had never used emacs in anger before.
14:01:31 <qinusty> I tried setting up a hasell vim environment and came across quite a few issues before giving up for the night
14:01:36 <benzrf> it's not so "intelligent" of a program the way emacs is, but it's magical for plain old text editing
14:01:42 <dedgrant> Though I understand integration with other editors is improving
14:01:43 <kadoban> Atom and sublime are pretty good. I prefer vim, but I know a few people who get by fine in sublime, and one in atom. If you're interested in it, yeah try emacs, see how it goes for you.
14:01:45 <benzrf> no yeah vim is not like emacs exactly
14:01:53 <benzrf> it's not quite as much of a "set up an enivironment" thing
14:02:10 <benzrf> emacs is the thing that's über-programmable, where you install 100000 plugins
14:02:22 <qinusty> I use vim as my terminal editor of choice at the minute
14:02:52 <qinusty> I am not a master of the key binds so I guess now would be a good time to learn some Emacs with all of the haskell tools available
14:03:05 <Hijiri> sleblanc: in some cases yes
14:03:10 <Hijiri> in many cases probably not
14:03:15 <Hijiri> wait
14:03:21 <Hijiri> yeah, you could, nevermind
14:03:23 <ertes> as a user i can confirm that emacs is a very efficient development environment for haskell
14:03:27 <Hijiri> but I don't know if you can enforce it
14:03:52 <sleblanc> ertes, I second this
14:04:00 <qinusty> What is the best way to learn Emacs? Would you recommend bothering to follow guides and practice? Or just use it and improve as I go on
14:04:03 <ertes> but that's mostly due to haskell-mode, and especially haskell-interactive-mode
14:04:03 <Hijiri> the nevermind is for the wait by the way, it's still true that in many cases you wouldn't be able to
14:04:11 <Welkin> quicksilver: go through the built-in tutorial
14:04:14 <dedgrant> I do keep Sublime around, though, particularly for it's incredibly responsive interface, and it just does a few things better (such as columnar blocking, multiple cursors and dealing with massive files).
14:04:15 <Welkin> it's all you need to get started
14:04:15 <sleblanc> qinusty, follow the built-in Emacs tutorial
14:04:24 <ertes> qinusty: first check whether your favourite development tool is well supported
14:04:39 <Welkin> qinusty: ^
14:04:47 <ertes> qinusty: if yes, there is probably no reason to learn a new editor
14:05:16 <qinusty> Well ertes, Coming out of first year with experience in Java and C#..... I generally used Visual Studio way back when I learnt C# and Intellij for Java
14:05:26 <qinusty> I could get the Idea plugins for Haskell
14:05:26 <sleblanc> qinusty, do the tutorial once a week, and the knowledge will quickly seep in
14:05:32 <ertes> qinusty: ok, learn emacs (or vim, which is also very popular)
14:05:48 <Welkin> hahaha
14:05:52 <Welkin> yeah, dump the IDEs
14:06:05 <Welkin> emacs is very efficient and easy to use once you learn the basic commands
14:06:10 <qinusty> I just finished trialing Atom for a few hours
14:06:14 <Welkin> no mouse ever again
14:06:16 <qinusty> and it seems a little slow and yeahh....
14:06:48 <sleblanc> C-h is the prefix for help, and there are several useful help subcommands (C-h m: about current modes; C-h w: where is bound some command; C-h f: what is some function;…)
14:07:40 <sleblanc> M-x allows you to invoke commands by their name. combined with auto-completion, it can teach you about existing commands you never knew
14:08:18 <qinusty> Other advantages to using Emacs, You can look like a wizard once you know what you're doing
14:08:28 <ertes> qinusty: to be honest a fully configured emacs isn't exactly fast either…  i notice it on smaller systems =)
14:08:41 <platz> cabal gen-bounds <- is this generally a good idea? any caveats?
14:08:45 <ertes> qinusty: in fact emacs takes well over 20 seconds to start on my netbook, so i have it running in daemon mode
14:08:47 <sleblanc> qinusty, s/can/will
14:08:54 <sleblanc> emacs enhances beard growth
14:09:02 <qinusty> yeah, can.
14:09:03 <sleblanc> and there's #haskell-emacs if you are interested
14:09:27 <oherrala> Does anyone have any tips on this: https://github.com/haskell/bytestring/pull/80#issuecomment-231473235
14:09:28 <ertes> qinusty: but of course i use linux mostly as a bootloader for emacs…  even this very line on IRC i wrote into an emacs buffer =)
14:09:37 <Welkin> emacs keyboard macros
14:09:38 <Welkin> haha
14:09:50 <sleblanc> ertes, never did IRC with emacs; are you using ERC?
14:10:00 <ertes> sleblanc: yeah
14:10:26 <qinusty> Note on the replace command sleblanc, I did a module in my first semeseter which brought everyone into the basics of Unix systems. The s/query/replace was one of the first things we used in vim, Is that a common thing throughout?
14:10:53 <sleblanc> qinusty, it's actually inspired from sed/ed, so it predates vim
14:10:55 <Welkin> qinusty: replace in emacs is M-%
14:11:02 <ertes> Welkin: thanks
14:11:26 <ertes> (yeah, i actually typed M-x replace-string all the time, because i can't be bothered to memorise it)
14:11:54 <qinusty> M being modifier?
14:11:57 <qinusty> Like Shift etc
14:11:59 <Welkin> Meta
14:12:02 <qinusty> ah
14:12:05 <Welkin> it should be Alt on your keyboard
14:12:32 <qinusty> Okay, well. I'll leave emacs until tomorrow I think
14:12:43 <qinusty> Then give it a go
14:12:56 <sleblanc> ertes, M-% is actually query-replace
14:13:33 <ertes> ah, i see
14:13:42 <adarqui> stack build --fast seems to be a life saver
14:14:29 <ertes> qinusty: you don't learn emacs, it learns you…  you just use it and pick up stuff as you go
14:14:32 <sleblanc> C-h k <key sequence> lets you know about what's bound to <key sequence>
14:14:59 <qinusty> Well, I'll use it for python and Haskell and I'm sure I'll pick things up
14:15:35 <sleblanc> qinusty, soon you will be using it for mail, IRC, address book management, calendaring…
14:15:44 <sleblanc> check out org-mode, it's pretty powerful
14:15:49 <qinusty> Nooo, my IRC is run on my VPS so that it stays online
14:15:58 <ertes> sleblanc: actually it took many years for me to do more things than coding with it
14:16:20 <qinusty> With my bot written in haskell, shameless plug : ping blackjack-hs-bot
14:16:33 <sleblanc> ertes, I started using emacs with org-mode, and I know a few people who use emacs only for org-mode
14:17:12 <ertes> sleblanc: i use it myself, but as said, it took many years for me to pick it up…  also ledger-mode, notmuch and many other things
14:17:31 <sleblanc> tables/spreadsheet mode is useful too
14:17:41 <ertes> alright, let's return to haskell =)
14:18:04 <ertes> talking about emacs makes me feel dirty
14:18:12 <nitrix> ertes: ping
14:18:16 <ertes> nitrix: pong
14:19:14 <qinusty> ertes: Vim will always be my default editor though :P I have a terrible habbit of :wq even on things like google docs
14:19:16 <nitrix> ertes: Does a typical FRP application starts with one function calling other functions to build the definition of one large network, or does it creates many smaller ones and there's code spread up a little everywhere to run these micro networks?
14:19:32 <nitrix> ertes: I'm using network as the terminology in reactive-banana.
14:19:48 <nitrix> A graph of events&behaviors + inputs and outputs.
14:20:19 <maerwald> with default emacs you have a higher chance of RSI
14:20:22 <ertes> qinusty: happens to me, too, except with C-x k and C-x b =)
14:20:53 <ertes> nitrix: it's really up to you…  it's a style choice
14:20:56 <qinusty> How does one reduce said risk? Different key binds?
14:21:24 <qinusty> maerwald: 
14:21:31 <ertes> nitrix: you could even have a collection of those network-building functions and call them from the controller as you see fit
14:21:54 <maerwald> qinusty: e.g. use spacemacs, but that's even more fragile
14:21:56 <ertes> qinusty: you can't really reduce that risk, but it's also not as bad as one might think
14:22:21 <ertes> definitely worse than with vim though, because you hold ctrl a lot
14:22:55 <maerwald> sure you can reduce it
14:23:03 <qinusty> Okay, before I hop on the emacs hype train, ertes what is your setup for developing haskell with vim? 
14:23:37 <woffs> (fugitive + hindent)
14:23:38 <ertes> maerwald: sure, you can rebind everything and use evil-mode
14:23:50 <dmj`> qinusty: hop on, train's about to leave the station
14:23:54 <maerwald> exactly
14:24:05 <ertes> qinusty: i don't have one, but i hear that many vim users use it with ghc-mod
14:24:22 <ertes> qinusty: which seems to be the vim variant of emacs' haskell-interactive-mode
14:24:33 <nitrix> I'm on vim and using the repl with a tiling window manager.
14:24:36 <nitrix> That is all.
14:25:05 <ertes> qinusty: also you don't have to go full IDE right away…  it's fine starting with emacs/vim as simple editors
14:25:19 <qinusty> Yeah I know
14:25:32 <ertes> it just makes you more "rapid" to have an intergrated interpreter
14:25:41 <qinusty> I do use vim for everything just text based
14:25:57 <qinusty> Like editing any files on my VPS, my git commit's etc
14:25:59 <ertes> i hear that haskell support is very good for vim
14:26:11 <ertes> and if you still want the extra features of emacs, there is a vim implementation in emacs 0)
14:26:11 <ertes> =)
14:26:15 <ertes> it's called evil-mode
14:27:07 <nmdanny> does haskell vim/emacs support something for showing types of selected/moused-over expressions, like atom editor?
14:27:20 <ertes> nmdanny: emacs does
14:27:46 <ertes> either from selected libraries/hoogle (via regular haskell-mode) or for things in scope from the loaded module (via haskell-interactive-mode)
14:28:12 <ertes> qinusty: i enjoyed this talk, if you've got an hour to waste: https://www.youtube.com/watch?v=JWD1Fpdd4Pc
14:29:22 <ertes> qinusty: question about your bot: does it support counting? =)
14:29:40 <qinusty> ertes: By that you mean card counting?
14:29:55 <ertes> yeah
14:30:07 <ertes> high/low counting
14:30:19 <ertes> in other words: does it exhauste a deck of cards before it restarts?
14:30:23 <ertes> exhaust
14:30:41 <qinusty> ertes: The logic dictates that if deck reaches a length of 26 cards 
14:30:45 <qinusty> it reshuffles
14:31:04 <ertes> ok, then i'm out…  i don't play games that i could lose =)
14:31:08 <qinusty> :P
14:32:57 <nmdanny> I really want to get into using emacs for haskell but there's so much configuration to do
14:33:14 <ertes> qinusty: that's not a good vegas simulator…  can't bet more than 1000 =P
14:33:38 <ertes> nmdanny: just don't do it all upfront
14:33:44 <qinusty> Ah well ertes, at the minute I don't have persistent data soooo. If it crashes you lose your balance. 
14:34:04 <qinusty> But it's haskell
14:34:06 <qinusty> sooo
14:34:16 <qinusty> That's less likely than if I'd written it in Python
14:34:25 <ertes> qinusty: that's fine…  statistically speaking i'm going to lose my balance anyway =)
14:34:38 <suppi> how can I run an IO action in a different thread without it blocking?
14:34:49 <ertes> suppi: forkIO?
14:34:51 <suppi> for example, doing `forkIO (pure ())` in ghci blocks
14:34:59 <ertes> suppi: it shouldn't
14:35:30 <suppi> sorry, i meant `forkIO (forever $ pure ())`
14:35:52 <ertes> suppi: that might block in GHCi, because i think it uses the single-threaded run-time
14:36:00 <ertes> suppi: try this:  forkIO (forever yield)
14:36:25 <the_2nd> I have problems nesting my cases for enumerated, nested data types. Can anyone help solving this? -> http://lpaste.net/3914766100784480256
14:37:32 <Welkin> the_2nd: what are you trying to do exactly?
14:37:32 <suppi> ertes, that seems to work
14:37:45 <Welkin> what is "foo"?
14:38:07 <the_2nd> just want to return different results for each case (even the nested ones)
14:38:10 <Welkin> that is just a type variable as it is right now, meaing the function accepts any type
14:38:13 <suppi> ertes, any way to use ghci without yield?
14:38:22 <cheater> EvanR: the idea to create an Expr data type was pretty good, thanks
14:38:32 <cheater> ertes: your solution with iterate was pretty good as well
14:38:50 <the_2nd> Welkin, I'll make it more clear / correct. One sec
14:39:15 <ertes> suppi: it tends not to be a problem, as soon as your thread does something more interesting than just busy-looping, but in general it needs to give control back to the RTS from time to time
14:39:30 <ertes> suppi: for example by I/O, by blocking operations or, as a last resort, by 'yield'
14:39:31 <Welkin> the_2nd: I think I see what you are trying to do
14:39:38 <Welkin> you are confusing data constructors with type constructors
14:39:50 <cheater> ertes: i don't know how this works, could you elaborate please? 20:01 <     ertes > > fix (\r i -> if i > 0 then 1 / (1 + r (i - 1)) else 0) 100 
14:40:26 <the_2nd> Welkin, improved -> http://lpaste.net/3914766100784480256
14:40:30 <ertes> cheater: let f i = if i > 0 then 1 / (1 + f (i - 1)) else 0 in f 100
14:40:35 <ertes> cheater: does this make sense to you?
14:41:13 <ertes> > let f i = if i > 0 then 1 / (1 + f (i - 1)) else 0 in f 100  -- testing it just to make sure it actually works =)
14:41:14 <lambdabot>  0.6180339887498948
14:41:21 <suppi> ertes, alright. thank you
14:41:41 <the_2nd> > len [1..]
14:41:43 <lambdabot>      Not in scope: ‘len’
14:41:43 <lambdabot>      Perhaps you meant one of these:
14:41:43 <lambdabot>        ‘lens’ (imported from Control.Lens), ‘lex’ (imported from Prelude)
14:41:44 <cheater> ertes: yes it does
14:41:57 <Welkin> the_2nd: http://lpaste.net/3914766100784480256
14:42:02 <Welkin> look at my annotation at the bottom
14:42:08 <ertes> cheater: good…  first "\x y -> z" is just syntactic sugar for "\x -> \y -> z"
14:42:10 <the_2nd> > length [1..]
14:42:13 <lambdabot>  mueval-core: Time limit exceeded
14:42:18 <cheater> yes i know
14:42:32 <cheater> oh so you're saying replace the first -> with =?
14:42:40 <cheater> gotcha
14:42:44 <ertes> cheater: fix (\r x -> stuff) x0 = fix (\r -> \x -> stuff) x0
14:42:54 <slack1256> SML is mostly functional. It is based on the model of evaluating expressions as opposed to the model of executing sequences of commands
14:42:54 <the_2nd> Welkin, ahhh
14:42:59 <the_2nd> one sec, trying it
14:43:05 <ertes> cheater: this is just "\x -> stuff", where "r" stands for "\x -> stuff"
14:43:07 <slack1256> Thus this is the definition of functional programming. I found it!
14:43:18 <Welkin> the_2nd: the first C in your A datatype is a data constructor
14:43:26 <dmwit> the_2nd: This is a common mistakes for folks new to Haskell. There are two completely separate namespaces for type-level stuff and value-level stuff.
14:43:29 <ertes> cheater: or literally just substitute the definition of 'fix'
14:43:39 <Welkin> the second C that comes right after it `C C` is the type of the parameter it takes
14:43:46 <Welkin> confusing naming scheme you set up
14:44:05 <cheater> ertes i don't get it: 23:42 <     ertes > cheater: this is just "\x -> stuff", where "r" stands for "\x -> stuff"
14:44:17 <dmwit> the_2nd: So in *your* code (not Welkin's), you have a value `C :: A` and a value `X :: C`, but the two different `C`s are not related to each other.
14:44:26 <cheater> you said "\x -> stuff" where "r" stands for ________ but there's no "r" in "\x -> stuff" ??
14:44:43 <ertes> cheater: fix (\r x -> _stuff) _x0 = let f = \x -> _stuff in f x0  -- 'f' is in scope in _stuff
14:44:54 <ertes> cheater: let me use a simpler example:
14:44:55 <sleblanc> the_2nd: if it makes sense, rename "data C" to something else. e.g. if A is an Expression, then data C could be a CArg
14:45:08 <ertes> > fix (\r x -> x : r (x + 1)) 0
14:45:10 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:45:43 <ertes> = fix (\r -> (\x -> x : r (x + 1))) 0
14:45:56 <dmwit> > fix ((0:) . map (1+))
14:45:57 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:46:05 <ertes> cheater: now the result is a function, not just a value
14:46:22 <ertes> (hence why you pass an argument to it after fix)
14:46:43 <dmwit> `fix` is mind-bending, even to experts.
14:46:48 <ertes> cheater: the 'r' stands for the whole inner parenthesised expression
14:46:59 <Welkin> I still haven't understood fix yet 
14:47:02 <ertes> so it stands for the function itself
14:47:06 <the_2nd> dmwit, sleblanc A == AI   C == GatherAI    X == GatherWood     Y == GatherStone    ...
14:47:20 <the_2nd> your solution worked, so thanks for that
14:47:38 <ertes> cheater: a different way to understand 'fix' is to see how one would typically *use* it
14:47:48 <cheater> hmm
14:47:51 <cheater> ertes i have to run
14:47:56 <sleblanc> the_2nd: so you could have data Resource = Wood | Stone …
14:47:58 <cheater> but let's continue talking tomorrow if you're here?
14:48:05 <cheater> or some other day =)
14:48:22 <ertes> i want to write something recursive…  "stuff"…  if i apply "fix" to it, then i get a name that refers to the very thing i'm defining
14:48:25 <ertes> so it can refer to itself
14:48:32 <ertes> cheater: sure
14:48:40 <ertes> not sure if i'm here, but there are many people who can help =)
14:48:57 <Welkin> :t fix
14:48:59 <lambdabot> (a -> a) -> a
14:48:59 <cheater> :)
14:49:14 <sleblanc> and instead of deeply nesting cases, you could do (GatherAI res) -> gatherResource res
14:49:22 <sleblanc> ^ the_2nd 
14:50:24 <the_2nd> sleblanc, the cases are already flat
14:50:34 <the_2nd> and I like the Resources improvement, makes it cleaner
14:50:53 <sleblanc> the_2nd: you are right. you could still split it out, so you can reuse gatherResource elsewhere
14:51:13 <qinusty> ertes: Watching the recommended video, Org mode may have just sold me on emacs, even if I use evil mode
14:51:26 <sleblanc> the_2nd: (assuming this is for a game) the function could be reused in e.g. an automated tutorial or scripted event
14:52:29 <the_2nd> sleblanc, I already have data Tree = Tree { position :: Position, ... } 
14:52:47 <the_2nd> and will get a "Tree redifition" on data Resource = Tree | Stone
14:53:13 <Welkin> yes, you already used Tree as a data constructor
14:53:30 <the_2nd> do I have to move the Tree definition into the Resource enum?
14:53:43 <the_2nd> data Resource = Tree {...} | Stone
14:53:48 <Welkin> you could use: data Resource = ResTree | ResStone
14:54:03 <Welkin> or you could simply nest the product types inside your sum type
14:54:27 <Welkin> the_2nd: it is not an enum
14:54:29 <Welkin> it is a sum type
14:54:40 <daey> why is the description 'output :: String -> IO ()' wrong for output = putStrLn "Hello"?
14:54:42 <Welkin> so yes, you can arbitrarily nest the types
14:54:59 <Welkin> daey: it doesn't take a String
14:55:02 <Welkin> it has type IO ()
14:55:17 <daey> but haskell.org says putStrLn :: String -> IO ()
14:55:21 <Welkin> yes
14:55:25 <Welkin> but you applied it to a String
14:56:01 <daey> ah i see what you mean
14:56:01 <ertes> daey: if (f :: A -> B) and (x :: A), then (f x :: B)
14:56:50 <sleblanc> the_2nd: check this out: http://lpaste.net/3914766100784480256#a169343
14:56:59 <daey> output x = putStrLn x :)
14:57:52 <sleblanc> the_2nd: oh, hang on, pattern matching will no longer work
15:00:09 <dmwit> daey: Sure, or just `output = putStrLn` or even just use `putStrLn` instead of `output`.
15:00:14 <sleblanc> the_2nd: I believe this should work: http://lpaste.net/3914766100784480256#a169344
15:02:25 <daey> dmwit: i know its stupid, just wanting to get a feel for the language
15:03:13 <Welkin> daey: one word of caution: don't try to be too clever using point-free style
15:03:15 <Welkin> it will bite you
15:03:23 <daey> point free style?
15:04:10 <sleblanc> daey: getting rid of variables in functions
15:04:20 <sleblanc> f x = g x becomes f = g in point-free
15:04:45 <daey> didnt even know that was possible
15:04:48 <Welkin> that is known as eta reduction
15:05:27 <sleblanc> daey: some examples of point-free style are horrendous: https://blunt.herokuapp.com/#input=f%20g%20x%20a%20%3D%20Something%20(g%20(x%20%2B%20a))
15:06:14 <dmwit> ?pl \x y z -> f y (g x y) (h y x)
15:06:14 <lambdabot> (const .) . ap (ap . ap f . g) (flip h)
15:06:17 <dmwit> obviously
15:06:29 <Welkin> @pl sum xs = foldl' (+) 0
15:06:29 <lambdabot> sum = const (foldl' (+) 0)
15:06:30 <Welkin> lol
15:06:48 <dmwit> Did you mean `foldl' (+) 0 xs`?
15:06:53 <daey> does the ' have a specific meaning?
15:06:54 <Welkin> haha
15:06:56 <Welkin> yes
15:07:04 <dmwit> daey: Nope, just part of the name.
15:07:06 <daey> ive seen it often within function ames
15:07:07 <Welkin> daey: it is a naming convention to denote strict evalution
15:07:12 <Welkin> oh
15:07:22 <daey> like functionname' = ...
15:07:25 <dmwit> Yes, the naming convention Welkin mentioned is right, too.
15:07:35 <Welkin> when used in variable names, it is just a way of saying "this variable is the updated version of the one without the '"
15:07:46 <ertes> @let don't _ = pure ()
15:07:47 <lambdabot>  Defined.
15:07:50 <Welkin> you don't have to use it
15:07:55 <Welkin> it can be confusing sometimes
15:08:02 <Welkin> I try to avoid naming my variable using '
15:08:14 <the_2nd> sleblanc, thanks
15:08:17 <ertes> @let but = (>>)
15:08:19 <lambdabot>  Defined.
15:08:46 <ertes> :t don't (putStrLn "Hello world") `but` do (print (2 + 2))
15:08:47 <lambdabot> IO ()
15:10:12 <dmwit>  ?let but _ = id -- for performance reasons
15:10:54 <ertes> (would be useful to have @unlet)
15:10:58 <sleblanc> the_2nd: have you seen the last paste annotation, where the Resource case match is nested?
15:11:01 <ertes> (or @relet)
15:11:21 <dmwit> > don't "say hello" `but` do "say goodbye"
15:11:23 <lambdabot>  "say goodbye"
15:11:36 <ertes> @let say = id
15:11:38 <lambdabot>  Defined.
15:11:53 <ertes> > don't (say "hello") `but` do say "goodbye"
15:11:55 <lambdabot>  "goodbye"
15:13:33 <ertes> there is a hilarious ten-minute youtube video where the guy plays around with stuff like that (afnfd mfafkfefs fufn of sfwfefdfifsfh)
15:13:39 * hackagebot htiled 0.1.4.0 - Import from the Tiled map editor.  https://hackage.haskell.org/package/htiled-0.1.4.0 (m09)
15:14:04 <ertes> https://www.youtube.com/watch?v=RqvCNb7fKsg
15:14:24 <reinh> *accurately portray the swedish language
15:23:30 <EvanR> ertes: "i really like haskell syntax because it looks so much like english" stealing pythons usual first impression... or perl poetry
15:23:39 * hackagebot imm 1.0.1.0 - Execute arbitrary actions for each unread element of RSS/Atom feeds  https://hackage.haskell.org/package/imm-1.0.1.0 (koral)
15:24:29 <ertes> =)
15:41:22 <monochrom> there is a blog article for "haskell syntax looks so much like BASIC"
15:41:56 <monochrom> in fact it has also been made into a library and uploaded to hackage.
15:42:13 <fishythefish> monochrom: link?
15:42:33 <mgsloan> http://augustss.blogspot.com/2009/02/regression-they-say-that-as-you-get.html https://hackage.haskell.org/package/BASIC
15:42:47 <mgsloan> fishythefish: ^^
15:43:13 <mgsloan> Not sure if it's what monochrom is thinking of, but probably.  Pretty good trick with the line numbers
15:44:01 <fishythefish> Well, my first language was BASIC, so if nothing else, I'm consistent with my language choice?
15:45:01 <EvanR> looks like basic is another python saying
15:45:07 <monochrom> these mimicking other languages should stay as insider jokes rather than examples for attracting people to haskell
15:45:09 <EvanR> which... seems wrong
15:45:42 <monochrom> remember that what kind of demos you show determines what kind of people you attract
15:46:24 <monochrom> if you demo mimicking PL/I, all you have achieved is to attract people who prefer PL/I
15:46:41 <EvanR> presentation title: stupid unsafePerformIO tricks
15:46:44 <monochrom> and in fact probably turn away people who have the good taste to not prefer PL/I
15:46:47 <sleblanc> which is why you can put the emphasis on the implementation rather than the result
15:46:59 <sleblanc> but news sites tend to twist and distort everything
15:47:50 <levi> The number of people who prefer PL/I these days must be pretty small.
15:48:57 <mgsloan> I started on BASIC.  I remember when I first encountered OOP I was like "arrgh why can't we just keep things simple"
15:49:29 <mgsloan> Ironic to now be using Haskell, which is in some ways rather complex.  But it's the right sort of complexity :)
15:49:58 <monochrom> objects are complicated, not just complex.
15:50:30 <EvanR> you got your simple simplicity, simple complexity, and complex complexity
15:50:30 <mgsloan> Right, the distinction being unnecessary complication versus intrinsic / necessary complexity
15:50:43 <monochrom> look up Luca Cardelli's work on the semantics of objects. it's full of recursion, and its recursion is even trickier than haskell's
15:50:44 <mgsloan> I tend to go for moderate simplicity
15:52:01 <monochrom> in haskell, if you don't syntactically use recursion, which is probably 50% of the time, you don't have to talk about fixed points.
15:52:43 <monochrom> in OOP, every time you use "this/self", which is 99.999% of the time, you are looking at a fixed point, no matter how much you pretend it is not there.
15:54:01 <monochrom> in addition, whenever you write a class that can be subclassed, or a prototype object that can be inherited, you are looking at open recursion.
15:54:08 <shachaf> I don't think that's true.
15:55:28 <sleblanc> I just discovered (haskell-cabal-add-dependency) in haskell-emacs
15:56:27 <EvanR> what is the value of understanding full OOP as a church encoding, rather than a more imperative machine model
15:57:39 <monochrom> I wouldn't call that church encoding
15:58:40 <monochrom> imperative machine model is why you have to execute the program in your head to predict what it does, rather than just doing algebra.
15:58:40 * hackagebot phoityne-vscode 0.0.7.0 - ghci debug viewer on Visual Studio Code  https://hackage.haskell.org/package/phoityne-vscode-0.0.7.0 (phoityne_hs)
15:59:06 <EvanR> and the algebra of OOP is easier?
15:59:30 <sleblanc> isn't an imperative model just a set of algebraic rules acting on some implicit state?
15:59:47 <sleblanc> assuming it does no unrestricted IO
15:59:59 <EvanR> yes
16:01:07 <monochrom> an imperative machine model also doesn't tell you how to come up with the program in the first place, or how to refactor it. an algebra does.
16:01:51 <monochrom> you are right to say that an algebra for OOP is no easier.
16:02:21 <still_learning_h> Hey guys, need some help with error-handling and stuff. I'm having trouble in how i should integrate logging/printing to stdout cleanly without dipping into IO everywhere.
16:02:38 <monochrom> the conclusion is that OOP does not have a real story for invention or refactoring. you can't do it with execution, and the algebra way is too hard.
16:02:44 <sleblanc> still_learning_h: Debug.Trace (trace) can be useful
16:02:54 <still_learning_h> Yeah but it feels so ugly though
16:03:07 <monochrom> whereas FP has at least some kind of Bird's story for both
16:03:12 <EvanR> trace is for debugging not logging or printing to stdout
16:03:16 <sleblanc> it's this, or using Writer as a logging channel
16:03:18 <johnw> monochrom: how does this/self have anything to do with fixed points?
16:04:20 <still_learning_h> I've thought about a Writer, but wouldn't Haskells laziness prevent any printing to stdout until it actually has finished executing everything?
16:04:55 <sleblanc> Haskell is lazy until you want the value
16:05:12 <monochrom> johnw, shachaf is asking that in #haskell-offtopic too. I will answer there after dinner. the summary is that each object is a fixed point of a parametrized template, and the template's parameter is for "this".
16:05:33 <still_learning_h> Hmmm
16:05:51 <maerwald> still_learning_h: you could use an effects system and do something like https://hackage.haskell.org/package/freer-0.2.3.0/docs/Control-Monad-Freer-Trace.html
16:06:20 <still_learning_h> An effects system? i'll have to google around
16:06:43 <sleblanc> if your main = runWriterT $ yourAction; then yes, the logging might only happen at the end, but if your application is sufficiently structured (e.g. it iterates through step) then you can scaffold around the steps so that after each step the effect is forced
16:07:50 <still_learning_h> sleblanc: Yeah this seems like the best way currently, thanks. 
16:09:11 <ertes> you can easily make haskell look like APL, too
16:09:31 <sleblanc> still_learning_h: this looks simple: https://hackage.haskell.org/package/logging-facade-0.1.1/docs/System-Logging-Facade.html
16:10:05 <ertes> but since we have actual screen editors now, it's probably not a good idea to do that =)
16:10:35 <still_learning_h> sleblanc: Ooh, this seems nice, will have a look at it
16:11:02 <EvanR> a related problem to logging is getting a progress bar on a long running computation
16:11:09 <EvanR> get this after its finished would be kind of pointless
16:11:36 <sleblanc> funny
16:11:46 <EvanR> and an error during a writer losing the whole log would be shitty
16:12:09 <still_learning_h> dang, stop ruining my plans 
16:12:38 <maerwald> a progreess bar involves a GUI library anyway, so you either have something FRP-like or are exposed to IO anyway
16:12:55 <EvanR> not literally a GUI, just a notification that progress has been made
16:13:07 <maerwald> how do you make that without GUI
16:13:15 <sleblanc> progress can easily be modeled with a continuation
16:13:15 <EvanR> with stdout
16:13:29 <sleblanc> PartialResult continuation | Done
16:13:30 <EvanR> yeah, continuations is a way
16:13:30 <maerwald> I consider ncurses a GUI library
16:13:42 <EvanR> thats fine, but this has nothing to do with GUIs
16:13:58 <sleblanc> didn't say gui
16:14:01 <still_learning_h> yeah, i'm currently learning haskell by making a CLI interface for a online code judge, and thus a progress bar is probably in place, displaying the progress during the test cases
16:14:05 <daey> why/when should i use (funca . funcb) x  as opposed to funcb (funca x)?
16:14:20 * EvanR says more stuff to maerwald with sleblanc standing right in front of him
16:14:22 <sleblanc> daey: when funca has two arguments
16:14:29 <ertes> maerwald: a progress bar can be printing a dot for each 10% of the process
16:14:31 * sleblanc apologizes
16:14:47 <maerwald> ertes: I consider that graphical
16:14:54 <ertes> maerwald: i consider that UI
16:14:56 <sleblanc> (funca y . funcb) x
16:15:00 <maerwald> ertes: hence GUI
16:15:23 <EvanR> indeed, peano arithmetic is graphical, you cant do math without seeing right?
16:15:52 <sleblanc> progress could be sent across the network, instead of stdout
16:15:52 <EvanR> how else do you count the freakin Ss
16:16:13 <ertes> i don't care if you call it UI, TUI or GUI…  all i care is that you actually implement good UX, which not only includes a progress bar, but includes a *responsive* progress bar =)
16:16:13 <maerwald> sleblanc: in which case it would not be a GUI thing, correct
16:16:17 <EvanR> yes progress can be logged to a database
16:16:33 <EvanR> and you will be forced to open a terminal to read it, thus also graphical
16:16:34 <maerwald> I'm confused why some people have a hard time distinguishing that
16:17:04 <JordiGH> ertes: How about a WUI?
16:17:15 <maerwald> sleblanc: but then it's likely you'd be working in IO too if you are already inside network and database stuff
16:17:24 <EvanR> by "progress bar" i mean a responsive notification of progress
16:17:54 <EvanR> which can be report graphically, audibly, telepathically, or whatever
16:17:57 <EvanR> reported*
16:17:58 <sleblanc> maerwald: if you model it as effects, it could be hosted in a test harness, with mock sockets that are not in IO…
16:18:45 <JordiGH> Wonder if we could do telepathically with very precise and strong magnetic fields.
16:18:54 <JordiGH> Stimulate your neurons in just the right way.
16:18:55 <EvanR> i would like to go back and emphasize continuations in case anyone didnt see it through the mass of nonsense
16:18:59 <sleblanc> JordiGH: isn't that wifi?
16:19:11 <JordiGH> sleblanc: wifi isn't strong enough to mess with neurons
16:19:46 <kadoban> JordiGH: It will be once we implement more direct neural interfaces.
16:19:51 <EvanR> one way to write continuing programs is with monads
16:20:12 <EvanR> then you can intercepting the semicolons and test or whatever the progress bar
16:20:15 <maerwald> sleblanc: my point is, instead of trying very hard to do this with some crazy model, just do it the easy way if you are already exposed to IO
16:20:51 <sleblanc> maerwald: oh, sure; you just have to ensure that effects are effectively applied, instead of delayed until the end of the computation
16:20:52 <EvanR> .oO( free monad progress bar )
16:21:00 <ertes> we have a great abstraction for responsive progress bars
16:21:01 <sleblanc> effect, effectively. wow.
16:21:07 <ertes> Control.Concurrent
16:21:15 <EvanR> ertes: oh?
16:21:17 <sleblanc> TChan?
16:21:21 <ertes> and it's actually better than using coroutines (a.k.a. free monads)
16:21:29 <EvanR> how
16:22:12 <ertes> EvanR: if the action stalls (due to a network problem perhaps), the progress bar can actually reflect that…  i know at least one program that gets that wrong, and keeps displaying the wrong download rate until it times out
16:22:22 <still_learning_h> what have I gotten myself into..
16:22:32 <EvanR> ertes: ah yeha well if youre already using IO for something
16:22:53 <EvanR> my original issue was "i have this pure computation which is probably going to take a while"
16:22:55 <dmwit> Sorry, can we revisit `Writer`? Why was it thrown out?
16:23:32 <EvanR> well i mentioned that crashing half way through a writer and losing a log sucks
16:23:36 <ertes> EvanR: well, for a pure computation you could just do what unix does:  "be patient, user, i'll get there" =)
16:23:54 <EvanR> true
16:23:57 <ertes> dmwit: Writer to report progress?
16:24:03 <EvanR> screw responsiveness
16:24:09 <dmwit> ertes: Yes.
16:24:17 <dmwit> EvanR: You need not lose the log just because you crashed.
16:24:35 <ertes> dmwit: i vote for State rather than Writer due to its questionable strictness
16:24:36 <EvanR> crashed badly, with undefined or an infinite loop
16:24:53 <EvanR> dmwit: how do you get any of the log before the writer is done?
16:25:15 <ertes> dmwit: let the log be of type Nat
16:25:20 <ertes> with one S per step
16:25:39 <ertes> whoops
16:25:43 <ertes> that was for EvanR 
16:26:03 <still_learning_h> ertes: So using a State is preferrable according to you?
16:26:06 <EvanR> well ok, how do you get any of the log before the writer is done?
16:26:08 <qinusty> I made a mistake not sleeping, trying to pick up emacs at this time is a terrible idea.
16:26:16 <EvanR> how many S are there
16:26:36 <still_learning_h> S?
16:26:44 <EvanR> data Nat = Z | S Nat
16:26:46 <ertes> hmm
16:26:56 <ertes> in this particular case the lazy Writer may actually be a better choice
16:27:00 <ertes> nevermind that
16:27:08 <EvanR> im still wondering...
16:27:21 <still_learning_h> you guys are supposed to know this :^)
16:27:38 <still_learning_h> but yes, a lazy writer I should be able to handle
16:27:59 <EvanR> well Nat is about the laziest thing
16:28:14 <ertes> EvanR: x `seq` tell [()] = x `seq` ((), [()])
16:28:21 <ertes> EvanR: (abusing [()] as Nat)
16:28:49 <dmwit> Okay, I have convinced myself that `WriterT [String] IO` is not fantastic.
16:28:58 <johnw> lol
16:29:15 <ertes> pure Writer is fine for this one
16:29:32 <dmwit> Only if you are happy with pure computations. =)
16:29:38 <EvanR> if i dont make a joke about how ridiculous this all is, ill be embarrassed for haskell
16:29:49 <ertes> EvanR is =)
16:30:05 <maerwald> dmwit: I feel like freer can do this nicer, but you can probably come up with an mtl-like approach too
16:30:36 <maerwald> only having a pre-defined subset of IO exposed
16:30:53 <maerwald> and screw all the writer/reader/state stuff
16:31:13 <ertes> (i'd probably go with Free, if only because i find it easier to reason about its strictness)
16:31:25 <dmwit> It's easy enough to write a `MonadWriter` instance for `IO` that does the logging, I guess. Or a suitable newtype of `IO` if you're nervous about that kind of thing.
16:31:44 <EvanR> if youre in IO already, its easy
16:31:47 <EvanR> putStrLn
16:31:52 * dmwit nods
16:32:06 <dmwit> If you're not yet in IO, then it's also easy: tell [foo].
16:32:07 <maerwald> I was rather thinking of 'Eff' monad
16:32:38 <still_learning_h> the thing is, my program consist of mostly MonadError MyError m => a -> IO (m b)
16:32:42 <maerwald> or a class-constraint that's a subset of IO via mtl
16:33:06 <EvanR> so. ++ with Writer lets you get the beginning before the entire thing is done running?
16:33:27 <dmwit> > snd (runWriter (fix (tell ["foo"] >>)))
16:33:29 <lambdabot>  ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","fo...
16:33:34 <dmwit> So yes. =)
16:33:49 <still_learning_h> Wait
16:33:49 * EvanR how in the
16:33:53 <still_learning_h> wat
16:33:55 <still_learning_h> so
16:33:56 <dmwit> > snd (runWriter (tell ["foo"] >> undefined))
16:33:58 <lambdabot>  ["foo"*Exception: Prelude.undefined
16:34:08 <ertes> instance (Show a) => MonadWriter a IO  -- lovely
16:36:09 <dmwit> still_learning_h: You will probably prefer `a -> ExceptT MyError IO b` to the type you posted, and probably `(MonadError MyError m, MonadIO m) => a -> m b` even better.
16:36:38 <still_learning_h> Ah, I actually have the second form whereever possible
16:37:13 <still_learning_h> and only one ExceptT at the end to resolve ambiguity problems
16:37:23 <dmwit> Sounds like you're doing the mtl right. =)
16:37:57 <still_learning_h> Thanks, but I've also heard there is a non-mtl camp of people sneaking around?
16:38:18 <acowley> Those sneaks!
16:38:19 <still_learning_h> the transformers, is there any striking pros/cons between the two?
16:38:20 <dmwit> Yes; some of my coworkers prefer MonadLib, and there are some folks that swear by free(r) monads.
16:38:20 <nshepperd_> let (answer, log) = runWriter calculation in forkIO (traverse showProgressBar log) >> continue doing stuff with answer
16:38:46 <still_learning_h> acowley: Those sneaks indeed ;)
16:38:47 <nshepperd_> traverse_
16:38:49 <maerwald> add :: Int -> Int -> Eff '[Trace] Int
16:38:51 <maerwald> or something
16:39:05 <acowley> dmwit: Where are you working?
16:39:06 <dmwit> "transformers" is a dependency of mtl. If you are happy using GHC, there's basically no reason to restrict yourself to transformers rather than using mtl.
16:39:10 <dmwit> acowley: Galois
16:39:23 <acowley> Oh, wow, I didn't know that!
16:39:31 <acowley> Belated congrats!
16:39:39 <dmwit> Yeah, thanks!
16:39:51 <dmwit> It's a pretty awesome workplace with very smart people in.
16:40:13 <acowley> I got to visit there once, and it seemed great
16:40:15 <dmwit> Plus I've been learning a ton of crypto, which has always been on my list of side interests with no time attached.
16:40:59 <still_learning_h> dmwit: Thanks for the help
16:41:37 <dmwit> still_learning_h: I hope you landed at a place where you think you can make progress. =)
16:41:56 <still_learning_h> dmwit: crypto an RE is always my blow-off-steam hobby whenever I can't take it no more ;)
16:42:12 <nitrix> Why is the combination of two monads not always a monad? And why can transformers achieve this nevertheless?
16:42:17 <still_learning_h> dmwit: Sure did! Have to play around with Writer and lazyness
16:42:44 <dmwit> nitrix: Some monads do not have associated transformers, of course. =)
16:42:58 <dmwit> nitrix: e.g. there is no IOT, leaving aside for the moment the recent fad
16:43:27 <acowley> booo
16:43:42 <acowley> That jokes probably kills at Galois
16:43:58 <dmwit> ;-)
16:44:05 <dmwit> nitrix: You may like http://stackoverflow.com/q/7040844/791604
16:44:29 <ertes> newtype IOT m a = IOT { runIOT :: m (IO a) }
16:45:21 <dmwit> ertes: I look forward to your implementation of (>>=) (or join).
16:45:27 <still_learning_h> ertes: Lol!
16:46:23 <ertes> dmwit: i never said it's a monad =)
16:47:27 <nitrix> dmwit: I see.
16:47:36 <nitrix> dmwit: So it's only possible if you have a swap :: n (m t) -> m (n t) operation?
16:47:46 <maerwald> still_learning_h: here's an example with an effects system doing logging http://vpaste.net/rrrPj
16:47:52 <maerwald> lpaste is down, so no idea
16:47:55 <nitrix> Is there a name for two monads that would have this property?
16:48:11 <sleblanc> maerwald: lpaste works here…
16:48:16 <maerwald> not when posting
16:48:29 <ertes> nitrix: "distributive"?
16:48:41 <ertes> looks like a distributive law to me
16:48:49 <dmwit> nitrix: Certainly it's possible if `swap` exists. I'm sure one could come up with some pair of monads for which `swap` does not exist but for which a suitable combination of the two monads does.
16:48:51 <nitrix> ertes: https://en.wikipedia.org/wiki/Distributive_law_between_monads
16:48:56 <nitrix> ertes: Yep. You're correct.
16:49:22 <nitrix> dmwit: I see. So ehm, how restrictive this is in practice for Haskell?
16:49:25 <nshepperd_> i imagine that swap is sufficient* but not necessary
16:49:31 <still_learning_h> maerwald: thank you, and the traces are effectively shown and not delayed until and of execution?
16:49:36 <nshepperd_> * it also needs to obey laws
16:50:07 <dmwit> nitrix: ST and IO are the only two monads I can think of which do not have associated transformers.
16:50:23 <dmwit> nitrix: And even then there's an STT on Hackage. Never looked into it so I can't vouch for it, tohugh.
16:50:31 <ertes> @let newtype IOT m a = IOT { runIOT :: m (IO a) }
16:50:32 <lambdabot>  Defined.
16:50:39 <nitrix> dmwit: Yeah, I've seen that one. It's nasty.
16:50:45 <ertes> @let instance MonadTrans IOT where lift = pure
16:50:46 <lambdabot>  .L.hs:172:16:
16:50:47 <lambdabot>      Couldn't match type ‘a’ with ‘m a’
16:50:47 <lambdabot>        ‘a’ is a rigid type variable bound by
16:50:52 <nshepperd_> [] sort of has a transformer but not really
16:50:52 <still_learning_h> maerwald: well I can simply test it :-)
16:51:08 <maerwald> still_learning_h: yes, you can try with using 'forever' in front of the runTrace
16:51:41 <maerwald> or maybe add a delay somewhere
16:51:58 <maerwald> but there's no Delay effect yet, so maybe write one :o
16:52:33 <ertes> @let instance MonadTrans IOT where lift = fmap pure
16:52:34 <lambdabot>  .L.hs:172:16:
16:52:35 <lambdabot>      Couldn't match type ‘m’ with ‘IOT m’
16:52:35 <lambdabot>        ‘m’ is a rigid type variable bound by
16:52:44 <dmwit> nshepperd_: https://hackage.haskell.org/package/list-t-0.4.7/docs/ListT.html ?
16:52:47 <ertes> last try…
16:52:59 <ertes> @let instance MonadTrans IOT where lift = IOT . fmap pure
16:53:00 <lambdabot>  Defined.
16:53:03 <ertes> there we go
16:53:06 <ertes> an IO transformer
16:53:17 <ertes> it's not a monad, but it's a correct monad transformer =)
16:53:25 <nitrix> Ah, yeah.
16:53:48 <nitrix> Well transformers just came to mind, the question wasn't really about them, but more about monad distributivity.
16:54:12 <nshepperd_> dmwit: hmm, I guess i'll believe it
16:54:19 <nitrix> This is pretty cool though. Thanks dmwit and ertes, appreciated.
16:54:32 <dmwit> ertes: It can't be a correct monad transformer: the laws for transformers use the monad instance.
16:54:56 <ertes> dmwit: and they are stated like this: "given a monad m…"
16:55:28 <dmwit> ertes: So?
16:55:52 <ertes> ah, i flipped the monad orders…
16:55:55 <ertes> nevermind
16:56:49 <nitrix> dmwit: ertes Thanks.
16:57:02 <qinusty> Emacs is slowly driving me insane, Maybe its because I'm tired. I had Haskellmode working for syntax highlighting etc but after a restart it won't load .hs files into haskell-mode :/ even with M-x haskell-mode
16:57:12 <ertes> my flawed logic was:  since (IOT m) is not a monad, any implication having that as a premise is automatically true
16:57:24 <nshepperd_> IOT has a nice Applicative instance though
16:57:38 <dmwit> ertes: Yeah. But the laws don't have that as a premise. Bummer. =)
16:57:45 <nshepperd_> so you can still do traversals and things with it
16:57:49 <ertes> dmwit: hence flawed =)
16:58:42 <acowley> qinusty: What happens when you M-x haskell-mode?
16:59:09 <nshepperd_> @let instance (Functor f) => Functor IOT f where fmap f (IOT m) = IOT (fmap (fmap f) m)
16:59:10 <lambdabot>  .L.hs:174:25:
16:59:10 <lambdabot>      ‘Functor’ is applied to too many type arguments
16:59:10 <lambdabot>      In the instance declaration for ‘Functor IOT f’
16:59:17 <qinusty> just no match, it's as if the package isn't installed. But it is. and it won't let me reinstall it until I clear ~/.emacs.d
16:59:22 <qinusty> ack
16:59:25 <qinusty> acowley: 
16:59:33 <ertes> @let deriving instance (Functor f) => Functor (IOT f)
16:59:35 <lambdabot>  Defined.
16:59:43 <dmwit> IOT m ~ Compose IO m, which already has a Functor and Applicative instance.
16:59:46 <nshepperd_> lol ofc
17:00:03 <nshepperd_> thanks, ghc deriving magic
17:00:29 <acowley> qinusty: You're installing it via package-list-packages?
17:00:49 <dmwit> nshepperd_: You had it right, just missed some parentheses around `(IOT f)` right before the `where`. =)
17:02:42 <qinusty> M-x package-install haskell-mode
17:03:26 <nshepperd_> :t (,) <$> IOT [return 5] <*> IOT [putStrLn "hi!"]
17:03:28 <lambdabot> Num a => IOT [] (a, ())
17:03:47 <nshepperd_> etc
17:04:15 <ertes> sorry for invoking the super-intelligent entity that we call GHC, before you could prove that humans are still on par =)
17:04:22 <acowley> qinusty: The usual least common denominator for debugging something at that point is to comment out everything in your init file and bisect until you find what's going wrong.
17:04:44 <ertes> i think, a few years from now GHC will become self-aware, rename itself to AM and destroy the world
17:05:00 <acowley> qinusty: But if you can't even run haskell-mode, it seems like something's going wrong with your load paths or package-initialize
17:06:37 <geekosaur> or rename itself to AC and create it >.>
17:08:09 <acowley> How do you facepalm on irc?
17:08:18 <sleblanc> //me facepalms
17:08:23 * sleblanc facepalms
17:08:45 * hpc b__
17:08:51 <hpc> ?
17:11:00 <jaarod> "Dallas sniper suspect said he wanted to kill white people, especially white officers"
17:11:16 <sleblanc> wrong channel?
17:11:23 <jaarod> yeah middle button
17:13:02 <geekosaur> hpc, yes that worked
17:13:05 <ertes> geekosaur: it's more likely to collapse to a black hole, as soon as it type-checks the last question
17:13:19 <ertes> ("shit, we should have used the untyped lambda calculus after all")
17:13:51 <geekosaur> by some cosmological theories, the universe *is* a black hole :p
17:14:06 <geekosaur> well, hypotheses. none of them really deserves to be called a theory
17:15:23 <geekosaur> alternately see xkcd on the question :p
17:18:43 * hackagebot rei 0.3.7 - Process lists easily  https://hackage.haskell.org/package/rei-0.3.7 (kerkomen)
17:25:42 <ertes> geekosaur: feel free to link it =)
17:26:21 <geekosaur> https://xkcd.com/224/
17:26:38 <geekosaur> (so much for untyped lambda calculus...)
17:26:44 <geekosaur> :p
17:42:33 <jaarod> Dallas shooter could have been Obama's son
17:42:53 <jaarod> sorry, middle key again
17:42:57 <ertes> geekosaur: lovely
17:47:43 <ertes> but yeah, reminds me of when i got that sensation of enlightenment, of unbounded euphoria and enthusiasm, just to find that hugs was hacked together in C =)
17:49:26 <jfmiller28> pl \s -> runMaybeT . flip evalStateT s
17:50:22 <jfmiller28> @pl \s -> runMaybeT . flip evalStateT s
17:50:22 <lambdabot> (runMaybeT .) . flip evalStateT
17:51:36 <geekosaur> "you can do anything in C. that doesn't mean you should."
17:51:50 <arcetera> waiting
17:52:09 <jfmiller28> Can anyone explain why evalStateT and evalState do not put their arguments in the same order?
17:52:14 <monochrom> Church would be proud if you implemented Haskell over a Turing tape.
17:52:30 <arcetera> geekosaur: i used to do everything in c. now i don't 
17:53:34 * geekosaur 's dayjob involves supporting a C code base. threaten to rewrite it in Haskell at least once a week, usually right after someone on the team finds the latest facepalm-inducing bug
17:53:49 <ertes> geekosaur: i blew up my first computer screen under DOS using int 10h…  could have done that in C, but yeah, it was definitely easier in assembly
18:01:14 <dmwit> :t evalStateT
18:01:15 <lambdabot> Monad m => StateT s m a -> s -> m a
18:01:17 <dmwit> :t evalState
18:01:18 <lambdabot> State s a -> s -> a
18:01:46 <dmwit> jfmiller28: I can't explain it, as it seems not to be the case.
18:07:24 <monochrom> wait, you can do anything in C? so for example you can move an immovable rock in C?
18:12:35 <geekosaur> for suitable definition of rock, yes :p
18:13:37 <jaarod> can C make BLM care about all lives
18:14:56 <MichaelK> Hi, does anyone have a good guide to singletons?
18:15:22 <jle`> MichaelK: the documentation isn't too bad, and the paper it links to is nice too. is there a question you had in specific?
18:16:04 <jle`> i sort of wrote an ad-hoc "guide" to singletons inadvertantly while walking through a project involving them, too
18:18:38 <MichaelK> jle`: I'm mostly looking for more extensive worked examples
18:20:13 <MichaelK> can't seem to get started right
18:38:09 <MichaelK> How can I print a `Q [Dec]`? preferably in ghci
18:40:15 <MichaelK> nevermind, figured out one way: \x -> $(x >>= return . LitE . StringL . show)
18:43:02 <MichaelK> or better: \x -> $(x >>= return . LitE . StringL . show . ppr)
18:55:40 <pavonia> MichaelK: Doesn't "ppr <$> runQ x" work?
18:55:57 <pavonia> or "show . ppr"
18:56:28 <MichaelK> pavonia: Template Haskell error: Can't do `recover' in the IO monad *** Exception: user error (Template Haskell failure)
18:57:33 <pavonia> Oh
18:58:55 <enthropy> stringE = return . LitE . StringL
19:00:33 <MichaelK> enthropy: Thanks
19:17:40 <chemouna> i'm looking for resources (blog posts, code examples...) for how to use haskell type system to encode in the type requirements of a program so that it doesn't compile when the input isn't the exact way it should
19:18:15 <chemouna> like Smart constructors https://wiki.haskell.org/Smart_constructors 
19:18:58 <chemouna> please ? 
19:19:46 <cloudhead> but the compiler doesn't have the input before it compiles?
19:22:28 <pavonia> chemouna: Maybe https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell is a good start
19:23:17 <pavonia> or https://byorgey.wordpress.com/2010/06/29/typed-type-level-programming-in-haskell-part-i-functional-dependencies/
19:23:30 <jaarod> are dependent types holy grail 
19:26:23 <cloudhead> you can have all the dependent types you want, you can't validate input before it exists :/
19:26:30 <cloudhead> unless you have a time machine
19:34:31 <chemouna> cloudhead: maybe i didn't express it in the right way, i meant compile checking some constraints like in the example in https://wiki.haskell.org/Smart_constructors with bands having to be >=4 and <=8
19:34:59 <chemouna> pavonia: thanks a lot
19:57:28 <Xe> Why do the lazy butestring type and the strict bytestring type share the same name?
20:01:53 <jaarod> http://www.cam4.com/charil_sexx
20:01:54 <jaarod> one black life that matters
20:03:48 --- mode: ChanServ set +o dibblego
20:03:54 --- mode: dibblego set +b *!*bc817ebe@*.bstnma.fios.verizon.net
20:03:58 --- kick: jaarod was kicked by dibblego (jaarod)
20:04:15 --- mode: dibblego set -o dibblego
20:06:46 <pavonia> Xe: This is very common, e.g. Text or Map do the same
20:08:07 <geekosaur> Map is a different case, though
20:08:22 <geekosaur> they are actually the same data structure; it's the *functions* that differ in strictness
20:09:04 <Xe> yeah, but i have just spent half an hour trying to find which of the 4 bytestring types i need to pass to wai's response.
20:10:30 <nshepperd_> ah, the actual problem is 'why does haddock not qualify type names'
20:11:32 <pavonia> You can tell from the Haddock links what's the correct type
20:11:58 <shachaf> There are only two bytestring types.
20:14:53 --- mode: ChanServ set +o glguy
20:14:53 --- mode: glguy set +q-o $a:jaarod glguy
20:16:19 <ertes> Xe: to answer your question: the reason is that someone decided it's a good idea =)
20:16:24 <ertes> there is no technical reason
20:17:04 <Xe> ertes: from a user standpoint it is kind of painful sometimes tbh
20:18:16 <Xe> nshepperd_: that is a better way to phrase it yes
20:18:50 <Xe> it really would be nice though if the lazy bytestring was named LazyByteString
20:19:08 <Xe> so that i could tell immediately without having to figure out what kind of bytestring it is talking about from ghci
20:21:29 <ertes> Xe: you get used to it…  using :t or hovering over links in haddocks are good ways to find out which types are relevant
20:22:13 <ertes>  :t is probably the more useful way, and your editor probably integrates it in some way
20:23:27 <geekosaur> if you import both modules then it should qualify each one
20:28:50 * hackagebot json-api 0.1.0.4 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-0.1.0.4 (toddmohney)
20:30:08 <Xe> ertes: i haven't yet figured out how to get emacs tooling to work with stack
20:33:48 <ertes> Xe: i don't use stack myself, but i've seen that haskell-interactive-mode supports it out of the box
20:34:40 <athan> Hi everyone. Anyone here know of a good way to print calls to `putStrLn` etc. _above_ the line currently being input by the user?
20:34:49 <ertes> Xe: M-x customize-variable RET haskell-process-type RET
20:35:04 <athan> So I have something like a repl, so my input text won't get clobbered by calls to putStrLn
20:35:22 <athan> I'm guessing this is something in unix, but I'm not sure, just looking for someone to point a finger :)
20:35:24 <ertes> Xe: in fact, according to the docs, it auto-detects stack (by looking for a stack.yaml file)
20:35:26 <Xe> ertes: does not show up as a variable i can customize
20:35:41 <c_wraith> athan: you're going to need to use a terminal library for that, unless you want to hope ansi escape sequences work.
20:35:43 <ertes> Xe: you need to load haskell-interactive-mode
20:36:00 <ertes> Xe: try putting this into your .emacs: (require 'haskell-interactive-mode)
20:36:36 <athan> c_wraith: O_O yeah I'll go for terminal stuff
20:36:44 <athan> do you happen to have a favorite?
20:36:51 <athan> I was just going to use the unix library
20:37:02 <c_wraith> athan: I don't.  I don't even remember what all the options are.  I know there are a couple with vty in the name
20:37:34 <athan> hmm, right on :) Thank you c_wraith!
20:37:41 <ertes> athan: you could enjoy the masochistic pleasures of trying to use the terminfo or hs-terminfo libraries
20:38:18 <ertes> athan: alternatively you could just give in and use a curses-like full-screen environment…  vty would be my favourite there
20:39:01 <ertes> athan: but of course, you could also just delete the current prompt, if it's just a single line, write the text and an LF, then reprint the prompt
20:39:26 <athan> ertes: Hmm! Yeah that's tricky, I'm worried the user may input multiple lines
20:40:31 <ertes> if you keep track of the terminal width (surprisingly tricky!), you can do it anyway, but you quickly end up somewhere between terminal limbo and signal hell
20:41:25 <ertes> another option is to use haskeline, which is a terminal line editor package
20:41:34 <ertes> it probably supports multi-line editing
20:42:08 <ertes> BTW, none of these options support windows =)
20:42:13 <athan> !! I heard that a long time ago
20:42:21 <athan> windows doesn't support me >_>
20:43:45 <ertes> athan: the simplest option would be not to be fancy and just leave the old prompt there
20:44:22 <ertes> only zsh users would notice the difference; bash users are used to it
20:45:47 <ertes> even in 2016 you notice that terminals were originally paper interfaces…  deleting a prompt is just an absurd idea =)
20:49:14 <athan> ertes: Leave the old prompt? :s
20:49:24 <athan> I don't know what you mean by that
20:49:32 <athan> I think haskeline is my go-to though
20:51:19 <ertes> athan: i mean: don't bother printing above…  print below and draw a new prompt
20:51:30 <ertes> that's what most REPLs do
20:51:40 <ertes> zsh is the only counterexample i know
20:52:05 <athan> Oh! Oh okay
20:52:14 * geekosaur thinks this sounds like iHaskell, although not sure its current status
20:52:15 <ertes> it prints completions below the prompt and tries hard to keep them there and to get rid of them when you confirm a line
20:52:47 <ertes> it's neat, but i imagine it's a nightmare to code
20:54:41 <sm> athan: have a look at concurrent-output
20:56:17 <athan> Thanks sm!
20:57:24 <athan> YES! Now we can finally have one of those retched \ | / - \ ... spinners like npm :D
20:57:32 <sm> I haven't got my head around what exactly it does, but it looks like it can do the trick
20:58:33 <geekosaur> spinner isn't hard. just remember that terminals do NOT have multithreaded cursors. it has ONE cursor position.
20:59:32 <geekosaur> (and most terminal libraries will fail horribly if used in multiple threads, independently of terminals not handling output from multiple threads)
21:00:25 <athan> geekosaur: It's a relative cursor too, right?
21:00:37 <athan> sm: I'm not sure, but I'll defintely stash it in my pocket :)
21:00:42 <geekosaur> meaning? (you may not like the answer...)
21:00:47 <athan> :x
21:00:54 * athan is a pleb
21:01:13 <sm> concurrent-output seems to multiplex output, buffering it when another thread is printing, 
21:01:37 <athan> sm: Yeah! It looks really well made
21:01:41 <geekosaur> screen addressing in the vt100/ansi model is top left at 1,1 and bottom right at 80,24 (or window size). screen memory is not addressable.
21:01:52 <sm> a joeyh joint - of course
21:02:06 <athan> heh, I still have yet to use propellor
21:02:15 <ertes> athan: if you keep your progress on a single line, you can just do this:  reputStr str = hPutStr stderr ("\r\027[K" ++ str) >> hFlush stderr
21:02:17 <athan> geekosaur: Hmm...
21:02:18 <geekosaur> but there are terminals that are not based on this model and some of them are utterly insane. (just hope you don't need to deal with them. that said I think emacs' terminal-mode is not ANSI?)
21:02:31 <athan> I'm not trying to track progress at all though haha
21:02:52 <athan> I'm just trying to keep a portion of the terminal segregated for user input (the bottom), while the rest above just spools up
21:02:56 <athan> just like a repl :)
21:03:09 <athan> I just hope haskeline supports multiple lines of input
21:03:12 <ertes> "\027[K" -- that one is supported by pretty much every terminal
21:03:15 <ertes> even emacs =)
21:03:20 <athan> :U
21:03:33 <geekosaur> this is for direct cursor address (\E[l;cH in ANSI). there are also relative cursor movements, which can be parameterized in ANSI but usually not in other terminal types
21:03:59 <geekosaur> so \E[3A moves up 3 lines
21:04:02 <athan> :(__(
21:04:07 <ertes> there are also codes to save/restore cursor position and one to delete everything from the current position downward
21:04:21 <geekosaur> and lots of other codes...
21:04:22 <ertes> that's a good way to keep track of where the current prompt starts
21:04:37 <athan> ertes: -.- whaaaa
21:04:46 <athan> .-.
21:04:48 <athan> welp
21:05:34 <geekosaur> this is why you use a terminal library instead of worrying about it yourself
21:06:15 <ertes> geekosaur: unfortunately the only terminal library i can think of that supports this is terminfo
21:06:29 <ertes> every higher-level library insists on being a GUI library
21:06:31 <geekosaur> vty / vty-ui
21:06:52 <geekosaur> s-lang, although I don't think there's a haskell binding
21:07:10 <geekosaur> just don't use a curses binding. it is so named for good reason >.>
21:07:16 <ertes> vty wants to be a GUI, i.e. it does some stuff that you wouldn't want a REPL to do
21:07:19 <athan> hah
21:08:10 <athan> what kind of terminal applications have you two built?
21:08:42 <athan> unless it's classified :|
21:08:53 <geekosaur> me? over the years I've done all sorts of them, including a clone of (then BSD) "screen"
21:09:09 <geekosaur> (which is itself a terminal emulator, for extra fun)
21:09:37 <ertes> athan: most terminal applications i write are batch-style programs with progress, although i had at least two web-scrapers with vty-ui frontends
21:10:37 <geekosaur> most recently was a console thing that displayed status from 12 clients, and allowed control of those clients. (in perl because it needed to run on centos 6 with only the packages available in centos)
21:12:03 <geekosaur> not sure whether the most complex (in terms of screen management) was the screen clone, or the JNOS port >.>
21:12:52 <ertes> for non-haskell stuff i find the program 'pv' to be very useful…  surprisingly unknown
21:13:07 <krusty> hey
21:13:10 <ertes> it's just like 'cat', but with progress on stderr =)
21:13:44 <krusty> man i can't make up my mind with these front end options.
21:14:04 <krusty> julius, javascript, ghcjs, elm, haste, purescript ...
21:14:46 <krusty> elm is really ergonomic but i'm not sure if it's worth it. purescript ecosystem breakage is probably too bad right now.
21:15:02 <ertes> krusty: + jmacro, clay, blaze-html, lucid, …
21:15:04 <krusty> julius iteration is too slow. ghcjs seems like it needs another 6 months of maturation
21:15:25 <krusty> i tried jmacro briefly, it seems kindof abandoned though no?
21:15:58 <krusty> how does lucid work? just script function + straight strings?
21:16:13 <ertes> krusty: last update in may
21:16:27 <ertes> lucid is an HTML library like blaze-html
21:16:41 <krusty> ertes do you actually recommend it as a preferred javascript option?
21:16:52 <ertes> krusty: you mean jmacro?
21:17:06 <krusty> ertes yeah
21:17:34 <ertes> krusty: for very small things yeah…  you can just dump your JS into your server-side haskell code
21:17:55 <ertes> if you want to do reactive GUI stuff, probably not so much, because it's still JS
21:18:24 <krusty> i've used julius for that (even though i don't use yesod anymore), does jmacro have advantages over julius?
21:19:21 <ertes> not necessarily…  it's just a smaller package that only does JS
21:20:07 <krusty> julius only does js
21:20:31 <krusty> oh i guess shakespeare is all merged now that's what you mean
21:20:33 <ertes> yeah, but isn't it part of a larger package that does everything?
21:20:37 <ertes> yeah
21:21:11 <ertes> just try it out and see if you like it…  it's a matter of taste
21:21:35 <ertes> on the server side i like jmacro for small things, clay for CSS and lucid for HTML
21:21:40 <krusty> i tried it a little bit. thought it was cool for a few mins but i remember stumbling over the function syntax being a bit weird
21:22:00 <krusty> like somehow inconsistent from how i thought it would work. but it's been a while
21:22:08 <krusty> and i know a bit more haskell now so maybe i'll figure it out
21:22:42 <ertes> i haven't done any large web UIs for a while, but i'd probably go with GHCJS and reflex there
21:22:46 <krusty> what about the transpiler options. i always start tinkering, then thinking, "this might not be worth it."
21:22:51 <krusty> compared to vanilla js
21:23:16 <krusty> that's one thing, my web UIs aren't that monolithic
21:23:34 <krusty> they're usually one off data visualization/interaction things that i should be able to write in a day or two.
21:24:03 <krusty> mostly it's a means of having haskell talk to interactivity and visualization stuff like d3 & plotly
21:24:15 <ertes> do you have any complicated interactions going on?  in other words: do you pass the must-use-FRP threshold?
21:25:26 <krusty> ertes not yet, but i'm not where i want to be with this yet.
21:25:44 <krusty> probably FRP would be a good idea for where I want to get to
21:26:08 <krusty> after all, prior to haskell i used R/shiny for a lot of the things i want to do with haskell+web now
21:26:40 <ertes> as long as your client-side code is simple, you're probably not missing much…  try jmacro or just keep using julius
21:27:36 <krusty> i wish i could iterate faster. that's one thing that is nice about doing vanilla js - you don't even have to reload the repl
21:27:44 <krusty> just edit the file and refresh the browser
21:28:17 <ertes> if you have the right editor integration, reloading your haskell project is as simple as saving a file =)
21:28:35 <krusty> hm how? the closest i come is ghcid
21:28:42 <krusty> but that doesn't exactly do it
21:28:52 * hackagebot cereal-streams 0.0.1.0 - Use cereal to encode/decode io-streams.  https://hackage.haskell.org/package/cereal-streams-0.0.1.0 (winterland)
21:28:52 <krusty> i use spacemacs
21:28:58 <ertes> in fact i have even written a library to make this even more convenient
21:29:09 <ertes> @hackage rapid
21:29:09 <lambdabot> http://hackage.haskell.org/package/rapid
21:29:32 <ertes> the haddocs of the Rapid module should explain how to use it (and how to hot-reload quickly in general)
21:29:37 <ertes> haddocks
21:30:18 <krusty> oh yeah i saw that a while back, haven't tried it yet but it looks promising
21:30:22 <krusty> better than halive?
21:30:59 <ertes> well, for one thing it's not a compiler
21:31:11 <ertes> it's really just a library you use from within a GHCi session
21:31:20 <krusty> i tried intero briefly but spacemacs dev branch was giving me grief. i don't quite get the hype for intero yet to be honest
21:31:59 <ertes> see the "emacs integration" section in the haddocks
21:33:41 <krusty> looks slightly complicated to use
21:34:04 <krusty> featureful though
21:36:46 <ertes> it's what powers hot-reload for me:  hit a key and it restarts the part of the application you're currently working on
21:37:21 <krusty> that sounds like something i need
21:37:26 <ertes> a pleasant way to do rapid prototyping on long-running haskell programs
21:37:30 <krusty> esp coming from dynamic repls that also save state between reloads
21:38:13 <ertes> if you decide to use it and run into problems, let me know…  also if the docs don't make sense, consider that a bug and report it as well =)
21:38:16 <krusty> wish it didn't need that code scaffolding.. but i guess that's the price to pay
21:38:28 <ertes> code scaffolding?
21:39:36 <krusty> not having written concurrent haskell code, i'm not parsing this tvar stuff..
21:39:56 <ertes> you probably won't need it
21:40:19 <krusty> k
21:40:32 <ertes> you only need it, if you have multiple interacting components like a web app and a background worker
21:40:44 <krusty> what's that 0 parameter for?
21:41:08 <ertes> it's the store index…  if you don't use the foreign-store library directly, just leave it at 0
21:43:14 <krusty> gotta hit the hay i will try it out later!
21:43:30 <ertes> have fun =)
22:36:42 <innerkick> Hi. I'm trying to install Haskell using Stack. http://lpaste.net/169358
22:39:00 <inerkick> Kindly help
22:43:48 <angerman> What's the difference between (do a; b; c) and (do a; b) >> c ?
22:44:12 <opqdonut> they're equivalent
22:44:27 <shachaf> (do a; b) = a >> b
22:44:42 <shachaf> (do a; b; c) = a >> (b >> c)
22:44:43 <angerman> Hmm... so if there *is* a difference, I probably failed to get my monad instance right.
22:44:52 <shachaf> So it's associated differently, but the monad laws make them equal.
22:45:11 <shachaf> Hmm, I should add a nonfree Monad instance.
22:45:35 <shachaf> The trouble with nonfree is that there are multiple options for how to represent things.
22:45:46 <shachaf> I suppose one that matches the class is the most obvious.
22:45:52 <angerman> shachaf, Yes, I basically though they were equivalent. But just wanted to make sure I'm not hallucinating.
22:48:08 <inerkick> anyone here. Need bit of help with this issue 
22:48:23 <inerkick> http://lpaste.net/169358
22:49:30 <glguy> What happened when you did what the message said to do?
22:50:10 <inerkick> stack init it says
22:50:42 <inerkick> ok :D glguy thanks :D 
23:58:56 * hackagebot kraken 0.0.3 - Kraken.io API client  https://hackage.haskell.org/package/kraken-0.0.3 (wereHamster)
