00:00:31 <jle`> daniel-s: you can see something simular with :t (+)
00:00:35 <jle`> :t (+)
00:00:36 <lambdabot> Num a => a -> a -> a
00:00:51 <jle`> daniel-s: that means that the type is (a -> a -> a), where 'a' can be any instance of the Num typeclass
00:03:01 <nineonine> hi
00:03:15 <nineonine> is it possible to declare typy synonyms this way ?
00:03:27 <nineonine> type Name, SecondName = Int
00:03:35 <nineonine> type*
00:03:49 <Koterpillar> why do you want to do this?
00:04:04 <cocreature> nineonine: nope you need to declare them separately
00:04:19 <nineonine> ok
00:04:20 <nineonine> thanks
00:04:22 <jle`> nineonine: do you expect that to be equivalent to type Name = Int and type SecondName = Int ?
00:04:28 <nineonine> yes
00:05:55 <nineonine> is there a reason why itsimpossible ?
00:06:04 <nineonine> is it hard to implement ?
00:07:08 <cocreature> probably not. it’s just not common enough to want to do that for it to be worth it
00:07:38 * hackagebot lio 0.11.6.0 - Labeled IO Information Flow Control Library  https://hackage.haskell.org/package/lio-0.11.6.0 (DeianStefan)
00:07:38 * hackagebot configifier 0.1.1 - parser for config files, shell variables, command line args.  https://hackage.haskell.org/package/configifier-0.1.1 (MatthiasFischmann)
00:10:05 <mniip> @undefine
00:10:05 <lambdabot> Undefined.
00:10:07 <mniip> @letlpaste 442294937573130240
00:10:08 <lambdabot>  .L.hs:164:16:
00:10:08 <lambdabot>      Ambiguous occurrence ‘DataType’
00:10:08 <lambdabot>      It could refer to either ‘L.DataType’, defined at .L.hs:166:1
00:10:17 <mniip> huh
00:12:33 * hackagebot hoauth2 0.5.5.0 - Haskell OAuth2 authentication client  https://hackage.haskell.org/package/hoauth2-0.5.5.0 (HaishengWu)
00:14:08 <mniip> > let unitType = Datatype "Unit" [unitCon]; unitCon = Con unitType "Unit" 0 in eval [] $ LamTerm "x" (VarTerm "x") `AppTerm` (ConTerm unitCon [])
00:14:09 <lambdabot>  ConTerm Unit.Unit []
00:17:02 <Dangerou1Dav3> https://github.com/sdiehl/write-you-a-haskell/blob/master/chapter4/untyped/Parser.hs , Can somone try to explain to me what is happening at line 70?
00:17:51 <Koterpillar> > foldl1 (+) [2, 3, 4]
00:17:52 <lambdabot>  9
00:18:35 <Koterpillar> > foldl1 (\a b -> [a, b]) [2, 3, 4]
00:18:36 <lambdabot>      Occurs check: cannot construct the infinite type: t ~ [t]
00:18:36 <lambdabot>      Relevant bindings include
00:18:36 <lambdabot>        b :: [t] (bound at <interactive>:1:12)
00:18:46 <Koterpillar> hmm, sorry
00:21:23 <Koterpillar> > foldl1 (\a b -> "(" ++ a ++ "`ap`" ++ b ++ ")") ["x", "y", "z"]
00:21:25 <lambdabot>  "((x`ap`y)`ap`z)"
00:21:33 <Koterpillar> Dangerou1Dav3: does this make it easier?
00:21:45 <cocreature> Dangerou1Dav3: given a list of expressions [e1,e2,e3] it builds up the expression App (App e1 e2) e3 which corresponds to curried function application
00:23:36 <Heather> hi, I need help: https://gist.github.com/Cynede/a3beccd34025493a96f362b28cad58a9 what's failing there? (which dependencies)
00:24:00 <Dangerou1Dav3> cocreature: Well Doesn't many1 make a Parser that that can parse many times of the same parsing mathod?
00:24:30 <Koterpillar> Dangerou1Dav3: it does, and it parses many terms
00:24:44 <Dangerou1Dav3> I don't understand what the App means
00:24:45 <Koterpillar> so es :: [Term]
00:24:51 <cocreature> Dangerou1Dav3: App is just a constructor
00:25:03 <Dangerou1Dav3> Shouldn't many1 get a function?
00:25:08 <Dangerou1Dav3> and not a ctor?
00:25:11 <cocreature> many1 gets a parser
00:25:18 <Cale> Heather: there's a space missing: "_n" should probably be "_ n"
00:25:19 <cocreature> which is "term" in this case
00:25:27 <Dangerou1Dav3> Oh
00:25:27 <Cale> er...
00:25:33 <Dangerou1Dav3> its many1 that defined in Parsec
00:25:36 <Heather> nvm I remind there was branch for ghc8 support
00:25:37 <Dangerou1Dav3> not the global one
00:25:38 <Dangerou1Dav3> -.-
00:25:38 <Cale> no, _ty rather
00:25:45 <Cale> oh
00:25:57 <Koterpillar> Dangerou1Dav3: where's "the global one"?
00:26:06 <Dangerou1Dav3> wait I got confused :P
00:26:08 <Dangerou1Dav3> one sec
00:26:30 <Dangerou1Dav3> Well, why whould I create many Apps?
00:26:45 <cocreature> because the user has written them? :)
00:26:48 <Koterpillar> because (+) 2 3 is (+) applied to 2, applied to 3
00:27:13 <Dangerou1Dav3> But in lambda calc you have app that is being constructed from expressions
00:27:31 <Dangerou1Dav3> why do I split the app to expressions and then create different apps from them
00:27:51 <cocreature> sorry I’m not following
00:27:56 <Koterpillar> if you have 3 terms, how many apps is that?
00:28:21 <Koterpillar> where do you "split" an app?
00:28:25 <cocreature> e1 e2 e3 is (e1 e2) e3 so it consists of two apps
00:28:36 <Dangerou1Dav3> http://dev.stephendiehl.com/fun/003_lambda_calculus.html
00:28:59 <Koterpillar> yeah, so app only gets 1 argument
00:28:59 <cocreature> an app always consists of a function applied to a single argument
00:29:11 <Dangerou1Dav3> I split the app, when I get many parsed components and then I foldr the app over it
00:29:17 <Dangerou1Dav3> what does it mean to fold a constructor
00:29:19 <Koterpillar> where do you split anything?
00:29:20 <Dangerou1Dav3> over a list?
00:29:27 <quchen> In lambda calculus yes, GHC has a notion of function arity (other than 1) though.
00:29:39 <quchen> (Not sure on which level we are here)
00:29:45 <Koterpillar> folding a constructor is the same as folding a function
00:29:45 <cocreature> quchen: yeah but that’s not what we’re talking about here :)
00:29:56 <quchen> cocreature: Oh, nevermind then.
00:30:28 <Dangerou1Dav3> But App is a kind that get only 2 expressions
00:30:34 <Dangerou1Dav3> not "infinity"
00:31:22 <cocreature> Dangerou1Dav3: you are only ever applying app to two arguments, what happens is that you end up nesting the applications so you end up with App (App (App e1 e2) e3) e4
00:31:22 <Koterpillar> an expression can be another App
00:32:04 <Dangerou1Dav3> cocreature: That what I mean by splitting, that way that the app works is wired instead of creating one app of list of expressions you create app of app of app,...
00:32:40 <Koterpillar> yes, that's what the example is parsing
00:32:46 <cocreature> I think I’m lost, what is your question?
00:32:57 <Koterpillar> if you want it to parse something else, change the grammar
00:33:23 <Dangerou1Dav3> My question is, isn't logically application in lambda calc is contained by expressions and not by other applications
00:33:44 <cocreature> what do you mean by being “contained by expressions”?
00:35:10 <Dangerou1Dav3> I mean app is somthing like (\x.(x+3))
00:35:26 <Dangerou1Dav3> and it is constructed by (x+3) expression
00:35:42 <Dangerou1Dav3> and in this case it is not constructed by other application
00:35:57 <Dangerou1Dav3> so I don't understand why would it be constructed from them in the parsing proccess
00:36:10 <Dangerou1Dav3> (As it does in the current proccess)
00:36:19 <cocreature> what is x+3 supposed to be if it’s not an application of x and 3 to +?
00:36:20 <Dangerou1Dav3> BTW thank you so much for the help :)
00:36:52 <Dangerou1Dav3> hmmm well IDK I tought that an application its the whole thing
00:36:56 <cocreature> (well to be precise it’s an application of x to + and then 3 to (x+)
00:37:13 <cocreature> an application consists of a function and exactly one argument
00:37:17 <cocreature> that’s it, there is nothing more to it
00:37:22 <cocreature> no abstraction around it or anything else
00:39:47 <Dangerou1Dav3> OK so the + symnol represent a function and for that reason its an application?
00:40:03 <Dangerou1Dav3> + operation*
00:40:18 <cocreature> yep
00:42:42 <Dangerou1Dav3> cocreature: Thank you! :)
00:42:47 <cocreature> yw :)
00:49:12 <humanoyd> Has anybody here used HaTeX (https://hackage.haskell.org/package/HaTeX) for a serious project (e.g. a paper)?
00:54:38 <merijn> humanoyd: Use it for a paper to do what?
00:56:18 <dexterph> humanoyd: I have, to me there's a tradeoff. It's hard to tell a colleague, with a straight face, that they have to edit a haskell file or instal ghc to help on the paper, so I've gone back to using LaTeX
00:57:53 <Athas> haskell-mode's syntax highlighting seems pretty slow.  Is there a way to speed it up?
00:58:43 <cookie3> http://espedito.homepc.it/ OneHostX..)
01:00:50 <Axman6> humanoyd: pandoc is probably a better option anyway, you get all the power of LaTeX, but can also use other formats like markdown if you don't need as much precision
01:00:54 <fr33domlover> dexterph, isn't LaTeX itself a huge distribution though? I mean, so many packages. Installing GHC, at least for me, is a single apt-get install, and then `stack build` etc. to get the deps from Hackage
01:01:52 <humanoyd> merijn: To write the paper with it. Part of what I really like about Haskell is its clean syntax...and LaTeX is pretty much on the other side of the spectrum
01:02:24 <Cale> fr33domlover: Well, but everyone who writes papers is already going to have LaTeX installed, while people who don't program in Haskell are probably not going to have GHC installed.
01:02:27 <humanoyd> dexterph: yes, that's a valid point...though I guess quasi-quoters could help a little bit with that
01:02:28 <merijn> humanoyd: tbh, I would just stick with LaTeX due the availability of like fifteen gazillion packages
01:02:45 <dysfun> and the literate haskell support...
01:02:57 <gothos> fr33domlover: same goes for haskell tho, I usually write my stuff in markdown and tell colleagues to install tex and pandon and execute make :}
01:03:04 <gothos> eh texlive
01:03:41 <dexterph> fr33domlover: well, 1) installing LaTeX is extremely easy (pacman -S texlive-most), 2) academics use latex all the time, it's guaranteed that they'll have it on their system
01:03:49 <merijn> LaTeX is generally huge because most distributions ship with every damn package. And thank god, I've almost never had a "package not installed" issue when trying to use some obscure package
01:04:01 <merijn> dexterph: CS and math academics
01:04:06 <merijn> dexterph: And maybe physics
01:04:10 <merijn> Everyone else uses Word
01:04:11 <humanoyd> Axman6: yes, I'm using pandoc for simple things...though I find that as soon as you need more advanced features, it quickly starts to look like LaTeX anyway so the readability of markdown is lost at some point
01:04:23 <merijn> markdown is awful
01:04:30 <merijn> At least use like rST or something
01:04:51 <merijn> markdown is ill-specified with lots of stupid corner cases it composes terribly
01:06:33 <quchen> merijn: Physics too, yes.
01:06:37 <fr33domlover> dexterph, good points. But when I worked at the local university, people here kept using m$ w0rd and were too lazy to give LaTeX a chance :-/ I think they still do and their papers look bad
01:07:05 <quchen> Markdown is nice for small documents, but terrible for documentation. I’m glad GHC has RST.
01:07:05 <fr33domlover> (it was in a "cyber security" reseach lab)
01:07:12 <gothos> I honestly never ran into one of them *shrug* but rst doesn't look too bad either
01:07:22 <dysfun> making latex look nice takes ages though. i can see why people at least prototype them in something else
01:07:48 <Axman6> if it's academic, most journals provide templates don't they?
01:07:52 <fr33domlover> Pandoc makes markdown much more pwerful though
01:08:01 <fr33domlover> (markdown alone is indeed weak)
01:08:04 <dexterph> humanoyd: quasi-quoters could help, yes, although ... I can just imagine it being 2 mintues before the deadline and some colleague is making some last minute changes but they accidentally altered some slight thing and they can't get the paper to build, for me LaTeX isn't thaaaat bad where I would risk it
01:08:05 <gothos> yes, most provide templates
01:08:07 <Axman6> basically every single paper I've read about Haskell looked identical, and it was great
01:08:19 <Axman6> so, just steal a template you like and use that
01:08:37 <gothos> some conferences don't care too much tho and you can run your own if it's not too awful
01:09:14 <dexterph> fr33domlover: Yeah, word is terrible, I feel bad for you there. Luckily everyone here uses LaTeX, as most (all) people do in the PL field (or CS field in general)
01:10:05 <dexterph> every conference I know of has provided a template
01:10:17 <merijn> dysfun: What do you mean by "look nice"? Usually I just use the regular templates/article style and just fix minor issues
01:10:25 <quchen> \beginfigure[hH!!!PUTTHISHEREGODDAMMIT]
01:10:30 <quchen> … LaTeχ 
01:10:45 <merijn> quchen: Still better than word
01:10:58 <dysfun> i'm no fan of word, but i don't like any markup language really
01:11:29 <dysfun> and it does take time to make papers look nice, arranging figures appropriately, fixing places where it looks odd
01:11:35 <quchen> merijn: Picture, here. Picture is here. I hope you’re happy with it here, because if you ever move it or add a header or footer the world will come to an end. Also let me renumber your sections starting with π because.
01:12:48 <dysfun> and people really need to learn to use xelatex. computer modern doesn't actually look very nice
01:12:59 <quchen> Blasphemy!
01:13:24 <dysfun> knuth may have been religious, but i don't think he founded a religion
01:14:24 <merijn> dysfun: XeLaTeX is basically identical to LaTeX
01:14:33 <merijn> dysfun: Some of the font selection stuff is changed
01:14:43 <dysfun> like support for OTF fonts
01:14:43 <merijn> And it can work with unicode
01:15:04 <merijn> dysfun: Most TeX distributions already ship with Xe(La)TeX
01:15:14 <dysfun> everyone uses texlive anyway?
01:15:18 <Xe> hi
01:15:49 <dysfun> did you just get highlighted by our talking about XeLaTeX ? :)
01:16:08 <merijn> My CV is done in XeLaTeX with OTF abuse :p
01:16:19 <merijn> Lots of alternate glyphs and ligatures :p
01:16:46 <dysfun> mine used to be. i keep it in openoffice now because nobody who will offer me work gives a fuck about typesetting
01:16:55 <mniip> > eval clsEnv $ apFun `AppTerm` ConTerm listConsCon [notFun, ConTerm listConsCon [idFun, ConTerm listNilCon []]] `AppTerm` ConTerm listConsCon [ConTerm boolFalseCon [], ConTerm listConsCon [ConTerm boolTrueCon [], ConTerm listNilCon []]]
01:16:57 <lambdabot>  ConTerm : [ConTerm True [],ConTerm : [ConTerm False [],ConTerm : [ConTerm Fa...
01:17:02 <mniip> \o/
01:17:45 <merijn> dysfun: I've gotten very positive replies from everyone about the look
01:17:50 <merijn> dysfun: Looks matter :)
01:17:51 <mniip> why is this not in GHC yet
01:18:01 <quchen> ?
01:18:06 <mniip> dynamic haskell :D
01:18:18 <quchen> String is in Base
01:18:25 <quchen> You can use that to get dynamic Haskell
01:18:47 <quchen> It’s just as awful as it should be. :-þ
01:18:56 <mniip> not really
01:19:23 <mniip> it's like a stronger version of -fdefer-type-errors
01:19:42 <mniip> so much stronger that it can actually express the Y combinator
01:20:26 <merijn> -fdefer-type-errors is awful :(
01:22:17 <Cale> You can express the Y combinator without -fdefer-type-errors though, you just need a newtype ;)
01:23:21 <mniip> @let yFun = LamTerm "f" (LamTerm "x" (VarTerm "f" `AppTerm` (VarTerm "x" `AppTerm` VarTerm "x")) `AppTerm` LamTerm "x" (VarTerm "f" `AppTerm` (VarTerm "x" `AppTerm` VarTerm "x")))
01:23:23 <lambdabot>  Defined.
01:23:41 <quchen> Cale: I never understood why though
01:23:50 <quchen> Somehow the newtype breaks the infinite type, but how?
01:24:06 <Cale> quchen: Why you need a newtype, or why the newtype works?
01:24:24 <quchen> Yes. :-D
01:25:01 <Cale> Well, write the Y combinator and look at the type error you get
01:25:02 <quchen> Well, "why you need a newtype" is “because it works”. But why it works is a mystery.
01:25:33 <mniip> > eval [] $ yFun `AppTerm` (LamTerm "x" (ConTerm listConsCon [ConTerm unitCon, VarTerm "x"]))
01:25:35 <lambdabot>      Couldn't match expected type ‘Term’
01:25:35 <lambdabot>                  with actual type ‘[Term] -> Term’
01:25:35 <lambdabot>      Probable cause: ‘ConTerm’ is applied to too few arguments
01:25:39 <mniip> > eval [] $ yFun `AppTerm` (LamTerm "x" (ConTerm listConsCon [ConTerm unitCon [], VarTerm "x"]))
01:25:41 <lambdabot>  ConTerm : [ConTerm () [],ConTerm : [ConTerm () [],ConTerm : [ConTerm () [],C...
01:25:53 <Cale> :t \f -> (\x -> f (x x)) (\x -> f (x x))
01:25:54 <lambdabot>     Occurs check: cannot construct the infinite type: r0 ~ r0 -> r
01:25:55 <lambdabot>     Expected type: r0 -> r
01:25:55 <lambdabot>       Actual type: (r0 -> r) -> r
01:26:08 <Cale> So we need a type r0 which is the same as r0 -> r
01:26:31 <quchen> Yes.
01:26:35 <quchen> That part is clear.
01:27:03 <Cale> So we'll define a newtype to stand for the r0
01:27:24 <Cale> say, Rec r
01:27:38 <Cale> and we know that we want Rec r to be the same as Rec r -> r
01:27:47 <quchen> @let newtype Rec r = Rec { unRec :: r }
01:27:49 <lambdabot>  Defined.
01:27:55 <Cale> nope
01:27:58 <mniip> nuh-uh
01:27:59 <quchen> ?undef
01:28:00 <lambdabot> Undefined.
01:28:02 <humanoyd> What I'd be interested in for TeX is separating the presentation and the meaning of equations...e.g. `frac` or `sfrac` is just a presentational matter but the math doesn't change...so ideally one could do something like `show asSmallAsPossible equation1` and `plot defaultOptions equation1`
01:28:02 <Cale> unRec :: Rec r -> r
01:28:11 <mniip> aww, you wiped out my dynamic haskell :(
01:28:26 <Cale> @let newtype Rec r = In { out :: Rec r -> r }
01:28:27 <lambdabot>  .L.hs:155:27:
01:28:28 <lambdabot>      Ambiguous occurrence ‘Rec’
01:28:28 <lambdabot>      It could refer to either ‘L.Rec’, defined at .L.hs:155:1
01:28:31 <mniip> int-e, why does letlpaste only allow 4 KB?
01:28:31 <Cale> oh, right
01:28:37 <Cale> @let newtype R r = In { out :: R r -> r }
01:28:38 <lambdabot>  .L.hs:158:30:
01:28:38 <lambdabot>      Ambiguous occurrence ‘out’
01:28:38 <lambdabot>      It could refer to either ‘L.out’, defined at .L.hs:155:18
01:28:41 <Cale> FINE
01:28:44 <Cale> haha
01:28:44 <merijn> mniip: wut
01:28:54 <merijn> mniip: Why are you trying to paste more than 4 KB? >.>
01:29:05 <quchen> ?let newtype CaleR r = CaleIn { caleOut :: CaleR r -> r }
01:29:07 <lambdabot>  Defined.
01:29:07 <Cale> Well, this already exists in lambdabot as InR/outR, I think
01:29:11 <Cale> sure
01:29:13 <mniip> merijn, it's a language interpreter
01:29:18 <Cale> :t CaleIn
01:29:19 <lambdabot> (CaleR r -> r) -> CaleR r
01:29:21 <mniip> getting it within 4K is a hassle
01:29:23 * quchen imported Cale qualified
01:29:26 <Cale> :t caleOut
01:29:27 <lambdabot> CaleR r -> CaleR r -> r
01:29:32 <merijn> mniip: At that size wouldn't it be simpler to put it in like a github gist?
01:29:37 <merijn> mniip: Or just a repo...
01:29:44 <quchen> merijn: It’s in a ?letlpaste
01:29:46 <Cale> So, these go back and forth between CaleR r and (CaleR r -> r) explicitly
01:29:58 <quchen> Cale: Okay.
01:30:00 <Cale> i.e. instead of an equality of types r0 ~ r0 -> r
01:30:02 <quchen> Makes sense so far.
01:30:05 <Cale> we just have an isomorphism
01:30:36 <Cale> and then it just comes down to putting in uses of the isomorphism in the places where the typechecker is upset
01:30:39 <mniip> merijn, but I wouldn't be able to load it into lambdabot then :(
01:30:58 <quchen> Cale: It’s strange that we can just make up an isomorphism like that.
01:31:08 <merijn> quchen: How so?
01:31:41 <quchen> To me those types look incompatible.
01:31:47 <quchen> To the typechecker they look in compatible.
01:31:48 <merijn> quchen: Actually, this isomorphism approach for recursive types is one of the ways TaPL suggest tackling recursive types :p
01:31:59 <mniip> @letlpaste 442294937573130240
01:31:59 <mniip> @letlpaste 2374451800347508736
01:32:01 <lambdabot>  Defined.
01:32:03 <lambdabot>  Defined.
01:32:09 <quchen> And then we say “here’s a wrapper” and the typechecker agrees.
01:32:24 <quchen> It’s like “sudo let me write this”.
01:32:49 <mniip> now, where was I
01:33:15 <mniip> > pureFun
01:33:16 <lambdabot>  LamTerm "x" (StuckTerm "Pointed" [] "pure" (AppTerm (VarTerm "pure") (VarTer...
01:33:17 <Cale> quchen: Well, we've replaced needing recursion at the value level with needing recursion at the type level
01:33:18 <mniip> fancy huh
01:33:30 <Cale> quchen: If we didn't have recursion at the type level, we would again be stuck
01:33:57 <quchen> Cale: Wait, there is no recursion at the value level left?
01:34:24 <Cale> quchen: Well, we don't need any for the Y combinator to work.
01:34:32 <mniip> quchen, yup, you can now write Y wherever you want
01:34:48 <Cale> and it lets us make effectively recursive definitions
01:34:49 <quchen> Cale: Oh, right. That's the point of it.
01:37:05 <Cale> Now, as for why you ought to be prevented from writing the Y combinator normally -- well, the original point of type systems was to prevent it :D
01:37:26 <Cale> (though we've gone and stuck recursion back in, spoiling things again)
01:38:04 <Cale> Originally, the lambda calculus was an early attempt to formulate logic in a mechanical way.
01:39:05 <quchen> You mean when Church was active
01:39:17 <Cale> The original untyped lambda calculus is actually kind of surprisingly not what we think of it as today -- it had an explicit logical negation operator, for instance.
01:39:38 <quchen> Huh? And did it have booleans?
01:39:46 <quchen> Or some other notion of truth?
01:39:52 <Cale> not separately
01:44:18 <Cale> http://sci-hub.cc/http://www.jstor.org/stable/1968337
01:45:30 <Cale> Really really weird :D
01:45:46 <mniip> I need to write a parser for this thing
01:45:56 <mniip> typing out ASTs is no fun
01:47:28 <quchen> I wonder whether there’s a non-gambling way of writing Y with this Rec type.
01:48:01 <Cale> :t InR
01:48:02 <lambdabot> (Rec a -> a) -> Rec a
01:48:08 <Cale> turn a function into a Rec
01:48:12 <Cale> :t outR
01:48:14 <lambdabot> Rec a -> Rec a -> a
01:48:22 <quchen> Sure.
01:48:35 <Cale> Note that outR is the one which takes two parameters of the same type
01:49:03 <Cale> So when you have "x x", you can bet that you need to apply outR to the first x so that you can apply it to itself :)
01:49:07 <Cale> and that tells you the type of x
01:49:11 <Cale> needs to be a Rec
01:49:12 <quchen> :t \f -> (\x -> f (InR x) (InR x)) (\x -> f x x)
01:49:13 <lambdabot> (Rec a -> Rec a -> a) -> a
01:49:15 <quchen> That was where I landed.
01:49:20 <quchen> And that’s a dead end.
01:49:39 <Cale> You're missing some parens
01:50:00 <Cale> It's \f -> (\x -> f (x x)) (\x -> f (x x))
01:50:14 <Cale> So let's start by putting in the outR's
01:50:31 <Cale> \f -> (\x -> f (outR x x)) (\x -> f (outR x x))
01:50:46 <Cale> But now look at the x in the first lambda
01:50:53 <Cale> It ought to be bound to a Rec
01:51:04 <Cale> So the second lambda needs to be turned into a Rec
01:51:13 <Cale> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
01:51:49 <Cale> :t \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
01:51:50 <lambdabot> (a -> a) -> a
01:52:38 <mniip> hmm I wonder
01:52:56 <quchen> Cale: Still processing why InR is there (and not also elsewhere) …
01:53:01 <quchen> Should probably revisit Tapl
01:53:14 <Cale> quchen: just think about the type of x in the first lambda
01:53:27 <Cale> It's got to be Rec a, because we're applying outR to it
01:53:28 <mniip> @let yFun = LamTerm "f" (VarTerm "f" `AppTerm` (yFun `AppTerm` VarTerm "f"))
01:53:31 <lambdabot>  Defined.
01:53:38 <mniip> > eval [] $ yFun `AppTerm` (LamTerm "x" (ConTerm listConsCon [ConTerm unitCon [], VarTerm "x"]))
01:53:40 <lambdabot>  ConTerm : [ConTerm () [],ConTerm : [ConTerm () [],ConTerm : [ConTerm () [],C...
01:53:47 <quchen> mniip: Private session?
01:53:50 <mniip> oh so it does work as a graph reduction thing
01:53:54 <mniip> okay okay
01:54:00 <Cale> and the second lambda is presumably a function (Rec a -> a)
01:54:19 <Cale> (already)
01:54:20 <quchen> “presumably”?
01:54:26 <Cale> (\x -> f (outR x x))
01:54:54 <quchen> Ah, we know f’s type because we want to write Y.
01:54:54 <Cale> We know that its argument has to be something of type Rec a, for the same reason just discussed, that we're applying outR to it
01:55:02 <Cale> and yeah, we know f's type
01:55:43 <Cale> So we have something of type (Rec a -> a) and we want it to be a Rec a
01:55:48 <Cale> But that's what InR does
01:57:41 <Cale> and then we can go stick this into a .hs file and compile it with GHC and watch the inliner go to town on it and blow up
01:58:17 <quchen> Really
01:59:54 <Cale> Yeah, if you have optimisations turned on, it'll panic
02:00:20 <Cale> This is well known and not something that anyone intends to fix, since it basically only ever comes up in this contrived case.
02:00:44 <Cale> Well, I should really try it with GHC 8 :P
02:01:11 <Cale> but I completely expect it to be the same as always -- this bug has existed for the entire time I've been using Haskell :P
02:02:55 <Cale> [1 of 1] Compiling Main             ( y.hs, y.o )
02:02:55 <Cale> ghc: panic! (the 'impossible' happened)
02:02:55 <Cale>   (GHC version 8.0.1 for x86_64-unknown-linux):
02:02:55 <Cale> 	Simplifier ticks exhausted
02:02:56 <Cale>   When trying UnfoldingDone x_s1a5
02:03:03 <Cale> yep
02:06:00 <schmittr> Hey guys, as I'm new to haskell I'm wondering, if there is the possibility to change some subtree in an unknown json string. i.e. I want to extract a specific key, which I get via an SQL request, extract the subtree/value behind it, manipulate this as sting and pass it back at this position (replacing the old subtree/value)
02:15:14 <sgronblo> schmittr: I think most JSON libraries in typed languages can parse JSON into a generic JSONValue type structure which you could then perform a transformation on and then serialize it back out to a string
02:17:36 * hackagebot alarmclock 0.4.0.1 - Wake up and perform an action at a certain time.  https://hackage.haskell.org/package/alarmclock-0.4.0.1 (dcturner)
02:18:05 <schmittr> sgronblo: my problem is, that I do not have a specific preknowledge about the structure, as this depends from the DB. Thus I only have the searched keys as string. I didn't find anything how I could possibly do it like that. I found something about lense, but I dunno, I'm new to haskell :(
02:19:29 <Cale> schmittr: If you use Aeson, its "Value" type can represent arbitrary JSON values in a structured way.
02:20:20 <Cale> schmittr: So even if you know nothing about the string apart from the fact that it's valid JSON, you can decode it as a Value, do whatever transformation Value -> Value you want, and then turn it back into a string again.
02:21:25 <fraid> does anyone use haskell-vim-now? when i write func = .. my cursor gets placed in the main module so i the two dots gets placed there instead of after the = which is what i want? how can i stop the cursor from jumping when writing functions?
02:22:22 <Cale> I dunno, that kind of thing is exactly the kind of thing that makes me stop using fancy editor plugins.
02:22:34 <Cale> But perhaps someone else has a better answer :)
02:22:43 <merijn> Cale: Word
02:23:06 <merijn> Cale: All these "ultimate haskell vim plugin" bundles seem to come with like 5gb of plugins screwing up your editors
02:24:04 <schmittr> let me give you an example: { "id" : 3, "nested": { "somekey" : "somevalue" }, "key":"value" } now I know that the required key name is "nested" which I estimate by an SQL statment (which already works very well). No I want to read out the whole subtree behind nested do some manipulation (encrypting the whole subtree) and set it as value behind "nested" again
02:24:30 <schmittr> Aeson sounds good, but no clue, how to do that, I'm such a noob :D
02:27:46 <Cale> schmittr: https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson.html#t:Value -- so here, it lists the data constructors for the Value type
02:29:09 <Cale> You probably want to pattern match on the Object data constructor, which has a single field of type "Object", which if we click on it in the documentation, it says is a type synonym for HashMap Text Value
02:29:29 <Cale> If from there, you click on HashMap, it'll take you to the documentation for manipulating hashmaps
02:29:54 <Cale> adjust :: (Eq k, Hashable k) => (v -> v) -> k -> HashMap k v -> HashMap k v
02:29:58 <Cale> might be useful
02:30:07 <Cale> There's also
02:30:09 <Cale> update :: (Eq k, Hashable k) => (a -> Maybe a) -> k -> HashMap k a -> HashMap k a
02:30:26 <Cale> which lets you delete the key in case the function produces Nothing
02:30:31 <Cale> alter :: (Eq k, Hashable k) => (Maybe v -> Maybe v) -> k -> HashMap k v -> HashMap k v
02:30:39 <schmittr> nice, thank you very much! That means I can press my json into a Hashmap (Object) and work on that one
02:30:46 <Cale> which lets you handle the case that the key doesn't occur
02:30:51 <Cale> yeah
02:31:09 <Cale> So, you'll want to write a function of type Value -> Value, which will pattern match on the Object constructor
02:31:47 <Cale> and then perhaps a function Value -> Value which you're going to pass to adjust in order to transform that subtree
02:32:37 * hackagebot authenticate 1.3.3.2 - Authentication methods for Haskell web applications.  https://hackage.haskell.org/package/authenticate-1.3.3.2 (MichaelSnoyman)
02:32:39 <Cale> So it'll look like  outerTransformation (Object o) = Object (adjust innerTransformation "nested" o)
02:33:15 <Cale> and then perhaps  outerTransformation x = x  as a second case just to do nothing to any other JSON values
02:33:44 <Cale> and then innerTransformation will also be Value -> Value and will do your encryption or whatever
02:33:57 <schmittr> ah ok, I see. So I need to apply a transformation to every key/value pair
02:34:24 <schmittr> and rebuild the whole thing and cannot just cherrypick the nested one
02:34:25 <Cale> does it transform the keys?
02:34:29 <schmittr> nope
02:34:36 <Cale> mapWithKey :: (k -> v1 -> v2) -> HashMap k v1 -> HashMap k v2
02:34:43 <schmittr> haskell really isn't easy :D
02:34:53 <Cale> Really? I think this is pretty easy :)
02:35:04 <Cale> map :: (v1 -> v2) -> HashMap k v1 -> HashMap k v2
02:35:06 <schmittr> Than I'm too complicated :D
02:35:29 <Cale> This'll apply a function to every value in the map, leaving the keys untouched
02:35:42 <schmittr> ok
02:35:42 <Cale> mapWithKey is for if you want what gets done to depend in some way on the key
02:35:54 <Cale> (but you're not going to change the keys)
02:36:39 <Cale> So you just write your function to transform the entry, and use this and it'll apply it to all of them.
02:37:14 <schmittr> well, I need the whole subtree as string in order to encrypt it.
02:37:20 <Cale> ah, okay
02:37:26 <Cale> so you'll want to encode it
02:37:32 <schmittr> kinda
02:37:38 <Cale> encode :: ToJSON a => a -> ByteString
02:37:43 <schmittr> yep
02:37:47 <schmittr> ok
02:37:51 <schmittr> nice
02:37:58 <Cale> (and Value is an instance of that)
02:38:33 <schmittr> thank you, very helpfull. I'll try my best :)
02:40:08 <fraid> does anyone use haskell-vim-now? when i write func = .. my cursor gets placed in the main module so i the two dots gets placed there instead of after the = which is what i want? how can i stop the cursor from jumping when writing functions?
02:52:21 <mpickering> Is there a way to tell stack to use the versions of GHC on my path
02:54:22 <nmattia> mpickering: would this do? :   --[no-]system-ghc        Enable/disable using the system installed GHC (on the
02:54:42 <nmattia> .. Operating system)
02:55:07 <mpickering> My exact situation is the stack.yaml picks out a 7.10.3 resolved
02:55:09 <mpickering> *resolver
02:55:31 <mpickering> but my "ghc" is 8.0.1 but I have ghc-7.10.3 already installed on my path
02:55:37 <mpickering> I will try that
02:57:45 <mpickering> it doesn't work in this case
03:02:04 <jgt> anyone here worked with Thoughtbot's yesod-auth-oauth2?
03:03:13 <ski> quchen : the Y combinator requires a cyclic type (aka an equi-recursive type). this could be allowed (and inferred) by a type system (like if you start OCaml as `ocaml -rectypes'), but typically isn't done because (a) lots of mistakes now gets transformed from type errors to strange cyclic types; and (b) attempting to only infer recursive types tends to construct larger types than intended
03:03:50 <ski> (and as Cale said, logically corresponding to circular reasoning)
03:12:37 * hackagebot alarmclock 0.4.0.2 - Wake up and perform an action at a certain time.  https://hackage.haskell.org/package/alarmclock-0.4.0.2 (dcturner)
03:13:11 <int-e> mniip: the 4kb is an arbitrary limit, but why on earth would you need more than that...
03:13:44 <aphorisme> Hey! I'm looking for a piece of advice considering general design ideas. This might be a too coarse question; not sure. Most of the times when designing a library which publishes a certain functionality in Haskell (for example a small graph database, where one can specify the kind of edges), I have the choice of designing it in either of two ways: 1) make choices available via type system (determining an edge becomes type MyEdge =
03:13:45 <aphorisme>  ... instance Edge MyEdge). 2) make choices available at runtime (determining an edge becomes myEdge = Edge ... where data Edge = ... )
03:13:51 <aphorisme> Which would you choose when and why?
03:13:55 <mniip> int-e, you did just witness an example of that
03:16:41 <int-e> mniip: I think you're simply exceeding the size of the toy examples that lambdabot is meant for.
03:20:10 <ibrahim> hello people
03:20:21 <ibrahim> i was trying to follow this book
03:20:24 <ibrahim> http://chimera.labs.oreilly.com/books/1230000000929/ch12.html
03:20:34 <ibrahim> concurrent programming in haskell
03:20:44 <ibrahim> there's one thing i couldn't wrap my head around
03:21:38 <ibrahim> http://chimera.labs.oreilly.com/books/1230000000929/ch12.html#CO43-13
03:21:47 <int-e> mniip: the fact that letlpaste exists is a concession from my point of view, to avoid people having to enter the same half-dozen definitions each time they want to demonstrate some example that answers a recurring question. for that purpose, 4kb is plenty enough.
03:21:48 <ibrahim> here when i'm trying to write to a TVar
03:22:42 <ibrahim> does it wake up every other thread simultaneously? 
03:22:46 <mniip> also any update on GHC 8?
03:22:51 <mniip> int-e:
03:23:39 <int-e> yes, once I get this pile of reviews off my desk
03:24:01 <ibrahim> why can't i have another message get interleaved with the current factor change?
03:26:25 <int-e> mniip: out of curiosity and to perhaps increase my motivation, what ghc 8 feature are you missing most?
03:26:40 <mniip> TypeInType
03:27:26 <mniip> well, also there's #11699 that's getting in the way quite often
03:27:42 <Squarism> As ive understood, using profiling libs is the only way to get stack traces. I wonder, do people use that in production too? Exceptions can be a great way of finding errors i mean.
03:28:22 <nmattia> Squarism: GHC 8 has some support for stack traces
03:28:48 <quchen> ibrahim: Yes, writing to a TVar changes its contents, and wakes every thread that depends on it.
03:29:25 <quchen> ibrahim: It’s known as “Thundering Herd”. https://en.wikipedia.org/wiki/Thundering_herd_problem
03:32:29 <ibrahim> oh, i guess what prevents interleaving was not STM but the check for the previous value. my bad.
03:52:39 * hackagebot rest-client 0.5.1.1 - Utility library for use in generated API client libraries.  https://hackage.haskell.org/package/rest-client-0.5.1.1 (ErikHesselink)
04:11:53 <tsahyt> How does type safety hold up with phantom types and Data.Coerce? For example say there's newtype Message a = Msg Text, with the intention of differentiating between Message PlainText and Message Encrypted, and there's a function encrypt :: Message PlainText -> Message Encrypted and several functions that only take the encrypted variant to make sure that plaintext isn't sent over the network. What's to stop a
04:11:55 <tsahyt> user of the library to do this anyhow by just using coerce?
04:13:07 <tsahyt> the two types are representationally equal, so GHC would generate a Coercible instance
04:13:47 <tsahyt> put differently, how can a library author prevent this?
04:14:05 <merijn> tsahyt: Role annotation
04:14:18 <merijn> tsahyt: Consult GHC manual for details
04:14:55 <tsahyt> merijn: ah I see. but what's the reasoning behind having the phantom role default to this behavior?
04:15:19 <merijn> tsahyt: "Otherwise all existing libraries have to be updated...*whine**whine*"
04:15:25 <tsahyt> :/
04:15:26 <merijn> So yes, the default behaviour is unsafe
04:15:28 <tsahyt> that's disappointing
04:16:24 <tsahyt> "Could not coerce from 'Char' to 'Int'". nice, that's what I wanted
04:16:32 <quchen> How is WHNF defined again? A term without a redex on the outermost level sounds too simplistic.
04:16:34 <fr33domlover> Shouldn't people be careful anyway when using coerce?
04:16:56 <quchen> fr33domlover: unsafeCoerce is dangerous, coerce is safe.
04:16:58 <merijn> The entire point is that it's supposed to be safe
04:17:06 <tsahyt> fr33domlover: I only ever used it for unpacking newtypes
04:17:26 <quchen> fr33domlover: I often use coerce in definitions like `unNewtype . f . Newtype` to save the `unNewtype`.
04:17:26 <tsahyt> as a way of saying "I don't need the additional type information anymore"
04:17:44 <quchen> fr33domlover: That way I don’t need a record definition, which I find akwward to read.
04:18:41 <fr33domlover> Ah I see
04:18:47 * fr33domlover never used coerce
04:21:13 <fr33domlover> btw what's the math term for "A directed path exists from u to v in a graph"?
04:21:43 <merijn> "A directed path exists from u to v in a graph"? :p
04:21:48 <merijn> What's wrong with that term?
04:22:04 <fr33domlover> merijn, I need to name a function f :: Node -> Node -> Graph -> Bool
04:22:11 <merijn> "connected"?
04:22:12 <fr33domlover> just wondering about possible short names
04:22:21 <tsahyt> +1 for connected
04:22:23 <merijn> Or just "pathExists"
04:23:14 <fr33domlover> yeah these are the same ideas I had :P just wanted to know if a math term exists because 'fgl' tends to use very short names and letter prefixes etc.
04:24:25 * fr33domlover will go for 'connects' because 'connected' sounds a bit like direction doesn't matter
04:24:45 <tsahyt> but direction always matters in a directed graph
04:26:09 <tsahyt> I suppose there's no way to have "or" in constraints?
04:26:38 <fr33domlover> tsahyt, yeah but I also have an undirected version and FGL graphs can be treated as undirected :P
04:26:39 <merijn> I wouldn't rulle it out
04:26:44 <merijn> But it won't be pretty :p
04:27:03 <tsahyt> It's easier to define a helper class then I think
04:38:47 <ski> fr33domlover : an alternative might be `reachable'
04:51:48 * ertesx tries to get started with purescript, reads about pulp and bower, and immediately returns to GHCJS
04:52:03 <dysfun> ertesx: exact same thing happened to me this week
04:53:15 <ertesx> sorry, not gonna happen, until i can figure out how to hide those under a thick layer of nix or something
04:55:48 <bernalex> ertesx: yeah ended up too much work for me too.
04:55:54 <bernalex> and I quite like the language.
04:55:57 <ertesx> actually in this project i'm using jmacro rather than GHCJS, and it's small enough that i thought i might give PS a try for that one
04:56:14 * dysfun is currently evaluating ghcjs-hplay (actually seems to use haste) and reflex-dom
04:57:08 <ertesx> yeah, i liked it, too…  but the complexity of actually using it seems to be too high, if you have a specific development workflow and deployment model that is *not* pulp/bower
04:57:41 <merijn> I don't even know wtf those are
04:58:11 <dysfun> bower is for *client side* js deps
04:58:17 <dysfun> and it's shit (imo)
04:58:25 <dysfun> i had never even heard of pulp previously
04:58:42 <maerwald> sounds like people complaining their old tools don't work with new tools
04:58:49 <ertesx> merijn: products of the wonder that is "productive javascript" (sounds ironic, doesn't it?)
04:59:01 <merijn> And here I am over here hand writing makefiles...
04:59:42 <ertesx> maerwald: i assure you, my tools are pretty new, but they are not pulp
04:59:44 <bernalex> javascript tooling is beyond ridiculous though. there's a million different tools per project, and all work so-so well independently, and terribly together.
04:59:51 <dysfun> well, you wouldn't want to leave it to autotools, would you?
04:59:55 <merijn> The entire JS ecosystem needs to learn from suckless
05:00:01 <maerwald> I can't use cabal with Swift, so I'm gonna stick with haskell.
05:00:35 <ertesx> suckless being the other extreme though…  probably not the one to learn from =)
05:00:44 <ertesx> rather something like s6:  just enough to be useful
05:00:48 <bernalex> maerwald: there's a world of difference between using pip, gems, cabal, autotools, whatever each language wants you to use, and javascript where it's ten thousand tools that all break all of the time.
05:01:02 <merijn> ertesx: Really? I agree with their philosophy :)
05:01:05 <maerwald> weird, they don't break for me
05:01:12 <bernalex> if it were just grunt, and grunt actually worked more than 80% of the time, it'd be fine by me.
05:01:22 <maerwald> sounds like stack users telling me my cabal breaks all the time, except it doesn't
05:01:31 <tdammers> in all fairness, I find pip, gems, cabal and autotools at least as terrible as npm, in their own special ways
05:01:31 <ertesx> merijn: it's a good philosophy in principle, but software they produce tends to be…  not so useful in practice =)
05:01:34 <jgt> just putting it out there: Grunt.js *sucks*
05:01:37 <dysfun> maerwald: as we've established, nothing ever breaks for you, but we've also just established you don't use anything except cabal
05:01:46 <maerwald> that's incorrect
05:01:47 <merijn> maerwald: Word...
05:02:26 <maerwald> javascript tools are annoying, but they don't break all the time
05:02:32 <tdammers> suckless, I like the philosophy, but it's kind of an extreme swing in the opposite direction
05:02:46 <merijn> tdammers: Sure, like with everything, take with a grain of salt
05:02:54 <jgt> JavaScript tools break a lot of the time
05:03:11 <jgt> or rather, they do if you follow current trends
05:03:15 <merijn> tdammers: They need to be extreme because everyone is way over on the other extreme, gotta make sure the middle is sane when meeting in the middle :p
05:03:15 <bernalex> tdammers: I mostly agree -- and my experience with grunt is pretty good. the problem is when there's several projects, all >10K SLOC, the workflow becomes really wonky with a ton of tools that break all the time, mostly due to everything moving independently, and way too fast.
05:03:33 <tdammers> wrt javascript tooling, my biggest complaints are 1) that it's a bit unclear which of the many options one should use (the community doesn't seem to agree either), and that they all violate Unix principles
05:03:38 <ertesx> anyway, GHCJS it is…  it's cabal, and cabal integrates nicely with everything i use
05:03:40 <tdammers> (the latter being 2))
05:03:54 <tdammers> merijn: I didn't say I disagree ;)
05:04:04 <merijn> oh joy
05:04:06 <ertesx> (well, not nicely, but automatically and reliably)
05:04:19 <merijn> Now we get the fun game of "Why does my dynamic linking code work on OSX but not on linux"
05:04:36 <dysfun> yay, those are always fun
05:05:00 <bennofs> at least you can use a vm in this direction
05:05:13 <maerwald> jgt: I'm developing a 3-component js application (frontend, backend, ftp server etc) full of grunt, automatic rebuilds, deployment scripts, mocha tests and other crap and everything within docker containers. Stuff rarely "just" breaks.
05:05:19 <maerwald> it's just all those tools are rather annoying
05:05:24 <jgt> merijn: …Haverbeke?
05:05:27 * ertesx wouldn't even know that JS tools break all the time, but had the pleasure to work with such masterpieces as grunt and bower in the past…  what a delightful experience that was…
05:05:43 <merijn> bennofs: I don't need to, I have linux machines lying around
05:05:54 <merijn> jgt: No? :p
05:06:01 <dysfun> ertesx: when you check out a tag of a random project and the random js build script doesn't work
05:06:06 <jgt> ah, sorry :P
05:06:30 <merijn> I get confused with different Merijns all the time :p
05:06:54 <merijn> dysfun: Looks like it's a classic "oh god, why does the linux linker suck balls so badly?!"
05:06:59 <ertesx> dysfun: yeah, that was pretty much the problem…  the tools didn't "break", they just didn't help and steepened the learning curve…  a colleague had to explain to me how to get his project to build
05:07:05 <merijn> Which idiot decided single-pass linking was nice
05:07:09 <maerwald> I make changes across components and they get automatically rebuilt and restarted without any interference
05:07:29 <dysfun> merijn: s/(the|linker) //g # FTFY :)
05:07:40 <jgt> maerwald: if it works for you, then great. I personally can't deal with the frustration of things breaking relatively often, and having to jump through silly hoops to do simple things
05:07:51 <ertesx> dysfun: later, with every fifth change he made, stuff stopped working for me, and he had to correct things once again
05:08:16 <maerwald> jgt: well, those tools are like Makefiles. One can do a lot of things wrong. They are not particularly high-level imo.
05:08:23 <dysfun> ertesx: had this with vagrant at one place. it would have been hilarious if it weren't so tragic (hour long builds that fail)
05:08:52 <ertesx> the irony is that it was all JS…  there was no actual *compilation* involved
05:08:57 <jgt> maerwald: I think there's a strong philosophical difference between Make and Grunt/Gulp
05:09:01 <ertesx> it was all about dependencies
05:09:10 <jgt> maerwald: in fact, I did a conference talk on *exactly* that topic
05:09:19 <maerwald> jgt: sure, but that wasn't my point
05:09:40 <merijn> Make is surprisingly high level if you learn it :)
05:09:46 <jgt> https://www.youtube.com/watch?v=JdqBbBazSPE if you're interested :P
05:09:50 <ertesx> merijn: GNU make, yeah =)
05:09:54 <merijn> It's basically a DSL for task trees
05:09:56 <ertesx> i use it a lot
05:10:03 <maerwald> merijn: I've literally never seen a Makefile that was written properly in the first place
05:10:35 <maerwald> it always took several distro developers to make it work, because they know about all the gotchas
05:10:35 <dysfun> accidentally invoking bsd make instead of gnu make makes for fun error messages on most makefiles
05:10:53 <maerwald> your Makefile does not work on debian... 2 weeks later: your Makefile does not work on Fedora
05:10:55 <maerwald> etc
05:11:11 <merijn> Sounds more like those distros suck :p
05:11:17 <dysfun> all distros suck
05:11:20 <ertesx> to me 'make' is more like a personal tool…  i use it to convert pictures, etc., not for development
05:11:25 <ertesx> so i don't care too much about portability
05:11:38 <maerwald> merijn: no, it sounds like the Makefile is not portable
05:11:48 <maerwald> which is a rather hard thing to achieve
05:11:53 <dysfun> whenever i have to write C projects, it makes me appreciate the build tools other languages have
05:12:19 <ertesx> maerwald: targets = $(patsubst %.md,%.html,$(wildcard *.md))
05:12:21 <ertesx> there, achieved
05:13:05 <maerwald> ertesx: did you try that with bsd make?
05:13:10 <ertesx> nope
05:13:21 <maerwald> ...
05:13:26 <ertesx> does it work?
05:13:47 <ertesx> i'm pretty sure it's not portable in general, even if it happens to work on BSD make
05:14:10 <maerwald> patsubst is GNU syntax afair
05:14:22 <merijn> TBH, for my current make stuff I don't care about portability beyond GNU make anyway :)
05:14:32 <maerwald> http://pubs.opengroup.org/onlinepubs/9699919799/utilities/make.html have fun reading lol
05:14:43 <maerwald> (no it is not fun)
05:14:45 <ertesx> maerwald: exactly…  in other words: unportable makefiles are very easy to achieve
05:14:55 <ertesx> just try to use anything *useful* from GNU make =)
05:15:03 <maerwald> and writing broken grunt stuff is also easy, which was my point
05:16:48 <ertesx> confusingly enough i have a Makefile in every haskell project that is not used for building at all…  i use it for deployment, docs generation (for hackage), etc.
05:17:13 <maerwald> ertesx: try those with -j8 and see what breaks 
05:17:21 <ertesx> maerwald: nothing
05:17:49 <maerwald> most people get the dependencies wrong thus parallel build breaks even for simple things
05:18:22 <maerwald> I'd rather use a shell script for docs generation honestly :P
05:18:28 <ertesx> it's not easy to get them right either, but mine works
05:18:50 <ertesx> a make recipe basically *is* a shell script
05:19:00 <maerwald> erm
05:19:29 <ertesx> (yes, i know it isn't)
05:19:57 <bennofs> has anything changed in make or are dynamic dependencies still hard?
05:20:05 <ertesx> bennofs: still hard
05:21:12 <maerwald> we have a solution: autotools, which generates a 30k LOC shell script that generates a 2000 LOC Makefile! win!
05:22:01 <maerwald> sufficiently high-level (lol)
05:22:23 <ertesx> i'd say autotools is lower-level than make
05:22:43 <maerwald> portability is a lot better
05:23:13 <ertesx> M4, the most beautiful progr… uhm… text language (i guess?) i've ever seen…
05:23:39 <maerwald> autotools macros constantly break...
05:23:52 <maerwald> so grunt is better... in a way :P
05:24:09 <ertesx> i'm happy to believe that…  autotools are terrible in every way
05:24:24 <dysfun> autotools really isn't so necessary any more
05:24:47 <maerwald> yeah, if you have someone who can write a Makefile that works on more than 2 distros :o
05:25:08 <ertesx> dysfun: people still program in C
05:25:30 <dysfun> i still program in c. but i don't use autotools
05:26:02 <dysfun> i have quite enough pain in my life thanks
05:26:08 <merijn> dysfun++
05:26:10 <maerwald> using bam? xD
05:26:23 <dysfun> is bam a new trendy c build tool?
05:26:39 <maerwald> bam is as bad as premake and waf and SCons
05:26:45 <ertesx> dysfun: but C, being a bad habit most of the time, seems to kindle all the other bad habits in programmers as well
05:27:18 <dysfun> maerwald: great. you'll understand why i choose a simple makefile then
05:27:42 <maerwald> dysfun: yes and no
05:27:53 <dysfun> ertesx: by virtue of being extremely tedious to program correctly, it enhances laziness by approx 5000%
05:27:57 <ertesx> "i'm going to write C code now…  must…  use…  autotools…"
05:30:45 <ertesx> autoconf is kind of clever though: you don't write *.ac files, you copy-paste chunks from the internet
05:30:57 <maerwald> ?
05:30:57 <ertesx> that explains why it's so popular:  it's the PHP of build tools
05:32:52 <maerwald> This is nothing specific to autoconf.
05:33:22 <maerwald> people not reading documentation and investigating problems... you have that everywhere
05:33:31 <iphy> Is <<loop>> a thing the ghc runtime produces?
05:33:38 <merijn> iphy: Yes
05:33:49 <iphy> What does it mean?
05:33:53 <merijn> iphy: Basically it has detected an infinite loop
05:34:31 <alercah> maerwald: investigation can take different forms though. For instance, in Haskell, you dig deep trying to figure out what's up, experiment, and next thing you know you're a lens maintainer
05:34:31 <merijn> iphy: i.e., your program hung, but through sheer luck it hung in a way that GHC can detect and it helpfull exits telling you so
05:34:45 <bollu> hey guys
05:34:48 <maerwald> alercah: I hope not :P
05:34:55 <bollu> I still don't understand how we can create existentials with forall
05:35:03 <bollu> I understand it with respect to logic
05:35:21 <ertesx> bollu: have you seen GADTs?
05:35:25 <bollu> exsts x. p(x) == not (forall x. not p(x))
05:35:27 <bollu> ertesx: yes
05:35:38 <ertesx> bollu: an existential is a type variable not mentioned in the constructor
05:35:38 <bollu> but we don't even have not in the type system!
05:35:53 <bollu> ertesx: wait.. what? that's doable? :O
05:36:00 <ertesx> bollu: MyConstr :: a -> b -> MyType b  -- a is existential
05:36:02 <alercah> bollu: more specifically
05:36:26 <alercah> a universally quantified variable in a type constructor creates a pseudo-existential when you use it
05:36:40 <ertesx> bollu: actually we have "not":  type Not a = a -> Void
05:36:52 <alercah> e.g. data Foo = forall a . Foo a
05:37:06 <alercah> a Foo contains an existential quantification, because you know there's a value but don't know the type
05:37:38 <bollu> oh, so because you were able to instantiate a "Foo" you know a 'a" exists, but you don't know which one?
05:37:40 <ertesx> bollu: the "forall" syntax of ExistentialQuantification is kind of an ugly hack in order to reuse the 'forall' keyword instead of introducing a new one
05:37:42 <iphy> https://github.com/TokTok/hstox/blob/master/test-toxcore/TestToxcore.hs
05:38:03 <alercah> bollu: right
05:38:15 <ertesx> bollu: it allows you to introduce a type variable that is not mentioned in the type itself without GADT syntax
05:38:31 <iphy> This is my program, it has no loops in it
05:38:36 <bollu> alercah: okay, now consider: Maybe a = Just a | Nothing
05:38:38 <bollu> so in this case
05:38:44 <bollu> if I give you a Nothing
05:38:50 <bollu> Nothing :: Maybe a
05:38:53 <bollu> is the "a" existential?
05:38:57 <bollu> why/why not?
05:38:58 <alercah> no, it's universal
05:39:02 <alercah> because Nothing is a Maybe a for all a
05:39:12 <alercah> but Foo a contains an a for some a
05:39:23 <iphy> How does ghc detect infinite loops?
05:39:26 <ClaudiusMaximus> iphy: i see one loop https://github.com/TokTok/hstox/blob/master/test-toxcore/TestToxcore.hs#L26
05:39:41 <bollu> alercah: why can't foo contain an "a" for all a?
05:39:43 <ertesx> bollu: look at the type of Nothing
05:39:45 <ertesx> :t Nothing
05:39:46 <lambdabot> Maybe a
05:39:49 <Cale> let result = fromIntegral $       result       .&. 0xff
05:39:53 <Cale> ^^ that's a loop
05:39:55 <bollu> correct
05:39:58 <ertesx> bollu: the 'a' is mentioned as an argument to the type
05:40:02 <ertesx> so it's universal
05:40:03 <bollu> right
05:40:05 <bollu> ohh
05:40:07 <alercah> bollu: because you have Foo 1 :: Foo
05:40:16 <alercah> so if I pattern match on this, I can't turn 1 into a String
05:40:23 <iphy> Haha
05:40:24 <bollu> so when the constructor asks for a type the actual *datatype* itself wants
05:40:24 <iphy> You're right
05:40:31 <bollu> that's existential?
05:40:43 <ertesx> @let data SomeMonoid = forall a. (Monoid a) => SomeMonoid a
05:40:45 <alercah> other way around
05:40:45 <bollu> wait, that's a messed up sentence
05:40:46 <lambdabot>  Defined.
05:40:49 <bollu> yeah
05:40:52 <ertesx> bollu: now look at this:
05:40:55 <ertesx> :t SomeMonoid
05:40:56 <lambdabot> Monoid a => a -> SomeMonoid
05:41:02 <ertesx> it's the type of the *constructor* SomeMonoid
05:41:08 <bollu> ah, the SomeMonoid does not "capture" the a
05:41:19 <bollu> but the constructor "consumes" an a
05:41:20 <alercah> and remember that you have to consider the context
05:41:21 <bollu> :t Void
05:41:23 <lambdabot>     Not in scope: data constructor ‘Void’
05:41:23 <lambdabot>     Perhaps you meant one of these:
05:41:23 <lambdabot>       variable ‘void’ (imported from Control.Monad.Writer),
05:41:30 <alercah> for instance, in these constructors, the type is universal
05:41:31 <bollu> :t absurd
05:41:32 <lambdabot> Not in scope: ‘absurd’
05:41:42 <alercah> because the constructor can accept any vale
05:41:44 <alercah> *value
05:41:54 <bollu> so, wait, I can something like data Exists where exists :: a -> Exists?
05:42:18 <ski> yes
05:42:20 <ertesx> bollu: the constructor is universal in one of the fields…  it's not really the type variable that is an existential, but the whole type represents something that is existential
05:42:23 <ski> but it's not useful
05:42:32 <bollu> > data (Exists :: *) where exists :: a -> Exists
05:42:33 <lambdabot>  <hint>:1:1: parse error on input ‘data’
05:42:44 <Cale> iphy: Variables may be bound to unevaluated expressions, and so are represented basically as pointers to code. The first time this code is entered, it first rewrites the pointer to point at a black hole which will throw a <loop> exception if entered, before computing the value, and then rewriting the pointer again to point at a short piece of code that just returns the already computed value immediately next time.
05:42:44 * ski wouldn't say it's the type variable that is an existential
05:42:48 <bollu> ertesx: I see
05:42:57 <ertesx> bollu: SomeMonoid (the type) is an existential judgement
05:43:03 <bollu> ertesx: so the type itself asserts that it s "existential"
05:43:04 <bollu> ?
05:43:06 <ski> bollu : except data constructors have to start with a capital letter
05:43:21 <dsub> existential judgement sounds very apocalyptic... :)
05:43:27 <ski> @let data Exists :: * where Wrap :: a -> Exists
05:43:30 <lambdabot>  Defined.
05:43:39 <bollu> ski: ah crap :) I confuse GADT syntax
05:43:41 <bollu> > Wrap
05:43:43 <lambdabot>      No instance for (Typeable a0)
05:43:44 <lambdabot>        arising from a use of ‘show_M310277249737239029612650’
05:43:44 <lambdabot>      In the expression:
05:43:45 <bollu> > Wrap 1
05:43:46 <lambdabot>      No instance for (Show Exists)
05:43:47 <lambdabot>        arising from a use of ‘show_M804385042378903331912660’
05:43:47 <lambdabot>      In the expression:
05:43:52 <ski> `Wrap :: forall a. (a -> Exists)' is logically equivalent to `Wrap :: (exists a. a) -> Exists'
05:44:07 <Cale> iphy: So only if you try to evaluate a variable during its own evaluation do you get that exception. (Here, evaluation means just determining the outermost data constructor)
05:44:09 <ertesx> @let data UsefulExists :: (* -> Constraint) -> * where UsefulExists :: (c a) => a -> UsefulExists c
05:44:09 <lambdabot>  Parse failed: Illegal class assertion
05:44:10 <ski> > case Wrap "hello" of Wrap _ -> ()
05:44:12 <lambdabot>  ()
05:44:17 <bollu> that syntax is terrible IMO :( I'm sorry but it's so confusing
05:44:39 <ski> why do you feel it is terrible ?
05:45:08 <bollu> another keyword would have been nice (even if it were syntactic sugar).
05:45:24 * ski would call the type `exists a. a' here an "existential(ly quantified) type"
05:45:26 <bollu> I now need to check if the "forall" actually corresponds to an existential or not
05:45:26 <iphy> Cale: thanks, makes sense
05:45:29 <ertesx> bollu: "existentials" in haskell are really special cases of sigma types in type theory, and those represent logical statements involving "exists"
05:45:43 <alercah> the other half of the reason is that GHC doesn't directly support existential types as first-clsas
05:45:46 <alercah> *class
05:45:55 <ski> the point is that the data constructor `Wrap' *is* polymorphic, just like `length' of type `forall a. [a] -> Int' is
05:45:57 <ertesx> bollu: that's why we call them "existentials"…  but it's not the type variable that is existential, it's the statement the whole type represents
05:46:00 <alercah> > let foo (Wrap a) = a in True
05:46:02 <lambdabot>      Couldn't match expected type ‘t’ with actual type ‘a’
05:46:02 <lambdabot>        because type variable ‘a’ would escape its scope
05:46:02 <lambdabot>      This (rigid, skolem) type variable is bound by
05:46:10 <bollu> :t Wrap
05:46:12 <lambdabot> a -> Exists
05:46:15 <bollu> :k Wrap
05:46:16 <lambdabot> k -> Exists
05:46:16 <alercah> ^ attepmting to create a function returning an unwrapped existential gives you that error
05:46:37 <bollu> wait what? how does Wrap have a kind?
05:46:40 <bollu> I was screwing around
05:46:50 <ski> the above declaration of `Exists' declares that as a type equivalent to the type `exists a. a'
05:46:52 <Cale> Presumably DataKinds is turned on
05:46:57 <alercah> yeah, that's DataKinds
05:47:00 <bollu> ah
05:47:01 <Cale> and so that's the promoted Wrap
05:47:01 <bollu> right
05:47:14 <ertesx> bollu: more practically an existential field is a field you can choose freely when constructing, but you learn nothing about when pattern-matching
05:47:16 <alercah> bollu: So bascially, GHC doesn't actually support existensials
05:47:29 <alercah> it happens to support some universals that are equivalent to existensials
05:47:31 <alercah> but not all of them
05:47:37 <ski> alercah : that is not allowed. an "existential type variable" "can't escape"
05:47:41 <Cale> Er, some types which are equivalent to existential types
05:47:47 <bollu> so if I have: data GADT a b where cexists :: a -> b -> c -> GADT a b | here, "a" and "b" are foralls while "c" is existential?
05:47:48 <alercah> ski: right, that's my point
05:47:57 <alercah> bollu: yes
05:48:11 <ski> bollu : illtyped question
05:48:25 <ski> s/cexists/CExists/
05:48:25 <ertesx> bollu: always look at the type of the constructor
05:48:26 <Cale> It would be weird to call them universally quantified, when they might have no parameter :)
05:48:28 <bollu> ski: Cexists :: a -> b -> c -> GADT a b?
05:48:39 <bollu> right, sorry :)
05:48:47 <bollu> hmm
05:48:49 <ski> `CExists' is polymorphic in `a',`b',`c'
05:48:54 <bollu> okay, now I get "existential"
05:48:59 <ertesx> bollu: an "existential" is a type not captured as a type argument…  and that's it
05:49:03 <ski> all of these are universally quantified, iow with `forall'
05:49:11 <Cale> ertesx: wait...
05:49:13 <bollu> but now, why are "a" and "b" universal? 
05:49:18 <ski>   CExists :: forall a b c. a -> b -> c -> GADT a b
05:49:29 <bollu> what does it mean to be universally quantified?
05:49:35 <Cale> Yeah, I guess you could say that c is "existentially quantified"
05:49:40 <ertesx> bollu: it has the effect that you can choose it freely when constructing (hence the universal quantification in the constructor, the "forall")
05:49:43 <ski> universal quantification is related to polymorphism
05:49:54 <bollu> ertesx: but I can choose "c" freely as well!
05:49:55 <Cale> it's the GADT which is the "existential type"
05:49:59 <ski> `CExists' works for any types `a',`b',`c', is polymorphic in them
05:50:20 <bollu> so the only difference is whether the "c" is part of the final object or not?
05:50:21 <ski> but the point here is that
05:50:23 <ski>   CExists :: forall a b c. a -> b -> c -> GADT a b
05:50:25 <ertesx> bollu: yes, because c is the "existential"…  when applying CExists, you can choose 'c' freely
05:50:29 <ski> is logically equivalent to
05:50:40 <ertesx> you can't choose 'a' and 'b' freely, because they are dictated by the result type
05:50:41 <ski>   CExists :: forall a b. a -> b -> forall c. (c -> GADT a b)
05:50:47 <ski> which is logically equivalent to
05:50:54 <ski>   CExists :: forall a b. a -> b -> (exists c. c) -> GADT a b
05:51:03 <ski> (because `c' isn't mentioned in the result type)
05:51:10 <ski> and there's your existential quantification
05:51:29 <bollu> ski: so the transform rule is (forall a. a -> T ) = (exists a. a) -> T ?
05:52:05 <ski> bollu : yes, or in general, `forall a. (..a.. -> ...)' is logically equivalent to `(exists a. ..a..) -> ...' (where `...' doesn't mention `a' (freely))
05:52:09 <Cale> Yeah, which is just the usual thing from logic
05:52:20 <ski> bollu : note that by the same token
05:52:29 <ski>   length :: forall a. ([a] -> Int)
05:52:32 <bollu> Cale: how is this equivalent to logic?
05:52:35 <ski> is logically equivalent to
05:52:37 <bollu> Cale: I've never seen this before
05:52:42 <ski>   length :: (exists a. [a]) -> Int
05:52:45 <bollu> (exists a. [a]) -> Int?
05:52:46 <bollu> hmm
05:52:48 <ski> yes
05:53:11 <bollu> Cale: which part of logic? I haven't actually "done" logic, I've picked it up because of haskell in bits and pieces
05:53:21 <ski> to be able to successfully apply `length', it is enough that there *exists* some type `a' such that the argument has type `[a]' (and then the result will have type `Int')
05:53:22 <Cale> ah, first order logic
05:53:25 <bollu> Cale: where can I read more about this whole existential / universal dual?
05:53:31 <ski> bollu ^
05:54:16 <bollu> ski: okay, check this out: someop:: a -> b -> c -> SomeType a b. So, here, all I need is for c to "exist", but I need a and b to work over *all* types?
05:54:41 <bollu> Cale: um, link? I'm not sure how to google this
05:54:57 <ski> bollu : you also need for `someop' to work over *all* types, for `c'
05:54:59 <Cale> bollu: In logic, forall x. (P(x) -> Q) is logically equivalent to (exists x. P(x)) -> Q, whenever Q doesn't mention x, where now we're not reading these as types of data, but as propositions
05:55:00 <bollu> Cale: because this rule is realated to the type of a function)
05:55:17 <bollu> ski: so "c" is universal in this?
05:55:20 <ski> bollu : but since `c' isn't mentioned in the result, *another* way of saying that is that `someop' just needs some `c' to exist
05:55:20 <ertesx> bollu: are you trying to understand this as a programmer or as a logician?  while they're equivalent, IMO the way to approach it is very different
05:55:26 <Cale> P(x) is some statement depending on x, and Q is another statement, and "->" means "implies"
05:55:32 <bollu> ski: yes, that is the crux of my argument
05:55:53 <bollu> Cale: can you give me an example (in say, english) that lets me intuit the truth of that rule?
05:55:56 <ski> bollu : `c' can be thought of as universally quantified over the whole type. `c' can *also* be thought of as existentially quantified over the argument type
05:55:58 <bollu> Cale: or maybe a set theory thing
05:56:13 <bollu> ertesx: whatever is more enlightening :)
05:56:24 <ertesx> bollu: they enlight in different ways =)
05:56:36 <bollu> ski: where the "whole thing" is the entire function type?
05:56:50 <ski> bollu : i wouldn't say `c' is universal, nor existential. i'd say the whole type `forall a b c. a -> b -> c -> SomeType a b' is a universal type, universal in `a',`b',`c' (and therefore `someop' is polymorphic in those)
05:56:55 <ski> bollu : yes
05:57:08 <ertesx> bollu: as a programmer "existential" means "construct freely, learn nothing on pattern-matching other than what the constructor feeds you"
05:57:13 <bollu> ski: so where does the existential come from?
05:57:16 <ski> (and i'd say `exists c. c' in `forall a b. a -> b -> c -> SomeType a b
05:57:35 <ski> (and i'd say `exists c. c' in `forall a b. a -> b -> (exists c. c) -> SomeType a b' is an existential type)
05:57:42 <bollu> Isee
05:57:43 <bollu> I see*
05:57:53 <bollu> ertesx: and from a logic point of view?
05:58:05 <bollu> ertesx: can you link me / show me a proof of the equivalence of the two forms?
05:58:20 <bollu> Cale, ski ^
05:58:57 <bollu> ski: that helps a ton (the explanation)
05:59:11 <ski> bollu : if you use `CExists False "hello" (Just ())', then `a' is `Bool', `b' is `String', and `c' is `Maybe ()'. and the result type of this is then just `GADT Bool String'
05:59:31 <bollu> ski: right
05:59:40 <ski> bollu : the types `Bool' and `String' have been "recorded" as argument types of `GADT', but the type `Maybe ()' has disappeared from view
06:00:07 <bollu> ski: yeah. 
06:00:14 <ertesx> bollu: a proof for (exists a. f a) is a value of that type, proving "f a" for some 'a'…  when you try to use that proof (which is a value of the type), you learn nothing about 'a' other than that a proof for 'f a' exists
06:00:20 <ski> when we later match a value of type `GADT Bool String' with the pattern `CExists x y z', we know that `x :: Bool', and `y :: String', but we don't know the type of `z'
06:00:26 <ertesx> bollu: note that "proof for" and "value of type" are the same thing
06:00:38 <bollu> ski: ah
06:01:02 <ski> bollu : it could be `Maybe ()', but it could just as well be any other type. the safe thing to do is to assume nothing that we don't know for sure
06:01:04 <bollu> ski: so when you pattern match, you know there's some inhabitant of z, but you don't know what type z is and what inhabitant was used, right?
06:01:10 <ski> yes
06:01:17 <bollu> I see
06:01:21 <Cale> bollu: Let's take P(x) to be "x is under the legal age to drink", and Q to be "the bar is getting shut down"
06:01:35 <bollu> Cale: all right
06:02:05 <Cale> Then we might read forall x. (P(x) -> Q) means "for all people x in the bar, if x is under the legal age to drink, then the bar is getting shut down"
06:02:20 <Cale> s/means/as/
06:02:22 <bollu> Cale: okay
06:02:39 <bollu> ahh 
06:02:43 <ski> bollu : now consider `data Foo where MkFoo :: (a,a -> a,a -> String)'. if we match a value of type `Foo' with `MkFoo (x,f,s)', we know `x :: a', `f :: a -> a', and `s :: a -> String', but we have no idea what type `a' is. but we *do* know that it's the same (unknown/hidden) type `a' for all three `x',`f',`s'
06:03:02 <bollu> "if there exists an x such that x is under the legal age to drink, then the bar is getting shut down". damn
06:03:05 <bollu> Cale: proof?
06:03:06 <ski> bollu : so, we *can* compute `s x :: String',`s (f x) :: String',`s (f (f x)) :: String', &c.
06:03:10 <bollu> Cale: general proof? :)
06:03:25 <enthropy> https://hackage.haskell.org/package/probability-0.2.5/docs/Numeric-Probability-Example-Dice.html#v:droll is somebody aware of an interpreter/ something like that which lets you efficiently calculate expressions like "sort <$> dice 10"
06:03:29 <Cale> bollu: sure, we can do a general proof that they're equivalent by showing one implies the other
06:04:23 <Cale> Suppose that forall x. (P(x) -> Q). We want to show that (exists x. P(x)) -> Q, so to that end, suppose additionally that (exists x. P(x)), and now we want to show Q.
06:04:26 <bollu> Cale: how do you deal with \exists? I can how to go from \forall to \exists (I think), but not the other  way right
06:04:30 <bollu> okay
06:04:31 <bollu> go on
06:04:46 <bollu> ski: that's nifty
06:05:06 <Cale> So let c be the x for which P(x) given by the existential.
06:05:08 <ski> bollu : an example of using this idea would be `data QueueOps a where MkQO :: {emptyQ :: q,enqueue :: a -> q -> q,dequeue :: q -> Maybe (q,a)} -> QueueOps a'
06:05:19 <bollu> ski: and that's kinda like Codensity right? Codensity a = forall x. (a, x -> a) 
06:05:33 <Cale> and by forall x. (P(x) -> Q), we obtain P(c) -> Q in particular
06:05:45 <bollu> Cale: right, with you so far
06:05:48 <enthropy> as opposed to code which has more concern about when to check that sort applied to [1,2] and [2,1] are the same (one way http://lpaste.net/7169132360779169792)
06:05:51 <Cale> and so from P(c) and P(c) -> Q, we get Q
06:06:03 <bollu> Cale: okay
06:06:04 <ertesx> bollu: look at the constructor:  Codensity :: (forall r. (a -> m r) -> m r) -> Codensity m a
06:06:07 <Cale> So, we're done, in that direction.
06:06:11 <ertesx> bollu: no existentials
06:06:24 <ski> bollu : a value of type `QueueOps a' bundles up three queue operations on a queue with elements of type `a', the implementation/representation/state type of the queue, `q', is hidden
06:06:25 <bollu> ertesx: r?
06:06:29 <ertesx> bollu: not in scope
06:06:35 <Cale> So that's  (forall x. (P(x) -> Q)) -> ((exists x. P(x)) -> Q)
06:06:48 <ertesx> the 'r' is bound in the argument type, not the top level
06:07:11 <bollu> Cale: question
06:07:11 <ertesx> existentials are bound like this:  Codensity :: forall a. …
06:07:12 <ski> bollu : two different values of `QueueOps a' would (in general) represent two different implementations of a queue, possibly using different internal types for `q'
06:07:23 <Cale> sure
06:07:25 <bollu> Cale: how did you assume the existence of a "c" such that P(c) is satisfied?
06:07:40 <bollu> Cale: you just know that (forall x. (P(x) -> Q)) right?
06:07:45 <Cale> bollu: That's what you get to do when you know that exists x. P(x)
06:08:07 <bollu> Cale: but you're supposed to _prove_ that ((exists x. P(x)) -> Q) right?
06:08:14 <bollu> given (forall x. (P(x) -> Q))
06:08:14 <ski> ertesx : no. that's one way to *simulate* existentials ..
06:08:15 <Cale> right
06:08:21 <bollu> for all you know, that statement is vacuously true
06:08:28 <Cale> But in order to prove an implication
06:08:39 <Cale> We're allowed to assume its antecedent
06:08:43 <bollu> Cale: ahh
06:08:45 <bollu> Cale: hm
06:08:48 <Cale> and try to prove the consequent
06:09:10 <ertesx> bollu: you were interested in dependently typed languages…  have you tried one?  using actual sigma types to prove actual theorems is very enlightening
06:09:10 <bollu> Cale: that only prove the T => T case of the implies truth table right? what about F => _?
06:09:22 <bollu> ertesx: just started with idris :)
06:09:38 <bollu> Cale: in the sense of, if I have P => Q and I'm trying to prove it
06:09:44 <bollu> if I assume P and prove Q
06:09:47 <Cale> bollu: No, it only deals with the possibility that T => F, ruling it out.
06:09:50 <ski> bollu : perhaps you're thinking of `Density f b = exists a. (f a,f a -> b)' or `CoYoneda f b = exists a. (f a,a -> b)' ?
06:10:17 <Cale> bollu: T => F is the only case in which an implication is false, if we're thinking about truth tables
06:10:18 <bollu> ski: possibly Density :)
06:10:35 <ertesx> bollu: also check out the paste i linked you -- i think -- yesterday…  it gives an example of a sigma relevant both to programming and to logic
06:11:09 <bollu> Cale: if I assume P, then P = T. and if I prove Q from that, then Q = T, right?
06:11:18 <bollu> s/prove/derive
06:11:30 <ertesx> bollu: http://lpaste.net/109388
06:12:00 <ski> bollu : anyway, existential quantification is related to abstraction, as in abstract data types. (you can also do some OO:y things with them, which is a different "pattern" of using them)
06:12:12 <Cale> bollu: yeah, and in particular, it means that Q can't be F in that case
06:12:30 <bollu> Cale: right. So you've shown that T => T holds, and T => F is impossible
06:12:43 <bollu> Cale: oh okay, I see the point. if P is False, we "don't care" about Q
06:12:44 <bollu> ahh
06:12:45 <bollu> cool
06:12:46 <Cale> Well, we haven't really shown it's T => T
06:12:53 <bollu> Cale: how so?
06:12:56 <Cale> The antecedent could be false
06:13:02 <bollu> right
06:13:08 <Cale> But we've shown that *if* it's true, then the consequent is as well
06:13:08 <bollu> but in that case we don't care
06:13:11 <Cale> right
06:13:17 <bollu> right, got the subtle difference
06:13:19 <bollu> okay, continue
06:13:24 <bollu> now we need the other direction
06:13:27 <Cale> Right...
06:13:51 <bollu> ((exists x. P(x)) -> Q) -> (forall x. (P(x) -> Q))
06:14:41 <bollu> hm, how do you deal with the right hand side? you have a "forall" that encloses everything
06:15:31 <bollu> okay, let's assume ((exists x. P(x)) -> Q) is T
06:15:37 <Cale> So, okay, we get to assume that (exists x. P(x)) -> Q
06:15:48 <ski> bollu : often we use sloppy terminology and call a type like `QueueOps a' an "existential(ly quantified) type" (because we use `QueueOps a' to represent the type `exists q. (q,a -> q -> q,q -> Maybe (q,a))' (basically the argument type of the data constructor `MkQO', if you uncurry it)
06:15:53 <ski> bollu : however it would perhaps be better to say that `MkQO' is an "existential data constructor", since you can also have other constructors for your data type, without anything "existential" about them
06:16:02 <Cale> Now, we let x be given arbitrarily, and we need to show P(x) -> Q
06:16:17 <bollu> so either there is no "x" and the statement is vacuously true. or you have a "c" such that P(c) is T
06:16:22 <bollu> right
06:16:31 <bollu> Cale: okay, go on
06:16:41 <Cale> Because if we can show that P(x) -> Q for an x that we know nothing else about, then we can conclude forall x. P(x) -> Q
06:16:49 <bollu> Cale: right
06:17:03 <Cale> So, now in order to prove P(x) -> Q, we can additionally suppose that P(x)
06:17:09 <bollu> Cale: so now we get to assume P(x) as well
06:17:12 <Cale> yep
06:17:30 <Cale> and so we now have that exists x. P(x)
06:17:30 <bollu> Cale: maybe call it x'? we already have an "x" bound in the exists
06:17:42 <Cale> or we could call it c
06:17:44 <Cale> yeah
06:17:49 <bollu> yeah
06:17:54 <ski> bollu : .. another way to *represent/simulate* `exists q. (q,a -> q -> q,q -> Maybe (q,a))' (apart from `QueueOps a', as defined above) would be `forall o q. (q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> o) -> o' (i uncurried the argument callback for convenience)
06:18:00 <Cale> So we're trying to show that P(c) -> Q
06:18:11 <Cale> and we're allowed to assume P(c) and try to show Q
06:18:22 <Cale> and from P(c) we get exists x. P(x)
06:18:25 <bollu> Cale: right
06:18:37 <Cale> and from exists x. P(x) and (exists x. P(x)) -> Q, we get Q
06:18:47 <Cale> and then we're done
06:18:55 <bollu> ahh
06:18:57 <bollu> neat
06:19:03 <bollu> I see
06:19:08 <bollu> thanks :D
06:19:22 <bollu> the logic proof is more "believable" than the type theory "proof" ;)
06:19:35 <bollu> ski: how does that work? the last definition?
06:19:37 <ski> bollu : the point is that there's at least two different ways to encode/simulate existentially quantified types in GHC, in common use. i think it's useful to separate these in mind from the conceptual `exists q. (q,a -> q -> q,q -> Maybe (q,a))' (which we can't write as-in, currently)
06:19:43 <Cale> Well, the type theory proof is actually the same thing
06:19:49 <Cale> It's just written a different way
06:20:24 <Cale> The lambda terms involved will encode exactly what we did in our proof
06:20:29 <ski> bollu : i assume you mean the `forall o q. ...' one ? (which is called a "CPS/Church encoding". Continuation-Passing Style)
06:20:33 <Cale> Let's take a look at that...
06:20:34 <bollu> ski: yes
06:20:38 <bollu> Cale: sure, go on
06:21:01 <Cale> Have you seen anything of the Curry-Howard correspondence before?
06:21:29 <Cale> So, in logic, if we want to prove that P -> Q, we start by assuming P and try to show Q.
06:21:54 <bollu> Cale: lil bit, I know that it exists and I think I have a vague idea
06:21:58 <Cale> In lambda calculus, if we want to construct a function of type P -> Q, we start with a variable x: P, and try to construct an expression e: Q
06:22:07 <Cale> and then (\x -> e) is our function
06:22:20 <bollu> right
06:22:22 <Cale> In logic, if we have P -> Q, and we have P, we can obtain Q
06:22:43 <Cale> In lambda calculus, if we have f : P -> Q, and x : P, we obtain f x : Q
06:22:48 <bollu> right
06:22:55 <infandum> I'm lazy. Instead of "if filename == "" then [stdin] else [that file name]" for getting input, is there a withFile that, if the filename is empty or whatever, becomes stdin?
06:23:17 <Cale> Now, in order to have quantifiers, we need a lambda calculus which is either polymorphic or dependently typed in some way.
06:23:32 <ski> bollu : consider the slightly simpler example `exists b. (Foo a b,Bar b)'. say we really want to write `frob :: forall a. [(Int,a)] -> exists b. (Foo a b,Bar b)'
06:24:01 <maerwald> infandum: I hope not, that's too specific to be a lib function
06:24:06 <bollu> Cale: we have forall with type variables
06:24:07 <Cale> I think it may actually be easier to explain this stuff in a setting of dependent types, or at least something where we write type applications and abstractions explicitly
06:24:12 <bollu> okay
06:24:34 <ertesx> infandum: you can use foldr
06:24:35 <bollu> Cale: I don't know dependant types. Except, nothing more than "types can depend on values and you lift values to types and types to kinds"
06:24:56 <bollu> dependent*
06:25:05 <ski> bollu : the first approach to doing this is to define `data Baz a :: * where MkBaz :: Foo a b -> Bar b -> Baz a', and then define `frob :: forall a. [(Int,a)] -> Baz a' instead of `frob :: forall a. [(Int,a)] -> exists b. (Foo a b,Bar b)', taking care to wrap/unwrap the data constructor `MkBaz' as necessary
06:25:09 <bollu> Cale: I'm happuy to learn :)
06:25:16 <bollu> happy*
06:25:26 <infandum> maerwald: Then how do you do it?
06:25:27 <ertesx> infandum: withFile (foldr (\x _ -> _nonEmptyWith x) _emptyCase _theList)
06:25:45 <Cale> bollu: Okay, let's do the dependent types way, because I'd rather explain that than System F
06:25:57 <Cale> (though System F is a little more relevant to Haskell...)
06:25:57 <hpc> heh
06:26:06 <bollu> Cale: sure
06:26:27 <bollu> Cale: how are RankNTypes related to dependant types? are then two different "axis" of typing power?
06:26:28 <infandum> ertesx: What is the list? I don't see how that works
06:26:28 <maerwald> infandum: I would fix the input to be more specific instead of magically assuming stdin for an empty filename
06:26:33 <ski> bollu : the second approach is to instead define `withFrob :: forall a o. [(Int,a)] -> (forall b. Foo a b -> Bar b -> o) -> o'. `withFrob' takes an extra argument, a callback or continuation, that will be passed as arguments the result(s) that the original conceptual `frob' would have returned
06:26:37 <ertesx> infandum: or rather:  \k -> foldr (\fn _ -> withFile fn _mode k) (k stdin)
06:26:58 <ski> bollu : the continuation callback is polymorphic in `b'
06:27:00 <infandum> maerwald: I mean, it would be if the user doesn't put in a filename, it's assumed to be from stdin
06:27:04 <infandum> the input
06:27:05 <ertesx> :t \k -> foldr (\fn _ -> withFile fn ReadMode k) (k stdin)
06:27:06 <hpc> bollu: they're different things, but every DT system i know of includes rank N types
06:27:06 <lambdabot>     Not in scope: ‘withFile’
06:27:07 <lambdabot>     Perhaps you meant one of these:
06:27:07 <lambdabot>       ‘writeFile’ (imported from Prelude),
06:27:13 <maerwald> infandum: yes, and I would not assume that
06:27:18 <ertesx> :t \k -> foldr (\fn _ -> System.IO.withFile fn System.IO.ReadMode k) (k stdin)
06:27:18 <bollu> ski: if we rewrite it with Cont r a, it would be clearer right?
06:27:19 <lambdabot> Not in scope: ‘stdin’
06:27:21 <Cale> bollu: Well, it's different, but usually if you're going to have dependent types, you're also going to have some universe types (i.e. types inhabited by other types)
06:27:26 <ertesx> :t \k -> foldr (\fn _ -> System.IO.withFile fn System.IO.ReadMode k) (k System.IO.stdin)
06:27:28 <lambdabot> Foldable t => (GHC.IO.Handle.Types.Handle -> IO r) -> t FilePath -> IO r
06:27:29 <bollu> Cale: I see.
06:27:30 <Cale> which will let you express the same polymorphism
06:27:31 <maerwald> infandum: instead I would require the user to explicitly tell me he wants stdin
06:27:37 <ertesx> infandum: something like that?
06:27:40 <infandum> maerwald: I see
06:27:46 <ski> bollu : the `forall b.' in there interferes with using `Cont' directly
06:27:53 <maerwald> imagine he copy pasted something and by accident it's empty
06:28:19 <ertesx> infandum: if foldr's first argument ignores its second argument, then foldr is basically safeHead
06:28:20 <maerwald> or whatever... I like things to be explicit
06:28:29 <infandum> ertesx: oooooh, now I see
06:28:37 <Cale> bollu: So, for any type A and any function P: A -> Type (where Type is such a universe of types), we have a type  forall (x:A), P(x)
06:28:49 <infandum> ertesx: That's super funky actually\
06:28:59 <bollu> Cale:  P: A -> * in haskell nomenclature?
06:29:04 <Cale> yeah
06:29:15 <Cale> Though note that this is something a little weird in Haskell
06:29:18 <ski> bollu : the key here is to notice that if you have `poly :: forall a. ..a..', then the user/caller of `poly' gets to choose the type `a', while the callee `poly' itself has to treat it as an unknown (opaque) type, of which nothing can be assumed
06:29:23 <Cale> in that A is meant to be a type of values
06:29:27 <bollu> Cale: is P(x) the type you are referring to? 
06:29:41 <ertesx> infandum: but i tend to design command line interfaces around the idea that they should act like morphisms
06:29:53 <ertesx> infandum: myprog x y = myprog x && myprog y
06:30:05 <ertesx> or "||" or ";", whatever is more appropriate
06:30:17 <ertesx> you can always pass "-", if you want stdin
06:30:30 <ski> bollu : while if we have `forgetful :: exists a. ..a..', then the "callee" itself, `forgetful' gets to choose the type `a', while a caller/user of it must treat `a' as an unknown/hidden/opaque/abstract/forgotten type, of which nothing can be assumed
06:30:42 <infandum> ertesx: So that's how you do it? Make the user input "-"?
06:30:50 <Cale> bollu: for example, we might have for every n : Nat, some type BinString n of binary strings of length n
06:30:57 <ski> bollu : so the callee vs. caller roles "swap places", when you exchange `forall' for `exists'
06:31:08 <hpc> infandum: it's how almost all of linux command line tools do it
06:31:10 <bollu> Cale: right, that makes it dependant, right? 
06:31:27 <ertesx> infandum: main = getArgs >>= mapM_ (\fn -> if fn == "-" then mainWith stdin else withFile fn ReadMode mainWith)
06:31:28 <infandum> hpc: I sometimes see that, but most of the time it's with no input
06:31:37 <ertesx> infandum: as a simple example
06:31:39 <Cale> bollu: and then the type  forall (n : Nat), BinString n  would be the type of functions which given some n : Nat, will produce a binary string of that length
06:31:43 <infandum> like with sort, cat, etc
06:31:49 <bollu> ski: can we formalize the "swapping places"?
06:32:02 <ski> bollu : btw, note that in e.g. `mystery :: Bool -> exists a. (a,a -> String)', which type `a' that is chosen may depend also on the *value* of the argument (here of type `Bool')
06:32:03 <bollu> Cale: I see. right, got it till now
06:32:12 <ertesx> infandum: most unix tools don't do it that way…  they tend to have a special case for no arguments
06:32:18 <ski> bollu : formally, we say that `exists' and `forall' are *dual*
06:32:19 <bollu> Cale: so :k BinString = Int -> Type ?
06:32:30 <bollu> ski: in the cat. theory sense of the word?
06:32:38 <infandum> ertesx: what is mainWith? Another function you would have?
06:32:40 <maerwald> '-' is a valid filename btw
06:32:41 <Cale> bollu: In fact, there's no distinction any more between types and kinds usually
06:32:42 <infandum> ah i see
06:32:43 * hackagebot b9 0.5.21 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.21 (SvenHeyll)
06:32:43 <hpc> infandum: try cat <(echo 'foo') - <(echo 'bar')
06:32:54 <Cale> bollu: BinString : Nat -> Type
06:33:01 <bollu> Cale: because you can have an infinite tower of types?
06:33:05 <ertesx> infandum: the actual program, i.e. your 'k'
06:33:10 <bollu> Cale: right, gotcha
06:33:12 <bollu> okay, so
06:33:13 <hpc> <(cmd) in bash is "execute cmd and wrap it up in a fake filename"
06:33:21 <infandum> also head does it
06:33:26 <Cale> bollu: Yeah, really, you probably want to index Type itself with a universe level
06:33:30 <ertesx> infandum: to me personally, when you follow (prog x y = prog x && prog y), it makes sense that just "prog" acts like "true"…  it makes using the program easier, particularly in scripts
06:33:36 <Cale> and then you'll have Type n : Type (n+1)
06:33:46 <tdammers> hpc: doesn't <() actually create a file somewhere, even?
06:33:52 <hpc> possibly
06:33:54 <tdammers> something like a fifo in a tempfs
06:33:55 <ski> bollu : well, or just in plain classical logic. btw, in classical logic, we also have that `(forall a. ..a..) -> ...' is equivalent to `exists a. (..a.. -> ...)', but this doesn't hold in constructive logic -- we can't use this law when reasoning about types
06:34:01 <Cale> But often in these systems, we leave off the universe levels and let the computer infer them
06:34:03 <bollu> Cale: wait, tangential question: how does one implement a dependant type unification algorithm? is there something like system F? I'm sure it's not decidable right?
06:34:07 <bollu> Cale: okay
06:34:10 <hpc> i don't remember exactly, it's just one of those worksforme things
06:34:51 <bollu> is there something like Hindley Milner**
06:35:06 <bollu> some algorithm that spits out the types if you hand it in your definitions
06:35:12 <hpc> bollu: DT unification is decidable by having only particular rules it's allowed to follow and if you write something that "makes sense" if you add more rules it doesn't typecheck
06:35:13 <Cale> What do you mean by not decidable? It's surely possible to write a type checker for dependently typed lambda calculi
06:35:33 <Cale> But there's no principal types
06:35:38 <bollu> Cale: I assumed that it was not decidable, same way System F is not decidable
06:35:49 <bollu> Cale: so there's an algorithm that halts in finite time which unifies dependant types?
06:35:49 <ertesx> bollu: without general recursion, type-checking becomes decidable
06:35:57 <ski> bollu : anyway, i meant dual in the sense that `not (A or B)' is equivalent to `(not A) and (not B)', and `not (A and B)' is equivalent to `(not A) or (not B)' (though only the former of these two also holds constructively)
06:35:58 <hpc> bollu: unification is different from inference btw
06:36:01 <bollu> ertesx: "general recursion" at the type level?
06:36:09 <bollu> hpc: wait, really?
06:36:11 <hpc> type inference is undecidable in system f but unification isn't
06:36:22 <bollu> hpc: what's the difference?
06:36:40 <hpc> unification is "do these match" and inference is "what is this"
06:36:56 <bollu> so to infer you need unification?
06:36:56 <hpc> RankNTypes has undecidable inference but decidable unification as well
06:36:58 <bollu> but not the latter?
06:37:01 <hpc> right
06:37:05 <bollu> I see
06:37:10 <bollu> HM is inference?
06:37:41 <ertesx> bollu: yeah
06:37:45 <bollu> oh I see, "algorithm W" is the actual inference algoritm?
06:37:47 <hpc> HM is a few things all related to each other, but yes
06:37:48 <bollu> algorithm*?
06:37:59 <hpc> algorithm W is sometimes called the HM inference algorithm
06:38:07 <bollu> wow, I see
06:38:11 <ski> bollu : "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> might be interesting
06:38:29 <bollu> Cale: go on, please :) now that I have better perspective
06:38:33 <bollu> ski: thank you!
06:40:19 <Cale> bollu: okay
06:41:30 <Cale> bollu: Now, we also have  exists (x:A), P x  which is the type of pairs whose first component is some value x of type A, and whose second component is then a value of type P x
06:42:57 * hpc just had a funny realization about exists and DT, but will save it for after this explanation
06:44:35 <bollu> Cale: sorry, I DC'd :)
06:44:42 <bollu> Cale: lasyt message was about exists
06:44:47 <hpc> you didn't miss anything
06:44:48 <bollu> "Now, we also have  exists (x:A), P x  which is the type of pairs whose first component is some value x of type A, and whose second component is then a value of type P x"
06:45:30 <Cale> bollu: right
06:45:36 <Cale> I noticed you DC'd
06:45:48 <bollu> Cale: the (,) in between is syntax?
06:45:53 <bollu> yeah, spotty internet
06:46:18 <Cale> yeah, I'm just mimicking Coq's syntax subconsciously
06:46:18 <Cale> Some people will write a period there
06:46:26 <bollu> okay
06:46:27 <bollu> :)
06:46:58 <bollu> this is unrelated, but I have to use a proxy to even access IRC because of this crap: http://dronebl.org/blog/36
06:47:00 <Cale> Also, you'll often see Pi (x:A), P x and Sigma (x:A), P x instead of forall and exists
06:47:03 <bollu> so ridiculous
06:47:16 <hpc> or in agda, Π and Σ
06:47:32 <bollu> Cale: why pi and sigma? I don't see any relation to product / sum (or even functor pi)
06:47:35 <Cale> yeah
06:48:02 <Cale> Well, it's like an iterated product and sum
06:48:09 <bollu> in what sense?
06:48:41 <Cale> A function which sends each element x of A to an element of P x is like a product over all x in A of the types P x
06:48:46 <cocreature> product is like conjunction and the conjunction over all elements is forall
06:48:48 <Cale> er, is like a member of that product
06:49:06 <Cale> If we pick A to be a type with two elements, say Bool
06:49:41 <Cale> Then a function of type forall (x: Bool), P x 
06:50:02 <Cale> is basically the same thing as a pair of type  P False * P True
06:50:09 <bollu> ah okay
06:50:24 <bollu> Cale: product in the sense of "subset of cartesian product" ?
06:50:40 <Cale> It's exactly the Cartesian product
06:51:08 <Cale> If I give you a pair (f,t) where f : P False, and t : P True
06:51:34 <Cale> then I've basically given you a function of type forall (x:Bool), P x
06:52:16 <Cale> (\x -> case x of False -> f; True -> t)  (note that we'd usually also have to specify the type of the result of the case here explicitly...)
06:52:44 * hackagebot octane 0.13.1 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.13.1 (fozworth)
06:52:51 <Cale> and vice versa
06:53:11 <bollu> oh okay, so when you say (forall x. P(x)) == { (x', P(x') | \ forall x' \in x } right? where x' are values that inhabit x?
06:53:38 <Cale> If I give you a function of type forall (x:Bool), P x, you can give me a pair of a value of type P False and a value of type P True, just by applying the function to False and True
06:54:00 <Cale> uh
06:54:26 <Cale> There's not really an easy set theoretical way to say this
06:54:28 <ski> .. no `exists x. P x' is the type of pairs `(x,p)' where `p' has type `P x'
06:54:29 <bollu> forall x. P(x)) == { (x', P(x')) | \ forall x' \in x }
06:54:35 <bollu> ^ that?
06:54:36 <Cale> no
06:54:40 <bollu> hm
06:54:42 <Cale> That doesn't make sense
06:54:52 <bollu> if you think of "x" a type as a set of inhabitants
06:54:56 <ski> `forall x. P x' is the type of functions that when given an argument `x' will produce a result of type `P x'
06:55:16 <ski> `x' in this case is a value
06:55:23 <Cale> Yeah, set theory doesn't have a convenient name for such functions
06:55:24 <ski> (e.g. of type `Bool')
06:55:32 <bollu> ski: right, and in my notation, x' is the value in the type x
06:55:38 <ski> in math, they seem to often be called "families"
06:55:41 <bollu> so x' is a _value_ that inhabit x
06:55:43 <bollu> I see
06:55:51 <Cale> Well, they're sections of a (set) fibration
06:56:40 <Cale> But that's sort of roundabout
06:56:43 <ski> bollu : but the `x' in `forall x. ..x..' should be the value, not the type of the value
06:57:07 <bollu> ski: ah
06:57:15 <infandum> On the pipes-bytestring page, https://hackage.haskell.org/package/pipes-bytestring-2.1.3/docs/Pipes-ByteString.html , how does he get away with the withFiles not being indented in that first code block?
06:57:17 <bollu> hmm
06:57:43 <Cale> We might have some big set E, and then a map f: E -> A, and we regard the preimage of some x in A as being our type P x
06:58:00 <bollu> Cale: right, that works
06:58:20 <bollu> wait, the _preimage_ is P x?
06:58:36 <Cale> Yeah, the fibre lying over some x in A
06:58:46 <ski> bollu : there's of course a relation between these dependent versions of `forall' and `exists', and what we talked about earlier. the minor difference is that in the earlier talk, `x' would be required to be a type (and its type would then be some "type of types", commonly `*' in Haskell, or `* -> *', ...)
06:58:54 <Cale> (I don't know if you've heard these terms before)
06:59:36 <bollu> Cale: I've heard fiber once, in terms of a homomorphism
06:59:49 <bollu> a fiber of an element in the range is the set of all elements in the domain that map to it, right?
07:00:06 <Cale> yeah, or an element of the codomain more generally
07:00:18 <ski> bollu : main difference is that in the earlier talk, `x' would be implicit in the values. for `foo :: exists a. [a]' you'd say `foo = [False,True,False]', not `foo = (Bool,[False,True,False])' as you'd do in the dependent setting
07:00:21 <Cale> (the fiber might be the empty set)
07:01:03 <bollu> so, given f: A -> B, fiber(b \in B) = { a | a \in A, f(a) = b) right?
07:01:04 <ski> bollu : similarly, in Haskell, given `reverse :: forall a. [a] -> [a]' you say `id [False,False,True]', rather than `id Bool [False,False,True]', which you'd have in the dependent setting
07:01:07 <Cale> bollu: So in set theoretical language, rather than having a function P from the type A, to the universe of types
07:01:11 <bollu> I dropped a }
07:01:57 <Cale> bollu: We instead start with the union of all of what would be those types, some big set E, and map its elements to A, according to which type they would have belonged to
07:02:10 <Cale> and this partitions E into a bunch of parts based on where its elements are being sent
07:02:20 <ski> bollu : the minor difference was that in the Haskell setting, `a' in `forall a. ..a..' and `exists a. ..a..' must be a type, while in a dependent setting `x' in `forall x. ..x..' or `exist x. ..x..' *could* be a type (e.g. of kind `*'), but could also be a value (e.g. of type `Bool')
07:02:59 <bollu> Cale: "of all of what would be those types" <- I'm not sure what this refers to (what are the contents of E? can I have some examples of things in E please?)
07:03:23 <Cale> I mean the types P x for each x in A
07:03:44 <bollu> so E contains all P x?
07:04:20 <Cale> Yeah, I don't know if this is going to be helpful if you don't already know about something like this from set theory
07:04:37 <Cale> The set theory way of doing this is a little bit harder to understand if you ask me
07:05:25 <bollu> Cale: what are we trying to define again? 
07:05:36 <bollu> Cale: you're creating cosets in some sense right?
07:05:54 <Cale> Well, we're trying to talk about what forall (x:A), P x is, but with set theoretical language
07:06:07 <Cale> since you seemed interested in writing it in some set theoretical way
07:06:12 <bollu> right!
07:06:23 <Cale> So, in order to do that, we need to talk about P
07:06:31 <Cale> But P was a map A -> Type
07:06:36 <bollu> correct
07:06:48 <Cale> and we don't really have some analogous thing in set theory
07:06:59 <gammastorm> hi
07:07:27 <bollu> so we decided to create it by first taking all P x (E)
07:07:28 <bollu> and then..?
07:07:33 <Cale> nono
07:07:38 <ski> hello gammastorm
07:07:55 <gammastorm> ski : interesetd in javascript SAT solver ?
07:08:06 <Cale> We start with some set E (which you should think of as the disjoint union of all the P x)
07:08:17 * ski isn't that interested in SAT solvers, no
07:08:24 <gammastorm> kk
07:08:34 <bollu> Cale: okay :)
07:08:42 <Cale> and we take a function f: E -> A, which assigns to each e in E which x in A it ought to correspond to
07:09:03 <bollu> Cale: with you so far
07:09:14 <Cale> and then P x gets modelled by the preimage f^-1{x}
07:10:14 <Cale> and now the idea we're trying to capture is that of a function which assigns to each x in A, some element of P x
07:11:17 <Cale> So that would be a function g: A -> E which has the special property that for all x, g(x) is in f^-1{x}
07:11:48 <bollu> Cale: okay, I think I got it
07:11:49 <Cale> That is to say, for all x, f(g(x)) = x
07:11:55 * ski idly wonders how easy it would be in HoTT to prove `E' is equivalent to `exists a. {e : E | f e = a}'
07:12:39 <bollu> Cale: since a "type" is a collection of values
07:12:43 <bollu> we first make f
07:12:49 <bollu> which takes values to their corresponding new types
07:13:04 <bollu> wait, that's wrong
07:13:10 <bollu> we make f
07:13:25 <bollu> which takes types to the _values they came from_ with respect to P, right?
07:13:30 <bollu> so when we invert it, we get P back
07:14:18 <bollu> right?
07:14:19 <kurt11> c_wraith: thank you
07:14:23 <Cale> We take the elements of those types (in the "total space" E), to the values in A they ought to be associated with
07:14:43 <kurt11> can someone help me with _really_ simple newbie indexed array (IArray) usage: http://lpaste.net/169098
07:14:48 <umib0zu> Can I talk about instantiating categories here? Why/when would it ever be useful to instantiate a type as a category?
07:14:54 <bollu> hmm
07:15:14 <bollu> Cale: okay, this is somewhat of a diversion in any case :)
07:15:18 <Cale> yeah
07:15:32 <Cale> Set theory is not good at expressing dependently typed functions
07:15:38 <bollu> Cale: so we have a forall (x: A) P(x)
07:15:41 <Cale> at least, traditionally
07:15:48 <Cale> We could make a careful new definition
07:15:49 * ski isn't sure what umib0zu means by "instantiate" here
07:16:04 <Cale> But that wouldn't be any easier than just talking about it in type theory
07:16:10 <Cale> okay
07:16:15 <Cale> So, now that you have these ideas
07:16:24 <Cale> Let's write our proof
07:16:26 <umib0zu> ski just make one. I’m asking when one has ever instantiated a category in their day to day and why?
07:16:31 <iphy> I have a client/server program, the server (using conduit) stays up for a while, the client is regularly restarted. The client makes many TCP connections (1000 of them) each run. Most of the time, a complete run of the client takes 0.3 seconds, but sometimes it takes 7 seconds or more. Any idea what this could be?
07:16:43 <lyxia> kurt11: you have to pick an array type
07:17:03 <mnoonan> umib0zu: are you talking about a Category typeclass, or something else?
07:17:14 <bollu> Cale: okay
07:17:15 <Cale> bollu: i.e. we want to write a function of type (forall x. (P(x) -> Q)) -> (exists x. P(x)) -> Q
07:17:36 <bollu> Cale: right
07:17:45 <iphy> last run I tried even took 22 seconds
07:17:47 <lyxia> kurt11: let a = array ... :: Array Int Int
07:17:51 <umib0zu> ok I’m calling taking any typeclass and instantiating it as a category. using the “instance Category …”.
07:18:22 <umib0zu> I mean it’s an abstract question I’m not asking about any specific type. I’m just asking has anyone ever found it useful.
07:18:24 <Cale> (\f -> ...) so it might as well be a lambda, here f : forall x. (P(x) -> Q), and the body of the lambda has type (exists x. P(x)) -> Q
07:18:54 <Cale> and so the body might as well be a lambda also
07:19:02 <umib0zu> Most of the time I find I’m writing monads anyways. it seems like monads are “better” than just plain old categories but I’m not sure
07:20:09 <Cale> oh, oops, I'm leaving out the type we're quantifying over
07:20:13 <Cale> though it doesn't actually matter :)
07:20:30 <bollu> right
07:20:35 <bollu> Cale: why doesn't it matter?
07:20:39 <mnoonan> one perspective is that a category is very similar to a monoid, except the operation is only defined on some pairs of "elements" (arrows)
07:20:48 <Cale> Well, the proof won't actually rely on what that type is in any way
07:21:10 <mnoonan> so in that sense, they are closer to the "monoid" end of the power spectrum rather than the "monad" end
07:21:11 <Cale> (so we could further abstract over it)
07:21:40 <Cale> umib0zu: Type classes can't be instances of other type classes.
07:21:51 <ski> (except ..)
07:21:58 <umib0zu> I mean Type
07:22:09 <ski> @kind Category
07:22:10 <lambdabot> (k -> k -> *) -> Constraint
07:22:37 <Cale> bollu: anyway, let's do this...
07:22:40 <ski> (anything that is to possibly be an instance of `Category' must be a type function, though)
07:23:04 <bollu> Cale: okay!
07:23:14 <umib0zu> well the name doesn’t matter much. I’m mostly asking about using Control.Category.
07:23:22 <umib0zu> When is it useful?
07:23:33 <Cale> bollu: So, (\f -> (\p -> ...)) so now we have f : forall (x:A), P x  and  p : exists (x:A), P x
07:23:43 <Cale> oops
07:23:46 <ski> umib0zu : arrows, which are categories with more stuff, were invented to be able to do more static analysis of a "computation", before starting "executing it"
07:23:48 <Cale> bollu: So, (\f -> (\p -> ...)) so now we have f : forall (x:A), P x -> Q  and  p : exists (x:A), P x
07:23:56 <Cale> and the (...) part is supposed to have type Q
07:24:13 <bollu> right
07:24:25 <kurt11> lyxia: thanks!
07:24:35 <Cale> So think about how this relates to our logical proof earlier as we go along
07:24:57 <Cale> So now we're in a context where we've assumed both that forall (x:A), P x -> Q
07:25:02 <ski> umib0zu : the problem here is that if you make `(>>=) :: M a -> (a -> M b) -> M b' bundle up the arguments in a data structure, then you can't inspect the `a -> M b' part of that data structure without executing the `M a' (in order to get hold of an `a' value to feed to the function of type `a -> M b'
07:25:04 <Cale> and that exists (x:A), P x
07:25:09 <Cale> and we're trying to prove Q
07:25:38 <Cale> but the only new thing is that we have names f and p for our assumptions
07:25:39 <bollu> right
07:26:02 <umib0zu> ski ah ok. so my interpretation that the Category typeclass has the “least” of something, but I’m not sure what that something is. it seems like arrows are a bit more, and monads are the “most”. 
07:26:07 <bollu> in the logic case, we used the face that P x should be inhabited, and we picked a "c"
07:26:07 <Cale> now, in order to apply f, we first need some x of type A to apply it to
07:26:13 <bollu> correct
07:26:16 <ski> umib0zu : however, it was discovered that applicative functors can also allow such static analysis, since if `(<*>) :: I (a -> b) -> I a -> I b' bundles up its arguments into a data structure, then the part with type `I (a -> b)' need not itself be a function
07:26:30 <umib0zu> I’m also not sure what static analysis means.
07:27:01 <Cale> So in this case, we get that fst p : A has the property  snd p : P (fst p)
07:27:10 <umib0zu> is that basically analyzing an input before a computation is run?
07:27:10 <kurt11> :q
07:27:28 <Cale> So fst p is our "c"
07:27:33 <bollu> okaay
07:27:40 <Cale> We might also write this in a pattern matching sort of way
07:27:44 * hackagebot solga 0.1.0.0 - Simple typesafe web routing  https://hackage.haskell.org/package/solga-0.1.0.0 (PatrickChilton)
07:27:50 <Cale> (\f -> (\(c,p) -> ...))
07:27:50 <ski> umib0zu : the particular case was a parser where you could analyze the structure of the parser before starting to use it to parse some input. e.g. whether the parser could possibly succeed without eating any input, and what the set of initial tokens that a successful parse by the parser would be
07:27:53 <bollu> Cale: that would help
07:27:58 <Cale> c : A
07:28:02 <Cale> p : P c
07:28:06 <bollu> right
07:28:07 <ski> umib0zu : using such static information, one can more efficiently implement the parsing
07:28:12 <Cale> f : forall (x:A), P x -> Q
07:28:16 <Cale> we want Q
07:28:25 <Cale> So we can apply f to c
07:28:29 <ski> umib0zu : with monadic parsers, this kind of thing isn't (in general) available
07:28:34 <Cale> and get  f c : P c -> Q
07:28:59 <Cale> and then we can apply the result to p
07:29:02 <Cale> f c p : Q
07:29:15 <Cale> So (\f -> (\(c,p) -> f c p))
07:29:19 <bollu> hmm
07:29:23 <Cale> is our whole proof :)
07:29:27 <bollu> that's cool :O
07:29:29 <Cale> encoded succinctly in one line
07:29:30 <glguy> The machines library is an example of something that makes use of the category type class as a consumer of instances
07:29:57 <bollu> I need to learn more dependant type theory! :)
07:29:58 <Cale> Well, that's one direction
07:30:03 <Cale> Let's try the other
07:30:10 <bollu> does Idris have an "exists"?
07:30:15 <Cale> yeah
07:30:39 <ski> umib0zu : with a monadic parser, you can parse some initial tokens into some value, and then check which value you got to determine which parsing action to do next. this generality hinders/interferes with the kind of optimization that the people interested in the parsers above wanted to be able to do
07:31:12 <Cale> So now we want to write a function of type ((exists (x:A), P x) -> Q) -> forall (x:A), (P x -> Q)
07:31:30 <umib0zu> hm this is interesting. what do you mean by “parsers” by the way? I feel like this is just an abstract word for “function” but I’m not sure.
07:32:29 <ski> umib0zu : with an "arrow" parser, or an applicative parser, the "structure" of the parsing is fixed in advance (at "compile-time"). with a monadic one, it may depend on intermediate results parsed during "run-time"
07:33:02 <bollu> correct
07:33:03 <merijn> umib0zu: A parsers is a program/library/whatever that turns unstructured "text" (like, e.g., a file) into structured data (like an Abstract Syntax Tree)
07:33:03 <Cale> (\f -> ...) -- so now we have f : (exists (x:A), P x) -> Q, and the body of the lambda has type forall (x:A), (P x -> Q)
07:33:04 <merijn> umib0zu: For example on the network you receive text and you have to parse it to construct a JSON object (the structured data)
07:33:04 <Cale> (\f -> (\x -> ...)) -- so now we have f : (exists (x:A), P x) -> Q, and x : A, and the body of the lambda has type P x -> Q
07:33:22 <ski> umib0zu : by parsing, i mean converting a sequence of tokens (commonly a list or array of characters) into some (usually) structured object, like a parse tree, that is more suitable for further analysis and processing
07:33:25 <Cale> (\f -> (\x -> (\p -> ...))) -- so now we have f : (exists (x:A), P x) -> Q, and x : A, and p : P x, and the body of the lambda has type Q
07:33:29 <umib0zu> so with the Monad typeclass, it seems like you’re saying the point after instantiating a function as a monad is that I can analyze a function before running it on an input, and compose functions, correct?
07:33:51 <Cale> and note that (x,p) : exists (x:A), P x
07:33:55 <bollu> right
07:34:07 <Cale> and so f (x,p) : Q
07:34:18 <bollu> lost me there
07:34:23 <bollu> oh right
07:34:24 <ski> umib0zu : e.g. reading a configuration file into an internal format. or reading a program from a file into a compiler or interpreter, or a markup document into a document viewer/processor
07:34:27 <bollu> because exists is the tuple
07:34:29 <bollu> okay
07:34:35 <Cale> yeah
07:34:51 <Cale> (\f -> (\x -> (\p -> f (x,p))))
07:35:21 <bollu> hmm
07:35:26 <bollu> this is cool
07:35:30 <Cale> So, after all that, it's just uncurry and curry
07:35:34 <Cale> :D
07:35:43 <bollu> oh my god I didn't even notice that
07:35:46 <bollu> that's insane
07:35:48 <ski> umib0zu : one possible use of `Category' might be to represent a sequence of abstract "actions" that can be done to some system (and that you e.g. want to record, in order to reapply them later to an initial state, to arrive at the desired target state, from which you may then want to continue)
07:35:57 <Cale> (with fancy types)
07:36:07 <bollu> tell me this has something to do with (->) and (,) being adjoint :)
07:36:28 <Cale> I'm sure it does
07:36:39 <ski> umib0zu : each action would have a type of shape `Action beforeState afterState', where `beforeState' and `afterState' would be "type tokens" that describe the general kind of state that the system is in
07:36:58 <Cale> Well, those things are special cases
07:37:05 <Cale> of forall and exists respectively
07:37:16 <Cale> where we take P x to be a constant
07:37:34 <Cale> If we have P x = B
07:37:35 <bollu> hmm
07:37:45 * hackagebot quantum-random 0.6.1 - Retrieve, store and manage real quantum random data.  https://hackage.haskell.org/package/quantum-random-0.6.1 (Cliff_Harvey)
07:37:47 <Cale> then forall (x:A), P x is the same as A -> B
07:37:48 <ski> umib0zu : the idea is tha each action would only be applicable in a state matching the `beforeState', and would transform the system into the new state `afterState' (possibly equal to `beforeState'). each action would possibly have a different `beforeState'&`afterState'
07:37:54 <ski> umib0zu : does this make any sense ?
07:38:07 <Cale> and exists (x:A), P x is the same as A * B
07:38:15 <Cale> Or (A,B) in Haskell notation
07:38:32 <Cale> (it gets weird to use Haskell's punny syntax with dependent types)
07:38:56 <Cale> (is (A,B) a type whose inhabitants are pairs, or is it a pair of types?)
07:38:59 <umib0zu> ski somewhat. I’m still pretty new with haskell and I’m actually starting to explore Control.Category
07:39:12 <umib0zu> any good references to further read into this?
07:39:33 <bollu> Cale: this is all a little too much to take in
07:39:38 <bollu> thanks a ton for all the references
07:39:54 <ski> umib0zu : i wouldn't say that `Category' (or `Arrow') is used that often, though
07:40:08 <ski> umib0zu : i suppose you could try reading the original arrow papers
07:40:27 <Cale> bollu: Eventually you will wake up some morning and have the realisation that without trying, you already know how to program in Coq.
07:40:37 <ski> umib0zu : btw, the "actions with before and after states" i sketched above requires "GADTs" (a language extension)
07:40:42 <bollu> Cale: I hope that day comes sooner than later :P
07:40:45 <Cale> haha
07:40:50 <bollu> Cale: I've been trying to work through SF as I told you before
07:40:54 <Cale> ah, okay
07:40:55 <bollu> Cale: but it's slow progress
07:41:01 <Cale> That counts as trying
07:41:03 <Cale> haha
07:41:04 <bollu> hope to get to HoTT by the end of the year
07:41:07 <merijn> Slow progress is better than no progress :)
07:41:08 <bollu> :)
07:41:11 <bollu> that too
07:41:14 <merijn> Also
07:41:35 <bollu> yes?
07:41:57 <merijn> Note that I worked through SF at summer school with a whole bunch of PL phds and we *still* got stuck frequently, hope that puts your slowness in perspective :)
07:42:07 <Cale> But yeah, that happened to me -- I just suddenly realised that after a decade of being exposed to random bits of type theory, Coq was almost totally natural, with a little bit of looking syntax and tactics up in the manual
07:42:55 <bollu> Cale: you've been at type theory for a decade? :D
07:43:03 <Cale> more than that actually
07:43:08 <bollu> merijn: haha, that does make me feel a little better
07:43:22 <Cale> I started learning Haskell around 2001-2002
07:43:23 <jackhill> SF?
07:43:25 <merijn> bollu: Learning is just hard :)
07:43:26 <ski> umib0zu : otoh, the abstract concept of "category" is used more often, in informal discussions, to talk about functors (in general, as opposed to just the `Functor' type class), natural transformations, monad morphisms, adjunctions, `Yoneda'&`CoYoneda', &c.
07:43:30 <bollu> I maybe working under a type theory prof next sem, so I'm hoping that will help
07:43:30 <ski> @where SF
07:43:31 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
07:43:31 <lambdabot> assistant."
07:43:33 <merijn> jackhill: Software Foundations
07:43:34 <ski> jackhill ^
07:43:42 <jackhill> ski, merijn: thanks!
07:44:37 <umib0zu> ski yup yup. in this case I just meant Control.Category. Everyone seems to be more hyped about monads, but I wasn’t sure why Control.Category isn’t really seen.
07:44:45 <ski> @where HoTT
07:44:45 <lambdabot> http://homotopytypetheory.org/book/
07:45:28 <qinusty> Hey guys, quick question. I'm looking towards concurrency for a solution to my problem and was wondering if you guys had any input on where to look. I want to have a queue of IO () actions shared between two threads. One thread runs the application and appends to the queue and the other slowly performs the IO actions with delays. 
07:45:58 <merijn> qinusty: Control.Concurrent.Chan filled with IO actions?
07:46:28 <merijn> qinusty: Should be almost trivial to implement
07:46:41 <qinusty> Okay I'll look into it, Thanks
07:46:54 <umib0zu> ski was that for me? I’m not ready for HOTT yet. Still reading CTFS.
07:47:47 <ski> umib0zu : just someone mentioned HoTT in addition to SF, so i thought i'd expand it for interested bystanders
07:47:54 <Cale> umib0zu: Well, it's just a little less common to need to parameterise the type of the computations you're working with over both its "input" and "output" type
07:47:59 <ski> umib0zu : "CTFS" being ?
07:48:15 <Cale> umib0zu: (for why Category is a bit less popular)
07:48:31 <Cale> Also, there's not a whole lot you get from Category alone
07:48:57 <Akii> umib0zu: what's CTFS?
07:49:14 <Cale> The whole point of the Monad and Applicative type classes is that you get a library of functions like sequence and forM and liftM2 and so on (all the Traversable stuff)...
07:49:19 <Akii> HoTT looks readable looking at the first couple pages xD
07:49:22 <umib0zu> Akii http://math.mit.edu/~dspivak/teaching/sp13/
07:49:33 <umib0zu> category theory for scientists
07:49:42 <Cale> and in the case of Category, it's much rarer to be able to abstract some algorithm over a choice of category, than it is to abstract it over a choice of monad
07:49:44 <ski> umib0zu : still, the talk about "categories" should probably considered as a more esoteric part, by which i mean more abstract, and less directly related to the common practicalities. iow, it can be useful to know about, if you find mathy things fun and interesting, but it's not as essential as knowing (how to, in programming, use) `Functor',`Applicative',`Monad'
07:50:09 <Akii> thanks!
07:50:42 <ski> umib0zu, ty
07:52:36 <schmittr> Cale: I'm still struggling with the json stuff, do have a moment?
07:52:45 * hackagebot th-lift-instances 0.1.9 - Lift instances for template-haskell for common data types.  https://hackage.haskell.org/package/th-lift-instances-0.1.9 (BennoFuenfstueck)
07:55:05 <umib0zu> ski yup yup. ty. I mostly have a handle on Functor, Applicative, and Monad in the programming sense. I’m at a point where I’m trying to program down but theory up right now. I have a theory sense of a category, but no programming sense of it.
07:55:20 <umib0zu> But program wise, I have an understanding of Monad, but no theory yet.
07:55:31 <umib0zu> hence my questions about Control.Category
07:58:04 * ski nods
07:59:22 <dbishop> 1
07:59:34 <ski>     3
08:01:19 * ski continues pondering Kan extensions
08:02:45 * hackagebot singleton-nats 0.4.0.2 - Unary natural numbers relying on the singletons infrastructure.  https://hackage.haskell.org/package/singleton-nats-0.4.0.2 (AndrasKovacs)
08:02:47 * hackagebot jsaddle 0.4.0.4 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.4.0.4 (HamishMackenzie)
08:05:00 <tippenein> why does System.Environment throw an exception on getEnv ?
08:05:19 <tippenein> is it encouraged to use Posix.Env ?
08:06:35 <sm> tippenein: it's defined that way. lookupEnv right below it is the safe one
08:06:53 <sm> https://hackage.haskell.org/package/base-4.9.0.0/docs/System-Environment.html#v:getEnv
08:07:04 <tippenein> ahhh, bollox
08:12:51 <tippenein> *** Exception: SQLite3 returned ErrorRange while attempting to perform bind text.
08:13:16 <tippenein> interesting error from rawSql persistent
08:29:10 <jgt1> I have a list of pairs; how can I turn it into a record?
08:29:27 <nmattia> jgt1: what's a record?
08:29:32 <enthropy> map (uncurry Constructor) -- probably
08:29:58 <nmattia> oh.
08:30:10 <jgt1> nmattia: by record, I mean `data Thing = Thing { Attr :: Text…` etc
08:30:10 <enthropy> data T = Constructor { x, y :: Double }
08:30:30 <byorgey> jgt1: a list of pairs of what? Strings?
08:30:30 <lpaste> tippenein pasted “persistent rawSql ErrorRange from bind” at http://lpaste.net/169104
08:30:32 <nmattia> jgt1: I assumed the first element of your pair was somehow the name of the field, my bad
08:30:46 * ski is assuming something like `[("name","Dorkas"),("age","43"),("occupation","Tent maker")]'
08:30:58 <nmattia> ski: exactly
08:31:07 <jgt1> I'm assuming they're all strings
08:31:16 <jgt1> I'm a Haskell newbie, so I'm not sure
08:31:22 <jgt1> it's POST data in Yesod
08:31:45 <jgt1> I'm doing `(postData, _) <- runRequestBody` to get my list of pairs
08:31:51 <byorgey> jgt1: why do you want to turn it into a record?
08:32:07 <nmattia> so you have some sort of association list I guess?
08:32:14 <ski> we'd probably need to know more specifically how your record type is defined
08:32:34 <jgt1> byorgey: that's what I already do when accepting JSON in my handler. I'm just assuming this is the correct thing to do
08:33:09 <infandum> Is there a reason why every file builds, but a module that exports another module never exports anything from that module? So I have Test.hs which exports Test2.hs. However, when loading Test.hs (stack ghci) all other modules are exported other than Test2.hs. When I explicitely do import qualified Data.Blah.Test2 as T2 or whatever, it works but it doesn't list any of the functions in there at all.
08:33:11 <jgt1> ski: my constructor (right term?) looks like `data Message = Message { name :: Text , email :: Text , subject :: Text , body :: Text } deriving (Show)`
08:33:27 <nmattia> jgt1: what about using 'lookup' from Data.List and build each field?
08:34:06 <tsahyt> I've got a stateful computation with a state that is a product of some types, say MyState = MkS FooState BarState. I've got some functions that operate only on part of this, say fooAction. So far I've done this using a separate FooAction monad, which has a MonadState FooState instance. so fooAction :: FooAction, and I have a function to run actions composed in this monad in the "parent" monad. But it ocurred
08:34:08 <tsahyt> to me recently that I can use effect classes instead and get virtually the same static guarantees without having multiple types or the functions to execute those DSL-like sub-actions. Am I missing something or is the class based approach generally preferable?
08:34:23 <jgt1> nmattia: I don't know enough about Haskell to tell you whether or not I think that's the right approach
08:35:00 <benzrf_> hey
08:35:15 <benzrf_> ghc can't figure out that (0 ~ n + 1) is unsatisfiable? :(
08:35:26 <benzrf_> is that right, or am i doing something wrong?
08:35:35 <tsahyt> (with effect classes I mean defining a class FooAction which defines whatever primitives I want to allow on those FooStates. this means that I can have fooAction :: FooAction m => m ())
08:35:49 <nmattia> jgt1: I don't know enough about your code or about Yesod to tell you if it's the right approach :(
08:36:29 <c_wraith> benzrf_, ghc without type checker plugins knows approximately nothing about Nat
08:36:32 <nmattia> benzrf_: I guess you '+' is only defined on naturals?
08:36:36 <hpc> benzrf_: iirc ghc's type nats still haven't been perfected and there's a bunch of those things laying about
08:36:37 <benzrf_> c_wraith: ;-;
08:36:43 <hpc> benzrf_: does it figure out 1 + n?
08:36:47 <benzrf_> oh, let me try!
08:37:07 <enthropy> benzrf_: probably can if you could rewrite a ~ b + c  to a use of  Class a b c | a b->c, b c ->a, c a -> b
08:37:09 <hpc> you can also try 0 ~ S n, or Z ~ S n
08:37:18 <hpc> or... ooh, fundeps
08:37:32 <benzrf_> nope :|
08:37:38 <benzrf_> fundeps, wha?
08:37:40 <benzrf_> how os?
08:37:42 <benzrf_> *so
08:38:13 <hpc> benzrf_: you'd make instance resolution able to infer any of a, b, c given the other two
08:38:18 <hpc> in which case you have a = 0, c = 1
08:38:27 <hpc> and instance resolution discovers there is no instance or something
08:38:39 <hpc> you're sort of programming your own nat solver
08:38:41 <enthropy> infandum: is it possible you're confused by the fact that ghci doesn't respect export lists? (So this Test2.function you can refer to might not be exported by Test2...)
08:38:45 <hpc> for that single specific formula
08:39:14 <benzrf_> hpc: well i'm familiar with fundeps - i'm just not sure how they apply here
08:39:28 <nmattia> c_wraith: what's that type checker plugin?
08:39:41 <hpc> you'd write instance Class 0 0 0
08:39:52 <hpc> instance Class (n ~ m) => Class n 0 m
08:39:53 <hpc> etc
08:39:54 <benzrf_> oh, you mean - literally programming + from scratch?
08:39:58 <benzrf_> ack
08:40:47 <enthropy> tsahyt: if the effect classes are what I think you're talking about, they are possibly slower than another data type?
08:40:52 * enthropy looks for a benchmark
08:41:12 <tsahyt> enthropy: why would that be?
08:42:43 <enthropy> tsahyt: if you pile on lots of state effects in freer, it seems to be stored like "State (a,(b,(c,(d, ())))) x"
08:42:54 <tsahyt> freer?
08:43:20 <enthropy> oh well maybe I'm talking about something else
08:43:48 <danza> hi all, one question ... i am parsing a price value like "$1,234.03", with Parsec ... i managed to get ("1",["234"],"03"), with a nice monadic composition. Is turning this into a number part of parsing? I can't find an easy way to do that with Parsec, without using a state, for example. That seems complex, i would rather write a pure function. Is this part of parsing, or it goes under a different term?
08:44:12 <tsahyt> enthropy: I have a type with a MonadState FullState instance. I want to build classes on top of that which restrict which parts of the state is being worked on, such that my type signatures are more accurate
08:44:13 <enthropy> in that you are dealing with implementations like "calc1 :: State (X T) a", "calcZoomed :: State T a"
08:44:37 <enthropy> with X and T being defined with data X = X { a,b,c :: Int}, etc.
08:44:38 <tsahyt> where FullState is isomorphic to some tuple
08:46:47 <dmj`> danza: I'd check out parsec-numbers
08:46:48 <enthropy> okay my performance comment applies to http://hackage.haskell.org/package/freer (http://lpaste.net/169105 specifically)
08:46:54 <dmj`> @pacakge parsec-numbers
08:46:54 <lambdabot> Unknown command, try @list
08:46:59 <dmj`> @package parsec-numbers
08:46:59 <lambdabot> http://hackage.haskell.org/package/parsec-numbers
08:47:01 <danza> thanks a lot dmj` :)
08:48:15 <danza> still, conceptually, is that part of parsing, or is it a later or a more specific stage?
08:48:32 <enthropy> tsahyt: I think what you're proposing takes some discipline (because you might accidentally call Control.Monad.State.get)
08:48:36 <monochrom> it is part of parsing.
08:48:50 <dmj`> danza: although, you might be able to write your own, satisfy Data.Char.isNumber
08:49:12 <danza> that will not sum the digits
08:49:21 <tsahyt> enthropy: only as so far as I need to specify the type signature I think
08:49:35 <qinusty> thimoteus: New version up and running using Control.Concurrent.STM.TChan to manage concurrent message sending and allow for delays. Delay is set for 1s, might need tweaking.
08:50:05 <tsahyt> once I've gone from FullMonad () to RestrictedAction m => m (), using get should invoke a type error
08:50:39 <thimoteus> qinusty: cool, i'll check it out!
08:51:23 <qinusty> I also added a 'players' command to list other players who have messaged the bot since it's last restart. Next on the agenda is persistent data
08:53:03 <dmj`> danza: true, but it would be safe to call 'digitToInt' on a character you know is a number
08:53:31 <dmj`> danza: this is how parsec-numbers does it's conversion, http://lpaste.net/358990774102130688
08:53:35 <dmj`> its*
08:56:24 <tsahyt> enthropy: in particular I can of course still write functions in the parent monad directly and modify any state as I please, but I could do that with the DSL monad approach too
08:56:53 <danza> dmj`, yeah i was opting for something like that (actually using `read`) ... but i had hard times intertwining this in the monadic expression. I can do it in a pure external function
08:57:46 <dmj`> danza: yea, read is scary Text.Read.readMaybe is to be preferred imo
08:58:16 <enthropy> tsahyt: makes sense. I think "Control.Lens.zoom (_Wrapping RestrictedNewtype)", for meshing newtype RNT = RestrictedNewtype FullData might be less code for the same result?
08:58:23 <danza> right but the input is coming out of the parser, so using read is as safe as `digitToInt`
08:58:56 <danza> or ... as unsafe ... :P
08:59:00 <tsahyt> enthropy: possibly but it would require me to learn lenses and pull in the whole tree of dependencies that it comes with. that's a bit more than I'm comfortable with just for this one thing
09:00:04 <dmj`> danza: true :] there should be token parser's for things like integer, float in the base parsec package, maybe check out Text.Parsec.Token.integer
09:00:09 <monochrom> clearly, you can put pure code inside monadic code. for example "return (f cs)". for example "let y = f cs" in a do-block. etc etc.
09:01:38 <monochrom> logically, if pure code were banned from moandic code, then monadic code would be utterly useless, since for example "hGetLine h" is both pure code and monadic code at once.
09:02:18 <danza> monochrom, yes, but then i have conflicts, because some expressions would return a Number (like parsing the `1` at the beginning) and other expressions would return a String (like discarding the `.`)
09:02:29 <danza> so the monads don't match! :)
09:03:35 <monochrom> that is unrelated to putting pure code inside monadic code. pure code can have such type errors too. theorem: type error = thinko.
09:03:46 <ski> jgt1 : nmattia's `lookup' suggestion sounds like it could work. perhaps you'd like to check that there's no duplicate fields specified in the association list, and that there's no extra fields either, though
09:04:08 <monochrom> "if True then 1 else "."" is an easy example. no monad needed.
09:04:22 <jgt1> ski: I realise I might be making it more complicated for myself
09:05:31 <jgt1> instead of looking at the raw POST data with runRequestBody, I could try and build my Message with Yesod's forms, i.e., runFormPost
09:05:47 <ski> jgt1 : in `data Message = MkMessage { name,email,subject,body :: Text } deriving Show', `Message' would be the type (constructor), and `MkMessage' would be the (data) constructor
09:06:58 * ski doesn't really know much about Yesod either .. :/
09:07:47 * hackagebot cabal2nix 2.0 - Convert Cabal files into Nix build instructions.  https://hackage.haskell.org/package/cabal2nix-2.0 (PeterSimons)
09:07:59 <S11001001> tsahyt: classes sounds fine
09:09:00 <Benzi-Junior> can anyone point me towards a tutorial or code example for how to implement unboxed arrays for custom types ?
09:09:12 <Benzi-Junior> or just using unboxed types in general
09:09:28 <Benzi-Junior> ehh unboxed arrays  I mean
09:10:01 <S11001001> tsahyt: however, if you want to generally use combinators written to MonadState (rather than your classes with their own variants of 'get' et al), you'll need to use something like zoom, which is a whole set of a new mtl class and its instances, so it might be worth pulling in lens at that point
09:11:53 <enthropy> Benzi-Junior: have you seen https://hackage.haskell.org/package/vector-th-unbox ?
09:13:13 <tsahyt> S11001001: I think it won't be necessary but I'll keep it in mind in case the situation arises
09:14:49 <Benzi-Junior> enthropy: yes 
09:15:21 <Benzi-Junior> enthropy: but am not all to sure how it works
09:15:36 <Benzi-Junior> enthropy: is it a suitable replacement ?
09:16:36 * enthropy recalls some comments in the code
09:16:54 <iphy> is there a function typed Bool -> (a -> b) -> (a -> b) -> a -> b?
09:17:05 <iphy> hoogle doesn't find it, but it seems like that should exist
09:17:22 <liste> :t bool
09:17:23 <lambdabot> a -> a -> Bool -> a
09:17:42 <iphy> oh right
09:17:50 <liste> unify a with (a -> b) and flip the args around a bit
09:17:57 <jgt1> darn. My runFormPost idea won't work. Back to the drawing board.
09:18:09 <iphy> yes
09:18:30 <iphy> where is bool from?
09:18:52 <enthropy> Benzi-Junior: if the comments don't explain, you can compile an example with -ddump-splices (and -dsuppress-uniques or similar) to get an example
09:19:18 <byorgey> iphy: Data.Bool
09:19:25 <geekosaur> @index bool
09:19:26 <lambdabot> Data.Bool
09:19:42 <iphy> thanks
09:20:00 <iphy> hoogle wasn't very helpful there (or I failed to use it correctly)
09:20:19 <enthropy> it probably stores your "data X = X { x, y :: !Int }" with all the x in one array and y in a second (as opposed to interleaving them like [x,y,x2,y2 ... ])
09:20:43 <suppi> use hayoo
09:21:23 <benzrf_> is there a function in base to map over a list element by index
09:22:31 <lpaste> buglebudabey pasted “program” at http://lpaste.net/169109
09:22:32 <monochrom> does Data.List have it?
09:22:50 <buglebudabey> is there any way that program can produce the number 16?
09:22:57 <suppi> benzrf_: you can use zipWith i guess 
09:23:18 <suppi> zipWith f [0..] list
09:23:22 <buglebudabey> http://lpaste.net/169109 can this program produce 16 under any circumstances?
09:23:42 <lyxia> buglebudabey: how's twice defined
09:23:47 <benzrf_> suppi: yeesh
09:23:55 <benzrf_> er, no i mean -
09:24:00 <buglebudabey> lyxia twice = f (f x)
09:24:02 <Benzi-Junior> enthropy: i'll check it out 
09:24:11 <benzrf_> like this:
09:24:31 <benzrf_> > "abcdef" & ix 3 %~ succ
09:24:33 <lambdabot>  "abceef"
09:24:53 <enthropy> buglebudabey: does it typecheck in a sensible amount of time for you?
09:25:00 <enthropy> looks like it won't
09:25:14 <suppi> i don't know :p
09:25:26 <buglebudabey> enthropy that is Core, not haskell, i'm trying to compile it. when i put parenthesis around (twice inc) it runs correctly
09:25:55 <buglebudabey> enthropy so i'm wondering why it may not be parsing or compiling correctly
09:26:12 <monochrom> I have trouble believing that it is Core.
09:26:49 <buglebudabey> monochrom i'm following spj book implementing functional languages
09:26:51 <monochrom> I now know why I can't believe it. Core is full of type annotation.
09:27:02 <buglebudabey> monochrom that's the core he defined back then in this book
09:27:42 <monochrom> ok, you actually have something that runs Core?
09:27:48 <buglebudabey> monochrom i'm only implementing arithmetic at the moment, not type checking
09:28:15 <buglebudabey> enthropy lyxia when i run twice twice (twice inc) 0 = 8
09:28:26 <buglebudabey> twice twice twice  inc 0 = 16
09:28:36 <buglebudabey> twice (twice twice inc 0) = 8
09:28:50 <buglebudabey> (twice twice) twice inc 0 = 16
09:29:05 <buglebudabey> not sure why
09:29:06 <lyxia> a b c d  ==  ((a b) c) d
09:29:16 <monochrom> I also have trouble believing "twice = f (f x)". you have two free variables there, you know that?
09:30:06 <buglebudabey> monochrom twice f = compose f f, compose f g x = f (g x)
09:31:27 <monochrom> OK, so what is the question again?
09:31:36 <benzrf_> buglebudabey: monochrom was just referring to how you forgot to write the variables on the left hand side in "twice = f (f x)"
09:31:54 <buglebudabey> that's why i just corrected myself
09:40:13 <lpaste> buglebudabey pasted “program” at http://lpaste.net/8538217610888609792
09:40:33 <lpaste> buglebudabey pasted “program” at http://lpaste.net/169112
09:40:45 <buglebudabey> monochrom sorry, i missed your reply, so the program that was just pasted
09:40:55 <buglebudabey> i am parsing, compiling, interpreting
09:41:27 <buglebudabey> and in that program im getting different results depending on parenthesis vs none
09:41:49 <buglebudabey> is there something that would have to do with left or right associativity in my parsing that could be causing this?
09:42:33 <monochrom> do you know how, in highschool algebra for example, (2 / 3) / 4 has a different answer from 2 / (3 / 4)?
09:42:46 <hpc> buglebudabey: http://lpaste.net/8538217610888609792
09:42:49 * hackagebot colonnade 0.3 - Generic types and functions for columnar encoding and decoding  https://hackage.haskell.org/package/colonnade-0.3 (andrewthad)
09:42:51 * hackagebot reflex-dom-colonnade 0.3 - Use colonnade with reflex-dom  https://hackage.haskell.org/package/reflex-dom-colonnade-0.3 (andrewthad)
09:44:42 <buglebudabey> monochrom of course, i guess im just unsure of why when i have no parenthesis at all it assumes (twice twice) twice inc rather than twice twice (twice inc)
09:45:02 <hpc> because that's how the associativity of function application is defined
09:45:03 <monochrom> then combine with what lyxia said most recently.
09:46:22 <buglebudabey> alright, thanks
09:47:01 <monochrom> this is exceedingly strange, because supposedly you wrote the parser yourself.
09:47:46 <monochrom> can you predict the behaviour of the parser code your wrote yourself?
09:48:27 <buglebudabey> the way i wrote it, it should be parsing it as (twice (twice (twice inc))) 4
09:49:02 <lyxia> this is a very odd parser
09:49:46 <monochrom> if I try 3 different inputs, "2 - 3 - 4", "(2 - 3) - 4", "2 - (3 - 4)", can you predict what trees your parser will produce, respectively? (here there is no right and wrong, the point is only "do you know what your code does?")
09:51:00 <buglebudabey> yes, the last 2 cases would act as expected
09:51:06 <buglebudabey> the first would act as the second
09:51:09 <monochrom> and after your prediction, can you add a few Debug.Trace thingies to your code so it prints out the tree to confirm or refute your prediction?
09:51:38 <buglebudabey> twice inc 4 would parse as Apply twice (Apply inc 4)
09:52:49 * hackagebot wai-extra 3.0.16.0 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.16.0 (MichaelSnoyman)
10:09:15 <isochronia> Hi. I've been looking at Gloss, which has a Vector type, a synonym for (Float, Float). I'm a bit confused, because you can use (+) on them to add them, but wouldn't that make them an instance of Num? And, looking through the source, I can't find the type declarations at all.
10:09:52 <monochrom> yes, someone wrote a Num instance for (Float, Float)
10:10:08 <monochrom> maybe even Num a => Num (a, a)
10:10:17 <Geraldus> Hi friends! o/
10:10:36 <Geraldus> Does anybody know why there is no GHC 8 release on http://ghcformacosx.github.io/ ?
10:10:38 <isochronia> But I can't add (Float, Float)s natively.
10:11:20 <isochronia> I don't suppose you'd know off the top of my head. But I looked through the package source and I can't find a Num instance declaration, for anything.
10:11:24 <schell> Geraldus: the project is looking for new maintanership, last i heard
10:11:28 <isochronia> Nor explicit declarations for Vector.
10:11:50 <schell> it requires a small investment, since you need a mac developer’s account ($100)
10:11:54 <Geraldus> schell: ah… I hope it won't be left
10:12:25 <schell> me too - it’s professional and really lowers the barrier to entry
10:12:44 <monochrom> perhaps it is in some library Gloss depends on.
10:12:45 <Geraldus> Yeah, it's very nice.  
10:13:06 <Geraldus> Ok, meanwhile I can use stack I guess
10:14:41 <isochronia> Oh, that explains the other question I had. Yes, monochrom, you're right.
10:14:50 <isochronia> And it is instantiated as Num.
10:14:54 <isochronia> Thank you.
10:16:50 <infandum> enthropy: But for the other modules that Test exports they work. Only this one doesn't
10:19:14 <jle`> Geraldus: presumably you could install the 7.10 verison and then update it with stack?
10:21:50 <Geraldus> jle`: I have 7.10.3 installed as .app-bundle, and have installed version 8 via `stack setup` command.  I just wondered why there is no 8.0.1 dot-app-bundle for a long time.  
10:22:06 <jle`> ah ok
10:22:31 <Geraldus> By the way, is there a way to build GHCJS from GHC-8 branch using stack?
10:23:31 <mbuf> `a' is a rigid type variable bound by insert :: Ord a => Tree a -> a -> Tree a. What am I missing? https://paste.fedoraproject.org/388110/ 
10:24:40 <hpc> mbuf: it's a particular sort of type error for type variables
10:25:14 <hpc> the first part of the error is the more important part, it says you're saying something is of type 'a' and it's actually of type (t0, Integer)
10:25:33 <hpc> and the part you highlight is saying 'a' is set in a way that you can't just unify the two
10:25:34 <mbuf> hpc: I am actually using (String, Integer) for the type
10:25:54 <jle`> mbuf: so you probably need Tree (String, Integer) -> ...
10:25:56 <jle`> not Tree a
10:26:27 <mbuf> jle`: or Tree Wordcount?
10:26:36 <geekosaur> "your type signature says the caller can specify whatever `a` they want, but then you use it as if it's always a tuple whose second component is Integer"
10:26:37 <ski>   insert :: (Ord a,Num b) => Tree (a,b) -> a -> Tree (a,b)  -- might perhaps be closer to what you want
10:26:47 <ski> but you'll still have a type mismatch/error
10:26:49 <benzrf> @hoogle Int -> [a] -> (a -> a) -> [a]
10:26:53 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
10:26:53 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
10:26:53 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
10:26:57 <benzrf> :\
10:27:20 <jle`> if you're saying your function takes a 'Tree a' for any 'a', that's a lie --- your function only works for (a, b)'s, where a is n OrdN instance and b is a Num instance
10:27:48 <jle`> *is an Ord instance
10:28:06 <ski> mbuf : in the second defining clause of `insert', `x' has the same type as the first component of the pairs `a' in your tree. but in the first defining clause `x' is placed as a tree element, so must itself be such a pair. this doesn't work (you'd need an infinite type `((((...,b),b),b),b)')
10:33:28 <mbuf> ski: jle` hpc I got it working, https://paste.fedoraproject.org/388113/
10:34:16 <Cale> btw, if you're going to use fst a and snd a like that, you might consider pattern matching a
10:34:32 <Cale> insert (Node (u,v) left right) x
10:34:47 <Cale>   | x == u = Node (u, v+1) left right
10:34:51 <Cale> etc. etc.
10:35:57 <mbuf> Cale: cool!
10:36:24 <ski> `fst (a)' can be written as `fst a', but pattern-matching like Cale suggested is usually preferable
10:36:57 <ski> instead of doing `==',`<',`>' between the same two values, you can call `compare', and match the result with `EQ',`LT',`GT'
10:37:28 <ski>   insert (Node (u,v) left right) x = case x `compare` u of
10:37:32 <ski>     EQ -> ...
10:37:35 <ski>     LT -> ...
10:37:37 <ski>     GT -> ...
10:37:52 <ski> that might be somewhat more efficient
10:38:03 <mbuf> ski: thanks!
10:46:11 <runeks> Anyone aware of a simple way to split a single Haskell executable into two executables which communicate over some kind of IPC protocol? I have a library with a well-defined interface that is currently used by a server, and I would like to split the functionality of this library into a separate process, but I really would prefer not to have to go through the
10:46:11 <runeks> long process of writing the code that serializes commands and function arguments over some network protocol (and then deserializes argumentss and runs the command on the server side followed by serializing the response etc...).
10:46:47 <alercah> conduit/pipes can help immensely with that
10:47:08 <merijn> runeks: Why specifically a separate process?
10:47:59 <Cale> runeks: The closest thing I can think of to that is the Cloud Haskell stuff.
10:48:05 <runeks> merijn: I want to separate logic and state. So I can update the logic part without touching the state (database, really).
10:48:13 <runeks> Cale: I've been looking at that
10:48:26 <dysfun> also transient looks interesting
10:48:37 <Cale> runeks: Well, there are tools to help write the network protocol fairly automatically in other ways -- e.g. the Template Haskell and Generic stuff in Aeson
10:48:44 <runeks> I guess what I'm really looking for is a  library that takes a library and easily makes it usable over IPC.
10:49:32 <runeks> Cale: It's very possible I'm looking for a library that automates that automation
10:49:45 <Cale> There's nothing which guarantees that your library's API consists entirely of things to which the arguments are reasonable to serialise
10:50:01 <alercah> haskell does not have remote code execution capability
10:50:04 <Cale> (in fact, most functional libraries won't be...)
10:50:07 <alercah> you need to write the control flow yourself
10:50:48 <merijn> alercah: That's not actually true
10:50:54 <runeks> The arguments need to be serializable, yes. And they all are, because I already save them to disk.
10:51:03 <alercah> merijn: it isn't?
10:51:06 <merijn> alercah: With StaticPointers you can serialise a large number of closures
10:51:15 <alercah> huh, neat
10:51:27 <alercah> still, I wouldn't want to do that
10:51:28 <merijn> alercah: It's work related to the aforementioned Cloud Haskell
10:51:36 <alercah> I'd rather use explicit control flow myself
10:51:41 <alercah> something more erlangy
10:52:04 <Cale> There are a bunch of things which would be interesting to do with the Cloud Haskell stuff that actually have nothing to do with distributed computation.
10:53:12 <runeks> I still haven't quite understood what Cloud Haskell does
10:54:10 <Cale> https://skillsmatter.com/skillscasts/3523-cloud-haskell is a good talk about it
10:54:33 <runeks> Cale: Thanks!
10:54:49 <Cale> (you need an account on that site, obnoxiously, but the accounts are free)
10:56:13 <Cale> There's also this, which iirc, is a good followup talk by the same guy https://www.youtube.com/watch?v=1jJ2paFuErM
10:56:39 <Cale> actually, it might be a pretty similar talk, flipping through it
10:56:41 <Cale> I forget
10:59:11 <runeks> Sounds like what I'm after
11:00:35 <runeks> There really isn't any logical reason that the Haskell function I execute needs to be executed within the same process.
11:00:57 <shaleh> I am experimenting with parsers. If I have a language with the following: "expr | expr (and|or) expr" I can get a Parsec implementation working but trying the and/or first then falling back to just the expr. But this is expensive because the expr is parsed multiple times. Can anyone point me to an example where the parser reads part of an expression and then attempts to read the next part returning just the first one if the parsing 
11:00:57 <shaleh> fails without also failing the entire parse?
11:01:16 <runeks> Although it would be nice if it were implemented in Haskell, rather than in C (as I understand the forkIO stuff is)
11:01:29 <runeks> I mean as a Haskell library
11:01:41 <runeks> And not part of GHC
11:01:44 <hpc> shaleh: you would use the follow set of expr, which is "" | (and|or) expr
11:02:02 <hpc> so your parser would be expr ("" | (and|or) expr)
11:02:58 <shaleh> hpc where "" is eol/eof?
11:03:12 <hpc> yeah, or something like that
11:03:24 <hpc> maybe it's just the empty match (always succeeds, never consumes input)
11:03:38 <hpc> depends on what's happening around your minimal example
11:03:47 <hpc> the thing to google for is "first and follow sets"
11:04:03 <shaleh> hpc: thank you for the pointer
11:06:49 <hpc> . o O ( follow sets look a lot like continuations, wonder if there's any interesting theory to be found there )
11:07:42 <ski> shaleh : do you want ambiguous parses ?
11:08:24 <shaleh> ski: hmm. Good question.
11:08:50 <ski> shaleh : also you can search for "left factoring" and "left recursion", i think
11:09:14 <shaleh> ski: a real work example is something like (rule:has_x or rule:is_y). rule:has_x by itself is also valid.
11:09:54 <ski> hpc : i think this is related to continuations ..
11:10:43 <ski> hpc : .. at one point i wanted to make a precedence parser based on the idea of (multi-prompt) composable continutions, though i didn't finish it
11:12:31 <shaleh> so what I am trying to wrap my head around is how to only parse 'rule:has_x' once from my example above.
11:12:54 * hackagebot mac 0.1.3.0 - Static Mandatory Access Control in Haskell  https://hackage.haskell.org/package/mac-0.1.3.0 (AlejandroRusso)
11:13:21 <shaleh> if I write 'rule <|> or_rule' then the first part is parsed twice. Order helps the parsing but does not help the optimization.
11:13:37 <hexagoxel> for an expression parser, i used something like parseTerm >>= parseExprCont, where parseExprCont :: Term -> Parser Expr.
11:13:50 <hexagoxel> but that is not really a continuation..
11:13:56 <hexagoxel> it is closer to https://en.wikipedia.org/wiki/Shunting-yard_algorithm
11:14:49 <hexagoxel> and you can do precedence parsing (e.g. different binary operators) with that.
11:17:54 * hackagebot jsaddle 0.4.0.5 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.4.0.5 (HamishMackenzie)
11:18:34 <ski> hexagoxel : it is, though it's not plain CPS, it's nqCPS
11:18:47 <ski> ("not-quite Contination-Passing Style")
11:19:04 <hpc> :t (getLine >>=)
11:19:05 <lambdabot> (String -> IO b) -> IO b
11:19:11 <hpc> looks CPS to me!
11:19:14 * ski sometimes would call that  parseExprCont  :  return'
11:19:56 <hpc> it's just not double-CPS, which is where you can start flattening it into Cont and such
11:20:20 <hpc> or something like that
11:20:27 <ski> "double" ?
11:20:33 <infandum> In ghci, :show imports, what does -- added automatically mean?
11:21:53 <hpc> ski: er, ignore that i am a derp
11:22:00 <hpc> "not quite CPS" is probably a better term for it
11:22:54 * hackagebot jsaddle-dom 0.2.0.1 - DOM library that uses jsaddle to support both GHCJS and WebKitGTK  https://hackage.haskell.org/package/jsaddle-dom-0.2.0.1 (HamishMackenzie)
11:24:38 <ski> shaleh : the main point with `expr ::= atomic | expr ("and"|"or") atomic' is to realize that every successful parse must begin with a parse of `atomic' and then perhaps continue on. so we can refactor it into `expr ::= atomic expr_cont' and `expr_cont ::= "" | ("and"|"or") atomic expr_cont'. this is what hexagoxel (and probably also hpc) meant
11:26:11 <shaleh> ski: right, I see the idea. I just need to work it into my thinking.
11:26:21 <hexagoxel> yes. and by using Parsec monad instance, you can write this in such a way that the datatype you return still can be ~ "data Expr = ExprTerm t | ExprBin op t1 t2"
11:26:46 <iphy> hpc: user error (Pattern match failure in do expression at utils/hpc/HpcCombine.hs:93:3-11)
11:26:58 <iphy> sounds like a bug..
11:27:12 <hexagoxel> shaleh: `parseExprCont t1` roughly does "if next input is binary operator b + another term t2, call parseExprCont (ExprBin b t1 t2); otherwise you are done and return ExprTerm t"
11:27:46 <hpc> iphy: hey, source code is people too you know
11:28:42 <shaleh> hexagoxel: right.
11:30:18 <ski> shaleh : btw, note that i decided to remove the ambiguity by left-associating, in `expr ::= atomic | expr ("and"|"or") atomic', if you prefer right-associating, you get `expr ::= atomic | atomic ("and"|"or") expr', which can be *directly* left-factored into `expr ::= atomic ("" | ("and"|"or") expr)' (which i now realize is what hpc was suggesting)
11:30:59 <ski> shaleh : if you want to keep the ambiguity (iow get all different ways of associating), that's also possible ..
11:32:17 <shaleh> do any of you know of a good example of this out there I can read to see working code?
11:37:55 * hackagebot system-info 0.1.0.0 - Get information about CPUs, memory, etc.  https://hackage.haskell.org/package/system-info-0.1.0.0 (dtaskoff)
11:39:10 <qinusty> One thing I've noticed while picking up Haskell is that the availability of learning resources is lacking in terms of example code. Type definitions on Hoogle are great if you are comfortable with the language but I've struggled to find example usages of specific functions etc
11:41:21 <shaleh> qinusty: agreed. Either lots of high level logic, crusty half attempts, or the worst/best is working examples written by serious geniuses that are so tuned as to not be understand by anyone who is below that level.
11:42:36 <bennofs> At least Haskell documentation gets better when you know haskell better, rather than not being enough when you know the language better (as I see it often happen with otgher languages: beginner docs being great, but doing anything slightly advanced is undocumented). But I agree that more examples in documentation is a good thing to have
11:42:55 * hackagebot steeloverseer 2.0 - A file watcher and development tool.  https://hackage.haskell.org/package/steeloverseer-2.0 (SchellScivally)
11:42:57 * hackagebot fasta 0.10.3.0 - A simple, mindless parser for fasta files.  https://hackage.haskell.org/package/fasta-0.10.3.0 (GregorySchwartz)
11:43:40 <shaleh> bennofs: true it is getting over the hump of "this compiles" to "I can see how to implement that without cursing"
11:44:27 <shaleh> what consistently makes me grumpy is I get 80% of a project working and then the last 20 is like looking straight up a wall
11:47:14 <bennofs> I'd say Haskell has good worst-case documentation (there's always at least type signatures to fall back on), but bad best-caase documentation compared to other languages
11:50:30 <codedmart> Can I go from `IO (Either Error User)` -> `IO (Maybe User)`? Is this just a eitherToMaybe type thing?
11:50:47 <codedmart> I tried a few things but am getting hung up/
11:51:14 <monochrom> yes, and add "fmap" for the IO.
11:51:45 <hpc> unsafeCoerce will do it in ghc :P
11:51:49 * hpc zoidbergs away
11:52:09 <monochrom> @quote monochrom unsafeCoerce
11:52:09 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
11:52:41 <hpc> ive been considering making an acme module that's just a bunch of useful things implemented as unsafeCoerce
11:52:55 * hackagebot hyperloglogplus 0.1.0.0 - Approximate cardinality estimation using constant space  https://hackage.haskell.org/package/hyperloglogplus-0.1.0.0 (ezhulenev)
11:55:15 <cocreature> hpc: acme-totallysafe
11:58:57 <codedmart> monochrom: fmap? unsafeCoerce sounds bad :)
11:59:26 <shaleh> yeah, ignore the unsafe coerce joking :-)
11:59:52 <monochrom> I don't know how to explain fmap, except to tell you to look it up.
12:00:21 <codedmart> No I know what it is. Was just reinterating that is what you were recommending.
12:02:21 <hpc> codedmart: oh yeah, the serious suggestion is find one of the existing functions for getting Maybe values from Either values, and fmap that function over the IO action
12:06:20 <jackhill> L/win 45
12:12:29 <hexagoxel> do there exist any useful abstractions when calculating the fixpoint of some (rule-based) transformation of a recursive data type?
12:14:14 <hexagoxel> rules like "x (Foo y) -> Foo (x y), for any unary-recursive constructor x"
12:17:02 <codedmart> OK so I have this and am getting the attached error -> https://gist.github.com/codedmart/ff54b0738f1fffb4da035e4f6950fee5#file-auth-hs-L6
12:18:30 <ski> hexagoxel : maybe something like SYB,Compos,Biplate,Multiplate ..
12:19:35 <hexagoxel> up to this point i was able to do a single traversal, i.e. reaching the fixpoint was trivial. but now there are rules for which this is trickier, like the rule above; because changes in children allow new rule applications in the parent.
12:22:19 <codedmart> What is the function I want if I end up with IO (IO a) but want IO a?
12:22:27 <hexagoxel> join
12:22:35 <codedmart> hexagoxel: Thanks!
12:22:56 * hackagebot wol 0.2 - Send a Wake on LAN Magic Packet  https://hackage.haskell.org/package/wol-0.2 (TomLokhorst)
12:23:43 <hexagoxel> (at least syb does not help with finding the fixpoint, though; or does it? i'll have a look at the *plates though.)
12:23:49 <hexagoxel> ski: thanks for pointers.
12:26:14 <ski> (perhaps it might be useful also to look at term rewriting system. like perhaps Maude. i don't know much about such)
12:27:13 <ski> codedmart : alternatively use another function instead of one of your previously used ones, in order to avoid arriving at `IO (IO a)' in the first place
12:31:17 <codedmart> ski: Yeah trying to think this through.
12:32:52 <ski> codedmart : .. hard to say anything more, without knowing more of the context/code
12:32:56 * hackagebot imperative-edsl 0.6 - Deep embedding of imperative programs with code generation  https://hackage.haskell.org/package/imperative-edsl-0.6 (EmilAxelsson)
12:35:15 <codedmart> ski: Right I understand. I think I am missing something from servant that I could be doing or going about it wrong. Checking with them.
13:00:54 <ajf> I came here to ask about how to solve a problem, and in the process of explaining it, ended up figuring out the straightforward solution…
13:01:04 <ajf> Accidental rubber-duck debugging!
13:01:16 * ski smiles
13:01:51 <reinh> ajf: you are welcome
13:01:55 <ajf> (Specifically: Where do I find a version of `read` that raises an exception? Easy answer: write one with readEither. :p)
13:03:35 <Cale> ajf: If you're specifically reading a line of text obtained by getLine, there is readLn though
13:03:59 <ajf> Cale: not in this case, but I'll bear that in mind
13:04:16 <ajf> er, I'll remember it, I mean
13:04:47 <Cale> read actually already throws an exception when it fails to parse, but that's as part of the evaluation of the expression rather than as part of the execution of an IO action, so the exception is fiddly to catch
13:05:24 <Cale> (and yeah, using something like readEither would be the right way)
13:06:00 <ajf> in my case I don't want an IO exception, but a Scotty exception
13:06:25 <ajf> and it seems scotty's thing to lift IO and convert exceptions, does not catch read's
13:07:48 <geekosaur> it's looking for IO exceptions, not the one thrown by read
13:07:58 <ajf> oh, right
13:08:09 <ajf> read throws a different kind of exception, I guess?
13:08:50 <geekosaur> I think it's ErrorCall instead of IOException
13:09:13 <mizu_no_oto_work> Scotty doesn't actually 'throw exceptions' any more than Either does, right?
13:10:11 <ajf> mizu_no_oto_work: hmm?
13:10:44 <mizu_no_oto_work> ajf: Either and exceptions are a bit different, right?
13:10:45 <ajf> I don't know if Scotty, itself, throws IO exceptions. I know it has its own exception thing within its monad
13:10:48 <ajf> mizu_no_oto_work: yes.
13:11:08 <ajf> I wrote something that did case Text.Read.readEither s of Left err    -> raise ...
13:11:39 <reinh> Surely there is a combinator somewhere for raising on Lefts
13:11:51 <ajf> Probably!
13:17:02 <amf> when you have a libraries monad transformer stack, but you want to build an app around that, with a transformer stack, can you stack those? as in newtype MyApp a = MyApp { runMyApp :: StateT MyAppOpts TheirStackWithAlreadyIncludesStateTAndIO }; or is there a better way to compose stacks?
13:17:40 <mizu_no_oto_work> ajf: Doing a bit of source diving, it looks like ActionT is a newtyped ExceptT
13:18:09 <amf> ultimately trying to use https://robots.thoughtbot.com/refactoring-to-a-monad-transformer-stack as a guideline to clean up my mess of passing arguments around
13:19:14 <Welkin> I thought ExceptT was deprecated in favor of EitherT
13:19:19 <Welkin> or was that ErrorT that was deprecated?
13:19:31 <reinh> Welkin: you have that backwards
13:19:35 <reinh> Except is the new Error
13:20:10 <Welkin> what about EitherT?
13:20:14 <reinh> amf: Yes, you can do that.
13:20:48 <reinh> amf: and you can use GeneralizedNewtypeDeriving to generate the mtl instances for you.
13:20:59 <reinh> EitherT was an attempt to fix ErrorT
13:21:08 <reinh> It was basically reimplemented as ExceptT
13:21:58 <amf> reinh: ahhh ok. so as long as i keep track of where in the stack i am i use the correct number of lifts, as in i will always start at the inner-most?
13:21:59 <geekosaur> ? I thought EitherT was just the transformer version of Either, and agnostic about what each side meant; ErrorT and ExceptT both make one side a non-normal return value, ExceptT being more general than ErrorT
13:22:05 <reinh> And this change then begat a large amount of bikeshedding.
13:23:07 <reinh> geekosaur: That's fair, but EitherT was documented as a replacement for ErrorT that didn't have the spurious constraint
13:23:10 <reinh> e.g., https://hackage.haskell.org/package/either-4.4.1.1/docs/Control-Monad-Trans-Either.html
13:23:40 <reinh> So it's a bit of both
13:25:11 <geekosaur> hm. I think that was because ErrorT was trying to be both, unsuccessfully
13:25:24 <reinh> and it has a MonadError instance
13:25:26 <geekosaur> (or at least was being abused as both...)
13:25:40 <reinh> geekosaur: arguably, ErrorT should always have been EitherT
13:25:51 <reinh> thus the bikeshedding ;)
13:26:37 <geekosaur> ...an d none of it helped by the fact that Monad kinda requires you to make one side "special"
13:26:48 <reinh> EitherT is still useful if you want to avoid the "this is for errors" connotations, I guess
13:26:59 <reinh> and EitherR is fun
13:27:58 <jle`> transformer's ErrorT is the original and had the constriant on 'e'; either's EitherT was a replacement without one, and transformers add ExceptT which is a straight port of EitherT
13:28:29 <reinh> jle`: yep, that's basically what I just said ;)
13:28:37 <reinh> jle`: also hai o/
13:29:02 <jle`> i think it was either andy or ross who was also against giving the "transformer versions" the same name as their non-transformer versions
13:29:06 <jle`> reinh: \o
13:29:07 <Welkin> I have never encountered exception handling in haskell yet
13:29:08 <reinh> amf: the (a?) goal of mtl is to use typeclasses to avoid lifting
13:29:20 <reinh> amf: so you can, e.g., use the MonadReader instance for ask without having to count your lifts
13:29:26 <jle`> i originally thought it was just ExceptT to avoid a namespace clash
13:29:34 <Welkin> besides the obvious head/tail example, where else would you need to handle exceptions?
13:29:35 <reinh> abstracting over the specific transformer stack structure, basically
13:29:50 <jle`> but apparently the maintainer(s) of transformers don't like the EitherT naming scheme
13:29:55 <reinh> Welkin: async exceptions are a big deal in concurrent stuff
13:30:04 <reinh> SimonM's book covers them well
13:30:13 <reinh> jle`: thus the bikeshedding :)
13:30:24 <jle`> hysterical
13:30:27 <jle`> raisins
13:30:54 <reinh> <california_raisins.jpg>
13:31:01 <Welkin> is that all?
13:31:04 <Welkin> where else?
13:31:16 <reinh> Welkin: non-async exceptions (i.e., everywhere else) ;)
13:31:19 <Welkin> beside trying to read user input into a value like Int
13:31:41 <reinh> things that do a lot of IO sometimes use exceptions, e.g., some http clients
13:32:26 <reinh> e.g., http://www.serpentine.com/wreq/tutorial.html and ctrl-f exception
13:33:53 <jle`> yeah, a lot of IO libraries use exceptions as a part of their main control flow
13:34:18 <jle`> this actually makes a lot of sense, given the nature of IO
13:35:58 <jle`> using error/exceptions like this for 'pure functions' like head/tail is actually kind of a ridiculous idea in comparison
13:37:22 <reinh> error is in a category of things that are technically exceptions but should almost never be treated as such
13:37:36 <reinh> i.e., if you're catching head [] then you're doing it wrong.
13:37:59 * hackagebot modify-fasta 0.8.2.0 - Modify fasta (and CLIP) files in several optional ways  https://hackage.haskell.org/package/modify-fasta-0.8.2.0 (GregorySchwartz)
13:51:56 <tesrty> If I have a list of numbers and want to reduce that to a list with just the highest and lowest number, would you use `fold`? Or is there some cleaner way?
13:52:40 <Welkin> nope
13:52:41 <maerwald> isnt that rather a tuple?
13:52:42 <Welkin> use a fold
13:52:45 <dysfun> you'd probably reduce it to a *tuple* instead
13:52:53 <tesrty> Right. Thanks guys.
13:52:55 <johnw> you could sort and take the first and last
13:53:08 <johnw> but underneath, it's a fold
13:53:22 <tesrty> I always argued a reduce in JavaScript should take a list of type A and return a single value of type A. But I realised thats not how fold works. It can of course be a list of type a and return of type b.
13:53:25 <Welkin> or you could use maximum and minimum
13:53:49 <tesrty> Yea, it's more about the 'does it make sense' part of how you would do this
13:55:06 <Welkin> maximum and minimum are implemented as fold
13:55:14 <Welkin> using folds
13:55:30 <tesrty> It feels weird because my example is a list of type A to a list of type A (although a tuple would make more sense). And a list of type A to a list of type A of the same length would just be a poor excuse for a map.
13:56:19 <johnw> not necessarily
13:56:25 <tesrty> So I got confused about when fold should be used over simple conditions + recursion (a loop basically) or a map
13:56:28 <johnw> a map can never juggle elements around, for example
13:56:31 <tesrty> okay, explain
13:56:33 <tesrty> right
13:56:55 <johnw> a map can only consider one cell in its own context, it's can't consider the rest of the list when computing its result
13:56:57 <tesrty> I had hoped the use case would be more clear haha
13:57:09 <tesrty> it leaves me a little lost as to when to reduce in JS
13:57:19 <johnw> a fold can compute using a "fold value"
13:57:35 <tesrty> hmhm
13:57:37 <tesrty> yea
13:57:41 <johnw> there are other things, like paramorphisms, that *can* refer to the entire list while computing each element
13:57:51 <tesrty> those I have never used..
13:57:53 <johnw> though there's not a handy one in Data.List, I don't think
13:58:11 <johnw> it's basically like map, but you get to look at the whole remainder of the list in your mapping function
13:59:34 <tesrty> okay
14:00:13 <tesrty> Thanks johnw 
14:00:16 <jle`> tesrty: notice that map always returns a list of the same length as the original, too
14:00:21 <tesrty> This does make some things more clear
14:00:24 <tesrty> hmhm
14:00:56 <tesrty> But as was just pointed out, the length doesn't help you in defining when to use fold instead, maybe the order changes.
14:00:59 <tesrty> Right?
14:01:08 <johnw> right
14:01:17 <cloudhead> tesrty: map can be implemented with fold, so you can think of fold as a more general map
14:02:33 <tesrty> Hmhm. I get that. It's just that when my fellow JS coders use a fold to find an element, I explain that confuses me as its unexpected use of fold (reduce really) when there's a find method. But then when trying to define when not to use fold I got stuck.
14:02:37 <cloudhead> maps have a one to one relationship between input and output, fold doesn't have that restriction
14:02:58 <jle`> tesrty: 'find' is really just a fold, too
14:02:59 * hackagebot ip 0.7 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.7 (andrewthad)
14:03:07 <cloudhead> ie map preserves the length of the input list in its output, fold doesn't have to
14:03:07 <tesrty> Damn, really?
14:03:10 <johnw> tesrty: Consider that pretty much any function that takes a full list as its argument can be implemented using fold
14:03:30 <jle`> tesrty: yeah, you can implement it yourself using fold, or you can use the implementaiton that someone else already wrote for you
14:03:35 <johnw> it has to do with how much freedom you have in picking the initial fold value, and the folding function
14:03:39 <tesrty> I understand you can, but if you write a fold and then don't even touch the accumulator 
14:03:40 <jle`> same for maximum, minimum, etc.
14:04:01 <cloudhead> `sum` also is a good fold example
14:04:51 <jle`> tesrty: the accumulator's final state is the "result", so the accumulatorwhen you implement find with fold is the thing you are trying to find
14:05:02 <jle`> (for a foldl)
14:06:41 <tesrty> Hmhm, I get that. It's just that in this practical case when someone used fold over find because they wanted to do some quick data conversion before returning the found element, that felt very wrong to me. Now I'm not so sure.
14:06:58 <jle`> using fold over find is just re-impelmenting find from scratch
14:06:59 <tesrty> Thanks for all the explaining guys!! I think this distinction is as clear as it'll get for me.
14:07:04 <jle`> there's no reason why you would do it in practice
14:07:19 <tesrty> I do have a much better idea of when to reduce now.
14:07:49 <jle`> a proper linter would have advised "use find" in that situation :p
14:07:56 <tesrty> Hmhm, in this case someone really wanted everything packed into one statement, so to get the data mapping in he used fold
14:08:29 <tesrty> well like I said, there was a quick `a -> b` before returning the found result in this use of fold as find. So a linter wouldn't ;]
14:08:32 <jle`> in haskell we'd use find with function composition :)  you get the same performance results because of lazy evaluation
14:08:41 <jle`> find f . map g
14:08:49 <tesrty> hmhm
14:08:50 <jle`> definitely more readble and maintainble than the fold written out
14:08:51 <tesrty> I miss haskell
14:09:01 <johnw>  and if you need to do any transformation on the result, you would just compose that functional in as well
14:09:02 <jle`> hm
14:09:27 <jle`> i was going to say "in javascript, that'd be bad, because map g would have to map the entire list, but in haskell, it would only map as far as you need to go to find the element"
14:09:29 <tesrty> that is actually what I wrote in js. wrote the map function then passed the result of find. Which isn't quite the same but trying to
14:09:34 <jle`> but i just noticed that find f . map g = find (f . g)
14:10:30 <johnw> jle`:  sound like a good rewrite rule to me :)
14:10:48 <tesrty> when I first realised how map does '.' my mind was absolutely blown
14:10:59 <tesrty> good times
14:14:40 <ski> tesrty : "how map does '.'" ?
14:16:05 <tesrty> (b -> c) -> (a -> b) -> a -> c
14:16:12 <tesrty> thats function composition right
14:16:27 * ski nods
14:16:50 <tesrty> lists are basically a map from one type to another. I give an index for example, a number, and maybe it gives me a string.
14:17:29 <tesrty> So image (b -> c) is a list, (a -> b) is a list.. and you get
14:17:41 <tesrty> basically another list! but now its a (a -> c) list!
14:18:03 <LKoen> are you talking lists of couples?
14:18:11 <LKoen> [(a, b)]
14:18:19 <tesrty> No
14:19:09 <mudd> But (b -> c) isn't a list?
14:19:37 <ski> tesrty : so you think of a list of type `[b]' as being roughly the same as a function of type `Int -> b', or what ?
14:19:38 <tesrty> It can be thought of as a list
14:19:45 <tesrty> Yes ski exactly
14:19:58 <mudd> tesrty: In what way?
14:20:01 <tesrty> I don't remember what the exact exercise was, maybe I can find my college book..
14:20:06 <ski> tesrty : which would give the type `(b -> c) -> [b] -> [c]' for "function composition"
14:20:21 <ski> or even `[c] -> [Int] -> [c]'
14:20:32 <ski> tesrty : is that what you had in mind ?
14:21:00 <jle`> if you had `type Array a = Int -> a`
14:21:18 <ski> (i suppose another variant would be `[c] -> (a -> Int) -> (a -> c)')
14:21:19 <jle`> then map :: (a -> b) -> Array a -> Array b
14:21:37 <jle`> er
14:21:41 <ski> @type find (?f . ?g)
14:21:42 <lambdabot> (Foldable t, ?f::b -> Bool, ?g::a -> b) => t a -> Maybe a
14:21:42 <jle`> (.) :: (a -> b) -> Array a -> Array b
14:21:47 <ski> @type find (?f . ?g) . ([] ++)
14:21:48 <lambdabot> (?f::b -> Bool, ?g::a -> b) => [a] -> Maybe a
14:21:52 <ski> @type find ?f . map ?g
14:21:53 <lambdabot> (?f::a -> Bool, ?g::a1 -> a) => [a1] -> Maybe a
14:22:28 <minn> Functions of type Int -> a are isomorphic to sequences. The standard representation of lists as functions is folds, though.
14:22:30 <ski> jle` : i suppose the latter is slightly more general
14:23:13 <ski> hmm
14:23:17 <jle`> yeah, i guess the two are actually different because 'find' would give you the result post-map
14:23:20 <jle`> for find f . map g
14:23:25 <jle`> but find (f . g) would give you the result pre-map
14:23:26 <ski> no, not more general
14:23:43 <jle`> s/i guess/i see that
14:23:51 <johnw> "give you the result pre-map"?
14:24:00 <ski> the former yields an original element of the list. the latter yields a transformed element
14:24:15 <jle`> > find (even . (+3)) [1..10]
14:24:17 <lambdabot>  Just 1
14:24:17 <ski> jle` * *nod*
14:24:29 <jle`> > find even . map (+3) $ [1..10]
14:24:30 <lambdabot>  Just 4
14:24:31 <johnw> if the result is the same, there's no reason to assume what the operational semantics would be; optimization might cause them to be the exact same thing
14:24:43 <jle`> the result is not the same :o
14:24:44 <johnw> oh, I see what you mean
14:24:48 <johnw> ok, fair enough
14:25:00 <mgsloan> Yeah, instead you're looking for something like (fmapMaybe f . fmap g === fmapMaybe (f . g))
14:26:05 <mgsloan> (Like fmapMaybe from reflex - https://hackage.haskell.org/package/reflex-0.4.0/docs/Reflex-Class.html#v:fmapMaybe)
14:26:58 <ski> @type mapMaybe
14:26:59 <lambdabot> (a -> Maybe b) -> [a] -> [b]
14:27:02 <ski> @free mapMaybe :: (a -> Maybe b) -> [a] -> [b]
14:27:02 <lambdabot> $map_Maybe g . h = k . f => $map g . mapMaybe h = mapMaybe k . $map f
14:27:15 <mgsloan> (though I guess that leaves out the part where you lazily only get the first item, heh)
14:28:51 <tesrty> '[23:20:10]  <ski>	tesrty : is that what you had in mind ?' Yes, it was. Absolutely loved finding it rewriting the signature for function composition myself a year back.
14:30:38 <ski> hm, setting `g',`h',`k',`f' here to `id',`f . g',`f',`g', that specializes to `$map_Maybe id . f . g = f . g => $map id . mapMaybe (f . g) = mapMaybe f . $map g', and `$map_Maybe id = id' (of type `Maybe c -> Maybe c'), `$map id = id', so we get `f . g = f . g => mapMaybe (f . g) = mapMaybe f . $map g'
14:30:58 <ski> and so `mapMaybe f . $map g = mapMaybe (f . g)' (cf. mgsloan)
14:31:57 <ski> tesrty : at some point, in lambdabot, the type for `(.)' was `Functor f => (a -> b) -> f a -> f b', so that you could write `(^ 2) . [0 .. 9]' instead of `map (^ 2) [0 .. 9]'
14:32:17 <tesrty> Hah, cool.
14:33:41 <ski> tesrty : similarly, `flip :: (a -> b -> c) -> (b -> a -> c)' was generalized to `flip :: Functor f => f (b -> c) -> (b -> f c)', allowing you to write e.g. :  [(2 +),(2 *),(2 ^)] `flip` 3
14:34:33 <ski> > [(2 +),(2 *),(2 ^)] `sequence` 3  -- another way to achieve this example
14:34:34 <lambdabot>  [5,6,8]
14:36:00 <tesrty> You've lost me there ski
14:36:14 <tesrty> But thanks for sharing the enthusiasm for Haskell! ;]
14:36:59 <tesrty> I really feel like trying implementing fmap for my Rose tree again (where I last had fun / frustration with haskell ^^)
14:37:02 <ski> yw
14:37:46 <ski> you'll probably need a recursive call involving both `fmap' and `map'
14:38:03 <ski> (one could also use a helper for the children)
14:38:07 <tesrty> Oh yes, and I couldn't find it for the life of me
14:38:17 <tesrty> But thanks for the tip ;]
14:44:45 <IceNine|Work> LO
15:02:46 <buglebudabey> hi milky, just wanted to let you know that i am still getting disconnected every 10-15 minutes+ of inactivity
15:02:54 <buglebudabey> wrong chat!
15:03:01 * hackagebot beam-th 0.2.0.0 - Template Haskell utilities for beam  https://hackage.haskell.org/package/beam-th-0.2.0.0 (hesiod)
15:03:03 * hackagebot aeson-compat 0.3.5.1 - Compatibility layer for aeson  https://hackage.haskell.org/package/aeson-compat-0.3.5.1 (phadej)
15:09:51 <codedmart> This seems redundant. Can I write this better? https://gist.github.com/codedmart/e374ab1c2daa69493c3e1d763d406776
15:10:14 <hwkng> is the *.lhs file from https://www.andres-loeh.de/LambdaPi/ available anywhere? the "Haskell Source Code" linked on the page isn't exactly readable
15:10:58 <buglebudabey> are there any good resources for database.persistent.posgresql other than the yesod book and hackage?
15:13:02 * hackagebot hjsonschema 0.10.0.3 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-0.10.0.3 (seagreen)
15:25:57 <pavonia> codedmart: You could probably lift your actions to MaybeT and use the Alternative instance for that
15:27:30 <codedmart> pavonia: OK I will try that thanks!
15:30:39 <hexagoxel> codedmart: (ab)use EitherT to get early-return on the Nothings. see comment on gist.
15:32:18 <khumba> Huh, is there no short name for "foldr (<|>) mzero" to fold such a list of Alternatives down?
15:32:28 <johnw> asum
15:32:50 <johnw> @src asum
15:32:50 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:33:02 <khumba> Ah, I didn't look in Data.Foldable.  Thanks!
15:36:42 <codedmart> hexagoxel: Interesting, thanks! What about the case where LoggedIn us returned
15:41:12 <hexagoxel> codedmart: edited again, sorry. not sure anymore if that is pretty, but it would scale for more cases :p
15:42:40 <nilof> If I have a function with several inputs, is there any nice way to partially apply it to parameters that aren't the first without using a lambda? Some generalization of Flip?
15:43:40 <johnw> if it's just one argument, yes
15:43:47 <johnw> but not for multiple
15:44:01 <johnw> for the case of one argument, just put `flip` in place of the missing argument
15:44:29 <johnw> the lens library defines this as (??) = flip
15:44:31 <johnw> very handy
15:46:34 <reinh> johnw: o/
15:47:11 <codedmart> hexagoxel: OK so know I am not sure I understand how that works.
15:48:33 <hexagoxel> codedmart: MaybeT probably is prettier, try that instead.
15:49:12 <codedmart> hexagoxel: OK I will I appreciate your help. Still curious to understand it so I will play with it more.
15:49:31 <johnw> reinh: Hi!  You lower-cased yourself.  Been reading e.e. cummings?
15:49:36 <reinh> Heh
15:52:41 <nilof> one thing I tend to use in handwritten notes for (\x y -> fun x y z) is fun _ _ z, maybe I'll try writing a parser for that using a non-english character on my keyboard like Å to make the task easier
15:53:11 <nilof> fun Å Å z which wraps the word immediately before the first Å should work
15:56:56 <hexagoxel> codedmart: not sure if you get notifications for new gist comments automatically, so: "ping!"
16:43:51 <edwardk> @let foldll f z zs = go (reverse zs) zs where { go _ [] = z; go ~(x:xs) (_:ys) = f (go xs ys) x }
16:43:52 <lambdabot>  Defined.
16:44:01 <edwardk> @let data Nat = Z | S Nat
16:44:02 <lambdabot>  Defined.
16:44:05 <edwardk> @undefine
16:44:06 <lambdabot> Undefined.
16:44:07 <edwardk> @let foldll f z zs = go (reverse zs) zs where { go _ [] = z; go ~(x:xs) (_:ys) = f (go xs ys) x }
16:44:08 <lambdabot>  Defined.
16:44:12 <edwardk> @let data Nat = Z | S Nat deriving Show
16:44:13 <lambdabot>  Defined.
16:44:32 <edwardk> > foldll (\r _ -> S r) Z [1..]
16:44:33 <lambdabot>  S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S (S...
16:44:51 <edwardk> > foldll (flip (:)) [] [1..3]
16:44:52 <lambdabot>  [3,2,1]
16:51:03 <dmwit> ?tell nilof https://www.reddit.com/r/haskell/comments/4fqoke/thoughts_on_using_as_syntactic_sugar_for/
16:51:03 <lambdabot> Consider it noted.
16:52:54 <dmwit> edwardk: eep
16:53:31 <dmwit> ?let reverse_ = foldll (flip (:)) []
16:53:33 <lambdabot>  Defined.
16:53:49 <dmwit> > () <$ reverse_ [1..]
16:53:50 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
16:53:51 <edwardk> dmwit: this is the 'lazier' reverse trick generalized a tiny bit
16:53:55 <dmwit> right
16:54:21 <dmwit> I never understood the "lazier reverse". But I understand this. And it makes me go "eep". =)
16:59:35 <mniip> dmwit, it can give you the spine before evaluating the end of the input list
17:00:15 <mniip> reverse_ (⊥:⊥) = ⊥:⊥
17:00:24 <mniip> whereas reverse (⊥:⊥) = ⊥
17:01:07 * dmwit nods agreeably
17:19:03 <mniip> hmm
17:19:16 <mniip> what should datatype declarations look like in my "dynamic haskell"
17:22:57 <mniip> considering that the only thing that matters is the names of the constructors and their arities
17:45:55 <buglebudabey> offtopic: anyone know a good mac irc channel i could join?
17:55:54 <Jinxit> hTensor has this typeclass: https://goo.gl/P6VlQD and I can't figure out how to write an instance
17:56:35 <Jinxit> Instance Coord MyType complains "No instance for (Num (Vector MyType))" arising from superclass
17:57:19 <alercah> write an instance of Num (Vector MyType)
17:57:27 <alercah> it's listed in the requirements of Coord
17:57:34 <athan> Anyone here mess with websockets at all? I can't seem to get a basic websocket webserver running with warp yet :\
17:57:48 <athan> or better put - it's behaving "funny"
17:58:48 <Jinxit> alercah: can I derive it? MyType has Num
17:59:02 <alercah> probably not
17:59:13 <alercah> but I don't know about Vector so
18:19:22 <buglebudabey> does anyone have a good nlp package to recommend
18:36:38 <codedmart> hexagoxel: Are you still around by chance?
19:11:43 <athan> Does C^c throw an exception in your process?
19:11:50 <johnw> yes, an async exception
19:11:50 <athan> er in an actively running process :x
19:11:55 <athan> thanks johnw :)
19:12:15 <athan> johnw: Do you happen to know _where_/
19:12:21 <johnw> specifically: UserInterrupt :: AsyncException
19:12:21 <athan> s/\/?
19:12:23 <athan> er
19:12:34 <johnw> it throws it in the main bound thread, I believe
19:12:48 <athan> johnw: Every forked thread too or something..?
19:12:51 <athan> hmm, okay
19:13:00 <johnw> I don't think
19:13:05 <johnw> easy to test, though
19:13:10 <athan> :x
19:13:15 <johnw> from the docs: "This exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism(s) (e.g. Control-C in the console)."
19:14:00 <athan> johnw: Hmm! Okay, great, thank you!
19:14:39 <athan> So it might be wise to try and catch this exception, and propogate it to forked threads etc, to close everything via `finally` before exiting?
19:15:19 <johnw> I didn't say other threads wouldn't receive an exception, though :)
19:15:27 <johnw> i believe the main thread will kill them all before exiting
19:15:51 <johnw> so as long as they have a handler for ThreadKilled or SomeException, or something like that, they should be able to do cleanup
19:16:04 <johnw> SIGINT is not like SIGKILL
19:16:28 <athan> hmm... looks like an adventure :) thanks johnw
19:16:33 <johnw> becaues the runtime "owns" them, and when it exits, it kills everything running
19:16:47 <johnw> I'll be there are libraries for abstracting this pattern
19:16:57 <johnw> of writing "exception safe" CLI utilities that handle C-c gracefully
19:17:02 <johnw> I'll bet*
19:17:12 <athan> I'm hoping so :x
19:17:37 <athan> I have a feeling bracket solves this somehow, or if there's some implicit bracket in main or something like that
19:19:10 <johnw> athan: http://zguide.zeromq.org/hs:interrupt
19:19:24 <Jinxit> has anyone tried to use a custom number type with hmatrix?
19:19:37 <johnw> because, after all, the process is not required to exit after C-c
19:20:27 <athan> johnw: hrm http://stackoverflow.com/questions/7115386/handling-userinterrupt-exception-in-haskell
19:22:35 <athan> thanks johnw, I don't think there's a lib for this yet though! Maybe it would be a nice shot at a poorly designed library heh
19:23:32 <johnw> sure!
19:23:37 <johnw> a cli-utils library would be nice
19:38:00 <mniip> well played, laziness
19:38:06 <mniip>  > print (evaluate (case@Unit Unit of Unit -> Unit))
19:38:06 <mniip>  evaluate# (case@Unit Unit of Unit -> Unit)
19:45:52 <athan> mniip: de donde evaluate?
19:46:32 <mniip> a primitive function that evaluates its argument to normal form
19:46:48 <mniip> hmm, that's just id...
19:46:55 <mniip> because it only does so when applied
19:47:32 <tgeeky> any of the category theory nerds in here recognize what these diagrams are? https://scontent.fewr1-1.fna.fbcdn.net/v/t1.0-9/10402985_10204445521075643_303831804770747701_n.jpg?oh=e9385c4f21c550d7686298b2141ea819&oe=57F10F60
19:47:40 <tgeeky> a "W-cell"
19:49:59 <mniip> athan, I'm implementing a functional language of sorts
19:50:51 <athan> mniip: :) aweshome
19:50:59 <mniip> "dynamic haskell", except, since I have a homemade parser, it is, of course, more syntacitcally weak
19:51:25 <athan> mniip: Wait, is evaluate a user-level function?
19:51:29 <mniip> no
19:51:33 <athan> ahh okay
19:51:43 <tgeeky> re: the above, I don't need to know the meaning of the diagram, only that it is category theoretical or not
19:52:08 <mniip> there are currently 2 types of functions, lambdas, and "foreign" functions invoking a function in the host language
19:55:03 <Habib> hey
19:55:33 <athan> mniip: Hmm! That sounds like a good method. I really want to apply this approach to type inference: https://www.youtube.com/watch?v=R5NMX8FBlWU
19:55:44 * athan is a mega-newb though ._.
19:55:56 <mniip> well
19:56:00 <mniip> this language is duck-typed
19:56:03 <mniip> of sorts
19:56:28 <athan> heh, nice. Have you messed with elm at all?
19:57:18 <mniip> athan, nonono
19:57:24 <mniip> I can actually go and say
19:57:29 <mniip> omega = \x -> x x
19:57:37 <athan> :O!
19:58:10 <athan> it's lazilly typed?
19:58:22 <lpaste> mniip pasted “omega id” at http://lpaste.net/169145
19:58:31 * athan guzzles the haterade
19:58:43 <mniip> it's uh
19:58:46 <mniip> dynamically typed
19:59:10 <athan> :O that's awesome though
19:59:30 <mniip> implementing support for typeclasses right now
19:59:42 <mniip> well, in the parser. It's already implemented in the runtime
20:03:22 <Habib> Does anyone know what the default include paths for GHC are? I can't seem to find this information anywhere? Level one context: I'm trying to use hs-plugins to dynamically load Haskell code, and I've got it working to a degree. It works with very basic functions (well, only some functions), but anything more complex (even if I'm only using Prelude functions) fails with something like http://lpaste.net/4056555207587266560. At first, I thought it was anything that
20:03:22 <Habib> referenced IO or similarly complex things, but it seems to break down even before that.
20:03:57 <Habib> Has anyone here used hs-plugins?
20:11:11 <nitrix> Does haskell has a `maximumN` function?
20:11:21 <nitrix> Where n are the `n` largest numbers?
20:11:47 <Koterpillar> take n . sort
20:12:05 <Koterpillar> not sure if lazy enough
20:12:20 <nitrix> Isn't that a little expensive? Maybe the lazyness of the sort is enough?
20:12:55 <mniip> if you use a merge/pivot sort you can benefit from laziness there
20:13:21 <nitrix> mniip: Does `sort` from Data.List qualifies?
20:13:34 <mniip> not sure
20:14:39 <nitrix> mniip: Apparently it's a mergesort.
20:14:51 <nitrix> But more efficient.
20:15:17 <mudd> If it matters if it's O(n lg n) or O(n lg m), you should probably not rely on sort being implemented in just the right magic way I wouldn't think.
20:28:35 <seagreen> Is using microlens-th OK in a library, or should I write out lens functions by hand? I'm worried about compilation times.
20:29:50 <nitrix> seagreen: Do you have really complicated lenses?
20:30:21 <nitrix> They're fairly easy to write for records that aren't nested too nested.
20:30:31 <nitrix> *deep
20:32:05 <tieTYT> about 3 years ago I tried haskell and wanted to make a hobby project: A website crawler that collected all the images.  I develop on windows/cygwin and found it challenging to install libraries.  Actually, I couldn't get past this problem.  I was trying to install a high level http library.  Am I still going to experience this?  Should I only attempt to use haskell on linux?
20:32:39 <nitrix> tieTYT: The tooling has evolved.
20:32:59 <Adeon> yeah there is `stack` now which might help
20:33:03 <mudd> tieTYT: It's gotten better I believe. Windows is still not as polished as linux from what I can tell, but you'll likely have better luck.
20:33:08 <mudd> Yeah, 'stack' would be what I'd try.
20:33:20 <tieTYT> there's a library called `stack`?
20:33:28 <Adeon> it's a tool
20:33:31 <Adeon> kind of similar to cabal-install
20:33:43 <nitrix> Adeon: stack would be an alternative to 'cabal-install' that you might be familiar with.
20:33:44 <mudd> tieTYT: It's a build tool. It's a replacement for cabal-install that does more and in a more friendly way.
20:34:01 <tieTYT> ok cool, I'll give it another shot
20:34:29 <nitrix> tieTYT: Don't fear to ask if you hit a problem; it'd be a shame to dismiss Haskell so quickly again ;)
20:34:51 <tieTYT> actually I struggled for 3 days and was actively getting help from people here :P
20:35:21 <tieTYT> but thanks, I always found this channel to be very helpful
20:35:25 <mudd> Yeah it can be pretty frustrating.
20:35:27 <nitrix> tieTYT: https://github.com/nitrix/pstash/blob/master/src/Main.hs
20:35:38 <nitrix> tieTYT: For the information, that was one of my ealiest project, it's a tumblr crawler.
20:35:50 <nitrix> It's running perfectly fine on windows (:
20:36:04 <tieTYT> nice, thanks
20:36:17 <tieTYT> bbl
20:47:03 <sleblanc> will stackage provide GHC 8.x support anytime soon?
20:47:27 <mudd> sleblanc: nightly is already using GHC 8. Though I don't know how generally usable it is, I haven't tried it myself.
20:48:39 <sleblanc> hm, nightly is a bit too "bleeding edge" for me
20:52:43 <kadoban> sleblanc: Fair enough, but GHC 8 itself is pretty bleeding edge for general usage I think too, if you depend on many libraries at least. I wouldn't think it'd be too long until there's a LTS, but I haven't really been following closely (and don't have any inside information in the slightest)
21:02:04 <seagreen> nitrix: They're very simple, but one of my record types is kind of big (two dozen lines).
21:02:23 <seagreen> If I end up writing them by hand at least it will be good vim practice!
21:03:57 <nitrix> seagreen: fieldLens = lens _fieldName (\s x -> s { _fieldName = x })
21:04:25 <nitrix> fieldLens :: Lens' RecordType FieldType
21:05:15 <nitrix> seagreen: If your needs aren't that crazy, I think it's very do-able. The `lens` function need a getter and a setter. The getter is typically just the field name and the setter as simple as record update syntax.
21:06:26 <seagreen> nitrix: So you think the tradeoff of having a bigger codebase is worth the faster compilation speed?
21:07:18 <nitrix> I was writing my lenses manually for my game until GHC 8, because there was a TH bug on windows.
21:07:43 <seagreen> nitrix: Ouch!
21:08:07 <seagreen> Though maybe your point is it wasn't that big of a deal.
21:08:29 <nitrix> It got a little repetitive and annoying at times when doing large refactoring, but didn't make the code better or worse.
21:09:04 <nitrix> Myeap. On the other hand, how much compilation time are you going to shave off not using microlens-th, I couldn't tell.
21:09:51 <cobreadmonster> > putStr "Hello world!"
21:09:53 <lambdabot>  <IO ()>
21:10:01 <cobreadmonster> That's interesting.
21:10:24 <nitrix> cobreadmonster: lambdabot only evaluates IO, the effects aren't executed.
21:10:56 <seagreen> nitrix: Thanks for the thoughts!
21:11:02 <cobreadmonster> nitrix: Hmm, albeit that amounts to nothing more than a type check.
21:11:29 <nitrix> cobreadmonster: Is it a question? You can use :t for that :)
21:11:49 <nitrix> :t putStr "Hello World!"
21:11:50 <lambdabot> IO ()
21:12:48 <pavonia> What does evaluating IO even mean?
21:13:34 <Koterpillar> pavonia: it evaluates expressions, that happen to have IO in the type
21:15:07 <nitrix> > return (5 + 2) >>= putStrLn . show
21:15:09 <lambdabot>  <IO ()>
21:15:29 <cobreadmonster> :t pure fix pure
21:15:30 <lambdabot>     No instance for (Applicative f0) arising from a use of ‘pure’
21:15:31 <lambdabot>     The type variable ‘f0’ is ambiguous
21:15:31 <lambdabot>     Note: there are several potential instances:
21:15:43 <cobreadmonster> Can someone tell me how to relax this constraint?
21:16:59 <nitrix> pavonia: As you can see, the `IO Integer` is still passed monadically to putStrLn . show and gives a result of type IO (), evaluation happens.
21:17:27 <nitrix> pavonia: You simply wont see the effects carried out by putStrLn of actually outputing a string to stdout (or IRC)
21:17:53 <pavonia> > sequence [putStr "foo", putStr "bar", error "blah"]
21:17:55 <lambdabot>  <IO [()]>
21:18:06 <nitrix> They aren't hidden, nor discarded, they simply don't exists. lambdabot uses pure-io as far as I know.
21:18:39 <nitrix> (Or a similar variant)
21:19:31 <pavonia> So is it usung the original IO but with some GHC hacks to avoid the execution, or a complete replacement of the IO type?
21:21:47 <nitrix> pavonia: https://hackage.haskell.org/package/pure-io-0.2.1
21:21:59 <nitrix> pavonia: I'm not a 100% certain though. You'd have to check lambdabot's code.
21:22:40 <nitrix> pavonia: The engine is https://hackage.haskell.org/package/mueval
21:23:38 <pavonia> That first package looks interesting
21:25:35 <pavonia> If it were using this, it could actually print some output
21:27:02 <nitrix> pavonia: My knowledge doesn't extend beyond that it uses mueval and that the effects aren't carried out, unfortunately.
21:27:28 <nitrix> I've tried to work on lambdabot before but setting up all the cabal dependencies showed to be very painful.
21:29:39 <nshepperd> evaluating IO doesn't do anything
21:29:57 <nshepperd> it's just a data constructor
21:30:42 <nshepperd> ghci has special code to execute IO values you type in
21:30:54 <cobreadmonster> Okay, my ghc implementation is fucked.
21:30:58 <cobreadmonster> This is really annoying.
21:31:43 <nitrix> cobreadmonster: Let's hope the GHC devs don't read that.
21:32:05 <cobreadmonster> nitrix: No, like this has to do with a local install.
21:32:13 <cobreadmonster> I built from source, then upgraded Fedora.
21:32:22 <cobreadmonster> Now I have no clue what's going on.
21:32:41 <cobreadmonster> `/usr/local/lib/ghc-7.10.1/bin/ghc: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory` is an error I get.
21:32:55 <Koterpillar> ooh
21:32:59 <sleblanc> kadoban, re: GHC 8 being bleeding edge, I agree; that's what I get for running a rolling release distro (Arch)
21:33:08 <nitrix> cobreadmonster: Simply install libtinfo.
21:33:22 <Koterpillar> nitrix: no, latest libtinfo is .so.6
21:33:33 <nitrix> The older one.
21:33:35 <Koterpillar> cobreadmonster: install ncurses-compat or ncurses-5 or tinfo-compat
21:33:41 <cobreadmonster> Ah.
21:33:54 <nitrix> https://github.com/commercialhaskell/stack/issues/1012
21:33:56 <kadoban> sleblanc: I just let stack manage my GHC versions, personally. Though it's kind of funny to have to do it for that reason in particular (usually the OSes I use have an old as hell GHC in the package manager)
21:34:09 <nitrix> The issue has been raised a couple times. It's worrying.
21:34:09 <Koterpillar> ncurses5-compat-libs in Arch
21:34:24 <Koterpillar> kadoban: this is the corner case, see linked Stack issue
21:34:58 <Koterpillar> the issue _resurfaced_ for me because my system ghc upgraded to 8...
21:35:02 <kadoban> Koterpillar: I think I'm on a different thread of conversation, unless I didn't notice they're related.
21:35:17 <sleblanc> kadoban, stack on my machine was acting up (same problem as cobreadmonster) so I figured it might have something to do with the update to GHC 8
21:35:25 <kadoban> Ah
21:35:27 <cobreadmonster> sleblanc: Oh.
21:35:29 <cobreadmonster> Now I got it.
21:35:30 <Koterpillar> kadoban: turns out they are related!
21:35:36 <kadoban> Haha, apparently.
21:35:38 <cobreadmonster> Fedora 24 broke ncurses.
21:35:44 <Koterpillar> no one broke ncurses
21:35:57 <cobreadmonster> Well, it broke ncurses5 libs.
21:35:58 <Koterpillar> GHC is built against .so.5, that's it
21:36:11 <nitrix> Isn't GHC 8 using .so.6 ?
21:36:30 <Koterpillar> no idea; 7.10 distributed by Stack isn't
21:36:30 <cobreadmonster> Koterpillar: the package on fedora is called ncurses-compat-libs
21:36:39 <Koterpillar> cobreadmonster: good to know, thanks
21:37:16 <nitrix> Basically, the problem should vanish as projects stops using older GHC which needs the older libtinfo.
21:38:13 <nitrix> Eventually stack will also get a lts snaptop for GHC 8, right now it's only the nightlies :/
21:39:12 <sleblanc> also, "cabal list" barfs out the following: "cabal: ghc-pkg dump failed"
21:39:25 <Rotaerk> cabal is constipated?
21:39:35 <Koterpillar> sleblanc: is ghc-pkg also broken with the same error?
21:43:14 * hackagebot PortMidi 0.1.5.3 - A binding for PortMedia/PortMidi  https://hackage.haskell.org/package/PortMidi-0.1.5.3 (PaulLiu)
21:43:32 <sleblanc> Koterpillar, false alarm; it occurs only when I run it in a sandbox
21:44:40 <sleblanc> well, I mean, a sandbox from a previous version of cabal and GHC
22:31:38 <kadoban> I keep getting this error trying to build haskell-src-exts. Anyone recognize it, or have an idea what to do about it? :-/ http://lpaste.net/2766996804586176512
22:51:19 <inerkick> Hi when I try to update cabal, I'm getting this error "cabal: Command.optionToFieldDescr: feature not implemented
22:51:19 <inerkick> " Why is that. Kindly help
22:51:41 <inerkick> and grep jobs .cabal/config results in jobs: $ncpus
22:53:13 <codebje> inerkick, try using stack, it helps avoid pain with cabal versions
22:53:31 <inerkick> ok. Thank you codebje 
22:53:50 <codebje> kadoban: I suspect the build of happy went wrong, try "stack install happy" and see if it rebuilds, if not I'd personally blow away the lts-6.6 snapshots and build clean
22:54:01 <codebje> (or at least blow away the happy one, but if that's broken others might be too)
22:54:56 <kadoban> codebje: Hmm okay, I'll give that a try
22:55:14 <glguy> Inerkick: you can try moving your .cabal/config out of the way to see if it's just an invalid option value
22:55:15 <Koterpillar> how do I remove unused stack snapshots to free up disk space?
22:55:29 <glguy> Switching to stack would be a pretty drastic response
22:55:54 <inerkick> ok, I was installing VSCode to check how it works. And it started to show GHC-mod errors. 
22:56:11 <glguy> You delete them with rm. You can't delete individual snapshots because they interlink
22:56:48 <inerkick> how to get a clean install than, glguy 
22:56:50 <inerkick> please help
22:57:14 <glguy> The config file is ~/
22:57:27 <glguy> .cabal/config
22:57:41 <glguy> So try moving it and getting a default config
22:57:55 <Koterpillar> glguy: thanks, I'm guessing garbage collecting isn't implemented?
22:58:11 <glguy> Not that I'm aware of
22:58:46 <Koterpillar> oh, I can remove ghc-7.10.2 at least
23:05:48 <inerkick> how to completely remove haskell glguy 
23:06:36 <glguy> That completely depends on how you installed whatever you installed
23:06:48 <Koterpillar> ...from planet Earth?
23:07:19 <dysfun> inerkick: set fire to your computer? that ought to do it
23:07:28 <inerkick> :D
23:07:58 <dysfun> i hear rutabaga farming is a lot less stressful than programming
23:08:20 <thimoteus> funny, i hear the opposite from the rutabaga farmers
23:08:30 <dysfun> how many rutabaga farmers do you know?
23:08:41 <thimoteus> between 0 and infinitely many
23:08:45 <thimoteus> inclusive, of course
23:09:07 <dysfun> i know one person who gave up a programming career to go farming
23:09:13 <dysfun> he is very happy with that choice
23:09:22 <thimoteus> good for him!
23:12:22 <sleblanc> given that "show" is of type Show a => a -> String, how can applying Nothing to show pass typecheck, given that Show a => Show (Maybe a) ?
23:12:45 <Koterpillar> :t show Nothing
23:12:46 <lambdabot> String
23:13:04 <Cale> sleblanc: Defaulting
23:13:16 <Cale> sleblanc: (Extended default rules)
23:13:33 <Axman6> it'll be defaulting to Show (Maybe ())
23:13:35 <Cale> sleblanc: The ambiguity gets resolved by plugging in ()
23:14:14 <sleblanc> ok! is this specific to Show?
23:15:11 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#type-defaulting-in-ghci
23:15:14 <sleblanc> > show (Nothing :: _)
23:15:15 <lambdabot>      Found hole ‘_’ with type: Maybe ()
23:15:15 <lambdabot>      To use the inferred type, enable PartialTypeSignatures
23:15:15 <lambdabot>      In an expression type signature: _
23:15:24 <Axman6> it's specific to GHCi I think (possibly to Haskell, the language does define some defaulting rules, like number literals default to Integer if nothing else can be inferred)
23:16:12 <benzrf> uh... does it mean "with value"?
23:16:17 <benzrf> the hole has /type/ *
23:16:44 <Cale> Well, the hole *is* a type
23:16:53 <benzrf> yeah
23:17:03 <benzrf> so it doesn't have type "Maybe ()"
23:17:07 <benzrf> that's not the type of a type
23:17:17 <sleblanc> benzrf, the "value" of a type would quickly get confusing, IMO
23:17:32 <benzrf> ok tur
23:17:34 <benzrf> *tru
23:17:36 <Cale> Perhaps it should be  Found hole ‘_’ for type: Maybe ()
23:17:45 <sleblanc> "of type"
23:17:59 <Cale> Well, that again sounds like you're specifying the type of the hole
23:18:09 <Cale> which you're not, you're specifying the type which goes in the hole
23:19:20 <sleblanc> > show _
23:19:21 <lambdabot>      Found hole ‘_’ with type: ()
23:19:21 <lambdabot>      In the first argument of ‘show’, namely ‘_’
23:19:21 <lambdabot>      In the expression: show _
23:19:50 <contiver> Can anybody recommend any Haskell cli tool for me to take a look at the source code? I want to know how people deal with program flags. Do you usually pass a data type with all the options around?
23:20:28 <dysfun> huh?
23:20:29 <Cale> contiver: Usually what I do is click the source links in the haddock documentation on the right side of the page
23:20:40 <benzrf> contiver: perhaps using Reader?
23:20:47 <sleblanc> contiver, have you seen this? https://wiki.haskell.org/GetOpt
23:20:56 <Cale> You might not have the source code of an installed package on your computer after all.
23:21:09 <dysfun> ohh, i getcha
23:21:15 <dysfun> try CmdArgs, it's pretty easy
23:21:25 <dysfun> lemme find an example
23:21:41 <Cale> I like optparse-applicative
23:21:46 <contiver> I'm using optsparse-applicative, but I need to enable/disable certain data type transformations based on these flags.
23:22:44 <sleblanc> There is this, too: https://github.com/Gabriel439/Haskell-Optparse-Generic-Library/
23:22:46 <Cale> So yeah, you usually end up with some data type representing the result of parsing the commandline flags, and use values of that type to configure the remainder of your program
23:22:53 <contiver> Most of the options are things I can't (or don't know how I would) deal with them at the "main" level, since I have these data types inside other data types and need to kind of propagate the options...
23:23:45 <inerkick> Hi, glguy . I uninstalled Haskell. How to install Haskell in a way, I can configure it
23:24:19 <Axman6> contiver: I've been using configuration-tools in our webservices, it has some nice features, like being able to use a config file or command line args for any setting, it also allows you to specify a url for the config file, really useful in cloud deployments
23:24:24 <Cale> contiver: Start with plain parameter passing, and maybe refining the type so that you don't pass the whole structure along to things that are only concerned with some part of it
23:24:30 <dysfun> inerkick: what do you mean configure it?
23:24:56 <inerkick> I mean, I don't have to end up multiple installs 
23:25:01 <Axman6> IIRC, configuration-tools is based on optparse-applicative
23:25:08 <inerkick> I had 3 to 4 ghc's earlier dysfun 
23:25:13 <Koterpillar> install it once. do not install it again.
23:25:18 <inerkick> ok
23:25:24 <dysfun> what os are you on?
23:25:29 <Axman6> inerkick: stack is the easiest way to work with that
23:25:30 <inerkick> Ubuntu 14.04
23:25:34 <Axman6> it handles installing GHC for you
23:25:36 <dysfun> then just install stack
23:25:48 <inerkick> so should I use  sudo apt-get install haskell-platform or through it's software center.
23:25:58 <Axman6> you don't need to worry about which GHC version, because it will install and select the correct version for your package
23:26:00 <dysfun> no, i can't recommend HP
23:26:02 <inerkick> since I guess I installed through software center
23:26:03 <Koterpillar> can you apt-get install stack or haskell-stack?
23:26:21 <dysfun> http://docs.haskellstack.org/en/stable/install_and_upgrade/#ubuntu
23:26:31 <inerkick> I haven't installed stack yet.
23:26:38 <daniel-s> With regards Maybe, if something is "Just a" does that mean that there is a value and Just is just a container for it, so that it can be of the Maybe type?
23:26:48 <inerkick> yeah. I was seeing that dysfun 
23:26:55 <daniel-s> Otherwise I was confused why Just is used instead of returning a alone.
23:27:10 <inerkick> so do we need to install stack first and than haskell? 
23:27:11 <benzrf> daniel-s: approximately
23:27:24 <Cale> daniel-s: Yeah, if you didn't apply Just, then it would simply be of whatever type a it was, and not Maybe a
23:27:33 <dysfun> inerkick: my recommendation is only install stack and use that to get isolation for your projects
23:27:50 <dysfun> inerkick: it will quite happily install ghc as required
23:27:51 <benzrf> daniel-s: the terminology you're using is sort of indicative of a subtly wrong way of thinking about it, but the best way to fix that is just to write a bunch of haskell
23:27:57 <inerkick> ok, so  sudo apt-get install haskell-platform is just a separate thing, and stack just acts like on top of the installation , is it?
23:28:00 <benzrf> daniel-s: for now, that sounds like a good enough approximation
23:28:14 <dysfun> no, haskell platform is an entirely different thing
23:28:14 <inerkick> or stack installs ghc?
23:28:17 <contiver> Cale: that's what I was doing. But I started noticing I had to repeat code, and when I tried abstracting, I ended up trying to declare a function in a typeclass. The idea was for each data type to just define which flag they cared about (basically using the function GHC generates with record syntax), and then the default function implementation would handle it all. The problem is that, since this function doesn't mention the kind 
23:28:17 <contiver> varible of the class, ghc complains (since it has type Args -> Bool).
23:28:23 <daniel-s> Cool, thanks benzrf/Cale.
23:28:27 <inerkick> yeah. I was bit confused when started to check with Stack
23:28:32 <dysfun> stack is a build tool. it will install a ghc for each project
23:28:41 <dysfun> it keeps projects isolated to avoid dependency problems
23:28:44 <inerkick> Yeah, I can see it builds the project
23:28:56 <dysfun> i.e. only install stack
23:29:10 <inerkick> so I should now install haskell as usual  sudo apt-get install haskell-platform and than install stack and use it for projects , right?
23:29:25 <dysfun> no, you should ignore haskell-platform and install stack
23:29:42 <sleblanc> daniel-s, so "Just" is a constructor; this allows using pattern matches, which are a nifty piece of syntax
23:30:11 <dysfun> haskell platform is not the easiest route any more
23:30:24 <inerkick> ok
23:30:41 <Cale> I dunno, is stack really all that convenient for things which are not structured projects?
23:30:51 <inerkick> so stack automatically installs Haskell for me based on my platform and keeps the projects which I work on separately . Is that what it does?
23:30:54 <Cale> I haven't really had the chance to use it
23:31:00 <dysfun> stack is terribly convenient if you're a haskell newb
23:31:19 <dysfun> it's not quite so good for libraries you want to put on hackage, granted
23:31:31 <sleblanc> daniel-s, anywhere a piece of code wants a "Maybe a" value, it has to expect two possible cases: Just a, and Nothing. You cannot have a value of type "Just a", only "Maybe a"
23:31:37 <inerkick> Ok . I was just tinkering with coding with normal  sudo apt-get install haskell-platform installed earlier. So now it seems so confusing how to reconfigure. Hence got everything mixed up
23:32:11 <dysfun> okay, well remove haskell-platform if it's still installed. and ghc if you've managed to separately install that too
23:32:13 <benzrf> sleblanc: i think daniel-s was just using `a' as a value-level expression
23:32:17 <inerkick> so in a way stack does what cabal does?
23:32:25 <inerkick> i don't have haskell now. I removed it
23:32:44 <dysfun> stack uses cabal under the hood, but provides project isolation and stable package sets so you don't have dependency problems
23:33:13 <inerkick> ok, ok.. Quite interesting and new thing.. Nice to know
23:33:28 <inerkick> so I will follow how that stack install for my ubuntu 14.04 
23:33:31 <dysfun> you write a small stack.yaml telling it which stackage ("stable hackage") release to pulls deps from
23:33:40 <dysfun> and it will also build a project-specific sandbox
23:33:55 <dysfun> and it does clever sharing things so you don't needlessly recompile things
23:34:03 <inerkick> ok
23:34:58 <Cale> inerkick: One thing you'll probably find is that it's best to stay away from your linux distribution's packages for Haskell-related stuff, at least once you start caring that they're not horribly out of date.
23:35:38 <dysfun> yeah, linux distros are on average terrible at keeping haskell up to date
23:35:43 <inerkick> Agree. I mean I got so many things in my distribution packages. I am so worried where is going where.
23:36:00 <dysfun> well stack means you won't have to worry about it. it's good like that :)
23:36:01 <milesrout> they are however on average excellent at keeping themselves, which is what their goal actually is
23:36:10 <milesrout> keeping themselves stable*
23:36:34 <dysfun> let's not have that conversation. i've been through 4 linux installs in the last month
23:36:49 <milesrout> dysfun: then you did something wrong. don’t do things wrong.
23:36:49 <benzrf> i use nix~
23:36:53 <benzrf> its fun
23:36:57 * dysfun is currently using nix
23:37:21 <milesrout> i hope you enjoy reinstalling every package every time a security update is released for glibc lel
23:38:07 <dysfun> i am tempted to try freebsd again, but last time, this sata controller wasn't having any
23:39:01 <inerkick> i did so far till "sudo apt-get update && sudo apt-get install stack -y" for my ubuntu 14.04 . But I can't get stack yet. Any issues?
23:39:25 <dysfun> did you add the repo as per the instructions?
23:39:30 <inerkick> yes
23:39:40 <Koterpillar> so what happens after that command?
23:39:57 <inerkick> nothing. 
23:40:02 <inerkick> I can't use stack command yet
23:40:13 <dysfun> what did the output tell you?
23:40:16 <Koterpillar> paste the output of "sudo apt-get install stack -y"
23:41:30 <inerkick> Unable to locate package stack
23:41:31 <inerkick>  it says
23:41:45 <Koterpillar> add the repo
23:41:52 <dysfun> and what did apt-get update say? do you see it fetching from the fpco repo?
23:42:13 <inerkick> wget -qO- https://get.haskellstack.org/ | sh ? 
23:42:41 <inerkick> echo 'deb http://download.fpcomplete.com/ubuntu trusty main'|sudo tee /etc/apt/sources.list.d/fpco.list this I did
23:42:51 <dysfun> yes, that
23:42:55 <inerkick> yeah I did that
23:43:03 <dysfun> now do you see that repo url in your sudo apt-get update output?
23:43:36 <johnw> btw, there's #haskell-stack, if that helps
23:43:54 <dysfun> i suspect at this point it's more for #ubuntu heh
23:44:00 <inerkick> no Id idn't see it. 
23:44:17 <inerkick> weird 
23:44:28 <Koterpillar> inerkick: paste the output of: "cat /etc/apt/sources.list.d/fpco.list"
23:44:36 <dysfun> then it didn't work. does /etc/apt/source/list.d/fpco.list contain 'deb http://download.fpcomplete.com/ubuntu trusty" ?
23:44:39 <milesrout> anyone here installed lhs2TeX on a mac?
23:44:46 <milesrout> (using cabal)
23:45:02 <milesrout> it doesn’t seem to have added any binaries starting with lhs to my $PATH...
23:45:34 <dysfun> milesrout: does your path have the cabal bin dir on it?
23:45:37 <inerkick> output is "deb http://download.fpcomplete.com/ubuntu trusty main
23:45:38 <inerkick>  Koterpillar 
23:45:56 <Koterpillar> paste the output of "sudo apt-get update"
23:46:06 <dysfun> run it again and paste the output ;)
23:47:01 <dysfun> to a pastebin, it'll be long
23:47:39 <milesrout> dysfun: nope
23:47:48 <lpaste> shell pasted “shell” at http://lpaste.net/169149
23:47:50 <milesrout> can I get it from cabal?
23:47:56 <techieAgnostic> Noob question, when I'm mapping "read", where do I place the type thing (::Integer) ?
23:47:59 <dysfun> milesrout: that would explain. see if it's in ~/.local/bin
23:48:08 <inerkick> dysfun, Koterpillar  http://lpaste.net/169149
23:48:22 <milesrout> dysfun: hmm no such thing..
23:48:47 <milesrout> time for find
23:49:05 <dysfun> milesrout: ~/.cabal ?
23:49:06 <Koterpillar> did you miss step 1?
23:49:14 <inerkick> no
23:49:19 <milesrout> aha yep
23:49:38 <dysfun> Koterpillar: see line 18, it's aware
23:49:43 <inerkick> this one right Koterpillar sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 575159689BEFB442
23:49:56 <milesrout> dysfun: should $PATH changes go in ~/.bashrc or ~/.bash_profile?
23:50:05 <inerkick> yeah i can see that
23:50:26 <dysfun> milesrout: probably the former
23:50:32 <glguy> Looks like a 32 bit Ubuntu install
23:50:35 <dysfun> milesrout: the difference is profile is only run for login shells
23:50:41 <Koterpillar> glguy: spot on
23:50:49 <milesrout> ah ok, yeah should be in rc, ~/.bash_profile sources .bashrc
23:50:56 <inerkick> oops
23:51:13 <milesrout> thanks m8
23:51:24 <dysfun> inerkick: okay, the first line of the ubuntu section has your answer then
23:51:35 <dysfun> glguy: good spot :)
23:51:40 <inerkick> so you mean I should check 32bit one
23:51:47 <glguy> Maybe stack can sandbox you a 64-bit Ubuntu 
23:51:48 <inerkick> http://docs.haskellstack.org/en/stable/install_and_upgrade/#linux this one right
23:51:52 <dysfun> well, you have a 32 bit OS
23:52:00 <dysfun> yes
23:52:04 <inerkick> SHit. I got 64 bit and I Was in same mind
23:52:12 <inerkick> yeah my os is 32 bit
23:52:17 <dysfun> have you thought of getting a 64bit OS?
23:52:25 <inerkick> superb
23:52:28 <milesrout> echo 'export PATH=$PATH:~/.cabal/bin/' >> ~/.bashrc
23:52:29 <milesrout> oops
23:52:34 <milesrout> sorry
23:52:41 <inerkick> I got 2GB ram so I was told it isn't good
23:52:41 <dysfun> no
23:52:47 <dysfun> milesrout: add it to the FRONT
23:52:59 <inerkick> for 64bit RAM
23:53:05 <dysfun> oh right
23:53:05 <milesrout> tfw mistakes pay off
23:53:24 <dysfun> the main limitation with 32bit is a memory limit of 3-4GB
23:53:26 <milesrout> dysfun: surely I don’t want some cabal package adding a malicious chmod for example
23:53:30 <dysfun> obviously that's not a thing for you
23:53:54 <milesrout> dysfun: but all the pointers will waste his memory! /
23:53:54 <inerkick> so as it says in the link .should I download Linux 32-bit, standard or something
23:53:59 <milesrout> (sarcasm)
23:54:12 <inerkick> :D
23:54:30 <dysfun> milesrout: that's a theoretical possibility, sure, but this way isn't drama free either ;)
23:54:31 <glguy> No need to be sarcastic, that's actually relevant
23:55:02 <dysfun> inerkick: yes, get 32bit linux version
23:55:08 <inerkick> ok
23:55:23 <dysfun> you're the first person i've seen using 32 bit linux for a while heh
23:56:00 <inerkick> :-D thanks. I started using computer when all were using 500MB to 1Gb and I had 128MB :(
23:56:05 * Koterpillar is using 32 bit but not i386
23:56:43 <dysfun> inerkick: i complain about my hardware, but it's still better than what you have
23:57:03 <dysfun> haskell compiles take way too long heh
23:57:13 <inerkick> So I got this file downloaded now, stack-1.1.2-linux-i386.tar.gz
23:57:52 <inerkick> and I need to extract it
23:57:53 <dysfun> tar zxvf stack-*.gz
23:58:09 <Koterpillar> [just tar xf will do]
23:58:50 <dysfun> heh, i just realised the reason i tip it all the extra flags is because FreeBSD. except that now freebsd's tar is far more capable than gnu's!
23:59:13 <inerkick> done
23:59:24 <inerkick> you use FreeBSD?
23:59:39 <dysfun> i was using freebsd as a desktop until about a month ago
23:59:39 <inerkick> I fiddle with Linux and you are killing it :D
