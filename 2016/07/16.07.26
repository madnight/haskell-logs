00:00:12 <Cale> Yeah, the adjunction view is nice when you have enough limits to make a functor out of them
00:00:53 <shachaf> Sure, if you don't have all limits of a particular shape then it's not so nice.
00:01:04 <Guest8290> can anyone tell me why this produces a parse error? I pretty much copied this part from another (working) program: http://lpaste.net/171907
00:01:23 <mniip> why is CT so... intertwined
00:01:43 <Cale> Guest8290: The indentation is all screwy
00:01:56 <shachaf> Guest8290: You're mixing tabs and spaces.
00:01:59 <Cale> I think in particular, the p in program <-
00:02:14 <Cale> oh, right
00:02:18 <Cale> don't do that!
00:02:31 <Cale> Configure your text editor to expand tabs to spaces for you
00:02:42 <Cale> Because how many spaces actually matters in Haskell.
00:03:06 <Cale> So it's not a good idea to have different people's editors displaying them differently
00:03:44 <Cale> (If you aren't going to do that, tab stops should be every 8 spaces, because that's how the compiler will see them)
00:04:08 <Guest8290> that's a weird way of haskell telling me... I'm actually trying to follow the identation rules but they just don't make sense to me sometimes.
00:05:08 <Guest8290> anyway. Thanks! 
00:05:18 <mniip> Guest8290, well in newer versions it actually says
00:05:25 <mniip>  warning: [-Wtabs] Tab character found here, and in 41 further locations. Please use spaces instead.
00:05:37 <shachaf> It does? Hm.
00:05:41 <mniip> yes
00:05:51 <mniip> and in some intermediate version it did a warning for every single tab
00:06:19 <Cale> Guest8290: It's really hard to follow any indentation rules if you're mixing tabs and spaces in the file
00:07:48 <shachaf> How does the adjunction work for equalizers, anyway?
00:18:24 * hackagebot random-strings 0.1.1.0 - Generate random strings with specific qualities  https://hackage.haskell.org/package/random-strings-0.1.1.0 (mikehat)
01:01:06 <Guest2789> I... just don't get it. All I'm trying to do is: "if the program receives an argument, use it as filepath for the parser, if not just do nothing". It can't be that hard... but I'm starting to become desperate http://lpaste.net/171915
01:03:23 <ertes> Guest2789: what's 'it' on the first line?
01:03:37 <ertes> and what's the context?  is that the main action?
01:04:03 <Guest2789> ertes: that's part of the hspec. I tried to condense it, but I can provide the full file. One moment.
01:04:12 <ertes> ah, ok
01:04:24 <ertes> Guest2789: getArgs :: IO [String]
01:04:31 <ertes> Guest2789: so what's the type of 'args'?
01:04:47 <Guest2789> http://lpaste.net/171916
01:05:03 <Guest2789> I'd assume it is IO [String] as well
01:05:07 <ertes> Guest2789: nope
01:05:16 <Guest2789> is it reduced to [String]?
01:05:35 <ertes> Guest2789: let 'action' be of type 'IO A', then if you write "x <- action" in a do-block, then 'x' is of type A
01:05:53 <ertes> Guest2789: the "<-" gives the result of an action a name
01:06:15 <Guest2789> I see. Then args should be [String]
01:06:22 <ertes> correct
01:06:30 <ertes> now, if you would pattern-match on 'args', you would match on the list of arguments
01:07:52 <Guest2789> But since I'm doing "args !! 0" I'm matching on a single String, isn't that right?
01:08:03 <ertes> that's right, and that string may not even be there
01:08:07 <ertes> note that (!!) is an unsafe function
01:08:13 <ertes> what you should do is match on 'args' instead
01:08:19 <ertes> (and not use (!!) at all)
01:09:45 <Guest2789> Oh. I thought this maybe-check would be the idiom to check whether a list contains at least one element
01:10:03 <ertes> :t (!!)
01:10:05 <lambdabot> [a] -> Int -> a
01:10:10 <ertes> no Maybe there unfortunately
01:10:14 <ertes> > [1,2,3] !! 5
01:10:17 <lambdabot>  *Exception: Prelude.!!: index too large
01:10:19 <ertes> it just crashes
01:10:55 <ertes> the way to handle this is to pattern-match on args (there are better ways, but let's ignore that for now)
01:11:59 <Guest2789> can I match on (x:_) even if I'm not sure whether there is at least one element?
01:12:31 <ertes> why don't you just match against the empty list as well?  since you want to handle that case by not doing anything
01:12:56 <ertes> note that 'return ()' is the IO action that does nothing…  and that's exactly what you want to do, if you get no arguments =)
01:13:08 <Guest2789> good point
01:14:35 <Guest2789> ah, that works great. Thank you!
01:14:47 <ertes> you're welcome
01:15:02 <ertes> take a look at this function, too (the "better way" i mentioned):
01:15:05 <ertes> :t mapM_
01:15:06 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
01:15:17 <Guest2789> I've been coming here for three days now and I really have to commend this channel for responsiveness and helpfulness. So kudos to all yall
01:15:21 <Guest2789> will look into it
01:15:28 <ertes> note that [] is a Foldable
01:16:16 <ertes> so you can read "t a" as [a] in this particular case
01:17:04 <ertes> and of course IO is a Monad, so you can read m = IO
01:17:21 <Guest2789> I see. Will try to implement that as an exercise later
01:18:29 <Cynede> I've got hakyll problem: mapping values are not allowed in this context
01:29:32 <pavonia> Cynede: For what input?
01:42:00 <pollz> Hallo! I was trying to install profunctors-5.2 and encountered an ExitFailure 255. Anyone knows what might be the issue? Everytime I try to install the package ghci.exe crashes. I am on Windows 10.
01:44:40 <telmich> how can I find out which instance a data type implements (instances)? I.e. if i want to check which instances for Maybe exist?
01:45:19 <liste> telmich: :browse in ghci
01:45:19 <ertesx> telmich: you can see all instances in scope by using :i(nfo)
01:45:24 <liste> :info *
01:46:44 <pavonia> pollz: Do you mean ghc.exe crashes?
01:46:58 <pollz> Yes sorry. 
01:47:10 <pollz> It crashes and gives an ExitFailure of 255. 
01:47:21 <pollz> Before it gave some arbitrary large -ve number for ExitFailure.
01:47:31 <pollz> Does this look like I need to reinstall ghc?
01:47:48 <pavonia> What version are you using?
01:48:04 <pollz> 8.0.1
01:48:43 <pollz> I basically wanted to install Control.Lens.
01:48:51 <pollz> and it had this as the dependency.
01:49:35 <pavonia> Hhm, hard to tell
01:50:00 <pollz> I also have stack enabled. Will installing it via stack give the same effect as that of cabal?
01:50:08 <telmich> liste, ertesx: thank you!
01:51:10 <telmich> :info Maybe was exactly what I was looking for
01:53:27 * hackagebot idris 0.12.1 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.12.1 (EdwinBrady)
01:56:29 <Cynede> pavonia, https://github.com/jaspervdj/hakyll/issues/455
01:58:08 <pollz> Okay guys. I am going to reinstall Haskell on my Windows machine. What should I do to get the most stably operating setup?
01:58:14 <pavonia> Cynede: The error clearly states to put these charcters in quotes
01:58:17 <pollz> I want to do this for the last time in my life.
02:03:10 <black0range> Hey! Are there any way to print the results of a template haskell operation in ghci? 
02:03:21 <Cynede> pavonia, yes but
02:03:27 <merijn> black0range: The actual results, or, like the resulting Haskell?
02:03:36 <Cynede> pavonia, check simple https://jaspervdj.be/hakyll/
02:03:59 <Cynede> pavonia, there is title: Home and I wonder whether I should use quotes over there
02:04:00 <black0range> marijn: No the Exp structure :)
02:05:13 <merijn> black0range: You can probably get it by using runQ with some finnagling
02:05:22 <merijn> λ runQ [| 2 + 2 |]
02:05:22 <merijn> InfixE (Just (LitE (IntegerL 2))) (VarE GHC.Num.+) (Just (LitE (IntegerL 2)))
02:06:27 <black0range> merijn: thanks that worked great! 
02:08:37 <Macmod> Hey
02:09:56 <Macmod> What happens if I type-annotate an Integer to Int and it holds a value higher than the upper bound?
02:10:22 <liste> > 12365613671396719613961869876918671967196719861396719617691376139671867196719671967319673167196713671361379861796174517598151 :: Int
02:10:24 <pavonia> Cynede: So what is yout input file?
02:10:25 <lambdabot>  -2430917989150394425
02:10:41 <merijn> Macmod: Overflow
02:11:06 <merijn> Macmod: Incidentally, you can't annotate an Integer with Int, that's a type error
02:11:14 <merijn> > (1 :: Integer) :: Int
02:11:15 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Integer’
02:11:15 <lambdabot>      In the expression: (1 :: Integer) :: Int
02:11:55 <Macmod> > (fromIntegral (1 :: Integer)) :: Int
02:11:56 <lambdabot>  1
02:12:04 <Macmod> What happens here?
02:12:11 <merijn> Macmod: fromIntegral is an explicit conversion function
02:12:19 <merijn> :t fromIntegral
02:12:21 <lambdabot> (Integral a, Num b) => a -> b
02:13:47 <Macmod> > (fromIntegral (Overflow598151 :: Integer)) :: Int
02:13:48 <lambdabot>  Not in scope: data constructor ‘Overflow598151’
02:13:56 <Macmod> Where's that?
02:14:30 <merijn> Where is what?
02:14:51 <Macmod> Overflow598151
02:15:01 <merijn> I have no idea where you pulled that from
02:15:11 <Macmod> You said that
02:15:33 * Macmod is seeing things
02:15:46 <merijn> Yes, you are :)
02:31:11 <Cynede> pavonia error points : after title so it's basically any input file of such format
02:31:37 <Cynede> pavonia oh sorry :)
02:32:02 <Cynede> pavonia I've got yet another : in title, thanks for pointing obvious thing out :)
02:40:49 <Myrl-saki> man.
02:41:04 <Myrl-saki> haskell's kinda weird if you need mutation. '_'
02:41:54 <eklavya> Myrl-saki: how?
02:42:25 <Myrl-saki> eklavya: specifically if you're working with databases and you require trees.
02:42:53 <eklavya> Myrl-saki: you need mutable trees?
02:43:06 <Myrl-saki> eklavya: yeah. kinda. at least in what i'm doing.
02:43:26 <eklavya> crazy idea, rust it up and FFI :D
02:44:08 <Myrl-saki> eklavya: lol. :p
02:44:17 <eklavya> Myrl-saki: If you have time, please elaborate what you are doing, I would like to learn from it :P
02:44:49 <Myrl-saki> eklavya: the haskell way is to make a type with a self reference.
02:45:18 <Myrl-saki> eklavya: the database way would be to make a type with an id reference to its parent
02:45:31 <Myrl-saki> at least currently.
02:45:45 <eklavya> so two way pointers?
02:46:41 <Myrl-saki> eklavya: in my case, just one way.
02:46:47 <Myrl-saki> anyways, i may be wrong.
02:47:08 <eklavya> I understood it like you need a reference to parent from children
02:47:21 <eklavya> too
02:47:22 <Myrl-saki> eklavya: yeah, i understand what you mean. i just ommited that though.
02:48:02 <Myrl-saki> like. i have a feeling that persistent actually makes new objects for each children but there's no 'sane' way to access the children.
02:48:07 <Myrl-saki> actually, wait...
02:48:13 <Myrl-saki> hmmm
02:48:23 <Myrl-saki> maybe i can do [entity children]
02:48:25 <Myrl-saki> err
02:48:28 <Myrl-saki> [Entity t]
02:48:42 <Myrl-saki> i... i think that will work.
02:48:48 <eklavya> ok, I was in whole other land :D
02:49:13 <eklavya> I thought you were writing a database and some algorithm needed two way pointers in a tree :D
02:49:26 <Myrl-saki> eklavya: i'm just newly working with databases, so i probably am making a lot of mistakes.
02:49:34 <Myrl-saki> eklavya: ahaha~ :p
02:49:45 <Myrl-saki> eklavya: databases are not my forte so i don't really work with them.
02:50:03 <eklavya> ok
02:50:10 <eklavya> to me they are magical beasts
02:50:15 <eklavya> which I have no idea about
02:50:44 <Myrl-saki> eklavya: not just you. 'w'
02:50:55 <eklavya> :)
02:56:26 <mniip> hmm
02:56:36 <pollz> I cannot import or install Control.Lens. Need some help here guys.
02:56:42 <pollz> I have installed lens-4.14
02:56:47 <pollz> I am on GHC 8.0.1
03:03:06 <sdx23> pollz: you should rather put the code and error message into a pastebin
03:04:13 <pollz> lpaste is down
03:04:14 <pollz> ?
03:04:47 <pollz> sdx23: There is no code per se. Prelude> import Control.Lens
03:05:18 <pollz> output : Failed to load interface for "Control.Lens" perhaps you meant Control.Seq
03:13:03 <pollz> It's done.
03:13:06 <pollz> No Worries.
03:19:34 <mniip> alercah, you were right
03:19:44 <mniip> this stuff is much easier to express with dependent types
03:20:08 <mniip> maybe I should try to express it on the type level using dependent kinding?
03:44:14 <mniip> :I
03:44:30 <mniip> just as I thought I was able to express the abstract nonsense in haskell
03:44:31 <mniip> ghc panics
04:03:31 * hackagebot homplexity 0.4.3.4 - Haskell code quality tool  https://hackage.haskell.org/package/homplexity-0.4.3.4 (MichalGajda)
04:19:39 <mniip> \o/
04:19:41 <mniip> it works
04:20:25 <prohobo> why is this so hard to learn
04:21:08 <merijn> prohobo: What is? :)
04:21:18 <prohobo> this stupid language
04:21:53 <prohobo> lisp dialects are way simpler
04:22:15 <merijn> Because lisp dialects are all basically the same
04:22:16 <prohobo> haskell does some really weird things, and it's quite confusing
04:22:24 <merijn> So if you know one you already know the rest
04:22:59 <merijn> I could say the same for learning lisp if I only knew OCaml, Haskell, Clean, or other haskell-like languages :)
04:23:10 <merijn> Learning new stuff is hard :)
04:23:12 <prohobo> no way
04:23:35 <prohobo> haskell has a complex way of combining everything
04:23:49 <prohobo> lisp is just func(func(func(func(func(...
04:23:54 <mniip> you're only combining simple things though
04:24:00 <koz_> prohobo: Haskell is certainly different, but I wouldn't ssay it's confusing.
04:24:02 <mniip> also
04:24:16 <koz_> It actually has a very nice core idea behind everything, and once you grok that, it all makes sense.
04:24:18 <merijn> In what way does haskell have a complex way of combining things? Haskell only has function application and pattern mathcing
04:24:32 <mniip> I just constructed products as a limit of a diagram with no morphisms
04:24:34 <mniip> :D
04:24:38 <prohobo> and list comprehension
04:24:50 <merijn> prohobo: You don't have to use those
04:24:53 <mniip>  > projectK PairTag (Proxy :: Proxy SndK) (123, 456)
04:24:53 <mniip> 456
04:24:55 <koz_> In fact, I never do.
04:24:57 <mniip>  > decomposeK PairTag (FancyProduct 123 456) :: (Int, Int)
04:24:57 <mniip> (123,456)
04:25:01 <merijn> And tbh, I can't remember the last time I did use a list comprehension
04:25:03 <Macmod> Is there a take :: Integer -> [a] -> [a] ?
04:25:16 <prohobo> folding?
04:25:21 <prohobo> do u guys even fold
04:25:24 <mniip> :t genericTake
04:25:26 <lambdabot> Integral i => i -> [a] -> [a]
04:25:29 <koz_> prohobo: foldl or foldr?
04:25:29 <mniip> Macmod, ^
04:25:48 <Macmod> Thanks :)
04:25:54 <prohobo> koz_: either
04:26:01 <koz_> prohobo: We do plenty of both.
04:26:16 <koz_> Although foldr is probably the first thing we reach for, due to its nice behaviour on lazy infinite things.
04:26:19 <kuznero> Hi All
04:27:57 <prohobo> i cant figure out how to fold with anything except the most basic functions like ++
04:28:36 <rom1504> then you need to learn functional programming
04:28:42 <zomg> prohobo: it's probably a good idea to start by understanding what the type signature means
04:28:53 <zomg> that should help you understand what kind of a function you need to fold
04:29:23 <prohobo> those get confusing aswell :P
04:29:25 <prohobo> alright
04:29:28 <prohobo> time to reread that
04:29:55 <mniip> aww, shachaf went
04:30:15 <MasseR> prohobo: on the other side of the fence, I have trouble reducing on lisp-side, because I can never remember whether the accumulator fun is acc x or x acc :)
04:30:24 <MasseR> Which on the other hand is obvious in haskell
04:30:26 <MasseR> :t foldr
04:30:28 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
04:30:47 <zomg> MasseR: lol I always have that same problem in JS too :P have to look up the order every time
04:31:39 <koz_> Yeah - that's my biggest pet peeve with dynalangs.
04:31:40 <MasseR> zomg: the thing is, the order isn't easily seen. Not all libraries document it
04:31:52 <zomg> nice :P
04:31:58 <ertesx> prohobo: look at the definition of foldr once a day
04:32:14 <ertesx> prohobo: you'll start to recognise the pattern when you see it
04:32:26 <ertesx> :t foldr (\x r -> print x >> r) (pure ())
04:32:27 <lambdabot> (Show a, Foldable t) => t a -> IO ()
04:32:28 <koz_> In general, reading the types is a good way to learn deep secrets.
04:33:06 <ertesx> in the case of foldr the *definition* is what you should focus on, because it captures a certain pattern
04:33:20 <MasseR> @src foldr
04:33:20 <lambdabot> foldr f z []     = z
04:33:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:33:23 <ertesx> almost the same with foldl', although that one is not as interesting
04:33:54 <m0rphism> Can someone with a Haskell wiki account help me to fix https://wiki.haskell.org/GHC.Generics ?
04:34:53 <m0rphism> In Section 1.3 the comments are out of order: sums, products, constants, and meta-informations are tagged to the wrong instances.
04:36:59 <prohobo> haskell is cool
04:37:08 <prohobo> i wonder if ill ever use it
04:38:38 <ertesx> > pizza time
04:38:41 <lambdabot>  Pizza Time
04:39:21 <liste> > time
04:39:23 <lambdabot>  Time
04:40:13 <koz_> > cola time
04:40:14 <lambdabot>  Not in scope: ‘cola’
04:40:17 <koz_> :(
04:40:26 <koz_> Why the hell is 'pizza' defined as a function?
04:40:35 <merijn> koz_: Someone @define'd it
04:40:45 <hpc> > cake
04:40:47 <lambdabot>      Not in scope: ‘cake’
04:40:47 <lambdabot>      Perhaps you meant one of these:
04:40:47 <lambdabot>        ‘take’ (imported from Data.List),
04:40:53 <hpc> noooooooooooo
04:40:55 <koz_> :t pizza
04:40:57 <lambdabot> a -> Pizza a
04:41:24 <koz_> :info Pizza
04:41:40 <mniip> :t time
04:41:41 <lambdabot> Time
04:41:49 <Macmod> :info Pizza
04:41:51 <koz_> :i Pizza
04:42:02 <Macmod> :help
04:42:03 <koz_> Fucking hell, I just wanna know wtf a Pizza is...
04:42:15 <koz_> My guess is that it's just a polymorphic box.
04:42:30 <hpc> @src Pizza
04:42:30 <lambdabot> Source not found.
04:42:51 <Macmod> > :t (pizza 9)
04:42:52 <hpc> feature request: @let adds to @src as well
04:42:53 <lambdabot>  <hint>:1:1: parse error on input ‘:’
04:42:59 <Macmod> :t (pizza 9)
04:43:01 <lambdabot> Num a => Pizza a
04:43:25 <mniip> hpc, that's very hard to implement
04:43:47 <koz_> > fmap (\x -> x + 1) (pizza 10)
04:43:49 <lambdabot>  Pizza 11
04:43:56 <koz_> OK, so Pizzas are functors, apparently.
04:44:06 <hpc> but are they burritos?
04:44:09 <koz_> > pure :: Pizza Int
04:44:10 <mniip> > :t undefined :: p (Rep Pizza)
04:44:11 <lambdabot>      Couldn't match expected type ‘Pizza Int’
04:44:11 <lambdabot>                  with actual type ‘a0 -> f0 a0’
04:44:11 <lambdabot>      Probable cause: ‘pure’ is applied to too few arguments
04:44:12 <lambdabot>  <hint>:1:1: parse error on input ‘:’
04:44:13 <mniip> :t undefined :: p (Rep Pizza)
04:44:15 <lambdabot>     Expecting one more argument to ‘Pizza’
04:44:15 <lambdabot>     The first argument of ‘Rep’ should have kind ‘*’,
04:44:15 <lambdabot>       but ‘Pizza’ has kind ‘* -> *’
04:44:25 <mniip> :t undefined :: p (Rep (Pizza ()))
04:44:27 <lambdabot> p (Rep (Pizza ()))
04:44:49 <mniip> @let deriving instance Generic a => Generic (Pizza a)
04:44:51 <lambdabot>  Defined.
04:44:53 <mniip> :t undefined :: p (Rep (Pizza ()))
04:44:54 <lambdabot> p (D1 L.D1Pizza (C1 L.C1_0Pizza (S1 NoSelector (Rec0 ()))))
04:44:55 <Myrl-saki> does anyone here know about how persistent implements nested types?
04:44:58 <prohobo> data Pizza = Pizza Slice Slice Slice Slice Slice Slice Slice Slice | Slice Ormagord Cheese
04:45:10 <hpc> haha
04:45:11 <Macmod> :t Slice
04:45:12 <lambdabot> Not in scope: data constructor ‘Slice’
04:45:13 <mniip> data Pizza a = Pizza a deriving (...)
04:45:47 <koz_> > (+) <$> (pure 4) <*> (pure 5) :: Pizza Int
04:45:50 <lambdabot>  Pizza 9
04:45:56 <koz_> OK, Pizza is also an Applicative.
04:46:00 <ertesx> > pure tuna <*> Pizza Margherita
04:46:03 <lambdabot>  Pizza Tonno
04:46:06 <hpc> @let deriving instance Generic a => Generic (IO a)
04:46:08 <lambdabot>  .L.hs:266:1:
04:46:08 <lambdabot>      Can't make a derived instance of ‘Generic (IO a)’:
04:46:08 <lambdabot>        The data constructors of ‘IO’ are not all in scope
04:46:21 <hpc> :D
04:46:25 <mniip> :t Margherita
04:46:27 <lambdabot> Margherita
04:46:37 <mniip> @let deriving instance Generic Margherita
04:46:40 <lambdabot>  Defined.
04:46:46 <mniip> :t undefined :: p (Rep Margherita)
04:46:47 <lambdabot> p (D1 L.D1Margherita (C1 L.C1_0Margherita U1))
04:47:01 <mniip> data Margherita = Margherita
04:47:20 <koz_> Now, how best to check if pizza is a Monad...
04:47:31 <koz_> s/pizza/Pizza
04:47:35 <ertesx> it's not…  i just needed Applicative for pizza tonno
04:47:58 <koz_> ertesx: Ah, OK, so this is your doing. :P
04:48:01 <mniip> > Dict :: Dict (Monad Pizza)
04:48:03 <lambdabot>  Not in scope: data constructor ‘Dict’Not in scope: type constructor or class...
04:48:03 <tdammers> > fail "" :: Pizza Int
04:48:05 <lambdabot>      No instance for (Monad Pizza) arising from a use of ‘fail’
04:48:05 <lambdabot>      In the expression: fail "" :: Pizza Int
04:48:08 <koz_> Pizza ought to have a Monoid instance.
04:48:18 <ertesx> @let instance Monad Pizza where Pizza x >>= f = f x
04:48:21 <lambdabot>  Defined.
04:48:23 <ertesx> now it is
04:48:26 <tdammers> > fail "" :: Pizza Int
04:48:28 <lambdabot>  *Exception:
04:48:44 <prohobo> let Pizza = Life in ThisWorld
04:48:49 <mniip> @let data Dict d = d => Dict deriving Show
04:48:51 <lambdabot>  .L.hs:272:22:
04:48:51 <lambdabot>      Can't make a derived instance of ‘Show (Dict d)’:
04:48:51 <lambdabot>        Constructor ‘Dict’ has existentials or constraints in its type
04:48:56 <mniip> damn
04:49:00 <ertesx> ok…
04:49:02 <ertesx> @undef
04:49:03 <lambdabot> Undefined.
04:49:05 <ertesx> back to work ;)
04:50:37 <mniip> oh
04:50:42 <mniip> I should have used Generic1
05:07:17 <prohobo> that was quite the pizzageddon
05:13:47 <Guest7829> Does megaparsec feature anything like a noop-parser? I'm currently parsing an expression. After that I will "try" to parse an infix operator followed by another expression (binOpRHS). Should this fail I can assume that it is in fact no binary operation but a single expression. But when binOpRHS fails it will fail the whole parsing. I'd instead like something like "try binOpRHS <|> noop". Is there a built-in function or do I have to 
05:15:13 <mniip> what would said noop parser do
05:16:07 <peddie> Guest7829: "many"?
05:18:09 <tdammers> Guest7829: there's option and optional
05:18:16 <tdammers> also optionMaybe or sth like that
05:18:48 <Guest7829> peddie: ah, wouldn't have looked there! I'm more looking for something like zero or exactly onc.... tdammers to the rescue. Thanks to both of you
05:19:00 <peddie> oh right, of course, sorry
05:19:46 <merijn> Guest7829: Relevant to your example: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
05:21:11 <Guest7829> merijn: I'm aware and I'm trying to keep backtracking to a minimum. Thanks for the input anyway
05:21:15 <mniip> should I try to avoid RankNTypes in favor of GADT or vice versa?
05:22:54 <merijn> mniip: RankNTypes is certainly better founded then GADTs
05:23:04 <mniip> well consider
05:23:11 <merijn> mniip: GADTs implicitly also has ExistentialQuantification which is more dubious than RankN
05:23:32 <mniip> data BoolSing (b :: Bool) where TrueSing :: BoolSing True; FalseSing :: BoolSing False
05:23:44 <mniip> class KnownBool (b :: Bool) where boolSing :: BoolSing b
05:23:47 <mniip> versus
05:23:50 <MasseR> *Sing is something I need to learn one of these days
05:23:53 <merijn> mniip: I think RankN has a good chance of getting into the new Haskell Prime, GADTs almost certainly isn't :)
05:24:15 <mniip> class KnownBool (b :: Bool) where observeBool :: p b -> ((b ~ False) => r) -> ((b ~ True) => r) -> r
05:25:20 <merijn> mniip: I have no strong opinion :)
05:25:29 <mniip> I just wrote some stuff
05:25:32 <mniip> and it feels weird
05:25:37 <mniip> compared to singletons stuff
05:25:54 <mniip> also I crashed ghc in process but that's another story
05:26:24 <merijn> Like I said, RankN is on more solid theoretical ground than GADTs, other than that you're on your own with this decision :p
05:28:34 <mniip> hmm
05:28:47 <mniip> is there a name for the... uh
05:29:15 <mniip> whenever you have a universal construction you say that if another object satisfying this exists, there is a morphism between the two and the diagram commutes
05:29:23 <mniip> does that morphism have a name
05:35:02 <lpaste> pollz pasted “Print At Each Iteration” at http://lpaste.net/171939
05:35:14 <pollz> I have asked the question in the pastebin. Please refer.
05:36:11 <liste> pollz: you know >> ?
05:36:29 <pollz> Yes the operator called "then"
05:36:40 <pollz> I saw a monad tutorial never used them in my life, pardon.
05:37:03 <tdammers> ignore monad tutorials
05:37:09 <liste> it's equivalent to (a part of) do notation
05:37:16 <liste> you've used do?
05:37:24 <pollz> yeah. and the desugared edition
05:37:26 <pollz> with >>=
05:37:31 <pollz> yes I get it.
05:37:49 <tdammers> >> is just >>= but ignoring the output of the LHS, and taking something on the RHS that doesn't take an argument
05:37:52 <pollz> So, um, I output the function to IO ()?
05:37:57 <pollz> With >>?
05:38:00 <tdammers> no
05:38:07 <tdammers> >> takes two actions and combines them into one
05:38:09 <liste> then you can probably place a "printGrid grid size >>" on line 3
05:38:27 <tdammers> "sequences" them, if you will, although that intuition breaks with some monad instances
05:38:32 <tdammers> for IO it holds though
05:38:49 <pollz> liste: can you elaborate
05:38:55 <ertesx> mniip: RankNTypes + type equality constraints ≡ GADTs
05:38:57 <liste> which is equivalent to "printGrid grid size >>= \_ ->"
05:39:09 <pollz> Oh okay
05:39:34 <mniip> ertesx, probably
05:39:45 <pollz> so I am to do a printGrid >> life (newGrid) size k?
05:39:47 <ertesx> mniip: certainly =)
05:40:12 <pollz> ignoring the syntactic errors is that logic correct?
05:40:24 <liste> pollz: yes
05:40:34 <ertesx> mniip: you may find this interesting: https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html
05:40:38 <pollz> I will try and get back to you. Danke Herr liste 
05:44:11 <pollz> liste: It shows only the first and last iterations.
05:44:21 <pollz> I will pastebin modified code.
05:44:38 <lpaste> pollz pasted “Modificaiton” at http://lpaste.net/171940
05:44:49 <pollz> pardon me if I have done anything retarded.
05:45:29 <liste> pollz: you're using life, not life2 on line 3
05:45:47 <pollz> oh
05:46:37 <pollz> danke herr liste 
05:46:44 <pollz> I am really retarded lol
05:47:13 <liste> yw (:
05:47:22 <pollz> over and out
05:49:05 <ironChicken> what's a good data structure to use if i want to build a sequence via repeated monadic actions and then have random access to the elements afterwards?
05:52:35 <pavonia> ironChicken: Maybe build a list first and convert to Vector if the list is fully built
05:52:44 <pavonia> *when
05:52:56 <liste> ironChicken: or use a STVector in ST and freeze it
05:53:31 <ertesx> ironChicken: see Data.Vector.replicateM
05:53:53 <ertesx> replicateM is defined for all vector types, including storable and unboxed
05:54:40 <ertesx> ironChicken: i'm making the assumption that "random access" means "random indexing"
05:55:19 <ironChicken> erebe1: the only thing about replicateM is that you need to define the length initially and i can't do that here
05:55:27 <ironChicken> ertesx: yes, random indexing
05:55:34 <mniip> ertesx, interesting but nothing new
05:56:33 <ironChicken> pavonia: yes, that may be the simplest thing to do
06:00:29 <ertesx> ironChicken: if speed is not important, yeah…  otherwise what liste said
06:00:58 <ertesx> ironChicken: mutable vectors can grow…  not cheaply, but likely more cheaply than building a list in memory
06:03:18 <ironChicken> ertesx: yes, i was fiddling around with growing by 1 each time. but is the cost in calling grow at all? or in the number of elements by which you grow?
06:05:16 <liste> growable arrays in many languages (Python, Java) double the size on each grow
06:05:38 <liste> (the capacity, not the actual number of elements)
06:08:01 <tdammers> IIRC most C++ STL implementations use a lower growth exponent than the theoretically ideal 2
06:08:12 <tdammers> not sure what Java or Python do
06:08:41 <merijn> In C++ it's often cheaper to do the loop twice
06:09:05 <merijn> Once to compute the size, and throw away the element, then reserve the size for your vector, then redo and store
06:10:53 <orion> Generally speaking, going from 0.1.0 to 0.2.0 implies a breaking API change, right?
06:11:17 <mniip> to think about it, C allocation is really limited
06:11:36 <mniip> I mean, the amount of tricks the allocator implementation can do
06:13:49 <ggole> You might be surprised.
06:14:12 <mniip> I mean
06:14:22 <mniip> how many language implementations can actually move data around
06:14:37 <ggole> Oh, relocation. Yep, pretty much no scope for that.
06:16:39 <alercah> mniip: I don't know much about dependent kinds
06:23:35 * hackagebot altcomposition 0.2.3.0 - Alternative combinators for unorthodox function composition  https://hackage.haskell.org/package/altcomposition-0.2.3.0 (jcristovao)
06:38:36 * hackagebot data-easy 0.7.0 - Consistent set of utility functions for Maybe, Either, List and Monoids.  https://hackage.haskell.org/package/data-easy-0.7.0 (jcristovao)
06:39:55 <Guest7829> although I know that I've just been warned: is there a better way to combine more than two parsers via "try" in megaparsec other then nesting multiple tries with parantheses?
06:40:31 <tdammers> try doesn't combine parsers, it just wraps a parser such that any input consuming it does is undone when it fails
06:41:59 <tdammers> e.g., if you write: string "foo" *> string "bar" <|> many1 (anyChar)
06:42:15 <tdammers> and you pass it the input "foothing", it will produce "thing", not "foothing"
06:42:34 <tdammers> because the parser string "foo" will have consumed the "foo" part before the string "bar" parser fails
06:43:24 <tdammers> so you'd wrap the left side of the <|> in a try to make it push back its consumed input when it fails
06:43:35 <tdammers> the try doesn't really combine anything though
06:43:37 * hackagebot blake2 0.2.0 - A library providing BLAKE2  https://hackage.haskell.org/package/blake2-0.2.0 (jgalt)
06:45:21 <mniip> http://lpaste.net/5154264886129197056 what's that mean
06:48:48 <Guest7829> tdammers: right, that was bad formulation on my side. I have function-calls, accesses to lists, to maps and to scalar variables. They all start with an identifier. I therefore have to try each variant and push the consumed part back if one parser fails. So to rephrase: ss there a good way to try more than two parsers in a row other than wrapping them in parantheses?
06:50:36 <tdammers> you don't actually have to use try for that
06:51:00 <Guest7829> You mean consuming the identifier and then identifying what comes after?
06:51:57 <black0range> Are there any way to print the data from template haskell "reify" in ghci? 
06:51:58 <tdammers> yes
06:52:03 <tdammers> https://github.com/tdammers/ginger/blob/master/src/Text/Ginger/Parse.hs#L557
06:52:09 <tdammers> here's an example from my own code
06:52:36 <prohobo> guys, i finished #11 in 99 problems
06:52:39 <prohobo> am i a pro yet
06:53:01 <prohobo> im putting "haskell guru" on my resume
06:53:29 <Guest7829> I considered that. But then I'd had to restructure my whole code, plus it's getting harder to test for, as I can't simply to a separate "parseFuncCall" anymore since parseFuncCall would expect opening parans, not an identifier (which would have to be consumed before)
06:54:16 <tdammers> ?
06:54:45 <tdammers> you can still test both the function call tail and the entire function call
06:55:01 <aisqwe> is there a way to get a list of all the constructors of a type?
06:55:07 <tdammers> it's just that the function call test could also return a different kind of expression if it is buggy
06:55:08 <Guest7829> when before parseFuncCall would parse "f(x){x}", it would then have to parse "(x){x}" instead since the caller would have consumed "f" already
06:55:18 <tdammers> sure
06:56:04 <tdammers> so you test your whole postfix expression parser instead, and see if it produces a function call expression if you pass it "f(x){x}"
06:57:17 <Guest7829> that's probably a philosophic question but I wouldn't be testing the parseFuncCall-unit in itself, as the correctness of the result could be dependend on the caller
06:58:21 <Guest7829> e.g. "parser = parseFuncCall <|> otherParser" and I test whether passing "f(x){x}" produces the desired result I can't be sure whether parseFuncCall or otherParser did the trick
06:59:28 <tdammers> correct
06:59:46 <Guest7829> that's... undesirable, isn't it? :)
06:59:48 <tdammers> I err on the side of pragmatism on this one
07:00:00 <tdammers> when it comes to writing parsers, I test the parser as a whole
07:00:22 <tdammers> i.e., hardly any unit tests for individual sub-parsers, if any
07:00:35 <tdammers> just a battery of tests that run the entire parser
07:01:56 <Guest7829> I hope I'll be able to do so as well some day. But when I tried to do that two days ago I got all sorts of errors plus some unhelpful error reports which led me to doing unittests for the smaller parsers. I'm a haskell-novice after all :(
07:02:26 <merijn> tdammers: Depends on the complexity of your individual parser :)
07:02:43 <merijn> tdammers: If you're writing, e.g. a IEEE754 floating point parser, I'd probably test it to be sure :p
07:03:37 * hackagebot reverse-geocoding 0.2.4.0 - Simple reverse geocoding using OpenStreeMap  https://hackage.haskell.org/package/reverse-geocoding-0.2.4.0 (jcristovao)
07:08:26 <buglebudabey> if i find that a function i have is taking a lot of arguments (5) is there a good way to avoid that
07:10:13 <c_wraith> Gurkenglas_: Did lambdabot get my message to you?  Hmm, probably not if you're on a backup nick.
07:10:21 <c_wraith> Gurkenglas_: http://lpaste.net/171865
07:16:22 <divVerent> I want to iterate a function with random parameters until an "accumulated" result has a specific value... any "nice" way to do that?
07:16:45 <divVerent> thought of iterateUntilM but that seems fiddly
07:17:21 <divVerent> now thinking of making a pure function returning an infinite list, then using takeWhile or similar...
07:17:35 <c_wraith> divVerent: Create an infinite list of random parameters.  map your function over it.  Fold until your accumulator is what you want.
07:18:22 <divVerent> I'm a bit worried about abusing the RNG... if I use randomRs or similar, basically I'm not really allowed to use this RNG again
07:18:29 <c_wraith> so?
07:18:34 <c_wraith> You can always create another one.
07:18:47 <divVerent> that's good enough statistically? Good then :)
07:18:50 <divVerent> I'
07:19:07 <divVerent> "but very little work has been done on statistically robust implementations of split" worries me a bit
07:19:17 <c_wraith> It's not like they're a scarce resource
07:19:26 <divVerent> well, this documentation worries me still
07:19:30 <c_wraith> Don't use split.
07:19:36 <divVerent> well, newStdGen uses split
07:19:42 <hpc> is split that bad?
07:19:43 <divVerent> can't I just reseed from /dev/urandom?
07:19:45 <divVerent> the docs say it is
07:19:48 <c_wraith> newStdGen is that bad. :)
07:20:15 <merijn> divVerent: What are you using it for?
07:20:23 <c_wraith> If you care about quality of randomness enough to want /dev/urandom, you don't want StdGen
07:20:26 <divVerent> currently a small program to do a statistical simulation
07:20:30 <divVerent> just want to do it "right" from the start
07:20:37 <divVerent> and I care a lot about good randomness here
07:20:44 <merijn> divVerent: You can try using mwc-random if you need fast and good randomness
07:20:51 <c_wraith> You care about statistical properties, not cryptographic ones
07:21:00 <c_wraith> Which means mwc-random is appropriate
07:21:15 <divVerent> cool, thanks
07:21:20 <divVerent> createSystemRandom is what I wanted
07:21:31 <divVerent> if I wanted crypto, what would I take then?
07:21:56 <c_wraith> statistical work often wants reproducibility, which is the opposite of a cryptographic property 
07:22:27 <c_wraith> The best way to get cryptographic quality randomness is reading from /dev/urandom.  Not using anything at the library level.
07:23:53 <c_wraith> I wish linux would straighten out its act with /dev/random.  The current state of it on linux is useless garbage.  But someone with a lot of say over what gets in fundamentally doesn't understand what they're doing.
07:24:14 <hpc> what's the problem with it?
07:24:35 <c_wraith> It blocks.
07:24:36 <Macmod> How much does this suck?
07:24:37 <hpc> (genuine question, i don't kernel much)
07:24:39 <Macmod> https://github.com/Macmod/hsfun/blob/master/MonteCarlo/MonteCarlo.hs
07:24:58 <hpc> is that bad? there's always urandom
07:25:18 <merijn> hpc: Basically, it blocks if it thinks "entropy is too low", rather than simply using a seeded CPRNG
07:25:19 <c_wraith> In particular, using /dev/random opens you up to DoS attacks when the kernel suddenly decides that its entropy pool is insufficient, even though there is no math whatsoever which supports that view.
07:25:33 <hpc> ah
07:25:38 <c_wraith> It's always the wrong choice to use /dev/random
07:26:00 <c_wraith> Yet it's the preferred interface, in terms of what file name people will look for first.
07:26:23 <merijn> hpc: OpenBSD/FreeBSD/etc. all use a strong CPRNG generator seeded by system entropy, occasionally adding new entropy
07:26:47 <c_wraith> If they just made it the same as /dev/urandom, it would break exactly nothing, while fixing a lot of potential issues
07:26:48 <merijn> hpc: Since it's a CPRNG it produces an infinite stream anyway, so not point in "stopping" due to low entropy
07:26:55 <c_wraith> But they refuse to do that.
07:27:25 <c_wraith> There's also the fact that there's no definition of "low entropy" anyway.  All it can do is make poor guesses.
07:28:04 <c_wraith> last I heard, /dev/random was using the CPRNG mechanism /dev/urandom does.  The only thing it does differently is block arbitrarily.
07:29:19 <Clint> c_wraith: yup
07:30:31 <c_wraith> Wow, there's so much FUD in linux's man pages on this topic.  It's like they intentionally prevent contributions from people who understand the topic.
07:32:31 <buglebudabey> could someone check the efficiency of my program? particularly the classify and pWordGivenClass function? http://lpaste.net/171958
07:36:06 <mfukar> c_wraith, there have been many attempts to change the man pages - afaik all have gotten the same reply: WONTFIX
07:36:59 <c_wraith> mfukar: yeah...
07:39:02 <c_wraith> I wonder if you could just plug fixes in to a .deb (or something similar in other distros).  If it isn't fixed upstream, make the fix available downstream.
07:43:54 <hexagoxel> is there any way to hoogle by kind? or: what is the name of `data Foo f = Foo (f (Foo f))` ?
07:44:33 <c_wraith> hexagoxel: it usually goes by Fix
07:45:14 <hexagoxel> c_wraith: thanks.
07:45:39 <Gurkenglas> If one of the fields in my record S is [AGetter S a], how do I modify the record such that each element of that field is replaced by the constant function at its current value?
07:46:53 <c_wraith> Sounds tough, if all you have is AGetter
07:46:53 <merijn> hexagoxel: Fix or Mu
07:47:11 <c_wraith> Gurkenglas: also, http://lpaste.net/171865
07:47:21 <c_wraith> (I know, I've spammed you with it.  I'm stopping now)
07:47:32 <Gurkenglas> Only twice!
07:48:32 <c_wraith> Anyway, it works.  And I didn't even import a lens to do it. :)
07:50:02 <Gurkenglas> "[AGetter' S a]" of course (and what was the difference between AGetter' and Getter? AGetter'
07:50:07 <Gurkenglas> was the storable one right)
07:50:54 <c_wraith> AGetter removes the polymorphism in the functor
07:51:02 <c_wraith> which you can recover using cloneGetter
07:51:23 <aweinstock> buglebudabey: on line 42, you're using foldl with a Double-valued accumulator, I'm pretty sure foldl' would be an improvement
07:51:44 <c_wraith> ReifiedGetter does much the same thing, but with more language extensions.
07:52:01 <Gurkenglas> Let say I have S -> a instead :D
07:52:06 <c_wraith> also, any Getter unifies with the type of AGetter.  ReifiedGetter requires applying a constructor.
07:52:29 <buglebudabey> aweinstock thank you for that, i also just updated the function a little bit - if you'd like to take a second look
07:52:42 <c_wraith> Gurkenglas: the big issue I can see is that the Getter doesn't tell you where in S it is pulling its value from.
07:53:14 <c_wraith> Gurkenglas: Unless I misunderstood the problem statement, that's an insurmountable problem.
07:53:28 <Gurkenglas> It won't be the [S -> a]
07:53:37 <buglebudabey> aweinstock http://lpaste.net/171959
07:54:05 <Zemyla> Is there a database written in Haskell, for Haskell, that uses STM to store its stuff?
07:54:06 <c_wraith> Data S a = Foo a a a [AGetter S a]
07:54:07 <buglebudabey> aweinstock i lifted a function from pWordGivenClass to classify so that it wouldnt be called with every word
07:54:45 <aweinstock> buglebudabey: there's also a couple of things that could be made shorter: M.findWithDefault in totalOfWord, vecs = map flist, argmax = _cClass . maximum
07:54:53 <c_wraith> Gurkenglas: there's just no way to distinguish which of the first three params a particular getter applies to in general.
07:55:34 <Gurkenglas> Three params? S is the only one
07:56:19 <buglebudabey> thanks aweinstock i just changed those to what you said
07:56:52 <Gurkenglas> newType S a = {runS :: [S a -> a]} <- sounds loeby
07:56:58 <Gurkenglas> *t
07:57:53 <Gurkenglas> foob :: S a -> [a]; foob s = map ($s) s
07:58:55 <aweinstock> Gurkenglas: newtype's can be recursive?
08:00:27 <Gurkenglas> @let newtype S a = S {runS :: [S a -> a]}
08:00:29 <lambdabot>  Defined.
08:01:33 <Gurkenglas> @let foob :: S a -> [a]; foob s@(S list) = map ($s) list
08:01:34 <lambdabot>  Defined.
08:01:39 <Gurkenglas> Apparently.
08:03:01 <aweinstock> buglebudabey: on lines 40-44, caseC is used multiple times with the same arguments (some directly, some indirectly); unless I'm missing where the arguments differ, it'd be more efficient to leave off the arguments, so that it only gets computed once
08:03:21 <Gurkenglas> > let s = S [const 0, \(S s') -> head s' s] in foob s
08:03:23 <lambdabot>  [0,0]
08:03:30 <dmj`> is there a typeclass like Monoid, but just contains mempty
08:03:43 <phadej> dmj`: Default
08:03:43 <Gurkenglas> It's called Pointed and has no laws so we didnt bother defining it
08:03:46 <buglebudabey> aweinstock that's my goal, i was just unsure how to go about it
08:03:57 <buglebudabey> aweinstock i only want to calculate it once per class
08:03:59 <phadej> but no laws makes it quite arbitrary
08:04:01 <barrucadu> There's Default, but generally a default value is only meaningful if you specify what the combining operation is
08:04:23 <Zemyla> Gurkenglas: I thought Pointed did have laws, or was isomorphic to a type that had laws.
08:04:33 <phadej> e.g. "default" for integer could be 0 or 1 or ...
08:04:41 <Gurkenglas> nvm ek did it https://hackage.haskell.org/package/pointed
08:04:50 <phadej> Zemyla: it really doesn't
08:04:53 <dmj`> phadej: yea, was fearing that, but it makes sense
08:04:54 <phadej> or it does, but they are free
08:05:11 <dmj`> barrucadu: yes, good point
08:05:22 <Gurkenglas> Tho that one'
08:05:22 <buglebudabey> aweinstock in the last local function 'f' caseC changes with whatever class value is passed into it from the list comprehension i have
08:05:28 <aweinstock> buglebudabey: I'd start with increasing the scope of s (change to "classify mat s = f" and "f = [")
08:05:39 <phadej> (a -> f a should be natural transformation, but you cannot break that, because of parametricity)
08:05:41 <Gurkenglas> *s in the Functor hierarchy not the Monoid hierarchy
08:06:56 <phadej> and that law is satisfied e.g. by both \x -> Just x and \x -> Nothing
08:07:33 <aweinstock> buglebudabey: oops, inlining s wouldn't make too much of a difference, mat is the argument that's passed around everywhere
08:07:35 <phadej> you'd probably want the first one, but you cannot really express that
08:07:38 <Gurkenglas> :t do s <- get; ?listoffunctions . each %= const . ($s) -- c_wraith, this, but I hoped not to name s
08:07:39 <lambdabot> (?listoffunctions::(s1 -> Identity t) -> s -> Identity s, Each s1 t (s -> a) (b -> a), MonadState s m) => m ()
08:08:16 <buglebudabey> aweinstock true, but why is that a problem?
08:08:30 <phadej> (maybe it would work out buy saying that `point` should be injection, if it can be (\x -> Proxy) is valid `point` / `pure` / `return`)
08:08:32 <Zemyla> phadej: So the fact that a Functor is Pointed iff it is strong with respect to Either isn't a compelling use case?
08:08:43 <Gurkenglas> phadej, couldnt you say that 'point :: a -> f a' must have the form 'const x' for some x?
08:08:54 <m0rphism> Is it possible in ghc 8.0.1 to define two instances for a multi param type class `C x y`, such that one covers the case of `x == y` and the other covers that of `x /= y`?
08:09:07 <Gurkenglas> Oh actually that would mean you could call it 'point :: f a'
08:09:09 <phadej> Gurkenglas: that what I just said, but there `Proxy` and `Const` break it
08:09:27 <phadej> you have to exlude those patological cases
08:09:51 <Gurkenglas> Huh how do they break it
08:10:31 <phadej> Gurkenglas: `pure _ = Const :: Const a`
08:10:36 <phadej> sorry
08:10:44 <phadej> Gurkenglas: `pure _ = Const mempty :: Const m a`
08:11:08 <Gurkenglas> Right, that does have the form const x for some x
08:11:16 <Gurkenglas> ergo law not broken
08:11:32 <phadej> yet `Const` and `Proxy` are valid Applicatives
08:11:40 <phadej> and you want `point` and `pure` to coincide
08:12:01 <phadej> m0rphism: yes
08:12:38 <phadej> m0rphism: or you'll actually have one instance, and case on `a == b`: https://gist.github.com/phadej/cae76444548b9cffa10d9675e013847b
08:13:04 <mniip> edwardk, any idea how to make this better? http://lpaste.net/171967
08:13:23 <Gurkenglas> Is there a [Traversal' s a] -> Traversal' s a that'll first do the first traversal, then those elements of the second that haven't been traversed yet, etc?
08:13:25 <phadej> m0rphism: yet you'd probably better with just a function, as you'd have only single instance
08:13:47 <Gurkenglas> "left-biased traversal union" :D
08:13:56 <phadej> Gurkenglas: how'd you'll know what traversed?
08:14:04 <phadej> what is already traversed?
08:15:13 <Gurkenglas> What do I need to replace "Traversal' s a" with in my question so it becomes solvable?
08:16:13 <Gurkenglas> "-replace with+specialize to", I think
08:17:05 <phadej> Zemyla: do you mean that: Either (Maybe a) (Maybe b) -> Maybe (Either a b) is invertible?
08:17:50 <phadej> I don't remember ct definitions by heart...
08:18:31 <dolio> (1 + n) + (1 + m) =? 1 + (n + m)
08:18:39 <Gurkenglas> Wouldnt you have a collision between Left Nothing and Right Nothing? (or do you mean invertible to be "surjective"?)
08:19:42 <phadej> yet, that goes beyond "Pointed" as you'll need additional operations to stay the law.
08:19:58 <phadej> In the sense that applicative is monoidal functor in respect to (,)
08:20:13 <phadej> "there's more than just `pointed`"
08:20:58 <lpaste> aweinstock pasted “No title” at http://lpaste.net/171971
08:21:13 <aweinstock> buglebudabey: ^ what I had in mind
08:22:04 <aweinstock> buglebudabey: that way caseC only gets computed once, even though it's used both on 21 and 23
08:22:12 <buglebudabey> aweinstock that's basically what i just did except i broke prob out into a helper function instead of a local
08:22:17 <buglebudabey> but a local is probably bette
08:22:19 <buglebudabey> better*
08:22:28 <buglebudabey> aweinstock thanks! great minds..
08:23:21 <aweinstock> buglebudabey: could you post the current version you have?
08:23:56 <buglebudabey> aweinstock http://lpaste.net/171973
08:24:26 <buglebudabey> aweinstock what you did lets me not have to have so many parameters passed in, so i like yours better
08:26:34 <aweinstock> buglebudabey: btw, it looks like the algorithm doesn't depend on pattern matching on Class, only on the fact that Class is an instance of Eq, so there's probably room to generalize the signatures
08:27:59 <buglebudabey> signature in just classify or in others as well aweinstock 
08:28:08 <aweinstock> (I'm not sure how accurate it'd be, but that'd let you define "data PartOfSpeech = Noun | Verb | Adjective | Other" or something like that, and re-use your current algorithm)
08:28:23 <aweinstock> anywhere that Class is used
08:28:53 <buglebudabey> aweinstock my goal is to have others define their own data constructors for Class so that they can classify text using their own labels
08:29:14 <aweinstock> that's exactly what I was suggesting
08:29:19 <buglebudabey> aweinstock is there a way i can make my type polymorphic or something like that so that this can happen?
08:29:49 <buglebudabey> aweinstock yeah i see what you mean with the type signature
08:29:50 <aweinstock> data Labeled a = Labeled { flist :: FList, _lClass :: a}
08:29:59 <buglebudabey> so instead of [Class] i can say [a]?
08:30:02 <m0rphism> phadej: thanks that works. I was so sure I've tried the solution with OVERLAPS and it always chose the second one... maybe I've screwed up something else...
08:30:04 <aweinstock> (and similarly with the other types)
08:30:16 <buglebudabey> aweinstock ah i see
08:30:24 <lpaste> tippenein pasted “FromJSON instance for Entity Document” at http://lpaste.net/171979
08:30:30 <aweinstock> makeMaterial :: Eq a => [String] -> [a] -> Material a
08:30:43 <aweinstock> (and likewise for other functions)
08:31:17 <phadej> m0rphism: great
08:32:52 <buglebudabey> aweinstock is this looking alright? http://lpaste.net/171983
08:33:16 <buglebudabey> aweinstock should material be a newtype instead?
08:33:31 <aweinstock> type Material a = [Labeled a]
08:33:48 <aweinstock> I don't think so
08:35:20 <aweinstock> (the "I don't think so" was about the newtype, the rest of the changes were fine, once the correction to Material is made)
08:36:31 <buglebudabey> gotcha, would you mind if i showed you the changes to the rest of the program?
08:37:08 <aweinstock> I'd like to see it
08:37:29 <tippenein> Trying to write a FromJson instance for an persist Entity
08:37:31 <buglebudabey> i'm seeing if it builds first
08:39:39 <buglebudabey> aweinstock in 'data Classified a = Classified { _cClass :: a, _probability :: Double } deriving (Eq)' how do i add a type constrain on 'a' for Eq?
08:40:09 <buglebudabey> (Eq a) => data Classified a...?
08:41:42 <phadej> buglebudabey: i's added implicitly
08:42:00 <phadej> i.e. Eq a => Eq (Classified a) instance is generated
08:46:38 <buglebudabey> i'm getting aweinstock how does this look? new version: http://lpaste.net/171991
08:46:59 <buglebudabey> ignore the 'im getting' part
09:19:18 <Zemyla> phadej: No, it's strong over Either in that a function distRight :: (Pointed f) => Either a (f b) -> f (Either a b) exists.
09:20:12 <phadej> Zemyla: and what law `point` should then have?
09:28:58 <Zemyla> phadej: https://mail.haskell.org/pipermail/haskell-cafe/2015-November/122357.html
09:32:30 <ivegotasthma> Hello, is it possible to kick off a stack build && stack install from emacs? I'm looking for a stack layer if possible but I can't find anything on the matter (I'm using spacemacs)
09:42:17 <eklavya> is there a way to define a different typeclass implementation for something without introducing a newtype?
09:42:47 <mniip> different from what
09:42:47 <eklavya> I don't want the user of the API to litter their code with my newtype constructors 
09:43:10 <eklavya> I want to define a different Binary implementation than the deafult
09:43:25 <mniip> "default"?
09:43:48 <eklavya> umm
09:44:05 <eklavya> the Binary package defines implementations for some types
09:44:11 <eklavya> that's included
09:44:30 <mniip> and you want those types to have different instances
09:44:44 <eklavya> yes, but only in my library code
09:45:12 <eklavya> I mean from outside it should not be visible that I am using a different instance
09:45:28 <eklavya> so it doesn't interfere with any code that the user might have
09:46:50 <mniip> so you have an API function of the type 'Binary a => ... a -> ...'
09:47:01 <eklavya> yes
09:47:01 <mniip> where the user chooses the type that has a binary instance
09:47:05 <eklavya> yes
09:47:06 <mniip> and you want to use a different instance
09:47:09 <eklavya> yes
09:47:11 <mniip> no that can't be done
09:47:21 <eklavya> :(
09:47:48 <mniip> you could use a different typeclass
09:47:57 <mniip> or build something on top of Binary's output
09:48:43 <mniip> I suppose you could try to use the Data.Reflection.Magic trick
09:48:46 <mniip> but there be dragons
09:49:05 <the_2nd> Is there a function or faster way to transform a Maybe Bool to Bool, where Nothing -> False ... Just x -> x, than with a case of?
09:49:10 <eklavya> I defined a new typeclass for this purpose
09:49:13 <eklavya> but
09:49:26 <mniip> :t maybe False (const True)
09:49:27 <lambdabot> Maybe b -> Bool
09:49:31 <eklavya> that requires mixing stuff in Binary monads
09:49:35 <mniip> er
09:49:38 <mniip> :t maybe False id
09:49:39 <lambdabot> Maybe Bool -> Bool
09:49:47 <glguy> :t fromMaybe False
09:49:48 <lambdabot> Maybe Bool -> Bool
09:51:23 <mniip> 1 char longer
09:51:56 <mniip> :t getAny . fold . fmap Any
09:51:57 <lambdabot> (Functor t, Foldable t) => t Bool -> Bool
09:52:01 <the_2nd> :D
09:52:09 <mniip> :t getAny . foldMap Any
09:52:10 <lambdabot> Foldable t => t Bool -> Bool
09:55:37 <lyxia> :t or
09:55:38 <lambdabot> Foldable t => t Bool -> Bool
09:58:03 * mniip . o O ( . . . )
09:59:29 <aweinstock> :t ala Any foldMap
09:59:30 <lambdabot> Foldable t => t Bool -> Bool
09:59:54 <glguy> It's going to be hard to beat lyxia's solution
10:00:18 <aweinstock> @let o = or
10:00:19 <lambdabot>  Defined.
10:01:15 <shachaf> 16 bits is a lot.
10:11:09 <phadej> Zemyla: yet gershom answered to that
10:11:23 <phadej> Zemyla: strongsum is "stronger" than Pointed
10:12:56 <dmwit> I have to say one of the consequences of the FTP is that I find myself using the Foldable/Traversable class functions a lot more, and often in places that strike me as surprising.
10:13:06 <buglebudabey> i'm trying to install haddock using stack and i'm getting a failure to add dependency error: haddock-api: needed (==2.17.*), 2.16.1 found (latest applicable is 2.17.3)
10:13:07 <buglebudabey>     needed for package haddock-2.17.2
10:13:20 <dmwit> e.g. the first time I saw `for_` used on a `Maybe` it blew my mind, but I've found that or something like it very useful many times since.
10:14:24 <Axman6> :t for_
10:14:25 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
10:14:49 <kadoban> buglebudabey: Are you just doing 'stack install haddock' outside of a package? What's the full output?
10:14:55 <hpc> isn't that just \m f -> m >>= f >> pure ()?
10:14:59 <Axman6> dmwit: got a good mindblowing example?
10:15:08 <hpc> (for Maybe)
10:15:12 <dmwit> :t for_ (Just 3) print
10:15:14 <lambdabot> IO ()
10:15:24 <buglebudabey> kadoban i am outside of any package and that is the full output
10:15:29 <hpc> erp, mixing my fs and ts
10:15:38 <hpc> okay, that's pretty neat
10:15:43 <dmwit> I think that was the interesting core of the example I saw.
10:16:04 <buglebudabey> kadoban http://lpaste.net/172028
10:16:11 <Axman6> I do find myself pattern matching on maybes and eithers a lot mmore than I should, probably because I'm forgetting the traversable functions
10:16:30 <buglebudabey> kadoban and yes just stack install haddock
10:16:32 <kadoban> Oh huh, haddock isn't in stackage. Try older versions maybe? 'stack install haddock-2.16.1' maybe
10:17:56 <buglebudabey> kadoban it's downloading now, thank you
10:18:04 <buglebudabey> i wonder why 2.17 isn't on stack yet
10:18:04 <joe9>  is there something like lucid for svg's?
10:18:15 <buglebudabey> what's the command to update package list in stack?
10:18:16 <Zemyla> phadej: How so? distRight = either (pure . Left) (fmap Right), yes? And pure = fmap (either id absurd) . distRight . Left?
10:18:35 <kadoban> buglebudabey: Usually just nobody agreed to maintain it.
10:19:28 <kadoban> buglebudabey: 'stack update' though you rarely have to actually use it manually.
10:19:40 <buglebudabey> ah thanks
10:19:56 <kadoban> But yeah I don't really understand why haddock-api is in stackage but not haddock itself.
10:21:01 <dmwit> joe9: diagrams has an svg backend, but is probably not as svg-specific as lucid is html-specific
10:23:16 <dmwit> > for (Just 3) show
10:23:17 <lambdabot>  [Just '3']
10:23:34 <dmwit> Okay, I admit this is not what I expected.
10:24:06 <dmwit> It is what I expected in retrospect, though.
10:25:09 <shachaf> My predictions in retrospect usually come true.
10:25:58 <glguy> Being able to think clearly about the past is nothing to hold your nose at
10:26:10 <glguy> Not everyone can do it
10:27:16 <dmj`> I'd assume most people can hold their noses
10:28:05 <shachaf> > for (Just 12) show
10:28:07 <lambdabot>  [Just '1',Just '2']
10:28:18 <joe9> dmwit, Thanks, just checked out diagrams. you are right it is not svg-specific. I know the svg elements and their structure. I am just looking for a way to represent them and present them.
10:29:55 <joe9> dmwit, found lucid.svg
10:30:06 <mniip> hey shachaf
10:30:24 <mniip> shachaf, any idea how to make this look less ugly http://lpaste.net/171967
10:32:47 <xuxu> i'm often confused when persons claim they can spit out 1-2 thousand lines of code in a day without a problem
10:33:27 <xuxu> sometimes it can take me about a week to get two to three hundred lines just right
10:33:47 <xuxu> specs change
10:33:53 <mniip> depends on the language I guess
10:34:00 <mniip> I wrote 1400 loc in one night once
10:34:18 <xuxu> you write once, people want something different, you edit what you have, repeat
10:34:26 <xuxu> i.e. changing specs happen
10:35:13 <xuxu> i can understand writing 1000+ lines on a fresh new project
10:35:22 <xuxu> especially if it's your own project
10:35:43 <mniip> yeah
10:35:46 <mniip> that  was the case
10:35:53 <xuxu> i was curious what other people think
10:35:59 <mniip> kinda spawned an entire library in one night
10:36:24 <mniip> editing other people's code requires much more reading than writing
10:36:28 <xuxu> i can think too far into these statements and start to feel terrible about myself
10:36:48 <phadej> Zemyla: gershom's case: https://gist.github.com/phadej/6f4529a96030e6fe16d9983a1eaa90f5
10:36:51 <kadoban> xuxu: Lines of code is an almost meaningless measure.
10:36:57 <xuxu> also, difficult problems take time. if i want to write maintainable code, i can't always just spit out what first comes to mind
10:37:19 <xuxu> s/spit/type
10:37:26 <xuxu> :)
10:37:38 <phadej> Zemyla: i.e. StrongSum requires more then needed
10:37:47 <phadej> s/needed/we want it to require/
10:38:01 <mniip> well with practice you learn to spit out maintainable code and have it be the first thing that comes to mind
10:38:04 <xuxu> these are my justifications for why i normally am not writing 1000+ lines everyday
10:38:26 <dolio> You shouldn't be writing 1,000 lines every day.
10:38:28 <xuxu> i rarely have a green field opportunity
10:39:22 <xuxu> thanks mniip and dolio for your feedback
10:40:36 <dolio> 1,000 lines per week is probably excessive.
10:41:11 <hpc> 1k lines per day is over 2 lines a minute, non-stop
10:45:35 <dolio> Yeah, I would think that could only be done if most of your lines take almost no thought at all.
10:46:00 <joe9> Would this be a good library to use for representing a multi-branch tree? https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Tree.html
10:46:55 <lyxia> joe9: sure
10:56:54 <carado> hi ! is there a haskell/ghc extension that would do something like replacing f !a b !c !d with { a' <- a ; c' <- c ; d' <- d ; f a b c d } ? (yes, I know about liftM*.)
10:57:11 <carado> (not necessarily with '!' ofc, but you see the idea)
10:58:36 <mniip> there are banana brackets kinda
11:02:57 <aweinstock> carado: <$> and <*> can be used to generalize liftM (e.g. (f <$> a <*> b <*> c <*> d))
11:03:52 <buglebudabey> are examples of code on a hackage page done using haddock?
11:04:12 <carado> cool, thanks !
11:04:42 <ongy> buglebudabey: can be. the part above the normal text is *.cabal description, below it can be readme
11:05:27 <buglebudabey> what about with these 3 examples at the bottom https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html ongy 
11:06:30 <eklavya> I am in the Get (Binary) monad chain, I have to check for the incoming bytestring length and make a decision, how do I write that?
11:06:32 <glguy> buglebudabey: Click the [Source] link for that page so you can look at it
11:06:59 <buglebudabey> thanks glguy 
11:07:02 <glguy> eklavya: do len <- getLength; expression using len
11:07:22 <ivegotasthma> is it possible to match multiple patterns in the same guard? `1 | 2 | 3 -> expr`
11:07:31 <glguy> ivegotasthma: no
11:07:51 <eklavya> glguy: wow, yes
11:08:05 <eklavya> thanks glguy :)
11:08:09 <mniip> ivegotasthma, | a = expr | b = expr | c = expr where expr = ...
11:08:52 <ivegotasthma> mniip: glguy: thanks, I just have two patterns that match the same expr and I'm wondering if there's a way to combine them.
11:10:28 <dmwit> ivegotasthma: Even after you rephrase the question, the answer is still no. =P
11:10:54 <dmwit> ivegotasthma: I don't think there's anything fundamental preventing it. OCaml has something like that. It's just not implemented in Haskell or GHC.
11:11:00 <ivegotasthma> dmwit: hahaha, if only
11:11:09 <rrradical> has anyone here run haskell on an arm64 iphone?
11:11:21 <ivegotasthma> I'm a newb, wasn't sure I was using the correct terminology.
11:12:44 <dmwit> ivegotasthma: *nod* Making your question as clear as possible is a good instinct.
11:14:02 <eklavya> glguy: that didn't work :(
11:14:14 <eklavya> I was wondering how that could work
11:14:17 <glguy> eklavya: You'll have to show us what you did wrong
11:14:29 <eklavya> ok
11:15:17 <glguy> Oh, I see, the question wasn't about how to make a decision, it was how to get the length?
11:16:43 <eklavya> glguy: http://lpaste.net/172040
11:16:59 <eklavya> I am in the Get monad
11:17:08 <eklavya> so every stage needs to be a Get, no?
11:17:19 <glguy> Yeah, that's right
11:17:46 <eklavya> I am stuck on how to get the length of the incoming bytestring and make this decision 
11:17:55 <glguy> It doesn't appear that you need the remaining length, you need to know if the remaining bytestring is empty
11:18:14 <dmwit> eklavya: Proposal: `do { num <- get; ... } <|> pure DMS.empty`
11:18:23 <glguy> which is good because you don't usually want to check the full remaining length. You can use isEmpty :: Get Bool
11:19:06 <glguy> You can refer to http://hackage.haskell.org/package/binary-0.8.4.1/docs/Data-Binary-Get.html to see what's possible with Get
11:19:41 <glguy> dmwit: That will hide other failures, though
11:19:49 <dmwit> It is a different parser, yes.
11:20:32 <eklavya> glguy: hmm, so I should try to read a boolean?
11:20:37 <eklavya> but that would fail, no?
11:20:54 <dmwit> `isEmpty` produces a boolean, but not by reading it from the input stream.
11:20:57 <glguy> Get Bool doesn't mean that it actually consumes a Bool
11:21:26 <dmwit> Too many cooks. I'll be quiet.
11:21:31 <eklavya> the length of the bytestring will be zero so binary will fail with error
11:21:38 <glguy> Nope
11:21:53 <eklavya> let me try that
11:22:12 <glguy> isEmpty checks if the bytestring is empty and returns True if so, False otherwise
11:23:48 <eklavya> oh
11:23:59 <eklavya> glguy: thanks :)
11:25:25 <Gurkenglas> Can I put stack on a usb stick such that I can plug it into any machine and do stack things?
11:27:29 <Gurkenglas> (Such that *looking for simple characteristic properties* any workflow is not interrupted by moving the usb stick to a different machine)
11:33:31 <yyyyy> Gurkenglas: if your home fits a pen drive you could mount it there and bring not just stack but everything else alongside
11:33:50 <yyyyy> with the downside of having to have the pendrive to mount home
11:33:54 <kadoban> Gurkenglas: What use-case would it be for? Is it all the same OS, or?
11:34:48 <Gurkenglas> everyone here has win 10
11:35:22 <Gurkenglas> this machine is better which is why other people want to go there when they're present and why I want to go there when they're not
11:35:42 <Gurkenglas> And then sometimes people want me present somewhere else, but there's another machine there
11:36:36 <slack1256> wxwidgets does have a GUI builder that can be used with haskell right?
11:38:33 <buglebudabey> haddock says it couldnt find Data.Text.Lazy but my package builds just fine: http://lpaste.net/172044
11:39:01 <glguy> buglebudabey: You probably didn't install documentation for text
11:39:37 <buglebudabey> i installed haddock 2.16 an hour or so ago using stack, how can i install documentation for text?
11:40:04 <glguy> stack has a command for building documentation, stack haddock
11:40:14 <buglebudabey> thanks
11:43:55 <buglebudabey> glguy after performing that command should it work? i received the same error message after attempting to run the command again
11:44:23 <glguy> buglebudabey: If you're using stack you use it for everything
11:44:30 <glguy> you can switch back to plain haddock afterward
11:44:34 <glguy> cant'*
11:45:04 <buglebudabey> ah my bad, thank you
11:47:23 <glguy> When you're using cabal-install , you can set "documentation: True" in ~/.cabal/config
11:47:41 <glguy> then when you install package the documentation will be installed too
11:50:39 <Darwin226> Is it expected that code using the timeout combinator runs on multiple threads?
11:51:06 <Darwin226> Everything else in my code is synchronous
11:53:24 <geekosaur> it is expected, yes
11:59:12 <buglebudabey> since i did a fresh install of haskell with stack, i no longer have cabal commands available. do i already have cabal but just not the path set up?
11:59:57 <kadoban> buglebudabey: 'stack install cabal-install' if you need it. You shouldn't be using it for much at all though with stack.
12:00:33 <buglebudabey> kadoban im wondering how to upload my haddock documentation to hackage, and it seems like most ways include a cabal command
12:01:23 <kadoban> buglebudabey: That's possible, I don't think that's implemented in stack last I checked.
12:01:42 <aupiff_> buglebudabey: sdist is an available stack command, if that's what you need. What command do you usually use for docs specifically?
12:02:01 <buglebudabey> i don't mind doing it manually, i'm just unsure of how. it's my first hackage upload
12:02:09 <buglebudabey> havent uploaded the package yet either
12:02:24 <aupiff_> well if you do `sdist` the docs are included I believe.
12:02:32 <aupiff_> or at least hackage builds them for you
12:02:50 <buglebudabey> not sure what sdist is quite yet
12:03:06 <aupiff_> source distrobution, which is how you upload things to hackage
12:03:33 <aupiff_> try it out on your current project and see what happens, it won't break anything
12:04:16 <buglebudabey> just a command $ sdist project?
12:04:35 <aupiff_> in your project, run `stack sdist`
12:05:08 <aupiff_> try `stack sdist --help` if you need some more direction.
12:05:17 <buglebudabey> thank you very much
12:05:24 <aupiff_> no problem
12:06:08 <buglebudabey> aupiff_ so it wrote the tarball, i'm guessing this is what is used when uploading to hackage? did it generate the documentation for me?
12:06:35 <aupiff_> buglebudabey: I think that when you upload that tarball to hackage, hackage will automatically build the docs for you
12:06:58 <bennofs> stack does not have a documentation upload feature yet as far as I know - i'm not a stack user though
12:07:20 <aupiff_> does hackage even support a doc upload?
12:07:35 <bennofs> aupiff_: yes
12:07:36 <aupiff_> I thought you only had the option of submitting a source tarball
12:07:41 <aupiff_> bennofs: what is it?
12:08:02 <bennofs> aupiff_: you can upload a documentation tarball for an existing package. useful for packages which won't build on hackage due to missing native dependencies
12:08:09 <aupiff_> people tend to keep submitting different versions of their libraries when theh docs don't build.
12:08:14 <aupiff_> their*
12:08:27 <buglebudabey> alright, i have another question, but abaout my .cabal file - i use Data.Maybe, Data.Function Data.Char and Data.List, but the only ones i needed to include in my dependencies were 'containers' and 'text'. Why does it build in this condition?
12:08:29 <aupiff_> is this a recent feature?
12:08:53 <aupiff_> buglebudabey: you also include base.
12:09:08 <bennofs> aupiff_: If you are on the main page for a package you own, you can go to "edit package information" and then there is something to upload docs i believe
12:09:09 <buglebudabey> alright cool
12:09:09 <aupiff_> base contains all those Data.--- modules you listed
12:09:16 <kadoban> buglebudabey: Those are all in 'base'.
12:09:23 <aupiff_> bennofs: thanks, good to know.
12:09:33 <bennofs> aupiff_: there are also various scripts around to do it and recent cabal install versions have support for it through the cabal upload --doc command
12:09:56 <aupiff_> bennofs: ah I see, I've been using exclusively stack for too long...
12:14:34 <buglebudabey> i uploaded my tarball to candidate but no documentation is included?
12:23:38 <buglebudabey> do i need to upload the haddock documentation myself?
12:25:00 <geekosaur> usually it should build it on the server. if your package requires any special FFI dependencies, you may need to upload docs
12:26:17 <buglebudabey> it's a pretty simple package, it only has one file and doesnt have any language extensions
12:26:31 <buglebudabey> is there anything i could show you that would help solve the issue
12:26:45 <ivegotasthma> Could someone help me understand why this function signature is misbehaving? - https://dpaste.de/0GzO
12:28:18 <ivegotasthma> Hm, not quite function signature but fold lambda signature.
12:28:45 <geekosaur> (>>) does not work with a result type of Integer
12:29:25 <ivegotasthma> Why is that the case? What would be the best way to adjust to this?
12:30:44 <hellofunk> when I create an executable with stack build and fish it out of the .stack_word/.../bin/ directory, is this a standalone executable that should run even on a machine without GHC/Haskell installed (assuming it is the same architecture machine) ?
12:31:19 <geekosaur> reverse the order of the expressions and use (.), or import Data.Function and use (&). (>>) doesn't do anything like what you want
12:31:43 <geekosaur> (>>) is what a semicolon (or new line) in `do` notation becomes
12:31:49 <geekosaur> :t (>>)
12:31:50 <lambdabot> Monad m => m a -> m b -> m b
12:32:23 <geekosaur> runs the monadic action on the left, discards its result, runs the monadic action on the right
12:33:14 <geekosaur> (are you an F# programmer by any chance? this looks like you were looking for the Haskell version of |>)
12:34:01 <ivegotasthma> geekosaur: Not at all, I was trying to chain actions together and piping their results down.
12:34:19 <geekosaur> these aren't actions, though. they're pure expressions
12:34:40 <ivegotasthma> Need to read up on that, thanks a ton!
12:37:13 <buglebudabey> if i generated haddock documentation using stack haddock, how can i get this included in my tarball to be uploaded?
12:38:15 <geekosaur> you don't. if docs need to be uploaded manually, it is done after the fact. otherwise you can just wait for the hackage buildbot to finish (although it's been known to have issues; you could ask in #hackage)
12:41:17 <buglebudabey> geekosaur oh, so there is a time period to wait for documentation?
12:41:46 <joe9> I am trying to understand this type definition: http://codepad.org/2RswUVJe , it means that result is based on what arg is, correct?
12:42:15 <joe9> Where can I find what arg or result can be?
12:42:51 <fishythefish> joe9: arg is determined from result
12:43:29 <joe9> fishythefish: oh, ok. Thankse
12:44:09 <geekosaur> buglebudabey, there is. I don't know details of the buildbot, but packages (and I think candidates) get built by the buildbot which also generates documentation, and the build report should show up on the hackage page for the package
12:44:48 <geekosaur> if there are problems with that or the build report doesn't show up in a reasonable amount of time, you probably want to ask over in #hackage
12:44:51 <buglebudabey> alright, so i'm alright with uploading despite it not showing up on a candidate upload, because i could always upload the docs manually if i have to?
12:45:04 <geekosaur> right
12:45:09 <buglebudabey> great
12:46:23 <buglebudabey> if i have this warning on hackage 'Exposed modules use unallocated top-level names: NaiveBayes' on hackage do i just put NaiveBayes module inside a folder so it's not exposed?
12:49:08 <geekosaur> folders don't matter. if it's not supposed to be user-visible, list it in other-modules: instead of exposed-modules:
12:49:13 <joe9> fishythefish: where can I find the possible combinations of result and arg?
12:49:25 <geekosaur> joe9, that will be determined by instances
12:49:30 <joe9> geekosaur: ok, Thanks.
12:49:34 <fishythefish> ^
12:49:59 <runeks> How do I make "decodeFromBody" print the type of what it's trying to decode? http://lpaste.net/172048
12:50:23 <runeks> It says it could not deduce Typeable, but I see it right there
12:51:06 <buglebudabey> geekosaur it's supposed to be visible because it's the library i'm trying to upload
12:52:03 <joe9> geekosaur: from this http://codepad.org/zsXTkbSx there are only 2 combinations of arg and result that are possible, correct?
12:52:07 <geekosaur> so you want to use a new top-level module name "NaiveBayes" instead of placing it under one of the existing top-levels? I don't know what the policy is there
12:53:35 <geekosaur> joe9, those are the only two that are in scope. note that compiled libraries can be linked with code that introduces other instances; you cannot assume, and ghc will not assume, that the instances you know about are the only ones that will ever exist. (typeclasses are "open")
12:53:36 <buglebudabey> geekosaur if i want to put the top level as the existing NLP, do i simply put it in an NLP named folder?
12:53:50 <geekosaur> again, folders have nothing to do with this
12:54:03 <geekosaur> this is module naming policy
12:54:15 <geekosaur> not folder policy, not how you organize your sources.
12:54:41 <buglebudabey> I see, but if i want it included in NLP module, then..?
12:56:16 <buglebudabey> ie make the top level module NLP
12:56:40 <geekosaur> this warning is telling you that a module name starting with "NaiveBayes" does not fit Hackage's module naming policy. if you truly want to define a brand new NaiveBayes.whatever module hierarchy instead of something like Data.NaiveBayes, ... well, I don't know how this policy is managed. again, ask in #hackage
12:57:05 <buglebudabey> geekosaur i don't want to do that at all
12:57:28 <hpc> at the very least, i expect #hackage would say to use Bayes.Naive or something
12:57:30 <geekosaur> but that's what the warning is saying you did
13:01:31 <joe9> quick question, to define an instance, you need either a data definition or newtype correct? In lucid, the p_, style_, etc., do not have a data definition or newtype.
13:02:27 <joe9> the p_ , style_ , etc. are just functions not data definitions.
13:02:40 <geekosaur> instances are about data, not functions. those functions might however be methods defined by a class and instance-specific definitions provided by an instance
13:03:18 <joe9> geekosaur: yes, they are defined with term function. which is a method of Term class.
13:03:50 * hackagebot ghcjs-ajax 0.2.0.0 - Crossbrowser AJAX Bindings for GHCJS  https://hackage.haskell.org/package/ghcjs-ajax-0.2.0.0 (AlexanderThiemann)
13:04:57 <geekosaur> okay, so they're just normal functions that happen to use typeclass methods
13:07:44 <geekosaur> if you write some code that uses the `length` function, you don't need to define a `Foldable` instance for your code; you only need such an instance if you want some data type you have defined to have a `Foldable` instance.
13:09:15 <digits12> Trying to write a function that turns an Int into a list of Ints (123 -> [1,2,3]) but I really can't grasp why the compiler thinks I'm passing it the wrong types.. http://lpaste.net/487192670259642368
13:09:47 <shachaf> (:) :: a -> [a] -> [a]
13:12:12 <Gurkenglas> Can I tell stack to use a different directory than %appdata%/stack?
13:12:30 <Gurkenglas> (the one that's .stack on unix)
13:12:52 <digits12> shachaf: thanks a lot, was a stupid mistake
13:13:52 <Revenarus> What’s the pointfree command?
13:14:16 <kadoban> Gurkenglas: STACK_ROOT or --stack-root I think
13:14:17 <geekosaur> ...
13:14:33 <Revenarus> thought there was a bot that simplified it
13:14:57 <geekosaur> the bot command is @pl. however, it rarely simplifies code; usually it obfuscates it
13:15:04 <glguy> Gurkenglas: I think you'll just need to make sure that the STACK_ROOT is the same each time you mount your USB drive
13:15:10 <glguy> same driver letter, etc
13:15:26 <Gurkenglas> Can I make it try a number of letters until one works?
13:15:39 <Gurkenglas> Or make its path depend on the path of stack.exe?
13:15:40 <Revenarus> @pl elem’ x = foldr (\a b -> if x == a then True else b) False
13:15:40 <lambdabot> (line 1, column 6):
13:15:40 <lambdabot> unexpected '\128'
13:15:40 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
13:15:58 <Gurkenglas> Better use /query lambdabot to test stuff you aren't trying to show to people
13:16:06 <Revenarus> ah
13:16:07 <Revenarus> thanks
13:16:53 <Gurkenglas> :t any (== ?a) -- Revenarus
13:16:55 <lambdabot> (Eq a, Foldable t, ?a::a) => t a -> Bool
13:17:16 <Revenarus> ?a 
13:17:16 <lambdabot> Maybe you meant: activity activity-full admin all-dicts arr ask auto-reply auto-reply? v @ ? .
13:17:49 <Gurkenglas> :t \a -> any (==a) -- My last line is more convenient for use with lambdabot
13:17:51 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
13:18:11 <maerwald> Revenarus: @pl /= simplified
13:18:27 <Gurkenglas> @pl \a -> any (==a)
13:18:27 <lambdabot> any . (==)
13:18:34 <Revenarus> Yeah i figured, the book i’m reading through encouraged for this particular problem to write it in pl 
13:19:36 <Revenarus> Thanks Gurkenglas, the last one simplified well
13:21:12 <dmwit_> ?pl \a -> any (a==)
13:21:12 <lambdabot> any . (==)
13:22:28 <Revenarus> how would that work in the elem folding example?
13:23:30 <dmwit> Apparently ?pl can handle lets, but not lets that define infix operators.
13:23:51 * hackagebot HGE2D 0.1.9.0 - 2D game engine written in Haskell  https://hackage.haskell.org/package/HGE2D-0.1.9.0 (I3ck)
13:23:53 * hackagebot hext 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/hext-0.1.0.0 (aneksteind)
13:24:39 <geekosaur> well, that's one demonstration how @pl is not simplification...
13:24:40 <geekosaur> @pl \x -> foldr (\a b -> if x == a then True else b) False
13:24:40 <lambdabot> flip foldr False . flip flip True . (if' .) . (==)
13:25:09 <geekosaur> (as a rule, if the result has more than one flip in it, run away)
13:26:00 <Gurkenglas> Revenarus, "any . (==)" is semantically equal to "foldr (\a b -> if x == a then True else b) False"
13:26:06 <dmwit> :t flip flip
13:26:07 <lambdabot> b -> (a -> b -> c) -> a -> c
13:26:33 <dmwit> cute
13:26:34 <buglebudabey> how can i realease a new version of my package on hackage?
13:26:54 <dmwit> buglebudabey: Bump the version number in your cabal file, then `cabal sdist` and `cabal upload dist/whatever.tar.gz`.
13:27:04 <buglebudabey> thanks
13:28:51 * hackagebot hext 0.1.0.1 - a text classification library  https://hackage.haskell.org/package/hext-0.1.0.1 (aneksteind)
13:29:01 <Gurkenglas> http://lpaste.net/8213471521570553856 can I give it a relative path somehow?
13:32:25 <sdx23> Gurkenglas: omit the leading slash?
13:32:44 <adarqui> hey... say i'm creating a library which simply creates "css class names" for things like: inputGroup = "input-group" .. how should I write this library so that it could be used in Text, String, JSString, ByteString etc? Should I simply do: inputGroup :: IsString a => a; inputGroup = "input-group" ?
13:32:47 <Gurkenglas> same response, sdx23
13:33:34 <Gurkenglas> (Except that it now also omits that leading slash :P)
13:34:40 <sdx23> well, `pwd`/../stack -- whatever the windows equivalent to this may be.
13:35:42 <adarqui> answer to my own question: yes
13:37:06 <Revenarus> Gurkenglas, is that command setting the root path? If so, why would you want it relatively defined
13:37:19 <Gurkenglas> So I can put everything on a usb stick
13:37:53 <Gurkenglas> (And if I hadnt told you that, not being able to think of a use case is not enough reason to not allow it :P)
13:38:51 * hackagebot cndict 0.8.2 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.8.2 (DavidHimmelstrup)
13:39:09 <Revenarus> True, but unless you’re rewriting the base stack packages i don’t see a way of doing it if it is expecting an absolute path
13:40:22 <Revenarus> you could write a script i suppose that’d automatically get the drive location of the dir and set it on plugging it in?
13:40:27 <Gurkenglas> I was imagining you speaking on behalf of the developer who I would be currently asking to add that feature just then
13:41:11 <Gurkenglas> Can one write a script thatll autorun on anything with write privileges on itself? That'd allow bitcoin mining
13:42:19 <Revenarus> well, autolaunch has fallen out of favor, and you’re always prompted to execute as far as I’m aware. that and you’re running it on varying privledges depending on which system/configuaration you’ve plugged into
13:42:58 <Revenarus> maybe there are still malicious exploits to actually “autorun” unconditionally, but i haven’t heard so much of them in the past 10 years
13:46:56 <Gurkenglas> http://lpaste.net/4767759232973930496
13:48:27 <Revenarus> try “”s around the location? not sure how windows escape characters work
13:49:56 <dmwit> Looks like it understood the location just fine to me.
13:50:05 <dmwit> It's just that Gurkenglas didn't actually ask stack to do anything.
13:50:34 <Revenarus> ah, i thought that command was setting the root, my bad
13:50:37 <Gurkenglas> Oh I need to prefix that to every command that I want to use with stack?
13:50:45 <dmwit> I would assume so.
13:52:57 <Gurkenglas> http://lpaste.net/4996901643795562496
13:53:32 <dmwit> Have you ever used stack?
13:53:33 <Gurkenglas> same without the .exe
13:53:42 <dmwit> If not, you should probably try to find some quick-start documentation.
13:53:51 <dmwit> (I haven't, so I can't advise you well here.)
13:53:58 <Gurkenglas> sure ive been using that command on that other machine over there to run .hs files
13:54:25 <Gurkenglas> (i just interrupted it so it wouldnt install all the packages on this machine)
13:57:13 <dmwit> Oh. I understand the complaint in your lpaste now.
13:57:43 <dmwit> That looks like a bug to me.
14:01:06 <Gurkenglas> http://lpaste.net/6074131058549325824 can I install it into the usb stick instead?
14:03:43 <mgsloan> Gurkenglas: Sure, just set the STACK_ROOT environment variable to a dir on the usb stick
14:04:37 <Gurkenglas> Oh so the advice returned by the command I pasted doesnt take the current --stack-root flag into account?
14:05:31 <mgsloan> Well, if you just run "stack setup" without --stack-root then yes it won't take it into account
14:05:48 <Gurkenglas> Also the path it said it would install to has nothing to do with the default -stack--root right
14:06:15 <Gurkenglas> mgsloan I mean if the command that caused it to give that advice used -stack--root then the advice should also
14:07:03 <Gurkenglas> (I mean the default -stack--root is %appdata%/stack but this is like %appdata%/../Local/Programs/stack
14:07:05 <mgsloan> Yeah, that would be a nice enhancement
14:10:14 <Gurkenglas> "stack --stack-root E:\Neu\stack setup" didnt take the --stack-root into account :(
14:10:48 <mgsloan> Yeah, I just realized this is an opeen issue on windows - https://github.com/commercialhaskell/stack/issues/998 https://github.com/commercialhaskell/stack/issues/2067
14:11:23 <mgsloan> PRs appreciated.  Looks like one guy posted up a diff but not a PR for some reason
14:17:42 <meditans`> why can I write
14:17:47 <meditans`> > __ = __
14:17:48 <lambdabot>  <hint>:1:4: parse error on input ‘=’
14:18:20 <meditans`> and not get an error, like in http://okmij.org/ftp/Haskell/Prepose.hs
14:18:35 <shachaf> What error would you want to get?
14:19:11 <meditans`> something like "found hole with type t", I have not enabled -fdefer-typed-holes
14:19:24 <meditans`> what's the meaning of __ = __?
14:20:18 <shachaf> __ is just an identifier.
14:20:24 <shachaf> It's the same as a = a
14:21:25 <geekosaur> meditans`, that should be a warning, not an error
14:22:28 <geekosaur> the warning is enabled by default but should be possible to disable with -fno-warn-typed-holes
14:23:00 <meditans`> shachaf, geekosaur: I see, thanks :)
14:23:52 * hackagebot aeson-injector 1.0.0.0 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.0.0.0 (NCrashed)
14:47:54 <yodeo> ahh it's a wonderful day
15:08:54 * hackagebot aeson-injector 1.0.0.1 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.0.0.1 (NCrashed)
15:38:55 * hackagebot riak-protobuf 0.22.0.0 - Haskell types for the Riak protocol buffer API  https://hackage.haskell.org/package/riak-protobuf-0.22.0.0 (lambda_foo)
15:51:22 <ggVGc> man, I started writing some Elixir(erlang kind of). pretty enjoyable, but man I miss the return types of functions
15:55:42 <EvanR> ggVGc: how about the argument types...
15:55:45 <EvanR> of functions
15:55:47 <EvanR> how about functions
15:56:00 <ggVGc> EvanR: I feel I miss the return types most of all
15:56:33 <EvanR> annotating or even acknowledging there is such a thing as a return type is something missing from many dynamic languages, and from julia
15:56:56 <EvanR> its kind of important so thats why it confuses me
16:07:00 <juanpablos> is there a way to watch changes done to a TVar?
16:07:57 <sbrg> juanpablos: sounds like you essentially just want a stream of new values?
16:08:00 <sbrg> so basically a queue
16:08:12 <sbrg> and there is TQueue
16:08:35 <juanpablos> sbrg: sounds good. thanks!
16:10:14 <mvr_> some constraint trickiness: if I have the following setup
16:10:17 <mvr_> class Action (act :: k -> * -> *) where
16:10:17 <mvr_>   type ActionOb act :: k -> Constraint
16:10:17 <mvr_>   type ActionCompose act :: k -> k -> k
16:10:49 <mvr_> is there a way specify that if (ActionOb act n) and (ActionOb act m), then (ActionOb act (ActionCompose act n m))?
16:12:18 <glguy> could you have a class method: Dict (ActionOb act n) -> Dict (ActionOb act m) -> Dict (ActionOb act (ActionCompose act n m)) ?
16:12:52 <mvr_> I'll give it a try
16:14:11 <mvr_> ah, act is ambiguous in that
16:14:23 <glguy> so you'll need a proxy argument?
16:17:38 <fr33domlover> If I have a multi typeclass (C a b) and a set of functions, all of which take a Proxy (a, b) parameter in order to pick specific a and b, is this a wrong use case for typeclasses?
16:18:56 * hackagebot xmobar 0.24 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.24 (JoseAntonioOrtegaRuiz)
16:19:26 <fr33domlover> The typeclass represents a relation between SQL tables, and schema is known at compile time, while the class methods are functions used at runtime etc.
16:19:31 <fr33domlover> feels like I could make things better
16:26:02 <mvr_> glguy: thanks, it works. shame about all the Dicting around though
16:27:55 --- mode: ChanServ set +o glguy
16:27:55 --- mode: glguy set +b-o John[Lisbeth]!*@*$##fix_your_connection glguy
16:29:53 <glguy> mvr_: You could also go with:   (AbAction act n, AbAction act m) :- AbAction act ....
16:30:24 <glguy> Data.Constraint has some tools for working with (:-) constraint implication, still not as nice as not needing any Dicts
16:31:21 <mvr_> I'll roll with this for a while and see how it goes
17:00:12 <cheater> hello
17:00:55 <cheater> if i have a simple hello world hs file, how can i make GHC output the code in terms of the Expr type as seen here? https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
17:01:57 <cht> #lambdabot
17:02:32 <glguy> The flag to core is -ddump-simpl, and there's a utility for wrapping GHC and doing that, applying a few transforms/syntax highlighting: http://hackage.haskell.org/package/ghc-core
17:03:10 <dedgrant> fr33domlover: I am doing something quite similar, but I've a mixed bag of newtypes and type families instead of classes.
17:03:19 <cht> @pl \x -> justIf (f x) x
17:03:19 <lambdabot> justIf =<< f
17:04:37 <glguy> cht: You can play with lambdabot in /msg
17:05:32 <dedgrant> fr33domlover: I've found it is tricky to keep instances unique and coherent when following the defaulting rules of typeclasses over many parameters.
17:05:55 <cheater> glguy: -ddump-simpl displays code that looks just like normal haskell
17:06:17 <cheater> there's a few things added but it generally looks the same
17:06:56 <cheater> here's an example main = putStrLn (unpackCString# "Hello!"#)
17:07:11 <glguy> I know
17:07:59 <cheater> i even added a let on the source code, as in main = let hello = "Hello" in putStrLn hello
17:08:05 <cheater> and i don't see anything related to that
17:08:49 <glguy> it was "compiled away"
17:09:38 <cheater> sure but even if i'd still expect some of the constructors in the Expr type to show up
17:10:02 <glguy> They don't, they show up in a syntax that looks a lot like Haskell
17:10:21 <cheater> sorry, i didn't quite get that
17:10:31 <cheater> you say the constructors don't show up, and then that they show up?
17:10:47 <glguy> You won't see an App constructor, you'll just see function application
17:13:02 <cheater> right i am looking for some way to output those things though
17:13:41 <cheater> that's my original query: if i have a simple hello world hs file, how can i make GHC output the code in terms of the Expr type as seen here? https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
17:14:40 <glguy> You can make a GHC plugin to do that
17:15:43 <cheater> i was hoping there was an existing way to get some form of output already
17:26:36 <cheater> maybe i can use the GHC module, hmm
17:27:50 <radoye> hello! how do people deal with tests when doing type-level stuff?
17:29:07 <cheater> what sort of type level stuff?
17:29:48 <EvanR> test1 : fact 5 = 120
17:30:15 <EvanR> warning, not haskell
17:30:21 <slack1256> so equality at type-level?
17:30:37 <Enigmagic> :t Refl
17:30:39 <lambdabot> forall (k :: BOX) (b :: k). b :~: b
17:30:51 <EvanR> that particular equality at type level constitutes a classic unit test
17:31:24 <radoye> cheater : when writing type families etc. 
17:31:37 <cheater> what would you like to test about them?
17:31:43 <radoye> as a sanity check when messing with stuff
17:32:24 <radoye> same thing I'd want to test when writing normal (value-level) code .. have a set of tests to re-run & make sure I did not mess things up 
17:33:18 <Enigmagic> radoye: i do stuff like this https://github.com/alphaHeavy/llvm-general-typed/blob/75c39111f7fc685aacb3eaf1b2948451e7222e0b/llvm-general-typed-pure/test/Test.hs#L25-L43
17:34:11 <cheater> radoye: when writing normal haskell code i use types to tell me that..
17:34:30 <cheater> radoye: alternatively if i'm writing a lib a few small programs that use it
17:35:29 <cheater> so you have the types that are theorems and the programs and code are proofs
17:35:56 <cheater> so if you change programs you want the types to still hold, that is, if you change the proof of a theorem, you want the theorem to still hold
17:36:29 <cheater> now when you go and start changing types (including type families) you want to have some proofs that stay constant while you're doing that
17:36:48 <radoye> Enigmagic : hmm ... I don't quite understand that code, do you have a pointer to something simpler where i can start reading?
17:36:53 <cheater> so i'd say, write some code that exercises your types and type families, and see that it still compiles when you're changing your type families
17:37:34 <radoye> cheater : right, that's what I'm doing now ... I guess i wanted something a bit more focused, but thanks 
17:38:08 <Enigmagic> radoye: well what do you want to test? the basic idea is that "Refl :: Int :~: Float" will fail to compile but "Refl :: Int :~: Int" will compile
17:38:58 * hackagebot generic-deriving 1.10.7 - Generic programming library for generalised deriving.  https://hackage.haskell.org/package/generic-deriving-1.10.7 (ryanglscott)
17:39:01 <Enigmagic> radoye: so if you have some type family "F a" you can write assertions about what type will be returned from applying some type to F
17:40:24 <radoye> Enigmagic : hmm, I see. how does that mix with types that have type variables?
17:44:51 <Enigmagic> radoye: depends on the type family...
17:45:30 <Enigmagic> something like this would work: type family F (a :: * -> *) :: * -> *
17:45:37 <Enigmagic> Refl :: F Maybe :~: F []
17:45:46 <Enigmagic> with the correct instances ;-)
17:46:00 <radoye> Enigmagic : ok, thanks. I'll go learn more about the "Refl/:~:" thing and try to use it.
17:46:17 <radoye> cheers!
17:57:50 <danilo2> Hello guys! :) Is it possible in GHC >= 8.0 to define a type family : type family Binding t :: * -> * and its instance wich would do something like the following (illegal) one: type instance Binding Flat a = a ? So I want to create just an identity instance for type family declaration of kind * -> * . 
18:01:52 <erisco> danilo2, I am confused by your question. If I remember the syntax correctly, I think it may be  type family Binding (t :: * -> *)  you are looking for
18:03:38 <danilo2> erisco: No, I want the type family parameter t to have kind *. I want the type family kind to be * -> *, so the correct definition is type family Binding t :: * -> * . Now I want to define the instance like in my example, but GHC would reject it. GHC would allow it if we define the type family as type family Binding t a :: *, but I dont want the a parameter there. Is it clear now ?
18:04:28 <erisco> it is clearer. What sense is there in this extra parameter?
18:04:46 <erisco> you do not want to define the type family to have two parameters, yet you wish instances to have two parameters? I cannot make sense of this
18:05:51 <danilo2> erisco: the `a` is just a value that should NOT affect the resolution of the type family, so it should not be allowed to reference in the instances. The instances should be just wrappers around this type variable OR type level identity (if its possible)
18:06:30 <danilo2> erisco: I dont want instances to have 2 parameters. I want to create an identity instance that behaves LIKE this one, but for the definition with one parameter
18:06:54 <erisco> maybe you can show another example
18:06:55 <danilo2> erisco: please note that theoretically it could be possible to define such ID instance, because it does NOT depend on the parameter
18:07:18 <erisco> I trust that it makes sense to you. I am just struggling to understand it
18:08:19 <danilo2> erisco: there is no another example. Using other words. I've got family: `type family Binding t :: * -> *` and type `Flat` I want to create instance, which for given type `Flat` would return me an identity type transformation, so `Binding Flat Int` would result in Int
18:08:33 <erisco> it is like saying you have a function Int -> Int, but you want to call this function with two Ints instead of one, but this is okay because the second Int isn't used in the definition
18:08:57 <glguy> Danilo2: that doesn't sound possible
18:09:02 <danilo2> erisco: please look at my explanation above.
18:09:36 <erisco> can you explain it with functions on values?
18:09:46 <danilo2> glguy: I was afraid it is not. I can of course create a "identity" newtype and use it as a dummy wraper whenever I need this solution, but its just a little ugly
18:10:48 <erisco> what is an identity type?
18:11:04 <erisco> "identity type transformation" what is this?
18:11:28 <danilo2> erisco: by identity transformation type I mean a type `ID :: * -> *` which behaves like following closed TF: `type family ID a where ID a = a` 
18:11:30 <glguy> newtype Identity a = MkIdentity a <- that
18:11:56 <erisco> * -> * is not the kind of types
18:12:26 <danilo2> erisco: functions on type level / types / type families . In newer GHC these terms are very close imo
18:12:27 <erisco> functions are first order, i.e. functions are values, but this is not the same for types and type families
18:12:37 <erisco> type functions are not types
18:12:53 <glguy> Identity is a type, and has kind  * -> * in my code
18:12:59 <erisco> it is not a type
18:13:04 <glguy> It is
18:13:14 <erisco> the kind of types is *
18:13:19 <glguy> No
18:13:40 <erisco> well, please give me a source on this information
18:13:46 <erisco> I must be misinformed then
18:15:25 <glguy> Haskell Report 2010, section 4.1.1 "The symbol * is the kind of all nullary type constructors" is probably what you're thinking of
18:15:55 <glguy> You can read more in 4.1.2 Syntax of Types
18:16:06 <glguy> • Maybe and IO are unary type constructors, and treated as types with kind ∗ → ∗
18:16:10 <erisco> you
18:16:15 <erisco> 're talking about type constructors
18:16:21 <erisco> I am talking about types
18:16:26 <glguy> Bool, IO, Maybe, these are all type constructors for types
18:16:31 <erisco> a type constructor and a type function have the same kind signature
18:16:35 <glguy> Either String is a type, but not a type constructor
18:16:39 <erisco> I am not arguing with you there
18:16:41 <erisco> but Identity is not a type
18:16:49 <erisco> type constructors are not the same as types
18:16:49 <glguy> It's a type constructor and a type
18:16:55 <glguy> Type constructors construct types
18:16:59 <erisco> yes, they do
18:17:00 <glguy> like data consturctors construct values
18:17:02 <erisco> yet they are not types
18:17:08 <glguy> Just is a data constructor, True is too
18:17:12 <erisco> just like Int -> Int is not itself an Int
18:17:13 <glguy> Maybe is a type constructor, Int is too
18:17:31 <erisco> 3 is a nullary function
18:17:34 <glguy> They both make types
18:17:36 <glguy> 3 is not a function
18:17:41 <erisco> this is silly terminology at this point, meaningless
18:17:54 <danilo2>  erisco: could you provide any source for your statements? I'm on the same side as glguy here
18:17:54 <erisco> you're arguing that Int is a nullary type constructor
18:17:57 <glguy> It's just the terminology of the Haskell report, when we all use the same terminology it helps
18:17:58 <erisco> yet 3 is not a nullary function
18:18:05 <glguy> danilo2: I'm citing the Haskell report
18:18:08 <erisco> well, the distinction is critical here
18:18:20 <erisco> the reason this cannot possibly work is because * and * -> * are different kinds
18:18:23 <glguy> Don't confuse type constructors with types of kind * -> ...
18:18:33 <erisco> things of kind * -> * are not types
18:18:38 <glguy> They are
18:18:48 <erisco> the source you cite is no evidence of this
18:18:53 <glguy> Either String   is a type with kind * -> *
18:19:05 <danilo2> glguy: I know – I was asking erisco  where are the information that Identity is not considered a type
18:19:06 <glguy> • The function type is written as (->) and has kind ∗ → ∗ → ∗
18:19:22 <erisco> glguy, also is no evidence of your statement
18:19:36 <danilo2> of course :)
18:19:57 <glguy>  Type application. If t1 is a type of kind κ1 → κ2 and t2 is a type of kind κ1, then t1 t2 is a type
18:19:57 <glguy> expression of kind κ2.
18:20:13 <glguy> So given Either and String, we can have    Either String, a type with kind * -> *
18:20:37 <glguy> Identity is a type constructor as defined by the newtype, it makes a type
18:21:42 <glguy> erisco: function and type constructor are unrelated, this is why it's OK to have a nullary type  constructor but not a nullary function
18:22:17 <glguy> 3 can be a "nullary data constructor", but not a "nullary function"
18:22:42 <erisco> let me explain this with an example, because we're in the weeds on nomenclature here
18:22:57 <erisco> type family Foo :: *; type instance Foo = Maybe
18:23:01 <erisco> why does this fail?
18:23:27 <danilo2> because kinds doesnt match
18:23:32 <erisco> yes
18:24:00 <erisco> so, your type family Binding has kind * -> *, yet you are expecting Binding applied to some type should yield something of kind * -> *
18:24:07 <erisco> right? because you want it to yield the identity function on types
18:24:11 <erisco> but * -> * doesn't fit with *
18:24:15 <erisco> no more than Int -> Int fits with Int
18:24:26 <danilo2> erisco: you are wrong here, look
18:24:34 <danilo2> Binding Flat has kind * -> *
18:24:39 <glguy> You might have missed an argument in families syntax
18:24:40 <danilo2> in particular if you look at
18:24:46 <danilo2> type family ID a where ID a = a 
18:24:50 <danilo2> then ID :: * -> *
18:25:00 <danilo2> so theoretically it would be possible to have
18:25:16 <danilo2> Binding Flat Int = Int , because Binding Flat :: * -> *
18:25:37 <erisco> danilo2, ah, then I think you and I are seeing the same thing now. I have misread the notation
18:26:08 <danilo2> erisco: :)
18:28:10 <erisco> type families must occur fully applied danilo2
18:28:37 <erisco> so you have the choice of a type constructor, which cannot possibly be the identity function
18:28:41 <erisco> or you have a type family
18:28:46 <erisco> but type families must be fully applied
18:28:52 <erisco> so it is impossible to do what you want on that basis
18:29:05 <erisco> barring some other way to denote things of kind * -> *
18:29:59 <erisco> as I remember reading, this restriction is to prevent general recursion happening in types
18:30:22 <erisco> or it is to do with type inference, or something… but type inference is already mostly hopeless for type families so I'm not sure
18:30:40 <danilo2> erisco: I know it - this is the error GHC complains about. I was just asking if there is some new magic in GHC > 8.0 to allow something like this
18:30:52 <glguy> Yeah, I think that the type family saturation rules are specifically designed to stop you from doing this :)
18:30:52 <geekosaur> they keep talking about adding some way to access Fc's type lambdas
18:30:58 <geekosaur> but it hasn't been done yet
18:31:55 <geekosaur> I presume they want to make sure you know exactly what you're doing and/or limit the violence it does to the rest of the type system...
18:32:02 <erisco> glguy, I think I have assumed terminology different than what is standard in the spec, sorry
18:32:58 <danilo2> geekosaur: in most cases it makes perfect sense, but sometimes it would be so helpful. Just like UndecidalbeInstances
18:33:58 <erisco> there is TH
18:34:17 <ctesiphon> hey; I have a questions, if you don't mind.
18:34:28 <geekosaur> ask
18:34:42 <erisco> I think Haskell is going to suffer from these new type system features, but unavoidably
18:34:52 <geekosaur> (in general it's better to just ask, even if there are other discussions going on)
18:35:27 <ctesiphon> suppose I want to benchmark a bunch of different containers, many of which with overlapping method names - lookup, insert, alter, etc, using criterion. do I really have to write the names a dozen times, or is there a way to reduce boilerplate?
18:35:29 <geekosaur> erisco, I am pretty sure that is a large part of why (a) true type lambdas have not yet happened (b) dependent typing is going VERY slowly
18:36:38 <geekosaur> I mean, if they really wanted to do dependent typing, ghc 10.0.1 would just be the current agda with : and :: swapped >.>
18:36:40 <erisco> the way I see it you can conserve the way Haskell is and eventually die to obsolescence, or you can adapt Haskell and eventually die to obscurity
18:36:46 <erisco> but that is how these things go isn't it
18:38:18 <geekosaur> ctesiphon, I think for reducing boilerplate there the options are (a) cpp macros (b) clever TH use (c) one of the typeclass container wrappers on hackage, at a performance penalty you probably don't want for benchmarking
18:38:39 <erisco> lets just not outrace the adoption of Haskell
18:39:08 <erisco> mainstream picks it up by the time the functional pundits have jumped ship
18:40:29 <ctesiphon> geekosaur: I think I'm sticking to TH. can you just elaborate on what clever means? I can do the rest myself, thanks
18:40:51 <erisco> supply me with cleverness and I can do the rest ;)
18:40:54 <geekosaur> mostly it means that whuile I'm reasonably sure TH can do it, I'm no TH programmer
18:41:07 <geekosaur> it might not even be that clever in practice, just stuff I don't really know
18:42:35 <geekosaur> (considering I once tried to answer one of danilo2's questions and rapidly found myself breathing vacuum because what looked simple went way deeper than I have any clue about quickly... :)
18:44:32 <glguy> ctesiphon: You might even get away with using functions. do you have some example code you could paste showing the boilerplate you want to remove?
18:44:51 <ctesiphon> glguy: sure
18:45:11 <ctesiphon> although I'll need to find out how to send multiline messages here
18:45:15 <glguy> ?lpaste
18:45:15 <lambdabot> Haskell pastebin: http://lpaste.net/
18:45:19 <erisco> I wrote a couple quasi-quoters… only enough to be mildly frustrated by it. I wouldn't leap to TH to solve anything
18:45:26 <ctesiphon> ah, that also works. thanks glguy 
18:45:55 <monochrom> You compute the MD5 checksum of your multiline message, then post the MD5 checksum, and let us reverse-engineer the message.
18:46:03 <geekosaur> heh
18:46:09 <glguy> Yeah, either the pastebin or that
18:46:28 <monochrom> And it's MD5, don't do SHA65536, that would be too hard for us.
18:46:43 <erisco> I think rot13 would be more appropriate
18:47:04 <monochrom> rot13 is as big as the original message. we want compression.
18:47:08 <glguy> rot13 would probably result in flooding the channel
18:47:26 <Koterpillar> base64 . gzip ?
18:47:49 <erisco> well, just speaking to the difficulty component ;)
18:48:18 <erisco> are you in the camp that says procedural generation is just crappy compression monochrom?
18:49:04 <monochrom> no, I'm in the camp that says procedural generation is decompression, and non-judgmental about crappy or not.
18:50:08 <erisco> I was going to retort, but actually that is a fair characterisation of it
18:50:11 <monochrom> "de" is self-adjoint, i.e., (generation is decompression) iff (degeneration is compression).
18:50:27 <erisco> see, you'll read that they compressed universes onto floppy disks by using procedural generation techniques
18:50:37 <erisco> but you're right, it is really just decompression
18:50:43 <erisco> decompressing what? no one knows really
18:51:01 <erisco> to say it was compression would be to suggestion you were ever going in the other direction, which no one is
18:51:23 <ctesiphon> glguy: http://lpaste.net/172074
18:52:01 <ctesiphon> (I made a small correction)
18:53:39 <erisco> unless the function is periodic I don't see how you could go in the other direction
18:54:03 <edwardk> erisco: well, back when farbrausch made .kkrieger (http://www.farbrausch.com/prod.py?which=114) they did provide tools for generating content in procedural format -- for 'painting' that way
18:54:26 <erisco> decompressing you generate data until you exceed your fixed width numbers
18:54:35 <edwardk> similarly when folks build up complicated signed distance fields for demoscene use, its often layers of noise painted by hand
18:54:44 <erisco> you can't start compressing an infinite data set
18:55:46 <erisco> edwardk, they are layering the machine generated data with human generated data, but this is still in the decompression direction
18:55:54 <edwardk> you presuppose that it can compress anything, which is provably impossible, so ultimately you're just looking to section the decompression process and describe a subset of possible things that the decompressor can reconstitute from a small enough seed. not looking for a full inverse to decompression, just a right inverse
18:57:25 <erisco> well, I am wondering if the relation to compression/decompression is coherent at all
18:57:29 <edwardk> you need something of the form decompress . compress = id, for procedural generation to be convenient, randomly generate some nice parts of the space, pick ones with good features, then you can send them into the decompressor and combine/paint with them. you may _want_ compress . decompress = id, but that isn't necessary or generally computable in practice
18:58:52 <erisco> what is "compress"?
19:00:12 <erisco> edwardk, are you also ekmett?
19:00:39 <edwardk> er do i have that backwards? compress . decompress = id, would assume decompress is injective (which is a bit restrictive for generative techniques)
19:00:44 <edwardk> yes
19:01:28 <edwardk> decompress . compress = id would assume decompress is 'onto' or surjective, which is also a bit ambitious for something that typically is viewed as having an infinite domain
19:02:11 <edwardk> in practice when using procedural techniques we start with an idea of what we want and hill climb towards a better approximation of it by hand, then record the process
19:02:49 <erisco> in practice where is compress used?
19:03:44 <edwardk> in practice we simply generate, inspect and hill climb through whatever coherent generation properties decompress has, rather than look for an actual inverse to it
19:04:37 <erisco> the hill climbing process… is this tinkering with the decompress function or is it tinkering with the decompressed data?
19:05:09 <edwardk> usually with decompressed data. i get out data i don't quite like, add a bit of noise to, say, better model the warped surface i want to paint, etc.
19:05:15 <erisco> what I have read is that they weight the machine generated data with human generated data
19:05:30 <edwardk> once you change the decompression function you'll usually invalidate all the stuff you generated before
19:05:34 <erisco> so if we're doing landscapes, say, you can weight an area to be higher, and an area to be flatter, and so on
19:06:09 <edwardk> yes. i'd typically start with just some random noise, then maybe add a low resolution weight grid to help steer it
19:06:30 <edwardk> keep nudging the data until it looks "right" and sufficiently rich
19:06:34 <erisco> and if generation is one-time, i.e. not on the fly, then yes you can then freely edit what was been generated to obtain a final product
19:06:38 <erisco> I think this is what they are using in movies
19:06:57 <erisco> not a possibility in No Man's Sky, say, I'd have to reason
19:07:35 <edwardk> sure, but then you ave things like dwarf fortress which just brute forces history, models erosion over time, etc.
19:07:46 <edwardk> it generates a starting state and then simulates it forward
19:08:12 <edwardk> without something like that you are stuck faking it with a shallow 'pure function of time' with no memory
19:08:28 <erisco> by on-the-fly I mean you must incrementally generate more data as the dataset is explored
19:08:40 <erisco> so there is no opportunity for a human to add final touches before it is presented
19:09:24 <edwardk> e.g. the spider shadertoy at the bottom of http://iquilezles.org/www/articles/smin/smin.htm is impressive. it runs a full ik solution every pixel to avoid needing any memory
19:10:02 <edwardk> sure, that is the same sort of experience you get wandering around the mandelbulb, etc.
19:10:37 <edwardk> its a pretty thankless task though, big worlds with no 'history' tend to peel pretty plastic.
19:11:08 <edwardk> i guess this long-since drifted into #haskell-offtopic
19:12:27 <edwardk> Anyways, even with No Man's Sky, you'll note they pick the nicest seeds for demo purposes at big gaming conventions. ;)
19:13:08 <erisco> billions of kilometers of space yet you'll be bored of the game in a few dozen hours. Yes, thankless :P
19:13:44 <erisco> I don't know about that. At E3 last year their CEO choose a rather lousy planet
19:14:11 <erisco> also commenting on how it was being chosen randomly
19:14:53 <edwardk> i can't remember which video i watched where they were talking about selecting it for the interviewer, so they could have a couple of planets nearby and a bunch of moons or something
19:15:41 <edwardk> but if you want a good example of where procedural generation can be fairly epic, have you seen any of the dwarf fortress playthrough logs, like roomcarnage?
19:16:36 <edwardk> roomcarnage probably kept me reading longer than no man's sky kept you playing ;)
19:16:40 <erisco> I have never watched Dwarf Fortress, which must be a crime
19:17:13 <erisco> NMS isn't out until August
19:17:15 <edwardk> http://www.bay12forums.com/smf/index.php?topic=139393.0
19:17:44 <edwardk> oh sorry, read 'you'll be bored' as 'i was bored'
19:18:05 <edwardk> anyways i recommend the vertical layout of that
19:18:22 <edwardk> and i'm switching this conversation to #haskell-offtopic ;)
19:18:31 <edwardk> i'll happily chatter there though
19:18:52 <edwardk> question: does anybody have openvr bindings hacked up for haskell yet?
19:38:57 <anohigisavay> hi.
19:39:27 <dmj`> anohigisavay: hi
19:39:29 <erisco> anohigisavay, greetings
19:39:39 <anohigisavay> i remeber having seen the 'default' keyword appear differently from `default (Int, Double)` or so
19:39:46 <dfeuer> edwardk, no, I don't understand how the newtype definition is better at getting the correct bottoms. That makes little sense to me. And as far as I can tell, it does not do so reliably.
19:39:57 <anohigisavay> but i can't find any info about that
19:40:12 <anohigisavay> in data declaration maybe?
19:40:19 <edwardk> dfeuer: there are multiple issues
19:40:27 <edwardk> newtype Void = Void Void works on any correct haskell compiler
19:40:31 <edwardk> its portable to not just ghc
19:40:34 <dmj`> anohigisavay: in a typeclass?
19:40:56 <dfeuer> edwardk, the question is not that vs  data Void. The question is that vs. data Void = Void !Void
19:41:00 <edwardk> then the secondary issue that is independent of if you use newtype Void = Void Void or data Void is that you _still_ want to seq the input in absurd
19:41:24 <edwardk> data Void = Void !Void is 'heavier'
19:41:44 <dfeuer> edwardk, also, note that the new thing implicitly seqs, because empty case desugars to a Core case, which seqs.
19:41:50 <edwardk> it is only used to work around an explicitly known ghc bug in a particular compiler
19:41:52 <geekosaur> anohigisavay, the only other usage of `default` is with the DefaultSignatures extension, which is part of typeclass syntax
19:41:53 <dfeuer> Heavier how?
19:42:26 <edwardk> newtype Void = Void Void should work everywhere but there was a bug in a specific ghc compiler that someone noted that caused us to have to use the data mess
19:42:32 <geekosaur> unless you mean ExtendedDefaultRules, or some of the speculation about string Defaulting that was on -cafe a couple years back
19:43:13 <dfeuer> edwardk, if you define  newtype Void = Void Void in GHC 7.10, and then define  absurd x = x `seq` case x of Void x' -> absurd x', then the compiler "optimizes" it into an infinite loop that doesn't force the argument.
19:43:23 <edwardk> heavier because it is a data type wrapper, so it implicitly requires the plumbing for building a data constructor, etc. even if it is an absurd one there is some void constructor
19:43:40 <edwardk> is absurd defined that way or with absurd !x = undefined ?
19:43:50 <dfeuer> edwardk, you're complaining because GHC generates a definition of the constructor function?
19:44:11 <dfeuer> In base, absurd is defined    absurd x = case x of {}
19:44:16 <edwardk> in void
19:44:55 <edwardk> ghc 7.10 does an optimization, but it never gets fed the code in src-old in the void package
19:44:59 <dfeuer> No, it's not defined that way, but that way is the logical translation of the version that works for data Void = Void !Void
19:45:41 <dfeuer> My point is that the code in void exists only for compatibility with implementations other than recent GHC, for which data Void = Void !Void strikes me as a rather safer bet.
19:45:50 <edwardk> the problem with absurd x = case x of {} isn't isn't as good as the absurd !x = undefined form whe n given an unsafeCoerce () as a Void value
19:46:18 <glguy> edwardk: I simplified the license checking Setup.hs I mentioned the other day https://github.com/glguy/irc-core/blob/v2/Setup.hs
19:46:31 <edwardk> in the absurd !x = undefined form you get at least some exception
19:46:47 <edwardk> (or in the current form you get a <<loop>> to detect)
19:47:01 <dfeuer> edwardk, oh, because you'd rather fall back on "You are an idiot and misused unsafeCoerce and now you've inhabited Void" rather than just crashing with an internal error or whatever?
19:47:08 <edwardk> yes
19:47:34 <dfeuer> People who mess up using unsafeCoerce *normally* end up completely screwed; why should this be a special exception to the rule?
19:47:50 <edwardk> given that it has happened in the wild to users who were _sure_ their uninhabited data type was really uninhabited and used the unsafeVacuous stuff
19:48:12 <edwardk> because i can avoid completely shitting the bed on users who thought they were doing the right thing
19:48:17 <dfeuer> *nod*
19:48:55 <tippenein>    Occurs check: cannot construct the infinite type: a ~ [a]
19:49:26 <tippenein> does "Occurs check" mean anything to anyone?
19:49:42 <dfeuer> edwardk, that sounds like an interesting GHC feature request, for a pragma on a `case` expression indicating what error to throw if a case GHC has deemed impossible should appear. This would obviously work properly only with -O0, but that holds for your approach as well.
19:49:43 <edwardk> anyways, i'm not in a hurry to switch to the data Void = Void !Void encoding, as i like and trust it less and view it just as a backwards compatibility shim and don't really want to risk misunderstanding and creating an incompatibility I don't understand to remove 3 lines of code
19:49:44 <glguy> It means that the type 'a' isn't allowed to occur within itself
19:50:13 <glguy> tippenein: Through some bug you've got a case where the type would have to be an infinite loop of lists of lists of lists of lists of ....
19:50:25 <glguy> a ~ [a] means that you'd need a to be equal to [a]
19:50:32 <geekosaur> ^ and "occurs check" is the ghc internal operation that verifies that a type doesn't contain itself directly
19:50:36 <dfeuer> edwardk, incompatibility how?
19:50:38 <edwardk> tippenein: a ~ [a] means that the type would be [[[[[[[[[[[[[[[[[[[[[...]]]]]]]]]]]]]]]]]]]]]]  which isn't finite in size
19:51:24 <geekosaur> there are a few other sanity checks in a similar vein, like the coverage condition
19:51:31 <dolio> Why isn't `case unafeCoerce () :: Void of {}` an error?
19:51:34 <edwardk> i don't have a concrete case in mind, but given that the stupid package for an uninhabited data type is now on version 0.7.1 as a result of a constant stream of wibbles and gotchas i'm not inclined to risk inducing another one
19:52:30 <dfeuer> dolio, the trouble is that GHC successfully forces (), then doesn't have anywhere to branch to. Internal error.
19:52:45 <dolio> No, that isn't what happens.
19:52:48 <dolio> In ghci, at least.
19:53:05 <dolio> But that doesn't answer my question anyway.
19:53:25 <dfeuer> dolio, optimizations are needed to kill the "dead" code, I believe.
19:53:37 <edwardk> dolio: i only discovered they changed the implementation when they ported Void into base when i couldn't replicate an issue with a chunk of code someone gave me 
19:53:51 <edwardk> with the version i had
19:53:57 <alercah> dolio: Because the unsafeCoerce is never forced
19:54:10 <dolio> No, that is the wrong answer.
19:54:14 <alercah> it isn't?
19:54:22 <edwardk> i may be subtly misremembering the issue
19:54:30 <dolio> :t case () of {}
19:54:31 <lambdabot> t
19:54:37 <dolio> > case () of {}
19:54:38 <lambdabot>  *Exception: <interactive>:3:1-4: Non-exhaustive patterns in case
19:54:57 <edwardk> but it was along those lines, involving something that actually terminated when forced as void
19:55:33 <alercah> dolio: ok, I'm confused what you're trying to get at here?
19:55:47 <edwardk> if we logged #haskell-lens i could find the original issue =)
19:55:58 <dolio> The question is: why isn't `case x of {}` compiled to something that is an error _even if_ x is not bottom?
19:56:32 <edwardk> did ghc convince itself in a higher optimization level that all cases were handled?
19:57:11 <edwardk> removing the need for a __DEFAULT__ handler?
19:57:14 <dfeuer> dolio, if x :: Void, GHC is free to assume that forcing it will not terminate normally, and therefore the case never happens.
19:57:26 <alercah> dolio: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#empty-case-alternatives
19:57:26 <dfeuer> What edwardk said.
19:58:10 <dfeuer> The same goes for non-empty case with GADTs, where GHC can rule out some cases.
19:58:20 <dfeuer> Unless someone does unsafeCoerce to shoot themselves in the foot.
19:58:54 <dfeuer> I tend to assume that any time I use unsafeCoerce and something breaks, I need to be prepared to deal with both pieces.
19:59:36 <edwardk> dfeuer: alas, Data.Void.Unsafe is packaged in the same package as where this arises, so I _am_ the one prepared to deal with both pieces ;)
20:00:10 <edwardk> given that i'm the one equipping the user with a tool that might produce this case
20:00:39 <edwardk> er wait
20:00:44 <edwardk> actually that module goes the other way
20:01:00 <edwardk> oh well, sounded better until i clarified =)
20:03:15 <dolio> What is it saving by doing that optimization, I wonder?
20:03:51 <dolio> Basically, 'case x of {} = unsafeCoerce x' if x is decided to be uninhabited.
20:04:55 <shachaf> It gives you the right bottom?
20:05:01 <edwardk> (and if ghc optimizes it)
20:05:02 <dolio> Or is it doing something even weirder?
20:05:24 <dolio> shachaf: It would give you the right bottom anyway.
20:05:25 <edwardk> shachaf: i think it is so, but only if you crank up optimizations
20:06:00 <dolio> Even if it generated core with _DEFAULT_ that errors.
20:06:28 <edwardk> well if it generates the core with _DEFAULT_ then you get an error, but i mean that if it doesn't generate a _DEFAULT_ then you get the unsafeCoerce'ish thing
20:06:56 <edwardk> at least you did when someone pointed it out to me right after base incorporated Void
20:07:11 <edwardk> i can't speak to the current status
20:07:41 <dolio> Actually, I don't understand why that even makes sense.
20:08:13 <parsnipM_> how soon after you really start to use monads (make them?) do you start using monad transformers? 
20:08:14 <edwardk> quirk of the stg stack model that happened to work?
20:08:19 <dolio> Why is 'case x :: Void of {} = x' Like, why is that the operational semantics?
20:09:55 <edwardk> did you get the unsafeCoerce-like behavior to work by hand cranking to -O2?
20:10:05 <edwardk> or are you hypothesizing?
20:10:24 <dolio> I'm evaluating code. In GHCi and compiled.
20:10:41 <edwardk> and once compiled its doing this?
20:11:40 <edwardk> i never did file a ghc issue on this
20:12:07 <dolio> Okay, it actually doesn't do that on -O2.
20:12:33 <dolio> Without -O it behaves that way. With -O it's doing something else.
20:13:16 <dolio> http://lpaste.net/172087
20:13:26 <dolio> Without optimization, that prints 5.
20:13:38 <dolio> With optimization it prints a blank line for some reason.
20:14:22 <dolio> I'm not sure how that's possible.
20:14:31 <edwardk> heh
20:15:00 <edwardk> anyways, my fix was to seq and then loop myself rather than hope the seq took
20:16:28 <edwardk> i do the same sort of thing all over https://github.com/ekmett/keys/blob/master/src/Data/Key.hs#L146 -- in theory i should perhaps use bang patterns and bang pattern on the left of the = to get something more pseq like semantically
20:17:20 <edwardk> so unoptimized compiled code gets the broken semantics, but interpreted bytecode and optimized code break in different ways still
20:17:28 <edwardk> wheee
20:17:48 <edwardk> er interpreted bytecode works correctly
20:17:48 <dolio> Well, I mean, bang patterns don't act like pseq.
20:18:25 <edwardk> i was mostly referring to it for bottom selection
20:19:45 <edwardk> which may well not be sound, but i've never seen a ghc optimization take the bottom from the right of an = in the presence of a ! pattern.
20:21:05 <dolio> You've seen it do that with seq?
20:24:17 <edwardk> seq is allowed to do so, even if it doesn't in practice. but I always felt that foo !x = ... at least had the moral highground there as you have the guideline of stuff happening before the = being committed to before you cross the divide. even if the desugaring in https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/bang-patterns.html effectively
20:24:17 <edwardk> describes it as desugaring into a boring seq before the boddy
20:24:18 <edwardk> er body
20:25:14 <dolio> Yeah, it does not have that guarantee. It's not different from seq in that regard.
20:25:23 <edwardk> but i haven't been willing to pay for a full pseq
20:25:34 <edwardk> sadly
20:25:36 <dolio> The thing that reorders things doesn't even know if it came from seq or a bang pattern, I think.
20:25:41 <dolio> It's all just cases.
20:25:45 <edwardk> yep
20:27:25 <edwardk> that said, i never did check to see if the code generated by pseq was any worse
20:28:33 <songzh> Does anyone know in mmorph package, why StateT s is not an instance of MMonad?
20:28:35 <dolio> It might just be identical to the code you actually want.
20:28:54 <edwardk> songzh: try to define it with the appropriate laws you'll run out of room for your states
20:29:14 <edwardk> dolio: yeah
20:29:32 <dolio> And guaranteed to be so, instead of hopefully. :)
20:29:38 <songzh> I have to check the laws with   embed f m = StateT $ \x -> evalStateT (f (runStateT m x)) x
20:29:47 <edwardk> yeah. i'll need to pull it from GHC.Conc, but meh
20:29:51 <songzh> tell edwardk thanks
20:31:17 <edwardk> songzh: i happened to give a talk on monad homomorphisms the other day, and happened to build exactly this same class from scratch and happened to just check this law =)
20:31:55 <edwardk> two levels of state will give you something like
20:32:12 <dfeuer> edwardk, I've seen GHC 7.10 ignore the bang pattern in the absurd variant I showed!
20:32:15 <edwardk> s -> s -> ((a, s), s)   but now you have to convert that to s -> (a, s)
20:32:20 <dfeuer> (with the newtype def)
20:32:42 <dfeuer> edwardk, pseq isn't expensive.
20:32:56 <dfeuer> (at least doesn't have to be)
20:32:58 <edwardk> dfeuer: then i'll likely switch the code over to it
20:33:04 <dfeuer> I don't think.
20:33:08 <edwardk> my mental model for pseq was somewhat flawed in terms of cost
20:33:12 <dfeuer> It can probably mess up your strictness analysis though.
20:33:30 <dfeuer> Not sure.
20:33:40 <dfeuer> f !x = x `pseq` whatever   might be fine?
20:33:47 <dfeuer> Don't ask me.
20:34:17 <edwardk> dfeuer: i'll switch to pseq for the keys code, as it is morally correct
20:34:28 <rrradical> Could someone point me toward the code responsible for generating wrapping haskell functions into c function pointers? I'm trying to debug a problem on arm64. I can call regularly exported functions but not wrapped pointers.
20:34:30 <edwardk> maximizing the preservation of user supplied bottoms for the V1 code
20:34:35 <songzh> Another question is that it seems that impossible to make MFunctor for ParserT with mmorph.
20:34:50 <edwardk> which ParserT ?
20:34:57 <songzh> ParsecT
20:35:02 <songzh> Text.ParsecT
20:35:04 <edwardk> oh does `m` occur in negative position in modern parsec?
20:35:22 <edwardk> you have to build something that converts it out of CPS'd form into something like the old rep
20:35:30 <edwardk> then you can MFunctor on that, then convert back
20:35:34 <edwardk> its a pain in the ass to write the instance
20:35:56 <edwardk> i also addressed this in my zurihac talk on saturday =)
20:36:09 <songzh> are there any videos?
20:36:16 <edwardk> about why ContT and most CPS'd monads can't be functors on the category of monads.
20:36:27 <edwardk> not sure how quick they'll get up video, but it was recorded
20:36:49 <edwardk> er cps'd monad transfomers
20:37:17 <edwardk> but consider just ContT
20:37:25 <edwardk> ContT r m a = (a -> m r) -> m r
20:37:27 <songzh> I found many function in parsec are combined with Identity, and there is no way to generalize them.
20:37:31 <edwardk> m occurs in both positive and negative position
20:37:40 <songzh> Yes.
20:37:52 <edwardk> songzh: this is why i wrote the 'parsers' library
20:38:09 <edwardk> which has its own very open token parsing scheme that gets you out of that limitation
20:38:09 <songzh> I will check on that, thanks.
20:38:43 <edwardk> anyways with m in both positive and negative position you'd need a monad isomorphism (or maybe just a split mono or split epi? not sure which?) to map over it
20:39:17 <edwardk> dolio: thoughts about if you could get away with a one sided inverse and which it'd be? it makes my head hurt
20:40:34 <edwardk> songzh: another issue you'll eventually run into with mmorph is that MFunctor and MonadTrans are missing a concept. they don't give you the proof that Monad m :- Monad (t m)
20:40:50 <dolio> You want some `(m <~> n) -> ContT r m ~> ContT r n`?
20:41:15 <songzh> yes, I see that.
20:41:17 <edwardk> this means that many constructions can't be 'thought' in the mmorph framework. i haven't decided if i'm going to finish packaging up the code from the talk as a separate package or try to figure out how to get gabriel to change the mmorph api to fix it so that the extra thoughts can be thought
20:41:27 <edwardk> dolio: yeah
20:41:39 <edwardk> and trying to figure out of (m <~> n) can be weaker than monad iso
20:41:48 <edwardk> and which side of the inverse we need
20:41:49 <dolio> And the latter is just supposed to be a monad homomorphism?
20:41:52 <edwardk> yep
20:41:52 <tippenein> geekosaur: thanks. Was making sure "occurs check" was some relatively arbitrary internal ghc thing that doesn't help me figure out what the error message is about
20:42:05 <tippenein> the a ~ [a] makes sense now tho!
20:42:14 <edwardk> well, i'd like to know if, e.g. given a split epi if the result is epi or something
20:42:29 <edwardk> just stabbing, not sure about variance
20:43:00 <edwardk> tippenein: the term comes from the prolog community
20:43:39 <edwardk> tippenein: or more generally from anything doing unification. it rules out infinite terms
20:43:56 <edwardk> prolog skips the check because it is expensive and calls it a feature
20:44:20 <glguy> tippenein: It's more general than GHC internal https://en.wikipedia.org/wiki/Occurs_check
20:46:00 <tippenein> glguy: sure. I didn't think they made it up. But as someone who doesn't write compilers (unfortunately), it doesn't help me debug the problem
20:48:06 <tippenein> makes senses - "causes unification of a variable V and a structure S to fail if S contains V."
20:49:16 <tippenein> edwardk: *thumbs up* now I wanna see what kind of prolog unifications I can break
20:50:47 <edwardk> tippenein: anyways in situations where you get stuff like a ~ [a] you're usually mistakenly treating the left hand side of : as a list rather than an element or something or trying to make a list of lists of lists of lists of ... which in haskell you can interrupt the process with a newtype Foo = Foo [Foo] -- and put on and take off Foo constructors to deal
20:50:48 <edwardk> with the recursion of types
20:51:04 <edwardk> two other terms that are useful here are 'equirecursion' and 'isorecursion'
20:51:51 <edwardk> https://en.wikipedia.org/wiki/Recursive_data_type
20:53:44 <edwardk> in haskell we deal with infinitely recursive types through isorecursion w/ newtypes or explicit ADTs, putting on and taking them off acting as our sort implementation of the isomorphsism
20:54:11 <edwardk> prolog follows more the equirecursive style where it just lets you build infinite things willy nilly
20:54:57 <tippenein> you want to avoid equirecursive because of complexities?
20:55:00 <edwardk> type system features in the presence of equirecursion can be tricky or impossible to implement
20:55:25 <edwardk> so they are neat, but hard to incorporate all the other things we want into a language that has them
20:56:06 <tippenein> looks like ocaml allows it with a flag? http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora209.html
20:56:13 <edwardk> https://www.cs.cornell.edu/Courses/cs4110/2012fa/lectures/lecture27.pdf
20:57:06 <edwardk> anyways, it not only gets in the way of advanced type system features, but once you have them then many things that 'should' be type errors aren't, and it becomes much harder to figure out where you made a mistake
21:05:39 <dfeuer> Ugh. This is kind of obnoxious.
21:09:01 <ctesiphon> how would I use -XCPP or -XTemplateHaskell to define a function that can work on functions with the same name, but from different modules, all in scope?
21:09:08 <dfeuer> I want GHC to specialize some call patterns it's not inclined to.
21:10:43 <enthropy> ctesiphon, you can use the fully qualified names (provided you didn't do something like  import A as X; import B as X)
21:11:46 <ctesiphon> enthropy: the problem is that I may have well over 20 imports to modules with the same function - imagine Data.Map.Lazy.lookup, Data.Map.Strict.lookup, Data.IntMap.Lazy.lookup, etc
21:12:17 <ctesiphon> I'm attempting to perform a comprehensive benchmark of container types
21:12:29 <dolio> edwardk: http://lpaste.net/172099
21:12:36 <dolio> Isomorphism only, looks like.
21:13:21 <edwardk> damn
21:13:23 <edwardk> was a nice dream
21:13:31 <enthropy> that would be nice to have ctesiphon. I don't know CPP well, but that seems doable with template haskell
21:16:25 <edwardk> cpp can't do it. templatehaskell likely has issues as well. i don't recall a way to just ask for all occurrences of a given name in scope
21:17:27 <edwardk> lookupValueName :: String -> Q (Maybe Name)
21:17:31 <edwardk> only gives a Maybe
21:17:32 <alercah> TH could hack it
21:17:34 <edwardk> so you're hosed
21:17:42 <edwardk> how do you find the names in local scope?
21:17:48 <ctesiphon> edwardk: so I'll have to write a different benchmarking function for every different type, and this for every function I want to test. I have to admit, not looking too foward to that.
21:17:50 <edwardk> you'd have to explicitly enumerate them all
21:18:04 <alercah> actually wait
21:18:07 <alercah> let me look something up
21:18:46 <edwardk> ctesiphon: my usual approach is to make a module per module i want to test and import some CPP noise in it that x-macros whatever it needs, generating some uniform test function or structure we can share, and import that module from another
21:19:14 <edwardk> if you look at vector they use a lot of cpp to process similar module contents using whatever names are locally in scope
21:20:07 <alercah> yeah ok
21:20:12 <alercah> you can iterate over all imported modules
21:21:18 <ctesiphon> alercah: uhm.. how?
21:21:38 <enthropy> http://code.haskell.org/~aavogt/HList-benchmark/Runtime.hs might be relevant (but you don't have the same problem that different sized inputs have different types)
21:22:03 <alercah> ctesiphon: see reifyModule
21:22:31 <enthropy> it's a mess of CPP+TH I wrote a couple years ago
21:25:50 <dfeuer> The way hedge union is implemented in Data.Set and Data.Map, it allocates a bunch of JustS constructors... the alternative seems to be to hand-specialize them away. Yech.
21:25:54 <alercah> ctesiphon: you can iterate over all the imported modules, and then attempt to lookup the name in each of them, since lookupValueName will acept fully-qualified names
21:27:42 <ctesiphon_> alercah: while that does sound like an elegant solution, I think I'd still require a separate benchmarking function for each datatype because the types wouldn't match
21:28:33 <ctesiphon_> a typeclass for "benchmarkable structures that have a lookup method" would complement this solution, but at a performace cost
21:30:50 <dfeuer> ctesiphon_, FYI, I'd be very interested in seeing your final benchmark code and results.
21:32:24 <alercah> ctesiphon_: you could use the same technique to generate the functions, though, couldn't you?
21:32:25 <ctesiphon_> dfeuer: I've been wanting to give back to the Haskell community, so I'll definitely try my best to make a usable package and try to have it available to all
21:34:45 <ctesiphon_> alercah: I'm not sure, honestly
21:39:05 <ctesiphon_> I'll look into this ASAP, although right now it's 5am. thanks for your help, everyone.
21:39:07 * hackagebot glirc 2.0 - Console IRC client  https://hackage.haskell.org/package/glirc-2.0 (EricMertens)
21:39:44 * enthropy imagines a doctest for benchmarks
21:40:38 <enthropy> so you get a graph time vs. n, instead of O(n^blah)
21:44:33 <eklavya> http://lpaste.net/172104
21:45:08 <eklavya> for some reason list is supposed to be returned from replicateM in the Set version
21:45:32 <eklavya> but it errors out for list and is inferred as a instead of [a]
21:45:58 <eklavya> which is really surprising, because the code is exactly same
21:46:01 <glguy> Binary (CQLList [a]), should that have been Binary (CQLList a) ?
21:46:23 <eklavya> :P
21:46:32 <eklavya> glguy: you are the man :D
22:03:57 <__Myst__> I've always wondered
22:04:00 <__Myst__> How does the IO monad work?
22:04:18 <__Myst__> How does me typing `putStrLn "hello, world"` make a monad which does something in the so-called real world?
22:05:06 <Xe> __Myst__: look up the RealWorld data type
22:05:06 <jle`> __Myst__: the IO type is just a type describing IO computations
22:05:15 <alercah> There are a couple different ways to think about it
22:05:27 <jle`> __Myst__: when you compile a program, you're compiling that description
22:05:37 <jle`> and then your computer looks at that description
22:05:40 <jle`> and goes, "hey, i can do this"
22:05:41 <alercah> jle`'s model is one such model
22:05:42 <jle`> and it executes it
22:06:00 <__Myst__> jle`: Oh, that's not what I meant
22:06:02 <jle`> __Myst__: the "monad-ness" of it has nothing to do with how it does its job
22:06:07 <__Myst__> I meant more how the IO monad was represented internally
22:06:16 <__Myst__> What data does it hold?
22:06:18 <jle`> it's mostly compiler hooks
22:06:19 <alercah> but the model more commonly employed by Haskell compilers is that IO is simply a type-level shim to ensure that you can't execute a computation outside it
22:06:35 <__Myst__> Rather
22:06:47 <__Myst__> If I wanted to de-abstractify `putStrLn "Hello, world!"` what would I have to write in my code?
22:06:56 <__Myst__> Just for the sake of "I'm a programmer, fuck abstraction"
22:07:00 <Koterpillar> __Myst__: a new compiler
22:07:02 <jle`> you can't quite do it within haskell
22:07:02 <alercah> ^
22:07:07 <alercah> putStrLn is a compiler primitive
22:07:10 <jle`> GHC provides IO primitives
22:07:19 <__Myst__> So basically "magic"
22:07:22 <alercah> under the hood it looks a lot like an imperative compilation, but since IO is inescapable at the type level, you're required to go through its interface
22:07:36 <__Myst__> So why does the IO monad exist hten?
22:07:38 <jle`> __Myst__: you can think of it like an API that the compiler offers for building IO actions
22:07:47 <__Myst__> Why can't it just return () and be done with it?
22:07:47 <Koterpillar> well, _maybe_ putStrLn is implemented in terms of putChar, but beyond that, magic
22:07:49 <jle`> __Myst__: the type exists to describe IO actions
22:07:54 <alercah> __Myst__: Because it allows you to say very easily whether or not a function can perform IO
22:07:55 <jle`> it's useful to describe IO actions
22:08:07 <jle`> lots of programs in the real world are basically descriptions of IO actions
22:08:10 <jle`> that would be useful to have/do
22:08:16 <__Myst__> Interesting
22:08:19 <jle`> so the "IO type" lets us describe IO actions
22:08:27 <__Myst__> I come from Python
22:08:28 <jle`> in fact, almost all interestiong programs in the world are IO actions
22:08:33 <__Myst__> Were  you can go step-by-step down the rabbit hole
22:08:36 <jle`> or well, they describe IO actions
22:08:48 <alercah> jle`: that's only an abstract way of looking at it, though
22:08:50 <__Myst__> print -> directly write to stdout -> handle file descriptors yourself -> etc...
22:08:55 <Koterpillar> __Myst__: and how would you rewrite print("hello") in Python?
22:09:02 <__Myst__> sys.stdout.write("hello\n")
22:09:04 <martinium_laptop> aren't IO actions side-effects by nature?
22:09:08 <jle`> __Myst__: you can have IO actions that do that, as well
22:09:11 <Koterpillar> __Myst__: and .write()?
22:09:11 <dibblego> martinium_laptop: No.
22:09:24 <jle`> there are IO actions that you can use to write to stdout
22:09:24 <__Myst__> Koterpillar: `os.write(1, "hello\n")`
22:09:38 <Koterpillar> __Myst__: sooner or later you'll arrive at a builtin
22:09:39 <martinium_laptop> dibblego :)
22:09:46 <alercah> __Myst__: in haskell, there's no reason fundamentally that you couldn't have e.g. foo : Int -> Int perform a side effect. But by letting the compiler know that it can't, it can be optimized more aggressively
22:09:48 <__Myst__> Koterpillar: Sure, didn't expect it to happen so soon however
22:09:59 <__Myst__> alercah: The mental image of this is quite fun
22:10:03 <__Myst__> I image Rambo optimizing my code
22:10:04 <jle`> __Myst__: you can implement putStrLn in terms of other IO actions
22:10:09 <jle`> __Myst__: that's the nice part about IO actions in haskell
22:10:14 <jle`> they're very easy to assemble, put together, compose
22:10:25 <Koterpillar> @src putStrLn
22:10:25 <lambdabot> putStrLn s = do putStr s; putChar '\n'
22:10:32 <Koterpillar> @src putStr
22:10:32 <lambdabot> putStr s = hPutStr stdout s
22:10:37 <Koterpillar> @src hPutStr
22:10:37 <lambdabot> Source not found. stty: unknown mode: doofus
22:10:44 <Koterpillar> __Myst__: same thing, see?
22:10:50 <jle`> __Myst__: there's 'hPutStrLn'
22:10:59 <__Myst__> I've always been frustrated with how Haskell just handles IO
22:10:59 <jle`> which you pass in a handle, and a string, and then it prints to that handle
22:11:02 <__Myst__> I understand why it is the way it is
22:11:05 <__Myst__> But sometimes man
22:11:18 <__Myst__> I just want to `print "yo this code doesn't work"` without having to rewrite lal my code
22:11:22 <jle`> __Myst__: so `putStrLn str = hPutStrLn stdin str`
22:11:33 <jle`> you can implement putStrLn in terms of other IO actions that GHC provides
22:11:40 <alercah> __Myst__: see Debug.Trace
22:11:50 <alercah> it lets you break the IO rules for exactly that purpose
22:12:01 <Koterpillar> __Myst__: unsafePerformIO
22:12:13 <gabbiel> I want to make a terminal emulator in haskell. is it a good idea? where do I start?
22:12:14 <jle`> in fact, i probaly wouldn't consider 'putStrLn' a GHC primitive
22:12:16 <Koterpillar> __Myst__: but thanks to laziness, it can execute whenever
22:12:23 <alercah> Koterpillar: don't recommend unsafePerformIO when Debug.Trace exists please
22:13:17 <__Myst__> alercah: ah yes
22:13:22 <__Myst__> the "don't reccomend this" of Haskell
22:13:23 <jle`> __Myst__: so putStrLn isn't really that "primitive" wall, i'm sure that haskell offers most of the same primitives that python's os package provides
22:13:26 <Koterpillar> __Myst__: alercah: this is the illustration of the fact that the IO type is implemented as just a label
22:13:39 <__Myst__> Koterpillar: wow so mysognistic
22:13:41 <__Myst__> you and your labels!
22:13:45 <__Myst__> IO doesn't want to be labeled.
22:13:56 <__Myst__> IO is a strong, powerful, code-fluid type.
22:14:13 <Koterpillar> __Myst__: here's another one for you: how is (+) implemented?
22:14:14 <alercah> __Myst__: unsafePerformIO is exactly what it says on the tin :) but it breaks the compiler's assumptions about functions not performing IO so it's very dangerous. Nonetheless, it is occasionally very useful.
22:14:28 <__Myst__> alercah: "occasionally"
22:14:28 <Koterpillar> __Myst__: both in Python and Haskell
22:14:43 <gabbiel> contrary to popular belief, IO instead contaminates code
22:14:51 <__Myst__> Koterpillar: Python? Probably just unwrapping PyObject* to int and adding them how C does it
22:14:53 <__Myst__> how C does it?
22:14:56 <__Myst__> It's compiled to machien code
22:14:59 <__Myst__> So probably however my CPU does it
22:15:23 <alercah> __Myst__: basically unsafePerformIO is the shotgun pointed at your foot. Fire at your own risk
22:15:23 <Koterpillar> so it's a primitive from the language's point of view
22:15:24 <__Myst__> If we go very technically I could just reimplement + using Data.Bits or in Python's case its builtin bitwise operators
22:15:37 <jle`> __Myst__: but yeah, your furstration about how the wall "happens so soon" isn't quite true -- you can break down putStrLn into IO primitives, just like in python
22:15:42 <jle`> probably to teh same level that python offers
22:15:59 <Koterpillar> jle`: see lambdabot earlier
22:16:10 <__Myst__> Shrug
22:16:12 <__Myst__> Haskell is fun
22:16:18 <__Myst__> If you do `~Python` you get Haskell
22:16:24 <__Myst__> I guess that's why I enjoy both
22:16:51 <gabbiel> isn't putStrLn xs = putStr xs >> putStr "\n"
22:17:00 <__Myst__> gabbiel: putChar '\n' rather?
22:17:10 <Koterpillar> @src putStrLn
22:17:11 <lambdabot> putStrLn s = do putStr s; putChar '\n'
22:17:12 <jle`> yeah, the statement that putStrLn was a primitive earlier is untrue and potentially misleading/confusing
22:17:20 <gabbiel> yeah, thas better
22:17:26 <Koterpillar> @src putStr
22:17:26 <lambdabot> putStr s = hPutStr stdout s
22:17:34 <Koterpillar> here you go
22:17:43 <__Myst__> @src join
22:17:43 <lambdabot> join x = x >>= id
22:17:47 <__Myst__> hah.
22:17:50 <__Myst__> @join id
22:17:50 <lambdabot> Not enough privileges
22:17:53 <__Myst__> woops
22:17:54 <__Myst__> @src id
22:17:54 <lambdabot> id x = x
22:18:00 <__Myst__> well that's simplistic
22:18:09 <__Myst__> @src map
22:18:09 <lambdabot> map _ []     = []
22:18:09 <lambdabot> map f (x:xs) = f x : map f xs
22:18:13 <__Myst__> @src mapM
22:18:13 <lambdabot> mapM f as = sequence (map f as)
22:18:19 <__Myst__> hahh.
22:18:22 <__Myst__> @src mapM_
22:18:22 <lambdabot> mapM_ f as = sequence_ (map f as)
22:18:27 <__Myst__> @src sequence
22:18:27 <lambdabot> sequence []     = return []
22:18:27 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:18:27 <lambdabot> --OR
22:18:27 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:18:29 <gabbiel> why isnt it sequence . map f
22:18:31 <jle`> you can use lambdabot in pm, too :)
22:18:34 <Koterpillar> I have a feeling I opened Pandora's box for __Myst__
22:18:37 <jle`> gabbiel: no reason
22:19:04 <__Myst__> @src sequence_
22:19:04 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
22:19:22 <glguy> __Myst__: You need flood in private /msg
22:19:40 <__Myst__> Actually, where can I find the whole GHC source code?
22:19:44 <__Myst__> this is quite interesting to look through
22:20:08 <gabbiel>  let {putStr [] = return (); putStr (x:xs) = putChar x >> putStr xs} in putStrLn xs = putStr xs >> putChar '\n'
22:20:08 <jle`> __Myst__: you can look at the documentation for base
22:20:10 <jle`> @hackage base
22:20:11 <lambdabot> http://hackage.haskell.org/package/base
22:20:15 <jle`> and look at the Prelude module
22:20:18 <jle`> all of the functions come with sources
22:20:30 <__Myst__> just a quick one though
22:20:32 <jle`> __Myst__: http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html
22:20:33 <__Myst__> @src (!!)
22:20:33 <lambdabot> xs     !! n | n < 0 = undefined
22:20:33 <lambdabot> []     !! _         = undefined
22:20:33 <lambdabot> (x:_)  !! 0         = x
22:20:33 <lambdabot> (_:xs) !! n         = xs !! (n-1)
22:20:59 <gabbiel> which pragmas do u guys use?
22:21:45 <__Myst__> Quick question
22:21:52 <gabbiel> libraries one should learn, go! ill start: parsec, brick
22:22:08 <jle`> gabbiel: that's a pretty open ended question heh, i just use whatever ones i need to get the job done
22:22:11 <__Myst__> Is it better to use things like
22:22:12 <jle`> *pragmas
22:22:25 <__Myst__> f x | condition x = whatever
22:22:34 <__Myst__>      | otherwise = whateverelse
22:22:37 <gabbiel> I like to use bangpatterns, and lambdacase, they're pretty useful
22:22:42 <__Myst__> or separate these as two separate function declarations?
22:22:59 <Koterpillar> __Myst__: I don't think you can
22:23:07 <__Myst__> Koterpillar: Yes I can?
22:23:10 <__Myst__> f x | condition = whatever
22:23:16 <__Myst__> f x = whateverelse
22:23:30 <Koterpillar> hmmm
22:24:07 <gabbiel> there's some people that literally do "f x | condition = s | condition2 - s' | condition3 = s'' | otherwise = s''' " in just a line
22:24:22 <__Myst__> gabbiel: oh god
22:24:46 <Koterpillar> I feel it's unnecessary to repeat the argument list here
22:24:53 <gabbiel> I know
22:24:53 <Koterpillar> if you have different arguments, sure
22:25:01 <__Myst__> A quite fun activity of mine is going to esolangs.org
22:25:07 <__Myst__> And just implementing a random language in Haskell
22:25:43 <gabbiel> hasell is built for this
22:26:10 <gabbiel> does anyone know where I can start to make a terminal emulator
22:26:13 <gabbiel> in haskell
22:27:00 <gabbiel> myst, do you use a lot of folding when implementing?
22:27:19 <Koterpillar> gabbiel: what is a PTY?
22:27:38 <gabbiel> what?
22:27:45 <__Myst__> gabbiel: I typically just code when coding, I fold my clothes at another time
22:28:03 <gabbiel> can u deacronymize that, katepillar?
22:28:12 <gabbiel> myst: bad-dum tsss
22:28:15 <dfeuer> GHC has the magic SPEC type to encourage call pattern specialization, but that's too aggressive for what I'm doing. I really only want aggressive call-pattern specialization for two of the arguments. Is this possible?
22:28:43 <Koterpillar> gabbiel: thanks for your answer. To start making a terminal emulator, you need to learn what ptys and ascii escapes are :)
22:29:37 <dfeuer> If not, I shall probably have to specialize by hand, which is ... nasty.
22:29:43 <dfeuer> Nastyish, anyway.
22:30:45 <__Myst__> Koterpillar: what's a PTY? :o
22:31:01 <gabbiel> kotepillar: just wikipidiad it, can't believe there's offensive terminilogy such as "slave" or "master"
22:31:09 <gabbiel> its basically a vty but its a fake one
22:31:14 <Koterpillar> http://man7.org/linux/man-pages/man7/pty.7.html
22:33:14 <Koterpillar> gabbiel: there are precedents that pull requests changing terminology that seemed offensive to people were merged
22:33:45 <__Myst__> Koterpillar: So basically
22:33:50 <__Myst__> a pseudo terminal is a terminal but not?
22:34:11 <Koterpillar> __Myst__: https://en.wikipedia.org/wiki/File:Termios-script-diagram.svg
22:34:15 <gabbiel> koterpillar, you guys are ok with people demanding a change in temrinology?
22:34:35 <__Myst__> where do I start Koterpillar?
22:34:54 <Koterpillar> gabbiel: I am not the author or maintainer of the Linux kernel
22:35:08 <Koterpillar> gabbiel: for my own projects, will consider
22:35:11 <glguy> crusading for terminal rights would be offtopic here
22:35:12 <gabbiel> but im saying, are you ok with it?
22:35:21 <__Myst__> dude
22:35:25 <Koterpillar> gabbiel: that's even more offtopic
22:35:26 <__Myst__> slave/master is not fucking offensive
22:35:36 <Koterpillar> ^ I hoped to prevent that
22:35:40 <__Myst__> They're two dictionary words.
22:35:56 <__Myst__> If you can tell me
22:35:56 <jle`> geting off-topic! :o
22:35:57 <__Myst__> 100%
22:36:06 <akfp> how do I disable stack's "x509-validation-1.6.3: using precompiled package" - not using precompiled?
22:36:13 <__Myst__> Any two words which have the same meaning
22:36:36 <__Myst__> Koterpillar: huh
22:36:39 <__Myst__> why does the script write to the master
22:36:42 <__Myst__> but bash write to the slave?
22:36:48 <gabbiel> i know its offtopic, but one last thing. why would u guys be ok with it, its just terminology, why not just ignore the requests?
22:37:20 <Koterpillar> gabbiel: still offtopic
22:37:21 <peddie> akfp: if you want it to rebuild the package, I think:   stack exec ghc-pkg -- unregister x509-validation-1.6.3
22:37:32 --- mode: ChanServ set +q *!*@142-196-117-128.res.bhn.net
22:37:44 <peddie> akfp: you might need a   --force
22:37:50 <Koterpillar> __Myst__: are you familiar with pipe syscall?
22:38:03 <__Myst__> Koterpillar: pipe? creates two inter-connected sockets iirc
22:38:26 <Koterpillar> yes, so ptys are a bit like that
22:39:02 <__Myst__> go on?
22:39:11 <Koterpillar> on one hand you get stdin/out/err, on the other  hand you interpret the output and feed in keyboard-like input
22:39:22 <akfp> peddie: "ghc-pkg: cannot find package x509-validation-1.6.3" - that's my problem.  stack wants to use a package that does not exist.
22:39:45 <peddie> akfp: oh, in that case, I'm not sure -- I wonder how it thought it was using a precompiled package!
22:40:06 <peddie> akfp: there is #haskell-stack if nobody here has a better idea
22:40:10 <Koterpillar> __Myst__: bash in the example can write to stdout, and you'll read it from the pty master
22:40:15 <__Myst__> Koterpillar: So baiscally the "slave" handles the user-facing
22:40:20 <__Myst__> And the "master" does all the back end
22:40:20 <akfp> peddie: thanks
22:40:45 <Koterpillar> __Myst__: no, master is the user side, slave is the processes you run in the vte
22:40:49 <slack1256> hehe you americans are just funny, afraid of words 
22:41:04 <__Myst__> Koterpillar: Makes sense, thanks
22:41:53 <Koterpillar> slack1256: some people can take offense if labeled american
22:42:16 <__Myst__> Koterpillar: dude
22:42:20 <__Myst__> labeling him as people
22:42:23 <glguy> The topic continues to be Haskell programming
22:42:24 <__Myst__> what if he's a dog?
22:42:32 <Koterpillar> glguy: sorry
22:42:33 <slack1256> to -blah
22:42:33 <__Myst__> glguy: I think that a bit of fun does no harm :)
22:42:55 <__Myst__> This channel is not going to go into madness because we're joking around, plus it's a dead time
22:42:59 <Koterpillar> gabbiel: I think I outlined a bit what should a vte do
22:43:23 <__Myst__> I'm an active user of ##learnpython and we joke around even while helping people
22:43:24 * __Myst__ shrugs
22:43:30 <glguy> __Myst__: That may be how you'd manage it, but that's not how we manage it
22:43:43 <slack1256> __Myst__: yeah, but we like the culture on #haskell being really on topic and helpful
22:43:48 <slack1256> plus I am already on -blah
22:44:15 <__Myst__> All work and no play makes jack a dull boy
23:14:09 * hackagebot pokemon-go-protobuf-types 0.1.0.0 - Haskell types for the Pokemon Go protobuf protocol.  https://hackage.haskell.org/package/pokemon-go-protobuf-types-0.1.0.0 (RickyElrod)
