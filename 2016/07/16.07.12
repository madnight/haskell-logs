00:03:18 * hackagebot simple-sql-parser 0.4.2 - A parser for SQL queries  https://hackage.haskell.org/package/simple-sql-parser-0.4.2 (JakeWheat)
00:10:40 <cookie16> http://espedito.homepc.it/ onehostx...)
00:31:14 <davidkart__> hi !
00:31:35 <davidkart__> I got a build problem with cabal and fpeclipse
00:31:57 <davidkart__> Here is the log :  http://pastie.org/10904769
00:32:04 <davidkart__> I forgot to say : greetings !
00:34:46 <gingitsune> I started reading learn you a haskell over the weekend. A friend of mine asked if she could join in
00:35:14 <LKoen> did you say yes?
00:35:19 <gingitsune> She has allmost no prior coding experience
00:35:22 <gingitsune> Nop
00:35:36 <gingitsune> I think it could be fun, but also kind of boring for a novice?
00:36:26 <LKoen> well, haskell is a programming language, and I don't think knowing another programming language is a prerequisite of learn you a haskell
00:37:10 <gingitsune> I think it is
00:37:20 <gingitsune> "This tutorial is aimed at people who have experience in imperative programming languages ..."
00:39:05 <EvanR> that tutorial notwithstanding, i think haskell is going to be way easier if you dont have any experience in imperative languages
00:40:07 <gingitsune> Ahh, so shes at an advantage
00:40:18 <gingitsune> I'm getting similiar vibes on stackoverflow
00:40:53 <systemfault> Less things to unlearn..
00:42:28 <trilog> EvanR: yeah, it is a shocker for most people when they start learning haskell... they find it immidating and stick with for example F# which allows you to do things "in the old way"
00:43:16 <trilog> F# is nice but it is way too complex for my taste
00:43:42 <liste> gingitsune: check out https://superginbaby.wordpress.com/2014/11/18/learning-haskell-as-a-nonprogrammer/
00:44:27 <dysfun> trilog: curious, i have an intense dislike of F#
00:44:49 <dysfun> (gained mostly from running through "try f#")
00:46:31 <trilog> dysfun: it has some nice concepts in it but it just has too many of them :)
00:46:49 <dysfun> it does feel like a kitchen sink, certainly. but i'm very well aware that ghc is too these days
00:47:13 <dysfun> at least it's a kitchen sink you can selectively enable
00:48:33 <ertesx> after years of teaching, both online and in person, my conclusion is that it does matter whether a haskell newbie has experience in an imperative language, but not as much as many people think
00:49:18 <trilog> dysfun: yep, F# is a language that tries to do it all but it isn't doing it very well
00:49:34 <ertesx> if you just teach it naturally without overemphasising anything (neither negatively ("I/O in haskell may be weird"), nor positively ("we have laziness, and it's different and great!")), i turns out to be surprisingly easy to teach
00:49:44 <ertesx> not easy to teach, just easier than one might expect
00:49:58 <jup> but is it worth it?
00:50:20 <dysfun> what, learning haskell?
00:50:23 <dysfun> i'd say so
00:50:32 <jup> yes
00:50:43 <dysfun> haskell is one of my favourite toys
00:50:52 <jup> in comparison to c#?
00:51:22 <dysfun> well, what do you want to do? if .NET framework compatibility because your company does a lot of .NET, maybe haskell isn't as useful to you
00:51:35 <ertesx> jup: it's an investment definitely, but it arguably pays off
00:51:44 <dysfun> but i think that haskell is a far more programmable language than c#
00:51:56 <eklavya> if I have several shared resources across a cluster, how do I modify them? in Scala I used to use actors to encapsulate the resource, what is the haskell way of doing it?
00:51:58 <ertesx> jup: you might even end up using it commercially these days, though it's not as easy to get a job as with C#
00:52:12 <jup> ok, tks!
00:52:22 <bartavelle> eklavya, you can do something a bit similar with "cloud haskell", although I never used it
00:52:48 <eklavya> how do people do it in general in haskell?
00:52:54 <dysfun> eklavya: in a similar vein to cloud haskell, there's also some reflex extensions
00:53:16 <eklavya> so basically the actor model?
00:53:18 <dysfun> eklavya: most people chuck it in a database and make it the db's problem
00:53:41 <eklavya> dysfun: that would require an SQL db I suppose?
00:53:58 <bartavelle> eklavya, I think your question is a bit too vague, it really depends on what your use case actually is
00:54:01 <dysfun> not necessarily. what properties do you need of it?
00:54:07 <bartavelle> if it's just RPCs, then you can just use standard webservices
00:54:30 <daniel-s> Function composition is not working as I'm expecting.
00:54:42 <daniel-s> I can do "map odd [1,2,3,4]"
00:54:55 <daniel-s> In which case I get [True, False, True, False]
00:54:57 <undreren> hey
00:54:58 <eklavya> uh, I want to be able to place orders, the product quantities should be atomically changed
00:55:09 <daniel-s> However "map . odd" gives an error.
00:55:33 <liste> daniel-s: what's the type of (.) ?
00:55:33 <dysfun> daniel-s: map is a function that takes 2 params, odd takes one. how can you compose them?
00:55:40 <bartavelle> eklavya, do you need a distributed system ?
00:55:47 <eklavya> in actor model, I could have it be done inside an actor and that would serialize modifications to it
00:56:03 <eklavya> bartavelle: force of habit, anything I do must be cloud ready :P
00:56:08 <daniel-s> dysfun: oops, compose is wrond.
00:56:12 <daniel-s> *wrong
00:56:26 <bartavelle> eklavya, well if you can keep it in a single program, then using the STM should be a pleasant experience
00:56:43 <bartavelle> if you need a distributed setup, then you can have a webservice that has an STM backed data store
00:56:50 <dysfun> eklavya: cloud haskell will give you the actor model. if you were to do it with a database, you'd want something with strong guarantees like postgres
00:56:51 <liste> daniel-s: what you want is (.) . (.), sometimes called .:
00:56:53 <bartavelle> if you need high availability, then you need to use something else :)
00:57:06 <daniel-s> I think I meant to say partial evalutation.
00:57:27 <liste> daniel-s: but usually it's more readable to write the expression pointfully
00:57:34 <eklavya> bartavelle: yeah well, there is no cassandra client :(
00:57:37 <liste> > map .: odd $ [1,2,3,4,5]
00:57:37 <dysfun> daniel-s: right, but for partial evaluation you'd do map odd
00:57:38 <lambdabot>      Couldn't match type ‘Bool’ with ‘a1 -> a -> b’
00:57:38 <lambdabot>      Expected type: [t0] -> a1 -> a -> b
00:57:38 <lambdabot>        Actual type: [t0] -> Bool
00:57:48 <eklavya> so it seems cloud haskell is closest to what I need
00:58:00 <dysfun> and we prefer to think of it as 'autocurrying'
00:58:17 <dysfun> partial evaluation is actually a compilation technique
00:58:59 <eklavya> thanks bartavelle dysfun :)
00:59:09 <undreren> > :t .:
00:59:11 <lambdabot>  <hint>:1:1: parse error on input ‘:’
00:59:15 <undreren> > :t (.:)
00:59:17 <lambdabot>  <hint>:1:1: parse error on input ‘:’
00:59:19 <ertesx> eklavya: you can also use network-transport in isolation, which can be useful, if all you need is message-based network communication
00:59:27 <dysfun> undreren: lambdabot isn't a full ghci
00:59:43 <eklavya> ertesx: let me look into that, thanks :)
00:59:47 <ertesx> eklavya: distributed-process (a.k.a. cloud haskell) gives you a lot more, including stuff like discovery
00:59:57 <ertesx> eklavya: network-transport is a component of it
01:00:12 <eklavya> oh ok
01:00:26 <eklavya> yeah I think I should explore cloud haskell
01:00:34 <undreren> dysfun: I have no idea what limitations it has, I was just trying to see what liste was doing
01:18:54 <idnb> is there a 99-exercsies in LogicT somewhere?
01:19:00 <idnb> I want to get good at using LogicT
01:19:02 <idnb> but I need practice
01:24:06 <gingitsune> liste: thanks for the link great read
01:28:21 * hackagebot tagsoup-megaparsec 0.1.0.0 - A Tag token parser and Tag specific parsing combinators  https://hackage.haskell.org/package/tagsoup-megaparsec-0.1.0.0 (kseo)
01:34:39 <LACampbell1> nick LACampbell
01:35:54 <LACampbell> I don't quite understand the difference between a type constructor and a function. I mean they both output a concrete value? What's the difference between "Just" and "let just x = Just x" ?
01:36:28 <liste> LACampbell: you can pattern match a (value) constructor
01:36:35 <LACampbell> oh
01:39:11 <srhb> LACampbell: Or to make your example even more evident (perhaps), `just = Just` :)
01:39:24 <srhb> > let just = Just in just 42
01:39:26 <lambdabot>  Just 42
01:40:17 <liste> > let just = Just in case Nothing of { (just x) -> x; Nothing -> 0 }
01:40:18 <lambdabot>  <hint>:1:39: Parse error in pattern: just
01:40:26 <lpaste> Ulrar pasted “No title” at http://lpaste.net/169594
01:40:50 <Ulrar> I'm trying to use Data.ConfigFile but I get that error when I try to compile
01:41:04 <Ulrar> And that's the first time I get one of those, what does it mean ?
01:47:26 <srhb> Ulrar: Did you read the section about Error Monad usage in the ConfigFile docs?
01:50:23 <Ulrar> srhb: I did, but I don't really understand what I'm supposed to do with it
01:51:34 <Ulrar> On the line following the one producing that error I'm just calling the items function, my goal is to iterate through the different config values defined in the file
01:53:44 <Guest10241> hi all, I am new to haskell and the auto differentiation library
01:54:10 <Guest10241> suppose i have this list of function fl = [\x -> x+1,\x->x**2]
01:54:37 <Guest10241> why cant I do map diff fl
01:55:48 <Guest10241> the error I am getting is ""Couldn't match type ‘Double’ with ‘AD s (Numeric.AD.Internal.Forward.Forward a)’"""
01:56:03 <shachaf> diff takes a polymorphic argument, but those functions have to be of a specific type.
01:56:20 <shachaf> To make it work you'd need something like ImpredicativeTypes, which GHC doesn't really support.
01:58:15 <Ulrar> srhb: Adding forceEither doesn't seem to change anything, it just pushed the error to the next line
02:10:41 <undreren> > :t fmap fmap fmap fmap
02:10:42 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:11:09 <undreren> > :t fmap
02:11:10 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:11:13 <undreren> >:t fmap
02:11:41 <undreren> fmap fmap fmap fmap
02:11:48 <undreren> > fmap fmap fmap fmap
02:11:50 <lambdabot>      No instance for (Typeable f0)
02:11:50 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
02:11:50 <lambdabot>        arising from a use of ‘show_M91117457873221177552191’
02:21:11 <srhb> Ulrar: The original example of using MonadError works in its entirety
02:21:54 <srhb> Ulrar: As does the "non-monadic" example in its entirety.
02:21:58 <srhb> Ulrar: You must be mixing the two.
02:26:21 <zyla> :t fmap fmap fmap fmap
02:26:23 <lambdabot> (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
02:27:20 <nomeata> I wonder if it were more easliy readable if GHC would infer the type
02:27:33 <nomeata> (Functor f1, Functor f2, Functor f3) => f1 (f2 (a -> b)) -> f1 (f2 (f3 a -> f3 b))
02:32:25 <Guest10241> I am trying to do something similar gradient descent using infinite list
02:33:04 <Guest10241> minimize :: (Floating a) => (a -> a) -> Maybe a
02:33:18 <Guest10241> minimize f =  find (<tolerance) candidates
02:33:26 <Ulrar> In it's entirety I'm sure, that doesn't really help me figure out what I'm doing wrong, and the error isn't helpful at all
02:33:35 <mtesseract> Hi
02:33:40 <Ulrar> Doesn't matter anyway, I used Data.Ini and it seems to work perfectly fine
02:33:41 <Guest10241> where candidates = iterate improve seed         delta = diff f         improve x  = x - learningRate*(delta x)          seed = 0.5         learningRate = 0.1         tolerance = 0.01
02:33:46 <Ulrar> And it's so much clearer
02:34:04 <merijn> Guest10241: Use lpaste for longer code snippets
02:34:48 <srhb> Ulrar: OK :) Well, I didn't see you paste what you were actually doing, which makes it hard to pinpoint the error. But great that you found a solution that works for you. :)
02:35:41 <Guest10241> http://paste.openstack.org/show/gv8sPDIRr5TQ7bCYHTU0/
02:35:57 <Guest10241> sorry for the messing up paste
02:36:17 <Guest10241> can refer to the link above
02:38:59 <Guest10241> i am getting the error : Couldn't match type ‘a’ with ‘AD s (Numeric.AD.Internal.Forward.Forward a)’
02:39:10 <Guest10241> for the code paste above
02:39:13 <Guest10241> any idea
02:39:34 <merijn> Guest10241: Impossible to say without type annotations on that code
02:40:50 <Guest10241> merijn: type annotations for which function?
02:41:43 <merijn> Guest10241: The types of diff, delta, and improve would be a start
02:45:13 <Guest10241> diff is a function in the ad library
02:45:21 <MrDetonia> I have a situation where I'm trying to return an IO (Maybe a) from a function, but I might not find the thing I want. Currently I have a type signature that looks like IO ( Maybe ( IO (Maybe a)))
02:45:21 <Guest10241> diff :: forall a. Num a => (forall s. AD s (Forward a) -> AD s (Forward a)) -> a -> a
02:45:23 <MrDetonia> is that bad?
02:45:43 <Guest10241> f :: (Num a) => a -> a
02:45:44 <Cale> MrDetonia: It's a little strange
02:45:51 <MrDetonia> that's what I was thinking
02:46:04 <MrDetonia> I'm trying to figure out a way of just using the Maybe value I want to ultimately use
02:46:15 <Cale> MrDetonia: That means it's an IO action, which may or may not produce a description of an IO action to be performed at a later time, which itself may or may not produce a result.
02:46:30 <MrDetonia> basically I'm searching for a matching IO function in a list
02:46:35 <MrDetonia> but I might not find it
02:46:47 <Cale> Well, maybe it really is okay, in that case.
02:46:54 <MrDetonia> they type of that function happens to already be IO( Maybe a)
02:46:54 <merijn> MrDetonia: Presumably you're looking for either MaybeT or something from monad-loops?
02:46:55 --- mode: Cale set -o Cale
02:47:08 <MrDetonia> merijn: no
02:47:12 <merijn> Guest10241: Try writing out all the type signatures and compiling again and paste the full error
02:47:13 <MrDetonia> I guess this is similar though
02:47:31 <MrDetonia> would it help if I pasted relavent code?
02:47:36 <Cale> Yeah, I think so.
02:47:59 <MrDetonia> k, 2 secs
02:48:11 <Cale> MrDetonia: Would you like to simply run the action you find if you find one, and do something else if it's not found?
02:48:26 <Cale> MrDetonia: If that's the case, then the solution is case ;)
02:48:59 <MrDetonia> https://ghostbin.com/paste/wx66p
02:49:17 <MrDetonia> Cale: if not found, ignore it completely
02:49:23 <tsahyt> I'm debugging an algorithm using Debug.Trace in ghci. how can I force reevaluation of something so that the trace gets printed again?
02:50:44 <MrDetonia> getCmd is then used to bind a Maybe IO action
02:50:52 <MrDetonia> and then I use a case to figure out whether to try running it
02:51:12 <MrDetonia> result <- getCmg msg
02:51:23 <Cale> sure
02:51:28 <MrDetonia> case res of { Just cmd -> cmd msg; Nothing -> Nothing }
02:51:33 <merijn> MrDetonia: Oh, I would simplify
02:51:41 <Cale> MrDetonia: Probably Nothing -> return ()
02:51:49 <merijn> Yeah, that
02:51:59 <Cale> Or return Nothing, rather
02:52:11 <Cale> since cmd msg :: IO (Maybe (Text, Text))
02:52:14 <MrDetonia> uhm yes
02:52:17 <MrDetonia> it should be return Nothing
02:52:21 <MrDetonia> and is in my actual code
02:52:37 <merijn> MrDetonia: Basically, why return "Maybe CmdFunc" instead of CmdFunc?
02:52:41 <Cale> You could merge doing that into getCmd
02:52:53 <MrDetonia> merijn: because it might not find a matching function
02:53:00 <MrDetonia> in which case I want to not do anything
02:53:15 <merijn> MrDetonia: So, you return "\_ -> return Nothing" in the unfound case?
02:53:26 <merijn> MrDetonia: i.e., why return Nothing instead of a function that does nothing?
02:53:29 <Cale> MrDetonia: If you know that you're always going to act this way in response to the Nothing, you might as well just return Nothing in that case
02:53:40 <Cale> MrDetonia: and in the other case, apply the command to the message
02:53:47 <Guest10241> merijn the full snippet and error message are here : http://paste.openstack.org/show/530803/
02:54:16 <MrDetonia> https://ghostbin.com/paste/te5hg
02:54:21 <MrDetonia> those are the functions being used
02:54:52 <MrDetonia> Maybes all over the place :v
02:55:55 <merijn> Guest10241: For some reason the line numbers are removed from your error message?
02:55:59 <Athas> Yay, FHPC acceptance.
02:56:03 <MrDetonia> I'm fairly new to the lang, so I might be missing some massively simple way of doing this
02:56:27 <MrDetonia> it makes sense to me for everything to be wrapped in a Maybe here, because I might not need to do anything at all
02:56:36 <davidkart__> :t maximum
02:56:37 <lambdabot> (Ord a, Foldable t) => t a -> a
02:56:48 <davidkart__> I don't understand what is Ord a ?
02:56:49 <Cale> MrDetonia: getCmd msg = foldr testFunc (return Nothing) cmdList where testFunc (p, cmd) k | p `T.isPrefixOf` msgContent msg = cmd msg | otherwise = k
02:57:17 <davidkart__> It's an interface ?
02:57:27 <Cale> davidkart__: It expresses the notion that a is a totally ordered type, i.e. that the operations (<), (>=), compare, etc. are defined for it
02:57:31 <merijn> davidkart__: Ord is the typeclass for ordered values
02:57:44 <Cale> :t (<)
02:57:45 <lambdabot> Ord a => a -> a -> Bool
02:58:01 <MrDetonia> Cale: hm, okay let me try that
02:58:14 <Cale> "For any ordered type a, (<) takes two values of type a, and produces a Bool result"
02:59:27 <Guest10241> merijn: Maybe it is because I am using IHaskell notebook
03:04:58 <MrDetonia> Cale: that works perfectly, thanks
03:05:23 <Guest10241> merijn: here are the full snippet with error message with correct line number https://ghostbin.com/paste/jf82w
03:08:41 <ongy> hm, Which of those lines would be better (idomatic) haskell?
03:08:43 <ongy>   mapM_ fclose [readf, writef, statef]
03:08:46 <ongy>   fclose readf >> fclose writef >> fclose statef
03:13:07 <Cale> ongy: I would prefer the first, I think
03:13:19 <Cale> If I was going to do the second, I'd use do-notation.
03:23:24 * hackagebot wire-streams 0.0.2.0 - Use cereal or binary with io-streams.  https://hackage.haskell.org/package/wire-streams-0.0.2.0 (winterland)
03:33:11 <Guest10241> can anyone help me on pointing what is wrong with my code here : https://ghostbin.com/paste/jf82w
03:35:43 <srhb> Guest10241: When you say a type is 'a' in a type signature, you're saying that that is the type for _any_ a, which GHC is telling you is a lie.
03:36:27 <srhb> Guest10241: Try removing the type signature and see what GHC infers.
03:38:25 * hackagebot xml-extractors 0.4.0.2 - Extension to the xml package to extract data from parsed xml  https://hackage.haskell.org/package/xml-extractors-0.4.0.2 (holmisen)
03:38:42 <Guest10241> srnb: I tried and I still get the similar error here https://ghostbin.com/paste/jf82w
03:39:38 <srhb> Guest10241: It's only superficially similar. They're not the same at all.
03:45:03 <srhb> Guest10241: Looks like some higher kinded problems. Hmm.
03:48:50 <srhb> Guest10241: If you use the Rank1 module, I think you can get away with (Fraction a, Num a, Ord a) => (Forward a -> Forward a) -> Maybe a
03:56:09 <srhb> Guest10241: Unless you need the higher kinds, of course. But type inference is worse then :)
03:59:25 <srhb> Guest10241: (I think it would be (Num a, Fractional a, Ord a) => (forall s. AD s (Forward a) -> AD s (Forward a)) -> Maybe a in the higher kinded way
03:59:54 <Guest10241> srnb: any pointer to what exactly goes wrong here for I am quite new to haskell
04:00:06 <srhb> Guest10241: Where?
04:02:33 <srhb> Guest10241: http://lpaste.net/1479491868398977024
04:02:51 <srhb> Guest10241: I suggest you use the Rank1 version, if at all possible, so you get better type inference and less scary type errors. :)
04:04:43 <Guest10241> srnb: Thanks alot! shall study it more
04:05:24 <undreren> Hey, I'm making a small game in Haskell in my spare time, and I am going to run it through with a monad stack. In that regard, I'm making a "backend" for the game, which has it's own data type, containing everything that is not game logic and game state. However, it will function as a container for my GLFW.Window, my Gloss.State and my Signal network, containing all the sinks, signals and generators.
04:05:46 <undreren> This seems like a good idea *in my head*, but I can't actually make out if it actually is that good.
04:07:38 <undreren> The good is that it will be totally separated from my game logic, so maybe it can be exported as an independent package.
04:08:26 * hackagebot hmpfr 0.4.0.2 - Haskell binding to the MPFR library  https://hackage.haskell.org/package/hmpfr-0.4.0.2 (MichalKonecny)
04:08:36 <undreren> But I worry that I'm in way over my head with this, for the small game I'm going to make.
04:09:32 <undreren> In effect, it seems like I am making a wrapper around GLFW-b, Gloss and Elerea
04:16:02 <ongy> is it normal for `cabal configure' to require more than 800MB of ram?
04:16:11 <Cale> undreren: I would tend to shy away from using monad transformers to construct some monad in which to build things before I really had a strong grasp of the problem domain and the operations that I would need, so that I could confirm that they were the best way to go about obtaining the effects I wanted, and weren't just going to get in the way.
04:16:20 <srhb> ongy: Doesn't sound normal. Which version of cabal-install?
04:16:37 <ongy> srhb: cabal-install version 1.20.0.3
04:17:25 <srhb> ongy: Try upgrading, if it persists it might be worth a bug report
04:17:34 <undreren> Cale: So far the stack is just StateT Game IO
04:18:34 <Cale> undreren: Yeah, I often question whether this is really saving trouble over parameter passing of some sort.
04:19:06 <Cale> undreren: It certainly makes things more annoying if you have to catch exceptions or fork threads, or any number of other higher-order IO-related things.
04:19:32 <undreren> Cale: But there'll probably be a WriterT, a ReaderT and EitherT MyOnError. But these can be added later, as needed
04:21:04 <ongy> srhb: It's the current version in debian jessie. And it just fixed itself for some reason I really don't know
04:21:23 <srhb> ongy: Well, cabal install cabal-install would still upgrade it for your user, if you have it on PATH. :)
04:21:41 <srhb> ongy: And "current" in jessie just means it isn't completely archaic (and sometimes not even that :-P)
04:21:45 <inerkick> Hi. I'm getting this issue, when tried to install ghc-mod http://lpaste.net/169601
04:22:24 <ongy> srhb: mh, not a fan but possible
04:22:28 <srhb> ongy: :)
04:22:38 <ongy> and I know, but I am familar with it for server setup
04:23:05 <srhb> ongy: Ditto. It's all we use in production, for some reason. I just loathe it for Haskell things. :-P
04:23:50 <tdammers> debian is fine for Haskell things, as long as you install the Haskell things from other sources
04:24:34 <srhb> tdammers: Yes, that's exactly what I said, if you follow the conversation. :)
04:24:44 <tdammers> oh ok
04:25:48 <tdammers> looks like I followed the conversation wrong
04:27:03 <srhb> Self-upgrading tools like cabal-install are pretty nice for that purpose. I think, prior to stack, it was mostly recommended to just get ghc and cabal-install on most distros anyway.
04:27:08 <srhb> Including Debians.
04:27:23 <srhb> Ah well, whichever works.
04:33:00 <inerkick> Kindly help installing hlint and ghcmod using stack. I am encountering this issue http://lpaste.net/169602
04:34:40 <inerkick> http://lpaste.net/169602
04:35:08 <srhb> inerkick: Yikes, that looks scary.
04:35:42 <inerkick> yeah srhb 
04:35:58 <inerkick> scared the shit out of me too srhb 
04:46:56 <Fare> where do I find a good reference on how category theory and how functors commute or interfere with usual algebraic constructions such as products, sums, etc.
04:47:08 <Fare> or where there is a short list of usual such constructions
04:47:28 <Fare> (and only semi-relatedly, is there some insightful presentation of arrows?)
04:47:58 <davidkart__> hi
04:48:07 <davidkart__> :t Ord
04:48:08 <lambdabot>     Not in scope: data constructor ‘Ord’
04:48:08 <lambdabot>     Perhaps you meant variable ‘ord’ (imported from Data.Char)
04:48:12 <davidkart__> :t ord
04:48:13 <lambdabot> Char -> Int
04:48:24 <davidkart__> can you help me what is Ord in ?
04:48:27 <davidkart__> :t maximum
04:48:28 <lambdabot> (Ord a, Foldable t) => t a -> a
04:48:39 <liste> davidkart__: Ord is a type class for types with ordering
04:48:47 <liste> :t (<)
04:48:48 <lambdabot> Ord a => a -> a -> Bool
04:48:52 <liste> :t (>)
04:48:54 <lambdabot> Ord a => a -> a -> Bool
04:49:02 <hexagoxel> @hoogle Ord
04:49:02 <lambdabot> Prelude class Eq a => Ord a
04:49:03 <lambdabot> Data.Ord class Eq a => Ord a
04:49:03 <lambdabot> Data.Ord module Data.Ord
04:49:10 <davidkart__> A type class is cool ? So Haskell is OO ?
04:49:21 <liste> davidkart__: no, type class has nothing to do with OO
04:50:20 <mniip> just because there is a class doesn't mean there are objects
04:50:37 <mniip> it's a *type* class, instantiated by types
04:50:38 <davidkart__> ok but this is the same « class » as in java eg.
04:50:48 <davidkart__> I mean
04:51:01 <davidkart__> There is a type class notion in Java
04:51:12 <davidkart__> (for strongly typed languages)
04:51:12 <liste> davidkart__: no, there's no type classes in JAva
04:51:26 <liste> there are classes which happen to be types too
04:52:22 <davidkart__> :t <
04:52:24 <lambdabot> parse error on input ‘<’
04:52:27 <davidkart__> :t (<)
04:52:28 <lambdabot> Ord a => a -> a -> Bool
04:53:46 <davidkart__> Could I define a type which implements Ord from scratch ?
04:54:33 <liste> davidkart__: yes, you can define an instance of Ord for your own type
04:54:42 <davidkart__> how would you do that ?
04:55:38 <srhb> inerkick: I can't reproduce it with that solver. Have you tried cleaning out tmp? Is your disk dying? Have you tried building it with cabal-install instead? If none of those help, I'm not sure what to do.
04:55:47 <srhb> (Well, not killing your disk obviously :-))
04:56:11 <inerkick> yeah I'm trying to build from cabal srhb . ITs kind of wrapping it up now. Lets see
04:56:20 <mniip> liste, I think java has some analogy to typeclasses?
04:56:25 <mniip> interfaces orsmth
04:56:48 <raduom> mniip: the adaptor pattern, alas no compile time type safety :)
04:57:41 <raduom> adapter* :)
04:58:48 <inerkick> srhb, It installed but got an error "hlint-1.9.35 depends on haskell-src-exts-1.17.1 which failed to install.
04:58:49 <inerkick> "
04:59:16 <liste> mniip: not really, interfaces only define the interface for objects, not types. that means that you can't have "class A a where foo :: a"
04:59:45 <mniip> I see
05:00:31 <liste> but yeah, the adapter pattern as raduom said. also you could just pass the dictionaries manually
05:01:03 <liste> Scala implements type class with passing dictionaries + implicit arguments
05:03:44 <raduom> that would be something like 'scoped' dictionaries :)
05:03:54 <liste> "interface Monoid<A> { A unit(); A combine(A val1, A val2) }" and "class IntMonoid implements Monoid<Integer> { Integer unit() {..} Integer combine (Integer val1, Integer val2) {..} }"
05:04:53 <liste> but people would look at you very weird if you did that in Java
05:14:13 <undreren> Hey
05:14:52 <liste> hi undreren 
05:15:46 <Maxdamantus> Seems reasonable to me.
05:15:59 * Maxdamantus just wishes he could write `interface Monoid<M>`
05:17:01 <liste> Maxdamantus: what do you mean?
05:17:17 <Maxdamantus> er, s/Monoid/Monad/
05:17:24 <liste> oh (:
05:18:40 <liste> Java wouldn't be too bad with a more powerful type system
05:19:52 <Maxdamantus> Indeed, and a less powerful type system.
05:19:58 <Maxdamantus> Basically, a different type system.
05:20:29 <eklavya_> which is THE TCP lib for haskell?
05:20:37 <Maxdamantus> one without subtypes (and hence without variance), but with higher-kinded generics.
05:20:42 <dibblego> http://www.functionaljava.org/javadoc/4.5/functionaljava/fj/Monoid.html
05:21:45 <Maxdamantus> and with the JSR that adds auto typing to variables.
05:21:59 <Maxdamantus> http://openjdk.java.net/jeps/286
05:33:39 <eklavya_> I want to do TCP IO should I use Network.Socket ?
05:49:17 <Guest50337> getContents bahaving strangely on long lines
05:49:21 <Guest50337> input <- getLine
05:49:21 <Guest50337>   replicateM_ (read input) (print $ take 5 getLine)
05:50:21 <Guest50337> it works fine with short lines but with a file having long lines it reads on first line, probably not reading to the end of line
05:50:52 <Axman6> take 5 getLine? that doesn't look right at all...
05:51:34 <Guest50337> i need to read several long line and solve a palindrome puzzle on them
05:51:54 <Guest50337> I seem to have solved the puzzle, but I'm stuck at input
05:52:04 <Guest50337> nothing I tried worked
05:52:10 <Guest50337> :-(
05:52:21 <Axman6> I'm confused, you're not using getCntents? was that a typo?
05:52:37 <Axman6> :t take
05:52:38 <lambdabot> Int -> [a] -> [a]
05:52:46 <Axman6> :t take 5 getLine
05:52:47 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘IO String’
05:52:47 <lambdabot>     In the second argument of ‘take’, namely ‘getLine’
05:52:47 <lambdabot>     In the expression: take 5 getLine
05:53:25 <Guest50337> I try to use get contents because on the puzzle site the arguments are read from standard input
05:53:33 <Guest50337> on local machine i do
05:53:53 <Guest50337>  cat ./input05.txt | runhaskell ./solution.hs 
05:54:02 <Axman6> what is (print $ take 5 getLine) supposed to do? it doesn't typecheck since getLine isn't a list of a's
05:54:24 <Guest50337> i just do not understand what I am doing
05:54:48 <Guest50337> i have read so many explanations that maybe I need a break
05:54:53 <Axman6> can you explain what you're trying to do then?
05:55:17 <Guest50337> I want to read severaal lines from the stream
05:55:31 <Guest50337> first line has number of lines to follow
05:55:36 <Axman6> and "several" is specified by the number passed in on the first line?
05:55:39 <Axman6> yep
05:56:09 <Axman6> so, you can do this: replicateM_ (read line) (getLine >>= putStrLn)
05:56:11 <Guest50337> following lines are almost palindromes and you have to find which character index has to be removed to make it palindrome
05:56:37 <Axman6> do you have a function which tells you that index already?
05:56:45 <Guest50337> yes
05:56:53 <Axman6> great!
05:57:11 <Axman6> so, are you expecting to print out the index for each line you read in?
05:57:11 <Guest50337> i need to pass a string and it returns either the index or -1
05:57:18 <Axman6> excellent
05:57:20 <Guest50337> i need to print the number
05:58:04 <Guest50337> I managed to solve few such puzzles in Haskell but IO is always a nightmare
05:58:10 <Axman6> so to do that, we can use this: replicateM_ (read line) (getLine >>= \myLine -> print (findError line))
05:58:19 <Axman6> yeah, it can take a while to understand
05:58:32 <Guest50337> ok i will try it
05:58:36 <Guest50337> thank you
05:59:49 <Axman6> you could also write that using do notation: https://gist.github.com/axman6/593369db1757bd68b73e2ceea20e9388
06:05:23 <dinnu93> What are the prerequisites to learn about Haskell-servant ?
06:05:49 <Guest50337> it didn't work :,-(
06:06:26 <Guest50337> following almost type checks except the (read line)  -- replicateM_ (read line) (getLine >>= \myLine -> print (solve myLine))
06:07:52 <Axman6> Guest50337: what error do you get? (if it's more thean a few lines, you should paste it on lpaste,.org)
06:09:37 <Guest50337> following works with short lines, but fails on long ones
06:09:39 <Guest50337> main = do
06:09:39 <Guest50337>   tcx <- getLine
06:09:39 <Guest50337>   let tc = read tcx
06:09:39 <Guest50337>   replicateM_ tc (getLine >>= \myLine -> print (solve myLine))
06:11:23 <Guest50337> it seems to hang after reading the first long input line
06:12:22 <Guest50337> if i remove solve and just try to print the line it chokes i do not know how to investigate it
06:12:34 <Guest50337> perhaps i shouls give up on this puzzle
06:13:57 <Bynbo7> sorry my internet died. what problem are you having with long lines?
06:15:35 <lyxia> Guest50337: you can use trace to try to follow the evaluation until you find where it hangs
06:16:06 <Axman6> Guest50337: we can probably help you more if you share the code for solve too
06:17:34 <shapr> good morning #haskell!
06:17:43 <Guest50337> @Bynbo7 haskell doesn't seem to handle long input lines well, or my knowledge of Haskell is poor, it's more likely to be  my fault
06:17:43 <lambdabot> Unknown command, try @list
06:18:05 <Axman6> good evening shapr!
06:18:29 * hackagebot tasty-rerun 1.1.6 - Run tests by filtering the test tree depending on the result of previous test  runs  https://hackage.haskell.org/package/tasty-rerun-1.1.6 (OliverCharles)
06:18:37 <Axman6> Guest50337: how long are these lines? 100's of characters? 1000s?
06:19:24 <shapr> Axman6: howdy! How's code?
06:19:38 <Guest50337> https://github.com/bigos/alguzzles/blob/25f05085c81abb834b754368fd3c6c520c3fa124/Strings/haskell/palindrome-index/solution.hs
06:19:44 <Guest50337> this is my repo
06:20:16 <Guest50337> https://github.com/bigos/alguzzles/tree/25f05085c81abb834b754368fd3c6c520c3fa124/Strings/haskell/palindrome-index  
06:20:37 <Guest50337> this folder contains problematic input05.txt
06:21:09 <Guest50337> ~/Programming/alguzzles/Strings/haskell/palindrome-index $ cat ./input05.txt | runhaskell ./solution.hs 
06:21:13 <Guest50337> fails
06:21:18 <Axman6> ah yes, looks like your algorithm might be at least O(n^2), which will fail on large inputs
06:21:23 <Guest50337> ./input0.txt works
06:21:58 <lyxia> It's never haskell's fault.
06:22:18 <Axman6> Guest50337: do you know that there will only be one character you need to change?
06:22:53 <Guest50337> if i try just print the files without going into the algorithm i also have problems
06:23:05 <Guest50337> not files, lines, sorry
06:24:07 <Axman6> you might want to try compiling your program instead of running it with runhaskell
06:24:36 <davidkart__> lyxia: are you sure ?
06:24:56 <Myrl-saki> Would mixing REST and FRP be a good idea.
06:25:29 <Axman6> Guest50337: try ghc -O2 solution.hs, that should give you a file called solution (I think) which you can execute: cat input05.txt | ./solution
06:25:57 <davidkart__> :t last 
06:25:58 <lambdabot> [a] -> a
06:26:02 <davidkart__> :t head
06:26:03 <lambdabot> [a] -> a
06:26:04 <woffs> was't it ghc --make ?
06:26:24 <Guest50337> https://www.hackerrank.com/challenges/palindrome-index
06:26:30 <Axman6> probably, it's been so long since I've called ghc directly. though I think you can forget the --make
06:26:31 <Guest50337> this is the puzzle url
06:27:41 <Guest50337> I have to paste the code in the browser and I do not know what happens to it later
06:27:59 <davidkart__> let palindrome (x:xs) = x==last xs:palindrome front x
06:28:00 <Axman6> Guest50337: there's a decent chance it'll get compiled on the server
06:28:08 <davidkart__> :t front
06:28:09 <lambdabot> Not in scope: ‘front’
06:28:16 <Axman6> davidkart__: that;s O(n^2) btw
06:28:35 <davidkart__> palindrome x = (reverse x==x)
06:28:42 <Axman6> also, front isn't a thing. you might be looking for init
06:28:49 <davidkart__> :t init
06:28:50 <lambdabot> [a] -> [a]
06:28:55 <davidkart__> ah yea that was it.
06:28:57 <Axman6> > init "Hello"
06:28:59 <lambdabot>  "Hell"
06:29:18 <davidkart__> Basically you would have at most (n/2 comparison).
06:29:47 <davidkart__> (reverse "hello"=="olleh")
06:29:54 <davidkart__> :l (reverse "hello"=="olleh")
06:30:10 <davidkart__> reverse "hello"=="olleh"
06:30:35 <davidkart__> :t reverse "hello"=="olleh"
06:30:36 <lambdabot> Bool
06:30:42 <davidkart__> :e reverse "hello"=="olleh"
06:30:49 <davidkart__> :h
06:31:00 <Axman6> you probably want >
06:31:06 <davidkart__> > reverse "hello"=="olleh"
06:31:07 <lambdabot>  True
06:32:20 <davidkart__> >palindrome "bob" where palindrome l = (reverse l == l) ; 
06:35:14 <woffs> > let palindrome l = (reverse l == l) in palindrome "bob"
06:35:16 <lambdabot>  True
06:35:31 <davidkart__> >let palindrome "helloolleh" where palindrome l = (reverse l == l) 
06:35:51 <davidkart__> > let palindrome "helloolleh" where palindrome l = (reverse l == l) 
06:35:53 <lambdabot>  <hint>:1:29: parse error on input ‘where’
06:36:08 <davidkart__> > let palindrome l = (reverse l == l) in palindrome "helloolleh"
06:36:10 <lambdabot>  True
06:36:28 <davidkart__> basically this definition is really too simple. Is it inefficient ?
06:36:29 <Guest50337> that still doesn't answer the question about long input strings, can we just print first few characters of the problematic string without going into the palindrome business?
06:36:46 <davidkart__> I don't know what was the question 
06:37:02 <magneticduck1> what's the problem with a definition being simple
06:37:07 <magneticduck1> if you want efficient, consider not using String
06:37:10 <Guest50337> i came here because I needed help with reading several lines from standard input
06:37:35 <davidkart__> ha. See you in two weeks then.
06:37:53 <davidkart__> But I advice you look on the web to find the correct boilerplate code.
06:38:14 <davidkart__> it will be fast
06:38:27 <davidkart__> and efficient.
06:38:44 <Guest50337> I seem to have correct boiler plate code, it works fine on short strings, with regards to long ones it reads only first string
06:38:54 <davidkart__> show us
06:39:17 <Guest50337> even if I skip the palindrome and try to read the string I get the problem
06:39:24 <davidkart__> show us
06:39:26 <davidkart__> the code
06:39:32 <davidkart__> http://pastie.og
06:39:35 <davidkart__> http://pastie.org
06:39:55 <Guest50337> https://raw.githubusercontent.com/bigos/alguzzles/25f05085c81abb834b754368fd3c6c520c3fa124/Strings/haskell/palindrome-index/solution.hs
06:40:46 <davidkart__> let tc = read tcx <- this is faulty
06:40:52 <davidkart__> it should be readInt
06:41:07 <Guest50337> sorry
06:41:10 <Guest50337> https://github.com/bigos/alguzzles/blob/dbabba1d81d9ee48471ff2ffee705fdfa45016fb/Strings/haskell/palindrome-index/solution.hs
06:41:10 <liste> davidkart__: it isn't very inefficient
06:41:13 <Axman6> that will that seems fine to me, from the context it knows it's an int
06:41:16 <Guest50337> this is the latest
06:41:25 <magneticduck1> I don't even know what readInt is
06:41:41 <magneticduck1> anyway, this is #haskell-beginner's raison d'etre
06:41:41 <liste> > [1,2..] == [3,4..]
06:41:43 <lambdabot>  False
06:42:29 <davidkart__> Guest50337: I suggest you put your lines into a list of Strings
06:43:09 <davidkart__> listOfLines <- replicateM_ 7 ( readLine ) it should look like.
06:43:13 <davidkart__> (not sure) 
06:43:18 <magneticduck1> davidkart__: what's readInt?
06:43:20 <davidkart__> avoid cryptic notation 
06:43:23 <davidkart__> :t readInt
06:43:24 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
06:43:45 <magneticduck1> I mean, I can see that much on hoogle -- I'm wondering what it is to you, and why you think Guest50337 should use it
06:43:57 <davidkart__> because he reads an Int from stdin
06:44:10 <magneticduck1> what it is to me is an internal function related to the Read typeclass
06:44:12 <davidkart__> he should use it to convert an IO string to an Int
06:44:27 <Clint> no he shouldn't
06:44:29 <magneticduck1> you should probably avoid giving advice x)
06:44:33 <davidkart__> ha sorry
06:44:47 <davidkart__> yes I forgot this is a function I define always when reading stdin
06:45:04 <davidkart__> magneticduck1: yes I should
06:45:08 <davidkart__> thanks for the advice
06:45:35 <Guest50337> oh dear, it's time for a break for me. i will come back to that in an hour or so. need to go back to real life and do some shopping
06:59:59 <magneticduck1> oof, I've spent too long away from Haskell
07:00:14 <magneticduck1> http://www.hastebin.com/rocofibuja.hs <- does this make sense? how would I do it? what does (Thingy c => c -> m b) actually mean?
07:00:26 <magneticduck1> it there a way of implementing `applyThingies` in any case?
07:01:48 <magneticduck1> basically I want to talk about a concrete type 'Thingy-like', that does everything Thingy can do, and can be downcast from (Thingy a => a)
07:01:59 <magneticduck1> I'm not sure if this is impossible -- perhaps I'm going about this in a very wrong way?
07:02:48 <sbrg> Thingy a => .. means that the type 'a' is an instance of the typeclass Thingy
07:03:05 <magneticduck1> indeed
07:03:12 <sbrg> i'm not sure what your question is though
07:03:29 <magneticduck1> do you see what I want to do with `applyThingies`?
07:03:33 <sbrg> nope
07:03:40 <cocreature> you might want forall c. Thingy c => c -> m b
07:04:08 <magneticduck1> cocreature: great!
07:04:11 <alercah> magneticduck1: yeah, you need to explicitly quantify as cocreature said
07:04:20 <alercah> (you also need a Monad constraint on m)
07:04:26 <cocreature> that requires RankNTypes but that’s a pretty safe extension
07:04:46 <magneticduck1> in the general case, is there any way to 'type-erase' a member of a typeclass into a concrete type that implements all the functions of the typeclass in the way that the original value did?
07:05:26 <magneticduck1> other languages might call this a 'trait object' (rust) or 'type erased reference' (C++ .. sort of)
07:06:34 <magneticduck1> I'd also like to understand more clearly why 'forall c.' is necessary there
07:07:12 <magneticduck1> what is being elided in place of that quantifier by default?
07:07:57 <sbrg> magneticduck1: You want a function that basically looks like: "Thingy c => c -> ConcreteThingyType"?
07:08:22 <magneticduck1> where `Thing ConcreteThingyType` is satisfied, yes
07:08:31 * hackagebot hoogle 5.0.1 - Haskell API Search  https://hackage.haskell.org/package/hoogle-5.0.1 (NeilMitchell)
07:09:30 <cocreature> oh nice, looks like hoogle 5 has finally been released
07:09:39 <magneticduck1> I used to feel at home in Haskell -- but after a little escapade into some other languages, I feel like I need to relearn everything
07:10:18 <sbrg> magneticduck1: well, you just have to write that function, then. create the ConcreteThingyType function and add the function "Thingy c => c -> ConcreteThingyType" to the typeclass and implement it for all members of the typeclass. 
07:10:28 <sbrg> create the ConcreteThingyType datatype*
07:10:54 <magneticduck1> but, let's say I want to abstract the definition of that datatype from the implementation of Thingy
07:11:26 <sbrg> then don't add it to the typeclass but implement it outside of it
07:12:04 <sbrg> it *kind of* sounds like you want dynamic typing. 
07:12:32 <magneticduck1> this sort of behaviour can exist in a statically typed system -- if I'm not mistaken
07:12:41 <alercah> it can
07:12:47 <alercah> but it does not in Haskell
07:13:21 <magneticduck1> alright
07:25:25 <nmattia> thoughtpolice: are you around?
07:33:40 <newbie-guest> I'm back with different nick, i was Guest50337
07:34:49 <newbie-guest> did anybody find solution to my question discussed around 50  minutes ago?
07:34:59 <hexagoxel> meh my `trace`s are all backwards. stupid lazy evaluation :p
07:36:51 <magneticduck1> http://www.hastebin.com/gamekemavu.hs <- I'm trying to find a better way of expressing this
07:37:09 <magneticduck1> the `applyThingies` function in particulary seems like it could use some word
07:37:24 <magneticduck1> s/word/work
07:40:18 <magneticduck1> is this an often warranted design pattern? if it is, are there any sort of standard typeclasses to represent this? if not, what kind of alternative ways are there to refactor this design?
07:44:40 <barrucadu> It made me think of https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
07:45:18 <barrucadu> Is dict passing insufficient?
07:45:49 <Profpatsch> I‘ve got two functinos a -> IO (Either e a)
07:46:04 <Profpatsch> What’s the best way to chain them?
07:46:43 <hexagoxel> magneticduck1: barrucadu is right, HasThingies effectively returns a list of an AnyThingy existentials.
07:47:30 <hexagoxel> s/an//
07:48:32 * hackagebot reflex-dom-colonnade 0.4 - Use colonnade with reflex-dom  https://hackage.haskell.org/package/reflex-dom-colonnade-0.4 (andrewthad)
07:48:46 <magneticduck1> yes that seems accurate
07:49:05 <S11001001> newbie-guest: what does your program look like after removing the solve step?
07:49:12 <fizruk> what would be the easiest way to derive Eq, Show instances for something like data T f = T { x :: f Int, y :: f Double } ?
07:49:48 <magneticduck1> however, imagine that this was a serialization framework, and I wanted to describe the idea of a typeclass whose members are containers with serializable types
07:49:57 <fizruk> (note that I can't use deriving (Eq, Show), because f has kind * -> * and therefore I think I need Eq1/Show1 constraint for it)
07:50:00 <S11001001> fizruk: you can use the Show1 typeclass and require Show1 f
07:50:10 <magneticduck1> `getInt` become an accessory function, instead of the main meaning of the member types
07:50:18 <S11001001> fizruk: I think deriving will not use that, though.
07:50:27 <fizruk> S11001001: but can I derive that instance?
07:51:20 <fizruk> S11001001: I have quite a few of such datatypes and I don't want to write the instances by hand
07:52:06 <magneticduck1> I could still do this on the data-level, I suppose -- instead of a serializable typeclass, I could have a 'serialization rule' datatype, with some combinators for expressing serialization of container types
07:53:07 <magneticduck1> this question of when to implement functionality through typeclasses and when to implement it through dictionary / 'rule'  types is interesting
07:53:24 <fizruk> S11001001: I guess it's time for Data.Functor.Contravariant.Generic, seems like it should fit!
07:54:10 <magneticduck1> it almost seems like typeclasses are just a sort of shorthand for a general case -- an automatic link made between record datatypes with functions and the implementing types themselves 
07:54:23 <fizruk> or not
07:54:44 <magneticduck1> .. but it's ungainly to express this kind of thing at the type level without type classes
07:54:46 <Myrl-saki> Would mixing REST and FRP be a good idea.
07:56:11 <S11001001> fizruk: nope, not Divisible either :)
07:56:41 <S11001001> fizruk: I'm not sure whether there's enough information in Generic anyway to get something matching derived Show
07:57:09 <fizruk> S11001001: equivalence is divisible, so I at least could derive Eq
07:57:52 <S11001001> magneticduck1: There's also a thing about how your program can take multiple paths and be guaranteed to get to the same destination.  edwardk talks about this in "typeclasses vs the world"
07:58:14 <magneticduck1> that sound vague and interesting ^^
07:59:57 <newbie-guest> https://github.com/bigos/alguzzles/blob/53b2f7f7cb5e03cc1e025c46ba82c0f23d54cd87/Strings/haskell/palindrome-index/solution.hs
08:00:01 <newbie-guest> line 39
08:00:30 <newbie-guest> prints 1 char of the line , works fine on short lines breaks on long
08:01:35 <hexagoxel> where short ~ length <= 1
08:01:47 <Profpatsch> (Monad m, Monad n) => m (n a) -> (a -> n b) -> m (n b)
08:01:51 <Profpatsch> Is there something like that?
08:03:41 <hexagoxel> :exf "(Monad m, Monad n) => m (n a) -> (a -> n b) -> m (n b)"
08:03:42 <exferenceBot> \ a f2 -> fmap (\ f -> f >>= f2) a
08:03:49 <hexagoxel> @pl \ a f2 -> fmap (\ f -> f >>= f2) a
08:03:49 <lambdabot> flip (fmap . (=<<))
08:04:05 <hexagoxel> :t flip (fmap . (=<<))
08:04:06 <lambdabot> (Monad m, Functor f) => f (m a) -> (a -> m b) -> f (m b)
08:04:06 <LKoen> what just happened
08:04:15 <LKoen> did you bot construct a function based on the type signature?
08:04:42 <Profpatsch> LKoen: It converted the function to a function without variables.
08:04:53 <Profpatsch> hexagoxel: Thanks, didn’t think about that approach.
08:05:04 <LKoen> hmm
08:05:16 <hexagoxel> exferenceBot did more than @pl :)
08:05:33 <tolt> Profpatsch exferenceBot did construct the expression from the type https://github.com/lspitzner/exference
08:07:57 <Profpatsch> tolt: Sweet, didn’t see the first line.
08:13:08 <beekeeper> friends, I'd like to put a simple newtype of (Int,Int) into an Unboxed array or vector, but none of the readily googleable solutions to making it unboxable seem to work...
08:13:46 <nmattia> beekeeper: can you derive unbox?
08:15:37 <nmattia> beekeeper: looks like (Unbox a, Unbox b) gets you Unbox (a, b)
08:21:37 <glguy> beekeeper: The documentation explains how to do that http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed.html
08:22:18 <glguy> There are also packages to generate the code to do that with template haskell
08:26:15 <nomeata> Here is a riddle: ":t fmap fmap fmap fmap … fmap" (with n fmap applied to each other) how many Functor constraints will the resulting type have?
08:28:12 <nomeata> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
08:28:16 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
08:28:34 * hackagebot monad-logger-prefix 0.1.2 - Add prefixes to your monad-logger output  https://hackage.haskell.org/package/monad-logger-prefix-0.1.2 (parsonsmatt)
08:28:38 <nomeata> @type fmap fmap fmap fmap fmap -- surprisingly simple result
08:28:39 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
08:29:04 <nomeata> Heh. On my branch, that is would be "Functor f => (a2 -> b) -> (a1 -> a2) -> f a1 -> f b". A bit nicer, isn’t it?
08:35:53 <hexagoxel> the annoying part about -Wredundant-constraints is that i now need `const` or `when False` to temporarily disable some code..
08:37:26 <hexagoxel> and const breaks half the time because the thing becomes ambiguous.
08:38:20 <glguy> That should only be an issue if you have -Werror, which is probably a mistake
08:40:36 <hexagoxel> glguy: i want my warnings to show up even when i press build twice.
08:49:21 <Benzi-Junior> hi I have a question is there a function similar to foldr for arrays or something I can use to sum over arrays ?
08:50:45 <ClaudiusMaximus> Benzi-Junior: looks like Array is Foldable, so you can use sum directly (with recent base versions)
08:50:50 <ClaudiusMaximus> :t sum
08:50:51 <lambdabot> (Num a, Foldable t) => t a -> a
08:50:51 <newbie-guest> cat ./input0.txt | runhaskell ./solution.hs
08:50:51 <newbie-guest> works on short lines with following code http://lpaste.net/169652
08:51:10 <newbie-guest> i'm stuck on long lines
08:51:40 <mauke> newbie-guest: what's the problem with long lines?
08:51:50 <newbie-guest> how can i make it efficient
08:52:08 <mauke> probably by not using String
08:52:26 <newbie-guest> long time passes with no output
08:52:36 <mauke> but what that program does is weird anyway
08:53:19 <newbie-guest> it's a step in a programming puzzle that i want to solve in haskell
08:53:45 <mauke> I doubt a programming puzzle involves producing strings in haskell syntax
08:53:58 <newbie-guest> in the puzzle i would look for palindromes, but here i want to debug the io
08:55:44 <newbie-guest> mauke: i agree, but the strings are almost palindromes an i need to find a character that will fix it, i'm stuck at io part
08:56:22 <mauke> how long are your long lines?
08:57:15 <newbie-guest> https://www.hackerrank.com/challenges/palindrome-index up to 10^5
08:59:06 <Benzi-Junior> ClaudiusMaximus: so it is 
09:01:21 <newbie-guest> https://www.hackerrank.com/challenges/solve-me-first this explains input format used on the site
09:04:38 <newbie-guest> oooops
09:05:19 <newbie-guest> could be emacs terminal related? seems to run ok on mate-terminal
09:06:10 <nmattia> has anybody here tried stack upload's --pvp-bounds? is there a way to have it write down the bounds in my local cabal file?
09:08:18 <daniel-s> (***) :: (a -> b) -> (c -> d) -> ((a,c) -> (b,d))
09:08:20 <daniel-s> f *** g = \(x,y) -> (f x, g y)
09:08:26 <daniel-s> Is that function in a library?
09:08:51 <mauke> :t (***)
09:08:52 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
09:08:53 <daniel-s> It appears not to be in the prelude and I don't know if my book's author created that or is referencign a real funciton that exists.
09:08:54 <Iceland_jack> Yes, you should prefer "bimap" from Data.Bifunctor though
09:09:05 <Iceland_jack> :t bimap :: (a -> b) -> (c -> d) -> ((a,c) -> (b,d))
09:09:06 <lambdabot> (a -> b) -> (c -> d) -> (a, c) -> (b, d)
09:09:14 <mauke> @hoogle (***)
09:09:16 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
09:09:24 <Iceland_jack> :t bimap :: (a -> b) -> (c -> d) -> (Either a c -> Either b d)
09:09:25 <lambdabot> (a -> b) -> (c -> d) -> Either a c -> Either b d
09:09:30 <nmattia> daniel-s: that one is in base
09:09:35 <nmattia> module Control.Arrow
09:09:38 <nmattia> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Arrow.html
09:09:50 <Iceland_jack> Both are in base
09:10:47 <yamadapc> I'm having trouble loading a C library onto GHCi; getting "the impossible has happened" as an error
09:13:35 * hackagebot giak 0.1.0.0 - Fuzzy finder for cabal executables  https://hackage.haskell.org/package/giak-0.1.0.0 (nmattia)
09:18:35 * hackagebot giak 0.1.0.1 - Fuzzy finder for cabal executables  https://hackage.haskell.org/package/giak-0.1.0.1 (nmattia)
09:24:11 <impure_hate> ohai. how to workaround     Couldn't match expected type ‘BS.ByteString’
09:24:11 <impure_hate>                 with actual type ‘ByteString’
09:24:14 <impure_hate> ?
09:24:24 <impure_hate> trying to GZip.decompress a ByteString
09:25:04 <mauke> looks like it's returning a lazy bytestring
09:25:24 <impure_hate> yes! just found it :)
09:25:24 <mauke> there are two types called ByteString, lazy and strict
09:25:31 <impure_hate> mauke: and the conversion function is?
09:26:54 <mauke> fromStrict/toStrict
09:26:59 <mauke> http://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString-Lazy.html
09:27:00 <kadoban> impure_hate: Data.ByteString.Lazy has fromStrict and toStrict
09:27:09 <impure_hate> thanks!
09:57:02 <dinnu93> {-# LANGUAGE DataKinds, TypeFamilies #-}
09:57:03 <dinnu93> data Nat = Zero | Succ Nat
09:57:45 <dinnu93> the above code should promote my value constructors into type constructors
09:58:11 <dinnu93> that means I should get => :k Zero = Nat
09:58:31 <dinnu93> but instead I'm getting error
09:58:46 <Iceland_jack> ghci> :kind Zero
09:58:46 <Iceland_jack> Zero :: Nat
09:58:48 <Iceland_jack> Does that work
09:59:19 <Denommus> dinnu93: you need to set in the GHCi, too
09:59:22 <dinnu93> Nope
09:59:24 <Denommus> dinnu93: :s -XDataKinds
09:59:42 <dinnu93> Denommus: Thanks
10:00:25 <Denommus> dinnu93: the extensions are always limited to the current file's module. If you import a module, you won't automatically set the flags that were activated inside of it
10:00:53 <dinnu93> Denommus: IO error:  "-XDataKinds" does not exist
10:01:09 <dinnu93> Denommus: I'm getting this weird error
10:01:32 <Denommus> dinnu93: in ghci?
10:01:51 <dinnu93> Denommus: Yeah
10:01:55 <Denommus> dinnu93: ah, it's :set not :s
10:01:58 <Denommus> dinnu93: sorry
10:01:58 <Iceland_jack> dinnu93: Write ':set'
10:02:15 <Denommus> my mistake
10:02:51 <dinnu93> Denummus: Thanks It worked :)
10:03:10 <dinnu93> Iceland_jack: Thank you
10:03:37 <Denommus> DataKinds are awesome
10:03:48 <Iceland_jack> DataKinds are awesome
10:03:52 <dinnu93> Denommus: I'm just learning about them
10:03:54 <Denommus> servant uses them to build typed URIs for a web backend
10:04:08 <dinnu93> Denommus: That's why I'm learning them
10:04:23 <dinnu93> Denommus: To use Servant
10:04:32 <the_2nd> When trying to build my test project via cabal I get a "this package key is deprecated, use this unit id instead", how can I solve this issue?
10:05:01 <dinnu93> Denommus: Do you know any good resources to learn about type-level programming in more depth
10:05:08 <dinnu93> Denommus: ?
10:05:50 <Denommus> dinnu93: not really, I learned by practice
10:06:29 <dinnu93> Denommus: Then I have to do the same as the number of good resources seem to be very less
10:07:07 <yamadapc> I don't know if this is a bug or if I'm doing it wrongly. I can build a package using the FFI, but not load it with GHCi https://asciinema.org/a/b64potjbjvafbv9gbuquvtb61
10:10:53 <Iceland_jack> dinnu93: this has a good intro https://www.cs.ox.ac.uk/projects/utgp/school/andres.pdf
10:11:09 <geekosaur> yamadapc, that's a known 7.10.3 bug on OS X
10:11:23 <Profpatsch> :exf (Monad m, Functor f) => f (m a) -> (a -> f (m b)) -> f (m b)
10:11:44 <Profpatsch> Oh, it needs a string
10:11:46 <Profpatsch> :exf "(Monad m, Functor f) => f (m a) -> (a -> f (m b)) -> f (m b)"
10:11:50 <yamadapc> geekosaur: is there a way to get around it? is it tracked? asking because GHC 8 also doesn't work
10:11:55 <exferenceBot> could not find expression
10:12:14 <exferenceBot> could not find expression
10:13:30 <geekosaur> interesting, was supposed to be fixed in 8.0.1. 
10:13:36 * geekosaur can't remember the ticket, is dfigging
10:15:34 <yamadapc> dfigging?
10:16:56 <geekosaur> https://ghc.haskell.org/trac/ghc/ticket/9277
10:17:07 <geekosaur> digging through ghc's trac looking for relevant tickets
10:17:20 <benzrf> is there a standard type or library to use for vector math
10:17:31 <benzrf> e.g. pointwise addition, scalar mult, dot products n stuff
10:17:48 <geekosaur> so, that looks distinct from the one that I thought was fixed; it's something to do specifically with the objc runtime
10:18:37 * hackagebot oeis 0.3.7 - Interface to the Online Encyclopedia of Integer Sequences (OEIS)  https://hackage.haskell.org/package/oeis-0.3.7 (niteria)
10:18:43 <yamadapc> well that's a bummer
10:19:43 <ahri> hi, i'm learning haskell and its ecosystem, and have grabbed a copy of the websockets example from https://jaspervdj.be/websockets/example.html - i installed stack and created a project, then i put that example in app/Main.lhs and pointed the .cabal file at it. so far so good. i then ran `stack setup`, and `stack install websockets`, but that last command didn't update either the .cabal or .yaml files, and r
10:19:49 <ahri> unning `stack build` tells me i haven't got websockets (and transformers, etc.) installed... so what did `stack install websockets` do, then?!
10:20:13 <benzrf> ahri: i'm not a stack expert, but one thing i can tell you is that `stack install' is not for installing libraries
10:20:20 <benzrf> stack reads configuration to install libraries
10:20:29 <benzrf> `stack install' is just for getting binaries from libraries
10:20:35 <benzrf> like if you want hdevtools
10:20:48 <ahri> benzrf: ah, that explains a few things then!
10:21:16 <benzrf> :)
10:22:06 <ahri> so do i need to manually edit the stack.yaml and add my deps? i'm used to python/nodejs/etc. where running the local package manager will update the config file with whatever version it installed
10:23:11 <yamadapc> so `stack install` will install the library globally within the default snapshot, if I understand it... to add you can either add it to the .cabal file, use something like hpack (a yaml .cabal alternative) or use a script (I use my own: https://github.com/yamadapc/cabal-add). Emacs adds dependencies automagically too most of the time
10:23:11 <ahri> or should my deps go in the .cabal file? i'm a bit confused :D
10:24:11 <ahri> ah, hm, ok. so what's the stack.yaml for if not project dependencies? would i put test dependencies in there, for example?
10:24:29 <yamadapc> the deps go on the `.cabal` file; stack defines where the packages come from +/-
10:24:53 <yamadapc> there're snapshots published regularly with a set of package versions that are known to compile with one another
10:25:26 <ahri> oh... i see, so there's no central haskell package repository?
10:25:32 <yamadapc> that's what goes on the stack file; which snapshot you'll use on the project. when a package isn't on the snapshot, most of the times `stack solver --update-config` will add it to the configuration
10:25:40 <yamadapc> there's a central package repository, hackage
10:28:27 <yamadapc> then stack uses `stackage`, which is this snapshots thing. it's actually really good compared to other languages' package managers, as far as reliability goes 
10:29:12 <ahri> oh i'm not complaining, just trying to understand how things are done, what goes where... it's just a bit different from what i'm used to :)
10:30:42 <hexagoxel> Profpatsch: monads don't compose in general, so there is no solution to that type.
10:30:44 <nitrix> Any libraru to recommend generating images of various shapes (translated and rotated) to train a NN ?
10:31:19 <nitrix> Profpatsch: They compose but not necessarily to another monad.
10:31:36 <hexagoxel> right
10:32:03 <Profpatsch> Well, it’s a -> IO (Either e b) 
10:32:06 <Jinxit> nitrix: are there even any reasonable NN libs in haskell?
10:32:31 <nitrix> Jinxit: instinct is pretty cool.
10:32:56 <nitrix> I said NN but I'm working on something more advanced than that, mixing genetic programming.
10:33:06 <WarDaft> NNs are pretty easy to work with in Haskell.
10:33:34 <Jinxit> but that only has "classical" NNs right? no convolutions or RNNs?
10:33:57 <nitrix> No, but convolution happens before the fully connected NN anyway
10:34:10 <nitrix> In most cases :/
10:34:33 <hexagoxel> Profpatsch: heh, exferenceBot's solution to the specific type is.. funny. or cheaty.
10:34:39 <hexagoxel> :exf "IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)"
10:35:01 <exferenceBot> \ i1 f2 -> runEitherT (EitherT i1 >>= (EitherT . f2))
10:35:01 <nitrix> Anyway, back to the question, a recommendation for a general shape drawing library that lets you save to an image format?
10:35:17 <hpc> rasterific, perhaps?
10:35:29 <hpc> it's pure haskell and uses juicypixels as its backend
10:35:42 <levi1> nitrix: diagrams is pretty neat and has a variety of backends.
10:35:50 <Profpatsch> hexagoxel: So that’s exactly what my approach would have been. :)
10:36:11 <Profpatsch> It probably uses mtl for every combination which has a translation.
10:36:34 <hexagoxel> Profpatsch: it uses whatever i put in its environment :)
10:36:39 <nitrix> Profpatsch: You can join the monad `m (n (m (n a)))` into `m (n a)` if you can provide a swap operation :: m (n a) -> n (m a)
10:37:35 <nitrix> Profpatsch: Because then you can swap that into m-n-n-m, join the two n's, m-n-m, swap again m-m-n, join, m-n.
10:39:21 <WarDaft> Anyone played around much with defining GHCi commands? I've got an action that seems to work fine when I call it directly, but causes a Prelude.read parse error if I try to call it as a command.
10:52:01 <ahri> yamadapc: for now i'm just adding deps into my .cabal file (e.g. ", websockets == 0.9.6.2") and re-running `stack build`, but it's not finding them; do i have to run cabal directly to install them? sorry, i'm still confused about whose responsibility it is to retrieve the dependencies
10:53:38 * hackagebot steeloverseer 2.0.0.1 - A file watcher and development tool.  https://hackage.haskell.org/package/steeloverseer-2.0.0.1 (SchellScivally)
10:53:58 <WarDaft> Stack has its own idea of which versions to use. If you specify ones that are out of its snapshot, it won't be able to see them automatically.
10:55:59 <ahri> WarDaft: i searched on stackage.org for "websockets" and it just linked to the hackage result; did i do something wrong? how can i know what is snapshotted?
10:58:02 <ahri> i just clicked "snapshots" and it lets me pick nightlies, and the most recent one has 0.9.6.2 on there, but i don't know what listing of snapshots will be consulted when type `stack build`
10:58:17 <ahri> having said that, `stack build` did suggest that version
10:58:38 * hackagebot Plot-ho-matic 0.10.1.0 - Real-time line plotter for generic data  https://hackage.haskell.org/package/Plot-ho-matic-0.10.1.0 (GregHorn)
10:58:54 <geekosaur> the snapshot it uses is specified as "resolver" in stack.yaml
10:59:04 <ahri> so now that i've added a dependency of the name and version `stack build` suggested to the .cabal file, it's still saying it can't find it
11:00:02 <Ornedan> What's the current recommended way to do logging? Control.Monad.Logger or something else?
11:00:11 <ahri> ok, lts-6.7, https://www.stackage.org/lts-6.7 lists websockets at version 0.9.6.2
11:00:45 <WarDaft> Don't put a version constraint in the cabal file just yet, see if that builds.
11:02:40 <bernalex> WarDaft: if your nick is meant to be a pun on WarCraft, I find it utterly delightful.
11:04:18 <ahri> WarDaft: i've set up my dependencies as follows: https://gist.github.com/ahri/d3cd81bf48da974ac2cb7a77fd2fcfac#file-project-cabal-L5-L7 - running `stack build` doesn't download anything, and certainly doesn't build :(
11:05:19 <ahri> perhaps the format is incorrect?
11:05:21 <WarDaft> It is, and I have been using it since WC3 came out.
11:06:12 <WarDaft> The formatting looks fine.
11:07:21 <ahri> WarDaft: ah, i think i added them in the wrong place; when i move them to the executable section `stack build` works
11:07:30 <ExcaliburZero> Would anyone be willing to give some feedback on a library that I am working on writing? It is a library for generating default user avatars for websites, similar to the system used by GitHub. Any suggestions on design, documentation, etc. would be very helpful.
11:07:30 <ExcaliburZero> Here is the link to the library's GitHub repo: https://github.com/ExcaliburZero/pixelated-avatar-generator
11:07:35 <ExcaliburZero> Here is the link to the package candidate on Hackage: https://hackage.haskell.org/package/pixelated-avatar-generator-0.1.0/candidate
11:16:48 <benzrf> 13:16 <benzrf> is there a standard type or library to use for vector math
11:16:51 <benzrf> 13:17 <benzrf> e.g. pointwise addition, scalar mult, dot products n stuff
11:19:25 <ahri> thanks for the help, i think i vaguely understand what stack/cabal are for!
11:20:28 <benzrf> ahri: nice :)
11:21:09 <nitrix> ahri: cabal-install solves reproducible builds with version freezing like PHP's composer, stack uses incremental resolvers that are set of packages known to work together.
11:22:05 <nitrix> ahri: Apart from these two big things are various small design choices, e.g. stack is managing sandboxes, GHC and local dependencies automatically for you, cabal doesn't, etc.
11:22:30 <nitrix> s/cabal/cabal-install/
11:28:50 <bollu> I'm trying to understand the whole Free DSL pattern
11:28:54 <bollu> I'm reading this: http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
11:29:10 <bollu> and I'm stuck on the liftFree action = Free (fmap Return action) part
11:29:20 <bollu> it makes zero intuitive sense to me as to why we define it that way
11:29:26 <bollu> :info Free
11:29:34 <bollu> can someone please enlighten me?
11:29:42 <bollu> I understand how the monad structure on free works
11:29:59 <bollu> it leaves the Pure parts alone, but it "inflates" the monadic Free nodes
11:30:03 <bollu> with the monadic action
11:30:06 <bollu> so that makes sense
11:30:18 <bollu> but I don't get how we can lift regular stuff into the free dsl
11:31:56 <bollu> um, anyone?
11:34:38 <kosmikus> Iceland_jack: thanks a lot for advertising my lecture notes; but ideally, use this link: https://github.com/kosmikus/SSGEP  -- this version is a bit more recent
11:35:21 <Iceland_jack> kosmikus: Ah, you're Andres :) noted
11:35:33 <Profpatsch> What’s your take on switching to ExceptT?
11:35:42 <kosmikus> Iceland_jack: :)
11:35:46 <Profpatsch> Once I have an IO (Either …)?
11:36:56 <bollu> can anyone tell me how Free monads allow us to write DSLs?
11:37:13 <bollu> I understand the semantics of >>= on Free monads of a functor
11:37:19 <bollu> I just don't understand how can use them to write a DSL
11:37:24 <bollu> a toy example would really ehlp
11:37:27 <bollu> help*
11:38:16 <kosmikus> bollu: perhaps this helps? https://www.andres-loeh.de/Free.pdf ?
11:38:53 <bollu> kosmikus: thank you, I'll check it out
11:40:10 <kosmikus> bollu: this is available as a video as well (https://skillsmatter.com/skillscasts/4430-monads-for-free), but unfortunately you have to sign up for that
11:40:19 <bollu> ahh
11:40:33 <bollu> kosmikus: the slides seem pretty good, but I'm cool with signing up
11:40:52 <Iceland_jack> You can maybe use http://bugmenot.com/
11:41:15 * Iceland_jack slithers back into a shady alley
11:47:48 <dedgrant> I do not think I've ever encountered this polykind puzzle before: http://lpaste.net/169701  ... the 'newtype' trick will not work here. What are others doing to patch up polykinded undecidables?
11:52:13 <isovector> bollu: i'm woking on a series right now. http://reasonablypolymorphic.com
11:53:01 <isovector> bollu: this is probably a better link: http://reasonablypolymorphic.com/blog/free-stories
11:53:40 * hackagebot haskell-packages 0.4 - Haskell suite library for package management and integration with Cabal  https://hackage.haskell.org/package/haskell-packages-0.4 (niteria)
12:13:41 * hackagebot data-elf 0.1.0.1 - Executable and Linkable Format (ELF) data structures.  https://hackage.haskell.org/package/data-elf-0.1.0.1 (MikhailVorozhtsov)
12:27:49 <impure_hate> what would you use for storing state of an application on filesystem? I'm building a CI server that will store tasks on disk
12:28:46 <johnw> what kind of state?
12:29:15 <impure_hate> list of tasks that are loaded on start and then evaluated on requests coming from socket
12:29:40 <impure_hate> data Task = Task Name ShellCode
12:29:43 <johnw> i'd probably serialize it to json
12:29:45 <impure_hate> basically
12:29:50 <johnw> make it easier to view/edit
12:30:00 <impure_hate> is yaml as easy as json?
12:30:08 <impure_hate> would better fit this one
12:30:10 <johnw> yaml is a subset of json
12:30:14 <impure_hate> hm :)
12:30:29 <Chousuke> hm? yaml is quite different from json
12:30:29 <impure_hate> ah, I remember now that aeson is also used for yaml pasring
12:30:38 <johnw> oh, json is a subset of yaml
12:30:39 <johnw> wrong way
12:30:44 <Chousuke> yaml also supports comments
12:30:47 <Chousuke> json doesn't
12:30:51 <impure_hate> aha
12:30:56 <johnw> http://stackoverflow.com/questions/1726802/what-is-the-difference-between-yaml-and-json-when-to-prefer-one-over-the-other
12:32:30 <impure_hate> lets try yaml then
12:32:58 <ertes> impure_hate: is this data that changes a lot?
12:33:22 <Welkin> impure_hate: impure functions?
12:33:32 <impure_hate> ertes: not really. in CI you don't change tasks that often. ideally you just configure once and forget :)
12:33:41 <impure_hate> Welkin: :))
12:33:42 <ertes> because you're solving two problems here:  1. which format to save it?  2. how to save?  the latter question isn't actually as easy as it sounds
12:33:55 <Chousuke> though now that I read your problem, I think you'd be much better off with sqlite
12:33:59 <impure_hate> to not corrupt my state?
12:34:08 <ertes> impure_hate: in that case, especially if you want to let users configure, yeah, YAML from a file =)
12:34:46 <impure_hate> I would like to avoid a database for once, had too much of them on previous project :)
12:34:49 <ertes> impure_hate: but if the application itself updates the state, you may be better off with a database or something like acid-state
12:34:59 <Welkin> acid-state seems cool
12:35:02 <Welkin> never used it though
12:35:10 <Welkin> in-memory db
12:35:26 <johnw> acid-state seems massive overkill for this use case
12:35:35 <Chousuke> impure_hate: sqlite is basically a database with all the good bits and none of the burden of the extra infrastructure
12:35:55 <Chousuke> and if you're storing tasks, that definitely sounds like something that should go in a database
12:35:55 <Welkin> sqlite is a flat file database
12:36:28 <impure_hate> Chousuke: it's only a definition of task, run of a task will be stored on filesystem
12:37:28 <ertes> impure_hate: ask yourself whether it's "configuration" or "state"
12:37:38 <impure_hate> hm, indeed
12:37:42 <impure_hate> more of a configuration I guess
12:37:42 <Chousuke> ah, I see. then you might actually have something that someone might want to edit, so a serialized data structure makes more sense.
12:37:50 <ertes> impure_hate: then just read a YAML file
12:37:58 <ertes> YAML is great for humans
12:38:01 <impure_hate> yup
12:38:08 <impure_hate> and save it atomically :)
12:38:14 <Chousuke> well, except when it isn't. but it's better than JSON
12:38:23 <Chousuke> if only because it has comments.
12:38:30 <ertes> impure_hate: consider before *saving* to YAML
12:38:52 <ertes> impure_hate: computer-produced YAML tends to be not so great
12:39:18 <Chousuke> if task definitions are something that you generate via an UI, then the database starts making sense again
12:39:44 <ertes> it would be nice if we had a YAML library that allowed updating individual parts of a file without completely reconstructing everything
12:39:54 <ertes> but i'm not aware of one
12:40:06 <impure_hate> indeed, that's common issue even with .ini style configs
12:40:27 <Welkin> oh .ini, I remember that from when I would writes mIRC scripts/bots :P
12:40:28 <Welkin> haha
12:41:00 <impure_hate> uu, there's even atomic-write package
12:41:04 <agocorona> what we need is Read/Show for Data.Text
12:42:14 <ertes> agocorona: printing/parsing haskell again?
12:42:27 <agocorona> ertes:  efficiently
12:42:28 <Chousuke> ertes: it's probably more efficient to read-modify-write the whole file than bother with such optimisation, unless the file gets very large
12:42:47 <ertes> Chousuke: this isn't about speed
12:42:56 <impure_hate> I would like to mainly avoid corruption
12:43:20 <Chousuke> store your yaml in an sqlite database? :P
12:43:21 <Welkin> wouldn't we all?
12:43:25 <impure_hate> :)
12:43:31 <Welkin> store your yaml in a yaml
12:43:35 <impure_hate> :D
12:43:42 * hackagebot cgrep 6.6.16 - Command line tool  https://hackage.haskell.org/package/cgrep-6.6.16 (NicolaBonelli)
12:43:47 <Welkin> it's yaml all the way down
12:43:51 <nitrix> The channel is extremely noisy today.
12:43:53 <ertes> Chousuke: have you ever written an irssi configuration by hand and then made the mistake to use /save in irssi?
12:43:53 <Chousuke> I actually did that once, to get easy persistence with a simple one-page web app...
12:44:13 <Welkin> nitrix: because of Irishluck83 ?
12:44:18 <Chousuke> sqlite takes care of all the hard stuff
12:44:20 <Welkin> the luck 'o the irish
12:45:05 <Chousuke> ertes: I see what you mean. 
12:45:09 <Welkin> ertes: or using the GUI to make changes to your .emacs instead of typing it manually?
12:45:17 <Chousuke> and yes I have :P
12:45:20 <ertes> Welkin: yeah
12:45:36 <Chousuke> actually there's a tool called augeas for just this kind of stuff
12:45:49 <ertes> i consider (custom-set-variables) portion of my .emacs foreign ground…  i don't touch any of it =)
12:46:00 <impure_hate> I'm likely going to write similar tool to augeas
12:46:05 <ertes> knowing that 'customize' will mess it up anyway
12:46:10 <Chousuke> but it works via regexp parsing the files it can edit :/
12:46:14 <impure_hate> as parsing in haskell is great ^^
12:46:24 <impure_hate> hehe
12:47:04 <Chousuke> amusingly enough, augeas definitions are called lenses :P
12:47:18 <johnw> haugeas
12:48:02 <Irishluck83> that is right Welkin 
13:04:32 <epicallan> @help
13:04:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:04:55 <epicallan> list
13:05:02 <epicallan> @help list
13:05:03 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
13:24:13 <bleuj> hello
13:30:50 <fishythefish> bleuj: hi!
13:31:00 <bleuj> I learned OCaml some years ago at school, Haskell looks similar.
13:31:40 <fishythefish> There are some differences, but ML did influence Haskell
13:33:00 <bleuj> which IDE do you recommend?
13:33:20 <maerwald> bleuj: if you want an IDE experience, you might wanna check leksah
13:34:02 <epicallan> Hi i am also new to haskell, i am using the atom editor with a bunch of plugins
13:34:46 <Henson> bleuj: I use "atom" with the ide-haskell, language-haskell, and haskell-ghc-mod plugins.  But I'm having difficulty getting the ghc-mod plugin working, so it's disabled currently.  It's not a great IDE experience, but it's better than using VI.
13:35:41 <Henson> bleuj: when the ghc-mod plugin works, it's a lot better, but it still doesn't have nearly as many features as Eclipse for Java, or KDevelop for C++
13:35:44 <bleuj> okay, I'll try leksah first
13:36:19 <Henson> maerwald: how is Leksah?  I tried getting it running a year ago, and it didn't work very well so I gave up on it.
13:36:45 <maerwald> Henson: I don't know what you mean
13:37:07 <maerwald> it works, I just don't use it, because I don't like the editor
13:37:55 <Henson> maerwald: ah, ok
13:38:55 <bleuj> by the way does OCaml have nice simple IDEs?
13:41:36 <exio4> what's the "standard" library for secure random numbers? I am making a small gambling mini-game on the bot and would like avoid people predicting it :P
13:43:45 * hackagebot deriving-compat 0.3 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.3 (ryanglscott)
13:45:34 <maerwald> personally, I'd probably use the low-level unix way
13:47:14 <bleuj> okay thanks
13:48:16 <bleuj> oh it was probably not an answer for me :)
13:48:45 * hackagebot gnss-converters 0.1.10 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.10 (mookerji)
13:49:43 <isochronia> Hi. I was wondering whether there was a built-in way to parse a string of Haskell into, say, a function. So, if I had the string "\x -> x^2", is there a way to do read .. :: Num a => a -> a ?
13:50:57 <crough> not built in
13:51:43 <isochronia> Right. Is there a library that would do that?
13:52:23 <kadoban> Something like mueval maybe? Never used it myself though, just heard about it.
13:53:45 * hackagebot th-lift-instances 0.1.10 - Lift instances for template-haskell for common data types.  https://hackage.haskell.org/package/th-lift-instances-0.1.10 (BennoFuenfstueck)
13:55:15 <jle`> isochronia: usually what you'd do is write an expression type and write a parser into that expression type
13:55:41 <jle`> reading arbitrary functions from a string is probably not something you'd want to be doing, anyway
13:55:42 <bleuj> newbie question : hello :: String -> Stringhello s = "Hellos " ++ s
13:55:51 <bleuj> means forced type?
13:56:08 <jle`> what do you mean by forced type?
13:56:30 <jle`> that's a function that takes a string and returns "Hellos " pre-pended to that string
13:56:35 <jle`> and it has a type annotation
13:56:44 <jle`> i am not sure i know what you mean by forced type
13:56:49 <bleuj> but it compiles without the type annotation
13:56:54 <isochronia> I see, yes. Well, in this case I just wanted to set up a configuration file for myself, so I'm not worried about unsafe code as it is. Yes, mueval is one of those things, I suppose, but it seems like it's POSIX-only. I imagine you can do it with the GHC API, but I haven't tried it.
13:57:46 <maerwald> bleuj: yeah, haskell has type inference
13:57:49 <kadoban> isochronia: If a small subset of functions would be enough you could write a simple parser for a language you make up I suppose.
13:57:57 <jle`> it's not necessarily about unsafeness -- it's also not something that makes too much sense, you'd have to be carrying around the entire GHC compiler to parse a string
13:58:19 <jle`> bleuj: haskell infers the type without you having to specify it manually
13:58:34 <jle`> explicitly
13:58:44 <jle`> it's kind of one of the big deals about haskell :)
13:58:52 <isochronia> That's true, yes. I suppose in this case I'll write a parser, yes.
13:59:05 <maerwald> bleuj: you could call that "enforced type", but I find that term confusing, because in the case you gave, there's really no other possible "interpretation" of the types
13:59:25 <jle`> isochronia: you might not even want to be parsing (\x -> x^2), even
13:59:28 <maerwald> sometimes, you might want a different type than the type inferer chooses
13:59:46 <jle`> depending on what your configuration file is supposed to be configuring
14:00:08 <bleuj> so it's a good practise to put it when we know what type we want, right?
14:00:31 <maerwald> people usually do that, yes, at least for top-level functions
14:00:36 <jle`> isochronia: if you're only ever going to be using one of a few functions, you can parse an ADT of possible function types, data PossibleFunctions = Double | Square | Halve
14:00:53 <jle`> and write a Num a => PossibleFunctions -> (a -> a) function
14:02:00 <isochronia> I suppose that makes sense, yes. In another place where I wanted 'arbitrary' functions I used a power series representation, for instance. 
14:02:23 <jle`> it's definitely a lot more sensible than building a parser for the entire Haskell language ...
14:02:36 <jle`> or carrying around the entire haskell compiler
14:02:54 <dmwit> isochronia: For configuration, you may like dyre.
14:02:55 <jle`> that would probably be absurd :)
14:03:09 <dmwit> isochronia: Just joined the conversation, though, so I may not know all the constraints you have.
14:03:13 <dmwit> ?hackage dyre
14:03:13 <lambdabot> http://hackage.haskell.org/package/dyre
14:03:22 <maerwald> bleuj: type information also serves as some kind of documentation. You don't really want readers to guess what the type might be, do you?
14:03:52 <bleuj> sure
14:03:56 <dmwit> Top-level description: write your application as a library, write your configuration as an executable that uses the library to do almost everything after it sets up whatever config values you need. Dyre handles dynamically reloading updated configs.
14:03:58 <jle`> yeah, haskell lets you add type annotations when you think it helps readbility, and not add them when you think they don't
14:04:20 <jle`> it's sort of a "best of both worlds" thing :)
14:04:50 <bleuj> now I remember there was the same with OCaml : f (x:int) =
14:04:54 <maerwald> that's true for pretty much all languages with type inference
14:05:43 <dmwit> isochronia: (If you're familiar with xmonad, that's a very similar technique -- xmonad is what inspired the creation of the dyre library.)
14:07:03 <maerwald> type inference in haskell isn't really special
14:08:17 <jle`> it's something the majority of programmers don't realize exists! :D
14:08:25 <buglebudabey> how different is stg from when it was first introduced? where can i read up on more recent implementations and compilation to C--?
14:08:34 <dmwit> exio4: Dunno about standard, but I've used the DRBG package before.
14:08:36 <dmwit> ?hackage DRBG
14:08:36 <lambdabot> http://hackage.haskell.org/package/DRBG
14:09:07 <maerwald> jle`: I don't see why that would be true
14:09:34 <jle`> most programmers i've met haven't even heard of any languages with type inference
14:09:51 <maerwald> that statement is a bit more specific
14:09:54 <dmwit> buglebudabey: I think the "push/enter vs. eval/apply" paper is more recent than the STG paper. The GHC wiki also has a ton of resources to dive into.
14:10:12 <buglebudabey> thanks dmwit 
14:10:17 <jle`> i can't claim to have a representative sample!  but most people i've met in my years at university and the workplace and academia haven't heard of type inference
14:10:46 <dmwit> buglebudabey: https://ghc.haskell.org/trac/ghc/wiki/Commentary
14:10:54 <jle`> this is the basis on which i make my generalization
14:11:29 <buglebudabey> thanks again dmwit  :D
14:11:44 <maerwald> jle`: "Some languages that include type inference include C++11, C# (starting with version 3.0), Clean, D,F#, FreeBASIC, Go, Haskell, ML, Nim, OCaml, Opa, Rust, Scala, Swift, and Visual Basic (starting with version 9.0)." -- wikipedia
14:11:47 <isochronia> dmwit, I'm looking at Dyre now, yes. I suppose that is a fair solution to what I wanted to do with the configuration.
14:12:05 <isochronia> Though, thinking about it, I think instead I'll define a few common functions and reference them by name.
14:12:11 <isochronia> Since that should be enough.
14:13:35 <exio4> dmwit: k, thanks
14:13:46 * hackagebot pixelated-avatar-generator 0.1.0 - A library and application for generating pixelated avatars.  https://hackage.haskell.org/package/pixelated-avatar-generator-0.1.0 (ExcaliburZero)
14:14:01 <exio4> jle`: I know :( 
14:14:01 <isochronia> Also, I haven't had the chance to use xmonad, since I usually use Windows. I suppose I'll try it when I can/
14:14:03 <isochronia> .
14:34:31 <adarqui> well i finally got ghcjs setup and working with lts-6.6. excited.
14:37:20 <muesli4> Hi, I need to treat the first element of a Foldable differently, what's the best way to handle this?
14:37:55 <maerwald> you could be more vague
14:37:56 <yyyyy> muesli4: what do you mean by differently? can you explain your use case?
14:38:39 <joe_____> pattern match `(x:xs)` and then return f on the first element and g on the rest
14:38:39 <muesli4> yyyyy: Basically I need to generate some code for every element of a Foldable, but I need to add some kind of Prelude to the first piece of code.
14:38:47 * hackagebot gnss-converters 0.1.11 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.11 (mookerji)
14:39:35 <Iceland_jack> muesli4: Either pattern match (first:rest) or depending on your use case distinguish the first element
14:39:35 <Iceland_jack>     data Foo a = Foo SpecialFirstElement [a]
14:39:54 <shachaf> muesli4: You could just use toList
14:40:32 <muesli4> shachaf: But then I would loose the structure.
14:40:50 <jle`> you lose the structure anyways with Foldable
14:40:51 <shachaf> Well, depending on what you're doing with Foldable, you might be losing it anyway.
14:41:08 <jle`> all functions in the Foldable typeclass loses the structure
14:41:14 <jle`> s/looses/lose
14:42:27 <jle`> if you want to keep the structure, you'll have to use Traversable
14:42:28 <muesli4> jle`: Silly me, I meant Traversable, in that case it's probably not possible.
14:42:39 <jle`> it's possible with Traversable; you can use StateT as the Applicative, for instance
14:42:58 <jle`> and run it with an initial state of True, and have the first action flip the state to False
14:43:00 <shachaf> They have some structure. For example you can get the last element of a Data.Set in logarithmic time.
14:43:40 <shachaf> muesli4: One answer might be partsOf in lens.
14:44:12 <jle`> the implementations take advantage of the structure, but the structure is lost in the end result
14:44:18 <shachaf> It lets you get all the elements in a Traversable thing in a list, do whatever you want to the list, and then put its contents back into the original thing.
14:44:21 <Iceland_jack> muesli4: Consider applying the "prelude" as part of the structure
14:44:33 <shachaf> It's a bit of a hack, though.
14:44:58 <muesli4> I'll try that, thanks all.
14:45:04 <Iceland_jack> If that doesn't fit then maybe it's round hole/square peg
14:45:58 <jle`> > flip evalState False $ traverse (\x -> do isFirst <- get; modify not; if isFirst then x else x*2) (M.fromList [('a', 1),('b', 2),('c', 3)])
14:46:00 <lambdabot>      No instance for (Show b0)
14:46:00 <lambdabot>        arising from a use of ‘show_M23410789397541646315583’
14:46:00 <lambdabot>      The type variable ‘b0’ is ambiguous
14:46:02 <jle`> my hubris
14:47:01 <Iceland_jack> > "pride" `compare` "fall"
14:47:03 <lambdabot>  GT
14:47:32 <jle`> > flip evalState True $ traverse (\x -> do isFirst <- get; modify not; return (if isFirst then x else x*2)) (M.fromList [('a', 1),('b', 2),('c', 3)])
14:47:33 <lambdabot>  fromList [('a',1),('b',4),('c',3)]
14:47:50 <shachaf> jle`: Very misleading.
14:48:01 <shachaf> You should submit it to the underhanded Haskell contest.
14:48:18 <muesli4> jle`: Almost: when isFirst $ modify not
14:48:24 <jle`> :o
14:48:27 <shachaf> > flip evalState True $ traverse (\x -> do isFirst <- get; modify not; return (if isFirst then x else x*2)) (M.fromList [('a', 1),('b', 2),('c',3),('d',4)])
14:48:29 <lambdabot>  fromList [('a',1),('b',4),('c',3),('d',8)]
14:48:59 <jle`> > flip evalState True $ traverse (\x -> do isFirst <- get; put False; return (if isFirst then x else x*2)) (M.fromList [('a', 1),('b', 2),('c', 3)])
14:49:01 <lambdabot>  fromList [('a',1),('b',4),('c',6)]
14:54:13 <jle`> oops sorry
14:55:16 <mniip> oi jle`
15:26:38 <dedgrant> Well now, this might be fun... data Table ; data Query (t :: Table) ; data Query' (query :: Query (t :: Table))
15:41:17 <magneticduck1> dedgrant: what extensions does that use?
15:41:31 <dedgrant> TypeInType
15:41:40 <dedgrant> Pushing my luck again :)
15:43:43 <magneticduck1> oh right, I'm not up to date with GHC 8.0
15:44:04 <magneticduck1> I thought the error messages have started looking different.. been away for too long :(
15:45:37 <magneticduck1> if there's one fear I have about developing in Haskell, it's not that I'll be feeling stifled by lack of featuress
15:46:16 <magneticduck1> everything except dependant typing
15:46:38 <magneticduck1> or was -XYesWeHaveThatToo released with 8.0? 
15:57:57 <c_wraith> TypeInType gives full dependent typing.. from the type level up. which is actually still pretty far from dependent typing. but it's a necessary step. 
16:00:03 <nitrix> Since dependent typing was mentioned; how does one introduce control-flow (beyond branching) for a language in a way that guarantees the program will still halt?
16:00:27 <nitrix> Someone told me to look at dependent typing, but the reference language in question doesn't even have types.
16:02:19 <nitrix> To make myself clear, this language doesn't need to decide wether another turing machine will halt or not; just to guarantee that it will itself halt.
16:04:00 <hpc> you could do it inductively
16:04:16 <hpc> if x and y are actions that halt, then {x; y} is an action that halts
16:04:52 <hpc> show that all your primitives halt when used individually, determine what the valid ways to combine them are, and prove those interactions
16:04:53 <nitrix> Are there known languages/papers on total turing machines / recursive/decidable languages?
16:05:07 <hpc> for instance, you might make your looping mechanism be foreach over immutable finite lists
16:05:54 <nitrix> hpc: That's simple, but that's not control flow though.
16:06:46 <nitrix> I guess it is, actually.
16:07:15 <hpc> yeah
16:07:48 <Profpatsch> :exf "(b -> b -> Bool -> b) -> (a -> b) -> (a -> b) -> (a -> Bool) -> b"
16:07:51 <hpc> so your foreach properties would be it takes a finite immutable list (meaning it always executes exactly n times, n = the length of the list at the start, and n is also finite)
16:07:54 <nitrix> I was just hoping for something that'd allow for custom explicit control-flow yet remain halting.
16:08:00 <hpc> and then what's inside the loop is inductively shown to be halting
16:08:13 <exferenceBot> could not find expression
16:08:36 <hpc> you'd have to design some generic bits of control flow and then define others in terms of those, probably
16:08:58 <nitrix> hpc: It seems no one has ever done that :/
16:09:09 <nitrix> Decidable explict control-flow :/
16:09:20 <mniip> Profpatsch, you've missed the a
16:09:43 <hpc> usually when you care about that, you're also in a situation to use something like agda or idris where control flow isn't syntax anyway
16:10:07 <Profpatsch> :exf "(b -> b -> Bool -> b) -> (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b"
16:10:08 <exferenceBot> \ f1 f2 f3 f4 e -> f1 (f2 e) (f3 e) (f4 e)
16:10:08 <exferenceBot> \ f1 f2 f3 f4 e -> f1 (f3 e) (f2 e) (f4 e)
16:10:10 <hpc> maybe if you define your language as a DSL in one of those?
16:10:30 <hpc> Profpatsch: is that like a less goofy djinn?
16:10:43 <Profpatsch> hpc: Seems like it.
16:10:52 * hpc is not even going to attempt djinning that type, knows it's going to be at least 5 lines
16:11:03 <Profpatsch> It’s fun to play around with (“what if“).
16:11:18 <Profpatsch> Maybe enlightenment follows.
16:18:13 <Profpatsch> :exf "(b -> b -> Bool -> b) -> (a -> b) -> (a -> b) -> (a -> Bool) -> (c -> a) -> b"
16:18:39 <exferenceBot> could not find expression
16:21:09 <mniip> hpc, what no
16:21:13 <mniip> @djinn (b -> b -> Bool -> b) -> (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b
16:21:13 <lambdabot> f a b c d e =
16:21:13 <lambdabot>     case d e of
16:21:13 <lambdabot>     False -> c e
16:21:13 <lambdabot>     True -> a (c e) (b e) False
16:21:32 <mniip> see, only four
16:22:07 <srhb> Four what?
16:22:26 <Profpatsch> lines
16:22:52 <srhb> Ah. :P
16:23:09 <cloudhead> hey, is there such a thing as overusing type synonyms? ex: having a bunch of synonyms for Int to make function signatures self-documenting?
16:23:52 <shachaf> If you really want it to be self-documenting, you can use a newtype instead of a type synonym.
16:24:26 <Profpatsch> I like ViewPatterns. People should know about them.
16:24:38 <dedgrant> Profpatsch: ^ this
16:24:42 <nitrix> hpc: I've actually just learned a simple way to do it. It think I'm going to allow arbitrary control flow and rely on an old paper of 1967 that says the halting problem can be solved for all finite-state systems. Thus, I can observe state changes in a given cycle, see what relies on that and if it's involved in deciding wether or not to continue looping, then I can record their states.
16:25:06 <cloudhead> shachaf: right but that places a bit more burden when writing code
16:25:07 <nitrix> hpc: If at any given time their states repeat, then I have an oracle to claim the machine will never halt, right?
16:25:08 <Profpatsch> shachaf: cloudhead Hm, I’d only use newtypes if I wanted to hide some implementation detail.
16:25:25 <Welkin> there are a lot of extensions that should become standard in ghc
16:25:27 <cloudhead> Profpatsch: yeah I'm talking mostly `type`
16:25:29 <Profpatsch> Otherwise types are fine methinks (they also appear in the docs)
16:25:57 <Profpatsch> But if you want to have a smart constructor for a type’s values, always use newtypes.
16:26:07 <Profpatsch> (and don’t export the constructor)
16:26:23 <cloudhead> for example: type Cost = Int;    calculateCost :: A -> B -> Cost
16:26:30 <cloudhead> instead of just using Int
16:26:39 <Welkin> cloudhead: that is a type synonym though
16:26:50 <cloudhead> that's what I was asking about
16:26:55 <Welkin> it offers no type safety
16:26:57 <hpc> Welkin: i would rather see those extensions make it through the prime committee rather than have ghc haskell be wildly different from standard haskell
16:27:05 <hpc> (which it already is, though not /that/ wildly yet)
16:27:22 <cloudhead> Welkin: I know, I'm using them to make the code easier to understand
16:28:03 <cloudhead> but wondering if it's bad practice to use them vs. the raw type, like Int or String
16:28:21 <Profpatsch> cloudhead: No, definitely not.
16:28:34 <hpc> cloudhead: as long as it's exceptionally clear that they are aliases and not real types, it should be fine
16:28:35 <Profpatsch> Use as many descriptive names as you can. You’ll thank yourself later.
16:28:55 <dedgrant> Though, be aware of the way structural equality leads to erratic programming.
16:29:01 <hpc> cloudhead: for instance, you just used String as an example of a "raw type" when it's actually an alias for [Char]
16:29:10 <Welkin> lol
16:29:11 <cloudhead> Profpatsch: even if I end up having a dozen synonyms for Int?
16:29:15 <cloudhead> hpc: heh true
16:29:16 <Welkin> type String = [Char]
16:29:17 <Welkin> :D
16:29:29 <dedgrant> cloudhead: Reevaluate regularly, definitely.
16:29:53 <dedgrant> The difference in the case of string is that it is indexed.
16:30:06 <hpc> actually, to give a good example of aliases being not all that
16:30:15 <dedgrant> Partitions the potential for ill-defined programs :)
16:30:27 <hpc> i am starting to think FilePath should not have been an alias for String
16:30:32 <Welkin> hahaha
16:30:37 <Welkin> that has confused me many times
16:30:39 <cloudhead> heh
16:30:42 <hpc> it should have been some newtype of something that stops you putting '/' in filenames
16:30:44 <Welkin> until I realize "oh, it's just a String"
16:30:53 <dedgrant> 'starting' :D
16:31:01 <hpc> or forces you to construct files with (</>) or something
16:31:02 <cloudhead> yeah, that's what I'm worried about... you have to lookup more types that end up just being synonyms for types you already know
16:31:19 <phadej> hpc: check http://hackage.haskell.org/package/path and path-io
16:31:22 <hpc> then give it some specific read-like function
16:31:32 <hpc> osFilePath :: String -> FilePath
16:31:51 <cloudhead> = id
16:32:01 <hpc> osFilePath "C:/bacon/waffle" would fail on anything but windows
16:32:10 <cloudhead> ah I see
16:32:19 <hpc> and on windows would resolve to (Drive 'C' </> "bacon" </> "waffle")
16:32:31 <cloudhead> I think for that kind of thing, where some values are disallowed, a newtype makes more sense?
16:32:32 <hpc> and then showing that filepath would be C:\bacon\waffle with backslashes
16:33:02 <hpc> yeah
16:33:15 <cloudhead> or you just push the failure further down.. to the functions that use the paths
16:33:16 <hpc> in your case, Cost might forbid negative values
16:33:27 <cloudhead> which I guess is how it works
16:33:34 <cloudhead> hmm yeah that's true
16:33:46 <cloudhead> but then perhaps it should be a synonym for a UInt of sorts
16:34:00 <hpc> and you have to decide if that's worth the syntactic overhead of going back and forth between Int and Cost
16:34:06 <hpc> or writing a Num instance for Cost
16:34:08 <hpc> or something like that
16:34:21 <cloudhead> yeah
16:34:29 <hpc> sometimes the benefits of writing a new type really are too minor
16:34:35 <hpc> anyway, food for thought
16:34:41 <cloudhead> thanks :)
16:35:23 <dedgrant> Common lisp has probably one of the most pedantic and robust set of APIs I've ever seen for dealing with platform-agnostic file paths. A lot of opportunity for nominative type barriers there to enforce correct API use.
16:35:34 <hpc> actually let me ammend my example, that filepath would be resolved as (Drive 'C' <:/> "bacon" </> "waffle")
16:35:47 <hpc> (<:/>) being a windows-only operation to put a drive at the front of a filepath
16:36:31 <cloudhead> that's pretty type safe
16:36:36 <hpc> maybe you could do something like (envPart "appdata" </> "foobar")
16:36:54 <hpc> which would resolve to %appdata%\foobar which would further resolve to something logical
16:37:16 <hpc> though that's getting a bit more into dot-file territory
16:37:38 <hpc> on linux it'd have to be $FOO/.foobar, and that dot makes it not quite so easy
16:58:45 <Profpatsch> hpc: You know that there was a library that did exactly that? https://hackage.haskell.org/package/system-filepath
16:58:58 <Profpatsch> This is why it was deprecated: https://plus.google.com/+MichaelSnoyman/posts/Ft5hnPqpgEx
17:00:10 <Profpatsch> I think the original author had a writeup as well.
17:02:40 <Profpatsch> Ah, here (but Snoyman too) http://www.yesodweb.com/blog/2015/05/deprecating-system-filepath
17:06:07 <EvanR> filepaths should be deprecated
17:06:09 <Profpatsch> cloudhead: If you want to ensure Cost is always positive you have a few possibilities.
17:06:11 <EvanR> who needsem
17:06:30 <Profpatsch> EvanR: Every datatype except ByteString should be deprecated!
17:06:40 <EvanR> ByteString is no exception
17:06:44 <Profpatsch> Write code like it’s 1950!
17:06:58 <EvanR> you only need cons car and cdr
17:07:20 <Profpatsch> Aprospos exceptions, we need more of those.
17:07:40 <EvanR> > 3 - 4 :: Natural
17:07:42 <lambdabot>  *Exception: Natural: (-)
17:07:51 <Profpatsch> And haven’t seen enough subroutins lately. Oh, and goto is direly missed.
17:07:54 <Profpatsch> *ines
17:08:27 <Profpatsch> > :i Natural
17:08:28 <lambdabot>  <hint>:1:1: parse error on input ‘:’
17:09:01 <EvanR> its nega-guarded Integer
17:09:11 <Profpatsch> Where from?
17:09:38 <EvanR> Numeric.Natural
17:09:49 <Profpatsch> There’s natural-number, natural-numbers, type-natural and naturals on Hackage
17:10:02 <EvanR> its in base
17:10:10 <Profpatsch> Oh, nice. Hoogle doesn’t find it.
17:10:33 <EvanR> https://hackage.haskell.org/package/base-4.9.0.0/docs/Numeric-Natural.html
17:10:45 <Profpatsch> wow, such Exception
17:11:39 <Profpatsch> What do I do with such a type? I mean, exceptions can only be caught in IO
17:11:51 <EvanR> you prove that negatives never happen
17:12:06 <EvanR> but when they do, at least it fails early
17:12:33 <EvanR> the only real downside is converting back and forth because nothing uses it
17:13:06 <Profpatsch> unsafePerformIO $ catch … :: Maybe Natural
17:13:25 <EvanR> thats sort of defeating the point
17:13:59 <EvanR> unless you do stuff like that in the event of negative Integers
17:14:23 <Profpatsch> Numbers are magic. I try to stay away from them.
17:14:37 <Profpatsch> abs on every Integer operation.
17:14:47 <EvanR> nice
17:14:56 <EvanR> as long as no one ever knows its wrong, its right
17:15:15 <Profpatsch> data MyPerfectNatural
17:15:55 <mniip> ;
17:15:55 <Profpatsch> data MyPerfectlyNaturalGirlInYourNeighborhood
17:16:18 <EvanR> idris> :t (-)
17:16:27 <EvanR> (m : Nat) -> (n : Nat) -> {auto smaller : LTE n m} -> Nat
17:19:12 <Profpatsch> Only it doesn’t perform, does it?
17:19:35 <EvanR> what doesnt
17:19:46 <Profpatsch> “Given a sufficiently smart compiler, it does”
17:19:50 <Profpatsch> The Idris code.
17:19:59 <Profpatsch> Does it unbox stuff?
17:20:09 <EvanR> i think thats the least of the issues
17:20:26 <Profpatsch> Can it map those Nats to uints?
17:20:31 <EvanR> oh, yeah
17:20:42 <EvanR> not ints but gmp naturals
17:21:19 <EvanR> (beyond a certain size anyway)
17:21:53 <EvanR> would be nice to have a pluggable way to implement abstract types like that
17:22:09 <EvanR> or in the case of Nat, any type you want
17:28:47 <cloudhead> Profpatsch: how would I ensure the ints are positive?
17:29:13 <cloudhead> It's not a super big deal, so if it has too high a cost I probably won't bother
17:29:56 <Profpatsch> You could look at the existing types (Numeric.Natural) or the packages I listed earlier.
17:30:13 <Profpatsch> You can also write your type like
17:30:32 <EvanR> positive or non negative
17:30:39 <Profpatsch> data Cost = Cost Int
17:30:49 <cloudhead> I see I see, but Natural would raise a runtime error essentially
17:30:51 <Profpatsch> cost :: Int -> Maybe Cost
17:31:03 <EvanR> cloudhead: only if you have a bug
17:31:03 <Profpatsch> And then not export the Cost constructor.
17:31:04 <cloudhead> EvanR: non-negative
17:31:42 <EvanR> the smart ctor above is more idiomatic though
17:32:09 <cloudhead> yeah that could work
17:32:11 <EvanR> also its redundant if you have no bugs, and pointless if you do because you have nothing valid to do with Nothing
17:32:24 <cloudhead> haha
17:32:34 <cloudhead> well, the idea would have been to catch the bugs at compile-time
17:32:45 <EvanR> which smart ctors unfortunately dont
17:33:01 <EvanR> theyre a way to ensure you do runtime checks
17:33:02 <Profpatsch> They catch the bugs at error-handling time. :P
17:33:08 <cloudhead> :D
17:33:29 <Profpatsch> But yeah, depends on what you want to do.
17:33:32 <cloudhead> I wonder how useful a type that only had '+' and positive numbers or zero be
17:33:33 <EvanR> antipattern: case safeParseInt str of Just x -> x; Nothing -> error "oh crap"
17:33:36 <cloudhead> hmm 
17:33:39 <cloudhead> sounds like a Monoid
17:33:47 <EvanR> cloudhead: sounds like Natural
17:34:08 <cloudhead> that would ensure only >= 0 numbers
17:34:16 <cloudhead> EvanR: but how can that exception be thrown then?
17:34:19 <EvanR> oh... no zero?
17:34:25 <Profpatsch> Natural/+ is a monoid, is it not?
17:34:33 <cloudhead> if it's impossible to construct a value < 0?
17:34:42 <EvanR> safeParseInt "-345" -> Nothing
17:34:50 <Koterpillar> Profpatsch: it would be with zero
17:35:07 <cloudhead> Natural has no zero?
17:35:21 <EvanR> > 0 :: Natural
17:35:22 <lambdabot>  0
17:35:23 <Profpatsch> Int/0/+/- an inverse Monoid
17:36:16 <EvanR> cloudhead: for arbitrary restrictions of types on their values, youll need a more sophisticated smart ctor (above caveats still apply), refinement types, dependent types, type class tricks, or something like this
17:36:33 <EvanR> generally its a pain in the ass dependending on what youre doing
17:36:44 <cloudhead> hmm yeah it looks like it
17:37:02 <EvanR> your input validation stuff should stop negatives
17:37:14 <EvanR> in which case hanlding Maybes later is just annoying
17:37:21 <EvanR> because they cant happen
17:37:36 <EvanR> (and is the whole point of validation)
17:38:18 <EvanR> input validation is kind of a big deal
17:38:23 <cloudhead> yeah, I think it's the kind of thing where treating the <0 case as an exceptional situation will make my life easier
17:38:30 <cloudhead> rather than cluttering the code with Maybes
17:39:15 <sbrg> Anyone happen to know if there's a way to tell stack to only build the executable with profiling? i have no need to profile all the libraries
17:39:42 <EvanR> "i have no need to profile all the libraries" famous last words ;)
17:40:11 <sbrg> all the 3rd party libraries
17:40:26 <EvanR> when one of them has a bug and crashes up...
17:40:44 <kadoban> sbrg: Aren't there separate switches for that? I though one mentioned executable profiling and one mentioned library profiling.
17:41:10 <sbrg> yes, but they both seem to want to do the same thing
17:41:29 <sbrg> stack build --executable-profiling starts rebuilding 90 libraries with profiling
17:41:36 <kadoban> Hmm
17:41:48 <EvanR> cloudhead: that being said... its nice in idris that Nat is a lot more acceptable to use. lots of real world stuff is non negative
17:41:56 <kadoban> Then I'm not sure, I thought that that was what that one was supposed to do.
17:42:54 <cloudhead> EvanR: yeah I feel like it's such a common case, but people don't really bother with it
17:42:59 <EvanR> nope
17:43:54 * hackagebot graphviz 2999.18.1.1 - Bindings to Graphviz for graph visualisation.  https://hackage.haskell.org/package/graphviz-2999.18.1.1 (IvanMiljenovic)
18:23:55 * hackagebot ofx 0.4.2.0 - Parser for OFX data  https://hackage.haskell.org/package/ofx-0.4.2.0 (OmariNorman)
18:24:15 <Henson> '\''
18:26:02 <tempeh> What can you do when two libraries you depend on have conflicting version requirements for a third?
18:29:18 <cloudhead> tempeh: usually one is behind, so I'll check to see if it's been updated on github or wherever the source is hosted
18:29:42 <cloudhead> and use that instead of the hackage version
18:30:11 <tempeh> and if they're just old and unmaintained? no way to build it?
18:30:36 <cloudhead> then update the version in the .cabal file and see if it still compiles and run the tests
18:31:10 <cloudhead> sometimes the version bounds are just conservative
18:31:30 <ReinH> If the upper bound is spurious, you can build with --allow-newer
18:31:41 <tempeh> right, so i'll have to go maintain it myself?
18:32:18 <tempeh> ReinH: is that with stack build?
18:33:03 <ReinH> with stack, you add allow-newer: true to stack.yaml
18:33:06 <ReinH> er stack.yml
18:34:05 <tempeh> ahh brilliant. thanks ReinH and cloudhead
18:53:48 <AndChat306516> Hi
18:54:16 <AndChat306516> Hello :o
18:57:47 <mzabani> hi everyone, anyone knows how to make attoparsec's runScanner stop consuming input and return the state that has been computed so far?
19:01:20 <pavonia> mzabani: It does that when the passed function returns Nothing, no?
19:03:27 <mzabani> That's what the docs say... I must be doing something wrong
19:05:06 <mzabani> my function only returns Nothing after consuming many other characters, but it seems that only after end of input the last computed state is actually returned
19:06:57 <pavonia> Could you paste your code?
19:07:01 <pavonia> @lpaste
19:07:02 <lambdabot> Haskell pastebin: http://lpaste.net/
19:09:08 <mzabani> http://lpaste.net/169719
19:09:58 <mzabani> this is the function passed to runScanner, like so: runScanner [] parInt
19:10:23 <mzabani> I can paste a complete parser if it helps
19:10:40 <pavonia> On what input are you running it?
19:10:50 <mzabani> the purpose here is to return every digit in a string ignoring dots
19:11:10 <mzabani> so "3.4.5" should return [5, 4, 3] (it does it in reverse order)
19:11:44 <mzabani> and "3.4.5," should leave the comma for future consumption and return [5,4,3] as well
19:13:22 <pavonia> And what is the result you get?
19:13:53 <mzabani> after adding the comma the returned state is Nothing
19:14:44 <pavonia> What do you mean? The state can't be Nothing, it's not a Maybe
19:17:44 <mzabani> oops, sorry about that. The result of maybeResult (parse parser "53.2,")) is Nothing, where parser is a Parser [Int], one that uses the runScanner that I pasted
19:17:57 <mzabani> sorry if I'm making any stupid mistakes here, I'm very new to all of this
19:18:28 <mzabani> so there may be some beginner-like mistake lurking somewhere
19:20:12 <pavonia> mzabani: Where parser is what?
19:22:28 <mzabani> let me paste a working example
19:24:35 <mzabani> http://lpaste.net/169719
19:25:07 <mzabani> Try digitsOf "1.23" and digitsOf "1.23,"
19:27:37 <pavonia> Uh, my attoparsec version doesn't have runScanner :<
19:28:06 <pavonia> mzabani: What is the error message if you don't use maybeResult?
19:29:04 <mzabani> *Main> parse parser "1.23," Done "," []
19:29:36 <pavonia> Ah, so it succeeds
19:29:50 <mzabani> indeed...
19:30:47 <pavonia> maybeResult seems to fail because the parser returns a partial result, i.e. there's still input left to be processed later
19:31:47 <mzabani> oh, right! the docs talk about partial results, guess I didn't even consider that, though
19:31:48 <pavonia> Err no
19:32:37 <mzabani> but when the state accum. function returns Nothing, shouldn't runScanner return the laste computed state?
19:33:08 <pavonia> Yeah, it should be Done "," [3,2,1], IMHO
19:34:24 <mzabani> hmmm
19:34:50 <mzabani> but, anyway, if I don't want the comma to be consumed, runScanner will never work
19:35:33 <pavonia> It's not consumed
19:36:27 <mzabani> hmm, you mean that comma in the output of "parse" is the left over?
19:37:36 <mzabani> that's right, in the successful example an empty string is returned, so it could work
19:38:37 <mzabani> pavonia: thank you very much for your attention
19:38:49 <mzabani> I have to go now
19:39:14 <mzabani> I'll beat my head on this tomorrow, had enough for tonight
19:39:16 <pavonia> Yes, the comma is left over
19:39:41 <pavonia> I just don't get why an empty list is returned
19:40:47 <mzabani> I hope we can find out
19:40:55 <mzabani> gotta go now,thanks for your help
19:41:06 <pavonia> You're welcome
19:41:57 <newbie-guest> yesterday about 15:00 gmt i was asking here a question about optimising some haskell puzzle, i made some progress but it's still too slow
19:43:02 <lpaste> newbie-guest pasted “still slow” at http://lpaste.net/169723
19:43:22 <newbie-guest> http://lpaste.net/169723
19:45:06 <pavonia> newbie-guest: What was the puzzle?
19:45:09 <newbie-guest> lines 9 - 17 seem to be responsible for that. 
19:45:34 <newbie-guest> i check for palindrome only on two occasions per test case and it is not too slow
19:46:26 <pavonia> One thing I can spot is that in palRanges you're using length twice
19:46:55 <newbie-guest> but is haskell lazyness supposed to execute it only once?
19:47:11 <pavonia> No, that has nothing to do with laziness
19:47:20 <newbie-guest> I do npot fully understand how lazyness and optimisation works
19:48:04 <pavonia> Also, lists in Haskell are single-linked lists, so operations like (!!) are O(n)
19:48:05 <newbie-guest> what do you suggest? let or another subfunction after where?
19:48:25 <pavonia> If you really want to speed up, you probably should use arrays or Vectors
19:49:02 <newbie-guest> is it difficult to convert to vectors?
19:50:11 <pavonia> I don't think so
19:51:39 <goowlit> Just came here to warn you about the soon to be biggest mistake in the world of Haskell.
19:51:47 <goowlit> Someone is going to create a Firefox implementation
19:54:03 <geekosaur> that warning should be delivered to whoever was planning to destroy their sanity by creating it >.>
19:55:54 <okek> what did that even mean?
19:58:55 <newbie-guest> @pavonia thanks
19:58:55 <lambdabot> Unknown command, try @list
19:59:06 <newbie-guest> pavonia: thanks
20:05:41 <jle`> mniip: oi
20:13:59 * hackagebot coordinate 0.1.2 - A representation of latitude and longitude  https://hackage.haskell.org/package/coordinate-0.1.2 (TonyMorris)
20:44:37 <dustmote> can you use happy parsers to generate random programs (similar to quickcheck?)
20:44:49 <dustmote> eg. can i run the parser the other way
20:47:24 <pavonia> I don't think so
21:09:01 * hackagebot pinch 0.2.0.2 - An alternative implementation of Thrift for Haskell.  https://hackage.haskell.org/package/pinch-0.2.0.2 (abhinav)
21:09:03 * hackagebot sdl2 2.1.2 - Both high- and low-level bindings to the SDL library (version 2.0.2).  https://hackage.haskell.org/package/sdl2-2.1.2 (tejon)
21:14:01 * hackagebot pinch 0.3.0.1 - An alternative implementation of Thrift for Haskell.  https://hackage.haskell.org/package/pinch-0.3.0.1 (abhinav)
21:24:03 <adarqui> hey anyone know why web-encodings is deprecated? does encodeurl/decodeurl exist anywhere else? http://hackage.haskell.org/package/web-encodings-0.3.0.9/docs/Web-Encodings.html#v:encodeUrl
21:34:02 * hackagebot sdl2 2.1.2.1 - Both high- and low-level bindings to the SDL library (version 2.0.2).  https://hackage.haskell.org/package/sdl2-2.1.2.1 (tejon)
21:38:14 <adarqui> is there any way to trat a type synonym like a data constructor in pattern match? type Tuple a b = (a, b) .... map (\(Tuple a b) -> ...) 
21:39:36 <glguy> Pattern synonym
21:44:02 * hackagebot aeson-yak 0.1.1.1 - Handle JSON that may or may not be a list, or exist  https://hackage.haskell.org/package/aeson-yak-0.1.1.1 (tejon)
21:45:20 <koz_> Is aeson-yak some kind of yak-shaaving reference?
21:48:45 <geekosaur> "This library provides an intermediary data type and supporting functions to shave that stupid yak." (https://github.com/tejon/aeson-yak)
21:49:56 <koz_> geekosaur: I *thought* so...
21:50:36 <geekosaur> (and whoever schema.org is, I hereby sentence them to parsing html without any libraries.)
21:54:28 <adarqui> glguy: thanks. what's crazy is i already use that/knew of that but didnt think about it. my brain is fried ;f
21:56:13 <jamiejamiejamie> hi guys, haskell newbie here... I was wondering if anyone could point towards a resource for understanding something...
21:56:21 <jamiejamiejamie> I stumbled into compress = map head . group
21:56:44 <jamiejamiejamie> and i read it as compress = map (head . group) until I finally found out it's actually (map head) . group
21:57:01 <jamiejamiejamie> I was wondering if anyone knows of a good resource that explains this... function evaluation? 
21:57:05 <jamiejamiejamie> not sure that's the right term
21:57:11 <Koterpillar> that's precedence
21:57:24 <geekosaur> function application has higher precedence than everything else (except record update syntax, sigh)
21:57:27 <Axman6> function application always has the highest precedence
21:57:41 <Koterpillar> if you search for "haskell operator precedence" you should find relevant things
21:58:25 <jamiejamiejamie> precedence! ahhh
21:58:28 <jamiejamiejamie> thank you so much
22:01:14 <jamiejamiejamie> this language is stretching my mind out like silly putty 
22:01:19 <jamiejamiejamie> it's fantastic
22:05:03 <Iceland_jack> jamiejamiejamie: you can write it as
22:05:04 <Iceland_jack>     compress xs = map head (group xs)
22:05:27 <Iceland_jack> means the same
22:05:40 <Iceland_jack> > group "aaaBBaBB"
22:05:42 <lambdabot>  ["aaa","BB","a","BB"]
22:05:43 <jamiejamiejamie> Iceland_jack: much clearer that way too.. 
22:05:45 <jamiejamiejamie> thank you
22:06:24 <Iceland_jack> jamiejamiejamie: 'head' is a function that can fail though
22:06:24 <Iceland_jack> > head []
22:06:25 <lambdabot>  *Exception: Prelude.head: empty list
22:07:00 <Iceland_jack> but we know that "group" always returns non-empty lists (not ideal to rely on)
22:07:16 <Iceland_jack> > map head (group "aaaBBaBB")
22:07:18 <lambdabot>  "aBaB"
22:07:33 <Iceland_jack> > [ head xs | xs <- group "aaaBBaBB" ]
22:07:35 <lambdabot>  "aBaB"
22:07:42 <Iceland_jack> > [ x | x:_ <- group "aaaBBaBB" ]
22:07:44 <lambdabot>  "aBaB"
22:08:14 <jamiejamiejamie> you're blowing my mind right now... but it could still fail if the list was empty, right?
22:08:22 <jamiejamiejamie> group ""
22:08:32 <Iceland_jack> jamiejamiejamie: No it will succeede
22:08:44 <Iceland_jack> Since mapping over the empty list... does nothing
22:08:44 <Iceland_jack>     map f [] = []
22:08:48 <Iceland_jack> > group ""
22:08:50 <jamiejamiejamie> oh riiiight
22:08:50 <lambdabot>  []
22:08:59 <jamiejamiejamie> slick
22:09:03 * hackagebot http-media 0.6.4 - Processing HTTP Content-Type and Accept headers  https://hackage.haskell.org/package/http-media-0.6.4 (TimothyJones)
22:09:10 <Iceland_jack>       map head (group "")
22:09:10 <Iceland_jack>     = map head []
22:09:10 <Iceland_jack>     = []
22:09:52 <Iceland_jack> jamiejamiejamie: Can I spoil something?
22:09:57 <jamiejamiejamie> sure!
22:10:05 <Iceland_jack> It's not necessarily how it would be introduced in a book
22:10:18 <Iceland_jack> but there is a type for lists that aren't empty
22:10:30 <Iceland_jack> Do you understand this type?
22:10:30 <Iceland_jack>     (a, [a])
22:10:49 <jamiejamiejamie> a vector with two elements, one anything, one a list of anything
22:10:50 <jamiejamiejamie> right?
22:11:09 <Iceland_jack> We'd call it a tuple but otherwise yes
22:11:20 <Iceland_jack> this is a non-empty list
22:11:50 <Iceland_jack>     "a"    == ('a', "")
22:11:51 <Iceland_jack>     "ab"   == ('a', "b")
22:11:51 <Iceland_jack>     "abc"  == ('a', "bc")
22:11:51 <Iceland_jack>     "abcd" == ('a', "bcd")
22:12:23 <Iceland_jack> First component = first element of the list --- there is no way to represent the empty list like this
22:12:35 <jamiejamiejamie> oh my god
22:13:14 <Iceland_jack> So we could make it a type synonym
22:13:14 <Iceland_jack>     type NonEmpty a = (a, [a])
22:13:20 <jamiejamiejamie> very clever... since it's a tuple, does it make it harder to work with than a regular list? like, how would you use it in the previous examples?
22:13:31 <Iceland_jack> and then
22:13:31 <Iceland_jack>     ('a', "bc") :: NonEmpty Char
22:13:36 <Iceland_jack> Good question jamiejamiejamie!
22:13:56 <Iceland_jack> In the most recent version of base we have a data type that looks like
22:13:56 <Iceland_jack>     data NonEmpty a = a :| [a]
22:14:23 <Iceland_jack> Don't let the infix ":|" data constructor fool ya', this is just like our (a, [a])
22:14:40 <jamiejamiejamie> I was just about to ask about that
22:14:46 <Iceland_jack>     "a"    == 'a' :| ""
22:14:46 <Iceland_jack>     "ab"   == 'a' :| "b"
22:14:46 <Iceland_jack>     "abc"  == 'a' :| "bc"
22:14:46 <Iceland_jack>     "abcd" == 'a' :| "bcd"
22:14:51 <Iceland_jack> see the pattern?
22:15:13 <jamiejamiejamie> hm, yep, it looks awfully similar to :
22:15:18 <Iceland_jack> exactly
22:15:34 <Iceland_jack> If you desugared the "bcd" it would look like
22:15:35 <Iceland_jack>     'a' :| 'b' : 'c' : 'd' : []
22:15:49 <Iceland_jack> That's why the name was chosen
22:15:53 <Iceland_jack> Now this is what the type of our "normal" group looks like
22:15:53 <Iceland_jack>     group :: Eq a => [a] -> [[a]]
22:15:58 <Iceland_jack> Does it make sense?
22:16:20 <Iceland_jack> If we're working with a String, it's type is
22:16:20 <Iceland_jack>     group :: String -> [String]
22:16:25 <Iceland_jack> *its type
22:17:17 <jamiejamiejamie> one moment
22:17:20 <jamiejamiejamie> still wrapping my head around it
22:17:32 <Iceland_jack> It takes a single string "aaaBBaBB"
22:17:32 <Iceland_jack>  
22:17:41 <Iceland_jack> And returns a list of Strings: ["aaa","BB","a","BB"]
22:17:54 <jamiejamiejamie> oh, yeah, group, right
22:17:58 <jamiejamiejamie> a list of lsits
22:18:00 <jamiejamiejamie> *lists
22:18:02 <Iceland_jack> Yes
22:18:36 <Iceland_jack> Now we read the Bible and it told us the lists in the list are *never* empty
22:18:43 <Iceland_jack> but Haskell doesn't know that
22:19:08 <Iceland_jack> jamiejamiejamie: So "Data.List.NonEmpty" has its own version of 'group' which has a more descriptive type
22:19:19 <Iceland_jack>     group :: String -> [NonEmpty Char]
22:19:41 <jamiejamiejamie> ohhh, there's another implementation... I wondered how you were going to tie that all together
22:19:51 <jamiejamiejamie> that is more descriptive!
22:19:53 <Iceland_jack> This is the output of Data.List.NonEmpty.group
22:20:07 <Iceland_jack>     >>> group "aaaBBaBB"
22:20:07 <Iceland_jack>     ['a' :| "aa",'B' :| "B",'a' :| "",'B' :| "B"]
22:20:33 <jamiejamiejamie> sure, makes sense
22:20:52 <jamiejamiejamie> how would you "say" the ":|" operator, by the way?
22:20:57 <Iceland_jack> This is more difficult to read, but it's just telling us
22:20:57 <Iceland_jack>     "aaa" == 'a' :| "aa"
22:20:57 <Iceland_jack>     "BB"  == 'B' :| "B"
22:20:57 <Iceland_jack>     "a"   == 'a' :| ""
22:21:00 <Iceland_jack>     "BB"  == 'B' :| "B"
22:21:09 <Iceland_jack> jamiejamiejamie: I'd just say "cons", same as (:)
22:21:30 <Iceland_jack> it's not well known enough to have a name, maybe "non-empty cons" if you want to distinguish between the wao
22:21:36 <jamiejamiejamie> shoutout to lisp! 
22:21:43 <Iceland_jack> Indeed :)
22:21:59 <Iceland_jack> jamiejamiejamie: Do you know 'fst' / 'snd'?
22:22:06 <jamiejamiejamie> so it functions very similarly to (:).. why do we need (:|) then? I'm struggling to understand the extra "sugar" (:|) gives us
22:22:11 <jamiejamiejamie> I do
22:22:14 <Iceland_jack> Ah 
22:22:16 <Iceland_jack> real quick
22:22:31 <Iceland_jack>     data NonEmpty a = a :| [a]
22:22:31 <Iceland_jack> defines an entirely *new* data type
22:22:57 <Iceland_jack> I made a mistake using '==' between "aaa" and 'a':|"aa" because their types are completely different
22:23:30 <jamiejamiejamie> sure... from what i've read, I've usually seen something like data Maybe a = Nothing | Just a ... which makes sense to me, it's saying it's one or the other
22:23:41 <Iceland_jack> Yes, in this case it's saying "both"
22:23:55 <jamiejamiejamie> ohhhh
22:24:00 <jamiejamiejamie> I see
22:24:02 <jamiejamiejamie> thank you
22:24:08 <Iceland_jack> Just like our tuples
22:24:08 <Iceland_jack>     (a, [a])
22:24:09 <Iceland_jack> says "both" a value *and* a list of values of the same type
22:24:14 <jamiejamiejamie> presumably then, there are other data types which use (:|)
22:24:24 <jamiejamiejamie> for some silly reason I thought it was special to NonEmpty
22:24:26 <Iceland_jack> No
22:24:31 <jamiejamiejamie> no? oh
22:24:45 <Iceland_jack> It is special to NonEmpty, in the sense that if I used it in my library they would "clash"
22:25:07 <Koterpillar> there's not much difference between ":|" and "group". Both are names
22:25:12 <Iceland_jack> It's maybe easier writing it not as an operator
22:25:13 <Iceland_jack>     data NonEmpty a = NE a [a]
22:25:52 <Koterpillar> :| can implicitly be used in an infix position though. I can define some other type using :| and call it a different thing, and it'll be up to you to import one or the other
22:25:55 <Iceland_jack>     "aaa"   becomes   NE 'a' "aa"
22:25:56 <Iceland_jack>     "BB"    becomes   NE 'B' "B"
22:25:56 <Iceland_jack>     "a"     becomes   NE 'a' ""
22:26:10 <jamiejamiejamie> ahhh
22:26:12 <jamiejamiejamie> I see
22:26:31 <Iceland_jack> jamiejamiejamie: It may become clearer when you realize 'head' is defined as
22:26:31 <Iceland_jack>     head :: NonEmpty a -> a
22:26:31 <Iceland_jack>     head (x :| _) = x
22:26:35 <Iceland_jack> and it *cannot* fail
22:27:02 <Iceland_jack> And 'tail' is defined as
22:27:03 <Iceland_jack>     tail :: NonEmpty a -> [a]
22:27:03 <Iceland_jack>     tail (_ :| xs) = xs
22:27:10 <jamiejamiejamie> that's very nice.. that answers my question of what people do about empty lists
22:27:42 <Iceland_jack> (notice that 'head' is just 'fst, and that 'tail' is just 'snd')
22:28:00 <Iceland_jack> (conceptually)
22:28:16 <jamiejamiejamie> oh, yes, that makes sense, considering your earlier definition of nonempty as (a, [a])
22:28:22 <Iceland_jack> Exactly
22:28:47 <Iceland_jack> I'm not sure if bringing this up was good pedagogy 
22:29:15 <jamiejamiejamie> by the way, question about terminology... in the case of that NonEmpty data type, would NE (or :|) be called a "data constructor"?
22:29:22 <Iceland_jack> That's right
22:29:29 <jamiejamiejamie> ah, perfect
22:29:30 <Iceland_jack> NonEmpty would be a type constructor
22:30:12 <Iceland_jack> but this was an excellent example of moving things you'd put in comments
22:30:13 <Iceland_jack>     -- NOTA BENE: It's okay to use head, since the elements of the result
22:30:13 <Iceland_jack>     -- of 'group' are always non-empty.
22:30:13 <Iceland_jack>     map head (group xs)
22:30:27 <Iceland_jack> into the type system
22:31:02 <Iceland_jack> jamiejamiejamie: (,) is actually a data constructor too
22:31:10 <Iceland_jack> You can write
22:31:10 <Iceland_jack> > ('a', "bcd")
22:31:12 <lambdabot>  ('a',"bcd")
22:31:15 <Iceland_jack> as
22:31:15 <Iceland_jack> > (,) 'a' "bcd"
22:31:17 <lambdabot>  ('a',"bcd")
22:31:28 <jamiejamiejamie> oh my
22:31:35 <Iceland_jack> Same with (:|)
22:31:46 <Iceland_jack>     >>> (:|) 'a' "bcd"
22:31:46 <Iceland_jack>     'a' :| "bcd"
22:32:15 <Iceland_jack> jamiejamiejamie: We can try it right now
22:32:15 <Iceland_jack> @let data Foo = Int :+: Int deriving Show
22:32:16 <lambdabot>  Defined.
22:32:20 <esteth> Does anyone know if there's a stable, existing way to serialize coroutines in haskell? I want the equivalent of pypy/stackless's tasklets, which i can save to disk or send over the network while they're yielded.
22:32:23 <Iceland_jack> > 10 :+: 20
22:32:24 <lambdabot>  10 :+: 20
22:32:31 <Iceland_jack> > (:+:) 10 20
22:32:32 <lambdabot>  10 :+: 20
22:32:57 <jamiejamiejamie> wow
22:33:08 <jamiejamiejamie> Iceland_jack: you just defined a custom operator
22:33:13 <Iceland_jack> That's right
22:33:15 <jamiejamiejamie> as a data constructor
22:33:19 <jamiejamiejamie> it just got real in here
22:33:26 <Iceland_jack> jamiejamiejamie: okay, now I can't help myself
22:33:31 <Iceland_jack> > let 2 + 2 = 5 in 2 + 2 
22:33:33 <lambdabot>  5
22:33:58 <Iceland_jack> I 'redefined' (shadowed) the regular (+) operator
22:34:58 <jamiejamiejamie> just a minute while I read this carefully...
22:35:29 <jamiejamiejamie> that is crazy cool, but I have a couple follow up questions
22:35:33 <Iceland_jack> shoot
22:35:40 <jamiejamiejamie> first, I'm not familiar with the use of "in"
22:36:05 <Iceland_jack> Okay,
22:36:06 <Iceland_jack>     let a = 10
22:36:06 <Iceland_jack>         b = 5
22:36:06 <Iceland_jack>      in a + b
22:36:11 <Iceland_jack> this evaluates to 15
22:36:11 <jamiejamiejamie> and is it possible to arbitrarily shadow/override operators? if so, that seems incredibly dangerous, cause if a library feels like redefining multiplication to be addition...
22:36:17 <Iceland_jack> if that makes it clearer
22:36:30 <jamiejamiejamie> ah, yep, that makes sense
22:36:32 <Iceland_jack> jamiejamiejamie: It doesn't happen with dynamic scope
22:37:21 <Iceland_jack> A library can certainly export (+), but then it would clash with the regular (+) and you as a user go "huh, what a dummy"
22:37:22 <Iceland_jack>     import Library hiding ( (+) )
22:37:41 <Iceland_jack> If you shadow it at a function level, you can obviously see the source
22:37:41 <Iceland_jack>     foo (+) = ...
22:38:12 <Iceland_jack> so it's not dangerous at all
22:38:22 <jamiejamiejamie> I see, all right
22:38:36 <jamiejamiejamie> that brings up another question... when you made
22:38:43 <jamiejamiejamie> data Foo = Int :+: Int deriving Show
22:38:47 <Iceland_jack> yes
22:39:11 <jamiejamiejamie> my first instinct is to think that (:) will try to do its... "normal thing", which is the list prepend 
22:39:26 <Iceland_jack> aaah, good question good question
22:39:27 <jamiejamiejamie> but it seems it becomes an arbitrary symbol in the type
22:39:39 <Iceland_jack> It becomes an arbitrary symbol in the terms
22:39:48 <Iceland_jack> The magic is, (:) doesn't do ****
22:40:06 <magic> ****
22:40:18 <Iceland_jack> insert own explitive
22:40:52 <jamiejamiejamie> okay, sure
22:41:02 <jamiejamiejamie> for my follow up question, I need to ensure I'm going to use the right terminology
22:41:07 <Iceland_jack> You could just as well write
22:41:08 <Iceland_jack>     1:2:3:4:[]
22:41:08 <Iceland_jack> as
22:41:08 <Iceland_jack>     (:) 1 ((:) 2 ((:) 3 ((:) 4 [])))
22:41:38 <jamiejamiejamie> "data Foo = Int :+: Int deriving Show" is a ... "data type definition"?
22:41:39 <Iceland_jack> and then you could just as well represent it with lispy notion
22:41:39 <Iceland_jack>     (cons 1 (cons 2 (cons 3 (cons 4 nil))))
22:41:43 <Iceland_jack> Yes
22:42:10 <jamiejamiejamie> ah, excellent
22:42:26 <Iceland_jack> (this represents a list, you can clearly see its shape yet 'cons' and 'nil' are just do-nothing labels
22:42:27 <jamiejamiejamie> so does that rule of "things becoming arbitrary symbols" only apply in data type definitions?
22:42:30 <Iceland_jack> )
22:42:51 <Iceland_jack> That's basically what a constructor is :) here is a question, does True actually indicate truth?
22:43:06 <Iceland_jack> Currently, 'Bool' is defined as such
22:43:06 <Iceland_jack>     data Bool = False | True
22:43:25 <jamiejamiejamie> but that could just as well be Bool = Cheese | Pasta, couldn't it... ?
22:43:33 <Iceland_jack> That's exactly the point :)
22:43:37 <jamiejamiejamie> ahh
22:43:38 <Iceland_jack> I could just as well define in my own library
22:43:39 <Iceland_jack>     data Bool = A | B
22:43:43 <jamiejamiejamie> so the semantic meaning is assigned by the programmer
22:43:46 <Iceland_jack> Yes
22:44:03 <jamiejamiejamie> that's kind of an a-ha moment for me!
22:44:11 <Iceland_jack> jamiejamiejamie: We could just as well interpret that "cons" *appends* a value to a list
22:44:52 <Iceland_jack> So
22:44:52 <Iceland_jack>     (cons 1 (cons 2 (cons 3 (cons 4 nil))))
22:44:52 <Iceland_jack> means
22:44:53 <Iceland_jack>     ((([] ++ [4]) ++ [3]) ++ [2]) ++ [1]
22:44:56 <Iceland_jack> means
22:44:59 <Iceland_jack>     [4,3,2,1]
22:45:53 <jamiejamiejamie> ah yes
22:45:53 <undreren> > nil
22:45:55 <lambdabot>  Not in scope: ‘nil’
22:45:57 <Koterpillar> I'm just waiting to see jamiejamiejamie's reaction to how True defined in lambda calculus
22:46:21 <jamiejamiejamie> man, I started reading a book on lambda calculus but I haven't gotten that far yet ... 
22:46:36 <Iceland_jack> That's another story :) jamiejamiejamie: You probably think you'd need some fancy stuff to define data types
22:46:41 <Iceland_jack> but all you need are functions
22:47:16 <jamiejamiejamie> can you elaborate?
22:47:41 <Iceland_jack> You can encode them as
22:47:41 <Iceland_jack> :t \tru fls -> tru       -- TRUE
22:47:43 <lambdabot> r1 -> r -> r1
22:47:46 <Iceland_jack> :t \tru fls -> fls       -- FALSE
22:47:47 <lambdabot> r -> r1 -> r1
22:48:00 <Iceland_jack> (again, this choice (encoding) is arbitrary)
22:48:13 <Koterpillar> not so much if you don't have any constants
22:48:48 <Iceland_jack> Where do you need constants
22:49:05 <Koterpillar> without them, the only value you can make that's a function of 1 argument is \a -> a
22:49:16 <Koterpillar> that's not enough to represent two values (true and false)
22:49:28 <Iceland_jack> Look at the two lambda abstractions above
22:49:32 <Koterpillar> therefore, you need at least two arguments
22:49:37 <Iceland_jack> well, yes
22:49:42 <Iceland_jack> but you don't need constants
22:49:52 <Iceland_jack> Just abstractions (\x -> ...) and variables (x, y, ...)
22:50:10 <Iceland_jack> (application is not needed to define True/False)
22:50:32 <jamiejamiejamie> ... I'm going to start reading that book again
22:50:51 <Iceland_jack> For example, negation is
22:50:51 <Iceland_jack> :t \p -> p (\tru fls -> tru) (\tru fls -> fls)
22:50:52 <lambdabot> ((r2 -> r1 -> r2) -> (r3 -> r4 -> r4) -> r) -> r
22:51:46 <Iceland_jack> Mixed up the ordering
22:51:46 <Iceland_jack> :t \p -> p (\tru fls -> fls) (\tru fls -> tru)
22:51:47 <lambdabot> ((r1 -> r2 -> r2) -> (r4 -> r3 -> r4) -> r) -> r
22:52:05 <Iceland_jack>     true  t _ = t
22:52:06 <Iceland_jack>     false _ f = f
22:52:06 <Iceland_jack>     not p     = p false true
22:52:06 <Iceland_jack> nicer syntax
22:52:21 <Iceland_jack> anyway
22:52:36 <jamiejamiejamie> not p = p false true
22:52:44 <jamiejamiejamie> I have some mulling to do on that one
22:52:52 <jamiejamiejamie> this has been illuminating, thank you
22:52:56 <Iceland_jack> You're welcome
22:52:59 <jamiejamiejamie> are you gentlemen often on this channel?
22:53:13 <Iceland_jack> I'm usually here, may take some time to respond
22:53:55 <shachaf> Not all folks here are gentlemen.
22:54:08 <jamiejamiejamie> well, excellent! I'm sure I will have more questions in the future, though i will try not to pester you
22:54:15 <Iceland_jack> yes indeed
22:54:18 <jamiejamiejamie> thank you again, many times
22:54:24 <Iceland_jack> jamiejamiejamie: check your PM
22:59:05 * hackagebot leapseconds-announced 2017 - Leap seconds announced at library release time.  https://hackage.haskell.org/package/leapseconds-announced-2017 (BjornBuckwalter)
23:04:47 <raduom> does anyone use a ligature font on windows and if so did you find out how to make it render the font better (like it does on osx?)
23:05:34 <shachaf> This channel is for talking about Haskell.
23:13:21 <pollz> I need help regarding file IO. In most competitive programming challenges you are supposed to read the first line having the number of test cases and then the next lines contain the test cases. In C or C++ I could set a loop after reading the first line, but is there a better way to do this in Haskell?
23:14:15 <mauke> do n <- readLn; forM_ [1 .. n] $ \i -> do ...
23:14:39 <pollz> mauke: oh
23:15:50 <inerkick> Getting this error. kindly help http://lpaste.net/169730
23:15:59 <pollz> mauke: What would I do if I had to answer a problem like this: I need to count the number of lines in a given test case which do not have more than ten characters. Now if the input specification is like "T Test cases and each test case starts with a number N having the number of lines in the test case" what would I have to do?
23:16:14 <pollz> Two do loops?
23:17:12 <pollz> sorry for sounding retarded but I have only discovered functional programming last week
23:18:09 <Koterpillar> pollz: you would do it in a language you know well; there are books that help make Haskell one of those ;)
23:18:37 <Koterpillar> I don't see two loops in your problem description
23:18:45 <qmm> how do you create a function definitions with assembly operations? is there a resource online that could teach me this plus how to handle control flow in assembly?
23:19:12 <mauke> pollz: yes
23:19:18 <qmm> i'm sure function defintions are easy and control flow is complex
23:19:28 <mauke> qmm: this is #haskell
23:19:28 <pollz> Koterpillar: No the input is like this : 3\n5(5 lines follow)n7(7 lines follow)\n
23:19:30 <Koterpillar> qmm: this is not a channel about assembly, unless - for whatever reason - you want to embed assembly definitions in haskell
23:19:39 <Koterpillar> pollz: ah! then yes
23:19:43 <qmm> Koterpillar: that's what i'm doing
23:20:07 <Koterpillar> pollz: you can nest the exact construct mauke suggested
23:20:21 <pollz> Koterpillar: Ok Coo will try and get back to you guys
23:20:30 <Cale> inerkick: That's not an error, it's just a warning that the location to which it installed Happy's executable is not currently in your PATH
23:20:47 <Iceland_jack> Somewhat relevant proposal: https://ghc.haskell.org/trac/ghc/ticket/11441 discussing inlining cmm (core, strict core, ...)
23:20:53 <qmm> mauke, kantokomi: do you have a recommended channel for these topics by chance?
23:20:57 <pollz> Koterpillar: any quick suggestions for resources which teach mapM forM et cetera quickly (some cheat sheet if thats what you call)
23:21:05 <Iceland_jack> Not assembly, not implemented.
23:21:09 <inerkick> ok. But . But I didn't do anything not to set the path Ca
23:22:58 <Cale> inerkick: yeah, it's just telling you that because you might want to add that directory to your PATH, which involves editing the startup script for your shell, like .profile or .bashrc or .zshrc
23:23:04 <inerkick> What will be difference now if I install using apt-get than stack which I used earlier, Cale 
23:24:00 <Koterpillar> apt-get install happy, you mean?
23:24:01 <Cale> apt-get will install the program system globally, and will most likely install a different version of it
23:24:29 <akfp> is there an option or a way to force import of hidden modules?
23:24:37 <inerkick> I got this issue yesterday http://stackoverflow.com/questions/35819659/cannot-install-ghc-mod-due-to-happy-cannot-be-installed and for that I read that I need to install happy and than Hlint and Ghc-mod. But it's not working. Kindly help
23:25:33 <inerkick> Just a newbie trying to setup haskell properly . Earlier had Haskell systemwide, but screwed up my OS I guess. So trying to install through stack. 
23:27:23 <Cale> inerkick: Oh, you're on Mac OS X? You probably won't have apt-get then...
23:27:37 <inerkick> no , Ubuntu Cale 
23:27:46 <Cale> ah, okay
23:28:29 <Cale> (the guy who posted the SO question was a Mac user, I guess)
23:28:33 <inerkick> I couldn't find a complete guide or docs of stack helping newbies to install Haskell without much glitch. All I see is a distributed guidance of Stack, CAbal instal. And it just screws up installing each time
23:29:01 <Cale> You don't really need ghc-mod to get started, lots of people don't bother with it
23:29:30 <inerkick> I keep getting those errors in my VSCODe which you can see in that link of stackoverflow. 
23:29:44 <inerkick> https://stackoverflow.com/questions/38322699/vscode-editor-got-errors-while-using-haskell-installed-using-stackage
23:30:25 <inerkick> No one replied in STackoverflow, Cale . Hence thought better to reach here and look for help. 
23:30:28 <Cale> Maybe turn off whatever thing requires ghc-mod?
23:31:02 <inerkick> what you mean, Cale 
23:31:19 <Cale> I have no idea what vscode is about
23:31:35 <inerkick> you mean just uninstall that extension of vscode for this moment. VS code is just an opensource editor
23:31:36 <Cale> But from the responses there, it sounds like it's a plugin to vscode which requires ghc-mod
23:31:38 <Cale> yeah
23:31:53 <inerkick> https://code.visualstudio.com/
23:32:19 <inerkick> Yeah, I did tried to install GHC-mod and happy. And it says I need to have happy. 
23:32:35 <inerkick> and when I try to install happy it says path not set as you can see
23:32:36 <Cale> Yeah, just make sure that happy is in your PATH, and it should find it
23:32:46 <inerkick> how to do so
23:32:53 <inerkick> kindly help
23:33:22 <Koterpillar> inerkick: your OS?
23:33:28 <Cale> Either add that directory to your PATH, or move the executable from that directory to some directory which is listed in your PATH environment variable.
23:33:28 <inerkick> Ubuntu 14.04
23:33:48 <Koterpillar> inerkick: http://askubuntu.com/questions/60218/how-to-add-a-directory-to-my-path
23:34:05 <inerkick> my ghci is in /usr/bin/ghci 
23:34:15 <Koterpillar> what about happy?
23:34:20 <Koterpillar> it would be in ~/.local/bin
23:34:23 <inerkick> I couldn't install happy
23:34:31 <inerkick> Koterpillar, . 
23:34:39 <Cale> inerkick: No, the installation was successful
23:34:42 <Koterpillar> what did it say?
23:35:00 <Cale> The only part which wasn't a success was that it installed to a location which didn't happen to already be in your PATH
23:35:03 <inerkick> OH is it, Cale .I thought it didn't install it yet due to path not setting it properly
23:35:07 <Koterpillar> ^^
23:35:13 <inerkick> oh ok 
23:36:49 <inerkick> command "which happy" doesn't show if happy is installed
23:36:51 <inerkick> :(
23:36:59 <Koterpillar> because it's not on PATH
23:37:08 <inerkick> ok
23:37:10 <Koterpillar> follow the Askubuntu answer I posted
23:37:25 <inerkick> ok
23:37:33 <Koterpillar> except it should be $HOME/.local/bin, not $HOME/bin
23:37:55 <inerkick> ok
23:44:36 <Mateon1> Hi, I'm having issues with Cabal. I'm using Haskell Platform 8.0.1, and I have just reinstalled a couple of libraries to have profiling support. When I try to build my project, I get multiple messages like: C:/Path/To/HaskellPlatform/8.0.1/mingw/bin/ld.exe: Cannot find -lHSprimitive-0.6.1.0-lp44DqhfCp21tTUYbecwa_p; ending with: collect2.exe: error: ld returned 1 exit statis and `gcc.exe` failed in phase `Linker`. (Exit code: 1)
23:49:35 <adarqui> how come you can list exposed-modules on new lines without commas in cabal, but you can't do that with build-depends? or can u and maybe im just doing it wrong
23:51:12 <undreren> I'm currently developing a small game about pushing paperwork for Fantasy Adventurers, though I've only just begun working on the backend, which will rely on GLFW, Glass and Elerea. The problem is that I am working on a linux machine, and I want it to be able to run on Windows and Mac. Is there anything I should be aware of?
23:51:39 <undreren> I'm worrying about how to make it cross platform, because I have no idea how that works
23:51:40 <quchen> Mateon1: Could it be that you forgot adding a module to your .cabal file?
23:52:20 <Mateon1> quchen: I can tell you it's not the case, the only change was adding profiling flags, and reinstalling the libraries with profiling support manually
23:52:28 <Mateon1> quchen: It worked before that
23:53:03 <Mateon1> quchen: Also, wouldn't it fail during the build, not during the linking in that case?
23:56:58 <quchen> Probably, yes.
23:57:46 <quchen> Reinstallations are often a bit problematic with Cabal. When I ran into this (before using Stack most of the time) I usually reinstalled everything to get rid of the error.
23:59:09 <inerkick> still not working Koterpillar 
23:59:38 <Mateon1> quchen: So I should just purge/unregister all libraries and take 2 hours reinstalling everything again?
