00:00:30 <ReinH> map tasks . filter (\i -> invoiceClient i == client)
00:00:38 <jeroenbourgois> ok, let me give that a go
00:00:39 <ReinH> to have a list of tasks, replace map with concatMap
00:00:52 <jeroenbourgois> both ReinH and pavonia: thanks for your time!
00:01:59 <ReinH> *array of arrays of tasks
00:03:14 <Welkin> the funny thing is that javascript arrays are not even arrays
00:03:43 <Welkin> they are hashmaps with integer keys
00:04:06 <ReinH> Welkin: and when you say integer
00:04:14 <nomeata> joeyh: Hi. Debian has a version of git-annex that is not yet on hackage, which confuses the hell out of our packaging scripts. Would you mind uploading 6.20160719 to hackage?
00:04:37 <ReinH> Welkin: you mean floating point number pretending to be an integer
00:05:11 <Welkin> hm, not sure actually
00:05:15 <pavonia> Is that JS "i => ..." something like a lambda expression in Haskell?
00:05:22 <Welkin> at least in lua, there is a way to distinguish between integers and floats
00:05:26 <Welkin> pavonia: yes
00:05:35 <Welkin> that is a lambda in es6
00:05:41 <ReinH> Welkin: https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript#Numbers
00:05:44 <Welkin> no idea why they use => instead of ->
00:05:47 <Welkin> seems random
00:05:50 <Welkin> swift uses ->
00:06:12 <Koterpillar> clashing with subtraction?
00:06:15 <pavonia> My JS knowledge is obviously very outdated
00:06:42 <ReinH> Welkin: TL;DR: JS only has one "number" type, which is an IEEE 754 double.
00:07:16 <ReinH> Although I think it's possible that modern implementations are fed up with that and actually store ints as ints.
00:08:02 <jeroenbourgois> pavonia: I think it is some kind of lambda thing, this is es6 syntax, in older syntax it would be  list.filter(function(arg) { return arg === check })
00:08:03 <Welkin> js is so fragmented, you need to compile it using a complex build system into older specifications to ensure it will run in all browsers
00:08:06 <ReinH> Welkin: Of all the dubious JS design decisions, "all numbers are doubles" is my favorite.
00:08:48 <ReinH> "Surely this won't cause any problems, as it never has in the history of software engineering heretofore."
00:09:01 <jeroenbourgois> ReinH, Welkin and pavonia: sorry for bringing js in here, it was just as an example :P please let it be ;) I use it on a daily basis. While being far from perfect, it get's my job done very well
00:09:49 <ReinH> jeroenbourgois: you're fine, I probably should shut up about it. :)
00:10:10 <jeroenbourgois> :D
00:13:07 <Welkin> jeroenbourgois: using ramda?
00:16:49 <ertes> jeroenbourgois: your JS example translates almost literally to haskell:  map tasks . filter (\i -> client i == clientName) :: [Invoice] -> [Task]
00:17:29 <ertes> jeroenbourgois: assuming that Invoice has fields called 'client' and 'tasks', and a value 'clientName' is in scope
00:17:54 <ertes> uhm
00:18:01 <ertes> [Invoice] -> [[Task]]  -- rather
00:20:34 <ReinH> ertes: I did mention that :)
00:21:35 <ertes> ReinH: sorry, i didn't read the whole backlog…  i was just triggered by "JS is crap" and wanted to know what it's about =)
00:23:03 <jeroenbourgois> ertes: thanks! looks great. For some stupid reason I have the tendency to put everything in it's own pattern matched function now :P this is my second week of haskell :D
00:23:33 <ertes> jeroenbourgois: no worries…  if you want a flat list use 'concatMap' instead of 'map'
00:23:58 <jeroenbo1rgois> ok
00:25:06 <ReinH> ertes: I did also mention that :D
00:25:20 <ertes> ReinH: sorry, i didn't read the whole backlog…  i was just triggered by "JS is crap" and wanted to know what it's about ;)
00:25:22 <ReinH> ertes: in fact we gave almost exactly the same answer, funny :)
00:25:34 <ReinH> ertes: not a problem, it's just humorous
00:25:37 <ertes> hehe
00:26:26 <ertes> jeroenbo1rgois: of course now would be a good time to introduce you to our beloved functional data structures like Map, and to certain design considerations
00:26:59 <ertes> but i'll let someone else do that =)
00:27:52 <ertes> ReinH: in case you mentioned that, too…
00:28:00 <ertes> i'll start believing in wormholes ;)
00:28:13 <ReinH> ertes: No you're good
00:31:46 <Welkin> lol ertes 
00:31:49 <Welkin> how is that functional
00:32:06 <Welkin> I thought you were going to say finger trees
00:32:52 <ertes> Welkin: not yet =)
00:33:25 <ertes> (i use them far less often than my finger-tree marketing might suggest)
00:35:52 <ReinH> Welkin: Map is a finger tree...
00:36:15 <ertes> ReinH: huh?  no
00:36:18 <Welkin> I thought it was a self-balancing binary tree
00:36:28 <Welkin> Sequence is a finger tree
00:36:32 <ertes> ReinH: in containers Seq is a finger-tree
00:36:42 <ReinH> Oh yeah, that's right.
00:38:40 <ReinH> I'm trying to figure out how to combine a line-number metric with the usual metric used for ropes, actually
00:38:54 <ertes> ReinH: use a product monoid
00:38:59 <ReinH> ertes: well yes
00:39:56 <ReinH> But then split isn't sufficient
00:40:05 <ReinH> since you want to split on either
00:40:08 <ReinH> depending on usage
00:41:16 <ertes> ReinH: why not?
00:41:49 <ReinH> because sometimes you want to split on block length and sometimes you want to split on line number
00:42:01 <ertes> sure…  'split' can do that
00:42:35 <ertes> split ((>= 50) . charCount)
00:42:46 <ertes> split ((>= 5) . lineCount)
00:43:58 <ReinH> Hmm, right
00:44:07 <ReinH> Why did I think that wouldn't work
00:44:13 <ReinH> Maybe becaue it's late.
00:46:01 <ReinH> ertes: I guess I can write that editor now, thanks
00:46:16 <ertes> ReinH: have fun =)
01:07:06 <boj`> using pipes, how would one take N bytes, then use that result to take result more bytes, then finally push the final value downstream?
01:11:39 <boj`> ah, i may have it
01:35:07 <lpaste> telmich pasted “how to add let n = length (x:xs) before where?” at http://lpaste.net/171042
01:35:18 <telmich> how do I combine let with where? I'd like to define "n" as the number of elements in (x:xs) so I can use it for testing the diagonal later?
01:35:56 <telmich> let alone in a function works fine, the code pasted above works fine, however using let and then continue the local function definitons gives me a syntax error
01:39:04 <geekosaur> you can't, because even if you use the correct form of let (expression form let ... in ..., since you are not in a do block) its scope will terminate at the where
01:40:08 <geekosaur> but you should be able to bind n in the outer where
01:41:46 <lpaste> geekosaur annotated “how to add let n = length (x:xs) before where?” with “how to add let n = length (x:xs) before where? (annotation)” at http://lpaste.net/171042#a171044
02:16:11 <kosc_> Hello. Can you please give me some haskell projects that uses TDD with hspec?
02:23:44 * hackagebot cmark-lucid 0.1.0.0 - Use cmark with Lucid  https://hackage.haskell.org/package/cmark-lucid-0.1.0.0 (Artyom)
02:35:28 <merijn> I'm not sure there's much TDD going on in the haskell world
02:38:48 <kosc_> merijn: But is it a good practic for haskell projects?
02:39:57 <merijn> I'm personally not convinced TDD is good practice for any project, so I'm probably not the person to ask :)
02:46:03 <zomg> merijn: you'd change your mind if you used JavaScript or something :D
02:47:32 <zomg> but yeah although I'm a big fan of TDD with dynamic langs, I find there is less need for it with Haskell
02:55:26 <merijn> zomg: I wouldn't be caught dead writing JS :)
02:56:33 <zomg> hehe
03:12:51 <ertesx> kosc_: we use tests, but we don't typically use "TDD" in the typical sense (100% coverage, etc.)
03:13:36 <ertesx> kosc_: you may look into the more numerical libraries on hackage, which may have more test coverage
03:18:29 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
03:18:29 --- topic: set by Cale!~Cale@2607:fea8:9840:324:58c2:98f3:e7ff:280e on [Thu Jun 23 02:10:43 2016]
03:53:46 * hackagebot isobmff-builder 0.3.0.0 - A (bytestring-) builder for the ISO-14496-12 base media file format  https://hackage.haskell.org/package/isobmff-builder-0.3.0.0 (SvenHeyll)
04:09:31 <wedens> what's so cool about Cofree interpreters? I don't understand motivation (I'm reading this series http://dlaing.org/cofun/)
04:11:51 <phadej> you can build bigger one from pieces? (i.e. the same coolness as with extensible effects)
04:31:01 <hexagoxel> so.. memoizing a `b -> m c` is counterproductive. well i guess it depends on the `m`.
04:35:26 <hexagoxel> in my testcase no monadic effects are used; i just `return`. My best guess is that i still memoize long lists of fmaps around some `return`, encoded inefficiently.
04:36:02 <hexagoxel> (that seems to be a counterargument to transformers (?))
04:47:22 <cupcake3> I'm new to Haskell. I have a class called Vehicle which the types Car and Bike implement, but the compiler complains about this: data Garage = Garage Vehicle Vehicle. What is the natural way to create such a data structure?
04:48:16 <merijn> cupcake3: Unlike OO language classes aren't datatypes, therefore they can't be stored in datatypes
04:49:04 <zomg> cupcake3: one way to do it would be to have a sum type, `data Vehicle = Car | Bike`
04:49:55 <ertesx> cupcake3: Vehicle should be a type, but not a sum type…  instead it should be the semantics of vehicles, including the functions you expect a vehicle "object type" to have
04:50:42 <ertesx> cupcake3: the reason i put "object type" in quotes is that there is no clear 1:1 mapping between OO classes and haskell concepts
04:51:08 <ertesx> in particular some OO classes would be types (like Vehicle), and some would be rather values (like car and bike)
04:51:19 <ertesx> and none of them would be type classes
04:54:57 <cupcake3> Thanks for the responses.
04:55:53 <cupcake3> ertesx: But a bike and car may have nothing in common except that they implement a 'drive' function? I might add more Vehicles that are implemented completely differently too
04:56:35 <ertesx> cupcake3: they have in common that they are vehicles
04:56:38 <cupcake3> merjin ertesx: I'm still stuck thinking in terms of OOP
04:56:59 <ertesx> just like 3 and 4 have in common that they are integers, a car and a bike have in common that they are vehicles
04:57:11 <LKoen> you can think of type classes as "properties" a type can have cupcake3
04:57:37 <LKoen> for instance both a car and a bike are drivable, so you could make a Drivable type class
04:57:52 <Zemyla> cupcake3: If you really want an OOish thing, you can create a value that contains a bunch of functions, which do different things based on how they were constructed.
04:57:54 <ertesx> i strongly suggest that you don't make *any* type classes for now
04:58:18 <Zemyla> Like a drivable thing might have a drive :: IO () record.
04:58:29 <ertesx> it's too tempting to abuse type classes to emulate OO and become very sad very quickly
04:59:14 <cupcake3> ertesx: That's true!
04:59:40 <ertesx> the way to do (java/C++-style) OO in haskell is with types and values, not with classes
05:00:14 <hpc> the thing to remember is that type classes don't really get you polymorphism in the way you would expect
05:00:34 <hpc> it only gets you code reuse
05:00:47 <quicksilver> the first rule of typeclasses
05:00:54 <quicksilver> is you didn't really want a typeclass at all.
05:00:59 <hpc> (if you add existentials you sort of get polymorphism back, but that's an antipattern)
05:01:38 <cupcake3> Thanks for the replies everyone, I'm definitely thinking about type classes the wrong way.
05:03:03 <ertesx> cupcake3: don't worry, you never *need* type classes…  in fact you will understand when they are useful by *not* using them =)
05:03:48 * hackagebot state-bag 0.1.0.0 - Monad transformers for holding bags of state.  https://hackage.haskell.org/package/state-bag-0.1.0.0 (RobinKay)
05:03:49 <ertesx> in essence type classes are a fancy way to write functions, for which the compiler infers some arguments automatically
05:04:09 <ertesx> here is an example of such a function:
05:04:17 <ertesx> > let f x = x + x in f (5 :: Integer)
05:04:19 <lambdabot>  10
05:04:45 <ertesx> you passt the argument 5, which is an Integer, but the compiler passed a second argument invisibly:  the addition function for Integer
05:06:12 <ertesx> type classes are what gets you the incredibly short, beautiful and seemingly magical code that seems to read your mind…  but there is one thing they are absolutely terrible at: emulating OO =)
05:07:04 <cupcake3> Ah I see, that makes more sense.
05:07:50 <zomg> not written a huge amount of haskell but I did build some web apps, an AI of sorts, parsers / interpreter for a language, and I don't think I ever needed to implement a custom typeclass for any of that
05:09:03 <cupcake3> zomg: oh wow
05:16:15 <cupcake3> Is it possible, for example, to create an array of things which have a "name" (could include people, buildings, countries etc)? I mistakenly assumed that could somehow be achieved by creating a Name type class. Is there a common way of creating such a structure?
05:17:25 <cheater> hi
05:17:28 <bartavelle> cupcake3, you usually need the elements of a vector/array/list to be of the same type anyway
05:17:48 <bartavelle> heterogeneous lists are a lot more complex to handle
05:17:50 <pavonia> cupcake3: You could define a new data type that acts like a wrapper around values of any other type
05:18:28 <bartavelle> cupcake3, so you usually create a sum type that hold all the distinct cases
05:18:34 <bartavelle> (and yes, it is not always optimal)
05:18:43 <cupcake3> pavonia: ah ok, I was considering this.
05:19:59 <bartavelle> cupcake3, also you *might* do something like "data Named a = Named Text a", a bit like the "composition over inheritance" thing you might have seen in the OOP world
05:20:20 <cupcake3> bartavelle: Ok, that's possible, but I thought there would be a more extensible way of accomplishing this. In Java, of course, you would just create a Nameable interface which anyone can implement
05:21:32 <cupcake3> bartavelle: (that was in response to the sum type all cases idea)
05:21:50 <Liskni_si> cupcake3: you could define an existential data type, data Named = forall a. Name a => Named a, then make a list of Named, [Named]
05:22:07 <Liskni_si> but then all you can do is get a name of those things, so you might as well just have a list of those names :-)
05:22:13 <bartavelle> cupcake3, yup, I got it. Note that for this specific example there already is a typeclass based approach that is widely used, it's the "makeClassy" thingie in lens
05:25:12 <cupcake3> Liskni_si: ah, ok.
05:25:46 <ertesx> cupcake3: i think you'll spend a lot of time unlearning OO habits…  yes, you can get heterogenous lists using any of the (basically) hacks mentioned, but ultimately you'll find that even the heterogenous list is an OO-ism
05:26:17 <bartavelle> ertesx, aren't the heterogenous lists the main implementation mean of "OO haskell" ?
05:26:39 <dibblego> http://www.functionaljava.org/javadoc/4.5/functionaljava/fj/data/hlist/HList.html
05:26:45 <ertesx> bartavelle: not sure what you mean
05:27:08 <ertesx> those two seem orthogonal
05:27:09 <bartavelle> ertesx, some paper with a name like "haskell is the best oo language", that implements "java like oo" with hlists
05:27:44 <ertesx> oh, yeah…  <insert OO definition here> =)
05:27:53 <bartavelle> heh
05:28:13 <bartavelle> dibblego, why did they create such a class where you can just List<object> in java ?
05:28:14 <ertesx> i think the essence of OO is captured simply by sums and products
05:28:51 <dibblego> bartavelle: because types are a good idea, which Object forgoes. 
05:29:15 <dibblego> OO does not exist. http://blog.higher-order.com/blog/2008/12/04/no-such-thing/
05:29:32 <maerwald> I find transformers to be quite OO and less declarative
05:29:34 <ertesx> abstract class (OO) → type (haskell);  abstract subclass (OO) → product type (haskell);  concrete class (OO) → value (haskell);  concrete subclass (OO) → value (haskell)
05:30:34 <ertesx> and yes, i don't even mind it that much…  it's just that the way you have to code these things in OO is rather unsatisfactory (if only too verbose, but mostly because it doesn't compose well)
05:33:14 <pavonia> How do you deal with parsing multiple versions of a language? I basically see two ways: Writing an own parser for each language version, possibly sharing sub-parsers; or writing a most general parser that handles all versions in one, and then adding a postprocessing step to check whether the string fits the respective language version. Any other options?
05:34:12 <ertesx> pavonia: if n people answer that question, expect n different answers =)
05:34:52 <merijn> pavonia: One parser per language, sharing sub-parsers is what I did when parsing multiple versions of ZMQ messages
05:34:52 <pavonia> Really? What other ways are there?
05:35:14 <bartavelle> pavonia, you can have the runtime checks at parsing time
05:35:45 <ertesx> pavonia: one example is to translate one version into the other at some level
05:36:11 <ertesx> pavonia: another is to abstract the different parts and have a higher-order parser
05:36:12 <ertesx> etc.
05:36:12 <pavonia> bartavelle: What do you mean?
05:36:50 <bartavelle> pavonia, dataParser = do t <- get; case t of Ver1 -> iso616615; Ver2 -> yyyymmdd;
05:37:13 <bartavelle> that was supposed to be dateParser
05:37:39 <pavonia> Err no, the version isn't marked in the input, you have to choose before you start parsing which version you want
05:37:53 <bartavelle> pavonia, sorry, then "t <- ask" :)
05:38:27 <bartavelle> that was my meaning from the beginning, brainfart
05:38:36 <ertesx> pavonia: surprisingly that makes it easier…  if the version were encoded, you'd likely be stuck with monadic branching
05:38:49 <pavonia> bartavelle: Ah, I see what you mean
05:39:29 <pavonia> A bit like parsing Haskell with/without having extensions enabled
05:39:33 <ertesx> pavonia: a nice example language of that kind is the horrible mess that is GLSL
05:40:03 <pavonia> Yeah, like that
05:41:26 <pavonia> ertesx: Do you know of a Haskell parser for GLSL that supports different versions?
05:41:38 <ertesx> i don't know any parser for GLSL
05:41:39 <merijn> Ah
05:41:45 <merijn> I see pavonia likes pain :)
05:42:34 <pavonia> Just for inspiration, that is :p
05:42:47 <ertesx> pavonia: you don't parse GLSL…  ideally you don't write it either
05:42:49 <ertesx> you generate it
05:43:04 <hodapp> doubly so for JavaScript!
05:43:08 * hexagoxel defines Applicative,Monad for strict Maybe datatype while nobody is looking.
05:43:31 <pavonia> I actually want to parse CSS 3/4 selectors plus some extra version with custom additions
05:44:54 <ertesx> pavonia: not sure if that helps, but we have reasonable EDSLs for CSS
05:45:00 <ertesx> @package clay
05:45:01 <lambdabot> http://hackage.haskell.org/package/clay
05:45:03 <hexagoxel> but seriously, is there a nice (lawful) solution around this? was this e.g. discussed anywhere around -XStrict?
05:46:17 <ertesx> (for some value of reasonable…  CSS is not reasonable)
05:46:25 <pavonia> ertesx: It doesn'T have a parser, AFAICS, but I need some extra stuff anyway
05:46:51 <schlander> I don't understand why execStatement returns [[[(ColumnName, a)]]] https://hackage.haskell.org/package/sqlite-0.5.3/docs/Database-SQLite.html#v:execStatement
05:47:26 <schlander> I mean reading the code it looks like the top list is used to prepare the statement multiple times, but there's no way this will happen: https://hackage.haskell.org/package/sqlite-0.5.3/docs/src/Database-SQLite.html#execParamStatement
05:48:29 <schlander> I mean it looks like there's one level of nesting to deep as this issue mentions: https://github.com/GaloisInc/sqlite/issues/4
05:48:33 <schlander> but nobody answered
05:49:13 <schlander> s/to deep/too deep/
05:53:42 <pavonia> schlander: So the outer list always has just one element?
05:53:50 * hackagebot cmark-highlight 0.2.0.0 - Code highlighting for cmark  https://hackage.haskell.org/package/cmark-highlight-0.2.0.0 (Artyom)
05:57:27 <zlens> I just did 'stack install xmonad' but forgot libxinerama-dev
05:57:33 <zlens> how od I do 'stack uninstall xmonad; stack install xmonad' ?
05:58:50 <schlander> pavonia: yes
05:59:26 <schlander> pavonia: unless the code manage to prepare the same statement twice (but it can only be prepared once according to sqlite3 documentation)
05:59:50 <schlander> pavonia: this happens in the `loop` function.
06:00:09 <schlander> that's when the top level list is constructed
06:02:56 <pavonia> schlander: I'm wondering if there actually are cases where multiple outer lists may be returned, because the code doesn't look like it's adding an unnecessary extra layer 
06:06:36 <telmich> how can I use let within where?
06:06:59 <telmich> I'd like to define a variable n of the original size of a list to be usable by the functions defined in my where block
06:10:12 <pavonia> telmich: Why do you need let if you already are in a where-block?
06:10:15 <maerwald> telmich: you can also nest "where" btw
06:11:21 <lpaste> maerwald revised “No title”: “nested where” at http://lpaste.net/5908360546582790144
06:12:02 <maerwald> it's not that pretty, but not that uncommon either
06:18:28 <telmich> maerwald: uh, that might be a solution!
06:18:51 <telmich> pavonia: I was thinking that let n = ... in ... is more the use case than where
06:19:41 <pavonia> It's more for bindings within expressions
06:22:05 <codedmart> So I am trying to understand the different between covariant and contravariant. What is the best resource and/or is there some easy to parse examples displaying the difference?
06:22:36 <telmich> nice, double where actually does the job
06:22:56 <codedmart> I have used fmap enough, but just not sure I understand contravariant yet.
06:35:50 <liste> codedmart: fmap f x applies f to what comes "out" of x, while contramap f x applies f to what goes "in" to x (in very vague terms)
06:36:14 <liste> > let xs = [1,2,3] in fmap (+1) xs
06:36:16 <lambdabot>  [2,3,4]
06:36:33 <mnoonan> Cale: thanks for the clarification on type families yesterday. After I got a chance to fool around with proxies for a bit, I finally had the a-ha moment
06:36:54 <liste> > let pred = Predicate (> 0) in contramap (+1) pred `getPredicate` 0
06:36:56 <lambdabot>  Not in scope: data constructor ‘Predicate’Not in scope: ‘getPredicate’
06:37:08 <liste> @let import Data.Functor.Contravariant
06:37:10 <lambdabot>  Defined.
06:37:12 <liste> > let pred = Predicate (> 0) in contramap (+1) pred `getPredicate` 0
06:37:14 <lambdabot>  True
06:37:30 <mnoonan> (which for me was [1] understanding why injectivity was important and [2] realizing that proxies give you back injectivity for the same reason that the *graph* of an arbitrary function is always injective
06:38:05 <codedmart> liste: OK thanks for those examples. That is helping.
06:38:12 <mnoonan> But all the proxies mixed into the code got pretty ugly. Can I sleep well if I refactor them all to type applications in GHC 8?
06:40:13 <codedmart> liste: So in the contramap example. contramap does the +1 before `pred` is called. Is that right? Which is why it is True.
06:40:28 <liste> codedmart: yes
06:40:34 <codedmart> OK thanks!
06:43:51 * hackagebot ginger 0.2.6.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.2.6.0 (TobiasDammers)
07:06:17 <ARM9> is there any reason to use array instead of vector? the latter seems to have a much nicer api in general
07:08:30 <liste> ARM9: Vector is only for Int indexes
07:12:07 <ARM9> fair point, but does that give me anything if my indices are <= maxBound :: Int?
07:28:53 * hackagebot 3d-graphics-examples 0.0.0.2 - Examples of 3D graphics programming with OpenGL  https://hackage.haskell.org/package/3d-graphics-examples-0.0.0.2 (WolfgangJeltsch)
07:33:00 <cheater> ARM9: you don't have to hash whatever you're looking up..
07:33:09 <cheater> ARM9: look at the runtime performance...
07:36:20 <ARM9> why would the vector implementation need to hash anything?
07:36:39 <ARM9> I'd love to look at benchmarks if you've got any, I tried googling but I couldn't really find anything comparing the two
07:39:11 <cheater> no but map
07:39:26 <ARM9> what
07:39:39 <ARM9> the list function map?
07:40:39 <ARM9> I don't see what a hash map has to do with my question
07:40:52 <cheater> sorry, i meant Array. Array needs you to hash things, as I understand.
07:41:07 <ARM9> interesting, is that true for all Ix instances?
07:41:14 <nitrix> ARM9: The Vector API allows slices as well as resizing.
07:41:15 <ARM9> do you have a source?
07:41:48 <nitrix> ARM9: You can consider vectors as augmented arrays.
07:41:56 <ARM9> yup those are nice properties, I'm more trying to find pros for the array package
07:42:31 <ARM9> what kind of arrays though, haskell arrays from the Data.Array package? or in the way c++ std::vector is "augmented" c arrays?
07:43:21 <cheater> http://stackoverflow.com/a/7289331 < ARM9 
07:43:21 <nitrix> ARM9: Having those additional features comes to a cost. If you don't want the features, there's no reason to pay that cost. You use what's suitable for your problem.
07:44:00 <cheater> nitrix: i think he's trying to figure out what cost there is.
07:44:18 <cheater> nitrix: saying "engineering is about tradeoffs" is not the precision of answer ARM9 is looking for i think
07:44:58 <cheater> ARM9: having read that link, my general interpretation is Data.Array exists because it's in the Haskell standard, whereas the vector package was made to be better.
07:45:06 <ARM9> thanks nitrix although like cheater said I'm trying to figure out what the tradeoffs of array vs vector are if all I want is contiguous storage of some type
07:45:44 <ARM9> yeah cheater that seems to be my impression as well from browsing around, thanks for helping clear that up
07:46:09 <cheater> it's just an impression. try not to reinforce your impression with it.
07:46:35 <cheater> e.g. maybe since 2011 Array got some fusion rules and it's faster too than it was back then.
07:46:43 <cheater> maybe it was rewritten. who knows.
07:46:59 <ARM9> >who knows
07:47:03 <cheater> generally i'd start with vector unless you really need Array
07:47:06 <nitrix> ARM9: Both have immutable andi mmutable variants. On the top of my head, the main complaint is that arrays are bounded (again, back to the resizing thing).
07:47:10 <ARM9> this is the kind of information I'd like to be readily available somewhere
07:47:46 <cheater> maybe duncan knows, he worked on fusion
07:47:56 <cheater> dcoutts that is
08:12:50 <shirt> how do i use Control.Lens to convert (HashMap k v) into [(k, v)] ?
08:13:32 <c_wraith> shirt, I would just use toList. 
08:13:48 <c_wraith> shirt, I mean, you could do it with an indexed fold, but... why? 
08:14:15 <shirt> c_wraith: thanks. i'm learning lens and curious to see what the best way is
08:16:00 <c_wraith> shirt, ah, that's a good reason. 
08:20:20 <c_wraith> shirt, looks like you should be able to do something like ifoldMap (\i x -> [(i, x)] 
08:21:21 <c_wraith> shirt, check out https://hackage.haskell.org/package/lens-4.14/docs/Control-Lens-Indexed.html
08:21:49 <cheater> ARM9: just yesterday i was talking here that i'd like haskell functions to carry info about runtime complexity :)
08:21:58 <c_wraith> shirt, and ignore the stuff about Conjoined at the top. it's not the really important part of the module. :) 
08:22:19 <glguy> :t itoListOf ifolded
08:22:20 <lambdabot> FoldableWithIndex i f => f a -> [(i, a)]
08:22:32 <glguy> actually:
08:22:35 <glguy> :t itoList
08:22:36 <lambdabot> FoldableWithIndex i f => f a -> [(i, a)]
08:22:41 <glguy> That's how you do it with lens :)
08:25:19 <c_wraith> pfft. the other one is better if you want to do it that way. it actually uses a lens! 
08:26:16 <shirt> thanks
08:28:36 <c_wraith> hmm. asIndex returns an indexed fold? 
08:30:11 <ooop555> hey everyone
08:30:41 <c_wraith> > "hello" ^.. ifolded.asIndex
08:30:53 <Eduard_Munteanu> ooop555, hi
08:32:55 * mniip prods lambdabot
08:33:33 <Eduard_Munteanu> @bot
08:33:46 <Eduard_Munteanu> No bawt? :(
08:33:51 <c_wraith> I think I killed it. 
08:34:01 <c_wraith> :t () 
08:34:22 * mniip prods rajaniemi
08:34:23 <c_wraith> yep. ded. D-E-D ded. 
08:34:38 <Eduard_Munteanu> Ded bawt no good.
08:38:33 <ooop555> qustion ..
08:38:42 <c_wraith> anyway.. asIndex is idempotent. that amuses me. 
08:38:57 <ooop555> question*
08:39:08 <c_wraith> ooop555, feel free to ask. Lots of people here. most of the time, someone is paying attention 
08:41:01 <ooop555> I''m trying actually to connect to this channel using mIRC, and it seems like I couldn't find the freenode server '>_>
08:41:22 <ooop555> now I'm on webchat
08:41:36 <byorgey> ooop555: chat.freenode.net
08:41:40 <ooop555> Noob alert!
08:41:41 <glguy> ooop555: If you're having connection trouble you might ask #freenode for help
08:41:43 <ooop555> :)
08:41:53 <ooop555> oh, alreight 
08:41:56 <byorgey> ooop555: no worries, everyone was a noob at some point =)
08:44:12 <geekosaur> also note we just lost ~ 150 people to a netsplit; the server(s) are a bit unstable atm
08:44:29 <geekosaur> (lambdabot was one of them, which probably explains that)
08:47:56 <c_wraith> Oh, yeah. that's what comes of not showing parts and joins in this client. 
08:48:56 * hackagebot HGE2D 0.1.7.1 - 2D game engine written in Haskell  https://hackage.haskell.org/package/HGE2D-0.1.7.1 (I3ck)
08:50:42 <glguy> c_wraith: http://imgur.com/a/rWzmz
08:50:54 <glguy> You need a client that shows them without flooding!
08:53:56 * hackagebot HGE2D 0.1.7.2 - 2D game engine written in Haskell  https://hackage.haskell.org/package/HGE2D-0.1.7.2 (I3ck)
08:56:03 <ph88> hey guys, does anyone know how i can change my main function so that it handles all the errors, and not just the last one ?  https://paste.fedoraproject.org/393950/92029201/
08:56:13 <ph88> line 91
08:57:24 <cloudhead> is there a way to see what linker flags are passed to ghc with stack build? ie: stuff like OSX frameworks and native libraries?
08:57:46 <cocreature> cloudhead: --verbose should work iirc
08:58:24 <glguy> ph88: Parsec doesn't generally give you all errors, it stops when there's an error. Instead of taking the head of the error position list you could show all of the positions. Additionally, main isn't a function
08:59:22 <ph88> glguy, this is megaparsec with an error recovery feature .. it continues parsing after an error has been found
08:59:34 <petercommand> cocreature: add  "ghc-options: -v" to the cabal file
09:00:10 <ph88> glguy, the positions are all related to a single error .. I don't want to map over the positions, but over the ParseError itself
09:00:10 <petercommand> cocreature: this will tell you what linker flags are used by ghc
09:00:33 <cloudhead> cocreature: thought so too, but I'm not getting in C-level stuff there
09:00:57 <cloudhead> is ghc-options: -v different to stack build --verbose?
09:01:21 <petercommand> ah, I inteaded to ping cloudhead 
09:02:27 <petercommand> I just recognised cloudhead and cocreature as the same nick lol
09:02:39 <cloudhead> ^_^
09:02:50 <cloudhead> petercommand: is there no way without updated the cabal file? It's a third party package
09:02:59 <cocreature> --ghc-options=-v
09:03:13 <cocreature> you can pass that to stack
09:03:15 <cloudhead> ah let me try that
09:03:19 <petercommand> :D
09:03:50 <cocreature> but I think that doesn’t have an effect on packages that are not part of your project so it won’t work for third party packages
09:05:10 <cloudhead> looks like it shows everything!
09:05:22 <petercommand> great!
09:06:49 <cloudhead> ok now I've found the problem
09:07:01 <cloudhead> is it possible to change the order in which the -l flags are passed to the linker?
09:07:06 <cloudhead> :/
09:11:04 <lyxia> ph88: "Note that if r fails, original error message is reported as if without withRecovery. In no way recovering parser r can influence error messages."
09:11:32 <lyxia> ph88: I guess you'll have to modify your parser type to accumulate errors.
09:17:06 <gibbers> hey, what are the tradeoffs of haskell vs scala? I have a free week and I want to get a handle on one of them but I'm not sure which would serve me better
09:17:24 <shapr> scala lets you do everything Java, but isn't as functional as Haskell
09:17:27 <maerwald> gibbers: haskell is cooler, scala might get you more jobs
09:17:29 <ARM9> scala is waaay more complex
09:17:52 <shapr> I'd say scala is more complex because it mixes the imperative java world and the functional world.
09:18:18 <gibbers> the only reason I'm considering scala is you can wedge java libraries into functional code
09:18:21 <Welkin> scala is nothing like haskell
09:18:28 <Welkin> and it is basically java
09:18:50 <Welkin> "functional" doesn't really mean anything at all
09:18:58 <maerwald> "we have functions!"
09:19:03 <gibbers> and I don't ever see myself trying to get a job programming java so I'm not too worried about that :P
09:19:08 <sleblanc`> "it functions"
09:19:19 <ARM9> they do have pretty good metaprogramming
09:21:00 <shapr> gibbers: if you don't want a programming job, Haskell is WAY cooler
09:21:21 <Welkin> if you want a programming job, learn javascript anyway
09:21:34 <maerwald> gibbers: in that case, haskell is more interesting
09:21:55 <maerwald> scala is only a few baby steps less annoying than java
09:22:13 <maerwald> and it's not a big "paradigm break"
09:22:21 <maerwald> if you want to experience that, you probably want haskell
09:23:02 <gibbers> yeah I want to go full functional
09:23:06 <ARM9> if you want something functionalish that interops with a kitchen sink, F# is pretty neat
09:23:58 <magneticduck> whatever happened to Forth?
09:25:03 <shapr> gibbers: full functional is Haskell
09:25:36 <maerwald> ARM9: F# also has automatic currying right?
09:26:13 <ARM9> yes, it's quite functional, but it lacks proper higher kinded types
09:26:23 <maerwald> maybe that's a design decision
09:26:48 <ARM9> probably, they have something they call computation expressions which imitate monads/applicative/functors
09:27:06 <ph88> lyxia, how can i change my parser type to accumulate errors ?
09:32:51 <lyxia> ph88: add StateT on top of Parser
09:34:12 <maerwald> ARM9: I wonder if that feels less crazy than haskell
09:37:25 <ph88> lyxia, should i use runParser' or runParserT' from https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec.html  ??
09:42:49 <Zemyla> ph88: Are you ising Megaparsec as a monad transformer or not?
09:43:32 <ph88> Zemyla, i don't think i'm using it as a monadtransformer at the moment .. but i understood from lyxia that i should keep state, and it seems megaparsec has special run functions that take state
09:43:59 <lyxia> this state is parsec's state
09:44:10 <lyxia> *megaparsec's
09:44:38 <ph88> i can't put my own stuff together with megaparsec's state ?
09:45:35 <lyxia> no it's only state that's used internally by the parser
09:47:05 <ph88> how do i put my own state on top of that parser ?
09:47:17 <mniip> add StateT to the transofrmer stack
09:47:37 <ph88> don't know about transformer stacks
09:47:59 <maerwald> type Parsec e s = ParsecT e s Identity
09:48:05 <maerwald> Identity is the monad, use something else
09:50:03 <ph88> is that a monadic type that embeds another monad ?
09:50:32 <maerwald> yes, it's annoying, but the most wide-spread solution to "stack" effects
09:53:18 <maerwald> so you probably need to run the parser and then run the state
09:53:48 <eklavya> I get cycle errors while building
09:53:56 <eklavya> all modules are inter dependent right now
09:54:00 <eklavya> why is it a problem?
09:54:50 <Welkin> to avoid cyclic imports, pull out the common imports and put them into another module
09:55:05 <eklavya> ok
09:55:16 <eklavya> but they make sense in their respective module
09:55:26 <maerwald> eklavya: https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/separate_compilation.html#how-to-compile-mutually-recursive-modules
09:55:32 <eklavya> besides why is A depending on A a problem?
09:57:19 <eklavya> maerwald: that seems like a lot of work :(
09:57:28 <ARM9> maerwald, I think it's more palpable for beginners, but it may fall short in some aspects, haven't used them enough myself
09:57:39 <eklavya> but people will call me names if I put everything in a single file
09:58:12 <maerwald> ARM9: well, haskell obviously doesn't consider the price of expressivity a lot, so I'm interested in languages that do and how far they get with it
10:01:18 <fragamus> hi i want to ask about ST
10:01:20 <maerwald> eklavya: I don't know. Depends how much actual recursive modules you have. I use that technique in at least two projects, but only once.
10:01:59 <eklavya> I am moving all type/data definitions in a single file, will import that everywhere
10:02:12 <maerwald> it would be odd to need like 4-5 hs-boot files for one project
10:02:21 <maerwald> that's also a solution yeah
10:02:59 <eklavya> maerwald: I think this was a problem because I had everything in one file while experimenting and now I am cleaning and breaking
10:03:04 <lyxia> fragamus: feel free to
10:03:29 <eklavya> If I had started with different modules, maybe I wouldn't have faced this problem
10:04:32 <fragamus> Regarding ST, it looks like one allocates some hunk of mutable state but it has to be passed around explicitly   like   a<-newArray      a is not accessible with anything like State monad's get/put
10:04:38 <fragamus> Is this right
10:04:49 <maerwald> eklavya: depends. Not all of those problems can be solved with moving data types to their own files
10:05:42 <geekosaur> fragamus, ST is not comparable to State
10:05:45 <maerwald> the ultimate solution is always to "merge", but if those mutually recursive modules should be logically separated, then sometimes hs-boot is a useful way
10:05:50 <geekosaur> despite the name
10:05:58 <fragamus> ah thanks
10:06:07 <geekosaur> a "state thread" is data accessible only to a particular computation and not anywhere else
10:06:11 <fragamus> I think i get it then
10:08:28 <fragamus> anybody here familiar with transposition tables like in chess programs
10:08:42 <kttr> hello
10:08:44 <kttr> is anyone here
10:08:57 <lyxia> yes
10:09:01 <lyxia> lots of ppl
10:09:26 <kttr> ok i have a question 
10:09:36 <kttr> so i’m writing an absolute value function
10:09:45 <kttr> absoluteValue x =
10:09:54 <kttr> if x >= 0 then x else negate x
10:10:16 <kttr> the type signature is Num a => a -> a
10:10:17 <maerwald> fragamus: don't ask to ask and avoid asking for people... just ask the question
10:10:42 <kttr> but i keep getting the following error when i try to load it in ghci
10:10:51 <kttr> Could not deduce (Ord a) arising from a use of ‘>=’
10:10:52 <kttr> etc.
10:10:55 <kttr> Any thoughts
10:11:17 <geekosaur> kttr, Num does not imply Ord
10:11:26 <geekosaur> (complex numbers cannot be compared)
10:11:26 <lyxia> kttr: you're doing a comparison with >=, which requires the type of x to be an instance of Ord.
10:11:37 <kttr> I see
10:11:43 <kttr> but wait
10:11:59 <kttr> why is the type signature of the built in abs function: Num => a -> a?
10:12:15 <kttr> doesn’t it do a comparison too?
10:12:22 <c_wraith> doesn't have to. 
10:12:31 <kttr> how else could you compute absolute value
10:12:33 <kttr> ?
10:12:37 <c_wraith> it's also very poorly defined for a lot of Num instances
10:12:56 <maerwald> c_wraith: example?
10:13:04 <c_wraith> Complex 
10:13:17 <thewormkill> kttr: that depends on the type, obviously
10:13:37 <c_wraith> also, any matrix type doesn't have a great abs function 
10:16:59 <Zemyla> c_wraith: What are you talking about? I have a 2x4 matrix of great abs!
10:17:55 <c_wraith> Zemyla, according to popular descriptions, I think you're missing 2
10:18:35 <Zemyla> Those are under my waistband, so it's a hidden variable model.
10:18:55 <c_wraith> I thought Bell's inequalities ruled that out. 
10:19:41 <Zemyla> No, that just ruled out local hidden variables.
10:28:59 * hackagebot vectortiles 1.1.1 - GIS Vector Tiles, as defined by Mapbox.  https://hackage.haskell.org/package/vectortiles-1.1.1 (fosskers)
10:35:18 <cheater> is there a small subset of haskell that's implemented as a haskell library?
10:36:22 <lwer> how can I pattern match an empty vector? I mean, I imported Data.Vector qualified as V, if I use V.empty as a paramter, I get "Qualified name in binding position: V.empty".
10:37:11 <glguy> v | Vector.null v ->
10:39:05 <lwer> yes, thanks, I was thinking something like the [] for lists
10:39:24 <lwer> so there's no other way other than performing the check?
10:39:51 <ARM9> you need to perform the check to match, but you may be able to use a more terse representation
10:40:01 <ARM9> pattern synonyms for example
10:40:47 <geekosaur> vector doesn't expose its constructors, so no, you can't match them explicitly. eventually it should use pattern synonyms to let you write something that looks more natural
10:42:04 <ARM9> maybe overloaded lists works
10:42:06 <cheater> has anyone used this? https://hackage.haskell.org/package/hfusion-0.0.6.1/docs/HFusion-HFusion.html
10:42:14 <ARM9> I haven't tried that extension myself
10:42:34 <geekosaur> only if there is an appropriate instance defined; it's not magic
10:43:30 <eklavya_> I have reexported everything under a common import
10:43:37 <eklavya_> but now I get linker errors :(
10:44:00 * hackagebot safe-exceptions 0.1.4.0 - Safe, consistent, and easy exception handling  https://hackage.haskell.org/package/safe-exceptions-0.1.4.0 (MichaelSnoyman)
10:45:16 <cloudhead> is there any way I can get cabal/ghc to order the linker flags differently?
10:46:03 <geekosaur> eklavya_, did you remember to add the new module to other-modules?
10:46:28 <geekosaur> cloudhead, I don't think so. what exactly is the problem you are seeing?
10:46:50 <eklavya_> geekosaur: I don't see a "other-modules" key anywhere
10:46:59 <cloudhead> geekosaur: I suspect the way it's ordering certain flags is causing runtime problems
10:46:59 <eklavya_> you are talking about the cabal file, right?
10:47:11 <cloudhead> geekosaur: namely -alut and -framework OpenAL
10:47:19 <geekosaur> eklavya_, yes. you may not have had such a field, only exposed-modules
10:47:37 <cheater> does anyone know what paper defines the primitives used in haskell?
10:47:37 <eklavya_> yeah
10:47:44 <geekosaur> but if you now have a module that needs to be part of the library for its internal linkage but should not be exposed to others, you must add an other-modules field listing it
10:47:50 <cloudhead> geekosaur: I found this: http://www.alecjacobson.com/weblog/?p=3708 and was trying to see if this was the problem
10:48:03 <eklavya_> oh ok
10:48:17 <eklavya_> so all the modules I am reexporting should come under other-modules?
10:49:06 <geekosaur> no, just the module that is doing the re-exporting
10:49:08 <geekosaur> https://www.haskell.org/cabal/users-guide/developing-packages.html#build-information
10:49:48 <eklavya_> geekosaur: that worked, I added all reexported modules to other-modules
10:49:55 <eklavya_> geekosaur: thanks a lot :)
10:50:33 <eklavya_> now I just need to figure out the library bundling stuff in haskell
10:50:47 <eklavya_> and my pre-pre alpha cassandra driver will be ready !
10:51:04 <eklavya_> haskell all the way !
11:14:00 * hackagebot canteven-http 0.1.1.1 - Utilities for HTTP programming.  https://hackage.haskell.org/package/canteven-http-0.1.1.1 (taphu)
11:21:04 <mattn> I have a type class C that bundles up a bunch of other type families, kind of like a traits class in C++. Most of the functions that use instances of C need all of the associated types to be instances of Num. Is there some clean way to describe that constraint on the associated types tersely?
11:23:03 <glguy> class Num (TyFam a) => C a where ... 
11:24:26 <dmj`> glguy: that is cool
11:24:53 <glguy> Some extensions may apply, void where prohibited
11:26:28 <mattn> glguy: I think that is pretty much what I want (but repeated for TyFam1 through TyFam10 or so!), except I was intending TyFam to be an associated type family of C. So I think I can’t write it that way?
11:26:55 <glguy> Did you try?
11:28:06 <mattn> yes.. but now I see that FlexibleContexts seems to make it work
11:28:12 <mattn> thanks!
11:29:01 * hackagebot cereal 0.5.3.0 - A binary serialization library  https://hackage.haskell.org/package/cereal-0.5.3.0 (TrevorElliott)
11:41:01 <saurabhnanda> hey, has anyone used quickcheck with yesod/persistent? for testing DB oriented stuff?
11:41:30 <shapr> that would be neat
11:41:42 <shapr> saurabhnanda: what properties would you test?
11:42:28 <saurabhnanda> right now, I'm working with a peculiar problem, where I want to test an invariant, but it also depends on DB state
11:42:35 <saurabhnanda> wait... let me write it down in a reddit post
11:56:23 <saurabhnanda> shapr: https://www.reddit.com/r/haskell/comments/4u4cu6/using_quickcheck_for_testing_functions_involving/
11:57:30 <saurabhnanda> any help with https://www.reddit.com/r/haskell/comments/4u4cu6/using_quickcheck_for_testing_functions_involving/ ?
12:00:22 <Tuplanolla> Using microlens, I can write (blob ^.. thing . each . subthing) to get a list of values, but can I easily get, say, a Seq or a Set instead?
12:00:37 <Tuplanolla> I looked at the source code and it defines (^..) as (\ x -> foldrOf x (:) []) without exposing foldrOf.
12:04:15 <glguy> Prelude Control.Lens Data.IntSet> views folded singleton [1..4] :: IntSet
12:04:15 <glguy> fromList [1,2,3,4]
12:05:40 <tsani> Is it safe to write to a Chan from multiple threads concurrently, or should I wrap the Chan in an MVar?
12:06:08 <Tuplanolla> Thanks, glguy. Let me meditate over this for a few minutes.
12:08:46 <Tuplanolla> It appears microlens doesn't provide views.
12:11:37 <ski> rotty : did you figure out whether you needed the `ipMap' you were talking about the other day ? afaics, the signature glguy suggested (`ipMap :: (forall a. Addr a => (a -> b)) -> IP -> b') should work for your code (assuming `IPv4' and `IPv6' are instances of `Addr'), if you enable the `Rank2Types' extension (or the more general `RankNTypes' if you prefer)
12:14:32 <buglebudabey> anyone know a good package for text classification?
12:19:31 <lpaste> pollz pasted “Cabal” at http://lpaste.net/171093
12:19:39 <pollz> My cabal installation has broken down. I am working on Windows and I cannot install any package. It says the above.
12:20:06 <pollz> I am trying to install Snap.
12:22:54 <tdammers> suppose I have a grammar in EBNF (antlr style); is there a library that I can use to painlessly derive a Parsec parser from that?
12:23:03 <ReinH> pollz: what versions of cabal and ghc?
12:23:18 <pollz> Uhm how do I find out?
12:23:32 <ReinH> ``ghc --version'' and ``cabal --version''
12:24:07 <pollz> GHC 8.0.1 Cabal 1.24.00
12:26:52 <ReinH> It's not clear why cabal would have rejected base-4.9.0.0. What's in your cabal file?
12:27:04 <pollz> config file you mean?
12:27:21 <ReinH> Is there a cabal file for a project? Did you type ``cabal install snap''?
12:27:25 <geekosaur> sounds like base got unregistered; that would be Bad
12:27:47 <ReinH> geekosaur: welp, time to reinstall ghc
12:27:53 <pollz> Damn
12:27:56 <pollz> Reinstall?
12:28:12 <geekosaur> did you try to solve a conflict with base by removing the installed one?
12:28:12 <pollz> Is there anyway to register it back?
12:28:27 <pollz> I think so. I'm not sure. But base is also not installed seems like.
12:28:36 <pollz> I just tried cabal install base and it flipped.
12:28:46 <geekosaur> and I think you no longer have the registration data file that would be needed
12:29:02 <pollz> So, reinstall the whole thing?
12:29:14 <geekosaur> and yes, (a) nothing will work (b) the only way to install a particular version of base is to install the ghc that comes with that version of base; it is not user installab;le
12:29:28 <pollz> How is it deregisterable so easily then?
12:29:34 <pollz> Isn't this paradoxical?
12:29:57 <ReinH> No, but it's certainly letting you shoot yourself in the foot
12:30:13 <pollz> LOL. Isn't that bad?
12:30:22 <ReinH> Well, most people don't try to uninstall the base package
12:30:29 <pollz> Like shouldn't there be a warning.
12:30:32 <ReinH> And I suppose those that do only do so once
12:30:58 <pollz> No shit. So, will running the haskell-platform installer once again fix it?
12:31:36 <Welkin> pollz: you don't need the platform
12:31:45 <Welkin> if you just want to get set up quickly, use stack
12:31:46 <rotty> ski: thanks, I will try that.
12:31:49 <ReinH> But if that's the GHC installer you haved, you can use it.
12:31:51 <geekosaur> and yes probably ghc-pkg should refuse to unregister base
12:32:06 <pollz> geekosaur: It nicely deregistered.
12:34:28 <ski> rotty : the argument type `forall a. Addr a => (a -> b)' here means that in `ipMap f (IPv4 a) = f a' and `ipMap f (IPv6 a) = f a', `f' (the argument/callback) itself will be polymorphic, which is (afaics) what you intend here
12:35:25 <Tuplanolla> Well, I still don't see how this lens thing should work.
12:35:51 <ski> rotty : your current signature `ipMap :: Addr a => (a -> b) -> IP -> b' (which is short for `ipMap :: forall a b. Addr a => (a -> b) -> IP -> b') means that `ipMap' is polymorphic in both `a' and `b'. that means that the caller (of `ipMap') gets to pick/choose which actual types to use in place of `a' and `b'
12:37:22 <ski> rotty : but in your case, you want `ipMap' itself (the "callee"), who is the *caller* of the callback `f', to pick the type for `a' (namely to pick it as either the type `IPv4' or the type `IPv6', depending on the shape / data constructor of the `IP' argument)
12:38:22 <ski> rotty : so, if the callback itself is polymorphic in `a', that means that its caller, `ipMap', gets to pick `a'. it also means that whoever calls `ipMap' must make sure to provide a polymorphic callback argument, that will work for any `a' that's an instance of `Addr' (and so will work for both `IPv4' and `IPv6')
12:38:48 <rotty> yep, that's what i had in mind
12:39:27 <ski> rotty : with your original signature, with `ipMap' being polymorphic in `a', that would allow a caller of `ipMap' to pass a *monomorphic* callback, that e.g. only works for `IPv4'. and so `ipMap' would be in trouble if the `IP' passed had shape `IPv6'
12:40:45 <ski> rotty : in any case, in either version (either the original, nonworking one, or the suggested, hopefully working one), `ipMap' would still be polymorphic in `b'. i.e. the caller of `ipMap' would pick the "common return type", which the passed callback must then also have as return type
12:41:10 <rotty> that makes sense, yes, if put that way :-)
12:41:21 <ski> rotty : does this explanation attempt help explain the issue, and why you need the somewhat more awkward type, to get the desired behaviour ?
12:42:33 <rotty> yes, it helped, but I guess I'd have to gain a bit more experience to be fully confident
12:42:44 <rotty> thanks a bunch
12:43:00 <ski> rotty : higher-rank types don't come up that often in practice, but when they do, there's often no substitute for it (apart from packing polymorphic operations inside a new data type, using `PolymorphicComponents', which achieves the same thing, in a somewhat more clumsy way (but easier on the type checker))
12:43:45 <ski> rotty : anyway, i want to emphasize that it's the `forall' in the type that signifies that the value (most commonly a function) is polymorphic
12:44:34 <ski> rotty : a "nested forall", normally nested inside an argument type, means that this polymorphism pertains not to the function itself, but to the argument. and you nest deeper, if you really need to, using `RankNTypes'
12:45:13 <ski> (`Rank2Types' only gives you polymorphic arguments/callbacks. `RankNTypes' also gives you callbacks which themselves expect polymorphic arguments, &c.)
12:45:17 * ski is done
12:51:08 <c_wraith> RankNTypes is also why few people care that -XImpredicativeTypes is broken. you can always emulate them with a Rank N type inside an appropriate newtype
12:53:03 <Welkin> what do you mean by a callback?
12:53:12 <Welkin> it's just passing functions around
12:53:27 <c_wraith> functions are callbacks. 
12:54:01 <c_wraith> it's just how it's used. do you pass a function to something that will call it? then that argument is used as a callback. 
12:54:41 <shachaf> I care that ImpredicativeTypes is broken.
12:55:16 <shachaf> I don't think that statement makes sense. Without RankNTypes, ImpredicativeTypes is meaningless.
12:55:27 <c_wraith> I didn't say "no one". 
12:55:37 <c_wraith> I'd like it to work, too. 
12:57:30 <c_wraith> well, it's kind of a hierarchy - prenex, rank 2 functions, rank N functions, impredicative polymorphism.. each one allows you to specify more things are polymorphic 
12:58:32 <c_wraith> but the current state is rank n works well, impredicative barely works at all. 
12:58:59 <EvanR> prenex?
12:59:20 <Welkin> kleenex for pregnant mothers
12:59:30 <EvanR> i see
12:59:42 <c_wraith> all type variables must be quantified in the same scope. 
13:00:22 <EvanR> whats an example of that 
13:01:24 <ski> (well, with type classes, not all type variables are necessarily quantified in the same scope)
13:01:24 <mniip> you mean like
13:01:31 <mniip> (forall a. a -> X) -> Y
13:01:41 <ski> should e.g. `((forall a. Foo a) -> Bar) -> Baz' be implicitly convertable to `(Foo T -> Bar) -> Baz' ?
13:02:22 <ski> (since `(... -> Bar) -> Baz' is a positive (though not strictly positive) context)
13:02:54 <ski> similarly, with `ImpredicativeTypes', should `[forall a. Foo a]' be implicitly convertable to `[Foo T]' ?
13:03:26 <mniip> implicitly convertable?
13:04:08 <ski> like how `length :: forall a. [a] -> Int' can be used as having type `[String] -> Int', with no extra annotation needed to perform the conversion between the types
13:04:19 <mniip> you mean 'unifies with'
13:04:25 <ski> no
13:04:35 <ski> this is directed
13:05:03 <ski> clearly given something of type `[String] -> Int', you shouldn't be able to treat it as having type `forall a. [a] -> Int'
13:05:11 <ski> but the other way around works fine
13:05:24 <EvanR> exists t . [t] -> Int
13:05:29 <mniip> "can be instantiated into"
13:06:12 <ski> (a related question would be : should `Foo T -> Bar' be implicitly convertable to `(forall a. Foo a) -> Bar' .. this is perhaps related to what EvanR is thinking about)
13:06:55 <ski> (btw, `length :: forall a. ([a] -> Int)' is equivalent to `length :: (exists t. [t]) -> Int' (not to `length :: exists t. [t] -> Int'))
13:07:25 <EvanR> whats the difference?
13:07:39 <ski> mniip : yes, except in System F, that kind of instantiation can only be done when the `forall' is on the toplevel of the type
13:08:33 <ski> EvanR : `(exists t. [t]) -> Int' is the type of functions such that, if there exists some type `t' such that the argument has type `[t]', then the result will have type `Int'
13:08:45 <mniip> EvanR, forall - user picks. exists - implementation picks
13:08:51 <EvanR> no
13:09:05 <dolio> Same as the difference between `forall a. a -> Int` and `(forall a. a) -> Int`.
13:09:11 <ski> (this is equivalent to `forall t. ([t] -> Int)', which is the type of functions which, for any/every type `t', can convert an argument of type `[t]' into a result of type `Int')
13:10:05 <ski> otoh, `exists t. ([t] -> Int)' would be the type of a function that will convert arguments of type `[t]' into results of type `Int', for *some* type `t' (but you don't know what that type is, so the only (total) argument you can pass is the empty list)
13:10:22 <ski> EvanR, ok ?
13:11:37 <EvanR> they started hammering on my ceiling so im having trouble sifting through all this
13:12:25 <mniip> a simple enough way to reason about it is that when you're *using* a function, its *implementation* *uses* the arguments to provide an *implementation* of the result
13:12:35 <mniip> so the roles get reversed to the left of -> but not to the right
13:12:47 <EvanR> mniip i get RankN, which is not what i was asking about
13:12:51 <mniip> oh?
13:12:58 <mniip> what was your question then
13:13:04 <ski> (another somewhat related question would be : should `forall f g. (forall a. Either (f a) (g a)) -> Either (forall a. f a) (forall a. g a)' be possible (wrap the alternative results with `PolymorphicComponents' if you don't like `ImpredicativeTypes') ?)
13:13:13 * EvanR continues reading ski and dolios answers above
13:15:20 <mniip> ski, I don't see why not
13:15:36 <EvanR> so you cant convert String -> Int into exists t . [t] -> Int because in code that before used it on a string, that code is no longer right?
13:15:44 <EvanR> it seems like it would still work
13:15:54 <EvanR> though the type checker may not be able to tell
13:16:04 <ski> clearly you can convert `String -> Int' into `exists t. ([t] -> Int)'
13:16:13 <ski> (though that latter is probably not very useful)
13:16:43 <EvanR> either one seems like a valid generalization
13:17:31 <ski> well, this one is not a generalization, but an abstraction (we're hiding which type `t' we used when defining/constructing the value of type `exists t. ([t] -> Int)')
13:18:02 <ski> (i know that sometimes logicians calls this "existential generalization", but i'm not a fan of the term)
13:19:05 * hackagebot data-serializer 0.1 - Common API for serialization libraries  https://hackage.haskell.org/package/data-serializer-0.1 (MikhailVorozhtsov)
13:26:24 <dolio> ski: The thing about those sorts of rules is that they're not just hard to check, they're hard to give the term-level meaning when things like type classes appear.
13:27:09 <dolio> Unless you step into a fancier system.
13:29:05 * hackagebot data-serializer 0.2 - Common API for serialization libraries  https://hackage.haskell.org/package/data-serializer-0.2 (MikhailVorozhtsov)
13:33:26 <ski> dolio : yes, with something like type classes that's (in general) not erasable, it would be more questionable
13:34:13 <ski> the questions were meant for plain `forall' (and `exists')
13:35:57 <lpaste> pollz pasted “Parsec Install Issue” at http://lpaste.net/171104
13:36:13 <pollz> I reinstalled the platform and cabal. 
13:36:19 <pollz> This is the issue I am up with.
13:36:32 <pollz> I did ghc-pkg check and it gave me walls and walls of output.
13:38:19 <pollz> And I can't install snap also.
13:38:55 <ltcmelo> when I have ` x :: a -> a
13:38:56 <lpaste> pollz pasted “Snap Install Issue” at http://lpaste.net/171105
13:40:39 <ltcmelo> sorry… for `x :: a -> a ` I get the type of x polimorphically instantiated. Is there such a thing as `y :: a ` ?
13:41:04 <ltcmelo> assume the binding `x val = val ` for the first case
13:41:10 <mniip> y = y
13:41:45 * ski is not sure what ltcmelo is really after
13:42:17 <ltcmelo> ski: I’m going through the Haskell report, writting a parser for own project ;-)
13:42:44 <ltcmelo> ski: I’m not a haskell expert though, so I’m taking the opportunity to improve my language knowledge as well
13:43:06 <ltcmelo> but what would be the use of such ` y :: a ` (if any) ?
13:43:10 <mniip> writing a haskell-like parser? good luck
13:43:28 <maerwald> what does that even mean?
13:43:40 <mniip> ltcmelo, not much, but it sure can occur
13:43:49 <maerwald> parsing haskell code?
13:43:58 <mniip> other bottoms can also have type forall a.a
13:44:01 <mniip> e.g
13:44:02 <ltcmelo> mniip: yep, I know :D I want to integrate it with my other parsers  -> https://github.com/ltcmelo/uaiso
13:44:02 <mniip> :t undefined
13:44:04 <lambdabot> t
13:44:09 <mniip> :t error "foo"
13:44:11 <lambdabot> t
13:44:25 <mniip> now those have some usecases
13:44:31 <ski> ltcmelo : `y :: a' (which is short for `y :: forall a. a', unless the type variable `a' is already in scope), is not very useful
13:44:54 <ski> what mniip said is about it
13:45:20 <pollz> Anyone having any solution?
13:45:22 <ltcmelo> ski: I understand the meaning, but I was looking for any sense behind it…
13:45:32 <hexagoxel> ltcmelo: it is not about "has type x" but about "unifies with type x". and the types of (), True, "abc" all unify with `a`.
13:46:00 <mniip> @src tail
13:46:00 <lambdabot> tail (_:xs) = xs
13:46:01 <lambdabot> tail []     = error "Prelude.tail: empty list"
13:46:08 <ltcmelo> hexagoxel: but when would you have such a declaration?
13:46:09 <mniip> ltcmelo, in the above, error "..." :: a
13:46:09 <hexagoxel> ltcmelo: because to apply a function, types need to unify, not more, not less.
13:46:13 * ski isn't sure whether ltcmelo saw `y :: a' somewhere, or invented that snippet themselves
13:46:32 <hexagoxel> ltcmelo: because it communicates that the "user" of the function gets to choose the `a`, so to speak.
13:46:46 <mniip> ltcmelo, you can use error/undefined at any type, thanks to that
13:47:05 <ltcmelo> yes, but error is `error:: [Char] -> a `
13:47:08 <ltcmelo> which is fine
13:47:13 <mniip> :t undefined
13:47:15 <lambdabot> t
13:47:19 <mightybyte> pollz: What OS and GHC version are you using?
13:47:19 <ski> yes, but `error "foo"' has type `a', for any type `a'
13:47:22 <hexagoxel> (i don't think that mentioning any version of bottom as an "instance of that type" is actually helpful)
13:47:36 <ltcmelo> what I mean is declaration in which the type is essentially unifying on the type variable
13:47:43 <pollz> Windows. 8.0.1
13:47:51 <ltcmelo> I really mean exactly this declaration -> `x :: a`
13:47:52 <pollz> 8.0.1 being the GHC version. mightybyte 
13:47:58 <mightybyte> pollz: Snap doesn't support GHC 8 quite yet.
13:48:01 <ski> ltcmelo : can you invent a more complicted example of what you're wondering about ?
13:48:17 <pollz> mightybyte: parsec error?
13:48:18 <ltcmelo> ski: ok, let me try
13:48:30 * ski thought ltcmelo mentioned `x :: a -> a' and `y :: a', not `x :: a'
13:48:39 <mniip> ltcmelo, https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Err.html#undefined
13:48:48 <mightybyte> pollz: If you're willing to use the latest snap from github, that should work with GHC 8.
13:49:14 <hexagoxel> pollz: you probably have left-over registrations of your previous install in your user package database. i.e. template-haskell-2.11.0.0
13:49:34 <pollz> hexagoxel: is there any way in which cabal can fix these and install or should I move on to stack?
13:50:01 <pollz> hexagoxel: also what about the parsec errors? I have just reinstalled the platform and I did not get cabal with it surprisingly.
13:50:03 <hexagoxel> pollz: these cause the `ghc check` problems and explain why install still does not work.
13:50:06 <Welkin> pollz: stack is easier
13:50:06 <ltcmelo> mniip: oh… I see, cool
13:50:22 <maerwald> Welkin: that's subjective
13:50:26 <Welkin> the stack config files are nice too
13:50:31 <ltcmelo> mniip: this is a kind of use I was looking for, thanks
13:50:33 <Welkin> maerwald: sure it is
13:50:34 <maerwald> and I beg to differ
13:50:36 <pollz> Welkin: Installing as we discuss.
13:50:36 <hexagoxel> stack is not easier.
13:50:38 <Welkin> but it's my experience
13:51:10 <pollz> Cabal has given me much heartbreak after I deregistered base the last time. Like a douche.
13:51:13 <Welkin> I use multiple versions of ghc with stack too
13:51:35 <pollz> Since then I haven't got one package installed.
13:51:35 <Welkin> shared package caches are the killer feature
13:51:43 <Welkin> no more waiting 30 minites for yesod to install in a new sandbox
13:51:45 <ltcmelo> ski: mniip ’s link showed me an example
13:51:51 <Welkin> minutes*
13:51:58 <ltcmelo> ski: the case of undefined
13:52:03 <ski> ltcmelo : confusion cleared up, then ?
13:52:11 <ltcmelo> ski: yep, thanks
13:52:12 <hexagoxel> pollz: as you started over anyways, you probably should delete your user package database. under unixes that would be under ~/.ghc
13:52:13 <ski> ok
13:52:35 <hexagoxel> pollz: unfortunately i don't know the location in win
13:52:42 <ski> @src Bounded
13:52:42 <lambdabot> class Bounded a where
13:52:42 <lambdabot>     minBound, maxBound :: a
13:52:52 <mightybyte> pollz: Yeah, the base package comes wiht GHC.  So unregistering it is a bad idea.
13:53:07 <ski> ltcmelo : that's an example where `a' is already in scope, so that does *not* mean `minBound,maxBound :: forall a. a'
13:53:27 <Welkin> it's super easy to nuke everything and reinstall ghc + whatever packages you need
13:53:53 <Welkin> whether using cabal or stack
13:54:23 <tempay> Hi
13:54:38 <ltcmelo> ski: not sure I understand what you mean
13:54:58 <ltcmelo> ski: why is `a` is scope there?
13:56:00 <ski> `Bounded a' brings it in scope
13:56:27 <ltcmelo> ski: but what binds `a` is the type declaration `undefined :: a `, right?
13:56:35 <ski> the effective type for `minBound' and `maxBound' thus becomes `forall a. Bounded a => a'
13:57:08 <ski> where the `forall a. Bounded a =>' part comes from the fact that the signatures above occurs inside a class declaration (for `Bounded a')
13:57:09 <ltcmelo> type signature
13:57:35 <adarqui> hey, is there a "hoistEitherT"? i have some helper functions to do it but, wondering if there's a more official way to do it. I basically have functions of the form: m (Either e a) .. but hoistEither takes an (Either e a)
13:57:54 <ski> ltcmelo : in the case `undefined :: a', that is an abbreviation for the full `undefined :: forall a. a'. it is the `forall a.' part which binds the `a' there (brings it into scope)
13:58:28 <ltcmelo> ski: ok, that’s what I mean
13:58:32 <ski> ltcmelo : similarly, `length :: [a] -> Int' is an abbreviation of `length :: forall a. [a] -> Int'
13:59:17 <ltcmelo> ski: I though you meant that `a` is already in scope _before_ the declaration, so my confusion
14:00:07 <ski> the abbreviation exists in the language because (a) it's quite common to write type signatures for polymorphic operations, and they get perhaps a little bit more easy looking without the explicit `forall' (mayhaps especially so for beginners); and (b) originally the explicit `forall' form didn't exist, only the abbreviated form existed
14:00:50 <ltcmelo> ski: alright, thanks
14:01:16 <ski> ltcmelo : i'm just saying that in e.g. `length :: [a] -> Int', the `a' isn't brought into scope by its mention inside `[...]'. in this case `a' is *already* in scope (brought into scope by the implicit `forall a.')
14:02:07 <ltcmelo> ski: I get what you mean… `length :: <<a enters scope here>> [a] -> Int`
14:02:17 <ski> ltcmelo : while in `minBound :: a' inside that `class' declaration for `Bounded a', `a' is in fact already in scope even before the type signature (unlike the `length' case, where it's brought into scope *inside* the type signature, by the implicit `forall')
14:02:21 * ski nods
14:03:37 <ski> ltcmelo : so, for rule for the abbreviation is that in a type signature `foo :: ..a..', an implicit `forall a.' is inserted, *directly* after the `::' (nowhere else, which would often mean something different), *unless* the variable `a' is already in scope before the type signature (such as in the `class' case)
14:04:16 <pollz> hexagoxel: should i delete the packages even if I am installing stack?
14:04:19 <ltcmelo> ski: makes sense, thanks for the detailed explanation ;-)
14:04:40 <ski> e.g. in `foo :: ([a] -> [a]) -> Bool', this means `foo :: forall a. ([a] -> [a]) -> Bool'. `foo :: (forall a. [a] -> [a]) -> Bool' would be something completely different, and is not what the abbreviated first signature expands into
14:05:02 <buglebudabey> :t readFile
14:05:03 <lambdabot> FilePath -> IO String
14:05:48 <hexagoxel> pollz: afaik stack does things completely separately when it comes to package databases.
14:06:03 <ski> (for the first two `foo's here, `foo' itself is polymorphic. the caller will pick an `a'. in the last `foo', `foo' is not polymorphic, but expects (requires) a polymorphic *argument*. `foo' itself will pick `a' there (possibly many times, with different types picked))
14:06:10 <pollz> hexagoxel: I will update once the install is done.
14:06:29 <pollz> hexagoxel: But why is cabal so bad?
14:07:04 <ski> ltcmelo : my main point here is that the exact placement of a `forall' in a type can matter a lot. however, "normal" uses are to only have it directly after the `::' in a type signature
14:07:04 <mightybyte> pollz: Are you talking about the Snap error or something else?
14:07:04 <pollz> hexagoxel: I am asking regarding the so called cabal hell.
14:07:45 <pollz> mightybyte: General dependency pains.
14:08:14 <mightybyte> pollz: Well, the dependency pain with Snap has nothing to do with Cabal.  Snap simply doesn't support your GHC version yet.
14:08:38 <pollz> mightybyte: Isn't this GHC the latest one distributed? Why isn't snap supported?
14:08:53 <pollz> mightybyte: or am I asking at the wrong place
14:08:57 <ltcmelo> ski: sure...
14:09:58 <mightybyte> pollz: GHC 8 came out only a couple months ago.  It has significant changes.  It will take the community awhile to get everything upgraded to support it.
14:10:40 <mightybyte> pollz: You'll have better luck installing more packages if you stick to GHC 7.10 for now.
14:10:47 <pollz> mightybyte: Aye.
14:11:16 <hexagoxel> mightybyte is correct, thanks for pointing that out.
14:12:00 <pollz> mightybyte: hexagoxel While I'm installing things anyway, care to share favorite editor?
14:12:05 <hexagoxel> i was misinterpreting the last paste.
14:12:07 <lispy> And if you are using GHC 8 and having issues, make sure you file bug reports
14:12:11 <mightybyte> I use spacemacs
14:12:37 <hexagoxel> sublime text
14:12:46 <mightybyte> I'm a longtime vim user and spacemacs gives me everything I used from vim plus a lot of nice things from emacs.
14:13:10 <Welkin> I haven't upgraded to ghc 8 yet
14:13:22 <pollz> hexagoxel: Haven't upgraded to Atom yet? :P
14:13:33 <Welkin> pollz: upgraded? you mean downgraded?
14:13:40 <pollz> Welkin: Hahahaha
14:13:46 <pollz> True.
14:13:57 <ARM9> long time vim user but I actually settled on atom for haskell after trying a bunch of vim/emacs plugins
14:14:00 <Welkin> oh
14:14:04 <Welkin> hexagoxel: uses sublime
14:14:12 <Welkin> I thought you were talking about emacs or spacemacs
14:14:26 <pollz> hexagoxel: Isn't Sublime propreitary?
14:14:29 <Welkin> yeah
14:14:32 <Welkin> so I don't use it
14:14:41 <pollz> Welkin: You use?
14:14:46 <Welkin> emacs
14:14:57 <ARM9> do you use haskell-mode?
14:15:01 <Welkin> of course
14:15:19 <Welkin> I don't use any fancy plugins though, not even ghc-mod or flycheck
14:15:29 <ARM9> was a pain to use with stack when I tried
14:16:08 <pollz> Nobody uses Notepad++ I think :/
14:16:27 <Welkin> I used to many years ago when I was in school, haha
14:16:48 <pollz> I love it's save tabs feature.
14:27:41 <vozz> I have a parsing problem. If I have text like "klajsd asdklf adf {asdfasd} dffadf {d} adfa{s}" and want to parse it as a list of TextBlocks and BracketBlocks (each containing the text inside them), what library would make that easy, and which functions should I be looking at?
14:27:56 <Welkin> vozz: parsec
14:27:59 <pollz> vozz: Parsec?
14:28:49 <vozz> If I use parsec, and I make a parser for the TextBlock, won't that be take all input so it would greedily take it and the bracket block would never match?
14:29:30 <Welkin> no
14:29:37 <Welkin> just read the parsec tutorial
14:29:54 <vozz> okay, thanks
14:30:08 <vozz> parsec over attoparsec?
14:30:15 <Welkin> yes
14:30:19 <vozz> okay, thanks
14:30:22 <Welkin> attoparsec is an optimizatin
14:30:28 <Welkin> optimization*
14:30:40 <Welkin> because it does no error checking
14:30:59 <Welkin> well, its errors are not useful
14:31:11 <ARM9> parsec can also work with bytestrings if you don't need more than ascii I suppose
14:31:36 <ARM9> http://hackage.haskell.org/package/parsec-3.0.0/docs/Text-Parsec-ByteString.html
14:31:49 <thewormkill> however, attoparsec is backtracking by default
14:32:05 <thewormkill> there were some libraries that wrap both to ease development
14:32:17 <Welkin> megaparsec or something?
14:32:53 <Welkin> oh, no
14:32:56 <Welkin> that looks like a fork
14:33:04 <thewormkill> can't remember the names, sorry
14:34:34 <geekosaur> megaparsec is parsec with bug fixes
14:34:53 <geekosaur> iirc parsers wraps parsec/attoparsec/trifecta?
14:35:03 <geekosaur> (and possibly megaparsec at this point)
14:35:24 <ARM9> how come they didn't contribute those fixes to parsec instead?
14:35:25 <Welkin> geekosaur: bug fixes?
14:35:31 <ARM9> since it's like the defacto parser generator
14:35:31 <Welkin> why not just add them to parsec?
14:35:37 <ARM9> parser combinator*
14:35:41 <ARM9> got happy on my mind
14:36:04 <geekosaur> I feel like I explained thi at one point already... the release announcement claims they forked after submitting the fixes to parsec and getting no response for months
14:36:21 <geekosaur> the prsec maintainers spoke up afterward and said "what?"
14:36:26 <Welkin> lol
14:36:31 <geekosaur> (i.e. they saw no fixes)
14:37:01 <geekosaur> I have no idea what has happened since
14:37:33 <flicflac> 91.217.189.42 @isalo
14:37:33 <hpc> https://github.com/aslatter/parsec/issues/43 - this is a bug from last year by the guy who hosts the megaparsec package's homepage
14:37:39 <Welkin> too much fragmentation
14:37:50 <hpc> almost exactly a year ago, no response
14:38:10 <hpc> and a very simple one at that
14:39:25 <pollz> anyone know how to fix broken packages shown by ghc-pkg check?
14:39:34 <pollz> or is it the end of the road for me yet again?
14:39:58 <sm> sometimes it makes sense for a productive developer to work in their own space
14:40:57 <Welkin> that's true
14:41:00 <sm> I think megaparsec was a good move. Probably it wouldn't be impossible to make it parsec now, if both devs wanted
14:41:06 <pollz> It says there are files missing when I try to install parsec
14:41:09 <Welkin> it's just unfortunate that popular packages like that go unmaintained
14:41:23 <Welkin> the maintenance should be opened up to more than just one person
14:41:59 <Welkin> no idea pollz 
14:42:08 <Welkin> I don't use windows
14:42:21 <Welkin> but if you are using stack, it should work
14:42:44 <Welkin> oh, or maybe you are missing system files
14:42:53 <glguy> pollz: If you broke a package using --force flags, you can use ghc-pkg unregister to unregister the stuff you broke
14:42:54 <Welkin> you would need to install those yourself
14:43:17 <pollz> glguy: I am never typing unregister ever in my life after what happened an hour ago
14:43:36 <pollz> and the packages are broken as it is when i freshly installed haskell
14:47:01 <sm> pollz: ghc-pkg-clean is handy, https://gist.github.com/simonmichael/1185421
14:47:57 <sm> uninstalls all the broken ones if you run it a few times. Or you can reinstall the broken ones explicitly yourself
14:48:33 <dmwit> pollz: Perhaps you should paste the output of ghc-pkg check.
14:48:46 <dmwit> pollz: "broken on a fresh install" is an especially surprising claim.
14:54:07 * hackagebot gnss-converters 0.1.12 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.12 (markfine)
14:54:40 <pollz> dmwit: I do not know why but my stupid windows shell stdout is not writing to any file
14:54:49 <pollz> dmwit: so I am posting the last few lines
14:54:59 <lpaste> pollz pasted “ghc-pkg check” at http://lpaste.net/171110
14:55:42 <pollz> dmwit: Any idea what is happening?
14:58:09 <dmwit> Perhaps permission problems. Is there a reason you are installing everything globally? If not, it is generally considered best practice to leave the global database alone and install everything in your user database.
14:58:20 <dmwit> Not least because it's easy to nuke the user database and hard to nuke the global one. =P
14:59:02 <pollz> dmwit: Is there anyway I can start with a clean Cabal once again?
14:59:09 <pollz> which all files do I have to remove?
14:59:12 <hpc> similarly, it's even easier to nuke a sandbox
14:59:16 <pollz> I am on windows and I hate my life.
14:59:30 <hpc> on windows you can uninstall and reinstall ghc
14:59:42 <sm> ah now. Could be worse
15:00:05 <hpc> and in between, remove... the directory under program files, if it doesn't get fully removed
15:00:18 <hpc> plus the cabal and ghc folders in %appdata%
15:00:48 <hpc> you might also like to try stack instead of the platform or using ghc directly
15:01:15 <hpc> it makes some stuff significantly easier to deal with, especially with foreign dependencies
15:01:21 <hpc> i couldn't have gotten sdl2 working without it
15:01:38 <hpc> (it also makes some stuff harder, but it's worth trying out regardless)
15:02:00 <pollz> hpc: Thanks.
15:02:25 <pollz> When cabal says "Warning: Packages Likely To Be Broken" does it always mean they will be broken?
15:02:31 <maerwald> hpc: why is that?
15:02:45 <hpc> why does stack make foreign stuff easier on windows?
15:03:02 <maerwald> why you didn't get sdl2 working without it
15:03:41 <dmwit> pollz: No. monochrom's SICP is a good resource for understanding the subtleties.
15:03:43 <dmwit> ?where SICP
15:03:44 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
15:03:50 <hpc> because i just have weird stupid windows problems
15:03:53 <dmwit> pollz: The last one there.
15:04:00 <maerwald> oh, you are on windows? that explains a lot
15:04:03 <pollz> dmwit: On it. Danke.
15:04:05 <hpc> i could never figure out enough of how the platform fits together to even know what i was doing wrong
15:04:11 <glguy> pollz: It means unless everything is exactly the same as the first tim eyou installed it those packages will be broken
15:04:26 <glguy> pollz: You should be unregistering things if they depend on something you want to replace
15:04:52 <pollz> Or just force reinstall all the nonsense and wade through piles of broken shit.
15:05:03 <glguy> no, you should never be forcing things
15:05:19 <pollz> glguy: But but I just did that and got parsec running
15:05:21 <dmwit> pollz: Yeah, don't force-reinstall. If you did that, you deserve what you get.
15:05:30 <hpc> there was a reddit post with idiotproof instructions to install sdl2 on windows with stack, but can't find them now
15:05:35 <pollz> dmwit: Wow. Okay.
15:05:54 <hpc> the key point was that you can run "stack install x86_64-sdl2-something-something" and it just does all the things
15:05:59 <glguy> pollz: forcing things is likely to make exactly the operation you just performed work and break lots of other stuff in the process
15:06:23 <hpc> with platform you're running pkg-config, that weird mingw package gui thing, etc
15:06:24 <dmwit> pollz: Hey man, if you like wading through piles of broken shit, don't let me stand in your way. I'm just operating on the assumption you don't like that. =P
15:06:34 <hpc> all of which may or may not sometimes maybe not work probably
15:06:40 <pollz> dmwit: Hehehe. I get what you mean.
15:06:42 <hpc> and that's if you have pkg-config on your path at all
15:07:06 <Welkin> hpc: what about sdl2? The ffi part?
15:07:09 <shirt> what's better? "const" or "\_ ->" ?
15:07:12 <hpc> yeah
15:07:32 <Welkin> shirt: eplicit is better
15:07:33 <Welkin> usually
15:07:36 <Welkin> explicit*
15:07:38 <hpc> my favorite bit of breakage was when i was trying to find pkg-config in my platform install, couldn't find it, and tried to install it separately
15:07:38 <erisco> shirt, neither! pure
15:07:44 <pollz> dmwit: So lemme get this straight. If a package is listed as broken in ghc-pkg check then will reinstalling it fix it's status (even though it breaks something else)?
15:08:00 <hpc> turns out when you google for "pkg-config download", everything tells you to download gtk+ which includes it
15:08:01 <shirt> Welkin: which one is the explicit one?
15:08:09 <Welkin> shirt:  \_ -> ...
15:08:23 <Welkin> but it depends on what you are doing
15:08:25 <maerwald> hpc: erm.
15:08:32 <maerwald> pkg-config is from freedesktop, not gnome
15:08:35 <Welkin> if you are using that with >>=, then there is already >> for that
15:08:56 <shirt> no, i am using withMVar
15:09:14 <hpc> maerwald: er, "pkg-config windows download"
15:09:18 <hpc> http://stackoverflow.com/questions/1710922/how-to-install-pkg-config-in-windows - my first result
15:09:19 <maerwald> ah
15:09:37 <dmwit> pollz: Possibly. It's complicated.
15:09:42 <maerwald> I guess whenever you add "windows" to your search parameters, all sorts of weird stuff will pop up
15:09:46 <hpc> yeah
15:09:57 <dmwit> pollz: On old GHC/cabal-install's, reinstalling the exact same version successfully will fix it.
15:10:07 <maerwald> I also love these picture tutorials telling you what icons to click
15:10:13 <dmwit> pollz: On newer GHC/cabal-install's, reinstalling the exact same version with the exact same dependency tree and the exact same cabal flags will fix it.
15:10:22 <maerwald> with red lines and stuff
15:10:39 <pollz> dmwit: Aye cap'n.
15:11:01 <dmwit> pollz: I do not know of a convenient way to ask cabal-install to reinstall a package with the same dependency tree as a previous installation.
15:15:16 <pollz> dmwit: Windows is a cunt. That's the solution to my problem.
15:15:27 <pollz> Pardon my french.
15:15:45 <Welkin> at the least you could run a vm
15:15:54 <Welkin> at the best, install linux
15:16:05 <pyon> lambdabot doesn't have free's modules loaded? :-O
15:16:18 <pollz> Welkin: Shifting in a week. Old machine has Linux. Will have to boot that bugger up.
15:19:59 <pollz> Welkin: dmwit hexagoxel hpc Anyways thanks for the help guys good night.
15:37:58 <joe9> need some advice, please? I have f :: a -> Maybe b; x :: Maybe a, and a default b value: I want a f :: b -> (a -> Maybe b) -> Maybe a -> b . The difference with maybe is that the function can return Maybe b instead of b.
15:42:49 <dmj`> :t \d g val = fromMaybe d (val >>= g)
15:42:50 <lambdabot> parse error on input ‘=’
15:42:55 <dmj`> :t \d g val -> fromMaybe d (val >>= g)
15:42:56 <lambdabot> a -> (a1 -> Maybe a) -> Maybe a1 -> a
15:43:12 <dmj`> :t \d g val -> fromMaybe d (val >>= g) :: b -> (a -> Maybe b) -> Maybe a -> b
15:43:13 <lambdabot>     Couldn't match expected type ‘b1
15:43:13 <lambdabot>                                   -> (a2 -> Maybe b1) -> Maybe a2 -> b1’
15:43:13 <lambdabot>                 with actual type ‘r’
15:44:03 <joe9> I can do : fromMaybe undefined $ (f :: a -> Maybe b) =<< (undefined :: Maybe a)
15:44:26 <joe9> dmj' Thanks.
15:45:06 <dmj`> :t \(d :: b) (g :: a -> Maybe b) (val :: Maybe a) -> fromMaybe d (val >>= g)
15:45:07 <lambdabot> b -> (a -> Maybe b) -> Maybe a -> b
15:45:12 <dmj`> there it is
15:45:29 <joe9> dmj' got it. Thanks.
15:45:40 <dmj`> sure
15:58:17 <dmwit> ?djinn b -> (a -> Maybe b) -> Maybe a -> b
15:58:17 <lambdabot> f a b c =
15:58:17 <lambdabot>     case c of
15:58:17 <lambdabot>     Nothing -> a
15:58:17 <lambdabot>     Just d -> case b d of
15:58:17 <lambdabot>               Nothing -> a
15:58:19 <lambdabot>               Just e -> e
15:59:45 <geekosaur> :exf b -> (a -> Maybe b) -> Maybe a -> b
15:59:45 <exferenceBot> parse error: more than one input
15:59:56 <geekosaur> :exf "b -> (a -> Maybe b) -> Maybe a -> b"
15:59:57 <exferenceBot> \ a f2 m3 -> fromMaybe a (m3 >>= f2)
16:00:23 <dmwit> Wow, that's impressive.
16:14:10 * hackagebot servant-swagger 1.1.1 - Generate Swagger specification for your servant API.  https://hackage.haskell.org/package/servant-swagger-1.1.1 (NickolayKudasov)
16:21:42 <ARM9> fromIntegral (0xFFFF::Int16) :: Word32
16:22:09 <dmwit> > fromIntegral (0xffff :: Int16) :: Word32
16:22:10 <ARM9> this one sort of surprised me, my guess was 65535
16:22:11 <lambdabot>  4294967295
16:22:23 <ARM9> ah right, forgot the pointy bit
16:22:26 <ARM9> thanks
16:22:54 <dmwit> > fromIntegral (-1 :: Int16) + fromIntegral (1 :: Int16) :: Word32 -- some rationale for this choice
16:22:55 <lambdabot>  0
16:25:03 <dmwit> I guess there is also the question of why (0xffff :: Int16) == -1. The rationale for that one is harder to write in Haskell and basically boils down to "becauses then the hardware doesn't have to distinguish between Int16 and Word16".
16:27:13 <dmwit> > (0xffff + 1, 0xffff + 1) :: (Int16, Word16) -- perhaps it is not so hard to write in Haskell after all
16:27:15 <lambdabot>  (0,0)
16:27:50 <ARM9> that one don't bother me, I just found it curious that it's sign extended before being cast to unsigned
16:28:51 <dmwit> It isn't. It's cast to an unbounded Integer before being cast to unsigned.
16:29:01 <dmwit> > fromIntegral (0xffff :: Int16) :: Integer
16:29:02 <lambdabot>  -1
16:29:34 <dmwit> ?src fromIntegral
16:29:34 <lambdabot> fromIntegral = fromInteger . toInteger
16:29:34 <dolio> It might not be, but it has to do the same thing.
16:30:02 <kzhang> A question about the conduit package: Is there such a function: zipConduit :: ConduitM i o1 m () -> ConduitM i o2 m () -> ConduitM i (o1,o2) m ()? There is a zipSources function which only works when i == ().
16:30:08 <dmwit> As dolio points out, this is speaking semantically, not operationally. Who knows what the heck it does operationally by the time GHC gets done with all its rewrite rules. =)
16:33:32 <ARM9> yup, probably ends up in a movsx eax, ax or such
16:34:08 <jle`> kzhang: how about http://hackage.haskell.org/package/conduit-1.2.6.6/docs/Data-Conduit.html#g:17 ?
16:34:24 <dmwit> Anyway, my point is that if you think of the middle point as being Integer instead of some collection of bits in memory, it is much more clear why it behaves as it does.
16:34:38 <ARM9> in fact that's what gcc does too
16:34:51 <ARM9> right, gotcha
16:35:27 <ARM9> yup makes sense, thanks
16:36:15 <kzhang> jle`: I think it's a different one. It's signature is: f (ConduitM i o m r) -> ConduitM i o m (f r). What I want is f (ConduitM i o m r) -> ConduitM i (f o) m r
16:36:46 <faux___> i'm making a pokemon game in haskell. i'm starting very small with `Data Monster = Bulbasaur Int | Squirtle Int | Charmander Int`. The `Int`s are for the health of the pokemon. i want to make a function `impact :: Monster -> Int -> Monster` that subtracts the second argument from the pokemon's health. can i use pattern matching like `impact (monster health) damage = monster $ health - damage`?
16:37:10 <shachaf> No.
16:37:29 <shachaf> You can define data Monster = Monster MonsterType Int, and data MonsterType = A | B | C
16:38:01 <shachaf> Or you can define data Monster = A { health :: Int } | B { health :: Int } | C { health :: Int }, and then health :: Monster -> Int
16:38:03 <glguy> o.O I don't remember any of those single letter Pokémon
16:38:31 <faux___> shachaf: thanks, what would the impact function look like?
16:38:39 <shachaf> glguy: Obviously you haven't caught them all yet.
16:39:06 <jle`> they're from gen 8
16:39:18 <ARM9> or data Monster = Foomon | Barmon | Stallmon; then uh data Digimon = Digimon {monsterType :: Monster, health :: Int}
16:40:07 <mniip> >stallmon
16:40:08 <ARM9> and match like (with named field puns iirc) impact mon@Digimon{health} damage = mon {health = health - damage}
16:41:54 <faux___> okay i think i understand. thanks
16:42:41 <Zemyla> glguy: They're Unown.
16:43:09 <glguy> Zemyla: OK, that makes more sense
16:49:46 <vozz> What's wrong with my parser? It works fine most of the time, but fails if theres an ! with something other than []( after it
16:49:52 <vozz> http://lpaste.net/4559578543184412672
16:51:12 <vozz> Oh, it seems to fail if the last block isn't an image block
16:52:02 <glguy> vozz: Given: a <|> b, if a consumes *any* input then the parser commits to a
16:52:25 <glguy> vozz: so given that your parseBlock has parseImageBlock <|> other
16:52:32 <glguy> and parseImageBlock starts with string "![]("
16:52:39 <vozz> Hmm... is there something I can wrap a in, or should I change parseImageBlock to lookahead?
16:52:40 <glguy> once you see a !, then Parsec commits to that branch
16:53:21 <glguy> If you want parsec to backtrack on failure you can wrap the part you want to be able to backtrack in a try
16:54:49 <vozz> Putting (try parseImageBlock) <|> parseTextBlock results in unexpectected end of input
16:54:58 <glguy> try (string "![](") will act as though it consumed no input if it fails to parse the whole thing
16:55:30 <vozz> ahh
16:55:43 <glguy> vozz: then you might have more than one issue to resolve in your parser
16:57:56 <linduxed> hey guys o/
16:58:25 <mniip> huh
16:58:37 <mniip> :t \n -> product [1..n]
16:58:38 <lambdabot> (Enum a, Num a) => a -> a
16:58:43 <linduxed> i've got a 1000x1000 Matrix of Bool that gets updated a whole lot
16:59:05 <linduxed> large chunks of it gets changed, many times over
16:59:33 <linduxed> i've come to the conclusion that it would be best to make use of a mutable matrix package of some sort
16:59:48 <linduxed> whether it's mutable matrix, mutable array or state or something else
16:59:54 <linduxed> i'll need to make things mutable
17:00:07 <linduxed> with that said, i haven't done mutable stuff in haskell so far
17:00:12 <linduxed> so i'm not sure what package to use
17:00:23 <vozz> http://lpaste.net/4559578543184412672 This is what I have now... unexpected input, expecting "![](", but surely if it's in a try it can't be expecting it?
17:00:42 <linduxed> i've found this thing https://hackage.haskell.org/package/array-0.5.1.1/docs/Data-Array-ST.html
17:00:47 <linduxed> which i suspect would work 
17:00:52 <linduxed> but i'm not entirely sure
17:01:16 <Welkin> use vector instead of array
17:01:22 <Welkin> @hackage vector
17:01:22 <lambdabot> http://hackage.haskell.org/package/vector
17:01:33 <Welkin> it has MVectors which use IO or ST (you choose)
17:01:38 <Adeon> vectors are 1-dimensional though
17:01:44 <Adeon> and array package I think supports both IO and ST
17:02:03 <Welkin> well, it depends on if you want ragged arrays or not
17:02:21 <Welkin> a one-dimensional vector can be indexed as multidimensional using an index expression
17:02:28 <Welkin> unless you want them ragged
17:02:34 <Welkin> then you use Vector (Vector a)
17:02:39 <pavonia> vozz: What input do you call the parser with
17:02:46 <pavonia> ?
17:03:10 <vozz> "![](sdfsdf)asds![](sd)sdfdssdfsdf"
17:03:12 <Welkin> but yeah, Array has a nice Ix instance that lets you use anything to index them easily, and in any number of dimensions too
17:03:19 <vozz> "![](sdfsdf)asds![](sd)" works fine
17:03:19 <Welkin> but lacks all the other features from vector
17:07:37 <pavonia> vozz: The problem seems to be that the ending parser in manyTill never succeeds
17:08:53 <vozz> pavonia: The one in parseTextBlock needs to check end of file doesnt it? How would I do that?
17:09:34 <pavonia> Wild guess: (lookAhead parseImageBlock <|> eof)
17:10:51 <pavonia> But I'd prefer something like many (satisfy (/= '!'))
17:11:32 <vozz> I got it working with (lookAhead parseImageBlock >> return "") <|> (lookAhead eof >> return "") but that seems mad :|
17:12:18 <vozz> If I just checked against ! then "asfasf!asafs" would result in two TextBlocks rather than one I think
17:12:58 <pavonia> (void $ lookAhead parseImageBlock) <|> eof
17:14:03 <vozz> thanks :)
17:14:33 <pavonia> vozz: Can the stream also start with a text block?
17:14:52 <jle`> i'm really spoiled by haskell types when it comes to reading documentation
17:14:55 <vozz> Yes
17:15:01 <jle`> trying to read docs for a language without a good type system is torture
17:15:15 <jle`> *docs for a library in a language
17:17:43 <Welkin> even *finding* documentation in other languages is difficult
17:17:47 <Welkin> if not impossible
17:18:00 <Welkin> in haskell, no one has any excuse, because oh haddock
17:18:03 <Welkin> of
17:55:08 <dmj`> /msg jle` hatched an abra \o/
17:55:08 <dmj`>  
17:55:12 <dmj`> /msg jle` hatched an abra \o/
17:55:12 <dmj`>  
17:55:17 <dmj`> oh man
17:55:17 <dmj`>  
17:57:27 <Welkin> lol what
18:09:23 <geekosaur> as pokemon go eats haskellers' brains as well as it does everyone else's...
18:10:14 <bernalex> yes, people are definitely getting stupider from having fun geocaching...
18:14:13 * hackagebot tcp-streams 0.2.2.0 - One stop solution for tcp client and server with tls support.  https://hackage.haskell.org/package/tcp-streams-0.2.2.0 (winterland)
18:19:14 * hackagebot Concurrent-Cache 0.2.2.0 - A Cached variable for IO functions.  https://hackage.haskell.org/package/Concurrent-Cache-0.2.2.0 (Ofenhed)
18:20:42 <sayla> Every restaurant in my area has a Pokemon Go chintzy sign out front
18:21:03 <sayla> "Get a latte -- and a Pikachu!"
18:21:13 <sayla> I've never seen anything bridge online -> offline like this
18:29:14 * hackagebot Concurrent-Cache 0.2.2.1 - A Cached variable for IO functions.  https://hackage.haskell.org/package/Concurrent-Cache-0.2.2.1 (Ofenhed)
18:45:02 <synergistics> What's the best way to profile a file stack?
18:45:13 <synergistics> a file from stack*
18:58:55 <parsnipM_> Hakyll uses Snap for previewing locally... can i set content-type html/text easily? 
18:59:31 <parsnipM_> maybe i need something from https://hackage.haskell.org/package/snap-core-0.9.8.0/docs/Snap-Internal-Http-Types.html
19:00:56 <parsnipM_> defaulting to application/octet-stream for files without a file extension. 
19:22:39 <CodA> .
19:23:58 <CodA> Sup?
19:24:31 <glguy> Welcome to #haskell
19:25:04 <CodA> Thnx dude!
19:25:40 <CodA> It's all about hacking and techy things here, right?
19:25:56 <glguy> The topic is specifically the Haskell programming language, actually
19:26:24 <CodA> Cool
19:26:40 <parsnipM_> getting closer, https://hackage.haskell.org/package/snap-core-0.9.8.0/docs/Snap-Core.html#v:setContentType
19:28:07 <CodA> Actully am new to IRC, What is this link?
19:28:49 <glguy> parsnipM_: Is narrating an attempt at figuring out how to set the content type for a HTTP response in Snap
19:29:31 <JustinHitla> anyone here ?
19:29:44 <sleblanc`> JustinHitla: sure.
19:29:49 <JustinHitla> so I heard it like in perl6 you can create your own syntax, can you create own syntax in haskell ?
19:30:13 <geekosaur> not the same way
19:30:30 <sleblanc`> Haskell has semantics and libraries that allow you to define a domain-specific language without getting a headache
19:30:58 <sleblanc`> but it is much unlike the Perl method
19:31:22 <JustinHitla> sleblanc`: you mean Perl method is wrong way doing it ?
19:31:41 <geekosaur> nobody said anything about wrong way...
19:32:18 <sleblanc`> oh, the headache thing is not directed at Perl, it's just a general thing
19:33:25 <geekosaur> haskell is good at defining emmbedded domain-specific languages. that does not actually add new syntax though, only new semantics. the basic syntax is not flexible although there are some experimental preprocessors that allow adding some kinds of syntax extensions (e.g. https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/)
19:33:47 <vctr> hello
19:34:04 <geekosaur> whereas perl 6 lets you define new things in existing syntactic categories, or push an entire grammar modifier ("slang") on top of the current one
19:34:56 <JustinHitla> also, there is only one haskel right ?
19:35:36 <geekosaur> only one currently (and publicly; uhc gets commits but nothing is announced and it's likely to be utrecht student experiemnts) developed compiler currently.
19:35:41 <shachaf> There is no Haskell but Haskell 2010, and GHC is its compiler.
19:36:14 <JustinHitla> I mean like others have few versions: "scheme,closure,common lisp", "perl 5, perl 6", "python 2.* python 3.*"
19:36:38 <JustinHitla> there is only one haskell and it will stay that way ?
19:38:14 <glguy> shachaf: Which GHC was the Haskell 2010 compiler?
19:38:33 <sleblanc`> JustinHitla: here's an example of one way of embedding a language inside Haskell: http://www.yesodweb.com/book/shakespearean-templates#shakespearean-templates_interpolation
19:39:26 <shachaf> glguy: Haskell 2010 is a fiction.
19:40:06 <geekosaur> ghc stopped compiling actual haskell2010 with 7.10 anyway (well, 7.8 but it still claimed to, it just got it wrong)
19:40:09 <sleblanc`> the second excerpt shows Hamlet (part of Shakespearean templates) and is a method of writing HTML widgets that can include variables from the local scope
19:42:47 <lambdafan> I've derived a foldable instance for my data type using DeriveFoldable, how do I see the generated code?
19:43:37 <glguy> -ddump-deriv
19:49:27 <sleblanc`> in GHCI, how can I find the actual type of an exception?
19:50:52 <lambdafan> glguy: I have that as a ghc-option in cabal now, nothing came outas output. Is there something I am forgetting?
19:51:28 <glguy> You might need to clean first so that GHC rebuilds the module
19:51:41 <geekosaur> cabal probably stashed the output in a log file; also what glguy said
19:51:52 <glguy> sleblanc`: Typeable is a superclass of Exception, so using Data.Typeable methods
19:56:18 <sleblanc`> glguy: I don't understand how I can use these functions, as I do not have a handle on the exception. e.g. I type > myAction in GHCI, and it outputs "*** Exception: /adsf: …"
19:56:25 <sleblanc`> for instance, Python has sys.last_traceback…
19:56:53 <JustinHitla> some intersting links on reddit about haskell to read ?
19:57:36 <geekosaur> sleblanc`, use something like Control.Exception.catch
19:57:38 <glguy> sleblanc`: You'll need a value of the exception, using try or similar
20:00:46 <dmj`> sleblanc`: exceptions in haskell are implemented with existential types, which are resolved at runtime, so you have to cast them after you catch them (using try or the like), you can call show on it too
20:01:15 <dmj`> fromException is your friend
20:06:22 <glguy> Compare existential types to theoretical ones
20:08:27 <sleblanc`> http://lpaste.net/8502727806495490048
20:08:42 <sleblanc`> hmph, I thought there would be a way to find it in a interpreter session
20:09:17 * hackagebot json-rpc-generic 0.2.0.0 - Generic encoder and decode for JSON-RPC  https://hackage.haskell.org/package/json-rpc-generic-0.2.0.0 (KeiHibino)
20:09:25 <geekosaur> ghci is not a full interpreted environment like perl/python/ruby, which are primarily interpreters and therefore can be introspected
20:09:43 <glguy> `catch` \( SomeException e ) -> ...
20:10:28 <Cale> `catch` \( SomeException e ) -> print (typeOf e)
20:10:46 <geekosaur> "natural" haskell code is compiled and does not have an interpreter environment to remember the last exception or w/e. ghci could in theory arrange for bytecode compilation to track that, but the result might be less than useful if an exception gets handled by compiled code
20:11:41 <glguy> Also create directory is going to throw an IOError found in System.Io.Error
20:12:26 <sleblanc`> thanks for the explanation
20:14:25 <Cale> It is a little bit unfortunate sometimes that there's no way to inspect an IO action to discern which exceptions it might throw. Of course, if you wanted statically checked exceptions, you'd just use Either
20:14:52 <geekosaur> also holding onto that in the interpreter environment would potentially introduce leakage (i.e. things that don't get garbage collected when you expect them to). with interpreted languages that's just a cost of the interpreter; the pervasive assumption in Haskell code is native compilation and nothing expects that an outer environment might hold onto something for an arbitrary amount of time. (this can already show up with ghci's "it" binding, 
20:14:52 <geekosaur> but as that gets rebound with every expression it's not usually noticeable()
20:15:56 <geekosaur> ...note that if you spawn threads, they continue running concurrently with the prompt, so there can't sim[ly be a full reset every time ghci prompts
20:16:01 <sleblanc`> could the exception's value also be bound to `it` when an expression throws an exception?
20:16:12 <geekosaur> no
20:16:26 <geekosaur> not unless you want to design a completely different exception system
20:16:34 <Cale> If you wrap the thing in try it kind of sort of will be
20:16:47 <Cale> Oh, but not if *expression evaluation* does that
20:16:51 <sleblanc`> re: threads in ghci, I am aware of that (*** Exception: bind: resource busy (Address already in use))
20:17:11 <Cale> Only if execution of the IO action throws the exception (which is the sort of exception you'd typically want to catch anyway)
20:18:30 * geekosaur still thinks using exceptions for the effectively synchronous I/O errors was a mistake, sigh
