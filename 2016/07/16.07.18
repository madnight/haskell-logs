00:02:46 <Iceland_jack> better link: http://comonad.com/reader/2012/abstracting-with-applicatives/
00:03:14 <bollu> ertes: how does the Constant work?
00:04:39 <ertes> bollu: the terminology is a bit convoluted here…  Constant is really not "constant functor" here
00:04:42 <Iceland_jack> Keep in mind that this is 'identity + some applicative functor'
00:04:42 <Iceland_jack>     data Lift f a = Return a | Others (f a)
00:04:58 <ertes> Constant is more like Identity on the functor level, i.e. an identity transformation
00:04:59 <Iceland_jack> while this is 'identity + constant functor'
00:04:59 <Iceland_jack>     Lift (Const err) a
00:05:08 <bollu> ertes: yeah, that's what tripped me up.
00:05:25 <Iceland_jack> We make use of the Applicative instance for (Const e) there, but we could have inlined it
00:05:27 <bollu> ertes: so it's an identity on a _functor_? which is why it takes a functor and just wraps it up in an Other?
00:05:48 <ertes> bollu: Constant :: (* -> *) -> (* -> *)  -- takes a functor and results in a functor that is isomorphic to it
00:06:16 <ertes> (i wouldn't call it "Constant")
00:06:20 <bollu> ertes: gotcha
00:06:31 <bollu> ertes: Identity seems better? >_<
00:06:41 <Iceland_jack> I'm not sure what ertes means
00:06:48 <ertes> bollu: it's basically IdentityT =)
00:07:20 <ertes> Iceland_jack: i'm reconstructing your Lift type as a sum of two functors
00:07:39 <bollu> ertes: right :)
00:07:47 <ertes> Lift f = Id + f
00:08:16 <Iceland_jack> Then 'newtype IdentityPlusConstant f a = Return a | Others (f a)' is confusingly named
00:08:47 <bollu> "his is in fact how we typically write monads (pace operational, free, etc.)" what is "pace operational"?
00:08:56 <ertes> Iceland_jack: i named it that way, because you referred to it as "the sum of identity and the constant functor"
00:09:05 <Iceland_jack> I hadn't finished typing :)
00:09:20 <Iceland_jack> <Iceland_jack> For those interested, this is the sum of identity and the constant functor
00:09:20 <Iceland_jack> ...
00:09:21 <Iceland_jack> <Iceland_jack>     type Validation err a = Lift (Const err) a
00:09:21 <Iceland_jack>  
00:09:29 <ertes> ah
00:09:32 <ertes> ok =)
00:09:48 <ertes> yeah, that one is indeed such a sum
00:10:50 <ertes> bollu: not sure about "pace operational", but 'operational' is a package for imperative DSLs
00:13:19 <bollu> ertes: I see
00:13:30 <bollu> ertes: what does it give us? a sort of a custom Free monad construction?
00:15:09 <ertes> bollu: with operational you write:  MyCommand :: Blah -> MyFunctor Blubb
00:15:23 <ertes> with free you write:  MyCommand :: (Blubb -> x) -> Blah -> MyFunctor x
00:15:40 <ertes> the former is badly named, as it's not a functor
00:17:03 <ertes> operational is for command languages with the GADT's type argument specifying the result type of each operation…  you can't really do anything fancier with it
00:17:21 <ertes> but it may be easier to understand than free monads
00:38:17 <zipper> Hey dudes do you have  a major issue with autoindent on spacemacs?
00:53:19 * hackagebot env-locale 1.0.0.1 - A (non-forking) interface to the current locale  https://hackage.haskell.org/package/env-locale-1.0.0.1 (ongyerth)
01:38:20 * hackagebot path-io 1.2.0 - Interface to directory package for users of path  https://hackage.haskell.org/package/path-io-1.2.0 (mrkkrp)
01:43:09 <nkaretnikov`> Iceland_jack: i gathered i need a version of Validation that's also a Monoid in a, is there such a thing?
01:43:28 <nkaretnikov`> Iceland_jack: it mappends Failures and Successes, that is
01:43:40 <nkaretnikov`> Iceland_jack: and short-circuits on Failure
01:45:01 <nkaretnikov`> (need to check the monoid laws for this one, tho)
01:48:45 <nkaretnikov`> damn, the monoid laws don't hold for my definition
01:48:53 <nkaretnikov`> that's probably why it's defined as is
01:49:00 <nkaretnikov`> maybe i could at least have a semigroup, hm
02:07:14 <zaquest> hello. i think i havent asked here yet. does anyone know what can cause ".stack-work/dist/x86_64-linux/Cabal-1.22.8.0_ghcjs/: does not exist" error during `stack build`. the directory exists. i installed ghcjs using `stack setup` with stack.yaml file from here http://docs.haskellstack.org/en/stable/ghcjs/ master section both lts-5.12 and lts-3.6
02:08:21 * hackagebot hasql 0.19.13 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.13 (NikitaVolkov)
02:08:23 * hackagebot rebase 0.5.4 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-0.5.4 (NikitaVolkov)
02:47:49 <ertesx> #10569 was a terrible idea
02:48:34 <ertesx> https://ghc.haskell.org/trac/ghc/ticket/10569 ⇐ i already commented on it being a bad idea, but it is turning into so much of a headache that i'm going to disable typed hole warnings now
02:49:01 <ertesx> problem:  you use a symbol without importing it…  instead of a hole warning or a not-in-scope error you get a completely confusing and useless type error
02:52:47 <ertesx> i've just wasted 20 minutes on a bullshit type error that should have been: "not in scope: join" (a.k.a. "please import Control.Monad")
02:52:57 <ertesx> excuse the strong language, but this is really annoying
02:54:41 <pavonia> ertesx: What error does it report instead?
02:56:16 <ertesx> pavonia: a type error:     • Couldn't match type ‘EventTrigger t0’ with ‘Reflex.Spider.Internal.RootTrigger’
02:56:16 <ertesx>  
02:57:16 <ertesx> the real error is that i forgot to import Control.Monad
02:58:19 <pavonia> Is that the new default behaviour?
02:58:30 <ertesx> it is, if you enable -fdefer-typed-holes
02:58:35 <ertesx> since 8.0
02:58:51 <volothamp> Hello. Does anyone know here if some Haskell tool (i.e. purescript compiler installer) creates this folder on macOS? /Users/myuser/Library/Haskell/bin/psci
02:59:03 <pavonia> That indeed sounds annoying
02:59:26 <ertesx> actually no
02:59:50 <ertesx> this happens even without deferred typed holes
02:59:58 <volothamp> Or in other terms, if it's safe to remove the ~/Library/Haskell folder
03:00:00 <ertesx> i justed tested it
03:00:10 <ertesx> i'm reporting this as a GHC bug
03:01:39 <superlinux> hello. I still on debian get : Missing C libraries: qtc_core, qtc_gui, qtc_network, qtc_opengl, qtc_tools,qtc_script . and I did install qt-sdk
03:10:20 <tdammers> superlinux: have you installed the -dev packages for those?
03:10:57 <tdammers> normally, libraries come in two flavors: the plain one (libfoobar) and the -dev one (libfoobar-dev)
03:11:20 <tdammers> the plain flavor only installs runtime dependencies (.so and such), the -dev flavor also installs headers and other link-time / compile-time dependencies
03:13:21 <superlinux> tdammers, the qt-sdk should install everything
03:38:53 <insitu> I found this paper from Oleg to generate SQL from embedded query-language: http://okmij.org/ftp/meta-programming/quel.pdf
03:40:01 <insitu> I would like to do the converse: generate haskell code from SQL. Does anybody know something like that in Haskell?
03:40:02 <merijn> ertesx: Yeah, I don't know who the hell added "not imported" errors to typed holes
03:40:43 <fr33domlover> insitu, never heard of such a thing, but what code do you want to generate exactly?
03:41:02 <merijn> ertesx: That ticket says it's optional
03:41:11 <merijn> ertesx: Your sayins it;s enabled by default?
03:41:42 <insitu> fr33domlover something like embedded QL 
03:41:49 <insitu> or LINQ
03:43:02 <jle`> insitu: sounds like just a normal parser/interpreter?
03:43:08 <insitu> fr33domlover to be exact, something like what Spark's catalyst (https://databricks.com/blog/2015/04/13/deep-dive-into-spark-sqls-catalyst-optimizer.html) does but simpler/more generic
03:43:12 <jle`> parse an SQL string into a representation of a command?
03:43:32 <insitu> jle` yes. Just looking for prior work on this in Haskell
03:43:51 <merijn> ertesx: Did you submit a bug? Else I will reopen the ticket
03:43:55 <insitu> might be something obvious... or my google-fu is lacking
03:44:17 <insitu> foudn this paper: https://www.cs.purdue.edu/homes/rompf/papers/rompf-icfp15.pdf
03:44:56 <fr33domlover> I read some discussion somewhere about the possibility of making a qq that parses a subset of SQL into esqueleto or similar
03:45:11 <fr33domlover> Not sure if anyone rolled the sleeves and did that yet :P
03:47:30 <insitu> spark people did that for spark, apparently
03:48:14 <ertesx> merijn: i just did
03:48:31 <insitu> given the pervasiveness of SQL and the "obvious" functional interpretation it can have, I am surprised nobody already did that
03:48:42 <ertesx> merijn: https://ghc.haskell.org/trac/ghc/ticket/12406
03:48:48 <insitu> or maybe I am looking at it the wrong way?
03:49:25 <ertesx> merijn: SPJ implemented the new behaviour…  in principle being able to see the types of out-of-scope variables could be useful, but with -fdefer-typed-holes they turn into a nightmare
03:49:41 <ertesx> honestly i just want the old behaviour back
03:49:47 <jle`> insitu: most people just write "sql" in a haskell dsl
03:49:52 <merijn> ertesx: Yeah, this is completely antithetical to what I intended with defer-typed-holes
03:49:52 <jle`> there isn't any reason to enter sql as a string
03:49:59 <jle`> and have it be interpreted ... into sql
03:51:03 <jle`> that's like using the string "{ fst: 'a', snd: 'b' }" to define a tuple instead of just ('a', 'b')
03:51:32 <insitu> jle` sure. The point is that 1/ there are more (probably) people comfortable with SQL than with Haskell/OCaml and 2/ I would like to execute it against something which is not a relational DB, e.g. streams, data structures in memory, files, whatever...
03:51:39 <jle`> sure, you could always define tuples by parsing a string representing them, but that's kind of silly
03:51:47 <insitu> jle` :)
03:51:47 <merijn> ertesx: Your bug example relies on a non-base library
03:52:01 <ertesx> merijn: apparently everybody is fine with making the new behaviour optional, but nobody is going to implement it…  and i have no clue about GHC's source code =/
03:52:13 <ertesx> merijn: it was the smallest example i could build
03:52:18 <jle`> insitu: good points though
03:52:30 <ertesx> merijn: the MonadRef class is small and could in principle be just pasted into the code
03:52:51 <insitu> jle` thanks. I mean, on a personal level I would not care of course.
03:52:53 <merijn> ertesx: For me it panics
03:53:05 <merijn> ertesx: It should be fairly simple
03:53:15 <ertesx> merijn: that's interesting…
03:53:20 <merijn> ertesx: I hacked in defer-typed-holes because no one wanted to implement it :p
03:53:50 <ertesx> merijn: should i copy the MonadRef code into the bug report?
03:53:59 <merijn> ertesx: http://lpaste.net/170305
03:55:58 <merijn> ertesx: This is the original implementation: https://phabricator.haskell.org/rGHC2cc854b7133e38c7ad1107057931761782d03594
03:56:00 <ertesx> merijn: you managed to make it even worse than i have =)
03:58:09 <lpaste> newcomer pasted “gadts” at http://lpaste.net/170306
03:59:00 <merijn> ertesx: See also: https://ghc.haskell.org/trac/ghc/ticket/12170
03:59:12 <newcomer> so I'm trying to learn GADTs. On line 23 I'm trying to do the same thing as line 12 but I'm getting a parse error. Any help? http://lpaste.net/170306
03:59:21 <jle`> egadts
03:59:39 <merijn> ertesx: Was already reported: https://ghc.haskell.org/trac/ghc/ticket/12156
03:59:57 <merijn> Supposedly fixed in HEAD?
04:00:01 <jle`> what's the error?
04:00:38 <newcomer> parse error in constructor in data/newtype declaration: forall b. ty ~ (->) a b => SArrow (STy a) (STy b)
04:01:06 <jle`> hm, have you tried squishing the foralls together?
04:01:19 <newcomer> jle`, I don't know why.
04:01:23 <newcomer> how
04:01:33 <jle`> forall a b. (ty ~ (a -> b)) => ...
04:01:36 <jle`> not sure if that'd work though
04:02:15 <merijn> ertesx: But it only took me like 1 day or so to trace through the type checking code to figure out where to add the defer-typed-holes stuff, so it shouldn't be to hard to fix, assuming it's not already fixed in HEAD
04:02:39 <newcomer> jle`, That worked.
04:02:47 <jle`> hooray
04:07:15 <newcomer> jle`, Just that you don't think that I'm a lazy asker, I first put a comma between the type variables and that didn't work, so I googled "multiple existential quantifiers" and got no relevant results yet saw some code that did it the way it is on the lpaste post. But that gave me the parse error so I came here.
04:08:14 <jle`> haha i didn't think you were a lazy asker.  honestly existential type syntax in data constructor declaration feels super ad-hoc to me
04:08:25 * hackagebot sharc-timbre 0.2 - Sandell Harmonic Archive. A collection of stable phases for all instruments in the orchestra.  https://hackage.haskell.org/package/sharc-timbre-0.2 (AntonKholomiov)
04:08:29 <jle`> i like to pretend they don't exist
04:08:48 <ertesx> merijn: i updated my report to be self-contained (no ref-tf dependency)
04:09:03 <merijn> ertesx: Did you check the other ticket I linked?
04:09:17 <jle`> it's just weird arbitrary syntax that really appears nowhere else in the language.  GADT syntax is much more natural
04:09:29 <ertesx> merijn: yeah, the first one i was actually already cc-ed
04:10:24 <ertesx> merijn: because i made a lot of noise against the new not-in-scope behavior and reopened #10569, then mpickering reported it as a separate issue
04:12:51 <ertesx> merijn: i wouldn't even mind the new behaviour, if the problem i discovered today gets fixed and someone implements warning priorities (https://ghc.haskell.org/trac/ghc/ticket/12157)
04:14:33 <merijn> ertesx: Did you test HEAD already?
04:17:42 <ertesx> merijn: i have only 2 GiB RAM here, so compiling GHC isn't reasonable here =/
04:18:26 <ertesx> merijn: do you have HEAD ready to go?
04:18:55 <hpc> ertesx: i have compiled ghc on one gig
04:20:07 <ertesx> hpc: while working?
04:20:08 <merijn> I don't have HEAD< no
04:21:17 <hpc> it slows down a bunch of things, but i can still vim and stuff
04:22:27 <thomie> ertesx merijn: #12170 isn't fixed yet in HEAD, so #12406 isn't either
04:24:08 <ertesx> hpc: i'm working on one project with a running GHCi session and a browser, and i've got 640 MiB RAM left =)
04:24:51 <hpc> ah, you'll have a hard time with that then ;)
04:25:31 <hpc> browsers crap out pretty hard when memory and disk are both under load
04:26:03 <APic> What Sort of Applications do not do that?
04:26:15 <ertesx> hpc: GHCi takes a majority
04:26:38 <hpc> vim runs fine under load
04:26:41 <ertesx> 511 MiB GHCi, 277 MiB browser
04:26:46 <ertesx> emacs doesn't =)
04:26:47 <tdammers> I've also locked up my computer a few times by writing careless quickcheck tests
04:26:52 <ertesx> and no, i'm not going to switch to vim =)
04:26:58 <tdammers> specifically, Arbitrary instances for tree-shaped things
04:27:08 <cocreature> ertesx: I heard you can run emacs in neovim
04:27:13 <hpc> one page visit in a browser hits disk dozens of times and touches a few tens of megs of memory
04:27:19 <tdammers> :!emacs %
04:27:36 <hpc> a typical minute or two in vim touches disk once or twice, and a very narrow range of ram
04:27:41 <ertesx> cocreature: hmm?
04:28:46 <ertesx> hpc: emacs and vim side by side look like an elefant and an ant…  especially with my configuration…  emacs needs 70 MiB RAM here, and it usually needs ~20 seconds to start up
04:29:21 <hpc> it takes longer for my craptop to load emacs than it does for my good laptop to boot into windows
04:29:35 <cocreature> ertesx: mine takes up 267mb :)
04:29:41 <hpc> if it wasn't for agda, i would literally never use it
04:29:47 <barrucadu> cocreature: Booting an operating system takes a while :p
04:29:58 <ertesx> cocreature: i'm glad =)
04:30:09 <cocreature> but it starts in 2 seconds or so
04:30:13 <hpc> agda-mode is the only reason i have ever purposefully edited a file in emacs
04:30:19 <tdammers> "It's an ant. An eleph one, even."
04:31:32 <ertesx> let's just say i'm glad emacs has a daemon mode =)
04:32:31 * Maxdamantus installs emacs on his phone to see how long it takes to start.
04:32:59 <ertesx> Maxdamantus: you can't test it like that…  an unconfigured emacs starts fast
04:33:20 <ertesx> to benchmark emacs' start time, you must have used and configured it for at least 10 years
04:34:05 <Maxdamantus> If I configured it as much as vim I'm sure it would still start quickly enough then.
04:34:07 <wedens> how can I use multiple temporary files and ensure they are deleted?
04:34:34 * Maxdamantus basically knows the settings he needs for vim.
04:34:41 <hpc> there's a package for tempfiles on hackage
04:34:56 <Maxdamantus> set copyindent, colourscheme slate
04:35:03 <Maxdamantus> that's pretty much it.
04:35:18 <hpc> i like to set list
04:35:37 <cocreature> wedens: https://hackage.haskell.org/package/temporary-1.2.0.4/docs/System-IO-Temp.html
04:35:38 <ertesx> wedens: in System.IO there is the 'openTempFile' function that you can apply twice together with 'bracket' from Control.Exception
04:36:02 <tdammers> IIRC there's also a withTempFile that does the bracketing for you
04:37:00 <wedens> ertesx, cocreature: too much nested brackets.. and sometimes it is list of files. is there more convenient way?
04:37:25 <cocreature> too much nested brackets?
04:37:33 <ertesx> wedens: i use Codensity to streamline brackets
04:37:38 * Maxdamantus just started emacs on his phone (started in X11 mode by default) and was reminded that he needs to fix his stupid main programs' fonts.
04:37:39 <ertesx> wedens: from kan-extensions
04:38:01 <wedens> ertesx: do you have an example?
04:38:20 <Maxdamantus> the font rendering in emacs looks amazing compared to all the standard applications, including the funny version of xterm.
04:38:23 <cocreature> you can also use the managed package to make working with these “with…” functions more convenient. 
04:38:23 <ertesx> wedens: lowerCodensity (do x <- Codensity (bracket acquire1 release1); y <- Codensity (bracket acquire2 release2); liftIO (doSomething x y))
04:39:08 <superlinux> f@#$% man! how messy is haskell and cabal
04:39:37 <tdammers> could be worse
04:40:29 <tdammers> the problem isn't so much that cabal does things badly, it's that cabal attempts to do things that other build systems just hand-waive and implicitly leave to the programmer
04:40:33 <wedens> ertesx: so, lowerCodensity releases resources in this case?
04:41:37 <ertesx> wedens: the argument to lowerCodensity is the scope of the brackets, and they are released in reverse order as you might expect
04:42:04 <superlinux> I wanted to install qt.. not working.. gtk.. not working... wx .. not working.. yesod.. it forces me to re download ghc while i already have ghc.
04:42:20 <wedens> ertesx: thanks. I'll try this approach
04:42:28 <superlinux> i really had it with haskell.
04:42:38 <superlinux> that's enough
04:43:19 <ertesx> wedens: Codensity (\k -> …)  -- k applied to an argument represents the remainder of the action, so if you use e.g. 'finally' here, then it's like you had written it around the whole action
04:43:33 <koz_> superlinux: It'd help us help you if you said what precisely 'not working' means in your cases for Qt, GTK etc.
04:43:44 <bennofs> superlinux: also what os are you on
04:44:09 <koz_> bennofs: The name is somewhat suggestive of that. :P
04:44:31 <bennofs> what distro then? :D
04:44:34 <ertesx> wedens: Codensity (\k -> k () `finally` action)  -- here you simply "register" 'action' to run after everything else (except stuff that was registered earlier)
04:45:05 <ertesx> it's quite a nice abstraction, if you allocate multiple resources =)
04:45:15 <ertesx> or do multiple cleanups
04:46:04 <bennofs> superlinux: also how did you install ghc/cabal?
04:49:46 <koz_> bennofs: I guess we shall never know...
04:49:53 <superlinux> koz_, and bennofs look my friends..
04:49:59 <wedens> ertesx: yeah. looks useful
04:50:14 <superlinux> I use debian jessie linux.
04:50:32 <maerwald> superlinux: install the -dev packages
04:50:47 <koz_> What maerwald says is usually good practice anyway.
04:50:49 <superlinux> but I wanted to use haskell away from packges
04:50:58 <koz_> superlinux: Why on earth would you want that?
04:51:12 <koz_> The whole point of package management is to *not* have to do all that shit yourself.
04:51:19 <superlinux> so i downloaded the latest generic version of haskell
04:51:27 <merijn> koz_: Easy: Because package management doesn't work AT ALL if you don't have root
04:51:39 <merijn> Incidentally, GHC is one of the easiest tool to install user local
04:51:41 <bennofs> koz_: using ghc/cabal from debian repo are very outdated
04:51:46 <koz_> merijn: This is true, but I somehow doubt this is the issue here.
04:51:50 <superlinux> merijn, yep that't correct
04:51:58 <superlinux> rooting is my problem
04:51:58 <koz_> bennofs: Debian stable probably isn't *that* far behind nowadays.
04:52:15 <merijn> superlinux: Latest being GHC 8?
04:52:20 <koz_> superlinux: Huh, OK then. I'm a bit surprised, but sure.
04:52:21 <merijn> superlinux: I would grab 7.10 instead
04:52:29 <merijn> 8 is still a bit shakey
04:52:30 <superlinux> merijn, yes! version 8 of ghc
04:52:43 <hpc> koz_: has it improved lately? last i checked stable was consistently 3 years behind
04:53:16 <koz_> hpc: Unsure, but it can't be *that* bad surely? My only interaction with Debian is the testing instance on my uni machine.
04:53:23 <superlinux> i feel that no one is taking haskell seriously in debian.
04:53:36 <koz_> (and that's only because UEFI makes me shit myself in anger on that POS)
04:53:46 <koz_> (and Debian at least auto-makes-it-work)
04:53:56 <superlinux> I wish there is an official independent debian repo for haskell. that would be better
04:54:32 * superlinux is drinking pomegranate juice. yummm
04:54:57 <bennofs> superlinux: https://github.com/hvr/multi-ghc-travis not sure if the packages work on debian?
04:55:03 <maerwald> superlinux: https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/Linux#DebianUbuntuandotherDebian-basedsystems
04:55:09 <maerwald> did you follow that?
04:58:07 <superlinux> maerwald, what i know is i install only haskell-platform package and I am done
04:58:43 <superlinux> I always download the build-essential package. it does all C++ things
05:00:32 <bennofs> maerwald: do you really need to build from source on debian?
05:00:41 <maerwald> bennofs: no, it was a question
05:00:46 <sm> superlinux: I have the opposite impression of debian haskell, from watching the debian-haskell mail list
05:01:54 <maerwald> superlinux: haskell stuff is very difficult to package, so most distros just drop you the haskell-platform and are done with it
05:01:58 <maerwald> which kind of makes sense
05:02:35 <maerwald> the only exception might be nix, which can handle that stuff easily, but that's not a recommendation
05:02:54 <bennofs> Perhaps stack would be easier in this case?
05:02:57 <maerwald> no
05:03:10 <sm> yes, stackage is great for packagers
05:03:20 <maerwald> stack is more complicated for beginners
05:03:27 * hackagebot sproxy 0.9.8 - HTTP proxy for authenticating users via OAuth2  https://hackage.haskell.org/package/sproxy-0.9.8 (ip1981)
05:03:30 <merijn> sm: 50% says "great" other 50% says "terrible"
05:03:32 <bennofs> at least it handles ghc installation for you
05:03:42 <maerwald> sm: what do you mean with that?
05:03:48 <maerwald> sm: a packager never uses stack anyway
05:04:02 <sm> stackage does the biggest part of eg debian packagers work for them already
05:04:03 <maerwald> he uses the .cabal definition and transforms it into a distro-specific definition
05:04:03 <bennofs> but stackage is good
05:04:18 <bennofs> it provides a stable set of packages, so you don't need to pick package sets as a packager 
05:04:22 <sm> and if y'all don't agree I don't know what planet you people are from :)
05:04:46 <bennofs> it is super useful for packagers to get at least a core set of packages that build together
05:06:21 <bennofs> superlinux: what UI framework would you like to use?
05:06:42 <maerwald> bennofs: I don't consider that proper packaging. In proper packaging, you have your OWN CI system and your OWN tests.
05:06:58 <bennofs> maerwald: yes, you still have that
05:07:08 <bennofs> maerwald: but it saves you from the trouble of trying many things that don't work
05:07:09 <maerwald> I don't know stackages policy, workflow or QA rules.
05:07:17 <maerwald> so I tend to ignore it if I package haskell stuff
05:08:11 <bennofs> maerwald: you can still run your own QA on top of the stackage package set
05:09:41 <maerwald> bennofs: the only thing you need is correct .cabal definitions
05:09:44 <superlinux> bennofs, i don't care.. I am a masters degree holder. I can do whatever. I have the potential to learn
05:09:54 <maerwald> if something does not build with something else, it simply means the dependencies in the cabal file are wrong
05:09:57 <superlinux> btw I want to tell you this..
05:10:29 <superlinux> I taught two girls haskell. they are masters students too.
05:10:50 <maerwald> xD
05:11:00 <rgrinberg> On this page in the in the definition of cofree: http://dlaing.org/cofun/posts/free_and_cofree.html, what is :<?
05:11:29 <bennofs> maerwald: but in reality, you have to deal with broken .cabal files. stackage saves you time. Of course, if you want, you can replicate the efforts stackage does and select your own package set. Still, if you don't want to spend so much time, stackage really helps, especially for smaller distributions where you don't have too many people working on Haskell packaging
05:11:32 <Iceland_jack> rgrinberg: 
05:11:33 <Iceland_jack> Constructor for Cofree
05:11:51 <maerwald> bennofs: a packager is supposed to fix the .cabal file 
05:11:54 <maerwald> that's the proper way
05:11:56 <superlinux> and I have been graduated from masters since 2008. and I taught them haskell which I  never ever had in university... and finally they got 70% mark. they passed...
05:12:05 <superlinux> this means I passed too :)
05:12:05 <rgrinberg> you can have symbols for constructors - cool.
05:12:07 <Iceland_jack> Defined here
05:12:07 <Iceland_jack>     data Cofree f a = a :< f (Cofree f a)
05:12:07 <Iceland_jack> could be defined
05:12:07 <Iceland_jack>     data Cofree f a = MkCofree a (f (Cofree f a))
05:12:28 <Iceland_jack> rgrinberg: that's basically what (:) is for lists
05:12:28 <Iceland_jack> > 1:2:3:4:5:[]
05:12:29 <lambdabot>  [1,2,3,4,5]
05:12:33 <Iceland_jack> with some cheating
05:12:53 <Iceland_jack> rgrinberg: The definition for "NonEmpty" lists is
05:12:53 <Iceland_jack>     data NonEmpty a = a :| [a]
05:12:56 <rgrinberg> Iceland_jack: nice. I thought [] was hard coded in the compiler somewhere
05:13:00 <Iceland_jack> It is
05:13:05 <bennofs> maerwald: nixpkgs used to take that approach (just take the latest of everything on Hackage and hope the package cabal files work! yay) but switched to Stackage as it was too much effort to do this for every single package. 
05:13:55 <maerwald> bennofs: which is why packaging everything simply does not make sense for haskell
05:14:09 <bennofs> maerwald: what would you package then?
05:14:20 <maerwald> the haskell-platform
05:14:32 <bennofs> but haskell platform is not enough for most applications
05:14:39 <maerwald> yes, use cabal
05:14:53 <bennofs> so you might as well just not package any haskell packages at all
05:14:59 <bennofs> just ghc and cabal-install
05:15:03 <maerwald> yes
05:15:09 <barrucadu> People like to be able to install programs without needing to compile them
05:15:16 <barrucadu> Not every user is also a developer
05:15:20 <bennofs> of course, you can do that ;) but then you lose precompiled binary packages
05:15:28 <maerwald> barrucadu: well, I use source distros since 10 years, so I don't agree with that
05:15:42 <barrucadu> maerwald: Yet the vast majority of linux users don't
05:15:44 <bennofs> maerwald: you surely agree that using a source distro is a tradeoff though, don't you?
05:15:49 <barrucadu> So there is clearly a large demand for binary packages
05:16:00 <maerwald> bennofs: depends what you want to do
05:16:11 <maerwald> good source distros also have support for binary packages
05:16:54 <bennofs> maerwald: right. but to have binaries, you definitely need to package the thing. so just using cabal install won't work in this case
05:16:59 <maerwald> if you want "small-sized stuff", you'll end up with Alpine or something, since a source distro cannot fit that use case properly
05:17:55 <maerwald> bennofs: well, I wouldn't do it that way, tbh
05:18:01 <bennofs> maerwald: or do you recommend only packaging applications, and venoring haskell deps with each application package?
05:18:10 <maerwald> e.g. I wrote a docker image for darcsden, that's sort of "binary" too
05:18:17 <maerwald> but packaging every single dependency? hell no
05:18:47 <bennofs> maerwald: oh so you recommend just packaging each application independently, using cabal sandbox to vendor the dependencies?
05:18:50 <maerwald> there are lots of ways, but haskell is just a pain to package
05:19:16 <bennofs> maerwald: what languages are *not* a pain to package, TBH?
05:19:18 <maerwald> some people copy binaries elsewhere for deployment
05:19:20 <tdammers> programs written in haskell aren't too bad, but haskell dev stuff is near impossible
05:19:23 <maerwald> bennofs: C
05:19:27 <bennofs> he
05:19:48 <maerwald> bennofs: the problem is the depgraph of the haskell ecosystem
05:19:50 <tdammers> and the only reason C is less painful to package is because most package managers are built around C-isms in the first place
05:19:55 <bennofs> I wonder if that is because of C, or because our package managers were written mostly for C based packages :D
05:20:12 <maerwald> if you take the most 50 common C programs all distros package, the depgraph barely has any cycles or unsolvable constraints
05:20:24 <maerwald> for haskell, it already happens with 5-10 programs
05:20:41 <maerwald> (if you are not sandboxing ofc)
05:21:01 <hpc> to be fair, C programs have no dependency constraints other than "build it and see if it works"
05:21:12 <bennofs> maerwald: ok, so you
05:21:31 <bennofs> maerwald: so you're saying that essentially the only language the can be reasonably well packaged is C?
05:21:35 <maerwald> hpc: that's incorrect mostly, a lot of autotools scripts check versions very specifically and existing functions and symbols
05:21:49 <bennofs> what do you do with all the other languages?
05:21:50 <maerwald> bennofs: depends on the package manager
05:22:10 <bennofs> maerwald: what is a good package manager that can do more than C well?
05:22:11 <maerwald> bennofs: as said, nix can handle that stuff more easily, but with a huge cost of completely breaking FHS
05:22:30 <bennofs> yes, and nix packages each haskell library and nix uses stackage, to come back to the original point :D
05:23:20 <maerwald> Even python is relatively easy to package, although the pip ecosystem is huge. The depgraph of haskell is the worst.
05:23:26 <merijn> maerwald: lol
05:23:36 <merijn> maerwald: python packaging is godawful
05:23:39 <sm> hmm someone should keep a database of working build plans, so packagers don't have to deal with dep graphs
05:23:44 <merijn> Trying getting ANYTHING to work if you don't have root
05:23:44 <bennofs> maerwald: python packages frequently fail at runtime though
05:23:46 <maerwald> merijn: doing that since 5 years, works well
05:24:05 <maerwald> again: you barely have unsolvable constraints there
05:24:10 <bennofs> sm: this idea has been discussed a lot, but I think it is easy to underestimated the number of possible build plans
05:24:28 <merijn> maerwald: If you can enlighten me how to install executables + dependencies user locally you'd dramatically improve my life
05:24:28 <bennofs> sm: and in fact, that is kind of what stackage is: a working build plan for a set of "common" packages
05:24:29 <barrucadu> sm: Perhaps it could be called "stable hackage" or something
05:24:41 <maerwald> merijn: I'm talking distro-level packaging currently
05:24:59 <maerwald> and there python is not that bad
05:25:11 <bennofs> python has the advantage of being interpreted though
05:25:20 <maerwald> I think another reason might be that we have quite some bit-rot on hackage
05:25:23 <sm> "stahackage"
05:25:29 <maerwald> stuff that's barely updated to work with the latest libraries
05:26:27 <maerwald> (the reason for that is that lib developers like to break API a lot)
05:26:51 <maerwald> more than I have seen anywhere, tbh
05:27:24 <bennofs> or more than you've *noticed* anywhere :=)
05:27:39 <maerwald> that's basically what I said
05:28:07 <bennofs> I don't have statistics on this, but I suspect python packages just fail at runtime and thus you only notice them in bug reports, which are not as visible as compile errors. I don't know how frequent that is
05:28:20 <hpc> neither do python devs ;)
05:28:23 <maerwald> bennofs: if you package broken python packages, you will get user bug reports
05:28:32 <maerwald> so I have quite a good figure on how often that happens
05:28:41 <hpc> when i get a runtime error from something python, i just give up
05:28:46 <hpc> it's not worth dealing with it
05:28:52 <merijn> hpc: Word
05:29:09 <maerwald> bennofs: and if someone does that, he's not a good packager anyway
05:29:22 <merijn> hpc: I once tried to fix a mercurial exception where I *knew* (from the exception and input) EXACTLY what went wrong and how to fix it. But couldn't find where that code was
05:30:19 <bennofs> maerwald: I can only tell from nixpkgs perspective that python packaging is a lot more difficult than Haskell packaging there. In fact, I think Haskell has the best packaging support in nixpkgs :)
05:30:21 <hpc> that sounds about right
05:30:52 <maerwald> bennofs: why is it more difficult?
05:30:56 <bennofs> You can package haskell 90% automatically with stackage. Try doing that with python?
05:31:05 <hpc> did it end up being an actual reasonable exception, or was it something really derpy like what i get with mailman?
05:31:09 <bennofs> Just figuring out runtime deps is hard for python
05:31:10 <hpc> foo.set("bar", true)
05:31:17 <hpc> throwing ExceptionBarIsAlreadyTrue
05:31:23 <maerwald> bennofs: that's just because nix lacks tools like cabal2nix for python
05:31:27 <tdammers> python stuff is generally easy by virtue of allowing silent breakage
05:31:28 <maerwald> not really something you can blame python for
05:31:57 <tdammers> basically, as far as dependencies and types and all that goes, python pretty much just says "I trust you", and calls it a day
05:32:00 <bennofs> maerwald: well, it is also because python does not have a "static" dependency specification. To get deps of python packages, you actually need to *run* setup.py
05:32:15 <maerwald> bennofs: depends
05:32:57 <bennofs> maerwald: for haskell, you can just use the all-cabal-files repo that stackage kindly provides for all of hackage and you don't even need to fetch the source code to generate the package specifications
05:33:09 <tdammers> also, I believe the flaw with the Cabal ecosystem is that people tried to combine two things that are good ideas individually: microlibraries, and semantic dependency version ranges
05:33:17 <maerwald> bennofs: https://github.com/docker/compose/blob/master/setup.py#L30
05:33:52 <maerwald> the problem there is just that you can do build systems for python in lots of different ways
05:33:53 <tdammers> so we get a really deep dependency graph, with strict version checks on version ranges; that's kind of a hard problem
05:33:56 <maerwald> while for haskell there is only one
05:34:30 <maerwald> Anyway, I don't have high opinions on mindlessly generating package definitions out of .cabal files. And I know people don't second guess the output.
05:35:02 <maerwald> So yeah, you get kind of working stuff, most of the time. But it's not a proper workflow either.
05:35:09 <tdammers> personally, I'm still a bit sad that ghc never continued down the path where you could instrument ghc like you'd instrument gcc, and leave build systems up to, well, existing build systems
05:35:12 <bennofs> maerwald: you can add overrides to it as well
05:35:28 <maerwald> bennofs: sure, but I know most people don't second guess the output
05:36:07 <bennofs> tdammers: how would instrumentation like that look??
05:36:48 <tdammers> bennofs: idk, makefiles?
05:37:14 <bennofs> tdammers: I mean, what is missing from ghc to do that?
05:37:45 <maerwald> bennofs: an interface like pkg-config files
05:38:10 <bennofs> maerwald: isn't that kind of the same as what ghc-pkg provides?
05:38:28 * hackagebot descrilo 0.1.0.4 - Loads a list of items with fields  https://hackage.haskell.org/package/descrilo-0.1.0.4 (mgmillani)
05:39:36 <maerwald> bennofs: can you make it output the relevant information to pass it on to ghc in order to compile against library XY and the deps?
05:39:59 <maerwald> I mean literally "ghc", not cabal.
05:40:04 <bennofs> maerwald: oh... right, that is a difference. I hadn't thought of that
05:42:03 <buglebudabey> could anyone provide an example of custom a parseError in happy showing line number or the like?
05:43:28 * hackagebot simtreelo 0.1.1.1 - Loader for data organized in a tree  https://hackage.haskell.org/package/simtreelo-0.1.1.1 (mgmillani)
05:43:31 <bennofs> maerwald: I agree that such functionality would be nice to have. I assume you would have to have a flag to tell GHC where to find the interface files for a package + add the package's binaries to the linker command line?
05:44:08 <maerwald> something like that probably
05:44:35 <maerwald> but only having one build system is also an advantage, because tools like cabal2nix work most of the time
05:45:07 <bennofs> maerwald: I mean, you can "fake" it by just building a package database with each package and then passsing --package-db /path/to/dep for each dependency to ghc
05:45:38 <bennofs> maerwald: like when you install a package, you'd register all the deps of the package and the package itself in a new package database
05:45:52 <bennofs> maerwald: then when you want to use it, you just add the package db for this package 
05:46:33 <maerwald> I think allowing more than cabal in haskell would probably cause a huge mess and a lot of pressure on distros, because then they are mandatory again as an abstraction layer.
05:47:12 <bennofs> tbh, I don't like the idea of "distros being mandatory as abstraction layers"
05:47:14 <maerwald> that's one of the key roles of distros anyway: abstract over all build systems
05:47:44 <bennofs> i would rather like to have one tool that I can give any kind of source code tarball and it automatically figures out how to build that source tarball into binaries
05:48:05 <maerwald> bennofs: that's basically what source distros let you do, lol
05:48:06 <bennofs> of course, such a tool would still provide me with the option to override versions of the dependencies
05:48:20 <bennofs> maerwald: well, but I need to manually write package descriptions for each package :/
05:48:27 <maerwald> only if there is none yet
05:48:28 <bennofs> maerwald: and figure out what deps i need
05:48:30 <bennofs> maerwald: etc
05:48:37 <bennofs> maerwald: yes, but *someone* has to write one
05:48:46 <bennofs> maerwald: and they have to be maintained
05:49:25 <bennofs> it is all work, which means that eventually I'll find an application for which I *do* have to write a package because noone has found the time to do it before
05:49:34 <maerwald> It's a dream to have on tool that can manage all. There is no such thing.
05:50:01 <bennofs> well, it works pretty well for Haskell. Why could you not extend this to more languages?
05:50:10 <maerwald> because cabal doesn't fit all languages
05:50:31 <maerwald> there are over 9000 things missing for it to be even remotely useful for C projects
05:50:33 <bennofs> well, it would ofc use the package manager specific to the language of the project
05:50:49 <maerwald> I don't understand what that means.
05:50:49 <danza> bennofs, do you know Nix?
05:51:00 <bennofs> danza: yes, in fact I'm currently writing this on NixOS :)
05:51:29 <maerwald> bennofs: you will always have more than one build system. And as long as you have more than one build system, there will always be a package manager that needs to abstract over them.
05:51:44 <maerwald> everything else is a dream, but unrealistic
05:52:08 <StarsC> how do i fix Bytestring conflicts (having 2 golbal packages) on cabal 1.22?
05:52:12 <bennofs> maerwald: the hypothetical tool would take a source tarball, detect what language that is/which package description that project already has (setup.py, cabal, autotools, whatever) and then try to autodetect most of the dependencies and use the detected tool to build it
05:52:26 <maerwald> bennofs: autodetection is broken and doesn't work
05:52:39 <bennofs> maerwald: of course, it will not work 100% of the time, but it'll save me a lot of "try to build this, oh it fails, add a dep, oh it fails again, etc"
05:52:43 <maerwald> and what you are describing is basically a package manager
05:52:55 <maerwald> except that it writes the definitions for you
05:52:57 <maerwald> and that will go bad
05:52:57 <bennofs> maerwald: no I'm describing a tool to generate package descriptions for a package manager
05:53:04 <maerwald> yes, that's awful
05:53:11 <quchen> Stack isn’t able to upload Hackage docs, is it?
05:53:12 <maerwald> it cannot work
05:53:23 <merijn> quchen: Newest cabal should be able to
05:53:30 <maerwald> autotools/Makefiles etc are too complicated to be handled automatically
05:53:39 <maerwald> there are a thousand ways to write them
05:53:56 <bennofs> maerwald: but at least pkg-config deps could be detected relatively precise I think
05:54:05 <maerwald> bennofs: and what if the program uses dlopen?
05:54:08 <quchen> merijn: Yes, it is. But I find building the docs with Stack easier. Currently, I use Stack to build the docs, pack them up manually, and then upload them with Cabal. :-/
05:54:24 <maerwald> bennofs: and what if the build system doesn't use pkg-config? (there are a lot)
05:54:26 <bennofs> maerwald: that would be a case where the packager has to manually add overrides to specify runtime-only dependencies
05:54:35 <maerwald> nah, that doesn't work
05:54:49 <maerwald> packaging is tedious if you want to do it correctly and it will stay that way
05:55:04 <bennofs> maerwald: I would also probably fall back on existing package descriptions in nixpkgs for c packages, and concentrate on languages with a real dependency specification first
05:55:04 <quchen> merijn: The actual root of my problems is that Hackage does not build the docs on its own.
05:55:18 <maerwald> bennofs: how many are there except haskell? ;)
05:55:46 <maerwald> rust maybe
05:55:54 <maerwald> they have only cargo I think
05:56:00 <bennofs> maerwald: yeah that was what I was planning on next ;D
05:56:16 <maerwald> well, that's like 0.05% of the usual package list of a distro
05:56:27 <bennofs> maerwald: the tool would not be fully automatic, it would only save you from missing all the "obvious" depednencies which is still a timesaver for me
05:56:34 <maerwald> the rest is C, C++, perl and python stuff
05:56:51 <bennofs> maerwald: perl is pretty ok too i think, no? And ocaml and go probably too
05:57:43 <bennofs> oh no was Perl the one where deps are only specified through 'use'?
05:58:04 <bennofs> maerwald: well anyway, of course I do not expect it to find 
05:58:15 <maerwald> bennofs: some source distro CI systems already tell you if you missed dependencies by analizing DT_NEEDED of the binary stuff that is installed. But there are cases where DT_NEEDED is incomplete or just plain wrong. So you still need to do your own research.
05:58:39 <bennofs> maerwald: all dependencies. Still, when I package things for nixpkgs, I often encounter cases of missing dependencies that could have been easily detected by a tool
05:59:06 <maerwald> yes, those are tools that are useful as additional input, but they are simply unreliable to auto-generate stuff
05:59:17 <maerwald> I would forget about that idea quickly.
05:59:22 <bennofs> maerwald: in fact, that is the mechanism that Nix relies on for runtime dependencies. it simply scans for /nix/store/<blah> paths in the output, and uses matches as runtime deps
05:59:52 <bennofs> (so everything in rpath will show up)
06:00:07 <vctr> using pipes, is there a pattern to reference previous yields in the next stream value?
06:00:30 <bennofs> vctr: you mean like: "use the previous N yields to produce the next stream value"?
06:00:47 <vctr> yeah, although I only need the prior yield
06:00:59 <vctr> i think plain old recursion would do it..
06:01:27 <bennofs> vctr: sounds kind of like a fold?
06:01:52 <bennofs> vctr: so the idea is you await, produce something to yield, await again and combine this value with the one from the previous yield, ... right?
06:02:15 <vctr> sortof a fold. yeah that's correct
06:03:25 <bennofs> vctr: http://hackage.haskell.org/package/pipes-4.2.0/docs/Pipes-Prelude.html#v:scan looks kinda like it might be able to do this
06:03:29 * hackagebot boomange 0.1.3.2 - A Bookmarks manager with a HTML generator  https://hackage.haskell.org/package/boomange-0.1.3.2 (mgmillani)
06:03:43 <bennofs> vctr: 'x' would be the value of the previous yield here
06:04:00 <bennofs> vctr: the first func would be the combining function, and the third arg is the func to produce the new yield
06:04:04 <maerwald> bennofs: that sounds fishy, so it ignores dlopen deps?
06:05:05 <bennofs> maerwald: dlopen deps have to be specified manually by packagers, by either patching the package to use absolute dlopen paths (so the appear as strings in the binary), or changing the executable after the build to add the needed shared objects to RPATH
06:05:11 <vctr> i think i will try it with recursion first, then collapse it into a scan if i can get the logic figured out
06:05:37 <vaibhavsagar> ooh, is this an attoparsec question?
06:05:38 <maerwald> bennofs: yeah, looks silly https://git.io/vKa05
06:05:56 <maerwald> too much hackery for my taste
06:05:58 <bennofs> maerwald: it works surprisingly well for most packages
06:06:18 <maerwald> relies too much of underspecified language internals
06:06:38 <maerwald> I remember when in nix all haskell packages broke since GHC changed its behavior
06:06:48 <maerwald> long time ago, but it happened
06:06:54 <vctr> thanks bennofs
06:07:50 <bennofs> maerwald: dlopen is kind of bad from nix ideology anyway, since in nix, you generally don't want to put all dependencies of an application in your environment as well. How can you use two applications that dlopen the same lib, but you want to use different versions of that for both apps?
06:08:39 <bennofs> maerwald: or perhaps you don't want different versions, but just different build configs. that only works if you specify the absolute path to the build you want to use, you cannot rely on the environment for that because both builds of the lib would conflict
06:08:49 <maerwald> when I hit weird problems like that, I already want a proper abstraction (e.g. containerization or full virtualization)
06:10:01 <bennofs> alright, I guess I can understand that POV :)
06:13:43 <vctr> straight porting python to haskell code makes me realize how different i think about problems in haskell
06:13:53 <maerwald> vctr: hah
06:14:15 <vctr> way more lenses and pipes in this code than i'd normally use.
06:14:26 <maerwald> I usually use none of those
06:15:02 <maerwald> but I never ported python to haskell, just C to haskell
06:15:18 <maerwald> and there it was 500 LOC parser code shrinked to 10 LOC xD
06:15:42 <maerwald> (however, wasn't as fast)
06:15:42 <vctr> maerwald i'm finding you have to do intermediate-ish haskell to do a straight port of beginner-ish python. after i write this i'm going to refactor though
06:16:18 <vctr> in general i've been using pipes a lot lately to exploit their compositionality, even in place of basic stuff like folds
06:16:21 <maerwald> you can probably get away with a lot of IO and ST
06:16:28 <maerwald> don't see the need for lenses or pipes there
06:16:40 <Gurkenglas> Why isn't scanl defined on all Traversables?
06:16:40 <vctr> dumb stuff like having a progress bar is a breeze with pipes
06:17:29 <vctr> yeah part of the difficulty is i'm not comfortable with ST yet
06:18:03 <vctr> i'm probably using lens/pipes and recursion where i could be using ST
06:18:11 <ARM9> http://ideone.com/aDA5gl any idea why it's mixing up the fields all willy nilly? line 45 and 47 should guarantee it only ever modifies r2
06:18:55 <maerwald> vctr: or MonadRef or something
06:19:58 <vctr> what's MonadRef for?
06:21:00 <maerwald> @hackage ref-fd
06:21:00 <lambdabot> http://hackage.haskell.org/package/ref-fd
06:21:14 <maerwald> "allowing one to write code that can operate in either the ST monad or the IO monad"
06:21:53 <vctr> so obviating lifts? 
06:22:33 <maerwald> here's a popular example https://augustss.blogspot.de/2007/08/quicksort-in-haskell-quicksort-is.html
06:22:36 <vctr> it's also interesting to see this. even though i'm doing an almost a literal port, haskell still forces me to pull out the functional core from the imperative mishmash of this algorithm
06:23:05 <maerwald> many people argue python is more suitable for algorithm (competitions)
06:23:09 <tsahyt> does anyone here have experience with writing high performance code using fgl?
06:23:51 <Clint> i have experience writing low performance code using fgl
06:24:11 <tsahyt> well I now share that experience too
06:24:29 <tsahyt> my code spends most of its time in insEdges and delEdges and I was wondering how to speed this up
06:24:35 <fr33domlover> tsahyt, did you try the graph monad etc.?
06:24:37 <tsahyt> I suppose I could always just write my own Graph and DynGraph instances
06:24:43 <fr33domlover> some of the functions in FGL can be optimized
06:24:50 <fr33domlover> based on specific use case
06:24:56 <tsahyt> fr33domlover: no because GraphM doesn't have any of the query functions
06:24:59 <tsahyt> i.e. dfs
06:25:07 <tsahyt> and they're really the reason why I use fgl in the first place
06:25:14 <fr33domlover> ah I see
06:25:45 <fr33domlover> I use FGL a lot, didn't benchmark so far, but I do notice obvious cases where optimization is possible in the implementation
06:25:56 <fr33domlover> if you hunt the bottlenecks etc.
06:26:16 <vctr> maerwald i think if you're really good you can do it. but there's a short-term disadvantage to impeding certain sorts of expression in a language
06:26:30 <tsahyt> well the algorithm that I'm implementing initially builds a graph, then searches for cuts in that graph, changes parts of it, and iterates until no suitable cut can be found
06:26:43 <maerwald> vctr: yeah, python doesn't impose so many constraints on you. It also allows you to do things wrong way easier.
06:26:45 <vctr> it's not that haskell is bad, it's a cultural problem of algorithms being expressed imperatively
06:26:52 <tsahyt> using delEdges and insEdges to modify the graph was the first thing I could think of provided the fgl functions. maybe there's a better way to do it?
06:26:54 <maerwald> vctr: that too
06:27:32 <maerwald> vctr: but as the link about quicksort I just gave says... it's not just about "expression", it's whether the algorithm itself might be due to it's nature imperative
06:27:41 <tsahyt> the changing of the graph is a major bottleneck right now (about 60% of execution time)
06:27:53 <maerwald> so if you express it functionally, it might just be a wrong implementation
06:27:57 <tsahyt> rebuilding the whole graph is obviously even slower
06:27:58 <vctr> i'm working on some MCMC code which is quite imperative in its high level description
06:28:15 <fr33domlover> tsahyt, you could try to keep some edge map while running the loop
06:28:19 <vctr> i guess it somewhat depends on how you define the algorithm though
06:28:27 <fr33domlover> and implement alternative insEdges and delEdges that use it
06:28:30 * hackagebot ghc-typelits-natnormalise 0.4.3 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.4.3 (ChristiaanBaaij)
06:28:43 <vctr> maybe that's true of quicksort
06:28:48 <fr33domlover> to reduce the number of IntMap interactions
06:28:49 <Gurkenglas> Why isn't Control.Monad.Random seen as safe?
06:28:54 <Gurkenglas> (by lambdabot)
06:29:14 <vctr> but i think often an algorithm is described imperatively just because that's the culture, not because it intrinsically is
06:29:16 <tsahyt> fr33domlover: but that edge map would be independent from the graph and again I'd lose the ability to use the dfs implementation from fgl, right?
06:29:33 <fr33domlover> tsahyt, I mean in parallel to the FGL graph
06:29:49 <fr33domlover> it's just an idea though, need to think about it further :P
06:29:55 <tsahyt> I think I don't quite understand what you mean
06:30:23 <fr33domlover> tsahyt, check how insEdges and delEdges work. They do lookups in the particia tree / IntMap and then do modifications
06:30:29 <tsahyt> yes
06:30:36 <fr33domlover> Try to figure out how you could reduce those, if possible
06:30:53 <tsahyt> on a related note I'm surprised that they're that slow considering that it's just an IntMap underneath which is usually very fast
06:30:53 <fr33domlover> I meant maybe some sort of cache to run with would avoid some lookups or make them faster
06:30:55 <maerwald> vctr: well, when I was looking into computational geometry algorithms I thought about how to make them more "functional". It was always incredibly hard except for a few. I think most of them are really intrinsically imperative.
06:31:12 <fr33domlover> tsahyt, maybe it's just the rest of your code being simple
06:31:23 <fr33domlover> and then FGL simply happens to take a lot of the execution time
06:31:30 <maerwald> vctr: sure, you can come up with an alternative algorithm, but then it's not the same anymore
06:32:06 <tsahyt> fr33domlover: I benchmarked those functions using criterion and they take about 30µs each. that's massive for just changing an edge in a graph. besides, the code runs about 1000x slower than the equivalent C++ implementation right now
06:32:19 <maerwald> sometimes, even the data structure is already "imperative"
06:32:21 <fr33domlover> tsahyt, for example, IntMap is iirc good at set operations
06:32:39 <fr33domlover> and insEdges and delEdges iirc just loop through the list of edges
06:32:53 <fr33domlover> what if instead, you did the whole multi-del or multi-ins in one gp
06:32:56 <fr33domlover> *go
06:33:06 <fr33domlover> using IntMap's union or difference functions
06:33:07 <fr33domlover> just an idea
06:33:11 <tsahyt> according to criterion, insEdges and delEdges actually perform better than just n times insEdge/delEdge.
06:33:19 <tsahyt> but yes, the union and difference functions would be a good starting point
06:34:48 <vctr> maerwald what do you think is the solution? monadic fallbacks + smart compiler optimizations?
06:35:08 <vctr> btw i came across this recently - have you seen it?
06:35:08 <maerwald> vctr: inventing new algorithms
06:35:09 <vctr> https://groups.csail.mit.edu/mac/users/gjs/6946/calculus-indexed.pdf
06:35:34 <maerwald> vctr: but the point is... expressing functional algorithms in python isn't really hard either. So you get easy imperative and easy functional expressivity.
06:35:41 <maerwald> Both of them not particularly elegant, but it works
06:36:17 <vctr> the unfortunate thing is inventing new algorithms takes time. i'm trying to get haskell used now =/
06:37:10 <Gurkenglas> To convince your bosses to let you use Haskell?
06:37:57 <maerwald> low bus factor, not good
06:38:12 <vctr> Gurkenglas to use it myself first
06:38:26 <tdammers> maerwald: matter of priorities
06:38:31 * hackagebot hw-bits 0.0.0.7 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.0.0.7 (haskellworks)
06:38:34 <vctr> i already have leeway to use whatever (data scientists have more flexibility like that)
06:38:43 <tdammers> the bus factor of a Python project is just less visible
06:38:44 <maerwald> tdammers: better pay the guy very well who wrote that cryptic haskell code ;)
06:38:59 <maerwald> full of lenses and pipes even!
06:39:12 <tdammers> maerwald: better pay the guy very well who actually understands the convoluted Python codebase with all its weird undocumented edge cases
06:39:16 <vctr> i've also gotten a project funded for external development which i'm hoping to OSS.
06:39:23 <maerwald> tdammers: you find enough python devs for that
06:39:34 <tdammers> yeah, but there's still a huge bus factor there
06:39:45 <maerwald> huge bus factor is good
06:40:00 <tdammers> depends on the definition
06:40:04 <vctr> i haven't gotten uptake for a larger internal dev efforts yet
06:40:09 <maerwald> tdammers: https://en.wikipedia.org/wiki/Bus_factor
06:40:11 <tdammers> and you know what I mean
06:40:13 <vctr> TBH i think haskell devs are easier to replace than convoluted R/python programmers
06:40:39 <vctr> the type system goes a long way to a built in expression of intent 
06:40:46 <maerwald> vctr: uhm...
06:41:05 <vctr> there's a reasonable pool of deep talent where i'm at too
06:41:33 <maerwald> haskell has so many concepts and libraries and ways to do one thing, that you are lucky if you find someone who's familiar with the specific approach that was taken in the haskell codebase
06:41:44 <maerwald> oh, that guy didn't use mtl, but freer? ouch, how does that work
06:41:58 <tsahyt> fr33domlover: Looks like fgl makes it impossible to write a combining function, since the Gr constructor isn't exported
06:42:12 <vctr> maerwald i'm sincere here. if i look at the average R/python programmer's spaghetti code ..
06:42:15 <maerwald> so you are off reading another paper here
06:42:20 <tdammers> but haskell is also rigid and structured enough for any given haskeller to figure things out in finite time, or at least it's easy to write code for that goal
06:42:21 <maerwald> just to understand the codebase
06:42:26 <hpc> maerwald: that's not a very big hurdle when you have actual code for them to look at and tweak to get familiar with it
06:42:27 <maerwald> that's not going to happen to you in python haha
06:42:34 <tdammers> no
06:42:36 <maerwald> having to read papers :P
06:43:05 <tdammers> instead, in python, what happens is you have to do detective work on the code itself, and make wild guesses all the time whether a particular behavior is intentional or not
06:43:13 <vctr> also codebases are inherently more modular
06:43:17 <maerwald> I think haskell is an incredibly bad language choice if you only have one or two developers that can do it. You need a company that's actually dedicated to it.
06:43:35 <hpc> any language is bad if you only have one or two developers that can do it
06:43:39 <tdammers> haskell is a great language for companies willing to invest in code quality
06:43:40 <maerwald> hpc: no
06:43:57 <tdammers> most companies aren't though, not beyond low-hanging fruit and lip service anyway
06:44:21 <fr33domlover> tsahyt, if performance is critical, perhaps maintain a modified copy of fgl? also there's another graph library, that's based on HashMap
06:44:22 <maerwald> hpc: I'm working at a 2 ppl company that writes shitty javascript code. We could replace ourselves easily with one of the other 9000 javascript developers that are looking for jobs in this city 
06:44:39 <tdammers> maerwald: then why don't you?
06:44:55 <maerwald> tdammers: because there are no haskell jobs?
06:44:56 <tsahyt> fr33domlover: I think at this point it'd be easiest to write my own Graph/DynGraph instance
06:45:13 <hpc> why did you pick javascript for a 2-person company?
06:45:15 <tsahyt> using some fast adjacency list representation underneath, vectors possibly
06:45:15 <tdammers> maerwald: you could have them do your work, and spend the day consuming drinks with little umbrellas by the poolside
06:45:27 <tsahyt> both classes are actually rather small, it might be feasible
06:45:37 <yyyyy> maerwald: you can also turn your company into a compile-to-javascript company using GHCJS, purescript or elm, no?
06:45:40 <Gurkenglas> tdammers, where would he buy the drinks if he has to pay the devs
06:45:42 <tsahyt> the monadic graphs of fgl aren't much help either because they're static graphs
06:45:46 <maerwald> tdammers: I'm already paid for doing nothing, practically, since javascript is so easy
06:45:53 <tdammers> Gurkenglas: the remaining 50% of the salary
06:46:00 <yyyyy> i work in a 5k people company and managed to steer my department towards haskell and elm.
06:46:08 <tdammers> maerwald: I find javascript quite difficult, compared to haskell
06:46:14 <tdammers> maerwald: easier than PHP, but not a lot
06:46:27 <fr33domlover> tsahyt, go for it, if it gives you enough flexibility. Note that there are rules in the PatriciaTree module so use them etc. to avoid losing the advantage of having them)
06:46:44 <hpc> php the language is easier than javascript the language
06:46:46 <maerwald> tdammers: when I write haskell, I want write good haskell. Which means I spend more and more time optimizing and doing stuff abstract and blah. With javascript, you don't have that problem. And that's good.
06:46:46 <Gurkenglas> tdammers, that's what the guy who outsorced to him is doing, there's only one 50% left :P
06:46:47 <fr33domlover> copy the parts you don't need to change etc. from FGL
06:46:49 <hpc> php the ecosystem is horrendous
06:47:01 <hpc> if you can find yourself writing 100% fresh php code, you might almost not go crazy
06:47:04 <tdammers> php the language is not easier
06:47:12 <tsahyt> fr33domlover: yes I saw that. I just hope that vector fusion does enough magic to prevent me from having to do things manually in ST
06:47:17 <maerwald> yyyyy: no, bad bus factor, again
06:47:19 <hpc> javascript has baffling crap like optional semicolons and "this" baked right into the language
06:47:41 <tdammers> maerwald: I *always* want to have proper abstractions, it's how I get any work done at all
06:47:47 <hpc> what does "this" equal? who knows, depends on how you got there
06:47:54 <hpc> maybe there's a .bind somewhere
06:47:56 <maerwald> tdammers: you don't write a lot of java do you? :P
06:48:04 <tdammers> maerwald: if I can avoid it, ...
06:48:14 <fr33domlover> tsahyt, also in the worst case, if performance is critical and Haskell can't match C/C++, do that part in C/C++...
06:48:17 <maerwald> that "I want to have proper abstraction" should really die out after doing a considerable amount of java :P
06:48:28 <maerwald> the more you want to abstract, the uglier it gets
06:48:35 <tdammers> maerwald: same for PHP, only worse
06:48:40 <vctr> i'm @ megacorp and steering things towards haskell one project at a time.
06:48:40 <tsahyt> fr33domlover: I'm using Haskell specifically to *avoid* C++. the library I'm writing is actually a plugin for a solver written in C++
06:49:03 <tsahyt> I can live with being 10x slower per call than a C version, but not with 1000x
06:49:14 <vctr> C++ is getting better. still lots of warts..
06:49:27 <hpc> well
06:49:29 <maerwald> C++ is not a designed language
06:49:33 <tsahyt> vctr: I'll give it another 50 years or so
06:49:33 <maerwald> it just grows
06:49:38 <hpc> C++ is getting bigger, and the new parts are mostly better than the old parts
06:49:42 <hpc> it's not exactly improving ;)
06:49:43 <maerwald> unfortunately, the same is happening to haskell (GHC)
06:49:45 <fr33domlover> tsahyt, ah I see. Good luck, and report results :)
06:49:52 <bennofs> I do not think you can improve C++ by evolving it. The problem is it does only get more complex, not less
06:50:02 <maerwald> bennofs: yeah, GHC does too ;)
06:50:04 <fr33domlover> I'm using FGL in a web app, but too early to do benchmarks
06:50:17 <fr33domlover> I'm using recursive SQL queries too though
06:50:33 <fr33domlover> so the heavy data stuff is the DB's problem
06:50:35 <hpc> i have a feeling once DependentHaskell happens a lot of other stuff is going to get reduced to that
06:50:44 <hpc> and ghc haskell will trim down quite a bit
06:50:53 <vctr> is any language "designed"?
06:50:53 <tsahyt> fr33domlover: actually working on the graph is very fast actually. as long as you don't have to change it a lot, fgl seems to perform well
06:50:57 <maerwald> vctr: yes
06:51:21 <vctr> such as?
06:51:23 <hpc> standard haskell hasn't grown much at all
06:51:36 <bennofs> but noone uses standard haskell...
06:51:37 <vctr> well that's by definition
06:51:41 <maerwald> vctr: evolution happens when stuff gets added to the compiler gradually without it actually being considered in the greater context and adding it to the language spec. Or just say "no, it doesn't fit into the language, make a new report".
06:51:48 <vctr> you could say that C++03 hasn't grown, by definition
06:52:03 <maerwald> vctr: and that is happening in GHC too, stuff just gets added
06:52:22 <vctr> i think it's inevitable beyond a certain point
06:52:27 <maerwald> I think it is
06:52:32 <bennofs> maerwald: well, in C++ the things are added to the language spec. 
06:52:39 <vctr> and the committees do spend a lot of effort thinking about what happens to the broader language, it's just hard to do
06:52:45 <vctr> beyond a certain point of complexity.
06:52:53 <maerwald> bennofs: yeah, but they don't look at the big picture
06:52:58 <Jinxit> maerwald: you think C++ doesn't have enough of a review process?
06:53:04 <tdammers> there are quite some benefits to evolution there
06:53:11 <tdammers> but there's a balance to be struck
06:53:15 <vctr> i don't think that's fair. they try. it's just hard when the language spec is 1000 pages
06:53:19 <puregreen> vctr: Wolfram Mathematica is probably designed/controlled/uninfluenced-by-outsiders to a bigger extent than lots of other languages
06:53:20 <vctr> er.. thousands of pages
06:53:35 <vctr> puregreen i think it's a bit of a continuum
06:53:39 <puregreen> well sure
06:53:43 <bennofs> well, they need to keep backwards compat which is the main problem i beliebe
06:53:45 <vctr> you could say dictator languages like python and ruby
06:53:45 <maerwald> C++ is far over the point where it could be split in 4 different languages. As a whole, it's just a huge inconsistent mess with hundreds of gotchas you gotta learn.
06:53:46 <vctr> are designed
06:53:55 <tdammers> and at least C++ and GHC have some guiding unifying principles, whether you agree with them is another question though
06:53:56 <vctr> but really they are also iterative, just with an n = 1 committee
06:54:06 <Jinxit> maerwald: what is the point of splitting it?
06:54:19 <maerwald> Jinxit: I think people should be less afraid of letting a language die.
06:54:27 <vctr> rust is practically that i think
06:54:32 <maerwald> Say... ok, we have this new idea, but does it really make sense to add to THIS language?
06:54:37 <vctr> C++ the good parts + some haskell ish things
06:54:46 <tsahyt> vctr: more like C the good parts imo
06:54:52 <maerwald> vctr: rust doesn't even have a language spec last I checked, lol
06:54:54 <puregreen> I think there's an additional difference between “designed by one person” and “designed by one person but under the influence of millions of users and companies constantly demanding various things”, tho
06:54:55 <maerwald> so it's even worse
06:55:06 <Jinxit> yes sure, drop all the tooling and stuff built up over the years - so we can make a certain subset separate for no other reason than making it separate
06:55:16 <bennofs> maerwald: rust has as a lanugage reference, which is kind of like a spec 
06:55:22 <Jinxit> we could even use the same syntax! but remember that it's not the same language
06:55:27 <tsahyt> maerwald: to be fair, rust is still a very young language
06:55:38 <hpc> isn't that how C++ happened in the first place?
06:55:40 <merijn> tsahyt: You start with a spec first, implementation later >.>
06:55:44 <maerwald> bennofs: not really the same
06:55:57 <tsahyt> merijn: yes I agree, but I still think rust is going in roughly the right direction
06:56:15 <Ke> ^^
06:56:18 <Jinxit> maerwald: use a subset of c++ that you agree with, call it c++maer, problem solved
06:56:38 <maerwald> Jinxit: it would basically be D, lol.
06:56:52 <bennofs> maerwald: https://doc.rust-lang.org/reference.html looks pretty much like a spec to me, despite being called reference
06:56:55 <rydgel> Rust is promising, I just sometimes have a hard time with the borrow checker. I find myself caught in the borrow/mut hell. But that's maybe because I'm biased with my C++ experience.
06:57:01 <maerwald> Jinxit: but the D compilers are crap, so I stopped trying
06:57:11 <Jinxit> just because I can write everything in Haskell in IO doesn't mean that's the way to do it
06:57:19 <Jinxit> just like new and delete in c++
06:57:32 <Ke> I find it encouraging that there are so many haskellers interested in Rust
06:57:48 <tsahyt> Rust is also one of very few imperative languages with a type system that isn't useless afaik
06:57:53 <Ke> yes
06:58:15 <liste> I wonder what Haskellers think of Ada/SPARK
06:58:17 <maerwald> yes, I like rust too, but I wouldn't even remotely use it in production
06:58:24 <bennofs> Ke: heh it is quite fun to join #rust and notice how many nicks you know already :D
06:58:31 <Ke> yes
06:58:49 <tsahyt> maerwald: I'm waiting for it to mature and hope that it can replace C as the language that I call via FFI
06:59:36 <Ke> tsahyt: though C interface is the only one that allows for shared libs, abi stability and most other so benefits, right?
06:59:56 <Ke> implementation internally can of course be rusty
07:00:11 <tsahyt> Ke: well as long as the rust compiler can create something that corresponds to the interface, I can use it via FFI
07:00:24 <tsahyt> technically I can also use a haskell library via FFI by exporting the relevant things
07:00:29 <tsahyt> there's just no reason at all to do that
07:00:31 <maerwald> also, I don't like the absence of exceptions in rust
07:01:03 <maerwald> you get an error propagated through a huge monadic stack and need to handle it everywhere without really knowing what failed where
07:01:03 <hpc> exceptions are invisible gotos, i like almost any language that doesn't have them
07:01:09 <Ke> maerwald: exceptions often seem to break static typing aesthetics
07:01:19 <vctr> g2g
07:01:23 <maerwald> Ke: that depends how you implement them
07:01:26 <maerwald> in haskell, they suck
07:01:29 <Ke> yes
07:01:45 <Ke> I hear java has exceptions visible in function signatures
07:01:51 <Ke> or some other language
07:01:59 <maerwald> yes, java is actually pretty good at that
07:01:59 <hpc> Ke: java does, but only some exceptions
07:02:03 <tdammers> Ke: checked exceptions, yes
07:02:05 <hpc> foo(...) throws FooException
07:02:11 <tdammers> Ke: one of the few things that aren't shit in Java
07:02:12 <maerwald> the problem is, it also allows uncatched exceptions
07:02:34 <hpc> usually what ends up happening is people write empty catch blocks
07:02:41 <hpc> or they rethrow the exception as something unchecked
07:02:44 <maerwald> exceptions are a good way to say "ok, this might fail somewhere, but I don't want to deal with the failure in the _whole_ call stack, just at one point"
07:02:47 <maerwald> which makes sense for IO
07:03:05 <hpc> but the idea itself is one i wish caught on years before
07:03:06 <maerwald> otherwise it's just ugly Either wrappery without actually knowing what you are doing where
07:03:09 <tdammers> hpc: that is the downside indeed, but the problem there is people not wanting the benefits their language is offering them
07:03:42 <tdammers> maerwald: I believe if you use them appropriately, namely to barf loudly when something fails unexpectedly, exceptions aren't a bad thing at all
07:03:52 <maerwald> yes, I love them
07:03:57 <maerwald> when they are properly implemented
07:04:00 <tdammers> maerwald: you do have to resist the temptation to use them for actual control flow though
07:04:17 <hpc> tdammers: python is lousy with control flow exceptions :(
07:04:18 <tdammers> maerwald: nonsense like `raise HttpNotFound()` to abort a request with a 404, for example
07:04:19 <koala_man> if Java didn't have unchecked exceptions, how would division by zero be handled?
07:04:43 <tdammers> koala_man: why does division by zero have to be unchecked?
07:04:57 <tdammers> koala_man: only reason I can think of is "legacy code would break"
07:05:10 <hpc> obviously what you do is give java dependent types
07:05:14 <maerwald> e.g. I wrote a filemanager in haskell... and the exceptions caused by the low-level operations like copy travel a huge call stack through abstraction and even GUI code... but I really only care about them somewhere in the end, where I have to tell the user "dude, that didn't work". Having Either/Maybe along that call stack would be really annoying
07:05:14 <koala_man> it doesn't, I'm just asking how you'd want to deal with it in practice 
07:05:26 <hpc> then encode the type of (/) so it only throws if the divisor has 0 in its domain
07:05:36 <hpc> and then you can use assertions to eliminate it
07:06:06 <tsahyt> Either/Maybe shine in pure code, not necessarily in IO code
07:06:10 <bennofs> tdammers: I really have problems separating "control flow errors" from "exceptional errors" though
07:06:27 <maerwald> tsahyt: even there I rather use MonadThrow
07:06:59 <tdammers> bennofs: "this should never happen" vs. "under this particular condition, ..."
07:07:36 <maerwald> the sad part is, GHC doesn't know anything whether exceptions are handled or not
07:07:56 <tdammers> well, that's probably because exceptions aren't meant for that use case
07:08:04 <maerwald> I doubt it
07:08:12 <maerwald> it's probably just hard to implement
07:08:15 <bennofs> tdammers: "this should never happen" is quite rare in library code though. Perhaps the "this should never happen" is because the application using the library got invalid user input?
07:08:18 <tsahyt> maerwald: I prefer not putting everything into a monad just because something can fail somewhere
07:08:34 <tdammers> bennofs: invalid user input is not an exceptional condition IMO
07:08:47 <maerwald> tsahyt: it gives the caller control if he wants it to be Maybe, Either or an exception inside IO
07:08:51 <maerwald> which is far more appropriate
07:09:16 <bennofs> tdammers: well, but how do you know if your function argument comes from user input or not?
07:09:20 <tsahyt> ok on second thought this doesn't make sense since both Maybe and Either are monads. I retract my comment.
07:10:04 <maerwald> besides, I find Maybe a terrible choice for error handling anyway (even if there is only one way a function can fail)
07:11:07 <tsahyt> how so?
07:11:14 <tdammers> bennofs: you don't. You use the type system to make sure your inputs are always within valid range, and validate before calling the function with user input
07:11:24 <maerwald> tsahyt: because it doesn't give any useful info on Nothing
07:11:54 <tdammers> the function takes a specific type from your problem domain, which forces callers to deal with erroneous input
07:12:00 <maerwald> on indexing something, you might actually want to encode information into the error like, what index did you try to reach, how long was the list? and so on
07:12:02 <tsahyt> maerwald: I use Maybe when I have a function that is conceptually partial. Nothing conveys that it's undefined for those parameters. That's how I always looked at it anyhow
07:12:05 <maerwald> Nothing is just utter crap for that
07:12:22 <maerwald> MonadThrow gives you all that
07:12:30 <tdammers> then when you write the caller, you are most likely in a situation where error handling is available anyway (IO, or a custom application monad stack, or whatever)
07:12:30 <maerwald> and if you don't care about the error, you can just convert it to Maybe
07:12:35 <bennofs> tdammers: that is quite impratical. For example, how would you deal with "index out of range" for vector index operations? Is that an exception or an error?
07:12:36 <maerwald> just by type annotation!
07:13:00 <tdammers> bennofs: depends on the situation
07:13:12 <bennofs> tdammers: well I am writing the library. I don't know the situation
07:13:29 <maerwald> tsahyt: e.g. https://git.io/vKaoX the result type is MonadThrow, but in the doctest I only care about Just x/Nothing, so type annotation is enough
07:13:36 <tdammers> bennofs: ah, well... in that case, I'd go with Maybe
07:14:05 <tdammers> not because Nothing is an appropriate error value (it's not), but because it makes sense to say "if you ask me for the object at index i, you may or may not get a value from me"
07:14:14 <tdammers> which is *exactly* what Maybe symbolizes
07:14:28 <tsahyt> maerwald: I see. I haven't looked at MonadThrow much so far, but it seems very useful.
07:14:49 <bennofs> tdammers: I feel like this is the sitation that comes up mostly in library code, there are very few cases where you really have a place for exceptions under your definition in library code
07:14:54 <tdammers> asking for something outside the existing range is not an exceptional condition; it's a perfectly normal use case, and the correct answer to "what's at position n+1" is "nothing"
07:14:58 <tsahyt> So if I understand this correctly the idea is to throw whatever information you want at the site of the "exception" and have the caller decide via the type system how much he receives?
07:15:02 <tdammers> true
07:15:18 <tdammers> exceptions from library code are often unnecessary
07:15:44 <maerwald> tsahyt: yes, MonadThrow allows that. Directly using Maybe is just bad style imo.
07:15:52 <bennofs> tdammers: in fact, you could argue that under your definition, library code should *never* throw exceptions if you only use public functions
07:16:09 <tsahyt> maerwald: well it's all over base
07:16:11 <bennofs> and I kind of agree with that
07:18:09 <maerwald> bennofs: you are saying if you implement "cp -R" in haskell you don't want to pass the low-level posfix failures as exceptions, but want to wrap it in Either?
07:18:31 <maerwald> that's like taking the decision from the caller
07:18:36 <maerwald> he can already wrap it in either if he wants
07:19:14 <bennofs> maerwald: i would use MonadThrow probably
07:19:30 <maerwald> bennofs: in IO code?
07:20:12 <bennofs> oh, MonadThrow does not encode what types of exceptions it allows to be thrown :(
07:20:19 <bennofs> I thought it was like MonadError
07:20:32 <EvanR> too many error monads
07:20:41 <EvanR> the error monads are too damn many
07:20:45 <RyanGlScott> Is there a way to have conditional output for a doctest test?
07:20:48 <RyanGlScott> For example, https://github.com/ekmett/lens/blob/96f064ff10e1048a0857b09eb136ac9c116628fa/src/System/FilePath/Lens.hs#L175-L176
07:21:05 <RyanGlScott> On Linux, the output is "path/filename.png", but on Windows, it's "path\\filename.png"
07:21:29 <maerwald> hmm, does CPP work with doctest?
07:21:37 <maerwald> probably, I guess
07:21:48 <RyanGlScott> maerwald: I think I tried that and it freaked out, let me see if I can reproduce it...
07:21:51 <maerwald> heh
07:22:10 <tsahyt> is there a simple way to have an unboxed Vector ([a],[b]) such that the tuple is unboxed but the lists aren't?
07:24:41 <merijn> tsahyt: eh...
07:24:54 <merijn> tsahyt: That doesn't really make sense to me?
07:25:06 <merijn> tsahyt: Well, I suppose it saves you one pointer indirection
07:25:10 <EvanR> tsahyt is trying to remove one layer of indirection
07:25:12 <tsahyt> yes exactly
07:25:15 <maerwald> bennofs: here's an example of heavy exception use in IO, which I think is the cleanest way possible here https://git.io/vKa69
07:25:32 <tsahyt> I guess I'll have to write a custom tuple type or so
07:25:34 <puregreen> hybrid-vectors might be what you want, but I'm not sure
07:25:39 <merijn> tsahyt: "data Pair a b = Pair {-# UNPACK #-}![a] {-# UNPACK #-}![b]" ?
07:25:40 <puregreen> @hackage hybrid-vectors
07:25:40 <lambdabot> http://hackage.haskell.org/package/hybrid-vectors
07:25:56 <bennofs> maerwald: "NoSuchThing if source directory does not exist" I think tdammers would not agree with this exception :)
07:26:02 <tsahyt> merijn: something like that, yes. I'll have to write an Unbox instance too
07:26:11 <maerwald> bennofs: that's what GHC throws
07:26:14 <maerwald> it's left untouched
07:26:27 <maerwald> no messing with low-level exceptions.
07:26:32 <tsahyt> I'll try the naive way first and do the unboxing when necessary I think
07:27:53 <barrucadu> I just saw a comment from pigworker saying Const () is the terminal monad. I thought about it a little, and that makes sense. Is Identity the initial monad?
07:28:01 <maerwald> bennofs: in addition, the exceptions are hspec tested
07:28:02 <RyanGlScott> merijn: No good. Putting an #ifdef in the middle of a Haddock comment makes GHC think the comment is being split in two.
07:28:12 <RyanGlScott> Er sorry, I meant maerwald
07:28:15 <puregreen> tsahyt: hm, no, hybrid-vectors seems to simply split a vector into two (one for fst, one for snd) – that technically unboxes the tuple but might be worse when you consider cache locality or whatever (or it might be not)
07:28:23 <maerwald> RyanGlScott: darn
07:28:25 <barrucadu> I think it is, with the unique morphism ':: forall m a. Identity a -> m a' being 'pure'
07:28:41 <barrucadu> Well, 'pure . runIdentity'
07:31:03 <maerwald> RyanGlScott: well, another way would be to "duplicate" the function in two different files and include it via CPP, then you can have two different doctests
07:31:26 <maerwald> the filepath package does similar things
07:31:33 <maerwald> (except it doesn't use doctest)
07:31:43 <maerwald> (also mind that breaks haddock links, lol)
07:31:53 <RyanGlScott> maerwald: Sure, although I was hoping to avoid guarding the entirety of the comment in an #ifdef.
07:32:08 <maerwald> https://hackage.haskell.org/package/filepath-1.4.1.0/docs/src/System.FilePath.Posix.html#splitExtension
07:32:12 <maerwald> nice source code, isn't it?
07:32:17 <RyanGlScott> :)
07:49:41 <buglebudabey> i'm getting a weird error using alex, it says one of my variables is not in scope on line 137, but my program is only 105 lines
07:50:01 <buglebudabey> and it's not in the .hs file it's saying this, it's in my .x file
07:50:53 <buglebudabey> nevermind, found the problem
07:51:39 <hpc> was it something not in scope on line 137 of your .x file? ;)
07:52:18 * hpc has that sometimes, wondering what an error is for a few minutes before noticing it's telling me exactly what's wrong
07:54:43 <buglebudabey> hpc since i was building with stack, it said the error was on line 137 of the .x file, when really the error was occuring when it was generating the .hs file
07:54:54 <buglebudabey> but i had no .hs that i generated myself
07:55:14 <buglebudabey> the error was really on line 26 of my .x
08:14:05 <buglebudabey> could someone help me with this type error in lex? http://lpaste.net/170376
08:16:03 <buglebudabey> it's odd
08:23:45 <glguy> ?tell buglebudabey Your implementation of alexEOF was wrong, it needs to return a Token instead of a TokenClass
08:23:45 <lambdabot> Consider it noted.
08:24:43 <glguy> buglebudabey: Your implementation of alexEOF was wrong, it needs to return a Token instead of a TokenClass
08:24:49 <buglebudabey> thank you glguy 
08:24:55 * geekosaur had been wondering about that bit googling was suggesting otherwise
08:27:27 <glguy> buglebudabey: Also, you don't appear to be using the features of the monad wrapper in that paste. Are you planning to use them as you add more code?
08:27:54 <buglebudabey> i really just wanted the monad wrapper for error handling
08:28:04 <buglebudabey> to show where the parse error occur
08:28:08 <buglebudabey> occurs*
08:29:41 <glguy> buglebudabey: You don't have to use the monad wrapper for that, you can just add an error case to your lexer at the bottom and emit an error token
08:29:41 <buglebudabey> glguy is what i'm doing correct for that? or is using the monad wrapper too much
08:30:19 <buglebudabey> ah alright, where does it get the line and column number from then?
08:30:56 <glguy> The same place as all the other tokens
08:31:28 <glguy> The last line of your lexer can be: . { mkA TokenError }
08:32:17 <buglebudabey> and does that get the relevant info from AlexPosn or something?
08:32:27 <glguy> And then you can propagate the error up through your parser. The error token won't satisfy your parser and you'll get an unexpected lexical error
08:32:46 <glguy> It gets the error position of the character that didn't match any lexical productions
08:33:01 <buglebudabey> what if what i'd like was a parse error and not a lexical error?
08:33:01 <glguy> just like ";" and "{" provide location information when lexed
08:33:20 <glguy> You can report it however you want, I suppose
08:33:31 <glguy> the point is that it gets folded into the token stream just like EOF
08:34:12 <buglebudabey> what i mean is in happy what can i use to show that at 16:10 there was expected to be a certain token
08:34:44 <glguy> You can use error productions in happy to handle more interesting error cases
08:35:19 <buglebudabey> where can i learn about that? i've never heard of error productions in happy
08:35:20 <glguy> https://github.com/glguy/language-lua/blob/master/src/Language/Lua/Annotated/Parser.y#L154
08:36:05 <glguy> You can read about it in the happy documentation; this is an example of how to use it
08:37:20 <glguy> I tend to avoid Alex's predefined wrappers. I find that the code is clearer without them:
08:37:20 <glguy> https://github.com/glguy/config-value/blob/master/src/Config/Lexer.x
08:37:20 <glguy> https://github.com/glguy/config-value/blob/master/src/Config/LexerUtils.hs
08:37:20 <glguy> https://github.com/glguy/language-lua/blob/master/src/Language/Lua/Annotated/Lexer.x
08:37:46 <glguy> If you're interested you can see what it looks like to avoid the wrappers with those two examples
08:37:55 <buglebudabey> ya, it was getting complicated, all i really want to do is show a location of a parse error
08:38:03 <buglebudabey> thank you for the examples
08:38:21 <glguy> https://github.com/glguy/language-lua/blob/master/src/Language/Lua/Annotated/Parser.y#L289
08:38:32 <glguy> This is how I propagate error locations from a happy parser
08:38:35 * hackagebot monad-logger-prefix 0.1.4 - Add prefixes to your monad-logger output  https://hackage.haskell.org/package/monad-logger-prefix-0.1.4 (parsonsmatt)
08:40:31 <buglebudabey> glguy that function errorP makes sense, but you have the sourcepos already in the token, so where does that happen
08:40:57 <glguy> buglebudabey: The lexer adds the position to the tokens. Your lexer does that, too.
08:41:08 <glguy> data Token = T AlexPosn TokenClass String
08:41:39 <glguy> AlexPosn character-index line-index column-index
08:42:22 <buglebudabey> i can still add the position to the token with a basic wrapper?
08:42:40 <glguy> If you want to use a wrapper you'd use the posn wrapper iirc
08:42:56 <glguy> https://www.haskell.org/alex/doc/html/wrappers.html#id462357
08:43:34 <Gurkenglas> :t zipWith ?f `on` cycle -- Will this apply f finitely or infinitely often?
08:43:35 <lambdabot> (?f::a -> a -> c) => [a] -> [a] -> [c]
08:44:00 <buglebudabey> glguy so i no longer need alexEOF if i'm not longer using the monad wrapper
08:44:22 <glguy> Gurkenglas: zipWith won't be aware of the sharing that cycle is producing
08:44:56 <Gurkenglas> So I have to pull the cycle outside the zipWith, or is there another way?
08:45:17 <glguy> what you said: \x -> cycle (zipWith f x x)
08:45:26 <Zemyla> :t cycle
08:45:27 <lambdabot> [a] -> [a]
08:45:36 <glguy> err, I guess yours has x and y, not two x x
08:46:00 <glguy> You could extend the two lists out to their gcd length
08:46:05 <glguy> and zip those and cycle that
08:46:18 <Gurkenglas> You make a nice case for (.:) to be added as a dual to on
08:49:48 <Gurkenglas> There's actually a 'tail' in front of one of the arguments to make a cellular automaton and I thought I could make it wrap around like that but looks like thatd be quadratic time
08:49:50 <lpaste> glguy pasted “for gurkenglas” at http://lpaste.net/170383
09:08:19 <n1nj4> somebody to help?query me
09:08:29 <cybershadows> bruh
09:14:52 <simg> n1nj4: you're welcome to ask your question !
09:28:37 * hackagebot gitHUD 1.3.2 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/gitHUD-1.3.2 (gbataille)
09:35:24 <ExcaliburZero> Would anyone be willing to give some feedback on a library that I am working on? It is a library for generating default user avatars for websites, similar to the system used by GitHub. Any suggestions on design, documentation, etc. would be very helpful.
09:35:25 <ExcaliburZero> Here is the link to the library's GitHub repo: https://github.com/ExcaliburZero/pixelated-avatar-generator
09:35:28 <ExcaliburZero> Here is the link to the library's package on Hackage: https://hackage.haskell.org/package/pixelated-avatar-generator
09:40:47 <lyxia> ExcaliburZero: looks neat
09:41:07 <ExcaliburZero> lyxia: Thanks!
09:42:48 <oherrala> Agreed. code is easy to read. well done
09:43:28 <codedmart> Still get caught up in this. Is there a way to right this in one line (more compact)?
09:43:30 <codedmart> https://gist.github.com/codedmart/f9ff75c06565837dc42bd76060948bc0
09:44:38 <glguy> codedmart: Not without making a mess
09:45:06 <oherrala> ExcaliburZero: and well commented code
09:45:31 <codedmart> glguy: Oh fair enough, maybe why I had issues :)
09:45:32 <codedmart> Thanks!
09:46:50 <glguy> Would be something like: fmap encodeUtf8 . lookup "token" . parseCookiesText . encodedUtf8 =<< mc
09:47:11 <Cale> That's not too bad
09:47:19 <ExcaliburZero> oherrala: Thanks!
09:48:37 * hackagebot leancheck 0.5.0 - Cholesterol-free property-based testing  https://hackage.haskell.org/package/leancheck-0.5.0 (rudymatela)
09:58:38 * hackagebot fitspec 0.3.0 - refining property sets for testing Haskell programs  https://hackage.haskell.org/package/fitspec-0.3.0 (rudymatela)
10:03:38 * hackagebot Glob 0.7.10 - Globbing library  https://hackage.haskell.org/package/Glob-0.7.10 (MattiNiemenmaa)
10:03:40 * hackagebot list-tries 0.6.3 - Tries and Patricia tries: finite sets and maps for list keys  https://hackage.haskell.org/package/list-tries-0.6.3 (MattiNiemenmaa)
10:09:39 <ironChicken> can i intersperse other top-level definitions with patterns for a single function?
10:11:48 <nmdanny> question regarding HSpec: is there a function for passing a test or failing a test on purpose?
10:12:52 <Sonolin> O
10:13:01 <Gurkenglas> Can we get lambdabot to specialize values of type "(MonadRandom m, Show a) => m a" to IO a and execute them?
10:14:00 <Zemyla> Gurkenglas: It really shouldm't be executing values of type IO a.
10:14:28 <Gurkenglas> Why not, as long as it specialized them from MonadRandom?
10:14:30 <ironChicken> in answer to my own question: it seems not. i'd never noticed that before
10:14:30 <Iceland_jack> Gurkenglas: you can use 'evalRandIO' locally
10:15:09 <Zemyla> I think Gurkenglas may want to use lambdabot as a dicebot :P
10:16:02 <Gurkenglas> :t replicateM 8 $ fmap (ap (++) reverse) . replicateM 4 $ ?uniform " \9608" -- I wanted to replace that guys library ^^
10:16:06 <lambdabot> (Monad m, ?uniform::[Char] -> m a) => m [[a]]
10:16:12 <buglebudabey> if i have many data constructors such as "data Letter = A String | ... | Z string" is there a way i can extract the string without pattern matching on every constructor or doing record syntax for each one?
10:16:55 <nitrix> Does GHC unifies `map (+1) $ map (+1) $ xs` into `map ((+1).(+1)) xs` ?
10:16:55 <Iceland_jack> buglebudabey: 1. Use different data structure, 2. Normal function, 3. Pattern synonym, 4. Prisms
10:17:15 <Iceland_jack>     1. data Tag = A | B | ... | Z
10:17:15 <Iceland_jack>        data Letter = Letter Tag String
10:17:30 <Iceland_jack> this works if all of them have the same shape
10:17:56 <Iceland_jack>     2. getStr :: Letter -> String
10:17:56 <Iceland_jack>        getStr (A str) = str
10:17:56 <Iceland_jack>        getStr (B str) = str
10:17:56 <Iceland_jack> unsatisfactory
10:18:15 <maerwald> nmdanny: did you try "False"?
10:18:17 <Iceland_jack>     3. pattern GetStr str <- (getStr -> str)
10:18:22 <c_wraith> buglebudabey, heh. I have a silly answer. make String a type variable instead, then derive Traversable
10:18:53 <maerwald> nmdanny: it "This test always fails" $ False
10:19:02 <Iceland_jack> c_wraith: That's not a bad idea except you lose the guarantee that you will get a value out
10:19:24 <nmdanny> maerwald : Emm, how does it work? the test operates in a SpecM () monad
10:19:26 <buglebudabey> Iceland_jack going along with your answer i'm getting an error, i'll paste it, one sec
10:19:32 <c_wraith> ok, derive Functor. :P
10:19:43 <nmdanny> and False is a value, I can't return it or do anything with it
10:19:49 <Gurkenglas> c_wraith, Functor is a superclass of Traversable
10:19:55 <maerwald> nmdanny: are you using the 'it' function?
10:19:59 <Gurkenglas> (Also Const a is a Functor.)
10:20:05 <nmdanny> yes
10:20:09 <maerwald> then False works
10:20:29 <nmdanny> but i'm inside a do block
10:20:30 <buglebudabey> Iceland_jack http://lpaste.net/170398 this is the error
10:20:57 <maerwald> nmdanny: still works here
10:20:59 <Iceland_jack> buglebudabey: You don't include the code?æ
10:21:08 <Iceland_jack> just the data 
10:21:16 <nmdanny> both doing False or return False gives me compile errors
10:21:17 <maerwald> it "Blah" $ do if 3 == 3 then True else False
10:21:17 <buglebudabey> the error has the relevant code in it
10:21:20 <buglebudabey> Iceland_jack ^
10:21:38 <buglebudabey> ill give you more, apologies
10:21:54 <Iceland_jack> The more the better!
10:21:54 <nitrix> maerwald: What's that? The Bool monad?
10:22:16 <buglebudabey> Iceland_jack http://lpaste.net/170401, error at bottom
10:22:18 <c_wraith> > do () 
10:22:19 <lambdabot>  ()
10:22:33 <Iceland_jack> I use that all the time
10:22:33 <Iceland_jack>     do let a = "hi"
10:22:33 <Iceland_jack>        a ++ a
10:22:45 <c_wraith> nitrix, desugaring do blocks doesn't add any constraints on its own. 
10:23:04 <nitrix> Oh!?
10:23:16 <c_wraith> nitrix, those come from the operators it desugars into. 
10:23:22 <nitrix> :t do 1 + 1
10:23:23 <lambdabot> Num a => a
10:23:24 <Gurkenglas> do is the type-level fixpoint of (a -> a) -> a
10:23:26 <Gurkenglas> :t do
10:23:27 <lambdabot> Empty 'do' block
10:23:28 <Gurkenglas> :t fix $ do
10:23:29 <lambdabot> Empty 'do' block
10:23:33 <nitrix> That's really cool.
10:23:50 <maerwald> nmdanny: assertFailure ?
10:24:01 <maerwald> https://hackage.haskell.org/package/HUnit-1.3.0.0/docs/Test-HUnit-Lang.html#v:assertFailure
10:24:03 <nitrix> c_wraith: It might be a little confusing as far as protraying the intentions, but still nice.
10:24:31 <nmdanny> hmm seems like this function is in HUnit and not HSpec
10:24:53 <buglebudabey> Iceland_jack i found the problem
10:24:55 <nmdanny> oh I probably need the package 'hspec-expectations'
10:24:59 <buglebudabey> I was applying 'T' twice
10:25:31 <Iceland_jack> Ah
10:25:39 <Iceland_jack> buglebudabey: solved it without help :)
10:25:55 <maerwald> nmdanny: assertFailre works here
10:26:08 <maerwald> sth like http://lpaste.net/170402
10:26:36 <nmdanny> yea seems like assertFailure == expectationFailure, just different aliases
10:27:21 <nmdanny> ok another question, can I share state between different 'it' blocks?
10:27:47 <nmdanny> Like, in one 'it' block I test a function which registers a user in a database, returning me a user key, and in another 'it' block I test a function which deletes that user
10:28:03 <nmdanny> based on the returned user key from the previous i
10:28:05 <nmdanny> it*
10:29:05 <maerwald> nmdanny: I simply use IORefs for that
10:29:17 <nmdanny> or would it be better to simply keep each `it` block atomic?
10:30:24 <nmdanny> though then each function that registers a user, should also delete it (in order to not clutter the test DB), and that seems to me like something that should be a different test.
10:38:39 * hackagebot zip-archive 0.3.0.4 - Library for creating and modifying zip archives.  https://hackage.haskell.org/package/zip-archive-0.3.0.4 (JohnMacFarlane)
10:56:18 <nmdanny> for HSpec, is there a function like expectationFailure but for success?
10:56:31 <maerwald> nmdanny: isn't that just nothing?
10:56:36 <maerwald> if it doesn't fail, it succeeds
10:56:40 <nmdanny> oh, right
10:56:43 <nmdanny> so return () 
10:58:40 * hackagebot bifunctors 5.4 - Bifunctors  https://hackage.haskell.org/package/bifunctors-5.4 (ryanglscott)
10:58:42 * hackagebot deriving-compat 0.3.1 - Backports of GHC deriving extensions  https://hackage.haskell.org/package/deriving-compat-0.3.1 (ryanglscott)
11:00:32 <schell> can i use unsafeCoerce to coerce Double -> Double# safely?
11:00:42 <dolio> No.
11:01:04 <schell> dolio: thanks, so the standard way is to match the D# constructor?
11:01:48 <dolio> That's the right way, yes. unsafeCoerce wouldn't even do the same thing as matching.
11:02:15 <schell> dolio: i just did a naive Hoogle search for Double -> Double#, is all 
11:02:19 <schell> wishful thinking
11:02:39 <johnw> schell: if you did that, you'd have a Double# whose value is that of the pointer to the heap location containing the Double
11:02:55 <dolio> I don't think unsafeCoerce would actually let you have that type, either. Only the more evil unsafeCoerce# would.
11:03:09 <schell> johnw: that makes sense, and that was my intuition though i wanted to make sure
11:03:21 <a6a3uh2> @hoogle Either
11:03:24 <lambdabot> Prelude data Either a b
11:03:24 <lambdabot> Data.Either data Either a b
11:03:24 <lambdabot> Data.Either module Data.Either
11:03:40 * hackagebot invariant 0.4 - Haskell 98 invariant functors  https://hackage.haskell.org/package/invariant-0.4 (ryanglscott)
11:05:10 <dolio> schell: Does hoogle actually report unsafeCoerce for that?
11:05:22 <dolio> Seems like it shouldn't be indexing that.
11:05:44 <schell> kind of, it matches in the sense that it’s `a -> b` 
11:05:59 <schell> https://www.haskell.org/hoogle/?hoogle=Double%20-%3E%20Double%23
11:06:22 <dolio> Wow.
11:06:24 <a6a3uh2> @hoogle Prelude data Either a b
11:06:26 <lambdabot> No results found
11:06:40 <a6a3uh2> @prelude Maybe
11:06:40 <lambdabot> Unknown command, try @list
11:06:42 <pikajude> is there a hackage package that *just* parses IRC messages?
11:06:45 <schell> going the other way works better because there’s a complete match https://www.haskell.org/hoogle/?hoogle=Double%23+-%3E+Double
11:07:00 <schell> unsafeCoerce is still second, tho!
11:07:05 <pikajude> ok, i guess `irc`
11:07:44 <nmdanny> is it possible to use 'if' expressions to check the type of a value, without destructuring the value?
11:08:01 <nmdanny> e.g mbLoginData :: Either ServantErr (Maybe LoginData), 
11:08:43 <nmdanny> so I'd just check if mbLoginData is Right (Just someVal), without accessing someVal
11:09:19 <cocreature> case mbLoginData of Right _ -> 
11:09:44 <cocreature> or rather Right (Just _) 
11:10:27 <nmdanny> yea but I'd like to avoid cases as it makes the code too nested
11:10:55 <cocreature> you can always define a isJustOfRight function, there is nothing builtin for that
11:11:05 <nmdanny> yea I guess I can do that
11:11:27 <nmdanny> or maybe use ExceptT and MaybeT
11:11:52 <nmdanny> is it possible to pattern match on two different values?
11:11:53 <cocreature> lens has a function called “is” that allows you to check if a prism matches
11:11:58 <cocreature> you could use that as well
11:13:12 <cocreature> > is (_Right . _Just) (Right (Just ())
11:13:14 <lambdabot>  <hint>:1:37:
11:13:14 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:13:28 <cocreature> well lambdabot hates me, but that works :)
11:13:36 <cocreature> > is (_Right . _Just) (Right (Just ()))
11:13:38 <lambdabot>      Not in scope: ‘is’
11:13:38 <lambdabot>      Perhaps you meant one of these:
11:13:38 <lambdabot>        ‘id’ (imported from Data.Function),
11:14:26 <nmdanny> is there a built in way to pattern match on two values, something like
11:14:32 <nmdanny>         case invalidLoggedData of Right (Just wtf) && invalidLoggedData2 of Right (Just wtf2)-> expectationFailure "wtf"
11:14:50 <cocreature> nmdanny: match on a tuple
11:15:09 <cocreature> there is nothing builtin for it
11:16:59 <nmdanny> hmm, matching on tuple is good enough then
11:17:22 <dolio> cocreature: It's called `has`.
11:17:39 <nmdanny> whew, my registration/login/auth module seems to pass the tests.
11:18:03 <glguy> ?type Control.Lens.Extras.is
11:18:04 <lambdabot> APrism s t a b -> s -> Bool
11:18:37 <dolio> Oh, it actually has is? Ed told me it was ruled out.
11:18:40 * hackagebot checkers 0.4.5 - Check properties on standard classes and data structures.  https://hackage.haskell.org/package/checkers-0.4.5 (ConalElliott)
11:18:54 <glguy> dolio: It was ruled out from being exported by default from Control.Lens
11:19:01 <cocreature> dolio: I’ve checked before because I wasn’t sure if is exists :)
11:20:28 <nmdanny> just to be sure, it is possible to run a spec within a monad transformer, right?
11:23:17 <pchiusano> question about https://hackage.haskell.org/package/process-1.4.2.0/docs/System-Process.html
11:23:42 <pchiusano> what happens if the process dies?
11:23:42 <pchiusano> are the handles closed?
11:24:01 <pchiusano> by the OS?
11:24:13 <pchiusano> or is it always necessary to call hClose on the process
11:24:25 <pchiusano> er, on the process handles
11:25:21 <yyyyy> pchiusano: on linux the file descriptors will be reclaimed unless the process remains as a zombie.
11:25:38 <yyyyy> though it's a really bad practice to not clean up resources before exiting.
11:25:43 <pchiusano> yyyyy: wdym, "remains as a zombie"
11:25:48 <geekosaur> the cild's side will be closed. the parent's side remain open. read handles will return any remaining unread data, then EOF; write handles will provoke SIGPIPE, or if that is ignored EPIPE (which will throw an exception)
11:26:26 <geekosaur> you must close them yourself in either case
11:26:27 <pchiusano> geekosaur: which is the parent vs child
11:26:52 <geekosaur> the parent is what is using System.Process. the child is the program you run using System.Process
11:27:06 <pchiusano> okay
11:27:14 <yyyyy> pchiusano: once a process exits it (should) signals to its parent the case so the OS can reclaim it. if the parent is not PID 1 and it fails to do cleanup after receiving the signal it will be left dead but unreclaimed — a zombie.
11:27:23 <geekosaur> note that you also have a separate process handle which hClose does not apply to; you will need to correctly close that as well, as that is how you get the exit status of the child
11:27:54 <geekosaur> and the process will remain as a "zombie" (dead process entry that exists only to hold the final exit status and resource usage information)
11:28:24 * yyyyy thinks geekosaur did a way better job to explain it.
11:28:40 <geekosaur> when you close the process handle (not any file handles associated with the process) you can get the exit status; System.Posix,Process has routinmes that also let you get at the resource usage
11:28:49 <pchiusano> geekosaur: okay, would it be better to just check getProcessExitCode
11:29:21 <pchiusano> and then close the Handles if/when that returns something?
11:30:00 <pchiusano> as in, is it safe to assume that getProcessExitCode will return something after the child dies?
11:31:11 <yyyyy> that's the clean way to do it. but you should be aware that if the descriptors were shared by sockets you might need to ensure the other consumers won't be left out.
11:31:21 <geekosaur> getProcessExitCode will produce Nothing if it's still running or (Just exitcode) if it has exited. normally one uses waitForProcess instead, though, which blocks until the process exits. it is expected that you are using multiple threads which can block without affecting the main thread, not trying to manage this stuff yourself
11:31:47 <geekosaur> Handles will be left open, again readable handles may still have unread data in them after the program has exited
11:32:07 <pchiusano> I see
11:32:56 <pchiusano> so basically, calling waitForProcess (in a non-main thread), then read any buffered input from readable handles
11:32:58 <geekosaur> so, writable Handle-s can be closed immediately but you should make sure you have read all data from the readable ones. (and again, one normally hands those to separate threads; they will know the process is gone when they reach end-of-file on the Handle)
11:33:53 <geekosaur> you probably should not try to interleave these in one thread, but read in separate threads and have the main thread waitForProcess (if it must do other things, put that in a separate thread too but do all the process related stuff from that thread)
11:33:56 <joe9> I want to write a haskell client application. I have the API in a swagger data file format. I noticed that the swagger website cannot generate haskell client code. Any suggestions on how I can do that, please?
11:34:17 <pchiusano> okay, last silly question - I write to stdin of the child process, is that right?
11:35:03 <geekosaur> and, be aware that pipes hold only so much; you will deadlock if you wait and then read all data, and the data is larger than fits in the OS's pipe buffer, because the child cannot exit until it can finish writing to the pipe, but the parent won't be reading because it's waiting for the process to exit. this is why reading should be done in a separate thread
11:35:10 <dmj`> joe9: there is swagger code gen for servant
11:35:12 <geekosaur> yes
11:35:37 <nitrix> Hi. Can I get Aeson to encode `data Foo = F` as "F" and not "[]" ?
11:35:48 <pchiusano> geekosaur: understood
11:36:02 <nitrix> When I use a sum type `data Foo = F | G`, then it seems to be consistently doing "F" and "G".
11:36:06 <pchiusano> yeah, I will be spawning a thread to read from the process as fast as possible
11:36:29 <nitrix> I'm worried if I switch from a sum type to a nullary constructor, encoding will break (which it does).
11:36:33 <joe9> dmj`: this one https://github.com/swagger-api/swagger-codegen ?
11:37:17 <nitrix> Any solutions? I've looked at the options unwrapUnaryRecords, allNullaryToStringTag and sumEncoding with no success.
11:37:20 <dmj`> joe9: yea
11:37:31 <joe9> dmj`: Thanks.
11:37:52 <puregreen> nitrix: well, a custom instance should be a pretty easy solution in your case :)
11:37:55 <yyyyy> nitrix: manual instance?
11:38:04 <puregreen> * manual, yeah
11:39:01 <nitrix> I think I'll do that. I'll write my own "preciseGenericToJSON" helper, because so many types that I have needs to behave like this.
11:39:11 <nitrix> It's sad the generic one isn't more robust :(
11:39:53 <yyyyy> `instance ToJSON Foo where toJSON = String "F"` should work, no?
11:40:23 <puregreen> nitrix: first look at https://hackage.haskell.org/package/generic-aeson-0.2.0.8/docs/Generics-Generic-Aeson.html, maybe it does that
11:40:44 <joe9> dmj`: did you use swagger-code-gen? Any experiences to share, please?
11:40:54 <puregreen> (“Enumerations are converted to JSON strings”)
11:41:06 <dmj`> joe9: I've never used it, have only gone from haskell -> swagger, but not that other way
11:41:24 <nmdanny> wtf, why doesn't my HSpec test suite not show any values that I print
11:41:36 <nitrix> Data types with one unlabeled field convert to just that field.
11:41:38 <nitrix> Data types with multiple unlabeled fields become arrays.
11:41:38 <nmdanny> why doesn't it show*
11:41:59 <nitrix> puregreen: Same issue. It does a distinction between single field and mltiple fields data types.
11:42:15 <dmj`> joe9: if you're feeling ambitious, you could make a QuasiQuoter than reads in swagger json, and returns a Q [Dec] for the servant API and all corresponding types
11:42:20 <dmj`> s/than/that
11:42:20 <nitrix> puregreen: So changing `data Foo = F` to `data Foo = F | G` breaks :/
11:43:09 <puregreen> oh well
11:43:19 <joe9> dmj' . the swagger-code-gen seems to be swagger -> haskell servant. I have never used haskell-servant before. So, hopefully, this will not be a big learning curve.
11:43:59 <dmj`> joe9: it's pretty straight forward, there is a #servant channel too if you have questions. IMO servant-client is the simplest of all http clients
11:44:55 <joe9> dmj`: Thanks. That is helpful information. Will check out #servant. Thanks a lot.
11:46:44 <dmj`> joe9: cheers
11:47:19 <yamadapc> nmdanny: I think hspec suppresses stdout; you need to print to stderr with `hPrint stderr` 
11:48:27 <nmdanny> not only that, but even when I put a string as part of 'exceptationFailure', it doesn't show it
11:49:37 <nmdanny> actually it doesn't show it at all, I just noticed
11:50:15 <nmdanny> my assertFailure, does not print
11:53:57 <ongy> is there a way in haskell to get the current codeset? More specifically: I want to find out if my locale is UTF8 or not
11:55:10 <glguy> hGetEncoding will tell you the encoding a Handle is using
11:55:13 <Clint> ongy: https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-IO-Encoding.html#v:getLocaleEncoding
11:56:09 <nmdanny> how do I lift a HSpec spec to a certain monad stack?
11:57:26 <nmdanny> e.g if I have newtype App a = App { runApp :: ReaderT Config (ExceptT ServantErr IO) a }
11:57:26 <nmdanny> and I want to make a SpecM (App ())
11:57:53 <nmdanny> and then provide a config and convert it to Spec?
12:02:32 <maerwald> that's why I hate transformers
12:04:05 <nmdanny> I just don't want to thread around a config type and have to keep lifting my functions to match IO
12:04:45 <dmj`> nmdanny: mtl should lift for you though
12:04:56 <nmdanny> yea I have MTL
12:05:01 <nmdanny> but how do I wire it to work with HSPec?
12:05:28 <nmdanny> basically I have to test a lot of functions with the following signature: (MonadReader Config m,MonadIO m)
12:06:35 <dmj`> nmdanny: for hspec you could just write a helper function, runStack :: Config -> Stack a -> IO a; 
12:07:00 <nmdanny> yea that's exactl what i've done before, but it makes things not very tidy
12:07:22 <nmdanny> i'm wondering if it's possible to just have HSpec with a different base monad
12:08:39 <nmdanny> unfortunately, it looks like runSpecM converts a SpecWith a to a bunch of SpecTrees, which I have no idea what they are
12:08:42 * hackagebot canteven-log 1.0.0.0 - A canteven way of setting up logging for your program.  https://hackage.haskell.org/package/canteven-log-1.0.0.0 (taphu)
12:08:48 <maerwald> good luck walking the monad stack hell
12:15:11 <miscyb> what's the best way to use sftp in haskell? I'd like to be able to pause, cancel, and get download progress in particular
12:18:04 <nmdanny> question, is it possible to unwrap a monad with MTL classes, or must I have a transformer?
12:18:18 <nmdanny> e.g, can I make the following function: liftCommon :: (MonadReader Config m,MonadIO m) => Config -> m a -> IO a
12:18:21 <johnw> you cannon unwrap with MTL
12:18:30 <johnw> the MTL classes give you no knowledge of what the concrete monad actually is
12:19:17 <johnw> not even transformers will let you go from m a -> IO a in any general way
12:20:36 <dmj`> nmdanny: if you newtyped your stack you should be able to unwrap
12:20:36 <dmj`>  
12:20:36 <dmj`>  
12:20:36 <dmj`>  
12:20:38 <dmj`>  
12:20:50 <shapr> dmj`: I'm whitespace sensitive.
12:20:56 <ongy> Clint: how stable is GHC.IO.Encodding api?
12:21:00 <dmj`> shapr: sry :)
12:21:05 <shapr> :-)
12:21:13 <Clint> ongy: beats me
12:22:53 <dmj`> nmdanny: newtype Stack a = Stack { runStack :: ReaderT Int IO a } deriving (MonadReader Int), runApp c = flip runReaderT c . runStack; runApp :: Int -> Stack a -> IO a
12:23:09 <nmdanny> yea I understand how to unwrap a concrete stack
12:23:43 * hackagebot hgeos 0.1.0.0 - Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.0.0 (rcook)
12:25:00 <nitrix> How would I force the %~ lens to be strict?
12:27:20 <anilanar> let's say I have the following function:
12:27:32 <anilanar> myFunc [] = False
12:27:36 <anilanar> myFunc _ = True
12:27:49 <anilanar> how would I write quickcheck properties for this?
12:28:47 <anilanar> do I need o define my own type and impl Arbitrary? is there no shortcut?
12:32:08 <Gurkenglas> @let myFunc [] = False; myFunc _ = True
12:32:09 <lambdabot>  Defined.
12:32:22 <Gurkenglas> @check \x -> myFunc x == (x == [])
12:32:24 <lambdabot>  *** Failed! Falsifiable (after 1 test):
12:32:25 <lambdabot>  []
12:34:40 <puregreen> nitrix: by “strict” do you mean “x & f %~ undefined === undefined”?
12:34:58 <nitrix> puregreen: Yes.
12:35:11 <anilanar> @Gurkenglas is there a way to define a property that would run with a single edge case?
12:35:11 <lambdabot> Unknown command, try @list
12:35:26 <puregreen> anilanar: “@” prefixes commands to the bot
12:36:04 <anilanar> ah true, my bad
12:36:16 <nitrix> puregreen: Simplified to a use case, I have this IORef that must be performed strictly.  modifyIORef' refCache $ trace "foo" $ cacheLinks %~ \links -> trace "bar" $ id
12:36:26 <nitrix> puregreen: Suprisingly, `foo` is printed and not `bar`.
12:37:14 <nitrix> Normally it wouldn't be a problem, but this is for a library with weak pointers and if it's not strictly updated, the GC will never collect the weak pointers.
12:37:59 <nitrix> (Called links. They're stored in the data structure that I'm trying to update with this lens) :/
12:38:02 <buglebudabey> can anyone recommend a good package for markov chain analysis or other ML related analysis?
12:38:17 <geekosaur> modifyIORef' is strict in the same way everything else in Haskell is, that is, to WHNF
12:38:30 <geekosaur> if you really need to force the whole thing, you may need deepSeq
12:38:44 <puregreen> nitrix: I don't know anything in lens that does it for you, so I wrote a combinator
12:38:57 <puregreen> data Id a = Id {runId :: !a} deriving Functor
12:39:05 <puregreen> l %~! f = runId . l (Id . f)
12:39:45 <puregreen> hm, I wonder whether it's possible to do with just Identity and $!
12:40:26 <puregreen> nope, doesn't seem to work
12:41:08 <puregreen> anyway, the Id !a thing works and in the meantime I'll go file an issue against lens
12:48:46 <nitrix> puregreen: Not sure what kind of magic this is, but it worked. http://lpaste.net/170437
12:49:03 <puregreen> https://github.com/ekmett/lens/issues/664
12:49:09 <puregreen> darn, why not 666 :(
12:49:31 <nitrix> puregreen: As you can see, loading new links invalidate former ones.
12:49:38 <nitrix> Hurray! :)
13:01:30 <davidkart> hello
13:01:34 <davidkart> why is there monads in Haskell ?
13:01:35 <mekeor> hello davidkart :)
13:01:44 <davidkart> Hello mekeor
13:01:49 <davidkart> I hope you all do well
13:01:50 <alercah> What do you mean, why?
13:03:04 <dmj`> davidkart: I think that was due in part by Eugenio Moggi's work
13:03:05 <geekosaur> because main :: [Response] -> [Request] was an even bigger PITA to code for
13:03:06 <davidkart> alercah: I am running into a discussion on a french forum about the differences between Ocaml and Haskell. Some one is claiming that category theory has strictly speaking nothing to do with functional programming. Yet it would appear to me that it is the theoretical fundation for being able to do things like IO without being impure (I cannot justify)
13:03:26 <EvanR> nah
13:03:36 <alercah> ^
13:03:48 <alercah> they're just a nice way to implement that
13:03:52 <EvanR> its the theoretical foundation for being able to . any two appopriate functions
13:03:54 <alercah> and to factor out common behaviours
13:04:15 <davidkart> alercah: ok, so it gives a theoretical ground to procedural thinking then ?
13:04:17 <geekosaur> also Haskell's Monads have only a distant relationship to category theory monads; it's more a convenient "design pattern" that someone realized was a special case of the category theory stuff
13:04:25 <davidkart> okay
13:04:30 <alercah> yeah, that's the best description
13:04:41 <davidkart> okay okay
13:04:51 <alercah> Most of the higher mathematics you see in Haskell is motivated by being useful first
13:04:57 <davidkart> I couldn't ask you to be more precise, I've already bothered you enough with my trivial questions.
13:05:06 <davidkart> alercah: yeah, I think, okay.
13:05:29 <davidkart> alercah: I mean programming languages have to be useful to some extent I suppose
13:05:35 <Zemyla> You know, I'm wondering if some profunctors might not have a law-abiding Strong instance, but do have an instance firstM :: (Monoid c) => p a b -> p (a, c) (b, c).
13:05:37 <alercah> they don't have to be
13:05:53 <alercah> being useless never stopped INTERCAL's meteoric rise in popularity
13:05:54 <davidkart> alercah: they don't have to be if they don't care about being used 
13:06:35 <davidkart> well okay at this point things get humorous.
13:06:42 <davidkart> :)
13:06:54 <davidkart> i'm not old enough to know what INTERCAL is.
13:07:17 <davidkart> okay thank you for setting things clear.
13:07:27 <Zemyla> alercah: Meteoric rise? But meteors fall.
13:07:45 <EvanR> wait yeah whats with that saying
13:07:45 <davidkart> I actually was discarding math stuff. Programming is a much more practical and as well rewarding purpose in life.
13:08:06 <davidkart> Zemyla: or they go round and round with out any side effect :p
13:08:36 <Strikingwolf> I'm having some trouble with implementing Promises in Haskell to do with the types. The main problem being that once I declare Promise as a GADT with constructor of type (NFData a) => a -> Promise a then I try to make a Functor instance it fails due to NFData not being bound for the b variable in fmap :: (a -> b) -> Promise a -> Promise b, however the a variable is recognized as being an NFData, does anyone know how I could fix
13:08:52 <pikajude> so does readTChan retry until a message is received?
13:08:57 <mpickering> Zemyla: What is the precise question?
13:09:26 <Zemyla> Well, I'm wondering what laws could be described for it.
13:09:31 <pikajude> and if so, does that use a lot of CPU?
13:10:25 <alercah> Strikingwolf: Can you produce a minimal testcase?
13:11:17 <EvanR> pikajude: retry doesnt loop, it waits until retry has a possibility of working
13:11:23 <pikajude> i see
13:11:28 <pikajude> so something else in here is using a lot of CPU
13:12:37 <Strikingwolf> alercah: that's effectively as minimal as the test case may be, as the function from a -> b is required to produce the error it seems
13:13:41 <Strikingwolf> though you could replace the `Promise a` argument to fmap with a normal `a` not bound to NFData, but that's not that much more helpful
13:15:54 <alercah> Strikingwolf: it's not something I can put into my compiler and play with though
13:18:45 * hackagebot extra 1.4.12 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.12 (NeilMitchell)
13:19:51 <Strikingwolf> alercah: http://paste.ee/p/IGBEr
13:27:43 <nmdanny> question: what's the difference between Alternative and MonadPlus, apart from the fact that MonadPlus is specialized to monads?
13:28:32 <jle`> nmdanny: the only thing is really the laws
13:28:43 <kadoban> That's uhm, interesting. I'm creating a symbolic link with createSymbolicLink from 'unix'. I sleep for 1 second after my program finishes and check if the link exists, it does. I sleep for 5 seconds after that and check again, and the link no longer exists.
13:28:56 <jle`> but MonadPlus should really be an empty typeclass, mplus = (<|>) and mzero = empty, by requirement
13:29:04 <mniip> it's a diamond pattern
13:29:28 <mniip> Applicative => Monad, Applicative => Alternative, Monad => MonadPlus, Alternative => MonadPlus
13:30:14 <EvanR> thats not a diamond...
13:30:19 <nmdanny> so why have monadplus in the first place? seems redundant no?
13:30:29 <jle`> for the laws
13:30:39 <EvanR> er i see
13:32:00 <EvanR> but Alternative is not a prereq for MonadPlus
13:32:09 <jle`> EvanR: it is
13:32:58 <EvanR> i see it now, in latest base
13:33:05 <glguy> and also before the latest
13:33:18 <EvanR> google thinks 4.6.1 is latest
13:33:49 <EvanR> are monadplus and alternative supposed to agree?
13:34:46 <jle`> yeah, it's been a superclass for 2 ghc releases now
13:34:49 <jle`> yeah, they are supposed to
13:35:19 <jle`> although i guess the docs don't mention that
13:35:30 <jle`> that's unfortunate
13:35:41 <nmdanny> so what's the practical point of having MonadPlus, if we have functions that require a monadplus property, why not just specialize them to Monad,Alternative instead?
13:35:46 <glguy> MonadPlus is a bit of a mess, its instances don't necessarily satisfy what little the documentation does say
13:35:56 <jle`> nmdanny: the laws
13:36:02 <nmdanny> which laws
13:36:15 <jle`> mzero >>= f = mzero
13:36:19 <jle`> v >> mzero = mzero
13:36:24 <glguy> and that mzero is an identity for mplus
13:36:28 <jle`> see the docs --
13:36:35 <jle`> http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:MonadPlus
13:36:55 <jle`> those laws aren't Alternative laws
13:37:04 <jle`> so (Alternative m, Monad m) => ... doesn't really give you those laws to work with
13:37:12 <jle`> and you can't assume them
13:37:24 <EvanR> the laws boss, the laws!
13:37:35 <eacameron> What is the performance characteristics of tuple updates? Is it O(1) to update a field in a tuple?
13:39:04 <glguy> You can't update a tuple, they're immutable, so I'd say O(0)
13:39:34 <eacameron> glguy: I mean update as in, get a new one.
13:39:40 <jle`> i think it should be O(1) access on the index you want to access
13:39:46 <jle`> same for 'update'
13:39:54 <jle`> that's why there's a different type for every tuple length
13:39:57 <glguy> I imagine it's O(n) where n is the number of fields in the tuple to make a new tuple value
13:40:21 <eacameron> Hm...
13:40:26 <jle`> ah, yeah
13:40:34 <eacameron> Same for records I assume?
13:40:55 <glguy> The fields aren't going to populate themselves :)
13:41:09 <EvanR> O(n) to copy an n-element vector
13:41:20 <eacameron> Sure, I thought maybe sharing came into play or something.
13:41:33 <koala_man> it would be fun to see a benchmark. ghc might optimize to in-place editing in certain cases
13:41:45 <EvanR> that would be impressive
13:42:13 <EvanR> such tuples are somehow outside the gc sphere of influence i would guess
13:42:39 <eacameron> I ask because I'm curious how well various extensible-records approaches can compete in terms of performance.
13:43:04 <EvanR> extensible records is probably made of many parts and so can do sharing
13:43:19 <eacameron> If native tuple "updates" or O(n) then vinyl and hetero-dict actually have the same asymptotics.
13:43:27 <eacameron> *are
13:43:41 <EvanR> i think O(1) and O(n) probably dont mean much for this
13:43:45 * hackagebot haskell-names 0.7.0 - Name resolution library for Haskell  https://hackage.haskell.org/package/haskell-names-0.7.0 (PhilippSchuster)
13:43:47 <ggVGc> I am fairly amazed that ghc manages to produce reasonably performing code from haskell
13:43:48 <cocreature> eacameron: for updates yes, but not for accesses
13:43:56 <ggVGc> but I guess it took decades
13:44:10 <AirPlanes2> \\\\\\\\\
13:44:12 <EvanR> copying a pair and changing 1 field is not really "O(n)" as in the length of a 100000 element list
13:44:17 <EvanR> same with most records
13:44:50 <EvanR> where as traversing 5 levels of pointers is probably worse than copying a 5 element vector
13:45:03 <cocreature> yeah, what matters a lot more in this case is probably that the memory for a record is contiguous while you need to chase pointers for vinyl
13:46:40 <eacameron> That's true, O(n) isn't the best term since 'n' tends to be unknown until runtime. In this case it is statically known. Perhaps "linear" is a better term for this.
13:48:30 <eacameron> Speaking of vinyl, does anyone here use that in earnest?
13:49:23 <cocreature> eacameron: I use it sometimes but not as a record replacement. I use it to make lists of gadts with different type parameters
13:49:28 <EvanR> eacameron: its not even useful for comparing stuff like map update and vector copying
13:49:29 <AirPlanes2> a
13:49:30 <AirPlanes2> b
13:49:31 <AirPlanes2> c
13:49:38 <AirPlanes2> drop
13:49:46 <danza> AirPlanes2 ?
13:49:50 <AirPlanes2> !help
13:49:55 * Henson looks at his stacks of records
13:49:56 <glguy> AirPlanes2: This isn't a test channel
13:49:59 <AirPlanes2> test
13:50:20 <ggVGc> does anyone know the main technique ghc uses to reduce copying of data?
13:50:28 <AirPlanes2> wat
13:50:48 --- mode: ChanServ set +o glguy
13:50:49 <EvanR> ggVGc: well theres fusion
13:50:57 <ggVGc> EvanR: that's very new though isn't it?
13:51:01 <ggVGc> like, ghc 7?
13:51:13 <EvanR> i cant remember it not existing
13:51:18 <ggVGc> oh, okay
13:51:21 <cocreature> ghc 7 is not exactly new
13:51:33 <ggVGc> I think I meant 7.8
13:51:43 <dolio> It's older than ghc 7, too, though.
13:52:03 <EvanR> a summary of all the optimizations would be good
13:52:06 <EvanR> would be cool
13:52:09 <ggVGc> anyway, maybe there's actually a lot of data being copied, but in a way that CPU's like
13:52:39 <EvanR> everything the cpu does is "copying"
13:53:01 <AirPlanes2> glguy, what's up?
13:53:17 <glguy> AirPlanes2: This channel is for discussion of the Haskell programming language.
13:53:30 <AirPlanes2> Sure.
13:55:53 --- mode: glguy set -o glguy
14:01:00 <nitrix> ggVGc: There's a few strategies I think. Sharing pointers (since the data is immutable and the language is referentially transparent and the side effects are controlled), some fusion (avoiding repetitive operations that can be composed together), some unpacking (can remove layers of indirection) and memoization also plays a role for the performance.
14:01:41 <nitrix> ggVGc: The "main technique" as far as I know is the sharing of pointers.
14:04:20 <ggVGc> nitrix: yeah, makes sense, thanks
14:06:27 <nitrix> I also think it's also one of the contributing factor that required a garbage collector, so I'm assuming the benefits of sharing pointers must be pretty significant.
14:07:11 <EvanR> how would you remove the gc by removing sharing?
14:08:04 <nitrix> Good question. If you remove sharing, does it makes lifetimes easier to reason about statically?
14:10:02 <EvanR> when i learned about graph reduction machines i could not see how youd possible avoid a GC
14:10:31 <EvanR> but i didnt think about avoiding sharing
14:11:20 <nitrix> Maybe it'd have ended with something akin to Rust? The problem is that it'd have to be done without the help of the language (the Haskell report has very little on the subject).
14:12:27 <nitrix> A borrow checker for Haskell, ouch. Might as well introduce linear typing / dependent types.
14:12:58 <EvanR> copying everything all the time, and rust itself both seem like incredible efforts to avoid GC, a lot of times it seems like avoiding gc for the sake of it
14:13:46 <EvanR> based on language "niceness" ive seen so far im biased toward GCs
14:14:11 <nitrix> I'm perfectly okay with the current strategy, mind you. It simplifies the language so much.
14:14:59 <EvanR> manual memory management (one other way) means you admit defeat, that the computer has finite memory resources!
14:15:12 <EvanR> dont give in
14:17:14 <nitrix> ggVGc: It does require data to be immutable though. If the shared data is "modified" by either, it's actually a new copy of the data structure with the addionnal transformations created separately, then the common remainder of (let's say) the tree or list will stay shared.
14:18:04 <ggVGc> seems like this would lead to a lot of indirection in lookups anyway
14:18:31 <nitrix> ggVGc: x = [1,2,3,4,5]; y = 0 : x; Is literally that, 0 then a pointer to the remainder of the list, which is that x.
14:18:36 <EvanR> nitrix: i think you might be right, if every reference to a variable is a copy into a new object, such that each object has only one reference, then you can free the environment used by any function. however for this to be taken seriously, each time you use a closure it needs to copy everything in its environment
14:18:51 <geekosaur> rust is targeting the kind of lower level stuff that C targets. GC is not, in general, something you want in interrupt time device drivers --- or, for that matter, in any code that must allow said drivers to run immediately
14:19:03 <nitrix> ggVGc: All boxed types have a pointer anyway. That's what allows values to live on the heap, as well as having thunks for lazy evaluation and even do memoization.
14:19:27 <ggVGc> ghc must be doing something for cache coherency though, I would think?
14:19:28 <EvanR> standard lib functions can be shared since they dont need to be freed
14:19:58 <geekosaur> I would otherwise say that sharing is a memory optimization, which is significantly enabled by purity
14:22:07 <EvanR> nitrix: the simplest way is the allow sharing, assume you have infinite memory, and never worry about gc. a realistic variant of this works for "sparks" which arent expected to run for long, you can drop their entire memory when they are done
14:22:40 <EvanR> which is nice if they are statically guaranteed to terminate (even better terminate soon, even better use at most N memory)
14:24:56 <nitrix> ggVGc: The garbage collector is generational. There's a nuture area that gets migrated to a more permanent area after a couple cycles. Most of the trivial list manipulation and whatnot happens in that nuture area (which should help cache locality).
14:26:22 <nitrix> ggVGc: For the remainder, ehm, the benefits mostly outweights the cons, but you can still manually {-# UNPACK #-} things as well as refactoring your code to use unboxed # stuff. A necessary evil apparently at times.
14:28:47 * hackagebot stackage-install 0.1.2 - Secure download of packages for cabal-install  https://hackage.haskell.org/package/stackage-install-0.1.2 (MichaelSnoyman)
14:39:09 <buglebudabey> is a Map the best data structure for frequency lists?
14:39:53 <dmj`> could use a vector
14:40:32 <buglebudabey> any pros for one over the other?
14:40:44 <buglebudabey> what's a vector better at
14:41:06 <kadoban> Well, vector isn't going to work so well if your keys aren't numbers, right? It's also going to be bad if the keys aren't dense.
14:41:42 <monochrom> you probably should learn what is an array and what is a balanced binary search tree
14:42:05 <dmj`> kadoban: could use hashable to convert your keys to numbers
14:42:17 <monochrom> but skip lists are the best.
14:42:30 <kadoban> dmj`: Yes, but at that point you're just reimplementing a bunch of stuff for not a lot of reason, no?
14:43:08 <monochrom> if you have hashable, you will be more inclined to use hashmap
14:43:28 <dmj`> or hashtables
14:44:13 <buttbutter> Sorry for spam, but does anyone know a good channel on IRC to talk about grad school choices for CS? I need some guidance but I don't know where to ask.
14:45:49 <monochrom> try #algorithm and #cs
14:46:03 <buttbutter> Thanks :)
14:49:48 <verrlara> Hello, how is everyone today. 
14:50:37 <verrlara> Having some trouble with the default package of hakyll the static blog program and the server lighttpd. 
14:57:22 <verrlara> my problem is its building it into /public/_site and I'd rather it build into my docroot of /public
14:58:27 <pikajude> is there a way to get profiling information out of an executable that freezes
14:58:37 <pikajude> because not being able to do so almost makes it seem like profiling is pointless
14:58:59 <monochrom> does ctrl-c help?
14:59:07 <pikajude> uh...no
14:59:27 <Welkin> pikajude: did anyone try to catch you yet?
15:00:33 <verrlara> :<
15:00:41 <pikajude> like i said, frozen
15:00:43 <pikajude> i have to kill -9 it
15:00:43 <geekosaur> profiling information is only output on normal exit, unfortunately
15:00:47 <pikajude> and that evidently makes profiling go away
15:05:05 <Squarism> Say i have multiple (somewhat deeply nested) functions taking user input. What is the "right" way of handling bad input? Tossing around Either's or throw-try-catch ?
15:06:01 <Squarism> or are error's used to signal non resolvable errors?
15:06:10 <Squarism> "error" that is
15:07:05 <sleblanc`> Squarism: it's opinion-based, but using "error" is probably the wrong approach
15:07:23 <sleblanc`> undefined and error are convenient when messing around, but you should avoid them like the plague in robust, finished applications
15:07:48 <Squarism> sleblanc`, so what options do i have?
15:07:50 <sleblanc`> Either is a nice paradigm for this. Either InputException ActualInput
15:08:01 <Squarism> oh ok
15:09:03 <sleblanc`> many parsers use this approach. During parsing, if a component fails in a non-optional position, the result of the parse is a Left (x :: ParseError), otherwise it's a Right
15:11:10 <Welkin> Squarism: error can be used when there is no possible way for your program to continue (a fatal error), such as in IO
15:11:33 <Welkin> otherwise, use EitherT, ExceptT, or Maybe
15:12:13 <Squarism> Welkin, ok.. ill look upp EitherT and ExceptT
15:12:26 <monochrom> the right way is to keep pestering the user until they give you good input. then outer levels do not even know there was bad input at all.
15:12:45 <Welkin> they are just the transformer equivalents of Either and Except
15:14:51 <dylan_1> Hello everyone, I've been working through cis194, and I ran into a problem on HW # 7 when using ghci to load this file: http://lpaste.net/170446 . I get the error: http://pastebin.com/57jLMRvp . I found a post about this, telling me I need to install Cabal. I did just that and it still doesn't work out. However, I have "stack", shouldn't that be supplanting Cabal, in this case? Do I need to do some weird command to link the right libraries? Thank 
15:14:51 <dylan_1> you.
15:15:02 <Squarism> cannot find Except in hoogle?
15:15:26 <Welkin> Squarism: don't use hoogle
15:15:29 <shachaf> dylan_1: You need the package providing Control.Monad.State.
15:15:30 <Welkin> @hayoo ExceptT
15:15:31 <lambdabot> Unknown command, try @list
15:15:33 <dylan_1> Honestly at this point I've considered removing everything and installing Haskell Platform.
15:15:34 <Welkin> eh
15:15:36 <Welkin> use hayoo
15:15:39 <shachaf> You can get it in mtl.
15:15:44 <hexagoxel> http://hayoo.fh-wedel.de/?query=Except
15:15:46 <Welkin> http://hayoo.fh-wedel.de/?query=ExceptT
15:15:49 <shachaf> With cabal, you can `cabal install mtl`
15:15:53 <dylan_1> shachaf, when trying to get mtl I get another error. Let me copy and paste.
15:15:58 <mgsloan> dylan_1: Run "stack exec ghci"
15:15:59 <Squarism> thanks
15:16:06 <dylan_1> mgsloan, yeah I do that already
15:16:07 <Welkin> hoogle is good for searching by type signature
15:16:10 <dylan_1> have it aliased in fact
15:16:12 <Welkin> hayoo is better for everything else
15:16:25 <Welkin> hayoo searching everything on hackage, I believe
15:16:28 <Welkin> hoogle doesn't
15:16:32 <mgsloan> dylan_1: You do?  You can't pass "Editor.hs" in to stack ghci currently
15:16:35 <Welkin> searches*
15:16:44 <mgsloan> You could run "stack exec bash" and then run ghci within that
15:17:08 <mgsloan> Errr
15:17:15 <dylan_1> http://pastebin.com/VSQwQPCr
15:17:30 <mgsloan> Nevermind, you can pass that in to "stack exec ghci", I was thinking of "stack ghci", which doesn't yet take filepaths
15:17:32 <dylan_1> This is what happens when I attempt to cabal install mtl. Same thing happens as my normal user.
15:17:57 <dylan_1> cabal-install version 1.18.1.0
15:17:57 <dylan_1> using version 1.18.1.5 of the Cabal library 
15:18:16 <mgsloan> dylan_1: Try "stack --package mtl exec bash"
15:18:30 <dylan_1> It says I need at least 1.6? Is it actually doing a lexicographic comparison between 1.6 and 1.18...
15:18:35 <mgsloan> Rather, "stack --package mtl exec -- ghci Editor.hs"
15:18:36 <dylan_1> Because if so then just lol
15:18:41 <dylan_1> mgsloan, ok
15:18:43 <dylan_1> will try now
15:18:49 <dylan_1> as normal usr
15:19:17 <monochrom> 1.6 is considered < 1.18. this is not the problem.
15:19:47 <dylan_1> erm. stack --package? It's telling me that --package is an invalid option, mgsloan.
15:19:58 <mgsloan> dylan_1: Update your stack version!
15:19:58 <dylan_1> monochrom, good.
15:20:03 <mgsloan> What's your current version?
15:20:32 <dylan_1> mgsloan, 1.12. Would I be updating that as root? I know stack keeps a local directory with stuff in it as opposed to a global installation like the Haskell Plat does.
15:21:13 <vctr> o/
15:21:16 <dylan_1> I have the latest version of stack from my distro's repo.
15:21:17 <mgsloan> dylan_1: Oh, huh, that may be a regression in the options parsing 0_o, wacky
15:21:26 <mgsloan> "stack exec --package mtl -- ghci Editor.hs"
15:22:31 <mgsloan> (I suppose the flags should come after the command)
15:22:45 <dylan_1> mgsloan, thanks, that seemed to do something. Is mtl permanently a part of my list of packages now, or do I have to stick that package mtl bit in every time
15:23:01 <dylan_1> alright sweet, looks like it did grab it
15:23:03 <dylan_1> thanks a lot man
15:24:30 <mgsloan> Welcome!  It is not a permanent part of your list of packages.  However, if you have a project or other invocation of "stack exec" / etc which needs that exact mtl version, it will be reused
15:25:14 <buglebudabey> is this an efficient way to make a frequency list, say for words in a book? http://lpaste.net/170448
15:25:29 <dylan_1> mgsloan, oh ok. And...this is preferable to doing things the non-stack way?
15:25:49 <mgsloan> Depends on what you mean by the non-stack way
15:26:16 <dylan_1> Just having things work out of nowhere, basically.
15:26:20 <mgsloan> But yes, stack really helps with easily constructing a package environment for building projects or one-off scripts
15:26:40 <shachaf> You can expect a biased answer if you ask a Stack developer that question.
15:26:41 <mgsloan> (and having this environment be reliable / reproducible)
15:26:45 <mgsloan> Right
15:27:10 <mgsloan> Nix can also provide the same benefits, but it has other drawbacks
15:27:28 <maerwald> it's a real package manager, at least
15:27:39 <shachaf> What happened to lambdachine, anyway?
15:27:50 <mgsloan> Stack can integrate with nix or docker, in order to easily leverage the reproducibility provided by those tools 
15:27:52 <shachaf> nominolo got his PhD and stopped working on it?
15:28:35 <dylan_1> Reproducibility. That does sound like a good advantage. I know how annoying it is building some C projects when you're missing certain things.
15:28:36 <mgsloan> maerwald: Right, it's working to solve a bigger and different problem
15:28:47 <mgsloan> Whereas stack does lots of haskell-specific stuff
15:29:23 <hodapp> maybe I'll look at nix again if that silly Arch-specific bug is fixed.
15:29:24 <hodapp> hrm.
15:53:23 <dedgrant> Should anyone care to take a look, I'm seeking a review of the following code, wading once again into tricky type inference territory: http://lpaste.net/170449
15:54:38 <dedgrant> ghc-8.0.1 .. looking for some feedback on missed opportunities to simplify expressions and/or work at making a result that requires less handholding for users.
15:55:15 <dedgrant> (wrt satisfying the type constraints of insertAutoInc)
16:15:22 <unknownloner> How would I use lens-aeson to get either two fields from an object as a tuple or Nothing if either one doesn't exist. My intent would be like "{\"a\": 1, \"b\": 2}" ^? (key "a", key "b"), except not that because that's now how you actually do it of course
16:18:26 <Gurkenglas> '((,) <$> key "a" <*> key b) "{\"a\": 1, \"b\": 2}"' should work
16:18:45 <Gurkenglas> Wait, no, I think I forgot a layer of Applicative
16:19:05 <Gurkenglas> also the views
16:21:08 <Gurkenglas> (liftA2 . liftA2) (,) (view $ key "a") (view $ key "b") "{\"a\": 1, \"b\": 2}"
16:21:08 <jle`> hvr: any reason cassava use its own internal parser type?
16:21:25 <Gurkenglas> > (liftA2 . liftA2) (,) (view _1) (view _2) (Just 2, Just 3)
16:21:26 <lambdabot>  Just (2,3)
16:22:50 <Gurkenglas> unknownloner, make sense?
16:24:03 <unknownloner> one moment, testing it with stuff
16:24:54 <unknownloner> that doesn't actually work for some reason
16:25:37 <unknownloner> it's having an issue with the (view $ key "a") and (view $ key "b") parts
16:26:00 <unknownloner> expected f (f1 b) actual f (some aeson internal type)
16:30:45 <crough> doesn't key need preview?
16:32:24 <unknownloner> oh yeah it does
16:33:06 <unknownloner> preview makes it work
16:34:33 <unknownloner> To be honest though I'm not super clear on what this is actually doing
16:34:41 <unknownloner> I think it's the (liftA2 . liftA2) throwing me off
16:36:07 <Welkin> liftA2 is \g fa fb -> g <$> fa <*> fb
16:36:20 <Welkin> > liftA2 (+) (Just 2) (Just 3)
16:36:21 <lambdabot>  Just 5
16:36:45 <Welkin> > (liftA2 . liftA2) (+) (Just(Just 2)) (Just(Just 3))
16:36:46 <lambdabot>  Just (Just 5)
16:37:15 <unknownloner> > Just (+ 5) <*> Just 5
16:37:16 <lambdabot>  Just 10
16:37:18 <unknownloner> ok
16:37:32 <unknownloner> that makes more sense now
16:46:51 <unknownloner> While I'm here, maybe someone can explain something about lens. So I know that (f . g) x = f (g x), so typically data flow from right to left. How then does it seem to go from left to right with lens. For example "[{\"a\": 1}]" ^? nth 0 . key "a" . _Number is how it'd be written, but my intuiton tells me it should be "[{\"a\": 1}]" ^? _Number . key "a" . nth 0
16:47:07 <unknownloner> let me know if any of that seems to be cut off btw, I don't know if my irc client splits messages properly ^
16:47:39 <Welkin> you can control the order of evaluation
16:47:56 <Welkin> lens just makes it work more like an imperative language
16:48:06 <Welkin> (&) = (flip $)
16:50:18 <unknownloner> I understand that, but I'm confused about how (.) is working here
16:50:47 <Welkin> lenses compose backwards
16:50:53 <Welkin> that's all I know about lens
16:51:11 <Welkin> if you want more details, you can ask in #haskell-lens, too
16:51:11 <shachaf> It works the same way as map (fmap (*2)) [(1,2), (3,4)]
16:54:51 <Gurkenglas> Why is assignment in a do block to be preceded by let? Did the line "a = b", that now fails to parse, use to mean something in do blocks?
16:55:17 <Welkin> ?
16:55:23 <Welkin> there is no assignment
16:56:42 <monochrom> this will evolve into a debate over "what is assignment? what is binding?".
16:56:58 <Welkin> lol
16:57:14 <jle`> Gurkenglas: most likely an arbitrary design decision
16:57:30 <monochrom> and no, there is not going to be any "productive" answer apart from "go to the Haskell committee to discuss syntax design".
16:57:35 <Welkin> Gurkenglas: because do-notation is just synactic sugar for explicit >>= and >> with all the parentheses
16:58:04 <jle`> a = b is probably just as legitimate a design decision as let a = b, there probably isn't any deep reason why one is needed over the other
16:58:14 <jle`> let is closer to the desugaring, fwiw
16:58:32 <shachaf> monochrom: They're not going to change their mind now. The decision is binding.
16:58:38 <monochrom> hehe
16:58:56 <Welkin> I was just thinking about the wapping of (:) and (::) in haskell
16:59:02 <Welkin> and how Idris and Elm switched them back
16:59:08 <Welkin> swapping*
16:59:12 <jle`> i've read that there was a policy in the original language design commitee that for small syntactic things like this the first suggestion was taken without any discussion
16:59:19 <Enigmagic> haskell should swap them back just for fun
16:59:29 <jle`> just to prevent the ineviable bikeshedding
16:59:49 <jle`> unenviable
16:59:59 <jle`> & inevitable
17:00:24 <vctr> hi all
17:00:35 <mekeor> hi vctr
17:01:15 <vctr> how goes haskell hacking
17:01:24 <Welkin> there is no hacking
17:02:22 <mniip> very hacky
17:06:43 <vctr> hm just upgraded from a 2 year old macbook air to a 2016 macbook pro and my code is not noticeably faster :/
17:07:13 <monochrom> does your code wait for user input?
17:07:21 <vctr> guess the free lunch really is over..
17:07:37 <monochrom> you need to upgrade from user air to user pro, too.
17:07:38 <vctr> no input
17:08:11 <vctr> it's very imperative-ish code though. literal port of some python codebam
17:08:26 <vctr> code (damn emacs autocomplete) ...
17:08:28 <Welkin> codebam
17:08:30 <Welkin> lol
17:08:42 <Welkin> sounds like something someone wrote in python
17:08:47 <Welkin> python codebams
17:09:36 <glguy> vctr: There isn't a 2016 macbook pro that I know of, either, so it might not be as far away from their 2 year old air as you were expecting
17:09:48 <monochrom> still, air vs pro
17:10:04 <vctr> glguy true
17:10:05 <Welkin> if you care about performance, get a server or a workstation
17:10:06 <Welkin> o.o
17:10:26 <vctr> i would've waited a few more months, but i have a friend visiting to do some music recording
17:10:30 <vctr> and all i have is my work computer so...
17:11:09 <vctr> at the moment i get by. would be better if my megacorp's HPC supported haskell (or at least docker containers)
17:11:19 <Koterpillar> Welkin: if you care about performance, measure
17:11:42 <vctr> i'm do some computation-heavy work, but none that's outside the realm of laptop feasibility
17:12:18 <vctr> this code can probably be optimized a lot anyway, considering it's a literal port of python code at the moment.
17:12:32 <vctr> super imperative
17:12:35 <Welkin> oh god
17:12:47 <Welkin> like those literal translations from c++ into haskell on rosettacode?
17:12:52 <Welkin> those are terrible...
17:13:30 <vctr> i didn't use rosettacode 
17:13:45 <vctr> but i did use more gratuitous lenses and pipes than I ordinarily would
17:13:50 <vctr> if i were writing it from scratch
17:14:08 <vctr> it's a bit of an involved MCMC algorithm though, so I wanted to port it first, refactor second.
17:14:41 <Welkin> usually, starting from nothing is easier
17:14:52 <Welkin> than "refactoring" a big mess
17:15:08 <vctr> well the whole thing is ~ 400 lines, so it's not massive
17:15:15 <vctr> this way i was forced to give it a deep read
17:21:38 <vctr> for lens'd records
17:21:47 <vctr> is there a performance difference between
17:21:58 <vctr> rec ^. field vs. _field rec ?
17:22:08 <vctr> or does the former just desugar to the latter?
17:22:44 <monochrom> I only know that if you use IORef you get a penalty.
17:23:27 <geekosaur> doesn't ^. indirect through a typeclass dictionary?
17:31:36 <glguy> Geekosaur: once the lens and ^. inline it's the same as using the record selector
17:38:57 <dmwit> unknownloner: Usually, you think of function `f` as modifying its input. So `f . g` uses `g` to modify its input, then uses `f` to modify that.
17:39:22 <dmwit> unknownloner: But with lenses, the "input" is an input transformer.
17:39:41 <dmwit> unknownloner: So `f . g` uses `g` to modify the transformer, then uses `f` to modify that.
17:40:06 <dmwit> unknownloner: But if you look at how the ultimate input flows through `f` and `g`, you'll see that `f` gets to see the ultimate input first -- because it modifies the transformer last.
17:40:40 <dmwit> unknownloner: This is, incidentally, one of the few places where I felt lens' types actually helped me understand the picture better.
17:43:35 <dmwit> unknownloner: So, to be slightly less "fast and loose": the type `Lens' s a` eventually expands to `forall f. Functor f => (a -> f a) -> (s -> f s)`. So a `Lens' s a` is an operation which turns things that transform `a`s into things that transform `s`s.
17:45:48 <dmwit> unknownloner: So in particular you will notice that, even though the arguments to `Lens'` appear in the order `s` and then `a`, in the final arrow, the arguments to `(->)` appear in the order `(a -> f a)` and then `(s -> f s)` -- backwards by comparison!
18:08:54 * hackagebot kawhi 0.0.1 - stats.NBA.com library  https://hackage.haskell.org/package/kawhi-0.0.1 (aaron)
18:18:08 <vctr> doh dee doh
18:33:08 <recursion-ninja> When I run `stack`, it doesn't observe the `local-bin-path: bin` line in the `stack.yaml` file. Anyone know why this could be happening?
18:36:38 <mgsloan> recursion-ninja: Do you have an up-to-date stack?  That should work fine.  It will put the output exes in a local "bin" folder when you run "stack install"
18:36:48 <mgsloan> Perhaps you're just running "stack build"?
18:37:14 <mgsloan> Note, that that's the only effect the setting has.
18:41:19 <recursion-ninja>   mgsloan: It says placing execualbles in `.stack-work/blah/blah/bin` not `bin`. Stack is up to date.
18:42:01 <boj> recursion-ninja: what command did you run? 
18:42:39 <recursion-ninja> stack build
18:42:49 <boj> you will want to run "stack install"
18:43:03 <recursion-ninja> OHHHHHH
18:43:18 <recursion-ninja> I feel dumb now...
18:43:31 <boj> happens to us all
18:44:04 <recursion-ninja> Thanks for the hand holding :)
19:00:06 <tromp_> @hoogle intAtBase
19:00:08 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
19:32:50 <wrinkle> sup
19:33:55 <pyon> Can the Validation applicative (rather than the Except monad) be used to check whether all variables are in scope in a compiler? The problem with the Error monad is that it aborts the whole computation when the first error is found. :-|
19:34:38 <alercah> yes, that's by design. It's an exception-throwing mechanism :)
19:36:08 <pyon> Yes, I know why Except works the way it does. And I know why Validation can't be given a Monad instance (lawfully).
19:37:04 <alercah> looking at Validation, I think it's capable of what you want if used carefully
19:37:23 <Zemyla> pyon: Which Validation are you talking about?
19:37:49 <Zemyla> And does Codensity Validation satisfy the laws?
19:38:26 <alercah> Data.Either.Validation I assume
19:38:31 <pyon> Zemyla: It's like Either, but its Applicative instance requires a Semigroup constraint.
19:38:49 <Zemyla> Oh, so it can concatenate errors?
19:38:50 <pyon> Zemyla: And <*> on two Lefts merges the error messages with the semigroup operation.
19:38:57 <pyon> Yep, pretty much.
19:39:28 <Zemyla> pyon: Try using Data.These instead.
19:39:38 <pyon> Where is that? :-O
19:39:46 <pyon> I mean, which package.
19:39:52 <Zemyla> these.
19:40:18 <pyon> Checking, thanks.
19:44:55 <pyon> Zemyla: The point is that “This” means “complete failure”, “That” means “success”, and “These” means “completed, but with errors”, right?
19:45:16 <pyon> s/complete failure/aborted/
19:47:53 <Zemyla> pyon: More like These is "completed, but with warnings".
19:48:10 <pyon> Right.
20:04:02 <jle`> there should be better syntax for kind signtures in forall's
20:04:31 <jle`> forall (as :: [Nat]). Blah -> Blah is kind of weird and inconsistent
20:05:03 <Cale> hm?
20:05:34 <Cale> It looks pretty much like Coq's syntax, apart from the fact that it uses . instead of , and :: instead of :
20:06:04 <Cale> Not that Coq's syntax is super great, but I don't know that this part is all that bad ;)
20:06:50 <jle`> it's just kind of inconstent, giving type annotations and kind annotations
20:07:22 <jle`> forall (a :: k) (b :: j) (c :: l). Foo a -> Bar b -> ...
20:07:40 <jle`> type signatures are just a lot smoother/natural to write maybe :|
20:07:42 <jle`> but is it my bias
20:11:13 <EvanR> jle`: forall (a, b, c :: k) . would be nice if they were all the same k
20:11:37 <jle`> i also don't really have a way to format it nicely when i have several :|
20:12:03 <EvanR> forall a :: k . <newline> forall b :: j . <newline...
20:12:55 <jle`> does that work? :O
20:13:44 <jle`> oh neat
20:59:00 * hackagebot blockhash 0.1.0.0 - Blockhash perceptual image hash algorithm  https://hackage.haskell.org/package/blockhash-0.1.0.0 (kseo)
20:59:02 * hackagebot graphviz 2999.18.1.2 - Bindings to Graphviz for graph visualisation.  https://hackage.haskell.org/package/graphviz-2999.18.1.2 (IvanMiljenovic)
21:17:53 <unknownloner> I know I'm late by a few hours but thanks dmwit 
21:18:13 <unknownloner> that pretty helpful actually
21:31:10 <avalokite> Hello!!! :)
21:32:27 <dmj`> avalokite: hi
21:34:01 * hackagebot quiver-groups 0.1.0.1 - Group and chunk values within a Quiver  https://hackage.haskell.org/package/quiver-groups-0.1.0.1 (IvanMiljenovic)
21:34:03 * hackagebot unordered-graphs 0.1.0.1 - Graph library using unordered-containers  https://hackage.haskell.org/package/unordered-graphs-0.1.0.1 (IvanMiljenovic)
21:43:17 <avalokite> Where can I find a list of haskells predefined/built-in data types?
21:43:34 <glguy> https://www.haskell.org/definition/haskell2010.pdf
21:44:26 <avalokite> That was an extremely quick response. Thank you so much glguy.
21:44:43 <glguy> I keep that open in a browser tab ;-)
21:44:58 <avalokite> Smart man.
21:45:16 <Cale> https://www.haskell.org/onlinereport/ isn't much out of date compared with the 2010 edition, and is easier to navigate
21:45:46 <Cale> There are really only a few minor tweaks, and then the inclusion of the FFI addendum, http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
21:46:07 <shachaf> Wasn't there a one-page HTML version of the 2010 report?
21:46:10 <avalokite> Cale: could there be a PDF of this archive? I'd like to either print it and fit it all in a bind or at have it printed via Lulu or some other company.
21:46:16 <shachaf> I think one or two people made one.
21:46:20 <shachaf> haasn: ?
21:46:33 <glguy> avalokite: If you actually prefer the PDF, the link I gave is a PDF and more up to date than that one
21:46:35 <shachaf> chrisdone might have made one also.
21:46:39 <Cale> Well, if you want a PDF, you might as well just use glguy's link, yeah
21:46:48 <glguy> shachaf: I feel like we've had this discussion a few times now
21:46:54 <glguy> (I don't remember the answer though)
21:47:19 <Cale> The thing I linked is only better insofar as it has links to each section you can click on. Otherwise, it's older.
21:47:31 <avalokite> glguy: Yeah, kind of what I was thinking (kudos) but if Cale's link is more up to date.. I suppose really I just need the datatypes first and the rest is purely reference
21:47:39 <Cale> nonono, it's the other way around
21:47:50 <Cale> glguy linked the more up to date, but PDF-only version
21:47:59 <avalokite> Oh! My mistake. Understood! :D
21:48:04 <Cale> I linked the older version in HTML
21:48:44 <Cale> Mostly you'll probably just want to have a look at the Prelude there
21:49:20 <johnw> Cale: document like that are what Texinfo in Emacs is basically made for; too bad it's practically dead these days
21:49:25 <Cale> Which has artificial reference source code, including stubs for various types that will be available without any other imports (the Prelude is imported by default)
21:49:28 <avalokite> Cale: interestingly enough, I had already visited https://www.haskell.org/onlinereport/basic.html but felt something was missing. 
21:49:47 <avalokite> You guys are extremely helpful. Thank you so much
21:50:11 <Cale> avalokite: Well, it's really hard to even say that, e.g. Bool is "built in" really
21:50:31 <Cale> Or Maybe, for instance... these are just library definitions
21:50:47 <glguy> Bool is hard-wired into the meaning of if-then-else, at least
21:50:49 <shachaf> Bool is built-in.
21:51:07 <Cale> Well, okay, it's required for interpreting other syntax, sure
21:52:22 <avalokite> Is there a way I could look through the datatypes which are defined in other libraries? I think hoogle might help, but it seems to want a great deal of dependencies and I'm having a hard time with it.
21:52:25 <Cale> But it doesn't need to be put into the typechecker any differently than another algebraic data type. All the syntax which involves Bool is sugar which will be turned into case expressions and after that treated no differently from those for any other algebraic type.
21:52:39 <Cale> Usually people use hoogle on the web
21:52:52 <Cale> https://www.haskell.org/hoogle/
21:53:35 <Cale> and it conveniently links into the Haddock documentation of various packages on Hackage
21:54:41 <monochrom> with Haskell you have a new category of "user-definable but tied-in" that does not quite exist in other languages. Bool is user-definable, and is user-defined in Prelude, and Haskell syntax has a tie-in that uses Prelude's Bool and none other.
21:55:01 <monochrom> similarly the Monad class
21:55:03 <EvanR> and Eq - pattern matching relationship
21:55:11 <avalokite> This is exactly what I'm looking for! However, if it were offline, and provided the documentation for the libraries I have (or maybe there's a master dataset for hackage-current?), I think maybe I'd be satisfied
21:55:52 <monochrom> once again trying to bring dichotomies from other languages to Haskell is futile
21:55:57 <mirpa_> avalokite: you can use hoogle offline - sort of
21:56:13 <mirpa_> there is also command line tool
21:56:25 <Cale> monochrom: hehe
21:57:09 <EvanR> so there is no functor from other languages to haskell which preserves dichotomies?
21:57:31 <Cale> avalokite: It's probably easier just to get the Haddock documentation... depending on what tools you're using to install Haskell packages, there's typically an option you can turn on to generate a documentation index of all the installed packages
21:58:39 <Cale> For cabal-install, make sure that ~/.cabal/config has the option "documentation: True", and while you're at it, "library-profiling: True" is another good one to turn on there.
21:59:50 <Cale> and if that's turned on, then it'll start building an index for the packages you install, which will be under ~/.cabal/share/doc/<something>/index.html
22:00:04 <Cale> Where <something> is tied to your GHC version.
22:01:49 <Cale> There is almost certainly an equivalent option for stack, but I'm too ignorant of stack to know what it is.
22:10:55 <avalokite> This is probably a silly question, but is there a Type type?
22:11:22 <jle`> yes, and it's called Type
22:11:56 * jle` realized that was probably the least useful answer possible v.v
22:12:20 <avalokite> The hunt doesn't feel nearly as futile, jle`. :)
22:12:21 <EvanR> * is the type of types
22:12:42 <EvanR> the TypeInType extension started the process of renaming it to Type
22:12:48 <EvanR> among other things
22:13:07 <glguy> avalokite: In standard Haskell, values have types, and types have kinds
22:13:38 <avalokite> glguy: yes, Kind is exxactly what I was thinking when EvanR mentioned * as the type of types
22:13:50 <EvanR> Bool has kind *
22:13:55 <EvanR> Maybe has kind * -> *
22:14:08 <glguy> avalokite: But it's different from something like Java where you have a Class type that represents classes as a value
22:15:01 --- mode: ChanServ set +o glguy
22:15:19 * EvanR ducks
22:15:30 --- mode: glguy set -o glguy
22:15:42 <nineonine> how to leave only maximum values in a list ?
22:15:45 <glguy> Just wanted to look at the e and I mask lists (testing something in my client)
22:15:57 <nineonine> onlyMax [1,2,3,5,5] => [5,5]
22:16:07 <glguy> nineonine: Find the maximum value, remove the non maximum values
22:16:10 <nineonine> onlyMax [1,2] => [2]
22:16:23 <nineonine> glguy: thanks
22:16:24 <EvanR> onlyMax [] => []
22:16:29 * Cale resists the temptation to show the knot-tying solution
22:17:10 <Koterpillar> count the maximum values, use replicate
22:17:29 <nineonine> glguy: is this the most efficient way of doing that ?
22:17:30 <avalokite> Knot-tying solution?
22:17:43 <EvanR> Koterpillar is on to something
22:17:49 <EvanR> maybe
22:17:51 <Cale> There's a way to do it in one pass
22:18:01 <Cale> (sort of)
22:18:34 <Cale> Where you write a helper function that both computes the final maximum and the resulting list in one go, but also takes that final maximum as an argument to itself
22:18:35 <glguy> You can just run along the list tracking the maximum element and a list of the things that are equal to it, throw it out when something's bigger
22:18:42 <EvanR> accumulate the max so far and the number seen, reset if you see something higher
22:18:49 <glguy> reverse the accumulated list at the end
22:18:54 <Cale> Yeah, in this case, glguy's idea is simpler
22:18:54 <EvanR> then replicate
22:19:00 <Cale> and works out about the same :)
22:19:15 <nineonine> cool
22:19:17 <nineonine> thanks guys
22:22:12 <ahr> hi absolutely noob question here: i have a line like map (\[x,y] -> [x, read y :: Int]) xs
22:22:33 <ahr> it doesn't work on the read, it says it's expecting a String
22:22:37 <ahr> anyone can help?
22:22:40 <Cale> Yeah, there's no way that could ever typecheck
22:22:49 <Cale> What is the type of xs?
22:22:50 <ahr> what's going on?
22:22:51 <jle`> ahr: read is expecting a String
22:22:58 <dmj`> ahr: all elements in the list must be of the same type
22:22:59 <ahr> xs is [[String]]
22:23:05 <ahr> oh duh
22:23:11 <jle`> ahr: then x is a [String]
22:23:19 <ahr> as i said, very noob question
22:23:24 <Cale> Er, [x,y] is a [String]
22:23:26 <ahr> thanks!
22:23:30 <Cale> and x is just a String
22:23:37 <Cale> but read y :: Int is an Int
22:23:42 <ahr> yea, i'll just have to map to a tuple
22:23:45 <Cale> yeah
22:23:53 <jle`> if xs is [[String]], x is [String] and y is [String], and read wouldn't work
22:23:57 <ahr> forgot that lists are homogenous
22:24:05 <Cale> jle`: You missed the application of map there
22:24:13 <jle`> ah, yeah :O
22:24:28 <EvanR> noob question, earlier i was explaining foldl foldl' and was asked to explain why foldl exists at all and isnt just implemented as foldl'
22:24:37 <ahr> cheers
22:24:44 <EvanR> but i didnt have a good answer
22:26:06 <sleblanc`> @src foldl
22:26:06 <lambdabot> foldl f z []     = z
22:26:06 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:26:08 <Cale> Well, the real reason is that when Haskell was being specified, the assumption was that the compiler would figure out when the implementation ought to be something equivalent to foldl' and do that.
22:26:09 <sleblanc`> @src foldl'
22:26:09 <lambdabot> foldl' f a []     = a
22:26:09 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:26:26 <Cale> and in fact, GHC mostly does actually do this, if you have -O or better switched on
22:26:35 <EvanR> oh nice
22:26:36 <glguy> EvanR: You don't always want to be strict in the accumulator, the simplest case is when implementing "last"
22:26:53 <glguy> or searching a list from the end
22:27:03 <EvanR> i knew that last is an example of where it would make sense, but had no other example and last wasnt even that compelling
22:27:05 <Cale> But yeah, there are cases like last and reverse where you might actually want foldl
22:27:42 <EvanR> foldl to do last will build up thunks along the way uselessly right
22:27:54 <glguy> no
22:28:19 <glguy>  findFromBack p xs = foldl (\next x -> if p x then Just x else next) Nothing
22:28:45 <EvanR> that one actually makes sense
22:32:17 <EvanR> last = foldl (\next x -> next) undefined
22:33:45 <EvanR> er... x
22:33:58 <EvanR> > foldl (\next x -> x) undefined [1,2,3]
22:33:59 <lambdabot>  3
22:34:10 <EvanR> i see
22:34:18 <sleblanc`> > foldl (\next x -> next) undefined [1,2,3]
22:34:20 <lambdabot>  *Exception: Prelude.undefined
22:35:24 <EvanR> if you use foldl and dont use next, it quits early. however why doesnt it build the tree structure shown here, without knowing you wont need it? http://hongjiang.info/wp-content/uploads/2013/12/foldLeft.jpg
22:35:57 <EvanR> (also isnt this cale's foldl diagram)
22:36:14 <Cale> yes, it is mine, except grainy
22:36:28 <EvanR> its been repropriated to china
22:36:38 <glguy> EvanR: It might build up, actually, but that's the price you pay for deciding to implement last with foldl :)
22:36:48 <Cale> http://cale.yi.org/share/Folds.svg
22:36:52 <glguy> EvanR: foldl' is wrong because it forces all the elements along the way
22:36:56 <EvanR> yeah
22:37:09 <EvanR> still this use of foldl is still not very inspiring
22:37:20 <Cale> I guess it's really mostly reverse
22:37:35 <glguy> I prefer that that when functions are strict that that shows up in the name
22:37:46 <EvanR> ok ill go with that
22:37:50 <glguy> rather than having foldl quietly be strict and foldr be lazy
22:38:16 <Cale> and yeah, the original intention was that foldl' shouldn't actually be needed, ideally
22:38:16 <EvanR> other languages might make the choice to meddle with how functions behave without changing their name or indicating, like "you wont notice"
22:38:26 <Cale> (though strictness analysis is hard...)
22:38:50 <EvanR> > foldl (:) [] [1,2,3]
22:38:51 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
22:38:51 <lambdabot>      Expected type: [a] -> [a] -> [a]
22:38:51 <lambdabot>        Actual type: a -> [a] -> [a]
22:38:58 <EvanR> > foldl (flip (:)) [] [1,2,3]
22:39:00 <lambdabot>  [3,2,1]
22:40:50 <sleblanc`> > foldr (:) [7,8,9] [1..6]
22:40:51 <lambdabot>  [1,2,3,4,5,6,7,8,9]
22:41:04 <glguy> EvanR: In my quick little test case, implementing last with foldl isn't accumulating thunks as I search through [1::Int64 ..]
22:41:31 <Cale> glguy: Compiling with -O?
22:41:35 <glguy> definitely
22:41:53 <shachaf> last should be implemented with foldl
22:41:58 <Cale> Yeah, in that case, strictness analysis is probably figuring it out.
22:43:08 <Cale> foldl1 (const id)
22:43:13 <shachaf> foldl' last is a bug.
22:43:31 <shachaf> > foldl' (\x y -> y) (error "empty") [1,undefined,2]
22:43:32 <lambdabot>  *Exception: empty
22:43:41 <EvanR> for implementing reverse, is it so bad to force the list elements along the way?
22:43:47 <shachaf> Er.
22:43:52 <shachaf> OK, I mixed up two things there.
22:43:58 <glguy> EvanR: That depends on how expensive your list elements are to complete
22:44:00 <EvanR> oh yeah, because that would materialize the whole list
22:44:00 <glguy> compute
22:44:00 * shachaf sighs.
22:44:15 <EvanR> its not forcing the contents of the list though
22:44:41 <glguy> EvanR: Maybe each element of your list is the factorization of a large prime :)
22:44:53 <EvanR> but foldl' wouldnt mess with those
22:45:03 <Cale> Yeah, it's just the spine
22:45:03 <glguy> yeah, foldl' would
22:45:12 <Cale> foldl' won't touch the elements of the list
22:45:25 <EvanR> its evaluating (flip (:))'s
22:45:26 <glguy> when implementing last? sure it would
22:45:30 <EvanR> reverse
22:45:34 <Cale> When implementing reverse
22:45:37 <glguy> OK, I agree with reverse
22:46:03 <Cale> It also shouldn't touch the elements of the list with last...
22:46:07 <EvanR> and making it lazy kind of makes it worse since its a materialized list of thunks now
22:46:14 <Cale> Except the last one of course
22:46:19 <EvanR> instead of a list of list nodes
22:46:24 <Cale> Look at shachaf's command above
22:46:33 <Cale> > foldl' (\x y -> y) (error "empty") [1,undefined,2]
22:46:34 <lambdabot>  *Exception: empty
22:46:43 <glguy> Cale: foldl' is strict in the starting accumulator
22:46:47 <Cale> er, right
22:46:49 <glguy> so that example didn't really help
22:46:52 <Cale> yeah yeah'
22:47:04 <glguy> also it's going to find and evaluate that undefined
22:47:12 <Cale> yep, I agree now
22:47:29 <EvanR> studying the vagaries of foldr and foldl is like its own sub topic...
22:47:41 <Cale> > foldl1' (\_ y -> y) [1,undefined,2]
22:47:42 <lambdabot>  *Exception: Prelude.undefined
22:47:42 <glguy> You could insulate it like this: foldl' (\_ x -> Just x) Nothing
22:47:58 <EvanR> but i guess its really good since everything that you have to understand matters elsewhere in haskell
22:47:58 <glguy> > foldl' (\_ x -> Just x) Nothing [1,undefined,3]
22:47:59 <lambdabot>  Just 3
22:49:16 <Xnuk> > 'a':undefined
22:49:17 <lambdabot>  "a*Exception: Prelude.undefined
22:49:37 <EvanR> so which is better, foldl or foldl' for reverse
22:50:33 <EvanR> assuming strictness analysis doesnt deux ex machina 
22:51:28 <verrlara> Hi... having a problem and the #hakyll channel is very quiet. 
22:51:45 <st0opkid> hi, i know i can make natural numbers like "data Nat = Zero | Succ Nat", but what if i want to make binary or decimal numbers?
22:52:18 <verrlara> I am getting some errors trying to add a post to my haskell program hakyll and I can't seem to get it to behave itself. It seems to be a date related issue. I added imports and what not to make it behave itself I updated my template to match the date format and it still won't compile. Please someone help :<
22:52:35 <verrlara> [ERROR] Hakyll.Web.Template.Context.getItemUTC: could not parse time for posts/p1.markdown
22:52:41 <Xnuk> > "*Exception: " ++ Prelude.undefined
22:52:42 <glguy> EvanR: foldl, the foldl' does an extra but unneeded case
22:52:43 <lambdabot>  "*Exception: *Exception: Prelude.undefined
22:52:59 <EvanR> will forcing the spine take up less memory?
22:53:08 <lpaste> glguy pasted “reverse with foldl and foldl'” at http://lpaste.net/170487
22:53:13 <glguy> EvanR: no
22:53:28 <EvanR> oh nice
22:53:38 <wedens> ertesx: what's the difference between Codensity and ContT for resource management?
22:53:44 <verrlara> Were those bot replies after I posted my error?
22:54:42 <glguy> verrlara: No, the bot was replying to Xnuk
22:55:12 <verrlara> My apologies. 
22:55:27 * verrlara is a total haskell newb. But is learning fast from immersion xD
22:55:31 <EvanR> st0opkid: you can implement binary numbers pretty easily... one way is data Bin = One | I Bin | O Bin
22:56:42 <st0opkid> hrm, i guess i can see how you'd do the same for decimal
22:57:22 <Cale> verrlara: Apparently, looking at the source code for getItemUTC, it uses fail for whatever monad m you're using to give the error... I'm not sure which monads are instances of MonadMetadata though...
22:57:53 <st0opkid> can you then specify that it should use the binary form for execution of functions, and the decimal form for display?
22:58:03 <Cale> Oh, Compiler and Rules are, apparently, let's see how they implement fail...
22:58:24 <Cale> fail = compilerThrow . return -- Compiler...
22:58:25 <lpaste> verrlara pasted “default template - won't add markdown post” at http://lpaste.net/170489
22:59:02 <verrlara> didn't realize there was a beginners... page....
22:59:06 <Cale> oh, but Rules derives its instance from the one for RWST
22:59:08 <Cale> hmm
22:59:28 <Cale> verrlara: What are you referring to?
22:59:39 <glguy> http://hackage.haskell.org/package/hakyll-4.8.3.2/docs/src/Hakyll-Web-Template-Context.html#getItemUTC shows the supported formats
22:59:40 <Cale> verrlara: Don't worry, this channel is for beginners too
22:59:53 <EvanR> st0opkid: for display, you implement Show, which is usually decimal text
22:59:56 <Cale> verrlara: That other channel is just irritatingly mislabelled
23:00:10 <glguy> which can be deciphered using http://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Format.html#g:1
23:00:14 <verrlara> I apologize. I hope I am not bothering anyone. I am just trying to get it so it will accept my pure markdown blog posts. 
23:00:34 <EvanR> st0opkid: if youre just trying to get more efficient execution, you can use the already available typ Numeric.Natural
23:00:40 <Cale> verrlara: Yeah, I'm trying to figure out how you can deal with the exception it's generating...
23:00:46 <jamiejamiejamie> question for anyone who may know: why does the expression `axisMovePossible a x && axisMovePossible b y` evaluate fine, even though `axisMovePossible a x "blah"` doesn't? What I'm asking is, how does Haskell know that you're not trying to pass everything after the first `axisMovePossible` as an argument in the first case?
23:00:48 <verrlara> It is absolutely my firstday at haskell and that is a default template from hakyll-cssgarden off github.
23:00:56 <EvanR> glguy: what is the "types" count ?
23:01:30 <st0opkid> EvanR, well, i'm mainly trying to get an understanding of what's the proper way to implement these kinds of conversions in type theory
23:01:36 <ertesx> wedens: ContT has more effects than wrapping continuations, and it has an unnecessary extra type argument
23:01:43 <ertesx> wedens: that's why i prefer Codensity over ContT
23:02:18 <glguy> EvanR: I've apparently spaced out and have no idea what you meant
23:02:32 <Cale> It seems like I've been running into lots of cases where packages by jaspervdj have some annoying cases where they throw exceptions in ways that make them annoying to catch ;)
23:02:44 <ongy> jamiejamiejamie: '&&' is an infix operator while "blah" is just a string
23:02:52 <EvanR> glguy: http://lpaste.net/170487 what is "types: 6" reporting
23:03:14 <glguy> EvanR: No idea :)
23:03:15 <verrlara> Cale: Thats annoying :<
23:03:36 <jamiejamiejamie> ongy, right, but it's also a function, right? and you can pass functions as arguments ... but I suppose you'd have to wrap it in parens
23:03:41 <glguy> EvanR: I think that's part of the heuristic GHC uses to decide if it's OK to inline something
23:03:53 <ertesx> wedens: example ContT effect that is not a Codensity effect:  abort = ContT . const . pure
23:04:00 <verrlara> Cale: Cabal failed to install, so I did a repo install of it from the arch repo but since it was old I deleted just the haskell-hakyll bit and got the github latest master. 
23:04:01 <jamiejamiejamie> ongy, is this an order of operations question? or just the fact that it's an infix function?
23:04:27 <pavonia> jamiejamiejamie: It's only a function if you wrap it in parentheses
23:04:31 <verrlara> Cale: Let me post my errors one sec. 
23:04:33 <Cale> verrlara: Here's the source for the function which is throwing the exception: https://jaspervdj.be/hakyll/reference/src/Hakyll-Web-Template-Context.html#getItemUTC
23:04:50 <Cale> verrlara: Maybe we can figure out why it's landing in the exceptional case and sidestep it
23:04:57 <ertesx> wedens: basically anything that refers to the extra type argument is a ContT-exclusive effect:  abort :: r -> ContT r m a
23:05:29 <ertesx> (insert suitable context there)
23:05:58 <avalokite> So I'm kind of using haskell to better understand language(s) rather than writing computer programs, and at the moment, looking into all the ways a transformation, value, or representation can be typified purely to posit divergent types of knowledge-directed questions. Are there any known references to this subject matter?
23:06:02 <jamiejamiejamie> pavonia, huh, all right.. so there's some magic about operators after all? I guess that makes sense, otherwise how would they have different precedence from function application 
23:06:09 <avalokite> (excuse me if my question is totally off-topic)
23:06:15 <glguy> jamiejamiejamie: x && y    --- is   (&&) x y
23:06:29 <Cale> avalokite: I have no idea what that question means
23:06:40 <jamiejamiejamie> pavonia, if you use an operator as a function (&&) then at that point does it become left-associative and have the same precedence as function application?
23:07:04 <wedens> ertesx: so there is Codensity ~> ContT, but there is no ContT ~> Codensity?
23:07:07 <Cale> "typified purely to posit divergent types of knowledge-directed questions" -- can you rephrase this bit?
23:08:30 <lpaste> verrlara pasted “markdown page causes hakyll errors” at http://lpaste.net/170491
23:09:05 <pavonia> jamiejamiejamie: It becomes a function and it behaves the same way as a normal function, yeah
23:09:08 <ongy> verrlara: have you tried using different date: string?
23:09:21 <jamiejamiejamie> pavonia, ah, very interesting, that's useful information, thank you!
23:09:30 <Cale> verrlara: Can you change that to 2007-18-15?
23:09:39 <jamiejamiejamie> pavonia, so if it is _not_ used as a function, it is parsed "specially" as an operator
23:09:50 <verrlara> sure I can try that. 
23:09:59 <glguy> verrlara: You need a date like: 2016-07-18
23:10:05 <Cale> :t parseTime
23:10:06 <lambdabot> Not in scope: ‘parseTime’
23:10:14 <Cale> ah, too bad, can't test with the bot :)
23:10:26 <glguy> :t Data.Time.parseTimeM
23:10:28 <lambdabot> (Monad m, time-1.5.0.1:Data.Time.Format.Parse.ParseTime t) => Bool -> time-1.5.0.1:Data.Time.Format.Locale.TimeLocale -> String -> String -> m t
23:10:45 <glguy> verrlara: You have to use one of the date formats we've pointed out in the source code
23:11:54 <pavonia> jamiejamiejamie: Yes. Note that you can also turn any normal function in an infix operator by putting it into backticks, e.g. x `add` y
23:11:54 <verrlara> lord. wow. I am sorry. Midnight brainfart I guess.
23:11:54 <Cale> > Data.Time.parseTimeM True "%Y-%m-%d" "07-18-15"
23:11:55 <lambdabot>  Not in scope: ‘Data.Time.parseTimeM’
23:11:58 <Cale> nope
23:12:18 <Cale> oh, it also wants a locale
23:12:19 <Cale> ugh
23:12:22 <verrlara> It liked the date that glguy gave
23:12:36 <Cale> (but also I can't do it in the channel anyway)
23:13:03 <jamiejamiejamie> pavonia, but when you do that, how does it determine the precedence of the function? for example, x `myFunc` y `myFunc` z
23:13:06 <verrlara> Feel free to pastebin it  and I Will try it. I'd like to get it so it would do mm-dd-yy
23:13:19 <Cale> hmm, parseTimeM succeeds on that
23:13:28 <Cale> > parseTimeM True defaultTimeLocale "%Y-%m-%d" "07-18-15" :: Maybe UTCTime
23:13:28 <Cale> Just 0007-12-15 00:00:00 UTC
23:13:29 <lambdabot>  Not in scope: ‘parseTimeM’Not in scope: ‘defaultTimeLocale’    Not in scope:...
23:13:38 <glguy> Default operator precedence is infixl 9
23:14:17 <pavonia> jamiejamiejamie: There's a default precedence and associativity, but you can also change it with the infix(l/r) syntax
23:14:37 <jle`> infixr 5 `myFunc`
23:14:47 <jle`> same as for operators
23:14:52 <jle`> infixr 5 ++
23:15:02 <jamiejamiejamie> ahh, sweeeeeet 
23:15:13 <Cale> verrlara: Oh, are you Kat?
23:15:19 <avalokite> Cale: Asking questions, we may usually infer the type of response we'll recieve as expected by the type of question we ask (e.g, {what, where, when} {is, are, can, does, relation} {objective existence}). What I'm investigating is the types of signals which we may produce in questions in order to produce comprehensions of an equivalent type.
23:15:26 <glguy> Cale, I don't think they had blogs back then
23:15:36 <jamiejamiejamie> I can't seem to find this in the haskell 98 report.. does function application by default have 9 precedence? 
23:15:36 <Cale> verrlara: Oh, Kat was just the person who made the example...
23:15:42 <ertesx> wedens: yeah
23:15:47 <verrlara> Nope I am anna
23:15:54 <verrlara> Thats a free template
23:15:59 <verrlara> off github
23:16:05 <verrlara> from a lady named kat
23:16:34 <verrlara> Cale: correct
23:16:35 <Cale> I see, yeah. I've briefly met Kat in real life, when I visited New York.
23:16:45 <wedens> ertesx: ok. thanks
23:16:47 <ertesx> @let newtype Codensity m a = Codensity { lowerCodensity :: forall r. (a -> m r) -> m r }  deriving (Functor)
23:16:48 <lambdabot>  Defined.
23:17:07 <ertesx> :t ContT . lowerCodensity
23:17:08 <lambdabot> Codensity m a -> ContT r m a
23:17:18 <glguy> Jamie: function application has 10
23:17:27 <verrlara> Going to be going to ny in about two weeks. 
23:17:30 <verrlara> xD
23:17:39 <verrlara> Picking up my cat after visiting with my parents.
23:17:47 <jamiejamiejamie> glguy, oh! that's very useful information, thank you
23:17:50 <verrlara> They've looked after her for the last six months. 
23:18:32 <ertesx> wedens: ^
23:18:34 <Cale> avalokite: Apart from in the vaguest ways, I don't think type theory really has much to say about that kind of natural language issue...
23:19:17 <avalokite> Cale: For example, a question of type Who may be something like "Who is the main character in the story", a convergent question of type Why being, "why is the main character in the story sad?", divergent being of type when "When will the character in the story be happy?", evaluative of type What, "What are the charactaristics of the main character in the story?", etc.. 
23:19:19 <Cale> avalokite: I mean, you could look at how type classes let us express functions that are polymorphic in the type of their result, but the mechanism by which that occurs has no bearing whatsoever on how humans do it.
23:21:08 <Cale> glguy: haha, yeah, the year 7
23:23:00 <jamiejamiejamie> thanks for your help, everyone! goodnight
23:23:41 <Cale> #ReinstateHerodJr #JudeanPeoplesFront
23:23:54 <avalokite> Cale: Parametric-polymorphism, Equivalence Classes, and well, general Type Classes are all totally related. Let me see if I can make a bit more sense. Have a strong feeling you know something in this regard... I wonder though, are there any NLP-Haskell related channels I could check out?
23:24:22 <Cale> Yes, all of *those* things are related
23:25:50 <Cale> But type classes follow peculiar formal rules which are demonstrably not the rules that humans would follow while trying to make sense of natural language.
23:26:28 <avalokite> Is that a high-level insult? >_>
23:26:59 <avalokite> (joking!!)
23:27:01 <boj> those are the best
23:27:26 <Cale> Would it be an insult toward humans or an insult toward type classes? Who knows?
23:27:41 <ertesx> instance (Monad m) => Applicative m
23:27:45 <verrlara> Cale: So is it possible to adjust that format? to something like mm-dd-yy?
23:28:18 <Cale> But I dunno, I wouldn't expect type class instance resolution to closely mirror what's going on in a human brain while processing natural language.
23:28:31 <ertesx> definitely not
23:28:53 <Cale> verrlara: Not without editing the source of Hakyll, which you might just want to do.
23:29:32 <verrlara> ugh really? its that hardcoded? No worries. ^_^ I will look into it. 
23:30:02 <Cale> Yes, there's a hardcoded list of date formats for some inexplicable reason
23:30:31 <verrlara> so yyyy-mm-dd?
23:30:44 <verrlara> Just to make sure I remember properly
23:30:50 <Cale> https://jaspervdj.be/hakyll/reference/Hakyll-Web-Template-Context.html#v:dateField -- any of the formats given here
23:31:43 <nnon> Is there a preferred wrapper around the GHC API?
23:31:47 <Cale> and yeah, it's yyyy-mm-dd
23:32:30 <Cale> nnon: I haven't used any in a long time, but at one point I used hint a bit and it was decent for the scope of what it did
23:32:57 <nshepperd_> I took a nlp class in second year where we parsed english text by mapping the grammar to lambda calculus
23:33:26 <nshepperd_> representing words like 'nothing' and 'all' with a kind of cps transformation
23:33:44 <nshepperd_> it didn't seem like a very scalable approach
23:34:26 <verrlara> yikes. 
23:34:32 <verrlara> calculus is like latin
23:34:33 <verrlara> xD
23:34:48 <verrlara> ./tease
23:35:03 <Cale> Yeah, we're referring to a particular stone
23:35:42 <nshepperd_> the lambda stone, inexplicably more important than the eta stone
23:36:18 <ertesx> :t (<*>) pure pure id
23:36:19 <lambdabot>     No instance for (Applicative f0) arising from a use of ‘pure’
23:36:19 <lambdabot>     The type variable ‘f0’ is ambiguous
23:36:19 <lambdabot>     Note: there are several potential instances:
23:41:40 <pavonia> Given the following Parsec parser: `` let p = string "foo" <* optional (char ' ' *> string "foo") in  try p *> char ' ' *> string "bar" ``, is there a way to make that parse "foo bar" without changing p?
23:44:31 <verrlara> Cale: Thank you so much it seems to be working now. Now to get xmonad into shape and I am well on my way to having my 'neck beard' in line... oh wait I don't want a neck beard... I'd be a bearded lady. ew
23:44:47 <Cale> haha
23:45:34 <sleblanc`>  /msg NickServ info Verrlara
23:45:56 <avalokite> idk, ladybeards are pretty unique, totally different. Sound hot.
23:46:02 <nshepperd_> ._.
23:46:09 <Koterpillar> I hope "shape" wasn't a pun on shellshape
23:48:04 <ongy> avalokite: imagine a bearded lady and a really bearded guy kissing, and the beards tangle up so they can't let go of each other
23:48:18 <avalokite> ongy: now that's fashion!
23:48:36 <verrlara> xDDDDD
23:48:45 <quchen> pavonia: You’d have to un-consume the “ ” to do that
23:49:05 <ertesx> somehow i'm reminded of that cat proximity xkcd comic
23:49:07 <verrlara> I use a different window manager depending on the day but by far my favorite is xmonad. 
23:49:18 <quchen> pavonia: And there’s no way to find out whether “p” consumed a space
23:49:31 <ertesx> https://www.xkcd.com/231/
23:49:41 <pavonia> quchen: Hhm, okay
23:50:12 <shachaf> Cale: Yes, I was thinking of e.g. foldl1 vs. foldl1'
23:50:37 <Cale> shachaf: yeah, and I misread what it was that you actually wrote too :D
23:50:50 <shachaf> I miswrote it too.
23:51:02 <shachaf> Anyway when you're writing last you definitely want foldl, not foldl'
23:51:43 <EvanR> you definitely dont want foldl', but you probably want a direct recursion anyway to avoid the thunks
23:52:05 <EvanR> @src last
23:52:05 <lambdabot> last [x]    = x
23:52:05 <lambdabot> last (_:xs) = last xs
23:52:05 <lambdabot> last []     = error "Prelude.last: empty list"
23:53:04 <pavonia> quchen: Would that work with an attoparsec parser automatically?
23:56:35 <quchen> pavonia: I don’t think so. Parsing “foo bar” would parse “foo ” with p, and then fail to parse “ bar” because the space has already been consumed. Backtracking would only mean backtracking to where the last branching occurred, but there’s no branching in your parser (outside of p).
23:58:44 <Enigmagic> doesn't attoparsec backtrack on all failures?
23:58:59 <quchen> Yes, but backtracking doesn’t help here
23:59:16 <pavonia> Darn
23:59:37 <quchen> The space is consumed, p is successful, there is no need to backtrack back into it
