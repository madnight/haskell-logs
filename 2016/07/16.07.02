00:00:45 <nshepperd> this is where we need super syntax :) fake IsString magic so that "click" :: Proxy "click"
00:01:17 <texasmynsted> I know this is subjective, but given the styles here, which would be considered the most traditional style, or best one to start with as a beginner?   https://github.com/chrisdone/hindent
00:01:19 <EvanR> !@#$fake("click")
00:01:22 <dmj`> nshepperd: ooh :] 
00:01:51 <dmj`> nshepperd: maybe a type operator
00:02:26 <dmj`> @google haskell style guide
00:02:28 <lambdabot> https://github.com/tibbe/haskell-style-guide
00:02:31 <EvanR> texasmynsted: ... oh gross... hold on
00:02:40 <texasmynsted> oh?
00:02:44 <texasmynsted> Is there something better?
00:03:19 <dmj`> texasmynsted: I think that style guide may have been incorporated into haskell emacs mode
00:03:34 <texasmynsted> I am using neovim (vim)
00:04:26 <lpaste> texasmynsted pasted “No title” at http://lpaste.net/1759109434962870272
00:04:33 <nshepperd> dmj`: ahoy, we can actually get close enough with -XTypeApplications
00:04:54 <texasmynsted> I was trying to make 
00:05:03 <texasmynsted> hah I see one error after pasting… 
00:06:40 <EvanR> texasmynsted: hmm. this is my enter directly into where style to avoid a weird tiny where at the end of do notation http://lpaste.net/168730
00:07:22 <EvanR> though the example doesnt refer to anything significant to warrant thinking properly about refactoring
00:07:36 <koz_> Time to go space-leak-hunting...
00:07:41 <texasmynsted> looks nice
00:08:09 <nshepperd> dmj`: let p :: forall t. Proxy t; p = Proxy in p @"click"
00:08:36 <nshepperd> or just Proxy @ "click" if you feel like writing out lots of letters
00:08:54 <EvanR> i would move the case into another entry of the where somehow to avoid putting it in parens
00:09:04 <lpaste> texasmynsted revised “No title”: “No title” at http://lpaste.net/1759109434962870272
00:09:08 <EvanR> if i knew what it was for
00:09:20 <texasmynsted> what have I done wrong with formatting in this paste?
00:09:33 <EvanR> i hate putting where on the next line
00:10:30 <EvanR> http://lpaste.net/168731
00:11:02 <dmj`> onKeyPress :: On "keypress" = On $ \(e :: KeyBoardEvent) -> putStrLn "hi"
00:11:05 <dmj`> nshepperd ^
00:11:34 <dmj`> nshepperd: type applications?
00:12:14 <texasmynsted> oh you have the guard on the same line also
00:12:55 <texasmynsted> I wish I could gq a region and get it fixed up
00:13:21 <EvanR> heh
00:13:43 <nshepperd> what's On?
00:16:04 <dmj`> data On (event :: Symbol) where On :: IsEvent e => (e -> IO ()) -> IO ()
00:16:44 <dmj`> nshepperd: can we get the "click" from p@"click" using someSymbolVal
00:16:44 <nshepperd> oh, On :: forall s e. (NameToEvent s ~ e) => (e -> IO ()) -> On s
00:16:46 <nshepperd> nice
00:17:47 <nshepperd> p @"click" :: Proxy "click", so you can just use the normal symbolVal if you want a String out of it
00:18:19 <texasmynsted> Why does this not work? http://lpaste.net/168731
00:18:19 * hackagebot scientific 0.3.4.8 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.8 (BasVanDijk)
00:18:36 <texasmynsted> It seems that if I do mySum 3, I get 3 as the result
00:18:45 <dmj`> nshepperd: yea, but I want to put a String into it :]
00:19:28 <EvanR> texasmynsted: makes sense
00:19:37 <EvanR> 0 == 0
00:19:44 <EvanR> mySum is basically id
00:19:57 <koz_> Should my program be spending > 50% of its time GCing?
00:20:18 <texasmynsted> I was somehow expecting the parameter to become n
00:20:26 <EvanR> no its s
00:20:44 <nshepperd> dmj`: you'll need some pattern matching and a Maybe (or partial pattern) somewhere if you want to put an actual honest-to-god runtime String into the system anywhere here :)
00:23:14 <srhb> koz_: Depends what your program is.
00:23:32 <srhb> koz_: You probably wrote a program that spends a lot of time generating and collecting garbage, so probably yes. :-P
00:24:54 <EvanR> thats not supposed to be in haskells semantics ;_;
00:33:20 * hackagebot legion 0.1.0.0 - Distributed, stateful, homogeneous microservice framework.  https://hackage.haskell.org/package/legion-0.1.0.0 (taphu)
00:34:41 <texasmynsted> so this does what I want.
00:35:08 <texasmynsted> any suggestions on how to simplify or improve, knowing that I want to keep it a recursive function and not use a fold or anything?
00:35:11 <texasmynsted> http://lpaste.net/168731
00:37:27 <lyxia> texasmynsted: mySum 0 = 0 ; mySum c = c + mySum (c-1)
00:37:28 <EvanR> texasmynsted: align the | and write c - 1
00:38:15 <EvanR> i totally didnt notice what this function was trying to accomplish o_O
00:38:39 <lpaste> texasmynsted revised “No title”: “No title” at http://lpaste.net/1759109434962870272
00:38:46 <texasmynsted> like this?
00:38:50 <bjs> EvanR: that's probably a sign that it needs a refactor 
00:39:40 <EvanR> mySum n = n * (n - 1) `div` 2 ;)
00:39:50 <EvanR> hmm n+ 1
00:40:05 <texasmynsted> I am working a problem in a book.  Need to be recursive
00:40:29 <texasmynsted> The code returns the correct result
00:40:38 <EvanR> did you see lyxia's post
00:41:45 <koz_> OK, I have no clue as to why I have this gigantic space leak in one function.
00:42:10 <EvanR> koz_: accumulating a lot of computation without looking at the result?
00:42:21 <koz_> EvanR: I... don't know.
00:42:36 <koz_> And explaining what it does involves inspecting my six-file codebase, because it's kinda complex.
00:42:43 <EvanR> well.
00:43:10 <koz_> I know what it's *meant* to do, and I've ruled out some obvious places where it could leak, but beyond that I have no clue, and profiling isn't helping.
00:43:14 <EvanR> to the bat profiler
00:44:34 <koz_> Is there some kind of guide to 'find the space leak'?
00:44:47 <koz_> I'm using a bunch of Data.Vector operations, not on the mutable kind of vector.
00:45:12 <bjs> texasmynsted: uhm, are you sure your original function worked :) your (go (s + c) c - 1) won't ever hit a base case
00:45:30 <koz_> Also, some operations are being called an absurd number of times relative to what they should be.
00:45:46 <koz_> (like, a subroutine which is called by a function which does *one* call is being called over a million times)
00:48:20 * hackagebot fizzbuzz 0.1.0.0 - test  https://hackage.haskell.org/package/fizzbuzz-0.1.0.0 (paperlefthand)
00:49:25 <EvanR> koz_: calls?
00:49:33 <EvanR> hmm
00:49:43 <EvanR> yes there are a few blog posts about finding space leaks
00:49:45 <texasmynsted> Original, no.
00:49:50 <texasmynsted> This one yes http://lpaste.net/1759109434962870272
00:50:04 <texasmynsted> Anybody use hindent in vim ?
00:50:14 <texasmynsted> Can't seem to make it work
00:52:19 <koz_> EvanR: I have a function foo, which completes 1 call during profiling. foo, as part of doing its thing, calls a function 'bar' 6 times (in the code writeup). In my profiling report, 'bar' is called about 1 million times, but foo only 1 time.
00:52:52 <koz_> Also, could someone help me write a function that's just like replicateM, but instead of keeping track of all results of the monadic computation, only gives the last one?
00:53:17 <koz_> I'm guessing it should have a signature like 'doNTimes :: Monad m => Int -> m a -> m a', but I have no clue what its body should look like...
00:53:33 <EvanR> the concept of a call is trickier in haskell, if youre thinking of it like C
00:53:58 <koz_> EvanR: Maybe I don't understand what the profiling report is saying.
00:54:22 <koz_> EvanR: I'm referring to the 'entries' column.
00:54:34 <EvanR> you might be evaluating a function a lot accidentally, or also accidentally saving a result (which would usually save you some time, but maybe not memory)
00:55:47 <dysfun> ugh, i feel like ghc is deliberately trying to annoy me this morning
00:55:57 <koz_> dysfun: I was having similar feelings all of today.
00:56:18 <EvanR> entries, yeah sounds like youre using it 6 million times
00:56:26 <EvanR> maybe you dont understand your algorithm
00:56:44 * dysfun is pretty sure he doesn't understand his algorithm after half an hour of trying to satisfy ghc
00:56:59 <dysfun> moar coffee
00:57:03 <koz_> EvanR: Maybe not.
00:57:13 <koz_> But right now, I'm trying to write that 'doN' function above.
00:57:19 <koz_> And I have no clue if I'm even doing it right.
00:57:29 <EvanR> if (foo bar) is an expression used somewhere as an argument, then every place this expression goes will be a potential recomputation
00:57:42 <koz_> My goal is 'like replicateN, but chuck all results except the last'.
00:58:21 * hackagebot usb 1.3.0.4 - Communicate with USB devices  https://hackage.haskell.org/package/usb-1.3.0.4 (BasVanDijk)
00:58:31 <EvanR> hmm, no thats not good advice..
00:58:39 <caconym> koz_: are you sure this declaration that's being evaluated a million times isn't in a scope associated with iteration?
00:59:33 <koz_> caconym: I don't think so. Let me just put up the profiling report.
01:00:24 <lpaste> koz_ pasted “Profiling report” at http://lpaste.net/168732
01:00:51 <caconym> koz_: and not in a context that might muddy the waters e.g. the list monad?
01:03:39 <koz_> caconym: In that particular function, there's only one place this could interact with lists at all.
01:03:52 <koz_> Wait a minute...
01:03:56 <koz_> OK, I'm daft.
01:04:19 <caconym> figured it out? :)
01:04:40 <koz_> Yeah, and I think it was idiotic of me.
01:04:50 <koz_> I'm gonna confirm if I'm right, and if I am, I'm gonna kick myself.
01:05:16 <hawk78> Hi, I have       sumM' x y = (\x' y' -> (+) <$> pure x' <*> y')  <$> pure x <*> y   which is       sumM' :: (Num a, Applicative m, Applicative m1) => a -> m (m1 a) -> m (m1 a)
01:05:40 <caconym> koz_: don't kick too hard, we all have those moments
01:05:52 <koz_> Yep, I get it now.
01:05:55 <koz_> i was trying to sort an infinite list.
01:06:09 <koz_> I feel pretty darn intelligent now.
01:07:24 <hawk78> Can I write a function that does the same as sumM' but that can work for an y of type m (m1 (m2 ... (mn y))) where m, m1 ... mn are all Applicative?
01:07:48 <EvanR> nothing wrong with trying to sort an infinite list
01:07:58 <EvanR> everyone knows theres a well ordering of the reals
01:08:26 <EvanR> countable haskell lists should be a synch
01:08:31 <koz_> EvanR: Lol.
01:08:36 <koz_> Well, I am duly humbled.
01:08:46 <koz_> The space leak was in my brain.
01:10:25 <dysfun> ghc is actually trolling me
01:18:45 <EvanR> why is there no trollface emoji to use in ghc error messages
01:19:35 <EvanR> http://i.imgur.com/kEaGuSi.jpg
01:20:23 <dysfun> it's inevitably accompanied by feeling stupid and eventually realising how simple the bug was
01:46:06 <hawk78> How do I apply a function inside nested applicatives?
01:46:41 <EvanR> :t fmap . fmap
01:46:42 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:47:11 <EvanR> :t fmap . fmap ord
01:47:12 <lambdabot> Functor f => (a -> Char) -> f a -> f Int
01:47:39 <EvanR> ... huh
01:47:43 <hawk78> EvanR: can I do that for a generic level of nesting?
01:48:10 <EvanR> you do fmap . fmap . fmap . ... however many times it takes
01:48:27 <hawk78> EvanR: I mean...
01:49:24 <EvanR> :t (fmap . fmap . fmap) ord
01:49:25 <lambdabot> (Functor f, Functor f1, Functor f2) => f (f1 (f2 Char)) -> f (f1 (f2 Int))
01:49:33 <hawk78> can I write a function that can apply f to m(m(a)) or m(a) ??? 
01:49:57 <EvanR> probably but it wont be pretty
01:50:31 <cobreadmonster> lol
01:50:44 <EvanR> it might not be well defined either, since how will it know which level you want to modify
01:51:00 <dibblego> you might mean (m -> m -> a) -> (m -> a)
01:51:22 <hawk78> EvanR: It can use the type of the parameters of f
01:51:27 <cobreadmonster> EvanR: Isn't the composition of two functors also a functor instance?
01:51:47 <dibblego> Yes.
01:51:49 <EvanR> yeah
01:51:56 <dibblego> @type fmap.fmap
01:51:57 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:52:01 <hawk78> if f :: a -> b and I apply it to m ( m (a ))) I would like to get m ( m ( b))
01:52:13 <dibblego> let g ~ (f. f1) then this is (a -> b) -> g a -> g b
01:52:17 <EvanR> so its even less clear which one the function will pick
01:52:30 <hawk78> if f :: a -> b and I apply it to m(m ( m (a )))) I would like to get m( m ( m ( b)))
01:52:32 <cobreadmonster> EvanR: So you need just one fmap?
01:53:26 <hawk78> EvanR: for instance replace a with Int in my last two messages
01:53:30 <EvanR> > fmap fromJust [Just 3, Just 9]
01:53:32 <lambdabot>  [3,9]
01:53:51 <EvanR> > fmap fromJust [Just Nothing, Just Nothing]
01:53:52 <lambdabot>  [Nothing,Nothing]
01:54:00 <EvanR> aint workin ;)
01:54:34 <hawk78> Maybe I can use a typeclass with  TypeFamilies
01:54:49 <EvanR> you can probably figure out a convoluted way to do it with typeclasses
01:55:15 <EvanR> or lenses maybe
01:56:36 <EvanR> hawk78: what i was getting at earlier was.. what if a = b = Maybe c
01:56:40 <SpamPls> Guys, can I get help.
01:57:00 <EvanR> then will it stop at the first Maybe in the chain, or go to the last Maybe in the chain, or what, or how
01:57:49 <SpamPls> Permission to post a link?
01:57:55 <SpamPls> I just want people to go blow this page the fuck up.
01:58:07 <SpamPls> can people here do that pls.
01:58:15 <EvanR> ops
01:59:39 <EvanR> ignoring SpamPls for PMing
01:59:48 <SpamPls> Fucking faggot.
02:00:36 <cobreadmonster> hawk78: Look at compose.
02:01:22 <hawk78> :t compose
02:01:23 <lambdabot>     Not in scope: ‘compose’
02:01:23 <lambdabot>     Perhaps you meant one of these:
02:01:23 <lambdabot>       ‘icompose’ (imported from Control.Lens),
02:01:39 <EvanR> you mean type-compose the package?
02:03:01 <hawk78> EvanR: I would stop with the first maybe in the chain
02:03:48 <EvanR> then you might be able to do it with a typeclass
02:04:34 <hawk78> EvanR: cobreadmonster ^^^
02:04:59 <EvanR> or an alternative functor instance newtype for composed functors might exist in type-compose
02:05:11 <cobreadmonster> Yeah, the package.
02:05:17 <cobreadmonster> It's been a while since I had to use something like this.
02:05:21 <hawk78> Ah, ok
02:05:35 <hawk78> The rationale oround my request is...
02:08:28 <hawk78> isn't it difficolt/cluttered to read       sumM' x y = (\x' y' -> (+) <$> pure x' <*> y')  <$> pure x <*> y    when all you want is like    sumM x = f  <$$> x <**> y
02:08:47 <EvanR> use liftA2 (+)
02:09:02 <hawk78> but maybe you can suggest a better solution, a more idiomatic way to do that
02:09:12 <EvanR> :t liftA2 . liftA2
02:09:13 <lambdabot> (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
02:09:22 <EvanR> :t (liftA2 . liftA2) (+)
02:09:24 <lambdabot> (Num c, Applicative f, Applicative f1) => f (f1 c) -> f (f1 c) -> f (f1 c)
02:11:18 <hawk78> EvanR: in my case x is not into an applicative 
02:11:41 <EvanR> well then youll need 2 pures
02:11:48 <EvanR> around it
02:11:48 <hawk78> yup
02:12:38 <EvanR> you could also make a liftA2 that puts the pure for you
02:13:27 <barrucadu> :t \x y -> (\y' -> (x+) <$> y') <$> y
02:13:29 <lambdabot> (Functor f, Functor f1, Num b) => b -> f (f1 b) -> f (f1 b)
02:13:43 <EvanR> @djinn (Functor f, Functor f1, Num b) => b -> f (f1 b) -> f (f1 b)
02:13:43 <lambdabot> Error: Class not found: Functor
02:13:50 <EvanR> :exf (Functor f, Functor f1, Num b) => b -> f (f1 b) -> f (f1 b)
02:13:52 <exferenceBot> \ a -> fmap (fmap (fromMaybe a . pure))
02:13:52 <exferenceBot> \ a -> fmap (fmap (\ j -> fromMaybe j (pure a)))
02:15:00 <EvanR> er...
02:15:22 <EvanR> :t (fmap . fmap) (3+)
02:15:23 <lambdabot> (Functor f, Functor f1, Num b) => f (f1 b) -> f (f1 b)
02:15:31 <EvanR> right
02:18:40 <hawk78> mmm... it's a mess also with typeclasses
02:19:09 <EvanR> (fmap . fmap) (x+) is not what you are trying to do?
02:20:00 <hawk78> EvanR: yes, but also (fmap . fmap . fmap) (x+) 
02:20:14 <EvanR> at the same time?
02:20:33 <EvanR> im kind of skeptical 
02:20:41 <hawk78> no, not at the same time
02:21:10 <EvanR> however much code this would take, doesnt seem like its saving much 
02:21:29 <hawk78> I want to write a function that can apply the "minimum number" of fmap neede
02:23:01 <hawk78> I could my int inside a IO [Maybe [Ether String Int]] or inside a http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Int ...
02:23:19 <hawk78> whops I could my int inside a IO [Maybe [Ether String Int]] or inside a [[ Int ]] ...
02:24:04 <hawk78> I would like to call magicFmap (+3) myNestedApplicatives
02:25:14 <EvanR> :t lift
02:25:15 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
02:25:16 <hawk78> EvanR: do you see what I mean? A more generic fmap that can traverse the applicatives... I'm thinking if it could be possible to write one in haskell
02:26:35 <hawk78> :t liff (+3)
02:26:36 <lambdabot>     Not in scope: ‘liff’
02:26:36 <lambdabot>     Perhaps you meant ‘lift’ (imported from Control.Monad.Writer)
02:26:41 <hawk78> :t lift (+3)
02:26:42 <lambdabot> (Num a, MonadTrans t) => t ((->) a) a
02:27:11 <EvanR> :t lift (fmap (+3)) -- dont think this will work
02:27:13 <lambdabot> (Functor f, Num b, MonadTrans t) => t ((->) (f b)) (f b)
02:27:54 <hawk78> EvanR: I don't get it
02:28:03 <EvanR> me neither
02:28:08 <hawk78> :-)
02:30:03 <hawk78> Type level if is implement with type families, I think this is one possible thing to try, do you agree?
02:30:33 <EvanR> https://hackage.haskell.org/package/NestedFunctor-0.2.0.2/docs/Data-Functor-Nested.html
02:30:45 <EvanR> looks like it can be made to work
02:32:15 <EvanR> type compose would work if your example was a composition of IO, [], Maybe, [], and Either String
03:05:50 <lpaste> koz_ pasted “How would I write this?” at http://lpaste.net/168738
03:21:45 <lpaste> lyxia annotated “How would I write this?” with “How would I write this? (reply to koz_)” at http://lpaste.net/168738#a168739
03:22:34 <koz_> lyxia: Basically what I came up with after nobody responded for a while, lol.
03:22:41 <koz_> Although I used doN as a subroutine.
03:23:54 <koz_> Also, damn - I have a program in Haskell that needs < 7M of RAM.
03:23:57 <koz_> This has to be a first for me.
03:24:15 <kadoban> Haha nice
03:25:07 <koz_> kadoban: Amazingly, I didn't need any optimization or anything.
03:25:14 <koz_> It just ... magically worked well.
03:27:05 * koz_ eagerly awaits the day when he can just write the Haskell that runs well directly, instead of stumbling in the dark.
03:31:44 <dickbarends> @help
03:31:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:32:42 <dickbarends> @type map
03:32:43 <lambdabot> (a -> b) -> [a] -> [b]
04:11:26 <Xnuk> > map Just . map Left . map Right . (:[]) $ Nothing
04:11:28 <lambdabot>  [Just (Left (Right Nothing))]
04:18:25 <dickbarends> Cabal gives an error when installing hasktags on a mac. 'Ambiguous occurrence 'isSymbolicLink'. Anybody seen the same error?
04:20:18 <Peaker> Unqualified open imports strike again, I presume?
04:28:48 <maerwald> dickbarends: https://github.com/MarcWeber/hasktags/issues/23
04:31:42 <dickbarends>  mearwald: thanks. This helps very much:-)
05:05:21 <srpx> Hello. A type of a lib I'm using has a confusing Show instance. Can I derive a *second* show instance with the default deriver?
05:06:15 <maerwald> srpx: if it's confusing, it's likely a bug and should be fixed
05:06:15 <srpx> I'd like to inspect that type and the ones contained in the "(Constructor fields...)" format.
05:06:29 <maerwald> e.g. misusing Show for pretty-printing
05:06:45 <srpx> maerwald: it is confusing in a sense it pretty prints the type (an AST), but I can't figure out what constructor it is actually printing...
05:06:56 <maerwald> that's a bug
05:07:25 <srpx> maerwald: well that's the Show instance for LExp on Idris and it has been like that on the stable branch for years so I don't think that is going to change
05:07:33 <srpx> Isn't there a way to just ask GHC to derive a clean Show to me?
05:07:47 <hc> hi, any wai developers here? i've got question about the ParseSpec.hs file...
05:08:52 <maerwald> srpx: if "Show" omits information that is necessary to reconstruct the type, then that's a bug and should be reported, no matter how long it has been like that
05:09:25 <maerwald> @hackage pretty -- this is for pretty printing
05:09:25 <lambdabot> http://hackage.haskell.org/package/pretty -- this is for pretty printing
05:09:37 <srpx> maerwald: it doesn't omit info, it just prints them in a way I personally can't tell what is the constructor
05:09:37 <Jinxit> try reading the output and see if you get the same input back?
05:09:45 <Jinxit> oh
05:09:58 <srpx> maerwald: probably just lacking documentation and/or I didn't find the proper doc
05:10:20 <srpx> Let me show you
05:10:34 <pavonia> Yeah, some packages do that and it's one of the most annoying things, IMHO
05:12:10 <srpx> http://lpaste.net/168740 it isn't bad, doesn't look like it hides info, just I'm not sure what is going on and would like a proper `(Constructor fields...)` syntax to explore and figure it out
05:14:30 <srpx> For example, the `{e0}` there... what is it? There is LVar, and the constructors of Name. So it is probably a combination of those. But which combination? `Glob (UN "e0")`? `Loc 0`? `Glob (UN "e0" [])`? Etc...
05:15:08 <srpx> There must be a way to know? Maybe a GHC debugger? Anything?
05:15:38 <srpx> Maybe I should create another typeclass `show2` and just add instances myself?
05:16:00 <pavonia> srpx: Here's a hack I use in such cases http://lpaste.net/168741
05:19:34 <srpx> I think I get it
05:43:40 <hawk78> EvanR: ping
06:04:47 <troydm> how do I print out all packages using stack tha my hpackage is using, including hidden packages?
06:38:37 <ertesx> srpx: it's probably not a good idea, but i'm sure you can use -XStandaloneDeriving together with {-# OVERLAPPING #-}
06:38:57 <ertesx> srpx: a better way would be to fork the package and replace the Show instance
06:41:31 <Zearen> Is there a way to reserve an arbitrary number of function args ?  e.g. (a1 -> a2 -> a3  -> r) -> a3 -> a2 -> a1 -> r
06:43:15 <Zearen> The last time I did this, I built up an HList within the cont, reversed it, and wrote a type function to apply a function to an HList, but myy reviewer didn't like the HList...
06:50:42 <EvanR> Zearen: theres also the FunList
06:50:46 <EvanR> which is similar
06:52:01 <Zearen> Google is failing me, do you have a link ?
06:53:39 <Zearen> I mean, the code is funtional.  I just have an aesthetic issue with the combination function arguments neeeding to be specified in reverse order from that which the combinators are specified...
06:53:57 <Zearen> But 'tis the nature of cont.
07:01:34 <ertesx> Zearen: you could use a type class with Nat
07:02:59 <ertesx> or rather a list of types
07:04:02 <EvanR> Zearen: this is the link, for what its worth http://twanvl.nl/blog/haskell/non-regular1
07:04:51 <ertesx> Zearen: class Reverse (ts :: [*]) where type RevFunc ts; rev :: proxy ts -> …  -- something like that…  not sure how to design the type of 'rev' nicely, but it should be possible
07:06:28 <ertesx> Zearen: what are you trying to do anyway?  it seems like a bad idea to do this
07:06:57 <EvanR> varadic function!
07:07:02 <EvanR> on acid
07:08:05 <Zearen> Yeah, I'm looking some stuff in HList, and if I can hide the HList in the types, it *might* be OK.
07:08:17 <ertesx> Zearen: you can't
07:08:47 <ertesx> if you want the combinator to be sufficiently polymorphic, you *must* communicate the shape of the function
07:09:49 <Zearen> I mean, HList seems to be able to distinguish between funtion and not function in its Arity type funs, which gets me halfway there.
07:09:50 <EvanR> i dont think Zearen sufficiently defined what theyre really trying to do to make an impossibility judgment
07:10:08 <ertesx> you could get away only communicating the number of arguments, but that's the minimum
07:10:34 <ertesx> Zearen: what's the application?
07:10:38 <Zearen> I mean, this situation is non-optimal.  I have to speak carefully because confidentiality and stuff.
07:11:03 <tsahyt> Hello. I'm implementing an algorithm that works on a graph, so I've implemented it in terms of the fgl typeclass Graph. However, this graph is generated from a different structure and I think it'd be both nicer and easier to write an instance for a wrapper around this structure. But Graph is defined over (* -> * -> *), whereas carrying around parametricity for my type would be somewhat useless. Am I right to
07:11:04 <tsahyt> suppose that implementing an instance is impossible for something of kind *?
07:11:13 <Zearen> Yes, I recognize this is an XY question.  No, I cannot tell you what X is.
07:11:29 <tsahyt> fwiw I use fgl because DFS etc are already implemented for the Graph typeclass
07:11:59 <ertesx> Zearen: you don't need to reveal anything business-specific, but what application pattern are you trying to achieve?  it seems extremely unlikely that you will ever need this in a real application
07:12:11 <Zearen> ...
07:12:43 <EvanR> who needs more than 640k!
07:12:53 <EvanR> -- said no one ever
07:12:53 <tsahyt> EvanR: the ghc runtime for example
07:13:03 <ertesx> Zearen: (in haskell)
07:13:33 <Zearen> I have a clear business case for this.  The only reason I need reverse it is a side effect of how the function gets applied in cont.
07:14:08 <EvanR> you can reverse an HList
07:14:08 <ertesx> Zearen: is there a known limit on the number of arguments you are going to flip?
07:14:16 <Zearen> No.
07:14:27 <EvanR> but it sounds like youre trying to do a FunList
07:14:43 <ertesx> then yes, you're really just reversing a list
07:14:46 <Zearen> Yeah, something HList like was my original impl, but it was shot down.
07:15:28 <Zearen> It may just be that my sense of aesthetics and my reviewers aren't aligned...
07:15:37 <ertesx> the problem is that the compiler does not understand the arity of functions due to polymorphism…  you need to communicate it explicitly
07:16:13 <ertesx> 'id' is a function if 17 arguments
07:16:29 <EvanR> ...?
07:16:32 <Zearen> I mean, yes.
07:16:33 <EvanR> 1 arguments
07:16:54 <Zearen> Not if you pass a function of 16 args :p
07:17:02 <EvanR> whether a is a function is on another level as usual
07:17:18 <EvanR> a FunList has the same idea
07:18:12 <ertesx> in one interpretation the arity of every function is 1, which does not help…  in the other interpretation the arity of 'id' is itself flexible, and that doesn't help either
07:18:14 <Zearen> If the answer is: "no you, cannot,"  then that's the answer.  You don't need to insult my reasoning that this might be useful -_-
07:18:32 <EvanR> the result of a funlist function can be a function, or not. depends on when you say Done
07:18:38 <ertesx> Zearen: sorry, not my intention…  you can do this, but it's not going to be pretty
07:19:19 <EvanR> all functions have 1 argument, thats the most helpful ime
07:19:58 <ertesx> i don't know what FunList is, but my first impulse would be to use HList
07:20:16 <EvanR> it lets you do a variable number of arguments determined at runtime
07:20:16 <Zearen> Yeah...  I'd rather just build an HList, and apply a function at the end (well, originally I did a (a, (b, (c, ... (z, ()))) Hlist analogue because it simplified the interface, but still).
07:20:52 <ertesx> you can probably get away with just a proxy argument with a list of types
07:20:53 <EvanR> its a cool pattern
07:21:07 <ertesx> forall (ts :: [*]). proxy ts -> …
07:21:55 <Zearen> I mean, Cont really needs the innermost arg to be applied first, because of how currying works.  I thought about trying to do cleverness with flip inside the combinators, but this restriction prevents that...
07:22:23 <EvanR> no one wants to listen to meeee /me leaves
07:23:03 <ertesx> i think, everybody is thinking that right now =)
07:23:10 <Zearen> I mean, FunList sounds like what I want...
07:23:34 <Zearen> And yeah, reading that seems like what I want.
07:24:35 <ertesx> Zearen: how are you using Cont?  i mean, why do you need the flipping?  note for example that if you unwrap, it composes nicely using the usual combinators like (.)
07:25:18 <ertesx> :t \(ContT f) (ContT g) = ContT (f . g)
07:25:19 <lambdabot> parse error on input ‘=’
07:25:24 <ertesx> :t \(ContT f) (ContT g) -> ContT (f . g)
07:25:25 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ t -> t1
07:25:26 <lambdabot>     Expected type: (t2 -> t -> t1) -> t -> t -> t1
07:25:26 <lambdabot>       Actual type: (t2 -> t -> t1) -> t -> t1
07:25:29 <ertesx> meh
07:26:06 <Zearen> I'm adapting things of the form, e.g. (in -> io a) -> io (out a), which is clearly a type of cont.
07:26:16 <Zearen> (IxContT, specifically).
07:27:58 <Zearen> I hope I can convince $COMPANY to let me open source it...
07:28:25 <ertesx> Zearen: do you know how (.) is used in van laarhoven lenses?
07:28:56 <EvanR> i hookuped things like this in microtubes with a builder type, which is basically an hlist in reverse
07:29:06 <EvanR> nothing to do with cont though
07:29:30 <Zearen> Yes, sort of.  It's been awhile.
07:29:31 <EvanR> a hetero builder
07:30:02 <ertesx> Zearen: CPS functions compose naturally using (.) in reverse, if you require that they take an argument
07:30:27 <ertesx> @let CpsFunc a b = forall r. (b -> r) -> a -> r
07:30:27 <lambdabot>  Parse failed: Parse error in expression: b -> r
07:30:34 <ertesx> @let type CpsFunc a b = forall r. (b -> r) -> a -> r
07:30:35 <lambdabot>  Defined.
07:30:41 <Zearen> Ah, yes.
07:30:54 <ertesx> :t (.) :: CpsFunc a b -> CpsFunc b c -> CpsFunc a c
07:30:55 <lambdabot> CpsFunc a b -> CpsFunc b c -> (c -> r) -> a -> r
07:31:02 <ertesx> Zearen: does that help?
07:31:13 <Zearen> This... This is exactly what my first iteration on this problem did.
07:32:18 <Zearen> Oh wait.  I said IxCont.  This is a function changing @r@, which is why this is tricky.
07:32:37 <ertesx> shouldn't matter too much
07:32:57 <ertesx> @undef
07:32:58 <lambdabot> Undefined.
07:33:21 <ertesx> @let type CpsFunc s t a b = (a -> b) -> s -> t
07:33:22 <lambdabot>  Defined.
07:33:47 <ertesx> :t (.) :: CpsFunc a b c d -> CpsFunc c d e f -> CpsFunc a b e f
07:33:48 <lambdabot> CpsFunc a b c d -> CpsFunc c d e f -> CpsFunc a b e f
07:34:04 <ertesx> Zearen: that's pretty much what lenses do
07:34:10 <ertesx> they are just compositions of CPS functions like that
07:34:22 <Zearen> Yes, the input looks beautiful with iap, but when you finally do the runCont*, you need the innermost @m a@ and a -> f, just because of how Cont works.
07:34:29 <EvanR> with a functor thrown in for good measure
07:35:21 <Zearen> Which means the innermost type of the combinator must be the outermost function arg.
07:35:55 <ertesx> well, you can flip your type and construct a custom (.)-like operator that keeps it outermost
07:36:01 <Zearen> Which isn't a problem, I just think it's a non-intuitive API.
07:36:38 <ertesx> i think the API doesn't need to change except that you use (#!.%) instead of (.)  -- feel free to come up with a more intuitive name
07:37:15 <ertesx> as far as i understand, you need:  type CpsFunc m s t a b = s -> (a -> m b) -> m t
07:37:17 <Zearen> Yeah, I considered that, but now the arguments are reversed for the *input* adapting function.
07:37:36 <ertesx> is that what you need?
07:38:26 <Zearen> Er.  Let me be more explicit.  Thanks for your patience.  This is what's awful about closed source -_-
07:38:45 <ertesx> perhaps you should negotiate with your company first =)
07:39:40 <EvanR> you can also use >>> to compose
07:41:13 <Zearen> Say you have some class of functions c1 -> c2 -> ... -> cN -> m a.  You also have another class of functions (cK -> m a) -> m (cK, a) which is the only way to get these c types.
07:43:24 <Zearen> Er, (cK -> m a) -> m (hK, a)
07:44:49 <Zearen> This creates a bunch of code like
07:44:49 <Zearen> (h1, (h2, a)) <- makeC1 $ \c1 -> makeC2 $ \c2 -> cFun c1 c2
07:44:49 <Zearen> return $ f h1 h2 a
07:45:10 <Zearen> It seems this ought to be abstractable, which is what I'm doing.
07:46:09 <Zearen> I think I'll start looking at adapting this HList awfulness, so thanks ^.^
07:47:27 <Zearen> (The problem with flipping iap is that now *cFun* needs reversed.)
08:29:38 <saurabhnanda> glguy: I've got me RPi thing going. Is compiled GHC from source the first step? (I'm running into problems, btw). Is there no GHC binary available?
08:30:49 <saurabhnanda> *is compiling GHC from source
08:39:16 <saurabhnanda> on an RPi -- what is the GMP library used for? "error: cannot find -lgmp"
08:39:44 <monochrom> the Integer type. it's also true of linux windows mac
08:40:51 <saurabhnanda> okay, that's why GHC is failing. Btw, it doesn't detect that I'm NOT using Integer and not link against GMP accordingly?
08:41:26 <saurabhnanda> interesting.
08:42:12 <saurabhnanda> #offtopc -- anyone knows what exactly ARM is? It's a company, a standard, a governing body, what?
08:59:02 <Philonous> saurabhnanda, "ARM, originally Acorn RISC Machine, later Advanced RISC Machine, is a family of reduced instruction set computing (RISC) architectures for computer processors" (https://en.wikipedia.org/wiki/ARM_architecture)
09:02:31 <dmwit> Is there any mildly maintained mapping between base versions and GHC versions?
09:04:45 <sm> https://wiki.haskell.org/Base_package
09:05:29 <dmwit> Sweet, thanks.
09:07:18 <newcomer> So I'm running GHCi 7.8.4 and can't import Safe module. It's simply not there.
09:07:19 <newcomer> How can I remedy this?
09:07:43 <dmwit> Why do you believe this module should exist?
09:08:24 <maerwald> newcomer: by installing it
09:12:11 <tsahyt> @hoogle (a -> b) -> (a,a) -> (b,b)
09:12:13 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
09:12:13 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
09:12:13 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
09:13:18 <Cale> :t join (***)
09:13:19 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
09:13:31 <Cale> :t join (***) :: (a -> b) -> (a,a) -> (b,b)
09:13:32 <lambdabot> (a -> b) -> (a, a) -> (b, b)
09:13:37 <tsahyt> Cale: thanks!
09:13:52 <Cale> Not sure it's really any better than a lambda though :P
09:14:06 <tsahyt> I'm always in favor of making some use of Control.Arrow
09:14:17 <dmwit> :t bimap
09:14:18 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
09:14:33 <Cale> :t join bimap
09:14:34 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
09:14:35 <dmwit> :t join bimap :: (a -> b) -> (a, a) -> (b, b)
09:14:36 <lambdabot> (a -> b) -> (a, a) -> (b, b)
09:15:20 <dmwit> You may also like `data Pair a = Pair a a`, which (unlike `(,) a a`) also offers a `Monad` instance.
09:15:34 <dmwit> (And for which `fmap` is the operation you want.)
09:15:49 <tsahyt> the join (***) version actually ended up longer than just using f *** f (for an actual function f), but at least I don't repeat myself
09:15:55 <dmwit> :t fmap :: (a -> b) -> (Bool -> a) -> (Bool -> b)
09:15:57 <lambdabot> (a -> b) -> (Bool -> a) -> Bool -> b
09:16:03 <tsahyt> dmwit: Where is Pair defined?
09:16:14 <dmwit> dunno lol
09:16:21 <tsahyt> @hoogle Pair
09:16:21 <lambdabot> Data.Text.Internal.Fusion.Types data PairS a b
09:16:22 <lambdabot> System.Mem.Weak mkWeakPair :: k -> v -> Maybe (IO ()) -> IO (Weak (k, v))
09:16:22 <lambdabot> package despair
09:16:49 <dmwit> Looks like Data.Functor.Product offers `Pair Identity Identity` for that purpose.
09:16:50 <tsahyt> http://hackage.haskell.org/package/despair-0.0.6/docs/src/Despair.html#despair
09:16:52 <tsahyt> interesting package
09:17:20 <tsahyt> oh nice, Bifunctor is in base now
09:17:31 <tsahyt> well, has been for a while I suppose
09:18:56 <newcomer> maerwald, Thanks. Installed it through cabal.
09:19:01 <dmwit> Hm, the `ghc` package also offers it from the `Pair` module.
09:19:10 <dmwit> Not sure I'd want to depend on `ghc` just for this type, though. =P
09:19:20 <monochrom> haha
09:19:35 <dmwit> newcomer: What exactly did you install through cabal?
09:19:49 <dmwit> newcomer: (Again I ask: why do you believe the `Safe` module should exist?)
09:20:09 <maerwald> dmwit: I don't see how your questions are useful. He installed the 'safe' package obviously.
09:20:36 <maerwald> @hackage safe
09:20:36 <lambdabot> http://hackage.haskell.org/package/safe
09:20:42 * dmwit shrugs
09:20:44 <dmwit> Wasn't obvious to me.
09:20:54 <dmwit> Call me stupid. (You won't be the first.)
09:21:08 <monochrom> nothing is ever obvious. askers need to be trained to give more information. explain like I am not telepathic.
09:21:18 <dmwit> newcomer: What does `ghc-pkg list safe` say?
09:21:28 <dmwit> newcomer: What was the exact command you used to install the `safe` package?
09:21:36 <dmwit> newcomer: What was the exact command you used to start ghci?
09:21:49 <maerwald> erm
09:21:52 <newcomer> dmwit, just ghci
09:21:54 <tsahyt> I'm still confused why we don't have at least a subset of the safe package in base already
09:22:00 <tsahyt> things like minimumDef for example
09:23:05 <maerwald> dmwit: when a Module cannot be imported, it usually means the required package does not exist.
09:23:08 <dmwit> newcomer: I eagerly await the answers to my other two questions.
09:23:36 <tsahyt> or at least a minimumMonoid :: (Foldable t, Ord a, Monoid a) => t a -> a or something, 
09:23:39 <newcomer> sudo cabal update; sudo cabal install safe
09:23:41 <maerwald> the Safe module is provides by the safe package, there's not much more to know
09:23:48 <dmwit> maerwald: It can mean many things. It can mean you installed to a different package database than ghc is currently looking at, or that it had a build problem during installation, or many other things.
09:23:58 <monochrom> maerwald, if you think no further information is necessary, why haven't you solved the problem already? I eagerly await your solution.
09:24:08 <dmwit> maerwald: It could mean the installation went smoothly but the package is currently being hidden.
09:24:19 <maerwald> monochrom: the question was answered already and he said he has fixed it
09:24:23 <maerwald> I don't understand you.
09:24:40 <monochrom> ok good.
09:25:17 <maerwald> Safe is obviously not in base. One could argue about that, but...
09:25:37 <monochrom> "sudo cabal install safe" causes the problem.
09:25:47 <dmwit> Wow. That is some mind-reading right there. I see now that you interpreted, "Thanks. Installed it through cabal." as "I fixed it", but that was not at all clear to me.
09:26:13 <dmwit> (How are we to know that he installed it between asking the question and this message, and not before asking the question, for example?)
09:26:56 <maerwald> monochrom: you mean that's what fixed the problem
09:27:07 <dmwit> maerwald: No, that would not solve the problem.
09:27:10 <monochrom> No, read my http://www.vex.net/~trebla/haskell/sicp.xhtml#root
09:27:22 <dmwit> maerwald: You see, there are many ways to "install the safe package" and still not have ghc(i) see it.
09:27:25 <monochrom> that is, unless you already habitually "sudo ghci"
09:27:42 <monochrom> s/already/also/
09:27:50 <newcomer> Guys, problem already solved :) ... The question is, should safe package have been already available with my ghci installation?
09:27:50 <newcomer> dmwit, :)
09:27:51 <newcomer> dmwit, yes, I meant "I fixed it".
09:27:52 <maerwald> I know what sudo does
09:28:05 <dmwit> newcomer: No, GHC does not come with the safe package.
09:28:06 <maerwald> I don't even understand the confusion here
09:28:23 <newcomer> nor do I ... I'm confused with all this confusion :)
09:28:46 <monochrom> OK I see.
09:31:46 <dmwit> You can't be properly confused by something going right until you know how many ways it can go wrong.
09:32:51 <maerwald> or you are simply overthinking it
09:38:36 * hackagebot microlens 0.4.5.0 - A tiny lens library with no dependencies. If you're writing an app, you probably want microlens-platform, not this.  https://hackage.haskell.org/package/microlens-0.4.5.0 (Artyom)
09:38:38 * hackagebot microlens-ghc 0.4.5.0 - microlens + array, bytestring, containers, transformers  https://hackage.haskell.org/package/microlens-ghc-0.4.5.0 (Artyom)
09:38:40 * hackagebot microlens-mtl 0.1.8.0 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.8.0 (Artyom)
09:38:42 * hackagebot microlens-platform 0.3.2.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.3.2.0 (Artyom)
09:48:34 <marchelzo> hi
09:49:11 <marchelzo> could nub from Data.List run in O(n lg n) time if it required Ord in addition to Eq?
09:50:33 <Myrl-saki> marchelzo: yes
09:50:54 <Myrl-saki> marchelzo: I think you were in the discussion in ##programming a few months ago.
09:51:12 <marchelzo> about nub?
09:51:17 <Myrl-saki> marchelzo: Yeah
09:51:38 <Myrl-saki> marchelzo: I argued that nub couldn't be done below O(n lg n) time due to stability, and got proven wrong.
09:51:38 <marchelzo> hmm. if i was, i don't remember it :s
09:51:42 <Myrl-saki> O(n^2)*
09:52:01 <marchelzo> ah
09:52:21 <tsahyt> Myrl-saki: how can you nub in less than O(n lg n)?
09:52:33 <Myrl-saki> tsahyt: I meant O(n^2)
09:52:36 <tsahyt> ah okay
09:53:16 <Myrl-saki> marchelzo: One proposition(and the only one I remember) was to use a set.
09:53:36 <tsahyt> :t head . group . sort
09:53:38 <lambdabot> Ord a => [a] -> [a]
09:53:43 <saurabhnanda> the following program compiles on RPi, but give an error when exectuted: main = putStrLn "work!"  // main: schedule: re-entered unsafely. Perhaps a 'foreign import unsafe' should be 'safe'?
09:53:47 <tsahyt> that should be O(n log n) actually
09:53:55 <tsahyt> and should have the desired behavior
09:53:59 <Myrl-saki> tsahyt: unstable.
09:54:08 <tsahyt> how so?
09:54:20 <Myrl-saki> tsahyt: unstable in the sense that it changes the order of elements.
09:54:38 <tsahyt> ah, I had a different notion of stability in mind
09:54:58 <marchelzo> also, it doesn't nub
09:55:07 <Myrl-saki> marchelzo: it does.
09:55:25 <marchelzo> (head . group . sort) [1, 2, 1, 3, 1] would just be [1, 1, 1]
09:55:30 <tsahyt> I forgot a map
09:55:35 <Boomerang> > map head . group . sort $ [1, 3, 2, 3]
09:55:37 <lambdabot>  [1,2,3]
09:55:38 <Myrl-saki> oh woops
09:55:39 <tsahyt> yes, that's the one
09:55:40 <Myrl-saki> yeah
09:55:44 <Boomerang> > nub [1,3,2,3]
09:55:45 <lambdabot>  [1,3,2]
09:56:02 <sm> poor newcomer :)
09:56:59 <tsahyt> well at least unstable nub is trivially in O(n log n) then. trivial when you don't forget your map that is
09:57:15 <marchelzo> you could also augment all of the elements, and then nub, and then re-sort and de-augment them
09:57:24 <tsahyt> and I know that there's a O(n log n) version of standard nub too
09:57:29 <Myrl-saki> marchelzo: augment?
09:57:34 <tsahyt> requiring an Ord instance
09:57:51 <tsahyt> this one http://hackage.haskell.org/package/extra-1.4.10/docs/src/Data-List-Extra.html#nubOrd
09:58:06 <marchelzo> like, nub xs = ... (zip xs [1..])
09:58:19 <marchelzo> and then after the nub, you sortOn snd
09:58:24 <marchelzo> and then map fst
09:58:46 <Cale> saurabhnanda: That's the whole program? What happens if you build with -threaded?
09:59:05 <Myrl-saki> I believe insertrb == RBT?
09:59:17 <Cale> oh, saurabhnanda: https://ghc.haskell.org/trac/ghc/ticket/11190
10:00:17 <Myrl-saki> tsahyt: Yep, that's exactly the implementation I had in mind.
10:00:23 <marchelzo> > (map fst . sortOn snd . map head . group . sortOn fst . flip zip [1..]) [3, 1, 2, 4, 3, 1, 0]
10:00:25 <lambdabot>  [3,1,2,4,3,1,0]
10:00:32 <Myrl-saki> marchelzo: rip
10:00:33 <marchelzo> argh
10:00:42 <tsahyt> @hoogle sortOn
10:00:42 <lambdabot> No results found
10:00:48 <tsahyt> where's sortOn coming from?
10:00:56 <tsahyt> I've been sortBy (comparing foo) all those years
10:01:00 <Myrl-saki> :t sortOn
10:01:01 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
10:01:22 <Cale> > foldr (\x xs s -> if S.member x s then xs s else x : xs (S.insert x s)) (const []) [3, 1, 2, 4, 3, 1, 0] S.empty
10:01:23 <sm> newcomer: in case it wasn't clear, running cabal as root is strongly discouraged as it can lead to confusion
10:01:23 <marchelzo> > (map fst . sortOn snd . map head . groupBy (\a b -> fst a == fst b) . sortOn fst . flip zip [1..]) [3, 1, 2, 4, 3, 1, 0]
10:01:24 <lambdabot>  [3,1,2,4,0]
10:01:25 <lambdabot>  [3,1,2,4,0]
10:01:46 <tsahyt> turns out sortOn is in base O.O
10:01:54 <tsahyt> I should really start reading release notes
10:01:57 <Myrl-saki> trah-- Defined in ‘base-4.8.2.0:Data.OldList’
10:02:02 <maerwald> tsahyt: hoogle has very poor results, try http://hayoo.fh-wedel.de/?query=sortOn
10:02:02 <Myrl-saki> tsahyt: *
10:02:44 <Myrl-saki> maerwald: now we just need a duckduckgo pun.
10:02:53 <maerwald> :D
10:02:59 <Myrl-saki> any idea?
10:03:07 <maerwald> duckduckhaskell?
10:03:24 <Myrl-saki> confirmed. haskell > go.
10:03:30 <marchelzo> i should have written groupBy ((==) `on` fst)
10:03:41 <tsahyt> hackhack $ do
10:03:58 <Myrl-saki> tsahyt: naisu
10:04:00 <tsahyt> I'm no good at this
10:04:05 <newcomer> sm, Oh, I thought it will just install the package system wise. Now that you mentioned it I can see how it can be a security concern.
10:04:13 <Myrl-saki> oh oh i got it
10:04:18 <Myrl-saki> haskhaskgo
10:04:28 <Cale> The advantage of the foldr version is that it works with infinite lists
10:05:00 <Cale> > map (`div` 2) [0..]
10:05:01 <lambdabot>  [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15...
10:05:14 <Cale> > foldr (\x xs s -> if S.member x s then xs s else x : xs (S.insert x s)) (const []) (map (`div` 2) [0..]) S.empty
10:05:15 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:05:35 <sm> newcomer: that too
10:05:51 <Cale> and it's still O(n log n) for the first n elements
10:05:59 <marchelzo> ah, that is quite nice.
10:06:10 <Cale> (rather, processing the first n elements of the input)
10:06:49 <sm> cabal/stack should be used for installing packages at user or project level. Use your system's package manager for installing at system level (many haskellers skip this)
10:07:37 <marchelzo> you could nub in O(n) time for Bounded types
10:07:58 <Cale> Technically, this already does
10:08:06 <marchelzo> ah, right
10:08:17 <mrkkrp> Hi, can anyone help with this question https://stackoverflow.com/questions/38143464/cant-find-inerface-file-declaration-for-variable ?
10:08:19 <marchelzo> because the max size of the set is fixed
10:08:22 <Cale> yeah
10:08:37 * hackagebot Glob 0.7.9 - Globbing library  https://hackage.haskell.org/package/Glob-0.7.9 (MattiNiemenmaa)
10:10:28 <sm> mrkkrp: is it specific to the text package ?
10:11:31 <mrkkrp> sm: I have not tested this.
10:12:55 <mrkkrp> sm: I'll try to use liftData with other data types and see if it fails only for data involving text.
10:13:27 <sm> yeah, maybe build up from a minimal example and see when the problem starts
10:14:29 <mrkkrp> OK, I just wondered if this may happen to be a known issue, but apparently it is not.
10:14:55 <sm> I would bet money not. Worth asking #ghc maybe
10:15:58 <luca__> Hello is anyone around 
10:16:20 <hpc> the whole channel went to lunch at the same time
10:16:28 <hpc> all 1400 people
10:16:30 <maerwald> yes, ask later maybe
10:16:31 <hpc> ;)
10:17:02 <luca__> ahaha, I just want to ask people here about what type of things are you all hacking?
10:17:29 <maerwald> that sounds offtopic, or do you want a recommendation on what haskell project to work on?
10:17:29 <monochrom> metalic lunch boxes
10:17:53 <luca__> Yes can I have that please?
10:18:10 <maerwald> depends on what stuff you like and know about, I guess
10:18:42 <monochrom> I have a great idea. merge safe into base.
10:18:48 <maerwald> :o
10:20:21 <JeanCarloMachado> sorry 
10:26:10 <dmwit> sm++ for the base-to-GHC version mapping, forgot to bump him at the time
10:33:37 * hackagebot protolude 0.1.6 - A sensible set of defaults for writing custom Preludes.  https://hackage.haskell.org/package/protolude-0.1.6 (sdiehl)
10:50:17 <hwkng> is there a nice way to read large haskell codebases on an ipad ?
10:50:29 <hwkng> so the ipad won't have internet access
10:50:34 <hpc> look with your special eyes
10:50:38 <hwkng> I want to take a bunch of *.hs files, and somehow format it to be easy to read on an ipad
10:51:06 <hwkng> hpc: wtf
10:51:18 <hwkng> in particular, something that does **/*.hs -> pdf, with a table of contents with one entry for each file would be nice
10:51:24 <hpc> ah
10:51:34 <hpc> is a regular text editor not good enough?
10:51:42 <hwkng> I can do a2ps **/*.hs ->, ps -> pdf ; but then there's no TOC
10:51:53 <hwkng> hpc: this is for reading on an ipad without wifi, so I cna't ssh into a remote linux box
10:52:47 <EvanR> has anyone else had problems with pandoc putting extra space in the pre tag for code blocks...
10:53:31 <monochrom> hwkng: I don't know what software does this, but I think what you need is hyperlinked source code
10:54:43 <hwkng> monochrom: hyperlinks; yes, that'd be nicer; tapping ona function jumps to its definition
10:54:53 <cocreature> if you can save html to view it offline you could use the hyperlinked source code produced by haddock
10:54:54 <hwkng> we have haskell parsers; and we have html; why don't we ahve hyperlinked source code :-)
10:55:09 <cocreature> we do have hyperlinked source code :)
10:55:19 <EvanR> nevermind!
10:55:32 <monochrom> yeah, I heard that new haddock does it
10:55:47 <Zemyla> Is there such a thing as a comonad that's the "opposite" of a monadic parser?
10:56:18 <hwkng> comonad pretty-printer ?
10:58:19 <hwkng> anyone tried http://slidetocode.com/raskell ? thinking of dumping an entire coxebase into that
10:59:48 <Iceland_jack> hwkng: Hugs makes modern devlopment difficult
11:08:38 * hackagebot coin 1.1.1 - Simple account manager  https://hackage.haskell.org/package/coin-1.1.1 (piotrborek)
11:10:56 <quchen> hvr has a really nice version of Haddock that's not merged into master yet (for silly reasons if I recall correctly). If you look at the Hackage source of base modules you'll see nice links for every value.
11:24:16 <leshow> does anyone have experience with middlewars in Wai? i have a very simple (i think) problem
11:24:35 <leshow> there is a simpleCors middleware in Network.Wai.Middleware.Cors
11:24:46 <leshow> https://github.com/haskell-servant/example-servant-minimal/blob/master/src/App.hs#L27
11:25:11 <leshow> i just want to use it in something similar to this, but all the examples i can find use Application
11:25:23 <leshow> and my app type is IO Application
11:29:18 <opqdonut> leshow: the IO in mkApp is redundant
11:29:47 <opqdonut> you have the value serve itemApi server :: Application and you just wrap it in IO with return
11:30:01 <leshow> https://github.com/haskell-servant/example-servant-elm/blob/master/server/src/App.hs#L17
11:30:03 <leshow> sorry, this one
11:30:06 <leshow> where there is a DB
11:30:09 <opqdonut> ah right
11:30:11 <leshow> well, imitation db
11:31:01 <leshow> i found how to apply a middleware, if the type is application
11:31:08 <leshow> https://github.com/haskell-servant/servant-swagger/issues/45#issuecomment-219148710
11:31:10 <leshow> here
11:31:45 <leshow> or if the server type is Server ApiName instead of IO (Server ApiName) rather
11:32:05 <opqdonut> well then you just do it
11:32:22 <leshow> ?
11:32:34 <opqdonut> e.g. app = simpleCors . serve withAssets <$> server
11:33:19 <leshow> i dont understand why that works
11:33:26 <opqdonut> let me break it down
11:33:32 <leshow> i was trying like
11:33:52 <opqdonut> that's equivalent to: app = do s <- server; return (simpleCors (serve withAssets s))
11:34:33 <opqdonut> so you run the server IO action to get a Server X
11:34:54 <opqdonut> then you apply the simpleCors and serve functions to that
11:36:28 <leshow> i cant find the type signature of simpleCors anywhere
11:36:42 <leshow> i guess that's why it doesnt make much sense to me, how you knew how to compose them
11:37:33 <opqdonut> well the example you pasted tells me simpleCors takes in whatever server returns
11:37:45 <leshow> serve
11:37:47 <leshow> you mean
11:38:13 <opqdonut> serve, yes
11:38:21 <opqdonut> heh right the documentation is simpleCors :: Middleware
11:38:32 <leshow> yeah
11:38:52 <leshow> doesnt help much
11:39:09 <opqdonut> but Middleware is something like Application -> Application
11:39:16 <opqdonut> it's somewhere in wai's docs I guess
11:40:07 <opqdonut> here: https://www.stackage.org/haddock/lts-6.5/wai-3.2.1.1/Network-Wai.html#g:1
11:43:10 <leshow> thanks
11:43:59 <leshow> the do s <- server;
11:44:02 <leshow> in your above comment
11:44:19 <leshow> is s an IO (Server whatever) 
11:44:26 <leshow> or just Server whatever
11:45:19 <leshow> because the function sig shows IO (Server Api), does doing it inside a do block affect that
11:51:43 <maerwald> leshow: are you familiar with do notation and how it translates to >>= syntax?
11:54:49 <leshow> roughly, i know that it binds the previous statement to the next one, and the un-sugared form passes variables along
11:56:33 <leshow> but im confused about why outside of the do block i have to do use fmaps infix operator <$> in order to pass server to serve withAssets
11:56:50 <leshow> and inside the do block, it's sufficient to write serve withAssets s
11:57:07 <leshow> why is fmap no longer needed inside the do block
11:57:22 <dmj`> leshow: can you paste your code
11:57:42 <leshow> before we changed it?
11:57:42 <kadoban> leshow: Precisely because it desugars into uses of (>>=), which is more powerful than fmap
11:58:15 <Cale> Note that  f <$> x  is the same thing as  do v <- x; return (f v)
11:58:29 <Cale> (at least, whenever you know that you're working with a monad)
11:58:30 <leshow> Cale: oh i didnt know that
11:58:41 <maerwald> > do { s <- return 1 ; return (s + 1) ; } :: Maybe Int
11:58:41 <maerwald> > return 1 >>= \s -> return (s + 1) :: Maybe Int
11:58:42 <leshow> that makes sense then
11:58:43 <lambdabot>  Just 2
11:58:44 <lambdabot>  Just 2
12:00:11 <Cale> leshow: It should make sense if you think about what each one means
12:00:35 <Cale> f <$> x means the action which will run x, and apply f to its result
12:00:38 <leshow> i thought <$> was only for functors, and the do notation was in the realm of moands
12:00:40 <leshow> monads*
12:00:45 <Cale> yes, that is true
12:00:53 <Cale> But every monad is a functor
12:02:17 <Cale> In the same way that every square is a quadrilateral
12:02:31 <leshow> return x >>= \v -> return (f v)
12:02:35 <leshow> is that correct
12:02:37 <leshow> for
12:02:41 <leshow> f <$> x
12:02:42 <Cale> no
12:02:52 <Cale> x >>= (\v -> return (f v))
12:03:06 <leshow> you dont need the identity function on x?
12:03:13 <Cale> return x >>= f is always the same thing as f x
12:03:45 <Cale> So  return x >>= (\v -> return (f v)) would be the same as  return (f x)
12:04:19 <Cale> and we can perhaps more easily see that this doesn't have the right type
12:04:45 <maerwald> > Just 3 >>= (\v -> return (v +1))
12:04:45 <maerwald> > fmap (\v -> v + 1) (Just 3)
12:04:47 <lambdabot>  Just 4
12:04:47 <lambdabot>  Just 4
12:04:49 <Cale> since if f <$> x is going to typecheck, then f x probably won't
12:05:20 <Cale> (unless f is sufficiently polymorphic, in which case we'll have to use it at different types...)
12:06:17 <leshow> ok, i think i'd have to practice doing a few of these conversions for it to sink in better, thanks for the help 
12:06:41 <leshow> one more question
12:06:46 <leshow> is every monad also an applicative
12:06:56 <Cale> yes
12:07:09 <maerwald> Cale: but it wasn't always like that, was it?
12:07:11 <leshow> and since ghc 8, you can write applicatives with do also correct?
12:07:18 <Cale> mf <*> mx = do f <- mf; x <- mx; return (f x)
12:07:24 <leshow> with the ApplicativeDo language extension
12:07:38 <Cale> maerwald: Morally it was always like that, but the superclass constraints were missing until recently
12:08:00 <leshow> Cale: what you just wrote, the language extension needs to be enabled for that to work right?>
12:08:03 <Cale> no
12:08:09 <Cale> That equation is always true
12:08:13 <Cale> whenever you're working with a monad
12:08:27 <Cale> I'm assuming that we have a monad in the first place here
12:08:46 <leshow> oh i see, the language extension just make it desugar into applicatives instead of monad? for some cases where applicative is faster?
12:08:54 <Cale> yeah
12:09:02 <Cale> Into the Applicative operations
12:09:06 <maerwald> like parsers, which is probably the biggest use case I'd say
12:09:24 <reinh> Or things like haxl
12:09:27 <leshow> i cant remember the other applicative operation
12:09:29 <Cale> and you have to follow careful rules in order to avoid having it use Monad operations, if you don't really have a Monad instance
12:09:30 <leshow> <*> and
12:09:33 <reinh> leshow: pure
12:09:36 <leshow> <$> ? no thats fmap
12:09:37 <reinh> a.k.a. return
12:09:40 <maerwald> reinh: since when are you lowercase?
12:09:40 <leshow> right
12:09:50 <reinh> maerwald: since a few days ago
12:09:56 <Cale> Well, <$> is *also* available for Applicative functors
12:09:56 <maerwald> looks like a haircut :D
12:09:58 <leshow> the functor identity function is id?
12:10:02 <reinh> maerwald: should I go back?
12:10:14 <reinh> leshow: fmap id = id is an fmap law
12:10:19 <Cale> leshow: Not sure what you mean, but it is a law that fmap id = id
12:10:19 <maerwald> reinh: it's fine :P
12:10:43 <leshow> ok
12:10:59 <Cale> (in fact, if you only remember this law, you'll be okay defining functors in Haskell, since the other functor law, that fmap (f . g) = fmap f . fmap g actually is ensured by polymorphism and that first law
12:11:02 <Cale> )
12:11:03 <hpc> it takes time to grow out those capital letters
12:11:19 <reinh> hpc: :p
12:11:25 <Cale> reinh got a haircut
12:11:31 <reinh> indeed
12:26:22 <leshow> what is the most popular web framework, ive been trying servant
12:26:29 <leshow> but yesod seems really popular
12:26:35 <maerwald> snap is popular too
12:26:52 <maerwald> snap and yesod are the more "heavy" ones I'd say
12:27:04 <leshow> what's the "best" one lol, i realize that's a loaded question
12:27:07 <maerwald> although they are very different from each other
12:27:16 <leshow> i liked servant because of how you define routes
12:29:37 <suppi> depends on what you want to do
12:59:09 <dysfun> leshow: i found snap much easier to get things started with and yesod better for things after that
13:00:23 <maerwald> if you use Snaplets properly, it's fine with snap too
13:01:13 * dysfun is currently using raw WAI
13:05:43 <suppi> how does one even learn how to use snap these days?
13:06:07 <maerwald> start with visiting the homepage
13:06:29 <suppi> yeah i tried that two years ago
13:06:33 <dysfun> yeah, the best resources are on their website
13:06:41 <suppi> doesn't seem like anything changed since then
13:07:09 <Cale> suppi: Well, what are you stuck on?
13:07:44 <Cale> Maybe we can figure out what you need to do :)
13:08:07 <suppi> Cale, right now? nothing. i'm not trying anything. I used to try and wrap my head around all this snaplets stuff.
13:08:22 <Cale> ah, I haven't really looked at that part of snap myself
13:08:30 <suppi> how up to date is the documentation with what's going on on snap these days?
13:08:47 <Cale> I just get by with the haddock documentation which is necessarily up to date
13:09:11 <dysfun> haddocks are the best way to find individual functions in snap for sure
13:09:50 <maerwald> suppi: check out #snapframework
13:09:54 <suppi> yeah, haddocks are not enough for me to learn how to use a web framework. especially since i don't have much domain specific knowledge on web dev
13:14:16 <Cale> suppi: Usually you're going to want to write a server to handle HTTP requests, so you'll kick things off with something from here: http://hackage.haskell.org/package/snap-server-0.9.5.1/docs/Snap-Http-Server.html
13:14:31 <Cale> and then the Snap action you pass to that will say how requests get handled
13:14:47 <Cale> http://hackage.haskell.org/package/snap-core-0.9.8.0/docs/Snap-Core.html#v:route
13:15:31 <maerwald> http://snapframework.com/docs/tutorials/snaplets-tutorial
13:15:54 <maerwald> and even a video https://vimeo.com/59109358
13:15:58 <maerwald> not sure what your problem is
13:16:48 <suppi> i was just asking, has anything changed in the last 2/3 years since the docs were written?
13:16:53 <suppi> the tutorials*
13:16:57 <Cale> I guess if you want to do the snaplet stuff, you might do things a little differently
13:17:59 <Cale> I've never had to bother with the webserver being too complicated in the direction that snaplets appear to simplify things
13:20:36 <Cale> (we mostly write single page applications, so the application is served by the main route, and then we just have static resources and perhaps file uploads or something like that)
13:21:20 <maerwald> suppi: check the git repo if you want to know stats about the website
13:21:51 <suppi> Cale, I thank you for your good intentions, but I'm probably not going to learn how to build websites from reading a few lines on IRC
13:21:59 <suppi> please, forget i said anything.
13:22:03 <Cale> heh, sorry
13:22:26 <maerwald> suppi: we can't read the docs for you.
13:22:31 <Cale> It really doesn't have to be a big deal though. Depending on what sort of website you're building, your usage of snap might only be a few lines long.
13:22:33 <Cale> (in the code)
13:22:58 <suppi> Cale, for that i'd probably just use scotty or something.
13:23:06 <suppi> or servant, or happstack
13:23:07 <Cale> Well, sure
13:23:34 <Cale> Snap does have a lot of features though, and it's nice to be able to pick just one of them out of the pile whenever you happen to need it.
13:24:05 <Cale> But yeah, for the sort of stuff that I've used it for, probably Scotty would be not too bad either.
13:24:53 <Cale> If you start by just serving *something* then you can work your way outward from there, and not go too wrong
13:25:54 <Welkin> If I want to use a guard inside ST, will it work?
13:26:00 <Welkin> I don't see a MonadPlus instance for ST
13:26:14 <Cale> What would the MonadPlus instance do?
13:26:17 <Welkin> I'm writing an imperative loop that shuld break
13:26:28 <Cale> ST actions don't have multiple results, and they don't have catchable exceptions
13:26:58 <Cale> Usually the canonical answer is just to write it in a way that it decides on each iteration whether it should continue.
13:27:09 <Cale> You could use ContT though.
13:27:15 <Welkin> maybe I should use monad-loops?
13:27:27 <Welkin> I have never really done imperative programming in haskell before
13:27:40 <Cale> naah, it probably has something, but that library is full of stuff that you'll have to go look up what it means every time
13:27:46 <Welkin> I'm working with (mutable) vectors
13:27:59 <Cale> and you'll wish that you'd just written the recursive thing
13:28:23 <Welkin> hm
13:28:32 <Welkin> what is the best way to write programs like this then?
13:28:42 <Welkin> like an insertion sort on a mutable vector
13:29:32 <Welkin> plus I need to print out the progress after each swap, which means I should probably use Writer
13:30:04 <Cale> So you probably have as parameters the mutable vector, and the position of the first element which has not yet been sorted
13:30:10 <Cale> right?
13:30:23 <Welkin> yes, and the size (even though I don't need it
13:30:29 <Jinxit> what structure would you use to represent code like "a = 5; b = 2; c = a + b; d = c + a"? a tree? directed graph?
13:30:38 <kadoban> ssh
13:30:41 <kadoban> Woops
13:30:59 <dysfun> most code is a directed graph
13:31:05 <Welkin> Jinxit: a graph I suppose. Doesn't look like a tree
13:31:11 <Cale> Jinxit: A map from variable names to expressions?
13:31:50 <Welkin> working with these kinds of exercises lately has me thinking about where imperative programming style fits
13:32:07 <Welkin> it seems too low level for anything but C or assembly
13:32:13 <Welkin> it becomes difficult to do thos things in haskell
13:32:17 <Jinxit> I want to describe operations in a way that lets me parallelize some of it
13:32:26 <Jinxit> a and b are independent
13:32:35 <Jinxit> but both are needed for c
13:32:48 <Cale> Welkin: In my experience it's never more complicated in Haskell than it is in C.
13:33:07 <Welkin> Cale: modify state, print out result for this step, things like that
13:33:10 <Welkin> super easy in c
13:33:16 <maerwald> use IO
13:33:21 <Cale> It's pretty easy in IO as well.
13:33:24 <Cale> yeah
13:33:25 <Welkin> yeah, I don't want my whole program in IO
13:33:27 <Welkin> what's the point
13:33:39 <Cale> Well, the point is your whole program is IO, apparently.
13:33:47 <Welkin> I see what you mean
13:33:48 <maerwald> when I do imperative programming in haskell, it's mostly IO
13:33:52 <Welkin> but that is how this exercise works
13:33:55 <jeremyjh> you dont want your whole program in IO, so you want to use C?
13:34:08 <jeremyjh> haskell is a great language for imperative programming
13:34:27 <Cale> Welkin: Another option is to somehow model what the program would have done, produce some kind of data representing that purely
13:34:33 <Welkin> yes
13:34:36 <Welkin> I did that
13:34:37 <Cale> Welkin: and then transform *that* into an IO action to actually do it
13:34:42 <Welkin> and I would just use Writer for the output
13:34:48 <Cale> But meh
13:35:03 <jeremyjh> free monad is good too
13:35:07 <Welkin> I'm wondering about how to handle loops that need to break
13:35:07 <Cale> That's a nice step to take sometimes -- it makes the thing rather testable.
13:35:12 <maerwald> Cale: I think people often overdo this. If you are writing a framework like diagrams, that indirection probably makes sense.
13:35:16 <maerwald> but otherwise, I don't know
13:35:34 <Cale> But you need to do extra work to get extra benefit out of it. If you're not going to do that, then just writing the thing in IO is fine.
13:35:36 <Welkin> inside of ST, in particular
13:36:05 <Cale> You never *need* to write loops that need to break
13:36:19 <Cale> Well, okay
13:36:23 <dmj`> c_wraith: o/
13:36:27 <Welkin> I have done it in pure code before
13:36:33 <Cale> Here's a translation you can always apply which will work
13:36:43 <c_wraith> dmj`: So, what problems still need to be resolved?
13:36:43 <Welkin> I'm wondering how to do it inside of a forM_ "loop" though
13:36:46 <Cale> Local variables in scope become function parameters
13:36:52 <Welkin> which is why I asked about guard
13:36:57 <Cale> every point of control in the imperative program becomes a function
13:37:09 <Cale> the functions apply each other according to control flow
13:37:23 <Cale> like a finite state machine
13:37:28 <Cale> loops arise out of mutual recursion
13:37:48 <Cale> and you can break simply by applying the appropriate function for where the program needs to go next
13:38:11 <Cale> This will typically result in a mess at first, but it's an equational mess that you can immediately begin to simplify
13:38:40 <Cale> I've done this at times just to understand what some obfuscated C program would do
13:38:43 <Welkin> even when I imitate C in haskell, I still stay out of IO whenever possible
13:38:57 <Welkin> but I suppose I could imitate C almost exactly very easily if every function is in IO
13:39:02 <Welkin> which is esentially what C already does
13:39:08 <Welkin> I never thought of it that way thouhg
13:39:14 <Cale> yep -- and Haskell is still pretty beneficial even in programs of that sort
13:39:17 <dmj`> c_wraith: we need to exchange Proxy for an actual String, then use someSymbolVal to to get the Proxy and apply it to the type family, I think the type error is from the existential showing reluctance during the type family application
13:39:25 <Cale> You still have the nice fact that IO actions are first class
13:39:30 <jeremyjh> you still have excellent type system
13:39:41 <Cale> and so you can factor out any repetitive nonsense
13:39:49 <Cale> that you might not be able to in C
13:39:58 <c_wraith> dmj`: ah.  Yeah, you're going to have some issues.  That might be beyond what GHC supports right now.
13:40:59 <c_wraith> dmj`: the problem is going to be resolving the type family on an unknown type.  You would have to package up the type family resolution the existential somehow
13:41:19 <c_wraith> dmj`: but I think that actually doesn't work right.  
13:41:53 <c_wraith> dmj`: I think that has cause-and-effect issues.  You need to know the real type to get the type family to apply.  
13:42:35 <c_wraith> dmj`: but if the real type isn't known until runtime thanks to symbolVal, you're sort of stuck.  I don't think type families are reified for runtime use in any way.
13:45:05 <dmj`> c_wraith: isn't that what someSymbalVal is for? I fail to see the purpose of it if I can't do anything with the type it produces
13:45:26 <c_wraith> dmj`: you can use the KnownSymbol class on the value it produces.  that's all.
13:47:50 <c_wraith> dmj`: all it gives you is the ability to pass the original string around implicitly inside the KnownSymbol argument.
13:47:59 <c_wraith> dmj`: this is still short of dependent typing.
13:48:18 <c_wraith> Err.  Inside the KnownSymbol constraint as a sort of implicit argument.
13:49:42 <dmj`> case someSymbVal (str :: String) of SomeSymbol (p :: Proxy sym)... so the 'sym' here can't be used in a constraint?
13:50:52 <c_wraith> dmj`: it can only satisfy a KnownSymbol requirement, because that's the only thing packed inside the SomeSymbol constructor.
13:52:15 <dmj`> c_wraith: I see
13:52:38 <lpaste> koz_ pasted “jle`: How do I write doNKeep while working with MonadRandom?” at http://lpaste.net/168830
13:53:38 <dmj`> c_wraith: well, we tried
13:54:09 <c_wraith> dmj`: It's worth noting that you might be able to get more done with the singletons package.  It covers this sort of thing.
13:54:17 <c_wraith> dmj`: But I haven't used it, so I don't know for sure.
13:56:22 <dmj`> c_wraith: seems singletons has something similar to SomeSymbol
13:56:25 <dmj`> "An existentially-quantified singleton. This type is useful when you want a singleton type, but there is no way of knowing, at compile-time, what the type index will be. To make use of this type, you will generally have to use a pattern-match:
13:59:48 <dmj`> c_wraith: I bet there's a way to do this
14:24:01 <Ero_> Grettings  Haskelletors
14:24:22 <Ero_> I am a great noob and I request some assistance with delcaring typeclass instances#
14:24:36 <Ero_> Is anyone about who might help?
14:24:54 <koz_> Ero_: Which typeclass?
14:24:58 <Ero_> Monoid
14:25:11 <koz_> OK, what are you trying to declare a monoid instance for?
14:25:24 <Ero_> specifically, i want to delcare an instance for the Map type in Data.Map
14:25:51 <koz_> There already is one.
14:26:03 <koz_> 'Ord k => Monoid (Map k v)'
14:26:08 <Ero_> i believe there is a default implementation, i wish to provide my own, and the compiler is tellign me alsorts of bizarre things in my attempt to declare a newtype
14:26:24 <koz_> Ah, I see. Could you paste your up-to-now efforts?
14:26:34 <Jinxit> are there any good libs for runtime DAGs?
14:26:35 <koz_> (using lpaste)
14:27:11 <Ero_> yes, it is a little messy as i have redeefined my type declarations in desperation
14:27:27 <koz_> Ero_: It's fine - we just need to see what you've actually done before we can advise you.
14:29:00 <Ero_> koz_, please observe! http://lpaste.net/168836
14:29:57 <Ero_> this is where i was at when i first concluded that type constructors are still magic to me
14:30:09 <fr33domlover> Jinxit, FGL?
14:30:27 <Ero_> this all worked until i attempted to declare an instance of Monoid, the types were working before this as intended
14:31:11 <Ero_> commends for koz_ if we win this game
14:32:37 <koz_> Ero_: So your idea is that you're combining the values using <>?
14:32:48 <koz_> And what is PlayerState?
14:33:07 <Jinxit> fr33domlover: I like this, thanks
14:33:46 <Ero_> this is my idea koz_ yes :) PlayerState is itself an instance of Monoid | newtype PlayerState = PlayerState { getPlayerState :: (Lifes, Credits, Hand) }
14:33:58 <koz_> OK, that would have been my *next* question.
14:34:02 <Ero_> i appreciate that it is a horrendous use of newtype. I am a massive noob
14:34:34 <koz_> And what's the error that you're getting from this?
14:34:48 <koz_> (annotate your paste with it if you could)
14:36:43 <Ero_> koz_, I have done this thing for you for me http://lpaste.net/168836
14:36:49 <Ero_> thank you kindly
14:36:59 <koz_> Ah, this.
14:37:12 * Ero_ great anticipation
14:37:28 <koz_> Basically, you're trying to declare a *specific* kind of Map as a Monoid. Haskell2010 is very strict about this and normally doesn't allow it.
14:37:36 <Ero_> oh
14:37:47 <Welkin> why not just make PlayerState a monoid?
14:37:50 <koz_> You wanna add {-# LANGUAGE FlexibleInstances #-} at the top of your file.
14:37:53 <koz_> Welkin: It already is.
14:38:14 <koz_> Apparently, Ero_ doesn't like the default Monoid instance for Maps for one reason or another.
14:38:28 <koz_> (although I suspect that it's exactly this anyway)
14:38:33 <Ero_> in this case koz_ , when the compiler first rejected this code i decided to change Players from a type to a newtype, although i got further errors
14:39:07 <Welkin> you mean a datatype?
14:39:08 <Ero_> I will try your solution and if it works i will be happy, but: is there a reason my implementation is against the compilers recommendation?
14:39:09 <koz_> Ero_: Nah, that's got nothing to do with it. Basically, if you want instances like that, you need FlexibleInstances. You might wanna read up about this extension in the GHC manual.
14:39:11 <Welkin> or a type synonym?
14:39:34 <koz_> Ero_: The Haskell2010 standard is very conservative about what instance declarations it allows.
14:39:51 <dysfun> sometimes a bit too conservative, but that's why we have extensions
14:39:56 <koz_> I dunno precisely why - that's just what I've been told. I'm sure some of the smarter people on this chan could fill you in.
14:40:12 <koz_> But yeah, Ero_: Read up on FlexibleInstances in the GHC manual if you want the low-down.
14:40:26 <Ero_> if i may trouble you further koz_ with one more q: is there any negatives/pitfalls to using the language pragma, or can i carry on ignorantly? 
14:40:34 <Ero_> i will indeed read the manual in any case
14:40:38 <koz_> Ero_: Provided you don't mind always using GHC.
14:40:45 <koz_> (since it's a GHC extension AFAIK)
14:40:49 <Ero_> not in the slighest :) 
14:41:01 <Ero_> many thanks for your assitance with this, i will try it now
14:41:06 <Ero_> sorry for ignoring you, Welkin 
14:41:11 <koz_> Ero_: No worries! This channel's friendly, always ask.
14:42:15 <Ero_> it is now compiling koz_ :) thank you graciously 
14:42:24 <koz_> Ero_: :)
14:44:10 <Ero_> MONOIDS ARE SO COOL 
14:44:27 <hexagoxel> Ero_: http://dev.stephendiehl.com/hask/#the-benign
14:44:33 <hexagoxel> and above and below
14:47:04 <koz_> Ero_: Monoids are, indeed, a rather cool thing.
14:50:26 <buttbutter> So I have a type Size as defined here: http://lpaste.net/168842 . Why is it that when I load this module into ghci, I can do things like (Size 2) > 2? I understand it's because of deriving (Num), but what exactly is going on?
14:51:07 <hexagoxel> are there min/max monoids in base? why not? because Ord does not provide mzero with no clear choice for an additional constraint?
14:51:27 <Maxdamantus> :t 2
14:51:28 <lambdabot> Num a => a
14:51:46 <Maxdamantus> buttbutter: `2` also has type `Size` there.
14:52:07 <irisEmerald> Get
14:52:11 <irisEmerald> Hey*
14:53:34 <buttbutter> Maxdamantus: Can you give me a feeling of what the implementaiton of (>) looks like in this scenario?
14:54:16 <Maxdamantus> buttbutter: (>) has to have type `Size -> Size -> Bool` there, since it's applied a `Size`.
14:54:37 <Maxdamantus> buttbutter: so it will be the implementation from the `Num Size` instance.
14:54:47 <buttbutter> Okay, I see :D
14:54:53 <Maxdamantus> er, `Ord Size`*
14:55:04 <buttbutter> And the compiler generates all that for us from the deriving (Num)
14:55:14 <Maxdamantus> deriving Ord, yes.
14:55:17 <buttbutter> Or, right, deriving Ord
14:55:18 <buttbutter> Yeah.
14:55:23 <buttbutter> Okay. Cool. Thanks! :D
14:58:02 <Maxdamantus> hexagoxel: min/max would be semigroups, not monoids.
14:58:29 <Maxdamantus> Because yes, there's no identity element unless you're willing to come up with some upper bound.
14:58:38 <Maxdamantus> (or lower bound in the case of min)
15:03:13 <Ero_> thanks hexagoxel 
15:03:33 <hexagoxel> Maxdamantus: thanks.
15:03:34 <shachaf> But you can get a free monoid by adding infinity (or minus infinity).
15:03:59 <shachaf> Those types exist somewhere. Probably not base.
15:04:02 <marchelzo> you'd need an upper bound for to have a monoid where (<>) = min, no?
15:04:07 <Maxdamantus> or `minBound`/`maxBound`.
15:04:10 <marchelzo> not a lower bound
15:04:36 <shachaf> Yes.
15:04:47 <Maxdamantus> You'd need a lower bound for `max` and an upper bound for `min`.
15:05:20 <Maxdamantus> The maximum out of an empty set is the lower bound, the minimum out of an empty set is the upper bound.
15:05:43 <leshow> whats the difference between like import Data.Map as M and import qualified Data.Map as M
15:06:18 <marchelzo> unqualified imports bring all of the symbols from the imported module into the global scope
15:06:44 <marchelzo> so you'd have fromList and M.fromList
15:06:45 <Iceland_jack> marchelzo: You can also use something akin to "Nothing" as the bound
15:06:48 <leshow> isn't that just import Data.Map
15:06:52 <leshow> oh i see
15:06:55 <hexagoxel> (in my case i had 0 and only positive numbers in mind. and i cannot use semigroups for my use-case, but nonetheless good to keep in mind.)
15:06:56 <quchen> leshow: "import Data.Map as M" is the same as "import qualified Data.Map as M; import Data.Map".
15:07:05 <leshow> oh i see
15:07:11 <Maxdamantus> @check \a -> max minBound a == a
15:07:12 <lambdabot>  +++ OK, passed 100 tests.
15:07:18 <Maxdamantus> @check \a -> min maxBound a == a
15:07:20 <lambdabot>  +++ OK, passed 100 tests.
15:07:33 <quchen> Maxdamantus: I think that's using the () Monoid.
15:07:50 <Iceland_jack> Like 'Option a' (from Data.Semigroups) that wraps 'Maybe a'
15:07:50 <Iceland_jack>     instance Semigroup a => Monoid (Option a)
15:07:51 <quchen> @check \xs -> reverse xs == xs
15:07:52 <lambdabot>  +++ OK, passed 100 tests.
15:08:00 <leshow> ok, what about this. i have seen stuff like
15:08:03 <quchen> Lambdabot has awkward defaults sometimes.
15:08:04 <Maxdamantus> Oh, lame.
15:08:07 <Maxdamantus> @check \a -> min maxBound a == (a :: Int)
15:08:09 <lambdabot>  +++ OK, passed 100 tests.
15:08:18 <leshow> import Servant ((:<|>)(..))
15:08:21 <leshow> whats the extra
15:08:22 <leshow> (..) for
15:09:11 <Maxdamantus> @check \xs -> reverse xs == (xs :: [Int])
15:09:13 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 4 shrinks):
15:09:13 <lambdabot>  [-1,-2]
15:09:24 <quchen> leshow: The syntax is "import (Type(Constructors))". You can write "(..)" to import all constructors, e.g. "import Data.Sequence (Seq(..))". Servant happens to have a data type called "(:<|>)".
15:09:45 <quchen> leshow: Putting this all together, this means that the type :<|> with all its constructors is imported.
15:09:59 <leshow> gotcha
15:10:19 <quchen> Constructors like that aren't standard Haskell, but the TypeOperators GHC extension allows for infix type names.
15:10:42 <quchen> In Haskell, constructors are letters, TypeOperators also permits, well, operators.
15:11:00 <quchen> For the lack of a better word for "special character things like <>"
15:11:49 <leshow> i thought those special character things where just functions
15:12:14 <marchelzo> sometimes they are names of functions
15:13:11 <quchen> Special character things need not be functions. They are names like "map" and "pure".
15:13:40 <hodapp> hmm, I found myself using State Foo Svg, where Svg is just MarkupM () from Blaze... could turn this to StateT Foo MarkupM () but then I'd be using what looks like an internal type
15:13:49 <quchen> > let (+//+) = "hello" in reverse (+//+) -- leshow 
15:13:50 <lambdabot>  "olleh"
15:14:45 <quchen> leshow: It's just a syntactic thing. Special-character-things are infix, but can be made prefix by using parentheses around them, like (+). Word-character-things are prefix, but can be made infix by putting backticks around them, `elem`.
15:14:53 <leshow> i dont really get whats going on there lol
15:14:55 <quchen> Other than that, there's no difference.
15:15:11 <leshow> i know how to write infix
15:15:27 <hodapp> but in the former case I seemingly cannot lift Svg operations...
15:17:44 <Cale> Even without TypeOperators, you're allowed to have type constructors whose names start with colon
15:18:30 <hodapp> yes, Ivory makes use of that
15:20:53 <quchen> Cale: Oh?
15:22:54 <c_wraith> @let data a :=: b = a :=: b
15:22:55 <lambdabot>  Defined.
15:23:20 <c_wraith> :t 5 :=: ()
15:23:21 <lambdabot> Num a => a :=: ()
15:23:39 <c_wraith> Not sure whether lambdabot has TypeOperators enabled, though
15:23:39 <Cale> Before TypeOperators was a thing, you were also allowed to have infix type variables
15:23:51 <Cale> and it makes me a bit sad that you can't anymore
15:24:04 <c_wraith> I'm kind of glad that's gone.  ~> made type signatures really hard to read.
15:24:06 <Eduard_Munteanu> :t (':=:)
15:24:07 <lambdabot> parse error on input ‘:=:’
15:24:16 <Cale> (Arrow (~>)) => ...
15:24:23 <Cale> was pretty much essential for using Arrow :P
15:24:25 <Eduard_Munteanu> @kind (':=:)
15:24:26 <lambdabot> parse error on input ‘:=:’
15:24:44 <c_wraith> Eduard_Munteanu: does lambdabot have DataKinds enabled?
15:24:53 <Eduard_Munteanu> Probably not, just testing. :)
15:25:14 <Eduard_Munteanu> (I'm not even sure that's the right syntax for lifted type operators.)
15:25:27 <leshow>  "hello" in reverse
15:25:30 <leshow> how is that valid
15:25:32 <leshow> the 'in'
15:26:57 <Eduard_Munteanu> leshow, "in" is part of "let ... in ..." syntax
15:27:11 <leshow> OH
15:27:16 <Eduard_Munteanu> > let x = 3 in x + 2
15:27:18 <lambdabot>  5
15:27:29 <leshow> sorry, it didnt click in that context
15:27:40 <leshow> i almost always see it properly indented
15:36:01 <leshow> how does one import a module into ghci, like Control.Concurrent
15:38:13 <geekosaur> you can just write the import at the prompt
15:38:24 <geekosaur> or you can use :m +modulename
15:39:03 <leshow> yeah that last one works, it makes the prompt long htough when you import a bunch
15:39:12 <anilanar> why foldr (&&) False $ repeat False resolves to False immediately while foldr (&&) False $ repeat True does not?
15:39:36 <shachaf> > foldr f z [a,b,c,d]
15:39:38 <lambdabot>  f a (f b (f c (f d z)))
15:40:07 <shachaf> It's True && (True && (True && ...
15:43:36 <anilanar> ah I see thanks
15:46:21 <lpaste> tippenein pasted “how to avoid migrations like these?” at http://lpaste.net/168846
15:47:23 <tippenein> Any advice on how to avoid migrations like this? or maybe a better way to go about it?
15:48:56 <Cale> tippenein: uh, which library is that?
15:48:57 <abbe> hi
15:49:10 <Cale> Is that persistent?
15:49:13 <tippenein> the TH is persistent
15:49:29 <Cale> mkMigrate :: String -> [EntityDef] -> Q [Dec]
15:50:16 <Cale> makes a function that will perform any obvious migrations it can
15:50:40 <tippenein> this one must not be obvious then
15:51:15 <Cale> Ah, so you're already doing that at the start of the program?
15:51:18 <Cale> hm
15:51:43 <abbe> I remember coming across an Haskell at one of the Haskell related articles, where author mentioned something like "type Foo (a :: AnotherType) = ...." or was it newtype. I wondering if anyone knows more about this, specifying types for the type parameters
15:51:47 <Cale> oh, I see, yeah that's not an obvious migration
15:51:56 <abbe> s/an Haskell/an example/
15:52:06 <Cale> abbe: Those would be kind annotations
15:52:59 <Cale> and it's not really a type you'd put there, but a kind... however there is a feature called DataKinds which automatically turns many algebraic type definitions into kind definitions (and their data constructors into type constructors)
15:53:15 <koz_> Cale: Would you be able to help me with this? http://lpaste.net/168830 
15:53:27 <koz_> jle`'s not about right now, and I'm confused...
15:53:58 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#datatype-promotion
15:54:10 <Cale> koz_: what's up?
15:55:26 <abbe> Cale: thanks, although I'm pretty sure this was not it. Author's intent was to specify a "type" for the parameter a, to restrict its instances
15:55:36 <koz_> Cale: I'm not sure how to write the function I need in http://lpaste.net/168830 . I can do doNKeep if I have an 'a' and an '(a -> m a)', but I don't have that in the context of MonadRandom in any way I can see.
15:56:44 <Ero_> hey ppl its me again
15:57:04 <Cale> abbe: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XKindSignatures -- it was this, anyway
15:58:17 <Ero_> using Flexible Instances has allowed my program to compile but when i use the monoid in practise GHC tells me 'Overlapping instances for Monoid'
15:58:24 <Cale> koz_: I'm not sure I understand what you're trying to do with doNKeep if you don't have anything of that shape
15:58:51 <abbe> okay, thanks, maybe I'm mis-remembering.
15:58:53 <Ero_> referring to the default implententation of Monoid for Data.Map. Is there a simple way to make it distinguish my instance, without going to newtypes?
15:58:59 <Cale> koz_: It is *legal* to use doNKeep anyway
15:59:09 <nmattia> Ero_: you can say that your instance is 'OVERLAPPING'
15:59:18 <nmattia> Ero_: GHC should then pick yours
15:59:18 <koz_> Cale: The V.replicateM in the initCluster function.
15:59:25 <Cale> koz_: any m which is an instance of MonadRandom is also guaranteed to be an instance of Monad
15:59:42 <Ero_> ty nmattia 
15:59:52 <koz_> I wanna rewrite the use of V.replicateM to use doNKeepV, but I'm unsure how to define it.
16:00:01 <nmattia> Ero_: no worries. though you *should* use a newtype wrapper instead.
16:00:30 <nmattia> Ero_: instance {-# OVERLAPPING #-} Monoid (MyMap) where ...
16:00:50 <Cale> koz_: What are you trying to compute?
16:00:58 <Cale> I don't actually understand the intention of this code
16:01:22 <Ero_> due to your recommendation nmattia, i'll have to grok newtypes instead
16:01:29 <koz_> Cale: I want to run 'initialProc t', which returns 'm Processor' n times, but update the RNG each time.
16:01:31 <Ero_> which will make me cry, but this is a healthy thing
16:01:46 <Cale> koz_: MonadRandom keeps track of the generator state for you
16:01:48 <koz_> So the idea is I have something like 'x1 <- initialProc t; x2 <- initialProc t; ...'
16:01:50 <nmattia> Ero_: cathartic even
16:01:52 <Cale> koz_: So you just want replicateM
16:02:07 <koz_> So replicateM *does* update the state between calls?
16:02:18 <Cale> (well, not MonadRandom, that's the class, but any respectable instance of it)
16:02:35 <Cale> That's the whole point of Rand/RandT
16:02:53 <nmattia> Ero_: overlapping instances aren't terrible, the problem in your case is more that you're defining an instance in a module that's different than where your type was defined, the infamous "orphan instance"
16:03:11 <koz_> OK, that makes sense. I was just a bit confused about whether replicateM actually did that or not, or whether it just used the same state n times.
16:03:20 <nmattia> peeps, anybody to give me a hand with lens and type families?
16:05:42 <nmattia> alright then
16:07:52 <koz_> OK Cale - I'm convinced now. Sorry for the confusion.
16:08:04 <tippenein> Cale: actually, I think the migration worked, but only after I removed the sql=<name> .. I think you can't do a rename and a column type change at the same time?
16:08:36 <cheater> hello
16:08:53 <Cale> tippenein: hmm, I can't really claim to understand it
16:09:12 <cheater> Cale: am I right to say that monads are in Haskell because they're necessary for determinism?
16:09:20 <cheater> (one of the things they give us)
16:09:39 <Cale> We use groundhog for our client databases (which was forked from an early version of persistent and so is quite similar), but the migration stuff is all pretty magical
16:09:48 <Cale> cheater: Nope
16:09:59 <cheater> ok. why?
16:10:25 <Cale> Monad is an abstraction, it captures a pattern occurring in many libraries, gives it a name, and lets us write code which is abstracted over all those libraries
16:10:36 <koz_> cheater: http://dev.stephendiehl.com/hask/#whats-the-point
16:10:45 <koz_> This is a really good demonstration of why monads rock our world.
16:11:00 <Cale> The stuff you can write that will work with any monad tends to be control-structure-like stuff
16:11:23 <Cale> for a prototypical example, sequence :: (Monad m) => [m a] -> m [a]
16:11:29 <cheater> right but bind is the only way that i know of to provide deterministic execution flow
16:11:35 <cheater> in lambda calculus
16:11:55 <cheater> if you have x >>= f, then x *must* be evaluated before f can be evaluated
16:12:03 <Cale> We could write all the same libraries even if we didn't have the idea of monads
16:12:13 <Cale> and we didn't choose to abstract over >>=
16:12:16 <Cale> and return
16:12:23 <cheater> but then the execution flow would be dependent on implementation
16:12:25 <cheater> and undefined
16:12:32 <cheater> and the whole language would be completely random
16:12:33 <Cale> Each library could have its own way of gluing actions together
16:12:42 <Cale> and it really wouldn't even be all that bad
16:12:53 <cheater> gluing yes, but in lambda calculus, how do you force one action to happen before the other?
16:12:57 <tippenein> Cale: even Groundhogs migration stuff is magical?
16:13:01 <cheater> other than bind?
16:13:04 <Cale> cheater: that doesn't even make sense
16:13:05 <tippenein> this is still broken.. PersistMarshalError "field person: int64 Expected Integer, received: PersistText \"[[\\\"name\\\",\\\"sDonald Trump\\\"]]\""
16:13:12 <Cale> lambda calculus doesn't have any notion of time
16:13:17 <nshepperd> cheater: (>>=) :: IO a -> (a -> IO b) -> IO b
16:13:22 <nshepperd> cheater: no Monads there ^^
16:13:42 <cheater> nshepperd: nice
16:14:00 <cheater> Cale: but it does have a notion of sequence
16:14:08 <Cale> You could also probably write IO actions directly
16:14:23 <Cale> Note that the first couple versions of Haskell didn't even have an IO monad
16:14:27 <cheater> sure but then the sequentiality is not based in lambda calculus, and instead it is magical
16:14:29 <nshepperd> Monad is just the typeclass, you can do perfectly fine without it, using operators specialised to IO
16:14:31 <Cale> huh?
16:14:44 <Cale> The sequentiality already *isn't* based on evaluation in any way
16:14:52 <Cale> It's reflected directly in the data
16:14:59 <cheater> no i do not agree
16:15:03 <Cale> The order in which expressions are evaluated doesn't matter
16:15:10 <Cale> That's the point of having an IO type
16:15:11 <nshepperd> cheater: the rts handles IO
16:15:26 <Cale> IO actions are a concrete representation of what to do, in what order
16:15:39 <Cale> (it happens to be an abstract type, but it doesn't really have to be)
16:15:42 <cheater> yes but those io actions have to be stored in some structure
16:16:01 <cheater> and that structure is either 1. a haskell data type 2. something from outside the world of haskell
16:16:02 <Cale> Let's define a mock IO monad which is not abstract, just as a plain algebraic data type
16:16:11 <cheater> you can go with 2, but then that makes IO even more magical
16:16:39 <cheater> you can go with 1, but then how do you ensure things get executed in sequence within the rules of Haskell's logic?
16:16:40 <Cale> data IO a = Return a | GetChar (Char -> IO a) | PutChar Char (IO a) | ForkIO (IO ()) (ThreadId -> IO a) | ...
16:16:45 <cheater> sure
16:16:47 <Cale> ^^ something like this
16:17:01 <cheater> let's even just do Return .. | GetChar .. | PutChar ..
16:17:05 <nshepperd> (I'm ok with IO being magical, but this really has nothing to do with Monads either way)
16:17:13 <Cale> okay, no ForkIO you mean?
16:17:16 <Cale> sure
16:17:32 <cheater> so let's say you are going to do the following: get a char, then put a char.
16:17:38 <cheater> how do you encode this?
16:17:50 <Cale> GetChar (\c -> PutChar c (Return ()))
16:18:01 <cheater> nono, you get a char, throw it away, put another char
16:18:07 <cheater> you put a constant
16:18:10 <Cale> oh, okay
16:18:14 <Cale> GetChar (\c -> PutChar c' (Return ()))
16:18:28 <Cale> (or \_ -> ... if you prefer)
16:19:28 <Cale> and of course, we can write >>= in terms of this
16:19:37 <Cale> and regain all the expressiveness it gives us
16:19:38 <cheater> right so that's effectively an unary tree that you've built
16:19:48 <Cale> yeah, well, sort of
16:19:51 <koz_> Cale: Are you driving toward free monads perchance?
16:20:01 <Cale> GetChar is kind of like a very very wide branch node in a way
16:20:14 <Cale> koz_: We don't need to go there, but that's the technique I'm using here
16:20:19 <Cale> (just specialised)
16:20:21 <cheater> so let's say you put a char and then get a char
16:20:30 <koz_> Cale: I just wanted to check if I got the idea of what free monads were.
16:20:39 <Cale> PutChar c1 (GetChar (\c2 -> Return ()))
16:20:41 <cheater> you'd do PutChar c (GetChar (\_ -> Return ()))
16:20:43 <cheater> yea
16:20:47 <Cale> yep
16:20:52 <Cale> Let's write >>=
16:20:55 <cheater> no
16:20:56 <cheater> wait
16:21:15 <cheater> now what prevents a perfectly valid implementation of Putchar from executing its second argument before putting?
16:21:35 <Cale> What do you mean by "perfectly valid"?
16:21:47 <cheater> one that agrees with our type
16:21:59 <nshepperd> you don't 'implement' Putchar
16:22:00 <cheater> and everything we can encode in Haskell
16:22:04 <Cale> Well, you can write an interpreter which typechecks and does the wrong thing
16:22:07 <Cale> But that's okay
16:22:24 <Cale> You of course can't say in the type that it's got to deal with the termanal in some way
16:22:29 <cheater> yeah i do, because i'm on the Cale Haskell Compiler team and i'm implementing PutChar
16:22:45 <Cale> Who knows, maybe an alternate interpreter does something entirely different and talks over the network.
16:22:52 <cheater> and say i purposefully write a bad PutChar
16:22:52 <nshepperd> cheater: PutChar is just a constructor with two arguments
16:23:00 <nshepperd> there's nothing to implement
16:23:18 <Cale> cheater: Then you could have done so with any other implementation of the IO monad
16:23:25 <cheater> right, obviously I'm talking about how the RTS or some interpreter handles this
16:23:33 <cheater> Cale: i believe that is incorrect
16:23:40 <Cale> cheater: There's nothing about the concept of monads which prevents you from writing a bad interpreter
16:23:45 <nshepperd> you can implement an intepreter for PutChar, yes
16:23:45 <cheater> Cale: i believe that a monad precisely prevents this sort of thing
16:23:48 <Cale> This is actually a free monad
16:23:59 <Cale> and it has a valid monad instance
16:24:08 <cheater> it is not, it becomes a free monad once it's been put through Coyoneda etc
16:24:13 <Cale> huh?
16:24:24 <cheater> right now it is, as nshepperd said, just a bunch of data constructors
16:24:29 <Cale> It's pretty much exactly Free, already applied to a particular functor
16:24:38 <Cale> Let's write that functor
16:24:47 <cheater> wait a second..
16:24:48 <nshepperd> cheater: it is a monad
16:24:52 <cheater> let's not go that far yet
16:24:54 <Cale> data IOF a = GetChar (Char -> a) | PutChar Char a
16:25:07 <Cale> type IO a = Free IOF a
16:25:08 <cheater> i'm still unhappy with your argument from before
16:25:24 <cheater> you said i could write a broken monad instance from IO which would break sequentiality
16:25:28 <Cale> no
16:25:34 <Cale> You don't need a broken monad instance
16:25:39 <Cale> You just need a broken interpreter
16:25:41 <cheater> err broken RTS or something like that
16:25:43 <cheater> yes
16:25:49 <cheater> and i said that a monad purposefully prevents this sort of thing
16:25:54 <Cale> It doesn't.
16:26:06 <Cale> This type is after all a valid monad
16:26:12 <Cale> and we can write an incorrect interpreter for it
16:26:28 <cheater> if you have x >>= f, then how do you evaluate f before you evaluated x?
16:26:44 <Cale> Irrelevant
16:26:55 <Cale> Evaluation doesn't cause any of the effects to occur
16:27:25 <cheater> i disagree
16:27:39 <Cale> I'm sorry that you feel the need to be incorrect ;)
16:27:47 <cheater> here's my argument
16:28:22 <nshepperd> anyway, you don't have x >>= f, you have some concrete constructor value, such as 'PutChar c next', where the 'next' is there for the taking, plain as day
16:28:26 <Cale> Yeah
16:28:43 <cheater> the way >>= is made, it needs x to provide monadic context to f. to do this, x needs to go through the RTS (or interpreter) already. this easily lends itself to actually going forward and executing the IO action that x represents.
16:28:58 <Cale> cheater: Remember that your interpreter never even gets to see the (>>=)
16:29:08 <Cale> it only ever pattern matches on data constructors of the type
16:29:48 <cheater> i disagree, it's not the data constructors as they are written in data IOF
16:29:49 <Cale> I can write you a bad interpreter which will interpret this IO type into the real one, badly, if you like
16:30:01 <cheater> it's all been put through Free (which is the Coyoneda transformation)
16:30:19 <Cale> Free does nothing interesting vs. just having the extra constructors
16:30:23 <Cale> It's totally isomorphic
16:30:38 <cheater> it is my belief (but i haven't actually followed this through) that this encoding includes additional semantics that are isomorphic to bind
16:30:54 <Cale> Have you looked at the definition of Free?
16:31:25 <Cale> data Free f a = Return a | Free (f (Free f a))
16:31:48 <hodapp> oh, how timely
16:31:52 <Cale> So now instead of pattern matching on GetChar or whatever directly, it's pattern matching on Free (GetChar ...), big deal
16:32:30 <hodapp> https://github.com/Hodapp87/contextual/blob/master/Contextual.hs#L148 - why does the compiler complain that this line overlaps pattern match with line 188, when they're separate constructors?
16:32:42 <Cale> ahahahha
16:32:47 <Cale> how timely indeed
16:33:11 <Cale> hodapp: wtf
16:33:19 <Cale> hodapp: really?
16:33:31 <Cale> Make sure that it's compiling the correct file?
16:33:33 <hodapp> Cale: so, as far as you can tell, it should not be?
16:33:37 <hodapp> it's the correct file
16:33:49 <c_wraith> correct project?
16:33:52 <hodapp> yes...
16:33:59 <cheater> you sure you don't have issues with hidden characters or unflushed files?
16:34:13 <hodapp> yes, it's actually been doing this for weeks and I just didn't ask until now
16:34:27 <cheater> do this
16:34:33 <cheater> cat -v file.hs | vim -
16:34:36 <cheater> look at it that way
16:34:50 <cheater> see if after cat -v you get any syntax errors
16:35:23 <hodapp> nothing shows up there
16:35:30 <hodapp> this isn't an error, just a warning, but it's still confusing me
16:36:06 <Cale> OH
16:36:07 <Cale> lol
16:36:28 <Cale> er
16:36:51 <Cale> make it Free t rather than Free t@_
16:37:12 <Cale> It's parsing as (Free t)@_
16:37:17 * hodapp tries to figure out why he wrote t@_ in the first place...
16:37:21 <Cale> rather than Free (t@_)
16:37:31 <Cale> sneaky!
16:37:40 <hodapp> still complains
16:37:45 <Cale> well then
16:38:11 <Cale> It's complaining that Pure _ and Free t are overlapping?
16:38:40 <cheater> what is the exact warning?
16:39:23 <hodapp> http://lpaste.net/82197389053526016
16:40:39 <Cale> oh
16:40:44 <Cale> It doesn't mention Pure there
16:40:57 <Cale> It's saying that there are no other cases
16:41:02 <hodapp> neither did I
16:41:14 <m1dnight_> Is there a way to generate only postivie numbers? 
16:41:15 <hodapp> oh, hmm
16:41:15 <Cale> Did you handle all the cases?
16:41:22 <Cale> If you did, then it's dead code
16:41:44 <hodapp> probably, but I have that there because I keep forgetting to update the function
16:41:45 <Cale> and so the warning is saying that everything is already good
16:41:50 <koz_> m1dnight_: Define 'generate'.
16:41:57 <m1dnight_> Oh, I missed "random" :< Sorry
16:41:58 <koz_> How are you trying to obtain them?
16:42:06 <m1dnight_> Generate random positive numbers.
16:42:15 <koz_> m1dnight_: filter the non-positives?
16:42:22 <Boomerang> with a maximum bound?
16:42:31 <koz_> Like, use something like randomRs and feed the list to filter.
16:42:40 <hodapp> or, map abs.
16:43:01 <koz_> s/randomRs/randoms
16:43:05 <m1dnight_> I might have an XY problem here. I'm trying to generate short unique strings, like bitly. E.g., '1hdk3'
16:43:20 <m1dnight_> So I figured, just generate random positive integers and turn them into a string.
16:43:37 <koz_> m1dnight_: Do they need to be *completely* random, or are they 'random based on something'?
16:43:45 <koz_> If they're random based on something,, try hashing said something?
16:44:10 <m1dnight_> Well, I thought about that too. But then I would have to cut off the hash, right? To keep them reasonably short.
16:44:18 <koz_> m1dnight_: Many hashes have fixed sizes.
16:44:29 <koz_> And in fact, hashing makes a number, which has a limited size anyway IIRC.
16:44:30 <m1dnight_> Oh. I just noticed. When the string is long enough they are indeed shorter.
16:44:44 <Cale> m1dnight_: pretty much any of the random generator libraries you're going to use in Haskell will be able to generate random Chars from a given range
16:45:20 <m1dnight_> Hrm, if I use hashing I dont need to wrap this stuff in a state monad to keep track of the generator. So I think im going with hashing
16:45:32 <m1dnight_> Thanks guys!
16:45:35 <koz_> m1dnight_: The reason I asked is because oyu mentioned bit.ly.
16:45:36 <Cale> Though I suppose you might want to use a specific alphabet of Chars for some reason
16:46:06 <Heasummn> I might be going over board here, but I've got this line of code that I want to remove the parenthesis from
16:46:07 <Eduard_Munteanu> m1dnight_, it's easier to generate a fixed number of random chars from a range
16:46:21 <Heasummn> validate x =  (sumDigits . doubleEveryOther . toDigits) x `mod` 10 == 0 From CIS194
16:46:23 <Cale> What URL shorteners tend to do is just give you the next number, and encode it base 36 or whatever
16:46:46 <Boomerang> Heasummn> validate x =  sumDigits . doubleEveryOther . toDigits $ x `mod` 10 == 0
16:47:31 <Cale> shouldn't there be a 'map' in there somewhere?
16:47:43 <Cale> oh, no
16:47:48 <Heasummn> Boomerang, I tried that, but then it thinks I'm passing x `mod` 10 into the composition of functions
16:47:51 <Cale> Boomerang: that's, uh, not right
16:47:57 <Boomerang> Heasummn> validate =  (sumDigits . doubleEveryOther . toDigits . (0==) . (`mod` 10)
16:47:57 <Heasummn> I only want to pass in x
16:48:11 <Cale> validate = (==0) . (`mod` 10) . sumDigits . doubleEveryOther . toDigits
16:48:22 <Cale> Boomerang: still no
16:48:25 <Cale> heh
16:48:30 <Boomerang> ^^
16:48:36 <Cale> f $ x = f x
16:48:37 <Heasummn> alright
16:49:44 <srpx> what is "\case"?
16:49:58 <Cale> srpx: It's like (\x -> case x of ...)
16:50:13 <srpx> Cale: but what is the name of the language extension?
16:50:17 <Cale> LambdaCase
16:50:25 <srpx> Cale: thanks
16:50:30 <Cale> GHC will tell you if you just use it
16:50:31 <Cale> :)
16:51:27 <srpx> Are you sure? I just get a `parse error: naked lambda expression ''`.
16:59:18 <pavonia> srpx: For what input?
16:59:50 <srpx> pavonia: main = (\case { 1 -> print "a"; 2 -> print "b"}) 1
17:00:29 <srpx> 7.10.2
17:00:55 <pavonia> With the extension enabled?
17:01:31 <srpx> No, I think Cale meant that GHC would tell me the extension name if I used the feature without it.
17:01:41 <srpx> It works fine with the extension.
17:01:54 <Cale> srpx: ah, hm
17:40:49 <lpaste> tippenein revised “how to avoid migrations like these?”: “how to fix this migration script?” at http://lpaste.net/168846
17:49:19 <nocturne777> Iin new code, should we use Except instead of Either?
17:51:25 <nocturne777> nvm, question does not make sense :)
17:54:30 <m1dnight_> `(fromInteger (toInteger (256 :: Word32) :: Integer) :: Int)`
17:54:33 <m1dnight_> Does this seem sensible?
17:54:56 <m1dnight_> It looks like there is an easier way, no?
17:55:08 <EvanR> toInteger converts to Integer you dont need an extra annotation
17:55:11 <koz_> m1dnight_: fromIntegral is the thing you seek.
17:55:20 <koz_> :t fromIntegral
17:55:21 <lambdabot> (Integral a, Num b) => a -> b
17:55:23 <EvanR> and fromIntegral = fromInteger . toInteger
17:55:29 <m1dnight_> Ooooh
17:55:54 <m1dnight_> Nice. Thanks guys.
17:56:06 <m1dnight_> I was looking over the Data.word page on hackage but I couldn't find a link to the conversion functions.
17:56:55 <koz_> m1dnight_: fromIntegral is more general than Data.Word.
17:57:04 <koz_> That's likely why you couldn't locate it.
17:57:18 <m1dnight_> Well, makes sense now. Thanks guys :)
17:57:32 <m1dnight_> I believe I have asked this before. Long time ago. :D
18:00:16 <koz_> If I have overflowing sparks, what should I do?
18:01:01 <EvanR> m1dnight_: have this! https://github.com/haskellcats/haskell-numbers conversion tips at the bottom
18:01:18 <tippenein> So, I have a working migration script for Persistent now, but.. how do I insure it's run along with the other migrations and in the correct order?
18:02:07 <tippenein> It would be nice to have some sort of DSL for migrations to do simple things like drop tables and rename columns and such
18:50:02 <test11> hi anyone here?
18:50:23 <shachaf> No one who counts.
18:50:26 <test11> i am trying to understand monads and came across this http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
18:51:00 <test11> i am stuck at the randomized function part
18:52:12 <test11> if someone could help me out 
18:52:32 <pavonia> What exactly is your question?
18:53:00 <test11> well can someone give me an example of a randomised function?
18:53:05 <koz_> I have a parallel workload which intially saturates my cores, but then *suddenly* stops doing so about 10% of the way through. What could be a cause of this?
18:53:40 <koz_> I literally go from 95% CPU usage to like, 60% or so.
18:55:22 <pavonia> test11: That unit functions mentioned in the text is an example
18:55:36 <test11> ?
18:55:37 <pavonia> *function
18:55:50 <pavonia> unit :: a → (StdGen → (a,StdGen))
18:56:45 <pavonia> It takes an a as input and returns the same a without touching the seed
18:57:27 <test11> no i mean a example of f
18:57:42 <test11> in f * unit = unit * f = f
18:57:59 <test11> is f something like f x = x + 2 ?
18:58:10 <koz_> test11: How is * defined?
18:58:16 <test11> f::Int -> Int
18:58:44 <ertes> koz_: what parallelism abstraction are you using?
18:58:58 <koz_> ertes: Control.Parallel
18:59:37 <pavonia> test11: f must be of type a -> StdGen -> (b, StdGen)
18:59:39 <ertes> koz_: just to eliminate assumptions: are you sure that the algorithm is as parallel as you think it is?
19:00:00 <koz_> ertes: The part I'm parMapping is a list of completely independent subproblems.
19:00:26 <ertes> koz_: that's a different abstraction…  you are using strategies?
19:00:31 <koz_> ertes: Yes.
19:01:05 <koz_> I'm currently doing 'parMap rpar f xs' for a list xs, where f is an operation that depends only on an element of xs.
19:01:11 <test11> pavonia, well i am having trouble understanding randomized functions and their bind
19:01:16 <ertes> koz_: one thing to note about the basic parMap is that it does suffer from the peculiarities of lists, and also that the regular one actually insists on evaluating the whole list
19:01:40 <ertes> koz_: you probably shouldn't do `parMap rpar`, but rather `parMap rdeepseq`
19:02:09 <koz_> ertes: OK, I will try.
19:02:15 <ertes> koz_: the argument strategy specifies how each *element* should be evaluated, and normal form is usually what you'd want
19:02:32 <test11> in the other examples bind is a function that has signature    bind:: (t1 -> (t1, t2)) -> ((t1, t2) -> (t1, t2))
19:02:47 <EvanR> :t (>>=)
19:02:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:03:14 <test11> well i am not talking about >>= i am talking about the one in the page i linked
19:03:37 <pavonia> test11: A randomized function is a functinon that takes some input, a random generator (a seed), and retruns another value with the next seed
19:03:37 <EvanR> uh oh...
19:04:06 <test11> right, but can you give an example
19:04:08 <koz_> ertes: Ah, derp. That was my mistake!
19:05:02 <shachaf> You can just invent an example.
19:05:10 <shachaf> randomInt :: StdGen -> (Int, StdGen)
19:05:19 <test11> i got that
19:05:25 <koz_> ertes: OK, that *blows away* the previous run, and doesn't seem to drop off at the 10% mark.
19:05:43 <test11> what about f, in unit * f = f * unit = f
19:05:44 <shachaf> Actually that function is called "random".
19:05:46 <ertes> koz_: also see parBuffer, if your list is large
19:05:59 <shachaf> It doesn't matter what f is.
19:06:06 <koz_> What is 'large' in this context? I have about 65k items in said list - is this large?
19:06:17 <test11> shachaf, no i am asking for an example
19:06:23 <test11> of f
19:06:25 <shachaf> I gave you an example.
19:06:35 <koz_> ertes: Also,it seems I still get the drop-off as before - just a bit later.
19:06:45 <test11> is that example the same f as in unit * f = f * unit = f
19:06:52 <shachaf> random :: StdGen -> (Int, StdGen)
19:06:52 <ertes> koz_: yeah, that's large…  parMap is structurally strict in the list, so basically the first item of the list has the same complexity as 'last'
19:07:03 <shachaf> Or, I guess, not quite that.
19:07:15 <koz_> ertes: So parBuffer and tune for the right parameter, you think?
19:07:20 <pavonia> shachaf: I think it needs another parameter
19:07:32 <ertes> koz_: yeah
19:07:49 <koz_> ertes: OK, I'll give that a go once this run concludes.
19:07:52 <ertes> koz_: so use regular 'map' and then evaluate using parBuffer
19:08:05 <EvanR> pavonia: nah... StdGen -> (a, StdGen) is the "random action" here
19:08:10 <shachaf> OK. \x g -> let (y,g') = random g in (x+y, g')
19:08:20 <koz_> Can I write a 'parBufferMap' to do that, similarly to how parMap is defined, but with parBuffer instead of parList?
19:08:20 <test11> can i tell you where i am at?
19:08:28 <EvanR> i think the type of bind there is flipped 
19:08:29 <pavonia> EvanR: Yes, but it's not what they call a randomized function in that text
19:08:30 <ertes> koz_: sure
19:08:38 <koz_> ertes: OK - that's what I've been doing before.
19:08:42 <test11> the way i understand the section on randomized functions and what they are doing
19:09:12 <ertes> koz_: i should answer: "of course, because '=' means 'equals' in haskell" =)
19:09:18 <EvanR> you can bind StdGen -> (X, StdGen) to a X -> StdGen -> (Y, StdGen) to get a StdGen -> (Y, StdGen)
19:09:30 <ertes> (not quite, but close enough in this context)
19:09:30 <koz_> ertes: Roughly when should I consider lists as large enough to be candidates for parBuffer?
19:09:58 <ertes> koz_: i don't think parMap can ever be faster than parBuffer, but to be safe you should benchmark
19:10:05 <test11> you have a function eg:- random :: StdGen -> (Int, StdGen) and a function  eg:-    addRand :: Int -> StdGen -> (Int, StdGen)
19:10:12 <koz_> ertes: OK, shall do.
19:10:12 <test11> and you want to compose them
19:10:18 <EvanR> right
19:10:34 <test11> so why not do      addRand . random
19:10:38 <test11> ?
19:10:39 <EvanR> to get a new StdGen -> (Int, StdGen)
19:10:45 <test11> instead of bind
19:10:57 <EvanR> because the types dont match up
19:11:03 <test11> oh right
19:11:10 <test11> so bind splits it up
19:11:29 <EvanR> it has to do a few things to get it to work
19:11:37 <ertes> koz_: also note that different systems have very different parallel performance, so make the parameter user-tunable
19:11:45 <ertes> is
19:12:06 <test11> but the problem is  f * g makes sense
19:12:14 <EvanR> * ?
19:12:27 <test11> i mean       addRand * random   makes sense
19:12:40 <EvanR> multiplying functions?
19:12:54 <test11> i mean       addRand * random = bind addRand random
19:13:11 <ertes> koz_: (or if you want to be fancy, you can use machine learning to auto-tune)
19:13:19 <EvanR> addRand =<< random?
19:13:38 <test11> but     random * addRand = bind random addRand    doesn't work?
19:13:52 <test11> unlike the previous examples in that article
19:13:56 <EvanR> it not commutative, its not even well typed if you do it backwards
19:14:05 <test11> exactly
19:14:13 <ertes> koz_: i have used simulated annealing to auto-tune parameters in one application…  pretty interesting experience
19:14:26 <test11> so whats happening with unit * f = f * unit?
19:14:35 <test11> how is that well typed
19:14:40 <EvanR> calling it f and g is probably misleading, different kinds of functions
19:14:47 <shachaf> What is *?
19:14:51 <koz_> ertes: For now, that's a little too much work. But I might have to do something like that later - thanks for the idea.
19:14:55 <EvanR> =<< i think
19:15:03 <test11> yeah
19:15:15 <test11>  f * g = bind f . g
19:15:24 <shachaf> :t \f g -> bind f . g
19:15:26 <lambdabot>     Not in scope: ‘bind’
19:15:26 <lambdabot>     Perhaps you meant one of these:
19:15:26 <lambdabot>       ‘Data.ByteString.find’ (imported from Data.ByteString),
19:15:28 <test11> bind :: (a → StdGen → (b,StdGen)) → (StdGen → (a,StdGen)) → (StdGen → (b,StdGen))
19:15:30 <shachaf> Right.
19:15:39 <EvanR> > return =<< Just 3
19:15:39 <shachaf> :t \f g -> (=<<) f . g
19:15:40 <lambdabot> Monad m => (a1 -> m b) -> (a -> m a1) -> a -> m b
19:15:40 <lambdabot>  Just 3
19:15:55 <ertes> koz_: SA and genetic algorithms work very well, but in this scenario SA is probably better, because it uses only a single candidate per epoch
19:15:56 <shachaf> Right. So unit * f = f = f * unit is fine.
19:15:57 <EvanR> Just 3 =<< return  -- error
19:16:09 <shachaf> But note that those two units don't have the same type.
19:16:17 <test11> how is unit still commutative?
19:16:25 <shachaf> There's no commutativity here.
19:16:29 <test11> ?
19:16:42 <EvanR> not the same unit, and f and g arent just arbitrary functions a -> b
19:16:48 <shachaf> First check that unit * f = f
19:16:51 <shachaf> Then check that f * unit = f
19:17:04 <shachaf> That's the only claim.
19:17:11 <ertes> koz_: if you need to do that, you should plan at least one day for learning and experimentation…  SA is simple, but not easy
19:17:25 <test11> wha?
19:17:46 <test11> unit * f = f * f * unit doesn't mean commutativity?
19:18:00 <test11> unit * f = f = f * unit doesn't mean commutativity?
19:18:07 <EvanR> * isnt commutative
19:18:22 <shachaf> Not really. Maybe you could call it that. It's probably not very helpful to call it that.
19:18:27 <test11> oh its not commutative in general
19:18:29 <test11> ok
19:18:33 <shachaf> Those are two different units.
19:18:50 <test11> right they have different signatures
19:19:03 <shachaf> So calling that commutativity is stretching it a bit.
19:19:05 <EvanR> two different f's too?
19:19:10 <test11> yes
19:19:27 <EvanR> so the double equation is misleading
19:19:28 <test11> so what exactly are the 2 types?
19:19:36 <ertes> test11: "for all f, unit and f commute with respect to *"
19:19:53 <shachaf> ertes: I maintain that that's an unhelpful thing to say.
19:20:22 <pavonia> It's usually called left/right identity
19:20:23 <shachaf> I would even say that it isn't correct. Or at least to make it correct you need a rank-2 statement.
19:20:38 <ertes> shachaf: in my experience explicit quantification can sometimes be of great help, but not necessarily…  i'm just giving it a try
19:21:02 <shachaf> ertes: The part that I think doesn't help is claiming that they commute.
19:21:04 <ertes> shachaf: i didn't want to go that far, but you're right
19:21:14 <shachaf> test11: This is the same as "id . f = f, f = f . id"
19:22:03 <test11> what are the 2 types here?
19:22:21 <test11> id1 . f1 = f2 = f3 . id2
19:22:25 <EvanR> f and g arent the same kind of thing, even worse f and f arent the same kind of thing
19:22:28 <shachaf> There's only one f.
19:22:39 <test11> what are the types of f1, f2, f3 and id1, d2
19:22:41 <shachaf> f :: A -> (StdGen -> (B, StdGen))
19:23:04 <shachaf> unit1 :: B -> (StdGen -> (C, StdGen))
19:23:15 <shachaf> unit2 :: D -> (StdGen -> (A, StdGen))
19:23:25 <shachaf> Oh, you were talking about my example, not your original example.
19:23:37 <shachaf> Wait.
19:23:39 <shachaf> Those are wrong anyway.
19:23:49 <shachaf> unit1 :: B -> (StdGen -> (B, StdGen))
19:23:56 <shachaf> unit2 :: A -> (StdGen -> (A, StdGen))
19:24:12 <shachaf> In my example: f :: A -> B; id1 :: B -> B; id2 :: A -> A
19:24:15 <test11> oh i meant to * not .
19:24:30 <test11> say*
19:24:32 <EvanR> looks like i was wrong about *
19:24:43 <EvanR> being =<<
19:24:48 <test11> id1 * f1 = f2 = f3 * id2 what are the types here?
19:25:26 <ertes> test11: i recommend that you don't combine equations
19:25:36 <ertes> rather than "a = b = c", write "a = b, b = c"
19:26:02 <ertes> there is a subtle difference in that the former may be ill-typed when the latter is not
19:26:13 <shachaf> That's not really true.
19:26:17 <shachaf> Those three things really are equal.
19:26:22 <test11> what are the types involved?
19:26:38 <shachaf> I already answered that question.
19:27:03 <test11> but you used A B C D
19:27:04 <shachaf> f :: A -> (StdGen -> (B, StdGen)); unit1 :: B -> (StdGen -> (B, StdGen)); unit1 :: A -> (StdGen -> (A, StdGen))
19:28:03 <test11> what are A B C and D's types
19:28:20 <shachaf> Any type you like.
19:28:33 <test11> so then they all have the same type?
19:28:43 <EvanR> A B C and D are the types
19:29:26 <test11> ok lets break this down a bit    unit * addRandom = addRandom ?
19:30:04 <test11> and addRandom * unit = addRandom?
19:30:52 <test11> but * bind is assymetric
19:30:53 <test11> bind :: (a → StdGen → (b,StdGen)) → (StdGen → (a,StdGen)) → (StdGen → (b,StdGen))
19:31:17 <EvanR> sounds like we need to go all the way back to "what is *"
19:31:34 <test11> f * g = bind f . g
19:31:49 <test11> and bind :: (a → StdGen → (b,StdGen)) → (StdGen → (a,StdGen)) → (StdGen → (b,StdGen))
19:32:06 <EvanR> so * is symmetric
19:32:13 <ertes> "*" is (<=<), isn't it?
19:32:14 <test11> where?
19:32:47 <pavonia> :t (<=<)
19:32:48 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
19:32:53 <test11> f :: (a → StdGen → (b,StdGen))   and g :: (StdGen → (a,StdGen))
19:33:11 <test11> how is that symmetric?
19:33:57 <EvanR> :t (f =<<) . g
19:33:58 <lambdabot> (Monad m, Show a, Show a1, FromExpr (m a1), FromExpr (m b)) => a -> m b
19:34:18 <ertes> :t \f g -> (f =<<) . g
19:34:18 <EvanR> :t f <=< g
19:34:19 <lambdabot> Monad m => (a1 -> m b) -> (a -> m a1) -> a -> m b
19:34:19 <lambdabot> (Monad m, Show b, Show a, FromExpr (m b), FromExpr (m c)) => a -> m c
19:34:22 <test11> thats not helping
19:34:48 <EvanR> well at least im not confused anymore ;)
19:35:20 <EvanR> your * is <=< and bind is =<<, renamed to make this all harder
19:35:24 <ertes> if 'bind' is by any change (=<<), then according to the equation "f * g = bind f . g", (*) is (<=<)
19:35:30 <ertes> chance
19:36:07 <test11> f :: (a → StdGen → (b,StdGen))   and g :: (StdGen → (a,StdGen))
19:36:11 <test11> how is that symmetric?
19:36:32 <test11> you can't do   g * f = bind g . f
19:36:33 <EvanR> in f * g, those arent the right types for f and 
19:36:34 <EvanR> g
19:37:53 <test11> shachaf, ?
19:39:03 <ertes> too many teachers at the same time…  i'm out =)
19:39:07 <EvanR> if f :: B -> StdGen -> (C, StdGen), and g :: A -> StdGen -> (B, StdGen), then f * g :: A -> StdGen -> (C, StdGen)
19:39:54 <test11> oh thats right * and bind have different types
19:40:09 <ertes> test11: your 'g' is not a valid argument to 'bind' to begin with
19:40:13 <test11> what the type of  *
19:40:15 <EvanR> they are totally different, at least theres a point to having different names this time
19:40:37 <EvanR> i basically just stated it
19:41:10 <shachaf> You're the one who brought up *
19:41:13 <test11> wait type of f * g = type of *?
19:41:21 <shachaf> Anyway, I was already out.
19:42:11 <ertes> (#haskell could benefit from a ticket system)
19:42:25 <pavonia> test11: If you know the types of f, g, and f * g it's pretty easy to conclude the type of *
19:47:08 <test11> * :: (A -> StdGen -> (B, StdGen)) -> (B -> StdGen -> (C, StdGen)) -> (A -> StdGen -> (C, StdGen))   ?
19:47:23 <test11> ok so thats symmetric
19:47:31 <EvanR> next exercise simplify this using notation: type Random a = StdGen -> (a, StdGen)
19:48:23 <shachaf> I suspect the arguments are backwards.
19:48:32 <test11> yes
19:49:03 <test11> * ::  (B -> StdGen -> (C, StdGen)) -> (A -> StdGen -> (B, StdGen)) -> (A -> StdGen -> (C, StdGen))
19:49:50 <test11> so bind unit . f = bind f . unit = f ?
19:51:25 <test11> whats f :: in there
19:51:41 <test11> f :: StdGen -> (B, StdGen) ?
19:51:54 <EvanR> you can type all this into a haskell source file, load it into ghci, and do :t :D
19:52:40 <pavonia> test11: Check the type of the first parameter of bind
19:59:10 <test11> pavonia,  is f :: (A -> StdGen -> (B, StdGen))?
19:59:52 <pavonia> Yes
20:01:26 <test11> but unit :: a → (StdGen → (a,StdGen))
20:01:36 <test11> how do you unit . f
20:01:58 <test11> . has precedence over bind right?
20:02:19 <shachaf> No.
20:02:29 <shachaf> Function application has higher precedence than any operator.
20:02:40 <shachaf> It's easy to test something like that.
20:02:55 <test11> wait
20:03:03 <test11> then f :: (StdGen → (a,StdGen))
20:03:15 <test11> not  f :: (A -> StdGen -> (B, StdGen))
20:06:49 <test11> oh nvm i think i got it
20:07:00 <test11> its that . operator that i keep ignoring
20:08:21 <test11> if we give it the seed explicitly then would be     bind unit . f a $ seed   ?
20:09:38 <EvanR> newtype Random a = MkRandom { runRandom :: StdGen -> (a, StdGen) }
20:10:00 <EvanR> runRandom myRandomAction seed
20:10:24 <EvanR> not the actual seed, but the generator
20:11:28 <test11> EvanR, the generator?
20:11:41 <EvanR> StdGen
20:11:57 <test11> wait so StdGen is not the current state of the prng?
20:12:16 <EvanR> StdGen is an RNG state
20:12:17 <Cale> it is
20:12:47 <test11> then why do you call it a generator? instead of state
20:12:55 <EvanR> i was objecting to calling it a seed
20:13:00 <test11> its not a function is it?
20:13:06 <EvanR> its not
20:13:44 <test11> if we give it the seed explicitly then would be     bind unit . f a $ currstate   ?
20:13:58 <EvanR> if you give it the generator explicitly
20:14:06 <test11> yes
20:14:10 <test11> the state
20:14:38 <EvanR> (any StdGen -> (X, StdGen) you want) currstate
20:14:52 <test11>  bind unit . f1 a $ currstate =  bind f2 . unit a $ currstate
20:14:54 <EvanR> will give you (X, StdGen)
20:14:58 <test11> are f1 and f2 the same?
20:16:55 <test11> is f1 = f2 = f?
20:17:39 <EvanR> as long as its well typed, you an remove currstate from both sides of the equation in your question, and you probably already asked about whatever remains
20:19:35 <test11> so f and unit have the type    a -> StdGen -> (b, StdGen) and  a -> StdGen -> (a, StdGen) 
20:20:25 <test11> but when you give them to bind,   bind  unit . f doesn't make sense to me  but bind unit . f a makes sense
20:21:07 <test11> after you give a to f then the type assymetry makes sense
20:22:18 <EvanR> you mean (bind unit . f) a
20:22:48 <test11> yeah that doesn't make sense, how do the types match up before you give a to f
20:23:24 <EvanR> you already agreed bind g . f makes sense and has type X -> StdGen -> (Y, StdGen)
20:23:54 <EvanR> so to use this thing, you need to prove an X then a generator
20:23:58 <EvanR> provide*
20:24:44 <EvanR> i think you should implement Random yourself, ignore that blog post, then once you understand it, go back to the blog post and marvel at the extra complexity
20:25:00 <test11> EvanR, the problem i have is
20:25:17 <test11> bind takes 2 functions of different types
20:25:26 <test11> but unit and f have almost the same type
20:25:27 <EvanR> sure
20:25:41 <EvanR> sure
20:25:50 <test11> it makes sense when you give f a and unit to bind
20:25:53 <EvanR> how is that a problem
20:25:58 <test11> but not f and unit to bind
20:26:00 <hodapp> well, I just ran into using 'State Foo Svg' where 'Svg' is just 'MarkupM ()', but I need to 'lift' some things from Svg and I can't because I can't do 'StateT Foo Svg' and 'MarkupM' is a sort of internal type in blaze
20:26:12 <hodapp> not sure how to approach this
20:26:28 <EvanR> test11: you seem to be forgetting what all the types are
20:27:07 <EvanR> try something simpler and work your way back to this
20:27:46 <test11> something simpler? like what?
20:29:19 <EvanR> using generators directly, then make a Random type like i mentioned
20:29:28 <EvanR> and implement its Functor and Monad instances
20:29:50 <test11> oh derp
20:29:55 <test11> i figured it out
20:30:01 <test11> that . keeps messing me up
20:30:26 <test11> bind unit $ f doesn't make sense but bind unit . f does
20:31:05 <EvanR> . is associative, its nice. $ isnt associative
20:31:19 <EvanR> $ is gross
20:33:27 <test11> EvanR, so the article goes on to say "Use the variable m to represent Debuggable, Multivalued or Randomised"
20:33:43 <test11> so is m the monad?
20:34:10 <EvanR> m stands for monad in this case
20:34:20 <EvanR> dial m for monad
20:37:07 <lpaste> arcetera pasted “xmonad” at http://lpaste.net/168882
20:37:53 <lpaste> arcetera pasted “xmonad2” at http://lpaste.net/168883
20:38:24 <arcetera> see above
20:38:47 <arcetera> why does "xmonad2" work, but "xmonad" cause xmobar to constantly flicker?
20:39:07 <arcetera> i thought do notation was just syntactic sugar over monads
20:40:38 <c_wraith> it'd be nice to have a diff
20:41:57 <reinh> arcetera: the two are not equivalent
20:42:05 <c_wraith> for reference, the diff is line 100 and 109
20:42:18 <arcetera> howso
20:42:22 <arcetera> because i'm a total idiot
20:42:32 <reinh> desugar them both manually and you will see the difference
20:43:24 <reinh> well, desugar the one that uses do
20:44:04 <arcetera> oh god don't tell me it's relaunching xmobar every time
20:45:07 <reinh> one passes an action that uses a spawned pipe
20:45:22 <reinh> one passes an action that *spawns* a pipe
20:45:35 <arcetera> yes
20:45:55 <reinh> thus the flickering ;)
20:46:57 <arcetera> ah
20:47:10 <arcetera> i mean i literally just "figured out" monads yesterday
20:47:30 <reinh> your OS is trying so hard for you :D
20:47:57 <arcetera> to believe i was completely new to fp in june
20:48:03 <reinh> :)
20:50:05 <arcetera> emacs crashed
20:50:08 <arcetera> well isn't that just fine and dandy
21:13:55 * hackagebot trifecta 1.6 - A modern parser combinator library with convenient diagnostics  https://hackage.haskell.org/package/trifecta-1.6 (EricMertens)
21:16:34 <shachaf> What, not Eric Emertens?
21:19:51 <glguy> I don't think that person exists / is allowed to upload trifecta
21:20:20 <glguy> Which is probably good, but having someone with that name in the community would really be confusing!
21:31:37 <test11> is there a standard gui library?
21:40:39 <kadoban> test11: I don't think so.
21:40:55 <kadoban> There's a few choices, none of them all that perfect, AFAIK.
21:42:04 <EvanR> would be nice to have a "gloss of guis" for simple stuff
21:42:07 <EvanR> three-penny-gui ?
21:42:40 <test11> so what would you recommend?
21:45:03 <EvanR> the spoiler alert is... "standard gui" is secretly the same thing as "your browser"
21:46:26 <kadoban> test11: I usually just use reflex-dom recently, which via webkit-gtk can be used natively. It's not for everyone though, just happens to fit what I'm largely doing.
21:49:01 <test11> isn't there something about FRP guis
21:51:40 <EvanR> e.g. reflex-dom and reactive-banana
21:56:06 <Heasummn> If I was using something like Stack, where would I put resource files?
21:56:33 <Heasummn> I need to for example, parse a file, and I'm wondering where I should place that file
21:58:56 * hackagebot list-transformer 1.0.0 - List monad transformer  https://hackage.haskell.org/package/list-transformer-1.0.0 (GabrielGonzalez)
22:44:30 <hwkng> Text.Parsec.Token -- is there any tutorial for how to use this?
22:47:36 <glguy> hwkng: The example of how to use it is at the end of the module
22:52:14 <texasmynsted> anybody use intellij idea with haskell stack?
22:52:28 <texasmynsted> by that I mean install ghc etc via stack?
22:55:52 <texasmynsted> This http://docs.haskellstack.org/
23:09:25 <texasmynsted> is there a freenode channel for haskellstack?
23:16:15 <thimoteus> try #haskell-stack
23:18:23 <texasmynsted> thank you
23:18:29 <texasmynsted> I will ask there
