00:00:06 <bollu> shachaf: and the former?
00:00:16 <bollu> data Foo = Foo (forall a. a) ?
00:00:30 <shachaf> The former means that, if x :: forall a. a, then Foo x :: Foo
00:00:44 <bollu> ahh
00:00:52 <shachaf> (forall a. a) is a perfectly legitimate type in GHC, so it doesn't need special support.
00:00:54 <bollu> shachaf: so you're saying that the value inside me works "for all a"
00:01:41 <shachaf> Even without built-in support, you can turn an exists into a couple of foralls.
00:01:52 <shachaf> But that's probably not the best first example.
00:02:26 <shachaf> (exists a. a) is useless by itself. But more complex types can be useful.
00:02:57 <bollu> shachaf: wait, I'm _still_ confused. When I pattern match over Foo and Bar
00:03:01 <bollu> what's the difference?
00:03:15 <bollu> won't both give me access to the "a"?
00:03:32 <shachaf> In the case of Foo, you can choose what the type "a" is.
00:03:35 <shachaf> For example, you can choose a=Int
00:03:48 * hackagebot language-puppet 1.3 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.3 (SimonMarechal)
00:03:49 <shachaf> Then you can write (case Foo of Foo x -> x) :: Int
00:04:14 <shachaf> In the case of Bar, you can't choose. The choice has already been made.
00:04:27 <shachaf> Er, of course I mean (case foo of Foo x -> x) :: Int
00:04:48 <shachaf> You can't even write (case bar of Bar x -> x) :: anything
00:04:56 <shachaf> It's an error. You don't know what type to give it.
00:05:04 <bollu> shachaf: the choice has been made, because the choice is made "outside the value region" ?
00:05:12 <shachaf> I don't know what a value region is.
00:05:16 <bollu> shachaf: like, because, you have the universal quantifier _before_ actually making the object?
00:05:22 <bollu> forall a. Bar <stuff in Bar>
00:05:26 <shachaf> Forget the syntax.
00:05:28 <bollu> okay
00:05:37 <shachaf> A value of type Bar contains a value of type a, for some a.
00:05:51 <shachaf> To construct a value of type bar, you choose a type a, and then you choose a value x :: a.
00:05:58 <bollu> right
00:06:03 <shachaf> For example, you can write Bar True. Or Bar 'a'.
00:06:29 <shachaf> Now say I give you bar :: Bar. What can you do with it?
00:07:10 <bollu> shachaf: nothing? I can't make any assumption about it except that it has a value insideit
00:07:12 <bollu> inside it*
00:07:16 <shachaf> Right.
00:07:23 <shachaf> You can pattern-match on it, but it's useless.
00:07:35 <shachaf> Now let's make a more complicated existential.
00:07:38 * hackagebot qtah-examples 0.1.0 - Example programs for Qtah Qt bindings  https://hackage.haskell.org/package/qtah-examples-0.1.0 (khumba)
00:07:38 * hackagebot language-puppet 1.3 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.3 (SimonMarechal)
00:07:43 <shachaf> data Vaz = forall a. Vaz a (a -> Int)
00:08:05 <shachaf> Can you produce some values of type Vaz?
00:08:27 <bollu> shachaf: sure? I get to choose the type, right? Vaz 1 show
00:08:44 <shachaf> show :: a -> Int?
00:08:57 <bollu> shachaf: whoops, brain fart
00:08:59 <bollu> Vaz 1 (+1) or something
00:09:06 <bollu> I picked a = Int
00:09:12 <shachaf> Right.
00:09:30 <shachaf> Now I give you a value :: Vaz to consume. What can you do with it?
00:09:31 <bollu> this is interesting. I can produce an Int from Vaz even though I don't know what "a" is
00:10:08 <bollu> shachaf: I can produce an int
00:10:19 <shachaf> An Int. Yes.
00:10:27 <shachaf> That's all you can do, in fact.
00:10:28 <bollu> right, sorry. Int* 
00:10:34 <bollu> shachaf: hm, true
00:10:52 <shachaf> You can't tell the values (Vaz 2 id), (Vaz 1 (+1)), (Vaz "hi" length) apart.
00:11:03 <shachaf> They're equal. Not just equivalent, they're exactly equal.
00:11:53 <shachaf> Vaz is isomorphic to Int. Instead of giving you a Vaz, I might as well give you an Int.
00:12:03 <bollu> shachaf: right
00:12:29 <bollu> shachaf: the other direction of the isomorphism is vazzer x = Vaz x id right?
00:12:33 * hackagebot mandrill 0.5.2.2 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.5.2.2 (AlfredoDiNapoli)
00:12:37 <shachaf> Yes.
00:12:41 <bollu> okay, cool
00:13:05 <shachaf> Let's take another type.
00:13:14 <bollu> shachaf: this is interesting to us because? since we clearly showed the existence of an isomorphism, why not just send Int?
00:13:20 <shachaf> It's not interesting.
00:13:33 <bollu> ah, all right, go on
00:13:40 <shachaf> You should probably never use data Vaz = forall a. Vaz a (a -> Int) instead of Int.
00:13:57 <shachaf> Or data S = forall a. Show a => S a instead of String.
00:13:59 <shachaf> Just use String.
00:14:19 <bollu> right
00:15:14 <bollu> okay, so the next type?
00:15:33 <shachaf> Let's take this: exists a. (a, a -> Maybe a)
00:15:50 <bollu> sure
00:16:21 <shachaf> You can write it in GHC as data T = forall a. T a (a -> Maybe a)
00:16:30 <shachaf> Your job is to figure out what's going on with that type.
00:17:02 <bollu> shachaf: I can use it to figure out if there's a Just a or a Nothing, but I can't use the value inside the "a"
00:17:12 <bollu> shachaf: so I can use it to pattern match and check if it produces a Just _ or Nothing
00:17:20 <shachaf> You can do more than that.
00:18:25 <bollu> shachaf: I can run functions of the type forall a. a -> a -> a if I want to, since I will have two "a"'s, one outside and one inside the just. But there's nothing interesting in that family of functions?
00:18:51 <shachaf> There are only two functions of that type, and they don't do anything you can't have done yourself.
00:19:40 <shachaf> Anyway, it's your homework.
00:19:47 <bollu> shachaf: all right.
00:21:14 <bollu> shachaf: continuing with existentials? :)
00:21:27 <shachaf> Existentials are done.
00:21:41 <bollu> shachaf: cool, back to lens then?
00:21:56 <shachaf> Not today. I'm going to sleep soon.
00:22:31 * dysfun just woke up, is considering going back to sleep
00:22:57 <bollu> shachaf: all right. Thanks a lot for your help
00:23:03 <bollu> shachaf: will you be around tomorrow at the same time?
00:23:14 <shachaf> I don't know.
00:23:23 <bollu> shachaf: okay, thanks
00:28:09 <shachaf> For bonus points, figure out the type (forall a. (Maybe a -> a) -> a) too.
00:41:20 <mtesseract> Hi
00:47:34 * hackagebot QuickCheck 2.9.1 - Automatic testing of Haskell programs  https://hackage.haskell.org/package/QuickCheck-2.9.1 (NickSmallbone)
01:05:38 <Athas> Did anyone here receive an FHPC'16 response yet?
01:05:44 <Undreren> Can I hide the "joined/quit" messages? It's really messy
01:06:07 <merijn> Undreren: Depends on your IRC client?
01:07:18 <Undreren> webchat
01:07:26 <Undreren> merijn: webclient
01:07:35 * hackagebot postgresql-query 3.0.0 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  https://hackage.haskell.org/package/postgresql-query-3.0.0 (AlekseyUymanov)
01:08:07 <sdx23> Undreren: http://wiki.xkcd.com/irc/Hide_join_part_messages#qwebirc
01:10:09 <Undreren> sdx23++
01:10:14 <Undreren> sdx23++ 4
01:11:25 <Undreren> preflex: sdx23++
01:11:36 <Undreren> Can't make it work, lol
01:13:23 <Undreren> > (forever $ return "Thanks!") :: [String]
01:13:27 <lambdabot>  mueval-core: Time limit exceeded
01:13:40 <Undreren> > return "Thanks!" :: [String]
01:13:42 <lambdabot>  ["Thanks!"]
01:14:10 <Undreren> > let thanks = "Thanks!" : thanks in thans
01:14:12 <lambdabot>      Not in scope: ‘thans’
01:14:12 <lambdabot>      Perhaps you meant ‘thanks’ (line 1)
01:14:12 <Undreren> > let thanks = "Thanks!" : thanks in thanks
01:14:14 <lambdabot>  ["Thanks!","Thanks!","Thanks!","Thanks!","Thanks!","Thanks!","Thanks!","Than...
01:14:52 <ThreeOfEight> > fix show
01:14:54 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
01:14:59 <ThreeOfEight> This one never gets old :)
01:19:22 <bollu> is there a nice way to prevent the collision between Aeson's .= and Lens' .= ?
01:23:27 <idnb> import ... hiding (.=)
01:24:09 <ongy> how big is the performance hit, if I don't hardcode a function, but build in during runtime? Usecase; I could either make an strftime-like function with a format string (or something better typed) and prebake a function that will be used often, or hardcode it and make configuration harder/more annoying.
01:24:19 <Athas> Is it possible to make the linking stage of cabal run in parallel (if you have multiple executable targets)?
01:25:10 <fr33domlover> ongy, everything in Haskell is functions anyway :P
01:25:10 <Athas> ongy: performance hit is not big at a first approximation, _but_ the dynamic approach likely prevents the compiler from doing much optimisation.
01:25:24 <fr33domlover> ongy, high order functions are everywhere already
01:25:39 <fr33domlover> it's a powerful tool, just use it when you need it
01:25:39 <Athas> If this is really a string formatting function, I don't think function dispatch is going to be the bottleneck.
01:25:44 <fr33domlover> and optimize much much later
01:25:53 <fr33domlover> if at all
01:26:01 <mauke> ongy: about three pounds
01:27:34 <ongy> mauke: oh, that's to heavy for a laptop
01:30:35 <bollu> idnb: can I import the operator with some other name?
01:30:49 <ongy> fr33domlover: I love haskell, but I really dislike that "if at all" attitude. I wouldn't care about performance if I didn't think it's worth it
01:30:56 <Maxdamantus> pound mass, pound force or pound sterling?
01:31:43 <mauke> bollu: you can import it qualified
01:31:48 <mauke> bollu: and then define an alias if you want
01:31:50 <bollu> mauke: hm, the module?
01:31:55 <bollu> mauke: good idea, thanks
01:32:11 <bollu> mauke: the collision is awkward. I'd like to use both Aeson and Lens, but the collision is sort of annoying
01:32:11 <mauke> well, you could restrict it to just that operator if you want, but there's probably no need
01:32:27 <mauke> import qualified Foo.Bar ((.=))
01:32:55 <ongy> Maxdamantus: I guess a "hit" would be pound force
01:33:15 <mauke> Maxdamantus: ground pound
01:34:22 <bollu> mauke: ahh, neat. Thanks!
01:35:01 <bollu> Iceland_jack: thanks for the info about GADT syntax earlier
01:42:16 <sphinxo> What does the ' do before [JSON] https://haskell-servant.github.io/tutorial/0.4/api-type.html
01:43:50 <lyxia> make the list type-level
01:44:49 <sphinxo> ahh 
01:44:59 <sphinxo> Where could I look in future if I encounter syntax like that?
01:45:45 <lyxia> it's enabled by the DataKinds extension
01:46:05 <merijn> sphinxo: The GHC manual? :)
01:46:15 <fr33domlover> ongy, I just mean performance depends on many things, that specific case many be negligible. Actually, it may matter in one place and not matter in another
01:46:30 <fr33domlover> So by default, write readable reusable composable code etc.
01:46:37 <merijn> sphinxo: It's surprisingly good, yet many people seem to avoid reading it at all cost
01:46:39 <fr33domlover> Then benchmark etc. and see
01:46:51 <sphinxo> ok thanks +1
01:47:55 <ongy> how can I apply a list of function to one argument? do some `map (arg ($))' stuff?
01:48:58 <lyxia> map ($ arg) list   list <*> pure arg
01:49:33 <lyxia> [f arg | f <- list]
01:51:30 <bollu> is it considered a bad idea to have a library depend on lens?
01:51:35 <bollu> like, for ease of access
01:51:44 <bollu> I'm writing bindings to a web API, and I'm using lens
01:51:52 <bollu> if I'm going to publish it, should I un-lens it?
01:52:14 <dysfun> it's a matter of taste
01:52:17 <dysfun> i like lenses
01:52:37 <dysfun> i have no problem using them
01:52:42 <bollu> me too, though I'm really new to it
01:52:48 <bollu> but it seems to be pretty heavy
01:53:01 <dysfun> right, but by the time it's an executable it's not :)
01:53:06 <bollu> true :)
01:53:15 <dysfun> there are downsides of course
01:53:24 <dysfun> like this machine being so slow, lens-based things can take ages to build
01:53:25 <bollu> dysfun: such as? overhead for learning or something?
01:53:30 <bollu> dysfun: ah
01:53:40 <bollu> dysfun: I haven't noticed that yet
01:53:50 <dysfun> but this is hardly unique to lenses
01:54:18 <ongy> I think it takes me 15min to build lense, but that is once during install time
01:55:38 <bollu> what does "type-indexed data types" mean?
01:55:46 <merijn> bollu: FYI, the way lenses are defined means you can define/export lenses from your library without depending on lens
01:55:56 <bollu> merijn: wait, how?that's pretty cool
01:56:06 <merijn> Of course then you can't use lens internally
01:56:18 <bollu> merijn: because? double export?
01:56:41 <merijn> bollu: No, but how can you use lens functions without depending on lens? :p
01:56:56 <merijn> bollu: See the "Minimizing Dependencies" section at the bottom of https://hackage.haskell.org/package/lens
01:57:07 <mauke> ongy: sequence fns arg
01:57:15 <lyxia> sometimes you can just use microlens
01:58:22 <bollu> merijn: thanks!
01:59:32 <mauke> > sequence [f, g, h] x  :: [Expr]
01:59:36 <lambdabot>  [f x,g x,h x]
02:00:08 <ongy> I think the map ($ a) is more readable though
02:00:28 <eklavya> I have included mtl and transformers both as dependencies, but still stack says "Could not find module ‘Control.Monad.Maybe’"
02:00:44 <eklavya> what package should I install to get this?
02:01:05 <fr33domlover> bollu, several packages export lenses without depending on lens
02:01:12 <fr33domlover> you could check how they do it :P
02:01:14 <mauke> http://hayoo.fh-wedel.de/?query=Control.Monad.Maybe says MaybeT
02:01:45 <eklavya> mauke I need MaybeT
02:01:54 <eklavya> but that's the package itsn't it?
02:02:50 <fr33domlover> eklavya, you have MaybeT in transformers
02:03:05 <eklavya> stack build fails though :(
02:03:13 <eklavya> I have added both mtl and transformers
02:03:15 <fr33domlover> eklavya, is the module name correct?
02:03:32 <fr33domlover> in transformers it's Control.Monad.Trans.Mayb
02:03:34 <fr33domlover> in transformers it's Control.Monad.Trans.Maybe
02:03:48 <fr33domlover> Don't guess the names, check in the docs :P
02:04:01 <eklavya> docs say Control.Monad.Maybe
02:04:10 <lyxia> which docs
02:04:26 <fr33domlover> @hackage transformers
02:04:26 <lambdabot> http://hackage.haskell.org/package/transformers
02:04:29 <fr33domlover> eklavya, ^
02:04:44 <eklavya> let me paste
02:05:20 <eklavya> https://hackage.haskell.org/package/MaybeT-0.1.2/docs/Control-Monad-Maybe.html
02:05:31 <eklavya> https://wiki.haskell.org/New_monads/MaybeT
02:05:49 <fr33domlover> eklavya, it will help if you tell us exactly what you are trying to do
02:06:09 <mauke> those are the docs of the MaybeT package, not transformers
02:06:18 <fr33domlover> If you want to include MaybeT in your monad stack, just use transformers
02:06:26 <eklavya> I want to mix IO and Maybe
02:06:35 <fr33domlover> then use transformers
02:07:03 <eklavya> ok, so is transformers recommended over mtl?
02:07:19 <fr33domlover> eklavya, mtl is a layer on top, sort of
02:07:27 <fr33domlover> use transformers unless you need mtl
02:07:35 <eklavya> also mauke which package is that? why are there two (three?) MaybeT in the docs
02:08:03 <eklavya> fr33domlover: ok so transformers until I learn more :P
02:08:14 <mauke> eklavya: the MaybeT package is the MaybeT package
02:08:19 <mauke> what do you mean, "which package"
02:08:37 <eklavya> sorry
02:08:57 <eklavya> I mean what is "that" particular MaybeT
02:09:18 <eklavya> which says it is in "Control.Monad.Maybe"
02:09:33 <mauke> huh?
02:09:39 <fr33domlover> eklavya, sometimes there are several versions of the same functionality around
02:09:45 <eklavya> I am not sure how to put it :)
02:10:01 <fr33domlover> eklavya, different people trying different approaches
02:10:15 <fr33domlover> or some old package gets superseded by another
02:10:18 <eklavya> fr33domlover: so this one looked more official because of the namespace used
02:10:37 <fr33domlover> eklavya, if you aren't sure, just ask here :P
02:10:49 <eklavya> yup
02:11:05 <eklavya> thanks fr33domlover mauke lyxia for your time :)
02:18:22 <jle`> eklavya: mtl just re-exports MaybeT from transformers, so using mtl is the same as using transformers
02:18:27 <jle`> in this case
02:18:42 <eklavya> ok
02:18:47 <jle`> it's just basically a literal re-export
02:52:38 * hackagebot generics-sop-lens 0.1.2.0 - Lenses for types in generics-sop  https://hackage.haskell.org/package/generics-sop-lens-0.1.2.0 (phadej)
02:57:38 * hackagebot solga-swagger 0.1.0.1 - Swagger generation for Solga  https://hackage.haskell.org/package/solga-swagger-0.1.0.1 (PatrickChilton)
03:16:49 <bollu> does makeFields have a bug where it doesn't work with types ending in _?
03:17:03 <bollu> if I have a type data Foo_ =  { _foo_Field }
03:17:11 <bollu> will makeFields work?
03:17:23 <bollu> it doesn't seem to be creating an accesor "field"
03:21:07 <Voltzlive> So I think I understand the *what* of Arrows, but I don't quite understand the *why*.. 
03:21:10 <akegalj> hey guys. Can you point me where to look if I would like to run some code in compile time and do some io (dump some files)
03:22:19 <mtesseract> I have some trouble understanding the peculiarities of tail-recursion in Haskell. I do understand that there is a completely different notion (guarded recursion), that is sometimes more useful than tail recursion. But that is not my point. I don't fully understand "stack growth" as it relates to (non-) tail-recursive functions. Some texts suggest (at least to me) that a function in Haskell does not have to
03:22:21 <mtesseract> LOOK tail-recursive in order to run in constant memory. Does this boil down to the well known example that foldr is usually the right choice for dealing with infinite lists or is there also some other concise example of a non-tail-recursive function that is evaluated by GHCs eval/apply strategy in constant memory?
03:22:22 <tdammers> akegalj: you mean, you want to do IO at compile time?
03:22:38 <tdammers> akegalj: if so, I recommend reading the source code from the file-embed package
03:23:01 <akegalj> tdammers: oh, ok. I thought file-embed is for reading only. Ok will look at it
03:23:17 <tdammers> akegalj: it is; but if you read the source code, you'll see how you can do IO from within TH
03:23:34 <akegalj> tdammers: ok, got it
03:23:43 <tdammers> file-embed uses this power to read files, but you can of course also go in the other direction
03:23:54 <bollu> if I have an IO action
03:24:02 <bollu> how do I use it along with a servant ExceptT?
03:24:08 <Voltzlive> Arrows are an abstraction of Monads (right?) but how would (>>>) be so different than just applying?
03:24:22 <akegalj> tdammers: thanks
03:24:34 <bollu> I want to unify a IO a with ExceptT ServantError IO b
03:24:40 <bollu> how do I do that?
03:24:47 <hpc> Arrow is extra stuff on top of Category
03:25:02 <KaneTW> bollu: from what direction
03:25:03 <shachaf> mtesseract: I was trying to be asleep a long time ago, but I'll give you a short example.
03:25:14 <shachaf> Say you have map. map f [] = []; map f (x:xs) = f x : map f xs
03:25:22 <bollu> KaneTW: IO to the ExceptT ... type
03:25:26 <KaneTW> lift
03:25:28 <mtesseract> shachaf: I'm listening!
03:25:32 <shachaf> You're computing map (+1) (1 : 2 : ...)
03:25:33 <hpc> there's an instance of Arrow for Kleisli, which is the type of functions (a -> m b)
03:25:42 <KaneTW> :t lift
03:25:43 <shachaf> map (+1) (1 : 2 : ...) = (+1) : (2 : ...)
03:25:44 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
03:25:48 <shachaf> Er.
03:25:53 <shachaf> map (+1) (1 : 2 : ...) = (+1) : map (+1) (2 : ...)
03:26:01 <shachaf> That's it, map's job is done.
03:26:04 <bollu> oh, so lift will work?
03:26:07 <shachaf> No, I wrote that wrong again.
03:26:12 <shachaf> map (+1) (1 : 2 : ...) = (+1) 1 : map (+1) (2 : ...)
03:26:32 <shachaf> map's job is done at that point. It gave you a (:), and what you do with it is up to you.
03:26:55 <hpc> Voltzlive: the why of Arrow is something along the lines of being able to write a larger set of calculations that are polymorphic over a Category-ish thing
03:27:02 <hpc> since otherwise you'd only get to use id and (.)
03:27:13 <mtesseract> shachaf: This is an example showing the usefulness of guarded recursion, as I understand it.
03:27:19 <hpc> but a lot of the usefulness of Arrow is lost by it having arr
03:27:20 <hpc> :t arr
03:27:21 <lambdabot> Arrow a => (b -> c) -> a b c
03:27:26 <Voltzlive> hmmm... 
03:27:30 <shachaf> Yes.
03:27:30 <mtesseract> shachaf: I don't intent to question that.
03:27:38 <hpc> which states that the arrow must always be some superset of haskell functions
03:27:47 <shachaf> Well, that function isn't tail-recursive, and it can run in constant memory.
03:28:12 <hpc> and it's not hard to imagine a useful category that doesn't involve (->)
03:28:16 <shachaf> Say you're computing the length of that list. The result of map can be GCed immediately.
03:28:25 <hpc> such as functions between finite sets
03:28:53 <hpc> so for the most part, Arrow is no longer considered to be a useful abstraction
03:29:21 <bollu> guys, how do I do IO inside a ExceptT?
03:29:27 <hpc> and it's just used as a way to get things like first :: (a -> b) -> (a, c) -> (b, c)
03:29:37 <Voltzlive> Correct me if I'm wrong
03:29:39 <hpc> bollu: use liftIO
03:29:47 <Voltzlive> Arrows are to Functions what Monads are to data?
03:30:04 <shachaf> Arrows are not important.
03:30:09 <bollu> hpc: it doesn't seem to be working
03:30:30 <bollu> hpc: which action do I liftIO?
03:30:35 <hpc> :t liftIO
03:30:36 <lambdabot> MonadIO m => IO a -> m a
03:30:37 <bollu> hpc: the IO action or the ExceptT actino?
03:30:47 <hpc> you liftIO an IO action, and it becomes some other type of action
03:31:09 <hpc> in your specific case, using the instance MonadIO m => MonadIO (ExceptT e m)
03:31:28 <hpc> and if your stack of transformers is just the one, followed by MonadIO IO
03:31:28 <bollu> hpc: do I need to import a module for that?
03:31:37 <hpc> you need liftIO in scope, yes
03:31:38 <shachaf> mtesseract: Maybe you're asking a different question than I thought.
03:31:48 <bollu> hpc: the exact transformer is: ExceptT ServantError IO Stockfighter.Orderboo
03:31:52 <shachaf> mtesseract: I guess you already had my example in mind.
03:32:00 <bollu> hpc: so a simple liftIO will work in this case?
03:32:01 <mtesseract> shachaf: I'm not sure, but maybe that helps.
03:32:08 <hpc> bollu: it should, yes
03:32:21 <bollu> hpc: thanks, I'll try it out!
03:32:32 <shachaf> mtesseract: I don't know what the texts you're thinking of say.
03:33:42 <chpatrick> Voltzlive: arrows are Categories with some extra features
03:34:27 <hpc> hmm, lambdabot doesn't have any of the transformers in scope
03:34:47 <mtesseract> shachaf: e.g. "In Haskell, the function call model is a little different, function calls might not use a new stack frame, so making a function tail-recursive typically isn't as big a deal???being productive, via guarded recursion, is more usually a concern." (https://wiki.haskell.org/Tail_recursion). I have been wondering if that somehow implies that because of the evaluation strategy used by e.g. GHC, stack
03:34:49 <mtesseract> growth is not a concertn when dealing with non-tail-recursive functions, because the compiler optimizes that non-tail-calls aways.
03:35:16 <mtesseract> shachaf: the "???" are a copy and paste error (utf-8).
03:36:29 <hpc> mtesseract: ghc's stack is an evaluation stack
03:37:05 <hpc> to use a highly contrived example, to evaluate something like (id (id (id (id (id 5))))), there's 5 ids on the evaluation stack plus a literal "5"
03:37:42 <hpc> it's still quite possible (and even easy) to overflow the stack, but how you do it is totally different
03:38:10 <hpc> in something like (fix (1:)), when you evaluate it...
03:38:13 <shachaf> I don't think your id example is accurate.
03:38:42 <hpc> oh yeah, it probably isn't
03:39:02 <bollu>     Couldn't match expected type ‘IO r0’   with actual type ‘ExceptT ServantError IO Heartbeat’
03:39:09 <bollu> I'm not sure why things aren't working :(
03:39:13 <bollu> I'm using a liftIO
03:39:35 <shachaf> I should really go to sleep, anyway.
03:39:55 <mtesseract> shachaf: Thanks for your help. Sleep well.
03:40:06 <shachaf> mtesseract: I don't think you need any special compiler optimizations for those statements to make sense.
03:40:49 <shachaf> Even with a pretty naïve graph reduction model it should be right.
03:41:07 <hpc> mtesseract: anyway, when you evaluate something productive like that fix expression, the stack never gets very high because it only evaluates as far as discovering the result is some cons cell (<thunk1> : <thunk2>)
03:41:21 * shachaf goes to sleep.
03:41:52 * hpc would have to think to come up with a better teaching example of a stack overflow
03:42:21 <hpc> a more opaque but easy to reproduce way to stack overflow is to use foldl with a strict function
03:42:36 <shachaf> Your example should be foldl.
03:42:48 <shachaf> But GHC doesn't do stack overflows anymore.
03:42:54 <mtesseract> hpc: I think my problem is that I used to know what a call stack is in e.g. C. I knew exactly what is put on the stack and when and how I can overflow it. I would like to be able to answer the same questions for HAskell.
03:42:55 <hpc> it doesn't?
03:43:06 <shachaf> No, it'll just grow the stack.
03:43:16 <hpc> ah, neat
03:43:30 <hpc> so now the stack is kind of like heap 2: electric boogaloo
03:43:31 <mtesseract> which means the stack is simple heap memory?
03:43:41 <mtesseract> (for modern GHCs?)
03:44:01 <shachaf> I don't know the details there.
03:44:30 <shachaf> > foldl (+) 0 [a,b,c,d]
03:44:31 <lambdabot>  0 + a + b + c + d
03:44:54 <shachaf> That's (((0 + a) + b) + c) + d
03:45:01 <shachaf> (+) is strict in both arguments.
03:45:03 <hpc> mtesseract: understanding ghc's memory model is highly dependent on understanding its evaluation strategy, which there's a commentary on the ghc trac which i think is still quite accurate
03:45:07 <hpc> @where commentary
03:45:07 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
03:45:12 <hpc> @where trac
03:45:13 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
03:45:17 <hpc> hmm
03:45:17 <mtesseract> shachaf: yes, the same is written on the paper on my desk. :-)
03:45:29 <hpc> https://ghc.haskell.org/trac/ghc/wiki/Commentary -- that one
03:45:41 <mtesseract> Thanks
03:45:57 <shachaf> I think the commentary is too low-level. But maybe it won't hurt.
03:46:01 <shachaf> So to evaluate that thing, you first need to evaluate ((0 + a) + b) + c
03:46:16 <shachaf> And when you're done doing that, you need to remember what to do with the result, which is to add it to d.
03:46:21 <shachaf> That's what you use the stack for.
03:46:44 <mtesseract> (phone, brb)
03:46:56 <shachaf> Good opportunity for me to actually go to sleep.
03:47:00 * shachaf goes.
03:47:18 <bollu> okay, new problem
03:47:24 <bollu> I have a main :: IO ()
03:47:30 <bollu> and I want to use values from a monad transformer stack
03:47:43 <bollu> transformer = ExceptT ServantError IO a
03:47:52 <hpc> you'll need to run transformer
03:47:53 <merijn> bollu: "main = runExceptT $ do ..." ?
03:47:58 <hpc> with something like... that
03:47:59 <bollu> ohh
03:48:02 <bollu> ah, thank you!
03:48:12 <hpc> runExceptT :: ExceptT e m a -> m (Either e a)
03:48:20 <bollu> what exactly happens when I run the transformeR?
03:48:26 <bollu> like, on an implementation level?
03:48:56 <hpc> it varies
03:49:23 <hpc> but for the most part, runFooT is just the record accessor for the FooT newtype
03:49:33 <bollu> I see
03:49:42 <hpc> and the magic is happening in (>>=)
03:49:52 <bollu> so, why do APIs return their transformer stack? why doesn't the API just squash the stack?
03:50:21 <hpc> how do you mean?
03:50:42 <bollu> hpc: why does the servant API Return the entire transformer stack of ExceptT ...
03:50:55 <bollu> why doesn't it just return the IO value by doing runExceptT $ <internal stack>
03:51:26 <merijn> bollu: What if you want to combine multiple servant operations?
03:53:27 <bollu> merijn: ah, okay, got the problem
03:54:08 <bollu> merijn: so the transformer stack lets me combine things with the correct semantics (>>= should work out), and then let you "collapse" the stack to the final IO value?
03:54:34 <hpc> pretty much
03:54:57 <semigroup> except that the base monad isn't necessarily IO
03:55:20 <bollu> semigroup: usually what will you have as the base?
03:55:42 <merijn> bollu: Whatever's convenient for your application :)
03:56:00 <hpc> other valid ways to end a transformer stack are Identity, some domain-specific type that doesn't have a transformer version, or one of the other IO-y base types like ST / STM
03:56:02 <semigroup> Yep, it really depends on the use case
03:56:03 <bollu> merijn: ahh :) 
03:56:17 <bollu> merijn: so, monads don't commute right? the order of the stack matters in that case
03:56:23 <merijn> bollu: Yes
03:56:31 <hpc> @src Identity
03:56:31 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
03:56:53 <bollu> what's the runtime impact of a transformer stack?
03:57:00 <hpc> that also depends
03:57:04 <bollu> on?
03:57:23 <hpc> the definition of the particular transformers involved and their order in the stack
03:57:27 <bollu> I see
03:57:45 <cocreature> is there some intuition for when ghc specializes typeclass dictionaries? I think it also does this if I don’t use SPECIALIZE right?
03:57:52 <bollu> one last question: I don't think all monads would compose will all other monads?
03:58:18 <hpc> all laws-obeying transformers compose
03:59:02 <semigroup> The most famous law-breaking transformer is ListT https://wiki.haskell.org/ListT_done_right
04:02:28 <bollu> hpc: oh, I didn't expect that
04:03:16 <hpc> well, why wouldn't they compose? that's what laws are for ;)
04:04:30 <bollu> hpc: :) categorically, sure, they should compose, but haskell always has surprises that screw it up :P 
04:04:38 <bollu> hpc: okay, what does ListT do?
04:04:49 <bollu> hpc: I understand the usual ones (ExceptT, StateT, ReaderT)
04:04:59 <bollu> ListT gives you non-determinism over arbitrary monads?
04:05:06 <hpc> pretty much
04:05:13 <bollu> hpc: example please?
04:05:19 <hpc> in theory, runListT :: ListT m a -> m [a]
04:05:26 <hpc> but it's a bit broken
04:05:38 <mtesseract> hpc: Thanks for the link
04:06:05 <hpc> and this is one of those rare cases where the wiki has good information, you should read semigroup's link
04:06:06 <bollu> hpc: how so?
04:06:11 <bollu> I see. thanks!
04:08:22 <hpc> 3.2 and 3.3 are the really good examples, showing how simple theoretically-identical statements produce different results
04:09:27 <hpc> hackage's version of ListT done right is LogicT, which looks entirely different if you look at the implementation
04:09:38 <merijn> Pipes also has one
04:09:53 <hpc> and it's a neat use of higher-ranked types
04:10:26 <tsahyt> haskellstack.org is down. Does anyone have a link to the stack repo for Fedora 24?
04:13:52 <tsahyt> nevermind, there's a copr repository
04:17:41 * hackagebot elm-export 0.4.0.0 - A library to generate Elm types from Haskell source.  https://hackage.haskell.org/package/elm-export-0.4.0.0 (krisajenkins)
04:31:14 <mtesseract> (for the record: one can easily trigger stack overflows with GHC compiled code)
04:31:34 <LKoen> intentionally or unintentionally?
04:32:35 <mtesseract> LKoen: Well, I am currently trying to trigger them intentionally in order to become more familiar with the execution model.
04:32:48 <Undreren> try foldr (+) 0 [1..100000]
04:32:57 <Undreren> > foldr (+) 0 [1..100000]
04:32:59 <lambdabot>  5000050000
04:33:02 <Undreren> > foldr (+) 0 [1..1000000]
04:33:04 <lambdabot>  *Exception: stack overflow
04:33:38 <Undreren> Summing a million elements with a right fold isn't exactly smart
04:33:41 <Undreren> ;)
04:33:58 <LKoen> > foldl' (+) 0 [1..1000000]
04:34:02 <lambdabot>  500000500000
04:34:30 <Undreren> A strict fold will work, but sometimes you forget to make it strict
04:34:33 <mtesseract> True. It was previously claimed that GHC doesn't do stack overflows anymore.
04:34:48 <Undreren> Maybe because you do not realize how large inputs you will be handing the function
04:34:53 <mtesseract> But maybe that was meant in a different way.
04:35:13 <clever> i believe tail-recursive is how the left fold can cheat and not overflow the stack
04:35:26 <Undreren> I think you are right
04:35:42 <clever> it uses jmp to enter the next function (usualy itself) rather then call
04:35:52 <clever> so the stack pointer doesnt have to move any
04:35:52 <dibblego> it uses seq to ensure constant stack
04:35:52 <Undreren> yeah
04:36:02 <dibblego> foldr will not always stack overflow as it may be optimised
04:36:48 <dibblego> foldl will also be optimised, even without having used seq
04:36:48 <mtesseract> Undreren: But what is it that causes the stack overflow in your example? The 100000 thunks building up? (I was udner the impression previously that thunks are stored on the heap, not on the call stack). Or is the stack overflow in this situation caused by the evaluation of the expression involving 100000 thunks?
04:37:14 <dramforever> Actually, http://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.List.html#foldl
04:37:34 <clever> mtesseract: i think it might be because each thunk depends on another, and thats causing the stack to inflate
04:37:51 <hpc> thunks do go on the heap, what ends up on the stack is "i am evaluating this, and to evaluate this i need to evaluate that, and to evaluate that i need to evaluate the other thing..."
04:37:55 <clever> mtesseract: but if you used strict types, it wouldnt make a massive chain of thunks, and would eval them much sooner on
04:39:24 <mtesseract> hpc: Is this basically the information encoded in the graph employed by the graph reduction?
04:41:17 <merijn> mtesseract: Do you know what CPS is?
04:41:22 <hpc> the stack would be your current path into the graph, or something along those lines
04:42:35 <mtesseract> merijn: No
04:43:21 <mtesseract> Ah, Continuation Passing Style.
04:43:27 <mtesseract> I am roughly familiar with that.
04:43:39 <merijn> mtesseract: Right, so the branches of a case are kinda like the continuation of a computation, right?
04:44:09 <newcomer> I need some guiding advice. I'm learning Haskell with no clear path. I'm just surveying the language. (The problem is that I'm not a programmer and never wrote "Real World" programs and have little incentive to actually do anything useful with PLs. I learn programming languages for the sake of it.) Anyway, in my attempt to survey Haskell, I get distracted. I learned the basics (higher order functions, ADTs, pattern matching, type classes and Mo
04:44:10 <merijn> mtesseract: As in "case foo of Left x -> stuff; Right y -> otherStuff" the Left/Right cases are just continuations of the "foo" operation
04:44:14 <newcomer> nads). I'm confused as what to learn next. I'm yet to learn some Monad instances (State, Reader, Parser), Monad Transformers, Free Monads, GADTs, and useful libraries like Lens. What should I start with? In what order should I learn these things? What additional things should I learn?
04:44:15 <mtesseract> merijn: Yes, and these branches are pushed on the stack during evaluation of a case expression, right?
04:44:30 <merijn> mtesseract: Right, because you need to remember which branch to take when it's done
04:44:31 <Voltaire> Hi, I am trying to understand uses of type classes. Many type classes I see use a sort of structural recursion over the type structure of one type parameter. For example if A and B are Eq, then (A,B) is Eq. What are some examples of type classes that do not follow this pattern?
04:44:46 <merijn> mtesseract: But what if evaluating foo has another case with branches? You need to track that too
04:44:58 <mtesseract> merijn: I think I have used that to trigger an (educational) stack overflow :)
04:44:58 <merijn> mtesseract: so you have a stuck of branches for nested cases
04:45:01 <akegalj> do I understand correctly that to make cabal hook I have to create Setup.hs in the same folder as <project-name>.cabal in the similar way as this example http://stackoverflow.com/a/17623564 ? Do I have to configure something additionally with stack/cabal files ?
04:45:09 <bollu> Voltaire: something like this? Monoid a => Applicative (Const a) 
04:45:23 <merijn> mtesseract: Evaluation finishes -> pop continuation of stack and pick approriate branch, repeat :)
04:45:29 <bollu> Voltaire: that's an actual instance if you were wondering
04:45:47 <mtesseract> merijn: That makes sense.
04:46:00 <mtesseract> merijn: So it is one point where I understand the stack usage.
04:46:08 <merijn> akegalj: The Setup.hs should be auto created by "cabal init", but yes, it should be there
04:46:46 <merijn> akegalj: Depends on how complex your setup is, if you only use "default" cabal features your Setup.hs will be only two lines
04:47:03 <merijn> mtesseract: That's the only stack that exists in (GHC) haskell :)
04:47:07 <akegalj> merijn: ok, we already have project setup with stack, so `cabal init` is extra I guess
04:47:18 <Voltaire> thanks :)
04:47:20 <merijn> akegalj: No clue, I don't use stack
04:47:30 <akegalj> merijn: thanks anyway... will try
04:47:50 <hexagoxel> akegalj: needs `build-type: Custom` in .cabal
04:48:02 <merijn> akegalj: The default Setup.hs looks like: https://github.com/merijn/lambda-except/blob/master/Setup.hs
04:48:02 <akegalj> hexagoxel: thanks
04:48:18 <merijn> Oh, wait, I missed the presence of hooks part
04:48:19 <merijn> Yes
04:48:23 <merijn> Use Custom build-type
04:49:22 <Voltaire> are there also type classes that 'recurse' on two arguments? the examples of type classes with two arguments that I've seen only recurse on one of them
04:50:10 <akegalj> merijn: thank you, will do some reading now to figure that out
04:54:14 <Boomerang> @src zip
04:54:14 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
04:54:14 <lambdabot> zip _      _      = []
04:54:38 <newcomer> @src zipWith
04:54:38 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
04:54:38 <lambdabot> zipWith _ _      _      = []
04:54:45 <Boomerang> Not a type class though, I was just curious
04:58:36 <merijn> Is there a C++ parser like language-c written in Haskell?
04:59:08 <merijn> Actually, it'd be sufficient for me to parse just function definitions/declarations
05:01:22 <bernalex> merijn: writing a c++-bnf is part of the introduction to programming languages course at Chalmers, so even I have a c++-parser lying around from doing that course on my own. :p 
05:02:16 <sbrg> bernalex: "introduction to programming languages" is a course about writing a compiler or just a course delving into some alternate programming languages?
05:02:16 <bernalex> oh, it's called "Programming Language Technology".
05:02:22 <sbrg> because if it is the .... yeah that makes more sense
05:02:56 <bernalex> sbrg: it goes on to the Compiler Construction course, which goes on to the Compiling Functional Languages course.
05:03:30 <sbrg> i see
05:03:50 <merijn> bernalex: Oh? Is it online somewhere?
05:04:11 <bernalex> merijn: the courses are all online. but the c++-bnf is iirc incomplete and I don't think I'd use it for industry work. :p
05:04:43 <merijn> bernalex: I don't need industry robustness, I just need "does the function declaration match a header file definition" levels of parsing
05:04:50 <bernalex> merijn: http://www.cse.chalmers.se/edu/year/2015/course/DAT151/ http://www.cse.chalmers.se/edu/year/2015/course/TDA283_Compiler_Construction/ http://www.cse.chalmers.se/edu/year/2011/course/CompFun/ are the three I mentioned.
05:05:25 <bernalex> merijn: ask Andreas Abel. he was helpful when I had questions doing the homework of a course I'm not registered for at a school I'm not registered at.
05:06:43 <mauke> merijn: well, that's easily turing complete
05:07:02 <merijn> mauke: Is it?
05:08:18 <mauke> it's also reversed. why would you have a function declaration if the header already contains a definition?
05:08:37 <merijn> mauke: I always get mixed up which is declaration and which is definition
05:08:53 <bernalex> mauke: DCE?
05:09:15 <bernalex> merijn: declaring x: int x; defining x: x = 42;
05:09:19 <chpatrick> merijn: if it's for practical purposes you could try https://hackage.haskell.org/package/clang-pure
05:09:33 <chpatrick> it should support everything clang does
05:10:01 <mauke> int foo();  if_then_else<is_prime<123456779>::value, int, void>::type foo();  // or something
05:10:20 <merijn> mauke: Right, but I only care about sane cases
05:10:42 <mauke> bernalex: int x; is a definition, x = 42; is assignment
05:10:42 <chpatrick> https://github.com/chpatrick/clang-pure/blob/master/examples/test.hs
05:10:48 <chpatrick> print out the types of every declaration in a header in 10 lines
05:11:17 <merijn> chpatrick: ok, that might be worth trying
05:11:30 <bernalex> mauke: I meant int x = 42; in the latter.
05:11:38 <mauke> that's a definition with initialization
05:12:46 <mauke> merijn: you might still run into typedef issues in practice
05:13:05 <merijn> mauke: I'm only trying to quickly hack together a workaround for the fact that NVidia's compiler engineers are retarded and unlike clang(++)/gcc/g++ can't manage to implement a -Wmissing-prototypes flag
05:13:17 <sbrg> lol
05:13:23 <mauke> oh, fun
05:13:24 <bernalex> mauke: per all classes I've had, and the results I got from a quick Web search, int x; is a declaration. so is int x();. int x = 42; and int x() { return 42; } are definitions.
05:13:31 <sbrg> but is that such a big issue for you that you want to write a tool to do it yourself? :O
05:13:39 <merijn> mauke: In fact I was told that according to their engineers it's "literally impossible"
05:14:06 <merijn> sbrg: I've thrice now spend two days debugging problems that would've been caught compile time by lack of prototype
05:14:13 <mauke> bernalex: depends on the context, but normally int x; is a definition
05:14:26 <bernalex> mauke: per teh C++ standard it's actually both.
05:14:32 <mauke> all definitions are declarations
05:14:40 <merijn> sbrg: i.e. "I changed either the definition/declaration and forgot to update the other and thus am calling code with wrong arguments and crashing"
05:14:46 <bernalex> mauke: yes but not all declarations are definitions.
05:14:59 <bernalex> merijn: int x; is a declaration and definition, but int x(); is only a definition.
05:15:03 <bernalex> sorry mauke 
05:15:07 <mauke> right. e.g. 'extern int x;' at global scope is a declaration only
05:15:18 <bernalex> yes, OK so we were in agreement all along probably. :)
05:15:27 <sbrg> merijn: aaaah like that. 
05:15:32 <merijn> sbrg: So, yes, at this point hacking together a dirty tool that checks this seems like a better investment of time than spending another two days debugging trivial issues in the future
05:15:58 <merijn> But if this clang-pure thing works that'd be awesome too
05:16:41 <bernalex> from the standard: "a declaration is a definition unless it declares a function without specifying the function's body."
05:16:47 <chpatrick> merijn: docs here btw http://chpatrick.github.io/clang-pure/Language-C-Clang.html
05:17:00 <merijn> The alternative would be to somehow hack together a list of "expected" missing symbols in my libraries and then run nm + grep to check for UNEXPECTED missing symbols, since that'd also be a tipoff
05:17:32 <merijn> chpatrick: You should manually upload them to hackage too :)
05:17:43 <bernalex> merijn: well, that, or not changing the definitions without updating the declarations. :)
05:17:59 <merijn> bernalex: Sure, I don't need a type system either if I just never write wrong code!
05:18:14 <bernalex> merijn: don't you habitually triple check everything in the header when you change something in c++? I sure do, after years of the stuff.
05:18:34 <merijn> bernalex: This is stuff I alter like 20+ times a day
05:18:55 <akegalj> hexagoxel: merijn thanks, it worked
05:19:11 <bernalex> merijn: I meticulously triple check everything, so I probably don't alter things 20+ times a day. in my experience this is more efficient long-term. :)
05:19:21 <merijn> chpatrick: I think modern cabal has like an "upload docs" flag, but there's other ways to do i manually to :)
05:19:31 <chpatrick> it should be in stackage too soon
05:19:49 <merijn> bernalex: You can't avoid 20+ alterations if you're comparing minor variations of the same code
05:20:24 <merijn> chpatrick: This approach works for my libraries: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
05:20:39 <merijn> And/or the script here: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Hackage-documentation-v2.html
05:20:43 <chpatrick> merijn: thanks
05:21:32 <bernalex> merijn: thank you for some perspective. you've made me glad that I only have to use c++ a little bit each day, instead of a lot. :)
05:57:19 <bag_> hello?
05:57:25 <tdammers> hi
05:57:34 <bernalex> hallo!
05:58:19 <mauke> a talking bag?!
05:58:26 <bag_> that's me
05:58:46 <Undreren> > putStrLn "Hello"
05:58:48 <lambdabot>  <IO ()>
05:58:50 <bag_> just having a look at the irc chat nearly every tutorial is talking about
05:58:51 <Undreren> aww
05:58:53 <akegalj> in Setup.hs (I am using custo haskell hook) how can I import package from that library and/or import some hackage package. I have added `build-type: Custom` to Setup.hs and it runs ok. But when I am trying to "import <some_module_from_that_library>" cabal can't find it neither it can find "import <some_package_installed_from_hackage_module>". Am I missing something ?
05:59:00 <bernalex> mauke: I've had conversations with talking bags in dnd.
05:59:23 <bernalex> bag_: irc = internet relay chat. irc chat = internet relay chat chat. fyi. :)
05:59:35 <bernalex> bag_: what do the tutorials say about us? nothing too bad, I hope?
05:59:35 <Undreren> bernalex: That sounds glorious
05:59:41 <akegalj> s/I have added `build-type: Custom` o Setup/ added to *.cabal/
05:59:45 <hodapp> bag_: you've not been on IRC before?!
05:59:59 <hodapp> bernalex: oh, pipe down and play with your GHC compiler
06:00:01 <bag_> first time on #haskell but i think i've used irc a few times
06:00:35 * hodapp . o O ( of course, if you're building GHC then GHC *is* your GHC compiler... )
06:00:58 <bernalex> hodapp: depending on how you're bootstrapping things and so on, it might even be your GHC compiler compiler compiler.
06:01:21 <hodapp> bag_: welcome!
06:01:32 <merijn> akegalj: Old cabal didn't allow you to add build-dependencies, I think newer cabal does, but not sure about the details
06:01:32 <bag_> hodapp: thank you ^_^
06:01:39 <merijn> akegalj: I recommend asking in #hackage
06:03:51 <akegalj> merijn: thanks
06:07:26 * hodapp looks over to-do list, tries to find a way to avoid everything that doesn't involve Haskell
06:07:44 * hackagebot servant-aeson-specs 0.2 - generic tests for aeson serialization in servant  https://hackage.haskell.org/package/servant-aeson-specs-0.2 (SoenkeHahn)
06:08:04 <bag_> how long have most of you used haskell for?
06:08:52 <bernalex> bag_: there's uh a lot of users in this chan. I don't think you'll get a lot out of that question. :p
06:09:00 <phanimahesh> Me, I've been learning for an year or so. Never did a real project, though. :(
06:09:02 <mauke> bag_: that's a pretty complex query
06:10:25 <bernalex> I picked it up 4 years ago or so. I used it in industry for a couple of years. unfortunately I don't do that now.
06:11:05 <phanimahesh> I would love to work on a non trivial real world project on haskell.
06:11:15 <merijn> phanimahesh: Xmonad, pandoc, ghc ;)
06:11:31 <bernalex> xmonad is actually trivial
06:11:34 <hodapp> bag_: well, I learned Haskell in 2013, and then actually learned it in late 2014 and used it on a non-trivial real-world project at my (former) job
06:11:34 <bernalex> in a *good* way
06:11:54 <bernalex> also, I'd add cabal and [insert any games or gui stuff] to that list.
06:11:58 <hodapp> should I switch from dwm to xmonad? my only reason for not doing so is basically "I'm lazy"
06:12:03 <phanimahesh> I know little, but am very confident that I can explain anything I know, reasonably well.
06:12:11 <bernalex> hodapp: switch to i3. it destroys everything else imo. :)
06:12:12 <merijn> phanimahesh: A lot of these large Haskell projects are substantially easier to dive into than smaller projects in other languages
06:12:28 <merijn> phanimahesh: For exaple, GHC uses fairly conservative haskell (not many if any extensions)
06:12:36 <bernalex> and haskell does incredibly well at compartmentalisation
06:12:36 <phanimahesh> I'm on i3. considered xmonad but many recommended i3 instead.
06:12:56 <bernalex> and refactoring is IME haskell's biggest strength by far
06:13:05 <bernalex> or, more specifically, how well refactoring scales.
06:13:27 <phanimahesh> merijn: The trouble is, my motivation levels vary wildly. And I am lazy. haskell and the community is awesome.
06:13:29 <hodapp> oh, I did rather large refactors and it was pretty surprising how well it worked
06:13:50 <merijn> phanimahesh: My first haskell contribution ever was extending the pandoc rST parser to properly support some stuff I needed (I think it was inline LaTeX support)
06:13:54 <bernalex> I rewrote GHC's typechecker completely to allow extra commas in maybe an hour. and it worked on my first compile. it was mind blowing.
06:13:55 <phanimahesh> Actually I was first fascinated by the haskell community. It has a reputation for being very, very nice.
06:14:21 <bernalex> phanimahesh: motivation is fleeting and uncontrollable, so it would be unwise to rely on it. instead, get disciplined.
06:14:33 <phanimahesh> Then I started listening in on conversations, and looked at the language.
06:14:54 <bernalex> merijn: my first contribution that was worthy of other people talking about was a paper.
06:15:23 <bernalex> a highly informal paper about picking up haskell for game programming. my point being: documentation, or even blog posts about diving into haskell, are just as meaningful contributions as code. :)
06:15:40 <mauke> bernalex: what's the type of a comma?
06:15:41 <phanimahesh> bernalex: Discipline is one quality I lack. I had everything easy, in retrospect. Trying to get into a routine and develop discipline.
06:15:57 <bernalex> mauke: oh wow, my bad. s/typechecker/parser/
06:16:40 <mauke> oh, that makes more sense
06:16:42 <bernalex> mauke: but since you ask: HsCommaList (HsRecField id arg)
06:16:43 <Xandaros> I'm looking for a data structure much like a list zipper. I have a list, with a focused element. Two operations I need are all the elements left of the focused element and all the elements right of it. None of the zipper packages I found have those operations - what am I missing here?
06:16:48 <mauke> heh
06:16:53 <bernalex> as an example
06:16:54 <bernalex> data HsCommaList a
06:16:56 <bernalex>   = Empty
06:16:58 <bernalex>   | ExtraComma (HsCommaList a)
06:17:00 <bernalex>   | Cons a (HsCommaList a)
06:17:12 <bernalex> then you get (HsCommaList (HsRecField RdrName (LHsExpr RdrName))) and so on.
06:17:22 <bernalex> I should revive that thing since I had it pretty much ready to go.
06:28:03 <srhb> Xandaros: Usually you just pattern match either side out.
06:28:30 <Xandaros> Yeah, I guess that's what I'm going to do
06:42:45 * hackagebot stache 0.1.1 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-0.1.1 (mrkkrp)
07:31:06 <MrDetonia> Is it considered bad style to create a type for a common kind of function? e.g. type CmdFunc = Message -> Maybe (T.Text, T.Text)
07:31:30 <MrDetonia> this is a common type signature in this one file only, and is not used anywhere else
07:32:07 <merijn> MrDetonia: To make other type signatures more readable, you mean?
07:32:13 <MrDetonia> exactly, yes
07:32:20 <MrDetonia> I'm using HOF a lot, and it was getting messy
07:32:43 <tdammers> matter of taste I'd say
07:32:58 <merijn> MrDetonia: I'd say that's like one of my main uses of type aliases
07:33:05 <tdammers> it's a pretty common idiom, many packages on hackage use it, others avoid it
07:33:06 <geekosaur> likewise
07:33:13 <MrDetonia> ah okay, that's good then
07:33:22 <tdammers> the advantage is that your type signatures are shorter and simpler; the downside is that they're more obscure
07:33:26 <MrDetonia> just wanted to make sure I wasn't breaking some sacred rule :P
07:33:37 <tdammers> WAI, for example, uses it quite heavily
07:33:39 <merijn> MrDetonia: It's about the only thing type aliases are good for
07:39:26 <tdammers> merijn: there's also the case where you define more descriptive aliases for generic types
07:39:31 <tdammers> type UserID = Integer
07:39:44 <tdammers> also, quite useful for aliasing platform-dependent types
07:39:48 <tdammers> (e.g. CInt)
07:40:13 <tdammers> (although that one actually isn't a type alias)
07:40:27 <geekosaur> although that can easily be an antipattern (aliases for general types) because if it wants to be that easily distinguished, perhaps it should be distinct so the compiler can help you catch misuse...
07:40:28 <tdammers> . o O (note to self: think before you write)
07:40:41 <tdammers> geekosaur: yes, if possible, newtype is preferred
07:41:50 <ertesx> MrDetonia: don't overuse it though
07:42:28 <ertesx> MrDetonia: one of the number one reasons i find code hard to read is that it used too much indirection
07:42:30 <MrDetonia> ertesx: yeah, it was just in this one file where I'm passing functions around in different places
07:42:35 <tdammers> as always, use taste
07:44:12 <MrDetonia> also, while I'm here, is it a good idea to wrap a function in parentheses, even when it's at the end of a type signature?
07:44:24 <MrDetonia> e.g. bleh :: a -> (a -> b)
07:44:34 <MrDetonia> I know that doesn't matter because of currying, but it seems clearer
07:45:03 <merijn> MrDetonia: I would say that's not a good idea, because it makes function types really noisy to read
07:45:04 <ertesx> MrDetonia: since that's equal to 'a -> a -> b', and since haddock won't take it into docs
07:45:28 <merijn> MrDetonia: Besides, not doing so will force you to more quickly adjust to reading them right ;)
07:45:30 <MrDetonia> ah, okay then
07:45:35 <MrDetonia> yes, true
07:45:37 <MrDetonia> thanks
07:46:00 <ertesx> MrDetonia: but if you like that style, no worries…  for example i like to put parentheses around contexts, even if there is only one condition
07:46:07 <ertesx> (Num a) => a -> a -> a
07:47:48 * hackagebot ip 0.8.4 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.8.4 (andrewthad)
07:48:55 <bollu> I was wondering what the current state of the art haskell openGL story is
07:49:02 <bollu> is there a nice "high level" ish openGL library?
07:49:12 <bollu> by high level, I don't mean "abstract out openGL"
07:49:33 <bollu> I mean something more like "handle the 20 years of API pain and don't make me call glTextParameterOhGodWhati"
07:49:53 <bollu> rust has glium for example
07:49:57 <bollu> I wanted something like that
07:50:18 <ertesx> bollu: OpenGL is the highest-level library i'm aware of, and it actually fixes the problem you just mentioned, but it comes with its own set of problems
07:50:28 <ertesx> bollu: the 'gl' library was created as a response, but it's low-level
07:50:32 <bollu> ertesx: what's the problems that it has then?
07:50:33 <merijn> Man, there isn't even a nice high level OpenGL library outside of haskell >.>
07:50:48 <bollu> merijn: the one I mentioned, glium is pretty nice
07:50:58 <ertesx> bollu: OpenGL has some issues with multi-context applications
07:51:16 <bollu> ertesx: ah. But I don't think I'll be using more than one context at a time, so that should be okay
07:51:28 <sm> what about luminance
07:51:36 <bollu> sm: isn't that only for shaders?
07:51:36 <ertesx> bollu: the trend is to go with 'gl' these days
07:51:44 <sm> oh, maybe
07:51:45 <bollu> ertesx: I see
07:52:01 <ertesx> bollu: and yes, i agree…  OpenGL is a terrible API
07:52:22 <ertesx> haskell can do a few things to make it more reasonable, but not much
07:52:35 <Henson> hello everyone, I was wondering if somebody could help me track down the "tryParse" command to implement an instance of the Read class.  I can't find out what library exports it.  Google, Hoogle, and other search engines are of no help.  Does that command still exist or is it deprecated?
07:52:41 <bollu> ertesx: It's quite unfortunate tbh :( I've been writing a lot of webGL lately and I love three.js.
07:53:09 <bollu> ertesx: even though I don't use most of it's stuff - its still nice to be able to compile a shader an link a program and get pixels on the screen in like, 20loc
07:53:21 <ertesx> bollu: but three.js is rather high-level…  WebGL is basically OpenGL ES
07:53:25 <lyxia> Henson: where have you seen this function?
07:53:38 <bollu> ertesx: yeah, I know. I mostly use it to get a context going and a couple render buffers
07:53:46 <bollu> ertesx: I do most of my thing in the shaders :)
07:54:34 <bollu> is this the OpenGL package? https://hackage.haskell.org/package/OpenGL
07:55:00 <ertesx> bollu: a lot of people would be grateful, if you could create a high-level OpenGL wrapper that is also useful =)
07:55:03 <Henson> lyxia: in "real world haskell" in chapter 6 on using typeclasses.  I also used it in a program I wrote last year but can't figure out what module to import to get it.
07:55:15 <ertesx> bollu: that's the one – the broken one
07:55:28 <ertesx> bollu: the non-broken but lower-level one is:
07:55:31 <ertesx> @package gl
07:55:31 <lambdabot> http://hackage.haskell.org/package/gl
07:55:55 <bollu> ertesx: haha, yeah. I actually submitted a GsoC proposal this time for binding diagrams to openGL. So you could hopefully do a bunch of interesting things and not have it compile to gif.
07:56:03 <ertesx> int-e: those links should probably be fixed to be 'https'
07:56:22 <bollu> ertesx: but, well, haskell didn't participate in gsoc
07:56:33 <ertesx> bollu: you can certainly do interesting things with that, but you probably won't be writing shaders =)
07:56:36 <bollu> ertesx: I think I will work on that first (diagrams <-> opengl)
07:56:42 <bollu> ertesx: yes, that's true
07:57:04 <bollu> ertesx: but I wanted to get a feel for how openGL in haskell would be, and I thought that being able to render all of what diagrams supports would be a good first step
07:57:16 <bollu> ertesx: vector graphics and animations that is
07:57:22 <Henson> lyxia: uh oh, it looks like I didn't search closely enough.  It's actually a function I defined myself.  I must have copied it from "real world haskell" and forgot I did that :-(  So sorry.
07:57:27 * Henson slaps himself in the head
07:57:36 <bollu> ertesx: I would like to take a stab at implementing a high level openGL interface
07:57:44 <ertesx> currently: just as terrible as in all other languages, except the not-directly-OpenGL stuff is pretty nice, like linear algebra
07:57:44 <bollu> ertesx: high level in the sense that I talked about.
07:57:48 * hackagebot hjsonpointer 0.3.0.2 - JSON Pointer library  https://hackage.haskell.org/package/hjsonpointer-0.3.0.2 (seagreen)
07:57:57 <lyxia> Henson: I have it, I just found an occurence and it is defined locally in the snippet.
07:58:21 <ertesx> bollu: for example the 'linear' library is a great linear algebrea library that works well with OpenGL, particularly 'gl'
07:58:29 <Henson> lyxia: great, thank you for looking.
07:58:31 <bollu> ertesx: I see
07:58:44 <bollu> it seems like luminance is trying to do exactly that? https://hackage.haskell.org/package/luminance
07:58:50 <lyxia> Henson: No problem. You're welcome!
08:01:03 <ertesx> bollu: apparently there is also a library called 'linear-OpenGL'
08:01:28 <bollu> ertesx: huh, just checked it out
08:01:30 <bollu> pretty cool
08:04:27 <ertesx> bollu: luminance looks very interesting
08:04:46 <ertesx> not familiar with it myself, but from the description and the dependencies it's interesting indeed
08:05:17 <bollu> ertesx: I know right? I think I'll play around with it this week
08:27:49 * hackagebot purescript 0.9.2 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.9.2 (PhilFreeman)
08:30:42 <nmattia> hey guys, is there a way to have 'stack upload .' upload the documentation as well?
08:31:52 <cocreature> nmattia: sadly not
08:31:57 <nmattia> or should I just wait, and eventually hackage will build it?
08:32:04 <cocreature> or at least not yet there is an issue for it, but it’s been open for ages
08:32:14 <nmattia> cocreature: ah, thanks
08:32:20 <nmattia> cocreature: how does one go about it then?
08:32:32 <cocreature> nmattia: I use cabal for uploading docs even though I use stack otherwise
08:32:49 * hackagebot makefile 0.1.0.0 - Simple Makefile parser  https://hackage.haskell.org/package/makefile-0.1.0.0 (nmattia)
08:33:11 <nmattia> ah, there's my package
08:33:11 <cocreature> I think the idea of letting hackage build docs is silly in the first place. it’s a package repository not a ci server
08:33:24 <nmattia> alright, thanks a lot
08:34:34 <tdammers> cocreature: it's a package repository, and "building" the documentation is, in theory, just showing information that is embedded in the package
08:34:53 <tdammers> hackage displays other information as well, so why not documentation
08:35:06 <tdammers> granted, in practice it does boil down to CI, more or less
08:35:11 <nmattia> cocreature: will hackage pick up anything that's in the format mypackage-1.2.3.4-docs.tar.gz?
08:35:19 <cocreature> tdammers: not really, haddock builds the package and that simply can’t work in all cases because of missing deps or whatnot
08:35:43 <tdammers> cocreature: well, yes, that's why I said in practice is *does* boil down to CI
08:35:55 <tdammers> "in theory, there is no difference between theory and practice"
08:38:49 <beekeeper> at the end of my ST monad I have this little turd, and I wondered if it could become 1 line somehow:
08:38:52 <beekeeper>         photons <- Vector.freeze v
08:38:55 <beekeeper>         randFloats <- readSTRef f
08:38:57 <beekeeper>         return (photons, randFloats)
08:39:34 <beekeeper> like a mapM for tuples :-/
08:39:47 <merijn> nmattia: Modern cabal should have a command to upload docs, but if your cabal is old, see http://fuuzetsu.co.uk/blog/posts/2014-01-06-Hackage-documentation-v2.html
08:40:55 <nmattia> merijn: cabal version is 1.22
08:41:10 <nmattia> latest being... 1.24/
08:41:11 <nmattia> ?
08:42:49 * hackagebot postgresql-query 3.0.1 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  https://hackage.haskell.org/package/postgresql-query-3.0.1 (AlekseyUymanov)
08:42:58 <mauke> beekeeper: (,) <$> Vector.freeze v <*> readSTRef f ?
08:43:00 <merijn> nmattia: No idea at which version the feature was added :)
08:45:20 <nmattia> merijn: no worries. the article you linked is helpful though.
08:46:37 <nmattia> feel like it's time to ditch stack in favor of cabal, or I'll never understand what I'm doing
08:47:14 <dysfun> wut?
08:47:19 <dysfun> how does that work?
08:55:11 <eklavya_> I am able to get an aeson FromJSON instance for Int/Double/Text/String etc but not ByteString !
08:55:13 <eklavya_> http://pastie.org/10904194
08:55:21 <eklavya_> this is the error I get
08:55:25 <eklavya_> what could be wrong?
08:56:27 <eklavya_> in the docs it shows that there is an instance for ByteString
08:56:42 <dysfun> is it the wrong bytestring?
08:56:53 <mauke> missing import?
08:57:00 <eklavya_> I imported Data.ByteString
08:57:19 <eklavya_> and I added bytestring as a dependency
08:57:20 <mauke> that's probably not where the instance is defined
08:59:05 <nmattia> cocreature: so while I was trying to figure out how to upload docs to hackage, it looks like hackage built it for me
08:59:15 <dysfun> http://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson.html#g:8
08:59:17 <nmattia> cocreature: were we talking about two different things?
09:02:09 <geekosaur> eklavya_, confusingly there are two different "ByteString" types, one from Data.ByteString and the other from Data.ByteString.Lazy
09:02:18 <cocreature> nmattia: sometimes it works reasonably well, sometimes it takes ages or doesn’t work at all
09:03:32 <eklavya_> mauke instance is defined in aeson and that's imported
09:03:43 <eklavya_> dysfun: it's listed in Data.Aeson.Types
09:03:52 <eklavya_> geekosaur: tried both :(
09:04:11 <dysfun> eklavya_: and did you import Data.Aeson.Types ?
09:04:24 <geekosaur> another possible cause is that aeson was built against a different version of bytestring
09:04:26 <eklavya_> yes
09:04:37 <geekosaur> (this one usually shows a versioned symbol somewhere)
09:04:52 <eklavya_> dysfun: it works as soon as I change the type to anything else, they are listed in the same package
09:05:09 <eklavya_> geekosaur: how do I check that
09:05:31 <eklavya_> oh maybe that package page lists it
09:05:34 <eklavya_> let me check
09:05:34 <cobreadmonster> Hello.
09:06:01 <geekosaur> web pages can't show what package versions you have installed locally
09:06:30 <Henson> eklavya_: does a FromJSON instance for ByteString make sense given the types that can be encoded into JSON?  Int, Double, Text, and String all have instances because they're some of the fundamental types that can be encoded in JSON.
09:06:54 <cobreadmonster> I've fucked up my ghc install.
09:07:04 <eklavya_> Henson: https://hackage.haskell.org/package/aeson-0.3.2.4/docs/Data-Aeson-Types.html
09:07:11 <eklavya_> there is an instance for ByteString
09:07:36 <eklavya_> geekosaur: yeah, I wanted to check if the required ByteString version was what I was using
09:07:57 <Henson> eklavya_: I see it now, thank you.
09:08:18 <geekosaur> it's trickier even than that, I'm afraid. has to be an exact binary match :/
09:08:28 <eklavya_> oh man :(
09:09:04 <eklavya_> wait, that doc page is saying aeson 0.3.2.4 !!??
09:09:06 <geekosaur> reinstalling the exact same version of a package will break all the packages that were built against the old one, because ghc exports inlining information and there are some internal details there that change with each compile
09:09:18 <eklavya_> and the package page says 0.11.2
09:09:36 <cobreadmonster> geekosaur: Isn't stack meant to solve these kinds of issues
09:09:37 <cobreadmonster> ?
09:10:06 <geekosaur> sometimes
09:10:06 <barrucadu> eklavya_: That's because you linked to the docs for aeson-0.3.2.4: it's right there in the URL
09:10:27 <geekosaur> as much as people would like to believe cabal causes these and stack cures them, people run into this with stack sometimes as well
09:10:42 <eklavya_> barrucadu: yeah, that;s what I just noticed
09:10:51 <eklavya_> in the new docs page I can't find a list of instances
09:10:59 <eklavya_> maybe ByteString is not supported anymore?
09:11:08 <eklavya_> but how to be sure :P
09:11:34 <snaek> Hello world.
09:11:39 <cobreadmonster> I wish we had a venv for Haskell.
09:12:17 <barrucadu> You could just make a separate cabal sandbox for every project
09:12:35 <geekosaur> cobreadmonster, we did (hsenv)
09:13:23 <geekosaur> it has its own problems. (stack does a good but not 100% perfect job of fixing its shortcomings too.) but when it comes down to it, ghc does things that help performance a lot but make ecosystems *really hard* to manage
09:14:32 <geekosaur> recent cabal with backpack (cabal new-build and friends) does an even better job, but I don't think there's any sure fire 100% solution even possible
09:18:17 <Cale> You can use nix environments
09:18:28 <Cale> But then you're saddled with dealing with nix ;)
09:19:09 <cobreadmonster> geekosaur: what are these problems?
09:19:33 <Cale> Nix is technically quite good, but its configuration language... well, I don't know why they felt the need to make up some random new language for configuring nix rather than just using a real one.
09:19:55 <cobreadmonster> I mean, why are systems hard to manage?
09:20:04 <ertesx> Cale: for haskell development you rarely have to touch nix at all though
09:20:20 <suppi> Cale, have you tried guix?
09:20:21 * geekosaur should probably dig up the last time he explained this, as it's fairly lengthy (the problems are not that hard to list, but everyone thinks the fixes are obvious and explaining why it's not that simple gets long)
09:20:25 <Cale> suppi: I haven't
09:21:01 <ovibos> suppi: have you?
09:21:08 <suppi> not yet
09:21:17 <Cale> suppi: But I've heard of it and it sounds somewhat interesting. I don't know what the tooling is like for guile, but I imagine it's got to be better than for nix configuration files.
09:21:38 <Cale> But really what I want is something with a static type system
09:21:42 <Cale> Like, e.g. Haskell
09:21:44 <Cale> ;)
09:21:48 <ertesx> the general idea is to write `cabal2nix --shell ./. > shell.nix`, and then wrap all commands by `nix-shell --pure --command`
09:21:50 <suppi> :)
09:22:35 <Cale> ertesx: Yeah, which is great so long as that's all you need
09:23:00 <Cale> Nix is great as long as other people handle configuring it for you :)
09:24:07 <ertesx> Cale: it's not that bad, if you have to touch it…  the nix language is pretty much a mini-haskell without static types and without top-level bindings =)
09:24:39 <Cale> The "without static types" thing makes it really hard to figure out what's going on a lot of the time
09:25:21 <ertesx> yes, and the topic has its own issue in the nix issue tracker
09:25:29 <ertesx> but i doubt that it will ever be changed
09:25:41 <ertesx> and guix doesn't fix that either, unfortunately
09:26:26 <magneticduck1> 'mini-haskell'? more like a lambda calculus with sets
09:26:31 <Cale> Well, what we really need is a Haskell implementation of Nix, which can interpret .nix files and so we can gradually replace things :)
09:26:54 <ertesx> magneticduck1: it's lazy and has 'let'…  so it's like haskell core
09:26:55 <dysfun> well volunteered
09:27:39 <Cale> dysfun: There are some steps in that direction already...
09:27:53 * geekosaur needs a more flexible/appropriate version of "I'm not expendable, I'm not stupid, and I'm *not going*"
09:27:58 <nmattia> Cale: where can we follow those?
09:28:31 <Cale> http://hackage.haskell.org/package/hnix
09:28:48 * dysfun isn't really convinced that haskell adds anything to the equation, just wants any sane language to replace nixlang
09:29:21 <ertesx> haskell at least makes it easy to implement a language
09:29:30 <Cale> dysfun: Well, I'm saying Haskell ought to be that language
09:29:32 <ertesx> hnix doesn't seem to be a better language though, just nix in haskell
09:29:44 <dysfun> but why?
09:29:52 <dysfun> guix uses scheme. not perfect but good enough
09:30:01 <dysfun> what does haskell actually win me for this type of work?
09:30:05 <Cale> Yes, hnix would just help implementing the nix compatibility -- package-level compatibility would be useful to get off the ground
09:30:10 <ertesx> (also i can't figure out why haskell language implementions never use locally nameless binding)
09:31:01 <rayners> Hi, any hint about creating a PDF using Pandoc with styles or at least a simple formatting?
09:31:30 <Cale> dysfun: All the things Haskell usually gets you: a nice type system, GHCi, Haddock
09:31:42 <ertesx> rayners: use a document class or write a LaTeX template that implements the style you want
09:31:57 <ertesx> rayners: see: pandoc -D latex
09:32:04 <dysfun> Cale: why do types help me build systems like this? it seems to be dynamic languages have got this licked
09:32:08 <ertesx> rayners: that's the default tempalte
09:32:17 <dysfun> and haskell is far from the only language to support a repl
09:32:40 <ertesx> dysfun: the reason i have trouble understanding nixpkgs is that it is untyped
09:32:48 <rayners> :ertesx thanks dude
09:32:57 <ertesx> rayners: you're welcome
09:33:01 <Cale> dysfun: Dynamic types don't mean that you don't have to deal with types, they just mean that *you* have to deal with types.
09:33:35 <dysfun> https://www.gnu.org/software/guix/manual/html_node/Using-the-Configuration-System.html#Using-the-Configuration-System 
09:33:58 <dysfun> how does using haskell instead of scheme actually significantly improve upon that example?
09:34:05 <geekosaur> dynamic languages mean you can ignore types right up until you suddenly have a string where you expected a dict and ???
09:34:51 <ertesx> dysfun: the number one way i learn APIs is by looking at names and types…  something like nixpkgs is in fact an API in disguise
09:35:04 <ertesx> guix fixes part of it:  it gives me names
09:35:08 <ertesx> but it still lacks types
09:35:20 <dysfun> hrm, i guess my brain just works different
09:35:22 <ertesx> so i have to read source code or rely on mostly non-existent documentation
09:36:26 <ggVGc> bash has the best type system
09:36:31 <ggVGc> strings all the way down
09:36:34 <ggVGc> whooho
09:36:43 <ertesx> i wouldn't say that haskell is the best choice, but anything typed and with parametric polymorphism would be an improvement over guix/nix
09:36:44 <dysfun> tcl does that better
09:36:47 <ggVGc> :(
09:37:33 <kazagistar> I thought nix was "like haskell"? Did I mishear?
09:37:36 <ertesx> personally i'd add modules and types to nix, then it is in fact just a mini-haskell
09:37:55 <ertesx> kazagistar: it's not "like haskell" enough =)
09:37:59 <geekosaur> kazagistar, to a C++ programmer it looks "like Haskell". to a Haskeller, not so much
09:38:00 <ggVGc> one day nix will just be a library for haskell
09:38:22 <Cale> dysfun: Basically, type systems let the part of your brain which is responsible for checking that types always make sense get some rest now and again
09:38:59 <ertesx> kazagistar: it has some key properties (like laziness and a functional API), but lacks some other key properties (proper modules, types)
09:39:30 <dysfun> Cale: sure. i'm not sure that this is a domain where types show themselves off best though
09:39:49 <ertesx> dysfun: it is one killer feature of static types for me – not the only one, but definitely one
09:39:59 <Cale> dysfun: Because the compiler is going to check, you don't need to worry about it *all the damn time*. It's really frustrating to spend 2 hours tracking down a bug where some incorrect data went through some long procedure without tripping any dynamic type checks before coming out incorrect on the other end, and then realise that if you had a type checker, it would have given you the appropriate line number up front.
09:39:59 <dysfun> but then again i'm still waiting to see this done but with types :)
09:40:41 <dysfun> and sure it is, but the type system also isn't some sort of panacea, it's a tool like any other
09:40:53 <ertesx> dysfun: exactly =)
09:41:00 <ertesx> and i'm a heavy user of this tool
09:41:02 <ertesx> others aren't
09:41:13 <Cale> Nix is full of usages of higher order shenanigans and understanding the types of expressions gets pretty hard quickly.
09:41:25 * dysfun has to flick between typed and untyped languages a lot, doesn't mind either
09:41:27 <Cale> (at least for me)
09:41:37 <dysfun> yeah but nix is crack
09:41:51 <kazagistar> I like using libraries written to utilize type systems, and get really really annoyed using libraries that are "dynamic"
09:41:56 <Cale> The real reason that I want it is so that I can have sane documentation of what's already there
09:42:03 <Cale> With, you know, type signatures.
09:42:15 <dysfun> i saw the word "monad" in conjunction with guix. my experience of monadic programming in clojure was *awful*, so you can imagine i'm looking forward to doing it in scheme a lot
09:42:18 <Cale> It's impossible for me to understand anything without the type signatures :D
09:42:35 <ertesx> dysfun: i wouldn't expect a much better experience in scheme either =)
09:42:45 <dysfun> no. monads need a type system
09:42:50 <kazagistar> "just pass in some string, followed by something to run it on" 
09:42:52 <ertesx> effective use of monads requires the compiler to know which monad you want
09:42:55 <Cale> Monads are basically a non-working abstraction in anything which doesn't have type classes.
09:43:20 <Cale> Unless you really enjoy threading a third parameter to every bind
09:43:47 <kazagistar> "what can I run it on?"  "oh, you know, a name of a file, or a function, or an object with a run function, or our special wrapper thing, or a number in the predefined process table" "O_o"
09:44:16 <ertesx> ironically i've done PHP for several years
09:44:56 <dysfun> you say ironic, i say tragic :)
09:45:09 <ertesx> yet: take :t away from me, and i can't write a line of code anymore
09:45:29 <Cale> ertesx: Yeah, this is the real thing which I can't handle about nix
09:45:51 <Cale> I need to be able to interactively ask the system about the types of expressions, or I'm just completely lost
09:46:02 <ertesx> ditto
09:46:47 <dysfun> do you know how many people say the exact opposite when learning haskell?
09:47:01 <ertesx> dysfun: at least one: an earlier version of me
09:47:19 <Cale> dysfun: Which opposite?
09:47:23 <dysfun> i think it was never helped by the historically bad error messages
09:47:29 <Cale> They need to not be able to do that?
09:47:46 <dysfun> that the types confused them horribly
09:48:23 <Cale> Being told that you're wrong about something that you don't understand on line 106 is better than not being told and just having a program which doesn't work :)
09:48:41 <Cale> (for a reason that is hard to begin to figure out)
09:48:44 <ozgura> hi! how does one use the impl syntax of ghc to check for, say, ghc-7.8.4? I tried `if impl(ghc == 7.8)` but it doesn't seem to work.
09:48:48 <dysfun> no, now you can have a system that doesn't work instead :)
09:48:53 <ozgura> impl syntax of cabal, I guess
09:48:59 <Cale> hm?
09:49:50 <ertesx> dysfun: what kept me going was that once the types made sense to me, it was always crystal-clear, and the type system went one step further from "i'm your oppressor" to the "i'm your best friend" side
09:50:09 <ozgura> like this, but for checking the exact version: https://github.com/nick8325/quickcheck/blob/master/QuickCheck.cabal#L80
09:50:09 <Cale> ozgura: ghc == 7.8.* ?
09:50:24 <ozgura> Cale: oh, that makes sense
09:50:26 <dysfun> ertesx: yes, i know what you mean. i find java's type system annoys me, but haskell's i quite like
09:50:44 <ozgura> Cale: do you know how I could have found this out by myself? I cannot find any documentation about the feature.
09:51:06 <ertesx> dysfun: it's not about writing correct programs for me…  it's about letting the compiler do the book-keeping and telling me where i can do what…  and later types become my main modelling language
09:51:14 <Cale> ozgura: I would assume it's somewhere in the cabal user's guide
09:51:26 <ertesx> s/telling/tell/
09:51:52 <dysfun> ertesx: yes, i quite often open a haskell-mode buffer and just start writing functions to let the type checker do my thinking for me
09:52:16 <ozgura> Cale: thanks!
09:52:19 <ertesx> dysfun: yeah, and that's why i can't code in scheme – i've tried =)
09:52:38 <ertesx> i wanted to write some system stuff in chicken-scheme, but ended up writing them in haskell
09:52:41 <Cale> https://www.haskell.org/cabal/users-guide/developing-packages.html -- search for the paragraph staring "You will notice"
09:52:42 <dysfun> heh
09:52:46 <Cale> starting*
09:53:15 <dysfun> i do find myself more annoyed with dynamic language bugs these days since i've been writing a lot of haskell
09:53:29 <dysfun> but i also recognise that quite a few of the bugs i fix wouldn't have been caught either
09:54:37 <ertesx> dysfun: i basically write the same code in dynamic languages that i would have written in haskell, only MUCH slower, because i do the type stuff in my head and in code comments…  so yeah, i actually end up with relatively bug-free code, but it takes me forever to get there
09:54:58 <dysfun> heh. clojure stuff i mostly do at a repl
09:55:03 <Cale> Sometimes I've been surprised though. There was one time when I screwed up a graph traversal algorithm in such a way that it would have missed vertices, and the type system actually managed to catch it.
09:55:17 <dysfun> nice
09:55:26 <ertesx> Cale: parametricity?
09:55:31 <dysfun> i'd really like to see dependent types in haskell
09:56:04 <Cale> ertesx: Yeah, something along those lines... I forget the details now, this would have been back in 2004, the particular thing I'm thinking of
09:56:39 <ertesx> Cale: that's one reason why a lot of my code uses RankNTypes, even though it wouldn't be necessary
09:57:20 <Phillemann> I wanted to try intero using a clean install (no .ghc or .cabal present) and got this error (and a compile error following that): http://ideone.com/4b1fkA
09:58:03 <Phillemann> It's supposed to have been tested with ghc-7.10.3, which I use, so I was wondering if I could tweak my stack project yaml to make it work?
09:59:16 <mgsloan> So you used stack to setup ghc?
09:59:40 <Phillemann> No, I have it installed via my package manager.
09:59:50 <Phillemann> Maybe that's causing the problem?
10:00:02 <mgsloan> Ah, I think that is the issue here.  For some reason your global DB / ghc depend on a different transformers version than usual
10:00:16 <mgsloan> So is this actually causing issues?  Those are just warnings
10:00:39 <Phillemann> Well, the build fails due to "No instance for (MonadIO Ghc) arising from a use of ‘liftIO’"
10:00:45 <mgsloan> Ah, darn, yeah
10:00:53 <Phillemann> So I'll try uninstalling my global ghc.
10:01:17 <mgsloan> Yup, and re-install with "stack setup".  If that doesn't fix it, then this is definitely something to fix in intero
10:01:27 <mgsloan> (and should be reported as an issue)
10:02:19 <Phillemann> Okay, let's see.
10:11:31 <lambdafan> I'm trying to write library for kd-trees adapted to regions. The application I have in mind is a text-based space-simulation. I'm using the Samet book and have focused in on the kdb-tree variant. But I see nothing concerning a nearest neighbor operation. Does this mean nearest neighbor makes no sense for kdb-tree applications?
10:13:56 <the_2nd> Even after adding TypeSynonymInstances to my file, I get the error that I have to use it within the file I'd like to write an instance for a type
10:14:54 <the_2nd> do I have to add it somewhere else?
10:16:03 <Phillemann> Damn. stack _really_ shouldn't use /tmp/ for its temporary files.
10:17:09 <Cale> Well, the real problem is that distributions _really_ shouldn't use ramdisks for /tmp
10:17:31 <dysfun> it used to be a ramdisk, a long time ago
10:17:36 <the_2nd> can anyone help? do I have to define it where the type is defined?
10:17:47 <Cale> It has almost no benefit these days, because there are disk buffers.
10:17:53 * hackagebot hjsonschema 1.0.0.0 - JSON Schema library  https://hackage.haskell.org/package/hjsonschema-1.0.0.0 (seagreen)
10:18:07 <Cale> the_2nd: I don't understand the question?
10:18:18 <dysfun> my favourite implementation is actually redhat's: they just sweep out /tmp on boot
10:18:53 <Cale> the_2nd: You have to specify that you're using extensions in the files where you have code that uses the extension
10:19:05 <Cale> In this case, it'll be in the file where your instance is located.
10:19:06 <the_2nd> Cale, I added {-# LANGUAGE TypeSynonymInstances #-} to my file, but still get the "Illegal instance decleration for CLASS TYPE ... use TypeSynonymInstances if you want to disable this"
10:19:24 <Cale> hm
10:19:28 <Phillemann> It seems like almost all major distributions use ramdisks for /tmp, so unpacking ghc into it while my RAM is sort of full isn't a good thing :D
10:19:38 <Cale> the_2nd: can you stick the file on lpaste.net?
10:19:55 <eklavya_> I am using 7.10.3, I am getting Unsupported extension: DuplicateRecordFields
10:20:06 <eklavya_> is that not available in 7.10.3 ?
10:20:07 <Cale> Phillemann: Really? Do the debian ones do that now?
10:20:22 <mgsloan> Phillemann: Indeed, PRs for that appreciated https://github.com/commercialhaskell/stack/issues/996
10:20:56 <the_2nd> Cale, ha! I had the definition below the module line
10:21:04 <mgsloan> PR queue is a little backed up atm, but rest assured they'll be looked at, likely soon
10:21:05 <the_2nd> funky, non-existing error message there
10:21:05 <Cale> eklavya_: That's correct.
10:21:41 <eklavya_> shit, I could swear I had read it somewhere that this was supported through an extension
10:21:46 <Cale> eklavya_: It's available in 8.0
10:21:53 <Cale> But ugh... why
10:22:11 <eklavya_> why do I need it?
10:22:22 <Cale> Well, nobody ever really needs it
10:22:28 <eklavya_> :)
10:23:09 <eklavya_> I thought this was a solved problem, I just had to stick an extension decl :P
10:23:55 <eklavya_> as for "nobody needs it", I am not so sure but it's not technical but purely aesthetic (I think) so people will have different opinions :)
10:24:13 <Cale> The thing is, field names are not just field names -- in fact, the label itself is secondary to what's really being defined, which is a function for extracting the corresponding field from the record.
10:24:32 <Cale> So, when you have duplicated field labels, you're bringing functions with the same name into scope
10:24:57 <Cale> and now you have this complicated extra system for distinguishing which function you mean
10:24:58 <eklavya_> understood, but syntax sugar should go all the way ;)
10:25:14 <Cale> that interacts with the typechecker
10:25:18 <Cale> it's not just syntax sugar
10:25:23 <Cale> It's really complicated
10:25:45 <eklavya_> I meant record syntax is syntax sugar if I am really just declaring functions
10:26:06 <Cale> Well, yeah, in Haskell 98, it's just syntax sugar, pretty much
10:26:30 <eklavya_> so then it should sugar it up all the way :D
10:26:41 <Cale> But DuplicateRecordFields screws with that pretty heavily -- making it no longer just syntax sugar
10:27:05 <eklavya_> so recommended way is to just have a different name always?
10:27:24 <Cale> That's what I'd recommend -- obviously not everyone would agree with me
10:27:44 <eklavya_> oh man, so many things have "name" :P
10:27:44 <Cale> If the fields are actually related, you can define a type class
10:27:52 <eklavya_> I would have to rename them all
10:28:06 <eklavya_> Cale: what do you mean?
10:28:11 <snaek> Hello!
10:28:23 <Cale> I mean, you really name the fields with their distinct prefixes or whatever
10:28:38 <eklavya_> no about the type class
10:28:48 <snaek> Can you guys tell me what Haskell can be used for?
10:28:51 <Cale> and then you define a typeclass  class HasName a where name :: a -> Name
10:28:52 <Cale> or whatever
10:29:02 <dysfun> snaek: it's a general purpose programming language, i.e. anything
10:29:03 <pikajude> snaek: anything!
10:29:03 <Cale> snaek: Just about anything.
10:29:09 <snaek> ok
10:29:14 <snaek> can i use it for web dev
10:29:15 <jle`> snaek: haskell is a general purpose language, so it can be used for anything other languges can be used for :)
10:29:31 <Cale> snaek: At the company I work for, we're using it both for the backend and frontend development of our web applications
10:29:36 <eklavya_> Cale: sorry, didn't get that
10:29:36 <snaek> :O
10:29:38 <Cale> snaek: So, yes, completely.
10:29:47 <Cale> GHCJS is a Haskell -> Javascript compiler
10:29:54 <eklavya_> Cale: side question, which db do you use?
10:30:01 <Cale> and we use that along with reflex-dom on the frontend
10:30:04 <snaek> Cale: can you tell me any frameworks or something I can get started with web dev with haskell
10:30:17 <dysfun> snap
10:30:24 <Cale> On the backend, we're using postgresql via postgresql-simple and groundhog.
10:30:34 <eklavya_> ok
10:30:36 <Cale> and we're using snap for the webserver
10:30:50 <snaek> okay
10:31:05 <eklavya_> thanks Cale :)
10:31:09 <snaek> could you tell me why this would be better than using nodejs/angular 
10:31:15 <Cale> (though really, scotty would probably do it for us, since all our applications are single page, we don't really get a whole lot out of snap's fanciness)
10:31:50 <Cale> It's nice that snap's features are there if we ever need them though.
10:32:06 <dysfun> snaek: i used to like angular, but i finally got pissed off with it this year
10:32:08 <Cale> snaek: Basically, types.
10:32:34 <snaek> dysfun: why u get pissed off at it?
10:32:48 <snaek> currently, i love angular.. other than the fact that it's error messages are not helpful :(
10:32:55 <snaek> its*
10:32:58 <dysfun> the error messages are certainly special
10:32:59 <sm> eklavya_: I prefix field names with the first letter or two of the type, it's not too bad and kind of helps readability I feel
10:33:13 <ertesx> snaek: also FRP (on the UI side) and concurrency (both server and UI side)
10:33:17 <dysfun> i find myself "editing it until it works"
10:33:22 <dysfun> it's not a healthy habit to get into
10:33:23 <snaek> when i get an error: "HomeController is not a" .... me: NOT A WHAT!?!?
10:33:28 <ertesx> both things JS is consistently terrible for
10:33:43 <Cale> snaek: I can make some change to the backend code, which will percolate into some change to the common API types that we're using, and since both the frontend and backend use the same modules defining the types (and the same library for parsing and constructing JSON), this eventually results in type errors in the frontend, and I know all the things which need changing in order to incorporate my new feature.
10:34:22 <Cale> and yeah, Haskell's concurrency is really nice
10:34:23 <eklavya_> sm: yeah, I don't think it's a big deal, just wondered if I could avoid it :)
10:34:37 <snaek> fackkk.. for me, i've spent the past year working with angular and node... i dont know if i can make the step into usig haskell
10:34:49 <buglebudabey> how can i compile G-Code, from the STG machine, to an executable? I want to try using LLVM, but the gcode is for a stack machine and keeps track of a few association lists as well
10:34:49 <snaek> ive never seen any job postings asking for haskell for web dev..
10:34:50 <sm> snaek: aurelia looks pretty nice
10:34:55 <Cale> snaek: Well, give it a year :)
10:35:10 <ertesx> snaek: you'll just have to try and see…  if it's not for you, you can always go back to node/angular =)
10:35:34 <snaek> Is it alright if I'm alright with node/angular?
10:35:42 <Cale> snaek: Haskell isn't an easy language to just pick up in a week or something if you haven't used other functional programming languages extensively before.
10:35:45 <snaek> Like for the most part, I know what I'm doing..
10:35:52 <ertesx> snaek: i don't see why not…  people can have different opinions
10:35:54 <Cale> It's sort of like learning to program again
10:36:05 <ertesx> snaek: as long as it's alright with you that i think both are terrible =)
10:36:09 <Cale> (but it is worth the trouble, I would say)
10:36:12 <snaek> ya.. then I might as well not get into it.. don't wanna start from the beginning
10:36:15 <dysfun> yeah, but so is learning e.g. lisp from c++
10:36:30 <Cale> dysfun: yeah
10:36:35 <snaek> what about typescript, have you guys heard of that?
10:36:40 <snaek> and then obv angular 3 
10:36:44 <dysfun> i have nothing good to say about typescript
10:36:46 <snaek> angular 2*
10:37:00 <eklavya_> snaek: if you learn it, you don't have anything to lose, you can still write JS all you want :)
10:37:28 <ertesx> snaek: if you want to try a language that looks like haskell and has some of its more basic features (like types, functional APIs and layout syntax), have a look at PureScript
10:37:36 <Cale> snaek: I think it's worth getting into, I'm just saying don't be surprised if you have to feel incompetent for a little while -- eventually it's more productive than anything else I'm aware of
10:37:59 <lambdafan> snaek: It's a climb, but you will be rewarded.
10:38:24 <snaek> ya.. I felt "incompetent" when learning angularjs as well.. i guess that's with most things
10:38:24 <ertesx> snaek: that may give you a taste of what haskell *might* feel like, so you can decide whether you'd want to go all the way and get the full feature set (laziness, concurrency, FRP, web frameworks, lots of libraries, etc.)
10:38:30 <Phillemann> I always wondered how integrated PureScript is into the JS ecosystem. Is is a hassle to interop with common JS frameworks?
10:39:11 <ertesx> Phillemann: it wants you to use pulp and bower even to get started
10:39:15 <ertesx> so it's probably well integrated =)
10:39:21 <eklavya_> :D
10:39:33 <dysfun> if you were wondering that about elm, it's horrible when you want to use js
10:40:03 <ertesx> Phillemann: the whole point of PureScript is readable output plus interoperability…  there are even bindings to angular and many other libraries
10:40:21 <eklavya_> typescript + vscode is not too bad
10:40:43 <Phillemann> ertesx: Ah, perfect.
10:40:55 <mgsloan> snaek: You might enjoy my WIP / abandoned, but seemingly working, implementation of typescript's type system in Haskell https://github.com/mgsloan/ghcjs-typescript/blob/master/ghcjs-typescript/GHCJS/TypeScript/Types.hs 
10:41:00 <Cale> It's *possible* to just dive into writing useful things in Haskell, but typically the methodical route to learning the language takes quite a while to get to the point where you can actually write real programs that do I/O. It's not that this is hard, it's just that explaining how it works is easier if you understand a bunch of other things about the type system and how Haskell works already.
10:41:04 <yyyyy> dysfun: i don't find elm horrible to integrate at all. you just end up bundling up channels on a few ports.
10:41:22 <dysfun> yup
10:41:58 <ertesx> personally i didn't like it, but i'm a haskell programmer, so it feels like going from writing high-level code to punching holes into paper
10:42:19 <yyyyy> ertesx: elm or purescript?
10:42:23 <ertesx> yyyyy: both =)
10:42:28 <yyyyy> lol
10:42:44 <eklavya_> ertesx: even purescript?
10:42:45 <Profpatsch> IO (Either A B) vs ExceptT A IO B ?
10:43:02 <mgsloan> I worked to make the type errors almost tolerable even though it's kinda trying to embed another type system: https://github.com/mgsloan/ghcjs-typescript/blob/master/ghcjs-typescript/test/expected-output
10:43:05 <yyyyy> i find them quite different. elm takes a lot of the niceties we have in haskell away, but it's easy to onboard people.
10:43:08 <snaek> dysfun: how come you don't have anything good to say about typescript
10:43:27 <lambdafan> snaek: We know what is possible, is why.
10:43:34 <Zekka> I am tempted to say a lot of the things Elm makes hard to do are things that have dubious benefit!
10:43:36 <ertesx> eklavya_: yeah, PS is not quite haskell
10:43:37 <yyyyy> purescript seems to be even harder to teach than haskell. it gets things right for people who know it, and looks like gibberish for those that don't already, imo.
10:44:01 <ertesx> eklavya_: no concurrency, no laziness, no FRP libraries
10:44:12 <eklavya_> ok
10:44:31 <Cale> Reflex-dom is *really* nice to use, I have to say.
10:44:45 <yyyyy> Zekka: such as?
10:44:46 <dysfun> snaek: because no matter how hard you try, any type system on top of javascript is going to be an enormous bodge
10:44:52 <Cale> It's hard to pick up, we need to do a better job of tutorialising it.
10:45:08 <Zekka> yyyyy: Most polymorphic Haskell code that relies on typeclasses cannot be written in Elm
10:45:14 <Cale> But I actually more often than not have a better time writing frontend code than backend now.
10:45:27 <Cale> which is really really weird :D
10:45:32 <Zekka> There are a lot of people who think that kind of code has a lot of value but my experience with learners is that the super polymorphic Haskell stuff is *really* hard to teach
10:46:07 <Zekka> the penalty is that you have to write your gluing-together code manually and it will probably not be polymorphic
10:46:13 <yyyyy> true, and that's one of the things you lose, as well as sugar for monadic binding.
10:46:14 <Zekka> I don't see this as a significant penalty
10:46:29 <Zekka> (more accurately, most polymorphic haskell code that relies on hkt -- you can si[Dmulate typeclasses)
10:46:34 <c_wraith> I feel like losing lens is far too much. 
10:46:34 <yyyyy> it's not unless you're reusing abstractions a lot, then it hurts.
10:47:11 <Zekka> c_wraith: Reminder: lots of languages have accessors with behavior that is a lot easier to describe than lens' behavior
10:47:22 <Zekka> to get accessors that do enough for most people, you probably don't need all of lens
10:47:31 <dolio> lens isn't just about accessors.
10:47:32 <c_wraith> Zekka, who cares about accessors? I'm talking about lens. 
10:47:48 <ertesx> Zekka: i gave a lot of haskell workshops and ran into some of those difficulties, but found that it was mostly my own mistake…  there are two main lessons i learned:  1. be honest (polymorphism exists, and we need to learn it early), 2. be natural (polymorphism is nothing fancy)
10:47:52 <Zekka> I'm implying here that if you use lens for more than accessors you are probably making your software nearly incomprehensible to people who haven't accepted lens
10:48:02 <c_wraith> lens is a very power universal data manipulation framework. 
10:48:17 <ertesx> Zekka: haskell is not easy to teach, but it can be taught with some practice
10:48:25 <c_wraith> *powerful 
10:48:26 <Zekka> c_wraith: It's also very confusing, and I'm saying this as someone who (at least at one point) understood probably about half of it
10:48:45 <Zekka> not just the interface, but the derivation
10:48:53 <Adeon> I use lens for accessors
10:48:59 <Adeon> I am also terrible and also shower only every second day
10:49:02 <snaek> Okay, thanks a lot for your help guys! I'm trying my best to not be conflicted against using js but I think I've gone too far into my project to switch.. at this point, i understand my angular/node code perfectly and I'm going to stick with it.. perhaps later, I can start studying haskell
10:49:38 <ertesx> Zekka: 3. don't teach van laarhoven lenses to beginners =)
10:50:02 <ertesx> snaek: don't worry too much about it…  pick haskell for your next mini-project =)
10:50:02 <c_wraith> I use lens for things like exploding data structures into families if related structures, each differing from the original at a location specified by a traversal. 
10:50:10 <Welkin> lol
10:50:24 <Zekka> This was my experience: I learned lenses up to some of the more exotic builtin types (uh, Iso, Prism, Traversal) and then wrote a bunch of confusing code
10:50:29 <Adeon> I have a haskell nethack bot in works
10:50:35 <Adeon> it uses a bunch of semi-advanced haskell features
10:50:39 <tnks> dibblego: anyone: I'm open to having this code reviewed:  https://gist.github.com/shajra/57eaf39c4a1fa1c8257e4c65f6464679
10:50:40 <Zekka> I couldn't explain it to my friends and several months later I didn't really understand what I was doing, coming back having not used lenses
10:50:41 <Adeon> or maybe not so advanced
10:50:43 <Adeon> lots of free monads
10:50:45 <ertesx> snaek: one important hint though: learn haskell as part of an actual project…  as weird as this may sound: it's very hard to learn haskell in isolation
10:50:53 <Welkin> funny, becaus I recently did another comparison between purescript and elm
10:51:01 <Welkin> elm feels like a DSL to me, which is fine
10:51:02 <tnks> it's just a new type to get some type class instances all under one type.
10:51:05 <Adeon> and lenses that dig deep into deeply nested records
10:51:07 <snaek> ertesx: ya, that's what I think im gonna do.. and like slowly switch over as time passes and I learn more haskell.. but at the same time im gonna try to keep up with js
10:51:23 <snaek> ertesx: yes, i plan on doing small projects with it
10:51:26 <Welkin> Adeon: nethack4?
10:51:27 <Welkin> :D
10:51:29 <c_wraith> it's far easier to use lens than not to, when writing declarative data transformations 
10:51:39 <Adeon> running it on nethack 3.6.0 at the moment
10:51:45 <Welkin> the nethack4 team is actively developing, in C no less
10:52:00 <Adeon> a fun part was writing terminal emulator that's smart enough to correctly interpret the subset of the escape sequences to make sense of nethack
10:52:08 <Adeon> although
10:52:31 <Adeon> I think modern nethacks have better output formats now more suitable for automaton
10:52:37 <Adeon> but that wouldn't have been as fun
10:52:41 <c_wraith> isn't detecting when drawing is done something of a challenge for nethack bots? 
10:52:54 <ertesx> c_wraith: i rarely find myself using lens with actual lenses…  almost always there is a proper traversal involved
10:53:00 <Adeon> I think the other bots have some more advanced tricks that I do
10:53:07 <Cale> ertesx: Just... maybe not a project that needs to be done in a timely fashion, unless you have some more experienced Haskell developers around to help you with it :)
10:53:11 <Adeon> I just wait until terminal has been idle for N milliseconds and then assume it has done sending everything
10:53:30 <Adeon> which has worked so far, nethack doesn't have unexpected pauses
10:53:30 <c_wraith> does that mean you disable sparkle? :) 
10:53:33 <ertesx> snaek: what Cale said =)
10:53:34 <Adeon> or at least I haven't observed anything
10:53:34 <Adeon> yeah
10:53:49 <Zekka> c_wraith: I can butt out if I'm just being a jerk, but this is an experience I personally had as a learner
10:53:54 <Adeon> also disabled timed_wait option which I'm not sure what it did but it made this thing much more reliable
10:54:00 <snaek> ertesx: ya, ya, for sure, just somthing small for fun
10:54:02 <Zekka> I started out conceptualizing problems in super concrete ways where I wrote what things I wante dthe computer to do and it did them
10:54:12 <Zekka> I found abstractions that covered the concrete stuff I wanted the computer to do and brought them in
10:54:23 <Welkin> snaek: building a we bapp in haskell is fun and pretty easy
10:54:28 <Welkin> if you have done web dev before
10:54:30 <Zekka> I got comfortable with those abstractions and started learning new ones -- this is about the time I learned what monads were
10:54:47 <Zekka> then I discovered esoteric flavors of those abstractions, like free monads, lenses, and I dug in pretty deep on those
10:55:09 <Zekka> The weird thing is that about the time I got past monads, my program structure got increasingly complex, but my code did not get shorter
10:55:11 <snaek> Welkin: yup, web dev's all I do
10:55:22 <snaek> but with angular/node..
10:55:27 <Welkin> snaek: I have gotten so bored of web and mobile dev
10:55:32 <Zekka> I think I at least was very vulnerable to the fallacy that "this was hard to learn and it does something complicated -- it must be important and useful"
10:55:33 <Welkin> I'm doing game dev now :D
10:55:36 <Welkin> for fun
10:55:42 <snaek> which i personally like rn ... and it's probably because i havent been exposed to the strongly typed world
10:55:48 <Zekka> But I think for many of the designs I screwed aroudn with, that wasn't true -- it was hard to learn and it did something complicated, but all it did was make my project more complicated
10:56:04 <ertesx> Zekka: you already went to ReaderT and back – good =)
10:56:18 <snaek> Welkin: ya, you probably have a lot more experience than me.. i think ill reach that day too.. but as of now, im cool with web dev
10:56:43 <Zekka> The rest of the world outside Haskell has survived fairly well without lenses, and that includes languages that prioritize similar things to Haskell
10:57:04 <Welkin> lol, lenses Zekka 
10:57:11 <Zekka> a lot of languages have strong support for immutability or at least for cloning, a lot of languages have features to make it easier to write homemade control flow, and a lot of languages have patterns like Reader but not implemented in a pure way
10:57:14 <Welkin> that is my on complaint about the new high-level sdl2 bindings
10:57:22 <Zekka> ertesx: I wrote almost everything in Haskell for about three-four years
10:57:23 <Welkin> and no one seems to take is seriously
10:57:25 <ertesx> Zekka: as a haskell programmer i survive without lenses most of the time, but i do find the idea of traversals very useful in practice
10:57:26 <Adeon> oh they put lenses on the sdl2 bindings?
10:57:26 <Cale> Zekka: Let's be honest, a lot of the world *inside* Haskell has survived fairly well without lenses too
10:57:28 <Welkin> lens is a dependency for no reason
10:57:46 <Welkin> one complaint*
10:58:00 <Zekka> I'd probably say that I'm not a particularly deep Haskell programmer, but I'm a pretty broad one -- I tried a lot of things and wrote a lot of different kinds of programs in it, and I usually tried to dig pretty deep on the details of what I used
10:58:09 <Cale> Welkin: I don't think it's something worth complaining about -- it can be a useful dependency to have
10:58:11 <Zekka> I haven't used Haskell seriously for about two years, mind, except for side projecty things
10:58:15 <snaek> has anyone ever used scala for web dev?
10:58:26 <Zekka> I'll be back in like a half hour, sorry to interrupt you guys
10:58:28 <sm> microlens can be a good alternative for lighter deps
10:58:36 <Welkin> snaek: it's basically java...
10:58:42 <snaek> one of my friends told me that I should look into scala before haskell as it would be an easier transition from weakly typed to strongly
10:58:43 <Adeon> there's also linear in sdl2 which is probably more justified
10:58:47 <Adeon> I think linear depends on lens? not sure
10:58:55 <Welkin> Adeon: ah, yeah, I think that was why perhaps
10:58:58 <ertesx> snaek: honestly i don't think so
10:58:58 <c_wraith> Oh. I do find it silly to have most libraries depend on lens. most of the time, you can easily include lenses without depending on anything more than base. though that breaks down a bit for things like Plated
10:59:01 <Welkin> still ,seems eincredibly bloated
10:59:07 <Welkin> I use the low-level bindings
10:59:24 <Welkin> but now I have to fork it into my own package, unless I want my game to have linear and lens as dependencies
10:59:28 <Welkin> pretty dumb
10:59:31 <ertesx> snaek: scala is basically java with a better type system and less noisy syntax
10:59:39 <dysfun> 'better'. citation needed
10:59:49 <eklavya_> :)
10:59:58 <snaek> ertesx: why do you not think so?
11:00:10 <Welkin> snaek: if you want to learn a good FP language, go with haskell and ignore the half-assed stuff like scala
11:00:21 <Cale> ertesx: And lots of fancy tempting features which apparently if you use them together, you get into lots of trouble :P
11:00:22 <eklavya_> snaek: Scala is easier
11:00:34 <eklavya_> it's not so bad
11:00:43 <eklavya_> I have been doing it for 3 years now
11:01:02 <lambdafan> we can do better than "not so bad".
11:01:17 <ertesx> snaek: haskell is actually a very simple and natural language…  the main problem people have with learning it is that they come from very different languages like JS in your case
11:01:31 <eklavya_> honestly for whatever I did , Scala was never a problem
11:01:45 <eklavya_> but I like the terseness of haskell
11:01:49 <eklavya_> so I am diving in it
11:01:50 <Cale> I haven't actually used Scala myself, but all the people who I've talked to that have are eternally frustrated with how it looks like you ought to be able to translate Haskell into it, but if you try to do that for various reasons it doesn't work out so well.
11:02:00 <ertesx> snaek: scala takes the best of haskell and java into a lovely blend: hard to learn for a JS programmer *and* complex and unnatural
11:02:02 <Welkin> most people only know algol-family languages (e.g. c, java, js, python, ruby) and they don't know any ML-family languages or lisp languages
11:02:15 <dysfun> Cale: suffice to say the merging of fp and oop worlds didn't go quite to plan
11:02:17 <Welkin> so they only have oe reference for what a programming language is like: Algol
11:02:32 <Welkin> one reference*
11:02:53 <eklavya_> Cale: maybe it worked for me because it was my first FP language
11:03:13 <eklavya_> so I wrote scala, without translating anything into it
11:03:20 <dysfun> maybe you just never walked far enough down the path
11:03:39 <dysfun> i felt a little sick when i realised where scala got implicits from, the ghc extensions
11:03:42 <eklavya_> I see how trying to do it the haskell way would frustrate people
11:04:29 <eklavya_> the ergonomics
11:04:36 <dysfun> but doing it the java way is equally frustrating, just differently so
11:04:43 <ertesx> the main reason i don't like scala can be summarised as:  F[_]
11:04:52 <buglebudabey> i am trying to use llvm-general and llvm-pure bindings to compile gcode instructions into llvm, but the problem is that gcode instructions are to manipulate a stack machine, so how can i go about this? 
11:04:56 <eklavya_> dysfun: there is a Scala way though :)
11:05:09 <dysfun> eklavya_: yes, which manages to combine the worst of both
11:05:34 <eklavya_> well, not for me :P but it's subjective so
11:05:50 * dysfun abandoned scala in favour of clojure
11:05:57 <eklavya_> WHAT!!!
11:06:43 <mizu_no_oto_work> subtyping + implicits is... interesting
11:07:00 <dysfun> well after about the millionth time it took way longer than i expected to write some code, i finally said "fuck it". it's no real surprise
11:07:21 <eklavya_> ok
11:07:28 <dysfun> scala is not only "not haskell", but it is nowhere near as easy to just get things done either
11:07:35 <ertesx> scala really just abuses haskell for marketing
11:07:53 <dolio> This seems pretty off topic.
11:07:54 <Welkin> haha
11:08:13 <mizu_no_oto_work> Well, there's also a number of Haskellers who use Scala because they need to be on the JVM for some reason
11:08:33 <Welkin> Frege
11:08:33 <ertesx> well, we got GHCJS, maybe some day we get GHCJ
11:08:49 <ertesx> but i expect that as soon as android switches to something else, the JVM will just die
11:08:59 <mizu_no_oto_work> And there's also Ermine
11:09:16 <dysfun> no, the jvm is huge in enterprise, it won't just die
11:09:35 <Welkin> it will die when the crufty enterprise execs die
11:09:44 <ertesx> Welkin: just like PureScript, Frege is "not quite haskell" though
11:10:07 <Welkin> all of the new tech companies use ruby/python/js/go/elixir or some FP language
11:10:17 <bernalex> as I've mentioned a few times in this channel, ghcjvm is a hsoc project.
11:10:23 <Welkin> they would never touch java/c# or any enterprise things
11:10:58 <dysfun> Welkin: *cough* clojure
11:12:03 <eklavya_> will a stable stack with ghc 8 be released soon? is there something good enough I can use for now?
11:12:46 <Profpatsch> What is fixIO used for?
11:13:00 <Welkin> something I have been thinking about recently, how is it that languages like java *still* don't have first class functions?
11:13:06 <Profpatsch> @type fixIO
11:13:07 <lambdabot> Not in scope: ‘fixIO’
11:13:12 <Cale> Profpatsch: Well, it's the mfix for IO, isn't it?
11:13:31 <Welkin> programming without first-class functions feels like you may as well be writing assembly
11:13:32 <jackhill> eklavya_: Stack nightly? They hade a blog post with the timeline, let me see if I can dig it up…
11:13:58 <Profpatsch> Cale: mfix from MonadFix?
11:14:02 <Cale> yeah
11:14:06 <Profpatsch> ah, okay.
11:14:07 <Profpatsch> Thanks.
11:14:12 <Nikotiini> Welkin: It's too abstract
11:14:22 <eklavya_> jackhill: is stack nightly ok to use?
11:14:31 <jackhill> eklavya_: https://unknownparallel.wordpress.com/2016/05/22/stackage-lts-and-ghc-8-0/
11:14:56 <eklavya_> thanks jackhill :)
11:16:03 <jackhill> eklavya_: I think it should be in the sense that stack with nightly stackage snapshots is still focused on reproducable builds, so if you find a snapshot that works, you should be able to continue to use that.
11:16:06 <eklavya_> if it doesn't work, I can downgrade it again without problems, right?
11:17:02 <jackhill> eklavya_: yep. In the worst case you can always wipe out .stack_work
11:17:14 <eklavya_> ok cool
11:19:10 <jackhill> eklavya_: good luck/have fun!
11:19:19 <eklavya_> thanks :)
11:19:44 <Ornedan> What's the current recommended way to do logging? Control.Monad.Logger or something else?
11:22:17 <Zekka> Sorry for ditching folks! I'm back, not that it matters to you, but when I'm saying contentious things I feel like it's rude to leave before anyone can complain at me
11:23:05 <undreren_> Hi
11:23:29 <undreren_> How can I kick "undreren" from this channel? It's me, logged in from my pc at work
11:23:48 <Zekka> Is your nickname registerered? If so, you can use /ns ghost
11:23:56 <undreren_> It isn't
11:23:56 <Zekka> (well, /msg NickServ ghost)
11:24:03 <undreren_> How do I register
11:24:06 <undreren_> ?
11:24:14 <Zekka> you would /msg nickserv register, that should give you a help page
11:24:28 <Zekka> but you wouldn't want to do that until you're using hte nick you want to register
11:24:45 <undreren_> oh, ok
11:24:48 <undreren_> hmmmm
11:25:03 <undreren_> Maybe I should just log on remotely and log out
11:25:07 <undreren_> one sec
11:25:29 <bernalex> you don't need to document this for us.
11:25:59 <Zekka> bernalex: Document what? undreren specifically asked
11:27:04 <nitrix> undreren_: #freenode are good to help beginners with issues associated to using IRC and configuring your client.
11:27:33 <Undreren> wow
11:27:49 <Undreren> I'm having a conversation with myself!
11:27:59 <undreren_> This is so weird
11:28:45 <daey> would this function be ok, by 'nice' standards? i know that it works. http://lpaste.net/169559
11:29:13 <Squarism> Zekka, im interrested in hearing your insights after beeing away 2 years from haskell? Eager to get back or something else shines brighter? =D
11:29:35 <Zekka> Squarism: I still use it for simple stuff, but I don't particularly want to write large programs in it at this point
11:29:58 <undreren> nitrix: thanks
11:30:05 <Zekka> I'd say I'm comfortable in the subset most beginners learn after a week or two -- so basically everything in Typeclassopedia
11:30:38 <Zekka> But I think the state/side effect management story in Haskell isn't that great at this point, and the solutions people have proposed are awfully complicated with a ton of rough edges
11:30:47 <bernalex> Zekka: I'm not sure if you're trying to humblebrag or what's up, but in no way do most beginners learn all of typeclassopedia in a week or two.
11:30:49 <Squarism> ok. What is your preferred tool for larger projects then?
11:30:52 <Zekka> bernalex: I'm not
11:31:04 <Zekka> I don't know how long it takes beginners to learn typeclassopedia, but it took me several months to get to that point
11:31:09 <Zekka> I am not a particularly fast learner
11:31:19 <Zekka> You seem to keep assuming I'm trying to be a jerk to people -- if I'm being a jerk to people I'm doing it accidentally
11:31:56 <Zekka> Squarism: Lately I've just been using whatever typed imperative language my friends are using -- I can't really recommend any of them in good conscience, but C#, Java, etc. are all comfortably mediocre. I wrote my own logic programming language which I'm using in my main C# personal project right now
11:32:02 <nitrix> daey: It's fine, but we have generic functions in Haskell that already capture this form of simple recursivity.
11:32:12 <nitrix> daey: e.g. foldl, scanl.
11:32:14 <nitrix> > foldl1 (*) [1..5]
11:32:16 <lambdabot>  120
11:32:21 <Zekka> the closest language to the one I wrote is CHR, which has good implementations in Java and Prolog
11:33:16 <Zekka> For easy problems and for most cases of state management, C#/Java/typed imperative language of the day don't do anything terrible, even though they're more annoying than Haskell in a few syntax cases
11:33:22 <Welkin> you prefer imperative over purely functional? O.o
11:33:36 <Zekka> Welkin: I used to prefer purely functional and then I noticed that all the abstractions I was using in purely functional code leak
11:33:47 <nitrix> daey: You could probably write this as: rekurs''' x = foldl' 1 (*) [1..x]
11:33:55 <shapr> Zekka: have you written a blog post about that?
11:34:01 <Zekka> shapr: I don't actually have a blog, maybe I should
11:34:11 <shapr> I'm curious about the leaky abstractions
11:34:28 <Zekka> Basically, if I were to write a blog post what it would cover is that monad transformers don't compose very well and MTL is not a good answer
11:34:37 <nitrix> daey: The identity of 1*1 in this foldl' captures the same idea as your x-1 when x is 1, and you short circuit the recursivity.
11:34:44 <Zekka> extensible-effects/whatever Idris does are possibly better answers, but they involve a lot of math
11:34:47 <shapr> Zekka: I'd like to read how you got to that point
11:34:56 <Zekka> anything that requires monad transformer-level explanation is imho kind of dangerous
11:35:10 <bernalex> I like extensive effects a lot more than transformers as well.
11:35:25 <Zekka> shapr: Let me write your name down, if I do write something I'll try to remember to write you back with it
11:35:31 <shapr> sure!
11:35:42 <daey> nitrix: hm ok. i wasnt looking for a more complex solution. still learning. i wasnt sure the 'x' in rekurs'' x = is ok. as i used the '_' in those cases before
11:35:46 <eklavya> Zekka: me too!!
11:35:52 <bernalex> hi shapr! how are you?
11:35:56 <Zekka> Usually I try not to get too vocal about it because haskell guys really like haskell and the non-haskell guys I show it to usually get a distaste for it pretty fast
11:36:05 <Welkin> lol Zekka 
11:36:07 <shapr> Zekka: I'm always looking for new knowledge
11:36:08 <Zekka> which makes me a little sad because I think the most obvious reasons to disown Haskell aren't good ones
11:36:11 <Welkin> programmer holy wars
11:36:26 <bernalex> Zekka: I've not heard anyone complain about haskell even an iota as much as haskell programmers
11:36:28 <shapr> Zekka: I've been writing Haskell for about 15 years, but I certainly don't think it's perfect the way it is.
11:36:58 <nitrix> That discussion again?
11:36:58 <Zekka> bernalex: I think haskell programmers complain more about Haskell than anyone else, definitely
11:37:02 <bernalex> Zekka: one of the all time top 3 (maybe it's even #1) threads on r/haskell is called "Why does Haskell, in your opinion, suck?"
11:37:05 <shapr> I just wrote a tiny bit of Haskell code to talk to xinput to disable my touchpad
11:37:16 <Zekka> but if you're a haskell programmer and you complain about Haskell you probably still use Haskell
11:37:24 <Zekka> as a non-Haskell programmer, minor annoyances are often enough to turn you off to it
11:37:30 <nitrix> Zekka: Of course they'd do, they're the one using the language everyday after all.
11:37:36 <shapr> Zekka: isn't that true of many things?
11:37:39 <Zekka> I would not want to be the guy who has to pitch Haskell to newbies
11:37:45 <shapr> I never got over the syntax of Erlang, even though I wanted to learn it.
11:37:48 <nitrix> That observation is a little biased.
11:37:49 <shapr> Zekka: oh, that's me!
11:37:53 <Welkin> shapr: yeah, there is elixer too
11:37:54 <bernalex> for me, there's no language that's as useful as haskell. yet.
11:37:55 <Zekka> shapr: I think it's true of all technologies, yeah
11:38:04 <Welkin> elixir*
11:38:11 <shapr> Zekka: so my generalization there is that small changes in difficulty lead to dramatic changes in usage
11:38:16 <bernalex> idris is getting closer by the day, but I really dislike that it has an eager evaluation strategy.
11:38:20 <Cale> Haskell is pretty great, but of course there are things worth complaining about.
11:38:26 <Zekka> bernalex: What have you worked with? I can't think of a general purpose programming language that tries to tackle as many situations as haskell, but I can think of some more specific general-purpose languages that do OK
11:38:31 <bernalex> Cale: yeah but compared to like... java? come on. :p
11:38:39 <nitrix> Granted we're slowly solving the ugly parts about Haskell.
11:38:46 <Zekka> (you can technically write anything in Prolog but Prolog is really targeted at programs that model data a certain way)
11:38:48 <Cale> bernalex: Well, comparing it to something which is practically unusable is not fair ;)
11:38:51 <nitrix> Just recently, GHC 8 got Semigroups.
11:39:12 <bernalex> Zekka: I have probably written something beyond hello world in >20 languages, and >10K SLOC in >10 languages.
11:39:15 <Zekka> Oh, thank god, semigroups! Now my life (which was previously difficult) is easy!
11:39:17 <shapr> I'm enjoying the typeclass improvements
11:39:27 <dysfun> bernalex: oh good, i'm not the only one
11:39:33 <bernalex> yeah it's so great to see semigroups fixed
11:39:42 <Zekka> bernalex: Cool, it sounds like you're a little deeper on programming languages than I am
11:39:45 <nitrix> Zekka: A lot of work went into it. That comment is almost insulting.
11:39:47 <bernalex> now Num needs to become Ring, and all that crap needs to be fixed.
11:39:55 <Cale> Num does not need to become Ring
11:39:57 <Zekka> I've used a lot of programming languages but not to that degree
11:40:05 <bernalex> Cale: "Ring and other things"
11:40:06 <shapr> nitrix: meh, people got opinions, nothing to get upset about
11:40:11 <Cale> because that would mean losing the instances for Double and Float
11:40:16 <Cale> which is probably unacceptable
11:40:17 <Zekka> nitrix: It was jokingly insulting -- if it was so difficult, it was obviously important to a lot of people, and I'm glad it got settled
11:40:36 <nitrix> Glad we're on the same page.
11:40:41 <bernalex> Cale: we can probably do maths a bit less sucky, and still have hacks around for Double and Float.
11:40:43 <Zekka> but the stuff that I get the most concerned about is usually more new-developer-experience-related
11:40:45 --- mode: ChanServ set +o Cale
11:41:01 <shapr> Zekka: yeah, that's the make or break point.
11:41:18 <bernalex> Zekka: I think that's pretty dangerous TBH
11:41:21 <Zekka> my experience is that with a ton of technologies, including programming languages, people design them who get very invested in the experience for seasoned devs
11:41:41 <shapr> Zekka: APL did a good job of that, right?
11:41:43 <bernalex> Zekka: a *lot* of languages are optimising for the first week or two of learning it. those languages aren't exactly pleasant to use when you've got 50K SLOC.
11:42:09 <Zekka> bernalex: Although I'd argue a lot of those misfeatures are orthogonal to new dev experience -- or sometimes even fly in the face of it
11:42:21 <Zekka> a study run by the folks behind Quorum found that a static type system actually improved newbies' ability to learn
11:42:53 <Zekka> I think a lot of those misfeatures come from "we did what was easy to implement," which is sad
11:43:23 <Zekka> I think a pretty important goal should be to produce features that don't require you to become a specialist in them
11:43:37 <nitrix> Zekka: #ghc are looking for more devs.
11:44:04 <Zekka> the language I hacked out has an implementation that's only 800 lines long
11:44:12 <bernalex> it would be useful if ghc had devs. at all.
11:44:12 <Zekka> there's nothing to become a specialist and the support for abstraction is basically nil
11:44:31 <Zekka> it's a really highly-specific tool for certain kinds of program logic I hate writing
11:44:42 <undreren> q
11:45:14 <Welkin> programming web applications has never been easier for me since using haskell
11:45:25 <Welkin> especially for a recent ~50k SLOC project
11:47:37 <Zekka> Welkin: FYI, I believe you -- I also suspect I'm a below-average user of haskell -- but something thath elped me stop using haskell was to write programs that I had previously written in Haskell in a super hacky and direct fashion in other languages
11:48:15 <Zekka> I often found that if I threw out conventions of good design in favor of doing one specific thing, I could reduce bugs and get shorter code than I did otherwise
11:48:42 <Zekka> I think that at least for me, the things that made Haskell significantly more productive for me were a little imaginary. (although frankly, Java and C# are still absurdly verbose)
11:49:06 <Zekka> Ideally when you set rules for yourself, you need to break them occasionally to see if the rules are doing what you think they're doing
11:49:12 <bernalex> and what happened 50K SLOC and 5 years down the line, when someone else on the opposite side of the globe needed to change those specific things?
11:49:17 <nitrix> Zekka: Are you Haskell projects open source?
11:49:33 <Zekka> if you break all the "good design" rules and it turns out an unmaintainable mess, then the "good design" rules need to be revised
11:49:35 <nitrix> s/you/your/
11:49:37 <Zekka> nitrix: Nothing recent
11:50:09 <Zekka> I think my most recent haskell program online is from freshman year in highschool when I'd only been using it for like six months, but I could have my timeline all screwed up
11:50:24 <Zekka> that was also from when I was very excited about Haskell and I think I did a lot of distasteful things in the implementation
11:50:55 <Zekka> bernalex: FYI you shouldn't do what I'm describing in a case where someone else is counting on you
11:51:37 <Zekka> but examples: I wrote 2000 lines of imperative prolog and nothing bad happened -- apparently symmetry isn't that important; I wrote 4000 lines of Java without accessor functions and nothing bad happened, apparently accessor f unctions aren't that important to my model.
11:52:09 <nitrix> Maybe that works for small single men projects, but I have trouble imaginating those projects grow.
11:52:37 <Zekka> I abused a constraint programming language basically the same way I abused prolog and nothing bad happened -- I did a project with very little abstraction and mostly copypasting, nothing bad happened
11:52:39 <nitrix> What are you going to do when the complexity grows? Add abstractions? Rewrite everything?
11:53:14 <Zekka> Obviously it doesn't mean that you absolutely should do all the things I listed, but it means that if you apply the "good design" rules in every case, there's an easy-to-hit slice of cases where that makes things worse, not better
11:53:55 <niteria> does anyone know a channel for stackage related questions?
11:54:04 <nitrix> niteria: Here.
11:54:15 <Zekka> nitrix: I'm not really saying "you should do the opposite of good practice all the time" either
11:54:20 <bernalex> nitrix: this reminds me of the guy who was in #haskell-game a year or two ago, who didn't understand why you would have your programs in more than one file. "it's just easier to write it in one file." often those kinds of things are something you'll have to experience for yourself why they're not all that great ideas.
11:54:34 <Zekka> this is mostly just me using programming as an example to talk about philosophy-of-making-rules
11:54:49 <Zekka> if you don't test what happens when you break the rules you make, you can't be sure the rules are very good
11:54:51 <nitrix> Zekka: Then what is it you're saying? With all due respect, you're being very noisy and sticking out like a sore thumb, ranmbling alone at the moment.
11:55:00 <Zekka> nitrix: Sorry, I can ditch you guys if you don't care
11:55:03 <shapr> nitrix: be nice
11:55:38 <shapr> Zekka: I also try the opposite of what I believe is best practice to get perspective
11:55:41 <niteria> are all transitive dependencies of packages in stackage/build-constraints.yaml?
11:55:58 <shapr> turns out I started liking asparagus ten years later
11:56:01 <niteria> I'm asking because for lambdabot it doesn't seem to be the case
11:56:38 <Zekka> shapr: Part of why I think this is relevant in #haskell is that Haskell itself has really strong opinions on managing state and effects
11:56:41 <shapr> niteria: I think it's direct deps
11:56:43 <bernalex> Cale: int-e: so remind me again -- why isn't lambdabot in #-offtopic?
11:56:46 <Zekka> for a while I just assumed it would be easier if I did it Haskell's way
11:57:05 <Zekka> After I seriously switched to using the imperative languages I thought I didn't like for a bunch of problems, I decided Haskell's way was actually harder for the stuff I'd been doing
11:57:12 <Welkin> bernalex: lambdabot is offtopic for offtopic
11:57:20 <shapr> Zekka: I'd certainly like to read a blog post with more explanatory text.
11:57:48 <shapr> Zekka: I do think Haskell's way is harder, in that it requires more discipline. For the programs I build, the benefits of that discipline are worth the cost.
11:57:51 <bernalex> shapr: do *you* blog? I'd read your blog :)
11:58:19 <shapr> bernalex: I've had several, and I really need to start another. I'm starting a startup culture reprogramming project that I would like to document.
11:58:32 <shapr> I started it this past weekend, it's been a blast so far.
11:58:46 <shapr> For the next part of this project I need to figure out which Haskell firebase library is best.
11:59:13 <buglebudabey> if anyone would be willing to help me translate g-code into llvm i'd appreciate it, i put up a bigger description here https://www.reddit.com/r/haskell/comments/4sclsi/translating_gcode_to_llvmmachine_code/
11:59:21 <bernalex> shapr: I had a few blogs too. but it never took off because I was too lazy. I've had this idea for idk ten years(?) that I never followed through on though, which was to essentially just get a group of like-minded (to some degree) friends together, and have a 'collective blog'.
11:59:38 <platz> Zekka: you might like some of the video's that game programmer Jonathan Blow produces.. he has some counter-intuitive preferences based on things specific to building games
11:59:41 <Welkin> bernalex: the bernalex post?
11:59:47 <bernalex> Welkin: 
11:59:47 <shapr> bernalex: I'm a member of the haskell-embedded github organization, but I've never written a blog post :-(
11:59:54 <Welkin> ariana bernalex
11:59:56 <bernalex> Welkin: I was actually going to call it "Let's ride bikes".
11:59:57 <Zekka> platz: Oh yeah, I have some friends-of-friends who are interested
12:00:12 <Zekka> But I don't get much from them other than "they really like rowy representations and they don't think encapsulation is important"
12:00:34 <Zekka> er, interested in Jon Blow's stuff and object models for games
12:00:49 <shapr> buglebudabey: sounds like you're having fun, that's one book I've never gotten around to reading.
12:00:58 <shapr> hoi tromp_!
12:01:13 <buglebudabey> shapr fun time has passed, now i'm having trouble :P
12:01:38 <nitrix> shapr: Thanks for the friendly reminder by the way, but I still have an aversion with #haskell turning into ##programming.
12:02:00 <Zekka> I'm not actually from ##programming, is there subtext here?
12:02:16 <shapr> nitrix: It's hard to find a good balance between staying on-topic and learning new stuff.
12:02:19 <minib00m> hey guys, i'm having trouble with lenses, could anyone help me? code is short http://lpaste.net/169563
12:02:21 <mgsloan> niteria: I believe it doesn't specify the versions for ghc / other core packages.  However, they are present in the generated build plan bundle files such as https://github.com/fpco/stackage-nightly/blob/master/nightly-2016-07-11.yaml
12:02:51 <Zekka> I kinda figured "this is a channel of people who probably have really strong design opinions; if I talk out of my rear end about philosophy of developing design opinions, maybe someone will care"
12:02:56 <shapr> nitrix: My approach is to allow somewhat Haskell-oriented discussion as long as it's not distracting from more on-topic discussion (and as long as people are not getting upset)
12:03:24 <nitrix> shapr: minib00m asked a question for example. As long as we don't borrow them with walls of text.
12:03:32 <niteria> mgsloan: I think you're right
12:03:46 <bernalex> shapr: not a mod, but my rule would be that the percentage slider for how haskell-related something needs to be would be proportional with the amount of traffic the channel has.
12:03:54 <shapr> Zekka: so far, I strongly dislike the way imperative languages handle state, but since I don't really understand the motivation behind your ideas, I'm willing to listen.
12:04:02 <shapr> nitrix: yes, I agree
12:04:14 <Zekka> shapr: I think it'd be better at this point if I wrote something to cover specific things that happened in my haskell projects and why I didn't like them
12:04:18 <bernalex> shapr: if lots of people are getting haskell-specific help, then barely-related things become more quickly undesirable than if the channel is nigh dead.
12:04:23 <shapr> minib00m: Are you following some particular tutorial? I want to learn lenses too. 
12:04:42 <Zekka> I could try to give examples off the cuff but I'd rather edit them because Haskell is fairly versatile and there's always a bunch of "why didn't you?"s
12:04:43 <shapr> I've heard the process of switching to lenses is called refractoring.
12:04:55 <shapr> Zekka: yes please, I'd read it!
12:05:01 <minib00m> shapr: unfortunately no, i try to do things and then find solution :/ i tried once, but it seems to messy at first
12:05:14 <minib00m> i tried once to follow tutorial
12:05:15 <Zekka> so I'd want to cover the common "why didn't you?"s for the cases I ran into trouble with
12:07:20 <shapr> minib00m: I wish I knew lenses, maybe Cale knows?
12:07:52 <minib00m> this seems like easy problem, i believe i miss some little thing, but i can't find it 
12:08:29 <dedgrant> Zekka: Also interested in reading about your specific experiences if you choose to share.
12:08:49 <Zekka> dedgrant: at this point I have a text file and you are the third name in the text file
12:09:03 <Zekka> maybe what I need is a patreon so I can extort you suckers
12:09:13 <dedgrant> :)
12:09:16 <eklavya> :D
12:09:27 <shapr> gotta put up some content first :-P
12:09:42 <eklavya> here are 2 good wishes to get you started :P
12:09:57 <bernalex> shapr: shareware blogging
12:10:17 <nitrix> shapr: I occasonally give tiny tutorials about lens on #haskell-beginners.
12:10:27 <bernalex> #haskell-lens are also helpful
12:10:34 <Zekka> maybe I should call my blog haskellkillspeople
12:10:42 <Zekka> that way I won't look biased
12:10:51 <nitrix> Please.
12:11:29 <bernalex> all this talk about blogs has spurred me on to make a blog tomorrow.
12:11:45 <Welkin> bernalex: you already had a hakyll blog...
12:11:48 <Zekka> bernalexkillspeople.blogpost.com?
12:11:52 <bernalex> Welkin: wat?
12:12:01 <Welkin> bernalex: for your game studio
12:12:05 <dedgrant> For me the value is in the dialog, so it really depends on how reasonable the argument is. For a trite example, "I wrote into memory I didn't allocate and nothing bad happened, so those of you taking the time to ensure that you're only writing into memory you've allocated are suckers," is fairly unreasonable. The specific argument would have to be pretty compelling to purchase license.
12:12:29 <bernalex> Welkin: I don't know what you mean by hakyll blog. or game studio, really. my previous company had a hakyll website, if that's what you mean.
12:13:15 * parsnipM_ set up his hakyll to use .org files
12:13:29 * bernalex notes down parsnipM_'s nick
12:13:36 <bernalex> parsnipM_: that was my plan precisely.
12:14:19 * Welkin cleans, slices, and cooks parsnipM_ 
12:14:24 <undreren> I am about to undertake my first *real* haskell project
12:14:26 <bernalex> parsnipM_: src link by any chance?
12:14:27 <Welkin> wait
12:14:29 <minib00m> no lens experts here? 
12:14:30 <Welkin> who is parsnip?
12:14:32 <Welkin> o.o
12:14:41 <shapr> minib00m: nitrix said he knows something
12:14:49 <Welkin> parsnipM_: your doppelganger?
12:14:53 <Zekka> undreren: Cool, what project?
12:15:02 <shapr> parsnipM_: I used org-mode, tell me you wrote a blog post on how to do that?
12:15:14 <shapr> undreren: cool, what will it be?
12:15:35 <minib00m> oh, missed that
12:15:41 <Welkin> hakyll just uses parsec underneath, so you just need to hook it up to use .org files insitead
12:15:48 <Welkin> or maybe it just does it automatically
12:15:55 <bernalex> parsec?
12:15:56 <parsnipM_> i should make an blog post, but i'm still so newb, it would be messy. it basically comes down to sprinkling `pandocCompiler` around the Site.hs. 
12:15:57 <Welkin> er
12:15:59 <Welkin> pandoc
12:16:26 <bernalex> yeah I used md and pandoc.
12:16:31 <shapr> parsnipM_: is the source on github?
12:16:31 <undreren> Zekka, shapr: A small game about paperwork and asset management
12:16:37 <platz> the basics and types of lens is one thing, but learning how all the combinators fit together takes some time (like learning some vocab)
12:16:48 <shapr> undreren: sounds like fun
12:16:49 <Welkin> undreren: Papers, Please (Lambda Edition)
12:16:49 <nmattia> undreren: how do you turn that into a game?
12:16:50 <bernalex> also use hakyll/pandoc on latex to get paper previews.
12:16:55 <Zekka> Oh yeah? I had a similar idea a long time ago, but never committed
12:17:00 <Zekka> please do so, it'll probably be cool
12:17:18 <shapr> I enjoy resource management games
12:17:25 <parsnipM_> shapr: no, i'd really have to clean it up, but if i do, it'll either be at github.com/bradyt, or bradyt.com, or notes.bradyt.com
12:17:40 <bernalex> parsnipM_: cleaning schmeaning
12:17:55 <parsnipM_> it is additionally messy cause of the hideous part for generating the resume
12:17:58 <bernalex> parsnipM_: git push and let random people online get so annoyed with it that they fix it for you
12:18:00 <parsnipM_> from a yaml file
12:18:09 <shapr> I use LaTeX for my resume
12:18:14 <bernalex> me too
12:18:16 <shapr> bernalex: yes!
12:18:30 <bernalex> I didn't get any jobs though
12:18:34 <undreren> nmattia: Well, you are asset managing for "adventurers". Your job will mainly be to spend their money.
12:18:36 <bernalex> I blame Donald Knuth.
12:18:36 <Welkin> shapr: kinky
12:18:37 <shapr> bernalex: what's your twitter account again?
12:18:39 <troydm> suggest a plugin for vim to format haskell code, because when I use = it literally destroys my entire formatting
12:18:41 <parsnipM_> shapr: i use everything for my resume, from yaml, i make latex, html, ...
12:18:42 <bernalex> shapr: skramlife
12:18:54 <nmattia> undreren: spending other people's money, sounds like fun
12:18:55 <Zekka> started with latex, then painstakingly imitated the typesetting in googledocs and made tweaks to be flashy
12:19:10 <Zekka> it didn't turn out well
12:19:11 <undreren> nmattia: Virtual currency, is their anything it cannot buy?
12:19:11 <Welkin> troydm: emacs with haskell-mode and evil?
12:19:25 <troydm> Welkin: not going to emacs yet
12:19:26 <parsnipM_> i would probably have a better job by now if i'd simply used googledocs
12:19:32 <bernalex> troydm: honestly, there's no good haskell formatter.
12:19:34 <EvanR> undreren: "will it spend"
12:19:42 <bernalex> troydm: I just end up doing it by hand. both in vim and in emacs.
12:19:43 <undreren> EvanR: lol
12:19:56 <shapr> I really want to try the new intero stuff
12:19:57 <nmattia> everybody really using emacs here?
12:20:05 * bernalex uses emacs
12:20:05 * Welkin does
12:20:08 <nmattia> ew
12:20:08 <shapr> I have really been using emacs for 17 years or so
12:20:16 <nmattia> though I don't want to start a fight, plz
12:20:17 <shapr> nmattia: not saying you have to :-)
12:20:18 <undreren> nmattia: I use Sublime Text
12:20:29 <nmattia> undreren: weird! I see more and more people using that
12:20:37 <Zekka> I think I got my last job with like six pages in Courier New
12:20:38 <bernalex> I used vim for over a decade, and started using emacs earlier this year.
12:20:39 <nmattia> is it for the multi cursor stuff?
12:20:40 <shapr> variety is a good thing, then people find cool stuff I don't know about yet!
12:21:00 <bernalex> nmattia: it's kind of like vim but not good, and proprietary.
12:21:05 <shapr> nmattia: I got all excited about the multi cursor stuff, turns out emacs had it but I didn't know it was a thing!
12:21:17 <nmattia> shapr: yeah, vim has a cool plugin for that too
12:21:20 <Zekka> only a real programmer would use courier new
12:21:21 <nmattia> bernalex: sounds... good?
12:21:49 <shapr> aw, I was going to send buglebudabey over to #ghc
12:22:01 <thoughtpolice> join ##pfsense
12:22:05 <sm> Zekka: I appreciate hearing your post-haskell thoughts based on experience, that's quite valuable
12:22:05 <thoughtpolice> Oh, shoot. Sorry
12:22:15 <Zekka> sm: ok you're going in the textfile
12:22:30 <bernalex> thoughtpolice: hi Austin! what's up? you've been doing some phab stuff lately, right?
12:22:47 <shapr> Zekka: if you're looking for other Haskell critique, smdiehl's writings are informative
12:22:58 <bernalex> thoughtpolice: I got an email about a commit I didn't think would land in a million years -- and then it turned out it hadn't landed, there's just been some phab wibbling.
12:23:04 <sm> it sounds like you often know quite well what you're building, or even were redoing it ("I had previously written in Haskell") - that would help things go quickly and well in a more quick & dirty language, no ?
12:23:19 <shapr> Zekka: here's a direct link: http://www.stephendiehl.com/posts.html
12:23:21 <Zekka> sm: Yeah, I think that made a difference
12:23:35 <Zekka> one of my rewritten programs is about seven iterations into the same design -- started out very large, but I cut more and more things
12:23:38 <sm> I find haskell's strictness more of an asset as things get too big or too unfamiliar to know what you're doing at all times
12:23:43 <thoughtpolice> bernalex: Oh yeah, sorry about that. That was due to us doing an upgrade; Phabricator had some changes in how it 'discovered' commits from remote repositories, so it ended up being 'too eager' about emailing people for those.
12:24:05 <bernalex> sm: "haskell's strictness" is an unfortunate choice of words :p
12:24:07 <thoughtpolice> bernalex: So I need to reproduce this on my own server as a bug for them. But I did fix that in the mean time so it shouldn't ever happen again. Sorry about that :(
12:24:12 <bernalex> sm: had me confused a second or two
12:24:36 <thoughtpolice> (I basically turned off notifications for like, all mirrors except GHC.)
12:24:39 <sm> bernalex: yes, sorry, please translate as needed
12:24:40 <bernalex> thoughtpolice: NP! someone should merge that commit though. oh well.
12:24:44 <Zekka> My largest Haskell program was about 13kloc and I found I was running into many of the same problems I ran into with other technologies, but that might have been related to some peculiarities of the problem
12:24:50 <Zekka> it gets dicier than that
12:24:52 <sm> s/strictness/rigour/
12:24:57 <shapr> Zekka: oh I *really* want to read that blog post
12:25:20 <thoughtpolice> bernalex: https://phabricator.haskell.org/D1693 ?
12:25:20 <Zekka> the gist is that this is a program with a *lot* of global state and it needed to expose a pretty imperative interface to manipulate it
12:25:32 <thoughtpolice> Yeah, that should be fixed. Sorry none of us have got to it.
12:25:40 <Zekka> but I suspect this actually describes a lot of real haskell programs, namely webapps
12:25:42 <shapr> Zekka: yeah, I'd probably ask a lot of "why didn't you?" questions
12:25:56 <EvanR> Zekka: really?
12:26:03 <EvanR> re webapps
12:26:17 <bernalex> thoughtpolice: nah it was a simple s/open source/free software/ for the website.
12:26:22 <Zekka> EvanR: I mean, before you do any abstraction, a ton of the code is letting people order people to make a certain kind of change to a global resource (the database)
12:26:30 <EvanR> do we not internalize the transactional basis of everything ever
12:26:30 <thoughtpolice> Oh, on the HL repo?
12:26:33 <Zekka> letting people order the service to*
12:26:51 <bernalex> thoughtpolice: what's HL?
12:26:58 <thoughtpolice> The main webpage
12:27:03 <thoughtpolice> Which I assume is what you meant by website
12:27:06 <bernalex> probably, yeah.
12:27:24 <bernalex> I didn't even know that was in phab.
12:27:40 <Zekka> EvanR: Hm, I think you're getting at a more speciifc application development concern than I was when I said web apps met my description, but I'm not sure
12:28:03 <thoughtpolice> bernalex: So I think that the bug was this - GitHub actually has this kind of weird feature where when you open a PR, it creates an actual ref in the main repository that is not fetched by default. But you can make your git client fetch it. That allows you to check out PR's locally: https://gist.github.com/piscisaureus/3342247
12:28:09 <thoughtpolice> (I use that all the time for my GH stuff)
12:28:35 <thoughtpolice> bernalex: So Phabricator, when it monitors remote repositories, became more aggressive about fetching these refs. Hence, that is why it emailed you, because it saw a new ref 'appear' in the repository.
12:28:39 <bernalex> so phab fetched it now?
12:28:41 <bernalex> yeah ok
12:29:07 <thoughtpolice> So yeah this is almost certainly a bug but I'm not sure how they'll want to fix it. They have some plans for GitHub interoperability, so they might fix it when they get to that.
12:29:17 <thoughtpolice> In the mean time, just turning off notifications was the right thing to do, anyway.
12:30:06 <bernalex> well, if it were up to me, github wouldn't even be part of the conversation. but it seems most people disagree with me on that. :)
12:30:16 <thoughtpolice> bernalex: I need to boil this down into like a simple test case so I can submit it to them, haven't done so yet.
12:30:34 <thoughtpolice> But I'm like 99% sure that's what happened.
12:30:42 <bernalex> hire me! I can do that. and then I could afford food too. :D
12:30:49 <shapr> My workplace has a collection of git aliases that let you grab a PR
12:31:11 <bernalex> shapr: git already has pull-request
12:31:18 <thoughtpolice> Hiring unfortunately is not my baileywick, I'm afraid.
12:31:27 <thoughtpolice> Also yes, nobody seems to know about git pull-request!
12:31:36 <bernalex> github's crap is quite superfluous, but I use their cli tool 'hub' to manage it.
12:31:42 <thoughtpolice> (Or that weird hidden PR feature either, for that matter)
12:31:58 <bernalex> git-pull-request is neat. that's what Linux has been doing since forever.
12:32:34 * thoughtpolice still has very fond memories of 'darcs send'
12:33:07 <bernalex> I think darcs, essentially, has gotten the whole abstraction of a RCS one order of magnitude better than git.
12:33:32 <bernalex> make OpenPGP stuff actually work properly in darcs, and I'm changing to darcs in a heartbeat.
12:34:36 <joof> @seach Kathleen Berger
12:34:36 * lambdabot orders her trained monkeys to punch Kathleen Berger
12:34:55 <joof> derp
12:36:05 <xcombelle> read this question http://programmers.stackexchange.com/questions/324033/minimal-programmers-definition-of-a-monad looks like the serie of ericlippert referenced are good
12:37:52 <Welkin> o.o
12:37:56 <jackhill> bernalex: I am in the anti-github camp
12:37:57 * hackagebot HGE2D 0.1.6.5 - 2D game engine written in Haskell  https://hackage.haskell.org/package/HGE2D-0.1.6.5 (I3ck)
12:38:00 <nmattia> shower thought: if the GHC's rts only regains control when a new heapblock is allocated, what happens if your program allocates nothing?
12:38:04 <nmattia> could that actually happen?
12:38:16 <nmattia> or is there always *some* allocation
12:39:36 <thoughtpolice> nmattia: Yes, it can happen. The answer is, generally, "Don't do that". For larger programs it'll be essentially impossible to avoid allocations. For smaller ones, you can do that, but normally the example has to be quite contrived or an 'obvious' bug. Finally, there is a code generation option to ensure that even non-allocating loops perform a heap check to
12:39:36 <thoughtpolice> switch over.
12:39:53 <thoughtpolice> This is useful in some cases of e.g. exposing Haskell evaluation through a sandbox, or something.
12:40:30 <nmattia> thoughtpolice: I assuming it could happen quite easily when interfacing with foreign code?
12:40:43 <nmattia> and that'd only be a problem in a concurrent setting
12:40:57 <nmattia> otherwise, if nothing's allocated, well, you don't really nead the rts
12:41:17 <nmattia> I'm, need
12:41:29 <EvanR> you do need the rts
12:41:32 <Gurkenglas> How do I open an example .hs in stack's ghci? http://lpaste.net/6366419895327916032
12:41:34 <thoughtpolice> Yes, if a foreign call takes a very long time, and it is marked 'unsafe', then it can block the whole program indefinitely. That is because an 'unsafe' call is basically just a "large instruction" as far as the code generator is concerned, so it calls it directly inline from the Haskell code.
12:42:07 <EvanR> without rts switching a thread will hog the capability
12:42:14 <thoughtpolice> What will happen is, other threads will still switch, if they're on their own hardware threads. But once a GC occurs, the runtime must wait for all threads to hit a safe point for GC. But that cannot happen until the thread inside the foreign call returns.
12:42:14 <nmattia> EvanR: what would the RTS do in a non-concurrent setting where you allocate nothing?
12:42:14 <shapr> thoughtpolice: ok, I still don't know about git pull-request, where do I find docs?
12:42:23 <Gurkenglas> (I have run stack install quickspec before that)
12:42:24 <bernalex> shapr: man git pull-request
12:42:59 <bernalex> shapr: sorry, man git request-pull
12:43:12 <EvanR> nmattia: well, youre always in a concurrent setting on a modern OS. youll need to at least deal with signals, but probably other stuff from the OS
12:43:21 <nmattia> thoughtpolice: oh, I always thought the "safe" annotation refered to programs that had no possible pattern match fails or errors
12:43:38 <thoughtpolice> -XSafe is different from a 'safe' foreign call.
12:43:51 <shapr> bernalex: but that's not the same as grabbing a PR for testing?
12:43:52 <thoughtpolice> You have to explicitly request an unsafe one (so you don't normally see the keyword 'safe')
12:44:09 <thoughtpolice> s/one/foreign call/
12:44:28 <EvanR> nmattia: if you mean 1 thread and not doing allocations, that should be fine. but it seems very unlikely
12:44:28 <bernalex> shapr: I'm not sure what you mean. request-pull is git's built in pull request. it doesn't really have much to do with github.
12:44:35 <xcombelle> after reading, ercic lippert blog series about monad is all but clear
12:44:43 <mgsloan> bernalex: Maybe try "stack ghci --no-load" and then ":load examples/Composition.hs" ?
12:44:52 <mgsloan> Err I mean Gurkenglas 
12:45:09 <nmattia> EvanR: yeah, it was just a "though experiment"
12:45:18 <nmattia> thoughtpolice: thanks for all the clarification
12:45:26 <shapr> bernalex: I often want to check out a PR someone else created for testing, I thought that's what you were discussing.
12:45:58 <nmattia> thoughtpolice: and by the way, never got to thank you for cleaning up the issue list on binary-serialize-cbor for the london meetup. Thank you!
12:46:03 <bernalex> shapr: I'm not sure what you even mean. why do you make a PR for testing instead of just a branch?
12:46:18 <bernalex> shapr: anyway, you can use github's own cli tool 'hub' to interface with github. that's what I use.
12:46:28 <shapr> ok, thanks
12:46:47 <bernalex> shapr: it's quite good for e.g. making and grabbing pull requests.
12:47:48 <thoughtpolice> nmattia: np, glad you enjoyed it! I need to actually finish up the ST work and release it...
12:48:56 <bernalex> shapr: when deag with github, I usually just git clone it as usual, then use 'hub fork' to get a fork. then I can 'git push alexander-b' my changes, or just hub pull-request on a branch, and it does that for me before pushing. you can also merge pull requests and similar things.
12:49:20 <bernalex> shapr: s/deag/dealing/
12:50:31 <shapr> bernalex: that's neat
12:50:59 <nmattia> thoughtpolice: I actually had a quick look at the ST thing during the meetup, but have since been ridiculously busy. Now's much quieter, so let me know if I can lend a hand
12:52:57 * hackagebot Strafunski-StrategyLib 5.0.0.9 - Library for strategic programming  https://hackage.haskell.org/package/Strafunski-StrategyLib-5.0.0.9 (AlanZimmerman)
12:56:32 <undreren> can't make my IRC client make beepy sounds on messages
12:56:47 <undreren> Google is not my friend, apparently
12:57:04 <daey>  why is it that recursion is glorified as good, while all other languages that i know of tell you to avoid it
12:57:22 <gtsteel> I'm trying to get ghcjs set up. I've followed the instructions in http://docs.haskellstack.org/en/stable/ghcjs/ and it can run ghcjsi and compile stuff, but it crashes when trying to install any dependencies
12:57:41 <nmattia> daey: mostly because they implement it using a stack
12:57:43 <bernalex> daey: because those languages work differently at runtime.
12:57:45 <hpc> many other languages are structured in ways that prevent you from gaining reasoning power from recursion
12:57:47 <nmattia> daey: from my understanding
12:57:54 <hpc> or in ways that make recursion have a lot of runtime issues
12:57:58 * hackagebot megaparsec 5.0.1 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-5.0.1 (mrkkrp)
12:58:08 <luite> gtsteel: how does it crash?
12:58:21 <gtsteel> I get the error message "Process exited with code: ExitFailure 1
12:58:22 <daey> well the two issues i often read about are of two natures: A. compiler has trouble optimizing them. B. Hard to debug
12:58:23 <gtsteel> Logs have been written to: /home/george/ghcjs-test/.stack-work/logs/ssv-0.3.log"
12:58:33 <bernalex> daey: problems that are elegantly solved using recursion are elegantly solved using recursion in e.g. Java too. it's just that those languages can't actually handle them very well at runtime.
12:59:03 <luite> gtsteel: anything interesting in that log file? if not, can you rerun with the '-j1 -v' options?
12:59:04 <gtsteel> Configuring ssv-0.3...
12:59:06 <gtsteel>     setup-Simple-Cabal-1.22.8.0-ghcjs-0.2.0_ghc-7.10.3:
12:59:07 <gtsteel>     .stack-work/dist/x86_64-linux/Cabal-1.22.8.0_ghcjs/: does not exist
12:59:11 <Peaker> bernalex, elegant using recursion and pattern-matching, often, so Java will lack the latter
12:59:24 <daey> i kinda like recursion. i usually need some time to get it right but when it works it looks so pretty
12:59:35 <Gurkenglas> mgsloan, nope http://lpaste.net/6366419895327916032
12:59:49 <undreren> daey: recursions is awesome
12:59:55 <luite> gtsteel: hmm, i don't know that one, could be a stack issue. does creating that directory fix it?
13:00:33 <undreren> > let fibs = 0 : 1 : scanl1 (+) fibs in fibs
13:00:36 <lambdabot>  [0,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10...
13:00:45 <gtsteel> that directory exists
13:01:03 <benjwadams> Help!  People here want to program in node.js!  What's the status of Haskell for frontend?  I saw GHCJS, purescript, haste, plus others that are sorta haskelly like Elm
13:01:09 <daey> its like telling someone to tell himself to work
13:01:10 <mizu_no_oto_work> daey: In many imperative languages, recursion is likely to cause a stack overflow.  If you don't suffer from that problem, then recursion becomes more attractive
13:01:16 <hpc> > scanl1 [0, 1, 1, 2, 3, 5]
13:01:17 <lambdabot>      Couldn't match expected type ‘a -> a -> a’
13:01:18 <lambdabot>                  with actual type ‘[Integer]’
13:01:18 <lambdabot>      In the first argument of ‘scanl1’, namely ‘[0, 1, 1, 2, ....]’
13:01:24 <hpc> > scanl1 (+) [0, 1, 1, 2, 3, 5]
13:01:25 <lambdabot>  [0,1,2,4,7,12]
13:01:30 * EvanR breaks glass and hoses down the node.js
13:01:40 * daey applies recursive motivation to himself
13:01:56 <daey> *it failed*
13:01:58 <hpc> > scanl1 (+) [1, 2]
13:01:59 <lambdabot>  [1,3]
13:02:05 <hpc> ah
13:02:09 <benjwadams> I don't understand all the hype around JS and would like to avoid it
13:02:21 <Peaker> I dislike the tie-the-knot examples like fibs, because they're so fragile/error-prone, and you get no help from the type checker
13:02:23 <Welkin> benjwadams: plenty of choices
13:02:27 <dmwit_> > iterate (scanl1 (+)) [0,1]
13:02:29 <lambdabot>  [[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,1],[0,...
13:02:40 <benjwadams> how can I give my employers a taste of haskell instead?
13:02:55 <Peaker> > fst <$> iterate (\(cur,next)->(next,cur+next)) (0,1)
13:02:57 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:02:58 * hackagebot xlsx 0.2.3 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.2.3 (KirillZaborsky)
13:03:02 <Welkin> benjwadams: Elm is more like a DSL, Purescript is pretty much just a haskell-like javascript, and then you can use reflex-dom in haskell with ghcjs
13:03:04 <shachaf> i,i let x = not x -- tying the not
13:03:05 <Peaker> no fragile recursion
13:03:11 <mgsloan> Gurkenglas: You need to create a stack project which includes quickspec.  Just create a "stack.yaml" with "resolver: lts-6.7" in it
13:03:17 <EvanR> unfortunately haskell is not a spectator sport
13:03:27 <benjwadams> Anything that integrates with meteor?
13:03:29 <mgsloan> That will implicitly have packages: ["."]
13:03:30 <thoughtpolice> nmattia: So I think benchmarking the ST patch from Duncan would be pretty useful. I'll get to it at some point Soonish, but any help would be appreciated!
13:03:34 <EvanR> its hard to explain how awesome it is to bystanders
13:03:51 <thoughtpolice> nmattia: That's the main thing holding it up, so we can improve the serialization/deserialization of boxed arrays/vectors of things.
13:04:07 <Gurkenglas> mgsloan, stack init in quickspec-0.9.6/ will work for that right?
13:04:11 <thoughtpolice> And unboxed ones. The patch is somewhere; I did integrate like 90% of Duncan's changes, except the 'ST' change.
13:04:15 <undreren> > fix not
13:04:19 <lambdabot>  mueval-core: Time limit exceeded
13:04:23 <undreren> lol
13:04:26 <EvanR> True
13:04:35 <mgsloan> Gurkenglas: Yup that too
13:05:16 <EvanR> > fix (not :: Expr)
13:05:18 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘Bool -> Bool’
13:05:18 <lambdabot>      Probable cause: ‘not’ is applied to too few arguments
13:05:18 <lambdabot>      In the first argument of ‘fix’, namely ‘(not :: Expr)’
13:06:00 <EvanR> huh
13:06:39 <Gurkenglas> worked thx http://lpaste.net/6366419895327916032
13:06:52 <dmwit> That scanl1 definition for fibs seems like it only works by accident.
13:07:16 <dmwit> (And doesn't even work properly at that.)
13:07:20 <gtsteel> luite: is there another recommended way to install ghcjs if stack is not working?
13:08:30 <dmwit> > let fibs = x : y : scanl1 (+) fibs in fibs
13:08:32 <lambdabot>  [x,y,x,x + y,x + y + x,x + y + x + (x + y),x + y + x + (x + y) + (x + y + x)...
13:08:42 <undreren> let the = (0:); knot = (1:); tie x y = (x . y) : tie x y in tie the knot
13:08:59 <undreren> > let the = (0:); knot = (1:); tie x y = (x . y) : tie x y in tie the knot
13:09:01 <Welkin> undreren: what are you doing?
13:09:01 <lambdabot>  [<[Integer] -> [Integer]>,<[Integer] -> [Integer]>,<[Integer] -> [Integer]>,...
13:09:26 <dolio> `fix ((0:) . scanl (+) 1)` is the good one, I believe.
13:09:29 <dmwit> > let the = (0:); knot = (1:); tie x y = x . y $ tie x y in tie the knot
13:09:30 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
13:09:31 <nmattia> thoughtpolice: alright. Duncan also mentioned that some actual benchmarks (especially against 'store') would be useful, so it'll be a benchmark fest
13:09:54 <undreren> Welkin: dumb things, i suppose
13:10:01 <thoughtpolice> nmattia: There's actually a PR for that, which I think needs an update - it would be good to expand that, though.
13:10:05 <thoughtpolice> I need to merge that PR...
13:10:07 <MichaelK> Hi, I'm having some trouble with binding nested monads, i.e. I want something like `(Monad m1, Monad m2) => m1 (m2 a) -> (a -> m1 (m2 b)) -> m1 (m2 b)`
13:10:27 <EvanR> that canna be done!
13:10:36 <dmwit> MichaelK: http://stackoverflow.com/q/7040844/791604
13:10:36 <EvanR> in general
13:10:42 <Welkin> my favorite fibonacci generator (and the easiest to read) is this one
13:11:04 <Welkin> > let fibs a b = a : fibs b (a + b) in fibs 0 1
13:11:05 <dmwit> MichaelK: And the helpful version of that answer is, "I hope one of those two monads has an analogous transformer.". ;-)
13:11:06 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:11:48 <MichaelK> dmwit: hmmm.. so should work for `IO (Maybe a)`? 
13:11:56 <MichaelK> or no..
13:12:22 <dmwit> MichaelK: No, there is no operation of type `IO (Maybe a) -> Maybe (IO a)`. But there is a `MaybeT` that you will probably enjoy very much.
13:12:39 <nmattia> thoughtpolice: can't seem to find Duncan's "patch". is it somewhere in the "faster vectore support" (#62) PR?
13:13:06 <EvanR> thats a vectore
13:13:07 <MichaelK> dmwit: tis nice, thanks
13:13:08 <thoughtpolice> nmattia: Ah, it's this branch: https://github.com/well-typed/binary-serialise-cbor/commits/pr/st-monad
13:13:10 <dmwit> MichaelK: Sorry, my mistake. Yes, there is an operation of type `Maybe (IO a) -> IO (Maybe a)`.
13:13:32 <thoughtpolice> nmattia: So I integrated a lot of those changes, several were unrelated, so the main ones are
13:13:36 <nmattia> thoughtpolice: yeah, saw it too late
13:13:36 <dmwit> :t traverse
13:13:38 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:13:39 <thoughtpolice> https://github.com/well-typed/binary-serialise-cbor/commit/776106b75009a74d3b3405fa65ea6cc52c2d4035 and https://github.com/well-typed/binary-serialise-cbor/commit/1e11627ff60dfc16297646fd54c0decdb2d6ae63
13:13:50 <nmattia> thoughtpolice: will have a look tomorrow
13:13:55 <nmattia> ah cool
13:13:58 <thoughtpolice> But just benchmarking the first one is the main thing. I think Duncan said it got a few % slower
13:13:59 <dmwit> :t sequence
13:14:01 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:14:05 <dmwit> That one. =)
13:14:10 <thoughtpolice> Since that's just the conversion to ST. Maybe worth eating it, but maybe also we can fix it.
13:14:12 <dmwit> MichaelK: ^^
13:14:21 <thoughtpolice> nmattia: Cool, just ping me or lmk if you need help.
13:14:28 <nmattia> thoughtpolice: cool, will do
13:16:09 <platz> lose :: (a -> Void) -> f a   interesting type
13:17:42 <dmwit> :t \nested f -> fmap join (join (fmap (sequence . fmap f) nested)) -- MichaelK
13:17:43 <lambdabot> (Monad f, Monad m, Traversable m) => f (m a1) -> (a1 -> f (m a)) -> f (m a)
13:18:14 <dmwit> :t \f -> sequence . fmap f
13:18:15 <lambdabot> (Monad m, Traversable t) => (a1 -> m a) -> t a1 -> m (t a)
13:18:26 <dmwit> :t \nested f -> fmap join (join (fmap (traverse f) nested)) -- MichaelK
13:18:27 <lambdabot> (Monad f, Monad m, Traversable m) => f (m a1) -> (a1 -> f (m a)) -> f (m a)
13:20:04 <MichaelK> dmwit: \nested f -> join <$> (join $ traverse f <$> nested) is slightly prettier. thank you
13:21:40 <dmwit> MichaelK: But just plain old `>>=` is prettier still, and has the same functionality when using `MaybeT IO a` in place of `IO (Maybe a)` everywhere.
13:21:55 <dmwit> MichaelK: Plus you get to use `do` syntax if you prefer it to `>>=`.
13:22:10 <dmwit> ?unmtl MaybeT IO a
13:22:10 <lambdabot> IO (Maybe a)
13:22:52 <MichaelK> I agree, however this is mostly for an online challenge so I can't use MaybeT without copy-pasting all the code I need :/
13:25:58 <woffs> a question: how can I reap the zombie left by createProcess (proc "/notexist" []) 
13:28:36 <dmwit> woffs: wait for it
13:28:55 <dmwit> https://hackage.haskell.org/package/process-1.4.2.0/docs/System-Process.html#v:waitForProcess
13:29:16 <woffs> dmwit, but how? since createProcess throws the exception, I get no processhandle
13:29:57 <dmwit> hah
13:31:43 <woffs> maybe a ghc-7.8.4 bug? ghc 8 seems to leave no zombies there
13:32:16 <dmwit> Yeah, I would say that's a bug.
13:42:39 <athan> So I've heard conflicting reports.. in IO, if I do something like `do{ _ <- someAction; foo }`, is `someAction` genuinely executed even though its result value isn't evaluated to WHNF?
13:44:22 <dmwit> `someAction` is executed. Its result is not evaluated.
13:45:10 <dmwit> This is also easily tested. Write `main = do { _ <- putStrLn "hi!"; return () }` and see what happens.
13:45:45 <gtsteel> your do block desugars to `someAction >> foo`, you might want to look up the documentation on (>>)
13:45:50 <dmwit> Also, I will point out that `someAction` is of course only executed if it is referenced (however deeply) from `main`.
13:46:08 <athan> dmwit: Thanks dmwit :) I think that's where I've lost my understanding of monadic actions
13:46:30 <athan> ahh yes, that makes sense
13:48:35 <dmwit> I guess "referenced from `main`" is slightly imprecise. See the paper "Tackling the Awkward Squad" for the precise version.
13:50:49 <ertesx> woffs: you could try this while the bug exists:  do rec (_, _, _, ph) <- createProcess `finally` waitForProcess ph
13:51:03 <ertesx> (add the missing argument i failed to write)
13:52:22 <ertesx> uhm…  perhaps not with finally, but rather onException
13:53:53 <woffs> :i rec
13:54:09 <ertesx> woffs: it's a language construct enabled by -XRecursiveDo
13:54:22 <ertesx> and a really ugly solution i would be surprised to find working
14:01:42 <athan> dmwit: !! Ahh I remember that one, okay I'll check it out
14:01:48 <woffs> ertesx, thx anyway :)
14:03:05 <Summ314> Hello, I'm trying to get gtk2hs on Windows, but when installing I get errors like "pkg configurati" 
14:03:16 <Summ314> Oops
14:03:39 <Summ314> Pkg config for "Cairo" not found
14:04:34 <mmachenry> I just git cloned a package that has a .cabal file and a stack.yaml file in it. I would like to make it available to my system so that non-project, one-off scripts can make use of it. Is there a recommended process for this now?
14:05:38 <mgsloan> mmachenry: Do you intend for anyone else to ever run those scripts?
14:05:50 <mmachenry> mgsloan: Nope, just me.
14:06:22 <mmachenry> It's also okay for the package I got from github to be simply installed for my user and not global to the system.
14:06:43 <mgsloan> Well, stack defaults to using the global project, so if you put the package in there and build it, it will be available
14:06:58 <mmachenry> It's just that I tend to use some of these packages often and I want to be able to open ghci and import them and play with them or write a quick script and import them.
14:07:40 <mmachenry> mgsloan: So the best way to do this is to edit my global stack.yaml file and then use stack ghci instead of ghci from here on out?
14:10:25 <mgsloan> Yeah, and this is likely helpful too - http://docs.haskellstack.org/en/stable/GUIDE/?highlight=script#script-interpreter
14:10:39 <mgsloan> Personally, I'd always use a local stack.yaml
14:10:41 <minib00m> guys, how can i find packages available for compiler version 7.6.3?
14:11:16 <minib00m> cause 7.6.3 doesn't know what Parsec is... :p
14:11:20 <Welkin> minib00m: just cabal install, or stack install
14:11:25 <Welkin> minib00m: upgrade your ghc
14:11:40 <daey> ive noticed that cabal install works without root, except it doesnt
14:11:41 <minib00m> Welkin: i have ghc8 on my machine, but i just need to use 7.6.3
14:11:48 <daey> where does it put the pacakges?
14:12:24 <Welkin> ~/.cabal
14:12:42 <daey> ah...that was obvious :D
14:22:52 <athan> Is there a convenience function `splitLast :: [a] -> Maybe ([a],a)`?
14:23:00 * hackagebot rapid 0.1.2 - Rapid prototyping with GHCi: hot reloading of running components and reload-surviving values  https://hackage.haskell.org/package/rapid-0.1.2 (esz)
14:23:14 <dmwit> ?hoogle unsnoc
14:23:16 <athan> or really `[a] -> ([a], Maybe a)`
14:23:17 <lambdabot> Data.ByteString.Char8 unsnoc :: ByteString -> Maybe (ByteString, Char)
14:23:17 <lambdabot> Data.ByteString.Lazy.Char8 unsnoc :: ByteString -> Maybe (ByteString, Char)
14:23:17 <lambdabot> Data.ByteString unsnoc :: ByteString -> Maybe (ByteString, Word8)
14:23:39 <dmwit> https://hackage.haskell.org/package/extra-1.4.10/docs/Data-List-Extra.html#v:unsnoc
14:23:44 <athan> dmwit: I see it all the time in bytestring & text, I'm just wondering if there's one for lists
14:23:47 <athan> oh!
14:23:56 <athan> thanks dmwit!
14:25:04 <ertesx> athan: it's not universally true, but in most cases when you have to manipulate the far end of a list, Data.Sequence is worth looking into
14:28:00 * hackagebot scientific 0.3.4.9 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.9 (BasVanDijk)
14:28:00 <athan> ertesx: Yeah I've dug into it :) I saw a reddit post not long ago about a random-access data.sequence on O(log n) I think!
14:28:08 <EvanR> Sequence exists, and MkQueue [a] [a] exists
14:28:28 <EvanR> and using a list in reverse exists
14:28:38 <athan> forgoeing vector anyway
14:29:28 <Welkin> I love Data.Sequence
14:29:32 <EvanR> manipulating lists in the form of a vector is C++ shenanigans
14:29:32 <Welkin> one of the coolest data structures
14:29:40 <Welkin> I use it as a queue :D
14:29:45 <ertesx> athan: vectors aren't necessarily better than [] or Seq
14:30:44 <EvanR> Welkin: depending on circumstances the folk function queue which is two lists might perform better
14:30:51 <EvanR> functional queue
14:31:16 <Welkin> I have used a double stack wrapped in a Queue type
14:31:24 <Welkin> but Sequence has a far superior API
14:31:33 <Welkin> it's annoying to make your own queue
14:31:36 <luite> gtsteel: cabal install should work on a snapshot
14:31:38 * EvanR thinks about the queue API
14:31:57 <Welkin> plus using pattern matching to pop the next item off
14:31:58 <EvanR> Welkin: well its like 5 lines of code, but is of course available on hackage
14:32:01 <Welkin> with ViewPatterns
14:32:14 <Welkin> I have never see na standard FIFO queue on hackage
14:32:20 <Welkin> I always just used Seq or made my own Queue
14:32:29 <EvanR> while Sequence has a dedicated dude doing bitfiddling to increase its performance
14:32:50 <Welkin> it's not about the lines of code
14:32:55 <Welkin> it is about how to design the API
14:33:21 <Welkin> when you dequeue, do you get a pair of a (Maybe a, Queue a)
14:33:24 <Welkin> ?
14:33:42 <Welkin> it's easier to pattern match
14:33:50 <Welkin> which Seq has already done for you
14:33:57 <EvanR> i would not do it like that
14:34:11 <EvanR> in any case its trivial
14:34:31 <EvanR> if you need operations other than enqueue and dequeue, yeah this is not good
14:35:06 <EvanR> just mentioning the performance
14:35:27 <Welkin> I have also seen Data.Set used as a priority queue
14:35:36 <Welkin> I thought that was funny
14:35:44 <EvanR> IntSet is a pretty nice priority queue
14:35:46 <Welkin> with minView
14:35:56 <Welkin> but that doesn't allow duplicates
14:36:13 <Welkin> edwark wrote a nice heap package though
14:36:17 <Welkin> and there is pqueue I think
14:36:27 <ertesx> you mean Map and IntMap, don't you?
14:36:34 <EvanR> IntMap
14:36:49 <EvanR> my brain is failing me
14:36:55 <Welkin> no ertesx 
14:37:05 <Welkin> you can use Set if you are just sorting the keys
14:37:12 <Welkin> for some other structure
14:37:14 <Welkin> like a graph
14:37:14 <ertesx> yeah, Set could act as a priority queue with the right Ord instance
14:37:37 <EvanR> IntSet is just a set of ints
14:37:53 <EvanR> boring as all hell
14:38:21 <ertesx> sometimes that's all you want to queue, and sometimes the value is indeed also the priority =)
14:38:23 <bjs> EvanR: who said sets are boring
14:38:36 <EvanR> -- no one ever
14:38:40 <bjs> ^^
14:40:21 <EvanR> Integer -- implementation of all finite sets up to isomorphism
14:40:27 <Jello_Raptor> hmm, I need some advice regarding existential types
14:40:33 <EvanR> Maybe Integer -- adding an infinite set
14:41:25 <ertesx> EvanR: or 1/2
14:41:28 <ertesx> ;)
14:41:36 <EvanR> half?
14:42:07 <ertesx> Maybe Integer ~ { …, -2, -1, 0, 1/2, 1, 2, … }
14:42:25 <EvanR> theres no set with 1/2 cardinality
14:42:50 <ertesx> why would there be?  i'm just defining Nothing to be 1/2 =)
14:43:08 <EvanR> thats all wrong!
14:43:40 <Jello_Raptor> I have a bunch of types (A,B,C,D,...) and a class Foo f with some function :: f -> f -> f. I want to be able to put a bunch of elements of class Foo in a pile, and compute pairwise relationships such that if both Foos are the same underlying type then I get Just(function foo foo') otherwise Nothing. Is there any good way to do this without needing to have explicit flag values floating around?  
14:44:33 <ertesx> Jello_Raptor: class (Typeable a) => Foo a
14:44:48 <ertesx> Jello_Raptor: you need dynamic typing for that, which is what Typeable is for
14:44:51 <EvanR> Typeable gives you these necessary flags floating around
14:45:26 <Jello_Raptor> ertesx: ahh, cool
14:45:35 <EvanR> but if A B C D... is a specific set you can instead use a sum type to tag them explicitly
14:45:45 <EvanR> then you dont have to mess with dynamic typing
14:46:00 <ertesx> or rather: you implement the dynamic typing yourself through tags =)
14:46:07 <EvanR> right
14:46:31 <EvanR> you can also use the typeable machinery for the specific A B C Ds without opening yourself up to mistakes
14:46:42 <Jello_Raptor> EvanR: It could be, but that makes my code significantly less modular :/ 
14:46:52 <EvanR> create a new class for MyCoolTypeables and declare empty instances for A B C D ...
14:47:03 <EvanR> Jello_Raptor: modular?
14:47:10 <Welkin> tubular
14:47:16 <ertesx> Jello_Raptor: personally i wouldn't put the Typeable constraint on Foo, but rather on the function that requires the dynamic typing
14:47:25 <EvanR> is your problem description to "put a bunch of any haskell types whatsoever in a pile" ?
14:47:36 <Welkin> lol
14:48:05 <Welkin> typecast your elements to Any/Object like all the oop programmers
14:48:06 <EvanR> there might be a saner way to do whatever youre trying to do
14:48:06 <ertesx> Jello_Raptor: like this: combine :: (Typeable a, Foo a, Typeable b, Foo b) => a -> b -> Maybe a
14:48:35 <ertesx> Jello_Raptor: and now comes the speech
14:48:40 <ertesx> Jello_Raptor: incoming…
14:48:51 <Welkin> which basically turns off the type system altogether
14:48:59 <Welkin> when they decide it is inconvenient
14:49:18 <Jello_Raptor> EvanR: not quite. I'm writing this thing where there's a stack of different types each with lattice operations, and I want to be able to treat them as members of the same lattice by embedding them as Maybe(ExistentialWrapper) 
14:49:21 <EvanR> well a lot of times in OOP it *is* inconvenient
14:49:23 <ertesx> Jello_Raptor: your main mistake may be that you have Foo to begin with…  it sounds like you're trying to do OO in haskell
14:49:39 <Squarism> i feel like when i first tried pascal as 14 yo when doing non-trivial-but-not-complex UI programming FP-style. Amature at the wheel. My polymorphic components are now type parameterized functions. Everything feels tightly coupled like a hedgehog in rolled up in a mesh. 
14:49:54 <EvanR> Jello_Raptor: yeah, in this case you actually want to define an interface that all your types follow, and then create a record of those functions or a type class
14:50:04 <EvanR> not use typeable
14:50:39 <Jello_Raptor> mmm, how is that different from using a typeclass? 
14:51:04 <EvanR> since i mentioned using a type class, its not
14:51:15 <ertesx> Jello_Raptor: in OO you have subtypes as implementations of an informal semantics, in haskell you have types as semantics and *values* as implementations of semantics
14:51:36 <EvanR> its different from Typeable because it doesnt use Typeable and doesnt introduce the implied headaches of Typeable
14:52:33 <ertesx> Jello_Raptor: tl;dr: Foo, if anything, should be a type
14:52:48 <ertesx> likely…  i don't know what the application is
14:54:26 <EvanR> ertesx: they want to have different implementations of "lattice operations"
14:54:47 <Jello_Raptor> EvanR: yup
14:54:49 <minib00m> is it possible to import some functions from module, but hide all constructors?
14:55:18 <ertesx> minib00m: import Module (Type1, Type2, func1, func2)
14:55:19 <EvanR> so define lattice operations as a record type or a type class
14:55:20 <Welkin> minib00m: import <module> (f1, f2)
14:55:31 <ertesx> minib00m: imports Type1 (without constructors), etc.
14:56:18 <EvanR> if you run into a binary method problem, then one way to fix it is to build a conversion operation into your interface
14:56:54 <EvanR> before fooing x and y, it converts either to the common format
14:57:10 <EvanR> which kind of sucks
14:57:37 <EvanR> but there you have it
15:02:08 <Jello_Raptor> ertesx: EvanR: yeah, my issue is that it does kinda suck. Existential types + typable would allow me to treat them as identical when neccesary and call the appropriate pairwise function when they match. I'm currently doing what the both of you suggested, but it's getting annoying having to update the code in a dozen places for each change, and having to deal with gigantic modules or circular module dependencies. 
15:02:34 <Jello_Raptor> Problem is I don't know enough about Typeable to figure out which is the lesser evil 
15:02:49 <EvanR> well circular deps is another issue solved by moving your common types into a module with no deps
15:04:58 <EvanR> Jello_Raptor: so... one way to deal with this is to emulate multimethods with a multi param typeclass. you can implement Ops A A, Ops B B one way, and Ops A a and Ops a A with conversions, though thats overlapping
15:05:13 <Jello_Raptor> EvanR: it's a lot of complex types that are all independent of each other, but when they're all summed into a single Foo type I can't split them up at all. 
15:05:52 <EvanR> can you give an example operation which involves two of these "independent" types
15:06:50 <EvanR> and the use case for putting all the independent types together
15:07:57 <EvanR> thinking about it, it seems like this is another avenue to get selective "intelligent" automatic conversions
15:08:05 <EvanR> which haskell kind of doesnt do
15:09:18 <EvanR> putting fromIntegral in places where you need it, explicitly, is the idiom
15:09:24 <EvanR> for example
15:09:48 <EvanR> it wont do like ruby in the face of "+" and chose a way to convert the operands to something or not
15:10:26 <Jello_Raptor> basically, I've got a "component" with properties in a `Map String Property` where properties are the "Foo" type. I've got an operation "join :: Foo -> Foo -> Foo", and I want to be able to write a function that combined two components by matching elements up by their keys and calling "join" on the pair if they have the same constructor of Property. Ideally "Property" would actually be a typeclass, with each constructor in property 
15:10:26 <Jello_Raptor> being a type of its own with its own join function. 
15:10:44 <Jello_Raptor> 'Foo = Property'
15:11:07 <EvanR> mkay
15:11:35 <EvanR> you might be able to restructure that to get what you want and nicer type safety
15:12:01 <EvanR> i dont understand what join :: Foo -> Foo -> Foo is supposed to do?
15:12:13 <EvanR> what is the Foo type
15:13:49 <Jello_Raptor> EvanR: there's multiple things if the Foo is a range of values then join gets you the intersection of that range, if it's sets then the set intersection, there's other things a foo can be with their own definitions for join. 
15:13:59 <Jello_Raptor> if both Foos*
15:14:12 <EvanR> so Foo is some dynamically typed universe of values
15:14:21 <Jello_Raptor> yes
15:14:44 <EvanR> right... so then youre on the sanest track to do *that*
15:15:01 <EvanR> use a sum type, and your code can decide how to do these things (or not) based on the sum tags
15:15:23 <dmwit> Why not one `Map` per possible contained type...?
15:15:23 <EvanR> but its not that nice really from a type-driven perspective
15:15:28 <Jello_Raptor> damn :/ 
15:15:43 <Jello_Raptor> I was hoping for a better way to solve the problem 
15:15:46 <dmwit> Then there's no concern about mismatched properties, no need for dynamically checking constructors, ....
15:15:50 <EvanR> there almost certainly is
15:16:59 <Jello_Raptor> dmwit: I have been changing the universe of types quite rapidly and it's just painful to have to create the amount of boilerplate needed for it to work well.
15:17:11 <EvanR> Jello_Raptor: do you actually need to invest in this Map String Foos ? can this be genuine records with types?
15:17:29 <EvanR> it sounds like youre trying to get out of the type system
15:18:04 <dmwit> Jello_Raptor: You might like the `Map1 :: (* -> *) -> (* -> *) -> *` that somebody was cooking up on /r/haskell.
15:18:19 <dmwit> Together with a GADT for the keys/values, it should be pretty usable.
15:18:49 <Jello_Raptor> dmwit: hmm, do you have some search terms? 
15:19:02 <EvanR> Jello_Raptor: by deleting the structure more and more, i think youll find it hurts modularity
15:19:22 <EvanR> most haskell code is not made of Map String Dynamics
15:19:27 <dmwit> Jello_Raptor: Trying to find it now. But the idea is pretty simple anyway, you can probably build it yourself once you've seen the kind.
15:21:15 <dmwit> Jello_Raptor: can't find it =(
15:21:43 <EvanR> Jello_Raptor: one way to deal with handling data generically is with Generic, this lets you inspect any Generic data structure. It might not be appropriate for what youre trying to do, but at least you should know about this. Especially before going into more experimental territory
15:23:08 <EvanR> specifically it doesnt sound like a solution to the binary method problem, but the last thing you explained is a totally different issue, something like extensible records
15:25:39 <EvanR> generics, typeable, and many other things might be a great solution to the XY problem ;)
15:26:02 <Jello_Raptor> EvanR: good to know, I'll look into that too. 
15:40:23 <Profpatsch> Hm, why do I need to add a dependency to tests that I only use in the tested library?
15:40:53 <Profpatsch> This is my .cabal so far: http://lpaste.net/169576
15:41:01 <Profpatsch> Without the second protolude cabal complains.
15:41:29 <Profpatsch> Do I need to put the tests into their own folder?
15:42:01 <MichaelK> I just wrote a lightweight parser (~25 lines). Would someone be willing to take a look?
15:42:48 <lpaste> MichaelK pasted “lightweight parse” at http://lpaste.net/169577
15:53:59 <pavonia> Profpatsch: What error do you get if you compile without that dependency?
15:56:47 <haasn> How does GHC deal with module conflicts? Can I install two packages that expose the same module?
15:56:55 <haasn> And how do I import them? import "pkgname" Module?
15:57:24 <shachaf> Yes and yes.
15:57:38 <shachaf> The extension is PackageImports.
15:57:59 <shachaf> You might also just hide the packages you don't need.
15:58:03 * hackagebot superdoc 0.1.2.3 - Additional documentation markup and Unicode support  https://hackage.haskell.org/package/superdoc-0.1.2.3 (PeterSelinger)
15:59:27 <haasn> shachaf: Makes sense. In this case I'm trying to shadow a module from xmonad-contrib with one from the upstream repository
16:00:07 <Profpatsch> pavonia: Foreign/Nix/Shellout.hs:8:1: error:
16:00:09 <Profpatsch>     Failed to load interface for ‘Protolude’
16:00:11 <Profpatsch>     It is a member of the hidden package ‘protolude-0.1.6’.
16:02:15 <pavonia> Profpatsch: So you are using a module of that package?
16:03:29 <Profpatsch> pavonia: Hm, I’m using a module in the test suite from the library and the library module depends on protolude.
16:03:48 <Profpatsch> The library has protolude in the dependencies as you can see.
16:04:55 <pavonia> Hhm, but when is says "Failed to load interface for ‘Protolude’" it seems to be using something from that module
16:05:26 <pavonia> Not sure what's going on, maybe paste your test module too
16:07:19 <dmwit> haasn: In that case I think I would hide (or unregister) the outdated xmonad-contrib package.
16:07:39 <Profpatsch> pavonia: My test modules look like this: http://lpaste.net/169579
16:07:40 <haasn> dmwit: The problem is that I'm using other things from xmonad-contrib
16:08:03 * hackagebot hmpfr 0.4.0 - Haskell binding to the MPFR library  https://hackage.haskell.org/package/hmpfr-0.4.0 (MichalKonecny)
16:08:10 <dmwit> haasn: But you have installed the upstream xmonad-contrib, no?
16:08:25 <haasn> dmwit: I have installed the upstream xmonad-contrib, but this is older than one of the things it includes
16:08:45 <haasn> and I want to work around that by building the thing it includes separately in a new package
16:09:07 <haasn> (at least until upstream xmonad-contrib is updated)
16:09:27 <dmwit> I've gotten lost in your pronouns.
16:10:03 <dmwit> But if you think you have a way forward, don't let me stand in your way.
16:11:09 <pavonia> Profpatsch: No idea then, sorry
16:11:38 <Profpatsch> pavonia: np, thanks!
16:13:03 * hackagebot easyrender 0.1.1.1 - User-friendly creation of EPS, PostScript, and PDF files  https://hackage.haskell.org/package/easyrender-0.1.1.1 (PeterSelinger)
16:19:45 <haasn> dmwit: Turns out just patching xmonad-contrib itself and using my patched version is easier either way
16:21:25 <geekosaur> guh. is this the issue I just closed as expecting me to adopt someone's random fork of an existing module?
16:22:01 <ertesx> Jello_Raptor: i'm not familiar with your application, so i can't give you a full design guide, but in general a simple function approach (types as semantics, values as implementations) should always be easy to extend and refactor…  you don't branch on types, but individual implementations may choose branches from given ones
16:22:34 <ertesx> Jello_Raptor: it's hard to put into a one-line summary, and sadly i'm not aware of any good tutorials
16:22:56 <ertesx> i was going to write one myself, but it never happened
16:23:03 * hackagebot hmpfr 0.4.0.1 - Haskell binding to the MPFR library  https://hackage.haskell.org/package/hmpfr-0.4.0.1 (MichalKonecny)
16:23:29 <geekosaur> (correct answer there being to talk to whoever forked it, and they should talk to the original contributor or w/e. not up to us to decide who "owns" a module contributed by someone else)
16:23:51 <ertesx> s/function approach/functional approach/
16:23:52 <dmwit> geekosaur: Your complaint seems odd. We're not chasing anything down -- it's been explicitly brought to our attention.
16:24:02 <haasn> geekosaur: I don't really deal with software politics, all I care about is my computing experience. I don't mind what your policy is, I'm just applying the patch locally to improve my user experience
16:24:16 <dmwit> geekosaur: Admittedly it would be more convenient as a pull request than as an HTML link to a commit.
16:24:26 <yamadapc> I've a question about interruptible, user-interrupt and the C FFI. I'm working on Haskell bindings to a GUI framework in C. Somewhere I call `c_startMainLoop` which is a `foreign import ccall interruptible ...`, but `catch c_startMainLoop (\UserInterrupt -> undefined) ` doesn't do what I'd guess it does. The FFI call doesn't get stopped (handling control to Haskell) as I'd expect it to. I'm a little ignorant of wha
16:24:27 <yamadapc> t "interrupts" really are, but does someone know what this might be? The FFI call starts an NSApplication run loop (from Cocoa)
16:24:36 <haasn> And my only M.O. is following the path of least resistance, where “create an issue on github” has less resistance than “patch the file locally”
16:24:57 <haasn> has less resistance than “clean up the code (if needed) and submit the contribution as a pull request for the xmonad-contrib git”
16:25:33 <geekosaur> if I'm the original submitter of something, I'd at least like to be contacted before having my code thrown out and replaced by someone else's fork
16:25:56 <dmwit> haasn: Okay. In any case I don't think there's very much manpower from xmonad maintainers to do that, either. So if you want something included, you pretty much have to do the legwork yourself: make sure it won't break any configs, turn it into a PR, etc.
16:26:03 <johnw> geekosaur: what are you talking about?
16:26:19 <haasn> dmwit: Fair enough. I'm not noble enough to do that legwork until maintaining my patch file causes me more pain than not doing so :p
16:26:19 <dmwit> johnw: this, it seems: https://github.com/xmonad/xmonad-contrib/issues/64
16:26:27 <geekosaur> ^
16:29:40 <yamadapc> All in all, I can't get `foreign import ccall interruptible` to work with UserInterrupt
16:30:02 <dmwit> yamadapc: What does your foreign call do with SIGPIPE?
16:30:25 <dmwit> yamadapc: (Just reading the docs on InterruptibleFFI, https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/ffi.html)
16:30:27 <yamadapc> I don't know
16:30:34 <dmwit> yamadapc: Perhaps you should find out.
16:31:58 <dmwit> yamadapc: Additionally, I suppose it's entirely possible that your interruptible call isn't in a blocking system call. In which case it's not clear what GHC should do anyway.
16:33:00 <yamadapc> Mm... It's not; it's a GUI run loop... Will do something like render, wait for events or sleep and repeat
16:34:20 <dmwit> If it's a GUI run loop, then it is probably spending most of its time in a blocking system call (e.g. epoll or select), which is good for you.
16:34:22 <geekosaur> note that this may well be doing its own signal handling and recovery, and not expect to worry about caller interruptibility
16:34:30 <geekosaur> this is *especially* true of GUI run loops
16:34:52 <geekosaur> because the interrupt will probably abort the current operation *and restart the run loop*
16:34:55 <dmwit> BUT, as geekosaur says, it probably *is* doing something interesting with SIGPIPE and similar, which is bad for you.
16:35:37 <dmwit> yamadapc: You may like to insert a timer in your GUI that periodically calls Haskell's `yield`.
16:35:53 <yamadapc> yeah... is there a way to debug that? I can run the loop from within Haskell
16:35:55 <dmwit> yamadapc: These will be good points even for non-interruptible calls to get interrupted.
16:36:00 <yamadapc> I think that's what I'll do
16:36:17 <geekosaur> my guess is that (a) there is some specific call that can be made to terminate the run loop (b) you need to install a handler for UserInterrupt (SIGINT on POSIX) and invoke that call from there (c) and hope it works from outside the run loop
16:36:42 <dmwit> or, actually... hm. probably `yield` won't help
16:39:05 <Profpatsch> pavonia: It works when I put the tests in a different directory.
16:41:01 <geekosaur> if the call only works from inside the run loop, you'd need to do something really hacky like install a C-side SIGPIPE signal handler that schedules a call to the quit function in an idle handler and hope the signal isn't delivered while something is modifying the run queue
16:41:42 <geekosaur> (you'll get a core dump if it's done at the wrong time. no way to fix this really unless the GUI library documents a proper way to shut down its event loop from outside)
16:46:27 <yamadapc> Ok... I'm going to tick the loop from Haskell I think, that's working +/-
16:46:54 <yamadapc> finishing the higher-level bit of libui bindings 
16:49:59 <dmwit> Ticking the loop from Haskell is a good idea.
16:55:23 <asdf1010> hello guys; can somebody please help me?
16:55:36 <asdf1010> just a sec, was trying to check if shift+enter added a newline
16:56:04 <geekosaur> if this involves multi-line code examples, please use
16:56:06 <geekosaur> @lpaste
16:56:07 <lambdabot> Haskell pastebin: http://lpaste.net/
16:57:55 <asdf1010> how come if i do `case x of { a -> ... ; b -> ... }` where `a` and `b` are simple functions, it doesn't work? the first branch always gets selected. and ghc warns me about `a` and `b` hiding the existing definitions of `a` and `b`. do `case` statements introduce new bindings? what's a nice-looking alternative for such cases?
16:58:01 <enthropy> Cale: is the MaybeT package obsolete considering that transformers package has one in Control.Monad.Trans.Maybe?
16:58:27 <asdf1010> pun not intended
16:59:33 <geekosaur> asdf1010, case does not compare values, it compares patterns. "a" and "b" there are patterns which match any value and bind it to the specified name
16:59:47 <geekosaur> shadowing any existing use of that name
17:00:21 <enthropy> asdf1010: you want something to happen with the function `a` applied to `x`?
17:00:25 <ClaudiusMaximus> asdf1010: maybe you want to use guards, like  case () of { _ | x == a -> ... | x == b -> ... }
17:00:30 <asdf1010> geekosaur: hmm... but if I match against constant values, it's not like the constant `1` would get a new meaning, right?
17:00:30 <geekosaur> a "pattern" here is the structure of a type; for example, with the type (Maybe a) valid structural patterns are (Just x) and (Nothing)
17:00:51 <geekosaur> a number acts like a constructor
17:01:14 <geekosaur> (and there's some horrid compiler hackery involved that can sometimes surprise/annoy you)
17:02:23 <asdf1010> geekosaur: i was just wondering what exactly happens if on the left side i have a function; does it bind to a new body somehow? seems counter-intuitive, i would expect the function to get evaluated instead, matching against the value
17:02:33 <geekosaur> if you want to compare values, you can use (if ... then ... else ...) or you can use a dummy pattern with a guard: case () of () | x == a -> ...
17:02:54 <rhllor> i want to look through a list and return true if any element is odd and false if any is even
17:03:02 <asdf1010> ClaudiusMaximus: yeah, i saw that, just seems a bit ugly as well as nested `if`s
17:03:15 <geekosaur> they're just names at that level. you get a brand new name in the new scope introduced by `case`, unrelated to the old name
17:04:01 <geekosaur> it does not care that the name refers to a function in an outer scope
17:04:47 <geekosaur> if you mean using multiple top level functions (f 1 = ...; f 2 = ...; ...) then it's rewriting that into (f x = case x of 1 -> ...; 2 -> ...; ...)
17:05:17 <asdf1010> geekosaur: so i have to use the described dummy matching technique or nested `if`s (which seem more or less identical to me) if i want to do this, right?
17:05:23 <geekosaur> yes
17:05:36 <asdf1010> ok, thank you
17:06:23 <monochrom> there is now a "multi-way if" extension you may like
17:07:00 <monochrom> but unless you're crunching numbers, boolean conditions should be pretty rare.
17:08:05 <asdf1010> monochrom: hmm, that seems like a nice sugar, i think i use that instead
17:09:14 <asdf1010> geekosaur: yeah, i finally figured that out... so when match a number (say, `1`) against a function which returns a number (`foo`), the `case` statement just tries to bind `foo` to `1` (and successfully so), so the branch for `foo` gets picked
17:09:33 <geekosaur> yes
17:10:07 <asdf1010> seems counter-intuitive, but what doesn't, given my c-ish background
17:10:22 <asdf1010> ok, thank your guys, nice to have you here
17:10:29 <geekosaur> well, if you put the function after `case` instead of as the pattern, it should do what you expect. but you can't use an existing "variable"/name in a pattern, it will always treat it as a new name that matches anything at that point in the structure
17:11:05 <asdf1010> geekosaur: yep, finally got that, pretty cool actually
17:12:22 <lpaste> MichaelK pasted “Parser” at http://lpaste.net/2398721024154664960
19:08:09 * hackagebot happstack-authenticate 2.3.4.3 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.3.4.3 (JeremyShaw)
19:08:11 * hackagebot clckwrks 0.23.17 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.17 (JeremyShaw)
19:12:00 <adarqui> haskellnews.org should filter out "haskell" if it has SONIC / Drive Through in it.. lmfao
19:12:44 <adarqui> apparently the SONIC in haskell texas is always hiring
19:15:04 <mmachenry> lol
19:15:40 <mmachenry> That's where I work. I figured my boss would have me on a Haskell project, or at least a coding project once I proved myself.
19:16:39 <adarqui> tehe
19:20:17 <boj`> adarqui: indeed, i keep seeing job posts in my twitter feed from there and get all excited that a new haskell job opened up >.<
19:29:40 <hodapp> time to see if hmatrix-glpk actually works right. Somehow, I have avoided ever having to use linear programming.
19:40:11 <idnb> is there any good (i.e. worth studying/reading) code in haskell for 'how do I implement a simple gc for a VM" ?
20:18:38 <dd> kind peeps ... when I get a compile error like "Could not find module X", how do I find the package name to include in my .cabal file build-depends? (I use stack build to grab needed packages)
20:25:47 <athan> dd: So it didn't say "from the hidden package..." huh :\
20:25:57 <athan> Usually people here should know if its a common name
20:26:06 <athan> actually, I bet you could just google it and hackage would know
20:26:23 <athan> (iirc Hoogle should only be used for terms in the language, not modules specifically)
20:27:08 <dd> athan: sometimes it does suggest a package name, some do not
20:28:40 <glguy> It will only know the module name if the package is already installed but not listed in build-depends
20:29:04 <glguy> If the package is installed you can find it with `ghc-pkg find-module`
20:30:50 <glguy> Otherwise you can just type the module name into Google, possibly including the word Haskell
20:31:09 <dd> ok, i'll try those options - thanks
20:31:29 <dd> had trouble before with: Could not find module ‘Network.Wai’ Perhaps you meant   Network.BSD (needs flag -package-key network-2.6.2.1@netwo_A6pE0dLgMEk2GtUa1JtTJQ)   Network.URI (needs flag -package-key network-uri-2.6.1.0@netwo_8hCRgBDYvZA6nRJCSPBXws)
20:33:12 * hackagebot logentries 0.1.0.1 - Request logger middleware for Logentries  https://hackage.haskell.org/package/logentries-0.1.0.1 (toddmohney)
20:33:20 <glguy> I'd guess that was from the wai package
20:33:29 <glguy> ?hackage wai
20:33:29 <lambdabot> http://hackage.haskell.org/package/wai
20:34:40 <glguy> http://hackage.haskell.org/package/wai-3.2.1.1/docs/Network-Wai.html
20:36:37 <Mateon1> Is it possible to create a global mutable, safely?
20:36:48 <Mateon1> I know it doesn't work with IORefs, but I wonder if something exists that does
20:37:58 <nitrix> Safely, not really.
20:38:26 <athan> Shoot, does anyone know of an associative unlines?
20:38:35 <athan> > unlines [unlines ["",""], ""]
20:38:37 <lambdabot>  "\n\n\n\n"
20:38:50 <athan> Ideally I'm looking for "\n\n\n" :(
20:38:59 <athan> > lines $ unlines [unlines ["",""], ""]
20:39:00 <lambdabot>  ["","","",""]
20:39:40 <Mateon1> > unlines $ "" : ["", ""] -- @athan
20:39:41 <lambdabot>  "\n\n\n"
20:40:07 <athan> Mateon1: Of course that works, but I don't have the option of only running it once if that makes sense
20:40:17 <nitrix> Then (++) ?
20:40:57 <nitrix> Would a more concrete example help give a better recommendation?
20:41:05 <athan> hmm, maybe this law might help:
20:41:09 <athan> > unlines [""]
20:41:11 <lambdabot>  "\n"
20:41:17 <athan> should actually just be "" I think
20:41:18 <ertesx> Mateon1: "global" as in "top-level"?  i.e. in-scope everywhere?
20:41:27 <athan> actually nevermind, I'm being silly I'll think on it
20:41:29 <Mateon1> ertesx: Yes, exactly
20:42:08 <nitrix> > intercalate "\n" ["hello", "world"]
20:42:10 <lambdabot>  "hello\nworld"
20:42:14 <ertesx> Mateon1: there is the NOINLINE+unsafePerformIO hack, but there are quite a few ramifications to using it, like being per-process
20:42:26 <nitrix> athan: Is this better?
20:42:39 <athan> nitrix: I think so :s I'm not sure. Thank you though!!
20:43:10 <nitrix> @let myUnlines = intercalate "\n"
20:43:11 <lambdabot>  Defined.
20:43:33 <ertesx> Mateon1: in general write your API in such a way that it takes the mutable as an argument (myApiWith), and later, if you still thing it would be beneficial to do it, add variants that use a global mutable (myApi)
20:43:34 <nitrix> > myUnlines [myUnlines ["", ""], ""]
20:43:36 <Mateon1> ertesx: Hm, so NOINLINE saves the day... Still don't feel comfortable using that, so I guess I have no choice but pass state around
20:43:36 <lambdabot>  "\n\n"
20:44:17 <ertesx> Mateon1: passing state around is not as bad as it sounds…  people try to use all kinds of hacks to avoid it, but if you just do it, you'll quickly notice that there is nothing wrong with it
20:44:27 <nitrix> athan: Three makes no sense though. That'd mean you want only the inner list has the intercalate behavior but the outer one to have the unlines behavior?
20:44:46 <Mateon1> ertesx: I'm making a game, where I have a config argument, a state/model argument, and an input argument, for almost every function
20:45:01 <ertesx> Mateon1: then that's an argument to every function
20:45:05 <athan> nitrix: Did the trick :)
20:45:33 <athan> nitrix: It's pretty difficult to explain, sorry :\
20:45:47 <ertesx> Mateon1: really, just try it…  all it does is to make all your top-level functions start like "f cfg = …" instead of "f = do cfg <- readIORef cfgRef; …"
20:46:00 <ertesx> Mateon1: do you see what i mean? =)
20:46:14 <nitrix> athan: As long as it helped :P
20:46:29 <Mateon1> ertesx: I already pass the config around as arguments, but I find that adding more, (eg. keyboard/mouse input) is painful
20:47:01 <ertesx> Mateon1: you could use a reader monad, but a better approach may be to just make a product type for the stuff you pass around
20:47:02 <Mateon1> ertesx: Should I just create a type that contains all of the state passed aroung?
20:47:15 <ertesx> Mateon1: yeah, that may pay off
20:47:38 <Mateon1> Hm, now which module to put that in, haha
20:47:51 <Mateon1> I guess that goes into the model
20:48:25 <ertesx> Mateon1: in applications like that i tend to create up to two types:  one with actual state that changes (AppState) and one with stuff that is constant throughout the lifetime of the app/component/whatever (AppConfig)
20:58:12 * hackagebot secd 0.1.0.0 - A Haskell implementation of the SECD abstract machine  https://hackage.haskell.org/package/secd-0.1.0.0 (kseo)
21:03:13 * hackagebot language-dart 0.2.0.0 - Manipulating Dart source: abstract syntax and pretty-printer  https://hackage.haskell.org/package/language-dart-0.2.0.0 (kseo)
21:38:14 * hackagebot ltext 0.1.0 - Higher-order file applicator  https://hackage.haskell.org/package/ltext-0.1.0 (athanclark)
21:57:31 <isovector> hi there! i have some structure `data Something g a = Something (g Int a)` and am trying to substitute g with (->) and Snd
21:58:00 <isovector> is there some way if I use Snd I can get rid of the Snd constructor? 
21:58:35 <isovector> so it's just `= Something a` ?
21:59:14 <isovector> trying to avoid a bunch of annoying pattern matching
22:00:34 <glguy> You can have: data T g a = C (Apply g Int a))
22:00:51 <glguy> And define a type family Apply 
22:01:01 <ertesx> isovector: you could also use pattern synonyms
22:02:29 <slack1256> is Snd defined somewhere?
22:02:54 <isovector> slack1256: not sure, but `newtype Snd a b = Snd b`
22:03:12 <slack1256> oh, Flip Const
22:03:18 <isovector> glguy: ahh, cool. i had thought of type families but wasn't sure how to connect all the pieces
22:03:41 <ertesx> pattern SomethingSnd x = Something (Snd x)
22:05:23 <ertesx> hmm, pattern synonyms still have that weird exhaustiveness problem in GHC 8, so nevermind
22:05:38 <ertesx> (to be honest, it makes pattern synonyms almost useless)
22:06:06 <isovector> ertesx: my real code is actually significantly more involved and has a bunch more Snds than i'm letting on, but thanks for the suggestion!
22:07:30 <isovector> ahhh! lame! `Apply Snd a b = b` isn't a functor
22:08:08 <isovector> maybe pattern synonyms it is :)
22:08:15 * hackagebot wai-http2-extra 0.0.1 - WAI utilities for HTTP/2  https://hackage.haskell.org/package/wai-http2-extra-0.0.1 (KazuYamamoto)
22:09:03 <ertesx> isovector: if the choices of 'g' are very limited and not subject to extension, you could make Something itself a type family
22:09:44 <ertesx> newtype instance Something Snd a = SndSomething a  deriving (…, Functor, …)
22:10:41 <isovector> ertesx: g is only ever (->) or Snd. what is this sorcery you present??
22:12:39 <slack1256> Is there a "Prelude" for GHC.TypeLits?
22:12:54 <slack1256> the preamble mentions that that module shouldn't be used directly
22:14:49 <jle`> slack1256: Data.Singletons.TypeLits has some nice general things
22:15:05 <tieTYT> i'm using cygwin and ghcii.sh  When I press up, the cursor goes up one line.  I expect it to scroll through command history.  Can I make it do the latter?
22:15:18 <jle`> it sort of tries to lift the entire Integer interface to the type level
22:15:28 <jle`> but it's still missing some functionality here or there
22:15:34 <ertesx> isovector: if you make Something a type family (data family Somthing (f :: * -> *) :: * -> *), you can have different sets of constructors for different 'g'
22:15:42 <jle`> usuallyi just cobble together things from different libraries
22:15:44 <jerin> anyone else having issues with preview server. hakyll 4.8.3-2 
22:15:44 <jerin> Its saying recompile with flag set to true, can someone guide me on how to do that, couldn't find much documentation online
22:16:38 <ertesx> jle`: yeah, like actually lifting Integer =)
22:16:57 <isovector> ertesx: neat! is there better documentation on this stuff than the hs wiki for type families?
22:17:23 <ertesx> isovector: the GHC user guide is fine, i think
22:17:50 <ertesx> isovector: btw, is there a benefit to having this common Something type?
22:17:57 <ertesx> isovector: i mean: why not just two types?
22:18:51 <ertesx> isovector: why not even just 'a' and (Int -> a)?
22:19:14 <isovector> ertesx: Something is actually a functor to run over Free -- it's a big sum type that acts as a continuation. I want to partially evaluate the continuation pieces but keep the free structure, so that i can define catamorphisms over it
22:19:17 <jle`> ertesx, slack1256: well, just lifting integer is nice, but the need for proofs also comes up decently often, for things like ordering and stuff like that
22:19:39 <jle`> so just a straight up lifting of Integer to the type level doesn't really gain you the full benefit of nats-in-type
22:20:22 <isovector> ertesx: so now I have `apply :: Free (Something (->)) a -> Free (Something Snd) a` which gets rid of all of the continuation bits and is now a joy to work with
22:20:23 <jle`> right now most proofs involving typelits are just wrapped up unsafeCoerce's
22:20:35 <jle`> which does decently well
22:20:48 <jle`> but having them come from a library helps you pretend that they are real, heh
22:21:04 <ertesx> isovector: 'g' is currently of kind * -> * -> * for no apparent reason…  you can simplify it at least this way:  newtype Something f a = Something (f a)  -- now f = (->) Int or f = Identity
22:21:13 <tieTYT> can anyone help me with this? http://stackoverflow.com/q/38320570/61624
22:21:54 <ertesx> jle`: i mean, singletons fails at actually lifting Integer as promised
22:22:10 <jle`> ah, yes, that ^^
22:22:14 <pythonhole> this is a simple update script written in python, and I'm wondering if the haskell equivalent would be any shorter http://paste.ofcode.org/gb6MbMMyQSVMgdMXQneUaY
22:22:21 <sjl__> i bet someone is going to point out how that question isn't really best suited for stackoverflow to begin with
22:22:43 <ertesx> jle`: and it's not singletons' fault, but the weird choice not to lift Natural to a Natural kind directly
22:22:57 <sjl__> the comment n:o 2 is going to mention how it's much better suited to superuser.com because it's not really about programming but using some tool
22:23:23 <jle`> ertesx: i think that's because Natural came after Nat
22:23:32 <jle`> i could be wrong
22:23:40 <jle`> but yeah, the entire Nat situation is extremely awkward
22:23:44 <ertesx> pythonhole: unlikely
22:23:53 <pythonhole> I was hoping someone might be kind enough to show me a quick example of what that script might look like in haskell, and if I save on LoC
22:24:00 <jle`> at least singletons offers "kind-classes", so we can somewhat simulate polymorphic overloading of type level nats
22:24:05 <jle`> the same way it works at the value level
22:24:09 <ertesx> pythonhole: it will look pretty much the same, except that instead of a loop you have a fold
22:25:05 <jle`> maybe we can move the kindclass to base so it'd be standardized across libraries
22:25:30 <ertesx> jle`: i'd vote for fixing Nat, because it would have been very useful for me more than once
22:25:49 <ertesx> i ended up awkwardly bit-encoding integers just to make them promotable
22:26:10 <ertesx> (or ditch the whole machinery altogether and just use reflection where possible)
22:26:54 <slack1256> type Apply (TyFun a1627953356 (TyFun b1627953357 (TyFun c1627953358 d1627953359 -> Type) -> Type) -> Type) 
22:26:56 <jle`> scrap Nat, allow Int and Char to be promotable, and offer a kindclass mechanism for overloading integer literals
22:27:00 <slack1256> man singletons is scary
22:27:22 <jle`> slack1256: yeah, the template haskell makes things pretty awful to read, heh
22:27:35 <jle`> i don't think those are meant for human consumption
22:27:58 <slack1256> yep.
22:28:34 <ertesx> the slogan of the next version of singletons: "Make -XDependentTypes already!"
22:29:47 <isovector> ertesx: not entirely sure what you're suggesting by the newtype. here's what i'm actually doing, if you're interested: https://gist.github.com/isovector/445b898752bd9e6ee5162650b0b5cb87
22:30:07 <jle`> i don't know if there's ever going to be natural dependent types in haskell
22:30:35 <jle`> separation of the type and term level is too fundamental to break, i feel
22:31:14 <ertesx> isovector: side note: i like to define extra types for existential parts of a functor in order to preserve -XDeriveFunctor automation
22:31:21 <jle`> we went from having terms, types, kinds, sorts to just terms and types, collapsing types/kinds/sorts into one thing
22:31:50 <jle`> but i don't know if it will ever make sense for haskell to collapse terms and types in a natural way
22:31:58 <slack1256> why do we even want Dependent types on a general programming language?
22:32:06 <ertesx> jle`: we have -XTypeInType now, and the type language is basically as powerful as the term language…  we're close to being able to merge them
22:32:37 <jle`> slack1256: stronger types helps guide you when implementing programs, also you get verification, safety, stuff like that
22:32:37 <ertesx> slack1256: because it makes certain abstractions delightfully easy to express as well as express the intention of an API through the types
22:32:42 <slack1256> It makes sense to a language that doubles as a Proof assistant. Branching on types is done with Gadts already
22:33:15 <slack1256> the most succesful Type-level trickery seems to be Servant
22:33:23 <jle`> i'm in a middle of a blog series about how dependent types helps me implement a toy neural network in haskell
22:33:29 <slack1256> yet that doesn't needs "arithmetic" at type-level
22:33:37 <slack1256> *need
22:33:37 <ertesx> slack1256: for example instead of checking whether a user is currently logged in, a function takes a proof that they are…  that not only makes the run-time more efficient, but also helps prevent bugs and security holes
22:33:41 <jle`> it's sort of the same things you'd get when writing a normal haskell program vs a dynamically typed one
22:33:46 <jle`> GHC helps you write your programs for you
22:33:58 <jle`> things just...fit together, writing programs is fun again
22:34:08 <ertesx> slack1256: and the more the compiler knows about your code, the more code it writes for you
22:34:31 <slack1256> I don't think that is really true
22:34:36 <jle`> most of the reasons why you'd recommend haskell's type system over a dynamic language can also be applied to why you'd want dependent types over haskell
22:34:38 <slack1256> I mean, in a hand-wavy way yes
22:35:09 <jle`> your declaration that it isn't really true won't stop me from continuing to enjoy the benefits every day :)
22:35:23 <ertesx> slack1256: the reason you're not seeing more wonderful type-level stuff in haskell is that it's just not practical enough
22:35:29 <jle`> i've been using dependent types in my haskell for months now and programming is a lot more of a breeze
22:35:32 <jle`> compilers write my programs for me
22:35:36 <slack1256> Probably
22:35:36 <jle`> i get verification, better documentation, etc.
22:35:43 <ertesx> singletons are awkward and noisy to use, and code written them is awfully hard to understand
22:36:30 <ertesx> slack1256: if you want to get a taste of what is possible, look at what idris already does today
22:36:52 <jle`> besides, even in dependently typed languages, you can always choose the level of type-power that you want to work in
22:37:13 <jle`> so if extra power helps you today, you can use it, and if it doesn't, you can forego it
22:37:17 <ertesx> jle`: until you can't anymore =)
22:37:39 <jle`> i don't follow :o
22:37:40 <slack1256> I guess people put defensive on this one
22:38:15 <ertesx> jle`: if dependent types are introduced in 2020, "i don't want to use dependent types" in 2026 could mean "i don't want to use the majority of libraries on hackage" =)
22:38:52 <slack1256> What I don't like about idris is the term construction is really related to the proof construction. So sometimes I am obliged to do something in non efficient ways because I can satisfy the totality checker easier that way
22:40:19 <ertesx> slack1256: that's more a design choice of the API, not the language…  there is a "prove later" idiom, too
22:40:48 <ertesx> slack1256: IMO that one is also the better idiom, because it makes APIs more flexible
22:41:07 <isovector> ertesx: glguy: thanks for your help!
22:42:53 <ertesx> "prove now": nthPrime :: Int -> Prime  -- where a Prime is an integer with a primality proof…  you get a proof whether you asked for it or not
22:43:34 <slack1256> Nice!
22:43:36 <ertesx> "prove later": nthPrime :: Int -> Integer;  nthPrimeIsPrime :: ∀ x. IsPrime (nthPrime x)
22:47:29 <Tea7ime> Hello?
22:47:36 <Axman6> Hello!
22:48:40 <davidthomas> Hi!
22:48:49 <slack1256> Hello from the other sideeeeeee
22:54:43 <eklavya> I hit a problem, if I use different names for records, I can't auto generate json serial/deserialization anymore because the field names won't match
22:54:50 <eklavya> what to do?
22:54:56 <tnks> Can I make a function of this type?  Typeable a => TypeName a  -- where newtype TypeName a = TypeName Text
22:55:35 <tnks> I can use typeRep easily enough for monomorphic calls, but not sure if this is possible.
23:02:26 <ThreeOfEight> tnks: I don't see why not.
23:03:25 <srhb> eklavya: More modules, I guess.
23:03:30 <srhb> eklavya: Or hack it out with TH.
23:03:39 <srhb> eklavya: The first solution is probably easiest. :)
23:03:55 <eklavya> srhb: more modules?
23:04:00 <eklavya> oh
23:04:08 <eklavya> so it's only visible in the same file?
23:04:26 <srhb> eklavya: You can import them qualified wherever you use them.
23:04:34 <eklavya> oh yes
23:04:43 <eklavya> thanks you so much srhb :P
23:04:48 <srhb> eklavya: No problem.
23:05:55 <ThreeOfEight> @type (\x -> Data.Text.pack (showsTypeRep (typeOf x) []))
23:05:56 <lambdabot> Typeable a => a -> Data.Text.Internal.Text
23:06:12 <ThreeOfEight> tnks: This is what you want, isn't it? Modulo the TypeName constructor.
23:06:59 <tnks> ThreeOfEight: it works well enough when I have an instance of the type, but in this case I have in front of me, I don't have an instance.
23:07:21 <alercah> tnks: use Proxy?
23:07:25 <tnks> which is why I made the phantom type.
23:07:31 <tnks> alercah: I tried to use Proxy.
23:07:45 <ThreeOfEight> Well, what type are you putting in?
23:08:01 <ThreeOfEight> You will require a "Typeable a" instance.
23:08:22 <tnks> typeRep (Proxy :: Proxy a) -- given a Typeable a
23:08:50 <alercah> tnks: you would have typeRep :: (Typeable a) => Proxy a -> TypeName a
23:08:52 <ThreeOfEight> so by "instance" you meant "value"?
23:09:14 <tnks> but I got:  Could not deduce (Typeable a0) arising from a use of `typeRep'
23:13:05 <jle`> ertesx: ah, i was referring to having types with different levels of power
23:14:34 <jle`> like idris's base has three lists:  a list with no information about the type of values inside, a list with information about the values of types inside (Haskell's [a]), and a list with types and also the number of elements in its type
23:14:57 <ThreeOfEight> @type (\x -> Data.Text.pack $ showsTypeRep (head . snd . splitTyConApp . typeOf $ p) [])
23:14:57 <exio4> what's that first one? oO
23:14:58 <lambdabot> r -> Data.Text.Internal.Text
23:15:08 <ThreeOfEight> er
23:15:31 <ThreeOfEight> (\(p::Proxy a) -> Data.Text.pack $ showsTypeRep (head . snd . splitTyConApp . typeOf $ p) []
23:15:36 <ThreeOfEight> @type (\(p::Proxy a) -> Data.Text.pack $ showsTypeRep (head . snd . splitTyConApp . typeOf $ p) [])
23:15:37 <lambdabot> forall (k :: BOX) (a :: k). (Typeable a, Typeable Proxy) => Proxy a -> Data.Text.Internal.Text
23:15:53 <ThreeOfEight> something like that anyway
23:15:56 <EvanR> jle`: hrm... i see regular list, vector (length indexed), and Stream
23:16:09 <EvanR> but not list with no information about elements
23:16:18 <exio4> a list without the information of the elements seems quite useless too
23:16:36 <ThreeOfEight> tnks: this just gets the typerep of the proxy and deconstructs it to get the typerep of the original type variable
23:16:47 <EvanR> exio4: Nat :D
23:17:06 <exio4> well, sure :p
23:17:24 <jle`> EvanR: hm, the book lists "AnyList", "List a", and "Vect n a"
23:17:31 <exio4> I mean, as lists!
23:17:36 <EvanR> i sort of remember that
23:17:41 <EvanR> but AnyList is not a real thing
23:17:56 <jle`> aw
23:18:09 <jle`> oh yeah, that's in the notes
23:18:27 <EvanR> much to the dismay of dynamically type minded coders!
23:19:15 <jle`> my idea of AnyList wouldn't be a heterogenous list, actually
23:19:23 <jle`> it'd be a homogeneous list but with the type hidden
23:19:38 <EvanR> how would you guarantee it is homogeneous?
23:19:42 <exio4> so (∃a.List a)
23:19:51 <EvanR> ah
23:19:58 <jle`> data AnyList where AnyList :: {a} -> List a -> AnyList
23:19:59 <EvanR> im not sure how you would do that in idris
23:20:02 <exio4> vs (List (∃a.a))
23:20:04 <EvanR> oh
23:20:22 <exio4> remember the type is a value
23:20:45 <EvanR> newtype AnyList = forall a . MkAnyList [a]
23:21:07 <jle`> you can get something similar in Haskell with data AnyList = forall a. AnyList (Sing a) [a]
23:21:08 <EvanR> brilliant
23:21:19 <jle`> or MkAnyList :: Sing a -> [a] -> AnyList
23:21:26 <EvanR> whats the Sing for
23:21:35 <jle`> so you can pattern match to get the type back out
23:21:42 <EvanR> wut o_O
23:21:44 <ThreeOfEight> tnks: a more direct way would be to do "typeRep (undefined :: a)". But then you have to give the type of the function as "forall a. Typeable a => Proxy a -> String" and enable ScopedTypeVariables
23:22:32 <shachaf> Is there anything you can only write with ScopedTypeVariables?
23:22:37 <ThreeOfEight> Not sure which of these two ways is less ugly. In my opinion, "typeOf" should take a Proxy to begin with.
23:22:49 <ThreeOfEight> shachaf: I should think so.
23:22:59 <shachaf> I don't know any examples.
23:23:25 <jle`> i think there was a discussion here and it was concluded that there isn't anything that scoped type variables lets you implement that wasn't implementable before
23:23:46 <ThreeOfEight> well in this case you could use asProxyTypeOf
23:23:51 <jle`> scoped type variables just makes some things a little cleaner
23:24:01 <jle`> but it's mostly cosmetic in that sense
23:24:42 <ThreeOfEight> you may need auxiliary functions without it though, don't you?
23:25:04 <alercah> there are functions in where/let that you cannot type without scoped type variables
23:25:06 <jle`> yes, but auxillary functions are a part of normal haskell
23:25:08 <alercah> *explicitly type
23:25:24 <jle`> alercah: do you mean like type with a keyboard, or specify their typess?
23:25:37 <alercah> jle`: the latter
23:25:38 <ThreeOfEight> Well, okay. But this means you need to use a completely different structure in your program to achieve the same thing.
23:25:51 <jle`> yeah, that's what i was saying
23:25:57 <jle`> scoped type variables lets you do it a little bit cleaner
23:26:08 <jle`> but it doesn't enable any functionality that wasn't previously unavailable without it
23:26:12 <jle`> *any new programs
23:26:15 <alercah> sure
23:26:18 <alercah> but neither do most features
23:26:30 <jle`> um
23:26:36 <alercah> you don't even need type classes
23:43:12 <adarqui> anyone here use stack to compile reflex apps without ghcjs compiler? ie, just using normal ghc
23:43:48 <kadoban> Occasionally, though mostly I just ghcjs.
23:45:15 <adarqui> cool. without ghcjs, i have to have gtk libraries installed huh? lots of gtk stuff
23:45:37 <adarqui> basically, i want this setup: ./library (using ghc), ./app which depends on ./library and builds using ghcjs
23:45:48 <adarqui> so id like to develop 'library' using ghci/ghc
23:46:02 <adarqui> and then just turn to ./app and build with ghcjs when i'm ready to build the web version of it, and compile to js
23:46:05 <adarqui> makes sense?
23:46:55 <kadoban> Yeah, though the library doesn't really choose what compiler builds it.
23:47:18 <adarqui> right
23:47:23 <kadoban> And yeah you have to have webkitgtk for most stuff at least, ya. I forget what all I had to install in terms of OS libraries for that, it was minorly annoying IIRC.
23:47:30 <adarqui> i just want to use ghc/ghci because it's "faster"
23:47:45 <adarqui> ya it's been annoying so far
23:47:52 <adarqui> but once i get it i imagine i'll be good for a while
23:47:59 <adarqui> just glad u got it done.. proves it can be done......... lol
23:48:26 <kadoban> Yeah it's been a while since I did it, heh, and it's still working. I actually have a new computer I need to set up eventually that I'll have to work it out again :-/
23:49:01 <adarqui> ya.. stuff like this sux. just want to code ;f
