00:00:19 <heebo> oh thanks ... perhaps its my tests .....hmmmm
00:00:32 <heebo> will investigate cheerio. and thanks
00:00:50 <ridecar2> Robot diagram made sense!
00:01:27 <EvanR> :t (+)
00:01:29 <lambdabot> Num a => a -> a -> a
00:01:57 <julianleviston> ridecar2: :partyparrot:
00:03:19 <ridecar2> If I were to want to do something as silly as building a type that met all the constraints to be in the class of Num then could I add it to the typeclass? Am I even making sense here?
00:03:28 <julianleviston> EvanR: hey EvanR you might know … is there any way to convince Hint to load multiple modules from a single String rather than disk?
00:03:31 <pavonia> julianleviston: Re RWH, yeah, doesn't work for me too, but not sure if it is a temporary problem or if that subdomain is down permanently
00:04:10 <EvanR> ridecar2: you can make a type an instance of Num by implementing +, fromInteger et
00:04:13 <EvanR> etc
00:04:29 <SAL9000> ridecar2: instance Num YourType where + = ... etc.
00:04:51 <EvanR> julianleviston: nope
00:04:56 <julianleviston> ridecar2: yeah… then you “wire it up” by marking it an instance, as SAL9000 just wrote above… and writing out your implementation as EvanR  said.
00:04:58 <EvanR> i do not know hint
00:05:28 <julianleviston> EvanR: I thik it’s a limitation of GHC… each module has to be in a File.
00:06:11 <julianleviston> ridecar2: so you can see that a type can be in many classes at once…
00:06:30 <EvanR> ridecar2: you can think of Num a => being a contraint on what `a' can be. but practically it helps me to think of the Num a as being an invisible argument, the collection of operations to use, a dictionary of functions
00:06:44 <ridecar2> Sounds good to me, still looking like interfaces at the moment.
00:06:53 <EvanR> this explains why sometimes it fails to compile because it doesnt know which one to use from context
00:06:55 <julianleviston> ridecar2:  EvanR  is now talking about polymorphic values.
00:07:57 <EvanR> like this
00:08:00 <EvanR> :t read
00:08:01 <lambdabot> Read a => String -> a
00:08:02 <julianleviston> ridecar2: in other words, your VALUES can be interfaced, too...
00:08:15 <EvanR> > read "1984"
00:08:17 <lambdabot>  *Exception: Prelude.read: no parse
00:08:22 <EvanR> gr
00:08:51 <EvanR> if it didnt default to a = (), it would have failed with "a is ambiguous"
00:09:04 <ridecar2> Talking of polymorphism - if I define a function that could sensibly work with 2 different typeclasses then could I use it with both or would Haskell moan at me?
00:10:10 <EvanR> its not a good idea to name methods in different type classes the same thing
00:10:35 <julianleviston> ridecar2: a function can easily use multiple types in it…. 
00:10:39 <julianleviston> ridecar2: no moaning.
00:11:34 <julianleviston> ridecar2: oh maybe I misunderstood what you were wasking
00:11:37 <julianleviston> asking*
00:11:42 <EvanR> me neither
00:12:28 <ridecar2> Let's say that I have two types that share some common part of their structure, then could I write one function that could be given either type and do the right thing or would I have to write a function for each type even though it would be the same function?
00:12:30 <EvanR> ridecar2: when you use operations from a type class, its from one particular class, you decide
00:13:11 <julianleviston> ridecar2: that’s exactly what Functor is. 
00:13:12 <EvanR> now it sounds like youre talking about record subtyping
00:13:45 <EvanR> you cant really do that in haskell, but there are extensible record libraries
00:13:50 <ridecar2> That sounds like it to me, @EvanR
00:14:47 <EvanR> you can do it in so many words simply by mapping which ever types you want to a record which has the common structure
00:14:52 <EvanR> and your function operates on that
00:15:20 <EvanR> basically doing the implicit conversion subtyping offers explicitly
00:15:30 <julianleviston> EvanR: that’s sort of what Aeson does for JSON, right?
00:15:38 <EvanR> no
00:15:41 <julianleviston> oh. :)
00:16:20 <julianleviston> EvanR: oh I see what you mean… the “common” record has all the structure in it…
00:16:31 <EvanR> it has only the common structure
00:16:35 <julianleviston> yep.
00:16:36 <EvanR> the common fields
00:16:48 <julianleviston> all the structure required for the application of the function
00:16:49 <ridecar2> I like your thinking EvanR - so map from a -> common and from b -> common - then do everything that I can on common?
00:16:55 <EvanR> right
00:17:50 <EvanR> each part of your code is expecting a certain interface, and you put this information into types rather than into algorithms to avoid the type system
00:17:55 <ridecar2> Also - would you recommend the haskell platform for a poor Windows user?
00:18:55 <EvanR> i cant say whats good on windows, but i never went wrong just installing GHC, then cabal-install, then installing the rest through cabal install
00:20:08 <julianleviston> I really like stack… http://docs.haskellstack.org/en/stable/README/
00:20:20 <julianleviston> Only ever tried it on OS/X tho.
00:22:39 <ridecar2> Thank you julianleviston - trying stack now
00:23:07 <julianleviston> ridecar2: worth noting that stack uses cabal, but manages it for you.
00:24:41 <ridecar2> Soudns good to me, looks very simple.
00:24:49 <ridecar2> I'm liking this
00:29:39 <ridecar2> Just running 'stack setup' now
00:29:44 <ridecar2> :t print
00:29:46 <lambdabot> Show a => a -> IO ()
00:30:31 <ridecar2> Does that mean print takes anything in the typeclass Show and returns an IO action?
00:30:56 <ridecar2> Then it's the IO action that does the impure output?
00:32:04 <EvanR> yes
00:32:48 <EvanR> IO actions are normal values, you can pass them around and store them in containers
00:33:19 <EvanR> print is thus a normal (pure) function
00:34:08 <ridecar2> How can print be pure though if when I use it I get a side effect?
00:34:21 <EvanR> you dont get a side effect, you can an IO action
00:34:24 <ridecar2> (This is now where my brain melts)
00:34:27 <EvanR> you get an*
00:34:42 <Maxdamantus> > length [print "foo", print 4]
00:34:43 <lambdabot>  2
00:34:48 <Maxdamantus> Where are the side effects?
00:34:57 <ridecar2> > print "foo"
00:34:59 <lambdabot>  <IO ()>
00:35:04 <julianleviston> ridecar2: read this… http://www.happylearnhaskelltutorial.com/1/main_road.html
00:35:19 <ridecar2> When I do that in GHCi I get a side effect
00:35:31 <EvanR> ghci takes the liberty of executing any IO action you compute
00:35:32 <Maxdamantus> Because ghci doesn't just evaluate Haskell expressions.
00:35:42 <Maxdamantus> It also runs IO values.
00:35:42 <EvanR> same thing happens when you compile and execute main :: IO ()
00:36:21 <EvanR> lambdabot doesn't for security reasons
00:36:31 <EvanR> and general sanity
00:36:58 <EvanR> the idris REPL by constrast shows the IO value as is, and you need to :exec it to make it execute
00:38:40 <ridecar2> Ahhh - so my passing around of IO actions and the execution of them are decoupled? GHC and GHCi just fire them off for me whenever they see one?
00:39:02 <EvanR> main is the only IO action that gets executed normally, when you run the program
00:39:22 <julianleviston> ridecar2: nice :) yep. 
00:39:24 <EvanR> ghci also executes IO actions if that is the result
00:39:38 <EvanR> for convenience
00:40:13 <EvanR> main is usually a very complex IO action made by combining a bunch of smaller ones with fmap, >>=, <*>, and other stuff
00:40:38 <julianleviston> ridecar2: when you write code, you’re manipulating pure Haskell expressions - some of which can be descriptions of what to do with “side-effects”. When the compiler executes that code, the “side effects” happen. 
00:40:59 <ridecar2> Now that makes perfect sense! I think...
00:41:11 <julianleviston> whoa! :)
00:41:13 <julianleviston> cool. :)
00:41:13 <EvanR> yeah, you can do this in any language, and its sometimes useful
00:41:29 <julianleviston> ridecar2: that’s very exciting :)
00:41:31 <EvanR> you make a structure of actions to execute, and process them somehow before actually doing them
00:41:43 <EvanR> haskell just makes its really easy
00:42:02 <julianleviston> ridecar2: it’s nice when you learn things in the right order, because things are *so* easy.
00:42:18 <ridecar2> So a very simple view of an IO action would be that it's a recipe that I make and the compiler goes and does it for me?
00:42:26 <EvanR> right
00:43:02 <EvanR> well the compiler just outputs the code, the runtime system executes the actions
00:43:10 <ridecar2> Saving me from having to do the .Execute() part that I have to do in C# (and often forget... grr... so many hours debugging that mess up)
00:43:29 <julianleviston> ridecar2: lol… what’s monads all about? Composing and manipulating actions. What’s monoid? Smashing things together… what’s Functor? applying a function over some structure to the content contained with it. What’s a typeclass? Kind of like an interface, but works on values as well as types… specifies a bunch of functions that will be implemented on the type for it to be a member. 
00:44:05 <EvanR> hrm...
00:44:09 <ridecar2> Let me guess... laziness makes it all the much nicer?
00:44:09 <julianleviston> WRONG! :)
00:44:23 <julianleviston> ridecar2:  sometimes.
00:44:28 <EvanR> laziness really lets you stop thinking so much...
00:44:44 <julianleviston> EvanR: feel free to correct anything I say, hopefully you do anyway :)
00:45:12 <EvanR> with laziness you can easily create new control structures which require weird language features otherwise
00:45:30 <ridecar2> I have to say - thank you so much for being on here and fielding my, possibly inane at times, questioning.
00:45:32 <julianleviston> EvanR: yeah, or that require macros in other langauges
00:46:03 <julianleviston> EvanR:  haha I suppose macros are weird language features? :)
00:46:15 <EvanR> definitely
00:46:28 <julianleviston> ridecar2: you’re very welcome.
00:47:06 <julianleviston> ridecar2: I don’t know about EvanR but it helps me because I get to understand how people learn… and learn more myself each time I explain thing, and hear others explain things.
00:47:07 <ridecar2> I'm tempted now to do a short video for youtube explaining what you guys have explained to me, or maybe a stream of me learning more things
00:47:33 <ridecar2> Going to have to change computers though so will be back shortly.
00:47:39 <EvanR> whatever you do, dont make a monad tutorial
00:47:44 <julianleviston> lol yeah.
01:04:12 <Cooler1> http://espedito.homepc.it/ Hi to all...)
01:08:19 * hackagebot digit 0.2.8 - A data-type representing digits 0-9 and other combinations  https://hackage.haskell.org/package/digit-0.2.8 (TonyMorris)
01:13:20 * hackagebot neat-interpolation 0.3.2.1 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.3.2.1 (NikitaVolkov)
01:33:49 <anykey> I'm working on the 99 haskell questions, and I am at the function elementAt, which I declared elementAt :: Integral b -> [a] -> b -> a. My question is: I can't pattern match something like elementAt (x:xs) b > 0 = ..., can I...?
01:34:29 <anykey> oh wait.
01:35:29 <anykey> never mind, I reordered the steps. sorry.
01:38:04 <anykey> is there something like Integral which only allows positive integers?
01:40:03 <julianleviston> anykey: Nat, but you probably don’t want that.
01:40:40 <julianleviston> anykey: sorry that’s not very helpful. I’d say “not really, according to my knowledge, which isn’t vast"
01:40:50 <anykey> I don't want that?
01:41:17 <julianleviston> Well… it’s not a normal number 
01:41:54 <julianleviston> and it can be a bit cumbersome to work with.
01:42:29 <anykey> hmm. I might come back to that later, for now I am satisfied that the function works as long as no one tries to get a negative index
01:42:52 <anykey> oh, actually, I could reverse the list if that happens.
01:42:54 <julianleviston> anykey: well you can always capture that case and return an empty kind of value
01:43:16 <anykey> an empty kind of value? Does Haskell have something like null?
01:43:25 <julianleviston> anykey: for list, it’s [], right?
01:43:26 <anykey> I'm totally new to this stuff, sorry
01:43:30 <julianleviston> anykey: all good! :)
01:43:33 <anykey> but I don't want to return a list
01:43:46 <julianleviston> anykey: oh you’re returning a number… right… 
01:43:47 <anykey> if I do, the type signature is just plain wrong
01:43:53 <julianleviston> anykey:  the number has no such thing.
01:44:26 <anykey> oh well I will allow indexing from the end of the array in reverse on a negative number
01:44:36 <anykey> it's like python does it
01:44:45 <julianleviston> anykey:  hehe :) ok. What happens if they do an index out of bounds on the other end?
01:45:18 <anykey> hmm, if the index is out of bounds, you invariable get the last element
01:45:26 <anykey> in that case, you will get the first element
01:45:31 <julianleviston> elementAt [1,2,3] 5000
01:45:43 <julianleviston> ok and what happens with this? elementAt [] 5 ?
01:45:56 <julianleviston> (ie there’s no first or last element)
01:46:24 <julianleviston> What’s the function supposed to do? throw up its hands and error?
01:46:28 <julianleviston> or didn’t they say?
01:46:49 <julianleviston> I’ll look it up one sec
01:47:12 <anykey> they didn't say
01:47:18 <anykey> it's just the first problem
01:47:39 <julianleviston> Ah ok.
01:47:43 <julianleviston> Problem 3 isn’t it?
01:48:15 <julianleviston> the first problem is “find the last element of a list”
01:48:21 <julianleviston> :t last
01:48:22 <lambdabot> [a] -> a
01:48:44 <julianleviston> The trouble is, that’s not a total function, meaning it’s possible to break it. This is generally not the best thing in the world.
01:48:52 <julianleviston> So long as you realise that, though, it’s ok.
01:49:24 <julianleviston> In other words, for some inputs, what it should do is undefined. (Such as what it should do with an empty list)
01:49:42 <julianleviston> if we use this function in a program, certain data will make the whole program crash, and this is bad.
01:49:48 <anykey> https://wiki.haskell.org/99_questions/1_to_10
01:49:57 <anykey> problem 3 is find the K'th element of a list
01:50:24 <anykey> and of course I didn't use the built-in last function
01:50:34 <julianleviston> oh ok.
01:50:40 <anykey> I used recursion to match the last element of the list.
01:51:00 <anykey> like (x:[]), but I was corrected to [x]
01:51:59 <julianleviston> myLast [] = error ; myLast [x] = x ; myLast (_:xs) = myLast xs 
01:52:00 <julianleviston> like that?
01:52:26 <anykey> yes, like that, except I don't have an error clause
01:52:36 <julianleviston> ok. it’ll error anyway...
01:54:09 <julianleviston> anykey: so I generally recommend when beginning to think about recursion, you break the possible cases up… and do them one by one
01:54:44 <anykey> yes, but that's not the problem here, sorry. 
01:54:49 <julianleviston> oh sorry
01:54:58 <julianleviston> what is?
01:55:22 <julianleviston> you want a type that has only pos integers?
01:55:26 <anykey> I just don't know what to do when someone goes out of bounds without resorting to the length function to get the maximum index, which I actually want to avoid
01:55:35 <anykey> no, negative integers is fine
01:55:40 <julianleviston> ah ok
01:55:58 <anykey> and I don't know what to do when the list is empty, because I can't just not return anything
01:56:05 <julianleviston> well that’s one of your cases, right? out of bounds. What do you want to do when it’s out of bounds?
01:56:12 <julianleviston> Well, like I said, pick them off one by one.
01:56:21 <julianleviston> choose either out of bounds or empty list, and do that first.
01:56:45 <anykey> I'm gonna say "never mind" 
01:56:50 <julianleviston> if it’s empty list, well, it has to return an element… so we can’t encode it into the types.
01:56:55 <julianleviston> so you *have* to write error.
01:56:57 <julianleviston> oh ok.
01:57:04 <anykey> mu description is: and I don't know *what to do*  when ...
01:57:10 <anykey> it's not a case by any means
01:57:17 <anykey> I can match these things
01:57:20 <julianleviston> sorry for using the wrong words.
01:57:36 <julianleviston> All I was saying is we have to pick one first. So I picked empty list for you.
01:57:50 <anykey> so, elementAt [] k = ...?
01:58:00 <julianleviston> yeah, elementAt [] _ = … ?
01:58:07 <anykey> that's my whole problem, the function doesn't work then
01:58:11 <julianleviston> For empty list, you *have* to write error… because your type is “a”, right?
01:58:13 <julianleviston> yep.
01:58:15 <julianleviston> spot on
01:58:24 <julianleviston> it’s impossible
01:58:32 <anykey> so I'd have to limit this to nonempty lists, which I don't know how to do
01:58:40 <julianleviston> so you either change the types so it *does* make sense, or not.
01:58:42 <julianleviston> You can't.
01:58:52 <julianleviston> Haskell doesn’t have dependent types (which is what that is)
01:59:17 <anykey> well, then the exercise isn't thought out very well.
01:59:34 <anykey> Or maybe it is thought out quite well, because it makes me ask questions and see problems.
01:59:36 <julianleviston> dependent types are types where data informs the types
01:59:44 <julianleviston> anykey: it’s for Lisp.
01:59:51 <julianleviston> ;-)
01:59:56 <anykey> I've actually done Lisp before, though not for a while.
01:59:59 <anykey> 2006 I think.
02:00:05 <julianleviston> anykey: it’s good to think about it.
02:00:12 <anykey> whoa, that's TEN YEARS ago
02:00:14 <julianleviston> anykey: in this case, I’d return a wrapped value.
02:00:17 <julianleviston> anykey: hehe :)
02:00:33 <julianleviston> myLast :: [a] -> Maybe a
02:00:43 <julianleviston> But I don’t know if you’ve done Maybe yet.
02:00:51 <anykey> no I haven't
02:01:00 <julianleviston> anykey: do you want to?
02:01:02 <anykey> I just noticed I am getting old.
02:01:08 <julianleviston> anykey: haha me too :)
02:01:17 <anykey> that's the "presence or absence of a value"-Monad.
02:01:28 <anykey> I've done Maybe, but not in Haskell.
02:01:36 <julianleviston> anykey: just ignore the monad part...
02:01:56 <julianleviston> anykey: the important thing is it represents a value of a type, or no value of that type.
02:02:12 <julianleviston> anykey: so… this gets a bit tricky sounding, but the FULL type becomes Maybe Int
02:02:30 <julianleviston> which means “a type that can have values of NO INTS or values of Int"
02:02:37 <julianleviston> sounds like you already know it.
02:02:55 <anykey> yes, but I don't know the syntax and I think Haskell does it quite differently
02:02:57 <julianleviston> no ints is called Nothing. The number 7 would be called Just 7. Etc.
02:03:06 <anykey> ah
02:03:22 <anykey> sounds almost like my JavaScript implementation last week, which blew several minds...
02:03:44 <julianleviston> Just 7 is one single value… but its type is Maybe Int (one single type, composed of a “wrappering type called Maybe, and the inner type called Int”)
02:03:47 <anykey> Wrapper.wrap() returning Wrapper, Wrapper.map() returning either Wrapper() or Nothing()
02:03:56 <julianleviston> lol :)
02:04:18 <julianleviston> so we can replace error with our Nothing value, and then we get to return Just Int as the type.
02:04:31 <julianleviston> myLast :: [a] -> Maybe a
02:04:48 <anykey> ah I see
02:04:57 <julianleviston> myLast [] = Nothing ; myLast [x] = x ; myLast (_:xs) = myLast xs
02:05:27 <anykey> yes, that's what I storm-typed in while you typed it here
02:05:35 <anykey> great
02:05:50 <anykey> the concept was familiar, but the syntax wasn't.
02:05:54 <anykey> Thanks!
02:06:00 <julianleviston> Then later when you need to get the number out, you can decide what to do with the Nothing case…. maybe if you’re multiplying it by 1000, you want to use the number 1 for example, so that it has no effect on the multiplication.
02:06:04 <julianleviston> no problem! :)
02:06:37 <anykey> how do I get at the number in a just?
02:06:43 <anykey> like, how do I unwrap?
02:06:46 <julianleviston> you can use a case … 
02:07:24 <julianleviston> case maybeVal of ; Just x -> x ; Nothing -> 0
02:07:28 <julianleviston> something like that…
02:07:32 <anykey> oh
02:07:41 <julianleviston> if you want 0 as your Nothing.
02:07:43 <anykey> can I pattern match this?
02:07:51 <julianleviston> Yeah, that’s pattern matching
02:08:12 <julianleviston> The Just x part pattern-matches the inner part (as x) and the outer part (the Just part).
02:08:15 <anykey> like, anotherFunc Just x = ....?
02:08:24 <julianleviston> Oh yeah, sure. :)
02:08:30 <liste> anykey: anotherFunc (Just x) = ...
02:08:30 <anykey> and anotherFunc Nothing = ...
02:08:35 <julianleviston> but you need bothe cases yep :)
02:08:40 <anykey> ah, parentheses required
02:09:01 <anykey> I get it. I think. As far as I can make that statement. Maybe (pun intended) this is all there is to it.
02:09:12 <julianleviston> lol
02:09:24 <julianleviston> well, just so you know, the danger is I just showed you something not basic… 
02:09:54 <anykey> you mean I might use things I am not supposed to to answer the questions?
02:10:09 <liste> I think pattern matching is pretty much as basic as it gets
02:10:29 <julianleviston> liste: ah I was talking about algebrac data types & Maybe.
02:10:52 <anykey> like the built-in last function, I will not overdo it. I will tackle the problems meant to be tackling, though that question probably should have "don't worry about empty lists and out of bounds or negative indexing"
02:11:00 <anykey> but then people wouldn't see the problem
02:11:19 <julianleviston> anykey:  yeah that’s cool :) use error, but realise it’s not good, that’s all
02:11:21 <liste> all Haskell's data types are pretty much algebraic (apart from ints, chars, floats), so I'd say they're pretty basic too
02:11:31 <liste> lists are algebraic too
02:11:39 <julianleviston> liste: massively disagree for this conversation :)
02:11:52 <julianleviston> liste: yes, everything is in truth. This isn’t helping this person in this case.
02:11:55 <anykey> liste: I don't know what that is yet, so I won't comment.
02:13:12 <liste> it's just a fancy-sounding name for a very simple concept
02:13:26 <liste> don't worry about it
02:13:28 <julianleviston> true true :)
02:14:53 <samanths> hi
02:14:53 <anykey> good
02:15:50 <julianleviston> liste: sorry that was a bit rude of me.
02:15:57 <julianleviston> samanths: hi
02:16:01 <samanths> why does haskell have so many ridiculous error messages?
02:16:08 <liste> > maybe 4 id (Just 20) -- there's also a function for getting stuff out of maybes if you prefer that
02:16:09 <lambdabot>  20
02:16:14 <anykey> Thanks again for bearing with me through this. I will correct the solutions that are now solvable with this.
02:16:15 <liste> > maybe 4 id Nothing
02:16:16 <lambdabot>  4
02:16:31 <liste> but I think pattern matching is more basic
02:16:42 <julianleviston> liste: yeah, fair enough :)
02:17:04 <julianleviston> samanths: I’m not sure how to answer that. Anything in particular?
02:17:07 <liste> julianleviston: I don't think you were rude
02:17:22 <julianleviston> liste: I’m glad :)
02:19:00 <anykey> I've not seen anything "ridiculous" in Haskell errors yet. C++ compiler messages tended to be ridiculous because of the templates often involved (you need a parser to "get" what the compiler is actually complaining about)...
02:19:20 <samanths> really anykey
02:19:40 <julianleviston> samanths: can you give any example?
02:19:46 <julianleviston> > + 3 (
02:19:47 <lambdabot>  <hint>:1:1: parse error on input ‘+’
02:19:51 <julianleviston> Something like this ? 
02:21:13 <samanths> suppose you meant to type 1 + 1, but you missed the + key and accidentally typed 1 1 instead
02:21:39 <samanths> haskells error messages is just retarded
02:21:51 <julianleviston> > 1 1
02:21:52 <lambdabot>      Could not deduce (Num a0)
02:21:52 <lambdabot>      from the context (Num a, Num (a -> t))
02:21:52 <lambdabot>        bound by the inferred type for ‘e_111’: (Num a, Num (a -> t)) => t
02:22:03 <samanths> it thinks you are attempting to call the number 1 a function
02:22:25 <liste> samanths: it's technically possible (if you provide the Num instance)
02:22:54 <jle`> the number 1 can be a function, so that's what's going on there.  but admittedly the error message isn't the best for someone new
02:23:12 <julianleviston> samanths: If you want nicer error messages, Elm might be a better fit until you grow out of it…
02:23:25 <samanths> you dont understand julian
02:23:28 <samanths> never mind
02:23:34 <jle`> haskell error messages can be daunting at times ... it can be like learning another language alongside the normal language
02:23:43 <samanths> glad at least jle sees the issue
02:23:44 <jle`> it's definitely an aspect that people are actively working on, though
02:23:50 <julianleviston> I see the issue too
02:24:02 <jle`> every update with GHC comes with improvements :)
02:24:04 <julianleviston> I was trying to solve your immediate problem.
02:24:06 <samanths> sure
02:24:09 <julianleviston> obviously with the wrong hammer :)
02:24:13 <samanths> yes
02:24:36 <julianleviston> so you actually didn’t want to know why the error messages are the way they are,.. you wanted to talk about how they’re terrible?
02:24:38 <samanths> no hammer was needed atall -
02:24:38 <julianleviston> (guessing)
02:25:48 <samanths> yes julian
02:25:54 <samanths> haskell is not user friendly
02:26:09 <julianleviston> uhhuh
02:26:14 <jle`> things like '1 1's error message could probably be improved by an ad-hoc rule, maybe, but there are a lot of ad-hoc rules out there and it just takes a lot of manpower to corner them down and categorize them and find them
02:26:33 <jle`> but there has been progress in general rules for helping error messages
02:27:01 <samanths> a lot of man power
02:27:01 <samanths> wow
02:27:04 <samanths> cant have that then
02:27:24 <julianleviston> horsepower?
02:27:30 <julianleviston> watts?
02:27:36 <samanths> steam 4 eva!
02:27:40 <jle`> just explaining why the progress has been a little slow :)
02:27:54 <liste> if it was in the interest of some company/organization with a lot of $$$ to spare...
02:28:01 <samanths> ok
02:28:09 <samanths> sorry to vent
02:28:11 <ahihi> the problem in "1 1" seems quite easy to spot even if you don't understand the error message
02:28:37 <samanths> dont suppose anyone here is a mac expert?
02:30:57 <jle`> you'd probably get a better response if you asked a specific question :)  being willing to answer a question about macs is much more likely than being willing to claim to be a mac expert
02:31:38 <samanths> ok
02:31:49 <samanths> its a problem that has PLAGUED me on macs
02:31:51 <jle`> i actually can't even imagine anyone ever answering "yup, i am a mac expert" to that question, heh
02:31:52 <samanths> for YEARS
02:31:57 <julianleviston> having said that, if you ask mac questions in here it’s a *bit* off topic
02:32:05 <jle`> oh, i was assuming it was a question about haskell on mac
02:32:10 <julianleviston> lol
02:32:18 <samanths> i dont know how to eject a usb drive
02:32:22 <samanths> i try to
02:32:26 <samanths> i press the eject button
02:32:33 <samanths> and it comes up with this smiley face
02:32:33 <jle`> definitely off-topic :|
02:32:35 <samanths> infuriating
02:32:43 <samanths> and says a file is in use
02:32:49 <samanths> so it cant be ejected!
02:32:52 <samanths> what do i do?
02:33:16 <ahihi> figure out what's using the file and close it
02:33:22 <samanths> how?
02:33:39 <samanths> it doesnt even say what file is in use!
02:34:00 <ahihi> lsof is a good start. but this is indeed off topic, try ##mac or #macosx
02:34:23 <samanths> isof?
02:34:41 <samanths> ahihi it says i need to register to post there
02:34:50 <samanths> just was hoping somoene here had some tech skills
02:39:25 <julianleviston> samanths: we do, but this is a chatroom for Haskell. I’ll pm you.
02:39:56 <samanths> ok
03:11:53 <deni> is there are standard templating language that most of the haskell community is familiar with? Something like: https://github.com/commercialhaskell/stack-templates/blob/master/yesod-hello-world.hsfiles
03:12:30 <deni> so not for html but like general file templating (for automatization purposes)...so that I don't choose something that people have to learn if they already know some other template
03:13:01 <deni> I was using HStringTemplate for a private project but I'm not sure how common that is
03:14:38 <Cale> I think that one is probably your best bet...
03:19:51 <suppi> you probably won't find something no one has to learn
03:26:44 <the_2nd> looking for an elegant way to transform a list into a list of lists with a certain size
03:27:17 <the_2nd> e.g. f 2 [1,2,3,4,5,6,7,8,9,10] => [[1,2,3,4,5], [6,7,8,9,10]]
03:27:59 <the_2nd> some sort of reverse concat which creates sublists of equal size (except the last one)
03:28:30 <puregreen> you can use the split package
03:28:34 <puregreen> @hackage split
03:28:35 <lambdabot> http://hackage.haskell.org/package/split
03:30:05 <puregreen> or you can use unfoldr and splitAt
03:30:15 <puregreen> > takeWhile (not.null) $ unfoldr (Just . splitAt 5) [1..23]
03:30:17 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23]]
03:31:07 <Cale> > map (take 5) . takeWhile (not . null) . iterate (drop 5) $ [1..23] -- another way (perhaps a bit less efficient, but also handy to be familiar with)
03:31:09 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23]]
03:33:03 <cloudhead> there's also `chunksOf` from extra
03:33:09 <cloudhead> depends what you're looking to do
03:34:14 <deni> Cale: suppi was also looking at this: https://hackage.haskell.org/package/ginger-0.2.5.0/docs/Text-Ginger.html
03:34:23 <deni> (coming from python I'm familiar with Jinja2
03:34:26 <deni> )
03:35:52 <the_2nd> puregreen, nice impl. went with chunksOf, tho
03:37:03 <DzyubSpirit> the_2nd++
03:40:32 <DzyubSpirit> @help
03:40:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:40:39 <DzyubSpirit> @help list
03:40:39 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
03:41:28 <DzyubSpirit> @help type
03:41:28 <lambdabot> type <expr>. Return the type of a value
04:43:29 <akegalj> puregreen: hey, we were talking about aeson but that you have looked into. Thank you for help. I just want to update you that we figured out what was wrong. We were using GeneralizedNewtypeDeriving which altered how ToJSON works
04:52:21 <puregreen> okay, thanks for the update
04:53:26 * hackagebot monoid-extras 0.4.2 - Various extra monoid-related definitions and utilities  https://hackage.haskell.org/package/monoid-extras-0.4.2 (BrentYorgey)
05:57:19 <saurabhnanda> how does one create an object/value for a record that has strict fields and lensees?
05:57:34 <Unicorn_Princess> so with the record syntax, no two types in the same namespace can share a record name, so for example, they can't both have a 'position' field. is there anything on the horizon to fix this? and, how often is this a problem in real code?
05:59:51 <saurabhnanda> Unicorn_Princess: big problem in real code. Check out my question - related to this. GHC 8 solves this partially
06:00:28 <Unicorn_Princess> what does ghc8 do about it?
06:01:42 <sm> recent discussion: https://www.reddit.com/r/haskell/comments/4s5i79/whats_the_current_agreed_upon_solution_to_records/
06:01:49 <Unicorn_Princess> thanks
06:10:11 <gpyh> hi
06:11:13 <gpyh> I have a very specific cabal-install question that google couldn't help me answer: how can I get the path that "cabal copy" will use after a "cabal configure"?
06:18:21 <bennofs> gpyh: that might be quite hard to read out of cabal-install does not already provide a command for that. cabal will store the information gathered during configure in dist/setup-info, but that is a binary file and you can only read it using the Cabal library from Haskell
06:18:30 <bennofs> s/of/if
06:19:20 <gpyh> bennofs: many thanks
06:25:44 <DzyubSpirit> quit
06:25:47 <DzyubSpirit> :q
06:26:03 <mauke> try /quit
06:26:20 <DzyubSpirit> thank you ;)
06:33:30 * hackagebot quipper 0.7 - Quipper is an embedded, scalable functional programming language for quantum computing.  https://hackage.haskell.org/package/quipper-0.7 (miniBill)
06:34:09 <Thra11> I'm using a cabal sandbox for development. It appears that cabal repl and cabal run are using the same .o files, but possibly with slightly different compilation options, so if I just use cabal repl, doing e.g. :r will only recompile the files that have changed. Same if I just use cabal run. However, if I switch between the two, it recompiles all modules. Is there a way to avoid this issue?
06:37:02 <saurabhnanda> no way to have same lens name across two modules, and import both modules?
06:39:20 <Thra11> I have, ":set -fobject-code" in my .ghci. If I remove it, the problem goes away, as ghci no longer compiles to the .o files. It's not ideal though...
06:40:05 <DzyubSpirit> window move 2
06:42:17 <dolio> That sounds like it's probably just ghci's behavior.
06:43:30 * hackagebot bindings-GLFW 3.1.2.1 - Low-level bindings to GLFW OpenGL library  https://hackage.haskell.org/package/bindings-GLFW-3.1.2.1 (SchellScivally)
06:44:44 <DzyubSpirit> window show 1
07:08:00 <deathcode> hello
07:08:08 <anontrax> hey
07:08:33 <deathcode> I know this could be the wrong place to ask, but I am a veteran programmer (5 years with 7 languages) and what to get into haskell
07:08:39 <deathcode> what are some good resources i can use
07:08:43 <voc> hi deathcode
07:08:53 <anontrax> hey deathcode
07:08:53 <Welkin> veteranarian?
07:08:54 <voc> start with this: http://haskellbook.com/
07:08:58 <anontrax> veteran
07:09:07 <anontrax> At leat that's what I think he means
07:09:08 <voc> avoid "learn you a haskell"
07:09:10 <Welkin> so you program animals?
07:09:19 <deathcode> yes
07:09:27 <anontrax> He means veteran (old user) i think
07:09:35 <voc> deathcode if you want some recommendations on what libraries to use, go here: http://haskelliseasy.com/
07:09:39 <deathcode> Started in like 6th grade
07:09:40 <hpc> i wouldn't so much say to avoid it, as just pick something better
07:09:42 <deathcode> C# and JS
07:09:46 <voc> deathcode also, use stack instead of cabal
07:09:49 <Welkin> deathcode: eww
07:09:52 <hpc> lyah isn't necessarily bad, just lacking in a few ways
07:10:19 <voc> hpc the problem i have with lyah isn't the comprehensiveness. it's that the pedagogical style gives you the illusion of learning
07:10:20 <deathcode> ok thx
07:10:33 <voc> hpc then when you actually start a project you have no idea what to do
07:10:37 <Welkin> wtf is with that haskelliseasy site?
07:10:39 <Welkin> never seen it before
07:10:49 <Welkin> and it lists attoparsec instead of parsec under "parsing"
07:10:53 <Welkin> bad advice
07:10:57 <Axman6> not sure I'd call 5 years enough time to be a "vetran" :P
07:11:04 <deathcode> Yeah i guess not
07:11:06 <voc> welkin it's by chris allen, he made it in like an hour after there was a reddit thread complaining about not knowing which libraries to pick
07:11:13 <Welkin> lol
07:11:14 <Welkin> I see
07:11:14 <Iceland_jack> Let's not nitpick the veteran part too hard
07:11:16 <Welkin> well he needs to fix it
07:11:23 <Iceland_jack> deathcode: Haskell may feel frustrating at first, many experienced programmers give up because they expect it to be similar to C/Java/Python/...
07:11:26 <Welkin> "senior ninja programming guru"
07:11:31 <voc> welkin it's specifically opinionated. i don't agree with everything either, but it's better than nothing
07:11:40 <deathcode> I mean i am now a systems programmer using assembly and c/c+++
07:11:50 <voc> welkin it's better than stumbling through hackage as a beginner, which is quite daunting
07:12:03 <deathcode> ok welkin lets call me "experianced"
07:12:12 <voc> deathcode, i came from a c++ background as well. Well sortof, C++ and R mostly
07:12:28 <deathcode> for me haskell is a syntactic thing
07:12:33 <Welkin> deathcode: or just say that you know how to program
07:12:35 <voc> enough with the vetran jokes :P
07:12:37 <mettekou> Iceland_jack: I concur: experienced programmers generally have a bias towards imperative languages.
07:12:44 <Welkin> there is no need for qualifiers
07:12:53 <deathcode> i cant quite grasp the ill say inadiquacy of the syntax compared to the relative clarity imo of C
07:12:59 <voc> deathcode one important thing about haskell is you don't want to approach it as learning syntax though
07:13:07 <deathcode> oh
07:13:09 <deathcode> that would do it
07:13:13 <Welkin> deathcode: haskell flows like english once you get used to it
07:13:17 <mauke> deathcode: you can probably learn haskell syntax pretty quickly
07:13:17 <Welkin> it feels totally natural
07:13:24 <voc> usually when programmers learn new languages they try to find the "equivalent" of things they know
07:13:29 <Welkin> lol voc
07:13:30 <mauke> deathcode: but that's not where the difficulty is
07:13:38 <Welkin> hence all the oop people coming in here wanting to abuse typeclasses
07:13:41 <voc> how do i assign variables, how do i call functions, how do i write a loop
07:13:55 <deathcode> the thing is the functional part is easy, i do some lisp, so its not entirely foreign
07:14:02 <mauke> deathcode: which lisp?
07:14:09 <Welkin> deathcode: well, half the language is the type system in haskell
07:14:14 <deathcode> CLISP and some emacs lisp
07:14:24 <Welkin> that is likely the biggest challenge for newcomers
07:14:31 <Welkin> and the concept of lazy evaluation
07:14:32 <voc> deathcode i will reiterate my recommendation to start with http://haskellbook.com/
07:14:34 <mauke> deathcode: those are basically imperative
07:14:38 <deathcode> I actually just finished struture and interpretation of computer programming
07:14:39 <Welkin> and referential transparency/control of side effects
07:15:03 <voc> deathcode i took a SICP class. it's good preparation, but haskell is still something else entirely
07:15:03 <mauke> speaking from my own experience, I came from ocaml
07:15:03 <deathcode> fun read
07:15:10 <hpc> deathcode: the thing you'll probably find toughest from your background is how much equational reasoning there is
07:15:11 <Welkin> yeah, just start with heaskellbook or learnhaskell
07:15:14 <Welkin> @where learnhaskell
07:15:15 <lambdabot> https://github.com/bitemyapp/learnhaskell
07:15:22 <mauke> ocaml has a pretty similar syntax and type system, and I still had problems with haskell
07:15:37 <Welkin> lol, ocaml
07:15:46 <mettekou> voc: Where did you take that SICP class?
07:15:50 <voc> hpc i'm not sure about that. the thing about equational reasoning is that it's not like it _introduces_ difficulty
07:15:55 <voc> mettekou berkeley
07:16:07 <deathcode> i only want to learn because i love FP
07:16:08 <voc> (it's either going to be berkeley or mit right?) :-)
07:16:18 <hpc> voc: it's just a thing you have to get in the mindset of
07:16:33 <mauke> deathcode: if you have any concrete questions about the syntax, feel free to ask :-)
07:16:39 <deathcode> got it
07:16:55 <voc> hpc yeah but other things introduce difficulty. equational reasoning is more like a nice property that you start thinking in terms of as you get more advanced
07:16:56 <deathcode> thinking i kinda want to make a haskell irc client
07:17:01 <deathcode> that would be a cool thing
07:17:05 <Welkin> deathcode: work in the type system first, write out all your types, make sure they fit together, then write your program
07:17:07 <mettekou> voc: Well, here in Belgium the Vrije Universiteit Brussel in Brussels has a SICP class for both computer science students (2 semesters) and other science students (1 semester, condensed).
07:17:59 <voc> mettekou ah ... i was sortof kidding.  the thing that's sad and kind of hilarious is that SICP is being replaced by python.
07:18:17 <Welkin> lol
07:18:19 <deathcode> that is disappointing
07:18:20 <Welkin> I saw that
07:18:22 <mettekou> voc: Yeah, they refused to do that at the VUB, which is great in my opinion.
07:18:22 <voc> but then recently i saw some intro python class where they obviously sortof kept the SICP curriculum
07:18:23 <deathcode> that was a fun read
07:18:28 <Welkin> python is anti-functional
07:18:36 <voc> and they had students drawing those environment diagram things
07:18:36 <Welkin> they could at least replace it with lua
07:18:38 <voc> for python code
07:18:38 <deathcode> it has lambda support
07:18:39 <Welkin> I mean come on
07:18:43 <Welkin> deathcode: it sucks
07:18:52 <deathcode> welkin the problem with lua is that its not OO at all
07:18:54 <hpc> that's not an exaggeration either, the design of python actively discourages functional style
07:18:54 <Welkin> deathcode: it has no support for recursion
07:19:03 <deathcode> i love scala in that i have the ability to do both
07:19:06 <hpc> lambdas can contain expressions but not statements
07:19:08 <troydm> how do I compare String's without case sensetivity
07:19:18 <voc> eh lua is pointless. i mean the only place it seemed to get traction was scripting games
07:19:21 <Welkin> deathcode: languages like scala are worse because they try to do everything
07:19:25 <mettekou> :t toLower
07:19:26 <lambdabot> Char -> Char
07:19:26 <Welkin> why would anyone want oo in the first place?
07:19:29 <hpc> only named function definitions can contain blocks of code
07:19:32 <mettekou> :t fmap toLower
07:19:33 <lambdabot> Functor f => f Char -> f Char
07:19:40 <deathcode> Welkin: OOP is good for modeling
07:19:42 <voc> lua is not beautiful enough to learn it for elegance, it's not practical enough to learn it for practical work
07:19:44 <mettekou> :t compareBy
07:19:46 <lambdabot>     Not in scope: ‘compareBy’
07:19:46 <lambdabot>     Perhaps you meant ‘compare’ (imported from Data.Ord)
07:19:56 <Welkin> voc: lua is actually great
07:19:57 <voc> deathcode mike acton would disagree :)
07:19:59 <deathcode> in reality, truely good programmers should be able to accomplish any problem with the simplist of tools
07:20:10 <deathcode> Not bashing on anyone
07:20:11 <Welkin> it is super minimal and works for its intended purpose
07:20:13 <voc> why would i spend my time learning lua, as opposed to... haskell
07:20:16 <deathcode> in that regards i would suck
07:20:20 <Welkin> supposedly, a lot of chinese companies are using lua for the web
07:20:31 <Welkin> voc: not instead, but in addition to
07:20:37 <voc> deathcode that's the common wisdom. but after learning haskell i'm not sure i agree with that any more
07:20:38 <mauke> troydm: how correct do you need it to be?
07:20:43 <mettekou> Hmmm... There was a function around which allowed you to precompose a transformation with a predicate, troydm.
07:20:53 <voc> there's an inherent march towards complexity that certain very-standard language constructs introduce
07:20:54 <troydm> mauke: only english letters
07:20:56 <deathcode> voc: and why is that
07:20:59 <mauke> troydm: define "english"
07:21:14 <troydm> mauke: anything within first 128 chars of ascii
07:21:23 <voc> deathcode that make a system collapsing on its own complexity almost inevitable beyond certain scales
07:21:28 <hpc> troydm: ascii is 127 characters ;)
07:21:31 <mauke> troydm: ... that's all of ASCII :-)
07:21:32 <mettekou> :t comparing
07:21:33 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
07:21:42 <mauke> troydm: then toLower'ing both sides should work
07:21:48 <deathcode> voc: thats where paradigms fall into play
07:21:49 <mettekou> :t comparing (fmap toLower)
07:21:50 <lambdabot> (Functor f, Ord (f Char)) => f Char -> f Char -> Ordering
07:21:55 <deathcode> voc: OOP simplifies representaion
07:21:59 <troydm> aha
07:22:01 <troydm> thx
07:22:09 <deathcode> FP simplifies everything involving functions
07:22:09 <mettekou> > comparing (fmap toLower) "Hello" "HeLlO"
07:22:09 <Welkin> deathcode: it makes it vastly more complex for no reason
07:22:10 <lambdabot>  EQ
07:22:13 <voc> deathcode and certain languages cannot express certain paradigms
07:22:15 <Welkin> oop, that is
07:22:18 <mettekou> There you go, troydm.
07:22:28 <voc> i mean, they can express some approximation of OO or FP, but there's certain things i can express in haskell
07:22:33 <voc> that i simply cannot express in R or C++
07:22:33 <deathcode> voc there is most definatly truth in that
07:23:32 <Welkin> lol what?
07:23:35 <Welkin> he just left
07:23:43 <voc> those specific things that i can or cannot complex can doom me to death by complexity or prevent it.
07:23:53 <voc> welkin it's irc..
07:24:18 <voc> ain't no etiquette here
07:25:08 <voc> time to work on trying to write probabilistic models in haskell..
07:25:16 <mauke> @let import Data.CaseInsensitive
07:25:17 <lambdabot>  .L.hs:77:1:
07:25:17 <lambdabot>      Data.CaseInsensitive: Can't be safely imported!
07:25:17 <lambdabot>      The package (case-insensitive-1.2.0.4) the module resides in isn't trusted.
07:25:22 <mauke> aww
07:25:40 <Welkin> never heard of that mauke 
07:26:03 <mauke> http://hackage.haskell.org/package/case-insensitive
07:27:36 <vxt> another weekend another day of happy haskell hacking.
07:28:11 <Welkin> writing in haskell (or haskell-like languages) does make me happy
07:28:17 <Welkin> unlike most languages...
07:28:21 <Iceland_jack> ^
07:28:36 <vxt> yep
07:29:27 <mauke> ... I think this is why I don't use haskell that much
07:29:34 <mauke> writing it doesn't make me happy
07:29:35 <vxt> i like the feeling of "i did not know the program i wrote could do that!"
07:29:49 <vxt> mauke what does
07:29:57 <mauke> Perl
07:30:16 <mauke> and sometimes C, for specialized problems
07:30:23 <vxt> lol to each his own :-)
07:30:35 <vxt> C i can relate to. sortof.
07:31:19 <hpc> i enjoy perl
07:31:33 <mauke> Haskell is harder to optimize: I don't know how to find the best solution to any problem, and if I did I wouldn't recognize it
07:31:59 <vxt> i'm okay with haskell<->C FFI if the problem demands it
07:32:08 <mauke> the Haskell FFI is great
07:32:31 <vxt> i'm not good at optimizing haskell, but it seems like some people get pretty far with unboxed vector tricks
07:32:41 <mauke> I'm not talking about performance
07:34:24 <vxt> what sense of optimization are you referring to then
07:34:38 <mauke> finding the best solution to any problem
07:35:25 <mauke> where "best" is usually measured along several axes, like: handles all cases correctly, has elegant code, is efficient, is maintainable
07:36:09 <hpc> ah yeah, that's an annoying mental block to get past
07:36:41 <hpc> ive finally gotten to the point i think where i can just go write some haskell that does what i want, and not care about how good it is
07:36:54 <hpc> and then once i have something i can go back and make it abstracted out in the most useful way
07:37:21 <Rotaerk_> abstraction shouldn't be done until you have at least 3 concrete cases
07:37:21 <mauke> it seems like that would be solved by gaining more experience, to get both better intuition and a better toolkit
07:37:23 <Welkin> lol, that is just called "programming"
07:37:33 <Welkin> Casey Muratori calls it "exploratory programming"
07:37:45 <mauke> but haskell also makes it hard to write reusable code
07:37:49 <Welkin> "just write the dumbest thing that does what you want to do, then make it better later if necessary"
07:40:18 <hpc> mauke: if you need practice writing really bad haskell code, i accept pull requests for acme-php :D
07:41:32 <Rotaerk_> the worst code is non-existent code
07:41:35 <Rotaerk_> I've got tons of that
07:41:47 <Welkin> the best code is code you never have to write :D
07:41:51 <cocreature> Rotaerk_: just delete it
07:42:02 <Welkin> template haskell takes tht too literally
07:42:05 <Rotaerk_> heh
07:42:32 <mauke> hpc: you know what? I want CPAN for Haskell
07:42:41 <mauke> hpc: (and Haskell FFI for Perl)
07:45:27 <notdan> hpc: the homepage for that package looks  broken
07:45:31 <Iceland_jack> C-SPAN for Haskell
07:47:04 <hpc> notdan: it's the documentation, written in acme-php
07:47:16 <hpc> remember to view source to get the jokes, as with the package itself
07:47:28 <Welkin> lol
07:47:53 <mettekou> hpc: Although acme-php is a jab at PHP, which I fully support, it implements bubble sort instead of PHP's merge sort lifted from the MIT (contains optimizations for a certain Cray supercomputer which the PHP developers did not elect to remove).
07:48:18 <hodapp> Iceland_jack: ain't the mailing list good enough for that?
07:48:51 <hpc> mettekou: yeah, but what a bubblesort it is
07:50:24 <mettekou> hpc: I just laughed way too hard at (<>) = getLine.
07:51:34 <Welkin> hpc: upload your docs >:0!
08:18:34 * hackagebot sync-mht 0.3.8.5 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.8.5 (emink)
08:21:58 <mzabani> howdy
08:22:39 <mzabani> I'm having trouble with an implementation of Aeson's parseJSON, GHC complains that Maybe doesn't match Parser after using the .:? operator
08:23:22 <mzabani> I'm new to haskell so I wonder if someone could help me out with this
08:26:53 <glguy> mzabani: You can paste the code in question to http://lpaste.net along with the error
08:28:19 <mzabani> http://lpaste.net/169994
08:28:25 <mzabani> thanks in advance
08:29:12 <glguy> mzabani: You'll need to delete line 17, "tipo :: Maybe T.Text"
08:29:31 <glguy> By putting it there you're adding it as a statement in the do-notation
08:30:09 <glguy> mzabani: If you want to annotate the type of the expression tipo, you can do that on the next line at the beginning of your case expressions
08:30:16 <glguy> case tipo :: Maybe T.Text of
08:30:55 <Welkin> mbanza-kongo :D
08:31:08 <glguy> Welkin: This is an English-language channel
08:31:15 <mzabani> oh gosh, that was it... I tried putting it before, after, on the same line
08:32:08 <mzabani> is there any other way to annotate types for a binding defined with the <- operator?
08:32:34 <glguy> mzabani: You can write: tipo <- o .:? "TIPO" :: Parser (Maybe T.Text)
08:32:46 <glguy> or with the ScopedTypeVariables extension enabled you can write:
08:32:53 <glguy> (tipo :: Maybe T.Text) <- ....
08:33:52 <mzabani> good to know that
08:34:00 <mzabani> thanks a lot for the help!
08:36:04 <vxt> anyone doing data analysis type of work with haskell?
08:52:27 <Iceland_jack> <mzabani> is there any other way to annotate types for a binding defined with the <- operator?
08:52:28 <Iceland_jack> You can also write
08:52:28 <Iceland_jack>     tipo <- o .:? "TIPO" :: _ (Maybe T.Text)
08:52:28 <Iceland_jack> with PartialTypeSignatures
08:52:49 <Iceland_jack> glguy's solution is preferred
08:53:35 * hackagebot cmark 0.5.3.1 - Fast, accurate CommonMark (Markdown) parser and renderer  https://hackage.haskell.org/package/cmark-0.5.3.1 (JohnMacFarlane)
08:53:45 <Welkin> if you are reading in a value from IO, you can use this too: (read :: String -> Int)
08:53:48 <Welkin> for example
08:54:09 <Iceland_jack> There is also
08:54:09 <Iceland_jack> :t readLn
08:54:10 <lambdabot> Read a => IO a
08:54:18 <Iceland_jack>     readLn @Int :: IO Int
08:58:12 <Maplicant> What are your thoughts on Rust?
08:58:35 <glguy> I think it's probably on topic in ##rust
08:59:00 <nitrix> What is the name of the @ type extension again?
08:59:13 <glguy> TypeApplications
08:59:48 <glguy> Maplicant: Alternatively it would be on topic in #haskell-offtopic if you just wanted to talk to Haskell people about Rust
09:07:22 <vxt> what happened to haskell blah
09:07:46 <glguy> It's it own independent thing
09:08:26 <monochrom> haskell-blah requires TLS. you can go there but I'm not there.
09:14:48 <vxt> ghcid is nize
09:17:25 <nitrix> I don't know. If all you're doing with ghci is :r, you're missing on a lot.
09:20:02 <vxt> nitrix what do you mean?
09:27:55 <nitrix> Finding instances, figuring what a type is or where it comes from, putting breakpoints to step through the code...
09:28:23 <nitrix> Loading and unloading files is merely how you get started with GHCi, not its only purpose :P
09:30:01 <vxt> just because ghcid speeds up one aspect of my development cycle doesn't mean i'm not doing anything else!
09:30:20 <vxt> i probably use ghci in ways that most people don't
09:30:38 <nitrix> vxt: http://hackage.haskell.org/package/foreign-store-0.2/docs/Foreign-Store.html
09:30:57 <vxt> yup, actually rapid looks amazing but i haven't had a chance to play with it
09:31:11 <vxt> i've written my own elisp extensions to send lines or blocks of code ala python or R
09:31:48 <nitrix> This lets you do really neat things. I believe yesod had similar automatic code reloading based on a similar implementation.
09:31:59 <nitrix> The advantage is that it maintains the context of your application.
09:32:20 <vxt> i've used foreign store, but it sounds like rapid basically supercedes it, no?
09:32:24 <nitrix> Rather than resetting everything everytime it does :r. And then you can start really working in GHCi and enjoying it.
09:32:41 <nitrix> vxt: What does rapid do better?
09:33:19 <Welkin> nitrix: yesod-devel just watchs your source folder for changes to files
09:33:24 <Welkin> I think
09:33:49 <Welkin> kind of like how keter watches the /incoming directory for new keter bundles
09:34:11 <Welkin> oh, you mean in ghci
09:35:48 <vxt> gotta run
09:36:44 <nitrix> Seems like a neat library. Wouldn't those interfere with his ghcid thing though?
09:36:57 <nitrix> We'll never know :P
09:58:01 <whald> hi! when the "current directory" was reached through a symlink, "echo $PWD" and "getCurrentDirectory" (from System.Directory) disagree. getCurrentDirectory does not take into account that i navigated a symlink to get where i am. is there an alternative function which returns what $PWD says?
09:58:49 <glguy> System.Environment.getEnv "PWD"
09:59:44 <geekosaur> whald, only if the shell exports its idea of it. that knowledge otherwise is only available to the shell that traversed the symlink
10:00:42 * geekosaur dislikes that particular bash-ism, because it means paths ../<something> won't do what users expect from the lie the shell is telling them
10:02:12 <whald> glguy, geekosaur thanks. i though that this is known to the kernel or the like and getCurrentDirectory is sanitising this so there would be hope to get the "raw" path in some way.
10:02:35 <geekosaur> if you want it to be known to the kernel, use a bind mount instead of a symlink
10:02:49 <mauke> whald: no, getcwd() already returns the resolved name
10:03:29 <mauke> I wouldn't be surprised if chdir() follows and resolves symlinks internally, so the symlink name isn't even stored by the kernel
10:03:31 <geekosaur> what has been traversed cannot be un-traversed; nothing can know about it
10:03:37 * hackagebot json-rpc-generic 0.1.0.0 - Generic encoder and decode for JSON-RPC  https://hackage.haskell.org/package/json-rpc-generic-0.1.0.0 (KeiHibino)
10:03:52 <geekosaur> compare `pwd -L` to `pwd -P` in bash
10:07:06 <ertes> geekosaur: it's a shellism…  zsh does it, too
10:07:34 <geekosaur> but other shells do not
10:07:36 <ertes> compare these 'pwd' to 'command pwd'…  the latter actually runs a program called 'pwd' that isn't part of the shell
10:46:44 <ertes> i need a data structure for the following purpose:  each element has an assigned priority, but the priority only determines the relative *probability* of selection (so not a priority queue), and the elements change very frequently with 1k-10k elements at peaks…  in other words:  i need cheap probabilistic selection, cheap add, cheap remove
10:47:01 <ertes> i'd go for a finger tree, but if anyone has a better suggestion, i'm all ears
10:48:36 <ertes> the finger tree makes these operations logarithmic, but i'm a bit worried about the potentially bad constant factor at > 1k elements
10:51:37 <Jinxit> ertes: making a particle filter?
10:52:23 <Jinxit> regardless; if you don't actually need the priority (just sampling) a plain array works
10:52:43 <Jinxit> well, provided the probabilities are normalized
10:58:34 <nshepperd_> ertes: any kind of tree where each node contains the total probability of its children
10:59:35 <nshepperd_> you can add any where you like as long as it keeps the tree balanced
11:00:03 <nshepperd_> when you sample, just recursively decide randomly whether to go to left or right child based on weights
11:07:46 <nshepperd_> maybe a 2-3 tree would be nice and easy
11:08:45 <mauke> "2-3 tree" is unnecessarily hard to pronounce
11:14:50 <saurabhnanda> if all fields in a record are strict, does that mean that the entire record is strict? Does that mean that simply passing the record as an argument to a function is actually going to instantiate it?
11:15:11 <glguy> No
11:15:54 <mauke> it means forcing the record will force all fields
11:16:31 <hpc> saurabhnanda: strictness is always measured relative to something else
11:17:26 <hpc> X is strict in Y if evaluating X evaluates Y
11:17:35 <saurabhnanda> if the record is being used as part of an else-statement, which is not actually executed during runtime, I won't be paying the penalty for the record creation, right?
11:18:39 * hackagebot ratel-wai 0.2.0 - Notify Honeybadger about exceptions via a WAI middleware.  https://hackage.haskell.org/package/ratel-wai-0.2.0 (fozworth)
11:19:20 <hpc> you'll likely still be creating the thunk, and depending on how expensive making your record is and how many times you do it, might still matter
11:19:30 <hpc> also this only applies to evaluation, not execution
11:19:57 <saurabhnanda> hpc: difference?
11:19:57 <hpc> if you're creating this record by parsing some output from a file or network connection, you're still doing that IO even if you don't use the result
11:20:17 <mauke> hpc: not if the 'else' never runs
11:20:29 <hpc> i am assuming the code here is something like
11:20:30 <hpc> foo = do
11:20:35 <hpc>   record <- something
11:20:47 <hpc>   if x then do stuff with record else don't
11:20:58 <mauke> ah
11:21:16 <hpc> that "something" is still going to be run
11:21:23 <hpc> if it's something like "read a file and parse the contents"
11:22:00 <hpc> then you'll have read in the whole file and record will be a thunk that denotes "parse the contents of the file and produce some data structure"
11:22:22 <saurabhnanda> hpc: not really
11:22:31 <saurabhnanda> hpc: that's now that the code looks like
11:23:01 <saurabhnanda> createOrReplaceUser searchFn replacementFn newUserRecord
11:23:11 <saurabhnanda> that's the function
11:23:37 <saurabhnanda> i'm worried about newUserRecord being unnecessarily evaluated even if the code-path is going to go via `replacementFn`
11:23:58 <saurabhnanda> a -> Text
11:23:59 <saurabhnanda> :t show
11:24:00 <lambdabot> Show a => a -> String
11:24:03 <saurabhnanda> :t view
11:24:04 <lambdabot> MonadReader s m => Getting a s a -> m a
11:24:10 <saurabhnanda> :t showText
11:24:11 <lambdabot>     Not in scope: ‘showText’
11:24:11 <lambdabot>     Perhaps you meant ‘showHex’ (imported from Numeric)
11:25:09 <saurabhnanda> any help?
11:25:11 <EvanR> theres no reason to believe it will be evaluated
11:25:32 <EvanR> but i think hpc was saying you still might be paying the cost of whatever the thunk is made of
11:25:45 <EvanR> so you still need to understand that part
11:25:49 <hpc> yeah
11:25:55 <saurabhnanda> I think I got it
11:26:08 <hpc> not sure what createOrReplaceUser is, but you can probably reason it out from what ive explained and looking at the definition yourself
11:26:33 <saurabhnanda> if the fields are being evaluated in IO **before** the call to `createOrReplaceUser` I'm stilling paying for the fields. 
11:26:38 <hpc> odds are it's fine
11:26:44 <saurabhnanda> thanks
11:26:53 <saurabhnanda> whas't the Text equivalent of show?
11:27:05 <saurabhnanda> :t text-show
11:27:06 <lambdabot>     Couldn't match type ‘[Char]’ with ‘Doc’
11:27:06 <lambdabot>     Expected type: String -> Doc
11:27:06 <lambdabot>       Actual type: String -> String
11:27:09 <EvanR> if the fields are being materialized earlier, in IO or not, then it doesnt really matter much
11:27:16 <saurabhnanda> :t textShow
11:27:17 <lambdabot> Not in scope: ‘textShow’
11:27:27 <maerwald> saurabhnanda: you can pm lambdadbot
11:27:28 <ertes> Jinxit: they aren't, and how would a plain array allow for efficient sampling, if they were?
11:27:32 <quchen_> Has anyone tried writing a tavis.yml to test building with both Stack and Cabal?
11:27:44 <saurabhnanda> maerwald: thanks for the tip. sorry for the noise.
11:27:45 <maerwald> only with cabal
11:28:22 <maerwald> doesn't have stack its own build stuff, why should you care in your repo?
11:28:36 <ertes> nshepperd_: that's basically what a finger-tree does and saves me from having to implement an (arguably more efficient) balanced tree myself…  do you know of an efficient implementation?
11:28:46 <hvr> quchen_: it's a mess if you try to keep the .travis.yml file self-contained
11:28:57 <zcd> is the debian package for haskell-platform the minimal version?
11:29:09 <quchen_> hvr: That’s my current status, yes. :-|
11:29:12 <hvr> quchen_: as well as keep the build-steps separated
11:29:35 <quchen_> I could either start 5 independent silly copypaste builds, or lose all abstraction.
11:29:39 <quchen_> Boo Travis. :-(
11:29:56 <hvr> quchen_: otoh, if the motivation is just to test whether something builds against a specific lts snapshot, I'm working on something...
11:30:13 <quchen_> (I’d like to build with Stackage LTS {,3,4,5}, Nightly, Cabal. In individual builds.
11:30:19 <quchen_> )
11:30:57 <ertes> nshepperd_: actually i could probably keep the tree balanced on average by just inserting new elements at random positions
11:32:05 <nshepperd_> ertes: you could keep it 'probabilistically' balanced by inserting at the child with least weight
11:32:42 <ertes> yeah, that could work
11:32:59 <ertes> fortunately i don't have to maintain an order
11:33:01 <maerwald> quchen_: you can use 'env' and set a build variable that is then used in shell scripts you call, that way it is rather isolated
11:33:19 <nshepperd_> ertes: I think a plain old 2-3 tree with this would be pretty efficient, a lot simpler than a finger tree
11:33:35 <maerwald> quchen_: here's a non-haskell example https://git.io/vKgv5
11:33:47 <nshepperd_> ertes: if you want to go mutable you could probably do it as an array heap
11:33:52 <quchen_> maerwald: Sure, I could do that. But then I lose other goodies. I cannot use travis_{retry,wait} anymore, I don’t get a good build log (because the commands issued are not echoed back to me).
11:34:16 <maerwald> uhm, you can see the log of all scripts afaik
11:34:51 <quchen_> maerwald: When call `./before_install`, all Travis echos is that it called that script, not all of the subcommands it issued.
11:34:55 <quchen_> That’s what I meant.
11:35:21 <quchen_> Unifying multiple Stack builds works fine, because only a couple of paramters change. But a Cabal build and a Stack build are so different I don’t see a nice way.
11:35:48 <nmdanny> is there a built in function for converting a bool into Maybe (), for use inside a Maybe monad?
11:36:00 <quchen_> nmdanny: guard
11:36:14 <quchen_> > guard False :: Maybe ()
11:36:16 <lambdabot>  Nothing
11:36:16 <DzyubSpirit> return
11:36:19 <quchen_> > guard True :: Maybe ()
11:36:21 <lambdabot>  Just ()
11:36:27 <maerwald> quchen_: that's not correct
11:36:33 <maerwald> quchen_: you can expand the script in the build log
11:36:53 <bollu> guys, quick Coq question. I was trying to prove that (negb x = negby => x = y). I have a solution here: http://lpaste.net/170036
11:36:59 <bollu> can someone tell me a better solution?
11:37:05 <bollu> I practically brute force the truth table
11:37:08 <nmdanny> oh I see, guard it is
11:37:11 <bollu> there's got to be a smarter way
11:37:36 <quchen_> maerwald: I’ll get the same output as if I ran the script from my own console.
11:37:39 <maerwald> quchen_: and if you want every command explicitly echoed you can just use a very trivial shell helper function for that
11:37:48 <EvanR> f x = f y implies x = y, this is also called "f is injective"
11:37:50 <mauke> sh -x
11:38:07 <ertes> nshepperd_: why a 2-3-tree as opposed to a regular binary tree with elements at the leaves?
11:38:10 <EvanR> so you are trying to prove negb is injective
11:38:25 <bollu> EvanR: right, but I'm not sure how to express injectivity in Coq
11:38:43 <EvanR> you express the definition as above, you mean how to prove it
11:38:46 <bollu> EvanR: injectivity requires a notion of mapping right?
11:38:54 <EvanR> since negb has 4 cases, its easy
11:39:08 <EvanR> wait it has 2 cases
11:39:13 <bollu> EvanR: yeah, but my Coq proof is so long! isn't there a tactic to make it smaller?
11:39:27 <quchen_> maerwald: Hm, let me see how far that gets me, thanks
11:39:39 <maerwald> quchen_: http://lpaste.net/170037
11:40:15 <EvanR> bollu: i actually dont know what negb is, also i dont know coq
11:40:36 <bollu> EvanR: ah, okay. I'm trying to use Coq to prove it. negb is just negation of a boolean
11:40:40 <bollu> damn, I was hoping for some help
11:40:42 <EvanR> oh, not
11:40:53 <bollu> Cale, merijn : ping
11:40:58 <monochrom> why are you talking about injectivity?
11:41:13 <bollu> monochrom: because f(x) = f(y) => x = y iff f is injective
11:41:21 <EvanR> prove that "not" is injective
11:41:24 <bollu> monochrom: can you look through my Coq proof? http://lpaste.net/170036
11:41:48 <monochrom> what should I pay attention to?
11:41:57 <bollu> monochrom: in the sense..?
11:42:10 <nshepperd_> ertes: I was thinking that 2-3 trees are just easier to do insertion and deletion, but not thinking very hard, so probably a normal binary tree is just fine
11:42:13 <bollu> monochrom: like, my proof is literally brute forcing. I want a more elegant way to do it
11:42:37 <monochrom> OK, let me ask you two meta-questions. A. Do you like this theorem? B. Is the proof accepted?
11:43:17 <bollu> monochrom: yes, the proof is accepted. I hate the proving method, but I need the theorem. There's no like/dislike to it :)
11:45:12 <bollu> monochrom: any ideas?
11:45:53 <monochrom> OK, in the style of Coq, this is probably the shortest and most elegant proof.
11:46:05 <bollu> monochrom: really? damn
11:46:12 <monochrom> which is a way to say how elegant and efficient Coq is.
11:46:27 <monochrom> (or generally any natural-deduction style thing)
11:46:36 <bollu> monochrom: :) what do you mean by "this style"? are there different styles?
11:46:43 <ertes> nshepperd_: ok, thanks
11:47:45 <Jinxit> ertes: regarding sampling, using a tree will get you something like O(log n), but (I think?) you have to generate multiple random numbers
11:47:58 <Jinxit> you can do it in O(n) with one random number on a standard array
11:48:15 <ertes> Jinxit: you only need one random number with the tree approach
11:48:46 <ertes> Jinxit: you use the tree to keep a total weight, generate a number between 0 and that weight, and then you descend into the tree
11:48:57 <EvanR> bollu: http://lpaste.net/170039
11:49:18 <bollu> EvanR: that's Coq syntax?
11:49:18 <nmdanny> is there any way to convert the following function to use a MaybeT monad, instead of binding to effectful values from an outer monad?
11:49:20 <lpaste> nmdanny pasted “how to refactor this to use MaybeT” at http://lpaste.net/170040
11:49:23 <EvanR> idris
11:49:29 <bollu> EvanR: ah
11:49:36 <Jinxit> aha, yeah, makes sense
11:49:41 <Jinxit> TIL
11:49:52 <EvanR> the two other cases are impossible, and :total f is "f is total" so youre done
11:49:57 <bollu> EvanR: what about the "absurd cases"? coq makes you do that as well.
11:50:06 <EvanR> you can write them out if you want though
11:50:07 <bollu> EvanR: I see
11:50:17 <monochrom> If you do equational reasoning instead, there is a better way. First prove: (neg a = b) iff (a = neg b). This proof is not very short, it requires 2 cases (but not 4). But once it's proved, you can use it to prove other useful things, and they won't require case analysis.
11:50:35 <monochrom> Then use that to prove: neg (neg a) = a.
11:51:02 <monochrom> Then use both of them to prove: neg x = neg y -> x = y.
11:51:07 <bollu> monochrom: I see. Is there coq syntax for "iff" ? Right now I only know "implies"
11:51:33 <monochrom> Coq has a syntax for "iff". But only syntax. No real support.
11:52:01 <monochrom> This is why Coq and generally natural deduction is inefficient and inelegant. "Iff" is second class.
11:52:41 <bollu> monochrom: hm, I guess I see. It's fun to solve SF though
11:52:41 <EvanR> you can say for all a and b : Bool, neg a = b is "isomorphic" to a = neg b
11:52:52 <monochrom> You need to read http://www.cs.utoronto.ca/~trebla/eq-wiltink.pdf to see why natural deduction sucks.
11:53:40 * hackagebot log 0.5.1 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.5.1 (arybczak)
11:53:42 * hackagebot log 0.5.2 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.5.2 (arybczak)
11:54:05 <bollu> monochrom: thanks a ton for the link
11:54:34 <bollu> monochrom: this is silly ,but I feel like I'm drowning all over again (in a good way, like the overwhelming feeling you get when you first learn Haskell)
11:54:44 <monochrom> This is why I was completely not impressed when I learned of Coq. I had already learned equational reasoning before seeing Coq. My conclusion could only be "so much fanfare for so little done".
11:54:59 <monochrom> I.e., unlike most people here.
11:56:37 <EvanR> bollu: in the idris case at least, you could have used a key combo to arrive at this proof ;)
11:57:08 <bollu> EvanR: :) I understand that idris is more "modern", but I'm learning Coq for the brilliant book (software foundations)
11:58:01 <EvanR> first case split x, case split y, then proof search the two holes to get two refls
11:58:40 * hackagebot hpqtypes 1.5.1 - Haskell bindings to libpqtypes  https://hackage.haskell.org/package/hpqtypes-1.5.1 (arybczak)
11:59:08 <EvanR> the idris book recommends this kind of thing over a tactic language
11:59:23 <johnw> bollu: you know, all the proof you need is "intros x y ?; destruct x, y; auto."
11:59:43 <bollu> johnw: really?
12:00:14 <bollu> johnw: oh right. I haven't really used "auto". I've been only "officially shown" reflexivity and  simpl in SF as of yet
12:00:33 <johnw> in fact, just: destruct 0, x; auto.
12:00:42 <EvanR> is auto like saying "the rest is obvious" in a book ;)
12:00:53 <johnw> not sure what monochrom means by "so little done", but that's a discussion for #coq
12:01:20 <johnw> EvanR: more or less :)
12:01:23 <bollu> EvanR: AFAIK, auto is a "smart" tactic, right johnw?
12:01:40 <EvanR> cantors theorem: auto.
12:01:47 <EvanR> QED ;)
12:02:02 <johnw> it's fairly smart, since it works by extensible hint databases
12:02:34 <bollu> EvanR: TBH, it's not "hard" :) just some contradiction involved :P
12:02:59 <mauke> http://inutile.club/estatis/falso/
12:03:34 <bollu> mauke: just took a look. I disagree, contradiction is so opaque
12:03:40 * hackagebot haskell-gi-base 0.18.1 - Foundation for libraries generated by haskell-gi  https://hackage.haskell.org/package/haskell-gi-base-0.18.1 (inaki)
12:04:12 <bollu> mauke: oh, it's a joke >_<
12:04:12 <EvanR> did they encode HoTT into coq, thats seems kind of impressive
12:04:47 <mauke> https://github.com/clarus/falso#falso
12:06:11 <lpaste> hexagoxel annotated “how to refactor this to use MaybeT” with “typed holes ftw” at http://lpaste.net/170040#a170043
12:06:59 <hexagoxel> nmdanny: ^
12:07:11 <EvanR> mauke: a magnificent proof
12:07:16 <EvanR> quite profound
12:13:55 <nmdanny> thanks hexagoxel, although I've figured it out by now :p
12:14:52 <nmdanny> thoug the typed holes don't seem to help very much, i've solved this with much guesswork
12:17:59 <undermink> nabend :)
12:19:50 <maerwald> depends on your timezone
12:20:04 <undermink> hehe indeed:)
12:28:16 <ReinH> timezone-appropriate greeting to you as well
12:31:25 <monochrom> I simply always say "good morning"
12:33:50 <ReinH> good day to you sir
12:33:58 <ReinH> I say good day
12:38:29 <mniip> just use freenode standard time
12:38:41 * hackagebot pipes-cliff 0.12.0.0 - Streaming to and from subprocesses using Pipes  https://hackage.haskell.org/package/pipes-cliff-0.12.0.0 (OmariNorman)
12:54:46 <nicksoline> hello_world
12:57:47 <EvanR> nicksonline
12:58:15 <ertes> HelloWorld#
13:17:08 <timthelion> What is the technical term when you have f :: a -> b \n g :: b -> a and g . f == id and f . g == id so you can go back and forth?
13:18:43 <mniip> isomorphism
13:18:46 <mniip> bijection
13:19:11 <mniip> one-to-one
13:23:43 * hackagebot binary-orphans 0.1.5.1 - Orphan instances for binary  https://hackage.haskell.org/package/binary-orphans-0.1.5.1 (phadej)
13:24:54 <timthelion> mniip: isomorphism is what I wanted I think. I want to say that two file formats are isomorphic, aka, that you can translate one from the other without data loss.
13:27:31 <nicksoline> hi EvanR
13:28:43 * hackagebot semibounded-lattices 0.1.0.0 - A Haskell implementation of semibounded lattices  https://hackage.haskell.org/package/semibounded-lattices-0.1.0.0 (xuhao)
13:29:29 <orion> Are there any good maths libraries for solving several non-linear systems of equations?
13:29:40 <nicksoline> timthelion: can i ask what are the file formats
13:30:46 <EvanR> orion: non-linear systems of equations is not very specific
13:33:19 <timthelion> nicksoline: um, well, one of them doesn't exist yet. The first one is textgraph, which I describe in a long video here http://thobbs.cz/tg/tg.html . textgraph is json based, and I'd like to create a second one that is harder for computers to parse and easier for humans to parse.
13:33:29 <orion> I'm probably going to want to use the Gauss-Newton algorithm for non-linear least squares.
13:45:11 <davidkart> hello
13:45:38 <davidkart> when my program goes into an infinite recursion loop, ghci doesn't give me the input loop back after hitting ctrl+C.
13:46:39 <davidkart> iti s really weird.
13:46:43 <EvanR> huh
13:46:58 <davidkart> yes I said infinite loop
13:47:14 <davidkart> this is weird but the mishape of the interpreter puzzles me more.
13:47:14 <ertes> davidkart: indeed…  is the loop in haskell?  i can see how it might happen, if the loop is in foreign code
13:47:28 <davidkart> yes this is an haskell program.
13:47:34 <davidkart> Do you want the source ?
13:47:59 <ertes> feel free to paste it on lpaste.net
13:48:21 <davidkart> i hate stuck terminals
13:48:32 * timthelion resists the urge to tell davidkart that the problem is his lack of use of agda
13:49:01 <davidkart> http://pastie.org/10909400 <-here is the code.
13:49:05 <glguy> That's a good urge to resist
13:49:06 <davidkart> I just load into GHCi
13:49:19 <davidkart> then I run « solve mySecretCode »
13:49:24 <geekosaur> I think it can happen if a computation doesn't cause any allocation, especially on Windows (Unix at least has actual async signals)
13:49:26 <davidkart> well of course the code is buggy
13:49:53 <davidkart> but the interpreter should resist buggy code
13:50:15 <davidkart> and actually the pattern matching has been changed since I ran the code.
13:50:39 <davidkart> it was "solvePlain secretCode [] = [] 
13:51:03 <davidkart> I needed to match with a list with one single element instead.
13:51:09 <davidkart> but this is detail
13:52:24 <timthelion> The other possibility, is that the code is doing a whole lot of allocations, and is getting stuck in the GC. In that case, jamming Ctrl-C over and over again and waiting should unfreeze it after a few seconds, but is liable to kill ghci as well :/
13:53:44 * hackagebot namespace 0.1.0.0 - A Generic Haskell library for managing namespaces  https://hackage.haskell.org/package/namespace-0.1.0.0 (xuhao)
13:53:46 * hackagebot publicsuffix 0.20160716 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160716 (wereHamster)
13:54:41 <davidkart> timthelion : the interpreter is coded in Haskell, isn't it ?
13:54:50 <davidkart> why won't you do it with C ?
13:55:05 <davidkart> Or at least make it more robust ?
13:55:26 <davidkart> I feel the urge to tell to the community how important my problem is
13:55:38 <davidkart> I feel this problem is really important
13:57:06 <glguy> davidkart: First figure out how to reproduce the problem, the code you pasted doesn't seem to get stuck
13:57:10 <davidkart> or probably I should rewrite my code better
13:57:20 <davidkart> glguy: really ?
13:57:32 <glguy> serious ?
13:57:36 <davidkart> I do a recursion without stopping condition 
13:58:10 <davidkart> BTW how you do a plain simple main in a file that is executed when you call ghc onto it ? a do :: IO () ?
13:58:36 <glguy> Name the action "main"
13:58:46 <glguy> and name the module Main
13:59:07 <glguy> When you "call ghc onto it" then ghc will produce an executable
13:59:12 <glguy> which you can run
13:59:25 <Phyx-> did this change btw, didn't it used to be any module is fine as long as you tell it where main is?
14:00:15 <davidkart> I meant (main) like in C code. The function or the bit of code that is directly run when you launch your program.
14:00:19 <glguy> Phyx-: If you don't name the module Main you have to tell GHC what the Main module is
14:00:30 <glguy> davidkart: Yeah, that's what main does in Haskell
14:00:42 <davidkart> do you often write buggy code on a first trial ?
14:00:51 <ertes> davidkart: in general i would expect that not to happen, especially in code that uses only the Prelude (e.g. your code)
14:01:14 <davidkart> yes that's why I am a little desperate
14:01:20 <Phyx-> glguy: yeah, -main-is no? couldn't get it to work with Cabal last i tried
14:01:25 <Phyx-> but didn't try very hard
14:01:38 <glguy> Phyx-: -main-is flag is when you're using GHC directly
14:01:57 <glguy> With Cabal you use the main-is: configuration field
14:02:26 <davidkart> how is the printing negociated ?
14:02:48 <glguy> You'll have to ask that a different way
14:03:01 <ertes> davidkart: try this in the interpreter:  let x = x in x
14:03:22 <davidkart> ertes: this is buggy
14:03:44 <ertes> davidkart: that's about the most minimal infinite loop…  see if you can abort it with ctrl-c
14:03:56 <sarfraz> Playing 
14:04:13 <davidkart> yes I can of course. You must be right, the ghci must be lost in some recursion stack where it can hear the CTRL+C.
14:04:23 <davidkart> s/can/cannot
14:05:04 <ertes> davidkart: there is one way GHCi can get unresponsive: when your code has a memory leak and allocates like crazy…  but in that case i'd expect your whole system to crash
14:05:19 <davidkart> no, not really
14:05:38 <ertes> (unless you used a heap limit with +RTS -M)
14:05:39 <davidkart> ghci was unresponsive because it probably was adding elements to a list 
14:06:00 <ertes> that doesn't make it unresponsive (in fact that's probably not what is happening)
14:06:19 <davidkart> ok, open interpreter. Type '[1..]' and hit enter.
14:06:30 <davidkart> that's what I called "unresponsive"
14:06:40 <ertes> yeah, try that…  it should start printing and go on forever, until you hit ctrl-c
14:06:44 <davidkart> in fact it just reproduced my problem in a direct way.
14:06:48 <mirpa> [1..] is infinite loop
14:06:50 <ertes> i see
14:07:08 <monochrom> my [1..] is stopped by ctrl-c just fine. worksforme.
14:07:08 <davidkart> ertes: indeed it stops displaying the numbers, but the interpreter is still stuck.
14:07:20 <ertes> davidkart: "stuck"?
14:07:22 <davidkart> I don't know, it could be my VT at fault.
14:07:23 <ertes> no prompt?
14:07:31 <glguy> What OS and version of GHC?
14:07:32 <monochrom> negative. I get back the ghci prompt too just fine. still worksforme
14:07:35 <davidkart> ertes, no prompt.
14:07:54 <ertes> davidkart: what glguy asked
14:07:56 <davidkart> In fact I am stuck at ...,49379,49380,..
14:08:22 <davidkart> I'm using archlinux so probably last version of ghci, kate and konsole as a virtual terminal
14:08:29 <ertes> ghc --version
14:08:51 <davidkart> The Glorious Glasgow Haskell Compilation System, version 8.0.1
14:09:02 <davidkart> oh my :)
14:09:09 <glguy> see if you can reproduce it in other contexts like with xterm
14:09:26 <davidkart> but yeah, I tried into a simple terminal (no emulation) and CTRL+C works just fine.
14:09:29 <ertes> ok…  now exit GHCi (or kill it), open a fresh GHCi and type [1..]
14:09:33 <ertes> see if it happens again
14:09:47 <monochrom> 8.0.1 workforme too
14:09:50 <glguy> perhaps you terminal simply can't handle long lines
14:10:01 <davidkart> well, it is definitely the virtual terminal that is stuck
14:10:10 <ertes> davidkart: try this in konsole:  mapM_ print [1..]
14:10:36 <ertes> same thing, but each number on a separate line
14:10:51 <davidkart> ertes: it is stuck all the same
14:11:05 <davidkart> :) thanks for the advice.
14:11:21 <ertes> glad it's not GHCi's fault =)
14:11:24 <ertes> would be very confusing
14:11:32 <davidkart> At this point I don't know exactly what to do. Plain old terminal is allright, konsole is not.
14:11:49 <glguy> Now you stop using the broken terminal
14:11:50 <mauke> no issues in tmux/urxvt
14:11:57 <mauke> (also on arch linux)
14:12:04 <davidkart> few xterm is just working very fine and much faster than konsole
14:12:39 <davidkart> gnome-terminal is working just fine.
14:12:43 <ertes> rxvt-unicode works, too
14:12:47 <davidkart> It must be kde/konsole related.
14:13:03 <ertes> i'm a bit surprised konsole has that problem…  seems a weird problem to have for a terminal
14:13:15 <davidkart> yes actually it is.
14:13:22 <davidkart> mauke: could you confirm the bug ?
14:13:31 <EvanR> most terms ive used are broken in some way
14:13:45 <ertes> davidkart: which KDE version?
14:13:49 <EvanR> xterm's only problem being that its hellish to configure
14:13:58 <ertes> i'm going to try this myself
14:14:01 <davidkart> if you are archlinux, the same as the distro's version.
14:14:03 <mauke> davidkart: I ran ghci in konsole, then [1..], then ^C
14:14:05 <mauke> no issues
14:14:08 <ertes> davidkart: 4 or 5?
14:14:33 <ertes> i'll just try both
14:14:57 <davidkart> Version 16.04.3 of Konsole ; 
14:14:57 <davidkart> KDE Frameworks 5.24.0 ;
14:14:57 <davidkart> Qt 5.7.0 (built against 5.7.0)
14:15:26 <davidkart> The xcb windowing system
14:15:29 <mauke> same
14:15:40 <davidkart> so it just works for you ?
14:15:57 <mauke> [1..] and ^C? yes
14:16:06 <ertes> konsole from KDE 4 works
14:16:30 <glguy> It could be something specific about the configuration of konsole, scrollback size, etc. But at this point it's not a #haskell issue
14:16:30 <davidkart> I just spotted it works one time over 2.
14:16:36 <davidkart> (or 3 for that matters)
14:17:18 <ertes> glguy: i'll just see if i can confirm it for davidkart
14:19:28 <davidkart> it is definitely an Input/Output bug of Konsole.
14:19:43 <davidkart> and a really weird one.
14:23:24 <ertes> davidkart: neither KDE 4 konsole no KDE 5 konsole gets stuck for me, but i do observe very slow text rendering, so maybe it's just very slow…  consider switching to a different terminal emulator
14:23:45 <geekosaur> or a simpler font maybe
14:23:46 <davidkart> ok
14:24:17 <davidkart> no kate seems broken to me. Indeed, it is very slow rendering. It must be a race condition that I trigger in someway because of my system or something else.
14:24:45 <davidkart> thanks for your kind answers.
14:24:58 <dxtr> What library should I use to parse XML?
14:25:40 <ertes> dxtr: i've used xml-conduit with success
14:25:46 <dxtr> Right!
14:26:03 <dxtr> I wanna do a lot of weird stuff with XML 
14:26:12 <cocreature> xml-conduit is quite nice
14:26:20 <cocreature> and you don’t need to understand conduit to use it
14:26:36 <ertes> dxtr: if "weird stuff" involves malformed XML, there is also tagsoup
14:26:54 <cocreature> ere is also html-conduit
14:27:09 <cocreature> if your misformed xml happens to be html :) 
14:27:35 <dxtr> ertes: Not malformed! That's one of those things I want to check for
14:28:16 <dxtr> But want I want to do is parse 300-400 XML files and find conflicting stuff
14:28:21 <dxtr> Possibly even find stuff that doesn't make sense
14:28:51 <dxtr> So yeah, a lot of cross-referencing
14:29:50 <dxtr> I'm not sure if it's even doable in a reasonable manner but that's why I want to try it
14:55:11 <davidkart> If I do (length x), what is the complexity of the algorithm used internally ?
14:55:26 <mauke> O(n)
14:55:50 <davidkart> isn't it subefficient ?
14:56:10 <mauke> it can't be faster or slower
14:56:20 <davidkart> well it depends on the data structure.
14:56:26 <davidkart> On an array, it would be O(1)
14:56:27 <mauke> :t length
14:56:28 <lambdabot> Foldable t => t a -> Int
14:56:35 <mauke> oh, I was assuming [a] -> Int
14:57:11 <davidkart> Foldable is not making asumption on the type ? (ie, it could be list, array, anything else ?)
14:57:21 <Iceland_jack>     length @[] 
14:57:22 <Iceland_jack>       :: [a] -> Int
14:57:32 <hpc> :t length
14:57:34 <lambdabot> Foldable t => t a -> Int
14:58:09 <davidkart> ok thanks
14:58:50 <geekosaur> if you are looking for a data structure faster than a linked list, consider Vector
15:00:12 <Iceland_jack>     length @Vector  ::  Vector a -> Int
15:00:49 <davidkart> I finally finished the mastermind solver. If you are interested : http://pastie.org/10909435
15:01:35 <mekeor> so, i want to modify the package clckwrks-theme-bootstrap from hackage locally and test it using a project called example-dot-com. example-dot-com depends on clckwrks-theme-bootstrap. how would i make example-dot-com use my local version automatically  
15:02:16 <mekeor> ... *local version of clckwrks-theme-bootstrap automatically using stack?
15:02:26 <Iceland_jack> mekeor: Fun trick, you can write
15:02:26 <Iceland_jack>     [Red .. Purple]
15:02:26 <Iceland_jack> if you derive Enum and Bounded for Peg
15:02:36 <Iceland_jack> Instead of listing them manually
15:02:36 <Iceland_jack>     
15:02:36 <Iceland_jack> {-# OPTIONS_GHC -Wall #-}
15:02:36 <Iceland_jack> module HW02 where
15:02:38 <Iceland_jack> -- Mastermind -----------------------------------------
15:02:42 <Lambdanaut> Hey all. Been a while since I've Haskelled. Is "lens" still the best way to treat a Type as an imperitive Object? 
15:02:43 <Iceland_jack> -- A peg can be one of six colors
15:02:46 <Iceland_jack> data Peg  =   Red
15:02:49 <Iceland_jack>             | Green 
15:02:52 <Iceland_jack>             | Blue 
15:02:54 --- mode: ChanServ set +o glguy
15:02:54 --- kick: Iceland_jack was kicked by glguy (Iceland_jack)
15:04:00 <Lambdanaut> by "lens" I mean the lens library in hackage
15:06:09 --- mode: glguy set -o glguy
15:06:44 <davidkart> Iceland_jack: thanks
15:07:01 <davidkart> actually you can just do [Red ..]
15:07:04 <davidkart> it works
15:07:21 <Iceland_jack> True true
15:07:31 <Iceland_jack> davidkart: You can write exactMatches as
15:07:31 <Iceland_jack>     exactMatches xs ys = sum (zipWith (\x y -> if x == y then 1 else 0) xs ys)
15:08:09 <davidkart> ho yeah, the style was bad on that one.
15:08:22 <Iceland_jack> Or using ParallelLispComps
15:08:22 <Iceland_jack>     exactMatches xs ys = sum [ if x == y then 1 else 0 | x <- xs | y <- ys ]
15:08:22 <Iceland_jack>     exactMatches xs ys = sum [ fromEnum (x == y)       | x <- xs | y <- ys ]   
15:08:29 <Iceland_jack> the last one is not a great idea
15:09:03 <davidkart> Iceland_jack: your fist suggestion is far better than the two others.
15:09:14 <davidkart> (I believe actually)
15:09:27 <Iceland_jack> I agree
15:09:55 <davidkart> thank you I have to get used to functional constructs and I dont want to go far away from good style and practices.
15:10:31 <davidkart> Iceland_jack: I should have come with this solution first but I need a little more reading.
15:10:51 <Iceland_jack> You do a very similar thing in 'matches'
15:11:16 <mekeor> let me ask again: anyway, so, i've got ~/proj-dep/ and ~/proj-main/. when i build proj-main after i modified proj-dep, i'd like stack to build and use the new version of proj-dep automatically. is adding "../proj-dep" to the list of packages in ~/proj-main/stack.yaml the correct way?
15:11:26 <koshmar> how to start xmonad in ghci inside another xmonad so internal xmonad doesnot read .xmonad/xmonad.hs. (version - newest from github). before I could use "xmonad defaultConfig", but it get depricated and the function buildLanch is inside xmonad. (for timebeeing I replaced buildLanch with return ()) 
15:12:11 <mekeor> koshmar: did you try #xmonad? :P
15:12:31 <koshmar> oh sorry ) I will
15:14:00 <hexagoxel> i have type Foo = Maybe Bar. I make use of the instances (e.g. Monad) for the Maybe. Now, I would like to avoid Maybe-blindness and thus define Foo differently. Is there something better than writing a custom equivalent of Maybe, including necessary instances, to avoid blindness? (i.e. type Foo = MyNonBlindMaybe Bar)
15:14:39 <Iceland_jack> hexagoxel: you can always use a 'newtype' and GeneralizedNewtypeDeriving (GND)
15:15:12 <hexagoxel> Iceland_jack: Maybe has two constructors.
15:15:19 <Iceland_jack>     newtype ServerUp a = ServerUp (Maybe a)
15:15:36 <Iceland_jack> Then you can use pattern synonyms to hide (ServerUp Nothing) and (ServerUp (Just x))
15:15:54 <Iceland_jack> And derive Functor/Applicative/Monad/...
15:16:00 <Kimae> "[...] Monad type class does not require a Functor instance, even though mathematically speaking, every monad is a functor." Is that still correct?
15:16:06 <Iceland_jack> Kimae: No
15:16:09 <geekosaur> as of 7.10, no
15:16:18 <Kimae> alright thanks
15:16:32 <Iceland_jack> We have
15:16:32 <Iceland_jack>     class                  Functor f
15:16:32 <Iceland_jack>     class Functor     f => Applicative f
15:16:32 <Iceland_jack>     class Applicative f => Monad f
15:16:51 <hpc> the googlable term is "applicative monad proposal"
15:17:08 <hpc> and it took years of work to get it through
15:17:57 <hpc> it's an interesting bit of history to learn, since there aren't very many other languages which have changed something that major so seamlessly
15:18:25 <Iceland_jack> hpc: https://github.com/quchen/articles/blob/master/applicative_monad.md
15:18:38 <hexagoxel> Iceland_jack: thanks (another extension to get familiar with. yay :p)
15:19:12 <Iceland_jack> The proposal doesn't require an extension?
15:19:22 <Iceland_jack> Are you refering to GND
15:19:31 <Iceland_jack> *referring
15:20:11 <geekosaur> no, it is not GenericNewtypeDeriving, and it does not require an extension
15:20:22 <geekosaur> it is a library change, not a language change
15:20:41 <Iceland_jack> Where does Generic* come from
15:20:52 <Kimae> i wonder why there still is liftM then?
15:20:56 <quchen_> Monad is part of Haskell, so the AMP is a language change too
15:20:58 <Iceland_jack> Kimae: Historical
15:21:05 <geekosaur> backward compatibility
15:21:11 <quchen_> (Applicative has to be in the standard now, for example)
15:21:21 <monochrom> for a seamless change, you don't want a function name to disappear overnight.
15:21:27 <Kimae> really interesting :)
15:22:28 <monochrom> instead, you want it to disappear gradually over many years. For example, rename liftM to iftM for the 1st 5 years, then rename to ftM for the 2nd 5 years, etc, until the last letter also disappears.
15:22:36 <Iceland_jack> hah
15:23:10 <quchen_> monochrom: `M` would be a lexical error, we’ll have to figure something out for this
15:23:25 <Kimae> ^^
15:23:35 <monochrom> yes, this is where "but it is really a language change" comes into play!
15:24:05 <monochrom> i.e., for the final 5 years, there is a language change for allowing M to be a function name
15:24:26 <Iceland_jack>     "liftM is fmap but not really." - "So when should I use fmap and when liftM?" - sigh
15:24:26 <Iceland_jack> That's already a distant past, phew.
15:24:33 <zenobit> is there such a thing as a 'binmap' that can take two parameters?
15:24:35 <Iceland_jack> Or it feels that way 
15:24:38 <Iceland_jack> :t bimap
15:24:39 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
15:24:47 <zenobit> the function, rather.
15:24:54 <Iceland_jack> :t bimap :: (a -> a') -> (b -> b') -> (Either a b -> Either a' b')
15:24:55 <lambdabot> (a -> a') -> (b -> b') -> Either a b -> Either a' b'
15:25:05 <Iceland_jack> :t bimap :: (a -> a') -> (b -> b') -> ((a, b) -> (a', b'))
15:25:06 <lambdabot> (a -> a') -> (b -> b') -> (a, b) -> (a', b')
15:25:17 <zenobit> like a map.. but I have two lists.
15:25:48 <monochrom> what does binmap mean? and no, I don't understand the latest explanation
15:25:53 <Iceland_jack> zenobit: If you want two lists you'd have to define
15:25:53 <Iceland_jack>     data TwoLists a = TL [a] [a]
15:25:54 <Iceland_jack>     instance Bifunctor TwoLists 
15:25:55 <zenobit> so I map over both of them and return a list with the changed elements. like, say I wanted to add two lists together.
15:26:09 <Iceland_jack> oops
15:26:11 <monochrom> is that zipWith?
15:26:13 <Iceland_jack>     data TwoLists a b = TL [a] [b]
15:26:14 <zenobit> not sure what the term for that function would be..
15:26:17 <Iceland_jack> zenobit: You don't want "bimap"
15:26:19 <zenobit> monochrom: I thought about zip.
15:26:30 <Iceland_jack> :t zipWith (+)
15:26:31 <lambdabot> Num c => [c] -> [c] -> [c]
15:26:32 <monochrom> Zip has little to do with zipWith
15:26:32 <zenobit> Iceland_jack: yeah, I was just thinking "okay it's a binary operation and it's mapping over two lists.."
15:26:39 <Iceland_jack> > zipWith [1,2,3] [10,20,30,40]
15:26:41 <lambdabot>      Couldn't match expected type ‘Integer -> b -> c’
15:26:41 <lambdabot>                  with actual type ‘[Integer]’
15:26:41 <lambdabot>      In the first argument of ‘zipWith’, namely ‘[1, 2, 3]’
15:26:44 <Iceland_jack> > zipWith (+) [1,2,3] [10,20,30,40]
15:26:45 <lambdabot>  [11,22,33]
15:26:52 <zenobit> awesome, that's the term. thanks so much.
15:27:08 <zenobit> jog the ol' memory. :)
15:27:35 <Iceland_jack> zenobit: Note that you could have implemented it with 'zip' thusly
15:27:35 <Iceland_jack>     [ x + y | (x, y) <- zip [1,2,3] [10,20,30,40] ]
15:28:11 <Iceland_jack> @zip
15:28:11 <lambdabot> Maybe you meant: id bid
15:28:12 <zenobit> Iceland_jack: I'm aware, good ol' list comprehensions. problem is I'm writing something in C, not haskell, and I have an equivalent operation. just wanted to remember what the term was.
15:28:14 <Iceland_jack> @src zip
15:28:14 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
15:28:14 <lambdabot> zip _      _      = []
15:28:17 <Iceland_jack> @src zipWith
15:28:17 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
15:28:17 <lambdabot> zipWith _ _      _      = []
15:28:25 <Iceland_jack> gotcha
15:28:34 <zenobit> anyway, thanks! cheers!
15:28:48 <Zemyla> There needs to be align and These in the core library.
15:29:11 <hexagoxel> Iceland_jack: but i need -XPatternSynonyms, right?
15:30:00 <hexagoxel> how do i write the pattern synonym type signature?
15:30:27 <glguy> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=pattern%20synonyms#ghc-flag--XPatternSynonyms
15:36:15 <hexagoxel> `pattern Foo :: ..`, i see. thanks.
16:07:03 * hexagoxel runs into the known exhaustive-checking problems with PatternSynonyms.
16:08:48 * hackagebot text-icu-normalized 0.1.5.1 - Dealing with Strict Text in NFC normalization.  https://hackage.haskell.org/package/text-icu-normalized-0.1.5.1 (misandrist)
16:12:22 <hexagoxel> this means the syntactical overhead of the PatternSynonym approach is non-constant. meh.
16:15:03 <Kimae> Is there a reason why values "travel" from left to right with monads using >>= and from right to left without monads using $. I fell like there should be an infix function a -> (a -> b) -> b
16:15:27 <hexagoxel> :t (&)
16:15:28 <lambdabot> a -> (a -> b) -> b
16:15:29 <mniip> :t (Data.Function.&)
16:15:31 <lambdabot> a -> (a -> b) -> b
16:15:54 <mniip> :t (=<<)
16:15:55 <lambdabot> Monad m => (a -> m b) -> m a -> m b
16:16:05 <mniip> :t (>>>)
16:16:06 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
16:16:43 <Kimae> oh nice, didn't find it using hoogle. arg
16:42:02 <Xe> is there any documentation out there how to take a C function passed as a function pointer to haskell and then conditionally execute it?
16:42:22 <Xe> the haskell function is loaded as a shared object being called out from C
16:44:52 <johnw> yes, there is documentation out there to do that :)
16:49:53 <glguy> Xe: Haskell Report 2010, Section 8.5.1, "dynamic" stub
16:51:54 <Xe> glguy: https://gist.github.com/Xe/651aae25542e80af7d26eb34a311bfb8 is the exact problem and error message I am getting
16:54:29 * dfeuer is not pleased with the way GHC's Generic class throws away information about recursive structure.
16:56:04 <dfeuer> For instance, I'd want the instance for GNFData (a :*: b) to force a non-recursive field before a recursive one, but it has no way to pin that down.
16:56:05 <glguy> Xe: You need: let success = mkFun x
16:56:38 <glguy> Xe: What you wrote is just a type error as you pasted
16:57:21 <glguy> mkFun :: FunPtr (CString -> IO CInt) -> CString -> IO CInt
16:57:46 <glguy> so, success <- mkFun x   -- isn't going to work,  mkFun x :: CString -> IO CSing
16:57:49 <glguy> so, success <- mkFun x   -- isn't going to work,  mkFun x :: CString -> IO CInt
16:59:50 <carnufex> exit
17:23:51 * hackagebot Concurrent-Cache 0.2.1.0 - A Cached variable for IO functions.  https://hackage.haskell.org/package/Concurrent-Cache-0.2.1.0 (Ofenhed)
17:59:16 <parsnipM_> any ideas on after running `stack build --profile` ? i get this error when trying to run ghc to profile: http://lpaste.net/170061
18:00:06 <parsnipM_> maybe my arithmoi shouldn't be in .cabal? 
18:01:24 <parsnipM_> hmm, maybe `cabal install --reinstall -p arithmoi` will be sufficient, trying now. 
18:03:08 <parsnipM_> nope, says lots of other items are not ready for profiling
18:03:24 <parsnipM_> maybe ghc doesn't know where the stack installed libraries are
18:06:38 <mirpa> parsnipM_: ghc knows nothing about cabal/stack
18:08:46 <parsnipM_> okay, now i'm trying `stack build --ghc-options="-fprof-auto -rtsopts" --enable-executable-profiling --enable-library-profiling`
18:08:53 * hackagebot monad-logger-prefix 0.1.3 - Add prefixes to your monad-logger output  https://hackage.haskell.org/package/monad-logger-prefix-0.1.3 (parsonsmatt)
18:09:21 <parsnipM_> er, i guess i already had that approximately, but i need to try calling the profiler with stack instead of ghc. 
18:09:52 <mirpa> parsnipM_: use 'stack build --profile' to build with profiling support and then 'stack exec <exec> -- +RTS <rts options>'
18:18:04 <parsnipM_> okay, will try soon, i think i may be rebuilding again :(
18:19:48 <mirpa> parsnipM_: btw if you are just working on Euler problems with libraries from base, then you might be ok with 'ghc --make ...'
18:25:02 <parsnipM_> mirpa: but if my file has an import, wouldn't `ghc` have to know where the library is, and especially the one installed with profile option? 
18:26:40 <dramforever> parsnip: GHC has a local database for that
18:27:24 <lambdafan> I'm making a closed type family that begins (class ( BoundingBox bbox, Vector vect) =>                 KdTreeRegional bbox vect where
18:27:25 <dramforever> And apparently it needs the entire world to be compiled with profiling enabled
18:27:46 <dramforever> So I'm afraid you _are_ rebuilding again. :(
18:28:21 <lambdafan> How can I require Vector vect to be determined by BoundingBox bbox. What I am trying to avoid is instance like this "instance KdTreeRegional BBox2 Vector3"
18:29:15 <lambdafan> if it's an instance for BBox then the instance must be "instance KdTreeRegional BBox3 Vector3
18:29:42 <lambdafan> I mean "If it's an instance for BBox3"
18:29:42 <ertes> lambdafan: do you want the *constraint* to be implied, or do you want the bbox to follow from vect?
18:30:15 <parsnipM_> dramforever: so do i sort of have a choice whether i want to profile with ghc or stack? 
18:30:15 <lambdafan> ertes: I want vect to follow from bbox
18:30:36 <ertes> lambdafan: first of all, this doesn't seem to have anything to do with closed type families
18:30:47 <ertes> lambdafan: there are two approaches:  functional dependencies and associated types
18:31:14 <ertes> lambdafan: the fundep way:  class C a b | a -> b  -- the type 'b' follows from the type 'a'
18:31:45 <lambdafan> ertes: anything special I have to do in the instance?
18:31:46 <ertes> lambdafan: the AT way:  class C a where type F a  -- F acts as a type function on the instance types
18:32:19 <ertes> in the fundep variant no…  it's just a restriction and helps type inference (whenever 'a' is determined, 'b' follows from it)
18:32:36 <ertes> in the AT variant you do this:  instance C A where F A = B
18:32:43 <ertes> whoops
18:32:45 <ertes> in the AT variant you do this:  instance C A where type F A = B
18:33:32 <lambdafan> ertes: I tried functdep way, getting error.  I will post
18:35:10 <lpaste> lambdafan pasted “Converage Condition Fails” at http://lpaste.net/170064
18:35:55 <ertes> lambdafan: don't use equality constraints like that
18:36:21 <ertes> instance KdTreeRegional BBox3 Vector3 where …
18:37:59 <lambdafan> ertes : hmm okay, those equality constraints were solving another problem
18:39:04 <ertes> lambdafan: instance contexts aren't used for instance resolution, so during resolution your instance looked like an instance for *all* pairs of types
18:39:35 <ertes> and that violates the fundep, because the vector type does not follow from the bbox type
18:39:52 <lambdafan> ertes: got it, I'm chaning it now
18:43:44 <lambdafan> ertes: now I am back to the problem the equality constraints were solving. I'll post and maybe there is another solution. Maybe this is a code smell.
18:48:17 <lpaste> lambdafan pasted “The type variable ‘bbox1’ is ambiguous” at http://lpaste.net/170066
18:50:10 <glguy> lambdafan: That paste seems confused. KdTreeRegional shouldn't have a data declaration inside of it, and Axes isn't even declared as a data family much less as an associated one
18:51:23 <lambdafan> glguy, I will add LANGUAGE pragmas I am using
18:51:29 <glguy> are lines 22 and 23 supposed to be indented under the class definition?
18:52:00 <lpaste> lambdafan revised “The type variable ‘bbox1’ is ambiguous”: “The type variable ‘bbox1’ is ambiguous” at http://lpaste.net/170066
18:52:20 <lambdafan> glguy, yes
18:52:51 <glguy> lambdafan: attrib_values must mention the type bbox
18:53:42 <glguy> Perhaps the Axes associated data family should be parameterized by bbox rather than vect
18:53:45 <lambdafan> glguy: okay, this was once a where clause. I was trying to reduce the size of the function by brining it out
18:54:02 <lambdafan> gluguy: hmm, let me re-think that!
18:55:24 <lambdafan> glguy: that's a good idea, I am going to go with that
18:55:32 <lambdafan> glguy: Thanks :)
18:59:03 <lambdafan> glguy: it works :)
18:59:20 <lambdafan> it *was* a code smell, thanks for helping me fix it
19:00:56 <glguy> Before it was just wrong, the mixture of functional dependencies and associated data types is probably a "smell", if that's useful way of describing code
19:01:51 <lambdafan> glguy: okay as long as I get the same behavior I can use the other technique
19:02:02 <lambdafan> I will scroll up it was explained earlier
19:02:57 <jle`> is there a conduit sink that just evaluates everything and returns () ?
19:35:58 <joe9> hello, I have a Data.Map.Strict.Map of [(1,1),(2,1]),(3.1),(4,2)] structure and I want to remove all the elements with the same value as the previous value. For example, to [(1,1),(4,2)] result. Other than the fold operations, is there a better way of going about this? Should I be using Data.Foldable?
19:37:37 <mjrosenb> joe9: I assume the first ']' was a typo?
19:44:38 <joe9> mjrosenb: yes, sorry about that.
19:45:26 <glguy> joe9: Map isn't suitable for that operation. Convert to a list with toList, filter it out, and then back to a Map with fromList
19:45:49 <c_wraith> you could even use fromAscList
19:46:12 <glguy> You don't need to, fromList is fast on a sorted list
19:47:01 <joe9> glguy: for filter, I would have to check that item with the previous value. it probably should be some version of fold, correct?
19:47:31 <Iceland_jack> joe9: You can always zip it with its tail
19:47:31 <Iceland_jack> > zip [1,20,300] (tail [1,20,300])
19:47:32 <lambdabot>  [(1,20),(20,300)]
19:47:35 <joe9> [(1,1),(4,2),(5,1)] is a possible result if I extend it.
19:47:53 <joe9> Iceland_jack: oh, cool.
19:47:56 <shachaf> fromAscList is the one that's not Unicode-compatible, right?
19:48:35 <glguy> joe9: I'd recommend using recursion to implement the filter operation you have in mind
19:48:55 <joe9> glguy, ok, Thanks. seems the most comprehensible.
19:51:05 <mjrosenb> wait, isn't that filter operation just head . groupBy (\l r -> snd l == snd r)?
19:53:47 <joe9> mjrosenb: That is way cool. Thanks. cannot believe that it can be so simple.
19:55:15 <mjrosenb> I hope you test it first before trusting what I said without fully understanding what you're trying to do.
19:55:44 <mjrosenb> joe9: also, haskell is pretty good at very compact solutions that are not always decipherable.
19:56:13 <mjrosenb> (I know the argument to groupBy can be shorter, but it requires a function that I don't happen to remember).
19:56:51 <dmj`> is there a way to conditionally remove a typeclass constraint based on a value
19:58:11 <mniip> what would the type of such expression be
19:58:34 <glguy> You want the type to depend on the value?
20:00:24 <dmj`> basically yes, for example, if I have a Config type with a boolean, I'd like add a HasFoo constraint onto the type variable 'a' based on the True / False value of the boolean in Config
20:00:32 <dmj`> I'd like to*
20:01:38 <glguy> You can make a sum type of the various possibilities where each member of the sum is a value with different constraints
20:03:09 <dmj`> glguy: can we conditionally apply type class constraints on type variableswith type families? If so, maybe this sum type could have a phantom type with kind Bool, and a type family can turn the constraint on and off
20:03:37 <dmj`> based on the type of kind Bool
20:03:54 <glguy> The bool is more or less irrelevant
20:04:41 <dmj`> how would we add different constraints to each sum type?
20:06:30 <dmj`> glguy: data Foo a b = HasThing a => LeftFoo a | HasOtherThing b => RightFoo b
20:06:59 <glguy> The context goes inside the constructor
20:07:37 <glguy> I'm not saying this is useful, but I think it's what you're asking about
20:11:16 <glguy> If this is a run time configuration value then you'll have to satisfy the constraints required for both the true and false cases at compile time
20:11:45 <glguy> If it's compile time configuration you can use template Haskell
20:14:46 <dmj`> it would be runtime
20:15:17 <dmj`> maybe I can just remove the typeclass altogether
20:18:07 <dmj`> glguy: ah, I need the typeclass because there is a function where I need to gain access to the config, but cannot simply pass the config into the function as an additional parameter
20:20:20 <srpx> What specifically is `Control`? When should I use that namespace?
20:20:45 <_6a68> hi all, what's a nice introduction to functional data structures / algorithms in haskell? I'm new to haskell, write imperative code for a living, know basic undergrad CS and some category theory.
20:20:50 <dmj`> maybe I can use a closure
20:20:54 <srpx> Also, where should I put `call :: Int -> (a -> a) -> a -> a`, which calls a function N times on its argument?
20:21:09 <dmj`> @google okasaki pfds
20:21:10 <lambdabot> https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
20:21:40 <dmj`> _6a68: although, you can just do dirty mutable things in haskell too with vector
20:22:13 <glguy> What type is good for clean mutable things?
20:22:29 <joe9> Is there an efficient way of finding the last element of a Data.Map.Strict.Map data structure? I read about findMax but, it seems to be going through all the elements.
20:22:30 <nitrix> srpx: Would you be interested to know we already have such function to do exactly that?
20:22:51 <dmj`> glguy: immutable vectors :) 
20:22:53 <srpx> nitrix: yes what is it called?
20:23:19 <nitrix> srpx: iterate. But it yields a list of all the intermediate results of the applications.
20:23:39 <nitrix> > take 10 $ iterate (+1) 0
20:23:40 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
20:23:52 <srpx> I expected you'd say that, `call` is **much** faster than iterate (with proper strictness and tco)...
20:23:56 <srpx> Thanks though
20:25:06 <_6a68> dmj`: thx!
20:25:58 <_6a68> I've looked at okasaki but never worked through it. any other refs that come to mind? I'm more interested in thinking functionally than anything else
20:26:14 <dmj`> @google snoyman vector
20:26:15 <lambdabot> https://github.com/commercialhaskell/haskelldocumentation/blob/master/content/vector.md
20:26:19 <dmj`> _6a68: ^
20:26:21 <dmj`> that's a good read
20:26:41 <dmj`> you'll be writing imperative algorithms in no time
20:26:53 <nitrix> srpx: I see. Disregard that then.
20:27:13 <srpx> nitrix: no problems! Thank you
20:29:09 <_6a68> dmj`: that repo seriously looks great. thank you
20:34:31 <roboguy`> There isn't a nice way to make a tree data type where each level is guaranteed a consecutive prime number of children (the root has two children, they each have three children, those children have five children, etc), though the use of a non-regular type or the sort of techniques Okasaki uses is there?
20:35:45 <mniip> GADTs and UndecidableInstancees
20:35:54 <mniip> with that it sure is possible
20:35:58 <roboguy`> hmm
20:36:14 <mniip> not sure about the "nice" part
20:36:50 <roboguy`> ha. Well, I just thought of a potential use for such a tree so I thought it might be interesting to try and encode that invariant into the type if possible
20:45:14 <peddie> roboguy`: something like fibonacci numbers is probably _way_ easier, because it's much simpler to express it as a recurrence and build the tree inductively.  what use did you think of, out of curiosity?
20:45:24 <adarqui> can you use pandoc to convert haddocks to markdown? I want to generate haddock and then convert to markdown inside my git repository ;f
20:47:03 <dmj`> adarqui: you could use github pages to host your haddocks, with the gh-pages branch
20:47:12 <dmj`> https://pages.github.com/
20:47:22 <roboguy`> peddie: yeah, I thought about that. Not sure it'd work for this though. My thought is that if you have a set of items, each with an associated probability (where all the probabilities add up to 1), you could put each item at a leaf of a "prime tree". This would be so that you can pick items with appropriate probability if you randomly pick a child at each level as you traverse it until you reach a leaf
20:47:35 <dmj`> adarqui: unsure about converting them to markdown though
20:47:38 <roboguy`> I'm sure it's not the simplest way to solve that problem, but I thought it might be fun
20:48:10 <adarqui> dmj`: cool thanks! ya i'll try in a bit and report back hehe.
20:48:20 <dmj`> adarqui: k, cool :)
20:48:37 <peddie> roboguy`: I'm not sure I understand the relationship between primes and probabilities here.  also what if you have a tree with e.g. 4 elements?  but it sounds fun :)
20:48:39 <roboguy`> peddie: Primes work because you can construct any natural number as a product of primes
20:49:08 <peddie> but it sounds like the tree has certain numbers of nodes of each size
20:49:11 <roboguy`> peddie: and the probabilities of the leaves being picked end up getting multiplied: https://www.mathsisfun.com/data/probability-tree-diagrams.html
20:49:47 <peddie> ok, I think I see what you're getting at.
20:49:54 <roboguy`> a tree with 4 elements would work because you'd have one element in the left child of the root (a leaf) and the right child of the root would have three leaves
20:50:19 <adarqui> is there a react-flux channel on freenode? if any1 knows
20:50:25 <peddie> ah OK, I misunderstood the relationship between the orders of nodes on consecutive levels of the tree
20:50:29 <peddie> neat
20:50:43 <mjrosenb> roboguy`: how would you express a coin that comes up heads 3/4 of the time, and tails 1/4 of the time?
20:50:51 <adarqui> it doesn't seem to be used too much, from what i see .. but it's a really nice library
20:51:12 <peddie> roboguy`: hm, you could also have 2 2s?  I don't see how 1 and 3 is related to the product of primes exactly
20:52:31 <peddie> I guess all siblings have to have the same order, and then you get a product
20:53:07 <roboguy`> mjrosenb: I'm also imagining that you could have the same element from the set occur in multiple leaves. So you'd have heads once at the left leaf of the root and once as a leaf of the right child of the root (I think0
20:53:50 <roboguy`> I might have to draw this out and do some more thinking on it though =)
20:53:52 <mniip> @letlpaste 3434255248586178560
20:53:53 <lambdabot>  Parse failed: Parse error: -
20:54:04 <mniip> u wot m8
20:56:23 <mjrosenb> roboguy`: So, making up something like a datatype Node2 [Leaf Heads, x]?
20:56:27 <roboguy`> mjrosenb: oh wait, that would be for 2/3 vs 1/3
20:56:51 <roboguy`> yeah, I think so
20:57:47 <mjrosenb> and what would x be here?
20:58:17 <roboguy`> a node with three children
20:59:11 <mjrosenb> with 1.5 elements Heads and 1.5 elements Tails?
21:00:53 * geekosaur sends mjrosenb a benzene ring >.>
21:00:54 <roboguy`> ha, no. You'd need to go a level down at least, if it does end up working
21:02:19 <mjrosenb> geekosaur: mmmm, tasty tasty aromatized carbon
21:02:26 <travism> So i tried install cassava the first time it caused a core dump with cabal. Then I tried running it agian, it downloaded it but cassava fails to build. Should it be reported? I didn't see any reports on the issues tracker on github?
21:02:38 <roboguy`> hmm, you'd need a way to decompose an arbitrary rational number into a sum of "reciprocal natural numbers", given some constraints (which I'm not sure what they are yet)
21:02:54 <travism> and apparently I can't type today..
21:03:19 <mjrosenb> roboguy`: I suspect that you will be hard pressed to find any combination of 3,5,7,11,13, etc. that will yield half heads and half tails.
21:04:18 <roboguy`> mjrosenb: well, you can definitely generate any rational number probability that has 1 in the numerator with those combinations
21:05:20 <roboguy`> since you can have the same element at multiple leaves, that should allow for numbers with factors that have multiplicity > 1 also
21:06:03 <mjrosenb> roboguy`: I am unconvinced.
21:06:22 <roboguy`> mjrosenb: also, half heads, half tails is easy: tails is the left leaf of the root, heads is the right leaf of the root
21:06:31 <roboguy`> (you forgot 2)
21:07:09 <mjrosenb> roboguy`: right, but this was for the 1/4, 3/4 case.  the root already has the entire left side dedicated to heads.
21:07:31 <mjrosenb> then the right node needs to be half heads half tails, but you've already used your even depth.
21:08:58 * hackagebot stackage-curator 0.14.1.1 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.14.1.1 (MichaelSnoyman)
21:09:27 <mjrosenb> roboguy`: requiring one in the numerator doesn't save you.
21:11:14 <mniip> roboguy`, lambdabot seems to not like the paste, but take a look http://lpaste.net/1460255259636006912
21:11:27 <mniip> then you can have like
21:11:48 <roboguy`> mjrosenb: what if you don't take up the entire left half with just heads and you go down at least one level on both sides? So you make the 3/4s heads in a different way?
21:12:11 <roboguy`> mniip: oh very cool! Thanks!
21:12:12 <mniip> data FancyTree xs a = FancyTree (Vector (NextPrime xs) (FancyTree (NextPrime xs ': xs) a)) | FancyNil
21:12:19 <mniip> data FancyRoot a = FancyTree '[] a
21:12:24 <mniip> type*
21:12:59 <mniip> oh hm not like that
21:13:45 <mniip> data FancyTree xs n a = FancyTree (Vector (NextPrime xs n) (FancyTree (NextPrime xs n ': xs) (NextPrime xs n) a)) | FancyNil
21:13:47 <mniip> that
21:13:58 * hackagebot wai-middleware-crowd 0.1.4.1 - Middleware and utilities for using Atlassian Crowd authentication  https://hackage.haskell.org/package/wai-middleware-crowd-0.1.4.1 (MichaelSnoyman)
21:15:08 <roboguy`> mjrosenb: hmm, you might be right about running out of a number though
21:16:11 <mjrosenb> roboguy`: so, having the branches be different depths doesn't really affect anything, so let's just pretend that they're all the same depth, having Node2 [Leaf Heads, Node3 [Leaf Heads, Leaf Heads, Leaf Tails] is equivalent to having Node2 [Node3 [Leaf Heads, Leaf Heads, Leaf Heads], Node3 [Leaf Heads, Leaf Heads, Leaf Tails]]
21:16:13 <roboguy`> maybe it would help if each leaf was a list of possibilities, which you then chose from with equal probability of picking each
21:16:22 <Welkin> mniip: is that using type families to simlulate dependent types?
21:16:27 <mniip> no
21:16:39 <Welkin> empty list or non-empty list
21:17:21 <mniip> nope that's type families calculating prime numbers
21:17:27 <mniip> see roboguy`'s problem description
21:17:59 <mjrosenb> roboguy`: then a 1-deep tree will have 2 leaf nodes, a 2-deep tree will have 6 leaf nodes, 3-deep will have 30 nodes, each time taking the product of the first N primes
21:19:23 <mjrosenb> and you can express a probability distribution where the denominator of any given event divides evenly into any number in this list
21:19:47 <mjrosenb> unfortunately, those numbers are vanishingly small.
21:20:01 <mjrosenb> rather a vanishingly small percentage of all numbers.
21:20:30 <mjrosenb> roboguy`: if you're just going to use a list, why have a tree in the first place? :-p
21:21:20 <roboguy`> mjrosenb: ha, yeah
21:21:23 <roboguy`> good point
21:21:24 <roboguy`> hmm
21:54:42 <NeverDie> Hey anyone hiring for Haskell positions here remotely or in NYC?
22:06:39 <mjrosenb> NeverDie: no, but now *I'm* interested in finding out the answer to that question.
22:07:20 <Welkin> just check job boards
22:07:36 <Welkin> stackoverflow has one that's okay
22:09:18 <NeverDie> Welkin: Where at?
22:09:31 <Welkin> on stackoverflow o.o
22:16:09 <NeverDie> Welkin: I mean like a more specific link lol.
22:16:11 <NeverDie> Or a company name.
22:16:55 <Welkin> there's only one way to find out
22:17:04 <glguy> and that's to wait for Welkin to do the work for you
22:26:47 <phanimahesh> :D
22:27:12 <ongy> searching for haskell keyword actually has 2 entries, and one of those actually is a haskell job
23:00:10 <dmj`> have a weird question
23:01:48 <dmj`> suppose I wanted to add one sum type as a field of another sum type, would template haskell be the only way to do this in an automated fashion
23:03:00 <pavonia> Automated in what way?
23:12:35 <travism> How come I cant pass getStdGen from System.Random to the type RandomGen on the normal funcion here when it leads me to it? I keep gettinga type error for IO. https://hackage.haskell.org/package/normaldistribution-1.1.0.3/docs/Data-Random-Normal.html#g:1
23:14:22 <dmj`> pavonia: like, I want to augment one type with another
23:16:04 <dmj`> pavonia: if I had, data A = ThingA; data B = ThingB; I'd like to construct data C = A A | B B
23:16:54 <pavonia> I guess you don't want to use Either?
23:17:29 <pavonia> travism: Because getStdGen is an IO action that returns the generator, you can't pass that to a function that expects the generator directly
23:17:38 <dmj`> pavonia: The sum can potentially have n constructors
23:18:12 <travism> I'm not understanding what I am suppose to pass to it then..?
23:18:26 <pavonia> Hhm, I think there's a generic sum type somewhere already
23:18:50 <dmj`> pavonia: hmm, yes, I'll need to think more about that
23:19:20 <pavonia> travism: You have to execute the IO action and apply normal to the result, e.g. by using fmap or (>>=)
23:19:37 <Eduard_Munteanu> It should be doable with type-level lists and such.
23:20:39 <travism> hmph, thought I tried that. Ill work on that. Thanks
23:25:17 <Eduard_Munteanu> data OneOf xs where This :: x -> OneOf (x ': xs); NotThis :: OneOf xs -> OneOf (x ': xs)   -- something like that
23:30:39 <travism> pavonia: I still must be doing something wrong http://lpaste.net/4979275029293301760
23:30:48 <eklavya> I need to store callbacks in a central place and execute them when their arguments come over network, how to achieve this without mutability?
23:30:57 <eklavya> should I solve a different problem?
23:31:22 <pavonia> travism: Several problems: First, the type of normal must result in an IO action if you use (>>=)
23:31:47 <pavonia> travism: Then you can't match an IO action again a pair, that's a type error
23:32:14 <travism> hmph
23:32:31 <Eduard_Munteanu> eklavya, where would mutation step in?
23:32:58 <joe9> I am trying to figure out how to condense multiple consecutive isSpace characters to a single space
23:33:13 <eklavya> Eduard_Munteanu: that collection of callbacks will be somewhat like global state, no?
23:33:16 <joe9> I cannot figure out how to use isSpace character in the code: unwords $ split (condense . dropDelims $ oneOf "xyz") "aazbxyzcxd"
23:33:20 <travism> This seems a lot more complicated then it really is
23:33:21 <pavonia> travism: Note that once you are in the IO monad, there's no escape, all other code that depends on the values returned by an IO action must run in that monad too
23:33:23 <eklavya> I can't pass around context I think
23:33:29 <joe9> is there any library function that can help, please?
23:33:56 <travism> well it was noted as a "pure function" so I might as well use normalIO ...
23:34:37 <Eduard_Munteanu> > unwords . words $ "abc def    ghi jkl   mno"
23:34:39 <lambdabot>  "abc def ghi jkl mno"
23:35:03 <joe9> Eduard_Munteanu: Thanks.
23:35:52 <Eduard_Munteanu> eklavya, not necessarily, do you need to update that collection?
23:36:04 <eklavya> yes
23:36:25 <travism> like his example doesnt make since then its not as easy as calling it like how he has it then "(sample,g) = normal  myRandomGen"
23:38:58 <Eduard_Munteanu> eklavya, you could put the callback list in a state monad (transformer) or in a IORef referenced by a reader monad (transformer).
23:40:50 <Eduard_Munteanu> eklavya, or just pass it recursively to your network stuff loop
23:42:01 <boj> travism: is it possible you simply want to do something like gen <- getStdGen? you can then pass gen to something with StdGen as its type
23:43:28 <travism> Well I would have to use do notation for that no? I guess I misunderstood this library when it was stated as pure functions.. If everything is IO i might as well just use all the IO functions then.
23:44:17 <Eduard_Munteanu> travism, you just need a stdgen, which you may get from IO or some other way.
23:44:22 <boj> travism: i like to think of "<-" as "extracting the value out of IO". you can then pass "gen" to pure functions, although you'll have to use something like "split" if you want to continue to use random values further downstream
23:44:59 <eklavya> Eduard_Munteanu: let me read up more on that, I might be solving the wrong problem
23:45:05 <eklavya> thanks :)
23:45:58 <Rotaerk> monads are like burritos, with lettuce... and no sour cream... and I'm hungry
23:46:02 <Eduard_Munteanu> travism, you can certainly build your code such that you pass a stdgen around and you only have to getStdGen in, say, main.
23:47:05 <systemfault> I would definitely eat a Monad right now.
23:47:09 <travism> Yeah, I guess I need to rethink how I am making this.
23:49:36 <boj> travism: were you trying to avoid using do notation for some reason?
23:50:01 <travism> I was trying avoid having half my code be in IO
23:50:17 <rhovland> travism: note it's possible (and easy) to generate infinite lists of random numbers, and pass that around, and just access it lazily as you go
23:53:54 <travism> Yeah at first I was trying to write a couple functions to learn about the monte carlo simulation. Now its turned into hours :X
23:54:06 <travism> So I really didn't have a good plan on the design..
23:57:38 <gabbiel> how did you guys learn Brick?
