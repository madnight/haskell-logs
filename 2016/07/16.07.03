00:07:40 * hackagebot list-transformer 1.0.0 - List monad transformer  https://hackage.haskell.org/package/list-transformer-1.0.0 (GabrielGonzalez)
00:07:40 * hackagebot yahoo-finance-api 0.1.0.0 - Read quotes from Yahoo Finance API  https://hackage.haskell.org/package/yahoo-finance-api-0.1.0.0 (cdepillabout)
00:27:30 <adarqui> hey, anyone here have an idea what's going on with hspec discover? i'm running stack test, everything works fine.. prints all of my tests passing.. after making changes or just randomly, it won't run the tests anymore.. it simply compiles the dependencies and says: Completed 3 action(s).
00:27:35 <adarqui> anyone ever run into that?
00:29:37 <Squarism> i do miss a good ide i must say
00:32:35 * hackagebot hascar 0.2.0.1 - Decompress SAPCAR archives  https://hackage.haskell.org/package/hascar-0.2.0.1 (hc)
00:34:50 <adarqui> i can't get stack test to work anymore
00:34:53 <adarqui> heh
00:34:53 <hc> adarqui: hmm, I had a case when "stack test -v" would only show the output of my print when at least one test failed...
00:35:07 <hc> but that's probably intended behavior and not what you are experiencing
00:36:31 <adarqui> thanks hc.. ya i dno what's going on. it just won't run my tests anymore, out of nowhere.
00:36:34 <adarqui> guh !! ;f
00:36:49 <ongy> what's the best way to install multiple versions of ghc? stack? Though I would prefere system installations over project specific
00:37:33 <hc> ongy: stack if it's project specific, and I guess with nixos it's easy to have multiple versions installed systemwide
00:38:07 <ongy> switching linux-distro sounds a bit overkill. But I wanted to try nixos either way...
00:38:23 <hc> 00~https://nixos.org/wiki/Development_Environments01~
00:38:27 <hc> oops https://nixos.org/wiki/Development_Environments
00:39:03 <hc> I've heard you can also use the nix package manager without switching the distro altogether
00:59:34 <saurabhnanda> I'm on a raspberry-pi and have managed to install GHC. However it seems to be a hitting an LLVM-3.5 bug. Although I've installed LLVM-3.7 via apt-get, 3.5 still seems to be the default version on the system. How do I get GHC to use LLVM-3.7?
01:05:33 <efindlay> What function converts a string to html using Text.Shakespeare?
01:48:05 <TimoMeijer> I'm attempting to consume the twitter-conduit library, but can't figure out how to go about it, how would I go about getting from the stream function with result of type '(MonadResource m) => m (ResumableSource m StreamingAPI)' to a regular Source?
01:54:54 <srhb> TimoMeijer: Doesn't Source have a MonadResource instance?
01:56:14 <TimoMeijer> srhb: 'MonadResource m => MonadResource (ConduitM i o m)', so only when the inner Monad is a MonadResource, right?
01:57:06 <srhb> TimoMeijer: In the signature you gave, they're the same m.
01:58:37 <TimoMeijer> srhb: Yes, which is how it's given in the library
02:01:34 <srhb> TimoMeijer: Okay. I'm not sure, aside from using the Conduit operators for resumable sources, sorry.
02:02:28 <nilof> I'm confused by Monad namespaces
02:02:46 <Clint> what are Monad namespaces?
02:03:32 <nilof> well, if I type  [2,3,4,5] >>= (\n -> [n + 1]) it instantly knows that it's supposed to use the List monad
02:03:38 <nilof> and applies map
02:03:40 <TimoMeijer> srhb: Mostly the wrapped and nested MonadResource has me confused, and how to consume it properly, so I can get to the Source
02:03:44 <nilof> how does it do that?
02:04:03 <srhb> :t (>>=)
02:04:04 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:04:21 <Clint> nilof: type inference
02:04:27 <srhb> nilof: So the m is determined by the arguments.
02:04:52 <srhb> nilof: Ie. you gave it a list, so m must be []
02:05:09 <nilof> but suppose you had two monads which both had an a -> [a] type constructor
02:05:17 <nilof> how would it choose which one to use?
02:05:28 <nilof> or is the list type inherently linked to a monad?
02:05:39 <srhb> nilof: instance Monad [] where ...
02:06:20 <Rotaerk> there are other ways of implementing Monad for [], but you'd have to wrap it in a newtype or something, and then implement it for that type
02:11:52 <srhb> nilof: And you cannot normally have duplicate instances
02:12:08 <srhb> nilof: That is, more than one monad instance for one type, in this case.
02:13:11 <srhb> It's easier to see how we resolve this with newtypes in the Monoid case, because it's simpler
02:13:42 <srhb> > (Sum 2 <> Sum 3, Product 2 <> Product 3)
02:13:44 <lambdabot>  (Sum {getSum = 5},Product {getProduct = 6})
02:24:44 <nilof> does this also mean I can technically replace map with fmap everywhere and my code will still work?
02:25:04 <nilof> though the limited type signature of map should be safer
02:25:14 <srhb> TimoMeijer: I wonder if this might be helpful: http://www.yesodweb.com/blog/2012/07/resumablesource
02:25:17 <srhb> nilof: Yes.
02:25:53 <srhb> nilof: There's nothing inherently unsafe with using fmap instead though. Either the type is uniquely determined, or you get a compile time error about the ambiguity.
02:26:40 <srhb> nilof: I tend to use <> instead of ++ for strings and lists, for instance, simply because there's less to remember when you have the general operator and you know you're dealing with a monoid anyway. :)
02:27:49 <srhb> TimoMeijer: Particularly: "This actually works out to a fairly minor change in usage. In many cases, you can simply replace $$ with $$+-, and continue using the library exactly as you did before."
02:30:46 <nilof> true, I can also see how the ++ notation can be confusing since concatenation isn't commutative
02:31:47 <nilof> though I wouldn't expect anyone to make the mistake of assuming it is in practice
02:32:02 <TimoMeijer> srhb: Okay, so I can simply use the ResumableSource, or unwrap it. But what about the MonadResource it's wrapping/nested in?
02:32:40 <srhb> nilof: No, I hadn't even thought of that in fact. But I see your point.
02:33:30 <srhb> TimoMeijer: Well at one point you have to run your resource regardless, I assume.
02:35:54 <srhb> TimoMeijer: Ie. with runResourceT or whatever. :)
02:35:57 <TimoMeijer> srhb: Yes, so I'll have to have a ResourceT in the transformer stack, and a runResourceT to consume it. My confusion is as to why there are two MonadResource instances, do I need to have two ResourceT's that I'll have to consume separately?
02:36:50 <srhb> TimoMeijer: Sorry, where do you have two again?
02:37:09 <srhb> TimoMeijer: m (ResumableSource m value) ?
02:37:27 <TimoMeijer> srhb: Yes, as m should be a MonadResource
02:37:43 <TimoMeijer> According to the signature
02:38:20 <srhb> TimoMeijer: I'd have to go out on a limb and say the inner one is what makes it resumable at all.
02:38:28 <srhb> TimoMeijer: (You get a new resource to run)
02:38:32 <srhb> TimoMeijer: But I'm not sure. :)
02:39:56 <TimoMeijer> srhb: Hmmm, that might make sense, that the outer MonadResource is to run the whole request, which returns inner MonadResources for every response
02:40:04 <TimoMeijer> I'll see if i can get the types to line up ;)
02:40:18 <srhb> TimoMeijer: Yeah, a tiny working example will probably enlighten quite a bit. :)
02:40:53 <TimoMeijer> srhb: Ye, couldn't find any streaming example in the library documentation :/
02:41:25 <srhb> TimoMeijer: https://github.com/himura/twitter-conduit/blob/master/sample/userstream.hs ?
02:43:58 <lpaste> koz_ pasted “Can I make this allocate less?” at http://lpaste.net/168922
02:44:37 <koz_> If anyone could help me with this question, I'd be very grateful ^.
02:45:51 <lpaste> koz_ revised “Can I make this allocate less?”: “Can I make this allocate less?” at http://lpaste.net/168922
02:48:47 <TimoMeijer> srhb: Thanks, that helps a bit, still struggling to figure otut he types and make them line up though, but I'll manage
02:50:16 <srhb> koz_: Can you remove all that whitespace please.
02:50:27 <srhb> koz_: It's not fun to copy paste that blob :P
02:52:47 <koz_> srhb: My bad, sorry!
02:53:53 <srhb> koz_: It would also be nice to have a sample Main to run it that shows the allocation
02:54:07 <srhb> koz_: (Basically, spoon feed the debuggers and they might drink their coffee and get to work. :-P)
02:54:47 <lpaste> koz_ revised “Can I make this allocate less?”: “Whitespace removed” at http://lpaste.net/168922
02:55:14 <nilof> by the way, is there a left to right alternative to $ ?
02:55:25 <srhb> :t (&)
02:55:26 <koz_> nilof: Lens provides one.
02:55:26 <lambdabot> a -> (a -> b) -> b
02:55:32 <koz_> What srhb said.
02:55:33 <srhb> @index (&)
02:55:33 <lambdabot> Data.Function
02:55:34 <nilof> ah, thanks
02:56:03 <srhb> @hoogle a -> (a -> b) -> b
02:56:06 <koz_> srhb: I can provide one - but I mostly seek some advice about reducing allocation in 'interpret' in general, because I'm pretty sure I'm over-allocating.
02:56:07 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
02:56:07 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
02:56:07 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
02:56:18 <koz_> But sure, I'll add one.
02:56:29 <srhb> koz_: Yes, but in order to test it and see if the advice works, it would be nice to run it on some sample input. :)
02:56:33 <srhb> to be able to*
03:01:44 <koz_> srhb: http://lpaste.net/168922 (as per request)
03:04:24 <lpaste> srhb annotated “Adding sample main” with “Made it compile, for anyone who wants to try optimizing” at http://lpaste.net/168922#a3945702535469203456
03:04:39 <srhb> koz_: ^ That helps too ;-)
03:05:25 <lpaste> koz_ revised “Adding sample main”: “Fixing some glaring issues” at http://lpaste.net/168922
03:06:00 <koz_> srhb: Thanks for that - I keep forgetting not everyone uses BasicPrelude like I do.
03:06:17 <srhb> koz_: Does it import Set and Map types unqualified?
03:06:41 <koz_> srhb: BasicPrelude? Yes.
03:06:47 <koz_> (just the types though)
03:06:48 <srhb> Interesting.
03:10:05 <koz_> srhb: Is that a good 'Interesting' or a not-so-good 'Interesting'?
03:10:25 <srhb> koz_: I don't use it, I'm just surprised. :) I have no opinion whether it's a good idea or not.
03:10:33 <koz_> srhb: Ah, OK.
03:12:20 <fraid> hi, what is the best scripts with vim and haskell?
03:14:05 <srhb> koz_: I removed the `read`s and all I see is allocation going on in GHC.IO.Handle.FD
03:14:35 <srhb> koz_: Do you have a test case that actually reproduces your complaint?
03:14:40 <srhb> Or, well, question. :-)
03:14:44 <koz_> srhb: My codebase?
03:15:06 <lpaste> srhb annotated “Fixing some glaring issues” with “remove read” at http://lpaste.net/168922#a5565724501137686528
03:15:09 <srhb> koz_: ^
03:15:23 <srhb> Oops, I didn't mean to annotate that annotation. ugh.
03:16:04 <koz_> srhb: It's fine. I mean, I can supply my entire codebase and someone can try building and running it if they wanna see that for themselves (under profiling settings, obviously, for which I have a cabal run option).
03:16:18 <lpaste> kritzcreek pasted “linker error” at http://lpaste.net/8793927375143305216
03:16:40 <srhb> koz_: Well, I'm not terribly good at this, but I can't spot any glaring issues. So if there's a leak, it doesn't really show at this input.
03:16:43 <kritzcreek> does someone have an idea how to fix that linker error at a glance? I've never seen that before
03:16:45 <srhb> koz_: Perhaps someone else can. :)
03:17:04 <koz_> srhb: OK, I'll ask someone else. Thanks for making me be thorough, though.
03:17:36 <srhb> koz_: Good luck. :)
03:18:05 <bennofs> kritzcreek: have you tried cleaning and rebuilding?
03:18:31 <bennofs> kritzcreek: also, check that all your library modules are listed in either other-modules or in exposed-modules for the library entry in the cabal file
03:19:27 <nilof> Ah, a question regarding the earlier about monads and type inference, what about the identity monad? Will it get called if nothing else matches?
03:19:32 <kritzcreek> bennofs: I've managed to reproduce the error on both my mac and my arch after `stack clean`
03:19:48 <kritzcreek> I haven't added or removed any modules, so the cabal file should be just fine...
03:20:06 <bennofs> kritzcreek: ok, then have you checked all library modules are listed, especially Language.PureScript.Traversals?
03:20:38 <kritzcreek> yes they are
03:20:51 <srhb> nilof: That's just yet another newtype.
03:21:04 <kritzcreek> well Traversals is. I haven't touched any Traversal module neither the psc/Main.hs file in my commit... :D
03:21:23 <srhb> nilof: newtype Identity a = Identity { runIdentity :: a }
03:21:44 <kritzcreek> bennofs: wow. Now I've gotten past that error... Sorry cleaning and reinstalling for the third time did it
03:21:50 <srhb> nilof: In other words, its bind will only be used if the type is actually Identity a.
03:22:03 <nilof> ah ok
03:22:13 <bennofs> kritzcreek: oh, also check that you have other-extensions: TemplateHaskell in your cabal file if a target uses TH
03:22:27 <srhb> nilof: This is true for overloading in general in Haskell. One type, one instance. Under normal circumstances, you can't overload for the _same_ type.
03:22:29 <bennofs> kritzcreek: that can sometimes cause these weird non-deterministic build failures if missing
03:22:55 <kritzcreek> bennofs: yeah I usually check for missing modules in cabal files / template haskell first when I get these cryptic linker errors...
03:22:57 <srhb> nilof: Which gets rid of a lot of confusion. :-)
03:23:09 <kritzcreek> something that is really frustrating to a beginner
03:35:01 <{AS}> Hi, is there a way to return n-ary tuples generically?
03:35:11 <{AS}> like take an Int and then return a tuple with that size
03:37:27 <dysfun> why? sounds like you want a HList?
03:41:55 <{AS}> dysfun: Yeah, actually I want Vec
03:42:52 <{AS}> Thanks for the answer :)
03:44:10 <HoloIRCUser1> Hey can anyone please help me with http://stackoverflow.com/questions/38167924/how-to-make-llvm-3-7-default-on-raspberry-pi
03:44:47 <saurabhnanda> Any help with http://stackoverflow.com/questions/38167924/how-to-make-llvm-3-7-default-on-raspberry-pi
03:49:14 <cocreature> saurabhnanda: have you tried just putting the llvm 3.7 binaries in the path before the 3.5 ones?
03:56:34 <hrnz>  /close
03:56:36 <hrnz> ergh
04:05:12 <dysfun> does anyone know of a good irc channel for asking university-level maths questions?
04:06:34 <Berra> dysfun: ##math
04:06:44 <dysfun> on freenode?
04:06:48 <Berra> dysfun: Yes
04:06:54 <dysfun> thanks :)
04:29:14 <koz_> What's the best Haskell library for command-line option parsing?
04:29:32 <dysfun> CmdArgs, imo
04:29:53 <cocreature> optparse-applicative is also quite popular
04:30:13 <koz_> dysfun and cocreature: Thank you - I shall investigate both of these.
04:34:14 <dimsuz> Hi! When I write code in some monad (Yesod's Handler for example) and get some other monad's value, e.g. Maybe/Either, I am tempted to write "val <- myMaybeValue", but it's not permitted. I know about transformers, but this means I have to enrich the function type?
04:34:51 <dimsuz> still wrapping my head around this stuff, so I figure I should ask all kind of silly questions :)
04:35:01 <dysfun> maybe is trivially unwrappable though
04:35:49 <dimsuz> yes, but I always get a feeling that I'm doing something wrong and code should be written some other way )
04:35:59 <dimsuz> but for the lack of experience I don't even know how 
04:36:31 <dysfun> if you look in Data.Maybe there are a handful of functions working with them. you wouldn't want for example do notation unless you were trying to compose several operations on the same maybe, in which case you can factor it out into another function and simply return one maybe
04:36:57 <dimsuz> ok, so I should just use `maybe` etc and be done?
04:37:16 <dysfun> yes
04:37:22 <dimsuz> great. thanks
04:37:30 <dysfun> if you want to chain operations on maybes, then we can talk about how to do that
04:38:13 <dimsuz> I think I understand how to do this. I can either start an inner "do" block or use ">>=", ">>" in place
04:38:36 <dysfun> or even better, put it in an auxiliary functoin
04:38:51 <dimsuz> oh, right! and use do notation there, it will be explicit
04:38:56 <dimsuz> more readable
04:39:00 <dysfun> exactly
04:39:47 <dysfun> 'do' threads a single monad type. if you want to interoperate monads you need to use some unboxing function, or return or fmap or something
04:42:53 <dimsuz> I somehow thought that monad transformers are designed to help here - so that i can use all kind of monads in a single do block. But after completing a transofmer tutorial I feel that mtl is just a way to build a complex monad with features of several monads.
04:43:35 <dysfun> pretty much. you build the stack of transformers that contain the side effects you want to tap into
04:44:17 <dysfun> worth noting that mtl isn't the only set of transformers in town
04:44:24 <dysfun> i think transformers is more used now
04:44:57 <dimsuz> oh. didn't know that
04:45:14 <dysfun> there are others too, in varying states of usability
04:49:03 <dysfun> does anyone actually use a non-ghc haskell in production? i'm looking at my code and thinking that i use far too many extensions for anything else to be feasible
04:49:53 <dysfun> and given how difficult it is to get work done without them, i can only assume i'm not alone
04:50:52 <maerwald> dysfun: I haven't heard a lot of haskellers complaining about it. Most are fine to write GHC instead of haskell and there is little hope that the language report will become more complete.
04:51:14 <dysfun> oh, i'm not unhappy with ghc, it was more idle musing
04:51:45 <maerwald> it's not about being unhappy with ghc, but being unhappy with the language report
04:52:00 <dysfun> well yes, i *am* unhappy with the language report
04:52:12 <srhb> I don't think there's reason to lose hope yet.
04:52:19 <maerwald> if you would write a new haskell compiler, you'd be forced to re-implement most of the ghc extensions in order for it to be remotely useful
04:52:31 <dysfun> very much so
04:52:37 <S11001001> dysfun dimsuz: mtl doesn't define a separate set of transformers; it's a library on top of transformers
04:52:49 <dysfun> S11001001: oh, nice :)
04:53:14 <maerwald> dysfun: if you are sick of mtl/transformer, you might want to check out freer or extensible-effects
04:53:43 <dysfun> i'm sick of transformers, certainly. i haven't actually used mtl
04:53:45 <srhb> dysfun: I don't know if you know, but the Haskell 2020 committee _has_ been discussing the incorporation of several extensions.
04:53:47 <S11001001> dysfun dimsuz: specifically, mtl implements a particular approach (similar to "tagless final" style) to avoid manually lifting, and to let you specify your functions using a constraint-on-monad style
04:53:50 <srhb> Into the report, that is.
04:54:18 <dysfun> srhb: there are *many* that i consider essential
04:54:31 <srhb> dysfun: Agreed. I don't mind terribly just enabling them though.
04:55:17 <dysfun> well most of my modules tend to start with enabling a lot of them. It would be nice if the fairly benign ones were enabled by default
04:55:20 <maerwald> I'm really more worried about the state of the language, because compilers can derail and then there's little left to start anew.
04:55:30 <S11001001> dysfun dimsuz: this is very convenient because you typically only specify "the monad" at one place, where you "run" it, and your functions can operate on lots of possible stacks without being specific about what stack they work in
04:55:33 <dysfun> and MultiParamTypeClasses, I should *not* have to enable that manually
04:55:50 <alercah> dysfun: you can put them into your cabal file
04:56:01 <alercah> default-extensions
04:56:05 <dysfun> i do :)
04:56:41 <dysfun> S11001001: aha, thanks for the explanation
04:56:56 <maerwald> then you enable them for ALL modules no?
04:57:01 <maerwald> I don't really like that
04:57:37 <maerwald> e.g. enabling OverloadedStrings globally can have odd side-effects
04:57:58 <dysfun> OverloadedStrings I prefer not to enable globally, but MPTC?
04:59:06 <S11001001> dysfun dimsuz: for example this uses mtl to get the "Reader" input and the current state, no matter where ReaderT/StateT are in your transformer stack:
04:59:08 <S11001001> @ty (,) <$> ask <*> get
04:59:10 <lambdabot> (MonadReader a1 f, MonadState a f) => f (a1, a)
05:02:52 <dimsuz> S11001001: yes, this feels very convenient!
05:04:46 <dysfun> maerwald: extensible-effects and freer look really nice
05:05:13 <dimsuz> S11001001: is there a constraint to Maybe monad? a-la MonadState? MonadMaybe. do not see it in docs. or is this not needed for some reason?
05:05:14 <S11001001> dimsuz: There's a good chance you will want to use the same constraint on several functions; you can shorten this with the ConstraintKinds extension, following the style of L5Monad here https://github.com/joshcough/L5-Haskell/blob/master/src/L/L5/L5Interp.hs
05:05:59 <dimsuz> oh, I was just thinking that there must be some way to avoid this repetition :) already got this on several functions
05:06:55 <maerwald> dysfun: it's certainly more "designed" I'd say. Transformers/mtl is something that just came out of necessity and lack of proper effects system in haskell.
05:07:07 <maerwald> ofc both have different approaches, limitations and properties
05:07:13 <S11001001> dimsuz: I think in such cases you'd generally use MonadError and ExceptT
05:07:25 <dimsuz> I see, thanks
05:08:10 <dysfun> maerwald: yeah, i've also seen some reimplementations of e-e that are waiting to be studied
06:00:26 <hodapp> dysfun: e-e = extensible effects?
06:04:21 <dysfun> yes
06:06:50 <dysfun> if you hackage search for extensible-effects and look at what comes up
06:15:11 <hodapp> dysfun: it's something I've heard about here and there, and just haven't gotten around to reading about
06:16:41 <dysfun> http://okmij.org/ftp/Haskell/extensible/more.pdf # the paper on e-e
06:16:52 * dysfun is currently trying to digest it
06:18:16 * hodapp saves that
06:18:49 <dysfun> it sounds very interesting. and much more efficient than transformers
06:19:38 <hodapp> I had read someplace that stacks of monad transformers were slow, but hadn't read much past that
06:19:39 <maerwald> one of the main differences is that e-e does not have static ordering of effects
06:20:01 <maerwald> and he also presents use cases for that
06:21:29 <dysfun> i suspect this is where idris got their inspiration for their effects system from
06:24:59 <hodapp> that's yet another thing I need to read about :P
06:28:54 <nmattia> if you guys are in london next week, oliver charles will lead a hack-evning on transformers-eff, another alternative to mtl transformers :)
06:59:51 <nilof> :kind (->)
07:01:20 <quchen> -> is syntax, but you can think of it as having kind `* -> * -> *`.
07:01:59 <quchen> Oh, nevermind that, you can actually ask GHCi for its kind.
07:02:12 <quchen> :k (->)
07:02:13 <lambdabot> * -> * -> *
07:02:29 <nilof> ah ok, so it's :k
07:02:44 * hackagebot wai-session-mysql 0.2.1.0 - MySQL backed Wai session store  https://hackage.haskell.org/package/wai-session-mysql-0.2.1.0 (Lupino)
07:02:46 <nilof> :k []
07:02:48 <lambdabot> * -> *
07:03:17 <quchen> @kind Either
07:03:18 <lambdabot> * -> * -> *
07:03:25 <quchen> :k Either
07:03:26 <lambdabot> * -> * -> *
07:03:46 <quchen> Lambdabot has some convenience definitions to make it feel more like GHCi, but it's not actually GHCi.
07:03:53 <nilof> Should I interpret any kind of the form * -> (something else) as a type constructor?
07:03:56 <quchen> Most notably, there's no :i(nfo).
07:04:17 <quchen> Typically you'd call anything that maps to * a type constructor.
07:04:27 <quchen> At least I would.
07:05:32 <quchen> The language is a bit fuzzy here. Sometimes types of kind * are called "types", sometimes they're called "proper types", sometimes types includes everything well-kinded, …
07:06:29 <quchen> When in doubt, over-specify. "Type of kind *" is unambiguous.
07:06:40 <nilof> I'm working on this problem set to get a bit of practice: http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/ , but I'm not sure how to interpret exercise 3
07:07:40 <quchen> nilof: furry :: (a -> b) -> (t -> a) -> (t -> b)  in this case
07:07:43 <nilof> So far all functor instances I've seen have some concrete type constructor, how should I interpret it in this case
07:07:45 <nilof> ah
07:07:48 <nilof> ok, that help
07:07:53 <nilof> *helps
07:07:59 <quchen> (->) t a = t -> a
07:08:06 <quchen> Just like (*) a b = a * b
07:09:03 <nilof> That cleared things up, thanks!
07:28:48 <quxbam> @pl a b c d=d[c[b[a.a]]]
07:28:48 <lambdabot> a = fix (((flip id .) .) . flip flip [] . ((flip . ((:) .) . flip id) .) . flip flip [] . ((:) .) . flip id . return . join (.))
07:29:03 <quxbam> hm
07:29:14 <maerwald> another series of pointless style
07:30:50 <glguy> nilof: A "type constructor" is the capitalized name of a type or concrete type operator
07:30:51 <quxbam> There should be a contest of longest pointless style for a given input length
07:31:12 <glguy> Identity, Bool, [],  (->) are "type constructors"
07:31:33 <exio4> quxbam: you can always add redundant operators and calls - shortest is harder 
07:31:51 <quxbam> exio4: Well, for a given input length
07:32:02 <quxbam> lets say, the input code is at most 10 chars
07:33:39 <glguy> nilof: Compare to "data constructors" like True, Left, (:)
07:34:31 <glguy> nilof: but having a kind of "* -> ..." doesn't have anythign to do with it
07:38:51 <cloudhead> would it be good practice to put my custom monad transformer classes in Control.Monad.Trans even if it's domain-specific? 
07:39:24 <cloudhead> or is that module hierarchy just for reader/writer type stuff
07:39:26 <glguy> Probably not
07:39:36 <glguy> to the first question
07:39:45 <cloudhead> ok yeah
07:40:05 <bergmark> i like to keep all modules in a package under a shared namespace
07:40:10 <cloudhead> and I guess same for the MonadXX instances, I wouldn't put them in Control.Monad.XX.Class
07:40:21 <cloudhead> s/instances/classes
07:40:44 <glguy> No, if you're using that style the constraints would still go in the relevant module for the domain you're working in
07:42:06 <cloudhead> glguy right, so something like MyDomain.Types or MyDomain.Class?
07:42:22 <glguy> for example, ure
07:42:23 <glguy> sure*
07:42:37 <cloudhead> cool, thanks
07:50:45 <tojoko> hi
07:50:56 <tojoko> could somebody answer me three questions?
07:51:17 <tojoko> well, don't ask to ask, i guess so
07:52:03 <tojoko> a) why are here so many people. as far as i could remembers haskell was only a little programming language in 2004 when i tried it once.
07:52:26 <leshow> because it's grown lol?
07:52:46 <dysfun> astonishingly, if you keep working on a thing for years, it moves on
07:54:32 <tojoko> oh, well, i thought you couldn't do much with it, at least not much with practical use. i remember the professor sayin somethin like haskell would be perfect, if there weren any user interactions. ^^
07:54:50 <tojoko> well, b), which one is the latest version i can compile with gcc?
07:55:23 <dysfun> most of us program using language extensions when we need to do real world work
07:55:58 <tojoko> dysfun, so, u use java?
07:56:09 <dysfun> not where possible
07:56:32 <tojoko> ok
07:56:36 <Philonous> tojoko, I remember my professor saying similar things. Turns out he didn't know Haskell at all
07:56:44 <maerwald> most don't
07:56:58 <arcetera> java is the source of pain
07:57:08 <dysfun> when i applied for uni, i picked the only one that did haskell. before i would have started (i didn't go), they took it out of the syllabus
07:57:10 <maerwald> no language war plz
07:57:23 <leshow> ghc is at version 8
07:57:33 <tojoko> Philonous, sorry to hear that, but mine was a she and i guess her to know what she was talkin about.
07:58:12 <tojoko> dysfun, oh, sorry to here - which country would that be?
07:58:17 <dysfun> that was the uk
07:58:34 <dysfun> basically all the universities are cranking out java programmers in the uk
07:58:36 <maerwald> tojoko: then you should ask her why one of the primary domains of haskell is web development, which is all about user interaction
07:58:43 <tojoko> well, than why don't u leave, dysfun? ;)
07:58:46 <dysfun> i did :)
07:59:14 <dysfun> but i think if i went to university now, it wouldn't be for compsci
07:59:17 <Philonous> tojoko, Well, Haskell's IO model used to be rather wonky, but that was a very long time ago. You can have all sorts of outside-world interactions now without any problem (some would argue that Haskell is the best imperative language)
07:59:28 <tojoko> arcetera, well, but java now includes some functional programmin
07:59:37 <dysfun> no, it includes lambdas
07:59:44 <dysfun> and really, it always did, they just added new syntax
07:59:50 <dysfun> it compiles down to an old bytecode idiom
07:59:51 <leshow> if you consider functional programming just chaining a couple function calls together
07:59:51 <tojoko> well, ok thanks.
07:59:56 <leshow> it's not really FP
08:00:34 <dysfun> if i'm going to program for the jvm, i'd rather use clojure
08:01:15 <tojoko> Philonous, well, i think my professors point was a bit different from yours. Her concern was all about provin' that the programm did what it was supposed to do. That's a lot easier if you have no user interaction, i guess.
08:02:04 <SphericalCow> Frege looks pretty cool, I've been meaning to use it for a project soon
08:02:24 <Philonous> tojoko, Ah, but that's still the case. Haskell makes it easy to split your program into pure (effects-free, easy to reason about) and effectful (messy) parts
08:03:00 <maerwald> does "pure" really mean effects-free?
08:03:36 <maerwald> evaluation in haskell is always pure, including IO
08:05:13 <Philonous> maerwald, Haskell also has an execution semantics. 
08:05:20 <maerwald> yes and that is always impure
08:05:24 <arcetera> tojoko: java's still nowhere near functional
08:05:33 <arcetera> i learned that the hard way in ap computer science
08:06:04 <arcetera> i like to say
08:06:07 <arcetera> haskell is a functional language
08:06:10 <arcetera> c is a non-functional language
08:06:14 <arcetera> java is a non-functioning language
08:07:14 <tojoko> arcetera, well, sure. i'm not surprised. But i guess it's like learnin' a foreign language. 80% of the time u only need 20% of the words or so. Meanin', a basic functionality is often all u need.
08:07:23 <maerwald> Philonous: whether you are dealing with effects or not doesn't matter for it to be pure at evulation level. It always is.
08:07:44 <Philonous> maerwald, I'm not sure what you are arguing. You can write Haskell like you would write C, with lots of IO-effects even for pure functions. My point is that that's not idiomatic and you'd rather have as much pure code as possible and only use IO where you really want to interact with the real world 
08:08:00 <tojoko> but i want to compile haskell myself and don't know where to start.
08:08:26 <Philonous> maerwald, E.g. you can implement a loop by mutation IORefs. But that's not idiomatic. 
08:08:37 <Philonous> mutating*
08:08:38 <maerwald> Philonous: when you execute any haskell program, it is inherently impure by definition and communicated with the outside world via kernel, libc whatever
08:08:43 <nitrix> tojoko: Out of curiosity, is there a need for ommiting your G's and shortening "you" to "u" ?
08:08:54 <maerwald> Philonous: evaluation is always pure though and it doesn't matter whether it includes IO
08:09:23 <maerwald> IO is not executed when stuff is evaluated
08:09:55 <maerwald> in C, evaluation may involve execution of stuff
08:10:00 <Philonous> maerwald, So? See my example. There's definitely a difference whether I use IORefs and pointers to loop through an array or a pure function to map over it. 
08:10:01 <maerwald> in haskell not
08:10:12 <tojoko> nitrix, no, just a bad habid i guess. but i've now routine with english anymore.
08:10:13 <maerwald> Philonous: yes, but it's not about pure vs impure
08:10:30 <Philonous> maerwald, Sure it is. I can implement the same algorith as a pure function or using IO. 
08:10:39 <maerwald> IO code is harder to reason about, that is right
08:10:58 <maerwald> Philonous: your function is still pure, even if it's an IO function
08:11:02 <maerwald> at least on evaluation level
08:11:08 <maerwald> but I feel like I'm repeating myself
08:11:41 <maerwald> "IO is a messy effect" is pretty accurate though
08:12:57 <Philonous> maerwald, You mean _evaluating_ the IO function is pure? Or do you mean that executing it is, because it doesn't really have side effects and hence could be implemented as a pure function?
08:13:07 <nitrix> Reading the backlog, you're confused Philonous. IO isn't some kind of magical type that breaks purity or something.
08:13:33 <Philonous> nitrix, I never said it was
08:13:44 <maerwald> Philonous: IO does not have side effects. It's an accurate but very vague description of a set of effects that can occur when the function is executed by the RTS.
08:13:53 <maerwald> but the RTS is already impure anyway
08:14:16 <maerwald> and whenever you execute stuff, it may just outright crash, although the program is correct
08:14:17 <nitrix> Philonous: Mhhh, well you hinted that pure values were different from IO somehow. I'm curious to know where that misconception comes from because it's pretty harmful.
08:14:22 <Philonous> maerwald, That's a smoke screen. IO doesn't have side effects when you evaluate it, but it most certainly has effects when the RTS executes it, which is what we care about
08:15:19 <maerwald> Philonous: does it really make sense to talk about side effects when you are executing something? There are a thousand ways a correct haskell program with very little IO may just outright crash, including kernel bugs.
08:15:34 <maerwald> memory exhaustion, whatever
08:15:48 <maerwald> how can execution be pure?
08:16:54 <nitrix> maerwald: Besides, some things like memoization have side-effects, they are just made pure for language convenience.
08:16:54 <maerwald> when your haskell binary starts up the RTS, it can already fail
08:17:15 <Philonous> nitrix, Al I was arguing is that you can implement an algorithm either as a pure function or using IO (that it won't be executed when the IO value is evaluated is besides the point). And I was arguing that implementing it as a pure function (probably) makes it easier to reason about
08:17:17 <ashishnegi> maerwald: side effects are from the point of code optimizer / compiler .. not programmer point of view.. http://programmers.stackexchange.com/questions/258663/how-can-io-cause-side-effects-in-functional-programming
08:17:49 <maerwald> ashishnegi: yeah, and IO does not have side effects
08:18:28 <nitrix> It doesn't have side effects, it represents effects.
08:18:57 <tojoko> sorry, if i have started that war.
08:19:23 <maerwald> Philonous: the part about "reasoning" is correct, but it's unrelated to pure vs impure. IO is hard to reason about because it describes a HUGE set of possible effects
08:19:40 <nitrix> tojoko: Knowledge transfer isn't a war in any way ;)
08:20:43 <maerwald> if you imagine an effect that _only_ allows printing stuff to stdout along with return values, is it really that hard to reason about those functions?
08:20:55 <ertesx> to be honest i find IO easier to reason about than side effects
08:21:25 <ertesx> it gives you first class effects, so you can actually write equations
08:21:38 <maerwald> ertesx: well, there's the __pure__ attribute in C, but most people don't use it
08:21:58 <ertesx> maerwald: i mean reasoning about effects
08:22:00 <tojoko> well, i guess i've never used haskell, it was called hugs at that time i gave it a little try.
08:22:44 <nitrix> tojoko: Hugs is (or was) a compiler for Haskell. GHC is pretty much de-facto at the moment.
08:22:45 <dysfun> hugs is an implementation
08:22:57 <glguy> And wasn't a compiler
08:23:24 <nitrix> Oh! I didn't even bother to look. An interpreter apparently.
08:23:39 <Philonous> maerwald, If it's not easier to reason about because of the lack of effects, then why? Or are you saying that's not what "pure" means? 
08:24:37 <ertesx> Philonous: i think maerwald just differentiates between "effect" and "side effect"…  IO does have effects, but no *side* effects
08:24:47 <ertesx> it's a language for real-world effects after all
08:25:01 <Philonous> I was careful to say "effect" everywhere. But maybe I missed some places
08:25:08 <ertesx> you did =)
08:25:17 <bbear> hi
08:26:15 <maerwald> Philonous: if you use unsafePerformIO you will get side effects that are hard to reason about, because GHC still assumes that it can optimize stuff at evaluation level in crazy ways, because "purity" is assumed. Which leads to very odd behavior if you use unsafePerformIO in evil ways.
08:26:52 <dysfun> (don't use unsafePerformIO unless you really know what you're doing)
08:26:56 <maerwald> yeah
08:27:21 <maerwald> GHC doesn't go "oh, he uses unsafePerformIO so I better not optimize that whole stuff"
08:28:07 <nitrix> That'd be problematic, considering memoization uses unsafePerformIO.
08:28:10 <Philonous> ertesx, No, the places where I said "side effects" I actually meant it. I think
08:28:12 <ertesx> let's take something far more mundane and not related to optimisation: sharing
08:28:32 <davidkart> how does one install apps with debian ?
08:29:03 <ertesx> if you break haskell semantics (if you write "impure" code), you get unexpected behaviour, as soon as sharing is involved…  and it's basically everywhere
08:29:06 <nitrix> davidkart: I believe `aptitude` is their package manager.
08:29:17 <ertesx> there is just no way to write correct haskell code by abusing unsafePerformIO
08:29:28 <ertesx> it's not impossible, but impractical
08:29:29 <davidkart> well, I want to install hakyll but the binary never appear in my system.
08:29:29 <maerwald> ertesx: good thing GHC is full of it :P
08:29:29 <dysfun> nitrix: aptitude is *a* package manager. most people use the apt-* tools
08:29:48 <davidkart> https://packages.debian.org/sid/libghc-hakyll-dev
08:30:06 <dysfun> sid is unstable. are you running sid?
08:30:24 <davidkart> That's really annoying that debianity which is not actually working.
08:30:42 <nitrix> dysfun: Interesting. I thought apt stood for aptitute. What a confusing choice for the name.
08:30:54 <nitrix> Can't be worse than Cabal, cabal and cabal-install though.
08:30:58 <ertesx> davidkart: hakyll is not a binary
08:31:30 <dysfun> nitrix: Advanced Package Tool. Aptitude came later
08:31:35 <davidkart> yes of course it is a lib, but it comes with some binary file from what I can gather on the main website.
08:32:05 <davidkart> I am just looking for the hakyll-init executable.
08:32:33 <dysfun> what output did you get when you went to install libghc-hakyll-dev ?
08:32:39 <davidkart> and also debian has no stack, only cabal : https://jaspervdj.be/hakyll/tutorials/01-installation.html To make things a little bit more troublesome.
08:33:22 <nitrix> davidkart: I guess you could do `cabal install stack`.
08:33:33 <maerwald> or just use cabal without stack
08:33:39 <davidkart> cabal: There is no package named 'stack'.
08:33:52 <nitrix> davidkart: Your cabal is maybe out of date?
08:34:05 <davidkart> well, it's debian, so yes it is out of date.
08:34:20 <dysfun> davidkart: http://docs.haskellstack.org/en/stable/install_and_upgrade/#debian
08:34:24 <davidkart> I suppose I shouldn't install anything from their repository and stick with an user wide installation.
08:35:25 <nitrix> Fortunately, cabal can update itself :)
08:36:17 <maerwald> cabal install hakyll
08:36:22 <maerwald> why bother with stack?
08:37:05 <dysfun> because stack makes life very easy
08:37:15 <nitrix> Reproducible builds :]
08:37:16 <leshow> yeah stack is great
08:37:36 <maerwald> I don't know. People have been telling me about all the trouble I am supposed to have with cabal-install. Except that's just not the case.
08:37:48 <maerwald> stack is great for deployment yeah
08:37:51 <dysfun> how fortunate for you
08:38:00 <leshow> i dont even write a lot of haskell and i
08:38:04 <maerwald> I think it's overhyped.
08:38:06 <leshow> ve had plenty of issues
08:38:16 <dysfun> i think it's a blunt instrument but it works
08:38:18 <sm> maerwald: it's easy for one person to experience no problems with cabal, while many others struggle with it
08:38:29 <sm> it depends on your usage patterns and expertise
08:38:30 <maerwald> sm: I'm not really the only person
08:38:34 <glguy> maerwald: But stack's got what plants crave. It's got electrolytes
08:38:39 <maerwald> if you use cabal sandboxes correctly you barely get any build failures
08:38:54 <maerwald> and if you do, it's almost always an incorrect .cabal definition
08:39:02 <maerwald> which can then be fixed upstream, profit
08:39:18 <dysfun> we're thrilled you do it the hard way, but not all of us prefer to
08:39:47 <maerwald> I don't see how that's hard. I'm using gtk3 which has a crapload of dependencies and I haven't had a build failure since half a year.
08:39:58 <davidkart> well at some point I'd rather not point out either projects weakness, rather debian incapacity to have running software on their own repositories.
08:40:45 <nitrix> maerwald: GHC 7 to GHC 8 migration was a breeze with stack for projects in production.
08:40:59 <glguy> It was also a breeze without, it's a breeze with both
08:41:00 <maerwald> yes, it makes sense for deployment
08:41:26 <leshow> maerwald: what do you do for different versions of ghc
08:41:44 <maerwald> leshow: my travis CI tests them, otherwise I'd probably use a docker environment
08:42:11 <nitrix> maerwald: It makes also sense for developement. The environements should be as similar as possible. Personally I like that it does the sandboxes for me and the solver is pretty nice when you get into really nasty dependency versioning issues.
08:42:16 <leshow> stack handles that, and it's nice. i have ghc 8 on my system but stack will handle any ghc version for any project
08:42:19 <nitrix> Like SDL2 with transformers at the moment.
08:42:31 <maerwald> nitrix: I disagree. For development, people should always run the latest hackage state
08:42:39 <maerwald> that also ensures that their dependencies are correct and not junk
08:42:41 <dysfun> also, stack means i don't have to specify any package bounds in my cabal file
08:42:53 <glguy> leshow: It's fine to have multiple version of GHC on the same system. Cabal-install has a -w flag and you can tell it which one to use when you configure
08:43:08 <maerwald> dysfun: which is bad not to do
08:43:10 <glguy> dysfun: No, you still need to know which versions your package relies on
08:43:11 <nitrix> maerwald: What if hackage is broken?
08:43:21 <Squarism> if i have profiling libs, was there a way to get line number from any error of sorts?
08:43:22 <maerwald> nitrix: I don't know what that means, can you be more specific?
08:43:23 <nitrix> maerwald: You don't work for a week?
08:43:25 <tojoko> can't remember how i compiled hugs
08:43:26 <leshow> glguy: i can't install mutliple versions from the arch repos
08:43:27 <glguy> dysfun: leaving out the versions is a terrible anti-pattern and just building up debt you'll pay for later
08:43:33 <dysfun> maerwald: if it's going on hackage, sure
08:43:37 <glguy> leshow: That's a bug in arch
08:43:39 <dysfun> glguy: only for things that stack isn't pinning
08:43:50 <dysfun> and for those you have to pin them anyway
08:43:55 <leshow> glguy: lmao, that's a convenient place to shift the blame
08:44:04 <nitrix> maerwald: Also, what about managing local dependencies as well?
08:44:09 <nitrix> Automatically ;) ?
08:44:20 <maerwald> nitrix: what do you mean with local dependencies?
08:44:25 <glguy> leshow: GHC natively support having multiple versions installed at the same time
08:44:34 <nitrix> maerwald: Things not on hackage.
08:44:38 <glguy> leshow: It's how I use it on Linux and OS X regularly without having stack manage it
08:44:45 <maerwald> nitrix: git submodule and "cabal sandbox add-source"
08:44:50 <glguy> leshow: if your OS removes that feature it's an OS issue
08:44:52 <leshow> glguy: however most linux installations besides gentoo wont let you install multiple versions of the same package
08:45:12 <nitrix> maerwald: Yeah, you don't have to manually do that with stack either.
08:45:17 <maerwald> nitrix: see https://github.com/simonmichael/hledger/blob/master/cabal-install.sh
08:45:27 <nitrix> maerwald: I know how cabal works ;)
08:45:33 <maerwald> nitrix: you don't have to do that manually either if you write a simple shell script
08:45:57 <nitrix> ...
08:46:03 <leshow> glguy: and how about not having to actually go and install it myself? if i used cabal like you said, id have to go find the verison, install it, set the flag. with stack i dont have to do any of that and there isnt much benefit to pure cabal that i can see
08:46:10 <nitrix> maerwald: That's your argument? I think you're missing the point.
08:46:19 <maerwald> nitrix: what point?
08:46:36 <nitrix> maerwald: You're writing yourself scripts to do things people bundled in a useful tool.
08:46:46 <maerwald> that's so trivial that I don't really care
08:46:53 <glguy> nitrix: it's about as hard as writing a yaml file
08:46:57 <maerwald> yeah
08:47:13 <nitrix> Some people have needs less trivial. You can't dismiss stack so easily like that.
08:47:30 <maerwald> I'm not dismissing stack. I said it's great for deployment, but it's overhyped.
08:47:37 <leshow> for your use case
08:47:39 <maerwald> And I wouldn't use it for development.
08:47:56 <nitrix> maerwald: Even for development. How do you deal with projects on different GHC versions?
08:47:57 <maerwald> and even for deployment, I prefer docker with cabal-install over stack
08:48:04 <maerwald> docker.
08:48:26 <maerwald> I don't deploy without containerization. That would be awful.
08:48:26 <nitrix> maerwald: Oh, guess what, stack has docker included as well.
08:48:34 <nitrix> It can even generate docker images for you :)
08:48:46 <dolio> I just build multiple versions of GHC myself, because that will actually work.
08:48:46 <nitrix> And nix integration if you're a nixos person.
08:48:46 <maerwald> I prefer to write them myself without stack, as said.
08:48:57 * dysfun waves a hand for nixos integration
08:49:20 <maerwald> When using docker, I see little use of either stack or nixos. I have my own automatic builds with CI, testing and whatnot.
08:50:37 <srhb> nitrix: The nix integration is rather lackluster, to be honest. It doesn't handle haskell dependencies at all.
08:50:47 <srhb> That said, this discussion seems like a rerun. :-P
08:51:41 <dysfun> my preferred tooling is better than your preferred tooling!
08:51:43 * dysfun hides
08:51:51 <ertesx> maerwald: i can't speak for stack, but nix gives you all of that with little extra work and a useful underlying semantics
08:52:09 <maerwald> I've used NixOS and I would never use it again
08:52:13 <glguy> It's OK to have different opinions on tooling until it starts degrading the quality of stuf being uploaded to hackage
08:52:14 <leshow> and uhhh vim is better than emacs too, while we're at it
08:52:21 <ertesx> maerwald: NixOS ≠ nix
08:52:26 <maerwald> ertesx: I am ware
08:52:28 <maerwald> *aware
08:52:31 <maerwald> that's why I said NixOS
08:52:43 <ertesx> maerwald: but that's irrelevant
08:52:46 <nitrix> That's interesting. Considering docker serves pretty much the same simplification goal of over manual management of LXC/cgroups, I'd have thought you had more interest for stack that promises to do the same with sandboxes, ghc/package versioning and stuff.
08:52:48 <maerwald> it's not
08:52:54 <nitrix> Oh well.
08:53:21 <maerwald> you can't use nix without packages. So you certainly depend on the NixOS ecosystem in one way or the other anyway
08:54:54 <ertesx> maerwald: not much actually…  when you do haskell development you use nixpkgs, which is a well maintained project
08:55:17 <maerwald> ertesx: nixpkgs is part of NixOS
08:55:30 <maerwald> https://github.com/NixOS/nixpkgs
08:55:35 <ertesx> maerwald: so?
08:55:53 <maerwald> yeah, and I said I won't use NixOS again, because it has incredibly poor quality
08:56:06 <maerwald> but this is drifting offtopic
08:56:13 <ertesx> and it's also insulting and wrong
08:56:20 <maerwald> no, that's my opinion
08:57:31 <btcNeverSleeps> I cannot live without my beloved Emacs and in the past the Haskell tooling/support for Emacs drove me crazy, so I gave up (on Haskell, not on Emacs). But...
08:57:42 <btcNeverSleeps> Now I read good thing about intero.el    so I'd like to try that
08:57:52 <dysfun> haskell-mode has gotten much much much better
08:58:11 <dysfun> i'd go so far as really good actually
08:58:22 <nitrix> I'd still write Haskell in notepad if I had to choose between both.
08:59:06 <ertesx> maerwald: an opinion is in your head, and as someone used to other ways of doing things, i can see how one obtains it…  but what you *said* is just an uneducated insult, nothing more
08:59:33 <nitrix> ertesx: Can you move on?
08:59:48 <maerwald> ertesx: I've been a linux distro dev for half a decade and have used and tried a lot of things. I could go into a lot of details here about NixOS, since I really tried it, but again: that's offtopic.
08:59:52 <saurabhnanda> is it possible to use 'stack new' on an existing project?
08:59:58 <nitrix> ertesx: I believe the original discussion between me and maerwald got a little too involved and you happened to join when it was over.
09:00:12 <btcNeverSleeps> I've got a system without any Haskell on it. Can I install Haskell (stack) in a user account, without needing to be root?
09:00:20 <dysfun> saurabhnanda: it doesn't win you anything, just create a simple stack.yaml
09:00:33 <btcNeverSleeps> (Linux btw)
09:00:36 <leshow> marchelzo: what distro?
09:00:44 <saurabhnanda> dysfun: I'm trying to use it to create a yesod scaffolding, btw
09:00:52 <glguy> btcNeverSleeps: Yeah, GHC works in an arbitrary prefix. I typically install my GHC's into my home directory
09:00:54 <GXNPwd> saurabhnanda: "stack init" for existing cabal projects
09:01:16 <saurabhnanda> glguy: "stack init yesod-postgres" something like that?
09:01:23 <dysfun> saurabhnanda: in that case, i'd suggest you generate the scaffolding in another directory and copy over your sources
09:01:27 <leshow> oops i mean maerwald 
09:01:44 <srhb> saurabhnanda, dysfun: I think there's a --bare option or something like that for the same directory initalization
09:01:46 <maerwald> leshow: what do you mean?
09:01:46 <glguy> saurabhnanda: I don't know I don't use stack to start projects
09:01:47 <btcNeverSleeps> glguy: ok good
09:02:03 <leshow> maerwald: you said you were a distro dev, just curious what distro
09:02:09 <btcNeverSleeps> and... What should I install first? GHC? Stack? Cabal?
09:02:27 <glguy> btcNeverSleeps: Depends on what you plan on using. I install GHC first and then cabal
09:02:42 <saurabhnanda> wow - 82 files!
09:02:43 <btcNeverSleeps> thankfully I know some Haskell already... But I'm totally lost when it comes to the tooling around it.
09:02:53 <saurabhnanda> sorry 52 files
09:02:56 <srhb> btcNeverSleeps: If you decide to use stack you should probably just install that first and go from there.
09:02:56 <maerwald> leshow: as a dev: gentoo, as a contributor: archlinux, exherbo and various others
09:03:07 <glguy> If you plan on using stack exclusively you can let stack manage your GHC, if you plan on using stack sometimes you can have it use the one you install yourself
09:03:08 <leshow> never heard of exherbo
09:03:23 <ertesx> maerwald: people who consider themselves smart developers with a lot of background say similar things about haskell…  i won't question their background, but smart people get to wrong conclusions from time to time
09:03:27 <srhb> btcNeverSleeps: What glguy said :-)
09:03:29 <dysfun> haha, i used to hang out with the people who started exherbo
09:04:04 <btcNeverSleeps> srhb: I'd like to try Emacs's (newish) intero.el and Intero says it's opinionated: it's stack only. So I want to use Stack I guess.
09:04:31 <ertesx> maerwald: and that's fine, not everybody has to like haskell, but saying that "haskell is a bad language" because of a bad experience would be an uneducated insult
09:04:32 <srhb> btcNeverSleeps: Sounds like the way to go then. :)
09:04:51 <dysfun> "I just tried this and it works. It just works. I have never had this experience with Haskell + Emacs. Thank you so much for this." -- Intero website
09:05:18 <maerwald> ertesx: you are throwing "uneducated" around without actually knowing it. I told you my opinion and that going into detail is offtopic here. Calling people uneducated is rather offensive than just expressing your opinion on a technical matter.
09:05:31 <btcNeverSleeps> dysfun: yup, I read the reddit thread. Lots of past bad experiences similar to mine and then people saying intero "just works", so I want to try it.
09:05:45 <dysfun> i'm trying it now :)
09:06:14 <bbear> mmh I got a great deal of trouble with stack
09:08:25 <btcNeverSleeps> can stack be installed without the root user account? It's asking "[sudo] password for john:"
09:08:39 <btcNeverSleeps> (when I try to launch the Stack shell script)
09:09:37 <leshow> what do you guys think of elixir
09:09:44 <ertesx> maerwald: fine, scratch the "uneducated"…  you didn't express your opinion, you expressed an untrue claim based on your opinion…  your knowledge about the matter is either outdated or just wrong, and that's why i say "uneducated"
09:10:05 <srhb> btcNeverSleeps: I'm assuming it's trying to get its dependencies.
09:10:13 <srhb> btcNeverSleeps: via your package manager. But I'm not sure.
09:10:15 <maerwald> ertesx: I think we just have different standards of quality in terms of packaging I guess.
09:10:24 <srhb> btcNeverSleeps: http://docs.haskellstack.org/en/stable/install_and_upgrade/#linux -- you can see them here
09:10:28 <ertesx> maerwald: now you're insulting me personally
09:10:35 <maerwald> I am not
09:10:41 <leshow> ertesx: dude relax
09:11:02 * Clint squints.
09:11:31 <maerwald> I guess I will just stop talking about it.
09:11:37 <dysfun> leshow: i think it's got a great VM behind it but it's not to my taste. i prefer lisp-flavoured-erlang
09:12:08 <leshow> having never written ruby before the syntax was a bit odd to me, but it's grown on me
09:12:21 <ertesx> that's a good choice, i'll do the same
09:12:43 <leshow> haskell, elm and elixir are my current 'play' languages during my free time
09:12:50 <dysfun> leshow: i can take or leave the ruby syntax, but it's the way they've made it a huge language all of a sudden
09:12:55 <bbear> http://textuploader.com/5i1pe <-- here you go for the problem.
09:13:15 <glguy> bbear: did you read any of the output?
09:13:20 <leshow> dysfun: what do you mean? is it substantially larger than erlang?
09:13:23 <bbear> well did you ?
09:13:31 <btcNeverSleeps> srhb: ah it's indeed saying "Install dependencies..." 
09:13:47 <leshow> it doesnt seem that 'big', maybe i havent dug enough into it
09:13:54 <btcNeverSleeps> Hmmm... I manually installed the dependencies and stack is still asking for root password. I already don't like that.
09:14:02 <dysfun> leshow: they've layered a whole load of structures that you don't get in erlang on top. and they've added gratuitous macros everywhere. it's a lot to remember
09:14:02 <bbear> leshow
09:14:23 <glguy> bbear: Yeah, you pasted a page of "Cannot write: No space left on device"
09:14:23 <bbear> http://pastie.org/10897904
09:14:36 <leshow> bbear: yeah?
09:14:41 <bbear> that's weird, I thought /tmp could handle some data.
09:14:55 <bbear> leshow, take a look at the above link, it says /tmp is on tmpfs
09:15:03 <ertesx> bbear: /tmp is usually a RAM-disk
09:15:09 <leshow> ok?
09:15:14 <ertesx> or not usually, but very often
09:15:17 <dysfun> tmpfs is a memory-backed filesystem
09:15:24 <bbear> well basically I should try to extract elsewhere ?
09:15:31 <dysfun> yes, like onto a real filesystem
09:15:32 <monochrom> "tmpfs" is RAM disk. it is going to be small.
09:15:49 <bbear> ok, but is that ok for most applications but not stack ?
09:16:05 <bbear> Anyway, why stack would attempt to extract into /tmp/some_folder ?
09:16:06 <dysfun> don't put large things in /tmp
09:16:30 <bbear> dysfun: yeah, so that's good practice, as you just said. But good practice that stack developpers are not following.
09:16:45 <saurabhnanda> when using the yesod scaffold, does anyone know how to give the app a custom module name?
09:16:49 <bbear> I'd maybe fill in a bug report, or, if some stack developper is around( he can do it )
09:16:54 <nitrix> Which of reactive-banana and netwire is easier for someone learning FRP and which is more practical for writing (1) a game (2) a gui application?
09:17:10 <dysfun> bbear: on the other hand, where else should one put temporary files? there is no 'good' option
09:17:22 <ertesx> nitrix: as the developer of netwire i recommend that you don't use it…  my current recommentation is reflex
09:17:40 <bbear> mmh yes, you maybe right. But I don't see why it would need to be a temporary location.
09:17:50 <nitrix> ertesx: That's an honest answer?
09:17:51 * dysfun is just starting a reflex-dom project
09:18:02 <bbear> if the program is just unpacking to move after in ~/.stack/ that things, it useless.
09:18:11 <nitrix> ertesx: Not even reactive-banana?
09:18:30 <bbear> If not, so, what is it doing in /tmp ? You could create a user ~/.tmp20390 folder to do your thing into it.
09:18:47 <ertesx> nitrix: yes, i already wrote to haskell-cafe that i'm going to deprecate netwire…  i'm working on a much simpler and easier to maintain replacement, but very slowly
09:18:49 <leshow> nitrix: no love for elm?
09:18:52 <dysfun>  /tmp is explicitly for temporary files, however. ~ is not
09:18:57 <bbear> It would be the same and would avoid, I bet, most problems of sharing files between different file systems.
09:19:19 <dysfun> leshow: i am trying to port some elm to haskell
09:19:36 <bbear> IMO, /tmp is made imho for « volatile » things. 
09:19:44 <bbear> not what is it used for right here.
09:19:50 <dysfun> right, and something that's going to go away in a couple of minutes is volatile
09:19:52 <ertesx> nitrix: reflex has a few benefits over reactive-banana that make it more practical like efficient event combinators
09:19:53 <leshow> dysfun: elm to haskell? elm transpiles to js, why would you write that in haskell
09:20:00 <monochrom> there is probably a command line option to redirect temp files
09:20:04 <dysfun> leshow: because i am dissatisfied with elm
09:20:07 <ertesx> nitrix: not that reactive-banana is a bad library…  i used to recommend that one before reflex came along
09:20:11 <bbear> again if the plan is to move that files (ie copy them elsewhere) the first location to be thought of is not /tmp.
09:20:12 <dysfun> (and ghcjs exists)
09:20:16 <maerwald> dysfun: try purescript
09:20:19 <maerwald> it's more powerful 
09:20:29 <leshow> dysfun: i just dont understand how you're going to write your web frontend in haskell and have it transpile to js
09:20:39 <leshow> dysfun: unless you use something like purescript
09:20:43 <ertesx> bbear: try this:  mkdir ~/mytmp && TMP=~/mytmp mycommand
09:20:46 <dysfun> leshow: or ghcjs
09:20:54 <ertesx> bbear: that should make 'mycommand' use ~/mytmp
09:21:00 <nitrix> ertesx: That's very appreciated. Does the recommendation still stand for writing a game and/or learning FRP in general?
09:21:02 <dysfun> maerwald: why should i use it over ghcjs?
09:21:16 <leshow> dysfun: what about elm dont you like?
09:21:16 <maerwald> dysfun: simpler, more readable output?
09:21:25 <maerwald> ghcjs is a beast
09:21:34 <maerwald> also, purescript has a better effect system imo
09:21:43 <ertesx> nitrix: for the latter definitely, for the former i'm not entirely sure
09:21:55 <dysfun> yes, i just compiled the hello world reflex and it came out at 1.9mb
09:22:05 <dysfun> but for this project, i don't care
09:22:11 <ertesx> nitrix: AFRP has more predictable performance, which becomes relevant when dealing with hundreds of thousands of dynamically created and destroyed objects
09:22:16 <nitrix> ertesx: I liked that reactive-banana had the two basis theorical types of "Event" and "Behavior" as presented by Conal Elliott :/
09:22:24 <maerwald> dysfun: makes frontend-debugging really fun without codemaps xD
09:22:31 <ertesx> nitrix: reflex has those, too…  it's FRP
09:22:56 <ertesx> nitrix: reactive-banana and reflex have almost the same semantics
09:22:59 <nitrix> ertesx: Okay. I'll look into it then.
09:23:24 <nitrix> Then evaluate if AFRP is worth investing time before attacking this game.
09:23:30 <monochrom> hell, hello world IO takes 2.2MB
09:23:54 <ertesx> nitrix: in general AFRP is the more awkward choice…  i used to choose it most of the time, because it has efficient switching and predictable performance
09:23:57 <maerwald> it's like Cython xD
09:24:25 <ertesx> nitrix: those were the very things reactive-banana lacked (reflex wasn't around)
09:24:46 <nitrix> ertesx: It's often what happens. Increased complexity for better performances.
09:24:55 <leshow> im sort of surprised, i thought guys here would like elm. granted the 0.17 release kind of sucks since they got rid of signals
09:25:15 <ertesx> nitrix: it's not even necessarily *better* performance, just more predictable (though most of the time it's also better)
09:25:21 <dysfun> i only actually tooik elm seriously at 0.17
09:25:38 <dysfun> mostly because haskell already does FRP and i wanted to see what this allegedly much better approach was about
09:25:50 <nitrix> ertesx: I don't need anything _too_ fancy, so maybe reflex is the sweet spot. I'll let you know how far my learnings go. Maybe the questions I have or the needs for my projects will guide me elsewhere.
09:25:57 <nitrix> ertesx: Thank you.
09:26:18 <leshow> i really like the simplicity of elm. and it looks familiar coming from redux
09:26:29 <ertesx> leshow: elm was a good choice before the "farewell to FRP" post: http://elm-lang.org/blog/farewell-to-frp
09:26:43 <leshow> yeah that's what i mean, losing signals was a bad choice
09:26:46 <ertesx> leshow: but even then i didn't use or recommend it, because it was never really "FRP"
09:26:53 <dysfun> what i don't like in elm is simply i got bored of rewriting code that was in the haskell standard library, but not even in the elm community libraries
09:27:20 <maerwald> elm still has no typeclasses right?
09:27:24 <dysfun> yup
09:27:24 <marchelzo> that is the problem with DSLs of any kind
09:27:37 <maerwald> how can you take the language seriously even
09:27:42 <leshow> since elm lost signals it's basically just, pass these things off to a magic Html.App function
09:28:08 <dysfun> it solved my use case
09:28:09 <leshow> maerwald: you cant take any language seriously that doesnt have typeclasses?
09:28:27 <maerwald> leshow: that's not what I said
09:28:31 <ertesx> nitrix: if reflex turns out to be not the thing for you, you'll probably need AFRP after all…  in that case my recommendation is Yampa
09:29:09 <monochrom> does AFRP mean arrow FRP?
09:29:32 <ertesx> nitrix: alternatively jle` made a netwire-inspired automaton calculus for locally stateful programming:  see the 'auto' library
09:29:55 <ertesx> nitrix: it's closer to what netwire feels like, but it's even further away from FRP
09:30:22 <ertesx> monochrom: arrowised or applicative, you choose
09:30:39 <leshow> maerwald: what about elm doesnt allow you to take it seriously
09:30:50 <dysfun> anyway, i wanted to understand what this new supposedly better-than-frp model was about
09:30:57 <maerwald> leshow: the lack of typeclasses makes it uninteresting
09:31:00 <dysfun> i'm not convinced it's better than FRP
09:31:17 <leshow> so.... exactly what i said lol
09:31:21 <maerwald> leshow: no
09:31:25 <ertesx> dysfun: you mean elm?
09:31:27 <leshow> hahaha
09:31:28 <dysfun> yes
09:31:29 <maerwald> you interpreted something into my statement that is not there
09:31:46 <leshow> you just repeated it back to me
09:31:48 <ertesx> dysfun: it went from "easy to use" to "easy to learn"
09:32:08 <maerwald> leshow: no, I didn't. I was talking about elm, not about languages in general.
09:32:25 <leshow> i was asking about elm
09:32:25 <maerwald> so don't twist my words please
09:32:26 <dysfun> ertesx: well i very much agree it was easy to learn. it's just that once i'd gotten to grips with it, i started wanting things like typeclasses and the missing half of the haskell standard library
09:32:44 <maerwald> leshow: "leshow: maerwald: you cant take any language seriously that doesnt have typeclasses?"
09:32:52 <dysfun> and i can see there are certain problems that it would suck to solve with elm
09:33:57 <leshow>  "what about elm doesnt allow you to take it seriously" "the lack of typeclasses makes it uninteresting"
09:34:03 <ertesx> dysfun: i use haskell since ~2007, so i can easily forgive having to write a few things myself, if the language is actually easy to use
09:34:24 <maerwald> leshow: exactly, do you see the difference of talking about "elm lacking typeclasses" vs "any language lacking typeclasses"?
09:34:44 <leshow> im not talking about any language, im talking about elm
09:34:47 <dysfun> ertesx: well it was easy up until the point where i wanted to solve some problems they haven't solved to their own satisfaction yet (and thus just don't support)
09:34:56 <maerwald> leshow: why did you ask me about languages in general then?
09:35:02 <ertesx> dysfun: elm as a programming language is not easy to use (by a haskell programmer's standards), but if all you use it for is GUIs, then even that could be forgiven
09:35:04 <dysfun> ertesx: e.g. i wanted to upload an image file. javascript ports and stuff. it was all very painful
09:35:35 <dysfun> yes, they just entirely don't support uploading binary blobs with POST
09:35:56 <dysfun> and because of the lack of loads of features haskell has, i had no choice but to use javascript
09:36:02 <dysfun> it was all very tedious
09:36:10 <leshow> the lack of typeclasses means you "cant take it seriously" i want to know why that is specifically a problem for elm
09:36:11 <ertesx> dysfun: now elm is not even useful as a GUI toolkit anymore…  you can't really write an FRP library for it, and it's not FRP itself (has never been)
09:36:20 <leshow> and not for any other language
09:37:09 <dysfun> leshow: because it's haskell-lite?
09:37:11 <maerwald> leshow: how can you abstract over problems without typeclasses in a functional high-level language? Does elm offer an alternative approach? Then I don't see it.
09:37:20 <ertesx> bottom line:  the time-travelling debugger is not an excuse to give up everything else…  it feels more like a gimmick to a bad tool now
09:37:39 <leshow> see, answering wasnt so hard
09:37:56 <maerwald> leshow: well, you just started to ask answerable questions
09:38:13 <maerwald> I don't want typeclasses in bash
09:38:21 <maerwald> so I don't know how to answer your previous question
09:39:37 <leshow> ill be sure to spell it out for you more next time
09:39:39 <maerwald> https://github.com/elm-lang/elm-compiler/issues/38
09:40:40 <leshow> i think they probably dont include typeclasses because it's a concept that may be hard for people coming from javascript to understand
09:40:49 <leshow> which is their target audience, i guess
09:40:54 <maerwald> I think it might just be hard to implement
09:41:27 <maerwald> on that issue, an elm member declared his interest in type classes in 2012
09:41:30 <hpc> most of type classes should be pretty obvious to a javascripter, except perhaps the non-overlapping property
09:41:32 <maerwald> since then, it seems nothing has happened
09:41:35 <leshow> yeah im reading the thread
09:42:05 <leshow> if by elm member you mean evan, he wrote the language
09:43:54 <suppi> type classes has their own share of problems. i respect elm for not reaching for them straight away trying to find a better solution to the underline problem
09:44:37 <leshow> they are 'still' just at 0.17 after all, the language has changes pretty majorly even on the latest release
09:44:37 <ertesx> they could have taken inspiration from idris
09:44:42 <suppi> however, having a language with no mechanism for abstracting code is painful IMO
09:45:18 <ertesx> elm has all the abstraction capabilities, but everything has to be explicit
09:45:45 <ertesx> lack of type classes is annoying, but it doesn't really limit you by itself
09:45:49 <suppi> ertesx, can you write a sequence function generically?
09:45:55 <ertesx> suppi: sure
09:46:02 <suppi> ertesx, please describe
09:46:21 <ertesx> sequence :: Applicative f -> [f a] -> f [a]
09:46:27 <suppi> in elm..................
09:46:31 <ertesx> sequence : Applicative f -> [f a] -> f [a]
09:46:47 <suppi> elm doesn't have higher kinded types
09:46:52 <suppi> so you can't write `f a`
09:46:54 <leshow> [a] isnt elm
09:46:56 <leshow> its List a
09:46:56 <ertesx> oh?
09:47:02 <ertesx> didn't know that
09:47:04 <leshow> and no Applicative
09:47:06 <suppi> :)
09:47:20 <ertesx> lack of higher-kinded types is a genuine limit =)
09:47:24 <leshow> hahah
09:47:27 <suppi> as i said.
09:48:10 <bbear> ertesx: actually the answer you have provided just doesn't make the trick.
09:48:17 <maerwald> suppi: yeah, I don't really care how they achieve it, but if you don't get that level of abstraction, why would you choose that over purescript?
09:48:23 <ertesx> suppi: it surely does have higher-kinded types, doesn't it?  what it lacks is probably polymorphism on those
09:48:52 <suppi> maerwald, you are asking the wrong person. i clearly chose purescript :)
09:49:14 <ertesx> bbear: sorry to hear…  you can probably bind-mount /tmp to a disk in a mount namespace…  wait…
09:49:15 <suppi> ertesx, alright, so polymorphism on those.
09:49:16 <leshow> no there's no HKT
09:49:32 <ertesx> suppi: that's awful…  feels like going back to C#
09:49:44 <ertesx> and yes, you actually can't write 'sequence' in it
09:50:17 <maerwald> you have an IDE for that, which generates the code!
09:50:30 <suppi> do you? :)
09:50:41 <suppi> oh, you mean in C#?
09:50:58 <ertesx> hehe
09:51:32 <ertesx> yeah, anything that starts with "visual" makes up for lack of abstractions with automatic code generation
09:51:38 <suppi> isn't this basically what Go people do? use code generation tools instead of copy paste themselves?
09:51:58 <leshow> suppi: basically, and a lot of copy-paste. there are no generics in go
09:52:09 <leshow> so you there are some things which you literally must just copy-paste
09:52:14 <leshow> and that's the only solution
09:52:31 <maerwald> so... do we have code-generation tools for elm too?
09:52:32 <ertesx> bbear: this is a major hack, but you can do the following:
09:52:33 <suppi> leshow, or use code generation tools that does copy pasting for you, right?
09:52:35 <leshow> it's more of an issue for Go, IMO because that's a general purpose language
09:52:58 <leshow> whereas elm's domain is specifically writing web frontends
09:53:07 <ertesx> bbear: unshare -fmrU  # after this command, you will find yourself in a virtual root shell…  you're still your regular user, but now you can do mounts
09:53:25 <suppi> also elm does have parametric polymorphism and stuff...
09:53:26 <ertesx> bbear: now do this:  mkdir ~/mytmp; mount --bind ~/mytmp /tmp
09:53:42 <ertesx> bbear: then run the program that needs a lot of /tmp space…  it now writes to ~/mytmp
09:54:04 <suppi> I'm more interested in purescript myself though :}
09:54:26 <leshow> suppi: do you write a lot of web frontends?
09:54:43 <suppi> leshow, no, i don't.
09:55:14 <leshow> so conceptually, you like it probably because it's more similar to haskell?
09:55:21 <ertesx> bbear: don't worry, the rebound /tmp is only visible within that shell
09:55:27 <dysfun> btcNeverSleeps: on nixos, intero does not 'just work'
09:55:52 <suppi> leshow, that's part of it. if you are interested, i've made some slides about it: https://soupi.github.io/ps-evangelism/
09:56:11 <leshow> i write a lot of frontends, granted this is anecdotal. but i haven't found myself wanting to reach for HKT when writing front ends very often
09:57:53 <ertesx> isn't purescript more like javascript than haskell?  i understood it as:  javascript with types, sensible syntax and polished semantics
09:57:57 <suppi> leshow, i wrote a small game in elm once. i later thought i might abstract it to something i could reuse
09:58:26 <suppi> ertesx, try it and see for yourself. it wouldn't take more than 5 minutes :) http://try.purescript.org 
09:58:52 <suppi> leshow, i gave up a few days later. i couldn't do what i wanted to do
09:59:16 <ertesx> hmm…  they're using cloudflare =/
09:59:23 <suppi> oh course, if it works for you, great! it didn't work for me
10:00:34 <ertesx> is there an FRP library for purescript?
10:00:43 <dysfun> suppi: the emacs integration in your slides looks nice
10:01:00 <suppi> ertesx, no. there are reactive libraries however
10:01:08 <suppi> like purescript-signal
10:01:24 <ertesx> hmm
10:01:33 <suppi> and a few UI frameworks like pux, thermite and halogen
10:01:49 <ertesx> what about concurrency?  or at least the language features to implement coroutines?
10:01:50 <suppi> pux is very inspired from elm 0.16
10:02:09 <dysfun> suppi: what would you recommend for someone who knows haskell and elm 0.17 but not ps?
10:02:53 <dysfun> i have a single page administration app in javascript that i want shot of. the most complicated things it does are reorder lists of data that are reflected in the dom and POST files
10:02:57 <suppi> dysfun, if you are interested in UI, perhaps start following one of the UI libraries tutorials, like pux
10:03:24 <suppi> also come to the purescript channel to ask people much more informed than i :)
10:03:27 <ertesx> if PS supports non-strict functions and fields and doesn't choke on tail calls, i might actually try it
10:03:52 <suppi> ertesx, there's a library for coroutines but i'm not very familiar with that area: https://github.com/purescript-contrib/purescript-coroutines
10:04:30 <suppi> dysfun, this is pux: http://www.alexmingoia.com/purescript-pux/
10:05:09 <dysfun> oh it uses react :/
10:05:17 <suppi> purescript is currently in a transition stage from 0.8.5 to 0.9.1 so some things might be off
10:05:17 <ertesx> suppi: if you can't have concurrency, coroutines are the closest you can get to it
10:05:32 <suppi> dysfun, is that bad?
10:05:37 <ertesx> suppi: you've probably used a few special cases in haskell already:  iteratees, pipes, conduit, monad-coroutine, free, …
10:05:48 <dysfun> i've had many negative experiences with react and wrappers thereof
10:06:25 <suppi> dysfun, halogen runs on top of vdom, but has a higher learning curve
10:06:46 <dysfun> link?
10:06:47 <bbear> ertesx: unshare -fmrU
10:06:52 <bbear> it's just not working
10:06:58 <suppi> https://github.com/slamdata/purescript-halogen
10:07:01 <dysfun> ty
10:07:28 <suppi> also this exists: https://github.com/purescript/purescript/wiki/Differences-from-Haskell
10:08:36 <dysfun> oh, does purescript do the elm thing of 'bag of data' records?
10:08:52 <dysfun> i see `type State = { on :: Boolean }`
10:09:10 <dysfun> i thought it was pretty nice in elm
10:09:13 <suppi> it can if you want
10:09:21 <ertesx> bbear: huh?  either you're on a virtual machine hoster, or your operating system is really old
10:09:21 <suppi> records are first class
10:09:30 <suppi> and are extensible
10:09:42 <dysfun> neat
10:09:49 <suppi> very! :)
10:10:05 <dysfun> oh, how does it handle text fields? i've had nightmares about doing it in react
10:10:33 <dysfun> (halogen)
10:11:01 <suppi> dysfun, I haven't tried that yet. sorry
10:11:11 <suppi> i've mostly played with canvas and stuff
10:11:16 <lpaste> Cir0X pasted “lev” at http://lpaste.net/168956
10:11:22 <dysfun> basically my entire app is text fields and image upload fields
10:12:06 <Cir0X> Why does this where clause in lev doesn't work? http://lpaste.net/168956
10:12:29 <suppi> Cir0X, what do you mean by doesn't work?
10:13:36 <suppi> dysfun, best to ask in the purescript channel :) i don't know of a reason why it shouldn't work
10:15:52 <Cir0X> suppi: ghc tries to match type 't1 a1' with Int. What kind of type is 't1 a1' ?
10:16:07 <glguy> Cir0X: What type do you think lev should have?
10:16:54 <Cir0X> glguy: The parameters should be [Char]'s
10:17:09 <glguy> Cir0X: OK, add that type annotation to the file and get a new error message
10:17:22 <suppi> Cir0X, take a look of all applications of lev in your file
10:18:08 <suppi> check that the arguments you pass to lev match everywhere
10:18:10 <glguy> Cir0X: You're using lev inconsistently so you're going to get an error. If you add more information you'll get a more useful error
10:20:14 <glguy> Currently the problem is that the compiler knows that lev has Int arguments, not [Char]
10:21:34 <lpaste> Cir0X pasted “lev1” at http://lpaste.net/168957
10:22:24 <Cir0X> Now I get a wall of errors. I don't get it. Why doesn't he just define i with the length of a?
10:22:45 <glguy> You get a wall of errors because the function definite has a lot of errors
10:22:49 * hackagebot smallcheck-series 0.6 - Extra SmallCheck series and utilities  https://hackage.haskell.org/package/smallcheck-series-0.6 (jdnavarro)
10:22:56 <glguy> You'll applying lev to Ints
10:23:00 <glguy> You're
10:23:53 <Cir0X> glguy: Ups didn't changed that stuff :/ … sry for the dumb question
10:25:08 <suppi> also `lev (i - 1) + 1` <-- probably not what you want to do
10:25:31 <suppi> i mean `lev (i-1) j + 1`
10:25:56 <Cir0X> Going from this definition https://wikimedia.org/api/rest_v1/media/math/render/svg/f0a48ecfc9852c042382fdc33c19e11a16948e85 should I give lev 4 parameters then?
10:26:07 <Cir0X> *coming
10:26:58 <suppi> i... guess?
10:27:10 <suppi> i don't know. sorry
10:27:29 <glguy> Cir0X: You should have an outer function that takes the a and b, they never change
10:27:59 <glguy> and then internally you should build an array or map or something of all the (i,j) indexed computations
10:28:12 <glguy> so that you aren't recomputing them
10:28:49 <glguy> This is a common example of https://en.wikipedia.org/wiki/Dynamic_programming
10:33:47 <Cir0X> glguy, suppi: Thanks a lot for the help! I think I need to spend more time in the beginner tutorials
10:34:31 <suppi> np. good luck
10:41:48 <tippenein> how do I generalize this type signature? Int64 -> EntityField PersonStatement (Key Person) -> IO [Entity PersonStatement]   --- like Int64 -> EntityField a (Key b) -> IO [entity a]  ?
10:44:09 <tippenein> or even further by generalizing Int64 to the second part of EntityField a (_)
10:45:03 <saurabhnanda> so, yesod scaffold creates a complete project directory (with an independent .cabal file) which has a bunch of modules, but I couldn't find any way to give the modules a namespace, for example Nightwatch.Webapp instead of Application. If my yesod site is part of a larger app, is there any easy way to do this? Can I create a dependency between a parent cabal project and a child cabal project, such that the child project's modules are in
10:45:04 <saurabhnanda>  a namespace defined by the parent project?
10:47:25 <sarfraz> saurabhnanda: you can create the Nightwatch.Webapp directory structure at the root of your app folder and add it to the the Application.hs an app.cabal file
10:47:59 <sarfraz> Or create a separate project with your logic and add it to the cabal file
10:48:12 <saurabhnanda> sarfraz: didn't quite understand the first approach
10:52:18 <saurabhnanda> help, please?
10:53:06 <sarfraz> saurabhnanda: I mean you can create the Nightwatch/Webapp directories (with your logic in it) in the same directory as your cabal file. And then add Nightwatch.Webapp.Module1 to your cabal file
10:55:10 <saurabhnanda> sarfraz: so, you're suggesting the other way around? Use the yesod scaffold as the base, and add the existing logic in a sub-module? I was trying to do the exact opposite. I have an existing app doing a bunch of low-level socket stuff, and I want to add a Yesod webapp for some admin/CRUD stuff. Want the Yesod webapp to be a submodule inside the main app. Is that possible with scaffolding?
11:06:25 <sarfraz> I don't think it is (not that I know). Maybe with stack, but is seems clanky (--> https://www.reddit.com/r/haskell/comments/42e7rl/stack_users_multiple_executables_in_one_cabal/)
11:10:49 <bollu> what is the difference between a type family and a data family?
11:10:59 <bollu> the haskell wiki is confusing, it seems to use both interchanggably?
11:11:07 <bollu> Intercharangably*
11:11:11 <bollu> omg, I can't type
11:11:20 <bollu> Interchangeably**
11:14:30 <nilof> Is there a way to set ghci so that if you :reload and it fails to compile, you still keep the bindings from the previous time you compiled successfully?
11:14:47 <dmj`> nilof: check out rapid
11:14:49 <oherrala> bollu: I think they might be synonyms
11:15:00 <dmj`> @package rapid
11:15:00 <lambdabot> http://hackage.haskell.org/package/rapid
11:15:18 <oherrala> bollu: ''Indexed type families, or type families for short, are a Haskell extension supporting ad-hoc overloading of data types.'' https://wiki.haskell.org/GHC/Type_families
11:15:36 <bollu> oherrala: I'm not so sure, I googled a little bit - it seems that there's some difference. Type Families need not "create a new data type" while a Data Family must
11:16:09 <bollu> oherrala: It seems to be some parallel to type x = … (which aliases) and data D = Constructor { ..} (which needs a constructor)
11:16:14 <bollu> but I'm still confused
11:16:23 <bollu> I want an example to highlight the difference
11:17:40 <bollu> also, what is the relationship between type families, GADT and dependant types?
11:21:43 <monochrom> unrelated. except "moar types".
11:22:16 <bollu> I see
11:22:33 <bollu> monochrom: GADT's let you bundle up constructors together
11:22:33 <bollu> ?
11:23:08 <monochrom> that is a non-sequitur description. ADT bundles up constructors, too.
11:23:11 <bollu> I've been reading this: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
11:23:15 <bollu> monochrom: hm
11:23:36 <bollu> monochrom: better characterisation: They let you explicitly write out the constructor in terms of functions?
11:23:49 <bollu> monochrom: rather than have the functions be generated from the type signature?
11:23:56 <bollu> monochrom: is that an okay way to think about them?
11:24:01 <monochrom> yes but that is reading the message wrong.
11:24:17 <bollu> monochrom: oh, okay. So what is the message?
11:25:26 <monochrom> if I write "data L a where {N :: L a; C :: a -> L a -> L a}", I am using GADT syntax, but I am merely defining an ADT. Therefore, function type syntax is not the point.
11:25:37 <glguy> bollu: type family and data familty are related similar to type synonym and data type
11:26:15 <bollu> monochrom: that would be equivalent to the type data L a = N | C a (L a) right?
11:26:18 <glguy> data families make new types, they have their own constructors
11:26:33 <monochrom> the moment I add "B :: L Int", i.e., "Int" as opposed to "a" there, that's when I begin to actually use the power of GADT
11:26:50 <bollu> glguy: do they "make new types", or do they "carry information about a new type"?
11:27:21 <bollu> monochrom: but, like, what does that _mean_? does that mean that B is a constructor of L  which lets you create an L Int?
11:27:23 <glguy> data families? new types
11:27:28 <monochrom> hint: I never learned GADT from wikipedia. not even the haskell wiki. I directly read the GHC user's guide.
11:27:57 <maerwald> honestly, I never learned anything from the haskell wiki (haha)
11:28:04 <bollu> monochrom: ooh. Link please?
11:28:05 <maerwald> most stuff there is just outright confusing
11:28:31 <monochrom> it means B's type is nailed at "L Int", and not polymorphically "L a". compare with N.
11:28:58 <bollu> monochrom: I see, so it lets you forcibly create an L Int
11:29:22 <monochrom> GHC user's guide comes with GHC. if you have installed GHC, it's already somewhere on your hard disk.
11:29:25 <bollu> monochrom: question: if I write a GADT function (for out type L) something like X :: Int -> Int -> Int -> L Int
11:29:39 <bollu> monochrom: is it possible for me not "not use" 2 of the 3 Int's or something?
11:29:44 <monochrom> mine is file:///usr/local/haskell/ghc-7.10.3-x86_64/share/doc/ghc/html/users_guide/index.html
11:29:47 <bollu> monochrom: like, can _I_ myself write the constructor?
11:30:14 <monochrom> "X :: b -> L Int" is allowed.
11:31:04 <bollu> monochrom: so, that will do what exactly? Like, will I have access to the "b" value once the L Int is created?
11:31:17 <bollu> monochrom: in fact, how is the L Int instantiated in the first place?
11:31:28 <EvanR> X "foo"
11:31:30 <EvanR> X 99
11:31:33 <EvanR> X False
11:31:35 <monochrom> and B
11:31:58 <bollu> EvanR: so will I be able to access the "b" ?
11:32:08 <bollu> EvanR: can I pattern match and extract the value?
11:32:09 <EvanR> yeah, which look like a forall a . a
11:32:25 <EvanR> so no
11:33:05 <bollu> hmm, I'm still kind of puzzled
11:33:16 <EvanR> youll have no basis to know what the type of the b is
11:33:32 <EvanR> remember all type info is deleted before runtime
11:33:36 <bollu> ah
11:33:43 <monochrom> you seem to be unable to make up your mind whether you're talking about building a value or consuming a value.
11:33:56 <bollu> monochrom: right now, I'm asking about consuming
11:34:04 <monochrom> then use pattern matching.
11:34:06 <bollu> monochrom: but I was interested in what happens while building
11:34:29 <bollu> monochrom: right, so I was wondering if I could pattern match on the (b -> L Int) type constructor
11:34:34 <monochrom> have you read the GHC user's guide yet?
11:35:02 <monochrom> you need to s/type constructor/data constructor/
11:35:20 <monochrom> in fact you also need to s/the (b -> L Int) type constructor/X
11:35:28 <bollu> monochrom: looking for it on my hard drive. Checking it out online right now
11:35:40 <monochrom> then it is obvious. yes you can pattern matching on X. it's a data constructor
11:36:20 <monochrom> case ??? of X v -> ... although v won't be very useful here, but it exists.
11:36:38 <monochrom>    B -> etc
11:36:46 <bollu> so the use of a GADT is to let you "force" the type variable to take a specific type upon instantiation?
11:37:01 <monochrom> I wouldn't call that instantiation.
11:37:25 <bollu> monochrom: what is the correct work?
11:37:26 <bollu> word*
11:37:37 <monochrom> some data constructors can change the type variable or make it monomorphic altogether
11:38:28 <EvanR> a good check on understand GADTs is to go back and define what the regular data Foo a = MkFoo a a a means in terms of GADTs
11:38:52 <bollu> EvanR: data Foo a where MkFoo :: a -> a -> a -> Foo a ?
11:38:55 <EvanR> its a more limited way to define data
11:39:05 <EvanR> subsumed by GADTs (clearly from the G...)
11:39:58 <EvanR> bollu: true, now what is that interesting?
11:40:02 <EvanR> why*
11:40:07 <EvanR> whats the key
11:40:43 <EvanR> you translated it into GADTs now what does it mean in terms of GADTs
11:40:52 <mniip> 1467570984 [21:36:24] <bollu> so the use of a GADT is to let you "force" the type variable to take a specific type upon instantiation?
11:41:07 <mniip> more specifically, you can put constraints on type variables
11:41:24 <bollu> EvanR: it means that I have a function that lets me instantiate a Foo a, which "bundles up" 3 a's together to create a Foo a?
11:41:52 <mniip> "MkFoo :: Foo Int" actually means "MkFoo :: (a ~ Int) => Foo a"
11:41:56 <maerwald> mniip: isn't that possible without GADTs too with some ghc extension?
11:42:20 <EvanR> the reason i brought it up is that GADTs make way more sense, all the things you can do with GADTs seem kind of natural after you get them, which leaves the shorthand ADTs in the lurch, their restrictions are kind of hard to explain to beginners, ime
11:42:22 <mniip> maerwald, not as generally, probably
11:42:40 <bollu> EvanR: so technically, we can deprecate the "old" data syntax?
11:42:47 <EvanR> its like, explaining prime numbers to someone before you explain numbers
11:43:21 <lpaste> bollu pasted “gadt-derive-show” at http://lpaste.net/168966
11:43:24 <monochrom> EvanR: I feel it is not like prime numbers before numbers. rather, numbers before rings and fields.
11:43:26 <ertesx> bollu: i'd vote not to deprecated it, but rather make it syntactic sugar, as it's often more convenient
11:43:40 <bollu> why can I not derive show for a GADT?
11:43:46 <ertesx> data Bool = False | True  -- short and sweet
11:43:51 <mniip> apparently you can
11:43:52 <mniip> @let data Foo a = (a ~ Int) => Foo
11:43:53 <lambdabot>  Defined.
11:43:53 <ertesx> bollu: you can
11:43:56 <EvanR> monochrom: agreed IF regular ADTs were simple in comparison
11:43:57 <hpc> | FILE_NOT_FOUND
11:44:01 <bollu> ertesx: can you check my paste?
11:44:08 <bollu> http://lpaste.net/168966
11:44:14 <monochrom> regular ADTs are simple.
11:44:22 <maerwald> mniip: so it's just different syntax in the end?
11:44:30 <EvanR> well *waits for bollu to explain what is special about regular ADTs*
11:44:32 <maerwald> given you use those ghc extensions
11:44:35 <ertesx> bollu: what's the error message?
11:44:43 <hpc> :t Foo
11:44:44 <ertesx> it usually tells you why it can't derive
11:44:45 <lambdabot> Foo Int
11:44:48 <monochrom> bollu is not a good example
11:44:50 <hpc> mniip: oooooooooooh
11:44:51 <EvanR> heh
11:44:51 <bollu> EvanR: I'm not sure I see anything "special"., just that they're more restricted
11:44:58 <EvanR> what is the restriction?
11:45:02 <bollu> monochrom: I'm not a good example? >_<
11:45:25 <mniip> @let data N = Z | S N
11:45:26 <lambdabot>  Defined.
11:45:38 <ertesx> you can get GADT expressivity with RankNTypes and TypeFamilies
11:45:41 <bollu> EvanR: ADTs don't allow one to add constraints on the type variable. It will be the most general?
11:45:47 <EvanR> its not just constraints
11:45:50 <EvanR> but thats one restriction
11:46:04 <bollu> EvanR: there's more?
11:46:06 <mniip> @let data List (n :: N) a = (n ~ Z) => Nil | (n ~ S m) => Cons a (List m)
11:46:07 <lambdabot>  .L.hs:161:31: Not in scope: type variable ‘m’
11:46:08 <lambdabot>  
11:46:08 <lambdabot>  .L.hs:161:50: Not in scope: type variable ‘m’
11:46:30 <mniip> @let data List (n :: N) a = (n ~ Z) => Nil | forall m. (n ~ S m) => Cons a (List m)
11:46:31 <lambdabot>  .L.hs:161:56:
11:46:31 <lambdabot>      Expecting one more argument to ‘List m’
11:46:31 <lambdabot>      Expected a type, but ‘List m’ has kind ‘* -> *’
11:47:00 <mniip> List m a was what was needed
11:47:05 <mniip> :t Cons
11:47:06 <lambdabot> a -> List m a -> List ('S m) a
11:47:08 <EvanR> what are you spamming?
11:47:15 <ertesx> @let newtype Something a = Something { forall r. ((a ~ Int) => Int -> r) -> ((a ~ Bool) => Bool -> r) -> r }
11:47:15 <lambdabot>  Parse failed: Parse error: r
11:47:25 <ertesx> @let newtype Something a = Something { runSomething :: forall r. ((a ~ Int) => Int -> r) -> ((a ~ Bool) => Bool -> r) -> r }
11:47:27 <lambdabot>  Defined.
11:47:27 <bollu> EvanR: what am I missing when it comes to vanilla ADT's?
11:48:29 <ertesx> that's the RankNTypes + TypeFamilies equivalent of:  data Something :: * -> * where SomeInt :: Int -> Something Int; SomeBool :: Bool -> Something Bool
11:48:53 <EvanR> bollu: sorry having a hard time seeing through all this type family stuff
11:48:59 <ertesx> (i find it awkward that you need TypeFamilies for equiality contexts)
11:49:12 <bbear> hey ppl
11:49:26 <ertesx> equality
11:49:32 <bbear> I just wanted to say how awkward a feeling I have toward haskell today (that's not the first time though).
11:49:37 <mniip> ertesx, no need to CPS-transform it
11:49:59 <bollu> bbear: "awkward" as in?
11:50:04 <ertesx> mniip: i think for the non-CPS variant you need ExistentialQuantification, don't you?
11:50:10 <mniip> data Something a = (a ~ Int) => SomeInt a | (a ~ Bool) = SomeBool a
11:50:11 <mniip> yesh
11:50:15 <EvanR> bollu: MkFoo :: a -> a -> a -> Foo a, i write this. but with a reguar ADT is didnt *really* write the a in Foo a, that was chosen for me
11:50:31 <EvanR> the thing after the last -> is not under my control
11:50:39 <Hafydd> Don't get the wrong idea! I-it's not like Haskell or anything!
11:50:45 <Hafydd> *like I like
11:50:47 <bbear> bollu: "awkward" as in (angry and despised)
11:50:55 <bollu> EvanR: ahh
11:51:08 <bollu> EvanR: I see, so it's not even "upto you"
11:51:27 <bbear> but nevermind. I just found out that haskell is weird to use in production code.
11:51:38 <Hafydd> bbear: how did you discover this?
11:51:40 <ertesx> bbear: through my limited view on your problem, i'd say that you have a bad feeling about stack
11:51:52 <ertesx> not haskell
11:52:19 <Tor_> Has anybody had luck with using GHC with Windows' new BASH feature?
11:52:25 <EvanR> bollu: this doesnt have a notational analog with shorthand MkFoo :: a -> a -> a -> Foo b, or MkFoo :: a -> a -> a -> Foo (MyTypeManipulator a Int)
11:52:50 <bbear> yes, but also, I don't quite understand the fact that the compiler needs so much lib to run.
11:52:57 <bollu> EvanR: right. it's just not possible wth regular ADT's right?
11:53:07 <EvanR> actually the b does have an analog..   mean
11:53:26 <bbear> And why installing for example just a library like "hakyll" comes with so much dependancies. It doesn't seem that much suited for e.g. deployment.
11:53:36 <EvanR> bollu: ... see i cant even explain what the normal notation fucks up
11:53:51 <bbear> It seems like to get the cherry on the cake you need to eat all the cake. That may be heavy.
11:54:01 <bollu> EvanR: xD
11:54:20 <bbear> just saying. No ill feeling.
11:54:21 <ertesx> bbear: haskell libraries tend to be smaller, so you often get larger dependency graphs than with other languages…  whether that's a good or bad thing is a question of philosophy
11:54:25 <EvanR> bollu: you have to use universally quantified variables in each position of the final type
11:54:47 <bollu> EvanR: so we wrote that down?
11:54:52 <EvanR> and its not just any variables, they have to all agree across constructors
11:55:24 <ertesx> bbear: hakyll in particular (or rather pandoc, which it depends on) has a huge dependency graph
11:55:56 <hpc> it's usually a good thing if you can automate the dependency graph in a way that's favorable to your use case
11:55:58 <maerwald> well, I think every high-level language has that kind of problem, some more than others
11:56:01 <bbear> ha, yes, that is the fault to pandoc, I forgot. Yeah. I consider this pandoc to be a huge and great piece of software indeed.
11:56:12 <bbear> I don't think it has any equivalent
11:56:34 <hpc> i ran into a thing with stack where adding a dependency i already needed to stack.yaml made it rebuild all the dependencies
11:56:37 <maerwald> bbear: did you ever install javascript, ruby oder python stuff?
11:56:46 <maerwald> yes, there are equivalents
11:56:57 <hpc> ie, stack.yaml => A-x.x.x.x => B-x.x.x.x
11:57:08 <ertesx> bbear: i know the feeling…  i remember having to work with such delightful environments as grunt and bower
11:57:11 <hpc> to stack.yaml => (A-x.x.x.x, B-x.x.x.x)
11:57:29 <bbear> maerwald: yes, a lot. I d say pandoc needs something like 1G of dependencies. I don't know of a software that comes with that much. GHC himself is pretty big I think.
11:57:32 <ertesx> bbear: but i can tell you that with haskell the feeling goes away =)
11:58:02 <hpc> that kind of thing can get very annoying if you are dealing with a very deep tree
11:58:21 <bbear> To me stack doesn't seem that much mature and user friendly.
11:58:36 <ertesx> bbear: i'm not referring to stack…  i don't use it myself
11:58:40 <bbear> Well, anyway i'm not familiar with build system in haskell to start with.
11:58:44 <EvanR> pandoc is kind of insane, it has support for almost infinite stuff
11:58:51 <EvanR> im not surprised by its deps
11:59:01 <ertesx> bbear: try just the classic old cabal-install
11:59:23 <EvanR> otoh why are we using cabal *or* stack to install pandoc
11:59:38 <EvanR> or any program
11:59:52 <hpc> i prefer cabal myself, but stack's "let me do this other stuff for you too" design is the best thing to happen to windows haskell
12:00:10 <monochrom> I am not going to defend the large dependency size. But I want to remark that it has no impact on deployment, in the exe case.
12:00:47 <alesaico> hi
12:00:49 <monochrom> You just copy the exe over, and you're done. The trillions of libraries depended on are in that exe already.
12:00:51 <bbear> monochrom: ah, yeah ? Truly ? Ok, interesting. So for production environment, you have to stick with compiled programs, that is the lesson I learned today I suppose.
12:00:57 <maerwald> bbear: look at paraview or blender, those don't even use high-level languages, but have a huge depgraph
12:01:07 <bbear> monochrom: but you lose the dynamic linking thing.
12:01:34 * bbear dunno if haskell can do dynamic linking.
12:01:42 <ertesx> bbear: you don't have to, but it's an option…  personally i prefer dynamic linking
12:01:47 <monochrom> The beauty of it is that now that you can't complain about deployment nightmare, you can switch to complaining about exe size.
12:02:08 <EvanR> bbear: osx dropped this issue long ago
12:02:11 <monochrom> GHC can. Why do you want it? So that you can complain about deployment nightmare?
12:02:18 <EvanR> apps come in a bunble, no more complaining 
12:02:31 <maerwald> much secure
12:02:37 <bbear> You mean there is no shared libraries in OSX (at all?)
12:02:52 <EvanR> there are but, different apps that use their own bundled libs will not share them
12:03:01 <maerwald> basically windows
12:03:02 <bbear> monochrom: just try to assess some software dev. problems.
12:03:15 <ertesx> so that's why macs come with so much RAM
12:03:16 <EvanR> it might be even more extreme on windows, zip of DLLs
12:03:19 <ertesx> even windows can share…
12:03:32 <ertesx> of course if you actually do share…
12:03:35 <maerwald> ertesx: and you can download missing dlls from fishy websites too!
12:03:41 <ertesx> hehe, yeah
12:03:44 <bbear> Maerwald :)
12:04:14 <EvanR> i dont recommend deploying your program with missing libraries
12:04:24 <EvanR> its not good for the user experience
12:04:26 <maerwald> so slackware is out of the window xD
12:04:35 <EvanR> eh?
12:04:59 <maerwald> EvanR: slackware does not do dependency resolution ;) so you can deploy with missing libraries
12:05:16 <EvanR> slackware doesnt deploy your program
12:05:18 <ertesx> you don't "deploy" with slackware…  you copy files…
12:05:43 <maerwald> EvanR: I said "you can deploy with missing libraries" not "slackware deploy your program with missing libraries"
12:05:45 <EvanR> no you usually rebuild from source
12:05:57 <EvanR> something like chrome comes bundled with all its libraries
12:06:13 <EvanR> maerwald: you can on any system, i recommend not
12:06:28 <maerwald> EvanR: no, unless you circumvent the system tools
12:06:31 <monochrom> Clearly, Slackware is out of Windows, not in. :)
12:06:43 <maerwald> anyway, it seems you didn't get the joke
12:06:55 <EvanR> what system stops you from copying an exe onto the computer running it and getting a linker error
12:07:25 <maerwald> if you call copying exe's deployment, then I don't even know what to talk about :)
12:07:25 <EvanR> the FCC
12:07:31 <ertesx> BTW, if you use firefox, don't complain about GHC…  its closure has 605 packages with a total of 4.4 GiB
12:08:37 <maerwald> yeah, chrome is similarly bad
12:09:00 <maerwald> but given a firefox-like browser would be written in haskell... it would probably be 500GiB xD
12:09:15 <monochrom> bbear: The followings are pretty much universally true regardless of languages: dynamic linking is philosophically nice but can be deployment nightmare; static linking makes deployment easy but you get to complain about sizes; to get both deployment ease and small size you can foresake binaries and go interpreted, but then you get to complain about execution speed.
12:09:42 <monochrom> at any rate GHC can do both dynamic and static, default static. choose your poison.
12:09:43 * EvanR chooses to complain about all of them
12:09:50 <EvanR> no compromise
12:09:55 <hpc> the right way is to just not deploy
12:10:00 <hpc> do everything live on the production server
12:10:08 <EvanR> smalltalk!
12:10:13 <maerwald> monochrom: well, I don't even see the point of dynamic linking in haskell when ABI is constantly broken anyway :o
12:10:15 <EvanR> (or clojure)
12:10:17 * dysfun has a client for whom editing the code live on the server is not a problem
12:10:18 <bbear> hpc: well I don't think it's a good idea precisely
12:10:39 * ertesx tries hard not to mention nix =)
12:10:39 <monochrom> yeah maerwald, there are rare use cases but really rare
12:10:41 <bbear> hpc: that's typically a bad idea I'd say but, hey, why not
12:10:53 <monochrom> ghci itself is one such use case :)
12:11:33 <ertesx> hmm
12:11:42 <ertesx> chromium has a closure of 605 MiB
12:11:43 <dysfun> hot reloading of code
12:12:12 <ertesx> dysfun: you can hot-reload compiled code
12:12:16 <lpaste> bollu pasted “derive-show-gadt” at http://lpaste.net/168970
12:12:29 <bollu1> ^ some help in type-level list length encofing?
12:12:33 <bollu1> encoding*
12:13:05 <EvanR> bollu1: if you swap the args to List then you have a shot at doing stuff like Functor
12:13:16 <dysfun> ertesx: yes, with dynamic linking!
12:13:17 <monochrom> I think "encofing" is a great word. you can use it to mean "both encoding and enforcing"
12:13:25 <EvanR> Possible fix: use a standalone deriving declaration instead
12:13:31 <EvanR> try that
12:13:39 <bollu1> EvanR: don't know what that means >_
12:13:40 <bollu1> >_<
12:13:46 <bollu1> EvanR: heh, I'll try 
12:13:55 * EvanR looks in the manual... actually goes to get coffee
12:13:57 <ertesx> dysfun: yeah…  dynamic dynamic linking…  i'm not sure why that's even called "linking"…  you're loading stuff and then looking up pointers
12:14:06 <monochrom> ghci used to hot-load static code
12:14:36 <dysfun> true, but we have a lot of baggage in our industry
12:15:12 <ertesx> GHCi doesn't really "hot-reload", BTW…  what it can do is to reload modules without stopping running threads or garbage-collecting existing values
12:15:16 <monochrom> I think the loading mutates pointers in-situ too, so it counts as linking during runtime.
12:15:21 <ertesx> see 'foreign-store' and 'rapid'
12:16:15 <ertesx> you can then restart *some* threads or reassign *some* mutable variables
12:16:38 <ertesx> it's an erlang-like experience
12:17:10 * dysfun has been looking at cloud haskell for the other part of erlang. i wonddre if foreign-store and rapid can be made to work with it
12:17:23 <ertesx> but it's mostly only useful for development…  in production you should use a proper plugin system with compiled modules
12:18:08 <ertesx> dysfun: those are orthogonal…  foreign-store is a development tool, and rapid is a convenient wrapper around it
12:18:17 <dysfun> can you give an example of such a plugin system?
12:18:22 <monochrom> I think yes. if you invoke the "foreign-store" part, and it is really really foreign, like a country in another timezone speaking another language altogether, then you get cloud by definition.
12:19:26 <EvanR> dysfun: dynamic loading...
12:19:32 <EvanR> dlopen
12:19:39 <dysfun> yeah, that's what i thought
12:20:37 <dysfun> i vaguely remember watching simon marlow talk about doing some hot reloading stuff on ghc at facebook a few years back
12:21:06 <monochrom> ertesx: I am not entirely sure how to use rapid. Is it true that I no longer use ":reload", I call a rapid function?
12:22:02 <ertesx> monochrom: you do use :reload
12:22:05 <dysfun> pankajmore.in/ping-pong-in-cloud-haskell-part-2.html # looks like someone else wanted erlang-in-haskell too :)
12:22:42 <ertesx> monochrom: the haddocks should explain how to use it…  if not, please tell me which part is unclear, and i will improve it
12:23:02 <monochrom> OK, I just didn't read it carefully.
12:23:21 <ertesx> dysfun: the 'plugins' library might work
12:25:01 <ertesx> monochrom: the development cycle is:  make your changes, :reload, then 'update'
12:25:17 <monochrom> ah
12:25:18 <ertesx> and 'update' defines what is restarted/redone
12:26:18 <monochrom> if ":reload" fails, e.g., my code has a typo, then what does "update" do?
12:26:39 <ertesx> monochrom: probably not in scope, until you fixed it
12:26:45 <bollu1> http://lpaste.net/168971#line34
12:26:50 <ertesx> monochrom: or unchanged
12:27:03 <bollu1> how does GHC know that my "head" function cannot pattern match on an Empty?
12:27:14 <bollu1> this is brilliant and beautiful, but I don't understand how GHC is figuring stuff out
12:27:58 <ertesx> bollu1: 'head' takes an argument of type 'List a (S n)', for some 'a' and 'n'
12:28:04 <bollu1> ertesx: correct
12:28:10 <monochrom> probably because the type says "S n" specifically
12:28:11 <ertesx> bollu1: Empty is of type 'List a Z'
12:28:25 <ertesx> bollu1: it can't be an argument to 'head'
12:28:30 <bollu1> ertesx: ah, so it becomes a type error
12:28:32 <bollu1> neat
12:28:37 <ertesx> yeah
12:28:42 <bollu1> this is an example of something I *need* GADTs to encode, right?
12:29:07 <monochrom> well, I can't say GADT is the only way. but it is successful.
12:29:20 <ertesx> bollu1: i'll say that you should use GADTs to encode this
12:29:33 <bollu1> hmm, I see
12:29:39 <bollu1> can someone give me a GADT exercie?
12:29:43 <bollu1> exercise*
12:30:19 <ertesx> bollu1: use cases for GADTs pop up as you need them…  i wouldn't worry about them too much, except that if you do need them, you'll know you have them
12:30:25 <EvanR> GADTs are pretty crucial to haskell i think, unlike some extensions
12:30:54 <dysfun> they're less crucial than e.g. MultiParamTypeClasses
12:31:00 <bollu1> EvanR: I guess I want to grok them better. Like, I want to fully realise their power
12:31:04 <EvanR> i use GADTs more
12:31:16 <EvanR> but MPTC with flexibleFoo yeah i think thats crucial too
12:31:24 <dysfun> i use GADTs quite sparingly
12:31:26 <fraid> snlj
12:31:28 <fraid> nk
12:31:39 <ertesx> bollu1: let me give you one:  data Something :: * -> * where SomeInt :: Int -> Something Int; SomeString :: String -> Something String
12:31:49 <ertesx> bollu1: f :: Something a -> a
12:31:53 <ertesx> f (SomeInt x) = 2*x
12:31:53 <fraid> hi, is haskell-mode-now or haskell and vim in 2016 "better"
12:31:57 <EvanR> i try not to use type classes too much
12:31:59 <bjs> EvanR: i have a feeling others hav very different notions of "cruical"
12:32:10 <EvanR> and i dont see what type classes and GADTs have to do with each other
12:32:15 <ertesx> f (SomeString str) = "wooooo" <> str <> "!"
12:32:25 <fraid> last one at www.stephendiehl.com
12:32:33 <EvanR> bjs: i know you can encoded a lot of junk into type classes, but it doesnt seem right to me somehow
12:32:34 <dysfun> they don't. i just find it odd that something i don't often used would be considered 'crucial'
12:32:46 <bollu1> ertesx: why'd you specify the kind of Something? can't Haskell figure it out?
12:32:48 <ertesx> bollu1: the magic here is called type refinement…  that's why you can compute with the 'x' in the first clause, and why you can append with (<>) in the second one
12:32:49 <EvanR> dysfun: maybe this is another camp of "second haskell"
12:32:50 <dysfun> whereas MPTC is something I've used several times in the last week
12:32:59 <EvanR> you created new type classes?
12:33:00 <ertesx> bollu1: according to the type signature of 'f' *nothing* is known about the type 'a'
12:33:18 <ertesx> bollu1: i always specify kinds for GADTs…  it's my coding style
12:33:30 <bollu1> ertesx: oh, okay. So it's optional byut good?
12:33:31 <bollu1> but*
12:33:42 <dysfun> EvanR: i create typeclasses all the time
12:33:45 <dysfun> don't you?
12:33:46 <bjs> EvanR: maybe, typeclasses feel a bit more specific whereas GADTs feel like a natural extension of datatypes
12:33:46 <EvanR> meh
12:33:49 <bjs> EvanR: which i guess is the point...
12:33:50 <ertesx> bollu1: just like i write type signatures for all top level definitions, i write kind signatures for all GADTs
12:33:54 <EvanR> dysfun: maybe your framework is making you
12:33:55 <ertesx> bollu1: it's a style choice
12:33:59 <bollu1> ertesx: I see
12:34:04 <dysfun> what framework?
12:34:05 <EvanR> dysfun: no i rarely make type classes
12:34:42 <ertesx> bollu1: most people go with type variables:  data Something a  -- but that doesn't really make much sense to me
12:34:45 <fraid> when i try that one line from haskell-vim-now it says stack path incorrect? how do i uninstall stack and reinstall it
12:35:06 <bollu1> ertesx: right
12:35:10 <bollu1> wait, now I have a question
12:35:15 <ertesx> bollu1: the type variables are actually bound in the individual constructors rather than in the type…  that's basically *the* feature of GADTs
12:35:18 <bollu1> what happens if I mix GADT with dependant tyoes?
12:35:26 <dysfun> EvanR: i just see the type system as a tool to enforce invariants
12:35:33 <ertesx> bollu1: you probably get some error, because haskell doesn't have dependent types =)
12:35:35 <bollu1> something like data Weird a where Make5 :: Weird 5?
12:35:47 <bollu1> ertesx: oh, really? I thought it did
12:36:24 <EvanR> in that case 5 is a type, not a value
12:36:27 <ertesx> bollu1: it's equivalent in expressive power to dependent types, if you turn on enough extensions and tolerate all the reification/reflection
12:36:43 <ertesx> bollu1: but the type 5 is not the same as the value 5
12:37:19 <fraid> is it best to use stack from ubuntu repos or download from git or something
12:37:26 <bollu> I'm instantiating a Weird with a "5"?
12:37:34 <bollu> 5 as a type parameter*
12:37:43 <ertesx> bollu: it's equivalent in expressive power to dependent types, if you turn on enough extensions and tolerate all the reification/reflection, but the type 5 is not the same as the value 5
12:37:57 <EvanR> bollu: the DataKinds extension gives you these type level number literals
12:38:00 <bollu> ertesx: right. I was wondering if it was allowed though
12:38:07 <dysfun> fraid: there are instructions on the stack docs site for ubuntu and other OSses
12:38:38 <bollu> EvanR: is it possible to have something that takes a 5 type and returns the corresponding S(S(S(S(S(Z))))) representation
12:38:45 <bollu> (peano)
12:38:52 <EvanR> thats essentially what 5 is
12:39:06 <EvanR> but theres magic to make it more efficient behind the scenes
12:39:11 <fraid> dysfun: yes but how outdated is the stack package on ubuntu?
12:39:15 <ertesx> bollu: dependent types allow you to pass something to the type as well as the value:  f :: (x :: A) -> Y x  -- the remainder of the type can refer to 'x', and the value of 'f' can also bind the 'x'
12:39:21 <dysfun> fraid: no, fpco maintain a repo
12:39:31 <ertesx> bollu: haskell does not have that
12:39:42 <bollu> ertesx: you lost me. What's f ?
12:39:50 <ertesx> bollu: any function
12:40:03 <EvanR> ertesx: literally, you could make a "thing" to take 5 the type and give S S S S S... data
12:40:07 <bollu> (x :: A) means that?
12:40:13 <fraid> dysfun: hmm, im new to this. how do i use that? what is fpco? and what exactly *is* stack?
12:40:36 <bollu> EvanR: I meant in general, a function that does something like peanoify :: Int -> Nat or something
12:40:38 <ertesx> bollu: imagine a function that takes a boolean and returns a Y (whatever that is):  f :: Bool -> Y
12:40:47 <bollu> ertesx: okay
12:40:56 <EvanR> bollu: well this is tricky enough that you need to be more precise with the type of the thing you want!
12:41:04 <EvanR> Int -> Nat is pretty easy
12:41:06 <ertesx> bollu: you can access the value of the Bool on the value level:  f b = ...
12:41:28 <ertesx> bollu: dependent types would allow you to access it on the type level as well, without conversion, without restriction
12:41:35 <ertesx> and the typical syntax for that is:
12:41:42 <ertesx> f :: (b :: Bool) -> …
12:41:49 <kadoban> fraid: fpco is presumably fpcomplete, a company that's fairly well known and involved in the haskell world. stack is a build program that abstracts away some tedium for you, so you can get to actually writing and using haskell code.
12:42:08 <ertesx> bollu: example: f :: (b :: Bool) -> if b then Y1 else Y2  -- the result type depends on the *value* of the argument
12:42:38 <bollu> ertesx: this is the usual, right?
12:42:40 <maerwald> fraid: haskell-vim-now is more or less just a set of (awkward) shell scripts. You can install the packages yourself and those usually don't force you to use stack. I'd rather check the vimrc myself and pick what I want: https://github.com/begriffs/haskell-vim-now/blob/master/.vimrc
12:42:49 <ertesx> bollu: haskell does not give you that power directly
12:43:00 <ertesx> instead it gives you a load of extensions that you can use to emulate it
12:43:21 <EvanR> bollu: at this point you flip the table and try idris
12:43:38 <ertesx> and then you complain about haskell =)
12:43:38 <bollu> ertesx: oh, I got what you're saying! I pick Y (a _type_) based on the _value_ of the boolean
12:43:40 <bollu> holy smokes
12:43:45 <bollu> that's so cool
12:43:53 <ertesx> bollu: it would be cool =)
12:43:58 <ertesx> but you don't get to do it
12:44:12 <bollu> EvanR: there's so much to learn :( I'm slowly going through software foundations / Coq
12:44:17 <EvanR> bollu: actually when you implement the function, then you will be restricted on how you can implement it, depending on the bool you will only be able to produce a Y1 or a Y2...
12:44:20 <EvanR> it has to match up
12:44:40 <ertesx> yeah…  it's type refinement on steroids
12:44:41 <bollu> EvanR: right
12:44:47 <fraid> maerwald: i've used haskell-vim-now before and found it very good, im just wondering if this guy "haskell and vim in 2016" has some other stuff that haskell-vim-now don't?
12:44:57 <bollu> EvanR: can I have something like f :: (b :: IO Bool) -> Y? ;)
12:45:01 <ertesx> normally a Bool does not refine types, but when dependent types are involved, it can
12:45:11 <EvanR> bollu: well thats not dependent at all
12:45:25 <dysfun> fraid: sorry, fpco is fp complete, stack is a tool for building haskell projects and the site for stack has instructions on how to install and use it
12:45:35 <ertesx> bollu: you can have '(b :: IO Bool) -> Y b', but you probably can't do IO on the type level =)
12:45:40 <bollu> f :: (b :: IO Bool) -> Y b*
12:45:57 <bollu> ertesx: yeah, I was wondering about that :)
12:46:05 <EvanR> remember an IO Bool is some abstract type, you can do anything with it but combine it with other IO
12:46:17 <EvanR> you CANT do anything with it except
12:46:23 <bollu> hmm
12:46:34 <bollu> EvanR: I was hoping you could "read off" the IO Bool
12:46:35 <ertesx> bollu: in principle you can…  i've read about dependent CSV parser libraries that can compute the result type at compile time from a template CSV
12:46:58 <EvanR> bollu: not without an operation like insaneRunIO :: IO a -> a
12:47:01 <dysfun> fraid: http://docs.haskellstack.org/en/stable/install_and_upgrade/#ubuntu
12:47:07 <bollu> EvanR: unsafePerformIO? :P
12:47:16 <EvanR> bollu: neverheard of it
12:47:29 <EvanR> i see no way to implement it ;)
12:47:34 <bollu> ;)
12:47:57 <ertesx> bollu: you should probably just check out idris…  but be prepared for some depression when you return to the practical language haskell =)
12:48:08 <EvanR> to do IO in the type system there are type providers
12:48:15 <fraid> thanks, but it says some file is locked (i have apt-get open somewhere i think) but i can't find it in ps aux
12:48:18 <bollu> ertesx: how's the learning curve? I'm genuinely curious
12:48:24 <ertesx> bollu: steep
12:48:28 <EvanR> idris is easy!
12:48:38 <dysfun> fraid: | grep apt ?
12:48:40 <fraid> how do i use lsof or fuser to see what process locks the file
12:48:43 <ertesx> well, yeah, the *language* is actually pretty easy
12:48:44 <bollu> EvanR: fight with ertesx :)
12:48:48 <EvanR> type driven development with idris, you will feel insulted at the pace
12:48:54 <bollu> my problem is
12:48:56 <EvanR> (thats a book)
12:48:59 <bollu> I don't know what to use Idris for
12:49:06 <bollu> I picked Haskell up to write a compiler for my toy language
12:49:12 <ertesx> bollu: you can use it to target javascript
12:49:13 <fraid> dysfun: i doesn't find anything
12:49:18 <bollu> ertesx: nice!
12:49:22 <EvanR> its a general purpose language, you do whatever with it
12:49:24 <bollu> ertesx: does it have webGL support?
12:49:31 <dysfun> fraid: idoes it complain about the existence of a lockfile, or that a file is locked?
12:49:34 <bollu> EvanR: sure, but, well, libraries and tooling matter
12:49:41 <ertesx> bollu: it has an FFI, so yes =)
12:49:44 <EvanR> yep, youll have to write those yourself ;)
12:49:45 <bollu> EvanR: you can say the same about any turing complete language, but.. you know :P
12:49:49 <fraid> dysfun: yes /var/lib/dpkg/lock
12:50:12 <bollu> wait, idris has a theorem prover in it?
12:50:18 <bollu> neat
12:50:25 <bollu> does it have tactics?
12:50:39 <EvanR> bollu: much the same as haskell, whatever mind blowing things you learn there can be translated back to your 9 to 5 job with a blue shirt, black tie, cubicle, and Java.... hmm
12:50:43 <maerwald> idris has like ~35 libraries
12:50:51 <ertesx> bollu: any dependently typed language is at the same time a theorem prover, usually with some caveats, unless the language designers were careful to make a theorem prover rather than a programming language (example: agda)
12:51:07 <maerwald> and I bet half of them don't compile anymore
12:51:08 <bollu> ertesx: elaborate on that please
12:51:31 <ertesx> bollu: type-checking in a dependently typed language is equivalent to proof checking in type theory
12:51:41 <EvanR> bollu: they are trying to get rid of the tactics thing and instead youre encouraged to use the text editor to interactively create normal code to prove stuff. at the same time they are exposing the elaboration monad for users purposes
12:51:46 <dysfun> fraid: lsof | grep dpkg would be a good start
12:52:16 <bollu> ertesx: wow, TIL o_O
12:52:32 <dysfun> bollu: dependent types are awesome :)
12:52:36 <bollu> ertesx: so, wait, what does having inductive logic imply for types?
12:52:44 <bollu> I'm not sure if the question is even well formed
12:52:56 <EvanR> logic implies _
12:53:11 <maerwald> dependent types are so powerful I'm not even sure I want them and be exposed to all sorts of crazy ideas people can come up with in their libraries
12:53:14 <fraid> dysfun: gnome-sof gmain gdbus dconf\x20 pops up
12:53:20 <fraid> 4 lines
12:53:20 <ertesx> bollu: type theory is a logical calculus that also happens to have a computing semantics
12:53:29 <bollu> the question is something along the lines of "since we use inductive in Coq, and proving stuff <—> types in dependant types, what is the translation in terms of dependant types?"
12:53:32 <fraid> ill just restart
12:53:34 <EvanR> maerwald: we need to be protected from ourselves!
12:53:38 <maerwald> yes
12:53:40 <dysfun> fraid: that won't remove the lockfile ;)
12:53:43 <bollu> ertesx: other way round right?
12:53:53 <fraid> dysfun: hmmmm
12:53:58 <dysfun> fraid: anyway, it's clear that no process is actually using the package database, so just remove the lockfile
12:54:04 <fraid> wtf has happend then. i used aptitude like 2 seconds before
12:54:11 <dysfun> did it die?
12:54:22 <fraid> normally yes
12:54:24 <monochrom> crazy things at the type level doesn't sound like protecting oneself
12:54:24 <ertesx> bollu: i don't understand the question
12:54:24 <dysfun> did you accidentally close the terminal while something was running?
12:54:25 <fraid> no errrors
12:54:34 <fraid> dysfun: yeah maybe thats it
12:54:38 <EvanR> bollu: idris lets you use inductive and coinductive types, and in either case youre not strictly required to ensure that you use them in a total way
12:54:46 <fraid> how do i solve that
12:54:46 <bollu> ertesx: wasn't it conceived as a model for computation initially?
12:54:54 <EvanR> the totality checker exists but isnt that smart
12:55:07 <bollu> EvanR: can type checking Idris lead to nontermination?
12:55:11 <EvanR> no
12:55:21 <EvanR> unless it has a bug
12:55:24 <ertesx> bollu: as said, type theory is a logical calculus, but proofs can be interpreted as computations, giving rise to a programming language with a type system that has the full power of a logical calculus
12:55:47 <fraid> cat lock says 1,, what do that mean
12:55:49 <ertesx> bollu: not sure about the history, but i can imagine that computation was an aspect
12:55:59 <bollu> I see
12:56:08 <dysfun> fraid: it's just a lockfile. the existence of the file is a signal that a lock has been taken
12:56:14 <dysfun> just rm it
12:56:28 <dysfun> the idea is that when you're done you remove the file
12:56:39 <dysfun> but in this case, that didn't happen so you have to step in and clean up 
12:56:53 <fraid> dysfun: i have, and the same error. actually it says i have no permmisions 
12:56:57 <dysfun> sudo
12:57:08 <fraid> but i do sudo aptitude install stack -y
12:57:39 <dysfun> did you sudo rm'ing the lock?
12:57:53 * hackagebot text-icu-normalized 0.1.4.1 - Dealing with Strict Text in NFC normalization.  https://hackage.haskell.org/package/text-icu-normalized-0.1.4.1 (misandrist)
12:58:05 <EvanR> maerwald: i can imagine having this same worry about haskell while only being comfortable with java
12:58:08 <fraid> dysfun: yes
12:58:17 <fraid> and the file is gone
12:58:19 <maerwald> EvanR: I can't imagine that.
12:58:23 <EvanR> its too powerful, i dont want people making things i cant understand
12:58:24 <dysfun> okay. can you pastebin the error?
12:58:45 <EvanR> PHP is different, people only make things that no one can understand
12:58:56 <dysfun> EvanR: nothing says "fuck off" like 30 lines of {-# LANGUAGE ... at the top of a file
12:59:02 <EvanR> but with haskell you have the ability to learn awesome new things
12:59:17 <ertesx> bollu: the basic idea is that you can have first class proofs:  proofs are values that you can pass or use to compute more proofs…  that together with type refinement allows you to reason about programs using arbitrary logical statements
12:59:29 <ertesx> bollu: this is not true for haskell
12:59:33 <EvanR> dysfun: pretty much...
12:59:47 <maerwald> EvanR: I think you got that wrong. I just think that dependent types don't improve understandability, but just improve the stuff you can express. And people will use it in a lot of weird ways.
12:59:48 <mniip> do people usually split {-# LANGUAGE #-} into multiple lines?
12:59:55 <maerwald> it's not about "oh, I can't understand it"
13:00:05 <ertesx> mniip: i write multiple LANGUAGE statements
13:00:06 <dysfun> mniip: i wrap them at 80 chars
13:00:15 <ertesx> one per line
13:00:16 <monochrom> I use one single line with 30 items.
13:00:22 <fraid> dysfun: strange. i think it works now
13:00:28 <dysfun> fraid: ace :)
13:00:42 <mniip> I use one single line with all 106 flags
13:00:54 <dysfun> (when it mysteriously works, don't ask why, just roll with it :) )
13:01:13 <ertesx> bollu1: the basic idea is that you can have first class proofs:  proofs are values that you can pass or use to compute more proofs…  that together with type refinement allows you to reason about programs using arbitrary logical statements…  this is not true for haskell
13:01:21 <monochrom> {-# PANDORA-BOX  ... 108 items here ... #-}
13:01:26 <EvanR> maerwald: weird ways, and cool ways. i feel uneasy taking what i know so far and calcifying it into "the only thing that i know will work" and stopping there
13:01:42 <maerwald> EvanR: I don't like cool code.
13:01:52 <EvanR> the good kind of cool
13:02:03 <ertesx> {-# LANGUAGE AlmostIdris #-}  -- i'd like that extension
13:02:11 <EvanR> "this code makes sense if youre familiar with the the idea of a vector space"
13:02:23 <EvanR> i dont know vector space, so its "too cool" and sucks
13:02:34 <maerwald> again, that's not what I meant
13:02:56 <EvanR> well then stop intentionally misunderstanding words like cool
13:02:56 <bollu1> ertesx: I see
13:02:56 <mniip> monochrom, what's the 107th and 108th?
13:03:08 <monochrom> I don't know
13:03:11 <bollu1> EvanR: where did you read that? "this code makes sense if youre familiar with the the idea of a vector space"
13:03:20 <EvanR> i didnt read it, i wrote it
13:03:34 <bollu1> EvanR: diagrams?
13:03:47 <EvanR> a lot of stuff makes sense once everyone is on board with linear algebra
13:03:58 <EvanR> this is not the same as "clever code"
13:04:12 <bollu1> hm, the idris interp does not have :k
13:04:12 <maerwald> I understand C pointers, yet I don't want people to use them.
13:04:14 <EvanR> i think dependent types has a lot of this to offer, at some point
13:04:24 <ertesx> bollu1: in a dependent language, :k and :t are the same thing
13:04:26 <fraid> right, so after i've installed stack, should i use haskell-vim-now or haskell and vim in 2016? :) is it a matter of taste or is one noticably better?
13:04:28 <maerwald> because I _know_ what they can be misused for
13:04:30 <bollu1> ertesx: I see
13:04:43 <fraid> and Vundle or pathogen?
13:04:46 <bollu1> what the hell is a "Type"
13:04:55 <bollu1> fraid: vim-plug
13:05:01 <mniip> type Type = TYPE LiftedPtrRep
13:05:02 <maerwald> and I also know that a lot of people find f'ed up pointer arithmetic "cool code"
13:05:05 <fraid> bollu1: what is that
13:05:06 <bollu1> like, in idris, is a Type a placeholder for "all types"?
13:05:07 <ertesx> bollu1: Type is the type of types
13:05:24 <bollu1> fraid: better Vundle (IMO): https://github.com/junegunn/vim-plug
13:05:31 <ertesx> bollu1: Integer :: Type  -- Integer is a type, Integer is of type Type
13:05:35 <bollu1> ertesx: soo Type is the "universe of types"?
13:05:41 <ertesx> yeah
13:05:46 <bollu1> so it's *?
13:05:48 <EvanR> maerwald: more education on what im talking would specifically illuminate how uncool pointer arithmetic is!
13:05:58 <ertesx> bollu1: yeah…  basically
13:06:16 <bollu1> maerwald: c'mon, the whole x[3] == 3[x] _is_ pretty cool the first time you see it
13:06:23 <EvanR> there is no symmetry, no beauty in it
13:06:26 <maerwald> bollu1: ...
13:06:26 <bollu1> ertesx: I see :)
13:06:32 <ertesx> bollu1: but it's not a kind…  it's a type, and yes, it itself has a type =)
13:06:34 <bollu1> maerwald: :P
13:06:44 <monochrom> x[3] == 3[x] is clearly beautiful and symmetric :)
13:06:54 <maerwald> EvanR: I cannot parse your sentence
13:06:56 <bollu1> *hello> :t Type | Type : Type 1
13:06:56 <EvanR> lexically!
13:07:01 <mniip> monochrom, no it isn't
13:07:12 <monochrom> int is a monoid that acts on pointers
13:07:17 <bollu1> ertesx: "Type 1" is the type of Type?
13:07:17 <EvanR> concrete syntax being an image of something else 
13:07:23 <ertesx> bollu1: yeah
13:07:31 <bollu1> does "Type 1" have a type?
13:07:32 <mniip> only because the + operator is defined for both T * -> size_t -> T *, and size_t -> T * -> T *
13:07:32 <mniip> cases
13:07:38 <bollu1> (do types have types?)
13:08:01 <EvanR> yeah C virtual machine doesnt really have these nice things, it may but in your head though
13:08:04 <bollu1> *hello> :t Bool
13:08:05 <bollu1> Bool : Type
13:08:05 <bollu1> *hello> :t Type
13:08:05 <bollu1> Type : Type 1
13:08:05 <bollu1> *hello> :t True
13:08:05 <bollu1> True : Bool
13:08:06 <bollu1> *hello> :t Bool
13:08:06 <bollu1> Bool : Type
13:08:07 <bollu1> *hello> :t Type
13:08:07 <bollu1> Type : Type 1
13:08:08 <bollu1> *hello> :t (Type 1)
13:08:08 <bollu1> builtin:Type mismatch between
13:08:09 <bollu1>         Type (Type of Type)
13:08:09 <bollu1> and
13:08:10 <bollu1>         _ -> _ (Is Type applied to too many arguments?)
13:08:10 <bollu1> ouch, sorry for the copy paste
13:08:11 <EvanR> WTF
13:08:19 <bollu1> thought I'd line broken it
13:08:36 <bollu1> so, Bool has type Type. Type has type Type 1. Type 1 has type..?
13:08:37 <EvanR> the type of Type 1 is Type 2
13:08:44 <bollu1> how do I ask idris that
13:08:44 <EvanR> but you cant type it in, in idris
13:08:45 <bollu1> ?
13:08:47 <bollu1> ahh
13:08:50 <bollu1> why not?
13:08:58 <mniip> does idris have an infinite hierarchy of kinds?
13:09:03 <bollu1> ^
13:09:05 <maerwald> bollu1: when I look at the C code I wrote 3 years ago or so, I want to commit seppuku, because there's no way I could ever understand it again. Dependent types is such a powerful idea that it lets you express very complicated patterns, that ...later, might be hard to understand again. No matter if you are familiar with the concept or not.
13:09:17 <ertesx> bollu1: welcome to universes, or: how to avoid the barber of seville
13:09:17 <EvanR> mniip: yes... supposedly
13:09:31 <bollu1> so how do I ask the idris interpreter what the type of Type 1 is?
13:09:38 <EvanR> you cant
13:09:45 <bollu1> ertesx: soo, "THERE IS NO UNIVERSE OF DISCOURSE!" just in types?
13:09:46 <EvanR> that output might even be just a hack
13:09:50 <bollu1> EvanR: is that a syntax limitation?
13:09:56 <maerwald> bollu1: EvanR just misread that as "I'm not familiar with the concept so I don't want it" ;)
13:10:17 <EvanR> maerwald: more like i dont know enough to know if this is complete bullshit or actually awesome
13:10:27 <mniip> well if idris is a dependent language
13:10:31 <EvanR> if you do know enough, then you dont have a problem
13:10:35 <mniip> surely you can write typeOf :: (a :: k) -> k
13:11:00 <mniip> and ask :t typeOf (typeOf (typeOf Type))
13:11:13 * EvanR tries
13:11:14 <maerwald> EvanR: well, you're not really arguing about the topic, so I will stop
13:11:22 <bollu1> what's idris' :info?
13:11:32 * mniip <- never written a single line of idris
13:13:20 <bollu1> oh my god, dependant types are _insane_
13:13:28 <bollu1> I'm reading the Idris tutorial and I'm awestruck
13:13:48 <EvanR> they dont have the best materials... i think
13:13:52 <mniip> does idris not support GHC 8 ?
13:13:55 <maerwald> bollu1: also check https://www.youtube.com/watch?v=fVBck2Zngjo which is pretty awesome
13:13:55 <EvanR> except this book is OK so far
13:13:57 <bernalex> I wouldn't call dependent types insane. it's all rather elegant and useful, I think.
13:14:11 <EvanR> mniip: they are having issues aiui
13:14:14 <bollu1> bernalex: "insane" in the vein of "insanely cool"
13:14:43 <maerwald> bollu1: it's just that expressivity always comes with a price
13:15:12 <ertesx> i think we have a new idris developer
13:15:14 <bollu1> maerwald: I think I've seen someone encode something similar in Haskell?
13:15:18 <EvanR> mniip: indeed when i try your trick, i just get the answer Type for everything
13:15:19 <bollu1> maerwald: what are the drawbacks?
13:15:27 <bollu1> ertesx: whom?
13:15:32 <maerwald> bollu1: what I just said the last 10 minutes
13:15:36 <EvanR> mniip: it is said that the universes are handled for you magically behind the scenes ...
13:15:50 <bernalex> bollu1: here's a drawback
13:15:53 <bollu1> maerwald: ah, complexity?
13:15:54 <ertesx> bollu1: you may be interested in this:  http://lpaste.net/109388
13:15:54 <bernalex> :t (.)
13:15:56 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:15:59 <bernalex> vs. {A : Set}{B : A -> Set}{C : (x : a) -> B x -> Set} (f : {x : A}(y : B x) -> C x y)(g : (x : A) -> B x) (x : A) -> C x (g x)
13:16:14 <EvanR> thats now what (.) lokos like in idris though
13:16:17 <EvanR> looks*
13:16:19 <bollu1> ouch
13:16:20 <maerwald> bollu1: I consider perl an expressive language, in a way. It's cool when you write it, but it's awful when you read it.
13:16:39 <maerwald> and what bernalex just said, lol
13:17:00 <EvanR> (.) : (b -> c) -> (a -> b) -> a -> c -- idris, only its colorful in the repl ;)
13:17:03 <bollu1> ertesx: were you referring to me, as someone who's onboard and will learn Idris? :)
13:17:10 <bollu1> EvanR: yeah I just checked that
13:17:16 <ertesx> bollu1: i won't answer that =)
13:17:24 <bollu1> ertesx: :)
13:17:27 <bernalex> EvanR: the (.) I posted was from agda.
13:17:38 <bollu1> ertesx: I'd love to study this fully, buut I'm a college student
13:17:41 <bernalex> bollu1: check out agda too. beautiful language.
13:17:42 <EvanR> yeah... edwin i think really tried to avoid anything too complex in the standard lib
13:17:42 <bollu1> responsibilities :/
13:17:56 <bollu1> bernalex: I've tried before, but the tooling has put me off
13:17:57 <ertesx> bollu1: the paste contains an example of how to encode something fully dependent in haskell
13:18:05 <mniip> mueval needs GHC 8 support
13:18:13 <bernalex> bollu1: lol. as a college student you have all the time in the world for learning idris compared to what you will have when you get a job.
13:18:24 <EvanR> heh
13:18:37 <mniip> then we can have dependent kinds in lambdabot
13:18:50 <bollu1> bernalex: good point I guess :P
13:18:55 <EvanR> yeah even with 30 hours of courses i had so much free time
13:18:58 <bollu1> bernalex: right now I'm a research intern
13:18:59 <bernalex> bollu1: you don't need cool tooling to appreciate the beauty of Agda. a PDF reader or some printed papers will do.
13:19:10 <bollu1> bernalex: really? I mean, how so?
13:19:30 <bernalex> EvanR: 30h? standard when I went to school was 45h of weekly work. I still had more time than I ever did when I had a 'real job'.
13:19:31 <ertesx> being an agda user pretty much means being an emacs user
13:19:37 <bollu1> bernalex: I've always learnt a language by having the compiler yell at me
13:19:49 <EvanR> bernalex: yeah 12 was the min for full time
13:20:02 <bollu1> ertesx: I was forced to use emacs by a  prof during one summer :P so, some good out of that?
13:20:08 <EvanR> this is the south, *sips a mint julip*
13:20:22 <ertesx> bollu1: i like agda, and i like emacs, so it's a natural fit =)
13:20:27 <bernalex> bollu1: it's enlightening to just see what's possible with agda.
13:20:31 <ertesx> but agda is not as beautiful as one might think
13:20:37 <bollu1> ertesx: but, but, my vim keybindings ;)
13:20:44 <bollu1> bernalex: links to a PDF you think I should print?
13:20:56 <ertesx> the think that annoys me most about agda is the way universes are handled…  idris does it much better
13:21:06 <EvanR> bernalex: 45H per week of sitting in a room?
13:21:10 <bernalex> bollu1: to be fair, the agda tooling is pretty cool too. having the compiler construct proofs for you is nice.
13:21:20 <EvanR> that would make it worse than a job ;)
13:21:25 <bernalex> bollu1: sorry, I'm kind of only half-way here. have IRC open on a laptop that I glance at every now and again.
13:21:30 <ertesx> s/think/thing/
13:21:32 <bollu1> bernalex: np :)
13:21:42 <EvanR> because you dont have homework in a job
13:21:57 <bernalex> ertesx: no. you were expected to do 45h of weekly work in total.
13:22:10 <EvanR> ah not sure how to compare
13:22:19 <bernalex> ertesx: sorry that was for EvanR obviously
13:22:29 <ertesx> ah, i was wondering
13:22:38 <bernalex> EvanR: 1 point = 1.5h work -- 30p semesters were minimum. I usually did 40h semesters.
13:23:05 <EvanR> hours was literally how much time you spend in a lecture or a lab
13:23:27 <bollu1> I haven't seen idiom brackets before
13:23:43 <bollu1> I like how I can skim over a bunch of idris thanks to haskell
13:23:53 <EvanR> its so easy (TM)
13:24:26 <hpc> i hope the same nutter that wrote the gentle introduction to haskell writes a gentle introduction to idris
13:24:30 <hpc> step 1, learn haskell
13:24:30 <bollu1> anyway, 'night peeps :) I'll come back with idris/GADT doubts. Adios!
13:24:39 <hpc> step 2, read these research papers
13:25:12 <EvanR> that would actually be awesome, because #idris has no idea what papers are required, i guess they all read so many they forgot
13:25:29 <fraid> what is travic ci?
13:25:30 <hpc> it sure wouldn't be gentle though
13:25:33 <hpc> @quote gentle
13:25:33 <lambdabot> PenguinOfDoom says: Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
13:25:39 <hpc> @quote gentle.intro
13:25:39 <lambdabot> kmc says: i started to read the "tutorial" and it was incomprehensible. makes the Gentle Introduction to Haskell look like Teach Yourself PHP in 24 Hours
13:25:58 <hpc> hah
13:26:19 <bollu1> how does @quote work? :)
13:26:22 <bollu1> @quote haskell
13:26:22 <lambdabot> haskell says: BONUS> as you can see, one of the best parts of Haskell is #haskell
13:26:27 <bollu1> @quote lens
13:26:27 <lambdabot> bernalex says: I used to have a problem then I used lens now I have an abstraction problem?
13:26:29 <hpc> fraid: CI is continuous integration - it automatically monitors your repo for changes and performs a controlled build/test with a bunch of backend stuff to track it
13:26:35 <hpc> fraid: travis is a commonly used CI tool
13:26:35 <bollu1> @quote php
13:26:35 <lambdabot> tdammers says: Paypal is the PHP of payment providers
13:26:39 <bernalex> hpc: all functional programming tutorials should just start with crap like "read the art of computer programming, practical foundations of programming languages, types and programming languages, and the implementation of functional programming languages"
13:26:44 <bollu1> @quote clang
13:26:44 <lambdabot> No quotes match. Just try something else.
13:26:45 <EvanR> stahhhp
13:26:49 <bollu1> sorry :P
13:26:54 <bollu1> I wanted to see fun quotes
13:26:56 <bollu1> is there a DB?
13:26:57 <ertesx> bollu1: /query lambdabot 
13:27:26 <EvanR> IRC interface to the database ;)
13:27:29 <hpc> usually you query lambdabot first, i didn't expect there to be "gentle" quotes that weren't related to that tutorial
13:27:40 <ertesx> if books were a lot thinner and a lot cheaper, i actually wouldn't mind a dependency system for them
13:27:52 <bernalex> ertesx: they are. it's called the Internet.
13:28:09 <bernalex> ertesx: except that instead of hyperlinked scientific articles, we got cat GIFs and pornography.
13:28:24 <bollu1> "shapr says: Haskell separates Church and state" oh my god that is brilliant
13:28:27 <bernalex> ertesx: whilst the scientific articles remain behind paywalls -- just less physical ones.
13:28:45 <maerwald> bernalex: well, at least something is free...
13:29:30 <EvanR> yeah 1984 got at least the exclusivity of porn completely wrong
13:29:33 <bernalex> maerwald: hey, I remained impartial on whether it was for good or bad.
13:30:33 <maerwald> EvanR: yeah, glad we sorted that out :D
13:33:11 <ertesx> bernalex: well, the general public got its hands on the internet at some point
13:34:18 <ertesx> you know, haskell is kind of a singularity…  it's a popular language these days, yet we somehow managed to get the AMP through
13:34:24 <bernalex> ertesx: the free hyperlinked scientific journals weren't there previously either. at least, as maerwald pointed out, the general public didn't put all of their pornography and cat GIFs behind paywalls. so general public > academics, as far as I'm concerned.
13:35:47 * maerwald tries to imagine it would be the other way around
13:38:33 <ertesx> well, how are academics supposed to get money?
13:38:55 <maerwald> ertesx: they should be paid for just being academics
13:39:07 <maerwald> not their papers
13:39:15 <ertesx> maerwald: do you pay them?
13:39:26 <ertesx> i don't
13:39:30 <maerwald> there's no system that provides this
13:39:34 <maerwald> but there could
13:39:44 <bernalex> #-offtopic, guys :)
13:39:45 <ertesx> there could, but nobody is really interested in it, so it won't happen
13:40:47 <maks> ertesx: i think you are somewhat misinformed on the paywall issue
13:40:50 <babelchips> Hi - looking for some advice on sorting a Vector.Unboxed Vec3 by their magnitutde.  Do I need to create a seperate Vector of mags and use it as a sorting source?  Any ideas?
13:41:14 <maks> ertesx: academics don't get paid by the journal, in fact there has been a movement to create journals without paywalls (i.e open access)
13:44:31 <ertesx> maks: my point is this:  in many ways academics/researchers are like open source programmers: you don't get paid merely for being one…  usually there is a good reason why people pay you: either you are known for doing interesting/useful stuff, or you solve a specific problem
13:46:06 <ertesx> babelchips: what is Vec3?
13:46:45 <babelchips> From the Linear library
13:46:55 <ertesx> babelchips: if you use vector-algorithms, you don't need a separate vector of magnitudes, but you do need a pure function to compute the sort order
13:47:18 <maks> ertesx: agreed!
13:48:32 <ertesx> babelchips: ah, V3…  use sortBy (comparing norm)
13:48:45 <ertesx> babelchips: from vector-algorithms
13:49:33 <babelchips> Ah ok.  That is for Unboxed.Mutable right?
13:50:24 <ertesx> babelchips: yeah, you can use 'modify' to apply it to immutable ones
13:50:39 <ertesx> babelchips: and i recommend .Algorithms.Intro for most use cases
13:51:19 <ertesx> babelchips: Vu.modify (Vai.sortBy (comparing norm))
13:52:09 <babelchips> Ok.  So is there an overhead for working with immutable then using modify?
13:54:08 <ertesx> you'll likely create a sorted copy, so yeah
13:55:33 <ertesx> in simple cases i would hope that fusion gets rid of the initial vector, but if performance is critical, you should create the initial vector as an immutable one
13:56:18 <ertesx> Vu.create (do xsVec <- genInitialVector; Vai.sortBy (comparing norm) xsVec; pure xsVec)
13:57:01 <ertesx> s/immutable/mutable/
13:57:12 <babelchips> So when I use V.zipWith (on an unboxed) I guess it produces a new Vector each time?  So should I use a Mutable version for zipWith for example?
13:57:39 <ertesx> the usual vector functions should fuse nicely
14:01:43 <babelchips> I assumed the Vu.modify converts an unboxed to unboxed mutable?
14:03:35 <EvanR> modify looks complicated, but is supposed to be safe and easy
14:03:51 <ertesx> babelchips: semantically it creates a mutable copy that you can modify, then freezes it
14:04:16 <ertesx> babelchips: so semantically it copies the unsorted vector, then sortBy acts on it
14:05:52 <babelchips> ok - so can I think of Data.Vector.Storable.convert on a Data.Vector.Unboxed in the same light?  (i.e. it doesn’t produce copies?)
14:06:24 <ertesx> babelchips: most of the time 'modify' does actually copy =)
14:06:45 <ertesx> and 'convert' will also copy most of the time, if not always
14:07:34 <babelchips> Oh.  Is there something I can do about that?
14:08:00 <ertesx> yes, start from a mutable vector and go to immutable after sorting
14:08:05 <ertesx> i.e. use 'create' instead of 'modify'
14:09:15 <ertesx> but if you do a lot of stuff before sorting, i wouldn't bother…  the cost of copying may be small compared to the cost of having to rewrite all of that for mutable vectors
14:11:03 <ertesx> to avoid converting, just don't convert…  usually storable vectors are just as fast and compact as unboxed vectors, so if you need it, there is no reason to convert to unboxed
14:11:59 <babelchips> I am processing hundreds of thousands of Vec3 every frame, then I need to get an unsafe ptr to copy to the GPU
14:12:24 <babelchips> As far as I can see I need to use convert.  Unless there’s another way?
14:12:26 <ertesx> yeah, i assumed something like that…  is this about a GL buffer?
14:12:32 <babelchips> Yep
14:12:46 <ertesx> don't use unboxed vectors, just work with Storable vectors
14:13:10 <ertesx> wait, let me check something
14:13:31 <ertesx> yeah, V3 is storable
14:15:15 <babelchips> OK cheers.  So the extra features of storable won’t be a hindrance over Unboxed
14:15:16 <babelchips> ?
14:15:32 <ertesx> with OpenGL and performance in mind, i suggest using a single mutable storable vector together with glMapBufferRange <https://www.opengl.org/sdk/docs/man4/html/glMapBufferRange.xhtml>
14:16:02 <ertesx> babelchips: the difference between unboxed and storable is that storable vectors don't move in memory
14:17:04 <babelchips> That sounds ideal.  Why am I using unboxed eh? ;)
14:17:26 <ertesx> because you've been told that unboxed vectors are the speedy ones =)
14:17:42 <babelchips> FYI I am using glMapBuffer and copyBytes to get the data onto the GPU
14:18:51 <ertesx> babelchips: if you use glMapBufferRange, you can tell it to persist the buffer mapping, even across renders
14:18:59 <ertesx> babelchips: https://www.opengl.org/sdk/docs/man4/html/glMapBufferRange.xhtml
14:19:44 <babelchips> I’m updating every frame, the full VBO
14:20:19 <ertesx> babelchips: that doesn't matter =)
14:20:45 <ertesx> glMapBufferRange accepts a lot more access flags than glMapBuffer
14:25:19 <ertesx> babelchips: the idea is this: you generate a buffer and get a pointer to it via glMapBufferRange with the GL_MAP_PERSISTENT_BIT flag
14:25:40 <ertesx> then you convert that to a mutable vector using Vsm.unsafeFromForeignPtr0
14:26:00 <babelchips> And only do it once!  Nice.
14:26:08 <ertesx> then your loop looks like this:  modify, flush, render, modify, flush, render
14:26:09 <ertesx> yeah
14:26:16 <babelchips> I see now.  Thanks for that! :)
14:26:32 <ertesx> you need OpenGL 4 for that, but you probably need it anyway =)
14:28:02 <ertesx> i should note one thing about this approach: you likely freeze the GPU memory address this way, so if you do this with a bunch of large buffers, per-frame mapping may be a bit faster
14:28:35 <koz_> ertesx: Thank you for your parallelism help yesterday - it works *much* better now.
14:28:37 * EvanR hugs GLES2
14:28:51 <ertesx> koz_: my pleasure =)
14:29:40 <babelchips> I’m on a Macbook Pro 2013 so i’m not sure what GL ver I can go to
14:30:09 <hpc> you can probably do 4
14:30:20 <hpc> opengl 4.5 was 2014
14:30:20 <koz_> babelchips: What's the model number? Look it up online and see what CPU/GPU you have.
14:30:27 <hpc> 4.0 was 2010
14:30:34 <ertesx> babelchips: 4 should be fine
14:30:43 <hpc> "Hardware support: Nvidia GeForce 400 Series and newer, ATI Radeon HD 5000 Series and newer, Intel HD Graphics in Intel Ivy Bridge processors and newer"
14:30:50 <ertesx> babelchips: if you have users complaining, you can add fallback code
14:31:13 <babelchips> As long as 4 works for me now I’m happy
14:31:27 <babelchips> Is it 4.1 that Mac’s don’t support?
14:32:24 <babelchips> Or 4.5?  Either way they’re behind and prob won’t get there now Metal is a thing.
14:32:38 <ertesx> babelchips: do you have glxinfo?  it tells you
14:33:44 <ertesx> look for "core profile version" and "core profile shading language version"
14:35:34 <babelchips> OpenGL version string: 2.1 NVIDIA-10.10.5.2 310.42.25f01
14:35:34 <babelchips> OpenGL shading language version string: 1.20
14:35:57 <ertesx> ouch
14:36:31 <hpc> that's... ancient
14:36:38 <ertesx> no glMapBufferRange for you then
14:36:44 <hpc> 2.1 was 2006
14:36:55 <babelchips> It’s a 2012 Macbook Pro so....
14:37:32 <ertesx> babelchips: but the approach does not change much with glMapBuffer…  you just do it in every frame
14:37:50 <babelchips> I think i’m ok - 4.1 according to this: https://support.apple.com/en-gb/HT202823
14:37:56 <hpc> still, that's two years after 4.0
14:38:42 <koz_> ertesx: Should I be concerned if my parallel GC work balance is low?
14:38:48 <koz_> (like, ~30%)
14:39:13 <babelchips> Ok - yes if glMapBufferRange doesn’t work I’ll stick with what i’ve got
14:39:19 <EvanR> babelchips: this is why i stick to "solid" gl apis...
14:39:35 <EvanR> i have having to make users go out and buy a new video card
14:39:42 <EvanR> hate*
14:39:48 <EvanR> or a new laptop
14:39:50 <koz_> EvanR: You won't fit too well into the mainstream game industry then. :P
14:40:00 <EvanR> no shit
14:40:10 <hpc> it's getting better
14:40:15 <ertesx> koz_: the measure for parallel performance is: take multi-thread time, divide by number of cores, compare to single-thread time
14:40:15 <hpc> mostly due to hardware stagnation, but still
14:40:23 <ertesx> koz_: if that's far off, then you have a problem
14:40:49 <koz_> ertesx: Is the multi-thread time you refer to 'total time' or 'total elapsed time'?
14:40:49 <ertesx> koz_: if your parallelisation works perfectly, the two numbers will be almost equal
14:41:18 <ertesx> koz_: whoops…  take total elapsed time and *multiply* by number of cores
14:41:36 <koz_> So that means that under -N4, I should be multiplying by 4?
14:41:39 <ertesx> then compare to CPU time on a single-thread run
14:41:45 <ertesx> yeah
14:42:13 <ertesx> note that stuff like hyperthreading can make a difference, so it's not necessarily your fault, if you get less than ideal improvement
14:42:41 <koz_> ertesx: OK, I'll just rig up a single-thread test.
14:43:17 <ertesx> koz_: you may want to write single-threaded code just to see how much the abstraction itself costs
14:43:36 <ertesx> parBuffer should be cheap enough though
14:44:13 <koz_> ertesx: Checking this right now.
14:45:41 <ertesx> if single-threaded code runs in 2s and is fully parallelisable, and with -N4 you get 0.7s:  4*0.7s = 2.8s  -- computed for 0.8s longer than the single-thread version did
14:47:01 <koz_> Well, I'm about to see how good/bad this overhead is.
14:48:02 <hpc> that's 0.8 cpu-seconds
14:48:42 <hpc> for wallclock seconds, you'd divide 2s by 4 and get 0.2s wallclock time estimated slowdown
14:48:57 <hpc> it could be that you have cores wasting work, in which case you're actually losing 0.8 cpu-seconds
14:49:20 <hpc> or it could be there's still some part of your code that doesn't parallelize, in which case some of that 0.8 is going to be spent on other processes
14:49:55 <hpc> (just to disambiguate the time units a bit there)
14:50:22 <koz_> hpc: Thanks for that!
14:50:28 <ertesx> and yes, GC may be a factor
14:50:39 <ertesx> but that's rather rare – at least for me
14:51:01 * koz_ wishes he had an 8-core machine to test this on.
14:51:11 <TheUnrequited> who is op here?
14:51:12 <koz_> I only have 2-no-hyper or 2-hyper.
14:51:34 <Cale> TheUnrequited: why? Is there a problem?
14:51:42 <EvanR> who is over powered here
14:51:46 <TheUnrequited> have a question can i pm you?
14:52:00 <Cale> You may
14:52:51 <hpc> TheUnrequited: ops don't go full-on @ on freenode until there's something to do, if you aren't familiar with that policy
14:52:57 <koz_> Uhhh, ertesx: My parallel total elapsed * core count = 1740.464; serial total elapsed is like, 488.992...
14:53:09 <hpc> the theory is that staying opped all the time is putting a big red authority sticker on everything they say
14:53:16 <hpc> which is bad for general channel health
14:53:28 <ertesx> koz_: that sounds rather terrible =)
14:53:34 <koz_> ertesx: Hence my confusion.
14:54:10 <koz_> ertesx: If I paste my main (which is where I parallelize), would that perhaps shed some light on this?
14:54:25 <ertesx> koz_: you are using (map f xs `using` parBuffer n rdeepseq)?
14:55:06 <koz_> ertesx: I wrote a helper called parBufferMap which should do that exact thing.
14:55:14 <ertesx> should or does?
14:55:18 <koz_> ertesx: 'parBufferMap i strat f = withStrategy (parBuffer i strat) . fmap f'
14:55:34 <ertesx> looks reasonable
14:55:35 <koz_> And the strat I pass in is rdeepseq.
14:56:01 <ertesx> koz_: are the individual computing times very different?
14:56:16 <ertesx> or do all elements take roughly the same time to compute?
14:56:21 <koz_> For each element? I don't *believe* they'd be too wildly different.
14:57:39 <koz_> ertesx: Am I perhaps being too granular in my parallel tasks?
14:58:35 <ertesx> koz_: potentially, yeah
14:58:57 <ertesx> have you tried different values for 'i'?
14:59:10 <koz_> Different buffer sizes? Nope - could this be an issue?
14:59:15 <ertesx> yeah
14:59:15 <koz_> (my current size is 50)
14:59:35 <koz_> (maybe that's a little small for a list of 65.5k items...)
14:59:45 <ertesx> also make sure the buffer size is a multiple of the number of threads
14:59:54 <koz_> ertesx: How come?
15:00:18 <ertesx> you're basically doing parMap on i-sized chunks
15:00:41 <ertesx> if the number of threads doesn't fit evenly into the chunks, you're wasting core time per chunk
15:01:09 <ertesx> try powers of 2, then fine-tune
15:01:46 <koz_> ertesx: OK. I just launched a run with 200, but I'll try powers of 2 after that.
15:04:05 <ertesx> koz_: did i mention that you should read The Book?
15:04:14 <ertesx> @where The Book
15:04:30 <ertesx> koz_: http://chimera.labs.oreilly.com/books/1230000000929/
15:04:44 <koz_> ertesx: I have, but that didn't seem to help me much here.
15:05:06 <koz_> Unless I'm a *very* poor reader, none of what you've told me over the last two days comes up in it. Or at least, my copy of it.
15:05:30 <ertesx> i guess some of that is just my own experience
15:05:47 <koz_> ertesx: Well, it's also mine now, seemingly.
15:07:56 * hackagebot pipes-extras 1.0.5 - Extra utilities for pipes  https://hackage.haskell.org/package/pipes-extras-1.0.5 (GabrielGonzalez)
15:08:57 <koz_> ertesx: OK, 200 already got me down to 1600s from 1700s, so it seems to be helping.
15:09:22 <ertesx> koz_: try something like 32 or 64
15:09:29 <koz_> ertesx: I'm trying 512.
15:17:10 <koz_> ertesx: Your idea seems to be working - 512 did even better.
15:21:15 <ertesx> koz_: find the best power of 2, then examine values around that one
15:21:53 <koz_> ertesx: OK.
15:25:00 <koz_> ertesx: If even that fails to give me sensible speedups, what's the next step?
15:28:07 <ertesx> koz_: well, you could always split the work into exactly as many pieces as you use cores and fire up threads explicitly, but i don't recommend doing that
15:28:20 <ertesx> koz_: also you don't necessarily get better performance that way
15:28:44 <ertesx> parallel performance depends on many factors, some of which aren't under your control
15:28:54 <koz_> ertesx: OK.
15:29:02 <ertesx> for example whether innermost caches are core-local, whether you have hyperthreading, etc.
15:31:00 <ertesx> one thing you can do is to make sure that the threads don't thrash each other's caches by improving memory locality
15:31:26 <ertesx> even if L1 is core-local, L2 and L3 rarely are, as far as i know
15:48:18 <python476> hi there
15:49:24 <python476> I just found out that Simon Marlow book on Parallel Haskell, is it a hard read ? I never read haskell books, only did meijer FP101 (hugs, and some typeclasses)
15:56:10 <hpc> it looks extremely readable to me, but not sure if that extends to someone not already familiar with concurrency/parallelism
15:56:30 <koz_> It's very readable, but I'd say it's the beginning to understanding this stuff in Haskell, not the end.
15:56:40 <hpc> it's freely available online, so you can try it out yourself
15:56:40 <koz_> (as my chatter with ertesx above should indicate)
15:57:08 <hpc> and yeah, it's definitely on the translating-concepts-to-haskell side
15:58:10 <hpc> on the bright side, it gives you a vocabulary to have said chatter in
15:58:42 <hpc> and simply knowing what questions you need to ask is useful by itself
16:00:03 <hpc> these four lines are all of the same length, what an odd  coincidence
16:00:53 <hpc> (whoops used double-spaces in there)
16:01:14 <geekosaur> or piped it thought fmt >.>
16:01:15 <python476> hpc: I was trying not to put carriage before the horses
16:01:34 <python476> maybe reading another book before would be better advised
16:01:55 <hpc> geekosaur: my prompt starts two characters before my scrollback output, so i was actually aligning the lines
16:02:00 <python476> I'll see how far I can go
16:02:06 <hpc> and filling in suitable words
16:03:18 <koz_> ertesx: 512 seems to give the best results, but I still have *ridonculous* differences between the serial and parallel versions. Here's my code - hopefully it might help you see where I'm missing something: http://lpaste.net/168982
16:07:32 <iphy> hi, I'm trying to get hpc coverage to work with hpc-coveralls or codecov-haskell
16:08:40 <iphy> or even just get hpc to work correctly
16:08:49 <iphy> Test coverage report written to dist/hpc/vanilla/html/test-tox/hpc_index.html
16:09:27 <iphy> if I open this file, I see "module hstox_KIMME0omFTdA6dhUsDvo5J/Network.Tox.Binary"
16:11:49 <iphy> $ codecov-haskell hstox-0.0.1
16:11:49 <iphy> codecov-haskell: Couldn't find the file dist/hpc/tix/hstox-0.0.1/hstox-0.0.tix
16:12:48 <iphy> I don't understand what it's trying to do - none of the targets from the cabal file work as argument, and a dist/hpc/tix directory doesn't even exist
16:27:32 <ertesx> python476: The Book by simon marlow assumes that you have basic understanding of haskell, not much else
16:27:59 <Welkin> I found it easy to understand and get into quickly
16:28:07 <Welkin> though I dropped it as soon as I got busy
16:32:16 <ertesx> koz_: doN n f x = replicateM_ n (f x) *> pure x
16:32:25 <ertesx> ah, no
16:32:27 <ertesx> nevermind
16:34:08 <ertesx> koz_: next: make sure that everything needed by the parallel computation is fully evaluated, before it starts
16:35:38 <ertesx> due to haskell's laziness you may find that some threads, especially in the initial chunk, do stuff that isn't part of the algorithm, but really of initialisation
16:37:58 <ertesx> i can't really give you any more advice, because i'm not familiar with your use case…  but those are the general guidelines i can give you
17:04:16 <koz_> I'm a bit confused with how to combine Strategies. I wanna do a combination of parBuffer and parListChunk (so process the list in chunks, but also treat the list as a rolling buffer as per parBuffer). How would I write this?
17:36:31 <ClaudiusMaximus> koz_: maybe you could do the chunking separately? but that would limit useful strategies for parBuffer.. something like  concat . withStrategy (parBuffer numCapabilities rdeepseq) . chunksOf 147  (from the split package)
17:36:53 <ClaudiusMaximus> koz_: maybe you'd need to write your own Strategy if they can't be composed from outside cleanly
17:39:14 <koz_> ClaudiusMaximus: I think that's where I'm headed. Thanks anyway - I'll read that stuff more carefully I guess.
17:55:14 <brian-8473> join/ #clojure
17:55:35 <Koterpillar> boo
18:18:01 * hackagebot systemstats 0.1.0.0 - An application that regularly logs system stats for later analysis  https://hackage.haskell.org/package/systemstats-0.1.0.0 (savannidgerinel)
18:22:00 <jle`> anyone have an example link to a deprecated module? just seeing how current libraries deal with it/format it
18:28:01 * hackagebot micrologger 0.2.0.1 - A super simple logging module. Only for use for very simple projects.  https://hackage.haskell.org/package/micrologger-0.2.0.1 (savannidgerinel)
19:34:50 <hatds> If you have two bindings set to the same expression, they can sometimes 'share' the computation that is later done to evaluate the expression.  What about IORefs?  Writing to one IORef doesn't change the stored value of another IORef, but can computation be shared if they are storing the same expression?
19:36:08 <hatds> I would assume it happens just as in the case with bindings, but I'm a bit unsure.
19:46:37 <KaneTW> hatds: looks like it doe
19:46:39 <KaneTW> does*
19:47:04 <hatds> thanks
19:47:36 <KaneTW> i didn't check the spec, just did some quick tests in ghci with a ioref shared between threads
19:51:13 <geekosaur> that sounds not what they were asking?
19:51:21 <geekosaur> two IORefs with "the same expression" in them
19:52:08 <geekosaur> (which I would hope would *not* be shared unless it's from the same *binding*. I wouldn't expect the other to be shared either but that's just because ghc doesn't normally do CSE)
19:53:38 <geekosaur> basically, because IORefs are in IO, there can be no guarantee that such sharing is safe
19:53:55 <geekosaur> it is safe in pure code only
19:55:50 <hatds> yes, I meant the same expression is coming from the same binding
19:56:12 <geekosaur> also too much sharing can be a bad thing, by unexpectedly retaining values you thought would be garbage collected
19:57:01 <hatds> I'm not so interested in relying on the sharing, but I was curious if IORefs even work that way or not.
19:58:19 <geekosaur> an IORef has in it the same thing any other "value" does, it's a pointer to either a computed value or what amounts to a piece of code that will compute a value. these can be shared, unless they are themselves in IO (that is, you stored a IO something in an IORef)
19:59:00 <hatds> As I thought, thanks.
20:00:13 <geekosaur> (actually even the IO something would be shared, but it's a "program" which could produce different results in different contexts...)
20:01:16 <hatds> replicateM_ x (putStr "hi!") where x = billionth digit of e
20:01:47 <hatds> :)
20:01:52 <alercah> geekosaur: why can't you store an IO operatin in an IO ref?
20:02:09 <geekosaur> huh? that's not what I said
20:03:16 <hatds> hmm, I'm not even sure if that'd work.  I guess you'd need x to be scoped outside the expression you writing to the IORef
20:03:17 <geekosaur> athough I put what I was trying to say badly; I meant that if I store getLine :: IO String in an IORef, that does not mean that anything that binds the IORef's value will get the same result as if I'd stored the result of executing the getLine
20:03:45 <geekosaur> (getLine itself is pure; it's an instruction to the runtime, not a value or a wrapper around a value)
20:04:06 <alercah> oh right
20:08:04 * hackagebot hpqtypes 1.5.0 - Haskell bindings to libpqtypes  https://hackage.haskell.org/package/hpqtypes-1.5.0 (arybczak)
20:08:06 * hackagebot log 0.5.0 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.5.0 (arybczak)
20:08:08 * hackagebot consumers 2.0 - Concurrent PostgreSQL data consumers  https://hackage.haskell.org/package/consumers-2.0 (arybczak)
21:11:29 <tsani> lua
21:11:34 <tsani> whoops mischan
21:21:25 <gabbiel> @src reverse
21:21:25 <lambdabot> reverse = foldl (flip (:)) []
21:48:23 <foobarbaz> hi all, i'm trying to create a basic API written in haskell that would stream audio files. i was thinking streaming via HTTP and i was looking into pipes-http
21:49:41 <foobarbaz> i wasn't sure if it was the best way to approach my problem, are there any other libraries that i'm not aware of that can stream HTTP?
22:20:30 <ludat> foobarbaz: conduit could work (never used it though)
22:27:12 <Sonarpulse> hey all, where are the cabal release notes?
22:27:56 <srhb> Sonarpulse: cabal or cabal install?
22:28:40 <Sonarpulse> whatever has more 1.24 notes
22:28:51 <srhb> Sonarpulse: https://github.com/haskell/cabal/blob/master/cabal-install/changelog ?
22:29:06 <Sonarpulse> that's kinda nitty gritty (though technically not what I asked for)
22:29:12 <Sonarpulse> *what i asked for
22:29:13 <Sonarpulse> sorry
22:29:24 <Sonarpulse> http://coldwa.st/e/blog/2016-05-04-Cabal-1-24.html
22:29:30 <Sonarpulse> might be better
22:29:33 <Sonarpulse> thanks anyways!
22:29:40 <srhb> Sonarpulse: Ok :)
22:48:07 * hackagebot http-client 0.4.31 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.31 (MichaelSnoyman)
23:13:15 <joobus> i'm working through the haskell book, and I'm trying to figure out: (fmap . fmap)
23:14:56 <joobus> since fmap takes 2 arguments, a function, and a functor, would: (fmap . fmap) someFunc aType... expand to (fmap (fmap someFunc aType)) or (fmap (fmap someFunc)) aType?
23:15:24 <benzrf> joobus: fmap does not take a functor
23:15:41 <benzrf> "a functor" is a type constructor (or more properly, a type constructor plus an fmap implementation)
23:15:46 <cocreature> joobus: it expands to the latter
23:15:59 <benzrf> not a value whose type is an application of that constructor.
23:16:06 <benzrf> so "Just 3" is not a functor; "Maybe" is
23:16:20 <benzrf> or more properly, Maybe + fmap for Maybe
23:17:06 <koz_> joobus: Another way to think about fmap - imagine it has the type (a -> b) -> (f a -> f b).
23:17:16 <koz_> Then, fmap . fmap becomes rather easy to imagine.
23:17:16 <benzrf> it *does* have that type :P
23:17:35 <koz_> benzrf: The brackets make the intent a bit clearer IMHO, and the actual type doesn't have them.
23:17:38 <koz_> :t fmap
23:17:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:17:59 <koz_> That was the 'a-ha!' moment for me and functors.
23:18:04 <benzrf> kk
23:20:22 <joobus> i understand one fmap: fmap someFunc aType, and I understand looking at the type signature in ghci what (fmap . fmap) does, but the book wants me to write out how (fmap . fmap) expands, and thats the part I am brainstewing on.
23:20:54 <koz_> joobus: Try and write its type.
23:21:04 <kadoban> joobus: Well, what is the definition of (.) ?
23:21:09 <koz_> :t (.)
23:21:10 <lambdabot> (b -> c) -> (a -> b) -> a -> c
23:21:13 <joobus> that's what I'm doing.
23:21:25 <joobus> the book has the types for (.) and fmap laid out on the page
23:21:47 <koz_> joobus: Well, consider fmap. You start with (a -> b), and you get (f a -> f b).
23:22:06 <koz_> Now, replace 'f a' with 'c' and 'f b' with 'd'.
23:22:10 <koz_> And run it through the same process.
23:22:16 <koz_> What do you get on the *outer* fmap then?
23:23:08 * hackagebot monad-logger 0.3.19 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.19 (MichaelSnoyman)
23:26:22 <joobus> i think i am beginning to see the light...
23:27:05 <koz_> joobus: So what'll come out of the outer fmap, then?
23:28:43 <hwkng> anyone know if there is an irc channel / mailing list for haskell/project-m36? I'm trying to figure out how they store their rows / tables in a typesafe manner
23:29:18 <joobus> a type f (g x) with a function (y -> x) applied to the inner value
23:30:13 <joobus> for (fmap . fmap) to work the type needs to be 2 functors deep
23:31:07 <Koterpillar> joobus: I don't think that's right; if you started with (a -> b), what's the *exact* type?
23:33:08 * hackagebot conduit-extra 1.1.13.2 - Batteries included conduit: adapters for common libraries.  https://hackage.haskell.org/package/conduit-extra-1.1.13.2 (MichaelSnoyman)
23:34:08 <joobus> Koterpillar: you mean the original function is (a -> b)?
23:35:16 <joobus> :t (fmap . fmap)
23:35:18 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
23:37:29 <Koterpillar> now that was cheating
23:37:52 <Koterpillar> note that this is different to what you said (a function applied to the inner value)
23:37:59 <Koterpillar> although maybe I just misunderstood
23:40:42 <joobus> Koterpillar: just assume I'm noobish and didn't use the right words exactly.  I'll try again: for (fmap . fmap) to work, it takes a function, and a value which needs to be a combination of 2 functors (2 functors deep).
23:40:57 <Koterpillar> yes, that's right
23:41:33 <Koterpillar> sorry, the types written in English are not that precise ;)
23:48:09 * hackagebot point-octree 0.5.5.3 - Point octree, with bounding boxes  https://hackage.haskell.org/package/point-octree-0.5.5.3 (MichaelLitchard)
