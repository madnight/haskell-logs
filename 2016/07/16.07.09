00:07:37 * hackagebot cereal-streams 0.0.1.0 - Use cereal to encode/decode io-streams.  https://hackage.haskell.org/package/cereal-streams-0.0.1.0 (winterland)
00:07:37 * hackagebot kraken 0.0.3 - Kraken.io API client  https://hackage.haskell.org/package/kraken-0.0.3 (wereHamster)
00:57:33 * hackagebot debian-build 0.10.1.0 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.10.1.0 (KeiHibino)
02:29:17 <renji_> hey guys
02:34:18 <Axman6> hello renji_!
02:34:53 <renji_> i need help in socket programmation anyone can help me ? 
02:39:32 <renji_> somebody can help me ? 
02:41:56 <Freundlich> renji_: Nobody knows if they can help you unless you ask a more specific question.
02:45:33 <renji_> I'm an informatic engineer student and i need some help for program socket in c lenguage 
02:55:48 <cocreature> reinh: this channel is about the haskell programming language, not C
02:56:01 <cocreature> oh he left
02:56:23 <reinh> cocreature: thanks for letting me know :p
02:56:34 <cocreature> reinh: sorry I’m too stupid for tab completion :)
02:56:37 <reinh> :D
02:57:11 <jle`> your lowercase r still throws me off ><
02:59:15 <mniip> does anyone know a good book that would serve as an intro to CT?
03:00:45 <reinh> jle`: :p
03:00:54 <ReinH> jle`: better?
03:01:17 <ReinH> mniip: category theory?
03:01:23 <mniip> yes
03:02:20 <ReinH> mniip: Conceptual Mathematics by Lawvere or Category Theory by Awodey
03:02:42 <ReinH> mniip: also http://reinh.com/notes/posts/2014-07-25-recommended-reading-material.html, https://www.quora.com/What-is-the-best-textbook-for-Category-theory
03:03:47 <shachaf> mniip: Try Tom Leinster's _Basic Category Theory_.
03:04:10 <shachaf> http://www.maths.ed.ac.uk/~tl/bct/ -- he was going to put it online this year but I guess he hasn't gotten around to it yet.
03:05:26 <ReinH> Yeah, Leinster's new book is good. I need to update my list.
03:08:06 <maerwald> ReinH: wrt "Category Theory" by Awodey it seems computer scientists have rather trouble reading that, judging from the amazon reviews
03:10:06 <ReinH> Well, it's category theory...
03:10:28 <mniip> I'm asking for a friend actually...
03:10:29 <maerwald> not sure that explains it
03:10:33 <mniip> but yeah that probalby works
03:10:38 <maerwald> see the review
03:11:00 <ReinH> Yeah, it can be tough. That's why I recommended Lawvere first.
03:11:10 <ReinH> Just be glad I didn't recommend Mac Lane :p
03:17:12 <shachaf> whoa, the category of partial functions is the same as the category of pointed sets and point-preserving functions
03:17:32 <shachaf> In retrospect that's obvious but I didn't think of it.
03:45:17 <zoran119> i'm using stack for a project and am trying to add libssh2 as a dependency
03:45:42 <zoran119> however i keep getting this error 'setup-Simple-Cabal-1.24.0.0-ghc-8.0.1: The program 'c2hs' is required but it could not be found'
03:45:47 <zoran119> any ideas?
03:46:25 <oherrala> zoran119: install c2hs
03:46:49 <oherrala> stack install c2hs
03:52:29 <cobreadmonster> shachaf: what on earth is a pointed set?
03:54:38 <int-e> a set with a point (distinguished element)
03:55:31 <zoran119> oherrala: how come this doesn't get taken care of by the package dependencies?
03:58:28 <oherrala> zoran119: that's what I have always wondered also :)
03:58:40 <oherrala> zoran119: it might be something to do with being executable instead of library
03:59:53 <zoran119> oherrala: cool, well that worked. thank you
04:00:40 <zoran119> oherrala: i'm guessing that i have to do 'stack install ...' and i cannot add this 'dependency' to stack.yaml?
04:01:14 <oherrala> zoran119: I have never tried
04:04:15 <mtesseract> Hi
04:14:38 <lyndon1> Is there a good example of plotting beenchmarks against input sizes in criterion? I'm trying to illustrate the algorithmic complexity of some algos and having to do a lot of hand-massaging and variable passing at the moment.
04:18:06 <ph88^> Failed to load interface for ‘Data.List.Split’    what does this mean?   i did:  import Data.List.Split (linesBy)
04:18:17 <parsnipM_> so i guess Data.Map has been the most useful library in considering projecteuler problems. 
04:18:46 <parsnipM_> lyndon1: i had a similar question, and someone linked me to this: http://book.realworldhaskell.org/read/profiling-and-optimization.html
04:22:38 * hackagebot telegram-api 0.4.3.1 - Telegram Bot API bindings  https://hackage.haskell.org/package/telegram-api-0.4.3.1 (klappvisor)
04:26:36 <lyndon1> parsnipM_: Cheers!
04:27:39 <lyndon1> parsnipM_: ah not quite what I was after, but still nice to see
04:47:39 * hackagebot nested-sequence 0.2 - List-like data structures with O(log(n)) random access  https://hackage.haskell.org/package/nested-sequence-0.2 (BalazsKomuves)
05:00:39 <nmdanny> is there a way to make lenses work with GHC-8's 'DuplicateRecordFields' extension? basically, having lenses for datatypes with identical field names?
05:04:24 <notdan>  Hi
05:05:20 <pacak> o/
05:07:03 <lyxia> nmdanny: change the lenses name for one of the datatypes
05:07:26 <nmdanny> is there no way for them to have the same name?
05:08:22 <lyxia> not in the same module
05:10:28 <mtesseract> Isn't stack supposed to rebuild a package when I  specify a new set of ghc-options on the command line? As in e.g. 'stack build --ghc-options=-O0'? It doesn't seem to rebuild anything here, irregardles of the ghc-options I specify.
05:17:38 <ph88^> Failed to load interface for ‘Data.List.Split’    what does this mean?   i did:  import Data.List.Split (linesBy)
05:23:02 <int-e> ph88^: usually it means that the package providing that module can't be found... either because it's not installed, or because it's hidden, or because you're using cabal and forgot to add a dependency, or <something with stack here>.
05:23:23 <int-e> it can also indicate broken packages
05:24:45 <ph88^> int-e, any idea what is the name of the package ?
05:26:04 <lyxia> It's split
05:28:01 <thomie> mtesseract: ghc doesn't recompile a module after changing optimization flags. It's a bug though, see https://ghc.haskell.org/trac/ghc/ticket/10923.
05:29:21 <ph88^> lyxia, how do you know? i never know how to get the package name from the module name
05:31:46 <lyxia> http://hoogle.haskell.org/?hoogle=Data.List.Split
05:31:56 <mtesseract> thomie: I see, thank you
05:35:59 <ph88^> how can i a split a string by lines ?
05:36:48 <mtesseract> ph88^: lines :: String -> [String]
05:39:12 <mtesseract> Is it possible to make cabal generate output that contains the precise ghc commands (including specified ghc-options) used during the build? I sometimes like being able to directly see the ghc commands.
05:42:14 <ph88^> instead of dealing with just one error here i would like to handle multiple. Should i use mapM_ ?  https://paste.fedoraproject.org/389226/14680680/
05:42:20 <mtesseract> Hmm, stack's debugging facitilty produce way too much output for my taste, but it includes the ghc command.
05:43:52 <mtesseract> ph88^: Not sure what you mean.
05:46:45 <ph88^> mtesseract, https://paste.fedoraproject.org/389228/68375146/
05:50:00 <mtesseract> ph88^: and your question is...? When to use mapM_?
05:50:03 <ph88^> mtesseract, my train is arriving, have to go. back later :)
05:50:13 <mtesseract> Okay, bye.
05:50:17 <ph88^> byeee
06:04:44 <ph88^> mtesseract, i mean i expect mapM_ to work on multiple items but i get only one map action
06:09:22 <mtesseract> ph88^: What does errorPos pe evaluate to? Have you tried doing this kind of stuff in the REPL? 
06:15:48 <mtesseract> Trying to build a package with -rtsopts enabled. But cabal gives me the error message "warning: -rtsopts and -with-rtsopts have no effect with -shared." I don't really understand where this -shared comes from, nor how I am supposed to work around this.
06:24:53 <glguy> Mtesseract: RTS options go on executables, not libraries
06:27:21 <mtesseract> glguy: Well, the package consists of an executable and a library used by that executable.
06:29:20 <glguy> You'll have to paste your cabal file
06:29:29 <mtesseract> glguy: Aaah! It works. The warning is generated by the library part, but the executable seems to be compiled correctly with support for +RTS.
06:29:39 <mtesseract> glguy: Thanks. :)
06:30:16 <skrio> Does anyone have experience using yesod+fay?js
06:31:47 <skrio> Wonder if it works nicely, can't seem to find sources that arent more than 2 years old
06:35:29 <mniip> ReinH, wow, that page is awesome
06:36:02 <mniip> ReinH, I'm borrowing the "How to prove it" because another friend of mine is struggling from exactly this issue, and I didn't even know a book on such a topic exists
07:08:51 <still_learning_h> Quick question, what is preferable: WriterT in top of ExcepT or vice versa?
07:11:54 <notdan> the type `ExceptT e (WriterT w m) a` is m (Either e a, w)
07:12:19 <notdan> and `WriterT w (ExceptT e m) a` is m (Either (a, w), e)
07:12:24 <notdan> or maybe the other way around
07:12:32 <notdan> but yeah the semantics would be different
07:13:01 <notdan> still_learning_h: in one case, if you have an error/exception, you will lose the WriterT stuff. in the other case you will keep it
07:13:04 <still_learning_h> notdan: So ExceptT on top of Writer is preferable in my case, if i want to preserve the Writer-log incase of an error?
07:13:29 <notdan> yeah I would say so
07:13:42 <still_learning_h> then ExceptT on top is the way to go. Thanks!
07:19:09 <lpaste> anewnewbie pasted “Problem mapping over an HList of Eithers” at http://lpaste.net/169379
07:20:45 <anewnewbie> Hello, I'm having some trouble using Data.HList. I have pasted a MWE. The problem is that I cannot seem to map over an HList of Eithers where the "left type" is always the same and I always just want to work over that part in the mapping function.
07:21:32 <notdan> still_learning_h: yeah i think rule of thumb is that the outer effects apply first
07:23:06 <anewnewbie> the problem arises in `mappedHList3` but I think that maybe the `leftToMaybe` is not correctly polymorphic.
07:34:47 <aphorisme> anything against -XInstanceSigs ?
07:35:34 <lyxia> anewnewbie: you'll need a wrapper around leftToMaybe to be able to map it on the heterogeneous list
07:36:04 <nitrix> aphorisme: You could write the function separately and just do   instance Foo where f = g
07:36:53 <anewnewbie> lyxia: thanks a lot for answering. This has stumpted me for some time. Any example / pointer as what kind of wrapper is needed?
07:37:25 <anewnewbie> lyxia: maybe I can extrapolate the appropriate wrapper for my case
07:37:34 <aphorisme> Right, thanks nitrix.
07:42:24 <hexagoxel> anewnewbie: see first note on http://hackage.haskell.org/package/HList-0.4.1.0/docs/src/Data-HList-FakePrelude.html
07:43:29 <hexagoxel> anewnewbie: i don't know what exactly the solution in your case looks like (yet) but that seems to be the right explanation.
07:44:26 <anewnewbie> hexagoxel: Thanks a lot. I had stumbled upon that note in searching for a solution but I din't comprehent its importance. I will now read it more thoroughly.
07:45:00 <anewnewbie> hexagoxel: I had tried the RankNTypes solution as well, but it obviously did not work either
07:57:31 <hexagoxel> anewnewbie: seems you need introduce a new trivial datatype and an ApplyAB instance, just like `HPrint` below.
07:58:07 <hexagoxel> data LeftToMaybe = LeftToMaybe; instance ApplyAB LeftToMaybe (Either a b) (Maybe a) where applyAB LeftToMaybe e = leftToMaybe e; mappedHList3 = hMap LeftToMaybe simpleHList3
07:59:33 <anewnewbie> hexagoxel: Looking at this now..
08:02:12 <anewnewbie> hexagoxel: Yes!! This is great! It works fine. Thanks a bunch to both you (hexagoxel) and to lyxia!
08:03:21 <anewnewbie> hexagoxel: It's a bit stupid that a new Instance is needed for each function, but the fact that it works fine is more important to me.
08:12:30 <rhllor> im not at my home computer right now so i cant test but if i try to test for inclusion in an infinite list with elem will i get a value back on first occurence or will it keep running
08:13:29 <lyxia> if it is in the list you will get a value
08:13:46 <rhllor> for example if i run 2 `elem` [1..] will it return when it reaches 2 or will it try to traverse the whole list
08:14:12 <deank> >  2 `elem` [1..]
08:14:13 <lambdabot>  True
08:14:35 <rhllor> sweet tghanks
08:18:17 <rhllor> i had a problem whee I had to get the last ten digits in a very big number. the solution i wrote was     reverse (take 10 (reverse (show number)))  but im sure there is a better way to write this. Any help?
08:18:54 <geekosaur> use a data structure that lets you index properly, not a linked list
08:18:55 <mtesseract> rhllor: A numeric computation (modulo) might help.
08:20:56 <rhllor> well it worked and it didnt take more than half a second which i was surprised seeing as the number was more than 2 million digits. I guess I was looking more to make the function more readable but seeing as you say there are different solutions can you give me an exmple?
08:21:53 <mtesseract> rhllor: Do you know the modulo operation?
08:21:59 <rhllor> yes
08:22:00 <rhllor> %
08:22:35 <rhllor> or mod
08:22:38 <mtesseract> The last two digits of some number n are the same as the last two digits of the number n modulo 100.
08:22:54 <mtesseract> So, when you  do modulo, you basically throw away everything you don't need.
08:23:11 <mtesseract> instead of going through the very expensive string operations.
08:23:40 <rhllor> oh so to get the last ten digits i just have to calculate n `mod` 10^10
08:23:45 <rhllor> okay i get it now
08:24:06 <rhllor> well i guess you learn something new every day. thanks!
08:24:13 <mtesseract> rhllor: you are welcome.
08:24:47 <Jinxit> mtesseract: so you want to divide a 2 million digit number in order to extract the last 10 digits?
08:25:31 <rhllor> it was a problem from projecteuler. im very new to haskell and I like how I can pretty much translate what I want it to do instead of going through the steps of how to do it
08:25:49 <mtesseract> Jinxit: I didn't claim that the computation is particularly feasible for the concrete application (which I don't know).
08:26:08 <Jinxit> wat
08:26:17 <Jinxit> he told you
08:27:40 <rhllor> regardless of which is more efficient at least he taught me another way so i can know in the future when another case arises
08:27:57 <rhllor> and then i can determine myself which is the best solution
08:28:13 <mtesseract> Jinxit: I have missed the part about how long the number is. I am very sorry for this. On the other hand, I don't know by heart if it is more efficient to reverse a list of that many Char elements.
08:28:26 <mtesseract> (I have my doubts)
08:29:02 <Jinxit> anything involving two million digits is going to be a mess
08:37:08 <daey> if variables are stateless how is something like: let a = []; 0:1:a; ok?
08:37:44 * hackagebot mcm 0.6.4.10 - Machine Configuration Manager  https://hackage.haskell.org/package/mcm-0.6.4.10 (AnthonyDoggett)
08:37:47 * hackagebot Euterpea 2.0.2 - Library for computer music research and education  https://hackage.haskell.org/package/Euterpea-2.0.2 (DonyaQuick)
08:38:06 <pavonia> daey: In what context? Only that isn't valid syntax
08:38:34 <daey> i defined 'a' as []. after that i changed it to [0,1]
08:38:35 <kadoban> daey: I would say they're immutable instead, but what's wrong with it?  0:1:a is just an expression using a. It's like asking what 2 + x is, once you've defined x. That doesn't change what x is.
08:39:10 <daey> ah my bad
08:39:19 <daey> i assumed a would now be [0,1]
08:39:24 <daey> but it isnt. its still []
08:39:29 <kadoban> Right
08:40:56 <Profpatsch> huh, why is there no Either instance for MonadFail?!
08:41:18 <Profpatsch> Oooh
08:41:33 <maerwald> MonadFail, MonadThrow, MonadError, MonadExcept
08:41:36 <maerwald> we need more
08:42:16 <Clint> MonadPanic
08:42:35 <pavonia> > let a = [] in let a = 0:1:a in a
08:42:37 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
08:42:58 <Profpatsch> Yeah, I thought maybe fail a = Left a
08:43:16 <Iceland_jack> Profpatsch: It's being discussed
08:43:23 <Iceland_jack> https://ghc.haskell.org/trac/ghc/ticket/12160
08:43:28 <Profpatsch> But that’s hard because instance MonadFail (Either e)
08:43:43 <Iceland_jack> Profpatsch: 
08:43:43 <Iceland_jack>     instance String ~ str => MonadFail (Either str)
08:43:56 <Profpatsch> Ah, wow, that’s quite something.
08:44:01 <Profpatsch> Didn’t know that works.
08:44:22 <Iceland_jack> Profpatsch: see http://chrisdone.com/posts/haskell-constraint-trick
08:45:27 <Profpatsch> But then you need FunctionalDependencies, right?
08:45:35 <Profpatsch> So how much is gained really?
08:45:54 <Profpatsch> Oh, will read the blog post.
08:55:01 <lyxia> it's not Fundeps
09:10:14 <Zemyla> What packages are there for making an im-memory, queryable database?
09:10:44 <monochrom> do "acid-state" and "persistent" count?
09:10:57 <Zemyla> Well, it doesn't have to be persistent.
09:11:13 <monochrom> does Data.Map count? :)
09:11:14 <liste> Zemyla: persistent + sqlite
09:11:25 <liste> + maybe esqueleto
09:11:30 <Zemyla> Well, I kind of want to be able to query it in non-IO functions.
09:12:10 <liste> maybe this? https://hackage.haskell.org/package/ixset
09:12:26 <liste> or something similar. there was a tables package for lens but it was considered fundamentally flawed
09:12:39 <liste> https://hackage.haskell.org/package/tables
09:13:13 <Clint> ixset-typed
09:13:13 <Zemyla> This is the kind of thing I want to be able to query. http://mtgjson.com/
09:13:47 <liste> Clint: cool, thanks for the suggestion
09:14:12 <liste> Zemyla: if it's queries only, why not lens and aeson?
09:16:55 <Zemyla> liste: My plan is to be able to search for, say, all white creatures with 1 power and first strike or double strike.
09:17:16 <Zemyla> Yeah, I might as well do something like SQLite :V
09:48:31 <ertesx> (,) is an in-memory queryable database
09:49:41 <monochrom> I prefer Identity
09:50:07 <monochrom> I might be talked into going with Proxy
09:53:16 <ertesx> the universal empty database
09:53:28 <ertesx> "how do i put data into it?" – "you don't"
09:54:00 <monochrom> "a -> Proxy a" is certainly possible. that's how to "put data in".
09:54:15 <ertesx> except you don't
09:54:42 <ertesx> but it's quite funky…  you can actually combine data you don't have
09:55:05 <ertesx> > pure sin <*> pure 3 :: Proxy Double
09:55:05 <monochrom> if you know the implementation, then you know data isn't put in. But you're supposed to just look at the API, which has the desired type a -> Proxy a
09:55:06 <lambdabot>  Proxy
09:56:09 <ertesx> you can even run arbitrary IO actions you don't have and populate a data structure you don't have with the results you never get =)
09:56:21 <ertesx> the universal empty data-structure =)
09:57:18 <monochrom> actually, the question asked for queryable, not settable. so we need getters instead of setters.
09:57:41 <monochrom> so "const 4" is a queryable database.
09:57:55 <EvanR> -_-
09:58:20 <mniip> performInALocalUniverse :: IO a -> Proxy a
09:58:27 <ertesx> isn't that a random number generator?
09:58:58 <monochrom> it's both!
09:59:02 <mniip> aren't those synonyms
09:59:10 <monochrom> \∩/
09:59:13 <ertesx> do you need Comonad for queryable, or would Extend be sufficient?
09:59:18 <EvanR> anything can be anythinged. if i scroll up will i find that were being an ass to someone
09:59:22 <ertesx> because by Extend standards Proxy is queryable
10:02:46 <ertesx> Zemyla: please don't take any of this seriously…  you got your useful answers already =)
10:10:56 <micahjam97> Im confused about the functions '$' and '.' . What do they do and how are they used
10:11:28 <oherrala> micahjam97: '.' is function composition. You can use it to compose two functions to make a new one
10:11:30 <monochrom> I don't use $. This makes life simpler.
10:12:08 <oherrala> micahjam97: for example f(g(x)) can be written as f . g
10:12:22 <ertesx> oherrala: that's not quite true
10:12:23 <micahjam97> oherrala: ahh ok. what about $
10:12:23 <monochrom> I just have to learn "f . g = (\x -> f (g x))"
10:12:37 <EvanR> @src ($)
10:12:37 <lambdabot> f $ x = f x
10:12:52 <micahjam97> so whats the purpose of $
10:12:58 <oherrala> micahjam97: $ is mostly used to avoid parenthesis
10:13:11 <micahjam97> okay then
10:13:11 <EvanR> its sometimes badly used to avoid parentheses
10:13:16 <oherrala> micahjam97: f(x+y) can be written as f $ x + y
10:13:29 <ertesx> micahjam97: using ($) is a (controversial) style choice
10:13:43 <oherrala> micahjam97: http://stackoverflow.com/a/1290727/361823
10:13:57 <mtesseract> As I see it, its precedence is what makes $ useful.
10:14:24 <micahjam97> okay sweet thanks. Ig as I go along learning haskell ill pick up on how its used
10:14:26 <oherrala> It's really easy to hack code which $ looks $ like $ this
10:14:33 <ertesx> mtesseract: rarely for me…  it's more often "being an operator" that makes ($) useful, because i can write: f $ do …
10:14:34 <oherrala> s/hack/write/
10:14:59 <ertesx> haskell doesn't allow "f do …"
10:15:51 <mtesseract> ertesx: I agree, that is also a good point.
10:16:12 <EvanR> ime experience its hard to convince people that code $ which $ looks $ like $ this is nice
10:16:32 <maerwald> and then, there is & and things get even worse
10:16:37 <EvanR> but its also hard to convince code . which . looks . like is better
10:17:06 <oherrala> EvanR: well, with point free style it . might . look . like $ this also
10:17:15 <EvanR> yuckc
10:17:18 <maerwald> and since haskellers usually want to look smart, they like to abuse operators, so the code looks smart 
10:17:28 <EvanR> get as far as you can without applying
10:17:31 <ertesx> EvanR: the difference between (.) and ($) is that the former is associative, so having a flat list of things is fine
10:18:06 <EvanR> yes $ is not associative, which means it hurts my feelings, but thats as far as my argument goes
10:18:35 <ertesx> EvanR: not being associative means it makes structured code look flat, so you can't see its structure syntactically
10:18:59 <EvanR> you already have to convince people that f x y z w is (((f x) y) z) w, so $ and & are just middle fingers to pedagogy
10:18:59 <ertesx> i stopped doing that after i found old code of mine mildly annoying to read
10:21:47 <EvanR> people think a pile of operators is idiomatic haskell, which hurts, i cant wait until someone looks at it and says "just use freakin parentheses" without knowing haskell at all
10:22:11 <EvanR> instead of that being an advance technique you have to learn
10:26:01 <Rotaerk> EvanR, some people are turned off to haskell by the strange operators they see in the example code snippets
10:35:13 <ertesx> EvanR: i know haskell and say, just use freakin' parentheses =)
10:35:50 <ertesx> also, "just name the argument!"
10:36:33 <ertesx> @pl is more like alcohol than a programmer tool…  when you feel you need it, you have a problem
10:36:34 <lambdabot> (line 1, column 45):
10:36:34 <lambdabot> unexpected '\128'
10:36:34 <lambdabot> expecting variable, "(", operator or end of input
10:48:56 <jmcarthur> To me, ($) is usually just temporary scaffolding that I tear down once I understand how my code is going to be structured in the end.
10:49:04 <athan> Hi everyone, I'm trying to build a simple typeinference algorithm for prenex-polymorphic lambda calculus with a single monomorphic type, by hand without cheating and looking at algorithmW for reference. Does anyone here know of a nice way to handle alpha equivalence? Right now, I'm thinking of just recursing from the outer most part of the AST inward, and then having some kind of context invariant mapping, 
10:49:10 <athan> so every time I run into an Abs, I can map my context dictionary to a new one that's alpha equivalent to avoid name issues, and then morph back. I also don't want to use DeBrujin indicies for this, I really want to staple this together by hand so I can actually say I understand how to make one :p
10:52:25 <athan> Really, I think what I'm thinking is this: if `App :: String -> Expr -> Expr`, then `typeInfer (App x e) = do {ctx <- get; let ctx' = {- somehow rip out `x` from the ctx mapping, then re-embed it once complete -}; put ctx'; t <- typeInfer e; {- put the stuff I ripped out back in -} }
10:53:11 <athan> I'm not sure if I'm right here, but this might make type inference hylomorphic, not catamorphic. Can anyone here give their 2c?
11:25:34 <Guest21> Is there a way to chain the execution of randomR a bunch of times? Basically, it'd like to pass the new RandomGen produced by one call into the next call. I started out with this: https://github.com/cjlarose/exercism-solutions/blob/178246d6432a5ed90e6fe20275b0087e4748d555/haskell/robot-name/Robot.hs#L16-L22. And rewrote with a fold like this: https://github.com/cjlarose/exercism-solutions/blob/b6914c0f8c591f24c9ba47c4403b41dedb42645b/hask
11:25:34 <Guest21> ell/robot-name/Robot.hs#L16-L21
11:25:55 <Guest21> But I was wondering if there's a more idiomatic way to do it
11:29:03 <Eduard_Munteanu> Guest21, you normally call randomRs to get an infinite list of random numbers
11:29:11 <mniip> Guest21, yes, monads
11:29:23 <cocreature> a state monad to be specific
11:29:24 <Profpatsch> Nothing up in #haskell-lens, so my question here.
11:29:25 <Profpatsch> Getter s a -> Getter s b -> Getter s (a,b)
11:29:39 <Profpatsch> Is there a function like that? Or how do I construct it?
11:30:03 <cocreature> Guest21: if you don’t want to implement it yourself there is also a package called MonadRandom providing a typeclass for types that pass the rngs around for you
11:30:41 <nmdanny> Can somebody help me? i'm getting a weird "Could not deduce ... from the context ... bound by type signature..." error
11:30:42 <Eduard_Munteanu> :t (&&&)
11:30:44 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:30:49 <cocreature> nmdanny: show your code
11:31:01 <Profpatsch> Eduard_Munteanu: Holy crap.
11:31:04 <cocreature> otherwise it’s pretty harad to help you
11:31:13 <Profpatsch> It’s always more general than one would imagine.
11:31:27 <lpaste> nmdanny pasted “A typeclass and some methods for database CRUD operations” at http://lpaste.net/169397
11:31:28 <Guest21> Eduard_Menteanu The problem I had with randomRs was that it can't return the new RandomGen. I think it's nice to be able to take a RandomGen and return a new one, analogous to randomR
11:31:48 <mniip> :t state . randomR 
11:31:50 <lambdabot> (MonadState s m, RandomGen s, Random a) => (a, a) -> m a
11:32:00 <nmdanny> I am trying to make a typeclass for easily performing CRUD operations over items stored in a database,
11:32:10 <cocreature> nmdanny: please add the error to it :)
11:32:12 <mniip> :t replicateM 5 $ state $ randomR ('A', 'Z')
11:32:13 <lambdabot> (MonadState s m, RandomGen s) => m [Char]
11:32:55 <Guest21> mniip Ok cool. I've never used MonadState before, but I'll check it out!
11:33:01 <Eduard_Munteanu> :t runState $ replicateM 5 $ state $ randomR ('A', 'Z')
11:33:03 <lambdabot> RandomGen s => s -> ([Char], s)
11:33:09 <mniip> well, you can use any other comfortable State monad
11:33:21 <mniip> not neccessarily transformers (mtl?)
11:33:54 <Guest21> Eduard_Munteanu you're a magician 
11:34:11 <nmdanny> im trying to paste the error from cmd but its badly formatted
11:34:40 <Guest21> nmdanny http://lpaste.net/new/haskell
11:34:52 <lpaste> nmdanny revised “A typeclass and some methods for database CRUD operations”: “A typeclass and some methods for database CRUD operations” at http://lpaste.net/169397
11:35:11 <nmdanny> bunch of whitespace in the error message
11:35:33 <cocreature> the bigger problem is that there is text missing :)
11:36:02 <mniip> > runState (replicateM 10 $ state $ randomR ('A', 'Z')) (mkStdGen 0)
11:36:04 <lambdabot>  ("NLRKWLDBJI",1695805043 1336516156)
11:36:05 <lpaste> nmdanny revised “A typeclass and some methods for database CRUD operations”: “A typeclass and some methods for database CRUD operations” at http://lpaste.net/169397
11:36:13 <nmdanny> ok here full error
11:36:18 <Profpatsch> Eduard_Munteanu: Nope, &&& doesn’t go well with lenses
11:36:20 <cocreature> thx, I’ll take a look
11:36:28 <Profpatsch> statusCode :: Functor f => (Int -> f Int) -> Status -> f Status
11:37:26 <cocreature> nmdanny: the problem is that the "item" in the type of vec doesn’t have to match the one in the type signature
11:37:58 <cocreature> nmdanny: you could work around this by giving it an explicit type signature (which requires ScopedTypeVariables)
11:38:36 <nmdanny> how does the type of "item" not match, clearly the vector I do "putStore" is the same as the one from "getStore"
11:39:13 <nmdanny> since Vec.ifilter, which takes a vector parameterized over 'a', returns a vector parameterized over 'a'
11:39:46 <mniip> Profpatsch, doesn't seem to be doable without instantiating foralls in the type signature exactly
11:40:18 <Profpatsch> mniip: There is no combinator?
11:40:36 <cocreature> nmdanny: you are right that the it’s the same as the one you put in putStore, but still that could be something different from the item you mention in your type signature. there is nothing that says that these two types have to match
11:40:36 <mniip> might as well just use view and to
11:41:41 <mniip> Profpatsch, lenses are bad at being combined in any way other than (.)
11:42:00 <nmdanny> do you mean that the compiler thinks that 'getStore' and 'putStore' operate with different 'item' instances?
11:42:37 <Profpatsch> mniip: Hm, that’s interesting.
11:42:44 <Profpatsch> Why could that be?
11:43:09 <mniip> well, consider your Getter issue
11:43:33 <cocreature> nmdanny: the compiler sees that you use getStore, which has type m (store item), item here is a fresh type variable corresponding to the item0 in your error message. it then trys to resolve the constraint, but it has only a constraint for some fixed item which might not be the same as the item0.
11:43:59 <mniip> ultimately you're trying to combine (forall f. (Phantom f) => f s) and (forall g. (Phanotm g) => g s) into (forall h. (Phantom h) => h s)
11:44:08 <cocreature> nmdanny: the problem is not between getStore and putStore, removing putStore will leave you with more or less the same error message
11:45:08 <nmdanny> Ok, then where do I put a type signature for it to compile?
11:45:56 <cocreature> nmdanny: you need a type signature on vec, but to be able to refer to the item from your main signature you need to enable ScopedTypeVariables and use "forall item m." at the beginning of vectorCrudDelete’s type signature
11:46:27 <Profpatsch> mniip: Oh, so I’d have to explicitely state the whole type arguments and put the forall around everything.
11:46:53 <Profpatsch> Which is quite a narrow setting after all.
11:47:06 <athan> Anyone know of an alternative to `'` for annotating a similar, but still slightly different variable?
11:47:12 <athan> (and not _ ? :D)
11:47:27 <athan> I'm thinking `fooHat`, but I don't want to write Hat all the time :(
11:47:32 <nmdanny> I tried doing so, but it doesn't seem to help
11:47:54 <nmdanny> if I want to annotate "vec <- getStore",
11:47:58 <Eduard_Munteanu> Yeah, my bad, I thought (&&&) would do, but...
11:48:09 <Eduard_Munteanu> :t (_1 &&& _2)
11:48:10 <lambdabot> (Functor f, Field2 s1 t1 a b, Field1 s t a b) => (a -> f b) -> (s -> f t, s1 -> f t1)
11:48:10 <nmdanny> do I have to type :  "vec <- getStore :: Vector item" ?
11:48:47 <Eduard_Munteanu> nmdanny, the annotation applies to getStore, not vec
11:48:57 <mniip> Profpatsch, nah I mean
11:49:04 <ertesx> > evalState (forever (state (randomR ('a','z')))) (mkStdGen 0)
11:49:11 <lambdabot>  mueval: ExitFailure 1
11:49:23 <mniip> tools that construct optics, such as 'to', 'lens', 'prism', abstract specific behaviors to general classes of functors
11:50:01 <mniip> whereas tools that use lenses, 'view', 'preview', etc, instantiate those functions with specific functors
11:50:05 <ertesx> > execWriter (evalStateT (forever (state (randomR ('a','z')) >>= \x -> tell [x])) (mkStdGen 0))
11:50:07 <lambdabot>  "nlrkwldbjiroiuubqpnceqcnspixnozidyqweulljuitndhdnopdgkkjzyrdwgwwzxvofbjrxcp...
11:50:41 <Xe> I am trying to disable a timeout via a http manager
11:50:44 <Xe> let settings = defaultManagerSettings { managerResponseTimeout = ResponseTimeoutNone }
11:50:49 <nmdanny> I tried doing "  vec :: Vector item <- getStore " , doesn't help either
11:50:57 <Xe> this is saying there is a parse error on `let`. what did i do wrong?
11:51:09 <Eduard_Munteanu> :t to ((^. _1) &&& (^. _2))
11:51:11 <lambdabot> (Profunctor p, Field2 s s c' c', Field1 s s c c, Contravariant f) => Optic' p f s (c, c')
11:51:39 <mniip> Profpatsch, so unless I'm mistaken, any combinator that does what you want will essentially be abstracting and then generalizing
11:51:44 <mniip> i.e not any different from to+view
11:52:25 <mniip> Xe, context?
11:52:37 <nmdanny> ok some questions, 
11:52:37 <Eduard_Munteanu> :t view ((^. _1) &&& (^. _2))
11:52:38 <lambdabot>     Couldn't match type ‘(c0, c'0)’ with ‘s0 -> Const a s0’
11:52:38 <lambdabot>     Expected type: Getting a s0 a
11:52:38 <lambdabot>       Actual type: (a -> Const a a) -> (c0, c'0)
11:52:49 * hackagebot rainbow 0.28.0.4 - Print text to terminal with colors and effects  https://hackage.haskell.org/package/rainbow-0.28.0.4 (OmariNorman)
11:52:53 <Eduard_Munteanu> Nvm.
11:52:57 <Xe> mniip: http://puu.sh/pVYkj/e592f71399.png
11:53:05 <nmdanny> if I want to annotate a bound value's type in a 'do block', do I need to include the monad's type?
11:53:21 <mniip> Xe, that needs to be within a do-block
11:53:28 <nmdanny> second, do I have to annotate the value itself, or the function which provides that monadic value?
11:53:46 <Xe> mniip: it is whithin one i thought
11:54:09 <Eduard_Munteanu> > do { (s :: String) <- getLine; putStrLn s }
11:54:10 <lambdabot>  <IO ()>
11:54:16 <mniip> Xe, context of your code then?
11:54:24 <Xe> mniip: WAI applicaion handler
11:54:47 <Xe> takes post body, fires to another service, converts the resulting html into markdown
11:54:48 <jmcarthur> nmdanny: It should look like either   x :: A <- m   or   x <- m :: M A
11:54:53 <Eduard_Munteanu> > do { s <- (getLine :: IO String); putStrLn s }
11:54:55 <lambdabot>  <IO ()>
11:54:56 <mniip> no I mean, the surroundings of the 'let' line
11:55:22 <mniip> jmcarthur, iirc the former needs an extension?
11:55:24 <jmcarthur> nmdanny: The first one might require an extension. I don't remember which one.
11:55:36 <jmcarthur> nmdanny: I expect GHC would tell you which one is needed.
11:55:41 <Eduard_Munteanu> ViewPatterns I think.
11:55:44 <mniip> ScopedTyVars
11:55:48 <jmcarthur> Eduard_Munteanu: Pretty sure not that.
11:55:53 <Eduard_Munteanu> Ah, that.
11:56:13 <jmcarthur> mniip: That sounds right (even though that extension is more powerful than needed)
11:56:26 <Xe> mniip: https://gist.github.com/anonymous/db30735f2729ef4e7ac9099bb0c00b58
11:57:30 <Xe> it says tha tt the `let settings` fails o parse
11:57:35 <Xe> fails to parse*
11:57:40 <mniip> what says
11:57:45 <Xe> haskell
11:57:56 <Xe> /home/xena/code/textile-conversion/hsapp/src/Main.md:106:17: parse error on input ‘let’
11:58:21 <mniip> ah the haskell source is a concatenation of all code blocks?
11:58:34 <Xe> yes
11:58:43 <mniip> should've clarified
11:58:53 <mniip> pastebin the .hs file
11:58:59 <lpaste> nmdanny revised “A typeclass and some methods for database CRUD operations”: “A typeclass and some methods for database CRUD operations” at http://lpaste.net/169397
11:59:07 <Xe> there is no hs file
11:59:15 <Xe> it's preprocessed on compile
11:59:26 <nmdanny> ok even after adding a forall and annotation, I still get the same error
11:59:50 <dmwit_> nmdanny: With modern GHCs, there are also other options. e.g. `do { v <- readLine @Int; print v }` looks quite pretty to me
11:59:58 <mniip> well, standard GHC can only interpret haskell or literal haskell files
12:00:18 <nmdanny> ok I'm not really interested in how pretty it looks, I want it to work first
12:01:03 <nmdanny> I did notice something: vectorCrudDelete is the only function that doesn't have 'item' in its parameter or return types.
12:01:05 <dmwit_> nmdanny: The type of `vectorCrudDelete` is ambiguous. It's not a type-checking problem.
12:01:10 <mniip> so one of those must be an intermediate step?
12:01:11 <dmwit_> nmdanny: ...exactly!
12:01:21 <dmwit_> nmdanny: You can add one using the standard `Proxy` trick.
12:01:48 <dmwit_> nmdanny: e.g. use a type like `forall item m. MonadItemStore item Vector m => proxy item -> Int -> m ()`
12:02:01 <Xe> mniip: just assume that the literatte haskell document is valid haskell code
12:02:09 <dmwit_> nmdanny: Callers need to provide a proxy value, which can be done using (for example) `Proxy :: Proxy ItemType`.
12:02:17 <mniip> Xe, I can't
12:02:19 <Xe> mniip: it actually uses https://hackage.haskell.org/package/markdown-unlit
12:02:23 <mniip> the issue is obviously somewhere inbetween
12:02:50 * hackagebot js-jquery 3.1.0 - Obtain minified jQuery code  https://hackage.haskell.org/package/js-jquery-3.1.0 (NeilMitchell)
12:02:51 <nmdanny> I think I saw proxys in servant, IIRC, it's a dummy value that is used to add type information, am i correct?
12:02:52 * hackagebot http-client 0.5.1 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.1 (MichaelSnoyman)
12:02:59 <dmwit> nmdanny: Does your `MonadItemStore` class really need the `item` parameter?
12:03:05 <mniip> Xe, haha
12:03:06 <mniip> tabs
12:03:17 <dmwit> nmdanny: (Is it actually possible to have a store which can only store certain types of items?)
12:03:29 <dmwit> nmdanny: You are correct.
12:03:31 <mniip> let is preceeded by two tabs, which is 16 spaces
12:03:44 <mniip> the code above is preceeded by 8 space
12:03:44 <mniip> s
12:04:05 <nmdanny> well I'm not sure about the naming, but my idea is
12:04:22 <nmdanny> I have a certain monad which has access to a database, which contains vectors of various things
12:04:48 <nmdanny> for example I have data Db = Db {  _weapons  :: Vector Weapon  , _people   :: Vector Person }
12:05:01 <nmdanny> and, im trying to use acid-state, so I defined the following instances
12:05:20 <nmdanny> instance MonadItemStore Weapon Vector (Update Db) , instance MonadItemStore Person Vector (Update Db)
12:06:04 <dmwit> Are you sure you don't just want `data Accessor m v = Accessor { getStore :: m v, putStore v -> m () }`?
12:06:09 <dmwit> or similar?
12:06:37 <dmwit> Like, are the `getStore` and `putStore` operations *really* type directed?
12:07:46 <nmdanny> well, the entire purpose of MonadItemStore, is to allow implementing functions such as vectorCrudGet and vectorCrudPost
12:07:47 <Profpatsch> mniip: My solution is foo ^. W.responseStatus & (^.statusCode) &&& (^.statusMessage)
12:08:10 <dmwit> nmdanny: And you still can.
12:08:25 <mniip> well that differs from your original question :)
12:08:28 <Profpatsch> That might be a bit too out there though. :P
12:08:45 <dmwit> nmdanny: vectorCrudGet :: Accessor m (Vector v) -> Int -> m (Maybe v)
12:09:11 <dmwit> nmdanny: Or perhaps even better `vectorIndex :: Int -> Accessor m (Vector v) -> Accessor m (Maybe v)`
12:09:22 <Profpatsch> mniip: Since I can’t combine the getters, I first generate the intermediate value and then construct a tuple on it with the two getters.
12:09:35 <mniip> I can see, yes
12:09:36 <dmwit> nmdanny: (Not sure about argument order of that last one. Maybe the flipped version would be better.)
12:11:50 <nmdanny> I'm not sure if I want Accessor as an ADT
12:12:25 <dmwit> Tell me more about your concerns.
12:12:34 <nmdanny> I already have a Db ADT (for acid-state), which I'm gonna have a transformer stack parameterized on
12:12:50 * hackagebot rainbox 0.18.0.10 - Two-dimensional box pretty printing, with colors  https://hackage.haskell.org/package/rainbox-0.18.0.10 (OmariNorman)
12:14:23 <platz> since http-client has changed it's api sligtly on version 0.5.0, what is the best practice for existing clients?  Include an upper bound 'http-client < 0.5.0' ?
12:15:07 <dmwit> nmdanny: Is that the entire content of your concern? If so, I'm not sure I understand it. Haskell makes new types cheap. It's common to make lots of them.
12:15:54 <dmwit> platz: That seems reasonable to me. Porting to the new API and putting a lower bound also seems reasonable.
12:16:06 <dmwit> platz: Honestly, you should already have had that upper bound, according to the PVP.
12:16:32 <platz> dmwit: yeah, I didn't realize the importance of having it before.  I do now though!
12:16:36 <EvanR> lots of newtypes are cheap... if you have the TH to autogenerate all their utility functions
12:16:51 <dmwit> EvanR: I said new types, not newtypes. =)
12:17:09 <EvanR> i was referring to "dumb" product of sums
12:17:13 <nmdanny> I'm not worried about creating new types, I just don't want to pass around additional parameters if not necessary
12:17:43 <dmwit> nmdanny: Type classes don't save you from that. They just make it syntactically quieter -- and also harder to choose which actual parameter you want to use.
12:18:04 <EvanR> parameters are nice... sometimes
12:18:11 <dmwit> nmdanny: e.g. if you have two "columns" that both have a `Person` in them, a typeclass won't be able to distinguish between them.
12:18:22 <dmwit> An explicit dictionary will.
12:18:29 <nmdanny> I guess you might have a point there, if I'll use type classes, I'll have to add type annotations, seeing as I want my "Db" to act both as a "Person" provider, and a "Weapon" provider etc etc
12:18:29 <maerwald> EvanR: must stuff ALL parameters into my monad stack!
12:18:34 <EvanR> it takes a lot for the extra parameters to be in the way
12:18:35 <maerwald> idomatic haskell!
12:19:36 <nmdanny> I guess I could try going with the accessor approach for creating generic CRUD functions,
12:20:01 <EvanR> lenses?
12:20:16 <dmwit> EvanR: There's too much monad in there for it to be a lens.
12:20:30 <nmdanny> and then make a bunch of one-line functions such as "getPeople" "getPerson" "setPerson" that delegate to my crud functions
12:20:47 <EvanR> oh... youve gone full imperative
12:21:06 <EvanR> godspeed
12:21:11 <nmdanny> me?
12:21:45 <EvanR> this doesnt seem like a case where haskell is going to be the best imperative language
12:23:53 <nmdanny> btw, does there already exist some library for CRUD operations? Preferablly something not tied to a specific database and without template haskell?
12:24:49 <umib0zu> Does anyone have experience with the Control.Category library? https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Category.html
12:25:04 <bobajett> /join# python
12:25:44 <EvanR> nmdanny: acid-state is a persistent database not using any rdbms, you are free to create as much CRUD as you want in whatever form you want, and you dont have to use TH, you can write out all the boilerplate yourself
12:25:47 <jle`> umib0zu: best to just ask your question :)
12:26:08 <nmdanny> I know, the whole point is that I don't want to create boilerplate
12:26:10 <umib0zu> jle` how do I implement a monoid using Control.Category?
12:26:14 <athan> Should I typecheck an argument before typechecking its operand?
12:26:17 <jle`> the people who are more likely to answer a question than to assert their confidence at being familiar with a module
12:26:24 <jle`> *are are
12:26:33 <EvanR> nmdanny: well, thats the only requirement i understand so far of your needs. what is CRUD anyway
12:27:08 <jle`> that is, [people who would answer a question on Control.Category] is a strictly larger subset than [people who would take their time to assert they are familiar in it], usually several times bigger :)
12:27:33 <lpaste> none pasted “Monoid??.hs” at http://lpaste.net/169405
12:27:39 <nmdanny> basically I have a monad(or an ADT) that provides access to lists of resources. such as Db { people :: [Person], cars :: [Car] }
12:27:41 <EvanR> nmdanny: do you want an interface to SQL databases?
12:27:48 <nmdanny> no no
12:27:52 <jle`> umib0zu: you can write a simple Monoid instance for something that's an instance of Control.Category by just using id as mempty and (.) as mappend
12:28:11 <umib0zu> jle` this was me by the way http://lpaste.net/169405
12:28:17 <EvanR> nmdanny: do you want on-disk persistence?
12:28:39 <nmdanny> so I have something that provides me with a collection of resources. I'd like to be able to index a resource from the list, add a resource, delete a resource, modify a resource. (Copy, Read, Update, Delete)
12:28:52 <EvanR> an indexed set?
12:28:54 <umib0zu> jle` I sort of want to create a Monoid from scratch though.
12:29:01 <nmdanny> no no, I'm not talking about the specific database representation
12:29:14 <nmdanny> i'm looking  for a way to reduce boilerplate
12:29:24 <jle`> umib0zu: fwiw, i don't think your type can have a Category instance
12:29:29 <EvanR> you want an indexed set of resources
12:29:33 <jle`> i'm almost certain it doesn't
12:29:35 <EvanR> which you can query and update
12:29:59 <nmdanny> yes
12:30:05 <EvanR> there is IxSet
12:30:07 <jle`> but yeah, you can always write a Monoid instance for any instance of Control.Category
12:30:13 <nmdanny> no I know,
12:30:18 <umib0zu> jle` likely. I’ve been trying to make a single object category for a few days now.
12:30:29 <nmdanny> the thing is, I would have several types(or tables, if speaking in RBDMS terminology)
12:30:32 <jle`> instance Category c => Monoid (c a a) where mempty = id; mappend = (.)   (with newtype wrappers)
12:30:37 <EvanR> well, it sounds like your actual program isnt written yet, so the final answer is no
12:30:46 <shachaf> The newtype wrapper is usually called Endo.
12:30:56 <dmwit> umib0zu: `data SingleObject a b = SingleObject; instance Category SingleObject where id = SingleObject; _ . _ = SingleObject`.
12:31:02 <shachaf> Well, I guess Haskell uses Endo for a special case of that.
12:31:15 <dmwit> Well, I guess that's actually a single arrow category.
12:31:23 <dmwit> So it's even stricter than just being a single object. =P
12:31:24 <shachaf> dmwit: That category has more than one object.
12:31:25 <umib0zu> dmwit ……
12:31:36 <dmwit> Also I am wrong.
12:31:58 <EvanR> nmdanny: multiple tables corresponds to multiple IxSets
12:31:59 <dmwit> Now that I understand the request, I don't think `Category` can support a single-object category.
12:32:19 <dmwit> `Category` demands that all objects of `Hask` be objects of your category as well.
12:32:32 <shachaf> It almost can, since it's polykinded.
12:32:35 <nmdanny> ok again, my problem is not representing the resouces in a database
12:32:50 * hackagebot fast-digits 0.2.1.0 - The fast library for integer-to-digits conversion.  https://hackage.haskell.org/package/fast-digits-0.2.1.0 (Bodigrim)
12:33:04 <EvanR> youre asking if there is a library with the particular ways you want to update a set exist already?
12:33:23 <EvanR> beyond create modify delete
12:33:47 <nmdanny> ok lets say I have the following ADTs: Car, Person, Toy, Item
12:34:04 <nmdanny> I have somewhere, in a database, a table of cars, persons, toys, items
12:34:25 <nmdanny> I want to make a simple restful server that will allow CRUD operations on any of those tables
12:34:26 <umib0zu> dmwit it’s just odd since the type signature for the typeclass looks like the A and B are the Source and Target
12:34:27 <dmwit> shachaf: Cute, it can.
12:34:32 <nmdanny> so, I would have to define the following functions
12:34:45 <nmdanny> getCar, postCar, putCar, deleteCar,      getPerson, postPerson, putPerson, deletePerson
12:34:45 <lpaste> dmwit annotated “Monoid??.hs” with “Monoid??.hs (annotation)” at http://lpaste.net/169405#a169406
12:34:46 <EvanR> so PHPMyAdmin
12:34:49 <nmdanny> yes
12:34:53 <EvanR> that exists
12:35:04 <dmwit> umib0zu: See annotation for an example of a single-object `Category` instance.
12:35:17 <dmwit> umib0zu: Of course you can make the RHS of `data SingleObject` more exciting if you want more arrows.
12:35:33 <umib0zu> ah ok
12:35:45 <umib0zu> so no I want to be able to define arrows
12:35:50 <umib0zu> dmwit ^^^
12:35:58 <umib0zu> not having a single arrow
12:36:15 <shachaf> dmwit: Except for issues with Any.
12:36:16 <umib0zu> and also logically, I think you’re saying f x f = f = id in this case
12:36:42 <umib0zu> like for example what if I want to implement a cyclical monoid
12:36:47 <lpaste> dmwit annotated “Monoid??.hs” with “turning a `Monoid` instance into a `Category` instance” at http://lpaste.net/169405#a169407
12:37:12 <dmwit> umib0zu: Yes, you can define arrows. Just because my `SingleObject` type only had one arrow doesn't mean yours has to. =)
12:37:25 <dmwit> umib0zu: e.g. in the annotation I show how to turn any `Monoid` instance into a `Category` instance.
12:37:43 <nmdanny> So I want something that is in essence, similar to an admin site, but not necessarily as a webserver, but rather as more general haskell functions that operate in a certain database monad
12:38:02 <EvanR> see, i almost understood that until the database monad
12:38:09 <nmdanny> so that I would not have to copy paste the same 5 functions for each of my ADTs/tables (getPerson,putPerson,postPerson,deletePerson)
12:38:42 <EvanR> you can abstract over those of course, haskell has polymorphism
12:38:48 <EvanR> if they are literally doing the same thing
12:38:54 <nmdanny> yes, that is what I've been trying to do
12:39:17 <nmdanny> but I keep getting into problems
12:39:22 <EvanR> requiring that you name 5 things getPerson getWhatever etc is kind of a deal breaker though
12:39:25 <EvanR> sounds impossible
12:39:50 <dmwit> nmdanny: Why would you define `getPerson`, `getWeapon`, etc. when you can just use `get person` and `get weapon` at no extra cost in keystrokes?
12:40:21 <nmdanny> dmwit, is that your accessor approach? 
12:40:24 <dmwit> yes
12:40:26 <EvanR> get :: Noun a -> ID a -> a might work better
12:40:36 <EvanR> or -> Maybe a
12:40:47 <dmwit> nmdanny: Forgive me, I haven't been following along. Was there a good reason to dislike accessors?
12:41:16 <nmdanny> I still haven't looked into them in depth
12:41:32 <nmdanny> but anyway it just feels that whatever I'm trying to implement should already exist somewhere
12:41:50 <EvanR> thats why rails exist, and it still doesnt
12:42:16 <EvanR> you still need to write boilerplate, of course it comes with scripts to generate boilerplate
12:43:01 <EvanR> in real life i think the issue becomes that no one actually wants to give full access to a bunch of tables
12:43:29 <EvanR> they want to provide some interface on top of tables, existing already or not, that is censored for public consumption and safety
12:43:42 <nmdanny> yes, that is also a thing that I've been wondering about
12:43:51 <EvanR> thats a non trivial thing for something to already exist for
12:44:42 <EvanR> but if you do, then you can have one endpoint which is "post SQL here" and it runs it ;)
12:44:49 <EvanR> done
12:45:17 <EvanR> sounds stupid, but many PHP systems basically beat around the bush to basically do that
12:45:52 <nmdanny> Lets say I have two layers: a database layer, and a server layer
12:46:16 <nmdanny> in the database layer, I would define those CRUD functions for each datatype/table, no problem since I still haven't exposed those functions to users
12:46:33 <EvanR> why for each one?
12:47:21 <nmdanny> well not necesarily the same functions duplicated, but my idea is that they'll work for all those datatypes/tables,
12:47:43 <nmdanny> but essentially the database layer would have a bunch of haskell functions which performs standard queries/updates (CRUD)
12:48:39 <nmdanny> and in the server layer, I would have handlers that would deal with authorization/authentication, and would be composed of those CRUD functions
12:49:02 <EvanR> until its too slow to support the api, and you need more specialized "CRUD" procedures
12:49:13 <EvanR> and circle of life is complete
12:49:28 <umib0zu> dmwit dude datakinds
12:49:31 <nmdanny> yes, obviously I will create more complex functions/handlers that use joins etc and the CRUD procedures won't suffice
12:49:47 <EvanR> sounds good. are you using servant?
12:50:14 <nmdanny> I will once I finish with setting up acid-state and the needed boilerplate (which i'm hoping to minimize)
12:52:16 <nmdanny> btw, an issue specifc to acid-state, I'm not sure if the accessor method would work since I need to run a TH function, $(deriveSafeCopy ...), which needs functions that operate in a specific Query/Update monad
12:52:51 * hackagebot tsvsql 0.2.1.0 - Template tsv into SQL  https://hackage.haskell.org/package/tsvsql-0.2.1.0 (DanielChoi)
12:53:18 <nmdanny> though I could just create a bunch of concrete functions that delegate to my generic functions, no biggie, it'll still cut down on most boilerplate
12:53:40 <umib0zu> I think I understand now. The cat A B signature in my head represents an arrow. And I wanted A and B to be objects in the category.
12:54:02 <EvanR> if your database is Map String (IntMap (Map String DynVal)) then there would only be 1 of each CRUD operation
12:55:04 <nmdanny> what is DynVal?
12:55:15 <EvanR> a sum type for any primitive value you can store
12:55:35 <EvanR> welcome to NoSQL
12:55:52 <nmdanny> oh so basically a dynamically typed value
12:56:05 <dmwit> Why are you recommending this?
12:56:19 <nmdanny> I think he's being sarcastic?
12:56:25 <EvanR> im taking nmdanny boilerplate requirements seriously
12:56:35 <EvanR> hes trying to avoid TH
12:57:10 <dmwit> I think nmdanny would be done with the boilerplate by now if he made a vim macro instead of overthinking things too much.
12:57:47 <EvanR> yeah, for the purposes of this 4 table REST CRUD thing, you can be done with it pretty fast by using sqlite-simple
12:57:58 <EvanR> and just writing the code
12:59:58 <Rotaerk> hamishmack, hmm, https://hackage.haskell.org/package/ghcjs-dom  doesn't have the documentation
13:00:12 <Rotaerk> I see that you split out some stuff into ghcjs-dom-webkit, but I'm not sure what stuff remains
13:02:06 <nmdanny> ok, another question
13:03:49 <nmdanny> if I want to support updating a variable amount of fields of an ADT/table row, for my RESTful api, is there a proven solution/way to doing so?
13:05:36 <Rotaerk> nmdanny, do a POST and put all the stuff you want to update into the body according to whatever format you're using?
13:05:53 <nmdanny> yes
13:06:19 <nmdanny> so how would I represent this with my haskell functions and types,
13:06:35 <dmwit> ETOOVAGUE
13:06:53 <nmdanny> for example I have the type: Person { personName :: Text, personDob :: UTCTime, personEmail :: Text, etc.. }
13:07:15 <nmdanny> lets say I have , Person1 = Person "Daniel Kb" "1/1/1997" "danny@email.com"
13:07:23 <nmdanny> and, I want to update the DOB field
13:07:47 <nmdanny> now, of course, I could just pass the same object with the DOB field changed, using my database update function
13:08:09 <nmdanny> but, I would rather only pass the specific fields that I intend to change
13:08:51 <nmdanny> e.g,    updatePerson Person1 [PersonDob "1/1/1900"] , would update the PersonDob field of Person1
13:09:32 <dmwit> person1 { personDOB = "1/1/1900" } -- this is literally built-in syntax
13:10:23 <nmdanny> yes, except that I want to do this in a REST handler
13:10:35 <dmwit> I don't see why a REST handler should be restricted from using this syntax.
13:10:44 <nmdanny> basically some way to serialize/deserialize the specific field to/from JSON
13:10:59 <dmwit> We have aeson for handling JSON.
13:11:00 <nmdanny> and, preferablly, without having to write too much boilerplate
13:11:06 <dmwit> ?hackage aeson
13:11:06 <lambdabot> http://hackage.haskell.org/package/aeson
13:11:39 <Rotaerk> is there some way for me to cause documentation on hackage to be generated for a package? or is that strictly up to the maintainer
13:11:57 <Rotaerk> e.g. https://hackage.haskell.org/package/ghcjs-dom
13:12:07 <Rotaerk> if I go back a couple versions I see some documentation...
13:12:11 <dmwit> You have to contact or become a Hackage trustee.
13:12:17 <Rotaerk> k
13:12:32 <dmwit> I think glguy recently became a trustee with the express purpose of being a point of contact for kicking off documentation generation, you might ping him.
13:12:40 <kadoban> It's broken like, all the time unfortunately. If it's also something that's on stackage, that tends to be more reliable.
13:12:54 <Rotaerk> hmm, I'll check stackage for this
13:13:27 <Rotaerk> that just redirects to hackage
13:13:34 <nmdanny> could it be that what I'm looking for is related to form validation/digestive-functors?
13:15:14 <Rotaerk> oh I see what happened; he didn't just move *some* of ghcjs-dom into ghcjs-dom-webkit, it looks like it's all been moved
13:15:36 <Rotaerk> this may be a way to loosen the dependency on webkit, so that he can move away from it
13:22:51 * hackagebot pinboard 0.9.7 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.9.7 (jonschoning)
13:23:34 <EvanR> kadoban: hackage docs not being built, this must be a one character bug in a job script somewhere
13:35:23 <Rotaerk> huh, seems adding webkitgtk3 to my stack cabal file isn't working
13:36:20 <Rotaerk> wait, maybe that's just me forgetting how to use stack...
13:36:25 <kadoban> Rotaerk: I seem to remember it being somewhat difficult to get the OS libraries needed installed for that.
13:41:33 <nmdanny> :pl
13:41:35 <nmdanny> :pf
13:45:06 <ph88^> hi guys
13:46:22 <ontop> I have a State monad. And I want to collect a list of the values it outputs up until some predicate fails. Sort of: while state looks like X, runState and append it's output to list.
13:46:42 <ontop> Any awesome ideas? I thought about whileM... maybe? :|
13:46:53 <ph88^> anyone know why this mapM_ just works on one item?  https://paste.fedoraproject.org/389228/68375146/  it's from megaparsec
13:48:49 <athan> Anyone here use Earley? I seems like `many` is basically `many1`
13:50:39 * athan may just use parsec :(
13:50:59 <athan> Wait, isn't there a successor to parsec now? Like a parsec++ :P
13:51:15 <athan> I just really need backtracking
13:53:09 <Rotaerk> bleh, stack setup is failing, for a fresh stack project
13:53:35 <Gurkenglas> ontop, Control.Monad.Loops does that, but if you'll make the failure a part of the monad (by using StateT S Maybe, usually), you can use Alternative's many
13:53:49 <Gurkenglas> (which I find more idiomatic, as it isnt prone to boolean blindness)
13:53:58 <ontop> Alterative?
13:54:02 <ontop> +n
13:54:28 <ontop> As soon as I look at StateT my eyes cross.
13:54:35 <ontop> I don't know Monad transformers :(
13:54:53 <Gurkenglas> > Just 2 <|> Nothing
13:54:57 <lambdabot>  Just 2
13:54:59 <Gurkenglas> > Just 2 <|> Just 3
13:55:01 <lambdabot>  Just 2
13:55:11 <Gurkenglas> > Nothing <|> Nothing
13:55:12 <lambdabot>  Nothing
13:55:26 <Gurkenglas> > manyLazy Nothing
13:55:29 <lambdabot>  Identity []
13:55:34 <Gurkenglas> > manyLazy $ Just 2
13:55:36 <lambdabot>  Identity [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
13:56:25 <Gurkenglas> (That should say many, but many is strict and so runs into an infinite loop when trying to work with infinite lists, so I made manyLazy, and I also made it say in the type that the output is not a fail)
13:56:53 <Clint> :t manyLazy
13:56:55 <lambdabot> PointedAlternative f g => f a -> g [a]
13:57:04 <Gurkenglas> http://lpaste.net/150858
13:57:22 <hexagoxel> ph88^: the most likely reason is that there is only one item in that NonEmpty. The least likely reason is that `mapM_` is broken. try printing length of NonEmpty.
13:59:00 <Gurkenglas> > (`runStateT` [1,2,3]) $ StateT uncons
13:59:03 <lambdabot>  Just (1,[2,3])
13:59:06 <Gurkenglas> > (`runStateT` [1,2,3]) $ many $ StateT uncons
13:59:09 <lambdabot>  Just ([1,2,3],[])
13:59:30 <Gurkenglas> > (`runStateT` [1,2,3]) $ manyLazy $ StateT uncons
13:59:32 <lambdabot>  Identity ([1,2,3],[])
13:59:38 <Gurkenglas> > (`runStateT` [1..]) $ many $ StateT uncons
13:59:40 <lambdabot>  *Exception: stack overflow
13:59:46 <Gurkenglas> > (`runStateT` [1..]) $ manyLazy $ StateT uncons
13:59:48 <lambdabot>  Identity ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
13:59:58 <ontop> Gurkenglas: I'm reading up on Monad Transformers etc now so I can try and figure out what a StateT can do for me.
14:00:15 <ph88^> hexagoxel, you are right .. it's length is only one. That's strange because there are 2 errors in the input for the parser .. do you have any idea why i'm not getting a list of two items ?
14:01:22 <ph88^> hexagoxel, i have to go, thank you for help :)
14:01:26 <Gurkenglas> ontop, here's drawings I made to compare how Maybe, State S and StateT S Maybe implement sequence: http://sketchtoy.com/66039859 http://sketchtoy.com/66039843 http://sketchtoy.com/66462297
14:01:38 <athan> mer, why isn't ParsecT an MFunctor?
14:02:17 <athan> (imo mmorph should be in base :x)
14:04:35 <hexagoxel> so mmorph could not be updated without updating the compiler?
14:05:08 <ontop> Gurkenglas: I'm starting to understand what you're on about. And it makes sense. I also think that maybe monad-loops will be best here. My state has a list in it, the only "stop" condition is when it's empty.
14:05:25 <ontop> And so I don't know if complicating things with the StateT + Maybe would be advantageous or just overcomplicated.
14:05:37 <Gurkenglas> ontop, does each step remove one element from the list?
14:05:41 <ontop> Yes.
14:05:51 <ontop> It's kind of a map with state.
14:05:57 <ontop> with a state machine*
14:06:02 <Gurkenglas> then you just want traverse
14:06:28 <Gurkenglas> (which works just like the second drawing)
14:07:12 <ontop> https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Traversable.html
14:07:14 <ontop> This stuff?
14:07:18 <Gurkenglas> ya
14:07:32 <ontop> Hmm. I will look into it. Going to have to take remembering applicatives to figure it out.
14:07:34 <ontop> Thanks for the hint :)
14:08:14 <Gurkenglas> (In this case the type of traverse will be "(a -> State S b) -> [a] -> State S [b]")
14:08:59 <Gurkenglas> Or if the only reason you would be using the State monad is this combination, you can use mapAccumL instead.
14:09:02 <Gurkenglas> :t mapAccumL
14:09:04 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
14:09:16 <Gurkenglas> (Imagine t as [].)
14:09:51 <ontop> [] or [].
14:09:59 <ontop> For some reason I feel like there's the possibility of an insane distinction there
14:10:10 <Gurkenglas> "[]", which turns "a" into "[a]"
14:10:15 <ontop> Okay yeah.
14:10:17 <ontop> Gotcha.
14:10:31 <ontop> Gotta run for a sec, will come back and dig in more. Thanks so much for your patience. Being new is hard :D
14:10:46 <Gurkenglas> (Yes, the argument order and the tuple order of mapAccumL are the wrong way round. Apparently it's too late to change that now?)
14:11:19 <Rotaerk> anyone here having trouble getting stack setup to work in arch linux now?
14:12:00 <Rotaerk> it's complaining about libtinfo.so.5 not existing; I even wiped out my ~/.stack, and re-ran stack setup, and same error
14:15:15 <geekosaur> ncurses-compat5
14:17:54 <geekosaur> sorry, ncurses5-compat-libs, in aur. arch is continuing its "what is backward compatibility?" thing full steam, so people are working around it
14:18:02 <Rotaerk> ah k
14:18:03 <Rotaerk> thanks
14:18:11 <geekosaur> presumably at some point stack will need to be built against ncurses6
14:18:46 <Rotaerk> I don't see *any* version of libtinfo... pacman -Fs libtinfo  returns nothing
14:19:01 <Rotaerk> figured it'd be version 6, but it's completely absent
14:19:10 <geekosaur> maybe they decided to merge it
14:19:20 <geekosaur> it can be built separate, or as part of libncurses
14:19:39 <Rotaerk> ah
14:19:40 <geekosaur> I've never understood the rules by which different distributions decide which to do...
14:20:43 <geekosaur> (also I'm kinda from the System V world where terminfo was always rolled into curses, not a separate lib, so the separate one always initially strikes me as weird...)
14:21:00 <Iceland_jack> ghci> :t mapAccumL @[]
14:21:00 <Iceland_jack> mapAccumL @[] :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
14:21:41 * nshepperd_ just symlinked libtinfo.so.5 to libncursesw.so.6
14:21:50 <nshepperd_> it hasn't exploded in fire yet...
14:22:09 <geekosaur> right, so they folded it in SysV-style
14:22:21 <itnex> is mankind divided going to be good?
14:22:32 <Welkin> itnex: brexit?
14:22:35 <Welkin> who needs britain?
14:22:35 <itnex> no
14:22:39 <itnex> the new deus ex game
14:22:45 <Welkin> hahaha
14:22:48 <itnex> human revolution was excellent
14:22:52 <itnex> in my opinion
14:22:52 <Welkin> dunno
14:22:55 <itnex> i really loved it
14:22:58 <itnex> espec the biochip part
14:23:00 <Welkin> I loved the soundtrack to human revolution
14:23:13 <nshepperd_> yeah there's a libtinfo-6 in aur that is just a symlink to ncurses
14:23:25 <itnex> me2
14:23:30 <itnex> missing link was nice too
14:24:03 <itnex> anyway
14:24:07 <itnex> i must now leave
14:25:38 <daey> is compiled haskell code worse than c code? if i understand c orrectly ghc converts haskell to c-code first?
14:25:48 <Welkin> no
14:25:51 <Welkin> it doesn't
14:25:59 <Welkin> there are many stages in the ocmpilation
14:26:02 <Welkin> compilation*
14:26:10 <Welkin> one of the last stages I believe is C--
14:26:17 <Welkin> which was invented specially for this compiler
14:26:46 <athan> daey: http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf >.>
14:26:46 <EvanR> something like haskell code -> core code -> c-- code -> machine code
14:26:54 <monochrom> 10 years ago GHC compiled Haskell to C. Almost. (After gcc turns C into asm, some modification of the asm was done.)
14:27:21 <daey> i see. i guess ive got that info from an old source then
14:27:40 <monochrom> But the nature of believe the Internet is such that outdated history is enshrined as today's facts.
14:27:49 <monochrom> s/believe/believing/
14:28:04 <Welkin> daey: haskell changes rapidly
14:28:05 <quchen_> Here’s the GHC compiler pipeline in a picture: https://ghc.haskell.org/trac/ghc/attachment/wiki/Commentary/Compiler/HscPipe/HscPipe2.png
14:28:20 <quchen_> Haskell changes extremely slowly, GHC changes quickly.
14:28:20 <maerwald> Welkin: not at all
14:29:26 <Welkin> yes, that is what I meant to say
14:30:04 <monochrom> http://www.vex.net/~trebla/humour/lmcify.html?t=People+in+Egypt+still+write+and+read+on+papayrus+scrolls
14:30:18 * EvanR goes to get coffee rapidly
14:36:50 <athan> cofree coffee injestion
14:37:50 <monochrom> mathematicians turn coffee in theorems. category theories turn theorems into cofree theorems.
14:38:03 <monochrom> s/theories/theorists/
14:38:54 <cobreadmonster> Hmm
14:40:33 <homer_sampson> man
14:40:47 <homer_sampson> this haskell-lang thing is bringing out the best in everyone!
14:40:47 <EvanR> shucks
14:40:52 <Welkin> haha
14:40:58 <Welkin> haskell reddit drama?
14:41:23 <Welkin> I haven't seen that for ages
14:41:26 <EvanR> is haskell reddit anything like #haskell ?
14:41:28 <Welkin> I ignore it
14:41:33 <Welkin> EvanR: no
14:41:35 <homer_sampson> EvanR #haskell is nicer
14:41:39 <Welkin> it is just people complaining about everything
14:41:46 <Clint> so it's more like reddit
14:41:52 <homer_sampson> well i think it's down to one conflict really
14:41:54 <Welkin> and flamewars over libraries
14:42:08 <homer_sampson> cabal cabal and fpc not getting along basically
14:42:10 <monochrom> sorry, what is "this haskell-lang thing"?
14:42:19 <homer_sampson> and a bunch of suspicious sockpuppets fighting
14:42:25 <Welkin> some new website and subreddit called haskell-lang
14:42:36 <homer_sampson> https://haskell-lang.org/
14:42:37 <monochrom> thanks
14:43:20 <Welkin> it is worse than I thought
14:43:28 <Welkin> another split in the community...
14:43:36 <homer_sampson> welkin another?
14:43:53 <Welkin> homer_sampson: it happens pretty often
14:43:54 <EvanR> would you prefer if everyone agreed with you?
14:44:00 <homer_sampson> it's not all bad though. there's something to be said for some competition and new ideas.
14:44:07 <hexagoxel> is there any reliable information about the size of the "sides" of this "split"?
14:44:33 <homer_sampson> hexagoxel yeah there was a good summary in one of the threads
14:44:34 <Hijiri> is the split over the website design?
14:44:48 <Welkin> it is very small
14:44:49 <Welkin> https://haskell-lang.org/announcements
14:44:55 <Welkin> but it includes some well known people
14:45:01 <homer_sampson> hijiri sort of. it's over download links and how much haskell platform / cabal sucks...
14:45:01 <Welkin> Hijiri: probably?
14:45:07 <EvanR> heh the w3schools of haskell
14:45:16 <Berra> Is there any sane reason as to why Data.String has a basically a partial of split (lines) but not an actual split?
14:45:35 <Welkin> Berra: use Data.List.Split
14:45:47 <homer_sampson> hexagoxel: top post in this thread sums it up decently
14:45:49 <homer_sampson> https://www.reddit.com/r/haskell/comments/4rv8cj/can_somebody_please_clarify_this_haskellorg/
14:45:56 <Welkin> Berra: http://hackage.haskell.org/package/split-0.2.3.1/docs/Data-List-Split.html
14:46:18 <sm> that's a terrible thread.. see https://www.reddit.com/r/haskell/comments/4ruqbl/new_haskell_community_nexus_site_launched/ instead
14:46:23 <Berra> Welkin: Not in base
14:46:28 <homer_sampson> berra but really you should be using text :P
14:46:29 <hexagoxel> homer_sampson: that does not give any clear indication of the size of this "split"
14:46:37 <Berra> homer_sampson: Also not in base
14:46:40 <EvanR> :t splitOn -- might be nice to have in base
14:46:41 <lambdabot> Eq a => [a] -> [a] -> [[a]]
14:46:54 <homer_sampson> berra why do you have to use only base?
14:47:12 <EvanR> > splitOn "," "fruit,pizza,shoes"
14:47:14 <lambdabot>  ["fruit","pizza","shoes"]
14:47:17 <Berra> homer_sampson: I was asking as to the reasoning why there is a partial of a split function (lines) in base but not an actual split.
14:47:58 <Welkin> Berra: yes, it is not in base, so you install it
14:48:01 <homer_sampson> hexagoxel i think it's basically cabal devs on one side and fp complete + chris on the other . and a bunch of sock puppets
14:48:22 <Berra> Welkin: I don't think you understand my question.
14:48:32 <EvanR> Berra: there are a lot of things not in prelude... theres an alternative prelude lifestyle choice you could make
14:49:20 <geekosaur> Berra, the base system is not intended to be all-inclusive; in fact it's as small as possible and they shed new bits into the ecosystem when they can.
14:49:20 <Berra> EvanR: It would be one thing if there was no split AND no lines. But that lines exist but not split just makes me question the sanity of the one who wrote Date.String / Data.List
14:49:21 <Welkin> Berra: I do
14:49:25 <Welkin> there is no answer to your question
14:49:32 <Welkin> that is just how it is
14:49:39 <EvanR> Berra: lines actually isnt like splitOn 
14:49:50 <Berra> lines = split '\n'
14:49:56 <EvanR> > lines "abc\r\n123\nhmm"
14:49:58 <lambdabot>  ["abc\r","123","hmm"]
14:49:59 <hexagoxel> homer_sampson: right. but i have my doubts that fp complete + some few represent any relevant portion of the global haskell community.
14:50:02 <geekosaur> "lines" is still in the Prelude because the language report from years ago says it should be there
14:50:07 <EvanR> ;_;
14:50:31 <Berra> geekosaur: Yes but please couldn't they have just defined it as lines = split '\n'
14:50:56 <geekosaur> you still assume that the Prelude must be a full blown batteries included setup
14:50:59 <homer_sampson> hexagoxel well no "few" people can claim to represent the global haskell community.
14:51:01 <Welkin> I don't understand the drama from fpcomplete and co
14:51:04 <geekosaur> [09 21:48] <geekosaur> Berra, the base system is not intended to be all-inclusive; in fact it's as small as possible and they shed new bits into the ecosystem when they can.
14:51:05 <Welkin> install haskell however you want
14:51:19 <Welkin> use cabal-install, or stack, or haskell platform
14:51:30 <homer_sampson> welkin the issue is really aimed at new adopters
14:51:36 <geekosaur> they're not going to pull Data.List.SPlit into the base just to define "lines"
14:51:42 <homer_sampson> and how not to scare them away. small choices can have a big effect
14:51:44 <Welkin> lol geekosaur 
14:52:04 <homer_sampson> i came about this -> <- close to quitting because haskell platform did suck.
14:52:09 <hexagoxel> and unless there are some clear numbers indicating otherwise, i will assume there is no "split" at all, but file this as a marketing stunt instead. and ignore it.
14:52:14 <EvanR> haskell-lang seems like a "enterprise haskell integration" move, which im angry i didnt invent
14:52:21 <EvanR> wait i still can
14:52:22 <Berra> It's not like it makes the prelude bigger to define swap \
14:52:43 <Berra> '\n' to an argument then on the next line define lines as  split '\n'
14:52:47 * geekosaur is actually not happy with this arrangement, a standard install should really include a reasonable set of libraries. but Teh Community beliuves Haskell Platofrm is and forever will be Satan himself, and thinks nickel-and-diming newcomers to death is The Best Idea Ever
14:52:50 <geekosaur> so be it.
14:52:54 <homer_sampson> no one (fpc or otherwise) is trying to market it as a split, some people are just calling it that.
14:53:03 <EvanR> Berra: many other problems like this you could have separately would all be solved at once with alternative preludes
14:53:49 <Berra> https://wiki.haskell.org/The_Other_Prelude
14:54:05 <Berra> I get that, but isn't what I asked really.
14:54:17 <EvanR> TheOtherPrelude... no
14:54:20 <Berra> I was questioning the reasoning for having a hard coded partial in the prelude.
14:54:35 <sm> Berra: no reasoning. Simply how it happened.
14:54:41 <homer_sampson> Berra lots of prelude choices are not so good
14:54:41 <sm> can we move on ? :)
14:54:49 <Berra> sm: Yes. It was stupid. The end.
14:54:49 <EvanR> The Other Prelude is just the same issue as before, someone will hate it
14:54:50 <homer_sampson> it's really not the greatest thing about haskell
14:55:06 <homer_sampson> EvanR i'm curious how jump or whatever it's called will look
14:55:16 <hexagoxel> homer_sampson: i meant marketing by making a separate website, no matter what they call it or how the explain their intentions.
14:55:19 <homer_sampson> i wish subhask had taken off a bit more. need better numerics
14:55:34 <EvanR> if anything we need a cheatsheet for how to get the most common stuff with the standard setup
14:55:56 <EvanR> and maybe a blurb about how to install a custom prelude, in lieu of a blurb on how to create a new programming language to solve this one issue
14:55:58 <sm> homer_sampson: agreed, I expect it will be excellent
14:56:46 <homer_sampson> hexagoxel imo people should do whatever they want. i don't see the big deal. and like i said, i personally had a bad beginner experience with "the wrong download" so i understand where they're coming from.
14:57:11 <EvanR> and a blurb on how to install idris where the choices havent been finalized yet, so youre free to screw up that decision yourself!
14:57:15 <homer_sampson> i don't see why anyone should need to get permission from hvr or someone to do so.
14:57:44 <homer_sampson> EvanR isn't that what haskelliseasy.com is?
14:57:49 <hexagoxel> homer_sampson: the issue is not that or what they try to improve, but how they try to cooperate with the rest of the community.
14:58:27 <Squarism> is there some nice way of making a tuple3 -> tuple4.. ie prepending or appending a "dimension"?
14:58:45 <homer_sampson> hexagoxel i don't see how cooperate with the rest of the community means they need to ask permission to put up a website.
14:58:57 <EvanR> append (x,y,z) w = (x,y,z,w) ;)
14:59:02 <EvanR> pretty nice
14:59:06 <Welkin> Berra: no one who uses haskell seriously cares about prelude
14:59:25 <EvanR> no true seriously haskell user
14:59:25 <Welkin> prelude just re-exports other modules
14:59:26 <homer_sampson> welkin agree. it is unfortunate for beginners though.
14:59:45 <sm> Welkin: quite untrue, I am sick of having to import things over and over
14:59:45 <Welkin> there is also classy-prelude, if you like
14:59:52 <Squarism> EvanR, id hoped there was like a 2 sympbol max version 
14:59:57 <Berra> EvanR: Fair enough
15:00:04 <EvanR> Welkin: and protolude, and foolude, and...
15:00:10 <hexagoxel> homer_sampson: don't frame what i say that way, please. i said cooperation, which is far from "asking for permission".
15:00:13 <Squarism> \?$ ... for readability
15:00:24 <anon1> Hello everyone. I want to dive into haskell and I don't have many experience with it. Is learnyouahaskel.com a good way of learning the language?
15:00:47 <EvanR> Squarism: thats more readable?
15:00:51 <homer_sampson> hexagoxel well what should they have done? to comply with "cooperating with the community"
15:01:10 <homer_sampson> fwiw the "few" people who run haskell.org don't represent the community either.
15:01:16 <EvanR> > (\(x,y,z) w -> (x,y,z,w)) (1,2,3) '4'
15:01:18 <sm> anon1: sure. It's considered a good read, but short of exercises
15:01:18 <lambdabot>  (1,2,3,'4')
15:01:26 <EvanR> maybe you meant more easily typed in
15:01:46 <Welkin> I started on haskell-platform and has no issues, because I soon learned how to use cabal-install and then moved on to installing ghc from the binary distribution instead. Then when stack came out I started using that too.
15:01:55 <Welkin> had*
15:02:15 <Squarism> EvanR, i hoped i could make a tuple generic function but the mor i think about it that is a dumb idea
15:02:26 <Welkin> @where learnhaskell -- anon1 use this
15:02:26 <lambdabot> https://github.com/bitemyapp/learnhaskell
15:02:33 <EvanR> Squarism: well you can do this
15:02:55 <sm> anon1: http://tryhaskell.org is a good practical start, as is http://schoolofhaskell.com, and see https://www.haskell.org/documentation for the rest
15:03:01 <hexagoxel> homer_sampson: bring up the topic "official website" on any official haskell mailing list, for example.
15:03:08 <hexagoxel> or have i missed something like that?
15:03:09 <EvanR> > (,) 3 (1,2)
15:03:11 <lambdabot>  (3,(1,2))
15:03:22 <anon1> sm: I'd rather learn trying to write my own programs, as oposed to exercises anyway
15:03:23 <EvanR> > (,) 4 (3,(1,2))
15:03:25 <lambdabot>  (4,(3,(1,2)))
15:03:28 <EvanR> (,) is generic
15:03:37 <sm> anon1: I liked project euler for that
15:03:53 <sm> oh, unless that's exercises too
15:03:58 <Welkin> lol
15:04:06 <hexagoxel> (or is the "official mailing list" not official either? at that point the argument would dead-end in a discussion what is "official"..)
15:04:25 <mirpa> hexagoxel: they don't sell it as "official haskell website", do they?
15:04:30 <EvanR> Squarism: (3-tuples and bigger are literally represented like this in idris so its easier but... anyway you can do it)
15:04:34 <homer_sampson> anon1 will concur, learn you a haskell is a trap for beginners. it's not a good place to start.
15:04:50 <Welkin> LYAH is a fun book to read though
15:04:52 <homer_sampson> anon1 if you want to save time, i suggest starting with haskellbook.com
15:04:56 <Welkin> just don't use it as your only resource
15:05:01 <anon1> homer_sampson: why is that?
15:05:25 <homer_sampson> anon1 because the padagogical style is basically "type what i type", which fools you into thinking you know what you're doing
15:05:26 <hexagoxel> i don't care how they call/sell it. it looks exactly like haskell.org, which is the defacto official site.
15:05:34 <Squarism> EvanR, yeah.. it was (,) that inspired me to this trial. Well thanks for letting me know what is possible!
15:05:36 <homer_sampson> then when you start a real project, you get stuck
15:05:38 <sm> homer_sampson: it's considered one of the best and certainly most thorough intro books. But you have to buy it
15:05:49 <sm> (anon1, I mean)
15:06:12 <Welkin> hexagoxel: yeah... this looks bad for the whole community to have two identical websites run by different people, both claiming to be "the official haskell website"
15:06:29 <Welkin> although haskell.org has more authority just by the name alone
15:06:34 <homer_sampson> hexagoxel that's partially because haskell.org used chris done's layout. if they don't like that they should make a new one that's different.
15:07:16 <EvanR> is this topic ridiculous?
15:07:21 <anon1> homer_sampson: that's 59$, do you think it's really worth it for a tutorial?
15:07:22 <homer_sampson> sm yes but imo it's worth the time saved.
15:07:29 <homer_sampson> anon1 let me put it this way
15:07:47 <EvanR> $59? buy a real haskell book
15:07:54 <homer_sampson> anon1 i would credit the book with accelerating my haskell ability by about 1-2 years
15:07:57 <sm> it's also not finished..
15:08:19 <homer_sampson> anon1 do you think saving 1-2 years of time is worth 59$? i do
15:08:41 <Welkin> lol sm 
15:08:44 <sm> (in final editing. Almost there!)
15:08:59 <homer_sampson> yeah it's practically finished
15:09:10 <homer_sampson> by the time you finish reading th 1500 pages it will be anyway :P
15:09:19 <hexagoxel> homer_sampson: it goes beyond using the same design. the contents / effective goals of the two sides are identical. they try to be the frontpage for anyone googling "haskell language", looking for general information and beginner introductions.
15:09:30 <sm> if I'm going to read 1500 pages I'm going to wait and read the edited version :)
15:09:33 <hexagoxel> s/two sides/two sites/
15:10:09 <hexagoxel> if you call that "official website" or not does not matter at all.
15:10:27 <EvanR> will everyone be happy when the look and content of the site diverge?
15:10:34 <Welkin> EvanR: no
15:10:38 <maerwald> this all just sounds like uncollaborative behavior
15:10:41 <homer_sampson> hexagoxel it'd be great to have one perfect resource, but absent that i'd rather have diversity than monoculture. besides there are lots of google destinations which i think are detrimental
15:10:43 <sm> hexagoxel: have you read the comments from the site's builders, or not ?
15:10:45 <homer_sampson> such as learn you a haskell
15:11:01 <homer_sampson> but i don't feel entitled to tell learn you a haskell to take down their site for the good of the community
15:11:20 <hexagoxel> sm: potentially. don't know what you mean specifically.
15:12:02 <sm> on the big reddit thread eg. It sounds like maybe you haven't
15:12:03 <hpc> fwiw, LYAH looks really good if you put it next to the wiki
15:12:15 <Welkin> there is so much drama that most people don't even know exists on the haskell reddit and on twitter
15:12:17 <Welkin> haha
15:12:33 <Welkin> I have peeked in once or twice at the 300+ tweet threads on twitter
15:12:35 <Welkin> hilariously bad
15:13:46 <hexagoxel> sm: i have read that. does not give me sufficient reason to revoke my criticism regarding cooperation.
15:15:06 <homer_sampson> hexagoxel i don't think we're going to agree, but there are limits to working by committee, esp when some members of the committee have the final say and others don't.
15:18:29 <hexagoxel> but committee /= community. and "there are limits .." is a weak argument anyways.
15:20:04 <homer_sampson> if your preference isn't for the two sides to cooperate on contributing to haskell.org, then i don't understand what you would want them to do. we'll just leave it at that.
15:21:02 <tnks> I wonder whether people meet face-to-face enough to resolve these problems.
15:21:04 <Gurkenglas> The sense that splitting the tribe is detrimental regardless of the reasons is a heuristic suited to the ancestral environment. It might or might not apply today, but we aren't going to find out which by stating how strongly evolution has instilled that sense in each of us.
15:21:23 <tnks> so many people involved in these differences are so awesomely nice face-to-face.
15:21:45 <tnks> I mean specifically in the Haskell community around this specific issue.
15:22:09 <sm> tnks: that's true, we might be in need of a bigger conference (like pycon) ?
15:22:32 <homer_sampson> tnks i think people might be more polite in person, but sometimes conflicts of interests are just that.
15:22:33 <Gurkenglas> tnks, that would also not help with finding out whether we should cooperate - it might only make us want to cooperate
15:22:50 <tnks> Gurkenglas: that's a start.
15:23:09 <homer_sampson> sm that would be interesting to have a pycon. it seems like haskell gets subsumed by the various FP conferences
15:23:15 <Gurkenglas> thats a start towards cooperation. we should start with finding out whether cooperation is the correct goal.
15:23:28 <sm> haskcon
15:23:42 <tnks> there's a ton is Hacks.
15:23:44 <homer_sampson> curry on, lambdaconf, icfp are defacto haskell con
15:24:01 <homer_sampson> sm i'd totally dig that :D
15:24:14 <tnks> and now there's Compose (which is great!)
15:24:56 <homer_sampson> the lambdaconf thing... now that was some ugly drama =(
15:25:43 <hexagoxel> homer_sampson: said before: if committee is at fault and does not cooperate, address the community as a whole.
15:25:53 <tnks> there's clearly some people involved that feel left out, and I think the committee people just need to meet in a nice public space and try to invite more than just the committee to come and be heard.
15:26:04 <tnks> if they do it well, there's a lot of bridges built.
15:26:20 <homer_sampson> what does that even mean? write a post on reddit? start shouting complaints on irc?
15:26:39 <tnks> I think people's day job's get in the way.  But on that note, the PSF people are kind of a force of nature.
15:27:16 <homer_sampson> as you said, no 'few' people can claim to speak for the community.
15:27:30 <homer_sampson> tnks PSF?
15:27:49 <sm> python software foundation
15:27:50 <EvanR> homer_sampson: youre doing a good job of that
15:28:03 <Rotaerk> pretty much no one can speak for a community, unless they've been voted as a representative
15:28:06 <hexagoxel> homer_sampson: i already gave one option above.
15:28:26 <homer_sampson> EvanR i don't recall claiming to speak for anyone but myself here.
15:28:30 <tnks> we need to stop talking like founders of a nation, and just make a conference, and meet, and talk.
15:28:48 <EvanR> yeah, voting? really?
15:29:02 * hexagoxel loses interest in this.
15:29:13 * daey executes hexagoxel 
15:29:25 <EvanR> hexagoxel :: IO ()
15:29:36 <Welkin> lol tnks 
15:29:37 * sm penalises EvanR for impure thoughts
15:30:11 <EvanR> IO is abstract, abstract thoughts
15:30:30 * EvanR demands a lesser penalty
15:30:41 <sm> fine, fine, penalty revoked
15:31:39 * sm penalises hexagoxel posthumously
15:31:44 <daey> (-) 1 2
15:32:34 <homer_sampson> sm tnks interesting, what do you think makes PSF so effective?
15:33:32 <sm> AFAIK python has always had a fantastic community, that's often the luck of the personalities involved
15:34:03 <sm> and lots of effective conferences reinforcing that, such as the aforementioned pycon
15:34:08 <daey> charisma is important
15:34:20 <daey> imagine where linux would be today without linus
15:34:41 <EvanR> nowhere since he wrote it
15:34:46 <daey> ...
15:35:01 <sm> and lots of commercial use, which means funding for conferences, contributors, and a level of professionalism and communication skills
15:35:09 <systemfault> I thought it would have been as good without him being an asshole.
15:35:35 <tnks> homer_sampson: honestly, I think it's to some degree a sense of identity that was fostered over time.
15:35:54 <EvanR> sm: to get back on topic, that is a good point that since haskell is not as commercialized, you could infer that there is room for dweeby "internetty" arguments
15:36:03 <EvanR> but that falls apart for ruby
15:36:35 <sm> but holds up for lisp
15:36:45 <tnks> also, the culture of Haskell has such deep roots with academia and technical innovation, sometimes those conversation take more of a center stage.
15:36:49 <sm> by reputation at least
15:36:51 <hexagoxel> better posthumous than posthumorous
15:37:05 <hexagoxel> oh, other way round.
15:37:16 <homer_sampson> EvanR sm hmm commercialization of Haskell is maybe where Python was in ... 2005ish?
15:37:20 <daey> im not a good programmer by any means. but the biggest issue i see with haskell/functional programming is, that i ahve to learn programming from scratch. i mean i picked up python on the go, same with java. just with my C knowledge. but haskell? :D
15:37:35 <homer_sampson> how does haskell plot out the trajectory than python made since then?
15:37:54 <tnks> and also, there's always the problem of thinking "the grass is greener" when it's not; every language has its squabbles eventually.
15:38:06 <EvanR> daey: i noticed recently that "learning foo from scratch" is a skill ive had to use more and more after haskell, or at least ive realized that would be a good idea 
15:38:06 <homer_sampson> daey i sympathize but at the same time that's what was exciting about it.
15:38:22 <EvanR> and how to learn stuff from scratch is a thing you dont necessarily need but really helps if you have it
15:38:23 <sm> homer_sampson: that'll change pretty soon, the ideas are spreading 
15:38:36 <homer_sampson> tnks idunno the pydata ecosystem looks pretty cohesive to me
15:38:44 <sm> sorry, I mean daey
15:38:49 <Welkin> daey: that is because all of those other languages are basically the same thing: they are all derived from Algol
15:38:51 <hexagoxel> (oh wait, no, i meant it.. ah nevermind.)
15:39:02 <Welkin> so they are the same languages with slightly different syntax and some have extra features
15:39:03 <tnks> homer_sampson: well, there's money and adoption lubricating things
15:39:06 <Welkin> haskell is an ML language
15:39:09 <daey> homer_sampson: i agree. its the reason im looking into it. but i would NEVER start a company project on haskell.
15:39:19 <Welkin> plus it has a completely different evaluation strategy
15:39:22 <homer_sampson> sm funny i just came across a new Hadley Wickham (god of R / ggplot2) talk where he brings up referential transparency
15:39:26 <homer_sampson> and almost fell out of my chair
15:39:31 <EvanR> Welkin: thats the high level view, but when you go back and think "what if i needed to learn this from scratch" you end up with wildly different answers
15:40:10 <sm> homer_sampson: it's the same everywhere.. PHP, js devs know a good idea when they see it
15:40:38 <homer_sampson> daey why wouldn't you? i just got the first haskell project funded at a megacorp
15:40:44 <Welkin> daey: why not?
15:41:43 <homer_sampson> sm php/js devs? dunno about that ;-)
15:41:44 <homer_sampson> i kid i kid ...
15:41:47 <maerwald> Welkin: it's not so easy as people make it sound. I'm getting tired of this. No matter what your first language is, haskell IS harder than others.
15:42:03 <sm> true, true
15:42:06 <daey> Welkin: A. non of our programmers afaik knows it. B. good luck finding future programmers that know haskell. Meaning: you are responsible for a project. You want it to succeed, why risk it?
15:42:09 <maerwald> and the main reason is abstraction 
15:42:10 <EvanR> unless its your first language! ;)
15:42:15 <maerwald> EvanR: no
15:42:16 <sm> I develop in both myself
15:42:26 <EvanR> its by definition the easiest language you ever tried
15:42:31 <homer_sampson> i learned js after haskell
15:42:37 <tnks> maerwald: this is maybe true for some people, but it's not universal.
15:42:40 <homer_sampson> or rather, i'm learning... still a beginner.
15:42:46 <EvanR> and then you get fucked up when they put you in front of C++
15:42:57 <maerwald> tnks: pretty much the majority
15:42:58 <homer_sampson> i'm probably more advanced at haskell than i am at javascript at the moment.
15:43:21 <tnks> maerwald: that may be true, but this is where it's hard to know what the reason is.
15:43:32 <maerwald> abstraction and a lot of non-trivial concepts
15:43:39 <sm> it's partly tooling and funding
15:43:43 <EvanR> theres a lot more trivial concepts in haskell
15:43:47 <EvanR> than normal
15:43:53 <systemfault> daey: Tons of devs would actually work for your company BECAUSE they'd get to use Haskell.
15:43:54 <EvanR> and i think thats an issue, people arent generally good at those
15:44:03 <tnks> I'm constantly astounded by how popular Python is when they have to explain stuff like "def __init__(self, ...)"
15:44:21 <hpc> double-underscores are the pythonic way
15:44:25 <Welkin> the biggest problem in programming is that all of these uiversities are still teaching java and oop as "the one true way" because they are stuck teaching ideas from the 1980's, and the students spread this around when they enter the workforce, and the cycle continues
15:44:29 <Welkin> who can break the cycle?
15:44:40 <EvanR> its because people are more adept at grokking into complex and complexly presented concepts
15:44:40 <systemfault> daey: There's a classic article on Python by Paul Graham about that: The Python Paradox: http://paulgraham.com/pypar.html 
15:44:43 <maerwald> Welkin: no, it's not the biggest problem
15:44:47 <maerwald> it's one, though
15:45:00 <daey> systemfault: if you are a top notch company everyone wants to work for it might be simple. for smaller companies it gets much more difficult. People wont just relocate for some tiny company as they would for e.g. Amazon, google etc.
15:45:02 <tnks> it's not the dunderscores that I find hard to explain.  It's more the explicit magic self parameter.
15:45:06 <homer_sampson> welkin: one death at a time, as they say.
15:45:21 <tnks> you just have to handwave some details and let people experience what's going on.
15:45:23 <EvanR> Rx "think of an observable as an immutable asynchronous array" <- makes sense to people
15:45:29 <tnks> which I find is the case for even Haskell.
15:45:33 <daey> systemfault: im also guessing that haskell programmers might be more expensive, as the amount of them is tiny
15:45:37 <EvanR> "all functions take 1 argument" <- insane
15:45:57 <maerwald> people shouldn't make OOP a devil. It's an OK concept, just not very nice to build real abstraction
15:46:02 * sm fines EvanR 1 lambda
15:46:23 <Welkin> daey: no, they are not more expensive
15:46:33 <EvanR> Welkin: speak for yoself
15:46:34 <Welkin> in fact, most haskell positions pay the same or less than others
15:46:52 <daey> Welkin: fact is the amount is more limited. therefore they have more power on the discussion table
15:46:53 <tnks> also, the market is changing.
15:46:56 <Welkin> the languages doesn't matter when it comes to price
15:46:57 <homer_sampson> EvanR my college-level intro to programming was sicp so when i cam across that in haskell it made me feel all nostalgic
15:46:58 <sm> oh if we're talking OOP now, this recent Alan Kay discussion is wonderful: https://news.ycombinator.com/item?id=11808551#11809741
15:47:03 <Welkin> unless you need someone to fix your legacy cobol
15:47:06 <tnks> in Austin, I know of two companies hiring Haskell programmers.
15:47:16 <anon1> so what's the point of learning haskell. I'm starting to have second thoughts x)
15:47:23 <homer_sampson> the funniest thing is there's courses that try to teach a SICP-esque course with python
15:47:31 <Welkin> anon1: that question doesn't make sense
15:47:37 <EvanR> homer_sampson: o_O
15:47:38 <Welkin> why do you want to learn haskell in the first place?
15:47:38 <daey> anon1: expand your horizon. isnt that all that counts?
15:47:53 <sm> homer_sampson: you mean like MIT's ? :)
15:47:57 <homer_sampson> there's exams with scheme-ish environment diagrams (or whatever they're called) for python code
15:48:12 <Welkin> I started off with haskell thinking it was impractical, but wanted to learn true functional programming. Then after I really learned it, I used it commercially for all of my work.
15:48:14 <homer_sampson> what the hell? how does that even work :P
15:48:21 <Squarism> theres no uncurry that tuples all but return value of a function?
15:48:22 <Welkin> now it is pretty much all I use and all I want to use
15:48:27 <homer_sampson> welkin yeah i'm using it for work too
15:48:31 <hpc> anon1: assuming you'll never use haskell productively, learning it still directly pushes you to learn things that are useful in other languages
15:48:33 <Rotaerk> geekosaur, thanks, btw; it worked
15:48:36 <hpc> anon1: which you would never have learned otherwise
15:48:50 <Rotaerk> though webkitgtk still isn't found ... not sure if that's relying on me having it installed outside of stack or not
15:48:52 <Welkin> anon1: once you learn haskell, all other languages will suck
15:48:56 <hpc> like how to take callbacks / CPS to its logical conclusion
15:48:57 <homer_sampson> anon1 well i make a decent salary and i use it at work. does that count?
15:48:57 <anon1> Welkin: I want to learn it so I can shove functional programming down my throat
15:49:13 <homer_sampson> welkin been said before, it's "The Wire" of programming languages.
15:49:34 <hpc> now that's a metaphor
15:49:37 <tnks> there's two elephants that are often in the room, I find:  1) Haskell rewards hard work with more correctness, but correctness is not always what businesses want to pay for
15:49:42 <EvanR> functional seppukgramming?
15:49:59 <tnks> 2) to make more Haskell jobs, some programmers need to think more about the social dynamics of job creation (get out of their editor)
15:50:13 <homer_sampson> tnks i think though the real promise is that you get correctness as fast as you would've gotten code that wasn't correct if you were writing in python
15:50:18 <Welkin> tnks: it is faster to write and has fewer bugs
15:50:26 <Welkin> that means the costs go down
15:50:33 <homer_sampson> tnks i think that's possible, but the catch is you have to get over an upfront fixed cost
15:50:35 <homer_sampson> of learning
15:50:43 <tnks> homer_sampson: I can pipe all your requests to /dev/null way faster than I can write correct programs in Haskell.
15:50:47 <EvanR> haskell and you, dont think, call today for a free consultation (charges apply)
15:51:23 <homer_sampson> tnks companies wouldn't py for that. but they do pay for shitty python or java code
15:51:35 <homer_sampson> and i think writing haskell can be as fast or faster
15:51:40 <homer_sampson> once you're experience
15:51:46 <tnks> homer_sampson: also, there's a learning curve for doing Haskell well.
15:51:54 <tnks> Haskell is litered with partial functions.
15:51:57 <homer_sampson> + you get the rigor/correctness for free because that's the default of the human-language interface.
15:52:07 <anon1> hpc: but if I don't find a practical application for it it will be difficult to keep programming with it long enough to be proficient at it
15:52:15 <tnks> and people that leap in without mastering MTL or even transformers often just make a mess.
15:52:33 <Welkin> tnks: it is?
15:52:37 <homer_sampson> tnks well that's the catch. can you make the upfront investment, but that's why i think efforts to lower the learning curve are hugely important (resources like haskellbook, better tools like stack, etc)
15:52:37 <tnks> at which point, they've put in more work dealing with the unfamiliar, only to have the same class of defects.
15:52:39 <EvanR> transformers in commercial code ;_;
15:52:42 <Welkin> tnks: you mean `head` and `tail`?
15:53:00 <Welkin> tnks: by partial, you mean non-total?
15:53:07 <Welkin> tnks: or partially applied?
15:53:10 <tnks> Welkin: yeah, non-total
15:53:21 <homer_sampson> basically the haskell community has to put their money where their mouth is and dominate the productivity game.
15:53:22 <tnks> I have no beef with partial application :)
15:53:56 <tnks> homer_sampson: that takes education, and also failure, which is why we have to talk about my point 2) to really move the needle.
15:54:29 <EvanR> (whats the definition of partial application in haskell)
15:54:50 <homer_sampson> what was point 2)? it's going to take time, and professors + managers + team members dying off over time to make room for new and better ways.
15:55:19 <tnks> homer_sampson: managers in industry are not Haskell-enlightened, and generally conservative.
15:55:39 <Welkin> tnks: right, at least in big enterprise
15:55:41 <tnks> so Haskell programmers need to think about how to build the right social structures to create the environments and teams needed.
15:55:46 <EvanR> going with stuff like mongo, nodejs is conservative now?
15:55:48 <Welkin> at startups they are geenrally messed up in other ways though
15:55:54 <homer_sampson> yeah, i think ultimately you can't count on people changing. you agressively carve out space for it yourself, or wait for people to die off.
15:55:56 <tnks> my route was to become a hiring manager, but there are others.
15:55:59 <Welkin> they want the latest shiny thing that all the cool kids are using
15:56:06 <tnks> like becoming an entreprenuer.
15:56:36 <tnks> but waiting around for Haskell jobs seems like the wrong strategy first.
15:56:39 <Welkin> yeah... they use nodejs because it is "webscale" and "nonblocking!"
15:56:40 <homer_sampson> i'm carving out a haskell-shaped space at a big company now.
15:56:47 <maerwald> tnks: there are none anyway
15:56:52 <tnks> homer_sampson: awesome, me too.
15:57:00 <tnks> maerwald: I'm not at all sure of that.
15:57:09 <homer_sampson> tnks waiting for haskell jobs is definitely a losing game
15:57:17 <tnks> but to find them, I've found you need to tie into a network that's still closely nit.
15:57:25 <homer_sampson> you basically have to make them and wait for others to catch on in 2-5 years.
15:57:40 <Welkin> but it is funny that haskell's Warp blows nodejs away by a multiple
15:57:54 <homer_sampson> tnks to find what? haskell within an organization? hires? positions?
15:57:55 <tnks> also, because of how many jobs there are and where they're at, you may have to move.
15:57:57 <Welkin> in terms of performance
15:58:01 <maerwald> tnks: I consider 10-20 nothing
15:58:02 <Squarism> if i have a function a -> b -> c -> d -> f and want to apply it on (a,b,c,d) - theres no neat way of accomplishing that? 
15:58:19 <EvanR> uncurry4
15:58:22 <hpc> @hoogle uncurry4
15:58:25 <tnks> homer_sampson: jobs using Haskell that aren't just one developer with a script knocked out over a weekend.
15:58:25 <lambdabot> No results found
15:58:25 <Squarism> thanks
15:58:38 <homer_sampson> tnks alternatively, establish yourself somewhere, doing python data analysis or whatever effectively until you have some influence/power
15:58:39 <hpc> you probably need to write it yourself
15:58:40 <Rotaerk> could someone start a new stack project, add webkitgtk3 to their build-depends, and see if it fails?
15:58:41 <EvanR> the real answer, dont use a 4 tuple if you can avoid it
15:58:55 <homer_sampson> then promote haskell once you have a say
15:58:57 <tnks> maerwald: I find I only need one job, which is why the number of opportunities doesn't phase me that much.
15:59:02 <Welkin> lol, if you have 4 items in a tuple, you should just make a new datatype Squarism 
15:59:10 <Welkin> tuples are usually only for pairs
15:59:14 <tnks> but I agree that to move the needle, more is needed.
15:59:20 <Welkin> or for use in  lambda
15:59:22 <tnks> waiting for them to come to you is a losing game.
15:59:48 <tnks> well, for most people, I guess.
16:00:08 <Welkin> Squarism: you can also use a let expression like this
16:00:20 <maerwald> tnks: well, in my country, there are zero literally
16:00:22 <maerwald> so
16:00:33 <Welkin> let (a,b,c,d) = someFun 0 4 in otherFun a b c d
16:00:36 <tnks> maerwald: fair enough, sorry for the US-centricism.
16:00:40 <Squarism> Welkin, i know i know.. but im already in the rabbit hole
16:01:03 <EvanR> Squarism: whats great about haskell is you can refactor almost freely
16:01:15 <EvanR> and the compiler will tell you what you broke
16:01:34 <maerwald> tnks: so when someone asks me if he should learn haskell I usually say no ;)
16:01:44 <tnks> maerwald: aw, that's rough.
16:02:05 <maerwald> well, why invest so much time in something you cant use anyway for your professional career
16:02:14 <EvanR> maerwald: sounds like a catch 22 for education in that country
16:02:17 <Welkin> maerwald: that is the stupidest question I have heard all day
16:02:21 <tnks> I think it also depends on the context; learning to program a language can be much more than for direct application to a job.
16:02:32 <Squarism> EvanR, true. Sometimes its better to do the tracer bullit and tidy up afterwards
16:02:35 <Welkin> "why learn anything if you can't make money from it?"
16:03:02 <hpc> that's why i only learned enough algebra to do compound interest
16:03:02 <EvanR> why learn anything advanced if your community is not advanced
16:03:04 <tnks> maerwald: I can sympathize with people trying to get out of financial problems.
16:03:06 <Squarism> Pride in what you accomplish > money
16:03:27 <daey> its also funny to write stuff no one else understands.. has its 'carrier' advantages as well :p
16:03:29 <maerwald> tnks: lol xD
16:03:35 <tnks> but a lot of people asking if they should learn Haskell aren't in that position.
16:03:43 <sm> "should I learn haskell ?" "what are your goals ?" 
16:03:45 <EvanR> there is zero interest in haskell in my city-state, why do i care about haskell
16:03:59 <daey> career*
16:04:17 <tnks> there's no reason to be snarky.
16:04:29 <tnks> if someone has other goals, you can't force an interest.
16:04:31 <EvanR> tnks: this brings up a good point, haskell may be/seem very luxurious
16:04:43 <tnks> EvanR: that's a false presumption.
16:04:43 <EvanR> its only for people who spend their non programming time at country clubs
16:04:56 <tnks> but it's true for possibly a very specific class of people learning a programming language.
16:05:07 <sm> tnks: if that was to me, not being snarky.. I think that's how we should handle that q
16:05:34 <Welkin> no, the public image of haskell is as if it is Coq, an unpractical academic research language that can't possibly be useful for building anything
16:05:36 <tnks> sm: no, not you... honestly whom doesn't matter.
16:05:38 <EvanR> if youre buried in credit card debt, living in detroit with 7 kids and a dog... you might need to learn java
16:05:46 <tnks> EvanR: right.
16:05:58 <Welkin> EvanR: no, javascript
16:06:03 * sm skilfully deflects blame to the rest of #haskell
16:06:16 <tnks> or how about a single mom switching from an unstable career to just a modest web developer.
16:06:28 <hpc> sm: no, it's the children who are wrong :P
16:06:39 <daey> clearly the dog
16:07:20 <EvanR> this realization sucks!
16:07:34 <EvanR> haskell for all
16:07:55 * hackagebot Concurrent-Cache 0.1.0.0 - A Cached variable for IO functions.  https://hackage.haskell.org/package/Concurrent-Cache-0.1.0.0 (Ofenhed)
16:08:01 <Squarism> Welkin, thanks for that someFun/otherFun .. will invesigate that
16:08:04 <tnks> EvanR: create jobs with real mentorship opportunities.
16:08:19 <Welkin> Squarism: let expressions can be extremely useful in many situations
16:08:24 <EvanR> tnks: what does this mean?
16:08:48 <Welkin> you can also use it to build a data structure in-place while still being able to pass around additional information in a tuple
16:08:53 <tnks> EvanR: create a team, company, or even a project that needs more people.
16:09:08 <tnks> I just find a lot of Haskellers are heads-down in the work.
16:09:08 <EvanR> in order to train them?
16:09:34 <tnks> EvanR: if you want to beckon for the huddled masses, you need to provide them with the oppotunity to thrive.
16:09:41 <tnks> they need more than a link to LYAH.
16:10:13 <EvanR> functional programmers cant be industrial farmed
16:10:21 <EvanR> they have to have an interest already
16:10:24 <Welkin> lol
16:10:27 <Welkin> like java programmers?
16:10:29 <tnks> EvanR: I find that's not true.
16:10:48 <tnks> calling it "industrial farming" probably lumps in as a perjorative things I wouldn't want to do.
16:10:59 <tnks> but you can definitely make an inviting learning organization.
16:11:05 <tnks> and you might be surprised who shows up.
16:11:13 <sm> cf FP Complete's efforts
16:11:18 <tnks> people aren't birthed with the desire to make functional programs.
16:11:20 <sm> circling back to where we started, see
16:11:21 <EvanR> im kind of not surprised that basically no one shows up to my haskell group
16:11:43 <tnks> and only a thin slice of the population finds this interest through exploration.
16:12:01 <Welkin> I found haskell in a strange way while exploring I suppose
16:12:04 <EvanR> i do think a lot of people here have at least heard of FP
16:12:19 <tnks> I know some people who when to the math department of their local college when they wanted to hire non-traditional funtional programmers.
16:12:22 <tnks> it worked.
16:12:32 <tnks> and that's just one avenue.
16:12:40 <homer_sampson> evanr you have a haskell group?
16:12:43 <Welkin> I found out about list comprehensions and map/filter/reduce/lambda in python and loved it and I needed more, so I looked into clojure. I tried clojure for 5 minutes before running the other way (because of the JVM stuff)
16:12:48 <Welkin> and I ran straight into haskell
16:12:55 * hackagebot Concurrent-Cache 0.1.0.1 - A Cached variable for IO functions.  https://hackage.haskell.org/package/Concurrent-Cache-0.1.0.1 (Ofenhed)
16:13:04 <tnks> Welkin: yeah, I think we're in an interesting point where Haskell has more visibility.
16:13:05 <EvanR> and it doesnt help that new orleans pretty much deleted their math and engineering university stuff
16:13:11 <EvanR> except oil
16:13:16 <homer_sampson> welkin RH gives nice presentations tho
16:13:20 <tnks> but it's also possible to expect that visibility to do more than it actually will.
16:13:35 <Welkin> homer_sampson: yes, I like Rich Hickey
16:13:40 <Welkin> I just didn't like the jvm
16:14:43 <homer_sampson> tnks i think this is why some of the beginner-interfaces get so heated. it's not really about download links and websites, it's about capturing the next generation of adopters and how to do that right.
16:14:54 <EvanR> homer_sampson: http://tinyurl.com/zukx9jj
16:15:05 <tnks> homer_sampson: I agree.
16:15:30 <tnks> though personally, I'm on the side of the burning bridges proposal.
16:15:34 <homer_sampson> EvanR wth this is hilarious
16:15:50 <homer_sampson> i don't know what the burning bridges proposal is
16:16:02 <Squarism> Hypothesis: Some of big organizations utilize FP languages. If that proves successful for more than niched problems more will adopt. Community and resources will grow organically. Demand will rise, motivation to teach and learn will rise. Self fixing problem?
16:16:04 <EvanR> let the ashes blow away
16:16:09 <EvanR> its over
16:16:10 <Welkin> EvanR: is that your haskell group?
16:16:14 <EvanR> yes
16:16:18 <Welkin> should have known
16:16:24 <Welkin> you have a fetish for thundercats and mum-ra
16:16:41 <tnks> homer_sampson: https://ghc.haskell.org/trac/ghc/wiki/BurningBridgesSlowly (that's one link)
16:16:51 <homer_sampson> squarism depends at what level you're looking at the process
16:16:53 <sm> Squarism: pretty much, the only question is will the solution involve Haskell or something else
16:17:13 <homer_sampson> if your the person in the big organization driving adoption it is certainly taking a lot of effort
16:17:19 <Squarism> rubyFP
16:17:22 <Squarism> =D
16:17:25 <tnks> honestly, a lot of people are sneaking in FP with Scala.
16:17:28 <homer_sampson> if you're a blogger making a plot of adoption over a 10 year span it might look "automatic"
16:17:37 <Rotaerk> oh, I just had to install webkitgtk at the system level in order for stack to be able to build my project...
16:17:49 <tnks> but the problem with Scala is that people get very familiar with it, and kind of consider it "good enough"
16:17:50 <Welkin> tnks: scalaz, you mean?
16:17:52 <Rotaerk> it didn't get the dependency for me
16:17:58 <homer_sampson> argh time to stop talking about haskell and actually right some
16:18:00 <tnks> Welkin: yeah, scalaz, and also cats.
16:18:00 <homer_sampson> write some
16:18:23 <homer_sampson> i tried hask in python for about 20 mins and was like "eh this kinda sucks"
16:18:34 <sm> Rotaerk: ah, well known (except to all new users) limitation of stack/cabal, they don't install C libs
16:18:44 <Rotaerk> k
16:18:56 <daey> what exactly is an 'integral type'? i know that 'int' is part of it. but i only know the word integral from calculus
16:19:03 <tnks> radix I believe is writing a book about his experience bringing FP to Python.
16:19:06 <daey> and isnt 'int' and 'integer' the same?
16:19:07 <Welkin> daey: Integer-like
16:19:09 <sm> someone should file a feature request for clearer warnings of that
16:19:11 <tnks> including effects.
16:19:22 <Welkin> daey: Integer has no bounds
16:19:22 <EvanR> daey: as in integral domain, you can do division (quotient, remainder)
16:19:26 <Welkin> Int is an int32 or int64
16:19:41 <EvanR> :t divMod
16:19:43 <lambdabot> Integral a => a -> a -> (a, a)
16:19:56 <daey> im asking because the haskell wiki says:
16:19:58 <daey> Integral type into any Numeric type (which includes Int, Integer, Rational, and Double):
16:20:01 <homer_sampson> tnks what did radix do?
16:20:22 <Welkin> tnks: lol, what?
16:20:34 <Welkin> tnks: but guido hates anything remotely fp
16:20:41 <Welkin> and he hates recursion
16:20:47 <EvanR> daey: hmm. the wiki is weird. maybe youll like this page https://github.com/haskellcats/haskell-numbers
16:21:12 <EvanR> it doesnt explain the myraid numeric classes though
16:21:21 <homer_sampson> welkin i don't think it's that simple. he doesn't buy certain idioms. it's too late now to make fp the foundation of python anyway even if he loved haskell.
16:21:41 <Welkin> and the python vm does not support TCO
16:22:10 <tnks> Welkin: I find it's best to ignore (to a degree) what the core authors of a language say
16:22:14 <homer_sampson> if you're wedded to python coconut is probably the best hope for fp now.
16:22:32 <Welkin> any "functional" language without TCO is a joke
16:22:57 <homer_sampson> purescript -> python could be neat though. there's some projects around that.
16:24:01 <tnks> homer_sampson: radix made this library:  https://pypi.python.org/pypi/effect
16:24:24 <tnks> I thought he had a book deal, but I can't find a link, and maybe I got facts twiddled.
16:24:28 <EvanR> daey: fromIntegral = fromInteger . toInteger, if you look at the types of all these and then :i the referenced type classes youll see how it fits together
16:25:15 <EvanR> this is basically the swiss army knife of converting between "integral" numbers
16:25:22 <homer_sampson> tnks looks like a valiant effort & painful to use
16:25:50 <homer_sampson> (which was also my take on hask)
16:26:00 <tnks> homer_sampson: I agree.  Even with a handful of libraries like this, I'm not interested in programming in Python.
16:26:29 <Rotaerk> pypi longstocking
16:26:29 <tnks> but at work we have some machine learning people using Python, and maybe libraries like this can help a touch.
16:26:52 <homer_sampson> tnks yeah 'data science' is stuck with R and python for the time being
16:27:06 <homer_sampson> too much of an ecosystem advantage
16:27:16 <tnks> yeah, hard to catch up.
16:27:29 <homer_sampson> i wish haskell would catch up. stuff like subhask and hlearn seem to have stalled though
16:27:42 <EvanR> runPython ::
16:28:07 <EvanR> Python a -> IO a
16:29:02 <EvanR> (works for java-bridge)
16:29:29 <EvanR> embrace extend and extinguish
16:29:43 <Welkin> always be evil
16:30:14 <tnks> now you got me searching:  https://john-millikin.com/articles/ride-the-snake/
16:30:33 <tnks> I'm pretty sure I might end up doing something like this at work.
16:30:56 <tnks> that's my plan at least. . . I want to keep the Python to a minimum.
16:31:00 <hpc> runhaskell :: IO a -> IO a
16:31:18 <EvanR> that cant possibly work
16:31:37 <hpc> :P
16:32:56 * hackagebot Concurrent-Cache 0.1.0.2 - A Cached variable for IO functions.  https://hackage.haskell.org/package/Concurrent-Cache-0.1.0.2 (Ofenhed)
16:33:12 <daey> what is the difference between :load and :module? or in other words, what is the difference between a file.hs and a module?
16:34:29 * EvanR checks to see if theres a manual for that before saying read the manual
16:34:39 <texasmynsted> ha
16:34:47 <monochrom> Yes the GHC user's guide has a section on that.
16:35:00 * daey is in the official wiki :3
16:35:09 <Welkin> daey: I always just type :m module-name
16:35:14 <Welkin> or import module-name
16:35:16 <monochrom> The difference between reading in code and setting namespace.
16:35:16 <EvanR> the wiki! 
16:35:28 <monochrom> what official wiki?
16:35:28 <Welkin>  and :l MyFile
16:35:46 <daey> monochrom: wiki.haskell.org
16:35:52 <daey> if thats not official then idk
16:35:55 <EvanR> these days wiki is a thing projects use to stand in for actual documentation, which fortunately exists
16:36:18 <monochrom> it is official, but like all wikis, volunteer efforts are spotty.
16:36:39 <daey> well maybe its even in there. i just stumbled across :m and :l
16:37:02 <Welkin> daey: and use :r or :reload to reload
16:37:04 <Welkin> pretty simple
16:37:05 <monochrom> *shrug* the GHC user's guide exists and it is not on the wiki
16:37:22 <hpc> also the ghc user's guide is pretty much guaranteed to be accurate
16:37:29 <hpc> and it's easier to search for what you need
16:37:33 <EvanR> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#modules-vs-filenames
16:38:28 <daey> i see.  so a module is just a part of a file
16:38:34 <monochrom> no.
16:39:10 <daey> How does GHC find the filename which contains module ⟨M⟩?
16:39:29 <daey> thats what makes me think its a part of a file
16:39:36 <monochrom> that is a long story, and the GHC user's guide has it. there is some notion of search path.
16:39:38 <Welkin> a module is a file
16:39:46 <Welkin> but a file is not necessarily a module
16:40:00 <EvanR> doesnt that violate reflexivity
16:40:01 <monochrom> GHC looks for a "M.hs" on the search path.
16:40:12 <EvanR> or is that symmetry
16:41:00 <Welkin> I watced The Transporter yesterday
16:41:06 <Welkin> watching Transporter 2 now
16:41:07 <Welkin> haha
16:41:07 <monochrom> Welkin is wrong. GHC regards a *.hs file to be a module. If you don't say "module XXX" inside, a "module Main(main)" is added for you, so your file still becomes a module. You have no choice.
16:41:22 <Welkin> monochrom: I didn't know that. Thank
16:41:24 <Welkin> thanks
16:43:02 <monochrom> note also that it's "module Main(main)", not "module Main". there is a difference.
16:44:21 <monochrom> most answers on this topic you receive from most random people on the Internet are basically randomly generated fiction.
16:44:50 <monochrom> people love to imagine rather than test and check
16:45:29 <maerwald> monochrom: mh, why was that added?
16:45:32 <jmcarthur> I just leave the module header out of my main modules.
16:45:34 <maerwald> isn't really that useful is it
16:45:59 <michbad> What would you guys recommend as a second Haskell book? My knowledge is around the level of having completed Learn You A Haskell.
16:46:08 <maerwald> ugh
16:46:15 <Welkin> hahaha
16:46:16 <maerwald> start with something that gives you actual exercises
16:46:21 <hpc> read RWH
16:46:22 <Welkin> the question we get 100 times a day
16:46:31 <Welkin> @where learnhaskell -- michbad 
16:46:32 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:46:35 <monochrom> Then you have only read a trailer, not a first book.
16:46:43 <hpc> parts of it will be repetative but it has exercises and chapters LYAH doesn't have
16:46:54 <maerwald> lyah has pictures
16:46:58 <monochrom> That's right, LYAH is a trailer of the length of a full-feature movie.
16:47:09 <Welkin> it has clint eastwood and mario monsters
16:47:13 <maerwald> the only thing about lyah I remember is a picture of cookies, I don't remember where though
16:47:22 <daey> how is this course? https://en.wikibooks.org/wiki/Haskell 
16:47:24 <michbad> Okay, so I've actually taken a class on Haskell, I might know a little more than that.
16:47:24 <maerwald> ah, I think it was zippers xD
16:47:30 <daey> at least im following it atm
16:47:40 <michbad> I didn't go through all of LYAH, but it was listed as one of the texts.
16:47:48 <monochrom> it's OK, it's just too long on some topics.
16:47:50 <jmcarthur> michbad: From what I hear, http://haskellbook.com/ is shaping up really nicely.
16:47:53 <hpc> the wikibook isn't cohesive enough to be a book, but i like it for some specific bits
16:47:59 <EvanR> "think of zippers as a sort of immutable asynchronous cookie"
16:48:11 <Welkin> you won't really have learned it until you write an actual project in it
16:48:21 <maerwald> EvanR: did you make that up or does lyah actually say that
16:48:22 <Welkin> not just one-liners in ghci and solving project euler problems
16:48:32 <monochrom> like "exercise 2: data Two a = Two a a", "exercise 3: data Three a = Three a a a", "exercise 4: data Four a = Four a a a a"
16:48:38 <EvanR> maerwald: ad libbing
16:48:59 <michbad> And Real World Haskell would be best for learning actual practical stuff?
16:49:06 <Welkin> RWH is really old
16:49:15 <Welkin> I haven't looked at haskellbook, but a lot of people recommend it
16:49:24 <hpc> i think RWH has been updating?
16:49:51 <Welkin> RWH covers lots of non-language topics like parsing and other stuff
16:49:54 <maerwald> RWH is still accurate on a lot of things
16:49:58 <monochrom> and its Monad explanation is a long-winded story that requires you to keep track of twice as many things as a Monad explanation, because now you also have to keep track of two fictional characters and ten things they did in previous stories.
16:50:11 <maerwald> monochrom: xD
16:50:12 <Welkin> you only need to basics to get started, then you are start a project and learn when you get stuck
16:50:22 <michbad> Haskell Book looks good, but it's 60$? That's a little expensive.
16:51:05 <maerwald> maybe it was designed as a haskell bed-time story for his kids
16:51:06 <Welkin> michbad: it's not expensive for that type of book
16:51:30 <EvanR> a monad is like a functor but with two extra operations and some extra laws
16:51:37 <maerwald> "pa, tell me about the cookie monster living in the zipper again"
16:51:46 <EvanR> with verde sauce on top
16:51:49 <monochrom> the haskell wikibook and the haskell wiki shows you what's wrong with unmoderated wikis. overly enthusiastic volunteers who go on and on about what excites them rather than what benefits you. incoherent irrelevant information overload.
16:51:53 <hpc> what if you have cookies disabled
16:51:56 <Welkin> michbad: when I started, I used LYAH and RWH, and they were not enough
16:52:03 <Welkin> RWH was really hard to read
16:52:29 <Welkin> I only learned by jumping into a project after reading LYAH, some of RWH, the typeclassopedia, and asking lots of questions here
16:52:47 <maerwald> the only real course I did was cis, after that just doing stuff, reading other peoples code, reading documentation or asking here
16:52:47 <Welkin> Haskell Book probably covers all of that so you won't have to waste weeks or months finding it yourself
16:52:54 <Welkin> ah, I did cis as well
16:53:06 <michbad> What's cis?
16:53:15 <Welkin> michbad: in the link I gave you
16:53:20 <Welkin> @where learnhaskell -- michbad 
16:53:20 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:53:31 <Welkin> it is a haskell course
16:53:45 <hpc> why is it called cis?
16:53:56 <Welkin> CIS190 is the name of the course at UPenn
16:53:59 <hpc> ah
16:54:10 <hpc> that's a terrible way to name things :P
16:54:10 <EvanR> 194 ?
16:54:13 <Welkin> 194*
16:54:20 <EvanR> its pretty terrible
16:54:25 <EvanR> use the dudes name instead
16:54:32 <michbad> Alright, I've looked at the github page. Thanks!
16:54:34 <EvanR> byorgey
16:54:57 <Welkin> I wonder, is Haskell Book going to become the standard recommendation for newcomers?
16:54:58 <maerwald> wonder if there are any courses from Dijkstras time
16:55:01 <Welkin> I haven't even looked at it yet
16:55:16 <Welkin> oly the table of contents
16:55:23 <EvanR> Welkin: bitemyapps book? or the haskell wikibook
16:55:24 <monochrom> there is no "the".
16:55:36 <Welkin> EvanR: bitemyapp's book
16:55:43 <monochrom> there are about 5 standard recommendations
16:55:53 <daey> http://lpaste.net/169419 this is an example from the wikibook which doesnt load. the last line causes the issue, as it has no argument. is that a wiki book error? did something change in haskell that requires an argument for the 'in all other cases'?
16:56:01 <Welkin> speaking of which... bitemyapp is not here anymore, but he is in #haskell-beginners
16:56:06 <hpc> i hope the haskell book ends up being obviously better than the alternatives
16:56:06 <EvanR> indeed
16:56:10 <Welkin> I wonder if it's the drama
16:56:12 <hpc> so the community can at least decide on one thing
16:56:18 <EvanR> DRAMAAAAA
16:56:29 * EvanR goes to listen to pop music
16:56:41 <monochrom> daey, "pts _ = 0". the underscore.
16:56:59 <monochrom> I am too lazy to check whether it's your misreading or wikibook's miswriting.
16:57:00 <daey> ah right. ive seen that beofre
16:57:10 <daey> no its not there. i copied it to lpaste
16:57:23 <daey> or chromiums pdf reader does strange things*
16:57:59 <monochrom> and I forgot that there are always a million network hops, a web server, and a web browser between you and the wikibook, every stage of which has a chance to mutilate things.
17:01:46 <iphy> is there a way to write a single function instead of N for N possible arities here? https://github.com/iphydf/hstox/blob/equiv-test/src/testsuite/Network/Tox/RPCTest.hs
17:03:15 <EvanR> maybe Client a is an Applicative
17:03:32 <monochrom> Yes, the most ideal solution is to refactor or completely redesign the whole thing so you never need N different arities again.
17:04:14 <monochrom> If you can't do that, the next best thing is to hack type classes to fake multiple arities, like what Text.Printf does.
17:04:27 <Squarism> monochrom, you said the other day that your IO_inside article was FAR from the truth. I wonder, is there some nice writeup that doesnt do a "tooth fairy tale" of it all? =D
17:04:42 <EvanR> i like "a free approach"
17:04:46 <monochrom> the IO_inside article is not mine.
17:04:57 <EvanR> which is just an even better fairy tale is all
17:05:16 <monochrom> because I haven't got drunk and done s/RealWorld/SantaClaus/ to it yet.
17:05:21 <Welkin> is that like "Intel Inside"?
17:05:31 <monochrom> when I finally do that, I will accept that it's "my article"
17:05:46 <Squarism> please be easy on the noob
17:06:07 <iphy> EvanR: it's a Monad, what can I do with that?
17:06:08 <Welkin> I like SPJ's paper on Lazy Functional State Threads to learn about ST and IO
17:06:22 <EvanR> iphy: well, then its an Applicative
17:06:22 <Welkin> even if it is quite old
17:06:24 <Welkin> it is very good
17:06:28 <EvanR> Squarism: https://wiki.haskell.org/IO_Semantics
17:06:36 <iphy> EvanR: yes
17:06:43 <iphy> monochrom: I can completely refactor it, but I don't know what I should refactor it to
17:06:45 <Squarism> EvanR, thanks
17:07:54 <Welkin> iphy: use lists as the input? You may want dependent types if you do that though :D
17:08:02 <Squarism> Welkin, sounds like a "scientific paper" with lots of category theory and homomorphismic semigroups? No?
17:08:18 <Welkin> Squarism: no, it is written very well for anyone to read
17:08:18 <EvanR> Welkin: no... 
17:08:54 <Squarism> Welkin, ok.. ill google that then
17:09:09 <Welkin> I wish I had found it earlier than I did, too
17:10:20 <Welkin> Squarism: http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html#monads
17:10:21 <EvanR> iphy: there is some repeating structure here begging to be deleted!
17:10:43 <Profpatsch> When I am in an ExceptT and I want to check something and throw an error if it doesn’t hold, what do I do?
17:10:55 <dibblego> type-class hacking for multiple arities, https://hackage.haskell.org/package/optional
17:10:57 <Squarism> great!
17:11:11 <iphy> EvanR: a bit, yes
17:11:16 <iphy> but I'd still have N functions
17:11:31 <EvanR> iphy: first off, all of your functions apply two functions to N arguments
17:11:57 <EvanR> then it does something (the same exact thing) with the 2 results
17:12:13 <EvanR> without further thought, you could factor out the "same thing" part into another wrapper 
17:12:18 <Welkin> dibblego: the email address is upside down
17:12:22 <iphy> right
17:12:39 <iphy> but I was hoping I could do away with the need for N functions
17:12:44 <EvanR> now to get the apply two functions to N args to get 2 results... 
17:12:44 <Profpatsch> guard False :: Either String () gives me Left ""
17:12:46 <iphy> I can factor out repetitive things
17:12:55 <Profpatsch> But I want to return an error message.
17:13:05 <dibblego> Welkin: yes, to help prevent unsophisticated spammers
17:13:25 <Welkin> dibblego: is this the new captcha of the day? It is just as bad
17:13:32 <EvanR> :t <<*>>
17:13:33 <lambdabot> parse error on input ‘<<*>>’
17:13:39 <EvanR> :t (<<*>>)
17:13:41 <lambdabot> Not in scope: ‘<<*>>’
17:13:43 <monochrom> no, it's the new captcha of five years ago
17:13:49 <dibblego> Welkin: haven't received a spam to that address since 2008, when I started using upside-down email addresses
17:13:50 <EvanR> p (a -> b) (c -> d) -> p a c -> p b d
17:14:20 <Welkin> dibblego: I meant it is bad for everyone but you
17:14:32 <dibblego> Welkin: excellent
17:14:47 <EvanR> (f1, f2) `bimap` bipure x <<*>> bipure y <<*>> ... 
17:15:06 <EvanR> theres probably an arrow to use here instead...
17:15:42 <iphy> hm I see, bimap yes
17:16:44 <EvanR> when you write your test, you would just write N <<*>>s, or whatever the arrow thing is, and you dont need your helper functions
17:16:45 <Welkin> lol, bifunctors
17:17:02 <Profpatsch> #!/bin/env nix-shell
17:17:03 <Profpatsch> #!nix-shell -i sh -p haskellPackages.spy
17:17:05 <Profpatsch> cabalfiles=$(find *.cabal)
17:17:07 <EvanR> but you do need the 1 wrapper to do the liftIO and `actual` etx
17:17:08 <Profpatsch> test -z && (echo "no cabal file, aborting"; exit 1)
17:17:09 <Profpatsch> for f in "$cabalfiles"; do
17:17:11 <Welkin> Profpatsch: use @lpaste
17:17:11 <Profpatsch>     echo "$f" | sed 's/^\(.*\)\.cabal$/'
17:17:13 <Profpatsch> done
17:17:15 <Welkin> !lpaste
17:17:15 <Profpatsch> Oh, sorry
17:17:17 <Profpatsch>   if length cabalFiles == 0 then throwE "no cabal file, aborting" else pure ()
17:17:18 <Welkin> @lpaste
17:17:18 <lambdabot> Haskell pastebin: http://lpaste.net/
17:17:21 <Welkin> ...
17:17:26 <Profpatsch> That’s the one line I wanted to paste …
17:17:38 <Profpatsch> But now that I’ve got the attention. :P
17:17:59 <EvanR> :t throwE
17:18:00 <lambdabot>     Not in scope: ‘throwE’
17:18:00 <lambdabot>     Perhaps you meant one of these:
17:18:00 <lambdabot>       ‘throw’ (imported from Control.Exception),
17:18:00 <Profpatsch> How to encode that check without the unnecessary else part?
17:18:14 <EvanR> when?
17:18:24 <EvanR> @src when
17:18:24 <lambdabot> when p s = if p then s else return ()
17:18:32 <monochrom> yeah
17:18:37 <Profpatsch> Okay, I should go to bed right now.
17:19:09 <Profpatsch> Thanks. <.<
17:19:21 <iphy> Welkin: what's wrong with bifunctors?
17:19:41 <EvanR> throwTo bed ProfpatschException
17:20:23 * Profpatsch flies in the direction of the bed but crashes out of the window because it was unchecked
17:21:12 <Profpatsch> *** Exception: no sleep for you
17:21:26 <Welkin> iphy: nothing
17:21:29 <Welkin> I just think they are funny
17:21:40 <EvanR> this is BiApplicative
17:21:43 <EvanR> which is hilarious
17:21:44 <Welkin> I haven't used them yet, but I would like to find a reason to
17:22:21 <iphy> I've used bimap with Either
17:22:39 <Welkin> I see that commonly used in that way I suppose
17:23:05 <maerwald> iphy: yeah, me too
17:23:24 <maerwald> I guess one could use them for tuples, but...
17:23:33 <maerwald> tuples are boring
17:24:07 <Welkin> but we have Arrow for tuples!
17:24:16 <Welkin> which is what everyone uses it for now
17:24:17 <maerwald> yeah, that too
17:24:41 <Welkin> to make your programs harder to read
17:24:45 <Welkin> but it looks cool
17:25:06 <maerwald> yes, that's what haskell is about after all
17:25:59 <Welkin> like point-free
17:27:26 <EvanR> in this case its about not writing redundant code
17:28:03 <maerwald> often, the provided abstraction is so minor, but people still decide to go for it
17:32:28 <EvanR> the bipures actually dont help at all
17:32:31 <iphy> https://github.com/iphydf/hstox/blob/equiv-test/src/testsuite/Network/Tox/RPCTest.hs
17:32:39 <iphy> I didn't get the bimap thing to work yet
17:32:52 <EvanR> well and the way i originally wrote it is wrong
17:32:57 <iphy> I think this is fine though
17:33:49 <EvanR> (f1,f2) <<*>> (x,x) <<*>> (y,y) <<*>> ...
17:34:55 <EvanR> (never actually seen anyone do this, but it works)
17:34:58 <Iceland_jack> or
17:34:58 <Iceland_jack>     biLiftA2
17:35:11 <EvanR> yeah for small number of args
17:35:13 <Iceland_jack> *biliftA2 :: Biapplicative f => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f
17:35:15 <Iceland_jack> yeah
17:35:36 <Iceland_jack> It's quite rare to see Biapplicative in practice but it happens :)
17:35:53 <Welkin> f or w?
17:35:54 <Welkin> lol
17:36:16 <Iceland_jack> Someone asked if there is a cleaner way of writing
17:36:16 <Iceland_jack>     (\(k1,b1) (k2,b2) -> (min k1 k2, b1 || b2))
17:36:34 <Iceland_jack> > bipure min (||) <<*>> (4, True) <<*>> (10, False)
17:36:36 <lambdabot>      Not in scope: ‘bipure’
17:36:36 <lambdabot>      Perhaps you meant one of these:
17:36:36 <lambdabot>        ‘pure’ (imported from Control.Applicative),
17:36:41 <Iceland_jack> oh poo
17:36:52 <EvanR> bipure is kind of noise here
17:36:57 <Iceland_jack> ghci> biliftA2 min (||) (10, False) (666, False)
17:36:57 <Iceland_jack> (10,False)
17:36:57 <Iceland_jack> ghci> bipure min (||) <<*>> (4, True) <<*>> (10, False)
17:36:57 <Iceland_jack> (4,True)
17:37:25 <EvanR> clearly we need a Triapplicative
17:37:29 <Iceland_jack> ;)
17:37:36 <Rembane> Napplicative
17:38:14 <EvanR> i want to encode the shape in the types ;_;
17:38:16 <iphy> I'll have that without plicative
17:38:24 <maerwald> EvanR: we need a TH lib to generate n-applicative
17:38:37 <EvanR> no we need dependent types
17:38:57 <Iceland_jack> Welkin: there is also
17:38:57 <Iceland_jack>     fold :: [(Min Int, Any)] -> (Min Int, Any)
17:38:57 <Iceland_jack> for that case, maybe that helps
17:39:09 <Welkin> you need an AbstractFactoryFactoryManagerFactory
17:39:31 <EvanR> pi types are type factories
17:39:44 <EvanR> suddenly its the next big thing
17:41:01 <Welkin> movie time
17:57:58 * hackagebot uuid-orphans 1.4.1 - Orphan instances for the UUID datatype  https://hackage.haskell.org/package/uuid-orphans-1.4.1 (DavidFox)
18:17:58 * hackagebot husk-scheme 3.19.3 - R5RS Scheme interpreter, compiler, and library.  https://hackage.haskell.org/package/husk-scheme-3.19.3 (JustinEthier)
18:22:07 <daey> can i think of '<-' as an 'impurity stripper'?
18:22:16 <alercah> not really, no
18:22:28 <alercah> or maybe you can if it's helpful to you
18:22:35 <alercah> but it's liable to leave you confused later
18:22:36 <shachaf> You oughtn't.
18:22:45 <alercah> most monads are entirely pure
18:22:52 <alercah> IO can be seen as pure through the right lens
18:22:57 <alercah> (no pun intended)
18:23:32 <shachaf> Even if you want to say that IO isn't pure, <- isn't "stripping" anything.
18:23:41 <daey> i see. so its used for other things than getting values from actions
18:23:55 <shachaf> No, that's the only thing it's used for.
18:23:56 <daey> well its stripping the IO from the String :p
18:24:22 <alercah> but the actions are all pure (except for a few magic monads, and again, even they can be seen as pure from a certain perspective)
18:24:28 <daey> and just to clarify. <- has nothing to do with -> right?
18:24:31 <alercah> correct
18:24:59 <alercah> daey: the list monad is perhaps a good example of where <- will really violate your expectations
18:25:09 <shachaf> No, it's not "stripping the IO from the String".
18:25:24 <alercah> > do { x <- [1, 2, 3, 4, 5]; return $ x * 2; }
18:25:26 <lambdabot>  [2,4,6,8,10]
18:25:27 <dmwit> It is not stripping `IO` from the `String`. It is teaching the `String`-consumer how to consume `IO String` instead.
18:26:18 <daey> alercah: is that a monad?
18:26:41 <daey> the more i look for them the better they seem to hide...
18:26:49 <shachaf> It's a monad, and moreover [1, 2, 3, 4, 5] is an action.
18:27:03 <daey> yeah i already know the syntax
18:27:15 <alercah> yep, lists form a monad
18:27:59 <alercah> with (>>=) = flip concatMap and return = \x -> [x]
18:28:50 <alercah> it's a great mind-blower since a single bind executes the bound function once per element in the list, which is different from IO
18:33:16 <alercah> daey: do you follow?
18:36:29 <ertesx> daey: "do" notation lets you have multiple IO actions in sequence, and "<-" allows you to give the results of some of those actions a name
18:36:37 <daey> alercah: barely. ive seen >>= and know that it has something to do with 'do'.
18:36:45 <ertesx> daey: and that's about it
18:37:06 <daey> and the last action isnt supposed to be used in conjunction with <-
18:37:11 <Shou> Is there a zipWith that doesn't truncate the combined list to the shortest list's length?
18:37:20 <alercah> daey: right, do notation is syntactic sugar
18:37:43 <daey> im guessing due to the fact that they are used in a function of type IO (). and only actions can return said type
18:37:55 <alercah> well IO a for some a
18:38:09 <alercah> when you use "p <- expr; ..." in a do block, this is desugared to "expr >>= (\p -> ...)"
18:38:13 <ertesx> do line <- getLine; putStrLn line  -- two actions in sequence, with the result of the first action named "line"…  no stripping
18:38:32 <alercah> you can't put a <- line last because then the ... is empty which makes no sense
18:39:21 <alercah> likewise you can't end with a let line because it doesn't have a value
18:39:26 <alercah> and the do block has to have some value
18:39:30 <ertesx> daey: do x1 <- c1; x2 <- c2  -- there is nothing wrong with this in principle…  the haskell standard simply doesn't allow it
18:39:39 <ertesx> for no technical reason
18:40:10 <shachaf> I would say that there's a reason.
18:40:28 <alercah> ertesx: what's the value of that expression?
18:40:41 <ertesx> perhaps, if you are a bit strict about how you desugar
18:40:54 <ertesx> but in principle it's just the same as "do x1 <- c1; c2"
18:41:59 <ertesx> alercah: the value of that expression?  since it's not standard, i'd have to make one up =)
18:42:21 <alercah> haha
18:43:16 <ertesx> what i mean is:  the question why the last result may not be named is a reasonable question, and i think the only good answer is: because it was designed that way
18:45:21 <jmcarthur> To me,   blah = do { x <- foo }   makes about as much sense as   blah = let x = foo
18:46:18 <ertesx> jmcarthur: would you really mind, if that were just "blah = foo"?
18:47:17 <shachaf> I would mind.
18:47:20 <alercah> ^
18:47:25 <shachaf> It makes the syntax more complicated.
18:47:26 <jmcarthur> ertesx: Yeah, because that was the body of a let binding...
18:47:45 <alercah> daey: please continue to ask any questions you have! :)
18:48:10 <ertesx> shachaf: good point
18:48:28 <ertesx> i wouldn't anyway…  i'm not a haskell implementor =)
18:51:26 <daey> alercah: thanks, i will :)
19:02:59 * hackagebot text-zipper-monad 0.1.0.0 - Monadic interface to the text-zipper package  https://hackage.haskell.org/package/text-zipper-monad-0.1.0.0 (kseo)
19:24:54 <POGtastic> hi guys, just started learning haskell. i'm trying to grab lines of text from a file. it's returning an error that it can't match "IO <type>" with "<type>". code is here: https://gist.github.com/mbottini/6d348ff15e874b1f84ee5b437d8c260f
19:36:15 <pavonia> POGtastic: You can't use "testParse" as an argument to "build" because it's an IO action. You could use (<$>) again here to apply "build" to the result
19:41:11 <POGtastic> so it would be build <$> testParse parse 10 "error.log"
19:41:31 <POGtastic> looks better... it threw an error because my buildTree function wasn't made right. that's progress though :)
19:41:33 <POGtastic> thank you!
19:43:08 <POGtastic> also, is there a link on the haskell wiki about what <$> means? i know that the $ operator does f(g x) == f $ g x, but i don't know what the significance of the brackets is
19:43:45 <shachaf> You can look up operators using Hoogle, https://www.haskell.org/hoogle/
19:44:03 <shachaf> In this case the answer is slightly involved, and the right thing to do is probably to read about Functor somewhere.
19:46:00 <Band1t> hi
19:48:38 <Band1t> exit
19:52:51 <daey> :: String -> IO (Either String Data.ByteString.Internal.ByteString) how exactly would i pass the output of that to putStrLn?
19:54:31 <alercah> daey: well, you know how to get an Either String ByteString, right?
19:54:44 <shachaf> do { x <- daey "hi"; case x of { Left s -> f s; Right bs -> g bs } }
19:56:11 <daey> alercah: well document <- openURI url. should get me said Either String Byte....
19:56:47 <alercah> daey: right
19:56:57 <alercah> so then you can use a case expression as shachaf showed :)
19:57:05 <daey> lol
19:57:31 <daey> i thought that was some kind of joke riddle >,<
19:57:47 <alercah> nope
19:58:16 <joobus> question: in this expression `(++) <$> Just "asdf" <*> Just "qwer"` both <$> and <*> are infixl 4, so I'm guessing haskell just evaluates from left to right in order.  If <*> was infixl 5, would `Just "asdf" <*> Just "qwer"` be evaluated before the <$>?
19:59:06 <shachaf> joobus: Precedence isn't the same as evaluation order.
19:59:40 <shachaf> But if <*> was infixl 5, then that expression would mean (++) <$> (Just "asdf" <*> Just "qwer")
19:59:47 <shachaf> (Which is an error.)
20:00:12 <joobus> i know it wouldn't evaluate, but i don't have an example of an infixl 5 off the top of my head.
20:00:41 <joobus> you say precedence isn't the same as evaluation order, but in this case the precedence would affect the evaluation order.
20:01:16 <shachaf> Of course it would affect the evaluation order, because a completely different thing would be evaluated.
20:02:13 <joobus> k, just confirming.  back to reading the haskell book :)
20:02:42 <shachaf> Oh, that book. I don't even want to know what it says about precedence.
20:04:13 <daey> what exactly is an "either string..."?
20:04:32 <shachaf> Oh, now I remember. It's in the sample PDF.
20:04:42 <shachaf> «If you like, a way to understand ($) in words is: “evaluate everything to the right of me first.”»
20:05:22 <shachaf> If you're reading that book, I don't blame you if you're confused, because it's pretty sloppy.
20:05:35 <shachaf> But I've said enough about it in here already.
20:06:34 <joobus> i'm reading the applicative chapter and was just curious about evaluation order of something similar to my example.
20:08:19 <EvanR> $! ?
20:10:01 <EvanR> i guess that would still be sloppy since i see $! in fst (9, (+1) $! undefined) but im not evaluating the left or right
20:11:05 <EvanR> i can see how counterexamples like that might annoy louis reasoner, and so it might be a strategy to be loose in a book designed to appeal to him
20:18:46 <noob2000> hey all :D
20:19:43 <noob2000> So I'm playing with haskell for the first time today, transitioning from languages like C, Python, ASM, ETC...
20:20:13 <noob2000> and I have been doing pretty good so far, but this code not working is blowing my mind
20:20:16 <noob2000> http://lpaste.net/5176504956932325376
20:20:25 <noob2000> anyone out there wanna help me figure this out?
20:20:57 <noob2000> what am i doing wrong at line 14
20:21:10 <noob2000> and what am i not getting about currying
20:21:17 <EvanR> error message?
20:21:29 <noob2000> sure, one sec
20:22:16 <noob2000> http://lpaste.net/6879126986313170944
20:22:29 <EvanR> mkay
20:22:39 <noob2000> lol, this reminds me of the horror i felt years ago learning to write C lol
20:22:39 <EvanR> start by writing the top level type sigs for all your top level stuff
20:22:53 <EvanR> then the type error messages will probably be easier to understand
20:23:12 <EvanR> as it is, your mapM's are being interpreted as working on any Foldable
20:23:21 <EvanR> but you probably only care about lists
20:23:36 <noob2000> that is exactly right
20:24:40 <EvanR> i see the error though
20:24:46 <noob2000> what is it?
20:25:00 <noob2000> this is day one, go easy lol
20:25:13 <EvanR> write type top level type sig for filter_null
20:25:25 <noob2000> can you explain what that means?
20:25:38 <EvanR> you have filter_null = filter not_null
20:25:49 <EvanR> above that put filter_null :: <a type signature>
20:25:54 <noob2000> ok
20:26:02 <EvanR> like, what is this thing, a function from what to what
20:26:07 <noob2000> thats what i figured you meant, but im not up on the jargon yet
20:26:15 <noob2000> from a list to a list
20:26:28 <EvanR> ok so :: [a] -> [a]
20:26:40 <EvanR> thats probably not the whole thing
20:27:01 <EvanR> but try that and see what the error turns into
20:27:21 <noob2000> Expected type: IO [String] -> IO [String]
20:27:22 <noob2000>       Actual type: [t0 a0] -> [t0 a0]
20:27:31 <noob2000> well now its down to just one error lol
20:27:34 <EvanR> on line
20:27:55 <noob2000> same line
20:27:57 <EvanR> yeah top level type sigs are awesome
20:27:58 <noob2000> :(
20:28:04 <EvanR> what line?
20:28:09 <noob2000> 14
20:28:18 <EvanR> yep thats where the error is
20:28:19 <noob2000> well now 15
20:28:47 <noob2000> the output of the curried function is the same type that should go in
20:28:47 <noob2000> and come out
20:28:49 <noob2000> what kind of crazy shit is going on lol
20:29:00 <EvanR> eh?
20:29:15 <EvanR> break that line down
20:29:34 <EvanR> if you have l <- blah, then blah has type IO X, and l has type X
20:29:44 <EvanR> in your case blah is filter_null (readlines x)
20:30:01 <EvanR> but filter_null doesnt return an IO X
20:30:33 <EvanR> that is the problem
20:30:50 <noob2000> hmmm
20:31:01 <EvanR> it returns [X] at best
20:31:26 <EvanR> whats the type of readlines x
20:32:14 <EvanR> (if you have the type of x written somewhere and the type of readlines that would be easy)
20:33:35 <noob2000> readLines :: FilePath -> IO [String]
20:33:42 <noob2000> filter_null :: IO [String] -> IO [String]
20:33:57 <EvanR> oh you changed the type of filter_null ?
20:34:01 <noob2000> yeah
20:34:03 <noob2000> and now this:
20:34:14 <noob2000> Expected type: IO [String] -> IO [String]
20:34:14 <noob2000>       Actual type: [IO [String]] -> [IO [String]]
20:34:18 <noob2000> haskell is trolling me man
20:34:19 <noob2000> lol
20:34:25 <EvanR> well what line is that on
20:34:37 <monochrom> no. instead, you're just doing random genetic mutation.
20:35:14 <EvanR> as long as it type checks, its good (TM)
20:35:18 <noob2000> http://lpaste.net/9126655794324963328
20:35:38 <noob2000> this is making me sad lol
20:35:44 <noob2000> that is the new updated code
20:36:01 <pavonia> The type has to match the defintion of your function
20:36:11 <noob2000> it should
20:36:22 <pavonia> It doesn't
20:36:26 <EvanR> the error message should be telling you where you messed up, now that you have a proper type sig
20:36:33 <pavonia> :t null
20:36:34 <lambdabot> Foldable t => t a -> Bool
20:36:40 <pavonia> :S
20:36:46 <noob2000> In the expression: filter not_null
20:36:46 <noob2000>     In an equation for ‘filter_null’: filter_null = filter not_null
20:36:47 <monochrom> [a] -> Bool
20:36:58 <EvanR> there you go, filter_null is broken
20:37:07 <EvanR> figure out why, then fix it
20:37:31 <noob2000> it works if i put it in a statement like this:
20:37:32 <EvanR> (you didnt paste the actual error message, but i assume you read it)
20:37:47 <noob2000> mapM print (filter_null l)
20:37:54 <EvanR> im trying to say, in so many words, that you need to read these error messages
20:38:01 <noob2000> I am lol
20:38:28 <EvanR> filter not_null is wrong because ....
20:38:39 <EvanR> filter :: (a -> Bool) -> [a] -> [a]
20:38:45 <EvanR> and you put IO [String]
20:39:25 <monochrom> No, I think people have a mental block on error messages. If you write 100 lines of text and label it as blog post, they are able to read it. If you write even just 5 words but label it as error message, suddenly they're subconsciously blind.
20:40:08 <kadoban> In many contexts we've been conditioned to treat error messages as essentially meaningless :-/
20:40:17 <EvanR> if GHC starts outputting blog posts im not going to read them
20:40:49 <monochrom> Even if you say so much as "Syntax error. You need to change 'a' to 'b'", they will "see" it and then still ask, "what should I do?". Yes, we see it happen all the time right here.
20:41:02 <noob2000> oh shit
20:41:04 <noob2000> i fixed it
20:41:08 <noob2000> lol, you guys are awesome
20:41:09 <kadoban> Yeah, a lot of times what it's telling you to do is pretty direct.
20:41:53 <noob2000> nah, its that the format of haskell error messages is 100% foreign to me
20:42:03 <noob2000> they make sense to you because you deal with them regularly
20:42:26 <noob2000> I write a LOT of code in C and other languages and understand their error messaghes quite nicely
20:42:39 <noob2000> thanks for the help guys lol
20:42:53 <noob2000> filter_null :: [String] -> [String]
20:43:08 <noob2000> i had to make the type dec more general
20:43:14 <noob2000> i didnt kn ow that was a thing
20:43:16 <noob2000> xD
20:43:21 <EvanR> noob2000: maybe you should have been asking questions about the error messages then
20:43:22 <noob2000> im used to strict casting
20:43:32 <noob2000> i said i was on day one
20:43:39 <noob2000> and specifically asked about that
20:43:40 <noob2000> lol
20:43:49 <EvanR> its more important than getting your example code to build
20:44:23 <EvanR> also haskell is pretty strict on conversions
20:44:29 <EvanR> C++ is not
20:44:58 <monochrom> I don't think "casting" is relevant here.
20:45:18 <monochrom> I don't even think Haskell has C's sense of "casting"
20:45:57 <EvanR> unsafeCoerceMuthafuckazz
20:46:11 <EvanR> should exist
20:46:28 <falsesentence> hi I am trying to follow the haskellGL tutorial and getting a really basic error. I am hoping that someone else is using deb jessie and knows about error
20:48:29 <EvanR> noob2000: moral of the story, learn how to write proper top level type sigs, yeah [String] -> [String] was probably what you wanted, and then line 14 would have been the obvious error because you were trying to filter an IO action not a list
20:48:42 <pavonia> falsesentence: What are you trying, what error do you get?
20:49:27 <EvanR> top level type signatures are how you give ghc more information, so you can help it help you
20:49:56 <falsesentence> pavonia import Graphics.UI.GLUT
20:49:56 <falsesentence> import Graphics.Rendering.OpenGL
20:49:56 <falsesentence> main = do
20:49:56 <falsesentence>   getArgsAndInitialize   error is *** Exception: user error (unknown GLUT entry glutInit)
20:50:15 <EvanR> when things get hairy you can put more type sigs in other places like where clauses
20:51:39 <falsesentence> wait I mighta got it. I think its system level deps.
20:55:40 <falsesentence> nope. I am following everything I can find via google, keep getting same error
20:55:57 <falsesentence> user error (unknown GLUT entry glutInit)
20:56:03 <EvanR> maybe you need to link against GLUT
20:56:17 <falsesentence> like  ghc -package GLUT -o helloGL helloGL.hs
20:57:01 <EvanR> uh ghc -lGL -lGLU -lglut
20:58:00 <Hafydd> ghc -l -lG -lGL -lGLU -lGLUT -lGLUTT -lGLUTTO -lGLUTTON -lGLUTTONY
20:58:39 * EvanR spins and gets bankrupt
20:59:38 <falsesentence> ghc -l GL -l GLU -l GLUT -o helloGL helloGL.hs
20:59:38 <falsesentence> Linking helloGL ...
20:59:52 <falsesentence> cannot find -lGLUT
20:59:59 <falsesentence> duh...
21:00:19 <EvanR> lowercase?
21:00:34 <falsesentence> ...same
21:00:48 <falsesentence> cannot find -lglut
21:00:56 <falsesentence> tried 2 spaces too
21:01:12 <EvanR> spaces?
21:01:40 <EvanR> you might need to install GLUT, and if its dynamically loading it, you probably dont need the flag
21:02:14 <EvanR> apt-get install freeglut3-dev
21:02:20 <falsesentence> i did cabal install GLUT, and it appeared to work
21:02:30 <falsesentence> that looks likely, lemme try
21:02:54 <falsesentence> sorry I'm asking a yak shaving question, just got really frustrated
21:04:00 <falsesentence> oh happy days! Thankya
21:04:35 <falsesentence> was about to install windows!
21:04:37 <falsesentence> jk
21:05:37 <EvanR> i j k
21:05:40 <EvanR> k i j
21:05:45 <EvanR> j k i
21:06:50 <falsesentence> j i k
21:07:03 <falsesentence> j k i
21:07:27 <falsesentence> i k j
21:07:51 <falsesentence> I kill jargon
21:07:58 <EvanR> > permutations "ijk"
21:08:00 <lambdabot>  ["ijk","jik","kji","jki","kij","ikj"]
21:08:19 <EvanR> @src permutations
21:08:19 <lambdabot> Source not found.
21:09:26 <Hafydd> > map (("d" ++) . ("stra")) (permutations "ijk")
21:09:28 <lambdabot>      Couldn't match expected type ‘[Char] -> [Char]’
21:09:28 <lambdabot>                  with actual type ‘[Char]’
21:09:28 <lambdabot>      In the second argument of ‘(.)’, namely ‘("stra")’
21:09:34 <Hafydd> > map (("d" ++) . (++ "stra")) (permutations "ijk")
21:09:36 <lambdabot>  ["dijkstra","djikstra","dkjistra","djkistra","dkijstra","dikjstra"]
21:09:42 <nshepperd_> you, too, can do the tensor dance
21:11:42 <EvanR> somehow i read that as 6 identical dijkstas
21:11:48 <EvanR> stras
21:13:07 <falsesentence> time to siplmfiy egnislh
21:14:00 <geekosaur> maybe that's your problem. it's dutch :p
21:18:31 <POGtastic> :q
21:18:36 <POGtastic> whoops
21:21:43 <Hafydd> Simplify English by speaking Dutch instead.
21:23:06 <falsesentence> I've written a permutation function before, I am trying to think of one now
21:23:55 <EvanR> theres gotta be a slick one-liner
21:24:30 <falsesentence> I think my roommate, who is better at math than me, thought of one
21:25:02 <EvanR> the permutations of x:xs is the permutations of xs each with x inserted at each position 
21:44:02 <NeverDie> How do you guys usually update Haskell through OS X?
21:44:20 <NeverDie> By manually removing the old files and installing a new one or is there a more methodical way of doing this?
21:47:07 <Tene> NeverDie: I think using stack to manage that is becoming very common on OS X these days.
21:47:10 <Tene> http://docs.haskellstack.org/en/stable/install_and_upgrade/#mac-os-x
21:47:26 <NeverDie> I tried playing with Stack once and it felt very messy.
21:47:32 <NeverDie> Haven't touched it since lol.
21:51:39 <parsnipM_> NeverDie: i just started using stack again
21:52:32 <parsnipM_> i think i always used stack to install ghc though, but i was using cabal sandboxes rather than stack.yaml per directory. 
21:53:08 <NeverDie> parsnipM_: Ah, I have my Haskell install system-wide at the moment.
21:53:19 <NeverDie> https://ghcformacosx.github.io/
21:53:23 <NeverDie> This is what I had used originally.
21:53:31 <Tene> I can't say I know anything about stack on OS X, but it's been very nice for me on linux.
21:53:37 <NeverDie> Any smooth way of uninstalling the current version I have right now?
21:56:42 <EvanR> the smooth way is to know where ghc is installed then delete it
21:57:36 <NeverDie> Aside from that is what I meant lol.
21:57:41 <NeverDie> I thought that was a given.
21:58:02 <EvanR> well, from ghcformacosx it looks like its just in Applications
21:58:51 <EvanR> there is a .ghc dir in your home, but it shouldnt matter. i have several versions of ghc stuff under that
22:01:44 <nshepperd_> let permutations ls = (let f [] xs = [[] | null xs]; f (x:xs) ys = fmap (x:) (f (xs ++ ys) []) ++ f xs (x:ys) in f ls []) -- i'm sure this can be golfed down smaller somehow
22:03:05 * hackagebot courier 0.1.1.3 - A message-passing library for simplifying network applications  https://hackage.haskell.org/package/courier-0.1.1.3 (PhilHargett)
22:03:31 <NeverDie> EvanR: I'm guessing I'd have to remove my previous cabal install as well?
22:03:45 <EvanR> cabal install isn't part of ghc
22:04:07 <NeverDie> Yeah but it won't update with `cabal update`
22:04:19 <EvanR> why not?
22:04:49 <NeverDie> This is all that happened `Downloading the latest package list from hackage.haskell.org`
22:04:55 <NeverDie> And then nothing.
22:05:01 <EvanR> well you got it
22:05:33 <NeverDie> Is it not supposed to update in version?
22:05:55 <EvanR> the package list doesnt depend on ghc either
22:05:55 <NeverDie> It's still at 1.22.0.0
22:06:58 <EvanR> i have 1.22.6.0
22:07:29 <EvanR> 1.22.4.0 of the cabal library
22:07:50 <EvanR> ghc 7.10.2
22:08:15 <NeverDie> EvanR: Any reason you're not using GHC v8?
22:08:15 <EvanR> to update cabal-install maybe you can do cabal install cabal-install
22:08:40 <NeverDie> Doing that now.
22:08:50 <NeverDie> It's now downloading Cabal-1.24.0.0
22:48:06 * hackagebot Concurrent-Cache 0.2.0.0 - A Cached variable for IO functions.  https://hackage.haskell.org/package/Concurrent-Cache-0.2.0.0 (Ofenhed)
22:52:50 <gingitsune> Hey, just starting out with haskell
22:53:04 <gingitsune> On the 1st chapter of Learn You a Haskell
22:53:25 <gingitsune> I can't load a .hs file
22:53:32 <gingitsune> :l filename
22:53:55 <gingitsune> Parse error: naked expression at top level
22:55:13 <nitrix> Can you paste the file's content on lpaste.net?
22:55:19 <gingitsune> The book runs ghci 6.8.2
22:55:57 <gingitsune> I'm so sorry
22:56:17 <gingitsune> I had written == instead of = 
22:56:52 <gingitsune> But the error message isn't all that helpfull
22:58:50 <nitrix> :t (==)
22:58:51 <lambdabot> Eq a => a -> a -> Bool
22:59:53 <nitrix> gingitsune: It seems precise to me. (==) is a function, which made the parser think you wrote a naked expression at the top-level which isn't allowed.
23:02:17 <gingitsune> Fair enough. Hard for a novice to digest then maybe? :D
23:08:06 * hackagebot generics-sop 0.2.2.0 - Generic Programming using True Sums of Products  https://hackage.haskell.org/package/generics-sop-0.2.2.0 (AndresLoeh)
23:18:06 * hackagebot lens-sop 0.2.0.1 - Computing lenses generically using generics-sop  https://hackage.haskell.org/package/lens-sop-0.2.0.1 (AndresLoeh)
23:18:08 * hackagebot json-sop 0.2.0.1 - Generics JSON (de)serialization using generics-sop  https://hackage.haskell.org/package/json-sop-0.2.0.1 (AndresLoeh)
23:48:36 <NeverDie> So how do I download a specific version of GHC through Stack?
23:56:40 <petercommand> NeverDie: stack setup GHC_VERSION
