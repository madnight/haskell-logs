00:14:46 <eklavya> instance (MonadState m, StateType m ~ EventF)
00:14:54 <eklavya> what is meant by the ~ ?
00:17:45 <mniip> "unifies with"
00:18:00 <kaol> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#equality-constraints
00:18:06 <shachaf> It means "equal to".
00:19:06 <eklavya> what does that mean?
00:19:43 <mniip> last time I said that, I think it was monochrom who went on a lengthy explanation on why "equal to" is bad
00:22:03 <eklavya> I am not getting what "equal to" implies in this context
00:22:15 <shachaf> It means they are the same type.
00:22:27 <eklavya> If two types are same, then they are that same type
00:22:27 <shachaf> mniip: What's the explanation?
00:22:30 <eklavya> why have two?
00:22:31 <haasn> eklavya: Double ~ Double succeeds. Double ~ Int does not
00:22:56 <haasn> eklavya: It can be useful when involving variables, for example foo :: (a, Double) ~ (Int, b) => (a,b)  has the type (Int, Double)
00:23:04 <mniip> shachaf, in presence of quatifiers "is equal to" doesn't exactly work
00:23:21 <shachaf> But in this context it *does* mean equality, doesn't it?
00:23:38 <mniip> not really
00:23:47 <mniip> StateType m could be a quantified type
00:23:57 <haasn> eklavya: In this example, ‘StateType m’ depends on m, and this constraint is saying that ‘StateType m’ must be EventF for the instance to work
00:24:00 <shachaf> For example (forall a. a) is not equal to Int
00:25:12 <eklavya> haasn: I still don't understand, i StateType m IS EventF why not just write StateType m OR EventF ?
00:25:34 <mniip> haasn, it expesses the relation between m and EventF
00:26:00 <mniip> eklavya, *
00:26:34 <eklavya> so m is being bound to all values which satisfy this constraint?
00:26:41 <eklavya> is that right?
00:26:55 <mniip> m can be bound to any type that satisfies that constraint
00:27:04 <mniip> so like
00:27:11 <mniip> not much different from a regular constraint
00:27:21 <eklavya> ok
00:27:29 <eklavya> got it :)
00:27:33 <haasn> eklavya: variables in type signatures are picked by the caller (or in this case: the code that uses the instance)
00:28:01 <mniip> haasn, well that depends on the location of the forall
00:28:01 <haasn> perhaps it would point out that (a ~ b) is a constraint, just like (Foo a)
00:28:05 <eklavya> thanks mniip haasn shachaf kaol :)
00:28:09 <haasn> it would help to point out*
00:38:20 * hackagebot language-webidl 0.1.3.1 - Parser and Pretty Printer for WebIDL  https://hackage.haskell.org/package/language-webidl-0.1.3.1 (izgzhen)
00:38:22 * hackagebot servant-purescript 0.2.0.1 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.2.0.1 (eskimo)
00:48:20 * hackagebot haskell-src-exts 1.18.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.18.0 (mpickering)
01:03:21 * hackagebot eternal 0.1.6 - everything breaking the Fairbairn threshold  https://hackage.haskell.org/package/eternal-0.1.6 (Heather)
01:06:48 <jle`> btw i think it's kind of weird that foo :: (Int ~ Bool) => ... doesn't compile
01:07:53 <jle`> when things like foo :: (Integral Void) => ... compile just fine even when there's no instance at compile-time
01:12:03 <shachaf> Well, there could be an instance later.
01:12:23 <shachaf> It's certainly not a problem that Integral Void => ... compiles. It should.
01:12:55 <shachaf> I do kind of which that you could use invalid equality constraints or other invalid constraints in some cases, though.
01:13:09 <shachaf> I posted about it to the mailing list, back when I posted to the mailing list.
01:13:24 <shachaf> data Foo a = a ~ Char => A | a ~ Bool => B -- valid
01:13:43 <shachaf> newtype Bar a = Bar { runBar :: forall r. (a ~ Char => r) -> (a ~ Bool => r) -> r } -- unusable
01:18:21 * hackagebot eternal 0.1.7 - everything breaking the Fairbairn threshold  https://hackage.haskell.org/package/eternal-0.1.7 (Heather)
01:18:31 <mniip> so wait you can't CPS GADTs?
01:19:30 <shachaf> Not as far as I know.
01:19:41 <shachaf> Well, not this way, anyway.
01:28:22 * hackagebot ghc-exactprint 0.5.2 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.5.2 (mpickering)
01:35:48 <jle`> shachaf: yeah, it would make sense for 'Integral Void => Foo' to compile ... that'd mean that it's a Foo you can access in the case that Integral Void can be satisfied
01:36:06 --- mode: ChanServ set +o shachaf
01:36:12 <jle`> `(Int ~ Bool) => Foo` should mean the same thing ... a Foo y ou can access in the case that (Int ~ Bool) can be satisfied
01:36:25 --- mode: shachaf set -qo winsoff!*@* shachaf
01:36:37 <jle`> sort of like the trivial implication
01:36:57 <shachaf> GHC doesn't have a good way to express contradiction.
01:37:05 <shachaf> I wrote another email to the mailing list about that.
01:56:02 <jmi2k> ?src head
01:56:02 <lambdabot> head (x:_) = x
01:56:02 <lambdabot> head []    = error "Prelude.head: empty list"
02:26:09 <zedik> Hi all, how to program this type of computation in Haskell? I suspect that the best way is to mimic loops somehow, because it is not obvious how to use map to do it. http://lpaste.net/171350
02:28:24 * hackagebot apply-refact 0.3.0.0 - Perform refactorings specified by the refact library.  https://hackage.haskell.org/package/apply-refact-0.3.0.0 (mpickering)
02:28:28 <shachaf> Looks like a fold?
02:29:00 <zomg> zip measurements and motions, then fold, seems like what it is :)
02:29:08 <shachaf> Since you loop over measurements and motions together, you can zip them together. That would improve even the Python code.
02:30:14 <shachaf> Then you can use (\(measurement,motion) -> fn2 motion . fn1 measurement) to apply one measurement-motion pair to a value.
02:30:43 <shachaf> Then you can fold over the list of pairs.
02:31:41 <zedik> Thanks !!! 
02:33:20 <bshd> Talking about '~', what does ':-' mean?
02:33:31 <bshd> Seen it in type declarations quite a few times too, IIRC
02:33:46 <zedik> But just in case, is it possible to mimic Python nested loops in Haskell? 
02:34:40 <shachaf> Probably?
02:34:43 <shachaf> That's not a nested loop.
02:35:01 <shachaf> bshd: Nothing in particular. Just a constructor.
02:35:33 <bshd> Oh well, stupid me
02:36:29 <bshd> Thanks, hehe :)
02:36:32 <zedik> Yes, I know, but I have them in another piece of code which I should translate. I saw in the tutorials that in case if it is very needed it is possible to write programs in Haskell in imperative style. But I can't find how to do it. 
02:42:08 <the_2nd> I have weird bugs when using cabal haddock on my project. I get "target 'SECOND WORD IN SYNOPSIS' is not a module or a source file
02:44:03 <sbrg> zedik: run measurements motions = let p = foldl' (\oldp (x, y) -> fn2 x $ fn1 y oldp) (zip measurements motions) in p
02:44:05 <sbrg> something like that
02:44:48 <sbrg> foldl1' probably
02:44:56 <sbrg> no,
02:45:20 <sbrg> maybe
02:45:24 <sbrg> something in that direction anyway
02:45:45 <zedik> sbrg Ok! Thanks! Yes, seems just map doesn't work
02:47:25 <sbrg> that function is a canonical fold really
02:48:24 * hackagebot HGE2D 0.1.7.4 - 2D game engine written in Haskell  https://hackage.haskell.org/package/HGE2D-0.1.7.4 (I3ck)
02:48:47 <hawk78> Hi, suppose I have 2 typeclasses T1 and T2 that expose a method e.g. m1 :: a -> Int and m2 :: a -> Int respctively. Can I write a function that accepts either T1 or T2 instances and produces and Int?
03:05:27 <Kimae> Can someone help me understand the definition of <*> in either: Left  e <*> _ = Left e. isn't e supposed to be of type (a -> b) and the return type should be f b, so how does Left e work as the return value? Isn't Left e of type f (a ->b) and not f b?
03:09:03 <deam> I don't understand how concatMapM is composed? What is the order of operations? https://gist.github.com/anonymous/3291dffcd59ac658f85e2b69ce44a1bd
03:09:47 <raek> Kimae: no, in "Right c" the "c" would be of type (a -> b)
03:10:00 <sbrg> ^
03:10:30 <raek> "Left" means error here, so the first error spotted will be the result of the whole thing
03:10:41 <sbrg> deam: what is the problem exactly?
03:10:44 <prohobo> can haskell be brandished as a weapon
03:10:46 <prohobo> nvm
03:11:16 <raek> (<*>) :: Either e (a -> b) -> Either e a -> Either e b
03:11:43 <raek> only the Right part of the Either is applied
03:12:16 <sbrg> deam: the definition for concatMapM you linked is equal to: concatMapM f xs = do { res <- mapM f xs; return (concat res); }
03:13:15 <Kimae> raek: ah ok. but how is Either e (a -> b) of type f (a -> b)
03:14:03 <deam> sbrg: I don't understand ´liftM concat . mapM f´ the order of precedence
03:14:32 <sbrg> deam: you understand function composition via the composition operator/function (.)?
03:14:42 <deam> sbrg: yes
03:14:42 <sbrg> it's just like function composition in mathematics
03:14:59 <supki_> hawk78: I don't know if this helps, but you can write something like http://lpaste.net/3742207487495897088
03:15:06 <sbrg> compose f g x = f (g x). in this case, f = liftM concat, g = mapM f
03:15:15 <deam> sbrg: does concat and mapM get composed first?
03:15:19 <sbrg> liftM concat (mapM f)
03:15:31 <sbrg> no
03:15:45 <sbrg> <everything here> . <composed with everything here>
03:15:59 <deam> what about the xs?
03:16:07 <sbrg> @src (.)
03:16:07 <lambdabot> (f . g) x = f (g x)
03:16:41 <sbrg> foo f xs = liftM concat (mapM f xs)
03:16:46 <sbrg> forgot that parameter
03:17:08 <raek> Kimae: if you have "Right f :: Either e (a -> b)" as the left operand and "Right x :: Either e a" as the right operand to <*>, then you can use pattern matching to extract the f and the x
03:17:25 <raek> and then return a "Right (f x) :: Either e b" value
03:17:39 <raek> Kimae: does that answer your question?
03:17:56 <sbrg> Kimae: Either isn't an instance of Applicative, but (Either a) is 
03:18:31 <sbrg> :kind Either
03:18:34 <Kimae> Ah now i get thanks.
03:18:42 <sbrg> yw
03:20:58 <deam> sbrg: but liftM can only take concat as the first parameter?
03:21:28 <sbrg> deam: not sure what you mean?
03:21:30 <sbrg> :t liftM
03:21:31 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
03:21:40 <deam> yeah
03:22:01 <deam> the (a1 -> r) part is the concat function right?
03:22:11 <sbrg> yes
03:22:16 <haasn> I have a very big record full of Doubles (and only doubles). I want to make a monoid instance that simply adds all of the doubles (pair-wise), with 0 as the identity. What would be the best way to approach this without writing every single addition myself?
03:22:21 <haasn> Some sort of Generic-type class?
03:22:57 <deam> sbrg: but my composed function executes ´mapM f xs´ first
03:23:09 <sbrg> it does yes
03:23:47 <deam> sbrg: so I don't understand why I can use liftM anyway
03:24:48 <sbrg> :t mapM
03:24:49 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
03:25:30 <sbrg> liftM takes a function of type (a -> b) and a value of type `m a`, lifts the function into the monad and applies it to the value to return `m b`
03:25:44 <ertesx> haasn: i'd make the type parametric and derive Foldable, Functor and Traversable to start
03:25:58 <ertesx> haasn: then i'd write an Applicative instance, and finally a Monoid instance
03:26:13 <sbrg> mapM takes a function (a -> m b) and a list of values of type `a` to return `m [b]`
03:26:14 <haasn> hmm, decent idea
03:26:17 <sbrg> well, specialized to list, anyway
03:27:52 <sbrg> mapM f has type `[a] -> m [b]` and liftM concat has type `m [[a]] -> m [a]`. 
03:27:54 <ertesx> haasn: instance Monoid MyType where mappend = liftA2 mappend; mempty = pure mempty
03:27:56 <deam> sbrg: yes but liftM takes the concat function as the first parameter but what gets executed first is actually ´mapM f xs´ which returns m[b]??
03:28:12 <deam> sbrg: it just doesn't match up..
03:28:14 <ertesx> haasn: similarly Fractional, IsString, Num, etc.
03:28:15 <sbrg> deam: it does
03:28:22 <sbrg> the compiler is telling you that it does in that it's typechecking
03:29:23 <deam> sbrg: maybe I should just accept it? I don't think it matches up..
03:29:35 <sbrg> deam: in this case, `b` in the first type above becomes `[a]`. 
03:29:37 <sbrg> :t (.)
03:29:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
03:29:52 <sbrg> deam: let's just insert all the types we know
03:30:40 <sbrg> mapM f :: [a] -> m [[a]]. liftM concat :: m [[a]] -> m [a]. 
03:31:33 <deam> oh
03:31:53 <deam> or
03:31:58 <sbrg> so we have: (.) :: ([a] -> m [[a]]) -> (m [[a]] -> m [a]) -> m [[a]] -> m [a]
03:32:15 <sbrg> a = [a], b = m [[a]], c = m [a]
03:32:54 <sbrg> ^ are the types in (.) specialized to the types of the functions you have
03:32:58 <sbrg> does it begin to make sense?
03:33:03 <haasn> ertesx: A bit I'm struggling on is a simple ‘pure’. I figure I can write  pure x = x <$ Record{} but this gives me a GHC warning. I guess I could just turn off the warning, but maybe there's a more elegant way?
03:33:33 <deam> sbrg: didn't concat and ´mapM f xs´ get composed first?
03:33:34 <haasn> Also I still need boilerplate for the (<*>) as far as I can tell
03:33:59 <sbrg> deam: nope
03:34:15 <sbrg> the precedence of the (.) operator is such that it composes everything on the left with everything on the right
03:34:21 <sbrg> with some caveats, of course
03:34:37 <deam> sbrg: I see, thank you!
03:34:38 <sbrg> but it's (liftM concat) . (mapM f)
03:34:57 <deam> sbrg: it all make sense now
03:35:47 <sbrg> good!
03:37:11 <haasn> ertesx: Ah, it doesn't even work because my fields are strict :(
03:38:01 <sbrg> haasn: the Record type, what does it contain?
03:38:07 <sbrg> Record {} doesn't sound like a valid empty record
03:39:36 <haasn> sbrg: It contains a bunch of statistics, the fields are unrelated but I want a Monoid instance so I can use foldMap etc. to combine the statistics for an entire list of things
03:39:43 <haasn> (combining means adding)
03:40:00 <haasn> my “zero” (mempty) record has 0 for every value
03:40:24 <haasn> I want to avoid at all costs hard-coding a full list of these fields
03:41:09 <sbrg> haasn: oh, so it's like.. data Record = Record { x :: Double, y :: Double.. } etc?
03:41:46 <sbrg> because if you represented it as a Map or something like that, you could simply use Map.empty
03:41:57 <haasn> sbrg: Map is not a good fit (imo)
03:42:05 <sbrg> so it's a lot of fields?
03:42:10 <sbrg> in the Record
03:42:40 <sbrg> there's nothing you can do except define some sort of valid empty record. even if it's a lot of values to hard-code you only have to do it once
03:42:55 <haasn> Couldn't I use something like GHC.Generics to construct it?
03:43:00 <samcv> what's the demonym for people who use Haskell, Haskellites?
03:43:09 <haasn> “Haskellers” I think
03:44:10 <ertesx> haasn: just write 'pure' straightforwardly
03:46:39 <ertesx> haasn: how many fields do you have?
03:47:04 <haasn> 13, but I'll manage. Mostly the annoyance is that I'm adding new fields often
03:47:27 <ertesx> haasn: you could construct the type differently
03:47:41 <ertesx> data Prop = Field1 | Field2 | Field3 | …
03:47:43 <deam> what is this, ´{-# LANGUAGE DataKinds #-}´?
03:47:59 <ertesx> newtype MyType a = MyType { property :: Prop -> a }
03:48:13 <ertesx> then pure = MyType . const
03:48:29 <ertesx> you also get Functor, but you won't get Foldable and Traversable any longer
03:48:46 <ertesx> (or you write them yourself and be careful enough)
03:49:21 <ertesx> you can derive Enum and Bounded for Prop, so that Foldable can be written in terms of minBound and maxBound instead of enumerating every field
03:51:02 <haasn> ertesx: I'm using RecordWildCards quite heavily, the field syntax is very useful for this
03:51:28 <ertesx> haasn: then write 'pure'…  you're going to have to write (<*>) by enumerating, too
03:51:40 <haasn> I did, using a vim macro
03:51:51 <haasn> the point is: shouldn't I be able to do it automatically with generics et al?
03:52:13 <ertesx> probably…  i wouldn't know how
03:53:43 <mikail`> Hi, in my example here: http://lpaste.net/171363, is it possible to simplify this function any further? The only difference between the patterns is that depending on the type (ie. Equity, Currency...) the argument to the 'b' parameter in the `call` and `put` functions changes.
03:55:03 <ertesx> mikail`: instead of pattern-matching directly on the left side of "=", use 'case'
03:55:19 <ertesx> mikail`: then you can factor out using 'where'
03:55:42 <mikail`> ertesx: I'm not quite sure what you mean
03:56:38 <ertesx> mikail`: price blah r v = case blah of …;  where f s k t y = case c of …
03:57:10 <ertesx> apply 'f' with y = r - q, y = 0 or y = r - rf depending on the case
03:58:26 * hackagebot stylish-haskell 0.6.1.0 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.6.1.0 (JasperVanDerJeugt)
03:58:28 * hackagebot turing-machines 0.1.0.0 - A simple simulator for Turing machines  https://hackage.haskell.org/package/turing-machines-0.1.0.0 (jariazavalverde)
04:00:30 <mikail`> ertesx: thanks, I get it now.
04:00:35 <haasn> (wow, compilation of this takes forever)
04:00:59 <haasn> deriving Foldable/Traversable seems to be the slowdown
04:01:22 <ertesx> haasn: GHC isn't particularly fond of large types =)
04:01:27 <rightfold> Hi, where can I find the Haddock documentation of the ghc package? It used to be here: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/index.html
04:01:47 <ertesx> haasn: you can help it by splitting it up into separate units…  it can still derive everything
04:02:15 <ertesx> data T1 a = …;  data T2 a = …;  data T a = T (T1 a) (T2 a)
04:02:33 <haasn> I'd rather pay the compile hit than the code hit :)
04:02:52 <ertesx> (bang the parens, if you want strict fields)
04:03:01 <ertesx> (that sounded weird…)
04:11:35 <maerwald> omg, I just misread that
04:18:33 <deam> how does readUTF8File access inFile? https://gist.github.com/anonymous/d8ed56a3efa4db6c264039e78d572e47
04:21:09 <rightfold> it is passed as an argument
04:22:00 <deam> rightfold: is ´(inFile, )´ a function?
04:22:09 <rightfold> yeah
04:22:13 <deam> oh...
04:22:19 <rightfold> but you need the TupleSections extension enabled
04:22:34 <rightfold> it's equivalent to \x -> (inFile, x)
04:22:44 <Hafydd> Or (,) inFile.
04:24:00 <deam> rightfold, I see thank you
04:29:20 <maerwald> :t (3,)
04:29:21 <lambdabot> Num t => t1 -> (t, t1)
04:51:14 <raichoo> ls
04:51:18 <raichoo> whoops ^^
05:08:21 <the_2nd> hackage stopped trying to build my package after some failed vrsions?
05:08:35 <the_2nd> how can I enable builds again?
05:09:56 <samcv> what is the haskell mascot. is there any unofficial one?
05:10:12 <the_2nd> a purple lambda
05:10:18 <the_2nd> it doesn't do much, tho
05:10:27 <samcv> that's a logo not a mascot tho
05:10:27 <the_2nd> also needs no food, which is nice
05:10:40 <samcv> though the mascot of Stanford university is Cardinal
05:10:43 <samcv> as in the color
05:11:39 <samcv> so i guess if a color can be a "mascot" then i guess a purple lambda can, i guess
05:23:22 <maerwald> that sounds boring
05:23:32 <maerwald> wasn't spj suggesting something now and then on the ML?
05:25:36 <cloudhead> is there a way to get ghc to keep checking errors in all files, instead of stopping at the first file?
05:28:41 <maerwald> how does that work if a "to-be-imported" file doesn't build?
05:30:02 <cloudhead> hmm yeah that wouldn't work
05:30:59 <cloudhead> does it work outside of that though? say if A depends on B,C,D, it should be able to show build errors in B,C,D
05:33:02 <Mario_P_Luth> Hi guys, anyone could sent me a little review about the Allen's book HPFFP?
05:34:06 <mikail`> Is there a paper or some other reference which describes how typeclasses work under the hood in Haskell?
05:34:13 <cloudhead> Mario_P_Luth: did you see the free sample?
05:35:21 <ertesx> mikail`: read "=>" as "->" and think of type classes as regular types: data Monoid a = Monoid { mappend :: a -> a -> a, mempty :: a }
05:36:25 <cloudhead> mikail`: afaik, this is the paper that introduced them: http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps
05:36:47 <ertesx> mikail`: in essence type classes are a fancy way to pass automatically chosen arguments implicitly
05:37:06 <Mario_P_Luth> cloudhead: yes, but didn't try it out. I'll read it (y)
05:37:55 <cloudhead> Mario_P_Luth: ok, from what I heard from people who have tried it out, it's probably the best beginners book there is right now
05:38:03 <mikail`> thanks - I have used them in the past with good effect but I just want to deepen my understanding of them.
05:38:29 * hackagebot hw-prim 0.0.3.4 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.3.4 (haskellworks)
05:38:42 <maerwald> cloudhead: you can use parallel build, but even that doesn't figure out the dependencies like that
05:38:50 <maerwald> it might just "go further" by chance
05:38:56 <ertesx> cloudhead, Mario_P_Luth: i've heard the exact opposite
05:39:21 <cloudhead> maerwald: gotcha, thanks
05:39:30 <ertesx> i haven't read it myself, but judging by the reviews of some knowledgable people it has to be the most terrible book
05:39:36 <cloudhead> haha
05:39:39 <cloudhead> hmm
05:39:48 <Mario_P_Luth> cloudhead: Hummm, that's good. Actually I've read Learn You a Haskell for Good but the lack of exercices makes everything a little bit confusing...
05:40:08 <maerwald> cabal install --jobs=10 or something
05:40:20 <cloudhead> that would be ironic, given how critical the author is of other learning resources
05:40:29 <ertesx> cloudhead: yeah
05:40:34 <cloudhead> Mario_P_Luth: http://bitemyapp.com/posts/2014-12-31-functional-education.html this might be of interest
05:40:45 <cloudhead> the author of the book talks about other books
05:40:58 <Mario_P_Luth> thanks
05:41:34 <Mario_P_Luth> ertesx: What you heard? I'm curious lol
05:42:00 <ertesx> i'm reluctant to recommend any resource, but i feel safest recommending Real World Haskell, until this one gets a second edition: http://www.cs.nott.ac.uk/~pszgmh/book.html
05:42:38 <cloudhead> Mario_P_Luth: also you might want to check out #haskell-beginners, it's the (official?) channel for the book
05:42:40 <Mario_P_Luth> ertesx: I don't want to make a turmoil, just know a little bit...
05:43:10 <ertesx> Mario_P_Luth: if you want to be safe, wait for the latter one i just linked
05:43:11 <cloudhead> yeah, I would recommend Real World Haskell
05:43:32 <Mario_P_Luth> cloudhead: I just get there.
05:43:44 <Mario_P_Luth> thanks, guys.
05:44:42 <cloudhead> Mario_P_Luth: the one advantage of HPFFP is that there are many people going through the exercises right now, so it's easy to get help
05:44:56 <cloudhead> on the channel I mentioned
05:48:30 * hackagebot psqueues 0.2.2.2 - Pure priority search queues  https://hackage.haskell.org/package/psqueues-0.2.2.2 (JasperVanDerJeugt)
05:48:44 <ertesx> i'd prefer not to encourage anything that makes the community fragmentation any worse than it already is
05:48:56 <ertesx> so i encourage people to come here
05:53:30 * hackagebot blaze-markup 0.7.1.0 - A blazingly fast markup combinator library for Haskell  https://hackage.haskell.org/package/blaze-markup-0.7.1.0 (JasperVanDerJeugt)
05:58:30 * hackagebot blaze-html 0.8.1.2 - A blazingly fast HTML combinator library for Haskell  https://hackage.haskell.org/package/blaze-html-0.8.1.2 (JasperVanDerJeugt)
06:03:30 * hackagebot websockets 0.9.7.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.9.7.0 (JasperVanDerJeugt)
06:13:31 * hackagebot poppler 0.14.1 - Binding to the Poppler.  https://hackage.haskell.org/package/poppler-0.14.1 (IanWooKim)
06:36:39 <maerwald> where do you get HPFFP for free?
07:11:06 <ben______> hi
07:12:20 <ben______> i have a question about fmap, im not sure why "fmap (+100) $ 1" doesnt work, while "fmap (+100) $ [1]" works
07:13:11 <ben______> and "fmap (+100) (*3) $ 1" works, but not "fmap (+100) (*3) $ [1]"
07:13:23 <thewormkill> :t fmap
07:13:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:13:39 <thewormkill> now, is "1" a value of a type that is a functor, ben______?
07:13:48 <thewormkill> or rather, 1
07:14:07 <ben______> :t 1
07:14:08 <lambdabot> Num a => a
07:14:19 <thewormkill> that's a no.
07:14:23 <ben______> :info Num
07:14:51 <thewormkill> now, onto your second question: why does "fmap (+1) (*20) $ 1" work?
07:15:03 <thewormkill> well, functions are functors
07:15:05 <ben______> but why does it work in the second case still dont quite get it
07:15:27 <thewormkill> so your fmap (+1) (*20) evaluates to a function, whcih then gets applied to the value 1
07:15:56 <thewormkill> to understand how that works, look at the corresponding Functor instance
07:16:11 <thewormkill> or guess based on the results :)
07:17:10 <ben______> okay, thanks a lot :D now i know that functions are functors, ill try to digest this...
07:17:39 <thewormkill> yw
07:17:42 <ben______> how do i know that functions are functors?
07:17:55 <ben______> how can i check if it is a functor?
07:18:40 <liste> ben______: use :info Functor in ghci
07:18:50 <fr33domlover> ben______, or :info (->)
07:19:00 <liste> it shows all types that are instances of Functor (in the currently imported files)
07:19:38 <ben______> ((->) r) this one?
07:19:55 <liste> ben______: yes
07:20:12 <ben______> great, thanks a lot :)
07:20:16 <Rotaerk> fmap generally uses the passed in function to transform the things that are within/produced-by the functor
07:21:16 <bernalex> ben______: <$> = (.) for functions.
07:21:30 <bernalex> :t (<$>)
07:21:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:21:33 <bernalex> :t (.)
07:21:34 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:22:23 <ben______> okay OAO
07:22:31 <bernalex> use (->t) for f in the type of <$>, and you get (.).
07:23:16 <ben______> can you give an example maybe 0.0
07:23:25 <ben______> the use of <$>
07:23:51 <Rotaerk> <$> is just an operator version of fmap
07:24:04 <liste> > (+1) <$> (*2) $ 5
07:24:06 <lambdabot>  11
07:24:17 <liste> > fmap (+1) (*2) $ 5
07:24:19 <lambdabot>  11
07:24:20 <Rotaerk> > (+1) <$> Just 5
07:24:22 <lambdabot>  Just 6
07:24:31 <Rotaerk> > fmap (+1) (Just 5)
07:24:32 <lambdabot>  Just 6
07:24:56 <bernalex> (a -> b) -> f a -> f b -- with list you get (a -> b) -> [a] -> [b]. with (->t) you get (a -> b) -> (t -> a) -> t -> b.
07:25:06 <Eduard_Munteanu> > (+) <$> Just 3 <*> Just 5
07:25:07 <lambdabot>  Just 8
07:25:23 <ben______> so fmap (+1) (Just 5) and  (+1) <$> Just 5 is basically the same 0.0?
07:25:35 <Eduard_Munteanu> Yes.
07:25:37 <bernalex> > show . abs $ 5
07:25:39 <lambdabot>  "5"
07:25:41 <Rotaerk> > (+1) `fmap` Just 5
07:25:42 <bernalex> > show <$> abs $ 5
07:25:44 <lambdabot>  "5"
07:25:44 <lambdabot>  Just 6
07:25:55 <Eduard_Munteanu> :t (<$>)
07:25:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:26:13 <bernalex> ben______: yes. use the types.
07:26:17 <bernalex> :t fmap
07:26:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:26:28 <bernalex> as you can see, they're the same.
07:26:39 <bernalex> > (<$>) show abs $ 5
07:26:40 <Eduard_Munteanu> @src (<$>)
07:26:40 <lambdabot> f <$> a = fmap f a
07:26:41 <lambdabot>  "5"
07:26:49 <bernalex> > show `fmap` abs $ 5
07:26:51 <lambdabot>  "5"
07:27:52 <Eduard_Munteanu> @src (.)
07:27:52 <lambdabot> (f . g) x = f (g x)
07:27:59 <Rotaerk> > ((+1) <$> (*5)) 3
07:28:01 <lambdabot>  16
07:29:58 <shirt> @pl \x -> if foo then bar else x
07:29:58 <lambdabot> if' foo bar
07:30:04 <shirt> where is if'?
07:31:59 <bernalex> shirt: if' True = const; if' False = const id
07:32:16 <bernalex> and then fi = flip . flip if'
07:32:52 <shirt> what module is it exported from?
07:33:13 <bernalex> shirt: I don't recall it being in base.
07:33:27 <liste> :t bool -- there's bool though
07:33:28 <lambdabot> a -> a -> Bool -> a
07:33:36 <liste> with different argument order
07:33:37 <shirt> hm.. so why lambdabot recommending to use it?
07:33:38 <liste> @index bool
07:33:38 <lambdabot> Data.Bool
07:34:01 <bernalex> shirt: I assume lambdabot is using the pointfree program.
07:34:31 <bernalex> hah. actually (I just checked), the pointfree tool came *after* lambdabot, so it's the other way around.
07:35:02 <bernalex> I don't know why it recommends it then. but if' is a very common and well-known function, even if it isn't in base.
07:35:13 <bernalex> and if-then-else is stupid.
07:35:17 <bernalex> gief mixfix amirite
07:38:19 <shirt> bernalex: do you know which package it is defined in then? i can't seem to find it anywhere
07:38:41 <bernalex> shirt: probably a bunch. we had it in our prelude-extension package at my company.
07:39:01 <bernalex> just define it yourself. it's not exactly a complicated function.
07:39:16 <Rotaerk> https://www.stackage.org/lts-6.8/hoogle?q=if%27
07:40:08 <Rotaerk> utility-ht looks like what you want
07:41:12 <shirt> thanks!
08:08:35 * hackagebot gitHUD 1.3.3 - More efficient replacement to the great git-radar  https://hackage.haskell.org/package/gitHUD-1.3.3 (gbataille)
08:13:35 * hackagebot async-ajax 0.2.0.0 - Crossbrowser async AJAX Bindings for GHCJS  https://hackage.haskell.org/package/async-ajax-0.2.0.0 (AlexanderThiemann)
08:23:36 * hackagebot classy-prelude 1.0.0.1 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-1.0.0.1 (MichaelSnoyman)
08:41:50 <Gurkenglas_> When I try install gloss via stack on this Win 10 machine, I get this: http://lpaste.net/4783204412111716352
08:41:54 <Gurkenglas_> What do?
08:46:12 <Welkin> Gurkenglas_: stack install --install-ghc
08:46:20 <Welkin> or use an older version of gloss?
08:47:13 <Gurkenglas_> Welkin, just that or including "gloss"?
08:49:32 <Gurkenglas_> (And shouldn't stack be automatically installing the latest version that fits with its packages?)
08:49:38 <Welkin> well, if you need a newer version of base, you need to upgrade ghc
08:50:34 <Gurkenglas_> Welkin, http://lpaste.net/6711621530897350656
08:51:28 <Welkin> yeah
08:51:39 <Welkin> you need to run it with a stack.yaml file in your project directory
08:53:57 <Welkin> you can look at this as an example http://www.yesodweb.com/page/quickstart
08:55:53 <Gurkenglas_> Welkin, can't I install gloss globally?
08:56:04 <Welkin> why would you?
08:56:19 <glguy> Gurkenglas_: you're trying to use stack like cabal install, it's a different model
08:56:27 <Welkin> with stack, you can install it locally for a project and then if you want to start a new project, it will just copy from the cache
08:56:49 <Welkin> you can also easily use multiple versions of ghc this way
08:57:03 <glguy> You make a new stack project with a stack.yaml and you pick a resolver that has the packages you wanted
08:57:13 <Gurkenglas_> Looks like it has the same outcome from within a project http://lpaste.net/8836730787287007232
08:57:55 <glguy> Otherwise you should read through the output you pasted, it tells you various ways to proceed
08:59:12 <Gurkenglas_> I added that dependency to the global .yaml and that did nothing, the last few times I had a problem and it suggested stack solver that didnt help, and filling in name etc. shouldnt affect this right
08:59:30 <Gurkenglas_> (added it to the global .yaml before doing this project thing)
09:00:06 <Gurkenglas_> Whats the difference between stack install and cabal install? On another machine they seemed to do the same things
09:01:56 <Gurkenglas_> But heres the dependency added to the local .yaml and a run of stack solver: http://lpaste.net/2025833685797830656
09:03:32 <Gurkenglas_> <Welkin> or use an older version of gloss? <- how?
09:04:17 <Gurkenglas_> (And why does stack install gloss try to install a version that needs base versions that aren't in the current stack snapshot?)
09:09:09 <Welkin> Gurkenglas_: you can specify the versio you want to install in your stack.yaml
09:09:12 <Welkin> or your cabal file
09:13:38 * hackagebot turing-machines 0.1.0.1 - A simple simulator for Turing machines  https://hackage.haskell.org/package/turing-machines-0.1.0.1 (jariazavalverde)
09:15:35 <Gurkenglas_> I didn't find out how, but setting the .yaml extra-deps to [gloss-rendering-1.10.1.1] (which uses base 4.8.*) and then doing "stack install gloss-1.10.1.1" seems to work
09:15:38 <Gurkenglas_> (even globally)
09:26:57 <Welkin> yeah, that is how you do it
09:34:55 <gibbers> hey, how is haskell game development? I'm hoping to use it for the backend for a game I'm working on, but I was curious about what state it's in
09:35:16 <sbrg> depends on what kind of games you're referring to. 3d?
09:35:19 <gibbers> I've noticed that there's bindings to SDL, but I'm probably not good enough at haskell to write my own engine
09:35:22 <gibbers> honestly either
09:35:27 <gibbers> I'm just curious
09:35:34 <maerwald> gibbers: it's rather non-existent
09:35:35 <bernalex> for backend it's quite good.
09:35:41 <sbrg> I think there's some work being done on a high-level 3D engine, can't remember its name. lambdasomething?
09:35:48 <gibbers> right now I'm leaning towards using it for the backend then learning Unity for the actual client
09:35:52 <bernalex> I've made a few simple servers, and they've went well enough.
09:36:08 <gibbers> maerwald: dang, that's what I figured, honestly
09:36:09 <bernalex> hedgewars uses haskell, for a more stable and sophisticated example.
09:36:19 <maerwald> gibbers: common game development practices don't mix very well with the way haskell forces you to think about your design
09:36:36 <bernalex> that's utter nonsense
09:36:43 <maerwald> yep, hedgewars is a mix of c++, lua, pascal and haskell
09:36:50 <maerwald> where haskell is _only_ used for the server
09:37:41 <bernalex> gibbers: most commercial haskell gamedev has been for phones. but there are quite a few people over at #haskell-game, you should check it out. there's hardly anything by way of middleware. but for a backend server thing, it should work very well.
09:38:27 <bernalex> sbrg: do you mean lambdacube?
09:38:33 <sbrg> bernalex: that may be the one?
09:38:36 <sbrg> not sure
09:38:39 <bernalex> it's a rendering engien.
09:38:40 <maerwald> gibbers: as in... you add stuff and effects as you go and none of that really changes your API that much. That's not how haskell works
09:38:41 <bernalex> engine.
09:38:58 <bernalex> maerwald: that's not really how game development is done post-90s.
09:39:07 <Gurkenglas_> What do I do when running a haskell-written executible that uses gloss says "slider.exe: user error (unknown GLUT entry glutInit)"
09:39:10 <maerwald> bernalex: I disagree
09:39:12 <bernalex> well, several people still do it, I'm sure, but not most people who know anything.
09:39:29 <gibbers> thanks! I just wanted to see if I could avoid learning C# at the same time as haskell but I guess I'll just suck it up haha
09:39:35 <bernalex> games now are written in rigid modern c++ with CSE.
09:39:37 <Gurkenglas_> Is it something like "You've installed the bindings to opengl but haven't installed opengl"?
09:39:56 <Gurkenglas_> (http://gloss.ouroborus.net/ says I dont have to worry about that)
09:39:58 <Welkin> what do you mean by backend?
09:39:58 <sbrg> Gurkenglas_: something like that. maybe it can't load the opengl dll
09:40:03 <maerwald> gibbers: C# becomes rather complicated too with large game projects, performance-wise
09:40:05 <Welkin> haskell for web servers is amazing
09:40:12 <Welkin> for game development, there is not much of an ecosystem
09:40:14 <Welkin> if that is what you mean
09:40:27 <bernalex> maerwald: that's not really true, unless you have some very weird metric for "large".
09:40:37 <maerwald> bernalex: see OpenRA
09:40:37 <bernalex> there are several c# games with hundreds of thousands of line of code.
09:40:54 <bernalex> well, if you don't know what you're doing, it's going to go bad regardless of lang.
09:40:58 <maerwald> they have various problems with performance that they could not solve for 2+ years
09:41:21 <bernalex> and c# has a lot of cool libraries and middleware. mono lets you use it on GNU+Linux too.
09:41:30 <maerwald> sure, but that wasn't the point
09:41:31 <Gurkenglas_> arg im stupid i didnt remove the slider.exe when Ctrl-Fing for my phrase, my error is well known.
09:41:50 <maerwald> I've talked with the main developers of OpenRA and they said C# is complicated and they would not choose it another time
09:42:03 <maerwald> (performance-wise that is)
09:42:29 <bernalex> have they written everything from scratch? because commercial devs using c# seem happy enough using the readily available libraries and middleware.
09:42:43 <maerwald> bernalex: OpenRA is written "from scratch"
09:43:06 <gibbers> I've done some game dev before and I've learned a bit of unity already so I think learning haskell is still going to be the hard part
09:43:12 <bernalex> well, then their engine probably sucks. maybe it sucks because c# is extraordinarily difficult, but somehow I doubt it.
09:43:24 <maerwald> bernalex: check the git repository if you want to see the libraries
09:43:28 <bernalex> I really don't.
09:44:05 <maerwald> I tend to believe what a professional C# dev says who has written 200+ LOC game engine code. But okay.
09:44:11 <maerwald> *200k
09:44:48 <bernalex> that's one out of very many c# devs. the engine likely sucks because of some bad choice somewhere, and since it's not haskell, refactoring isn't the funniest job on earth.
09:45:13 <maerwald> well, seems you are already familiar with the codebase
09:45:32 <bernalex> I've seen a lot of shitty running free software c++ game code. to extrapolate that into "c++ isn't suitable for gamedev" would be absurd.
09:46:17 <Gurkenglas_> http://gloss.ouroborus.net/ should say more than just "install glut32.dll". The first google result is offering to solve all my glut32.dll-related problems forever for just 24,95!
09:46:34 <maerwald> I've just stated the experience of someone has written an engine in C# from scratch. And I hold that experience to be more useful than random guessing.
09:47:54 <bernalex> the fact that there are several commercially successful computer games that run perfectly well, that are also written in c#, isn't random guessing as much as just an observable fact.
09:48:25 <maerwald> bernalex: I said "C# becomes rather complicated too with large game projects, performance-wise", I didn't say you can't do it.
09:48:27 <bernalex> gibbers: what kind of gamedev are you actually talking about?
09:48:41 <bernalex> maerwald: s/C#/programming/
09:49:00 <maerwald> I'm not making such gernalizations.
09:49:11 <monochrom> Just don't believe anyone.
09:49:24 <bernalex> performance is complicated for big games. that's just how it is. games push it.
09:49:59 <maerwald> it's about the amount of control the language gives you, it's just not about "complexity"
09:50:04 <bernalex> it's not like it's easy to ensure good performance in haskell just because it's high-level, or c just because it's zomg fast.
09:50:27 <gibbers> bernalex: I want to make a simple multiplayer mmo-style game for practice. Click to move, click to attack, collect items, gain exp. I'm not going for MMO scale, I just want some practice syncing game states and rendering a simple game
09:50:35 <bernalex> gibbers: simple mmo lol
09:50:51 <bernalex> gibbers: I've used haskell for a dedicated server and clients, and that went well.
09:50:56 <gibbers> well the reason MMOs are hard is the "massive" part
09:51:03 <gibbers> I want to do like 10 players lol
09:52:00 <bernalex> gibbers: ok so it depends on how much you want to dogfood, really. if you want a ready-made physics/game engine, then haskell might not be a good choice. unless your game is going to be 2D -- then there's actually some stuff there.
09:52:16 <maerwald> Any language that has automatic garbage collection requires more sophisticated optimizations and very good knowledge about how the garbage collector behaves in order to make smart optimizations. In more low-level languages, that becomes more easy, but also more repetitive. There is a clear difference. Writing high-performance code in java is also not particularly easy.
09:52:47 <bernalex> gibbers: if you're making a multiplayer roguelike, for instance, haskell will be great. multiplayer 2D, haskell is mostly okay. multiplayer 3D, yeah, no.
09:53:08 <bernalex> gibbers: regardless, you can still use haskell for the server, easily. just write a dedicated server, and define a way to speak to it.
09:53:20 <maerwald> also, the C# GC also allows for a lot of memory leaks
09:53:47 <bernalex> maerwald: writing performant code in C is a nightmare too, because of how easy it is to make a mistake. I would not say it is any easier to optimise a C game than a Java game.
09:54:04 <bernalex> you can optimise the C game further than the Java game, but that is likely irrelevant in 99% of all examples.
09:54:28 <maerwald> bernalex: I would say it's easier, because you just have to know about memory, not about GC logic and implementation details.
09:55:16 <bernalex> I suggest you write a 500K SLOC game project in each language, and then come back to me with the results. for science!
09:55:43 <Welkin> sloc isn't a menaingful metric...
09:55:52 <Welkin> meaningful*
09:56:40 <bernalex> in any event I am willing to bet that in terms of overall complexity and productivity, I would rather have a high-level language like haskell, than c.
09:56:53 <monochrom> why are we arguing over this?
09:56:57 <maerwald> for fun?
09:57:19 <bernalex> Welkin: sure it is. it's not necessarily meaningful by itself, or without any further context. but it's meaningful.
09:57:28 <monochrom> well, I guess there is a silver lining: you are not polluting my favourite #haskell-offtopic with this.
09:57:57 <bernalex> monochrom: I don't know if I'd say anyone is arguing. but we're discussing this because someone asked about using haskell for games. so gamedev came up.
09:58:47 <maerwald> bernalex: also, writing 500k SLOC in java isn't even that hard, you'd have to be more specific :P
09:59:06 <maerwald> I'd even say you barely get something useful with JUST 500k xD
09:59:27 <maerwald> while 500k SLOC in haskell is insane
09:59:39 <bernalex> maerwald: yeah I meant comparable gamedev projects, not Quake 5 in C, and fizzbuzz in java.
10:00:24 <maerwald> I feel hedgewars made the right decisions about their language choices (maybe except for pascal, which is a bit weird)
10:00:32 <bernalex> I wrote like 5K of Java once, and all it did was pretty much turn on the GPS.
10:01:35 <bernalex> maerwald: I think c++ is a bit odd too
10:01:48 <bernalex> c++ for the *game*, sure. but c++ explicitly for the frontend? and pascal for the game? wat?
10:01:56 <maerwald> xD
10:02:08 <bernalex> but, hey, it's a great game.
10:02:30 <bernalex> the gearhead series is also written in freepascal (a turbopascal dialect iirc)
10:02:43 <glguy> This discussion has diverged from being about Haskell programming
10:03:00 <bernalex> glguy: that's OK. there's no traffic, so nobody's being disturbed.
10:03:13 --- mode: ChanServ set +o monochrom
10:03:15 <glguy> Sorry, that's not how the topic works
10:03:18 --- mode: monochrom set +b *!*@gentoo/developer/fsf.member.bernalex
10:03:19 --- kick: bernalex was kicked by monochrom (bernalex)
10:03:35 <monochrom> Yes, invoking that fallacy is bannable.
10:13:40 * hackagebot heckle 2.0.0.2 - Jekyll in Haskell  https://hackage.haskell.org/package/heckle-2.0.0.2 (2016rshah)
10:16:45 --- mode: monochrom set -b *!*@gentoo/developer/fsf.member.bernalex
10:16:49 --- mode: monochrom set -o monochrom
10:27:58 <ARM9> encode from Data.Binary seems to prepend garbage when encoding a [Word32] to ByteString
10:28:11 <ARM9>    0:	00000000 	nop   4:	000000aa 	0xaa
10:28:33 <glguy> Data.Binary is prefixing the list length
10:28:39 <Zemyla> ARM9: Does said ByteString decode properly?
10:28:41 <ARM9> makes sense
10:28:49 <ARM9> Zemyla, it probably does considering what glguy mentioned
10:28:57 <ARM9> but I'll try it for good measure
10:29:06 <glguy> The Binary class is for opaque serialization and deserialization to a ByteString
10:29:24 <glguy> You aren't supposed to care about the encoding when using it
10:30:14 <Zemyla> Also, I need to learn how to use Hindley-Milner.
10:31:00 <Zemyla> Abd by "use" I mean "write a type inference engine".
10:31:13 <gibbers> would deserializing a malicious ByteString cause security issues?
10:31:41 <gibbers> I don't know much about how haskell handles encoding/decoding stuff to bytestrings
10:31:44 <ARM9> in that case I was probably suggested the wrong function, what I need to do is write the bytes of a [Word32] to a file
10:32:22 <Zemyla> gibbers: It might run out of memory, but I don't think it will cause things like remote execution.
10:32:30 <gibbers> but I know in other languages reading/writing data structures directly from a file/network is a bad idea
10:32:45 <glguy> ARM9: I'd recommend using the Data.ByteString.Builder module along with one of word32LE/word32BE
10:33:01 <Zemyla> gibbers: Data.Binary reading is more along the lines of parsing.
10:33:02 <glguy> gibbers: It's not unsafe, but you'd want to validate what you go
10:33:08 <monochrom> Data.Binary is not direct.
10:33:19 <glguy> gibbers: It wouldn't be vulnerable to code execution or similar
10:33:30 <Zemyla> If it sees something it doesn't underatand, it'll just give an error.
10:33:32 <cheater> hello
10:33:33 <monochrom> And I don't know what is security.
10:33:46 <cheater> in Core, an expression is defined as data Expr b, where b is a "binder", what is a binder?
10:33:51 <gibbers> glguy: How come? I'm curious. Does it automatically do sanity checking?
10:34:21 <Zemyla> cheater: It's a big piece of plastic with metal rings that holds paper.
10:34:32 <Zemyla> :V
10:35:10 <gibbers> How often do people use the built-in stuff to serialize/deserialize data to/from untrusted sources?
10:35:24 <glguy> gibbers: It's just a function on bytestrings, it's not reinterpret casting raw byte arrays into other objects
10:35:44 <monochrom> there is no built-in deserialization.
10:36:14 <cheater> gibbers: not at all, there's no such thing, you'd use a parser like, say, attoparsec, which validates your data against your types while it's deserializing.
10:37:35 <gibbers> okay cool. Are these libraries generally written in haskell too?
10:38:28 <monochrom> yes
10:38:37 <geekosaur> Data.Binary is pure Haskell. things like compression are usually done via the FFI but there is at least one pure Haskell zip implementation
10:38:41 * hackagebot HGE2D 0.1.8.0 - 2D game engine written in Haskell  https://hackage.haskell.org/package/HGE2D-0.1.8.0 (I3ck)
10:39:07 <gibbers> good to know, thanks
10:39:17 <monochrom> once again, conventional wisdom from other languages fall flat on its face in Haskell
10:39:27 <gibbers> I was hoping for some C dependency I could poke at :P
10:39:51 <obadz> Is there a way to have an Async be canceled when the async that calls it is canceled?
10:40:06 <gibbers> or loading raw bytes straight into memory and just casting it to something
10:41:27 <Eduard_Munteanu> obadz, see 'link'
10:41:33 <Eduard_Munteanu> @hoogle link
10:41:34 <glguy> link is backwards
10:41:35 <lambdabot> Text.Html link :: String -> HtmlAttr
10:41:35 <lambdabot> Text.XHtml.Transitional link :: String -> HtmlAttr
10:41:35 <lambdabot> package linkchk
10:41:41 <ertesx> obadz: withAsync
10:41:46 <obadz> yeah I think link goes in wrong direection
10:42:01 <glguy> I thnk withAsync is closer if you can deal with the scoping of it
10:42:17 <obadz> ertesx: ok let me try
10:42:33 <ertesx> obadz: but note that async only makes sure that the kill exception is delivered…  it does not wait for the thread to actually exit
10:43:49 <ertesx> obadz: if you want that, the following pattern should do it:  withAsync action (\ax -> c `finally` (cancel ax >> waitCatch ax))
10:44:12 <Eduard_Munteanu> You could call 'link' in the child Async, though.
10:44:24 <ertesx> Eduard_Munteanu: not safely
10:45:06 <Eduard_Munteanu> You mean since the child is already spawned and may die before link?
10:45:09 <obadz> ertesx: I'm not sure I get those last statements
10:45:15 <ertesx> i'm not even 100% sure about the solution i just wrote…  i'd probably drop a 'mask' in there just to be safe
10:45:18 <obadz> got withAsync to work with a trivial example
10:45:29 <ertesx> mask $ \unmask -> withAsync action (\ax -> unmask c `finally` (cancel ax >> waitCatch ax))
10:45:51 <ertesx> obadz: try this in the subthread:  someAction `finally` putStrLn "blah"
10:45:58 <glguy> Eduard_Munteanu: link would only help with exceptions, though, not lifetimes
10:46:06 <saurabhnanda> hey, just broadcasting this here: https://www.reddit.com/r/haskell/comments/4ue51y/help_space_leak_with_quickcheckpersistent/ -- need help with QuickCheck + Persisten
10:46:13 <Eduard_Munteanu> Oh, hm, fair.
10:46:24 <ertesx> obadz: if the creating thread is the main thread and exits after withAsync, you may find that "blah" is never printed
10:46:37 <ertesx> obadz: see the documentation of throwTo for details
10:47:18 <obadz> withAsync f1 $ \ t1 -> withAsync f2 $ \ t2 -> waitEitherCancel t1 t2
10:47:23 <obadz> does that make sense?
10:47:49 <monochrom> obadz: There can be a time lapse between "the exception reaches the thread" and "the thread finishes". (For example if the exception handler takes a little time.) Sometimes you don't care, sometimes you do.
10:48:05 <ph88> hi guys
10:48:24 <ph88> how can i wrap State around my parser ?
10:48:29 <ertesx> obadz: if you want two threads to race, the async library actually has a special combinator for that
10:48:38 <ertesx> obadz: see 'race'
10:49:13 <Eduard_Munteanu> ph88, hi. You can use StateT to augment the Parser monad.
10:49:48 <obadz> ertesx: good point, looks like I just rewrote it
10:49:51 <glguy> ph88: That completely depends on what kind of parser you have
10:50:16 <Eduard_Munteanu> ph88, what is the intended purpose?
10:50:29 <obadz> ertesx: looks like it uses waitEither and not waitEitherCancel
10:50:34 <obadz> ertesx: however doc says looser is canceled
10:50:42 <ertesx> obadz: cancellation is implied by withAsync
10:50:52 <obadz> ertesx: that's what I thought it might be, thanks
10:51:05 <ertesx> obadz: with the caveat i meantioned above
10:51:25 <ph88> Eduard_Munteanu, i want to collect error messages from the parser
10:51:38 <ph88> glguy, it's still the same one https://paste.fedoraproject.org/393950/92029201/
10:51:54 <ertesx> obadz: if you have cleanup code that must run in the thread, you need special care as above…  in that case you can't use 'race'
10:52:20 <ph88> Eduard_Munteanu, would it be enough to change the type on line 81 ?
10:52:28 <obadz> ertesx: no cleanup in that thread
10:52:52 <ertesx> obadz: then you're fine
10:52:56 <obadz> ertesx: meaning if I did race_ f1 f2 `finally` cleanup, then cleanup would not get executed?
10:52:58 <Eduard_Munteanu> ph88, not really
10:53:06 <obadz> ertesx: on a cancel of the parent thread?
10:53:15 <ertesx> obadz: it would but that's cleanup code in the parent thread
10:53:24 <ertesx> obadz: the caveat is about cleanup code in subthreads
10:53:25 <ph88> Eduard_Munteanu, what can i do ?
10:54:04 * obadz 's brain explodes thinking about these exceptions in async world
10:54:10 <ertesx> obadz: say one of the threads looks like this:  bracket create destroy c
10:54:38 <obadz> ertesx: then destroy wouldn't get evaluated if the other thread fails and they are racing?
10:55:05 <ertesx> obadz: when the withAsync action is done, it cancels the thread, but that only means that the thread gets a kill exception, so it exits 'c' and goes into 'destroy' – concurrently!
10:55:26 <obadz> so destroy DOES get evaluated?
10:55:28 <ertesx> obadz: the thread is going to exit, but haskell has this weird behaviour with the main thread:  if the main thread exits, all threads are killed instantly
10:55:53 <ertesx> so while 'destroy' starts to run, it may not get a chance to finish
10:55:58 <monochrom> I would rather say "the whole system vanishes". There is not even a formal kill.
10:56:48 <obadz> ertesx: when you say main thread, you mean the unique thread per process that's in the main function?
10:56:48 <ertesx> obadz: this is relevant in cases when you'd want to be sure that something has been written to disk before the thread exits
10:57:00 <ertesx> obadz: yeah, the first thread
10:57:01 <obadz> ertesx: you're talking about the whole process going down here?
10:57:03 <obadz> ok
10:57:28 <ertesx> obadz: the first thread is special in that it can't exit without bringing the whole program down
10:57:30 <obadz> so cleanup might not happen because they got threadKilled but process might terminate before cleanup, is that the right way to think about it?
10:57:39 <ertesx> yeah
10:57:43 <obadz> ok, get it
10:57:54 <obadz> why does race make this any worse?
10:58:00 <ertesx> it doesn't
10:58:08 <ertesx> it just doesn't allow you to do anything about it, if you need to
10:58:41 * hackagebot texmath 0.8.6.5 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.6.5 (JohnMacFarlane)
10:58:43 <obadz> Is there anything you can do about it other than put a bunch of waits from the main thread?
10:58:45 <Eduard_Munteanu> ph88, you'll likely have to make error collection explicit
10:58:55 <ertesx> obadz: nope
10:59:18 <obadz> ok, and race because it doesn't return the async handles of its children prevents the dev from adding the waits, is that it?
10:59:25 <monochrom> to a large extent, a practical multithreaded program has main just wait for the other threads.
10:59:35 <Eduard_Munteanu> ph88, it isn't straightforward to parse and show all error messages meaningfully
10:59:47 <ertesx> obadz: yeah
11:00:10 <obadz> alright I think we've beaten that horse to death, thx!
11:00:29 <monochrom> no, we have raced the horses to death.
11:00:46 <glguy> Who won?
11:00:55 <ph88> Eduard_Munteanu, how can i make the error collection explicit ?
11:01:01 <ertesx> obadz: i'm mentioning it, because you wouldn't normally notice it in most applications, but if you get it wrong in critical code, you may lose data
11:01:07 <monochrom> we don't know. the main thread suddenly exited.
11:01:50 <Eduard_Munteanu> ph88, you need to know which parsers cannot fail, run them and see what error they return
11:02:05 <Eduard_Munteanu> s/cannot/should not/
11:02:28 <monochrom> oh good, my "finally save data" is in the main thread.
11:02:57 <ertesx> monochrom: note that ctrl-c normally sends an async exception to the main thread =)
11:03:41 <obadz> ertesx: yep I appreciate it
11:03:42 <monochrom> yes, in fact my "finally" there is for both normal finish and ctrl-c
11:04:01 <ph88> Eduard_Munteanu, is a failing parser different than one which returns an error ?
11:04:56 <Eduard_Munteanu> ph88, I was talking about failure, not returning the error as a value. They're different.
11:05:25 <ph88> Eduard_Munteanu, how can i know which parsers can not fail ?
11:06:06 <monochrom> you wrote them, so supposed you know, supposedly you did intelligent design, not evolution.
11:06:56 <ph88> you talking to me monochrom ?
11:08:09 <Eduard_Munteanu> ph88, for example, once you see an '=', you know you've got an assignment, so you report the error if needed. On the other hand, if you haven't seen '=', it may be a blank line or something else legitimate.
11:08:45 <ph88> Eduard_Munteanu, a '=' in the input string you mean ?
11:08:50 <Eduard_Munteanu> Yeah.
11:09:13 <ph88> i think the parser is already reporting errors
11:09:23 <ph88> i didn't customize that part yet
11:09:56 * Eduard_Munteanu has to go afk soon
11:10:14 <ph88> oki ^^
11:15:13 <Thra11> Is there a way to tell cabal that Foo.hs depends on template.hamlet, such that Foo.hs will be recompiled if template.hamlet changes? (I'm using TH, hamletFile in Foo.hs)
11:17:12 <supki_> Thra11: yes, with Language.Haskell.TH.Syntax.addDependentFile
11:22:48 <Thra11> supki_: Thanks!
11:23:42 * hackagebot rivet-autoimporter 0.1.0.0 - Database migration library; automatic importer.  https://hackage.haskell.org/package/rivet-autoimporter-0.1.0.0 (DanielPatterson)
11:23:44 * hackagebot rivet-adaptor-postgresql 0.1.0.0 - Rivet migration library postgresql backend  https://hackage.haskell.org/package/rivet-adaptor-postgresql-0.1.0.0 (DanielPatterson)
11:23:46 * hackagebot rivet-core 0.2.0.0 - Database migration library; core functionality.  https://hackage.haskell.org/package/rivet-core-0.2.0.0 (DanielPatterson)
11:30:12 <ph88> anyone seen pjdelport ?
11:31:56 <parsnipM_> ph88: i think it's PiDelport, they're in #haskell-beginners
11:35:41 <ph88> oh ok thx
11:44:35 <superlinux> hi. how can I read and build a list on the fly in haskell from stdin?
11:47:22 <Thra11> supki_: Where do I put it?
11:50:52 <anohigisavay> hi.
11:51:32 <anohigisavay> i'm playing with attoparsec and i noticed the decimal parser will not fail when parsing floating numbers
11:51:53 <anohigisavay> say '3.14', it'll get a partial with '3' and leaving '.14'
11:52:33 <anohigisavay> i want it to use double parser instead
11:53:00 <maerwald> anohigisavay: https://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/Data-Attoparsec-ByteString.html#v:endOfInput
11:53:23 <maerwald> you combine that with that and it will "throw" for 3.14
11:56:35 <anohigisavay> maerwald: it's not the end of input. there is more text remaining, but the number itself is a whole
11:57:10 <anohigisavay> maybe with space or '\n' afterwards
11:57:17 <maerwald> anohigisavay: then you can adjust the parser to consume those chars, but not make it part of the result
11:57:24 <maerwald> e.g. *> and <*
11:58:43 * hackagebot edit-lenses-demo 0.1.1 - Programs demoing the use of symmetric, stateful edit lenses  https://hackage.haskell.org/package/edit-lenses-demo-0.1.1 (DanielWagner)
11:58:49 <maerwald> decimal <* takeWhile (/= ' ') -- or something
11:58:57 <cheater> in Core, what is a binder? I mean the type variable in type constructor Expr b
12:02:27 <supki_> Thra11: if you put $([] <$ addDependentFile "./path/to/template.hamlet") in the toplevel of Foo.hs GHC will recompile it on changes in ./path/to/template.hamlet
12:03:06 <anohigisavay> maerwald: cool. thanks :)
12:08:43 * hackagebot genvalidity 0.2.0.1 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.2.0.1 (Norfair)
12:08:45 * hackagebot validity 0.3.0.0 - Validity typeclass  https://hackage.haskell.org/package/validity-0.3.0.0 (Norfair)
12:08:47 * hackagebot validity-containers 0.1.0.0 - Validity instances for containers  https://hackage.haskell.org/package/validity-containers-0.1.0.0 (Norfair)
12:08:49 * hackagebot genvalidity-hspec 0.2.0.1 - Standard spec's for GenValidity instances  https://hackage.haskell.org/package/genvalidity-hspec-0.2.0.1 (Norfair)
12:12:30 <dmwit> cheater: term-level lambda, type-level lambdas, and patterns with variables in them are all traditionally called binders.
12:12:43 <dmwit> cheater: Because they "bind" a variable name to a value (or type).
12:12:47 <dmwit> cheater: Why do you ask?
12:21:39 <Thra11> supki_: Thankyou. That seems to work. (with cabal build it works. Doesn't work with cabal new-build though. Assume it's a bug/missing feature in cabal new-build)
12:26:27 <cheater> dmwit: i'm trying to build a small implementation of untyped Core as part of a haskell lib i'm writing and i wonder why i need the "binder type" as they say there
12:26:38 <cheater> https://downloads.haskell.org/~ghc/7.6.2/docs/html/libraries/ghc/CoreSyn.html
12:27:00 <cheater> data Expr b
12:27:14 <cheater> "The type parameter b is for the type of binders in the expression tree."
12:28:44 * hackagebot diagrams-boolean 0.1.0 - boolean operations on Diagrams paths  https://hackage.haskell.org/package/diagrams-boolean-0.1.0 (KristofBastiaensen)
12:35:20 <ggole> cheater: for stuffing variable info into
12:37:26 <cheater> ggole: i don't get it
12:38:08 <geekosaur> that's not the type of the thing being bound, but the "flavor" of binder that is being used
12:38:44 * hackagebot workdays 0.1.0 - Workday calculations  https://hackage.haskell.org/package/workdays-0.1.0 (jpvillaisaza)
12:38:58 <ggole> The idea is that you substitute a data type containing the variable info that you are interested in, rather than just a name/id
12:39:09 <dmwit> cheater: For an example of what `b` might be, think of choosing `String` for a parse tree, or `UniqueID` for the result of a pass that disambiguates shadowed names.
12:39:22 <ggole> Rather than have a table off to the side that you index with the name/id
12:39:30 <geekosaur> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType might be helpful here
12:40:12 <dmwit> I don't think an "untyped Core" is going to be particularly interesting. Basically just your standard untyped lambda calculus.
12:40:39 <dmwit> Maybe with the addition of data/pattern matching.
12:42:36 <cheater> ok i want a super duper simple version of Core that's pretty much as untyped as goes, has Char, Int, Float, and algebraic data types
12:42:40 <cheater> do i need binders at all?
12:42:52 <cheater> and if i don't can i just plug the Var type into b and be done with it?
12:42:53 <ggole> Not really
12:43:05 <cheater> not really as in i don't really need binders?
12:43:37 <ggole> You need binders, just put the type that you want there
12:43:53 <cheater> remember i'm reimplementing Expr
12:43:58 <cheater> not using the one from GHC
12:44:03 <cheater> so I could simplify
12:44:22 <ggole> Sure, go ahead
12:44:35 <cheater> how would i simplify? how do you see that happening?
12:45:14 <cheater> btw i don't even have recursive let right now
12:45:30 <ggole> Remove the parameter b and substitute whatever you have in place of it
12:46:04 <cheater> i'm still not sure what exactly is allowed to go in b
12:46:30 <cheater> geekosaur's link says:  Expr is parameterised over the type of its binders, b. This facility is used only rarely, and always temporarily; for example, the let-floater SetLevels pass attaches a binding level to every binder. By far the most important type is CoreExpr, which is Expr with Var binders. If you want to learn more about such AST-parametrization, I encourage you to read a blog post about it: ...
12:46:36 <cheater> ... ​http://blog.ezyang.com/2013/05/the-ast-typing-problem . 
12:46:53 <ggole> A b occurs at each point that a variable is bound
12:47:33 <ggole> So you want the variable name/id, for a start, to know which one
12:47:54 <cheater> i don't know really what you mean by that
12:48:02 <cheater> what does it mean that "b occurs"?
12:48:35 <ggole> A value of type b exists for each variable that is bound in the program.
12:48:39 <cheater> i hope it doesn't look like i'm being obtuse, i am just missing some context here i think
12:49:04 <cheater> does each variable that is bound in the program have its own unique value of type b?
12:49:12 <ggole> Why don't you start with a bare-bones lambda calculus until you are comfortable with what a binder is?
12:49:23 <ggole> It's easy to tack on stuff.
12:49:35 <cheater> because i still haven't found a remotely good explanation of what a binder is
12:49:48 <cheater> or what can go inside b in the case of GHC Core
12:50:34 <cheater> eg you say "value of type b" but I don't know what types get put into the type variable b so it's difficult to picture things. is there a list of those things with what they mean?
12:51:49 <geekosaur> binders are, in effect, local variables. b is, as ggole said, something specific to a given pass through the Core allowing you to do something useful with it; as from your quote earlier, SetLevels uses it to notate each binder with its depth, so that let-floating knows what level each binder currently is and can compute how far it can be floated out (by comparing the level of anything it's used with)
12:52:19 <geekosaur> there's no fixed list of things it "can be", it's completely up to the code that is using it at the moment to decide what (if anything) it needs to use it for
12:52:34 <ggole> You can just use strings to start with
12:52:36 <geekosaur> and if the code isn';t using it, it can use ()
12:53:24 <cheater> mhm
12:53:53 <cheater> wait, let me back track, they say b is the type of binders, right?
12:54:06 <geekosaur> that's shorthand. ot
12:54:16 <cheater> but what is a binder itself?
12:54:21 <geekosaur> it's the type of a data value that gets asociated with a binder (a local binding/"variable")
12:54:38 <cheater> so the constructors of the type Expr b, they're the binders?
12:54:49 <geekosaur> let b = 5 in b -- the first "b" is a binder
12:55:02 <geekosaur> f (x:xs) = xs -- x and xs are binders
12:55:12 <cheater> wait a sec
12:55:15 <abbe> hi
12:55:18 <cheater> i thought in Core, that would be a Bind
12:55:21 <cheater> not a "binder"?
12:55:28 <cheater> i thought those were distict things.
12:55:36 <cheater> see here:   | Let   (Bind b) (Expr b)
12:55:49 <abbe> I'm trying to use HDBC-mysql, and my libmysqlclient.* library files live in /usr/local/lib/mysql
12:56:01 <cheater> see, in "let x = 2" (Bind b) would be x, right?
12:56:11 <geekosaur> Bind is the AST node. binders are the names that are bound within that node (and a few others that can do binding)
12:56:15 <abbe> I have explicitly specified them with: cabal configure --extra-lib-dirs=/usr/local/lib/mysql
12:57:15 <geekosaur> as per the CoreSynType page, data Bind b = NonRec b (Expr b) | Rec [(b, (Expr b))]
12:57:40 <cheater> geekosaur: ok, so here... that binder would be "x"?
12:57:49 <abbe> but when I do cabal build, it says linker can't find '-lmysqlclient', and I don't see '/usr/local/lib/mysql' being mentioned in the command-line of 'ghc -shared -dynamic ...' when I do 'cabal build -v'
12:58:05 <abbe> any ideas ?
12:58:05 <geekosaur> so a Bind is a non-recursive binding along with the expression it is bound to, or a (possibly mutually recursive) list of bindings. "b" is an associated data type you can use for *anything*
12:58:10 <cheater> as in "x"::String ?
12:58:44 <cheater> abbe: can you post the full output please?
12:58:50 <abbe> sure
12:59:35 <maerwald> abbe: it uses "mysql_config" to determine linker flags etc
12:59:48 <maerwald> abbe: https://github.com/bos/hdbc-mysql/blob/master/Setup.lhs#L29
12:59:49 <Shockk> hello, I wondered if someone could quickly remind me what the operator is that lets me write something like  _1 .~ "hello" $ ((), "world")  as  ((), "world") ? _1 .~ "hello"  ?
13:00:01 <Shockk> the ? is the operator I can't remember
13:00:03 <geekosaur> at the very least here, 'b' needs to have the name of the binding ("x" in "let x = 2"); it can also have more information in it. as ggole said, at the simplest you need the binding name (so, String or maybe Text)
13:00:20 <maerwald> abbe: so the questions are: does mysql_config exist? does it exist more than once? which one is used then?
13:00:23 <abbe> maerwald: right, but I don't see it working without explicit path
13:00:25 <abbe> https://pastebin.com/D9Y25b2b
13:00:29 <abbe> cheater: ^
13:00:35 <maerwald> abbe: ?
13:00:46 <abbe> λ mysql_config --libs => -L/usr/local/lib/mysql  -lmysqlclient  -pthread -lz -lm -lexecinfo     -L/usr/local/lib
13:00:51 <abbe> output of mysql_config ^
13:00:51 <Shockk> I have a feeling it might have been something like an ampersand, but I may be wrong
13:01:08 <abbe> thanks (in advance)? for looking, and help.
13:01:11 <Shockk> edwardk: might you know which one I mean?
13:01:46 <cheater> abbe: well what i think is that somehow somewhere your -L is empty and so something else thinks that "-lmysqlclient" is the value of the "-L" option.
13:02:28 <abbe> hmmm
13:02:55 <abbe> /usr/local/bin/ghc -shared -dynamic -lmysqlclient ... <<< is how it invokes GHC
13:03:30 <Shockk> ah aha, I found it, it is & after all
13:03:39 <abbe> so where is the "-L" you are hinting at
13:10:40 <cheater> the complaint doesn't come from ghc
13:10:43 <cheater> it comes from ld
13:11:20 <maerwald> there is something broken in the build system, I can reproduce the problem
13:11:51 <abbe> ghc passes flags to ld
13:12:14 <abbe> and it's not passing the right arguments for ld to link to the libmysqlclient.so file
13:12:17 <cheater> in Setup.hs, why don't you add something like: print includeDirs
13:12:26 <cheater> see what happens there
13:12:45 <cheater> same with ldOptions
13:13:07 <maerwald> they are correct, that's not the problem
13:13:26 <abbe> cheater: include directories seem to be working fine, as you can see in the output -I/usr/local/include/mysql being passed
13:15:18 <cheater> i don't see where in the output you posted on pastebin it says that those two variables have the correct value
13:15:21 <abbe> and I truss-ed the 'cabal configure' command-line, and it did 'exec' mysql_config
13:15:45 <abbe> creating dist/build
13:15:45 <abbe> /usr/local/bin/ghc --make -fbuilding-cabal-package -O -j8 -static -dynamic-too -dynosuf dyn_o -dynhisuf dyn_hi -outputdir dist/build -odir dist/build -hidir dist/build -stubdir dist/build -i -idist/build -i. -idist/build/autogen -Idist/build/autogen -Idist/build -I/usr/local/include/mysql -I/usr/local/include/mysql/.
13:15:52 <abbe> ^ this line
13:17:31 <cheater> right but that doesn't seem to be derived from the ldOptions variabl
13:17:31 <cheater> e
13:17:55 <cheater> why don't you check, i mean you're spinning your wheels anyways?
13:17:56 <abbe> okay
13:17:58 <abbe> adding
13:18:16 <cheater> try both variables
13:19:09 <maerwald> abbe: I have it fixed
13:19:13 <maerwald> use: sharedOptions   = [(GHC, ldOptions)]
13:19:22 <maerwald> in addition of ldOptions
13:19:31 <maerwald> not sure if that's the "correct" fix, but it makes it buildable here
13:20:43 <abbe> cheater: https://pastebin.com/K3M5npdd
13:21:26 <lpaste> maerwald pasted “hdbc-mysql-linker.patch” at http://lpaste.net/171457
13:21:34 <maerwald> try that one
13:21:37 <abbe> checking
13:21:55 <cheater> interesting
13:22:59 <abbe> maerwald: now I get: ghc: unrecognized flag: '-pthread'
13:23:12 <abbe> but yes, now arguments are getting passed
13:24:05 <maerwald> abbe: so you could specify them manually in fact
13:24:19 <maerwald> sharedOptions   = [(GHC, "-L/your/suff")]
13:24:39 <maerwald> fascinating how broken this is
13:24:42 <maerwald> but anyway
13:25:25 <maerwald> I guess people didn't test this with alternate installation destinations that are not /usr/lib
13:25:35 <maerwald> for those, the bug probably does not occur
13:26:59 <abbe> yeah
13:28:16 <abbe> also after 'rm -rf dist', cabal build works with 'cabal configure --extra-lib-dirs=/usr/local/lib/mysql' now
13:28:30 <abbe> No ideas, what I did wrong before :(
13:28:51 <abbe> Anyways, thanks maerwald, and cheater for your time. Have a good weekend.
13:29:04 <cheater> yw
13:30:05 <maerwald> abbe: it's still a bug, please report it
13:30:43 <abbe> sure
13:38:51 <abbe> reported
13:48:47 * hackagebot ghc-exactprint 0.5.2.1 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.5.2.1 (mpickering)
13:51:16 <cheater> thank you abbe
13:53:59 <mikail`> In definition of a Functor, there is a function <$ which has a definition fmap . const
13:54:18 <mikail`> i don't understand how fmap . const satisfies it's function signature
13:54:44 <mikail`> I understand the function signature (<$) :: a -> f b -> f a
13:54:49 <mikail`> but not the fmap . const
13:54:51 <glguy> mikail`: What type do you think fmap . const would have?
13:55:11 <mikail`> is it a partial function?
13:55:46 <glguy> A partial function is one that isn't defined for all of its inputs, like head
13:55:48 <glguy> this isn't partial
13:55:59 <mikail`> i mean partially applied sorry
13:56:16 <mikail`> so it will map the const
13:56:50 <monochrom> "fmap const" would map the const. But you're looking at "fmap . const".
13:57:39 <mikail`> well const has a a -> b -> a
13:57:44 <deam> yo
13:58:10 <mikail`> and fmap has (a -> b) -> f a -> f b
13:58:27 <glguy> fmap . const   evaluates to    \x -> fmap (const x)
13:59:31 <deam> :t fmap
13:59:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:59:34 <deam> :t const
13:59:35 <lambdabot> a -> b -> a
13:59:38 <mikail`> but the return type of const is a
13:59:51 <mikail`> and fmap takes a function (a -> b)
14:00:11 <mikail`> i don't get how they compose
14:00:26 <deam> const returns a
14:00:33 <mikail`> yeah
14:00:39 <deam> oh
14:00:46 <mikail`> so that should be the input of fmap
14:00:54 <monochrom> Do you mind renaming the type variables in one of them? const :: t -> w -> t. That will lead to less self-deception.
14:00:54 <cobreadmonster> :t fmap . const
14:00:56 <lambdabot> Functor f => b -> f a -> f b
14:01:21 <monochrom> You really don't want to reuse the same variables "a", "b", "c" all the time.
14:01:27 <deam> :t (<$)
14:01:28 <lambdabot> Functor f => a -> f b -> f a
14:01:35 <deam> there you go
14:01:39 <mikail`> I'm reading the hackage docs
14:01:44 <mikail`> that's what they hvave
14:01:57 <glguy> That's fine, you just rename them to something else
14:03:52 <deam> :t (.)
14:03:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:04:14 <monochrom> And you want to rename that one too
14:04:33 <monochrom> You cannot survive with only 4 pronouns.
14:06:33 <mikail`> ok. penny has dropped
14:06:36 <mikail`> i get it now
14:06:42 <mikail`> Haskell is hard
14:07:08 <deam> I still don
14:07:12 <deam> don't get it
14:07:47 <glguy> Given some x of type q,  const x :: p -> q
14:07:59 <glguy> so you can use that as an argument to fmap
14:08:46 <glguy> fmap :: (a -> b) -> f a -> f b ; fmap (const x) :: f p -> f q
14:09:25 <mikail`> const is an unusual name for what it does
14:09:31 <glguy> It creates a constant function
14:09:37 <mikail`> oh ok
14:09:42 <mikail`> that makes sense
14:09:49 <mikail`> when you put it like that
14:09:55 <deam> :t (const)
14:09:56 <lambdabot> a -> b -> a
14:10:34 <deam> :t fmap
14:10:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:12:14 <deam> okay then
14:12:17 <deam> I get it
14:14:45 <mikail`> when you think about, for a little bit of code in haskell you get alot of power
14:17:19 <deam> - evil laugh
14:18:01 <Rotaerk> nah, that's just the power of abstraction ... very little repetition
14:18:08 <Rotaerk> and haskell is a rabbit hole of abstraction
14:23:46 <new444> hi I am new and am getting Failed to load interface for ‘Data.Rewriting.Term’ in win 10 after installing the package with cabal
14:27:26 <glguy> new444: You can paste the output for how you installed it and how you tried to use it http://lpaste.net
14:29:13 <EvilMachine> Hi, is there something like Writer, but for constantly modifying the same value? (I want to have a monad for “drawing” (like folding) layers of [[Char]] into a single [[Char]], with my own combination operator supplied.
14:29:31 <koz_> EvilMachine: State?
14:29:46 <Zemyla> Okay, I have a question about recursion schemes; catamorphism, anamorphism, and so on.
14:29:58 <EvilMachine> (Think of a CLI program similar to ncurses, where I can draw onto a text “canvas”)
14:30:10 <new444> looks like reloading winghci solved my problem
14:30:13 <EvilMachine> koz_: :) You’re probably right.
14:32:14 <Zemyla> If I have a Bifunctor f, and newtype Mu f a = In { out :: f a (Mu f a) }, then can I define the Functor instance using an existing catamorphism/anamorphism/whichever?
14:38:54 <buglebudabey> could someone critique my code/project, it's very short. I'd like to make it so that someone using this text classification library can create their own classes to classify data with https://github.com/aneksteind/hext/blob/master/src/NaiveBayes.hs
14:39:49 <YellowOnion> Has anyone here got experience with OpenGLRaw or the gl package and supporting GL-ES?
14:43:29 <koz_> buglebudabey: I have one question already - why use String?
14:43:34 <koz_> Surely Text is the better choice here?
14:44:01 <buglebudabey> it would be, and honestly I was planning on switching string to text
14:44:27 <koz_> OK, just figured I'd ask in case there was some odd corner case I didn't know about.
14:44:45 <koz_> Also, in the signature of makeMaterial, did you mean to use Words instead of [String]?
14:44:49 <dolio> map f = fold (In . first f)
14:45:56 <koz_> s/Words instead of [String]/[String] instead of Words
14:46:58 <buglebudabey> koz_ I meant to put string but I can see that it can obviously be switched
14:47:10 <buglebudabey> and probably should
14:47:20 <koz_> buglebudabey: Hence the question.
14:48:03 <buglebudabey> koz_ if i want to make it so that other can create their own Class data type to classify data with, what can I do?
14:48:08 <Ivana> hi! Please, can anyboly get me a link to lambdabot on this channel?
14:48:50 <koz_> buglebudabey: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html <-- this may be of interest
14:49:00 <buglebudabey> koz_ thanks
14:50:01 <buglebudabey> Ivana do you want to query it or have the source?
14:50:09 * dmj` <3's typeclasses
14:50:51 <Ivana> <buglebudabey> thanks, i have find him in users
14:52:03 <new444> im doing cabal install and getting "Perhaps you need to add `QuickCheck` to your build-depends" but it is already there
14:52:06 <Ivana> i am windows user, abd i can not have it locally - i only may use this chat )
14:53:54 <glguy> Ivana: You can use /msg lambdabot to send messages to lambdabot directly in most clients
14:55:10 <glguy> new444: You can paste your cabal file and the error message to lpaste
14:56:09 <Ivana> <glguy> i chat with him privatelly, thanks!
15:00:32 <buglebudabey> koz_ now that i'm switching to Text, what can i do with 'filter (not . isPunctuation)' on a Text value?
15:04:01 <buglebudabey> koz_ nevermind
15:10:41 <buglebudabey> is there a way to initialize something between quotes as Text so that I don't have to go through the O(n) time to convert from string -> text?
15:13:17 <glguy> buglebudabey: Text.pack "some thing" doesn't actually allocate a String and convert it to a Text
15:13:57 <buglebudabey> glguy but the hackage info says O(n) on pack time
15:14:08 <glguy> big O is an upper bound
15:14:40 <buglebudabey> I understand that, but in what circumstance would it be less than O(n)?
15:15:09 <glguy> never, but it's as fast as its going to be, pack applied to a string literal rewrites to an operation on the underlying constant string pointer
15:15:27 <glguy> there's fusion, so if you end up doing something and the text fuses away, it might not actually do the pack
15:15:36 <glguy> but if you use the whole text then obviously it will be linear in the text you used
15:15:46 <glguy> (so I guess never was wrong)
15:16:08 <glguy> but the short answer is "keep moving, nothing to see", you don't have to try and outclever the library
15:16:19 <buglebudabey> would using overloaded strings change anything?
15:16:24 <glguy> no
15:16:29 <buglebudabey> alright, thank you
15:17:22 <glguy> overloadedStrings doesn't do anything more clever than to apply fromString to string literals for you, which is implemented with pack for Text
15:17:39 <glguy> (which is subject to rewrite rules and fusion already)
15:18:04 <buglebudabey> ah i see, well thank you again
15:20:16 <glguy> Incidentally remember that indexing and length on Text are both O(n) because Text uses a variable-length encoding internally
15:21:25 <lpaste> new444 pasted “error cabal install sexpr” at http://lpaste.net/171492
15:23:06 <hexagoxel> new444: you did re-configure, right?
15:23:18 <new444> no what does that mean
15:23:30 <hexagoxel> run `cabal configure`
15:24:09 <glguy> new444: Is it the case that you've edited that .cabal file?
15:24:19 <new444> yes
15:24:26 <new444> the cabal file is in a tgz archive
15:24:39 <new444> running cabal configure says no cabal file found
15:24:51 <glguy> You need to run the command in the directory where the .cabal file is
15:25:13 <glguy> http://hackage.haskell.org/package/sexpr doesn't show a build dependency on QuickCheck == 1.2.0.0 like yours has
15:25:37 <new444> yes i tried just adding one without a version first
15:25:47 <new444> i got same error before i modified anything
15:25:59 <glguy> You've added a build dependency on an old version of quickcheck
15:26:23 <glguy> running configure again you'll probably get an error about not having that version of the library
15:26:38 <new444> ok i can untar that module right
15:26:53 <glguy> You shouldn't need to be touching any tar files
15:27:13 <new444> the cabal file im looking at is in sexper-0.2.1.tar.gz
15:27:29 <glguy> The command "cabal install sexpr" will download, build, and install that package
15:27:29 <new444> is there a different place to modify it?
15:27:41 <new444> yeah but it gave that build error
15:27:45 <glguy> The package doesn't need to be modified
15:28:04 <new444> im guessing it maybe it out of date or something?
15:28:18 <new444> the error was the same before i modified anything
15:28:25 <glguy> ah, I see
15:31:12 <glguy> This package has never been buildable since it was uploaded, and that was back in 2009
15:31:19 <glguy> Are you sure this is the package you need?
15:31:40 <new444> oh that doesn't sound good
15:31:51 <new444> no i just thought i would try it
15:32:17 <new444> looking for something to parse and print sexpr like terms
15:34:10 <glguy> new444: the s-cargot package is written by someone I work with and has a simple mode that might be interesting to you : http://hackage.haskell.org/package/s-cargot-0.1.1.1/docs/Data-SCargot-Language-Basic.html
15:36:09 <joe9> hello, I am looking to build a simple haskell web server with just the home page (which has a table of links) . This is for localhost use and is not meant for the public.
15:36:23 <joe9> Any kind suggestion on what library / package I should look out for?
15:36:36 <buglebudabey> maybe yesod, joe9 
15:36:45 <buglebudabey> theres a free book for it
15:37:00 <new444> glguy: thanks looks useful
15:37:21 <glguy> I use snap-server for making HTTP servers. Are you doing dynamic page generation?
15:37:23 <joe9> buglebudabey: ok, Thanks. What do you think of servant? It seems to get complicated.
15:37:53 <joe9> glguy: I need to add 2 lines to the .xhtml file. So, not much dynamic stuff.
15:37:57 <buglebudabey> joe9 I honestly don't have experience with it, so I couldn't tell you
15:39:10 <YellowOnion> Is anyone here using Spacemacs+SHM and can tell me how to fix this seemly broken indentation?
15:43:49 <mniip> is there a widely accepted package that defines a natural transformation datatype?
15:54:29 <slack1256> YellowOnion: I just use spacemacs and don't bother with any haskell tooling (apart from the syntax coloring)
15:55:06 <slack1256> type holes replaced ghc-mod for me and the identation is variable per project
15:56:58 <slack1256> mniip: forall a b. (Functor f, Functor g) => f a -> g b 
15:57:23 <mniip> hmm?
15:57:29 <slack1256> something like that? (nothing that haskell functor are just endo-functors and not the `structure preserving mapping` of the theoric functor
15:57:44 <YellowOnion> slack1256, interesting. I think my issues is somewhat related to evil.. but my spacemacs is refusing to update as well, so attempting a complete reinstall.
15:57:50 <mniip> surely you mean f a -> g a
15:57:55 <mniip> also I was asking about a package
15:57:58 <mniip> not the definition
15:58:51 * hackagebot namespace 0.1.1.0 - A Generic Haskell library for managing namespaces  https://hackage.haskell.org/package/namespace-0.1.1.0 (xuhao)
15:58:58 <slack1256> Oops right. I remember a package, let me search
15:59:56 <mniip> I came across natural-transformation, but it's not written by edward kmett so naturally that induces some questions
16:00:39 <hpc> supernatural-transformations
16:00:49 <hpc> data WhereWolf where Wolf :: WhereWolf
16:02:09 <slack1256> Mmm I thought subhask was a package for this
16:02:20 <slack1256> but their category-transformers are not natural transformations
16:11:23 <YellowOnion> slack1256, grr, so disabled shm, but I still can't indent lines with code
16:11:58 <slack1256> I just insert spaces, plus when I open a newline spacemacs preserves the ident level
16:12:17 <slack1256> and can move around pressing tab insert mode
16:12:38 <slack1256> s/insert mode/in insert mode/
16:12:59 <__Myst__> Is it a bad idea to define types just for clarity?
16:13:06 <__Myst__> Things like `type Index = Int`
16:13:34 <YellowOnion> slack1256, I guess if you're not even using indentation scripts I guess the editor is becoming some what irrelevant.
16:13:49 <sm> __Myst__: usually it's considered a good idea. Like everything it depends
16:14:07 <YellowOnion> Looks like indentaion is actually hard-fixed (it actually removes indentation if there's to much)
16:18:52 * hackagebot higher-leveldb 0.4.0.0 - A rich monadic API for working with leveldb databases.  https://hackage.haskell.org/package/higher-leveldb-0.4.0.0 (jeremyjh)
16:28:52 * hackagebot vector-bytes-instances 0.1 - Serial (from the bytes package) for Vector (from the vector package)  https://hackage.haskell.org/package/vector-bytes-instances-0.1 (RenzoCarbonara)
16:43:17 <__Myst__> Will the expression xs !! i == 0 be parsed as (xs !! i) == 0?
16:43:34 <Xe> it should
16:43:36 <Xe> test it in ghci
16:44:52 <slack1256> > [5,6,0] !! 2 == 0
16:44:54 <lambdabot>  True
16:45:39 <benzrf> if it's wrong it'll type error, __Myst__
16:46:27 <__Myst__> Xe: I've had issues with !!
16:46:58 <slack1256> extra parens usually don't hurt and hlint will tell you when they are redundant
16:47:07 <Xe> isn't !! more right-associative than ==?
16:47:19 <slack1256> @info (!!)
16:47:19 <lambdabot> (!!)
16:47:29 <glguy> lambdabot doesn't have an :info
16:47:30 <slack1256> @src (!!)
16:47:30 <lambdabot> xs     !! n | n < 0 = undefined
16:47:30 <lambdabot> []     !! _         = undefined
16:47:30 <lambdabot> (x:_)  !! 0         = x
16:47:30 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:47:44 <glguy> __Myst__: You can ask GHCi   :i !!   and :i ==
16:47:46 <Welkin> info is interpreted as undo by lambdabot 
16:47:48 <Welkin> lo;
16:47:49 <Welkin> lol
16:47:57 <slack1256> I remember lambdabot also showed the fixities
16:48:04 <slack1256> oh lol
16:48:07 <glguy> __Myst__: When GHCi doesn't mention an infix declaration, then the operator uses the default: infixl 9
16:48:11 <__Myst__> !! is rather funly implemented
16:48:14 <Xe> glguy: :i => shows how infix-y it is?
16:48:27 <__Myst__> :i !!
16:48:34 <glguy> No, you do that in GHCi, not IRC
16:49:25 <__Myst__> glguy: I saw lambdabot supported GHCI-like commands and I was ondering if :i worked
16:49:37 <glguy> 16:47 glguy: lambdabot doesn't have an :info
16:49:48 <Welkin> @undo "hello"
16:49:48 <lambdabot> "hello"
16:49:52 <Welkin> @info "hello"
16:49:53 <lambdabot> "hello"
16:50:55 <__Myst__> Is there something like splitAt
16:51:03 <__Myst__> But that returns a tuple ([a], a, [a])
16:51:10 <Welkin> :t break
16:51:11 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
16:51:53 <__Myst__> Welkin: not what I'm looking for
16:51:55 <__Myst__> I meant something like
16:52:00 <glguy> __Myst__: No, but what you can do is:  case splitAt n xs of (xs,y:ys) ->
16:52:11 <__Myst__> k
16:52:26 <deank> :t splitAt
16:52:28 <lambdabot> Int -> [a] -> ([a], [a])
16:52:42 <Zemyla> __Myst__: What should newSplitAt 2 [1] return? What should the middle value be?
16:52:59 <deank> undefined ;)
16:53:39 <__Myst__> Zemyla: Whatever splitAt 2 [1] is :)
16:53:57 <glguy> > splitAt 2 [1]
16:53:59 <lambdabot>  ([1],[])
16:54:07 <pavonia> __Myst__: What do you expect the middle element to be?
16:54:08 <__Myst__> wondering what the middle value should be though
16:54:20 <__Myst__> pavonia: This is an internally used function
16:54:27 <__Myst__> there's always gonna be at the very least three elemnts 
16:54:28 <__Myst__> rather
16:54:32 <__Myst__> It's always gonna take valid input
16:54:35 <__Myst__> I'm not going to worry about this
17:01:13 <ertesx> __Myst__: take inspiration from 'splitLookup' for Data.Map
17:01:24 <ertesx> :t M.splitLookup
17:01:25 <lambdabot> Ord k => k -> Data.Map.Map k a -> (Data.Map.Map k a, Maybe a, Data.Map.Map k a)
17:01:36 <__Myst__> ertesx: Eh, I don't like dealing with maybes 
17:02:12 <ertesx> i suppose that's one way of saying you don't like to deal with failures =)
17:02:41 <Koterpillar> pattern matching on Just will be a way to deal with maybes but not failures ;)
17:02:50 <__Myst__> ertesx: I don't like to deal with failures that won't happen
17:03:05 <Welkin> it;s two extra lines
17:03:08 <Welkin> what's the big deal?
17:03:18 <__Myst__> Welkin: I like my code to be pretty
17:03:21 <Welkin> or one if you just use `maybe`
17:03:28 <__Myst__> I redefine `lookup` to error out on Nothing
17:03:31 <__Myst__> enough said.
17:03:34 <Welkin> ...
17:03:38 <Welkin> why???
17:03:47 <__Myst__> Rather
17:03:48 <Koterpillar> __Myst__: pattern match on Just then
17:03:51 <__Myst__> I redefine it to error out
17:03:58 <__Myst__> When I know it won't ever be Nothing
17:03:59 <ertesx> __Myst__: unfortunately we have no (half-way beautiful) way to encode the invariant on the type level
17:04:11 <__Myst__> ertesx: Huh?
17:05:14 <Gurkenglas> Should gloss have a variant of playIO that allows you to use arbitrary MonadIOs instead of just IO?
17:05:23 <ertesx> __Myst__: i recommend that you just go with Maybe…  it's not as bad as it sounds, and if you really want shortest possible code, use Maybe as a monad
17:05:33 <ertesx> > do x <- Just 3; y <- Just 4; pure (x + y)
17:05:35 <lambdabot>  Just 7
17:06:05 <mniip> Gurkenglas, then there would be no need for the world state
17:06:07 <__Myst__> ertesx: Thing is
17:06:15 <__Myst__> As I said, I'm only using this on a prepopulated array internally
17:06:35 <Gurkenglas> mniip, which is good right?
17:06:43 <mniip> playMonadIO :: m Picture -> (Event -> m ()) -> (Float -> m ())
17:06:58 <ertesx> __Myst__: does it have to be a list in the first place?  if it's prepopulated you could benefit from a different data structure like Vector
17:07:04 <mniip> -> m ()
17:07:09 <ertesx> __Myst__: or even just a function
17:07:59 <__Myst__> ertesx: Well 
17:08:02 <__Myst__> I?m using this ery non-haskelly
17:08:09 <__Myst__> I change values on random indexes
17:08:22 <__Myst__> Like, I'm using this to for example
17:08:36 <__Myst__> Say I have list [0, 1, 2, 3, 4] and I want to set the item at index 2 to be 4
17:08:41 <__Myst__> I use this function, and merge evrything back together
17:09:00 <ertesx> __Myst__: well, you could just use a mutable vector =)
17:09:22 <__Myst__> ertesx: Any guide on that?
17:09:30 <Welkin> @package vector
17:09:30 <lambdabot> http://hackage.haskell.org/package/vector
17:09:32 <Welkin> yeah :D
17:10:56 <ertesx> __Myst__: the 'vector' library provides a mutable variants of all flavours of arrays…  pick the first one that works for you from:  unboxed, storable, boxed
17:11:23 <ertesx> __Myst__: it gives you pretty much a typical mutable array library with indexing, modification and bulk operations
17:11:31 <ertesx> the API should explain itself
17:13:17 <Gurkenglas> One thing that people might argue to be a downside of making the world state implicit is that you might now be able to introduce side effects into, say, printing the picture. Although you could already do that because IO and because you might depend on whether youre told to update on 2 milliseconds twice or on 4 milliseconds once
17:15:06 <mniip> huh
17:15:37 <mniip>     • Could not deduce (Functor a (->) (->)) arising from a use of ‘NT’ from the context: (Ob NT a, Ob NT b, Ob NT c)
17:15:42 <mniip> yet clearly it says here: instance Functor f (->) (->) => Ob NT f where
17:17:57 <dmwit_> mniip: Why does that warrant a "huh"?
17:18:30 <dmwit_> Oh, I understand.
17:18:31 <mniip> well, if instance F => G, then why can't we deduce F from G?
17:18:35 <dmwit_> Perhaps a kinding problem?
17:18:39 <pavonia> How does "Functor f (->) (->)" even kind-check?
17:18:57 <mniip> pavonia, not Prelude.Functor
17:19:03 <pavonia> Ah
17:20:59 <mniip> well, I kinda understand why that is so from the constraint dictionaries point of view
17:21:03 <mniip> but how do I work around this
17:21:05 <dmwit> mniip: I think only subclassing gives the implication you want.
17:21:13 <dmwit> mniip: Not "sub-instancing".
17:22:57 <mniip> hmm
17:24:10 <mniip> aha
17:24:36 * mniip rewrites Ob as an associated type synonym of the Category typeclass
17:24:44 <mniip> of kind Constraint
17:26:15 * mniip throws more KitchenSink
17:30:00 <__Myst__> Does this chat do code review?
17:30:14 <mniip> if it's not terribly big
17:30:18 <__Myst__> 66 lines
17:30:24 <__Myst__> I'd call that short
17:30:29 <dmwit> Just ask.
17:30:30 <__Myst__> considering it's counting type declarations and whitespace
17:30:31 <mniip> some folks might be able to assist
17:30:35 <__Myst__> Here it is http://paste.ofcode.org/QCzPsK5ua5CZuHSUTb6Az4
17:30:39 <__Myst__> It's some brainfuck interpreter
17:30:46 <dmwit> If somebody's into that, they'll code review. Just keep in mind that nobody owes you anything for asking.
17:31:03 <__Myst__> dmwit: I know, I was asking so that I could find somebody who was into code review
17:32:23 <caseof> I'm having a problem when using this function: http://lpaste.net/171509 Does this declaration makes sense?
17:33:30 <dmwit> __Myst__: partition and friends make me squint. Perhaps you will be better served by a zipper. (Indexing into [] is notoriously slow.)
17:33:48 <__Myst__> dmwit: Zipper?
17:33:54 <codebje> __Myst__: chr/ord are equivalent to toEnum/fromEnum, function "go" is partial and may blow up at runtime (because !! is partial)
17:33:57 <geekosaur> it does not. (op x y) typechecks only if op matches the types of x and y; but you declared op such that the caller can specify any type
17:34:05 <codebje> https://en.wikipedia.org/wiki/Zipper_(data_structure)
17:34:08 <__Myst__> codebje: !! is partial?
17:34:17 <codebje> __Myst__: [1] !! 5
17:34:28 <slack1256> > [1] !! 5
17:34:29 <lambdabot>  *Exception: Prelude.!!: index too large
17:34:39 <__Myst__> codebje: I really don'tg et how
17:34:53 <__Myst__> codebje: I only index the code and stop wen the index get too large
17:34:57 <dmwit> codebje: The declaration looks reasonable, though the type `forall a. a -> a -> a` is quite narrowly inhabited: only `\t _ -> t` and `\_ f -> f` are inhabitants and nothing else.
17:35:03 <__Myst__> and the stack I think is meant to error out if going over
17:35:12 <caseof> geekosaur: The types can be Int and Double which have Num instances, So I should be able to pass (+)
17:35:15 <codebje> __Myst__: the domain is Int, but !! doesn't have a defined value for all Ints
17:35:19 <dmwit> caseof: Incorrect.
17:35:32 <geekosaur> caseof, no, that is not how it works
17:35:35 <dmwit> caseof: See my last message at codedbje (which was a mistake).
17:35:36 <__Myst__> codebje: Sure, but there's no datatype for me to represent every number <30,000
17:35:58 <codebje> dmwit: oh good, I can stop trying to interpret that in the context of !! :-)
17:35:59 <caseof> How can I make that work?
17:36:39 <dmwit> caseof: Move the `Num` constraint inside the forall.
17:36:49 <Gribo> Is there any reason to learn haskell for fun?
17:36:51 <dmwit> caseof: (forall a. Num a => a -> a -> a) -> ...
17:37:00 <lpaste> nabs pasted “testing” at http://lpaste.net/171511
17:37:24 <Koterpillar> Gribo: yes; it's fun
17:37:29 <lpaste> nabs pasted “testing” at http://lpaste.net/171512
17:37:31 <dmwit> Gribo: I can think of few reasons better than "for fun".
17:38:02 <codebje> __Myst__: shrug, unhandled and hidden errors like that bother me, but if you don't want to make it explicit, that's not going to materially change much :-)
17:38:15 <__Myst__> codebje: I could just do it the Python way
17:38:20 <__Myst__> and moduloo it to 30000
17:38:36 <dmwit> __Myst__: ...or use a zipper, and dynamically expand the memory as needed.
17:39:05 <caseof> dwynwen_ddlleyw: thanks, did that. Now when I'm trying to use the function I get an error "[...] because type variable ‘a2’ would escape its scope [...]"
17:39:05 <codebje> true, a zipper is pretty ideal here: you can easily have an infinite "tape" and only blow up when you run out of real memory
17:39:12 <Gribo> dmwit: Koterpillar: what I meant is, is there any interesting projects to do with it that wouldn't be better implemented in other languages?
17:39:20 <nabs> ops..sorry 
17:39:24 <Gribo> Because from what I've been reading a lot of people say Haskell is useless.
17:39:25 <dmwit> __Myst__: (For that matter, you could expand the memory dynamically with your existing technique. A zipper would just make it easier.)
17:39:35 <codebje> data ZStack a = ZStack [a] a [a]  -- left of focus, focus, right of focus
17:39:46 <nabs> I didnt realize that the lpaste would be linked here.
17:40:02 <dmwit> Gribo: Well, if a lot of people say it, it must be true.
17:40:33 <ertesx> nabs: only if you select #haskell in the paste form
17:40:43 <Gribo> dmwit: These seemed to be respectable computer scientists.
17:40:43 <dmwit> Gribo: Haskell is a general purpose programming language. Any interesting project that can be done, can be done in Haskell. Moreover, I find it quite a pleasant language, to the point that any project I've wanted to do since I learned Haskell, I've wanted to do in Haskell.
17:40:57 <dustmote> i guess i can make a newtype which derives Num and Fractional etc... or i could just derive Functor and fmap operations on the content of the newtype
17:40:59 <__Myst__> dmwit: I'll look into zippers
17:41:00 <dmwit> Gribo: Only interop or social considerations have caused me to choose other languages.
17:41:08 <dustmote> what are the tradeoffs?
17:41:11 <__Myst__> dmwit: Original spec said size of 30k however
17:41:18 <Gribo> dmwit: interop? What's that?
17:41:45 <dmwit> Gribo: I have done some projects in other languages because I wanted to use existing code in that other language.
17:42:06 <Gribo> Oh
17:42:08 <dmwit> Gribo: Using Haskell wouldn't have prevented that; but the friction is sometimes not worth the upside.
17:42:21 <Gribo> dmwit: Why do people say it's useless though?
17:42:30 <dmwit> You would have to ask somebody who says that.
17:42:42 <Gribo> It had to do with safety.
17:42:53 <Gribo> Apparently they claimed it was too safe to be of any real use.
17:43:08 <dmwit> Do you find that convincing?
17:43:36 <slack1256> I remember a post that said some computers scientist hated declarative languages because they are algoritmists and thus the sequencial nature of standard langs fits they overall work better
17:43:38 <Gribo> dmwit: I'm not qualified enough to have an opinion
17:43:50 <Gribo> I just really like the syntax and look
17:43:51 <dmwit> Gribo: I know a way to fix that. =)
17:43:59 <Gribo> dmwit: How?
17:44:04 <ertesx> Gribo: for many people "i'd have to properly learn it" translates to "it's useless" =)
17:44:05 <dmwit> Gribo: Hack in Haskell for a while!
17:44:27 <Gribo> ertesx: These were published computer scientists.
17:44:37 <dmwit> Argument from authority doesn't impress me.
17:44:39 <ertesx> Gribo: that doesn't mean anything
17:44:43 <mniip> shachaf, so I made a thing :o
17:44:48 <mniip> and it even works
17:44:49 <Gribo> I know I know. I'm just saying, they probably knew the language very well
17:45:00 <Welkin> lol whaT?
17:45:02 <mniip> return :: Monoid f NT Compose => a -> f a; join :: Monoid f NT Compose => f (f a) -> f a
17:45:06 <mniip> shachaf, ^
17:45:08 <Welkin> why would you assume that?
17:45:13 <Welkin> appeal to authority
17:45:34 <dustmote> it seems like deriving Num and Fractional means my constraints when doing numeric operations start to include "Real (BlahNewtype a)"
17:45:40 <codebje> __Myst__: the initial value would be "ZStack [] 0 []" with '>' doing "(ZStack l f r) -> uncurry (ZStack (f:l)) $ maybe (0,[]) $ uncons r" for moving left and equivalent for right
17:45:45 <Gribo> It's how things work in real life. It's not a strong argument by any means but an economist is more likely to be right about economics than a random person picked from the street
17:45:48 <ertesx> Gribo: i wouldn't be sure of that; the reason is often less of a technical nature…  the average programmer can pick up pretty much every language simply by translating concepts from languages they already knew
17:45:52 <codebje> or something that typechecks
17:45:56 <ertesx> Gribo: haskell being an exception
17:46:07 <dmwit> dustmote: If your type can support `Num` and friends, I can think of very few downsides of doing so.
17:46:25 <Gribo> Anyway, is there any standard resources to learn Haskell and category theory?
17:46:31 <dmwit> ?where tutorials
17:46:31 <lambdabot> http://haskell.org/haskellwiki/Tutorials
17:46:45 <dmwit> Gribo: I really liked the gentle introduction, though it is famously misnamed.
17:46:48 <dmwit> ?where gentle
17:46:48 <lambdabot> http://www.haskell.org/tutorial/
17:46:51 <dustmote> dmwit: but if i do numeric stuff, it seems like i have to enable FlexibleInstances?
17:47:15 <dmwit> dustmote: If you want specific advice on a particular problem, you'll have to show enough code for us to see the problem.
17:47:19 <dmwit> ?paste
17:47:19 <lambdabot> Haskell pastebin: http://lpaste.net/
17:47:49 <Gribo> dmwit: Does it teach the math?
17:48:00 <codebje> it teaches the math or it goes back in the box
17:48:12 <Gribo> codebje: What do you mean?
17:48:20 <codebje> nothing useful, sorry
17:48:26 <dmwit> Gribo: It changed my worldview to the point that I ended up doing a Ph.D. in programming languages, and was a fantastic foundation for that effort.
17:48:49 <codebje> do you mean "does haskell teach the math" ?
17:48:57 <ertesx> Gribo: even if it doesn't teach the math, you will know what to look up, because haskell doesn't rename things
17:49:04 <dmwit> I think he meant "Does the Gentle Intro teach the math?".
17:49:12 <ertesx> Gribo: if we mean "monoid", we say "monoid", not "ICombinable" =)
17:49:20 <codebje> ertesx: that's so important!
17:49:33 <Gribo> yeah I meant that dmwit
17:49:34 <Koterpillar> IConfusing
17:49:52 <codebje> you can "get by" in haskell without learning the math, I think, but it'll be a struggle
17:50:04 <codebje> you can definitely get by without learning anything more than really cursory category theory
17:50:06 <Welkin> codebje: what???
17:50:19 <Welkin> you don't need to know any math or CT to program in haskell
17:50:22 <Gribo> So to be good at haskell you just need category theory?
17:50:23 <dmwit> Gribo: If you want a serious introduction to language design, I can recommend TAPL. If you want a serious introduction to category theory, I can recommend that you rethink what you want. Then I will suggest Barendregt's course notes on CT.
17:50:27 <Welkin> monoid, monad, etc. are just interfaces
17:50:31 <dmwit> Gribo: CT not required.
17:50:34 <codebje> Gribo: nah, you need basic algebra
17:50:43 <dmwit> Gribo: You can get quite far with just boring old programming skills. I did.
17:50:45 <slack1256> ^ that
17:50:54 <codebje> Welkin: sure, but if you don't really understand how they _work_ you'll be groping for ways to accomplish what should be easy
17:50:57 <ertesx> dmwit: i haven't read it…  by many sources the gentle intro is difficult to follow…  is that true?  and if yes, what's the trade-off?
17:50:57 <dolio> Can you program at all without knowing math?
17:51:03 <Gribo> Why is it always mentioned together with haskell though?
17:51:10 <codebje> Gribo: because Haskell doesn't lie about it
17:51:10 <Gribo> Category Theory that is
17:51:15 <Welkin> Gribo: haskell uses a lot of concepts from CT
17:51:23 <dmwit> ertesx: The Gentle Intro is terse, and doesn't do a lot of thinking for you.
17:51:26 <slack1256> at the end, haskell is really clever variable substitution. That really helped comming from school
17:51:29 <Welkin> but you don't need to understand them
17:51:36 <geekosaur> but that doesn't mean you need to know them. someone needed to know them to *create* the things you use, but you don't need to know it to use them
17:51:37 <dmwit> ertesx: The benefit of this is that it is terse, and doesn't do a lot of thinking for you. ;-)
17:51:49 <ertesx> Gribo: honestly you don't need *any* math…  what you need is basic logic and reasoning skills
17:51:51 <dmwit> ertesx: But seriously: I really appreciated the "no fluff, just content" approach.
17:51:57 <dolio> The benefit is that it's the only thing that existed 12 years ago.
17:52:01 <codebje> Welkin: it kind of helps to understand the sort of functor that Haskell's Functor typeclass is, but you don't really need to understand what sort of category theoretic functor it is
17:52:19 <dmwit> ertesx: The Gentle Intro was written by PL experts for PL experts. So it focuses on what makes Haskell interesting compared to other lambda calculi.
17:52:28 <dolio> Well, that's probably not true. But it was the only free thing.
17:52:43 <dmwit> ertesx: If you're strong on LC, the Gentle Intro is going to hit a sweet spot for you. If, like me, you had only heard the name, it will take some effort; but again I think it is well worth it.
17:53:06 <Welkin> LC?
17:53:13 <dmwit> lambda calculus
17:53:15 <codebje> ertesx: logic is a branch of mathematics :-)
17:53:17 <Welkin> ah
17:53:28 <ertesx> dmwit: does the age have an impact?  it's pre-AMP and pre-FTP and pre-many-other-things
17:53:35 <Gribo> dmwit: Is TAPL a book?
17:53:37 <dmwit> ertesx: Some, yes.
17:53:39 <Welkin> boolean algebra is trivial though...
17:53:40 <dmwit> Gribo: Yes.
17:53:42 <dmwit> ?where TAPL
17:53:42 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
17:53:44 <N3RGY> How do I make Pipes.ByteString and Pipes.Text more performant? Using the provided lenses (like "lines" and "unlines") yields pretty horrible performance compared to just using e.g. ByteString's "lines" function
17:53:51 <__Myst__> codebje: Where do I get ZStack?
17:54:20 <__Myst__> codebje: This chat is really hard to follow
17:54:21 <dmwit> ertesx: But for the most part, the Gentle Intro avoids the libraries entirely, focusing on the core language instead. So only tangential stuff is out of date, I think.
17:54:23 <__Myst__> there's way too many people
17:54:27 <__Myst__> people don't ping me when they're talking to me
17:54:29 <__Myst__> so I lose messages
17:54:29 <codebje> Welkin: so are monoids and (haskell) functors :-)
17:54:31 <__Myst__> ugh.
17:54:50 <slack1256> __Myst__: use /grep /filter on you irc client
17:54:54 <codebje> __Myst__: data ZStack a = ZStack [a] a [a] deriving Show -- left of focus, focus, right of focus
17:55:05 <ertesx> N3RGY: first identify the bottleneck…  it's unlikely to be a problem with pipes or bytestring/text
17:55:08 <slack1256> plus /msg to talk helpful people(?)
17:55:10 <dmwit> __Myst__: codebje posted the complete source of ZStack in-channel. It's just one line.
17:55:11 <codebje> __Myst__: the idea of the zipper is you have a "focus" on some element in the structure, and traverse the focus around
17:55:39 <N3RGY> ertesx: Here's my program: "main = P.runEffect $ (L.view (PB.lines . PB.unlines)) PB.stdin P.>-> PB.stdout"
17:55:40 <codebje> __Myst__: (if you're mathematically inclined, to link to the other conversation happening, a zipper is the _derivative_ of some data structure, here, the derivative of a list)
17:55:45 <slack1256> N3RGY: pipes probably doesn't have general performance tips (or gabriel would have already applied/enforced them)
17:56:03 <slack1256> N3RGY: you probably should lpaste some code that we can study
17:56:11 <N3RGY> slack1256: "main = P.runEffect $ (L.view (PB.lines . PB.unlines)) PB.stdin P.>-> PB.stdout"
17:56:14 <N3RGY> entire program
17:56:21 <codebje> __Myst__: if we had a list [1,2,3,4,5], and we focused on the 3, we'd have a ZStack of ([2,1] 3 [4,5]) - noting the left list is "backwards" so movement is O(1)
17:56:33 <slack1256> L I guess is Control.Lens
17:56:37 <__Myst__> Makes sense
17:56:38 <N3RGY> P is pipes, PB is Pipes.ByteString, L is Control.Lens
17:56:39 <N3RGY> exactly
17:56:41 <__Myst__> So I should brew my own zipper
17:56:43 <__Myst__> i get it
17:56:45 <codebje> if we moved left, we'd have a ZStack of ([1] 2 [3,4,5]), and right, ZStack [3,2,1] 4 [5]
17:56:57 <codebje> well, you brewed your own stack and dictionary types :-)
17:57:11 <dustmote> dmwit: no, i'm just trying to understand the implications of automatically deriving Num and Fractional
17:57:20 <ertesx> N3RGY: i see no obvious problems there, but i don't know how 'lines' and 'unlines' are implemented
17:57:38 <codebje> there is a zipper package, but it's highly generic, and you don't really need it
17:57:45 <N3RGY> ertesx: It's incredibly slow. Tens of times slower than naive lazy bytestring stuff
17:57:48 <codebje> ooh, or ListZipper
17:58:22 <ertesx> N3RGY: a straightforward implementation using the FreeT approach should yield very efficient code in time and space…  if it doesn't, i'd consider that a bug
17:58:49 <__Myst__> codebje: I don't have a problem with brewing my own to be honest
17:58:53 <ertesx> N3RGY: however, i've never been a big fan of the lens stuff, especially not in a case like this
17:58:58 <codebje> __Myst__: note that ListZipper is partial in left/right, so you could get nearly the same result as your code, except the error will trigger when you try to move rather than when you try to access
17:59:09 <N3RGY> ertesx: Unfortunately, they only provide a lens API as far as I can tell
17:59:12 <codebje> __Myst__: I'd recommend brewing your own trivial one for the first case, because it engenders understanding
17:59:26 <N3RGY> ertesx: Not sure why they don't just export "lines" as a function...
17:59:43 <ertesx> N3RGY: yeah, they do…  try implementing 'lines' and 'unlines' yourself as simple functions
17:59:57 <codebje> __Myst__: you can do one capped at 30k entries with "ZStack [] 0 (replicate 29999 0)"
18:00:01 <ertesx> N3RGY: the lens should not make a performance difference, but the underlying implementation of lines/unlines might
18:00:23 <codebje> but then I'd suggest your left/right methods should be "ZStack a -> Maybe (ZStack a)" because I don't like partial functions :-)
18:01:49 <codebje> __Myst__: you'd probably be well served running a zipper over the input too, because !!'s performance isn't fantastic
18:02:06 <nnon> If I want to see (and disable) the plugins on a module I'm loading via the GHC API, does anyone know where that info is stored?
18:02:09 <codebje> fortunately a ZStack can be a ZStack Char or a ZStack Int
18:02:14 <ertesx> N3RGY: oh, important note about ByteString: 'split' has been surprisingly slow for me
18:02:28 <ertesx> N3RGY: you can get a performance improvement by implementing 'lines' in terms of 'break' instead
18:03:48 <__Myst__> codebje: How do I handle moving left when I'm out of stuff?
18:03:50 <__Myst__> like
18:04:02 <__Myst__> moveLeft (ZStack [1, 2, 3] 4 [])
18:04:22 <ertesx> N3RGY: i found out why pipes-bytestring's 'lines' is terribly slow
18:04:29 <slack1256> FreeT?
18:04:33 <ertesx> N3RGY: it actually does a byte-by-byte algorithm =)
18:04:56 <ertesx> instead of using 'break'
18:04:59 <N3RGY> ertesx: ertesx: Yikes
18:05:06 <slack1256> ????
18:05:22 <N3RGY> OK, well as an excercise I guess I should write one using break
18:05:49 <ertesx> N3RGY: if it works, consider contributing to pipes-bytestring…  the current implementation is terrible, as far as i see
18:05:56 <N3RGY> slack1256: You can use FreeT to represent "effectful" list generation
18:06:08 <mniip> :exf "(forall x' y'. (forall x y. f x -> g y -> (x -> y -> x')) -> h y' -> (x' -> y' -> a)) -> (forall x' y'. f x' -> (forall x y. g x -> h y -> (x -> y -> y')) -> (x' -> y' -> a))"
18:06:27 <mniip> hmm, can it even do rank N?
18:06:39 <__Myst__> codebje: An issue with zippers is that
18:06:41 <exferenceBot> could not find expression
18:06:42 <slack1256> Yep
18:06:43 <N3RGY> ertesx: I don't actually understand exactly what is going on with the implementation of lines, or the motivation for making it a lens
18:06:43 <__Myst__> There's no efficient way to append to the end
18:06:58 <N3RGY> But I'll check it out
18:07:07 <ertesx> N3RGY: don't make it a lens for now…  once you have the basic function, turning it into a lens is pretty straightforward
18:07:44 <mniip> no wait that's wrong
18:08:14 <mniip> I don't think expressing this in CPS is a good idea
18:08:44 <ertesx> (you'd think they'd at least make it an Iso and get rid of 'unlines')
18:08:58 <divVerent> what is eitherM even good for? It seems to be an argument-reversed form of either that requires a monad
18:09:15 <divVerent> are there cases where this extra type assertion even helps?
18:09:26 <ertesx> divVerent: what's the type?
18:10:05 <divVerent> eitherM :: Monad m => Either a b -> (a -> m c) -> (b -> m c) -> m c
18:10:21 <divVerent> the m c could just as well be c, as far as the implementation is concerned
18:10:21 <ertesx> divVerent: doesn't look very useful to me
18:10:28 <N3RGY> ertesx: The significance of that is lost on me. My lens knowledge doesn't extend to Isos
18:10:42 <ertesx> divVerent: i'd just write (>>= either _l _r)
18:10:50 <divVerent> just wondering if the Monad m => assertion could help in some cases
18:10:56 <divVerent> ertesx: exactly
18:11:14 <codebje> __Myst__: is there an "append to end" operation in brainfuck?
18:11:44 <ertesx> divVerent: since it's still polymorphic, it doesn't help type inference (except perhaps in some extremely narrow cases where you'd benefit from having a Monad constraint)
18:11:48 <divVerent> ertesx: so rephrasing as a more generic question
18:11:49 <codebje> __Myst__: if you want an infinite zipper, then the "left" operation needs to know how to make a new value
18:11:51 <ertesx> divVerent: so i think it's pretty useless
18:11:57 <divVerent> idM :: Monad m => m a -> m a
18:12:03 <divVerent> are there any cases where this could be useful?
18:12:04 <__Myst__> codebje: Yes, I'm doing this by re'stricting moving to the Enum class
18:12:04 <ertesx> N3RGY: don't worry about it
18:12:05 <codebje> the uncons thing I did above produces a new monoidal value on moving
18:12:11 <__Myst__> codebje: So that I can do `toEnum 0`
18:12:11 <divVerent> and indeed, I also think it can't be useful
18:12:17 <codebje> going to away form keyboard for a bit, sorry
18:12:20 <__Myst__> codebje: Int and Char are both enums
18:12:21 <ertesx> N3RGY: it does allow some conveniences, but nothing earth-shaking
18:12:39 <divVerent> also... writing brainfuck interpreter in Haskell or what?
18:12:41 <glguy> divVerent: If it had any use it would be to assist with type inference
18:12:50 <ertesx> N3RGY: in fact most of these lenses aren't even lenses…  they violate the lens laws
18:13:01 <divVerent> reminds me that I wanted to make a turing interpreter in ex or ed ;)
18:13:05 <__Myst__> divVerent: Wrote, I'm optimizing it now
18:13:09 <N3RGY> N3RGY: Then why did they bother? Makes things more complicated
18:13:14 <__Myst__> Is there a good way to append to the end of a list?
18:13:15 <N3RGY> I mean * ertesx
18:13:17 <N3RGY> lol
18:13:23 <ertesx> N3RGY: search the haddock page for "improper" to see what i mean
18:13:30 <ertesx> N3RGY: https://hackage.haskell.org/package/pipes-bytestring-2.1.3/docs/Pipes-ByteString.html
18:13:37 <lpaste> mniip pasted “applicative monoid in the category of endofunctors” at http://lpaste.net/171517
18:13:37 <N3RGY> __Myst__: If you need append to the end, use Data.Sequence
18:13:46 <mniip> anyone wanna do some exference by hand? ^ :p
18:13:53 <dustmote> http://lpaste.net/171516 this code causes an error because of the inferred signature of the function (it requires FlexibleContexts)
18:14:03 <N3RGY> ertesx: Yeah, I saw that. But if they're not even obeying lens laws, seems like they're just using lenses for the sake of being cool
18:14:15 <slack1256> (which they are)
18:14:22 <ertesx> N3RGY: i have no idea…  personally i don't use the improper lens stuff
18:14:39 <ertesx> N3RGY: and i don't have much faith in pipes-bytestring either, so i tend to just write my own implementations =)
18:14:45 <__Myst__> N3RGY: I'll keep that in mind
18:14:55 <dustmote> i guess it's fixed if i derive `Real` .. it seems kind of weird to just derive all the numeric classes..
18:15:17 <divVerent> __Myst__: hehe, nice
18:15:43 <ertesx> N3RGY: there are some genuine use cases for the lens stuff
18:15:58 <divVerent> I've still got a bf interpreter in vi macros (not necessarily vim) lying around... a clear case of accidentally turing complete
18:16:46 <ertesx> N3RGY: for example if you want to map a function 'f' over the part of a producer 50 elements ahead:  producer & drop 50 %~ f
18:17:18 <__Myst__> divVerent: lol. link?
18:17:21 <__Myst__> Question, in a zipper
18:17:28 <ertesx> N3RGY: that would be rather difficult to do without the lens…  but they go a bit overboard with it
18:17:42 <__Myst__> When moving left with state `ZStack [1, 2] 3 [4, 5]` will the end result be `ZStack [1, 2, 3] 4 [5]` or is that moving right?
18:17:57 <N3RGY> ertesx: That is quite cool. However, doesn't that involve an expensive "inverse" operation with every lens usage?
18:18:01 <mniip> ZStack [3, 1, 2] 4 [5]
18:18:07 <__Myst__> mniip: wat?
18:18:10 <ertesx> N3RGY: nope
18:18:11 <mniip> yes
18:18:15 <__Myst__> mniip: wat?
18:18:17 <__Myst__> I don't get it.
18:18:23 <ertesx> N3RGY: not anything you wouldn't have to do without the lens anyway
18:18:42 <nitrix> __Myst__: It cannot become [1,2,3] 4 [5]
18:18:57 <ertesx> N3RGY: (lenses are cheap, and most of the time free)
18:18:59 <mniip> well it can but storing that list in reversed form would be very inefficient
18:19:05 <nitrix> At least, it wont conserve nice O properties if you do that.
18:19:13 <mniip> and might cause issues if you want to use an infinite tape
18:19:14 <__Myst__> mniip: oh so I should store it in reversed form and pull from the top?
18:19:20 <nitrix> __Myst__: Generally, the elements are added at the begining of the list, not its end.
18:19:33 <dustmote> does the haskell numeric tower correspond to some theory that will help it make sense for me? Fractional, RealFrac, and Floating .. I'm just confused
18:20:07 <nitrix> ZStack [2, 1] 3 [4, 5]  then moving right gives ZStack [3, 2, 1] 4 [5]
18:20:16 <slack1256> dustmote: they wish
18:20:16 <__Myst__> nitrix: That makes sense, thank you
18:20:41 <slack1256> dustmote: it is mostly a tower that works most of the time (tm)
18:22:23 <dustmote> hmm.. yeah, i've mustly ignored it and done conversions where necessary, but sometimes i want to write code that does things with numbers but doesn't prescribe your numeric type ... i usually fail and end up writing code which is very perscriptive
18:22:44 <ertesx> N3RGY: actually i take it back…  it's surprisingly easy to do without the lens =)
18:23:02 <N3RGY> ertesx: How's that?
18:23:10 <__Myst__> So wait
18:23:14 <ertesx> N3RGY: splitAt :: Producer a m r -> Producer a m (Producer a m r)
18:23:20 <__Myst__> How would a zipper form of the array [1, 2, 3, 4, 5] work if I was focusing on 3?
18:23:21 <ertesx> N3RGY: then use fmap
18:23:25 <__Myst__> Please ping me if you're answering
18:23:35 <ertesx> N3RGY: whoops…  splitAt :: Int -> Producer a m r -> Producer a m (Producer a m r)
18:23:41 <Koterpillar> __Myst__: ZStack [2, 1] 3 [4, 5]
18:24:03 <__Myst__> Koterpillar: god that's confusing.
18:24:11 <ertesx> N3RGY: append . fmap f . splitAt 50  -- where append :: Producer a m (Producer a m r) -> Producer a m r
18:24:34 <ertesx> N3RGY: (that's basically what the lens does anyway)
18:24:35 <Koterpillar> __Myst__: by the way, do you mind making it easier to highlight you by removing __ from the nick? :P
18:24:56 <__Myst__> Koterpillar: Your client should ping me atuomatically if you type Myst and tab
18:24:59 <__Myst__> Atleast mine does, Koterpillar
18:25:09 <Koterpillar> touché 
18:31:16 <Koterpillar> __Myst__: both _ends_ of the array end up being _ends_ of those lists: ZStack [2, 1 *here*] 3 [4, 5 *here*]
18:32:09 <ertesx> hmm…  the gentle intro isn't that bad, i must say…  have beginners actually complained about its difficulty?
18:32:25 <ertesx> or is it just haskell programmers who say it has to be difficult?
18:32:47 <sleblanc`> "stack setup" puts 1.1G of stuff in a directory inside /tmp; that's a lot of data to load in RAM for limited systems
18:33:15 <Koterpillar> sleblanc`: /tmp or something like $TMPDIR?
18:33:32 <codebje> __Myst__: back now, how's it going?
18:33:57 <sleblanc`> Koterpillar: hang on, will try
18:34:24 <__Myst__> codebje: Pretty good, however Zippers are hard to understand 
18:34:35 <codebje> __Myst__: the left list is "backwards" so that moving left is a very cheap operation
18:34:42 <codebje> (and right, because it's prepend, not append)
18:34:54 <sleblanc`> Koterpillar: ok, it respects TMPDIR
18:35:01 <codebje> you can think of the "left" side as the "history" of your movement through the zipper
18:35:04 <__Myst__> codebje: They're both backwards, isn't it?
18:35:08 <__Myst__> aren't they*
18:35:17 <Koterpillar> no
18:35:25 <codebje> no, the right list is the normal order
18:35:36 <Koterpillar> they are both going from where you are to the ends
18:35:38 <codebje> toZipper [1,2,3,4,5] == Zipper 1 [2,3,4,5]
18:35:46 <codebje> toZipper [1,2,3,4,5] == Zipper [] 1 [2,3,4,5]
18:35:57 <dustmote> seems like rationals are a good internal representation..
18:35:58 <codebje> moving right takes the head of the right list as the focus, and prepends the focus as the head of the left list
18:36:06 <codebje> both very cheap
18:36:18 <ertesx> __Myst__: ZStack "lleH" 'o' " world!"  -- the end that is modified often is at the front
18:36:18 <codebje> moving left takes the head of the left list as the focus, and prepends the focus as the head of the right list
18:36:37 <__Myst__> codebje: it's rather hard to understand
18:36:39 <__Myst__> but I got it
18:36:42 <__Myst__> codebje: Want a link?
18:36:45 <codebje> sure
18:37:40 <__Myst__> codebje: http://paste.ofcode.org/33neL2FwRRRD3ENQBDVA5W2
18:38:12 <codebje> (the use of "toEnum 0" is good, by the way)
18:38:36 <codebje> (I was thinking mempty, but that's stronger than you need)
18:39:21 <__Myst__> Are ints even monoids?
18:39:38 <ertesx> > getSum (Sum 3 <> Sum 4)
18:39:39 <codebje> they're multiple monoids at once
18:39:41 <lambdabot>  7
18:39:50 <ertesx> > getProduct (Product 3 <> Product 4)
18:39:55 <lambdabot>  12
18:40:21 <codebje> but you definitely don't need a monoid, and you don't need an identity, just a "zero"
18:40:51 <codebje> (there should be a singleton type class providing mempty, imo, but that's another tale)
18:40:59 <codebje> (singleton? wrong word, probably)
18:41:29 <Welkin> why?
18:41:46 <__Myst__> Welkin: ease of use?
18:42:05 <ertesx> there is Data.Default, but "mempty" has meaning compared to "def", which is just an arbitrary value someone marked as "default", because they liked the aesthetics of the value
18:42:07 <codebje> Welkin: hmm, I was going to say "because identity is useful on its own" but it really isn't
18:42:20 <codebje> Welkin: you're right, there shouldn't be
18:42:22 <codebje> :-)
18:42:54 <codebje> monoid's only useful contribution is the identity on the operation, assuming it's an extension of a semigroup
18:43:01 <codebje> thus, there must be an operation
18:44:41 <ertesx> people underestimate the usefulness of Monoid
18:45:27 <sleblanc`> codebje: PureScript (a variant of Haskell?) the Monoid is implemented as an extension of the Semigroup type class : http://blog.functorial.com/posts/2015-12-06-Counterexamples.html
18:45:52 <sleblanc`> Not sure what PureScript is; I just thought the article was interesting
18:46:08 <codebje> sleblanc`: purescript is a strict haskell-like language compiling to javascript
18:46:10 <Welkin> purescript is a haskell-like language for javascript
18:46:24 <codebje> there's a proposal to make semigroup be a superclass of monoid in GHC base
18:46:25 <Welkin> and haskell has semigroup, too
18:46:33 <codebje> progress is up to having <> in Prelude, I think
18:46:51 <Welkin> but since it wasn't added until later, monoid does not require it
18:47:00 <codebje> https://prime.haskell.org/wiki/Libraries/Proposals/SemigroupMonoid
18:47:18 <codebje> GHC 8 adds semigroup and NonEmpty to base
18:47:34 <codebje> 8.2 adds <> to Prelude (hooray)
18:47:43 <Welkin> purescript was created by one person
18:48:15 <Welkin> he can do whatever he wants with it
18:48:29 <Welkin> I wonder how many people actually use purescript
18:48:43 <codebje> purescript is nice enough, but I tried writing a monadic parser in it and blew the JS stack because strictness :(
18:48:43 <Welkin> and if haskell will ever swap back : and ::
18:49:14 <codebje> (there are plenty of fixes for blowing the stack on a monadic chain, but you can't treat purescript like "haskell in the web")
18:49:45 <__Myst__> codebje: Won't `asm.js` help with "haskell in the web"?
18:50:05 <sleblanc`> Welkin, the : - :: swap is bound to be very controversial
18:50:12 <codebje> __Myst__: nah, asm.js is just "here's a tiny subset of javascript to use, oh, and it uses a fixed byte array for memory, no allocations"
18:50:21 <Welkin> it probably won't ever happen :P
18:50:30 <__Myst__> codebje: I'm assuming since you can compile C to asm.js you could also compile Haskell to it
18:51:27 <codebje> __Myst__: theoretically you can, though you'll need to write a new runtime for it
18:51:57 <__Myst__> codebje: Some people are dedicated enough for it.
18:52:04 <codebje> you may as well just use ghcjs if you want to do that
18:53:01 <codebje> I'm not sure how much you'd really gain by writing your own allocator and garbage collector
18:53:11 <__Myst__> ghcjs?
18:53:48 <codebje> https://github.com/ghcjs/ghcjs
18:56:15 <codebje> __Myst__: I suspect your loops are broken in the ZStack variant
18:56:23 <__Myst__> codebje: Why?
18:56:30 <__Myst__> codebje: They seem to run fine
18:56:53 <__Myst__> https://esolangs.org/wiki/Brainfuck has a Hello World variant which "is meant to trigger interpreter bugs" and it's always worked for me whenever I had a buggy interpreter
18:56:57 <__Myst__> ANd it works for this one
18:57:17 <codebje> oh, nevermind, you're only using a zipper for the stack, not the program code
18:57:49 <__Myst__> codebje: Yes, I was just about to ask
18:57:58 <__Myst__> How would I even go about using zippers for the acutal code?
18:59:16 <codebje> probably rename ZStack to Zipper, and declare "type Program = Zipper Char", that's more or less it
18:59:57 <__Myst__> codebje: I meant for the loops
19:00:42 <codebje> ah well, because it's a zipper structure it'll cost you the scan time from loop start to end to move regardless, so drop the "parseLoops" bit and introduce a "moveMatching" bit to move to a matching loop instruction
19:01:19 <__Myst__> codebje: That would add the cost of handling nested loops every time
19:01:41 <codebje> __Myst__: sure, but it'll remove the cost of iterating through the program code to reach the current instruction for every instruction, so overall a win
19:01:52 <codebje> even for a pathological program consisting only of nested loops, I think
19:02:02 <lpaste> mniip pasted “A monad is just a monoid in the category of endofunctors” at http://lpaste.net/171524
19:02:04 <__Myst__> codebje: Why, can't I just keep the parseLoops and add a `moveLeftTimes`
19:02:20 <__Myst__> codebje: ANd then calculate the offset I need to move
19:03:28 <codebje> __Myst__: oh, you could, but you won't gain much performance because "moveLeftTimes" will do <x> list destructure/construct operations where <x> is the length of the loop, and a "moveMatcing" will do <x> list destructure/construct operations plus <x> comparisions
19:03:54 <__Myst__> codebje: Would I gain performance on regular moving though?
19:04:12 <codebje> line 46 is O(n) on size of input, because of the list index operation
19:04:32 <dustmote> dmwit: deriving Num means (11 :: MyNewtype) is valid sintax.. it means literals can bypass a smart constructor! yikes
19:04:35 <codebje> so if you're near the end of a large BF program, every program instruction involves counting off the program counter from the start of the program each time
19:04:55 <__Myst__> codebje: So basically, using a Zipper I would gain performance on everything but loops?
19:05:21 <codebje> yes, and loops would only be slower if the location of the loop instruction were closer to the start of the program than the length of the loop
19:05:33 <dmwit> dustmote: Instances can be written by hand if the semantics of the derived instance are not desirable.
19:05:36 <codebje> but you can keep parseLoops if it helps you think about it
19:06:21 <dmwit> dustmote: But yes, the conditional "If your type can support `Num`" in my last statement is important.
19:06:55 <N3RGY> ertesx: Pipes.ByteString doesn't use a byte-by-byte algorithm. It uses ByteString.span
19:07:09 <N3RGY> the "nextByte" is only used to consume the newline
19:07:09 <__Myst__> codebje: Isn't it faster?
19:07:29 <__Myst__> codebje: Like, isn't the cost of needing to fetch the matching bracket bigger?
19:07:36 <dustmote> dmwit: thanks for the heads up, though i guess i missed the important nuance therein.. it was documented here anyhow https://hackage.haskell.org/package/base/docs/Prelude.html#v:fromInteger
19:07:37 <__Myst__> codebje: Like, isn't the cost of needing to fetch the matching bracket bigger than just moving n amount of times?
19:07:41 <dustmote> dmwit: thanks for your help!
19:07:59 <codebje> __Myst__: yes, by a small constant amount because you're doing comparisons and counting nesting levels each time
19:08:11 <codebje> (constant per iteration, that is)
19:08:16 <codebje> (per step?)
19:08:25 <__Myst__> Micro-optimization + it helps me get the program
19:09:26 <__Myst__> codebje: I'm assuming that I'd also add a O(n) cost of initially parsing the string to a zipper, right?
19:09:34 <codebje> __Myst__: don't forget that the lookup in the loops structure is also O(n) in the number of loops in the program, so it's not a clear cut optimisation - it's a premature optimisation
19:09:47 <codebje> __Myst__: Nope, constructing a zipper focussed on the first element of a list is O(1)
19:10:11 <__Myst__> Assuming program code is in variable `cs`
19:10:14 <__Myst__> Would I do this?
19:10:18 <codebje> toZipper :: String -> Zipper Char ; toZipper (a:bs) = Zipper "" a bs
19:10:31 <__Myst__> case cs of (x:xs) -> Zipper [] x xs
19:10:46 <codebje> yep
19:10:57 <__Myst__> What if toZIpper gets passd []?
19:11:07 <dmwit> codebje: I like the signature of `zippers :: [a] -> [Zipper a]` better (and it's occasionally useful to have all possible zippers).
19:11:10 <codebje> it'll fail
19:11:23 <__Myst__> codebje: I'll just add the case of `toZipper [] = undefined`
19:11:34 <codebje> that's what it already is :-)
19:11:41 <codebje> (but writing it explicitly is OK)
19:11:44 <dmwit> __Myst__: zippers = go [] where go l [] = []; go l (v:r) = (l, v, r) : go (v:l) r
19:12:35 <dmwit> __Myst__: This is from the `Dmwit.hs` that I keep lying around for when I want to write one-off stuff. For your purposes, replace `(,,)` with `Zipper` if you need.
19:13:47 <dmwit> __Myst__: (...and then if you absolutely must have the partial version, you can write `toZipper = head . zippers`.)
19:14:31 <__Myst__> codebje: Won't go need to take a zipper as an argument now?
19:14:42 <codebje> __Myst__: yes, in place of the Index argument more or less
19:16:19 <__Myst__> codebje: huh.
19:16:24 <__Myst__> I'll still need to have an i, thinking about it
19:16:34 <__Myst__> or, I can make it a `Zipper (int, char)`
19:17:40 <codebje> what for?
19:17:53 <codebje> oh, if you want to compute the distance to move on loops
19:18:25 <__Myst__> yep
19:18:46 <__Myst__> I really need to give better names to my variables
19:22:03 <dmwit> Since the code never changes, I propose that loops be implemented by simply storing the zipper after the jump point.
19:22:11 <dmwit> One zipper per jump target.
19:22:16 <dmwit> Store it in the jump source.
19:22:35 <dmwit> There is basically no memory cost, and the runtime improvement will be noticeable on programs with many jumps
19:23:07 <dmwit> __Myst__: (no content in this message, just highlighting you)
19:25:47 <__Myst__> codebje: I'm surprised (Enum, Enum) isn't an instance of Enum
19:26:40 <mniip> __Myst__, succ (3, 5) :: (Integer, Integer)
19:26:53 <__Myst__> > succ (3, 5) :: (Integer)
19:26:55 <lambdabot>      Couldn't match expected type ‘Integer’
19:26:55 <lambdabot>                  with actual type ‘(Integer, Integer)’
19:26:55 <lambdabot>      In the first argument of ‘succ’, namely ‘(3, 5)’
19:26:57 <__Myst__> > succ (3, 5) :: (Integer, Integer)
19:26:59 <lambdabot>      No instance for (Enum (Integer, Integer))
19:27:00 <lambdabot>        arising from a use of ‘succ’
19:27:00 <lambdabot>      In the expression: succ (3, 5) :: (Integer, Integer)
19:27:09 <__Myst__> mniip: ^
19:27:09 <mniip> asking you what's that supposed to be
19:27:12 <Axman6> how would that work?
19:27:14 <__Myst__> (4, 6)
19:27:20 <mniip> ok, what's
19:27:30 <mniip> enumFromTo (3,5) (6,7)
19:27:47 <Axman6> what should succ (1,255) :: (Word8, Word8) return? Enum has no way of knowing that succ 255 is the last value
19:27:57 <__Myst__> zip (enumFromTo 3 6) (enumFromTo 5 7)
19:28:08 <Axman6> that definitely seems wrong
19:28:12 <mniip> hmm
19:28:19 <mniip> probably not so wrong
19:28:28 <Axman6> (,) [3..6] <*> [5..7] seems to be the right answer
19:28:59 <mniip> well the [] applicative doesn't explain why 'succ (x, y)' is a single number
19:29:04 <mniip> while ZipList does
19:30:15 <__Myst__> Shrug
19:30:20 <__Myst__> I''ll find some way to work around it
19:31:00 <Axman6> > (5,6) ^. both . to succ
19:31:01 <lambdabot>      Ambiguous occurrence ‘to’
19:31:02 <lambdabot>      It could refer to either ‘Control.Lens.to’,
19:31:02 <lambdabot>                               imported from ‘Control.Lens’ at /tmp/mueval1365...
19:31:10 <Axman6> > (5,6) ^. both . Control.Lens.to succ
19:31:12 <lambdabot>      No instance for (Show a0)
19:31:12 <lambdabot>        arising from a use of ‘show_M329721031832871330616520’
19:31:12 <lambdabot>      The type variable ‘a0’ is ambiguous
19:31:20 <Axman6> > (5,6) ^. both . Control.Lens.to succ :: (Integer, Integer)
19:31:22 <lambdabot>      No instance for (Num (Integer, Integer))
19:31:22 <lambdabot>        arising from the literal ‘5’
19:31:22 <lambdabot>      In the expression: 5
19:31:52 <Axman6> bleh, obviously...
19:32:11 <Axman6> > (5,6) & both %~ succ :: (Integer, Integer)
19:32:14 <lambdabot>  (6,7)
19:33:24 <codebje> > (succ &&& succ) (5,6)
19:33:26 <lambdabot>      No instance for (Show t0)
19:33:26 <lambdabot>        arising from a use of ‘show_M159089378470250086016587’
19:33:26 <lambdabot>      The type variable ‘t0’ is ambiguous
19:33:31 <codebje> pft is not
19:33:38 <codebje> > (succ &&& succ) (5,6) :: (Int, Int)
19:33:39 <lambdabot>      Couldn't match type ‘Int’ with ‘(Integer, Integer)’
19:33:40 <lambdabot>      Expected type: (Integer, Integer) -> (Int, Int)
19:33:40 <lambdabot>        Actual type: Int -> (Int, Int)
19:33:46 <codebje> oh duh
19:33:52 <codebje> > (succ *** succ) (5,6)
19:33:54 <lambdabot>  (6,7)
19:33:55 <codebje> better
19:34:37 <Axman6> that's not a fun to say out loud though =)
19:34:50 <Axman6> 5, 6 and both succ
19:34:59 <codebje> "succ timeflieslikeanarrow succ 5 and 6"
19:35:59 <codebje> __Myst__: go :: ZStack Int -> ZStack Char -> Index -> IO () ?
19:36:03 <codebje> that works around it :-)
19:36:15 <codebje> (except you have to keep your index and zipper focus in sync)
19:40:06 <mniip> something tells me that ZStack should be strict in all 3 fields
19:41:08 <ertesx> what's your favourite Word32?
19:42:41 <Axman6> 4294967296
19:42:53 <mniip> 0
19:43:07 <mniip> what a coincidence
19:43:21 <Axman6> twinsies
19:43:31 <ertesx> Axman6: why that one?
19:43:42 <Axman6> > 4294967296 :: Word32
19:43:44 <lambdabot>  0
19:44:00 <Axman6> > maxBound + 1 :: Word32
19:44:02 <lambdabot>  0
19:45:12 <ertesx> thanks
19:45:22 <ertesx> anyone have a favourite Char?
19:45:37 <sleblanc`> I like →
19:45:45 <sleblanc`> :t '→'
19:45:46 <lambdabot> Char
19:45:53 <Axman6> > '\NUL' -- is pretty handy
19:45:55 <lambdabot>  '\NUL'
19:45:56 <ertesx> sleblanc`: why?
19:46:08 <zcd> mander :: Char
19:46:15 <ertesx> Axman6: for the library i'm writing usefulness doesn't matter, only aesthetics
19:46:25 <sleblanc`> Because arrows look fancy when you use them in a chat
19:46:28 <sleblanc`> compose key ftw
19:48:14 <Axman6> '\NUL' is really useful when you need to compress text in C programs - just sprinkle a few around and all your strings will be compressed automatically
19:48:32 <ertesx> please tell me more favourites in #haskell-blah; i still need a few base types =)
19:48:33 <Axman6> which IMO, is pretty, because consise strings are good strings
19:51:22 <slack-haskell1> <jiyinyiyong> How about this Char ":coffee:"
19:52:57 <Squarism> can i write a nice pattern match that provides me first, last and elements inbetween (of possibly 0-length) of a list ? 
19:53:27 <dmwit> Squarism: Nope. For that you need a type that was designed for access from both ends.
19:53:38 <dmwit> Squarism: You can write an ugly pattern match, though. =)
19:53:58 <slack-haskell1> <jiyinyiyong> how to match the last one?
19:54:08 <Squarism> dmwit, how would that utly variant look? 
19:55:16 <dmwit> let uncons [] = Nothing; uncons (x:xs) = Just (x, xs); unsnoc [] = Nothing; unsnoc _ = Just (init xs, last xs) in foo (uncons -> Just (firstElem, unsnoc -> Just (remainder, lastElem))) = ...
19:55:26 <dmwit> requires some extensions; GHC will tell you which
19:55:33 <dmwit> gotta run
19:55:57 <Squarism> thanks
19:56:25 <dmwit> Strictly speaking `unsnoc` isn't needed, but it's nice symmetry.
19:56:36 <dmwit> s/unsnoc/uncons/
19:57:01 <dmwit> Without it, the pattern would be `foo (firstElem:(unsnoc -> Just (remainder, lastElem)) = ...`
19:59:42 --- mode: ChanServ set +o glguy
19:59:43 --- mode: glguy set +q *!*@188.166.222.62
20:00:26 <mniip> oh was that unauthorized?
20:01:37 <glguy> yeah, proxy bots aren't welcome
20:03:59 <glguy> jiyinyiyong: You'll need to join the channel directly to chat in it
20:04:18 <mniip> oh it's +z
20:05:45 <jiyinyiyong> so, why? I don't use IRC often but spend a lot time in Slack. Did that bother you?
20:05:54 --- mode: glguy set -qo slack-haskell!*@* glguy
20:06:38 <mniip> no it probably was the bot
20:07:24 <glguy> You're welcome to join #haskell-ops if you want to talk about it
20:20:34 --- mode: ChanServ set +o glguy
20:20:35 --- mode: glguy set -qo *!*@188.166.222.62 glguy
20:21:20 * hackagebot higher-leveldb 0.4.0.0 - A rich monadic API for working with leveldb databases.  https://hackage.haskell.org/package/higher-leveldb-0.4.0.0 (jeremyjh)
20:21:20 * hackagebot vector-bytes-instances 0.1 - Serial (from the bytes package) for Vector (from the vector package)  https://hackage.haskell.org/package/vector-bytes-instances-0.1 (RenzoCarbonara)
20:31:32 <maybefbi> what is the best for one thread to access a value that another thread periodically updates by querying the web?
20:31:52 <maybefbi> s/best/best way/
20:31:55 <Welkin> MVar?
20:31:58 <Welkin> TVar?
20:32:13 <maybefbi> TVar better than MVar?
20:32:14 <mniip> IORef if you don't care about atomicity
20:32:52 <dmj`> if you don't need thread synchronization, then yea, IORef
20:32:54 <Welkin> @where parconc -- maybefbi 
20:32:54 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
20:33:12 <maybefbi> Welkin, thanks
20:33:14 <monochrom> TVar or IORef.
20:33:22 <maybefbi> ok
20:33:46 <monochrom> MVar is not designed for just-reading.
20:34:04 <maybefbi> whats the deal with Chans?
20:34:11 <maybefbi> is that for the same purpose?
20:34:27 <monochrom> it's a message queue. do you want a message queue?
20:35:03 <maybefbi> if it is faster way to look up a value updated by another thread then yeah
20:35:09 <monochrom> IORef is fine for multithreading if there is only one IORef at stake. use atomicModifyIORef etc.
20:35:18 <maybefbi> ok
20:35:22 <dmj`> Chans are like linked lists of MVars
20:35:33 <maybefbi> dmj`, i see
20:36:07 <maybefbi> thanks i will read up on all of that
20:36:40 <dmj`> would recommend TQueue though, since it's similar conceptually, but performs better
20:37:21 <maybefbi> copy that
20:38:13 <Welkin> where is TQueue?
20:38:57 <dmj`> Control.Concurrent.STM
20:40:41 <dmj`> unagi chan is fastest though, for x86 arch.'s since it uses a specific processor instruction, fetch-and-add
20:40:46 <dmj`> https://en.wikipedia.org/wiki/Fetch-and-add
20:43:46 <Welkin> unagi chan?
20:43:47 <Welkin> lol
20:43:53 <Welkin> little rabbit?
20:44:40 <dmj`> @package unagi-chan
20:44:40 <lambdabot> http://hackage.haskell.org/package/unagi-chan
20:46:42 <Squarism> what is the shortest form of filtering a list with a certain constructor?
20:47:10 <glguy> list comprehension
20:49:32 <dmj`> > [ Right x | Right x <- [ Left (1 :: Int), Right (0 :: Int) ] ]
20:49:34 <lambdabot>  [Right 0]
20:49:54 <Squarism> glguy, thanks man
20:50:24 <geekosaur> or for more complex constructors, try [ x | x@(Constr{}) <- xs ] for whatever xs
20:50:55 <dmj`> > [ x | x@Right{} <- [ Right (0 :: Int) ] ]
20:50:57 <lambdabot>  [Right 0]
20:51:21 <geekosaur> oh right, record syntax binds tightest...
20:51:53 <Squarism> Hmm.. i realize that what i want to do is verify all elemnts in a list match a certain constructor
20:52:04 <geekosaur> anyway that's useful if there's more than one data value in the constructor (e.g. Foo Int String [Bar])
20:52:16 <Welkin> and . map f
20:52:31 <Welkin> f :: a -> Bool
20:52:51 <Squarism> so f would be a pattern match?
20:52:56 <Welkin> yes
20:53:01 <Welkin> that produces True or False
20:53:02 <glguy> and . map f   is   all
20:53:07 <glguy> err, all f
20:53:17 <Welkin> :t all
20:53:19 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
20:53:24 <Welkin> didnt='t know about that
20:53:25 <Welkin> haha
20:53:25 <dmj`> I'd say that's a predicate, not a pattern match
20:53:49 <dmj`> f :: a -> Bool, that is
20:54:09 <mniip> hmm
20:54:19 <dmj`> I guess, filter isJust [Just 1, Nothing] would act like a pattern match, but it's a pattern match that returns a Bool
20:54:19 <Squarism> i mean u need a pattern match to create the predicate
20:54:20 <mniip> so uh, anyone up for a puzzle
20:54:22 <dmj`> @src isJust
20:54:22 <lambdabot> isJust Nothing = False
20:54:22 <lambdabot> isJust _       = True
20:54:52 <mniip> http://lpaste.net/171517
20:54:57 <Welkin> bad definition...
20:55:02 <Welkin> _ instead of Just
20:55:42 <Squarism> wish there were a : matches :: Pattern -> Bool =D
20:56:07 <mniip> that's not really useful
20:56:18 <jle`> the lens library has some TH that can auto-generate those for you if you're already using it
20:56:28 <glguy> There kind of is, you can treat lens prisms like constructors
20:56:29 <Welkin> lol jle` 
20:56:30 <Squarism> for all type predicates it would be 
20:56:33 <Welkin> lens *and* TH?
20:56:37 <glguy> and then "has" is that function
20:56:43 <glguy> You don't need TH, the TH is just handy
20:56:47 <jle`> yeah, it's not possible to auto-generate them without TH
20:56:48 * mniip waves at jle`
20:57:01 <jle`> because the names of the lenses depends on the names of the constructor
20:57:08 <jle`> s/lenses/prisms
20:57:10 * jle` waves back
20:57:15 <mniip> jle`, up for a puzzle?
20:57:25 <jle`> doesn't hurt to send it!
20:57:27 <mniip> http://lpaste.net/171517
20:57:56 <glguy> jle`: You can probably generate the prisms with generics (you can generate lenses with generics). You specify the names as part of the process. It end s up looking like:  (field1, field2, field3) = generateLenses
20:58:18 <jle`> yeah, you can write them yourself, that's what i always do actually
20:58:25 <jle`> but you need TH for full automatic generation
20:59:17 <glguy> jle`: http://lpaste.net/116931#line70
20:59:17 <jle`> but in this case, if all they want is a '(Constructor) -> Bool', might as well write the actual function instead of writing the prism, heh
21:00:35 <jle`> glguy: that's pretty neat :o
21:01:01 <glguy> The same process ought to work for prisms, time to find out I guess
21:04:01 <Squarism> im not familiar with prisms yet
21:04:12 <glguy> You can forget about them for now
21:04:22 <Welkin> it's just part of lens
21:04:31 <Welkin> if you never use lens, you don't need to know them
21:04:33 <glguy> (Unless you are interested, then of course ask questions, but it's optional reading)
21:04:57 <Squarism> i use lens - amature style!
21:05:01 <dmwit> mniip: Do you have a reason to believe this puzzle has a solution?
21:05:06 <slack1256> we all do
21:05:35 <dmwit> mniip: You have two functions on arbitrary (existentially-quantified) types `x`/`y` and `z`/`w` and you want to combine them; why should we believe that's possible?
21:10:10 <mniip> dmwit, because Apply surely is a monoidal product in End(Hask)
21:11:14 <yiimi> is call by value considered strict evaluation?
21:11:25 <slack1256> I think so, yes
21:12:12 <slack1256> yiimi: https://en.wikipedia.org/wiki/Evaluation_strategy
21:12:16 <dmwit> mniip: Are you sure the type of the continuation is right?
21:12:36 <mniip> which continuation you mean
21:12:37 <dmwit> mniip: i.e. that it doesn't need more `f`s and `g`s; or perhaps that `Apply` needs some `Functor` constraints?
21:12:53 <mniip> well sure, f and g are functors
21:12:57 <mniip> as indicated in assoc/coassoc
21:13:02 <dmwit> ...err, right.
21:13:11 <mniip> and Functor f, Functor g => Functor (Apply f g)
21:13:14 <dmwit> Yes, okay, that makes things easier. Let's take another stab at this. =P
21:13:37 <mniip> actually, just Functor (Apply f g)
21:16:16 * hackagebot acme-default 0.1.0 - A class for types with a distinguished aesthetically pleasing value  https://hackage.haskell.org/package/acme-default-0.1.0 (esz)
21:16:46 <ertesx> thanks for your suggestions =)
21:19:20 * mniip tries to solve the puzzle with holes
21:19:45 <dmwit> mniip: assoc (Apply (Apply f g k) h k') = Apply f (Apply (flip k <$> g) (flip k' <$> h) (flip (.))) (flip ($))
21:19:55 <dmwit> mniip: Type-checks, at least. No idea whether it makes sense semantically. =)
21:21:23 <Zemyla> Is there a Haskell extension more dangerous than IncoherentInstances?
21:21:34 <mniip> AllowAmbiguousTypes
21:21:35 <dmwit> FFI
21:22:20 <dmwit> More seriously: IncoherentInstances is definitely the one I squint at most.
21:23:03 <dmj`> UndecideableInstances?
21:23:57 <dmwit> Is UndecidableInstances dangerous?
21:24:12 <dmwit> Worst case you never produce any library/executable. No executable -> no bugs
21:24:58 <oracle_> hello. how do you express this java code in haskell : while (x!=-1) { int x = ReadFromStdin(); mylist.add(x) ; }   ???   this is like reading and building a list on the fly.
21:25:38 <Welkin> oracle_: just read the whole file in
21:25:38 <dmwit> readInts = do { x <- readLn; if x == -1 then [] else (x:) <$> readInts }
21:26:05 <oracle_> Welkin, I don't have a file. I just want to read numbers and make a list.
21:33:34 <Hijiri> oracle_: don't you want to test if x = -1 before adding it to the list?
21:34:08 <Hijiri> I guess it doesn't matter as long as you expect it
21:34:49 <oracle_> Hijiri, it's like CP101 lesson, where on each time you read a number you add it to the list and ask the user to add another until the user is satisfied with his input. you know.. you need to communicate with the user of your app.
21:35:25 <oracle_> any object.. doesn't have to be a number even
21:35:47 <dmj`> oracle_: http://lpaste.net/171551
21:36:06 <dmwit> oracle_: Did you see my answer...?
21:36:21 <dmwit> dmj`: What is that monstrosity.
21:36:26 <dmwit> dmj`: That's ridiculous.
21:36:41 <sleblanc`> owch
21:36:56 <dmj`> dmwit: :] 
21:37:09 <dmj`> it can make it prettier
21:37:11 <oracle_> dmwit, yes.. but I could not understand it yet. looks to me very complicated
21:37:27 <Squarism> gah.. ive started using HUnit together with some umbrella foundation called Test.Framework ... sadly documenation of the two together is scarse. Im starting to feel i chosen the wrong combination cause of the lack of answers. What do most people use really?
21:37:38 <dmwit> oracle_: Okay. Please complain about some part of it that looks complicated so we can make that part simple. =)
21:37:55 <Koterpillar> Squarism: HTF?
21:37:59 <dmj`> oracle_: StateT let's you maintain the list while operating in IO, so you can call getLine, fix let's you continue looping until a negative condition is encountered, then your list is returned
21:38:01 <Squarism> HTF? 
21:38:01 <kadoban> Squarism: test-framework is a little outdated (though I still use it :-/). I think people switch to tasty or something.
21:38:03 <Welkin> Squarism: tasty with hspec
21:38:08 <oracle_> i will read it later.. I have to go to work. at work I have time.
21:38:18 <mniip> dmwit, thanks, that's exactly what I've been looking for
21:38:48 <mniip> x and assoc x unwrap to the same term
21:39:05 <Squarism> so tasty has a big community not just latest / greatest / flavor of month?
21:40:02 <glguy> Lol, don't introduce StateT to a question of "How does one do this basic operation in Haskell"
21:40:22 <dmj`> oracle_: http://lpaste.net/171553
21:40:28 <kadoban> Squarism: It's been around for a long time, and people mention it a lot.
21:40:56 <Squarism> what about quickcheck, i hear alot about that too?
21:41:14 <Welkin> tasty is just a way to use multiple testing libraris together
21:41:15 <glguy> oracle_: Kindly ignore that
21:41:19 <Welkin> libraries*
21:41:23 <Koterpillar> that's orthogonal, HTF (haskell-test-framework) can use it
21:41:27 <Koterpillar> Squarism: ^
21:41:35 <Welkin> using tasty, you can use hspec with quickcheck, and whatever else
21:41:41 <dmj`> glguy: is it basic though? :)
21:41:48 <Squarism> ok
21:41:58 <glguy> dmj`: 171553   this?
21:42:13 <Squarism> ill rewrite me suite in hspec tasty then
21:42:31 <Welkin> Squarism: tasty can use hunit too
21:42:43 <Welkin> it just depends what you prefer, hunit or hspec
21:42:58 <Squarism> hunit does not seem to have a big userbase
21:43:01 <Welkin> I think hspec is easier to read
21:43:05 <dmj`> glguy: his requirement, to build up a list from user input
21:43:30 <dmwit> dmj`: Considering how simple the answer to the query *can* be, yes, it is basic.
21:43:37 <glguy> dmj`: Yeah, I think the original question was basic and merits a simple solution on the order of dmwit's
21:44:12 <glguy> maybe without <$>, but otherwise that
21:44:30 <Squarism> ...also hunit api seems very "minimal", to the point you think "is this all you provide?"
21:44:44 <dmwit> I could easily be argued into converting the `<$>` into another `do` block.
21:44:50 <dmj`> glguy: ah, did not see dmwit's answer, it's very nice
21:44:54 <Welkin> I think hunit is modeled on junit (java unit testing library)
21:45:08 <Welkin> and hspec is modeled on rspec (ruby unit testing library)
21:46:24 <wedens> any emacs+intero users? should it complete local functions and functions defined in other imported modules of the project?
21:51:09 <Welkin> Squarism: and it looks like hspec uses hunit internally
22:03:23 * mniip wonders if edwardk is around
22:05:08 <slack1256> you have to chant his name 3 times
22:05:23 <mniip> and stand between two natural isomorphisms
22:06:04 <Axman6> or just say "I don't know what 'a monad is just a monoid in the category of endofunctors' means" and he'll appear
22:06:13 <mniip> how ironic
22:06:18 <mniip> that's exactly what I'm about
22:07:47 <slack1256> I only know the waving-hand (modulo good will) explanation of that 
22:09:44 <slack1256> Basically if you use the join/return definition of Monad. join :: (Monad m) => m (m a) -> m a
22:09:55 <mniip> no need to explain
22:10:14 <slack1256> OK
22:10:42 <slack1256> because I was going to BS my way until you said "I got it" ;-)
22:17:11 <lpaste> mniip revised “A monad is just a monoid in the category of endofunctors”: “An applicative is, too, just a monoid in the category of endofunctors” at http://lpaste.net/171524
22:17:26 <mniip> slack1256, ^
22:18:35 <alercah> eh, no, an applicative is not
22:19:38 <alercah> join is the monoid operation
22:19:46 <alercah> and an applicative lacks join
22:20:06 <mniip> alercah, see the snipped
22:20:08 <mniip> snippet
22:21:16 <alercah> I'm reading
22:24:20 <alercah> mniip: are you using a slightly different definition of monoid, there?
22:24:33 <mniip> different from what
22:25:00 <alercah> the typical definition of monoid in a category
22:25:11 <alercah> I'm having a hard time parsing all the ks and fs out to be sure
22:25:34 <jle`> alercah: there is more than one way you can have a monoid for most things
22:25:55 <jle`> there are bunches of different monoids on Bool, for example
22:26:07 <mniip> and that's only in Hask under (,)
22:26:08 <alercah> jle`: we're definitely not talking about that kind of monoid, though :)
22:26:21 <jle`> all you need is a binary operator and an identity
22:26:26 <jle`> and that it's associative
22:26:32 <mniip> jle`, err we're talking about a different monoid
22:26:37 <dmwit> jle`: Presumably the different ways to have monoids on Haskell endofunctors would amount to different instances of Monad, though, not different typeclasses.
22:26:37 <mniip> categorical monoids
22:26:46 <jle`> ah yeah, stretched too far
22:27:00 <Squarism> ok.. wierd question. Is there a version of liftA2 that let me bind to a new container? 
22:27:13 <alercah> Squarism: what do you mean "bind to a new container"?
22:27:35 <Squarism> i dont use the right words i guess
22:28:01 <jle`> Squarism: can you give a specific type of what you're looking for?
22:28:16 <Squarism> let me bind to same monad with different type arguments
22:28:20 <jle`> a lot of times people ask questions about the most general possible type
22:28:32 <mniip> alercah, you're probably familiar with how haskell functors are not really functors
22:28:32 <jle`> but the question would be easier to answer if just given specific types
22:28:38 <Squarism> ok ill try
22:28:41 <jle`> Squarism: can you give a monomorphis example?
22:28:41 <alercah> mniip: yeah
22:28:49 <jle`> like (a -> b -> c) -> Maybe a -> Maybe b -> [c] ?
22:28:56 <mniip> the same applies to Data.Monoid.Monoid
22:29:09 <alercah> right
22:29:15 <mniip> it's just a particular subset of monoids: in the Hask category under (,) as the tensor product
22:29:35 <dfeuer> Isn't a monoid a (sub)category with a single object?
22:29:42 <alercah> wait let me think about this
22:30:20 <mniip> dfeuer, not neccessarily
22:30:35 <alercah> Maybe I misunderstood what you mean about "not really functors". I thought you were referring to the issues with bottom
22:30:44 <mniip> oh
22:30:53 <mniip> I was referring to how Data.Functor.Functor is only endofunctors on hask
22:31:01 <alercah> oh right, sure
22:31:06 <mniip> dfeuer, I mean, if your category has a single object, and tensor product is monad composition, then that category is monoidal, and that object is a monoid
22:31:22 <mniip> er
22:31:27 <mniip> morphism composition
22:31:28 <mniip> not monad
22:31:34 <Squarism> xxx :: (a -> b -> t c) -> t a -> t b -> t c
22:31:38 <Squarism> is what im after
22:32:16 <alercah> mniip: right, ok, so all Monoids are monoids but not all monoids can be represented as Monoids
22:32:23 <mniip> sure
22:32:25 <alercah> oh I get your comment now
22:32:33 <alercah> you're talking about categorical monoids, right
22:32:37 <mniip> yes
22:32:43 <alercah> yep yep, I follow here
22:33:25 <mniip> monoids in (End(Hask), (.), Identity) are monads in Hask
22:33:41 <mniip> monoids in (End(Hask), Apply, Identity) are applicatives in Hask
22:33:56 <mniip> monoids in (End(Hask), (,), Proxy) are alternatives in Hask
22:34:04 * alercah pulls out awodey
22:35:16 <alercah> mniip: ah, ok, thanks
22:35:24 <alercah> this all makes sense now
22:35:40 <mniip> in particular I wanted to poke edwardk about representing categories the way I did
22:35:48 <mniip> with an associated Constraint family
22:35:56 <alercah> I suppose I'd argue that "the category of endofunctors" is understood to use (,) as the product but I suppose there is no reason this must be so
22:36:04 <mniip> seemed worth looking at to me
22:36:13 <alercah> it's interesting
22:36:15 <mniip> alercah, "product"?
22:36:17 <alercah> but excessively verbose to me
22:36:22 <alercah> mniip: the tensor product
22:36:46 <mniip> "excessively verbose"? I was only referring to lines 7-10
22:37:00 <alercah> oh ok
22:37:13 <mniip> alercah, there are multiple choices for tensor product
22:37:16 <alercah> mniip: right
22:37:23 <mniip> and I don't think they're related to product objects at all
22:37:46 <alercah> no, I guess they aren't
22:38:18 <alercah> but I think it is usually implied, if not otherwise specified, that the categorial product is also the monoidal product
22:38:43 <Squarism> no know implemenation of xxx :: (a -> b -> t c) -> t a -> t b -> t c ?
22:38:47 <mniip> hmm, are there categories with all product objects but no terminal objects?
22:39:17 <alercah> mniip: no, by definition
22:39:25 <alercah> since a terminal object is the empty product
22:39:42 <mniip> "empty product"?
22:39:51 <mniip> well I meant all binary products
22:40:15 <alercah> oh, sure. Set \ {}
22:40:23 <alercah> err
22:40:33 <alercah> {} is initial
22:40:35 <alercah> but you know what I mean
22:40:48 <alercah> The category of all sets of cardinality at least 2
22:41:05 <dmwit> Squarism: (join .) . liftM2
22:41:10 <mniip> hmm  then
22:41:12 <dmwit> :t (join .) . liftM2
22:41:13 <lambdabot>     Occurs check: cannot construct the infinite type: m ~ (->) (m a2)
22:41:13 <lambdabot>     Expected type: (a1 -> a2 -> a) -> m a1 -> m a2 -> m a2 -> a
22:41:13 <lambdabot>       Actual type: (a1 -> a2 -> a) -> m a1 -> m a2 -> m a
22:41:25 <dmwit> :t ((join .) .) . liftM2
22:41:26 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
22:41:32 <dmwit> just needed more dot
22:41:39 <Squarism> thanks!
22:42:12 <mniip> product-producing bifunctor and the terminal object always produce a monoidal category
22:42:15 <mniip> is what I'd conjecture
22:42:25 <mniip> coproduct+coterminal too
22:45:41 <mniip> CT is fascinating
22:45:53 <alercah> yes
22:46:08 <mniip> btw the interesting point about Category representation
22:46:16 <mniip> is that I was actually able to build all this structure on top
22:46:33 <mniip> you run into all kinds of issues otherwise
22:46:43 <alercah> mniip: yeah
22:46:53 <alercah> though it really feels like a crib for real dependent types to me
22:53:11 <alercah> mniip: wikipedia indicates it works for categories with all finite products; I can't think of any reason it wouldn't work for all 0- and 2-products
22:53:22 <alercah> since a 3-product, etc. never comes into it
22:55:06 * mniip draws a diagram
22:55:25 <mniip> alercah, obviously it is
22:55:58 <mniip> oh hmm
22:56:06 * mniip draws more diagrams
22:56:20 * alercah steals them and runs away
22:56:24 <alercah> you'll have to chase them!
22:56:55 <alercah> oh wait, d'oh, of course, binary products implies finite products
22:56:56 <alercah> forgot that
22:57:08 <alercah> (or more accurately, binary products + terminal object)
23:01:36 <pavonia> Wasn't there a flip (.) somewhere?
23:01:42 <mniip> I think I proved that (AB)C = A(BC)
23:01:46 <mniip> up to unique isomorphism
23:02:39 <kadoban> pavonia: (>>>) from Control.Category, but it doesn't have the best precedence
23:03:07 <pavonia> Ah that, thanks!
23:06:24 <Squarism> Is there some neat way i could bombine functions to realize : (a -> b) -> (a -> c) -> a -> (a -> b -> d) -> d
23:06:46 <Squarism> order not so important
23:07:26 <pavonia> There's a 'c' missing, no?
23:07:33 <jle`> Squarism: can you give us the implemenation
23:07:35 <Squarism> oh
23:07:38 <Squarism> yes
23:07:55 <Squarism> (a -> b) -> (a -> c) -> a -> (b -> c -> d) -> d
23:08:29 <jle`> :t liftA2
23:08:29 <dibblego> @type (&&&)
23:08:31 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
23:08:31 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
23:08:46 <dibblego> @type liftA2 (,)
23:08:48 <lambdabot> Applicative f => f a -> f b -> f (a, b)
23:09:02 <jle`> :t \f g h -> liftA2 f g h
23:09:03 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
23:09:07 <jle`> hm
23:09:12 <jle`> :t \f g h x -> liftA2 f g h x
23:09:14 <lambdabot> (a -> b -> c) -> (t -> a) -> (t -> b) -> t -> c
23:09:29 <Squarism> neat!
23:09:34 <jle`> :t \f g x h -> liftA2 h f g x
23:09:35 <lambdabot> (t -> a) -> (t -> b) -> t -> (a -> b -> c) -> c
23:10:06 <Squarism> haskell dont stop to impress
23:10:13 <jle`> Squarism: liftA2 f g h = \x -> f (g x) (h x)
23:10:30 <jle`> it applies g and h, and applies f to the result to combine it
23:10:38 <mniip> alercah, http://i.imgur.com/krjwhZN.png
23:11:17 <alercah> mniip: yeah
23:13:05 <Squarism> jle`, im impressed you could spit that out so quickly! I hope ill end up there some day
23:14:13 <dmwit> :exf (a -> b) -> (a -> c) -> a -> (a -> b -> d) -> d
23:14:14 <jle`> you start to see the same patterns over and over again after a while :)
23:14:44 <exferenceBot> could not find expression
23:14:44 <dmwit> ?djinn (a -> b) -> (a -> c) -> a -> (a -> b -> d) -> d
23:14:45 <lambdabot> f a _ b c = c b (a b)
23:14:50 <dmwit> :exf "(a -> b) -> (a -> c) -> a -> (a -> b -> d) -> d"
23:15:17 <exferenceBot> could not find expression
23:15:23 <dmwit> too bad
23:15:33 <Squarism> dmwit, what are these "services" you use? 
23:15:51 <dmwit> djinn and exference are theorem provers of varying sophistication.
23:15:56 <dmwit> Give them a type and they will give you code.
23:16:01 <dmwit> Not all types are supported, of course.
23:16:17 <dmwit> ?where djinn
23:16:17 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
23:16:21 <dmwit> ?hackage exference
23:16:21 <lambdabot> http://hackage.haskell.org/package/exference
23:16:35 <dmwit> Perhaps exference is not yet on Hackage.
23:19:23 <mniip> exference is pretty much term bruteforce isn't it
23:19:55 <Squarism> so it tries to simplify things into shorter form? 
23:20:06 <jle`> mniip: is it possible with just Functor?
23:20:09 <jle`> the puzzle
23:20:28 <mniip> yeah it's been solved already
23:21:01 <alercah> mniip: have you looked at dependently typed languages at lal?
23:21:02 <alercah> *all
23:21:29 <geekosaur> github.com/lspitzner/exference fwiw
23:21:35 <mniip> I've played with dependent kinding in GHC 8.0
23:21:50 <alercah> use a real language :P
23:22:02 <alercah> the hoops you have to go through with GHC, like Proxy, hurt
23:24:04 <mniip> pfft
23:24:10 <mniip> that's nothing
23:25:54 <mniip> jle`, see http://lpaste.net/171524
23:26:23 <jle`> ty
23:32:36 <Squarism> just need to try this
23:32:38 <mniip> hmm, I guess I should get rid of the bifunctor class
23:32:39 <Squarism> :exf  (a -> b) -> (a -> c) -> a -> (b -> c -> d) -> d
23:32:39 <exferenceBot> \ f1 f2 c f4 -> f4 (f1 c) (f2 c)
23:32:55 <mniip> and use that's just K * L ---> M
23:33:00 <mniip> a functor
23:33:17 * mniip tries to be coherent
23:44:13 <mniip> argh, how do record gadts work again
23:45:53 <pavonia> Foo :: { ... } -> Bar?
23:51:21 * hackagebot hlint 1.9.36 - Source code suggestions  https://hackage.haskell.org/package/hlint-1.9.36 (NeilMitchell)
23:52:21 <joe9> When I load the Main.hs file with ghci, I get an error. But, when I run "cabal build", it works fine. code:  https://gist.github.com/39e277ea48d54d6720a73b74032fcddf , error:  http://codepad.org/wwG98k4R .
23:52:56 <joe9> I know that it does not have much to do with this particular source as I have another similar project (servant) which is showing the same behaviour.
23:53:08 <joe9> It probably has something to do with ghc setup
23:53:18 <joe9> any suggestions on what I might be missing, please?
23:55:08 <liste> joe9: does "cabal repl" work?
23:55:29 <mniip>       Expected type: Cartesian k l a a
23:55:29 <mniip>         Actual type: Cartesian k l '(a0, c0) '(a0, c0)
23:55:30 <mniip> wat
23:56:36 <joe9> liste, cool. cabal repl works.
23:58:07 <joe9> liste, what is the difference between "cabal repl" and ghci?
23:59:03 <joe9> this is my .cabal file: https://gist.github.com/1c7986844e3db24f8ec78cc711577e83 . Could it be the default-language: Haskell2010 that could be causing the issue?
23:59:15 <liste> cabal repl starts ghci that's configured for the project/sandbox
23:59:56 <mniip> hmm
