00:02:16 <seivan_> Can you remake ParsecIndent with regular Parsec?
00:02:21 <seivan_> It seem to use Source/State 
00:28:10 * hackagebot warp 3.2.7 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.2.7 (KazuYamamoto)
00:28:12 * hackagebot wai-http2-extra 0.0.0 - WAI utilities for HTTP/2  https://hackage.haskell.org/package/wai-http2-extra-0.0.0 (KazuYamamoto)
00:28:14 * hackagebot wai-logger 2.3.0 - A logging system for WAI  https://hackage.haskell.org/package/wai-logger-2.3.0 (KazuYamamoto)
00:43:10 * hackagebot mighttpd2 3.3.2 - High performance web server on WAI/warp  https://hackage.haskell.org/package/mighttpd2-3.3.2 (KazuYamamoto)
00:48:10 * hackagebot safe-exceptions 0.1.1.0 - Safe, consistent, and easy exception handling  https://hackage.haskell.org/package/safe-exceptions-0.1.1.0 (MichaelSnoyman)
01:24:25 <koz_> Did I ever say how much I love QuickCheck?
01:45:14 <koz_> I'm not quite sure how to do this - I wanna write a regression test for a particular function I'm refactoring for optimality (after profiling). I wanna have a test against its 'old version'. However, that function relies on internals the module does not export. Should I export an 'old' and 'new' function like this forever more to allow the tests to run?
01:56:22 <fr33domlover> koz_, you could include the private module in the test program
01:56:47 <fr33domlover> i.e. it's imported in your Test.hs etc. but not exported in the library
01:56:54 <koz_> fr33domlover: How would I do that? In order for me to write this function, I would have to write it in the same module as the thing I'm trying to refactor.
01:58:58 <fr33domlover> koz_, you can have a separate internals module which exports the functions you need. Just put it in the other-modules list instead of the public ones (in the .cabal file)
01:59:13 <koz_> Ah, so create a module that does nothing but export things?
01:59:32 <fr33domlover> I'm not 100% sure exactly what the situation is, but remember not all your library modules have to be exported
01:59:44 <koz_> fr33domlover: Yeah, that's a good idea. I will do exactly that.
02:00:29 <fr33domlover> (you still need to list all modules, but the .cabal file lets you list the non-exported ones in a separate list)
02:28:13 * hackagebot transient 0.4.0 - Making composable programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.4.0 (AlbertoCorona)
02:33:13 * hackagebot transient-universe 0.3 - remote execution and map-reduce: distributed computing for transient  https://hackage.haskell.org/package/transient-universe-0.3 (AlbertoCorona)
02:38:13 * hackagebot ghcjs-hplay 0.3 - monadic, reactive Formlets running in the Web browser  https://hackage.haskell.org/package/ghcjs-hplay-0.3 (AlbertoCorona)
02:40:50 <daniel-s> Hi
02:41:05 <daniel-s> Does Haskell use indentation to delineate blocks like in Python?
02:41:19 <daniel-s> Also, Emacs is indenting "where" like this: https://paste.debian.net/776382/
02:41:36 <daniel-s> Rather than aligning it with "in".
02:41:42 <daniel-s> Is that a big deal?
02:42:08 <koz_> Can criterion (or any other benching tool) check for space usage (i.e. allocation) as well as time usage?
02:43:10 <tdammers> daniel-s: Haskell does use whitespace for blocks under some circumstances, but not as pervasively as Python
02:43:14 * hackagebot ghcjs-hplay 0.3.1 - client-side Web EDSL for transient nodes running in the Web browser  https://hackage.haskell.org/package/ghcjs-hplay-0.3.1 (AlbertoCorona)
02:43:27 <oherrala> koz_: check out weight https://hackage.haskell.org/package/weigh
02:43:44 <tdammers> daniel-s: https://www.haskell.org/onlinereport/lexemes.html#sect2.7
02:43:54 <tdammers> a bit technical, but covers things pretty well
02:44:02 <koz_> oherrala: Thank you - that's exactly what I was hunting for!
02:44:49 <oherrala> koz_: np
02:48:14 * hackagebot inline-c 0.5.5.4 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.5.5.4 (FrancescoMazzoli)
03:00:46 <merijn> Anyone know if there's a C++ parsing library like language-c?
03:01:07 <ChthonicCrusader> quick question: what is the easiest way to serialize a Data.Matrix.Matrix to store it in a database. I am looking for a function (Matrix -> ByteString) Data.Matrix.Matrix doesnt have any instance of ToJSON
03:07:49 <koz_> oherrala: I'm getting very weird errors from Weigh. Specifically: http://lpaste.net/169015
03:08:55 <ChthonicCrusader> anyone?
03:09:31 <koz_> ChthonicCrusader: Does it have an instance of Generic?
03:09:39 <koz_> If so, Aeson might be able to help you.
03:12:56 <ChthonicCrusader> koz_: No, it doesnt have an instance of generic, the instances are http://lpaste.net/169016
03:13:00 <cloudhead> Can someone explain what the differences between Control.Monad.Catch (exceptions package) and Control.Monad.Except (mtl)  are? In general, which one is recommended?
03:13:16 <ChthonicCrusader> koz_: Can we use any other serialization library?
03:16:10 <tdammers> ChthonicCrusader: you could write your own Matrix -> JSON instance
03:16:38 <koz_> ChthonicCrusader: What tdammers said, assuming you have some way to get at the squishy internals.
03:16:39 <tdammers> ChthonicCrusader: or, using Cereal or Binary, write your own binary serializer
03:17:04 <koz_> Weirdly, it has a Show instance, but not a Read one.
03:17:20 <tdammers> the advantage of using JSON would be that some database backends have native support for JSON data (e.g. PostgreSQL), such that you can index and query into your data
03:18:02 <tdammers> koz_: maybe that's because Read is a bit of a wart? idk, I don't usually bother with Read instances myself unless they can be derived or trivially composed
03:19:35 <koz_> tdammers: Fair enough.
03:19:53 <koz_> I basically auto-derive Show and Read on all my datatypes for debugging reasons if nothing else.
03:20:18 <tdammers> yeah, I do that for Show, but Read isn't very helpful for debugging usually
03:20:46 <koz_> tdammers: I found it really great. YMMV.
03:21:15 <oherrala> koz_: sorry, I'm not familiar with weigh. I only know the name and purpose :)
03:21:30 <koz_> oherrala: OK, thanks anyway!
03:21:47 <koz_> I'll see if anyone around here knows.
03:21:57 <ChthonicCrusader> tdammers: Thanks, lemme go through Cereal/Binary
03:22:03 <oherrala> koz_: did you see this: https://www.fpcomplete.com/blog/2016/05/weigh-package
03:22:52 <koz_> oherrala: No, I did not. I just followed the sample code.
03:24:06 <koz_> This is what I have: http://lpaste.net/169018
03:26:28 <simg> Hi, I'm currently doing some asynchronous programming with Haskell. What I'm looking for is something as simple as node's async.mapLimit for running a large number of actions but automatically managing the concurrency for me. There is Control.Async mapConcurrently - but that appears to try and running everything at the same time, and there is parallel-io but that doesn't compile (using stack) and hasn't been updated in 4 years. Any suggestions or pointers? TIA
03:26:59 <koz_> simg: For those of us who dunno JS - what does async.mapLimit do?
03:27:41 <earthy> simg: ttp://stackoverflow.com/questions/18896103/can-haskells-control-concurrent-async-mapconcurrently-have-a-limit
03:28:22 <zomg> koz_: that's like `map` except it only runs maximum of N simultaneous operations
03:28:42 <koz_> zomg: Ah. 
03:29:44 <quchen> simg: You could use a semaphore to add a limit.
03:29:52 <simg> earthy: thanks, will investigate that.
03:30:06 <quchen> Async won’t do this on its own.
03:31:52 <earthy> simg: other than that there's also async-pool 
03:32:44 <fr33domlover> Is there a way to check for cycles in an FGL graph, other than implementing a variant of DFS?
03:32:46 <simg> quchen: I'm looking for something easy / well proven / definitive answer - I'd rather avoid writing it myself
03:33:11 <fr33domlover> Should be simple, but just asking in case a function exists (I can't find any!)
03:34:22 <simg> earthy: thanks, will also look into that
03:34:54 <koz_> fr33domlover: FGL?
03:35:16 <schmittr> hey guys I'm very new to haskell and trying to interact with an postgres db by using hasql. Anybody here who has some experience with this package?
03:35:26 <fr33domlover> koz_, functional graph library
03:35:31 <fr33domlover> @hackage fgl
03:35:31 <lambdabot> http://hackage.haskell.org/package/fgl
03:56:50 <srhb> schmittr: You're more likely to get answers if you just pose your question :)
03:58:11 <quchen> simg: http://lpaste.net/169020
03:58:23 <quchen> simg: Something like that is what I meant.
03:58:46 <quchen> Allocate a semaphore, then map concurrently limited by the semaphore.
03:59:20 <quchen> This will fork (length xs) threads, n of which will be run concurrently while the rest waits.
03:59:47 <schmittr> ok, thnks. I'm trying to perform a multirow query. I already succeeded to do a singlerow qry. Has somebody an example rdy how to do so?  
04:00:06 <schmittr> by using hasql of course ;)
04:01:17 <simg> quchen: that looks very elegant and instructive, thanks. will give it some thought
04:02:32 <quchen> simg: Are you familiar with semaphores? With bracket?
04:03:06 <simg> quchen: semaphores in general yes, with haskell not so much. don't know what bracket is.
04:03:17 <srhb> schmittr: What have you tried so far? You can paste on lpaste.net if you have something long.
04:03:26 <quchen> Bracket is roughly Haskell's try-catch
04:04:20 <quchen> “bracket before after thing” runs ‘before’, then ‘thing’, then ‘after’.
04:04:52 <quchen> Something you often see is  bracket (openFile "foo") hClose (\handle -> … do stuff with handle …)
04:05:50 <quchen> In my example above, bracket ensures the semaphore is waited for before doing the "f" mapping, and signalled (released) afterwards.
04:05:56 <quchen> Even in the presence of exceptions, that is.
04:06:19 <quchen> When you don’t care about exceptions, you can leave the bracket away to get a smaller example code.
04:07:15 <quchen> Well, not really smaller, but maybe more understandable.
04:07:29 <simg> quchen: thanks, definitely going to give your solution a go for the shear simple elegance of it :)
04:08:21 <quchen> The non-bracket (exception-unsafe) version would be   do { waitQSem sem; result <- f x; signalQSem sem },  simg 
04:08:33 <quchen> Woops, add "pure result" at the end
04:09:36 <maerwald> sometimes I wonder why we don't have try-catch if there is already if-then-else
04:10:09 <quchen> Sometimes I wonder why we have if-then-else.
04:10:30 <maerwald> because it's convenient in anon functions
04:10:35 <maerwald> or do blocks
04:10:43 <simg> quchen: why isn't it : (\x -> bracket_ (waitQSem sem) (f x) (signalQSem sem) ) so that the semaphore gets released after the function is executed?
04:11:23 <quchen> simg: Bracket's argument order is "before after thing", not "before thing after".
04:11:40 <quchen> The reason for this is that most brackets look like "bracket foo bar (\x -> )".
04:11:55 <quchen> And the "thing" is usually the biggest, most interesting part of a bracket.
04:12:14 <simg> quchen: yeah, sorry / thanks, missed that. 
04:16:11 <koz_> Huh, optimizations. I managed to make a hot zone *hotter* (i.e. bigger percentage of my allocs and work), but my code is about twice as fast now.
04:16:30 <maerwald> "twice as fast"!
04:16:59 <koz_> maerwald: More than twice, actually - from 3m30s to 1m30s.
04:17:07 <koz_> (or so)
04:17:31 <maerwald> there are still little useful resource on optimizing haskell code
04:17:57 <koz_> maerwald: Well, this was a combination of 'attack hot zones' and 'parallelize like a madman'.
04:20:33 <koz_> After this, *one function* uses up two-thirds of my program's run time.
04:20:40 <koz_> Maybe some micro-optimizations *are* in order...
04:22:06 <maerwald> last time I was tweaking performance I was randomly interchanging arrays, maps and lists and got rather weird and unexpected results
04:22:16 <maerwald> almost impossible to guess what was faster
04:23:58 <maerwald> and splitting/merging some functions also had a huge impact I couldn't really tell why
04:24:44 <koz_> maerwald: Performance is weird.
04:24:50 <maerwald> depends on the language
04:24:55 <maerwald> it's particularly weird in haskell
04:24:57 <koz_> In Haskell, definitely.
04:28:28 <bernalex> quchen: because we don't have mixfix :'(
04:29:01 <bernalex> (RE <quchen> Sometimes I wonder why we have if-then-else. )
04:29:23 <quchen> bernalex: I don’t miss mixfix.
04:29:35 <bernalex> I dearly miss it.
04:29:46 <maerwald> koz_: btw. I don't even think that laziness is the culprit here. It's probably rather the fact of cross-module inlining and pure evaluation that allows to optimize stuff in new ways.
04:30:10 <maerwald> and then ofc it gets harder to know what happens
04:30:12 <quchen> We have case-of instead of if-then-else, apart from that.
04:30:29 <schmittr> thx @ srhb for offering help, but finally got it by my own :)
04:30:38 <quchen> I never wanted mixfix for Maybe either.
04:30:57 <quchen> (Other than ‘case’
04:30:59 <quchen> )
04:31:21 <koz_> maerwald: Laziness can really catch you out performance-wise too.
04:31:37 <koz_> (although yes, it's not common)
04:32:19 <genso-pyon> I have an abstract type “Key” (implemented by someone else, not me), and a function “reorder :: (a -> Key) -> (a, a) -> (a, a)”, satisfying the following laws: (0) Either “reorder f (x, y) = (x, y)” or “reorder f (x, y) = (y, x)”. (1) “reorder f (x, y) = reorder f (y, x)”. (2) If “reorder f (x, y) = (x, y)” and “reorder f (y, z) = (y, z)”, then “reorder f (x, z) = (x, z)”. (Another way to put it is that “fst . reorder 
04:32:20 <genso-pyon> associative.) ... Can it be proven that the implementor of “Key” had enough information to provide an “Ord” instance?
04:32:28 <maerwald> koz_: the Idris guys said that they choose strictness by default also because of reasoning about performance... I think that's not the main point
04:32:29 <bernalex> quchen: why would you want mixfix for Maybe?
04:32:43 <quchen> bernalex: Why would I want mixfix for Bool?
04:32:47 <bernalex> I'm not sure what that means. I mean mixfix operators.
04:33:14 <bernalex> _if_ x _then_ y _else_ z | x == true = y | otherwise = z
04:34:04 <quchen> if-then-else is a special case of “case” with less flexibility (can’t swap cases), I don’t see its point.
04:34:18 <maerwald> quchen: less verbose and ugly in anon functions
04:34:35 <genso-pyon> Function literals are kinda ugly themselves.
04:34:38 <quchen> Looks just the same in anonymous functions.
04:34:47 <maerwald> yes, ugly
04:35:04 <bernalex> maerwald: oh, right, yes I agree that if-than-else itself isn't strictly necessary. I still like mixfix though.
04:35:09 <bernalex> sorry quchen not maerwald 
04:35:22 <genso-pyon> If you find yourself using anonymous functions, chances are you should refactor your existing non-anonymous functions to take their arguments in a saner order.
04:35:33 <bernalex> I've several times wanted mixfix for games stuff. describing levels and maps and whatnot.
04:35:34 <maerwald> the alternative is your own if' function, but that forces you to use ugly brackets
04:36:13 <bernalex> I have sometimes used if' True = const; if' False = const id; fi = flip . flip if'
04:36:19 <maerwald> so if-then-else is a rather clean syntax
04:36:23 <bernalex> they are *a lot* nicer than the builtin syntax
04:36:28 <maerwald> not that it's particularly powerful
04:36:29 <bernalex> the builtin syntax isn't first class, so it's horrible.
04:37:00 * bernalex >>= shower
04:52:02 <quchen> I like not having custom mixfix notation.
04:52:40 <quchen> I don’t think Lisp-style meta-capabilities are ver desirable, they make code too personalized.
04:53:25 <quchen> For one-man projects it’s fine, but as soon as I have to read someone else’s code I like normal identifiers.
04:53:41 <quchen> Being able to write <<<>~ is bad enough ;-)
04:54:07 <tdammers> lisp-style meta wouldn't be too bad if it were more explicit, and type-safe
04:54:08 <locallycompact> <<<~>@_@<~>>>
04:54:33 <tdammers> as it stands, I think not being able to tell from the syntax alone whether something is a macro or a function is quite bad
04:54:42 <quchen> locallycompact: Invalid, underscore is letter-like ;-P
04:54:51 <tdammers> more so when the language doesn't control effects enough
04:55:55 <quchen> > let (ლಠ益ಠლ) = "angry" in (ლಠ益ಠლ)
04:55:56 <lambdabot>  "angry"
04:57:42 <MrDetonia> I'm trying my hand at concurrent programming with haskell for the first time, and I have a situation where I have n threads, and any one of them could call for the program to terminate.
04:58:11 <MrDetonia> Is there a way to send that signal back to the main thread, and best case have all the other threads perform some action to cleanly terminate
04:58:13 <MrDetonia> ?
04:58:45 <srhb> MrDetonia: Using MVars to synchronize thread behaviour is pretty common
04:59:16 <srhb> MrDetonia: There's even an example for waiting for all threads to finish in its documentation page, I believe. That should be adaptable.
04:59:38 <MrDetonia> something like that could work yes. I want to force threads to close however, not interested in waiting for any
04:59:55 <LordBrain> genso-pyon, even if they could write an Ord instance, what would you do? switch to requiring that? maybe there are multiple choices of Ord..
05:00:02 <mikail`> Hi, I've added a new function called 'delta' to my type class as shown here: http://lpaste.net/169024. The problem I'm having is that there is alot of duplication now in the code. The delta function and the price function both need the value `d1` but it does not look as if Haskell will allow me to put a general `where` clause that satisfies both functions. Is there a way to do this?
05:00:10 <srhb> MrDetonia: Same principle. The threads each check for a shutdown command in some MVar when they loop.
05:00:21 <LordBrain> so i wouldn't refactor to require an Ord instance
05:00:31 <MrDetonia> ahh okay
05:00:55 <MrDetonia> so I coud do something like unless (not <killvar>) <quit actions>
05:01:09 <srhb> MrDetonia: Or simply if the MVar is not empty, start the shutdown stuff
05:01:22 <MrDetonia> yeah that could work, thanks
05:01:39 <roconnor> are class names and type names part of the same namespace and are not allowed to collide?
05:01:58 <tdammers> yes
05:02:09 <Cale> MrDetonia: Though, what does shutting down cleanly entail here?
05:02:18 <roconnor> hmm, okay
05:02:30 <Cale> MrDetonia: You *will* have to wait for the threads, if you want them to actually have time to clean up.
05:02:58 <Cale> When the main thread finishes, the whole program ends.
05:03:17 * hackagebot wai-extra 3.0.15.3 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.15.3 (MichaelSnoyman)
05:03:45 <MrDetonia> Cale: yes, I should have made that clearer. I want to force the threads to terminate, but not immediately
05:04:12 <MrDetonia> so one thread can receive some quit signal, and make all the other threads quit also, and finally the main thread should terminate
05:12:39 <seivan_> What does pure in parsec do?
05:15:21 <LordBrain> pure is applicative version of return
05:15:50 <LordBrain> pure x = return x, same thing, but pure does not necessarily imply monad
05:22:29 <merijn> seivan_: Construct a parser that consumes no input and returns whatever you gave as argument to pure
06:05:26 <seivan_> merijn: Ah, so it's just a result
06:05:55 <merijn> seivan_: Basically
06:06:02 <seivan_> is there a description that maps operators to methods? I take it >>= is bind, what is <*>
06:06:15 <seivan_> Documentation is unclear on that
06:06:25 <merijn> seivan_: "maps operators to methods" <- wrong question
06:06:31 <merijn> seivan_: operator are "just" functions
06:06:43 <merijn> "bind" does not exist, it's just what we call >>= in speech
06:07:00 <merijn> seivan_: You can define whatever* operators you like
06:07:06 <merijn> * - well, they have to be operator names
06:07:45 <merijn> seivan_: It's not like C++ or python where there's a fixed built-in set of operators that map to methods or whatever
06:07:48 <seivan_> merijn: Yeah but that's the thing, what would you name >>= if you had to give it a name?
06:08:10 <seivan_> merijn: Also what would you name <$>? (I'd calle it reduce, but that's wrong)
06:08:19 <merijn> seivan_: <$> is literally fmap :)
06:08:28 <merijn> seivan_: As in "f <$> x = fmap f x"
06:09:13 <seivan_> flatmap?
06:09:51 <merijn> I don't know what flatmap means'
06:10:02 <merijn> The 'f' stands for functor
06:12:19 <dysfun> flatMap is the haskell name for >>=
06:12:26 <dysfun> er scala rather
06:12:39 <seivan_> And Swift then
06:13:10 <bernalex> merijn: flatmap is another way to say concatmap
06:13:57 <bernalex> seivan_: we usually say "bind" for >>=, and "map" for <$>.
06:14:22 <seivan_> bernalex: Thanks :)
06:14:23 <bernalex> fsvo "we" that includes me and some others that I've met and talked with about haskell.
06:14:26 <schmittr> I'm using some function here which returns some Either typed result. Is it easily possible to get the right part? in my case it's a tuple which is in Right
06:14:30 <seivan_> bernalex: That's perfect, that's what I am doing now. Porting.
06:14:54 <seivan_> merijn: Thanks as well. It helped
06:15:05 <bernalex> :t map
06:15:06 <lambdabot> (a -> b) -> [a] -> [b]
06:15:10 <seivan_> What operator would you use for joint? is + okay?
06:15:20 <seivan_> If I wanted to joint two parsers
06:15:25 <bernalex> someone should really do 'map = fmap' asap...
06:15:33 <pavonia> :t either  -- schmittr
06:15:34 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
06:15:36 <bernalex> seivan_: I don't know what joint is. what is its type?
06:15:42 <seivan_> Return the aggregate of two results
06:15:50 <bernalex> seivan_: I don't know what that means. what is its type?
06:15:55 <pavonia> schmittr: Or use a case
06:16:00 <seivan_> I take it it would be an accumulerator? 
06:16:03 <merijn> seivan_: You could, but it'd hide the normal use of +
06:16:09 <merijn> seivan_: i.e. addition
06:16:14 <bernalex> I would not shadow any prelude operators.
06:16:24 <bernalex> but I still don't know what they mean or what the type of the thing is.
06:16:26 <merijn> > let x + y = x * y in 2 + 3 -- confusing
06:16:28 <schmittr> pavonia case?
06:16:28 <lambdabot>  6
06:17:08 <seivan_> or <*>
06:17:20 <bernalex> <*> is also a prelude function.
06:17:22 <pavonia> > case Right 123 of { Left _ -> "fail"; Right x -> show x }
06:17:24 <lambdabot>  "123"
06:17:36 <schmittr> ah ok, thx
06:17:52 <schmittr> I'm very new to haskell :)
06:19:03 <liste> seivan_: you could make your parser type an instance of Monoid, so you can use <>
06:19:10 <liste> (or semigroup)
06:19:18 <seivan_> bernalex: Yeah but what would you translate it to in Scala?
06:19:29 <bernalex> seivan_: I don't know. I don't use scala.
06:19:40 <bernalex> I would not use scala. so that solves the problem for me.
06:22:30 <bernalex> the scalaz people probably know. maybe ask them. there's also probably #scala. I think scala programmers know scala better than haskell programmers. usually, at least. edwardk probably knows it better than scala programmers.
06:25:39 <dibblego> scalaz has <*>
06:53:20 * hackagebot http-client 0.5.0 - An HTTP client engine  https://hackage.haskell.org/package/http-client-0.5.0 (MichaelSnoyman)
06:53:22 * hackagebot http-client-openssl 0.2.0.3 - http-client backend using the OpenSSL library.  https://hackage.haskell.org/package/http-client-openssl-0.2.0.3 (MichaelSnoyman)
06:53:24 * hackagebot http-client-tls 0.3.0 - http-client backend using the connection package and tls library  https://hackage.haskell.org/package/http-client-tls-0.3.0 (MichaelSnoyman)
06:53:26 * hackagebot http-conduit 2.2.0 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.2.0 (MichaelSnoyman)
07:07:08 <iphy> what does cabal do when it says "preprocessing library"? it can take quite a while
07:07:24 <iphy> up to several minutes
07:07:46 <bergmark> iphy: i'm guessing it's compiling and running Setup.hs
07:08:18 <iphy> https://github.com/neurocyte/foreign-jni/blob/master/Setup.hs <- main = defaultMain
07:08:23 <iphy> what does defaultMain do that takes so long?
07:09:04 <iphy> I only see that on this particular library, all others are quite fast
07:14:06 <bergmark> iphy: does -v say anything useful?
07:15:11 <iphy> hsc2hs, ok
07:15:43 <iphy> it's a pretty large hsc file, 1800 lines
07:25:07 <Sindome> O
07:31:14 <bollu> hey guys, quick question
07:31:35 <bollu> I think the terminal object in the category Hask is (), since I have terminalarr:: a -> (), terminarr a = ()
07:31:40 <bollu> however, what is the initial object?
07:31:44 <bollu> I suspect it is Void
07:31:57 <bollu> but I'm not able to come up with a morphism initialarr:: Void -> a
07:32:09 <bollu> only thing that I can think of is initialarr _ = undefined
07:32:14 <bollu> but that's sort of stupid, right?
07:32:22 <bollu> is there a "legit" initial object in Haske/
07:32:24 <bollu> Hask*
07:32:48 <glguy> :t Data.Void.absurd
07:32:49 <lambdabot> Data.Void.Void -> a
07:33:17 <bollu> wat? how is it implemented?
07:33:29 <marchelzo> i thought Void was like (forall a. a)
07:33:33 <lyxia> I don't think you can write it properly in haskell
07:33:45 <bollu> so it's not actually encoded in Haskell?
07:33:52 <hpc> it's effectively absurd _ = undefined
07:33:53 <bollu> like, you can't even construct a Void right?
07:33:57 <bollu> right
07:33:58 <bollu> hmm
07:34:06 <bollu> I was hoping for a more "substantial" a
07:34:09 <bollu> answer*
07:34:15 <bollu> what if I have a language with no bottom?
07:34:20 <glguy> bollu: You should just look at the source code of the package
07:34:24 <Iceland_jack> bollu: https://hackage.haskell.org/package/void-0.7.1/docs/src/Data-Void.html
07:34:27 <bollu> then what will be the initial object in that category?
07:34:38 <bollu> in the category of that language with no bottom*
07:34:38 <Iceland_jack>     newtype Void = Void Void
07:34:39 <glguy> bollu: You can't construct a void, so you don't have to worry about getting one
07:34:49 <TheUnafflited> clear
07:34:57 <lyxia> If we're talking about bottoms I don't think () is terminal either
07:35:10 <bollu> lyxia: why not?
07:35:21 <bollu> lyxia: didn't I show the morphism from every type to ()?
07:35:33 <bollu> oh, are you saying that there is no morphism from _|_ -> () ?
07:35:34 <Iceland_jack> bollu: Because the arrow 'const ()' is not unique
07:35:51 <bollu> :t seq
07:35:52 <lambdabot> a -> b -> b
07:36:01 <bollu> Iceland_jack: not unique in the sense of?
07:36:07 <lyxia> const undefined
07:36:10 <lyxia> undefined
07:36:22 <hpc> bollu: unique in the sense of being the only inhabitant of its type
07:36:28 <hpc> maybe?
07:36:37 <Iceland_jack> to expand
07:36:37 <Iceland_jack>     const ()        :: Int -> ()
07:36:37 <Iceland_jack>     const undefined :: Int -> ()
07:36:37 <Iceland_jack>     undefined       :: Int -> ()
07:37:16 <Iceland_jack> it's not a big deal
07:37:23 <hpc> ah, yes
07:37:31 <bollu> Iceland_jack: so you're saying I have two arrows from a to () ? one being arr = const ()  and the other being arr' = const undefined
07:37:40 <hpc> three
07:37:43 <hpc> the last one is undefined
07:37:58 <bollu> hpc: undefined is a type, not a function (arrow) ?
07:38:15 <Iceland_jack> :t undefined :: Int -> Bool
07:38:16 <lambdabot> Int -> Bool
07:38:16 <hpc> undefined is an inhabitant of the type (x -> ())
07:38:55 <bollu> ah right. undefined is some type variable "a", and I can have it unify with anything. dang
07:38:59 <lyxia> and seq adds even more
07:39:07 <bollu> is it possible to have a type system with no bottom?
07:39:27 <bollu> or do all type systems of turing complete languages "need" bottom to model divergence?
07:39:28 <tdammers> bollu: possible, yes, useful, probably very, at least not for general-purpose programming
07:39:30 <Xandaros> It's possible, but you give up turing completeness
07:39:48 <bollu> Xandaros: for the reason I mentioned?
07:40:07 <bollu> lyxia: what exactly does "seq" do? it forces the first parameter to evaluate before the second right?
07:40:13 <hpc> so, (() the type) is a terminal object in category C (read, Hask) if for all x in C, there is a unique morphism of type x -> ()
07:40:17 <Xandaros> Because you need to solve the halting problem to get rid of bottom in a turing complete language
07:40:18 <bollu> lyxia: it's some form of forced evaluation in a lazy language?
07:40:21 <hpc> this is false because there are three inhabitants of that type
07:40:21 <tdammers> because given turing completeness, a non-trivially infinite loop or recursion can always be expressed
07:40:32 <hpc> (to summarize)
07:40:41 <bollu> hpc: so the final terminal object is bottom?
07:40:42 <tdammers> (some non-trivially infinite loop / recursion, that is)
07:40:47 <bollu> hpc: like, the actual terminal object?
07:41:07 <tdammers> bollu: no; the expression that doesn't terminate "evaluates to bottom"
07:41:18 <hpc> the terminal object in the category of haskell types is itself a type
07:41:22 <bollu> tdammers: so, like, fix id?
07:41:24 <hpc> so it would be Void if anything
07:41:29 <bollu> bottom is not a type?
07:41:33 <hpc> but there's still two unique morphisms to it
07:41:37 <hpc> const undefined and undefined
07:41:45 <hpc> bottom is a denotation of values
07:41:56 <bollu> :t fix id
07:41:58 <lambdabot> a
07:42:00 <hpc> there are many unique values that denote bottom
07:42:04 <bollu> oh, so, bottom is an inhabitant of a type?
07:42:12 <tdammers> worse
07:42:13 <Xandaros> s/a/every
07:42:17 <tdammers> an inhabitant of *every* type
07:42:22 <bollu> right
07:42:24 <hpc> yeah
07:42:39 <hpc> usually we lump all the bottoms together because you reason about them in the same way
07:42:39 <bollu> tdammers: you can show that with "fix id" right? fix id is an inifinite loop, and has type "a" so it inhabits every type?
07:42:46 <tdammers> bollu: yes
07:42:50 <Xandaros> I usually pretend bottom doesn't exist. Works fairly well most of the time
07:42:53 <bollu> tdammers: is there a simpler way to show that bottom inhabits every type?
07:43:06 <bollu> also, how is Haskell a closed cartesian category if it doesn't have a terminal object?
07:43:07 <tdammers> > undefined :: a
07:43:09 <lambdabot>  *Exception: Prelude.undefined
07:43:14 <bollu> tdammers: oh right
07:43:33 <bollu> don't the axioms of CCC need initial, terminal and exp. objects?
07:43:41 <tdammers> but that's nowhere near as illustrative as fix id, because you could have that by making undefined an actual value
07:43:43 <bollu> but Hask doesn't seem to have a termina; object?
07:43:45 <hpc> i think that assertion ignores bottoms
07:43:55 <bollu> I see
07:43:56 <Iceland_jack> bollu: ignore bottoms when doing CT
07:44:06 <bollu> so we pretend our language doesn't have diverging computation?
07:44:09 <bollu> when it actually does?
07:44:12 <Iceland_jack> sure
07:44:14 <hpc> sometimes we pretend, sometimes we don't
07:44:19 <bollu> how do we know that we aren't letting something slip by?
07:44:27 <mayhew> ;q
07:44:29 <hpc> stream fusion has to assume bottom and seq in order to work in all cases
07:44:36 <bollu> that's like physicist math :P
07:44:36 <hpc> and i think there were some ghc bug reports about it at one point
07:44:48 <tdammers> in practice, the silent agreement that every statement about our types comes with an unspoken "...except for bottom"
07:44:51 <hpc> (as applies to optimizations on [])
07:44:53 <bollu> I see
07:45:03 <bollu> going back to seq
07:45:07 <bollu> what exactly does it do?
07:45:07 <tdammers> i.e., as long as nothing bottoms out, our type system is consistent
07:45:23 <hpc> (x `seq` y) = y, but strict in both y and x
07:45:25 <tdammers> which is as good as it gets as long as TC is required
07:45:38 <hpc> or to put it another way
07:45:43 <hpc> defined `seq` y = y
07:45:44 <bollu> hpc: so it evaluates x and throws it away?
07:45:49 <hpc> bottom `seq` y = bottom
07:45:53 <hpc> and that's the whole definition
07:45:56 <hpc> yes
07:46:00 <bollu> so it lets you propogate bottom?
07:46:06 <bollu> > fix id `seq` 2
07:46:07 <hpc> it's a bit weirder than that though
07:46:10 <lambdabot>  mueval-core: Time limit exceeded
07:46:14 <bollu> nooe
07:46:19 <bollu> hpc: go on
07:46:21 <hpc> in practice it's used to tie evaluation to other evaluation that would otherwise be independent
07:46:31 <hpc> it makes foldl' work, for example
07:46:39 <bollu> hpc: why would we want a seq?
07:46:46 <bollu> hpc: efficiency? or is there some theory to it?
07:47:12 <hpc> it controls what things are evaluated when, for the convenience of the physical computers that have to run your code
07:47:20 <lyxia> efficiency yes
07:47:23 <Xandaros> So you can evaluate values early you know will be needed. So you don't build a giant stack of stuff in memory
07:47:50 <bollu> and how does the existnce of seq interact with theory? what happens when you mix seq with bottom?
07:47:55 <hpc> on the one hand, physical computers being able to run code is nice
07:48:05 <hodapp> hpc: that's open for debate
07:48:14 <hpc> on the other hand, being able to cary bottoms around like that makes some reasoning hard
07:48:21 <hpc> there's one more weird thing seq does
07:48:27 <hpc> which is massively inconvenient
07:48:38 <hpc> which is it can distinguish between undefined and (const undefined)
07:48:48 <bollu> hpc: how?
07:49:04 <Xandaros> > const undefined `seq` 5
07:49:05 <bollu> > (const undefined) `seq` 2
07:49:05 <hpc> > let x = undefined :: Int -> Int in x `seq` 5
07:49:10 <lambdabot>  5
07:49:10 <lambdabot>  2
07:49:10 <lambdabot>  *Exception: Prelude.undefined
07:49:10 <Xandaros> xD
07:49:12 <hpc> > let x = undefined :: Int -> Int in x `seq` 5
07:49:16 <lambdabot>  *Exception: Prelude.undefined
07:49:19 <hpc> > let x = const undefined :: Int -> Int in x `seq` 5
07:49:21 <lambdabot>  5
07:49:35 <bollu> okay, I'll bite: how?
07:49:38 <Xandaros> :t const undefined
07:49:39 <lambdabot> b -> a
07:49:45 <hpc> (const undefined) evaluates to a lambda-y thing
07:49:50 <bollu> becaue const undefined throws it away?
07:50:01 <bollu> \x -> y (with y in the closure) right?
07:50:05 <bollu> that's const y^
07:50:06 <bollu> ?
07:50:25 <hpc> a very rough description is that (\_ -> undefined) uses some magical "lambda" constructor that undefined itself doesn't
07:50:26 <Xandaros> const x y = x
07:50:43 <bollu> Xandaros: right. I wrote the curried version. 
07:50:45 <hpc> i don't know the specifics of ghc's implementation because it does some funny things with functions
07:50:45 <bollu> hpc: okay
07:50:56 <hpc> the reason that messes stuff up theoretically is
07:51:13 <hpc> there's an assumption that the only way to detect a lambda that's bottom is to apply it to something
07:51:25 <hpc> that turns out to be convenient sometimes, but seq breaks it
07:51:44 <bollu> hpc: why is the assumption needed?
07:51:49 <Xandaros> But the thing is, \x -> undefined itself is not bottom. It is a function that returns bottom
07:52:01 <Xandaros> As is const undefined
07:52:05 <bollu> Xandaros: right
07:52:26 <hpc> it lets you treat a function as a black box defined only by its behavior when applied to something
07:52:47 <bollu> hpc: ah okay, makes sense
07:52:47 <Xandaros> And to tell whether a function returns undefined is solving the halting problem. So I don't see why seq should attempt that
07:52:57 <hpc> so you don't need any sort of extra formalization on what a function is
07:53:03 <hpc> it's just what it does, and what it does is "obvious"
07:53:05 <bollu> hpc: so it's the math way of thinking of it right? as a map which you can only observe by applying
07:53:08 <hpc> yeah
07:53:20 <bollu> Xandaros: oh, right, when you put it that way o_O
07:53:44 <bollu> hm, so in a very real way it's able to distinguish between bottom and a function that returns bottom
07:53:45 <hpc> the more general mathematical term is extensionality, though that term applies more broadly than just seq and stuff
07:54:02 <hpc> functions are extensionally equal if their results are the same for all inputs
07:54:10 <hpc> functions are intentionally equal if they are defined the same way
07:54:26 <bollu> hpc: isn't the name of "extentionality" from ZFC?
07:54:30 <bollu> hpc: or is it a general thing?
07:54:37 <hpc> (2 *) and (join (+)) are extensionally equal but not intentionally equal
07:54:53 <hpc> in fact, (2 *) and (* 2) might not even be intentionally equal
07:55:12 <bollu> hpc: commutativity be damned?
07:55:19 <hpc> bollu: not sure, i mostly just learn the math directly adjacent to computing concerns
07:55:26 <hpc> commutativity be damned
07:55:28 <Xandaros> What about (2*) and \x -> 2*x, though? It seems difficult to draw a line here
07:55:44 <hpc> in haskell those would be intentionally equal
07:55:50 <hpc> because (2*) is syntactic sugar
07:56:07 <Iceland_jack> (2*) is not the same as (\x -> 2*x) since we're being pedantic
07:56:08 <Iceland_jack> https://github.com/quchen/articles/blob/master/fbut.md#a-op-is-not-x---a-op-x
07:56:27 <hpc> oh wow, they aren't
07:56:30 * hpc TILs
07:56:32 <Iceland_jack> or at least for a given operator
07:56:44 <hpc> oh right, it's (*2) = (\x -> x * 2)
07:56:55 <bollu> Iceland_jack: is that your github? :)
07:57:00 <hpc> oh wait, i was right
07:57:05 <hpc> sort of
07:57:09 <Iceland_jack> no
07:57:12 <hpc> the haskell standard says i am right, but ghc deviates
07:57:26 <hpc> This GHC behaviour violates the Haskell standard, which literally demands that "the following identities hold":
07:57:29 <hpc> (op e)  =  \ x -> x op e
07:57:32 <hpc> (e op)  =  \ x -> e op x
07:57:32 <quchen> hpc: Well, in *Haskell* they are equal.
07:57:35 <quchen> In GHC, they are not.
07:57:39 <hpc> yeah
07:58:13 <hpc> also i would have never thought to use a github repo as a text dump like that
07:58:35 <quchen> hpc: I don’t like HTML enough to generate a proper website
07:58:49 <Iceland_jack> hpc: I have some 20 thousand lines of Haskell notes that I should really tidy up and make public
07:59:00 <hpc> quchen: me either, that's why i only make improper websites ;)
07:59:01 <bollu> quchen: use a static site generator? I particularly like hugo
07:59:41 <quchen> I think Hakyll is pretty nice. But by website would be a ripoff of Chris Done's site because everything I do is solarized. Also: I really don't like HTML ;-)
08:00:03 <hpc> bollu: just looked it up, extensionality is used in the same way as in ZFC
08:00:04 <Xandaros> Just write it in md and have it converted :P
08:00:17 <quchen> The FBUT is more of a dump of things that come up occasionally in here to avoid repetitive answers. I think a text file is a good fit for that.
08:00:19 <bollu> hpc: cool, thanks :D
08:00:30 <quchen> And much better than “Google it”.
08:01:11 <hpc> i like wikipedia's page on ZFC
08:01:15 <hpc> there's a section listing the axioms
08:01:19 <hpc> 8 of them are "axiom of blah"
08:01:27 <hpc> last one is "well ordering theorem"
08:01:32 <hpc> way to axiom, guys
08:01:53 <hpc> "this axiom is so true that i proved it!"
08:02:33 <hodapp> -_-
08:02:59 <hodapp> Hakyll is nice, but I *still* do not feel like learning how to CSS properly
08:03:27 <bollu> thanks for the explanation guys :)
08:10:04 <tdammers> I'm working on a thing that does that on the fly
08:13:40 <Squarism> im trying to run leksah here. To be able to show types and such, it required GHCi debugger to run. It complains i dont have certain dependencies. I use stack for building/dependencies otherwise wo problem. Can i somehow make leksah rely on stack - where i got my dependencies?
08:14:08 <Squarism> .."got my dep.." ok.. bad explaination but i guess you understand
08:18:39 <Squarism> ...just found out from leksah github page they currently dont play along
08:20:04 <rydgel> Squarism: Emacs/Spacemacs and Atom works pretty well with Stack for me. If you want to look for another IDE.
08:20:55 <Squarism> rydgel, what im after is inspection of infered types. Do these handle that?
08:27:40 <Cale> hpc: Yeah, usually that would be "axiom of choice", but I don't know why they went with well ordering instead
08:43:55 <rydgel> Squarism: yes
08:44:35 <hpc> Cale: obviously it's wikipedia's math bias showing - they went for the one that's obviously false instead of the one that's obviously true
08:45:07 <Cale> hpc: It's almost as weird as putting "every vector space has a basis" there
08:45:44 <alercah> every infinite connected graph has a spanning tree
08:45:50 <alercah> canonical form of the axiom
08:53:23 * hackagebot eventstore 0.13.1.0 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.13.1.0 (YorickLaupa)
08:53:25 * hackagebot ghcjs-hplay 0.3.2 - client-side Web EDSL for transient nodes running in the Web browser  https://hackage.haskell.org/package/ghcjs-hplay-0.3.2 (AlbertoCorona)
08:58:55 <genso-pyon> I have a question about what the users of an abstract data type can infer the implementor knows. The question is in this gist: https://gist.github.com/eduardoleon/f5f0df8f9a686148ffcb8c3f6066472f
09:00:32 <Sinestro> Do Criterion `env`s get kept around between runs? I assume they're not included, but at the same time there's no way that what I'm getting is right, despite having an incredibly close grouping of (massively too-large) datapoints 
09:00:43 <Sinestro> but if the setup was being included, I could almost see it being right
09:05:33 <glguy> genso-pyon: It looks like Bob won't be able to learn anything because he has no way to produce any Key values, so he can't construct the first argument to lower/upper, so he can't use them either
09:06:26 <glguy> so is the plan to only consider the two properties?
09:07:26 <genso-pyon> glguy: I'm not saying that the reasoning has to be carried out *inside* Haskell.
09:08:07 <Squarism> ok.. obvious i should have used lenses for everything. Pattern matching every constructor gets unreadable
09:08:24 * hackagebot eventstore 0.13.1.1 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.13.1.1 (YorickLaupa)
09:08:43 <genso-pyon> glguy: Strictly speaking, what I want to know is whether it's possible to implement the “lower” and “upper” without having already enough information to implement an Ord instance. Or even an Eq instance, since Eq, lower and upper together provide enough information to recover the Ord instance.
09:08:52 <glguy> genso-pyon: Where is f quantified?
09:09:08 <genso-pyon> glguy: Implicitly, at the beginning, with a forall.
09:09:11 <ARM9> I'm trying to redirect stderr from a process started in haskell, but I'm not even sure which method I should use to start the process. readProcess seems inadequate
09:09:17 <ARM9> is there anything like good ol' popen?
09:09:25 <genso-pyon> glguy: Similarly, f,x,y are all implicitly quantifified at the beginning of (1), with a forall.
09:09:52 <genso-pyon> glguy: Fixed gist.
09:10:22 <srhb> ARM9: doesn't createProcess give you back a stderr handle?
09:10:32 <glguy> genso-pyon: can rule 1 be right? surely f could have been (const someKey) and then lower and upper wouldn't  be commutative
09:10:39 <ARM9> srhb, nope, doesn't give me back any handles
09:10:44 <glguy> err, rule 0
09:11:06 <genso-pyon> glguy: Oh, right...
09:11:06 <ARM9> it's also kind of annoying to use when you just want 2>/dev/null
09:12:48 <genso-pyon> glguy: Mmm, I need some notion of “commutative wherever possible”. Like, if you have a priority queue, two entries with the same key... striiictly speaking aren't necessarily equal, but they are “equal for our purposes”.
09:13:01 <genso-pyon> I'm going to have to rethink this better.
09:13:14 <genso-pyon> glguy: Thanks!
09:18:53 <maerwald> ARM9: there is https://hackage.haskell.org/package/unix-2.7.2.0/docs/System-Posix-Process-ByteString.html#v:forkProcess
09:24:20 <glguy> ARM9: createProcess is configurable with what it does with stdout,in,err. You can tell it to close them, create a pipe, inherit, or send to handle
09:25:48 <srhb> ARM9: in the process library, one can use Inherit for std_out for instance
09:25:56 <srhb> Oh, glguy just said that, sorry.
09:26:01 * srhb was experimenting
09:28:57 <maerwald> https://hackage.haskell.org/package/MissingH-1.4.0.1/docs/System-Cmd-Utils.html#v:pOpen
09:37:01 <nitrix> genso-pyon: Always nice to see you here, pyon-senpai c:
09:48:25 * hackagebot chunked-data 0.3.0 - Typeclasses for dealing with various chunked data representations  https://hackage.haskell.org/package/chunked-data-0.3.0 (MichaelSnoyman)
09:48:27 * hackagebot classy-prelude 1.0.0 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-1.0.0 (MichaelSnoyman)
09:48:29 * hackagebot classy-prelude-conduit 1.0.0 - classy-prelude together with conduit functions  https://hackage.haskell.org/package/classy-prelude-conduit-1.0.0 (MichaelSnoyman)
09:48:31 * hackagebot classy-prelude-yesod 1.0.0 - Provide a classy prelude including common Yesod functionality.  https://hackage.haskell.org/package/classy-prelude-yesod-1.0.0 (MichaelSnoyman)
09:53:09 <Sinestro> How do I write the FFI fiddling in http://lpaste.net/169041 so that it's not 20x slower than the same (completely naive) code in Haskell?
09:53:25 * hackagebot conduit-combinators 1.0.4 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.4 (MichaelSnoyman)
09:53:27 * hackagebot minlen 0.1.0.0 - Express the minimum length of a container in its type  https://hackage.haskell.org/package/minlen-0.1.0.0 (MichaelSnoyman)
09:53:29 * hackagebot mono-traversable 1.0.0 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-1.0.0 (MichaelSnoyman)
09:53:31 * hackagebot mono-traversable-instances 0.1.0.0 - Extra typeclass instances for mono-traversable  https://hackage.haskell.org/package/mono-traversable-instances-0.1.0.0 (MichaelSnoyman)
09:53:33 * hackagebot mutable-containers 0.3.3 - Abstactions and concrete implementations of mutable containers  https://hackage.haskell.org/package/mutable-containers-0.3.3 (MichaelSnoyman)
09:55:58 <the_2nd> Instead of Just and Nothing, I defined treesOntile as [makeTree ...] or []
09:56:00 <the_2nd> http://lpaste.net/8638812140167233536
09:56:23 <the_2nd> with the Maybe solution, I get a "No instance for Ord arising from a use of <" at random
09:56:45 <the_2nd> while random ist just a Double, seems like I'm in the monadic Maybe context now, which breaks this
09:57:23 <lyxia> how's random defined
09:57:50 <lyxia> you can't have monadic guards
09:57:54 <the_2nd> http://lpaste.net/2692257162385686528
09:58:22 <the_2nd> ah
09:58:22 <lyxia> ok it's not monadic
09:58:31 <the_2nd> my bad is on l 10
09:58:34 <the_2nd> didnt change that
09:58:47 <the_2nd> yep
09:59:01 <the_2nd> totally missed that line until pasting it to lpaste :D
09:59:15 <the_2nd> http://lpaste.net/3646852032339378176   works
09:59:59 <lyxia> the_2nd: you can inline the first clause of treesOnTile, f _ takes care of the rest
10:00:33 <lyxia> f (random, ..) | random < 0.3 = Just $ .... where (...)  ; f _ = Nothing
10:01:04 <the_2nd> http://i.imgur.com/531lOsz.png   wonderful trees
10:01:49 <lyxia> cute
10:02:31 <the_2nd> yep, your syntax is nicer
10:18:26 * hackagebot hpp 0.3.1.0 - A Haskell pre-processor  https://hackage.haskell.org/package/hpp-0.3.1.0 (AnthonyCowley)
10:18:28 * hackagebot GLUtil 0.9.1.0 - Miscellaneous OpenGL utilities.  https://hackage.haskell.org/package/GLUtil-0.9.1.0 (AnthonyCowley)
10:34:02 <sleblanc> Is there a way to import only a specific instance of a class? For example, importing the Bifunctor instance of Either, but not all the n-tuple instances?
10:34:25 <geekosaur> there's no way to conditionally import instances at all
10:34:35 <geekosaur> except to put each instance in its own module
10:34:53 <alercah> it's a deliberate design decision, to reduce incoherence
10:35:17 <alercah> if you don't allow orphan instances then all instances are coherent
10:35:38 <sleblanc> ok, thanks for the insight
10:35:46 <alercah> but there are valid reasons for orphan instances, so disallowing selective import at least allows for some consistency
10:35:58 <alercah> (coherence means that the same instance is chosen at every point in the program)
11:08:00 <kurt11> Can someone help me make a super simple array: http://lpaste.net/169049
11:09:07 <c_wraith> kurt11: it needs to know what type of array you're making.  It doesn't know what type the bounds are, because numeric literals are polymorphic.
11:09:35 <c_wraith> kurt11: try making the bounds (0 :: Int, 3)
11:10:06 <c_wraith> (usually inference with the rest of the program means you don't need to do this, but since there's no extra context in this case, it needs some help)
11:13:27 * hackagebot elm-hybrid 0.1.3.0 - Combine Elm with Haskell for data based applications  https://hackage.haskell.org/package/elm-hybrid-0.1.3.0 (matsrietdijk)
11:16:17 <tippenein> should I be using Exception.bracket for setting and unsetting env variables for a spec?
11:16:35 <tippenein> it seems a bit appropriate, but the type signature is slightly off
11:16:48 <c_wraith> Only if the test environment doesn't do it for you.
11:16:59 <c_wraith> I would expect the test environment to make sure that you're exception-safe
11:17:46 <tippenein> the presence of the "test" env variable means it uses an in-memory database mostly
11:18:01 <tippenein> at the moment anyway..
11:18:34 <tippenein> but usually the you're passing something along in a bracket, but this is just 2 empty IO ()'s
11:19:07 <c_wraith> Eh, throw the second one and your action in a const
11:21:40 <tippenein> c_wraith: that seems to do it. Thanks!
11:36:24 <{AS}> What does it mean if cabal configure exists with code 11?
11:38:55 <geekosaur> those codes don't carry any information, aside from zero/nonzero
11:42:28 <buglebudabey> how can i tell stack to look in subdirectories when importing modules in runghc
11:53:58 <Welkin> runing into a stack problem where I try to install vector globally (to use in ghci), but I get an error when I start ghci using `stack ghci`
11:54:11 <Welkin> worked on mac, but there is a problem on linux
11:54:39 <Welkin> `stack install vector` then `stack ghci` just worked before
11:55:32 <mbuf> I am trying a simple binary search tree, https://paste.fedoraproject.org/387907/. How do I assert the tree structure with hspec?
11:56:30 <lyxia> Welkin: what error
11:56:47 <Welkin> lyxia: well, I am not sure if it is related
11:57:24 <Welkin> but when I start ghci using stack, it says "Error parsing targets: the specified targets matched no packages" and then "Warning: build failed"
11:57:55 <Welkin> I am running it outside of a project on purpose
11:58:26 <Welkin> I don't get that error on mac though
11:58:28 * hackagebot aeson-compat 0.3.5.0 - Compatibility layer for aeson  https://hackage.haskell.org/package/aeson-compat-0.3.5.0 (phadej)
12:01:31 <cocreature> mbuf: you need an Eq instance, but you can let ghc derive it for you
12:02:14 <mbuf> cocreature, I get the error, No instance for (Eq (Tree Int)) arising from a use of `shouldBe'.
12:02:40 <mbuf> cocreature, how can I derive it?
12:02:44 <cocreature> mbuf: yeah that’s exactly what I was trying to say :) an Eq instance is what allows you to use == which is what shouldBe is using behind the scenes
12:03:03 <cocreature> mbuf: just change "deriving (Show)" to "deriving (Show,Eq)"
12:03:29 * hackagebot operational-alacarte 0.3 - A version of Operational suitable for extensible EDSLs  https://hackage.haskell.org/package/operational-alacarte-0.3 (EmilAxelsson)
12:03:39 <mbuf> cocreature, awesome!
12:03:42 <mbuf> cocreature, thanks!
12:04:09 <lyxia> Welkin: are you sure you don't have a stack.yml laying around? what about in the .stack folder?
12:04:14 <cocreature> mbuf: yw
12:04:50 <Welkin> lyxia: yes, in the ~/.stack/global-project directory
12:04:54 <Welkin> but that is always there
12:05:35 <Welkin> it is empty anyway
12:05:40 <Welkin> it just lists the resolver
12:06:02 <Welkin> it's the same on both my systems
12:08:15 <lyxia> Welkin: maybe it's this (i.e., stack working fine)? https://github.com/commercialhaskell/stack/issues/1494
12:09:15 <Welkin> hm
12:09:33 <Welkin> that is exactly the problem I'm running into
12:10:12 <lyxia> so the difference would be due to your linux using an older version
12:10:16 <Welkin> I'm running stack 0.1.5.0 on one machine (no problem) and 1.1.2 on the other (has the problem)
12:10:19 <Welkin> no
12:10:25 <Welkin> the linux is using the newest version
12:10:26 <Welkin> o.o
12:10:33 <Welkin> the mac is using the old version
12:10:59 <Welkin> oh, the fixed wasn't released yet
12:11:03 <Welkin> the last release was may 22
12:11:07 <Welkin> er
12:11:15 <Welkin> the last release was may 20, but the fix was done on the 22nd
12:11:31 <haskellquestion> Is there an elegant way to do  [('A',1,2), ('B',3,4), ('C',5,6)] -> (1+3+5,2+4+6)
12:12:03 <Welkin> haskellquestion: fold over the list
12:13:11 <cobreadmonster> Hello.
12:13:14 <Welkin> > foldr (\(_, a, b) (as, bs) -> (a + as, b + bs)) [] $ [('A',1,2), ('B',3,4), ('C',5,6)]
12:13:15 <lambdabot>      Couldn't match expected type ‘(t, t1)’ with actual type ‘[t0]’
12:13:15 <lambdabot>      In the second argument of ‘foldr’, namely ‘[]’
12:13:15 <lambdabot>      In the expression:
12:13:20 <cobreadmonster> Welkin: lol
12:13:26 <Welkin> > foldr (\(_, a, b) (as, bs) -> (a + as, b + bs)) (0,0) $ [('A',1,2), ('B',3,4), ('C',5,6)]
12:13:27 <lambdabot>  (9,12)
12:13:35 <Welkin> haskellquestion: ^
12:13:57 <haskellquestion> Welkin: Thanks!
12:17:00 <glguy> To do that fold on more than a handful of elements you'd want to use a strict left fold
12:17:40 <Iceland_jack> > mconcat [ (Sum a, Sum b) | (_, a, b) <- [('A',1,2), ('B',3,4), ('C',5,6)] ]
12:17:41 <Iceland_jack> ;)
12:17:42 <lambdabot>  (Sum {getSum = 9},Sum {getSum = 12})
12:18:28 <lyxia> Welkin: Oh okay. I guess I somehow silenced it but can't remember it.
12:18:55 <cobreadmonster> glguy: I never got this.
12:19:28 <cobreadmonster> Isn't + strict in all its arguments anyway?
12:19:47 <glguy> it is, which is why you'd opt for a strict fold
12:20:16 <cobreadmonster> So won't the (+) force the evaluation anyway?
12:20:36 <glguy> Yeah, but in a less efficient order
12:20:53 <cobreadmonster> What order will that be in?
12:22:05 <glguy> one in which the whole sum was retraversed to evaluate it
12:22:44 <glguy> The answer from the foldr would be an unevaluated (1 + (3 + (5 + 0))) and (2 + (4 + (6 + 0)))
12:22:57 <cobreadmonster> Oh wait, he used a foldr/
12:23:00 <cobreadmonster> Okay, point taken.
12:23:09 <glguy> using foldl wouldn't  be any better
12:23:50 <dolio> The problem is that (,) is non-strict.
12:24:04 <cobreadmonster> Oh, right.
12:24:33 <cobreadmonster> So the top constructor in WHNF is (,) so fair enough.
12:24:33 <glguy> yeah, and because of (,) simply using foldl' wouldn't be better, either
12:28:03 <dolio> If you do something like: ((,) $! a+as) $! b+bs
12:28:35 <dolio> And your function has a type like `[(Int,Int)] -> (Int,Int)`, then you don't need foldl'.
12:30:14 <cobreadmonster> Fair enough.
12:31:55 <dolio> If it's more abstract, you might need to do something else, because GHC won't be able to optimize it.
12:33:12 <lpaste> glguy pasted “summing pairs” at http://lpaste.net/169053
12:33:29 <glguy> In this case GHC doesn't even bother with the intermediate pair
12:33:53 <glguy> The worker has two unboxed Int argument accumulator arguments
12:55:28 <Tor_> after having run "stack setup" is cabal then installed and if so where?
12:55:52 <Tor_> Atom complains when I try to build "'cabal' could not be spawned. Is it installed and on your path?"
12:56:58 <glguy> Tor_: No, stack is something else
12:59:17 <glguy> stack can install it's own private copy of GHC when you use stack setup, and stack uses the Cabal library for building, but it's a different executable from cabal, which you get by installing the package called cabal-install
12:59:52 <Tor_> @glguy thanks 
12:59:53 <lambdabot> Unknown command, try @list
13:01:39 <SparkySquirrel> !books
13:02:07 <Welkin> lol
13:02:40 <SparkySquirrel> Welkin: do you know an online paid for book that would teach me haskell?
13:02:43 <nitrix> ertes: ping
13:02:51 <leshow> SparkySquirrel: there are a ton
13:03:16 <nitrix> Is ertex the same as ertesx ?
13:03:21 <Welkin> @where learnhaskell -- SparkySquirrel 
13:03:21 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:03:27 <nitrix> err, ertes & ertesx ?
13:03:34 <Welkin> @where haskellbook -- also check out this
13:03:34 <lambdabot> http://haskellbook.com
13:03:37 <Welkin> the first is free
13:03:40 <Welkin> the second is not
13:03:49 <leshow> http://learnyouahaskell.com/chapters
13:03:51 <SparkySquirrel> it says to read Real World HAskell and then Learn You a Haskell for Great Good then make your first project
13:03:59 <leshow> http://book.realworldhaskell.org/read/
13:04:07 <Welkin> do the CIS course
13:04:43 <nitrix> SparkySquirrel: Recently, some of us have been recommending the HaskellBook.com by bitemyapp.
13:04:58 <leshow> http://chimera.labs.oreilly.com/books/1230000000929/index.html
13:05:10 <leshow> that one is "parallel and concurrent programming in haskell"
13:05:19 <leshow> i liked that one a lot
13:05:48 <nitrix> SparkySquirrel: You could also be interested in #haskell-beginners that are mostly readers of the book.
13:07:19 <SparkySquirrel> nitrix: I want to study so I'll go in there! Thanks!
13:07:30 <SparkySquirrel> nitrix: if I buy this book how do I back it up?
13:07:30 <nitrix> SparkySquirrel: From being on that channel and responding to questions often, I have observed the readers of the Haskellbook seems less confused and ask more pertinent questions.
13:07:43 <glguy> SparkySquirrel: This channel is fine for beginners, that one just hapens to be specific to that book
13:08:05 <SparkySquirrel> I want it copied 5 places on 5 different computers and 1 flash drive
13:08:14 <SparkySquirrel> because I break my operating systems so much
13:08:29 <SparkySquirrel> but my folks do not.
13:08:36 <nitrix> SparkySquirrel: It's available on Gumroad, you can download it and make as many copies as you'd like.
13:08:36 <TimoMeijer> Any knows how to implement an instance of MonadBaseControl for the Proxy type from pipes?
13:08:47 <SparkySquirrel> nitrix: ah, thanks!
13:08:51 <bennofs> TimoMeijer: i remember it is impossible
13:08:59 <bennofs> TimoMeijer: I could be wrong though
13:09:02 <buglebudabey> is there a Stack datatype in a library i should be aware of?
13:09:04 <TimoMeijer> bennofs: Well, that sucks xD
13:09:11 <glguy> Just be aware that it misuses a lot of terminology from Haskell, so it can be confusing to relate to other sources
13:09:18 <nitrix> buglebudabey: A list! :)
13:09:38 <buglebudabey> nitrix alright lol thanks
13:09:54 <SparkySquirrel> nitrix: if you lose your book can you redownload it for free?
13:10:03 <cloudhead> Hey can someone explain what the differences between Control.Monad.Catch (exceptions package) and Control.Monad.Except (mtl)  are? In general, which one is recommended?
13:10:04 <nitrix> SparkySquirrel: Correct.
13:10:10 <TimoMeijer> bennofs: So that makes it impossible to use ResourceT on top of a Proxy?
13:10:22 <SparkySquirrel> nitrix: alright I'll have it ordered within 5 minutes
13:10:43 <SparkySquirrel> lol what if there was a way to write device drivers in Haskell on Minix
13:10:55 <bennofs> TimoMeijer: I think https://hackage.haskell.org/package/pipes-safe-2.2.4/docs/Pipes-Safe.html is the pipes version of ResourceT (which originates from conduit)
13:10:57 <SparkySquirrel> would I get laughed at?
13:11:06 <nitrix> There is always a way, but I don't think it's going to be easy.
13:11:17 <glguy> People have done drivers in Haskell as a research project before
13:11:18 <nitrix> Some clever minds managed to write an operating system in Haskell.
13:11:37 <SparkySquirrel> nitrix: I looked at that and it's a bunch of low level data types and glue code
13:11:51 <nitrix> SparkySquirrel: Kernels tend to be like that.
13:11:54 <SparkySquirrel> I'd want an OS that makes all this simple and clean
13:12:18 <SparkySquirrel> ok, so drivers in C and translators in haskell?
13:12:19 <lyxia> cloudhead: exceptions works with exceptions (types that are instances of Exception), while Except can use any type as "error"
13:12:45 <SparkySquirrel> all the file systems can be in Haskell right?
13:12:59 <nitrix> There are file systems written in Haskell, sure.
13:13:21 <ertes> nitrix: pong and yes
13:13:24 <cloudhead> lyxia is that the main difference though?
13:13:25 <SparkySquirrel> perfect! offtopic: what's a good C book?
13:13:29 * ertes = ertesx
13:13:33 <Welkin> lol SparkySquirrel 
13:13:39 <cloudhead> lyxia how to choose?
13:13:44 <Welkin> "The C Programming Language"
13:13:46 <Welkin> the original
13:13:50 <SparkySquirrel> alright :)
13:13:52 <dysfun> no, it's not
13:13:54 <Welkin> by K&R
13:13:55 <Welkin> lol
13:14:07 <dysfun> if you want to learn to program ancient c badly, go ahead
13:14:08 <TimoMeijer> bennofs: Thanks, but doesn't solve what I was trying, I was attempting to go from a Conduit(As it had an already made twitter library) to pipes(As I wanted to try that library), this was how far I got until I ran into the issue that the proxy had to "pass through" the MonadBaseControl from the IO it wraps. http://lpaste.net/169055
13:14:44 <nitrix> ertes: I've had troubles using Reflex on windows. First, it has high bounds issues on multiple dependencies, which I solved on a fork, then because it depends on haskell-src-exts, which depends on old-time, it makes building it on windows much more tricky with a mysys+mingw environment.
13:15:14 <nitrix> ertes: I liked the premise and the talks I've seen, but I might just stick to reactive-banana. What am I trading off?
13:16:32 <nitrix> Last detail, I thought FRP frameworks using a monad were prone to time leaks :/ ?
13:16:39 <bennofs> TimoMeijer: I just looked at conduit, and its ConduitM type doesn't have a MonadBaseControl instance either. So you'll have to find another way, my memory that MonadBaseControl does not mmix well with streaming transformers was correct
13:17:41 <tojoko> hi
13:18:02 <zcourts> Is there a high level write up that describes GHC frontend's conversion from HsSyn to CoreSyn or more generally how Haskell desugars each of its constructs into core? 
13:18:35 <Welkin> zcourts: ask in #ghc
13:18:54 <zcourts> oki, thanks
13:20:14 <TimoMeijer> bennofs: Any other ideas how I could go from '(MonadResource m) => m (C.ResumableSource m StreamingAPI)' to a pipes Producer?
13:21:25 <bennofs> TimoMeijer: not sure, I'm not very experienced with either API, but perhaps there is a way to translate between the underlying types directly? A ConduitM is just an ADT, and I think both libraries export their constructors in an .Internal module?
13:22:49 <Tor_> In Atom trying to build haskell cabal project (made with stack) and I get "cabal: The program 'ghc' version >=6.4 is required but it could not be found." I have ghc-7.10.3 from running "stack setup". Or so the directory C:\stack_root\precompiled\x86_64-windows\ghc-7.10.3 makes me believe
13:23:59 <qualiaqq> if anyone uses spacemacs and has it setup nicely to work with stack, I would really appreciate seeing your config.
13:24:15 <glguy> Tor_: stack setup doesn't put things in standard places, so you'll have to add that to your path in the atom settings
13:28:47 <lyxia> cloudhead: If you need to handle errors that come from doing IO, for example reading files or communicating over a network, you could use exceptions; if you're defining custom error types, ExceptT might be handy.
13:29:12 <lyxia> I prefer the rule "you know it when you do it"
13:30:01 <Tor_> glguy: which path exactly is it? Under ghc-7.10.3 there is 1.22.5.0 and there I find many directories for things like ghc-mod. But not just "ghc".
13:30:13 <slemonide> How do I use "reads"?
13:30:58 <nitrix> :t reads
13:30:59 <lambdabot> Read a => ReadS a
13:31:03 <nitrix> type ReadS a = String -> [(a, String)]
13:31:30 <glguy> Slemonide: usually you dont, though
13:31:40 <glguy> You'd use read or readMaybe
13:31:50 <nitrix> slemonide: It's a parser for a type `Read a => a`, that returns a list of the possible parses.
13:32:34 <slemonide> so, why does reads "'e'" return an empty list? 
13:33:07 <nitrix> Depends on the type of said list.
13:33:17 <glguy> Because the parse failed
13:33:26 <nitrix> I'd expect :: [Char] to work.
13:33:55 <iphy> I'm trying to cross-compile a package ("distributive") which has a non-trivial Setup.lhs, and cabal tries to link it using the cross compilation linker and fails: Linking /tmp/cabal-tmp-16/distributive-0.5.0.2/dist/setup/setup ... unsupported ELF machine number 0
13:34:21 <nitrix> slemonide: Without the explicit type, you could be hitting a defaulting rule and then the parser fails for that type. It's just a theory though.
13:34:24 <slemonide> nitrix: reads "\'e\'" :: [(Char, String)] works
13:34:36 <nitrix> slemonide: There you go.
13:35:34 <nitrix> If you had code using these characters, the type inference would figure this out for you; but as it is currently, there's probably not enough information for that.
13:35:47 <slemonide> ok
13:36:33 <ertes> nitrix: if reactive-banana works for you, you won't miss too much
13:36:44 <ertes> one thing reflex has is efficient event fan-out
13:36:57 <ertes> also reflex gives you control over the main loop
13:36:59 <nitrix> Yeah, O(log n) supposedly.
13:37:23 <nitrix> I don't think I'll ever do crazy fan out, but I even put it in practice yet so I don't know what the needs are going to be.
13:38:02 <nitrix> ertes: I had a very last question for you, concerning FRP in general. What happens if I need to have effects within the "pure network" ?
13:38:27 <Tor_> glguy: stack path gave the information :)
13:38:37 <nitrix> ertes: Would I generate more events for the desired side effect and then have behaviors in IO react to that?
13:39:12 <nitrix> s/even/haven't/
13:42:13 <ertes> nitrix: in principle you never need that, particularly since r-b and reflex are capable of creating events and behaviours dynamically
13:42:39 <nitrix> I see. So it can modify its own structure.
13:43:01 <nitrix> What about effects though? I'm worried because my game has to load assets and new chunks of the map as the character moves.
13:43:13 <nitrix> Also, if it's going to be multiplayer, there
13:43:23 <Tor_> In Atom ide-haskell-cabal I have active GHC version 7.10, path for ghc 7.10 C:\Users\Tor\AppData\Local\Programs\stack\x86_64-windows\ghc-7.10.3\bin (where it is) and still I get "cabal: The program 'ghc' version >=6.4 is required but it could not be found."
13:43:24 <nitrix> *there's even more I/O involved. 
13:43:48 <ertes> nitrix: it's basically a coroutine model, passing control back and forth between the reactive network and the controlling loop
13:44:17 <ertes> nitrix: i can't say how well it's going to work with r-b, because your application isn't in control (i don't know what exactly 'actuate' does)
13:44:37 <ertes> but with reflex it's quite predictable, because you know when control leaves your application and returns to it
13:48:23 <gestone> hi all, i was wondering how to map over a type that's IO [String]
13:48:41 <ertes> nitrix: in other words, the reactive part of your application should not concern itself at all with loading assets…  that's the job of the controller (the "host" in reflex terms)
13:48:52 <gestone> i have this bit of code here
13:49:00 <ertes> gestone: you can apply a function to the result of an IO action by using 'fmap'
13:49:10 <gestone> ah yes i've tried doing that
13:49:21 <gestone> the line i have is here:
13:49:37 <gestone> pure ("music/" ++) <*> (lines <$> readProcess "ls" ["music"] [])
13:49:59 <Tor_> I gave up on adding it to the path in atom and added it to my user path in windows. Now it compiles :)
13:50:03 <ertes> gestone: note:  pure f <*> c = f <$> c
13:51:13 <gestone> ertes: ah okay, got it
13:51:45 <Tor_> Having read the first 13 chapters of "Learn You a Haskell for Great Good!" and finally have I actually compiled something.
13:51:48 <gestone> the issue i'm having though is that it's saying there's "No instance for (Data.String.IsString [String])"
13:51:53 <ertes> gestone: are you trying to prepend "music/" to each path?
13:51:56 <gestone> yeah
13:52:11 <ertes> gestone: you need two layers of mapping here
13:52:25 <ertes> your fmap (or (<$>)) goes through the IO layer
13:52:31 <ertes> fmap :: (a -> b) -> IO a -> IO b
13:52:41 <ertes> you're not going through the list layer yet
13:52:41 <gestone> right
13:52:57 <ertes> :t fmap . map
13:52:58 <lambdabot> Functor f => (a -> b) -> f [a] -> f [b]
13:53:25 <ertes> gestone: does that make sense?
13:53:55 <nitrix> ertes: Mind elaborating on the host concept? My biggest mental blocker revolves around it. Does that mean that some part (the host) that is going to feed events to the network is also responsible for doing IO prior and after the propagation?
13:54:14 <gestone> ertes: in a way, i understand that i need two layers of mapping so that i can get access to the list
13:54:42 <nitrix> ertes: What if some intermediate values are what determines the IOs that are executed?
13:55:03 <ertes> nitrix: yeah…  the host creates and also fires events, passing control to the reactive application; that's called a frame…  when the frame ends, control is returned to the host
13:55:18 <ertes> nitrix: and that's basically it
13:55:43 <ertes> nitrix: typically the host receives an "application" in the form of a function that takes events/behaviours to events/behaviours
13:55:58 <nitrix> ertes: So, the network isn't stateful then. The host has to maintain all the states and everything necessary for the network to work.
13:55:59 <ertes> it then creates the events and behaviours and applies that function accordingly
13:56:29 <nitrix> Right. I see.
13:56:36 <ertes> the network is stateful…  as you fire events, existing stuff changes, for example events in the network might fire in response, or behaviours might change
13:56:51 <nitrix> It's stateful only for the duration of the frame, though.
13:56:55 <ertes> gestone: somePureFunction <$> someAction
13:57:05 <nitrix> It's ehm, similar to ST ?
13:57:10 <ertes> gestone: map somePureFunctionForEachElementOfTheResultList <$> someAction
13:57:30 <ertes> nitrix: one frame accounts for one state transaction, basically
13:57:56 <gestone> ertes: got it, <$> (infix fmap) lifts the pure function so that it can operate on the functor correct?
13:58:18 <ertes> nitrix: http://lpaste.net/159333
13:58:25 <gestone> so it'd be map (++ "music/") <$> (lines <$> readProcess "ls" ["music"] [])
13:58:31 <ertes> nitrix: runMyApp is the controller, the "host"
13:59:02 <gestone> oops ("music/" ++)
13:59:17 <ertes> gestone: yeah
13:59:30 <ertes> gestone: next, import System.FilePath and use:  map ("music" </>)
13:59:49 <scriptor> hi everyone
13:59:57 <ertes> gestone: it's more portable than concatenating paths =)
14:00:02 <scriptor> I'm planning on diving into Pierce's TaPL soon
14:00:04 <gestone> oh awesome thanks!
14:00:26 <ertes> gestone: also use System.Directory instead of calling out to 'ls'
14:00:31 <ertes> gestone: getDirectoryContents
14:00:34 <scriptor> anyone have any resources I should read as precursors to that textbook?
14:00:55 <gestone> ertes: ahhh yes i thought there might have been an easier way to do so
14:01:27 <nitrix> ertes: Appreciated.
14:02:49 <ertes> gestone: map ("music" </>) . filter (foldr (\c _ -> c /= '.') False) <$> getDirectoryContents "."
14:03:10 <ertes> gestone: if the 'filter' part didn't make sense:  filters out stuff that starts with '.'
14:04:48 <ertes> nitrix: oh, if you want to run this, you'll need the timelike-time library
14:14:43 <synergistics> Is there any way to use the same variable twice in a pattern match to signify equality by using an extension or something? I have two constructors L and A that each take three arguments and I want to match against the list [L a b c, A c d e] where c in L and c in A refer to the same thing
14:15:22 <synergistics> Or do I just have to name them differently and check for equality in the function
14:15:40 <yamadapc> I'm trying to understand a bit of HVect's type family usage: https://hackage.haskell.org/package/hvect-0.3.1.0/docs/src/Data-HVect.html#HVect could someone point me to what `'[]` means? What extension defines that syntax?
14:18:25 <ertes> synergistics: you need to check explicitly
14:18:32 * hackagebot eventstore 0.13.1.2 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.13.1.2 (YorickLaupa)
14:19:11 <synergistics> ertes: Ok, thank you
14:19:32 <ertes> synergistics: but if your containers are Foldable, you can probably take a shortcut, by defining a combinator
14:20:55 <pavonia> yamadapc: DataKinds or PolyKinds, I guess
14:22:35 <synergistics> ertes: How would a combinator help?
14:22:50 <yamadapc> pavonia: There're like 10 extensions enabled on the module; I'm going to take a look, thanks!
14:24:00 <pavonia> yamadapc: It's promoting types to the kind level or something like that, other may know better
14:30:14 <yamadapc> It's a bit hard for me to grasp...
14:32:17 <ertes> @let allEqual xs = foldr (\x _ -> all (== x) xs) True xs
14:32:19 <lambdabot>  Defined.
14:32:24 <ertes> @let MyF a = MyF a a a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
14:32:24 <lambdabot>  Parse failed: Parse error: deriving
14:32:30 <ertes> @let data MyF a = MyF a a a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
14:32:32 <lambdabot>  Defined.
14:32:41 <ertes> > allEqual (MyF 3 3 3)
14:32:43 <lambdabot>  True
14:32:45 <ertes> > allEqual (MyF 3 3 4)
14:32:46 <lambdabot>  False
14:32:50 <ertes> synergistics: like that
14:33:17 <ertes> you can use 'allEqual' in a guard:  f xs | allEqual xs = …
14:39:33 <pavonia> :t foldr
14:39:34 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
14:43:33 * hackagebot monoidal-containers 0.2.0.0 - Containers with monoidal accumulation  https://hackage.haskell.org/package/monoidal-containers-0.2.0.0 (BenGamari)
14:50:31 <anilanar> so i've read the introduction for IO in haskell, it sounds like await/async in C#
14:51:48 <monochrom> I don't really know C#, but I bet this is a very good model, much better than most beginner's models already.
14:52:18 <anilanar> to be able to unwrap asynchronous ops (get result of it), you must use await operator (<- in haskell). To use await operator, it must be wrapped inside an async (Do in haskell) function.
14:52:18 <AliciaRose> @pl 
14:52:18 <lambdabot> (line 1, column 1):
14:52:19 <lambdabot> unexpected end of input
14:52:19 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
14:52:29 <monochrom> certainly at once superior to "SantaClaus -> (a, SantaClaus)" in terms of both accuracy and common knowledge
14:52:53 <anilanar> so Do blocks poisons the whole chain of IO upto the main function
14:53:06 <Rotaerk> async/await isn't really analogous to IO
14:53:15 <AliciaRose> @pl flip f x y = f y x
14:53:15 <lambdabot> flip = flip
14:55:09 <monochrom> Rotaerk, what if I just say "await" alone?
14:55:30 <monochrom> will it be close enough to >>= ?
14:55:45 <monochrom> or perhaps join?
14:56:10 <monochrom> (I don't know C#. but I will believe your answer.)
14:57:19 <Rotaerk> await is specifically for asyncronous IO
14:59:26 <anilanar> yes, but it seems one can implement async/await in haskell using IO
14:59:32 <anilanar> not vice versa
15:01:27 <Guest21> I'm trying to implement a linked list as part of an exercise on exercism.io, but I'm having difficulty implementing a function that returns true iff a LinkedList is empty. I can run `isNil Nil` and `isNil (Cons 5 Nil)` in ghci and everything works fine, but the test file won't compile. Can someone point be in the right direction? https://gist.github.com/cjlarose/b1a25cc1e8e6165342506faa15d6cd65
15:02:56 <monochrom> Guest21, don't use "Nil == l", use pattern matching again.
15:03:28 <Guest21> monochrom you mean like "isNil Nil = True" "isNil _ = False" ?
15:03:33 <monochrom> yes
15:04:43 <Guest21> monochrom well, shit. That worked. I've been hitting my head up against a wall for a half hour. Thanks!
15:04:58 <Guest21> monochrom do you know what caused the problem I was having specifically?
15:05:26 <monochrom> you did not know type classes, the Eq type class, and where == comes from.
15:06:21 <nightuser> hello. is it possible to use `writeFile` from `System.IO` on Windows without LF to CRLF conversion?
15:06:52 <Guest21> monochrom so I probably don't even need `deriving Eq` at all.
15:08:14 <ertes> anilanar: i think the async/await model is not particularly helpful
15:09:00 <ertes> anilanar: IO is about first-class actions:  getLine is not a "function with side effects", but a program, and you use regular functions to compose those programs
15:09:28 <ertes> example:  (>>) is the "and then" function that takes two programs and results in a program:  putStrLn "blah" >> putStrLn "blubb"
15:09:40 <monochrom> nightuser: No. Use withFile, hSetNewlineMode, and hPutStr.
15:10:12 <anilanar> ertes: this analogy was result of me thinking about "if there's an IO operation very deep in the stack in a huge project, how difficult would it make things if IO needs to go up till main func"
15:11:10 <ertes> anilanar: it's not that you "poison" pure code with IO, but actually it's the other way around:  you start from IO and call out to pure code
15:11:13 <monochrom> I have a good introduction to IO at http://www.vex.net/~trebla/haskell/IO.xhtml . I know it's good because I wrote it. :)
15:11:42 <buglebudabey> is there a way to do this " let (x:xs) = getList a" and at the same time account for the empty case?
15:11:46 <buglebudabey> within a function
15:12:13 <ertes> buglebudabey: use 'case' or 'foldr', whatever is more appropriate
15:12:26 <ertes> case getList a of x : xs -> …; [] -> …
15:12:36 <buglebudabey> ertes alright, was hoping there was a more shorthand way of doing it
15:12:56 <ertes> there probably is for your particular use case
15:13:30 <buglebudabey> ertes i'm not sure what type of wording would be appropriate for searching for such a way
15:13:58 <ertes> buglebudabey: you could explain what you're doing *after* the pattern-matching
15:14:07 <monochrom> there is more. "let <pattern> = xxx" is lazier, and it is lazier than necessary for the unaware.
15:14:36 <monochrom> in other words, even when it is correct, it is less efficient.
15:14:54 <ertes> also to be honest i don't consider 'case' to be very noisy
15:14:59 <buglebudabey> ertes i guess a case expression would be the way to go
15:15:05 <mniip> > let False = True in False
15:15:05 <buglebudabey> thanks
15:15:06 <lambdabot>  False
15:15:21 <monochrom> (both "lazier than necessary" and "more eager than necessary" are less efficient. generally "unnecessary" = "inefficient".)
15:16:14 <ertes> > let 2 = 3 in 2 + 2
15:16:15 <lambdabot>  6
15:17:01 <Irishluc1> any good projects out there which are newbie friendly
15:19:28 <newcomer> so I was checking a quora question and there's some code claimed to be valid Haskell. Can someone help me understand these imperative-looking functions?
15:19:29 <newcomer> http://lpaste.net/169064
15:20:57 <lyxia> it's indeed haskell syntax
15:21:37 <newcomer> lyxia, in what module/package are def, var, += and -= defined?
15:21:40 <umib0zu> hey all. are there any tutorials for the control.category library? I’m looking at the type docs, but I’m not sure what it’s actually for.
15:22:12 <monochrom> I sincerely think the author intends to hide their definitions from you.
15:22:42 <dmj`> newcomer: lens is (+=), (-=), data-default is def
15:22:55 <monochrom> I feel that the author just tries to show off rather than provide a reproducible experiment for you to verify and explore.
15:22:56 <dmj`> oh :] yea, they could be from anywhere really
15:23:21 * geekosaur would not be greatly surprised to find an acme package...
15:23:51 <monochrom> there is no way his/her "def" has anything to do with data-default, judging from how this "def" is used.
15:24:26 <bennofs> also not lens
15:24:30 <dmj`> monochrom: yea... 
15:24:57 <monochrom> this "def" seems to be a kind of evalState. I am willing to believe that (+=) etc are lenses or like lenses.
15:26:05 <ertes> someone tried to make haskell look like python
15:27:45 <dmj`> or..
15:27:47 <dmj`> > flip execState (def :: (Int,Int)) $ _1 += 1
15:27:51 <lambdabot>  (1,0)
15:35:00 <ertes> looks more like they are using the dependent-map library together with StateT to get mutable variables
15:35:47 <ertes> with 'var' being a member of some type class
15:40:55 <monochrom> This is the problem with programmers behaving unscientifically. Now we have to go out of our way to guess what they mean and how to clean up after them.
15:41:20 <monochrom> They should deserve all the hostile treatment given to the cold fusion people.
15:42:07 <dmj`> cold fusion lol
15:42:09 <maerwald> programmers behaving unscientifically? errr
15:42:57 <ertes> monochrom: are you aware that PHP is still the most popular web language?
15:43:10 <monochrom> yes maerwald, posting an incomplete code snippet and using it as evidence for a very strong assertion.
15:43:44 <maerwald> sounds like a pretty good troll then :D
15:43:50 <maerwald> pretty much expected from a programmer
15:43:56 <ertes> i don't expect programmers to be reasonable, much less scientific
15:44:09 <thimoteus> i expect them to think theyre reasonable and scientific
15:44:21 <ertes> yeah, that's more likely
15:44:46 <mettekou> I expect them to question the vagueness of those two terms.
15:44:57 <mettekou> The scientific method is not monolithic.
15:45:08 <monochrom> maerwald: here it is, near the end of https://www.quora.com/What-are-the-key-differences-between-Haskell-and-Standard-ML/answer/Raeez-Lorgat , where mysteriously undefined "def" and "*=" etc appear out of nowhere. and it is supposed to prove a point.
15:45:34 <maerwald> monochrom: you could reply like Linus: "you are full of sh..." xD
15:46:56 <maerwald> it works well for him (I guess)
15:47:14 <monochrom> yeah, cold fusion worked well for the cold fusion people, too.
15:47:46 <mettekou> "In summary, the Haskell of today is more mindful of modern software development practices, boasts a thriving community and is less 'theoretically pure' (some would argue) then SML."
15:47:51 <mettekou> This is the worrying part.
15:48:26 <mettekou> The semantics of core Haskell never changed. It's as "theoretically pure" as ever, whatever that means.
15:49:42 <ianbloom> Would anyone know of a function to print the contents of a foreign array?
15:51:02 <newcomer> I guess I should just ignore that snippet of code. I thought going through it will lead me to understand how mutability can be handled in Haskell.
15:51:03 <maerwald> mettekou: I could understand if he goes about 'theoretically unpure' wrt laziness... but it doesn't seem like that's what he means. Laziness is very "practical" and full of gotchas.
15:52:01 <PatchCode> @ianbloom  Have you tried peek array?
15:52:01 <lambdabot> Unknown command, try @list
15:52:11 <PatchCode> *peekArray
15:52:29 <taksuyu> Yeah I was thinking peekArray and print if it has a Show instance
15:52:42 <ertes> ianbloom: a "foreign array"?  as in a Ptr or ForeignPtr?  if yes, you can use Data.Vector.Storable from the 'vector' library
15:52:45 <taksuyu> Probably what you need :3
15:53:05 <ianbloom> Yes it’s actually an array created from a Repa array
15:53:40 <ertes> ianbloom: "array" is not well defined
15:53:41 <PatchCode> why don't you just run the array and print the results?
15:54:22 <ianbloom> Ah, ok it’s a foreignptr created by Repa.computeIntoP
15:55:21 <ianbloom> I just can’t figure out the order that is created in memory for a multi dimensional Repa.Array
15:55:43 <ianbloom> I’m not sure what you mean by “run”?
15:55:45 <ertes> ianbloom: you can easily go from a ForeignPtr to a storable Vector
15:55:58 <monochrom> newcomer: There are two venues you will need to pursue. The first is that IO provides IORef for mutable references (same as SML's "ref" type). The second is faking mutability by functions of types like "S -> (a, S)", putting them in a newtype wrapper called "State S a", and a few operators to make them convenient.
15:56:13 <ertes> ianbloom: if it's immutable, use Data.Vector.Storable.unsafeFromForeignPtr0
15:56:25 <ertes> ianbloom: otherwise use the same function from Data.Vector.Storable.Mutable
15:56:40 <ertes> that gives you a regular Vector or MVector
15:57:10 <ianbloom> Ok, I’ll give that a shot
15:57:16 <newcomer> monochrom, OK, will check IORef and the State monad.
15:57:53 <ianbloom> The reason I’m doing this is because I’m having trouble going from a Repa.array into an OpenCL Kernel
16:00:02 <ertes> ianbloom: a ForeignPtr or Ptr is pretty much exactly what you need for that
16:00:37 <ianbloom> Cool
16:01:00 <ianbloom> I have it working, it’s just that the order is wrong in memory.
16:03:05 <ertes> ianbloom: the order of a host array is platform-dependent…  if you need more control over it, one way is to write a type with a custom Storable instance
16:07:33 <umib0zu> has anyone used Control.Category before?
16:08:08 <umib0zu> How do I test for path equivalences using Control.Category
16:08:24 <umib0zu> and also how do I define some path equivalences?
16:09:27 <ianbloom> ertes: Ok I see.
16:10:28 <ski> umib0zu : i would assume with `Eq', if applicable
16:15:20 <mikail`> Hi, I need some design help. I have added a new function `delta` to my type class. It turns out that `delta` needs pretty much the same parameters as the other function in the type class called `price`. I'm not sure how I can factorise the implementation in order to allow code reuse amongst the two functions. See http://lpaste.net/169024.
16:16:47 <mikail`> It is mainly the `where` clause which I want to share amongst the two functions.
16:18:36 * hackagebot server-generic 1.0.0 - Auto-generate a server for your datatype  https://hackage.haskell.org/package/server-generic-1.0.0 (GabrielGonzalez)
16:24:33 <Humbert> dear #haskell: i have a more general dynamic programming question, is this a good place to ask?
16:24:52 <thimoteus> wont know until you ask it
16:25:52 <Humbert> it's a puzzle type question: http://pastebin.com/pTbiHWd7 , i have a brute force solution, but i *think* there should be a better solution via DP
16:26:03 <qinusty> Anyone know how I can circumvent memory issues with cabal on Digital Ocean servers? If I try to cabal update, the cabal process gets SIGKILL'd due to memory issues
16:28:02 <c_wraith> qinusty: you can try switching the system to use gold as the linker instead of ld
16:35:54 <pavonia> Humbert: What's the point of the array there?
16:37:19 <pavonia> And why is the result 13 not 12?
16:38:36 <qinusty> c_wraith: How can I get GHC to use gold by default?
16:38:54 <c_wraith> The only time I've done it, I just changed the system linker.
16:39:13 <c_wraith> and I only did that by following instructions in a debian tutorial somewhere.
16:40:01 <monochrom> on ubuntu /usr/bin/ld is a symlink. so I changed the symlink.
16:41:18 <monochrom> in fact ubuntu already has gold without adding any special package. it just doesn't get used. "the gold package" simply changes the symlink.
16:44:40 <monochrom> you may like to try "ghc -pgml /usr/bin/gold"
16:45:05 <Cale> Humbert: That problem, the weighted maximum independent set problem, is NP-hard.
16:45:08 <monochrom> I do not actually know how well it works. I haven't tried. I have only tried setting the symlink.
16:46:49 <Cale> Humbert: Here's a PDF I just Googled up which has some basic results about it: https://courses.engr.illinois.edu/cs598csc/sp2011/lectures/lecture_7.pdf
16:47:08 <monochrom> ok, it doesn't work well, "/usr/bin/gold: -Wl,-u,ghczmprim_GHCziTypes_Izh_static_info: unknown option"
16:48:16 <Donald_ET3> Would Haskell be a better language for writing safety-critical software than Ada?
16:48:43 <c_wraith> not for hard real-time applications
16:48:50 <c_wraith> which many safety-critical systems are
16:48:58 <monochrom> you know, there is $prefix/lib/ghc-7.10.3/settings , it may be possible to change some linker settings there
16:49:56 <c_wraith> Though people have had some fantastic success writing robot control software in haskell, using packages that create allocation-free C code as an intermediate pass.
16:51:10 <Cale> Yeah, and control systems for hybrid hydraulic vehicles.
16:51:46 <Donald_ET3> Interesting. Okay.
16:51:46 <Cale> (That's the application that the atom library was originally written for iirc)
16:52:02 <Cale> https://hackage.haskell.org/package/atom
16:52:07 <dolio> Too late.
16:52:34 <numee> Hi, recently I got to know ListT but still don't get the point. What are the advantages of `ListT IO String` over `IO [String]` ?
16:52:48 <Cale> numee: Which ListT is that?
16:53:06 <Cale> Unfortunately, there are several libraries which provide something called ListT
16:53:07 <numee> Cale: I'm referring to https://hackage.haskell.org/package/list-transformer-1.0.0/docs/List-Transformer.html
16:53:52 <mniip> numee, it's IO (Either () (a, IO (Either () (a, ...)))
16:54:29 <dolio> The point is that `ListT IO` is a Functor/Applicative/Monad that incorporates aspects of both lists and IO.
16:54:31 <mniip> IO actions are interspersed with the spine of the list
16:54:32 <monochrom> oh I see! ghc calls gcc for linking, too. therefore it basically wraps all options with "-Wl,".
16:54:47 <dolio> And just having an IO of a list doesn't do that.
16:55:20 <monochrom> I think you pretty much have to change the symlink.
16:55:45 <qinusty> If anyone gets bored and fancies testing my blackjack bot while you're on IRC, PM blackjack-hs-bot :) I'm going to bed though.
16:55:54 <monochrom> (is also why I did that in the past, when I used gold.)
16:56:47 <monochrom> hmm, maybe I can tell gcc to call gold
16:57:05 <numee> dolio: What do you mean by "incorporates aspects of both lists and IO" ? Is there anything that IO [a] can't do that ListT IO can?
16:57:21 <Humbert> pavonia: haha oops the result should be 12... math is hard
16:57:23 <monochrom> the road to passing options down 3 layers of abstractions is full of escape codes
16:57:29 <Humbert> Cale: thanks! reading
16:57:55 <hpc> numee: the point is that (ListT IO)'s (>>=) and whatnot incorporate elements of IO's and []'s
16:58:17 <dolio> If you have `m :: IO [a]`, then `(m >>=) :: ([a] -> IO b) -> IO b`
16:58:41 <dolio> If you have `m :: ListT IO a` then `(m >>=) :: (a -> ListT IO b) -> ListT IO b`
16:59:41 <dolio> Just having `IO [a]` doesn't allow you to work with `IO . []` as a unit.
16:59:48 <dolio> And also, `IO . []` isn't a monad.
17:00:10 <ski> numee : with `IO [a]' you first do some I/O, then get back a list. with `ListT IO a', you do some I/O before getting back each element, and you can probably stop and abort before getting all the elements
17:00:55 <Cale> So yeah, basically it gives you something like IO actions, but they're allowed to produce zero or more results to be iterated over, and "v <- x" means "run the action x, and let v be selected from its results in all possible ways"
17:01:15 <ski> numee : you can also probably interleave one `ListT IO a' with one `ListT IO b'
17:01:59 <numee> Isn't aborting possible in IO [a] taking advantage of Haskell's laziness?
17:02:43 <Koterpillar> laziness doesn't interleave with IO actions
17:03:09 <monochrom> IO is not lazy. at least 99% of the time.
17:03:37 * hackagebot z3-encoding 0.3.0.0 - High-level assertion encoding to Z3 solver  https://hackage.haskell.org/package/z3-encoding-0.3.0.0 (izgzhen)
17:03:52 <monochrom> if IO were lazy, "main = getLine >> putStrLn "bye"" would not wait for your input.
17:04:20 <monochrom> In fact, it would have no reason to output "bye" either, since it doesn't know for sure that you're watching.
17:05:25 <monochrom> This is what's wrong with imprecise thinking based on natural language essays.
17:05:56 <numee> wouldn't take 3 `fmap` sequence (repeat getLine) return first 3 lines of stdin even if that's in the middle of stdin?
17:06:19 <c_wraith> it'll never terminate
17:06:25 <c_wraith> Well, until you run out of memory.
17:06:44 <monochrom> do you know what IO's fmap does?
17:07:40 <monochrom> and I mean: be able to say it in precise code, not in make-believe essays and slogans
17:08:25 <Koterpillar> how do I submit an expression to runhaskell via the command line? e.g. runhaskell --??? "print 1"
17:09:01 <monochrom> I don't think you can. instead, consider: ghc -e "print 1"
17:09:13 <Koterpillar> that's what I wanted, thanks!
17:09:20 <tindo> hello Moussa you there
17:09:45 <msarr490> Tindo I m here
17:09:52 <tindo> okay I see you
17:10:55 <numee> monochrom: I think `fmap f action` is like a shorter way to write `action >>= (\x -> return (f x))`
17:11:31 <monochrom> oh haha, gcc accepts "-fuse-ld=gold" but not "-fuse-ld=<pathname here>". in fact, I only know after reading the doc, which says it is either "-fuse-ld=bfd" or "-fuse-ld=gold"
17:11:56 <thimoteus> oh no, i think i broke the blackjack bot
17:12:32 <monochrom> OK, can you next expand the definition of "sequence (repeat getLine)"?
17:13:24 <monochrom> which is going to be like "getLine >>= \x1 -> getLine >>= \x2 -> ... ad nauseum", right?
17:13:38 * hackagebot lio 0.11.6.0 - Labeled IO Information Flow Control Library  https://hackage.haskell.org/package/lio-0.11.6.0 (DeianStefan)
17:14:16 <monochrom> so the whole thing you're looking at is (getLine >>= \x1 -> ... ad infinium) >>= (\xs -> actually who cares what's here), right?
17:14:32 <monochrom> and remember what I said about main = getLine >> putStrLn "bye"?
17:15:23 <monochrom> As soon as the computer sees "getLine >>= whatever", it stops and waits for your input, doesn't matter what's inside whatever, no?
17:16:00 <monochrom> so if you have an infinite chain of getLine's, does an occurrence of some "return (take 3 xs)" at the end really matter?
17:16:23 <monochrom> See the predictive power of actual code and actual experiments?
17:16:53 <numee> monochrom: well, I might have got it ... many thanks for the gentle explanation.
17:16:56 <monochrom> As opposed to the astrological power of make-believe slogans and blog posts like "Haskell is lazy"?
17:18:03 <qinusty> thimoteus: What happened :P
17:18:28 <thimoteus> i'm not sure, but i got a hand worth 20, and he didn't give me the option to stay or hit. i said stay anyway, but no response
17:18:37 <qinusty> Ooooooo, strange
17:19:15 <tindo> \quit
17:21:30 <monochrom> ok, "ghc -optl -fuse-ld=gold" should do it
17:26:21 <monochrom> now I wonder if I can do it in conjunction with -split-objs too
17:28:03 <qinusty> thimoteus: Found the problem https://i.imgur.com/YbfmREE.png
17:28:21 <thimoteus> aww, i was playing too fast?
17:28:36 <monochrom> heh
17:28:55 <monochrom> try evaluating the Ackermann function once in a while.
17:29:41 <qinusty> Yeahhh, I'm not too sure what I can do to deal with that :P I'd have to hack in some sort of flood prevention
17:29:41 <thimoteus> i think in one of my complexity theory classes years ago we did something like that, to get a sense of how it grows
17:30:00 <thimoteus> maybe you could have it respond a second or so after it gets a message?
17:30:33 <hpc> iirc freenode's flood limit is one message every 2 seconds
17:30:37 <hpc> or 5 seconds, one of those
17:30:50 <hpc> so have messages push to a queue that gets slowly popped
17:31:35 <qinusty> I'm not actually using threads though so delaying for one person would mean others have to wait
17:31:56 <qinusty> I should probably add it at some point but I'm still getting to grips with Haskell so
17:32:46 <monochrom> you can just have 2 threads. one thread is what you do now, except it doesn't output to IRC directly, it sends a message to the 2nd thread. the 2nd thread simply waits for messages and outputs them to IRC, with delays.
17:33:18 <qinusty> Yeah I could, I'll look into it tomorrow. I've done enough midnight hacking for tonight
17:33:35 <qinusty> My haskell code started off so nice, now it's just ugly
17:37:05 <qinusty> thimoteus: It's up and running again. I'm heading off for the night though so I won't be able to reset it again :P I can't see why the flooding would stop you getting interactions all together though. Perhaps you just had to wait
17:37:17 <thimoteus> yeah, i'll just slow down
17:37:18 <thimoteus> thanks!
17:37:31 <qinusty> Also, Balance isn't persistent atm. No storage, That's a task for another day
19:01:13 <mniip> it seems that currently type families and similar mechanisms are unable to interact with quantification
19:01:30 <mniip> is there a fundamental reason why that can't be done or something?
19:02:22 <dmj`> mniip: existentially quantified types have their values inferred at runtime, it's the rigid skolem iirc
19:02:52 <mniip> I was thinking about universal quantification
19:07:55 <dmj`> mniip: unsure
19:09:55 <mniip> if in the 'F x' type family, the x argument is relevant, then no matter the structure of F, 'forall a. ... F a ...' is never getting inlined
19:10:03 <mniip> at least, that's what it seems like
19:18:29 <ski> by "relevant", i assume you mean that `F x' is defined by possibly matching on `x' ?
19:19:09 <mniip> yes
19:20:44 <ski> so, how could `F a' get expanded, without knowing more concretely what `a' is ?
19:47:56 <pikajude> so this happens a lot with node, but never before with haskell. i'm getting no output and an exit(1)
19:47:59 <pikajude> how do I figure out why?
20:01:33 <pavonia> pikajude: When you do what?
20:01:41 <pikajude> when I run my program
20:01:59 <pavonia> Only for a certain program?
20:02:07 <pikajude> yeah, it's something I'm working on
20:02:33 <pavonia> Hard to tell without more information
20:03:36 <pikajude> well it's about 2000 loc, i'll try to make a minimal test case
20:04:00 <pikajude> but I didn't think a program exiting without printing an exception and skipping all my own print statements was a thing that could happen
20:04:26 <pikajude> I was more hoping for maybe some RTS flags I could pass to print out exceptions I might be missing
20:04:52 <geekosaur> exceptions aren't normally silent...
20:15:03 <pikajude> right
20:16:24 <geekosaur> actually I am inclined to guess that you are (perhaps indirectly) invoking via the FFI a C function that does exit(1) instead of a proper error return when something goes wrong
20:20:17 * geekosaur has been known to atexit(abort); and run in a debugger in that situation...
20:23:38 <geekosaur> (or just set breakpoints on exit() and _exit())
22:28:47 * hackagebot configifier 0.1.1 - parser for config files, shell variables, command line args.  https://hackage.haskell.org/package/configifier-0.1.1 (MatthiasFischmann)
23:57:11 <mniip> @letlpaste 169081
23:57:12 <lambdabot>  That paste is too long! (maximum length: 4096)
23:57:17 <mniip> ಠ_ಠ
23:57:37 <daniel-s> Hi. If I use ":t 5" I get given "5 :: Num a => a". As I understand, Num is a type class and not a type.
23:57:48 <daniel-s> Why does :t not give me the type?
23:57:54 <Koterpillar> this is a type
23:58:01 <Koterpillar> Num is a typeclass
23:58:06 <Koterpillar> "Num a => a" is a type
23:58:15 <mniip> => takes a typeclass on the left and a type on the right
23:58:17 <mniip> and returns a type
23:58:32 <mniip> (s/typeclass/constraint)
23:59:09 <jle`> daniel-s: you can read that as "the type is 'a', where 'a' is any instance of the Num typeclass"
23:59:22 <jle`> daniel-s: so, it can be Integer, Double, Float, Int, etc.
23:59:31 <Koterpillar> :t undefined
23:59:33 <lambdabot> t
23:59:51 <daniel-s> OK. Thanks everyone.
