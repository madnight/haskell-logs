00:00:13 <dysfun> then i had to hand back my borrowed computer and move to a 2008 mac mini. Most linuxes do not run smoothly on them
00:00:31 <inerkick> I extracted stack, and now as doc says "place stack somewhere on your $PATH"
00:00:58 <dysfun> so the sensible thing to do would be to add $HOME/bin to your path and put it there
00:01:12 <Koterpillar> or ~/.local/bin
00:03:51 <inerkick> done
00:04:22 <dysfun> now just install the deps per the guide and you're done
00:04:28 <inerkick> so should install dependencies now
00:08:24 <inerkick> not getting it
00:08:29 <inerkick> may be some issue with the path
00:08:51 <dysfun> echo $PATH
00:10:06 <lpaste> shell pasted ‚ÄúNo title‚Äù at http://lpaste.net/169151
00:10:22 <inerkick>  thats the onehttp://lpaste.net/169151
00:10:43 <dysfun> right, and you put it in ~/bin or ~/.local/bin ?
00:11:03 <Koterpillar> inerkick: this is all coming from .bashrc or equivalent; clean that up and add what dysfun said instead
00:11:15 <Koterpillar> i.e. do you even have /opt/cabal/1.22/bin?
00:11:20 <inerkick> yeah
00:11:22 <inerkick> i am seeing that now
00:11:32 <inerkick> wondered where cabal came from
00:11:35 <dysfun> Koterpillar: see the last two entries though
00:11:56 <dysfun> inerkick: i recommend putting custom paths on the FRONT of $PATH
00:12:07 <Koterpillar> hash -r; which stack
00:12:24 <dysfun> my next guess is that the stack file isn't executable
00:12:28 <cobreadmonster> Does anyone have an interesting PL theory paper I could implement in Haskell with only a few days of effort?
00:12:32 <cobreadmonster> I have the week off.
00:12:36 <dysfun> which you can fix with chmod +x /path/to/stack
00:12:51 <Koterpillar> dysfun: disagree, it was extracted with tar
00:12:53 <dysfun> cobreadmonster: i've been wanting a raft implementation for haskell :)
00:13:22 * Koterpillar read that as "implementation of haskell" - that would be interesting distributed project
00:13:23 <cobreadmonster> dysfun: Paper link?
00:13:29 <dysfun> Koterpillar: and then moved. seems more likely than the possibilities
00:13:36 <cobreadmonster> Koterpillar: same.
00:13:44 <inerkick> weird
00:14:16 <dysfun> cobreadmonster: https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf
00:14:17 <Koterpillar> dysfun: my guess: mv stack ~/bin created an executable file '~/bin'
00:14:35 <dysfun> Koterpillar: ah yes, that sounds entirely plausible :)
00:15:42 <cobreadmonster> dysfun: Thanks! I really need to pick up some rudiments of distributed computing.
00:15:47 <cobreadmonster> I know next to nothing.
00:16:16 <dysfun> cobreadmonster: raft is is the least broken of the existing solutions imo. the trick with distributed computing is to rely exclusively on the good papers and not make shit up :)
00:17:39 <dysfun> you might also like to play with cloud haskell or transient
00:18:19 <cobreadmonster> dysfun: Sure, but I know next to nothing.
00:18:36 <dysfun> cobreadmonster: raft was explicitly written because nobody could understand the paxos paper :)
00:19:02 <cobreadmonster> dysfun: I don't have a CS background.
00:19:07 <dysfun> neither do i
00:19:34 <cobreadmonster> I know distributed computing is useful because it allows you to scale machine learning techniques, but short of that, I know nothing :P
00:19:57 <dysfun> well, any system with more than one machine is distributed
00:20:10 <dysfun> it's just normally we make it a database's problem
00:21:51 * dysfun wants to extend raft at some point to provide for higher level concensus (i.e. something you can build a distributed in-app database on)
00:38:20 * hackagebot transient 0.4.1 - Making composable programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.4.1 (AlbertoCorona)
00:58:20 * hackagebot transient-universe 0.3.1.2 - Remote execution and map-reduce: distributed computing for Transient  https://hackage.haskell.org/package/transient-universe-0.3.1.2 (AlbertoCorona)
01:11:18 <m1dnight_> I made my first "complete" haskell program \o/ https://github.com/m1dnight/carte
01:11:19 <tsahyt> is there an easy way to find out whether GHC has decided to inline a function?
01:12:51 <merijn> tsahyt: Look at the Core
01:13:04 <tsahyt> merijn: not my definition of "easy" but it'll do I suppose
01:13:19 <merijn> tsahyt: Most accurate way I know off at least :)
01:13:50 <tsahyt> does {-# INLINE #-} work as expected with functions in instances?
01:14:31 <merijn> No clue, tbh I would expect so?
01:15:28 <tsahyt> seems like it does
01:15:42 <tsahyt> I wonder how I get a full second of function call overhead though...
01:16:07 <merijn> tsahyt: I doubt it's the call producing the overhead, since calls are just jumps
01:16:26 <merijn> tsahyt: I assume you've already profiled it?
01:16:32 <tsahyt> not this version
01:16:43 <tsahyt> but with the inline pragmas it performs virtually the same
01:16:50 <tsahyt> as the old version that is
01:17:11 <merijn> Inlining is only really relevant if it allows further optimisation
01:17:21 <merijn> tsahyt: Got a small example?
01:18:33 <tsahyt> merijn: I'm operating on a monad with a MonadState BigState instance, where BigState is isomorphic to (SmallState1, SmallState2) and I've written classes that zoom in on SmallState1 and SmallState2, such that I can be more precise about what part of the state is changed in type signatures
01:19:03 <tsahyt> so basically I've got functions like modifyFoo f = modify (..apply to part of the state, leave rest alone..)
01:19:17 <merijn> hmmm
01:19:29 <tsahyt> the actual MonadState instance underneath is implemented with IORefs btw
01:19:34 <tsahyt> that's how far I went already...
01:19:46 <tsahyt> I feel ashamed, but it works
01:19:49 <merijn> Where's the cost according to the profiler?
01:20:04 * merijn writes Haskell that's usually 90% IO, so...
01:20:04 <tsahyt> all over the place, a lot is inexplicably in (>>)
01:20:28 <milesrout> merijn: well, it is the best imperative programming language
01:20:32 <merijn> milesrout: Word.
01:20:33 <milesrout> crap at functional programming though
01:20:35 <milesrout> just kidding
01:21:06 <merijn> I do mostly networking and concurrency, so it's IO everywhere, but I wouldn't wanna write this in C for anything... :p
01:21:42 <tsahyt> The code I'm working on now is actually a plugin library for an ASP solver written in C++
01:22:26 <tsahyt> the only reason why I put up with the pain of getting this to compile such that it can actually be loaded and runs is to avoid C++
01:22:32 <milesrout> ASP solver, is that a Haskell web framework?
01:22:37 <milesrout> :P
01:22:42 <tsahyt> answer set programming
01:22:44 <merijn> tsahyt: I've heard before that you can speed up monad stacks by explicitly writing them out, but I don't have experience with that
01:22:56 <merijn> Most of my performance sensitive stuff is C++ or worse >.>
01:23:21 <tsahyt> merijn: the stack itself is now only LoggingT (ReaderT Foo IO)
01:23:40 <tsahyt> it used to be a full RWS actually, but since I need IO as a base anyway I might as well roll it into this
01:24:07 <tsahyt> the LoggingT didn't add any appreciable overhead
01:24:16 <tsahyt> in fact it was actually faster than the Debug.Trace hack that I used for traces before
01:35:33 <merijn> Sorry, don't know any obvious things to try and I'm a bit busy trying to figure out why my code is inexplicably 3 ms slower to look into it :p
01:37:10 <tdammers> you're worrying about 3 ms
01:37:41 <tdammers> and here I am unable to figure out why I'm seeing something that should be as simple as one SQL query and a conversion to JSON take a whopping 20 seconds
01:37:57 <merijn> tdammers: The difference between HPC and web :p
01:40:59 <daniel-s> Are these two functions exactly the same thing?
01:41:01 <daniel-s> https://paste.debian.net/777341/
01:41:01 <merijn> tdammers: Also, the secret answer is: Because everything is terrible!
01:41:20 <merijn> daniel-s: Yes
01:41:39 <merijn> daniel-s: The latter is what the compiler turns the former into
01:42:22 <merijn> daniel-s: Or rather the compiler would probably turn it into "mammm = \lst -> case lst of ..."
01:46:34 <quchen> It will look the same in GHC‚Äôs intermediate representation.
01:47:07 <quchen> Not sure about the parameter-to-lambda though.
01:47:35 <merijn> quchen: STG (at least as presented in the paper) only has lambda's and variables
01:47:52 <merijn> quchen: So all functions in STG look like that
01:48:25 <quchen> Yeah, inlining is already done before STG.
01:48:52 <quchen> Maybe we should agree on the IR beforehand, or we‚Äôll argue about parsed Haskell, Core and STG simultaneously ;-)
01:51:37 <tdammers> merijn: the latter. in this particular case, the "web" part is actually quite fast; the slowness is probably caused by some sort of locking conflict in the home-grown legacy sockets code that is used for RPC calls between backend components
02:03:22 * hackagebot processing-for-haskell 0.1.0.0 - Computer graphics for kids and artists with Processing implemented in Haskell.  https://hackage.haskell.org/package/processing-for-haskell-0.1.0.0 (AntonKholomiov)
02:04:39 <jose__> Hi
02:06:42 <liste> hi jose__ 
02:08:05 <jose__> jesuscarri: mira arriba, debe haber una pesta√±a con un canal directo
02:08:35 <jesuscarri> si
02:09:39 <jose__> jesuscarri: dale a la pesta√±a y contesta
02:12:09 <jose__> jesuscarri: where are you?
02:13:22 * hackagebot processing-for-haskell 0.1.0.1 - Computer graphics for kids and artists with Processing implemented in Haskell.  https://hackage.haskell.org/package/processing-for-haskell-0.1.0.1 (AntonKholomiov)
02:32:16 <milesrout> can I use XeLaTeX with lhs2TeX?
02:32:16 <milesrout> (lhs2TeX is for literal haskell)
02:32:16 <merijn> milesrout: Sure
02:32:16 <merijn> I always use XeLaTeX and I've used lhs2TeX in the past and I don't remember anything breaking
02:32:16 <milesrout> merijn: okay, I‚Äôm using xelatex on the output of lhs2TeX and it‚Äôs just not displaying any unicode symbols at all. Specifically the equivalent of $\bot$
02:32:16 <tdammers> IIRC xelatex is a superset of latex, at least as long as input is utf-8
02:32:16 <merijn> You can specify the encoding for xelatex
02:32:16 <milesrout> merijn: it should just be UTF-8 by default though, right?
02:32:16 <merijn> I think so
02:38:23 * hackagebot http-proxy 0.1.0.2 - A library for writing HTTP and HTTPS proxies  https://hackage.haskell.org/package/http-proxy-0.1.0.2 (ErikDeCastroLopo)
02:40:44 <milesrout> w t f this shit is not working at all as I would expect it to
02:45:11 <kosmikus> milesrout: minimal example?
02:49:54 <milesrout> kosmikus: https://gist.github.com/milesrout/f1b4b7a55dc1e0ee54170267c5c419cd
02:50:09 <milesrout> output is a = ‚Äú‚Äù
02:50:56 <milesrout> with both lhs2TeX ‚Äîverb and lhs2TeX ‚Äîmath
02:51:55 <kosmikus> milesrout: oh, so this has nothing to do with xelatex
02:52:11 <milesrout> I‚Äôm running xelatex on the result of lhs2TeX
02:52:16 <milesrout> although it doesn‚Äôt work with pdflatex either
02:53:38 <kosmikus> milesrout: wait, when you say "output is a = ‚Äú‚Äù" you're talking about the pdf, not the immediate output of lhs2tex?
02:54:35 <milesrout> yes, the output of lhs2TeX includes the line 1,15\>[B]{}\Varid{a}\mathrel{=}\mathbin{1,15‚ä•1,15}{}\<[E]%
02:55:02 <milesrout> spose it‚Äôs not really a #haskell problem given that it seems to be on the latex end of things 
02:56:01 <cobreadmonster> Can Haskell identifiers start with an _?
02:56:27 <merijn> cobreadmonster: Sure
02:56:43 <merijn> cobreadmonster: Bonus: starting with _ silences the "unused variable" warning
02:57:40 <cobreadmonster> merijn: That's why it's used for record selectors, okay.
02:57:44 <nkaretnikov`> when reading a file via template haskell, is it possible to force reads, e.g., by forcing a certain module to recompile?
02:58:24 <cobreadmonster> albeit, why would you use something like `getA (Data a _b _c) = a` instead of `getA (Data a _ _) = a`?
02:58:25 * hackagebot wai-extra 3.0.16.1 - Provides some basic WAI handlers and middleware.  https://hackage.haskell.org/package/wai-extra-3.0.16.1 (MichaelSnoyman)
02:58:46 <merijn> cobreadmonster: Might wanna name variables for documentation reasons
03:03:25 * hackagebot http-proxy 0.1.0.3 - A library for writing HTTP and HTTPS proxies  https://hackage.haskell.org/package/http-proxy-0.1.0.3 (ErikDeCastroLopo)
03:05:10 <bitonic> Is there a way to get the number of currently running threads?
03:07:59 <Axman6> there's a way get the number of capabilities (roughly the OS thread which runs the Haskell threads) but I don't believe there's a way go get the number of haskell threads
03:13:41 <quicksilver> no, you'd have to implement your own thread manager - some kind of wrapper which stores the ThreadIDs as it creates them
03:13:44 <quicksilver> as far as I know.
03:43:27 * hackagebot snaplet-purescript 0.5.1.0 - Automatic (re)compilation of purescript projects  https://hackage.haskell.org/package/snaplet-purescript-0.5.1.0 (AlfredoDiNapoli)
03:58:55 <nkaretnikov`> is there a way to dump an arbitrary haskell expression as a template haskell exp?
04:10:06 <sigrlami_> how can I make synonym for type contraint? 
04:10:26 <cocreature> sigrlami_: enable ConstraintKinds and then just use a regular type synonym
04:10:36 <sigrlami_> ah, awesome
04:11:03 <merijn> Note, you can't actually use that synonym in any other file without enabling ConstraintKinds in it
04:11:26 <sigrlami_> yeah, I get it
04:11:38 <cobreadmonster> merijn: but you can pass -XConstraintKinds as  a compile flag.
04:11:48 <sigrlami_> I'm adding it to cabal
04:11:53 <cobreadmonster> Or better yet, put it in the makefile.
04:11:56 <cobreadmonster> or that.
04:12:10 <cobreadmonster> merijn: Is there a use case for local flags?
04:12:42 <magneticduck> cobreadmonster: the makefile?!
04:12:57 <cobreadmonster> magneticduck: The .cabal file, my bad.
04:13:05 * cobreadmonster mea culpa, mea maxima culpa...
04:13:36 <magneticduck> cobreadmonster: and are you talking about language extensions?
04:13:47 <magneticduck> I'd say there can be good cases for file-local language extensions
04:14:25 <cobreadmonster> Go on?
04:14:41 <magneticduck> some particularly ugly ones like UndecidableInstances can occasionally be "necessary", but enabling them globally can be too damaging
04:15:42 <cocreature> nkpart: you can use $(stringE . show =<< lift True) but that requires a lift instance
04:16:08 <cocreature> eh ^ nkaretnikov
04:16:17 <cocreature> oh he left
04:17:45 <magneticduck> cobreadmonster: I think these decisions (of using project-global extensions vs file-local ones) can hinge on a lot of factors, including project size and how accessible you want to make it
04:18:28 * hackagebot ListLike 4.4 - Generic support for list-like structures  https://hackage.haskell.org/package/ListLike-4.4 (DavidFox)
04:18:40 <cocreature> I prefer file local language extensions in all cases
04:19:06 <cocreature> makes it easier to see which extensions are enabled and thereby probably also used in a certain file
04:19:30 <magneticduck> teams can sometimes find it useful to decide on a central conglomeration of extensions to form their in-house dialect -- in those cases it probably makes sense to make that global
04:19:58 <magneticduck> it's a balance between redundancy and explicitness
04:20:23 <magneticduck> uh, or rather, redundancy and lack of explicitness
04:22:02 <magneticduck> huh, the CPP extension enables a C preprocessor pass on the source
04:22:23 <cocreature> well that‚Äôs what cpp stands for :)
04:23:06 <magneticduck> it could also enable a cpp compiler pass on the code n_n
04:23:28 * hackagebot caledon 3.2.2.0 - a logic programming language based on the calculus of constructions  https://hackage.haskell.org/package/caledon-3.2.2.0 (MatthewMirman)
04:23:43 <cocreature> cpp  stands for C PreProcessor
04:23:54 <cocreature> not sure what a cpp compiler pass is supposed to be
04:24:17 <merijn> magneticduck: This is why it's always called cxx
04:24:34 * magneticduck is pretty sure CPP can also mean C++, in some contexts
04:24:38 <merijn> magneticduck: i.e. the C++ variant of $CC in make/etc. is $CXX, not $CPP
04:26:09 <bernalex> people who name their c++ files .h and .c are awful people
04:26:47 <bernalex> .cpp is also not nice because of the cpp. .hxx and .cxx are otoh pretty foolproof.
04:27:15 <cocreature> well nobody uses files exclusively for preprocessing them so cpp is not that bad imho
04:28:11 <magneticduck> in my experience with large C++ projects *.cxx files usually contain generated code
04:28:57 <magneticduck> .. to make matters slightly more confusing
04:29:03 <bernalex> magneticduck: code is code, so I'd like those to have the same filename. and generated code isn't in src/include (IME, at least), so it's distinguishable by that.
04:29:14 * bernalex >>= run
04:31:33 <magneticduck> then there are also *.txx, *.tpp, *.ii, *.ixx, *.inl, etc
04:32:01 <magneticduck> I personally perfer *.cp and *.hp
04:32:11 <magneticduck> prefer*
04:47:35 <nkaretnikov`> I have a derived Read instance, so I can use read for parsing, but it gives a non-informative error on failure. Is there a parser that's capable of reusing my Read instance as well as giving a helpful error message on failure?
04:55:59 <merijn> Not really, I think?
04:56:07 <merijn> Also, note that the performance of Read is AWFUL
04:57:19 <maerwald> it's only useful for simple things really
04:57:35 <maerwald> if you are that far that you need to understand error messages, you probably need a real parser
05:58:31 * hackagebot wuss 1.1.0 - Secure WebSocket (WSS) clients  https://hackage.haskell.org/package/wuss-1.1.0 (fozworth)
06:08:29 <nkaretnikov`> is there anything like haskell-src-meta but with better error msgs?
06:08:31 * hackagebot intero 0.1.16 - Complete interactive development program for Haskell  https://hackage.haskell.org/package/intero-0.1.16 (ChrisDone)
06:09:16 <nkaretnikov`> basically, i want some parser capable of parsing haskell exprs with nice error messages
06:41:33 <runeks> Does it make sense to use "bracket" to have a thread signal when it's done, like this? http://lpaste.net/169161
06:42:37 <runeks> Does "bracket" guarantee that the allocated resource is no longer in use by the main thread when the cleanup action runs?
06:44:06 <hpc> :t bracket
06:44:08 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:44:21 <runeks> I want to dump a map to disk before my program shuts down. So I want to make sure all threads are done using the map when I start reading the contents and writing to disk.
06:45:23 <hpc> bracket is very generic, and can't really do much to dictate what happens with the 'a' you have opened
06:45:55 <hpc> for instance the (a -> IO b) action could be to store it in an IORef, or to fork a thread that keeps using it
06:46:04 <hpc> you'll have to do the blocking and such yourself
06:46:05 <runeks> hpc: That's why I put an MVar in the cleanup action, thereby (hopefully) knowing that the thread accessing 'a' has exited.
06:46:31 <hpc> er, the (a -> IO c)
06:47:06 <runeks> second argument
06:47:18 <hpc> yeah, you'd have the cleanup action do anything appropriate to finish the action
06:47:29 <runeks> bracket init cleanup mainThread = ...
06:47:30 <hpc> since in some sense you've also allocated threads during this action
06:47:51 <hpc> you might want to have your open action return a tuple of the threads and the resource
06:48:00 <runeks> hpc: Bu can I be sure that it only runs *after* the main thread? Do you know?
06:48:02 <hpc> just to make it look right
06:49:10 <hpc> the cleanup action is executed after the between action is finished executing, or if an exception is thrown
06:49:23 <hpc> if an exception was thrown, bracket rethrows it after cleanup
06:49:26 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception.html#v:bracket
06:49:43 <pavonia> Isn't the main thread always the last to run?
06:49:59 <pavonia> s/run/finish/
06:50:29 <hpc> mainThread there isn't an actual thread, just an action passed to bracket
06:50:48 <hpc> which presumably is running in the main thread
06:51:07 <hpc> but the main thread continues executing after mainThread terminates, if only because it runs cleanup in the same thread
06:53:59 <hpc> the usual caveats of multithreading apply, if you fork a bunch of stuff and then don't wait, the bracket will easily finish first and close resources currently in use
06:56:22 <MrDetonia> is there a way to break from a 'forever' action, or do I have to define the recursion myself for that?
06:56:26 <ajf> So, `ReadS a` gives you a `[(a, String)]`, right? Why is it a list rather than a `Maybe`?
06:56:58 <hpc> MrDetonia: exceptions, but you usually just want to do something different from forever
06:57:02 <hpc> since forever is forever
06:57:08 <hpc> and forever is a long time
06:57:12 <MrDetonia> true
06:57:15 <srhb> MrDetonia: There's an untilM that might be useful.
06:57:24 <srhb> MrDetonia: In monad-loops.
06:57:27 <MrDetonia> oh okay.. so until some condition is met?
06:57:34 <srhb> :t untilM
06:57:35 <hpc> @hoogle untilM
06:57:36 <lambdabot>     Not in scope: ‚ÄòuntilM‚Äô
06:57:36 <lambdabot>     Perhaps you meant ‚Äòuntil‚Äô (imported from Prelude)
06:57:38 <srhb> Aw
06:57:38 <lambdabot> No results found
06:57:39 <ajf> Should I just assume it always returns either [] or [(valueIWant, someString)]
06:57:40 <hpc> :(
06:57:50 <ajf> or will ReadS sometimes give me multiple items?
06:57:56 <maerwald> lambdabot should have a hayoo plugin
06:58:24 <MrDetonia> final question, can I define some code that will always run when a thread is killed?
06:58:27 <hpc> ajf: a successful parse is a value that matches the pattern [(value, "")]
06:58:27 <srhb> maerwald: Or just have a definable set for hoogle.haskell.org
06:58:31 <MrDetonia> something to close off any handles, etc.
06:58:37 <srhb> http://hoogle.haskell.org/?hoogle=untilM&scope=set%3Astackage -- it's there.
06:58:50 <hpc> [] is a failed parse, lists greater than one element are ambiguous parses, and if the string is non-empty there's trailing garbage
06:59:03 <ajf> ah.
06:59:10 <ajf> oh, I see, the string is the remainder
06:59:19 <ajf> so I should just match for [(someValue, "")]
06:59:26 <ajf> and if it's anything else, assume something went wrong
06:59:28 <maerwald> srhb: that's limited to stack
06:59:37 <ajf> (my use case is readDec)
06:59:47 <hpc> yeah
06:59:59 <ajf> cool, thanks
07:00:05 <hpc> usually you don't need to get that complicated with Read instances, you might be better off with regular old parsing
07:00:28 <ajf> ‚Äúregular old parsing‚Äù?
07:00:37 <hpc> parsec and friends
07:00:48 <srhb> maerwald: I'm aware.
07:01:00 <hpc> oh wait, readDec is simple
07:01:04 <ajf> it is
07:01:53 <hpc> yeah, you're fine with just the one match
07:02:20 <hpc> also fwiw, i have never encountered a scenario where it's possible to get ambiguous parses
07:02:38 <ajf> it didn't seem like something likely to happen
07:02:41 <hpc> but that's how the result is defined, and it's not strictly impossible so good to know anyway ;)
07:02:44 <hpc> yeah
07:03:33 * hackagebot octane 0.13.2 - Parse Rocket League replays.  https://hackage.haskell.org/package/octane-0.13.2 (fozworth)
07:20:09 <LKoen> sometimes I wonder if the makers of haskell were thinking "hey, let's use complicated mathematic names to describe syntactic sugar"
07:20:31 <Iceland_jack> LKoen: It can sometimes feel like that :)
07:20:49 <Iceland_jack> but the mathematics helps you pick the right 'sugar'
07:21:11 <umib0zu> LKoen‚Ä¶ uh I think it‚Äôs the other way around. The syntactic sugur is defined by complicated mathatematical constructs
07:21:38 <umib0zu> the syntactic sure isn‚Äôt ‚Äúdescribed‚Äù by complicated mathematics. it‚Äôs defined by it.
07:21:44 <umib0zu> sugar**
07:22:15 <quchen_> Do-notation is syntactic sugar. There is no do-notation in mathematics.
07:22:37 <ajf> Haskell is just syntactic sugar over the lambda calculus.
07:22:39 <ajf> Mostly.
07:22:41 <ajf> :p
07:22:58 <quchen_> Nested patterns are syntactic sugar. I don‚Äôt know a branch of mathematics that deals with that either.
07:23:20 <umib0zu> quchen_ but do-notation is syntactic sugar over monads
07:23:31 <quchen_> Monads are not syntactic sugar.
07:23:49 <umib0zu> quchen_ that‚Äôs not what I said. I said do-notation is syntactic sugar
07:24:05 <quchen_> The claim was that Haskell has sugar defined by complicated mathematical structures. That claim is false, because the sugar part is not what is also in mathematics.
07:24:06 <umib0zu> quchen_ what do you mean by nested patterns by the way?
07:24:22 <quchen_> Just (1,x) -> x
07:24:34 <umib0zu> so‚Ä¶. ‚Äúdo-notation‚Äù (sugar) isn‚Äôt defined by monads (complicated mathematics)?
07:24:45 <quchen_> As opposed to "Just x", which is a single level
07:25:22 <hpc> do-notation is three distinct cases of source to source syntactic translation
07:25:33 <hpc> which happen to involve (>>=)
07:25:52 <umib0zu> well that‚Äôs another thing. what people call ‚Äúsyntactic sugar‚Äù is just syntax.
07:26:05 <hpc> with the rebindable syntax extension, the (>>=) which do-notation uses can be a different (>>=) from what Monad defines
07:26:55 <hpc> (the three cases are expression, pat <- expression, and let {bindings})
07:28:03 <hpc> @src Monad
07:28:04 <lambdabot> class Applicative m => Monad m where
07:28:04 <lambdabot>     -- Note: Applicative wasn't a superclass before GHC 7.10
07:28:04 <lambdabot>     (>>=)  :: m a -> (a -> m b) -> m b
07:28:04 <lambdabot>     (>>)   :: m a -> m b -> m b
07:28:04 <lambdabot>     return :: a -> m a
07:28:06 <lambdabot>     fail   :: String -> m a
07:28:09 <quchen_> ‚ÄúSyntactic sugar‚Äù is roughly what Haskell has over Core.
07:28:19 <hpc> that's the definition of Monad, which you would be pretty hard-pressed to describe as syntactic sugar
07:28:23 <hpc> unless Num and Eq are too
07:28:26 <umib0zu> well yeah but the argument I‚Äôm trying to make is that there exists plenty of syntactic patterns that are unwrapped into complicated math. the original point before we diverged into a discussion about case examples is that sugar is defined by some logical constructs so when someone is looking at sugar and people are giving them discriptions of complicated math, it‚Äôs because the sugar was designed to hide the math.
07:28:58 <umib0zu> what was said is that someone believes the sugar just exists and we‚Äôre being abstruse by explaining it with math. I‚Äôm trying to say that‚Äôs not true.
07:29:21 <umib0zu> most of the time the math was the original goal, but we added sugar to aid the programmer.
07:29:26 <umib0zu> hence do-notation
07:29:38 <umib0zu> yes I know you can break do-notation
07:29:42 <hpc> yeah, there's sort of layers of "defined by"
07:30:08 <hpc> do-notation is a direct response to the typical way in which Monad is used, but is technically speaking not directly dependent on Monad to function
07:30:39 <hpc> (monads are like ogres)
07:32:13 <anewnewbie> Hello, I just written a fair amount of code for a library but I haven't yet put in any documentation on the functions. Is there any tool which will autogenerate haddock stubs for my functions?
07:32:47 <maerwald> stubs?
07:33:04 <shapr> maerwald: empty stanzas that only need text filled in?
07:33:19 <anewnewbie> shapr:  Yes
07:33:20 <maerwald> I don't see how that makes sense wrt haddock.
07:33:25 <hpc> haddock doesn't really have any of the javadoc-style perfunctory stuff
07:33:33 <hpc> it's just text you put around the function definition
07:33:41 <anewnewbie> Mmmm
07:33:42 <dolio> What would a stub be? '-- |'?
07:33:47 <anewnewbie> :)
07:33:49 <dolio> You want a tool to add that to every function?
07:33:53 <hpc> if any documentation was required, it would be happening in-language
07:34:04 <hpc> *if any elements of documentation
07:34:50 <hpc> (in an ideal world, everything would be obvious just from type signatures)
07:35:20 <cheater> @src some
07:35:20 <lambdabot> some v = some_v
07:35:21 <lambdabot>   where many_v = some_v <|> pure []
07:35:21 <lambdabot>         some_v = (:) <$> v <*> many_v
07:35:24 <cheater> hm
07:35:28 <anewnewbie> Well, you're right. This doesn't make sense. Coming from the java world, I assumed that more information would be needed, but you're right.
07:36:06 <exio4> hpc: we haven't got dependent types... yet
07:36:11 <shapr> I still prefer lhs files for docs
07:36:14 <anewnewbie> Thanks hpc, shapr, maerwald and dolio.
07:36:31 <dolio> I don't think dependent types can replace comments.
07:36:35 <hpc> shapr: do you use "> " style lhs or tex style?
07:36:47 <dolio> I write paragraphs of comments sometimes. I don't want my types to be paragraphs long.
07:37:13 <cheater> what do you use some for?
07:37:30 <shapr> hpc: I like both, but TeX style is my fav
07:37:43 <hpc> cheater: matching zero or more things
07:38:06 <hpc> er, one or more things
07:38:19 <monochrom> I think there is crosstalk here. "doc" has two antipodal meanings: internal docs (explaining to maintainers) vs external docs (explaining to users).
07:38:24 <cheater> i don't get it
07:38:43 <monochrom> you would do lhs for internal docs, haddock for external docs
07:42:49 <maerwald> monochrom: what would you autogenerate for lhs?
07:43:16 <monochrom> I don't know. I haven't autogenerated code or doc
07:43:23 <cheater> hpc: could you elaborate please?
07:44:27 <arnabold> @pl and . fmap (\x -> x >= a && x <= b)
07:44:27 <lambdabot> and . fmap (liftM2 (&&) (>= a) (<= b))
07:44:58 <arnabold> @pl all (>= 0) xs && all (<= 8) xs
07:44:59 <lambdabot> all (>= 0) xs && all (<= 8) xs
07:45:32 <arnabold> @pl all (>= a) xs && all (<= b) xs
07:45:33 <lambdabot> all (>= a) xs && all (<= b) xs
07:47:09 <arnabold> @pl \xs -> all (>= a) xs && all (<= b) xs
07:47:09 <lambdabot> ap ((&&) . all (>= a)) (all (<= b))
07:48:40 <arnabold> @pl and . (((&&) <$> (>= a) <*> (<= b)) <$>)
07:48:40 <lambdabot> and . (((&&) <$> (>= a) <*> (<= b)) <$>)
07:48:56 <arnabold> @pl \a b -> and . (((&&) <$> (>= a) <*> (<= b)) <$>)
07:48:56 <lambdabot> (((and .) . (<$>) . ((&&) <$>)) .) . (. flip (<=)) . (<*>) . flip (>=)
08:05:19 <dinnu93> I'm unable to understand monad transformers I read a lot of blog posts but I still couldn't get my head around it
08:05:35 <dinnu93> Can somebody point me to a good resource ?
08:05:52 <Clint> what are you trying to do?
08:06:16 <dinnu93> Writing a lisp interpreter 
08:06:30 <dinnu93> so I need to use state monad under IO monad
08:06:37 <tdammers> *over
08:06:57 <tdammers> IO can't be a transformer, it can only sit at the bottom of the transformer stack
08:07:03 <tdammers> *BUT*
08:07:23 <tdammers> if you have to use IO anyway, StateT might not be the best choice
08:07:39 <dinnu93> tdammers: Thanks 
08:07:49 <tdammers> you can really just do with InterpreterState -> IO ()
08:08:02 <tdammers> and then make anything that needs to be mutable an IORef or MVar or something
08:08:27 <dinnu93> tdammers: ok
08:08:49 <dinnu93> tdammers: I'll try that
08:09:22 <tdammers> ReaderT InterpreterState IO () -- would also work
08:09:52 <tdammers> it's a matter of peppering your code with liftIO for IO actions vs. dragging along the extra argument everywhere
08:12:43 <dinnu93> tdammers: ok
08:14:06 <whittle> I‚Äôm having some trouble understanding execution order. I‚Äôm trying to get a PR merged in (https://github.com/frasertweedale/hs-jose/pull/15) and in regards to the line "(verifyJWS conf k jws &&) <$> validateClaimsSet conf c" the library author commented that, ‚ÄúClaims validation [validateClaimsSet] precedes signature validation [verifyJWS],‚Äùand that it, ‚Äúshould happen the other way around.‚Äù Can someone tel
08:14:06 <whittle> l me what I need to understand in order to figure out why the second part executes before the first part? 
08:18:36 * hackagebot lazy-search 0.1.1.0 - Finds values satisfying a lazy predicate  https://hackage.haskell.org/package/lazy-search-0.1.1.0 (JonasDuregard)
08:23:36 * hackagebot ghc-srcspan-plugin 0.2.2.0 - Generic GHC Plugin for annotating Haskell code with source  location data.  https://hackage.haskell.org/package/ghc-srcspan-plugin-0.2.2.0 (EricSeidel)
08:37:39 <adarqui> hey. i have a bunch of stuff i'm running inside of EitherT. For some things, I want to basically do something like: result <- (action1 <|> action2 <|> action3), but, I can't make this an instance of MonadPlus; it's Yesod's HandlerT App IO. action1/action2/action3 all result in (Either ApiError a).. any idea what I should do? it's almost as if I need a version of EitherT that keeps going if it sees a Left, and finishes once it gets a Right
08:38:36 * hackagebot cryptol 2.4.0 - Cryptol: The Language of Cryptography  https://hackage.haskell.org/package/cryptol-2.4.0 (AdamFoltzer)
08:42:11 <cobreadmonster> Hey guys.
08:42:32 <whittle> adarqui: Are you running the actions in parallel to see if any succeed? 
08:42:54 <adarqui> whittle: nah not parallel.. they are sequential
08:43:13 <whittle> But you do want the first one that succeed? 
08:43:23 <adarqui> ya
08:43:48 <adarqui> i might have up to 5 actions sequentially, and, i want the first one to succeed.. basically
08:44:16 <adarqui> im overlooking something simple perhaps.. but normally i'd be using smoething that supports <|>/mplus so i'd just use that
08:44:20 <adarqui> but i can't in this case
08:45:09 <whittle> adarqui: That sounds like the list monad. Put the actions in a list, filter the list for successes, and take the first one. 
08:46:13 <adarqui> cool thanks alot. i'll go experiment with that shortly
08:46:47 <whittle> np
08:48:37 * hackagebot hsyslog-udp 0.1.2 - Log to syslog over a network via UDP  https://hackage.haskell.org/package/hsyslog-udp-0.1.2 (jonplussed)
08:56:06 <ertes> hmm‚Ä¶  the 'entropy' library XORs the output of RDRAND directly with the output of /dev/urandom ‚Äì the same mistake the linux kernel was doing with a known exploit
08:57:06 <ertes> i'm responsible for that‚Ä¶  thomas trusted the RDRAND instruction *exclusively* when available, and after my complaint he changed it to XOR, but apparently even that is problematic
08:59:22 <whittle> adarqui: On second thought, I can‚Äôt see how filtering would actually work. I suspect a fold would be more appropriate. 
09:03:37 * hackagebot rest-types 1.14.1.1 - Silk Rest Framework Types  https://hackage.haskell.org/package/rest-types-1.14.1.1 (ErikHesselink)
09:06:57 <alaswat> Hi there
09:07:36 <alaswat> has any one read the "hello world" snippet in "The nightmare stacks" by Charles Stross?
09:07:49 <alaswat> I really recommend it to anyone who enjoys SciFi
09:12:32 <josephle> alaswat: tell us more about it in #haskell-offtopic
09:20:40 <mikail`> Hi, what is `pure` used for in the Applicative class?
09:20:48 <bollu> so, I've been playing stockfighter
09:20:53 <bollu> and I've ben writing the API using servant
09:20:58 <bollu> and I think it's lovely
09:21:12 <bollu> Is it okay if I publish my API bindings on hackage?
09:21:22 <bollu> the existing API bindings on hackage are immature somewhat
09:21:40 <bollu> I could name the package stockfighter-servant
09:21:44 <bollu> is that okay?
09:22:33 <Rotaerk_> mikail`, it just trivially wraps the value you provide
09:22:38 <Rotaerk_> "lifts" it into the applicative type
09:23:02 <mikail`> Rotaerk_: yes I see that; so in the Maybe instance pure = Just
09:23:02 <srhb> bollu: Why wouldn't it be? 
09:23:19 <Rotaerk_> mikail`, yea
09:23:20 <bollu> srhb: I don't know, maybe it's considered bad form to publlsh APIs?
09:23:23 <mikail`> since Just takes a type and lifts it
09:23:28 <srhb> bollu: It's not.
09:23:36 <bollu> srhb: okay, cool :)
09:23:37 <mikail`> but how would I use it?
09:23:53 <mikail`> in what context?
09:24:41 <Rotaerk_> mikail`, well applicative is an abstraction, so you can use it when you're writing code generically for all applicatives, for one thing
09:25:31 <bwe> Hi, I can't reproduce the session under "Let's play around with the Maybe type." http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-parameters --> http://lpaste.net/7167252002622144512
09:26:29 <mikail`> Rotaerk_: I see, so if I wrote generic code and then passed in a Maybe type it would know to use "Just" to lift the a value
09:26:49 <c_wraith> bwe, that looks like the session is with the library Maybe type 
09:27:17 <c_wraith> bwe, which has a bunch of helpful instances in addition to the basic data definition 
09:27:49 <c_wraith> bwe, I think the definition of the type listed is mostly for illustration, not intended to be copied. 
09:28:08 <bollu> guys, what's the difference between EitherT and ExceptT?
09:28:15 <bollu> when does one use one over the other?
09:30:22 <Rotaerk_> mikail`, yep, and if you passed in a [], then it'd wrap the value into a singleton list for pure
09:31:20 <mikail`> Rotaerk_: thanks for clearing that up
09:31:46 <Boomerang> > let f a = (+3) <$> a in (f (Just 2), f (Right 5), f [2,3,4]) -- Check this out mikail`
09:31:47 <lambdabot>  (Just 5,Right 8,[5,6,7])
09:31:57 <Rotaerk_> I *think* the implementation for pure is generally the same as the implementation for monadic return
09:32:31 <josephle> bollu: AFAICT there is no difference (reference: https://github.com/Gabriel439/Haskell-Errors-Library/issues/32)
09:32:42 <Rotaerk_> as they both are supposed to trivially lift the value
09:33:17 <josephle> bollu: so practically speaking their only differences are in their package dependency graphs
09:33:25 <bollu> josephle: thanks
09:33:49 <joeyh> I was just stracing a haskell binary, and I noticed it tries to open 9000 haskell dynamic libraries. This is despite it being statically linked to all the haskell libs.
09:33:58 <joeyh> seems to only happen when the binary is built with cabal, not ghc --make
09:34:55 <mikail`> Boomerang: is that monadic application?
09:35:48 <joeyh> hmm, I'll bet it's because cabal is passing -lHSfoo for every dependency
09:35:54 <mikail`> I can't see how pure has been used there. I know what the code is doing but the instance definitions don't tell me how it arrived to that
09:36:30 <Rotaerk_> mikail`, that's applicative... application
09:37:00 <mikail`> Rotaerk_: I can't see the <$> defined in the applicative type class
09:37:22 <Rotaerk_> it's not within the typeclass itself; it's defined within the applicative module though, in-terms-of the applicative class
09:37:46 <Rotaerk_> it's actually just a synonym for fmap (so it's really something that works for all functors)
09:37:51 <Rotaerk_> not just applicatives
09:38:38 * hackagebot ip 0.8 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.8 (andrewthad)
09:38:40 * hackagebot PortMidi 0.1.6.1 - A binding for PortMedia/PortMidi  https://hackage.haskell.org/package/PortMidi-0.1.6.1 (PaulLiu)
09:38:59 <mikail`> Rotaerk_: ok but in Boomerang's example, I can't see how pure was used 
09:40:00 <Rotaerk_> mikail`, it's not; not really sure what their point was
09:40:26 <mikail`> Rotaerk_: ok great, I thought I was missing something there
09:40:31 <Rotaerk_> benzrf, hmm I used "their" for a specific person; it sounds so weird
09:40:53 <benzrf> Rotaerk_: stay salty
09:40:57 <Rotaerk_> lol
09:41:33 <Boomerang> oh yeah, I thought it was about applicative in general not just pure
09:42:08 <Rotaerk_> thing is you didn't even use applicative features, Boomerang 
09:42:25 <Rotaerk_> only functor features
09:45:23 <Boomerang> > let f a = pure (+3) <*> a in (f (Just 2), f (Right 5), f [2,3,4])
09:45:24 <lambdabot>  (Just 5,Right 8,[5,6,7])
09:46:59 <lpaste> woffs pasted ‚Äúwrap IO in a transformer to avoid that "case" stairs?‚Äù at http://lpaste.net/3653975527657570304
09:48:43 <bwe> c_wraith: Okay, I'll skip this part for the time being. When I should use Maybe is not 100% clear for me.
09:49:08 <monochrom> yes woffs, it is possible to use EitherT for that.
09:49:33 <monochrom> hmm, is EitherT deprecated? should we go ErrorT instead?
09:50:03 <woffs> monochrom, can I get rid of "try"?
09:50:12 <monochrom> no
09:50:43 <woffs> so I have to wrap try into EitherT
09:50:49 <monochrom> actually I think your "try" is too inside, not outside enough.
09:51:10 <woffs> monochrom, that's a good hint
09:51:37 <c_wraith> bwe, don't skip it. just don't define your own data type, since you don't need to. 
09:51:40 <monochrom> you should just wrap one single "try" outermost. then there is only one pattern-matching to do, and you don't need to bring in the big gun of ErrorT
09:51:51 <woffs> yeah
09:52:12 <c_wraith> bwe, as far as when to use Maybe.. it's is simple as "when you might not have a value" 
09:52:25 <woffs> thanks monochrom, I'll give it a, hm, try
09:52:57 <monochrom> \‚à©/
10:01:20 <bwe> c_wraith: I do understand "either it has a value or not". I do not understand what  Just  does in this.
10:01:38 <bwe> c_wraith: data Maybe a = Nothing | Just a
10:02:43 <quchen_> Just is the tag the value has to distinguish it from the Nothing tag, which says there is no value.
10:02:45 <monochrom> "Just" tells you you are not in the "Nothing" case.
10:03:56 <monochrom> "data Maybe a = Nothing | Just a" is saying: there are two cases, therefore you need two different constructors to indicate which case you're in, therefore you need two different names.
10:04:38 <ajf> what's the shortest way to concatenate two Texts?
10:04:42 <quchen_> <>
10:04:48 <quchen_> :t (<>)
10:04:49 <lambdabot> Monoid m => m -> m -> m
10:04:55 <ajf> Ah, neat. Thanks.
10:05:00 <LKoen> bwe: do you mean you would have expected it to be "data Maybe a = Nothing | a" ?
10:05:22 <LKoen> that wouldn't really work because when presented with a value of type a, you wouldn't know whether it should be a Maybe a or just an a
10:05:34 <LKoen> so 'Just' is a constructor to tell you we're in Maybe
10:05:51 <ajf> wait, where's (<>) defined?
10:05:55 <quchen_> Data.Monoid
10:05:58 <quchen_> And Data.Semigroup
10:06:04 <bwe> LKoen: a can itself be a Maybe?
10:06:07 <quchen_> Monoid traditionally
10:06:29 <LKoen> bwe: we can't allow *any type* to be able to get replaced by Nothing
10:06:53 <LKoen> otherwise all functions we'd ever implement would have to deal with the possibility of a Nothing popping up as one of the argument
10:06:54 <monochrom> for greatest self-consistency, there are only two logically sensible designs. one is "data Maybe a = | a". the other is "data Maybe a = C1 | C2 a". either having constructors for all cases, or having no constructors for all cases.
10:07:45 <LKoen> for instance, if you're writing a function that expects an int, it should only be able to receive an int, not "an int or Nothing"
10:08:06 <LKoen> unless you've explicitely written your function to expect a Maybe Int
10:08:21 <bwe> LKoen: Then it's okay if it receives Nothing or Int
10:08:41 <LKoen> no
10:08:57 <LKoen> then it's okay if it receives Nothing or Just (something)
10:09:09 <LKoen> because you have told it to expect a Maybe Int, not an Int
10:09:19 <monochrom> bwe, you need to know https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
10:09:58 <quchen_> You wouldn‚Äôt expect a functio that takes a `[a]` as argument to take a simple `Int` in case there‚Äôs only one element in the list, would you?
10:10:45 <lpaste> woffs pasted ‚Äúmonochrom, here is the result. works great. thank you! :-)‚Äù at http://lpaste.net/2498284194346565632
10:11:04 <quchen_> One way to look at Maybe is that it‚Äôs the type of lists of at most one element. :-)
10:11:12 <bwe> I appreciate that three people try to help in parallel. However, trying to grasp three understandings at a time, well, is hard ;).
10:12:02 <bwe> LKoen: So, what's the point in specifying Int with Maybe Int, if the function expects Nothing or Just (something) (where Int is missing)?
10:12:20 <LKoen> by (something) I meant a value
10:12:26 <LKoen> like Just 3 or Just 5
10:12:35 <LKoen> which is of type Maybe Int
10:12:54 <LKoen> so you're function expects its argument to be Nothing or Just 3 or Just 5
10:12:59 <LKoen> but not 3 or 5
10:13:31 <bwe> LKoen: Why not 3 or 5? (I did not get the difference of Just 3 vs. 3 yet)
10:14:35 <sleblanc> bwe, it makes sense to a function to accept a value of type Maybe only if it can do something meaningful in both cases
10:14:41 <LKoen> 3 is of type Int, Just 3 is of type Maybe Int
10:14:43 <LKoen> that's the difference
10:15:09 <LKoen> we want to be able to make a distinction between Int and Maybe Int
10:16:05 <LKoen> I think what you would like to do would be some kind of "implicit cast" where a Maybe Int could be fed to a function expecting an Int if it's not Nothing
10:16:21 <LKoen> but haskell has very strong typing
10:16:26 <bwe> data Maybe = Nothing | Just a    -- expects something of type Maybe. 
10:16:32 <LKoen> so I don't think you can do that implicitely
10:16:45 <sleblanc> data Maybe a*
10:17:09 <LKoen> but if you're willing to do it explicitly, you'll be ok :)
10:19:38 <mizu_no_oto_work> bwe: as a slightly more foundational question: do you understand what Algebraic Data Types are?
10:19:57 <mizu_no_oto_work> i.e. do you understand what the data keyword does?
10:20:28 <mizu_no_oto_work> since that's probably a good place to start from, if you don't
10:20:31 <monochrom> I actually thought of asking that. But then perhaps we start with Maybe as an example before we look at ADT generally, so the question is moot.
10:21:10 <bwe> mizu_no_oto_work: that comes on pages 126ff, I am stuck on page 118.
10:21:37 <mizu_no_oto_work> bwe: Which other programming languages do you know?
10:21:52 <bwe> mizu_no_oto_work: Python, bash, awk.
10:22:13 <bwe> | differentiates different values in   data Bool = False | True
10:22:44 <haskell522> anyone here?
10:22:47 <chpatrick> bwe: that says that something of type Bool has either the value False or the value True
10:22:58 <bwe> chpatrick: Which I do understand.
10:23:12 <hpc> haskell522: this channel is full, try #haskell-2-electric-boogaloo
10:23:22 <chpatrick> bwe: ok, so these values can also carry other values
10:23:22 <haskell522> hey.. I wanna ask something
10:23:27 <ertes> bwe: "Maybe A" conceptually is like "A with a distinct, additional value called Nothing"
10:23:28 <hpc> :P
10:23:32 <chpatrick> bwe: data Foo = FooInt Int | FooString String
10:23:35 <chpatrick> bwe: ok so far?
10:24:01 <chpatrick> so it can be a FooInt with an Int, or a FooString with a String
10:24:03 <ertes> bwe: where you write values of type A as "x", you write values of type Maybe A as "Just x", and there is this distinct value called "Nothing"
10:24:32 <monochrom> consider "data Y = GoLeft Int | GoRight Int"
10:24:33 <mizu_no_oto_work> haskell522: If you have a question, just ask.
10:24:49 <cheater> can someone tell me what "some" is for?
10:24:51 <cheater> i don't get it
10:25:24 <bwe> chpatrick: Yep.
10:25:29 <ertes> cheater: you may know "some" as "many1" from some parser libraries
10:25:32 <mizu_no_oto_work> haskell522: generally on IRC, "don't ask to ask, just ask"
10:25:33 <chpatrick> bwe: ok, so you can also parameterize these types
10:25:44 <chpatrick> bwe: data Foo a = Foo a
10:25:49 <haskell522> thanks. i have a question about Applicative instance for my Vector data
10:25:55 <chpatrick> so Foo String has a String, and Foo Int has an Int
10:26:02 <srhb> haskell522: Ask. ;-)
10:26:07 <chpatrick> like a function has a parameter, a type can have a parameter too
10:26:14 <cheater> right i know it from attoparsed but... why is "some" in the prelude?
10:26:23 <chpatrick> cheater: it's from Control.Applicative
10:26:34 <chpatrick> you can generalize the concept to anything that's Alternative
10:27:14 <haskell522> so i made my own vector data : data Triple a = V a a a
10:27:14 <bwe> chpatrick: That's clear. However, ghci> Foo Int raise an error
10:27:24 <chpatrick> bwe: because it's a type, not a value
10:27:31 <chpatrick> try Foo 3 :: Foo Int
10:27:43 <quchen_> ‚Äúsome‚Äù and ‚Äúmany‚Äù should not be in Alternative. Luckily, not many rely on those historical mistakes. They cannot be implemented for all Alternatives.
10:27:54 <mizu_no_oto_work> haskell522: The easiest way to get help on IRC is just to type out your question in full (possibly using lpaste if you have a long error message or code), and if anyone knows enough to respond they generally will
10:28:10 <bwe> chpatrick: data Foo a = Foo a deriving (Show)
10:28:25 <bwe> Foo 3 :: Foo Int results Foo 3
10:28:35 <chpatrick> bwe: so now you've got a datatype with one constructor, which contains a value of type a
10:28:41 <chpatrick> does it make sense so far?
10:29:15 <chpatrick> you could also do data Foo a = FooInt Int | FooA a
10:29:41 <bwe> Here I am stuck.
10:29:56 <chpatrick> bwe: all this says is that a value of type Foo a
10:30:02 <chpatrick> can either be a FooInt with an Int
10:30:07 <chpatrick> or a FooA with an a
10:30:19 <chpatrick> same as how Bool can be either False or True
10:30:22 <chpatrick> except with some extra data
10:30:35 <bwe> data Foo a = Foo a  <-- what's "a" here? (sorry for going back to the first point which I don't get)
10:30:51 <chpatrick> bwe: a is a type parameter
10:31:10 <chpatrick> so it's a regular old type like Int or String
10:31:16 <bwe> chpatrick: so if I do  Foo 3    then 3 is not a type, it's a value of type Int.
10:31:17 <chpatrick> the only difference is that you can choose which one you want
10:31:22 <chpatrick> bwe: right!
10:31:41 <Iceland_jack>     Foo :: a -> Foo a
10:31:41 <Iceland_jack> also
10:31:42 <Iceland_jack>     Foo :: Int  -> Foo Int
10:31:42 <Iceland_jack>     Foo :: Bool -> Foo Bool
10:32:00 <mizu_no_oto_work> bwe: The one tricky thing there is that with 'data Foo a = Foo a', Foo exists in two namespaces
10:32:12 <mizu_no_oto_work> bwe: Foo Int exists in the namespace of types
10:32:20 <Iceland_jack> It's common to write
10:32:20 <Iceland_jack>     data Foo a = MkFoo a
10:32:20 <Iceland_jack> to avoid that confusion
10:32:24 <Iceland_jack>     MkFoo :: a -> Foo a
10:32:33 <mizu_no_oto_work> while Foo 3 exists in the namespace of values
10:32:50 <haskell522> i build my own data as "data Triple a = V a a a" where it takes 3 numbers as Vector representation. and i wanna write the Applicative instance for it. but i confused since "pure" only takes 1 parameter and vector must have 3 numbers  
10:33:04 <Iceland_jack> haskell522: Well there is only one way to write it :)
10:33:14 <ertes> haskell522: Applicative for that type basically does zipWith
10:33:17 <Iceland_jack>     pure :: a -> Triple a
10:33:17 <Iceland_jack>     pure x = V x x x
10:33:20 <ertes> haskell522: so 'pure' is 'repeat'
10:33:40 <bwe> Okay. So what does   Foo 3 :: Foo Int   do?
10:33:57 <bwe> Foo 3 -- here Foo is in the namespace of values, right?
10:34:00 <Iceland_jack> @let data Foo a = MkFoo a deriving Show
10:34:01 <lambdabot>  Defined.
10:34:06 <Iceland_jack> > MkFoo 3 
10:34:08 <chpatrick> bwe: it's a value of type Foo Int
10:34:08 <lambdabot>  MkFoo 3
10:34:17 <chpatrick> bwe: and it's value is Foo 3
10:34:17 <mizu_no_oto_work> bwe: to start out with, '::' is used  for type ascriptions, where you're saying that a value has a given type
10:34:27 <mizu_no_oto_work> like "3 :: Double"
10:34:31 <LKoen> :t MkFoo 3
10:34:33 <lambdabot> Num a => Foo a
10:34:47 <haskell522> that's what i heard by using repeat but i don't know what that means
10:34:48 <LKoen> :t MkFoo 3 :: MkFoo Int
10:34:49 <lambdabot>     Expected a type, but ‚ÄòMkFoo Int‚Äô has kind ‚ÄòFoo *‚Äô
10:34:49 <lambdabot>     In an expression type signature: MkFoo Int
10:34:49 <lambdabot>     In the expression: MkFoo 3 :: MkFoo Int
10:34:58 <LKoen> oops
10:35:12 <Iceland_jack> > MkFoo 10 :: Foo Float
10:35:14 <lambdabot>  MkFoo 10.0
10:35:46 <bwe> mizu_no_oto_work: so left of the :: is the value, right is the type.
10:36:06 <quchen_> The other way round.
10:36:09 <mizu_no_oto_work> bwe: exactly
10:36:14 <chpatrick> bwe: that's right
10:36:27 <bwe> Foo 3 :: Foo Int    -- here value "Foo 3" has the type "Foo Int"
10:36:32 <quchen_> Woops, ignore me, I‚Äôll show myself out.
10:36:36 <quchen_> :-s
10:36:52 <chpatrick> bwe: you could also do Foo True :: Foo Bool
10:36:56 <bwe> >MkFoo 10 :: Foo Double
10:37:03 <bwe> > MkFoo 10 :: Foo Double
10:37:05 <lambdabot>  MkFoo 10.0
10:37:09 <bwe> > MkFoo 10 :: Foo Int
10:37:10 <lambdabot>  MkFoo 10
10:37:25 <bwe> > Foo True :: Foo Bool
10:37:26 <lambdabot>  Not in scope: data constructor ‚ÄòFoo‚Äô
10:37:33 <chpatrick> > MkFoo True :: Foo Bool
10:37:35 <lambdabot>  MkFoo True
10:38:53 <bwe> Okay. What's the next step I need to comprehend?
10:39:12 <buglebud_> .
10:39:16 <chpatrick> bwe: so you can have multiple constructors right?
10:39:16 <Iceland_jack> bwe: What's the goal? Do you understand
10:39:17 <Iceland_jack>     data Maybe a = Nothing | Just a
10:39:26 <chpatrick> > Just True :: Maybe Bool
10:39:27 <lambdabot>  Just True
10:39:30 <chpatrick> > Nothing :: Maybe Bool
10:39:32 <lambdabot>  Nothing
10:39:37 <ajf> How do I do something in a Monad if some Maybe is a Just, or do nothing otherwise?
10:39:50 <chpatrick> :t traverse
10:39:51 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:39:53 <Iceland_jack> ajf: for_
10:40:01 <Iceland_jack> or traverse (traverse_)
10:40:11 <ajf> Iceland_jack: oh, right, of course, I forgot that worked on `Maybe`s
10:40:14 <Iceland_jack>     traverse_ print (Just 10)
10:40:22 <bwe> Iceland_jack: My goal is to understand  data Maybe a = Nothing | Just a
10:40:31 <chpatrick> bwe: what do you think it means?
10:41:11 <Iceland_jack> bwe: When we define 'data Maybe a = Nothing | Just a' we get two constructors
10:41:11 <Iceland_jack>     Nothing ::      Maybe a
10:41:11 <Iceland_jack>     JUst    :: a -> Maybe a
10:41:18 <Iceland_jack> *Just
10:41:24 <bwe> chpatrick: Good question ;).  Value of type Maybe may be Nothing or Just a
10:41:45 <mizu_no_oto_work> bwe: that's correct
10:42:13 <bwe> Nothing is "nothing". Just a is whatever "a" is for a value. 
10:42:17 <chpatrick> bwe: so what is the problem?
10:42:21 <bwe> So, Just 3 is 3.
10:42:30 <bwe> The problem is, that this is not precisely true.
10:42:32 <chpatrick> bwe: Just 3 is Just 3
10:42:38 <bwe> Exactly.
10:42:39 <chpatrick> there's nothing special going on
10:42:47 <chpatrick> Bool is either True or False
10:42:52 <chpatrick> Maybe a is either Nothing or Just a
10:42:55 <SamuraiChinpo> ertes: so what do you mean is pure = repeat?
10:42:56 <bwe> I don't understand why do I need Just 3 if it can only be 3.
10:43:07 <Iceland_jack> That's a good question
10:43:20 <chpatrick> bwe: you use Maybe if you want to have the possibility of a missing value
10:43:26 <chpatrick> in Python everything is a Maybe by default
10:43:28 <bwe> That's clear.
10:43:40 <Iceland_jack> We want to distinguish a value (3) and a value that may not be there (Just 3)
10:43:41 <chpatrick> in Haskell by default there are never missing values
10:43:58 <chpatrick> if you want to allow for missing values, you need this extra data structure on top, Maybe
10:43:59 <bwe> because it's a type driven language.
10:44:02 <ertes> bwe: when you read a "data" declaration, it defines all the possible shapes a value of that type can be in‚Ä¶  "3" is in fact syntactic sugar, but there is no such sugar (by default) for "Maybe Int"
10:44:02 <Iceland_jack> > find even [1,3,5,7]
10:44:03 <lambdabot>  Nothing
10:44:15 <Iceland_jack> > find odd [1,3,5,7]
10:44:17 <lambdabot>  Just 1
10:44:33 <bwe> Iceland_jack: Ah!
10:44:36 <ertes> bwe: if you're worried about having to type a lot, don't worry‚Ä¶  you almost certainly won't have to =)
10:45:05 <mayhew> bwe: functions need to be able to return a value that says that it was unable to produce a computation for that given input
10:45:06 <bwe> Iceland_jack: Just 1 means, the value *could* possibly be Nothing.
10:45:13 <chpatrick> bwe: no
10:45:25 <chpatrick> Maybe Int means that it could be Nothing or Just + an Int
10:45:26 <bwe> chpatrick: Why not?
10:45:27 <Iceland_jack> We don't know until we pattern match
10:45:35 <chpatrick> if you have a value Just 1, it's definitely Jus t1
10:45:51 <Iceland_jack>     case find even [1,3,5] of
10:45:51 <Iceland_jack>       Nothing -> putStrLn "ERROR: No even number found!"
10:45:51 <Iceland_jack>       Just n  -> print n
10:45:52 <ertes> SamuraiChinpo: a value of type "F a" contains multiple 'a'‚Ä¶  and "repeat" is by convention a function that makes them all equal
10:45:52 <mizu_no_oto_work> bwe: Maybe Int means it could be nothing; Just 1 means it wasn't Nothing
10:46:02 <ertes> SamuraiChinpo: pure x = F x x x
10:46:22 <bwe> mizu_no_oto_work: But there is a condition defined wherein it could have been Nothing.
10:46:29 <bwe> mizu_no_oto_work: Right?
10:46:29 <ajf> a Maybe is either a Just or a Nothing
10:46:36 <ajf> if it's a Just, it's a Just
10:46:41 <ajf> if it's a Nothing, it's a Nothing
10:46:55 <Iceland_jack> bwe: The important part, in other languages we could write something like
10:46:55 <Iceland_jack>     10000 * find even [1,3,5] 
10:46:55 <ertes> SamuraiChinpo: and it's the only possible 'pure' anyway
10:47:10 <SamuraiChinpo> :ertes but it will be become the same thing isn't it? example: pure 10 F 10 10 10
10:47:14 <mayhew> bwe: doubleEven :: Maybe Int could return Nothing if it was given an odd number. Otherwise what would you return?
10:47:32 <Iceland_jack> But in Haskell that doesn't compile, since the left side is (10000 :: Int) and the right side is (find even [1,3,5] :: Maybe Int)
10:47:36 <Iceland_jack> so the types don't match
10:48:00 <bwe> Iceland_jack: Then make them match: 10000 :: Just Int
10:48:16 <mizu_no_oto_work> bwe: that won't compile
10:48:21 <Iceland_jack> You mean (10000 :: Maybt Int)
10:48:22 <Iceland_jack> *Maybe
10:48:25 <bwe> > Just 2 * find even [1,3,5]
10:48:26 <lambdabot>      No instance for (Show a0)
10:48:27 <lambdabot>        arising from a use of ‚Äòshow_M471122243398291595311570‚Äô
10:48:27 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
10:48:44 <bwe> > (Just 2) * find even [1,3,5]
10:48:46 <lambdabot>      No instance for (Show a0)
10:48:46 <lambdabot>        arising from a use of ‚Äòshow_M128887879039612809711593‚Äô
10:48:46 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
10:48:58 <Iceland_jack> bwe: If we assume nothing, we have to write
10:48:58 <Iceland_jack>     case find even [1,3,5] of
10:48:58 <Iceland_jack>       Nothing -> Nothing
10:48:58 <Iceland_jack>       Just n  -> 10000 * n
10:49:04 <Iceland_jack> This makes the error explicit
10:49:57 <bwe> When want I to use Just?
10:50:20 <Iceland_jack> :t lookup
10:50:22 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
10:50:29 <ertes> SamuraiChinpo: yes
10:50:31 <Iceland_jack> short answer, when something can fail
10:50:50 <Iceland_jack> > lookup "bob" [("bob", 42), ("alice", 61)]
10:50:51 <lambdabot>  Just 42
10:51:03 <bwe> Iceland_jack: So, is Maybe then used to cover weak programmed code?
10:51:09 <mizu_no_oto_work> bwe: You know how in python, if you have a class it can be null, but if you have an int or another primitive, it can't?
10:51:18 <Iceland_jack> I wouldn't say that
10:51:26 <ertes> bwe: haskell has no 'null' value like most other languages, and "error values" (like in C) are highly discouraged
10:51:31 <SamuraiChinpo> :ertes then it's a wrong Vector (?) 
10:51:36 <chpatrick> bwe: it's not about weak programming, sometimes theres just isn't an answer
10:51:49 <chpatrick> :t findIndex
10:51:50 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
10:51:56 <chpatrick> :t elemIndex
10:51:57 <lambdabot> Eq a => a -> [a] -> Maybe Int
10:52:04 <chpatrick> elemIndex 3 [ 1, 2, 3 ]
10:52:05 <ertes> SamuraiChinpo: is it?  the only valid definition for 'pure x' is 'V x x x'
10:52:09 <mizu_no_oto_work> bwe: That's really a bad rule, because you can sometimes have a missing int and you can have cases where classes simply have to be there
10:52:12 <chpatrick> > elemIndex 3 [ 1, 2, 3 ]
10:52:13 <lambdabot>  Just 2
10:52:14 <ertes> SamuraiChinpo: try to write a different 'pure'
10:52:17 <chpatrick> > elemIndex 42 [ 1, 2, 3 ]
10:52:19 <lambdabot>  Nothing
10:53:13 <ertes> @let msqrt x = if x < 0 then Nothing else Just (sqrt x)
10:53:15 <lambdabot>  Defined.
10:53:19 <ertes> > msqrt 15
10:53:21 <lambdabot>  Just 3.872983346207417
10:53:23 <ertes> > msqrt (-15)
10:53:25 <lambdabot>  Nothing
10:53:40 * hackagebot pretty-show 1.6.11 - Tools for working with derived `Show` instances and generic  inspection of values.  https://hackage.haskell.org/package/pretty-show-1.6.11 (IavorDiatchki)
10:53:43 <mizu_no_oto_work> bwe: Maybe is used as an alternative to null, with a better rule: if it isn't a Maybe, it's 'non-nullable'.  If it is a Maybe, then it's 'nullable' 
10:53:44 <Iceland_jack> bwe: Think hard about the difference between 'Nothing' and 'Just Nothing'
10:53:59 <bwe> mizu_no_oto_work: Please don't take it as an offense when I don't follow your idea. Otherwise I will be completely confused ;).
10:54:11 <ajf> what's that thing that lets you combine an application of a pure function with a <- in a monad
10:54:17 <ajf> (it's been a while.)
10:54:25 <SamuraiChinpo> :ertes but how? since 'pure' only takes one parameter
10:54:36 <ajf> like, I wanna do `ps <- params; let errorMessage = lookup "error" ps` in one line
10:54:50 <ajf> I think it's something in angle brackets
10:54:55 <bwe> Iceland_jack: Nothing is "Sorry, there's no value at all"
10:54:56 <Iceland_jack> In Common Lisp you can look for a "NIL" 
10:54:56 <Iceland_jack>     (find-if #'null '(2 4 nil 6))
10:54:56 <Iceland_jack> this returns "NIL" if it fails... but also "NIL" if it succeeds!!!
10:55:04 <kadoban> :t (=<<) -- ajf ?
10:55:06 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:55:13 <ertes> bwe: you should first understand that haskell has no null value‚Ä¶  if something is of type Int, it is an actual number (or an infinite loop that would produce a number when it would finish)
10:55:28 <ertes> nothing else can be of type Int
10:55:29 <ajf> kadoban: that might be it
10:55:32 <chpatrick> ajf: lookup "error" <$> params
10:55:34 <Iceland_jack> In Haskell it returns 'Just Nothing' if it succeeds
10:55:37 <Iceland_jack> and 'Nothing' if it fails
10:55:42 <Iceland_jack> > find (== Nothing) []
10:55:44 <lambdabot>  Nothing
10:55:45 <Iceland_jack> > find (== Nothing) [Nothing]
10:55:47 <lambdabot>  Just Nothing
10:55:57 <Iceland_jack> Other languages collapse this into a single value
10:56:07 <ertes> SamuraiChinpo: i suggest that you try to understand (<*>) first
10:56:18 <ajf> chpatrick: is it also possible to do that with =<<?
10:56:19 <ertes> SamuraiChinpo: because 'pure' is easier to understand in relation to that one
10:56:36 <chpatrick> ajf: there's no point since lookup is pure
10:56:42 <bwe> Iceland_jack: Can I say that Nothing and Just blabla define only two possible outputs a function can have?
10:56:49 <chpatrick> ajf: wait is params in Maybe?
10:56:54 <ajf> no
10:56:57 <bwe> Just is the opposite of Nothing?
10:56:59 <ajf> it's a list
10:56:59 <chpatrick> ajf: what is it?
10:57:10 <chpatrick> so you want to lookup error in every element?
10:57:13 <ertes> bwe: the two possible *shapes* of the result
10:57:19 <infandum> Using cassava, is there a way to not define the type but still index by name? Like, "header1,header2\ncheese,almond" decoded to give some kind of object (like in aeson) where I can just say parsedCSV .: "header2" and get "almond"? With no definition of a record?
10:57:20 <ajf> er
10:57:22 <bwe> ertes: shapes ;)
10:57:22 <chpatrick> and get a list of maybes?
10:57:28 <infandum> In aeson you can do that with a generic Object type
10:57:31 <ajf> chpatrick: `params` returns a list of pairs
10:57:32 <Iceland_jack> bwe: Yes, pretty much
10:57:32 <mizu_no_oto_work> bwe: suppose you have a function that takes a String and tries to parse it into an Int.  What type would you expect that function to have?
10:57:35 <bwe> Iceland_jack: Can I say that Nothing and Just blabla define only two possible *shapes* a function can have?
10:57:36 <ajf> I want to find a particular value in a pair
10:57:43 <Iceland_jack> bwe: A Bool is either True or False
10:57:45 <chpatrick> ajf: what is the type of params?
10:57:52 <ertes> bwe: if something (such as the result of a function) is of type Maybe A, then the result can only be of the shape "Nothing" or the shape "Just x", where x is an A
10:57:53 <Iceland_jack> a 'Maybe _' is either Nothing or (Just _)
10:57:56 <kadoban> bwe: data Maybe a = Nothing | Just a     -- <-- that's Maybe   So if you have a value of type :: Maybe Int, it's either an Int (wrapped in Just) or it's Nothing
10:57:58 <ajf> ActionM [(Text, Text)]
10:58:02 <ajf> IIRC
10:58:05 <chpatrick> ajf: yes then what I wrote
10:58:05 <bwe> So, if I use Just in some function that means the same function could end up returning Nothing, right?
10:58:07 <chpatrick> :t (<$>)
10:58:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:58:10 <ajf> ah, okay, thanks
10:58:13 <chpatrick> :t lookup
10:58:14 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
10:58:29 <Iceland_jack> I don't understand the question
10:58:35 <ajf> should I import it from Data.Functor or from Control.Applicative? :p
10:58:58 <ertes> bwe: if given a type "B" and a value "Just x" of that type, then certainly B = Maybe A for some A
10:59:01 <chpatrick> ajf: I think it's in the prelude now
10:59:14 <ertes> bwe: and yes, in that case Nothing would be another valid value of type B
10:59:15 <ajf> hmm
11:00:17 <ajf> chpatrick: GHC didn't moan at me not importing, so you must be right
11:00:34 <bwe> ertes: I think I've got it.
11:00:45 <bwe> Now, can anyone test me if I do?
11:00:57 <ertes> bwe: what's the type of Just ()?
11:01:17 <bwe> Maybe ()
11:01:29 <Iceland_jack> bwe: what's the type of Nothing?
11:02:03 <bwe> Maybe
11:02:10 <ertes> bwe: that's not a type =)
11:02:22 <bwe> Then it can only be Maybe Nothing
11:02:28 <Iceland_jack> no
11:02:42 <Iceland_jack> <Iceland_jack> bwe: When we define 'data Maybe a = Nothing | Just a' we get two constructors
11:02:42 <Iceland_jack> <Iceland_jack>     Nothing ::      Maybe a
11:02:42 <Iceland_jack> <Iceland_jack>     Just    :: a -> Maybe a
11:02:49 <ertes> bwe: Maybe always takes a *type* as its argument
11:02:51 <infandum> :t Nothing
11:02:52 <lambdabot> Maybe a
11:03:14 <infandum> :t Just 3
11:03:15 <lambdabot> Num a => Maybe a
11:03:17 <ertes> bwe: and only then it becomes a type‚Ä¶  "Maybe" alone is called a "type constructor", because it needs a type argument
11:03:40 * hackagebot system-info 0.1.0.1 - Get information about CPUs, memory, etc.  https://hackage.haskell.org/package/system-info-0.1.0.1 (dtaskoff)
11:03:42 <bwe> So, the type of Nothing is Maybe a
11:03:47 <Iceland_jack> Yes
11:03:59 <Iceland_jack> bwe: Compare this to the lists, what is the type of the empty list?
11:04:03 <Iceland_jack> :t []
11:04:03 <ertes> bwe: Iceland_jack's question is a bit difficult to answer‚Ä¶  the correct answer is:  Nothing is of type Maybe A, for all A
11:04:04 <lambdabot> [t]
11:04:06 <bwe> [a]
11:04:22 <ertes> so Nothing is of type Maybe Int, Maybe (), Maybe Bool, ‚Ä¶
11:04:34 <bwe> ertes: anything a could be, right?
11:04:38 <ertes> yeah
11:04:41 <ertes> bwe: is Nothing a valid value of type Maybe (Maybe Int)?
11:04:52 <Iceland_jack>     Nothing   vs []
11:04:52 <Iceland_jack>     Just x    vs [x]
11:04:52 <Iceland_jack>  
11:05:45 <bwe> Maybe Int can end up to be Nothing.
11:05:55 <Iceland_jack> certainly
11:06:00 <Iceland_jack> Just like [Int] can be empty
11:06:09 <Iceland_jack> > [] :: [Int]
11:06:11 <lambdabot>  []
11:06:17 <ertes> bwe: that was an exercise‚Ä¶  feel free to try to answer it =)
11:06:19 <bwe> Maybe (Nothing)  will be of type Maybe a.
11:06:24 <ertes> nope
11:06:34 <ertes> Maybe Nothing  -- that's an error
11:06:46 <ertes> do you see why?
11:07:22 <bwe> Because Nothing infers Maybe?
11:07:29 <bwe> Maybe Maybe a?
11:07:31 <ertes> because Nothing is a *value*
11:07:36 <ertes> Maybe is a *type* constructor
11:07:42 <bwe> ertes: and Maybe expects a type
11:07:57 <ertes> values:  Nothing, Just Nothing, Just 15, Just (Just 15), Just (Just Nothing), etc.
11:08:11 <ertes> types: Maybe (), Maybe Int, Maybe (Maybe ()), Maybe (Maybe Int), etc.
11:08:35 <bwe> So, what's now  Maybe (Maybe Int) ?
11:08:49 <bwe> Maybe Int is either Just Int or Nothing
11:08:51 <chpatrick> bwe: what values do you think it can have?
11:09:06 <bwe> Maybe (Just Int | Nothing)
11:09:11 <johnw> Just Int is equally as wrong as Maybe Nothing
11:09:19 <johnw> though in a different way
11:09:28 <chpatrick> bwe: well the outer one is a Maybe too right?
11:09:29 <ertes> bwe: a (Maybe A) may be of shape Nothing or (Just x), where x is of type A‚Ä¶  now you have A = Maybe Int
11:09:47 <Iceland_jack> bwe: Play around with Maybe in your ghci
11:10:04 <Iceland_jack> You'll develop a feel for it in no time
11:11:01 <bwe> Iceland_jack: Sure, that's how I ended up here: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-parameters "Let's play around with the Maybe type." does not work for me.
11:11:10 <bwe> I can't reproduce what the book has.
11:11:17 <bwe> > Just "Haha"
11:11:19 <lambdabot>  Just "Haha"
11:11:20 <ertes> bwe: i think you're an algebraic learner =)
11:11:23 <chpatrick> bwe: what's the problem?
11:11:34 <ertes> bwe: playing around does not work for me either, most of the time
11:11:55 <bwe> Okay. I've needed a fresh ghci.
11:11:58 <bwe> That's it.
11:12:53 <ertes> i wonder what could mess up GHCi that way
11:13:02 <dedgrant> One thing that got me a lot early on was learning where names referred to types and where they referred to values.
11:13:05 <Iceland_jack> ertes: If they redefined Maybe
11:13:12 <bwe> Iceland_jack: Which is the case.
11:13:31 <ertes> ah, ambiguity errors then
11:14:30 <bwe> ertes: What's an algebraic learner?
11:14:45 <Cale> dedgrant: Yeah, it's pretty important to realise that these are two separate namespaces, since the fact that you can name a type and a data constructor of that type the same thing gets used a fair bit.
11:15:11 <ertes> bwe: personally i learn less from experimentation, and more from understanding relationships
11:16:12 <ertes> bwe: that's what i refer to as an "algebraic learner"
11:16:23 <bwe> So, thank you very much for your awesome support in this very basic problem I had. I can't grasp more for today. Hope for your understanding, please.
11:17:25 <ertes> perhaps "conceptual learner" vs. "empirical learner" would be a better distinction =)
11:21:21 <johnw> learn by deduction, or learn by induction :)
11:22:41 * Iceland_jack . o O (( do aliens learn by abduction ))
11:22:46 <shapr> :-P
11:23:14 <johnw> lol, good one :)
11:28:17 <hpc> acids learn by reduction
11:29:31 <shapr> Has anyone done any network protocol parsing?
11:29:56 <hpc> as in like parsing the responses from an always-open connection?
11:30:50 <shapr> hpc: nah, I want to write a SIP parser, wasn't sure which libs/parsers would be best
11:31:33 <shapr> hpc: so I guess closer to consuming a pcap, or reading from a promiscuous interface
11:31:48 <shapr> although your approach is probably a good sensible way to start
11:32:40 <shapr> hpc: have you written code to parse responses from an always open connection?
11:33:40 <ertes> hehe
11:33:54 <hpc> i haven't
11:34:12 <hpc> but the general concept is an always-open connection is a stream of some finite packet
11:34:20 <shapr> ertes: you don't tweet much
11:34:21 <hpc> you have a parser for the packet which you run incrementally on the stream
11:34:37 <ertes> shapr: i don't tweet anything really, because i no longer have access to @ertesx =)
11:34:41 <hpc> and either get partial results or done-with-more-input results
11:34:42 <shapr> ertes: aw :-(
11:34:56 <hpc> which parser combinators are amenable to
11:35:12 <shapr> hpc: I'm hoping I can use the tcp packet code from h0p/house/lighthouse so I can deal with only the SIP level parsing
11:35:32 <hpc> ah, that's lower level than i usually go then
11:35:57 <hpc> the lowest i have gone is bytes of tcp-packet data, and you're just below that
11:36:00 <shapr> you just wrap the OS packet libs?
11:36:21 <hpc> ill use whatever the language
11:36:40 <hpc> whatever the language's version of network is
11:37:18 <ertes> if there are good desktop and android twitter clients, i'd consider making a twitter account again
11:44:43 <shapr> hpc: thanks for the advice
11:48:42 * hackagebot json-api 0.1.0.0 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-0.1.0.0 (toddmohney)
11:50:06 <elucidata> greetings. someone awhile ago mentioned to me there's a fantastic Haskell book written by an expert that's about to have it's 2nd edition released in August but I can't recall the title. Anyone know it?
11:50:48 <byorgey> elucidata: http://www.cs.nott.ac.uk/~pszgmh/book.html
11:51:55 <elucidata> byorgey: that's the one! thanks so much.
11:53:42 * hackagebot ip 0.8.1 - Library for IP and MAC addresses  https://hackage.haskell.org/package/ip-0.8.1 (andrewthad)
11:58:42 * hackagebot timerep 2.0.0.2 - Parse and display time according to some RFCs (RFC3339, RFC2822, RFC822)  https://hackage.haskell.org/package/timerep-2.0.0.2 (koral)
11:58:44 * hackagebot yesod-ip 0.5.0 - Code for using the ip package with yesod  https://hackage.haskell.org/package/yesod-ip-0.5.0 (andrewthad)
12:05:09 <parsnipM_> what's recommended way to install cabal-install on ubuntu? 
12:05:26 <parsnipM_> i think i have stack installed the recommended way
12:07:31 <ertes> do you even need cabal-install, if you use stack?
12:08:10 <parsnipM_> ertes: i prefer cabal-install at the moment, wasn't sure if using stack was recommended way to install cabal-install. 
12:08:58 <parsnipM_> even, at some point i'd like to research how their installation methods compare. 
12:09:00 <suppi> parsnipM_, why not? seems like it should work
12:09:04 <Wizek> Hello! I'm about to write a function that sorts a list of lists. Some of the sub-lists are possibly infinite, but that is theoretically not a problem since I want them in descending order of length, so for the lists for which length is defined will be at the beginning, and the order of elements near the end will be undefined, but that's not a problem. I wonder, since this seems like a curious and somewhat general function, might anyone know
12:09:05 <Wizek>  if this has been written already somewhere? If so, I'd like to take a look and potentially use that solution instead of reinventing the wheel.
12:09:52 <suppi> Wizek, sortBy length ?
12:10:22 <suppi> oh, not length
12:10:28 <koomi> how do you know if a list is infinite?
12:10:30 <Wizek> suppi, That will hit _|_ as soon as it encounters an infinite sublist
12:10:56 <ertes> parsnipM_: if you're not planning to use stack, there is no reason to have it at all
12:11:33 <glguy> koomi: Because you defined it as such. You can't determine if it is after the fact
12:12:22 <ertes> Wizek: there is no way to compute whether a list is infinite
12:12:28 <suppi> Wizek, i see. i'm not familiar with such a function. have you tried hayoo?
12:12:41 <suppi> but if you'll try to compare 2 infinite lists you will encounter bottom as well
12:12:48 <Wizek> ertes, I know that, and I am not trying to comute such.
12:12:58 <parsnipM_> ertes: question is about cabal-install :(
12:13:09 <ertes> Wizek: you're trying to have infinite ones at the end, don't you?
12:13:20 <parsnipM_> https://www.haskell.org/downloads/linux is this ppa seem reasonable? 
12:13:31 <Wizek> suppi, I know that too, and I think I can avoid ever directly comparing two lists
12:13:35 <Wizek> ertes, yes
12:13:38 <ertes> Wizek: that's not possible, because you can't find out whether a list is infinite
12:13:47 <suppi> Wizek, how?
12:14:08 <suppi> parsnipM_, why not install cabal-install with stack?
12:14:33 <ertes> Wizek: you need a fully computable order; 'comparing length' (even a lazier version of that) is not computable when infinite lists are involved
12:15:16 <glguy> You can download a cabal-install binary depending on your platform: https://www.haskell.org/cabal/download.html
12:15:24 <glguy> and it's likely packaged by your distro
12:17:10 <parsnipM_> glguy: oh yeah distro, not sure why i missed that. sorry for the lunch break rushed question folks :)
12:17:20 <Wizek> Hear me out, this is how I imagine the algorithm could work: "step" all sub-lusts one step forward. We take all the [] we have encountered after stepping, return their corresponding lists, filter them out, then recurse. If there is, say, 5 finite lists in the super-list (which is always finite), and we `take 5` we should get a perfectly finite list of lists as a result.
12:17:49 <glguy> parsnipM_: The problem with distro packaged ones is that they're typically outdated, but they can be a starting point
12:17:56 <ertes> Wizek: the problem is: you will never know when to stop, i.e. at which point only infinite lists are left
12:18:12 <ertes> Wizek: if two infinite lists are left, you will keep going forever
12:18:16 <parsnipM_> glguy: yes, will keep in mind, but my file compiles again :)
12:18:43 * hackagebot json-api 0.1.0.1 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-0.1.0.1 (toddmohney)
12:19:50 <reinh> I think it can be done lazily
12:20:01 <reinh> You can calculate length lazily using lazy nats
12:20:37 <Wizek> ertes, That's a valid point, but not necessarily a problem. The user (person) of this function cares only about the beginning of the list, and if the computation takes too long they can try `take`ing less of the returned value.
12:20:59 <reinh> if two lists are infinite (more than zero, for that matter) then they would never be given by the sorting function anyway.
12:21:04 <ertes> Wizek: that's fine, but then you're comparing by a different, computable order =)
12:21:09 <reinh> it's expected that it would not terminate
12:21:37 <ertes> Wizek: your original order is not computable‚Ä¶  it's impossible to sort infinite lists to the end
12:21:39 <Wizek> reinh, yes
12:21:43 <reinh> but it's non-strict, so that's fine, just like take 5 [1..] is
12:22:04 <Wizek> reinh, exactly
12:22:05 <ertes> reinh: that's the "lazier version of that" i mentioned above
12:22:53 <ertes> it helps to sort finite lists by length more efficiently (likely), but it does not solve the infinite case, because it's not solvable
12:23:14 <reinh> you are basically doing diagonalization
12:23:33 <reinh> fsvo "solve", it does. iow, modify your expectations and you can solve it. ;)
12:23:46 <ertes> you can solve a different problem
12:23:52 <reinh> yes
12:24:09 <reinh> which sounds like the actual problem being solved
12:24:19 <ertes> <ertes> Wizek: you need a fully computable order; 'comparing length' (even a lazier version of that) is not computable when infinite lists are involved
12:24:37 <ertes> that's the original problem =)
12:26:15 <reinh> It seems like Wizek has already abandoned the impossible ask in favor of the possible one :)
12:26:38 <ertes> i'm just nitpicking over terminology =P
12:26:47 <reinh> our national pasttime
12:26:58 <johnw> our national hobby, maybe
12:27:06 <reinh> I see what you did there.
12:28:40 <ertes> no!  i'm not going to nitpick over orthography now
12:29:22 <reinh> I think you mean nit-pick.
12:29:56 <Wizek> Have I abandoned something? I believe what I originally asked for is the same function I am still asking for, and that one seems fully possible for me. :) And it seems no one knows of it already written anywhere, so I think I'll take a stab at it.
12:30:30 <reinh> Wizek: if you want an `f` such that `comparing f` is your function, you can't have it.
12:31:04 <reinh> If you want *some* procedure for lazily sorting a list of lists by length, you can have it.
12:31:22 <Wizek> yes, the latter is what I am after.
12:31:39 <Wizek> f :: [[a]] -> [[a]]
12:44:13 <reinh> Well, practically speaking, you cannot.
12:44:24 <reinh> You can have something useless that is technically what you asked for, though
12:45:05 <reinh> You can have a possibly infinite list of empty lists.
12:45:27 <reinh> But your sorting algorithm will never produce any lists of size 1 or more
12:46:27 <reinh> If you could somehow know that your outer list is finite, it could be done the way you want.
12:53:45 * hackagebot data-bword 0.1.0.1 - Extra operations on binary words of fixed length  https://hackage.haskell.org/package/data-bword-0.1.0.1 (MikhailVorozhtsov)
12:53:47 * hackagebot data-dword 0.3.1 - Stick two binary words together to get a bigger one  https://hackage.haskell.org/package/data-dword-0.3.1 (MikhailVorozhtsov)
12:54:54 <hc> hi, could someone trigger some builds on hackage?
12:55:01 <hc> namely for wai-session-postgresql and wai-extra
12:55:35 <hc> ah, i guess #hackage is the right place to ask this
12:55:55 <hc> disregard
12:59:10 <lpaste> glguy pasted ‚Äúsort by length without getting stuff on infinite lists‚Äù at http://lpaste.net/169181
13:01:34 <glguy> hc: You just want the documentation to be on hackage?
13:03:05 <Wizek> reinh, I believe I've said that the outer list is always finite, haven't I?
13:03:41 <Wizek> it's only the sublists that have the potential to be infinite
13:03:42 <glguy> Wizek: That last paste is related to your question
13:04:25 <Wizek> glguy, taking a look, thanks
13:05:21 <glguy> hc: the postgresql package requires postgresql to be installed to build, so that's not going to get automatically built for sure
13:05:44 <glguy> hc: http://hackage.haskell.org/package/wai-extra-3.0.16.1 is up
13:07:16 <hc> thanks!
13:07:29 <hc> glguy: builds of the postgres package used to work in the past, though
13:07:36 <Wizek> glguy, This is quite what I was looking for, and started implementing too. Thanks for an implementation. :) It seems yours is more succinct too.
13:08:08 <hc> glguy: the package doesn't have a failed build, but no builds
13:08:32 <glguy> hc: I don't think it would have helped any to have a failed build
13:09:41 <hc> glguy: 00~http://hackage.haskell.org/package/wai-session-postgresql-0.2.0.4/reports/01~
13:09:49 <hc> sry, http://hackage.haskell.org/package/wai-session-postgresql-0.2.0.4/reports/
13:10:26 <glguy> hc: In any case, the docs are up for it
13:10:49 <hc> thank you :)
13:15:24 <reinh> Wizek: well, you can *say* that.
13:15:33 <reinh> but you can't prove it.
13:16:32 <reinh> Or, rather, Haskell can't prove it.
13:18:31 <ertes> reinh: =P
13:19:46 <ertes> Wizek: you can compare lists by length and treat lists longer than a certain length as equal
13:20:39 <ertes> Wizek: that makes it decidable‚Ä¶  given a random list of lists, it's theoretically impossible to sort infinite sublists to the end
13:22:50 <ertes> Wizek: the length of the outer list does not matter:  let [xs, ys, zs] be a list of lists, where xs and zs are infinite‚Ä¶  you can sort ys to the front, but the rest will diverge
13:25:31 <reinh> If the outer list is infinite, it matters for a different reason
13:25:42 <ertes> Wizek: if you try running glguy's example, you will see what i mean‚Ä¶  the result diverges on the first infinite list
13:25:59 <reinh> if the outer list is finite, it will produce all finite lists before it diverges
13:26:11 <reinh> if the outer list is infinite, it will produce only empty lists before it diverges
13:26:36 <ertes> and there is simply no way to avoid that other than to switch to a different order:  sort not *infinite* lists to the end, but instead sort lists longer than a certain length to the end ‚Äì a slight variation of glguy's code can do that
13:29:17 <Wizek> Gentlemen, I am well aware of the limitation of this function, and that it 'diverges' after returning all finite sub-lists. And I believe this function is still useful for me. :) I wasn't asking for the impossible and for it to diverge, it returning a bottom eventually is exactly what I expected.
13:29:41 <Wizek> s/to diverge/to converge/
13:29:44 <reinh> We just want to be extremely specific and technically correct. Don't mind us.
13:30:08 <ertes> haskeller's syndrome =)
13:30:22 <reinh> The compiler trains us to be so.
13:30:23 <Wizek> That's okay, but aren't we all on the same page already? :)
13:30:36 <reinh> Wizek: that isn't the point ;)
13:30:41 <Wizek> haha
13:30:50 <ertes> Wizek: other than that i can't imagine a use case for this function, we are =)
13:31:24 <ertes> your problem description sounded like you were expecting infinite lists to be there
13:35:58 <ertes> not sure if i should consider that a blatant abuse of 'sequence'
13:36:05 <ertes> > sequence (5, "abc")
13:36:07 <lambdabot>  [(5,'a'),(5,'b'),(5,'c')]
13:36:49 <Wizek> Yes, I wasn't (and still am not) sure how to interpret sequence in there.
13:36:52 <Wizek> :t sequence
13:36:53 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:37:23 <ertes> Wizek: sequence (x, ys) = map (x ,) ys
13:37:29 <ertes> where ys is a list
13:37:31 <glguy> :t curry sequence
13:37:32 <lambdabot> Monad m => a -> m a1 -> m (a, a1)
13:38:47 * hackagebot bloodhound 0.11.1.0 - ElasticSearch client library for Haskell  https://hackage.haskell.org/package/bloodhound-0.11.1.0 (bitemyapp)
13:41:20 <glguy> Writing out $ map (\xs -> [ (xs, t) | t <- tails xs ]) xss
13:41:48 <glguy> would have been nicer, I just like messing around for IRC code, it's like using @pl
13:42:18 <hpc> > map ((,) <$> id <*> tails) [[1..3], [2..4], [3..5]]
13:42:20 <lambdabot>  [([1,2,3],[[1,2,3],[2,3],[3],[]]),([2,3,4],[[2,3,4],[3,4],[4],[]]),([3,4,5],...
13:43:14 <glguy> Yeah, there are lots of IRC-grade abuses we could use :)
13:45:59 <ertes> i think the [] pattern is the worst of them all =)
13:46:21 <ertes> but it makes the code short and sweet
13:46:43 <glguy> Oh, I'll throw the sequence under the bus, but using patterns in list comprehensions is right on track
13:47:11 <ertes> i don't know‚Ä¶  somehow partial patterns don't appeal to me
13:48:00 <ertes> perhaps because they translate to 'fail' in monads, and i never liked 'fail'
13:48:25 <nkaretnikov> is there a way to use an anitquote inside quoteFile?  something like [quoteFile hs|$x|] doesn't work even though hs from haskell-src-exts-qq should support $
13:48:33 <glguy> I'll go along with disliking the desugar to fail in do-notation
13:48:39 <nkaretnikov> (sorry, i have to le-learn th whenever i attempt to use it)
13:49:00 <glguy> and if list comprehensions were generalized as monad comprehensions still I might apply that same logic there, too
13:49:44 <hpc> i like the idea of fail, but it definitely belongs in MonadFail or something
13:49:49 <geekosaur> better than translating to exceptions...
13:50:50 <johnw> hpc: I hope that sometime, that change will happen too
13:51:05 <mgsloan> nkaretnikov: Since quasiquoters have to implement antiquotation on their own, I don't think it's possible for quoteFile to make a difference
13:51:19 <glguy> The monadfail transition is already in progess
13:52:52 <mgsloan> "fail" was such an apt name ;)
13:54:41 <ertes> it's not the name that bothers me =)
13:54:49 <nkaretnikov> mgsloan: this doesn't seem to work, though: let f s = [quoteFile hs|$s|] (complains about a missing '$s' file)  while let f s = [hs|$s|]; f "foo" returns just "foo"
13:55:12 <mgsloan> nkaretnikov: Well yeah, you've gotta have the antiquote in the file
13:55:18 <mgsloan> quoteFile expects a filepath
13:56:21 <nkaretnikov> mgsloan: oh, do i need to define my own version of quoteFile to make it work the way i want?
13:56:41 <mgsloan> Not sure I understand how you want it to work.  Is it supposed to use "s" as the filepath?
13:57:15 <dolio> The problem with fail is that it doesn't (make sense for all monads), not that it (doesn't make sense) for all monads.
13:57:15 <geekosaur> nkaretnikov, s is a runtime value, how is a compile time mechanism supposed to work?
13:58:38 <nkaretnikov> geekosaur: wat?  i want to do this: main = do readFile "foo"; readFile "bar"; ... where readFile should be a magic function that calls quoteFile or the like
13:59:20 <geekosaur> that looks like it should be a quasiquote there, or a splice there
13:59:39 <geekosaur> you cannot define readFile to do that because it is not defined as a compile time macro but as a runtime function
14:00:10 <mgsloan> nkaretnikov: https://hackage.haskell.org/package/file-embed-0.0.10/docs/Data-FileEmbed.html This might be helpful to look at
14:00:55 <geekosaur> it can't go back at the point that it recognizes a quasiquote using the parameter and define it as a compile time macro instead of as a normal function
14:01:06 <nkaretnikov> mgsloan: i've bumped into it, but i'll look more closely later, thanks!
14:01:08 <geekosaur> but compile time macro is the only way that it can know "s" at compile tme
14:02:25 <nkaretnikov> geekosaur: i'm having trouble deciphering this, i'll get back to this tomorrow :)
14:02:52 <geekosaur> ghc has already committed to "readFile s =" as being a function that exists at and is called at runtime
14:03:04 <geekosaur> "s" is therefore a value only available at runtime
14:03:48 * hackagebot digits 0.3 - Converts integers to lists of digits and back.  https://hackage.haskell.org/package/digits-0.3 (HenryBucklow)
14:03:50 * hackagebot eventstore 0.13.1.3 - EventStore TCP Client  https://hackage.haskell.org/package/eventstore-0.13.1.3 (YorickLaupa)
14:05:22 <nkaretnikov> geekosaur: got it
14:11:07 <sleblanc> Given a value of type "Maybe (IO ())", how can I evaluate it without using a case statement? i.e. something equivalent to case x of Just action -> action; Nothing -> return ()
14:11:43 <sleblanc> Ah, that's sequence.
14:11:46 <dolio> sequence_
14:13:48 * hackagebot indentation-trifecta 0.0.1 - Indentation sensitive parsing combinators for Trifecta  https://hackage.haskell.org/package/indentation-trifecta-0.0.1 (AlekseyKliger)
14:13:50 * hackagebot indentation 0.3.1 - Indentation sensitive parsing combinators for Parsec and Trifecta  https://hackage.haskell.org/package/indentation-0.3.1 (AlekseyKliger)
14:13:53 <geekosaur> nkaretnikov, this is why if you want to use a function at compile time, you use it as a splice. so you could write a readFile that works that way, but it must produce a (Q something) and be invoked as $(readFile ...)
14:13:55 <johnw> Aleksey!
14:14:01 <sleblanc> dolio, does sequence_ allow action to be of type IO a instead of () ? Is this the only difference?
14:15:15 <geekosaur> sleblanc, the difference between sequence and sequence_ is that sequence collects and returns the results, whereas sequence_ discards them
14:16:34 <nkaretnikov> geekosaur: kk
14:17:58 <sleblanc> geekosaur, ok
14:18:08 <hwkng> anyone have deep-Q learning / playing of atari games via deep learning in Haskell ?
14:19:40 <peddie> hwkng: https://poincare.github.io/QLearn/
14:20:38 <hwkng> peddie: nice; thanks
14:21:12 <peddie> hwkng: no deep learning there, but it's a start, I guess
14:25:51 <hsk3> This works: https://pastee.org/pa3dd
14:25:52 <hsk3> But this is really bad.
14:25:53 <hsk3> How can I make this more succinct?
14:26:25 <hsk3> In other words, IO code where a list gets put into the same function, but the result of the previous IO action  gets added to the list for the next IO action
14:28:11 <sleblanc> What does it mean for a function to be safe/unsafe?
14:28:32 <muesli4> Hi, is it possible to create constraints from a list of types (e.g. with ConstraintKinds) and use them as a single constraint (e.g. with a type family)? What I'm basically searching is mappend on constraints kinds on the type level. :)
14:31:04 <cocreature> muesli4: do you have an example of what you are trying to achieve?
14:31:18 <Iceland_jack> muesli4: not tested
14:31:18 <Iceland_jack>     type family
14:31:18 <Iceland_jack>       Map xs a :: Constraint where
14:31:18 <Iceland_jack>       Map '[]     a = () 
14:31:21 <Iceland_jack>       Map (c':cs) a = (c a, Map cs a)
14:31:42 <muesli4> Iceland_jack: thx, I will try it.
14:31:53 <Iceland_jack> *   Map (c ': cs) a = ...    
14:32:15 <Iceland_jack> Œª> :kind! Map [Ord,Eq,Num] Int
14:32:15 <Iceland_jack> Map [Ord,Eq,Num] Int :: Constraint                                                                                                                                                                                                                             
14:32:15 <Iceland_jack> = (Ord Int, (Eq Int, (Num Int, () :: Constraint)))                                                                                                                                                                                                             
14:32:57 <muesli4> cocreature: What I'm trying to achieve is, enforcing a constraint on all types in a heterogeneous list, while still being able to acces every specific element (so no existential types).
14:33:28 <Iceland_jack> muesli4: You can also define
14:33:28 <Iceland_jack>     class    (c1 a, c2 a) => (c1 & c2) a
14:33:28 <Iceland_jack>     instance (c1 a, c2 a) => (c1 & c2) a
14:33:55 <cocreature> muesli4: yeah I got it by seeing Iceland_jacks example, I first thought you were trying to scrape constraints of types
14:34:15 <Iceland_jack> and then you can write
14:34:15 <Iceland_jack>     (Ord & Eq & Num) :: Type -> Constraint
14:35:32 <muesli4> Iceland_jack: I don't like it. :D
14:35:35 <Iceland_jack> ;)
14:35:40 <Rembane> hsk3: What about this? https://pastee.org/nextm
14:35:49 <Iceland_jack> I'm not here to make friends!
14:36:06 <muesli4> Iceland_jack: No worries. Probably a matter of taste.
14:36:11 * Iceland_jack . o O ( tear )
14:36:57 <sigrlami_> where yesod app stores app logs by default?
14:37:06 <pumita_> Hello, how can I update a library version with cabal?
14:37:47 <sigrlami_> pumita_: your library or depends?
14:38:24 <pumita_> I don't know, I'm just getting this: rejecting: base-4.9.0.0 (only already installed instances can be used) rejecting: base-4.8.2.0, 4.8.1.0, 4.8.0.0, 4.7.0.2/installed-5ef..., 4.7.0.2, 4.7.0.1, 4.7.0.0, 4.6.0.1, 4.6.0.0, 4.5.1.0, 4.5.0.0, 4.4.1.0, 4.4.0.0, 4.3.1.0, 4.3.0.0, 4.2.0.2, 4.2.0.1, 4.2.0.0, 4.1.0.0, 4.0.0.0, 3.0.3.2, 3.0.3.1 (global constraint requires ==4.9.0.0) Dependency tree exhaustively searched.
14:39:08 <geekosaur> base is wired in; that message is telling you your ghc is too old
14:39:28 <sigrlami_> which ghc you're using?
14:39:38 <pumita_> 7.8.4
14:39:59 <pumita_> mmm, maybe I need to update it, let me see what happens after
14:40:13 <geekosaur> https://wiki.haskell.org/Base_package
14:40:25 <geekosaur> has a table of which ghc versions ship which versions of base
14:40:27 <sigrlami_> well  4.9 is fresh one, better switch at least to 7.10.3
14:40:42 <geekosaur> 4.9.0.0 is ghc 8.0.1
14:41:10 <sigrlami_> yes, geekosaur is right that's even 8.0.1
14:42:56 <hsk3> Rembane: haha genius..
14:43:02 <hsk3> nice.
14:43:11 <Rembane> hsk3: ^^ 
14:43:15 <Rembane> hsk3: does it work? :)
14:44:01 <hsk3> didn't try yet lol, i thought you did..
14:44:12 <hsk3> i wonder if it will since it's IO actions
14:44:26 <hsk3> i'll test it
14:44:31 <hsk3> (running some code atm)
14:44:46 <Rembane> hsk3: Nah, it won't typecheck.
14:44:59 <Rembane> hsk3: But you might be able to fix it anyway, otherwise I can fix it. :)
14:51:05 <ertes> muesli4: note that constraints compose naturally with commas
14:51:38 <ertes> type C1 x = ‚Ä¶; type C2 x = ‚Ä¶; type C12 x = (C1 x, C2 x)
14:52:09 <muesli4> ertes: Yep, thx, got it working already.
14:53:13 <ertes> (i wish commas weren't so special syntactically)
14:53:52 <hsk3> Rembane: i'll try it myself, thanks :)
14:54:01 <hsk3> seems like a nice exercise
14:54:11 <Rembane> hsk3: No worries. Just tell me if the types don't add up. :)
14:54:58 <pumita_> Hi, how do I mix stack with some cabal library?
14:55:10 <sigrlami_> meaning mix?
14:55:21 <sigrlami_> you just add library to .cabal
14:55:24 <pumita_> using stack
14:55:30 <sigrlami_> and stack pick it up if it's in stackage
14:56:00 <pumita_> I mean, I have an old project with cabal, I just want to build it with stack
14:56:03 <mmachenry> Does anyone know why this cabal file I just forked will not install the library portion of the code? It only installs the executable when I run "stack install" https://github.com/mmachenry/finite-domain/blob/master/fd.cabal
14:56:06 <sigrlami_> or you need to add `extra-deps` if you need to use something from hackage additionaly
14:56:07 <kadoban> If it's not in stackage, you just tell stack where to find it, in the stack.yaml. Which if it's on hackage is just telling it what version to use.
14:56:27 <ertes> pumita_: stack and cabal aren't in competition
14:56:30 <kadoban> mmachenry: Because that's all that 'stack install' is for. Are you trying to use it as a dependency?
14:56:50 <kadoban> pumita_: Try 'stack init' in the project directory?
14:56:53 <ertes> pumita_: in other words, your library is not *old* and every library is a cabalised library =)
14:57:06 <pumita_> haha thanks
14:57:07 <mmachenry> kadoban: Yes, I'd like to install it in my .cabal so that I have it when I run ghci for example
14:57:07 <glguy> ertes: Maybe it's actually just old
14:57:26 <ertes> the base dependency might tell whether it is
14:57:45 <kadoban> mmachenry: You just put it in the cabal file as a dependency then, and then run 'stack ghci' or whatever you're doing.
14:58:04 <pumita_> another thing, I just want to update ghc... how should I do it properly?
14:58:25 <mmachenry> kadoban: But I have another project in another directory that I want to use this as a dependancy for. I want to install it on my system.
14:58:29 <pumita_> I'm trying to use stack, as it says it installs ghc in an isolated location
14:59:53 <kadoban> mmachenry: stack automatically reuses dependencies when it can. stack has no concept of globally installed packages, really. You specify dependencies in projects. If you don't want to be in a project, you can do stuff like  'stack ghci -package lens' for instance, outside of a project directory.
15:00:09 <glguy> mmachenry: Instead of installing the package to have it available you have to add the directory to your stack.yaml
15:00:16 <kadoban> mmachenry: So if you have two projects you want to use a dependency from, specify the dependency for both of them individually. That's it.
15:00:26 <glguy> mmachenry: It will go in your packages: section
15:00:54 <kadoban> mmachenry: Also set the extra-dep: true flag for it
15:01:10 <glguy> If what you want is for it to be treated as an extra dep
15:01:15 <mmachenry> Is there a way to use a stack project I have written as a dependency for a one-off script I'm writing that has no stack file of its own?
15:01:35 <glguy> Yeah, stack.yaml files are for project workspaces, not for packages
15:01:58 <kadoban> mmachenry: Easy way is likely to add a stack.yaml, though you can probably do it without. I'm not sure of the command line syntax for that.
15:03:05 <mmachenry> I guess, basically, I'm looking for the old cabal workflow which was that I could cabal install then go to a totally new directory, make a one-off script and just say import MyModule and it was globally there. Maybe that's not possible anymore?
15:03:10 <mgsloan> mmachenry: You can!  Take a look at http://docs.haskellstack.org/en/stable/GUIDE/?highlight=script#script-interpreter
15:03:17 <glguy> your one-off package still has a .cabal file so you can install it with cabal-install still
15:03:50 <mmachenry> glguy: My one-off package does not have a .cabal file. Not yet anyway. I was hoping to avoid that.
15:04:05 <mgsloan> Lets say you have a script that works with lts-3.2 and the turtle package, just put at the top after the env shebang "-- stack --resolver lts-3.2 --install-ghc runghc --package turtle"
15:04:15 <glguy> mgsloan: No, that looks different than installing a library for use somewhere else, does it?
15:04:22 <mgsloan> And running the script should work for anyone that has stack
15:04:23 <kadoban> mgsloan: The part I wasn't sure how to do is ... how do you specify a -package that's just a directory? Or does it accept just file paths maybe?
15:04:35 <mgsloan> glguy: It does install the library
15:05:00 <mgsloan> kadoban: It just accepts stackage-pkg-name or specific-hackage-version-1.0
15:05:26 <glguy> mmachenry: If you don't have a .cabal file it's not a package
15:05:33 <kadoban> mgsloan: So if you just have a package locally you want to use, you have to have a stack.yaml, right? I think that's what the person is trying to do, if I understood correctly.
15:05:35 <mmachenry> glguy: Yes I know
15:05:36 <mgsloan> mmachenry: If you have a bunch of scripts that all need a similar package environment, then it can be quite convenient to wrap that up as a stack.yaml
15:05:59 <mmachenry> glguy: I don't want the dependent to be a package. But the dependency is a package with a cabal file.
15:06:20 <mmachenry> mgsloan: I'm hearing that my workflow is not possible I guess. :(
15:06:38 <kadoban> mmachenry: So you have  SomeScript.hs you just want to run, and it uses some package as a dependency, that has a .cabal file, that's only available on your local hard drive, correct?
15:06:52 <mmachenry> kadoban: correct
15:07:20 <glguy> mmachenry: You'd confusedmme when you described it as a "one-off package"
15:07:36 <kadoban> Hmm. Can that dep be specified in the global-project and then used in standalone scripts I wonder?
15:07:51 <mmachenry> Yeah sorry I corrected and said it's not a package
15:07:54 <mgsloan> kadoban: Right, maybe it would make sense for ghci to support paths in --package, though https://github.com/commercialhaskell/stack/blob/master/src/Stack/Ghci.hs#L290
15:08:17 <pumita_> How can I properly update ghc?
15:08:42 <kadoban> mgsloan: I'd imagine it's a fairly rare use-case, but I guess ideally maybe ...
15:08:50 <mgsloan> I mean, TARGET syntax already overloads package name / package identifier / dir name
15:09:01 <ertes> mmachenry: not sure about stack, but with nix you can have GHC environments with arbitrary package sets from hackage or local packages, and they don't have to be bound to a "project"
15:09:05 <mgsloan> Yeah, no reason not to, just not something that we tend to encounter
15:09:06 <kadoban> Oh, yea that's somewhat problematic.
15:09:06 <glguy> pumita_: The same way you installed it the first time
15:09:44 <mgsloan> ertes: "Project" is just terminology.  A stack.yaml really just specifies an environment like that
15:10:10 <glguy> pumita_: Via your package manager, via bindists on haskell.org/ghc, via stack, via haskell-platform. Whichever you happen to be using
15:10:12 <mgsloan> A "project" is an environment for building packages and code in such a way that deps can be automatically installed
15:10:14 <kadoban> mgsloan: What if in the global-project stack.yaml the person specifies it in packages: as an extra-dep, would that work? Could they then just do the interpreter syntaxy thing and specify the package by whatever name?
15:10:46 <kadoban> Or maybe that doesn't make sense, I'm not quite sure.
15:11:02 <kadoban> I'd try, but I'm currently trying to build ghcjs, haha.
15:11:06 <mmachenry> kadoban: ~/.stack/config.yaml?
15:11:16 <mgsloan> That'd work, but it wouldn't work well for other folks that clone your repo
15:11:44 <kadoban> mmachenry: I was referring to ~/.stack/global-project/stack.yaml  which is what's used for "project specific settings when you're not in a project" kind of things.
15:12:00 <mgsloan> Yeah, it's just a default, the global project is not special
15:12:05 <mmachenry> Ah, I see.
15:12:06 <mgsloan> (other than being a default)
15:12:29 <ertes> mgsloan: a nix-based environment is not bound to any directory, file or cabal project‚Ä¶  one option is to define a bunch of those in your user configuration and then just the appropriate one for each non-cabalised haskell project‚Ä¶  not entirely sure, but i think that's what mmachenry is asking for
15:12:46 <ertes> s/just/just use/
15:13:41 <mgsloan> I know, but you need to specify which environment you are in
15:13:52 <mgsloan> With stack you can get "into" the environment by doing "stack exec bash"
15:14:08 <ertes> same with nix via nix-shell
15:14:16 <mgsloan> Yeah
15:14:19 <mmachenry> So I could put a reference to my project in ~/.stack/global-project/stack.yaml and then run stack ghci instead of ghci?
15:14:20 <kadoban> mmachenry: So you'd need something like: http://lpaste.net/5810988170489102336 in that file, along with possibly other settings, especially maybe a resolver:  line usually goes in there, but may be optional.
15:14:27 <mgsloan> Also, stack integrates with nix, so you can use nix to control your 3rd party deps
15:14:34 <pumita_> glguy: thanks, I'd like to do it from stack, do you know how?
15:14:48 <mmachenry> I see.
15:15:01 <glguy> pumita_: stack setup, will install GHC if needed for the current workspace
15:15:05 <pumita_> glguy: I executed `stack setup` but it shows : stack will use a locally installed GHC
15:15:12 <glguy> pumita_: Then it's done
15:15:20 <pumita_> but it is an old version
15:15:24 <mgsloan> mmachenry: You could, particularly if noone else needs to run these scripts
15:15:50 <kadoban> pumita_: It chooses what GHC to install based on what's needed for the current project, or what's in the globla-project if you're not in a project.
15:15:56 <glguy> If you want a different GHC you'll need a different resolver
15:15:56 <glguy> That's the version that that resolver uses
15:16:31 <mgsloan> Yeah.  If you don't want to create a stack.yaml that demands the ghc version, then you can also just do "stack setup --resolver ghc-8.0"
15:16:46 <kadoban> Oh, good idea
15:17:26 <glguy> If the goal was to build a workspace with a particular GHC pumita_ might as well update the stack.yaml accordingly
15:18:10 <pumita_> glguy I had a problem with the base library... Someone said it was because the ghc version I'm using, so I just want to update it, that's all
15:18:26 <mgsloan> glguy: True!
15:18:51 * hackagebot json-api 0.1.0.2 - Utilities for generating JSON-API payloads  https://hackage.haskell.org/package/json-api-0.1.0.2 (toddmohney)
15:19:01 <kadoban> pumita_: If you just do 'stack init' inside the project you're using, I'm assuming there's a .cabal file there, and then 'stack setup' it should be all great.
15:19:31 <pumita_> kadoban I'm following the example from the stack web page
15:19:37 <pumita_> `my-project`
15:20:00 <pumita_> so I don't know why it doesn't upgrade the ghc version, if it should
15:20:23 <kadoban> pumita_: Hmm, what example? from haskellstack.org somewhere in there?
15:21:05 <mgsloan> pumita_: What is the error that requires a newer ghc version?  Are you on windows?
15:21:20 <kadoban> Oh I think I see it. Well that's for when you don't already have a project you've written though. You have code you're trying to just run, right? But except for stack init instead of stack new, that still looks fine.
15:21:52 <pumita_> mgsloan: I'm on ubuntu, on Windows it worked fine as it was the first time I had ghc :P
15:22:14 <pumita_> kadoban yes, I think you're right
15:38:51 * hackagebot yesod-auth-oauth2 0.2.1 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.2.1 (PatrickBrisbin)
15:53:28 <sleblanc> I am looking for a function Handle -> Maybe Char that returns Nothing when there is no input (or similar)
15:53:52 * hackagebot Chart 1.8 - A library for generating 2D Charts and Plots  https://hackage.haskell.org/package/Chart-1.8 (TimDocker)
15:53:54 * hackagebot Chart-cairo 1.8 - Cairo backend for Charts.  https://hackage.haskell.org/package/Chart-cairo-1.8 (TimDocker)
15:55:59 <hpc> \h -> hWaitForInput h 0 >>= \ready -> if ready then Just <$> hGetChar h else return Nothing
15:56:20 <hpc> (or hLookAhead if you don't want to consume the char)
15:57:05 <hpc> you'll want to make that nicer before you use it, i wrote it to fit on one line
15:58:15 <dmwit> sleblanc: Proposal: put the thing that handle the Handle in another thread and just use boring old blocking IO.
15:58:20 <geekosaur> that has the potential to fail in a multibyte locale (including UTF8)
15:58:30 <dmwit> (Or why did we bother having a fancy IO manager? ;-)
15:58:35 <geekosaur> the hWaitForInput one, that is
15:58:52 * hackagebot Chart-gtk 1.8 - Utility functions for using the chart library with GTK  https://hackage.haskell.org/package/Chart-gtk-1.8 (TimDocker)
15:58:54 * hackagebot Chart-diagrams 1.8 - Diagrams backend for Charts.  https://hackage.haskell.org/package/Chart-diagrams-1.8 (TimDocker)
15:59:03 <sleblanc> geekosaur, yeah, I saw that in the documentation of hWaitForInput
15:59:31 <sleblanc> I just want to handle the user pressing "q" to quit in a simple app that otherwise continuously performs an action
16:01:04 <dmwit> sleblanc: main = do { tid <- forkIO (forever (putStrLn "Hi!")); getChar } -- ?
16:01:19 <dmwit> Whoops, the `tid <-` bit isn't even necessary.
16:01:20 <sleblanc> dmwit, ah, that's another way of doing it
16:01:53 <sleblanc> i'll make the second part a loop too, so that if the user presses on something other than q it continues
16:01:58 <dmwit> (I was going to add a `throwTo` but remembered that everything dies when `main` does.)
16:05:15 <pumita_> If I install ghc with stack inside a project, it means that I will have to install ghc every time I work in a different project?
16:05:49 <glguy> No, stack will reuse ghc GHC installations for other stack workspaces
16:06:58 <pumita_> glguy is there a way to know the ghc version i'm using on stack? because `stack ghc --version` doesn't work
16:07:29 <dmwit> stack ghc -- --version
16:07:56 <dmwit> -- is a standard "pass-through" technique for options.
16:08:05 <pumita_> dmwit thanks! 
16:11:09 <lpaste> sleblanc pasted ‚ÄúDoes not terminate‚Äù at http://lpaste.net/6181526294879010816
16:11:48 <sleblanc> So, as per the title, when I run this in GHCi and hit 'q', control returns to GHC, but the program continues running in background
16:12:01 <glguy> Because it's GHCi
16:12:17 <glguy> It will when you compile it and run it
16:13:40 <glguy> If you want to use this in GHCi, you can remember the ThreadId returned from forkIO and execute the action returne from applying killThread to that ThreadId when a 'q' is pressed
16:13:43 <sleblanc> so should I stop the thread to make it work in GHCi, too?
16:13:46 <sleblanc> ok
16:19:04 <lpaste> glguy annotated ‚ÄúDoes not terminate‚Äù with ‚Äúusing async‚Äù at http://lpaste.net/6181526294879010816#a169187
16:19:27 <glguy> sleblanc: async provides a nice set of operations for working with threads
16:24:13 <sleblanc> glguy, pretty!
16:37:41 <sleblanc> How does Blunt infer it can flip arguments to "=="? Is it hard-coded? https://blunt.herokuapp.com/#input=f%20c%20%3D%20when%20%28c%20%3D%3D%20%27q%27%29%20doSomething
16:42:39 <Koterpillar> sleblanc: https://github.com/bmillwood/pointfree/blob/master/Plugin/Pl/Rules.hs#L732
18:29:52 <pumita> hey, how could I perform `stack init` over a project when the libraries are not found?
18:30:36 <pumita> Because I'm getting a lot of `not found` errors
18:30:48 <kadoban> pumita: What are the exact errors?
18:31:07 <pumita> Selecting the best among 8 snapshots...
18:31:07 <pumita> * Partially matches lts-6.6
18:31:07 <pumita>     ALUT not found
18:31:14 <pumita> and so on...
18:31:29 <kadoban> pumita: Well, what's ALUT? Where did you get it from?
18:31:53 <pumita> I guess ALUT is some hackage library
18:32:04 <pumita> it's in the .cabal file of the project I'm trying to build
18:32:17 <pumita> , ALUT == 2.4.0.0
18:32:34 <mniip> wtf
18:32:41 <mniip> why does it attempt to use fix in a nonrecursive function
18:33:01 <kadoban> Hmm, it is. Can you lpaste the whole output? Maybe you just need to specify them in your stack.yaml
18:33:04 <kadoban> pumita: ^
18:33:08 <pumita> ok
18:33:57 <pumita> kadoban: http://lpaste.net/169204
18:33:57 <mniip> \c -> when (c == 'q') doSomething
18:34:01 <kadoban> Grr, this is really annoying ... trying to build my ghcjs app on a new computer and it apparently builds fine, but just crashes immediately when I attempt to use it.
18:34:14 <mniip> \c -> when . ($ doSomething) . (== 'q') $ c
18:34:19 <mniip> when . ($ doSomething) . (== 'q')
18:34:34 <mniip> no wait
18:34:35 <Koterpillar> pumita: specify a resolver
18:34:40 <mniip> ($ doSomething) . when . (== 'q')
18:35:13 <pumita> Koterpillar: yes, the problem is I don't know which :P
18:35:25 <ggVGc> I think haskell is pretty great
18:35:26 <Koterpillar> let's start with the latest LTS
18:35:28 <ggVGc> that's all I have to say
18:35:38 <pumita> ahh
18:36:10 <pumita> should I create the stack.yaml by hand right?
18:36:17 <Koterpillar> it'll do it for you
18:36:26 <Koterpillar> see last line of your paste
18:36:53 <pumita> oh yes, thanks!
18:37:50 <pumita> done creating the stack.yaml
18:38:36 <pumita> also I specified the latest lts (lts-6.6, am I right?), but throws the same errors
18:39:05 <kadoban> pumita: It should give you suggestions as to what to do.
18:39:14 <Koterpillar> what did you do, and what errors did it give?
18:39:20 <glguy> pumita: I think the way to go here is: stack init --resolver=ghc-7.10
18:39:31 <pumita> stack init --resolver lts-6.6 --omit-packages
18:39:32 <glguy> pumita: This package is very specific about which versions it wants
18:39:39 <glguy> so using an lts isn't buying anything
18:39:43 <Koterpillar> pumita: just --resolver
18:40:19 <medical247> hi
18:40:24 <medical247> hi all, plz help me bypass a login screen as shown in this pic https://s33.postimg.org/u12vuvoe7/bci_4.png
18:40:25 <medical247> we run a private charity in Malawi and this screen blocks the latest software update needed for a pathogen testing lab machine.
18:40:25 <medical247> we dont have the money for software updates :(
18:40:25 <medical247> plz help.. my email is medical247 at tutamail dot com
18:40:28 <glguy> pumita: Using the ghc-7.10 resolver you don't need to supply any additional flags for it to succeed
18:40:31 <nitrix> ping glguy 
18:40:47 <pumita> glguy Nice!!!
18:40:50 --- mode: ChanServ set +o glguy
18:40:51 --- mode: glguy set +b *!*@164.215.108.20
18:40:51 --- kick: medical247 was kicked by glguy (offtopic)
18:41:16 <pumita> glguy it worked... mind if I ask why?
18:41:27 <glguy> Why it worked?
18:41:31 <pumita> yes
18:41:53 <shirt> i have a list of elements. how do i get a list containing all of the pairs?
18:42:06 <glguy> stack init makes a new stack.yaml, --resolver ghc-7.10 because we know tha this package requires a 7.10 ghc due to it's base range
18:42:31 <glguy> pumita: then it allows cabal to resolve a set of packages that satisfies the version constraints
18:42:37 <glguy> and saves those version in your stack.yaml
18:42:46 <Koterpillar> > let es = [1, 2, 3] in (,) <$> es <*> es  -- shirt
18:42:47 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
18:43:01 --- mode: glguy set -bo *!*@164.215.108.20 glguy
18:43:31 <shirt> Koterpillar: thanks, but without the pairs containing the same element
18:43:32 <pumita> glguy thanks!
18:45:22 <Koterpillar> > [(e1, e2) | e1 <- x, e2 <- x, e1 /= e2]  -- shirt
18:45:23 <lambdabot>      Couldn't match expected type ‚Äò[t]‚Äô with actual type ‚ÄòExpr‚Äô
18:45:23 <lambdabot>      In the expression: x
18:45:23 <lambdabot>      In a stmt of a list comprehension: e1 <- x    Couldn't match expected ty...
18:45:35 <Koterpillar> > let es = [1, 2, 3] in [(e1, e2) | e1 <- es, e2 <- es, e1 /= e2]  -- shirt
18:45:39 <lambdabot>  [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
18:46:33 <shirt> Koterpillar: awesome thanks! any way without Eq typeclass though?
18:47:31 <dibblego> how would you know they are equal, without Eq?
18:47:41 <Koterpillar> I would guess by position in the list
18:47:42 <glguy> Just positionally
18:48:00 <nitrix> dibblego: The diagonal of the cartesian product.
18:48:02 <dibblego> so (1, 1) can appear, as long as they are from different positions
18:49:27 <Koterpillar> not very nice but:
18:49:40 <Koterpillar> > do { x <- tails es; y <- tails x; guard (not (null x)); guard (not (null y)); return (head x, head y)} where es = [1, 2, 3]
18:49:41 <lambdabot>  <hint>:1:104: parse error on input ‚Äòwhere‚Äô
18:49:44 <glguy> > let es = [1,2,3] in [ z | x:xs <- tails es, y <- xs, z <- [(x,y),(y,x)] ]
18:49:46 <lambdabot>  [(1,2),(2,1),(1,3),(3,1),(2,3),(3,2)]
18:50:00 <Koterpillar> ooh, that's my guard
18:50:07 <Koterpillar> glguy: thanks for reminding me
18:50:16 <glguy> Don't tell ertes! ;-)
18:51:42 <shirt> Koterpillar, glguy: thank you!!!! this channel is the best
18:52:11 <dibblego> > let es = [1,2,3,1] in [ z | x:xs <- tails es, y <- xs, z <- [(x,y),(y,x)] ]
18:52:12 <lambdabot>  [(1,2),(2,1),(1,3),(3,1),(1,1),(1,1),(2,3),(3,2),(2,1),(1,2),(3,1),(1,3)]
18:52:13 <LKoen> shirt: somewhat linked to this great article today http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
18:52:32 <glguy> Ugh, not that thing again!
18:53:02 <dibblego> haha glguy ‚ù§ that article, I mean, look at how easy the explanations are!
18:53:39 <Koterpillar> I like "the photo of¬†>>=".
18:54:27 <glguy> dibblego: the pictures certainly save us from having to explain what they are
18:54:35 <nitrix> I'm not fond of it either. The only benefit it can possibly have is to vulgarise the subject to help the beginners and put them in a situation of confidence to abolish an existing mental blocker.
18:54:55 <nitrix> If you do not suffer from a mental blocker, there are much better ways to teach these things for a beginner.
18:55:08 <LKoen> nitrix: well feel free to share these ways
18:55:31 <dibblego> NICTA/course exercises has a 100% success rate under certain conditions
18:55:32 <LKoen> most haskell courses I've read online kind of blocked at the introduction of monads and functors
18:55:57 <LKoen> they went all "eeeeeeh this is going to be complicated and not gonna make any sense but look at this syntactic sugar!!"
18:56:03 <nitrix> LKoen: It can be done here by discussing typeclasses or there are books like the Haskellbook that builds a pretty solid foundation before it gets to the meat of the subject.
18:56:04 <glguy> That post never actually teaches you what a Functor is, it only shows you a couple of examples of them
18:56:21 <Koterpillar> ^^ exactly
18:56:39 <dibblego> I agree with glguy; you either already know what a Functor is, and so you eyeroll and close it, or you don't know, and now you definitely still do not know.
18:56:43 <LKoen> at the end of the post it links to the page in learn yourself a haskell where functors are explained thoroughly
18:56:43 <Koterpillar> other tutorials start with examples too, but then explicitly generalize
18:56:55 <LKoen> dibblego: I definitely didn't know this morning, and now I know
18:57:11 <dibblego> LKoen: what exactly do you know?
18:57:29 <nitrix> Burritos.
18:57:38 <Koterpillar> railways
18:58:13 <LKoen> dibblego: what the word functor means, I guess
18:58:29 <nitrix> LKoen: What is a functor?
18:58:33 <dibblego> LKoen: I am sceptical that you would be the first counter-example in the history of my teaching this subject. Would you like to take a test?
18:59:14 <dibblego> not to be silly about it, but maybe there is a new way of teaching that I don't know :)
18:59:16 <LKoen> dibblego: as you haven't taught me, I can't be a counterexample. I am definitely willing to take a test
18:59:56 <LKoen> nitrix: well there's a typeclass called functor, and now I've got a feeling as to how it's useful
19:00:14 <dibblego> A counter-example to the claim, "this definitely fails, 100% of the time", which I have put under test numerous times.
19:00:27 * glguy wants to see the test!
19:00:27 <LKoen> okay
19:01:18 <dibblego> NICTA/course is the test
19:01:41 <dibblego> LKoen: do you ever visit .au?
19:01:50 <LKoen> I don't know what that is
19:01:53 <dibblego> Australia
19:02:32 <jmcarthur> LKoen: What kinds of things can be functors?
19:02:59 <LKoen> types
19:03:05 <nitrix> Not quite :)
19:03:25 <jmcarthur> (I'll accept "types" even though it isn't *exactly* correct.) What kinds of types?
19:03:30 <nitrix> LKoen: Some types aren't functors :)
19:04:01 <dibblego> type constructors, specifically, unary type constructors (necessary but not sufficient)
19:04:12 <LKoen> why unary?
19:04:22 <dibblego> or you'll receive a kind error
19:04:32 <dibblego> instance Functor Int where -- what goes here?
19:04:54 <LKoen> well, Maybe can have zero or one argument, it's not unary
19:05:04 <dibblego> Maybe is definitely unary
19:05:08 <jmcarthur> Maybe takes exactly one argument.
19:05:13 <LKoen> oh
19:05:18 <nitrix> :k Maybe
19:05:19 <lambdabot> * -> *
19:05:19 <jmcarthur> LKoen: You are mixing up Maybe with Just/Nothing
19:05:20 <glguy> Maybe is a type constructor, it has kind * -> *
19:05:23 <dibblego> (and to be clear, all type constructors are unary)
19:05:24 <LKoen> indeed
19:05:44 <dibblego> so, when I say unary, I really mean (* -> *)
19:06:16 <LKoen> okay
19:06:21 <nitrix> class Functor (f :: * -> *) where
19:06:51 <dibblego> newtype ToInt a = ToInt (a -> Int)
19:07:02 <dibblego> ToInt is unary, but not a functor (Data.Functor#Functor)
19:07:12 <nitrix> Thus, `f` could be substitued by `Maybe` there, but `Int` would have the wrong kind (*).
19:07:16 <LKoen> so you'd say Either is unary?
19:07:23 <glguy> Int is a type constructor
19:07:23 <glguy> It's not "unary"
19:07:23 <glguy> It has kind *
19:07:35 <glguy> Either has kind * -> * -> *, but if you apply it to a type it has the right kind
19:07:36 <jmcarthur> LKoen: Either is not a functor, even. (Either a) is.
19:07:41 <dibblego> is Int a type constructor, or a type value?
19:07:59 <glguy> type constructor
19:08:01 <mniip> well in ghc terminology Int is a TyCon
19:08:01 <nitrix> dibblego: A type value isn't a thing, as far as I know.
19:08:01 <dibblego> LKoen: yes, Either takes one argument, to return a type constructor, taking one argument, to a type
19:08:12 <dibblego> I meant to say value, sorry
19:08:18 <LKoen> okay
19:08:34 <glguy> type constructors: Int , Maybe, Either. data constructors: Nothing, Left, False
19:08:46 <mniip> but in GHC terminology Either is a type
19:08:50 <LKoen> so I take it the fmap from Either does not behave like I would have imagined
19:09:00 <jmcarthur> Actually what I said isn't necessarily true, but it is true when limiting to Functor as in Haskell.
19:09:05 <mniip> uninhabited because not a subkind of TYPE, but definitely a type
19:09:13 <dibblego> LKoen: (Either a) is the functor, and it fmaps the only way it possibly can.
19:09:21 <glguy> mniip: In Haskell terminology Int and Either are both types, and type constructors
19:09:32 <glguy> Either Int   is a type, not a type constructor
19:09:32 <mniip> "haskell terminology"?
19:09:54 <glguy> Stuff that isn't GHC internal specific
19:09:54 <nitrix> glguy: I have a question. What is going to happen with the `kind` terminology and other nice things now that we have the unification of types and kinds with Levity ?
19:10:20 <glguy> nitrix: types still have kinds, the namespaces are just mixed up
19:11:13 <nitrix> glguy: I see. So pedagogically (and theory wise) it still makes sense to talk about kinds.
19:11:21 <LKoen> dibblego: that is somewhat disappointing. I would have expected Either to be a Functor, and fmap to be defined as fmap f (Left x) = Left (f x)   fmap f (Right x) = Right (f x)
19:11:48 <nitrix> That's a Bifunctor.
19:11:57 <dibblego> LKoen: that's a binary functor, and quite different
19:11:58 <jmcarthur> LKoen: You could define a different type where fmap has that behavior, but it would not be the same as Either.
19:12:19 <dibblego> there is also this, https://github.com/ekmett/hask/blob/master/src/Hask/Category.hs#L313
19:12:21 <jmcarthur> LKoen:   data NotQuiteEither a = Left' a | Right' a
19:12:32 <LKoen> fair enough
19:13:11 <nitrix> Notice that `NotQuiteEither` has kind `* -> *` there, so it'd fit the requirements for Functor.
19:13:23 <Koterpillar> jmcarthur: that's isomorphic to (Bool, a) with its instance of Functor
19:13:25 <nitrix> Either having * -> * -> * can't.
19:13:31 <jmcarthur> Koterpillar: indeed
19:13:41 <mniip> nitrix, what does levity have to do with this?
19:14:05 <benzrf> what is levity
19:14:15 <jmcarthur> Koterpillar: a+a = 2*a
19:14:36 <nitrix> benzrf: Types to represent kinds.
19:14:40 <LKoen> dibblego: that link seems to imply that Either and (Either a) are both functors, which is in disagreement with what nitrix is saying
19:14:46 <mniip> nitrix, ummm no?
19:15:05 <jmcarthur> LKoen: That is with a different Functor type class
19:15:08 <LKoen> if Either has kind * -> (* -> *), shouldn't it be ok?
19:15:09 <mniip> it's a kinding trick to specify how values of types are represented at runtime
19:15:10 <jmcarthur> LKoen: A more general one.
19:15:11 <LKoen> oh
19:15:24 <mniip> which replaces the old-as-ever */# thing
19:15:37 <nitrix> mniip: Where is the trick?
19:15:39 <nitrix> data Levity = Lifted | Unlifted
19:15:50 <nitrix> TYPE Lifted, TYPE Unlifted.
19:15:55 <mniip> nitrix, compared to */#/OpenKind, it is a trick
19:16:16 <nitrix> ... OpenKind is ever more of a trick.
19:16:29 <jmcarthur> LKoen: Like I said earlier, technically Either is a functor, just not a legal instance of Haskell's Functor.
19:16:36 <nitrix> In fact, it's its limitations that started the discussion about levity.
19:16:41 <LKoen> ohhhh okay
19:16:42 <mniip> yes
19:17:08 <mniip> it's a solution to an incoherency problem
19:17:10 <benzrf> it's a curried functor Hask x Hask -> Hask
19:17:32 <jmcarthur> LKoen: Also, the extra instance you see there is still not the one you expected.
19:17:44 <LKoen> indeed
19:18:02 <LKoen> but it makes sense after your comment about unary
19:18:29 <mniip> nitrix, one way or another, levity is related to runtime representation of values
19:18:36 <LKoen> there'd be an fmap for the left, and an fmap for the right
19:18:39 <mniip> in more recent GHCs it is actually called RuntimeRep
19:18:46 <nitrix> mniip: I'm aware :)
19:18:52 <glguy> LKoen: Once you get settled about types that are functors having kind * -> *, you can start thinking about types with that kind which are not functors
19:19:05 <mniip> that has nothing to do with unification of kinds and types, * :: *, dependent kinding and so on
19:19:37 <LKoen> I don't know that many types
19:19:57 <mniip> LKoen, you only need two
19:20:03 <Koterpillar> you know enough from today's conversation
19:20:04 <mniip> an exponential and a unit
19:20:10 <benzrf> LKoen: types in haskell are usually either function types, primitive types (like Int#) and ADTs
19:20:14 <benzrf> (im ignoring newtypes here)
19:20:26 <dibblego> LKoen: there is functor, in category theory, and there is functor as in Data.Functor#Functor. Either is not the latter.
19:20:27 <benzrf> LKoen: so anything you see will probably be built from those
19:22:19 <nitrix> mniip: Reading the backlog to understand your intervention; is it "types to represent kinds" or the "unification" that you didn't like in my choice of words?
19:22:21 <LKoen> I meant I wasn't sure I knew of a type with kind * -> * which as not a functor
19:22:34 <dibblego> LKoen: ToInt, as above
19:23:04 <dibblego> newtype ToInt a = ToInt (a -> Int)
19:23:27 <reinh> dibblego: o/
19:23:35 <dibblego> reinh: hi
19:23:46 <LKoen> hmmmmmmm
19:24:06 <Iceland_jack>     newtype Endo a = MkEndo (a -> a)
19:24:09 <mniip> " now that we have the unification of types and kinds with Levity ?"
19:24:18 <dibblego> LKoen: try this, newtype Flipped a b = Flipped (b -> a); instance Functor Flipped where Ö for you todo
19:24:18 <mniip> nitrix, sounded like Levity is somehow involved in the unification?
19:24:36 <dibblego> instance Functor (Flipped a) -- correction
19:24:42 <Axman6> but... D:
19:25:10 <benzrf> dibblego isnt that contravariant
19:25:16 <jmcarthur> benzrf: that'
19:25:18 <dibblego> benzrf: Yes.
19:25:20 <jmcarthur> s the point
19:25:24 <mniip> still not haskell's Data.Functor.Functor
19:25:26 <dibblego> Endo is invariant
19:26:25 <LKoen> instance Functor (Flipped a) where fmap f (Flipped h) = Flipped (h . b)
19:26:46 <nitrix> mniip: I see where it could be misleading. Then no, the Levity data type isn't what's special.
19:26:56 <Koterpillar> LKoen: what's b?
19:27:09 <LKoen> oops
19:27:11 <dibblego> LKoen: Not in scope: b
19:27:29 <Iceland_jack>     (a -> a') -> ([a] -> [a'])
19:27:30 <Iceland_jack> for 'ToInt' we flip first arrow
19:27:30 <Iceland_jack>     (a <- a') -> (ToInt a -> ToInt a')
19:27:30 <Iceland_jack> for 'Either' final arrow becomes '~>'
19:27:32 <LKoen> instance Functor (Flipped a) where fmap f (Flipped h) = Flipped (h . f)
19:27:33 <Iceland_jack>     (a -> a') -> (Either a ~> Either a')
19:27:44 <dibblego> LKoen:  Couldn't match type ëbí with ëaí
19:27:50 <Iceland_jack> where (f ~> g) is 'forall x. f x -> g x'
19:28:05 <LKoen> dibblego: fine, I'm grabbing a paper and pen
19:28:07 <Iceland_jack> It's all the same thing (sans Endo)
19:28:21 <mniip> @let newtype Flipped a b = Flipped (b -> a)
19:28:22 <lambdabot>  Defined.
19:28:29 <mniip> :t \f (Flipped h) -> Flipped (h . f)
19:28:31 <lambdabot> (b -> t) -> Flipped a t -> Flipped a b
19:28:34 <dibblego> LKoen: sure, don't spend too long, because it's actually impossible, but try refuting that so you can see why
19:28:36 <mniip> LKoen, ^
19:28:46 <LKoen> oh
19:29:25 <ertes> :t \x -> if isJust x then Just (fromJust x + 5) else Nothing  -- guvf vf n fbpvny rkcrevzrag
19:29:26 <lambdabot> Num a => Maybe a -> Maybe a
19:30:41 <mniip> ertes, jung abj?
19:31:41 <mniip> ertes,  hfr sznc (+5) :)
19:32:04 <ertes> mniip: urur
19:36:40 <LKoen> dibblego: okay, writing down the expected type of fmap makes it apparent that something is wrong
19:37:33 <pumita> is there a synonym for `cabal run` but for stack?
19:37:36 <dibblego> LKoen: right, you can't get it to work out. However, if I made this type-class; class Contravariant f where contramap :: (a -> b) -> f b -> f a, then instance Contravariant (Flipped a) where, this will work out.
19:38:14 <LKoen> okay
19:39:29 <glguy> pumita: No, but people have made such things. There's stack exec but it needs an executable argument and doesn't rebuild like cabal run
19:40:14 <LKoen> well thank you all so much for your help tonight
19:40:30 <glguy> stack works at a lightly higher "level" than normal cabal, so it probably makes sense that this is missing. cabal commands are run in the context of some local package, stack commands are run in a whole environment, there isn't a main package
19:41:03 <mniip> type Stack = 'Cabal
19:41:17 <pumita> thanks
20:06:43 --- mode: ChanServ set +o shachaf
20:07:03 --- mode: shachaf set +b-o isocliff*!*@*$##fix_your_connection shachaf
20:20:06 <jle`> pumita: https://hackage.haskell.org/package/stack-run
20:20:19 <jle`> stack lets you define utilities as stack-foo, so you can type "stack run ..."
20:23:30 <pumita> thanks jle`
20:33:53 <sleblanc> :t join
20:33:55 <lambdabot> Monad m => m (m a) -> m a
20:33:57 <sleblanc> :t join (,)
20:33:59 <lambdabot> a -> (a, a)
20:34:18 <sleblanc> a comes in, a comes out, a comes out, you can't explain this
20:34:46 <Koterpillar> > join (,) 1
20:34:48 <lambdabot>  (1,1)
20:34:54 <Koterpillar> oh well, what would I be expecting
20:39:52 <Iceland_jack>     M (M a) -> M a
20:39:53 <Iceland_jack> replace M by (Arr r)
20:39:53 <Iceland_jack>     Arr r (Arr r a) -> Arr r a
20:39:53 <Iceland_jack> write (Arr) as infix (->)
20:39:56 <Iceland_jack>     (r -> r -> a) -> (r -> a)
20:40:07 <jle`> @free f :: a -> (a, a)
20:40:07 <lambdabot> $map_Pair g g . f = f . g
20:40:26 <shachaf> Good theorem.
20:40:36 <jle`> a+ solid theorem
20:41:01 <jle`> would theorize again
20:41:58 <Iceland_jack> :t \f g -> [bimap g g . f, f . g]
20:42:00 <lambdabot> Bifunctor p => (b -> p b b) -> (b -> b) -> [b -> p b b]
20:42:16 <Iceland_jack> ghci> :t \f g -> [bimap @(,) g g . f, f . g]
20:42:16 <Iceland_jack> \f g -> [bimap @(,) g g . f, f . g]
20:42:16 <Iceland_jack>   :: (a -> (a, a)) -> (a -> a) -> [a -> (a, a)]
20:45:33 <jle`> @check \g x -> join (,) (g x) == bimap g g (join (,) x)
20:45:35 <lambdabot>  +++ OK, passed 100 tests.
20:47:40 <Iceland_jack> I believe that would default to ()
20:47:51 <jle`> @check \x -> fst x == snd x
20:47:53 <lambdabot>  +++ OK, passed 100 tests.
20:48:16 <jle`> @check \g x -> join (,) ((g :: Double -> String) x) == bimap g g (join (,) x)
20:48:18 <lambdabot>  +++ OK, passed 100 tests.
20:48:27 <Iceland_jack> Huh I wonder why these have different types
20:48:27 <Iceland_jack> :t (\f g -> [bimap g g . f, f . g]) (join (,))
20:48:28 <lambdabot> (b -> b) -> [b -> (b, b)]
20:48:38 <Iceland_jack> and
20:48:39 <Iceland_jack> :t \g -> [bimap g g . join (,), join (,) . g]
20:48:40 <lambdabot> (a -> b) -> [a -> (b, b)]
20:49:27 <jle`> my first instinct would be that the two join (,)'s in the second case have different types
20:50:02 <Iceland_jack> You're probably right
20:50:04 <Iceland_jack> :t \g -> let Œ¥ = join (,) in [bimap g g . Œ¥, Œ¥ . g]
20:50:05 <lambdabot> (c -> d) -> [c -> (d, d)]
20:50:35 <jle`> ah yeah, in the first case, the join goes before g and after g
20:51:02 <jle`> the same join, so it all has to be the same type
20:51:07 <Iceland_jack> Yes
20:51:08 <jle`> *same join (,)
20:52:19 <jle`> in the second case the first time, join (,) is (a -> (a, a)) the first time and (b -> (b, b)) the second time
20:52:33 <Iceland_jack>         |-- A --g--> B                     |-- B
20:52:34 <Iceland_jack>     A --Œ¥                VS   A --g--> B --Œ¥
20:52:34 <Iceland_jack>         |-- A --g--> B                     |-- B 
20:52:34 <Iceland_jack>  
20:52:46 <sleblanc> nice graph
20:53:00 <Iceland_jack> sleblanc: I get paid per ASCII art
20:53:14 <Iceland_jack> this is shrimp money
20:53:26 <parsnipM_> if i had a nickel for every time i wrote Int -> Int
20:53:44 * Iceland_jack . o O ( is allergic )
20:54:02 <Iceland_jack> parsnipM_: It's Haskell's "for (int i = 0; i < ...; ++i) {"
20:54:03 <sleblanc> now, I'm looking for something (m a, m b) -> m (a,b)‚Ä¶
20:54:17 <Iceland_jack> sleblanc: You can find it in the lens library of course
20:54:19 <adarqui> i'm trying to wrap my 'RWST' type with StateStackT.. i have everything compiling/working, except for one thing.. using 'get/put' inside of RunnerM. anyone have any idea? here's my type: RWST RunnerReader RunnerWriter RunnerState (StateStackT StackState IO) .... and here's how I enter those transformers: runStateStackT (runRWST go defaultRunnerReader defaultRunnerState) defaultStackState ... so all of that works except using get/put in a function, such as: blah :: Ru
20:54:30 <ggVGc> parsnipM_: then you'd have multiple nickles.
20:54:49 <Koterpillar> do nickels form a monoid?
20:54:52 <geekosaur> adarqui, that chopped off at "such as: blah :: Ru"
20:54:56 <Iceland_jack> sleblanc: But you can also use "Data.Bitraversable"
20:54:59 <Iceland_jack> :t bisequence
20:55:00 <lambdabot>     Not in scope: ‚Äòbisequence‚Äô
20:55:01 <lambdabot>     Perhaps you meant one of these:
20:55:01 <lambdabot>       ‚Äòsequence‚Äô (imported from Data.Traversable),
20:55:03 <Iceland_jack> ghci> :t bisequence @(,)
20:55:03 <Iceland_jack> bisequence @(,) :: Monad m => (m a, m b) -> m (a, b)
20:55:08 <adarqui> ah, sorry.. such as: blah :: RunnerM (), blah = st <- get ...
20:55:14 <jle`> sleblanc: if you do a refactor, you can just use liftA2 (,) x y, or (,) <$> x <*> y
20:55:19 <jle`> where x :: m a, y :: m b
20:55:20 <adarqui> im trying to get/put state inside of blah
20:55:25 <jle`> :t uncurry (liftA2 (,))
20:55:26 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
20:55:35 <geekosaur> if you wanted the state from the wrapped StateStackT, you need to use lift
20:55:39 <adarqui> because when I get/put state, i can use StateStackT's save/restore functions
20:56:07 <Iceland_jack> Another way of writing with Applicative is
20:56:07 <Iceland_jack> ghci> :t sequenceAOf (both @(,))
20:56:08 <Iceland_jack> sequenceAOf (both @(,)) :: Applicative f => (f b, f b) -> f (b, b)
20:56:08 <geekosaur> unlifted get / put will be the ones from the RWST
20:56:26 <adarqui> geekosaur: ya i've tried that.. I get this: Couldn't match type ‚ÄòControl.Monad.Trans.State.Lazy.StateT StackState m0‚Äô with ‚ÄòStateStackT StackState IO‚Äô
20:56:29 <jle`> adarqui: you can ditch get/put from RWST and just use the polymorphic interface offered by mtl, right?
20:56:47 <jle`> they have the same names too for some reason
20:56:49 <adarqui> jle`: AH.. i think that might be it
20:57:06 <jle`> 'get' and 'put' from mtl work for more than just StateT or RWST, they work for anything that implements the MonadState interface
20:57:27 <adarqui> geekosaur, jle`  thanks. jle` i'll make sure im using get/put from MTL, that would explain the Lazy.StateT error in the output
20:57:30 <adarqui> i think
20:57:33 <adarqui> ya
20:57:41 <jle`> but if you use get/put from mtl, you need to write a MonadState instance for whatevr type you're using
20:57:42 <adarqui> StateStackT uses MonadState.. nice
20:57:55 <jle`> or you can possibly have GHC derive one for you
20:58:31 <adarqui> bam.. that was it
20:58:45 <adarqui> i was using Control.Monad.Trans.State.Lazy instead of Control.Monad.State.Lazy
20:58:45 <adarqui> :D
20:58:47 <adarqui> thanks folks!
20:58:50 <jle`> np!
20:59:02 * hackagebot binary-list 1.1.1.2 - Lists of length a power of two.  https://hackage.haskell.org/package/binary-list-1.1.1.2 (DanielDiaz)
20:59:20 <jle`> it is potentially confusing that the API for the concret StateT uses the same identifiers/names as the MonadState methods
21:09:02 * hackagebot coordinate 0.1.0 - A representation of latitude and longitude  https://hackage.haskell.org/package/coordinate-0.1.0 (TonyMorris)
21:14:16 <ertes> is the base64-bytestring library still the state of the art?  last release was in 2013
21:14:35 <ertes> (why is base64 encoding not in the bytestring library anyway?)
21:27:40 <mjrosenb> ertes: well, after you've decided on base64, you still need to choose an encoding for the characters themselves :-p
21:31:41 <nshepperd> hmm, encode should then really be ByteString -> Text there shouldn't it?
21:32:36 <Iceland_jack> Or a hypothetical 'ByteString -> Radix64'
21:33:41 <nshepperd> Word6 lol
21:34:04 <Iceland_jack> https://hackage.haskell.org/package/OddWord-1.0.1.0/docs/Data-Word-Odd.html ;)
21:35:49 <Iceland_jack> There are multiple ways of encoding that representation, simple ASCII, a dependent representation that only allows valid Base64 (valid padding etc.) I'm just rambling
21:36:00 <ertes> mjrosenb: there is a fairly standard encoding using [A-Za-z0-9+/]
21:37:32 <ertes> base64 encoding is such a common thing to do with ByteString in many applications, and the codec is really small‚Ä¶  IMO it should be in the bytestring library
21:38:26 <mjrosenb> ertes: personally, I like my base64 encoded in ebcdic.
21:39:12 <mjrosenb> UTF-EBCDIC if I'm feeling like being forwards-compatible.
21:39:23 <mjrosenb> not that it makes a difference for base64 though.
21:40:07 <nshepperd> i assume that the base64-bytestring library uses utf-8 (ie. ascii) encoding since that's what you usually want
21:40:12 <sleblanc> so, forever $ putStrLn "Hello, World!" is fun, while forever putStrLn "Hello, World!" is not as fun, and goes against the saying "it typechecks; ship it!"
21:40:37 <mjrosenb> :t forever
21:40:38 <lambdabot> Monad m => m a -> m b
21:40:46 <sleblanc> Applicative f...
21:40:57 <nshepperd> :t forever putStrLn
21:40:58 <lambdabot> String -> b
21:41:16 <sleblanc> Is lambdabot "robust"?
21:41:33 <mjrosenb> sleblanc: you can probably assume that you can't break lambdabot.
21:41:38 <nshepperd> heh
21:41:39 <Iceland_jack> sleblanc: It's instance of "(->) _" coming back to Weirdville 
21:41:44 <sleblanc> > forever putStrLn "Hello, World!"
21:41:50 <lambdabot>  mueval: ExitFailure 1
21:42:02 <Ralith> I wouldn't describe lambdabot as robust, but the haskell evaluation interface has certainly been tested to hell at this point
21:42:50 <mjrosenb> so... that evaluates to putStrLn (putStrLn (putStrLn ... "Hello, World!")))?
21:42:51 <Iceland_jack>     forever @((->) _)             :: (t -> a) -> (t -> b)
21:42:51 <Iceland_jack>     forever @((->) _) print       :: Show a =>    a -> b)
21:42:52 <Iceland_jack>     forever @((->) _) print 10    ::                   b
21:43:56 <nshepperd> @src forever
21:43:56 <lambdabot> forever a = let a' = a >> a' in a'
21:44:01 <sleblanc> Iceland_jack, how do you generate these?
21:44:21 <Iceland_jack> Iwrite them out by hand
21:44:34 <mjrosenb> Iceland_jack: :-(
21:44:48 <sleblanc> ok. what does the @(‚Ä¶) notation mean?
21:44:52 <mjrosenb> > forever f a
21:44:54 <lambdabot>      No instance for (FromExpr a0) arising from a use of ‚Äòf‚Äô
21:44:54 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
21:44:54 <lambdabot>      Note: there are several potential instances:
21:45:04 <mjrosenb> > forever f
21:45:05 <Iceland_jack> It's using TypeApplications from the latest GHC version (GHC 8)
21:45:06 <lambdabot>      Could not deduce (FromExpr (m a0))
21:45:06 <lambdabot>      from the context (Monad m, FromExpr (m a))
21:45:06 <lambdabot>        bound by the inferred type for ‚Äòe_1‚Äô:
21:46:04 <Iceland_jack> mjrosenb: Why ':-('
21:46:35 <Iceland_jack> If you're interested what happens to 'forever' specialized to ((->) _) it's basically an infinite loop afaik
21:46:35 <mjrosenb> Iceland_jack: because it seems like it would be a neat (and useful) thing to automate.
21:46:55 <Iceland_jack> I agree :) if someone makes one please notify me
21:47:06 <mjrosenb> Iceland_jack: well, yes, that is evident from how it behaves, but I'm interested in more detial.
21:47:18 <Iceland_jack>       forever a
21:47:18 <Iceland_jack>     = a *> forever a
21:47:19 <Iceland_jack>     = forever a
21:47:26 <Iceland_jack> is that enough detail? :)
21:47:32 <mjrosenb> also, what is the _ in the type there? is that a new syntax, or it that special for TypeApplications?
21:47:47 <sleblanc> @src fix
21:47:48 <lambdabot> fix f = let x = f x in x
21:47:52 <ertes> > readFile "/etc/shadow"
21:47:54 <lambdabot>  *Exception: /etc/shadow: openFile: permission denied (Permission denied)
21:48:01 <sleblanc> @src fixIO
21:48:01 <lambdabot> Source not found. My mind is going. I can feel it.
21:48:02 <Iceland_jack> That's from partial type signatures
21:48:13 <mniip> wait what
21:48:16 <mniip> lambdabot does IO now?
21:48:30 <sleblanc> @src System.IO.fixIO
21:48:30 <lambdabot> Source not found. :(
21:48:35 <mniip> :t readFile
21:48:36 <lambdabot> FilePath -> IO String
21:48:36 <mjrosenb> are those new in 8.0, or have I just not realized that one of my most wanted features has been in GHC for a while?
21:48:37 <kadoban> Yeah, that's what I was wondering ... wtf.
21:49:01 <Iceland_jack> mjrosenb: There were since previous/penultimate version
21:49:11 <jle`> i've been using them for a while now! it's great :D
21:49:39 <mniip> > readFile "/etc/shadow"
21:49:40 <jle`> i can't imagine a world without them anymore
21:49:40 <lambdabot>  <IO [Char]>
21:49:43 <Iceland_jack> https://downloads.haskell.org/~ghc/master/users-guide/glasgow_exts.html#ghc-flag--XPartialTypeSignatures 
21:49:46 <mniip> wtf
21:49:56 <Iceland_jack> Yes, I couldn't go back either
21:50:15 <jle`> too bad they're not in lambdabot yet
21:50:22 <Iceland_jack> ghci> :t forever :: (_ -> _) -> _
21:50:22 <mniip> either ertes has got some kind of privs in lambdabot, or godspeed int-e
21:50:22 <Iceland_jack> forever :: (_ -> _) -> _ :: (t -> a) -> t -> b
21:50:28 <jle`> i can finally stop using `asTypeOf` etc.
21:50:39 <Iceland_jack> That's one way to get the ((->) _) instance with partials
21:50:56 <sleblanc> > readFile "/etc/machine-id"
21:50:57 <lambdabot>  <IO [Char]>
21:51:05 <jle`> > readFile "/etc/shadow"
21:51:07 <lambdabot>  <IO [Char]>
21:51:10 <jle`> oops
21:51:42 <Iceland_jack>     (*>) :: (r -> a) -> (r -> b) -> (r -> b)
21:51:42 <Iceland_jack> there is only one way to implement that
21:51:51 <Iceland_jack>     _ *> rb = rb
21:52:33 <Iceland_jack> so 
21:52:33 <Iceland_jack>     forever a = a *> forever a
21:52:33 <Iceland_jack> becomes
21:52:33 <Iceland_jack>     forever @((->) _) a = forever a
21:52:36 <Iceland_jack>  
21:53:05 <ertes> mniip: lambdabot has a unicode vulnerability
21:53:09 <ertes> > readFile "/etc/passwd"
21:53:11 <lambdabot>  *Exception: /etc/passwd: openFile: permission denied (Permission denied)
21:53:12 <ertes> > readFile "/etc/hosts"
21:53:13 <lambdabot>  *Exception: /etc/hosts: openFile: permission denied (Permission denied)
21:53:25 <jle`> i thot i copy-pasted your unicode
21:53:33 <jle`> > readFile "/etc/hosts"
21:53:35 <lambdabot>  <IO [Char]>
21:53:38 <jle`> :(
21:53:59 <mjrosenb> > readFile "/proc/self/mem"
21:54:01 <lambdabot>  <IO [Char]>
21:54:04 * hackagebot coordinate 0.1.1 - A representation of latitude and longitude  https://hackage.haskell.org/package/coordinate-0.1.1 (TonyMorris)
21:54:18 <sleblanc> > readfile "/dev/stdin"
21:54:20 <lambdabot>      Not in scope: ‚Äòreadfile‚Äô
21:54:20 <lambdabot>      Perhaps you meant one of these:
21:54:20 <lambdabot>        ‚ÄòreadFile‚Äô (imported from Prelude),
21:54:25 <sleblanc> > readFile "/dev/stdin"
21:54:27 <lambdabot>  <IO [Char]>
21:54:35 <Koterpillar> > readFile "/etc/passwd"
21:54:37 <lambdabot>  <IO [Char]>
21:55:10 <ertes> alright people, i'm just joking‚Ä¶  i was privmsging lambdabot with a custom readFile =)
21:55:39 <mniip> but how does it differentiate
21:55:41 <jle`> i figured, but i hoped to catch you before you ninja undefined :'(
21:55:41 <Koterpillar> so contexts are per person, not per chat?
21:56:08 <ertes> @import Prelude hiding (readFile)
21:56:09 <ertes> @let data X = X String
21:56:09 <lambdabot> Unknown command, try @list
21:56:09 <ertes> @let instance Show X where show (X str) = "*Exception: " ++ str ++ ": openFile: permission denied (Permission denied)"
21:56:09 <ertes> @let readFile = X
21:56:10 <lambdabot>  Defined.
21:56:11 <lambdabot>  Defined.
21:56:12 <lambdabot>  Defined.
21:56:16 <ertes> whoops
21:56:27 <ertes> @let import Prelude hiding (readFile)
21:56:28 <lambdabot>  Defined.
21:56:32 <ertes> > readFile "blah"
21:56:33 <lambdabot>  *Exception: blah: openFile: permission denied (Permission denied)
21:57:03 <mjrosenb> ertes: that was evil
21:57:06 <mjrosenb> ertes: and awesome.
21:57:29 <sleblanc> I guess the answer is no: can I "unload" class instances, to avoid the kind of problem that happens with `forever putStrLn "Hello, World!"` ?
21:57:49 <sleblanc> I guess what I am asking for does not make much sense
21:57:58 <mniip> ohhh
21:58:06 <mniip> I didn't know you can unimport stuff
21:58:24 <ertes> mniip: you can't, but lambdabot does not actually import Prelude explicitly
21:58:27 <nshepperd> I would have used one of those identical looking unicode characters, like cyrillic i to define a custom readFile
21:58:31 <mniip> well I see what you mean
21:58:33 <ertes> mniip: so you can import it hiding stuff
21:58:37 <sleblanc> But I feel like this issue is a loaded gun
21:58:37 <mniip> yes
21:59:09 <mniip> > "r–µ–∞dfil–µ"
21:59:10 <lambdabot>  "r\1077\1072dfil\1077"
21:59:21 <ertes> nshepperd: but then someone with a terrible client or a terrible font would have noticed it =)
21:59:43 <ertes> also i think lambdabot doesn't have -XUnicodeSyntax enabled
21:59:50 <ertes> @let bl√§h = True
21:59:51 <lambdabot>  Defined.
21:59:54 <ertes> > bl√§h
21:59:55 <mniip> sure does
21:59:55 <lambdabot>  True
21:59:56 <ertes> oh
22:00:07 <mniip> I wonder tho
22:00:08 <sleblanc> "let h√©ƒºƒº√∂ = 123
22:00:16 <sleblanc> @let h√©ƒºƒº√∂ = 123
22:00:17 <lambdabot>  Defined.
22:00:29 <sleblanc> Interesting
22:00:29 <mniip> :t undefined :: forall —ã. —ã
22:00:31 <lambdabot> K
22:00:40 <mniip> ‡≤†_‡≤†
22:00:48 <mniip> how does that work now
22:00:50 <ertes> > let x :: ‚àÄ a. a -> a; x = id in x 5
22:00:51 <lambdabot>  5
22:00:58 <ertes> lovely
22:01:16 <Koterpillar> @let üåØ = (>>=)
22:01:17 <mniip> :t undefined :: forall —é–Ω–∏–∫–æ–¥. —é–Ω–∏–∫–æ–¥
22:01:17 <lambdabot>  Parse failed: Illegal character ''\127791''
22:01:18 <lambdabot> N=8:>4
22:01:30 <Koterpillar> boo, no burrito monads
22:01:51 <Koterpillar> @let üåÆ = (>>=)
22:01:51 <lambdabot>  Parse failed: Illegal character ''\127790''
22:02:27 <mjrosenb> > let (a‚Äãb, ab) = (4,5) in (ab, a‚Äãb)
22:02:28 <lambdabot>  <hint>:1:7: lexical error at character '\8203'
22:02:39 <sleblanc> http://www.fileformat.info/info/unicode/char/1f32f/index.htm
22:02:46 <ertes> mniip: on april 1st i replaced all the usual IO stuff by non-IO stuff seemingly with actual side effects‚Ä¶  unfortunately nobody noticed =)
22:03:07 <ertes> readFile :: FilePath -> String  -- like this
22:03:41 <ertes> (it would just 'throw' an IO exception)
22:03:42 <sleblanc> @let
22:03:42 <lambdabot>  Define what?
22:04:58 <mniip> @let data –ü a = –ü
22:04:59 <lambdabot>  Defined.
22:05:08 <mniip> :t –ü :: –ü wows
22:05:09 <lambdabot> forall (k :: BOX) (wows :: k).  wows
22:05:35 <Iceland_jack> mniip: I knew we had Type::Type but I never expected Pi::Pi ;)
22:06:20 <mniip> this isn't looking good because
22:07:16 <mniip> @let data –ê a b = A a b
22:07:17 <lambdabot>  Defined.
22:07:25 <mniip> @let data QUIT = QUIT
22:07:26 <lambdabot>  Defined.
22:07:32 <mniip> :t –ê QUIT (–ê () ())
22:07:33 <lambdabot> Not in scope: data constructor ‚Äò–ê‚Äô
22:07:34 <lambdabot> Not in scope: data constructor ‚Äò–ê‚Äô
22:07:34 <kick> <
22:07:45 <nshepperd> > put–ÖtrLn "good news everyone!"
22:07:46 <lambdabot>  good news everyone!
22:07:52 <Guest50785> >
22:07:57 <mniip> oh right, wrong symbol
22:08:03 <nshepperd> hehe
22:08:15 <mniip> @let data –ä a b = –ä a b
22:08:16 <lambdabot>  Defined.
22:08:22 <mniip> :t –ä QUIT (–ä () ())
22:08:33 <Guest50785> hey guys i am new in here and i don't know whats going on :P
22:09:16 <nshepperd> now that's a unicode vulnerability
22:09:21 <sleblanc> shiiii
22:09:38 <ertes> nice
22:09:44 <sleblanc> Guest50785, lambdabot is a bot that interprets commands on the chat, and the guys are fiddling with it
22:10:08 <Guest50785> what can we do here
22:10:19 <alercah> mniip: what the...
22:10:21 <mniip> @undefine
22:10:22 <Guest50785> can someoneguide me
22:10:26 <lambdabot> Undefined.
22:10:55 <sleblanc> > eval me
22:10:56 <Guest50785> <>
22:11:01 <lambdabot>      Not in scope: ‚Äòeval‚Äô
22:11:04 <sleblanc> ^ Guest50785
22:11:07 <lambdabot>      Perhaps you meant ‚Äòival‚Äô (imported from Data.Number.Interval)    Not in ...
22:11:28 <sleblanc> > getSum $ Sum 1 <> Sum 2
22:11:36 <Guest50785> got you sleblanc
22:11:39 <lambdabot>  3
22:12:01 <mniip> :t –ä MODE Lambdabot Dg (–ä () () () ())
22:12:10 <mniip> > aand it is now deafened
22:12:28 <sleblanc> whaaa
22:12:47 <Guest50785> kick
22:13:07 <mniip> this is a serious attack vector
22:13:17 <Ralith> huh.
22:13:23 <mniip> I wouldn't want it to be open to everyone
22:13:33 <glguy> If you keep exploiting it you're going to earn a ban 
22:13:34 <Ralith> then you probably shouldn't have used it in public
22:13:44 <mniip> well I was messing with it and it worked :(
22:13:50 <mniip> 0/10 did not expect
22:14:02 <ertes> deafening it was a good idea
22:15:04 <ertes> probably not as bad as remote code execution or IO access, but being able to send arbitrary IRC commands could already do some harm
22:15:24 <mniip> someone could have stolen the nickserv account
22:15:27 <glguy> We wouldn't need a deaf lambda bot if someone wasn't demonstrating the problem in public
22:15:41 <mniip> ns set password, ns set email
22:15:57 <nshepperd> judging by the output there, it's reencoding messages as.. utf-16?
22:16:11 <mniip> no it's taking the unicode character mod 256
22:17:23 <mniip> glguy, :(
22:17:26 <nshepperd> oh, that makes sense with char8. why does –ä become two bytes though?
22:17:30 <sleblanc> > putStrLn "What's going on, guys?"
22:17:33 <mniip> nshepperd, only one
22:17:40 <mniip> the server is okay with just \n
22:18:09 <ggVGc> how do I rearrange these cases and if's in a better way? https://gist.github.com/6e3afb5c523f8319d3cd9ee65715bc07
22:18:15 <nshepperd> mniip: i'm seeing an extraneous 0xd0 in the output
22:18:32 <mniip> nshepperd, which output in particular?
22:19:25 <nshepperd> oh hold on, i'm just confused
22:19:39 <nshepperd> you're right
22:19:59 <ertes> this is a reminder that haskell does not magically make all your code secure‚Ä¶  you still need to be careful =)
22:22:26 <mniip> glguy, I am indeed sorry, I was not having any malicious intent and as you see I prevented others from exploiting the vulnerability
22:24:28 <kadoban> Has anyone notified whoever maintains lambdabot that it has a problem yet?
22:25:03 <mniip> int-e has been highlighted
22:25:12 <sleblanc> meanwhile an ircop could kill lambdabot so that it will reconnect
22:25:12 <kadoban> That's good
22:25:13 <mniip> earlier
22:25:26 <mniip> sleblanc, what for
22:25:30 <sleblanc> to restore it
22:25:44 <mniip> "restore"? into a state where anyone can execute arbitrary irc commands?
22:25:48 <ertes> sleblanc: that would also restore the vulnerability
22:26:08 <kadoban> Not sure restoring it is a good idea ... preventing it from reconnecting sounds better, temporarily.
22:26:27 <mniip> I think it's good as it is right now
22:26:53 <mniip> no need to hand out klines
22:28:51 <nshepperd> o_O lambdabot filters out \CR but not \n from the output?
22:29:12 <mniip> does it filter \r ?
22:29:32 <ertes> that would be funny, because CR and LF are actually equivalent in terms of IRC
22:29:45 <nshepperd> \CR is \r, yeah
22:30:00 <nshepperd> at https://github.com/lambdabot/lambdabot/blob/master/lambdabot-core/src/Lambdabot/IRC.hs : 85
22:30:23 <ertes> ouch
22:30:31 <ertes> don't use String for network stuff!
22:32:09 <ertes> i wonder why it doesn't use the 'irc' library
22:32:40 <ggVGc> I want to store a bunch of things with a "start point" and a length, both which are integers, and I want these pieces to never be able to "overlap". What's my best choice of data structure?
22:32:54 <ggVGc> I was gonna use a map where the key is the start index, and the value is the length
22:32:55 <mjrosenb> I would not be surprised if lambdabot were older than the irc library.
22:32:58 <ggVGc> but that doesn't prevent overlaps
22:33:29 <ertes> mjrosenb: lambdabot was around when the irc library was itself using String
22:33:31 <kadoban> ggVGc: Interval tree I guess? You'd just wrap it and check for intersection before you insert
22:33:55 <ertes> mjrosenb: but not using 'irc' in favour of a square wheel seems to be counterproductive
22:34:07 <ertes> even back then
22:34:08 <KaneTW> i think lambdabot is older than 'orc'
22:34:10 <KaneTW> irc*
22:35:16 <nshepperd> oh, maybe that's dead code
22:35:41 <nshepperd> github is not great for reading code
22:35:42 <KaneTW> irc-0.1 hackage is '07
22:35:56 <ertes> ggVGc: use an interval map‚Ä¶  the fingertree library has an implementation
22:36:03 <KaneTW> github lambdabot is at least '05
22:36:27 <KaneTW> oct 29 '04 and that's "import latest lambdabot"
22:36:35 <ertes> ggVGc: alternatively there is also the IntervalMap library, but i don't know what data structure it uses
22:36:58 <ertes> (probably regular Map)
22:38:10 <kadoban> An interval tree is just an augmented BST, so yeah it's probably just an interval tree based on Data.Map, if I had to guess.
22:38:40 <ertes> well, there is a 'containers' dependency‚Ä¶  that's what motivated my guess
22:39:28 <nshepperd> ah yes, the damning import of Data.ByteString.Char8 in Lambdabot/Plugin/IRC/IRC.hs
22:40:35 <nshepperd> bah, at least if we had a Data.ByteString.Ascii that could have the decency to filter things properly
22:41:40 <ertes> IRC is in essence a binary protocol and should be treated as such
22:42:01 <ertes> text is only an abstraction in IRC
22:42:12 <Maxdamantus> strings should normally be handled as binary things anyway.
22:42:41 <Maxdamantus> Having them split into unicode codepoints is fairly meaningless.
22:42:41 <kadoban> Depends on what context, they shouldn't really internally. But as they come in they're essentially binary things, yes.
22:43:02 <ertes> in fact IRC does not even understand text encodings‚Ä¶  it's from a time when C was the de facto language for networking, and "character" and "byte" were the same thing to most people, particularly protocol inventors
22:43:21 <Maxdamantus> They should be internally.
22:43:34 <Maxdamantus> as well as interfacially.
22:44:19 <ggVGc> ertes: thanks, that's exactly what I needed!
22:44:34 <sleblanc> Maxdamantus, not necessarily. If you know you are dealing with text, you can re-encode everything in memory as UTF-16, UTF-24 or UTF-32, while with Char bytestrings you would gain nothing by doing so
22:45:14 <kadoban> Maxdamantus: If you're messing around with strings of character data inside your program, there's no reason to use something like ByteString internally, unless you just plain don't care what the contents is at all and you're just proxying it. You do a kind of sandwhich thing, ideally, where the input is some encoding that you decode, and then to output you re-encode to whatever bytestream is appropriate.
22:45:29 <Maxdamantus> sleblanc: you can transcode from UTF8 to something else regardless.
22:45:32 <kadoban> Treating it as binary at all levels is ... not good.
22:46:02 <Maxdamantus> kadoban: what level should it be treated at then, and what's the advantage?
22:46:33 <ertes> at some point in the API a ByteString is taken, and that one contains a message to be sent‚Ä¶  that message, by IRC standards, is completely binary, but some bytes must be removed/replaced to make it secure
22:46:36 <Maxdamantus> Should 'a' followed by U+301 be considered one character?
22:47:21 <kadoban> Maxdamantus: It should be abstracted as actual characters. Data.Text is a decent example. I don't have to care what encoding that's in ... for good reason. It's not perfect, but it's pretty good. And it's quite a bit better than just using ByteString everywhere.
22:47:23 <ertes> B.map (\x -> if x == 0 || x == 10 || x == 13 then 63 else x)
22:47:33 <ertes> there is no sensible way to handle this with IRC
22:47:45 <ertes> it's neither really binary, nor is it really text
22:48:05 <ertes> it's basically a half-binary half-pseudo-text encoding
22:48:10 <Maxdamantus> Again, it's not clear what "actual characters" are.
22:48:15 <ertes> exactly
22:48:33 <Maxdamantus> They're certainly not unicode codepoints, just as they're not octets in a UTF8 sequence.
22:48:48 <ertes> they aren't even really "octets"
22:48:59 <ertes> they are "octets except these particular characters"
22:49:03 <ertes> uhm
22:49:04 <nshepperd> well, at least the user messages built into your application should be treated as text
22:49:05 <ertes> numbers
22:49:31 <ertes> IRC is weird in many ways‚Ä¶  in standard IRC the nicknames [blah] and {blah} are treated as equal
22:50:02 <alercah> that's because [ is uppercase {, duh
22:50:14 <nshepperd> so that they can be encoded properly and the users don't just get nonsense depending on whether you built the program in whatever locale the channel "is"
22:50:52 <ertes> and it's ridiculous in many other ways:  the byte 0 is not allowed in IRC message‚Ä¶  reason: C string handling sucks
22:50:52 * Maxdamantus would think it's because Jarkko Oikarinen used a keyboard layout without []
22:52:12 <Maxdamantus> nshepperd: if you want to avoid the nonsense situations you're talking about, you need to transcode.
22:52:26 <nshepperd> the main reason to keep things as text in your application is so that you're not blindly transcoding ByteString -> ByteString and forgetting whether or not you've already encoded
22:53:01 <Maxdamantus> nshepperd: whether it transcodes to an array of unicode codepoints or UTF8 octets is fairly irrelevant.
22:53:04 <nshepperd> Text vs ByteString is type safe
22:53:15 <ertes> nshepperd: text handling in IRC is fine, but it should be on a higher level than IRC‚Ä¶  text is an abstraction over raw bytes here
22:54:29 <ertes> nshepperd: in other words, PRIVMSG *should* take a ByteString (and filter it appropriately)
22:54:36 <nshepperd> you can't "transcode" to an array of unicode codepoints
22:55:06 <nshepperd> that's decoding. it's conceptually a completely different thing to an encoded string of bytes
22:55:34 <ggVGc> so, IntervalMap has toList and fromList. Can I somehow easily get a Binary instance from this?
22:56:13 <ertes> ggVGc: you could just use the Binary instance of the list
22:57:14 <ggVGc> ertes: yeah, I was wondering if I could have it auto-generated or if I just need to write the Binary instance in terms of the list
22:57:41 <ertes> ggVGc: if you want to have an instance, you need a newtype wrapper (otherwise the instance would be orphan)
22:57:45 <ggVGc> ah, I guess not since it doesn't derive Generic
22:58:10 <ertes> ggVGc: newtype MyIntervalMap = MyIntervalMap { fromMyIntervalMap :: IntervalMap ‚Ä¶ }
22:58:14 <ggVGc> ertes: I just want to make this work in the simplest way possible, https://gist.github.com/022b3b8daa6601f244860762e8463261
22:58:20 <ertes> then you can write a Binary instance using fromList and toList
22:58:26 <ggVGc> cool thanks
22:58:40 <ertes> it's not going to be pretty though
22:58:53 <ggVGc> you have a better suggestion?
22:59:48 <ertes> personally i would just use 'encode . toList' and 'fmap (fmap fromList) . decodeOrFail'
23:00:29 <ertes> uhm
23:00:39 <ggVGc> ertes: and write the Binary instance for my ArrTrack type?
23:01:19 <ertes> ggVGc: ah, i see what you mean‚Ä¶  to get generic deriving to work, you need a wrapper type like the newtype
23:01:37 <nshepperd> what was the cutesy term for the nonsense you get when text is decoded using the wrong encoding?
23:01:47 <Maxdamantus> 17:54:44 < nshepperd> that's decoding. it's conceptually a completely different thing to an encoded string of bytes
23:01:58 <ertes> nshepperd: windows
23:02:17 <Maxdamantus> What if you're going from something like Shift-JIS, or 8091-2?
23:02:48 <Maxdamantus> That's obviously transcoding, and it's not really much different when going from UTF-16, you just happen to be going between different unicode formats.
23:03:16 <Maxdamantus> (rather than between unicode and non-unicode formats)
23:03:19 <ertes> CP-whatever‚Ä¶  what microsoft calls "ANSI"
23:03:26 <Maxdamantus> CP-1251
23:03:39 <Maxdamantus> or maybe 1252, can't remember.
23:03:55 <ertes> see?  i've seen it a million times, and i can't remember either
23:03:57 <Maxdamantus> Yes, that would be another example. It's kind of like 8091, but it's not a "subset" of unicode.
23:04:05 <ggVGc> ertes: how can I derive generic even with a wrapper type?
23:04:11 <nshepperd> Maxdamantus: no
23:04:18 <ggVGc> ah you mean I have to write a Binary instance for the wrapper type
23:04:19 <ggVGc> yep
23:04:25 <ertes> ggVGc: yeah
23:04:49 <Maxdamantus> > length "aÃÅ"
23:05:11 * Maxdamantus wonders where ecmabot is.
23:05:59 <nshepperd> the point of 'decoding' is that you don't need to know what the encoding is after you've done it, because it's built into the type, and hidden
23:06:02 <Maxdamantus> Anyway, I suspect it would give a result back there of `2`
23:06:15 <Maxdamantus> as opposed to: > length "√°"
23:06:18 <Maxdamantus> which would give back 1
23:06:50 <ertes> it doesn't count characters, but Chars
23:06:57 <Maxdamantus> Indeed.
23:07:04 <Maxdamantus> which are related to characters in arbitrary ways.
23:07:17 <Maxdamantus> even linguistically, it's not clear what is a character.
23:07:18 <nshepperd> Text uses utf-16 internally (apparently), but you don't care, because 'encode whateverCodec :: Text -> ByteString' always does the right thing
23:07:35 <Maxdamantus> How many characters in the Korean spelling of "Han-geul"?
23:07:42 <ertes> there is a library to deal with characters and widths‚Ä¶  i think text-icu can do it
23:08:00 <nshepperd> Maxdamantus: this is totally beside the point
23:08:26 <ertes> nshepperd: i don't think you two are disagreeing =)
23:08:27 <nshepperd> but if you want to write a text editor, you can certainly use text-icu to handle things like user glyphs and whatnot
23:08:54 <Maxdamantus> A text editor can't deal with strings as binary sequences at every level.
23:09:03 <Maxdamantus> since it has to render them on a the screen (or get something else to)
23:09:13 <Maxdamantus> that obviously requires more information than the UTF-8 octets.
23:09:24 <Maxdamantus> it also requires more information than the unicode codepoints.
23:09:31 <ertes> you're just on different levels of abstraction‚Ä¶  an IRC *application* most likely would benefit from Text
23:09:41 <Maxdamantus> Neither of those systems are adequite for rendering text.
23:09:47 <ertes> but an implementation of the IRC protocol would not
23:10:29 <ertes> in particular there are valid IRC messages that cannot be represented by Text
23:11:08 <adarqui> is there anything like purescript-halogen for haskell?
23:11:30 <srhb> ertes: Such as?
23:11:55 <nshepperd> Maxdamantus: you're missing the point, it has nothing to do with handling codepoints, just getting your encodings straight
23:12:58 <mniip> srhb, such as the byte 0x80 on its own
23:13:42 <ertes> srhb: ok, i was making an assumption there =)
23:13:47 <ertes> (UTF-8)
23:15:25 <ertes> adarqui: what's special about it?
23:15:50 <ertes> adarqui: (i.e. what properties would you like to have?)
23:16:13 <reinh> the answer to this question is "it depends"
23:16:26 <Adeon> IRC and encodings; I have this problem with a bot I wrote
23:16:34 <reinh> on, e.g., what you mean by "character"
23:16:38 <Adeon> I don't know what I was thinking but there are some decodeUtf8s there that go from ByteString to Text
23:16:49 <Adeon> assuming that all IRC messages are valid utf-8
23:17:04 <Adeon> now it doesn't happen every day, maybe once a week something or someone says something that crashes the bot
23:17:04 <Axman6> I doubt you can assume the whole message is UTF-8
23:17:10 <Adeon> yeah you can't
23:17:13 <reinh> well it's a safe assumption until it isn't
23:17:16 <Axman6> but the text of a message probably is
23:17:18 <ertes> typically you would assume UTF-8 with a fallback to a single-byte encoding like 8859-1
23:17:32 <Adeon> this particular bot could have been totally encoding-agnostic
23:17:34 <nshepperd> oh! for reference, text that has been wrongly decoded and turned into humorous gibberish is called mojibake
23:17:35 <Adeon> and just work with bytestrings
23:17:40 <Adeon> but I was a stoopid
23:18:49 <ertes> mojibake?  le big make?
23:18:55 <nshepperd> there's probably a version of decodeUtf8 that does the replacement character thing rather than crashing
23:19:07 <Adeon> yeah there is that streaming thing version
23:19:11 <nshepperd> there really should be at least
23:19:13 <adarqui> ertes: nothing was just wondering. i have a purescript-halogen app that i'm considering porting slightly to a haskell framework (reflex-dom/ghcjs) as an experiment.. i kind of want to feel what it would be like to just code haskell and nothing else
23:19:28 <Adeon> you can give it a function that decides what to do with invalid bytes
23:19:31 <srhb> mniip: Why is that not valid Text?
23:19:36 <nshepperd> ertes: "character transformation"
23:19:46 <Adeon> and replace them with '?' or something or whatever is acceptable in your case
23:20:04 <ertes> adarqui: i'd have recommended reflex anyway =)
23:20:26 <nshepperd> Adeon: there's a specific unicode character for 'invalid'
23:20:50 <adarqui> ertes: ya.. i love purescript but, i do spend quite a bit of time duplicating code, even tho i also wrote something to help me generate purescript code from haskell types etc.. it's just adding up over time
23:20:54 <mniip> srhb, you mean encoded as the unicode codepoint U+80 ?
23:21:12 <adarqui> plus purescript compiler is pretty slow for me lately.. but i do have some unique situation perhaps, with tons of lines of code (generated)
23:21:18 <Adeon> can 0x80 appear in valid utf-8?
23:21:20 <int-e> eep
23:21:20 <adarqui> i think im going to look into reflex a bit
23:21:35 <adarqui> i just want to make my life easier and have even more fun.. whatever will do that, i'm willing to port
23:21:37 <srhb> mniip: No, I mean...
23:21:38 <adarqui> :f
23:21:55 <srhb> > "\128" :: Text 
23:21:57 <ertes> adarqui: i'd most likely use either pure reflex together with lucid, or reflex-dom
23:22:04 <srhb> Oh, lambdabot is dead.
23:22:09 <Adeon> oh I think it can, just not on its own
23:22:20 <ertes> adarqui: with a bias toward the former, because i like to have control over the main loop
23:22:26 <Maxdamantus> er, I said "ecmabot" earlier .. meant lambdabot.
23:22:50 <mjrosenb> Maxdamantus: spending a bit too much time in JS land?
23:22:54 <adarqui> ertes: cool. right now i have a purescript-halogen app, and i use things like halogen-bootstrap3, purescript-css, websockets
23:23:00 <adarqui> cool ertes thanks alot, i will look into all of that
23:23:16 <ertes> adarqui: i use clay for stylesheets
23:23:23 <Maxdamantus> mjrosenb: possibly.
23:23:27 <adarqui> being able to "just code haskell" sounds like a dream that I want..
23:23:30 <adarqui> deep down
23:23:34 <adarqui> so ithink it's time to start researching
23:23:35 <ertes> adarqui: and if ever necessary i use jmacro for direct javascript
23:24:08 <adarqui> ya i barely do any direct javascript but, dependencies i use have tons of direct javascript.. but mostly for things like Date's and such
23:24:18 <adarqui> my app doesn't use too many advanced js features
23:24:22 <ertes> it's hygienic JS with some builtin syntactic sugar like syntactically cheap functions and lambdas
23:24:24 * Maxdamantus tried looking at TypeScript today .. again, reminded of why promises are horrible.
23:25:02 <ertes> adarqui: in general GHCJS should compile most of haskell to JS with only one drawback: large output
23:25:17 <Maxdamantus> function foo<T>(a: T): Promise<T> { return Promise.resolve(a); } var a: Promise<number> = Promise.resolve(4); var b: Promise<Promise<number>> = foo(a);
23:25:20 <Axman6> reading the output of ghcjs is pretty fun
23:25:30 <mniip> hi int-e
23:25:37 <adarqui> ertes: any idea on performance? my purescript app, compiled/minified/etc.. is 800kb.. the code base is like 25k generated lines of code, then another 12k of hand-crafted code
23:25:45 <ertes> adarqui: you can shrink the output to reasonable sizes by using closure-compiler and make it smaller on transmission by using gzip/zopfli
23:25:47 <adarqui> and the code is only going to keep growing
23:25:49 <Axman6> there's a whole virtual machine implemented in there
23:25:58 <adarqui> ertes: ya im reading about that right now
23:26:03 <ertes> adarqui: uh‚Ä¶
23:26:06 <adarqui> ?
23:26:22 <ertes> adarqui: that's a lot of code, and there is a constant translation factor involved
23:26:29 <ertes> you'll just have to try
23:26:38 <ertes> but you may find that the output is too large
23:27:19 <adarqui> ya @ the alot of code.. i'm basically writing a forum so it has tons of types
23:27:38 <adarqui> it's one thing that's wrecking me with ps.. as i add more types/api endpoints.. compilation gets slower and slower
23:27:51 <ertes> adarqui: types are fine‚Ä¶  what increases code size is values
23:27:53 <adarqui> the generated code size isn't a problem with PS, it does a great job keeping things small it seems
23:28:21 <ertes> also GHC does not particularly like large code bases either
23:28:29 <adarqui> what do you mean ertes?
23:28:34 <adarqui> ya my code base is compile-hell
23:29:08 <ertes> it can handle many modules of small size, but it chokes on large modules
23:29:58 <int-e> :t –ä MODE Lambdabot Dg (–ä () () () ())
23:30:44 <ertes> adarqui: do you actually need many types?
23:31:02 <adarqui> ertes: ya i feel i do.. they correspond to models and such in the backend
23:32:09 <ertes> adarqui: you said, they are *generated*‚Ä¶  in what way?
23:32:17 <adarqui> ertes: this repo takes a long time for haskell to compile.. it has one very large module, which is auto-generated... is stuff like this just a no-no/nightmare for haskell? https://github.com/adarqui/ln-types/blob/master/src/LN/T/Internal/JSON.hs    **warning big file**
23:32:41 <int-e> :t –ä MODE Lambdabot Dg (–ä () () () ())
23:32:46 <lambdabot>  MODE Lambdabot Dg ( () () () ())
23:33:13 <Axman6> what is that character(s) anyway?
23:33:14 <adarqui> i have a bunch of types in several files, in that src/LN/T directory.. ie, src/LN/T/Forum/{Request,Response} etc.. so, in another library, i use template haskell to figure out those types, then generate json instances, eq/read/show/etc instances for haskell AND purescript
23:33:31 <mniip> Axman6, U+40A
23:33:37 <mniip> which somehow gets sent as 0x0A
23:33:44 <int-e> not perfect but it should plug these holes for now (it filters "bytes" >255 when sending messages)
23:34:02 <int-e> it's d0 8a 0a in UTF-8
23:34:09 <nshepperd> the worlds of unicode and time zone handling can learn a lot from each other, I think... making everything "timezone aware" including things that only needed clock time was a horrible mistake...
23:34:20 <mniip> int-e, what no
23:34:29 <mniip> utf-8 always uses characters >127
23:34:32 <adarqui> ertes: so i write the basic haskell types, each in their own file.. only deriving Generic/Typeable.. then, i use a library to generate various instances for haskell and purescript, so that i can just re-generate any time i add a new type, modify a type, etc.. and everything interops fine between haskell/purescript
23:34:33 <int-e> but yeah, that's not it.
23:34:44 <Axman6> mniip: no it doesn't...
23:34:52 <mniip> what?
23:34:57 <pikhq> Only when it's encoding not-ASCII.
23:35:01 <mniip> well yes, that
23:35:02 <Axman6> yeah
23:35:10 <ertes> adarqui: i see
23:35:54 <int-e> sorry. it's really the modulo 256 as others have said, plus an UTF-8 decoding/encoding mismatch.
23:36:10 <nshepperd> so we get correct ascii for c < 128, utf-8 mojibake for c < 256, and the rest filtered
23:36:12 <mniip> > text "–∞"
23:36:13 <lambdabot>  –∞
23:36:20 <ertes> adarqui: and you really need all of them?  it looks like some of them are just plural versions of others, and some of them seem to be different names for the same semantics
23:36:22 <mniip> int-e, can't you do the same thing as in @eval?
23:36:33 <int-e> mniip: I've patched the IRC plugin
23:36:56 <mniip> well that's only half of the solution
23:37:00 <adarqui> ertes: well, the plural ones probably no.. but.. there aren't a ton of those
23:37:07 <adarqui> i mean if i have to "shave those out" then i'm probably in trouble
23:37:10 <mniip> > undefined :: –∞
23:37:12 <lambdabot>  *Exception: Prelude.undefined
23:37:15 <mniip> –ñ–µ undefined :: –∞
23:37:20 <mniip> oops
23:37:24 <mniip> :t undefined :: –∞
23:37:27 <adarqui> because, i have so many 'types' i'll probably have to add to this thing over the years
23:37:30 <mniip> see
23:38:36 <adarqui> so the thing that's biting me right now hard are: compile times in both haskell and purescript, but more-so purescript.. having to auto-generate code to be shared between haskell & purescript -> and if i dont have that type of instance/etc in my library, now i have to add it etc, needless time... potentially large output code sizes (moreso for ghcjs than purescript?)
23:38:43 <adarqui> and community support
23:39:12 <adarqui> purescript has a pretty strong community.. no experience with haskell web/ui community
23:39:51 <int-e> mniip: it's not a proper fix of the encoding issue; it's just plugging the hole that lets you exploit encoding bugs to send arbitrary IRC commands.
23:40:06 <ertes> adarqui: i would refactor first: having lots and lots of types are a sign that you should redesign your DSL
23:40:16 <ertes> s/are/is/
23:40:52 <mniip> well alright
23:41:00 <adarqui> i refactor too much.. honestly i just want to get my forum members into this custom app.. then i want to spend lots of time focusing on every little detail
23:41:08 <adarqui> all i do is refactor.. ;f
23:41:15 <Cale> :t –äPING
23:41:16 <lambdabot> PING
23:41:40 <mjrosenb> oh hey, lambdabot is back
23:41:44 <ertes> adarqui: when you started this project, did you come from an OO language?
23:42:01 <adarqui> as for the types i just dont see how i could refactor considerably.. i have lots of different 'things' in the system
23:42:04 <adarqui> nope
23:43:17 <ertes> adarqui: since i'm not familiar with your semantics i can't help you much, but the idea is to find a minimal base language that can express everything you currently have and most things you're likely to have in the future
23:43:52 <mjrosenb> so, I assume that I can specify scripts to install alongside my program in a .cabal file; is there a way to specify some amount of shell environment as well?
23:44:01 <ertes> adarqui: a sufficiently generic algebra of types that allows you to *compose*
23:44:11 <mjrosenb> e.g. I want to export a bash function automatically, possibly through /etc/env.d
23:44:36 <adarqui> well the types matchup with my haskell-persistent models.. i have organizations/users/teams/groups/forums/boards/threads/posts/likes/stars etc
23:44:55 <ertes> adarqui: persistent as in the 'persistent' library?
23:45:17 <adarqui> i definitely want to eventually get to that.. cleaning everything up dramatically.. major refactor/re-engineering.. but mission #1 is to get this thing "into production"
23:45:19 <nshepperd> :t –äPING
23:45:20 <adarqui> ya
23:45:26 <lambdabot> PING
23:45:57 <adarqui> my types are basically a mirror of my models.. except i have request and response types, because of the API that sits in between the user and the backend/database
23:46:04 <adarqui> so model types * 2
23:46:09 <adarqui> models * 2
23:46:10 <adarqui> even
23:46:26 <ertes> adarqui: i see‚Ä¶  persistent pretty much forces you to have lots of highly specific types
23:46:35 <ertes> because it identifies "type" and "table"
23:46:45 <ertes> s/and/with/
23:46:51 <adarqui> ya
23:46:55 <nshepperd> > put–ÖtrLn "–äPING"
23:47:02 <lambdabot>  –äPING
23:47:11 <adarqui> and tbh i like the relational db for this project, with types/models matching up
23:47:40 <adarqui> i'm learning new things as i go.. part of this project is to improve as a programmer + improve engineering.. but also to make my site "my own" (forum etc)
23:47:53 <adarqui> instead of some third-party php software it uses now
23:47:59 <ertes> adarqui: well, your best bet for now is to split your project into three packages:  one as-small-as-possible common library, the server package and the client-side package
23:48:17 <adarqui> ya i have it split into several libraries
23:48:21 <adarqui> like you say
23:48:29 <adarqui> ie, ln-types is simply the types
23:48:39 <adarqui> ln-yesod is the backend, ln-ui is purescript.. among several other libs
23:48:52 <nshepperd> I don't understand why that's not being filtered?
23:49:03 <adarqui> so i guess i just need to experiment with ghcjs and see what happens.. i could perhaps do some FAKE code size tests
23:49:13 <adarqui> generate a ton of 'fake haskell' which is all utilized in the app
23:49:17 <adarqui> and see how big the app gets
23:49:23 <adarqui> and how long it takes to compile
23:49:25 <adarqui> using ghcjs
23:49:56 <adarqui> that sounds like a good idea actually.. before i start porting (if i do).. that'll give me an idea of what to expect, or if it is even feasible
23:50:06 <adarqui> given my code size (and future code size increases)
23:50:09 <ertes> adarqui: GHCJS is slower than GHC, but it's still reasonably fast‚Ä¶  in general try to use GHC during development (both ghcjs-dom and reflex-dom support native code as well)
23:50:19 <kadoban> adarqui: If it helps, for production code, closure-compiler is kind of a required step for ghcjs for me. That + gzip get sizes down to quite reasonable. Without it ... they're a little huge.
23:50:24 <adarqui> ertes, thanks for your help
23:50:51 <adarqui> ertes: ya so i could just develop and make sure things are compiling.. then i could fire off a front-end build with all of the minification etc
23:51:06 <adarqui> kadoban: cool thanks
23:51:51 <ertes> adarqui: you don't need GHCJS until the very last step (producing actual JS)‚Ä¶  for prototyping you can use regular GHC, which compiles to a small webkit application with native code
23:52:48 <adarqui> ill look into it, but, honestly, i'd love to be able to develop a front end app without actually using the front end/browser much.. i mean im forcing myself to code frontend by taking on this project, but im more of a deveops/backend guy so.. it's pretty rough.. i'd love to actually code alot more in terminal.
23:52:58 <adarqui> ertes: nice.. see that sounds so appealing to me
23:53:37 <adarqui> i love using ghci.. psci (ghci equiv) is too slow given my code size.. and yesod development is kind of brutal in ghci.. would love to use ghci more for the front-end portion of the app
23:54:07 <ertes> adarqui: which editor/IDE do you use?
23:54:11 <adarqui> i need to experiment with splitting out that json module into separate modules for each type
23:54:14 <adarqui> vim.. lol ;f
23:54:22 <adarqui> vim + tmux
23:54:39 <ertes> vim launching GHCi or GHCi launching vim?
23:55:14 <adarqui> ? neither.. tmux with split panes.. vim in most panes, ghci at the bottom
23:55:17 <adarqui> i'm pretty archaic
23:55:20 <adarqui> ;/
23:55:53 <ertes> ah, i see‚Ä¶  in any case, if you have a persistent GHCi session, you may find my 'rapid' library useful
23:55:58 <ertes> https://hackage.haskell.org/package/rapid
23:57:34 <adarqui> pretty cool, thanks
23:57:36 <adarqui> is it on github too?
23:57:49 <milesrout> i might be retarded but how do I list all the packages installed in a cabal sandbox?
23:58:09 <milesrout> cabal sandbox[tab] gives no good suggestions
23:58:17 <adarqui> milesrout: in stack i think it's stack --list-dependencies, something like that
23:58:19 <ertes> adarqui: it's on hub.darcs.net
23:58:33 <adarqui> ertes: ya i see
23:58:35 <milesrout> what is stack? i‚Äôm using cabal
23:58:59 <milesrout> I typed cabal install transformers-free and then realised I actually want free instead
23:59:00 <Koterpillar> milesrout: cabal sandbox exec (or run?) ghc-pkg --list
23:59:30 <Koterpillar> milesrout: cabal exec ghc-pkg --list
23:59:35 <ertes> milesrout: cabal list --installed
