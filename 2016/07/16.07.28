00:00:36 <Halla> anyways, thanks all!
00:14:33 <anohigisavay> hi
00:14:51 <srhb> anohigisavay: Hi.
00:15:00 <anohigisavay> is it possible to have |] as part of QuasiQuotation content?
00:15:52 <black0range> Hello! I recently promised a friend of mine to teach him a bit of haskell, I though that it might be fun for him to try to make some kind of game (graphical or not). Does anyone know some kind of game that is easy to make and is can explain haskell concepts in a fun manner? 
00:16:16 <srhb> anohigisavay: Not easily: https://ghc.haskell.org/trac/ghc/ticket/5348
00:18:04 <liste> black0range: tic tac toe!
00:18:08 <pavonia> black0range: How far do you want to go?
00:18:52 <anohigisavay> srhb: thanks ::)
00:20:03 <black0range> liste: might be a good idea :)
00:20:38 <liste> it can work in ASCII art too
00:21:16 <black0range> pavonia: I was thinking of something simple at start, to make sure that his atention span doesn't run out :) 
00:23:27 <srhb> black0range: Game development in Haskell being more or less unexplored, at least for bigger things, I would not recommend it at all. I remember the different way of handling state to be extremely frustrating too for this purpose.
00:23:52 <srhb> black0range: I managed to make a graphical Snake regardless, but it took me a long while
00:24:11 <srhb> I only had this channel though, so perhaps a dedicated tutor might make it no problem at all. :)
00:24:28 <Koterpillar> there are quite a few attempts, including gl and all; I know someone who made an Android game in Haskell
00:24:58 <srhb> Yes, and there's Niki and the Robots or whatnot.
00:25:08 <black0range> srhb: I agree to make something sophisticated you do need to know a bit of haskell to make something good :)
00:25:08 <srhb> And that cookie :-P
00:25:32 <srhb> black0range: Right, I just think other things fit more naturally and demonstrate more easily what it is Haskell does really well.
00:25:54 <srhb> (I find game dev, my limited experience in the field notwithstanding, to be quite pleasant in HAskell now)
00:25:55 <black0range> srhb: Do you have any suggestions? :) 
00:26:29 <srhb> black0range: Not without knowing more of their interests, really.
00:26:46 <srhb> black0range: I can say what I really enjoy (shell stuff, web dev stuff, backend stuff, parsing)
00:27:47 <black0range> This is a guy that just finished his first year in CS so i don't think even he knows what he enjoys quite yet :) 
00:28:12 <srhb> OK. :) Well, writing Snake wasn't _that_ bad, and surely enlightening as I kept with it. :-P
00:35:34 <koz_> OK, I have a weird profiling result. I have a big cost centre (both for allocation and CPU) on a let-bind.
00:35:49 <koz_> It's basically something like 'let foo = bar x y', where 'bar' is a function in a different module.
00:35:58 <koz_> However, that function doesn't come up in the top cost centres.
00:36:03 <koz_> Is laziness sneaking up on me?
00:36:04 <black0range> srhb: Did you per chance come up with some really minimalistic way to do it? :)
00:38:26 <mniip> hey edwardk
00:47:50 <ertes> black0range: i like the hangman game for a first non-graphical game, because you can explain a number of concepts using it
00:47:55 <ertes> most notably: functional programming
00:50:04 <black0range> ertes: That is a great idea!
00:50:25 <ertes> black0range: the particular idiom i had in mind is:  data Hangman = Guess [Maybe Char] (Char -> Hangman) | Won String
00:51:01 <ertes> black0range: from there you can go in any number of directions…  example: notice that Hangman is a Monoid
00:51:13 <ertes> another example:  Hangman can be abstracted in a number of ways
00:51:59 <ertes> here is a highly generalised version of the same thing:  data GuessGame f a b = Guess (f (Maybe b)) (a -> GuessGame f a b) | Won (f b)
00:52:28 <srhb> Yeah, guessing games are rather nice for this. Great suggestion. :)
00:52:30 <ertes> guess a random number the computer thought of, or guess the individual characters in a word
00:53:05 <joe9> I can get this to work: *Main> do rect_ [x_ "10"] ; style_ [visibility_ "hidden"]
00:53:05 <joe9> <rect x="10"/><style visibility="hidden"/>
00:53:15 <joe9> but, I want the style to be an attribute of rect.
00:53:36 <joe9> code : http://dpaste.com/26C2J1P
00:53:46 <joe9> on line 46
00:54:14 <ertes> joe9: rect_ [x_ "10", style_ (compileStyle myStyle)]
00:54:18 <joe9> <rect x="10" style="visibility:hidden;"/>
00:54:28 <ertes> joe9: if the style-sheet is actually CSS, you need a separate language for that, like clay
00:55:17 <liste> joe9: rect_ [x_ "10", style_ "visibility: hidden"]
00:55:26 <ertes> lucid only does markup…  as far as lucid is concerned, CSS is just text
00:56:03 <joe9> ertes: http://codepad.org/NBf09PX5
00:56:12 <black0range> ertes: I think i'll skip the concept of monoid the first time :) 
00:56:40 <ertes> joe9: see liste's example…  "visibility" is a CSS thing, not a markup thing
00:56:47 <joe9>  liste: http://codepad.org/rf5KoFGz
00:57:17 <joe9> style_ :: Monad m => [Attribute] -> SvgT m ()
00:57:35 <joe9> this is the definition of style_ . so it must be passed an []
00:57:39 <black0range> Speaking about monoid, the simplest way i've heard it described is the behavior of a clock, does anyone know any simpler way to do it? :) 
00:57:50 <liste> joe9: that's the style tag, not the style attribute
00:58:14 <ertes> black0range: yeah, keep monoids until they understand the Hangman type very well, and there are a number of steps toward that goal:  first teach ADTs and make them understand what the Hangman type *means*
00:58:15 <joe9> liste, how do I get the style_ attribute?
00:58:30 <joe9> and not the style_ tag
00:58:40 <ertes> black0range: then help them (without giving away too much) write an interpreter for Hangman:  hangmanStdio :: Hangman -> IO ()
00:58:59 <ertes> black0range: let them come up with that type by themselves, which gives you an opportunity to explain IO
00:59:08 <liste> joe9: there's an example in Lucid docs: >>> style_ [style_ "inception"] "Go deeper." :: Html ()
00:59:26 <ertes> black0range: a monoid is best explained in terms of examples…  show them two examples, then show them the definition, then show them a third example
00:59:26 <liste> prints <style style="inception">Go deeper.</style>
00:59:57 <ertes> black0range: that's what has worked best for me so far:  show two examples, reveal common structure, show third example
01:00:10 <liste> joe9, it's overloaded for Html5, not sure about Svg
01:00:24 <joe9> liste, it appears to be different with Svg.
01:00:44 <liste> joe9: the style attribute for Svg is in https://hackage.haskell.org/package/lucid-svg-0.7.0.0/docs/Lucid-Svg-Attributes.html
01:00:52 <ertes> black0range: also let them experience the difficulty of writing this function:  hangmanFromString :: String -> Hangman
01:01:25 <ertes> black0range: that helps justifying why abstraction is great:  later they do this:  singleton :: Char -> Hangman;  hangmanFromString = foldMap singleton
01:01:48 <joe9>  liste, got it. Thanks a lot.
01:04:37 <edwardk> heya mniip 
01:05:49 <mniip> edwardk, any idea how to improve this http://lpaste.net/171967
01:06:13 <edwardk> lighter, gasoline?
01:06:17 * edwardk ducks.
01:06:33 <edwardk> building products?
01:06:39 <mniip> yeah from limits
01:07:20 <edwardk> i mean you can do it, it is a fun intellectual exercise then the need to be able to talk about "the" product functor eventually rears its ugly head and everything goes to crap
01:08:00 <edwardk> you can drop PairK and use Bool
01:08:15 <mniip> not much of a difference is there
01:08:40 <edwardk> well, you get to use an out of the box thing, and can make sure there is a singleton instance, etc.
01:09:11 <edwardk> that has the benefit of starting to reuse existing machinery there as well
01:09:15 <mniip> a different option is to allow arbitrary type families to be functors
01:09:26 <edwardk> this is sjoerd's approach
01:09:27 <mniip> but then you have to tag all your functors
01:09:32 <edwardk> its hell to use
01:09:46 <edwardk> you get to define things like simplicial sets though
01:09:50 <edwardk> it is 'better' category theory
01:09:52 <edwardk> worse hasell
01:09:54 <edwardk> er haskell
01:10:14 <edwardk> the thing you have here, like hask, is an exercise in knowingly doing category theory wrongly
01:11:18 <mniip> welp
01:11:20 <edwardk> one thing i miss from the original hask was having '(,) and '(,) a as functors
01:11:29 <mniip> Hask is nice from a distance
01:11:40 <mniip> but as you get closer it starts to diverge from CT
01:11:48 <edwardk> sure
01:12:21 <edwardk> my goal was never to implement ct faithfully in haskell, but rather to move from the other direction and get Functor up in power to something more useful without compromising inference
01:12:21 <mniip> so when coming up with CT stuff you have to make sure you can actually trace it back to haskell
01:12:49 <mniip> and Limit seems to be one of those things where it's hard to do that
01:13:11 <edwardk> the fact that you can write instance Functor Either is enough of a head explosion for most people. =)
01:13:22 <edwardk> well limits work pretty well i thought
01:13:40 <edwardk> they were pretty much single-handedly the reason why i needed to introduce Ob, etc.
01:13:46 <mniip> Either as a functor from Hask to [Hask, Hask] ?
01:13:51 <edwardk> yeah
01:14:31 <mniip> hmm, I haven't tried to do that in my hask yet
01:14:47 <koz_> Am I understanding this correctly: http://hackage.haskell.org/package/bitwise-0.1.1.1/docs/Data-Array-BitArray.html ? I assume that 'BitArray i' here means 'a bit array indexed by things of type i'?
01:15:02 <edwardk> another thing worth doing is showing bifunctor as a functor to a functor category, so you can remove the concept
01:15:23 <edwardk> you need a little bit of work to make sure you can do 'first' and 'second' and hence 'bimap' but once you have it, tons of instances go away
01:15:50 <mniip> you mean
01:15:52 <edwardk> because now your code isn't cluttered with functor, bifunctr, profunctor, contravariant, etc. instances, just 'functor' on whatever arguments you are functorial
01:16:09 <mniip> CxD --> E ~ C --> [D, E]
01:16:11 <edwardk> and you can use a discrete category for the arguments where you are nominal
01:16:42 <edwardk> yes. because we don't tuple up the two *'s our bifunctor's have as arguments anyways
01:16:45 <edwardk> :k (,)
01:16:46 <lambdabot> * -> * -> *
01:17:13 <edwardk> if that was (*,*) -> * then it'd be a functor from the product category to the category
01:17:20 <mniip> :k '(,)
01:17:22 <lambdabot> k -> k1 -> (,) k k1
01:17:52 <edwardk> that is still different =)
01:18:40 <edwardk> that is what i was referring to in the old hask was interesting. it is a functor from C -> [D, (C * D)]
01:19:19 <edwardk> in current hask / your code you need to clutter it with a couple more type parameters to talk about what C and D are
01:19:35 <edwardk> so you wind up making your own type, which is kinda meh
01:21:11 <edwardk> anyways the above curried category theory works really well in haskell, as it avoids all the usual mathematical dodges where they pretend you can tuple up n things and re-associate 'on the nose' in your type theory
01:21:20 <edwardk> we always have to deal with associators, etc. here
01:21:37 <mniip> ooh
01:21:46 <mniip> instance Functor (->) (->) ((,) a) where fmap f (x, y) = (x, f y)
01:21:46 <mniip> instance Functor (->) (NT (->) (->)) (,) where fmap f = NT $ \(x, y) -> (f x, y)
01:21:48 <mniip> that's p cool
01:26:58 <edwardk> yeah
01:27:09 <edwardk> and then if you runNat or whatever you call it you move 'back' one argument
01:27:19 <edwardk> and you can do that over and over and over to map over any argument in a k-ary functor like that
01:28:11 <mniip> instance Functor (->) (->) ((->) a) where fmap f = \g -> f . g
01:28:11 <mniip> instance Functor (Op (->)) (NT (->) (->)) (->) where fmap (Op f) = NT $ \g -> g . f
01:28:12 <mniip> fun
01:28:33 <edwardk> btw- i recommend using class associated types for your functors rather than MPTCs like that. you can go from class-associated types to fundeps through little FunctorOf tricks like I use, but you can never go the other way. so if your functors need two more type arguments, then every subclass of them is going to get polluted similarly
01:28:39 <edwardk> and it gets messy fast
01:29:09 <edwardk> in general any Category (p :: i -> i -> *) will be a functor from Op p to Nat p (->)
01:29:20 <edwardk> ideally i'd be able to express this as a superclass of Category
01:29:34 <edwardk> but this requires UndecidableSuperClasses
01:29:41 <edwardk> in fact this is why we _got_ UndecidableSuperClasses
01:29:52 <edwardk> but the 'cycle' goes through Nat in a way that expands explosively
01:30:16 <edwardk> so hask fakes it by defining Category'', and building up the extra constraints to by the time it gets to Category.
01:31:48 <edwardk> anyways i don't know how to plug the infinite superclass hole without closing the category of constraints with a type (|-) :: Constraint -> Constraint -> Constraint to serve as constraint's inner hom.
01:32:00 <mniip> "but you can never go the other way."
01:32:15 <mniip> any invocation of 'Fam a' can be rewritten as 'MPTC a b => b'
01:32:33 <edwardk> now write a type family, not a class.
01:32:44 <mniip> that you can't do
01:32:47 <edwardk> type, not term
01:32:55 <mniip> er?
01:32:56 <edwardk> and there you get stuck
01:33:12 <mniip> why would you need a type family
01:33:32 <edwardk> fundeps are strictly less powerful than the class associated types here.
01:33:43 <mniip> are they
01:34:00 <edwardk> given class Functor (f :: i -> j) where type Cod f :: i -> i -> *; type Dom f :: j -> j -> *
01:34:09 <mniip> how do you express circular fundeps in associated type synonyms?
01:34:37 <edwardk> i can define class (Dom f ~ c, Cod f ~ d) => FunctorOf c d f; instance (Dom f ~ c, Cod f ~ d) => FunctorOf c d f
01:35:01 <mniip> sure
01:35:28 <edwardk> but you can _never_ choose to go the other way so that for any instance of your Functor c d f you have some class Foo f     that lets you drop the 'c' and 'd' from discussion. you always have to talk about them. every data type that ever references 'f' has to have a c and a d in it.
01:35:31 <dredozubov_> Do you mean that the FunctorOf trick can't be applied for GHC <8? Or do you refer to something else.
01:35:36 <edwardk> they pollute every data type you touch
01:36:12 <edwardk> dredozubov_: no i mean that the FunctorOf trick I gave there turns the TF form into the fundep form, but you can't go back
01:36:37 <dredozubov_> i look at the Hask.Category and it doesn't use UndecidableSuperClasses, so i was confused
01:36:42 <edwardk> you can't write, say, Vector's API with just FDs without polluting every vector with crap rambling on about the representation
01:37:09 <edwardk> dredozubov_: the UndecidableSuperClasses feature didn't exist when hask was written. and Category'' doesn't have Functor as a superclass
01:37:11 <dredozubov_> yeah, i wonder if it can be used to get a nicer API for servant typeclasses
01:37:11 <mniip> "every data type that ever references 'f' has to have a c and a d in it."
01:37:23 <mniip> what do you mean by that
01:37:24 <dredozubov_> i'm kinda bummed out by the huge MPTCs
01:38:16 <edwardk> mniip: https://ghc.haskell.org/trac/ghc/ticket/11534
01:41:15 <edwardk> dredozubov_: https://ghc.haskell.org/trac/ghc/ticket/10318 is the UndecidableSuperClasses origin story
01:41:27 <edwardk> there are more issues since then
01:41:31 <edwardk> but that is the core of it
01:41:32 <dredozubov_> edwardk: btw i wanted to ask you about reflection a little bit
01:41:52 <dredozubov_> it implies a dynamic typeclasses story, but i don't really get why it's useful
01:42:00 <edwardk> i'm happy to answer but at some point tonight i will fall asleep
01:42:34 <dredozubov_> hehe, it's morning here :)
01:43:16 <edwardk> dredozubov_: saw you have a number, and you need to turn it into a type that you can reflect back down and get the number out. or you have a value of  type 'a' and a function a -> a -> a that is associative and has that as its unit, and you need a monoid to run foldMap with
01:43:34 <edwardk> if you use newtype M a = M (a -> (a -> a -> a) -> a)   or something
01:43:40 <edwardk> then you get a problem.
01:43:42 <dredozubov_> i have to say i saw the monoid example in the repo
01:43:52 <dredozubov_> but i still don't get a point
01:44:02 <edwardk> x = mappend y y; z = mappend x x, etc. shares _functions_
01:44:09 <edwardk> which does nothing towards sharing values
01:44:28 <edwardk> so you have to compute something for every leaf in the expanded tree
01:44:40 <edwardk> but with reflection you get to write an instance on a newtype of 'a'
01:44:45 <dredozubov_> ah, i see, you can do an implicit memoization kinda
01:44:57 <Xnuk> How can I use `|]` in QuiasiQuote?
01:45:08 <Xnuk> s/Quiasi/Quasi/g
01:45:13 <edwardk> you share leaves, GHC gets to know that every unit and every (a -> a -> a) you are given will be the same one, so it can commute instance passing into functions.
01:45:48 <glaukon> In a State monad, is there a way to have a generic function for modifying a field in a record like e.g. setField field val = modify (\s -> s { field = val })
01:46:02 <edwardk> another example. Say you have a data type like Rounded 512 TowardZero
01:46:09 <edwardk> and you need that number to be dynamic
01:46:16 <edwardk> based on user input
01:46:18 <edwardk> now what?
01:46:38 <mniip> glaukon, this problem is partly solved by lenses
01:46:47 <edwardk> reifyNat 512 $ \(Proxy :: Proxy p) -> ... in here you can work with Rounded p TowardZero ...
01:46:57 <dredozubov_> ok, if you're basing it on the user input, you have to reify it anyway
01:46:59 <edwardk> takes a value level 512 and turns it into a type level nat
01:47:02 <mniip> :t (.=)
01:47:04 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
01:47:08 <mniip> if I recall correctly
01:48:13 <mniip> edwardk, I see what you mean there. I thought you're passing c and d to datatypes
01:48:21 <edwardk> similarly, hyperloglog uses reflection to talk about the precision, but if it was a function then instead i'd have to recompute the hyperloglog approximation from scratch when i unioned two hyperloglog sets, defeating the purpose of having a fixed sized approximation of a set in the first place
01:48:34 <mniip> in which case the simple answer would be to hide a constraint inside the datatype using gadts
01:48:36 <edwardk> mniip: say you wanted to talk about data Foo f = ...
01:49:03 <koz_> https://wiki.haskell.org/Arrays <-- this says I can implement unboxed arrays for enumeration types. Where can I find out how?
01:49:09 <koz_> s/how/how to do that
01:49:33 <edwardk> you may in some cases be able to package up a dictionary with the existential, but this forever rules out a newtype
01:49:38 <dredozubov_> ok, now i have to convert it to some ground rules for the work codebase
01:49:41 <edwardk> say you want to deal with type Foo f = ... 
01:49:44 <mniip> indeed
01:49:49 <edwardk> now you can't carry a dictionary!
01:50:02 <dredozubov_> i see people abusing the library
01:50:05 <mniip> quantification?
01:50:21 <edwardk> say you have something like
01:51:02 <dredozubov_> koz_: you can use unboxed Vector
01:51:56 <edwardk> type family Initial (k :: (i -> i -> *)) :: i -- there you are safe, right? you only talk about the functor, but now once you get up to cartesian closed category or something your classes are talking about (->) as the arrow, (,) as the product, () as the unit, (->) as the internal hom. and every class has to take 4-5 arguments
01:52:07 <dredozubov_> have to go to the office now o/
01:52:20 <edwardk> every thing that wants to talk about your category being cartesian closed has to take all 5 arguments, even the ones it doesn't use
01:52:32 <koz_> OK, so to have an unboxed vector of something, I need that something to be an instance of Unbox, right?
01:52:35 <koz_> How do I define one?
01:52:36 <mniip> yeah I do see the problem with that
01:52:44 <koz_> Or is there some automagic involving GHC Generics for this?
01:52:54 <mniip> but with type families how do you get behavior similar to circular fundeps?
01:53:14 <mniip> injectivetypefamilies tries to solve that, but they still don't have type C injectivity as per https://ghc.haskell.org/trac/ghc/wiki/InjectiveTypeFamilies
01:53:55 <edwardk> mniip: silly question: how often do these arise in category theory here? ;)
01:54:12 <edwardk> i don't have any in practice
01:54:24 <mniip> I've dealt with those a lot in a different area
01:54:28 <edwardk> the fundep story is nice for when you have several fundeps
01:54:34 <edwardk> i like them a lot
01:54:45 <edwardk> but you cant escape them once you start
01:54:57 <edwardk> the TF story on the otherhand can be more verbose
01:55:07 <edwardk> but you can always escape to the FD story
01:57:57 <edwardk> class Idem a b | a -> b, b -> a;     type family L b; type family R a; gives you the two halves, but misses the mutual inverse property
01:58:00 <edwardk> so you can do things like
01:58:31 <edwardk> class (L a ~ b, R b ~ a) => Idem a b
01:58:54 <edwardk> then L (R b) ~ b     and R (L a) ~ a by substitution
01:59:48 <edwardk> modeling the fundeps with TFs is kinda tedious, but at least it isn't 'forever'
02:00:16 <mniip> I remember running into inference issues with this
02:00:48 <mniip> like if you have a b -> c, a c -> b, b c -> a
02:00:50 <edwardk> MonadState s m => .. is a good fundep story. in general no combinator you write with MonadState s m won't talk about 's'. few combinators like: forget m = do s <- get; x <- m; put s; return x   -- get used in practice
02:00:54 <mniip> witnessed by families Foo, Bar, Baz
02:01:10 <edwardk> you need a _lot_ of equalities to model the consequences there
02:01:24 <Iskarlar> clear
02:01:37 <mniip> then 'Foo (Baz b c) (Bar a c) ~ c' is a mess that ghc can't infer
02:01:40 <mniip> or something
02:04:20 <edwardk> that is part of the superclassesyou need to write. computing that transitive closure is doable. i even have an algorithm for it somewhere
02:04:52 <edwardk> it takes stating 'c' all the ways you generate c by fundep.
02:05:08 <edwardk> this is combinatorially explosive
02:07:05 <koz_> Suppose I have something like 'data Colour = Red | Blue | Yellow'. Can those live in unboxed Vectors?
02:08:47 <mniip> edwardk, https://ghc.haskell.org/trac/ghc/ticket/11534 definitely sounds like something I'd support
02:12:16 <edwardk> a b -> c, a c -> b, b c -> a,   c ~ Foo a b, b ~ Bar a c, a ~ Baz b c, -- say we want a two parameter typeclass here, now go back and try all substitutions to start . lets pick one   b ~ Bar a c, say we need to eliminate 'c', substitute  b ~ Bar a (Foo a b). This lets us talk about a two parameter typeclass class (b ~ Bar a (Foo a b), a ~ Baz b (Foo a b)) =>
02:12:16 <edwardk> Whatever a b  ... the 'mess ghc can't infer' is demanded from the type parameters a and b that we're told by the head. so it always winds up inferrable as long as you do the substitutions write
02:12:18 <edwardk> er right
02:12:53 <edwardk> koz_: you'd have to write an Unbox instance by hand to get that today
02:13:23 <koz_> edwardk: And how do I do that? I can't see what I have to implement to make something an instance of Unbox according to the docs.
02:13:32 <koz_> Also, hi! I love your lens work!
02:13:40 <edwardk> koz_: it is pretty much hell to write ;)
02:13:45 <edwardk> koz_: thanks =)
02:13:50 <koz_> edwardk: :(
02:14:14 <edwardk> i'd first start with writing a Prim instance
02:15:08 <osa1> koz_: just write Colour -> Int# and Int# -> Colour and store Int# instead. maybe abstract your writeColour and readColour and newtype the vector type to avoid bugs.
02:15:36 <mniip> you'd probably want to use tagToEnum# and dataToTag# but I'm not familiar with the vector typeclass stuff
02:15:43 <edwardk> http://hackage.haskell.org/package/primitive-0.6.1.0/docs/Data-Primitive-Types.html
02:16:05 <edwardk> but to but to do that you need to use something like mniip mentions
02:16:16 <koz_> edwardk: Thank you - I shall read. I might just do what osa1 suggests, however.
02:16:36 <edwardk> basically your Prim'd piggyback off, say, the Int# instance.
02:17:05 <edwardk> using dataToTag# and wrapping and calling the other, to deal with the impedence mismatch
02:17:20 <edwardk> but you'd need to be comfortable with unboxed data types, etc.
02:17:29 <koz_> edwardk: I'm really not.
02:17:36 <koz_> I'll probably do what osa1 suggests.
02:17:41 <koz_> But thanks for the info all the same.
02:19:57 <koz_> osa1: If I do something like 'type Colour = Int#', will I be able to still ahve unboxed vectors of Colour?
02:19:59 <koz_> I assume yes.
02:20:07 <osa1> koz_: yes
02:20:11 <mniip> yes because that's a  synonym
02:20:28 <mniip> edwardk, any interesting type-theoretical advancements recently :o
02:20:31 <koz_> osa1 and mniip: I thought as much, but figured I'd double-check.
02:22:22 <implementation> hey guys, I wrote a GUI application using wxHaskell, and now I'm trying to run it on Mac OS X (El Capitan) and wxWidgets-3.0.2; compilation works, but when I try to start it, I get "dyld: Symbol not found: __ZThn920_N12wxHtmlWindow13GetHTMLWindowEv"
02:22:59 <implementation> on the web I found the advice that I should compile wxwidgets with --enable-shared, so I did, but nothing changed
02:24:07 <sbrg> implementation: well, I'm going to assume that "dyld" is the name for the dynamic linker on OS X or something in that direction. it's telling you that the library it's loading for wxwidgets doesn't contain the symbol in question. perhaps you are using the wrong version on OS X?
02:25:52 <koz_> Also, 'dyld' is an awesomely awful name for something. :P
02:26:18 <implementation> according to https://wiki.haskell.org/WxHaskell/MacOS_X, wxwidgets 3.0 should work fine
02:27:14 <eklavya> there seems to be a parsing problem with this code http://lpaste.net/172460
02:27:25 <eklavya> but I can't figure out what
02:27:35 <eklavya> can someone please help?
02:27:46 <sbrg> eklavya: is that all the code?
02:27:54 <sbrg> because if you have forkIO $ .. at top level, that's invalid
02:28:10 <sbrg> the `where` clause attaches to a function definition. you are not defining a function
02:28:13 <merijn> koz_: Why is that? It's the DYnamic version of ld?
02:28:15 <sbrg> you just have a bare expression
02:28:22 <koz_> merijn: I have a very dirty mind, y'see.
02:28:25 <eklavya> sbrg: it's part of code
02:28:40 <eklavya> why?
02:28:45 <sbrg> eklavya: are you missing the first line?
02:28:45 <eklavya> isn't loop a function?
02:28:50 <merijn> implementation: run "otool -L" on the library
02:28:59 <merijn> See if you find said symbol in there
02:29:25 <eklavya> sbrg: first line?
02:29:40 <sbrg> eklavya: if that is an exact copy of the top level definition and you're not missing a line or something, then you are doing the equivalent of calling a function outside the main function, so to speak
02:29:57 <eklavya> let me paste the whole thing
02:30:28 <eklavya> http://lpaste.net/172460
02:30:37 <eklavya> there is a parse error in the last line
02:30:48 <eklavya> if I remove loop, it works fine
02:31:30 <sbrg> eklavya: you can't have "where" attached to the expression `forkIO $ forever loop`
02:31:46 <sbrg> move your where clause after the definition of init
02:32:38 <jle`> sbrg: 'where' is a part of syntax for declarations of values in general, not just functions :)
02:33:16 <sbrg> jle`: I'm not sure what distinction you're trying to make, but surely you agree that the use of `where` is not valid in the code above?
02:33:23 <sbrg> unless it's something i never realized you could do
02:33:52 <jle`> sbrg: you said earlier that you use where when you're defining functions
02:33:57 <implementation> merijn: output of "otool -L": http://paste.lisp.org/display/321555 doesn't show any symbols, just other dylibs
02:33:58 <jle`> but it also works for values in general that aren't functions
02:34:00 <jle`> :)
02:34:01 <eklavya_> stupid mac wifi problems :(
02:34:13 <eklavya_> sorry sbrg what were you saying?
02:34:14 <merijn> implementation: Oh, wait, maybe I meant "nm" :)
02:34:16 <mniip> wtf
02:34:39 <sbrg> jle`: values, functions, you know what I mean. by value I assume you mean "foo = 1"
02:34:48 <sbrg> ?
02:34:49 <jle`> values can be functions too!
02:34:54 <jle`> but you said that it only worked for functions
02:35:09 <jle`> just clarifying that it works for non-functions too
02:35:23 <sbrg> no, I didn't. I just used functions because I couldn't really be bothered to be pedantic and explain that in detail since it's not really relevant
02:35:51 <sbrg> eklavya_: your `where` clause is misplaced. 
02:35:59 <implementation> merijn: Yes, the __ZThn920_N12wxHtmlWindow13GetHTMLWindowEv ist listed there
02:36:09 <sbrg> it needs to come after the definition of your `init` function. you cannot 'attach' it to the expression `forkIO $ forever loop`
02:36:10 <mniip> 1469698336 [12:32:16] <jle`> sbrg: 'where' is a part of syntax for declarations of values in general, not just functions :)
02:36:20 <mniip> I think "bindings" is the term you're looking for
02:36:24 <merijn> implementation: Is that the .a or the .dylib of the library? :)
02:36:27 <eklavya_> sbrg: oh ok
02:36:30 <mniip> @src asTypeOf
02:36:30 <lambdabot> asTypeOf = const
02:36:31 <eklavya_> thanks sbrg :)
02:36:33 <mniip> er
02:36:36 <mniip> @src asAppliedTo
02:36:36 <lambdabot> f `asAppliedTo` a = f where _ = f a
02:36:36 <lambdabot> infixl 0 `asAppliedTo`
02:36:42 <sbrg> yw
02:36:50 <mniip> that where clause can be hardly said to declare a value
02:37:21 <merijn> mniip: asAppliedTo is just const with a more specific type
02:37:26 <merijn> :t asAppliedTo
02:37:27 <jle`> mniip: hm, the haskell report calls them declarations
02:37:28 <lambdabot> (a -> b) -> a -> a -> b
02:37:30 <merijn> :t const
02:37:31 <lambdabot> a -> b -> a
02:37:36 <mniip> merijn, not sure why you're telling me this :pp
02:37:40 <jle`> 'where' is a part of declaration syntax
02:37:45 <implementation> merijn: the dylib (I don't find any .a, no idea where that is)
02:38:31 <merijn> implementation: What's the letter in front of the symbol?
02:38:49 <implementation> merijn: U
02:41:09 <BartAdv> what's the reason there's no profunctor instance for pair?
02:42:01 <jle`> BartAdv: pair?
02:42:01 <ertesx> is there a simple way to branch on whether the module is interpreted?  e.g. via CPP
02:42:16 <BartAdv> jle`: 2-sized tuple
02:42:33 <jle`> (,) is covariant on both its arguments
02:42:43 <merijn> implementation: That's saying it's undefined (i.e. missing), so it's supposed to come from one of the other libraries you're linking to, but it can't find it
02:42:50 <jle`> BartAdv: try writing the instance :)
02:43:06 <BartAdv> hah, that might actually be good idea
02:43:20 <jle`> also compare Profunctor to Bifunctor (in base), which (,) is an instance of
02:45:54 <BartAdv> ouch, so I was just thinking about bifunctor but somehow googled profunctor
02:46:16 <BartAdv> silly me, now everything makes sense
02:47:46 <implementation> merijn: that's strange, I compiled wxwidgets with nearly everything enabled
02:49:37 <merijn> implementation: Well, you can use nm to inspect the wxwidgets library to see if it's in there
02:49:40 <merijn> Also
02:49:53 <koz_> OK, I decided to bite the bullet and write a Prim instance. Does sizeOf# mean the size in *bytes*?
02:49:55 <merijn> wxwidgets the haskell library, right? Do you have the actual wxwidgets installed?
02:50:31 <merijn> koz_: Uneducated guess: Almost certainly
02:50:41 <koz_> merijn: That's what I thought.
02:51:35 <koz_> Also, alignment# is meant to be an Int#. What does that even *mean*?
02:52:18 <implementation> merijn: wxWidgets is the actual C++ library (installed, v. 3.0.2), wxc is part of the haskell bindings (v. 0.92.2.0)
02:53:06 <merijn> implementation: Right, I'd check both the C++ library and the wxc library to see if you can find that symbol exported
02:53:08 <freeside_> wxWidgets-dev?
02:53:13 <merijn> koz_: What alignment means?
02:53:21 <merijn> koz_: Or what Int# means?
02:53:53 <koz_> merijn: The function signature is 'alignment# :: a -> Int#'. I am *absolutely* not clear how it expects to understand the alignment of my type from an Int#.
02:54:17 <koz_> I understand what alignment means, but I have no clue how to tell it how to align my data type by means of an Int#.
02:54:20 <merijn> koz_: You give it an 'a' and it returns the alignemtn of 'a' as an Int#?
02:54:32 <koz_> merijn: How do you describe an alignment as an Int#?
02:54:42 <merijn> koz_: uh...alignment is usually a memory offset in bytes? :)
02:54:48 <koz_> merijn: Oh, so 0.
02:54:54 <merijn> i.e. C int usually has an alignment of 4 or 8
02:54:55 <koz_> (it's 1 byte, so it should be 0)
02:55:05 <koz_> merijn: Oh, wait, derp, offset.
02:55:08 <koz_> So it should be 1, then?
02:55:12 <koz_> (if my size is 1)
02:55:15 <merijn> Most likely, it depends :)
02:55:50 <koz_> merijn: OK, well, 1 it is for now.
02:56:01 <koz_> (well, 1# to be exact)
02:57:14 <koz_> OK, I can *see* why it's hell to write...
02:57:33 <koz_> You'd think *enums* wouldn't be hard to prim-pack.
02:57:53 <ljc> hey i'm trying to convert my hello world program into accepting an integer. i've found the `read` function but don't really knowhow to use it
02:58:36 <sbrg> :t read -- ljc
02:58:38 <lambdabot> Read a => String -> a
02:58:46 <sbrg> :info Read
02:58:51 <sbrg> @info Read
02:58:51 <lambdabot> Read
02:58:53 <sbrg> god
02:58:58 <christiaanb> Hi, When working with GHC.Generics, what's the recommended way to deal with 9-tuples and beyond? there is no Generic instance for 9-tuples and beyond
02:58:59 <mniip> that's not a thing that exists
02:59:00 <sbrg> why doesn't lambdabot support @infO'
02:59:06 <sbrg> or rather, :info
02:59:20 <mniip> christiaanb, why would you need that
02:59:25 <implementation> merijn: none of the libwx_*.dylib exports it
02:59:41 <ljc> thanks, i already found the read signature
02:59:43 <sbrg> ljc: the `read` function takes a String and tries to read from it a value. it can read any value that ist an instance of Read
02:59:49 <ljc> but dont know how to use it
02:59:57 <sbrg> > read "23" :: Int
02:59:59 <lambdabot>  23
02:59:59 <christiaanb> mniip: I'm implementing a Show class that prints exeptions as "X", instead of throwing the exception. 
03:00:06 <sbrg> > read "\"foo\"" :: String
03:00:08 <lambdabot>  "foo"
03:00:13 <merijn> implementation: Then the question is, "where is it supposed to come from"
03:00:19 <sbrg> > read "True" :: Bool
03:00:21 <lambdabot>  True
03:00:39 <ljc> so you could have: `num <- read "23" :: Int` 
03:00:54 <christiaanb> mniip: And I'm using Generics to impliment this "ShowX" class. Show is defined beyond 8-tuples, so I wanted to make a ShowX that works beyond 8-tuples also
03:01:07 <sbrg> ljc: <- is not correct in this case, since that's syntactic sugar for monads
03:01:14 <sbrg> but `let` works
03:01:15 <implementation> oh, but I found a symbol T __ZThn888_N12wxHtmlWindow13GetHTMLWindowEv, which looks almost the same, but the number at the start is different
03:01:22 <sbrg> > let value = read "123" :: Int in value * 2
03:01:25 <lambdabot>  246
03:01:27 <implementation> (888 vs 920)
03:01:44 <ljc> k i'm not really sure what monads are yet
03:01:49 <sbrg> you will need to annotate the type of the read application unless you use the value in a context such that the type inferred is unambiguous
03:02:06 <merijn> implementation: the number is C++ name mangling, so I'm guessing the function (and thus name) changed at some point and you're linking a wrong version
03:02:53 <sbrg> ljc: your hello world program, how does it read a value?
03:02:59 <sbrg> you said "accept an integer"
03:03:55 <ljc> http://pastebin.com/p4TV8pZK
03:04:06 <sbrg> alright
03:04:08 <ljc> yep so atm it's taking in a stirng from io
03:04:16 <ljc> so i want to get an integer, but have to convert it from a string
03:04:20 <sbrg> yes
03:04:38 <ljc> a string io if i'm not mistaken, since string != string io
03:04:43 <sbrg> if you add the line: "let intValue = read stuff :: Int" after `stuff <- getLine` you're good to go
03:05:16 <sbrg> ljc: well, it's not IO String, if that's what you're referring to. the type of `stuff` is just String
03:05:38 <ljc> sbrg: oh i see. hm!
03:05:42 <maerwald> read is unsafe
03:05:47 <sbrg> but `getLine` has type :: IO String, but the IO action is evaluated, the result is just a String
03:05:57 <ljc> oh right
03:06:02 <ertesx> s/evaluated/executed/
03:06:19 <sbrg> ertesx: thank you for your important contribution
03:06:20 <mniip> s/result/bound value/
03:06:27 <sbrg> really
03:06:30 <implementation> merijn: thanks for your patience and help. but now i'm still in the situation that i don't know how to fix that :/
03:06:32 <maerwald> when dealing with user input, I'd avoid using "read"
03:06:33 <mniip> there is no result
03:06:50 <freeside_> Is there a way to do a `<-` unwrap and a `read` in one line, without the temp variable `stuff`?
03:07:03 <sbrg> maerwald: maybe we should let the beginner gain a basic grasp of a hello world program before teaching him about partial functions and everything else?
03:07:17 <sbrg> freeside_: aye, `fmap`
03:07:29 <maerwald> sbrg: if he is a beginner, why is he using do-notation?
03:07:29 <ertesx> ljc: do-notation allows you to write IO actions in sequence, and "<-" allows you give some of the individual results names (we call that binding)…  if you write "let x = y", then x and y are in fact the same thing
03:07:52 <tdammers> maerwald: many ways to Rome
03:07:55 <sbrg> .....
03:08:17 <ljc> because i've copied it from my lecturer
03:08:22 <maerwald> well, I usually assume people know at least Monads and Functors when they use do-notation. Otherwise they are probably following a very bad tutorial
03:08:40 <sbrg> I honestly think that this channel is possibly the best irc channel I've ever been in, but really, it's not very helpful to have people chime in with useless pedantic suggestions that do absolutely nothing to help the person that's asking the question
03:08:44 <ertesx> maerwald: i couldn't disagree more
03:08:50 <sbrg> except maybe prove to everyone else that you're a really smart dude or something
03:09:02 <tdammers> maerwald: you don't need to know *everything* about monads, and do notation is IMO as valid an entry point as any
03:09:16 <sbrg> maerwald: what kind of ridiculous assumption is that? based on what?
03:09:18 <maerwald> implementation: are you a beginner?
03:09:26 <maerwald> err
03:09:30 <maerwald> ljc: ^
03:09:30 <ertesx> sbrg: if you skip over important details, it bites people…  evaluation and execution are not the same thing, and they shouldn't be treated as such
03:09:33 <sbrg> What exactly is it that would make you think for a second that only "experienced" people use do notation?
03:09:53 <tdammers> obvious downside with using do notation without being familiar with monads is that the imperative looks are deceiving
03:10:05 <tdammers> but you'll hit that point sooner or later, and then you can still figure it out
03:10:23 <sbrg> ertesx: unless you dig really deep into the exact meaning of those words, both of them convey exactly the same meaning, at least enough for a beginner. there is no reason to waste a beginner's time trying to teach him about some really specific jargon that he has no use for
03:10:36 <maerwald> sbrg: it's an assumption based on experience which can be wrong. If it's wrong, it's good to escalate it and tell the "beginner" to stop using do-notation until he understands monads.
03:10:58 <tdammers> and meanwhile, the imperative model is good enough to get you to the point where you can write a main action to bootstrap into your pure code, without actually understanding monads or IO or any of that
03:11:11 <ertesx> sbrg: i teach haskell for many years now, and confusing these two notions makes people write stuff like "case getLine of"
03:11:24 <sbrg> maerwald: according to whom? Are you the sole authority on how people should learn programming languages? 
03:11:25 <freeside_> I think this pedagogical stylistic issue is addressed at https://github.com/bitemyapp/learnhaskell/blob/master/coc.md
03:11:37 <ertesx> sbrg: if you don't care about my contribution, ignore it, but if stop being stubborn and listen, you could improve as a teacher
03:11:44 <tdammers> oh, and you don't even have to understand monads at all; you can use do notation correctly on one particular monadic type by understanding its monad features specifically to that type
03:11:47 <maerwald> sbrg: I don't understand what that is supposed to mean. I was saying my opinion here or can I not do that anymore?
03:12:09 <tdammers> i.e., you can get started with just IO, and reasoning about >>= and >> and return in terms of what they mean in IO
03:12:13 <maerwald> I think you somewhat take this discussion to seriously
03:12:26 <sbrg> ertesx: according to you, perhaps. I, too, have taught haskell for a few years now, and I am 100% sure that the people I taught were simply too busy trying to understand how haskell works in general to even realize the distinction between execution and evaluation. 
03:12:29 <maerwald> and start getting aggressive, while there is no use to it
03:12:45 <maerwald> the distinction is fundamental
03:12:50 <maerwald> I agree with ertesx
03:13:10 <sbrg> maerwald: I am really not trying to be aggressive. what makes you think that? I'm just trying to have a discussion
03:13:25 <maerwald> it is what makes haskell "functional" in the end, that's the paradigm shift
03:13:28 <LKoen> sbrg: the first three tutorials I found about haskell didn't teach me much, because they tried to explain do notation before what it stood for, and that didn't make any sense to me
03:13:33 <sbrg> perhaps I am little bit frustrated by people trying to butt in with their deep knowledge when you're just trying to help a beginner grasp the very basics :)
03:14:13 <LKoen> they were all like "haskell is a functional language but hey look at our cool imperative notations!!"
03:14:14 <freeside_> CS prof: "To understand any of this, you first have to understand all of it. So most of you should pass this class the second time you take it. Now, let's begin."
03:14:31 <ljc> maerwald: sorry, yes i am a beginner. reason i used 'do' notation is because of my lecturer's code
03:14:42 <tdammers> LKoen: yeah, that's a bad idea - but I believe introducing do notation in a way that you just brush over some superficial rules of thumb for the time being, and get back to fully explaining things later, isn't a bad approach IMO
03:14:52 <sbrg> At any rate, in my experience, teaching people from the "bottom up" is not always the best idea. I'd rather have people engaged and engrossed, writing programs that do something, even if they're using do notation without fully understanding it. 
03:14:58 <maerwald> ljc: ask your lecturer why he explains syntactic sugar before explaining what the syntactic sugar resolves to and the concepts behind it
03:15:01 <ertesx> sbrg: i don't get why you're making such a big deal out of this…  why not just use the proper terminology in the future?  right now *you* are wasting everyone's time
03:15:04 <sbrg> tdammers: exactly 
03:15:19 <maerwald> it's like explaining list comprehension before explaining lists
03:15:32 <LKoen> eventually I learned about >>= and >> and *then* about do notation and it was way easier than the other way around
03:15:34 <sbrg> ertesx: not really. I was just minding my own business, more or less. Much like I can feel free to ignore your opinion, you do not have to engage in a discussion with me. 
03:15:37 <tdammers> maerwald: no, they key is that you don't actually explain it *at all*
03:15:39 <maerwald> LKoen: agreed
03:15:41 <tdammers> you brush over it
03:15:55 <ljc> maerwald: he talked about it, and i what i learned is that syntactical sugar is easy for the coder, but is assembled into something else. like a[i] in C
03:16:06 <tdammers> to maintain your intellectual honesty, you can add warnings, like "this is not *actually* how do notation works, but it'll do for now"
03:16:15 <sbrg> ^
03:16:41 <freeside_> "it'll do, ha-ha!"
03:16:45 <tdammers> e.g., you can say that (as far as IO is concerned), do { foo; bar } means "execute foo and bar in order"
03:16:55 <tdammers> freeside_: accidental pun ;0
03:16:55 <ljc> but this is all very enlightening :)
03:17:02 <ertesx> the curse of the many teachers
03:17:09 <ecvk> are haskell beginners allowed here? :)
03:17:11 <ljc> your discussions are good
03:17:26 <ljc> ecvk well i haven't been banned yet haha
03:17:34 <freeside_> I won't bind you to it! Now we will return.
03:17:37 <ecvk> ljc haha
03:17:42 <tdammers> or that do { x <- foo; bar x } first executes foo, binds its result to x, and then calls bar on it
03:17:56 <ljc> sbrg: your comment about best irc channel, were you using irc in the 90's? because that's when it was really fun
03:17:58 <ertesx> ljc: FWIW i don't think that do-notation for beginners is a bad idea
03:18:11 <sbrg> ljc: I was, but I was a kid then, so not really much experience
03:18:16 <maerwald> ertesx: well, on IRC it's rather easy to follow a particular conversation while ignoring other ppl who chime on, so I think it's not that bad. You can always read the rest of the answers later and think if it contributed something
03:18:45 <ljc> ertesx: cool. i'm def going to read up on it now (after this discussion) for sure
03:18:46 <freeside_> That's what we call lazy evaluation
03:19:04 <tdammers> it's not exactly correct, but explaining how it actually works is a chicken-and-egg problem, because in order to understand this, you first need to understand the Monad concept, how the IO type forms an EDSL for combining effectful computations, and how this allows us to write impure programs in a pure language
03:19:07 <ertesx> ljc: well, there isn't much more to it than i explained above (for now)
03:19:49 <ljc> ertesx: ah ok, thanks! :)
03:20:02 <tdammers> and in order to understand all that, it's really really useful to be familiar with plain old pure (as in "not involving monads") Haskell functions, typeclasses, polymorphic types, etc.
03:20:07 <ertesx> maerwald: the problem is that a beginner may not know which thread to follow
03:20:19 <ertesx> and i tend not to interject when others are teaching
03:20:31 <tdammers> which is a lot easier to understand if you can play around with it in an actual program that you can actually run
03:20:41 <LKoen> tdammers: in my experience "this is not how this works but just pretend it is for now" is the most confusing way to teach something. I am not talking about haskell specifically; all classes I've taken or book I've read in my life that did this made things much more complicated and confusing than they were
03:20:43 <ertesx> except when they teach stuff that is objectively wrong
03:21:05 <jchia_> Hi, let's say i have a record type with multiple Int fields. I want to combine two records so that for each field, I either take the max of the field from the two records or take the sum, and use it as the value of the same field in the computed record. Is there a succinct way to do without involving mentioning the each field name twice in the source code?
03:21:12 <ertesx> even when it's just a nitpick…  wrong is wrong
03:21:13 <tdammers> LKoen: more like, "use this code as a template for now, I'll explain how and why it works later"
03:21:17 <maerwald> ertesx: well, suggesting "read" for parsing user input is somewhat "wrong" to me ;) without knowing too much of the context
03:21:50 <tdammers> ertesx: there's a difference between "factually wrong" and "morally wrong"
03:21:51 <jchia_> E.g. data Foo = Foo {a :: Int, b :: Int}. I want to define (<>) so that for a, I use (+) and for b I use max
03:22:05 <dibblego> I have seen students given that explanation, and then they are confused for years, unaware of how dissimilar it is to true things.
03:22:06 <ertesx> maerwald: that wasn't a reference to that
03:22:16 <sbrg> when teaching someone, "objectively wrong" is .. well, IMO, it's fine to be "handwavy" in an attempt to get someone to gain intuition, even though it is "objectively wrong"
03:22:40 <dibblego> and yet it takes a few minutes to understand when explained accurately and progressively
03:22:48 <maerwald> dibblego: what are you referring to exactly?
03:22:53 <maerwald> do-notation?
03:23:24 <sbrg> tdammers: all your points are basically all the points i would make myself, and it mirrors exactly my experience teaching multiple different programming languages to people that are new to programming
03:23:28 <dibblego> do { foo; bar } means "execute foo and bar in order"
03:23:44 <ertesx> sbrg: i had that attitude for a long time, but all these little "just right enough" things pile up, and in the end, when people seek help elsewhere, they can't explain themselves properly and get confused about the information they are given
03:23:45 <dibblego> this is a) not true b) not helpful c) potentially disastrous for anyone who believes it
03:23:46 <sbrg> perhaps if you're teaching a more experienced crowd, then you can dive into the details immediately. 
03:23:54 <maerwald> dibblego: ah, yeah
03:23:54 <ertesx> sbrg: that's why i'm pedantic about terminology
03:24:27 <dibblego> Classes of 40+ people solving far more advanced problems in NICTA/course after two days. This happens, regularly.
03:24:56 <sbrg> ertesx: No one is saying that you just leave people at that level.
03:25:20 <ertesx> sbrg: but when you're going to correct them later, why not just feed them the correct information in the first place?
03:25:25 <tdammers> dibblego: a lot depends on the audience
03:25:25 <ecvk> Hello, I'm very interested in learning haskell, i believe that some of you here has a good knowledge when it comes to haskell, can you show me what can you do with haskell? or what you have already did? Thanks!
03:25:29 <dibblego> those who struggle have had a prior pseudo-approximation and then fail to let it go
03:25:40 <ertesx> sbrg: especially when it's as trivial as choosing the right words
03:25:46 <sbrg> but if you go from "how do I make this hello world program take an integer" into a discussion about monads in general and do notation and syntactic sugar and evaluation and execution and whatnot, you're not gonna make much progress
03:25:52 <tdammers> dibblego: I would argue that in such cases, the failure to let go is to blame, not the pseudo-approximation
03:26:04 <ertesx> sbrg: you're not calling monads "warm fuzzy things", are you?  you're calling them monads, even for beginners
03:26:07 <hpc> ecvk: take a look through http://hackage.haskell.org/packages/
03:26:14 <freeside_> You are arguing about the duality between theory and empiricism. Some people are natural theorists, who begin with math and reduce it to code. Some people are natural empiricists, who begin with given code and deduce theory from it. A scientist builds in order to learn, an engineer learns in order to build. Perhaps we can resolve the difficulty by explicitly setting any given pedagogical transacti
03:26:15 <freeside_> on in the context of one style or the other, matching it to the learner.
03:26:23 <dibblego> tdammers: the failure to let go exists, because of how much needs to be let go (all of it, because it is all completely useless, and has benefitted a total of zero people in the history of humanity)
03:26:27 <ecvk> thanks hpc
03:26:51 <tdammers> ertesx: well, one thing that I think causes a lot of confusion is talking about IO's monadic nature even when that's not very relevant to how IO represents effectful computations
03:26:54 <maerwald> ertesx: the haskell language report doesn't even specify anything about execution (order) or the RTS afair, so I feel that's also something mentionable and also lines out that the difference in haskell about execution/evaluation is not fuzzy, but very real
03:27:11 <ertesx> tdammers: then don't talk about IO's monadic nature
03:27:18 <ertesx> but *if* you talk about monads, you should call them monads
03:27:19 <tdammers> ertesx: exactly
03:27:45 <osa1> uhhhh what's wrong with cabal I get linker errors after the first `cabal build`
03:27:47 <tdammers> ertesx: I can explain >> and >>= and return and fail in the context of IO without mentioning monads at all
03:27:53 <ertesx> similarly: if you talk about execution, call it execution, not evaluation, especially since at the point when people learn about execution, they already have a notion of evaluation that *disagrees* with execution
03:27:58 <osa1> I have to clean before every `cabal build`
03:28:01 <tdammers> ertesx: just like I can explain map without talking about functors
03:28:06 <sbrg> ertesx: Well, if I were teaching beginners, I refrain from talking about monads as long as I can. I'm not going to get anyone to learn a programming language if I first have to dive into concepts that are based on concepts from abstract mathematics they have never heard of. I want people to want to learn, and being able to write code that works to experiment helps with that. And if people are really new,
03:28:08 <sbrg> they don't even pick up on, for example, my usage of "evaluation" vs "execution"
03:28:12 <freeside_> ecvk, the current discussion has lifted teaching Haskell to a discussion about how to teach Haskell, so if you have an actual question, maybe better go to #haskell-beginners 
03:28:52 <maerwald> tdammers: I feel it's more useful to try the "natural" explanation order of things... like the cis course does. It's proven to work rather well.
03:28:55 <sbrg> anyway, I have to run. good talk!
03:29:08 <ljc> cheers sbrg!
03:29:14 <tdammers> maerwald: again, depends on the audience
03:29:17 <jchia_> how do I make my definition of (<>) more concise? I want to avoid mentioning the field names, or at least mentioning each field name twice because there are many fields. http://lpaste.net/172467
03:29:33 <maerwald> ofc you can teach things upside down and then correct yourself after every lecture "I have been lying" :P
03:29:35 <ertesx> sbrg: really i don't think you're a bad teacher…  i just think that some of your low-level choices may be misguided…  you could consider this a nitpick, but i assure you, i have reason to tell you that, based on my own experience
03:29:52 <hpc> :t on
03:29:54 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
03:29:58 <dibblego> if the audience is of the type, "wishes to know true things", then say no things that are not true, and serve only to cause confusion in a net negative direction from knowing nothing at all
03:30:03 <tdammers> maerwald: the way I learned things, without any teacher or tutor, mind you, was through the incorrect mental model of do notation as pseudo-imperative
03:30:28 <maerwald> tdammers: that doesn't mean it's the most effective way
03:30:42 <dibblego> jchia_: instance Semigroup Foo where Foo a1 b1 c2 <> Foo a2 b2 c2 = Foo (a1 + a2) (max b1 b2) (c1 + c2)
03:30:48 <hpc> jchia_: there's probably something fancy you can do with ((+) `on` a), (max `on` b0), etc
03:30:59 <hpc> or... that probably works better
03:31:22 <tdammers> maerwald: it probably was for me; the "correct way" just didn't make it past my brain's resistance at first, because I had so many other things to understand first, and getting productive and writing stuff using my incorrect ad-hoc model was what got me there
03:31:41 <jchia_> dibblego: this way i have to spell out field names 4 times
03:31:43 <dibblego> tdammers: how have you verified your understanding?
03:32:15 <tdammers> dibblego: what do you mean, verify my understanding? I read a lot, it didn't make sense at first, until at some point it did.
03:32:35 <sbrg> ertesx: Sure, and thank you for attempting to improve my teaching. I'm sure you were just trying to help. But you have to consider that it doesn't make much sense for me to put much stock into advice from some strangers on the internet on my teaching habits when you have a couple of lines of text in irc to base your 'opinion' of my habits on. 
03:32:45 <sbrg> i don't mean that in any inflammatory way. 
03:32:50 <dibblego> tdammers: how do you know that what you know is accurate?
03:32:50 <sbrg> anyway, gtg
03:32:52 <sbrg> laundry time
03:32:56 <maerwald> The only challenge in the way of teaching only "true things" is that you have to explain relevance up-front. That can be hard.
03:33:05 <dibblego> do not
03:33:08 <tdammers> dibblego: I don't? Does anyone?
03:33:14 <dibblego> tdammers: Yes.
03:33:32 <ertesx> sbrg: no worries…  have fun =)
03:33:32 <maerwald> a lot of maths teachers don't talk about relevance at all, which is really bad
03:33:40 <freeside_> Does liquid water become denser as it cools?
03:34:23 <tdammers> dibblego: I do observe, however, that conclusions I draw from my current mental model seem to work out, and that when I write down my mental model according to a set of formal rules, it's consistent, as far as I can tell
03:34:41 <ertesx> maerwald: in my experience relevance better follows from context:  teach by solving a problem
03:34:48 <ljc> dibblego: have you done the nicta course? i've just cloned it, done `ghci` but don't know how to get started
03:35:06 <maerwald> ertesx: not always possible, because the problem might be really hard
03:35:24 <fr33domlover> ljc, I learned Haskell using the Haskell Wikibook and it was amazing
03:35:29 <ertesx> maerwald: that try to break up the problem into milestones or choose a different problem =)
03:35:45 <ertesx> s/that/then/
03:36:27 <maerwald> ertesx: how do you find a practical non-esoteric, useful problem for the Bézier curve that gives enough context to naturally understand why it's useful? It normally involves writing a large OpenGL program and seeing for yourself. That's too much time.
03:36:31 <ljc> thanks fr33domlover ! checking it out now also. there's so many resources for this language
03:37:37 <ertesx> maerwald: in a learning context drawing pretty pictures is a worthy problem, and it gets people engaged…  just tell them upfront that there is a long way ahead of them =)
03:37:38 <fr33domlover> ljc, the wikibook is also free culture work (CC by-sa, iirc), which isn't true for most other Haskell tutorials and books
03:37:51 <koz_> fr33domlover: Correct on the licensing.
03:37:53 <ertesx> maerwald: and maybe don't use OpenGL when teaching bezier curves…  use the easiest graphics library you can find
03:38:12 <maerwald> ertesx: in a maths course? 
03:38:33 <maerwald> which is basically only about theory... :P
03:39:00 <tdammers> maerwald: in a math course, you don't need to write a program at all, you just present a bunch of example bezier curve plots and the corresponding parameters
03:39:02 <maerwald> all you can reasonably do is say "ok, this will be useful for a, b, c"
03:39:05 <ertesx> maerwald: i think most math courses are too dry…  they could benefit from some practical fun problem-solving
03:39:19 <tdammers> and, again, audience matters
03:39:22 <ertesx> maerwald: the problem is rather that schedules are often too tight, so you don't exactly have time to write programs
03:39:38 <fr33domlover> I once used bezier curves to create some basic rope simulation
03:39:39 <liste> maerwald: would the original motivation for bezier curves be enough?
03:39:45 <maerwald> I think it's enough to say what it will be useful for and where it will be used later
03:39:48 <fr33domlover> I mean, the rope would be drawn using these curves
03:39:53 <ertesx> maerwald: alternatively as a teacher do the programming upfront and show them a fancy animation…  that's often enough to make math fun and engaging
03:40:18 <ertesx> maerwald: to you and me that may be enough, but most people learn best when engaged
03:40:24 <ertesx> to be honest, me too =)
03:40:48 <maerwald> ertesx: yes, but my point was about things that are hard to get engaged directly in
03:41:28 <ertesx> maerwald: well, category theory would be a good example of that:  i still have only bits and pieces here and there
03:41:30 <maerwald> e.g. you take a course "haskell web development" and end up learning a lot about monad transformers, gotta tell people why
03:41:44 <ertesx> after almost 10 years of haskell i barely know what a limit is
03:41:52 <ertesx> because i have no problem to solve with them
03:42:04 <maerwald> ertesx: yeah
03:42:17 <ertesx> and i *tried* to learn them
03:42:29 <tdammers> IMO a course on "haskell web development" should either focus on teaching Haskell (and use web dev as a practical context), or it should assume existing Haskell knowledge
03:42:35 <maerwald> if you can do follow-up exercises directly (e.g. when teaching Functors, Monoids etc), then sure
03:43:16 <maerwald> if not, you gotta at least explain the relevance
03:43:18 <tdammers> i.e., "so you know Haskell, here's how you use it for web dev", or "so you know Web Dev, here's how Haskell works"
03:43:56 <tdammers> anyway, there's many ways to Rome, but "concrete to abstract" and "problem to solution" strikes me as a more natural learning progression than the other way around
03:44:48 <tdammers> and this also means that just writing do { putStrLn "hello"; putStrLn "world" } and observing that it does in fact first print "hello" and then "world" is not wrong in any way
03:44:55 <tdammers> what matters is where you go from there
03:45:47 <tdammers> one valid followup is to desugar the do notation
03:45:54 <dibblego> ljc: Yes. I wrote it.
03:46:16 <maerwald> tdammers: well, there's always a "motivation" in maths solutions, but lots of times people don't really know what problems it can really solve :P ... so, saying "here's a concept to describe something" first and then say "ok, now let's have a look what problems we can solve" can be useful too (imo, applies to CT as well)
03:46:23 <tdammers> i.e., start explaining *why* you see the observed behavior
03:47:15 <tdammers> OTOH, approaching the thing from the other end, something like "A monad is a monoid in the category of endofunctors", doesn't strike me as equally useful
03:47:24 <maerwald> I think maths and physics ppl have less of a problem with the "describe something first"-approach
03:47:32 <tdammers> probably, eys
03:47:37 <tdammers> yes*
03:47:45 <maerwald> because being able to describe something is a beauty in its own
03:47:48 <tdammers> again, audience matters
03:47:49 <ljc> dibblego: cool! thanks! i love nicta ;) just getting started now. seems a bit tricky to do solo though
03:48:12 <dibblego> ljc: yes, it would be difficult. We are probably running it again in Sydney soon, maybe October.
03:48:32 <cloudhead> it's the classic "can haskell functions take multiple arguments" question, which is the right answer, to a beginner?
03:48:39 <maerwald> hehe
03:48:49 <maerwald> I usually say "yes, but"
03:48:57 <dibblego> cloudhead: The answer is no, always, and especially to a beginner.
03:49:05 <tdammers> I usually say "no, but we can make them look almost like they could"
03:49:12 <cloudhead> see it's interesting
03:49:16 <ljc> dibblego: awesome. i'll tell my work colleagues too. i'm currently doing a course with it at the uni
03:49:28 <dibblego> ljc: a uni course is using it?
03:49:31 <maerwald> cloudhead: maybe the answer yes/no isn't that important, but the explanation that follows
03:49:51 <cloudhead> right but the point is whether or not you actually explain it or leave it for later
03:49:55 <ljc> dibblego: sorry, not using the course you wrote. i meant haskell
03:49:55 <dibblego> it's very important, and there are practical exercises where commitment to it being true is essential, or you'll fail
03:49:59 <dibblego> ljc: ah ok
03:50:12 <cloudhead> "yes, but <explanation on currying>" vs. "yes, for now"
03:50:16 <tdammers> the weird thing is that throughout the community, people *do* talk about f :: a -> b -> c as "a function that takes two arguments"
03:50:16 <ljc> but i'm at unsw
03:50:22 <maerwald> cloudhead: I once did a basic haskell source and I simply avoided those kind of functions like hell in the slides until I got to currying :P
03:50:24 <cloudhead> yeah exactly
03:50:26 <dibblego> ljc: ah, Manuel?
03:50:28 <maerwald> s/source/course/
03:51:02 <ljc> yeap. only been one week, but good so far
03:51:08 <cloudhead> maerwald: ha yeah, see I think some people are quite comfortable using things they don't understand yet
03:51:11 <ertesx> cloudhead: my answer to that is "no"…  a function takes exactly one argument
03:51:11 <cloudhead> as part of the learning process
03:51:39 <maerwald> tdammers: I find it ok to talk about functions that way, otherwise it just becomes tedious to communicate
03:51:41 <cloudhead> ertesx: but then you have to dive into currying/partial application
03:51:47 <ertesx> cloudhead: and i wouldn't even bother to hand-wave: "but because of currying it looks like …"
03:51:48 <cloudhead> when it can be really distracting to the topic at hand
03:51:58 <ertesx> cloudhead: people can see that for themselves
03:51:59 <tdammers> maerwald: yes, and in many situations, the incorrect model is good enough
03:52:32 <dibblego> type constructors are functions, and all functions take one argument, and if you don't believe that, you're going to really struggle when you see instance Monad ((->) t), which happens on day one
03:52:34 <LKoen> tdammers: is map a function that "takes a function and a list and applies the function to every element of the list" or a function that "takes a function and returns an elementwise list function"
03:52:36 <tdammers> f x y = x + y -- reasoning about this in terms of "a two-argument function that returns the sum of both its arguments" is good enough
03:52:50 <maerwald> tdammers: I mean, depending on the input, you can "feed a function more arguments than it appears to have" :P so that's a nice example to tell people "ok, wtf is going on"
03:52:52 <ertesx> cloudhead: in general i have a "don't answer unasked questions" policy, and at the same time i invite people to ask as many questions as they can
03:52:59 <dibblego> tdammers: No, it is a) not true b) not helpful c) very damaging to progress 
03:53:28 <tdammers> dibblego: yet people do it all the time, and they survive just fine
03:53:34 <dibblego> tdammers: No they don't.
03:53:39 <tdammers> *sigh*
03:53:44 <cloudhead> ertesx: yes, because answering unasked questions usually means more confusion and questions
03:54:06 <dibblego> tdammers: those same people are very confused on certain practical exercises and I know that *because I have to coach them out of it, constantly*
03:54:29 <dibblego> tdammers: further to this, such an unhelpful, inaccurate explanation serves no relative benefit anyway
03:54:35 <tdammers> I think the confusion is largely unavoidable, and beneficial to the learning process
03:54:39 <dibblego> it is not even an approximation
03:54:44 <dibblego> it's just completely false
03:54:54 <dibblego> well, then you're wrong and I have hundreds of students who agree with me
03:55:20 <cloudhead> struggling is normal though, that's what learning is
03:55:30 <tdammers> ^ this
03:55:34 <zomg> dibblego: I suspect there's hundreds of people who agree with the opposing perspective as well, I mean just look at how divided everyone here is :)
03:55:42 <ertesx> tdammers: i agree that confusion *can* be an aid, but only if it's based on the genuine difficulty of the subject matter
03:55:44 <dibblego> struggling inefficiently, without progress, may or may not be normal, but it's completely avoidable
03:56:01 <tdammers> you from a mental model that matches what you've seen so far; you get confused when it turns out to be incorrect; you adjust your mental model
03:56:04 <ljc> learning, for me, is asking questions
03:56:09 <tdammers> rinse and repeat until the model is right
03:56:23 <dibblego> zomg: then let's test it, because I hear about these people who use completely false, inaccurate explanations as if it has some mystical benefit, and yet I have never met such a person. Only weird claims that when put under test, fall over like sand.
03:56:41 <ertesx> in fact when teaching i make mistakes all the time
03:56:46 <locallycompact> I think the exact opposite of everyone here
03:56:50 <freeside_> Please be reminded that in 5 minutes the North Abbey will host a discussion about how many angels can dance on the head of a pin. 
03:57:09 <cloudhead> :3
03:57:23 <tdammers> dibblego: http://hackage.haskell.org/package/base-4.9.0.0/docs/Data-List.html#v:intersperse
03:57:31 <ertesx> and often i ask my audience questions that don't make sense
03:57:35 <sbrg> I've taught like .. 150 people Haskell, and using "approximately correct" explanations to help people gain intuition like tdammers is advocating has worked very well. 
03:57:37 <tdammers> "the intersperse function takes an element and a list"
03:57:38 <sbrg> ¯\_(ツ)_/¯
03:57:53 <dibblego> here is my experience, 100% of people who claim "functions take multiple arguments" is a useful approximation (it's not, it's just false), fail very early when given practical exercises of increasing difficulty where reliance on this falsehood must be abandoned. 
03:57:54 <tdammers> who wrote that? it's false!
03:58:09 <dibblego> yes it's false, woopy?
03:58:10 <tdammers> the intersperse function takes exactly one argument
03:58:13 <dibblego> Correct.
03:58:22 <tdammers> but it's in the documentation for base
03:58:25 <tdammers> and that's just one example
03:58:32 <dibblego> there are lots of wrong things on the internet, so what?
03:58:38 <locallycompact> why is this wrong
03:59:01 <tdammers> this isn't just "the internet", this is the documentation that comes with the de facto standard Haskell implementation itself
03:59:06 <dibblego> if that sentence is interpreted to mean that intersperse takes not-one argument, then it's wrong, because intersperse takes one argument
03:59:23 <dibblego> tdammers: I once worked on the JVM, implementing the JVM specification. Do you know how many wrong things are in that document?
03:59:28 <locallycompact> dibblego, what argument
03:59:28 <zomg> It's interesting because to me the fact that functions take multiple args but the language curries them is fairly intuitive... I mean, syntax-wise, I write a function which does take multiple args
03:59:43 <dibblego> locallycompact: the only argument that the function takes (all functions take one)
03:59:45 <zomg> Syntax-wise, I don't write a function which returns a function which returns a function... :)
03:59:59 <zomg> As much as it may be true on a more low-level thinking
04:00:03 <dibblego> zomg: no you don't write a function that takes multiple arguments syntax-wise
04:00:08 <dibblego> function application is lef-tassociative
04:00:09 <tdammers> dibblego: my point is that while it's wrong, there must be a nonzero number of quite intelligent people perfectly capable of writing and understanding Haskell who consider this wrong model helpful
04:00:28 <dibblego> tdammers: I disagree, and I have tested it hundreds of times, so I'd like to meet this mystery individual
04:00:43 <zomg> dibblego: why does writing a function with one arg look different from writing a function with multiple args if that's the case?
04:01:00 <sbrg> dibblego: I am perfectly capable of writing and understanding Haskell and I find this wrong model helpful
04:01:05 <dibblego> zomg: function application is left-associative. Put some parentheses in there.
04:01:07 <sbrg> especially when teaching beginners
04:01:08 <locallycompact> Sorry I don't see at all why these percepts need preclude each other
04:01:13 <Gurkenglas> http://lpaste.net/172469 lines 59 and 61 trace identically, but 94, 95 and 97 indicate that a rectangle has moved. Why?
04:01:24 <x4w3> Hi, Could I disable keys for example in terminator for only use xmonad keybinds?, beacuse when i focus terminator window i cant for example close session in xmonad. Thank u in adv.
04:01:45 <dibblego> sbrg: to clarify, I do not mean "capable of writing haskell"; I specifically mean, "capable of solving problems where this model must be abandoned or you will fail"
04:02:06 <dibblego> sbrg: and when that failure occurs, we ask the question, "what was the benefit in believing this dfalse thing?" and the answer is, it never existed
04:02:09 <ertesx> @pl \l u n c h -> flip (flip (flip (flip (flip (.) (flip (.) z (i . z)) p) u) n) c) h (a l)
04:02:09 <lambdabot> p . i . z . z . a
04:02:13 <zomg> dibblego: it makes sense in function application but the syntax for declaring a function, I don't really see how that would work :)
04:02:14 <dibblego> so, on the latter claim, feel free to demonstrate that benefit
04:02:19 <tdammers> dibblego: so you would like to see the documentation rewritten to "intersperse takes an element and returns a function that takes a list and returns a list that is the result of interspersing the element between elements of the list"?
04:02:31 <locallycompact> dibblego, can you give a specific example
04:02:49 <sbrg> dibblego: Thinking "this function takes 2 arguments" and knowing that "this function can also be partially applied to produce another function because it really only has one argument" are not mutually exclusive.
04:03:09 <locallycompact> I don't see why I having both perceptions of a function is deterimental.
04:03:13 <Gurkenglas> Also if I remove line 56 (which only traces), the 94/95/97 stop tracing altogether
04:03:19 <dibblego> tdammers: No, I don't care what that sentence says. Once the concept is grasped, loose language is quite fine. Also, in my experience, once the concept is grasped, it is a realisation that this not-true, not-even-an-approximation falsehood was never helpful to begin with.
04:03:47 <dibblego> sbrg: They are different concepts. One is wrong.
04:03:50 <freeside_> Type constructor symbols T introduced by type synonym declarations cannot be partially applied; it is a static error to use T without the full number of arguments.
04:03:56 <sbrg> dibblego: it was helpful to begin with if this wrong model helped you use this function
04:04:07 <tdammers> exactly
04:04:19 <dibblego> sbrg: I would like to see this helpfulness demonstrated. I have heard it claimed hundreds of times and every time, it falls apart.
04:04:37 <cloudhead> and it's helpful now when talking about functions, it's a useful shortcut
04:04:48 <dibblego> thinking "this function takes two arguments", although wrong, did not help you. You just fluked it.
04:05:01 <locallycompact> no, it helped
04:05:05 <dibblego> yes, *talking* with *l;oose language* is quite a different thing to what is being claimed, which is *thinking about it*
04:05:10 <locallycompact> it helped me call it it helped me get a result
04:05:19 <dibblego> show where it helped
04:05:20 <ertesx> fast and loose talking =)
04:05:29 <dibblego> how does this not-true thing help?
04:05:47 <dibblego> "lucky you thought that not true thing, or it would have been less helpful!"
04:05:48 <locallycompact> because truth is not a metaphysical primacy it's a matter of disclosure
04:05:52 <dibblego> I want to say that to your case
04:05:53 <cloudhead> because you can get to more important not-true things that need to be understood first
04:05:57 <locallycompact> I have a function f a b
04:06:03 <locallycompact> I need to find an a and a b to put in my f
04:06:07 <dibblego> ok, so you fluked it
04:06:11 <x4w3> How could i activate some xmonad keybinds into terminator? i can't for example close xmonad session, thanks.
04:06:21 <locallycompact> no, I used a valid percept
04:06:21 <dibblego> you believed a not-true thing, and fortunately, its falsehood did not incur a penalty
04:06:25 <tdammers> dibblego: simple. When I first learned all this, the concept of a function that returns a function that returns a function was just too much to wrap my head around. Going with the idea of multi-argument functions, even while knowing that it was incorrect, helped me *use* the function, in a hands-on way, and from there, I could experiment with "partial application" (which is, in fact, also an incorrect term
04:06:27 <dibblego> Yes, this can happen, quite a lot
04:06:28 <tdammers> in this context, because you cannot partially apply functions that take only one argument anyway), repeatedly applying some formal rules to see how they work out, etc., finally made things click
04:06:30 <Gurkenglas> A traceShowM is having a side effect pls send help
04:06:31 <dibblego> Now, show where it *helped*
04:06:35 <tdammers> I never *believed* the untrue thing
04:06:47 <freeside_> https://en.wikipedia.org/wiki/Lie-to-children
04:06:48 <locallycompact> I believed it, it worked
04:06:54 <ertesx> i think this discussion has derailed
04:07:36 <tdammers> in fact, I *chose* to do that, because I noticed that I couldn't quite wrap my head around the correct explanation yet, but I needed a way to get there
04:07:39 <dibblego> I hope to one day put you all under a test, fail you early, then say, "now stop believing that untrue thing", while your peers, who never even heard such a thing, are ahead of you. Because this happens *every time*
04:07:45 <cloudhead> it helps because you get to learn about things at your own pace
04:08:11 <cloudhead> by skipping over things that are harder to understand
04:08:15 <dibblego> unless, you are all that mystery individual, that I keep hearing about, but never meet
04:08:23 <dibblego> "the one that actually benefits by this false thing"
04:08:31 <sbrg> dibblego: i'm not sure what you mean by a "demonstration". if someone who is new to haskell uses the wrong model that a function takes n arguments and that model helps him use the function correctly, which it can and has done for students in my experience, then it was helpful
04:08:34 <tdammers> again, I didn't actually believe it, in the sense of "I know this to be true"; I used it as a temporary hypothesis, a crutch towards better understanding
04:08:38 <dibblego> I am extremely suspicious this individual doesn't exist
04:08:41 <ertesx> and at this point it's unlikely that it will reach a satisfying conclusion for anyone
04:08:44 <dibblego> I'm out.
04:08:47 <tdammers> vOv
04:08:49 <sbrg> thank god
04:09:16 <sbrg> okay wrong channel. 
04:09:29 <sbrg> (the thank god part, i was not trying to be an asshole)
04:09:45 <cloudhead> haha
04:10:19 <cloudhead> well, I am curious about the nicta course now
04:10:39 <locallycompact> what's a nicta course
04:10:43 <maerwald> I understand dibblego. It's a way of teaching that may put students through more "pain", but will also force a different mindset of thinking about new concepts.
04:10:43 <dibblego> cloudhead: do it, and you'll be way ahead of the people who think that functions take more than one argument is a helpful falsehood
04:10:55 <dibblego> it's less pain, don't believe the lie
04:11:03 <ertesx> in general as a teacher you always try to get right what your own teachers got wrong, and that's why people have strong opinions on what's the best way to teach
04:11:07 <cloudhead> will report back :)
04:11:23 <locallycompact> If you get through type theory and are still hung up on deformities like truth and falsehood you did the whole thing wrong anyway
04:11:32 <maerwald> dibblego: I know it's more pain.
04:11:35 <maerwald> to some
04:11:41 <maerwald> but that's fine with me
04:11:43 <dibblego> FWIW, the first ~5 years of teaching FP, I would use this false thing, on the belief it was helpful. It's not though. It's a complete lie.
04:11:49 <Gurkenglas> How do I find out why the movement of my rectangle is rolled back? Would debugging help? How do I turn "stack dragger.hs" into something that lets me go through the lines of the do notation step by step?
04:11:57 <ertesx> maerwald: FWIW, i agree with you – in general
04:12:03 <ertesx> whoops
04:12:07 <ertesx> dibblego: that was for you
04:12:43 <Gurkenglas> How is thinking of (a -> (b -> c)) as a multi-argument function wrong?
04:12:46 <dibblego> all of you come to the next NICTA/course, we will split out, you can tell them lies, we will rejoin and then see who is ahead.
04:12:57 <Gurkenglas> It's like thinking of Cofree Identity as Stream
04:13:02 <dibblego> I guarantee you I will be *way way way* ahead of you
04:13:30 <dibblego> Gurkenglas: Cofree Identity is isomorphic to stream, it is a specific relationship. It is not equality.
04:13:30 <Gurkenglas> For control, afterwards you tell them lies and he must be honest
04:13:57 <dibblego> Well yes, we'd also need to put it to an ethics committee, because now all those students who were lied to are severely disadvantaged
04:14:06 <maerwald> If you teach things correctly, you often have a huge rat-tail you have to explain up-front and that's something that can be more painful, to some even discouraging (again: the relevance problem). But I get why it can also be more fruitful.
04:14:26 <sbrg> dibblego: you are simply wrong. all my students passed with flying colors despite my "wrong" models :)
04:14:29 <dibblego> for example, I'd have to have this conversation with them, about how that lie was never helpful to begin with.
04:14:42 <dibblego> sbrg: fine, I will test them and watch them fail
04:14:47 <maerwald> haha
04:14:49 <sbrg> lol
04:14:50 <tdammers> no you won't
04:15:01 <dibblego> OK, so this mystery individual exists
04:15:02 <sbrg> they most likely will, though. few come out the other side very interested in using haskell
04:15:17 <sbrg> so barely any have since
04:15:24 <dibblego> you likely mean university students; I don't teach at university anymore. In fact, I don't call it teaching.
04:15:34 <sbrg> I do
04:15:43 <dibblego> I will give your students a very trivial practical problem, and if they believe this lie, they will fail 100% of the time. 
04:15:59 <maerwald> now you are making me curious
04:16:01 <locallycompact> can I have this trivial practical problem
04:16:05 <ertesx> which lie?  about function arity?
04:16:05 <dibblego> to be clear, the lie is not, "functions take not-one argument"
04:16:05 <locallycompact> I want to try
04:16:06 <sbrg> uh, so you expect me to hand out the information for some of my students? lol
04:16:18 <dibblego> the lie is, "believing functions take not-one argument is a helpful thing to believe"
04:16:32 <maerwald> I also want to see the exercise
04:16:33 <ertesx> dibblego: i'd be interested in that problem
04:16:56 <dibblego> sbrg: No, I am telling you what has happened, in my experience and that of my trusted colleagues, 100% of the time, in the 15 years I have been teaching FP. There have been zero counter-examples to this claim.
04:17:15 <dibblego> the exercise is NICTA/course, along with how it is conducted
04:17:19 <locallycompact> what's the exercise
04:17:25 <maerwald> lol, really?
04:17:32 <maerwald> you are referencing a whole course now?
04:17:32 <dibblego> Yes, I wrote it, for exactly this reason.
04:17:33 <LKoen> "you likely mean university students; I don't teach at university anymore. In fact, I don't call it teaching." <<< that is very very sad, my condolences
04:17:42 <maerwald> that's honestly a poor example
04:17:52 <tdammers> the whole NICTA course is not a "trivial practical problem"
04:17:57 <maerwald> yeah
04:17:59 <dibblego> tdammers: Well yes, it is.
04:18:03 <dibblego> but that's not the point
04:18:06 <dibblego> they'll fail early
04:18:12 <dibblego> on day two
04:18:14 <tdammers> yes
04:18:19 <dibblego> 100% of people who believe this lie will have failed
04:18:21 <tdammers> and then they'll learn from their failure
04:18:30 <dibblego> their peers will be far far ahead 
04:18:34 <maerwald> dibblego: we want a proper concrecte example, not vague pointers to courses
04:18:34 <sbrg> dibblego: you wrote the NICTA course?
04:18:35 <locallycompact> is there a specific problem on day 2 you can use as an example
04:18:41 <dibblego> sbrg: Yes.
04:19:02 <ertesx> dibblego: in my next haskell workshop i'll see if i can verify this
04:19:09 <ertesx> sounds very interesting
04:19:21 <dibblego> I gave a trivial example earlier. I do not contend that 100% of people will fail it, but as I said, of increasing difficulty, but still extremely trivial, 100% of people will be failed.
04:19:23 <sbrg> I quote the nicta course, and I would like to remind you that tdammers provided an almost identical example in terms of word usage: move: takes a tic-tac-toe board and position and moves to that position (if not occupied) returning a new board. This function can only be called on a board that is empty or in-play. Calling move on a game board that is finished is a compile-time type error.
04:19:24 <maerwald> an example that can make people who have learned concepts by believing fallacies fail
04:19:33 <sbrg> "takes a tic-tac-toe board and position"
04:19:44 <maerwald> dibblego: I don't recall that example
04:19:51 <sbrg> shouldn't this be "takes a tic-tac-toe board and returns a new function which takes ap osition" according to your claims?
04:19:57 <dibblego> sbrg: No. Read carefully.
04:20:14 <dibblego> <dibblego> type constructors are functions, and all functions take one argument, and if you don't believe that, you're going to really struggle when you see instance Monad ((->) t), which happens on day one
04:20:46 <dibblego> I defend this position, by the way, because I think it is extremely insulting to students.
04:20:57 <dibblego> "You need to believe this bullshit to get by." No you don't
04:21:09 <sbrg> dibblego: I have read it carefully many times. IMO, there is 0 difference between the wording used for `intersperse` and the wording used there, and you were very much against the wording used for `intersperse`
04:21:38 <maerwald> sbrg: it's about teaching here, not about using loose language in documentation
04:21:45 <sbrg> before it was
04:21:49 <maerwald> no
04:22:01 <dibblego> sbrg: the tic-tac-toe example does not pertain to haskell. Also, like I have said, loose wording is fine, for as long as it is understood to be inaccurate. The claims that have been made do not pertain to wording, but "how it is to be thought of"
04:22:11 <freeside_> Type constructors need to take all their arguments at once, when the type constructor in question is a type synonym.
04:22:12 <dibblego> what maerwald said, thank you
04:22:25 <Gurkenglas> So the example on day 2 that they'll fail concerns ((->) a). Can you be more specific? If it's too long to repaste, can you link to the ircbrowse of that or say the time at which you said it?
04:22:33 <tdammers> there's a difference between "functions can take many arguments, that's a fact", and "functions always take exactly one argument, but under certain circumstances, we can, for the sake of using simpler language, pretend they take more than one"
04:22:43 <ertesx> loose wording is fine, as long as it's correct and follows conventional terminology
04:22:54 <ertesx> (>>) :: IO a -> IO b -> IO b  -- good loose wording
04:23:16 <dibblego> and there is a difference again to, "functions take not-one argument and believing this will help you", which is false
04:23:19 <ertesx> "loose" doesn't mean "wrong"
04:23:47 <ertesx> i tend to insist that functions take exactly one argument on day one
04:23:57 <sbrg> dibblego: I think I see your point more clearly. I was at no point suggesting that one literally teach students that functions take more than one argument. but talking about them as if they do and using the loose wording is fine with me.
04:23:57 <dibblego> ertesx: and your students thank you for it
04:23:59 <ertesx> on day two i *define* a "binary" function
04:23:59 <sbrg> so I guess we mostly agree
04:24:08 <tdammers> I think I never argued that *believing* it helped you; I argued that *using the incorrect model until you can wrap your head around a better one* helped me
04:24:10 <ertesx> "a binary function is a function that returns a function"
04:24:29 <dibblego> sbrg: talking about them as if they do, is itself, a topic that requires students to first demonstrate a commitment to that which is true by practical exercise.
04:24:42 <dibblego> tdammers: that is what I mean by "believe"
04:24:54 <ertesx> i think this is a way to have loose language without ever introducing *incorrect* language
04:25:13 <ertesx> (+) by my definition is a binary function, and 'id' may be depending on instantiation
04:25:22 <dibblego> ertesx: that's exactly how to approach the matter without putting students behind
04:26:26 <freeside_> Pour some sugar on me!
04:26:35 * koz_ pours sugar on freeside_ .
04:26:46 <koz_> I don't know why you'd want sugar on you though.
04:26:53 <Gurkenglas> So id isn't a function but a class of functions, because whether it returns a function isn't well-defined, and functions must be monomorphic?
04:27:26 <dibblego> wat
04:27:49 <merijn> The more beginners someone is, the more pedantic I get :)
04:28:01 <dibblego> merijn %~ (+1)
04:28:02 <Gurkenglas> If functions are binary or not, then id is binary or not. Since it isn't, it's not a function
04:28:04 <merijn> Sloppy wording is convenient for people who are not hopelessly confused
04:28:09 <freeside_> I love pedants! You had me at "actually".
04:28:12 <dibblego> merijn %~ (*10)
04:28:16 <Gurkenglas> Or is binaryness a property of monomoprhic functions?
04:28:26 <ertesx> loose terminology is an *expert's* tool
04:28:37 <maerwald> haha
04:28:38 <merijn> People who are properly confused benefit from pedantic and exact explanations, not handwavy nonsense that confuses them more
04:28:52 <maerwald> merijn: IO takes the world as an argument :P
04:29:01 <merijn> maerwald: Don't make me come over there!
04:29:02 <maerwald> couldn't resist
04:29:45 <ertesx> to master haskell thou must gain the Privilege Of The Not Sense
04:29:55 <dibblego> is it argued that that falsehood is helpful too? I thought we defeated that one
04:30:08 <mniip> merijn, functors are just containers!
04:30:38 <Gurkenglas> Now why does 59 -> 61 show no movement in rectangles, 94 -> 97 does show movement in rectangles, and removing the trace in 56 silence 94 -> 97?
04:30:41 <Gurkenglas> http://lpaste.net/172469
04:30:46 <merijn> dibblego: Well, lying is helpful sometimes :p
04:31:20 <maerwald> merijn: I agree, but it must be explicit lying, which people know about, not implicit lying by loose terminology
04:31:25 <ertesx> can i eat now?
04:31:28 <dibblego> merijn: I agree, just not these particular lies [which are extremely damaging]
04:31:33 <koz_> ertesx: What was stopping you before?
04:31:55 <merijn> dibblego: I'm not sure which lies we were talking about before :)
04:32:06 <maerwald> too late to the party, the flame is already over :P
04:32:27 <ertesx> koz_: the War Of The Schoolmen that i had to watch =)
04:32:29 <tdammers> so I'm damaged, apparently
04:33:19 <dibblego> my teenage son does that
04:33:30 <tdammers> especially since the teacher who lied to me was no one other than myself
04:33:50 <maerwald> dibblego: I guess I know what you would say to "arrays are just pointers in C" :P
04:34:21 <ertesx> arrays are just hash tables
04:34:21 <merijn> maerwald: No, that just summons mauke in here
04:34:26 <dibblego> maerwald: I would say it less confidently, because in that case, I have not tested it zillions of times, nor have my colleagues.
04:34:27 <maerwald> hehe
04:34:34 <tdammers> in other news, a lie that *did* damage me, big time, was "C strings"
04:35:00 <ertesx> a lie that had damaged me was "characters are just bytes"
04:35:16 <ljc> tdammers: what was the lie?
04:35:23 <tdammers> ljc: that there is such a thing
04:35:27 <merijn> War is peace, freedom is slavery, bytes is string!
04:35:31 <ertesx> ljc: that's the lie
04:35:35 <ertesx> ljc: "C strings"
04:35:41 <tdammers> ljc: or rather, that the thing that C programmers call a string is in fact a string
04:35:43 <maerwald> merijn: amusingly, in C you can barely explain anything without quoting the standard. I feel that's not so bad in haskell.
04:36:08 <ertesx> > 2["abc"]
04:36:09 <lambdabot>      No instance for (Show a0)
04:36:09 <lambdabot>        arising from a use of ‘show_M234227748479629188530247’
04:36:09 <lambdabot>      The type variable ‘a0’ is ambiguous
04:36:11 <ertesx> aw
04:36:18 <Gurkenglas> quoth the standard nevermore
04:36:37 <ertesx> i love how C got all the things right in the wrong places
04:36:44 <merijn> ertesx: Oh, you mean: https://gist.github.com/merijn/0392ae239b9a091986ae
04:36:45 <hpc> maerwald: to some extent, it comes down to the haskell standard being closer to an explanation you can actually give people
04:36:46 <ertesx> the associativity of "plus" aka []
04:36:47 <tdammers> I believe you could actually make that compile in Haskell
04:36:54 <hpc> i find myself quoting the standard without even noticing
04:37:04 <merijn> Popquiz: What's that print and is it standard defined, implementation defined or undefined behaviour? :)
04:37:05 <hpc> but yeah
04:37:06 <ertesx> merijn: lovely =)
04:37:47 <tdammers> well, C is one of those languages that sort of happened by accident
04:37:50 <Gurkenglas> tdammers, by giving ([a] -> a) a Num instance? How'd you add?
04:38:05 <maerwald> language war incoming
04:38:09 * maerwald ducks
04:38:13 <ertesx> > fromEnum 'D'
04:38:14 <lambdabot>  68
04:38:24 <ertesx> merijn: i'd assume that it prints 69 =)
04:38:30 <implementation> (+) = const
04:38:38 <tdammers> considering how another one of the languages that just sort of happened by accident turned out (PHP), I think we actually got lucky with C
04:38:51 <merijn> ertesx: Standard defined, implementation defined, or undefined behaviour?
04:38:56 <Gurkenglas> implementation, but commutativity
04:38:58 <tdammers> Gurkenglas: make an unlawful instance?
04:39:13 <tdammers> unlawful instances are bad, but they do compile
04:39:33 <ertesx> merijn: implementation-defined, because of sizeof(0), but i'm really guessing based on my experience that 'int' has different sizes depending on implementation
04:39:57 <merijn> ertesx: *bzzt* you answer is wrong in both aspects, result and definedness :p
04:40:06 <ertesx> merijn: wait
04:40:31 <ertesx> merijn: nevermind, i give up…  what is it?
04:40:39 <sbrg> 42
04:40:42 <sbrg> it must be
04:40:56 <sbrg> how is that even valid code?
04:40:59 <merijn> ertesx: Pro-tip: sizeof is an operator :)
04:41:27 <Saizan> is there any haskell editor that can show you all the occurences of a variable in a given scope?
04:41:29 <merijn> sbrg: 'x[i]' is defined to be identical to '*(x+i)'
04:41:37 <sbrg> aye
04:41:43 <sbrg> oh, duh
04:41:51 <merijn> sbrg: So why wouldn't it be? :)
04:41:55 <sbrg> I get it
04:42:04 <sbrg> it's the same as "ABCD.."[sizeof(0)]
04:42:05 <sbrg> right?
04:42:13 <merijn> sbrg: *bzzzt* wrong :)
04:42:15 <sbrg> huh
04:42:18 <joehh> I have many many floats to parse and am using read at the moment
04:42:20 <sbrg> i can see that, ideone prints 1
04:42:31 <merijn> sbrg: See my earlier pro-tip that sizeof is an operator :)
04:42:36 <ertesx> merijn: it's the size of a char
04:42:37 <tdammers> Gurkenglas: you could actually just go instance Num (a -> a) where { fromIntegral = const id }, provide nonsense implementations or bottom for the other methods, and 2["abc"] would work already
04:42:39 <tdammers> fsvo work
04:42:41 <Gurkenglas> Saizain, some dump setting in ghc probably annotates each variable with its scope
04:42:47 <merijn> ertesx: *ding**ding*
04:42:50 <ljc> and so x[i] == i[x] :)
04:43:01 <ertesx> merijn: but i have no idea whether it's standard-defined
04:43:05 <joehh> I could write a parser, but is there a standard fast String/ByteString/Text -> Double function
04:43:05 <sbrg> oh god
04:43:08 <sbrg> yes
04:43:08 <joehh> ?
04:43:09 <merijn> ertesx: It is :)
04:43:14 <sbrg> its sizeof ("ABCD.."[0]), isn't it?
04:43:24 <ertesx> merijn: is char actually defined to be an octet?
04:43:46 <merijn> sbrg: Yes, because sizeof is a unary operator and [] (and other suffix operators have higher precedence than prefix)
04:43:49 <merijn> ertesx: No
04:43:52 <tdammers> ertesx: merijn: I'm running with the assumption that it's not
04:43:56 <Gurkenglas> joehh: What's wrong with read?
04:43:57 <merijn> ertesx: In fact, char is expressly NOT an octet
04:43:58 <sbrg> merijn: I see what you mean, yeah, `sizeof 0[...]` would've been much clearer
04:44:10 <merijn> ertesx: char is "the smallest addressable unit"
04:44:13 <sbrg> since I knew about the whole "i[x] == x[i]" thing
04:44:17 <ertesx> ah
04:44:23 <merijn> ertesx: And sizeof returns sizes in char, not bytes
04:44:25 <tdammers> I thought the standard also demanded *at least* 8 bits
04:44:25 <ertesx> is that funny or sad?
04:44:34 <sbrg> merijn: thanks! I will use this knowledge to appear superior to my friends.
04:44:34 <merijn> ertesx: So by definition sizeof char must be one :)
04:44:41 <joehh> most of my codes time is spent in it and I suspect there may be something faster
04:44:50 <sbrg> tdammers: I believe so. 
04:44:52 <sbrg> IIRC
04:44:56 <merijn> ertesx: Colleagues of min have worked on architectures where char is 32bits
04:45:02 <tdammers> but that, for example, having long, int, short, and char all as 32 bit integers, would constitute a valid C implementation
04:45:15 <merijn> tdammers: This is correct
04:45:34 <Gurkenglas> https://www.google.de/?client=firefox-b-ab#q=bytestring+read&gfe_rd=cr joehh third one sounds good
04:45:47 <merijn> tdammers: I think it actually only demands 7 bits minimum
04:45:49 <freeside_> For those just tuning in, #haskell has temporarily become #C, just as the DNC2016 temporarily became RNC2008
04:45:51 <ertesx> merijn: C is often praised for its portability, but as far as i see that goes only as far as: "there is a compiler for everything"
04:46:21 <tdammers> merijn: I thought 8, but with some weirdness around the question whether it should be signed or not
04:46:22 <maerwald> merijn: char is still heavily abused for being uint8_t
04:46:30 <ertesx> merijn: #ifdef writing WRAPPER(actually) portable #else code is #endif terrible
04:46:35 <merijn> freeside_: Sometimes you need to release frustration of working with C :)
04:46:45 <joehh> I'm using parsec to grab the digits (many1 (oneOf "+-0123456789.e")) then calling read
04:46:51 <joehh> on the result
04:46:51 <merijn> maerwald: That's wrong, signedness of char is implementation defined
04:46:59 <joehh> I'll give that a go - thanks Gurkenglas 
04:47:00 <maerwald> merijn: yes, that's what I meant
04:47:14 <maerwald> people use char that way
04:47:16 <maerwald> still
04:47:17 <merijn> joehh: You're making me sad :(
04:47:33 <merijn> joehh: There should be existing parsers for numbers already somewhere
04:47:47 <ertesx> joehh: see the Data.Text.Read module
04:48:12 <ertesx> joehh: it comes with the 'text' package
04:48:23 <joehh> that is exactly my feeling as well
04:48:25 <maerwald> merijn: even my C prof back then did it
04:48:29 * hackagebot compound-types 0.1 - Sum and Product types and such  https://hackage.haskell.org/package/compound-types-0.1 (NikitaVolkov)
04:48:59 <maerwald> we were coding our own memory management and were supposed to cast to char and stuff
04:50:04 <merijn> maerwald: Similarly, casting function pointers to void* is not portable or allowed by the C spec :)
04:50:21 <merijn> (Although posix requires it to be valid)
04:50:44 <hpc> so posix directly contradicts the c spec
04:50:45 <hpc> :D
04:51:12 <merijn> hpc: Well, the C spec merely specifies it's undefined behaviour
04:51:13 <ertesx> *restricts* it
04:51:33 <merijn> hpc: posix says it must be allowed, which is a subset of all possible undefined behaviour :)
04:51:37 <hpc> merijn: ah, you said "not portable or allowed", which i read as "it's defined that you can't do it"
04:53:36 <merijn> hpc: By not portable I mean "you program is not required to behave the same (i.e. work at all) on different platforms"
04:54:04 <hpc> yeah, it was "or allowed" that got me
04:56:13 <ertesx> (*) :: Proxy b -> Ptr a -> Ptr b
04:56:20 <ertesx> char :: Proxy Word8
04:56:27 <ertesx> (char *) ptr
04:57:04 <merijn> ertesx: You're killing me...
04:57:09 <hpc> i wonder if it's possible without type classes to make it so (char *) ptr and char (* ptr) mean the same thing
04:57:11 <Gurkenglas> How do I go about making http://lpaste.net/150858 available to anyone who does "stack pointedalternative" and "import Control.Alternative.Pointed"?
04:57:49 <tdammers> hpc: at that point, I'd resort to TH and quasiquotation
04:58:16 <tdammers> [C99|char (*ptr)|] -- implementation of C99 left as an exercise for the reader
04:58:29 <ertesx> merijn: instance IsString (Ptr Word8)
04:58:30 * hackagebot compound-types 0.1.0.1 - Sum and Product types and such  https://hackage.haskell.org/package/compound-types-0.1.0.1 (NikitaVolkov)
04:58:57 <slack-haskell> <rizy> a
04:59:38 <ertesx> merijn: fromString = unsafePerformIO … malloc …  {-# NOINLINE … #-}
05:00:05 <ertesx> merijn: instance (Storable a) => Fractional (Ptr a) …
05:00:08 <tdammers> speaking of lies... "Haskell is pure"... :x
05:00:20 * tdammers runs away
05:02:07 <Gurkenglas> Why does 59 -> 61 show no movement in rectangles, 94 -> 97 does show movement in rectangles, and removing the trace in 56 silence 94 -> 97? http://lpaste.net/172469
05:04:28 <ertesx> merijn:
05:04:30 <ertesx> :t \p -> ContT $ \k -> let l x = ContT (\_ -> k x) in Foreign.Storable.poke p l >> k 0
05:04:32 <lambdabot> (Num a, Foreign.Storable.Storable (a -> ContT r IO a1)) => GHC.Ptr.Ptr (a -> ContT r IO a1) -> ContT r IO a
05:04:48 <ertesx> @let setjmp p = ContT $ \k -> let l x = ContT (\_ -> k x) in Foreign.Storable.poke p l >> k 0
05:04:49 <lambdabot>  .L.hs:215:41: Not in scope: ‘Foreign.Storable.poke’
05:04:50 <merijn> ertesx: Pretty sure I can have you arrested under the geneva convention...
05:05:33 <ertesx> WHY IS THAT GOOD IN C AND BAD IN HASKELL?!
05:05:35 * ertesx is sad =/
05:07:36 <mniip> ertesx, and longjmp is?
05:07:43 <ertesx> mniip: 
05:07:45 <ertesx> :t let longjmp p x = liftIO (Foreign.Storable.peek p) >>= ($ x) in longjmp
05:07:46 <lambdabot> (MonadIO m, Foreign.Storable.Storable (a -> m b)) => GHC.Ptr.Ptr (a -> m b) -> a -> m b
05:08:09 <maerwald> tdammers: well, the language report doesn't have a notion of "execution", so it is
05:08:31 <ertesx> mniip: actually you need to wrap all of those in FunPtrs
05:08:41 <ertesx> and that i can't do with lambdabot =)
05:09:37 <ertesx> @let foreign import ccall "wrapper" mkJmpBuf :: (a -> ContT r m b) -> IO (a -> ContT r m b)
05:09:38 <lambdabot>  .L.hs:207:1:
05:09:38 <lambdabot>      Unacceptable argument type in foreign declaration:
05:09:38 <lambdabot>        ‘a’ is not a data type
05:09:56 <ertesx> huh?
05:10:23 <ertesx> ah, ok, doesn't work due to safe haskell =)
05:11:21 <ertesx> mniip: if you dispense with the Ptr and use an IORef instead, it works pretty much out of the box
05:11:37 <ertesx> but IORef is so haskell…
05:13:30 * hackagebot impure-containers 0.2 - Mutable containers in haskell  https://hackage.haskell.org/package/impure-containers-0.2 (andrewthad)
05:13:32 * hackagebot compound-types 0.1.1 - Sum and Product types and such  https://hackage.haskell.org/package/compound-types-0.1.1 (NikitaVolkov)
05:16:45 <bizarrefish> Hi all
05:17:57 <bizarrefish> I've been reading about ad-hoc polymorphism vs parametric polymorphism, and trying to figure out where the smalltalk/java/C++ model of single-dispatch fits in to that framework.
05:18:30 * hackagebot compound-types 0.1.1.1 - Sum and Product types and such  https://hackage.haskell.org/package/compound-types-0.1.1.1 (NikitaVolkov)
05:18:59 <bizarrefish> I know that generics give java parametric polymorphism, but I have also heard of structural subtyping(as in go) described as ad-hoc polymorphism.
05:22:16 <ertesx> bizarrefish: parametric polymorphism and ad-hoc polymorphism are best kept separate…  they are rather unrelated
05:22:56 <liste> bizarrefish: method overloading give Java some ad-hoc polymorphism
05:23:22 <ertesx> parametric polymorphism is quantification over types, approximated by "generics" in java and "templates" in C++
05:23:32 <ertesx> :t id
05:23:33 <lambdabot> a -> a
05:24:16 <cromachina> :t sort
05:24:18 <lambdabot> Ord a => [a] -> [a]
05:24:37 <bizarrefish> So where does single-dispatch/message-passing fit into this?
05:25:10 <bizarrefish> Is it best thought of some other variety of the thing that method overloading is?
05:25:49 <ertesx> bizarrefish: in OO languages which function is called is often type-bound, and at the same time, the type is not statically determined
05:26:08 <ertesx> bizarrefish: so dispatch is really an OO programming pattern more than a language feature
05:26:53 <bizarrefish> Right; so it doesn't really fit into this whole thing
05:26:56 <liste> no
05:26:58 <bizarrefish> I can accept that :)
05:27:05 <ertesx> bizarrefish: when translating this to haskell, think of the semantics of a class hierarchy represented as a single haskell type, and the individual classes represented as values of that type
05:27:13 <bizarrefish> Thinking of an example...
05:27:16 <ertesx> you could consider this a form of dynamic typing
05:27:29 <asdasda> hi, I have a list of type, and I want to construct the sum type from it. I can do so by a type family fold, but I am sure it's already written somewhere already. do you know any library with such operators ?
05:28:24 <ertesx> bizarrefish: the important thing to realise here is that there are two notions of "type":  one is "an implementation of a certain semantics (e.g. a 'sub-class')", the other is "an object in the type language"
05:28:33 <ertesx> bizarrefish: surprisingly these two are almost completely unrelated
05:28:46 <cromachina> bizarrefish, how about anything that uses a type class?
05:29:29 <ertesx> asdasda: the HList library may have that, but i'm not sure
05:29:40 <ertesx> asdasda: if not, check out the singletons library
05:30:01 <bizarrefish> Say I have a set of objects; squares, circles, triangles, and I want to have them both drawable and clickable, so these behaviours need to be implemented for each. In OO land, I would tend to have a heterogenous set of differently-typed objects with different implementations for draw() and hitbox(), or whatever.
05:30:29 <bizarrefish> In Haskell, would I keep separate sets for triangles, circles, squares, ...?
05:30:54 <ertesx> bizarrefish: more likely you would have a type Shape, and values 'square :: Shape', 'circle :: Shape', etc.
05:31:17 <ertesx> bizarrefish: types in haskell and classes in OO languages do not really overlap that much
05:31:21 <asdasda> @ertesx thank you. HList does have it...
05:31:21 <lambdabot> Unknown command, try @list
05:31:22 <cromachina> or make them different constructors of the same data type
05:31:36 <cromachina> data Shape = Circle | Square | Triangle
05:32:23 <bizarrefish> Damn, breaking away from this kind of thinking is hard
05:32:30 <ertesx> that's one way, but i think extensibility is of concern here
05:32:31 <bizarrefish> I feel brainwashed
05:33:01 <ertesx> a Shape is a semantics for shapes…  a type that captures the *essence* of what a shape is
05:33:20 <ertesx> for you it may be defined in terms of what it looks like, or in terms of what happens when you draw it
05:33:35 <ertesx> data Shape = Shape { _drawShape :: IO (), … }
05:34:03 <ertesx> now the notion of circles is *not* a type, but a *value* of type Shape
05:34:32 <ertesx> and what you know has "constructor" in OO would just be a function or perhaps an action in haskell
05:34:42 <ertesx> circle :: Double -> Shape
05:34:49 <ertesx> randomCircle :: IO Shape
05:35:00 <ertesx> bizarrefish: does that make sense?
05:35:01 <Gurkenglas> I'm currently trying to minimize my code, cutting out features, until the program goes away. Instead, my trace just went away. http://lpaste.net/172476 traces each second on all lines that contain the string trace. http://lpaste.net/172477 does not trace on lines 61 and 63. All I changed was turning the StateT S Maybe () into a State S (), because I had already cut out all guards.
05:35:15 <Gurkenglas> *until the problem goes away. Or the program is gone, I guess.
05:38:09 <bizarrefish> ertesx: I think so. The basic difference here is that in OO, we'd typically define those as operations against the 'type', whereas here, we define a new type of value which includes closures for those operations.
05:38:29 <ertesx> bizarrefish: you have the option to give meaning to "type of shape" in order to perform what is basically dynamic typing, in which case cromachina's enumeration type may become handy:  data Shape = Shape { …, _shapeType :: ShapeType, … }
05:38:31 * hackagebot hpqtypes-extras 1.2.4 - Extra utilities for hpqtypes library  https://hackage.haskell.org/package/hpqtypes-extras-1.2.4 (jonathanjouty_scrive)
05:38:45 <ertesx> bizarrefish: but before you do that, ask yourself whether you need it…  most likely you don't
05:39:13 <bizarrefish> ertesx: If that was the case, what would I do instead?
05:41:01 <cromachina> a type class may get you close to what you want
05:41:02 <ertesx> bizarrefish: it's domain-specific and best discussed with a certain application in mind
05:41:36 <bizarrefish> Righto; just trying to get a feel for the options here.
05:42:08 <ertesx> bizarrefish: it all boils down to: understand the essence of the objects you handle, and capture that in a type
05:42:23 <bizarrefish> I guess you could even do something crazy like:  Shape a :: ShapeParams a -> ShapeOperations
05:42:27 <ertesx> bizarrefish: i'll refer to my hangman example again
05:42:50 <Guest74698> hi guys
05:42:52 <ertesx> bizarrefish: you know the game of hangman?  let's simplify it to a simple letter-guessing game with no option to lose
05:43:01 <cromachina> class Shape a where; draw a -> IO (); click a -> IO ()
05:43:19 <ertesx> cromachina: that's not a good idea
05:43:33 <merijn> IN fact, it's a pretty bad idea
05:43:36 <bizarrefish> ertesx: Because it would require rank-2-types?
05:44:00 <bizarrefish> (in order to define a parametrically polymorphic function over Shape)
05:44:08 <ertesx> bizarrefish: because type classes have nothing to do with OO and dispatch
05:44:26 <ertesx> and you don't need them here
05:44:35 <ertesx> (in fact you don't *want* them here)
05:44:45 <bizarrefish> You can't 'dispatch' in normal haskell, I thought. At least, not in that sense.
05:45:10 <ertesx> well…  you can…  it's just that the way you encode it is very different =)
05:45:28 <bizarrefish> You can't write a function :: Shape -> Shape , if Shape is a typeclass
05:45:37 <bizarrefish> right?
05:45:53 <ertesx> you can write:  function :: (Shape a) => a -> a
05:45:57 <asdasda> you don't want them here because you dont need them here ?
05:46:01 <ertesx> but still, it's not what you'd want
05:46:17 <ertesx> you don't want them here, because they buy you nothing, but increase complexity
05:46:27 <asdasda> yes
05:46:28 <bizarrefish> I mean a function which does something shapeish with a shape and returns another shape
05:46:42 <cloudhead> what's the best way to deal with newtype wrappers when one wants functor-like behaviour, but the newtype has no type variables?
05:47:02 <bizarrefish> So, not the identity function, or any bounded version of it.
05:47:13 <cloudhead> at the moment I have a `mapFoo` which behaves like fmap for that type, but seems redundant
05:47:18 <ertesx> bizarrefish: type classes are useful, if you have *at least* two instances and *at least* one useful function that does not refer to any particular instance and lives outside the class
05:47:39 <ertesx> cloudhead: force it to have a type variable =)
05:47:43 <bizarrefish> ertesx: That...makes sense as a rule
05:48:05 <bizarrefish> List is a nice example of that
05:48:05 <cloudhead> ertesx: but then my newtype is kind of meaningless no? `newtype Foo a = Foo a`
05:48:12 <bizarrefish> Or rather, Traversable
05:48:40 <ertesx> cloudhead: force the underlying type to have a type variable
05:48:40 <cloudhead> ertesx: then I need a type alias for the actual thing: `type Foo' = Foo Int`
05:49:11 <cloudhead> hmm but that doesn't make the newtype functor-like then
05:49:12 <ertesx> cloudhead: more seriously: you can use GeneralizedNewtypeDeriving to avoid a lot of boilerplate
05:49:30 <cloudhead> essentially I want to be operating on the type inside the newtype
05:49:30 <ertesx> cloudhead: if all else fails you can use iso lenses
05:49:44 <cloudhead> so with `newtype Foo = Foo [Int]` I want to use list functions on Foo
05:50:21 <Eduard_Munteanu> Not possible.
05:50:21 <ertesx> cloudhead: newtype Foo a = Foo { fromFoo :: [a] }  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
05:50:33 <ertesx> cloudhead: gives you most list functions for free
05:50:44 <cloudhead> right, but then if I do `map (+1) (Foo [1,2])`
05:50:53 <cloudhead> will that work?
05:50:56 <ertesx> use fmap instead
05:51:00 <Eduard_Munteanu> No.
05:51:00 <cloudhead> yes, sorry
05:51:05 <cloudhead> I meant fmap
05:51:10 <ertesx> yeah, that will work
05:51:17 <ertesx> @let newtype Foo a = Foo { fromFoo :: [a] }  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
05:51:19 <cloudhead> interesting
05:51:19 <lambdabot>  Defined.
05:51:28 <ertesx> wait
05:51:29 <ertesx> @undef
05:51:29 <lambdabot> Undefined.
05:51:37 <ertesx> ah, no, nevermind
05:51:40 <ertesx> @let newtype Foo a = Foo { fromFoo :: [a] }  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
05:51:42 <lambdabot>  Defined.
05:51:49 <ertesx> > fmap (+ 1) (Foo [1..5])
05:51:51 <lambdabot>  Foo {fromFoo = [2,3,4,5,6]}
05:51:55 <ertesx> > sum (fmap (+ 1) (Foo [1..5]))
05:51:57 <lambdabot>  20
05:52:00 <ertesx> cloudhead: ^
05:52:02 <cloudhead> that's cool
05:52:03 <cloudhead> thanks
05:52:16 <ertesx> when in doubt, beat it to having a type variable =)
05:52:22 <cloudhead> so somehow, both Foo and [a] become functors?
05:52:33 <ertesx> Foo is a functor, and [] is a functor
05:52:54 <cloudhead> but the deriving is doing some magic here it seems
05:53:01 <cloudhead> more than if it was Foo a = Foo a deriving (Functor)
05:53:05 <merijn> cloudhead: GeneralizedNewtypeDeriving
05:53:10 <cloudhead> yeah
05:53:12 <ertesx> yeah, DeriveFunctor can derive Functor for most types that are functors
05:53:16 <Eduard_Munteanu> It just does packing and unpacking the obvious way.
05:53:18 <cloudhead> I'm just trying to understand how it knows 
05:53:20 <merijn> cloudhead: AKA "just pretend the instance is the same without the newtype"
05:53:38 <cloudhead> I see yeah
05:53:40 <merijn> cloudhead: newtype are identical to their contents at runtime
05:53:50 <Eduard_Munteanu> instance Functor Foo where fmap f (Foo xs) = Foo (fmap f xs)
05:53:51 <merijn> cloudhead: So it can literally use the existing code
05:53:56 <ertesx> even if it weren't a newtype, the DeriveFunctor extension works wonderful magic, along with DeriveFoldable and DeriveTraversable
05:54:06 <merijn> cloudhead: The constructor and types of newtypes only exist at type-checking
05:54:41 <ertesx> @let data Vec3 a = Vec3 !a !a !a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
05:54:43 <lambdabot>  Defined.
05:54:43 <cloudhead> right, but so there's also no difference between `fmap f (Foo a)` and `fmap f (Foo [a])`
05:54:53 <ertesx> > fmap (^2) (Vec3 1 2 3)
05:54:55 <lambdabot>  Vec3 1 4 9
05:55:16 <Gurkenglas> On the other hand, this one http://lpaste.net/172479 works just as intended: The rectangles move even according to line 52 and across multiple seconds
05:56:00 <cloudhead> right, I think I'm getting confused because fmap (Foo a) == fmap (Foo [a]) since [a] is also functor
05:56:13 <cloudhead> so it propagates the fmap down
05:56:17 <cloudhead> which is what I want
05:56:23 <ertesx> cloudhead: a functor is a *type*
05:56:30 <ertesx> cloudhead: specifically a type of kind * -> *
05:56:35 <ertesx> so [] and Foo can be functors
05:57:03 <ertesx> (in haskell anyway)
05:57:05 <cloudhead> yeah, but `Foo [a]` is essentially a functor with a functor inside of it
05:57:16 <ertesx> Foo is a functor
05:57:18 <cloudhead> (once we derive functor on Foo)
05:57:21 <Eduard_Munteanu> Does anyone know when/if Haskell will be a supported target for proto3/grpc (the new Protocol Buffers stuff)??
05:57:25 <ertesx> and its definition of 'fmap' is based on fmap for lists
05:57:56 <ertesx> cloudhead: since this is a newtype, the deriver just reuses the definition of 'fmap' for the underlying type
05:58:08 <ertesx> cloudhead: example:  newtype Bar = Bar { fromBar :: Maybe a }
05:58:08 <cloudhead> I see
05:58:16 <ertesx> here it reuses 'fmap' for Maybe
05:58:23 <cloudhead> and if the underlying type is not a functor
05:58:38 <ertesx> then you can't derive in the first place
05:58:48 <cloudhead> really?
05:58:49 <cloudhead> but
05:59:04 <cloudhead> shouldn't `Foo a = Foo a` work as a functor?
05:59:04 <ertesx> @let newtype Impossible a = Impossible (a -> ())  deriving (Functor)
05:59:05 <lambdabot>  .L.hs:162:31:
05:59:05 <lambdabot>      Can't make a derived instance of ‘Functor Impossible’:
05:59:05 <lambdabot>        Constructor ‘Impossible’ must not use the type variable in a function ...
05:59:34 <cloudhead> @let newtype Foo a = Foo a deriving (Functor)
05:59:35 <lambdabot>  .L.hs:161:1:
05:59:35 <lambdabot>      Multiple declarations of ‘Foo’
05:59:35 <lambdabot>      Declared at: .L.hs:155:1
05:59:44 <cloudhead> @let newtype Foo1 a = Foo1 a deriving (Functor)
05:59:44 <lambdabot>  Defined.
05:59:48 <cloudhead> so this works
05:59:55 <Eduard_Munteanu> cloudhead, yes, but there fmap f (Foo a) = Foo (f a)
06:00:07 <cloudhead> > fmap (+1) (Foo1 4)
06:00:09 <lambdabot>      No instance for (Show (Foo1 b0))
06:00:09 <lambdabot>        arising from a use of ‘show_M26291740514964082831595’
06:00:09 <lambdabot>      In the expression:
06:00:15 <ertesx> cloudhead: GHC is pretty smart about figuring out how to map over your type
06:00:33 <ertesx> @let newtype Fancy a = Fancy (a, a, Integer -> a)
06:00:35 <ertesx> whoops
06:00:36 <lambdabot>  Defined.
06:00:37 <Eduard_Munteanu> @let newtype Foo1 a = Foo1 a deriving (Functor, Show)
06:00:38 <lambdabot>  .L.hs:166:1:
06:00:38 <lambdabot>      Multiple declarations of ‘Foo1’
06:00:38 <lambdabot>      Declared at: .L.hs:161:1
06:00:41 <ertesx> @let newtype Fancy a = Fancy (a, a, Integer -> a)  deriving (Functor)
06:00:42 <lambdabot>  .L.hs:166:1:
06:00:42 <lambdabot>      Multiple declarations of ‘Fancy’
06:00:42 <lambdabot>      Declared at: .L.hs:164:1
06:00:47 <ertesx> @let newtype Fancy1 a = Fancy1 (a, a, Integer -> a)  deriving (Functor)
06:00:49 <lambdabot>  Defined.
06:01:11 <cloudhead> @let newtype Foo' a = Foo' a deriving (Functor, Show)
06:01:14 <lambdabot>  Defined.
06:01:15 <ertesx> cloudhead: the deriver looks at the structure of your type to see what the map function has to look like
06:01:19 <cloudhead> > fmap (+1) (Foo' 4)
06:01:20 <lambdabot>  Foo' 5
06:01:29 <cloudhead> right
06:01:35 <ertesx> cloudhead: whenever it can, it reuses fmap from component types
06:01:53 <ertesx> in the case of the list or the Maybe, it just uses fmap of those
06:02:35 <cloudhead> right, so the only case this would be a problem, is if I want the outer type to be a functor, but the function not to be fmapped to the inner type
06:02:45 <ertesx> it understands sums and products and functions and many other things…  there is a limit to what it understands, but you need to use some rather advanced and questionable language features to hit that limit
06:03:11 <ertesx> cloudhead: generally if deriving Functor works, you can assume that it does the right thing
06:03:45 <cloudhead> because my understanding is that when I fmap Foo [a], I get `Foo (fmap f [a])` instead of `Foo (f [a]`
06:04:12 <cloudhead> and those are different behaviours
06:04:45 <cloudhead> if I simply want a function applied to the inner value, but the inner value is a functor, I may not want to fmap that function
06:05:01 <ertesx> the latter is a syntax error, and as soon as you fix it, it's a type error =)
06:05:44 <cloudhead> yes, but I could define an instance of functor that would work
06:05:49 <cloudhead> for the latter
06:05:59 <Eduard_Munteanu> @let newtype Bar a = Bar (a -> Maybe a) deriving (Functor)
06:06:00 <lambdabot>  .L.hs:173:24:
06:06:00 <lambdabot>      Can't make a derived instance of ‘Functor Bar’:
06:06:00 <lambdabot>        Constructor ‘Bar’ must not use the type variable in a function argument
06:06:06 <ertesx> cloudhead: do that and then check the functor laws
06:06:32 <ertesx> cloudhead: your alternative variant will violate them
06:06:37 <cloudhead> I see
06:07:00 <ertesx> here is a possible fmap:  wrongFmap f = const []
06:07:11 <ertesx> but that one violates:  wrongFmap id = id
06:07:37 <cloudhead> but: `instance Functor Foo where fmap f (Foo x) = Foo (f x)`
06:07:42 <cloudhead> doesn't this make sense?
06:07:57 <ertesx> cloudhead: if Foo wraps a single value, it does
06:08:08 <cloudhead> now what if `x` is [a]
06:08:09 <ertesx> and that's exactly the instance GHC derives for you
06:08:14 <ertesx> then no
06:08:19 <cloudhead> it will do (f [a]) instead of (fmap f [a])
06:08:20 <ertesx> it would be a type error
06:08:30 <ertesx> @undef
06:08:30 <lambdabot> Undefined.
06:08:32 <cloudhead> yes but if `f` is `length`
06:08:36 <cloudhead> it won't be a type error?
06:08:42 <cloudhead> oh wait
06:08:44 <cloudhead> yes it will
06:08:45 <cloudhead> :/
06:08:46 <cloudhead> ok
06:08:48 <cloudhead> I get it
06:08:56 <ertesx> cloudhead: what type of map do you want?  do you want to map over the list or the elements of the list?
06:09:12 <cloudhead> I want to map over the list as a whole
06:09:31 <ertesx> then you need Foo of this shape:  newtype Foo a = Foo { fromFoo :: a }
06:09:34 <cloudhead> ie: I want to use functions of type `[a] -> [a]`
06:10:16 <ertesx> fmap :: ([a] -> [b]) -> Foo [a] -> Foo [b]
06:10:30 <cloudhead> right, that's what I was thinking, but this makes Foo very generic
06:10:55 <ertesx> what do you need it for anyway?  perhaps there is a better solution
06:11:36 <cloudhead> I basically want to wrap an IntMap but hide the IntMap
06:11:45 <cloudhead> ie: only expose certain functions
06:13:02 <cloudhead> I guess with the definition of Foo you gave, I would export a type synonym, something like `type Foo' = Foo (IntMap Bar)`
06:13:28 <cloudhead> does that make sense? but probably use the ' for the internal type
06:13:32 * hackagebot camfort 0.804 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-0.804 (DominicOrchard)
06:13:33 <cloudhead> and not export it
06:13:50 <merijn> cloudhead: What's the point of that type alias?
06:13:58 <ggole> Wouldn't a newtype make more sense there?
06:14:17 <cloudhead> well that would mean two newtypes
06:14:34 <cloudhead> merijn: the type alias is because I only want to use this type with IntMap
06:14:53 <merijn> Honestly, by now I don't even understand what you want anymore :)
06:15:21 <maerwald> is there a language similar to haskell (at its core), but with less of a "concept fetish", trying to solve everything with yet another concept?
06:15:32 <cloudhead> ok, so I want to work with a type that has an underlying IntMap
06:15:32 <merijn> maerwald: SML?
06:15:38 <maerwald> sth like general purpose elm without it being annoying :P
06:15:43 <cloudhead> and I don't want to expose the IntMap to the outside
06:15:48 <merijn> maerwald: But that also doesn't have any of the general purpose libraries :p
06:16:19 <cloudhead> so the obvious way is: newtype Foo = Foo (IntMap Bar)
06:16:29 <cloudhead> but that doesn't give me functor goodness
06:16:33 <maerwald> merijn: maybe Ocaml, if you ignore the fact of free IO?
06:16:42 <merijn> maerwald: Also, horrific syntax
06:16:46 <cloudhead> so I do: newtype Foo a = Foo a deriving (Functor)
06:17:13 <merijn> cloudhead: Why can't you get a functor instance with the original Foo?
06:17:13 <cloudhead> but then specialize all my functions on `Foo (IntMap Bar)`
06:17:22 <cloudhead> merijn: because you can't?
06:17:29 <cloudhead> Functor is * -> * and Foo is *
06:18:11 <merijn> cloudhead: oh, right, but then why not "newtype Foo a = Foo (IntMap a)" with "type FooBar = Foo Bar"?
06:18:52 <cloudhead> because really I just want to apply functions on (IntMap Bar)
06:18:55 <merijn> Or just skip the type alias and use "Foo Bar" directly?
06:19:13 <cloudhead> from the outside, I want a simple type, like FooBar
06:19:20 <merijn> cloudhead: I don'
06:19:26 <cloudhead> so that's what I was saying earlier, I'd export a type alias
06:19:34 <merijn> I don't see the point in caring that it's just "IntMap Bar"?
06:19:37 <cloudhead> and use the internal Functor type
06:19:42 <merijn> What's wrong with the more general form?
06:19:59 <cloudhead> more general as in `Foo Bar`?
06:20:14 <cloudhead> well I can't export `Foo Bar`, I'd export `Foo`
06:20:25 <maerwald> merijn: I miss the KISS mentality in the haskell ecosystem a bit. People rather get exicted about "elegance" (overcomplicated, but smart solutions), not by "simplicity". So I'm looking for alternatives.
06:20:27 <cloudhead> yet all my exported functions take a `Foo Bar`
06:20:27 <merijn> Right, so what's the problem?
06:20:36 <cloudhead> that's the prob
06:21:02 <cloudhead> because the module's functionality is based on having an IntMap
06:21:11 <cloudhead> well, an IntMap Bar really
06:21:13 <merijn> I don't see the point in worrying about that type signature
06:21:30 <merijn> cloudhead: Also, if you only plan the functor inside your module, why does Foo need to be a functor at all?
06:21:42 <merijn> "newtype Foo = Foo (IntMap Bar)"
06:21:48 <cloudhead> it doesn't /need/ to be
06:21:50 <cloudhead> that's what I was asking
06:22:03 <merijn> "myFunction (Foo m) = Foo $ fmap f m"
06:22:10 <cloudhead> I mostly want to use it as a functor though
06:22:29 <cloudhead> yeah, that's what I have right now, or `mapFoo f (Foo x) = Foo (f x)`
06:22:33 <cloudhead> and I use that everywhere
06:22:55 <cloudhead> but it seems strange, given how close that looks to a functor
06:23:15 <cloudhead> to not use Functor
06:23:17 <tdammers> http://hackage.haskell.org/package/mono-traversable-1.0.0.1/docs/Data-MonoTraversable.html#t:MonoFunctor
06:23:20 <tdammers> maybe?
06:23:33 <cloudhead> I'm guessing this is a very common pattern too
06:23:41 <cloudhead> like, newtype Email = Email String
06:23:48 <cloudhead> and you want to operate on the String
06:24:09 <tdammers> newtype Email = { unEmail :: String } -- is how it's often written
06:24:35 <tdammers> you get the Email newtype just like with Email = Email String, but you also get the unwrapping function "for free"
06:26:01 <cloudhead> right, so then you would write your functions like: exclamation email = Email (unEmail email ++ "!")
06:26:34 <cloudhead> instead of `exclamation (Email str) = Email (str ++ "!")
06:27:27 <merijn> cloudhead: That last version works with tdammers version too
06:27:52 <merijn> @define newtype Email = Email { unEmail :: String } deriving (Show)
06:27:53 <lambdabot>  Defined.
06:28:00 <cloudhead> still not as nice as `excl email = fmap (++"!") email` though
06:28:10 <merijn> > let exclamation (Email str) = Email (str ++ "!") in exclamation (Email "foo")
06:28:12 <lambdabot>  Email {unEmail = "foo!"}
06:28:49 <freeside> isn't this what lifting is about?
06:29:37 <dramforever> Question: Is there a library for fixed point high(-ish) precision numbers? Specifically for the problem at hand I would need 90 decimal places, 1000 integer part digits, and I would need exp in addition to the usual arithmetics stuff
06:29:41 <cloudhead> yeah, you still have to construct the type manually though
06:31:03 <freeside> dramforever: are you modeling money or something else?
06:31:46 <cloudhead> dramforever: have you looked at the 'Rational' type in base?
06:32:06 <merijn> cloudhead: Rational is not the same as fixed point
06:32:19 <dramforever> no exp
06:32:40 <merijn> dramforever: You can use Data.Fixed plus custom instance of HasResolution, no?
06:32:45 <dramforever> freeside: Well something related to a special algorithm contest -ish problem
06:33:23 <dramforever> To program a calculator, which uses [1000].[90] numbers
06:33:34 <merijn> dramforever: Data.Fixed goes up to 10^12, but seems trivial to extend
06:33:36 <dramforever> merijn: Whoa thanks I'll check it out
06:33:45 <merijn> Since HasResolution is like a 1 line instance
06:34:37 <dramforever> Umm...I need exp
06:34:56 <dramforever> :t exp -- which is in Floating, sadly
06:34:57 <lambdabot> Floating a => a -> a
06:35:29 <merijn> :t realToFrac
06:35:31 <lambdabot> (Fractional b, Real a) => a -> b
06:36:01 <merijn> Convert to Double and back for exp?
06:36:09 <merijn> Else you have to implement fixed point exp anyway
06:36:16 <ertesx> maerwald: you don't need to participate in the concept fetish though, and in fact i often find it better not to
06:36:21 <dramforever> Actually you're right, I can
06:36:22 <merijn> Since there's no existing fixed point exponential
06:36:31 <dramforever> I actually need the logistic sigmoid function
06:36:45 <ertesx> maerwald: haskell won't stop you from just using functions and IO…  some libraries might try to, but haskell in general does not
06:37:23 <dramforever> which... gets really close to 0/1 for larger values
06:37:43 <ertesx> dramforever: if you don't need any excess precision, i'd go through Double
06:39:20 <freeside> for the logistic sigmoid function could you just discard the .[90] part?
06:39:22 <dramforever> I would need the result to be exact to 90 decimal places
06:39:22 * dramforever becomes yet another wtf requirement person
06:39:36 <freeside> from the input, i mean
06:39:52 <dramforever> Not really perhaps
06:40:58 <dramforever> I guess I'll go for implementing that function. There should be good well-known algorithms
06:41:32 <freeside> can you convert your [1000].[90] to [1090].[0]?
06:43:38 <freeside> or cheat with tanh()
06:44:26 <freeside> btw, footnoting the earlier, rather heated discussion about pedagogy, function arity, loose language, and lies: http://www.uky.edu/~mfi223/EDC670OtherReadings_files/ErlwangersBenny.pdf
06:47:11 <dramforever> freekevin: does that make it easier?
06:47:19 <dramforever> :t tanh
06:47:21 <lambdabot> Floating a => a -> a
06:49:30 <freeside> http://www.gutenberg.org/files/127/127.txt
06:51:27 <dramforever> whoa
06:53:34 * hackagebot soap 0.2.3.1 - SOAP client tools  https://hackage.haskell.org/package/soap-0.2.3.1 (AlexanderBondarenko)
06:53:36 * hackagebot shakespeare 2.0.10 - A toolkit for making compile-time interpolated templates  https://hackage.haskell.org/package/shakespeare-2.0.10 (MichaelSnoyman)
06:54:03 <dramforever> I guess I can play around with precision a bit
06:57:27 <Gurkenglas> If it's just a calculator, you wouldn't need good algorithms, right?
06:58:27 <freeside> https://hackage.haskell.org/package/numbers-3000.2.0.1/docs/Data-Number-BigFloat.html
06:58:34 <Guest87792> Instead of using angular and node can Haskell fulfill the need for them?
07:00:07 <Rembane> Guest87792: Could you elaborate on that?
07:00:13 <dramforever> freeside: now *that* looks like good enough
07:00:14 <dramforever> let me try it first
07:00:48 <alunduil> Guest87792, you might be able to fill that niche with purescript but I haven't used it to know the limitations or contrasts.
07:00:48 <Guest87792> suppose for like single thread applications
07:01:23 <dramforever> that's a strange requirement
07:01:28 <Rembane> Guest87792: On serverside?
07:01:36 <Guest87792> yes
07:01:51 <Guest87792> ofc on client you would have to use js lol but ya 
07:02:18 <alunduil> Guest87792, I've been playing with servant and enjoying it but there are several web frameworks if you don't want to roll your own.
07:03:03 <liste> Guest87792: you could use also something that compiles to JS on the client side
07:03:36 <liste> Guest87792: Haskell has lightweight threads, which has all the advantages of node's async model but none of the disadvantages
07:04:00 <Profpatsch> Just found out that the stack codebase is a very nice one to study.
07:04:00 <Guest87792> thanks that answerd my questions xD
07:04:08 <Profpatsch> A lot of stuff to learn.
07:04:21 <Profpatsch> And very clean and well documented.
07:05:17 <karanlearnshaske> hi room. beginner here.
07:05:23 <karanlearnshaske> foldr (\(a,b) x -> (b,x)) (0,0) $ [1,2,3,4]  
07:05:28 <karanlearnshaske> why this doesnt work
07:05:54 <oherrala> karanlearnshaske: your types don't mach
07:06:05 <oherrala> :t [1,2,3,4]
07:06:06 <lambdabot> Num t => [t]
07:06:10 <oherrala> :t (0,0)
07:06:10 <glguy> The arguments in your lambda are backwards
07:06:11 <lambdabot> (Num t, Num t1) => (t, t1)
07:06:52 <liste> :t foldr
07:06:53 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
07:06:59 <liste> note the first (a -> b -> b)
07:07:18 <liste> b is the tuple and a is the number
07:09:14 <Guest87792> uh dumb question from yesterday again i forgot to ask
07:09:32 <Guest87792> (1/) is 1 being applied to / 
07:09:37 <glguy> No
07:09:57 <freeside> well, this looks promising.
07:10:00 <Guest87792> (1/) 2 what is being applied to what
07:10:00 <freeside> Prelude> import Data.Number.CReal
07:10:00 <freeside> Prelude Data.Number.CReal> showCReal 109 (exp 1)
07:10:01 <freeside> "2.7182818284590452353602874713526624977572470936999595749669676277240766303535475945713821785251664274274663919"
07:10:01 <freeside>  
07:10:03 <dramforever> I remember this by remembering: foldr (:) [] xs = xs
07:10:48 <karanlearnshaske> getting it. thanks 
07:10:58 <liste> Guest87792: (1/) is ((/) 1), so (1/) 2 is ((/) 1) 2
07:11:38 <Guest87792> so  how is that reduced?
07:12:13 <dramforever> (1/) 2 is literally 2 being applied to (1/)
07:12:45 <Guest87792> OMG
07:12:53 <Guest87792> thats exactly what clicked right b4 u said it thanks!
07:12:54 <Guest87792> ahha
07:14:38 <dramforever> you're welcome
07:14:55 <dramforever> arrgh looks like BigFloat is, well, Big Float
07:15:02 <Xnuk> > 2 3
07:15:03 <lambdabot>  2
07:15:07 <Xnuk> > 2 3 (/)
07:15:08 <lambdabot>  2
07:15:39 <liste> Xnuk: that's just evil
07:15:43 <Guest87792> so (/1) that whole arugment will be applied to the next argument
07:15:51 <dramforever> @undefine
07:15:52 <lambdabot> Undefined.
07:15:55 <dramforever> > 2 3
07:15:56 <lambdabot>      Could not deduce (Num a0)
07:15:56 <lambdabot>      from the context (Num a, Num (a -> t))
07:15:56 <lambdabot>        bound by the inferred type for ‘e_123’: (Num a, Num (a -> t)) => t
07:16:04 <Xnuk> lol
07:16:23 <dramforever> I knew it...
07:16:51 <dramforever> So I for [1000].[90] I would need, well, 1090 digits of precision
07:17:08 <dramforever> apparently fixed point floating operations isn't a thing
07:17:21 <Guest87792> (-2) 2 1
07:17:35 <dramforever> But it's at least working
07:17:41 <dramforever> freeside: Thanks a lot
07:18:05 <Guest87792> what would be (-2) 2 1?
07:18:08 <glguy> (1/) if (/) being applied to 1
07:18:45 <glguy> (1/) 2 is (/) 1 being applied to 2
07:19:05 <freeside> https://hackage.haskell.org/package/FixedPoint-simple-0.6.1/docs/Data-FixedPoint.html
07:19:24 <glguy> (-2) 2 1, is negative 2 applied to 2, the result of which is applied to 1
07:19:41 <karanlearnshaske> just curious - can we find the lastbutone element using foldr
07:19:56 <mniip> yes but it's going to be a nightmare
07:20:05 <dramforever> wow
07:20:07 <karanlearnshaske> :)
07:20:36 <Guest87792> so (-2) is applied to both 2 and 1 or only the 2
07:20:57 <freeside> >(-2) 2
07:21:06 <mniip> Guest87792, it is applied to 2, and then the result is applied to 1
07:21:09 <glguy>  Functions have a single argument
07:21:16 <Xnuk> I wonder how `2 3 (/)` worked
07:21:39 <dramforever> > 2 3 (/) -- it doesn't
07:21:40 <lambdabot>      Could not deduce (Fractional a1)
07:21:40 <lambdabot>      from the context (Fractional a2,
07:21:40 <lambdabot>                        Num a,
07:21:45 <dramforever> not even funny, you know
07:21:46 <Guest87792> so (-2) itself is a function and 2 is the argument 
07:21:53 <mniip> someone defined an instance
07:22:02 <Guest87792> but once thats done that answer is an argument 
07:22:12 <Guest87792> so how can (-2)  2 1 be possible
07:22:14 <dramforever> on the other hand, what *exactly* did that "someone" do?
07:22:17 <Guest87792> an argument into argument?
07:22:30 <glguy> Guest87792: (-2) 2   evaluates to a function, and then that function is applied to 1
07:22:30 <freeside> https://prime.haskell.org/wiki/NegativeSyntax
07:22:38 <glguy> because lambdabot has a dumb Num instance for functions
07:22:43 <freeside> in theory it does ... in practice, it's a negative 2.
07:22:43 <dramforever> functions and values are treated equal
07:23:02 <dramforever> > :t (-2) 2 1 -- Let's see
07:23:03 <lambdabot>  <hint>:1:1: parse error on input ‘:’
07:23:09 <dramforever> :t (-2) 2 1 -- Let's see
07:23:10 <lambdabot> (Num a, Num a1, Num (a -> a1 -> t)) => t
07:23:20 <Guest87792> got it
07:23:48 <glguy> It's a general case of   f x y, which is   (f x) y
07:23:54 <glguy> f applied to x, the result of that applied to y
07:23:56 <mniip> > foldr (\a p -> case p of (Nothing, _) -> (Just a, Nothing); (x, Nothing) -> (x, Just a); _ -> p) (Nothing, Nothing) [1,2,3,4,5]
07:23:58 <lambdabot>  (Just 5,Just 4)
07:24:16 <glguy> mniip: Can I send you a quick PM?
07:24:16 <mniip> karanlearnshaske, snd is your "last but one" element
07:24:20 <mniip> glguy, sure
07:24:46 <Guest87792> but (-) 2 1 
07:25:05 <Guest87792> the 2 is applied to a negative ?
07:25:12 <bizarrefish> Can one use a typeclass as a type parameter?
07:25:17 <bizarrefish> I'm guessing the answer is no
07:25:27 <alercah> you can if you allow the Constraint kind
07:25:28 <dramforever> Yes
07:25:36 <bizarrefish> alercah: Is that an extension?
07:25:40 <alercah> yes
07:25:42 <dramforever> (Not exactly useful, though)
07:25:42 <bizarrefish> ah
07:25:56 <dramforever> I suppose you can't use any functions in it
07:26:04 <bizarrefish> Is that somehow related to RankNTypes?
07:26:09 <alercah> not at all
07:26:10 <bizarrefish> Hmm
07:26:14 <Guest87792> how does (-) 2 1 be applied im confused
07:26:34 <freeside> > (-) 2 1
07:26:37 <lambdabot>  1
07:26:40 <karanlearnshaske> 2-1
07:26:51 <alercah> Guest87792: the syntax "a op b", for some operator op, is equivalent to "(op) a b"
07:26:53 <Guest87792> (-) is a function though
07:26:54 <karanlearnshaske> 2 goes to left side of (-)
07:26:55 <alercah> :t (-)
07:26:58 <dramforever> :t (- ?x)
07:26:58 <lambdabot> Num a => a -> a -> a
07:26:59 <lambdabot> (Num a, ?x::a) => a
07:27:01 <freeside> > (*) 2 3
07:27:03 <lambdabot>  6
07:27:07 <Guest87792> so (-) isnt a function?
07:27:10 <alercah> it is a function
07:27:13 <alercah> it works like any other
07:27:17 <dramforever> (-x) is special syntax
07:27:19 <alercah> 2 is the first argument, then 1 is the secon
07:27:20 <dramforever> means negative x
07:27:20 <alercah> *second
07:27:25 <mniip> Guest87792, (∆) is sugar for (\x y -> x ∆ y)
07:27:30 <freeside> :t (-) 2
07:27:31 <lambdabot> Num a => a -> a
07:27:37 <Guest87792> wait hold on 
07:27:54 <dramforever> https://prime.haskell.org/wiki/NegativeSyntax
07:28:04 <Guest87792> so (-2) is  a argument and  funciton?
07:28:08 <Guest87792> function*
07:28:12 <freeside> > let myfunction = (-) 2; myfun 0
07:28:13 <alercah> (-2) is special magic
07:28:13 <lambdabot>  <hint>:1:32:
07:28:13 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:28:15 <alercah> it's not a function
07:28:26 <dramforever> FixedPoint-simple is taking forever to build, so thank you again first
07:28:30 <freeside> > let myfunction = (-) 2; myfunction 0
07:28:31 <lambdabot>  <hint>:1:37:
07:28:31 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:28:36 <freeside> argh, make it work
07:28:58 <dramforever> > let myfunction = (-) 2 in myfunction 0
07:29:00 <lambdabot>  2
07:29:04 <freeside> thanks
07:29:26 <freeside> need more sleep
07:29:46 <Guest87792> you guys are mkaing it way more confusing adding other variables and stuff lol
07:30:32 <dramforever> https://prime.haskell.org/wiki/NegativeSyntax
07:30:47 <dramforever> Does this link, posted earlier by freeside, un-confuse this
07:31:02 <freeside> > let myfunction = (-) 4 in myfunction 2
07:31:04 <lambdabot>  2
07:31:06 <alercah> that link is awful
07:31:11 <alercah> let me find a better one
07:31:13 <freeside> > let myfunction = (-) 4 in myfunction 6
07:31:14 <lambdabot>  -2
07:31:33 <alercah> https://wiki.haskell.org/Unary_operator
07:31:56 <alercah> the NegativeSyntax page is a proposal for a change to the language and explains nothing. That page I just linked is slightly better
07:32:00 <dramforever> aleator: +1 I thought it was *the* page, turns out to be a change
07:32:08 <freeside> the world is full of special cases
07:32:14 <alercah> also http://stackoverflow.com/questions/12831217/what-is-the-equivalent-to-1-for-the-subtraction-since-1-is-seen-as-a-nega
07:32:53 <Guest87792> (-) 2 1 okay so the first thing that happens is 
07:33:03 <freeside> > let myfun = subtract 2 in myfun 0
07:33:03 <Guest87792> -2 then -1
07:33:04 <lambdabot>  -2
07:34:30 <mpickering> Does FlexibleContexts imply MultiParamTypeClasses? 
07:34:35 <freeside> no, the first thing happens is the (-) function applies to positive 2, so you get a `2 -` breeding tension like a gun on the mantelpiece
07:34:53 <freeside> then the 0 comes along and discharges the `2 -` with a `2 - 0` which ends up as a 0.
07:36:28 <karanlearnshaske> cant believe one can get free mentorship here.  humans rock.
07:36:44 <freeside> watch the currying happen step by step.
07:36:45 <freeside> > let myfunA = subtract in let myfunB = myfunA 6 in myfunB 1
07:36:46 <lambdabot>  -5
07:37:25 <dramforever> People are tricked into promoting Haskell by Haskell the language itself
07:37:29 <dramforever> You're warned :P
07:37:34 <freeside> the myfunA is like a double-ended Darth Maul lightsaber
07:38:02 <freeside> when myfunA applies to 6, half the lightsaber is extinguished, and the new lightsaber is myfunB
07:38:03 <Guest87792> perhaps im too dumb for haskell
07:38:26 <freeside> myfunB then applies to 1, and both ends of the lightsaber get extinguished, and you're left with -5
07:38:41 <Guest87792> i kinda see that lol
07:39:09 <freeside> that's your basic binary function
07:39:29 <freeside> you can have lightsabers with 0, 1, 2, or more arity
07:40:05 <freeside> each time the function applies to a term, one of the beams of light gets plugged up with the value of the term
07:40:25 <Guest87792> thanks!
07:46:45 <erbse> hi, what's :->: mean in haskell?
07:47:07 <mniip> it's a data constructor
07:47:33 <mniip> it might mean more than that if you tell us what module it was imported from
07:47:35 <Clint> http://hayoo.fh-wedel.de/?query=(:-%3E:)
07:48:09 <mniip> ah well, a type constructor works too
07:48:25 <erbse> @mniip @Clint thanks guys, I saw some guy use it but I can't google with this marks
07:48:25 <lambdabot> Unknown command, try @list
07:48:47 <Clint> next time don't use google
07:49:10 <erbse> yeah
07:51:07 <mniip> I use google for haskell all the time but not for the operators
07:51:12 <nmattia> guys, whenever I use a free monad, I end up realize I don't need it
07:51:19 <nmattia> but it still seems like a necessary step
07:51:21 <mniip> most of the time I know the package name or the module name though
07:51:26 <nmattia> has anyone had that kind of experience?
07:57:33 <maerwald> nmattia: I have that with a lot of things... Reader, State etc xD
07:58:10 <Eduard_Munteanu> They say monads you actually pay for are more useful.
07:58:22 <Eduard_Munteanu> Like in online games.
07:58:22 <Guest87792> so (/1) 2 is an divison function with an argument of 1 applied to it
07:58:26 <buglebudabey> I hear that people rarely need to use Reader State and Write, so are there any monads that actually are useful generally speaking
07:59:07 <buglebudabey> and why are R W and S so talked about if they arent needed that often
07:59:18 <buglebudabey> in tutorials and book
07:59:20 <buglebudabey> books*
07:59:26 <Clint> i use RWS often
07:59:27 <Eduard_Munteanu> Reader is quite common.
07:59:28 <nmattia> buglebudabey: I guess they're convenient
07:59:32 <mniip> State is used quite often
07:59:43 <sdx23> Guest87792: (/1) = \x -> (/) x 1 -- as opposed to \x -> (/) 1 x = (/) 1 = (1/)
07:59:44 <nmattia> buglebudabey: when you don't want to have to thread every parameter by hand
07:59:51 <vaibhavsagar> I've found uses for Reader, Writer, and State
08:00:14 <buglebudabey> nmattia since i'm new to reader, what is parameter threading
08:00:15 <nmattia> but can free monads always be replaced by an equivalent typeclass, or am I misusing them?
08:00:42 <c_wraith> nmattia, the advantage is that you don't use type classes. 
08:00:47 <nmattia> buglebudabey: I don't think it's an actual term, I just mean not having to pass the same arguments to the next function explicitly
08:01:04 <Eduard_Munteanu> As in threading a needle.
08:01:14 <buglebudabey> gotcha
08:01:18 <nmattia> c_wraith: so just a matter of taste?
08:01:20 <mniip> > (do x <- sin; y <- cos; return (x^2 + y^2)) 123
08:01:22 <lambdabot>  1.0
08:01:24 <Aruro> are there any show instances for Array (Int,Int) a ? Basically table.
08:02:29 <c_wraith> nmattia, well, if you dislike using the class mechanism for ad-hoc behavior without laws, it's a pretty big win. 
08:02:35 <vaibhavsagar> buglebudabey, using State is equivalent to passing both your argument and state to each function
08:02:47 <nmattia> I could imagine that if you have to somehow map over the parameters free/operational would come really handy
08:03:12 <maerwald> vaibhavsagar: well, you gain the monad interface too, which gives a lot of free stuff
08:03:18 <vaibhavsagar> I have the desugaring of a simple example in a blog post: http://vaibhavsagar.com/blog/2016/06/17/haskell-state/
08:03:29 <maerwald> but other than that... it's really just silly obfuscation almost
08:03:29 <vaibhavsagar> maerwald, you're right
08:03:52 <nmattia> c_wraith: so another win is simply that whatever free/op you make it *will* satisfy the monad laws
08:04:01 <nmattia> is that always true?
08:04:19 <c_wraith> well, as long as your Functor instance is valid, yes. 
08:04:36 <c_wraith> but if you're using operational, that's taken care of too
08:05:42 <nmattia> well I guess I'll stick to free for this one, and see in the long run if it makes a difference
08:06:36 <c_wraith> free is slower. its overhead makes a difference if it is a significant part of hot sections of code. that's the downside. 
08:07:44 <nmattia> I can imagine that
08:13:37 * hackagebot simple-logger 0.0.1 - A very simple but efficient logging framework  https://hackage.haskell.org/package/simple-logger-0.0.1 (AlexanderThiemann)
08:24:24 <nitrix> How common is it to parametrize data types to avoid cyclic dependencies?
08:24:39 <mniip> I remember reading some paper about implementing zip as a fold
08:24:59 <mniip> what was the problem there and why the obvious 'foldr (\x f -> foldr (\y r -> (x, y):f (map snd r)) []) (const [])' solution didn't fit?
08:25:33 <c_wraith> nitrix, that's one of the best ways to avoid cyclic dependencies. 
08:26:26 <nitrix> c_wraith: Prior to that, I had dedicated Types.* module namespace, but I got rid of it and parametrized my data types. I really like the result.
08:26:41 <nitrix> c_wraith: I thought I was being clever, but apparently it's nothing new :P
08:26:51 <glguy> nitrix: I think if parameterization makes sense for your case, then that's the best and standard solution
08:27:02 <nitrix> glguy: Perfect. Thanks.
08:27:28 <c_wraith> mniip, if it was the hyperfunction paper, it was about applying build/fold fusion to zips so that the intermediate lists are never materialized in memory. 
08:27:40 <mniip> aah
08:27:44 <mniip> right, fusion
08:28:39 <c_wraith> specifically fold/build fusion, rather than stream fusion. stream fusion already had no issues with zip. :) 
08:30:38 <Guest87792> quick question so (+1) 2 we could say that was partially applied and orginally was (+) 1 2
08:30:44 <nmattia> another advantage of using free is that you can inspect the intermediate steps, whereas with typeclasses you just get the final monadic value and that's it, right?
08:31:03 <nmattia> Guest87792: I thinkg it would be (+) 2 1
08:31:14 <Guest87792> ya thats what i meant apologies 
08:31:38 <nmattia> Guest87792: then I would say yes
08:32:06 <Guest87792> no
08:32:07 <Guest87792> wait
08:32:15 <c_wraith> nmattia, that turns out to not be true in practice.. you could always make an instance for your free type to recover the concrete representation. 
08:32:15 <Guest87792> i thought it goes left to right
08:32:37 <Guest87792> so (+1) + 2
08:32:43 <nitrix> Guest87792: (+1) is a different section from (1+)
08:32:46 <nmattia> Guest87792: (1 + 2) == (+) 1 2
08:33:10 <nitrix> Guest87792: (+1) == \x -> x+1
08:33:11 <nmattia> Guest87792: just like (,1) 2 == (2,1)
08:33:16 <nitrix> Guest87792: (1+) == \x -> 1+x
08:33:35 <Guest87792> they are both sectioning regardless correct
08:33:41 <mniip> :t dimap ZipList (dimap ZipList getZipList) ap
08:33:41 <Cale> Yeah, it's (\x -> x + 1) 2
08:33:42 <lambdabot>     No instance for (Monad ZipList) arising from a use of ‘ap’
08:33:42 <lambdabot>     In the third argument of ‘dimap’, namely ‘ap’
08:33:42 <lambdabot>     In the expression: dimap ZipList (dimap ZipList getZipList) ap
08:33:49 <mniip> oops
08:33:50 <mniip> :t dimap ZipList (dimap ZipList getZipList) (<*>)
08:33:51 <lambdabot> [a -> a1] -> [a] -> [a1]
08:33:52 <nmattia> c_wraith: but then you can't force the user of your typeclass to use your "memorizing" instance
08:34:04 <mniip> hmm yeah, dimap definitely looks better than composition
08:34:33 <c_wraith> Guest87792, both sections, sure. but not always the same. not all operators are commutative. 
08:34:40 <buglebudabey> in data.list what is the union function O(n*m)?
08:34:49 <buglebudabey> is the union function**
08:35:01 <nmattia> Guest87792: it becomes clear with tuples
08:35:25 <Guest87792> i think im learning disabled seeing this after trying to learn haskell
08:36:55 <nitrix> Do you understand partial application? Possibly, it could be only the infix operators that are confusing you.
08:37:33 <nitrix> foo 5 2 ≡ (foo 5) 2
08:37:42 <mniip> why is Profunctor not in base :(
08:38:15 <freeside> partial application is when one or more, but not all, of the blades of your lightsaber gets plugged up by a value
08:38:56 <nmattia> c_wraith: actually I think I misunderstood your sentence above. what do you mean by "make an instance for your free type"?
08:40:24 <c_wraith> nmattia, if you're using a class approach, you can make an instance of that class for Free MyRepresentation that builds the Free structure. 
08:40:36 <Guest87792> like i get that operators are infix and by (+) makes it a function hence the prefix 
08:40:57 <Guest87792> and that (+1) 2 is where something is partially applied 
08:41:16 <Guest87792> but i was thinking the orginal of that would be (+) 1 2 
08:41:26 <Guest87792> but i dont get how its (+) 2 1
08:41:41 <glguy> There are four ways to use an operator, you can provide none, the left, the right, or both arguments
08:41:48 <nitrix> Guest87792: + is already a function, with or without the parens.
08:41:50 <buglebudabey> is there a function :: a -> t a -> t a where that inserts an item into a container if 'a' is unique?
08:41:51 <nmattia> c_wraith: gotcha. but then, only with the Free approach can you make sure that a given monadic value will always retain its structure
08:42:00 <glguy> (+), (1 +), (+ 1), (1 + 2)
08:42:24 <Guest87792> + is a function but ot use it as a prefix function the () is needed
08:42:25 <nitrix> buglebudabey: Not in the generic form.
08:42:32 <c_wraith> that's true. building the Free structure directly can let you control sharing. 
08:42:38 <buglebudabey> nitrix specific instance is okay too
08:42:53 <nitrix> buglebudabey: But the respective containers, like Data.Set for example would do this.
08:43:43 <nmattia> c_wraith: nice, thanks for clarifying
08:43:44 <buglebudabey> nitrix thanks
08:44:37 <nitrix> buglebudabey: containers-0.5.7.1/Data.Set.insert :: Ord a => a -> Set a -> Set a
08:44:55 <buglebudabey> thank you again
08:45:06 <glguy> Guest87792: Perhaps look up section "3.5 Sections" in the Haskell 2010 report? https://www.haskell.org/definition/haskell2010.pdf
08:45:35 <glguy> Guest87792: "Section" is the term used to describe (1 +) and (+ 1)
08:47:30 <nitrix> (Binary operators with one of its operand sectioned). It's still partial application, it just gives just you a little more controlled on where the partiality lies, if that's even a term.
08:47:37 <nitrix> *contorl
08:47:40 <nitrix> erf.
08:48:50 <nitrix> With the exception of (- exp) which isn't a section.
08:50:19 <Gurkenglas> I would like to traverse everything in a given list except for that which is traversed by another given Traversal. Is that possible?
08:52:07 <nitrix> Gurkenglas: Does the type in question lets you do local traversals instead of global? (Something akind to lenses?)
08:52:20 <jfischoff> how do you upgrade stack?
08:52:31 <Skami> Hi! I got a quasiquoter for matrices (e.g. let x = 7 in [mat| 1 $x 3 4|] == V2 (V2 1 7) (V2 3 4)). But I don't know how i can extend it so it accepts haskell code instead of only variable names (e.g. [mat| 1 $(sin 0) 3 4|] == V2 (V2 1 0) (V2 3 4))
08:52:35 <jle`> jfischoff: 'stack upgrade' ?
08:52:42 <jfischoff> stack upgrade installed a binary locally … not what I want … 
08:52:48 <jfischoff> should I just copy myself?
08:52:50 <jfischoff> seems ood
08:52:52 <jfischoff> odd
08:53:08 <jle`> it might be assuming that that location is in your $PATH
08:53:23 <jfischoff> yes I perhaps
08:53:39 * hackagebot repl-toolkit 1.0.1.0 - Toolkit for quickly whipping up config files and command-line interfaces.  https://hackage.haskell.org/package/repl-toolkit-1.0.1.0 (jtapolczai2)
08:53:42 <nitrix> Gurkenglas: Because otherwise, you have a traversal over the complete data structure and according to your specification, all elements are always going to get excluded.
08:53:45 <nmattia> jstimpfle: I had the same thing happen a few days ago, I just copied it
08:54:10 <nmattia> jfischoff: ^^
08:54:26 <jfischoff> I understand the issue now .. thanks all
08:56:13 <Guest87792> did you guys understand these concepts really fast?
08:56:19 <jfischoff> no
08:57:03 <nitrix> Guest87792: Speed is a terrible metric for learning things well.
08:57:14 <vaibhavsagar> Chris Allen says it took him at least 5 years: https://www.youtube.com/watch?v=Bg9ccYzMbxc
08:57:43 <vaibhavsagar> and now he's writing a book to teach it to others better
08:57:46 <mniip> I'm 3 years into haskell and there's still plenty of things out of my reach
08:58:08 <maerwald> Guest87792: most haskellers say "oh, cmon, haskell is so easy to learn", but that's outright wrong and goes against anything you observe during haskell courses :P -- the amount of confusion and frustration is a lot higher than in say, e.g. java, python or whatnot
08:58:46 <Rotaerk> haskell 98, language alone, isn't that hard to learn
08:59:06 <nitrix> The language is alright, it's learning the libraries that is painful.
08:59:10 <Rotaerk> it's the stuff built upon it that takes a while, as well as the heaps of newer features
08:59:16 <mniip> haskell gets easy to learn after some point
08:59:28 <Guest87792> this is my first and only language xD
08:59:58 <mniip> Guest87792, that isn't neccessarily a bad thing as you don't have imperative language prejudices
09:00:06 <maerwald> Guest87792: cool, a lot of haskellers also say "oh, haskell is only hard if it isn't your first language maybe", the classic "unlearning argument". Which is also wrong :P
09:00:45 <nitrix> "Wrong". I think there's still so value to both sides of the argument.
09:00:56 <nitrix> *some
09:01:13 <Rotaerk> I think if you're coming from an imperative background, you don't really have to unlearn so much as recognize that much of what you know isn't going to help
09:01:14 <Cale> maerwald: It would be more correct to say that learning Haskell is not any harder than learning your first programming language
09:01:17 <freeside> this is the era of donald trump! every judgement must include a pithy put-down, else it will not pass validation checks.
09:01:22 <Rotaerk> and that you're basically learning to program again from scratch
09:01:29 <nitrix> I personally explain it as "return on investment" and the other concerns are immediatly gone.
09:01:30 <maerwald> Cale: and that I strongly disagree with
09:01:41 <Cale> maerwald: It's just that people come to expect it to be easier to pick up languages than that :)
09:01:50 <maerwald> yeah, I disagree
09:02:28 <dmj`> > foldl' (flip ($)) 0 (reverse [(+1),(*2)])
09:02:29 <lambdabot>  1
09:02:50 <Rotaerk> the main difficulty with haskell versus something like C# or Java is that in the latter case, lazy disinterested programmers can learn just enough to get by, and write something that's coded badly but "works"
09:02:52 <Cale> If you already know a half-dozen imperative languages, you can pick up a new one pretty easily, but picking up Haskell is going to be nearly as hard as if you didn't know how to program.
09:02:58 <maerwald> I know the time and effort it took me to learn pascal (my first language). And I can easily compare that with the time and effort of learning haskell, while there was no "unlearning pascal" involved. There is a clear difference.
09:03:13 <maerwald> and I've observed that on other ppl too
09:03:27 <Rotaerk> I suppose it's possible to do that in haskell too though... but perhaps harder
09:03:27 <maerwald> Cale: that's orthogonal to the argument
09:03:41 <yyyyy> how would someone define a `$` for type constructors? e.g. TVar :$: Maybe SomeRecord
09:03:41 <Guest87792> which was harder to learn for you pascal or haskell
09:03:48 <maerwald> haskell ofc
09:04:04 <Cale> maerwald: It's an explanation for the perception that Haskell is easier to learn first. It's not really, it's just about equally hard to learn first.
09:04:09 <Guest87792> what should be the next language to learn after haskell?
09:04:10 <maerwald> pascal doesn't have that many concepts, and the concepts it has don't come from CT
09:04:10 <jle`> yyyyy: `type f $ x = f x`
09:04:18 <maerwald> it's not particularly abstract or intellectually challenging
09:04:19 <maerwald> haskell is
09:04:21 <yyyyy> with just one set of parentheses it's ok, but for more a :$: and :.: would be nice
09:04:32 <Rotaerk> Guest87792, well depends on what you need
09:04:35 <freeside> Wolverine: C++. Captain America: Java. Iron Man: Javascript. The Silver Surfer: Haskell. Jean Grey: Agda.
09:04:46 <Guest87792> what do you guys suggest?
09:04:49 <yyyyy> jle`: not for values, for types
09:04:49 <silver> hell yeah
09:04:49 <mniip> yyyyy, type composition is not allowed
09:04:55 <nitrix> maerwald: I think learning your first language generally stretches on longer periods than most actually recalls. I remember getting books on programming and skimming through without really knowing much what was going on, just curiously developping a hobby before being "learning full-time".
09:04:57 <jle`> yyyyy: this works for types
09:04:58 <Cale> maerwald: The origin of concepts doesn't inherently make them harder or easier to learn.
09:05:00 <maerwald> Guest87792: C
09:05:03 <jle`> yyyyy: try it :)
09:05:09 <maerwald> Cale: I disagree
09:05:15 <Rotaerk> Guest87792, it's much harder to find a haskell job than some of the more mainstream languages
09:05:31 <Zemyla> Okay, I don't know if I'm correct or not, but I think I've come up with a way to generate n primes ib O(n log n) time.
09:05:33 <yyyyy> i just did! i get type constructor or class not in scope for `$`.
09:05:49 <jle`> hm, it works for me on my ghci
09:05:54 <jle`> type f $ x =  f x
09:05:57 <mniip> -XTypeOperators
09:06:03 <jle`>  :k Maybe $ (,) Int Bool   -- => :: *
09:06:04 <Rotaerk> Guest87792, so if you want to be a programmer by trade, you should learn something more commonly used as well, such as C# or Java
09:06:10 <Welkin> Zemyla: a wheel sieve?
09:06:32 <Welkin> Rotaerk: more likely javascript, python, or ruby
09:06:34 <Rotaerk> (or C, C++, Javascript, or Python ... or whatever; depends on what you'd be getting into)
09:06:36 <freeside> zemyla: Erastothenes is O(n log log n)
09:06:38 <nitrix> General question, do you find "composing to monads doesn't necessarily give another monad" limitating?
09:06:46 <maerwald> Guest87792: yeah, if you want to "strategically" learn programming languages to put on your CV, haskell is a bad choice, look at the tiobe index http://www.tiobe.com/tiobe_index
09:06:50 <maerwald> pick the top 5 and learn them
09:06:56 <maerwald> if you learn haskell, do it out of interest
09:07:11 <Cale> I also think there's an extent to which we forget how much effort learning our first programming language(s) was. I spent about a decade learning to program in various imperative languages before starting with Haskell, and there were certainly a lot of struggles there.
09:07:16 <Cale> (especially early on in that)
09:07:21 <mniip> nitrix, do you find the fact that a square root of a rational isn't always rationl limiting?
09:07:25 <nitrix> I've faced that situation a couples times where I managed to refactor the code into clever monad transformers, but I'm afraid I'll have to do this some day and I'll get stuck again.
09:07:34 <jle`> i also had much much lower ambitions when learning my first language than when learning haskell
09:07:46 <Welkin> my first language was mIRCscript
09:07:47 <Welkin> hahahaha
09:07:48 <Rotaerk> Guest87792, also, even if you never use haskell professionally, it's not wasted effort, because a lot of the concepts are invaluable no matter what language you're using
09:07:50 <jle`> when learning my first language all i needed to do was draw a picture on a screen
09:07:51 <mniip> oh god
09:07:58 <jle`> when learning haskell i tried to build a full stack web app
09:08:10 <Welkin> I just wanted to automate my xdcc downloads
09:08:16 <Welkin> leech off those anime/manga bots
09:08:22 <Welkin> I archived the whole bot using a script
09:08:28 <yyyyy> jle`: ah, with TypeOperators it did work. nice!
09:08:30 <Cale> I think in learning anything, if you never feel a bit "at sea", if it's not much of a struggle, you're probably not learning as quickly as you could be.
09:08:44 <maerwald> Cale: I haven't forgotten the effort, I know it was about 3 months, and then we were able to program sth like a fractal generator (with guidance ofc) as a project. Doing the same in haskell would just be nuts.
09:08:44 <yyyyy> thanks, jle` and mniip.
09:08:57 <Cale> maerwald: I don't think it would be...
09:09:00 <jle`> np! it's a bit of a shame that it isn't defined in the main libraries.  or maybe not
09:09:03 <maerwald> well, I disagree
09:09:31 <maerwald> I think you've only worked with really smart people and don't know how the "regular programmer" down there looks like ;)
09:09:34 <mniip> it's not haskell98
09:09:36 <maerwald> and that's a compliment even
09:09:42 <Cale> maerwald: After about 2 months in Haskell, I wrote some small GUI applications related to music theory
09:09:51 <maerwald> yes, you ;)
09:09:57 <maerwald> but you are Cale
09:09:59 <jle`> mniip: a lot of base isn't haskell98, tho
09:10:08 <mniip> Prelude is tho
09:10:08 <Rotaerk> most programmers don't give a shit, and wouldn't be caught dead in haskell
09:10:12 <nitrix> First months I did a distributed file system and now working on a game (after a year).
09:10:19 <Rotaerk> they barely get by in C#/Java
09:10:24 <yyyyy> jle`: i agree. it should be. i was aching for it and didn't know how to solve it.
09:10:25 <jle`> yeah, it might not need to be in prelude, but having it be in a canonical module might be nice
09:10:26 <nitrix> I also have a git remote proxy thing as well.
09:10:41 <Cale> I'm really not all that special. If I know a lot of stuff, it's just because I spend my time well (and I don't even spend it all that well).
09:10:42 <Guest87792> so basically haskell and javascript it would be enough
09:10:43 <jle`> but it would completely upset current style guidelines, probably
09:11:20 <maerwald> Guest87792: hahaha, doing javascript after haskell will drive you nuts, been there
09:11:22 <maerwald> done that
09:11:26 <Welkin> Guest87792: if you are not actually going to be writing web front-ends I would choose lua over javascript
09:11:29 <Cale> Around that time when I was first learning Haskell, I also had a pretty full course load, so I'm sure that someone who was more serious about it could be faster at getting to practical work.
09:11:56 <mniip> I wonder what were my first haskell programs
09:11:58 <Cale> If you learn Haskell, you can just compile Haskell to Javascript ;)
09:12:06 <Rotaerk> Guest87792, hmm.  there is never "enough" when it comes to programming languages :P
09:12:42 <Guest87792> was hoping to learn something to get a job with haskell and another 
09:12:43 <Rotaerk> programmers often know lots of languages
09:12:59 <maerwald> Guest87792: forget about it, there are almost no public job offers in haskell
09:13:06 <Welkin> Guest87792: unfortunately, there are not many haskell positions, and most people have never heard of haskell
09:13:13 <Gurkenglas> mniip, well here's your first IRC posts http://ircbrowse.net/browse/haskell?events_page=751&q=mniip
09:13:13 <Cale> maerwald: Also, mind you, for most of that couple of months, I was doubtful that I could accomplish anything of much use with the language :)
09:13:24 <Welkin> Cale: lol, same
09:13:29 <mniip> Gurkenglas, nope!
09:13:37 <Gurkenglas> *to #haskell
09:13:49 <maerwald> Cale: my first real haskell project was using haskell for computational geometry with the diagrams library... it took me 3 times the effort of my colleagues who used C++/java.
09:13:51 <mniip> ah wait
09:13:51 <mniip> yes
09:14:04 <maerwald> because it was almost impossible to express the non-trivial algorithms without deeper knowledge about stuff
09:14:09 <Cale> Also, the guy who wrote Frag was apparently a complete beginner in Haskell.
09:14:20 <Cale> (but not a complete beginner to programming, that would be crazy)
09:14:29 <maerwald> I didn't know about ST, State, Monad transformers or other stuff
09:14:31 <nitrix> mniip: main = (liftM nub $ sequence $ take 5 $ repeat $ getLine) >>= sequence_ . (map putStrLn)
09:14:33 <nitrix> mniip: That's cute.
09:14:35 <maerwald> it was a nightmare
09:14:50 <Guest87792> well scala has good job offers i guess and erlang
09:14:54 <Rotaerk> Guest87792, that link that maerwald provided above (http://www.tiobe.com/tiobe_index) shows a prioritized list of languages that are worth knowing for the sake of employment
09:14:56 <jle`> were your colleageus also learning C++/Java at the same time?
09:14:57 <Welkin> at this point I don't see any difference between writing something in haskell or an imperative language, except that in the imperative language it is simply easier to do state mutation, so that is what you'll reach for more often
09:14:58 <mniip> clearly that was over 10 months after I started with haskell
09:15:00 <mniip> see the timestamps
09:15:01 <Welkin> the language encourages it
09:15:23 <maerwald> Cale: so in order to achieve the same thing, I needed to know 5 as many concepts. And ...well, learn all of them. That's the difference of haskell.
09:15:38 <Rotaerk> C is worth knowing, at least to some degree, regardless
09:15:40 <Cale> maerwald: Well, if you're being given instruction in terms of imperative algorithms, it certainly takes a good bunch of experience before you really get to the point of being able to translate those to Haskell at all, let alone work out how they ought to fit in with the framework of something like diagrams.
09:16:00 <Cale> So, well, sure, *that's* going to be hard :)
09:16:00 <maerwald> Cale: yeah, I translated them all. It was nuts.
09:16:02 <Guest87792> i see assembly there but which assembly arch are they speaking off 
09:16:05 <mniip> also damn
09:16:06 <Guest87792> intel or arm
09:16:17 <Welkin> Guest87792: once you know one imperative language, you know them all
09:16:17 <mniip> nub <$> replicateM getLine >>= mapM_ putStrLn
09:16:22 <Welkin> they are basically the same thing
09:16:23 <maerwald> Cale: but not only that, also the "effects problem", because we had to visualize algorithms
09:16:25 <Welkin> just pick on
09:16:29 <Welkin> just pick one*
09:16:29 <jle`> i remember merijn helped me with my first haskell question here in #haskell , i wonde rwhere he is these days
09:16:33 <maerwald> so... guess what, realize you have IO-free functions 
09:16:46 <maerwald> and then do what? next nightmare
09:16:50 <Guest87792> i see erlang devel making 180k a year lol
09:17:15 <maerwald> visualize as in "show the steps", not just a diagram
09:17:26 <nitrix> jle`: Often on ##programming and #haskell-beginners
09:17:29 <maerwald> that's rather trivial in java, you just add random drawing to your computation
09:17:34 <silver> probably because he is good, not because language magically makes you 180k :P
09:17:57 <mniip> jle`, probably #perl
09:17:58 <maerwald> Cale: also, I could go on and on about this. So, IMO, haskell is in no way easier. It's more powerful und expressive though.
09:18:07 <Cale> It's really not all that bad in Haskell either, though anything is going to be hard if you don't know what's going on.
09:18:21 <Cale> There are plenty of things which make Java annoying as a beginner too.
09:18:33 <mniip> well, he's not on right now, but that's the channel I saw him frequenting the most
09:19:02 <maerwald> Java doesn't have 300 concepts, half of them coming from CT, the other half being smart semi-hacks the community managed to come up with :P
09:19:21 <Welkin> we are all aware of maerwald's agenda by this point
09:19:30 <silver> maerwald, I agree, this might be due to differene in ways you think about programs, but instructions/prescription/imperative "method" is way easier to use without any background
09:19:31 <Cale> Java has worse: it has 300 concepts which *didn't* come from CT, and are inelegant nonsense
09:19:32 <maerwald> Welkin: I doubt you are
09:19:38 <Welkin> no need to repeat it every day maerwald 
09:19:44 <maerwald> Cale: well yeah, but they are pretty easy to learn mostly
09:19:48 <Rotaerk> ^ that means he's got an even bigger secreter agenda
09:19:55 <Welkin> we know you like to be the devil's advocate against learning haskell
09:19:57 <Cale> So are the things which came from CT to Haskell! :)
09:20:05 <maerwald> Welkin: see, you are wrong about that
09:20:10 <maerwald> Cale: I disagree
09:20:15 <silver> but if a teacher can introduce you to other ways of thinking, like functions, term-rewriting etc. Haskell might be easy enough, not sure though
09:20:17 <Cale> At least, *as easy*
09:20:31 <Cale> I mean, I would hesitate to say that either was easy
09:20:39 <Cale> But as far as abstractions go...
09:20:39 <mniip> maerwald, when are we going to upgrade the type of fmap to 'c a b -> d (f a) (f b)'
09:20:55 <Cale> mniip: Ed's working on it
09:20:55 <Welkin> after only writing in haskell for a while, it was weird coming back to an imperative language
09:21:04 <Welkin> I was lost ofr a bit before I readjusted
09:21:04 <Cale> (sort of :)
09:21:09 <mniip> I'm aware :p
09:21:16 <maerwald> Welkin: what I am missing in the haskell ecosystem is a a pull to what is a common known thing in CS: KISS. I never see people talk about it or try to achieve it. It's mostly just about "oh look, I can do this mostly elegant with all my type magic". 
09:21:16 <mniip> discussed it this morning
09:21:32 <nitrix> mniip: How does this even works? What'd d and c ?
09:21:38 <mniip> nitrix, categories
09:21:49 <nitrix> mniip: Isn't the arity different too?
09:21:49 <jle`> nitrix: for normal fmap, c and d would both be  (->)
09:21:56 <nitrix> mniip: Oh so d will be a category of functions?
09:22:05 <nitrix> Gotcha
09:22:12 <jle`> still a category of types
09:22:16 <mniip> as it stands Functor is a functor from Hask to Hask
09:22:16 <Cale> maerwald: Well, you'll see me arguing against building monad transformer monstrosities all the time :)
09:22:34 <nitrix> mniip: Is Hask limitating?
09:22:45 <mniip> with a more advanced construction you can define a functor type that lets you reason about higher functors
09:22:57 <mniip> and so you can get rid of Contravariant, Bifunctor, Profunctor,...
09:23:06 <nitrix> I thought we already had these functors, like functors over categories and whatnot.
09:23:31 <mniip> nitrix, is (->) a functor
09:23:33 <jle`> they exist, but there's no unifying typeclass
09:23:59 <nitrix> mniip: Haskell's functor or CT functor?
09:24:05 <Cale> maerwald: If anything makes the ideas from CT harder to learn than Java's shenanigans, it must just be that people have an aversion to the scary names and presume that it's going to be hard.
09:24:21 <maerwald> Cale: nah, it's abstraction
09:24:29 <mniip> nitrix, in haskell
09:24:37 <nitrix> mniip: Then no, afaik.
09:24:42 <mniip> it could be
09:24:54 <mniip> a functor from Hask^op to [Hask, Hask]
09:24:55 <maerwald> Cale: also, there is only one reason I like haskell. It's declarative nature. But there are various occasions when haskell really stops being declarative.
09:24:59 <Cale> There is, at a fundamental level, not that much to the ideas -- especially the ideas which are actually along the path of getting practical work done in Haskell.
09:25:22 <maerwald> Cale: Java ideas are dumb and don't have any depth. You just learn the pitfalls and are done.
09:25:28 <maerwald> see Generics
09:25:33 <maerwald> it's dumb and broken
09:25:36 <nitrix> mniip: Are they going to create yet another extension for fancier CT stuff like they did for TypeInType / Levity ?
09:25:40 <maerwald> but it's trivial too
09:25:40 <mniip> fmap f = Nat (. f)
09:25:50 <Cale> It's not trivial at all
09:25:54 <mniip> nitrix, you can represent it in modern haskell
09:25:57 <Rotaerk> the main reason I like haskell is its type system
09:26:13 <maerwald> Rotaerk: not for me, I like prolog too
09:26:14 <mniip> just need to define a bunch of things differently
09:26:25 <Rotaerk> never used prolog
09:26:33 <maerwald> it doesn't have types in the classic sense
09:27:00 <maerwald> whatever "classic" means :D
09:27:16 <Cale> maerwald: There's a fair amount of tricky stuff to Java's generics, especially relating to how it interacts with subtyping, which will trip you up and create lots of issues for you if you don't understand it.
09:28:02 <maerwald> Cale: building an intuition for something like "when do you use monads, when applicatives, what are their differences in terms of usefulness and applications?" is something that really requires... well, meditation. You don't need meditation in java. :P
09:28:03 <Cale> Also the interaction with type erasure, which can be surprising.
09:28:16 <maerwald> Cale: Generics might have been a bad example, yeah
09:28:29 <Cale> maerwald: That's not a real question though: you use monads when the libraries you want to use define monads
09:28:35 <maerwald> Cale: sure it is
09:28:44 <maerwald> and there is a pretty good answer on SO
09:28:46 <Cale> and you use applicatives when the libraries you use define applicative functors
09:28:53 <maerwald> that's not what I meant no
09:29:19 <Cale> Are you asking when you should make your library define a monad?
09:30:08 <maerwald> Cale: no, it's about understand what you can _DO_ with applicative, it's expressivity and nature
09:30:13 <maerwald> not just in the sense of types
09:30:28 <maerwald> that requires more than just looking at APIs or types
09:30:29 <Cale> You mean, which algorithms can be written polymorphically to work with any applicative?
09:30:39 <maerwald> Cale: this is my favorite answer http://stackoverflow.com/a/17412969
09:30:43 <Cale> This kind of thing seems like a distraction from getting work done.
09:31:12 <maerwald> Cale: not at all, it allows you to make the distinction of "control flow" and "result flow" for example, which is sort of fuzzy, but still allows to build an intuition of the difference
09:31:23 <maerwald> s/control/effect/
09:31:38 <maerwald> what you can do with one thing and the other
09:31:39 <maerwald> and what not
09:31:54 <maerwald> because it's so abstract that's not directly evident
09:32:01 <Cale> Yes, it's possible to say things regarding what kinds of algorithms and instances are possible under the umbrella of each abstraction
09:32:11 <Cale> But if you're trying to write a program, this information isn't helpful.
09:32:40 <Cale> Well, any program which is not at a fairly huge scale
09:32:40 <maerwald> that's a level of thinking you are barely exposed to in other languages and it's not just intellectually demanding, but also requires a great deal of building up "intuition"
09:34:13 <maerwald> and this is just one example, we can extend the discussion to "how do I model AND extend my effects without breaking my API completely every time"?
09:34:20 <Cale> People like to talk about this kind of thing in the context of Haskell because it's possible to talk about it, since we have words for it, but it is not really all that relevant to getting stuff done.
09:34:21 <maerwald> again, a question that doesn't come up in e.g. java at all
09:34:44 <Cale> and that kind of thing is again just a waste of time :)
09:35:25 <maerwald> not at all... I gave examples, e.g. implementing algorithms and then realizing "oh wait, also need to draw stuff during the computation", or "oh wait, need to add timing!"... and there goes your initial simple solution
09:35:43 <maerwald> in java you just add that stuff to your boring object, easy
09:35:46 <Cale> If your goal is to write a program which does some task, that level of abstraction is rarely going to improve your single program.
09:36:24 <Cale> Unless your program is sufficiently large that you can take advantages of multiple instances of the abstraction you define within it.
09:36:35 <Cale> -s
09:36:59 <Cale> But beginners are rarely going to be writing a program with such a giant scope
09:39:20 <Cale> Sometimes there are cute ways to take advantage of an abstraction in the small -- I recall early on writing an L-systems generator with Paolo Martini (who was a bit more of a beginner than I was at the time)
09:39:29 <yyyyy> truth be told if you want to just “draw stuff during computation” and that kind of side-effecting problem is recurrent the person can just tuck everything in the IO monad.
09:39:46 <yyyyy> until said person understands how to encapsulate the effects.
09:39:50 <Cale> and we realised that the program to unfold a non-deterministic L-system that we wrote using the list monad actually didn't use anything specific to lists
09:39:56 <maerwald> yyyyy: all of my code was IO-free and used heavy recursion logic. You simply could not "just add IO everywhere"
09:40:12 <Cale> and that let us use a random generation monad instead, and pick an unfolding at random :)
09:40:18 <maerwald> yyyyy: even worse, using the diagrams library that kind of design isn't even particularly supported 
09:40:29 <Cale> That kind of thing is cute to realise, but really really not essential
09:40:53 <Cale> Because if we wanted to generate one at random, we could also have written the random algorithm and it would have been another 5 lines of code
09:41:20 <maerwald> yyyyy: so I ended up modifying the algorithms so they don't just return the result, but also collect all intermediate states, and then use that state information after the computation is done to transform it into a diagram... and then actually run it through IO
09:41:21 <Cale> So we saved ourselves writing a handful of lines, and it was nice, but it was a tiny fraction of the program
09:41:27 <maerwald> that was again like 5h work
09:42:27 <maerwald> I gut a pretty gif
09:42:41 <yyyyy> i agree some refactoring takes time if there's new heavy type plumbing, but in general it helped me more than not.
09:42:57 <Cale> Did you start at the outset with the idea that you would need to compute all these intermediate things?
09:43:17 <maerwald> yyyyy: the point is, in other languages there is no real refactoring inolved, since effects are barely expressed at type-level
09:43:27 <yyyyy> the services we have running here with haskell usually have bugs during development, but then very little issues afterwards. the python ones blow up months later on a corner case.
09:43:38 <Cale> maerwald: Most of the tricky part there has nothing to do with IO
09:44:03 <Cale> maerwald: It has to do with pulling the algorithm apart to expose the intermediate results you're computing.
09:44:17 <yyyyy> maerwald: i think every language has its plus and cons. for maintenance i think haskell so far has been unbeaten. you pay the price upfront, though.
09:44:26 <maerwald> yyyyy: https://tinyurl.com/hh3n779 
09:44:51 <maerwald> yyyyy: sure, but this whole argument was about the fact that the cons are "learning curve" and "concept complexity"
09:45:53 <yyyyy> i disagree on the learning curve for basic programs, but there is a concept complexity IF you want to delve into it. it's not necessary in my experience, though.
09:47:12 <yyyyy> i'm not a computing scientist or engineer and write haskell for a living. in fact, i graduated as an industrial designer.
09:47:13 <buglebudabey> i want to do a list comprehension like this: [(c, f c) | c <- cs], except cs is actually a "Set a", not [a]. How can I accomplish what i want to do with Set?
09:47:16 <maerwald> Cale: yes, that's what I did and it wasn't easy
09:48:11 <nitrix> buglebudabey: You can't really, cs has to be a list to be deconstructed by the list comprehension (which desugars as a list monad)
09:48:13 <buglebudabey> is toList cs the best way to go?
09:48:20 <yyyyy> so i don't get the crazy “kan extensions” machinery and that sort of talk, but i can get by with monads, applicatives and the occasional “complex concepts”. i think it takes more effort than smarts.
09:48:28 <Rotaerk> the learning curve in haskell applies to any language's advanced features
09:48:31 <nitrix> buglebudabey: toList cs could work, but then it makes your list comprehension a little questionable.
09:48:36 <Rotaerk> it's the price of .. advanced features
09:48:39 <Cale> maerwald: Yeah, unless you translated the imperative algorithms in a particular way, it's not especially easy. One thing you can pretty much always do is to turn each point of control in the imperative algorithm into a function which computes the final result from the values of the mutable variables which are in scope.
09:48:45 <buglebudabey> nitrix how so?
09:48:57 <maerwald> yyyyy: well, I could extend my argument to "lens" to further prove my point what kind of stuff I have to learn just to get some basic accessors that don't suck, but I guess I'll refrain from that :P
09:49:02 <Cale> maerwald: and if things are written in that way, then it's easy to "just add IO"
09:49:07 <Rotaerk> C# programmers often don't bother to learn LINQ, and then they find LINQ code "unreadable", but *if* they were to learn it, they would find it to be more readable than raw loops
09:49:21 <nitrix> buglebudabey: Why not Data.Set.map :: Ord b => (a -> b) -> Set a -> Set b ?
09:49:26 <maerwald> Cale: I translated the algorithm, it's pretty functional now.
09:49:37 <yyyyy> Rotaerk: or C++ templates.
09:49:44 <Cale> maerwald: But if you're using a more abstract functional understanding of what the algorithm is, it might not have those same intermediate steps
09:49:48 <maerwald> Cale: I even wrote pseudo-code for it and a "simulation", because it's impossible to understand the code anymore ;)
09:50:03 <Rotaerk> haskell just takes the "let's do things right, at the cost of having a lot to learn" to the extreme
09:50:15 <buglebudabey> nitrix ill see if that makes more sense given the rest of the code, thanks
09:50:25 <nitrix> buglebudabey: Data.Set.map (\x -> (x, f x)) cs   or similar.
09:50:44 <nitrix> buglebudabey: Both approach are fine, it's just that you probably wouldn't want to do toList fromList back and forth too much.
09:50:53 <yyyyy> maerwald: lenses are a tough pill. i'm slowly swallowing it. using it is way easier than understanding it. the type errors though… feels like relearning haskell after years.
09:51:14 <maerwald> Cale: when I eagerly told my prof "omg, I translated this to functional", she said "oh well, I believe you, don't show me"
09:51:17 <nitrix> buglebudabey: Data.Set is a Functor so you can apply a transformation to each elements without doing any unecessary conversions.
09:51:22 <maerwald> that was really discouraging
09:51:25 <buglebudabey> nitrix i was thinking of a fold to get it into a list form as well
09:51:25 <buglebudabey> nitrix but ill see
09:51:25 <buglebudabey> nitrix thanks again
09:52:02 <maerwald> yyyyy: I'm not going to learn it because unless you write a compiler the effort and the use are in no relation.
09:52:05 <mniip> nitrix, ok what would you say about this
09:52:27 <nitrix> :: (a -> b) -> Set a -> Set (a, b)
09:52:34 <jle`> nitrix: not quite capital-F Functor, though
09:52:35 <Cale> maerwald: Meanwhile it was obvious that the lecturer we had for a CS course I took which used Java really would have liked to be teaching us functional programming instead. :D
09:52:41 <yyyyy> maerwald: i heard rust has everything you want. you can have some of the functional parts and side-effects alongside.
09:52:43 <mniip> @let instance Fun (->) (->) ((,) a) where funmap f (x, y) = (x, f y)
09:52:44 <lambdabot>  Defined.
09:52:53 <maerwald> yyyyy: yeah, I like rust
09:53:02 <maerwald> but it's not high-level, nor is it declarative
09:53:12 <mniip> @let instance Fun (->) (Nat (->) (->)) (,) where funmap f = NT $ \(x, y) -> (f x, y)
09:53:13 <lambdabot>  .L.hs:195:20:
09:53:13 <lambdabot>      Not in scope: data constructor ‘NT’
09:53:13 <lambdabot>      Perhaps you meant one of these:
09:53:17 <mniip> @let instance Fun (->) (Nat (->) (->)) (,) where funmap f = Nat $ \(x, y) -> (f x, y)
09:53:18 <lambdabot>  Defined.
09:53:19 <maerwald> it's perfect for writing a "file manager" probably
09:54:32 <nitrix> buglebudabey: jle` Fine, a functor, not a Functor. Because the elements have to remain unique, it'd break Functor laws I think.
09:54:34 <maerwald> or a game engine... someone implemented minecraft in rust
09:54:55 <nitrix> Or sorry, the Set semantics, not the functor laws.
09:55:07 <nitrix> Interested, I never noticed.
09:55:47 <mniip> > funmap (+1) (3, 5)
09:55:48 <lambdabot>  (3,6)
09:55:55 <mniip> > runNat (funmap (+1)) (3, 5)
09:55:57 <lambdabot>  (4,5)
09:56:15 <mniip> it's functors all the way down
09:56:30 <nitrix> Then turtles.
09:57:14 <hellofunk> i thought that argument only applied to the classic lisp machines! it's lisp all the way down!
09:57:39 <Profpatsch> It’s lambdas all the way down, until it isn’t anymore.
09:58:41 * hackagebot type-natural 0.4.1.1 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.4.1.1 (HiromiIshii)
10:21:52 <dalastboss> I'm having an issue where running "stack test" fails with an error saying the executable was not found
10:21:59 <dalastboss> has any one had this problem before?
10:22:37 <dalastboss> A google search reveals some discussions on github where this problem was supposedly fixed
10:22:47 <dalastboss> But the problem has persisted even after updating stack
10:23:19 <dalastboss> this is the project in question
10:23:24 <tdammers> which executable?
10:23:28 <dalastboss> https://github.com/zachhalle/hudson
10:23:42 <dalastboss> it says "hudson-test: executable not found"
10:24:18 <tdammers> have you added ~/.local/bin to your path?
10:24:30 <tdammers> does the hudsonc executable work?
10:25:02 <tdammers> also, does stack test actually build the test suite, or does it only attempt to run it? My usual incantation is stack install --file-watch --test
10:25:08 <tdammers> that builds, installs, and tests everything
10:25:55 <iphy> where would I best put my Arbitrary instances for quickcheck?
10:26:01 <iphy> for the types in my library
10:27:12 <tdammers> iphy: in theory, since you don't control the QuickCheck library, they would have to go in the same modules where the types are defined in order to avoid orphan instances
10:27:27 <iphy> that's what I have right now
10:27:38 <tdammers> iphy: but in practice, I think this is one of the cases where orphan instances are OK, and they should go somewhere in your test suite instead
10:27:54 <tdammers> because you never use them outside of that
10:28:11 <iphy> but I can imagine that for some types that would create cyclic dependencies, because you may have some functions generating values of the type elsewhere
10:28:24 <tdammers> OTOH, if your project is a library, the Arbitrary instances might come handy for testing other code that depends on it - then you'll get consistent instances across projects
10:28:38 <tdammers> I'd say apply taste
10:28:40 <iphy> I don't have that much, but I have a type called "CipherText" and a "PlainText" type, and a separate module that translates one to the other
10:29:01 <tdammers> sorry, gotta go
10:29:29 <iphy> I could either put those types into the crypto module that does the translation, or generate fake ciphertexts (requiring knowledge of how long a ciphertext must minimally be, which is 16 bytes), or make orphan instances
10:29:40 <iphy> I would really like to keep the arbitrary instances in the library itself
10:30:39 <dalastboss> problem resolved -- didn't realize main had to be in a module called Main
10:33:52 <fr33domlover> it doesn't...
10:33:58 <fr33domlover> afaik could be any other name
10:34:27 <fr33domlover> the point is to have a name (at least if the project is more than one module?)
10:36:52 <geekosaur> main has to be in Main, or in the module identified by ghc's -main-is option
10:37:08 <geekosaur> (which can also specify a different name instead of "main")
10:37:39 <geekosaur> note that the cabal main-is: is slightly different from ghc's option
10:50:48 <lol-icon> sclv: I must apologize. Yesterday I was just drunk and badly trolling. But let me see if I understand your argument correctly: Are you saying that case-analyzing on types in Haskell doesn't break parametricity because the phase distinction keeps such case analysis confined to the type level?
10:52:42 <sclv> lol-icon: something like that. tbqh it confused me too at first since i thought that "obviously casing on * destroys parametricity".
10:52:54 <sclv> but i tried to work through examples and it didn't
10:53:20 <sclv> i think the reason is as simple as "to case on * you need a typeclass constraint. once you have typeclass constraints you've already put yourself in a non-parametric context"
10:53:38 <hpc> or (Either Foo Bar)
10:53:56 <hpc> something that makes it visible in the type that some kind of case is possible
10:54:12 <sclv> GADTs can sort of screw up parametricity in interesting ways but its more complicated
10:54:25 <lol-icon> sclv: Yes, I can see the point, but that would mean that the language wouldn't survive the addition of actual dependent types.
10:54:38 <sclv> i'm not sure i can follow how that would work
10:55:45 <sclv> the issue with GADTs is more that on a _particular data type_ "Foo a" you might be able to perform nonparametric actions on it, casing on the "a"
10:56:19 <hpc> sort of
10:56:23 <sclv> if you expanded out that GADT though into a plain type with embedded type equality dictionaries then the issue sort of vanishes
10:56:30 <sclv> its almost an optical illusion
10:56:50 <sclv> that relates to fibrational semantics vs "classical initial semantics"
10:56:52 <lol-icon> What I *really* dislike is that this gives a finer-grained notion of type equality than isomorphism.
10:57:05 <hpc> if you have data Foo a where Any :: a -> Foo a; IntFoo :: Int -> Foo Int
10:57:06 <sclv> i wouldn't say its finer-grained. its competing.
10:57:25 <hpc> you don't really lose parametricity by casing on IntFoo because you could always get (Any 5) anyway
10:58:41 <sclv> hpc: but if I don't have the equality constraint embedded, I have the property that modulo bottom any function "forall a. Foo a -> Foo a" is id
10:58:48 <sclv> and if I do have it, it could case on the int and say add 1 to it
10:59:30 <sclv> but again if you expand out Foo into a "flat" data type with embedded dictionaries it becomes obvious why and the problem disappears
10:59:55 <hpc> i am not really sure how you would be able to say the only inhabitant of that type is id anyway, at least not generally
11:00:17 <hpc> consider Foo a = Either a a, it might flip the constructors
11:00:26 <sclv> oh good point, that was sloppy of me
11:00:33 <sclv> the right example is fmap
11:00:56 <sclv> or erm... nvm that could flip constructors too
11:01:10 <sclv> anyway, examples do exist :-)
11:01:18 <hpc> heh
11:02:22 <hpc> if you can construct an example i would be interested in seeing it
11:02:33 <sclv> the original still holds -- you just need a weaker claim than "is id"
11:02:52 <hpc> i quite like GADTs from the perspective of programming, but on the theoretical side i am not quite a Bad Enough Dude
11:03:08 <sclv> effectively a way to formulate "doesn't touch the values of type a"
11:03:30 <hpc> ah
11:03:43 * hackagebot algebraic-classes 0.7 - Conversions between algebraic classes and F-algebras.  https://hackage.haskell.org/package/algebraic-classes-0.7 (SjoerdVisscher)
11:03:50 <sclv> We can mother Either a a as (Bool, a)
11:03:53 <hpc> okay, that makes more sense then
11:03:54 <sclv> s/mother/model
11:04:13 <hpc> with Either, you get that property because you can mess with the left all you want but not the right
11:04:16 <sclv> that was a heckova typo
11:04:25 <hpc> with Foo, you can do foo (IntFoo 5) = Any 17
11:05:19 <hpc> i don't know if that's a parametricity issue, but i don't know of a formal enough definition that i can actually say it isn't
11:05:24 <hpc> someone else will have to comment on it
11:05:39 <sclv> right -- stating that formally is a bit tricky, but there's a clear argument that "things you can say about all datatypes that don't have equality constraints > things that you can say about all datatypes including equality constraints"
11:07:03 <hpc> yeah
11:07:17 <hpc> i am fairly convinced that it breaks some assumptions a programmer would want to have, in any event
11:08:07 <sclv> lol-icon: in any case, i'd be curious if you could come up with a good argument about issues with dependent types. i'm not sure i see them at the moment. that would be useful to think through....
11:08:16 <sclv> bearing in mind tho that most dt theories don't have internal parametricity
11:13:00 <lol-icon> sclv: Damas-Milner is a subset of System Fω whose type language is kept first-order for type inference's sake. I'm working on a DM-like subset of the CoC: types can depend on runtime values, but types constructors can't be higher-order functions. In particular, type synonyms are just normal functions satisfying an additional syntactic restriction. If type synonyms could case-analyze types, then that would mean that normal functions can
11:13:00 <lol-icon> do so as well.
11:13:30 <lol-icon> sclv: So your basic argument that “the phase distinction keeps the evil confined to the type level” wouldn't work in that setting.
11:13:44 * hackagebot heckle 2.0.0.3 - Jekyll in Haskell (feat. LaTeX)  https://hackage.haskell.org/package/heckle-2.0.0.3 (2016rshah)
11:13:46 * hackagebot haskintex 0.7.0.0 - Haskell Evaluation inside of LaTeX code.  https://hackage.haskell.org/package/haskintex-0.7.0.0 (DanielDiaz)
11:18:22 <joe9> need some help, please?
11:18:24 <sclv> lol-icon: ah i see, so this is not adding DT as per the current plan for GHC, but in a generally DT system where we interpret type families directly as functions
11:18:31 <joe9> *Main> :t (\l -> term "tspan" [id_ (pack l)] undefined) :: String -> Svg () =====> (\l -> term "tspan" [id_ (pack l)] undefined) :: String -> Svg () :: String -> Svg ()
11:18:37 <joe9> But, what I actually want is:  :t (\l -> term "tspan" [id_ (pack l)] l) :: String -> Svg () === replaced the undefined above with l
11:18:52 <sclv> but still i'd like you to provide me with a term that exhibits this problem
11:18:54 <joe9> This is with using the Lucid.Svg  package.
11:19:07 <joe9> Is there a way to convert the String -> Svg () ?
11:19:28 <joe9> I tried return l , but that would not fly. *Main> :t (\l -> return l >>= term "tspan" [id_ (pack l)] ) :: String -> Svg () === does not typecheck
11:19:42 <nitrix> Hey.
11:20:05 <nitrix> Given I wrote my own Game monad for my game which allows some IO but not all IO, how would I enforce this?
11:20:06 <joe9> trying this: *Main> :t term "tspan" [id_ (pack undefined)] _ :: Svg () ==> Found hole '_'      with type: Lucid.Base.HtmlT Data.Functor.Identity.Identity ()
11:20:20 <nitrix> Its own module and I never export the constructor ?
11:20:35 <hellofunk> does it haskell automatically memoize all functions?
11:20:43 <sclv> Like, I guess, Pi_(t : Type) (t -> t) could have many possible inhabitants
11:21:01 <nitrix> hellofunk: Not all.
11:21:01 <sclv> sure
11:21:02 <kadoban> hellofunk: No. It'd take too much memory in general.
11:21:15 <joe9> fromString helped fix my issue.
11:21:44 <hellofunk> i'm watching a video where he said that memoization was a nice feature of the language that falls out of laziness
11:21:52 <sclv> its sound, but you lose reasoning. I buy it.
11:22:35 <nitrix> hellofunk: Boxed values theorically allow all of them to be memoized but in practice, the compiler will only leverage memoization in cases where something is used twice in a situation where other optimization don't interfere.
11:23:30 <lol-icon> sclv: It indeed has many possible inhabitants. Unlike ∀, which creates a type scheme, which can only be instantiated by substituting its type variables (but no runtime computation), Π creates a monotype of dependent functions, and the only thing you can do with such functions is apply them (or pass them around). Incidentally, the distinction between ∀ and Π is the solution for getting rid of ML's annoying value restriction.
11:23:44 * hackagebot vectortiles 1.2.0 - GIS Vector Tiles, as defined by Mapbox.  https://hackage.haskell.org/package/vectortiles-1.2.0 (fosskers)
11:24:28 <sclv> lol-icon: right. when we add "DTs" (in some form) to GHC I definitely think that those in particular shouldn't pattern match on the universe
11:25:34 <dcoutts_> hellofunk: the rule is: for an expression bound to a variable, that expression will be evaluated (to WHNF) at most once.
11:26:11 <mniip> except that inlining and CSE changes what is bound and what is not
11:26:17 <dcoutts_> hellofunk: so informally you can think of it being named values that are memoised, but not functions
11:27:29 <dcoutts_> mniip: afaik, ghc does not in general violate this property in any observable way
11:29:23 <sclv> right -- but if you use evil accursed unsafe dupable perform io
11:29:25 <sclv> you can see it :-)
11:29:29 <buglebudabey> can someone give me the most up to date data.hashmap.lazy, i think google is giving me dead or non-existant pages
11:29:48 <buglebudabey> link to hackage*
11:29:53 <dcoutts_> buglebudabey: it's on hackage in the containers package
11:29:54 <sclv> buglebudabey: http://hackage.haskell.org/package/unordered-containers
11:29:57 <sclv> just go to the top level
11:30:02 <dcoutts_> erm yes, unordered-containers
11:30:34 <buglebudabey> thanks
11:30:40 <maerwald> wow, I needed to add 3 ghc extensions to make my project work with latest diagrams
11:31:15 --- mode: ChanServ set +o dcoutts
11:31:16 --- mode: ChanServ set -o dcoutts
11:31:23 <dcoutts> (just checking)
11:48:34 <sinelaw> recommended parser library, please!
11:48:42 <sinelaw> non-monadic
11:48:51 <sinelaw> (i.e. applicative, I guess)
11:49:04 <erisco> Parsec
11:49:15 <bennofs> sinelaw: why non-monadic?
11:51:11 <erisco> attoparsec is good if you're only parsing strings or text or bytes and do not require any diagnostic errors
11:51:49 <erisco> i.e. don't expect anything other than "it didn't work"
11:51:54 <buglebudabey> sinelaw you can do non-monadic parsing with happy
11:52:08 <jle`> sinelaw: what do you consider non-monadic yet applicative?  any monadic parser library can be used in applicative style
11:52:35 <ertesx> sinelaw: attoparsec (low-level/protocols), megaparsec (high-level/text grammars), trifecta (high-level with detailed diagnostics)
11:52:47 <ertesx> sinelaw: if in doubt, pick megaparsec
11:52:59 <erisco> what is the difference between megaparsec and parsec?
11:53:38 <ertesx> erisco: https://github.com/mrkkrp/megaparsec#megaparsec-and-parsec
11:53:41 <geekosaur> bug fixes, better integration with Control.Applicative (instead of reimplementing much of it because it predates Applicative)
11:54:55 <erisco> ertesx, sounds good then
11:56:23 <erisco> now we just have to dig up a megaparsec vs trifecta page
11:56:25 <dmwit> sinelaw: regex-applicative is great if you don't need monadic
11:56:34 <sinelaw> thanks
11:56:51 <erisco> and if you only need regular language
11:56:59 <dmwit> sinelaw: And doesn't have any of the problems the other ones do with having to be careful about how you construct your grammar.
11:57:16 <sinelaw> dmwit, left recursion?
11:57:33 <dmwit> sinelaw: No recursion at all. ;-)
11:58:15 <erisco> I don't think regex applicative has any diagnostics either
11:58:32 <dmwit> That is true.
11:59:38 <dmwit> sinelaw: Anyway, what I meant by that is that `(char 'a' *> foo) <|> (char 'a' *> bar)` is no problem in regex-applicative, where's it often requires the insertion of `try` or similar in other choices.
11:59:49 <dmwit> s/where's/whereas/
12:00:19 <erisco> well, trifecta doesn't have the wealth of documentation megaparsec does, so that's an easy decision
12:00:35 <dmwit> ...or refactoring your grammar to `char 'a' *> (foo <|> bar)`, which can be harder than you might guess in real-world examples.
12:00:51 <x1f577> Any tips for writing the absolute minimum amount of code required to solve arbitrary problems? General practices would be appreciated
12:00:55 <erisco> sinelaw, what kind of problem are you trying to solve? are diagnostics relevant?
12:01:08 <erisco> do you need left recursion? do you need ambiguous grammars?
12:01:20 <erisco> do you need indexed grammars? where are we on the spectrum here
12:02:44 <erisco> x1f577, think about the problem abstractly to tease out the distinct concepts
12:03:09 <erisco> x1f577, you'll make a confusing mess many times over, but continue trying
12:03:51 <erisco> x1f577, eventually you will reach a clarity and simplicity. Now you can begin the task of mapping your abstract ideas to a programming language such as Haskell
12:04:49 <erisco> x1f577, a mistake is to involve yourself with irrelevant intricacies of a computer language
12:05:16 <Cale> x1f577: This problem is undecidable, because it's undecidable whether a given piece of code implements a solution to an arbitrary problem.
12:05:20 <Cale> :D
12:05:45 <Cale> Otherwise, you could just enumerate all programs, starting with the small ones, until you found the minimum one.
12:06:09 * Cale takes a very different approach to the question
12:06:12 <erisco> but how can you then capture computational ideas without a programming language? I suggest learning Lambda Calculus
12:07:34 <Cale> x1f577: What's your actual goal? Are you really just golfing?
12:07:35 <erisco> denotative design is also appealing but I've had a difficult time with this
12:08:02 <Cale> Or does "absolute minimum" actually just mean "reasonably small"?
12:08:37 <jle`> x1f577: yeah, absolute minimum amount of code might actually be a bad goal to strive for
12:08:52 <erisco> I interpreted this as "simplicity"
12:08:58 <jle`> when you strain to make your code as short as possible you can make code unreadable and unmaintainble
12:09:04 <jle`> if you push it past what's reasonable
12:09:10 <erisco> a simplicity that is not necessarily seen in the chosen language of implementation either
12:10:00 <jle`> hm yeah, "absolute minimum" sort of sounds like they want to push the boundaries and make small amounts of code even smaller
12:10:09 <jle`> might be worth clarifying
12:10:14 <erisco> I'm talking about the long path to distill and refine a cloudy idea, which can be an effort over many months or years
12:10:23 <Cale> We're not even sure x1f577 is still here at this point :P
12:10:24 <erisco> so it is not appropriate to all problems
12:11:21 <ertesx> x1f577: the thing that makes you write short code is experience…  i don't think there is any other way
12:12:31 <erisco> the easiest way to write a great program is to have already written it before
12:13:06 <ertesx> and haskell may not be the language of choice for shortest possible code
12:13:17 <avalokite> how is having a program already written in any way writing a program?
12:13:23 <ertesx> you probably need something like APerL
12:13:54 <erisco> avalokite, you will encounter similar problems many times over
12:15:14 <avalokite> having been in software for maybe 10 years, I've never encountered this problem.. generally, you need to write a program by actually sitting down and writing it, not googling for programs already written (though that may help for some solutions you're for whatever reason unable to invest in writing yourself)
12:15:37 <avalokite> I may totally be misunderstanding you though
12:15:49 * avalokite apologises
12:15:56 <Cale> avalokite: erisco is referring to the case where you're writing code which solves a problem that you've solved with other code before
12:16:10 <Cale> i.e. your program does the same thing, but in a different way
12:16:17 <erisco> I was echoing ertesx's message about experience
12:18:02 <x1f577> He is
12:18:34 <x1f577> Chppy intwrwebs
12:27:21 <monochrom> beginners tend to create more complicated, contrived solutions. (in any subject.)
12:28:21 <monochrom> for example http://xkcd.com/763/
12:32:12 <erisco> we can make assumptions without realising it, either because it is under our radar or because we are not open to alternatives
12:37:57 <erisco> at a time all my thoughts about computing were conceived in PHP
12:38:47 * hackagebot pusher-http-haskell 1.1.0.0 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-1.1.0.0 (willsewell)
12:38:54 <erisco> you can imagine the limitations that has for clear thinking
12:39:09 <maerwald> vaibhavsagar: very interesting talk, but it's also basically an advertisement for his non-free learning material ;)
12:39:09 <avalokite> erisco: I feel this way about the english language quite often :(
12:39:20 <erisco> when solutions are conceptualised in terms of magic methods
12:40:57 <tdammers> erisco: or not conceptualized at all, people just write something down that they think might be close enough, and then they change it until it outputs what they want
12:41:29 <erisco> that is a familiar and dark place to be
12:42:21 <avalokite> tdammer and erisco, might you have recommendations for breaking this pattern?
12:42:25 <erisco> where you've surrendered hope of understanding but not desperation
12:42:36 <Rotaerk> isn't that called "Test driven development"?
12:42:37 <Rotaerk> *cough*
12:42:56 <tdammers> no, but TDD rules can be applied maliciously to get to the same result
12:43:00 <erisco> I am particularly poor with numerical problems and sometimes find myself trying random things with my fingers crossed
12:43:00 <avalokite> Rotaerk: There's usually specifications for that kind of thing
12:43:34 <avalokite> erisco: as I recall, much differential geometry is the same way
12:43:47 * hackagebot hext 0.1.0.3 - a text classification library  https://hackage.haskell.org/package/hext-0.1.0.3 (aneksteind)
12:43:57 <tdammers> normally, with TDD, the idea is that you design your program using whichever methodology, and then you write down the specifications in the form of test cases
12:44:23 <tdammers> and then you add one of those test cases, confirm that it fails, write code to make it pass, and then remove redundancy
12:44:36 <tdammers> the "write code to make it pass" isn't random
12:45:02 <tdammers> you just do it within a rigid harness of unit tests that alert you as soon as you break anything
12:45:03 <erisco> avalokite, first you must become fully aware of your simultaneous commitment to non-understanding and desperation
12:45:23 <avalokite> erisco: ah, the great filter!
12:46:15 <erisco> avalokite, indeed :)
12:48:36 <zlens> is there somethign like https://www.dailydrip.com/topics/elixir/drips/enum-part-3 but for haskell?
12:48:52 <zlens> I'm willing to pay for something where someone has produced 5-10 min segments on how to do cool things with haskell
12:48:55 <zlens> and I just follow along
12:51:16 <erisco> there are written materials with this format
12:51:20 <bitemyapp> hrm
12:51:29 <zlens> I like videos / audios
12:51:36 <bitemyapp> zlens: is it because you want snippets or bec---that answers my question
12:51:37 <zlens> somehow watching someone else type / listening to them talk helps me learn better
12:51:49 <avalokite> what if the commentaries/narratations were written? :o
12:52:11 <zlens> avalokite: depends on the quality of text->speech engine
12:52:22 <avalokite> you mean, your own voice?
12:52:30 <zlens> but honestly, so with the dailydrip, there's (1) the video and (2) text below which explains things and also shows what is typed
12:52:30 <x1f577> erisco: thank you!!
12:52:46 <avalokite> You could speak what is written aloud and develop your comprehension skills instead of merely mimicing people
12:52:55 <avalokite> personalized learning for all! :D
12:52:59 <zlens> I found that if I try to follow the text below, I end up speed reading / not trying everything
12:53:11 <zlens> whereas, with the video, I watch th eprson do somethign; I pause it, I try it msyelf, etc ...
12:53:26 <tdammers> I find videos very cumbersome for learning
12:53:31 <zlens> I realize there's probably not somehting free that does this; but I'm willing to pay for it
12:53:43 <avalokite> zlens: take your time. Kind of like playing the piano, you must take your time and not rush, otherwise everything becomes nonsense and hard to recollect.
12:53:53 <avalokite> Learn to speak
12:53:58 <avalokite> Learn to comprehend
12:54:11 <avalokite> You have time :)
12:54:30 <erisco> that is interesting that you find video and audio so compelling. I suspect that is not popular, but not invalid either
12:54:47 <erisco> I am not aware of any resources like this for Haskell but clearly someone should get on it
12:55:18 <avalokite> zlens can produce it for everyone! :)
12:55:36 <zlens> erisco: I used to dislike audio/video .. until I tried dailydrip (beucase I was struggling with the elixir books)
12:55:40 <zlens> and BAM, it somehow clicked for me
12:55:52 <tdammers> erisco: lots of people like video tutorials and the like
12:56:07 <tdammers> I don't, but apparently it works well for many
12:56:18 <avalokite> ReinH talks about haskell and that could be very helpful, but he doesn't actually speak about lines of code, line by line, as a tutorial. Surely something like this exists academically, though as an online tutoring service, perhaps very few are about
12:56:18 <erisco> tdammers, I implicitly was referring to the Haskell community, but I may be mistaken here too
12:57:15 <erisco> they have Elm? XD
12:57:22 <zlens> you know what would be even better? [perhaps this is impossoble
12:57:34 <avalokite> something that doesn't yet exist? :O
12:57:34 <zlens> owuld be ifk for each package on hackage, there was a video of the author developing it line by line
12:57:41 <zlens> walking us through how it's implemented
12:57:46 <zlens> that'd be amazing
12:58:02 <avalokite> zlens: isn't that what the type signatures are for?
12:58:05 <erisco> well, the implementation should be largely irrelevant, but they could walk through how you use it
12:58:17 <maerwald> the problem with video stuff is, it's harder to embed proper exercises, at least if you do stuff on youtube
12:58:25 <maerwald> it would have to be a proper platform that's designed for it
12:58:51 <zlens> avalokite: maybe if we had dependent types, the type sigs would be enough; but given current types, I'm not convinced
12:59:46 <zlens> avalokite: for example, using the type sig, please tell me what is going on in https://github.com/reflex-frp/reflex/blob/develop/src/Reflex/Spider/Internal.hs#L524-L566 :-) [not picking on this, this is one of my favorite haskell libs]
13:00:09 <avalokite> zlens: may follow that reading the documenation aloud may render an understanding of the code comprehensible. At least, this is how I've come to explain to those who how to learn how things work
13:00:12 <erisco> using the type sig, determine what any function which returns a list does
13:00:54 <zlens> maerwald: one of the things the dailydrip guy has done right is everything so far is either (1) trying it right out in iex (equiv of ghci) and (2) for modules, he (a) writes a unit test first, which fails, then (b) implements it -- so it's easy to follow along even though there isn't a platform -- I think similar things can be done in haskell via ghci + unit testing
13:01:30 <erisco> what if I find TDD a sham?
13:02:18 <zlens> erisco: then this would probably not be the right learning resource for you
13:02:18 <erisco> heh, I suppose not
13:02:21 <avalokite> zlens: err, that's a little more than purely the type signature.. What I mean is you geet a pretty idea of what's to happen while following the construction of the program. I agree, there really needs to be some kind of commentary explicating exactly what the intent of this and that is.
13:02:26 <erisco> I was just thinking of the small effort it would be to produce a 5 minute video
13:02:49 <osfameron> producing video is never a small effort :-)
13:03:29 <erisco> you're limiting yourself to 5 minutes of content
13:03:42 * osfameron just got an offer to produce some... I'm thinking of multiplying the time taken by around 10
13:03:52 <osfameron> so ok, for 5 minutes, you'd say that'd be just 50 minutes to prepare
13:03:53 <avalokite> Watching a video and pausing it every few seconds seems like so much more effort than actually reading a videos transcripts.. Unless theirs smoking hot women in it of course :)
13:04:02 <osfameron> but I suspect that's on the optimistic side
13:04:10 <erisco> osfameron, maybe once you're in the swing of things, yeah
13:04:55 <erisco> avalokite, do you not find the writing seductive?
13:05:18 <avalokite> The writing of the documentation? The programs? or the video?
13:05:48 <avalokite> Whatever allows us to learn from our speech seems seductive enough or me to go ahead and learn! :D
13:05:48 <maerwald> avalokite: it depends. Once I had a prof who was drawing while explaining, stopped, did stuff again and explained why and so forth. That's hard to do with just static text.
13:06:30 <osfameron> what zlens mentioned up there (author explaining how they developed the library) sounds very much like Andre Stalz's videos on cyclejs: https://egghead.io/courses/cycle-js-fundamentals
13:06:34 <osfameron> those are awesome
13:06:48 <avalokite> maerwald: oh I agree entirely! Now, what you're describing is what many would call teaching. What zlens describes from TDD is merely commentary on what's clearly written.
13:06:55 <osfameron> but I shudder to think how long it took to make those
13:07:00 <zlens> WHOA
13:07:02 <zlens> WAIT
13:07:06 <zlens> someone wrote a frp framework in js
13:07:12 <zlens> and then produced a set of videos explaining how it was built?
13:07:34 <erisco> there are many libraries in JavaScript misnamed as FRP, yes ;)
13:07:41 <osfameron> yeah.  they're really good.  and cyclejs is just simple enough that while he's explaining it, it makes Perfect Sense
13:07:49 <erisco> baconjs, rxjs, and I am sure dozens more
13:07:50 <osfameron> (I can't remember details any more of course...)
13:07:54 <zlens> osfameron: thi is so worth it
13:08:03 <zlens> I'm glad I brought this elixir issue into haskell :-)
13:08:19 <zlens>  ## haskell :: elixir vidcast -> js vidcast
13:08:35 <avalokite> zlens: would you mind producing some videos for future generations?
13:08:54 <zlens> avalokite: you over estimate my technical abilities
13:09:06 <zlens> I could probably produce a series of videos on how to ask questions on #haskell and wastte people's time
13:09:21 <avalokite> zlens: I've yet to estimate your technical ability. I do foster your creative impetus however. :)
13:10:01 <avalokite> Furhter, I encourage you to try. You'll learn quite a bit about yourself, and develop much more quickly than you may have considered. :D
13:10:34 * osfameron hadn't heard of dailydrip
13:11:05 <osfameron> I'm looking at doing something with Packt, who say they syndicate to all kinds of places, but don't mention that in their list
13:12:03 <osfameron> ah, it looks quite "boutique" ;-)
13:12:04 <erisco> I spend a lot of time shedding my ignorance on others, under the guise of "helping" ;)
13:12:28 <avalokite> as long as someone benefits, no problem :D
13:13:28 <bitemyapp> osfameron: don't work with Packt if you can help it.
13:13:37 <dmwit> osfameron: For what it's worth, Packt has contacted me several times and didn't seem particularly... legitimate.
13:13:48 <maerwald> erisco: I've met some people in the opensource community who are _seriously_ trolling with their superior knowledge and still somehow manage to educate ppl :D
13:13:48 * hackagebot PPrinter 0.0.2 - A derivable Haskell pretty printer.  https://hackage.haskell.org/package/PPrinter-0.0.2 (iamzhenyi)
13:13:59 <maerwald> not saying that's what we should be doing, but yeah
13:13:59 <Welkin> bitemyapp: 很久不见了
13:14:10 <bitemyapp> osfameron: they will not help you publish something you can be proud of, they publish a lot of junk with no editing. Publishing with them will not make you look good. Shop the idea to O'Reilly, Manning, or No Starch.
13:14:16 <avalokite> maerwald: are you describing a great majority of freenode? :p
13:14:22 <bitemyapp> Welkin: hi
13:14:45 <bitemyapp> that came out better in the translation than I expected
13:15:13 <Welkin> haha
13:16:17 <avalokite> osfameron: this Cycle.js tutorial is nice. I feel it's far too slow to digest though.. *sigh*
13:17:15 <avalokite> Show me a readme, and it all makes sense. Now, I can see an introductory as to how Cycle.js works, it's purpose, history, design, etc being immediately helpful, but as it is, the tutorial aspect is far too longwinded.
13:18:16 <avalokite> If we had to give a 5 minute presentation on each library, how could we best describe how it works assuming you have knowledge of the how-to write code? 
13:25:47 <zlens> we need to add speech-recognition to ghc, so that a function won't type check unless you also provide audio explaining how it's implemented
13:27:16 <avalokite> Why exactly do we /need to add/ speech recognition to GHC? 
13:27:32 <pharaun> no
13:27:39 <dfeuer> Audio? WTF?
13:27:39 <pharaun> no speech recogniation plz
13:27:56 <hpc> ghc just needs an ai that can be trained to recognize speech on its own
13:28:58 <Welkin> ghc needs a vocaloid that sings and dances while it compiles
13:29:12 <Welkin> and tells you the compile errors by singing
13:29:20 <zlens> the lyrics need to also explain how the functions work
13:31:21 <avalokite> Welkin: honestly, I've thought about that... ._.
13:32:44 <hpc> coming soon to ghc: http://www.text2speech.org/FW/getfile.php?file=e85689c7d440e23065363071a35a5749%2Fspeech.mp3
13:33:07 <avalokite> probably however was that I was unable to use vocaloid as a standalone vst (though the cubase extension may help with that if I ever get around to buying it)
13:33:42 <avalokite> s/probably/problem/
13:33:49 * hackagebot these 0.7.1 - An either-or-both data type & a generalized 'zip with padding' typeclass  https://hackage.haskell.org/package/these-0.7.1 (phadej)
13:33:53 <Adeon> speech recognition is coming right after e-mail functionality is in GHC
13:34:10 <osfameron> dmwit: bitemyapp: yeah, that's my impression with their book format work.  They seem to have invested more into their video platform though, and the guy I'm in touch with seems reasonably clued up
13:34:22 <avalokite> lmao... Adeon ;')
13:34:29 <Adeon> and after that social media integration
13:35:01 <erisco> share your type error on Twitter
13:35:48 <avalokite> Admittedly, that type of thing may help resolve issues in an totally unprecedented manner. But.... Just read the code!
13:35:52 <zlens> whoa, that may get you banned for hate speech for triggering dyanmic language users
13:36:30 <osfameron> avalokite: yeah, I often get impatient with video.  But with the cyclejs stuff, as I was quite new to the reactive idea, and the presentation was very slick, it worked for me
13:37:29 <erisco> oh, interesting, they call it "functional and reactive"
13:37:49 <osfameron> bitemyapp: fwiw, if I do go ahead with it, I got them to strike out the "my next 2 works belong to you" deal, so if it works out, pitching to O'Reilly for my *next* piece would be part of my masterplan :-)
13:38:26 <erisco> and then they say 'Functional means “clean”, and Reactive means “separated”.'
13:38:29 <avalokite> osfameron: in my mind, what is being said is "Here's the code. Here's what the code is in english, and here's what the code is in the language, and here's the code working in english, and here's the code working in the language, and here's what the code says analogously in english, and here's what the code says in the language, and here's the code......" starts to numb the brain
13:38:32 <erisco> mkay
13:38:45 <avalokite> erisco: also noticed that... 
13:39:03 <avalokite> oversimplified generalizations can be very misleading
13:39:08 <Khudher> do they people who created haskell exist in this channel?
13:39:09 <Khudher> just wondering lol
13:39:11 <hpc> erisco: but do they diagonalize the asynchronous threads?
13:39:30 <osfameron> oversimplified generalizations can also be an absolutely necessary part of the learning process
13:39:32 <Welkin> Khudher: usually no
13:39:50 <erisco> I wonder why they didn't make their tagline "A clean and separated JavaScript framework for cleaner code" then
13:40:03 <erisco> must not be referentially transparent or something
13:40:07 <osfameron> the way as you study, say, Chemistry through school, you realise that everything you learnt the previous year was basically untrue ;-)
13:40:24 <Welkin> erisco: because isomorphic <more CT words that don't apply at all>, webscale, non-blocking, FRP javascript is the new fad
13:40:58 <hpc> osfameron: i hate that
13:41:26 <avalokite> A great and valuable lesson is "managing your time effectively" should then be introduced? idk, there's better ways to learn things than to teach fiction. Give a real experience. Some someone cannot break through, find a tutor who can personally work with you.
13:41:30 <hpc> your understanding stays right near zero instead of converging on an accurate view of the world
13:41:52 <hpc> the only thing that evenly converges is how close your calculations are to physical reality
13:42:17 <hawk78> Hi, I wrote this blog ( http://hawkcode.blogspot.it/2016/07/haskell-how-not-to-oveload-type-classes.html ) post and tried posting it on reddit, but It is not showing. Who I can ask? Who are the moderators?
13:42:17 <hpc> it feels like you're just guessing why an experiment did what it did
13:42:42 <Welkin> hawk78: this isn't reddit
13:42:46 <osfameron> hmm, I suspect it depends on how good your teachers are
13:43:07 <ertesx> FRP in JS isn't really new
13:43:13 <osfameron> certainly, I didn't continue chemistry beyond age 16... but my friends who did A-level, then degree, the masters, then PhD basically had that experience at every step :-)
13:43:25 <ertesx> flapjax is the oldest example i know of, and you can do FRP with bacon.js, if you're careful
13:43:30 <hawk78> BTW: My blogpost asks a question about typeclasses... 
13:44:08 <avalokite> osfameron: from orbitals to probability density functions - There and back again: A tale by Bilbo Baggins
13:44:10 <geekosaur> osfameron, pretty much. flip side is that "lies-to-children" often work pretty well in chemistry up to a point, so you don't have to sweat the deeper details for many things
13:44:16 <hawk78> Welkin: I know, but mybe one of the moderators is around here
13:44:22 <giantoctopus> Hey folks, I have a question about eta conversion.
13:44:37 <giantoctopus> I have code that converts a string to WeIrDcAsE
13:44:40 <giantoctopus> ```
13:44:42 <giantoctopus> processWord' :: String -> String
13:44:42 <giantoctopus> processWord' word =
13:44:44 <giantoctopus>   zipWith (\x y -> x y) (cycle [toUpper, toLower]) word
13:44:48 <geekosaur> urgh
13:45:01 <avalokite>  http://lpaste.net/new/haskell
13:45:04 <geekosaur> pasting into the channel is not a good idea
13:45:06 <geekosaur> @paste
13:45:06 <lambdabot> Haskell pastebin: http://lpaste.net/
13:45:08 <giantoctopus> sorry
13:45:31 <giantoctopus> http://lpaste.net/172590
13:45:37 <ertesx> giantoctopus: (style note:  zipWith ($))
13:45:50 <osfameron> geekosaur: exactly.  it's not lies with intention of misleading, but lies to allow the student to understand what they can *right now*
13:46:00 <giantoctopus> ah, that's what I was looking for
13:46:11 <giantoctopus> application operator
13:46:16 <giantoctopus> thanks @ertesx 
13:46:20 <erisco> giantoctopus, wait a minute
13:46:28 <erisco> giantoctopus, you were on the right track actually
13:46:37 <erisco> giantoctopus, \x y -> x y  eta reduces to  \x -> x
13:46:44 <erisco> giantoctopus, and what is \x -> x? id!
13:46:58 <giantoctopus> no no @erisco, x is a function
13:47:00 <ertesx> giantoctopus: meaning that ($) is in fact 'id'
13:47:06 <giantoctopus> so I need to apply x to y
13:47:08 <ertesx> giantoctopus: that doesn't matter
13:47:11 <ertesx> ($) = id
13:47:14 <erisco> giantoctopus, think about it more :)
13:47:59 <ertesx> giantoctopus: look at the type of 'id':  c -> c
13:48:02 <ertesx> now let c = a -> b
13:48:12 <giantoctopus> Ah, true
13:48:55 <ertesx> > id sin 5
13:48:56 <lambdabot>  -0.9589242746631385
13:49:18 <ertesx> of course, since (id sin = sin), so (id sin) 5 = sin 5
13:49:40 <ertesx> -so
13:51:54 <giantoctopus> OK, starting to get the hang of it. Coming from an OO background I'm not used to think of functions this way.
13:52:09 <giantoctopus> Thanks @erisco and @ertesx!
13:53:07 <cobreadmonster> Does anyone have cool Haskell tricks they'd like to share?
13:53:16 <cobreadmonster> s/Haskell/type system
13:53:18 <Welkin> cobreadmonster: what are you up to this time?
13:53:31 <Welkin> street performances using haskell?
13:53:37 <cobreadmonster> Welkin: Trying to write a compiler for a language.
13:53:39 <implementation> giantoctopus: actually, there's still a little difference between ($) and id: the type signature of ($) is more restricted
13:53:42 <implementation> :t ($)
13:53:44 <lambdabot> (a -> b) -> a -> b
13:53:45 <implementation> :t id
13:53:46 <lambdabot> a -> a
13:53:58 <erisco> :t curry id
13:53:59 <lambdabot> a -> b -> (a, b)
13:54:03 <implementation> so you can write "id 5", but not "($) 5"
13:54:05 <erisco> cobreadmonster, I like that example
13:54:29 <hpc> :t curry
13:54:30 <lambdabot> ((a, b) -> c) -> a -> b -> c
13:54:42 <erisco> :t uncurry id
13:54:43 <lambdabot> (b -> c, b) -> c
13:54:46 <erisco> also a good example
13:54:49 <Welkin> you can write ($) id 5 :D
13:54:49 <ertesx> > let 0 = 5 in 0 + 0
13:54:50 <lambdabot>  10
13:54:52 <Welkin> > ($) id 5
13:54:53 <lambdabot>  5
13:54:57 <importantshock> cobreadmonster: Infinitely-nested functors with newtype Fix f = Fix (f (Fix f)) ? That's my favorite trick these days.
13:55:00 <ertesx> cobreadmonster: like this?
13:55:01 <hpc> hmm, somehow i thought curry was the universal fold for tuples
13:55:33 <cobreadmonster> ertesx: what the fuck?
13:55:37 <ertesx> cobreadmonster: more seriously for language implementation thou must search for "i'm not a number, i'm a free variable"
13:55:38 <erisco> hpc, you are thinking of uncurry
13:55:44 <hpc> :t uncurry
13:55:45 <lambdabot> (a -> b -> c) -> (a, b) -> c
13:55:53 <hpc> ah that's it
13:55:53 <cobreadmonster> importantshock: What's that good for? 
13:55:58 <cobreadmonster> It seems like a neat trick.
13:56:06 <cobreadmonster> I just don't get what it's supposed to do.
13:56:38 <ertesx> cobreadmonster: also known as locally nameless binding
13:56:39 <hpc> Fix is the free Monad for a Functor
13:56:42 <implementation> :t uncurry (,)
13:56:43 <lambdabot> (a, b) -> (a, b)
13:56:50 <importantshock> cobreadmonster: Lets you use morphisms to do beautiful bottom-up / top-down transformations and folds. Like foldr, but over any nested structure, not just lists.
13:56:51 <hpc> er, no it isn't
13:57:33 <implementation> :t uncurry id
13:57:34 <lambdabot> (b -> c, b) -> c
13:57:42 <implementation> this could actually be useful somehow o.o
13:58:02 <importantshock> Especially nice over syntax trees, if you're writing compilers.
13:58:04 <erisco> uncurry id   is an exercise in thinking about types
13:58:18 <cobreadmonster> importantshock: Interesting. May I PM?
13:58:18 <hpc> Fix is mostly useful for writing eDSLs
13:58:23 <importantshock> cobreadmonster: Go ahead.
13:58:44 <erisco> cobreadmonster, ah, here is another of my favourites (that I also came up with :P)
13:58:54 <erisco> > length . take 10 . inf $ undefined
13:58:56 <lambdabot>      Not in scope: ‘inf’
13:58:56 <lambdabot>      Perhaps you meant ‘int’ (imported from Text.PrettyPrint.HughesPJ)
13:59:14 <erisco> @let inf ~(x:xs) = x : inf xs
13:59:15 <lambdabot>  Defined.
13:59:17 <erisco> > length . take 10 . inf $ undefined
13:59:18 <lambdabot>  10
13:59:39 <hpc> data Machine next where GetLine :: Machine (String -> next); ...
13:59:50 <hpc> (Fix Machine) can express sequences of computation
14:00:01 <hpc> because next = Machine next
14:00:17 <erisco> I actually used this in a program to relax strictness on a function
14:00:36 <erisco> if you have a function which is strict on lists, you can then pass in an inf list and it is no longer strict
14:00:54 <ertesx> cobreadmonster: http://www.strictlypositive.org/notanum.ps.gz
14:00:58 <hpc> erisco: bwaaaaaaaah?
14:01:09 <Zemyla> hpc: Yes, but you geberally want Free Machine instead of Fix Machine, so yiu can chain these equences.
14:01:09 <hpc> oh, i see how that works
14:01:19 <erisco> this was helpful in a niche case where I personally knew the list was infinite but Haskell couldn't be sure
14:01:21 <hpc> doh, Free was what i was thinking of
14:01:23 <implementation> erisco: nice one
14:01:35 <ertesx> on my quest to stop people from implementing languages without locally nameless binding
14:02:15 <hpc> Free is the free Monad for a Functor
14:03:09 <Welkin> ertesx: what is that?
14:03:23 <bennofs> that paper is really fun to read, I can recommend it 
14:03:38 <avalokite> ertesx: reading this paper some time ago finally gave me an understanding of what the ancients may have referred to as the substance of nature, or God.
14:03:54 <hpc> Free has a pretty funny definition of join too
14:03:55 <avalokite> It's been a while since I've reflected on such thoughts
14:04:02 <ertesx> Welkin: the best of named binding and de bruijn indices without the headaches of either
14:04:41 <ertesx> avalokite: conor's papers tend to have that effect =)
14:05:14 <Zemyla> Okay, I find myself wondering if this thing I thought of would be useful: A priority system for a concurrency Applicative defined in terms of the "before" and "after" combinators.
14:06:04 <Zemyla> So fx <*> fy runs fx and fy concurrently, but fx <*> before fy runs fy before fx.
14:06:52 <hpc> that sounds somewhat awkward
14:06:53 <bennofs> Zemyla: what if fx = before <something> ?
14:06:53 <Zemyla> And everything in fy runs before fx, so before (fx <*> after fy) <*> fz runs fx first, then fy, then fz.
14:07:12 <ertesx> Zemyla: wouldn't ordering through dependencies be more sensible?
14:07:31 <Zemyla> ertesx: Applicatives don't have dependencies.
14:07:58 <ertesx> Zemyla: if you even get this to work without violating the laws (i doubt it!), it's probably awkward to use
14:08:03 <Zemyla> Everything in a concurrency Applicative could run at the same time.
14:08:04 <ertesx> Zemyla: that suggests you should use a monad here =)
14:08:07 <implementation> oh, now i remember, why "(b -> c, b) -> c" (type of uncurry id) seemed so familiar. that's "extract" on the store comonad :^D
14:08:08 <bennofs> Zemyla: it looks quite bad to me if `before` or `after` is not used at the same point where <*> is used, and if that is always the case, then you might as well use a new operator for before and aftter
14:08:46 <Zemyla> bennofs: Bad how?
14:09:09 <bennofs> Zemyla: it is quite non-obvious which action runs first if you just see fx <*> fy and don't have the definitions of fx and fy nearby
14:09:34 <hpc> what if fx = before fz <*> after fw?
14:09:50 <hpc> fx isn't one atomic thing, remember
14:09:53 <bennofs> Zemyla: and if you have them nearby, you can write either fx `after` fy or fx `before` fy just as easily
14:10:13 <Zemyla> True.
14:11:21 <bennofs> I think such a thing only works well with relative priorities, for which you would need some different structure (i.e. you could extract a "handle" to some action and then queue an action to be executed before or after the action referred to by the handle is)
14:12:29 <Zemyla> bennofs: Honestly, this is telling me that I should make it an Arrow.
14:12:32 <erisco> ertesx, your quest would be helped if the doctrine was more accessible than a gzipped ps file :P
14:12:43 <joe9> I am missing something simple here: http://dpaste.com/2DA85HT . The line 40 works fine . but, adding line 39 causes this error message:  http://codepad.org/ETpAwDuE . I think that there is something wrong with the type signature: svg :: S.Svg () that is causing this issue.
14:13:03 <erisco> I can't open it D:
14:14:25 <bitemyapp> osfameron: that's not a good idea but you're still in that pre-book super eager phase like a teenager with firstitis so I can't really convince you otherwise.
14:14:48 <bennofs> erisco: this file looks like it actually is not gzipped at all
14:14:56 <bennofs> erisco: just plain post script
14:15:23 <ertesx> erisco: i would have published a PDF, but at least zathura can open PS files…  you need to gunzip first, though
14:15:38 <erisco> bennofs is right, looks like
14:15:43 <ertesx> bennofs: i had to gunzip it…
14:15:46 <erisco> but I don't have a postscript reader
14:16:31 <ertesx> erisco: there is ps2pdf
14:16:53 <erisco> you're turning me into a seal
14:17:19 <monochrom> evince can open ps, pdf, ps.gz, pdf.gz
14:17:45 <ertesx> zathura can open PDF and PS, but has failed to open ps.gz when i tried
14:17:49 <erisco> I'm on *that* OS
14:18:02 <bennofs> erisco: here you go: https://transfer.sh/bDf3x/notanum.pdf
14:18:23 <ertesx> oh
14:18:24 <erisco> fantastic, thank-you
14:18:51 <ertesx> i have dark memories of being on *that* OS
14:18:55 <Welkin> what is zathura?
14:19:03 <bennofs> Welkin: a lightweight document viewer
14:19:06 <ertesx> Welkin: a document viewer
14:19:07 <Welkin> sounds like a disney made-for-TV film from the early 2000's
14:19:10 <edwardk> implementation: if you keep pressing on this, it is also the 'apply' morphism for a cartesian closed category, which says something about how fundamental 'store' is to any CCC.
14:19:28 <bennofs> Welkin: https://pwmt.org/projects/zathura/
14:19:32 <erisco> I want to know what "the best of named binding and de bruijn indices without the headaches of either" is
14:21:08 <Welkin> why not use evince?
14:21:17 <Cale> erisco: Represent everything in graph form from the beginning for a whole new kind of headaches
14:21:45 <bennofs> Welkin: well, this is offtopic, but I like a keyboard based UI without the clutter of menus
14:21:50 <erisco> well, I've been quite satisfied with the tacit approach
14:21:55 <erisco> get rid of variables altogether
14:22:11 <ezyang> What do people think the asymptotics of bind are in this code: http://lpaste.net/172600 
14:22:32 <erisco> it is not eminently practical for humans though
14:23:14 <ertesx> ezyang: should be fine when right-associated
14:23:27 <ertesx> ezyang: from a quick glance
14:23:34 <ertesx> you're not doing zipping or anything fancy
14:23:39 <ezyang> I'm a bit worried about the left-associativity case 
14:24:13 <ertesx> ezyang: apply a Codensity or represent Progress using its church encoding, if you're worried about that
14:24:44 <ertesx> ezyang: i think the iteratee library does that, as well as the machines library
14:25:17 <ertesx> correction: iteratee does not…  it uses scott encoding
14:27:52 <erisco> "results in unreadable, unreliable, unmaintainable code" I don't know about that phrasing
14:28:51 <erisco> you often read this list of un-ables adjacent to a fact-free opinion piece
14:30:14 <tdammers> the problem is that these un-things are difficult to quantify
14:30:45 <tdammers> "the readability of this piece of code is exactly 7.41 milliknuths" said no research paper ever
14:31:15 <joe9> Can anyone please help? I have f :: Svg () , g :: Html (), both Svg () and Html () are just type synonym to HtmlT m () . How can I call f from g? Code:  http://dpaste.com/18QFCE3
14:31:38 <joe9> error : http://codepad.org/10oCKFLK
14:33:04 <hpc> what is Item?
14:33:04 <joe9> these are the type definitions: http://codepad.org/OE6GCAIy
14:33:39 <joe9> hpc, this http://codepad.org/LOBSyAeM
14:33:48 <joe9> hpc, is that what you asked?
14:33:51 * hackagebot legion 0.1.0.1 - Distributed, stateful, homogeneous microservice framework.  https://hackage.haskell.org/package/legion-0.1.0.1 (taphu)
14:34:18 <hpc> oh wait, i was misreading
14:34:27 <erisco> um, hm, I guess the meat of the paper must be in the machine processing of such variables
14:34:52 <osfameron> bitemyapp: well, I have one book already, but yes, the pain from that seems to have dulled enough for me to be getting enthusiastic again... ;-)
14:35:15 <ertesx> erisco: the locally nameless representation makes pretty much everything just fall into place with little programming overhead
14:35:39 <erisco> you can also just avoid clobbering the space of variable and identifier names
14:36:02 <ertesx> erisco: that's part of "the best of de bruijn indices" =)
14:36:30 <joe9> hpc, does my question make sense?
14:36:35 <ertesx> erisco: if you want to play with the idea, try the 'bound' library…  IIRC it includes a quick tutorial
14:36:42 <hpc> yeah, it looks correct to me
14:37:37 <joe9> if I convert the svg type definition to : svg :: Monad m => HtmlT m ()
14:37:42 <joe9> then it compiles fine.
14:37:56 <ezyang> ertesx: I'm kind of wondering, does church encoding it preserve the laziness properties 
14:37:56 <erisco> ertesx, I'll have to read more of the paper later. I happen to be working on something where this issue is somewhat relevant
14:38:05 <joe9> hpc, but, the problem is that if I call any function which might have a retun type of Svg (), it errors out.
14:39:24 <erisco> ertesx, to the extent that I'd like variables in a program which require minimal implementation difficulty
14:39:57 <EvanR> passing an environment around is pretty easy
14:40:08 <hpc> ah
14:40:15 <hpc> Svg = SvgT Identity
14:40:19 <hpc> Identity /= m
14:42:12 <joe9> hpc, even Html is defined the same way. Html = Html Identity
14:43:55 <hpc> toHtml wants to be more polymorphic than that though, it seems
14:44:09 <erisco> but I don't have first order functions, so maybe it ends up not relevant
14:44:37 <joe9> Svg = SvgT Identity ; Html = HtmlT Identity; type S.SvgT = HtmlT     -- Defined in âLucid.Svg.Elementsâ
14:45:05 <hpc> toHtml wants it to be Monad m => HtmlT m ()
14:45:50 <hpc> so use svg :: Monad m => S.SvgT m () or something
14:45:50 <joe9> hpc, oh, ok. So, I would need to convert Svg () = HtmlT Identity () to HtmlT m ()
14:48:46 <joe9> hpc, I would have to change all functions returning Svg () to SvgT m (), correct?
14:49:21 <hpc> just whatever that toHtml is using, unless you're getting other errors
14:49:37 <joe9> hpc, ok, Thanks.
14:49:55 <ertesx> ezyang: with some caveats…  see how FreeT and FT map to each other
14:50:56 <ertesx> ezyang: since your type is not a monad transformer, i don't expect this to be a problem though
14:53:29 <joe9> hpc, that worked like a charm. Thanks.
14:53:52 * hackagebot xmobar 0.24.1 - A Minimalistic Text Based Status Bar  https://hackage.haskell.org/package/xmobar-0.24.1 (JoseAntonioOrtegaRuiz)
15:19:17 <shapr> phadej: With the latest changes for the githup api library, how do I list all pull requests on a github repo that requires auth?
15:19:39 <phadej> shapr: with github-0.14?
15:20:40 <shapr> phadej: I was previously using pullRequestsFor' but that no longer accepts auth info
15:21:29 <shapr> phadej: Yes, I think the change was between 0.11 and 0.14
15:21:34 <enthropy> what do people use to do "sortOnM :: Ord b => (a -> m b) -> [a] -> c a", with c being some iteratee/conduit/pipe?
15:21:56 <enthropy> @type \f -> sortOn (unsafeInterleaveIO . f)
15:21:57 <lambdabot> Not in scope: ‘unsafeInterleaveIO’
15:22:24 <enthropy> err, I guess unsafeInterleaveIO wouldn't work there
15:23:06 <phadej> shapr: it does?  http://hackage.haskell.org/package/github-0.14.1/docs/GitHub-Endpoints-PullRequests.html#v:pullRequestsFor'
15:23:13 <dmwit> enthropy: I'm not sure I've seen that, but it should be pretty easy to implement as a decorate-sort-undecorate kind of thing.
15:23:58 <enthropy> dmwit, I'm interested in not performing all the side effects (but that's premature optimization)
15:24:08 <phadej> shapr: the type has changed, but it should work still
15:24:27 <dmwit> enthropy: That seems unlikely. You have to perform them all to even know the first element of the result.
15:25:34 <shapr> phadej: oh, I'm looking at the latest in github, it doesn't have pullRequestsFor'
15:26:58 <enthropy> dmwit, how about for "sortOnM :: (Ord b1, Ord b2) => (a -> m b1) -> (a -> m b2) -> [a] -> c a"
15:27:11 <shapr> phadej: I wanted to fix up the broken samples like ListPulls.hs, so I figured I'd work with what's in github
15:27:27 <dmwit> enthropy: Hm; how should I interpret the two function arguments?
15:27:35 <dmwit> enthropy: Lexicographically or something?
15:27:52 <phadej> shapr: for that you should use http://docs.futurice.com/haskell-mega-repo/github-0.15.0/GitHub-Endpoints-PullRequests.html#v:pullRequestsForR and http://docs.futurice.com/haskell-mega-repo/github-0.15.0/GitHub-Request.html#v:executeRequest
15:27:52 <enthropy> yes
15:28:07 <dmwit> fun
15:28:32 <shapr> phadej: ah! that answers my question, thanks!
15:28:44 <dmwit> enthropy: I suppose one could DSU with the first function, then DSU locally on things that compared equal during the first pass.
15:28:53 <phadej> shapr: having foo, foo' and foo'' seemed as quite a lot duplication, so I decided to remove it in that case, as I also changed how params for PR works
15:29:05 <dmwit> enthropy: hm
15:29:13 <dmwit> enthropy: This is tricky. I like your puzzle. =)
15:29:30 <shapr> phadej: I won't have an opinion until I try the new approach.
15:30:21 <enthropy> good. Let me know if you have more ideas. Gotta go for a bit
15:30:53 <hololeap> is there a way to check what class a type falls into using ghci?
15:31:09 <dmwit> hololeap: :i will tell you about type constructors
15:31:31 <dmwit> hololeap: e.g. `:i Int` tells what classes `Int` is in
15:31:36 <hololeap> dmwit: nice, thanks :)
15:31:44 <phadej> shapr: it works for me quite well, as I work over https://github.com/futurice/haskell-mega-repo/blob/cd844b6f6ee3034f4ec3f8ffb2d5e785b07c80f1/futurice-integrations/src/Futurice/Integrations/Classes.hs#L21
15:32:42 <phadej> shapr: e.g. let's me transparently add caching
15:34:26 <dfeuer> Is there a tutorial somewhere suggesting "design patterns" for getting QuickCheck to give the most useful possible error messages?
15:34:56 <shapr> phadej: The possible benefit to the previous approach is that my coworkers who don't know Haskell would find it easier to modify.
15:35:11 <dfeuer> phadej, did you have any luck with generic-trie, by the way?
15:35:13 <shapr> Not that I'm convinced they'll dig into Haskell to modify the cute tools I write.
15:36:30 <phadej> shapr: it's easy to write a IO-wrapping instance of such monad class
15:36:36 <osfameron> oh, didn't realise futurice did Haskell too
15:36:57 * osfameron was idly thinking about looking for work in Finland, what with Brexit on the cards...
15:37:16 <shapr> espoo? tampere?
15:37:47 <shapr> I used to work in Tornio
15:37:48 <osfameron> I only knew about their office in Helsinki tbh, but sure
15:37:52 <phadej> dfeuer: for caching? haven't tried it. For github requests I cache them on disk
15:37:56 <osfameron> don't think I've ever been to Espoo
15:38:22 <dfeuer> phadej, oh, I think I got confused. Maybe hexagoxel was the one looking at that?
15:38:34 <phadej> dfeuer: maybe
15:39:35 <phadej> osfameron: we have many offices atm, Helsinki is HQ, but there are others as well. Check the website for more
15:40:17 <osfameron> phadej: yeah, so I see!  just looking now
15:41:44 <hololeap> are there any RoR-style web frameworks for haskell?
15:42:49 <sm> yesod
15:44:52 <hololeap> sm: ty
15:45:57 <Cale> hololeap: I'm not sure exactly what RoR-style entails, but also look at Happstack and Snap
15:47:01 <hololeap> i guess i mean i lean toward convention vs configuration and modularity
15:47:02 <Cale> hololeap: Where I work, we use Snap for our backends, and Reflex-DOM/GHCJS for our frontends, and it works quite well.
15:50:29 <hololeap> i am also a huge fan of activerecord
15:50:41 <hexagoxel> dfeuer: yeah, i was the one. i realized that the whole approach was doomed if i could not get StableNames to work to some minimal degree, which i could not, because i'd be working with an exponentially sized tree.
15:50:53 <dfeuer> :(
15:51:01 <hololeap> i'm mostly a ruby programmer, but i'm trying to learn haskell because i think it will make me a better programmer in general
15:52:10 <maerwald> hololeap: it doesn't. the knowledge it contains is very specific to that domain. you barely can use any of that in a different language. I'd say trying different paradigms is useful yes, but it's not specific to haskell.
15:52:29 <maerwald> as in: you have to learn programming from scratch
15:52:37 <maerwald> and when you go back to ruby, well...
15:53:26 <hololeap> the thing is, java and c# have functional programming abilities now and programming in a purely functional language will teach me how to think clearly in that context
15:53:42 <hexagoxel> dfeuer: i now use "manual StableNames" which is a bit ugly but works great. In turn removed the need for GenericTrie.
15:53:43 <maerwald> those are just minor tools you can learn explicitly
15:53:50 <hololeap> so the domain extends pretty far :)
15:54:06 <Zekka> FWIW, I don't think haskell is really representative of anything but haskell, but it *is* a statically typed language with no support for inheritance
15:54:09 <maerwald> learning haskell just because you want to understand monads doesn't make that much sense ;)
15:54:25 <hololeap> i guess i don't make that much sense
15:54:37 <Zekka> if I were a ruby programmer I would want to learn a statically-typed language with no support for inheritance
15:54:45 <maerwald> again: haskell is so fundamentally different that you don't really benefit much for other languages that are not alike
15:54:55 <Zekka> there's parts of Haskell that are pretty complicated but the data model is pretty simple and the type system encourages planning
15:55:06 <maerwald> which is the majority of mainstream languages
15:55:45 <hololeap> in any case i'm really enjoying the language so far
15:55:57 <maerwald> then learn it because you like it
15:56:04 <maerwald> don't expect it to make you a super-sajayin
15:56:18 <hololeap> didn't say anything like that...
15:56:23 <maerwald> :D
15:56:29 <Zekka> fwiw I don't think Haskell made me significantly better at programming, although it gave me some ideas I didn't have before
15:56:32 <glguy> maerwald: It seems like you've expressed your point
15:56:35 <maerwald> its not going to improve your ruby, or python or...
15:56:58 <Zekka> I wouldn't echo the view that "Haskell makes you better at programming," kinda how knowing more words doesn't make you better at writing
15:57:58 <shapr> I think being forced to think so differently about programming really did help me get better at coding in general.
15:59:03 <hololeap> i feel like learning haskell will help me wrap my mind around some more advanced functional programming concepts, which i could take to other languages. not that it will be a 1 to 1 correlation, but the experience will be useful. that's all i was trying to say
15:59:16 <Zekka> Have you worked with a statically-typed language before?
15:59:22 <maerwald> hololeap: if you do idris, purescript elm or stuff like that then maybe
15:59:23 <hololeap> yeah, java and c#
16:00:09 <kadoban> maerwald: Lol ... so any language except haskell? That doesn't seem to make much sense.
16:00:19 <maerwald> kadoban: that's not what I said
16:00:45 <kadoban> maerwald: Okay, well that's a few languages that are similar to haskell in one way or another. What makes that fairly diverse set of languages more instructive than haskell itself?
16:01:49 <maerwald> kadoban: I don't know what you mean
16:02:28 <senoj> hololeap: I think that learning Haskell would get you a long way towards your goal.
16:02:36 <kadoban> "[15:59] <maerwald> hololeap: if you do idris, purescript elm or stuff like that then maybe" I assume that was in response to "leraning haskell will help me wrap my mind around some more advanced functional programming concepts [...]" ?
16:02:55 <Zekka> FWIW being a little cynical, I think if you can avoid advanced functional programming concepts as much as possible, it might make your programs easier to understand
16:02:59 <maerwald> kadoban: nah I meant that learning haskell will help you with those languages too
16:03:04 <maerwald> it won't help your java skills
16:03:04 <Zekka> part of the pitch for using them to begin with is that sometimes every other option is worse
16:03:14 <kadoban> maerwald: Oh, that makes more sense.
16:03:38 <bitemyapp> lastlog 
16:03:41 <bitemyapp> sigh
16:04:00 <Zekka> there are a lot of parts of the US where people say you're allowed to carry a gun -- but the implication is that you should use it as little as possible
16:04:31 <maerwald> kadoban: that's why the assessment "will improve your programming" is either inaccurate or so broad that it's meaningless in the sense that "any new language will improve your programming". However, it certainly makes sense to learn new paradigms, but I think people expect too much of it.
16:04:39 <Zekka> if someone says they need help writing plugins and your first thought is "Oh, they need a contravariant functor!" you are failing them
16:04:46 <Zekka> er, help writing a plugin system*
16:05:03 <kadoban> maerwald: Why does it make sense to learn new paradigms if it won't improve your programming?
16:05:07 <bitemyapp> I'd tend to agree unless it slots extremely well into a particular problem they have or it kills more difficulty than it introduces.
16:05:17 <bitemyapp> (agree with Zekka's example, that is)
16:05:22 <avalokite> kadoban: isn't paradigm political?
16:05:23 <Zekka> A lot of functional programming patterns are kinda designed for the general case
16:05:35 <maerwald> kadoban: well, it's fun and widens your horizon
16:06:13 <kadoban> avalokite: I don't know what you mean exactly. You mean what defines one or another is political?
16:06:30 <Zekka> but in a lot of programs you don't actually need "contravariant functors, in general" -- you might need s -> a ("things that build an a") or even more realistically, s -> Document, or "functions to load a document from disk"
16:07:05 <kadoban> maerwald: I guess. I tend to think it helps. Not a lot, but ... some.
16:07:17 <pavonia> The Data.Sequence docs say some of its operations run in "amortized constant time". How is that exactly different to real O(1) (if there is any difference)?
16:07:18 <Zekka> (fwiw, there is implicitly IO not in that type signature -- I left it out to make things a little simpler)
16:07:34 <Rembane> I think making a program that solves hard problems look simple is the hard part regardles of paradigm.
16:07:54 <Zekka> Yeah, but I think that if you're not careful, you instantly bring things in that make the problem harder
16:07:56 <maerwald> kadoban: I tend to think it's maybe more useful for your "algorithmic skills" in a sense?
16:08:11 <Zekka> "Well, of course we need a framework." "Well, of course we need microservices."
16:08:14 <avalokite> kadoban: sure, for example, a lot of ideas were implemented as some kind of solution for this and that, and industial leaders eventually grouped this concept and that concept into a general class of concepts [i.e., paradigms], something that really didn't arise on it's own. At least, it's a peculiar pattern I've noticed over the years
16:08:17 <senoj> pavonia: it means that over many lookups (for example) the average worst case time is O(1)
16:08:47 <kadoban> pavonia: It means that a sequence of any n operations of that type will be O(n) total.
16:08:50 <Zekka> in an ideal world all programs would not be concurrent and not use external resources
16:09:27 <kadoban> maerwald: Depends what you mean by algorithmic skills I guess. I don't think it helps much with like algorithms problems specifically, like the coding challenge ones. I *think* it helps figure out better ways to structure programs.
16:09:27 <mvr_> https://www.irccloud.com/pastebin/vkMh4fLP/
16:09:30 <mvr_> is it odd that Good works but Bad doesn't? should Good not work at all? The error appears to blame the wrong place
16:09:42 <avalokite> speaking of which, anyone familiar with girard's system u?
16:10:05 <pavonia> senoj, kadoban: So that mean some oprations may run in O(n) but then much more others will actually run in O(1) time?
16:10:41 <maerwald> kadoban: I think it can help with _coming up_ with algorithms
16:10:57 <kadoban> pavonia: Sounds right, yeah.
16:10:57 <maerwald> because there are more ways to think about them
16:11:31 <kadoban> maerwald: Hmm, I'm not sure I noticed it helping me with that really. Only thing that seems to help is studying algorithms specifically and just practicing that a lot. But I'm not sure I would notice either, especially if it's subtle.
16:11:39 <Zekka> Haskell kinda comes with a few features that already threaten your ability to write fast code, doesn't it?
16:11:47 <Zekka> I thought a ton of its default representations were super pointery
16:12:08 <senoj> pavonia: an example would be extending a vector. most the time it's O(1) per adding one element to the end, but occasionally you have to reallocate and copy to grow the storage for the vector and that's O(m) where m is the vector size at the time
16:12:42 <Zekka> (sorry to drop out on you guys, but I have to go)
16:12:47 <kadoban> pavonia: Note that it's not enough just to say that "well, only once in a while it's Theta(n)". It's necessary, but not sufficient.
16:12:52 <maerwald> kadoban: if you think about some game algorithms in prolog, they are fundamentally different to what you would come up with otherwise
16:13:00 <senoj> pavonia: so over many sequential extensions the time complexity averages out to O(1) per extention in the limit
16:13:13 <glguy> mvr_: Have you looked at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html?highlight=polykinds#kind-inference-in-closed-type-families
16:13:25 <pavonia> kadoban, senoj: I see, thanks!
16:13:58 <senoj> pavonia: yw
16:13:59 <kadoban> maerwald: If you think learning new paradigms helps with that stuff, I mean ... isn't that part of programming? How would it help with coming up with algorithms but not with programming?
16:14:13 <glguy> mvr_: It seems that if you give any kind signatures with polykinds enabled (as you did on the argument 'a') then you must give a complete kind signature
16:14:22 <maerwald> kadoban: how does a prolog-like algorithm help you with your C code? xD
16:15:04 <kadoban> maerwald: So it only helps you come up with algorithms if you're using the original lanugage itself?
16:15:06 * avalokite loves the conversations in this channel
16:15:06 <maerwald> my point was just that it's too diverse to be an accurate statement
16:15:23 <glguy> mvr_: otherwise you don't get a polykinded definition, you get one where all of the arguments to Bad have to actually have the kind 'k'
16:15:31 <maerwald> kadoban: no, I gave examples where other languages are affected too
16:15:52 <kadoban> And C is just ... not a good guide anyway, shouldn't be used for general programming so it's kind of besides the point.
16:15:54 <maerwald> but the improvement is usually more specific or "domain-bound"
16:16:23 <kadoban> I mostly agree with that, I don't think all of the improvement is specific to the domain it came from though.
16:16:33 <kadoban> I'd say the effect is overstated, but still real.
16:16:42 <maerwald> let's agree on that
16:16:51 <mvr_> glguy: fantastic! makes sense
16:16:54 <mvr_> glguy: thanks again
16:33:55 * hackagebot casadi-bindings 3.0.0.4 - mid-level bindings to CasADi  https://hackage.haskell.org/package/casadi-bindings-3.0.0.4 (GregHorn)
16:52:10 <dmwit> enthropy: http://lpaste.net/172617
16:52:21 <dmwit> enthropy: Just hacked together. I'm sure it can be cleaned up a lot.
16:53:20 <dmwit> enthropy: Anyway, the basic idea is: have each kind of sort operate on chunks which are equal by previous comparators. Then you only need run the effects of lists where you will eventually do a comparison (i.e. length greater than one).
16:53:46 <dmwit> enthropy: Then throw on a top-level executor that packages things up into the required shape for these composable pieces.
16:54:29 <dmwit> enthropy: I have no experience with conduits or iteratees, so I don't know how well this idea will translate there.
17:01:33 <dmwit> enthropy: If you run the thing by stepping `M.uncons`, you'll notice that the side effects of later comparisons don't happen until they need to. e.g. add `(-1,0)` to the example list and you'll see `b(0,0)` and `b(0,1)` appear only after `(-1,0)` has been produced as the head of the sorted list.
17:26:53 <Xnuk> I saw `(?loc :: CallStack) => String -> a`. What does `?loc :: CallStack` mean?
17:28:57 * hackagebot gnss-converters 0.1.15 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.15 (markfine)
17:30:21 <Axman6> Xnuk: it's part of this: https://ghc.haskell.org/trac/ghc/wiki/ExplicitCallStack
17:30:33 <Axman6> hmm, actually that's not the best link...
17:31:51 <geekosaur> more generally, that's an implicit parameter https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#implicit-parameters
17:32:11 <Axman6> https://ghc.haskell.org/trac/ghc/wiki/ExplicitCallStack/ImplicitLocations is related, and better shows how the implicit callstack stuff works
17:33:15 <Xnuk> thanks
17:34:11 <Welkin> I thought ghc didn't use a callstack, but a pattern matching stack?
17:34:24 <geekosaur> it doesn't. that's why this hack is needed to get a call stack
17:34:40 <geekosaur> or something within what most people think of as a call stack
17:46:52 <mikail`> Hi, would I be right if I said Haskell does not have a notion of a top and bottom type?
17:47:11 <Welkin> haskell has bottom
17:47:21 <Welkin> it is `undefined`
17:47:26 <mikail`> oh
17:47:42 <mikail`> is there no need for a top type?
17:47:52 <Welkin> I don't know what a top type is
17:47:58 <Welkin> maybe someone else will
17:48:03 <mikail`> like Any in Scala
17:48:06 <Welkin> oh
17:48:07 <mikail`> or Object in Java
17:48:15 <Welkin> hm
17:48:32 <Welkin> using a type variable, yes
17:48:39 <Welkin> but a type, I don't think so
17:48:43 <Welkin> :t id
17:48:44 <lambdabot> a -> a
17:48:45 <slack1256> probably those notions don't fit in with haskell. Those seem related to sub-typing right?
17:48:50 <Welkin> forall a. a -> a
17:48:59 <Welkin> that is the closest
17:49:00 <mikail`> slack1256: yeah
17:49:37 <mikail`> it seems to be prevalent in languages which allow subtyping
17:49:40 <parsnipM_> weird, t is top in some lisps
17:50:26 <parsnipM_> for all a. a is mentioned at wikipedia page
17:50:55 <enthropy> @hackage data-default-class
17:50:55 <lambdabot> http://hackage.haskell.org/package/data-default-class
17:51:21 <enthropy> def from that package is kind of a top
17:56:24 <fishythefish> Er, isn't `undefined` a bottom value? A bottom type in Haskell would be an empty type
17:56:48 <geekosaur> @index Void
17:56:48 <lambdabot> Data.Void
17:57:08 <fishythefish> Right, or anything with EmptyDataDecls
17:58:19 <fishythefish> Although those don't really fit the bill because while they're uninhabited, Haskell doesn't have subtypes
17:58:21 <fishythefish> (as was mentioned)
18:01:44 <fishythefish> Welkin: exists a. a would be closer (assuming the syntax exists), right?
18:02:09 <enthropy> dmwit, interesting thanks!
18:18:58 <jchia_> how do i process latin1 strings efficiently? In other words, I only care for the first 256 characters so my characters should be 1 byte each. I thought I could use Data.ByteString.Char8.ByteString explicitly as a string-y type but it's not exported. If I use Data.Text or , I would be incurring unnecessary overhead for character values that I don't use.
18:19:58 <geekosaur> you want Data.ByteString.ByteString. Char8 is an interface, not a distinct type
18:20:09 <shachaf> Data.ByteString.Char8.ByteString is exported. It's the same type as Data.ByteString.ByteString
18:32:38 <jchia> i was confused earlier. what i really want to solve is this: http://lpaste.net/172633
18:33:05 <jchia> how do i decode a Map whose key is a Data.ByteString.Char8.ByteString? I have no use for unicode characters in the ckey
18:33:15 <jchia> in aeson
18:34:02 <jchia> L21 has an error "No instance for (FromJSON (Map B.ByteString Int)) arising from a use of ‘decode’"
18:34:24 <jchia> I already provided the FromJSON instance for the ByteString
18:38:07 <Axman6> json keys are always utf-8 (though you can usually assume they're acsii)
18:38:37 <Axman6> and the Data.ByteString.Char8.ByteString is the same type as Data.ByteString.ByteString
18:48:51 <monochrom> jchia, if you are willing to use Map String Int, it is already done.
19:13:25 <lpaste> songzh pasted “duplicate instances” at http://lpaste.net/172640
19:14:14 <songzh> hi can anyone help solve on this problem. 
19:15:11 <songzh> I want to give separate instance declarations for types from different classes.
19:15:46 <songzh> are there convenient way to implement this.
19:16:17 <parsnipM_> songzh: try hoogle/ 
19:16:22 <monochrom> From the computer's point of view you have two copies of "VariadicParam a". At this point it does not matter that they have different assumptins.
19:18:07 <parsnipM_> weird, hoogle doesn't give what i expected as first result
19:18:26 <monochrom> read Text.Printf for how to do variadic properly.
19:30:52 <avindroth> hello all!
19:31:00 <avindroth> I am trying to wrap my head around readers and maybes
19:31:12 <avindroth> is there a place I can place code to demonstrate the problem?
19:31:16 <avindroth> I don't feel like pasting it
19:31:29 <sleblanc> avindroth: lpaste.net
19:33:17 <avindroth> http://lpaste.net/172641
19:33:21 <avindroth> that was it
19:33:22 <avindroth> thanks
19:36:27 <Cale> avindroth: With the Monad instance for Maybe, you can use a do-block, where if you have  v <- x  with x :: Maybe t, then v :: t, and if x was Nothing, then the whole do-block evaluates to Nothing
19:36:58 <Cale> But... this operation appears a little bit questionable.
19:37:08 <shachaf> That code would be easier for people to read if you annotated it with types.
19:37:21 <songzh> songzh pasted “duplicate instances” at http://lpaste.net/172640
19:37:43 <songzh> I want to give separate instance declarations for types from different classes. but GHC said it is duplicated
19:38:02 <shachaf> You can't do that.
19:38:11 <shachaf> Instance selection is independent of any constraints.
19:38:37 <Cale> songzh: That's right, you can't. Both of those are indistinguishable from  "instance VaridicParam a where ..."  to the algorithm which selects which instance to use.
19:40:37 <martiniu_> does anyone know if any people or groups are working on a compiler backend that would optimize FP language code better than something like llvm that is designed for the imperative/OOP world?
19:40:44 <Cale> The reason for this has to do with the ability for that algorithm to make a consistent choice throughout the whole program even when it is separately compiled -- you have instances coming from various different libraries, and you don't know that you can see them all yet, so you can never reject an instance on the basis that a class constraint isn't yet satisfied.
19:41:08 <Cale> You can only commit to it and then complain when you don't end up finding the required instance.
19:41:50 <Cale> martinium_laptop: Well, GHC has a native codegen as well.
19:42:13 <martinium_laptop> yeah but doesn't it use LLVM primarily nowadays
19:42:20 <Cale> no
19:42:27 <shachaf> Optimizing Haskell code is quite different from optimizing most other "FP" languages.
19:42:36 <Cale> It has LLVM support, but it is not the default backend.
19:42:38 <martinium_laptop> due to it's pureness?
19:42:50 <martinium_laptop> purity*
19:43:01 <Cale> Due to lazy evaluation, mostly.
19:43:05 <shachaf> Yes.
19:43:15 <shachaf> Purity comes from laziness, really.
19:44:03 <martinium_laptop> Haskell performs so fast using warp and yesod for web stuff
19:44:10 <martinium_laptop> even with the laziness
19:44:17 <shachaf> Strict evaluation is a Communist conspiracy to sap and impurify all of our precious bodily fluids.
19:44:17 <martinium_laptop> it's amazing to be honest
19:44:28 <martinium_laptop> shachaf lol
19:44:34 <glguy> honesty is the  best policy, certainly
19:44:50 <Cale> The laziness isn't necessarily harmful to performance at all. It can be quite helpful too
19:44:52 <martinium_laptop> ;)
19:45:07 <songzh> Cale : thanks
19:45:12 <avindroth_> Cale: why is it questionable?
19:45:13 <martinium_laptop> lazyness seems to be complained about in many forums like it's a real drawback
19:45:45 <martinium_laptop> makes realtime systems programming a no go zone for haskell
19:45:45 <Cale> avindroth_: This function doesn't take a timezone as a parameter for one.
19:46:00 <Welkin> martinium_laptop: it enables efficient use of immutable data structures
19:46:22 <martinium_laptop> Welkin they basically need each other
19:46:28 <avindroth_> Cale: gotcha
19:46:42 <avindroth_> I should add that in
19:46:54 <avindroth_> I wanted it as a testing tool
19:48:12 <Cale> martinium_laptop: Some people are a bit noisy about it, but it's mostly an advantage.
19:49:23 <Cale> martinium_laptop: If you want to do realtime programming, you're probably better off applying Haskell as a metalanguage, and building a one-shot compiler which will schedule and emit your realtime code.
19:51:45 <martinium_laptop> Cale yeah there seem to be many ways to go about it
19:52:05 <martinium_laptop> I am still learning the language so will be some time before I am working on things that are that advanced
19:53:24 <Welkin> martinium_laptop: https://ro-che.info/ccc/25
19:56:57 <jchia> What is the code that allows decode to be able to produce a Map Text a? Where is the aeson code that does that? if I want to decode to Map ByteString.Char8.ByteString a, what do I need to do? I thought I just needed to provide a FromJSON instance for Byte.Char8.ByteString but apparently that's not enough
19:57:19 <jchia> my keys are all latin1. I have no need for unicode
19:57:46 <kadoban> jchia: Does it actually matter? How big is this JSON?
19:57:55 <Welkin> lol
19:57:55 <martinium_laptop> Welkin lol
19:58:00 <Welkin> seems like a pointless optimization to me
19:58:13 <glguy> jchia: Internally Aeson is going to build up Objects using: type Object = HashMap Text Value
19:59:16 <kadoban> jchia: I'd be quite surprised if you could even tell the performance difference with any JSON I've ever worked with. From what little I know of how aeson works too, I wouldn't be surprised if you make it worse by doing extra encoding/decoding instead of avoiding it.
19:59:17 <Cale> jchia: http://hackage.haskell.org/package/aeson-0.11.2.0/docs/src/Data.Aeson.Types.Instances.html#line-656 -- it's here
19:59:23 <glguy> The instance of FromJSON is for FromJSON a => Map Text a
19:59:26 <Cale> jchia: I think it's a really unfortunate instance to have
19:59:48 <joneshf-laptop> I'm looking for either a blog post or a video where someone had an "expression" language and they were showing that you could print it in multiple ways easier since you have laziness (maybe it was laziness?), vs how you'd have to rethink printing otherwise. Anyone know what I'm talking about?
19:59:59 <Cale> It should just be instance (ToJSON k, ToJSON v) => ToJSON (Map k v)
20:00:04 <Cale> But no
20:00:05 <rhovland> I swear I remember vector.mutable having "modify" but now I can't find it... has that moved to some generic monad package now?
20:00:19 <glguy> Cale: The keys are only Texts, not Values
20:00:22 <Welkin> rhovland: it is in vector I think
20:00:40 <Cale> glguy: Yes, I'm aware that this is what *this* instance is.
20:00:49 <jchia> The json itself is small and mostly human-readable. The type of the key of the resulting map matters because it'll be used to lookup
20:00:49 <Cale> glguy: I'm saying that's what the instance *ought* to be :)
20:01:02 <glguy> No, I mean the the underlying type is Text, not Values
20:01:06 <Welkin> rhovland: http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#v:modify
20:01:09 <glguy> Values being the thing that drive FromJSON
20:01:21 <shachaf> But JSON keys are strings, not JSON values.
20:01:27 <glguy> Though I suppose the Texts could be reinserted into Value
20:01:41 <glguy> and only FromJSON instances that used Texts would succeed for the keys
20:01:47 <Cale> shachaf: That doesn't matter... it doesn't have to encode the Map as a JSON dictionary.
20:02:06 <jchia> the json keys are unicode but my use-case has a constraint that they happen to be latin1 and i even want to reject the json if i have non-latin1 characters in the keys
20:02:06 <Cale> I don't actually care how it's encoded, just that it's encoded faithfully.
20:02:46 <Cale> Maybe I'm weird
20:02:51 <kadoban> Is there even such a thing as non-latin1? Isn't every possible byte a valid latin-1 character?
20:03:06 <shachaf> Well, it wouldn't make much sense to want it to be encoded fully.
20:03:28 <glguy> You can make an instance for FromJSON a =>Map ByteString a
20:03:35 <glguy> And it won't overlap
20:03:35 <kadoban> Ignore that though, not a useful question.
20:03:46 <joneshf-laptop> maybe it was a book?
20:03:52 <Cale> We even have Maps which are indexed by Sets which we transmit via JSON
20:04:20 <Cale> That Map Text instance occasionally gets in my way though and makes me use Identity Text for no other reason than to sidestep it.
20:04:40 <shachaf> Are you talking about a situation where you have Haskell code on the server side and also compiled to JavaScript on the client side?
20:04:46 <Cale> yes
20:04:54 <shachaf> Why use JSON at all in that case?
20:05:38 <glguy> The FromJSON class makes a bunch of assumptions. To make a custom encoding a custom class would be good
20:05:55 <Cale> It's quite possible that we should just fork aeson.
20:06:11 <glguy> Or just make a new class
20:06:14 <shachaf> I don't think that's what glguy is suggesting.
20:06:14 <monochrom> no, use a binary format.
20:06:14 <Cale> Or just use Binary instances instead
20:06:33 <Welkin> isometric haskell!?!?!?
20:06:35 <monochrom> use Show.
20:06:36 <Welkin> er
20:06:38 <Welkin> isomorphic!
20:06:38 <Cale> Though Chrome obnoxiously won't tell you anything about binary frames sent over a websocket
20:06:45 <Welkin> call it haskellscript!
20:06:48 <glguy> Just like you wouldn't use the Binary class if you needed control over the format
20:06:56 <joneshf-laptop> I I like isometric
20:07:02 <Cale> We don't actually need control over the format
20:07:05 <monochrom> it's isometric because both sides are equally slow
20:07:06 <glguy> The class as defined by the binary package
20:07:36 <monochrom> oh! binary then base64
20:08:03 <jchia> I was looking for the parseJSON for (Map Text a) for the FromJSON instance, on hoogle. hoogle doesn't show it when i search for 'parseJSON'. The results do not include Data.Aeson.Types.Instances, although they include Data.AesonTypes. I had to manually search for the code in Data.Aeson.Types.Instances.html in my local hackage. What am I missing about hoogle?
20:08:13 <Cale> Using JSON has the advantage that you can stare at it and tell what's going on, even if the format is a bit messy.
20:08:36 <shachaf> I would rather use something like protobuf for that sort of thing.
20:09:08 <jchia> (i'm using local hoogle that has indexed aeson)
20:11:26 <glguy> Arson uses orphan instance making it harder to find things
20:11:41 <glguy> My phone doesn't know about Aeson
20:11:57 <monochrom> haha
20:12:24 <glguy> And I'm sure as hell not going to start proofreading
20:12:49 <Welkin> glguy: you are one irc on your phone?
20:12:52 <Welkin> how do you type anything?
20:13:04 <glguy> Poorly
20:13:22 <glguy> I am one IRC, it's true
20:14:03 <glguy> It's hour I write all my Haskell; on my phone that is, not poorly
20:14:12 <glguy> How*
20:16:39 <kadoban> You write all of your code on a crappy phone keyboard? :-/
20:16:49 <kadoban> At least get a bluetooth one or something?
20:16:53 <glguy> No, that was a lie.
20:17:04 <monochrom> still better than speaking to the phone
20:17:36 <Welkin> dictate your programs
20:18:05 <Welkin> people do that
20:18:19 <monochrom> "computer, generalized newtype derive Show for Identity"
20:18:27 <glguy> I can imagine dictation of Haskell working if you could do it in a structured way, rather than dictating key presses
20:18:54 <kadoban> I've thought about that before, yeah you could probably make up your own spoken language that'd translate into a specific syntax.
20:19:46 <monochrom> I have a cunning plan. Click your tongue to speak morse code.
20:20:08 <glguy> OK, I'm doing that. What is step two of the plan?
20:20:49 <monochrom> Turn it into an app and sell it on iTunes and Google Play for $99.99
20:21:19 <glguy> Didn't someone do that step and call it the "I'm rich" app?
20:21:45 <monochrom> yeah, but they didn't do the first step.
20:21:49 <glguy> My understanding is that got some sales but then apple refunded them
20:22:23 <enthropy> maybe some preexisting voice recognition stuff could be adapted to use the haskell grammar (as opposed to some approximation of english grammar)
20:24:48 <songzh> :tell Cale are there any ways to separate the two kinds of instances.
20:24:59 <Cale> songzh: hm?
20:25:11 <Cale> songzh: Which two kinds?
20:25:49 <glguy> songzh: You'll make once instance for each type that should have an instance
20:26:18 <glguy> songzh: If many types share the same implementation you can define that as a top-level definition that you use for the body of your class method so they can all share the same implementation
20:41:15 <songzh> The ones in class A and other in class B
20:42:22 <songzh> I want to separate them. I am trying to define a type family to use a type function to separate them, but not success for now.
21:05:37 <freeside> huh. i just realized the bitcoin blockchain is a monad.
21:06:40 <exio4> welp, how so? :)
21:09:55 <freeside> it's a chain of operations in which the history of earlier execution is made available to subsequent operations; the operations are all of the same type; and the values that we care about (funds transfer) are wrapped in a container type (the ledger updates).
21:10:37 <freeside> i wonder if anyone's formalized the blockchain using the actor model and pi-calculus.
21:10:48 <glguy> How does that satisfy the laws that make something a Monad?
21:14:06 * hackagebot glirc 2.1 - Console IRC client  https://hackage.haskell.org/package/glirc-2.1 (EricMertens)
21:16:29 <freeside> hm, i need to think about that.
21:18:57 <Cale> freeside: It's not clear that it's even a functor.
21:20:59 <freeside> in a blockchain monad, the >>= would handle the crypto signatures and integration into blocks, and the functions would handle the intended ledger updates against specific keys.
21:26:28 <Cale> freeside: Well, what's the actual data type?
21:26:38 <Cale> freeside: Is fmap implementable?
21:26:55 <freeside> ":: or GTFO!"
21:26:58 <freeside> give me a moment to think it through
21:27:48 <Cale> There's surely some state-monad-like monads you could define which would be useful for implementing bitcoin-related stuff. But the blockchain itself? It seems doubtful.
21:27:55 <glguy> Any chance that the new "custom-setup" section in Cabal>=1.23 is documented somewhere?
21:28:12 <ezyang> glguy: I think we *just* added an entry to the manual 
21:28:17 <ezyang> but there's the blog post 
21:28:39 <ezyang> https://www.well-typed.com/blog/2015/07/cabal-setup-deps/ 
21:28:43 <glguy> thanks
21:29:07 <glguy> ezyang: Is it the case that custom-setup has exactly one field?
21:29:34 <ezyang> I believe so! 
21:29:51 <ezyang> The stated design reason was to make sure it was easy to build Setup executables 
21:30:18 <freeside> a single transaction can contain multiple inputs and outputs. so the type of a transaction would be something like `txn :: [(Key,Amt)] -> Ledger [(Key,Amt)]`
21:31:51 <freeside> so the Ledger monad is State-like
21:32:42 <freeside> i will go off and try to model this.
21:34:49 <eklavya> there was a post on haskell reddit about exception safety, aren't exceptions not recommended?
21:35:41 <glguy> exceptions are a regular part of doing IO in Haskell
21:36:22 <eklavya> ok but why, why not use error types?
21:36:36 <ezyang> eklavya: Asynchronous exceptions can't be handled that way 
21:36:53 <eklavya> ezyang: what are those?
21:37:24 <eklavya> IO actions happening in a different thread?
21:37:45 <ezyang> eklavya: Say you C-C a Haskell program. That turns into an async exception. 
21:38:05 <eklavya> C-C ?
21:38:15 <cromachina> control C
21:38:22 <eklavya> :P
21:38:24 <eklavya> oh
21:39:05 <eklavya> so all exception not generated in current thread?
21:40:00 <dmj`> eklavya: async exceptions arise from external influences, could be from another thread, could be from the operating system. 
21:40:35 <eklavya> I am worried now, I thought in haskell at least, everything will be visible in types :(
21:40:42 <dmj`> here's some examples, https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Exception.html#t:AsyncException
21:40:46 <eklavya> will this all only happen in IO ?
21:41:13 <cromachina> :t error
21:41:15 <lambdabot> [Char] -> a
21:41:22 <dmj`> eklavya: exceptions can arise in pure code, but only be caught in I/O, async exceptions can happen at any time
21:42:23 <eklavya> what happens if it arises in pure code?
21:43:01 <eklavya> propagation until caught in some IO?
21:43:03 <ezyang> eklavya: Operationally, execution stops and we unwind the stack frame until we find a catch handler 
21:43:03 <cromachina> the control stack is unwound to the next exception handler
21:43:50 <hrumph> what is the best way to deal with natural numbers in haskell?
21:43:54 <geekosaur> all pure code is ultimately run from IO (remember, main :: IO a)
21:44:00 <eklavya> so try catch everything?
21:44:03 <EvanR> does anyone know what the delta `lte` delta' means in this natural deduction-like notation https://ibin.co/2pgooZgVzAxz.png
21:44:25 <EvanR> on top of the bar are premises, on the bottom are conclusions, what about something off to the side
21:44:55 <EvanR> hrumph: for what purpose? computing? theres Numeric.Natural
21:46:04 <EvanR> if you want to use naturals on the type level look at the DataKinds exception which enables type level literals
21:46:10 <EvanR> DataKinds extension
21:48:14 <hrumph> EvanR, just for a lark i was making a version of the state monad that checks proofs, but I wanted to restrict the number type i was using to naturals
21:48:22 <hrumph> was/am
21:51:05 <EvanR> > 2 + 2 :: Natural
21:51:07 <lambdabot>  4
21:51:15 <EvanR> > 3 - 4 :: Natural
21:51:17 <lambdabot>  *Exception: Natural: (-)
21:52:08 <hrumph> EvanR where is the Natural type from?
21:53:44 <hrumph> data.natural, numeric.natural?
21:55:21 <EvanR> Numeric.Natural
21:56:11 <significance> Hey all! Noob here - I found this function (http://lpaste.net/172647) on LYAH. With it, `solveRPN "5"` happily returns "5". But good old `read "5"` gives a "no parse" error! Why does solveRPN work without an explicit numeric type?
21:56:48 <shachaf> You need to specify a type for (read "5")
21:56:58 <shachaf> If you're testing in ghci, it probably defaulted to ().
21:57:12 <significance> shachaf: I know - but why doesn't solveRPN need a type when it just parses "5"?
21:57:15 <glguy> solveRPN has both a Num constraint and a Read constraint
21:57:19 <glguy> read only has a Read constraint
21:57:59 <shachaf> If you're testing in ghci, it probably defaults to Integer.
21:58:08 <significance> glguy: how does solveRPN decide on Int then? wouldn't Float be just as viable for (Read a, Num a)?
21:58:28 <shachaf> It decides on Integer because of defaulting rules.
21:58:30 <glguy> significance: Because Haskell has some defaulting rules for ambiguous types
21:58:34 <shachaf> @where defaulting
21:58:34 <lambdabot> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4 https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/interactive-evaluation.html#extended-default-rules
21:58:35 <glguy> See section 4.3.4 of Haskell 2010
21:59:08 <significance> glguy, shachaf: you two are wonderful - thank you!
22:00:02 <significance> glguy, shachaf - any recommended reads after LYAH to fill in the technical gaps like that?
22:00:28 <significance> should I read through the 2010 report?
22:01:59 <ezyang> defaulting is in 98 too 
22:02:09 <glguy> It would probably be good to scan through the Haskell Report and note the stuff you don't understand. I don't know how prepared LYAH will have you for that, but it'll be useful to at least know what's in the language
22:02:29 <glguy> ezyang: I'm only citing 2010 because it's current, not because it's changed
22:02:33 <significance> glguy: awesome - thank you :)
22:02:49 <significance> so GHCI has `default (Integer, Double)` by default?
22:03:07 <glguy> GHCi has ExtendedDefaultRules by default, actually
22:03:26 <EvanR> > read "()"
22:03:28 <lambdabot>  ()
22:03:53 <significance> > read "5"
22:03:54 <lambdabot>  *Exception: Prelude.read: no parse
22:04:03 <EvanR> > defaulting to () seems kind of useless
22:04:05 <lambdabot>  <hint>:1:29: parse error on input ‘of’
22:04:21 <significance> read "( )"
22:04:27 <significance> > read "( )"
22:04:29 <lambdabot>  ()
22:04:31 <glguy> ExtendedDefaultRules seems to have been forgotten in the current GHC user's guide, or the search box isn't working well
22:04:41 <significance> glguy: I couldn't find it either - hrm
22:04:43 <hrumph> EvanR, compiler says it can't find numeric.natural
22:04:53 <EvanR> did you use caps?
22:05:10 <hrumph> EvanR, yes
22:05:19 <hrumph> in the docs it says its part of "base"
22:05:21 <EvanR> what version of ghc
22:05:38 <glguy> significance: It's in old versions of the guide https://downloads.haskell.org/~ghc/6.10.3/docs/users_guide.pdf if you search for that term
22:05:48 <glguy> I think it just got lost at some point
22:06:07 <hrumph> EvanR, 7.8.4. I don't have "base" in my cabal file. should i have it there?
22:06:17 <hrumph> wait i do have it there
22:06:27 <hrumph> ok base is there
22:06:28 <EvanR> 7.8 might be too old
22:06:51 <EvanR> well the version of base is the relevant thing here
22:07:41 <significance> glguy: ahhhh, so defaulting only happens when type constraints come into play?
22:08:51 <glguy> Yeah
22:09:33 <significance> glguy: so foo :: (Num a) a; foo = 5.0 would always return an int?
22:09:34 <EvanR> for something polymorphic without constraints defaulting is unnecessary because it works for all types
22:09:52 <glguy> significance: Actually, because you added that .0, it won't be an Int
22:10:05 <significance> glguy: ahhh, gotcha.
22:10:20 <glguy> significance: Also, the default is Integer, Double,    no Int in there by default
22:10:21 <significance> would the same function without the .0 default, or would it remain polymorphic?
22:10:30 <significance> glguy: oops, mixing my types :P
22:10:57 <glguy> and it will only default to a type if it would have been ambiguous when used
22:11:14 <EvanR> :t 5
22:11:15 <lambdabot> Num a => a
22:11:21 <significance> Ahh...
22:11:25 <significance> :t 5.0
22:11:26 <lambdabot> Fractional a => a
22:11:32 <significance> dang, Haskell is so cool
22:11:53 <curious> Hey, anyone know what the best way to search rewrite rules is?
22:12:11 <significance> > foo = 5
22:12:12 <lambdabot>  <hint>:1:5: parse error on input ‘=’
22:12:30 <significance> > foo :: Int
22:12:32 <lambdabot>      Not in scope: ‘foo’
22:12:32 <lambdabot>      Perhaps you meant ‘for’ (imported from Data.Traversable)
22:13:23 <significance> > foldl (+) 0 [1..100]
22:13:25 <lambdabot>  5050
22:13:47 <significance> Ahh, lambdabot is so incredible :)
22:14:02 <EvanR> its credible
22:14:12 * significance smirks :)
22:15:10 <EvanR> > foldl (+) 0 [1..100]
22:15:12 <lambdabot>      Ambiguous occurrence ‘foldl’
22:15:12 <lambdabot>      It could refer to either ‘L.foldl’,
22:15:12 <lambdabot>                               defined at /tmp/mueval13651805401540383426.hs:1...
22:15:16 <hrumph> EvanR, yeah i think i have base < 4.9 so i don't have Numeric.Natural
22:15:19 <EvanR> dang i was going to trick you
22:15:33 <EvanR> > L.foldl (+) 0 [1..100]
22:15:35 <vaibhavsagar> what happens when you ask lambdabot to calculate something like foldl (+) 0 [1..]
22:15:36 <lambdabot>  57
22:15:48 <vaibhavsagar> wut
22:15:52 <significance> hahaha
22:15:55 <EvanR> now its incredible
22:16:01 <significance> > L.foldl (+) 0 [1..]
22:16:03 <lambdabot>  57
22:16:03 <vaibhavsagar> > foldl (+) 0 [1..100]
22:16:05 <lambdabot>      Ambiguous occurrence ‘foldl’
22:16:05 <lambdabot>      It could refer to either ‘L.foldl’,
22:16:05 <lambdabot>                               defined at /tmp/mueval13651805401540383426.hs:1...
22:16:09 <EvanR> i broke it
22:16:11 <vaibhavsagar> how even
22:16:21 <vaibhavsagar> since it's borked anyway...
22:16:22 <significance> Apparently 1 + 2 + ... = 57.
22:16:26 <vaibhavsagar> > foldl (+) 0 [1..]
22:16:28 <EvanR> @undefine
22:16:28 <lambdabot> Undefined.
22:16:33 <lambdabot>  mueval: ExitFailure 1
22:16:51 <vaibhavsagar> I'm okay with this
22:16:57 <significance> foldl (*) 1 [1..]
22:17:07 <significance> > foldl (*) 1 [1..]
22:17:12 <lambdabot>  mueval-core: Time limit exceeded
22:17:13 <EvanR> foldl recurses to the end of the list before reducing anything
22:17:23 <vaibhavsagar> > foldl' (+) 0 [1..]
22:17:27 <lambdabot>  mueval-core: Time limit exceeded
22:17:34 <significance> Weird...
22:17:44 <EvanR> and foldl' on an infinite list will never end
22:17:57 <vaibhavsagar> neither will foldl though
22:18:10 <significance> unless it's 57.
22:18:13 <EvanR> @src foldl
22:18:13 <lambdabot> foldl f z []     = z
22:18:13 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:18:30 <vaibhavsagar> actually I had a question about that
22:18:45 <vaibhavsagar> I heard that foldr allows you to terminate early
22:18:54 <EvanR> @src foldr
22:18:54 <lambdabot> foldr f z []     = z
22:18:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:18:55 <dmj`> > foldl' (flip ($)) 0 [(+1), (*2)]
22:18:56 <lambdabot>  2
22:19:17 <dmj`> > foldr ($) 0 [(+1), (*2)]
22:19:19 <lambdabot>  1
22:19:22 <EvanR> foldr applies f first, so f can decide not to use the (foldr f z xs)
22:19:27 <dmj`> > foldl' (flip ($)) 0 (reverse [(+1), (*2)])
22:19:30 <lambdabot>  1
22:20:37 <vaibhavsagar> so if I have a function that doesn't use the second argument after a certain point, lazy evaluation means I'll terminate early?
22:20:48 <EvanR> > foldr (\x rest -> x) "cool" [1..]
22:20:50 <lambdabot>      No instance for (Enum [Char])
22:20:50 <lambdabot>        arising from the arithmetic sequence ‘1 .. ’
22:20:50 <lambdabot>      In the third argument of ‘foldr’, namely ‘[1 .. ]’
22:20:51 <vaibhavsagar> e.g. finding a certain value in a list
22:21:13 <EvanR> > foldr (\x rest -> x) 57 [1..]
22:21:14 <lambdabot>  1
22:22:19 <EvanR> vaibhavsagar: you always "terminate early" in this case, it helps to see some examples and also consider what evaluation does
22:22:36 <significance> :t **
22:22:37 <lambdabot> parse error on input ‘**’
22:22:40 <EvanR> when you ask for an answer it only evaluates what is necessary
22:22:42 <significance> :t (**)
22:22:43 <lambdabot> Floating a => a -> a -> a
22:22:50 <significance> ahh, that explains things
22:22:53 <vaibhavsagar> I think I understand
22:23:04 <significance> :t (/)
22:23:05 <lambdabot> Fractional a => a -> a -> a
22:23:07 <vaibhavsagar> so can I write a foldr that gives me the first 5 elements of a list?
22:23:12 <glguy> significance: You can play with lambdabot in /msg
22:23:22 <EvanR> yes
22:23:25 <significance> glguy: sorry :) just enjoying a new toy ;)
22:24:06 <EvanR> but if you only want the first two of THAT list, then youll still "terminate early"
22:24:29 <vaibhavsagar> right
22:25:01 <EvanR> aol keyword here is weak head normal form
22:25:17 <EvanR> > [1,2,3] ++ [4,undefined,5]
22:25:19 <lambdabot>  [1,2,3,4,*Exception: Prelude.undefined
22:25:49 <EvanR> it evaluated the elements of the answer up to undefined because i am asking the print them out in sequence
22:25:59 <vaibhavsagar> > take 3 $ 3 : [4,5,undefined]
22:25:59 <EvanR> it doesnt first compute the whole list
22:26:00 <lambdabot>  [3,4,5]
22:26:08 <vaibhavsagar> yeah, I understand
22:26:29 <vaibhavsagar> was just confused about how to apply that knowledge to foldr
22:26:51 <EvanR> if i dont want to print anything, then i can still conceptually "evaluate to weak head normal form" which would be like 
22:27:01 <EvanR> @src (++)
22:27:01 <lambdabot> []     ++ ys = ys
22:27:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
22:27:01 <lambdabot> -- OR
22:27:01 <lambdabot> xs ++ ys = foldr (:) ys xs
22:27:11 <EvanR> using top version
22:27:30 <EvanR> 1 : ([2,3] ++ [4,undefined,5])
22:28:53 <EvanR> try doing this sort of thing with foldr (:) ys xs
22:30:19 <koz_> > fmap (+ 1) (2, 3)
22:30:20 <lambdabot>  (2,4)
22:30:25 <koz_> A-ha!
22:30:48 <EvanR> > fmap (+1) ("cool", 3)
22:30:50 <lambdabot>  ("cool",4)
22:33:20 <koz_> I never remember whether fmap applies to the second or first element.
22:33:38 <vaibhavsagar> It's like Either
22:33:43 <vaibhavsagar> fmap applies to right
22:34:50 <ezyang> The other way to remember is that (a,b) = (,) a b 
22:34:57 <ezyang> and you can only ever be a functor on the *last* type argument 
22:35:04 <ezyang> because HAskell has no type level lambda 
22:36:02 <koz_> ezyang: That's a really cool way of remembering it - thank you!
22:36:16 <koz_> (also, I wish Vector has an iall and an iany)
22:36:22 <koz_> (like it has imap)
22:36:38 <lolisa> Hi, what combinator do I need to get a turing complete language, if I do not have application, only compose?
22:36:56 <ezyang> lolisa: Look up SKI calculus 
22:37:22 <lolisa> I know SKI, but I doubt if SKI - app + compose is turing complete...
22:38:08 <ezyang> Oh I misunderstood 
22:38:11 <Xpalo> what are you working on that this came up, i am curious
22:38:27 <Xpalo> lolisa... if you dont mind sharing
22:38:42 <Xpalo> sounds potentially interesting
22:39:07 <lolisa> So I am trying to make a language where all stuff are typed function, and they are in finally tagless style, so I cant get an app
22:39:37 <lolisa> But I do have compose, and I want it to be turing complete for obvious reason
22:39:42 <Xpalo> how did you arrive here tho, i wonder the application that drove you to the design
22:39:55 <ezyang> Why can't you have app in finally tagless 
22:40:19 <ezyang> To have app, you embed a *recursive* occurrence of your tagful type 
22:40:34 <ezyang> data Expr = Plus Expr Expr 
22:41:47 <lolisa> The exp need double argument, instead of the usual single argument one in typed finally tagless style... ezyang, I dont get it, could you care to provide some ref or explain?
22:42:09 <ezyang> What reference are you using for finally tagless 
22:46:03 <lolisa> ezyang, those in http://okmij.org/ftp/tagless-final/course/TTF.hs
22:46:40 <ezyang> Oh, maybe I understand the intent of your question more 
22:47:03 <ezyang> so, essentially, you don't want to use the HOAS style lam/app? 
22:47:17 <lpaste> koz_ pasted “Can I collapse these patterns?” at http://lpaste.net/172653
22:47:49 <ezyang> koz_: You could use the maybe combinator 
22:48:00 <ezyang> maybe True (== HS.member n 1) 
22:48:06 <koz_> ezyang: That would work - thanks!
22:48:14 <koz_> It lives in Data.Maybe,r ight?
22:48:17 <ezyang> yep 
22:48:49 <lolisa> no, I dont have repr that map type to representation, I have an arrow : Type -> Type -> Type... And all values in the languages are function, no double, string, etc for eval (of course we still can prettyprint with pp = _ -> _ -> String)
22:49:39 <koz_> :t maybe
22:49:40 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:49:44 <ezyang> Maybe you should post some code 
22:50:46 <lolisa> Yes, but I dont know, it is close sourced... And in large chunk of scala... I will ask for premission
22:51:15 <ezyang> Maybe you can rewrite the core of your interpreter in Haskell 
22:51:20 <ezyang> it shouldn't be too large 
22:53:50 <lolisa> yes, I got permission, please wait for about 30 minutes... cause I cant really write haskell :(
22:55:55 <gfixler> I'm looking for some insight around folding with failure
22:56:04 <gfixler> my toy example is scoring a bowling game
22:56:14 <gfixler> presented initially as [Int] rolls
22:56:36 <lolisa> Oh hey, I think that's why I cant have app, can you elaborate?
22:57:23 <ezyang> lolisa: I don't understand 
22:58:18 <lolisa> It's a 100 line of scala code, do you need me to translate it to haskell?
22:58:43 <gfixler> e.g. if I had a small game of [2,8,3,4], that should turn into [Spare 2, Open 3 4]
22:59:03 <gfixler> I can write a score1 to look at the front of the list and return the appropriate frame, along with the remainder
22:59:13 <EvanR> sounds like you need a parser
22:59:16 <ezyang> lolisa: Well, I'm trying to understand why you can't use app straight from the first example from Oleg 
22:59:24 <gfixler> EvanR: yeah, it's starting to as I'm describing it :)
22:59:47 <gfixler> so maybe fold isn't what I should be trying to solve
22:59:54 <EvanR> with 1 lookahead
23:00:15 <gfixler> is that something special?
23:00:25 <EvanR> i dont think so
23:00:27 <gfixler> I thought parsers on lists could just match on (x:y:ys)
23:00:31 <EvanR> you can also write a recursive function
23:00:32 <gfixler> where needed
23:00:35 <gfixler> true
23:00:47 <gfixler> but it got me wondering about the idea in the abstract
23:00:56 <gfixler> is there something with fold-like powers that can fail the entire fold?
23:01:14 <EvanR> why do you need that for this?
23:01:23 <gfixler> I'm not sure I do
23:01:29 <gfixler> I also don't need to score bowling, though
23:01:57 <lolisa> ezyang, all my stuff are Arr SomeT OtherT, and I dont have SomeT floating around...
23:01:57 <gfixler> but it's probably worth reexamining
23:02:12 <gfixler> I may have just looked at the fold idea for so long that it feels important now :)
23:02:30 <gfixler> EvanR: oh, I know one reason it's interesting
23:02:59 <ezyang> gfixler: foldM? 
23:03:10 <gfixler> ezyang: oh, maybe
23:03:14 <gfixler> toFrame1 :: [Int] -> Maybe (Frame, Bonus, [Int])
23:03:28 <ezyang> lolisa: Sorry, I don't understand :( 
23:03:37 <ezyang> I don't know what an Arr SomeT OtherT is 
23:03:59 <EvanR> gfixler: a small recursion over the list, matching on 0 1 or 2 elements seems pretty simple
23:04:09 <EvanR> foldM sounds like itll be more complicated
23:04:29 <EvanR> er matching 2 1 or 0
23:04:32 <gfixler> EvanR: well, I've done that, too, a few times, while playing with this idea
23:04:42 <gfixler> but even that has a problem
23:04:51 <gfixler> because a recursive function is still sort of like a fold
23:04:58 <gfixler> once I foo : recursive call
23:05:07 <gfixler> I can't get back outside that first cons to say the whole thing failed
23:05:27 <gfixler> so the point was to end up with a Success [Frame], or Failure, of some sort
23:05:47 <EvanR> im still not clear why the whole thing fails, because its an invalid game?
23:05:49 <lolisa> it is repr, but with two argument, should I get you some scala code, or would you like it better if I translate it to haskell?
23:06:00 <EvanR> then maybe you should use a parser
23:06:03 <gfixler> EvanR: [2,9] - that's 2 rolls that exceed 10
23:06:05 <gfixler> not possible
23:06:16 <gfixler> [-4,3] - can't have negatives
23:06:23 <gfixler> etc
23:06:43 <EvanR> x <- score -- makes sure its at least 0 - 10
23:06:43 <gfixler> so, given [Int], I want to convert to [Frame], which is properly bounded
23:06:50 <gfixler> EvanR: yes, I've done all that
23:06:57 <ezyang> lolisa: I can't really read this level of Scala code. Also this is #haskell :o) 
23:06:58 <gfixler> writing it like an imperative programmer works fine, in multiple ways
23:07:03 <gfixler> I've probably implemented it 5 different ways now
23:07:08 <gfixler> I was trying to find something FP and more elegant
23:07:13 <EvanR> if x == 10 then strike : recurse else ...
23:07:15 <ezyang> I hope it's not much. Hopefully you can just do the three constructors which get at the core of the problem 
23:07:21 <ezyang> it might help you solve it yourself 
23:07:50 <EvanR> gfixler: its sort of like wondering how to rewrite a parsec parser more functionally, itll be ugly as hell
23:07:52 <gfixler> EvanR: I've heard your message
23:08:10 <lolisa> I know, but I doubt if scala programmer employ finally tagless... I will translate.
23:08:38 <gfixler> EvanR: I was looking for something like "magicmorphism" that's encapsulates the idea of failing folds
23:08:56 <EvanR> parsec ;)
23:09:08 <gfixler> EvanR: yeah, probably, but it doesn't hurt to ask
23:09:17 <EvanR> [Token] -> Maybe (a, [Token])
23:09:25 <gfixler> toFrame1 :: [Int] -> Maybe (Frame, Bonus, [Int])
23:09:34 <gfixler> that's what my toFrame1 is
23:09:40 <EvanR> yes
23:09:44 <ezyang> no promises ;) 
23:09:49 <gfixler> wanted to write simple functions that parse one thing
23:09:52 <gfixler> alternative them together
23:10:01 <gfixler> and then run them through something magical, like a fold
23:10:07 <gfixler> I suppose I need to bone up on parsers finally
23:10:16 <EvanR> well, you combine them with >>= 
23:10:19 <gfixler> which parser does this feel like?
23:10:30 <EvanR> and the final thing is [Token] -> Maybe (a, [Token])
23:10:33 <EvanR> so you just apply that
23:10:40 <gfixler> right now I have: toFrame1 rs = strike rs <|> spare rs <|> frame rs
23:10:43 <gfixler> works great
23:10:45 <gfixler> but can't handle failure
23:10:50 <gfixler> unless I move failure into everything
23:10:54 <EvanR> the failure is the monad part
23:10:57 <EvanR> or applicative
23:11:03 <Xpalo> oh
23:11:04 <Xpalo> no
23:11:05 <gfixler> if strike, spare, frame, etc., all know about failure, then it works
23:11:10 <Xpalo> you need Alternative
23:11:17 <EvanR> thats why they are all Maybes
23:11:38 <gfixler> I also tried adding a failure constructor to the Frame type
23:11:40 <Xpalo> gflixer, you know Control.Applicative.Alternative ?
23:11:47 <gfixler> and when something failed, it would move the rest of the list into the failure
23:12:01 <gfixler> so it would succeed in the fold, but the semantics were a bit wonky
23:12:08 <Xnuk> Is there right-associative version (&)? Or should I make it?
23:12:10 <EvanR> this isnt really about folds
23:12:11 <gfixler> Xpalo: yes, but I'm no expert
23:12:25 <EvanR> its just combining functions of the form [Token] -> Maybe (a, [Token])
23:12:26 <ezyang> gfixler: Here's what you should do. Treat each score as a "Command" and define a small interpreter for this command language 
23:12:48 <gfixler> EvanR: feels an awful lot like some kind of cata/ana/hylo something to me
23:12:49 <EvanR> http://www.willamette.edu/~fruehr/haskell/SeussFinal2.JPG
23:13:07 <EvanR> gfixler: when you combine functions of that form, theres no folding left to do
23:13:14 <EvanR> it just works
23:13:27 <gfixler> not sure I understand that
23:13:41 <EvanR> the extra [] in that image is just for trying different branches
23:13:48 <EvanR> but you dont need to
23:13:51 <EvanR> in this case
23:13:57 <gfixler> right
23:14:06 <gfixler> I've done a little of this, but still not comfy
23:14:27 <EvanR> type Parser a = [Int] -> Maybe (a, [Int])
23:14:31 <EvanR> now you an write a function
23:14:35 <gfixler> okay, well, I think that answers my question for now - this doesn't look like a known morphism
23:14:49 <EvanR> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
23:14:55 <gfixler> and I'm in the parser world
23:15:09 <gfixler> EvanR: yeah, I've even implemented Monad for Parser a
23:15:11 <EvanR> running the final parser is just application
23:15:12 <gfixler> been a while, though
23:15:41 <EvanR> you can finalize your algorithm by checking that the stream ends up being empty
23:16:00 <EvanR> that will make sure game doesnt last too long
23:16:05 <gfixler> EvanR: ah, that may be the answer - parse as far as possible, then check result?
23:16:35 <EvanR> thats just a bell/whistle
23:16:45 <EvanR> not the core idea here
23:16:58 <gfixler> what's a bell?
23:17:07 <EvanR> ornamental feature
23:17:18 <gfixler> I mean which thing that we've brought up is the whistle
23:17:31 <EvanR> if you take 10 before passing the data in, youll never end up with unconsumed data
23:17:43 <EvanR> so probably dont even need to check
23:17:52 <gfixler> there are a variable number of frames in a game of bowling
23:18:03 <EvanR> oh
23:18:05 <gfixler> sorry, varying number of rolls
23:18:10 <gfixler> and they combine in various ways, depending on value
23:18:15 <EvanR> right
23:18:40 <gfixler> maybe this will end up being a hylomorphism, but I'm not smart enough yet to know
23:18:45 <EvanR> so you do need to keep checking that you arent going too far
23:19:06 <gfixler> yeah, that's true, I'm not even checking that the game isn't too long or too short
23:19:31 <gfixler> but I was thinking that I'd rather have the scorer take arbitrary length games
23:19:46 <gfixler> it's easy to imagine a 5-frame, or 30-frame game
23:20:03 <gfixler> something else could verify that once converted from rolls to frames, that there are the proper number of frames
23:20:23 <gfixler> there's also the question of bonuses
23:29:21 <Axman6> anyone know if there are tools which can look at a project, and offer suggections of modules you should refactor into a common imports only module because you use them everywhere? I feel I import bytestring, text, hashmap, lens and plenty more all the time, and hate having such huge import lists
23:29:56 <Axman6> I guess a tool that just gives tells you how many times each module is imported would be helpful
23:33:14 <ezyang> Axman6: Sounds easy enough to hack up in some perl ;) 
23:33:24 <Axman6> ew :(
23:33:44 <Axman6> sounds easy enough to hack up in Haskell...
23:34:08 <ezyang> like, it doesn't have to be sound 
23:34:37 <Axman6> yeah, but haskellers expect better
23:35:38 <Axman6> probably pretty easy to hack together with grep and awk or something
23:36:49 <Axman6> or, even just find, grep and sort
23:37:47 <mniip> don't forget uniq -c
23:38:02 <Axman6> yes, that's what I was after
23:50:11 <ezyang> lolisa_: So. 
23:50:26 <ezyang> In general, you cannot get TC computation out of arithmetic circuits 
23:50:50 <lolisa_> Here is the first attempt at the problem, without arrow thingy: http://goo.gl/DG6C0G 
23:50:51 <ezyang> you need "feedback", but that would defeat the ponit of your code 
23:51:42 <koz_> Is there a reason why unboxed Vectors are not Functors?
23:52:37 <lolisa_> I thought it might be possible to have more then arithmetic circuits and TC in that way (for example, adding SKI, which is what I did)
23:53:06 <ezyang> In work for computing on circuits, the classic way to solve this is to do loops in the metalanguage, unfolding the circuit as far as necessary 
23:53:20 <ezyang> Well yes, but you probably can't backprop with those combinators, right? ;) 
23:55:06 <lolisa_> I dont know, but combinators are constant that dont change values, so maybe we just need to preserve the input, patch, and backprop to the real 'handler', like sum...
23:56:16 <ezyang> At least in SKI, S is a higher order combinator 
23:56:17 <mniip> koz_, because there's no uniform fmap
23:56:35 <ezyang> There is no combination of first order combinators which will get you TC. By induction. 
23:57:50 <lolisa_> Does it sounds possible to make it higher order?
23:58:26 <koz_> mniip: Sadface.
23:58:39 <lolisa_> Or will adding Y (with infinite first order SKI) solve the problem?
23:58:48 <koz_> I guess in this case I'll have to do crazy shit involving toList -> do stuff -> fromList.
