00:00:00 <joobus> running decode from Data.Aeson and drilling down a couple levels of the json structure.
00:00:09 <Cale> joobus: If you have a function f :: ByteString -> Maybe [Whatever], you can return (f v)
00:00:27 <Cale> and the do-block will have type IO (Maybe [Whatever])
00:00:42 <joobus> k, I will try that
00:03:21 * hackagebot hw-bits 0.0.0.8 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-bits-0.0.0.8 (haskellworks)
00:05:42 <dnivra> Hello! I'm trying to write an Applicative instance for a custom datatype and test it using checkers(code: http://lpaste.net/172866). When I test it using ghci using 1st input(http://lpaste.net/172867), I get an error but the second one works fine. Could someone help me understand why first input doesn't work?
00:05:55 <Cale> saurabhnanda: I believe if you use UPDATE ... RETURNING ... it uses the post-update values of the columns
00:07:22 <Cale> dnivra: What's the definition of applicative?
00:07:28 <Cale> and what is its type?
00:09:48 <Cale> saurabhnanda: Oh, I see, it's some trick involving joining in another copy of the table, hm
00:16:13 <wolfperson> is anyone still up
00:16:20 <dnivra> Cale: Ah right I see in applicative's type signature it accepts an "m (a, b, c)" so Identity ((), (), ()) makes sense. But I'm confused about the Sum type(code: http://lpaste.net/172870, testing: http://lpaste.net/172872). Could you take a look at it?
00:17:17 <dnivra> The only difference I see is that Identity is defined using newtype while Sum is defined using data. I'm not sure if that matters though.
00:17:33 <Cale> The other difference is what everything does ;)
00:17:46 <Cale> What are you confused about?
00:18:21 * hackagebot atlassian-connect-descriptor 0.4.4.0 - Code that helps you create a valid Atlassian Connect Descriptor.  https://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.4.0 (RobertMassaioli)
00:19:30 <fr33domlover> wolfperson, in some places it's morning
00:19:32 <Cale> dnivra: The idea here is that First e might represent an "error"
00:19:59 <Cale> while Second x represents some successfully computed value
00:20:14 <joobus> does anyone have experience drilling down a couple levels of a json to get a value without defining a structure first?  Something like `items <- data .: "first_thing" .: "second_thing"`?
00:20:38 <Axman6> lens-aeson makes doing that trivia
00:20:44 <Cale> dnivra: In fmap, we just propagate the error without applying the function (note that we actually can't apply the function in that case, see if you can figure out why)
00:20:56 <Axman6> data ^. key "first_thing" . key "second_thing"
00:21:10 <Cale> dnivra: But if it's a successful result (Second), we apply the function.
00:22:26 <joobus> Axman6: thanks, I'll check it out
00:22:28 <Cale> Similarly with (<*>), if either argument to (<*>) is an error (First), we propagate the error, while if they're both Second, we produce a successful result which has the function from the left argument applied to the value from the right argument
00:25:22 <Cale> joobus: Note also that aeson's parser type is a monad, so you can write something like  do v <- data .: "first_thing"; w <- v .: "second_thing"; return ...
00:26:29 <dnivra> Cale: Ah I see. It makes sense now why First e works in case of Sum. It's a result of how the applicative instance works :). I also tried "Second 1" just now and sure enough, same error as what I observed in "Identity 1"
00:27:10 <dnivra> (And of course, that's how First should work: it's related to the error propagation like how you described)
00:31:12 <saurabhnanda> Cale: Yes, the default behaviour of RETURNING is to return the new row. The stuff on SO seems like a trick which just happens to work. Undefined behaviour.
00:36:50 <saurabhnanda> Cale: do you have any thoughts about https://gist.github.com/saurabhnanda/2271b5e1af2af77db9db9f6e14f5c12c
00:39:46 <Cale> I don't really have experience with this kind of global logging you're talking about, so I don't really know what the right model would be. However, if the fact that record accesses are not IO actions is a problem, perhaps they ought to be IO actions ;)
00:39:50 <freeside> saurabhnanda: is your underlying DB bitemporal?
00:40:19 <saurabhnanda> freeside: what do you mean? I'm new to this term -- bitemporal. It's Postgres. Is it bitemporal?
00:40:36 <freeside> https://en.wikipedia.org/wiki/Temporal_database
00:41:11 <freeside> this may be a useful abstraction for you to consider
00:41:14 <saurabhnanda> ah got it
00:41:23 <saurabhnanda> There's an amazing book about this
00:41:33 <saurabhnanda> using SQL to model entities changing with time
00:41:39 <saurabhnanda> I think it was written before this term was coined
00:42:14 <saurabhnanda> freeside: so are you saying it's better to use a bitemporal database (or a bitemporal schema) instead of using the audit log approach?
00:42:16 <freeside> rather than having to be bolted on, audit logs are an intrinsic property of a bitemporal database.
00:42:52 <freeside> when i learned about temporal DBs my reaction was "oh, this is the thing whose lack i have been working around"
00:42:56 <saurabhnanda> freeside: which means every single access to the DB needs to have a valid-time WHERE clause
00:43:08 <saurabhnanda> freeside: what would it do to the DB perf? during reads and writes?
00:43:35 <freeside> that has probably been considered by the https://wiki.postgresql.org/wiki/SQL2011Temporal movement
00:43:51 <freeside> http://clarkdave.net/2015/02/historical-records-with-postgresql-and-temporal-tables-and-sql-2011/
00:44:36 <freeside> so, i don't know the exactly answer to your question, but i think it is somewhere on the range of [feasible .. best-practice]
00:44:45 <freeside> s/ly//
00:45:07 <saurabhnanda> freeside: thanks! didn't know about that. But is it anywhere on the near-term roadmap?
00:45:57 <saurabhnanda> freeside: let me investigate the temporal approach in parallel. In the meantime, do you have any feedback on the three approaches I have outlined?
00:49:18 <freeside> i'm afraid i lack the domain expertise to offer a useful opinion, but my general preference is to avoid adding epicycles; sometimes the right place to introduce an abstraction is in the db itself, or somewhere nearer to it than even the application infra code.
00:49:37 <freeside> for instance, https://sivers.org/pg may inspire you to put the audit log code in the DB rather than Haskell.
00:49:59 <freeside> sorry i can't say anything useful about the question you specifically posed.
00:50:32 <saurabhnanda> second TIL: epicycle :)
00:51:12 <parsnipM_> they're not wrong
00:52:21 <saurabhnanda> parsnipM_: was that for me?
00:52:30 <ertes> i'd like to learn the haskell community's general attitude toward a security-related topic
00:54:03 <ertes> 1. trust RDRAND, a prioprietary hardware-based random number generator, 2. trust /dev/urandom, an open source one that gathers entropy from a number of sources, including RDRAND, if available
00:54:05 <parsnipM_> saurabhnanda: yeah, i thought we were talking about the overly complicated mathematcial representation of the heavens, that might be correct, but egregiously inelegant. 
00:54:08 <ertes> your pick?
00:54:41 <parsnipM_> flip a coin
00:54:47 <saurabhnanda> parsnipM_: no, they'r right. But just new terms/jargon for me.
00:55:19 <saurabhnanda> parsnipM_: actually, the core discussion was not around terminology but building audit logs in Persistent -- https://gist.github.com/saurabhnanda/2271b5e1af2af77db9db9f6e14f5c12c
00:55:36 <freeside> http://reinh.com/blog/2008/07/20/adding-epicycles-copernicus-on-software-development.html
00:55:51 <ertes> background: we have two major crypto implementors, and both would prefer number 1 for absurd or even no reason at all
00:55:59 <piyush-kurur> ertes: I trust /dev/urandom.
00:57:00 <piyush-kurur> not only that I distrust anything close source (RDRAND included)
00:57:23 <piyush-kurur> some times there is not much option for example the firm ware of your wifi card
00:57:30 <freeside> i think the correct way to resolve this issue is to hash both rdrand and /dev/urandom, and whichever one produces the longest sequence of 1s in a row within a 10 minute period is the winner
00:57:41 <piyush-kurur> but if possible avoid closed source
00:57:54 <piyush-kurur> freeside: things are not so simple
00:58:20 <ertes> freeside: also it's redundant: urandom already includes RDRAND, if it's available, and it's mixed in a trustworthy way
00:58:42 <ertes> here is today's RDRAND issue: https://github.com/haskell-crypto/cryptonite/issues/94
00:58:56 <piyush-kurur> if you naively hash /dev/urandom + rdrand you can be less secure
00:59:10 <ertes> after turning my back on TomMD's crypto libraries, i found that vincent's libraries make the same mistake, and he is just as difficult to talk to about it
00:59:23 <joobus> zomg, I finally fetched a json value 2 levels down...
00:59:27 <joobus> :P
00:59:49 <piyush-kurur> ertes: I will love to have your feedback on raaz. A library I am developing
00:59:51 <saurabhnanda> joobus: lenses to the rescue?
01:00:05 <joobus> no, I just used the Parser monad
01:00:14 <mniip> huh
01:00:44 <fr33domlover> joobus, how / why? If you don't want lenses you can use regular map lookup
01:00:50 <ertes> piyush-kurur: is it what it says?  a *network* library?  because there is no network dependency
01:00:52 <fr33domlover> inside MaybeT to avoid ugly code
01:00:53 <zomg> joobus: grats
01:00:58 <saurabhnanda> joobus: are you starting out with Haskell/Aeson? 
01:01:08 <piyush-kurur> ertes: the network part will come
01:01:09 <joobus> yes
01:01:25 <ertes> piyush-kurur: if it's a crypto library, i'd not just review it, but even contribute to it…  i suggest making the networking part a separate library
01:01:27 <piyush-kurur> you can see a raaz-ssh package in the git repository
01:01:27 <mniip> adjoint functors: hom(FX, Y) = hom(X, FY), seem strikingly similar to adjoint linear maps: Fx.y = x.Gy
01:01:34 <saurabhnanda> joobus: I struggled with this phase as well. Finally I gave up and went with the flow. It's easier to simply define a data-type for every level of nesting in your JSON.
01:01:56 <piyush-kurur> ertes: I agree the network part will be separate
01:02:16 <piyush-kurur> but there is some code that can be common to a lot of network protocols apart from the primitives
01:02:16 <joobus> saurabhnanda: I've looked at the lens library, but I don't think I'm ready for that yet.
01:02:26 <piyush-kurur> like basic packet parsing
01:02:47 <saurabhnanda> joobus: do you need to **parse** a nested JSON or **access** a pre-parsed nested JSON
01:02:56 <piyush-kurur> ertes: I will be happy to have your contributions
01:02:58 <saurabhnanda> joobus: I went crazy when I tried to parse something with a the Parser monad manually
01:03:47 <piyush-kurur> If you want to concentrate on raaz then hop on to #haskell-raaz and we can discuss there
01:04:03 <joobus> I basically did what Cale suggested.  d <- json .: "first_thing"; c <- d .: "second_thing"; return c
01:04:48 <saurabhnanda> joobus: okay. so you're accessing the JSON like you would in python/ruby
01:05:34 <joobus> saurabhnanda: there is a list of things 2 levels down in a json api I'm fetching.  I didn't want to write out the records for the first 2 levels, but I will write a record for the item type that actually makes up the list.
01:06:19 <freeside> https://hackage.haskell.org/package/aeson-lens-0.5.0.0/docs/Data-Aeson-Lens.html
01:06:35 <saurabhnanda> joobus: okay. As I said, I tried struggling and taking short cuts and eventually just defined a data-type for everything.
01:07:04 <fr33domlover> You can parse JSON into a 'Value'
01:07:12 <fr33domlover> no need for dedicated type just for a simple lookup
01:07:24 <joobus> fr33domlover: that's what I did
01:10:01 <freeside> this sounds like a perfect opportunity to learn lenses
01:11:33 <parsnipM_> situation X: trying to do Y, uses Z, motivation to learn Z... but i always end up thinking, "i need to continue learning A, B, C, ....". 
01:11:45 <joobus> freeside: baby steps
01:12:48 <parsnipM_> although, whatever i'm doing, has pushed me into Data.Map, and once in a while i get closer to trying Sequence or Vector. 
01:13:03 <parsnipM_> but i won't until i "have to". 
01:53:43 <mniip> Set doesn't have coconstant morphisms does it
01:54:00 <mniip> hmm, maybe towards a terminal set
02:03:24 * hackagebot compound-types 0.1.3.1 - Sum and Product types and such  https://hackage.haskell.org/package/compound-types-0.1.3.1 (NikitaVolkov)
02:07:37 <mniip> Sum7! just what I was looking for
02:18:25 * hackagebot operational 0.2.3.3 - Implementation of difficult monads made easy  with operational semantics.  https://hackage.haskell.org/package/operational-0.2.3.3 (HeinrichApfelmus)
02:23:25 * hackagebot hw-prim 0.0.3.5 - Primitive functions and data types  https://hackage.haskell.org/package/hw-prim-0.0.3.5 (haskellworks)
03:41:45 <freeside> quiet day today on #haskell. i assume everybody's code is flowing smoothly from brain to keyboard to IDE, compiling perfectly the first time, and running with no bugs.
03:50:44 <dysfun> yeah, that's definitely what's not happening here
04:03:28 * hackagebot gipeda 0.3.2 - Git Performance Dashboard  https://hackage.haskell.org/package/gipeda-0.3.2 (JoachimBreitner)
04:58:29 * hackagebot instant-generics 0.6 - Generic programming library with a sum of products view  https://hackage.haskell.org/package/instant-generics-0.6 (JosePedroMagalhaes)
05:18:26 <maybefbi> what does it mean hasql to have an sql statement "be prepared": https://hackage.haskell.org/package/hasql-0.19.14/docs/Hasql-Query.html#v:statement
05:18:36 <maybefbi> s/mean/mean in/
05:19:35 <liste> https://en.wikipedia.org/wiki/Prepared_statement
05:21:36 <maybefbi> liste, danke
05:30:09 <cocreature> is rtsSupportsBoundThreads the proper way to figure out if my program was compiled with the threaded runtime?
05:38:31 * hackagebot transient 0.4.2 - Making composable programs with multithreading, events and distributed computing  https://hackage.haskell.org/package/transient-0.4.2 (AlbertoCorona)
05:38:31 <Phyx-> cocreature: yup https://github.com/ghc/ghc/blob/db9de7eb3e91820024f673bfdb6fb8064cfed20d/rts/Threads.c
05:38:33 * hackagebot transient-universe 0.3.2.1 - Remote execution and map-reduce: distributed computing for Transient  https://hackage.haskell.org/package/transient-universe-0.3.2.1 (AlbertoCorona)
05:39:27 <cocreature> Phyx-: great, thanks!
05:48:31 * hackagebot ghcjs-hplay 0.3.4 - Client-side web EDSL for transient nodes running in the web browser  https://hackage.haskell.org/package/ghcjs-hplay-0.3.4 (AlbertoCorona)
05:59:56 <maybefbi> is hasql prone to sql injection at the parameters? do i have to sanitize inputs?
06:31:26 <orion> In this paste, can lines 10-11 be combined in to a one-liner?: http://lpaste.net/9145350451229622272#line10
06:32:41 <mniip> orion, second updateState <$> decryptAndIncrement "" x cs
06:33:45 <orion> mniip: Oh, cool. Thanks. My initial thought was to do this: return $ (second updateState) =<< (decryptAndIncrement "" x cs) -- Why is this logic incorrect?
06:34:34 <bergmark> replace ($) with (.) and it should work
06:34:39 <mniip> ^
06:35:14 <maerwald> (return $ second updateState) =<< (decryptAndIncrement "" x cs) -- should typecheck I think
06:35:22 <mniip> no
06:36:15 <mniip> anyway
06:36:25 <mniip> (return . x) =<< f
06:36:28 <mniip> is the same as f <$> x
06:36:35 <mniip> because monad laws
06:43:10 <mightybyte> Are there any weekend haskell hackathon events coming up in Europe in the near future?
06:50:33 <saurabhnanda> how do I something like this? http://lpaste.net/172941 -- I'm trying to make invalid states impossible to represent in my code
06:51:26 <cloudhead> is it possible to use pattern synonyms to alias a data type and all of its constructors somehow?
06:51:43 <cloudhead> without having to alias each constructor individually
06:52:53 <fizruk> mightybyte: MuniHac
06:53:21 <fizruk> mightybyte: http://munihac.de
06:53:23 <cloudhead> saurabhnanda: DownloadStatus = DownloadComplete ChildrenStatus | DownloadIncomplete
06:53:39 <mightybyte> fizruk: Great, thanks!
06:53:54 <saurabhnanda> cloudhead: ah... thanks
06:54:20 <cloudhead> saurabhnanda: it's not /exactly/ what you're asking, but I think it's pretty close
06:54:30 <maerwald> cloudhead: I don't know of a way. You probably want to allow pattern matching without exporting the constructors (e.g. because you have smart-constructors)?
06:54:34 <cloudhead> since the ChildrenNone will be inferred instead of explicit
06:55:15 <saurabhnanda> cloudhead: that's fine... that's the actual invariant. If download is incomplete, it CANNOT have any children.
06:55:29 <cloudhead> maerwald: hmm so the only way is to write a new data type and a conversion function
06:55:33 <cloudhead> saurabhnanda: yeah
06:56:22 <maerwald> cloudhead: I do that too https://git.io/vKjVE but it sucks, because exhaustiveness check for patternsynonyms is broken
06:58:37 <cloudhead> ah didn't know that :/
06:59:23 <maerwald> https://ghc.haskell.org/trac/ghc/ticket/8779
07:01:13 <cloudhead> wow this has been open for a while
07:02:53 <rvlander> Hi, I want to use Websockets package. I am wondering if there is a way to identify connections
07:03:04 <rvlander> https://hackage.haskell.org/package/websockets-0.9.7.0/docs/Network-WebSockets-Connection.html#t:Connection
07:07:37 <orion> mniip / bergmark / maerwald: Thank you.
07:48:35 * hackagebot cloud-haskell 0.3.0.0 - The Cloud Haskell Application Platform  https://hackage.haskell.org/package/cloud-haskell-0.3.0.0 (FacundoDominguez)
07:52:16 <ggVGc> I miss haskell a lot, after writing Elixir for a few days :(
08:06:17 <Squarism> you can follow a case-of pattern with boolean guards ie : case bla | exp -> ...; | not exp -> ... ; i wonder if you can do this in form of "decision trees" so to speak  
08:06:26 <Squarism> ...to avoid repeating some criteria
08:09:29 <ggole> Squarism: your concern here is the duplication of exp?
08:09:48 <ggole> Or the cost of evaluating it twice?
08:10:06 <Squarism> ggole, well lets say i have exp1..exp3
08:10:53 <Squarism> never mind
08:11:01 <Squarism> i understand its sort of pointless
08:11:46 <ggole> Seems like a reasonable enough question
08:13:17 <Squarism> well it would avoid restating a criteria 
08:15:09 <ggole> You could factor it out into a local function
08:15:15 <ggole> let f x = True in case 1 of x | f x -> 0; x | not (f x) -> 1
08:15:18 <ggole> Or something like that
08:16:04 <Squarism> http://lpaste.net/172954
08:16:20 <Squarism> theres an explaination of it
08:16:26 <hpc> the not case is better written as otherwise
08:16:26 <Squarism> ..what i would wish for
08:16:28 <hpc> @src otherwise
08:16:28 <lambdabot> otherwise = True
08:16:36 <Squarism> ok
08:17:00 <hpc> it's basically the guard form of "else"
08:17:23 <Squarism> you get my idea?
08:18:18 <hpc> ah
08:19:06 <hpc> i don't know of a nice way to write that
08:19:23 <ggole> This is or-patterns for guards, isn't it?
08:19:24 <hpc> other than to just do it the verbose way with explicitly nesting them
08:19:32 <ggole> I don't think that ML pattern matching works well for that.
08:19:35 <Squarism> i dont know if it makes things much clearer
08:19:48 <ggole> (In general.)
08:20:17 <Squarism> guards are supposed to be syntactic sugar as far as i understand
08:20:23 <Squarism> so maybe not possible
08:21:06 <ggole> You could collect the bools in a tuple and match on them
08:21:44 <Squarism> i guess, unclear if it enhances readibilty
08:22:18 <ggole> It would allow the nesting you asked for, but I agree that it would probably not turn out easy on the eyes.
08:24:41 <Squarism> talking of pattern matching. is there a way to match using a "value" like : case .. of ; Just *anExistingValue* -> .. ; Just captured -> ... ; .. or is that through guards? 
08:24:53 <Squarism> accomplished throug..
08:26:05 <glguy> Guards
08:44:01 <defanor> i'd like to visualize some data, what would involve plain drawing (currently only need coloured dots, though vector graphics may be handy later) and text values (e.g., time under a picture), some tables, and optionally plots -- perhaps a rather standard set of things. not necessarily interactive (i.e., zooming and similar things), but should work in both TUI and GUI. are there any libraries that would make it easy to do?
08:44:42 <sm> defanor: what kind of TUI are you thinking ? ascii diagrams and plots ?
08:45:00 <defanor> sm: yup, and translation of the drawn pictures into coloured ascii as well
08:46:46 <sm> there is something on hackage that can render images (such as generated by Chart or diagrams or gloss) to ascii
08:48:02 <ertes> probably not the text though
08:48:15 <defanor> will try to find it, thanks. but yup, also need something for tables and labels
08:48:44 <maerwald> defanor: diagrams or haskell-chart
08:48:53 <maerwald> no idea about ascii though
08:48:54 <sm> tabular is one for table layout
08:49:09 <maerwald> ascii is for ppl stuck in the 80s
08:49:26 <ertes> yeah, 10's kids use unicode!
08:50:04 <glguy> maerwald: Like in the a-Ha video "Take On Me"?
08:50:07 <defanor> checking the libraries now. oh, and unicode would also work for me -- just need something textual, to use via ssh without X forwarding
08:51:16 <sm> glguy: drat you, that's in my head now
08:51:54 <glguy> Don't let the ASCII art pull you in!
08:52:34 <sm> Taaake...Onnn..Meeee... {=:-o   <- 80's singer
08:54:50 <defanor> seems like a relatively quick way would be to render pictures as for GUI and translate them into ascii, and render all the textual data as ascii graphics, then printing on a canvas in GUI mode
08:55:18 <maerwald> would be surprised if there is no svg to ascii thing
08:55:38 <sm> I've wanted this too. I've been looking, but haven't found that thing I was thinking of
08:55:39 <defanor> oh, right, that may even work well for text
08:56:01 <defanor> though not sure about svg and tables
08:57:00 <sm> http://hackage.haskell.org/package/asciidiagram goes the other way
08:57:29 <defanor> but that won't work for raster graphics, i guess
08:57:55 <sm> http://hackage.haskell.org/package/haha does something.. drawing on the terminal I think
08:58:37 * hackagebot qtah-cpp-qt5 0.1.1 - Qt bindings for Haskell - C++ library  https://hackage.haskell.org/package/qtah-cpp-qt5-0.1.1 (khumba)
08:58:39 * hackagebot qtah-examples 0.1.1 - Example programs for Qtah Qt bindings  https://hackage.haskell.org/package/qtah-examples-0.1.1 (khumba)
09:00:50 <defanor> yup, but looks like there's no simple way to turn the drawn pictures into a GUI version with higher resolution. GUI→TUI seems like the right way for pictures, since some information will/should be lost there
09:01:27 <defanor> (at least, in what i'd like: pictures are big sometimes, about 200*200, while for a TUI mode it'd be better to keep them 80*x)
09:01:43 <sm> http://hackage.haskell.org/package/camh is there.. not the one I was thinking of
09:03:41 <sm> dang it. But I guess there are lots of non-haskell tools you could call out to
09:04:30 <ertes> i'd keep GUI and TUI rendering separate
09:04:41 <ertes> they typically have very different and conflicting needs
09:06:31 <defanor> in this case it seems that both can be used rather easily, if there was an appropriate library. i don't need interaction here, just relatively common ways to visualize data
09:06:51 <defanor> (and writing basically the same thing two times is not that fun)
09:07:09 <defanor> but yup, probably it's not such a common case
09:07:42 * defanor thinks of just writing a library for that
09:08:00 <ertes> i'd say it's also really difficult to abstract…  you have two media that work vastly differently
09:08:08 <defanor> getting further and further from the task at hand, which was to draw one picture
09:08:37 * hackagebot config-value 0.5 - Simple, layout-based value language similar to YAML or JSON  https://hackage.haskell.org/package/config-value-0.5 (EricMertens)
09:08:43 <sm> a text renderer for diagrams sounds reasonable
09:09:22 <ertes> if it's serial data, consider not drawing a diagram at all in text mode…  instead produce a readable textual representation using, say, ansi-wl-pprint
09:09:41 <defanor> well, at least in this case i can picture how it can be abstracted rather easily: a few types of elements (picture, table, plot, text), no predefined layout – could be rendered in both GUI and TUI
09:09:44 <ertes> that should work for a lot of structured data, not only serial
09:10:29 <ertes> if your domain is narrow enough, you can certainly abstract, but you'll probably do it yourself and not reuse it that often =)
09:11:43 <maerwald> what's wrong with a domain-specific abstraction? even as a library it makes sense
09:12:17 <ertes> nothing…  just that it's unlikely to be predefined
09:12:55 <maerwald> that's just a guess
09:14:41 <maerwald> defanor: you could ask in the #diagrams channel too
09:18:26 <defanor> maerwald: perhaps will do that, though not sure if it fits in the topic of diagrams
09:18:57 <maerwald> defanor: why not?
09:19:11 <defanor> maerwald: because there also are tables and raster graphics. and haskell
09:19:40 <defanor> (though C or some json-friendly tools could replace haskell wrt tools)
09:21:08 <defanor> anyway, i'll think about the task a bit more (it's just a helper tool for me, so it's flexible), will check the libraries more, and hopefully will figure something. thanks for the answers
09:21:10 <sm> #diagrams is the most popular haskell drawing lib, with many renderers - probably they are interested in text rendering
09:21:36 <Gurkenglas> http://lpaste.net/172968 produces a different display of this sort http://prnt.sc/bzi741 each frame, why? (Am I reading random memory into the output?)
09:21:38 <sm> let us know if you get it working
09:21:40 <defanor> oh, it's a library-related channel? i thought it's just about diagrams
09:21:53 <defanor> ok
09:22:02 <sm> http://projects.haskell.org/diagrams/
09:22:54 <sm> heheh, I would like to see all of http://projects.haskell.org/diagrams/gallery.html on a terminal
09:25:17 <defanor> some of those would indeed lose data when converted in ascii. my raster graphics are just pictures from weather radars, wouldn't harm to scale them down
09:28:02 <jmcarthur> Are any of the stack templates significantly nicer than the others?
09:28:16 <jmcarthur> For general purposes libraries, in this case, although I'm curious about for executables, too.
09:33:13 <Guest57883> printInc2 n = 
09:33:31 <Guest57883> (\plusTwo -> pring plusTwo) (n+2)
09:33:50 <Guest57883> how does that fit in the λx.x model
09:34:24 <Guest57883> is (λplusTwo -> pring plusTwo). (n+2)
09:34:53 <glguy> No, in Haskell the λ becomes \ and the . becomes ->
09:36:03 <Guest57883> how is free variables being used recurisvely in that example?
09:36:05 <Guest57883> also thanks!
09:36:23 <glguy> There's no recursive aspect to that example
09:36:24 <vinnie92> Hi there
09:36:51 <jmcarthur> I learned recently that the . in lambda notation originally was just a terser notation for right-associated parens, like ($) in Haskell.
09:37:08 <Guest57883> so does plusTwo go into the n?
09:37:28 <vinnie92> Is there a way to match patterns (eg: with lists) using guards?
09:37:40 <glguy> Guest34040: (\plusTwo -> pring plusTwo) (n+2)   evaluates to    pring (n+2)
09:37:45 <glguy> errr, Guest57883
09:38:02 <Guest57883> lol /nick RoYgBiV
09:38:22 <Guest57883> eh lol
09:38:38 * hackagebot llvm-tf 3.0.3.1.1 - Bindings to the LLVM compiler toolkit using type families.  https://hackage.haskell.org/package/llvm-tf-3.0.3.1.1 (HenningThielemann)
09:38:52 <vinnie92> http://lpaste.net/172973
09:39:54 <glguy> vinnie92: Your first clause is redundant, your third clause's pattern could be: [x] instead of (x:[])
09:40:34 <glguy> vinnie92: These are the right way to do the patterns otherwise, you can use a case expression if you want to avoid typing doubleEveryOther 3 times
09:41:45 <vinnie92> I just started learning haskell, so I don't already studied the case expressions in haskell
09:42:02 <glguy> Guest57883: If you're going to be learning Haskell for a bit, it would be good to pick a recognizable /nick and stick with it, rather than being Guest######
09:42:53 <vinnie92> glguy: I read the first tutorial of cis, but I asked myself if is possibile to rewrite that expression using guards (when I tried I got errors on the scope of x, y, and zs)
09:43:36 <glguy> vinnie92: Guards allow you to branch on boolean values rather than patterns
09:43:52 <vinnie92> Ok, thanks
09:43:58 <Guest57883> ya trying to figure this client out glguy Xd
09:44:11 <vinnie92> So I guess it is not possible 
09:44:47 <glguy> Guest57883: The nickname "roygbiv" is registered already, so if you weren't the one to register it you'll have to be even more creative
09:45:00 <Test123> cant think of anything
09:45:07 <monochrom> just use a random number
09:45:57 <monochrom> consider 31337
09:46:11 <glguy> Nicknames can't start with numbers, unfortunately (fortunately)
09:46:54 <monochrom> e1337 then. 31337 is a prime and is eleet
09:47:06 <hpc> /nick onetwothreefourfive
09:47:24 <glguy> too long
09:47:42 <hpc> ah, dang
09:47:43 <glguy> max length is 16
09:48:04 <glguy> Wow, I guess picking a /nick is actually pretty hard; so many failed attempts !
09:48:56 <monochrom> it's easier if you remove the "recognizable" condition
09:50:37 <Eduard_Munteanu> /nick totts
09:51:21 <Test123> cant think of anything lmfao
09:51:39 <^|{`-}_{> This is your dream nick.
09:51:44 <glguy> Well, Test123 is also a registered name :)
09:51:50 <Test123> now im getting sidetracked
09:52:25 <Test123> i had a badass name etc but i had said something not even bad got banned 
09:52:46 <Test123> and got lazy to make a new account
09:55:03 <mniip> it probably was inappropriate
09:55:25 <Test123> no all i said was haskell made me hard lol
09:55:43 <mniip> that is inappropriate
09:55:55 <st5l> lul
09:55:58 <monochrom> that is bad
09:56:18 <mniip> I wouldn't say it's particularly bad but the idea is that this channel is family friendly
09:56:18 <Test123> dictionary.com hard is not anything of that nature  
09:56:57 <Test123> anything can be taken into another context hell test123 could mean something bad
09:57:22 <st5l> Haskell probably didn't turn you into a rock
09:57:44 <mniip> let's not get sidetracked
09:58:09 <glguy> OK, you don't seem to recognize what was wrong with the behavior that got you into trouble in the first place
09:58:21 --- mode: ChanServ set +q *!*@pool-108-35-109-85.nwrknj.fios.verizon.net
09:59:01 <mniip> I don't think that was necessary :(
09:59:18 <glguy> We can chat about it in #haskell-ops if you want
10:11:17 <x4u3n> Hi, how could I do the mouse cursor be runned without lauch a browser or other app?
10:12:54 <ggVGc> I have no idea what that sentence means
10:13:28 <st5l> same
10:16:27 <x4u3n> How could I make the mouse cursor to run without having to launch a browser for example, sorry my english.
10:16:42 <liste> run how?
10:17:00 <x4u3n> is not enabled when xmonad start.
10:18:24 <liste> x4u3n: I'm sure #xmonad knows
10:18:58 <cocreature> x4u3n: it’s not really the right channel here, but "xsetroot -cursor_name left_ptr"  might do what you want (put it in your ~/.xinitrc or something like that)
10:20:05 <x4u3n> liste, cocreature: thanks
10:20:48 <danilo2> Hello! Is there in GHC>8 a way to define a TH in the same file I want to use it or the stage restriction is still something we've got to live with for now ? :)
10:22:30 <monochrom> I think staging is in the nature of it.
10:22:52 <glguy> Danilo2: no new tricks, you can define stuff in a let expression at least
10:23:17 <danilo2> monochrom: not exactly - we could easily define a TH function, discover that it is completely distinct from others and use it somewhere else. 
10:23:56 <danilo2> glguy: thanks! I need top level ones here so I've got to stick with sepearate files
10:42:07 <blueskull> hello
10:42:26 <blueskull> i'm learning haskell and have a doubt
10:42:34 <liste> what doubt?
10:42:50 <blueskull> raices :: Double -> Double -> Double -> (Double, Double) raices a b c | discriminante < 0 = error "not real solutions" 						 | otherwise = ( ((-b)+sqrt(discriminante))/(2*a) , ((-b)-sqrt(discriminante))/(2*a) ) 	where 		discriminante = b^2-4*a*c
10:42:56 <blueskull> oh, shit! jajaja
10:43:02 <maerwald> please use lpaste
10:43:24 <blueskull> its the first time in irc, so i don't know
10:43:27 <blueskull> :P
10:43:33 <glguy> blueskull: Be careful using tabs in your Haskell code. It's important that your editor is set for 8 space tabstops
10:43:35 <liste> @lpaste
10:43:35 <lambdabot> Haskell pastebin: http://lpaste.net/
10:43:59 <maerwald> 8 space?
10:44:20 <glguy> 8 space!
10:45:04 <blueskull> ok, i will try later, i can explain
10:45:11 <blueskull> i have a function roots
10:45:18 <glguy> maerwald: Haskell 2010, 10.3 Layout: • Tab stops are 8 characters apart.
10:45:31 <blueskull> this function is going well when define like
10:45:54 <blueskull> raices :: Double -> Double -> Double -> (Double, Double)
10:46:07 <blueskull> raices is to solve a second degree equation
10:46:17 <blueskull> but if i define like
10:46:40 <blueskull> raices :: Floating a => a -> a -> a -> (a, a)
10:46:44 <blueskull> get errors
10:47:33 <blueskull> raices :: Double -> Double -> Double -> (Double, Double) raices a b c | discriminante < 0 = error "not real solutions" 						 | otherwise = ( ((-b)+sqrt(discriminante))/(2*a) , ((-b)-sqrt(discriminante))/(2*a) ) 	where 		discriminante = b^2-4*a*c
10:47:52 <blueskull> sorry
10:47:56 <blueskull> Could not deduce (Ord a) arising from a use of ‘<’
10:48:09 <maerwald> blueskull: second time: use lpaste
10:48:24 <blueskull> ok, i will try
10:50:11 <glguy> blueskull: Floating doesn't imply Ord, you need both constraints
10:50:28 <blueskull> how can define two constraints?
10:50:38 <maerwald> glguy: I have tabstop=2, what's the problem?
10:50:45 <st5l> Class A, OtherClass A => ?
10:51:26 <blueskull> tnx!, i will try
10:52:03 <glguy> maerwald: You can get cases where you mixed spaces and tabs for indentation where your editor shows that something is at the same indentation level and GHC doesn't
10:53:04 <maerwald> oh well, I have expandtab anyway
10:53:41 * hackagebot llvm-ffi 3.0.0.1 - FFI bindings to the LLVM compiler toolkit.  https://hackage.haskell.org/package/llvm-ffi-3.0.0.1 (HenningThielemann)
10:53:41 <glguy> Me too. There's a soft tabstop setting you can use in Vim so that your tab key jumps by 2, but tabstops are 8
10:54:50 <x1f577> is there a pre-defined conduit sink to throw away the res of the input? like a /dev/null sink?
10:57:33 <lpaste> BlueSkull pasted “problem” at http://lpaste.net/172990
10:58:18 <blueskull> sorry for indentation, just a test to understand lpaste
10:59:55 <maerwald> blueskull: did you try adding the Ord class constraint to the 'a' in line 9?
11:00:21 <st5l> doesn't RealFloat implement Ord as well?
11:01:07 <blueskull> i've try, but fail in the sintaxis, i writed raices :: Floating a, Ord a => .....
11:01:23 <blueskull> i don't know how to define two constraints
11:01:23 <maerwald> blueskull: aices :: (Floating a, Ord a) =>
11:01:31 <blueskull> ok, tnx
11:01:34 <blueskull> i will try
11:02:22 <blueskull> yesssss, thank you maerwald 
11:02:29 <blueskull> :D
11:02:30 <maerwald> glguy said it even before ;)
11:02:52 <blueskull> i know but not put the ()
11:02:53 <blueskull> XDD
11:03:25 <maerwald> well, I'm not sure if it's actually needed for disambiguation, probably part of the haskell report or something?
11:03:52 <blueskull> without didn't run
11:03:59 <blueskull> :?
11:04:04 <maerwald> yeah I know, I was just wondering why we need it
11:10:45 <Eduard_Munteanu> maerwald, well, you can't write an empty constraint without ()
11:11:11 <maerwald> but you don't need it if there is only one constraint anyway, so...
11:12:39 <Eduard_Munteanu> :k ((), ()) => ()
11:12:40 <lambdabot> *
11:12:54 <Eduard_Munteanu> :k (())
11:12:55 <lambdabot> *
11:13:04 <maerwald> so, what's wrong with: (), () => () -- ?
11:13:10 <Eduard_Munteanu> Er.
11:13:16 <Eduard_Munteanu> Nothing.
11:13:25 <maerwald> but GHC rejects
11:13:26 <lipkab> I got this link from a friend: http://crashworks.org/if_programming_languages_were_vehicles/
11:13:40 <Eduard_Munteanu> I wonder how to disambiguate empty constraints from the unit type.
11:14:05 <maerwald> can't find a definite explanation in the report, but I didn't look hard
11:14:10 <EmmanuelC> Hi :)
11:14:13 <lipkab> Out of curiosity, what vehicle do you guys think could represent Haskell?
11:14:35 <lipkab> I guess I'm not alone thinking that the monocycle doesn't really fit :)
11:15:06 <st5l> DaVinci bicycle?
11:15:10 <Eduard_Munteanu> Something with a CVT and regenerative braking.
11:15:39 <Eduard_Munteanu> That people complain about that it doesn't make proper vroom.
11:16:06 <lipkab> Heh :)
11:16:08 <maerwald> haskell is a car that mostly refuses to run, unless you open the doors in the correct order
11:16:35 <x1f577> is there an attoparsec combinator to look ahead for a parser, returning (Maybe result) and not consuming anything?
11:16:56 <x1f577> something like lookAheadParser :: Parser a -> Parser (Maybe a)
11:17:33 <saurabhnanda> How do I run a test in QuickCheck with the following type? prop_a :: PropertyM (SqlPeristT IO) a? How do I get it to compose with monadicIO AND runSqlite?
11:21:07 <maerwald> x1f577: better you explain your usecase. attoparsec always backtracs on failure (and rewinds input)
11:24:48 <mniip> [21:13] (Eduard_Munteanu) I wonder how to disambiguate empty constraints from the unit type.
11:24:51 <mniip> kinds
11:24:54 <EvanR> x1f577: parser1 <|> parser2
11:25:04 <mniip> :k () :: Constraint
11:25:05 <lambdabot> parse error on input ‘::’
11:25:06 <EvanR> if parser 1 fails, parser 2 will be tried from the original point
11:25:12 <x1f577> maerwald: i have a stream of text and im parsing out unigrams, bigrams, and trigrams. I'm thinking ill do this by parsing one term (consuming the input) and then looking ahead for two more terms and constructing the bi and trigram from the latter 2 terms. 
11:25:15 <EvanR> in attoparsec
11:25:16 <mniip> :k (() :: Constraint)
11:25:17 <lambdabot> Constraint
11:25:39 <EvanR> gram1 <|> gram2 <|> gram3
11:25:45 <EvanR> choice [gram1, gram2, gram3]
11:26:02 <mniip> () and (,) have magical kinds
11:26:27 <maerwald> x1f577: I don't fully understand, but the Parsers also have a Monad interface, where you can make more complex choices
11:26:44 <x1f577> EvanR: if the stream contains "a b c d e", and i need a, ab, abc, b, bc, bcd, etc, wont i miss out on some using choice?
11:27:05 <EvanR> you need what?
11:27:19 <EvanR> exactly what should "a b c d e" be parsed as
11:28:12 <x1f577> EvanR: "a b c d e" -> ["a", "ab", "abc", "b", "bc", "bcd", "c", "cd", "cde", "d", "de", "e"]
11:28:41 * hackagebot ogmarkup 2.1 - A lightweight markup language for story writers  https://hackage.haskell.org/package/ogmarkup-2.1 (lethom)
11:28:56 <EvanR> substrings (unwords "a b c d e") /
11:29:04 <glguy> Don't forget that if the left side of <|> succeeded in attoparsec that the right side will never be tried
11:29:15 <EvanR> filter by length <= 3
11:29:41 <x1f577> EvanR: here's the catch, the input is a lazy stream of bytes coming over an http request, im using conduitParser to apply the attoparsec parser
11:30:07 <x1f577> EvanR: and i need to retain the lazyness
11:30:09 <glguy> return () <|> x , is return ()
11:30:13 <Eduard_Munteanu> mniip, hm, I see.
11:30:15 <EvanR> the lazy I/O you mean
11:30:37 <x1f577> EvanR: correct.
11:31:19 <EvanR> it looks like you want a DFA rather than a parser combinator library
11:32:24 <x1f577> EvanR: haven't explored that before.. do you have any links/search queries that might poiint me in the right direction/
11:32:33 <x1f577> s/\//?/
11:33:01 <EvanR> i dont know about a formal sense here, but you just need a state machine which remembers the last 3 characters in a queue
11:33:11 <EvanR> when it sees a character it pushes and outputs a word
11:33:29 <EvanR> , outputs a word, then pushes
11:33:30 <maerwald> megaparsec is a monadtransformer btw, so you could add State there
11:33:52 <EvanR> yeah, a parser with state might do it
11:34:03 <EvanR> but is megaparsec incremental
11:34:17 <dmwit> > do { xs <- tails "abcde"; y <- [1..3]; take y xs }
11:34:19 <lambdabot>  "aababcbbcbcdccdcdeddedeeee"
11:34:28 <dmwit> > do { xs <- tails "abcde"; y <- [1..3]; return (take y xs) }
11:34:33 <lambdabot>  mueval-core: Time limit exceeded
11:34:39 <dmwit> ...what
11:34:40 <x1f577> EvanR: im thinking i can use atto to parse out the unigrams from the conduit, and then write my own conduit with state that rembers 3 and outputs the terms
11:34:47 <dmwit> > do { xs <- tails "abcde"; y <- [1..3]; return (take y xs) }
11:34:48 <x1f577> outputs the bigrams & trigrams **
11:34:49 <lambdabot>  ["a","ab","abc","b","bc","bcd","c","cd","cde","d","de","de","e","e","e","","...
11:35:00 <EvanR> that sounds like a thing conduit can do
11:35:46 <EvanR> x1f577: honestly i dont see how attoparsec helps you here
11:35:53 <x1f577> i may have mislead you a tad bit - the individual items being composed into unigrams, bigrams, and trigrams arench Char's, their Terms which i've defined myself
11:35:59 <dmwit> > do { xs <- tails "abcde"; y <- [1..3]; guard (not . null . drop (y+1) $ xs); return (take y xs) }
11:36:02 <lambdabot>  ["a","ab","abc","b","bc","c"]
11:36:05 <x1f577> EvanR: because the individual elems arent Char's, they're terms that need to be parsed
11:36:23 <EvanR> then you output a stream of tokens
11:36:27 <EvanR> and do what you said
11:36:44 <x1f577> EvanR: thanks for helping me bounce ideas around.. im going to try it out
11:37:16 * EvanR throws a random "what are you really trying to do" and leaves for coffee
11:38:16 <x1f577> EvanR: lol - im trying to lazily turn a stream of bytes into a stream of uni/bi/trigrams for use with search indexing. the stream of bytes correspond to a file being added to the system
11:39:22 <Eduard_Munteanu> x1f577, (atto)parsec parsers can't really produce output in a streaming fashion.
11:39:38 <dmwit> It should be possible to make a conduit that turns a stream of arbitrary objects into a stream of lists of objects of adjacent things. Or else conduits is a lousy abstraction.
11:40:31 <Eduard_Munteanu> You could lift attoparsec parsers into conduits. Not sure if there's a package around that provides it.
11:40:51 <Eduard_Munteanu> I mean each component parser.
11:43:08 <x1f577> Eduard_Munteanu: thats a good point.. i may not even need to use atto at all. i think i can turn the incoming file into a conduit of Word8's, and then write a conduit from Word8's to my Term's, and then subsequently a conduit from Term's to [Term]'s representing the uni/bi/tri grams
11:44:03 <Eduard_Munteanu> x1f577, yeah. If you go that way, maybe cereal-conduit or binary-conduit could help.
11:44:52 <x1f577> Eduard_Munteanu: the challenge is going to be extending the system to handle any kind of file with a known protocol like .html, .pdf, .ppt, .xlsx, etc
11:45:35 <Eduard_Munteanu> x1f577, there are packages which provide conduits for XML and stuff.
11:46:08 <x1f577> Eduard_Munteanu: ill look into them, thank you
11:52:13 <x1f577> how does one turn a lazy bytestring into a lazy list of bytes (word8's)? is it simply unpack?
11:52:43 <geekosaur> yes
11:52:49 <ertes> x1f577: regarding your earlier question, you mean like…
11:53:19 <ertes> > takeWhile (not . null) . map (take 3) . iterate (drop 1) $ "abcdef"
11:53:21 <lambdabot>  ["abc","bcd","cde","def","ef","f"]
11:53:50 <ertes> you can do that nicer using the unfoldr combinator of your list structure
11:54:12 <ertes> (or actually just unfoldr for lists)
11:54:22 <ertes> (and splitAt of your list structure)
11:55:31 <x1f577> ertes: it's a bit more complicated because although the incoming data is a lazy list of bytes, i first need to lazily transform that into a lazy list of Terms, and the subsequently into a lazy list of unigrams, bigrams, and trigrams of those terms
11:56:08 <ertes> well, as long as you have "list" in there…
11:56:35 <x1f577> so "this is a test" -> ["this" "is" "a" "test"] -> [["this"], ["this is"], ["this is a"], ["is"], ["is", "a"]] etc
11:56:51 <x1f577> its actually a conduit, not a list
11:57:13 <ertes> @let data MyType = Groovy | Funky | Jazzy | Cheesy | Awkward | Cringy  deriving (Bounded, Enum, Eq, Ord, Show)
11:57:15 <lambdabot>  Defined.
11:57:34 <ertes> > takeWhile (not . null) . map (take 3) . iterate (drop 1) $ [Groovy, Jazzy, Awkward, Awkward, Cringy, Jazzy, Funky]
11:57:36 <lambdabot>  [[Groovy,Jazzy,Awkward],[Jazzy,Awkward,Awkward],[Awkward,Awkward,Cringy],[Aw...
11:58:01 <ertes> since conduits are basically pipes, and pipes can do that, conduits probably can do that
11:58:11 <x1f577> ertes: is is unpacking a lazy bytestring lazy? meaning, if i unpack the bytestring and take the first Word8, was the operation O(n)?
11:58:31 <ertes> yeah, that's lazy, as far as the bytestring itself is lazy
11:58:49 <x1f577> ertes: my first hurdle is turning a lazy bytestring into a source of word8's, and im thinking ill just unpack the bytestring and use sourceList
11:59:13 <x1f577> ertes: ok, ill go with it
11:59:32 <slack1256> In a haskell program, what would you use as a scripting language?
11:59:40 <slack1256> I would use haskell itself but ghc is too big
11:59:56 <ertes> x1f577: well, await a bytestring and yield every individual byte (mapM_ will help)
12:01:01 <ertes> slack1256: does it have to be a programming language?
12:02:09 <slack1256> no, but I am seeing if it possible
12:02:58 <ertes> slack1256: possible sure, but done?  not sure…  there have been toy scheme implementations that you could use, but most programming language implementations aren't really meant to be embedded
12:03:23 <ertes> most serious ones that is, like fay and purescript
12:03:59 <saurabhnanda> can anyone help me with http://stackoverflow.com/questions/38644779/how-to-use-quickcheck-to-test-database-related-functions ?
12:04:00 <slack1256> ! I hadn't thought of fay and purescript
12:04:10 <slack1256> I was thinking typed guile or the likes
12:04:35 <EvanR> what is "scripting"
12:04:48 <Eduard_Munteanu> The interpreters for JS are large too.
12:05:01 <Eduard_Munteanu> Or large-ish.
12:05:09 <EvanR> slow, type unsafe, awful programming languages
12:05:21 <ertes> slack1256: i would research that in the context of a particular application, because there are different needs and trade-offs
12:05:23 <slack1256> EvanR: bait much?
12:05:38 <ertes> slack1256: for example you might end up doing something as simple as xmonad
12:05:45 <maerwald> EvanR: you missed "dynamic"!
12:05:46 <maerwald> yay
12:06:01 <ertes> slack1256: but if all else fails, i'd really just embed haskell itself
12:06:09 <EvanR> the original scripting languages were invented because they were easier to implement and actually easier to use than C
12:06:20 <EvanR> but now that we have haskell...
12:06:29 <maerwald> weird, I find C easier than javascript =o
12:06:53 <cromachina> every tool has a purpose
12:06:56 <ertes> i find C easier to understand, but not easier to use
12:07:01 <Eduard_Munteanu> Except that they were designed by people who really had little clue of PL theory.
12:07:02 * EvanR images C scripting in a web page
12:07:17 <ertes> and also only if you don't go into certain dark corners of the spec =)
12:07:28 <EvanR> imagine C to modify DOMs
12:07:33 <EvanR> or navigate json data
12:07:33 <maerwald> awesome
12:07:40 <slack1256> What I would really like it is a 2016 hugs interpreter with conservative extensions...
12:07:42 <ertes> like merijn's lovely example:  sizeof(0)["ABCDEFGHI"]
12:07:44 <maerwald> C xml libs are cool too
12:07:59 <maerwald> ertes: well, it is _defined_ at least ;)
12:08:12 <Eduard_Munteanu> ertes, let me guess... 'D'?
12:08:18 <ertes> Eduard_Munteanu: wrong =)
12:08:19 <Eduard_Munteanu> Er, 'E'.
12:08:24 <ertes> Eduard_Munteanu: still wrong
12:08:42 <Eduard_Munteanu> Oh, duh.
12:08:56 <Eduard_Munteanu> It's 1.
12:09:22 <ertes> Eduard_Munteanu: right, and i had no clue how to explain it, until it was explained to me
12:09:36 <ertes> the [] part i got:  sure, it's just +
12:09:38 <EvanR> how about a DSL which compiles haskell into a form that runs on the target platform
12:09:50 <EvanR> instead of being an embedded runtime system
12:09:55 <EvanR> or embedded compiler
12:09:56 <ertes> but the sizeof part was (was? is!) weird to say the least =)
12:10:03 <Eduard_Munteanu> ertes, and sizeof which really doesn't need ()
12:10:16 <ertes> yeah
12:10:31 <ertes> sizeof has a built-in ($) =)
12:11:35 <slack1256> EvanR: what is "into a form that runs on the target platform"? wouldn't that be equal to embeed GHC?
12:11:38 <Eduard_Munteanu> Actually I'm not entirely sure whether it's 1 or 4. Characters are actually ints.
12:11:58 <ertes> Eduard_Munteanu: it's sizeof char
12:12:06 <ertes> and that's defined to be 1
12:12:09 <EvanR> slack1256: well, thats if you want 100% full haskell to work
12:12:11 <slack1256> the problem is that the user can't extend this program in haskell itself because GHC is 15 times bigger than the program itself
12:12:25 <maerwald> It doesn't even have that many pitfalls. If you work with a full-stack angular/node/mongodb project... the pitfalls are countless. And people stumble over them all the time. It's not "distant obfuscation no one uses".
12:12:44 <slack1256> but hs-lua seems to be an option though
12:12:55 <Eduard_Munteanu> ertes, yeah but 'A' is normally an int.
12:13:08 <EvanR> slack1256: imagine a monad which is like Script a, the stuff you can do in here is sufficiently limited to not required the ghc rts
12:13:15 <maerwald> Eduard_Munteanu: yeah, if you do sizeof('A') you get 4 or sth
12:13:18 <ertes> maerwald: fully fledged frameworks with a C API can have that, too, though…  my favourite example is OpenGL
12:13:22 <EvanR> slack1256: are you looking for plugins?
12:13:28 <maerwald> ertes: I didn't find it that bad
12:13:31 <slack1256> EvanR: oh, so you are saying, a "easy" subset of haskell that is compilable without many issues
12:14:16 <EvanR> you could use haskell to manually compile parts, using knowledge of how it will be translated
12:14:26 <EvanR> to cleverly get things done with low resources
12:14:34 <maerwald> ertes: it's just utterly verbose
12:14:34 <EvanR> theres one that outputs C code
12:14:36 <ertes> maerwald: GLSL was somewhat reasonable, but the client library is just terrible, and i attribute a good portion of it to shortcomings (not WATs, just shortcomings) of C
12:15:00 <maerwald> javascript libraries are usually just broken and wrong
12:15:08 <EvanR> but maybe im mixing up "embedded" with "hotswappable"
12:15:28 <ertes> maerwald: i think C could have been a much more reasonable language, if they added parametric polymorphism at some point
12:15:30 <slack1256> no problem, in my mind I am mixing them too
12:15:41 <EvanR> they dont have anything to do with each other
12:15:54 <maerwald> ertes: I am pretty sure that would have added more pitfalls, like all the pitfalls you have in C++ because of feature creep
12:16:00 <EvanR> theres going to be better solutions for each one individually
12:16:10 <EvanR> "lua" doesnt really help on low resources
12:16:29 <EvanR> haskell plugins doesnt help on low resources
12:16:36 <maerwald> ertes: I like it especially because it doesn't have *that* many pitfalls. I hate languages that have a lot.
12:16:38 <slack1256> yep, but if you think of the embeed language as a mean to extended the running program
12:16:45 <ertes> maerwald: basic C++ templates, except for the ultra-verbose syntax, are pretty reasonable
12:16:50 <EvanR> so hotswappable is the real goal
12:17:06 <EvanR> so dynamically loaded plugins sounds like the way to go
12:17:07 <maerwald> C++ is one giant pitfall mess. I know how to write it, but I never put it on my CV.
12:17:10 <slack1256> EvanR: haskell resources, what do you mean with that? the only ones I know are compiler plugins for things like type level naturals
12:17:23 <slack1256> s/resources/plugins/
12:17:23 <ertes> maerwald: C++ is not all bad…  it has some reasonable features that C should have, but then also drags along a pile of crap that makes it difficult
12:17:24 <EvanR> haskell plugins?
12:17:35 <slack1256> yeah, sorry
12:17:35 <EvanR> not compiler plugins, dynamic loading
12:17:46 <maerwald> haskell is rather reasonable if it comes to pitfalls... except if you hit GHC shenanigans with extensions... or, well, laziness
12:17:49 <ertes> maerwald: if given a choice between C and C++, i would choose the latter and then simply use a safe subset of its features
12:18:00 <Eduard_Munteanu> const void *const(const void *a, const void *b) __attribute__((pure)) { return a; }
12:18:06 <maerwald> ertes: I simply refuse to code C++ (even for money) :P
12:18:13 <EvanR> a few years ago this dude Manatee created a self contained "environment" in GTK which could dynamically load GUI plugins
12:18:21 <EvanR> all in haskell
12:18:38 <ertes> maerwald: i coded C++ for money a few years ago, and i was already aware of some of the abstractions from haskell…  so C was out of the question =)
12:19:00 <slack1256> I still see those Manatee programs in hackage. It seemed weird at the time
12:19:06 <ertes> no parametric polymorphism → no language for me…  that's the absolute minimum
12:19:09 <EvanR> it was weird
12:19:13 <Eduard_Munteanu> s/\*const/*constant/
12:19:19 <maerwald> ertes: C++ doesn't have abstractions, just hacks you have to understand on implementation level
12:19:25 <maerwald> otherwise you are going to screw up...
12:19:37 <EvanR> does C++ have parametric polymorphism now? without template code explosion?
12:19:47 <ertes> what ever happened to the manatee guy?  as far as i can tell he simply vanished, giving up all of his code
12:19:48 <EvanR> i.e. boxing
12:19:53 <ertes> and he wrong A LOT of code
12:19:55 <ertes> wrote
12:20:11 <ertes> EvanR: nope
12:20:19 <ertes> it's still code instantiation
12:20:24 <ertes> and yes, you still need headers
12:20:26 <EvanR> well hes not in #haskell-cn
12:20:29 <Eduard_Munteanu> I would ask preflex what happened, but he ain't around anymore. :(
12:21:08 <maerwald> I'd argue when rust stops being an unstable mess of a language, lots of haskellers will switch :P (at least for some projects)
12:21:36 <EvanR> idris has uniqness types, borrowing
12:21:48 <ertes> i'd like to have some of rust's features, but i wouldn't really switch to it
12:22:08 <ertes> idris has them all, i think =)
12:22:14 <ertes> linear, affine, uniqueness, …
12:22:25 <Eduard_Munteanu> I would implement a Haskell RTS in Rust. ;)
12:22:28 <EvanR> those are supposedly on the way out as soon as someone invents linear dependent types
12:22:39 <maerwald> ertes: imo, Idris will take even more time than rust to be remotely usable
12:23:07 <ertes> maerwald: i'm actually considering to try it on my next JS project, as soon as one comes up, and i don't have a tight deadline
12:23:32 <EvanR> ertes: get ready to implement some primitive data structures in C ;)
12:23:38 <EvanR> or js
12:23:43 <maerwald> the amount of libraries is something around ~35? and half of them haven't had a commit since 1.5 years :P
12:23:55 <EvanR> maerwald: which means those probably dont actually work
12:23:59 <maerwald> yeah
12:24:11 <hpc> idris has a package repository?
12:24:20 <EvanR> libraries shmibaries
12:24:35 <maerwald> https://github.com/idris-lang/Idris-dev/wiki/Libraries
12:24:38 <EvanR> real men write their own code
12:24:46 <hpc> eeesh
12:24:51 <maerwald> it fits on one wiki page
12:24:52 <a13ph> Evan
12:24:53 <maerwald> ...
12:25:09 <hpc> idris needs a website
12:25:18 <EvanR> it has a $30 book
12:25:27 <maerwald> hpc: like this http://www.idris-lang.org/ ?
12:25:49 <hpc> yeah, but not obviously wordpress ;)
12:26:02 <ertes> maerwald: i'm not a stranger to reinventing the wheel…  when i started haskell, hackage was like only 5% of its current size =)
12:26:41 <maerwald> ertes: well, one has to be a student or research guy to have that much time to invest...
12:26:54 <EvanR> you probably do need to reinvent the wheel since haskell code for stuff like a tree will just not work efficiently using eager evaluation
12:27:05 <maerwald> I'd rather pick something that allows me to move forward with my little projects that I do in my free time
12:27:09 <EvanR> youll need to use lots of accumulating parameters
12:27:16 <ertes> maerwald: i had more time back then, but i also needed a lot more time, because the paradigm was completely new to me
12:27:30 <ertes> maerwald: i think i can reinvent things much more quickly today =)
12:28:09 <ertes> also i simply don't mind doing it…  it keeps me into the little things as well as the huge things
12:28:11 <maerwald> I'll just write a haskell2idris converter :P
12:28:16 <maerwald> (in rust)
12:29:08 <maerwald> and burn out after the first 3 attempts
12:29:08 <maerwald> xD
12:29:50 <ertes> "i'm a rust programmer" – "hmm, but your code looks like haskell"
12:30:53 <maerwald> yeah, people get confused if your functions are not void, but actually return something
12:31:04 <maerwald> "must be a haskell programmer"
12:31:12 <EvanR> ;_;
12:31:35 <bennofs> haskell2idris converter written in rust, c to rust converter written in haskell...
12:31:55 <maerwald> bennofs: and then abstract over all of it with a java framework!
12:32:05 <EvanR> do you really write such high level programs in rust?
12:32:20 <bennofs> i think transpilers is one of the things where Haskell is really a good fitr
12:32:33 * dysfun is currently writing a transpiler
12:32:36 <maerwald> EvanR: naah... but I was actually considering to rewrite my haskell filemanager in rust. I mean, it's full of low-level system calls and stuff, where rust is supposed to shine anyway.
12:32:52 <bennofs> maerwald: that sounds like more of a rust project ;)
12:33:02 <dysfun> maerwald: fwiw i find the haskell FFI less painful than the rust one
12:33:43 <maerwald> well... the main thing keeping me from doing it is rusts lack of exceptions. I know all the pros and cons and arguments, but I really don't want to live without them, because I know the benefits in that specific project
12:34:03 <EvanR> idris doesnt have exceptions either!
12:34:11 <EvanR> (because you can implement them yourself)
12:34:30 <bennofs> maerwald: just make everything return Result<a,b> and sprinkle try! everywhere! :D
12:34:36 <dysfun> is idris useful for real work yet?
12:34:59 <EvanR> thats classified
12:35:12 <dysfun> thought so
12:35:36 <EvanR> it has an FFI so.... theoretically
12:36:09 <maerwald> I find it silly to make everything an option/maybe/either type just "well, you little function are unlucky, because somwehre in your call stack something might fail, although you don't care at that point... still have to deal with it, lol"
12:36:24 <maerwald> I feel trolled.
12:37:00 <bennofs> maerwald: yeah, but it is not that much of a problem either IMO
12:37:06 <EvanR> well in haskell, you could say that about IO
12:37:10 * dysfun really dislikes exceptions in haskell
12:37:20 <EvanR> on the subject of IO exceptions
12:37:31 <EvanR> you have to make everything IO
12:37:35 <maerwald> dysfun: I agree on your dislike even
12:37:43 <maerwald> but not having them would even be worse for some use cases
12:37:48 <athan> dysfun: Can I ask why? :)
12:38:22 <maerwald> bennofs: it clouds your function interfaces, because it's barely possible to understand anymore why your function returns Maybe
12:38:25 <nshepperd> I like haskell's pure exceptions
12:38:32 <athan> maerwald: Yeah, I would hate to need to `ExceptT (FooErr + BarErr + ...) ..` all the time
12:38:33 <dysfun> well basically your code can still compile and you're gonna be really confused when you didn't realise something threw and it does
12:38:53 <athan> dysfun: I actually can see that
12:39:05 <athan> I wish it included a stacktrace with _where_ it threw at least
12:39:06 <maerwald> bennofs: and you forced to deal with failure _immediately_ all the time, although you know your internal API already does it where it makes sense
12:39:09 <dysfun> someone else said this recently, let me find the link
12:39:12 <barrucadu> I would greatly prefer Haskell exceptions if they showed up in the type.
12:39:18 <bennofs> In an ideal world, I think each function that "passes through" an exception really wants to add additional information to that exception anyway
12:39:34 <dysfun> http://lexi-lambda.github.io/blog/2016/06/12/four-months-with-haskell/
12:39:42 <bennofs> because the internal api generally does not have enough context to give user-friendly error messages
12:40:08 <dysfun> first bit under "frustrations, drawbacks, and pain points"
12:40:09 <EvanR> each exception type can be an effect, and any "functions" which might throw have to list these in the effects
12:40:24 <athan> EvanR++
12:40:27 <EvanR> for real life things, this is either a huge list of exceptions
12:40:33 <bennofs> (for example, most of the IO errors are really bad from user-friendlyness POV imo, so you want to add some info about the more complex operation in which that particular IO was involved in)
12:40:36 <EvanR> or its water down to not be very specific
12:40:58 <athan> I feel like there could be an exception monad that stores a type-level set of exception types (maybe)
12:41:25 <EvanR> you can currently do that with ExceptT and a sum type
12:41:26 <athan> (and has subtyping :x)
12:41:30 <barrucadu> I would greatly prefer a huge list of exceptions in the type to the current situation, where you have to dig through source code of transitive dependencies to figure out what exceptions something can throw
12:41:31 <maerwald> also, I must say I find Maybe wrong for any kind of error handling (yes, even if there is only one way a function can fail)
12:41:36 <maerwald> I still want an error description.
12:41:36 <EvanR> and manual subtyping (conversion)
12:41:37 <dysfun> yes, monad transformers will save us all...
12:41:45 <athan> EvanR: The only issue I see with that is needing to rewrite the sum type all the time, and it's monolithic
12:42:01 <athan> yeah :s
12:42:08 <maerwald> people should use MonadThrow instead of Maybe (which allows to conver to Maybe or Either, depending on your needs)
12:42:09 <EvanR> well it doesnt have to be monolithic, but its unweidly i imagine
12:42:44 <athan> EvanR: Yeah, just a lot of repeated keystrokes to change things
12:42:53 <EvanR> what do you mean?
12:43:13 <EvanR> changing the type itself should be pretty easy, and then a lot of your code is broken, which is good right
12:43:23 <athan> I mean, say you have some set of exceptions Excepts1, and a subset of them Excepts2. If you have a new exception you want to add to both, you need to change both types
12:43:33 <bennofs> maerwald: but you can only use Either SomeException with monadthrow, right? the real type of possible exceptiosn gets lost in the process :(
12:43:36 <athan> but I _don't_ want to type at all :(
12:43:55 <EvanR> if you dont want much control over the exceptions
12:44:01 <EvanR> thats where were at now pretty much
12:44:04 <EvanR> it just works, somehow
12:44:08 <joe9> Is there any library that can help with updating the aeson Value. I want to add an attribute to all elements matching a name.
12:44:29 <athan> joe9: It's just a hashmap
12:44:33 <athan> nested hash map*
12:45:02 <EvanR> joe9: sounds like you want a traversal
12:45:05 <athan> so you could do something like `Data.HashMap.Lazy.mapKeys` or whichever to change the keys
12:45:51 <maerwald> bennofs: hmm, yeah, seems like it
12:46:02 <nshepperd> readFile :: (FileNotFoundError e, PermissionDeniedError e) => FilePath -> ExceptT e IO Text
12:46:09 <bennofs> nshepperd: that
12:46:13 <athan> I dig it
12:46:32 <bennofs> nshepperd: that's what you can do with control-monad-exception package
12:46:33 <joe9> athan, EvanR yes, I need to traverse the hashmap and Object.
12:46:42 <nshepperd> fileNotFound :: FileNotFoundError e => String -> e
12:46:46 <EvanR> youd traverse the Value
12:47:00 <joe9> EvanR: you mean the traverse of Data.Traversable?
12:47:05 <EvanR> yeah
12:47:05 <bennofs> nshepperd: like (Throws FileNotFoundError e, Throws PermissionDeniedError e) => ...
12:47:15 <bennofs> https://hackage.haskell.org/package/control-monad-exception
12:47:17 <joe9> EvanR: ok, Thanks.
12:47:45 <nshepperd> oh, cool
12:48:15 <EvanR> joe9: actually... its not traversable
12:48:28 <maerwald> yeah, but that requires you to deal with monad transformers
12:48:30 <EvanR> but you can write a recursive function
12:48:31 <maerwald> another annoyance
12:48:43 * hackagebot stache 0.1.4 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-0.1.4 (mrkkrp)
12:48:57 <bennofs> maerwald: hmm? you could have (Throws FileNotFoundError m, ...) => a -> m ...
12:49:14 <bennofs> maerwald: and then you can use IO for m, Maybe for m, Either for m, whatever
12:49:25 <maerwald> bennofs: and then you liftIO everywhere...
12:49:33 <bennofs> maerwald: use lifted-base :)
12:49:52 <maerwald> nah, I use IO directly for my systems code and IO exceptions
12:50:23 <nshepperd> or IO (Either e a)
12:50:27 <bennofs> maerwald: but MonadThrow also requires that liftIO, no?
12:50:45 <maerwald> bennofs: oh, I don't use MonadThrow in my IO code, only in my "pure" code
12:50:45 <joe9> EvanR, yes, I started writing the recursive function. and wanted to check if there is a library function can do et.
12:50:50 <joe9> s/et/it/
12:50:54 <dysfun> wow, accidentally writing :: instead of = causes some weird errors when you're using lots of operators
12:51:04 <bennofs> maerwald: you could use that 'Throws e m' in pure code as well :)
12:51:08 <maerwald> bennofs: so I have a path-parser, if that fails... it returns MonadThrow
12:51:32 <maerwald> and then if I parse stuff in my IO code I can just ignore the possible failure, because it's correctly converted already
12:51:38 <maerwald> in my pure-code I force the Maybe or Either type
12:51:42 <monochrom> haha dysfun
12:51:43 <maerwald> that's why I like it
12:52:28 <bennofs> maerwald: yeah, well what I don't like about it is that now the consumer of your API does not know that your pure function does not throw an IO error for example
12:52:37 <bennofs> maerwald: because with MonadThrow, all you get is a SomeException
12:52:38 <maerwald> huh?
12:52:52 <maerwald> MonadThrow does not throw an IO error
12:53:08 <bennofs> maerwald: if you have MonadThrow, you can throw *any* exception
12:53:19 <maerwald> yes, but that depends on the type checking
12:53:26 <maerwald> the user of the API has the freedom
12:53:38 <maerwald> if he doesn't understand the API and doesn't read docs... well, screw him
12:53:44 <bennofs> maerwald: and you can never be sure that you handle *all* exceptions in which a function can fail
12:53:52 <maerwald> that's a GHC problem, yes
12:53:56 <maerwald> it doesn't know about that
12:54:12 <bennofs> that's a problem of the design of MonadThrow: it erases the original type of the exception
12:54:13 <maerwald> which is the main reason why exceptions in haskell suck
12:54:16 <bennofs> and leaves only a SomeException
12:54:43 <Zemyla> This should be a law-abiding Alternative instance for Either, right? instance Monoid e => Alternative (Either e) where { empty = Left mempty; ea@(Right _) <|> _ = ea; Left _ <|> eb@(Right _) = eb; Left a <|> Left b = Left (mappend a b) }
12:54:46 <maerwald> bennofs: well, you should never catch _all_ exceptions anyway, since that's dangerous :P
12:55:03 <bennofs> maerwald: yes, but perhaps for a parseURI function, I *could
12:55:08 <nshepperd> -_-
12:55:09 <maerwald> the problem now is that GHC cannot tell you what exceptions are caught and what not
12:55:13 <maerwald> it doesn't know about it
12:55:20 <bennofs> catch all exceptions*, because it does not fail in ways that should not be handled?
12:55:37 <EvanR> why would parseURI, assuming its a pure function, throw exceptions
12:55:37 <maerwald> bennofs: there are internal exceptions you might catch which can probably leave your program in an invalid memory state...
12:55:43 <nshepperd> catching all exceptions is not the same as catching Exception
12:56:13 <bennofs> maerwald: there are ways to design an API in a way such that GHC can know what exceptions your parseURI function might possibly throw
12:56:26 <maerwald> bennofs: and I already agreed that the SomeException limitation of MonadThrow sucks
12:56:35 <EvanR> just use Maybe and at the use site, convert the Nothing to an exception that makes sense for that code
12:56:48 <bennofs> maerwald: ok, so I guess we agree :) I just want to say it's not a GHC problem, but an 'exceptions'-package problem
12:57:00 <maerwald> bennofs: it's also a GHC problem, yes
12:57:12 <bennofs> how that?
12:57:14 <Zemyla> maerwald: There are a few circumstances in which you should catch all exceptions, but they involve (a) either passing a function to an FFI function, or (b) passing the result (either a value or an exception) through a channel to someone else.
12:57:34 <maerwald> bennofs: GHC doesn't *know* if you catched all exceptions
12:57:59 <dysfun> gotta catch 'em all?
12:58:01 <nshepperd> how is ghc supposed to know if the type is erased?
12:58:03 <bennofs> maerwald: for pure code, if I specify all possible exception types that my pure function can throw, then sure ghc can make sure that I handle all?
12:58:05 <maerwald> e.g. you have your IO function that does system calls and other random crap... and there is no way GHC can tell you "ok, in your call stack you catched them all"
12:58:14 <maerwald> you can't
12:58:17 <bennofs> maerwald: yeah, I agree that i does not work for IO
12:58:24 <maerwald> in java it's possible
12:58:26 <bennofs> maerwald: but you said before that you use MonadThrow only for pure stuff
12:58:35 <EvanR> is it possible in java?
12:58:37 <EvanR> still
12:58:51 <nshepperd> so it's a ghc problem that it doesn't do the impossible with an inferior api?
12:58:55 <dysfun> provided you aren't being very naughty and subverting it, yes
12:59:10 <maerwald> bennofs: the functions that end with "MonadThrow m => ... m a" are pure, yes, but I use them in the context of IO functions too ofc
12:59:36 <bennofs> maerwald: well, in the context of IO functions, the guarranted that you catch all exceptions would of course vanish
13:00:12 <bennofs> maerwald: but you could design a library such that you can use functions both in a) pure code, guaranting you handle all failure cases and b) IO code, where failures get translated to haskell exceptions
13:00:27 <`Guest00000> is it possible to enumerate all constraints in a constraint list e. g. turn (C1 a, C2 a, C3 a, C4 a)  into list [C1 a, C2 a, C3 a, C4 a] ?
13:00:40 <bennofs> I was quite surprised when I found out that 'exceptions' does not do that
13:00:42 <nshepperd> why can't we just make a new IO type that includes the exception set in the type
13:00:43 <maerwald> bennofs: well, that's what MonadThrow does, except for the SomeException limitation
13:00:58 <nshepperd> and then make everything use that
13:00:58 <bennofs> maerwald: the SomeException limitation excludes possibility a) though
13:01:11 <maerwald> bennofs: why?
13:01:23 <maerwald> in pure code you would convert it to Maybe/Either
13:01:25 <bennofs> maerwald: because you cannot handle all exceptions if you only get a SomeException as result?
13:01:32 <bennofs> maerwald: you will get an Either SomeException
13:01:37 <bennofs> maerwald: what do you do with the Left?
13:01:43 <maerwald> I don't understand
13:02:05 <maerwald> I don't see how something "uncatched" can leak there when you convert to Either
13:02:06 <maerwald> it cannot
13:02:12 <maerwald> it's not IO code
13:02:20 <maerwald> it never crashes
13:02:22 <nshepperd> maerwald: the problem is not 'making exceptions go away'
13:02:25 <bennofs> maerwald: you only get e :: Exception x => x in the case of failure, even if the function you're calling perhaps only ever throws ParseError, you still have to deal with the possibility that it might have thrown an UserError
13:02:29 <nshepperd> maerwald: the problem is handling them
13:02:33 <glguy> Maybe bennofs is distinguishing between ignoring exceptions and handling all possible exceptions individually?
13:03:02 <maerwald> by matching on SomeExceptions you effectively _handle_ all failure cases
13:03:09 <maerwald> it's just that you don't know the details anymore
13:03:11 <bennofs> maerwald: if you have parseURI :: String -> Either SomeException URL
13:03:26 <bennofs> maerwald: how do you exhaustively match on someexception ? :O
13:03:40 <maerwald> bennofs: I don't see how you cannot?
13:03:51 <nshepperd> by throwing away the SomeException and giving up
13:04:11 <nshepperd> maerwald: you're describing ignoring the SomeException
13:04:18 <nshepperd> not _handling_ it
13:04:30 <nshepperd> which would involve doing something meaningful on, say, a ParseError
13:04:43 <bennofs> maerwald: say that my parseURI function only ever throws ParseErrors, yet the SomeException might also be a UserError from GHC pov, that is a problem with the API
13:04:57 <nshepperd> and something else meaningful on, say, a PermissionDeniedError
13:05:16 <monochrom> it could also be KillThread.
13:05:25 <maerwald> you match on "SomeException e"... and you lose details, you are not ignoring it though
13:05:26 <monochrom> in fact, it is always going to be KillThread.
13:05:26 <mauke> throwTo
13:05:27 <bennofs> monochrom: not in pure code though
13:05:57 <nshepperd> maerwald: details like what to actually do!
13:06:03 <bennofs> maerwald: yes, and losing the details is exactly what makes it impossible to "handle" the exception
13:06:25 <maerwald> depends, but I agree it sucks ofc
13:06:35 <bennofs> maerwald: apart from calling show on it (and what if yoou need to support mutliple output language for your program, not just english?)
13:07:22 <glguy> If the exception isn't in English just throwIO InvalidLanguageInException exception
13:07:42 <bennofs> and that this problem exists is because of a limitation in the API of 'exceptions', not because of GHC
13:07:43 <maerwald> bennofs: I wonder is there a way to fix MonadThrow?
13:08:13 <bennofs> maerwald: yes, by having the exception as type class parameter
13:08:23 <maerwald> so we are back to transformers?
13:08:31 <bennofs> I wonder why the 'exceptions' package did not go with that way, I'm assuming I've overseen something
13:08:37 <bennofs> maerwald: you would not need to use transformers for it
13:08:49 <bennofs> maerwald: you could write instance Exception e => MonadThrow e IO
13:10:02 <bennofs> maerwald: and you could have catch :: (Throws e m => m x) -> (e -> m x) -> m x
13:10:51 <glguy> There couldn't be a fun dep on that instance
13:11:00 <bennofs> glguy: is that a problem?
13:11:04 <glguy> So you wouldn't know that you covered all possibilities
13:11:09 <glguy> Oy
13:11:12 <glguy> Err
13:11:13 <maerwald> bennofs: given you have: parseFoo :: MonadThrow m => ByteString -> m MyResult -- what would it look like with your version?
13:11:30 <glguy> The type could have many instances of MonadThrow
13:11:50 <bennofs> maerwald: parseFoo :: (Throws ParseError m, Throws WhateverOtherError m) => ByteString -> m MyResult
13:12:35 <glguy> So this wouldn't help to handle all exceptions
13:13:15 <monochrom> where is that union type advocate when we need them? :)
13:13:17 <bennofs> glguy: why not? the idea is that `catch` discharges a `Throw` context, one at a time, until you have none left such that you can get at the result 
13:14:20 <nshepperd> in the case of IO, you would have to change it to put the exception in the type
13:14:37 <nshepperd> IO e a
13:15:13 <nshepperd> to be able to handle all possible exceptions from an IO action, that is
13:15:40 <glguy> Bennofs: so you're suggesting something like catch :: (MonadThrow e m=> m a) -> (e -> m a) -> m a ?
13:15:43 <nshepperd> but certainly you could live with the instance for IO being MonadThrow SomeException IO
13:15:47 <bennofs> glguy: exactly
13:16:04 <bennofs> nshepperd: why not Exception e => MonadThrow e IO ?
13:17:14 <glguy> You wouldn't want there to actually be a top level instance of MonadThrow then. You'd need something like what the reflection package does to provide local instances
13:17:43 <maerwald> "make it so"!
13:17:48 <bennofs> glguy: hmm, would toplevel instances for IO be bad though?
13:18:07 <bennofs> glguy: I don't think they would interfere with that
13:18:34 <bennofs> glguy: and for Maybe as well
13:18:41 <bennofs> glguy: just the Either instance would no longer work
13:19:01 <glguy> The top-level instance would allow you to write actions that didn't mention MonadThrow on them in IO
13:19:05 <glguy> and then you wouldn't have to catch them
13:19:13 <bennofs> glguy: yes, I'm fine with that in IO
13:19:25 <bennofs> glguy: since in IO, we don't have that guarrante anyway
13:19:44 <bennofs> (with async exceptions things get complicated in IO)
13:20:26 <maerwald> bennofs: if you implement it, I will download it :P
13:20:30 <bennofs> glguy: the idea is not to force you to handle all exceptions, but to provide a way to make sure that you do, which would still be possible with this approach (as long as your action does not require IO itself)
13:21:36 <bennofs> and it might be possible to even do it with IO through a simple wrapper type, which would then look like noThrow $ someAction `catch` ... `catch` ... or something, but haven't thought through that fully
13:21:41 <Eduard_Munteanu> main could have a type that throws exceptions.
13:24:25 <bennofs> perhaps I should just write checked-exceptions and then get everyone to use it :)
13:25:04 <dysfun> or perhaps we should put everything in Freer
13:26:31 <Eduard_Munteanu> You'd also have to work on stuff like lifted-base.
13:29:29 <bennofs> hmm, perhaps checked-exceptions could even be implemented as a thin layer above 'exceptions'...
13:34:08 --- mode: ChanServ set +o glguy
13:34:08 --- mode: glguy set -bbbo *!~knrdo@111.78.209.215 *!*@gateway/web/freenode/ip.194.219.45.56 *!*@183.136.152.66 glguy
14:06:20 <Darwin226> Hey guys. Is there a way to re-export a module without writing the full export list?
14:06:42 <geekosaur> put "module Whatever" in the export list?
14:06:43 <Darwin226> So, I want to export everything in my module and then an extra module along with it
14:06:53 <Darwin226> and I don't want to write the export list
14:07:02 <geekosaur> you can do that with your current module as well if you want to export the whole module + some things from another
14:08:01 <Darwin226> if I just put module Something in my export list, will I also export everything else?
14:08:11 <geekosaur> no
14:08:26 <Darwin226> So there's no way to avoid the export list?
14:08:34 <geekosaur> but as I just said, you can list your own module there too
14:08:46 <Darwin226> Oh. Right! Thanks
14:08:48 <geekosaur> module Foo (module Foo, module Bar, Baz.Feep(..))
14:09:14 <geekosaur> exports all of Foo, all of imported Bar, and just the Feep type and constructors from Baz
14:31:11 <dysfun> huh, when did haskell.org get a facelift/
14:33:46 * hackagebot hgeos 0.1.5.0 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.5.0 (rcook)
14:37:58 <athan> dysfun: I remember chrisdone did it sometime last year iirc
14:38:38 <glguy> This probably happened since then. Chris Done's design is slightly different
14:44:45 <pavonia> Is there a Haskell package that parses possibly malformed HTML documents to a well-formed DOM tree?
14:45:20 <glguy> tagsoup might be relevant
14:46:22 <pavonia> That's good for the parsing but not the conversion to a well-formed tree, unfortunately
14:56:39 <joe9> I am generating some haskell code using a swagger schema. Instead of doing putStrLn "data SwaggerDefinition ...", is there a more generic way of generating the haskell data types? Can I build some Haskell objects and let something like Language.Haskell.src.Exts print it out or such?
14:57:01 <jmcarthur> somebody stop me i am using unsafeinlineio
14:57:51 <glguy> joe9: Template Haskell is the typical way to programmatically generate Haskell
15:00:57 <joe9> glguy: ok, Thanks. How about GHC.Generics? Can they be useful in anyway? like a ToData or FromData instances, maybe?
15:01:28 <glguy> GHC.Generics isn't generally useful for defining new data types
15:02:17 <glguy> It's actually possible to derive a new data type using GHC.Generics from an existing type, though, if the definition of the new type can be determined from the structure of an existing one
15:03:04 <joe9> glguy:  btw, I want to output code to some files, and then buid code import'ing these files. I do not want to generate haskell data types on the fly (like a lisp macro?). Does that make sense?
15:03:47 <joe9> glguy: yes, that is what I am talking about. figure out a new data type based on a schema definition of the data type.
15:04:51 <joe9> glguy, more like a generator of data types. Instead of a program that builds those haskell data types on the fly. I think the second situation would be hard to debug, etc.
15:05:11 <glguy> OK, well you use type families and data families to derive a new data type from the generic representation of an existing one
15:06:32 <joe9> glguy: I do not understand the implications of what you are saying though I dabbled with Idris some time ago. But, it does sound cool.
15:07:10 <joe9> glguy, any pointers that can help me on this path of using type families and data families, please?
15:07:15 <glguy> joe9: This module is an example of it in action. It might go over your head now or you might get something from looking at it http://hackage.haskell.org/package/generic-trie-0.3.0.2/docs/Data-GenericTrie.html
15:08:03 <glguy> It can derive a map data type based on the structure of a key
15:08:49 <glguy> http://hackage.haskell.org/package/generic-trie-0.3.0.2/docs/Data-GenericTrie-Internal.html#t:GTrie
15:09:15 <joe9> Do i need ghc 8 for this?
15:09:16 <glguy> In particular that shows the way the types are generated
15:09:18 <glguy> no
15:09:32 <glguy> This is a limited and complicated way to go
15:09:51 <glguy> I'm not advocating it, fwiw  :)
15:09:59 <joe9> limited how?
15:10:09 <joe9> glguy:  so, you recommend TH?
15:10:12 <glguy> Yeah
15:10:41 <glguy> You have to think of a way to derive the type you wanted using type/data families with the generic Rep representation of your type
15:11:06 <glguy> and type-level computation is rather limited
15:11:13 <Zemyla> You know, I've jad to manually derive Generics for things.
15:13:53 <joe9> Zemyla: What does "jad" mean? good or bad?
15:13:57 <glguy> had
15:14:09 <Zemyla> Yeah, phone keyboard.
15:14:09 <joe9> oh, ok. Thanks. glguy.
15:14:32 <joe9> I wish i could somehow use Idris to do this though.
15:36:23 <Zemyla> Is there a way to wait on more than one MVar without having to fork?
15:37:35 <hpc> some kind of loop with tryTakeMVar?
15:43:48 * hackagebot HGE2D 0.1.9.2 - 2D game engine written in Haskell  https://hackage.haskell.org/package/HGE2D-0.1.9.2 (I3ck)
15:46:01 <EvanR> Zemyla: the async library is probably easiest
15:46:10 <EvanR> and less error prone
15:49:09 <rrika> The first 'example' link on https://www.haskell.org/haddock/ is dead
15:51:14 <systemfault> I know that C++'s type system is a joke compared to Haskell but, with it, you can do something like template<typename Type, size_t Dimension>struct vector{}; and then vector<double, 2> is a different type than vector<double, 3>. Is it possible to do that with Haskell or you need something like Idris?
15:54:33 <pavonia> systemfault: I think with GHC's type-level literals you can. Or you define an inductive naturals type yourself
15:55:01 <systemfault> Ok, but OOB with the core language, it cannot be modeled?
15:56:24 <pavonia> I don't know what the core language is
15:57:08 <systemfault> Without any GHC extension and not by defining an inductive natural type.
15:57:48 <pavonia> AFAIK, no
15:58:53 <pavonia> But without extensions, there's not so much you can do at the type-level anyway :p
15:59:05 <systemfault> Thank you, just surprised that the big and clunky language that is C++ supports that.
16:01:04 <geekosaur> templates are essentially source transformations. not a whole lot different from defining a C preprocessor macro in this case. (which you can also do with ghc, with an extension, not that it's a great idea)
16:02:35 <systemfault> geekosaur: templates still care about C++'s "wannabe type system" though, unlike the CPP, right?
16:03:32 <systemfault> Thank you for your answers, it was interesting for me :)
16:03:34 <geekosaur> sort of. the point is more that you can make something that looks like a value act like something at type level, with some restrictions because it's not actually at value level. templates are at something of a weird point in metaprogramming space
16:04:10 <geekosaur> ghc also has various metaprogramming features ranging from being able to use c preprocessor macros up to template haskell (kinda directly hacking the AST the compiler is building)
16:07:40 <geekosaur> templates make it scarily easy to get into places where not only are you surrounded by edge cases, but everything is an edge >.>
16:08:54 <d624> Hi all
16:09:20 <glguy> hi
16:09:40 <zedronar> hi
16:26:37 <Phyx-> hello
17:02:34 <ibrahims_> Hey, i get a Test error while installing Glob package. Is it something related with the package?
17:02:43 <ibrahims_> i opened an issue here https://github.com/Deewiant/glob/issues/5
17:02:51 <ibrahims_> Deewiant: are you the maintainer?
17:10:37 <ReinH> ertes: huh, funny seeing my blog post from 2008 referenced here
17:13:30 <shirt> If i want to return the character that comes after the Nth 'a' character in a Text, should i use Text.foldl or Text.foldr?
17:22:45 <glguy> foldr
17:23:18 <glguy> that way you can stop early
17:24:08 <shachaf> If it's a Data.Text, I imagine that both of them can stop early?
17:24:20 <shachaf> strict
17:24:23 <shachaf> But if you're counting from the left then foldr makes sense.
17:24:44 <shachaf> Maybe I'm assuming too much about Data.Text.
17:24:52 <glguy> Maybe we both are, hard to say
17:42:18 <dolio> If they were trying to be clever, maybe neither can stop early.
17:43:37 <c_wraith> It's a shared interface with Data.Text.Lazy, so I bet foldr can terminate early
17:47:54 <shirt> i can't figure out how foldr will terminate early, since early termination relies on the accumulating parameter
17:51:52 <glguy> > let myTake n xs0 = foldr (\x xs n -> if n > 0 then x : xs (n-1) else []) (const []) xs0 n in myTake 5 [1..10]
17:51:54 <glguy> consider
17:51:54 <lambdabot>  [1,2,3,4,5]
17:53:45 <shirt> the accumulating value is a function?
17:56:40 <glguy> Yeah, even better is to not think of foldr as having an "accumulator"
18:01:15 <shirt> how then to think of it?
18:02:31 <dibblego> replace constructors with the argument values http://functionaltalks.org/2013/06/19/tony-morris-explain-list-folds-to-yourself/
18:02:56 <dibblego> (foldr f z list) replaces (:) with (f) and [] with (z) in (list).
18:12:47 <shirt> > let myTake n xs0 = foldr (\x xs n -> if n > 0 then x : xs (n-1) else []) undefined xs0 n in myTake 5 [1..10]
18:12:49 <lambdabot>  [1,2,3,4,5]
18:25:58 <Trooper_> anyone here? 
18:29:20 <pavonia> Nope
18:30:41 <Trooper_> stuck trying to solve this image steganography exercise, would someone be able to help take a look?
18:31:06 <shachaf> If you have a question you should just ask it.
18:31:18 <shachaf> Rather than asking people to commit to helping you without even seeing the question.
18:31:44 <Trooper_> Okay, got it
18:31:54 <Trooper_> There's a hidden clue in this image
18:31:54 <Trooper_> http://www.filedropper.com/blankimage
18:32:05 <Trooper_> I can't see to find it however, though I know it's there. 
18:32:12 <shachaf> Is this related to Haskell?
18:32:36 <Trooper_> Not really 
18:32:39 <Trooper_> sorry
18:32:51 <shachaf> Then it's off-topic here.
18:33:11 <shachaf> Ask elsewhere (Now I see that you've already posted this elsewhere).
18:33:18 <Trooper_> okay
19:03:57 <zinking> how to understand `second succ (3,1)`
19:04:10 <zinking> does succ gets applied fist 
19:04:11 <zinking> ?
19:04:46 <zinking> the result looks like `second` gets applied first
19:05:07 <Clint> :t second
19:05:09 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
19:05:10 <Clint> :t second succ
19:05:11 <lambdabot> Enum c => (d, c) -> (d, c)
19:05:20 <dmwit> zinking: `second` applies its first argument to the second part of its second argument
19:05:28 <zlens> what is a good screencast to watch to learn how to do unit testing in ahskell? (in particular, test driven development)
19:05:35 <dmwit> zinking: So `second succ` is like `\(x, y) -> (x, succ y)`.
19:07:12 <zinking> I see, thanks
19:08:03 <zinking> seems I have mixed `second` with `and`
19:08:09 <zinking> `s nd`
19:08:34 <dmwit> `and` is a very different operation, yeah.
19:38:55 <zinking> would fmap Just(*3)  Just(1) work ?
19:39:28 <zinking> LYHFGG suggests it won't but I tried out on my ghci, it works
19:39:54 <geekosaur> seems some missing parens there...
19:40:03 <alercah> :t fmap Just (*3) Just (1)
19:40:04 <lambdabot>     Couldn't match type ‘Maybe (a0 -> Maybe a0)’ with ‘Integer -> t’
19:40:04 <lambdabot>     Expected type: (a0 -> Maybe a0) -> Integer -> t
19:40:04 <lambdabot>       Actual type: (a0 -> Maybe a0) -> Maybe (a0 -> Maybe a0)
19:40:11 <shachaf> What does it mean to work?
19:40:33 <glguy> The verb?
19:40:53 <zinking> get Just 3
19:41:30 <zinking> let a = fmap (* 1)
19:41:41 <zinking> fmap a Just 3
19:41:42 <glguy> > Just(*3) <*>  Just(1)
19:41:44 <lambdabot>  Just 3
19:42:43 <jle`> zinking: fmap a Just 3 is (fmap a Just) 3
19:42:49 <geekosaur> tht doesn't mean what you think...
19:42:55 <geekosaur> yeh,. that
19:43:29 <jle`> that's using fmap for the Function instance, which is (.)
19:43:34 <jle`> so that's really (fmap (*1) . Just) 3
19:43:47 <jle`> or fmap (*1) (Just 3)
19:45:31 <zinking> so meaning fmap (Just(*1)) (Just 3) won't work
19:45:42 <zinking> but Just(*1) <*> Just 3 will work
19:51:30 <geekosaur> I have to wonder if you realize that (x Just(*y)) does not mean the *y is provided to Just, but that it is provided to x, Haskell function calls do not work like function calls in Algol/C family languages
19:53:27 <shachaf> In general writing something "Just(*1)" is a bit rude. It's misleading, and should be written "Just (*1)" like any other application unless you're golfing or something.
19:53:57 <geekosaur> they pinged out right after I sent :/
19:54:35 <shachaf> I see.
19:55:27 <geekosaur> I wouldn't say it's "rude", unless they actually know better --- decidedly unproven in this case
19:55:50 <shachaf> Well, that's not quite the right word.
19:56:03 <shachaf> Saying something is rude is a bit rude.
19:57:17 <geekosaur> but then it took me long enough to figure out how to phrase my comment that they were gone by the time I did (and it's still not quite right... sigh)
19:57:19 <EvanR> rude.
20:48:58 * hackagebot network 2.6.3.1 - Low-level networking interface  https://hackage.haskell.org/package/network-2.6.3.1 (dukerutledge)
21:01:22 <ertes> ReinH: huh?  which one?
21:07:24 <rel> How do I refer to the `'[]` (promoted list) `TyCon` with the GHC API?
21:07:46 <joe9> I am trying to understand how gfoldl works. I found this http://stackoverflow.com/questions/29119986/understanding-the-type-signature-of-gfoldl-from-data-data-data but could not understand it. Is anyone of any place where I can read about it with some examples?
21:13:05 <Zemyla> joe9: You know basically how Applicatives work, right?
21:15:08 <joe9> yes, f (a -> b ) -> f a -> f b
21:15:34 <joe9> Zemyla: ^^
21:18:41 <athan> rel: It's just '[]
21:18:51 <Zemyla> Actually, a better description is that it's kind of like a Traversable, except with Data types instead of a specific type.
21:19:01 <athan> sometimes you need to quote type level lists, I had to tinker with it too
21:19:15 <athan> like sometimes it will infer that it's type level without the quote, but sometimes it won't :s
21:19:31 <athan> I've also had to use `(':) x xs` before :x
21:19:50 <athan> note though that GHC.TypeLits doesn't suffer from this
21:20:55 <Zemyla> So what happens is that the second function, which is rather like pure, is passed a constructor function, like Left or (,) or fromList.
21:21:34 <Zemyla> Then the first function is called several times on the result, each time passing in one argument.
21:21:35 <rel> athan: Maybe I'm missing something obvious. How do I convert the string into a `TyCon`? I've been using `lookupOrig` and `tcLookupTyCon`?
21:22:31 <joe9> Zemyla: do you mind showing an example, please?
21:23:57 <Zemyla> For Either, we have gfoldl f z (Left l) = f (z Left) l; gfoldl f z (Right r) = f (z Right) r.
21:24:57 <Zemyla> For (,) we have gfoldl f z (a, b) = f (f (z (,)) a) b.
21:25:01 <joe9> Zemyla: ok, Thanks. I need some more time understand it.
21:33:59 * hackagebot non-empty-sequence 0.2.0.0 - Non-empty sequence  https://hackage.haskell.org/package/non-empty-sequence-0.2.0.0 (OmariNorman)
21:36:08 --- mode: ChanServ set +o glguy
21:36:08 --- mode: glguy set -bbbb *!*@186.56.223.28 slack-haskell!*@*$##fix_your_connection *!*@ip72-197-167-107.sd.sd.cox.net *!*goodboy@93.99.16.*
21:38:36 --- mode: glguy set -bb *!*bc812366@*.bstnma.fios.verizon.net *!*Mandy21@37.221.169.*
21:39:00 * hackagebot non-empty-sequence 0.2.0.2 - Non-empty sequence  https://hackage.haskell.org/package/non-empty-sequence-0.2.0.2 (OmariNorman)
21:51:36 <joe9> Do you know where I can find this package:  Data.HashMap.Strict.InsOrd.InsOrdHashMap ? I can find Data.HashMap.Strict
21:51:47 <joe9> but, not the ..InsOrd.InsOrdHashMap
21:51:49 <glguy> unordered-containers
21:51:55 <glguy> Has Data.HashMap.Strict, at least
21:51:59 <glguy> never heard of InsOrd
21:53:07 <joe9> glguy: Tried that and got this error message http://bpaste.net/show/9d749a39b65b H is for Data.HashMap.Strict
21:53:38 <glguy> ?google Data.HashMap.Strict.InsOrd
21:53:39 <lambdabot> https://hackage.haskell.org/package/insert-ordered-containers/docs/Data-HashMap-Strict-InsOrd.html
21:54:05 <joe9> glguy: cool, Thanks.
21:54:06 <saurabhnanda> can anyone please help me with http://stackoverflow.com/questions/38644779/how-to-use-quickcheck-to-test-database-related-functions
21:54:15 <glguy> It's a search engine, highly recommend
21:54:23 <saurabhnanda> how to use QuickCheck with Persistent in a sane manner
21:55:45 <joe9> glguy: I tried it with startpage
21:56:02 <glguy> never heard of it
21:56:07 <joe9> glguy and could not find anything. should have tried google too.
22:15:10 <saurabhnanda> is there a way to lift/fmap something only ONE level into a transformer stack?
22:16:39 <EvanR> :t lift
22:16:40 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
22:16:44 <EvanR> lift lifts 1 level
22:17:01 <saurabhnanda> EvanR: that doesn't seem to be happening
22:17:18 <EvanR> :t lift . lift
22:17:19 <lambdabot> (Monad m, Monad (t1 m), MonadTrans t, MonadTrans t1) => m a -> t (t1 m) a
22:17:20 <saurabhnanda> runTests pool = lift (flip runSqlPool pool) prop_childCreation 
22:17:47 <EvanR> well whats the error
22:19:00 * hackagebot rtlsdr 0.1.0.5 - Bindings to librtlsdr  https://hackage.haskell.org/package/rtlsdr-0.1.0.5 (adamwalker)
22:26:17 <saurabhnanda> prop_childCreation :: PropertyM (SqlPersistT IO) Bool 
22:26:41 <saurabhnanda>       Couldn't match kind ‘* -> *’ with ‘*’
22:26:42 <saurabhnanda>      When matching types
22:26:42 <saurabhnanda>        t0 :: (* -> *) -> * -> *
22:26:43 <saurabhnanda>        (->) :: * -> * -> *
22:26:45 <saurabhnanda>      Expected type: PropertyM (SqlPersistT IO) Bool -> m a
22:26:47 <saurabhnanda>        Actual type: t0 ((->) (SqlPersistT m a)) (m a)
22:26:49 <saurabhnanda>      The function ‘lift’ is applied to two arguments,
22:26:50 <EvanR> blarg
22:26:51 <saurabhnanda>      but its type ‘(SqlPersistT m 
22:27:22 <saurabhnanda> but its type ‘(SqlPersistT m a -> m a) -> t0 ((->) (SqlPersistT m a)) (m a)’  has only one
22:27:31 <EvanR> so you missed an argument somewhere maybe
22:27:56 <saurabhnanda> basically, I'm trying to compost (PropertyM (SqlPersistT IO) Bool) with monadicIO and runSqlPool function
22:29:13 <geekosaur> @paste
22:29:13 <lambdabot> Haskell pastebin: http://lpaste.net/
22:29:51 <pavonia> Composting monads if you don't need them anymore? :)
22:29:55 <geekosaur> actually your lift looks wrong, and the error message tells you why
22:30:08 <saurabhnanda> monadicIO :: IO a -> Property
22:30:37 <saurabhnanda> runSqlPool :: SqlPeristT m a -> ConnectionPool -> m a
22:33:54 <saurabhnanda> sorry monadicIO :: PropertyM IO a -> Property 
22:34:20 <saurabhnanda> and proper_childCreation :: PropertyM (SqlPersistT IO) Bool
22:34:32 <saurabhnanda> I want a way to do the following:
22:34:45 <saurabhnanda> (f prop_childCreation) :: PropertyM IO Bool
22:35:01 <saurabhnanda> (g (f prop_childCreation)) :: Property
22:35:05 <saurabhnanda> how do I do this?
22:35:10 <saurabhnanda> have been breaking my head for 2 days now
22:36:08 <geekosaur> you can't get there with a lift. you need to use a runWhatever in an IO action
22:36:16 <geekosaur> this is the reverse of a lift
22:36:37 <saurabhnanda> how is this compoable?
22:37:40 <glguy> seems like you'll have to use
22:37:47 <glguy> monadic' :: Monad m => PropertyM m a ->Gen (m Property)
22:38:20 <saurabhnanda> glguy: and next step?
22:39:01 * hackagebot dynamic-graph 0.1.0.9 - Draw and update graphs in real time with OpenGL  https://hackage.haskell.org/package/dynamic-graph-0.1.0.9 (adamwalker)
22:40:19 <glguy> and then you'll have to do the next step
22:40:24 <saurabhnanda> runTests :: Gen (SqlPersistT IO Bool)
22:40:34 --- mode: glguy set -o glguy
22:40:52 <saurabhnanda> back to the same problem, right?
22:41:06 <saurabhnanda> it was PropertyM SqlPersistT IO Bool
22:41:14 <saurabhnanda> now it's Gen SqlPersistT IO Bool
22:42:48 <glguy> Not the same problem, no
22:43:12 <glguy> and not a Gen SqtPersistT IO Bool, either
22:44:02 <glguy> You'd have a Gen (SqlPersistT IO Property)
22:44:13 <glguy> not a bool, and with different ()s
22:45:34 <glguy> and now you can get to the (SqlPersistT IO Property) because Gen is a functor
22:46:02 <glguy> Once you get rid of the SqlPersistT and just have an IO Property, you can use ioProperty to get a Property
22:46:30 <glguy> And (Gen Property) is an instance of Testable
22:58:31 <eklavya> good people of #haskell with your much needed help, I have been able to create a cassandra driver, if you have time please look at https://github.com/eklavya/hascas and help me improve it
22:59:02 * hackagebot fftwRaw 0.1.0.1 - Low level bindings to FFTW.  https://hackage.haskell.org/package/fftwRaw-0.1.0.1 (adamwalker)
23:09:02 * hackagebot sdr 0.1.0.8 - A software defined radio library  https://hackage.haskell.org/package/sdr-0.1.0.8 (adamwalker)
23:11:16 <ongy> sdr library in haskell? I need to have a look at that
23:12:21 <maybefbi>  how can i access :: Hasql.Pool.Pool inside  :: BasicAuthCheck User ?
23:38:35 <Hi-Angel> Why would "stack install" complain about mismatched ghc version even after I ran "stack setup"? Do I need to setup some environment variables for stack to see the compiler it just installed, or what?
23:42:18 <Hi-Angel> Ah, okay, turns out the compiler that stack just installed doesn't even work, it complains about missing libtinfo library.
23:50:45 <glguy> you'll have to install libtinfo with your package manager
23:52:37 <Hi-Angel> Yeah, I did already. Now "stack install" complains about missing id, and reran of "stack setup" complain about failed sanity check. So I nuked the ~/.stack directory, and now "stack setup" works.
23:53:07 <glguy> yay!
