00:00:27 <quchen> pavonia: Maybe a different approach works better? Why can’t you modify “p”?
00:01:25 <pavonia> It's a parser from a package that I want to extend to accept some suffixes
00:01:50 <pavonia> I guess I have to split the string first and parse both parts separately then
00:01:50 <ertesx> p *> string " bar"?
00:02:24 <quchen> ertesx: p consumes the space already
00:02:36 <pavonia> ertesx: It's actually many (char ' ')
00:02:38 <quchen> Eh, and then fails.
00:03:16 <ertesx> ah, yeah
00:03:20 <quchen> Now I’m confused, maybe all I said was wrong. :-$
00:04:02 <ertesx> 'optional' doesn't backtrack by itself
00:04:19 <quchen> As much as I like “try” (sorry kosmikus) it sometimes makes reasoning difficult.
00:04:50 <quchen> Combinatorically difficult, that is
00:04:57 <ertesx> so there is a prefix that must be read by 'p' (because you don't want to reimplement it)
00:05:11 <Enigmagic> attoparsec doesn't have try
00:05:17 <ertesx> and it awkwardly takes an optional suffix, but already consumes as soon as it finds a space
00:05:40 <ertesx> i'd say:  fix the library that defines 'p'
00:05:59 <quchen> Enigmagic: Well, it has “try”, but it’s literally the identity
00:06:07 <quchen> (For compatibility)
00:06:22 <pavonia> ertesx: To use try for the optional part?
00:06:32 <Enigmagic> aka: it doesn't have try :p
00:06:33 <quchen> http://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/src/Data-Attoparsec-Combinator.html#try
00:06:40 <ertesx> pavonia: to use 'try' for the grammatical part, e.g. spaces
00:06:57 <ertesx> pavonia: not for the whole optional part (that would be wrong for a different reason)
00:07:12 <pavonia> What do you mean by grammatical part?
00:07:25 <quchen> Ad-hoc parsers are far too easy to write in Haskell. I sometimes wish we had a proper lexing and parsing phase.
00:07:36 <ertesx> pavonia: p = prefix *> optional (try spaces *> suffix)
00:07:40 * hackagebot quiver-groups 0.1.0.1 - Group and chunk values within a Quiver  https://hackage.haskell.org/package/quiver-groups-0.1.0.1 (IvanMiljenovic)
00:07:40 * hackagebot unordered-graphs 0.1.0.1 - Graph library using unordered-containers  https://hackage.haskell.org/package/unordered-graphs-0.1.0.1 (IvanMiljenovic)
00:08:33 <pavonia> Is that a general recommandation for writing such parsers?
00:08:34 <quchen> ertesx: Would that work if suffix was (partially) consumed?
00:08:58 <quchen> pavonia: A common convention is that each syntactical element should also consume all spaces after it
00:09:02 <verrlara> Cale: Hope you have a good night. Thanks for the help. Do you use xmonad? I might need some help just having someone explain a config to me once before I start my own. 
00:09:04 <ertesx> quchen: if suffix is partially consumed, but doesn't succeed, the whole parser fails with consumed input
00:09:24 <ertesx> quchen: but if the suffix fails without consuming, the whole thing fails without consuming
00:09:34 <ertesx> uhm
00:09:39 <Cale> I don't use xmonad myself, but lots of people here do...
00:09:39 <ertesx> the whole thing succeeds
00:10:27 <quchen> ertesx: Right, but what about parsing “foo for”? That should be a valid “extension” of the grammar with “for” instead of “bar” which this could not parse
00:10:28 <Cale> I've also sometimes successfully answered questions about it, just because I can read its documentation and intuit what's going on :)
00:10:41 <ertesx> pavonia: 'try' is a delicate construct…  it's easy to use it wrong in subtle ways and only notice it when the parser errors are completely nonsensical
00:11:39 <quchen> My advice for using “try” is to treat it as “unsafeTry” and explain every single use of it
00:12:38 <ertesx> pavonia: i found this article enlightening: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
00:12:42 <verrlara> Mainly I have been looking at other peoples configurations, running them through the xmonad compiler, trying them on, seeing what I like about them, then wanting to see if I could throw bits of each of those configs together to make my own. But I really want to understand what is going on so I know where to look for errors and what not. 
00:13:40 <Enigmagic> :r
00:13:56 <verrlara> did I say a badword?
00:15:03 <Enigmagic> pavonia: anyhow, it works just fine in attoparsec https://github.secureserver.net/gist/nhowell/a671614ed627db34b0791db275569c34
00:16:42 <pavonia> Enigmagic: That link doesn't work for me
00:16:52 <pavonia> Times out
00:16:59 <Enigmagic> doh
00:17:02 <Enigmagic> wrong server :p
00:17:34 * hackagebot dns 2.0.4 - DNS library in Haskell  https://hackage.haskell.org/package/dns-2.0.4 (KazuYamamoto)
00:17:49 <Enigmagic> pavonia: https://gist.github.com/NathanHowell/a7cb2d1fef9d0cf1b59659b77f9970b6
00:19:17 <pavonia> Nice, I guess I'll port everything to attoparsec then
00:21:08 <ertesx> that's not the conclusion you should draw =)
00:21:48 <pavonia> It's easier than thinking hard about where to add try's and where not :p
00:22:56 <ertesx> in fact i came to dislike the auto-backtracking behaviour of attoparsec, especially since it disagrees with its philosophy to be lean and fast
00:23:17 <ertesx> i do like the megaparsec library
00:24:55 <pavonia> How is megaparsec different from attoparsec on this point?
00:25:26 <Enigmagic> i prefer composability by default, i can make stuff faster later if need be
00:25:41 <Enigmagic> the STM would be impossible to use if it had a try combinator :p
00:27:42 <ertesx> pavonia: it's an improved fork of parsec
00:27:50 <ertesx> Enigmagic: i like both =)
00:28:08 <ongy> verrlara: there is no "xmonad compiler", it just uses ghc
00:28:39 <pavonia> ertesx: So you still have to use try explicitly?
00:28:50 <ertesx> pavonia: yeah
00:29:48 <quchen> For something really cool look at Trifecta. Unfortunately, the documentation is abysmal, so looking at existing code is the go-to tutorial.
00:29:52 <ertesx> pavonia: attoparsec's error reporting is basically: "your input sucks, i won't parse!"
00:30:05 <ertesx> that's why it gets away with auto-backtracking
00:30:06 <verrlara> ongy: Guess I was confused by xmonad --recompile as being its own compiler
00:30:06 <quchen> I used merijn’s lambda-except package to implement my STG parser.
00:30:10 <pavonia> :)
00:30:24 <quchen> merijn looked at Idris’ source I think.
00:31:11 <EvanR> who needs docs when you have.... 
00:31:15 <EvanR> nvm
00:31:39 <quchen> (CharParsing p, Monad p, LookAhead p) => p a -- what part of this do you not understand
00:32:05 <ertesx> it's an edwardk package, so you don't need docs…  all you need is a category theory book on the table =)
00:32:22 <quchen> No, that doesn’t help, it’s pretty light on math
00:32:23 <EvanR> uhg
00:32:37 <quchen> It’s really just poorly documented
00:32:43 <EvanR> type classes vs the world
00:33:05 <kosmikus> quchen: try? what?
00:33:22 <quchen> kosmikus: Parser “try”
00:33:28 <EvanR> BigBudget3DMMO p => p a
00:33:30 <quchen> Which you despise if I recall correctly
00:34:30 <kosmikus> quchen: oh yes, of course I do :)
00:35:21 <quchen> kosmikus: And why? You often mentioned that it’s known to be a bad idea for decades
00:35:50 <quchen> Try lets me control the amount of lookahead, that’s what I use it for
00:36:17 <ertesx> try a <|> try b <|> try c <|> try d <|> try e <|> f
00:36:18 <quchen> So in an Applicative parser for example, I often write   (try (foo <$> bar)) <*> bar <*> baz
00:36:27 <quchen> ertesx: Sure, that way of using try is bad.
00:36:49 <quchen> But you can also use try to say “this part can backtrack, but the rest cannot”
00:36:53 <ertesx> @let really f = f . f . f
00:36:54 <kosmikus> quchen: it's inherently uncompositional
00:36:55 <lambdabot>  Defined.
00:37:11 <quchen> kosmikus: In what way?
00:37:32 <ertesx> try a <|> really try a <|> (empty <?> "yeah, whatever!")
00:37:56 <Enigmagic> quchen: for the same reason the earlier example works in attoparsec but not in parsec
00:38:25 <ertesx> or to put it in attoparsec's words…
00:38:36 <ertesx> empty <?> "your input sucks, i won't parse!"
00:38:54 <Enigmagic> attoparsec's terrible failure messages are a different issue
00:39:08 <quchen> Mathematica has the /@@ operator if I recall correctly. “f /@@ xs” maps f over all elements of the following list (and almost everything being lists, it maps f EVERYWHERE). ertesx needs “try /@@” I think
00:39:29 <quchen> It’s like a tree map on steriods
00:39:43 <ertesx> sounds like fmap
00:40:06 <quchen> ertesx: Untyped, recursive fmap
00:42:33 <ertesx> sequenceA . fmap try  -- like this?
00:44:37 <quchen> mapAll f [a, [b,c], [d,e,f]] = f [f a, f [f b, f c], f [f d, f e, f f]]
00:44:53 <quchen> Ignore the duplicate “f”, my renamer ran out of symbols
00:45:21 <quchen> ertesx: ^
00:48:53 <osa1> any Happy users here? I have a reduce/reduce conflict in my grammar but Happy doesn't tell me where it is. is there a way to get more info from Happy?
00:48:57 <ertesx> quchen: that looks like a bad idea…  i like it =)
00:49:16 <ertesx> quchen: (i programmed in PHP for several years in the dark ages)
00:49:17 <quchen> ertesx: Not many things make sense with that function, yeah
00:49:33 <quchen> But there are some that would make sense even in Haskell, such as force
00:49:37 <quchen> and try ;-)
00:49:40 <ertesx> quchen: although -XDeriveGeneric gives us some of that =)
00:55:37 <kosmikus> quchen: sorry, was on a phone call. do you still want me to explain?
00:56:15 <quchen> kosmikus: Sure!
00:56:53 <kosmikus> quchen: you may have a parser p which works perfectly, and another parser q which also does, but p <|> q does not
00:57:14 <kosmikus> quchen: instead, you suddenly have to write try p <|> q, but even that might not actually be what you need to fix the problem properly
00:57:35 <kosmikus> quchen: in fact, you might go inside of p and put a try somewhere deep inside the definition of p to make it work properly
00:57:46 <kosmikus> quchen: but now, p might be used in other places, too
00:58:07 <kosmikus> quchen: and strictly speaking, it's not clear that the try you have just added is needed or even helpful for these other uses
00:58:24 <kosmikus> quchen: therefore, uncompositional
00:58:41 <quchen> What are examples of p and q? let/letrec?
00:59:09 <kosmikus> quchen: well, yes, any situation in which p and q have overlap in their "first set"
00:59:46 <kosmikus> quchen: I guess the situation owuld be somewhat better if the first set of a parser was tracked in its type
01:01:46 <quchen> kosmikus: Hm. That seems to make try hard to reason about indeed.
01:01:59 <quchen> kosmikus: Maybe I’m misusing try for lookahead.
01:02:12 <quchen> That’s ultimately what I try to limit its use to.
01:02:30 <quchen> Instead of looking ahead, just do what’s ahead, and on failure backtrack here.
01:02:33 <kosmikus> quchen: well, that's what it does, yes
01:02:46 <kosmikus> quchen: it's a kind of anti-cut :)
01:02:57 <quchen> Cut?
01:03:02 <kosmikus> quchen: prolog cut
01:03:13 <quchen> I don’t know Prolog
01:03:22 <kosmikus> quchen: the real problem is also not try, but the fact that try is necessary
01:03:28 <kosmikus> quchen: or sometimes necessary
01:03:36 <quchen> Practically necessary?
01:03:41 <quchen> Or necessary in what way
01:04:06 <kosmikus> quchen: the real problem is the non-backtracking nature of parsec being inherently uncompositional
01:04:13 <kosmikus> quchen: which makes the use of try necessary
01:04:29 <kosmikus> quchen: but placing try incorrectly can quickly lead to performance problems
01:05:21 <quchen> kosmikus: So what’s the benefit of conditional backtracking? I thought it was crucial for good error messages 
01:05:46 <kosmikus> quchen: no. there's a potential performance benefit.
01:06:11 <kosmikus> quchen: if you naively implement full backtracking, as the early parser combinators all did ...
01:06:56 <kosmikus> quchen: ... then once you start parsing, you hold on to the input at that position until you know for sure you won't have to backtrack to this point
01:07:22 <kosmikus> quchen: so if you have unbounded lookahead anywhere, that translates to unbounded space use
01:07:57 <kosmikus> quchen: parsec was an early success in fixing this problem by disabling full backtracking
01:08:05 <quchen> Interesting
01:08:09 <kosmikus> quchen: which means you typically can throw away any token immediately after you've looked at it
01:08:23 <kosmikus> quchen: and only hold on to input if you specifically mark the position using try
01:09:16 <kosmikus> quchen: however, there's a range of other methods one can use to fix or at least bypass this problem
01:10:32 <quchen> Such as?
01:10:42 <quchen> uu-parsinglib and trifecta are sometimes mentioned here
01:10:51 <kosmikus> quchen: one common trick is to use a form of "parallel" parsing
01:10:59 <kosmikus> quchen: which is for example what uu-parsinglib does
01:11:29 <kosmikus> quchen: so rather than trying the first alternative of a choice point until it fails (which may be very late) and then backtrack all the way
01:11:48 <kosmikus> quchen: you actually start parsing both alternatives simultaneously
01:12:02 <kosmikus> quchen: and as soon as one of them fails, you continue with just the other
01:12:31 <kosmikus> quchen: so this way, if your first alternative succeeds and the second fails quickly
01:12:47 <kosmikus> quchen: we don't have to hold on to any input anymore
01:12:59 <kosmikus> quchen: in fear that the first alternative might still fail too
01:13:10 <quchen> That’s an interesting concept.
01:13:17 <quchen> I should have a look at the source of that
01:13:29 <quchen> (And I wonder why Trifecta has “try” now)
01:13:31 <kosmikus> quchen: I think this has first been introduced by Koen Claessen
01:13:54 <kosmikus> quchen: I think the goal of trifecta was primarily to have better errors?
01:14:15 <quchen> I’m not sure, it’s certainly one of its selling points though
01:14:23 <kosmikus> quchen: but I'm not that familiar with it. I just thought that the original motivation for trifecta was to have clang-style colored error messages with cursors indicating the error position
01:14:42 <kosmikus> quchen: which is a very worthy goal. and you cannot always fix all problems at once.
01:15:54 <kosmikus> quchen: so for the parallel parsing stuff, read http://www.cse.chalmers.se/edu/year/2015/course/afp/Papers/parser-claessen.pdf and perhaps http://www.cs.uu.nl/docs/vakken/afp/Literature/p224-swierstra.pdf
01:15:55 <quchen> Claessen has a paper about parsers
01:16:07 <quchen> Yes, that one. :-
01:16:08 <quchen> )
01:16:26 <adarqui> anyone here ever use the web-routes package? https://hackage.haskell.org/package/web-routes-0.27.10/docs/Web-Routes-PathInfo.html   .. i'm running into an issue where i can't parse a segment of "" as say, "/" when using fromPathInfo.. ie, fromPathInfo = Home <$ segment ""
01:18:23 <adarqui> https://hackage.haskell.org/package/web-routes-0.27.10/docs/src/Web-Routes-PathInfo.html#segment
01:18:33 <adarqui> maybe i need to write my own function for an empty segment
01:18:45 <adarqui> it works with toPathInfo but not fromPathInfo
01:20:08 <kosmikus> quchen: we'll probably have a parsing talk at the eXchange :)
01:20:22 <quchen> Oh?
01:20:37 <quchen> From Utrecht implementors?
01:20:42 <kosmikus> no
01:21:40 <kosmikus> quchen: but with Utrecht history
01:24:23 <ertesx> quchen: i think arrows were invented specifically for the purpose of parallel parsing
01:24:44 <quchen> The paper mentions this as well in the introduction, yeah
01:27:29 <kosmikus> ertesx: yes, but that was in a time when applicative functors were only known "implicitly"
01:28:06 <kosmikus> ertesx: some UU parser libs were using an applicative interface, but the abstraction didn't yet have a name
01:30:03 <ertesx> kosmikus: one reason i like 'try' is that it gives me control over error reporting
01:30:20 <ertesx> parallel parsers have not really solved that as far as i'm aware
01:32:04 <rumia> [ https://a.pomf.cat/hirzih.jpg ] [ https://a.pomf.cat/uiywqg.jpg ] [ https://a.pomf.cat/nmhsiv.jpeg ] [ https://a.pomf.cat/losaig.png ]
01:33:20 <kosmikus> ertesx: I'm not sure if I understand what you mean
01:33:29 <kosmikus> ertesx: do you have a small example?
01:35:40 <TomSmeets> Hello. Is it possible to run the ghci interactive shell in parallel with the main method? I want to be able to debug xmonad with ghci while it is running.
01:36:55 <tdammers> TomSmeets: you can use concurrency stuff from within ghci, e.g. forkIO, but that doesn't allow you to attach to the main action while it's executing
01:37:04 <tdammers> so it's probably useless
01:38:05 <TomSmeets> Thanks, I can try that.
01:49:34 <adarqui> is there a sexier way to do this: http://lpaste.net/170559
01:49:41 <adarqui> getting late and i can't think of anything .. ugly :(
01:50:27 <adarqui> fwiw, i just added those try's because i need them.. my routes share the same segment "_edit" and "_delete" have multiple branches.
01:51:08 <TomSmeets> XMonad complains with (Can't open display) when run from ghci.
01:53:15 <pavonia> adarqui: What is the context of this?
01:54:49 <adarqui> parsing url routes
01:55:00 <adarqui> btw i meant, cleaning up the "try" blocks
01:55:17 <adarqui> i had everything lined up via <|> and it was pretty.. but i needed those try's because i have those overlapping paths
01:55:29 <adarqui> so wondering if there's any way to make those 'try blocks' look pretty
01:56:12 <pavonia> As a parser it makes no sense to me, because you never reach the second or third segment if they are the same
01:57:00 <Arguggi> I'm trying to use parseTimeM ( https://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Format.html#v:parseTimeM ) , can I somehow return an Either when the parsing fails instead of throwing an exception like it does now with fail? (I have to implement the https://hackage.haskell.org/package/http-api-data-0.2.3/docs/Web-HttpApiData.html#t:FromHttpApiData class)
01:57:28 <adarqui> hmm? in the edit block.. it tries EditI , then if that fails, it will go to EditS
01:58:19 <pavonia> That's the part I don't get, how can it "try EditI", EditI is the return value of the segment parser
01:58:40 <adarqui>        fromPathInfo "/_edit/ln"   `shouldBe` (Right $ EditS "ln")
01:58:40 <adarqui>        fromPathInfo "/_edit/9"    `shouldBe` (Right $ EditI 9)
01:59:23 <pavonia> You don't have anything that parses the ln or 9 in there
02:00:05 <adarqui> that function, fromPathSegments, returns an URLParser a
02:00:06 <pavonia> Also, don't the Show things creat an infinite loop?
02:00:08 <adarqui>   fromPathSegments :: URLParser url
02:00:38 <adarqui> no why would they? ShowI is (ShowI Int), (ShowS Text), (ShowB Bool)
02:01:13 <pavonia> Ah
02:01:21 <adarqui> btw. i can definitely say it works.. all of my tests are passing
02:01:25 <pavonia> Well, that's why you should add context ...
02:02:08 <adarqui> ok sorry it's 5 AM and i'm about to pass out.. and my original question was simply about making it pretty, not how to get it to work etc.. because i was implying it works. sorry for the confusion.
02:02:51 <pavonia> But that still doesn't work for Edit and Delete because these aren't function, so it shouldn't ever reach the second or third alternative
02:03:01 <adarqui> it works though.. tehe
02:03:57 <pavonia> No idea then, and I don't want to make guesses about what the types of these values could have
02:04:19 <adarqui> np
02:05:44 <ertes-t6v> kosmikus: if a parallel parser fails, it fails at a point when only the longest succeeding parsers are left
02:06:53 <ertes-t6v> kosmikus: for example if you were parsing haskell import lines, and you wrote "import Data,Map", you probably get an error like "expected 'qualified'"
02:07:28 <ertes-t6v> uhm, no, you don't
02:07:52 <ertes-t6v> at least if you parse character by character it might work
02:08:49 <ertes-t6v> the underlying problem is that you can't control error reporting (i.e. *where* parsers fail)
02:09:26 <kosmikus> hmm. interesting. I have to try this example.
02:09:56 <ertes-t6v> kosmikus: that one might work…  it was a bad example
02:10:54 <kosmikus> ertes-t6v: it's entirely possible that error reporting for e.g. uu-parsinglib is suboptimal in some cases. it's quite opinionated on the whole error stuff, because it's also allowing corrections.
02:11:10 <kosmikus> ertes: but I'm not convinced that this is a necessary drawback of parallel parsing.
02:12:01 <ertes> kosmikus: i think parallel parsing is semantically equivalent to full backtracking like in attoparsec
02:14:17 <ertes> kosmikus: no, i'm wrong…  if all parsers fail, in a fully backtracking parser the last parser reports the error, while in a parallel parser the longest parser reports it
02:14:19 <Jinxit> what is the right word for evaluating a thunk?
02:14:51 <ertes> Jinxit: "forcing" or just "evaluating"
02:15:05 <jarandaf> Jinxit: reduce?
02:15:17 <Jinxit> alright, does ghc evaluate thunks on separate threads?
02:15:31 <kosmikus> ertes: you can in principle keep track of all failing parsers and if there's no succeeding path, still decide late what to report
02:16:03 <kosmikus> ertes: you're not necessarily committed to reporting the longest successful path, even though in practice, this may be what all implementations do
02:16:29 <kosmikus> Jinxit: I use "forcing"
02:16:44 <kosmikus> but "evaluating" is fine. nobody will misunderstand that.
02:17:21 <kosmikus> Jinxit: not sure about your question though. do you mean OS threads, or Haskell threads. do you mean always/by default, or whether it can happen at all?
02:18:15 <Jinxit> let's say you have a <- foo; b <- bar; and both foo and bar are slow to execute
02:18:31 <Jinxit> does ghc evaluate them in parallel? (assuming both a and b are needed)
02:18:59 <Jinxit> mostly asking about default behaviour, but interested in alternatives
02:21:33 <tdammers> no
02:21:41 <tdammers> if you want IO actions to run in parallel, you have to ask for it
02:21:49 <cocreature> Jinxit: with normal do syntax it can’t do that, with applicativedo and an appropriate applicative instance it can
02:21:57 <cocreature> but it doesn’t do it automatically it depends on the instance
02:22:43 <Jinxit> what if I'm forcing them but I'm not in IO?
02:23:39 <tdammers> if you're not in IO, whether or not the actions run, and in what order, and how often, depends on the moand
02:23:43 <tdammers> s/moand/monad
02:23:44 <cocreature> Jinxit: you need to use `par` in that case
02:24:21 <Jinxit> is there any technical reason it couldn't be done by default apart from having full control?
02:25:35 <cocreature> Jinxit: I don’t think there are reasons why you couldn’t do it but there are very good reasons why you don’t want to parallelize in all cases (mostly you waste a lot of work and there is also an overhead to doing that)
02:25:40 <kosmikus> Jinxit: there's a lot of research on "automatic" parallelism
02:26:05 <Jinxit> cocreature: yeah that sounds aligned with what I was thinking
02:26:05 <kosmikus> Jinxit: but the short story is, it's extremely hard. there's always overhead in administrating threads, even lightweight Haskell ones.
02:26:15 <Jinxit> yeah
02:26:33 <kosmikus> Jinxit: so if you want to win by doing that, you have to have heuristics on how expensive a computation will be.
02:26:55 <Cale> Jinxit: Evaluating an IO action won't cause it to be executed, btw
02:26:58 <kosmikus> Jinxit: and that's a very difficult analysis in general. therefore, Haskell currently goes mostly for an annotation-based approach.
02:27:20 <ertes> kosmikus: but deciding which failure to report is essentially emulating parsec…  does that make sense?
02:27:25 <Cale> If you evaluate getLine `seq` (), the getLine will be evaluated, but you won't see anything occur.
02:27:41 <Jinxit> Cale: that wasn't really what I was asking about, but thank you regardless
02:27:55 <ertes> kosmikus: you use a lovely abstraction for parsing, but then you still need to write "basically parsec" to choose the proper error
02:28:06 <Cale> Yeah, I just saw some things in the above discussion that perhaps suggested it might be otherwise :)
02:29:13 <kosmikus> ertes: if the goal is to avoid the space leak, I think that combination can be achieved.
02:30:09 <kosmikus> ertes: not sure what you mean by "basically parsec". the use of "try" in itself has nothing to do with error messages, right?
02:33:01 <ertes> kosmikus: it has:  "import" *> spaces *> try moduleName <|> "type" *> spaces *> try typeName  -- if you write "import" followed by an invalid module name, you will get the error associated with the import branch, but with a different 'try' placement you'd get the error of the type branch
02:33:32 <ertes> kosmikus: example of the latter:  try ("import" *> spaces *> moduleName) <|> "type" *> spaces *> try typeName
02:33:54 <ertes> 'try' has a direct effect on which error the parser reports
02:44:59 <kosmikus> ertes: oh, I see what you mean now. but that's even worse (sorry). one shouldn't be forced to mix up the error reporting behaviour with the parsing order / strategy.
02:45:34 <tdammers> kosmikus: kind of impossible to avoid due to the semantics of try
02:45:35 <kosmikus> ertes: but anyway, you've given me an interesting example to think about. I'll have to look at it in a quiet minute in a bit more detail.
02:46:26 <kosmikus> tdammers: sure. the whole starting point of the discussion was that try is bad. I'm not saying that this is fixable "in parsec".
02:50:20 <tdammers> I can agree with that
03:47:51 <tsahyt> fr33domlover: I've implemented a rather specialized Graph and DynGraph instance for my problem now with batch insertion and deletion of edges, based on Vector. This has now reduced execution time by about 70% in total (not per call, still have to benchmark that). So yeah, with some work it looks like fgl can be reasonably fast.
03:49:48 <tsahyt> But I still think that I can get more performance out by making the graph implicit in the algorithm by implementing a general higher-order dfs function and not using fgl at all. I'll do some profiling and then decide.
04:07:41 * hackagebot casr-logbook 0.1.0 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.1.0 (TonyMorris)
04:17:41 * hackagebot tcp-streams 0.1.0.0 - One stop solution for tcp client and server with tls support.  https://hackage.haskell.org/package/tcp-streams-0.1.0.0 (winterland)
04:54:21 <humanoyd> What is the offset in the `Text` data type needed for? (https://hackage.haskell.org/package/text-1.2.2.1/docs/src/Data-Text-Internal.html#Text)
04:55:07 <hpc> efficient substrings, perhaps
04:56:53 <hpc> yeah, see the definition of tail here: https://hackage.haskell.org/package/text-1.2.2.1/docs/src/Data-Text.html#tail
04:57:43 * hackagebot irc-client 0.4.2.2 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.4.2.2 (barrucadu)
04:58:06 <hpc> (iter_ = UTF16-aware find-the-next-logical-character
04:58:07 <hpc> )
04:58:14 <hpc> https://hackage.haskell.org/package/text-1.2.2.1/docs/src/Data-Text-Unsafe.html#iter_
04:59:49 <hpc> there's an alternate iter_ that goes backwards too, for init
05:00:28 <hpc> which uses the length field
05:02:31 <humanoyd> hpc: Thanks! So is it just to work around the surrogate pair issues with UTF16?
05:02:55 <hpc> iter_ is
05:03:04 <hpc> the length/offset are to reduce copying
05:03:31 <hpc> you can have many substrings of some very long string, which all just index differently into the same array
05:06:00 <humanoyd> What tells ghc to only keep one array around? Or does that happen automagically?
05:06:33 <hpc> ghc does what just about any other language implementation does (though it's easy to forget it exists or why)
05:06:44 <hpc> which is that if you do something like let x = ... in f x x
05:06:51 <hpc> both of those are the same x
05:07:04 <hpc> basically, pass by reference
05:07:55 <hpc> so in the definition of tail for instance
05:08:15 <hpc> when it matches arr out of the source string and uses it to construct the result
05:08:26 <hpc> it's just using the same one for each
05:08:55 <hpc> this is the same implementation detail that makes tying the knot useful
05:09:02 <hpc> for instance, with fix
05:09:04 <hpc> @src fix
05:09:05 <lambdabot> fix f = let x = f x in x
05:09:11 <hpc> this is the knot-tied definition of fix
05:09:15 <hpc> if you do fix (1:)
05:09:27 <hpc> and then evaluate head (that thing)
05:09:33 <hpc> it's totally in normal form
05:09:43 <hpc> because the tail of that list actually points back on itself
05:10:07 <hpc> if you use fix f = f (fix f), the knot is not tied and each tail is a new thing
05:11:01 <hpc> (that fix bit is optional bonus fact, the key point is that ghc passes stuff by reference)
05:11:35 <humanoyd> hpc: Thanks! I will have to read up on tying the knot but having the offset makes a lot more sense now
05:11:55 <hpc> yeah
05:12:43 <hpc> also check out memoization, which is very similar but uses additional details of CAFs and function calls
05:13:32 <hpc> @where commentary
05:13:33 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/
05:13:38 <hpc> @where trac
05:13:38 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
05:13:46 <hpc> bleh
05:14:09 <hpc> @where+ commentary https://ghc.haskell.org/trac/ghc/wiki/Commentary
05:14:10 <lambdabot> Done.
05:14:13 <hpc> @where commentary
05:14:13 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/Commentary
05:14:19 <hpc> that one doesn't 404
05:17:01 <humanoyd> commentary about the GHC source code...talk about taking the plunge :-)
05:18:56 <heilkn> How to run a query from one database and inserting into a different one (different login data) with Database.Persist and Esqueleto?
05:19:14 <heilkn> without soting all intermediate results in memory
05:19:30 <heilkn> s./soting/storing/
05:21:41 <Myrl-saki> Can stack use nix to download the compiler?
05:23:00 <quchen> humanoyd: Maybe this gives a few new perspectives on `fix`. https://github.com/quchen/articles/blob/master/fix.md
05:26:57 <humanoyd> quchen: Thx, will definitely give it a read later
05:29:22 <tdammers> I have some TH code that runs an external command to produce data that is then spliced into my program; but when I compile with stack, it caches too aggressively, so old data ends up in the final program, and the external command isn't run
05:29:40 <tdammers> is there a way to force the relevant modules to be recompiled?
05:30:28 <merijn> tdammers: I dunno how to do it per module :\
05:30:40 <merijn> I only know -fforce-recomp (or whatever it is)
05:30:45 <merijn> But that goes for everything
05:31:08 <quchen> tdammers: cbaatz had a similar problem some time ago. Unfortunately TH does not provide an "always invalidate this module and re-TH it" primitive.
05:31:42 <quchen> But when Stack is the issue, then that would not even help.
05:38:06 <nomeata> tdammers: if you read external data file a file, use https://hackage.haskell.org/package/template-haskell-2.11.0.0/docs/Language-Haskell-TH-Syntax.html#v:addDependentFile
05:40:08 <tdammers> nomeata: I am familiar with that one, but I'm not reading any external files
05:40:22 <tdammers> it boils down to a series of git invocations
05:40:24 <nomeata> you could read /dev/random :-)
05:40:29 <tdammers> oy
05:40:39 <nomeata> (or better something that is of finite size)
05:40:48 <tdammers> well yeah... assuming that hashing is involved
05:40:58 <nomeata> Not sure if Stack pays attention to these dependencies.
05:41:03 <quchen> Hashing is involved.
05:41:23 <tdammers> hashing must be involved, because just touching the relevant modules does not cause actual recompilation
05:41:44 <tdammers> it does trigger a rebuild in --file-watch, but the modules aren't actually compiled
05:57:45 * hackagebot board-games 0.1.0.3 - Three games for inclusion in a web server  https://hackage.haskell.org/package/board-games-0.1.0.3 (HenningThielemann)
06:02:45 * hackagebot ghc-typelits-natnormalise 0.4.4 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-natnormalise-0.4.4 (ChristiaanBaaij)
06:06:14 <tomfirth> @help
06:06:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:07:45 * hackagebot board-games 0.1.0.4 - Three games for inclusion in a web server  https://hackage.haskell.org/package/board-games-0.1.0.4 (HenningThielemann)
06:07:47 * hackagebot aeson-schema 0.4.1.0 - Haskell JSON schema validator and parser generator  https://hackage.haskell.org/package/aeson-schema-0.4.1.0 (MateuszKowalczyk)
06:08:49 <xsperry> any bro wants to share pirated version of photoshop that isn't malware infested? i download 3 different versions.. all had malware
06:09:37 <hpc> @where ops
06:09:37 <lambdabot> byorgey Cale conal copumpkin dcoutts dibblego dolio edwardk geekosaur glguy jmcarthur johnw monochrom quicksilver Saizan shachaf shapr ski
06:10:00 <Myrl-saki> xsperry: okay.
06:12:11 --- mode: ChanServ set +o dibblego
06:12:23 --- mode: dibblego set +b *!*bc817ebe@*.server-home.org
06:12:29 --- kick: xsperry was kicked by dibblego (xsperry)
06:12:43 --- mode: dibblego set -o dibblego
06:19:27 <metl> does this no longer work to keep xmobar always on top in xmonad ? http://lpaste.net/170594
06:20:41 <metl> if i create an error on line 13-14 it works :\
06:22:46 * hackagebot ghc-typelits-extra 0.1.3 - Additional type-level operations on GHC.TypeLits.Nat  https://hackage.haskell.org/package/ghc-typelits-extra-0.1.3 (ChristiaanBaaij)
06:22:48 * hackagebot log 0.5.3 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.5.3 (jonathanjouty_scrive)
06:22:50 * hackagebot clash-lib 0.6.19 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.6.19 (ChristiaanBaaij)
06:22:52 * hackagebot clash-vhdl 0.6.15 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.6.15 (ChristiaanBaaij)
06:22:54 * hackagebot clash-ghc 0.6.21 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.6.21 (ChristiaanBaaij)
06:24:05 <eklavya_> I need to have DataKinds to restrict functions to some variants in a data family
06:24:16 <eklavya_> data Q = QS ShortStr ByteString
06:24:16 <eklavya_>        | QW ShortStr ByteString
06:24:31 <eklavya_> example function type (#) :: QS -> QW -> QW
06:25:04 <eklavya_> but now I get Data constructor 'QS' comes from an un-promotable type 'Q' in the type signature
06:25:13 <eklavya_> what am I doing wrong?
06:25:31 <daniel-s> Is there a shorter version of this function which takes v and returns Just v: (\_ -> (Just v))
06:25:35 <merijn> eklavya_: You're trying to lift a ByteString?
06:25:53 <merijn> daniel-s: Eh... pure & return?
06:25:58 <hpc> daniel-s: you mean \v -> Just v?
06:26:06 <hpc> @pl \v -> Just v
06:26:07 <lambdabot> Just
06:26:12 <hpc> or pure, or return
06:26:14 <merijn> oh, I see what he means
06:26:23 <merijn> "const . Just" ?
06:26:51 <hpc> oh, so \v _ -> Just v
06:26:52 <merijn> > (const . Just) 'c' 15
06:26:54 <lambdabot>  Just 'c'
06:28:30 <eklavya_> merijn: no that ShortStr is a different type
06:28:49 <eklavya_> was that what you were asking?
06:29:00 <hpc> eklavya_: it also has a ByteString field
06:29:06 <eklavya_> yeah
06:29:29 <hpc> lifting a type lifts the types of its constructor's fields
06:30:02 <hpc> so in lifting Q, you also lift ShortStr and ByteString
06:30:13 <merijn> I would be highly surprised if you could lift ByteString
06:30:13 <hpc> is what he is getting at
06:30:37 <eklavya_> so I am not saying QS and QW are types?
06:31:08 <hpc> so, when you lift Q
06:31:12 <hpc> you're saying Q is a kind
06:31:24 <hpc> the constructors keep their same nominal types
06:31:31 <eklavya_> ohhh
06:31:31 <hpc> QS :: ShortStr -> ByteString -> Q
06:31:46 <hpc> but now Q is on the same level as *
06:31:47 <eklavya_> I thought DataKinds meant the constructors can be used as types :P
06:32:07 <hpc> if you remove all the specificity, you basically have QS :: * -> * -> *
06:32:26 <hpc> so you'd still have issues with that (#) type even if you could lift ByteString
06:32:36 <hpc> which is probably what's keeping Q from being lifted in the first place
06:32:55 <eklavya_> I am not sure I am understanding all this, I am very very new :P
06:33:04 <hpc> you should look at the docs for data kinds to see if there are any exceptions to what can be lifted there
06:33:10 <eklavya_> how do I restrict some functions to only accept QS/QW ?
06:33:37 <hpc> or tell us the problem you are trying to solve, and we can suggest alternate ways
06:33:49 <hpc> since there's probably an easier way you aren't yet familiar with
06:33:52 <eklavya_> hpc: how do I restrict some functions to only accept QS/QW ?
06:34:47 <hpc> there's a bit of ambiguity in that question, but i assume what you mean is
06:34:53 <hpc> (#) takes two values of type Q
06:34:58 <eklavya_> yes
06:35:04 <eklavya_> and I only want it to take QS
06:35:07 <hpc> the first one is always the QS constructor, the second always QW
06:35:10 <eklavya_> and compile error on QW
06:35:15 <eklavya_> yeah
06:35:28 <hpc> you probably want GADTs then
06:35:33 <hpc> a very basic way to write it would be
06:35:35 <hpc> data QS
06:35:35 <eklavya_> oh no
06:35:38 <hpc> data QW
06:35:44 <hpc> data Q a where
06:35:55 <hpc>   QS :: ShortStr -> ByteString -> Q QS
06:35:57 <hpc>   ...
06:36:14 <hpc> then (#) :: Q QS -> Q QW -> Q QW
06:36:27 <eklavya_> yay!!
06:36:30 <hpc> basically what happens there is
06:36:40 <hpc> (QS foo bar) :: Q QS
06:36:45 <hpc> (QW foo bar) :: Q QW
06:37:03 <hpc> so if you pass a QW as the first parameter, it's a type error
06:37:07 <eklavya_> indirection solves everything :P
06:37:24 <tdammers> eklavya_: not directly though
06:37:48 <hpc> that changes your Q type quite a bit though
06:37:59 <hpc> and if you have a bunch of other code that uses Q you'll have to alter things
06:38:10 <alercah> Q is evil
06:38:38 <eklavya_> so GADTs are a better solution?
06:38:58 <hpc> they're a more appropriate solution to the problem you currently have, yes
06:39:24 <hpc> data kinds and GADTs are very different things, and both are powerful and interesting
06:39:24 <eklavya_> I hope they are not as difficult as I think they are :(
06:39:58 <eklavya_> let me look them up
06:39:59 <hpc> they're quite simple from the right perspective
06:40:12 <eklavya_> hpc: thanks a lot :)
06:40:30 <hpc> if you have questions about them, definitely ask here again
06:41:02 <eklavya_> well I got one from your explanation earlier
06:41:18 <eklavya_> data is not instantiating a new kind?
06:41:34 <hpc> right
06:41:44 <eklavya_> it's not!?
06:42:00 <eklavya_> what kind is data then?
06:42:01 <hpc> kinds are above types are above values
06:42:05 <hpc> so when you write something like
06:42:09 <hpc> data Bool = False | True
06:42:17 <hpc> False (value) :: Bool (type)
06:42:22 <hpc> Bool (type) :: * (kind)
06:42:26 <hpc> * always exists
06:42:39 <hpc> data kinds let you push things up a level
06:42:45 <hpc> and have False (type) :: Bool (kind)
06:43:05 <eklavya_> what does it mean for Bool now?
06:43:09 <hpc> but then there's no values of type False because that wouldn't make sense
06:43:09 <eklavya_> it was a type
06:43:41 <merijn> hpc: s/because that wouldn't make sense/because that's not allowed by the definition of Haskell/System F
06:43:49 <merijn> hpc: Not sure it never makes sense
06:43:52 <hpc> you should get more comfortable with the type system before messing with things that jump around between levels
06:43:54 <merijn> It just doesn't make sense in haskell
06:44:02 <hpc> merijn: fair enough
06:44:23 <eklavya_> kinds are types of types, right?
06:44:27 <hpc> correct
06:44:40 <eklavya_> so now False is a type of kind Bool
06:44:45 <hpc> correct
06:44:50 <hpc> and also a value of type Bool
06:45:06 <hpc> there's multiple Bools, in some sense
06:45:12 <eklavya_> before this Bool was a type of kind * ?
06:45:18 <merijn> There ARE multiple Bools
06:45:30 <merijn> Things being a type AND a kind simultaneously is nonsense
06:45:56 <hpc> in haskell, at least
06:45:57 <merijn> False and False are as much the same as "data Void = Void" has the same Void and Void
06:46:31 * hpc hopes someday haskell gets universe polymorphism
06:47:03 <eklavya_> wow, a formal education in all this would really really help :P
06:47:32 <hpc> eklavya_: you'll pick it all up eventually
06:48:08 <eklavya_> I hope :)
06:50:12 <tdammers> eklavya_: fwiw, I don't have a formal education (unless you count my degree in jazz music)
06:50:25 <eklavya_> :D
06:50:28 <eklavya_> yeah no
06:50:34 <eklavya_> I am already sold ;)
06:50:43 <hpc> tdammers wrote his thesis on saxofunctors
06:50:55 <eklavya_> I am better as a novice haskeller than I was a intermediate anything :P
06:50:56 <tdammers> saxomafunctors, please
06:51:09 <tdammers> eklavya_: common sentiment
06:51:14 <hpc> anyone know any good trombonad tutorials?
06:51:53 <eklavya_> :D
06:52:37 <a6a3uh1> @hoogle (***)
06:53:02 <hpc> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Arrow.html#v:-42--42--42-
06:53:07 <hpc> > lagcheck
06:53:08 <lambdabot>  Not in scope: ‘lagcheck’
06:53:19 <hpc> a6a3uh1: lambdabot must just not like you lol
06:53:55 <a6a3uh1> thanks a lot :)
06:54:00 <tdammers> eklavya_: relevant: http://i.imgur.com/er0tV3O.jpg
06:54:35 <hpc> a6a3uh1: if you have firefox, bookmark http://hoogle.haskell.org/?hoogle=%s and give it the keyword "hoogle"
06:54:48 <hpc> then type "hoogle (***)" in the url bar and it'll jump straight there
06:55:50 <hpc> haha, that image
06:56:35 <eklavya_> tdammers: :D
06:56:36 <a6a3uh1> does trick works for chrome?
06:56:41 <hpc> not sure
06:58:55 <demize> There's a "Search plugin" link on the top-right nav bar of Hoogle which will work in any browser that supports OpenSearch.
06:59:03 <puregreen> a6a3uh1: chrome has search shortcuts too, yep
06:59:05 <demize> It defaults to using haskell.org as the keyword though.
06:59:37 <demize> Nothing preventing you from changing it in the pop-up from clicking that link though.
06:59:42 <puregreen> also, I recommend shorter names since you'll likely be hoogling *often* (I have “hk” for Hackage and “hy” for Hayoo)
07:01:08 <puregreen> specifically, how to do it in Chrome: Settings → Search → Manage search engines...
07:01:47 <puregreen> the links are https://hackage.haskell.org/packages/search?terms=%s for Hackage and http://hayoo.fh-wedel.de/?query=%s for Hayoo
07:05:35 <eklavya_> for GADTs all constructors need to have the same arguments?
07:05:38 <eklavya_> data Q a where
07:05:39 <eklavya_>   QS :: ShortStr -> Q ShortStr
07:05:39 <eklavya_>   QW :: ShortStr -> ByteString -> Q ShortStr ByteString
07:05:43 <eklavya_> how can I make this work?
07:05:54 <mniip> what would the kind of Q otherwise be
07:05:59 <eklavya_> Qs have different signature
07:06:23 <eklavya_> mniip: data Q = QS ShortStr | QW ShortStr ByteString
07:06:37 <mniip> Q :: *
07:06:43 <mniip> your GADT has a different kind
07:06:44 <glguy> Eklavya_: usually you solve this by having two record types and one sum of the two
07:06:53 <glguy> You don't need complicated GADTs
07:06:54 <mniip> namely * -> * if you disregard the equation
07:07:00 <mrrtrump> is there a haskelly hadoop?
07:07:05 <mrrtrump> skip java use x?
07:07:13 <mrrtrump> something to replace hadoop?
07:07:43 <eklavya_> glguy: how would I write the sum?
07:07:50 <glguy> make data Q = Q Bytestring
07:08:10 <glguy> data Q = QW ByteString OtherThing
07:08:12 <hpc> mrrtrump: possibly distributed-process?
07:08:30 <eklavya_> glguy: two declarations?
07:08:37 <glguy> data QorQW = Q Q | QW QW
07:09:05 <glguy> The if you only want a Q or a QW you use those types
07:09:17 <glguy> If you support either you use the sum
07:09:44 <mrrtrump> is there a way with stm to use N nodes?
07:09:52 <mrrtrump> like create a compute cluster?
07:10:07 <glguy> No
07:11:27 <tdammers> not transparently anyway
07:11:31 <eklavya_> mrrtrump: won't the actor pattern be faster for that in a cluster than any STM?
07:11:36 <tdammers> STM can be very helpful with multithreaded code
07:12:02 <tdammers> but it won't distribute your code across physical machines
07:13:53 <mekeor> assuming every (except the absurd) type has a constructor, what would most likely be the constructor of (->)?
07:14:25 <hpc> it can't be expressed in haskell, but it'd be lambda
07:14:34 <eklavya_> glguy: so there is no way to do it with GADTs then?
07:15:40 <glguy> eklavya_: You'll get a different result with GADTs. You won't be able to do things like make a list of Q and QW things together without further wrappers and complexity
07:16:37 <glguy> It's rare to actually need a GADT
07:19:54 <eklavya_> ok
07:19:57 <spaceghost> You know that you can clint.
07:19:59 <eklavya_> understood
07:20:03 <spaceghost> It is just a matter of compile it.
07:26:26 <eklavya_> how do I make a sum type from:
07:26:29 <eklavya_> data QS = QS ShortStr
07:26:29 <eklavya_> data QW = QW ShortStr ByteString
07:27:25 <Clint> eklavya_: data QSW = QS ShortStr | QW ShortStr ByteString ?
07:27:34 <mettekou> a6a3uh1 hpc puregreen: Or if you're using DuckDuckGo: !hoogle <term> and !hayoo <term>.
07:27:56 <eklavya_> Clint: isn't that multi declaration?
07:27:59 <eklavya_> let me try that
07:28:24 <eklavya_> yup
07:28:28 <eklavya_> multi declaration
07:28:38 <eklavya_> I need all these to exist independently
07:29:15 <Clint> eklavya_: i don't understand what you are asking
07:30:15 <eklavya_> I need QS/QW AND QSW to be available as types
07:30:54 <Clint> eklavya_: so you want data QSW = QQS QS | QQW QW ?
07:32:30 <eklavya_> yeah, no way around that it seems
07:32:52 <eklavya_> first thing that's easier in Scala
07:33:27 <prooftechnique> What are you trying to do? I don't really see the difference between the first QSW and the second other than an extra layer of indirection
07:38:28 <suppi> Either QS QW?
07:38:39 <eklavya_> prooftechnique: I have two types of Q
07:39:17 <eklavya_> I need some functions to only work for Q1 and some to only work for Q2
07:39:25 <eklavya_> but since all they see is a Q
07:39:40 <eklavya_> I can't make this a compile time error to use the wrong Q
07:40:24 <bartavelle> eklavya_, what's wrong with data QS = ... ; data QW = ... ; data Q = QQS QS | QQW QW
07:41:03 <bartavelle> (what suppi suggested basically)
07:41:19 <eklavya_> it's really painful to have to write (#) (QQS (QS s)) (QQW (QW s2 b)) = ...
07:42:06 <bartavelle> I *think* what you would like is row-types, but haskell doesn't have it
07:42:13 <bartavelle> row polymorphism
07:43:21 <merijn> Naah
07:43:39 <merijn> You can do it with GADTs and DataKinds, but it's way to painful to bother with
07:44:40 <eklavya_> I tried GADTs but that won't work out apparently 
07:45:08 <merijn> It will, you just need about 20 times more boilerplate than you have right now :)
07:45:16 <eklavya_> hehehehe
07:45:44 <cloudhead> and why not have two types?
07:45:45 <bartavelle> eklavya_, or you can just church-encode it
07:46:02 <bartavelle> depending on your use case it might even result in an easier to read program
07:46:38 <bartavelle> you can keep the sum-type and write a combinator "(s -> a) -> (s2 -> b -> a) -> Q -> a"
07:46:49 <eklavya_> cloudhead: then I would need to write two functions for many same things, no?
07:47:02 <cloudhead> so you also need functions to work for both?
07:47:10 <eklavya_> cloudhead: yes
07:47:17 <cloudhead> i c.
07:47:36 <eklavya_> bartavelle: I would need much more elaborated version of that :P
07:47:44 <bartavelle> hum
07:47:52 <prooftechnique> Just throw Proxy at it until it works :D
07:47:52 <cloudhead> it seems like you'd have to just send the part "inside" Q1 and Q2 to the functions that take only one
07:47:55 <bartavelle> can you paste a bit of your current code ?
07:47:57 <cloudhead> instead of Q1 itself
07:48:41 <cloudhead> or you have to do `data Q = Q1 QX | Q2 QY`
07:48:59 <eklavya_> cloudhead: that would work if I didn't have different numbr of arguments in both
07:49:17 <eklavya_> bartavelle: let me do that
07:50:00 <eklavya_> http://lpaste.net/170601
07:51:19 <bartavelle> eklavya_, the (#) and (<>) functions should only work for the specified cases or for all 4 of them and you didn't feel like typing it all ?
07:51:40 <eklavya_> oh shit
07:51:42 <eklavya_> I didn't update
07:51:45 <bartavelle> (also you should derive Monoid instead of hiding ++ and <>)
07:51:49 <cloudhead> eklavya_: why not have the functions take QS/QW
07:51:51 <eklavya_> that was the whole point of this exercise :P
07:51:54 <cloudhead> heh
07:54:29 <eklavya_> not so bad anymore !
07:54:29 <eklavya_> http://lpaste.net/170602
07:54:55 <eklavya_> bartavelle: I was trying so many things, I will clean up after
07:55:22 <bartavelle> so, where do you want to go from the current paste ?
07:55:42 <cloudhead> yeah, that works, but I'd probably go as far as removing QS/QW and passing ShortStr/ByteString directly
07:55:42 <tomjaguarpaw> Does anyone know an efficient way of zeroing all but the bottom n bits of an Integer?
07:55:47 <eklavya_> I want to make a small hacky DSL for a CQL query
07:55:51 <bartavelle> (also why don't you derive Monoid ?)
07:56:00 <eklavya_> bartavelle: I was trying so many things, I will clean up after
07:56:04 <bartavelle> kk
07:56:17 * bartavelle looks CQL up
07:56:27 <eklavya_> bartavelle: oh boy, had I shown you the whole file
07:56:29 <eklavya_> :D
07:56:48 <bartavelle> ok, CQL is too large to look up in 5s
07:56:51 <eklavya_> I am trying to write a cassandra driver, I am half way there
07:56:54 <cloudhead> tomjaguarpaw: fold + bitshift 1?
07:57:05 <cloudhead> or something..
07:57:24 <bartavelle> eklavya_, so, what function would you like to write that is annoying ? a "generalized" (<>) for all QS/QW combinations ?
07:57:49 <eklavya_> I am trying to mimic what I saw being used as a DSL for a db
07:57:59 <tomjaguarpaw> cloudhead: Doesn't sound very efficient.
07:58:01 <eklavya_> table # something # update # something etc
07:58:59 <eklavya_> "select * from table" will have a different frame than a "select * from table where a = 1" is a different frame
07:59:17 <bartavelle> oh boy, what you wanna do is complicated :)
08:00:11 <eklavya_> maybe, doesn't feel like it so far. Maybe the dead end is farther than I can see :D
08:00:19 <bartavelle> heh
08:00:20 <eklavya_> no harm in trying, I am learning haskell :P
08:00:29 <bartavelle> ok, so what is QS / QW supposed to mean ?
08:00:37 <eklavya_> a select only part
08:00:47 <eklavya_> and a part which will have a where clause
08:00:55 <eklavya_> to make life easier
08:01:00 <bartavelle> oh so it's not a type safe DSL ?
08:01:18 <cloudhead> tomjaguarpaw: I mean you could predefine your "masks" and use the right one based on 'n'
08:01:34 <eklavya_> no, that would defninitely be out of my league right now
08:01:54 <eklavya_> bartavelle: I want to get an MVP then imporve
08:02:04 <eklavya_> right now as much I can do I am trying
08:02:30 <eklavya_> but it was a good choice for a first program
08:02:42 <tomjaguarpaw> cloudhead: Yes, that could be not unreasonable.
08:02:49 <cloudhead> mask 1 x = x .&. m1; mask 2 x = x .&. m2
08:02:51 <cloudhead> etc
08:03:01 <eklavya_> I learned monads/common libs/networking/concurrency primitives in haskell
08:03:21 <bartavelle> eklavya_, argh be right back at you in a few minutes
08:03:31 <eklavya_> sure :)
08:03:46 <merijn> j ##c++
08:05:51 <bartavelle> eklavya_, first of all I would have gone with something like "data Q = Q [Text] [Text]" and used T.unword in the end to concatenate everything
08:06:08 <bartavelle> (and skip the where clause if the second list is empty)
08:06:26 <eklavya_> won't ByteString be a better type for binary data?
08:06:30 <cloudhead> tomjaguarpaw: I was thinking at first you could do something clever with 'rotate', but probably not
08:06:47 <bartavelle> eklavya_, isn't that a textual query ?
08:07:05 <eklavya_> no I have to send a bunch of binary data to the node
08:07:23 <bartavelle> eklavya_, oh well, then ByteString is the preferred type
08:07:44 <cpennington> Is there an accepted way to generate bindings in haskell based on API specs? I'm working on something that is going to be generating bindings from swagger (a REST API specification format)
08:08:39 <cpennington> currently, I'm using Template Haskell, so that the bindings can be type-checked at compile time. But I was wondering if there was a way I could get the same type safety but move the work to runtime (to allow things like hot reloading)
08:08:49 <fizruk> cpennington: do you know there's already a swagger codegen for haskell's servant?
08:08:58 <tomjaguarpaw> cloudhead: I'm surprised it isn't a standard bit-twiddling operation
08:09:17 <cpennington> the swagger format has type specifications for all of the REST endpoints, so I'd love to type-check against those.
08:09:33 <cloudhead> tomjaguarpaw: it is, it's just that your 'n' change the amount of operations to do
08:09:42 <cloudhead> tomjaguarpaw: which is why I suggested the fold
08:10:00 <cpennington> firzuk: Yes, I'd seen those. I'm actually working on building client bindings, rather than server bindings (in particular, GraphQL -> Haxl -> Swagger)
08:10:26 <cpennington> so, I'm using the Swagger docs to generate the Haxl and GraphQL typeclass instances and such
08:10:54 <cloudhead> tomjaguarpaw: wait actually it should be possible to compute the value to .&. with easily based on n
08:11:01 <cloudhead> with ^2
08:11:03 <cpennington> but I wasn't sure if maybe I should just be building a generic Haxl/GraphQL class, and then essentially load data into it from the parsed swagger documents at runtime
08:11:24 <cloudhead> tomjaguarpaw: I mean x^2
08:12:10 <tomjaguarpaw> cloudhead: Not sure what you mean
08:12:13 <Boomerang> > let mask n x = x .&. (n^2 - 1)
08:12:14 <lambdabot>  <no location info>:
08:12:14 <lambdabot>      not an expression: ‘let mask n x = x .&. (n^2 - 1)’
08:12:19 <tomjaguarpaw> 2^n - 1, surely?
08:12:20 <cpennington> this is all happening over here, for anyone that's interested: https://github.com/edx/datagraph/tree/swagger-hackathon
08:12:38 <Boomerang> yes 2^n
08:12:52 <cloudhead> sorry yes
08:14:04 <tomjaguarpaw> Yes, that works, but calculating 2^n is not especially fast either.
08:14:11 <tomjaguarpaw> A lookup table could work though.
08:14:26 <fizruk> cpennington: so is catalog.swagger.json something that you are given, or something you are editing?
08:14:36 <cloudhead> shifting is faster for sure
08:14:53 <cloudhead> yeah hence the `mask n x`
08:15:30 <cloudhead> because if your table is a Data.Map, that's not exactly faster :)
08:15:42 <cloudhead> maybe Data.IntMap, but I can't say
08:16:54 <cloudhead> hm no it uses trees
08:17:30 <tomjaguarpaw> Folding a shift is faster than (2 ^ n) - 1?
08:17:38 <tomjaguarpaw> I'll have to try it.
08:17:53 <cloudhead> I'm not sure
08:17:53 <cloudhead> it could be optimized away by ghc
08:18:14 <fizruk> cpennington: btw, swagger codegen for servant should generate a type-level API, not just the server
08:18:29 <cloudhead> in which case it might be faster, but also 2^n could be optimized into shifts by ghc
08:18:29 <tomjaguarpaw> The problem is that I am parametrised on a typelevel Nat, otherwise everything could be specialised.
08:18:45 <cloudhead> (or llvm rather)
08:19:00 <Boomerang> > let mask n x = x .&. (bit n - 1) in mask 3 57
08:19:01 <lambdabot>  1
08:19:03 <fizruk> cpennington: you could use that to generate client with server-client
08:19:05 <cpennington> fizruk: The idea would be to have swagger files be generated (or perhaps hand-coded) by other services, and then run build a datagraph instance to provide a GraphQL api on top of those disparate REST apis
08:19:06 <cloudhead> ah I see
08:19:36 <fizruk> cpennington: err, servant-client 
08:21:16 <cloudhead> `bit` just uses a shift
08:21:24 <cloudhead> actually yeah you only need one shift
08:21:26 <cloudhead> and then -1
08:21:33 <cpennington> fizruk: oh, interesting.
08:21:41 <Boomerang> nevermind, "bit" is implemented in terms of shiftL for int...
08:21:51 <Boomerang> (as you said)
08:21:54 <cloudhead> yeah
08:21:56 <cloudhead> but that should still be the fastest
08:22:08 <cloudhead> since it's only 1 shift with the -1 trick
08:22:21 <cloudhead> no need to fold
08:22:57 <tomjaguarpaw> cloudhead: I don't get it?
08:22:59 <tomjaguarpaw> Shift what?
08:23:11 <cloudhead> I think you would do (bit (n+1) - 1)
08:23:13 <tomjaguarpaw> Oh, shift and pad from the right?
08:23:28 <cloudhead> you shift n+1 times
08:23:42 <tomjaguarpaw> So that's a fold, right?
08:23:47 <cloudhead> then subtract 1 to get all the lower bits set to 1
08:23:49 <cloudhead> no, no need to fold
08:23:51 <tomjaguarpaw> Oh I see
08:23:51 <fizruk> cpennington: I don't know GraphQL, but you could probably reuse servant's type-leve API and just add GraphQL interpretation(s)
08:23:59 <tomjaguarpaw> Right, that makes a lot of sense.
08:24:12 <cloudhead> yeah, I think that's your best bet
08:24:15 <tomjaguarpaw> Don't know why I ever thought of 2^n!
08:24:37 <cloudhead> you mean 2<<n
08:24:46 <cloudhead> um, 1<<n
08:25:17 <cpennington> fizruk: on the other hand, the swagger codegen for the servent API is java... so, a bit clumsy to work with, from a pure haskell perspective. But I'll have to look into how servent-client works to see if it gives a cleaner way of generating the Haxl/GraphQL bindings, if I generate the appropriate types using TH
08:25:18 <pflanze> I'm looking for a function with signature Int -> [a] -> [[a]] that groups the given list into a list of sublists of length n each. E.g. chop 2 [1,2,3,4,5,6] -> [[1,2],[3,4],[5,6]]
08:25:33 <pflanze> Can't find it on Hoogle, how comes, another suggestion?
08:26:27 <cloudhead> I gotta go but I think it's something like: complement ((1 `shiftL` (n+1)) - 1)   .&.  x
08:26:34 <cloudhead> maybe it can be simplified
08:26:41 <tomjaguarpaw> Thanks for your help.
08:26:55 <hpc> pflanze: https://hackage.haskell.org/package/split-0.2.3.1/docs/Data-List-Split.html#v:chunksOf
08:28:21 <cloudhead> so it goes:  001000 -> 000111 -> 111000, for the left side of .&.
08:28:25 <cloudhead> np
08:28:58 <cpennington> fizruk: https://hackage.haskell.org/package/servant-haxl-client-0.2.0.0/docs/Servant-Haxl-Client.html looks like it might handle part of this for me.
08:29:05 <cloudhead> actually starts with 000001 ie: 1
08:29:05 <cpennington> fizruk: thanks for the pointers!
08:29:44 <pflanze> hpc, thanks. How comes this is not on Hoogle? It only has chunksOf from Data.Text and Data.Text.Lazy
08:30:03 <fizruk> cpennington: note that there's #servant channel if you have more servant-related questions
08:30:41 <cpennington> col
08:35:57 <anemecek> you guys should post photos of your bookshelves https://www.reddit.com/r/techbookshelves
08:36:59 <hpc> pflanze: scroll down, the one from the split package is right below the ones from text
08:37:28 <hpc> (if you are searching for "chunks")
08:42:00 <synergistics> Is there a name for a Monoid that has both an addition and subtraction operation?
08:42:24 <merijn> synergistics: Semigroupoid? (not sure?)
08:42:34 <merijn> Group if you have an inverse operation for both
08:42:50 * hackagebot bifunctors 5.4.1 - Bifunctors  https://hackage.haskell.org/package/bifunctors-5.4.1 (ryanglscott)
08:43:15 <synergistics> What if they are each others inverse?
08:43:34 <cocreature> then it’s a group
08:43:56 <merijn> synergistics: Hold on, the inverse refers to an element of the type, NOT an operation on it :)
08:44:31 <merijn> synergistics: So in groups terms - and + are not inverses on the natural numbers (in fact, addition has no inverse for natural numbers)
08:44:36 <pflanze> hpc, not for me. Perhaps NoScript's fault? I've enabled all scripts on this page, but who knows.
08:45:12 <synergistics> merijn: So what is it that has the inverse? The whole group?
08:45:19 <merijn> Addition on integers has an inverse, "a + b = c" "c + -b = a" -b is the inverse of b
08:45:37 <synergistics> Oh if each element has an inverse
08:46:02 <merijn> synergistics: An inverse means that for every operation a * b = c each element has a inverse such that c * inv(b) = a and c * inv(a) = b
08:46:22 <synergistics> Ohh I see
08:47:31 <synergistics> So then lists for example don't have an inverse as a monoid?
08:47:50 * hackagebot yaml 0.8.18.1 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.18.1 (MichaelSnoyman)
08:47:52 * hackagebot camfort 0.802 - CamFort - Cambridge Fortran infrastructure  https://hackage.haskell.org/package/camfort-0.802 (DominicOrchard)
08:47:54 * hackagebot aeson-schema 0.4.1.1 - Haskell JSON schema validator and parser generator  https://hackage.haskell.org/package/aeson-schema-0.4.1.1 (MateuszKowalczyk)
08:48:01 <mniip> synergistics, if your subtraction satisfies some properties then it can be turned into inversion
08:48:58 <monochrom> combine subtraction and zero to define inverse(b) as 0-b
08:49:05 <mniip> yes
08:49:24 <monochrom> clearly, this method fails if you don't have 0.
08:49:43 <monochrom> but fortunately monoid has it.
08:50:41 <mniip> the properties needed, I think, are: a-a = 0, a-b-c = a-(b+c), a-b+c = a-(b-c), (a+b)-c = a+(b-c)
08:50:56 <synergistics> mniip: So then instead of lists, could the members of the group be actions that act on zero ([])? Like the operation of the group (not sure if that's correct syntax) would be just application and the members would be things like (++ [1,2,3]) and (\\ [4,5,6])
08:51:16 <alercah> monochrom: you have to have a 0
08:51:17 <alercah> a - a
08:51:38 <synergistics> Wait, zero would actually be (++ []) and (\\ [])
08:51:39 <monochrom> I forgot that
08:51:53 <mniip> synergistics, both are id so that's ok
08:52:00 <alercah> mniip: I'm pretty sure that's equivalent to a group
08:52:11 <mniip> alercah, that's what I just said
08:52:17 <mniip> synergistics, does a-b+c=a-(b+c) hold in your model?
08:52:28 <synergistics> Hmm
08:52:28 <mniip> er
08:52:33 <mniip> a-b+c = a-(b-c)
08:53:15 <mniip> ah right, subtraction is a secondary operation so we can just use the group axioms
08:53:25 <mniip> synergistics, does associativity hold in presence of negative lists?
08:53:50 <synergistics> Well I can't end up with an action smaller than (++ [])
08:53:58 <synergistics> So I don't think so
08:54:10 <mniip> hmm
08:54:27 <monochrom> look for "free group" and "the word problem" for inspiration on list-like groups.
08:54:46 <synergistics> No, I can't end up with an action that produces something smaller than [] when applied to []
08:54:59 <mniip> synergistics, a+-a = 0
08:55:03 <mniip> if a is negative,
08:55:16 <mniip> (++ xs) . (// xs) =/= id
08:55:34 <synergistics> ((\\ [1]) . (++ [1])) [] = []
08:55:51 <mniip> that's positive a
08:56:22 <synergistics> Other way around?
08:56:35 <mniip> yes
08:57:45 <mniip> on a related note
08:58:03 <mniip> would dependent typing allow us to include proofs of law correctness in typeclasses?
08:59:23 <synergistics> Because with type correctness alone when making instances of a typeclass, laws aren't automatically satisfied, right?
08:59:54 <mniip> well, parametricity gives us some laws
09:00:04 <mniip> but not all the required ones
09:00:08 <synergistics> But type correctness doesn't imply that laws are satisfied
09:00:10 <synergistics> Oh ok
09:00:57 <synergistics> How does parametricity yield laws?
09:01:15 <mniip> iirc, fmap f . fmap g = fmap (f . g) follows from parametricity
09:01:37 <mniip> err no it does ntot
09:01:50 <merijn> It does if you have "fmap id = id"
09:01:52 <mniip> possibly it follows from fmap id = id
09:01:53 <mniip> yes
09:02:14 <merijn> "fmap id = id" + parametricity is enough to prove "fmap f . fmap g = fmap (f . g)"
09:03:33 <mniip> so uh,
09:04:36 <mniip> fmapIdLaw :: Functor f => (x :: f a) -> Dict ((fmap id x == x) ~ True)
09:04:41 <mniip> or something like that
09:05:26 <synergistics> whoa
09:05:41 <synergistics> I've never seen a type signature like that
09:05:49 <mniip> because it's not a thing yet
09:05:54 <mniip> (if ever?)
09:06:13 <synergistics> Oh, hehe
09:06:44 <synergistics> is Dict for dictates or something like that?
09:07:10 <synergistics> and is True a type here because of the ~ 
09:07:14 <mniip> :t Data.Constraint.Dict
09:07:15 <lambdabot>     Not in scope: data constructor ‘Data.Constraint.Dict’
09:07:17 <mniip> aww
09:07:24 <mniip> synergistics, see https://hackage.haskell.org/package/constraints-0.8/docs/Data-Constraint.html
09:11:51 <synergistics> So in your example, if the id law is true for x, then it ensures that x is an instance of what?
09:12:16 <synergistics> Or, what's the constraint in the Dict
09:12:51 * hackagebot dtw 1.0.2.0 - (Fast) Dynamic Time Warping  https://hackage.haskell.org/package/dtw-1.0.2.0 (fho)
09:14:07 <mniip> synergistics, it ensures that (fmap id x == x) and True are instances of ~
09:14:42 <Welkin> instances of ~?
09:14:43 <Welkin> what?
09:15:00 <Welkin> isn't ~ a type operator that means "isomorphic to"?
09:15:05 <mniip> well we can pretend it's a fundep'd typeclass
09:15:11 <mniip> no, not isomorphic
09:15:18 <mniip> structurally equal
09:15:59 <synergistics> What would it mean to be an instance of ~ then
09:16:37 <merijn> Not structurally equal
09:16:41 <merijn> "unifyable with"
09:16:59 <simg> Hi, I have a number of pure functions that each return a list. I'd like to run the functions in turn until one of them returns exactly 1 value. Any pointers for a concise way to do this?
09:17:00 <mniip> I wouldn't say so
09:17:28 <mniip> f X ~ F x, tells us some things about f and x
09:17:31 <Welkin> simg: guard? or just use recursion
09:17:42 <glguy> ~ isn't structural equality, it's nominal equality
09:17:51 * hackagebot heckle 2.0.0.0 - Jekyll in Haskell  https://hackage.haskell.org/package/heckle-2.0.0.0 (2016rshah)
09:17:56 <glguy> Coerce constraints are closer to representational equality
09:18:18 <Welkin> no idea what the differen is for those glguy 
09:18:22 <Welkin> difference*
09:18:32 <mniip> no I mean structural equality of the types
09:18:33 <Zemyla> fmap id x == x isn't really quite true, because if x = 1:x, then fmap id x doesn't use sharing like x did.
09:18:52 <mniip> Zemyla, referential transparency makes that unobservable
09:18:52 <hpc> knot-tying isn't part of denotational semantics
09:19:00 <merijn> Zemyla: You're talking about operational details
09:19:12 <simg> Welkin: it's not recursive. I just want to run each function once. I could code it long hand but it seems like there should be an easy way. I don't *think* it's guards either
09:19:21 <Zemyla> True.
09:20:03 <Welkin> simg: no, I meant you can write a "fold" explicitly using recursion
09:20:09 <Welkin> and just stop when you get the value 1
09:20:23 <Welkin> fold over your list of functions
09:20:29 <glguy> Welkin: nominal equality is name-based, representational equality allows for things like: newtype MyInt = MyInt Int   and   Int to be "equal"
09:20:48 <simg> Welkin: that sounds promising. I'll investigate, thanks !
09:20:49 <Welkin> okat
09:20:59 <Welkin> okay
09:22:37 <mniip> merijn, any comment?
09:22:54 <merijn> mniip: On what?
09:22:55 <Iceland_jack> It can observe and manipulate sharing explicitly, in a stream like
09:22:56 <Iceland_jack>     data PStream a v = Var v | Mu (v -> PStream a v) | Cons a (PStream a v)
09:22:56 <Iceland_jack> for any v"
09:23:02 <Iceland_jack> *every
09:23:26 <mniip> merijn, I would say ~ is "unifyable with", because f X ~ F x actually instantiates f and x
09:23:31 <mniip> woudln't*
09:24:09 <merijn> mniip: Are we talking in the presence of type families or no?
09:24:41 <mniip> hmm, what's the significant change that they introduce?
09:25:16 <merijn> mniip: "F x" can be something arbitrary if F is a type family
09:25:23 <mniip> well I meant a datum
09:25:38 <merijn> If 'F' is not a type family then ~ means 'f' MUST unify with 'F'
09:26:33 <mniip> so what's the problem with saying that f is the same type as F
09:26:42 <merijn> mniip: Your initial remark was that both sides were structurall equal, but that's not true since, "Maybe a ~ Maybe Int" holds whenever 'a' unifies with Int
09:27:05 <merijn> mniip: Because for complex types there can be many free variables on both sides of ~
09:27:42 <merijn> "Either a b ~ Either c d" relies on unifying a with c and b with d, each of which could contain other free variables, etc.
09:27:53 <merijn> So straight structural equality is not a good description
09:28:02 <mniip> I still don't see the problem
09:28:38 <mniip> if 'Maybe a' and 'Maybe Int' are the same type then it naturally follows that 'a' and 'Int' are the same type
09:28:53 <mniip> ah
09:28:58 <mniip> I think I see what you mean
09:29:22 <mniip> well yes, structurally equal is a poor choice of words in presence of foralls, because that's what can be not equal
09:47:01 <jle`> Colour21\253,246,227\
09:47:08 <jle`> ah, sorry
09:52:53 * hackagebot fraction 0.1.0.5 - Fractions  https://hackage.haskell.org/package/fraction-0.1.0.5 (WolfgangJeltsch)
09:57:53 * hackagebot fraction 0.1.0.6 - Fractions  https://hackage.haskell.org/package/fraction-0.1.0.6 (WolfgangJeltsch)
09:58:56 <mettekou> Are there any Haskell libraries useful to manipulating data types representing abstract syntax trees/grammars?
10:00:05 <mettekou> uniplate and multiplate are not useful for types of which the constructors take arguments of different types.
10:02:53 * hackagebot heckle 2.0.0.1 - Jekyll in Haskell  https://hackage.haskell.org/package/heckle-2.0.0.1 (2016rshah)
10:07:54 * hackagebot lifted-base 0.2.3.7 - lifted IO operations from the base library  https://hackage.haskell.org/package/lifted-base-0.2.3.7 (BasVanDijk)
10:12:54 * hackagebot pixelated-avatar-generator 0.1.2 - A library and application for generating pixelated avatars.  https://hackage.haskell.org/package/pixelated-avatar-generator-0.1.2 (ExcaliburZero)
10:17:54 * hackagebot cndict 0.8.1 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.8.1 (DavidHimmelstrup)
10:34:48 <pikajude> race-condition-wise, is there any difference between atomically . readTChan and readChan
10:36:24 <ertes> mettekou: the base library is quite useful on its own for some basic operations like mapping and substitution, and there is 'bound' to deal with binders
10:37:09 <ertes> mettekou: if you want to learn more, search for "i'm not a number, i'm a free variable"
10:37:24 <mettekou> ertes: Yeah, I'm using bound, which is why uniplate and multiplate cannot help me due to Scope.
10:37:37 <mettekou> And I'm familiar with all the possible representations of terms and binders.
10:37:45 <mettekou> Or variables and binders, rather.
10:38:07 <mettekou> But what I'm doing is arguably more advanced: generating recursion schemes for inductive types etc.
10:55:36 <joe9> which is better from a performance perspective: reverse . takewhile (f :: a -> Bool) . reverse == dropWhile ? I am only taking a 100 elements or so from the last of a list
10:56:15 <joe9> dropWhile might have to go through all the elements. whereas, if reverse is optimized, it might jump to the last and start from there?
10:56:59 <kadoban> joe9: Reverse is always \Theta(n) in the size of the list. The only way the reverse way would be faster is if your predicate is *very* slow, I think.
10:57:12 <kadoban> Woops, I don't have my autoreplace text things on this client ... oh well.
10:58:18 <kadoban> Well, dropWhile is going to have to look at the whole list too, so I dunno.
11:00:39 <jle`> joe9: i don't think those two are the same thing
11:04:26 <quchen> You cannot optimize reverse away that easily.
11:05:03 <quchen> Lists cannot necessarily be reversed (think `repeat ()`), so reverse.reverse=id is false.
11:06:00 <quchen> Also, `reverse . takeWhile f . reverse` is not `dropWhile f`, it takes elements from the end of a list.
11:06:28 <quchen> joe9: ^
11:08:32 <joe9> kadoban: jle`, quchen, ok. THanks.
11:17:32 <mrrtrump> anyone using happstack?
11:18:10 <Iceland_jack> :t \pred -> droppingWhile pred (backwards traverse)
11:18:11 <lambdabot> (Applicative f, Traversable t) => (b -> Bool) -> Optical (->) (->) f (t b) (t b) b b
11:25:38 <nitrix> Iceland_jack: You're now a wizard :)
11:26:05 <verrlara> nitrix: You are a wizard in my mind :P
11:28:15 <mniip> :t droppingWhile
11:28:16 <lambdabot> (Applicative f, Profunctor q, Conjoined p) => (a -> Bool) -> Optical p q (Data.Functor.Compose.Compose (State Bool) f) s t a a -> Optical p q f s t a a
11:28:28 <mniip> dear...
11:28:44 <shapr> @src dropWhile
11:28:44 <lambdabot> dropWhile _ []                 = []
11:28:44 <lambdabot> dropWhile p (x:xs) | p x       = dropWhile p xs
11:28:44 <lambdabot>                    | otherwise = x:xs
11:28:48 <shapr> @src droppingWhile
11:28:49 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
11:30:16 <mniip> so it's primarily a prism transformation
11:31:19 <mrrtrump> I prefer the term magic user
11:31:43 <mrrtrump> any happstack users in here?
11:32:21 <mrrtrump> people still use twit and facebook?
11:32:26 <mrrtrump> nerds!
11:32:31 <mst> mrrtrump: HELLO GAVINO
11:34:12 <mst> mauke: ^^ more fodder for the detection system :D
11:35:25 <Iceland_jack> I'm am a lousy magician
11:36:07 <hpc> Iceland_jack: you're are a lousy grammerer too ;)
11:37:18 <Iceland_jack> I'm am a lousy most things!
11:40:00 <hpc> hmm, ghc feature request: type records
11:40:00 <APic> Good.
11:40:24 <APic> So we can finally pass the Touring Test?
11:40:44 <hpc> specifically for lens, but it'd be nice to have elsewhere
11:40:46 <fishythefish> Is "Touring Test" the Traveling Salesman Problem?
11:40:53 <APic> fishythefish: Good Question.
11:41:12 <hpc> class Monad m => MonadState {monad = m, state = s} | m -> s where ...
11:41:26 <ertes> lol
11:41:29 <Iceland_jack> O_O
11:41:41 <hpc> and for lens, the benefit would be knowing what the letters of Optical p q f s t a b are all supposed to mean
11:42:04 <hpc> (that's 7 type variables!)
11:43:00 <hpc> i haven't thought through anything at all about the implications it would have on other details of the language
11:43:00 <geekosaur> lens is getting stabby again (ob i m a s t a b u)
11:43:03 <hpc> i just want it
11:43:24 <ertes> Iceland_jack: don't worry, even the worst of entertainers can always look down on lambdabot's terrible jokes
11:43:27 <mniip> @let type family Force x where Force x = x
11:43:28 <lambdabot>  Defined.
11:43:35 <ertes> @src bewSheet
11:43:35 <lambdabot> Source not found. Are you typing with your feet?
11:43:43 <mniip> :t (undefined :: a -> Force a) (undefined :: Optical p q f s t a b)
11:43:44 <lambdabot> forall (k :: BOX) (k1 :: BOX) (k2 :: BOX) (k3 :: BOX) (p :: k -> k3 -> *) (q :: k2 -> k3 -> *) (f :: k1 -> k3) (s :: k2) (t :: k1) (a :: k) (b :: k1). p a (f b) -> q s (f t)
11:43:57 <mniip> simple enough
11:45:50 <lpaste> stevejb pasted “replacing case with when” at http://lpaste.net/170663
11:46:13 <stevejb> Have a quick syntax question described in the lpaste above
11:46:19 <stevejb> not sure how to replace this syntax
11:46:20 <glguy> stevejb: You can use for_ for that
11:46:33 <glguy> for_ a_maybe_value $ \something -> ...
11:46:49 <Iceland_jack> If you want "return ()" for the Nothing branch
11:47:18 <ertes> :t for_
11:47:20 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
11:47:22 <stevejb> Iceland_jack: the return () gives me type errors
11:47:36 <stevejb> glguy: I will give for_ a try
11:47:50 <Iceland_jack> stevejb: scratch that
11:47:57 * hackagebot git-annex 6.20160619 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-6.20160619 (JoeyHess)
11:48:18 <Iceland_jack>     for_ :: Maybe a -> (a -> IO b) -> IO ()
11:48:18 <Iceland_jack>     for_ Nothing  _ = return ()
11:48:18 <Iceland_jack>     for_ (Just x) f = do
11:48:18 <Iceland_jack>       f x
11:48:21 <Iceland_jack>       return ()
11:51:33 <lpaste> stevejb revised “replacing case with when”: “replacing case with when” at http://lpaste.net/170663
11:51:51 <stevejb> Iceland_jack: I don't think I am completely getting the syntax
11:52:21 <dmwit> stevejb: You will have to use `let`, or introduce a spurious `case` to attach the `where` to.
11:52:30 <Welkin> steve jbs
11:52:47 <dmwit> stevejb: for_ val $ \something -> let a = f something; b = g something in lift (run something a b)
11:52:58 <stevejb> dmwit: thanks
11:53:03 <Welkin> :t for_
11:53:04 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
11:53:17 <Welkin> :t forM
11:53:18 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
11:53:29 <Welkin> :t forM_
11:53:30 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
11:53:32 <Welkin> hm
11:53:36 <dmwit> :t for
11:53:37 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
11:53:46 <Iceland_jack> stevejb: You can use 'let' with 'do'
11:53:47 <Iceland_jack>     for_ a_maybe_value $ \something -> do
11:53:47 <Iceland_jack>       let a = f something
11:53:47 <Clint> stevejb: if you're getting a type error from return () you should get one from when as well
11:53:47 <Iceland_jack>           b = f something
11:53:50 <Iceland_jack>     lift (run something a b)
11:53:50 <Welkin> why for_ and not forM_?
11:53:56 <Iceland_jack> (indent 'lift ...' by 2 more spaces)
11:54:05 <dmwit> Welkin: It's just slightly more general. (Applicative vs Monad)
11:54:07 <Iceland_jack> Welkin: same thing
11:54:11 <Iceland_jack> "same"
11:54:18 <dolio> Why ever use forM_? It's just a worse name.
11:54:22 <Welkin> lol
11:54:26 <Welkin> I don't use it
11:54:30 <Welkin> I usually use mapM
11:55:13 <dmwit> :t mapM
11:55:14 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:55:15 <dmwit> :t traverse
11:55:16 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:55:20 <Iceland_jack> :t [mapM_, traverse_]
11:55:21 <lambdabot> (Monad m, Foldable t) => [(a -> m b) -> t a -> m ()]
11:56:54 <Welkin> next time I might use traverse instead then
11:58:22 <dmwit> I think the reasons for choosing one or the other are quite light. Despite the rhetoric I've been spitting in the past few lines, I doubt anybody would squint at your code if you picked the "wrong" one.
11:59:22 <Welkin> I just use mapM (or very rarely, forM) because it is what I was already familiar with using
11:59:39 <Welkin> but traverse is a better name indeed
11:59:53 <Welkin> I just tend to forget about it
12:00:33 <Clint> i tend to worry about pre-BBP incompatibility
12:01:47 <Welkin> Clint just has a fistful of monads
12:04:28 <APic> Clint who?
12:04:30 <APic> Ah. Clint.
12:08:32 <johnw> does anyone have an idea of why, when this code (https://gist.github.com/d06f8167e74fd4284c88705c614cc57c) is applied to a UTF-8 encoded XML file, it prints escape codes in the output instead of the correct Unicode entities?  Is it xml-conduit failing to properly decode the file?
12:09:35 <johnw> the file is UTF-8, and begins with <?xml version="1.0" encoding="UTF-8" ?>
12:12:13 <johnw> it happens on this sample input: https://gist.github.com/jwiegley/353ee6b0c59cad91c2cb34e12afb9117
12:14:58 <jmct> barrucadu: Just replied to your email, I know you know about the GHC proposal stuff, I just wanted to include it for those who aren't following that
12:16:05 <barrucadu> jmct: Awesome, thanks
12:16:14 <mauke> johnw: 'print'?
12:16:19 <mauke> @src print
12:16:20 <lambdabot> print x = putStrLn (show x)
12:16:33 <mauke> show produces haskell source syntax, including escape sequences
12:16:53 <johnw> am I really being that big a fool?  :(
12:18:22 <shapr> johnw: everybody makes mistakes?
12:18:25 <shapr> I make many every day.
12:18:44 <johnw> sigh
12:18:44 <APic> Who does not?
12:18:47 <johnw> thanks mauke
12:18:55 <johnw> indeed, it was the problem
12:19:01 <APic> ttyrec exists
12:32:59 * hackagebot estimator 1.2.0.0 - State-space estimation algorithms such as Kalman Filters  https://hackage.haskell.org/package/estimator-1.2.0.0 (AdamFoltzer)
12:35:37 <gottharsys> @pl fn x = x + 1
12:35:37 <lambdabot> fn = (1 +)
12:36:43 <gottharsys> @pl f xs = filter (/x -> x > 4000 and x < 5000) xs
12:36:44 <lambdabot> (line 1, column 7):
12:36:44 <lambdabot> unexpected " "
12:36:44 <lambdabot> expecting operator
12:37:30 <adarqui> are there any bindings for chef (chef dsl) in haskell?
12:37:33 <Welkin> oh lambdabot 
12:37:40 <adarqui> i can't find any
12:38:46 <shapr> adarqui: that sounds interesting, but why not use Shake?
12:38:53 <shapr> adarqui: what would you do with such bindings?
12:39:23 <adarqui> shapr: for someone who already uses chef for their cookbooks etc.. was curious in seeing what it would look like if it was re-written using some haskell dsl for chef
12:40:14 <tnks> I noticed that some packages define functions that type class instances delegate to.
12:40:19 <cloudhead> is there something like a mapMWithKey?
12:40:24 <cloudhead> I'm operating on a Data.Map
12:40:26 <shapr> adarqui: this is really a replacement for make, but : http://shakebuild.com/
12:40:31 <tnks> is there a benefit to this?
12:40:38 <shapr> adarqui: if you find something like chef for Haskell, I want to hear about it!
12:40:52 <adarqui> shapr: as for myself i plan on looking into nix/nixos/nixops .. and im looking for bindings for those too: this guy has some: https://github.com/peti
12:41:00 <adarqui> shapr: cool if i find something i'll let you know!
12:41:05 <thewormkill> tnks: you mean (>>=) = someFunc instead of an inline definition? In that case it's readability
12:41:14 <thewormkill> for longer definitions
12:41:33 <tnks> thewormkill: ah, you're right, these functions are even exported.
12:41:37 <tnks> so that settles that.
12:43:16 <tnks> also, as with lots of languages that allow you to control inlining, I sometimes don't know whether it's premature optimization or not.
12:43:45 <tnks> I see it at least for these functions that are delegated to in the type class instances.
12:48:23 <geekosaur> cloudhead, traverseWithKey might do?
12:49:08 <EvanR> tnks: or worse premature accidental deoptimization
12:49:49 <thewormkill> accidental /= unintended ;)
12:51:18 <Welkin> occidental
12:55:39 <geekosaur> shapr, adarqui: https://propellor.branchable.com/ ?
12:56:16 <shapr> wow, that looks nifty
12:57:28 * geekosaur actually seriously considered a SCM system as a Haskell DSL. sadly, one thing rather important to me is portability to more than just linux/windows/os x...
12:58:51 <shachaf> Portability to what else?
12:58:59 <johnw> Haiku, of course
12:59:11 <cocreature> don’t forget hurd
12:59:35 <geekosaur> solaris/illumos is probably most important from my pov
13:00:06 <geekosaur> (yes, it's "dead" from a FOSS point of view. not at all dead at many companies...)
13:01:38 <tnks> EvanR: right.
13:02:33 <jackhill> geekosaur: is Haskell not portable to illumos?
13:03:07 <geekosaur> AIX is another one I would need to support, and while ghc can be shoehorned onto Solaris/Illumos in a somewhat unsatifactory manner (the backend is somewhat bitrotted), I don't think there's a working AIX port
13:03:32 <dmwit> cloudhead: There is the keys package, and lens offers something similar with its indexed traversals.
13:03:35 <geekosaur> well. the backend builds and "works", it just produces rather lousy code >.>
13:03:55 <jackhill> :/ This is using the native-code-generator?
13:04:11 <dmwit> ?pl f xs = filter (\x -> x > 4000 && x < 5000) xs
13:04:11 <lambdabot> f = filter (liftM2 (&&) (> 4000) (< 5000))
13:04:12 <jackhill> illumos x86 or illumos sparc
13:04:21 <geekosaur> both
13:04:33 <dmwit> f = filter (inRange (4000, 5000))
13:04:48 <dmwit> gottharsys: ^^
13:04:53 <geekosaur> my department's top 3 customers all use solaris fairly heavily, and two of them still use sparc
13:05:51 <geekosaur> and oracle's still got a sparc roadmap, however tattered it may be at this point...
13:06:05 <dmwit> tnks: It is sometimes nice for readability to have a monomorphic version of a polymorphic function. I would bet some of the typeclass definitions you're referencing have that in mind.
13:07:21 <geekosaur> jackhill, more specifically, ghc works on illumos (x86 at least, don't think anyone has seriously tried to use sparc recently), but it breaks somewhat regularly because it's not a tier 1 platform
13:09:07 <tnks> dmwit: it's just nicta's validation package.
13:09:15 <tnks> I guess it's okay for readability.
13:09:23 <tnks> personally, I'm not convinced it's that much of an asset.
13:09:30 <snaek> HEY!
13:09:43 <tnks> sometimes you just have to try it a few ways to see how it feels.
13:09:49 <snaek> anyone here ever tried react?
13:10:17 <dmwit> ?where justask
13:10:18 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
13:11:32 <cocreature> snaek: this channel is about the haskell programming language not about react
13:11:52 <cocreature> snaek: if you want to hear the opinion of haskellers on random stuff we have #haskell-blah and #haskell-offtopic
13:11:59 <snaek> bruh chill
13:12:02 <snaek> last time i was here
13:12:11 <snaek> i was debating learning haskell or staying with js
13:12:15 <snaek> and we talked about angular
13:12:26 <snaek> but i wanna know about react now and what u guys think about that m8
13:12:39 <dmwit> If this is about the Haskell bindings to react, that is on-topic.
13:12:46 <dmwit> Otherwise please ask in a more appropriate channel.
13:12:48 <hpc> conversations occasionally drift off topic, but we try to avoid it
13:12:52 <hpc> and we don't open with something off topic
13:13:21 <snaek> okay, sorry m8, ill join haskell-offtopic
13:13:22 <snaek> thx!
13:16:55 <XSITE_PROXY> Wow..phising
13:17:04 <XSITE_PROXY>  $H$9123456785DAERgALpsri.D9z3ht120
13:17:31 --- mode: ChanServ set +o dolio
13:21:00 --- mode: ChanServ set -o dolio
13:26:12 <jackhill> geekosaur: thanks!
13:33:09 * hackagebot unused 0.6.0.0 - A command line tool to identify unused code.  https://hackage.haskell.org/package/unused-0.6.0.0 (joshuaclayton)
13:35:24 <anilanar> hello, if i impl a custom Read instance
13:35:58 <anilanar> should i make readPrec error on a parse error?
13:37:55 <glguy> anilanar: You can either use fail, or pfail
13:38:09 * hackagebot located 0.1.1.0 - Source location helpers  https://hackage.haskell.org/package/located-0.1.1.0 (TrevorElliott)
13:41:59 <anilanar> do i need to impl both readsPrec and readPrec?
13:42:21 <hsk3> Is it possible to divide an integer literal across lines somehow?
13:42:22 <anilanar> docs say "Minimal complete definition: readsPrec | readPrec"
13:42:22 <hsk3> a = 63721
13:42:23 <hsk3> 73482
13:42:24 <hsk3> 47839
13:42:28 <hsk3> (I'm working with some long integers)
13:42:52 <shachaf> | means "or"
13:43:03 <anilanar> ok thanks, i wanted to make sure 
13:45:00 <geekosaur> hsk3, I don't think so
13:45:05 <hsk3> ok
13:46:31 <geekosaur> could do something horrid like using read + string gaps
13:47:05 <glguy> or write a quasiquoter
13:47:44 <hsk3> meh
13:47:51 <hsk3> no big deal
13:54:29 <ReinH> I don't know of any language with that feature.
13:56:28 <maerwald> usually, a proper editor "breaks" the lines :P
13:57:49 <geekosaur> perl6's unspace can do it. older versions of C ignored comments (actually they were stripped by cpp) so you could use comments to break up a long token, although ANSI forbade that behavior
13:58:10 * hackagebot cmark-highlight 0.1.0.0 - Code highlighting for cmark  https://hackage.haskell.org/package/cmark-highlight-0.1.0.0 (Artyom)
13:58:21 <ReinH> geekosaur: Ok, but that assumes that perl6 actually exists
13:58:33 <geekosaur> where have you been the past 6 months?
13:58:45 <ReinH> Waiting for someone to show that you can parse perl6
13:59:08 <shachaf> ReinH8R
13:59:23 <ReinH> heh
14:00:44 <bollu> what's the monad transformer for State s (Maybe a)?
14:01:02 <hpc> StateT s Maybe a
14:01:06 <bollu> thanks :)
14:01:12 <hpc> just remove the parens ;)
14:01:43 <bollu> where is StateT? >_<
14:01:51 <hpc> @hoogle StateT
14:01:52 <geekosaur> mm, right, actually unspace can't do it because the \ is parsed as a postfix
14:01:53 <lambdabot> Control.Monad.Trans.State.Lazy newtype StateT s m a
14:01:54 <lambdabot> Control.Monad.Trans.State.Strict newtype StateT s m a
14:01:54 <lambdabot> package statethread
14:01:58 <bollu> oh thanks
14:02:04 <bollu> which do I need? lazy or strict?
14:02:19 <Clint> yes
14:02:26 <hpc> actually just import Control.Monad.State
14:02:39 <hpc> hoogle is being a bit misleading there, it's re-exported
14:02:49 <geekosaur> (mostly to avoid issues with using a postfix operator on a name)
14:04:22 <bollu>   :: (s -> m (a, s)) -> StateT s m a
14:04:26 <bollu> not what I want?
14:04:27 <ertes> are there any facilities to translate Proxy into Proxy#, or should i use the latter explicitly when performance is critical?
14:04:33 <bollu> I want s -> (m a, s)
14:04:50 <bollu> :t MaybeT
14:04:50 <lambdabot>     Not in scope: data constructor ‘MaybeT’
14:04:51 <lambdabot>     Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
14:05:00 <bollu> hmm, what do I do?
14:06:00 <bollu> am I asking for nonsense?
14:06:13 <ertes> bollu: not necessarily…  what are you trying to do?  what's the application?
14:07:01 <bollu> ertes: I'm trying to simulate a machine. If it succeeds, I return a value and the new machine state, otherwise I return a Nothing and an old machine state
14:07:19 <bollu> the "machine" is sorta weird to explain. It tries to play 2048 on a 1D grid
14:07:30 <bollu> so like, given an input: 2 2 4 -> 4 4 -> 8
14:07:36 <bollu> where each "step" is ->
14:07:45 <bollu> but when given say, 2 2 2 -> 4 2 -> 4 2 -> ...
14:07:54 <ertes> bollu: is this a multi-step simulation?
14:08:05 <bollu> ertes: yes, which is why I have multiple ->
14:08:23 <ertes> bollu: there are two ways to get machines like that
14:08:29 <bollu> ertes: go on
14:08:51 <ertes> bollu: first, what is s?  the internal state of the machine?
14:09:09 <bollu> ertes: in this case, yeah, it's the list that's the "current state"
14:09:29 <bollu> a is the "value produced by combining 2 elements of the head"
14:09:46 <ertes> is it internal?  if yes, i can show you a construction that doesn't even mention it in the type
14:10:02 <bollu> ertes: external tbh
14:10:09 <ertes> i imagine 'a' to be a value produced at each step
14:10:15 <ertes> while 's' is the state of the machine
14:10:27 <ertes> if part of the state should be exposed, it should really be part of 'a'
14:10:38 <bollu> I see, okay
14:10:56 <ertes> newtype Machine a = Machine { stepMachine :: Maybe (a, Machine a) }  -- this is a very basic construction
14:11:02 <bollu> ertes: okay, let's say the machine has state s its trying to hide
14:11:06 <ertes> it's an applicative functor (not a monad!)
14:11:15 <ertes> (well, it is a monad, but not a very useful one)
14:11:44 <ertes> here is a simple counter that refuses to continue after it reaches 10:
14:11:57 <ertes> countFrom :: Integer -> Machine Integer
14:13:02 <ertes> countFrom n = Machine (if n > 10 then Nothing else Just (n, countFrom (n + 1)))
14:13:20 <bollu> ertes: makes sense
14:13:39 <ertes> note how the type is completely agnostic to the internal state type
14:13:54 <ertes> and this is an applicative functor, so you can compose machines like that
14:14:45 <bollu> right
14:15:05 <ertes> you could introduce a stop case instead of Maybe:  data Machine e a = Done e | Machine a (Machine e a)
14:15:32 <amf> if hoogle cant find an operator (?~) what other options do i have? (i suspect lens, but not positive)
14:15:44 <ertes> bollu: but if you look closely at this type you might notice something
14:16:12 <geekosaur> http://hayoo.fh-wedel.de/?query=%3F~
14:16:57 <ertes> bollu: originally we had (Machine a = Maybe (a, Machine a)), right?
14:17:40 <amf> geekosaur: ah! thanks!!
14:18:04 <geekosaur> also I expect fpcomplete's hoogle has a better chance of finding stuff like that
14:18:17 <ertes> bollu: that's (except for some strictness details) the same as: data Machine a = MachineNothing | MachineJust a (Machine a)
14:18:22 <ertes> bollu: does that type look familiar?
14:19:17 <amf> geekosaur: you're right. i shall change my ways :)
14:37:06 <ARM9> is it possible to export functions from a class instance implicitly?
14:39:18 <liste> ARM9: module Foo (MyClass(..)) where ... ?
14:40:08 <ARM9> doesn't export the inherited functions
14:41:39 <ARM9> eg class Foo has function f, and in module Bar `instance Foo Bar where` without overriding f, if I import module Bar the inherited f is not exported
14:42:00 <ARM9> I'll make a test case if this is hard to visualize
14:44:30 <ARM9> nevermind, it did work. ide isn't very snappy
15:00:00 <anilanar> whats typical way of unit testing a stream of characters from a Handle? any tutorials out there?
15:18:46 <cheater> you make your algorithm pure and swap in quickcheck for what your handle provides
15:22:04 <cheater> ertes: what do you call this transformation? newtype Machine a = Machine { step :: Maybe (a, Machine a) } ---> data Machine e a = Done e | Machine a (Machine e a)
15:22:26 <cheater> it seems to me like Maybe has been "unpacked" into the type we're defining
15:23:38 <cheater> because it's like... data Machine a = Nothing | Just (a, Machine a)  which is just like data Machine a = Nothing | Just2 a (Machine a) which is pretty much data Machine e a = Done e | Machine a (Machine e a)
15:24:05 <Iceland_jack>     Machine a = Maybe (a * Machine a)
15:24:05 <Iceland_jack>     Maybe   a = 1 + a
15:24:05 <Iceland_jack> It's basically inlining 'Maybe'
15:24:05 <Iceland_jack>     Machine a = 1 + (a * Machine a)
15:24:26 <Iceland_jack> It's not the same though
15:26:36 <frerich> Hi all! I recently became aware of the fact that the 'Countdown Solver' by Graham Hutton at http://www.cs.nott.ac.uk/~pszgmh/countdown.hs can tell how to get 24 given the numbers 6,6,5,2 (e.g. 6+((5-2)*6)), but it cannot tell how to get 17 from the same numbers. The reason is that it can only work for natural numbers.
15:26:59 <frerich> What would be a good data type to deal with fractional values, such as 5/6? A floating point type, or rather something like Data.Ratio?
15:28:04 <cheater> Iceland_jack: yeah i guess "inlining" could be OK
15:28:36 <frerich> (The problem which Hutton's program solves, the "Countdown Problem", explicitly says that all intermediate values must be natural numbers - so his program is fine. I'd just like to extend it a bit for more tricky problems)
15:28:54 <cheater> frerich: floating point types will not result in exact values.
15:29:13 <frerich> cheater: Right, hence my question for a suitable alternative which is not too painful to work with :-)
15:29:22 <cheater> frerich: admitting fractional values will likely make the algorithm diverge (follow loops that do not lead anywhere)
15:29:43 <cheater> there are exact fractional number types on hackage if you feel like trying it
15:29:46 <Iceland_jack> frerich: For Countdown you'd want to stay within integral numbers, (5`div`6)
15:29:58 <cheater> but i don't know exactly off the top of my head
15:30:21 <Iceland_jack> nvm
15:33:20 <EvanR> frerich: all number types ever https://github.com/haskellcats/haskell-numbers
15:34:06 <EvanR> * not really
15:36:17 <ertes> cheater: i call it type algebra
15:36:59 <ertes> cheater: i just replaced a type by another, isomorphic type
15:37:34 <ertes> cheater: read "," as "times" and "|" as "plus"
15:37:52 <ertes> cheater: and the space between constructor fields is also "times"
15:39:00 <ertes> that makes types a commutative semiring up to isomorphism
15:39:36 <EvanR> the free such ring?
15:39:57 <dmwit> frerich: Rational seems like a perfectly natural choice
15:40:12 <dmwit> frerich: And comes with the compiler. ;-)
15:40:20 <EvanR> dont you mean rational choice here?
15:40:38 <ertes> EvanR: much awesome! so algebra!
15:40:41 <dmwit> I'm glad you enjoyed my pun. =)
15:41:45 <dmwit> EvanR: What, no cyclotomic numbers?
15:42:03 <EvanR> enough calling stuff stuff, i want some theorems that do something
15:42:56 <dmwit> EvanR: Also seems to be missing all the FFI number types (CInt, CDouble, etc.).
15:43:29 <EvanR> those arent essentially difference
15:43:33 <EvanR> different
15:44:04 <EvanR> the real story is i went through all the FFI number types and stopped listing them after the 35th
15:44:11 <EvanR> and deleted that part of the table
15:44:40 <dmwit> heh
15:45:21 <spacegoat> Hello.
15:45:24 <spacegoat> Pm clint.
15:46:49 <Luke> anyone know of a way to get the Attoparsec Parser for the actual haskell type from Aeson? Looks like I can get a Parser for the Value but I'd like it for my FromJSON instance
15:48:22 <dmwit> There isn't one.
15:48:41 <dmwit> There's an attoparsec parser for ByteString->JSON, and then an aeson parser for JSON->your type.
15:48:54 <dmwit> The first is run to completion before the second starts.
15:48:58 <EvanR> the definition of a field can 1) include the real numbers 2) be coherent or 3) be constructive, pick 2.
15:49:10 <Luke> dmwit: where's the first funciton you mentioned?
15:49:50 --- mode: ChanServ set +o glguy
15:49:53 --- mode: glguy set +q *!*@bzq-79-178-136-195.red.bezeqint.net
15:50:12 <Luke> dmwit: do you mean ByteString->Parser Value?
15:50:13 <dmwit> Luke: Not sure; it's been a while since I used the library. Why do you ask?
15:50:38 <Luke> dmwit: because what you explained would work for my purpose
15:50:56 <dmwit> What is your purpose?
15:51:21 <Luke> running a parser against a file to produce a JSON type which I can then turn into my own internal type
15:51:35 <dmwit> Why do you want to separate the phases, though?
15:51:39 <thewormkill> and why not go the direct route?
15:51:40 <dmwit> e.g. what is bad about the type of `decode`?
15:51:47 <EvanR> Luke: you can do that
15:51:52 <Luke> dmwit: i'm reading from a file with io-streams
15:51:53 <EvanR> with aeson
15:52:22 <dmwit> Luke: You'll need to tell me more for me to understand why that makes `decode`'s type bad.
15:52:29 <Luke> EvanR: I see the `json` function here but it has type `Parser Value` and I'm not sure how to go from Value -> MyType
15:52:31 <EvanR> an incremetal json parser would be nice but probably wont be as nice as aeson
15:52:42 <dmwit> Luke: By the way, I'm not trying to give you a hard time. I'm trying to be helpful. But I don't know the details of your problem yet.
15:53:34 <dmwit> Luke: Have you read the "writing instances by hand" section of the fine documentation?
15:53:38 <EvanR> Luke: see parse, parseEither, parseMaybe
15:53:51 <dmwit> Luke: It explains how to write a `Value -> Parser MyType` function.
15:53:59 <Luke> one moment
15:54:11 <dmwit> http://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson.html#g:2
15:54:19 <EvanR> you first need to convert the Parser Value to Parser MyType using the parser DSL
15:54:31 <Luke> I think the `json :: Parser Value` plus `fromJSON :: Value -> Result a` is sufficient
15:54:44 <Luke> EvanR: I already have a FromJSON instance
15:54:45 <EvanR> well if you want to do that, you dont even need two steps
15:54:52 <EvanR> just use decode
15:55:00 <Luke> I don't have the whole file in a bytestring though
15:55:08 <Luke> i'm using io-streams to stream the file in
15:55:08 <dmwit> Luke: If you already have a `FromJSON` instance, then once again I ask: what is wrong with `decode :: FromJSON a => ByteString -> Maybe a`?
15:55:24 <EvanR> well json :: Parser Value isnt going to help you
15:55:28 <Luke> dmwit: I don't have the whole file in a ByteString
15:55:39 <EvanR> its not incremental
15:55:51 <Luke> yeah... hmm
15:55:52 <dmwit> EvanR: It is.
15:55:58 <frerich> I just successfully ported a small Haskell program from all-Int to Rational + Integer, and it did not involve 15 minutes of random combinations of fromIntegral, toInteger and truncate. I think I transcended to the next level of Haskell-proficiency.
15:56:06 <EvanR> Result is Error or Success
15:56:09 <dmwit> EvanR: See `parse :: Parser a -> ByteString -> Result a`, one result of which can be `Partial`.
15:56:09 <EvanR> not NeedMoreInput
15:56:11 <Luke> right
15:56:23 <dmwit> EvanR: You are wrong.
15:56:27 <EvanR> er..
15:56:40 <Luke> wait where do you see partial?
15:56:55 <Luke> I just see Success or Errror
15:56:58 <EvanR> im looking at latest version of the docs
15:57:10 <EvanR> attoparsec lets you do incremental parsing
15:57:14 <EvanR> but aeson doesnt
15:57:23 <dmwit> `json :: Data.Attoparsec.ByteString.Parser Value`
15:57:43 <Luke> dmwit: where do you see partial?
15:57:56 <EvanR> maybe dmwit is looking at attoparsec docs
15:57:58 <dmwit> and `parse :: D.A.B.Parser a -> ByteString -> Result a` and `type Result = IResult ByteString` and `data IResult i r = ... | Partial (i -> IResult i r) | ...`
15:58:02 <dmwit> http://hackage.haskell.org/package/attoparsec-0.13.0.2/docs/Data-Attoparsec-ByteString.html#t:Parser
15:58:05 <Luke> dmwit: also see above. I'm already talking about incremental `json` + `fromJSON` but the partial is the important part
15:58:29 <Luke> dmwit: https://hackage.haskell.org/package/aeson-0.11.2.0/docs/Data-Aeson.html#t:Result
15:58:33 <dmwit> So I believe Luke was right to say that `json` + `fromJSON` should work for him where `decode` won't.
15:58:41 <Luke> let me try that
15:58:53 <Luke> i'm still not sure it can handle the chunking of file reading
15:59:00 <dmwit> Luke: Yes, you won't be able to get any part of `MyType` until the entire file has been read.
15:59:07 <Luke> right
16:00:01 <EvanR> one thing that is possible is to turn a stream of bytes into a stream of json tokens
16:00:09 <EvanR> which may or may not help
16:00:30 <EvanR> but this isnt outside aeson also
16:00:59 <EvanR> er.... IS.... >_<
16:01:17 --- mode: glguy set -qo *!*@bzq-79-178-136-195.red.bezeqint.net glguy
16:01:27 <dmwit> Anyway, I don't think there's anything *useful* to be had from aeson in terms of incremental parsing. So I guess I also owe EvanR an apology.
16:01:46 <dmwit> EvanR: Sorry. Your top-level description was accurate.
16:01:59 <Luke> here's my scratch pad: http://lpaste.net/9148836938176790528
16:02:03 <Luke> this doesn't type check
16:02:39 <EvanR> if you were a normal person you would do like 100% of web frameworks and browsers and accumulate the entirety of the json first then parse it
16:02:47 <EvanR> even if its 100M 
16:02:52 <Luke> haha
16:03:08 <Luke> i /think/ the `withFileAsInput` from io-streams is chunking for me
16:03:08 <dmwit> Luke: Perhaps you meant `IO (Result [...])` instead of `IO (Maybe [...])`.
16:03:11 <Luke> oh right
16:03:28 <EvanR> thereby disposing of your university C class where obviously the only way to do anything is with I/O streams
16:03:58 <Luke> that's it
16:04:02 <Luke> it all type checks at least
16:04:08 <Luke> `readKeys f = fromJSON <$> Streams.withFileAsInput f (parseFromStream json)`
16:05:05 <Luke> thanks guys
16:07:26 <dgonyeo> anyone here familiar with how haskell does dns resolution?
16:07:29 <Luke> still not totally sure this is semantically correct though ;-)
16:07:49 <dgonyeo> I built a container with just a haskell web app and what ldd said it needs, and it can run but dns is broken
16:08:06 <dgonyeo> looking at strace it never touches /etc/resolv.conf or dlopens anything
16:08:13 <dgonyeo> so I'm at a loss as to what could be wrong
16:08:19 <Koterpillar> dgonyeo: is it only Haskell?
16:08:27 <dgonyeo> Koterpillar: yup
16:08:38 <Koterpillar> what do you have in that container that works?
16:08:58 <dgonyeo> the container is just the binary produced by cabal, the linker, and the dynamic libraries it links against
16:09:01 <glguy> dgonyeo: Normally it's done via getaddrinfo(3)
16:09:07 <Koterpillar> what do you mean by the container?
16:09:14 <glguy> but that's up to the particular application
16:09:30 <mniip> what would would a good graphical framework to use if all I need to do is draw a bunch of polygons and detect mouse clicks on those polygons?
16:09:33 <mniip> would be*
16:09:34 <Koterpillar> there was another thing that controlled DNS resolution [on Linux], but I forgot its name
16:09:48 <dgonyeo> Koterpillar: to phrase it without containers, I have a chroot with only my binary the linker and the dynamic libs
16:09:50 <mniip> 2d polygons, to clarify
16:09:56 <glguy> dgonyeo: It'd be good to paste all the information you have including the error message to lpaste.net
16:10:23 <Koterpillar> dgonyeo: OS?
16:10:37 <dgonyeo> Koterpillar: linux
16:10:43 <dgonyeo> http://lpaste.net/2781538945375141888 http://lpaste.net/3229434623381471232
16:11:29 <glguy> dgonyeo: OK, it's using the getaddrinfo(3) function
16:12:18 <dgonyeo> glguy: any clue if I'm missing something that needs to work?
16:12:40 <glguy> I don't know, but that simplifies the problem away from Haskell
16:12:58 <dgonyeo> kk
16:13:14 <Koterpillar> ahh, nsswitch.conf
16:13:34 <Koterpillar> dgonyeo: not sure if it is the issue, but that should give you some more things to google
16:16:11 <dgonyeo> well at the very least copying /etc/nsswitch.conf into the container didn't help
16:16:13 <dgonyeo> time to go google
16:16:31 <glguy> dgonyeo: and it works outside of the container? One way that could fail is if the app was demanding an ipv6 address (because that particular hostname doesn't have an AAAA record)
16:16:55 <dgonyeo> glguy: yup, it works outside of the container
16:24:00 <gottharsys> @pl f x = (x < 5000) && (x > 4000)
16:24:00 <lambdabot> f = liftM2 (&&) (< 5000) (> 4000)
16:27:25 <gottharsys> @pl f x = (x < 5000 && x > 4000) || (x > 7000 && x < 8000)
16:27:25 <lambdabot> f = ap ((||) . liftM2 (&&) (< 5000) (> 4000)) (liftM2 (&&) (> 7000) (< 8000))
16:29:02 <hpc> :t or . map and
16:29:04 <lambdabot> Foldable t => [t Bool] -> Bool
16:29:38 <hpc> > or . map and [[(< 5000), (> 4000)], [(> 7000), (< 8000)]] $ 4500
16:29:40 <lambdabot>      Couldn't match expected type ‘Integer -> t0 Bool’
16:29:40 <lambdabot>                  with actual type ‘[Bool]’
16:29:40 <lambdabot>      Possible cause: ‘map’ is applied to too many arguments
16:29:51 <hpc> oh right
16:33:19 * hackagebot isobmff-builder 0.1.0.0 - A (bytestring-) builder for the ISO base media file format ISO-14496-12  https://hackage.haskell.org/package/isobmff-builder-0.1.0.0 (SvenHeyll)
16:38:26 <mniip> what would be a good graphical framework to use if all I need to do is draw a bunch of 2d polygons and detect mouse clicks on those polygons?
16:38:56 <hpc> gloss, perhaps
16:39:17 <hpc> (make sure you import the IO versions of things)
16:41:11 <gottharsys> @pl f x = x `mod` 2 == 0
16:41:11 <lambdabot> f = (0 ==) . (`mod` 2)
16:43:19 * hackagebot dlist-instances 0.1.1 - Difference lists instances  https://hackage.haskell.org/package/dlist-instances-0.1.1 (GregWeber)
16:44:18 <gottharsys> @pl f x = (sqrt (8*x + 1) - 1) `mod` 2 == 0
16:44:18 <lambdabot> f = (0 ==) . (`mod` 2) . subtract 1 . sqrt . (1 +) . (8 *)
16:46:41 <mzabani> Hi everyone! I need a typeclass' (call it t1) function to return an object whose type is an instance of another typeclass (call it t2), but I want to restrict the returned object according to the type of the object whose type is an instance of t1
16:47:22 <dibblego> mzabani: this is a functional dependency
16:47:45 <mzabani> hmm never heard of it
16:48:27 <mzabani> isn't there some conventional pattern to solve this?
16:48:47 <mzabani> or are functional dependencies conventional?
16:49:17 <EvanR> mniip: graphics drawing combinators allows you to put a value on each picture, which combines with other pictures using monoid, and lets you sample an x y location, but doesnt give you mouse >_>
16:50:54 <dgonyeo> glguy: Koterpillar figured it out, I was missing bits of glibc (libss_*.so and resolv.so)
16:50:58 <dgonyeo> thanks for the help!
16:53:09 <mniip> EvanR, seems like I'll have to use both
16:54:05 <mniip> now, I need to solve a couple mathematical problems like computing a dual of a graph using only parallelograms
16:54:16 <Koterpillar> dgonyeo: did I?
16:57:18 <dgonyeo> Koterpillar: I was also missing nsswitch.conf, which was needed
16:57:21 <dgonyeo> so yes :)
16:57:37 <S11001001> mzabani: for every instance of t1, there is a particular instance of t2 you have in mind, right?
16:58:06 <S11001001> mzabani: (by "particular instance of t2" I mean a particular type, which happens to have a t2 instance)
16:58:12 <mzabani> S11001001: exactly
16:59:13 <S11001001> mzabani: check out https://ocharles.org.uk/blog/posts/2014-12-13-multi-param-type-classes.html and https://ocharles.org.uk/blog/posts/2014-12-14-functional-dependencies.html
17:00:22 <mzabani> S11001001: I'm pretty new to haskell, but it seems to me there should be a simpler way
17:00:43 <S11001001> mzabani: also check out https://ocharles.org.uk/blog/posts/2014-12-12-type-families.html , which provides an alternative way of expressing the same thing
17:01:05 <mzabani> for example: what if I want to develop a single API for differente data sources, which will implement them separately
17:01:10 <gottharsys> @pl f x = x == fromIntegral(round x)
17:01:11 <lambdabot> f = ap (==) (fromIntegral . round)
17:01:41 <S11001001> mzabani: The thing is that MPTC+fundep or TF really very precisely fits the problem description that you just gave, so you might look for alternatives, but chances are they would be even more exotic
17:02:11 <mzabani> maybe these methods return objects whose types are themselves instances of another typeclass, but require separate implementations
17:03:21 * hackagebot isobmff-builder 0.1.0.1 - A (bytestring-) builder for the ISO base media file format ISO-14496-12  https://hackage.haskell.org/package/isobmff-builder-0.1.0.1 (SvenHeyll)
17:03:45 <S11001001> mzabani: at the very least, you have the sample that both dibblego and I read it and immediately thought of the same thing :)
17:03:45 <mzabani> S11001001: thanks for all the articles, I'll take a look at them
17:03:57 <mzabani> lol that is true
17:04:05 <dibblego> it's exactly fundeps
17:04:45 <mzabani> coming from OO languages and knowing returning interface types would fit the bill nicely, it sounds strange to me that typeclasses without these extensions can't handle it
17:05:00 <gottharsys> @pl f x = read ("[" + x + "]")
17:05:00 <lambdabot> f = read . (("]" + "[") +)
17:05:01 <dibblego> OO languages cannot handle it either
17:05:44 <mzabani> hmm, why not?
17:05:52 <dibblego> because they don't have fundeps :)
17:06:02 <dibblego> (nor any way to emulate fundeps, many people have tried)
17:06:17 <mzabani> oh, but I wouldn't need to enforce fundeps
17:06:22 <glguy> mzabani: If the thing you want can be handled by "interfaces" maybe you're asking for something else that people interpreted you to be asking for
17:06:27 <gottharsys> @pl f x = read ("[" ++ x ++ "]")
17:06:27 <lambdabot> f = read . ('[' :) . (++ "]")
17:06:52 <dibblego> "restrict the returned object according to the type of the object whose type is an instance of t1"
17:06:58 <mzabani> I would just leave each implementation to return instances with different implementations, but all tied to an API
17:07:13 <dibblego> then you wouldn't be restricting anything, nor obtaining the benefits of having done so
17:07:25 <EvanR> mzabani: if no one has mentioned it yet, the simplest way to make a interface / implementation separation in haskell is with a record of functions
17:07:37 <mzabani> EvanR: I thought of that at first!
17:07:46 <mzabani> but then I thought about using those nice typeclasses
17:07:54 <dibblego> type-classes are not analogous to interfaces, data types are
17:08:10 <S11001001> mzabani: There's a kind of information loss involved in this use of interfaces.  You can correct it with type parameters, where they are available, but the correctness is enforced in this style of Haskell.  Approaches that preserve type information are strongly preferred over those that discard it, in Haskell.
17:08:21 * hackagebot pretty-show 1.6.12 - Tools for working with derived `Show` instances and generic  inspection of values.  https://hackage.haskell.org/package/pretty-show-1.6.12 (IavorDiatchki)
17:08:35 <mzabani> and then haskell bit me, because returned types should be polymorphic for all implementations of the typeclass
17:08:47 <EvanR> you can parameterize the type of this record
17:08:56 <mzabani> S11001001: that's true, although in this case I thought at first I wouldn't be losing much
17:09:15 <EvanR> after you reach the expressive limit of that, you can add more weird stuff like type families 
17:09:28 <EvanR> or reflection
17:09:29 <S11001001> mzabani: Right.  Your data source ends up looking more like class T2 s => T1 s a where getAll :: a -> [s]
17:09:43 <mzabani> do you guys think I should go straight to type families and fundeps?
17:09:58 <EvanR> reaching directly for type classes of any sort should be done with some caution
17:09:59 <S11001001> mzabani: moving the T2 constraint up to the class makes a world of difference
17:10:00 <EvanR> i think
17:10:31 <EvanR> S11001001: did we ever get a concrete description of what mzabani's api looks like?
17:10:37 <EvanR> or is all this on the level of T1, T2
17:10:50 <dibblego> class TypeClass t1 t2 | t1 -> t2 where apply :: t1 -> t2 
17:10:58 <EvanR> ;_;
17:10:58 <dibblego> inferred from a description
17:11:10 <S11001001> EvanR: no; I merely confirmed that there exists a functional dependency in the stated invariants
17:11:13 <EvanR> it has the concrete structure of "a function from anything to anything" ?
17:11:25 <EvanR> this is worse than java
17:11:49 <dibblego> I inferred that, based on the description. It is not established.
17:12:04 <mzabani> there are typeclass functions returning objects whose types implement other typeclasses
17:12:12 <mzabani> and so on and so on..
17:12:15 <S11001001> EvanR: well that's just not true, because the forall has more stuff underneath it than t1 -> t2.
17:12:17 <dibblego> @type (*)
17:12:18 <lambdabot> Num a => a -> a -> a
17:12:19 <EvanR> mzabani: for the sake of it? or 
17:12:29 <dibblego> @type read . show
17:12:30 <lambdabot> (Read c, Show a) => a -> c
17:12:41 <mzabani> no, the current API I have in mind is 3 typeclasses deep
17:13:04 <EvanR> you said youre new, so ill just caution you against going directly to type classes without much experience
17:13:31 <EvanR> theyre not like "i need to do a task, start by making a ClassForTask" in other languages
17:13:37 <dibblego> mzabani: maybe show some code
17:13:56 <mzabani> I'll paste some code, hold on
17:14:17 <gottharsys> @pl wordtri w = sum [fromEnum(x) - 64 | x <- w]
17:14:17 <lambdabot> wordtri = sum . return . (-) (fromEnum x) . ((64 | x) <-)
17:15:51 <gottharsys> wordtri = sum . map (subtract 64) . map fromEnum
17:15:57 <gottharsys> @pl wordtri = sum . map (subtract 64) . map fromEnum
17:15:58 <lambdabot> wordtri = sum . map (subtract 64 . fromEnum)
17:17:30 <mzabani> http://lpaste.net/170730
17:18:59 <EvanR> these look more like data types to me
17:19:44 <EvanR> Contra is basically a record
17:19:46 <mzabani> I'll need many different implementations for Conta, Autorizacao and ConfirmacaoTransferencia
17:19:57 <mzabani> oops, there's a method missing there
17:20:06 <mzabani> autorizar :: a ->
17:20:27 <mzabani> autorizar :: (Autorizacao b) => a -> IO (Either T.Text b)
17:20:28 <EvanR> you can have many different implementations of the same record type
17:21:22 <mzabani> you mean by storing functions?
17:21:45 <EvanR> functions or non functions like banco
17:22:43 <mzabani> do you think that's a better aproach to it?
17:23:36 <EvanR> for records, definitely
17:26:30 <dibblego> I agree, data type
17:26:31 <mzabani> wouldn't fundeps also be a proper way to handle this?
17:27:03 <EvanR> Contra { banco :: Banco, agencia :: Text, corrente :: Text, autorizar :: IO (Either Text Autorizacoa) } for exmaple
17:27:25 <EvanR> fundeps sounds like an insane way to handle this
17:27:53 <mzabani> I was trying to avoid functions in records at all costs (no special reason for that)
17:28:01 <EvanR> in the case of Contra... there arent any
17:28:22 * hackagebot casr-logbook 0.1.1 - CASR 61.345 Pilot Personal Logbook  https://hackage.haskell.org/package/casr-logbook-0.1.1 (TonyMorris)
17:28:24 <EvanR> but even if there were, that is a great way to make behavior customizable and still well typed
17:28:31 <EvanR> Conta*
17:29:46 <mzabani> all right, I'll follow this idiom, then
17:30:03 <mzabani> thanks for all the help, everyone
17:30:19 <EvanR> in fact doing it with typeclasses requires you to use functions (that are passed around in dictionaries) as part of your api when you dont need it
17:31:31 <mzabani> it seems to me that typeclasses would force an implementation of it to be in one place
17:32:08 <mzabani> it just seems like a very proper mechanism at first
17:32:17 <EvanR> it does have the word class in it
17:32:34 <EvanR> which should sound more suspicious than anything!
17:33:06 <EvanR> on teh subject of locations of implementations, im not sure what you mean
17:34:30 <mzabani> it is possible now to create a record with functions from all over the place
17:34:43 <mzabani> although of course it is possible to create an implementation that does the same, so never mind
17:35:08 <EvanR> instances can go anywhere, in fact they are global when imported
18:11:43 <negatratoron> can a GADT be indexed on instances of a single type?  or is there a type system extension that achieves that effect?
18:12:11 <negatratoron> or, does that currently require a dependently typed language?
18:15:56 <acowley> negatratoron: Maybe you mean DataKinds
18:16:16 <acowley> negatratoron: You can constrain an index to be a type of a particular kind, where the kind in question is a lifted type you defined
18:17:01 <acowley> I meant the word "constrain" there in the general, non-Haskell sense. This is a typing question rather than ad hoc polymorphism.
18:17:12 <negatratoron> i very well might mean data kinds, let me look that up
18:17:50 <negatratoron> oh yeah, I think that's right
18:18:24 * hackagebot isobmff-builder 0.2.0.1 - A (bytestring-) builder for the ISO base media file format ISO-14496-12  https://hackage.haskell.org/package/isobmff-builder-0.2.0.1 (SvenHeyll)
18:18:29 <negatratoron> i would rather write this in haskell than idris
18:18:46 <negatratoron> more approachable
18:19:03 <negatratoron> it's a website code generator
18:19:06 <negatratoron> okay back to work
18:28:25 * hackagebot isobmff-builder 0.2.0.2 - A (bytestring-) builder for the ISO-14496-12 base media file format  https://hackage.haskell.org/package/isobmff-builder-0.2.0.2 (SvenHeyll)
18:43:25 * hackagebot isobmff-builder 0.2.0.3 - A (bytestring-) builder for the ISO-14496-12 base media file format  https://hackage.haskell.org/package/isobmff-builder-0.2.0.3 (SvenHeyll)
19:01:18 <tnks> dibblego: are you managing releases for the validation package?
19:01:41 <avalokite> /eval /channel add -auto $C $chatnet
19:04:54 <avalokite> eval echo $C $chatnet
19:05:14 <avalokite> eval }echo $C $chatnet
19:05:25 <glguy> avalokite: Please test that in a different channel
19:05:44 <avalokite> eval /echo $C $chatnet
19:06:00 --- mode: ChanServ set +o glguy
19:06:09 --- mode: glguy set +q $a:avalokite
19:11:52 <dibblego> tnks: sure, sup?
19:12:56 <mniip> what's flip map?
19:13:26 <tnks> dibblego: I noticed the mtl dependency got bumped in source code.
19:13:31 <mniip> definitely not for
19:13:47 <norotartagen> (...even though haskell uses :: for type declarations and : for cons)
19:13:52 <tnks> but there's also a lot of issues interesting to resolve with Base being improved.
19:13:55 <norotartagen> (i'm gonna wear out my : key)
19:14:01 <glguy> ?type (<&>)
19:14:02 <lambdabot> Functor f => f a -> (a -> b) -> f b
19:14:07 <dibblego> tnks: I am not sure what you are suggesting
19:14:23 --- mode: glguy set -qo $a:avalokite glguy
19:14:31 <tnks> dibblego: it might be nice to release the package with an upgraded dependency bound.
19:14:43 <dibblego> tnks: ok, which bounds exactly?
19:15:05 <tnks> dibblego: I'm pretty sure it was mtl that was holding me back, but I should check everything.
19:15:09 <dibblego> tnks: send a patch and I will do
19:15:11 <norotartagen> technically i could run sed on all my source files but meh
19:15:20 <tnks> dibblego: coo.
19:15:51 <tnks> dibblego: also, I was thinking about the difference between the monoid/semigroup instance in validation versus the one in scalaz.
19:16:11 <tnks> scalaz accumulates both successes and failures, but validation gives the first passing success.
19:16:31 <cheater> ertes: ok
19:16:59 <tnks> I think after thinking about it, I'm fine with the semantics in the validation package, because I can always foldr a merging operation.
19:17:50 <tnks> I'm not sure just for that one function it's worth an entirely new data type.
19:18:01 <tnks> and I'm not sure exactly what the "common case" is.
19:18:46 <dibblego> yeah, there is a poossible argument that the semigroup aligns with (<.>)
19:19:31 <tnks> right.
19:38:27 * hackagebot th-utilities 0.1.1.1 - Collection of useful functions for use with Template Haskell  https://hackage.haskell.org/package/th-utilities-0.1.1.1 (MichaelSloan)
19:43:27 * hackagebot tcp-streams 0.2.0.0 - One stop solution for tcp client and server with tls support.  https://hackage.haskell.org/package/tcp-streams-0.2.0.0 (winterland)
19:43:51 <mniip> hmm why does ghci claim 1 terabyte of virtual memory?
19:44:33 <alercah> it's a hacky way to figure out the pointer width
19:45:36 <geekosaur> mniip, https://downloads.haskell.org/~ghc/master/users-guide/8.0.1-notes.html#runtime-system
19:48:36 <aarvar> dibblego: oh hey, you still exist
19:49:00 <dibblego> hi aarvar 
20:24:30 <dibblego> tnks: try validation-0.5.3
20:24:32 <dibblego> gotta go
20:28:29 * hackagebot validation 0.5.3 - A data-type like Either but with an accumulating Applicative  https://hackage.haskell.org/package/validation-0.5.3 (TonyMorris)
21:40:03 <trepta> hi everyone!
21:40:51 <raduom> hi there. :)
21:41:13 <trepta> nice!
21:41:18 <trepta> hey I have a question
21:41:45 <trepta> I want to use a binary search tree, but I am too lazy to write it myself
21:42:12 <trepta> and too lazy to read the Data.Tree.AVL documentation
21:42:32 <trepta> is there an easier way to use a binary search tree?
21:42:42 <shachaf> What do you want it for?
21:43:16 <trepta> ha
21:43:20 <trepta> i am dumb
21:43:44 <trepta> well I want to query a structure of n elements in constant or log n time
21:43:57 <trepta> I think that lists are O(n) right?
21:44:06 <roboguy`> trepta: query as in index?
21:44:11 <roboguy`> or see if an element exists?
21:44:12 <trepta> yeah 
21:44:27 <trepta> Ultimately I would like an array
21:44:31 <roboguy`> if you're looking for fast indexing, you could look at Vector
21:44:33 <trepta> like an actual array
21:44:37 <roboguy`> Or Array for that matter
21:44:41 <roboguy`> Vector is easier though
21:44:55 <roboguy`> (unless you absolutely need Array for some reason)
21:44:58 <trepta> Data.Vector?
21:45:01 <roboguy`> yeah
21:45:07 <trepta> ok, let me see
21:45:10 <trepta> thanks!!
21:45:14 <roboguy`> That is O(1) indexing
21:45:21 <trepta> N I C E
21:45:29 <adarqui> d
21:45:33 <roboguy`> (since it uses an actual array inside)
21:45:39 <trepta> holy grail man!
21:45:43 <trepta> thanks!! :)
21:45:54 <roboguy`> no problem!
21:53:46 <trepta> ... how do I sort a vector?
21:54:52 <pavonia> vector-algorithms has a sort function
21:59:34 <jhance> If you're actually going to be modifying that vector in a way that stream fusion won't make optimal, you can also consider Sequence which has in general better performance than List while being more convenient to use than Vector for some operations
22:53:33 * hackagebot tcp-streams 0.2.1.0 - One stop solution for tcp client and server with tls support.  https://hackage.haskell.org/package/tcp-streams-0.2.1.0 (winterland)
23:03:05 <smorele> wow, more people than #haskell.fr :)
23:03:26 <Axman6> more people than #python usually ;)
23:23:04 <smorele> more than #python ? then why is haskell less popular ?
23:24:39 <liste> smorele: the people who use Haskell are more likely to IRC
23:27:11 <ent> maybe it's just a lie
23:27:18 <ent> and haskell is actually the more popular language
23:27:32 <smorele> hum OK liste thanks for information. I'm a new comer into haskell world :)
23:28:00 <gfixler> my work was in Python, but I secretly figured things out in Haskell on a separate computer
23:28:18 <gfixler> then cried while failing to translate it nicely to python
23:33:08 <cocreature> gfixler: you just need to write a haskell program to do the translation for you
23:33:19 <gfixler> agreed
23:34:02 <gfixler> or I can just add a haskell installer to my python
23:34:09 <gfixler> then everyone can have haskell
23:34:30 <cocreature> free haskell for everybody!
23:36:29 <pikajude> hi, i forget the answer to this but i asked yesterday
23:36:43 <pikajude> is there any difference, race condition wise, between atomically . writeTChan and writeChan?
23:45:01 <ertes> python programmers just make more noise…  have you read an average python program's documentation?  "lookie!  wow!  python so great!  python so amazing!  so beauty!  many language!"
23:46:06 <ertes> i could never figure out how one can have so much love for HashMap String Dynamic
23:46:07 <cocreature> much scoping! very type error!
23:48:15 <suppi> i'm currently in need to write a bit of python at work
23:48:27 <suppi> the error messages are horrible
23:49:20 <suppi> i mean, i could get by if all i got was a line and a column, but i don't even get that
23:49:43 <suppi> just "syntax error"
23:50:03 <ertes> pikajude: one of the two is a type error
23:51:48 <suppi> and yet, haskell is the one with bad error messages...
23:53:49 <ertes> gfixler: if you figured it out in haskell, why did you try to translate it to python?  that seems counterproductive
23:55:41 <gfixler> ertes: that's how we do it in the biz
23:56:10 <Ashy> "Enterprise"
23:57:50 <ertes> gfixler: i found that even the most bone-headed management will listen to productivity arguments backed by evidence
23:58:00 <Cale> Which business is that?
23:58:28 <gfixler> games
23:59:33 <gfixler> I started writing little functions that would generate Python calls to Maya
