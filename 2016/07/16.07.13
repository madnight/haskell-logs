00:00:16 <quchen> 2 hours sounds excessive. But that’s what I would do if I used Cabal, yes.
00:00:36 <quchen> Maybe there are better solutions, but I don’t know them.
00:00:54 <Mateon1> I'm missing linker things for doctest, syb, ghc-paths, base (uh oh), QuickCheck, tf-random, primitive and random.
00:01:00 <Mateon1> I cannot reinstall base
00:01:03 <Mateon1> So... crap
00:01:28 <quchen> Base comes with everything built properly, it comes with the compiler.
00:01:34 <quchen> There’s no need to rebuild that.
00:01:40 <quchen> But all the other things, yes.
00:01:57 <Mateon1> Is it possible that base has no profiling enabled, theferore not allowing me to build anything with profiling?
00:02:36 <tdammers> come to the dark side, use stack
00:02:37 <Mateon1> Why do libs need to be built with profiling in order to profile at all?
00:02:44 <Mateon1> tdammers: IDE doesn't support it
00:03:36 <tdammers> which IDE is that? and have you tried rolling without one?
00:04:01 <tdammers> because Haskell is a language for which IDEs provide relatively little benefit
00:04:16 <tdammers> AFAIK, most Haskellers just roll with vi(m) or emacs
00:04:27 <Mateon1> tdammers: Leksah, but I'm kinda wanting to switch to VIM, (but my MSYS environment doesn't seem to like vim plugins)
00:04:45 <tdammers> there's a vim for Windows
00:04:51 <quchen> Base has profiling enabled.
00:04:54 <Mateon1> tdammers: Yes, but not so many plugins
00:05:06 <quchen> (Unless you compiled GHC yourself and made sure it does not.)
00:05:13 <tdammers> might be personal, but I don't feel the need for an awful lot of plugins
00:05:41 <tdammers> switching to a unix-like OS might be a bit of a huge step, but I'd consider it anyway btw
00:05:43 <Mateon1> I tried using the haskell-vim-now installer but it broke my previous vim installation and didn't install properly itself
00:05:58 <liste> I couldn't use Vim for Haskell without Syntastic :(
00:06:04 <Mateon1> ^
00:06:14 <liste> or maybe I could but it'd feel so painful and slow
00:06:17 <tdammers> vanilla vim with a few vimrc tweaks works fine for me
00:06:25 <Mateon1> Syntastic, hlint, integrated hoogle...
00:06:51 <tdammers> :!hlint, :!hoogle, :!git ...
00:06:54 <tdammers> ;)
00:07:16 <Mateon1> tdammers: Tmux is better for that, if you bother to use Bash commands
00:07:40 * hackagebot http-media 0.6.4 - Processing HTTP Content-Type and Accept headers  https://hackage.haskell.org/package/http-media-0.6.4 (TimothyJones)
00:07:40 * hackagebot leapseconds-announced 2017 - Leap seconds announced at library release time.  https://hackage.haskell.org/package/leapseconds-announced-2017 (BjornBuckwalter)
00:07:48 <tdammers> it's not; :! knows more about my editing context than a standalone shell
00:08:01 <tdammers> but if I do want a standalone shell, I just use xmonad to multiplex
00:08:07 <tdammers> more flexible than tmux
00:08:42 <tdammers> although I do use tmux (or screen) to multiplex my background jobs (stack install --file-watch, browserify, development server, etc.)
00:09:15 <Mateon1> tdammers: stack install --file-watch? What is that sorcery?
00:09:41 <Mateon1> If it does what I think it does, I want it.
00:10:54 <quchen> “stack install” is just short for “stack build --copy-bins”. And “build” supports rebuilding on change. :-)
00:12:51 <Mateon1> Okay then, I think I'm dropping Leksah. I still need to fix my Vim config since that installer script broke everything
00:13:52 <tdammers> it gets better even
00:14:29 <tdammers> if you have test suites in your .cabal, stack install --file-watch --test will not only rebuild on save, but will also run all your tests
00:15:02 <tdammers> OTOH, even if you're not using a tool that supports this out-of-the-box, it's not hard to script yourself using inotifywait
00:15:05 <Mateon1> tdammers: Leksah does this
00:15:22 <tdammers> well sure, but you don't need an IDE to get that level of comfort
00:16:13 <Mateon1> Failed, I can't resolve the packages with Stack
00:16:23 <Mateon1> Due to GLFW and argparser, apparently
00:20:18 <shachaf> If I have a long one-liner in ghci and I get an error at column 190, is there an easy way to see where the error is?
00:23:31 <Cale> take 190 "<paste code here>"
00:23:38 <Cale> ?
00:23:46 <Cale> shachaf: hth
00:24:08 <Mateon1> I don't get stack
00:24:42 <Mateon1> "Error parsing targets: The project contains no local packages (packages not marked with 'extra-dep')"
00:25:27 <Mateon1> I have an "executable PackageName" and "test-suite test-PackageName" in the .cabal file, but stack doesn't pick it up?
00:27:24 <Cale> What are you trying to build? Supposedly this refers to something in stack.yaml?
00:27:37 <shachaf> Cale: Then I need to escape backslashes and contaminate my history and all sorts of things.
00:28:07 <shachaf> Cale: With readline I could e.g. use Alt-190 right-arrow to move right 190 characters.
00:28:13 <shachaf> I don't know if haskeline has anything like that.
00:28:50 <tdammers> Mateon1: how did you generate your stack.yml?
00:29:14 <Mateon1> Cale: The current project, I did "stack init", which failed because of GLFW and argparser, so I did "stack init --omit-packages", which succeeded with warnings, and then I get that message during "stack install"
00:29:48 <tdammers> Mateon1: http://docs.haskellstack.org/en/stable/GUIDE/#existing-projects
00:30:04 <Cale> Oh, well, if you told it not to install those, probably it means you have to add code for them to your project?
00:30:39 <Mateon1> So... Do GLFW and argparser not exist within stack?...
00:31:15 <Cale> Stack is just a tool for building and installing packages, and it can install packages from many different sources
00:31:27 <tdammers> they might not; if that's the case, you can add them manually (under extra-deps)
00:32:00 <tdammers> by default, stack only pulls packages from the curated stackage lists, but you can add anything from hackage, as well as your own git repositories etc.
00:32:26 <quchen> Mateon1: Try running “stack solver” for a simple attempt at a solution.
00:32:32 <tdammers> the reason you have to do this explicitly is because it breaks the promise that the curated lists are designed to work together without conflicts
00:32:52 <tdammers> http://docs.haskellstack.org/en/stable/GUIDE/#adding-dependencies
00:32:55 <tdammers> this should explain it
00:33:12 <Cale> It doesn't look to me like Stackage has a GLFW package
00:37:35 * hackagebot validity 0.1.0.0 - Validity typeclass  https://hackage.haskell.org/package/validity-0.1.0.0 (Norfair)
00:46:37 <Mateon1> Oh, stack installed the packages without profiling. What's the flag for profiling in stack install?
00:46:46 <Mateon1> But the package issues seem to be gone
00:47:17 <quchen> Mateon1: --profile
00:47:36 * hackagebot thentos-cookie-session 0.8.4 - All-in-one session handling for servant-based frontends  https://hackage.haskell.org/package/thentos-cookie-session-0.8.4 (MatthiasFischmann)
00:48:13 <quchen> Mateon1: Have a look at “stack build --help”, it’s quite a useful list of flags.
00:49:19 <Mateon1> quchen: Thanks
00:51:12 <Mateon1> Ouch, my GPU just crashed for no reason.
00:53:21 <cocreature> who needs a gpu anyway
00:54:57 <ggVGc> in 10 years the question will be who needs a cpu I reckon
00:55:02 <ggVGc> well, untrue
00:55:03 <ggVGc> but I wish
00:57:36 * hackagebot genvalidity 0.1.0.0 - Testing utilities for the validity library  https://hackage.haskell.org/package/genvalidity-0.1.0.0 (Norfair)
00:57:38 * hackagebot genvalidity-containers 0.1.0.0 - GenValidity support for containers  https://hackage.haskell.org/package/genvalidity-containers-0.1.0.0 (Norfair)
00:57:40 * hackagebot genvalidity-hspec 0.1.0.0 - Standard spec's for GenValidity instances  https://hackage.haskell.org/package/genvalidity-hspec-0.1.0.0 (Norfair)
01:09:12 <fakedrake> hello
01:09:26 <fakedrake> what is the (<*>) method of applicatives called?
01:09:38 <shachaf> (<*>)
01:09:52 <dibblego> apply, spaceship, angle bum
01:09:54 <shachaf> Sometimes people say "ap", since there's a function with that name.
01:10:00 <tdammers> sequential application operator
01:10:36 <fakedrake> I ll go with spaceship thnx
01:11:01 <tdammers> the PHP crowd has also claimed "spaceship operator" though
01:11:17 <tdammers> they celebrate it like the best thing since sliced bread
01:11:48 <dibblego> it was thus named spaceship, at least as early as 2007
01:11:55 <dibblego> Haskell wins, again.
01:12:14 <tdammers> the PHP one is a bit embarrassing even
01:12:19 <tdammers> https://wiki.php.net/rfc/combined-comparison-operator
01:12:31 <dibblego> would it be any other way?
01:12:40 <tdammers> more so if you consider that a) writing it yourself is impossible without hacking the language, and b) it took them decades to come up withit
01:13:22 <tdammers> it's basically Haskell's Ord typeclass, but rather than a proper Ordering type, they use 1 / 0 / -1
01:17:37 * hackagebot elm-export 0.4.0.1 - A library to generate Elm types from Haskell source.  https://hackage.haskell.org/package/elm-export-0.4.0.1 (krisajenkins)
01:23:53 <fakedrake> in my day job writing JS, what I miss most often since I learned haskell is partial function application
01:25:09 <liste> fakedrake: _.partial (from LoDash)
01:26:24 <liste> maybe Underscore too
01:27:33 <Markus23> Dear FOSS developers! Please fully fill out our survey at http://elektra.limequery.org/625192 and a donation will go to FOSS projects. The survey is carefully crafted and helps research! Thank you! If you have any questions you can ask me.
01:27:41 <Markus23> Would love to see some answers from haskell people!
01:28:58 <fakedrake> I actually rolled my own where `fp = partial(function (a,b,c) {});` is a function so that `fp(1)(2)(3)` is equivalent to `f(1,2,3)` but it doesn't compose very well...
01:29:26 <fakedrake> because it screws with the `.length` property of the function
01:32:37 * hackagebot makefile 0.1.0.1 - Simple Makefile parser  https://hackage.haskell.org/package/makefile-0.1.0.1 (nmattia)
01:32:39 * hackagebot stache 0.1.2 - Mustache templates for Haskell  https://hackage.haskell.org/package/stache-0.1.2 (mrkkrp)
01:36:24 <Ulrar> Is there any function to get from an UTCTime to a String or Text ? I'd like to have a timestamp as a string
01:36:32 <dibblego> show
01:36:54 <Ulrar> It'll just be the timestamp ? cool, thanks
01:37:31 <cocreature> Data.Time.Format allows you to use other formattings if the show instance doesn’t do the trick
01:38:32 <Ulrar> Yeah I saw that one, but I don't understand how it works, it takes a lot of parameters
01:40:08 <cocreature> it just requires a TimeLocale for which you can use the defaultTimeLocale if that fits your needs, a format string and obviously the time you are trying to format 
01:40:28 <mtesseract> Hi
01:40:58 <Ulrar> Ha, a time locale
01:41:05 <Ulrar> yeah show won't work, that's not a timestamp
01:45:18 <cocreature> Ulrar: formatTime defaultTimeLocale "%s" should do the trick
01:45:21 <Ulrar> cocreature: So I don't understand, it takes the format string as the first parameter, a locale as the second, something as the third and the UTCTime as the fourth ?
01:46:12 <cocreature> no formatTime takes the locale as the first parameter, the format string as the second and the UTCTime as the third
01:46:32 <Ulrar> I must be looking at the wrong doc then
01:46:34 <Ulrar> thanks
01:46:44 <cocreature> https://hackage.haskell.org/package/time-1.6.0.1/docs/Data-Time-Format.html#v:formatTime
01:48:39 <Ulrar> cocreature: And I'm right thinking that the locale doesn't matter here ?
01:48:52 <Ulrar> Or are timestamps dependent somehow on the time locale ?
01:50:05 <merijn> Ulrar: Sure, not all locales format timestamps the same way
01:50:23 <Ulrar> defaultTimeLocale seems to output what I need
01:50:23 <merijn> Ulrar: i.e. are day/month/year separated with slash, dash, dot, something else
01:50:34 <Ulrar> Really ? That's weird
01:50:48 <merijn> Not too mention locale influences whether it's day/month/year, month/day/year or year/month/day
01:50:55 <merijn> Ulrar: Eh, why's that weird?
01:50:56 <cocreature> merijn: we’re talking about unix timestamps here, I’m pretty sure the locale doesn’t matter for that
01:51:09 <Ulrar> Ha yeah, we aren't talking about the same thing
01:51:26 <Ulrar> cocreature: Thanks anyway, it works !
01:51:43 <Ulrar> Compared the output with what the api is saying, it's all good
01:52:01 <merijn> Well, formatTime clearly works for things other than unix timestamps, so it seems obvious it needs locale info for those cases
01:52:42 <Ulrar> Sure, I just wondered if using the default one, which is the american one according to the doc, would be a problem
01:52:44 <Ulrar> Since I'm in Europe
01:52:52 <Ulrar> apprently not
01:53:00 <cocreature> I wonder if we have a package with locales for a bunch of countries
01:53:05 <ggVGc> except when it all of a sudden is a problem
01:53:11 <ggVGc> Ulrar: why not use the correct one_
01:53:11 <ggVGc> ?
01:53:42 <Ulrar> Is there a way to get the correct one ?
01:53:49 <merijn> cocreature: Those things usually ship with your OS, like timezone databases
01:53:58 <merijn> Ulrar: Query the locale of the machine?
01:54:21 <merijn> The correct one should always be "whatever the machine is configured with"
01:54:32 <Ulrar> Not really, the correct one is GMT +2
01:54:44 <Ulrar> Always, since that's what the API is waiting for in my case
01:55:07 <cocreature> merijn: but how do you get these as a TimeLocale?
01:57:47 <merijn> I've never had to get the locale from haskell
01:58:12 <merijn> Ulrar: "the correct one is GMT +2", for you, maybe, not necessarily for other users
01:58:22 <merijn> Ulrar: GMT+2 is a timezone, not a locale, btw
01:58:56 <Ulrar> merijn: there won't be other users
01:59:02 <merijn> Famous last words
01:59:05 <Ulrar> :)
01:59:24 <Ulrar> It's interacting with two apis for work, I'm pretty sure about that
02:01:38 <Ulrar> Now to understand how the sha1 module works
02:03:15 <Mateon1> Oh, by the way, is is possible to display a float/double in a format different than `show`'s? `show 0.01 == "1.0e-2"`, whereas I'm looking for something like `showFixed 2 0.0123 == "0.01"; showFixed 2 111.0123 == "111.01"; showFixed 2 0.015 == "0.02"` (Always 2 digits after the decimal point, properly rounded, not scientific)
02:03:39 <Cale> > showFFloat (Just 2) pi ""
02:03:41 <lambdabot>  "3.14"
02:03:41 <mtesseract> Mateon1: the formatting package might do what you want.
02:03:54 <Mateon1> Cale: Thanks
02:03:59 <Cale> (That's in the Numeric module in base)
02:03:59 <Guest35696> http://lpaste.net/169737 I have solved the puzzle after the ages of struggle
02:04:48 <Guest35696> hopefully i will remember the efficiency lessons
02:05:09 <merijn> Mateon1: Incidentally, if you want fixed precision you might be interested in Fixed instead of Float? That supports fixed precision operations
02:05:33 <t4nk473> hello, looking for some help on running the gtk2hs intro examples
02:05:41 <Cale> > pi :: Centi
02:05:43 <lambdabot>      No instance for (Floating Centi) arising from a use of ‘pi’
02:05:43 <lambdabot>      In the expression: pi :: Centi
02:05:48 <t4nk473> the onclicked, ondestroy methods are deprecated
02:05:53 <Cale> > 3.14 :: Centi
02:05:55 <lambdabot>  3.14
02:06:00 <Cale> > 3.141592 :: Centi
02:06:02 <lambdabot>  3.14
02:06:33 <liste> @index Centi
02:06:33 <lambdabot> Data.Fixed
02:07:12 <merijn> liste: There's a couple of synonyms for common precisions in Fixed
02:07:26 <merijn> > pi :: Milli
02:07:27 <lambdabot>      No instance for (Floating Milli) arising from a use of ‘pi’
02:07:27 <lambdabot>      In the expression: pi :: Milli
02:07:38 <merijn> bah, same mistake xD
02:07:49 <merijn> > 3.141592 :: Milli
02:07:50 <lambdabot>  3.141
02:07:56 <merijn> > 3.141592 :: Nano
02:07:58 <lambdabot>  3.141592000
02:08:16 <ocramz> hi there
02:08:25 <undreren> > 0.5**20 :: Nano
02:08:26 <lambdabot>      No instance for (Floating Nano) arising from a use of ‘**’
02:08:26 <lambdabot>      In the expression: 0.5 ** 20 :: Nano
02:08:41 <undreren> > 1 :: Nano
02:08:43 <lambdabot>  1.000000000
02:08:59 <undreren> > 0.5**20 :: Milli
02:09:00 <lambdabot>      No instance for (Floating Milli) arising from a use of ‘**’
02:09:01 <lambdabot>      In the expression: 0.5 ** 20 :: Milli
02:09:26 <undreren> why is there no instance of Float for Milli or Nano? What use are they then?
02:09:27 <undreren> > pi
02:09:29 <lambdabot>  3.141592653589793
02:09:34 <undreren> > pi :: Nano
02:09:36 <lambdabot>      No instance for (Floating Nano) arising from a use of ‘pi’
02:09:36 <lambdabot>      In the expression: pi :: Nano
02:11:02 <ocramz> is anyone here building projects with stack within TravisCI? it seems like travis now blocks port 443 (HTTPS), so `stack setup` fails with `FailedConnectionException2 "raw.githubusercontent.com" 443 True getProtocolByName: does not exist (no such protocol name: tcp)` and I wonder if anyone has observed this behaviour
02:11:37 <Guest35696> still have problems with some lpaste hints
02:12:07 <Guest35696> for example removing seemingly redundant if breaks the code
02:16:39 <srhb> Guest35696: Example?
02:16:47 <mikail`> Hi, I created a type-class the other day and for two types out of about seven, I noticed that those two types have the same implementation. How can I avoid this duplication?
02:17:10 <srhb> mikail`: Normalize intwo several typeclasses?
02:17:21 <srhb> mikail`: Or take the implementation outside the instances and use it in both.
02:19:14 <srhb> undreren: Because they're fixed, not floating
02:19:22 <srhb> undreren: Fixed precision that is
02:20:06 <mikail`> srhb: thanks for the ideas
02:22:53 <Mateon1> merijn: Just now noticed you message, but I need an actual double, as the underlying mathematics aren't fixed. It's part of a rendering calculation, and I need to display it on a debug bar, scientific notation being unreadable there.
02:23:06 <Mateon1> Especially at 400 FPS
02:23:51 <srhb> Mateon1: printf?
02:24:13 <Mateon1> srhb: I already incorporated Numeric.showFFloat, it works
02:24:18 <srhb> Ok :)
02:28:51 <Guest35696> srhb: one moment please
02:29:05 <Guest35696> http://lpaste.net/6737445867873107968
02:29:22 <Guest35696> trying to figure out how to use hlint now
02:29:41 <Guest35696> imho lpaste gave confusing or wrong hints
02:29:51 <srhb> Guest35696: They look right to me
02:29:59 <srhb> Guest35696: Which one are you having problems with?
02:30:08 <srhb> Guest35696: By the way, the lpaste hints are from hlint.
02:30:52 <Guest35696> so you think I have solved my first challenging haskell puzzle?
02:31:30 <srhb> An even shorter version of not (head s == head sr) is head s /= head sr
02:32:17 <Guest35696> I come from lisp, i need brackets
02:32:44 <srhb> Fine, then (head s /= head sr)
02:32:54 <Guest35696> :-)
02:33:41 <mniip> parentheses*
02:33:42 <srhb> But `if foo then True else False` is always equivalent to `foo`, and `if bar then False else True` is always equivalent to `not bar`
02:34:02 <srhb> mniip: Not in british english, afaik.
02:34:27 <Mateon1> Does there exist a plain lock type in Haskell? I can't find one on Hoogle, so do I have to use an `MVar ()`?
02:34:40 <shachaf> MVar () is standard.
02:34:40 <mniip> (parentheses), [brackets], {braces}
02:35:51 <srhb> (brackets) [square brackets] {curly brackets}
02:36:14 <tdammers> (clipped-toenails) [boxy-thingies] {facial-hair}
02:36:19 <srhb> :-)
02:36:30 <sdx23> Mateon1: there's also Control.Concurrent.Lock - wrapping around MVar ()
02:37:06 <tdammers> Mateon1: my hunch is that if you ask about locks, you're probably approaching threaded programming from the wrong end
02:37:56 <tdammers> Mateon1: rather than using low-level threading primitives like locks and such directly, you're usually better off with higher-level threading abstractions such as channels
02:38:55 <tdammers> Mateon1: you can use something like MVar () to implement locks, but usually the actual use case is thread-safe shared state; for that, proper MVars, or, better yet, STM, are more suitable abstractions
02:40:43 <irn4l> hi
02:40:46 <irn4l> good morning people
02:40:48 <srhb> irn4l: Hi.
02:40:51 <irn4l> what is this channel all about?
02:40:54 <merijn> Mateon1: What's wrong with "MVar ()"?
02:40:59 <srhb> irn4l: The Haskell programming language.
02:41:11 <irn4l> ok
02:42:31 <irn4l> im a noob can i hang out in here?
02:42:52 <srhb> irn4l: As long as you stay on topic, beginners are absolutely welcome. :)
02:50:22 <Guest35696> http://lpaste.net/6737445867873107968 i made myself familiar with hlint
02:50:32 <irn4l> lol i got banned from #biotcoin cause i said that was a fraud
02:50:46 <irn4l> they dont tryed to explain clearly to all that it isnt
02:50:48 <irn4l> they banned me
02:50:57 <quchen> Bitcoin is an example of something that is not on topic here.
02:50:59 <irn4l> what a fucking retard corrupt people is around here
02:51:16 <irn4l> and corruption?
02:51:42 <irn4l> can you guys call me troll, ban me and go away with your corrupt schemes?
02:52:22 <quchen> We don’t care about that. This channel is about Haskell, please take your gripes with others elsewhere.
02:53:35 --- mode: ChanServ set +o dibblego
02:53:39 --- mode: dibblego set +b *!*irn4l@*unaffiliated/irn4l
02:53:41 --- kick: irn4l was kicked by dibblego (irn4l)
02:55:44 <Axman6> Guest35696: welcome back! That problem you were working on yesterday is a lot harder than it looks! I decided to give it a go. I ended up needing to use ByteString instead of String to make it complete in the required time
02:55:55 --- mode: dibblego set -o dibblego
02:56:04 <Mateon1> tdammers: It's not that easy, I'm trying to render concurrently with the logic. While the renderer works on the current frame, the next one can be calculated at the same time.
02:56:22 <Mateon1> Unfortunately, I'm having an issue, seems that GLFW doesn't like being ran on a forkIO'd thread
02:56:46 <Axman6> GL things tend not to like that
02:56:47 <merijn> Mateon1: Oh, that's easy (ish?) to solve
02:57:07 <merijn> Mateon1: GL tends to use thread local state, whereas forkIO threads are not guaranteed to always run in the same OS thread
02:57:19 <merijn> Mateon1: You'll want a bound thread
02:57:29 <Mateon1> Bound thread?
02:57:31 <Axman6> forkOS might help, but sometimes it needs to run in the main thread
02:57:34 <merijn> Mateon1: See forkOS
02:57:44 <Mateon1> merijn: Sure, I will
02:57:48 <Axman6> forkOS binds a haskell thread to a specific OS thread
02:58:47 <merijn> Heh
02:58:54 <merijn> forkOS docs explicitly call out OpenGL :p
02:59:01 <Mateon1> Hm, it's getting more difficult now. I assume that calling 'forkOS' in a loop isn't good
02:59:09 <Mateon1> I need an actual separate thread
02:59:11 <merijn> Mateon1: forkOS and forkIO are pretty identical
02:59:22 <Adeon> in GHC forkOS will always create a new OS thread
02:59:28 <Adeon> quite a bit more expensive than forkIO
02:59:37 <Mateon1> Well, I just realised I need to rethink this, since forking is expensive on Windows
02:59:39 <merijn> Adeon: Really?
02:59:43 <Adeon> yes
02:59:47 <Adeon> documentation suggests this may not be the case
02:59:51 <Adeon> but I once source dived this
02:59:55 <Adeon> it will always create a new thread
03:00:15 <merijn> Adeon: So if I start with X capabilities and use forkOS I end up with X+1 executing capabilities?
03:00:16 <Adeon> well unless they changed it in 7.8_
03:00:20 <Adeon> +
03:00:25 <Adeon> yes I think so
03:00:49 <Adeon> well I'm not sure if it'll affect capabilities in that way, the interactions may be subtle
03:01:11 <Mateon1> Unfortunately forkOS doesn't fix the GL problem. GLFW uses StateVars, IIRC
03:01:30 <Adeon> the thread in forkOS will be a bound thread so if you keep all GL stuff in that same thread everything will be a-ok
03:01:37 <Adeon> main thread will also be bound thread
03:01:43 <Adeon> there's also a function called runInBoundThread
03:01:57 <Adeon> which I think is implemented by checking if current thread is a bound thread, if not then spawn a new thread with forkOS and run in that
03:02:50 <Mateon1> Well, that's bad
03:02:55 <Mateon1> Still, this should be working correctly
03:03:00 <Mateon1> But isn't for some reason
03:04:01 <Mateon1> In `main`, I call a function to initialize GLFW and create a window, and in the game loop I call forkOS with the renderer, properly locked (I had to check :P)
03:30:27 <caleb> hi
03:41:01 <mettekou> Say I have an algebraic data type with a data constructor which takes arguments which can combine into a value of that same data type. The uniplate approach only allows me to operate on arguments of the same type. Is there a different approach which accomodates generating subterms from arguments to a data constructor which are of different types?
03:41:30 <zedik> Hi all. How to define data type for a number consisting of a fixed number of digits? E.g. for 1467368183 ? I need to match this data type exactly to this format (which is Unix time)
03:42:02 <mniip> unix time? fixed number of digits?
03:42:05 <mniip> what
03:42:22 <Rembane> zedik: Is it milliseconds since epoch?
03:42:24 <mniip> mettekou, can you provide an example of what you have in mind?
03:42:46 <zedik> Rembane: yes
03:42:58 <Rembane> zedik: Wouldn't an Int suffice?
03:43:31 <zedik> Rembane: there are other Int 's possible in the file, i need to skip them
03:45:06 <mettekou> mniip: Case in point is a data type for terms in a language which uses the bound library to deal with variable binding and substitution. This means that 'Term' is not defined recursively for binder bodies, instead these are wrapped in a 'Scope'. Concretely for untyped lambda calculus: data Term n = Variable n | Abstraction String (Scope () Term n) | Application (Term n) (Term n).
03:45:37 <mettekou> The components of 'Abstraction' can be used to build a 'Term String' by using 'instantiate1' from bound.
03:46:59 <Rembane> zedik: How do you know if an int in this file is a Unix timestamp?
03:47:23 <amaslov> 
03:50:04 <mniip> hmm
03:53:15 <Mr_Phreak> hello
03:53:43 <liste> hello Mr_Phreak 
03:56:07 <Mr_Phreak> i was wondering , i want to learn programming so what is the minimun skill level to start freelancing 
03:57:02 <undreren> Mr_Phreak: The easy answer is "That depends." The hard answer is rather complicated.
03:57:10 <mniip> this is the haskell channel, consider asking in ##programming perhaps
03:57:32 <Mr_Phreak> yeah right XD
03:58:56 <Mr_Phrea1> ok what about pentesting
03:59:04 <magneticduck1> Mr_Phreak: it's always a sort of threshold -- some percent of people will accept your offters, and some percent of those people will notice that you're hideously underqualified
03:59:19 <magneticduck1> so there are two things to do: you can either learn more, or find dumber customers
03:59:37 <magneticduck1> both of those things increase your threshold of sucess
04:00:06 <undreren> Please don't choose the latter
04:00:10 <undreren> ;)
04:00:17 <magneticduck1> from how you're staging your questions, I'm going to guess that you should concentrate more on learning and less on finding applications for your skills
04:00:27 <magneticduck1> ideally, you should always be focusing on learning
04:01:02 <undreren> A good idea is to make something, something not too complicated, but which will never the less show you what you still need to learn.
04:01:41 <magneticduck1> for instance, you could write a system that indexes IRC channel /topic's and searches them so you can find good places to ask your questions
04:20:24 <undreren> ^ I don't know if you meant to, but you sound a bit sarcastic
04:23:13 <undreren> magneticduck1: What I said above
04:29:37 <mtesseract> I would like to be able to write something like "convert :: DerivedUnit baseUnit unit => unit -> unit -> Rational" in order to detect an attempt to e.g. convert liters to grams fail at the type level. I don't see how that can be done. I think it would be easy to implement something like "convert :: DerivedFromLiter unit => unit -> unit -> Rational" and repeat the same for DerivedFromGram, etc. But what I am
04:29:39 <mtesseract> trying to achieve is to use a constraint (DerivedFrom ...) that expects as first argument a unit *value*, not a type. Can this be done?
04:31:25 <mniip> value?
04:32:52 <mtesseract> A value representing a specific unit, e.g. UnitLiter or UnitGram.
04:33:06 <mniip> mtesseract, why not just index your 'unit' type with an extra type argument
04:37:29 <mtesseract> mniip: In order to encode the base unit from which it is derived? I have been thinking about it, but I guess it would be less verbose in the long run if it was possible to keep the Unit type as a type of kind *. Also: I would like to use typeclasses anyway for some  of the conversion functionality. I think it can be done in a safer manner (if possible, that is) using type class constraints.
04:43:23 <kryo`> hi
04:43:42 <kryo`> does takeWhile in the Vector library give a slice or a copy?
04:43:56 <kryo`> the doc's arent exactly clear
04:44:01 <kryo`> take gives a slice
04:44:45 <Axman6> it's almost certainly a slice. 99% of the time you shouldn't care though
04:45:16 <magneticduck1> kryo`: it seems to say 'without copying'
04:45:45 <Axman6> unless you have very large vectors you won't want to hold onto, in that case, you should explicitly make a copy with force
04:46:12 <kryo`> I want to hold on to the vectors, actually
04:47:45 <kryo`> why does mut_arr_ptrs_frozen show up in my heap profile when i'm working with immutable vectors a lot? I assume it does something in the background with thawing and freezing the vectors, right?
04:52:08 <Axman6> yeah a lot of the vector functions use mutation behind the scenes, and should often be able to fuse operations so you only allocate the minimal number of vectors
04:52:48 <Axman6> well, IIRC they mostly use stream fusion, and the unstream function uses mutation to create the result vector
04:53:17 <kryo`> any idea how i can get rid of mut_arr_ptrs_frozen? It takes up entirely too much memory in my case and I thougt I'm strict enough on my vectors.
04:53:51 <Axman6> well, the memory it's taking up is the memory being allocated to produce your vectors
04:54:22 <kryo`> but it doesn't go away after my data structure is created
04:54:31 <kryo`> strangely
04:55:10 <Axman6> is that because you're (possibly lazily) holding onto a reference to a large vector?
04:55:19 <Axman6> feel free to share the code if you can
04:59:00 <kryo`> Axman6 http://lpaste.net/169747
04:59:02 <kryo`> but it's long
05:02:46 <kryo`> the relevant bit is the mergeTriesWith function
05:04:50 <Axman6> there's no need to use ! in each case of the function btw, it only needs to be forced once
05:05:46 <Axman6> things like V.head ra are likely to hold onto references to ra until forced
05:07:54 <Axman6> perhaps you could try forcing the values in the tuples in merge
05:08:09 <Axman6> I'd need to play with the code to know more though
05:08:25 <Axman6> kryo`: get GHC 8 and use -XStrict =)
05:08:49 <Axman6> I don't suppose you can use Unboxed vectors?
05:10:38 <kryo`> Axman6 I can't use unboxed vectors, sadly
05:10:57 <kryo`> because i want to have the genericity over my stored datatype
05:11:17 <kryo`> GHC8 with Strict would actually be a cool idea
05:11:21 <kryo`> is it stable enough ?
05:11:31 <Axman6> sure... I've never used it though
05:11:58 <kryo`> I would love to try it 
05:12:07 <Axman6> go for it =)
05:12:41 <Axman6> you can use https://www.stackage.org/nightly-2016-07-13 if you want to make life easier for yourself
05:12:48 <Axman6> got to go, good luck!
05:14:19 <kryo`> Will try
05:14:21 <kryo`> thx
05:15:25 <kryo`> changing (common, nd) to nd `seq` (common, nd) seems to have helped
05:15:30 <kryo`> but I have to run the profiler again
05:15:46 <kryo`> (in line 79)
05:15:52 <srhb> kryo`: Do you have a test case that's executable?
05:16:50 <kryo`> srhb not really
05:17:05 <kryo`> only a large dataset that I'm working on for my thesis
05:17:16 <srhb> kryo`: Oh well.
05:38:44 <erisco> EvanR, I realised this morning that syntactic equality is not necessary for the language either
05:43:21 <erisco> EvanR, d'oh, I have to retract that
05:44:27 <erisco> you can inductively define a syntactic equality relation but you then have no way to use it in the desired way
05:44:40 <erisco> without having the very equality trying to be avoided
05:46:34 <erisco> why in RPN are arguments not reversed… perplexing
05:52:46 <hpc> erisco: you mean as in (2 1 -) = 1?
05:53:01 <erisco> yes
05:53:47 <hpc> dunno, i like it as (2 1 -) = -1 too
05:55:12 <erisco> full reverse pn
05:57:25 <zedik> Hi all. How to define the type for a 5-digit telephone number?
05:57:41 <erisco> oh I'm in the wrong channel  *blush*
05:57:51 <hexagoxel> is there any documentation on how to manage hs-boot files in cabal?
05:58:00 <erisco> zedik, (Int, Int, Int, Int, Int) is one option
05:58:17 <tdammers> I'd go with [Char]
05:58:33 <zedik> erisco: but it will be a tuple?
05:58:56 <tdammers> or, if you have to, data PhoneKey = PhoneKey0 | PhoneKey1 | ... PhoneKeyHash | PhoneKeyStar, and then [PhoneKey]
05:59:04 <erisco> zedik, do you wish the length of 5 to be part of the type?
05:59:08 <Ulrar> I have a function returning an IO something that I need mapped on a list. It works fine but I end up with a list of IO somethings, is there a way to map <- or something ?
05:59:10 <mniip> PhoneKeyOctothorpe*
05:59:18 <tdammers> enforcing number-of-digits at the type level is almost certainly not a good idea
05:59:27 <mniip> :t mapM -- Ulrar
05:59:28 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
05:59:52 <zedik> erisco: yes. i need to read a file line by line and i create the data type for every record. the first entry in each line is a 5 digit tel. number.
05:59:58 <mniip> :t mapM `asAppliedTo` putStr
05:59:59 <lambdabot> Traversable t => (String -> IO ()) -> t String -> IO (t ())
06:00:29 <zedik> erisco: if there are 3 digits I need it to be anotnher type of record
06:00:47 <erisco> zedik, well, your justification doesn't seem to support the necessity of having the length of 5 be part of the type
06:01:00 <erisco> zedik, as tdammers suggested, how about [Char]? or Text?
06:01:14 <hpc> a 5 digit phone number? are you from the past?
06:01:23 <Ulrar> mniip: Not sure I understand, let me find the doc
06:01:25 <hpc> :P
06:02:30 <hexagoxel> i guess i just extra-source-files: the Foo.hs-boot (?)
06:02:42 <zedik> erisco, tdammers:  I see.. thanks! I need to think ..
06:03:26 <Ulrar> mniip: works great ! Thanks a lot
06:03:35 <Ulrar> I wasn't looking in Control.Monad, I admit
06:11:48 <ironChicken> any suggestions on how to create an array of pointers to arrays (of doubles) that i can safely marshal over the FFI? i.e. that the foreign code can then safely de-reference?
06:15:40 <merijn> ironChicken: Same way you do in C? Malloc an array and fill it with pointers to malloced arrays of doubles?
06:15:47 <merijn> "Ptr (Ptr CDouble)"
06:17:53 <Denommus> anyone here used MFlow?
06:32:17 <sbrg> I think I read an article where some prominent haskeller was doing sometihng where he replaced the default print functionality of the ghci repl, but I can't for the life of me remember where I read it. Does anyone know what I'm referring to?
06:34:09 <ironChicken> merijn: ok, yes. i was wondering if there was a package that does this, but maybe it's not so scary
06:37:54 <RyanGlScott> sbrg: I'm not sure what article it was, but it's probably using the -interactive-print feature: https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/ghci.html#using-a-custom-interactive-printing-function
06:38:08 <sbrg> yep -- I just found it, thanks though
06:38:16 <RyanGlScott> What was the article, then?
06:38:35 <sbrg> no I mean I just found those same docs, heh
06:38:42 <sbrg> Couldn't find the article
06:40:49 <merijn> ironChicken: There's a bunch of list to array marshalling stuff
06:41:06 <merijn> ironChicken: Foreign.Util.Marshal or something like that
06:41:38 <RyanGlScott> http://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-Marshal-Array.html#v:withArray is my goto
06:44:06 <ironChicken> merijn, RyanGlScott: i did try that, but i was getting garbage in the foreign code
06:44:20 <merijn> ironChicken: Then you did it wrong ;)
06:44:27 <ironChicken> yes, that's right
06:44:40 <merijn> Note that withArray becomes invalid after the foreign call returns
06:44:46 <merijn> you can't store those pointers
06:44:58 <ironChicken> so now i have some assurance that it's the right approach i'm going to try harder
06:45:21 <RyanGlScott> ironChicken: By any chance, are you using array members of a struct?
06:45:30 <ironChicken> no
06:45:54 <RyanGlScott> OK. I ask since there's some gotchas to be encountered when dealing with them.
06:50:31 <magneticduck1> am I reading this wrong? https://github.com/GaloisInc/cereal/blob/master/src/Data/Serialize.hs#L588
06:50:55 <magneticduck1> or does the cereal library actually handle types with up to 2^64 constructors?
06:51:50 <ertes> ironChicken: i tend to use Data.Vector.Storable (from the 'vector' library) as soon as i have to deal with arrays and C
06:52:13 <hexagoxel> does ghci handle hs-boot stuff correctly?
06:52:51 <hexagoxel> i seem not to be getting errors for the .hs where i have a .hs-boot
06:53:05 <ertes> magneticduck1: you're reading that right
06:54:58 <magneticduck1> ertes: so that library has an error message specifically for the case when a datatype has more than 2^64 constructors
06:55:27 * hexagoxel asks in #ghc
06:55:53 <ertes> magneticduck1: to me it looks like a "here's a bug!" kind of error
06:56:41 <bernalex> does ghc support that many constructors? I would assume not.
06:57:17 <ertes> magneticduck1: after failing to find the right word-size type, it still has a branch left, and one sensible thing at that point is to 'error'
06:57:29 <ertes> bernalex: i don't see why not – in principle
06:57:55 <magneticduck1> you certainly wouldn't be able to write them anywhere
06:57:58 <bernalex> ertes: I thought the reason tuples stop at N is because of a limit in the amount of constructors.
06:58:16 <ertes> bernalex: more likely in the number of fields
06:58:38 <ertes> is there still such a limit?
06:58:39 <bernalex> maybe. let me try.
06:58:48 <ertes> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
06:58:49 <lambdabot>     A 301-tuple is too large for GHC
06:58:49 <lambdabot>       (max size is 62)
06:58:49 <lambdabot>       Workaround: use nested tuples or define a data type
06:59:19 <magneticduck1> that has nothing to do with a limit on the number of constructors a datatype can have
06:59:25 <Freundlich> It should be possible to define your own tuples with more elements.
06:59:28 <magneticduck1> also wow, a 62 tuple
06:59:40 <Freundlich> It's just that every tuple constructor is distinct so the predefined ones have to stop somewhere.
06:59:50 <bernalex> ertes: you appear to be right
06:59:56 <geekosaur> there was a point where you could define a 63-tuple but it caused a compiler core dump
07:00:10 <mniip> why tho
07:00:18 <bernalex> @let data D a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__ k__ = D a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__ k__
07:00:19 <lambdabot>  Defined.
07:00:27 <bernalex> works fine
07:00:48 <bernalex> so it's not to do with the amount of arguments either.
07:00:54 <dot_asp> Hello. How do I set up a condition in haskell/ghc so that it terminates itself when there's a leak and then report back a profile to me?
07:00:59 <RyanGlScott> Indeed, the max tuple size is totally arbitrary. http://git.haskell.org/ghc.git/blob/45d8f4eb2bf2fcb103517d064e7ba1e491a66f4c:/compiler/main/Constants.hs#l14
07:01:21 <ertes> mniip: you shouldn't use such a type anyway, because you end up with basically a Vector, and every change copies it to update a single pointer or unboxed value
07:01:52 <bernalex> RyanGlScott: I would not say that it is arbitrary.
07:02:04 <RyanGlScott> Well, the docs state as much :P
07:02:17 <bernalex> RyanGlScott: "Including one more declaration gives a segmentation fault", so the decision to not include it sounds rather practical to my ears.
07:02:41 <RyanGlScott> What are you quoting?
07:02:48 <bernalex> the GHC source code.
07:03:10 <RyanGlScott> Oh, this is in a different place: http://git.haskell.org/ghc.git/blob/45d8f4eb2bf2fcb103517d064e7ba1e491a66f4c:/libraries/ghc-prim/GHC/Tuple.hs#l170
07:03:13 <bernalex> it is likely arbitrary in that they haven't investigated why it segfaults at that particular number.
07:03:32 <ertes> does it still segfault?
07:03:32 <Freundlich> That sounds really lame.
07:04:14 <bernalex> ertes: I don't know why it segfaults, and I haven't the time to compile GHC right now. but it's not to do with the number of parametres, I don't think. since putting one of the longer ones in GHCi works fine.
07:04:20 <RyanGlScott> It should be noted that comment was added sometime before 2008, so it may not be valid anymore.
07:05:03 <magneticduck1> now that I'm going through this library, https://github.com/GaloisInc/cereal/blob/master/src/Data/Serialize.hs#L668 seems interesting
07:05:06 <RyanGlScott> Since it was present in http://git.haskell.org/ghc.git/commit/4cf0bb2b9cb6192a212ab74aba3513ba289a47d9
07:05:13 <magneticduck1> I wonder what other ways there are to attach arbitrary information to a type
07:05:59 <magneticduck1> (in this case the SumSize typeclass is used to distinguish types whose size is known as a Word64)
07:06:00 <ertes> magneticduck1: i often use reflection to attach information to types
07:06:11 <magneticduck1> do elaborate?
07:06:31 <ertes> magneticduck1: the traditional term is "implicit configurations", and the library is:
07:06:34 <ertes> @package reflection
07:06:34 <lambdabot> http://hackage.haskell.org/package/reflection
07:07:31 <ertes> reify x (\(_ :: Proxy x) -> …)  -- within the parentheses the *type* x can reflect the *value* x
07:08:12 <magneticduck1> that's somewhat alarming
07:08:41 <magneticduck1> I'll read the paper, right now it just sounds like a terrible hack ^^
07:08:50 <ertes> someGroupAlgo :: (Reifies g Group) => MyType g -> MyType g -> MyResult g  -- the *group* all of this runs in is not value-bound, but type-bound, so it makes sense that it is a type argument
07:09:25 <ertes> it's a terrible hack internally (to make it efficient), but the theory is sound =)
07:10:05 <magneticduck1> the 'configuration problem' sounds like what I'd use a state monad for
07:10:19 <ertes> nope, you'd more likely use a reader monad
07:10:30 <magneticduck1> oops, that's what I meant to say
07:10:34 <ertes> (or most likely just a plain argument)
07:13:29 <ertes> note that the original paper is dated and makes it look terribly complicated, but it needs to roll out the entire theory for everything to make sense…  the 'reflection' package uses none of that, but really just a quick hack to make it both efficient and convenient
07:14:18 <maerwald> ertes: for GHC
07:14:38 <cocreature> yeah think about the mystical other haskell compilers everybody uses
07:14:41 <maerwald> it also has the real implementation afair
07:14:42 <ertes> maerwald: let's be honest, half of hackage is "for GHC" =)
07:15:52 <buglebudabey> does anyone have a good resource of papers related to haskell/ghc/etc. they'd like to share :)
07:16:13 <buglebudabey> other than stephen diehl and ghc reading list
07:17:00 <ertes> buglebudabey: i just look at papers linked from haskellwiki or wikipedia most of the time
07:17:15 <ertes> also i mostly prefer not to read papers, if i can avoid it
07:19:19 <maerwald> ertes: https://github.com/ekmett/reflection/blob/master/slow/Data/Reflection.hs
07:20:40 <ertes> maerwald: yeah, but i'm pretty sure nobody uses that one =)
07:20:51 <maerwald> that wasn't my point
07:21:12 <hexagoxel> dot_asp: closest thing is setting heap max via RTS and then investigate manually via -hy/..
07:21:42 <maerwald> you said "the reflection package uses none of that", which I think isn't accurate, since there's a portable implementation as well that doesn't really on GHC
07:22:12 <dot_asp> thanks hexagonel
07:23:34 <maerwald> anyway, I found reflection (except for the 'Given' class which is considered rather unsafe) not that useful. You still carry around an explicit proxy parameter.
07:24:20 <ertes> maerwald: usually you don't:  myModularArithmeticAlgo :: Mod n -> Mod n -> Mod n
07:25:00 <maerwald> I don't know what that type sig is supposed to tell me
07:25:00 <ertes> maerwald: it's useful, when you pass around something that is also an argument to the types of other arguments
07:25:04 <ertes> like in this case the modulus
07:25:14 <maerwald> where are you using reify?
07:26:11 <ertes> maerwald: i forgot the context:  f :: (Reifies n Integer) => Mod n -> Mod n -> Mod n  -- the modulus argument is not passed explicitly, but comes with the Reifies dictionary
07:26:49 <ertes> you use reify where you want to actually apply the modulus:  reify 101 (\(_ :: Proxy n) -> print (f (5 :: Mod n)))
07:27:07 <ertes> or rather:
07:27:17 <ertes> reify 101 (\(_ :: Proxy n) -> print (f 5 7 :: Mod n))
07:29:37 <ertes> fun fact: in this particular case you can even skip the 'reify' machinery altogether, because GHC has its own =)
07:29:45 <ertes> print (f 5 7 :: Mod 101)  -- works
07:30:10 <ertes> works for Integer and String
07:31:19 <int-e> huh.
07:31:32 <buglebudabey> ertes what do you prefer to read, if not papers?
07:32:57 <ertes> buglebudabey: in descending order of preference:  haddocks, blog posts and wiki pages, papers  -- try in order, until you have the level of detail you need
07:33:04 <maerwald> ertes: maybe make a pull request with a useful example, the ones in the repo are all weird
07:33:20 <buglebudabey> ertes got any good blog recommendations?
07:34:54 <ertes> maerwald: i posted this a while ago: http://lpaste.net/161348
07:35:20 <ertes> you may find it useful
07:35:51 <ertes> it computes the fibonacci formula using exact arithmetic via a number field
07:36:28 <ertes> the number field is constructed using the square root of some 'r', and that 'r' is passed as a type
07:41:03 <ertes> buglebudabey: i don't have a list =/
07:41:15 <buglebudabey> ill take any off hand :P
07:43:42 <ertes> buglebudabey: any topics you find particularly interesting?  then i can take a look at my browser history
07:44:51 <buglebudabey> anything concerning haskell really, i like learning about new topics but also ones that i can apply. i consider myself on the verge of intermediate of that helps, so anything nicely outside that comfort zone. 
07:45:00 <buglebudabey> if that helps*
07:47:27 <co-dh> Hello, is it a good place to ask category theory question here?
07:47:31 <ertes> buglebudabey: i'd say my most cited post is this one: https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
07:48:02 <ertes> buglebudabey: it's rather on the theoretical side, but does give some design advice for coders, too
07:48:19 <buglebudabey> nice, i'll take a look at that one, thanks
07:49:27 <co-dh> any way , I'll just ask here: is kan extension just functor divide? given two function F, and G, you divide F by G, you got Kan extension.
07:51:00 <dolio> Kind of. If 'multiplication' is composition.
07:51:31 <dolio> I'm not sure that's a good way of thinking about it, though.
07:53:35 <co-dh> @dolio why? too many simplification?
07:53:35 <lambdabot> Unknown command, try @list
07:53:55 <co-dh> s/many/much
07:55:11 <dolio> Well, I'm not sure what thinking about it as 'division' is going to help you with. Also, there is another set of things called Kan lifts, which could also be called 'division' because it is completing a composition triangle in a different way.
07:56:00 <dolio> Kan extensions have two arrows going out of the same place, and you add an arrow between their end points. Kan lifts have to arrows going into the same place and you add an arrow between their starting points.
07:58:34 <dolio> Also it's not equational. There's a directional component from the composition to the third thing.
07:58:58 <dolio> So it's not like division in a field. I guess it's more like integer division.
08:00:58 <dolio> p * (q `div` p) < q
08:01:07 <dolio> Or, <=.
08:01:17 <co-dh> :Dolio It's like division for me, but you have left division and right division. because the multiply ( composition ) is not ambient ( interchangable)
08:06:06 <magneticduck1> co-dh: commutative?
08:09:25 <co-dh> @magneticduc1 yes. sorry for my english.
08:09:26 <lambdabot> Unknown command, try @list
08:09:45 <magneticduck1> (I think that generally when you have a non-commutative but associative operator, its inverses are just expressed by operations with inverse values -- nobody's going to use \ and / ^^)
08:16:48 <buglebudabey> co-dh you don't need to put the @ before a person's name
08:17:59 <co-dh> buglebudabey: thanks
08:18:08 <buglebudabey> any time
08:22:52 * hackagebot tasty-program 1.0.5 - Use tasty framework to test whether a program executes correctly  https://hackage.haskell.org/package/tasty-program-1.0.5 (JanStolarek)
08:27:52 * hackagebot rethinkdb 2.2.0.6 - A driver for RethinkDB 2.2  https://hackage.haskell.org/package/rethinkdb-2.2.0.6 (codedmart)
08:30:54 <Xe> is there a way to compile a haskell shared object with all of its haskell runtime dependencies statically linked into the resulting shared objec?
08:33:09 <glguy> Xe: yes, but the process depends on your platform
08:33:23 <Xe> glguy: normal linux x86_64
08:33:56 <Xe> http://ix.io/13p5
08:34:07 <Xe> this is the raw ghc build step i am using so far
08:35:05 <co-dh> Xe: I'm not an expert on this, but here is a question: if two shared object A, B both statically linked C, which has a global state in C, you end up to have two global state of C.
08:35:47 <Xe> co-dh: i am basically wrapping pandoc html -> markdown for being called from ruby
08:36:15 <Xe> i just want html2markdown.so to be statically linked with all of the relevant GHC rts and the like
08:36:25 <HallaSurvivor> is there a way to tell haskell that my list is of odd numbers?
08:36:28 <Xe> so that the ruby program loads it and it's done
08:36:29 <lambdafan> so, I know how to use VBBBiewPatterns in this way let f x@(length -> 2) = x
08:36:39 <lambdafan> so, I know how to use ViewPatterns in this way let f x@(length -> 2) = x
08:36:44 <tdammers> Xe: frankly, my go-to solution for this stuff is to just run the thing in a subprocess
08:36:49 <co-dh> Xe: I see, you should have no problem.
08:36:54 <Xe> HallaSurvivor: you need dependent types for that, try liquidhaskell or even idris
08:36:57 <tdammers> Xe: if performance is not critical, that's a much easier path to pursue
08:36:59 <Xe> co-dh: how do you do it though?
08:37:00 <HallaSurvivor> map ((/2) . (-1)) . filter odd . map (^2) $ [1..] returns an error, since there's no way to verify (/2) works
08:37:01 <co-dh> Xe I agree with tdammers
08:37:12 <lambdafan> but is there a way to do a boolean test, say testing the length of the list, anf if true return the list?
08:37:34 <lambdafan> let f x@((length > 2) -> True) = x
08:37:37 <Xe> tdammers: Yes, I know the value of using a subprocess, it is less time to redesign this rails app to use subprocesses for things than it is to just have 1 function call and _be done_
08:37:42 <lambdafan> like that, but in a way that makes sense
08:37:52 * hackagebot lifted-protolude 0.1.6 - A sensible set of defaults for writing lifted custom Preludes.  https://hackage.haskell.org/package/lifted-protolude-0.1.6 (parsonsmatt)
08:37:59 <HallaSurvivor> Xe, then what's the cannonical way to solve the problem with the code I just posted
08:38:23 <Xe> HallaSurvivor: i don't think GHC is that smart
08:39:00 <HallaSurvivor> So would one wrap everything in a cast?
08:40:16 <dolio> The problem is that `odd` works on integral things, but (/2) works on fractional things.
08:40:26 <tdammers> Xe: the thing is, it's not "1 function call and be done"; it's "write a library, FFI-wrap it into an .so, wrap the .so such that you can use it from within Ruby, hook it into your Rails project, and also figure out all the marshalling between Haskell, C, and Ruby"
08:40:28 <dolio> So use `div` instead.
08:40:42 <tnks> if a library has not exposed an Internal module, is there any way to get ghc to expose it with the caveat of "at your own risk"
08:41:04 <tnks> I /could/ make my own abstractions, but sometimes, the data is right there, just laughing at you.
08:41:16 <Xe> tdammers: it is taking a C string with the HTML input and returning markdown output as C strings
08:41:32 <tdammers> Xe: yes, but so is the subprocess
08:41:51 <HallaSurvivor> dolio, thanks! I'm still a bit upset there's no way to tell the typechecker about the list being odd...
08:41:59 <Xe> tdammers: can you please tell me what I want to do or stop talking to me?
08:42:01 <HallaSurvivor> are there any other dependently typed languages you all would recommend?
08:42:10 <H13> how many of them are there
08:42:26 <co-dh> HallaSurvivor: How about agda? 
08:42:31 <dolio> What would the type checker knowing the list only has odd things in it acomplish?
08:42:32 <H13> the most general-purpose one that I am aware of is idris
08:43:08 <HallaSurvivor> co-dh, do you know if agda works well with vim yet?
08:43:22 <hpc> agda is almost general-purpose, but it has no IO in the standard library (last I checked anyway)
08:43:25 <tdammers> Xe: I pick option two.
08:43:26 <Xe> HallaSurvivor: i've had luck with idris personally
08:43:37 <co-dh> HallaSurvivor: You build natural number in the type system, and build odd number as Odd = S Zero | S S Odd
08:43:44 <co-dh> and then build a list of odd
08:43:56 <hpc> you can foreign import IO, and there's a native IO type that you can lift foreign IO into, and then everything you write has to come from haskell packages
08:44:32 <co-dh> HallaSurvivor: never tried vim with agda. You can use spaceemacs, it's really very similar to vim. just a little bit fat.
08:46:55 <HallaSurvivor> great! Thanks everyone, dependent types look really cool. I really didn't need a new obsession, haha
08:48:33 <dolio> I don't think dependent types are a necessary or very nice 'solution' to this situation.
08:49:57 <ertes> HallaSurvivor: practically speaking i would just write tests
08:50:56 <ertes> switching to a different language or pull up the whole pseudo-dependent type machinery in haskell is probably not worth the trouble
08:51:06 <ertes> s/pull/pulling/
08:52:59 <ertes> if you really need that type of guarantee, an easy way out is to have two types, Even and Odd, and switch between them:  half :: Even -> Either Even Odd
08:53:59 <ertes> (or rather Even -> Either Odd Even, so that you can use monadic chaining to divide by powers of 2)
08:54:11 <ertes> half >=> half >=> half  -- divide by 8
08:56:47 <ertes> also note that divMod is a non-boolean-blind variant of testing for 'even' and branching with halves
08:57:53 * hackagebot smsaero 0.6.1 - SMSAero API and HTTP client based on servant library.  https://hackage.haskell.org/package/smsaero-0.6.1 (NickolayKudasov)
08:58:32 <glguy> Xe: Doing this on Linux will require you to recompile GHC with -fPIC so that the RTS and FFI static libraries are PIC and then will require manual calls to the linker to pull everything together
08:58:55 <glguy> Xe: I had to do that for my Lua debugger: https://github.com/GaloisInc/galua
09:00:48 <HallaSurvivor> ertes, I'm not switching just to solve this problem, haha! This was a completely mock problem I made up because I was curious how haskell would handle it
09:01:25 <HallaSurvivor> Now I'm interested in dependent types, so I'm going to read about them. They aren't going to replace haskell (probably). I just think they're a really elegant solution to the problem I posed
09:01:56 <hpc> there's plans for haskell to gain dependent types in the future
09:02:11 <hpc> though it's a long way off, even with the rapid pace that haskell develops at
09:04:14 <bernalex> maybe we could at some point write agda in haskell. that would be interesting.
09:05:01 <hpc> is it not already?
09:05:05 <hpc> @hoogle agda
09:05:08 <lambdabot> package agda-server
09:05:08 <lambdabot> package Agda
09:05:08 <lambdabot> package Agda-executable
09:05:21 <ertes> HallaSurvivor: i do emulate dependent types from time to time when it's useful (i use reflection a lot, and once in a while i find myself using singletons), but not so much for correctness
09:05:38 <bernalex> hpc: I mean interchangably via some syntax thing. or is that actually possible?
09:05:55 <hpc> ah
09:06:04 <hpc> agda can foreign import haskell
09:06:11 <ertes> HallaSurvivor: i use them for API modelling, because they allow me to have types that are closer to the semantics
09:06:24 <hpc> but afaik there's not something like C's inline assembly where you can just plop haskell in there
09:08:39 <ertes> bernalex: you can mix agda and haskell on the module level, but it's not that useful in practice (can't sensibly share haskell's tooling and bind to libraries automatically), and agda's execution model is underspecified (the MAlonzo backend just "does whatever haskell does")
09:09:03 <bernalex> ertes: I would have thought the latter was an advantage in this instance
09:09:29 <ertes> maybe, but consider what happens when you compile agda to idris
09:09:34 <ertes> suddenly your code no longer works
09:10:01 <ertes> (there is no idris backend, but imagine a backend that "does whatever idris does")
09:12:58 <bernalex> that's not really an issue if you want to do agdaskell.
09:15:33 <ertes> bernalex: imagine haskell's evaluation strategy were specified as "whatever the compiler says"…  that's pretty much what MAlonzo does, because as a programming language agda is underspecified
09:15:55 <bernalex> ertes: I still don't see the problem for agdaskell.
09:15:58 <maerwald> ertes: haskell doesn't have an execution model afaik
09:16:12 <bernalex> or at least not GAHC.
09:16:31 <hpc> haskell has a little bit of one via the apis it says have to exist
09:16:38 <hpc> but it has a well specified evaluation model
09:17:04 <maerwald> but the execution and the RTS are all "GHC-specified"
09:17:21 <hpc> what ertes is saying is imagine if ghc goes "eh, what if haskell was actually strict" and was totally within spec to do so
09:17:21 <ertes> maerwald: sorry, i meant evaluation model
09:18:22 <bernalex> hpc: performance would skyrocket!
09:18:36 <ertes> at least it would keep the CPU busier =)
09:19:18 <geekosaur> well, there is -XStrict :p
09:19:33 <geekosaur> (and lo, it breaketh the known universe...)
09:19:53 <hpc> geekosaur: get that through the prime committee and then we'll talk :D
09:20:50 <bernalex> the ' committee will likely last a few April Fools yet.
09:21:28 <geekosaur> embedded agda sounds like a more prime-ish AF :p
09:21:40 <hpc> while you are at it, see about getting data Bool = True | False | FILE_NOT_FOUND
09:21:44 <sean_1> Hey guys, so I've been enjoying and learning Haskell, currently on week #9 of the Yorgey course (cis 194) and was wondering: Do I really have to do the NICTA course afterward? My time is sort of running short and I sort of intended to work more with Haskell on other stuff after finishing cis 194. I'm following this thing: https://github.com/bitemyapp/learnhaskell
09:22:45 <maerwald> sean_1: personally, cis was the only "course" I did, but courses are not the only way to learn about stuff
09:23:02 <maerwald> you might just start a toy project and see where stuff gets difficult
09:23:14 <maerwald> then look for solutions, then realize have to learn transformers or whatnot
09:23:18 <maerwald> that's usually how it goes
09:23:39 <sean_1> maerwald: Yeah exactly. I was considering doing the "final project" Yorgey had his students do, probably a ray tracer
09:24:14 <sean_1> I figured if I ran into any issues I could look more into Haskell's other powers if I needed something
09:24:28 <tnks> sean_1: the book is good for getting toes wet in pragmatics.
09:24:40 <maerwald> sean_1: there's actually too many of them, so I wouldn't worry about not knowing all the solutions that are out there
09:24:49 <ertes> @let strictCycle xs0 = foldl' (\xs x -> x `seq` xs ++ [x]) (strictCycle xs0) xs0
09:24:51 <lambdabot>  Defined.
09:24:54 <tnks> the courses are a good supplement if you want more exercises to supplement what's in the book.
09:25:17 <ertes> > strictCycle "Hello world! "
09:25:19 <lambdabot>  *Exception: Black hole formed in CPU
09:25:24 <sean_1> maerwald: heh, I figured. Thanks you guys.
09:25:42 <quchen_> Huh, in CPU?
09:25:44 <hpc> ooh that's new
09:25:47 <quchen_> Is that the new <<loop>>?
09:25:55 <hpc> > let x = x in x
09:25:59 <lambdabot>  mueval-core: Time limit exceeded
09:26:00 <maerwald> I don't know if we have a useful collection of "haskell design patterns", since usually a lot of people misinterpret that term and say "haskell does not need design patterns", which is quite an odd thing to say.
09:26:02 <hpc> hmm
09:26:11 <maerwald> Most "design patterns" I came across when reading other peoples code.
09:26:18 <quchen_> @let bottom = let x = x in x
09:26:19 <lambdabot>  Defined.
09:26:20 <quchen_> > bottom
09:26:24 <lambdabot>  mueval-core: Time limit exceeded
09:26:25 <quchen_> Hmpf.
09:26:37 <quchen_> I thought maybe @let is treated differently.
09:26:43 <hpc> there's not an explicit list of them with "every programmer must know these" names like factory and singleton
09:27:05 <hpc> they're much closer to style conventions and techniques
09:27:06 <maerwald> hpc: that's exactly what it does not mean
09:27:14 <codedmart> Is there a standard way to have you project rebuild whenever a file changes. Related more to running servant web-server and rebuilding/restarting when a file changes?
09:27:33 <magneticduck1> codedmart: are you looking for IDE integration?
09:27:37 <maerwald> hpc: "smart constructors" is a design pattern for instance
09:27:41 <quchen_> `stack build --file-watch`, codedmart 
09:27:44 <tnks> hpc: I'm not sure the OO people really had much figured out anyway.  A lot of it is just talk and pinpoint discussions for interviews.
09:28:12 <codedmart> quchen_: That won’t restart the server though will it?
09:28:25 <codedmart> magneticduck1: No just a way to rebuild then restart the server.
09:28:33 <ertes> codedmart: i use 'rapid' together with emacs integration in my projects
09:28:37 <hpc> maerwald: ah, fair point
09:28:43 <ertes> codedmart: (disclaimer: i wrote it) =)
09:28:50 <quchen_> codedmart: Try `stack exec … --file-watch`, maybe that works by SIGTERMing the process if it’s still running
09:28:59 <numee> it's a shame dohaskell.com, a collection of tagged links to articles related to haskell, has been down for days and the wayback machine doesn't have it archived due to its robots.txt
09:29:24 <codedmart> quchen_: Invalid option :) thanks!
09:29:30 <codedmart> ertes: rapid?
09:29:44 <ertes> codedmart: i reload with C-c C-l, and restart the server (or whatever long-running thread) with C-c m
09:29:47 <ertes> @package rapid
09:29:47 <lambdabot> http://hackage.haskell.org/package/rapid
09:30:15 <maerwald> hpc: but yeah, it could also mean general approach techniques like... map the program logic into a data type and THEN write functions to "unfold" the stuff
09:31:43 <maerwald> sort of "runner" functions, which is maybe a design pattern too
09:31:57 <codedmart> ertes: I don’t use emacs so I will have to see how it all works. Thanks!
09:32:13 <magneticduck1> how many people use this little trick http://www.hastebin.com/ekebikuses.hs ?
09:32:21 <magneticduck1> e.g. the that part of the reflection library
09:32:38 <magneticduck1> I'm .. still getting my mind around what it means
09:33:02 <lpaste> lambdafan pasted “syntax for ViewPatterns Snafu” at http://lpaste.net/169758
09:34:14 <ertes> magneticduck1: javascript wall; didn't read (try lpaste.net)
09:36:25 <magneticduck1> http://lpaste.net/169759
09:37:42 <lyxia> lambdafan: you're missing an argument 
09:37:54 * hackagebot diagrams-graphviz 1.3.1 - Graph layout and drawing with GrahpViz and diagrams  https://hackage.haskell.org/package/diagrams-graphviz-1.3.1 (BrentYorgey)
09:38:27 <lyxia> lambdafan: they must be before the guard. 
09:39:20 <ertes> magneticduck1: do you understand how (X => Y) is really just (X -> Y), but with the argument chosen by the compiler and passed implicitly (instance resolution)?
09:39:46 <lambdafan> lyxia thanks :)
09:40:31 <ertes> magneticduck1: imagine for example that Monoid were a regular data type:  data Monoid a = Monoid { mappend :: a -> a -> a, mempty :: a }
09:40:57 <ertes> then you could have:  mconcat :: Monoid a -> [a] -> a
09:41:36 <ertes> an "instance" for 'Monoid A' would just be a value of type 'Monoid A'
09:44:18 <erisco> hm… can't you get the current line, column, or byte offset even with attoparsec?
09:44:47 <johnw> ertes: another difference would be that you could have: foo :: Monoid a -> Monoid a -> Monoid a, which would allow the two arguments to use different implementations of Monoid, so long as they match at 'a'.  They become objects, essentially.
09:46:02 <erisco> I guess that is not in the purview of attoparsec, darn
09:46:14 <magneticduck1> erisco: yeah
09:47:05 <johnw> erisco: https://github.com/bos/attoparsec/issues/16
09:47:25 <ertes> johnw: sure, but that's not really the point here =)
09:47:47 <ertes> magneticduck1: now if a class has only a single member, it might just as well be a newtype, right?
09:47:55 <erisco> getting the current character offset can't be a performance problem
09:48:07 <erisco> and that is all you need to later derive column and line numbers
09:48:12 <ertes> magneticduck1: class C a where cf :: a -> X
09:48:24 <ertes> would become:  newtype C a = C { cf :: a -> X }
09:48:39 <johnw> erisco: if bos says it impacts performance, I'm inclined to believe him
09:49:09 <ertes> magneticduck1: and now 'C a' has the same low-level representation as 'a -> X'
09:49:09 <erisco> johnw, his comment was specifically for line and column numbers
09:49:27 <erisco> the parser already knows its position in the text
09:49:38 <ertes> magneticduck1: this happens to be exactly what GHC does for single-member classes…  it represents them as an invisible newtype
09:49:49 <Profpatsch> I’ve got three functions, a :: Either e1 A, b :: A -> Either e2 B and c :: B -> Either e3 C
09:50:02 <Profpatsch> Is there a nice way to combine them?
09:50:24 <fr33domlover> Is there a shorter way to write "f a b c d e = g $ h a b c d e", in particular a way with length constant in the number of arguments?
09:50:26 <Profpatsch> I thought about throwing all three error types into one, but that’s not very nice.
09:50:48 <ertes> magneticduck1: so given a function (forall a. (C a) => B), this hack unsafeCoerces it to a function of type (forall a. (a -> X) -> B)
09:50:56 <Profpatsch> So a >>= b >>= c doesn’t work.
09:50:57 <ertes> magneticduck1: because that's exactly the low-level representation
09:51:08 <johnw> fr33domlover: there is a library on hackage that will do that, using symbols like .:::::
09:51:11 <quchen_> fr33domlover: None more readable I think. 
09:51:17 <johnw> where the number of dots is the number of arguments you want to elide
09:51:17 * shapr hugs johnw
09:51:25 <ertes> magneticduck1: and then it just passes it an argument of type (a -> X), which emualtes instance selection
09:51:29 <johnw> I think it's called composition or something
09:51:35 * johnw hugs shapr right back!
09:51:37 <ertes> magneticduck1: that's the hack =)
09:51:59 <fr33domlover> johnw, thanks. I'll take a look
09:52:15 <johnw> https://hackage.haskell.org/package/composition-1.0.2.1/docs/Data-Composition.html
09:52:36 <ertes> magneticduck1: and if you ever feel inclined to use this hack yourself, what you really want to do is to use the 'reflection' library instead, because at this point it's really just an implementation of this hack =)
09:52:47 <shapr> :-)
09:52:48 <magneticduck1> sure
09:52:56 <magneticduck1> it's.. something I've never seen before
09:53:37 <erisco> fr33domlover, check out http://stackoverflow.com/a/37329756/260584
09:54:19 <ertes> magneticduck1: it relies a lot on how GHC compiles single-member type classes…  change it a bit, and reflection may as well segfault
09:54:33 <ertes> so it's really not something super-clever…  it's just something super-internal
09:54:49 <maerwald> which may break arbitrarily with a new ghc version
09:54:55 <magneticduck1> oof :(
09:56:08 <ertes> magneticduck1: something along the lines of the NOINLINE hack that some libraries use…  change haskell's treatment of CAFs and some libraries may break
09:56:20 <ertes> s/haskell/GHC/
09:58:35 <bennofs> magneticduck1, ertes: you could implement it without relying on ghc internals, but it would be much slower :(
09:58:47 <bennofs> I think reflection even has a cabal flag for the slow variant
09:59:40 <magneticduck1> it does
09:59:49 <magneticduck1> I find that interesting
10:00:21 <magneticduck1> I wonder if this could be made into a language feature somehow? it seems like some latent functionality present in GHC that isn't really exposed by any standard interface
10:22:55 * hackagebot thentos-cookie-session 0.9.0 - All-in-one session handling for servant-based frontends  https://hackage.haskell.org/package/thentos-cookie-session-0.9.0 (MatthiasFischmann)
10:24:30 <ertes> bennofs: slower and less generic
10:24:52 <ertes> reflection works for every value of every type out of the box
10:25:31 <bennofs> a right i forgot about that extra constraint necessary for the slow path
10:31:24 <ertes> notably it works for function types, which has been *very* useful for me
10:48:54 <kqr> does anyone know of a really good tutorial on conduit? I always forget how it works, because I don't use it enough, because I don't quite know it well enough to know when to use it...
10:49:36 <lambdafan> kqr: what has google brought up for you?
10:49:59 <kqr> mostly a bunch of simple examples on how to map a function over a list except lifted into conduit
10:50:25 <kqr> ideally I'd like something that also explains when and why it's good... if that question makes sense
10:50:37 <sm> how about the blog posts introducing it
10:50:54 <cocreature> the readme also looks pretty good
10:50:57 <sm> or I guess even the readme
10:51:06 <cocreature> it also links to some slides
10:51:07 <sm> crazy, I know
10:51:15 <rcat> kqr: school of haskell has a pretty good tutorial
10:51:39 <rcat> kqr: https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/conduit-overview
10:52:48 <kqr> cocreature, sm: the blog posts and readmes focus a lot on performance and not so much on code clarity. I'm still at the point where regular file and socket operations seem like they give me cleaner code than whatever conduit solution I can whip up
10:52:51 <kqr> rcat, thanks, will take a look
10:53:28 <cocreature> kqr: well a big if not the biggest reason why you would want to use conduit is performance
10:53:35 <sm> yeah, it might be that conduit code just isn't cleaner
10:53:51 <kqr> cocreature, sm: and, since I forgot to mention that, I rarely deal with files and resources of the sizes/amounts that make the "traditional" approach infeasible
10:54:43 <kqr> I feel like a constant-resources streaming approach would be a good habit to get into, but the code I write is not clean enough to be quite worth it. I suspect this is because I don't write good enough code, not because conduit isn't good enough for smaller projects
10:54:45 <kqr> but I might be wrong
10:56:24 <plugyn> the body of a function is called the lambda right?
10:56:47 <kqr> not generally, no
10:56:54 <plugyn> ok
10:57:06 <kqr> "the body of the function" is a good name for it though
10:57:18 <davidkart> lambda is « anonymous function » rather ?
10:57:40 <davidkart> Mathematically a function is a mapping. A lambda is just the mapping without a name for it.
10:57:50 <davidkart> (CMIIW)
10:57:52 <plugyn> hm. ok
10:57:54 <plugyn> thanks~
10:58:17 <ertes> plugyn: in "\x -> y", the part that's called a lambda is either "\" or the whole thing…  "y" is what you would call the "body" of the function
10:58:28 <plugyn> ah, right
10:58:28 <davidkart> Actually the name is just lambda (because of historical reasons).
10:58:34 <plugyn> which \x is the anonymous function input
10:58:58 <plugyn> sorry i'm really new with haskell
10:58:58 <kqr> davidkart, i still prefer the term "anonymous function", but sure, people use the word "lambda" to refer to them
10:58:59 <plugyn> :<
10:59:24 <ertes> kqr: streaming abstractions generally produce at best very similar code, but may produce worse code, sometimes *far* worse code
11:00:06 <ertes> kqr: but i'm happy to take a hit in code beauty, if by that i give my code an efficiency/scalability boost
11:00:33 <ertes> kqr: it has to be a reasonable trade though
11:00:53 <Profpatsch> How do I create a datatype like so that can implement Show?
11:01:17 <Profpatsch> data Foo = forall a. Bar a
11:01:39 <Profpatsch> It’s probably not what I want anyway.
11:02:14 <ertes> plugyn: which programming language is your current main language, if any?
11:02:30 <plugyn> ertes: C and java
11:02:38 <plugyn> java for academic reasons though
11:02:46 <Profpatsch> Backround is that I have an Error type data ParseError = A | forall a. B a
11:02:56 <plugyn> ertes: but I won't claim to be amazing at either of them :^)
11:03:11 <fr33domlover> kqr, for simple one-time cases, it may be easy and quick to write the streaming loop manually
11:03:12 <Profpatsch> And I want to be able to put stuff in the B, but the ParseError type shouldn’t change.
11:03:19 <ertes> plugyn: hmm…  any other language you know at least the basics of?  i hope there is one that has reasonable support for anonymous functions =)
11:03:38 <ggVGc> ertes: you could say that java has that, kind of
11:03:39 <fr33domlover> Especially if you haven't used conduit/pipes yet :P
11:03:41 <plugyn> ertes: this is my first time with anonymous functions, but doesn't python have them as well?
11:03:43 <ggVGc> well, java 8 does
11:03:45 <Profpatsch> Yet, of course that way a can be anything and I cannot derive Show
11:03:50 <ggVGc> earlier java had anonymous classes
11:03:52 <ertes> plugyn: yeah, python has the 'lambda' construct
11:04:07 <ertes> plugyn: python's "lambda x: y" translates to "\x -> y" in haskell
11:04:13 <ertes> (more or less)
11:04:15 <plugyn> ertes: ah, alright :3 
11:04:33 <Welkin> use lua if you want a dynamic language with lexical scoping, TCO, and is fast
11:04:36 <Welkin> :D
11:04:49 <maerwald> end end end end end end
11:04:50 <maerwald> oops
11:04:53 <Welkin> you can also look at racket
11:04:56 <maerwald> missed one
11:05:59 <ertes> plugyn: oh, and don't apologise for being new…  don't worry, haskell will give you plenty of opportunities to apologise for other things ;)
11:06:34 <plugyn> ertes: hah. I'm currently reading that new book that just came out for it
11:06:40 <Profpatsch> Hm, there is https://prime.haskell.org/wiki/PolymorphicComponents, but I’ve read time and again that there shouldn’t be constraints on data types.
11:06:42 <plugyn> Programming from First Principles
11:07:36 <ertes> "sorry for missing the deadline, because i tried to emulate dependent types to statically tell whether this list has prime numbers in it"
11:07:37 <Profpatsch> Is data ParseError = OtherError (forall a. Show a -> a) an okay data type?
11:07:44 <davidkart> anybody could help me to set up vim for haskell ?
11:08:10 <Profpatsch> s/->/=>/
11:09:01 <davidkart> what you guys are using as an IDE ?
11:09:02 <Profpatsch> And where is the difference between data ParseError = forall a. Show a => OtherError a ?
11:09:04 <co-dh> http://www.stephendiehl.com/posts/vim_2016.html
11:09:11 <co-dh> davidkart: 
11:09:11 <davidkart> yeah I got through it.
11:09:56 <davidkart> but if you had any supplementary advices I would like to hear about it.
11:10:15 <sm> davidkart: intellij IDEA
11:10:28 <davidkart> it works ok with haskell ?
11:10:36 <sm> yes, it works ok
11:10:48 <sm> not great, but still worth it
11:12:13 <Profpatsch> davidkart: If you don’t want to use vim, take a look at Spacemacs
11:12:21 <Profpatsch> Maybe you’ll like it.
11:12:33 <davidkart> ho, yeah
11:12:35 <davidkart> thanks sm
11:13:15 <davidkart> Profpatsch: i'm not so good with emacs, I already have a painfully acquired knowledge of vim and I'll try to build up my knowledge from what I already know.
11:13:52 <Welkin> davidkart: use evil mode in emacs
11:14:02 <Profpatsch> davidkart: You will be happy to hear that Spacemacs is the power of Emacs combined with the control scheme of vim (by default).
11:14:25 <Profpatsch> You should try it.
11:14:35 <Profpatsch> (it will blow your mind, probably)
11:16:08 <bennofs> (or your cpu)
11:16:12 <Profpatsch> Nobody on the difference between Existentials and Rank2Types in Constructors?
11:16:20 <Profpatsch> bennofs: well played
11:17:01 <davidkart> ok, I was going to add something but then you came. I will give it a try. Thank you very much.
11:17:26 <bennofs> Profpatsch: you mean data X = X (forall a. Show a => a) vs data Y = forall a. Show a => Y a?
11:17:39 <Profpatsch> Yes, exactly.
11:18:02 <bennofs> @let data X = X (forall a. Show a => a)
11:18:03 <lambdabot>  Defined.
11:18:05 <bennofs> :t X
11:18:07 <lambdabot> (forall a. Show a => a) -> X
11:18:29 <bennofs> Profpatsch: ^^^ this requires you to pass a value that can be of any type that implements show
11:18:57 <bennofs> :t X () -- Type error, because () is a concrete type, not "any type that implements show"
11:18:58 <lambdabot>     Couldn't match expected type ‘a’ with actual type ‘()’
11:18:58 <lambdabot>       ‘a’ is a rigid type variable bound by
11:18:58 <lambdabot>           a type expected by the context: Show a => a at <interactive>:1:1
11:18:59 <Profpatsch> So I can use the function show on those types?
11:19:16 <Profpatsch> wat
11:19:40 <bennofs> Profpatsch: the difference between the two data definitions is like forall a. (a -> c) -> b vs (forall a. a -> c) -> b
11:19:52 <Profpatsch> So Rank2Types in constructors are useless
11:20:16 <c_wraith> no
11:20:21 <bennofs> Profpatsch: it could work if you used a class other than Show
11:20:21 <Profpatsch> Now give me 20 minutes to understand the difference between the two. :)
11:20:24 <ertes> "you've been working on this log parser for two weeks; how the hell can you be not done yet?! …  you had to invent what? …  what's an effect language? …  type-level what?! …  base-control what?! you're making stuff up! …"
11:20:38 <bennofs> Profpatsch: consider it with read
11:20:39 <c_wraith> it just needs to be constructed with a polymorphic expression 
11:20:53 <bennofs> @let data Y = Y (forall a. Read a => a)
11:20:54 <lambdabot>  Defined.
11:21:17 <bennofs> :t Y (read "") -- the result of read "" can be used at any type a that is an instance of Read, therefore this is ok
11:21:18 <lambdabot> Y
11:22:14 <Profpatsch> That reminds me of Exceptions.
11:22:50 <c_wraith> SomeException is, in fact, an existential wrapper. 
11:22:53 <Cale> Profpatsch: If you wanted to turn the Monad type class into a data type, you'd have something like  data Monad m = MkMonad { return :: forall a. a -> m a, (>>=) :: forall a b. m a -> (a -> m b) -> m b }, which would mean that MkMonad had a rank 2 type.
11:23:14 <bennofs> > let y = Y (read "()") in (let Y x = y in x :: (), let Y x = y in x :: Int) -- Profpatsch the consumer can choose what type it wants to use the contents of the data type at
11:23:16 <lambdabot>  ((),*Exception: Prelude.read: no parse
11:23:33 <bennofs> Whereas with existential types, the producer gets to choose what type he puts into it
11:25:39 <bennofs> With existential types, the producer says: Hey, I give you something that satisfies these constraints, you need to know how to deal with *any* possible type satisfying the constraints 
11:25:50 <Profpatsch> So forall a. (a -> c) -> b is a function that takes a function that can convert *anything* to c and gives me a b?
11:26:10 <bennofs> Profpatsch: what you describe would be (forall a. a -> c) -> b
11:26:36 <Profpatsch> Hm. Is there such a function?
11:26:57 <hpc> given (c -> b) there is
11:26:57 <bennofs> Profpatsch: for c ~ (): const () :: forall a. a -> ()
11:27:06 <Profpatsch> And what’s forall a. (a -> c) -> b then?
11:27:16 <bennofs> Profpatsch: that's just like (a -> c) -> b
11:27:46 <Cale> davidkart: Basically, any text editor that you're comfortable with should do, imo. Keep it running alongside GHCi -- when you make changes to the code, type :r in GHCi to reload and either get type errors, or test whatever you just wrote interactively.
11:28:10 <bennofs> Profpatsch: in fact, forall a b c. (a -> c) -> b and (a -> c) -> b are the same, haskell implicitly adds forall for the toplevel type variables
11:28:22 <Cale> Profpatsch: perhaps consider something like this program:
11:28:22 <maerwald> Cale: that's a rather inconvenient workflow, jumping between two windows, always trying to track which line the error is on etc
11:28:45 <Cale> maerwald: eh, most editors have jump-to-line
11:28:53 <maerwald> yes, still inconvenient
11:29:01 <Cale> I don't find it bad at all
11:29:02 <EvanR> the number of keys to press is non zero
11:29:08 <Profpatsch> So if I want to have a ParseError type where the OtherError constructor should take a thing that implements Show, do I need Existentials or Rank2Types?
11:29:16 <Welkin> M-x imenu <function name>
11:29:26 <Welkin> you can bind it to anything you want
11:29:37 <Cale> Profpatsch: foo f = (f "hello", f [1,2,3])
11:29:38 <Welkin> oh
11:29:42 <bennofs> Profpatsch: probably existential types, because you want to put *in* any concrete type that implements Show
11:29:49 <Welkin> emacs compile-mode automatically takes you to the line the error occurred on
11:29:57 <Welkin> by pressing ,
11:29:58 <Cale> Profpatsch: This is normally a type error, but note that f = length would be just fine
11:30:03 <bennofs> Profpatsch: so the producer chooses the type, so you need Existential.
11:30:04 <EvanR> if errors take X time to fix, and the time to switch between errors is anything more than X/ say 50, then we have a significant drain going on
11:30:21 <Cale> Profpatsch: So we could give foo the type (forall a. [a] -> Int) -> (Int, Int)
11:30:28 <Cale> and that would work
11:30:54 <Profpatsch> Cale: That’s Existentials?
11:31:01 <EvanR> this effect gets worse the better the error messages and compiler get because X decreases
11:31:01 <Cale> No, that's a rank 2 type
11:31:08 <bennofs> Profpatsch: using Rank2Types would mean that the producer is responsible for producing the concrete type that the consumer wants (i.e. it must be able to make a value of *any* type that implements Show, which is not possible because you cannot create values using Show)
11:31:57 <Cale> Profpatsch: The idea here is that foo is demanding that its argument is polymorphic
11:32:10 <Profpatsch> So in Cale’s example the producer must be able to generate an Int for any List given.
11:32:24 <Cale> You're not allowed to pick which type of lists the function is allowed to accept -- it must be able to work with any type of list.
11:32:29 <Cale> right
11:32:32 <maerwald> EvanR: also, for long ghc errors (e.g. you make a non-trivial change throughout the whole codebase) you have a lot of fun scrolling through the errors finding what is relevant to you 
11:32:37 <Profpatsch> So length is correct, as is const 5
11:32:42 <Cale> yep
11:33:18 <EvanR> maerwald: sometimes i want the errors to list backwards so i can start at the top easily
11:33:21 <Cale> and therefore whichever function we pass in is not allowed to examine the elements of the lists that it will be given
11:33:50 <Profpatsch> And with Existentials (which only work in data definition) I say „give me anything that implements Show, I only need the show function“?
11:34:11 <ertes> i created a GHC feature request for warning/error priorities a while ago
11:34:14 <maerwald> if the errors are "embedded" into the editor you can start fixing stuff at the place where it makes sense (e.g. the entry point) and go from there without a lot of back and forth
11:34:17 <Cale> GHC is pretty good at reporting errors that are orthogonal to one another. Starting at the top doesn't really matter so much
11:34:50 <EvanR> i still feel weird fixing the bottom errors first
11:35:06 <ertes> holes, for example, are really inconvenient to use right now, because you have to skip past all the other warnings (unused import, unused variables, etc.)
11:35:07 <Cale> EvanR: Would it help to just think of those as the first errors?
11:35:09 <maerwald> I have never seen that the GHC error order makes any particular sense whatsoever
11:35:10 <EvanR> maerwald: yeah this is where the vim quickfix windows come in
11:35:11 <Cale> :D
11:35:18 <Profpatsch> maerwald: In vim you can hit <n> <n> g g and it will jump to the line.
11:35:23 <Profpatsch> So I use that a lot.
11:35:29 <maerwald> Profpatsch: erm
11:35:39 <EvanR> Cale: what if there were an infinite number of errors, that wouldnt work
11:35:41 <Cale> Pretend that GHC has already reversed them for you :D
11:35:47 <maerwald> Profpatsch: I don't need a crash course in basic vim commands ;)
11:36:02 <Cale> If there are an infinite number of errors, then the bug is in GHC and not your code :D
11:36:02 <Profpatsch> maerwald: And in Spacemacs it even underlines the right lines for you.
11:36:10 <maerwald> Profpatsch: I know that too
11:36:22 <maerwald> I've used both editors
11:37:03 <Cale> also, most editors have a feature you can turn on which will put line numbers in the margin
11:37:06 <Cale> hahaha
11:37:23 <Profpatsch> When you start up ghcid in a window side-by-side with vim, you don’t have to switch windows.
11:37:31 <maerwald> Cale: yeah, you need a lot of work to make that non-broken in emacs :P
11:37:43 <Cale> Oh?
11:38:05 <maerwald> yes
11:38:33 <maerwald> there are tons of cases where it breaks (e.g. frame scaling, font scaling and whatnot) 
11:38:41 <Cale> jeez
11:38:44 <EvanR> theres a vim window which lists errors and lets you jump to where these errors are
11:38:50 <EvanR> you might have to program it though
11:39:04 <maerwald> EvanR: or just use syntastic?
11:39:07 <Gurkenglas> People want top errors first? Next thing theyll ask for left to right composition
11:39:20 <EvanR> whats syntastic
11:39:37 <fishythefish> EvanR: vim plugin
11:39:38 <maerwald> EvanR: https://github.com/scrooloose/syntastic
11:39:38 <EvanR> Gurkenglas: not necessarily in that order
11:39:38 <sm> +1 for ghcid, I keep it running in a side pane
11:39:45 <Profpatsch> Gurkenglas: import Control.Category. :P
11:39:55 <maerwald> it's more than "syntax checking" though
11:39:57 <ertes> am i the only person running haskell-interactive-mode?
11:40:20 <Cale> I use ghcid whenever I'm working through a lot of errors.
11:40:26 <sm> ertes: could be
11:40:32 <EvanR> i see
11:40:34 <Profpatsch> Hm, (>>>) has infixr 1 and (>>=) has infixl 1, so I can‘t combine them, can I?
11:40:43 <sm> does it help with the error reporting problem ?
11:40:45 <EvanR> hopefully in the case of haskell "syntax checking" means "type checking"
11:40:49 <Cale> It's nice, but I sort of wish that the errors were scrollable.
11:40:53 <ggVGc> do  you guys use ghci from your editor or in terminal_
11:41:00 <fishythefish> Profpatsch: parentheses
11:41:02 <Cale> I just use ghci in the terminal
11:41:08 <ggVGc> I mean, do you have thigns set up to load and run code from buffers in ghci?
11:41:12 <Cale> and keep it entirely separate from my editor
11:41:13 <ertes> ggVGc: from haskell-interactive-mode…  it's basically REPL tightly integrated with the editor
11:41:15 <maerwald> EvanR: it allows you to use all of them at once: hdevtools, hlint, liquidhaskell, ghc-mod
11:41:17 <Profpatsch> fishythefish: duh :)
11:41:21 <Cale> I use my editor to edit text
11:41:21 <maerwald> and get errors/warnings from all of them
11:41:25 <ggVGc> yeah, seems emacs has nice ghci integration
11:41:26 <EvanR> oh
11:41:28 <Cale> and that's about it
11:41:32 <ggVGc> I haven't found anythign nice in vim yet
11:41:58 <Profpatsch> ggVGc: You should learn the controls, they are quite nice.
11:41:59 <maerwald> although ghc-mod needed a bit of manual fixing last time I checked because the syntactic dev got pissed off of the API breakages
11:42:03 <Profpatsch> And then switch back to emacs. :)
11:42:04 <sm> Cale: sounds dull :)
11:42:10 <ggVGc> Profpatsch: the controls for what?
11:42:24 <Profpatsch> ggVGc: Text editing & stuff
11:42:29 <Cale> sm: It's good enough, and saves me a lot of time fiddling with editor plugins.
11:42:40 <ertes> it gives you a REPL buffer, but it's not the GHCi REPL directly, but instead it runs GHCi more like a daemon and uses it to ask for types, warnings, errors, completion symbols, etc.
11:42:46 <sm> I hear that. That's one reason I'm using intellij more
11:42:54 <ggVGc> Profpatsch: i think you misunderstood. I know vim quite well. But there is no good ghci repl in vim that I've found
11:42:58 <ertes> to be honest i really don't know why not everybody is using haskell-interactive-mode =)
11:43:09 <ertes> s/everybody/everybody using emacs/
11:43:18 <maerwald> ertes: because of that
11:44:05 <sm> ertes: perceived fragmentation and high setup/maintenance cost of emacs tooling
11:44:09 <Profpatsch> ggVGc: Ah, yes, I misunderstood.
11:44:30 <anykey> I wanted to learn haskell, and picked the Yesod book. After struggling with cabal and dependencies, I found Yesod quickstart, and used stack. My question: This does take a really long time to build libraries and stuff, and I might want to start over when I break it. Is it normal that the setup time is half an hour?
11:44:31 <ertes> sm: not sure what you mean
11:44:40 <maerwald> sm: and it cannot map some workflows properly, at least not without another set of "program it yourself" answers
11:44:43 <ggVGc> ertes: because I started using vim 8 years ago, and now it's essentially 70% of my computer usage and there is no space in my life to get into emacs :(
11:45:00 <ggVGc> more than superficially
11:45:01 <Gurkenglas> I wonder how stupid it'd be to have operator precedence being handled by operator text color instead of fixity declarations
11:45:21 <ertes> ggVGc: well, there is evil-mode
11:45:22 <Profpatsch> ggVGc: You should try Spacemacs for one hour.
11:45:23 <codedmart> So I am trying to figure out how to handle structure. I have models, but some of them rely on each other. Right now I have the data and (FromJSON, ToJSON) instances in one file, but it will get fairly long. I tried using the .hs-boot method but doesn’t seem to work with instances.
11:45:33 <sm> anykey: only the first time
11:45:35 <codedmart> Any ideas on how I can handle this?
11:45:40 <ggVGc> ertes: yeah, and it works really nice now. But the input scheme is only a small part of effective editing
11:45:48 <maerwald> ertes: imagine you lost your memory and someone deletes your emacs config. It's a huge waste of time, similar to fixing latex bugs.
11:46:05 <ertes> maerwald: it's an investment, not a waste of time
11:46:21 <anykey> sm: thanks, I will try setting up a second one and see if it is really faster :-) because if it was taking as long every time, I'd have to consider a hardware upgrade...
11:46:23 <maerwald> "investment" implies that's useful knowledge somehow
11:46:30 <maerwald> it is not, except for it's own purpose
11:46:54 <ertes> maerwald: your opinion is the correct one, as always…  fine with me =)
11:46:59 <sm> anykey: stack build --dry-run shows how much work it'll do
11:47:08 <anykey> oh. that's valuable.
11:47:39 <ggVGc> one day I'll set aside a few hours a day for a week to get an emacs setup with evil that somewhat matches my main vim things
11:47:45 <ggVGc> and then I'll be on my way
11:47:50 <ggVGc> I think emacs is a much better piece of software
11:47:58 <ggVGc> but vim is where all my effort has gone into the past years
11:48:03 <sm> ertes: heh
11:48:03 <ggVGc> and I have work to do all the time..
11:48:03 <cloudhead> codedmart: can you keep the instances with the models? ie: Person.hs, Animal.hs etc?
11:48:17 <ggVGc> so, it's not easy to just say "let's make this other tool work exactly the same as my old one"
11:48:18 <maerwald> ertes: "correct opinion" is a delicate term, not sure what you mean. But ok.
11:48:42 <ggVGc> but yeah, for haskell emacs seems way nicer
11:48:44 <codedmart> cloudhead: Seems like I ran into an issue with that, but I can try again.
11:48:53 <ggVGc> I have vim with ghc-mod and it's pretty good, but I'd like a repl
11:48:57 <cloudhead> codedmart: cyclical imports?
11:49:13 <codedmart> Yeah, let me retry where I was at and see.
11:49:17 <ertes> maerwald: it means: i'm not getting into an editor war with you =)
11:49:23 <maerwald> ertes: what I meant is pretty much the same what Cale said. I don't want to waste my time with editors, and the time I had to invest into emacs to get even _simple_ things like line numbers working was HUGE.
11:49:53 <maerwald> now I know a lot about line numbers in emacs
11:49:57 <maerwald> very useful?
11:50:11 <ertes> maerwald: that's fine, emacs is not for you…  people also consider the hours i spent configuring zsh a waste of time, and i agree that a shell should "just work" and "just be productive"
11:50:13 <cloudhead> codedmart: if the types are co-dependent, you have to have them in the same file
11:50:15 <ertes> but that's not the way it is
11:50:25 <Welkin> what? you just turn line number on with a simple one-liner in your .emacs
11:50:28 <ertes> i'm the kind of person who invests time in good tools
11:50:31 <Cale> maerwald: I started using Sublime Text a little while ago, and while I had to change a few config options to make it not do distracting stuff, it didn't take very much configuration to make it usable at all.
11:50:31 <codedmart> cloudhead: But I thought that is what hs-boot is for?
11:50:33 <maerwald> Welkin: you are joking.
11:50:46 <maerwald> Welkin: please scale your font and watch what happens
11:50:49 <Welkin> (line, column) in the lower buffer
11:51:04 <maerwald> I'm talking about linum/nlinum mode
11:51:12 <maerwald> it's known and documented that they are full of bugs
11:51:12 <cloudhead> codedmart: ah yes, I haven't used that much tbh
11:51:48 <cloudhead> codedmart: I'd recommend trying to get it to work without that, ie: non-recursive dependencies
11:51:58 <maerwald> Cale: I tried it too, not too bad, but it didn't attract me too much yet
11:52:36 <maerwald> I would actually use leksah if the editor wouldn't be so boring
11:52:55 * sm uses linum-mode and has no trouble with font size changing, but YMMV
11:52:56 <Cale> maerwald: Basically, it does more than the job I need an editor to do without needing plugins or much configuration at all. I don't want my editor to be very exciting.
11:53:24 <maerwald> sm: did you try frame scaling?
11:53:40 <sm> not sure what that is, how do I ?
11:53:47 <Cale> I could almost get away with gedit, though with the projects I'm working on at the moment there are enough files I have to switch between that having the file list on the left is quite useful.
11:54:22 * sm gives nlinum-mode a try
11:54:43 <Profpatsch> Cale: bennofs Haskell' says: When existentials appear in the contravarient position <..>, they
11:54:44 <Profpatsch> can be desugared into rank-n types with foralls.
11:54:55 <Profpatsch> So both don’t seem so different after all.
11:55:24 <Cale> They're not unrelated
11:55:36 <Cale> There's a reason that the same keyword is involved in both
11:56:46 <maerwald> sm: you can use the package zoom-frm
11:56:55 <ertes> give me any editor that has good haskell integration, and i'll gladly try it out…  but if i need a separate terminal during development, it's out
11:57:48 <Cale> ertes: That seems crazy to me, it's so useful to have a few extra terminals around
11:58:01 <maerwald> sm: also see https://www.emacswiki.org/emacs/LineNumbers#toc14
11:58:40 <ertes> Cale: i can always open one, if i need it, but most of the time i don't
11:59:18 <sm> maerwald: ah. I'm on a mac, and using these: https://gist.github.com/anonymous/2758cb30ac586110f869bf52055aefb1
11:59:35 <Cale> ertes: At the very least, ghci and/or ghcid
12:00:01 <ertes> Cale: i have GHCi integrated into the editor
12:00:04 <Cale> I don't see any reason why I'd want those to be in the same window as my text editor
12:00:47 <ertes> Cale: it's not about the window…  i don't use the REPL very often, because most of the time, i ask it for types or to restart a thread
12:00:49 <maerwald> sm: also, linum is awfully slow, so you can pretty much forget that with C projects
12:00:55 <sm> ertes: how do you see build errors across your whole package (or multi-package project) ?
12:01:14 <sm> maerwald: I noticed that, thanks for the nlinum tip
12:01:30 <ertes> sm: i load a module and see errors highlighted, or i switch to the project buffer and see the error messages themselves
12:01:49 <ertes> sm: i say "next error, please" to jump around
12:02:59 <sm> so you might have to scroll through your file, or switch to a hidden buffer to see them ?
12:03:27 <sm> next error in compile-mode is good, I agree
12:03:40 <sm> all these ways have their strengths and weaknesses
12:03:45 <ertes> sm: or have the buffer below or beside…  when i go to the next error, the error message becomes visible in a split window
12:04:20 <maerwald> yeah, cross-reading manually between different windows in order to have the same context is awful
12:04:40 <sm> I have got tired of trying to control/outguess how emacs will split windows as screen size varies
12:06:16 <maerwald> I still am missing the inline popup-documentation of eclipse :(
12:06:25 <ertes> sm: it doesn't bother me that much…  the thing with GHC errors is that sometimes the first line is enough to know how to fix it, and in almost all other cases the error is long enough that you have to scroll anyway
12:06:28 <maerwald> leksah is what comes pretty close there
12:06:37 <sm> I like emacs' flexibility for building a quick task-specific IDE, intellij for stability/predictability
12:06:43 <ertes> sm: and after fixing it, you make the buffer disappear anyway
12:07:21 <ertes> most other useful things don't need the buffer visible, like asking for types (usually simply by placing the cursor over a word)
12:07:32 <ertes> or completion of symbols
12:07:49 <ertes> i don't want hoogle or TAGS for that…  i want to ask GHCi
12:08:18 <ertes> btw, "intellij" is a microsoft thing, i think…  haven't heard it in the context of emacs yet
12:09:22 <ertes> one thing i'd love to have is builtin haddock docs: walk over a symbol, have its haddock pop up via key binding
12:09:48 <sm> it's a jetbrains product
12:09:54 <maerwald> ertes: exactly
12:10:03 <maerwald> ertes: leksah "sort of" does that
12:10:11 <maerwald> I think it's the closes you can get (not popups though)
12:10:43 <ertes> maerwald: i wouldn't mind it opening a browser…  anything that just gets me the docs on the screen somehow
12:11:02 <maerwald> that's already annoying to me
12:11:08 <maerwald> it's context switching again
12:12:09 <ertes> sure, a buffer would be better, but my current workflow is:  go to browser, use keyword search to go to hackage page, use quick-find to go to module, use quick-find to hopefully quickly find the thing i'm looking for
12:12:19 <ertes> that's the number one thing that wastes my time right now
12:12:26 <ertes> everything else i have pretty efficient
12:12:32 <Profpatsch> Cale: bennofs Concerning Existentials, I believe edkmett made a point for using dumb datatypes and encoding the class restrictions only in the functions.
12:12:40 <sm> ertes: set up a keyword for hoogle, one less step ?
12:12:57 <ertes> sm: hoogle doesn't display docs, does it?
12:13:10 <sm> it does actually, and the full haddock is a click away
12:13:12 <Profpatsch> Because with existentials the type is constrained in a way that can also be done with functions when needed.
12:13:31 <bennofs> Profpatsch: no, that was about DatatypeContexts, not ExistentialTypes
12:13:34 <ertes> sm: oh!  hoogle is integrated into haskell-mode =)
12:13:39 <maerwald> ertes: also, to make that really proper, the plugin would also have to examine the installed version of the library the symbol is used from and then jump to _that_ version of the docs, not to the latest one
12:13:44 <ertes> sm: i'll have to look into that, thanks =)
12:13:49 <sm> yay
12:14:06 <sm> remember there are some different versions of hoogle around. I like http://hoogle.haskell.org
12:14:15 <Profpatsch> bennofs: I can’t implement the Existential functionality with function class constraints?
12:14:33 <bennofs> Profpatsch: no, because you don't have a type variable to constrain?
12:15:19 <Profpatsch> Hm, I have to think about that.
12:15:25 <ertes> sm: i'd actually use local hoogle, if it indexes quickly enough, because then i can integrate it with nix and have it nail the exact version i need =)
12:15:27 <Profpatsch> But good to know it was not about Existentials.
12:15:51 <sm> but you won't find things you haven't installed yet
12:15:55 <sm> but yes
12:16:08 <bennofs> Profpatsch: if was about data Show a => Z a = Z a
12:16:29 <maerwald> sm: as much as I hate eclipse, it's really strong on that end
12:16:31 <ertes> sm: i don't need that…  it's mostly revisting the docs of stuff i'm currently using, otherwise i'm going to open hackage pages anyway
12:17:10 <bennofs> Profpatsch: that is a quite unrelated syntax, and means that a must satisfy Show when you call the Z constructor. However, in constrast to existential types, the type 'a' itself is still a type argument of the data type
12:17:22 <bennofs> (the type of 
12:27:59 * hackagebot ring-buffer 0.3 - A concurrent, mutable ring-buffer  https://hackage.haskell.org/package/ring-buffer-0.3 (BenGamari)
12:31:47 <crough> existentials can be written in terms of RankNTypes, whoever is asking about them
12:31:50 <crough> https://gist.github.com/crough/f9b4c92771e17d55938839d57da74dc5
12:31:55 <crough> that probably explains them a touch better
12:41:14 <kqr> fr33domlover, I don't even know how to start writing the streaming loop. but you're basically saying while (!feof(fd)) {str = read(fd, 512); ...} ?
12:59:09 <fr33domlover> kqr, yeah, sort of. You read a chunk, process it, and pass the remainder you didn't use to the next iteration. I have an example if you like: A loop that parses a Zlib compressed text file with attoparsec: http://hub.darcs.net/fr33domlover/vervis/browse/src/Data/Attoparsec/ByteString/Local.hs
13:00:24 <fr33domlover> You can also check out incremental file parsing in the 'binary' package, there's a function there that basically does the same kind of thing
13:00:31 <fr33domlover> These loops always look the same :P
13:03:21 <davidkart> hello
13:03:34 <davidkart> I finished by installing all the archlinux haskell packages
13:03:41 <davidkart> (it must be 3G large)
13:04:05 <davidkart> I wonder if it is a good idea, but I really need that vim plugin to work.
13:04:13 <davidkart> I can't take any chance :p
13:05:53 <Jinxit> davidkart: enjoy that -Syyu
13:06:20 <davidkart> "Installer requires 'par'. Please install and try again." :(
13:06:52 <davidkart> at least I have syntactic coloration now
13:07:03 <davidkart> I wonder how I did this but it works now
13:08:33 <davidkart> wow i'm not in a good mood right now 
13:09:10 <Welkin> davidkart: just use emacs o.o
13:09:13 <Welkin> with evil mode
13:09:54 <bernalex> what vim plugin?
13:10:08 <davidkart> ya know I just opened my file with emacs, I don't even have syntactic coloration
13:10:18 <davidkart> My mood level just decreased a step
13:10:29 <Welkin> davidkart: of course not... you probably don't have font-lock turned on
13:10:38 <Welkin> or the right mode installed
13:10:43 <davidkart> https://github.com/begriffs/haskell-vim-now
13:10:45 <Welkin> depending on what language it is
13:10:51 <davidkart> ghc-mod is installed
13:10:57 <davidkart> but it's all distro packages
13:11:02 <bernalex> davidkart: fwiw I used vim for over a decade. in the last couple of years of those many years, I was aware that emacs was probably a better choice, but the cost of changing was too high to justify the switch.
13:11:31 <bernalex> davidkart: and then... earlier this year I made the switch. and I can safely say, I feel like an idiotic boob for not doing it two years ago or more.
13:11:56 <davidkart> yeah but emacs has ghc-mod but I can't know how to enable this.
13:11:57 <bernalex> I don't like haskell-vim-now at all. I did not use it when I used vim.
13:12:10 <bernalex> emacs and vim can both use ghc-mod. I have used it in both.
13:12:30 <kadoban> haskell-vim-now was just totally broken when I made my setup. And I get the feeling that that wasn't an isolated instance.
13:12:33 <bernalex> in emacs I use it with flycheck, in vim I used it with syntastic.
13:13:52 <bernalex> my recommendation is to look into spacemacs. start drooling over how gorgeous emacs can be. then uninstall spacemacs because it sucks, and install emacs proper. and start growing your emacs. https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md this is a bit outdated, but it helped me some to get started.
13:13:53 <Welkin> lol, just use the normal set up
13:14:04 <Welkin> emacs + haskell-mode + ghc-mod + whatever else
13:14:13 <plugyn> ^
13:14:35 <bernalex> bringing up spacemacs and realising how good it felt, was what compelled me to just make time to check out emacs an entire weekend.
13:14:56 <plugyn> I also used spacemacs when I was getting used to it. It's a very good introduction to emacs
13:15:06 <bernalex> for emacs & haskell I use haskell-mode, hare, ghc-mod, flycheck, and that's about it.
13:15:34 <bernalex> I need to push some things, but https://github.com/alexander-b/.emacs.d works well for emacs for me.
13:15:46 <bernalex> note that I'm a complete emacs noob though, so my .emacs probably isn't as pretty or nice as it should be. :p
13:15:58 <plugyn> bernalex: you can pull from other people
13:16:04 <plugyn> from dotshare.it or git*
13:16:17 <bernalex> plugyn: I don't know what you mean.
13:16:21 <Welkin> the way of ~/.emacs is to copy, paste, modify
13:16:23 <davidkart> how do you use all that plugins when launching emacs ?
13:16:36 <plugyn> bernalex: people post their .emacs stuff all the time. Pull from them and modify it to what you want
13:16:38 <davidkart> it is just bare emacs to me.
13:16:42 <bernalex> davidkart: I don't understand the question
13:16:48 <davidkart> i do emacs file.hs
13:16:53 <davidkart> and everything is raw
13:16:55 <bernalex> davidkart: the same way as you do in vim. you activate the plugins.
13:17:02 <davidkart> and how do you do that ?
13:17:09 <davidkart> this is not automatic ?
13:17:14 <bernalex> that's a bit much work for us to explain you how to basic emacs
13:17:32 <bernalex> sufficed to say that it's *a lot* simpler than in vim
13:17:52 <bernalex> you can just M-X package-install or whatever it's called, install haskell-mode, and then M-X haskell-mode, and then life is quite good already.
13:17:56 <Welkin> davidkart: join #emacs and ask away
13:18:02 <bernalex> yeah #emacs is really great
13:18:11 <bernalex> well. mostly. :p
13:18:30 <davidkart> hitting keyboard hard
13:18:36 <davidkart> going to sleep
13:18:38 <Welkin> although the current conversation is something about historical russian politics or something
13:19:44 <Shou> Is there something space-leaky-dangerous about IO functions calling themselves recursively? Does it keep things in memory from past iteration(s)? Or should I use monad-loops?
13:19:50 <bernalex> the only bad part about switching to emacs ime thus far is everyone always telling you "you're just not doing it the emacs way!!!" whenever there's something I dislike
13:19:51 <ertes> kqr: one reason i prefer pipes over conduit is simplicity
13:20:14 <bernalex> even when there are horrible design choices in emacs, it's just "you need to emacs harder" lol
13:20:35 <Welkin> pipés
13:21:11 <ertes> kqr: you understand the basic semantics (in particular regarding when everything aborts), and you remember 'await', 'yield' and (>->)
13:21:17 <ertes> kqr: everything else is convenience
13:21:26 <Welkin> I found conduit a little confusing
13:21:35 <kqr> fr33domlover: thanks. examples are cool!
13:21:40 <Welkin> after going through the pipes tutorial, I felt I understood pipes pretty well
13:22:05 <ertes> Shou: IO is in many ways like lazy lists that are evaluated and discarded element by element
13:22:17 <ertes> Shou: so no, generally there is nothing wrong with recursion
13:22:26 <kqr> ertes: huh I had the opposite impression -- conduit being more intuitive than pipes. mind expanding on your position?
13:22:27 <ertes> Shou: in fact it's the only way to repeat
13:22:58 <hpc> in many ways except for all of the other ways
13:22:59 <ertes> kqr: conduit has more builtin stuff
13:23:12 <hpc> IO hasn't been a lazy list for several decades now
13:23:26 <hpc> so don't actually learn that as being the way it actually is
13:23:56 <hpc> but the conclusion does still stand that recursion is perfectly fine with IO
13:24:10 <ertes> hpc: the lazy DSL interpretation of IO is actually pretty much the only one everybody thinks is fine
13:24:29 <ertes> i don't understand why you're saying all of that
13:25:29 <ertes> do you have "[Response] -> [Request]" in mind somehow?  because that's not at all what i meant
13:25:46 <hpc> ertes: ah
13:25:58 <hpc> you said "list" and my mind went back 20 years :P
13:26:24 <hpc> the DSL is a great mental model in every way except extending it with FFI and whatnot
13:26:34 <hpc> (which there are ways around that too, but still)
13:28:40 <Shou> ertes: I know things like `forever` are safe but what about a large function that does a lot, dealing with data parsing and let binds things, before calling itself at the end?
13:30:59 <ertes> Shou: same thing
13:31:16 <Shou> Oh nice, thanks.
13:31:20 <Welkin> all calls are tail calls, because there is no call stack
13:31:23 <Welkin> from my understanding
13:31:46 <ertes> Shou: forever is a library function, too
13:31:57 <ertes> Welkin: it's not about tail calls in this case
13:32:25 <ertes> IO should indeed be interpreted like a lazy data structure rather than a control construct
13:32:57 <ertes> if 'cycle' for lists is fine, then 'forever' for IO is also fine
13:33:35 <Welkin> I'd love to dig into the internals of ghc eventually, but I am happy with how it was explained to me as "the entire program is one big equation"
13:34:24 <hpc> technically it's one big expression ;)
13:47:13 <Shou> ertes: Yeah but forever separates the 
13:47:28 <Shou> functions basically
13:47:53 <Shou> Their scopes aren't accessible to forever or eachother
13:48:09 <ertes> Shou: 'fix' doesn't and it's fine, too =)
13:48:23 <ertes> Shou: fix (\again x -> …) x0
13:48:42 <ertes> and actually i would consider it a bug, if there were a difference
13:49:00 <ertes> forever c = let cs = c >> cs in cs
13:49:15 <ertes> but then (c >> cs) is just (c >>= \_ -> cs)
13:51:24 <ertes> so it's not like 'forever' can't refer to the result of the earlier action, but more like it chooses not to
13:53:59 <Iceland_jack> If it has an Applicative instance then actually it can't
13:54:07 <Iceland_jack>     forever c = c *> forever c
13:54:33 <travism> I barely even know how to play it 
13:54:39 <travism> er wrong channel lol
13:54:47 <ertes> Shou: the thing that determines whether you IO actions will compose properly has nothing to do with recursion, but with associativity
13:54:51 <Iceland_jack> using let
13:54:52 <Iceland_jack>     forever c = let cs = c *> cs in cs
13:55:10 <ertes> Shou: right-associated IO is always fine:  c >> (d >> (e >> f))
13:56:33 <ertes> Shou: if 'forever' were defined like this, it wouldn't work:  forever c = let cs = cs >> c in cs  -- for the same reason building infinite lists from the back doesn't work
13:57:42 <ertes> the reason is that those are left-associated:  ((… >> c) >> c) >> c  -- the run-time will never figure out what the first action is
13:58:01 <ertes> so it will never start executing
13:58:03 * hackagebot BlogLiterately 0.8.4 - A tool for posting Haskelly articles to blogs  https://hackage.haskell.org/package/BlogLiterately-0.8.4 (BrentYorgey)
14:03:03 * hackagebot pagination 0.1.0 - Framework-agnostic pagination boilerplate  https://hackage.haskell.org/package/pagination-0.1.0 (mrkkrp)
14:04:31 <fishythefish> Is there a specific feature of CPO I can point to as the reason that inductive and coinductive types coincide?
14:09:52 <Denommus> is something like OCaml's ocsigen doable in Haskell yet?
14:09:57 <linoge> Hi, I don't fully get why the singleton instance () is a terminal object of Set while Void is the initial. I'm starting on Category Theory. If there are any relevant resources that explain it more... fully, I'd really appreciate sharing :-)
14:10:53 <fishythefish> linoge: Do you know what it means to be an initial/terminal object?
14:11:13 <Iceland_jack> linoge: Being terminal means that there is an arrow 
14:11:13 <Iceland_jack>     foo :: a -> ()
14:11:13 <Iceland_jack>  
14:11:17 <fishythefish> Category Theory for Programmers is a blog you might enjoy
14:11:24 <Iceland_jack> but that it is also a *unique* such function 
14:11:25 <Shou> ertes: I mean what I'm thinking is the choosing not to refer to the result and the function scopes being inaccessible are the parts imply that no leaks can occur?
14:11:29 <ertes> linoge: how many (total) functions of type Integer -> () can you write?
14:11:34 <Shou> In forever.
14:11:36 <Iceland_jack>     foo :: a -> ()
14:11:36 <Iceland_jack>     foo _ = ()
14:11:58 <ertes> Shou: the part that implies no leaks is associativity
14:12:04 <linoge> Only one.
14:12:11 <ertes> linoge: what about Bool -> ()?
14:12:19 <jackhill> Denommus: what is ocsigen
14:12:26 <jackhill> is it http://ocsigen.org/ ?
14:12:32 <Iceland_jack> linoge: In normal Hask category, initial/terminal objects are basic
14:12:34 <linoge> Still one, as you can disregard whatever value gets passed to the function
14:12:40 <ertes> linoge: do you see why () is terminal?
14:12:54 <Shou> ertes: Oh alright
14:13:17 <Iceland_jack> In the same way, Void is initial because there is a (unique) function FROM it
14:13:17 <Iceland_jack>     initial :: Void -> a
14:13:17 <Iceland_jack>     initial = ...
14:13:22 <EvanR> theres a notion of sameness among functions which may not be obvious
14:13:26 <EvanR> but is used a helluva lot
14:13:43 <ertes> Shou: keep your IO right-associated, and everything is fine…  and it literally translates to having recursion as the last action in a do-block for obvious reasons =)
14:13:49 <fishythefish> EvanR: are you referring to intensional vs extensional equality?
14:14:13 <linoge> Well, that clears it up pretty well. I think I just needed it rephrased :-D.
14:14:16 <EvanR> i dont know what intensional equality is
14:14:23 <linoge> Thank you very much Iceland_jack :)
14:14:37 <Iceland_jack> linoge: You may think "this seems boring and slightly useless"
14:14:48 <Iceland_jack> but in categories with more structure, it becomes a lot more interesting
14:14:53 <EvanR> two haskell functions are the same if their behavior is the same
14:15:11 <fishythefish> EvanR: that's extensional equality; intensional equality is having the same definition
14:15:16 <EvanR> hmm ok
14:15:28 <buglebudabey> is there a good way to clean this up? maybe break up the first case on line 8 into two lines? http://lpaste.net/169783
14:15:40 <ertes> linoge: note also that (initial :: Void -> a) is a family of functions…  for every type 'a' 'initial' is the only function you can write of type (Void -> a)
14:16:01 <linoge> And that's what unique up to isomorphism means right?
14:16:04 <Iceland_jack> linoge: Note that the functions from/to Void/() reverse the arrow
14:16:04 <Iceland_jack>     initial  :: Void -> a
14:16:04 <Iceland_jack>     terminal :: a    -> ()
14:16:19 <Iceland_jack> linoge: Yes, because you can have many "terminal" objects
14:16:37 <Iceland_jack>     data Term = T
14:16:37 <Iceland_jack> is a terminal object
14:16:37 <Iceland_jack>     terminal' :: a -> Term
14:16:37 <Iceland_jack>     terminal' _ = T
14:16:44 <ertes> linoge: data X = X; data Y = Y  -- all terminal
14:16:49 <fishythefish> buglebudabey: use `maybe` from Data.Maybe? I don't know what you're looking for
14:16:53 <ertes> linoge: but also all isomorphic to each other
14:17:20 <Iceland_jack> linoge: That's why we talk about *the* initial object, *the* terminal object
14:17:21 <buglebudabey> fishythefish formatting really? but thanks for that tip
14:17:46 <Iceland_jack> even though you can have multiple initial/terminal objects, they are ‘the same’ (isomorphic)
14:17:48 <EvanR> hmm that doesnt sound right
14:18:01 <fishythefish> buglebudabey: seems okay to me. Although I prefer a newline after "of" so that I don't have to indent everything so far
14:18:07 <EvanR> "the same" is not the same as isomorphic
14:18:15 <Iceland_jack> Hence the quotes
14:18:16 <fishythefish> EvanR: hence the quotes
14:18:19 <Denommus> jackhill: yeah, that
14:18:21 <Iceland_jack> lol
14:18:23 <ertes> we have a few levels of "the same"
14:18:23 <fishythefish> :)
14:18:44 <EvanR> in a category with 4 objects, all isomorphic... it doesnt have 1 object
14:18:51 <Iceland_jack> I didn't want to get into the discussion of equality
14:19:07 <EvanR> i dont think you usually talk about objects being actually the same
14:19:12 <ertes> going into category theory is actually a good point to consider the question of equality =)
14:19:39 <EvanR> you know which objects youre talking about or quantifying over all of them
14:19:44 <fishythefish> EvanR: That's true from the point of the typechecker, for example, but it's often easier to reason about objects up to isomorphism
14:19:48 <Denommus> the individual components of ocsigen are easily surpassed by Haskell libraries (using servant instead of Eliom, GHCJS instead of js_of_ocaml, reflex instead of React), but ocsigen has something these unrelated libraries doesn't have, which is transparent communication between client and server
14:19:58 <Iceland_jack> EvanR: For what it's worth https://www.quora.com/What-is-an-intuitive-way-to-explain-isomorphism-mathematics
14:19:58 <Iceland_jack>     “Intuitively, two objects are isomorphic if they are the same (except possibly in their representations).”
14:20:05 <EvanR> yuck
14:20:06 <jackhill> Denommus: okay. I'm not sure if I can really answer you question, but you can do client side and server side sharing code via ghcjs, but I don't know how easy that is to do with off the shelf components compared to ocsigen.
14:20:16 <ertes> lol
14:20:23 <linoge> But saying they are the same implies that it is an automorphism doesn't it?
14:20:25 <EvanR> given an object A, the only object which is the same as A is A
14:20:26 <Iceland_jack> But more formally, you can go back and forth without losing information
14:20:26 <Iceland_jack>     hither () = T
14:20:26 <Iceland_jack>     yon    T  = ()
14:20:26 <fishythefish> Isomorphism means objects behave the same way even if they're not actually identical, so we can reason modulo isomorphism
14:20:36 <EvanR> but isomorphic is another thing
14:20:38 <ertes> that's as good as: "the things are equal, if they are equal (except possibly they look differently)"
14:20:46 <jackhill> Denommus: oh, and I see your second reply. Yeah, I have no idea.
14:20:47 <Denommus> jackhill: client and server side code is shared by compiling the same module twice, right? Once in GHC and then in GHCJS
14:21:05 <shachaf> If you're talking about categories, isomorphism is too strong.
14:21:05 <EvanR> yeah so you have to append "up to isomorphism" after everything
14:21:16 <ertes> isomorphism as a concept is simpler than equality, so i wouldn't even go for equality
14:21:16 <fishythefish> shachaf: objects in categories at the moment
14:21:28 <ertes> just say "a terminal object" instead of "the terminal object"
14:21:38 <ertes> the latter has no advantage, but introduces all sorts of complexity
14:21:42 <fishythefish> EvanR: right, and syntactic sugar for that is putting quotes around everything :P
14:21:43 <EvanR> yes
14:21:50 <shachaf> ertes: No way, you need equality to define isomorphism.
14:22:12 <Iceland_jack> ertes: That's how people usually talk about objects that have a universal mapping property
14:22:41 <ertes> shachaf: but you can disregard equality between objects
14:22:46 <EvanR> fishythefish: i want to define this kind of quotes as a different operator
14:23:01 <EvanR> at least get more precise about what the quotes do here
14:23:05 <Iceland_jack> "The free monoid M(A) on a set A is by defintiion "the" monoid with the following so called universal mapping property ...." from Awodey's book
14:23:43 <Iceland_jack> [a] is the free monoid on a, Natural is the free monoid on (), Void is the free monoid on () etc.
14:23:48 <linoge> I had no idea my basic question would turn on such an instructing discussion :O
14:23:58 <fishythefish> linoge: welcome to #haskell
14:24:05 <Jinxit> what is the difference between an isomorphism and homomorphism?
14:24:10 <linoge> Love it c:
14:24:12 <EvanR> yurg... dont you rather say a free monoid is such and such ... and then later "there is only one up to isomorphism"
14:24:16 <ertes> linoge: your question just turned out not to be that simple =)
14:24:18 <EvanR> makes more sense
14:24:36 <Iceland_jack> EvanR: That's how people speak in CT especially
14:24:41 <EvanR> linoge: we didnt even get into what = means!
14:24:42 <fishythefish> Jinxit: an isomorphism is a homomorphism that has an inverse
14:25:05 <Iceland_jack> You can call (a, b) *the* product of a and b, and people know what you mean
14:25:06 <Jinxit> aren't homomorphism structure-preserving or w/e the proper word is?
14:25:07 <ertes> linoge: observe:
14:25:15 <fishythefish> Jinxit: yes, but only in one direction
14:25:18 <ertes> hey people, how do i pass application configuration around implicitly?
14:25:29 <Jinxit> fishythefish: got any practical examples?
14:25:43 <Iceland_jack> ertes: HEY HAVE YOU TRIED ‘reflection’
14:25:46 <Jinxit> I mean I get it now, but just want to see an example
14:25:50 <fishythefish> Jinxit: consider the homomorphism from any group to the trivial group; this is clearly not an isomorphism
14:26:00 <EvanR> Iceland_jack: hrm... yuck. thats more like saying "the sum" because you agreed on only one sum operation earlier
14:26:09 <EvanR> numerical sum i mean
14:26:27 <EvanR> thats why we know what you mean
14:26:28 <fishythefish> Jinxit: you preserve the behavior of the group operation going to the trivial group, but there's no way to recover the original structure of the group you started with
14:26:45 <Welkin> EvanR: "The Sum" sounds like a trendy new reality TV show
14:26:56 <Iceland_jack> "The Coproduct: LA"
14:26:57 <ertes> Iceland_jack: not ReaderT?
14:27:14 <EvanR> "The Recursor"
14:27:57 <ertes> "The Identity Revelation"
14:28:40 <Welkin> "Oh no! He's hacking into our system!" *shows the back of a guy's head and the guy is typing randomly on a keyboard with an irc client open to ##javascript*
14:29:08 <Jinxit> fishythefish: aha, didn't actually know that was a homomorphism, thank you
14:29:14 <Jinxit> very new to CT
14:29:30 <ertes> i wanna see the movie that portrays hacking into a system as a physicist aligning lasers to operate a quantum computer
14:29:47 <ertes> that might be more realistic than pretty much everything actual movies do
14:30:32 <fishythefish> Jinxit: have you studied morphisms just in the context of e.g. group theory, ring theory, etc. rather than the full generality of CT?
14:30:39 <EvanR> f (x ★ y) = f x ★ f y -- homomorpism pattern
14:30:42 <Iceland_jack> EvanR: http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf
14:30:42 <Iceland_jack>     "When are two types the same? In this paper we argue that isomorphism is a more useful notion than equality."
14:31:11 <Iceland_jack> I regret using the word "equal" without a qualifier :)
14:31:22 <EvanR> Iceland_jack: especially if there i have no other meaningful way to identify two different types
14:31:25 <Iceland_jack> It's risky in #haskell
14:31:37 <EvanR> since there.. not the same
14:31:46 <fishythefish> Iceland_jack: yeah, they start to demand a formal grammar for what quotes mean :P
14:31:54 <Iceland_jack> EvanR: Yeah you mentioned that
14:32:15 <maerwald> there should be #haskell-nitpick
14:32:24 <fishythefish> maerwald: oh, is this not it?
14:32:24 <EvanR> well, theres quoted text... and then theres makeThisWrong(_)
14:32:31 <Jinxit> fishythefish: I took discrete maths but it's all a haze
14:33:25 <fishythefish> Jinxit: gotcha. Well, it's not impossible to study CT on its own, especially if you can at least apply concepts to types, but having concrete examples from various specific categories can be a useful thing
14:33:30 <ertes> > (\xs -> if null xs then "none" else show (head xs)) [3,5,7]
14:33:31 <lambdabot>  "3"
14:37:58 <EvanR> isomorphic is a thing in category theory... is "homotopic" from topology somehow a kind of isomorphism
14:39:43 <EvanR> what kind of category would that be
14:39:53 <fishythefish> EvanR: I don't see why not. Let the objects of your category be the continuous functions between two topological spaces
14:39:58 <linoge> Mmm, if I let the internet, interpreted as a collection of web pages with a morphism `linksTo`, and impose that each page should at least link to another and to itself.
14:40:03 <fishythefish> with morphisms between objects iff they're homotopic
14:40:04 <linoge> That's a category right?
14:40:17 <shachaf> Not really.
14:40:33 <shachaf> There's no composition.
14:40:39 <fishythefish> linoge: you don't even have to impose that each page links to another, just itself - and linksTo must be transitive
14:40:43 <dmwit> linoge: You can turn any graph into a category: let the objects be nodes of the graph, and arrows be paths in the graph.
14:40:45 <Iceland_jack> linoge: You can talk about "reachability"
14:40:51 <shachaf> But the -- what dmwit said.
14:40:57 <daey> could it be that substraction is a bit difficult with recursion?
14:41:01 <shachaf> That's the category you want. Paths from page to page, not links.
14:41:04 <Iceland_jack> From A you can reach website B
14:41:06 <daey> at least im stuck T_T
14:41:25 <dmwit> linoge: There are other ways, too, of course.
14:41:45 <linoge> I guess I phrased it badly. But then the initial and terminal objects would not exist would they?
14:42:01 <linoge> Or would the initial object be a kind of master index with links to all nodes/webpages?
14:42:12 <EvanR> fishythefish: hmm that seems to have a typing issue
14:42:24 <Iceland_jack> linoge: It depends on what your arrows are
14:42:34 <EvanR> because of the particular spaces involved
14:42:44 <fishythefish> EvanR: oh, did I miss something?
14:42:51 <dmwit> linoge: The category corresponding to a graph that has a cycle certainly does not have an initial or terminal object.
14:43:04 <ertes> daey: what's "substraction"?
14:43:06 <EvanR> fishythefish: you could have this category for each pair of spaces
14:43:14 <fishythefish> EvanR: sure
14:43:16 <dmwit> linoge: (Where when I say "corresponding" in that last sentence, I mean the translation I described above.)
14:43:26 <EvanR> ok
14:43:31 <shachaf> I'd say it's the free category on a graph or something, rather than corresponding.
14:43:41 <linoge> And a cycle would be represented as a composition of arrows that takes me from A to B then C then A again?
14:43:49 <dmwit> linoge: The category corresponding to a tree may have an initial or final object.
14:44:39 <EvanR> fishythefish: and every morphism would be an isomorphism?
14:44:42 <linoge> But in a Tree with N different leaves there would be no terminal object?
14:44:47 <EvanR> part of an isomorphism
14:44:48 <fishythefish> EvanR: yes, I believe so
14:44:56 <Iceland_jack> linoge: If your arrow is (<=) then an initial object is the minimal element
14:45:04 <fishythefish> Homotopy is an equivalence relation
14:45:04 <dmwit> linoge: Well, representation is a whole other thing. =) But you have the right basic idea: a cycle would give rise to an object with two different arrows, id_A (the empty path) and cycle_A (the path that goes through some other nodes first).
14:45:18 <EvanR> fishythefish: what is composition?
14:45:28 <Iceland_jack> Because for every other element in, say, [0..]
14:45:29 <Iceland_jack>     0 <= n 
14:45:29 <Iceland_jack>     
14:45:31 <dmwit> linoge: And moreover we have the property that id_A . f /= cycle_A . f, so there can be no final object. Likewise for terminal objects.
14:45:58 <dmwit> s/terminal/initial/ s/final/terminal/
14:46:07 <linoge> Ok I think I get it :).
14:46:10 <fishythefish> EvanR: oh, hm, typing issue
14:46:16 <Iceland_jack> There is no terminal object in [0..] because there is no largest element
14:47:24 <linoge> I guess I'll grasp the entire thing as I continue reading :)
14:47:25 <dmwit> shachaf: Sure, that's more precise.
14:47:32 <dmwit> shachaf: Good suggestion, I'll take it henceforth.
14:47:44 <fishythefish> EvanR: okay, well, the category of topological spaces with morphisms given by homotopy equivalence might be a better example
14:48:00 <EvanR> fishythefish: since the morphisms are facts about two functions, i guess composition is just rephrasing the subjects of the facts
14:48:39 <EvanR> A = B, and B = C ---> A = C
14:48:47 <EvanR> ok boring
14:48:49 <Iceland_jack> linoge: The natural numbers are an initial object
14:49:23 <fishythefish> EvanR: well, you could compose homotopies like this: perform each homotopy twice as fast and "concatenate" them
14:49:36 <linoge> Of, let's say [N, R] where real numbers would be a final object?
14:49:37 <davidkart> mhello tilili lala how do you get an instance into an object 
14:49:39 <fishythefish> EvanR: ignore the typing issue comment - I think this works
14:49:56 <davidkart> i mean a member in a Data construct
14:50:00 <EvanR> yeah if the morphisms were the homotopy themselves
14:50:13 <fishythefish> Yeah, that was my first example
14:50:15 <EvanR> rather than assertions
14:50:19 <fishythefish> In the second one, the morphisms are homotopy equivalence
14:50:26 <et09> take 1 [ i | i <- map (\x -> 2^x) [1..], i `mod` 15 == 0 ]
14:50:32 <et09> this is an infinite loop right?  what's the correct way
14:50:35 <dmwit> davidkart: There is an answer to that. But the question is weird enough that I feel compelled to make sure you really mean it. Can you give some more context about what you want to do?
14:50:35 <EvanR> "there is an arrow ... if ..."
14:50:44 <fishythefish> Note also that homotopy equivalence gives rise to other isomorphisms, e.g. between homology/cohomology groups
14:50:55 <davidkart> data Person = Person String Int Thing
14:50:56 <davidkart>   deriving Show
14:51:12 <EvanR> Iceland_jack: er... N is an initial object in what category?
14:51:18 <davidkart> how do I get for example the "String" field ?
14:51:29 <dmwit> davidkart: getString (Person s _ _) = s
14:51:32 <Iceland_jack> Category of certain algebras
14:51:41 <davidkart> ok
14:51:42 <EvanR> certain algebras?
14:51:43 <dmwit> davidkart: or use a `case` expression where it's needed
14:51:50 <fishythefish> davidkart: you can also look into record syntax
14:51:52 <EvanR> is certain a math word
14:52:09 <dmwit> davidkart: or use record syntax, e.g. `data Person = Person { name :: String, age :: Int, thing :: Thing }`, which will define `name` to be essentially identical to `getString` above.
14:52:11 <Iceland_jack> that's right, for natural numbers they are the initial object in category of F-algebras
14:52:15 <Iceland_jack> where
14:52:16 <Iceland_jack>     F X = 1 + X
14:52:49 <fishythefish> type Nat = Fix Maybe :)
14:52:50 <EvanR> the category of (1 +)-algebras
14:53:04 * hackagebot heckle 0.1.0.0 - Jekyll in Haskell  https://hackage.haskell.org/package/heckle-0.1.0.0 (2016rshah)
14:53:07 <Iceland_jack> So we can again talk about *the* natural numbers, which is what we went
14:53:11 <Iceland_jack> *what we want
14:53:15 <davidkart> dmwit: I prefer the first one, it's much more elegant imho
14:53:24 <davidkart> the second is more clear though.
14:53:42 <davidkart> Thank you 
14:53:50 <EvanR> is that "the" natural numbers the same natural numbers as the natural number object in category of sets? ;)
14:53:57 <Iceland_jack> Yes
14:54:01 <fishythefish> EvanR: up to isomorphism :P
14:54:03 <EvanR> in "the" "the" sense
14:54:05 <Iceland_jack> In a more general sense, yes
14:54:18 <Iceland_jack> there is a thing called the natural number object
14:54:24 <et09> is there not a power of 2 that's divisible by 15?
14:54:25 <et09>  take 1 [ i | i <- [1..], 2^i `mod` 15 == 0 ]
14:54:35 <fishythefish> et09: no, they're only divisible by 2 and powers of 2
14:54:37 <dmwit> There is not a power of 2 that's divisible by 15.
14:54:41 <et09> dammit
14:54:42 <davidkart> MMh wait I have another question. Could I do that thing : getString a = x where a=(Person x _ _) ?
14:54:44 <et09> all that effort for nothing
14:54:46 <fishythefish> et09: look at the prime factorization
14:55:04 <davidkart> et09: you don't need a computer for that :)
14:55:09 <et09> Prelude> take 1 [ i | i <- [1..], 2^i `mod` 128 == 0 ]
14:55:09 <et09> [7]
14:55:11 <dmwit> davidkart: Yes, but the equality is backwards. `name a = x where Person x _ _ = a`.
14:55:18 <et09> best feature of haskell probs
14:55:26 <et09> in my dumb opinion
14:55:30 <dmwit> > logBase 2 128
14:55:32 <lambdabot>  7.0
14:55:34 <fishythefish> ^
14:55:44 <davidkart> Just ok
14:55:53 <et09> figures
14:55:59 <EvanR> fishythefish: in what category could you say these two natural number types are isomorphic
14:56:54 <davidkart> EvanR: btw it makes me think about Peano axioms.
14:56:57 <fishythefish> EvanR: Set?
14:56:59 <dmwit> EvanR: Going out on a limb here: CAT
14:57:23 <davidkart> There is a non-axiomatic construct of natural numbers.
14:57:26 <fishythefish> dmwit: but we're not treating the natural numbers as a category in their own right
14:57:37 <EvanR> peano is boring, natural number objects are cooler
14:58:01 <dmwit> fishythefish: You're right.
14:58:19 <davidkart> yes, natural number... Then, if you follow the definition, you have a lot of possibilities to define the set of natural numbers I believe.
14:58:39 <EvanR> fishythefish: i guess you can make the one from Maybe-algebras to Set and then do it in Set
14:58:43 <EvanR> can map
14:59:14 <davidkart> there you go https://en.wikipedia.org/wiki/Set-theoretic_definition_of_natural_numbers
14:59:19 <EvanR> yuck
14:59:33 <fishythefish> EvanR: yeah, if you apply the forgetful functor then I think what I said works out in Set
14:59:50 <EvanR> ah right, functors
15:00:02 <EvanR> its how you get from one category to another
15:00:54 <Profpatsch> Hm, it’s quite challenging to implement an Eq for Existentials.
15:01:08 <Jinxit> how are CT and haskell functors related?
15:01:16 <Profpatsch> data A = forall a. Eq a => A a
15:01:26 <Profpatsch> instance Eq A where
15:01:27 <Iceland_jack> Profpatsch: that won't work
15:01:29 <EvanR> haskell functors are endofunctors, from hask back to hask
15:01:50 <EvanR> the type ctor, like Maybe, is mapping the type
15:01:55 <Jinxit> what are the objects and arrows in hask?
15:01:56 <EvanR> and fmap is mapping the functions on that type
15:01:59 <fishythefish> The initial algebra of a functor F can be viewed as the limit of the forgetful functor from F-alg to Hask, I believe
15:02:00 <shachaf> Profpatsch: The real answer is that it's impossible.
15:02:01 <Profpatsch>   (A a1) == (A a2) = a1 == a2
15:02:10 <fishythefish> Jinxit: objects are types, morphisms are functions between them
15:02:13 <Iceland_jack> Profpatsch: When you write
15:02:13 <Iceland_jack>     A x == A y = ...
15:02:13 <Iceland_jack> 'x' and 'y' may have completely different types
15:02:15 <joe_____> @faq Is predicate a functor?
15:02:15 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:02:18 <Profpatsch> a1 and a2 don’t have to be the same type, of course
15:02:22 <Jinxit> neat, thanks
15:02:30 <Iceland_jack> You could write (A () == A True) which makes no sense 
15:02:36 <shachaf> The funny answer is something like "instance Eq A where A x == A y = (x == x) == (y == y)"
15:02:45 <Profpatsch> But can’t I contrain in so that they are and if they are not, it is False?
15:02:47 <Zemyla> Profpatsch: data A = forall a. (Eq a, Typeable a) => A a
15:02:58 <shachaf> Zemyla: That's the worst answer of them all.
15:02:59 <Iceland_jack> Profpatsch: Typeable
15:03:01 <Iceland_jack> ;)
15:03:05 * hackagebot genvalidity-hspec 0.1.0.1 - Standard spec's for GenValidity instances  https://hackage.haskell.org/package/genvalidity-hspec-0.1.0.1 (Norfair)
15:03:07 <shachaf> I mean, maybe not the worst.
15:03:15 <EvanR> can we get even worse answers
15:03:16 <Profpatsch> But it’s not the most correct? :)
15:03:17 <Iceland_jack> afk
15:03:20 <EvanR> will it blend
15:03:30 <shachaf> It works fine.
15:03:30 <fishythefish> EvanR: always return True :P
15:03:38 <Profpatsch> I see the problem, yes.
15:03:51 <fishythefish> Actually, always producing False is arguably worse?
15:03:53 <EvanR> upio return rand()
15:04:18 <Profpatsch> (==) :: a -> a -> Bool
15:04:19 <EvanR> literally, not even casted to a Bool
15:04:46 <Profpatsch> So if the types are different, the function cannot be defined.
15:04:51 <davidkart> :t filter
15:04:52 <lambdabot> (a -> Bool) -> [a] -> [a]
15:05:04 <Profpatsch> Since they can be different, the function cannot be defined.
15:05:09 <EvanR> Profpatsch: yes, what are you even trying to do
15:05:17 <Profpatsch> EvanR: haha, true.
15:05:21 <Profpatsch> The same thing as before.
15:05:30 * EvanR facepalm
15:05:41 <EvanR> ok
15:05:53 <Profpatsch> I have a ParseError = foreach a. (Show a, Eq a) => OtherError a
15:06:01 <EvanR> oh nevermind
15:06:07 <Profpatsch> And I thought maybe that would work.
15:06:09 <Zemyla> A x == A y | x `seq` y `seq` False = undefined; A x == A y = isTrue# (dataToTag# x ==# dataToTag# y)
15:06:21 <Profpatsch> But apparently it doesn’t because Eq can’t be defined in that case.
15:06:29 <EvanR> why do you need Eq a
15:06:41 <Zemyla> Profpatsch: The best thing you can do is compare show x to show y.
15:06:50 <Profpatsch> Because I have tests which use Eq to check for a wanted output.
15:06:58 <Profpatsch> Zemyla: urgs
15:07:04 <Profpatsch> Nah, that’s dirty, is it not?
15:07:19 <EvanR> for Exceptions you can embed them in a bigger global type with equality
15:07:27 <EvanR> and compare those
15:07:42 <EvanR> but i would expect test frameworks to be able to deal with this without having to do that?
15:07:43 <Zemyla> Profpatsch: And ypu can't add a Typeable constraint?
15:07:54 <Profpatsch> No idea about Typeable.
15:07:57 <Profpatsch> Will look it up.
15:08:14 <Profpatsch> But people here told me that’s dirty as well a few minutes ago. :)
15:08:38 <EvanR> fishythefish: actually... isomorphic in Set (bijective) seems a lot more boring than i originally was hoping for
15:08:55 <EvanR> you lost the structure of the numbers
15:08:56 <fishythefish> EvanR: is isomorphism ever really that exciting?
15:08:58 <shachaf> Maybe I exaggerated.
15:09:05 <Profpatsch> My actual thing is that I have three function that return different Either e1 a, Either e2 b …
15:09:16 <Profpatsch> And I want to >>= them
15:09:23 <fishythefish> EvanR: well, yeah, it's Set. There is no structure.
15:09:49 <fishythefish> That being said, it's fairly easy to represent Peano numbers as the least fixed point of Maybe
15:10:07 <EvanR> so you need to map the NNO from set to the Maybe algebras somehow and do it there
15:10:30 <Profpatsch> So I convert e1, e2 to e3 and >>= that
15:10:40 <EvanR> since thats the category that has the structure that matters... the Z and S operations
15:10:58 <Profpatsch> And put e1, e2 in e3’s forall a. (Show a, Eq a) => OtherError a.
15:11:06 <EvanR> but how do you get the set NNO out of there intact
15:11:22 <hey2> Is Learn You A Haskell For Great Good a good book to start with?
15:11:31 <fishythefish> hey2: IMO yes
15:11:31 <maerwald> no
15:11:34 <fishythefish> well
15:11:41 <EvanR> a functor from set doesnt care about operations
15:11:42 <hey2> I know nothing about the language
15:11:42 <Taneb> hey2, I thought so
15:11:48 <Welkin> haskell fight!
15:11:55 <hey2> It sounds pretty interesting though
15:11:56 <Taneb> hey2, however some of the later chapters are somewhat out of date
15:12:06 <Taneb> And it doesn't go as far as I'd like
15:12:07 <hpc> it has some problems, mostly lack of exercises and teaching the old mtl
15:12:08 <hey2> So there's some errata?
15:12:14 <fishythefish> Yes
15:12:14 <shachaf> The new edition of Hutton's _Programming in Haskell_ will be out next month.
15:12:16 <maerwald> 1. it's outdated, 2. it's too verbose and is not concise, 3. it doesn't have any useful execises 
15:12:18 <Welkin> hey2: it's a fun book to read, but not a good way to learn haskell
15:12:25 <fishythefish> ^
15:12:25 <shachaf> The first edition was good but it's a bit out of date now.
15:12:36 <fishythefish> That being said, I've found it does a good job at getting people interested
15:12:42 <fishythefish> So it depends a bit on your needs
15:12:46 <hpc> if you can read through it and learn to write haskell programs from it, it's a good book
15:12:50 <hey2> Would it be a good book to read through and absorb to kind of get the gist of it?
15:12:57 <maerwald> imo, no
15:12:58 <hey2> I mostly do C/C++ stuff
15:13:02 <hey2> ok
15:13:20 <Welkin> @where learnhaskell -- hey2 start here
15:13:20 <lambdabot> https://github.com/bitemyapp/learnhaskell
15:13:27 <maerwald> it's a good book if you like pictures and weird analogies
15:13:39 <hey2> it kind of reminded me of the head first series by oreilly
15:13:41 <Welkin> it has clint eastwood and mario monster in it
15:13:46 <maerwald> not if you want concise and useful definitions/explanations of stuff you can memorize
15:13:56 <hey2> lol
15:14:10 <hpc> if you get into LYAH and find you don't like it, there's also learnhaskell as mentioned, or RWH
15:14:15 <hpc> @where rwh
15:14:15 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:14:27 <hey2> ok
15:14:51 <puregreen> shachaf: have you already had a chance to explain what mistakes you found in Haskellbook? I remember you talking about it, but I think I disconnected after that or something.
15:14:53 <hpc> you should probably start with learnhaskell first though
15:15:17 <hey2> Yorgey's course?
15:15:22 <maerwald> yes
15:15:30 <hey2> thats a cool last name
15:15:39 <davidkart> :product
15:15:42 <davidkart> :t product
15:15:43 <lambdabot> (Num a, Foldable t) => t a -> a
15:15:45 <maerwald> it's a little outdated too I think, but the exercises are very useful and challenging
15:15:50 <hey2> Oh it has homework even
15:16:03 <maerwald> and it explains stuff in the correct order
15:16:06 <davidkart> mm ok
15:16:13 <hpc> yeah, it's a full-blown 100-level course
15:16:22 <hpc> at upenn
15:16:26 <hey2> Did you find it took as long as the timeline suggests?
15:16:31 <hey2> Like, 12 weeks?
15:16:31 <hey2> lol
15:16:32 <davidkart> oh, i'm just a beginner but I'm working on this : http://www.seas.upenn.edu/~cis194/lectures/03-ADTs.html
15:16:33 <maerwald> you can do it faster
15:16:36 <hey2> okay
15:16:50 <maerwald> 4-6 weeks I'd say depending on your time. You still need stuff to sink in
15:16:51 <davidkart> hey2: if you'd like to do it we could share knowledge.
15:16:59 <hpc> when i learned haskell, i did it by going through LYAH and writing an irc bot
15:17:02 <hey2> I am starting it right now
15:17:03 <hpc> took about a month to get that far
15:17:14 <hey2> I'm taking a abstract data structures class this summer but not really doing much else
15:17:34 <hpc> it doesn't really stop, but that's how long it took for me to get to the point where i felt i could write a program that you would compile and run that did stuff
15:18:31 <hey2> much experience before?
15:18:48 <hpc> i was about halfway through a CS degree
15:18:51 <davidkart> hey2: if you have a lot of spare time and a strong motivation you can go high
15:18:52 <hey2> ok
15:19:16 <hey2> meaning, lol
15:19:23 <EvanR> i learned haskell in the process of doing PHP work
15:19:35 <davidkart> well Haskell is quite hard but it is really insightful for programming (in general)
15:19:54 <EvanR> to make server programs to do stuff in the background because PHP does not like that
15:20:01 <hey2> I keep reading that a good grasp of it goes a long ways on a resume all else equal
15:20:06 <linoge> EvanR: lol, I had the same start :O
15:20:11 <hey2> because its so different
15:20:20 <maerwald> hey2: maybe, but haskell jobs are _very_ rare
15:20:22 <systemfault> EvanR: Wow.
15:20:26 <systemfault> What a story.
15:20:35 <EvanR> sarcastic?
15:20:38 <systemfault> No.
15:20:44 <davidkart> you won't land a job in Haskell unless you are a top notch computer scientist with tons of background and knowledge I think.
15:20:49 <systemfault> PHP usually leads to mediocrity.
15:20:52 <maerwald> hey2: so if you do this to push your resume, there are better language choices
15:20:53 <systemfault> Not Haskell...
15:20:57 <Welkin> davidkart: lol, no
15:20:58 <EvanR> the difference between PHP and haskell was insane
15:21:04 <hey2> maerwald, I am not, I am doing this because I am interested
15:21:16 <hey2> I tried using brainfuck for a bit but I couldn't accomplish much
15:21:18 <Welkin> maerwald: what is with you?
15:21:20 <hey2> more of a curiosity thing
15:21:21 <maerwald> hey2: good, because you'd be disappointed when you search for actual haskell jobs
15:21:22 <davidkart> EvanR: actually the difference between haskell and any script language is insane
15:21:25 <Profpatsch> hey2: The Haskellbook might be a better experience.
15:21:28 <ertes> davidkart: you don't need to be a computer scientist…  case in point: me
15:21:34 <maerwald> Welkin: ?
15:21:36 <Welkin> you are always telling every newcomer who wants to learn haskell that they should learn something else
15:21:36 <davidkart> ok
15:21:42 <shachaf> puregreen: I gave a few quotes, but most of them were from the sample, which I skimmed.
15:21:47 <maerwald> Welkin: that's a misinterpretation
15:22:04 <davidkart> ah yes I agree
15:22:05 <Profpatsch> hey2: Oh lol, was offline for a bit and my client didn’t send the message a while back.
15:22:13 <hey2> lol its all good
15:22:21 <davidkart> but to dig in needs real motivation
15:22:24 <shachaf> puregreen: They took the sample PDF down the next day.
15:22:25 <puregreen> Welkin: you can bash me instead, I have personally persuaded someone not to learn Haskell once
15:23:04 <linoge> I actually, from a humble point of view, think that learning Haskell and Lisp is a good thing.
15:23:04 <maerwald> Welkin: if someone goes to learn haskell with the intention to improve his resume, he's on the wrong track. That's just the way it is. So it's better they really do it out of interest.
15:23:07 <hey2> I'm learning Japanese right now and I had the same opposition to it from other people, don't learn it it's not useful etc, I am just doing it out of curiosity and because it's something different
15:23:08 <shachaf> puregreen: If you want you can read the logs at <http://tunes.org/~nef/logs/haskell/16.07.01>.
15:23:15 <hey2> I am reading Learn Lisp the Hard Way too
15:23:32 <hey2> same reason lol
15:24:16 <bernalex> maerwald: actually, plenty of companies will fast track you if there's haskell on your résumé.
15:24:20 <davidkart> well my question was : could I have a function that makes a product set : f n [Objects] = [[Objects]]
15:24:25 <davidkart> (cartesian product)
15:24:31 <maerwald> bernalex: not here
15:24:32 <puregreen> shachaf: okay, thanks
15:24:33 <bernalex> maerwald: I've received several interviews where they went "we saw haskell on your cv, so we just called you in immediately"
15:24:42 <bernalex> maerwald: they didn't want me to actually *use* haskell though...
15:24:42 <linoge> I think it helps you think about problems differently, in a more mathematical way, that means abstract, that means better doesn't it?
15:24:58 <davidkart> well haskell programmers are the best ones, even if they work with other languages :)
15:25:00 <maerwald> bernalex: yes, most write "haskell" in their job description to pull in "smart people"
15:25:02 <hey2> more ways to approach the same situation is always better
15:25:02 <systemfault> bernalex: Usually means for them that you're passionate about programming to some extent...
15:25:06 <shachaf> puregreen: There are a bunch more things. Just about every page I look at I see problems, some more serious than others.
15:25:13 <bernalex> shachaf: exactly
15:25:54 <bernalex> well. systemfault: exactly. but. you both start with an 's', and you're both green. so.
15:26:12 <systemfault> Ha
15:26:15 <ertes> if i were to hire a software engineer, and they would have haskell on their CV, i'd challenge them to write a command line log parser with reasonable UX in less than 8 hours
15:26:22 <Welkin> it's true that learning haskell just to get a job is a bad reason to learn haskell, because most companies don't even know what haskell is. They only know and want java or javascript
15:26:45 <davidkart> stop telling that Welkin
15:26:46 <maerwald> Welkin: exactly, so there are better choices if you want to strategically improve your CV
15:26:46 <Profpatsch> ertes: I’d probably fail. So bad.
15:27:01 <maerwald> the easiest thing is to look up the Tiobe index and pick the top 10 lol
15:27:04 <davidkart> in fact Haskell is a great fundation to learn any language.
15:27:24 <systemfault> Welkin: The idea is... if someone has a language that isn't usually taught at school on their resume, it shows genuine interest in programming.
15:27:38 <systemfault> And possibly... better.
15:27:44 <maerwald> systemfault: I think you are overestimating that
15:27:57 <linoge> davidkart: Not an expert but product xs = [ (a,b) | a <- xs , b <- xs ] ?
15:28:06 <systemfault> maerwald: Possibly.
15:28:07 <maerwald> it's just something that catches the eye of the interviewer, but that's about it
15:28:17 <davidkart> yeah, the same with list and arbitrary length ?
15:29:22 <davidkart> :t concatMap
15:29:23 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
15:29:42 <ertes> Profpatsch: the point is just to see whether they are capable of focussing on the actual problem:  take command line options, parse a log file, print output
15:30:05 * EvanR puts brainfuck on the resume
15:30:13 * EvanR waits for job offers
15:30:18 <ertes> EvanR: and it's probably the truth =)
15:30:24 <ertes> i'd put unlambda on my resume
15:30:35 <maerwald> systemfault: I've actually had 2 interviews now where they were concerned about "haskell" on my CV, like... can he be bothered with anything else but haskell?
15:30:40 <ertes> brainfuck i can't code for the same reason i can't code PHP =)
15:31:00 <maerwald> so if you talk too much about haskell, they will think you are a fanboy and too complicated to work with
15:31:04 <EvanR> put brainfuck and PHP in the same section of the resume
15:31:12 <EvanR> PHP jobs might stop calling
15:31:59 <EvanR> maerwald: idea to deal with that, put "i assure you I do not know haskell"
15:32:27 <maerwald> EvanR: I usually pretend that haskell is only useful for very few domains (like, it's not really a general purpose language)
15:32:29 <maerwald> ofc that's a lie
15:32:29 <davidkart> what does it mean the => in 
15:32:30 <maerwald> but it works
15:32:32 <davidkart> :t concatMap
15:32:33 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
15:32:34 <davidkart> ?
15:32:48 <davidkart> and what is a Foldable anyway ?
15:32:53 <davidkart> (in general I mean)
15:32:53 <EvanR> stuff to the left of => are constraints
15:32:59 <ertes> davidkart: look at the type signature of (+) first
15:33:02 <ertes> :t (+)
15:33:03 <lambdabot> Num a => a -> a -> a
15:33:05 <davidkart> ok
15:33:08 <davidkart> I get it.
15:33:13 <Profpatsch> maerwald: They will see when you replace all your convenience scripts with short haskell modules.
15:33:14 <davidkart> thank you EvanR
15:33:31 <ertes> davidkart: "Foldable" means "can be reduced like a list of elements"
15:33:40 <EvanR> :t fold
15:33:41 <lambdabot> (Foldable t, Monoid m) => t m -> m
15:33:43 <davidkart> so you can apply map, filter, etc.
15:33:53 <davidkart> ha! I saw the word Monoid
15:33:53 <EvanR> map would be Functor
15:34:05 <davidkart> now i can't take anymore
15:34:06 <ertes> "fold" is haskell slang for "reducing to a value"
15:34:13 <davidkart> yes to fold 
15:34:18 <Profpatsch> maerwald: And as always, there’s two types of Haskell programmers: The ones who get shit done and the ones who bother with Existentials.
15:34:18 <davidkart> to fold a map
15:34:21 <maerwald> Profpatsch: heh, the last company I went to put haskell in the job description because a former employee did some haskell stuff and is now gone. They have no one who knows that crap xD
15:34:46 <Profpatsch> maerwald: I hope you converted them all. :P
15:34:50 <EvanR> > fold ["i","wanna","be","the","very","best"]
15:34:52 <lambdabot>  "iwannabetheverybest"
15:34:53 <maerwald> and they surely don't want to do that again so soon
15:35:28 <EvanR> thats probably a confusing example
15:35:37 <davidkart> > fold [1..10]
15:35:38 <lambdabot>      No instance for (Show a0)
15:35:38 <lambdabot>        arising from a use of ‘show_M450659049435276138710378’
15:35:38 <lambdabot>      The type variable ‘a0’ is ambiguous
15:35:48 <davidkart> :t prod
15:35:49 <lambdabot>     Not in scope: ‘prod’
15:35:49 <lambdabot>     Perhaps you meant ‘pred’ (imported from Prelude)
15:35:53 <davidkart> :t product
15:35:54 <lambdabot> (Num a, Foldable t) => t a -> a
15:36:07 <davidkart> :t concatMap
15:36:08 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
15:36:09 <Profpatsch> maerwald: And a good programmer can learn any language in two weeks anyway. Right? RIGHT?
15:36:14 <EvanR> > fold $ Just (Sum 10)
15:36:16 <lambdabot>  Sum {getSum = 10}
15:36:20 <maerwald> Profpatsch: well....
15:36:22 <davidkart> what is a monoid ?
15:36:23 <ertes> :t getProduct . foldMap Product
15:36:24 <lambdabot> (Num c, Foldable t) => t c -> c
15:36:29 <davidkart> :t monoid
15:36:30 <lambdabot> Not in scope: ‘monoid’
15:36:46 <Profpatsch> maerwald: Since all programming languages are the same. :P
15:36:47 <crough> :t Control.Lens.ala
15:36:48 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
15:36:50 <EvanR> Monoid types are "fusable"
15:36:58 <EvanR> > "abc" <> "123"
15:36:59 <lambdabot>  "abc123"
15:37:00 <davidkart> so the stuff (a->[b]) is actually a function right ?
15:37:03 <EvanR> :t (<>)
15:37:04 <lambdabot> Monoid m => m -> m -> m
15:37:14 <crough> > Control.lens.ala Data.Monoid.Product foldMap [1,2,3,4,5]
15:37:16 <lambdabot>  Not in scope: ‘Control.lens’
15:37:17 <davidkart> that's confusing I shouldn't have asked
15:37:21 <crough> > Control.Lens.ala Data.Monoid.Product foldMap [1,2,3,4,5]
15:37:23 <lambdabot>  120
15:37:27 <crough> ;)
15:37:47 <davidkart> what about (a->[b]) then, is it a function ?
15:37:53 <crough> yes
15:37:54 <EvanR> thats a function type
15:38:04 <crough> oh, well, yes @EvanR realy
15:38:10 <davidkart> and the t a that comes second, what is it ?
15:38:16 <crough> type variable
15:38:18 <EvanR> crough how the heck do you pronounce this nick
15:38:23 <crough> like the bird
15:38:24 <crough> crow
15:38:29 <crough> it's my given name yo
15:38:37 <crough> well surname. that's pretty different
15:38:45 <EvanR> its incredibly ambiguous heh
15:38:53 <crough> can't help that much :)
15:39:25 <EvanR> davidkart: t a is a type variable applied to a type variable
15:39:32 <EvanR> so t has kind * -> * 
15:39:57 <davidkart> > concatMap f             =  foldr ((++) . f) []
15:39:59 <lambdabot>  <hint>:1:25: parse error on input ‘=’
15:40:13 <Profpatsch> davidkart: a -> [b] is a function from any a to a list of any b
15:40:18 <davidkart> :t foldr
15:40:19 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:40:26 <Profpatsch> a could be Int, String, …
15:40:30 <ertes> davidkart: it also helps to look at the history of some of these things…  most of the functions that look like "t a -> b" used to look like "[a] -> b"
15:40:38 <ertes> davidkart: foldr is a good example
15:40:42 <EvanR> davidkart: example t could be [ ], in which case t a is [a]
15:40:48 <davidkart> ha ok
15:40:53 <davidkart> but are you sure that's it ?
15:40:58 <davidkart> I mean, yeah
15:41:00 <davidkart> ok
15:41:21 <davidkart> so in the past, the only foldable things where bracket lists[], is it so ?
15:41:22 <ertes> davidkart: we generalised away from just lists to any structure that holds values
15:41:27 <davidkart> ha ok
15:41:32 <davidkart> it must have been long ago.
15:41:34 <EvanR> [ ], Maybe, Map String are all * -> *
15:41:52 <EvanR> note Map String, not Map or String
15:41:52 <ertes> davidkart: no, Foldable existed for a long time, but only recently we started to generalise Prelude functions
15:42:04 <ertes> :t sum
15:42:05 <lambdabot> (Num a, Foldable t) => t a -> a
15:42:15 <ertes> this one now can sum anything that is Foldable
15:42:18 <ertes> > sum (Just 5)
15:42:20 <davidkart> wow maybe I need some sleep some day.
15:42:21 <lambdabot>  5
15:42:36 <EvanR> > sum ()
15:42:36 <davidkart> so let's do it again
15:42:37 <lambdabot>      Couldn't match expected type ‘t0 a’ with actual type ‘()’
15:42:37 <lambdabot>      In the first argument of ‘sum’, namely ‘()’
15:42:37 <lambdabot>      In the expression: sum ()
15:42:40 <ertes> and any foldable type that you define yourself
15:42:41 <Profpatsch> davidkart: Note that it was a controversial change, exactly because it could be confusing to newcomers. ;)
15:42:41 <davidkart> :t concatMap
15:42:42 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
15:42:46 <EvanR> oops
15:43:00 <ertes> @let data Vec3 a = Vec3 a a a  deriving (Eq, Foldable, Functor, Ord, Show, Traversable)
15:43:02 <lambdabot>  Defined.
15:43:03 <EvanR> Profpatsch: confusing... or just incomprehensible
15:43:07 <ertes> > sum (Vec3 5 7 11)
15:43:09 <lambdabot>  23
15:43:23 <ertes> davidkart: so you get a lot of stuff for free for your own types
15:43:27 <davidkart> so given a function that takes type 'a' and return a list of 'b' as the first argument, and a Foldable a as a second argument, it will give a list of b
15:43:34 <Profpatsch> EvanR: Hm, it’s not that bad. I mean (Foldable t) is quite understandable.
15:43:56 <EvanR> Profpatsch: yes once you understand what the syntax means and then what Foldable is
15:43:58 <Profpatsch> EvanR: Of course you’d first have to understand that it is possible at all *cough* higher kinded types
15:44:05 <EvanR> *crough*
15:44:14 <crough> heheh
15:44:15 <ertes> davidkart: try writing the type of that function
15:44:18 <crough> good work
15:44:27 <Profpatsch> EvanR: Isn’t that exactly what the new Haskellbook tries to solve? :)
15:44:33 <ertes> davidkart: may be less convoluted than a description in prose =)
15:44:41 <EvanR> no idea
15:44:43 <Profpatsch> Starting from the beginning and then building everything up?
15:44:44 <EvanR> which book
15:45:03 <Profpatsch> EvanR: http://haskellbook.com/
15:45:24 <EvanR> that domain name is annoying
15:45:35 <shachaf> That book is unfortunately full of wrong and sloppy things.
15:45:39 <shachaf> I don't recommend it.
15:45:43 <EvanR> the book is called "Haskell Programming from First Principles" by bitemyapp
15:45:55 <EvanR> "haskell book" is an entire class of things
15:46:33 <Profpatsch> So much social tension in the air. :P
15:46:49 <Profpatsch> shachaf: What do you recommend then? LYAH?
15:46:55 <EvanR> maybe we can specify it with HPfFP
15:47:37 <Profpatsch> Or just “First Principles”, “FP” :D
15:47:51 <puregreen> given the amount of publicity they generated, I kinda suspect “Haskellbook” is unambiguous in the same way “iPhone” is
15:47:52 * Profpatsch goes hide
15:48:06 <shachaf> Well, I liked Hutton's book, _Programming in Haskell_. It's a bit outdated now, but the next edition will be coming out in August.
15:48:26 <EvanR> puregreen: i was afraid of that...
15:48:40 <shachaf> puregreen: Yes, they like to do that sort of thing. Just like one of the authors named his channel, unaffiliated with this one, "#haskell-beginners".
15:48:50 <EvanR> i cant wait until i can walk into the bar and order "beer" too
15:48:57 <shachaf> Now people say "that book is the official book of the official beginner channel!".
15:49:01 <shachaf> Oh well.
15:49:18 <maerwald> are we talking about that unfree book?
15:49:31 <hpc> shachaf: careful, fp complete will start #haskell-lang-beginners
15:49:32 <EvanR> shachaf: it basically is... 
15:49:39 <EvanR> except for the channel being official
15:49:46 <Profpatsch> Can’t we just agree that everything has its pros and cons and every path where one learns the language is a good path?
15:50:09 <EvanR> also this channel isnt really official is it
15:50:30 <EvanR> its just large and old
15:50:30 <puregreen> hpc: FPComplete will start an open-access Slack group for Haskell and you won't even notice how after a while it'll have more users than this channel
15:50:43 <Profpatsch> I mean in my experience the only way to *really* learn the language is to ask thousands of questions in here.
15:50:47 <maerwald> non-free learning materials are immorale
15:50:54 <puregreen> maerwald: why?
15:51:15 <puregreen> Profpatsch: my experience wasn't like this at all, I just read RWH and the source of base
15:51:16 <maerwald> because knowledge should be free and not be defined by your wallet
15:51:22 <EvanR> and immemorial
15:51:28 <Profpatsch> Because noone uses IRC and it will be out of date in 1999!
15:51:38 <davidkart> maerwald: technically, a book is free (you can download it or buy it for cheap if you're already rich). The real cost of a book is almost moot.
15:51:40 <Profpatsch> Completely outdated.
15:51:48 <Jinxit> Profpatsch: by 2999 maybe
15:51:50 <Jinxit> -maybe-
15:52:12 <EvanR> slack is doomed
15:52:13 <puregreen> Profpatsch: people use IRC, it's just that people use Slack too and I suspect they might be using Slack more
15:52:15 <Jinxit> maerwald: and you think people should work for free then?
15:52:16 <davidkart> > concatMap iter [1..8] where iter n = [1..n]
15:52:17 <lambdabot>  <hint>:1:23: parse error on input ‘where’
15:52:19 <Iceland_jack> <Profpatsch> I have a ParseError = foreach a. (Show a, Eq a) => OtherError a
15:52:19 <Iceland_jack> Add a tag that you compare on
15:52:19 <Iceland_jack>  
15:52:46 <davidkart> > iter n = [1..n] in concatMap iter [1..8]
15:52:48 <lambdabot>  <hint>:1:8: parse error on input ‘=’
15:52:49 <Profpatsch> Iceland_jack: huh, how?
15:52:54 <davidkart> > let iter n = [1..n] in concatMap iter [1..8]
15:52:56 <maerwald> Jinxit: no
15:52:56 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8]
15:53:08 <davidkart> :) I did it :)
15:53:09 <Profpatsch> I didn’t even remember list comprehensions existed. oO
15:53:28 <Iceland_jack> That's reasonable in many cases
15:53:28 <Iceland_jack>     data ParseError where
15:53:29 <Iceland_jack>       Err :: Show a => Tag -> a -> ParseError
15:53:29 <Iceland_jack> and then your tag can be 
15:53:30 <ertes> they certainly know how social media works, and how to exploit people's feelings to build a community ("you're a beginner? come here! you're a minority? come here!")
15:53:31 <Iceland_jack>     data Tag = ErrorA | ErrorB | ErrorC deriving Eq
15:53:46 <Iceland_jack> Then 
15:53:46 <Iceland_jack>     instance Eq ParseError where
15:53:46 <Iceland_jack>       Err tag1 _ == Err tag2 _ = tag1 == tag2
15:54:49 <shachaf> I don't mind the cost of that book. I only mind the quality.
15:54:53 <begriffs> It sucks how IRC shows no history to people when they join the channel unless they use an IRC bouncer, and the capability to paste nice code blocks is bad too. However switching to Slack just makes me sad because it's yet another centralized commercial entity eating the open web.
15:54:55 <Profpatsch> Iceland_jack: Hm, so you mean I should combine the three Error types into one?
15:54:57 <davidkart> > let iter n = [1..n] in concatMap iter [1..n]
15:54:59 <lambdabot>  *Exception: not an integer: n
15:55:06 <davidkart> > let iter n = [1..8] in concatMap iter [1..n]
15:55:08 <lambdabot>  *Exception: not an integer: n
15:55:12 <EvanR> begriffs: well, #haskell has extensive public logs
15:55:13 <davidkart> > let iter n = [1..8] in concatMap iter [1..8]
15:55:15 <lambdabot>  [1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6...
15:55:38 <hpc> begriffs: on another network i run a bot that does that
15:55:38 <EvanR> begriffs: and slack only keeps your history if you pay
15:55:40 <davidkart> > let iter n = [[x]|x<-[1..8]] in concatMap iter [1..8]
15:55:41 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[1],[2],[3],[4],[5],[6],[7],[8],[1],[2],[3]...
15:55:48 <begriffs> EvanR: good point. OK I'll stop griping about random things and let people get back to the haskelling. :)
15:56:04 <hpc> it'll PM you the last few lines it saw in channels it's in, if you set your history to something non-zero
15:56:25 <tempeh> Am I correct in saying that if you have a functional dependency a -> b, if you define an instance where a is fully concrete, b must also be fully concrete?
15:56:38 <ertes> tempeh: nope
15:56:53 <ertes> tempeh: you have a functional dependency when one follows from the other, regardless of how concrete
15:57:24 <tempeh> I'm trying to fix a library that has an instance of type KRPC (Query GetPeers) (Response (GotPeers ip))
15:57:42 <ertes> tempeh: technically you have a functional dependency when in the class definition you state what follows from what
15:57:43 <tempeh> and getting a liberal coverage condition fails in class ‘KRPC’ error
15:58:41 <Profpatsch> Iceland_jack: That GADT uses an existential for a, right?
15:58:51 <tempeh> right. So the dependency is in the class, which is defined as class KRPC req resp | req -> resp where
15:58:53 <Profpatsch> I still have to grok GADTs.
15:59:11 <hpc> GADTs are pretty simple
15:59:32 <hpc> start with GADTSyntax, which is just another way to write regular ADTs
15:59:42 <hpc> take something like data Maybe a = Nothing | Just a
15:59:44 <hpc> it translates to
15:59:46 <Profpatsch> The problem is they expand the way in which you can define your data.
15:59:47 <hpc> data Maybe where
15:59:52 <linoge> begriffs: how do you feel about gitter?
15:59:58 <hpc>   Nothing :: Maybe a
16:00:03 <hpc>   Just :: a -> Maybe a
16:00:05 <Profpatsch> And that means I know even less about how I should design my types. :(
16:00:28 <hpc> oh, you mean in the sense of using it, not just what it is
16:00:58 <Profpatsch> Yeah, more possibilities mean it’s harder to design stuff.
16:01:01 <begriffs> linoge: I use gitter actually. Philosophically I feel the same about it as I do about Slack but I gave in so that my OSS contributors have a nice experience.
16:01:40 <Profpatsch> begriffs: And they log in with their Github credentials. ;)
16:02:21 * begriffs wipes a tear off his face
16:02:32 <ertes> Profpatsch: you don't need GADTs most of the time, and when you do, you'll know
16:02:40 <Profpatsch> hpc: What can I encode more with them that I can’t with ADTs?
16:02:51 <Profpatsch> Except from existentials
16:03:05 <ertes> Profpatsch: so don't worry too much…  if you want to learn them, just do, but don't expect to "get the point", unless you have a specific use case
16:03:11 <hpc> you can do something like
16:03:16 <hpc> data FastMap k v where
16:03:28 <hpc>   IntMap :: IntMap v -> FastMap Int v
16:03:56 <hpc>   HashMap :: Hashable k => HashMap k v -> FastMap k v
16:04:07 <Profpatsch> ertes: If I don’t learn about them, how will I know when I have a use case? :P
16:04:10 <hpc>   -- not sure about this one, might need extra extensions
16:04:19 <hpc> and then a constructor for just a regular Map
16:04:25 <ertes> Profpatsch: when the type you're trying to write somehow can't be written =)
16:04:40 <Profpatsch> ertes: I had such a problem recently.
16:04:45 <hpc> maybe SetMap :: Set k -> FastMap k ()
16:04:58 <ertes> Profpatsch: summary of GADTs: you learn something about types during pattern-matching
16:05:02 <travism>   /win 2
16:05:02 <hpc> it's also good for writing eDSLs
16:05:04 <travism> er
16:05:19 <Profpatsch> I wanted to encode component entiy systems with them.
16:05:29 <hpc> you don't gain terribly much as far as expressiveness from them, but you can add a bit more type safety
16:05:37 <ertes> Profpatsch: let me use hpc's example of FastMap:  case myFastMap of IntMap xs -> _intMapBranch
16:05:39 <Profpatsch> But it somehow wasn’t possible, exactly because pattern matching didn’t work.
16:05:40 <hpc> (when used that way)
16:06:01 <ertes> Profpatsch: in _intMapBranch you *know* that k = Int, even though it's polymorphic outside of it
16:06:30 <exio4> so, what do you think of having a typeclass and instances representing configuration? class Tables t where { tables_users_acc :: Proxy t -> String; [...] }? I am doing this to have implicit configurations 
16:06:57 <exio4> which other approaches are there to do this?
16:06:58 <ertes> Profpatsch: here is a simpler GADT to emphasise just that:  data Something :: * -> * where SomeInt :: Int -> Something Int; SomeText :: Text -> Something Text
16:07:09 <EvanR> Profpatsch: you can load this is ghci and play with Door to see how it works http://lpaste.net/169790
16:07:27 <ertes> Profpatsch: now you write a function: f :: Something a -> a  -- note how the function is fully polymorphic in 'a', so it doesn't know what 'a' is going to be
16:07:50 <ertes> Profpatsch: f (SomeInt x) = x + 3  -- yet in the SomeInt branch in can use (+), because after the match the function learned that a = Int
16:08:08 <ertes> Profpatsch: (the technical term for this is *type refinement*)
16:09:07 <tempeh> So if you have something like "class C a b | a -> b", to what degree does a need to determine b? I don't think you can have "instance C Int b", I think you can have "instance C Int Float", but can you have "instance C Int [b]" or something? Does the second type have to be concrete if the first is?
16:10:06 <EvanR> instance C [a] (Maybe a)
16:10:08 <ertes> tempeh: imagine you had a type family parameterised over 'a' to give 'b'…  basically the same restrictions apply
16:10:23 <ertes> tempeh: good:  instance C [a] (Maybe a)
16:10:30 <ertes> tempeh: bad:  instance C [Int] (Maybe a)
16:10:39 <ertes> (a would be out of scope)
16:10:55 <EvanR> you need flexible foos for this 
16:10:57 <EvanR> i think
16:11:09 <ertes> i'd expect it to fail even with FlexibleInstances
16:11:14 <ertes> @let class C a b | a -> b
16:11:16 <lambdabot>  Defined.
16:11:17 <EvanR> the good one
16:11:27 <ertes> @let instance C [a] (Maybe a)
16:11:28 <lambdabot>  Defined.
16:11:35 <ertes> @let instance C (Maybe Int) [a]
16:11:37 <lambdabot>  .L.hs:169:10:
16:11:37 <lambdabot>      Illegal instance declaration for ‘C (Maybe Int) [a]’
16:11:37 <lambdabot>        The liberal coverage condition fails in class ‘C’
16:11:37 <Profpatsch> ertes: So Something can only be Something Int or Something Text?
16:11:50 <tempeh> right. that makes sense
16:11:58 <Profpatsch> Not Something MyType?
16:12:08 <tempeh> I'm trying to doctor an old library into compiling, i guess i'll have to go back and make it concrete
16:12:10 <ertes> Profpatsch: yeah
16:13:14 <ertes> Profpatsch: and once you matched, you can make assumptions:  f (SomeText txt) = txt <> T.pack "blah"  -- yes, 'txt' is indeed a Text, and the result of 'f' is now also known to be a Text
16:13:19 <davidkart> I can't do the cartesian product with concatMap
16:13:28 <davidkart> I am a miserable failure
16:13:37 <davidkart> :t concatMap
16:13:38 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
16:14:00 <davidkart> let say [1..8] is the set that I want to raise to power n
16:14:27 <davidkart> Then [1..8] is a set
16:14:32 <davidkart> and [b] is a set of set
16:14:56 <davidkart> So the definition of concatMap would read (a->[a])-> t a->[[a]]
16:15:06 <davidkart> So the definition of concatMap would read (a->[a])-> t a->[a]
16:15:10 <davidkart> actually a==b
16:15:23 <ertes> davidkart: let t = []
16:16:01 <davidkart> So the definition of concatMap would read (a->[a])-> [a]->[a]
16:16:06 <davidkart> where a is a set
16:16:21 <davidkart> so how do you get a set of set from a set ?
16:16:23 <ertes> davidkart: you're trying to write a function?
16:16:26 <davidkart> yes
16:16:43 <ertes> what's the type of that function?
16:16:52 <davidkart> for size one, it reads [[x]|x<-a]
16:17:08 <davidkart> the type is f:: a->[a]
16:17:19 <ertes> f 5 = ?
16:17:29 <davidkart> No wait
16:17:46 <davidkart> it is f:: Int->a->[a]
16:17:55 <ertes> f 5 7 = ?
16:18:28 <davidkart> it is rather this ? f:: Int->[a]->[[a]]
16:18:37 <ertes> davidkart: you tell me =)
16:18:41 <davidkart> f 5 [7] = [[7,7,7,7,7]]
16:18:48 <ertes> f 3 [1,2] = ?
16:19:35 <davidkart> f 3 [1,2] = [1,2]×[1,2]×[1,2] =[ [1,1,1],[1,1,2],[1,2,1],...]
16:19:57 <ertes> you will be very surprised to find that f is actually predefined =)
16:20:06 <ertes> but let me not tell you what it is yet
16:20:21 <davidkart> but tell me what it is
16:20:26 <davidkart> I was looking for it
16:20:32 <ertes> > replicateM 3 [1,2]
16:20:34 <lambdabot>  [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
16:20:49 <davidkart> ertes: so it is a monad, then.
16:20:53 <davidkart> Here it is.
16:20:59 <ertes> "it"?
16:21:16 <ertes> anyway, that's why i wanted not to show it
16:21:34 <davidkart> Damn, I never thought I could encounter such a dreadful thing by wanting to do some trivial operation on sets.
16:21:51 <davidkart> ertes: I could try to write it down with other stuff.
16:22:06 <davidkart> I need concatMap
16:22:18 <davidkart> Then I need a correct mapping
16:22:27 <davidkart> :t replicateM
16:22:29 <lambdabot> Monad m => Int -> m a -> m [a]
16:23:44 <ertes> f is a bit tricky to write, but not impossible…  let's figure it out
16:23:47 <davidkart> damn I can't find the correct operation
16:23:50 <ertes> f 0 xs = ?
16:23:57 <davidkart> f 0 xs = []
16:24:00 <ertes> nope
16:24:13 <davidkart> f 0 xs = [[]]
16:24:17 <davidkart> (?)
16:24:26 <ertes> yeah…  do you see, why?
16:24:36 <davidkart> yes, the type must be enforced anyway.
16:24:49 <ertes> f 0 xs = []  -- that one is well-typed, too, but it's incorrect
16:24:55 <ertes> do you see why it's incorrect?
16:25:47 <exio4> I found it easier to start from the recursive/inductive definition
16:25:50 <davidkart> I'd say that I see why [[]] is correct. From set theory and rules on power set, A^0 × A = A
16:26:07 <ertes> davidkart: ok, now we need a recursive case
16:26:27 <davidkart> yes, we need a recursive case
16:26:36 <ertes> but let's try a non-trivial non-recursive one first
16:26:41 <ertes> f 1 xs = ?
16:26:44 <ertes> wait
16:26:46 <davidkart> say f 1 xs = [xs], this is the identity I believe.
16:26:53 <ertes> nope, that's wrong
16:27:06 <ertes> f 1 [1,2,3] = ?
16:27:19 <davidkart> I'd say it is [[1],[2],[3]]
16:27:23 <ertes> correct
16:27:37 <ertes> f 1 xs = ?  -- can you write this?
16:27:40 <davidkart> so I wrote it like [[x]|x<-xs]
16:27:50 <ertes> try without list comprehension
16:27:56 <ertes> try using 'map' instead
16:28:12 <davidkart> ha ok so it would be map (\x ->[x] ) xs ?
16:28:37 <ertes> yeah…  now let's see a harder non-trivial case
16:28:40 <davidkart> > map (\x -> [x] ) [1..3]
16:28:41 <lambdabot>  [[1],[2],[3]]
16:28:41 <ertes> f 2 [1,2,3] = ?
16:29:59 <davidkart> wow it goes with a recursive map, isn't it ?
16:30:30 <ertes> we'll use recursion, but not exactly 'map' =)
16:31:03 <ertes> but before we do that, what's the answer?
16:31:05 <davidkart> from this point I was looking on a more iterative like solution
16:31:20 <ertes> it is iterative in nature
16:31:29 <ertes> you'll see how
16:32:08 <davidkart> something like f 2 xs = [ x:y | x<-xs, y<-(f 1 xs)]
16:32:26 <ertes> f 2 [1,2,3] = [[1,1], [1,2], [1,3], [2,1], [2,2], [2,3], [3,1], [3,2], [3,3]]
16:32:51 <ertes> but there is a repetition pattern
16:33:18 <ertes> @let xs' = [[1], [2], [3]]
16:33:20 <lambdabot>  Defined.
16:33:33 <davidkart> So it would be f n xs = [x:y| x<-xs,y<-(f (n-1) xs)]
16:33:55 <ertes> > map (\x -> x : xs) [1,2,3]
16:33:57 <lambdabot>      Not in scope: ‘xs’
16:33:57 <lambdabot>      Perhaps you meant one of these:
16:33:57 <lambdabot>        ‘x’ (line 1), ‘x’ (imported from Debug.SimpleReflect),
16:34:00 <ertes> > map (\x -> x : xs') [1,2,3]
16:34:02 <lambdabot>      No instance for (Show t0)
16:34:02 <lambdabot>        arising from a use of ‘show_M40654910751701537711651’
16:34:02 <lambdabot>      The type variable ‘t0’ is ambiguous
16:34:06 <ertes> oh, come on
16:34:15 <ertes> > map (\x -> map (x :) xs') [1,2,3]
16:34:17 <lambdabot>  [[[1,1],[1,2],[1,3]],[[2,1],[2,2],[2,3]],[[3,1],[3,2],[3,3]]]
16:34:31 <hpc> wait what
16:34:34 <hpc> oh
16:34:41 <hpc> missed "map" there
16:34:55 <ertes> davidkart: do you see how what i wrote is not quite right
16:34:56 <ertes> ?
16:34:57 <davidkart> here is where the concatMap may come in handy ?
16:35:06 <davidkart> yes, not quite good
16:35:21 <ertes> but if you just concat the result, it's right
16:35:26 <ertes> > concat (map (\x -> map (x :) xs') [1,2,3])
16:35:28 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
16:35:48 <ertes> and that turns out to be a very common thing to do, so there are two functions to do it, one of which is concatMap
16:36:05 <ertes> > concatMap (\x -> map (x :) xs') [1,2,3]
16:36:07 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
16:36:23 <davidkart> but where do you put your integer ?
16:37:01 <davidkart> ho common i'm almost lost
16:37:11 <ertes> davidkart: this is the result of f 2 [1,2,3]
16:37:22 <ertes> f 2 [1,2,3] = [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
16:37:33 <ertes> and we just found a way to rewrite that
16:37:55 <ertes> f 2 [1,2,3] = concatMap (\x -> map (x :) [[1], [2], [3]]) [1,2,3]
16:38:06 <ertes> davidkart: with me so far?
16:38:14 <ertes> nothing fancy, just a different way to write it
16:38:16 <davidkart> yes
16:38:34 <ertes> now [[1], [2], [3]] happens to be f 1 [1,2,3]
16:38:37 <davidkart> so it was the first call
16:38:39 <davidkart> yes
16:38:50 <ertes> f 2 [1,2,3] = concatMap (\x -> map (x :) (f 1 [1,2,3])) [1,2,3]
16:39:01 <ertes> and this happens to work for every argument list, not just [1,2,3]
16:39:12 <ertes> f 2 xs = concatMap (\x -> map (x :) (f 1 xs)) xs
16:39:16 <davidkart> so f n [1,2,3] = concatMap(\x->map(x:) f n-1 [1,2,3]) [1,2,3] ?
16:39:28 <ertes> remember to use parentheses properly
16:39:36 <davidkart> ok
16:39:46 <davidkart> ghc always tell me they are not necessary in many cases
16:39:50 <ertes> but yeah, you're on the right track
16:42:22 <buglebudabey> if i do [A0,....,An] ++ [] is that O(n)? or does haskell know not to evaluate it completely
16:42:22 <davidkart> mmh
16:42:33 <davidkart> I am still thinking on it.
16:42:40 <davidkart> I believe I need to sleep before moving on.
16:42:51 <davidkart> buglebudabey: you are right, I think it is O(n)
16:43:10 <davidkart> but am not sure 
16:43:16 <davidkart> buglebudabey: try it :
16:43:45 <ertes> davidkart: if you combine my last generalisation with your last generalisation, you have the recursive case =)
16:44:00 <ertes> i generalised the list argument, you generalised the count argument
16:48:05 <davidkart> i'm not sure
16:48:25 <ertes> davidkart: let me correct yours:
16:48:28 <davidkart> f 2 [1,2,3] = concatMap (\x -> map (x :) [[1], [2], [3]]) [1,2,3]
16:49:06 <ertes> f n [1,2,3] = concatMap (\x -> map (x :) (f (n-1) [1,2,3])) [1,2,3]
16:49:10 <davidkart> I wrote that : f 2 [1,2,3] = concatMap (\x -> map (x :) [[1], [2], [3]]) [1,2,3]
16:49:13 <davidkart> stupid VIM
16:49:28 <davidkart> f n xs= concatMap(\x->map(x:) (f n-1 xs))  f 1 xs = map(\x->[x]) xs 
16:49:40 <mikail`> Hi, I need to some advice on the design on this module: http://lpaste.net/169792. I'm wondering if it is the correct use of typeclasses since both instances are using the *same* implementation of the functions.
16:52:39 <alzevir> test
16:53:30 <mikail`> The reason why I did it like this is because I wasn't able to write a single price function which would take different types.
16:54:43 <maerwald> micro-optimization, spend your time with something more useful :P
17:15:21 <schell> is there a way to set up my cabal/stack project for backward compatibility (pre applicative monad) without having my project generate tons of warnings when using ghc 7.10+?
17:16:03 <hpc> probably CPP and testing the ghc version or something
17:16:47 <schell> i hope that’s not the only way - i don’t like using CPP if i can get away with it :( 
17:16:53 <hpc> what warnings are you getting?
17:17:30 <schell> ‘importing data.monoid is redundant’ ‘importing control.applicative is redundant’ 
17:17:33 <schell> i think that’s it
17:17:57 <hpc> ah, you can probably just disable that particular warning
17:18:02 <schell> of course if you don’t import those, it breaks on ghc <= 7.8
17:18:22 <schell> hmm - i’ll have to look at the ghc options
17:18:39 <schell> i would like it to warn of _other_ redundant imports though
17:18:59 <hpc> yeah, and then it's back to CPP
17:19:05 <hpc> or something like that :(
17:19:18 <Profpatsch> ertes: EvanR hpc Do you want to take a look at the library I designed? https://github.com/Profpatsch/libnix-haskell/blob/master/Foreign/Nix/Shellout.hs
17:19:24 <schell> hpc: or maybe cabal can check the ghc version and then silence the warnings?
17:19:41 <Profpatsch> It’s in an alpha-version now, but I don’t want to submit it to Hackage just yet.
17:20:23 <hpc> i don't know if a .cabal file can do things conditionally for ghc versions
17:20:40 <hpc> oh!
17:20:51 <hpc> have two major versions of the package
17:21:11 <hpc> one running on a range of base that excludes 7.10+ and one that excludes before
17:21:26 <hpc> maintain both of them, and cabal's dependency resolution will pick the right one
17:21:37 <schell> yeah, that’s a thought
17:21:38 <schell> cool
17:21:44 <schell> thanks - i’ve got some things to go on
17:21:49 <hpc> it's literally doubling your codebase though
17:22:11 <hpc> and speaking from experience, it takes a lot of discipline to do it right
17:22:23 <hpc> making sure both versions are in sync
17:30:55 <jle`> schell: there are some packages that wrap up the cpp in a nice way for you
17:31:06 <jle`> like base-compat
17:31:18 <jle`> so you never see any cpp yourself in your own code
17:31:36 <schell> jle`: ah, thanks :) i’ll check that out too
17:32:47 <jle`> the imports and stuff are handled for the most part, bar some exceptions, if you work through those packages
17:43:09 * hackagebot ghci-history-parser 0.1.0.2 - parse output of ghci ":history" command  https://hackage.haskell.org/package/ghci-history-parser-0.1.0.2 (phlummox)
18:12:10 <lpaste> umib0zu pasted “MyCategory.hs” at http://lpaste.net/169795
18:12:19 <umib0zu> anyone want to help out with this ^^^
18:14:23 <umib0zu> I’m trying to create a new arrow here composing using composition, but I’m not sure why this doesn’t work out well
18:15:17 <mniip> Cats.. and Cats.id
18:21:45 <umib0zu> mniip now I got it
18:22:24 <lpaste> umib0zu pasted “PathEqs.hs” at http://lpaste.net/169796
18:22:29 <umib0zu> but now I want to define path equivalences…
18:23:17 <ski> umib0zu : any particular reason you want exactly one arrow between any pair of objects ?
18:24:05 <umib0zu> I’m not sure what you mean. Am I defining it like that? ski
18:24:34 <ski> you have `Arrow :: forall (a :: Object) (b :: Object). Arrow a b'
18:24:37 <umib0zu> There’s only 2 objects here from what I can see
18:24:51 <shachaf> There are two objects and four arrows.
18:24:54 <shachaf> (Disregarding Any.)
18:24:55 <ski> yes
18:25:02 <umib0zu> yup yup that’s what I wanted
18:25:04 <umib0zu> sort of...
18:25:43 <umib0zu> I mean. I wanted to define my set of arrows and objects, but I’m also not sure how to do that. For now I figured I would just try and instantiate things piece by piece
18:25:58 <ski> alternatively, you could try e.g. `data Arrow :: Object -> Object -> * where Id1 :: Arrow Object1 Object1; Id2 :: Arrow Object2 Object2; Arr1 :: Arrow Object1 Object2; ...'
18:27:10 <umib0zu> hm… ok
18:27:51 <umib0zu> now from there though, how do I define composition so I can say two arrows compose into an arrow of my choosing?
18:27:58 <ski> .. which would declare one arrow that could be used as identity over `Object1', and also one for `Object2', and then one arrow from `Object1' to `Object2'
18:28:15 <ski> (that would be enough to make a complete, though not that involved, category)
18:28:48 <ski> hm, try adding a type signature for `(.)', inside the instance declaration
18:29:40 * ski ponders
18:30:26 <ski> actually, i think `id' won't work, with my suggested `Id1' and `Id2' above. try replacing them by `Id :: Arrow o o' instead
18:31:22 <umib0zu> I’ll try
18:31:48 <ski> (afaiui, `id :: forall o. Arrow o o' in `Category Arrow' must be blind in `o', and so you can't determine whether to yield `Id1' or `Id2', depending on whether `o' is specialized as `Object1' or `Object2' ..)
18:33:20 <ski> (.. that being a rationale for why (i think) one can't make `id' here yield either `Id1' or `Id2', depending on `o' being `Object1' or `Object2')
18:33:58 <umib0zu> ahh ok
18:37:32 <ski> umib0zu : .. more interesting would perhaps be to make a category where arrows are matrices, and objects are natural numbers
18:39:22 <schell> which version of base did ghc 7.6.3 use?
18:39:26 <ski> (`Matrix :: * -> Nat -> Nat -> *' (first argument being the type (field) of scalars) where `data Nat = Zero | Succ Nat')
18:50:28 <Rotaerk> hmm, Cloud Haskell is designed for distributed processes; I want to build something that involves communication between processes, but not likely to be distributed, which makes cloud haskell seem like overkill
18:50:55 <Rotaerk> is there another package that's more ... optimal for interprocess communication when I don't care to distribute?
18:51:07 <Rotaerk> or should I just use cloud haskell
18:52:17 <Welkin> erlang?
18:52:47 <Rotaerk> I think cloud haskell is intended to imitate erlang
18:53:16 <dmj`> Rotaerk: network?
18:53:55 <Rotaerk> hmm lower level than I was thinking
18:54:03 <Rotaerk> I'll just go with cloud haskell, I guess
18:54:28 <Rotaerk> just seems weird to be building processes that will always run on the same machine, but communicate via the network interface
18:55:05 <Koterpillar> Rotaerk: they are already somewhat isolated, being processes not threads
18:55:18 <Rotaerk> true
18:58:20 <Welkin> lol Rotaerk 
18:58:25 <Welkin> that is... the worst
18:58:37 <Welkin> network latency is the worst of anything that exists
18:58:38 <Welkin> haha
18:58:46 <dmj`> Rotaerk: there is a high-level interface to network
18:58:59 <dmj`> it'd be far simpler than using cloud haskell
19:00:09 <Rotaerk> what high level interface are you referring to?
19:00:16 <Rotaerk> pipes-network and network-conduit?
19:01:15 <Rotaerk> Welkin, well, I don't think it actually leaves the computer or anything; but it's using TCP/IP
19:01:28 <Rotaerk> as opposed to some form of native IPC
19:02:35 <Rotaerk> dmj`, or just network-simple
19:05:20 <Rotaerk> I'll assume you just mean any/all of the above
19:06:45 <dmj`> Rotaerk: just the Network module
19:06:49 <dmj`> from the network package
19:06:52 <dmj`> Network was intended as a "higher-level" interface to networking facilities, and only supports TCP.
19:07:00 <Rotaerk> ahh k
19:55:45 <sailorr> I have a math degree can someone explain a monad to me
19:55:48 <sailorr> in a way I can understand
19:55:57 <sailorr> why are flatMap and map so special?
19:56:09 <sailorr> are they the only functors that return the same type?
20:03:51 <geekosaur> haskell monads don't have a whole lot to do with category theory, aside from someone noticing that its reflection in Haskell types provided some useful abstractions
20:05:00 <geekosaur> when it comes down to it, a Haskell monad consists of bind (aka flatMap aka join . fmap) and pure (aka return), and this turns out to be fairly useful in a large number of situations. no advanced math needed
20:05:37 <shachaf> Well, they have a lot to do with category theory monads, in that they're a special case.
20:06:00 <shachaf> But you probably don't need to know that unless you care about category theory for other reasons.
20:06:15 <adu> sailorr: are you still here?
20:06:39 <geekosaur> I decided to leave that out becase ... that, if you;re not otherwise interested in category theory then the only relationship is an origin story that might as well be myth as far as practical programming is concerned :)
20:07:32 <adu> sailorr: haskell monads don't have a whole lot to do with mathematical monads, either
20:08:08 <benzrf> sailorr: what math degree do you have
20:08:41 <Mateon1> Sometimes I wish Haskell had some sugar for an actual 'return', like in imperative programs. A lot of when/unless (..) $ do - makes control flow more difficult
20:09:07 <geekosaur> you could always use Cont :p
20:09:23 <Mateon1> Cont?
20:09:28 * Mateon1 Hoogles
20:09:28 <adu> CPS?
20:09:29 <sailorr> pure math why
20:09:40 <adu> sailorr: why what?
20:09:57 <sailorr> wut 
20:09:58 <sailorr> confused
20:09:59 <alercah> break your functions out into smaller combinators?
20:10:00 <sailorr> lol
20:10:12 <adu> sailorr: A monad is a tuple (X, bind, return)
20:10:35 <sailorr> X is a type?
20:10:39 <adu> oops
20:10:47 <geekosaur> Mateon1, continuation monad (and transformer). practically, you get a "current continuation" parameter which you can evaluate with a parameter to immediately "return" it
20:10:50 <adu> sailorr: A monad is a tuple (M A, A, bind, return)
20:11:32 <sailorr> could I say its a set too? {M A, A, bind, return} ?
20:11:36 <sailorr> or is tuple special
20:12:03 <sailorr> I know what MA and A do, bind and return I have to think about more 
20:12:10 <alercah> sailorr: tuple = ordered n elements
20:12:27 <alercah> order matters, and duplicates are theoretically allowed but usually not for practical reasons
20:12:28 <sailorr> ok
20:12:33 <alercah> but the important thing is that order matters
20:12:49 <alercah> it's like saying a group is a tuple (G, \cdot)
20:13:01 <sailorr> so return always returns M B? , bind takes MA and A ? 
20:13:01 <alercah> or a ring is a tuple (R, +, \cdot, 0, 1)
20:13:05 <adu> sailorr: you need to be able to distinguish between bind :: M A -> (A -> M B) -> M B, and return :: A -> M A
20:13:23 <adu> sailorr: and as a math major, you should know most mathematicians use tuples for that
20:13:42 <adu> sailorr: or a set (M A) "equipped with" two operations
20:14:06 <sailorr> I dont know much cat theory, I get confused by the amiguous notation a -> b -> c 
20:14:14 <sailorr> :: A -> MA  makes sense to me
20:14:14 <Mateon1> geekosaur: Hm, is there an IO Cont type?
20:14:25 <geekosaur> ContT IO?
20:14:39 <alercah> sailorr: -> is right-associative. a -> b -> c = a -> (b -> c)
20:14:40 <adu> sailorr: a -> b is the type of a function with domain in set a, and codomain in set b
20:14:49 <Mateon1> geekosaur: Ah, sorry. I'm not used to transformers
20:15:07 <adu> sailorr: are you sure you're a math major?
20:15:17 <alercah> adu: huh?
20:15:23 <sailorr> math graduate
20:15:27 <alercah> I could totally see someone going to get an undergrad in pure math without ever seeing this stuff
20:15:47 <sailorr> wtf why is it A - > B -> C thats horrible notation
20:15:52 <sailorr> is it just random
20:16:04 <adu> alercah: I'm a college drop-out and I've seen this stuff
20:16:07 <alercah> sailorr: because it's useful when you get to actually programming
20:16:15 <alercah> the tuple thing, for instance, only comes up if you're dealing with algebras in a general sense, like in category theory, universal algebra, or model theory
20:16:27 <alercah> depending on the presentation, you may not see it in a typical abstract algebra course
20:16:40 <alercah> and if all you took were the two courses you needed to take in third year because you liked analysis better..
20:16:45 <sailorr> o yea I know a tuple is ordered lol
20:16:49 <sailorr> I just didnt know if it matered here
20:16:50 <sailorr> mattered*
20:17:00 <alercah> sailorr: yeah but I mean this particular application of tuples
20:17:11 <sailorr> o ya never seen anything like it
20:17:21 <alercah> you can do group theory without it, because you just say "a group is a set G and an operation \cdot" or the like
20:17:23 <sailorr> well ...actually maybe short exact sequences
20:17:27 <alercah> same with ring theory, field theory, linear algebra...
20:17:32 <sailorr> kind of used arrow notation but in isolated cases 
20:17:49 <sailorr> like ive never seen a ->b ->c ->d ->e chained together like that 
20:17:49 <alercah> the tuple is only really useful when you are talking about general things various algebraic structures have in common
20:18:03 <alercah> sailorr: the reason we do it like that is because it reads very naturally from a computer programming point of view
20:18:11 <alercah> e.g. (+) :: Int -> Int -> Int
20:18:25 <alercah> you can read this as "it takes two Ints and gives an Int"
20:18:32 <sailorr> so I can think of it as (Int, Int ) -> Int ? 
20:18:37 <alercah> but you can also read it as "it takes one Int and gives back a function that, given an Int, gives you an Int"
20:18:42 <Koterpillar> does "2 + 3 + 4" or "2 - 3 - 4" feel normal?
20:18:58 <benzrf> sailorr: think of (->) as an operator that takes two types or sets and returns a new one
20:19:06 <alercah> sailorr: sort of, but that breaks down when you get to partial application
20:19:07 <Koterpillar> or do you need to rewrite it as "(2 - 3) - 4"?
20:19:09 <benzrf> sailorr: so for example, N -> Z is the set of functions from N to Z
20:19:22 <alercah> benzrf: he's seen that usage before
20:19:22 <benzrf> sailorr: so Int -> (Int -> Int) is the set of functions from Int to Int -> Int
20:19:26 <sailorr> Koterpillar: it makes sense but addition is associative (right and left)
20:19:28 <sailorr> I dont think -> is
20:19:32 <sailorr> is it?
20:19:34 <alercah> sailorr: we've defined it to be
20:19:36 <benzrf> sailorr: it's not, no
20:19:38 <Koterpillar> sailorr: it is not; neither is subtraction
20:19:46 <benzrf> sailorr: but it's understood that we mean it to be right-associative
20:19:47 <alercah> err
20:19:58 <alercah> what they said is clearer :)
20:20:29 <sailorr> ok so a ->b ->c ->d would be the type who takes type a and returns a type that takes type b and returns a function of type c -> d ?
20:20:41 <sailorr> I cant wrap my mind around that
20:20:48 <Koterpillar> s/type/function in some places
20:20:54 <alercah> sailorr: yes
20:21:02 <alercah> sailorr: it's isomorphic to (a, b, c) -> d
20:21:04 <adu> sailorr: f x y z is usually defined as a single function operating on a tuple in most languages, but in haskell it's defined to be a function that takes "x", and returns a function that takes "y", that returns a function that takes "z", that returns whatever
20:21:10 <alercah> but it's more convenient to talk abou
20:21:13 <alercah> *about
20:21:21 <alercah> and to use in programming
20:21:25 <alercah> because we can do stuff like
20:21:28 <sailorr> wow
20:21:37 <sailorr> ok ive heard of currying I guess makes sense now thank you
20:21:51 <alercah> yep, this is exactly currying
20:22:01 <Koterpillar> :t curry
20:22:02 <lambdabot> ((a, b) -> c) -> a -> b -> c
20:22:32 <sailorr> is it supposed to represent data flow?
20:22:38 <sailorr> or just so its easier to implement?
20:22:39 <adu> :t const
20:22:40 <lambdabot> a -> b -> a
20:22:53 <sailorr> I mean the motivation behind it in programming
20:23:32 <dfeuer> sailorr, here's a warning for you: good functional programming language designers are generally much better at coming up with good formal logic notation than typical mathematicians. Once you've gotten used to how consistent Haskell or Agda (for instance) are, you may find yourself annoyed with sloppy mathematicians.
20:24:05 <adu> sailorr: const is a "bivariate function" so to speak, but most people use (const 5) or something as a parameter to other functions, so that you don't have to write (\_ -> 5)
20:24:15 <sailorr> yeah im starting to figure that out dfeuer 
20:24:22 <sailorr> lol
20:24:39 <sailorr> mathematicians are idiots compared to type theorists 
20:24:49 <sailorr> just like physicists are idiots compared to most mathematicians
20:25:46 <sailorr> adu: why is the type Int missing in \_ -> 5 ? in math id have written it f : N-> N def by f( n) = 5 
20:25:49 <sailorr> is it inferred?
20:25:56 <dfeuer> sailorr, I wouldn't put it like that. But the CS people are really good at the type and logic business.
20:26:00 <adu> dfeuer: pure math is also full of proofs which literally use the phrase, "let X be defined such that F(X) is true"
20:26:25 <sailorr> thats true
20:26:27 <sailorr> lol
20:26:32 <sailorr> existence is the only thing that matters in proofs
20:26:38 <alercah> sailorr: the main reason is because it just turns everything into one uniform type of function
20:26:47 <alercah> it also has a huge practical upset when programming
20:26:50 <adu> sailorr: probably, it's an example, I didn't compile it, or typecheck it, inference depends on context, and there is none
20:26:55 <alercah> :t neg
20:26:57 <lambdabot> Not in scope: ‘neg’
20:26:57 <alercah> :t map
20:26:58 <lambdabot> (a -> b) -> [a] -> [b]
20:26:59 <dfeuer> sailorr, well, in CS, people are mostly only interested in *constructive* proofs.
20:27:03 <alercah> :t not
20:27:04 <lambdabot> Bool -> Bool
20:27:08 <alercah> given these functions
20:27:11 <alercah> I can just write 
20:27:14 <alercah> :t map not
20:27:15 <lambdabot> [Bool] -> [Bool]
20:27:27 <alercah> because of currying, this is well-defined with no extra magic
20:27:43 <alercah> if you don't have currying, you need to either explicitly define what a partial application is
20:27:50 <alercah> and special-case it
20:27:57 <alercah> or you need to manually do something like
20:28:03 <alercah> :t \l -> map not l
20:28:04 <lambdabot> [Bool] -> [Bool]
20:28:06 <alercah> to mean the same function
20:28:36 <sailorr> map not l ?
20:28:50 <shachaf> I suggest that sailorr's conversation be taken to #haskell-overflow.
20:29:07 <alercah> I'm find with that if they are
20:29:10 <dfeuer> > let f = map not in f [False, False, True]
20:29:12 <lambdabot>  [True,True,False]
20:29:14 <shachaf> It's been going on for half an hour and taking a lot of vertical space.
20:29:24 <adu> dfeuer: I love constructive proofs
20:30:42 <sailorr> oh I see
20:30:43 <sailorr> kind of
20:30:44 <sailorr> hm
20:31:06 <sailorr> cs is weird 
20:32:01 <shachaf> sailorr, et al.: Please go to #haskell-overflow.
20:51:50 <dustmote> not exactly about haskell, persay: if one were designing a simple language, would it make sense for varable dereferencing to go in the AST at Expr, Term, or Factor? I'm learning toward Expr for no reason in particular.. It seems like precedence isn't an issue.
20:57:44 <EvanR> dustmote: dereferencing as in C's * operator?
20:58:18 <glguy> dustmote: Expr/Term/Factor distinction goes away after parsing and probably shouldn't show up in your Expr representation
20:58:39 <glguy> as far parsing it matters where you put dereferencing because of precedence, so put it where it makes the most sense
20:58:40 <Axman6> so I find my self writing code like this all the time, where I'm creating a hashmap where the key for a value is also contained in the value: Vec.foldl (\hash loc -> Hash.insertWith Set.union (_someRecordAcessor loc) (Set.singleton loc) hash) Hash.empty vector. I wish there was a insertWith' :: (Monoid v, Hashable k) => (a -> k) -> a -> HashMap k v -> HashMap k v
21:27:27 <troydm> so I have some huge list of data, and I use filter and map functions over that list, just for performance reasons should I put this list into vector or not?
21:28:00 <EvanR> if its being generated lazily, that would make it worse
21:28:26 <troydm> EvanR: hmm, I'm not sure how it's generated actually, I get it as a result from mongoDB database driver
21:28:41 <EvanR> to get good performance doing literally just filtering and mapping, you want a lazy list, or stream
21:29:29 <EvanR> database libraries usually give you a combinator for folding over the results of a query
21:30:41 <troydm> EvanR: well it has some custom Cursor type which I can iterate with next function
21:31:13 <pavonia> Can't you defer at least part of the filtering to the database query?
21:31:20 <Koterpillar> troydm: don't use vector unless you need random access
21:31:40 <troydm> pavonia: tried it, it's even worse performance wise since I need to do some math on it
21:31:50 <troydm> Koterpillar: ok
21:32:30 <troydm> well performance is good actually, not astonishing but it takes literally 3-4 seconds to do the query
21:32:36 <EvanR> you might be able to integrate mongo with other parts of the program through pipes or conduit
21:32:46 <troydm> with database function it took over 30 secs
21:33:35 <troydm> EvanR: that means I need to learn how to use pipe or conduit, which i'm not feeling like I want to do right now since it's 6 AM here and I've been coding this whole night
21:34:02 <EvanR> agreed
21:34:37 <troydm> EvanR: well currently i'm using mongoDB's rest function to get [] out of Cursor 
21:34:57 <troydm> I should read it's source code since doc doesn't says anything about it being lazy or not
21:35:26 <EvanR> im going to guess / hope its not
21:35:46 <troydm> rest c = loop (next c)
21:35:53 <troydm> well c is Cursor
21:36:00 <troydm> so I guess loop is lazy
21:36:07 <EvanR> whats loop
21:36:40 <troydm> loop :: (Functor m, Monad m) => m (Maybe a) -> m [a]
21:36:49 <troydm> loop act = act >>= maybe (return []) (\a -> (a :) <$> loop act)
21:37:02 <EvanR> an IO [a] is going to produce an actual list unless it uses unsafeInterleaveIO somehow
21:37:06 <EvanR> when executed
21:37:23 <EvanR> yeah so not lazy
21:37:57 <troydm> EvanR: are u sure, I don'tt quite understand
21:37:59 <troydm> or my minds is metling
21:38:02 <troydm> *melting
21:38:08 <EvanR> IO is strict
21:38:11 <EvanR> normally
21:38:43 <troydm> hmm
21:39:32 <EvanR> if you execute loop (next c), it will not return until next returns Nothing
21:40:32 <troydm> EvanR: I get it now
21:40:36 <troydm> EvanR: thx
21:40:52 <EvanR> act >>= f, it executes act, then feeds the result to f and executes the result
21:41:03 <EvanR> which might return something, or might loop
21:41:30 <EvanR> other monads have >>= which can be lazy
21:44:16 <pavonia> troydm: There are also function to return a list of results, maybe these are faster than pulling each entry one by one
21:45:35 <EvanR> if its a "huge list" then just by materializing the whole thing before continuing has gotta hurt performance due to memory usage
21:46:30 <EvanR> but hey ruby on rails does it and wins regularly somehow
21:47:24 <pavonia> I don't mean pulling the whole list at once but only the next 50/100/whatever results
21:47:42 <EvanR> ah
22:31:34 <parsnipM_> what is the haskell version of the diagrams from SICP of environments and lambdas and function calls? 
22:32:44 <parsnipM_> how do i diagram my haskell code, or sketch ideas out with arrows like in flow control diagrams with if then branches and loops. it seems useful to draw such, but it seems difficult to translate to haskell idioms. 
22:32:54 <parsnipM_> like using Maybe Just Nothin
22:32:57 <parsnipM_> *Nothing
22:33:18 * hackagebot monad-lgbt 0.0.1 - Monad transformers for combining local and global state.  https://hackage.haskell.org/package/monad-lgbt-0.0.1 (MichalGajda)
22:33:46 <parsnipM_> i go to draw it, like replacing yes/no branches with Just a/Nothing, but it seems difficult to think that way. 
22:46:18 <Axman6> parsnipM_: it's easier if you think at a higher level usually, thinking in terms of functions which can be composed. when you have Maybe's you use the maybe function
22:57:19 <parsnipM_> Axman6: i have sort of a complicated web of conditionals and recursions
22:57:38 <parsnipM_> several of each mixed together
22:59:07 <parsnipM_> i guess i'll just redraw diagram, keeping mind Maybe and Either gives me a way to return whatever values i need
22:59:13 <parsnipM_> *keeping in mind
23:04:17 <EvanR> parsnipM_: the two kinds of languages are very different, especially considering laziness
23:04:39 <EvanR> you kind of dont want to translate these loop / conditional diagrams into haskell
23:05:03 <EvanR> instead of control flow, you use functions on data types
23:05:56 <EvanR> unless youve broken down and resorted to imperative IO programming
23:06:06 <EvanR> and even then...
23:06:18 <parsnipM_> EvanR: how do you replace a flow where you have conditionals and recursion spliced together? 
23:06:44 <parsnipM_> sorry, when i was saying loops, i meant recursion
23:06:57 <EvanR> you probably will write a schema function totally different in haskell because of lazy evaluation
23:07:02 <EvanR> scheme
23:07:55 <EvanR> but you can use easily use recursion and case analysis together
23:10:04 <EvanR> another key difference is pattern matching, which lets you sort of define your algorithms using equational reasoning
23:11:04 <EvanR> what is the answer for each case, and the cases are finite, definite, implied by the functions type
23:12:54 <pollz> anybody can give suggestions as to how to implement the following : wantTheseLines :: Int -> Int -> String -> [String]	
23:13:11 <pollz> wantTheseLines takes two line numbers and a filename and gives a string array of lines
23:13:18 <parsnipM_> my recursion has three nested conditionals in it, all three can lead back to main function, but third conditional can recurse back to second. 
23:13:20 <EvanR> use lines, take, and drop
23:13:27 <natalie92> Why isn't Foldable just class (Functor t) => Foldable t where toMonoidElement :: (a -> m)?
23:13:48 <shachaf> natalie92: What is m?
23:13:58 <natalie92> Uh Monoid m +>
23:14:01 <EvanR> whats a
23:14:01 <shachaf> Foldable has toList :: t a -> [a]
23:14:02 <natalie92> =>*
23:14:30 <shachaf> The function you want is impossible to write. Try it.
23:14:50 <pollz> EvanR: I am a newbie and I am slightly confused about writing the function. I have a do loop which reads the lineArray <- lines fileHandler
23:14:55 <shachaf> If m is some arbitrary monoid, where you don't know what it is, you can only write mempty, mappend mempty mempty, etc.
23:15:39 <shachaf> You need some way to put values into your monoid type, so that you can mappend them.
23:15:46 <EvanR> pollz: maybe lpaste.net your code so far
23:16:02 <shachaf> That's why Foldable's main method is foldMap :: Monoid m => t a -> (a -> m) -> m
23:17:02 <jle`> is there a nice way to format a type signature with many constraints
23:17:25 <pollz> EvanR: http://lpaste.net/169802 sorry for indentation issues
23:17:49 <natalie92> shachaf: When someone instances MyFoldable, they would only have to implement toMonoidElement (for some particular monoid), and out pops foldMap = mconcat . fmap toMonoidElement
23:18:00 <shachaf> natalie92: Oh, I see, with Functor.
23:18:22 <shachaf> natalie92: Do you mean fold :: t m -> m?
23:18:36 <shachaf> No, you don't mean that either.
23:18:42 <EvanR> jle`: you can use more => and put them on multiple lines like arguments
23:18:49 <shachaf> I think I assumed too much about your question.
23:19:10 <shachaf> Can you write a class definition that isn't an error?
23:19:16 <Cale> natalie92: a isn't in scope in the type signature you gave originally... which would mean that it takes something of an arbitrary type and produces a monoid element
23:19:26 <Cale> (which means that it'd have to be a constant function)
23:19:28 <shachaf> (One answer is that some things are Foldable but not Functor.)
23:19:43 <EvanR> pollz: so lineArray is the list of lines, and you want to select a subset from the middle
23:19:57 <pollz> EvanR: Yes. From x to y line numbers
23:20:11 <natalie92> Cale: doesn't foldMap also have the same problem?
23:20:15 <EvanR> first use drop to get to line x, then use take to only go up to y and ignore the rest
23:20:16 <Cale> :t foldMap
23:20:16 <pollz> I wanted to use the lineArray ^? element syntax from Control.Lens
23:20:17 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
23:20:23 <Koterpillar> pollz: take, drop
23:20:31 <Cale> natalie92: Note that the 'a' is used in two places
23:20:36 <EvanR> > drop 3 "hello world"
23:20:38 <lambdabot>  "lo world"
23:20:45 <EvanR> > take 3 "hello world"
23:20:47 <lambdabot>  "hel"
23:20:58 <Koterpillar> > drop 3 ["hello", "world", "and", "pollz"]
23:20:58 <pollz> Ok, I see.
23:20:59 <lambdabot>  ["pollz"]
23:21:06 <EvanR> > take 3 (drop 3 "hello world")
23:21:08 <lambdabot>  "lo "
23:21:14 <Cale> natalie92: The idea being that you're applying the function to all the elements of the data structure, and then somehow combining the resulting elements of the monoid.
23:21:36 <Cale> natalie92: It's this convention about the manner in which to combine those elements which Foldable is really expressing
23:21:45 <pollz> EvanR: Koterpillar This is fine but how does the function return an array of strings in my case
23:21:46 <natalie92> Oh, so in my case, I'd have to add an extra parameter to Foldable?
23:21:56 <pollz> I understand the logic behind the take drop
23:22:15 <shachaf> You aren't even using t.
23:22:30 <Koterpillar> > drop 3 ["how", "does", "the", "function", "return", "an", "array", "of", "strings", "in", "my", "case"]
23:22:31 <lambdabot>  ["function","return","an","array","of","strings","in","my","case"]
23:22:36 <Koterpillar> pollz: ^
23:22:40 <shachaf> Which is the important parameter, really, even if you add an a parameter for something.
23:22:49 <natalie92> shachaf: yeah, now I'm very confused
23:23:01 <pollz> Koterpillar: Ok Ok Coo
23:23:08 <pollz> Koterpillar: I am really dumb. Sorry.
23:23:14 <Koterpillar> pollz: hint: your signature is really Int -> Int -> [a] -> [a]
23:23:37 <shachaf> I think your proposal doesn't compile even with minor changes.
23:23:41 <pollz> Koterpillar: 
23:23:42 <pollz> Why
23:23:44 <Koterpillar> because you don't care if it's a string or a character or an Int
23:23:44 <natalie92> I mean mapping and combining are modular, (fmap and mconcat), so why have this class that tries to do both together?
23:23:53 <pollz> I mean, the file name is a string which is a char array right?
23:24:05 <shachaf> natalie92: One answer is what I wrote above: Some types are Foldable but not Functor.
23:24:06 <EvanR> char list
23:24:08 <pollz> Oh that way
23:24:09 <shachaf> For example Data.Set.
23:24:19 <natalie92> woah
23:24:36 <natalie92> example with foldMap, please?
23:24:38 <Koterpillar> pollz: oh no, let's write a pure function first
23:24:39 <Cale> Almost just Data.Set
23:24:46 <natalie92> haha
23:24:46 <Cale> heh
23:24:47 <shachaf> Well, lots of hypothetical examples.
23:25:02 <shachaf> Like data Iterated a = Iterated a (a -> a)
23:25:10 <pollz> Koterpillar: One more question. Variables inside the do cannot be used outside, right?
23:25:20 <Koterpillar> pollz: "read the data from a file" is a separate task
23:25:31 <Koterpillar> pollz: correct
23:25:38 <shachaf> natalie92: If you wanted to separate mapping and folding, you could define class Functor t => Foldable t where { fold :: Monoid m => t m -> m }
23:25:50 <shachaf> natalie92: Then foldMap f = fold . fmap f, like you want.
23:25:52 <pollz> Koterpillar: So I write another function which takes a file and returns me lineArray
23:25:59 <pollz> and then use this to drop and take ?
23:26:04 <Cale> > foldMap (Product . length) (S.fromList (words "here are some words"))
23:26:06 <lambdabot>  Product {getProduct = 240}
23:26:23 <Koterpillar> :t lines
23:26:24 <lambdabot> String -> [String]
23:26:26 <Koterpillar> pollz: ^
23:26:30 <Koterpillar> :t readFile
23:26:31 <lambdabot> FilePath -> IO String
23:26:34 <Koterpillar> pollz: ^
23:26:45 <pollz> Koterpillar: Sure, sure. But these are useless without a do right?
23:26:50 <Cale> I suppose to be really interesting, we should pick an instance of Monoid which isn't an instance of Ord
23:26:51 <shachaf> natalie92: There's another answer, which is that the type forall m. Monoid m => (a -> m) -> m is actually quite a good type, representing the free monoid on a, not a hack.
23:26:58 <pollz> like it always has to be do file <- readFile et cetera
23:26:58 <Koterpillar> pollz: do is just syntax sugar
23:27:04 <pollz> Oh
23:27:13 <pollz> So, file = readFile filename should work
23:27:26 <Koterpillar> heh
23:27:41 <Koterpillar> it's more involved; did you read an introductory book of any kind?
23:27:42 <natalie92> shachaf: okay that last bit sounds very interesting, but could you please explain?
23:28:11 <shachaf> natalie92: Note that yet another way to define Foldable, almost, would be class Foldable t where { toList :: t a -> [a] }
23:28:19 <pollz> Koterpillar: I went through LYAH, Real World Haskell, over the top only, I am trying to pick up things on the go :)
23:28:31 <pollz> Koterpillar: I know this is bad, but I am running out of time also.
23:28:36 <shachaf> That lets you do pretty much everything Foldable does. All Foldable represents is being able to get a sequence of values.
23:28:41 <Koterpillar> pollz: it pays to read any of those thoroughly
23:29:17 <bernalex> pollz: http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html shows you how to desugar do-syntax.
23:29:17 <pollz> Koterpillar: Yes, yes, for sure, but currently I need to learn quickly (like in two weeks, and this isn't the only thing up my arse)
23:29:34 <pollz> bernalex: checking it, thanks.
23:29:37 <bernalex> (disregarding that it's a bit out of date due to ApplicativeDo)
23:29:59 <Koterpillar> pollz: use all the time you allocated for learning Haskell for going as far as you can through LYAH / RWH (pick one), not skipping over
23:30:30 <pollz> Koterpillar: I was considering purchasing RWH, I think I will go for this.
23:30:38 <bernalex> I wouldn't purchase rwh
23:30:45 <shachaf> natalie92: But then there are some annoying details in Haskell, where Foldable can be more general than []. For example, you might have an infinite cons list (infinite on the right), or an infinite snoc list (infinite on the left).
23:30:51 <Koterpillar> pollz: quick non-explanation: in Haskell, functions are pure so guaranteed to return the same value if you give them save arguments; this includes readFile "/my/file"; how can this be if "/my/file" can be different every time?
23:30:52 <pollz> bernalex: hmm. Because free online?
23:30:55 <natalie92> shachaf: Also how can you have a defintion for  forall m. Monoid m => (a -> m) -> m without any 'a's? Or is that what you mean by free?
23:30:55 <bernalex> it's woefully out of date. which is somewhat acceptable when it's gratis online.
23:31:07 <shachaf> natalie92: Foldable can represent both of those equally well, but [] is biased toward right-infinite list.
23:31:09 <bernalex> pollz: https://github.com/bitemyapp/learnhaskell/ this would be my suggestion for learning haskell, not rwh nor lyah.
23:31:13 <Cale> natalie92: Here, a should be regarded as a specific type.
23:31:19 <bernalex> lyah is an okay read though.
23:31:25 <shachaf> What Cale said.
23:31:27 <pollz> Koterpillar: Ah. I see.
23:31:31 <bernalex> rwh > lyah, but rwh is so out of date.
23:31:31 <shachaf> It's the same a in toList :: t a -> [a]
23:31:39 <pollz> bernalex: LYAH is very rough
23:31:44 <shachaf> I.e. it's whatever the Foldable instance is parameterized over.
23:32:14 <Koterpillar> pollz: as far as I remember, what you're asking about is approximately chapter 5 or 7; but you do need the preceding chapters too
23:32:32 <Koterpillar> can't advise on a better intro because I only read those two
23:32:37 <Cale> e.g. if you pick Char, then functions of type  forall m. Monoid m => (Char -> m) -> m  basically give you "all the stuff you can form using just the monoid operations, and a way to regard Char values as elements of your monoid"
23:32:51 <shachaf> natalie92: So this forall m. Monoid m => (a -> m) -> m thing handles all these cases, right-infinite, left-infinite, middle-infinite, whatever, in the ideal way for Monoid.
23:32:53 <pollz> Koterpillar: Okie. I will attempt this and get back to you guys. Thanks for your time. You're amazing. 
23:33:20 * hackagebot quickcheck-io 0.1.3 - Use HUnit assertions as QuickCheck properties  https://hackage.haskell.org/package/quickcheck-io-0.1.3 (SimonHengel)
23:33:26 <natalie92> And why doesn't this a appear as  a parameter for Foldable? Or does foldMap take care of that (if yes, how? Is it because there are two a's in the signature?)
23:33:28 <Cale> an example of such a function might be (\f -> f 'H' <> f 'e' <> f 'l' <> f 'l' <> f 'o')
23:33:55 <Cale> So these are essentially a funny encoding of lists
23:34:09 <shachaf> Very nearly a funny encoding of lists. :-)
23:35:42 <shachaf> In a "reasonable" language, without infinite data, it would be the same thing as a list.
23:35:43 <Cale> But yeah, the difference comes with which "infinite" data structures can be encoded, and you can basically have more general infinite trees of combinations.
23:36:01 <shachaf> There's yet another answer to that question, but it involves lens, so it's probably out of scope here. :-)
23:36:26 <natalie92> shachaf: no go ahead please
23:36:34 <Cale> natalie92: and yeah, it's because the 'a' there is not just any 'a', but the type of elements of the foldable structure you're passing in
23:36:38 <shachaf> You can see the sorts of things that this type lets you do in http://hackage.haskell.org/package/fmlist-0.9/docs/Data-FMList.html
23:37:01 <Cale> natalie92: So we have a source of things to be combined
23:37:47 <Cale> natalie92: The idea is that we're going to apply the function to all the elements of the Foldable structure, and then we have some convention, based on the structure of the value of type t a, for combining the resulting elements of the monoid.
23:38:36 <shachaf> This (forall m. K m => (a -> m) -> m) construction is much more general than Monoid, by the way.
23:38:42 <Cale> With Data.Set, we can follow the internal tree structure, and due to associativity of monoids, not reveal anything about how the sets are represented.
23:38:59 <shachaf> It works for any algebraic class. So you can represent free groups that way if you like, for example.
23:39:10 <shachaf> (But it's pretty inefficient in that case.)
23:39:22 <Cale> (but a bad instance of Monoid will let you peek and see what the tree structure was)
23:40:21 <shachaf> @hackage nonfree
23:40:21 <lambdabot> http://hackage.haskell.org/package/nonfree
23:40:23 <shachaf> For instance.
23:40:42 <Cale> Regardless, you get the results of applying the function to the elements of the set, combined together somehow in order from least to greatest
23:41:04 <Cale> hah
23:42:06 <Cale> Hey, the comment there isn't quite right, the Foldable instance won't always make a right biased tree
23:42:38 <Cale> But maybe you meant in one particular instance
23:42:39 <shachaf> I think I'm just talking about the three-leaf tree in that comment.
23:42:46 <shachaf> I guess it wasn't very clear.
23:43:11 <shachaf> Or more generally (f <$> a <*> b <*> c <*> d <*> e) vs. (a <> b <> c <> d <> e)
23:43:31 <shachaf> But not the Foldable instance for Map.
23:43:46 <shachaf> Anyway I think it's kind of a bug that Foldable and Traversable generate different trees.
23:43:56 <shachaf> Even though it's not something you can observe legally.
23:44:06 <Cale> It's necessary though, isn't it?
23:44:17 <shachaf> Why?
23:44:33 <shachaf> You can write a right-associated liftA3 if you want to.
23:44:35 <Cale> hmm
23:44:52 <Cale> Yeah, I suppose it's possible
23:44:53 <shachaf> The natural <$>/<*> syntax is unfortunately left-associated.
23:45:06 <shachaf> Which is annoying because Haskell typically favors right-association.
23:45:12 <Cale> I wonder if you would really want that normally
23:45:31 <shachaf> I think you would want it if it didn't have extra overhead.
23:45:41 <Cale> Well, no, you typically want it left associated here, I think.
23:45:47 <Cale> Function application is left associative
23:45:53 <shachaf> Function application is, yes.
23:45:59 <shachaf> But this is about the shape of the mappend tree.
23:46:26 <shachaf> If you want that tree to be left-associated, then you should probably want <> to be infixl too.
23:46:26 <Cale> Traversable doesn't know about monoid structure
23:46:40 <shachaf> It knows about the Applicative structure. Same thing.
23:46:59 <shachaf> You can traverse with Const to get the same monoid structure.
23:47:49 <Cale> hmm
23:48:10 <shachaf> The difference is that reassocating <> is easy, and reassocative <$>/<*> is a headache.
23:48:19 <Cale> I suppose you'd need a bad instance of Applicative similarly to reveal the actual way in which it's associated
23:48:35 <shachaf> If you used something like mult :: f a -> f b -> f (a,b) in Applicative it would be more obvious.
23:48:56 <shachaf> Sure. For example Const of that bad Monoid instance.
23:49:21 <shachaf> Anyway, my challenge is to figure out a way to make <$>/<*>-ish syntax that associates to the right.
23:49:31 <shachaf> arkeet figured something out once, I think? I don't remember.
23:49:52 <shachaf> Also a way that doesn't introduce a lot of extra pures.
23:49:59 <shachaf> Which the "obvious" CPS transformation does.
23:51:13 <shachaf> (I mean that it should introduce no extra pures.)
23:52:47 <shachaf> > foldMapDefault N [1,2,3,4]
23:52:49 <lambdabot>  N 1 ◇ (N 2 ◇ (N 3 ◇ (N 4 ◇ ε)))
23:56:35 <shachaf> > let oddTraverse f [] = pure []; oddTraverse f [x] = (:[]) <$> f x; oddTraverse f (x:y:xs) = (\x' y' xs' -> x' : y' : xs') <$> f x <*> f y <*> oddTraverse f xs in (getConst . oddTraverse (Const . N)) [1..7]
23:56:36 <lambdabot>  (N 1 ◇ N 2) ◇ ((N 3 ◇ N 4) ◇ ((N 5 ◇ N 6) ◇ N 7))
23:57:27 <shachaf> > let oddFoldMap f [] = mempty; oddFoldMap f [x] = f x; oddFoldMap f (x:y:xs) = f x <> f y <> oddFoldMap f xs in oddFoldMap N [1..7]
23:57:29 <lambdabot>  N 1 ◇ (N 2 ◇ (N 3 ◇ (N 4 ◇ (N 5 ◇ (N 6 ◇ N 7)))))
23:57:36 <shachaf> Maybe this example is too contrived to be convincing.
