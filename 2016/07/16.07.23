03:18:11 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
03:18:11 --- topic: set by Cale!~Cale@2607:fea8:9840:324:58c2:98f3:e7ff:280e on [Thu Jun 23 02:10:44 2016]
03:18:11 --- names: list (clog PatrickRobotham oish rnons Yuras aupiff montagy_ hk238 osa1 hamid Maplicant Lowl3v3l hackebeilchen yude dgorbik zcourts narendraj9 dors_ derdon meditans fizruk agrafix dpn` bennofs condy tg aseidl inr herzmeister ralu HallaSurvivor jbgi_ intelux xiinotulp Maerten metl simg l3dx zipper cpup dcoutts edon_ silver chaosmasttter harfangk grayjoc marr ertes IlNominePatre jeltsch Cassiopaya zerotech irco kritzcreek drbean_ Wizek firstdayonthejob marienz eklavya_)
03:18:11 --- names: list (vtell benl23 uuplusu nour piyush-kurur cow_2001 m0rphism grouzen tgeeky sykora deank der-landgraf ggole xaimus quchen garphy`aw hackagebot pfurla Swizec Squarism chrisg_ aloiscochard robertk moop prohobo mikedlr Tourist wolfcub nomotif GXNPwd_ MrWoohoo shafox takuan cyphase montanonic vlatkoB flutterb1t Atrumx Internet13 vydd_ ManiacTwister mzf pointfree travism ali_bush jgornick nwf cschneid irclogger_com lspitzner Rotaerk hexagoxel exferenceBot Stratege)
03:18:11 --- names: list (dan_f s4kashya_ jo`ve darkf wlemuel wlemuel_ Jesin Zekka phileas dmiles skeet70 PragCyph5 pikajude desophos whaletechno meretrix alx741_ markus1199 predator117 nakal1 dmwit AustinMatherne eyck dolio hamishmack Beetny pie__ Sgeo taksuyu y2agarwa idupree electrostat sqrt2 noexcept thunderrd__ ElderFain timrs2998 lambdabot Dykam scinawa Destol Sornaensis watersoul otto_s_ jnoah Brando753-o_O_o funrep Sose zv mgaare Sorella jcreekmore numee Cooler216 Raynes Reiser)
03:18:11 --- names: list (jlouis Voldenet Diabolik gienah sooheon Moto-chan Frankablu cdsmith slack-haskell1 fkurkowski rcsgns Johannes13_ SegFaultAX MoALTz Cale binaryplease ljhms grol lassulus Deewiant slackircbot felher vishesh milessabin xinming int-e dfranke S11001001 groscoe Arguggi astocko ThreeOfEight t0m0 thewormkill zmanian__ Phyx- maerwald esssing sLite bbee bernalex linduxed Madars Chobbes MK_FG opqdonut ion tpsinnem ec\ nille tv _paul0 cic cdk_ tero- ido folsen Boreeas)
03:18:11 --- names: list (benzrf LnL mudfog_ jbalint TheMystic themagician snsapiens undermink _sjs Bane^ shachaf Tehnix andreass robogoat opqdonut__ yyyyy fionnan davidthomas dju mxf Gothmog_ Kavec rvncerr froztbyte dysfun julmac strixy coeus_ dqd M-mistake karls LeaChim chronon-io_ majoh_ mceier RageD_ saurik_ endokqr monty tek0_ byorgey xplat_ pikpok_ djm joshc_ zyla ziman_ tekacs jameseb dreamseeker horatioh1 shookees i- Mon_Ouie Khisanth magbo flebron armyriad CoconutCrab spektre)
03:18:11 --- names: list (M-Shrike d-rock epta dud ninefingers CurryWurst Hakey joehillen _kit_ haasn rembo10 AntiSpamMeta LordDeath kosmikus akermu bikeshedr Qommand0r epitron zymurgy spion richi235 Taylor orion Enigmagic Tesseraction davidar tagada[m] M-Quora M-Illandan M-wamaral atomi juhp koala_man mendez emmflo dsantiago notbsmt Cathy nurupo mrlase skarn nathanic Baughn vin-ivar abh klugez justanotheruser anachrome Guest9205 kaol jstolarek Ezku ft ao1ei8 amontez noctux josuf107)
03:18:11 --- names: list (capisce_ Guest69091 peterOJ Rodya ploop Ornedan Deadhand adarqui antoniy Maxdamantus jdt bizarrefish prooftechnique raduom angerman jle` caumeslasal Coldblackice wjm mikeizbicki carter-znc liyang elementalest miklcct jibi gfixler1 chchen mdarse Black-Wolf suppi alunduil squisher ahf johnw tsani cbm80 kaww canta vozz a3Dman saidinwot moei whoops kosorith2 jcurbo ghorn milos_cohagen kyren refried_ arkeet s4kashya troydm petercommand theorbtwo jtobin Excureo prkc)
03:18:11 --- names: list (yrdz _Shandy srcerer bshelden pikhq wolfcore OnkelTem nnon ARM9 Matajon nont_ shadowdaemon emlow ovibos docnvk dibblego spacegoat pacak vikraman coup_de_shitlord bogdanteleaga JuanDaugherty padre_angolano brixen quaestor marinintim thetallguy tdammers peterquest hnz Nahra iross chirpsal1 avalokite abrar Thra11 niteria hiratara wamaral monochrom jophish ortmage tobiasBora Vorpal otulp avn jokleinn felixsch derpderp boj bencryption bb010g[m] brian[m] M-cpt)
03:18:11 --- names: list (M-Magnap M-schmittlauch M-david radix M-krsiehl dschoepe srenatus[m] TheVoid vili_ OH- BigEndian __rlp Saimeidae acomminos vodkaInferno Ravana bd_ absence Nivim Mandus amf verement imalsogreg cdidd shymega obiwahn joeyh agrue psftw so koray pflanze Sigyn nitrix Rabbit__ bedouin runeks alphonse23_ zrl amatecha _flow_ cyberlard wolf_mozart hiptobecubic vfs andyo erikd sdx23 chattered cgfbee Natch mt rossberg_ `0660 oherrala eddsteel Bashmetim Cetusx texasmynsted)
03:18:11 --- names: list (kwantam Uakh Biohazard acertain katymoe Nik05 Morgawr Willis Guest54783 josephle whiteline TheAuGingembre shwouchk bananagram rwiggins rbocquet adimit Xnuk dario sbrg lieven okek yminsky sbauman gothos brt1 zpconn__________ fr33domlover nek0 gabiruh mitch_ joedevivo shans_ spicydonuts TimWolla drdo jonrh zph_ caasih ircbrowse wizonesolutions xplat|work orcus vikram__________ Ulrar cin huonw glguy bjs alevy stasku____ mpickering phuu Elsi rockfruit da-x carc)
03:18:11 --- names: list (aristid DigitalKiwi bartavelle Xorlev jroesch_ codedmart NemesisD banjiewen qguv afcondon marcel OliPicard jcp tomus nyuszika7h PotatoGim lancetw stephe valdyn SLi Lord_of_Life liff staffehn_ Bigcheese M-ou-se atk abbe aweinstock theDon Myrl-saki kurros divVerent besenwesen ClaudiusMaximus cods lokydor kolko sword_smith Ralith_ hegge rotcpy worch wedens catsup georgew sivs shutdown_-h_now rotty thimoteus mimi_vx chishiki Moyst schjetne rhovland jgertm)
03:18:11 --- names: list (MindlessDrone lachenmayer cYmen Jinxit Flaeme geal davl edwtjo bvad_ TommyC flonk Akii alpounet_ Cerise KaneTW yarou RGamma Phillemann joeytwiddle tnks knyppeldynan zerokarmaleft karshan koomi simony hpd tobik ernst ephess_ gargawel eagleflo arw rntz SphericalCow dilinger Hijiri s4msung knittl jstimpfle deni scopedTV zomg angseus kennyp T0pH4t bluepixel shesek luluapple mudfog ijp l0rdPE Zemyla etabot martinga_ albel727 hvr tolt jb55 kav _ashbreeze_ Blkt)
03:18:11 --- names: list (Tinchos quuxman Iceland_jack Sonmi tristero andrewsw etrepum u-ou rainbyte kier jml fiddlerwoaroof si14 Wamanuz Axman6 hansihe loopspace Scorchin stevenxl nkpart sdemos ryanpcmcquen defanor micmus mw euphoria- qnikst Ankhers greenbagels marens wagle guampa Xack Ranhir kantokomi sevsp Profpatsch fractalcat DrCode hpc irishsultan Starfire lhynes seyt sujeet Plastefuchs fengshaun ChongLi mokus _6a68 spacebug heurist acro nekomune snoogie teppic alem0lars Klumben)
03:18:11 --- names: list (xacktm SolarAquarion BrianHV eatonphil SAL9000 moredhel reqq456 ppnkk jimki taruti nesqi pdgwien Sonderblade M2tias DustyDin1o nshepperd_ Skuzzzy riscool shirt surtn m1dnight_ opios lanodan StoneToad mmaruseacph2 greeny John[Lisbeth] Tristan-Speccy Freundlich bsermons mephx oberstein dzack tessier wrmsr ahihi cocreature amiri psacrifice schnizzle chris2 dxtr quicksilver Laney mitchty samgd Hafydd Pucilowski nmattia mikeplus64 scared nlz UFODivebomb Paks)
03:18:11 --- names: list (dstockwell jlyndon gseitz libreman Kneiva icedev frontendloader crough Robin_Jadoul RevJohnnyHealey acowley koz_ cchalmers navilan kishar razi1 jrib1 magicman freekevin jorj nathanel_ CindyLinz phaazon hator michaf r143255 telmich jessicah Oxford parsnip Neo zimp Ring0` Rembane brennie ddima_ hanDerPeder nckx sleepynate tazjin thebnq c-rog_ erg betawaffle asjo martinbjeldbak_ callumacrae Reyu Guest77194 tych0 nathyong_ ephemeron tokik maskd jlewis_ naudiz)
03:18:11 --- names: list (MitchW liste pdxleif KeelOfSteel boostedcabbage bgamari Xe Majiir Adios codebam ryoia tarcwynne_ drewdavis cstrahan CARAM__ beckyconning_ pootler_ bgyss shelling__ fuziontech shennyg sewilton wyvern henriquev bigs zero7 reynir oelewapperke jorendorff_ d3lxa MasseR dredozubov_ statusbot tumdum pmade unsymbol armlesshobo henrytill strmpnk Tiktalik cjwelborn fingerzam niko hausdorff low-profile SoupEvil zeroskil1or thoughtpolice dh jrslepak chelfi Cr8 seliopou)
03:18:11 --- names: list (Vbitz carter andreypopp xa0 etcinit louispan YP-Cloud__ nyandoge sclv dkua Nycatelos ssedov kyagrd dgonyeo Guest34040 seanparsons jmct integral TRMander1on kuno happy0 myfreeweb SenpaiSilver Forkk cross borkdude swistak35 Ariadeno WzC Twey fairfieldt Kruppe sleezd dixie gbarboza ps-auxw buoto rfw edwardk yorick Liskni_si MorTal1ty solatis slick reem sisir__ mno2 mankyKitty jfokkan__ monad_cat t0mb0_ Fubar^ cjh` hive-mind lexi-lambda optocoupler earthy baweaver)
03:18:11 --- names: list (cloudhead danieli keix octo_ acfoltzer Geekingfrog mlhmwglt tctara Ashy gornikm burp xfix iphy skrio tswett norotartagen Satyajit APic lukexi PlasmaStar alang_ nopf zaquest sm platz fryguybob tjbp case39 dyreshark croben nilOps aaronm04 jotrk sz0 dredozubov trevorriles tomku monkeyiq krgn infinity0 Nikotiini Didac lnaia isochronia posco julm siddhu PanicSkittle tommd chameco marko___ Xandaros nullfxn noplamodo spaceships AppleJacks24_ toure raek psmolen Reda)
03:18:11 --- names: list (zhulikas tortal Jaxan Nimatek woffy wting Tharbakim mniip ByronJohnson yusukesuzuki WizJin keemyb tippenein [swift] davean hemite c_wraith ynyounuo thomas bitonic mattp_ fyolnish luite zopsi cnr jmiven Simson-san Fylwind bydo alercah aupiff_ superfatkappa newsham Raptor8m3 mak` jtcs warc solidsnack incomprehensibly nolrai_work pkogan mvr_ dmoon1221 fabianvf przembot TabAtkins ongy usr sevas JackMc jak xnyhps metaf5_ fall_ LiaoTao_ kungp DANtheBEASTman potatoe`)
03:18:11 --- names: list (indiffernet greymalkin Drezil_ hyperboreean ReinH asm89 kjanosz mkurkov AlainODea kini brisbin jrp6 dan64 Lutin` Eagle_Erwin l3france mathu jackhill mads- Ke zyoung benjamincrom hongminhee ski trig-ger joco42_ hydraz urdh abra0 jinblack ent DDR Athas dca cow-orker cmn ggVGc _janne supki_ cynick codebje orzo bind jix_ Jello_Raptor mero hodapp staticfox Speed eL_Bart0 johl kloeri max-m andjjj23 johtso mach squimmy abk7 CosmicRay tzaeru_ ario patha mkloczko Horv)
03:18:11 --- names: list (Saizan lenstr fergusnoble Sam_ alang ironChicken logcat bergmark Yaiyan Fuuzetsu trajing owa aleator qnix spinda elgot Vq dwynwen_ddlleyw Jaak mnoonan heyj dxld jokester kriztw fold4 zenzike vqrs dogui bjobjo ricardo82 PierreM je5finger lyxia Intensity x1n4u Bez_ Oxyd Elision_ anoe bengt_ julienXX erebe1 enolan bounb emiliocobos hc dunj3 avdi aatxe adamCS Edoxile adamh angular_mike RazorX- barrucadu pfoetche1 Igloo ggherdov kjnilsson Tritlo paf31_ nbouscal)
03:18:11 --- names: list (mauke osfameron wtw funfun ramatevish yamadapc caw arcetera ocharles yaknyasn sephiap tjpeden lpaste Purlox ixian ericbmerritt GGMethos otterdam statusfailed swhalen sphalerite KorriX joachifm flux phadej pleiosaur eyenx_ hyPiRion Chousuke JRHaigh rtur gsingh93 obihann lispy PHO notdan obcode Eliel_ sjl__ XMunkki_ Greezler Desoxy comboy hbar_ seagreen bcoppens gnusosa JDevlieghere uwap arianvp lpsmith fmapE mjrosenb guios mindos_cloud____ lyddonb ndeine peddie)
03:18:11 --- names: list (cjay pyrtsa kshannon jzl amuck owlscientist lattenwald gmci rstone mbrcknl nikola niluje luigy Ewout japesinator demize tumdedum sparr qz exio4 yeltzooo9 numberten honkfestival o`connor_ hxegon_afk wayne stux|RC-only pchiusano Factionwars dalmahal tinco alex_lu qinusty FMJaguar sanitypassing johnstein dustinm gpampara trilog no_hate chriswk brezel kipd ajmccluskey kmicu Tene pelegreno JPohlmann chrzyki killtheliterate alanz SuperTux88 cbaines raid minad)
03:18:11 --- names: list (codehero nemesit|znc spwhitt_ Quintasan brolin_empey keteim BrAsS_mOnKeY lucz srhb Taneb arrdem sinopeus zxtx IndigoTiger rom1504 kipras avocado Amadiro relrod isomorphismes mj12` clever gridaphobe __main__ parsnipM_ xxpor shapr mrd luis Vivek lstrano Clint Atlanis lukky513 sohum hiredman marmoute Ov3rload tomaw Adeon Belgarion0 pharaun EvanR @ChanServ sajith)
03:27:15 <quchen> dolio: So I just talked to Edward, and he told me youâ€™d remember how seq# works. Iâ€™m trying to understand how, although STG cannot scrutinize functions, you can `seq` functions in Haskell.
03:27:46 <quchen> Is there just a rule that returns from a case without popping a return frame if it finds a function thunk?
03:47:39 * hackagebot ascii-cows 0.0.1.0 - A collection of ASCII cows. Moo.  https://hackage.haskell.org/package/ascii-cows-0.0.1.0 (passy)
04:02:46 <koz_> OK, this is weird. In one of my tests, Haskell is complaining that there's no instance of Arbitrary for my type, even though I explicitly made one.
04:09:40 <rhovland> koz: that sounds ironic
04:10:33 <koz_> rhovland: Ironic, and hella-confusing.
04:10:43 <hexagoxel> is there a way to check execution time of a testcase in hspec or any other testing framework?
04:12:40 * hackagebot data-check 0.1.0 - Library for checking and normalization of data (e.g. from web forms)  https://hackage.haskell.org/package/data-check-0.1.0 (mrkkrp)
04:12:46 <hexagoxel> i wish to secure against accidental asymptotic complexity by having some large-n testcases.
04:14:14 <rhovland> hexagoxel: well, seems like looking at various 1x, 10x,100x, etc would be better for that
04:15:59 <hexagoxel> rhovland: sure, if there was a testsuite that provided easy tooling for that, even better :p
04:16:24 <rhovland> hexa: I don't have anything helpful other than that.. I mean, I don' tknow why asymptotic complexity would come up and surprise you
04:18:28 <hexagoxel> yesterday i called a function on the first, and then on every element of a list during a recursive descend. suddenly, exponential.
04:18:53 <hexagoxel> it was dumb, but not immediately obvious to me either.
04:20:20 <maerwald> hexagoxel: just write a benchmark?
04:20:29 <maerwald> e.g. with criterion
04:21:36 <koz_> OK, this is wtf. If I import Test.Tasty.QuickCheck, all my custom Arbitrary instances shit themselves. If I import just plain Test.QuickCheck, they work fine.
04:22:07 <hexagoxel> i'd prefer if there was a single command to run any (unit)tests and this kind of basic performance regression checking
04:23:05 <zomg> hexagoxel: run-tests.sh? ;)
04:23:25 <maerwald> hexagoxel: there is, see criterion
04:23:41 <maerwald> if your unit tests are properly structured, it should even work with code sharing
04:30:32 <hexagoxel> maerwald: can you perhaps point out any packages that use criterion in this way, i.e. for automated testing and not just manual benchmarking?
04:31:29 <hexagoxel> (oh, wrapping a hspec testcase in `timeout` might be a quick and dirty solution)
04:37:07 <hexagoxel> (sorry if my question/intention was unclear/too vague. i appreciate the input!)
05:20:25 <Teddy_Smoker> Greetings everyone. I come from a Rails and MEAN / JavaScript background, I would like to start using and learning Haskell. Any tips on where to start? Also, is it favorable to build web applications with Haskell frameworks?
05:21:33 <ertes> Teddy_Smoker: hi there!  obviously biased answer to your latter question: yes =)
05:22:42 * hackagebot monad-lgbt 0.0.2 - Monad transformers for combining local and global state.  https://hackage.haskell.org/package/monad-lgbt-0.0.2 (MichalGajda)
05:23:14 <Teddy_Smoker> ertes: Hey, thanks for the answer! I heard that Haskell is quite difficult, but very rewarding. Is that true? 
05:23:43 <ertes> Teddy_Smoker: the former is a bit trickyâ€¦  most current learning materials are anywhere from controversial to generally disapproved
05:26:11 <ertes> Teddy_Smoker: i wouldn't say that haskell is difficult, but it is very different, so you may find that you'll have to unlearn some ruby/JS knowledge
05:27:29 <ertes> Teddy_Smoker: i hear good things about this book, but i'd wait for the second edition in august: http://www.cs.nott.ac.uk/~pszgmh/book.html
05:28:05 <Teddy_Smoker> ertes: Yeah. Heard about that, it just seems like a programming language that will help me expand my knowledge. 
05:28:22 <Teddy_Smoker> ertes: Oh, I will be sure to bookmark that and check next month to see when its released. 
05:32:46 <ertes> i remember my first steps using "the haskell road to logic"
05:32:55 <ertes> and no, i don't recommend it =)
05:33:27 <ertes> it's not *bad*, but it's dry and has more of a math touch than engineering
05:33:40 <ertes> also it's pretty much completely outdated now
05:34:02 <Teddy_Smoker> I know how those books can be.. waste of time, frankly. 
05:36:57 <Teddy_Smoker> ertes: Did it help you learn Haskell better though? 
05:37:58 <ertes> Teddy_Smoker: good questionâ€¦  one problem of ignoring the engineering side of things was that it never properly explained some of haskell's key features
05:38:06 <ertes> for example that patterns in a function are tried in order
05:38:28 <ertes> it focussed more on making haskell look like math
05:38:55 <ertes> on the other hand it taught me some new ways of thinking, but honestly i think you'll learn them anyway as you learn haskell
05:39:36 <ertes> Teddy_Smoker: to elaborate: in haskell a completely hand-written list function might look like this:
05:39:47 <Teddy_Smoker> ThatÂ´s something I hear a lot about haskell, the fact that it will teach you new ways of thinking. 
05:39:49 <ertes> addOne (x : xs) = (x + 1) : addOne xs
05:39:52 <ertes> addOne [] = []
05:40:21 <ertes> it's two clauses defining inductively what the function does
05:40:55 <ertes> you might consider it an uninteresting detail that during evaluation these two cases are actually tried in orderâ€¦  there is no magic going on
05:41:37 <ertes> but in the book i was puzzled about that until i just tried it out myself
05:41:39 <mettekou> Does exporting a module from another module not expose its symbols for linkage? I'm getting errors from ld for an executable of which the modules refer to some symbols from a library module which the exposed library module re-exports.
05:42:47 <ertes> mettekou: exporting has nothing to do with linkingâ€¦  usually such an error means that you missed modules in your .cabal file
05:43:39 <ertes> mettekou: make sure you list all non-main modules under other-modules in executables, and in libraries list all modules either in exposed-modules or other-modules
05:44:38 <mettekou> ertes: I didn't realize all modules for the library should be under other-modules, I assumed the exposed module under exposed-modules was enough. Thanks!
05:45:09 <ertes> mettekou: all modules must be listedâ€¦  exposed-modules only lists those that can actually be used from other packages
05:45:29 <ertes> mettekou: internal modules belong under other-modules
05:45:55 <ertes> mettekou: there is a simple way to make sure you got your modules right:  use sdist and see if your tar.gz compiles
05:47:11 <Teddy_Smoker> ertes: Wow. I barely joined this IRC and already learned something interesting. Thanks so much! 
05:47:43 * hackagebot hasql 0.19.14 - A very efficient PostgreSQL driver and a flexible mapping API  https://hackage.haskell.org/package/hasql-0.19.14 (NikitaVolkov)
05:48:03 <ertes> Teddy_Smoker: the closest to a book i can recommend until the aforementioned one comes out is this one:  http://book.realworldhaskell.org/
05:48:37 <ertes> Teddy_Smoker: it's a bit dated, and some of the material is a bit dense, but overall it should give you the basics
05:49:06 <ertes> Teddy_Smoker: if something from the book doesn't work, don't worryâ€¦  just ask here!  haskell has changed over the last few years
05:51:12 <Teddy_Smoker> ertes: Thank you, I will start reading right away. One last question, how is HaskellÂ´s performance on Windows machines? I have a dual-booted computer with Fedora and Windows on it, should I only try it on the Linux OS? 
05:51:58 <ertes> Teddy_Smoker: i hear that there are a few gotchas on windows, but nothing that makes it unusable
05:52:23 <ertes> Teddy_Smoker: what is definitely a problem on windows is foreign bindings, most notably if you want to write GUIs
05:52:41 <ertes> i hear nightmare stories of getting things like GTK+ or WX to work
05:53:00 <ertes> so if you want to write GUIs, better write web GUIs =)
05:53:59 <Teddy_Smoker> I will remember that!
05:55:22 <ARM9> or use the Win32 library
05:56:02 <ertes> i don't think these problems are related to haskell, but more generally the difficulty of using libraries on windowsâ€¦  it's not as smooth an experience as on linux, where compiling and linking against libraries is a common thing to do
05:56:48 <ARM9> no, the problem is that microsoft supports a completely different toolchain
05:57:03 <ARM9> and the mingw community is relatively small
05:57:15 <ertes> yeah, makes sense
06:12:44 * hackagebot tagged 0.8.5 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  https://hackage.haskell.org/package/tagged-0.8.5 (ryanglscott)
06:44:23 <felixb_> Hi, I'm trying to write an evualtor for a little languagebut I want it to perform some IO stuff while it evaluates, eg read from files, print, etc. So far I have type Eval a = (StateT VarEnv IO (ThrowsError a)) and then the eval function has type  Expr -> Eval Expr
06:45:01 <felixb_> I'm wondering if this is the right direction, it seems a little clunky and sure as hell does not feel right
06:45:22 <felixb_> Oh and ThrowsError = Except LangErr
06:58:40 <m0rphism> Assuming a type `data Foo b a` is there a library which allows deriving a lens `Traversal` over `b` using Template Haskell?
07:00:38 <m0rphism> (That is, a traversal which would behave as the Traversable one derived via the DeriveTraversable ghc extension for `data Foo a b`)
07:04:48 <lyxia> felixb_: why not put ExceptT as another transformer layer?
07:10:21 <felixb_> Sorry, I am quite new to this. Do you mean using ExceptT rather than Except?
07:12:17 <lyxia> yeah, ExceptT LangErr (StateT VarEnv IO a)
07:13:00 <m0rphism> lyxia: there's a type, you probably mean: ExceptT LangErr (StateT VarEnv IO) a
07:13:09 <m0rphism> *typo
07:13:12 <lyxia> oh yeah
07:13:15 <lyxia> m0rphism: thanks
07:13:29 <ertes> felixb_: what does your language look like, and what evaluation semantics does it have?  do you have working code?
07:15:08 <m0rphism> felixb_: also what aspects do you find clunky? If you want to get rid of the `lift`s, you can use the `mtl` library, for example.
07:15:26 <ertes> felixb_: what is VarEnv?  variables in scope?  what is ThrowsError?
07:16:57 <felixb_> Call by value semantics? if that's what you mean? VarEnv is (Map String Expr) ThrowsError is (Except LangErr)
07:17:50 <felixb_> I do have working code, it's just incorperating IO that's confusing me a bit. But thanks for the answers, that helps.
07:17:52 <ertes> felixb_: first we need to understand the nature of your language, so if you have already designed an AST, it would be really helpful, if you could paste it
07:17:57 <ertes> @where lpaste
07:17:57 <lambdabot> http://lpaste.net/
07:19:36 <felixb_> http://lpaste.net/171197
07:19:44 <felixb_> that's the syntax of terms
07:20:19 <ertes> that's an imperative language, right?
07:20:25 <felixb_> Yes
07:20:35 <ertes> ok, then StateT makes sense
07:22:12 <ertes> felixb_: does execution cause side effects, or do you simply compute a result value?
07:22:54 <felixb_> At one point soon I hope to add side effects
07:23:26 <ertes> are you going to use IO exceptions for errors?  or do you want/need pure exceptions?
07:24:20 <felixb_> IO exceptions are fine for errors
07:25:05 <ertes> felixb_: and the result is supposed to be another expression?  not a result value?
07:27:06 <felixb_> Hopefully a certain expression that represents a value, eg EInt or EUnit or something
07:27:32 <ertes> felixb_: is your language dynamically typed?
07:28:26 <felixb_> No, staticly typed
07:29:16 <ertes> felixb_: i'm assuming that this is one of your first language implementations in haskellâ€¦  under that assumption i'd say that it's a good first step
07:29:23 <ertes> just get rid of Except and use IO exceptions
07:29:50 <ertes> as a next step you may want to learn about GADTs, so that you can actually encode the result type by sharing haskell's type system
07:30:35 <ertes> then you're going to have (Expr :: * -> *), such that the type argument represents the result type, and you can't construct ill-typed programs
07:31:02 <ertes> the interpreter will then look like this:  runExpr :: Expr a -> StateT VarEnv IO a
07:33:09 <felixb_> Ah, thanks, it is my first attempt at a language. Although actually now that I think about it- the plan is to have a langauge that compiles to LLVM first of all and errors should be caught at compile time / in the typechecker? So what kind of error makes more sense in that context?
07:33:37 <felixb_> Yeah I have seen GADTs about the place and i'll look into them, thanks.
07:35:00 <ertes> it dependsâ€¦  is this supposed to be an embedded DSL or a full-blown programming language?
07:35:23 <felixb_> Fully blown, although most of the action is in the type system
07:35:48 <ertes> the question is important, because that determines to what extent you can just share haskell's type system
07:36:12 <kirelagin> @free f :: a -> (b -> c)
07:36:12 <lambdabot> k . f x = f (g x) . h
07:36:34 <ertes> felixb_: do you want to implement your own type system?
07:37:27 <felixb_> Yes
07:37:40 <kirelagin> @free f :: a -> a
07:37:40 <lambdabot> g . f = f . g
07:37:48 <ertes> felixb_: you've got quite a task ahead of you then =)
07:38:12 <felixb_> haha in what sense? 
07:38:21 <ertes> felixb_: at least if your type system should be helping rather than hinderingâ€¦  making a C-like "type system" is actually pretty easy, but also pretty useless
07:38:53 <kirelagin> @free f :: a -> (b -> a)
07:38:54 <lambdabot> g . f x = f (g x) . h
07:39:41 <maerwald> C only has one type: 'char' :P (don't come with uint_8 plz :P)
07:39:48 <felixb_> the plan is type inference / reconstuction with type operators. But polymorphism is hard, so i'll see about that
07:40:02 <ertes> felixb_: designing an imperative type language is difficultâ€¦  surprisingly more difficult than a purely functional one
07:40:17 <felixb_> What are the major problems?
07:40:46 <ertes> felixb_: well, take haskell as an example:  everything has a type, so the type language can follow simple logic
07:40:55 <ertes> this sounds like a minor detail, but it's not
07:41:04 <maerwald> ertes: well, that's not so much about "functional" though, but aboure "pure"
07:41:06 <ertes> the fact that "actions" are first class values and that (>>) has a type is important
07:41:22 <ertes> it makes haskell's type language *simple*
07:41:23 <maerwald> ertes: e.g. back in the day rust had an IO type and was actually pretty close to the haskell typesystem
07:42:13 <kirelagin> @free f :: F (F x) -> F x
07:42:13 <lambdabot> $map_F g . f = f . $map_F ($map_F g)
07:42:15 <ertes> in an imperative language you lose all of that, so you need to come up with a clever language and type system design that can still infer sensibly and doesn't get in your way
07:42:15 <felixb_> Right, could one not just get away that saying an exprssion like print has type Unit and readFile or something has type String? obviously that has downsides
07:42:38 <maerwald> ertes: I don't think that's related to "imperative" really
07:42:41 <ertes> note that major languages designed by CS people have failed at this taskâ€¦  this is not to discourage you, but just to show you that it's a challenge
07:42:43 <kirelagin> @free f :: F x -> F (F x)
07:42:43 <lambdabot> $map_F ($map_F g) . f = f . $map_F g
07:43:00 <felixb_> Yeah, that was a motivations, loosly
07:43:28 <ertes> maerwald: the fact that everything, including actions, has a type, helps type inference a lot
07:43:45 <maerwald> ertes: yes, you can do that in imperative languages too, see rust
07:44:14 <felixb_> Right, so what kind of imperitive language features get in the way of type inference?
07:44:16 <maerwald> the only reason they removed the IO type was because they found it "silly" (to some it up). It worked fine though
07:44:22 <maerwald> s/some/sum/
07:44:27 <ertes> felixb_: most imperative languages split code into two types: values and "statements"
07:44:53 <ertes> maerwald: i'm not really familiar with rust
07:45:33 <maerwald> You can type effects in imperative languages too.
07:45:55 <ertes> i'm not saying you can'tâ€¦  i'm saying that you need to design it, and that it's a challenge
07:49:04 <ongy> In my experience hdevtools fails right when I need it most: when a file doesn't compile because of a compile error. So when I get a type error and press F1 (vim-plugin) I just get an error message instead of the type currently infered. Is there a tool that works, when the file has a compile error?
07:49:17 <maerwald> felixb_: you should ask some rust developers how they did it
07:49:30 <maerwald> if they still remember
07:50:15 <felixb_> ah, well in that case are there any resources that talk about interesting type systems in imperitive langauges? I've got Types and Programming langugaes in front of me but it's pretty functional and does not talk too much about imperitive language features
07:50:59 <Welkin> imperative languages don't have much of a type system to speak of
07:51:13 <maerwald> I remember the mailing list discussion where someone came up with that exact argument "IO type must be hard in rust", but that was actually not the reason they removed it.
07:51:28 <maerwald> Welkin: that's just false
07:51:50 <ertes> felixb_: is there a reason to make the language imperative?  because imperative idioms are usually easier to express in a language that is in essence functional, while the converse is not true
07:52:52 <ertes> felixb_: caveat: lazy functional languages that would naturally allow something like IO are more difficult to compile
07:53:27 <felixb_> My plan is not to make a lazy langauge
07:53:55 <ertes> then no IO for you =)
07:54:12 <glguy> M0rphism: lens package's TH module can generate traverse implementations like that
07:54:13 <felixb_> sorry, what do you mean?
07:54:14 <ertes> unless you make IO explicitly lazy, while keeping everything else eager
07:54:48 <ertes> felixb_: semantically IO relies on the non-strictness of (>>=) to work properly
07:55:25 <maerwald> strict by default doesn't mean you can't have laziness
07:55:34 <mjga> ertes: no (>>=) would work the same in strict language :-)
07:55:52 <ertes> mjga: (>>=) for IO *must* be non-strict in the second argument
07:55:57 <mjga> ertes: note that (>>=) :: m a -> (a -> m b) -> m b
07:55:59 <felixb_> I said i was planning on making it imperitive, but i guess i mean just incorperate some imperitive things like explicit mutability? loops? And no currying? Does that make it imperitive? Sorry sometimes I get a bit confused I have not been doing this for long
07:56:22 <mjga> ertes: evaluation of second argument is suspended until value of `a` is known!
07:56:41 <ertes> felixb_: focus on a minimal core languageâ€¦  that one can follow a number of paradigms
07:56:52 <mjga> ertes: indeed people are using IO Monad in strict languages
07:57:26 <ertes> mjga: people are using the fact that functions in those languages are inherently delayedâ€¦  in fact functions are often used to emulate laziness
07:57:38 <mjga> ertes: or at least until value of type `a` is passed on
07:59:11 <ertes> mjga: to understand what i mean, imagine an IO restricted to (>>), such that it's strict in both arguments
07:59:44 <ertes> mjga: forever c = c >> forever c  -- infinite loopâ€¦  the interpreter never figures out what the first action is
08:00:00 <mjga> ertes: IO restricted to (>>) makes little sense, since it would be just sequencing of operations (Monoid), without being able to read or examine anything :-)
08:00:15 <ertes> mjga: you're missing the point
08:00:24 <ertes> mjga: the point is that even in those languages (>>=) is non-strict
08:00:52 <ertes> if it were strict, you would get anything from terrible memory behaviour to diverging programs
08:00:55 <mjga> ertes: nope, I am just showing that without distinguishing operation, the (>>) + (return) is homomorphic to any sequence :-)
08:01:28 <ertes> also there is no reason why IO with only (>>) shouldn't make senseâ€¦  it would just be less powerful
08:01:34 <mjga> ertes: think about it in abstract way: IO makes you _interact_ with the world, not just make side effects
08:02:23 <glguy> I still haven't seen why it's not OK for >>= to be strict in its second argument
08:02:41 <glguy> I remember this discussion happening already
08:03:38 <mjga> glguy: second argument is a function, so it can only be evaluated when there is something known about the result of the first action... indeed "lazy IO" allows you to read files lazily
08:03:53 <mjga> so it happens that first argument passes results in lazy way...
08:04:18 <ertes> glguy: you're relying on the evaluation semantics of functions
08:04:26 <mjga> glguy: you are perfectly right: https://hackage.haskell.org/package/text-1.2.2.1/docs/Data-Text-Lazy-IO.html
08:05:06 <ertes> glguy: there is no inherent reason why (>>) has to be implemented in terms of a functionâ€¦  it might indeed just store two actions in some kind of data structure
08:05:16 <ertes> glguy: but then 'forever' will diverge
08:05:23 <mjga> glguy: it is just that we need Monads to say that we read the file before actions that may depend on its results
08:08:04 <glguy> You wouldn't have >> if >>= was strict in its second argument, but that's OK
08:09:08 <glguy> Ertes: and what kind of problem is there with relying on the semantics of evaluating functions?
08:09:23 <glguy> Which semantics can I rely on?
08:09:36 <ertes> glguy: imagine a restricted IO that has only 'pure' and (>>)
08:09:57 <glguy> Yeah, then strictness would be an issue
08:10:15 <ertes> glguy: unless you use the common function wrapper hack
08:10:17 <glguy> But you and I said >>=
08:10:31 <ertes> (>>) :: IO a -> (() -> IO b) -> IO b
08:10:39 <ertes> the function effectively emulates laziness
08:10:55 <glguy> Yup
08:14:46 <ertes> glguy: demonstration of the issue:  let c1 >> c2 = c1 >>= \_ -> c2
08:14:54 <ertes> now implement 'forever' in terms of (>>)
08:15:04 <ertes> it diverges
08:15:30 <ertes> if you implement it in terms of (>>=), it works
08:15:50 <glguy> First, that has nothing to do with whether or not >>= specifically is strict in its second argument
08:16:11 <glguy> Second I'm not talking about>>
08:16:34 <ertes> i'm talking about IO
08:17:18 <ertes> the issue pops up whenever you implement any IO/monadic combinator that doesn't happen to use a function for the next action
08:17:49 <glguy> I just objected to the statement about >>=. I agree that a strict language would make using >> for control flow a problem
08:18:19 <ertes> yeah, (>>=) itself can be strict in its second argument
08:18:42 <glguy> Then I think we're in agreement ðŸ˜€
08:19:31 <ertes> my font is unhappy, but yeah ;)
08:19:53 <buglebudabey> > words "this. is test"
08:19:55 <lambdabot>  ["this.","is","test"]
08:20:04 <buglebudabey> any way to remove punctuation?
08:20:44 <YellowOnion> How does my monad disappear?? http://lpaste.net/171207
08:21:03 <ertes> :t T.filter isPunctuation
08:21:04 <AirPlanes2> hi
08:21:04 <lambdabot>     Not in scope: â€˜T.filterâ€™
08:21:05 <lambdabot>     Perhaps you meant one of these:
08:21:05 <lambdabot>       â€˜M.filterâ€™ (imported from Data.Map),
08:21:11 <AirPlanes2> :help
08:21:14 <AirPlanes2> .help
08:21:15 <AirPlanes2> !help
08:21:16 <ertes> :t filter isPunctuation
08:21:17 <lambdabot> [Char] -> [Char]
08:21:22 <ertes> buglebudabey: ^
08:21:24 <lyxia> AirPlanes2: just ask your question
08:21:26 <AirPlanes2> sorry..
08:21:50 <ertes> buglebudabey: (import Data.Char for that)
08:22:06 <buglebudabey> > filter isPunctuation "this is . . test"
08:22:08 <lambdabot>  ".."
08:22:10 <ertes> whoops
08:22:17 <buglebudabey> i knew what you meatn its okay
08:22:18 <buglebudabey> lol
08:22:22 <glguy> YellowOnion: u need a return
08:22:23 <ertes> > filter (not . isPunctuation) "hello, there!"
08:22:25 <lambdabot>  "hello there"
08:22:31 <buglebudabey> thanks ertes
08:22:55 <lyxia> YellowOnion: m0   is unified with   (->) (V4 a0) there
08:23:36 <ertes> buglebudabey: it's a matter of self-controlâ€¦  must fix bug
08:24:23 <ertes> buglebudabey: i think many haskell programmers have thatâ€¦  observe:
08:24:33 <YellowOnion> glguy, I get a n error somewhat relating to lyxia is talking about.
08:24:42 <rick__> Hi, I'm stuck with this problem: how implement this recursive function (that doesn't typecheck)?  f 0 x = x; f n x = f (n-1) [x]
08:24:44 <YellowOnion> when I try return
08:24:59 <ertes> > map (\x -> sin(x) + cos(x)) $ [1,2,3,4,5]
08:25:00 <lambdabot>  [1.3817732906760363,0.4931505902785393,-0.8488724885405782,-1.41044611617154...
08:25:18 <buglebudabey> ertes are you sure this is supposed to be directed to me?
08:25:22 <lyxia> YellowOnion: why are you passing 5 arguments when its type asks for 4?
08:25:43 <ertes> buglebudabey: yeah, but feel free to ignore it =)
08:26:25 <buglebudabey> i'm confused what that has to do with the isPunctuation from Data.Char
08:26:26 <buglebudabey> :P
08:26:38 <YellowOnion> lyxia, Oh... haha I thoguh the type signature in the error was a bit strange using V4 as well.
08:27:38 <ertes> buglebudabey: don't worry about it =)
08:28:48 <caseof> I have functions f :: MonadError MyError m => a -> m b  and g :: MonadError MyError m => c -> m d    I'm trying to use g inside f but ghc tells me that: Could not deduce (MonadError MyError m3) from the context (MonadError MyError m1). Any idea?  
08:28:54 <lyxia> rick__: you can't have a type that depends on the value of the argument like that...
08:29:12 <lyxia> rick__: why are you trying to write this?
08:29:45 <glguy> caseof: You'd have to paste the problem code and actual error
08:29:59 <rick__> <lyxia> I'm interested in musical composition. So from a little structure to a bigger one.
08:30:42 <lyxia> I don't understand your point.
08:30:43 <caseof> glguy: Code is huge :(
08:30:50 <lyxia> rick__: how's that related
08:31:13 <caseof> glguy: But should this be possible in theory?
08:31:39 <glguy> Yeah, you should be able to use those in the same context
08:32:03 <caseof> f and g are defined in 2 different modules. Does this matter?
08:32:15 <glguy> no
08:32:40 <rick__> <lyxia> Ex. I've a list of musical values. I like to generate a list of all possible list of values obtained subtituing each value with other values, according with predefined functions.
08:35:11 <rick__> lyxya I mean, this substitutions have to repeat for a prefixed number of times.
08:35:31 <maerwald> ertes: following up, I found the reference:
08:35:31 <maerwald> "A long time ago we had an effect system and we made pure the default  (since we didn't want people accidentally leaving it out due to sloth)  and we made the impure specifier a very small and reasonable keyword:  "io". It was still a heavy complexity bill (required a full extra  dimension of subtyping, parametricity, etc.)"
08:35:31 <maerwald> http://thread.gmane.org/gmane.comp.lang.rust.devel/3674/focus=3855
08:36:51 <lyxia> rick__: I haven't exactly understood what you meant, but I'm certain the thing you were trying to write was quite unnecessary to that end.
08:37:14 <lyxia> rick__: http://xyproblem.info
08:37:44 <AirPlanes> Can you write kernel in haskell?
08:37:54 <AirPlanes> True or False?
08:38:25 <Zemyla> AirPlanes: You probably can in GHC, as it has stuff for manipulating pointers and can call foreign functions.
08:38:41 <geekosaur> http://programatica.cs.pdx.edu/House/
08:38:50 <AirPlanes> Who is that house belong too?
08:41:29 <rick__> lyxia. ok I try to make a concrete example with number i-> [m,m]-> [[q,q,m],[q,m,q],[m,q,q]]-> [[[o,o,q,m],[o,q,o,m].......
08:42:06 <rick__> lyxia (not number, but abbreviations of musical values).
08:45:16 <lyxia> I don't quite see a pattern there.
08:46:58 <rick__> lyxia in italian language i = 1/1; m = 1/2; o = 1/8. so I've to substitute a value generate with function like (/2) (/3)
08:47:40 <rick__> (\n -> [n/2,n/2])
08:48:12 <monochrom> wait, do you mean (\n -> [n/2, n/3])?
08:49:57 <ClaudiusMaximus> rick__: maybe you want Data.Tree instead of Data.List ?
08:50:05 <rick__> monochrom if I've a value 1/1 I can substitute it with [1/2,1/2]
08:51:32 <rick__> ClaudiusMaximus Yes the could be a solution.
08:51:48 <monochrom> I still don't understand. But perhaps "map (\n -> [n/2, n/2]) [a, b, c, d] = [[a/2, a/2], [b/2, b/2], [c/2, c/2], [d/2, d/2]]" is enough to get you started.
08:52:34 <monochrom> in general map f [a,b,c,d] = [f a, f b, f c, f d]  so just go wild with ingeniously designed f.
08:52:45 <rick__> monochrom Yes it's ok to start, but I'd like to continue the loop of substituion for n steps.
08:52:57 <monochrom> maybe f does n steps
08:53:17 <monochrom> consider for example map (f . f) [a, b, c, d]
08:54:15 <monochrom> no, maybe f.f isn't even well-typed
08:54:17 <rick__> monochrom Yes, but is it possible to parametrize le lopps with .. n?
08:55:04 <ClaudiusMaximus> > take 4 . levels . unfoldTree (\n -> (n, [n/2, n/2])) $ (1 :: Rational)
08:55:05 <lambdabot>  [[1 % 1],[1 % 2,1 % 2],[1 % 4,1 % 4,1 % 4,1 % 4],[1 % 8,1 % 8,1 % 8,1 % 8,1 ...
08:55:43 <rick__> lambdabot Yes, this is what I want.
08:56:05 <monochrom> nice
08:56:13 <lyxia> the third list is [q,q,q,q] though
08:56:41 <rick__> lambdabot but with also mix of values so [1%4,1%8,1/2,1%8]
08:57:19 <lyxia> lambdabot is a bot, it just replied with the evaluation of ClaudiusMaximus's expression
08:57:33 <rick__> lyxya, ok, thank you
08:58:10 <ClaudiusMaximus> you could store a list in each tree node, and unfoldTree (\ns -> (ns, some function that substitutes each item in turn)) [1]
08:59:14 <rick__> ClaudiusMaximus Yes, I think that is a good solution.
09:01:19 <Welkin> haha
09:01:22 * Welkin pets lambdabot 
09:01:26 <Welkin> good bot
09:02:26 <rick__> Thank to all for your advices.
09:06:54 <nitrix> newtype LinkT m a = LinkT { runLinkT :: m (IO a) }
09:06:55 <AirPlanes> talk haskell in haskell. offtopic nope
09:07:06 <nitrix> I cannot seem to be able to implement the Monad instance for this type.
09:07:31 <AirPlanes> wow
09:07:33 <AirPlanes> what is that
09:08:14 <nitrix> I'm probably just tired. Does m (IO a) vs IO (m a) affects the outcome?
09:08:49 <AirPlanes> https://play.google.com/store/search?q=haskell
09:09:25 <AirPlanes> sorry
09:11:01 <exio4> nitrix: yes.
09:11:16 <mauke> I don't see how to 'join' that
09:12:09 <nitrix> Would I have more success with IO (m a) ?
09:12:54 <AirPlanes> holy moly
09:13:36 <nitrix> Or do I end up having to implement a free monad?
09:13:52 <nitrix> glguy: Can you have a look at AirPlanes?
09:14:02 <AirPlanes> nooooo
09:14:02 <mauke> already happening
09:14:04 <monochrom> AirPlanes, if you don't have something constructive to contribute, please keep silent. Otherwise I will have to remove you.
09:14:05 <AirPlanes> please don't
09:14:16 <AirPlanes> please come to offtopic
09:14:52 --- mode: ChanServ set +q *!*@bzq-79-179-108-36.red.bezeqint.net
09:17:55 <nitrix> join ~ LinkT m :: LinkT m (LinkT m a) -> LinkT m a
09:18:48 <nitrix> IO (m (IO (m a))) -> IO (m a)
09:18:53 <nitrix> Ah I see what's happening.
09:19:28 <nitrix> exio4: mauke So both `IO (m a)` and `m (IO a)` wouldn't work?
09:19:51 <mauke> I don't if it's impossible, but I don't see a way to get that to work
09:19:56 <mauke> don't know*
09:20:26 <nitrix> It's possible only if you can provide a swap :: m (n a) -> n (m a)  operation between the two monads.
09:20:31 <nitrix> I've had that issue before :(
09:28:47 <nitrix> Can I get away with it by using a free monad?
09:30:15 <nitrix> It'd just pile up the monad layers and the runLinkT would recursively unwrap them until it can produce a final value.
09:54:24 <buglebudabey> can someone help me with this type error? http://lpaste.net/171220
09:54:57 <buglebudabey> i'm positive im applying the correct number of arguments
09:58:27 <Rotaerk> buglebudabey, is Document a [something] ?
09:58:35 <buglebudabey> [String]
09:59:38 <lyxia> buglebudabey: what's pWordGivenClass
10:00:02 <buglebudabey> I think I may have gotten to the issue, let me try something and I'll let you know if it doesn't work
10:00:39 <buglebudabey> i fixed it :P
10:01:06 <mniip> if m is Traversable
10:01:15 <mniip> oops I was scrolled up
10:01:26 <mniip> nitrix, you still having issues with monad transformers
10:02:21 <m0rphism> glguy: Thanks for the hint. I've looked in Control.Lens.TH before, but haven't found anything besides `makeLensesFor`, which seemed more explicit than the DeriveTraversable mechanism.
10:02:51 <glguy> Yeah, it would be more explicit
10:13:03 <m0rphism> glguy: Oh, in Neil Mitchell's `derive` library is an unexported module which seems to provide this functionality: https://hackage.haskell.org/package/derive-2.5.26/src/src/Data/Derive/Internal/Traversal.hs
10:13:48 <glguy> I should have code on github for it
10:14:36 <glguy> https://github.com/glguy/generic-traverse/blob/master/src/Data/Traversable/Generic.hs
10:15:26 <glguy> The naÃ¯ve implementation doesn't get the left associated <*> s 
10:15:56 <RyanGlScott> glguy: Code for what?
10:16:04 <RyanGlScott> (Sorry, joining this conversation late)
10:16:42 <glguy> Making a Traversable instance with generics in that last case (rather than using TH as originally asked)
10:16:57 <m0rphism> glguy: Awesome, thanks! Looks so clean with generics :)
10:17:13 <RyanGlScott> Ah! What is this 'boggle' stuff?
10:19:27 <glguy> Ryanglscott: it's an optimization in Haskell for using applicative and functor laws to rewrite generics derived traversals
10:20:05 <glguy> Fusing away unnecessary fmap or pure and left associating <*>
10:20:09 <RyanGlScott> Wow, that's impressive. How fast is it compared to DeriveTraversable?
10:22:23 <glguy> The generated code is the same
10:22:33 <glguy> Just that it uses generics
10:22:52 * hackagebot ListLike 4.5 - Generic support for list-like structures  https://hackage.haskell.org/package/ListLike-4.5 (DavidFox)
10:24:22 <RyanGlScott> Wasn't there a Trac ticket about GHC.Generics methods not inlining properly...?
10:24:46 <glguy> They don't inline properly in large cases
10:25:01 <RyanGlScott> Oh wait, you opened that ticket :P https://ghc.haskell.org/trac/ghc/ticket/11068
10:25:23 <gurki> any clash users in here? did hardware types get removed in later releases?
10:29:14 <glguy> Another issue is that ghc inlines the unoptimized version of things so whether or not things get too big to optimize if affected by where you use it
10:29:49 <mauke> s/if/is/
10:30:27 <glguy> Yeah, on phone, typos likely
10:31:06 <glguy> That's good fit rewrite based optimizations, bad for simplification and inlining based ones
10:34:02 <mauke> s/fit/for/
10:57:05 <bashed> I'm trying to use gtk2hs. I'm trying to register a callback function for a Window event. This is done using the 'on' function with the type 'object -> Signal object callback -> callback -> IO (ConnectId obect)'. The object here is the gtk 'Window'. The event 'keyPressEvent' has the type (Signal self (EventM EKey Bool)). So, I'm guessing the type of the callback should be (EventM EKey Bool). How do I create that? 
10:59:44 <trilog> I updated ghc and stuff and now it complains: "-this-package-key is deprecated: Use -this-unit-id instead", what does this mean and how to fix it?
11:05:39 <RyanGlScott> trilog: You're probably using an old version of cabal-install (1.22 or earlier).
11:05:58 <RyanGlScott> It's not explicitly an error to keep using it, but if you want that warning to go away, try cabal-install-1.24.
11:07:07 <hvr> RyanGlScott: iirc there can be subtle problems down the road; it's a serious warning
11:07:22 <RyanGlScott> In that case, please hurry up and upgrade :)
11:07:47 <hvr> RyanGlScott: I would have preferred if Cabal would error out if talking to an unknown GHC version
11:08:09 <hvr> or at least warn that it's an unusupported configuration
11:42:55 * hackagebot stitch 0.4.0.0 - lightweight CSS DSL  https://hackage.haskell.org/package/stitch-0.4.0.0 (Intolerable)
11:42:57 * hackagebot api-builder 0.12.0.0 - Library for easily building REST API wrappers in Haskell  https://hackage.haskell.org/package/api-builder-0.12.0.0 (Intolerable)
11:49:46 <mikail`> Hi, I'm reading about Monads. If we consider database actions, they can be considered to be both I/O and state changes, so which monad would you use to represent them or do you choose a combination of them?
11:50:10 <thewormkill> that depends on the API your database provides
11:50:44 <thewormkill> if you need to do IO, then IO it is. However, there are API's which expose a specialized monad.
11:50:50 <thewormkill> to address your general question:
11:51:43 <thewormkill> a state monad encapsulates internal state in your program, so it is in general not suited to communicate with a database system (which, normally, is "outside" your program)
11:52:01 <mikail`> thewormkill: ah, that makes sense
11:52:27 <EvanR> fetchRawDataForReport :: Foo1 -> Foo2 -> Db RawData
11:52:44 <thewormkill> if you want to see examples look for interfaces to big RDBMSes and acid-state on hackage
11:52:49 <EvanR> Db could be as simple as ReaderT Connection IO
11:53:07 <mikail`> ok thanks for the references
11:53:14 <EvanR> which is almost as simple as passing connection around and Db = IO
11:53:31 <EvanR> the latter is actually much simpler to set up
11:53:38 <mikail`> ok
11:54:11 <EvanR> dont confuse questions about monads with questions about whether you need IO for something
11:54:28 <mikail`> actually the reason why I am looking at monads is because I would like to create one to represent the different computation strategies in my program
11:54:38 <mikail`> i believe that is what they are for
11:54:48 <EvanR> or like last night, questions about monads with questions about whether you need mutation
11:54:50 <mikail`> is that correct?
11:55:08 <EvanR> mikail`: sounds kind of vague
11:55:18 <hpc> you might also look at persistent, which uses type families and whatnot
11:55:19 <mikail`> ok i will give you an example
11:55:38 <hpc> you'll be hard pressed to find "Monad" in its docs
11:56:36 <mikail`> I have a program which prices items. There are many ways to price a particular item: I could price them using analytical formulas, or I could price them using different technique use monte carlo, or finite differences etc
11:56:43 <dolio> Monads are for doing algebra. Embedded languages are often algebraic.
11:57:08 <mikail`> so depending on which monad I use I would get that computational strategy
11:57:11 <mikail`> for that item
11:57:25 <EvanR> mikail`: then you are thinking of the interface / implementation thing, i dont think monads should be involved
11:58:28 <EvanR> the way you described monads as "strategies for doing computations in different ways" might end up as unfocused as the use cases for "classes"
11:58:54 <mikail`> I am using typeclasses at the moment
11:59:06 <EvanR> if you write the type for the function that produces the price, then that function type is your interface
11:59:07 <hpc> "strategies for doing computations in different ways" is a descriptor that applies to if-then-else, fwiw
11:59:26 <EvanR> you can have different implementations of that function with the same type
11:59:32 <mikail`> yes
11:59:39 <mikail`> that's what i have at the moment
11:59:44 <EvanR> so its an instance of functional programming
12:00:04 <hpc> using type classes works if you're considering different things with the same interface
12:00:27 <EvanR> even then it might not be a good fit to go with type classes
12:00:35 <mikail`> yeah it doesn't
12:00:47 <hpc> since your items are likely to not be different types of things depending on the pricing mechanism
12:00:51 <hpc> you probably want something like
12:01:08 <hpc> data Item = {foo :: Bar, ..., price :: some stuff -> Price}
12:01:11 <hpc> or something like that
12:01:20 <EvanR> i was going to start with
12:01:21 <hpc> then when you construct an item, give it its own mechanism for determining price
12:01:35 <EvanR> type PriceStrategy = Stuff1 -> Stuff2 -> Stuff3 -> Price
12:01:55 <hpc> or data Item = Item {foo :: Bar, ..., priceStrategy :: PriceStrategy}
12:02:00 <mikail`> hpc: how does that help with one type being priced with many techniques?
12:02:08 <mikail`> ok
12:02:12 <mikail`> now it does
12:02:12 <hpc> data PriceStrategy = MonteCarlo | Analytical | FiniteDifferences | ...
12:02:18 <hpc> or something
12:02:28 <EvanR> mikail`: you can mix and match strategies all you want, they are just first class functions
12:02:29 <mikail`> yeah that looks good
12:02:43 <mikail`> i will try that
12:02:47 <EvanR> hpc's last type is a name for stratgies rather than their implementation
12:02:54 <mikail`> i think i jumped into the deep end pretty quick
12:02:56 * hackagebot data-elf 0.2 - Executable and Linkable Format (ELF) data structures.  https://hackage.haskell.org/package/data-elf-0.2 (MikhailVorozhtsov)
12:03:05 <mikail`> i saw monads and computation and got excited - lol
12:03:11 <EvanR> monteCarlo = _
12:03:16 <hpc> if you're storing items in an rdbms or something like that, you'd probably want an enum for strategies like what i wrote, since you can reify it
12:03:37 <mikail`> hpc: no, there won't be any db stuff
12:03:41 <EvanR> then data PriceStrategyEnum = _
12:03:43 <monochrom> data PriceStrategy = RollDice | MaximumOfCompetitors | YearlyIncrease Double
12:03:45 <mikail`> just pure calculations
12:03:46 <hpc> if that's not a concern and you want to have complete control over what price strategy each item uses, as just an arbitrary function
12:03:51 <hpc> use what EvanR wrote
12:03:58 <mikail`> ok
12:04:12 <hpc> it depends on what you need ;)
12:05:03 <EvanR> mikail`: watch out for the "i have a problem lets use any and all languages features for it somehow"
12:05:05 <EvanR> effect
12:06:05 <Welkin> EvanR: reminds me of the people who also use terminology that doesn't mean what they think it means, but they use it anyway
12:06:11 <monochrom> No, that is not the effect here. The effect here is "I have an essay explanation, let's actually believe it".
12:06:20 <Welkin> like "isomorphic javascript" used instead of "runs on the server and in the browser"
12:06:22 <EvanR> type classes in particular take some care to know when theyre appropriate
12:06:44 <hpc> Welkin: people say that?!
12:06:47 <Welkin> yes
12:06:48 <EvanR> they arent like classes in OOP which are probably for what youre doing
12:06:59 <trillozazza> !list
12:07:07 <Welkin> everywhere people are talking about "isomorphic" javascript
12:07:25 <EvanR> Welkin: ... like where
12:07:32 <monochrom> I guess they are eager to shoehorn "isomorphic" somewhere.
12:08:02 <nitrix> trillozazza: Our channle bot respond to commands with the prefix form of :, @ or > depending on what you're trying to do.
12:08:32 <EvanR> im not typing it into google and making the problem worse
12:10:19 <Welkin> just the other week I saw someone who was new to programming mention "isomorphic javascript"
12:10:59 <Welkin> and here... https://github.com/trueadm/inferno
12:11:04 <Welkin> read the first line of the readme
12:11:05 <Welkin> haha
12:11:38 <EvanR> hmm.
12:12:09 <EvanR> its an isomorphic library. for a minute i was going to say the server is an object, and the client is an object, and you can map js one way and the other
12:12:18 <EvanR> still doesnt make sense
12:12:56 * hackagebot dlist-instances 0.1.1.1 - Difference lists instances  https://hackage.haskell.org/package/dlist-instances-0.1.1.1 (GregWeber)
12:12:58 <erisco> I call upon the #haskell council to rule on the helpfulness of this documentation http://stackoverflow.com/documentation/haskell/251/hello-world/6125/factorial#t=201607231910329082786
12:13:20 <Welkin> erisco: I read that as "factorio"
12:14:53 <monochrom> erisco: I decide that it has the same helpfulness as the fibonacci example in the official python tutorial. (yes, they use fibonacci.)
12:15:11 <lyxia> the second variation is missing an Ord constraint
12:15:16 <erisco> is it suitable for the "Hello World" topic?
12:15:35 <erisco> lyxia, why does it need Ord?
12:15:55 <monochrom> I don't know. Is fibonacci suitable for demonstrating python variables and while-loops?
12:16:20 <Welkin> a good hello world is fib :D
12:16:35 <Welkin> > let fib a b = a : fib b (a + b) in fib 0 1
12:16:37 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:16:47 <monochrom> I can only decide that the two are equally valuable. I don't know what's the value.
12:16:50 <lyxia> :t \0 -> 0
12:16:51 <lambdabot> (Eq a, Num a, Num a1) => a -> a1
12:16:56 <lyxia> Oh, Eq.
12:17:08 <monochrom> But you know, if the oh-so-real-world python people do it, then it must be oh-so-real-world valuable, right?
12:17:54 <erisco> @let myfac :: Integral a => a -> a; myfac 0 = 1; myfac n = n * myfac (n - 1)
12:17:57 <lambdabot>  Defined.
12:17:58 <Welkin> another good one is a bottom-up mergesort
12:18:00 <lyxia> Integral implies Eq ?
12:18:02 <erisco> > myfac 5
12:18:03 <Welkin> very simple in haskell
12:18:04 <lambdabot>  120
12:18:38 <Welkin> of course there is a ever-popular treesort
12:18:45 <lyxia> erisco: nevermind :D
12:19:02 <lyxia> Ord => Real => Integral
12:19:17 <erisco> ah
12:19:27 <erisco> I did not know, I merely checked the example with ghci before I posted it
12:19:49 <hpc> treesort sounds like it's just mergesort
12:20:01 <erisco> well I am going to dismiss this complaint then :P
12:20:20 <monochrom> what complaint?
12:20:32 <erisco> that it was unhelpful and should be deleted
12:20:38 <slack1256> what was the name of the perl 6 implementation done in haskell?
12:20:43 <Welkin> hpc: it's the typical "quicksort" example everyone uses
12:20:44 <hpc> pugs
12:20:47 <slack1256> I remember hearing about it on 2009
12:20:50 <Welkin> that used to be on the front page of the website
12:20:52 <Welkin> or maybe still is
12:20:53 <EvanR> erisco are you the underground railroad smuggling information from #haskell to stack overflow?
12:20:54 <monochrom> yeah, tell them to read the official python tutorial fibonacci example.
12:21:03 <hpc> Welkin: oh, that
12:21:12 <erisco> EvanR, that is quite the elaborate analogy
12:21:20 <hpc> Welkin: now they have primes instead
12:24:37 <Welkin> I don't even understand how that primes example works
12:24:45 <Welkin> who chose that?
12:24:55 <erisco> EvanR, really it is undermining resources such as Haskell books, wiki, etc
12:25:28 <monochrom> wait, "it" = ?
12:25:47 <hpc> Welkin: 2 is the first prime, so produce that and then remove multiples from the list passed to the recursive call
12:25:58 <Welkin> yes, the stackoverflow "documentation" is really stupid
12:25:58 <erisco> monochrom, what you were looking at is a new initiative by Fog Creek to take over documentation resources
12:26:04 <hpc> Welkin: the next number is 3 which is prime, so produce that and then remove multiples of 3 from the list passed to the recursive call
12:26:05 <Welkin> whta's the point?
12:26:11 <Welkin> each community should have their own resources already
12:26:15 <hpc> Welkin: 4 is filtered, 5 is not, 6 is filtered, 7 is not, etc
12:26:17 <Welkin> don't give control to stackoverflow
12:26:30 <erisco> Welkin, what is the point of Wikipedia?
12:26:40 <EvanR> to confuse people curious about math and physics
12:26:52 <erisco> seems like a similar concept, only this is focused on technical nuance that is inappropriate for Wikipedia
12:27:20 <erisco> you will have a massive, coalesced resource of mediocre information
12:27:26 <erisco> but it is free and accessible
12:27:41 <EvanR> i spent a few years not knowing haskell because 2004 wikipedia said "but creating new monads is hard"
12:27:41 <erisco> which will push other resources further into the realm of specialty
12:27:52 <hpc> Welkin: imo it looks stupid when written as a list comprehension like that, and they should have used filter
12:28:02 <Welkin> hpc: so it is a recursive sieve
12:28:06 <hpc> yeah
12:28:24 <Welkin> it is hard to understand
12:28:26 <Welkin> not the syntax
12:28:30 <Welkin> but what the logic is
12:28:50 <erisco> so the point is that people are going to use it, and that's all
12:28:59 <hpc> or rather, what logic is not there
12:29:37 <hpc> you can say "it's Applicative with join :: f (f a) -> f a" all day and still have trouble breaking the idea of Monad being magic IO sauce
12:29:52 <erisco> so now we will have to battle with ideas on this field
12:29:56 <monochrom> reddit documentation is too late to the market, in terms of doing haskell documentation
12:30:04 <erisco> for example, there is a claim that [] is singly linked lists
12:30:12 <erisco> what do we collectively think about this association?
12:30:30 <monochrom> I will agree if "immutable" is added
12:30:38 <ReinH> monochrom: reddit or stackexchange?
12:30:50 <monochrom> oh wait, stackexchange.
12:30:50 <EvanR> erisco: thats exactly what it is
12:30:56 <Rembane> Isn't it an empty linked list?
12:31:11 <EvanR> [] the type
12:31:17 <ReinH> it's a linked list with a sentinel for the start of the list
12:31:18 <erisco> well, there is even discussion to be had on whether this is a relevant connection or if it is an implementation possibility
12:31:23 <hpc> [] is () in cartesian coordinates
12:31:26 <monochrom> and there is a difference between null pointer and the [] data constructor, but this can wait.
12:31:43 <erisco> "singly linked list" is often considered a concept tied to memory layout
12:31:43 <hpc> () of course, is [] in polar coodinates
12:31:47 <ReinH> monochrom: I guess it comes down to "fsvo linked list"
12:31:53 <erisco> where are the pointers, what do they point to
12:32:05 <EvanR> implementation details
12:32:11 <Welkin> show them the C ffi
12:32:12 <Welkin> lol
12:32:22 <hpc> erisco: often, but anyone who thinks that way is mistaken
12:32:22 <ReinH> I like that I can use a list zipper where I would use a doubly linked list with a sentinel in C
12:32:37 <EvanR> erisco: really, singly linked list implementations dont usually have a known memory layout.. 
12:32:41 <hpc> none of the classical data structures are defined in terms of memory layout
12:32:54 <EvanR> which is a big question mark for cache performance
12:33:20 <sleblanc`> singly-linked lists can be pre-allocated (then the question becomes: why not use an array, instead)
12:34:07 <Welkin> lol
12:34:37 <Welkin> in my data sctructures course, the professor talking about paging the memory to preallocate nodes for the singly linked lists
12:34:59 <EvanR> to be honest, explaining or agreeing that lists in haskell are singly linked lists (that are immutable) really helped me get what i could and couldnt do with them
12:35:06 <Welkin> too many gymnastics at that low of a level to perform
12:35:08 <nitrix> Can someone recommend me a library for playing monad distributivity? I'm interested in a distribute :: m (n a) -> n (m a) function.
12:35:27 <nitrix> Even better would be compose :: m (n (m (n a))) -> m (n a)
12:35:29 <Welkin> nitrix:  sequence
12:35:30 <hpc> Welkin: i make all of my singly linked lists out of registers
12:35:41 <ReinH> nitrix: monads do not generally compose (into monads)
12:35:44 <ReinH> or distribute
12:35:51 <nitrix> ReinH: Some can.
12:35:57 <hpc> nitrix: monad transformers?
12:35:58 <ReinH> Which is why I said "generally"
12:36:01 <slack1256> @package distributive
12:36:01 <lambdabot> http://hackage.haskell.org/package/distributive
12:36:10 <Welkin> hpc: not sure if that is a joke?
12:36:11 <slack1256> nitrix ^
12:36:23 <monochrom> It is not harmful to expose the implementational pointerness of [a]. In fact by the time you talk about sharing and about a dumb way to reverse in quadratic time, you will need it.
12:36:33 <nitrix> I looked at MonadCompose but the package doesn't compile because of an outdated dependency bound.
12:36:44 <nitrix> It does offer exactly what I'd want though.
12:36:51 <hpc> Welkin: 100% joke, your professor has his head filled with machine details
12:36:59 <slack1256> cabal configure --allow-newer?
12:37:08 <Welkin> yeah, that made the course a lot more difficult
12:37:13 <nitrix> slack1256: I don't see an instance for IO or how `distributive` would work for IO. Can you explain me?
12:37:18 <Welkin> too many implementation details introduced
12:37:38 <EvanR> hey weed out the people who only care about math
12:38:21 <EvanR> im sure WelkinU will be better
12:39:02 <slack1256> Maybe it can't distribute for IO. I am thinking in Maybe (IO a) and IO (Maybe a)
12:39:12 <EvanR> :t traverse
12:39:13 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:39:17 <Welkin> that is interesting though
12:39:23 <monochrom> :t sequence
12:39:25 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:39:27 <EvanR> ah
12:39:34 <Welkin> I think most schools use java (oh no) for their data structures courses, which is stupid
12:39:42 <Welkin> for computer engineering, mine used c
12:39:44 <monochrom> it's derived from traverse. you have the right gist.
12:39:48 <slack1256> sequence extracts the "monadic efect" from a structure
12:39:48 <Welkin> huge focus on implementation
12:39:53 <slack1256> this is the other way around
12:40:07 <Welkin> I think haskell is the best language for a general into to data structures
12:40:24 <slack1256> Welkin: Any book reference?
12:40:29 <Welkin> slack1256: hm?
12:40:42 <EvanR> the structures you use in C and haskell are totally different, and in java you just use a library
12:41:14 <Welkin> this https://www.amazon.com/Algorithms-Parts-1-4-Fundamentals-Structures/dp/0201314525
12:41:16 <nshepperd_> > sequence (Nothing :: Maybe (IO Int))
12:41:17 <slack1256> I am currently working Data Structures on C, if you say that maybe you have a data structures book for haskell?
12:41:17 <lambdabot>  <IO (Maybe Int)>
12:41:31 <monochrom> I use java for my data structure course because the students come in knowing two things for sure: java and python. guess which one is the lesser evil.
12:41:52 <EvanR> slack1256: theres okasaki...
12:42:09 <Welkin> okasaki is good
12:42:15 <monochrom> but don't you worry, I only talk about pointers and records.
12:42:28 <EvanR> in java??
12:42:32 <slack1256> BTW: Maybe (IO a) is really useful on its own right. Sometimes that kind of composition on monads is what you look for (instead of losing time with MaybeT IO)
12:42:33 <monochrom> yes
12:42:38 <Welkin> monochrom: the lesser evil is python, surprisingly
12:42:40 <EvanR> do you have a pointer class or something
12:42:50 <monochrom> no
12:43:01 <slack1256> EvanR: too advanced for me. But I am only reading this C book to then read Okasaki's
12:43:39 <monochrom> I want types. python is out.
12:43:49 <Welkin> python has types
12:43:53 <Welkin> at least now it does
12:44:03 <EvanR> what
12:44:07 <Welkin> python 3
12:44:14 <systemfault> IIRC, PEP8 added optional typing
12:44:28 <systemfault> Or was it another spec...
12:44:50 <systemfault> https://www.python.org/dev/peps/pep-0484/
12:44:52 <EvanR> what is a PEP
12:45:00 <erisco> this interface is wildly confusing
12:45:07 <Welkin> python something proposal
12:45:12 <systemfault> Python Enhancement Proposal
12:45:13 <monochrom> PEP is a language propose in python
12:45:16 <slack1256> Python Enhancement Proposal?
12:45:33 <systemfault> The same as PSR in php or JSR in Java..
12:45:41 <slack1256> isomophic!
12:45:51 <Welkin> as messed up as python is, it at least has first class functions and doesn't force a stupid oop/class system
12:45:54 <EvanR> well now i know what PSR and JSR is
12:46:20 <slack1256> it is equivalent to sending a mail to libraries and getting a +1 from edward
12:46:34 <monochrom> heh
12:47:00 <EvanR> Welkin: i felt like it enforced and oop class system ... maybe i was trying to do it right
12:47:43 <maerwald> EvanR: probably depends on the libraries you use, but generally no
12:48:03 <monochrom> python can be non-oo, if the only data format you work with is number.
12:48:51 <Welkin> what I mean is that not everything needs to be wrapped in a class
12:48:58 <monochrom> any time you use strings for example, be it homebrew string or library string, oo is suddenly once again forced upon you.
12:49:02 <Welkin> you can just use classes as types
12:49:07 <Welkin> no inheritance or methods
12:49:19 <EvanR> your terminology is confusing me somehow
12:49:21 <slack1256> how ``known'' do you have to be to vote on the libraries mailing list?
12:49:25 <Welkin> everything can be a top-level function
12:49:31 <maerwald> well, there goes the nitpicking again ;)
12:49:33 <Rembane> Welkin: Python is not Java?
12:49:38 <EvanR> do you mean objects as dynamically typed values
12:49:38 <Welkin> Rembane: yeah
12:49:46 <EvanR> and wrapped in objects
12:49:56 <glguy> slack1256: There isn't a vote tally, people mostly respond to articulated reasoning
12:50:00 <Rembane> Welkin: By that standard C++ is quite nice too. :)
12:50:09 <EvanR> i think im getting a good idea of PEP484 by ctrl-Fing "static"
12:50:20 <Welkin> Rembane: well, anything is nice compared to java, after my brief experience with it
12:50:38 <slack1256> glguy: I was then misreading their intents then
12:51:04 <maerwald> Welkin: oh, you like weak and dynamically typed languages like javascript, ruby and so on? Having seen that end... java is not so bad.
12:51:16 <Rembane> Welkin: You need to work with more languages I hear. :)
12:51:26 <Welkin> maerwald: I've been using more javascript lately, and it is not bad if you use it in a certain way
12:51:28 <maerwald> yeah :P
12:51:39 <Rembane> Javascript is very keen on foot shooting
12:52:09 <maerwald> Welkin: I'm not going to start a rant on the bugs I've seen (all caused by the lack of a type system, basically), but those are a lot
12:52:15 <Welkin> I've come to the conclusion that any type system like what java has is worse than using a dynamically typed language like python that at least has first-class functions
12:52:23 <maerwald> uh
12:52:38 <Welkin> yes, I used to hate working with dynamic languages too
12:52:48 <monochrom> I don't need first-class functions in my data structure course.
12:52:54 <Welkin> but I;ve come back to them after working in haskell for a couple years and they are not bad at all compared to java
12:52:59 <sleblanc`> Welkin: what's your take on C, regarding type system and "first class" fuctions?
12:53:00 <monochrom> not to mention that python's is still 2nd-class.
12:53:09 <Welkin> sleblanc`: c is basically assembly to me
12:53:10 <sleblanc`> (i.e. pointers to functions)
12:53:29 <Welkin> monochrom: sure, I don't actually like python. A better example would be lua or ruby
12:53:37 <EvanR> javascript is basically assembly to me
12:54:04 <EvanR> ruby also shits on functional programming
12:54:59 <glguy> The bathroom habits of other programming languages are off topic in Haskell
12:55:09 <maerwald> EvanR: hahaha
12:55:09 <sleblanc`> Anyone ever tried SuperCollider? it's a very interesting language
12:55:14 <Welkin> but yeah, since I had never worked in java before, I didn't understand why people hated static type systems (they meant ones like in java (or c/c++))
12:55:20 <EvanR> lets talk shit about haskell now
12:55:27 <Welkin> because haskell's type system is unknown to most of those people
12:55:29 <slack1256> fucking monads
12:55:35 <slack1256> how do they work
12:55:41 <EvanR> miracles
12:55:42 <Welkin> now I understand how useless most "static type systems" are
12:55:43 <sleblanc`> slack1256: burritos
12:55:46 <systemfault> Unicorns!
12:55:48 <Rotaerk> like burrit--wraps
12:55:59 <Welkin> I never programming anything high-level in C anyway, since I always just used it like assembly
12:56:03 <slack1256> don't put me a mothe*** scientist, he is making me piss!
12:56:03 <Welkin> programmed*
12:57:21 <Welkin> and writing a game in lua as I am now, it would be very nice to at least have basic type annotations (most of my errors), but it is workable
12:57:28 <Welkin> in fact, there are extensions for that already
12:58:23 <EvanR> can i have the lua extension which adds type annotations, static checking, laziness, better syntax, immutable data...
12:58:43 * slack1256 is learning C so he can read the rts
12:58:45 <monochrom> I have a cassava example, but it just uses Vector (Vector ByteString). I call it Untyped. I have another cassava example, this one uses Vector (Text, Text, Int, Maybe Int), which is better, so I call it Tupled.
12:59:09 <hodapp> RTS of what now?
12:59:13 <Welkin> ghc
12:59:21 <slack1256> yep
12:59:22 <monochrom> Now I have a third cassava example, and it uses Vector Marks, where Marks is my own record type. What should I call it? Recorded?
12:59:39 <EvanR> marxists
13:00:23 <EvanR> sigma n . Vector n Marks
13:00:25 <hodapp> I want to understand the C code of Hugs
13:00:28 <monochrom> EvanR, I think there is a hasklel-lua bridge for that
13:01:19 <monochrom> wait, you read GHC for how Hugs works?
13:01:57 <monochrom> they may use share some common ideas, but GHC is big, Hugs is small.
13:02:31 <slack1256> Mmm how difficult can be to do an embeed hugs?
13:02:37 <slack1256> to use in the domain of lua 
13:02:53 <slack1256> (or is that crazy talk that ignores the engineering costs?)
13:03:24 <monochrom> so you are like you train yourself for years to win an Olympic medal for heavy-lifting, and the purpose is to apply to be a construction worker...
13:04:05 <Welkin> sleblanc`: not sure what you are asking exactly
13:04:19 <Welkin> but the lua vm has been embedded inside the browser
13:04:24 <Welkin> isn't that how ghcjs works too?
13:04:35 <EvanR> equip hugs with an FFI and make it callable from C like ghc is
13:06:23 <monochrom> I now think I will call it Tailored.
13:09:35 <EvanR> shouldnt your first example be the ByteString of the entire csv file
13:10:15 <monochrom> haha, that will not be a cassava example, that will be a readFile example.
13:10:23 <EvanR> negatively typed
13:10:52 <monochrom> each example does both reading and writing
13:13:12 <nitrix> â€¢ Found hole: _ :: m (IO (m (IO b))) -> m (IO b)
13:13:31 <nitrix> I think I'm getting close to the solution? Is this implementable?
13:14:06 <Rembane> nitrix: It looks like a join.
13:14:08 <Rembane> :t join
13:14:43 <nitrix> Rembane: It's some monadic swap and some join.
13:14:54 <nitrix> Would IO allow me to do that?
13:15:17 <nitrix> Do I need an additional typeclass for `m`s that allows this swapping?
13:15:26 <lambdabot> Monad m => m (m a) -> m a
13:17:19 <Rembane> nitrix: What about sequence?
13:17:27 <Rembane> nitrix: Would that help you?
13:17:30 <EvanR> nitrix: mmorph?
13:18:13 <slack1256> nitrix: I think that exact example was discussed by spj on the ghc wiki page for commutative monads
13:18:20 <slack1256> let me look out for it
13:23:33 <nitrix> I essentially just need to figure out   m (IO a) -> IO (m a)   or    IO (m a) -> m (IO a)
13:23:45 <nitrix> Both are fine in my case (I think).
13:23:49 <hpc> well, the latter is impossible
13:24:13 <Welkin> lol
13:24:30 <erisco> "impossible"
13:24:44 <glguy> impossible
13:24:59 <hpc> in the way that i expect nitrix wants, yes
13:25:27 <EvanR> it would require runIO at least
13:25:39 <nitrix> So the former then. After that, it's some `join` juggling and I'm done :)
13:26:02 <Welkin> runIO?
13:26:08 <Welkin> so you *can* escape IO?
13:26:18 <hpc> @hoogle unsafePerformIO
13:26:18 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
13:26:18 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:26:19 <EvanR> escape?
13:26:36 <Welkin> EvanR: like runST
13:26:40 <geekosaur> there are ways to escape it. the compiler will happily punish you for using them without knowing what you are doing
13:26:46 <EvanR> runST is escaping?
13:26:47 <maerwald> s/escape/introduce semi-defined behavior/
13:27:13 <nitrix> I'd prefer sticking with the former unless I really have to do nasty things.
13:27:43 <Welkin> I've never looked into unsafePerformIO, but have heard several people talk about using it
13:27:46 <Welkin> why would you use it?
13:27:46 <nitrix> Granted, the complexity is at other levels. I'm almost done writing this library; this is the last piece missing (and I knew it'd be complicated)
13:27:58 * hackagebot language-webidl 0.1.3.0 - Parser and Pretty Printer for WebIDL  https://hackage.haskell.org/package/language-webidl-0.1.3.0 (izgzhen)
13:28:00 * hackagebot data-sword 0.2 - Shorter binary words  https://hackage.haskell.org/package/data-sword-0.2 (MikhailVorozhtsov)
13:28:19 <EvanR> Welkin: to evaluate code that has no side effects but has an IO type anyway, is one reason
13:28:34 <nitrix> Welkin: One of the examples I know, GHC uses unsafePerformIO for memoization.
13:28:50 <maerwald> when you have a C function that is actually pure?
13:28:50 <nitrix> I use it for resource caching in my game library.
13:29:08 <EvanR> maerwald: which the FFI has built in support for ...
13:29:08 <maerwald> some also use it for lazy IO instead of unsafecoerce or so
13:29:52 <EvanR> unsafeInterleaveIO
13:29:55 <maerwald> yeah
13:29:55 <hpc> for lazy IO it's enough to use... that
13:30:04 <hpc> @src unsafeInterleaveIO
13:30:04 <lambdabot> Source not found. You untyped fool!
13:30:07 <maerwald> it's not the same though
13:30:18 <hpc> iirc it's written in terms of unsafePerformIO
13:30:29 <hpc> oh, no it isn't
13:30:37 <hpc> well, sort of
13:30:51 <hpc> both are in terms of unsafeDupablePerformIO
13:31:34 <EvanR> which is written in terms of accursedUnmentionablePerformIO?
13:31:43 <hpc> heh
13:31:51 <hpc> it performs pattern matching on IO
13:32:23 <hpc> except it doesn't do anything, because IO's definition is effectively Identity
13:33:16 <hpc> through "type rep" stuff and State# having no concrete representation
13:33:33 <maerwald> hpc: https://github.com/jberryman/directory-tree/blob/master/System/Directory/Tree.hs#L356
13:33:46 <maerwald> I rewrote that to use unsafeInterleaveIO and it behaved slightly different afair
13:34:27 <maerwald> until I realized lazy IO is just bad, so I stopped :P
13:34:51 <hpc> heh, yeah
13:35:27 <hpc> a good exercise (and a really subtle one) is to work out why unsafeInterleaveIO is more dangerous than concurrent semantics
13:41:09 <Welkin> Teddy_Smoker: Ted?
13:43:23 <Teddy_Smoker> Welkin: Yes? 
13:43:26 <Rotaerk> hpc, because it says "unsafe" in the front
13:43:34 <Welkin> Teddy_Smoker: just commenting on your name
13:43:37 <Rotaerk> did I get it right?
13:44:47 <Teddy_Smoker> Welking: Haha, yours reminds me of the Â¨walkersÂ¨ from Walking Dead =)
13:47:58 <nitrix> I'm actually stuck, I think because my end type isn't good?
13:49:49 <nitrix> To provide an implementation that does  `m (IO (m (IO x))) -> m (m (IO (IO x))`  so that I can join twice and get my final `m (IO x)`, I'd need to `fmap swap` where swap is :: IO (m x) -> m (IO x)
13:49:51 <nitrix> Right ?
13:50:29 <nitrix> That was deemed impossible earlier I think? Is it just a bad decision on my part? Should my final type be IO (m x) instead and I rethink my implementation?
13:54:05 <Eduard_Munteanu> :t sequence
13:54:07 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:55:02 <Cale> nitrix: What are you trying to accomplish?
13:55:19 <nitrix> Cale: Composition of two monads.
13:55:21 <nitrix> newtype LinkT m a = LinkT { runLinkT :: m (IO a) }
13:55:29 <nitrix> IO and m
13:55:45 <Cale> Oh, that's probably not happening
13:55:47 <nitrix> Cale: I'm trying to implement instance Monad (LinkT m)
13:56:15 <EvanR> impastable
13:56:27 <Eduard_Munteanu> nitrix, you can't have IO as a transformer
13:56:33 <Cale> You need some evidence of some special relationship between IO and m, which if m is an arbitrary monad, you don't have.
13:56:56 <Cale> and which I don't know how to obtain for any particular m, with respect to IO
13:57:06 <nitrix> Eduard_Munteanu: https://hackage.haskell.org/package/MonadCompose-0.8.4.2/docs/Control-Monad-PlusMonad.html
13:57:12 <nitrix> Eduard_Munteanu: This package seems to hint otherwise.
13:57:14 <Cale> You need what's called a distributive law
13:57:23 <nitrix> Cale: I'm aware.
13:57:32 <Cale> Yeah, you don't have that.
13:57:40 <Cale> IO won't distribute over arbitrary other monads
13:57:53 <nitrix> But other monads can distribute to IO ?
13:58:09 <glguy> nitrix: That package hints that you could do this if you had a function that does this already (via the Dist typeclass)
13:58:24 <nitrix> glguy: I can implement that function, same way the package does.
13:58:52 <glguy> You'll have to provide an implementation for every m you want to use with LinkT
13:59:08 <nitrix> I'm perfectly fine with that.
13:59:28 <glguy> Cool, then you're done
13:59:58 <nitrix> Almost. The package is broken because of upper bounds dependencies, so I'm re-implementing it in a more compact form.
14:00:08 <Eduard_Munteanu> IO transformers break referential transparency.
14:00:54 <nitrix> Eduard_Munteanu: If it does, then transformers are quite flawed, no?
14:01:43 <EvanR> this isnt really the subject of transformers
14:02:18 <glguy> nitrix: No, it would mean IO transformers are
14:02:19 <Cale> nitrix: I don't know of any monad which has a distributive law with IO.
14:03:11 <EvanR> at first the goal was to make any type composition of monads commute
14:03:32 <exio4> nitrix: the easiest way to see why LinkT is .. impossible, is to specialize (>>=) and see the result :P 
14:03:34 <Cale> btw, that Dist is different from the usual one
14:03:39 <EvanR> now that its limited to one of them being IO... its still not any better
14:03:51 <Cale> https://en.wikipedia.org/wiki/Distributive_law_between_monads
14:04:00 <Eduard_Munteanu> :t dist
14:04:01 <lambdabot> Not in scope: â€˜distâ€™
14:04:09 <exio4> @type undefined :: Monad m => m (IO a) -> (a -> m (IO a)) -> m (IO a) 
14:04:10 <Eduard_Munteanu> :t distribute
14:04:11 <lambdabot> Monad m => m (IO a) -> (a -> m (IO a)) -> m (IO a)
14:04:11 <lambdabot>     Not in scope: â€˜distributeâ€™
14:04:11 <lambdabot>     Perhaps you meant â€˜distribâ€™ (imported from Control.Lens)
14:05:04 <Eduard_Munteanu> Anyway, f (g a) -> g (f a) is the usual one.
14:05:05 <EvanR> exio4: looks good to me ;)
14:05:42 <exio4> er, well, the type signature was nearly right!
14:09:49 <athan> Hey everyone, would anyone like to talk parser combinators?
14:10:11 <athan> I'm trying to understand the fundamental difference between what I call "greedy" parsers like parsec, and "liberal" parsers like attoparsec
14:10:45 <athan> from what I've seen, parsec consumes input even on failure, and backtracking is a nuisense in it, while attoparsec has backtracking built in
14:11:08 <athan> is this a byproduct of the capacity to check the current position and input in parsec, while no such facilities in attoparsec exist?
14:11:12 <athan> (or the other way around)
14:11:13 <glguy> parsec commits to a choice when the choice consumes some input, attoparsec commits to a choice when a  branch succeeds
14:13:02 <athan> Wow, that's clairvoyant. Thank you glguy
14:14:05 <jmi2k> ?src fmap
14:14:05 <lambdabot> Source not found. I feel much better now.
14:14:13 <jmi2k> ?src fmap
14:14:13 <lambdabot> Source not found. Maybe you made a typo?
14:14:15 <jmi2k> ?src fmap
14:14:15 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:14:17 <jmi2k> ?src map
14:14:17 <lambdabot> map _ []     = []
14:14:17 <lambdabot> map f (x:xs) = f x : map f xs
14:26:36 <hpc> Rotaerk: lol
14:33:38 <keemstar> hey
14:39:04 <keemstar> lolhello?
14:39:11 <lyxia> keemstar: what's up
14:39:24 <keemstar> nmuch, doing cs50x.
14:39:28 <keemstar> heard of it?
14:40:20 <lyxia> What is it?
14:40:50 <keemstar> a online cs mooc by harvard, its really good
14:40:55 <keemstar> on here as i plan to learn functional after it
14:41:57 <lyxia> I see. Feel free to hang around.
14:43:01 * hackagebot http-api-data 0.2.4 - Converting to/from HTTP API data like URL pieces, headers and query parameters.  https://hackage.haskell.org/package/http-api-data-0.2.4 (NickolayKudasov)
14:43:31 <Welkin> from edx?
14:43:43 <Welkin> coursera went to hell, so...
14:46:22 <keemstar> yep
14:46:23 <keemstar> edx
14:46:54 <keemstar> leraning c rn - comfortable with python so its a bit easier
14:48:01 * hackagebot Concurrent-Cache 0.2.2.3 - A Cached variable for IO functions.  https://hackage.haskell.org/package/Concurrent-Cache-0.2.2.3 (Ofenhed)
14:48:26 <glguy> The topic of #haskell is specifically Haskell programming
14:48:35 <keemstar> 9*9
14:48:42 <keemstar> 81
14:58:06 <GreenCeleryStick> Can someone point me to the GHC desugaring algorithm for converting the AST into CORE? Or is the source code the best place to start?
15:16:20 <cloudhead> would `procs v = takeMVar v >>= proc >>= procs v` blow the stack?
15:17:05 <cloudhead> since it's not a tail call, or does lazyness prevent that?
15:18:14 <hpc> it'll probably be a type error
15:18:30 <hpc> but it'll be fine
15:18:32 <hpc> @src forever
15:18:32 <lambdabot> forever a = let a' = a >> a' in a'
15:18:39 <hpc> bwuh
15:18:49 <hpc> oh right, knot tying
15:18:58 <hpc> forever a = do {a; forever a}
15:19:13 <hpc> you've basically written that
15:19:25 <hpc> you can do procs v = forever (takeMVar v >>= proc)
15:19:42 <hpc> and it'll look nicer, but mean the same thing
15:21:30 <cloudhead> hpc: why a type error?
15:22:04 <cloudhead> ah yes in my actual code there's an extra var that proc modifies and passes down, so I can't use forever
15:22:27 <hpc> does it not type error in your code?
15:22:37 <cloudhead> it doesn't, but it's not exactly my code
15:22:48 <hpc> you're using (>>= procs v), meaning procs is taking v and then the result of proc as well
15:23:02 <cloudhead> oh I see yeah
15:23:05 <cloudhead> processCommands var st = takeMVar var >>= flip processCommand st >>= processCommands var
15:23:08 <cloudhead> here's the actual code
15:23:10 <hpc> ah
15:23:14 <cloudhead> my bad
15:23:27 <hpc> yeah, that's perfectly fine
15:23:48 <cloudhead> cool, is there a simple explanation on why that doesn't stack overflow?
15:24:48 <cloudhead> I think I used to know this, but I forgot
15:24:55 <cloudhead> I guess it's the same as forever
15:25:43 <hpc> i don't have an accurate simple explanation prepared, but a very rough description of it is that once execution passes over part of an (a >>= b >>= c) chain, it forgets it
15:26:24 <cloudhead> I see, so it doesn't keep the stack frame hanging
15:26:44 <hpc> also, in ghc the stack is for evaluation only
15:26:54 <hpc> and for evaluating only one thing at a time
15:27:23 <hpc> think of it as having (x + y) at the bottom, then you push x
15:27:35 <hpc> then you evaluate x because that's how detailed this example is
15:27:39 <hpc> then you pop x because it's evaluated
15:27:43 <hpc> then you push y, etc
15:27:58 <hpc> (or y might be first, or depending on the type (+) might not evaluate both of them, etc)
15:28:18 <hpc> so it'd be that you ran out of heap memory if anything
15:28:26 <cloudhead> hmm ok
15:28:33 <cloudhead> what property of haskell makes it work that way?
15:28:51 <hpc> none, that's just how ghc is implemented
15:28:56 <hpc> and it meets the semantics in the report
15:29:01 <cloudhead> oh
15:29:12 <hpc> other implementations can do things differently
15:29:42 <cloudhead> but a correct haskell implementation would never overflow there
15:29:49 <hpc> i searched duckduckgo for "haskell report" and got the weather for haskell, texas
15:29:55 <cloudhead> haha
15:30:03 <hpc> a correct haskell implementation might overflow there
15:30:08 <hpc> but certainly not a useful one ;)
15:30:37 * hpc is finding a good page of the report to show you what kind of stuff is specified and what isn't
15:31:19 <cloudhead> cool, thanks
15:31:37 <cloudhead> I'm just trying to understand, because `forever` never returns there
15:31:58 <cloudhead> so I guess it's replacing the stack frame like a tail call, or doing something completely different
15:32:32 <hpc> https://www.haskell.org/onlinereport/exps.html
15:32:42 <hpc> search for "These examples demonstrate"
15:33:10 <hpc> https://www.haskell.org/onlinereport/basic.html - this basically reads like you're looking at Prelude's source itself
15:33:18 <hpc> https://www.haskell.org/onlinereport/io-13.html - IO
15:34:53 <hpc> sandwiching that section of the first link is the semantics of pattern matching, which is good to know but is likely information-dense for a beginner
15:35:02 <hpc> something to come back to later
15:35:46 <cloudhead> hmm I'm not sure how it answers my question
15:35:55 <hpc> it doesn't, directly
15:36:09 <hpc> it's just to get a sense of how distant from implementation details the standard is
15:36:53 <hpc> so there's not really a property of the language that makes ghc work the way it does, it's just the method they picked
15:37:03 <cloudhead> ah right
15:37:04 <hpc> usually because it's what works best on real hardware
15:37:35 <cloudhead> so you're saying the implementation of forever could be problematic in another haskell implementation
15:37:46 <hpc> only in bad ones ;)
15:37:50 <hpc> but yeah
15:37:57 <cloudhead> hehe
15:38:01 <cloudhead> interesting
15:38:28 <cloudhead> because obviously in any other language I can think of, that would blow the stack
15:38:39 <cloudhead> even say, erlang
15:39:06 <hpc> in languages with TCO, forever would usually hit that and work just fine
15:39:21 <hpc> because the last line of it is a recursive call to itself with different (the same) parameters
15:39:26 <cloudhead> but the tail call is `>>`
15:39:29 <cloudhead> not `forever`
15:39:58 <hpc> in those languages, (>>) is just semicolon ;)
15:40:18 <cloudhead> ahh but that's the thing though..
15:40:31 <hpc> ghc uses a very different evaluation model, to the point that TCO doesn't make much sense to even think about having
15:40:51 <cloudhead> if you look at it as `x >> \_ -> forever x` or so, it seems strange that TCO works
15:41:00 <cloudhead> right, yeah
15:41:20 <hpc> it's not really TCO that's happening here, but the effect is similar
15:41:38 <cloudhead> yeah
15:41:43 <hpc> often with ghc, writing something that's a traditional tail call will cause stack overflows
15:41:46 <hpc> @src foldl
15:41:46 <lambdabot> foldl f z []     = z
15:41:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:41:57 <cloudhead> I just did a double take writing that code, because it would be a mistake in most other functional languages
15:42:03 <hpc> the second pattern is a tail call
15:42:09 <cloudhead> yes
15:42:17 <cloudhead> that doesn't puzzle me
15:42:19 <hpc> what ends up happening for long lists is you build up a stack that's nothing but foldl
15:42:38 <hpc> well, "tail call"
15:42:48 <cloudhead> that kind of code would work in lua afaik
15:42:52 <cloudhead> which has tco
15:42:55 <hpc> foldl is the root of the expression, really is the problem
15:43:00 <hpc> @src foldr
15:43:00 <lambdabot> foldr f z []     = z
15:43:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:43:10 <hpc> there, f is the root
15:43:11 <cloudhead> right, that wouldn't work in lua :D
15:43:17 <hpc> and depending on the f, you don't have the same problem
15:43:19 <hpc> @src foldl'
15:43:19 <lambdabot> foldl' f a []     = a
15:43:19 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:43:56 <hpc> that does other stuff, seq is probably too much to explain in addition to the rest of this though
15:44:26 <cloudhead> yeah I haven't taken the time to understand laziness properly yet
15:45:14 <maerwald> it feels easier than it actually is
15:45:46 <hpc> anyway just trust that it works until you're ready to learn more
15:45:50 <maerwald> and when you know all the ways you can break laziness unintentionally
15:45:52 <cloudhead> cool
15:45:54 <cloudhead> thanks
15:46:38 <maerwald> https://wiki.haskell.org/Maintaining_laziness is also interesting
15:46:52 <maerwald> although haskell wiki pages are mostly badly written and hard to understand. But this is not that bad
15:47:00 <hpc> ghc's inner workings are very interesting, but there's some decent conceptual build-up to diving into it
15:47:06 <cloudhead> ah interesting
15:48:03 * hackagebot hgeos 0.1.3.0 - Simple Haskell bindings to GEOS C API  https://hackage.haskell.org/package/hgeos-0.1.3.0 (rcook)
15:48:46 <cloudhead> re: laziness, things just seem to work until they don't I guess
15:49:29 <cloudhead> but I haven't reached that point yet
15:49:40 <maerwald> I think laziness is overrated, but there are some very strong opinions in the community pro laziness from very smart people, so I guess I don't understand all details.
15:50:20 <maerwald> as in: I don't mind the Idris approach
15:50:22 <cloudhead> it seems like if it was black or white, ie: 100% lazy or 100% strict, strict would be the saner option
15:50:36 <cloudhead> but given that we can have a bit of both..
15:50:52 <Cale> Well, you can always make things stricter
15:50:59 <Cale> Just by pattern matching
15:51:01 <cloudhead> and by saner I mean: things are less likely to break
15:51:02 <hpc> yeah, the prevailing wisdom is... that
15:51:22 <Cale> Before seq was a builtin, it was a type class method
15:51:31 <cloudhead> Cale: how do you mean?
15:51:46 <Cale> e.g. you can define seq for Maybe as
15:51:51 <Cale> seq Nothing y = y
15:51:57 <Cale> seq (Just x) y = y
15:52:18 <cloudhead> oh interesting, so that forces the maybe to be evaluated
15:52:21 <Cale> right
15:52:21 <cloudhead> just by pattern matching
15:52:24 <cloudhead> ok
15:53:23 <Cale> The reason that lazy is a good default is that most of the benefits of laziness come from composing together things which happen to be able to operate incrementally in a lazy fasion
15:53:25 <EvanR> note x doesnt get evaluated
15:53:48 <EvanR> thatd be the realm of NFData in deepseq
15:53:49 <cloudhead> 'seq' seems like a wart though, ie: it doesn't provide any semantic value
15:53:57 <cloudhead> but it's necessary at times
15:54:05 <Cale> If laziness is not the default option, then you tend to end up with libraries full of things which are too strict, and chances are, you won't extract much benefit from lazy evaluation too often.
15:54:18 <EvanR> i dont use seq much, instead there are bang patterns and sometimes $!
15:54:24 <hpc> cloudhead: denotationally, seq's semantics are pretty much useless yes
15:54:33 <Cale> Well, bang patterns and $! are defined in terms of seq :P
15:54:49 <EvanR> yeah but maybe they do preserve "wartness" for cloudhead  ;)
15:54:54 <EvanR> maybe they dont***
15:55:05 <cloudhead> yeah, bang patterns are the same as seq really
15:55:08 <hpc> but since it can be defined (in a limited sense) already, might as well
15:55:11 <cloudhead> in terms of wartness
15:55:23 <EvanR> cloudhead: well, having that seq for Maybe defined as above is a wart...
15:55:25 <cloudhead> Cale: makes sense re: what should be the default
15:55:35 <EvanR> it would be so annoying
15:56:29 <hpc> cloudhead: one of those haskell report links i put up above has the denotational semantics of seq, if you're curious
15:56:30 <Cale> cloudhead: Yeah, it's sort of like laziness is a "recessive gene" when composing programs -- if some factor of a composition is evaluating too much, the whole thing evaluates too much.
15:56:31 <EvanR> you could call unsafePerformIO a wart too, but its probably a bad idea to go around deleting stuff that is actually useful
15:56:33 <hpc> it's basically
15:56:38 <hpc> seq bottom x = bottom
15:56:40 <cloudhead> well no matter how it's defined, it's exposing a leaky abstraction
15:56:41 <hpc> seq _ y = y
15:57:07 <Cale> cloudhead: The main reason that seq is ugly is that it works on function types
15:57:29 <Cale> There would be no way, normally, to write  funSeq :: (a -> b) -> c -> c
15:57:33 <hpc> it's worth noting that you can go the other way too, making something not evaluate until it is used in a strict language
15:57:51 <hpc> and the way to do that is \() -> val, which is rather intrusive
15:57:56 <Cale> > (undefined :: Integer -> Integer) `seq` ()
15:57:58 <lambdabot>  *Exception: Prelude.undefined
15:58:01 <Cale> > (const undefined :: Integer -> Integer) `seq` ()
15:58:03 <lambdabot>  ()
15:58:04 <cloudhead> yeah
15:58:25 <Cale> So with seq in the language, we can tell the difference between an undefined function, and a function which is undefined for all values
15:58:41 <Cale> which sucks if you're in a position to care about it
15:59:12 <EvanR> thats kind of like a constructor pattern match
15:59:18 <EvanR> does it suck for Maybe
15:59:20 <Cale> But it possibly sucks less than not being able to force evaluation when you really need it for performance.
15:59:33 <Cale> No, for Maybe, seq is fine.
15:59:46 <EvanR> whats the issue for being able to do something essentially the same for functions
15:59:49 <Cale> It's only for abstract and function types that seq does something magical.
15:59:50 <cloudhead> yeah, I don't mean to say it shouldn't be part of the language
16:00:43 <cloudhead> just that I'd hope it's only for very special cases
16:01:00 <EvanR> im definitely using strict fields a lot in my video game project
16:01:00 <cloudhead> but I see it a lot
16:01:47 <EvanR> it doesnt help at all for the fields to be lazy
16:01:58 <EvanR> and theyre not automatically made strict unfortunately
16:03:10 <cloudhead> there's https://ghc.haskell.org/trac/ghc/wiki/StrictPragma now
16:03:21 <EvanR> to make the entire language strict? o_O
16:03:28 <cloudhead> no I think it's just data fields
16:03:37 <cloudhead> actually it's both?
16:03:45 <cloudhead> StrictData is just for data fields
16:03:45 <EvanR> ah StrictData on a per module basis
16:03:55 <EvanR> i guess thats more convenient
16:05:08 <EvanR> does it actually exist yet?
16:06:25 <jellyCode> Hi guys, can anyone provide a real world example of multiple method chaining in haskell from an open source project?  
16:08:56 <glguy> What is multiple method chaining?
16:09:34 <jellyCode> Trying to see what a methodology like this would look like in Haskell:  https://fsharpforfunandprofit.com/posts/recipe-part2/
16:09:51 <cloudhead> EvanR: I think so
16:10:02 <cloudhead> since 7.10 or something
16:10:11 <jellyCode> Even though it's FSharp, i think the pattern seems purely functional, so thought it might be a natural pattern Haskell programmers use often
16:10:25 <Welkin> jellyCode: that just looks like bind
16:11:08 <cloudhead> that looks exactly like bind indeed
16:11:28 <Welkin> it even shows a sequence (>>) between the images
16:11:30 <Welkin> lol
16:11:53 <EvanR> watch out now
16:12:11 <jellyCode> yeah, it says it is bind.  i'm looking for where to see real world haskell examples.  brand new to haskell
16:12:23 <EvanR> >> specializes to Monoid behavior, which fsharp sometimes calls monads
16:12:55 <cloudhead> hmm, well exceptions can be implemented via that mechanism in haskell, for example
16:12:56 <jellyCode> i don't use or know FSharp, just found it a very nice explanation of the pattern
16:13:44 <EvanR> actually yeah this blog post seems to be about monoids
16:13:58 <Welkin> oh, yeah I see it now
16:14:14 <EvanR> note that each railway block can do side effects
16:14:17 <Welkin> well, it would be like Maybe with bind
16:14:23 <Welkin> once it fails, it can never succeed
16:14:31 <cloudhead> yeah, Maybe, or MonadError
16:14:42 <EvanR> it would be like IO (Either Error ())
16:15:12 <Welkin> @where learnhaskell -- jellyCode start here
16:15:12 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:15:23 <Welkin> you can also join #haskell-beginners
16:16:13 <mniip> haha
16:16:14 <jellyCode> thanks welkin, thats exactly what i needed
16:16:21 <mniip> monads are like railways now huh
16:16:22 <EvanR> uhg fsharp never puts type signatures ;_;
16:16:40 <jellyCode> Also the github project might be nice
16:17:09 <Welkin> jellyCode: there is tons of code to look at, but you need to understand how to read it first
16:17:21 <Welkin> so I recommend following that learnhaskell guide
16:17:31 <jellyCode> yeah i'm getting the hang of it
16:18:19 <jellyCode> thanks for the help
16:21:41 <EvanR> another way to comprehend one dimensional railway components like (Error, a) where the a can change between pieces is Category
16:22:26 <EvanR> and to get crazier with it, Arrow
16:22:47 <mniip> :o
16:23:00 <mniip> ArrowLoop
16:23:15 <EvanR> ArrowDerailment
16:39:50 <nnon> Does anyone know of any GHC API tutorials or decent documentation or just anything that makes it approachable?
16:40:35 <zxtx> nnon, stephen diehl is working on some tutorials for that now I believe, http://www.stephendiehl.com/posts.html
16:43:03 <mniip> docs are available at http://downloads.haskell.org/~ghc/8.0.1-rc4/docs/html/libraries/ghc-8.0.0.20160421/index.html
16:43:07 <mniip> not sure about "decent"
16:43:16 <mniip> they're pretty lacking in some places
16:52:55 <pavonia> I'm reading https://en.wikibooks.org/wiki/Haskell/Zippers#Differentiation_of_data_types and I'm a bit stuck at what to do if you data type already includes a list
16:53:15 <pavonia> e.g. data Node a = Leaf a | Branch [Node a] -- Do you have two nested mu types in the derivative then?
16:53:26 <vctr> hello
16:53:55 <mniip> pavonia, df(g(x))/dx = df(g(x))/dg(x) * dg(x)/dx
16:54:47 <pavonia> That is the chain rule, right?
16:55:07 <mniip> yes
16:56:40 <mniip> data NodeZipper a = ZLeaf | ZBranch (ListZipper (Node a)) (NodeZipper a)
17:03:12 <maerwald> I want: deriving Zipper :P
17:07:17 <bernalex> maerwald: that's easily doable, actually.
17:07:43 <bernalex> the reason we don't have Applicative deriving is that there are usually at least two very sensible ones, and neither are particularly more obvious than the other.
17:08:56 <maerwald> bernalex: with just the traversable instance?
17:09:14 <bernalex> maerwald: I don't follow what you mean.
17:09:42 <maerwald> I mean yeah I can write my own class and shit, but I mean automatic deriving you get for free
17:10:54 <bernalex> and I'm saying we could trivially derive Applicative instances that are zippers. but we don't do that, because there rarely (if ever) is a singularly useful and obvious Applicative.
17:11:26 <bernalex> take the lists for instance -- the default is nondeterminism instead of a zipper. arguably neither is more obvious or generally useful than the other.
17:12:03 <bernalex> but if we had XDeriveZipper, there would be no controversy, as the zipper instance is the expected one.
17:12:06 <dolio> You're talking about different zippers.
17:12:30 <vctr> anyone going to hac boston?
17:12:48 <bernalex> and then you could just remove XDeriveZipper and XDeriveSomethingElseUseful, and get something else without changing the source. which... might be useful. :p
17:12:51 <bernalex> dolio: oh. sorry.
17:13:29 <dolio> Zippers are the type of contexts from following a path into another data type.
17:14:47 <maerwald> I like them, but they also feel a bit clumsy to write, so having that abstracted away would seem cool.
17:15:30 <dolio> edwardk had some lens stuff that automatically formed zippers at some point. I never looked at it too closely, though.
17:15:44 <maerwald> I'll pass on lens :P
17:16:05 <dolio> Like, you can accumulate the context from drilling into things with a lens.
17:16:28 <maerwald> if I want more confusing type errors, I will probably go that way
17:17:08 <vctr> i'm a beginner and lens hasn't been too bad.
17:18:41 <maerwald> it's only high-level if you a) don't look at the types and b) never get a type error. And I don't want to deal with the "low-level" stuff and all the theory behind it just because. Cost and benefit doesn't add up there for me
17:19:09 <mniip> what would you call the following construction: data Foo a where Return :: a -> Foo a; Bind :: Foo a -> (a -> Foo b) -> Foo b
17:19:12 <maerwald> you can still do the things easier (and more clumsy)
17:19:41 <bernalex> mniip: Foo.
17:19:49 <mniip> !
17:20:12 <glguy> The lens zipper stuff suffers from taking
17:20:27 <glguy> Tracking your path in the types
17:20:43 <mniip> I mean, if you defined instance Monad Foo where return = Return; (>>=) = Bind
17:21:18 <mniip> and extract :: Monad m => Foo a -> m a
17:23:28 <mniip> pretty similar to Coyoneda
17:23:32 <mniip> does this construction have a name?
17:27:38 <dolio> It could almost be the free monad over the constantly void functor, except it's actually not a monad.
17:27:47 <pavonia> mniip: Thank you. Deriving the zipper from the actualy data constructors seems to be way easier than by all that theoretical explanations on the page :S
17:28:27 <mniip> um
17:28:28 <dolio> At least, not in the way you gave the instance.
17:28:32 <mniip> I went through the equations
17:29:13 <mniip> Node(x) = x + List(Node(x))
17:29:27 <mniip> Node'(x) = 1 + List'(Node(x)) * Node'(x)
17:30:23 <pavonia> Yes, I mean with that mu types and functors and such, that's just confusing
17:36:05 <hausdorff_> So. I have hobby project in which I could use a nice graph query language. I have a series of very vague questions about how I might implement this in a type system like Haskell's. Is this the right channel to talk about this?
17:36:27 <linman> > (+2) <$> (Just 3)
17:36:28 <lambdabot>  Just 5
17:36:31 <hausdorff_> And by "graph query language" I mean "something like an embedded DSL possibly inside Haskell"
17:40:07 <bernalex> hausdorff_: yes.
17:40:48 * maerwald waits for the next question "any people around that know about what I'm going to ask?" :P
17:41:20 <maerwald> shoot!
17:41:53 <jle`> hausdorff_: it's usually better to just ask your question first :)
17:42:50 <glguy> Maybe he's surveying channels to find out if that is the kind of question that would have been answered
17:42:54 <mniip> hmm
17:43:07 * hackagebot conduit-find 0.1.0.3 - A file-finding conduit that allows user control over traversals.  https://hackage.haskell.org/package/conduit-find-0.1.0.3 (ErikDeCastroLopo)
17:43:18 <jle`> glguy: if that's the case, he would still get a better response by asking first
17:43:46 <jle`> there isn't any advantage i not leading with the question, and only disadvantages! :o
17:43:51 <jle`> *advantage in
17:43:58 <glguy> Jle`: that would answer a subtly different question :)
17:44:20 <mniip> is 'retract . return = return' and 'retract (a >>= b) = retract a >>= (b . retract)'
17:44:37 <hausdorff_> Ok, that is fair. Let me start out by asking if people know what the "right way" to query graphs is in Haskell. It looks like neo4j doesn't really have language-level support for this stuff -- you basically have to write the query as a string and ship that to the neo4j server. It seems like we can do better.
17:45:48 <hausdorff_> It seems like we should be able to have some sort of "graph query combinators", in a manner similar to how parsec has parser combinators.
17:51:13 <vctr> has anyone tried the linear library? how does the performance compare with hmatrix?
17:52:53 <jellyCode> would anyone here be willing to look at this library and help me understand some basics:  https://github.com/louthy/language-ext
17:54:12 <vctr> jellyCode what are you trying to figure out?
17:54:18 <jle`> vctr: it depends on the application of course
17:54:27 <jle`> vctr: for anything typically related to linear algebra, hmatrix will probably be better
17:54:52 <jle`> linear isn't really meant for computational linear algebra and matrix manipulation
17:55:11 <vctr> "linear" isn't "related to liner algebra"?
17:55:15 <jle`> not computationally
17:55:18 <vctr> oh that is news to me
17:55:18 <jle`> it's related to it mathematically
17:55:42 <jle`> like it provides a nice typeclass hierarchy for linear algebra concepts
17:55:55 <jle`> metric fields, additive modules, etc.
17:56:11 <bernalex> the stuff I see people use linear for is GUI stuff. like game map editors.
17:56:22 <glguy> JellyCode: C# libraries are off topic in #haskell
17:56:36 <vctr> ok. but performance for matrix-vector computations is worse than hmatrix bindings?
17:56:40 <jle`> yeah, it's good with 2D/3D applications like drawing, some physics engines, stuff like that
17:56:44 <jle`> it doesn't have matrix/vector computaitons
17:56:46 <bernalex> glguy: unless you're porting them to haskell or similar. :)
17:56:53 <jle`> it doesn't even have a proper matrix data type
17:56:57 <jle`> they're just nested vectors :)
17:57:11 <vctr> jle` but 2D/3D applications will involve matrix/vector computations
17:57:26 <vctr> jle` well as long as it's fast and comfortable to work with i don't really are that they are 
17:57:39 <jle`> you can do things like vector addition, scalar products, cross products
17:57:46 <vctr> jle` if it's being used for 3D physics engines it can't be that slow right?
17:58:02 <jle`> it depends on the application
17:58:21 <jle`> if you're doing things like solving systems of equations, matrix inversions, finding eigenvalues/eigenvectors, SVD, PCA, etc.
17:58:23 <bernalex> I've not seen it used for an actual engine, only peripherally related things like map editors.
17:58:27 <jle`> then it definitely is not meant for that
17:58:35 <bernalex> basically, graphics.
17:58:36 <jle`> (that's what i mean when i mention computational linear algebra)
17:58:51 <jle`> 3d physics engines aren't really linear algebra intensive.  it's mostly vector arithmetic
17:58:56 <vctr> jle` yeah that's what i'm doing unfortunately. computational stats, machine learning stuff..
17:59:18 <vctr> hrm back to hmatrix it is then :/
17:59:37 <jle`> yeah, it doesn't really have any functions for eigendecomposition, covariance estimation, stuff like that --- that's not what the library is meant for
18:00:09 <vctr> still wishing there were better options
18:00:43 <vctr> there was some hype around repa but it seems a bit disappointing. every other week there's a reddit post about lackluster performance
18:01:06 <obadz> vctr: carter claimed he had some good stuff coming on that front but not sure if he released it
18:01:11 <obadz> vctr: hmatrix does work though
18:01:19 <vctr> and i was surprised there's not even a pretty matrix printer
18:01:40 <vctr> obadz yeah num haskell seems cool
18:01:45 <vctr> but it's still baking it seems
18:01:49 <carter> Vctr. Been busy :)
18:01:53 <avalokite> What a good analogy to express monads to children?
18:02:07 <carter> It's in my queue. Just have some near term crazy projects 
18:02:34 <hausdorff_> Alright. Well. I guess that means no one has any particular knowledge of graph querying in Haskell? :( That's too bad.
18:03:00 <avalokite> hausdorff_: check again soon!
18:03:02 <vctr> obadz yeah it works ok but not great. it's not particularly fast because of safe FFI
18:03:33 <obadz> vctr: FFI costs O(number of function calls) no ?
18:03:56 <obadz> vctr: â€¦ which is often not too bad
18:04:01 <vctr> carter hope to see it in the near future :)
18:04:13 <vctr> obadz er safe FFI has some cost
18:04:43 <vctr> obadz my experience in particular was with hmatrix-gsl 
18:05:01 <vctr> where ODE integration and RNG were really slowed down by safe FFI
18:05:54 <vctr> maybe the core matrix-vector operations don't have as much of a problem. i haven't benchmarked them against anything else.
18:06:17 <obadz> ah, I was using the matrix stuff, factorisations etc. and thought it was plenty fast for my needs
18:06:20 <carter> Vctr I do have hblas out
18:06:27 <carter> Need to do a new release some time 
18:07:09 <vctr> carter i took a look, but i think i need to be more familiar with the blas api itself since the documentation is kindof spare
18:07:41 <carter> Well read about blas :)
18:07:48 <vctr> carter btw this was a few weeks ago but i think there's a typo in the hackage example
18:07:50 <carter> Master needs some cleanup before I realize 
18:08:14 <carter> Do a new release
18:08:20 <carter> PRS welcome. 
18:08:20 <obadz> carter: looking at hblas on hackage, I have no idea what the type signatures mean
18:08:30 <carter> Oh. Click on rhem
18:09:25 * obadz doesn't know about PrimMonad
18:10:15 <vctr> primitive state-transformer monad
18:10:41 <carter> Monad STE is cool too
18:10:58 <obadz> why is that all over the type sigs of a numerical library? Is it for performance?
18:11:39 <glguy> Convenience
18:14:29 <jle`> obadz: PrimMonad is usually used to abstract over IO and ST
18:18:27 <obadz> I see
18:18:46 <obadz> I don't really see uses for IO for linear algebraâ€¦
18:18:59 <obadz> ST maybe
18:19:04 <carter> jle` Glguy  : have you poked at my monad ste ? :)
18:19:14 <carter> obadz: Blas is imperative
18:19:59 <monochrom> yes, but it's the mutable array kind, not the getLine kind
18:20:26 <obadz> monochrom: so ST, not IO ?
18:20:47 <monochrom> yeah, what you said
18:21:09 <monochrom> OTOH if you use FFI you get IO
18:21:30 <monochrom> even if the FFI just talks to a C procedure of the mutable array kind
18:22:11 <mniip> hmm, does a choice of fmap and bind uniquely determine pure?
18:23:01 <shachaf> Yes.
18:23:07 <mniip> cool
18:23:10 <shachaf> (If it exists.)
18:23:58 <jle`> carter: i haven't!
18:24:07 <obadz> shachaf: can pure be implemente from fmap + bind ? 
18:24:17 <shachaf> No.
18:24:26 <obadz> but fmap + bind determine pure?
18:24:30 <mniip> yes
18:24:33 <shachaf> Compare to mappend and mempty.
18:24:42 <obadz> aren't these two statements basically equivalent?
18:24:47 <mniip> no
18:25:18 <mniip> one follows from the other
18:25:27 <mniip> but not vice versa
18:25:50 <nshepperd_> I imagine 'determines' here means that if you have pure1 and pure2 that both follow the laws, you can use fmap and bind to prove that pure1 = pure2
18:26:12 <monochrom> "x defines y" is equivalent to "given x, y exists uniquely"
18:26:43 <monochrom> "x determines y" lacks the "exists" part. only equivalent to the "unique" part.
18:26:53 * nshepperd_ tries that
18:27:20 <carter> jle`: you may like it 
18:28:09 <shachaf> I'm not actually completely sure about the statement I made. Use the monochrom rule.
18:28:26 <dolio> I'm sure.
18:28:55 <shachaf> It should be the same argument as mempty being unique.
18:28:55 <jle`> i feel like bind itself already determines pure
18:29:27 <dolio> You can't state the rules you need without fmap.
18:29:41 <dolio> I think.
18:31:01 <shachaf> But fmap is unique anyway.
18:33:22 <obadz> is there a way to wait on the completion of a given threadId?
18:33:48 <obadz> or do I have to create an MVar, put the MVar from the finally part of the thread?
18:34:04 <monochrom> yes, but use the async library instead, not directly work with threads for this
18:34:21 <monochrom> yes, the way is to do what you just said. so use async instead.
18:34:49 <monochrom> the doc of Control.Concurrent has sample code
18:35:17 <monochrom> but use the async library instead. (its doc also has sample code, and much less work for you)
18:35:46 <obadz> hmmm cool
18:36:06 <glguy> Carter: I saw the repo but I haven't needed it yet. I'm keeping it in mind
18:36:50 <obadz> thx monochrom 
18:36:59 <monochrom> I wrote a program to spawn an external process, then wait for one of the following two to happen first, and then kill the other one: the external process finishes; 3 seconds has passed.
18:37:08 <nshepperd_> oh, it's easy, you don't even need fmap
18:37:32 <nshepperd_> just apply both left and right identity on 'pure1 a >>= pure2'
18:37:33 <monochrom> my first instinct was like yours: "oh I know how to code up some threads and some MVars to do that"
18:37:53 <monochrom> my second thought was "wait, async already does all that for me". thus it's settled.
18:38:25 <monochrom> nice, nshepperd_
18:38:56 <monochrom> shachaf now gets to say "told you so" :)
18:39:14 <obadz> monochrom: yeah async has really nice facilities that help me here like waitEitherCatch
18:39:58 <pavonia> So for List(a) = 1 + a * List(a) we get the zipper List'(a) = a * List'(a) + List(a), but how is that equivalent to the usual list zipper List'(a) = a * List(a)^2?
18:43:32 <carter> glguy: :) I did a hackage release that works on 7.4 through 8.0
18:43:37 <carter> So probably stable ;)
18:43:38 <nshepperd_> List'(a) is the derivative (datastructure with a hole), the zipper would be (a, List'(a))
18:44:44 <nshepperd_> er, a * List'(a) in that notation
18:45:41 <pavonia> nshepperd_: Right, but then the derivatives a * List'(a) + List(a) and List(a)^2 still should be equivalent
18:46:41 <nshepperd_> yeah I dunno
18:47:48 <nshepperd_> I guess List'(a) is sort of like two lists concatenated, rather than stored in a pair
18:49:05 <nshepperd_> You take the left constructor in List'(a) some number of times, which gives you a list of `a`s, then eventually it takes the right constructor which is another List(a)
18:50:11 <nshepperd_> so I guess it has the same information but would make a pretty bad zipper?
18:50:14 <shachaf> monochrom: Well, I was thinking that join = (>>= id), and then you can apply the usual monoid proof.
18:51:14 <shachaf> Of course nshepperd_'s way is much more straightforward for doing the same thing.
18:51:16 <Squarism> are there any "must have" libraries that most people include by default for collections/base-types. Things that make life easier and adds what shouldve been included by default?
18:52:01 <pavonia> nshepperd_: Yeah, I'm still trying to find some pattern or so to derive zippers from data types. The plain deriving by rules always yield some results that are very different from the zippers you find in packages
18:52:08 <Squarism> ie like guava for java, scalaz for scala..
18:52:23 <dibblego> Squarism: guava is not like scalaz, functionaljava is
18:52:38 <Squarism> well i mean in terms of popularity
18:53:19 <dibblego> I mean in terms of usefulness
18:53:21 <monochrom> I have no idea what are guava and scalaz, and I don't want to know. But GHC already comes with the containers library, and you will find the unordered-containers library often used too.
18:53:56 <Squarism> ok
18:54:08 <monochrom> I don't understand "base types". How many base types do you need?
18:54:48 <monochrom> GHC comes with at least 64 base types.
18:54:50 <dibblego> there is lens
18:55:24 <monochrom> They are: (), (,), (,,), ... up to 63-tuple.
18:55:27 <glguy> Base types, like Armory, Arsenal, Firebase, Forward operating base
18:56:39 <Squarism> Sorry for vagueness. What i mean was functions that enhance everyday work.. like addons for list/either/maybe/tuple 
18:56:56 <monochrom> Data.List has addons for list
18:57:05 <monochrom> Data.Either has addons for either
18:57:20 <Squarism> all those are in base right?
18:57:29 <monochrom> have you actually read the library doc that comes with GHC? if you have installed GHC, it is somewhere on your hard disk already.
18:58:01 <Squarism> i view docs through hoogle
18:58:45 <Squarism> ill check those *-containers libs
18:59:26 <monochrom> people spend 9 lifetimes browsing the web, and not even one second browsing their own disks.
19:00:01 <Squarism> disc stuff could be outdated?
19:00:24 <carter> monochrom: my ghc build has the fun hyper linked source for the ghc Api
19:01:58 <nshepperd_> pavonia: oh, hold on, you can do some algebraic manipulation to turn it into List(a)^2 though
19:02:32 <obadz> Is there a way to start an async process and "link" it directly so that exceptions bubble up directly?
19:02:32 <vaibhavsagar> Hi, may I have some feedback on a blog post? http://www.vaibhavsagar.com/blog/2016/07/24/writer-delta/
19:02:37 <vaibhavsagar> Thanks :)
19:03:23 <nshepperd_> pavonia: remembering that List(a) = 1 + a List(a), so List(a) = 1 / (1 - a)
19:04:08 <pavonia> What does 1 / (1 - a) mean on terms of types? O.o
19:04:19 <nshepperd_> pavonia: if you do the same thing to List'(a) = a List'(a) + List(a), you get List'(a) = List(a) / (1 - a) = List(a)^2
19:04:43 <EvanR> monochrom: the disk is a reflection, youd rather go on gawker and thank jeebus youre not them
19:05:18 <nshepperd_> pavonia: witchcraft :)
19:05:39 <monochrom> obadz: "wait" re-throws the exception thrown by the job
19:05:57 <jle`> pavonia: if you taylor expand it, you get 1/(1-a) = 1 + a + a^2 + a^3 + a^4 + a^5 + ...
19:06:02 <nshepperd_> pavonia: I think it's basically just the power series 1 / (1 - a) = 1 + a + a^2 + a^3 + ...
19:06:19 <jle`> pavonia: which is the type of finite lists!
19:06:32 <monochrom> and "waitCatch" gives you an Either instead. you can choose between "wait" and "waitCatch"
19:06:35 <pavonia> nshepperd_: I see how you get the same result, that's still very strange though
19:06:50 <jle`> it's either 1 ([]), or has 1 item, or has two items, or has 3 items, etc.
19:07:04 <glguy> obadz: Yeah, it's called "link"
19:07:24 <monochrom> there is also what glguy just said
19:08:36 <pavonia> I can't even imagine what - or / could possibly mean for types
19:09:07 <pavonia> It's like adding values to get an empty type :)
19:09:31 <nshepperd_> you can do logarithms and exponents as well :D
19:11:47 <angerman> Let X be a recursive datatype, e.g. X = X [X] | Y. What I'd like to allow is for the `[X]` to be either `[X]` or `[Located X]`. Is that possible by atering the definition for X, or do I have to introduce a separate datatype LocatedX?
19:11:53 <nshepperd_> I suppose if you want you can do it without using - and / by substituting List(a)^2 in List'(a) = a List'(a) + List(a)
19:12:36 <nshepperd_> and prove that way that at least List'(a) = List(a)^2 is consistent. but that doesn't really derive it
19:12:59 <mniip> nshepperd_, the 1/(1-a) trick breaks for infinite lists
19:13:29 <EvanR> this may only work as is for inductive types
19:13:34 <nshepperd_> yeah, I guess it does
19:15:32 <nshepperd_> hm, with infinite lists, a * List(a)^2 is actually bigger than a * List(a), the thing it supposedly is a zipper of
19:15:33 <pavonia> angerman: You could use another constructor
19:16:02 <nshepperd_> because your zipper can be in the middle of a tape that is infinite in both directions
19:17:47 <glguy> angerman , you can parameterize your data type X with the type contained in the list
19:18:20 <angerman> pavonia: as in data X = X [X] | Y | Located X. That's what I had. But that felt a bit weird, as Located wasn't truly X. 
19:18:34 <nshepperd_> anyway, even if it's formally invalid, I can still endorse blithely doing algebraic manipulation as a handy way to think up new data structures that might be a useful solution
19:18:46 <glguy> But then you'll need a layer to reintroduce the recursion
19:19:11 <pavonia> angerman: I meant something like X = X [X] | XLoc [Located X] | Y
19:19:12 <glguy> Or you can parameterize on a type f  Identity or Located
19:19:30 <glguy> X [f X]
19:20:58 <angerman> glguy: going with X a = X [a] | Y, results in types of the form X [X [X ...]] which I'd prefer to prevent. Ideally I'd like to have some unified way of representing data with location information and without. But maybe that's simply not possible.
19:26:29 <glguy> With that version you'll need something like newtype SimpleX = SX (X SimpleX)
19:27:17 <glguy> The other option avoids that layer
19:30:03 <obadz> glguy: I mean is there a function for \ p -> do { t <- async p; link t }
19:31:03 <glguy> Yeah, obadz just wrote it above
19:31:48 <obadz> alright, not in the library then
19:35:26 <angerman> glguy: so the more practical solution seems to stick Located into the datatype.
19:37:39 <angerman> Another question. Is there a shorthand for filtering a list of X, to only obtain elements with a certain constructor? Or is writing `isX :: X -> Bool` with with pattern matches on the constructors the way to go?
19:41:16 <geekosaur> > [x | Just x <- [Nothing,Just 1,Nothing,Just 8,Just 4,Nothing,Nothing]] 
19:41:18 <lambdabot>  [1,8,4]
19:41:31 <geekosaur> if you want to keep the constructor,
19:41:43 <geekosaur> > [y | y@(Just x) <- [Nothing,Just 1,Nothing,Just 8,Just 4,Nothing,Nothing]]
19:41:44 <lambdabot>  [Just 1,Just 8,Just 4]
19:42:36 <geekosaur> (or _ in place of x there)
19:42:59 <geekosaur> ...or y@(Just{})
19:43:30 <angerman> ahh, list comp, hadn't throught of those.
19:57:18 <Iceland_jack> This is 'catMaybes :: [Maybe a] -> [a]'
19:57:20 <Iceland_jack> @src catMaybes
19:57:20 <lambdabot> catMaybes ls = [x | Just x <- ls]
19:58:02 <Iceland_jack> angerman: It's possible to do this for more general constructs without list comprehensions, in somewhat more advanced Haskell
19:58:52 <Iceland_jack> > toListOf (folded._Just) [Nothing,Just 1,Nothing,Just 8,Just 4,Nothing,Nothing]
19:58:53 <lambdabot>  [1,8,4]
19:59:55 <Iceland_jack> > toListOf (folded._Left) [Right "AA",Left 1,Right "BBB",Left 8,Left 4,Right "C",Right "DDDD"]
19:59:57 <lambdabot>  [1,8,4]
19:59:57 <Iceland_jack> > toListOf (folded._Right) [Right "AA",Left 1,Right "BBB",Left 8,Left 4,Right "C",Right "DDDD"]
19:59:59 <lambdabot>  ["AA","BBB","C","DDDD"]
20:02:01 <geekosaur> Iceland_jack, I was just using Maybe as an example, they asked for "a certain constructor"
20:03:32 <Iceland_jack> Yes the relevant part is the lens answer
20:09:52 <fragamus> howdy i am using ST but once I allocate an STUArray I don't want to keep passing it as a parameter so I thought of using a monad transformer to give me state and keep it there. Then I got worried that the ST monad wouldn't let me do that. What's your advice?
20:29:15 <glguy> try it
20:36:14 <threeys> noob question, why does fromIntegral have the type declaration `(Num b, Integral a) => a -> b` if Num encompasses integrals and floats? Why is the `Integral a` necessary?
20:36:34 <glguy> Integral is only the integral types
20:36:41 <glguy> Not Double or Float, for example
20:37:02 <threeys> But isn't Num both the integral types and the float types?
20:37:13 <nitrix> threeys: Examples of Integrals are Word, Integer, Int. Not Double or Float.
20:37:44 <geekosaur> threeys, Haskell types don't work like OOP classes. Num is the things in common with all numbers, not the union of all possible numbers
20:37:59 <geekosaur> so the only things you can do knowig only Num is the things that work for any Num instance
20:38:13 <nitrix> threeys: Look at the type signature carefully, `a -> b`, where the constraint on `a` is an Integral (hence the name fromIntegral).
20:38:20 <geekosaur> if you want to do things that require an Integral instance, you musrt declare that, not just num
20:38:29 <threeys> ahh got it, thanks
20:49:16 <nnon> Does it make sense that GHC_PACKAGE_PATH would be unavailable inside a type checker plugin?
20:51:41 <glguy> nnon: I'd only expect to find that when using stack
20:51:44 <glguy> not in general
20:52:19 <nnon> Oh, the GHC docs make it sound like it's not stack specific
20:52:48 <nnon> And I am using stack
20:52:59 <glguy> It's not normally set, and GHC knows about it when it is
20:53:27 <nnon> The issue is that `getEnv "GHC_PACKAGE_PATH"` works when I do it in the repl, in a test, etc
20:54:02 <nnon> But does not exist during a `tcPluginInit`. Even though other env vars do
20:54:12 <nnon> So it seems like it's getting cleared somewhere by GHC?
20:55:10 <nnon> Also, is that not the mechanism cabal sandboxes use?
20:56:27 <glguy> no, it's not
20:57:35 <glguy> You're probably better off asking GHC where it thinks it's package databases are directly than depending on one particular way of specifying them (the environment variable)
20:58:53 <nnon> I'm very new to the GHC API. If I don't specify any extra DBs, don't I only get the user and global package DB?
20:59:43 <geekosaur> ghc has command line options to specify various databases; in sufficiently recent versions these can override the global and user package dbs
21:00:48 <nnon> Okay. When I'm loading a module via the API though, I'd need to be the one passing in those flags right? It's basically a fresh invocation of GHC with a vanilla DB setup, right?
21:01:52 <nnon> All I'm really trying to do is load a module, but it seems like I need to have already exposed all the packages it depends on and consequently specified the package DBs those packages are in
21:21:25 <__Myst___> Hi
21:21:42 <__Myst___> I was wondering, if I have to return something from an IO operation too
21:21:49 <__Myst___> would I do `putChar 'whatever' >> return ["hi"]'
21:21:58 <__Myst___> putStrLn, rather
21:22:13 <c_wraith> if you wanted to return a list of strings containing a single entry, sure.
21:22:31 <__Myst___> I have a code snippet trying to implement an esoteric language
21:22:37 <c_wraith> :t putStrLn "whatever" >> return ["hi"]
21:22:38 <lambdabot> IO [[Char]]
21:22:54 <arknave> Generally do notation is easier to read than >> though.
21:22:56 <__Myst___> I'm doing exactly that
21:22:59 <__Myst___> however nothing gets printed :/
21:23:10 <__Myst___> http://paste.ofcode.org/tM8JYQ2Rmtp4MCdNAgPpjX
21:23:12 <__Myst___> here's the code
21:23:22 <__Myst___> Compiling with ghc gives absolutely zero output
21:24:44 <__Myst___> arknave: I'm sure *something* is gettin gthrough
21:25:12 <__Myst___> oh woops
21:25:14 <__Myst___> found the bug
21:25:41 <__Myst___> I didn't actually
21:25:43 <__Myst___> huh.
21:27:09 <pavonia> You have no %s in your input
21:27:34 <pavonia> Oh wait, putChar
21:27:51 <__Myst___> I really don't get what the issue is..
21:27:55 <glguy> 0000000: 1619 16                                  ...
21:28:06 <glguy> It's printing control characters
21:28:22 <__Myst___> oh is it
21:29:20 <glguy> "\SYN\EM\SYN" in particular
21:30:10 <__Myst___> glguy: Thank you for the heads up
21:30:21 <__Myst___> For some reason ZSH doesn't show those..
21:30:33 <glguy> My terminal doesn't either
21:30:38 <mniip> it's your terminal emulator
21:30:40 <mniip> not your shell
21:30:59 <glguy> I ran: runghc Demo.hs | xxd
21:31:10 <mniip> "\EM" does show in my terminal emulator btw
21:32:00 <mniip> oh "\SYN" does too
21:33:09 <__Myst___> Figured it out!
21:33:15 <__Myst___> I forgot to make * and / work properly
21:33:17 <__Myst___> lol.
21:33:44 <arknave> lol
21:34:02 <__Myst___> thanks for all the help!
21:34:05 <__Myst___> bai!
22:20:06 <winsoff> Does function call overhead make haskell horribly inefficient on modern computers?
22:20:24 <Cale> winsoff: No
22:20:48 <Cale> Also, it's not entirely clear what function call overhead refers to in the context of Haskell.
22:21:34 <cocreature> nevertheless inlining is one of the most important optimizations performed by ghc
22:21:49 <Cale> Especially given that there is not really a call stack as such. The cost model for Haskell is pretty different from the one you'd get with a typical strict evaluator
22:21:58 <Cale> Yeah
22:22:06 <winsoff> Yeah, but what about RUST
22:22:14 <cocreature> what about it?
22:22:15 <Cale> What about it?
22:22:18 <cocreature> heh
22:22:19 <nshepperd_> haskell is horribly efficient
22:22:27 <mniip> I suppose #rust might know better
22:22:44 <winsoff> * Topic for ##rust set by mbrubeck!sid61@gateway/web/mozilla/x-hexxdselrkfhlxvd (Fri Jul 08 12:09:42 2016)
22:22:44 <winsoff> <winsoff> Yeah, but what about HASKELL?
22:23:08 <shachaf> winsoff: This is not appropriate behavior for this channel.
22:23:17 <shachaf> Please stop inciting flame wars and so on.
22:23:34 <winsoff> Really, though, what is the purpose of haskell in the modern environment?
22:23:43 <nshepperd_> I'm always thinking "I bet I could get a 5% speed up by writing this in C"
22:24:01 <Welkin> winsoff: to write programs...
22:24:43 <winsoff> Welkin, aye, but there is a menagerie of programming languages that do exactly that.
22:25:00 <winsoff> Does Haskell do anything better?  There is always this bullshit argument that programming languages have specific usages.
22:25:05 <winsoff> What's the use case for Haskell?
22:25:12 <mniip> not all do
22:25:19 <mniip> haskell is a generic purpose programming language
22:25:22 <mniip> just like C or C++
22:25:28 <Welkin> it make hard things easy
22:25:50 <shachaf> winsoff: Your behavior seems much too hostile to participate in this channel.
22:25:55 <shachaf> Please tone it down.
22:25:57 <Cale> winsoff: The company I work for develops web applications entirely in Haskell
22:25:59 <winsoff> shachaf, are you afraid of the word bullshit?
22:26:10 <winsoff> Cale, so it's a web programming language.
22:26:15 <Cale> winsoff: Nope
22:26:30 <Cale> It's a general purpose programming language, which is suitable for a lot of things
22:26:32 <winsoff> Ah, so you should use a web programming language.
22:26:34 <winsoff> Right?
22:26:36 <Cale> huh?
22:26:39 <mniip> winsoff, this is a family friendly channel
22:26:43 <winsoff> If there's a proper tool for every use case, why not?
22:26:54 <winsoff> mniip, my parents said fuck before I was old enough to understand the word.
22:26:58 <Cale> Haskell is a proper tool for a lot of use cases, is what I'm saying
22:27:03 <c_wraith> Haskell's special niche is writing software.
22:27:10 <mniip> winsoff, your point is?
22:27:18 <winsoff> mniip, "family" has nothing to do with it.
22:27:20 <nshepperd_> this trolling is highly inexpert
22:27:21 <Cale> Yeah, if you want to write software, Haskell is pretty good at that. :)
22:27:25 <winsoff> nshepperd_, not trolling.
22:27:35 <thimoteus> Cale: do you use ghcjs?
22:27:43 <winsoff> Cale, right, but there's this idea commonly held by people that certain programming languages excel at certain applications.
22:28:00 <mniip> haskell excels at theoretical computer science for example
22:28:00 <c_wraith> Haskell excels at software.
22:28:03 <mniip> and abstract mathematics
22:28:13 <winsoff> These people claim that general purpose languages do not excel at everyting.
22:28:16 <winsoff> Everything, even.**
22:28:21 <Welkin> and making people uncomfortable, like winsoff the troll
22:28:30 <winsoff> Welkin, I am not uncomfortable.
22:28:45 <nshepperd_> winsoff: your technique is off, you need to be more subtle
22:28:55 <winsoff> It is only dissonant in the minds of those who believe simultaneously that there is a specific use case for every language, and that Haskell can be good at everything.
22:29:00 <nshepperd_> perhaps learning haskell would improve your trolling ability?
22:29:05 <winsoff> nshepperd_, I am _not_ subtle because I am not trolling.
22:29:15 <mniip> winsoff, see above
22:29:17 <winsoff> You're doing the equivalent of "do your parents know you're gay :^)"
22:29:25 <winsoff> mniip, that's not what the rest of the group says.
22:29:33 <winsoff> Someone said it excels at web software.
22:29:33 <mniip> it's orthogonal
22:29:42 <winsoff> That implies that it is the best language for that use case.
22:29:44 <mniip> "excels" is not what they said
22:29:52 <Welkin> it does excel in the area of web development
22:29:56 <mniip> TIMTOWTDI
22:29:57 <Welkin> in my own experience
22:30:02 <winsoff> mniip, that's perl's
22:30:09 <winsoff> And perl has noticeable tradeoffs
22:30:10 <winsoff> like speed
22:30:18 <mniip> sure but sometimes multiple tools exist that can achieve the same
22:30:45 <winsoff> So the simple conclusion here is that people who think that programming languages are not actually just shitty feature creep social movements are completely idiotic.
22:30:49 <nshepperd_> right now I'm using haskell to write high performance machine learning code
22:31:15 <winsoff> nshepperd_, but you're not being purely functional, because you have side effects. How do you manage an entire neural network (state) with a language that hates state?
22:31:16 <mniip> winsoff, false dichotomy
22:31:30 <nshepperd_> winsoff: who are these people are why can't they represent themselves if any of them ever arrive in the channel?
22:31:44 <Welkin> nshepperd_ also uses haskell to toast his muffins
22:31:45 <winsoff> mniip, not whatsoever.  The dichotomy is that you cannot believe simultaneously that there are specific tools fit for the job, and also think that general tools are superior to those specific tools.
22:31:53 <Welkin> the heat is a side effect
22:31:57 <winsoff> nshepperd_, Welkin seems to be one.
22:31:58 <shachaf> winsoff: I don't care whether you're right or wrong here, only pleasant or unpleasant. Right now you're being the latter, too much so to participate in this channel if you don't stop.
22:32:17 <winsoff> shachaf, your personal interpretation of my language is pretty discriminatory.
22:32:22 <winsoff> You swear around your friends, yeah?
22:32:33 <shachaf> I didn't say anything about swearing.
22:32:33 <mniip> I don't think it's about swearing
22:32:36 --- mode: ChanServ set +o shachaf
22:32:47 <winsoff> Treat people like they're already your friends. Treat them with the respect you treat people who are close to you. Take it to PM if you want to derail my questions.
22:33:03 <winsoff> The only time someone decided to get pissy about me being here was when I said "bullshit."
22:33:20 --- mode: shachaf set +q winsoff!*@*
22:34:00 <nshepperd_> hmm, I don't use haskell to toast my muffins *yet*
22:34:05 <nshepperd_> I should look into that
22:34:57 <systemfault> Only burritos
22:35:18 <nshepperd_> I'm leery of home automation projects involving heat though
22:35:19 <mniip> monads are railways though
22:36:30 <Welkin> then what are comonads?
22:36:45 <nshepperd_> side effects like fire have no place in functional programs
22:36:46 <mniip> trains
22:36:55 <Welkin> swayliar?
22:37:11 <Welkin> could be an encrypted message
22:39:05 <nshepperd_> nonono, functors are railways, cofunctors are trains. combined, they can take you from a to b :)
22:41:10 --- mode: shachaf set -o shachaf
22:41:14 <shachaf> What are cofunctors?
22:41:37 <cocreature> cofunctors are functors
22:41:54 <systemfault> That's what my intuition tells me... but is it the case?
22:42:08 <systemfault> Reversing the arrows gives the same thing
22:42:29 <cocreature> there are also contravariant functors but they are not cofunctors
22:45:06 <mniip> confunctor ~ functor
22:45:14 <mniip> it is its own dual
22:46:00 <nshepperd_> oh, I was thinking contravariant
22:46:25 <nshepperd_> yeah, that doesn't roll off the tongue quite as well
22:53:17 * hackagebot servant-subscriber 0.2.0.0 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.2.0.0 (eskimo)
23:23:18 * hackagebot servant-purescript 0.2.0.0 - Generate PureScript accessor functions for you servant API  https://hackage.haskell.org/package/servant-purescript-0.2.0.0 (eskimo)
23:33:18 * hackagebot equational-reasoning 0.3.0.0 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-0.3.0.0 (HiromiIshii)
23:53:19 * hackagebot servant-subscriber 0.2.0.1 - When REST is not enough ...  https://hackage.haskell.org/package/servant-subscriber-0.2.0.1 (eskimo)
