00:07:39 * hackagebot stratosphere 0.1.3 - EDSL for AWS CloudFormation  https://hackage.haskell.org/package/stratosphere-0.1.3 (jdreaver)
00:07:39 * hackagebot Glob 0.7.8 - Globbing library  https://hackage.haskell.org/package/Glob-0.7.8 (MattiNiemenmaa)
00:08:35 <Ashy> is it possible to add ghc flags to stack.yaml?
00:08:43 <Ashy> rather than in the *.cabal file?
00:09:13 <hwkng> is there any tutorial showing a minimal implementation of relational algebra in haskell?
00:09:19 <hwkng> this is all for educational purposes
00:09:35 <quchen> I don't think so, Ashy. Stack is a wrapper for Cabal, Cabal is a wrapper for GHC. GHC things are done in Cabal.
00:10:59 <oherrala> Ashy: why .cabal doesn't work for you?
00:11:03 <reqq456> is this the right way to parse cli arguments? or i'm on the wrong way? http://sprunge.us/RCJj
00:11:37 <quchen> reqq456: What if x is []?
00:13:04 <quchen> reqq456: There are Libraries that do CMD parsing for you, it's not something you should code by hand. A simple one is even in Base, so you already have it installed! http://hackage.haskell.org/package/base-4.9.0.0/docs/System-Console-GetOpt.html
00:13:30 <reqq456> thanks
00:13:34 <dysfun> incidentally, i'm very fond of CmdArgs
00:13:42 <dysfun> makes it so easy
00:16:44 <Ashy> oherrala: just asking silly questions, im thinking about a script to profile GHC performance when compiling stackage packages
00:18:16 <oherrala> Ashy: if you need some flags to all packages, check out $HOME/.cabal/config
00:19:42 <Ashy> ah cool, thanks
00:22:34 * hackagebot z3-encoding 0.2.1.1 - High-level assertion encoding to Z3 solver  https://hackage.haskell.org/package/z3-encoding-0.2.1.1 (izgzhen)
00:22:46 <adarqui> is there a haskell stack channel?
00:23:01 <Ashy> yes
00:23:13 <Ashy> #haskell-stack
00:23:15 <Ashy> haha
00:24:27 <adarqui> nice :f
00:24:29 <adarqui> thnx
01:11:19 <matrium> Hi, I have a not direclty haskell related question, but am sure that one of can help me with it: How to formally define the set of all functions of a specific kind? Like the set of all functions [Int] -> Bool
01:11:54 <matrium> With formally define I mean in a mathematical notation
01:13:16 <thimoteus> the shorthand way is writing the domain as an exponent to the codomain
01:14:51 <thimoteus> but you could also do it using set-builder notation, something like { f ∈ Hask | f :: [Int] -> Bool }
01:16:04 <matrium> And how to correctly "assign" it to a named set? Like "S is set set of all functions from P(Int) to Boolean"? S = {s | s : 2^Int -> Bool}?
01:17:03 <thimoteus> yeah, that works, but mathematicians also routinely mix in english with symbols, so it's not unusual to see sentences like "Let P be the set of functions from ... " in a proof
01:17:52 <matrium> Thank you! that really helped me!
01:18:05 <thimoteus> glad to help
01:20:41 <quchen> f ∈ Hom(Hask), no?
01:34:51 <elucidata> does anyone have an opinion on http://haskellbook.com/ ?
01:35:03 <elucidata> does it live up to the hype?
01:37:28 <anilanar> i wonder the same
01:41:41 <ent> I've read about half of it, I would say it's probably really good for beginners
01:42:05 <ent> it doesn't go into very advanced stuff but it's pretty thorough
01:43:48 <anilanar> i've started working on "learn you a haskell for great good", should i switch to haskellbook.com ?
01:43:53 <elucidata> yeah but...$60
01:44:42 <elucidata> and they don't even provide a dead tree copy
01:44:53 <ent> yeah, it's not cheap
01:44:56 <elucidata> $60 for an ebook is pretty absurd
01:45:13 <anilanar> but it's 1500 pages or so, must have been a lot of effort
01:45:18 <anilanar> and if it's as good as they say
01:45:22 <ent> anilanar: I think it is better, depends on how much you value $60
01:45:54 <ent> I would have been happy if I had started haskell with that
01:45:58 <flux> besides when you put $60 to it, it motivates you to make most of your investment.. :)
01:46:18 <elucidata> ent: how rough is the formatting, they say it's content complete but still going through editing
01:47:26 <elucidata> i guess that mostly means editing for content
01:47:41 <elucidata> anyway, is it really ready for prime time?
01:57:26 <elucidata> whatever, I just bought it
01:57:37 * hackagebot shake-language-c 0.10.0 - Utilities for cross-compiling with Shake  https://hackage.haskell.org/package/shake-language-c-0.10.0 (StefanKersten)
02:09:00 <ent> elucidata: I've been reading the ebook reader version, I think the formatting is pretty good
02:09:36 <ent> formatting code for lines that short is hard but I think they did a good job
02:12:10 <chreekat> re haskelbook, 1. email the authors if you can't afford it and they'll probably send you a copy, 2. i've been getting access to the new version every time one becomes available
02:12:49 <ent> yeah, it's really nice how they send all updates
02:13:54 <chreekat> I haven't actually read it yet though ;_; 
02:15:13 <shachaf> Based on what I've read of it, you're better off reading just about any other book or introduction.
02:15:32 <elucidata> shachaf: why's that? 
02:16:45 <shachaf> It seems to be wrong about a lot of things and sloppy about even more things.
02:16:57 <elucidata> can you give an example?
02:16:58 <shachaf> I haven't read the whole book, of course, only some snippets.
02:17:33 <shachaf> For example I saw part of the monad chapter.
02:17:41 <ent> hmm, I certainly haven't noticed anything wrong
02:17:49 <ent> well, I'm not at the monad chapter yet :)
02:18:29 <elucidata> shachaf: so you saw the monad chapter....then what happened?
02:19:02 <shachaf> It said a lot of nonsense. I don't have a copy.
02:19:15 <elucidata> "It said a lot of nonsense" 
02:19:20 <elucidata> Ok thanks for the review.
02:19:35 <elucidata> Might want to tweet that to them.
02:19:45 <elucidata> I'm sure they'll find it useful just as I have.
02:20:15 <shachaf> It isn't a thorough review. I haven't read the book, I only skimmed some parts.
02:20:25 <chreekat> shachaf: I'm biased because i've had personal interactions with one of the authors, but you've said that this book is the worst thing out there ("you're better off reading just about any other book or introduction") and yet have incredibly vague complaints
02:20:28 <shachaf> I don't have a copy of it here to quote individual excerpts.
02:20:33 <elucidata> [nods respectfully]
02:21:09 <shachaf> chreekat: Well, compared to most other Haskell introductions I can think of.
02:21:41 <elucidata> shachaf: I'm assuming that's the set of all haskell intros that don't say a lot of nonsense?
02:21:49 <shachaf> Right.
02:21:55 <shachaf> For example, Hutton's _Programming in Haskell_ (second edition out soon, if you're looking for a book to learn from) is good.
02:22:18 <shachaf> _Learn You a Haskell_ was popular at one point. It's not ideal but I never saw it say things that are blatantly wrong.
02:22:45 <elucidata> shachaf: well as of yet you claim not to really have seen anything whatsoever from haskellbook, so....
02:23:25 <shachaf> That's not what I claim. I read some parts of it, mostly as quoted by other people etc., and they were nonsense. I didn't keep a copy.
02:24:40 <elucidata> So, you heard second hand that it was full of nonsense and then deleted it after looking at it for a few minutes and also deciding that this book, this book is quite obviously the worst haskell book ever written.
02:25:13 <shachaf> No, I read actual text. At least a chapter.
02:25:32 <elucidata> shachaf: but you have no memory of this chapter other than it was wrong in some vague way
02:26:39 <elucidata> I think it's fantastic that we have these precious moments during the hour of the wolf to shitpost about a book you haven't read, because usually this channel is abuzz with meaningful content.
02:26:54 <shachaf> I don't have a copy handy to give you exact quotes.
02:27:42 <suppi> i think lyah is a great book to read if you don't mind not being able to write any haskell after you finish it
02:28:05 <shachaf> I don't usually say much because this is the sort of reaction I expect. I won't twit at the authors because I don't think it'll do any good.
02:28:15 <elucidata> suppi: perhaps the title should have been "The Zen of Haskell" then :)
02:28:39 <rydgel> I don't think it is a bad book
02:28:48 <suppi> elucidata, yeah, i totally feel like i got the zen of haskell from lyah. but i definitely wasn't able to write any haskell after completing it.
02:28:49 <rydgel> I quite like it
02:28:52 <shachaf> I was hoping that telling people to read something else would be able to do some good. Looks like the way I'm doing it isn't doing any good. Oh well.
02:29:14 <elucidata> shachaf: yeah usually programmers are big on evidence and facts
02:29:20 <elucidata> frustrating, I know
02:30:13 <suppi> i think the best way to decide on haskellbook is to read the sample chapters and see if it gets to you or not
02:31:00 <chreekat> I'm not sure that's true, elucidata  :) But I do wish you could provide actual quotes, shachaf. It would strengthen your claim. Do you want me to send you a copy? I'm sure they wouldn't mind, since your feedback (even if it's just quoting parts that are incorrect or sloppy into irc) would be invaluable
02:31:34 <elucidata> chreekat: that's a fantastic suggestion
02:32:04 <elucidata> shachaf: would you do us the slight favor of receiving a copy now and telling us what's nonsense about the monad chapter?
02:34:32 <anilanar> oh wait
02:34:50 <shachaf> I have a couple of quotes from that chapter from IRC logs:
02:34:51 <anilanar> are there sample chapters for haskellbook :|
02:35:02 <shachaf> "The combination of a functor, a flattener, and an identity element gives us a triad, and it also gives us a monoid. Because this monoid is no ordinary monoid, but a particularly powerful one, it deserves to be singled out as a different form of monoid. One thing to note is that no one part of the triad here is itself monoidal. You have to have all three before you have a monoid defined for the set of fun
02:35:08 <shachaf> ctors: fmap for a binary associative ...
02:35:09 <shachaf> "As we said above, a monad is an applicative functor with some unique features that make it a bit more powerful than either alone. A functor maps a function over some structure; an applicative maps a function that is contained over some structure over some structure and then mappends the two bits of structure. So you can think of monads as just another way of applying functions over structure, with a coup
02:35:15 <shachaf> ... operation, and join . return for your identity element:"
02:35:17 <shachaf> le of additional features."
02:35:34 <shachaf> Maybe this is too hostile of me.
02:35:56 <elucidata> ok well what is nonsense about that passage
02:36:53 <shachaf> All of it?
02:37:09 <elucidata> how?
02:37:29 <elucidata> I don't know haskell. That's why I bought a beginners book.
02:37:45 <elucidata> Telling me it's wrong because it's wrong has literally zero utility to me whatsoever.
02:38:31 <rydgel> shachaf: the monoid part bothers you?
02:38:57 <shachaf> Anyway, I didn't mean to be giving a thorough review of a thousand-page book. I meant a recommendation to someone to read something else for their own sake. Obviously I picked a bad way to do it.
02:39:26 <shachaf> elucidata: If you don't know Haskell or what a monad is, what do you want me to say?
02:40:08 <elucidata> shachaf: I want you to say why it's wrong so the rest of the channel can judge you and inform me if you're full of shit or not.
02:40:29 <shachaf> Concretely: A monad is indeed a sort of monoid, but not the typical type of monoid. fmap isn't the "binary associative operation" part of it, and join . return isn't the "identity element" part of it.
02:41:05 <shachaf> And that whole passage is written in a bizarre way if you know anything about the topic.
02:41:31 <suppi> I have to agree that this quote is... weird
02:42:30 <shachaf> Concretely: "a monad is an applicative functor with some unique features that make it a bit more powerful than either alone" makes no sense, because "either alone" doesn't even happen, since every applicative functor is a functor. "an applicative" isn't a thing independent from functors.
02:42:46 <shachaf> Whatever intuition it's trying to provide there is unhelpful at best.
02:42:49 <suppi> but i can probably find weird quotes on other haskell books as well
02:43:46 <shachaf> Anyway, even skimming the sample PDF, it's full of wrong and misleading things.
02:43:48 <shachaf> It suggests that "c where a = b" is an expression (it isn't).
02:44:16 <shachaf> It says that "let a = b in c" is the same as "(\a -> c) b" (it isn't).
02:44:31 <shachaf> Whatever, I'm not doing myself any favors here.
02:44:41 <elucidata> I appreciate it.
02:44:50 <chreekat> shachaf: fwiw your first quote no longer exists in the most recent version I got (May 12)
02:44:53 <elucidata> This is what I was hoping you'd provide.
02:44:53 <srhb> At least those last few things are the kind of criticisms that I know the authors _do_ correct
02:45:01 <srhb> If given the chance, at least.
02:45:11 <shachaf> chreekat: I'm glad they got rid of it.
02:45:28 <elucidata> shachaf: and yes, not everything you pasted appears in the copy I just bought, so they have indeed been attempting to improve it
02:45:31 <srhb> Also I heartily recommend the book, if for no other reason than because they start with some simple lambda calculus intuition, which appears to be immensely helpful to beginners.
02:45:50 <chreekat> And the second quote is mostly intact, although "mappends them together" has been replaced by "...and then combines the two layers of structure like mappend."
02:46:50 <elucidata> chreekat: well thank you for the analysis, I'll definitely reconsider if it's worth $60 compared to other options
02:46:50 <suppi> shachaf, `let a = b in c` is not the same as `(\a -> c) b` ?
02:46:50 <suppi> and `c where a = b` is not an expression?
02:47:03 <shachaf> Correct.
02:47:37 <suppi> yeah, i see the where part
02:48:03 <suppi> why isn't the let thing equivalent? because of self reference?
02:48:27 <shachaf> Oh, that's another reason. Also because of polymorphism.
02:48:43 <suppi> polymorphism?
02:49:23 <shachaf> That's why e.g. https://en.wikipedia.org/wiki/Hindley-Milner has both let and lambda.
02:49:56 <suppi> can you expand on the polymorphism part?
02:50:43 <shachaf> The page I linked to expands on it. Section 4.3.
02:51:19 <shachaf> And of course the response is that it's OK to say that they're the same because beginners don't care about polymorphism.
02:51:22 <suppi> thanks
02:51:59 <elucidata> I care, I just can't make any sense of the notation in Section 4.3 of that link
02:52:12 <elucidata> which is what haskellbook is trying to help with
02:52:18 <suppi> i generally think that giving the wrong impression of something is not helpful
02:52:21 <elucidata> and apparently not doing as well as they hoped
02:52:56 <rydgel> suppi: it's ok to gives simpler explanation at the beginning
02:53:01 <rydgel> just like school
02:53:05 <shachaf> Making small errors like that all over the place is why I say sloppy. If you learn from that book, you'll have to relearn everything, because it'll build a rickety model in your head.
02:53:13 <suppi> rydgel, simple should still be correct
02:53:32 <suppi> rydgel, for example, don't talk about the generality of monads if you just want to teach someone to use IO
02:53:41 <elucidata> rydgel: did you take your name from Farscape?
02:54:01 <elucidata> sorry for off topic
02:54:12 <shachaf> If someone knows the language well, and is good at explaining things, they can write something correct and simple.
02:54:16 <rydgel> elucidata: rigel star, it might be on farscape
02:54:29 <suppi> shachaf, i don't know of better books though.
02:54:59 <shachaf> elucidata: You don't need to understand the section, just the part that says that it's "the reason why the let-expression appears in the syntax at all".
02:55:15 <shachaf> The details are way too esoteric for someone learning Haskell, I can agree on that much.
02:55:36 <rydgel> I remember learning physics/electricity at school and then I later learned that everything was "wrong" and that I should use maxwell equations and stuff
02:55:45 <rydgel> I think giving approximation to the beginners is ok
02:55:56 <elucidata> shachaf: what confuses me is that if this book is such garbage, then why aren't more people calling them out? there is wide praise for the book and they're even the official book of #haskell-beginners
02:56:13 <chreekat> Yeah, I learned physics at least three times, and it would have been a fourth if I had continued to graduate studies
02:56:22 <shachaf> elucidata: Yes, the author of that book made #haskell-beginners.
02:56:49 <shachaf> It's a channel unrelated to this channel.
02:57:09 <elucidata> shachaf: so why aren't more people critical of the book?
02:57:13 <chreekat> I'm not saying that's teh ideal way to learn things, but I also don't know that it would be practical to eschew physics altogether until I'd gotten through all the math needed for graduate-level physics
02:57:52 <shachaf> elucidata: I don't know the answer exactly. Have you talked to many people who know Haskell well about the book?
02:58:12 <elucidata> shachaf: just in this channel since joining
02:58:22 <elucidata> shachaf: but also reading all the reviews about it
02:58:28 <hexagoxel> elucidata: really it's the other way round; #haskell-beginners is the official channel of (one of) the book's author(s).
02:58:51 <shachaf> Are any of the reviews written by people who know Haskell well?
02:58:53 <hexagoxel> and reviews on what platform? the one run by the author?
02:59:51 <elucidata> https://www.reddit.com/r/haskell/comments/40frfj/new_release_of_the_book_haskell_programming_from/
03:00:17 <elucidata> I'm just saying, usually when something is bunk, someone calls them out, like shachaf did
03:01:19 <rydgel> I know Haskell for a lot of time, and I honestly wish there were more books at the time I learned it. And this one would have made my life simpler on some concept I had a hard time to grasp
03:01:33 <SP3NCR> Hey guys
03:03:24 <notdan> I mean that book is still WIP, isn't it?
03:03:26 <shachaf> Well, I'm going to sleep. I probably went farther than I should have.
03:03:43 <elucidata> notdan: they say it's complete with only minor editing needed
03:03:45 <relrod> elucidata: A lot of people say a lot of things and don't get called out on it; doesn't make it helpful. *shrug*
03:03:49 <elucidata> shachaf: no I ap[preciate it
03:03:52 <notdan> ok, well
03:03:56 <notdan> idk
03:04:06 <elucidata> shachaf: what's your book recommendation again?
03:04:21 <relrod> shachaf: thanks for fighting the good fight :)
03:04:32 <suppi> shachaf, good night 
03:04:36 <shachaf> I didn't really recommend any book.
03:05:03 <elucidata> can you recommend one for a beginner?
03:06:00 <shachaf> I happen to have liked Hutton's _Programming in Haskell_ when I read the first edition, but there are valid criticisms of it (though I can't think of any having to do with big mistakes or sloppiness or anything like that). The second edition will be out soon.
03:06:16 <elucidata> alright, I'll keep an eye out
03:06:29 <suppi> soon - august
03:06:32 <shachaf> I don't know whether it's appropriate for "a beginner". Some people would probably disagree.
03:06:49 <suppi> also, no one has read the new edition yet :)
03:07:01 <shachaf> Yes. That's why I mention the caveats.
03:07:02 <anilanar> they say it's more "academic"
03:07:02 <suppi> except a few chosen ones i guess
03:07:02 <elucidata> well I'm pretty much retarded, so. I need all the help I can get
03:08:04 <shachaf> It has the benefit of being under 200 pages.
03:08:24 <elucidata> for example, I spill coffee on myself pretty regularly because I lean too far back in my chair when I'm drinking. Been doing that most of my coffee drinking life now, and I've ruined many, many shirts. Perhaps Haskell isn't for me.
03:08:48 <suppi> ouch
03:09:08 <elucidata> like I said _retarded_
03:09:08 <suppi> actually, that sounds like a perfectly good reason to _use_ haskell ;)
03:09:44 <elucidata> heheh, yeah it will keep me on the edge of my seat instead of wishing I wasn't alive and having to write JavaScript
03:10:00 <suppi> most criticism of haskell and static typing i heard of is "well, i don't need it because i don't do these kinds of mistakes"
03:11:16 <suppi> so yeah, if you are not an elite programmer like that, the compiler can help you immensely
03:11:23 <suppi> imo anyway
03:11:43 <hexagoxel> in other languages you regular shoot yourself into the foot. in haskell, worst case is you shoot into a copy of your foot.
03:12:03 <elucidata> :D
03:12:42 <suppi> there are some ways to shoot yourself in the foot in haskell, but there are less, and most of them exists in other languages as well
03:13:19 <trilog> worst parts when programming in haskell: when you code in some other language, you are just banging your head against the wall because you have to start implementing monadic-style operations all over again
03:13:33 <relrod> elucidata: imo, find a book that generally has a good reputation of being technically sound (maybe what shachaf mentioned, I've not read it), and just ask tons of questions on IRC as you go through it, until concepts become clear. This lets you focus less on "is it beginner friendly enough?" and more on learning and not having to re-learn concepts later.
03:13:50 <trilog> I actually hit this everyday (I don't work in haskell)
03:13:59 <suppi> basically learning domain specific stuff is a pain because most tutorials are for other languages :\
03:14:10 <bernalex> suppi: any sufficiently experienced PHP or JavaScript programmer contains an ad hoc, informally-specified, bug-ridden, slow implementation of a typechecker.
03:14:55 <notdan> eeh i remember Learn You a Haskell to be a nice book. I certainly liked it myself
03:15:43 <suppi> X for lyah :<
03:16:29 <suppi> anyway bye for now
03:17:26 <notdan> see you
03:27:29 <tigerfinch> trilog: this, so much. Leads to some interesting code reviews
03:28:43 <anilanar> suppi: if you are an elite, you can't take it when your teammates making such mistakes, haskell is one way to reduce their mistakes :)
03:29:17 <anilanar> oops, grammer.
03:29:18 <suppi> anilanar, some people like to complain about others
03:40:35 <hexagoxel> how the ** does -fno-code break -Wall -Werror warning reporting in ghci?
03:40:39 <hexagoxel> :(
03:42:13 <quchen_> "break"?
03:43:38 <hexagoxel> no warnings are reported, loading returns with success.
03:46:25 <skrio> (Not an expert) but it seems fairly likely? If you tell ghci to not generate code, (and all later stages) those inspections are probably never run.
03:54:19 <hexagoxel> makes sense, but still sounds like a bug to me.
04:02:54 <chreekat> bitemyapp: fwiw I think shachaf is right to question equating let/where constructs with lambda expressions. Absent polymorphism they "mean" the same thing, but that's a big caveat, one that I remember being frustrated by. Had I learned via this book I would have appreciated a footnote about that
04:08:52 <quchen_> chreekat: What's the difference?
04:09:14 <quchen_> I always forget what "where" means. :-/
04:09:37 <chreekat> quchen_: heh tbh I can't remember off hand the difference between 'let' and 'where'; I just remember that a difference exists
04:10:12 <jophish> with haddock, how can I get it to not output help with file:/// links in
04:11:27 <maerwald> chreekat: scope
04:11:33 <chreekat> But shachaf was talking about how `\f -> (f True, f 0)` is a type error, but `let f = \x -> x in (f True, f 0)` is not
04:11:48 <skrio> quchen_: Let is an expression (can be written anywhere), where is bound to a syntactic construct
04:12:19 <chreekat> there's also "let/in" versus the do-syntax let
04:12:33 <quchen_> do-let is simple sugar for let...in.
04:12:48 <quchen_> where is some form of sugar for let, but I don't know in what way.
04:13:28 <chreekat> isn't there some difference in the consequences on sharing between let and where?
04:18:43 <quchen_> Rule (c) in the formal semantics of pattern matching in the Report translates where straight to let
04:23:32 <chreekat> This is probably what I was remebering poorly: https://wiki.haskell.org/Let_vs._Where#Problems_with_where
04:23:40 <breadmonster> Hello.
04:23:44 <breadmonster> What's up, guys?
04:24:16 * chreekat waves
04:24:27 <breadmonster> I'm in such a fucking fix.
04:25:02 <breadmonster> I know it's off topic, does anyone know their way around GNOME?
04:25:51 <dysfun> people in #gnome, i expect
04:27:42 * hackagebot haskell-tools-ast 0.1.2.0 - Haskell AST for efficient tooling  https://hackage.haskell.org/package/haskell-tools-ast-0.1.2.0 (lazac)
04:32:42 * hackagebot haskell-tools-ast-trf 0.1.2.0 - Conversions on Haskell-Tools AST to prepare for refactorings  https://hackage.haskell.org/package/haskell-tools-ast-trf-0.1.2.0 (lazac)
04:32:44 * hackagebot haskell-tools-ast-fromghc 0.1.2.0 - Creating the Haskell-Tools AST from GHC's representations  https://hackage.haskell.org/package/haskell-tools-ast-fromghc-0.1.2.0 (lazac)
04:32:46 * hackagebot haskell-tools-ast-gen 0.1.2.0 - Facilities for generating new parts of the Haskell-Tools AST  https://hackage.haskell.org/package/haskell-tools-ast-gen-0.1.2.0 (lazac)
04:32:47 <jmtorresg> Hi everybody! Sorry if my question seems dumb but I'm learning Haskell and I'm getting really confused about how folds (especially foldl) work.
04:32:48 * hackagebot haskell-tools-refactor 0.1.2.0 - Refactoring Tool for Haskell  https://hackage.haskell.org/package/haskell-tools-refactor-0.1.2.0 (lazac)
04:32:50 * hackagebot haskell-tools-prettyprint 0.1.2.0 - Pretty printing of Haskell-Tools AST  https://hackage.haskell.org/package/haskell-tools-prettyprint-0.1.2.0 (lazac)
04:33:15 <jmtorresg> Does anybody here know of a good ressource that explains clearly how they work and the differences between foldr and foldl?
04:33:33 <dysfun> have your examples been using multiplication perchance?
04:33:43 <dysfun> or addition
04:33:48 <jmtorresg> addition yeah
04:34:05 <dysfun> right, well try something that isn't commutative like division
04:34:43 <quchen_> (:) is not commutative.
04:34:51 <quchen_> :t foldr (:) []
04:34:52 <lambdabot> Foldable t => t a -> [a]
04:35:08 <dysfun> yeah, (:) is perfect
04:35:40 <quchen_> (:) has the advantage of having different types for the first and second arguments.
04:35:49 <quchen_> So you can't use it wrong in this context. :-)
04:36:05 <dysfun> and of showing every item
04:37:08 <jmtorresg> thanks a lot guys, gonna try it now :)
04:37:31 <jmtorresg> I'll get back to you if I have more questions
04:38:01 <quchen_> jmtorresg: `foldr f z` takes a list, and replaces all the (:) in it with f, and the [] with z.
04:38:22 <quchen_> So foldr (:) [] replaces all (:) with (:) and the [] with []. So it's the identity on lists.
04:38:39 <quchen_> But foldr can also terminate early, for example
04:38:48 <quchen_> > foldr const 0 [1..]
04:38:50 <lambdabot>  1
04:39:13 <quchen_> You can't do that with foldl, because it has to traverse the entire list before returnig a result.
04:39:23 <quchen_> > foldl const 0 [1..]
04:39:29 <lambdabot>  mueval-core: Time limit exceeded
04:40:35 <quchen_> foldr is also known as the "deconstructor", "recursor" or "inductor" on lists sometimes.
04:40:48 <quchen_> It's the canonical way of how to consume a list element-by-element.
04:41:28 <maerwald> mind that both foldr and foldl traverse the list in the same order
04:46:06 <notdan> jmtorresg: https://wiki.haskell.org/Fold#List_folds_as_structural_transformations
04:46:11 <notdan> might be of interest
04:50:45 <ijp> foldl is like foldr, but if the list was a snoc-list rather than a cons-list
04:51:42 <Ashy> so im interested in helping to improve ghc's performance: https://github.com/AshyIsMe/ghc-profiling
04:51:46 <hpc> > foldr (*) z [1..5] :: Expr
04:51:47 <lambdabot>  1 * (2 * (3 * (4 * (5 * z))))
04:51:49 <hpc> > foldl (*) z [1..5] :: Expr
04:51:51 <lambdabot>  z * 1 * 2 * 3 * 4 * 5
04:52:21 <Ashy> whipped up a simple script to compare compile times of a project between stackage lts and nightly (which gives us ghc-7.10.3 vs ghc-8.0.1)
04:52:33 <Ashy> bgamari: is there something like this already?
04:53:04 <Ashy> bgamari: my idea is to make it a simple "git clone ... & ./run" for people to start profiling ghc itself on their machine to help encourage more people to look at improving performance
04:53:25 <Ashy> it would be great if we could get per ghc pass timings too but i havent delved far enough into the ghc options just yet
04:53:52 <bgamari> Ashy, not that I know of
04:54:09 <bgamari> Ashy, GHC can give you per-pass timings as of 8.0
04:54:14 <bgamari> Ashy, with -v
04:55:10 <bgamari> Ashy, the problem with using arbitrary user code for performance characterization is that it can be very difficult to determine what actually changed
04:55:38 <bgamari> there are typically too many variables to be able to say much without significantly cutting down the code
04:55:46 <quchen_> ijp: No, not at all.
04:56:11 <Ashy> bgamari: yeah it's not going to be perfect, there's also version differences potentially between the stackage lts and nightly versions of the packages too
04:56:15 <Ashy> but it's a start right?
04:56:29 <bgamari> indeed, it may nevertheless be helpful
04:56:44 <bgamari> just pointing out that it can be tricky to get good numbers
04:56:54 <Ashy> it's also just a terrible bash script at the moment, the idea was a quick bang for buck proof of concept
04:57:13 <Ashy> also that's why it compares the two ghc versions on the same machine right after each other
04:57:13 <quchen_> ijp: Snoc lists are the same as normal lists. foldl is not the same as foldr.
04:57:23 <Ashy> so at least you get some kind of indication for the same cpu/ram etc
04:57:31 <bgamari> Ashy, for the record, we also have rather detailed logs of the last few years of nofib performance
04:57:45 <bgamari> Ashy, I've hacked together an interface to visualize trends in this dataset here, file:///home/ben/perf-import/web/index.html
04:57:54 <bgamari> err, http://home.smart-cactus.org/~ben/ghc-perf-import/web/
04:58:10 <maerwald> quchen_: he probably means that wrt: foldr (:)
04:58:25 <quchen_> Still.
04:58:32 <Darwin226> Hey guys. Anyone know how I can build documentation for my project with stack? "stack build myproject --haddock" unregisters every package I use and starts rebuilding them (or maybe just rebuilding their docs?) which I don't want
04:58:40 <bgamari> Ashy, sadly my conclusions thusfar seem to be that much of the performance pain is caused by the addition of instances to `base`
04:59:06 <Darwin226> I don't care if the types and stuff that belong to other packages are hyperlinked in the docks
04:59:08 <Darwin226> docs*
04:59:10 <bgamari> Ashy, since the compiler needs to load and potentially typecheck these on nearly every compilation
04:59:45 <maerwald> :t foldr (cons)
04:59:46 <lambdabot> (Foldable t, Cons b b a a) => b -> t a -> b
04:59:49 <maerwald> :t foldl (snoc)
04:59:50 <lambdabot> (Foldable t, Snoc b b a a) => b -> t a -> b
04:59:59 <Ashy> bgamari: so you don't see any low hanging fruit really?
05:00:20 <Ashy> i have no ghc hacking experience by the way, just love the idea of ghc being a really fast compiler
05:00:45 <Ashy> even though it already is for how advanced the language is compared to most other compilers...
05:00:53 <bgamari> Ashy, well, that's not to say there isn't low hanging fruit
05:00:57 <quchen_> Profiling GHC would be a good idea. Not sure how practical it is though, given its enormous size.
05:01:10 <Ashy> i can't seem to get any actual data to display on your ghc-perf-import page
05:01:15 <chreekat> Darwin226: --no-haddock-deps i think
05:01:15 <quchen_> It's full of lists and strings, there are probably plenty of opportunities with those.
05:01:35 <bgamari> Ashy, in fact, trying to work out how to reduce the cost of these instances may very well be low-hanging fruit
05:01:54 <bgamari> quchen_, profiling tends not to be very helpful in my experience
05:02:00 <Darwin226> chreekat: amazing!
05:02:04 <Darwin226> thanks
05:02:15 <bgamari> quchen_, since you really don't know what is a "reasonable" cost breakdown
05:03:10 <bgamari> quchen_, I have a patch which essentially replaces s/foldl/foldl'/ in the entire codebase; sadly it made precisely zero difference
05:03:29 <bgamari> quchen_, it turns out GHC's strictness analysis works rather remarkably well
05:03:34 <quchen_> Oh :(
05:03:54 <bgamari> quchen_, of course, that's just one datapoint
05:04:08 <bgamari> Ashy, it requires a rather new browser
05:04:23 <bgamari> it requires rather mature ES6 support
05:04:30 <Ashy> i have chrome stable up to date
05:04:35 <Ashy> oh nope, beta
05:05:15 <Ashy> maybe im just misusing it, you're supposed to just select some of the options right?
05:07:43 * hackagebot structural-traversal 0.1.1.1 - Initial project template from stack  https://hackage.haskell.org/package/structural-traversal-0.1.1.1 (lazac)
05:22:44 * hackagebot haskell-tools-ast 0.1.2.1 - Haskell AST for efficient tooling  https://hackage.haskell.org/package/haskell-tools-ast-0.1.2.1 (lazac)
05:22:51 <bgamari> Ashy, indeed, just check some of the options on the right
05:23:59 <Ashy> oh wow, the chart is failing to render entirely in crhome
05:24:02 <Ashy> but working in firefox
05:24:30 <Ashy> that makes more sense
05:36:06 <Aruro> what is most common way to derive parsers except aeson?
05:36:39 <Aruro> specifically data Day = Mon | .. | Sun deriving (Show, Enum)
05:37:29 <Aruro> would be nice to have ghc/attoparsec/parsec/trifecta/earley derive parser String->Day
05:37:59 <maerwald> Aruro: Read?
05:38:13 <Aruro> yeah, but "wise" people abandonned it
05:38:30 <maerwald> whatever that means
05:38:40 <Aruro> now just for this simple datatype u have to write spagetti
05:38:42 <Aruro> of code
05:39:02 <Aruro> it means that Read is not good solution?
05:39:58 <maerwald> read is perfectly suitable for parsing such simple data types
05:40:32 <Aruro> in attoparsec the shortest way to parser i can think of is : dayparser = map string [Mon .. Sun]
05:41:06 <Aruro> and then foldl (<|>) mempty dayparser
05:41:47 <Aruro> maerwald: couple of days ago people here strongly stated read is only for debug
05:42:30 <maerwald> read is simple and error-prone, that's all. Use "readMay" from the Safe package and don't do fancy things.
05:42:57 <Aruro> maerwald: but this seems such a common case why not SYB it?
05:43:29 <Aruro> some kind of parserbuilder for enum types for starter
05:49:59 <barrucadu> maerwald: No need for a separate package, readMaybe is in Text.Read
05:50:05 <barrucadu> Which is in base
05:50:07 <matrium> can I somehow  map a "Maybe (a, Maybe (b, Maybe c))" to a "(Maybe a, Maybe b, Maybe c)" without to much boilerplate code?
05:50:23 <maerwald> barrucadu: well, that works on Text I guess, not String
05:50:28 <barrucadu> No, String
05:50:33 <maerwald> oh
05:50:47 <maerwald> :t readMaybe
05:50:48 <lambdabot> Not in scope: ‘readMaybe’
05:50:52 <barrucadu> :t Text.Read.readMaybe
05:50:53 <lambdabot> Read a => String -> Maybe a
05:51:53 <niko> :14
05:52:22 <Aruro> maerwald: take example of time 14:43 while perfectly simple type (Int,Int) but read will fail miserably to parse it
05:52:42 <Aruro> because it will stuck on technicality of ":"
05:52:43 <maerwald> Aruro: 14:43 is not a type afais
05:52:59 <Aruro> this time string
05:53:07 <Aruro> can be represented very simple
05:53:10 <maerwald> that's not simple conversion of constructors
05:53:14 <maerwald> so no, it's not simple
05:53:42 <maerwald> "(14, 43)" to (14, 43) is simple
05:53:47 <Aruro> yes it is simple just comma changes to : and no brackets
05:53:59 <Aruro> from human stand point its very similar/simple
05:53:59 <maerwald> no, for that you want a parser, not a Read instance
05:54:10 <maerwald> if you just parse constructor names, Read is fine
05:55:02 <Aruro> > read "1:[]" :: [Int]
05:55:04 <lambdabot>  *Exception: Prelude.read: no parse
05:55:19 <barrucadu> If you have a type 'data Day = Mon | ... Sun' and want to derive a function :: String -> Day, 'deriving Read' gets you that.
05:55:20 <maerwald> you're trying to parse an expression
05:55:47 <Aruro> i want read to be able to read stuff like 14:55 as easily as (14,55)
05:55:53 <barrucadu> If you want anything more complicated, then you need a parser
05:56:04 <barrucadu> Well that's not what it's for
05:56:19 <Aruro> it should be for it
05:56:23 <barrucadu> Why?
05:56:24 <Aruro> thats my point
05:56:27 <maerwald> exactly... for your Day type, Read is fine, which was your initial question
05:56:34 <maerwald> now you are adding requirements
05:56:38 <barrucadu> Show and Read are for serialising and deserialising Haskell types
05:56:43 <Aruro> maerwald: im generalizing
05:56:45 <barrucadu> Not for parsing arbitrary expressions
05:57:16 <maerwald> Aruro: then we don't really know what you want if you start with a specific question and then throw it overboard and want a general answer
05:57:21 <Aruro> barrucadu: because of ADT u can match very big range of expressions if read will be slightly more general or allow some tweaks
05:57:37 <Aruro> maerwald: i wrote what is general way to derive parser, above
05:57:55 <bezirg> Is there a query to find out what flags the library is installed with?  ghc-pkg describe or ghc-pkg field does not have any flag entry. Is that even possible?
05:57:57 <maerwald> you can't automatically derive such complex logic
05:57:59 <barrucadu> You asked for a way to derive a parser for your 'Day' type
05:58:55 <Aruro> barrucadu: you dont see the poin read has no space to tweak, i showed you minimal example where read immediately fails and its sad
05:59:07 <barrucadu> No, I don't see the point
05:59:25 <Aruro> if you want to parse 23:34 not (23,34) then u need parser library
05:59:29 <barrucadu> How could you derive a parser? How does it know what syntax you might want?
05:59:33 <maerwald> we don't even know what you want. Do you want to parse Day, do you want to parse time? do you want someone to write parsers for you automagically?
06:00:12 <Aruro> maerwald: there is function readSlist or something which allows to tweak how read works on lists
06:00:23 <Aruro> maerwald: there is no such function for tuples i think
06:00:39 <maerwald> at that point, I would abandon Read
06:00:52 <Aruro> maerwald: and will write tons of code by hand?
06:01:00 <maerwald> TONS OF CODE, yes.
06:01:07 <maerwald> or just a 2 LOC solution in haskell
06:01:09 <maerwald> your choice
06:01:26 <dysfun> you mean ghc can't write all my code for me?
06:01:29 <maerwald> haha
06:01:57 <quchen_> readDay str = head [ x | x <- [Mon.. ], show x == str ]  -- There's a parser. It even does the right thing instead of crashing sometimes.
06:02:11 <quchen_> [Mon ..], rather.
06:02:17 <Aruro> ok, lets make specific we have date "Fri Jul 1 23:34" , what is easiest way to parse it ? assume u have enum types for day month, time can be just (Int,Int)
06:02:25 <Aruro> my point is read ALMOST could do it
06:02:43 <maerwald> I'd use a parser for that.
06:03:07 <Aruro> maerwald: do u agree that read almost could do it? if not problem with ":" ?
06:03:09 <dysfun> there are several on hackage
06:03:10 <maerwald> and I don't see how Read could do that when you are mixing in types
06:03:24 <maerwald> no, I don't think read can do it with your Day type
06:03:36 <maerwald> you can't parse Day and return (Int, Int)
06:03:48 <maerwald> that would be a type error
06:03:55 <Aruro> maerwald: assume extra type Date which sums all types
06:04:04 <Xandaros_> Just write a simple parser. Parsers in Haskell are ridiculously easy
06:04:09 <maerwald> I don't really know what to assume there
06:04:20 <maerwald> yes, write a parser
06:04:48 <Aruro> maerwald: so you completely dont understand my point? :)
06:05:07 <maerwald> Aruro: just because people disagree doesn't mean they don't understand you
06:05:19 <quchen_> The idea to use Read for this is bad.
06:05:23 <nmattia> sorry I'm a bit late, what's the goal here? parsing time? deriving a time parser? 
06:05:26 <dysfun> http://hackage.haskell.org/package/dates-0.2.2.1/docs/Data-Dates.html
06:05:40 <dysfun> there, somebody else even wrote it for you
06:05:53 <maerwald> again: Read is fine for _simple_ things (e.g. parsing constructor names only). For anything else, use parsers and stop complaining :P
06:06:08 <Xandaros_> (,) <$> (read <$> many digitChar) <*> (char ':' *> read <$> many digitChar) -- there you go - parser.
06:06:45 <Xandaros_> (Not a very robust one, mind you)
06:07:05 <maerwald> read <$> many digitChar <*> such parser
06:07:06 <maerwald> xD
06:07:25 <dysfun> very wow
06:07:56 <srhb> Wow <$> ...
06:08:04 <Aruro> Xandaros_: notice u just parsed two numbers with : inbetween, if you would want to parse enum type like Day = [Mon .. Sun] it will make your parser a lot uglier
06:08:22 <maerwald> Aruro: you write parsers for each type and combine the parsers
06:08:27 <maerwald> it will not be ugly
06:08:40 <barrucadu> Actually it wouldn't, because if you wanted to parse a simple enum type like that you'd use readMaybe
06:08:54 <barrucadu> Or something similar
06:09:07 <Xandaros_> yeah, in those cases you can use readMaybe, readMay, safeRead, whatever...
06:09:14 <Xandaros_> One of those read functions that returns a maybe
06:09:25 <Aruro> barrucadu: just for fun parse string Mon Jun 1 23:34 using read :)
06:09:34 <barrucadu> No
06:09:42 <barrucadu> Because that is not what Read is for, as we've been saying
06:09:51 <maerwald> I start to feel he's not listening
06:09:53 <Xandaros_> You use read to parse "Mon" and "Jun". You use a parser to read the whole thing
06:09:54 <barrucadu> But it could do the Mon, Jun, or 1
06:09:55 <Aruro> barrucadu: u just commented on emum types?
06:09:59 <barrucadu> Yes
06:09:59 <dysfun> i felt that a while ago
06:10:05 <barrucadu> Mon Jun 1 23:34 isn't an enum
06:10:07 <barrucadu> It's a sum
06:10:12 <barrucadu> And yes, this is going nowhere
06:10:18 <barrucadu> Sorry, not a sum, a product
06:10:42 <Aruro> whatever its a combination of enum types and couple of ints
06:11:09 <Xandaros_> And you can use read to parse the constituents. But you should still use a parser to combine everything
06:11:13 <barrucadu> I give up
06:11:25 <nmattia> how did this whole thing start?
06:11:37 <Xandaros_> What is with your aversion to parsers, anyway?
06:11:56 <hpc> nmattia: someone wanting read = eval, basically
06:11:59 <Aruro> barrucadu: take a look here: https://hackage.haskell.org/package/dates-0.2.2.1/docs/src/Data-Dates.html#parseDate
06:12:19 <Aruro> hpc: somebody wants smart deriving Read
06:12:26 <Aruro> hpc: forbidden?
06:12:47 <nmattia> hpc: thanks :)
06:13:23 <SOS_11100011> "Mr Satwant Singh" UK NHS fake nurse fake diploma big fish
06:13:47 <dysfun> this place is getting more surreal
06:13:49 <SOS_11100011> hey,please "KILL BILL": "Mr Satwant Singh" UK NHS fake nurse fake diploma big fish
06:14:31 <Denommus> hey
06:14:38 <Denommus> luite: ping
06:16:56 <Aruro> data Day = Mon | .. data Month = Jan | .. data Date = Date Day Month Int deriving Read , this can now parse things like "Date Mon Jul 1", only problem is need to prepend Date constructor to string 
06:17:13 <Denommus> I want to publish a GHCJS application on Cordova
06:17:19 <Denommus> and, surely enough, I want to include CSS files on the deployment
06:17:24 <Denommus> but I notice data-files doesn't include my additional files in my .jsexe file, instead it includes then in a share directory in a parent directory
06:17:29 <Denommus> is there any strategy to more easily deploy data-files?
06:17:42 <Denommus> to my .jsexe directory, that is
06:19:21 <Denommus> s/then/them
06:20:08 <Aruro> even parsing just things like:  read "true" :: Bool will cause error, not clear why
06:20:28 <Aruro> so read does need some extension
06:20:47 <codedmart> I am working on rewriting a nodejs web app in haskell/servant. I want to incrementally do it. If there any ffi for js or should I just use System.Process?
06:21:03 <maerwald> because "true" is not a constructor of Bool
06:21:23 <Aruro> maerwald: why having so strict restrictions on case?
06:21:27 <maerwald> Read is not very fault tolerant and it shouldn't be
06:21:33 <maerwald> that's not its use case
06:21:49 <Aruro> maerwald: then i dont understand why is it there at all :)
06:22:04 <Aruro> every little thing needs parser at the end
06:22:19 <dysfun> codedmart: you could proxy anything you don't handle
06:22:41 <bernalex> why would read "true" :: Bool work?
06:22:41 <codedmart> dysfun: you mean like http proxy?
06:22:49 <maerwald> Aruro: you usually want this property to hold: read (show a) == a
06:22:52 <dysfun> codedmart: exactly. if you 404, pass it on to the nodejs
06:22:59 <maerwald> > read (show True) :: Bool
06:23:01 <lambdabot>  True
06:23:32 <bernalex> show and read are isomorphic.
06:23:37 <maerwald> that's also why a lot of people consider this a debugging thing only
06:23:37 <bernalex> > show True
06:23:39 <lambdabot>  "True"
06:23:45 <bernalex> > "True" == "true"
06:23:46 <lambdabot>  False
06:23:49 <codedmart> dysfun: Right but I have some pre written scripts and such to interact with slimerjs and other apis in node. I don’t want to convert them all at once. I plan on proxy’ing routes to incrementally do those.
06:23:49 <bernalex> so why would read "true" work?
06:24:04 <codedmart> So I am talking about non route related scripts, etc
06:24:05 <Aruro> bernalex: why should they be isomorphic?
06:24:05 <dysfun> ah i see
06:24:10 <skrio> > [] == ""
06:24:11 <lambdabot>  True
06:24:21 <Aruro> maerwald: yea that makes sense
06:24:50 <bernalex> Aruro: if they aren't isomorphic what's the point of them at all then? if you want a parser, write a parser.
06:25:04 <Aruro> bernalex: point that u can derive?
06:25:13 <maerwald> it's starting again
06:25:14 <Aruro> isomorphism is not important here
06:25:16 <ironChicken> anyone used Data.Array.CArray? And know whether there's a way to build a CArray from (Storable a) => [a]?
06:25:26 <maerwald> bernalex: he wants ghc to derive fully-featured parsers for him
06:25:36 <Aruro> maerwald: aeson does it no?
06:25:44 <maerwald> and we told him 30 minutes ago he can't have it
06:26:07 <Aruro> maerwald: i did not say fully  and deriving parsers is not something bad
06:26:07 <bernalex> f (x:"rue") | x == 't' | x == 'T' = True -- have fun.
06:26:09 <hpc> aeson is a wildly different thing from Read/Show
06:26:26 <bernalex> maerwald: lol. that's not how... anything works.
06:26:31 <hpc> not every stringy conversion needs to be an omnipresent superparser
06:26:42 <bernalex> Aruro: if you want parsers for free, check out bnfc.
06:26:54 <Aruro> bernalex: is it haskell library?
06:27:42 <maerwald> he'll probably spend more time figuring that thing out than just writing his custom parser
06:27:57 <maerwald> and the time he's spent asking about it here is roughly the time you need to write such a parser
06:28:52 <srhb> Why not let them make this conclusion on their own? There's probably no danger of anyone ever running into that broken Read instance from some library on Hackage. And the mood of the channel isn't exactly improved by this meta-discussion.
06:29:36 <Aruro> maerwald: i dont udnerstand your desire to have no automatically derived parser
06:29:52 <maerwald> Aruro: that's not what I said
06:29:56 <nmattia> bnfc looks fun
06:30:08 <hpc> Aruro: automatically derived parsers are awesome
06:30:15 <Aruro> maerwald: its what you said and made fun that its not possible.
06:30:15 <hpc> Aruro: Read is not that parser
06:30:34 <maerwald> Aruro: no, it's not what I said
06:30:51 <hpc> Read solves a very specific problem that is superficially similar to but very much unlike parsing
06:30:51 <Xandaros_> There's also abnf, which you can use to generate a parser. I imagine it's similar to bnfc. (Shameless plug)
06:31:20 <nitrix> hpc: Serializing and unserializing; possibly?
06:31:40 <hpc> probably that, yeah
06:31:43 <Aruro> hpc: ty i would end my desire to investigate this topic here :)
06:31:57 <hpc> it's a bit higher-level than what you would normally think as serialization in say, C
06:32:29 <hpc> but fits the same niche of being a very specific combination of reading and writing of some-kind-of-stringy-thing
06:32:32 <dysfun> it's good to program C once in a while to remind yourself why you love haskell :)
06:32:53 <hpc> in text instead of bytes
06:32:55 <Xandaros> C is lovely. Try python
06:33:21 <hpc> python is like if perl was invented by an incompetent police state
06:33:36 <phanimahesh> hahahah.
06:33:44 <phanimahesh> Why do you think so?
06:33:52 <AzureStigma> is haskell be used for jailbreaking for ios
06:33:56 <AzureStigma> can*
06:33:58 <phanimahesh> Python was my first love, before I explored haskell
06:34:20 <Athas> I am having an infinite loop in some CAF.  How do I figure out what source code it corresponds to?  (I know the module.)
06:34:24 <hpc> the attitude of there being only one way to do it
06:34:26 <maerwald> language war incoming
06:34:39 <phanimahesh> I don't like it as much these days but it definitely is a beautiful language
06:34:49 <hpc> getting laser-focused on specific things, and designing away alternatives to those things even when they are the best way to do other things
06:34:53 <hpc> this should be in -offtopic though
06:34:54 * maerwald looks up the perl jam on youtube 
06:35:15 <phanimahesh> Oh, shall we move to -offtopic, then?
06:35:27 <Xandaros> s/-offtopic/-blah
06:35:33 <nitrix> I enjoy #haskell because there's not those type of language discussion often.
06:35:39 <hpc> -blah is poo
06:35:39 <maerwald> Xandaros: there are both channels
06:36:01 <Xandaros> I know.
06:36:16 <maerwald> and -offtopic is the more "official" ones with the same mods roughly
06:36:35 <skrio>  /join #haskell-offtopic
06:36:39 <skrio> -.-
06:37:05 <AzureStigma> so im guessing it cant be used for jailbreak
06:37:07 <rydgel> C is ok. If you want to remind yourslef why you love haskell, do some c++
06:37:08 <Xandaros> -blah was there first and there is no reason to have a second channel. -blah also requires you to use TLS which -offtopic is lacking
06:37:32 <maerwald> Xandaros: -blah is more of a private channel lead by one person, not really community-driven
06:37:53 <maerwald> which is fine, but also the main difference
06:39:29 <buglebudabey> if i have a function that uses mapM (lookup heap) addresses, how can i produce an error message that says which address in the list the lookup failed on?
06:39:43 <hwkng> project m36 transaction graph is brilliant: git branching for dbs
06:41:27 <maerwald> buglebudabey: well, both lists have the same length
06:41:37 <maerwald> but I'd probably write a lookup version that returns Either instead of Maybe
06:42:11 <maerwald> that saves you the reverse lookup I guess
06:42:23 <buglebudabey> maerwald alright i'll give that a shot
06:42:25 <buglebudabey> thanks
06:44:12 <maerwald> https://hackage.haskell.org/package/MissingH-1.4.0.1/docs/Data-Either-Utils.html#v:maybeToEither that might be useful
06:47:47 <buglebudabey> thanks
06:49:19 <nitrix> Small question; I'm learning FRP, what happens if you have Behaviors that needs to do IO ?
06:50:09 <nitrix> Do you end up with bFoo :: Behavior a -> IO (Behavior a) ?
06:50:50 <nitrix> Is there a facility for monadic behaviors or the whole FRP application is treated like a pure graph?
06:51:51 <nitrix> Reactive-banana seems to have Reactive.Banana.Frameworks that lets you build some sort of "graph network" and connect IO inputs and outputs to that :/
06:52:30 <nitrix> I'm just puzzled how that'd work in a video game where, for example, some of the events are responsible for loading more resources or communicating over the network.
06:53:10 <phanimahesh> Project m36 looks cool.
06:53:44 <rydgel> nitrix: you can do events that triggers IO
06:55:34 <nitrix> rydgel: That's cool. Can you guarantee it'll be processed before the next input event (if they were to be dependent on one another) ?
06:55:43 <suppi> phanimahesh, it does :)
06:57:49 * hackagebot th-alpha 0.2.1.0 - Alpha equivalence for TH Exp  https://hackage.haskell.org/package/th-alpha-0.2.1.0 (jkarni)
07:02:49 * hackagebot aeson-pretty 0.8.1 - JSON pretty-printing library and command-line tool.  https://hackage.haskell.org/package/aeson-pretty-0.8.1 (FalkoPeters)
07:03:39 <hexagoxel> nitrix: `fromPoll` not what you want?
07:06:37 <nitrix> That's very cool.
07:07:09 <nitrix> I'm not convinced with a bit of a learning curve, reactive-banana will probably solve most of the major problems I've had trying to implement my game.
07:08:05 <maerwald> nitrix: you're basically a pioneer in that domain, so no one really knows what works well there anyway
07:09:38 <nmattia> nitrix: Ivan Perez gave a few talks/workshops on making games with FRP
07:09:46 <nitrix> maerwald: I tried really cool stuff, including a library that allowed O(1) safe relations between records that weren't in IO.
07:09:49 <nmattia> I do believe he's actually doing a PhD on the topic
07:10:25 <nitrix> maerwald: On that part, I feel if I were to work more on it, it'd have a lot of potential, more than ixset probably. It's based on the same paper for memoization, Weak and IORef.
07:10:56 <nitrix> But if FRP can bring a different approach, I'm all in for it :] Get rid of those ugly StateT and ReaderT everywhere :P
07:13:15 <nitrix> Oh, my bad, I wrote "I'm not convinced", I mean "I'm convinced". Ouch.
07:13:47 <nitrix> nmattia: Will check, thanks.
07:15:11 <hwkng> "cabal run tutd" <-- how do I do the equiv with stack? I tried "stack run tutd" and "stack exec tutd"
07:16:29 <dramforever> "stack exec tutd" should work
07:16:33 <dramforever> If I got it right
07:16:37 <rydgel> Games in FRP is actually quite interesting
07:17:00 <rydgel> Made one with Yampa + SDL2
07:17:05 <dysfun> also quite plausible. it's an easier problem than gui toolkit integration
07:17:11 <rydgel> I don't know banana well tho
07:17:15 <nmattia> nitrix: finally found the name of his studio: http://keera.co.uk/blog/
07:17:58 <nmattia> rydgel: you beat me to it, yampa is actually his library
07:18:07 <rydgel> yup
07:18:57 <rydgel> Reactive-banana works well with GUIs, and Yampa works better with games. At least that's what the author of Netwire told me
07:19:19 <nitrix> I don't know, reactibe-banana seems to have a reactive-banan-sdl package that looks kind of nice to start.
07:20:55 <rydgel> I didn't say you won't be able to do a game in reactive-banana
07:21:17 <anilanar> irrelevant question - i always wonder how indie game programmers go about creating graphics/audio content
07:21:33 <anilanar> assuming no skills in them, do you partner with others?
07:21:49 <Akii> you could pay an artist
07:21:58 <rydgel> It's a difference between continuous time-varying functions and discrete ones
07:22:01 <rydgel> IIRC
07:22:14 <Akii> concernedApe, who made Stardew Valley, did all of it himself
07:23:12 <Akii> Toby Fox (Underworld) paid someone for the pixel art afaik
07:23:13 <nmattia> anilanar: for indie games, this is great: http://www.drpetter.se/project_sfxr.html
07:23:36 <nmattia> and the rest of the assets, well, you do what you can :p
07:23:50 <anilanar> nmattia: looks interesting
07:24:12 <nmattia> haven't made a game in years though, there might be better things out there nowadays
07:27:43 <hwkng> why does stackage not provide data-interval ?
07:28:08 <barrucadu> hwkng: It's up to the author of a package to get it included on stackage
07:28:16 <barrucadu> Although the process is incredibly easy
07:28:55 <barrucadu> People tend to be fairly receptive (in my experience) to including things on stackage if you open an issue and point them to https://github.com/fpco/stackage/blob/master/MAINTAINERS.md
07:29:31 <nmattia> barrucadu: what's the best way to get a review before you put your project up on hackage/stackage?
07:30:13 <barrucadu> nmattia: I tend to just go through all the haddock and make sure everything looks good. Also when I write something it's because I need it, so I usually have a pretty good idea that it works
07:30:20 <barrucadu> Then I upload to hackage
07:30:24 <barrucadu> And immediately spot a typo in the docs
07:30:29 <barrucadu> And make a patch release :(
07:30:59 <nmattia> barrucadu: sounds sensible
07:39:30 <nmattia> when a module reexports functions, is there a way for haddock to copy the doc?
07:39:50 <dramforever> nmattia: list the functions instead of the module
07:39:58 <dramforever> Hmm it's going to be long...
07:40:24 <nmattia> dramforever: yeah indeed, I'm sticking to module X ( module Y ) where ... import Data.MyModule as Y
07:44:01 <nmattia> dramforever: works like a charm though
07:44:32 <dramforever> you're welcome
08:05:06 <Welkin> this is a terrible haskell version of dijkstra on rosettacode http://rosettacode.org/wiki/Dijkstra%27s_algorithm#Haskell
08:05:21 <Welkin> it literallt says it is a direct translation from c++
08:05:57 <Welkin> I wrote my own version that is more idiomatic
08:06:10 <Welkin> just wondering if anyone has any other versions I can see
08:09:55 <pavonia> Heh, Dijkstra was one of the very first things I wrote when learning Haskell
08:17:51 * hackagebot yesod-auth-oauth2 0.2.0 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.2.0 (jsteiner)
08:18:38 <meditans> a question on the singletons library, and expecially how thing are defined in the singletons prelude: I get that I can mention 0 as a type, in fact ":k 0" returns "0 :: Nat", which is correct
08:19:14 <meditans> but then, I know there should be the type "SNat 0" and the inhabitant of this type (something like S0)
08:19:27 <meditans> and I cannot understand how to write those
08:20:18 <meditans> it's a Nat specific problem, because for bool, the equivalent is Sing 'True and STrue
08:21:20 <RedNifre> Hi. How do I split a list into a list of two element thingies (tuples or lists)? E.g. "abcdef" -> ["ab","cd","ef"] 
08:22:15 <pavonia> :t chunksOf -- RedNifre
08:22:16 <lambdabot> Int -> [e] -> [[e]]
08:22:28 <pavonia> from Data.List.Split
08:24:53 <RedNifre> thanks, that's perfect
08:31:07 <sigrlami> Trying to convert from JSVal to UTCTime gives an error  No instance for (FromJSVal DiffTime)
08:31:07 <sigrlami>           arising from a use of ‘GHCJS.Marshal.Internal.$gdmfromJSVal’
08:31:11 <sigrlami> how can I fix it?
08:31:36 <sigrlami> tried deriving, but couldn't derive because DiffTime is library data
08:32:50 <sigrlami> `deriving instance FromJSVal DiffTime` gives `Can't make a derived instance of ‘FromJSVal DiffTime’: The data constructors of ‘DiffTime’ are not all in scope so you cannot derive an instance for it
08:32:55 <sigrlami> which is fair I think
08:38:02 <c_wraith> it's actually an important restriction for protecting module boundaries. 
08:40:09 <sigrlami> yeah, I get it, I just want to write lots of boilerplate
08:40:15 <sigrlami> *don't want
08:40:45 <sigrlami> making conversion by hand, that's just one type
08:46:07 <nitrix> Is there a mathematical symbol for a proposition?
08:50:02 <nitrix> It's to put on a slide; I'm proposing the type of something where the thing is a more of a conceptual idea rather than a value, so I'd prefer not to use metasyntaxic variables.
08:50:45 <nitrix> I think I've seen the form  μ :: ... ?
08:51:37 <Cale> nitrix: Uhhh...
08:51:49 <Cale> "::" is Haskell syntax
08:53:11 <Cale> I don't think I've ever seen a double colon used elsewhere in mathematics.
08:53:16 <nitrix> Oh, it certainly will be a Haskell type.
08:53:39 <nitrix> Cale: It's the left hand of :: that I'm wonder what it could be.
08:53:46 <Cale> I'm not sure what you mean by "a proposition" -- which proposition?
08:53:57 <bitemyapp> shachaf: panning the entire book because of some attempts to draw connections that didn't hold up is pretty unfair
08:53:57 <Cale> Or are you saying that some P is a proposition
08:54:20 <bitemyapp> shachaf: I really don't appreciate you tearing into the work because you didn't like a single comparison.
08:55:11 <Boomerang> Is it possible to have ghc use prebuilt .hi files? For example I have a module A that depends on a module B, could I make something like this work: ghc A.hs B.hi   ?
08:55:16 <schell> morning all o/
08:55:47 <Cale> Boomerang: If B.hi and B.o are already built, ghc will use them
08:55:51 <hpc> Boomerang: you need both the .hi and .o
08:55:57 <nmattia> morning :)
08:56:06 <sigrlami> nitrix: what propositions you're talking about, it's usually `p` symbol and special characters for combinations
08:56:10 <Cale> B.hi doesn't contain the code for B though, it's just information about the interface of B
08:56:32 <schell> does anyone know how to get stack to spit out templatehaskell splices - i’m trying `stack build —fast —cabal-verbose` but it’s still hiding most of the output  
08:56:53 <Cale> Yeah, usually propositions are given letters like P, Q, R, and then there are logical connectives which act on them.
08:56:56 <Boomerang> So something like this: ghc A.hs B.hi B.o ? :)
08:57:05 <schell> i have —ddump-splices in my source file’s pragmas
08:57:37 <Cale> Boomerang: That... might work. I usually don't provide more than one file as explicit input to ghc. You can just let it find things.
08:57:46 <nitrix> Cale: sigrlami e.g. I'm looking at FRP right now and there's this typed presented `Event a → [(t, a)]` where an `Event a` is a list of values `a` varying over time `t`.
08:58:08 <hpc> you woudln't pass any sort of B to the ghc call
08:58:12 <hpc> since you're not building it
08:58:18 <Cale> Boomerang: If A imports B, and an up-to-date B.hi and B.o are available, then it will use them
08:58:45 <sigrlami> nitrix: general FRP? Look like an Arrow
08:59:17 <Cale> nitrix: That is a good example of an operation which you wouldn't want to provide in a sensible FRP library
08:59:23 <nitrix> Cale: sigrlami I'd like to refer to it with a variable, but cannot give it a meaningful name because it risk of conveying the bad message. It's supposed to reflect the message "you can make anything that type" kind of thing.
09:00:12 <nitrix> Cale: Obviously, but it isn't the question.
09:00:31 <sigrlami> nitrix: Action ?
09:00:48 <Cale> nitrix: I think I need more context to provide a suggestion for what you should write
09:01:18 <sigrlami> Comp (Computation)
09:01:30 <nitrix> Nevermind. I'll figure it out myself. Explaining what I'm trying to do will be just as long.
09:01:36 <Cale> nitrix: What exactly is the thing you want to refer to with a variable?
09:02:03 <Cale> You want to refer to that *type* with a variable, or some function of that type?
09:02:06 <nitrix> Cale: `Event a → [(t, a)]`, which is the type for an idea rather than an actual function/transformation.
09:02:13 <nitrix> Cale: No.
09:02:22 <Cale> Neither?
09:02:57 <nitrix> It's a mathematical proposition that an event can be seen as a flow of values varying over time.
09:03:14 <sigrlami> have you guys seen problem with stack, when it fails to unpack ghc.tar.gz? tried on several different linux distros and same story for lts5.15-6.5 relevant issue https://github.com/commercialhaskell/stack/issues/2170
09:03:26 <Cale> You mean, a semantic intepretation of Event a is [(t,a)]
09:03:50 <Cale> One thing which sometimes gets used for this kind of interpretation is a sort of blackboard bold brackets
09:03:55 <nitrix> Cale: Yes, the /-> isn't Haskell's ->, but I like that it still has Haskell's notation.
09:04:06 <nitrix> *→
09:04:12 <Cale> It's not rightly -> at all
09:04:16 <Cale> It's |-->
09:04:26 <nitrix> Yes.
09:04:32 <Cale> You're saying where the semantics is sending some type
09:04:45 <nitrix> I don't think I have that on my unicode substitution list :/
09:04:53 <Cale> ↦
09:05:38 <Cale> 〚Event a〛 = [(t,a)] is sort of confusing though, because list brackets
09:05:55 <mniip> my font doesn't even have U+301A/U+301B
09:06:01 <Cale> 〚Event a〛 = List (t,a) might be less confusing
09:06:08 <Cale> mniip: what OS?
09:06:16 <mniip> gnu/linux
09:06:45 <nitrix> I don't have those either.
09:06:56 <Cale> mniip: In that case, typically anything using freetype 2 will do font substitution for missing symbols, so the likelihood is that no font on your system has them
09:07:23 <Cale> (unless you're using a terminal that does its own font rendering)
09:07:55 <mniip> I don't have unifont installed I think
09:11:19 <Cale> one of the fonts on my system that has it is Symbola which I believe I got from http://users.teilar.gr/~g1951d/
09:11:37 <Cale> It's also in a bunch of CJK fonts
09:12:21 <Cale> also "OpenSymbol"
09:12:39 <int-e> `unidecode 〚〚
09:16:13 <int-e> I'm confused, why you'd use the CJK version of ⟦⟧
09:27:14 <xaviergmail> I just want to take a moment to praise LYAH's analogies: http://s3.amazonaws.com/lyah/listmonster.png
09:28:09 <maerwald> xaviergmail: http://learnyousomeerlang.com/static/img/worm.png :o
09:29:06 <xaviergmail> Haha! 
09:29:10 <xaviergmail> oh boy
09:36:03 <codedmart> What function am I looking for if I want to filter an array of arrays to keep the matches. Ex: `[[1,2,3,4],[1,2]]` -> `[[1,2], [1,2]]`
09:38:17 <Hafydd> codedmart: it isn't clear what you mean, but that could be "map . filter".
09:38:49 <Hafydd> > (map . filter) (<3) [[1,2,3,4],[1,2]]
09:38:50 <lambdabot>  [[1,2],[1,2]]
09:39:22 <Welkin> <3 should be an operator
09:39:23 <Welkin> :D
09:39:39 <hrnz>  su much love!
09:39:42 <hrnz> so*
09:39:59 <codedmart> Hafydd: Duh thanks!
09:40:31 <Welkin> > let (<3) = (\a b -> a*10 + b) in 3 <3 4
09:40:32 <lambdabot>  <hint>:1:6: Parse error in pattern: < 3
09:40:34 <Hafydd> codedmart: FTR, that would more naturally be written as: map (filter (<3)) [[1,2,3,4],[1,2]]
09:40:48 <Welkin> > let <3 = (\a b -> a*10 + b) in 3 <3 4
09:40:50 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
09:41:01 <Welkin> > let (<3) = (\a b -> a*10 + b) in 3 `<3` 4
09:41:03 <lambdabot>  <hint>:1:6: Parse error in pattern: < 3
09:41:04 <Welkin> hm
09:41:12 <Hafydd> <3 isn't a valid infix operator symbol.
09:41:54 <Welkin> > let (:<3) = (\a b -> a*10 + b) in 3 :<3 4
09:41:56 <lambdabot>  <hint>:1:6: Parse error in pattern: :< 3
09:42:05 <Welkin> o.o
09:42:14 <Welkin> > let (:<3:) = (\a b -> a*10 + b) in 3 :<3: 4
09:42:16 <lambdabot>  <hint>:1:10: parse error on input ‘)’
09:42:27 <Welkin> > let (:<:) = (\a b -> a*10 + b) in 3 :<: 4
09:42:28 <lambdabot>      Not in scope: data constructor ‘:<:’
09:42:28 <lambdabot>      Perhaps you meant ‘Data.Sequence.:<’ (imported from Data.Sequence)    No...
09:42:28 <lambdabot>      Perhaps you meant ‘Data.Sequence.:<’ (imported from Data.Sequence)
09:42:36 <Welkin> ...
09:42:46 <Hafydd> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
09:43:04 <maerwald> Welkin: you can pm lambdabot for testing
09:43:48 <jackhill> I'm not sure if that actually does what codemart wants though. What if the second list were [2,3] instead. codemart: would you then want [[2,3], [2,3]] ?
09:45:45 <Hafydd> > (map . filter) (<3) [[1,2,3,4],[1,2],[3,4]] -- This may also be good to keep in mind.
09:45:47 <lambdabot>  [[1,2],[1,2],[]]
09:46:14 <Hafydd> > (filter (not . null) . map . filter) (<3) [[1,2,3,4],[1,2],[3,4]] -- But this might remedy it.
09:46:15 <lambdabot>      Couldn't match expected type ‘[[Integer]] -> t’
09:46:15 <lambdabot>                  with actual type ‘[t0 a0]’
09:46:15 <lambdabot>      The function ‘filter (not . null) . map . filter’
09:46:18 <Hafydd> Whoops.
09:46:30 <Welkin> > let (❥) = (\a b -> a*10 + b) in 3 ❥ 4
09:46:32 <lambdabot>  34
09:46:36 <Welkin> >:D
09:46:39 <Welkin> take that
09:47:27 <Hafydd> > filter (not . null) . map (filter (<3)) $ [[1,2,3,4],[1,2],[3,4]]
09:47:28 <lambdabot>  [[1,2],[1,2]]
09:49:38 <hwkng> what does the NF in NFData stand for?
09:50:08 <Hafydd> Normal Form, I assume.
09:50:14 <Welkin> Cale: in your A-star package I see you are using Set as a priority queue with minView
09:50:42 <Welkin> I saw this done before as well, but it only works if all the nodes in the queue are unique
09:50:49 <Welkin> I suppose for a graph that is not a problem
09:51:07 <hwkng> Hafydd: thanks
09:51:08 <Welkin> I wonder when it would make sense to use the actual pqueue package instead of Set for a priority queue then
09:51:24 <hwkng> waht is the difference between "instance Foo Cat" and "instance Foo Cat where" ?
09:52:53 <Hafydd> That's much easier than working out what the NS in various Apple APIs stands for.
09:53:03 <Hafydd> (It stands for NextStep.)
09:53:46 <glguy> hwkng: The where means that method implementations follow
09:54:03 <glguy> without it the default implementation for all of the methods will be used
09:55:13 <hwkng> glguy: so what is the difference of (1) not having a "where" vs (2) "having a where but no implementation" ?
09:55:30 <glguy> none
09:55:45 <glguy> about 5 characters + whitespace
09:55:47 <hwkng> glguy: clarified; thanks!
09:56:23 <hwkng> glguy: so there 'where' in https://github.com/agentm/project-m36/blob/master/ProjectM36/Base.hs#L49 is redundant?
09:56:46 <Hafydd> hwkng: yes, there's no semantic difference.
09:56:51 <glguy> hwkng: That would follow from the previous comments, yes
09:57:32 <hwkng> Hafydd , glguy : yes, it does, but I wanted to double check as I found it confusing
09:57:35 <hwkng> thanks for clarifying :-)
10:04:29 <geekosaur> hwkng, I think the language standard requires "where" but ghc is lax about it when there's no implementation
10:05:30 <hwkng> geekosaur: looks like they must have already mergex in -XAllowImplicitWhereForInstance
10:06:08 <geekosaur> I did not check the standard, it might actually be part of h'2010 vs. h98
10:07:02 <glguy> From the report: class [scontext =>] tycls tyvar [where cdecls]
10:08:05 <glguy> and it's consistent across '98 and '10
10:08:10 * geekosaur is multitasking, work presentation (which doesn't actually need much of my attention because it's mostly for the programming team vs. the admin team, but)
10:08:23 <geekosaur> ok, then I'll claim habit for the "where"
10:14:58 <Hafydd> Haskell2010 makes "where" optional.
10:15:07 <Hafydd> ...for an empty body.
10:15:18 <glguy> It's optional in the Haskell 98 report, too
10:15:22 <Hafydd> I see.
10:15:28 <thimoteus> you can have a where with nothing after it?
10:15:33 <Hafydd> Yes.
10:15:36 <thimoteus> wow
10:15:40 <glguy> You can do that in general, not just in instances
10:16:00 <glguy> > let x = 10 where in x
10:16:01 <lambdabot>  10
10:16:08 <maerwald> I wonder why that is allowed.
10:16:12 <thimoteus> that's kind of hilarious
10:16:46 <Hafydd> It's algebraically pleasing for the empty declaration to have the same headers as a non-empty declaration.
10:21:21 <jle`> > let x = 10 where {} in x
10:21:22 <lambdabot>  10
10:21:36 <jle`> no reason to treat the empty declaration list as a special case :O
10:21:48 <jle`> if it wasn't allowed, that'd be even weirder/more ad-hoc :)
10:23:30 <lambdafan> I'm trying to model ship movement in space in terms of newtonian mechanics. Using this site as a guide http://blog.wolfire.com/2009/07/linear-algebra-for-game-developers-part-1/
10:24:57 <lambdafan> given a Scalar (representing speed), I think I would be multiplying it by a Vector3 to get Acceleration. What does that Vector3 I am multiplying the Speed by represent? I thought it would be a Direction vector but I am getting feedback saying I do not need a Direction vector.
10:26:20 <jle`> lambdafan: is this related to haskell? have you tried ##math ?
10:26:35 <lambdafan> jle': Well, I am implementing in Haskell
10:26:58 <lambdafan> jle': I always get my best responses here. Thought I would try here first
10:27:44 <lambdafan> jle': plus so much is going to be fudged. It's for a game.
10:27:54 * hackagebot mqtt-hs 1.0.0 - A MQTT client library.  https://hackage.haskell.org/package/mqtt-hs-1.0.0 (LukasBraun)
10:31:46 <geekosaur> lambdafan, your question seems a bit underspecified to me
10:33:20 <mizu_no_oto_work> lambdafan: I think games tend to work in discrete updates.  So you'd keep track of the spaceship's velocity and acceleration separately, and during an update, you'd have new_speed = old_speed + acceleration * duration_of_update
10:33:33 <geekosaur> yes
10:35:14 <geekosaur> I'm failing to put together how you'd go from a speed to an acceleration (delta speed over time) given a 3-vector, unless you are to reconstruct the acceleration from the points in the vector given the current speed at one endpoint. but that's not just multiplication 
10:35:38 <geekosaur> (it also seems like the wrong way to go about implementing game mechanics)
10:37:15 <lambdafan> geekosaur: I'm modeling acceleration as a vector, based on what this guy is saying http://blog.wolfire.com/2009/07/linear-algebra-for-game-developers-part-1/
10:37:51 <lambdafan> geekosaur: This is a new domain for me so my approach could be all wrong. I have not ruled that out
10:38:30 <leshow> i was wondering if someone could help me with a server im trying to write in haskell using Servant, I have a very small project on github and i've hit a little roadblock
10:38:36 <leshow> https://github.com/leshow/elm-tut/tree/master/app/server
10:38:58 <leshow> it's a very simple API, just get/patch/post on a list of 
10:39:03 <leshow> 'players'
10:40:06 <geekosaur> ok, I think I;m confusing things slightly becuase I'm trying to track too much at the same time. sorry
10:40:15 <leshow> https://github.com/leshow/elm-tut/blob/master/app/server/src/Lib.hs#L63
10:40:24 <leshow> this line is throwing an error during compilation
10:43:04 <dmj`> leshow: the type says a :<|> b :<|> c :<|> d, but you've only given a :<|> b :<|> c, updatePlayerById is commented out
10:43:12 <dmj`> leshow: can you paste the full error? 
10:43:14 <dmj`> @where paste
10:43:14 <lambdabot> Haskell pastebin: http://lpaste.net/
10:43:39 <leshow> dmj`: ok i just fixed that, ill post the remaining errors one sec
10:44:31 <leshow> http://lpaste.net/168671
10:44:38 <leshow> pushed the updated code to github
10:45:31 <dmj`> leshow: ah so, Handler a ~ ExceptT ServantErr IO a, and in a handler you the return type 'a' as (), when the type is expecting Player
10:45:46 <dmj`> in a handler you have*
10:46:42 <leshow> i dont follow really, what do you mean?
10:46:58 <leshow> like, it
10:47:08 <leshow> it's returning () instead of Player?
10:47:26 <buglebudabey> is there a fast way to load all of the modules in my project to stack's ghi
10:47:29 <buglebudabey> ghci*
10:48:31 <dmj`> leshow: so line 75, what is the return type of this function, "postPlayer db id player = liftIO $ insertPlayer db player"
10:48:45 <dmj`> the return type of 'insertPlayer' specifically
10:48:51 <leshow> oh i see, IO ()
10:49:47 <dmj`> leshow: so you can just change the type, or do another database get to return the user, or just return the user w/o a db call
10:50:21 <leshow> like just a 
10:50:23 <dmj`> liftIO (insertPlayer db player >> getPlayerById db id) 
10:50:34 <leshow> return player at the end of insertPlayer
10:50:42 <dmj`> or, liftIO (insertPlayer db player) >> pure player
10:50:55 <dmj`> I'd do the former
10:51:11 <leshow> what i said seems to compile. is there anything wrong with doing it that way?
10:51:15 <dmj`> I think that was your intention since you have 'id' as an argument that was being unused
10:51:50 <dmj`> leshow: well if it fails to insert you'd be treating it like it has inserted, that's why doing `getPlayerById db id` would ensure it's in there
10:52:02 <leshow> right
10:52:55 * hackagebot cloben 0.1.0.2 - Clone and benchmark Haskell cabal projects  https://hackage.haskell.org/package/cloben-0.1.0.2 (sgraf812)
10:52:56 <leshow> the (>>) operator, that just chains operations but forgets the previous value right?
10:54:02 <crough> there's also `Data.Functor.$>`, which lets you add a pure return value to something
10:54:03 <leshow>  liftIO (insertPlayer db player >> getPlayerById db id) -- this doesnt compile
10:54:48 <leshow> expected IO Player, actual type Handler Player
10:55:17 <crough> liftIO (insertPlayer db player) >> getPlayerById db id?
10:55:26 <crough> are insert and get different types?
10:55:50 <leshow> crough: yeah that one works
10:56:01 <dmj`> leshow: I assumed getPlayerById was in I/O
10:56:26 <leshow> insert returns IO (), findPlayer is IO (Maybe Player)
10:57:36 <cookie2> http://espedito.homepc.it/ onehost...)
10:57:42 <leshow> what about this? does tthis make more sense
10:57:48 <leshow> postPlayer db id player = maybe (throwE err404) return =<< liftIO (insertPlayer db player >> findPlayer db id)
10:58:02 <leshow> that way it returns a 404 if it fails to insert
10:58:10 <crough> does insertPlayer return failures?
10:58:40 <leshow> no, would it be better to return like IO (Maybe Player) from insert tooo?
10:59:07 <crough> I would probably do something like `IO (Maybe SomeErrorType)` if errors are expected
10:59:19 <crough> or `ExceptT SomeErrorType IO ()`
10:59:32 <leshow> im not sure how i'd know if the insert failed
10:59:40 <leshow> other than checking if the player is in there after an insert
11:00:00 <crough> If it's a db call, it's probably going to throw an exception and you'll get a 500
11:00:10 <leshow> it's sort of a mocked db
11:00:14 <crough> ahh got it
11:00:17 <leshow> it's just an in-memory data.map
11:00:30 <dmj`> leshow: there is a #servant channel as well
11:00:31 <crough> the mocked db should probably handle failure on insert tbh
11:01:14 <leshow> dmj`: thanks. i do have one more quesiotn thats not servant related
11:01:21 <leshow> getPmap (DB mvar) = elem <$> readMVar mvar
11:01:35 <leshow> haskell doesnt like this
11:01:37 <leshow> but i can do
11:01:43 <leshow> keys <$> readMVar mvar
11:02:04 <crough> @type elem
11:02:05 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
11:02:16 <leshow> thats cool
11:02:19 <leshow> @type keys
11:02:20 <lambdabot>     Not in scope: ‘keys’
11:02:20 <lambdabot>     Perhaps you meant one of these:
11:02:20 <lambdabot>       ‘Data.IntMap.keys’ (imported from Data.IntMap),
11:02:28 <leshow> @type Data.Map.keys
11:02:29 <crough> @type Data.Map.Strict.keys
11:02:29 <lambdabot> Data.Map.Map k a -> [k]
11:02:31 <lambdabot> Data.Map.Map k a -> [k]
11:02:40 <crough> very different types ;)
11:03:00 <leshow> maybe i meant
11:03:05 <leshow> @type Data.Map.elems
11:03:06 <lambdabot> Data.Map.Map k a -> [a]
11:03:09 <leshow> there we go
11:03:16 <crough> there we go! :)
11:03:32 <leshow> thanks guys
11:03:37 <crough> ofc!
11:03:58 <leshow> how long have you been writing haskell
11:04:06 <crough> since 2009
11:04:27 <leshow> do you consider yourself proficient at it, compared to other languages?
11:04:31 <crough> Yup
11:04:35 <crough> I do it professionally :)
11:04:38 <leshow> that helps
11:04:43 <crough> yeah
11:05:02 <leshow> i do very small things with it, like this little project, every few months or so, and i feel like it's taken a very long time to get to a beginner level
11:05:29 <leshow> like just figuring out what a monad was a month or so ago
11:05:36 <crough> yeah, that seems to be a common experience. don't worry though!
11:08:36 <LettuceThree> I have a Repa stencil (using Data.Array.Repa.Stencil.Dim2) over an unboxed double array and it's performing a *ton* of allocations and slowing the whole program down. How do I make it perform unboxed arithmetic only?
11:08:38 <Cale> When I started back around 2001-2002, it took me about 2 months to feel like I could do useful things with Haskell, and about a year to be "comfortable" for some definition of the term.
11:08:56 <slemonide> Is there any other way to pattern match maps from Data.Map without converting them to lists first?
11:09:01 <leshow> Cale: how often were you writing it?
11:09:25 <LettuceThree> slemonide: Maybe you want to make a pattern synonym
11:09:35 <LettuceThree> Or maybe you can get away with pattern guards
11:09:42 <LettuceThree> What's your use case?
11:10:00 <Cale> leshow: Well, mostly small projects here and there, but a little bit each week. I also had a full course load of mostly mathematics courses at the time :)
11:10:48 <leshow> can anyone here explain lift? specifically liftIO
11:11:05 <Cale> leshow: sure
11:11:06 <Welkin> I just started doing some of the exercises on hackerrank
11:11:10 <Welkin> I'm surprised they have haskell
11:11:12 <Welkin> it's kind of fun
11:11:16 <leshow> is it just changing to type from IO to like a regular monad type?
11:11:20 <Welkin> but the templates they give you are terrible
11:11:21 <Welkin> haha
11:11:29 <Welkin> everything is in a do block
11:11:37 <Cale> liftIO turns any IO action into an m action, for any m which is an instance of MonadIO
11:11:41 <Welkin> it looks like an imperative programmer tried to write in c using haskell
11:11:46 <Cale> :t liftIO
11:11:47 <lambdabot> MonadIO m => IO a -> m a
11:12:07 <Cale> It's the only method of the MonadIO type class, and the instances of the class say how to do that
11:12:26 <leshow> how would you know when you want to liftIO something to m though
11:12:43 <Cale> Well, when you're writing an m-action and you want to perform an IO action. :)
11:12:56 * hackagebot monad-logger-prefix 0.1.1 - Add prefixes to your monad-logger output  https://hackage.haskell.org/package/monad-logger-prefix-0.1.1 (parsonsmatt)
11:13:13 <slemonide> LettuceThree: I am trying to figure out how maps are made instances of a Functor typeclass.
11:13:38 <Welkin> Data.Map?
11:13:40 <LettuceThree> slemonide: You can look at the source for Data.Map via hackage.
11:13:40 <leshow> hm, ok. so ive got some function that returns IO Whatever and I want to do that action inside a function that returns some other monad?
11:13:52 <Welkin> Data.Map is implemented as a balanced binary tree
11:14:00 <LettuceThree> leshow: Only if that other Monad is a MonadIO
11:14:21 <leshow> an instance of MonadIO you mean?
11:14:21 <LettuceThree> You can't do it in an e.g. Maybe monad
11:14:24 <LettuceThree> Yes
11:14:32 <leshow> right, ok.
11:14:38 <Welkin> leshow: you use liftIO and lift a lot in yesod
11:14:40 <leshow> so Servant's Handler must be an instance of MonadIO
11:14:41 <Welkin> and other web frameworks
11:14:54 <Welkin> because you have something like Handler that is an instance of MonadIO
11:14:59 <leshow> :t lift
11:15:00 <Cale> leshow: For example, perhaps you're writing a parser using ParsecT s u IO, and you want to load an additional file to include its contents, based on what you'd parsed thus far
11:15:00 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:15:34 <Cale> leshow: you can liftIO the IO action which reads the file to turn it into a ParsecT s u IO action
11:15:59 <leshow> cool, ok. ill have to read the monadtransformer section of the haskell book lol
11:16:20 <Cale> A monad transformer is a type T which when applied to an arbitrary monad M gives a new monad T M
11:16:42 <Cale> such that there is this operation lift which turns an arbitrary M-action into a (T M)-action
11:17:20 <leshow> another thing, using stuff like MVars to lock/unlock access to some data structure. that doesn't itself make things run concurrently right? it just means that your data is now thread-safe?
11:17:46 <Cale> Well, MVars aren't likely to be so useful without concurrency
11:18:06 <Cale> If you're in a single-threaded program, and you either read from an empty MVar or write to a full one, then your program will just die.
11:18:16 <Cale> (It will be blocked forever, which will cause an exception)
11:18:52 <johnw> leshow: right, just using them doesn't make anything threaded
11:18:58 <leshow> yeah, ok
11:19:01 <Cale> But yeah
11:19:04 <johnw> leshow: even spawning threads doesn't make it threaded; you also need to link with -threaded
11:19:14 <johnw> or rather, that allows _concurrent_ threads
11:19:22 <leshow> yeah i have the -threaded option on this build
11:19:23 <Cale> threads are always concurrent
11:19:30 <Cale> That allows *parallel* threads
11:19:33 <johnw> oh, right
11:19:37 <johnw> _asynchronous_
11:19:42 <johnw> sorry, I knew that, slip of the mind
11:20:10 <Cale> (i.e. taking advantage of SMP parallelism)
11:22:25 <Cale> Even without -threaded, you should get pre-emptive multitasking in GHC.
11:23:44 <leshow> how might you do somehting like, run each request in it's own thread
11:24:11 <leshow> for the code i was working on earlier. i already have it locking/unlocking the data resource
11:24:50 <Cale> Well, you'd have a loop which gets a request (and blocks if none is available) and then when it gets one, it runs something like  forkIO (handleRequest req)
11:25:20 <johnw> better: use the async library instead of forkIO
11:25:30 <Cale> uhh
11:26:12 <Cale> I don't really regard async as a replacement for forkIO
11:26:15 <leshow> oh nvm apparently warp is already running the responses concurrently
11:26:25 <johnw> Cale: why not?
11:27:08 <Welkin> leshow: lol, of course
11:27:10 <Welkin> it's a web servr
11:27:14 <Cale> async is for when you want to start actions to run asynchronously that each have a result, and you're later going to want to wait for those results to be available
11:27:29 <johnw> you can ignore the result of course
11:27:35 <johnw> and just gain the benefit of how it manages exception propagation
11:28:26 <Cale> If you ignore the result, what tends to happen is your thread gets killed by an exception
11:28:41 <johnw> why?
11:29:32 <EvanR> if you want to fork a thread to get a result, then async is nice
11:29:34 <Cale> Because there's an MVar that when it gets GCed, an exception will be thrown
11:29:49 <leshow> Welkin: i thought you had to explicitly create the threads yourself
11:29:58 <leshow> Welkin: i had no idea servant was doing htat all for you
11:29:59 <Cale> and the async library's exception handling will catch that and clean up the thread it created
11:30:05 <EvanR> but if its something more exotic async may or may not work
11:30:37 <EvanR> and creating an MVar to just get a result from one forkIO is overkill
11:30:37 <Cale> If you don't want to listen for the result, you're going to get some weird janky prefix of the effects that you async'ed
11:31:07 <johnw> async creates its own TMVar
11:31:28 <johnw> I don't see why GC'ing it would be a problem after its been written to; and the thread itself will keep it from being GC'd before it is
11:31:28 <Cale> At least, I've seen that happen to people who were using the library that way
11:31:37 <EvanR> yeah async does it all for you and more, its a pain to set this up yourself for one thing
11:32:15 <johnw> anyway, I don't recall this ever being an issue
11:32:42 <EvanR> if the thread puts into the mvar and ends normally, and nobody checks it, then nothing special happens
11:32:56 <Cale> I forget exactly what the steps were, it was a little convoluted, but one thread would get a "blocked indefinitely" exception and it would ultimately result in the async computation being terminated early.
11:33:22 <johnw> maybe they exited a withAsync block too early?
11:33:52 <django_> hey all
11:34:25 <Cale> johnw: I think they were using async and not wait
11:34:35 <quchen> Santo's thesis is really great, I wonder how I missed it for so long! It's an excellent introduction into Haskell code optimizations.
11:34:45 <quchen> (Or Core, more accurately)
11:35:00 <johnw> Cale: I'd be interested to see this happen in an example
11:35:44 <EvanR> yeah it sounds kind of wrong to use async as a forkIO replacement, in that you fork a thread and forget about it
11:37:56 <johnw> not _entirely_ forget about it
11:38:04 <johnw> you're forgetting about the result value, but not about exception events
11:38:22 <johnw> as there's two possible results that can be produced by a thread
11:38:37 <EvanR> yeah you can forget about exceptions if you want with forkIO
11:38:39 <johnw> and getting proper delivery of the exceptional result is far trickier to manage
11:38:50 <johnw> right, if you care about neither, forkIO is simplest
11:39:08 <EvanR> non-exception results may not be well defined for a thread
11:39:37 <EvanR> what if its job is to heat up the CPU D:
11:40:51 <Cale> I'm more convinced that it would be okay to not wait for the result if you stay inside the withAsync. I actually can't get it to happen now with async in a small test case.
11:41:00 <Cale> But I'm not sure I'd trust that it doesn't happen :P
11:43:13 <EvanR> with IO handlers you probably do want exceptions though
11:43:15 <Cale> But yeah, in a server-type situation, you often also don't care in the main thread if one of your handlers dies with an exception -- you typically won't want to interrupt handling other new clients for that.
11:43:40 <EvanR> not necessarily to kill the whole server but to do something at all
11:44:07 <Cale> Well, you can always put the responsibility on the handler to do whatever that thing is.
11:47:38 <EvanR> in the special case of a server i guess its kind the behavior of a single app multiplied
11:48:03 <EvanR> so you could use async to handle exceptions for the subprogram doing one request
11:48:43 <EvanR> then your handler will crash as intended instead of having to deal with its subthreads exceptions manually
11:50:33 <EvanR> example, get a request, then validate the input, then async execute 3 IO bound actions to get information, then wait for all to finish, do the transactional effect, and put together the response
11:58:49 <leshow> can you do stuff like
11:59:16 <leshow> stack exec whatever +RTS -N2
11:59:34 <leshow> how do you run the binary created from stack build
11:59:35 <leshow> without stack
12:03:09 <geekosaur> leshow, you'd need to do that as: stack exec --RTS whatever +RTS -N2
12:03:21 <geekosaur> the --RTS stops stack itself from eating the +RTS
12:04:06 <geekosaur> otherwise, it depends; if you "stack install" then the program should be in ~/.local/bin which you can add to $PATH
12:04:19 <geekosaur> (I don't know equivalent dir on Windows offhand)
12:05:28 <Phyx-> probably %appdata%/stack something
12:06:49 <anilanar> is stack considered to be the best practice for managing haskell projects?
12:07:30 <anilanar> (and compiler and other tools ofc)
12:07:50 <glguy> There isn't much agreement on that
12:09:21 <leshow> is there an easy way to get stack to log stuff?
12:12:16 <flux> from exceptions, yes. check out the Printexc module
12:12:41 <mgsloan> leshow: -v ? --cabal-verbose may also be helpful, for even more info
12:14:57 <flux> oops, wrong channel :-)
12:21:31 <coda> hate this log 
12:21:41 <coda> let`s talk bout somethin
12:32:58 * hackagebot highlighting-kate 0.6.2.1 - Syntax highlighting  https://hackage.haskell.org/package/highlighting-kate-0.6.2.1 (JohnMacFarlane)
12:54:29 <leshow> updatePlayerById db id player = maybe (throwE err500) return =<< liftIO (updatePlayer db id player >> findPlayer db id)
12:54:38 <leshow> can someone explain what is getting passed to maybe here
12:54:47 <leshow> :t maybe
12:54:49 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:55:05 <leshow> i get that (throwE err500) is the default value
12:55:13 <anilanar> i wonder, does immutability take quite a toll on list operations? does a haskell dev ever feel like implementing parts of code in C (assuming impure code is difficult to write in haskell)
12:55:57 <Jinxit> there are mutable things in haskell
12:56:32 <geekosaur> the result of the findPlayer function, via =<< so it's getting the Maybe whatever from the m (Maybe whatever_
12:57:11 <leshow> geekosaur: i dont understand which part is the (a ->b) and Maybe a
12:57:18 <leshow> that's getting passed to maybe
12:57:22 <srhb> anilanar: impure is difficult, mutable isn't. :) But sometimes we do use C libraries via the FFI, which is also easy.
12:57:28 <srhb> leshow: return is the (a -> b)
12:57:41 <srhb> throwE err500 is the b
12:57:56 <leshow> if i rewrite it like
12:58:01 <leshow> maybe (throwE err500) (return) (=<< liftIO (updatePlayer db id player >> findPlayer db id))
12:58:05 <leshow> it will fail to compile
12:58:06 <geekosaur> and the Maybe value is coming from the findPlayer via liftIO and =<<
12:58:22 <srhb> leshow:That's a very funky operator section.
12:58:29 <EvanR> anilanar: it helps to image most list operations as happening on one node at a time, lazily. and old nodes get collected promptyl
12:58:40 <EvanR> allocating nodes is not as slow as it would be in eg C
12:58:44 <geekosaur> leshow, (\x -> maybe (throwE err500) (return) x) =<< liftIO (updatePlayer db id player >> findPlayer db id))
12:58:47 <srhb> leshow: =<< ... is not an argument to maybe. 
12:59:05 <leshow> oh i see
12:59:09 <srhb> leshow: Rather, both sides of =<< are arguments to _it_
12:59:26 <EvanR> anilanar: at the same time, mutable data cells in GHC need to have extra GC book keeping around to be able to collect, which adds some overhead
13:00:05 <EvanR> so if youre trying to improve performance by writing something with a lot of mutation, it might make more sense to use the FFI 
13:00:07 <geekosaur> actually I forgot to edit away the final ) on that...
13:01:05 <leshow> it's ok i understand
13:01:07 <leshow> thanks
13:01:25 <EvanR> anilanar: in any case, an important skill to have is to ignore performance concerns unless you have evidence or reliable insight that its going to be your biggest problem
13:01:41 <EvanR> as a good case study on this, look at ruby on rails
13:01:46 <leshow> x is the result of  whatever liftIO is right?
13:02:01 <anilanar> EvanR: thanks, that was informative
13:02:03 <leshow> :t (=<<)
13:02:04 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:02:48 <geekosaur> if you've seen (>>=), that is the same thing with the arguments swapped
13:02:52 <geekosaur> no other difference
13:03:01 <leshow> :t (>>=)
13:03:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:03:09 <leshow> oh right
13:03:59 <leshow> if i sit down and look at haskell, and really focus, i can understand a bit whats going on. but i feel like i could never sit down and just write something like this on my own
13:04:17 <srhb> leshow: It gets easier. Then everything gets harder. :-P
13:04:23 <leshow> lol
13:04:26 <dysfun> it'll just sort of happen to you
13:04:46 <geekosaur> eventually you will, if you keep working with it
13:05:44 <geekosaur> (although, just like any skill that isn't "muscle memory", if you go away for a few months and then come back you'll find that youy've started to forget parts of it...)
13:06:34 <leshow> yeah i get that a lot, i dont write haskell for my day job or anything so it's just whenever i feel like playing with it
13:07:06 <leshow> it does help that since doing haskell i see a lot of it's influences in other languages though
13:07:11 <leshow> like rust has ADTs
13:07:19 <leshow> and Option/Result
13:08:00 <Aruro> leshow: haskell 98 is pretty easy, after that they started to wonder
13:08:18 <Aruro> leshow: its more research language, not finalized yet
13:08:24 <EvanR> ill have what theyre having
13:08:42 <leshow> it's been in development for like 20 years lol, of course it's 'finalized'
13:08:54 <leshow> they just add new features like any other language
13:08:59 <Aruro> leshow: not :) just read how much new stuff got ghc 8
13:09:03 <cobreadmonster> leshow: There's a difference.
13:09:16 <EvanR> language evolves
13:09:17 <leshow> applicativedo is pretty cool
13:09:19 <Aruro> leshow: they add too big features vitrually killing old language
13:09:24 <cobreadmonster> There's like the addition the magnitude of C++ templates every other minor release.
13:09:52 <cobreadmonster> geekosaur: Does the use of dependent types make compilation semidecidable?
13:10:19 <Aruro> leshow: good language does not have to have features, it has to have libs
13:10:43 <Aruro> leshow: ideal language
13:11:01 <Aruro> leshow: same as u are not inventing new features in english grammar every day
13:11:04 <leshow> when you use mvar, does it actually pass whatever you put in there in it's entirety in a channel
13:11:23 <leshow> or does it just control access, like a mutex
13:12:06 <mauke> what's the difference?
13:12:20 * geekosaur no clue, sorry... aware of dependent types, not especially clear on how they affect things
13:12:35 <leshow> in one case you're copying the data structure every time you takeMVar
13:12:44 <leshow> in the other it doesnt copy, it just lock/unlocks
13:12:44 <srhb> leshow: Afaik it's more or less lock-free in its implementation in GHC, but not sure.
13:13:00 * hackagebot cloben 0.1.0.3 - Clone and benchmark Haskell cabal projects  https://hackage.haskell.org/package/cloben-0.1.0.3 (sgraf812)
13:13:02 <srhb> leshow: You could implement it with a mutex as well.
13:13:11 <mauke> leshow: copying isn't really a thing in haskell
13:13:39 <leshow> so it stays at the same memory location?
13:13:56 <geekosaur> one of the nice things about purity is that mostly the runtime "copies" pointers around, not the data
13:14:16 <geekosaur> which is why we keep the mutability carefully locked away
13:14:40 <mauke> leshow: things usually don't stay at the same memory location
13:14:42 <mauke> because GC
13:38:27 <schell> is there a flag or anything i can use to get the line number where my program hit undefined?
13:39:31 <glguy> schell: GHC 8 has "callstack" support and will report that kind of information
13:39:43 <schell> mmm - that will be nice
13:42:44 <glguy> Before that you can use the GHCi debugger with the -fbreak-on-error flag to help
13:43:08 <schell> oh, right, that’s a good idea
14:19:38 <vivace> hi, I am pretty new to haskell. Trying to install accelerate-cuda and running into many issues
14:20:15 <lyxia> schell: this callstack stuff already exists as a library for GHC <8: located-base.
14:20:42 <schell> lyxia: interesting, thanks
14:23:53 <hwkng> anyone know what the classical papers / theoretical work behind visicalc/spreadsheets/excel are?
14:26:31 <fishythefish> hwkng: they have classical papers behind them?
14:28:02 * hackagebot publicsuffix 0.20160701 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20160701 (wereHamster)
14:29:48 <hwkng> fishythefish: I suspect there were papers written on them back in the day
14:30:08 <fishythefish> Haskell-related?
14:30:46 <fishythefish> I mean, yeah, maybe there are papers on the data structures or something - this just seems like an odd place to ask
14:35:19 <hwkng> fishythefish: excel at it's core, ist one giant functional reactive program
14:35:34 <hwkng> fishythefish: which is one of the core ways ot do gui programming in any functional language
14:35:48 <johnw> that seems like a fairly optimistic statement
14:36:02 <johnw> given that FRP is still rarely used, and I doubt Excel was ever written using a functional language
14:37:22 <hwkng> johnw: reflex, reactive-bananas, conal's papers all seem pretty popular
14:38:04 <Cale> Excel would probably be a lot easier to write as a functional reactive program, but it's probably a hideous imperative one.
14:38:12 <fishythefish> hwkng: I've seen articles describing Excel's cell-oriented programming as a cousin of FRP, but not quite the same thing
14:38:21 <fishythefish> In any case, don't those applications all predate FRP?
14:38:26 <geekosaur> yes
14:38:30 <Cale> and yeah
14:38:48 <Cale> FRP is a lot newer, and only really started getting practical in the last few years
14:39:05 <geekosaur> and while SPJ has written about the idea of spreadsheets being a form of functional programming, I don't think they've ever been treated as such formally
14:39:34 <geekosaur> (aside from relatively recent musings re löb)
14:39:51 <fishythefish> So you might find a post hoc analysis of "FRP" in Excel, but nothing I'd call a classical paper
14:41:11 <nitrix> pattern SDL_AUDIO_S8 :: AudioFormat
14:41:20 <nitrix> Is this normal this fails on GHC < 8
14:41:21 <EvanR> im not sure how i feel about FRP = excel
14:41:29 <EvanR> it seems totally wrong somehow
14:41:54 <koz_> EvanR: As the Typeclassopedia mentions, any analogy is a starting point, not a definition.
14:42:00 <koz_> Maybe that's why it seems wrong.
14:42:28 <EvanR> well theres (flawed) analogies and then theres presentations where the person is like "FPR. It's just excel!"
14:42:46 <maerwald> let's hype it and make random analogies?
14:43:10 <koz_> maerwald: FRP. It's just like chocolate cake!
14:43:20 <EvanR> i guess im now used to this sort of statement being worth a lot more... like "Categories. it's just a typed monoid!"
14:43:23 <maerwald> make perfect sense :D
14:43:50 <geekosaur> I wouldn't say totally wrong. I'd say there is a conceptual similarity at some level
14:43:53 <koz_> EvanR: Comparing categories to typed monoids is a lot more meaningful than comparing FRP to Excel.
14:44:31 <EvanR> i feel like FRP needs a notion of animation
14:44:37 <EvanR> excel has none
14:44:40 <geekosaur> and that it's not "by design", just somewhat similar situations leading to somewhat similar answers
14:44:43 <Cale> The issue with this analogy is that Excel doesn't have any sort of separation between Behaviour and Event.
14:44:48 <geekosaur> from different directions
14:45:34 <Cale> and Excel cells have their definitions updated, so really, they're some more subtle kind of widget
14:45:49 <EvanR> FRP was inspired by (non-interactive) functional animations
14:53:29 <Cale> If you were to implement Excel using an FRP system, you'd have at least two Dynamics associated with every cell.
14:53:29 <EvanR> s/an FRP system/Cale and ryan's system/
14:53:29 <Cale> Well, no, just about any
14:53:30 <EvanR> which other has "Dynamic" ?
14:53:30 <Cale> anything that's close enough to Conal's idea to be worth referring to as FRP
14:53:30 <Cale> Pretty much anything which has Event and Behaviour can have Dynamic
14:53:30 <EvanR> not sure about that
14:53:30 <Cale> A Dynamic is a pair of an Event and a Behaviour with the contractual guarantee that the Behaviour changes only when the Event fires.
14:53:30 <EvanR> we need a agreed a glossary of what Event and Behavior are
14:53:30 <quxbam> What's the state of ghcjs?  The repo seems a bit dead...
14:53:31 <Cale> quxbam: I don't know what you're looking at, luite's been hard at work the last long while!
14:53:31 <Cale> It's being updated to GHC 8.0.1, which is almost(?) done
14:53:31 <quxbam> Well, I glanced at https://github.com/ghcjs/ghcjs/graphs/contributors
14:53:31 <maerwald> quxbam: last commit was 6 days ago
14:53:31 <Cale> "Contributions to master"
14:53:31 <Cale> last commit was less than 6 days ago
14:53:31 <Cale> Just wasn't on master
14:53:32 <quxbam> Ahh
14:53:32 <maerwald> 6 days without commits is clearly dead in the OSS world!
14:53:32 <geekosaur> I'd expect the 8.0.1 work to be on a branch currently
14:53:32 <quxbam> That's good to hear
14:53:32 <johnw> abandonware!
14:53:33 <maerwald> hamishmack is a beast, how does he do so many commits
14:53:33 <maerwald> and not just on that project
14:53:33 <Cale> https://github.com/ghcjs/ghcjs/commit/35a438302dafe7af9fb0e5956855f5578db0be10 -- June 29 :D
14:53:33 <maerwald> Cale: you almost made my browser crash there
14:53:33 <Cale> hahahaha
14:53:52 <Cale> ^^ lol what
14:54:12 <fr33domlover> Cale, look what you did
14:54:14 <fr33domlover> lol
14:54:21 * EvanR watches the internet collapse around us
14:54:29 <fr33domlover> now an earthquake should start
14:54:32 <geekosaur> goodness that's a large commit >.>
14:54:34 * fr33domlover hides
14:55:07 <geekosaur> (meanwhile 1400+ people load that and github melts)
14:57:38 <koz_> geekosaur: That'd be an interesting outcome.
15:15:23 <vivace> :quit
15:21:53 <lambdafan> give a V3, I am allowed to add a Scalar to that value. Is this an example of an operation that makes no sense but the type system allows it anyway?
15:22:17 <lambdafan> given a Vector3, I mean
15:22:51 <johnw> so, what does adding the scalar end up doing?
15:23:29 <lambdafan> johnw, say the Vector3 has values 0,0,0/ Adding 5 to it gives a new vector of values 5,5,5
15:23:45 <johnw> so, it's promoting the scalar to a vector of scalars
15:23:53 <johnw> i don't see how that "makes no sense"?
15:24:33 <EvanR> 5 is being interpreted as [5,5,5]
15:24:35 <lambdafan> johnw, I've always been told that you can't add a vector to a scalar. Even though this operation seems to be what I want. I wanted to make sure I was not doing something nonsensical.
15:25:15 <lambdafan> EvanR: Okay that makes sense now
15:25:56 <EvanR> number literals are polymorphic, they can do many things
15:26:14 <EvanR> :t 5
15:26:15 <lambdabot> Num a => a
15:27:02 <EvanR> for a square matrix though i would like 5 to be 5 times identity matrix, instead of a matrix of 5s
15:33:07 <reinh> Num instances often lie :p
15:33:42 <EvanR> Trust No Num
15:34:19 <Zemyla> Huh, I just realized that an ArrowChoice-based parser is just as powerful as a monadic parser, while still being more analyzable statically.
15:35:25 <reinh> I wish we made more use of slightly finer grained algebraic typeclasses
15:35:52 <reinh> at least there are packages which implement them
15:36:21 <parsnipM_> hmm, do folks discuss projecteuler here? i'm looking at https://projecteuler.net/problem=23, and i'm thinking i should use what i learned in problem 10, regarding summing the primes under 2,000,000. 
15:38:06 <parsnipM_> JFP-sieve.pdf describes in haskell to use a lookup table on next cross-out would be a lookup for elements like (6, [2,3]), so after excluding 6, it would sign up the next cancellations as concatenating with (8, ++[2]) and (9, ++[3]), etc
15:38:56 <parsnipM_> so i wonder if the solution for finding sums of abundant numbers should have a similar mechanism. 
15:39:29 <parsnipM_> except at first, the entries where the sums come from are sort of a 2-dimensional array now, in some sense. 
15:41:28 <parsnipM_> for discussion sake, i have `filter isAbundant [2..30] ==> [12,18,20,24,30]`
15:43:09 <parsnipM_> so i want to remove from [1..28123] all sums of abundant numbers, 24, 30, ...
15:44:11 <parsnipM_> so if i follow the primes approach, i would do something like make a lookup table with elements like [(24,[(12,12)]), ...]
15:44:43 <parsnipM_> i guess i should consider what an update would look like, and then reassess what structure to use. 
15:51:22 <sleblanc> I would like suggestions on how to make the function withFocused' look nicer in the following excerpt: http://lpaste.net/8640581683873054720
15:51:56 <glguy> sequence $ fmap f w   is   traverse f w
15:52:34 <koz_> OK, I'm getting weird as hell behaviour right now.
15:52:50 <koz_> Like, library calls having different behaviour with the same operations...
15:53:37 <sleblanc> glguy, thank you!
15:54:33 <glguy> do { w <- getFocused; traverse f w } is probably where the improvement will end
15:54:43 <koz_> Like, I literally have no explanation for how this could be happening. I even fired up GHCi, got the representations of the input in the program with 'show', and the result is exactly what I expect.
15:54:48 <koz_> But in the program, it's not...
15:56:13 <sleblanc> glguy, or (getFocused >>=) . traverse  -- if you are a fan of point-free
15:56:25 <glguy> No, that's terrible
15:57:22 <glguy> If you're running short on points, we have a free clinic where you can get more. No questions asked
15:57:33 <sleblanc> ;-)
15:57:49 <geekosaur> koz_, when comparing ghci to ghc, first thing to do is :seti -XNoExtendedDefaultRules
15:58:01 <koz_> That is *extremely* point-free. geekosaur: Thanks - will try!
15:58:12 <maerwald> it's point-less.
15:58:52 <koz_> geekosaur: I still get the same issue.
15:59:05 <koz_> In GHCi, I get the right behaviour - outside of it, I get the wrong behaviour...
15:59:16 <EvanR> where does the name "point free" come from ?
15:59:31 <maerwald> EvanR: from "point less" of course
15:59:33 <maerwald> xD
15:59:35 <geekosaur> second thing, if it's IO and might have threads involved, make sure you're comparing ghc -threaded (because ghci is always threaded) and beware that ghci generally does not run stuff in the program's main thread and will have trouble with things that only work on the main thread (like, oh, initializing OS X's GUI(
15:59:35 <koz_> EvanR: https://wiki.haskell.org/Pointfree#But_pointfree_has_more_points.21
15:59:44 <koz_> geekosaur: It's not IO and had no threads.
15:59:50 <geekosaur> (and opengl)
15:59:55 <koz_> Nor openGL.
15:59:58 <geekosaur> then I think we'd have to see more
16:00:00 <geekosaur> @paste
16:00:00 <lambdabot> Haskell pastebin: http://lpaste.net/
16:00:15 <koz_> geekosaur: I'd have to paste a veritable shittonne or it won't make sense.
16:00:26 <koz_> I could just give my entire project in a repo I guess...
16:00:39 <koz_> Let me just try something else real fast.
16:01:34 <koz_> Nope, that doesn't help, still the same.
16:01:49 <koz_> geekosaur: I can upload the whole thing to a repo and explain where it goes wrong, but that's a lotta digging.
16:02:17 <geekosaur> I think you might have t, if you can't construct a minimal example
16:02:40 <geekosaur> otoh trying to construct that example might e.g. reveal some unexpected type inference
16:02:48 <koz_> geekosaur: The thing is, I'm not even sure what's causing this behaviour as such. It's in pure code, and I literally get one set of behaviour inside the program and another outside of it.
16:03:08 <koz_> If I try to construct it directly (as I just did with GHCi), it behaves as it should.
16:03:19 <koz_> So I honestly don't even know *how* such an example could be constructed.
16:03:40 <geekosaur> and foldable/traversable gave ghc a lot of type inference rope to hang unwitting programmers with
16:04:51 <koz_> geekosaur: Near as I can tell, types are inferred correctly - I get a Nothing where I expect a Just Bool.
16:04:57 <koz_> (well, Just True in this particular case)
16:06:02 <koz_> The function in question takes two non-polymorphic, non-Maybe types as arguments.
16:06:17 <koz_> I can't imagine this is a type inference issue.
16:07:53 <geekosaur> depends on what it's doing exactly
16:08:07 <koz_> geekosaur: OK, I'll upload and explain how to reproduce.
16:08:19 <hexagoxel> the first thing i'd question is your method of observing any weird behaviour :p
16:08:25 <geekosaur> if you really think it's a ghc issue --- are you building with optimization? ghci does not optimize, ghc -O0 would be equivalent
16:08:45 <koz_> geekosaur: Let me check.
16:09:00 <koz_> Yes, -O2. Let me change that.
16:09:16 <hexagoxel> but maybe that is affected by me running into a bug in my toolchain where the executable was not linked, but everything else was built just today. had me for a couple minutes.
16:09:27 <koz_> Without optimization, same behaviour.
16:10:49 <hexagoxel> do some change that _must_ change behaviour, for sanity.
16:11:55 <koz_> hexagoxel: I did - adding the show-dumps.
16:24:38 <sam__> Hey I'm trying to use the ad package and was curious if anybody knew a nice tensor/linear algebra library which is compatible with it?
16:25:10 <sam__> I'm using Data.Vector right now (Unboxed doesn't work as far as I've tried), but I'm having to build everything from the ground up
16:28:05 * hackagebot simple-tar 0.5 - Simple, pure, file-system-free reading of tar files  https://hackage.haskell.org/package/simple-tar-0.5 (AdamWick)
16:57:37 <koz_> geekosaur: https://github.com/kozross/evolog <-- this is the code, with reproduction instructions for my weird bug.
17:04:03 <sean_1> whois gigglypuff
17:23:27 <geekosaur> koz_, did you mean "cabal install --only-dependencies"?
17:24:07 <geekosaur> although it looks like it wants ghc8? I am still on 7.10.3 and was not planning to upgrade until 8.0.2
17:28:06 <koz_> geekosaur: Yeah, I did mean that. It's OK - I'll figure it out on my own somehow.
17:28:18 <koz_> I think I've found a reproducible case though!
17:28:23 <koz_> I'll try and get that up.
17:29:09 <davean> geekosaur: is there some bug thats critical to you?
17:32:04 <geekosaur> davean, no, just general sysadmin paranoia, never run the first major release >.>
17:32:23 <c_wraith> the foldl' bug is pretty silly, though.
17:32:44 <c_wraith> ...  It's being treated as a bug, right?  Not new intended behavior?
17:33:04 <geekosaur> (.0 for most things, .1 for ghc, and for weird reasons .2 for SuSE)
17:33:33 <_xor> Hey guys, what's the best tutorial to learn Haskell?  I've been coding for quite a long time and have plenty of experience, so I prefer literature/tutorials that are dense and compact, as opposed to having a bunch of fluff.
17:33:38 <Welkin> lol geekosaur 
17:33:45 <Welkin> I never upgrade anything right away
17:33:46 <_xor> I know there was a tutorial called something like Haskell for C programmers.
17:33:54 <Welkin> I usually lag one or two versions behind
17:34:00 <AzureStigma>  i thought with haskell the transform was from a <- b to b to something that would roughly be b.whatever(function (a) ...)? not let a = b()
17:34:05 <Welkin> _xor: sounds ike a bad tutorial
17:34:25 <_xor> Welkin: Well, that's why I'm asking here :) I don't know if it's a good tutorial or not.
17:34:26 <geekosaur> (SuSE used to do this thing where they released their major updates in a .2, had a .3 if needed for debugging, then the next .0 was well tested and usually rock solid)
17:34:35 <c_wraith> Welkin: I vaguely recall it.  It wasn't terrible, but it wasn't particularly good either.
17:34:40 <Welkin> @where learnhaskell -- _xor 
17:34:40 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:34:48 <Welkin> that's the best place to start
17:35:26 <Welkin> also, when you are ready for it, read the typeclassopedia for Functor, Applicative, Monad, Monoid
17:36:10 <maerwald> is the cis course still correct wrt latest GHC and base changes?
17:36:11 <_xor> Welkin: Noting it all down, thanks!
17:36:17 <maerwald> probably has some outdated info
17:36:21 <c_wraith> _xor: I was in your position back in 2008.  Haskell is...  different.  Really actually different.  And it's in a way that is hard to make people like 2008 me believe actually matters. :)
17:36:29 <Welkin> _xor: of ocurse, this channel or #haskell-beginners in a good place to ask questions
17:36:46 <AzureStigma> haskell makes me hard 
17:37:05 <_xor> Welkin: My main workstation is a multi-mon Windows 10 machine, but I have a MacBook as well as several FreeBSD/Linux machines.  Is GHC the same across all of them, or should I use one over the other?
17:37:07 <Welkin> _xor: just don't try to approach haskell like it is an imperative language and all will be good
17:37:15 <_xor> Welkin: I know not all platforms are fully consistent.
17:37:19 <Welkin> I run ghc on linux and mac
17:37:25 <Welkin> you can run it on windows
17:37:29 <koz_> geekosaur: Seems like I was wrong - that doesn't reproduce the bug despite having *exactly the same data*.
17:37:57 <_xor> Welkin: Yeah, I mean I've perused Haskell before. I do like the terse syntax and I've written in a functional style before.
17:38:09 <_xor> Welkin: It's going to be a bit to wrap my head around I'm sure, but I don't think it'll be a problem with enough effort :)
17:38:23 <AzureStigma> macs are expensive :(
17:38:36 <c_wraith> _xor: even if you're completely comfortable with immutability and first-class functions...  That's not the hard part.  The hard part is the immense abstraction capacity. :)
17:38:49 --- mode: ChanServ set +o shachaf
17:39:51 <_xor> c_wraith: I'm looking forward to it :) I mean most of my time is still spent in JS/Java/Swift, but I'd like to mess around with Haskell in my spare time.
17:39:55 <c_wraith> _xor: most of that follows directly from the features of the type system.  It turns out that understanding the type system is the most important step in learning the language.  Imagine that! :)
17:40:15 <_xor> c_wraith: Lol, but of course :)
17:40:19 <Welkin> haha
17:40:26 <Welkin> yes, the type system is half the language
17:40:37 <Welkin> there was someone in here a few days ago who wanted to ignore it
17:40:41 <_xor> Guys, pls, stop. You're reminding me of my pain.  JavaScript :(
17:40:43 <Welkin> and it bit him in the ass later that day
17:40:46 <Welkin> he was lost
17:41:01 <_xor> Actually, I dislike JS from an academic stand-point, but it's pretty massive and practical for projects.
17:41:10 <_xor> I mean the ecosystem is massive.
17:41:39 --- mode: shachaf set +b $a:AzureStigma
17:41:40 <c_wraith> ES6 is providing a better lambda syntax, right?  That's my biggest complaint, other than the implicit type conversions..
17:41:45 --- mode: shachaf set -o shachaf
17:41:52 <Welkin> ?
17:41:54 <_xor> c_wraith: Better lambda syntax?
17:42:11 <_xor> c_wraith: Well, the big thing for me is ES7 async/await (very similiar to what's in C#)
17:42:15 <c_wraith> instead of function(foo, bar) { ...  }
17:42:20 <_xor> Oh, fat arrow.
17:42:25 <_xor> Yeah. I use those now.
17:42:29 <c_wraith> yeah, that's way better.
17:42:33 <_xor> It's certainly more consistent across languages.
17:43:07 <c_wraith> Funny thing - if you get far enough into Haskell, you'll wonder why async/await are language features.  Haskell puts them in a library. :)
17:43:26 <Welkin> almost everything in haskell is a library though
17:43:41 <shachaf> c_wraith: But Haskell has do notation as a language feature. And it doesn't have e.g. built-in loops.
17:43:51 <_xor> So I know one of the complaints about Haskell is that the ecosystem is not that large.  I understand it has a decent FFI.  What's the general approach within the community?  Port existing libs to be usable from the FFI and then slowly rewrite in Haskell, or spend more time upfront and rewrite libs in Haskell from the get-go?
17:44:01 <_xor> I'm not sure if that's a stupid question or not lol.
17:44:06 <c_wraith> Depends on the library.
17:44:13 <c_wraith> Lots of things go either way.
17:44:18 <Welkin> for web, there are tons of great libraries
17:44:21 <_xor> Yeah, most libs are going to be written to use lots of state.
17:44:32 <_xor> Hmm, what's your opinion of Go?
17:44:49 <Welkin> _xor: the consensus is: two thumbs down
17:45:05 <koz_> OK, this is really fucking me off now.
17:45:21 <koz_> Like, I literally cannot replicate this bug except in this *exact* environment.
17:45:46 <_xor> Welkin: Really? Damn. I was going to spend a day or two checking it out.  Heard good things about it.
17:45:53 <c_wraith> Go is.. a language with no interesting features whatsoever, and whose designers wanted exactly that.  I mean, it achieved its goals.  I have to give it credit for that.
17:45:56 <_xor> Welkin: I mean I still will, but not sure what to expect now heh.
17:46:15 <_xor> c_wraith: Ah ok, so it's not really revolutionary from a language perspective.
17:46:22 <maerwald> _xor: it's sometimes also a mixture. E.g. if you look at the diagrams libraries, it's a new DSL, but uses various foreign libraries (like cairo) to actually draw the stuff in the end
17:46:52 <maerwald> something similar could be done for e.g. OpenGL, but that's generally a lot of work
17:46:53 <_xor> maerwald: What's the point of the DSL then?
17:47:01 <maerwald> _xor: err, being a DSL
17:47:27 <_xor> maerwald: I meant why use the DSL there in the first place?
17:47:27 <iphy> can I conditionally build an executable with cabal?
17:47:37 <maerwald> _xor: because it's high-level?
17:47:39 <iphy> I want to disable it by default, but allow users to enable it if they want
17:47:45 <maerwald> I don't understand the question
17:47:51 <maerwald> cairo is not high-level and not a DSL
17:47:59 <_xor> maerwald: Yeah, I guess I'm misunderstanding.
17:48:16 <maerwald> http://projects.haskell.org/diagrams/
17:48:32 <_xor> maerwald: Oh, I see what you're saying.  Looking at it now.
17:49:20 <maerwald> so you can build a higher-level API around foreign libraries too, although for diagrams that's not even a correct description
17:49:47 <iphy> buildable: False seems to do it
17:49:53 <_xor> Heh, I don't know much about Cairo, which is fairly pathetic.  My background from the 90s is 3d gfx.
17:50:28 <maerwald> it's just that it lets you interface with your stuff in the end via something like cairo, gtk etc
17:50:53 <maerwald> _just_ doing bindings to cairo would be really boring
17:52:52 <_xor> Yeah, I see what you're saying.
17:54:05 <maerwald> but we have that too ofc for things like gtk, qt, sdl and so on
17:54:19 <maerwald> which are really hard to build a functional framework around
17:54:34 <maerwald> and those are annoying to work with
17:56:58 <_xor> Yeah, that was the thought that prefaced my question earlier about the FFI and porting existing libraries.
17:57:50 <_xor> "Well, if there's a nice FFI then porting should be possible...but since a vast majority of libs are written to be imperative and use state, then writing the bindings might not be enough."
17:57:54 <_xor> That's basically what I was thinking.
17:58:00 <maerwald> if you create bindings, you end up with a lot of IO foo, usually
17:58:22 <maerwald> https://hackage.haskell.org/package/gtk3-0.14.5/docs/Graphics-UI-Gtk-Gdk-Display.html
17:58:26 <maerwald> show me a function without IO there
17:58:40 <maerwald> because they are all not pure
18:02:21 <ertes> iphy: yes, you can set 'buildable' to false
18:04:21 <ertes> iphy: see lines 38-41 and 61-66 in http://hub.darcs.net/esz/skeleton/browse/skeleton.cabal
18:05:00 <iphy> ah yes
18:05:10 <iphy> I didn't make the build-depends conditional
18:05:30 <ertes> iphy: put the dependencies within the buildable branch, otherwise your package will depend on them even if the executables are disabled
18:05:38 <iphy> right
18:06:30 <ertes> iphy: you should do that with anything that affects dependencies: for example if you use the default-extensions field
18:08:44 <lambdafan> is this the proper channel for stack questions?
18:11:38 <Cale> lambdafan: #haskell-stack exists, but this channel is far more populated
18:12:35 <reinh> And lots of us use Stack
18:14:23 <iphy> ertes: thanks
18:43:09 * hackagebot active 0.2.0.10 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.10 (BrentYorgey)
19:03:23 <Fylwind> " Although the output [of WriterT] is built strictly, it is not possible to achieve constant space behaviour with this transformer: for that, use Control.Monad.Trans.State.Strict instead."  Can someone elaborate on why this is the case?  Pathological example that demonstrates this problem?
19:18:27 <ertes> Fylwind: any example is pathological…  the strict WriterT is not strict in the sense you would expect
19:20:06 <ertes> here is the strictness you would want:  WriterT c >>= f = WriterT (do (x, w1) <- c; (y, w2) <- runWriterT (f x); let !w = w1 <> w2 in pure (y, w))
19:20:22 <ertes> but in actuality it's only strict in the result *tuple*
19:20:34 <alercah> wait what
19:20:40 <alercah> isn't that rather pointless
19:20:43 <ertes> it is
19:21:38 <Fylwind> ertes: why is it implemented in that way? o.o
19:22:07 <ertes> Fylwind: no idea…  just use StateT
19:26:01 <glguy> It's implemented that way because there's a type that makes sense and WriterT happens to be what people call it
19:26:23 <glguy> It's the transformer generalization of "writer"
19:35:20 <glguy> And while you shouldn't mix it with a "strict" Monad like IO, it works fine for cases where you can "stream" the output
19:38:13 <glguy> The stuff in transformers/mtl doesn't exist as a recommendation for you to use it, it exists because it's a set of primitive components that already exist should you need them
19:38:22 <glguy> They kind of "exist because they should exist"
19:40:31 <pavonia> And how do you find the transformers you should use instead?
19:41:05 <glguy> If the pattern you need is what one of the transformers already is, you use it
19:43:44 <pavonia> But when you say you shouldn't mix it with IO, there seems to be a better alternative
19:44:49 <pavonia> I mean how do you know what transformers are the proper ones and what ar not? Do you find that out only by profiling?
19:45:49 <glguy> You look at the type and decide if the transformer provides the type you were looking for
19:46:10 <glguy> You can't go by the names and use intuition
19:46:25 <glguy> I don't know if someone has written up a chart of what types you should be using for all situations
19:56:18 <ertes> pavonia: in general it's safe to assume that WriterT is the wrong choice…  it's true most of the time, and when it isn't you will likely know
19:56:58 <ertes> in most of the cases i have encountered it was also sensible to use the non-strict version
19:57:50 <pavonia> What would be an okay case for using it?
19:59:17 <pavonia> I noticed that whenever I was using Writer in the past, it caused performance issues because of the list monoid appending in the wrong direction. But that isn't directly a problem with Writer
20:09:36 <cheater> hi
20:11:50 <cheater> is there anyone else here who is annoyed that the list monad is called the non determinism monad? the monad structure is made exactly to ensure determinism. it is a minimal system that ensures determinism: in a >>= b, the element on the left always runs before the element on the right because a needs to be fully evaluated so that the monadic value can be plugged into b. does anyone else find this to ...
20:11:56 <cheater> ... be an issue?
20:14:51 <brisbin> cheater: it's called that because it can model non-determinism, not because it itself is non-deterministic
20:15:15 <brisbin> some [a] is actually an a that can be any of the a's in the list, non-deterministically
20:15:57 <cheater> :t some
20:15:58 <lambdabot> Alternative f => f a -> f [a]
20:16:08 <cheater> huh
20:16:18 <cheater> > some [1..5]
20:16:22 <lambdabot>  mueval-core: Time limit exceeded
20:16:28 <cheater> yeah, great
20:16:35 * cheater kicks lambdabot :p
20:16:46 <cheater> :i some
20:16:52 <cheater> doesn't work...
20:17:56 <cheater> brisbin: i don't get it. what is "some" supposed to be doing?
20:19:06 <geekosaur> "some" doesn't really do what you expect; it's intended for parser combinator libraries
20:19:31 <brisbin> i wasn't actually talking about a specific "some" function, btw
20:19:57 <brisbin> i meant, consider a list of a's. it's meant to represent a single a that can be any one of the values in the list at the same time
20:26:17 <rdivyanshu> Is it possible to have depedent type signature of drop, along the line drop :: (k :: Int) -> Vect (k + n) -> Vect n using typelits and class contraints 
20:32:39 <c_wraith> rdivyanshu: you can have that signature, sure.  But at the moment, GHC doesn't do much (if anything) in the way of handling arithmetic.
20:33:14 <c_wraith> So you'll end with things like not being able to derive n ~ k + n - k
20:33:48 <rdivyanshu> c_wraith : I am using ghc-typelits-natnormalise plugin so that not problem 
20:33:51 <c_wraith> There are a couple type checker plugins that do handle that.  I haven't used them, I don't know how far they can go.
20:36:39 <rdivyanshu> c_wraith: what I specifically wanted to ask is it possible to give constraint that Int and k are related somehow in ghc, https://gist.github.com/rdivyanshu/9144de41daa68734b3bccb0f8301e27d in dropEasy signature
20:37:23 <c_wraith> rdivyanshu: what version of GHC?  8 has some tools for handling this much more nicely than 7
20:38:12 <rdivyanshu> c_wraith: i am on 7.10.3, will check out.  
20:38:15 <glguy> Haskell doesn't have actual dependent types, so you can't do this kind of:  (k :: Int) -> Vect k stuff
20:39:09 <benzrf> rdivyanshu: you can kind of do a hack type of thing, where the type of a value reflects the value
20:39:49 <benzrf> for example - "data NatTrick n where ZeroTrick :: NatTrick Zero; SuccTrick :: NatTrick n -> NatTrick (Succ n)"
20:40:04 <benzrf> then you can say "NatTrick k -> Vect k stuff"
20:43:53 <rdivyanshu> benzrf: Yeah, is it possible to do this without sacrifising Int and having class constraint like ( m ~ k + n ) in drop :: ( k :: Int) -> Vect m, which is 
20:44:11 <rdivyanshu> very unlikely since you can’t name type in type signature as far as I know
20:44:14 <dmj`> glguy: could someNatVal be used in some way
20:44:38 <c_wraith> the problem with someNatVal is that you lose static reasoning.
20:46:46 <dmj`> c_wraith: hm, how so?
20:48:48 <c_wraith> Well, you no longer know the types at which your function is working.  I mean, that's the point of it, but it always makes me a bit uncomfortable.
20:50:31 <dmj`> c_wraith: I see, you have to rely on the Maybe that's produced, or when comparing with sameNatVal
20:50:54 <c_wraith> The only reason there's a Maybe is that it can't handle negative inputs
20:51:05 <c_wraith> If the input is non-negative, the result is always a Just
20:51:25 <dmj`> c_wraith: ah! very interesting
20:51:45 <c_wraith> It's the existential wrapper hiding the type that bugs me, because it makes me face the fact that the type is a lie masking implicitly passing a value.
20:52:00 <dmj`> c_wraith: isn't SomeNat kind of like dependent typing though. You have a value (data constructor) that a type depends on. (Proxy n)
20:52:09 <dmj`> specifically the n
20:52:39 <c_wraith> The problem is, I know it's just an unsafeCoerce at the implementation level.  The KnownNat constraint is treated as an Integer
20:54:22 <dmj`> c_wraith: I see, very interesting
20:55:02 <dmj`> c_wraith: I have a use case I'd love to try this out on, even if it uses an existential that's still fine with me
20:55:33 <dmj`> c_wraith: I have a String literal I'd like to associate with a type
20:55:58 <dmj`> on "keypress" $ \(e :: KeyboardEvent)
20:56:22 <dmj`> so like exception the base class is Event, but you can coerce Event into more specific things like 'KeyboardEvent'
20:56:23 <c_wraith> you will note that someSymbolVal doesn't have the Maybe
20:56:48 <dmj`> ah, hmmm
20:56:51 <c_wraith> Because all Strings are valid Symbols. (Well, finite ones)
20:57:30 <dmj`> c_wraith: so from there I'd just use a type family then right
20:57:37 <dmj`> hmm, let me cook something up
21:02:41 <dmj`> c_wraith: still there?
21:02:46 <c_wraith> yeah
21:02:52 <dmj`> http://lpaste.net/168720
21:03:35 --- mode: ChanServ set +o glguy
21:03:36 --- mode: glguy set -bbbb *!*462330be@*.70.35.48.190 *!*4b538701@*.75.83.135.1 *!*4f8da404@*.com/ip.79.141.164.4 *!*627d1ecd@*.com/ip.98.125.30.205
21:03:36 --- mode: glguy set -bbbb *!*@*184.6.42.182 *!*@*51.174.19.26 *!*@108-65-78-116.lightspeed.sntcca.sbcglobal.net *!*@118-163-101-67.HINET-IP.hinet.net
21:03:36 --- mode: glguy set -bbbb *!*@128.199.158.247 *!*@128.199.244.202 *!*@173.57.31.183 *!*@178-84-111-121.dynamic.upc.nl
21:03:36 --- mode: glguy set -bbbb *!*@178.150.229.221 *!*@188.26.240.168 *!*@189.40.91.15 *!*@206.125.41.78
21:03:37 --- mode: glguy set -bbbb *!*@209-6-212-33.c3-0.bkl-ubr1.sbo-bkl.ma.cable.rcn.com *!*@23.254.167.179 *!*@27.123.7.134 *!*@31.186.13.221
21:03:39 --- mode: glguy set -bbbb *!*@41.215.40.78 *!*@84-72-192-208.dclient.hispeed.ch *!*@87-205-173-234.adsl.inetia.pl *!*@89.46.65.186
21:05:00 <dmj`> c_wraith: so the implementation of `on` will use someSymbolVal
21:05:10 <dmj`> but I can't even apply the type family for some reason
21:05:23 --- mode: glguy set -bbbb *!*@89.46.66.38 *!*@gateway/web/cgi-irc/kiwiirc.com/ip.162.244.81.177 *!*@gateway/web/cgi-irc/kiwiirc.com/ip.172.91.105.236 *!*@gateway/web/cgi-irc/kiwiirc.com/ip.206.190.141.229
21:05:23 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.107.77.172.19 *!*@gateway/web/freenode/ip.108.179.151.120 *!*@gateway/web/freenode/ip.173.250.159.249 *!*@gateway/web/freenode/ip.184.6.47.36
21:05:23 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.81.104.112.74 *!*@gateway/web/freenode/ip.85.76.101.110 *!*@h59.6.140.67.dynamic.ip.windstream.net *!*@m77-218-225-184.cust.tele2.se
21:05:23 --- mode: glguy set -bbbb *!*@pool-108-19-173-17.dllstx.fios.verizon.net *!*@tgn.188.23.73.dts.mg *!*hackteck@84.232.57.* *!*holoirc@*.1-3.cable.virginm.net
21:05:24 --- mode: glguy set -bbbb *!*jock@103.227.116.* *!*magistr@109.111.174.* *!*therapist@46.188.227.* *!*u931732@172.56.30.*
21:05:25 --- mode: glguy set -bbbb *!*yaaic@*.tbcn.telia.com *!*yaaic@81.230.180.* *!Guest33674@*.77.20.109.rev.sfr.net *!ident@109.246.155.212
21:05:52 <c_wraith> Probably because you put your documents on your desktop. :P
21:06:44 <texasmynsted> Where can I see more explanation for "where go" function?
21:07:01 <dmj`> c_wraith: haha :] 
21:07:51 <c_wraith> texasmynsted: it's just a locally-defined function in a where block
21:08:11 <c_wraith> texasmynsted: usually if it's named "go", it's a recursive helper function, but that's just a convention that some people use.
21:08:59 <texasmynsted> hm ok
21:09:42 <c_wraith> dmj`: the thing that's catching my attention is that it's saying sym0
21:09:58 <c_wraith> dmj`: which makes me suspect that you need ScopedTypeVariables or something
21:10:18 <texasmynsted> I suppose that makes sense 
21:10:25 --- mode: glguy set -o glguy
21:12:39 <c_wraith> dmj`: oh, I see the real problem
21:13:25 <c_wraith> dmj`: the issue is that you need to go backwards, from a to NameToEvent sym, in order to figure out what type sym is
21:13:40 <c_wraith> dmj`: but because NameToEvent isn't injective, that doesn't work.
21:13:48 <c_wraith> dmj`: that's why it's complaining the type is ambiguous
21:14:02 <c_wraith> dmj`: time to go to ghc 8 and use fancy injective type families
21:15:16 --- mode: ChanServ set +o glguy
21:15:16 --- mode: glguy set -bbbb *!*4d551e8e@*.77.85.30.142 *!*@121.127.12.242 *!*@141.2.179.78 *!*@190.197.66.2
21:15:16 --- mode: glguy set -bbbb *!*@197.195.141.154 *!*@2.237.171.7 *!*@202.166.206.154 *!*@222.Red-83-36-247.dynamicIP.rima-tde.net
21:15:16 --- mode: glguy set -bbbb *!*@2600:1008:b065:6ad3:2544:e8e3:6fa8:91ca *!*@41.222.193.19 *!*@64.88.227.134 *!*@65.202.30.2
21:15:17 --- mode: glguy set -bbbb *!*@70.33.229.146 *!*@70.51.242.179 *!*@83.143.240.6 *!*@APuteaux-655-1-88-179.w92-151.abo.wanadoo.fr
21:15:18 --- mode: glguy set -bbbb *!*@cpc29-walt12-2-0-cust7.13-2.cable.virginm.net *!*@dhcp-077-249-247-124.chello.nl *!*@gateway/vpn/mullvad/x-hpcjahidgfmlzgwh *!*@gateway/web/freenode/ip.128.40.76.3
21:15:20 --- mode: glguy set -bbbb *!*@gateway/web/freenode/ip.206.71.252.34 *!*@gateway/web/freenode/ip.87.89.74.248 *!*@host86-139-75-0.range86-139.btcentralplus.com *!*@host86-167-125-129.range86-167.btcentralplus.com
21:15:22 --- mode: glguy set -bbbb *!*b23e9505@*.178.62.149.5 *!4bab875d@gateway/web/freenode/ip.75.171.135.93 *!670ac723@gateway/web/freenode/ip.103.10.199.35 *!SafeMoneyO@188.26.43.190
21:15:24 --- mode: glguy set -bbbb *!SafeMoneyO@5-12-129-251.residential.rdsnet.ro *!~JusticeOf@pool-108-45-112-134.washdc.fios.verizon.net *!~ffja@68-70-91-130.static.kc.surewest.net *!~fxxwm@212.154.80.5
21:15:26 --- mode: glguy set -bb *!~mirror@104.255.96.100 *!~splinter@177.16.144.50
21:16:15 --- mode: ChanServ set -o glguy
21:18:08 <c_wraith> dmj`: alternatively, you could add a Proxy sym argument.  Or in GHC 8, you could use visible type application to provide it.
21:18:27 <c_wraith> dmj`: In other words, you're pushing at the bleeding edge.  And it's still bleeding. :)
21:19:36 <c_wraith> ...  I'm 100% certain that as soon as there's a way to treat Symbol as a list of type-level characters, someone will write a version of printf that takes the format string as a type, and uses it to ensure that printf is properly typed.  That'll be fun.
21:20:44 <dmj`> c_wraith: sounds painful :] but that would be cool
21:21:29 <glguy> c_wraith: Someone could already make a type-level list of symbols as though there were chars :)
21:21:47 <CastleK> Hey, just posting this here in case someone wants to help. The a StackOverflow question which was asked about importing JavaScript libraries to Haskell. If you're interested in helping the link is http://stackoverflow.com/q/38155884/5743988
21:22:21 <dmj`> c_wraith: had an idea for disallowing invalid states in HTML, if we represented HTML as a rose tree with a type level symbol, then we could iterate the structure and ensure certain html doesn't get nested in non-conforming ways, using a closed type family. Like W3C validation for types.
21:23:00 <dmj`> c_wraith: so here's a second try, this error more interesting
21:23:01 <dmj`> http://lpaste.net/168722
21:24:54 <dmj`> CastleK: it seems like it was answered, I'd only add that you can specify 'js-sources: js-bits' in the cabal file
21:27:04 <c_wraith> dmj`: something does look sketchy there.
21:27:37 <c_wraith> dmj`: ah.  I think on line 22 you meant NameToEvent instead of HasEvent
21:27:52 <koz_> Is there a way to write this to allocate less? '(fmap head . chunksOf 10) <$> replicateM 50 (runCluster beam t start)'?
21:28:23 <c_wraith> dmj`: because saying HasEvent b ~ a implies that a must be a Constraint, which is what the error is saying 
21:28:26 --- mode: ChanServ set +o glguy
21:28:26 --- mode: glguy set -qq microatxslim_!*@* *!*@5.172.238.153
21:30:27 <dmj`> c_wraith: doh, yes
21:31:54 --- mode: glguy set -q `H2O`!*@*
21:32:27 <dmj`> c_wraith: same error
21:34:09 --- mode: glguy set -q bayesian!*@*
21:35:30 --- mode: glguy set -q *!*@unaffiliated/fax
21:37:24 --- mode: glguy set -q *!*@unaffiliated/vennix
21:37:47 <koz_> Is there a way to write this to allocate less? '(fmap head . chunksOf 10) <$> replicateM 50 (runCluster beam t start)'? I'm really not sure - I just want it to run the thing 50 times, but only keep every 10th.
21:39:34 --- mode: glguy set -q *!*@unaffiliated/ilk
21:40:11 --- mode: glguy set -q *!*@*/lolwhat
21:40:35 <nitrix> koz_: Mhhh, I think this creates a list just to re-obtain the head, it's probably not too nice for the GC.
21:40:44 <nitrix> koz_: Have you tried  `every n xs = case drop (n-1) xs of (y:ys) -> y : every n ys [] -> []` ?
21:40:46 --- mode: glguy set -q StaffMsg!*@*
21:41:04 <nitrix> @let every n xs = case drop (n-1) xs of (y:ys) -> y : every n ys [] -> []
21:41:04 <lambdabot>  Parse failed: Parse error: ->
21:41:24 <nitrix> @let every n xs = case drop (n-1) xs of (y:ys) -> y : every n ys; [] -> []
21:41:26 <lambdabot>  Defined.
21:41:35 <nitrix> > every 5 [1..15]
21:41:37 <lambdabot>  [5,10,15]
21:41:41 <koz_> nitrix: Thanks!
21:45:18 <koz_> Let's see if this helps, or if I still have a hot zone there.
21:45:28 <koz_> This program is grabbing an *absurd* amount of RAM.
21:48:49 <lpaste> koz_ pasted “nitrix: This function eats an absurd amount of RAM according to my profiler. Why do you think this is?” at http://lpaste.net/168725
21:50:32 <kadoban> koz_: Does that even compile with that indenting?
21:50:32 --- mode: glguy set -o glguy
21:51:07 <nitrix> koz_: Oh boy, that abuse of `let` ._.
21:51:31 <koz_> kadoban: Whoops. Thought that pasting went a bit funny.
21:51:59 <koz_> nitrix: I should probably lift many of these into dedicated functions. However, I still have no clue how this could be eating > 80% of the allocations.
21:52:01 <geekosaur> koz_, one thing about replicateM is it's going to generate every list even though you ignore most of them. laziness does not propagate through it.
21:52:22 <koz_> geekosaur: How would you advise I write that instead?
21:52:38 <nitrix> koz_: How big can `range` get?
21:53:04 <koz_> nitrix: (0, 9) in this case.
21:53:36 <geekosaur> I don't know offhand, sorry
21:53:55 <koz_> geekosaur: It's OK - I'm a monadic noob, so I have no clue. :(
21:53:59 <geekosaur> I know the problem exists, I haven't yet run into it in any circumstances that would motivate me to work out ways around it
21:54:11 * geekosaur is not actually far beyond noob when it comes to this stuff either
22:23:15 <nitrix> koz_: Last resort, work backwards, replace some of those results with empty lists and see if it suddently takes less RAM.
22:23:15 <koz_> I'm still completely unsure why that particular function eats so much memory...
22:23:15 <koz_> nitrix: Sorry, which results?
22:23:15 <nitrix> koz_: Some of the actives for example.
22:23:15 <koz_> nitrix: That'd be... challenging, but I'll try, I guess?
22:23:15 <koz_> I suspect it's a laziness issue, because none of the routines it calls use that much memory.
22:23:15 <nitrix> koz_: Instead of the V.// you can just put V.empty
22:23:15 <nitrix> I think what's happening is that you're piling up transformations.
22:23:15 <koz_> So you mean the V.//s aren't happening when I ask?
22:23:16 <nitrix> Of course not :P
22:23:16 <koz_> nitrix: Figures...
22:23:16 <nitrix> Haskell is lazy :P
22:23:16 <koz_> nitrix: Where would the strictness annotation need to go to force the transformations to happen then and there?
22:23:16 <koz_> Do I need a let above it and bang-pattern it or something?
22:23:16 <nitrix> koz_: Depends on what happens and why it happens. You could have to use the `force` operation if you're doing slices, etc.
22:23:16 <nitrix> First, confirm it's the issue...
22:23:16 <koz_> nitrix: So you reckon replace the transformations with converting to an empty vector and see what happens?
22:23:16 <nitrix> For one, try:
22:23:16 <nitrix> active = act
22:23:16 <koz_> So, no change?
22:23:17 <nitrix> Mhm.
22:23:17 <koz_> OK, gonna try that.
23:07:12 --- topic: 'http://www.haskell.org/ | https://wiki.haskell.org/IRC_channel | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
23:07:12 --- topic: set by Cale!~Cale@2607:fea8:9840:324:58c2:98f3:e7ff:280e on [Thu Jun 23 02:10:43 2016]
23:07:59 <dmj`> c_wraith: http://lpaste.net/8222361932074582016
23:08:38 <dmj`> c_wraith: I want GHC to say, "can't match Event with KeyboardEvent"
23:09:43 <dmj`> c_wraith: shouldn't GHC infer t from Proxy a, in the presence of the type family constraint
23:11:22 <dmj`> it can't be any more obvious imo
23:12:50 <dmj`> glguy: o/
23:29:46 <nshepperd> dmj`: I don't think the 'a' in 'Proxy a' there is the same as the one in the type signature
23:31:05 <nshepperd> also shouldn't foo be, er... 'on "keypress" KeyboardEvent'
23:32:54 <glguy> Dmj: hi
23:33:09 <nshepperd> uh, wow that compiles somehow
23:34:06 <dmj`> nshepperd: yes, the point is to get ghc to yell at me about Event not being KeyboardEvent, I think it compiles because the existential on Event Handler and KeyboardEvent being an instance of IsEvent
23:34:23 <dmj`> glguy: hi!
23:35:10 <nshepperd> oh, it was just complaining that Event wasn't in the range of that type instance
23:35:30 <nshepperd> for a moment there I thought ghc had attained sentience
23:35:49 <dmj`> nshepperd: :] 
23:36:48 <dysfun> nah, if it had it would have finished my code for me
23:36:52 <dmj`> nshepperd: your comments on the 'a' in Proxy not being the 'a' in NameToEvent a ~ t were dead on, so an explicit forall a t . on `on` causes them to be compared
23:37:11 <EvanR> -XSkyNet
23:37:31 <EvanR> humanity determined to be a type error
23:37:56 <nshepperd> dmj`: yeah that sounds right.
23:38:18 * hackagebot yi-language 0.2.1 - Collection of language-related Yi libraries.  https://hackage.haskell.org/package/yi-language-0.2.1 (DmitryIvanov)
23:38:43 <nshepperd> you need some kind of runtime type comparison there though, because SomeSymbol is existential
23:41:33 <nshepperd> or just drop the string entirely since you can get it from symbolVal (Proxy :: Proxy a)
23:45:02 <dmj`> glguy: we were just playing with types :] 
23:45:04 <koz_> OK, I have an answer, kinda. Except it doesn't make sense.
23:45:10 <dmj`> nshepperd: that seems to have worked
23:45:21 <koz_> For some reason, my IntMap, despite *showing* having a value for a key, can't retrieve it.
23:45:27 <dmj`> nshepperd: • Couldn't match type ‘KeyBoardEvent’ with ‘Event’
23:45:29 <koz_> (I get Nothing when I do a lookup)
23:45:33 <dmj`> is exactly what I wanted
23:45:39 <koz_> How is that even possible?
23:45:55 <dmj`> koz_: can you paste your code
23:46:17 <koz_> dmj`: The code that produces such a map, you mean?
23:46:45 <dmj`> koz_: sure, and maybe your ghci playings too
23:47:02 <koz_> dmj`: I'll do the GHCi playings - this is coming from a rather large codebase. Let me just do a clean take.
23:47:04 <dmj`> koz_: are you sure you're not inspecting the old intmap, the one  before insertion?
23:47:56 <koz_> dmj`: Definitely not - my GHCi session will show it clearly.
23:47:56 <dmj`> glguy: is it possible to vary a type based on a value in ghc8? i.e. on ("click" :: String) $ \(e :: forall a . IsEvent e => e -> IO ()) -> IO (), where "click" here picks the right instance of IsEvent
23:48:02 <koz_> Let me just do a clean take.
23:51:23 <nshepperd> dmj`: what worked?
23:51:33 <nshepperd> I think it's probably still a trick
23:51:34 <EvanR> dmj`: that would be cool
23:52:34 <EvanR> dmj`: does "click" really need to be a string though?
23:52:35 <nshepperd> there's definitely no code in ghc that makes someSymbolVal "str" stop holding an existential
23:52:58 <koz_> dmj`: Found it - careless use of fromAscList....
23:53:01 * koz_ feels daft.
23:53:23 <EvanR> koz_: so that can cause brain damaged IntMaps... good to know
23:53:34 <koz_> EvanR: It seems to be able to cause brain-damaged *anything*.
23:53:41 <koz_> And IntMap has no 'valid' method to check with.
23:54:29 <nshepperd> hmm, should fromAscList there check the property?
23:55:31 <dmj`> nshepperd: http://lpaste.net/3181385793448968192
23:56:14 <nshepperd> ah, you're using Proxy a, of course
23:56:16 <dmj`> EvanR: yea, seems the best we can do is on (Proxy :: Proxy "click") $ \(e :: ClickEvent) <-- inferred
23:56:31 <dmj`> nshepperd: yea :/ not very dependent
23:57:05 <koz_> nshepperd: It won't check.
23:57:19 <koz_> They're all 'at own risk' functions - and I was careless.
23:58:00 <koz_> Now it works, but I have the mother of all space leaks *again*.
23:58:50 <dmj`> injectivity wasn't the issue here, in fact it was detrimental, we don't want one-to-one, but potentially many-to-one
23:59:28 <adarqui> is there a hoogle that gives more info (has more libraries loaded into it, perhaps some stack lts version)? for example i'm looking for StatusCodeException.
