00:07:38 * hackagebot glirc 2.0 - Console IRC client  https://hackage.haskell.org/package/glirc-2.0 (EricMertens)
00:07:38 * hackagebot pokemon-go-protobuf-types 0.1.0.0 - Haskell types for the Pokemon Go protobuf protocol.  https://hackage.haskell.org/package/pokemon-go-protobuf-types-0.1.0.0 (RickyElrod)
00:22:29 <piyush-kurur> question regarding package candidate on hackage: does hackage build these candidates? I do not
00:22:37 <piyush-kurur> understand the point of not building it
00:25:17 <piyush-kurur> The reason I am asking is that hackage does not seem to be building the candidate package that I uploaded https://hackage.haskell.org/package/raaz-0.0.2/candidate
00:25:37 <piyush-kurur> I would like to upload the actual package but now am unsure
00:56:20 <demize> piyush-kurur: https://github.com/haskell/hackage-server/issues/74
01:12:37 <piyush-kurur> demize: ohno. thanks anyway. Is it okey then to just go ahead, the travis builds are fine. What are others doing?
01:15:03 <ertesx> piyush-kurur: side note: did you see the cryptonite package?
01:20:11 <piyush-kurur> ertesx: I had seen other packages of vincenthz. I briefly heard about cryptonite but had not seriously looked into it.
01:26:26 <ertesx> piyush-kurur: reason i'm asking is that currently we have two major crypto implementors on hackage, and they aren't cooperating as far as i see…  in crypto community fragmentation can be toxic
01:27:00 <ertesx> so you could consider contributing to one of those instead of making yet another package-of-everything =)
01:28:34 <designgeek> Starting out with Haskell
01:28:42 <designgeek> Using an online compiler http://rextester.com/l/haskell_online_compiler
01:28:47 <designgeek> Whenever I'm trying to execute any code, the error "The IO action ‘main’ is not defined in module ‘Main’" shows up
01:28:51 <designgeek> Can't figure out how to make the error go away
01:29:43 <liste> designgeek: works for me
01:30:33 <ertesx> designgeek: does the initial example work?
01:30:35 <liste> designgeek: are you trying it out on your computer or does the online compiler fail for you?
01:30:48 <ertesx> designgeek: this one: main = print "hello world"
01:30:58 <designgeek> Yes, initial code works
01:31:09 <designgeek> But on adding my own code without the main, it fails
01:31:14 <ertesx> designgeek: haskell programs (!) need a 'main' action
01:31:27 <ertesx> designgeek: it does not execute from top to bottom like some other languages
01:32:11 <designgeek> Okay
01:32:18 <ertesx> designgeek: you should install GHC to get a reasonable development environment…  only being able to *compile* *programs* is very limiting
01:32:27 <designgeek> So, how do I make a simple program going?
01:32:31 <ertesx> example: you can't load modules and play with their local definitions
01:32:41 <designgeek> I have the GHC compiler in my home laptop
01:32:49 <designgeek> Using the web compiler at office
01:33:09 <ertesx> i see…  in that case you always need a main action, and anything you do has to be in 'main'
01:34:00 <designgeek> Ok
01:36:10 <ertesx> (not necessarily "in" main lexically, but referred to "from" main)
01:37:10 <designgeek> But it seems like the complete GHC environment when installed locally doesn't require the "main" anywhere to execute something
01:37:38 <ertesx> designgeek: it does…  if you compile a program, it has to have a 'main' action
01:38:30 <ertesx> what you don't need with a locally installed GHC is to have a 'main' action in a module you load into the interpreter
01:39:54 <ertes-t6v> <ertesx> designgeek: it does…  if you compile a program, it has to have a 'main' action…  what you don't need with a locally installed GHC is to have a 'main' action in a module you load into the interpreter
01:40:01 <designgeek> @ertesx So how do I execute a function within an explicit 'main' action?
01:40:01 <lambdabot> Unknown command, try @list
01:40:07 <designgeek> So how do I execute a function within an explicit 'main' action?
01:40:38 <ertes> designgeek: you write the function, let's call it f, and then you use e.g. 'print' from 'main'
01:40:43 <ertes> main = print (f 15)
01:41:13 <designgeek> Ok
01:41:23 <jmi2k> ?src doFloat
01:41:23 <lambdabot> Source not found. Just try something else.
01:41:35 <designgeek> Ah yes, got it. Thanks.
01:42:01 <ertes> jmi2k: sounds like you'd find it in xmonad or xmonad-contrib
01:42:50 <jmi2k> yes, I just wanted to know if I could view the source using lambdabot
01:42:54 <akegalj> can I would like to import all ToJSON instances but without `instance ToJSON Rational` . Can I achieve this with `hiding` clause ?
01:43:43 <ertes> akegalj: nope, instances are always imported
01:43:48 <liste> akegalj: no, import always imports all instances. what are you trying to accomplish?
01:44:14 <akegalj> liste: I would like to alter ToJSON Rational, but I whanted to do without newtype wrapper
01:44:28 <akegalj> but Ill wrap it if there is no other way
01:45:04 <ertes> akegalj: it's the proper way to wrap
01:45:32 <ertes> akegalj: note that you can derive most classes, so you can probably do without the wrapping/unwrapping most of the time
01:46:02 <ertes> newtype MyWrapper = MyWrapper { fromMyWrapper :: Rational }  deriving (Eq, Fractional, Num, Ord, Show)
01:46:34 <akegalj> ertes: yes, I am aware of that, thank you <3
01:47:36 * hackagebot hascar 0.2.0.2 - Decompress SAPCAR archives  https://hackage.haskell.org/package/hascar-0.2.0.2 (hc)
02:07:03 <piyush-kurur> ertesx: point taken. In fact I have contributed, in a trivial way, to one of vincenthz asn1 package
02:07:13 <sbrg> Anyone here gone from a "basic" MTL stack to using something like Ether? (https://int-index.github.io/ether/) 
02:07:28 <piyush-kurur> however there are some design choices that we have that I believe is unique
02:07:35 <sbrg> any experiences to share? I'm wondering if I should convert. it sounds like it would be much easier to 'navigate' a deep transformer stack
02:08:56 <piyush-kurur> regarding raaz: we have i believe some good stories on timing safe equality, secure memory etc
02:11:09 <cheater> hi
02:11:51 <cheater> if i have a piece of code, like a simple hs file, how can i compile it down to Core's Expr data type? like this here https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
02:16:27 <quicksilver> well -fext-core but it's not exactly 
02:17:25 <cheater> i trued -fext-core yesterday but it has been turned off a long time ago apparently
02:17:50 <cheater> i thought it was what -ddump-simpl did ?
02:29:32 <jvans> I'm trying to wrap my head around this code http://dev.stephendiehl.com/hask/#polyvariadic-functions. I don't understnad how it works, specifically when/why does the type class definition for Arg (a -> r ) get called?
02:31:18 <Cale> jvans: Well, that instance is used whenever collect' is used and the type of result needs to produce unifies with a function type.
02:32:26 <Cale> jvans: So if collect' is applied to a list of strings, and then anything else, well, it must have produced a function as its result, so we must be using the instance of Arg (a -> r)
02:33:10 <Cale> Similarly, collect :: Arg t => t
02:33:41 <jvans> ahh i see that makes sense, and then for each additional argument the same reasoning applies
02:33:46 <Cale> So whenever collect is applied to an argument at all, it must be a function, and so the instance of Arg being used must be the function one
02:33:49 <Cale> yeah
02:34:26 <jvans> very neat, thanks Cale!
02:52:37 * hackagebot microlens 0.4.6.0 - A tiny lens library with no dependencies. If you're writing an app, you probably want microlens-platform, not this.  https://hackage.haskell.org/package/microlens-0.4.6.0 (Artyom)
02:52:40 * hackagebot microlens-ghc 0.4.6.0 - microlens + array, bytestring, containers, transformers  https://hackage.haskell.org/package/microlens-ghc-0.4.6.0 (Artyom)
02:52:42 * hackagebot microlens-platform 0.3.4.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.3.4.0 (Artyom)
03:17:38 * hackagebot aeson-injector 1.0.1.0 - Injecting fields into aeson values  https://hackage.haskell.org/package/aeson-injector-1.0.1.0 (NCrashed)
03:17:50 <ertes> ApplicativeDo is very useful…  no more incomprehensible liftA517 applications
03:18:06 <maerwald> huh?
03:18:44 <maerwald> I've always used: f <$> foo <*> bar <*> baz
03:18:47 <maerwald> never liftA
03:19:47 <vaibhavsagar> what does ApplicativeDo allow you to do instead?
03:19:56 <ertes> vaibhavsagar: just use do-notation
03:20:29 <ertes> maerwald: that doesn't really help, if 'f' is actually a data constructor with a bunch of fields you keep changing
03:21:15 <maerwald> what do you mean?
03:21:25 <vaibhavsagar> What does f <$> a <*> b <*> c look like instead? "do a' <- a; b' <- b; c' <- c; return f a b c"?
03:21:45 <ertes> do x1 <- c1; x2 <- c2; x3 <- c3; pure (MyType { _x1 = x1, _x2 = x2, _x3 = x3 })
03:22:00 <ertes> the equivalent (<*>)/liftA3 version is rather ugly
03:22:21 <vaibhavsagar> (liftA3 . f) a b c?
03:22:55 <ertes> liftA3 (\x1 x2 x3 -> MyType { _x1 = x1, _x2 = x2, _x3 = x3 }) c1 c2 c3
03:23:14 <ertes> it looks reasonable, because you can read the order of things from the numbers i've written
03:23:36 <vaibhavsagar> why not (liftA3 . MyType) c1 c2 c3?
03:24:31 <ertes> vaibhavsagar: because that relies on the order of MyType's fields
03:24:41 <ertes> (and it's a type error)
03:24:49 <ertes> (liftA3 MyType c1 c2 c3)
03:25:04 <maerwald> I don't see how we get something particularly powerful here, except a bit of syntax sugar
03:25:17 <vaibhavsagar> no, (liftA3 . MyType) c1 c2 c3
03:25:21 <ertes> we get useful syntax sugar
03:25:21 <vaibhavsagar> it's different :)
03:27:55 <ertes> do blubb <- genBlubb; blah <- genBlah; foo <- genFoo; pure (MyType { _blah = blah, _blubb = blubb, _foo = foo })
03:29:11 <vaibhavsagar> Is relying on the order of fields bad? https://github.com/vaibhavsagar/duffer.hs/blob/master/src/Duffer.hs#L133-L167
03:29:22 <maerwald> if you worry about changing fields you can just use RecordWildCards
03:29:43 <maerwald> I don't see how that's particularly better with ApplicativeDo
03:30:45 <sbrg> vaibhavsagar: It isn't necessarily bad always, but it can conceivably be bad if you have multiple fields in a row that have the same type. removing or adding another field will then bump the fields up or down and might put the wrong values in the wrong places
03:31:15 <ertes> vaibhavsagar: not if you have two fields with a well-defined order that never changes
03:31:39 <ertes> vaibhavsagar: but in most projects i have larger product types with alphabetically ordered fields
03:32:09 <sbrg> > alphabetical order
03:32:10 <lambdabot>  Not in scope: ‘alphabetical’Not in scope: ‘order’
03:32:19 <sbrg> I think that's one way to order fields that has never occurred to me
03:32:20 <ertes> and ApplicativeDo makes initialising those very convenient
03:33:15 <ertes> sbrg: i use that ordering pretty consistently in my sources, because it makes navigating a lot easier =)
03:33:28 <ertes> top-level definitions, class members, constructor fields, etc.
03:33:49 <sbrg> hmm
03:34:08 <sbrg> ¯\_(ツ)_/¯ I use semantic navigation or just search
03:34:22 <sbrg> semantic-imenu or some such in emacs
03:35:08 <maerwald> https://downloads.haskell.org/~ghc/8.0.1/docs/html/users_guide/glasgow_exts.html#record-wildcards
03:36:31 <ertes> sbrg: i could probably do something like that, but i'd still keep it ordered, if only as a style choice
03:52:56 <ertes> :t L u n c h
03:52:57 <lambdabot> P i z z a
03:53:14 <prohobo> what the
03:53:27 <prohobo> :t P i z z a
03:53:28 <lambdabot> Not in scope: data constructor ‘P’
03:57:53 <AfC> If I was looking to ask questions about Intero, is there a [more] appropriate channel?
03:58:40 <srhb> AfC: This is probably fine. I don't think #haskell-emacs is concerned with much beside haskell-mode, but it may have changed.
03:59:24 <TomWalke`> hello
03:59:28 <maerwald> isn't intero pretty much emacs-only anyway?
03:59:43 <maybefbi> is it true that forkIO $ forever f only runs until the surrounding IO monad is fully evaluated?
04:00:57 <AfC> srhb: fair enough. There's obviously a point where my questions become issues I should file, but I figured I should ask around first. 
04:00:58 <sbrg> maybefbi: no, but once the processe exits(that is, when the end of main is reached) the threads are killed
04:01:34 <AfC> Anyone know if there's a way to get Intero to just enable all the available targets in a project at startup? Quite tedious to have to reselect them all each time I start Emacs.
04:01:42 <maybefbi> sbrg, ok thanks. that means i need hWaitForInput stdin (-1) to make the threads running until i desire?
04:01:49 <mniip> :k P
04:01:50 <lambdabot> * -> * -> * -> * -> *
04:01:54 <mniip> :t L
04:01:55 <lambdabot> Expr -> Expr -> Expr -> Expr -> P i z z a
04:02:32 <maerwald> :t L a m e r
04:02:33 <lambdabot> P i z z a
04:03:39 <mniip> :t undefined :: moo
04:03:40 <lambdabot> moo
04:03:47 <sbrg> maybefbi: that may be one way to do it. I personally use the async library for almost all my concurrent stuff in haskell, and I'd just use await
04:03:50 <dsm_> :info Expr
04:03:55 <sbrg> to wait for the thread to be done, if applicable
04:03:59 <sbrg> otherwise I'd do something similar
04:05:46 <maybefbi> sbrg, i have in mind something wai/warp applications do when run. they just stay blank until someone presses Ctrl + C
04:06:02 <maybefbi> or kills them process
04:06:23 <sbrg> yeah. I just normally wait for input and then kill the thread once input is received or some such. 
04:06:26 <merijn> maybefbi: I usually create an empty MVar and have the end of main do "takeMVar"
04:06:34 <sbrg> that works as well
04:06:40 <merijn> maybefbi: Then I have a signal/other thread/whatever fill the MVar when I want to exit
04:06:57 <maybefbi> nice
04:17:25 <cloudhead> is there something like a zset in haskell? Basically a set that increments a per-element counter every time an element is inserted.
04:18:01 <ertes> cloudhead: Map k Int
04:18:23 <ertes> cloudhead: add an element:  M.insertWith (+) x 1
04:18:44 <navilan> cloudhead: https://hackage.haskell.org/package/counter
04:19:09 <cloudhead> ertes: ah that's a nice trick
04:19:51 <ertes> cloudhead: similarly:  M.unionWith (+), M.insertWith (+) x (-1)
04:19:55 <cloudhead> navilan: thanks that could work too
04:19:58 <ertes> for union and delete
04:20:28 <cloudhead> ertes: if it reaches 0 though, the element will still be in the map
04:20:28 <ertes> and for lookup: M.findWithDefault 0
04:20:36 <cloudhead> ah ok
04:20:43 <cloudhead> so make the zero case the base case
04:21:07 <ertes> cloudhead: you could write a wrapper for deletion that removes the element, but consider that an optimisation rather than something you necessarily need
04:21:15 <cloudhead> thanks, that's very helpful
04:21:22 <cloudhead> yeah
04:21:42 <cloudhead> it's definitely not necessary if I do my lookups that way
04:22:03 <merijn> Probably Integer instead of Int if we wanna avoid premature optimisation
04:26:28 <zedik> Hi all. I am trying to find a way to mimic Python nested loops in Haskell. Because quite some time it is more readable than list comprehensions. What is the proper way to do it? The closest solution I found is to write it like take :  for_ [0..10] $ \i -> But I don't understand how it works. The question is 1) is it a proper way to mimic nested loops? 2) If yes, where can I read more about this syntax in order to understand how it wo
04:27:05 <zedik> I found it here http://stackoverflow.com/questions/30958975/normal-probability-density-function-gsl-equivalent-in-haskell
04:27:17 <ertes> zedik: it's not syntax, but rather just a function you apply
04:27:18 <merijn> zedik: tbh, I wouldn't use that, but I also wouldn't use list comprehensions
04:27:29 <merijn> The real answer is "what are you actually trying to do"
04:27:35 <merijn> "nested loop" -> doing what?
04:27:40 * hackagebot cabal-rpm 0.10.0 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-0.10.0 (JensPetersen)
04:27:44 <ertes> and yeah, what merijn said
04:30:57 <zedik> merijn: E.g. I need to generate nested list like that [ fn i j | i <- [1..100], j <- [1..i] ] And I want to print output in certain conditions while looping
04:31:34 <bshd> zedik: well, that's a pretty flat list though : p
04:32:46 <zedik> bshd: Yes, but fn might produce lists
04:34:10 <zedik> And they do printf from inside the loops
04:34:11 <bshd> You can do something like mapM_ [ ... ] $ \val -> when (someCondition val) $ print val
04:34:27 <bshd> Is that what you're trying to do?
04:35:31 <barrucadu> zedik: I think a more Haskelly solution would be to separate the generation of the list from the printing of certain elements
04:35:36 <zedik> bshd: what is [...] $ \val -> ? How does it work?
04:36:47 <zedik> barrucadu: For example I want to do Gaussian elimination on matrix, and I need to do output to test it
04:37:07 <bshd> forM_*
04:37:21 <srhb> zedik: It was short-hand for "insert the code you need here" :-)
04:38:11 <bshd> So, forM_ takes two arguments, [a] and (a -> m ())
04:38:44 <bshd> First one is a list of elements you're iterating over (actually a more generic container, list is just an example)
04:39:28 <bshd> And the second one is a function that takes an element (that has a same type as elements in this list) and results in a monadic action
04:40:25 <bshd> The function here is e.g. \val -> when (someCondition val) $ print val
04:41:16 <bshd> It's the same as lambda expressions in python
04:41:35 <bshd> Well, similar : p
04:44:51 <Guest8902> apparently I can't use "<-" without binding it's result to a variable, do I? http://lpaste.net/172145
04:45:09 <bshd> zedik: ah, and the dollar sign here is just syntax sugaring for forM_ [ ... ] (\val -> when (someCondition val) (print val))
04:45:27 <srhb> Guest8902: Do you know how <- desugars?
04:45:35 <Guest8902> srhb: no
04:45:54 <ahihi> the left side of <- is a pattern
04:46:04 <merijn> bshd: $ is not syntactic sugar
04:46:10 <merijn> bh$ is a regular operator
04:46:11 <zedik> bshd: Thanks!
04:46:17 <Guest8902> a variable is a pattern?
04:46:32 <mniip> it is
04:47:02 <srhb> Guest8902: What you want is simpyl Get <$> identifier, but it might be worth it to learn how do syntax works :)
04:47:04 <Guest8902> that's somewhat weird to me but okay. Is there an alternative operator that achieves what I was trying to do?
04:47:16 <merijn> Guest8902: What were you trying to do?
04:47:23 <srhb> @undo do { bar <- foo; return (f bar) }
04:47:23 <lambdabot> foo >>= \ bar -> return (f bar)
04:47:29 <srhb> Guest8902: ^
04:47:57 <mniip> @undo do { foo; return f }
04:47:57 <lambdabot> foo >> return f
04:48:59 <Guest8902> merijn: http://lpaste.net/172145 srhb: I tried that before and it yields "Expected type: [...] Kernel  Actual type: [...]  Data.Functor.Identity.Identity"
04:49:32 <srhb> Guest8902: What exactly did you try?
04:49:43 <srhb> Guest8902: fmap Get identifier?
04:49:43 <bshd> merijn: right, I was talking about its usage in this particular case though
04:49:57 <Guest8902> srhb: return Get <$> identifier
04:50:08 <srhb> Guest8902: Get rid of the return.
04:50:08 <bshd> Drop the return : p
04:50:13 <srhb> :t return
04:50:14 <lambdabot> Monad m => a -> m a
04:51:01 <srhb> Guest8902: Either you: `do { a <- identifier; return (Get a) }` or you `fmap Get identifier` -- not both. :)
04:51:06 <Guest8902> ah! It never came to mind that return is actually a function. That helps a lot. Thanks
04:51:19 <srhb> Guest8902: It's horribly named and causes a lot of confusion
04:51:30 <srhb> Guest8902: We tend to use "pure" instead these days, which minimizes conflation somewhat.
04:51:49 <Guest8902> what would that look like? pure Get <$> identifier?
04:52:07 <srhb> Guest8902: No, that's the "double trouble" again.
04:52:46 <srhb> Guest8902: do { bar <- foo; pure (f bar) } -- but again, `fmap f foo` is still nicer.
04:53:21 <srhb> Or `f <$> foo`, <$> being infix for fmap.
04:53:58 <Cale> Oh, that's interesting. Apparently TypeFamilies needs to be switched on in a module in order for GHC to be able to equate an imported associated type with its instantiation.
04:54:39 <Guest8902> is there an idiom on when to use return and when to use <$> or is it just a choice of style?
04:54:56 <srhb> Guest8902: Choose whichever is more legible.
04:55:16 <Guest8902> alright, thanks
04:55:21 <srhb> Guest8902: For short things, especially the functor/applicativy style of applying constructors over a structure, you'll almost always see <$>
04:55:34 <srhb> If you're doing some long IO'y validation stuff, do syntax is usually more clear.
04:55:55 <srhb> Basically, if it walks like an imperative program and talks like an imperative program, you might need to write it like one too, to make it legible ;-)
04:59:08 <Guest8902> just when I thought I had it. D: http://lpaste.net/172146 the do-blocks seem to differ fundamentally from functions without do-blocks
04:59:34 <srhb> Guest8902: Wait, ident is just a String
04:59:35 <ph88> hi guys
04:59:43 <liste> hi ph88 
04:59:54 <srhb> Guest8902: Before you used identifier as if it were a Parser a
05:01:13 <Guest8902> srhb: in this case ident is being passed as parameter. The naming here is a bit confusing, I give you that
05:01:43 <srhb> Guest8902: Then I need more information on what you intend  scalarAccessStmt to parse
05:02:08 <Guest8902> srhb: actually nothing. It just wraps the passed String into Get
05:02:18 <srhb> Guest8902: That's not what fmap does.
05:02:20 <srhb> :t fmap
05:02:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:02:49 <ph88> with megaparsec how can i get the position the parser stopped after it hit an error ?
05:03:07 <Guest8902> so I'd need something like (a -> b) -> a -> b, right?
05:03:09 <srhb> Guest8902: I suspect you're not saying entirely what you mean, but what you're asking for is `Get ident`
05:04:10 <Guest8902> srhb: guess you're right. I'll just leave it with the verbose version for now, thank you anyway :)
05:04:24 <srhb> Guest8902: What's the verbose version? 
05:04:40 <srhb> Guest8902: If you have one working, I'll be able to see what you actually mean. :-)
05:04:52 <ph88> what kind of monad is that m   in  https://hackage.haskell.org/package/megaparsec-5.0.1/docs/Text-Megaparsec.html  ??
05:05:05 <ph88> for function runParserT
05:05:47 <bshd> ph88: any monad :P
05:06:22 <srhb> ph88: (You can tell because it isn't further constrained, so that's a guarantee)
05:06:50 <ph88> what would be an example why runParserT can be useful in comparison to runParser ?
05:07:07 <Guest8902> srhb: just one second. My cabal file exploded in between runs. :P
05:07:15 <srhb> Guest8902: Happens :-)
05:08:35 <srhb> Guest8902: I think you want `pure (Get ident)` -- but I don't want to give incorrect advice :-P. pure being the better name for `return` for injecting a value into a context (Parser, in this case)
05:08:45 <bshd> ph88: it's a monad transformer, so it lets you wrap another monad layer into the computation
05:09:11 <bshd> Like keeping track of indentation level with a State monad
05:09:33 <srhb> Guest8902: Assuming `Get :: String -> Kernel`
05:10:53 <ph88> bshd, what would be the base monad ? the parser or state ?
05:14:20 <ph88> you two guys have a very similar name ^^
05:15:52 <srhb> There's also an sbrg occasionally, which is very confusing.
05:15:57 <srhb> :-)
05:16:31 <Guest8902> srhb: alright, verbose version is http://lpaste.net/172147 and you were right, the version with pure worked :)
05:17:00 <srhb> Guest8902: Oh, ok. It doesn't get a lot more succinct than that (but you can get rid of the `do`)
05:18:07 <Guest8902> srhb: guess I'll stick with pure. It looks somewhat cleaner
05:18:20 <srhb> Guest8902: (Well, ok, you could write `scalarAccessStmt = pure . Get` but that's just pointfree)
05:18:51 <bshd> ph88: you would be lifting functions into the state monad
05:19:19 <ph88> so the parser is inside the state monad ?
05:20:12 <justatech> i have a conflict in return function never understood it in life when return -1 or something i used
05:21:09 <srhb> justatech: I didn't understand that. Is your problem how prefix minus works?
05:22:34 <srhb> > return (-2) :: Maybe Int
05:22:35 <lambdabot>  Just (-2)
05:22:51 <srhb> > return -2 :: Maybe Int
05:22:52 <lambdabot>      Couldn't match expected type ‘Maybe Int’
05:22:52 <lambdabot>                  with actual type ‘a0 -> m0 a0’
05:22:52 <lambdabot>      Probable cause: ‘return’ is applied to too few arguments
05:23:28 <maerwald> :t return $ - 2
05:23:28 <Guest8902> is there btw something like friend-classes in c++? I was trying to unit-test the parsers in my module but I actually don't want to export them all.
05:23:29 <lambdabot> (Monad m, Num r) => m r
05:24:58 <justatech> srhb kind of 
05:25:04 <srhb> Guest8902: Stick them all in Foo.Internal and export them anyway
05:26:30 <Guest8902> srhb: so I'd make a proxy-module for my "public" functions and provide that as the API?
05:26:46 <srhb> Guest8902: Yes.
05:26:53 <Guest8902> srhb: makes sense. Thanks
05:27:30 <srhb> Guest8902: People get prickly when they can't get at internals if they _really really want to_ anyway :-)
05:28:29 <maerwald> yeah, just tell them "these are internals, so don't expect stable API"
05:31:07 <Darwin226> Hey guys. Does lens have a `Has` typeclass that's used to work with only parts of the state? I seem to recall there being something like that
05:31:08 <Guest8902> srhb: it's not as much about safety as about simplicity. I wouldn't want to give my coworker a module with a bazillion functions while all he needs is the "parseFile"-function
05:31:11 <Darwin226> But I can't find it now
05:31:44 <srhb> Guest8902: Right, exactly. :-)
05:36:56 <bshd> ph88: in a way, yes; check out some articles introducing monad transformers, should give you a better understanding
05:37:08 <sbrg> Darwin226: I think so
05:37:11 <sbrg> classy lens?
05:37:12 <sbrg> try searching for those
05:37:42 * hackagebot typerbole 0.0.0.1 - A typeystems library with exaggerated claims  https://hackage.haskell.org/package/typerbole-0.0.0.1 (Lokidottir)
05:38:22 <Darwin226> sbrg: Oh. It generates a separate class for each field.
05:38:40 <Darwin226> That makes sense I guess
05:47:42 * hackagebot ghc-typelits-presburger 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/ghc-typelits-presburger-0.1.0.0 (HiromiIshii)
05:47:44 * hackagebot typerbole 0.0.0.2 - A typeystems library with exaggerated claims  https://hackage.haskell.org/package/typerbole-0.0.0.2 (Lokidottir)
05:47:46 * hackagebot equational-reasoning 0.4.0.0 - Proof assistant for Haskell using DataKinds & PolyKinds  https://hackage.haskell.org/package/equational-reasoning-0.4.0.0 (HiromiIshii)
05:48:28 <cloudhead> in general, when defining a sum type that can have a "zero" case, do people prefer something like `Maybe MyType`, or is it better to add a "zero" constructor to MyType?
05:49:31 <maerwald> I avoid too much subtyping
05:50:03 <cloudhead> right, because it complicates the code quite a bit?
05:50:03 <liste> cloudhead: is the "zero" case always applicable?
05:50:09 <maerwald> `Maybe MyType` is also not very expressive in terms of "aha, so why Maybe"?
05:51:04 <cloudhead> liste: yeah, I mean it's just indicating a kind of zero value, like [] for [a]
05:51:43 <cloudhead> hmm you're right, the Maybe could mean various things
05:51:59 <cloudhead> whereas the explicit zero value is specific to the domain of the type
05:52:24 <Cale> Sometimes it's best to use Maybe, sometimes it's best to add a specific new constructor... it sort of requires a bit of global thinking about how the type gets used to really say what's going to be better.
05:52:36 <Cale> Maybe has the advantage that it comes with a Monad instance, among other things
05:53:03 <Gurkenglas> http://lpaste.net/8179778503860813824 <- line 34 is "makeFields ''S"
05:53:16 <liste> with a neutral element you can make your type a Monoid, if it makes sense
05:53:26 <Cale> So you get lots of operations for free -- are those operations meaningful and useful? If so, perhaps Maybe is going to be the better solution.
05:53:27 <Gurkenglas> (Also can I shut off that warning that theres no header line?)
05:54:01 <maerwald> Cale: well, you can certainly define a tree and its leafs in terms of Maybe, just so you get some free stuff, but that would still be horrible
05:54:14 <Cale> Sure
05:54:35 <Cale> It requires global understanding of how the code gets used
05:54:44 <cloudhead> makes sense
05:56:05 <Guest8902> errr... silly question. But how do I create "Foobar.Internal"? I tried having a file in "Foobar/Internal.hs" and actually naming the module "Foobar.Internal.hs" but both doesn't seem to work
05:56:52 <maerwald> "doesn't seem to work" is not a specific enough error description
05:57:00 <liste> Guest8902: filename "<source folder>/Foobar/Internal.hs", then "module Foobar.Internal(..) where .." in the file
05:57:21 <Guest8902> liste: I see, thanks
05:57:32 <cloudhead> you need to setup your .cabal file properly too Guest8902 
05:57:38 <cloudhead> have a look at existing projects
05:58:43 <Gurkenglas> http://lpaste.net/8065395965625892864 <- heres the whole code
06:02:07 <adarqui> hey, how come there's no Generic instance for Int64? any idea?
06:02:43 * hackagebot typerbole 0.0.0.3 - A typeystems library with exaggerated claims  https://hackage.haskell.org/package/typerbole-0.0.0.3 (Lokidottir)
06:02:57 <hexagoxel> Gurkenglas: you probably want `stack exec ghc -- -ddump-splices dragger.hs`
06:04:11 <hexagoxel> Gurkenglas: also, random suggestion: move `makeFields ''S` to the end of the file.
06:07:04 <Gurkenglas> That tells me rectangles, mouse, etc. are out of scope when I try to use them
06:08:26 <hexagoxel> ah, stage restriction stuff. yeah, afaik you need to put `data S` and its TH into separate module.
06:08:45 <Gurkenglas>  My problem is fixed by replacing the Monad m => m part up in the record definition by Maybe
06:12:43 * hackagebot type-natural 0.4.0.0 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.4.0.0 (HiromiIshii)
06:13:32 <lol-icon> What exactly does “readLn >>= putStrLn” do?
06:13:52 <lol-icon> I mean, which specific Read/Show instance does it pick in the end?
06:13:55 <lol-icon> instances*
06:14:08 <liste> I think it uses defaulting rules
06:14:26 <lyxia> putStrLn expects a String
06:14:41 <lol-icon> Oh, right. I meant to use a different function.
06:14:51 <lol-icon> s/putStrLn/print/
06:14:52 <liste> :t readLn >>= print
06:14:53 <lambdabot> IO ()
06:15:20 <lol-icon> Oh, I just tried it. It picks () by default.
06:15:39 <lol-icon> Is there some way to disable this defaulting behavior? It can be confusing. :-|
06:15:40 <geekosaur> only in ghci which has ExtendedDefaultRules enabled
06:15:46 <geekosaur> otherwise it picks Integer
06:15:58 <lyxia> does it not raise an ambiguity error?
06:16:06 <geekosaur> no
06:16:16 <lyxia> oh
06:16:36 <liste> geekosaur: why does it pick Integer? is there a default list somewhere?
06:17:21 <hexagoxel> lol-icon: :set -XNoExtendedDefaultRules
06:17:28 <lol-icon> Will do.
06:17:41 <geekosaur> if it is ambiguous and involves only a small list of typeclasses, it uses defaulting. 
06:17:43 <andreoss> `foo i => bar >>= f i`. how to rewrite it in point-free style?
06:17:53 <andreoss> s/=>/=/
06:17:56 <lol-icon> hexagoxel: Nice!
06:18:00 <lol-icon> Thanks.
06:18:16 * geekosaur looking for exact report references
06:18:43 <hexagoxel> lol-icon: you can put that into .ghci for persistence.
06:18:49 <lol-icon> Right.
06:19:07 <lyxia> @pl \i -> bar >>= f i
06:19:07 <lambdabot> (bar >>=) . f
06:19:10 <geekosaur> defaultings default is `default (Integer, Double)` meaning that it will try Integer, use it if it typechecks, otherwise try Double, use it if it typechecks, else fail. ExtendedDefaultRules adds () as a final fallback
06:20:13 <lol-icon> -XOverloadedStrings should add String to that list.
06:20:18 <lyxia> I see, it's a ghci thing.
06:20:48 <geekosaur> lol-icon, it can't because String is [Char] and lists add additional ambiguity iirc
06:21:28 <lol-icon> It would still try Integer and Double first, so I don't see what's the problem. :-|
06:22:11 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-790004.3.4 for how this is typed; candidates for defaulting need to involve a standard numeric typeclass and any other typeclasses must be from the Report-defined standard typeclasses. (ExtendedDefaultRules relaxes this IIRC)
06:22:29 <lol-icon> Oh.
06:30:22 <geekosaur> lol-icon, https://mail.haskell.org/pipermail/libraries/2013-August/020698.html is why you can't just add String to the default default
06:42:44 * hackagebot type-natural 0.4.1.0 - Type-level natural and proofs of their properties.  https://hackage.haskell.org/package/type-natural-0.4.1.0 (HiromiIshii)
06:50:24 <Gurkenglas> http://lpaste.net/7754078439451131904 <- The bottom error is much better readable. Can we make it assume the type mismatch to be at that point which produces the shortest error message?
06:56:08 <Gurkenglas> http://lpaste.net/172152 <- I can't figure out this last lensy error. Halp?
06:57:39 <Gurkenglas> :t ix :: Int -> Traversal' [a] a
06:57:40 <lambdabot> Applicative f => Int -> (a -> f a) -> [a] -> f [a]
06:57:59 <Gurkenglas> So now why is it saying it's only a TraversalLike' for one particular f0?
06:59:42 <mniip> Gurkenglas, your variances are off
07:00:21 <Gurkenglas> That's not in my vocabulary
07:00:30 <mniip> Gurkenglas, does the error show where f0 is bound?
07:00:47 <mniip> it's telling you that f0 is not applicative basically
07:00:54 <Gurkenglas> That's the only error and all its saying
07:00:57 <mniip> but it should be
07:01:36 <Gurkenglas> If I do not annotate time, the errors are http://lpaste.net/4869888345477480448
07:02:01 <Gurkenglas> wait no nvm
07:02:40 <Gurkenglas> If I do not annotate ix, the error is http://lpaste.net/2840496425303801856
07:03:06 <mniip> that's the same error
07:03:22 <mniip> the problem is elsewhere
07:04:09 <Gurkenglas> Refactoring like so produces these errors, presumably because you cant store traversals or something http://lpaste.net/4869888345477480448
07:06:04 <mniip> I wonder if you're hitting impredicative polymorphism here
07:06:28 <mniip> :t [ix 1, ix 2]
07:06:29 <lambdabot> (Num (Index m), Applicative f, Ixed m) => [(IxValue m -> f (IxValue m)) -> m -> f m]
07:07:07 <mniip> :t let foo = [ix 1, ix 2] in (view (foo !! 1), set (foo !! 2))
07:07:08 <lambdabot> (Num (Index s), Num (Index t), Monoid (IxValue s), MonadReader s m, Ixed s, Ixed t) => (m (IxValue s), IxValue t -> t -> t)
07:07:31 <mniip> or maybe you don't
07:10:12 <Gurkenglas> Ah well I guess Ill pass the Int rather than the Traversal' [Rectangle] Rectangle, I just noticed Im consing to the left of the list sometimes anyway, bumping all the indices
07:10:42 <Gurkenglas> Or maybe I could let the ix count from the right of the list, or maybe I should be consing new elements to the right
07:14:38 <dizzylizzy> I've got a weird one for y'all
07:15:27 <dizzylizzy> I work at a coffee shop and this guy came in to work on his laptop and somehow we started talking about programming and he couldn't stop praising the amazingness of Haskell
07:15:41 <dizzylizzy> told me to find him in here... if you're out there it's meee
07:17:10 <barrucadu> Well, I guess that's one way to advertise Haskell
07:17:19 <sbrg> lol
07:17:29 <dizzylizzy> haha
07:19:26 <Gurkenglas> http://lpaste.net/2028917545330802688 <- Can I modify my code to tell it "I know Float isnt Monoid, why would you think that?"
07:20:19 <liste> Gurkenglas: you mean giving a different error message?
07:20:39 <Gurkenglas> I want it to give a different error message, yes
07:22:45 * hackagebot network 2.6.3.0 - Low-level networking interface  https://hackage.haskell.org/package/network-2.6.3.0 (dukerutledge)
07:27:46 * hackagebot superdoc 0.1.2.4 - Additional documentation markup and Unicode support  https://hackage.haskell.org/package/superdoc-0.1.2.4 (PeterSelinger)
07:37:46 * hackagebot sized-vector 1.4.3.1 - Size-parameterized vector types and functions.  https://hackage.haskell.org/package/sized-vector-1.4.3.1 (HiromiIshii)
07:41:31 --- mode: ChanServ set -q *!*@142-196-117-128.res.bhn.net
07:42:46 * hackagebot easyrender 0.1.1.2 - User-friendly creation of EPS, PostScript, and PDF files  https://hackage.haskell.org/package/easyrender-0.1.1.2 (PeterSelinger)
07:42:48 * hackagebot haskell-src-exts 1.18.1 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.18.1 (mpickering)
07:52:46 * hackagebot newsynth 0.3.0.3 - Exact and approximate synthesis of quantum circuits  https://hackage.haskell.org/package/newsynth-0.3.0.3 (PeterSelinger)
08:01:12 <Gurkenglas> "from <- use $ (ix recti :: Traversal' [Rectangle] Rectangle) . (ffrom :: Getter Rectangle Point)" <- (Rectangle is (Point, Point), Point is (Float, Float).) Why would this make him think Float is a Monoid?
08:05:43 <barrucadu> What's the type of use?
08:05:54 <ertes> :t use
08:05:55 <lambdabot> MonadState s m => Getting a s a -> m a
08:06:26 <ertes> wow, that one is actually helpful
08:07:31 <barrucadu> All I can guess is that you're trying to use a Float as a Monoid somewhere, and ghc is thinking "well, the Float came from there, so that must be the issue"
08:07:55 <mniip> probably trying to "view" a traversal
08:08:03 <mniip> > view both ("foo", "bar")
08:08:05 <lambdabot>  "foobar"
08:08:27 <ertes> the magic of lens
08:08:50 <fr33domlover> :t view both
08:08:51 <lambdabot> (Monoid a, MonadReader (r a a) m, Data.Bitraversable.Bitraversable r) => m a
08:09:13 <Gurkenglas> :t use (ix 2) -- yep that explains it
08:09:14 <lambdabot> (Num (Index s), Monoid (IxValue s), Ixed s, MonadState s m) => m (IxValue s)
08:09:17 <ertes> does anyone else think that would better be a type error?
08:09:54 <Gurkenglas> It compiles with singular around the ix application! :)
08:09:56 <ertes> > view traverse (map Sum [1,2,3])
08:09:58 <lambdabot>  Sum {getSum = 6}
08:10:47 <mniip> :t singular
08:10:48 <lambdabot> (Functor f, Conjoined p) => Traversing p f s t a a -> Over p f s t a a
08:10:54 <mniip> sounds like cheating
08:11:00 <ertes> i think there is a point when do-what-i-mean becomes toxic
08:14:16 <EvanR> do-what-i-mean notation
08:16:09 <Gurkenglas> mniip, it is, I'm zipping (map (singular . ix) [0..]) with a list and using that lens on that list. The list might even grow later, but wont shrink
08:17:47 * hackagebot typerbole 0.0.0.4 - A typeystems library with exaggerated claims  https://hackage.haskell.org/package/typerbole-0.0.0.4 (Lokidottir)
08:24:17 <gurki> hi
08:24:31 <gurki> im trying to get https://hackage.haskell.org/package/Histogram-0.1.0.2/docs/Graphics-Histogram.html to run
08:24:46 <gurki> unfortunately i need to create some mealy in order for what i intend to do with it
08:24:49 <gurki> im stuck at
08:25:24 <gurki> http://pastebin.com/u2Hjaz8n
08:25:45 <gurki> error:
08:26:22 <gurki> http://pastebin.com/j5z35KRQ
08:26:26 <gurki> ideas? :S
08:26:34 <gurki> (the mealy part is still missing)
08:26:55 <glguy> I'll look, but in the future it's best to avoid pastebin.bin, or to provide raw links. Many people won't click on normal pastebin.com links
08:27:30 <ertes> gurki: you can't refer to the type Histogram, because it's not exported from the library
08:27:39 <glguy> gurki: This is a poorly written library that doesn't export the type "Histogram", so you can't write Histogram in your type signatures
08:27:55 <gurki> glguy: where am i expected to put my code in the future? my own webspace?
08:28:06 <gurki> glguy: any workaround?
08:28:08 <glguy> lpaste.net is the default pastebin for haskell
08:28:16 <gurki> ok. will use that in the future
08:28:42 <glguy> gurki: You can use a different library or simply avoid writing type signatures that require Histogram to appear in them
08:28:44 <ertes> gurki: well, an ugly workaround
08:28:49 <gurki> im fine with any histogram library tbh
08:28:55 <gurki> im not bound to that specific one
08:28:56 <glguy> or use partial type signatures with an extension
08:29:11 <glguy> or hack it using template haskell, but using a different library is probably the best way to go
08:29:26 <ertes> gurki: type MyHistogram = String -> PlotOptions -> IO ExitCode
08:29:38 <ertes> as far as i see plotting is the only thing you can really do with histograms in that library
08:29:46 <ertes> but yeah, i agree with glguy:  better use another one
08:30:07 <gurki> unfortunatelz i cannot use plot ... i intend to use that code for synthesizing on an fpga
08:30:42 <gurki> i actually need some sort of array or sth i can feed to whatever
08:30:49 <ertes> if you must use it, partially apply 'plot' or 'plotAdv', so you never have to refer to the Histogram type
08:31:12 <maerwald> mh, is there no diagrams package that does histograms?
08:31:33 <gurki> maerwald: throw sth into my face -> gurki is happy. checking.
08:32:12 <maerwald> I mean, you could definitely use it for that purpose, I'm just not sure if you have to come up with sth from scratch 
08:32:14 <EvanR> histogram library... map length . group
08:33:02 <ertes> plotting a list of integers isn't quite exclusive to "histogram plotters" =)
08:33:07 <maerwald> https://github.com/timbod7/haskell-chart/wiki
08:33:41 <ertes> and you can probably do it with diagrams with no extra library…  IIRC there are some examples in the gallery
08:34:05 <maerwald> coming up with proper x/y axis with numbers and crap is rather tedious though
08:34:25 <maerwald> but haskell-chart has a diagrams backend
08:34:32 <sm> yep
08:34:35 <maerwald> https://github.com/timbod7/haskell-chart/wiki#gallery
08:35:01 <sm> Chart++
08:35:33 <ertes> 7whois ChanServ
08:35:47 <gurki> i actually dont need a plot, i need some sort of double array ...
08:35:59 <ertes> gurki: with counts?
08:35:59 <gurki> i have to feed that to some other ip core in the fpga
08:36:02 <gurki> ertes: yes
08:36:10 <ertes> gurki: and what are you counting?  answer with a type
08:36:14 <gurki> creatinga  plot is gonna cause a lot of hassle
08:36:48 <gurki> ertes: im not sure my haskel foo is good enough to answer precise so im just gonna say "some image i represent by a double array"
08:36:54 <gurki> precisely*
08:37:00 <EvanR> typed madlibs... You are counting a ___(Type)___
08:37:15 <ertes> gurki: so pixels
08:37:20 <gurki> ertes: yes
08:38:09 <ertes> :t foldl' (\s x -> M.insertWith (+) x 1 s) M.empty
08:38:10 <lambdabot> (Num a, Ord k, Foldable t) => t k -> Data.Map.Map k a
08:38:43 <ertes> gurki: that one counts and gives you a map from elements to counts
08:38:53 <ertes> > foldl' (\s x -> M.insertWith (+) x 1 s) M.empty "hello there!"
08:38:54 <lambdabot>  fromList [(' ',1),('!',1),('e',3),('h',2),('l',2),('o',1),('r',1),('t',1)]
08:39:09 <gurki> ertes: still in the process of understanding how that line works
08:39:34 <ertes> gurki: do you understand left-folds on lists?
08:39:52 <ertes> > foldl' (+) 0 [3,50,800]
08:39:53 <lambdabot>  853
08:39:56 <gurki> reading https://wiki.haskell.org/Fold right now
08:39:57 <glguy> Map.fromListWith (+) [ (c,1) | c <- "hello there!" ] -- avoids reimplementing fromListWith with folds
08:39:58 <EvanR> make sure thats a strict map
08:40:13 <ertes> oh yeah, fromListWith works, too
08:40:43 <ertes> i fold by reflex =)
08:41:45 <gurki> ok i think i understand how foldl works now.
08:42:04 <EvanR> foldl != foldl'
08:42:09 <gurki> ok. so i dont.
08:42:13 <gurki> whats the difference?
08:42:33 <EvanR> foldl' has an extra seq between each recursion
08:42:48 <ertes> gurki: think of foldl' as "the foldl i should use"
08:43:10 <EvanR> it reduces the accumulator for each step down the list
08:43:27 <EvanR> foldl doesnt reduce anything until after it gets to the end of the list
08:43:30 <EvanR> if ever
08:43:42 <ertes> gurki: but see above for an even better solution
08:44:17 <ertes> > M.fromListWith (+) (map (, 1) "hello there!")
08:44:18 <lambdabot>  fromList [(' ',1),('!',1),('e',3),('h',2),('l',2),('o',1),('r',1),('t',1)]
08:44:37 <glguy> Now you're making him turn on TupleSections extension :)
08:44:50 <gurki> my brain is melting =[
08:44:51 <orion> Hi. What does this error mean?: http://lpaste.net/9044251499516919808
08:45:06 <ertes> glguy: i'm helping TupleSections make it into the next haskell standard ;)
08:45:31 <orion> My goal is to convert a "Either NoiseException (ScrubbedBytes, NoiseState c d h)" in to a "MonadThrow m => m (ScrubbedBytes, NoiseState c d h)"
08:45:35 <gurki> aaah.
08:45:54 <gurki> actually makes sense.
08:46:24 <glguy> orion: SomeException :: NoiseException -> SomeException
08:46:39 <gurki> but this would create a bin for every value there is wouldnt it_
08:46:40 <gurki> ?
08:46:46 <glguy> orion: but you might have to show the actual code
08:46:55 <ertes> gurki: isn't that what you want?
08:47:17 <glguy> gurki: If you want to process the values first: fromListWith (+) [ (process c, 1) | c <- your values ]
08:47:17 <gurki> given an image one would say "no." i can deal with theese 255 bins.
08:47:28 <gurki> though*
08:47:31 <EvanR> TupleSections not being default is annoying
08:47:53 <ertes> gurki: you can filter and map the list before you apply this function
08:48:52 <James123> Hello, I am learning haskell from a book, and I have defined >>=. However, it asks whether to use the Prelude or Main definition. Is there a way to use by default the Main definitions? (I can't use the `do' notation properly due to this fact I think)
08:48:56 <maerwald> EvanR: well: (,) 3 -- works at least
08:49:16 <glguy> James123: You can show us what you wrote with http://lpaste.net , but it sounds like you have an indentation problem
08:49:22 <EvanR> (map ((,) 3) foo) what is this, lisp
08:49:52 <ertes> that would probably be a syntax error in lisp – you have to appreciate the irony =)
08:49:58 <glguy> James123: (>>=) is a method of the Monad class, typically you won't define your own version of (>>=) but define implementations of the existing ones inside instance declarations
08:51:16 <maerwald> EvanR: I don't know what the outer braces are for
08:51:35 <wedens> suppose I have `data X = X A1 A2 A3 ... AN` and a tuple `(A1, A2, A3, ..., AN)` how can I create X from tuple without too much boilerplate?
08:51:36 <James123> Ok, I am not sure how to do that yet, but I got the basic idea.
08:51:40 <EvanR> maerwald: for exageration
08:51:53 <maerwald> well...
08:52:08 <gurki> <interactive>:3:1: Not in scope: ‘M.fromListWith’
08:52:08 <gurki> <interactive>:3:25: Illegal tuple section: use TupleSections
08:52:09 <gurki> hm
08:52:21 <ertes> wedens: there is probably a way using generics, but you may want to create the X right away without creating the tuple
08:52:30 * EvanR calls the cops on gurki 
08:52:32 <gurki> ah. "now youre making him turn on foo"
08:52:35 <gurki> sry
08:52:36 <ertes> gurki: 1. import qualified Data.Map.Strict as M
08:52:48 * hackagebot text-show 3.3 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-3.3 (ryanglscott)
08:52:52 <glguy> 2. use list comprehensions
08:53:04 <ertes> gurki: 2. if you want to use the variant without the list comprehension, you have to write the following at the top of the file:  {-# LANGUAGE TupleSections #-}
08:53:19 <wedens> ertes: yeah, I suppose it should be possible with generics. is there existing library?
08:53:40 <ertes> wedens: unlikely…  that's a very specific need
08:54:13 <EvanR> (well majority of hackages are for very specific needs, and theres alot)
08:54:32 <ertes> do we already have acme-leftpad?
08:54:33 <Darwin226> I get this "commit buffer: invalid argument (invalid character)" error when benchmarking with criterion. I think it's trying to output the little "squared" sign above "R"
08:54:39 <EvanR> of course
08:54:43 <Darwin226> I've tried setting the locale to utf8
08:54:55 <ertes> indeed, haha
08:55:01 <ertes> lovely
08:55:06 <Darwin226> This stops the error but it also makes it so there's no output whatsoever
08:55:13 <Darwin226> I'm using windows. Anyone know what else to try?
08:55:19 <glguy> wedens: If you're using the lens package, makePrisms will generate the boilerplate for that
08:55:22 <ertes> complete with hackage failing to build the docs…  perfect!
08:55:33 <glguy> ertes: which package?
08:55:38 <ertes> glguy: acme-left-pad
08:56:28 <wedens> glguy: could you elaborate? 
08:57:00 <EvanR> Darwin226: sounds like you solved the first proble
08:57:40 <Darwin226> EvanR: Well.. Maybe. Maybe no. If this "fix" just prevents all output then it never gets to the point where it crashes
08:57:48 * hackagebot typerbole 0.0.0.5 - A typeystems library with exaggerated claims  https://hackage.haskell.org/package/typerbole-0.0.0.5 (Lokidottir)
08:57:51 <EvanR> i thought windows preferred utf16
08:57:54 <ertes> Darwin226: you could try piping the output through something that discards non-ASCII characters
08:58:10 <ertes> Darwin226: if you have MSYS, this should do the trick:  | cat -v
08:58:27 <ertes> but only if it's not the haskell runtime itself that complains
08:58:35 <lpaste> glguy pasted “for wedens” at http://lpaste.net/172172
08:58:47 <Darwin226> ertes: Pretty sure it is. I'll try anyways
08:59:18 <ertes> Darwin226: not sure how to set locales for windows programs…  you could try setting LC_CTYPE as you would on unix/linux
08:59:44 <Darwin226> ertes: I tried that, but there's also a setLocaleEncoding function in GHC.IO.Encoding
08:59:45 <EvanR> we need more people like Darwin226, on windows finding problems with haskell on windows
09:00:23 <glguy> ertes: There you go :) http://hackage.haskell.org/package/acme-left-pad-3.0/docs/Data-Text-LeftPad.html
09:00:27 <glguy> such documentation!
09:00:30 <sm> Darwin226: have you tried setting LANG ? 
09:00:38 <Darwin226> EvanR: That's almost paradoxical since that very thing makes them not want to stay :D
09:00:56 <EvanR> on windows? 
09:00:58 <ertes> glguy: aw, you shouldn't have done that =/
09:01:02 <Darwin226> sm: To what do I set it to?
09:01:13 <Darwin226> EvanR: On Haskell I guess.
09:01:20 <EvanR> boo
09:01:20 <sm> en_US.UTF-8, eg
09:01:32 <wedens> glguy: well, I need the opposite :/ (Int,Char,Bool) -> X
09:01:57 <Darwin226> EvanR: I'm guessing that you'll find as many people willing to ditch Windows for Linux because of a language as you would willing to go the other way
09:02:03 <Darwin226> i.e. not many
09:02:10 <ertes> wedens: _MyPrism # (a, b, c)
09:02:11 <glguy> wedens: Then you'd use "review _Y" :(
09:02:29 <wedens> glguy: ah. thanks
09:02:46 <EvanR> Darwin226: catch 22
09:03:36 <EvanR> but unlike windows for server software, theres kind of no excuse for bad haskell experience
09:03:48 <Darwin226> So I've tried utf16, tried piping through cat -v, tried setting LANG
09:03:50 <Darwin226> no dice
09:04:00 <orion> glguy: https://gist.github.com/centromere/a997ebbc48270a0c8bc941255c8b7b09
09:04:03 <Darwin226> utf16 outputs nothing, the other two crash
09:04:40 <sm> Darwin226: http://stackoverflow.com/questions/33156758/get-haskell-programs-to-assume-a-utf8-locale-under-wine recommends CHCP
09:04:43 <Darwin226> EvanR: Except for the MAX_PATH issues. That's kind of excusable
09:05:34 <glguy> wow, that's some arrows
09:05:41 <Darwin226> sm: Yeah, I did that already. My terminal is set to the UTF8 "codepage"
09:05:48 <ertes> Darwin226: that might be worth a bug report…  i know it's old-school, but perhaps it would be best for libraries like criterion not to drop such a anti-portability bomb just to get pretty superscripts
09:06:11 <sm> this should be easier. #ghc should know, I would ask there
09:06:25 <Darwin226> I'll try asking in #ghc
09:06:28 <Darwin226> Thanks guys
09:06:51 <sm> it's kind of a pain on unix too, if you don't happen to have LANG set right
09:07:21 <glguy> orion: There might be more problems, but does the top-most 'right' have the right type to return a 'm (ByteString, NoiseState c d h)' ?
09:08:17 <pedercio> hello, i am writing a palindrome check as an exercise. I have seen the examples, but I am trying to understand what I am doing wrong in palin (x:xs:y)    | x==y = palin xs   | otherwise = False
09:08:39 <pedercio> your help understanding the pattern would be appreciated
09:09:02 <EvanR> thatd be a type error
09:09:20 <EvanR> x is an element of a list and y is a list
09:09:24 <glguy> pedercio: You've named the first element x, the second element xs, and the rest y
09:09:45 <pedercio> oh, I see. Is there a way to have element,list,element?
09:10:12 <glguy> not in a pattern, lists are (x:y) and [] as far as pattern matching is concerned
09:10:12 <magneticduck> pedercio: [a] is a linked list
09:10:25 <magneticduck> getting its last element is O(n)
09:10:40 <EvanR> in some languages you can split it like that
09:10:42 <magneticduck> pattern matches just deconstruct data in primitive ways
09:10:43 <EvanR> but not haskell
09:10:51 <magneticduck> s/deconstruct/deconstructs
09:11:12 <ertes> i wish people wouldn't refer to [] as a "linked list type"
09:11:20 <magneticduck> well, what is it?
09:11:25 <ertes> a list type
09:11:32 <pedercio> EvanR, glguy, magnetigduck: thank you a lot. I understand.
09:12:00 <magneticduck> I have been brought to believe that fundamentally it's a linked list type
09:12:04 <glguy> ertes: even better it's *the* list type :)
09:12:14 <ertes> magneticduck: a linked list is a particular low-level representation, and [] lists may end up using it, but in most *proper* scenarios they wouldn't
09:12:23 <EvanR> its clearly the (Either () (,))-coalgebra
09:12:31 <maerwald> you can do: (x:xs@(_:_)) and then safely call "last cs"
09:12:42 <maerwald> "last xs"
09:12:44 <maerwald> I mean
09:12:50 <glguy> maerwald: did you mean:   cs@(_:_)?
09:12:53 <maerwald> no
09:13:12 <pedercio> @maerwald: and then xs is a so-called as pattern?
09:13:12 <lambdabot> Unknown command, try @list
09:13:17 <glguy> ah, I see what you were writing now
09:13:18 <ertes> glguy: well, not sure about that, but i'm fine with it, as long as we don't mix up levels of abstraction =)
09:13:39 <maerwald> pedercio: the problem with doing (x:xs) and then calling "last xs" is that "xs" could be an empty list
09:13:47 <maerwald> the pattern matching I do makes sure it's not
09:13:56 <maerwald> so "last" cannot fail
09:14:07 <EvanR> levels of abstract form a cumulative hierarchy ... and youll probably never need anything but the bottom level ;)
09:14:13 <EvanR> -ion
09:14:17 <glguy> (x:xs@(:){})
09:14:51 <glguy> > let f (x:xs@(:){}) = (x,last xs) in f "records!"
09:14:52 <lambdabot>  ('r','!')
09:15:34 <ertes> pedercio: is there a particular reason to write it recursively?
09:15:53 <pedercio> @ertes: just for learning
09:15:53 <lambdabot> Unknown command, try @list
09:16:04 <glguy> pedercio: @ is for bot commands, not addressing people
09:16:08 <pedercio> oh
09:16:10 <pedercio> sorry
09:16:38 <EvanR> @ prefix on twitter is so annoying
09:16:55 <EvanR> after so many years of email having two parts
09:17:02 <pedercio> it's 20years since i have not used irc...i apologize
09:17:15 <glguy> You're not in trouble
09:17:16 <ertes> EvanR: yeah, it costs a whole character =/
09:17:51 <pedercio> thank you glguy for the pattern. i will go back learning haskell.
09:18:13 <glguy> pedercio: You should probably stick to   (_:_) instead of (:){}, fwiw
09:18:35 <ertes> (:){}?  never seen that one before
09:18:48 <glguy> I don't think *I've*  ever seen someone use (:){} before I did it today
09:19:11 <ertes> it wouldn't even have occurred to me that it's possible
09:22:49 * hackagebot bitx-bitcoin 0.10.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.10.0.0 (tebello_thejane)
09:24:52 <ertes> > let 1{} = 1 in 2
09:24:53 <lambdabot>  <hint>:1:5: Parse error in pattern: 1 {}
09:28:15 <texasmynsted> maybe not the ideal place to ask, but what are some good general references for low-level concurrency?
09:29:09 <EvanR> the concurrent haskell paper!
09:29:31 <EvanR> the concurrency book by simon marlow
09:29:37 <dmj`> @google parallel and concurrent programming in haskell
09:29:38 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
09:29:38 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
09:33:48 <Zemyla> So suppose I have a type Node s a = Node2 s a a | Node3 s a a a and a type Digit s a = Digit2 s a a | Digit3 s a a a | Digit1 s a | Digit4 s a a a a.
09:34:45 <Zemyla> Is it "safe" to have a function nodeToDigit :: Node s a -> Digit s a; nodeToDigit = unsafeCoerce?
09:35:12 <EvanR> what is this, C?
09:35:17 <Zemyla> I mean, since the first two possibilities have the same representation, will it work?
09:35:36 <Zemyla> Yeah, it probably won't work reliably. :V
09:35:47 <EvanR> they might have the same presentation
09:40:08 <glguy> Zemyla: It might work, but it's not documented to work, so it could stop working at any time
09:50:13 * fr33domlover is building fresh app with LTS 6.5, getting invalid .hi file errors for several packages :-/
09:51:01 <fr33domlover> is this a known issue? I'd update stack but I already did
09:51:37 <texasmynsted> thank you.  Is there also a resource that is not specific to haskell that I should look at as well?
09:52:50 * hackagebot wraxml 0.4.4.1 - Lazy wrapper to HaXML, HXT, TagSoup via custom XML tree structure  https://hackage.haskell.org/package/wraxml-0.4.4.1 (HenningThielemann)
09:57:50 * hackagebot http-monad 0.1.1.1 - Monad abstraction for HTTP allowing lazy transfer and non-I/O simulation  https://hackage.haskell.org/package/http-monad-0.1.1.1 (HenningThielemann)
10:02:51 * hackagebot llvm-extra 0.6.0.1 - Utility functions for the llvm interface  https://hackage.haskell.org/package/llvm-extra-0.6.0.1 (HenningThielemann)
10:02:53 * hackagebot fortran-src 0.1.0.2 - Parser and anlyses for Fortran standards 66, 77, 90.  https://hackage.haskell.org/package/fortran-src-0.1.0.2 (DominicOrchard)
10:05:48 <the_2nd> I keep getting the error : installed package info from too old version of cabal (key field does not match id field" when trying to add Hunit to my .cabal
10:08:07 <the_2nd> any idea?
10:11:53 <glguy> Maybe you installed HUnit previously with an old version of cabal and you need to reinstall it now with the new one?
10:12:51 * hackagebot text-show-instances 3.3 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-3.3 (ryanglscott)
10:17:51 * hackagebot synthesizer-alsa 0.5.0.3 - Control synthesizer effects via ALSA/MIDI  https://hackage.haskell.org/package/synthesizer-alsa-0.5.0.3 (HenningThielemann)
10:22:30 <the_2nd> glguy, problem already exists when adding a new executeable to the .cabal
10:22:37 <fr33domlover> I get this when doing `stack install`: http://paste.rel4tion.org/368
10:23:08 <fr33domlover> I tried removing ~/.stack and ./.stack, didn't help
10:23:17 <the_2nd> glguy, ah great, now it is completly broken :D
10:23:35 <glguy> the_2nd: I can only guess what you typed
10:23:39 <fr33domlover> What do I have to wipe / update to fix that? :P
10:25:35 <glguy> fr33domlover: It looks like something is wrong with your system installed GHC, array package specifically, at least
10:25:36 <Zemyla> On a completely different topic: MFunctor has the function hoist :: (Functor g) => (forall x. f x -> g x) -> t f a -> t g a. And there is an analogous class I thought about, MFoldable with mfold :: (Applicative g) => (forall x. f x -> g x) -> t f a -> g a.
10:25:38 <glguy>  /opt/ghc/7.10.3/lib/ghc-7.10.3/array_67iodizgJQIIxYVTp4emlA
10:25:49 <Zemyla> Is there a Traverable equivalent?
10:26:39 <glguy> fr33domlover: I don't know how you got a truncated .hi file, but you'll probably need to reinstall your GHC. Array package comes with GHC
10:26:46 <fr33domlover> glguy, I didn't touch these files and their mtime is in 2015. I do my regular stack build during development, and then when I want to stack build the "production" version as a different user but with the same GHC, that error happens
10:27:15 <the_2nd> glguy, seems like it would try to use another ghc when building as when installing
10:27:25 <the_2nd> it's a .cabal with mixed library and executeable
10:27:40 <the_2nd> cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.24.0.0, now Cabal-1.22.5.0). Additionally the compiler is different (was ghc-8.0, now ghc-7.10) which is probably the cause of the problem.
10:27:48 <the_2nd> install => build
10:28:03 <the_2nd> install => configure => build yields the same problem as above
10:29:14 <glguy> the_2nd: install isn't part of the configure,build,copy,register sequence
10:29:17 <glguy> it reruns configure
10:29:53 <the_2nd> glguy, it is a library with example executeables
10:30:03 <glguy> sure
10:30:11 <slack1256> I want a Map/Tree I can index by two different kinds of key (for each element). Does somebody know a package I could look for?
10:30:16 <the_2nd> hm, how do i compile both correctly?
10:30:18 * fr33domlover is apt-get reinstalling GHC
10:30:25 <geekosaur> ...
10:30:49 <glguy> the_2nd: cabal configure; cabal build, will build the library and executables
10:30:54 <geekosaur> was too slow. wanted to verify sha1sum of that .hi file since the path and abi hash tells me this is hvr's
10:30:56 <nitrix> slack1256: As in literally two set of indexes or a key that's data Key = Key a b  ?
10:31:05 <EvanR> slack1256: well theres IxSet
10:31:20 <EvanR> which gives you any number of indexes into the same set
10:31:59 <slack1256> nitrix: yes, but usally I know only one of the components, to query I should know both
10:32:08 <slack1256> s/usally/usually/
10:32:13 <slack1256> EvanR: Checking out!
10:32:19 <the_2nd> glguy, same problem then
10:32:21 <EvanR> oh you want one key with two components
10:32:46 <slack1256> no no, it is kind of a relational thing!
10:32:48 <nitrix> slack1256: Can we just clarify again. You want two keys for the same value or a key with two components?
10:33:22 <glguy> the_2nd: then you'll have to start pasting cabal files and error messages to a pastebin, those are the right commands
10:33:26 <slack1256> two keys for the same value. Such that if I operate (say delete) on only one key, the entry is deleted for the two keys
10:33:54 <slack1256> IxSet kinf of looks like what I want!
10:34:04 <nitrix> slack1256: I see. Look into ixset, but because this is what I'm actually researching, I shall show you later on what I'm working on.
10:34:48 <nitrix> slack1256: I'm working on a relational library that allows relations between independent cells with O(1) complexity.
10:35:00 <EvanR> slack1256: yeah IxSet does this, except its type system is a little funky
10:35:32 <nitrix> You can even specify the backend source of the relations (which are loading and unloaded as necessary, from the disk or network).
10:35:32 <slack1256> nitrix: Seriously? Awesome, yep I would be glad you notify me when you publish code or some of your work!
10:35:39 <nitrix> It's for a game :)
10:35:47 <fr33domlover> huh, looks like reinstalling GHC helped. It now continues to build packages
10:36:06 <slack1256> EvanR: yeh, but more than using it I want to know how they did it ;-)
10:36:34 <EvanR> slack1256: that part is simple, the set is a set, and each index is a map from keys to subsets
10:36:37 <slack1256> it is really cool when you have a doubt and find someone who is already working on the same thing!
10:36:46 <nitrix> slack1256: The second part of the project is adding a concept similar to FRP where we allow manipulating resources over time even though they aren't loaded, for procedurally generated infinite words that have relations between over so long distances that you can't possibly keep them all loaded at the same time.
10:36:46 <EvanR> er, by key i mean the value of an index function
10:37:19 <slack1256> EvanR: oh, that seems simple conceptually, nice
10:37:39 <nitrix> slack1256: I'm sorry I can't word this much better, but it's a typical problem in video games and I've found none of the current solutions sufficient so I'm working on my own :)
10:37:52 * hackagebot rebase 1 - A more progressive alternative to the "base" package  https://hackage.haskell.org/package/rebase-1 (NikitaVolkov)
10:37:52 <EvanR> so you can index by field, or by word lengths, or whatever computable property of the elements
10:37:56 <nitrix> But in your case, ixset is probably more than enough.
10:39:10 <conal> nitrix: you might want lazy *un*evaluation in addition to lazy evaluation in that case. i played with something similar for infinite-extent, infinite-resolution data representations of continuous, infinite imagery.
10:39:11 <slack1256> nitrix: don't worry, that part of procedurally generated infinite words of relation is something I can imagine (like the comonad instance for conway's life) It still interest me because you are right, seems like a common situation
10:39:43 <conal> nitrix: i was putting most of the data representation into GPU memory.
10:39:51 <nitrix> conal: I think I've brought the subject with you, but we only skimmed the surface. You can be sure I'll have an elaborated talk with you when I get to phase 2 :)
10:40:41 <conal> nitrix that investigation prompted http://conal.net/blog/posts/topless-data
10:40:49 <nitrix> The whole "keeping the simulation of the word going, in respect to their relations", when you don't actually have everything loaded and doing lazyly is fascinating and ressembles FRP a lot.
10:41:06 <the_2nd> https://github.com/I3ck/HGE2D/blob/master/HGE2D.cabal
10:41:14 <nitrix> conal: checking.
10:41:17 <the_2nd> I can cabal install, but cabal build fails
10:41:44 <the_2nd> "installed package info from too old version of cabal (key field does not match id field)"
10:42:07 <glguy> the_2nd: paste the full terminal transcript, too so we can do as little guesing as possible
10:43:29 <conal> nitrix: sounds like a fun project. good luck!
10:44:02 <the_2nd> glguy, http://pastebin.com/QdjnJnSz
10:44:19 <slack1256> Does modularity have a formal definition (as strict functions have?). In why functional programming matters it seems it used for "separates generation from consumption"
10:44:26 <slack1256> I wonder if that is a common definition
10:44:45 <glguy> the_2nd: What's the output from: cabal --version
10:45:10 <nitrix> slack1256: I'm more temptated to say Haskell modules are about separation of concerns.
10:45:22 <nitrix> They aren't as glorified as, say, SML modules.
10:45:25 <the_2nd> "cabal install version 1.22.9.0 using version 1.22.5.0 of the cabal library"
10:45:43 <glguy> the_2nd: You need to use Cabal-1.24 with GHC 8.0.1
10:45:51 <EvanR> slack1256: heres something qualitative, modular components can be taken apart easily
10:45:54 <slack1256> nitrix: oh, I should clarifity on the context of lazy evaluations. As when people say laziness is more modular
10:45:59 <conal> slack1256: i've never encountered a precise definition of modularity. the why FP paper emphasized that non-strictness is very helpful for modularity, but what modularity is exactly, i don't know.
10:46:02 <glguy> the_2nd: Are you using GHC 8.0.1?
10:46:37 <the_2nd> yep
10:46:45 <glguy> OK, time to update Cabal and then cabal-install
10:46:58 <the_2nd> can i update cabal from cabal?
10:47:06 <glguy> actually Cabal is already 1.24 distributed with GHC 8.0.1
10:47:08 <slack1256> conal: just how I thought ;-)
10:47:09 <EvanR> if you take this property seriously, many traditional forms of modularity arent modular at all
10:47:11 <glguy> so you just need cabal install cabal-install
10:47:18 <EvanR> OOP, structured programming, imperative programming
10:48:06 <conal> slack1256: and it's a denotational issue (non-strictness) rather than an operational one (laziness).
10:48:16 <EvanR> if composability is "easily put things together" maybe modularity is the opposite
10:48:49 <EvanR> nothing says a composable type can easily be decomposed once composed
10:48:54 <glguy> the_2nd: There are also binaries https://www.haskell.org/cabal/download.html
10:49:00 <slack1256> I am not CS trained so went I read WhyFPmatter it seemed odd that modularity was about separating generation from consumption. I honestly thought very few algorithms cared about that.
10:49:08 <slack1256> s/went/when/
10:49:15 <mnoonan_> EvanR: modularity = mposability?
10:49:26 <EvanR> lol
10:50:11 <conal> slack1256: very few algorithms are written with the degree of modularity that Why FP demonstrates. but that's a drawback in how those algos are usually written.
10:50:18 <EvanR> in practice though we can easily decompose stuff because we leave it in the original syntactic form
10:50:24 <enthropy> maybe generation and consumption is just one possible way to divide up a problem into manageable pieces that are straightforward to merge
10:50:25 <the_2nd> glguy, I ran the install and now have cabal 1.24
10:50:33 <the_2nd> but version still prints the same string as above
10:50:47 <conal> slack1256: sometimes people don't care (or don't want to) until they see a better way.
10:50:53 <EvanR> enthropy: and take apart afterward
10:50:55 <enthropy> and the WhyFPmatter just picked that as one example
10:51:14 <EvanR> writing ruby gems is apparently really easy, splitting them up however
10:51:28 <EvanR> once they are big balls of mud is hard
10:51:51 <glguy> the_2nd: you'll need to check where "cabal install cabal-install" installed the cabal executable, usually ~/.cabal/bin, and that should be in your path, it could also be an issue of the path being cached which can be resolved (in bash) with hash -r, or just opening a new terminal
10:52:03 <enthropy> sounds good EvanR
10:52:15 <slack1256> which is the opposite in haskell where extracting sub-structure is easy (because of purity) and it mostly works well at runtime (because of laziness)
10:53:01 <EvanR> or you end up chewing through memory because of laziness, one of the two ;)
10:53:21 <the_2nd> glguy, auto update didnt work, so I only have to set the path now I guess
10:53:31 <slack1256> how my teacher used to say "this is correct (modulo good will)"
10:57:52 * hackagebot synthesizer-dimensional 0.7.0.3 - Audio signal processing with static physical dimensions  https://hackage.haskell.org/package/synthesizer-dimensional-0.7.0.3 (HenningThielemann)
11:07:53 * hackagebot stack-run 0.1.1.1 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.1.1 (yamadapc)
11:17:09 <nak> is it possible to define a thunk ?
11:19:04 <nak> more specifically, a nullary function
11:22:37 <srhb> nak: Nullary function, no. Thunks, you make all the time.
11:22:49 <nak> srhb ^_^
11:22:58 <nak> yeah i realized the thunk question was dumb
11:23:01 <glguy> nak: There aren't nullary functions, but what are you trying to do?
11:23:54 <nak> glguy i was actually working on some javascript stuff and was wondering how you'd model it in haskell
11:24:04 <nak> e.g., js has Math.random() which is ... quite weird
11:24:29 <mniip> that's not referentially transparent
11:24:32 <srhb> nak: Because it has side effects?
11:24:40 <nak> srhb mostly because it doesn't take an argument
11:24:42 <glguy> You'd use an action for that possibly with type: IO Double
11:24:59 <nak> in js you call a function with (), but in haskell there's no such thing lol
11:25:05 <erisco> wow, SO documentation, so sad
11:25:13 <srhb> nak: Sure, just make functions take () arguments! :-)
11:25:16 <EvanR> its definitely not a pure function
11:25:20 <glguy> nak: Yeah, in Haskell functions are different from actions
11:25:29 <srhb> It'll still not be side effecty though
11:26:25 <erisco> I documented all the common list pattern match syntax with an explanation of what they are, things like the difference of (a:b) and [a,b]
11:26:34 <erisco> this has been completed erased now by other people
11:26:41 <EvanR> nak: random, one way is to pass in and get back a generator. another way is to use randomIO to use the system generator as a side effect. another way is to use a random monad
11:26:46 <erisco> every single line I wrote has been erased
11:27:00 <tdammers> the concept is flawed
11:27:02 <nak> i was more so looking at js source code `g()` as weird because there's no way to write that in haskell, right ?
11:27:03 <glguy> erisco: Other people deleting what you wrote is the magic of SO in general, not even just the documentation section
11:27:07 <erisco> this is a mess of too many chefs
11:27:10 <tdammers> crowd-sourced documentation, I mean
11:27:12 <nak> like if i had function g in haskell, how can you apply it with zero args ?
11:27:26 <glguy> nak: JavaScript conflates actions and functions, Haskell separates them
11:27:28 <dmwit> nak: Like this: `g`
11:27:50 <glguy> nak: All functions in Haskell are functions of a single argument, some functions return functions as their result
11:27:53 * hackagebot stack-run 0.1.1.2 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.1.2 (yamadapc)
11:27:55 <dmwit> nak: ...those are markdown backticks, not part of the suggested code, by the way.
11:28:06 <dmwit> :t randomR
11:28:07 <EvanR> nak: a function with no arguments is just a constant, so g() has to be about side effects, so you need to model the effects somehow 
11:28:07 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
11:28:29 <EvanR> like IO
11:28:40 <srhb> But g() would actually be similar to having no arguments, because () is meaningless (it only has one value, namely () )
11:28:45 <dmwit> :t random -- perhaps even closer to JS's Math.random
11:28:46 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
11:28:54 <srhb> > let g () = 42 in g()
11:28:55 <nak> dmwit i was trying to focus less on the side-effect behavior of math.random and more that js allows you to apply a function with zero args
11:28:56 <lambdabot>  42
11:29:02 <srhb> You now have a function that takes () and produces 42, every time.
11:29:03 <EvanR> :t randomIO
11:29:06 <lambdabot> Random a => IO a
11:29:06 <nak> i've taken this concept for granted. but when i think in haskell... that's a weird way to think
11:29:11 <nak> that's all i was trying to get at
11:29:12 <erisco> my entire section on syntax was erased with things that are *not* syntax!
11:29:18 * erisco *facepalms*
11:29:39 <srhb> nak: Yes, you're right. :)
11:29:50 <nak> srhb, so g() is actually valid haskell ?
11:30:00 <EvanR> g ()
11:30:02 <srhb> Sure, it's a function from () to whatever.
11:30:05 <srhb> g() is fine.
11:30:08 <EvanR> gross
11:30:10 <nak> lol
11:30:23 <srhb> () is the empty tuple, by the way.
11:30:25 <dmwit> > let g() = 3 in g()
11:30:25 <EvanR> > let f x = x+1 in f5
11:30:27 <lambdabot>  3
11:30:28 <lambdabot>      Not in scope: ‘f5’
11:30:28 <lambdabot>      Perhaps you meant one of these:
11:30:28 <lambdabot>        ‘f’ (line 1), ‘f’ (imported from Debug.SimpleReflect),
11:30:34 <srhb> (Or the type of the empty tuple, depending on how you squint)
11:30:47 <nak> EvanR i agree that the space looks better
11:30:59 <srhb> > () :: () -- very useful!
11:31:00 <lambdabot>  ()
11:31:18 <dmwit> > () :: () :: * :: *
11:31:20 <lambdabot>  <hint>:1:10: parse error on input ‘::’
11:31:22 <nak> let f x = 5 in f ()
11:31:26 <nak> > let f x = 5 in f ()
11:31:28 <lambdabot>  5
11:31:38 <nak> > let f = 5 in f ()
11:31:40 <lambdabot>      No instance for (Show a0)
11:31:40 <lambdabot>        arising from a use of ‘show_M883355935917172372514289’
11:31:40 <lambdabot>      The type variable ‘a0’ is ambiguous
11:31:43 <nak> ok good
11:31:47 <nak> > let f _ = 5 in f ()
11:31:49 <lambdabot>  5
11:32:07 <nak> yeah that's so weird
11:32:13 <nak> i'm glad that looks as ugly as it does
11:32:15 <srhb> :)
11:32:21 <nak> because writing nullary functinos in js makes no fricken sense to begin with
11:32:22 <dmwit> > let f = 5 in f () :: Integer
11:32:24 <lambdabot>      No instance for (Num (() -> Integer))
11:32:24 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
11:32:24 <lambdabot>        arising from a use of ‘f’
11:32:25 <srhb> Besides you can just paranthesize your arguments however you like
11:32:42 <EvanR> nak: "nullary procedures" otoh
11:32:49 <srhb> > let foo(x) = x in foo(3)
11:32:51 <lambdabot>  3
11:32:56 <srhb> Look how beautiful it is
11:33:11 <EvanR> f(()) 
11:33:37 <dmwit> ?let instance Num a => Num (b -> a) where fromInteger n = pure n; (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*)
11:33:38 <lambdabot>  .L.hs:191:25:
11:33:38 <lambdabot>      Couldn't match type ‘a’ with ‘Integer’
11:33:38 <lambdabot>        ‘a’ is a rigid type variable bound by
11:33:43 <erisco> I didn't foresee this problem, but it seems like a death knell to me
11:33:59 <erisco> or if it isn't I fear for the quality of documentation people regularly refer to
11:33:59 <dmwit> ?let instance Num a => Num (b -> a) where fromInteger n = pure (fromInteger n); (+) = liftA2 (+); (-) = liftA2 (-); (*) = liftA2 (*)
11:34:00 <lambdabot>  .L.hs:190:10: Warning:
11:34:00 <lambdabot>      No explicit implementation for
11:34:00 <lambdabot>        ‘abs’ and ‘signum’
11:34:10 <dmwit> > let f = 5 in f () :: Integer
11:34:12 <lambdabot>      No instance for (Num (() -> Integer))
11:34:12 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
11:34:12 <lambdabot>        arising from a use of ‘f’
11:34:15 <EvanR> erisco: why are you putting that documentation on stack overflow anyway
11:34:23 <erisco> EvanR, points
11:34:26 <EvanR> host it somewhere yourself, then they cant overwrite it
11:34:33 <EvanR> did you keep your points after it was overwritten?
11:34:38 <erisco> and they can't find it either :P
11:34:51 <dmwit> Why is there no instance for `Num (() -> Integer)`?
11:34:51 <EvanR> link it on haskell wiki
11:34:51 <erisco> I kept my points
11:34:57 <EvanR> ok then no problem
11:35:31 <nak> i think *a* problem with SO documentation is that it's going to happen no matter what; but can we prevent it from getting populated by the wrong people
11:35:39 <nak> often times, the dumbest people are the most eager to speak
11:35:51 <EvanR> Num x => Num (() -> x) would overlap with peoples ever so clever other function instances for ->
11:36:16 <nak> also, i'm pretty sure every language agnostic tag is going to be filled with C# and Java examples
11:36:16 <tdammers> I think documentation is just a much lousier fit for the SE format than questions about programming problems
11:36:44 <erisco> the other problem is that there is more than one way to explain something, yet people will vie for their favourite
11:36:50 <erisco> edit wars
11:36:58 <nak> erisco yeah true
11:37:04 <dmwit> EvanR: "other function instances for ->"?
11:37:13 <EvanR> yeah
11:37:24 <dmwit> EvanR: What is a "function instance for ->"?
11:37:28 <erisco> some people will prefer the most dense, concise possible documentation
11:37:28 <EvanR> er
11:37:32 <EvanR> Num instance
11:37:35 <erisco> others will want a more elaborated explanation
11:37:47 <nak> erisco spooooon feed meeeee
11:37:48 <dmwit> EvanR: Also: I'm not asking "why" in the philosophical sense. I'm asking in the mechanical sense. I defined the instance above, in case you missed it, and I'm asking why it's not present.
11:38:02 <EvanR> somebody must have deleted it
11:38:24 <nak> can someone tell me how (f 1 *) is evaluated
11:38:36 <erisco> so you'll have arguments on one side saying the elaborated explanation is unnecessarily verbose and irrelevant, and arguments on the other saying the dense explanation is impenetrable and unrelatable
11:38:36 <srhb> nak: Do you know about sections?
11:38:36 <nak> ((f 1) *)
11:38:40 <EvanR> same as (x *)
11:38:52 <nak> srhb i don't think so
11:38:56 <nak> (re: sections)
11:39:02 <erisco> arguments saying sandwiches make better analogies than burritos
11:39:03 <dmwit> nak: `(f 1 *)` is supposed to behave the same as `\x -> f 1 * x`, if that's helpful.
11:39:14 <srhb> nak: Operator sections allow you to place an operator with one side missing, and the function you get will take the missing side as an argument.
11:39:19 <srhb> What dmwit said.
11:39:41 <srhb> > ((/2) 2, (2/) 2)
11:39:43 <nak> ok so how is (f 1 * x) evaluated lol
11:39:43 <lambdabot>  (1.0,1.0)
11:39:45 <srhb> Err
11:39:49 <srhb> > ((/2) 1, (2/) 1)
11:39:51 <lambdabot>  (0.5,2.0)
11:39:58 <dmwit> > let f = 5 in f() :: Integer -- nak
11:40:00 <lambdabot>  5
11:40:09 <EvanR> dmwit: er, not (*) (f 1) ?
11:40:14 <dmwit> (This is a prank. Don't take this code snippet seriously.)
11:40:16 <Robin_Jadoul> > let f = 5 in f()()()()()()()()
11:40:19 <lambdabot>  5
11:40:20 <erisco> what is this sorcery dmwit ?
11:40:33 <hpc> erisco: instance Num a => Num (b -> a) where
11:40:34 <erisco> :t ()
11:40:35 <lambdabot> ()
11:40:42 <erisco> okay, making sure someone didn't override it
11:40:42 <srhb> nak: Functions have highest precedence, so evaluate f 1, then the result of that times x
11:40:48 <hpc> :t let ?f = 5 in f ()
11:40:50 <lambdabot> FromExpr t => t
11:40:54 <srhb> function application, rather.
11:40:56 <hpc> >:(
11:41:03 <dmwit> :t 5 :: a -> Integer
11:41:04 <lambdabot> a -> Integer
11:41:10 <hpc> :t let ?f = 5 in (f (), f)
11:41:11 <erisco> that's brutal
11:41:12 <lambdabot> (FromExpr t, FromExpr t1) => (t, t1)
11:41:16 <hpc> i give up
11:41:18 <nak>  \x -> ((f 1) * x)
11:41:21 <nak> so this ?
11:41:25 <dmwit> > (sin^2 + cos^2) 30
11:41:27 <lambdabot>  1.0
11:41:37 <geekosaur> :t let ?f = 5 in (?f (), ?f)
11:41:39 <lambdabot> Num t => (t, () -> t)
11:41:42 <dmwit> > map (sin^2 + cos^2) [1..10]
11:41:44 <lambdabot>  [1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0.9999...
11:41:54 <srhb> nak: Well, you didn't have any arguments in (f 1 * x)
11:41:58 <hpc> geekosaur: shouldn't it be putting (?f :: ...) into the context?
11:42:09 <srhb> nak: But in (f 1 *), yes
11:42:19 <dmwit> EvanR: I said *supposed to*, not *does*. ;-)
11:42:20 <hpc> and then you can just refer to f?
11:42:28 <dmwit> EvanR: (The Report and GHC disagree on this point.)
11:42:36 <EvanR> splendid
11:42:54 * hackagebot mohws 0.2.1.5 - Modular Haskell Web Server  https://hackage.haskell.org/package/mohws-0.2.1.5 (HenningThielemann)
11:42:59 <erisco> people write sin^2(x) + cos^2(x), but close enough I guess
11:43:44 <dmwit> > sin^2(10) + cos^2(10)
11:43:46 <lambdabot>  <Double -> Double>
11:43:53 <erisco> I'll be impressed when sin^-1 works
11:44:04 <dmwit> Ah, right, the precedence is just a bit off there.
11:44:21 <nak> everyone: thanks for the help
11:44:25 <geekosaur> hpc, the ?f I think should have been in the context, but iirc the ? is always needed to keep the namespace of implicits separate?
11:44:49 <hpc> ah, maybe that was it
11:45:14 * hpc defends himself with "implicits are terrible and using them often enough to know how they work is also terrible"
11:45:16 <dmwit> :t (?f (), ?f)
11:45:17 <hpc> :D
11:45:17 <lambdabot> (?f::() -> t) => (t, () -> t)
11:46:09 <erisco> maybe SO documentation simply dies out. Unlike their Q&A site, which had a novel format, I don't see what the documentation site adds to existing solutions
11:46:20 * EvanR puts implicit parameters in the "goofy extension bin"
11:46:30 <EvanR> and i want a flag which enables all non goofy extensions
11:46:32 <erisco> for collaborative single document editing you already have wikis, and that is why many projects have wikis
11:46:35 <tdammers> erisco: they're basically just milking the franchise at this point
11:46:37 * geekosaur pretty much only uses them for this kind of playing around in lb or ghci
11:46:38 <erisco> and this is just a wiki with the SO branding
11:47:10 <erisco> EvanR, but coeffects are certainly not goofy
11:47:34 <erisco> they give credence to the absurd set-then-call calling convention
11:47:36 <EvanR> it sounds goofy, whatever it is
11:47:41 <geekosaur> I am guessing their wiki started out as "so what do we do with all these archived 'great answers'?"
11:47:54 * hackagebot stack-run 0.1.1.3 - An equivalent to cabal run for stack.  https://hackage.haskell.org/package/stack-run-0.1.1.3 (yamadapc)
11:48:46 <dmwit> erisco: A possible benefit of centralized documentation: more moderator/editor review.
11:49:44 <erisco> maybe, but I am skeptical for the reasons I gave earlier. More than one way to explain something, and not everyone is as knowledgeable or good at explanation in written form
11:49:52 <erisco> you give equal powers to unequal people
11:50:15 <EvanR> unequal lives matter
11:50:23 <erisco> you just need a single person to approve your edits and they're live
11:50:45 <erisco> they can adjust that system and I hope they do
11:52:48 <erisco> I'm not just defending my contributions. They might suck. I could be the very person worth excluding from the process, or applying much scrutiny to
11:55:05 <erisco> the reason I've brought it up a few times now is because if it goes anything like SO's Q&A site does then it will overtake the industry
11:55:47 <tdammers> the whole idea with SO is to make people unequal
11:55:53 <erisco> and whatever documentation is there, of high or poor quality, will be informing an era of programming
11:56:12 <dmwit> very dramatic
11:56:45 <srhb> erisco: Hmm. There are still some of your additions awaiting approval, so it's not all gone.
11:56:53 <erisco> I resubmitted XD
11:56:59 <srhb> Oh. :P
11:57:15 <srhb> Are you saying it's an infinite fake internet points gold mine?
11:57:19 <srhb> Are you sure you didn't self-delete? :-)
11:57:30 <erisco> you could validly argue that my explanation is irrelevant because pattern matching can just be explained with constructors
11:57:33 <dfeuer> Hmmmm... Why is this? I am doing something wrong :(
11:57:37 <erisco> yes I am sure. I looked at the edit history
11:57:41 <srhb> :-)
11:57:45 <srhb> (I was joking)
11:57:49 <EvanR> everyone has to be misinformed by something early in their career
11:57:56 <EvanR> its part of the indoctrination process
11:58:10 <EvanR> its like hazing
11:58:10 <erisco> so another editor came along and decided, I am guessing, that talking about things of the form  f p = m  where p is a pattern match was redundant because you can just talk about constructors
11:58:31 <dfeuer> HRmmm.. I will need to thnk this through some moer.
11:58:45 <erisco> so the fact that  f (a:b) = m  is different than  f [a:b] = m   is just seen by that  a:b  is different than  [a,b]  (i.e. it doesn't matter if you're left or right of =)
11:58:55 <EvanR> erisco: now you see why people rage quit and write their own books
11:59:04 <EvanR> so they can only blame themselves
11:59:15 <EvanR> and the publisher review
11:59:19 <erisco> but my argument is that for people truly confused on this matter probably desire an explanation that specifically targets pattern matching
11:59:30 <erisco> even though it is just the same as constructing things on the right of =
12:00:05 <the_2nd> glguy, btw everything worked then, thanks a lot
12:00:34 <EvanR> = is an unfortunate asciiism for that, youd like to differentiate "is defined as, with connotation of computation rules going right" with equality
12:02:01 <ertes> erisco: sin^^(-1) should work
12:02:13 <ertes> :t sin ^^ (-1)
12:02:14 <lambdabot> (Floating a, Fractional (a -> a)) => a -> a
12:02:31 <ertes> but then (recip sin) is better =)
12:02:34 <ertes> :t recip sin
12:02:35 <lambdabot> (Floating a, Fractional (a -> a)) => a -> a
12:02:36 <srhb> erisco: Right now your addition just has formatting issues, I think.
12:02:41 <srhb> erisco: (I agree with your rationale)
12:02:54 * hackagebot sbp 1.0.1 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-1.0.1 (jgross)
12:02:56 <erisco> ertes, sin^-1 often means the inverse of sin, not the reciprocal
12:03:20 <erisco> srhb, well unfortunately the whole section is stuck in code-style
12:03:41 <erisco> how might you have formatted it?
12:03:53 <ertes> erisco: i'd be impressed, too…  and also worried =)
12:03:55 <Neko-chan> Hi, can I ask a stupid question? Can someone give me a run down of why the x:xs notation returns the first element as x and the rest as xs and not just the first 2 elements?
12:04:05 <geekosaur> :t (:)
12:04:07 <lambdabot> a -> [a] -> [a]
12:04:29 <ertes> Neko-chan: because a list in haskell can be of exactly two shapes:  [] or (x : xs), where x is a head element and xs is another list
12:04:36 <geekosaur> if you know Lisp or Scheme, (:) is cons.
12:05:05 <ertes> Neko-chan: so a list of exactly two elements would look like this:  x1 : (x2 : [])
12:05:10 <hpc> for a specific example, [1, 2, 3, 4, 5] is 1:(2:(3:(4:(5:[]))))
12:05:41 <hpc> matching that would yield x/xs = the two things on opposite sides of the outermost (:)
12:05:48 <hpc> which are an element and the rest of the list
12:06:17 <srhb> erisco: Oh, I didn't realize that was a limitation. I don't know then.
12:06:19 <Neko-chan> (x:xs) is a shape of a list like [] is... like x:x2:xs:[] is x:(x2:(xs:[]) ?
12:06:41 <hpc> right
12:06:42 <ertes> Neko-chan: yeah, and you'll notice that 'xs' is just a name
12:07:04 <Neko-chan> Ah, yes
12:07:12 <erisco> isn't it ironic, don't you think?
12:07:14 <hpc> it's just a pun, plural x
12:07:15 <hpc> :D
12:07:33 <Neko-chan> so (straw:strawberry) would work in spots that you'd use (x:xs)
12:07:42 <ertes> Neko-chan: exactly
12:07:49 <Neko-chan> Hmmm. okay! Thanks~~
12:08:01 <erisco> it is fascinating that this is such a common problem
12:08:09 <srhb> Neko-chan: But following the same analogy, it would be (strawberry:strawberries) :P
12:08:15 <Neko-chan> srhb: :p
12:08:30 <ertes> Neko-chan: regarding your first question: i don't think you can ;)
12:08:37 <tdammers> pattern matching does two things: one, match the shape of the pattern, and two, introduce variables defined in the pattern
12:08:38 <erisco> is it because x:y:z is syntactically like x,y,z ?
12:08:57 <hpc> erisco: there's probably not anything fundamentally difficult or confusing about it, it's just one of those first things people encounter and they don't know the language well enough to infer it themselves
12:09:02 <kadoban> I think it's just because lists seem magical at first, partly because the syntax for them is a little funny.
12:09:11 <tdammers> indeed
12:09:31 <kadoban> They have more sugar than most things, so it's not immediately clear how it works compared to other types.
12:09:32 <tdammers> if you write it as Cons x (Cons y (z)) it makes more sense I thing
12:09:35 <tdammers> s/thing/think
12:09:41 <joe9> any first impressions on ghc-8 . anyone using it already or does it break too many things?
12:09:45 <srhb> Or an infix :followedBy
12:09:47 <tdammers> (and for types, List a instead of [a])
12:09:49 <kadoban> I think that'd be less misunderstood, yeah. (it'd also be more tedious, unfortunately)
12:09:51 <erisco> hpc, this misconception happens all the time. I think there has to be something fundamentally confusing about it. For some reason the mind keeps making this incorrect association
12:09:52 <srhb> (although ouch)
12:10:01 <joe9> "using it" -- I meant using it for general use.
12:10:08 <erisco> my guess is that a:b:c looks like a,b,c
12:10:10 <ertes> joe9: i've been using it for a few weeks now
12:10:10 <hpc> joe9: i haven't updated yet out of laziness, but my understanding has been that ghc8 is the bee's knees
12:10:38 <kadoban> GHC8 seems fine, I didn't use it much though because a few libraries I wanted weren't in the stackage nightlies yet.
12:10:39 <joe9> ertes, did it break much userland packages ?
12:10:41 <ertes> joe9: snap (the package) broke for me, so for now i'm using snap-server without snaplets, but it may have been fixed by now
12:10:51 <ertes> joe9: everything else i use works
12:11:01 <joe9> ertes, cool. Thanks.
12:11:27 <hpc> erisco: hmm, maybe
12:11:40 <hpc> erisco: or like, people just mentally erase brackets and treat them all the same?
12:11:46 <mnoonan_> This discussion reminds me.. how come constructors start with regular operator symbols (and why can't operators start with ':')?
12:11:49 <joe9> hpc "bees knees" -- that good?
12:11:50 <hpc> i have seen that with perl and people mixing () [] {}
12:11:59 <mnoonan_> Or maybe the better question is: why do we need to know what things are constructors syntactically?
12:12:10 <ertes> mnoonan_: think of ":" is the only "upper case" character for operators
12:12:15 <erisco> maybe people are used to homogeny? + adds two numbers, ++ concats two lists
12:12:24 <hpc> mnoonan_: it started with ML using ":" for "has type of" and "::" for "cons"
12:12:27 <erisco> that doesn't seem quite right though
12:12:31 <hpc> and then haskell switched it for some reason
12:12:37 <geekosaur> mnoonan_, pattern matching has to be able to tell the difference between bindings and constructors. infix symbols *can* be either
12:12:41 <ertes> mnoonan_: just like word constructors need to start with upper case letters
12:12:49 <mnoonan_> ertes: I realized that when I was typing, and then realized I don't know why ctors need to be syntactically distinguished at all :)
12:12:54 <hpc> then to fit with the language's other features like capital symbols for constructors, ':' was deemed a capital symbol
12:12:58 <mnoonan_> geekosaur: ah, that makes sense
12:13:24 <hpc> so you can write data foo :*&$& bar = Thing (foo, bar)
12:13:25 <ertes> mnoonan_: well, i think technically there is no reason
12:13:27 <hpc> as a weird tuple type
12:13:38 <ertes> mnoonan_: in fact most newer languages (e.g. idris) have no such restriction
12:13:50 <hpc> but you can't write foo :*&^$*% bar = 5 any more than you could write Thing foo bar = 5
12:14:04 <hpc> it's a totally haskell quirk
12:14:34 <erisco> hpc, that could be part of the problem. A familiarity with commutativity
12:14:48 <hpc> joe9: features-wise, it's the next step ever closer to dependently typed haskell
12:14:57 <erisco> hpc, though no one expects a,b,c to be the same as c,b,a
12:15:33 <erisco> I don't know. I don't know if parentheses fit into it
12:15:43 <ertes> what bothers me slightly is that at some point TypeOperators lifted the restriction that types must start with ':'
12:15:55 <hpc> erisco: i was thinking people conflating (x:y) with [x:y]
12:16:01 <ertes> you could have symbolic type variables, which is no longer possible
12:16:10 <hpc> in perl, (1, 2, 3) is a list and [1, 2, 3] is a reference to an array
12:16:14 <erisco> oh, I should have that in my list! good one
12:16:32 <hpc> (a list can manifest itself at runtime as an array or a hash, but is neither)
12:17:00 <joe9> hpc, cool. Thanks.
12:17:09 <hpc> but people mix them and then wonder why $x = (1, 2, 3) is acting funny when $x = [1, 2, 3] was working fine just the other day
12:17:21 <hpc> it doesn't happen often, but i have seen it
12:17:43 <ertes> hpc: it's something that happens to me all the time in other languages
12:18:02 <ertes> because there is equality, but then there is this other concept "identity"
12:19:11 <ertes> … and not the kind of identity you would find in algebra books
12:19:21 <hpc> yeah
12:19:34 <EvanR> "identity" ?
12:19:35 <hpc> "i am the number 3" vs "i am this particular 3, right over there"
12:19:48 <hpc> java has an Integer cache
12:20:02 <hpc> storing Integer objects from 0 to 256
12:20:04 <EvanR> oh object identity
12:20:06 <erisco> object identity versus functional identity
12:20:09 <ertes> EvanR: i'm not sure where it came from, but it's used a lot in OO
12:20:10 <EvanR> lovely
12:20:45 <ertes> the interesting thing is:  i had been programming in C++ for years when i started with haskell, so i used to handle object identity and pointers/references very well
12:21:04 <erisco> well, languages with object identity have a mix of both identity kinds, otherwise it would be a hopeless affair
12:21:26 <ertes> so it's not only difficult to go into haskell from other languages, but also the other way around
12:21:51 <EvanR> haskell and idris have object identities, you could use Integer as the type of object identities and do (Integer, Object) ;)
12:21:54 <hpc> ertes: do you ever use IORef or MVar in your haskell code?
12:22:11 <EvanR> which is how IORef and MVar work
12:22:21 <ertes> hpc: yeah, sure
12:22:31 <erisco> ertes, equality in other languages can be hell
12:22:32 <buglebudabey> if i have an exposed module C nested in folders A/B , and the modules name is A.B.C, what do I call the exposed module in my cabal file?
12:22:50 <bennofs> A.B.C ?
12:22:53 <erisco> there is no expectation for libraries to implement a functional equality
12:23:08 <kadoban> bennofs: A.B.C, yeah.
12:23:09 <hpc> buglebudabey: yeah, A.B.C
12:23:12 <buglebudabey> right now it says can't find source for A/B/C in src
12:23:22 <ertes> hpc: but those don't sneak up on you…  you can't use an IORef Int as an Int and then wonder why (==) is weird
12:23:30 <erisco> and even still, be prepared to be bamboozled by strange equalities… like C#'s DateTime for example
12:23:33 <hpc> buglebudabey: is it in src/A/B?
12:23:37 <bennofs> buglebudabey: does your hs-source-dirs include the directory in which A is contained?
12:23:45 <kadoban> buglebudabey: You probably have your .cabal file set up to look for source code in the src/ directory, so move the whole tree of source files into there.
12:24:02 <erisco> C#'s DateTime equality is neither structural nor extensional
12:24:15 <buglebudabey> yes, but the name is A/B/A.B.C.hs, not A/B/C hpc bennofs  kadoban 
12:24:33 <hpc> the file should be C.hs
12:24:35 <ertes> buglebudabey: the proper file name is A/B/C.hs
12:24:37 <hpc> in A/B
12:24:38 <kadoban> buglebudabey: What? The file should be C.hs, yeah.
12:24:49 <erisco> (the only two sane options for equality!)
12:24:56 <EvanR> when "equality" means "computer function from t x t to Bool" you will certainly run out of terminology before you run out of functions
12:25:00 <buglebudabey> alright, and the module name in C.hs should be module C?
12:25:04 <EvanR> computable*
12:25:09 <geekosaur> buglebudabey, no
12:25:23 <hpc> A/B/C.hs
12:25:26 <geekosaur> .s in the module name translate to /s in the filesystem
12:25:26 <hpc> module A.B.C
12:25:26 <erisco> EvanR, in many languages, yes, it is just another predicate (not even an equivalence relation!)
12:25:28 <ertes> buglebudabey: the module A.B.C lives in A/B/C.hs
12:25:37 <erisco> EvanR, where predicates are always boolean, yes :P
12:25:39 <ertes> buglebudabey: and it's called A.B.C everywhere
12:25:40 <buglebudabey> alright perfect, thanks
12:25:52 <EvanR> ertes: i encountered no less than 4 sane options for equality so far in the HoTT book
12:26:05 <EvanR> at least
12:26:13 <EvanR> which is why no less than means
12:26:15 <erisco> EvanR, I gave two (structural and extensional). What are your 4 options?
12:26:23 <ertes> EvanR: structural equality, as far as it makes sense in the language, should be the default
12:26:45 <ertes> EvanR: for programming
12:27:05 <EvanR> yes HoTT has a computable flavor
12:27:07 <erisco> ertes, I've argued this and in retort I am told it would be too much of a performance hit
12:27:26 <EvanR> ertes: thats what idris calls judgmental equality
12:27:45 <ertes> erisco: well, it's true, but you can have "object identity", if you really want it
12:27:52 <erisco> if two objects have the same object identity this implies the same structural identity
12:28:03 <erisco> unfortunately it is crippling to only have this one direction of inference
12:28:39 <ertes> erisco: i wouldn't mind an optimisation that recognises when two objects are equal by virtue of pointer comparison
12:28:41 <erisco> "where did I put that object again?"
12:28:57 <EvanR> ertes: for example when you do f x = 5 in haskell, this is neither structural nor extensional
12:29:13 <EvanR> its definitional
12:29:15 <ertes> EvanR: i wouldn't call that one "equality"
12:29:23 <EvanR> well it has the dang = sign ;)
12:29:30 <erisco> ertes, that should be an easy dismantling of the argument, thanks
12:29:34 <EvanR> and something like it is used in many notations for definitions
12:29:37 <ertes> EvanR: or at least not an equality judgement =)
12:29:47 <EvanR> it is a judgment!
12:30:03 <ertes> EvanR: by "judgement" i mean "type"
12:30:09 * EvanR head scratch
12:30:55 <EvanR> oh equality type, thatd be "propositional equality"
12:31:07 <ertes> i should stop using the word "judgement"…  s/judgement/proposition/ =)
12:31:16 <ertes> propositional equality is just one of many
12:31:40 <ertes> (and the most awkward one in practice)
12:31:52 <EvanR> no way, its awesome
12:32:14 <EvanR> that coincides the most with random usage of = in math, i think
12:32:27 <ertes> trans (sym (cong (no way) cong)) (its awesome)
12:32:32 <EvanR> we just dont usually put the types
12:32:46 <EvanR> we use those laws in our head effortlessly
12:32:47 <ertes> got it wrong even =)
12:33:23 <buglebudabey> i tried installing my package from hackage but it only downloaded the executable, how can i make sure it downloads the library?
12:34:15 <ertes> buglebudabey: which package?
12:34:36 <buglebudabey> maybe its best for an outsider to try because it simply copied from my local repository, not download
12:34:38 <buglebudabey> ertes  hext
12:35:06 <ertes> buglebudabey: that package has no conditionals, so you should always get the full thing
12:35:24 <buglebudabey> alright, as long as it works for others that's good
12:37:21 <ertes> buglebudabey: i didn't try, but hackage was able to build it
12:37:29 <buglebudabey> awesome, thank you
12:39:17 <ertes> buglebudabey: if docs are available on hackage (without you uploading them manually), it's a good sign, but the converse is unfortunately not true right now
12:39:19 <EvanR> a fourth kind of equality would be an equivalence relation, where a relation between A and B is a type family A x B -> Type
12:39:29 <EvanR> satisfying the equivalence relation properties
12:39:40 <buglebudabey> ertes docs were successfully added this past version
12:40:11 <buglebudabey> ertes since it's in its infancy i'll probably be doing lots of little updates to the package
12:42:41 <EvanR> if definitional is not different from judgmental, then throw in "equivalence" too, which is a function from A to B which has a sort of inverse
12:44:26 <EvanR> which youd call isomorphism in haskell. and we often write = for an isomorphism between types
12:47:40 <buglebudabey> if im running a lot of Text through my program and only breaking it up into words and removing punctuation, is Hash better to use or a Vector when putting the data into  collection?
12:49:16 <EvanR> HashMap and HashSet seems to be better for short words
12:49:43 <EvanR> immutable Vector would be pretty bad since you have to reallocate the whole thing to add anything to it
12:50:04 <EvanR> and doesnt let you do efficient search
12:50:48 <buglebudabey> cool, thank you - ill look into this
12:50:55 <buglebudabey> what about using vector over a list?
12:51:09 <EvanR> for what?
12:51:12 <buglebudabey> when the value is not a word but a data structure
12:51:42 <buglebudabey> the data structure includes a hash and another datatype
12:52:09 <buglebudabey> Labeled a = Labeled {getHash :: HashMap, getClass :: a}
12:52:09 <EvanR> what are you trying to do
12:52:37 <EvanR> wait, earlier when you said Hash i thought you meant HashMap the container, now looks like youre calling a singular hash value a HashMap which is wrong
12:53:38 <buglebudabey> i need a container for a frequency list of words, so that's why i asked about hashmap
12:54:04 <buglebudabey> im gong to put that frequency list in a data type which i will end up making a list of, and was wondering if there was a better container for it
12:54:35 <EvanR> HashMap for frequencies makes sense
12:54:54 <buglebudabey> EvanR these are the datatypes i currently have http://lpaste.net/172265
12:54:55 <EvanR> if youre going to make a list of data types containing a hashmap... go with list
12:55:06 <EvanR> tautologically
12:55:25 <buglebudabey> so just change the FList datatype, and not Material?
12:55:58 <EvanR> well if youre asking if Material should be a list, what are you going to do with it
12:57:04 <buglebudabey> i use list comprehensions with it, map over it, filter with it - all in separate places
12:57:37 <buglebudabey> take the length of it..
12:58:02 <EvanR> it sounds like it can be any foldable and it wont matter
12:58:10 <EvanR> except for the "filter with it" part
12:58:14 <EvanR> not sure what that is
12:58:35 <buglebudabey> i just filter the list is all
12:58:42 <EvanR> oh filter the list itself
12:58:45 <EvanR> then just use list
12:58:46 <buglebudabey> yes
12:58:55 <buglebudabey> alright cool, thank you
13:17:57 * hackagebot hext 0.1.0.2 - a text classification library  https://hackage.haskell.org/package/hext-0.1.0.2 (aneksteind)
13:17:59 * hackagebot pokemon-go-protobuf-types 0.1.1 - Haskell types for the Pokemon Go protobuf protocol.  https://hackage.haskell.org/package/pokemon-go-protobuf-types-0.1.1 (RickyElrod)
13:18:11 <Rembane> :D
13:18:25 <EvanR> what
13:18:32 <Welkin> pokemon go
13:18:37 <EvanR> is no place safe
13:18:53 <hpc> hackage already has a rocket league replay parser
13:19:31 <buglebudabey> just had a look at that pokemon go package, so many modules
13:19:58 <geekosaur> (gotta catch 'em all?)
13:21:24 <EvanR> i see a buglebudabey !! and a geekosaur !!!!
13:21:41 <buglebudabey> buglebudabey's are easy to catch
13:22:48 <buglebudabey> Data.HashMap say's it's deprecated and to use Map instead EvanR, is there something else around?
13:22:59 <Welkin> Data.Map.HashMap
13:23:08 <EvanR> whurt
13:23:34 <buglebudabey> i was on Data.Hashmap hackage but theres also Data.Hashmap.Lazy and .Strict
13:23:36 <Welkin> oh
13:23:37 <EvanR> are you looking at up to date docs
13:23:38 <Welkin> nevermind
13:23:42 <Welkin> it's in  different package too
13:23:45 <Welkin> unordered-containers
13:23:59 <EvanR> heh yeah and the right package
13:24:03 <Welkin> http://hackage.haskell.org/package/unordered-containers-0.2.7.1
13:24:25 <buglebudabey> cool, thanks Welkin 
13:24:28 <EvanR> there arent any docs generated for Data.HashMap
13:24:51 <glguy> There also isn't a Data.HashMap module
13:24:58 <buglebudabey> EvanR https://hackage.haskell.org/package/hashmap-1.3.1.1/docs/Data-HashMap.html
13:25:22 <EvanR> the package is utterly incorrect
13:25:34 <Phyx-> haha
13:27:49 <slack1256> I got a Type-level example that has a GADT like this `data Polygraph :: Bool -> * where' 
13:27:57 * hackagebot servant-auth-cookie 0.3.0.0 - Authentication via encrypted cookies  https://hackage.haskell.org/package/servant-auth-cookie-0.3.0.0 (zohl)
13:28:19 <slack1256> I am comfortable with `data Polygraph (a :: 'Bool) where'. What is the distinction?
13:28:52 <glguy> The (a :: 'Bool) syntax is misleading, you might think that that 'a' is in scope in the constructors
13:28:52 <Eduard_Munteanu> slack1256, no distinction in Haskell
13:28:56 <glguy> but they do the same thing
13:29:55 <Eduard_Munteanu> (Agda distinguishes type parameters and indices, but that's another story.)
13:31:20 <slack1256> for some reason if I change the first to `data Polygraph 'Bool :: * where' it fails though
13:32:18 <Eduard_Munteanu> slack1256, you can't have unnamed type parameters in Haskell
13:32:49 <Eduard_Munteanu> data Polygraph (a :: 'Bool) :: * where   -- should work
13:33:00 <slack1256> Got it!
13:33:18 <Welkin> what's with the 'Bool ?
13:33:34 <Eduard_Munteanu> Welkin, it's Bool lifted to a kind
13:33:35 <Welkin> why is there a ' ?
13:33:37 <glguy> That's how you lift things with the DataKinds extension
13:33:40 <slack1256> I use to be very explicit that DataKinds is enabled
13:33:45 <Welkin> how does that work?
13:33:59 <slack1256> specially useful when dealing with Unit () at typelevel
13:34:02 <Welkin> what does it mean to lift a type into a kind?
13:34:36 <jle`> Welkin: the type Bool has two values of that type: True and False
13:34:41 <Eduard_Munteanu> Welkin, basically data Bool = False | True also defines a kind Bool with (uninhabited) types False, True in it.
13:34:43 <jle`> Welkin: the kind Bool has two types of that kind: 'True and 'False
13:34:48 <slack1256> Welkin: probably is better to direct to the source? https://wiki.haskell.org/GHC/Type_families
13:34:52 <jle`>  :k 'True  => Bool
13:34:58 <jle`>  :k False -- => Bool
13:35:06 <jle`> s/False/'False
13:36:13 <Eduard_Munteanu> Welkin, this allows you to use Peano numbers as type-level indices, e.g. S (S Z) of kind Nat
13:36:30 <Eduard_Munteanu> (for data Nat = Z | S Nat)
13:36:49 <Eduard_Munteanu> For example, that is.
13:38:00 <Welkin> I guess I don't understand the point of kinds
13:38:03 <Eduard_Munteanu> You can go ahead and play with length-indexed lists if you wish to give it a try.
13:38:31 <slack1256> there is also type-indexed matrices (in hmatrix) on a new module
13:38:58 <EvanR> Welkin: it keeps Maybe from being used in the same places as Bool
13:39:01 <jle`> Welkin: the point of kinds is the same as the point of types, really -- it's to restrict what sort of inputs a function can take and what you can do with it
13:39:09 <jle`> and also tells what it returns
13:39:11 <Eduard_Munteanu> Welkin, data Vec :: Nat -> * -> * where { Nil :: Vec Z; Cons :: a -> Vec n a -> Vec (S n) a }
13:39:15 <slack1256> ie "eye :: R '3" returns the 3x3 identity matrix over the reals!
13:39:57 <Eduard_Munteanu> s/Vec Z/Vec Z a/
13:40:03 <Welkin> so Nil is a type constructor?
13:40:20 <Welkin> and Cons
13:40:32 <Eduard_Munteanu> Welkin, no, it's a value constructor. But S and Z are type constructors now.
13:41:05 <Eduard_Munteanu> So you don't need to muck around with empty data declarations just to make up type indices.
13:41:22 <hpc> it's like saying
13:41:26 <hpc> data S a
13:41:28 <hpc> data Z
13:41:39 <hpc> data Vec :: (either S or Z) -> (all the rest the same)
13:41:49 <Welkin> okay
13:41:56 <Eduard_Munteanu> Before, you had like   data S a; data Z; data Vec :: * -> * -> *   which didn't restrict things properly
13:42:18 <buglebudabey> does this function make sense given that hashmap is lazy and foldl' is strict? 'foldl' (\acc hmap -> H.unionWith (+) hmap acc) H.empty'
13:42:58 <Eduard_Munteanu> buglebudabey, isn't HashMap strict in the spine as well?
13:43:01 <glguy> buglebudabey: Data.HashMap.Lazy is only lazy in its elements
13:43:30 <buglebudabey> Eduard_Munteanu it is, but that's not what i want
13:43:32 <buglebudabey> thank glguy 
13:44:12 <Welkin> so what is a more realistic example of when you might want to use datakinds?
13:44:23 <Welkin> slack1256: like your example, why do you need it?
13:44:54 <Eduard_Munteanu> I thought mine was realistic. :/
13:45:00 <Welkin> Eduard_Munteanu: it was, and thank you
13:45:12 <Welkin> I'm just looking for another example
13:45:23 <orion> Would it be accurate to say tht Monad transformers add functionality to a base monad? MonadLogger also seems to add functionality to a Monad, but it's not a transformer, it's a type class. What is the difference between adding functionality to a Monad via transformers vs. by typeclasses?
13:45:42 <glguy> Welkin: It certainly starts to make sense when you're doing thing with type families as type functions and you want those typed functions to be "kinded" just like you have your functions typed
13:46:46 <tdammers> orion: a monad transformer "adds functionality" by wrapping the base type in another type
13:47:06 <orion> tdammers: In particular, I'm curious as to why no logging functionality is mentioned here: https://github.com/haskoin/haskoin/blob/a63e3d0f78f5eff68cb3327ab54d7d412faa0f58/haskoin-node/Network/Haskoin/Node/STM.hs#L48 but almost every function looks like this: https://github.com/haskoin/haskoin/blob/3bb8c8944a4baa4082aa393c24d781652a7c40c3/haskoin-node/Network/Haskoin/Node/BlockChain.hs#L43
13:47:24 <jle`> orion: MonadLogger doesn't add functionality to a Monad, it's a typeclass, like Monad, FUnctor, Monoid, etc.
13:47:43 <jle`> orion: adding a MonadLogger constraint to your type means that you're *constraining* the types your function is defined over
13:47:51 <jle`> to only types that have those specific operations defined
13:48:11 <jle`> it's like adding a Monoid constraint to your type -- now, your function can only be used with types that are instances of Monoid, and give you mappend/mempty
13:48:29 <jle`> MonadLogger itself does not add any functionality to a type
13:48:36 <jle`> *a specific type
13:48:48 <jle`> it just constrains how polymorphic your function is
13:48:59 <Eduard_Munteanu> orion, typeclasses like MonadLogger, MonadIO etc. allow you to keep types generic without committing to a particular transformer. This in turn makes other things nicer, like lifting.
13:49:05 <tdammers> well, with a bit of squinting, you could say that typeclass constraints "add functionality" on the inside of a function
13:49:14 <tdammers> a lot of squinting, actually
13:49:20 <danilo2> Hello guys! A little bit naive and stupid question, but is IORef approximately as fast as reference in CPP ?
13:49:34 <tdammers> danilo2: probably not
13:49:51 <jle`> in a way, constraining your function gives your function more properties to work with than before
13:49:59 <hpc> CPP as in the preprocessor?
13:50:03 <danilo2> I want to have a value and I want to compute it once on the beginning and then access it multiple times. I want to access it as fast as possible - justl ike reference in CPP - how can I do it ?
13:50:05 <tdammers> hpc: I think C++
13:50:07 <geekosaur> c++ references (foo&)
13:50:09 <EvanR> CXX
13:50:10 <Eduard_Munteanu> danilo2, for one thing, setting IORefs is atomic.
13:50:11 <hpc> ah
13:50:12 <orion> Well then, why don't I see MonadReader in the functions' type constraints?
13:50:17 <hpc> IORef has some light atomicity guarantees
13:50:26 <hpc> and it has boxing (in ghc)
13:50:28 <Eduard_Munteanu> orion, actually that's common too
13:50:28 <tdammers> danilo2: you don't need IORef for that, you just need to force evaluation
13:50:35 <EvanR> IORef writes also go through a write barrier
13:50:42 <orion> Eduard_Munteanu: Ok, so it seems to me like there are two ways of accomplishing the same thing.
13:50:44 <jle`> orion: because your function is polymorphic in a way that it doesn't care about whether or not the type is an instance of MonadReader
13:50:59 <jle`> orion: for example, if i write const :: a -> b -> a; it doesn't care whether or not 'a' is a Monoid or not
13:51:04 <jle`> so i wouldn't add a Monoid constraint
13:51:09 <danilo2> Eduard_Munteanu: oh, good to know!
13:51:12 <jle`> it's polymorphic over things that *aren't* Monoids, too
13:51:12 <tdammers> danilo2: Haskell values are typically boxed already, so passing them around pretty much boils down to the same thing as const references in C++
13:51:30 <jle`> orion: if your function doesn't have a MonadReader constraint, that means that the function is polymorphic enough to work on things that *aren't* MonadReaders, as well
13:52:06 <tdammers> danilo2: except of course that by default, Haskell's "values" are actually thunks, so it's a bit more complicated than that (and also the reason why you have to force evaluation to get const-reference-like behavior)
13:52:24 <danilo2> tdammers: hmm, ok, so there is another problem here. I've got a list of datatypes - D1, D2, ... D10. I want each datatype associated an Int and I want to compute it once and then access it like a reference. Each datatype has its own Int, because of that I was thinking about IORefs. These dataypes are phantom - The ints are associated with their types
13:52:43 <orion> jle`: Hypothetically, could a MonadLogger transformer be defined? If so, what would be the benefit/downside?
13:52:50 <EvanR> danilo2: you can use proxies
13:52:56 <jle`> orion: are you aware of the "free monoid"?
13:52:57 <Eduard_Munteanu> orion, one thing to consider is that you have instances like MonadReader r m => MonadReader r (WriterT m)
13:52:59 <danilo2> tdammers: by the way - If I dont force evaluation will it not optimize itself after first evaluation ?
13:53:09 <EvanR> make a type class with one method of type Int, each type implements it differently
13:53:21 <Eduard_Munteanu> orion, which take care of calling lift appropriately
13:53:23 <orion> jle`: I'm aware of the Free Monad in that I've defined one before.
13:53:23 <EvanR> to get this int youll need to make a proxy of that type
13:53:26 <jle`> orion: i can take any type, monoid or not, and give it a "free" monoid instance, so you can use it as a monoid, with monoid functionality
13:53:37 <tdammers> danilo2: it will evaluate once and then reuse the value, most likely, yes
13:53:44 <jle`> orion: that's what List does.
13:53:48 <slack1256> Does any library use non-associaciated open type families? they seem weird
13:53:56 <Eduard_Munteanu> s/WriterT m/WriterT w m/
13:54:00 <sbef> hi
13:54:02 <jle`> orion: if i have an "a", that isn't a Monoid, i can just wrap it in a list, and voila, a monoid i can use, with mappend, mempty, etc!
13:54:03 <danilo2> EvanR: how? I know Proxies, but hmm, how you want to do it? I dont want to store them in a vector or so. I just want to have a typeclass or somethinfg that for a given type will result in the related integer
13:54:12 <EvanR> right
13:54:25 <jle`> orion: so, i can basically automatically take any type, and use it as if it were a Monoid, and had a Monoid instance
13:54:26 <EvanR> getInt :: Proxy t -> Int
13:54:30 <tdammers> danilo2: you can't put types in lists
13:54:39 <jle`> orion: that is essentially what LoggerT is.  and ReaderT.  and StateT
13:54:52 <sbef> does anyone know where can i find detailed documentation about old hardware? like ata-I hdd
13:54:53 <danilo2> tdammers: Of course. I dont want to. I've got a type-level list of types here
13:55:04 <jle`> orion: 'Maybe' doesn't have a MonadLogger instance.  but, i can use it as a MonadLogger if i use LoggerT
13:55:12 <danilo2> EvanR: ok, but how would the function be implemented ?
13:55:22 <EvanR> getInt _ = 5
13:55:28 <jle`> orion: what LoggerT does is take any Monad, and give it a "free" MonadLogger instance, so you can use logging functionality in it
13:55:39 <tdammers> danilo2: idk, look into Typeable maybe?
13:55:41 <danilo2> EvanR: that would be simple, but these Ints have to be computed once on the beginning
13:55:41 <orion> jle`: That's the basis of all Monad transformations?
13:55:51 <EvanR> danilo2: yurg... then there is reflection
13:55:59 <jle`> orion: not quite, some monad transformers are useful in and of themselves, without respect to any typeclasses
13:56:02 <EvanR> you compute them and introduce the instances at the beginning of the program
13:56:05 <EvanR> or block or whatever
13:56:12 <jle`> orion: list let us get free monoid instances, but lists are useful other than just that property
13:56:29 <jle`> but getting a free monoid instance is one very nice application of the List type
13:56:47 <jle`> getting a free MonadReader r instance is one very nice application of ReaderT r
13:56:48 <danilo2> EvanR: hmm, they have to be computed in runtime. So I cannot introduce instances "after computing them" Because of that I was thinking about something using IORefs or so
13:56:49 <jle`> (but not the only)
13:56:55 <EvanR> danilo2: computing values at runtime, lifting them to the type level, and getting them back later is not the simplest thing to do in haskell ;)
13:57:09 <EvanR> danilo2: you can introduce "instances" during runtime using reflection
13:57:32 <EvanR> though since its an entire list of types...
13:57:34 <jle`> you can of course write an instance of MonadReader directly for your type, if it has one.  Just like how you can write a Monoid instance for your type, directly, if it has one or would be useful
13:57:38 <EvanR> that sounds like some next level shit
13:57:58 <EvanR> just switch to idris ;)
13:58:00 <danilo2> EvanR: I dont want to lift them to type level. Look. I've got types D1, D2, ... D10. Each should have associated int (in CPP nomenclature, each has associated reference to address in memory for that Int). I want to compute these ints and then just use these associated references when needed. No lifting values to type level here
13:58:05 <jle`> but if you have a plain ol' type, and you need it to have a Monoid instance so you can do monoidy stuff with it, wrapping it in a list is just fine
13:58:17 <EvanR> danilo2: [(Int, Type)]
13:58:26 <EvanR> that would be type level in haskell
13:58:28 <jle`> and if you have a plain ol' Monad, and you need it to have a MOnadReader instance so you can do monadreadery stuff with it, wrapping it in ReaderT is also fune
13:58:43 <jle`> *fine
13:59:28 <jle`> but again, this is just one nice application/usage of ReaderT.  just like how getting a free monoid instance is just one nice applicaiton/usage of lists
13:59:56 <danilo2> EvanR: hmm, I think my problem description was not clear engough. I;m really sorry for that. I'll try again , just give me second to include all details
14:00:37 <Welkin> danilo2: you want an association list of Int mapped to some type?
14:01:19 <orion> jle`: It's not clear to me why the authors decided to use a class constraint in their function as opposed to merely adding LoggerT to NodeT.
14:01:34 <danilo2> EvanR: I've got datatypes - D1, D2, ... D10. User can define his own datatypes as well (in other libraries or in plugins loaded in runtime (!)). Each datatype should have associated Integer that would be computed by my frameork on the beginning and I need constant access to them knowing the type. So after the beggining I want to have a function `getTheInt :: HasInt a => a -> Int` that would work like a reference in CPP for given typ
14:01:43 <danilo2> Welkin: ^^^
14:01:46 <jle`> orion: well, that's like asking why foldMap, etc. are written to Monoid m => ... instead of just [a]
14:02:00 <danilo2> Welkin: it would be simple if there were no runtime constraints described above
14:02:02 <jle`> orion: it's a lot more useful because you can use them on all Monoid instances
14:02:06 <jle`> not just [a]
14:02:18 <jle`> for example, 'Sum Int' is a nice Monoid instance that people use all the time
14:02:19 <tdammers> danilo2: I would take a step back and ask myself whether the thing your users provide at runtime have to be types
14:02:43 <jle`> it wouldn't be very useful if functions were defined only to work on [a], instead of Monoid m => ... m
14:03:03 <danilo2> tdammers: yes. Its crutial because there is a big typelevel machinery here that optimizes things away. This is part of the core of a compiler, just belive me, it has to be done this way
14:03:13 <jle`> if something is defined over Monoid m => ... m ..., it would work for *all* Monoid insatnces --- Sum Int, [Void], String, etc.
14:03:20 <jle`> not just those constructed by the "free monoid"
14:04:06 <jle`> orion: in the case of that library's author, they wanted to allow the caller of the function to use other MonadLogger instances besides just LoggerT
14:04:17 <jle`> er, besides those constructed using LoggerT
14:04:36 <tdammers> danilo2: I'm confused. Are you writing a compiler?
14:04:41 <danilo2> tdammers, EvanR : is there any hack in GHC that would allow me to use just references like in CPP ? or sometihn  like that. Or just assing a value to a type - so everytime I've got a type O can access this specific value
14:04:45 <danilo2> tdammers: yes
14:04:49 <jle`> because constructing a MonadLogger instance using LoggerT is just one way to make a MonadLogger instance (just like using [] is one way to make a Monoid instance), but there are bunches of instances that *aren't* created involving LoggerT as well
14:04:57 <jle`> orion: just like there are a bunch of Monoid instances that aren't created by using lists
14:05:08 <danilo2> tdammers: yes, im writing a compiler
14:05:26 <tdammers> danilo2: but then, why do the types in the compiled language need to bleed into the compiler itself?
14:05:45 <tdammers> danilo2: typically you'd have types of the compiled language be values in the compiler code
14:06:04 <tdammers> danilo2: to the compiler, the compiled code, the AST, and the output, are all just data
14:06:14 <danilo2> tdammers: it doesnt have nothing in common with the language. Its part of the compiler internal api for compiler plugins
14:06:38 <athan> Has anyone here seen something like quickcheck's Arbitrary, but with supplimentary normal distributions over different scalar subcomponents?
14:06:42 <Gurkenglas> My record has a list of actions to perform on it that might fail. I want to perform all that dont fail and throw out the rest.
14:06:46 <Gurkenglas> I think that would be "[StateT s Maybe ())] -> State s (State [StateT s Maybe ()] ())"?
14:06:50 <athan> I'm just looking for a scalable arbitrary or something nuts
14:06:56 <danilo2> tdammers: it doesnt matter that it is a compiler. I ment it is a compiler only to indicate that this part is performance critical and I want to use custom datatypes to optimize them away
14:07:42 <tdammers> danilo2: then I'm back to confused again
14:08:00 <jle`> danilo2: not sure if this is the level that you want, but the singleton library offers a way to return a type that you can pattern match on to get the original type back out
14:08:21 <jle`> it's a constructor that you can pattern match on for types
14:08:35 <danilo2> tdammers: Ouch, sorry for that :( Ok - using simple words. Is there ANY way in haskell to associate a value to a given type? so I have several types - D1, D2, ... etc and for each there is associated Int and I can access that int having oonly the type? 
14:08:35 <jle`> case blah of (it's a bool) -> ...; (it's an int) -> ..., etc.
14:08:53 <lyxia> Gurkenglas: do you want to keep the list of successful actions too? the stacked States look odd.
14:08:57 <dmwit> Gurkenglas: Personally, I would implement the operation of type `StateT s Maybe () -> State s ()` which leaves the state alone on failures, then build up from there with the usual combinators.
14:09:04 <tdammers> danilo2: sure, but you have to define the type <-> integer value relationship somewhere
14:09:18 <tdammers> danilo2: something like [(TypeRef, Int)] would work
14:09:22 <danilo2> jle`: I dont want pattern matches. Its to slow here. look a line above - I want just a vbalue associated with a type. Just a "memory pointer" for a given type
14:09:43 <tdammers> danilo2: or a hashmap or sth
14:10:07 <dmwit> :t \act -> state $ \s -> case runStateT act s of Just (a, s') -> (a, s'); Nothing -> ((), s)
14:10:08 <danilo2> tdammers: exactly, but I want it to be as fast as reference in CPP. Look, using C++ you can define something like that without the overhead
14:10:09 <lambdabot> MonadState s m => StateT s Maybe () -> m ()
14:10:42 <jle`> Gurkenglas: i don't think StateT over Maybe would really give you any benefit here
14:10:56 <dmwit> I also agree with jle`'s assessment.
14:11:09 <jle`> Gurkenglas: also, what would it even mean to "throw out the rest" if the results are all () ?
14:11:09 <danilo2> tdammers: using even some hacks, but you can. For example - reserve a memory chunk, enumerate in compile time the types and just associate them with offset in the memory. Then each type will have reference to int without any further overheads
14:11:27 <jle`> you can't know if an action will fail or not until you perform it, right?
14:11:35 <jle`> so you perform all the actions...and accumulate the ()'s that succeed?
14:11:46 <jle`> [()] is just basically (positive) Int, right?  is that what you want?
14:11:52 <dmwit> jle`: I think the point is to accumulate the state-changes from the actions that succeed.
14:11:56 <jle`> a count of how many items succeeded?
14:12:00 <tdammers> danilo2: if you enumerate the types at compile time, then you can't add more of them dynamically at runtime, can you?
14:12:14 <dmwit> jle`: (And toss any state changes from actions that failed.)
14:12:34 <jle`> dmwit: is it then performing them all "in parallel"?  all from the same initial state?
14:12:55 <tdammers> danilo2: under such constraints, you can achieve a similar thing with TemplateHaskell, simply by doing the calculations at compile time
14:12:55 <dmwit> My guess is in series. But perhaps I should shut up and let Gurkenglas say what he wants instead.
14:12:56 <danilo2> tdammers: I dont want to add types at runtime. I want users to be able to define types in their libraries, that are for example compiled and loaded as "plugins" to the comiler. So they are defined in the plugin code and just loaded using some mechanism to Haskell as a plugin. 
14:12:58 <buglebudabey> theoretically is haskell a bad language to write an OS in?
14:13:13 <tdammers> danilo2: so those custom types get compiled in?
14:13:45 <dmwit> buglebudabey: You may be interested in House (a Haskell-based OS project) and HaLVM (a way to run a single Haskell process on Xen).
14:13:47 <danilo2> tdammers: somehow - when I complie the library, I dont know about them, but other modules that will eventually be loaded in have these types defined and compiled
14:14:02 <danilo2> tdammers: so yes, TH seems like something that could work, i still dont see how yet
14:14:19 <danilo2> tdammers: but I'm thinking about it now
14:14:29 <dmwit> ?unmtl MaybeT (State s) a
14:14:29 <lambdabot> s -> (Maybe a, s)
14:14:31 <tdammers> danilo2: yeah, OK, so whoever uses the library will have to register their types somehow, which could be a call to a TH function
14:14:39 <buglebudabey> dmwit I've heard of both, but just because an OS has been written using haskell means its good for it, right? :P
14:14:44 <dmwit> ?unmtl StateT s Maybe a
14:14:44 <lambdabot> s -> Maybe (a, s)
14:14:51 <buglebudabey> dmwit doesn
14:14:54 <ReinH> buglebudabey: https://wiki.haskell.org/Applications_and_libraries/Operating_system
14:14:56 <buglebudabey> doesnt***
14:15:23 <danilo2> tdammers: the problem with resgistration in TH is the 2 stage restriction. So it is very hard to create good registration process in TH especially if you provide al ibrary and api to compile additional plugins that dont know about each other
14:16:15 <tdammers> danilo2: the main program will have to trigger the actual registration through TH at some point, and use its output to bootstrap the compiler machinery
14:16:16 <dmwit> buglebudabey: Questions as subjective as yours make me nervous.
14:16:45 <tdammers> danilo2: you want the TH to generate code to marshal between types and integers
14:16:47 <Gurkenglas> Oh hey people said things. Here's an ugly implementation of what I think I want: http://lpaste.net/172299
14:16:48 <danilo2> tdammers: I dont want to need to compile the main program when adding a plugin :(
14:16:58 <danilo2> tdammers: brb I have to think deeper about it
14:16:58 <orion> jle`: thank you for that explanation
14:17:03 <buglebudabey> dmwit i don't believe it's that subjective, but that is subjective too so i guess i lose
14:17:13 <tdammers> danilo2: you can't compile in the plugins without doing any compiling
14:17:16 <danilo2> tdammers: thank you for your help and conversation, ill be right back i have to sketch something
14:17:30 <danilo2> tdammers: I want to compile the plugins, without touching the whole engine
14:17:46 <geekosaur> buglebudabey, not sure it's subjective so much as too amorphous. "good" in what sense(s)?
14:17:51 <danilo2> so there would be no "main" that can run TH after all TH from plugins
14:17:56 <danilo2> so the registration in TH breaks
14:18:34 <Gurkenglas> (dmwit, jle`, lyxia, ^)
14:18:38 <danilo2> tdammers: it is possible to load plugins at runtime. Plugins that are compiled earlier to object code if im not worng
14:19:38 <buglebudabey> geekosaur can it easily be interfaced with assembly, can it invoke code coming from raw data bytes, can it make a sufficient run-time library to support language features...
14:19:51 <buglebudabey> control memory allocation
14:19:53 <buglebudabey> etc
14:20:03 <dmwit> Gurkenglas: I have to say I'm a bit lost. Where do you ever touch the level-2 state?
14:20:20 <tdammers> danilo2: oh, OK
14:20:37 <tdammers> danilo2: so the equivalent of loading .so's / dll's at runtime
14:20:43 <dmwit> Gurkenglas: Oh, I see that I misread the type signature. That is one hell of a type signature.
14:20:44 <danilo2> tdammers: yes
14:20:51 <danilo2> tdammers: in fact I need a very simple thing ere
14:20:58 <tdammers> danilo2: I'm not sure you can do that and have Haskell types survive
14:21:06 <danilo2> tdammers: I need to associate a given type with a memory reference to an Int
14:21:19 <danilo2> tdammers: but I have no idea how to do it as efficiently as in CPP
14:21:42 <danilo2> tdammers: it sohuld not break any type assumption in haskell. It is a very clear mechanism
14:21:53 <danilo2> tdammers: it coudl work even in IO or some monad. Whatever
14:22:09 <danilo2> tdammers: I just want to associate types with values as references to memory 
14:22:18 <Gurkenglas> dmwit, result == Nothing means that the action wouldn't succeed, and we don't do anything to the outer state s. the recursive step returns an action on xs, and we turn that into an action on (x:xs) by throwing out the x and returning whatever the action on xs returns
14:22:35 <danilo2> so if you compile a type, in runtime there is memory reserved for int and it is remembered for given type. That is simple and could be done
14:22:43 <danilo2> theoretically
14:23:01 <Gurkenglas> dmwit, (Just _) means that the action would succeed, so we do it by "mapStateT fromJust x" (fromJust since we know itll succeed), and then we do the recursive step and modify its returned action by not doing anything to x
14:24:28 <qknight> hey. how to tell `stack` to install into /foo/bar instead of ~/.stack
14:24:46 <dmwit> :t let unmtled [] _ = []; unmtld (f:fs) s = case f s of Nothing -> unmtld fs s; Just s' -> f : unmtld fs s' in unmtld
14:24:47 <lambdabot> [t -> Maybe t] -> t -> [t -> Maybe t]
14:25:02 <kadoban> qknight: Install what?
14:25:05 <dmwit> Gurkenglas: What do you think of my simplified type signature and implementation?
14:25:17 <qknight> kadoban: a haskell program (not a library)
14:25:18 <slack1256> Are there corner cases hidden in the fact that open type families aren't total?
14:25:32 <kadoban> qknight: stack install those to ~/.local/bin/ by default
14:25:33 <qknight> kadoban: i'm on nixos and using the nix package manager. 
14:25:49 <dmwit> Gurkenglas: (Kindly ignore my typo. ;-)
14:25:57 <qknight> kadoban: ok, then the nix ppl have changed ~/.local/bin i suppose
14:26:35 <kadoban> qknight: 'stack --local-bin-path whatever install something' should work
14:27:05 <kadoban> qknight: I assume you're not talking about stuff like where it installs its own managed copies of GHC?
14:27:39 <avalokite> Hello :)
14:27:42 <Gurkenglas> Yep thats semantically equivalent but my example is minimized and inserting lenses into everything sounds easier with the mtl version. Also I feel like the mtl/lens version actually ought to be about a one-liner and Im not seeing it
14:27:49 <ctesiphon> alright, guys - I wrote a typeclass for things that can be Maps, have a few instances writte down (Map, IntMap, HashMap) but now I'm not sure how to write the benchmarking function for, say, the insert function. can anyone give me a hand?
14:27:50 <Gurkenglas> *dmwit
14:29:05 <ertes> ctesiphon: are you using criterion?
14:29:08 <Rembane> ctesiphon: Criterion is your friend.
14:29:50 <ctesiphon> ertes: Rembane: yes, criterion it is
14:30:00 <dmwit> :t let f [] = pure (); f (m:ms) = (m <|> pure ()) *> f ms in f
14:30:01 <lambdabot> Alternative f => [f ()] -> f ()
14:30:25 <ertes> ctesiphon: even though criterion is very precise, a single insert into a small map is too quick
14:30:40 <dmwit> :t traverse (\m -> m <|> pure ())
14:30:42 <lambdabot> (Traversable t, Alternative f) => t (f ()) -> f (t ())
14:30:49 <ertes> ctesiphon: you should benchmark a whole bunch of them in sequence
14:30:52 <dmwit> :t traverse_ (<|> pure ())
14:30:53 <lambdabot> (Foldable t, Alternative f) => t (f ()) -> f ()
14:31:10 <dmwit> Gurkenglas: If you're okay with just *applying* the state changes -- rather than returning them -- you may like the above.
14:31:45 <ertes> ctesiphon: other than that, it's the usual thing:  use 'nf'
14:32:04 <ctesiphon> ertes: oh, I am aware of that, I'm basing myself off of containers-benchmark
14:32:39 <ctesiphon> I'll put it in a pastebin.
14:32:39 <qknight> kadoban: indeed a good hint, thanks!
14:32:44 <dmwit> :t filterM
14:32:45 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
14:33:02 <Gurkenglas> Okay I think this new version is a little better http://lpaste.net/172299
14:33:47 <ertes> ctesiphon: you're just abstracting over typical map operations, right?  do you expect anything bad to happen?  doesn't sound like there should
14:34:30 <dmwit> :t filterM (\m -> do s <- get; case runStateT m s of Nothing -> return False; Just (s', _) -> put s' >> return True)
14:34:31 <lambdabot> MonadState s m => [StateT s Maybe s] -> m [StateT s Maybe s]
14:34:38 <dmwit> Gurkenglas: ^^
14:35:01 <dmwit> :t runStateT
14:35:02 <lambdabot> StateT s m a -> s -> m (a, s)
14:35:09 <dmwit> whoops, got my state-side backwards
14:35:15 <dmwit> :t filterM (\m -> do s <- get; case runStateT m s of Nothing -> return False; Just (_, s') -> put s' >> return True)
14:35:16 <lambdabot> MonadState s m => [StateT s Maybe a] -> m [StateT s Maybe a]
14:36:54 <ctesiphon> ertes: http://lpaste.net/172317
14:37:18 <ctesiphon> this is where I run into problems - I'm not quite sure what I'm missing in the function
14:37:19 <Gurkenglas> :t filterM (\m -> (m $> False) <|> pure True)
14:37:20 <lambdabot> (Monad m, Alternative m) => [m a] -> m [m a]
14:37:43 <Gurkenglas> Um switch those bools, boolean blindness strikes again
14:38:00 <Gurkenglas> (though this way round also sounds cool in some situations.)
14:38:27 <ertes> ctesiphon: you're contradicting yourself in that code:  you're expecting a tuple, but then in the type you're claiming that it takes a list
14:38:29 <dmwit> :t filterM (\m -> mapStateT fromJust ((True <$ m) <|> pure False))
14:38:30 <lambdabot>     Occurs check: cannot construct the infinite type: s ~ (Bool, s)
14:38:30 <lambdabot>     Expected type: Maybe (Bool, s) -> (Bool, (Bool, s))
14:38:30 <lambdabot>       Actual type: Maybe (Bool, (Bool, s)) -> (Bool, (Bool, s))
14:38:56 <ctesiphon> ertes: ah, that was a mistake I made when copying the code from my module since there's  extra stuff that doesn't matter in this example
14:39:08 <dmwit> :t mapStateT
14:39:09 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
14:39:19 <dmwit> :t mapStateT (Identity . fromJust)
14:39:19 <ctesiphon> ertes: alright, edited.
14:39:20 <lambdabot> StateT s Maybe b -> StateT s Identity b
14:40:46 <Gurkenglas> :t mapStateT (Identity . fromJust) . filterM (\m -> (m $> False) <|> pure True) -- yepyep
14:40:47 <lambdabot> [StateT s Maybe a] -> StateT s Identity [StateT s Maybe a]
14:40:51 <ertes> ctesiphon: first a general remark: you really shouldn't reduce to () for benchmarking
14:41:05 <ertes> ctesiphon: benchmark using 'nf' and an actual result
14:43:18 <Gurkenglas> :t filterM (\m -> ascertain False $ m $> True) -- lpaste.net/150858
14:43:19 <lambdabot> (Monad m, PointedAlternative f m) => [f a] -> m [f a]
14:44:51 <ctesiphon> ertes: oh, I was going to modify the code I have there, but I see
14:45:01 <ctesiphon> I should keep the map I build. alright.
14:47:23 <ertes> ctesiphon: adjust your code, and if that doesn't magically fix it, please attach the error message to the paste (make sure your code is complete, so that the line numbers match)
14:47:36 <ertes> otherwise we'd have to guess what's wrong =)
14:48:39 <danilo2> Hello guys! Is there in Haskell something like IORef but as fast as possible? Just like memory reference from C++ ? 
14:48:51 <glguy> Like a secret fast IORef?
14:48:55 <Koterpillar> danilo2: what do you want to do?
14:48:58 <maerwald> ST?
14:49:02 <Koterpillar> danilo2: ForeignPtr?
14:49:28 <danilo2> Koterpillar: nope, it is pointer. I want to have a reference to have access to the value without the additional jump
14:49:44 <geekosaur> I suspect the answer is no, just because it would play rather badly with the gc's assumptions about purity and ability to relocate things.
14:49:58 <Koterpillar> danilo2: reference to what? show a use case
14:49:59 <ertes> danilo2: use recursion, which can often unbox the value
14:50:04 <danilo2> Koterpillar: to an Int
14:50:17 <Koterpillar> danilo2: a single mutable int? 
14:50:22 <danilo2> ertes: it doesnt work here for some reasons
14:50:24 <danilo2> Koterpillar: yep
14:50:39 <ertes> danilo2: what doesn't work, and how does it not work?
14:51:16 <ertes> danilo2: i suggest you write the code you want to write using IORef and paste it…  then we might be able to help you improve its performance
14:51:43 <Koterpillar> danilo2: the price you pay might be for thread safety
14:52:10 <Koterpillar> danilo2: regardless, I think ForeignPtr *might* be faster
14:52:10 <danilo2> Koterpillar: i dont want thread safety. I want to set the values once on the beginning in runtime and then just access them many times
14:52:32 <Koterpillar> danilo2: so, not even mutable?
14:52:51 <ertes> danilo2: why don't you just do that then?  use bindings and functions
14:52:51 <danilo2> Koterpillar: mutable in some way - mutable once on the beginning, after initial setting, read only
14:52:58 <dmwit> danilo2: Int is a pretty good type for an immutable reference to an Int.
14:53:03 <hpc> why must it be mutable at the beginning?
14:53:17 <ctesiphon> ertes: alright, the error I got this time is clearer http://lpaste.net/172317
14:53:19 <danilo2> hpc: because I want to compute it in runtime, set it and use it many times
14:53:32 <ertes> danilo2: main = initThing >>= mainWithThing
14:53:34 <Koterpillar> danilo2: well, you've got all the options already
14:53:37 <hpc> you can't just define some immutable Int to be the correct value?
14:53:50 <Koterpillar> danilo2: also, just normal State Int
14:53:59 <hpc> (immutability isn't just for global constants)
14:55:02 <ertes> ctesiphon: your code is making an assumption without justifying it:  that 'MapKey m' and 'MapValue m' are the same type
14:55:20 <ertes> ctesiphon: does it work without the type signature?
14:55:30 <danilo2> ertes: of course, sorry for providing not enough info. I was talking about it earlier.  I need following interface: `getTheInt :: Proxy a -> m Int` - I want to access the int just having a type information and I want this int to be associated with a type only
14:55:44 <ctesiphon> it does, I should've checked after changing this, my bad
14:55:47 <dmwit> ctesiphon: Just add `MapValue map ~ MapKey map` to your type's context.
14:55:54 <Koterpillar> danilo2: so, many ints?
14:56:13 <danilo2> Koterpillar: a single int for a given type. 
14:56:15 <maerwald> @hackage reflection -- danilo2 do you know that one?
14:56:15 <lambdabot> http://hackage.haskell.org/package/reflection -- danilo2 do you know that one?
14:56:18 <ctesiphon> dmwit: I tried doing that but it failed - I presume I was doing something wrong, but I'll remember your suggestion in the future. thanks.
14:56:40 <dmwit> ctesiphon: How did it fail?
14:56:56 <danilo2> maerwald: no, Im looking into it
14:57:11 <maerwald> danilo2: http://lpaste.net/161348 here's an example
14:57:11 <dmwit> ctesiphon: It WFM.
14:57:12 <ertes> dmwit: earlier there was an actual type error
14:57:14 <ctesiphon> basically, it told me that MapKey was a type function which may not be ijective
14:57:26 <ertes> dmwit: tuple vs. list, that's probably why it failed
14:57:52 <ertes> ctesiphon: well, let's get to the design of your IsMap class…  i think it's horrible =)
14:58:20 <maerwald> because what you describe to me sounds like a "configuration problem": compute some stuff at the start of the program, feed it to the rest and access it many times
14:58:24 <dmwit> ctesiphon: I'd be happy to explain. But we'd need to see the exact code and error for that. I tested the change I'm suggesting on my own machine and it works.
14:58:43 <maerwald> that's what the reflection package solves
14:58:46 <ctesiphon> ertes: I think so too, but I prefer doing that than writing a test for each function I want to test, and this for each datatype
14:59:21 <ertes> ctesiphon: this is how i would have designed it:  class IsMap map where type Key map;  insert :: Key map -> a -> map a -> map a
14:59:26 <ertes> ctesiphon: do you see the difference?
14:59:33 <danilo2> maerwald: it sounds like this. The only constrain additional from my side is to access it as fast as possible by type-> value assotiation
15:00:18 <ctesiphon> ertes: I do, yes
15:00:25 <ctesiphon> let me trying and make that change
15:00:26 <maerwald> danilo2: the values are "reflected" by type classes, I guess that's fast?
15:00:32 <maerwald> you can read about it here http://okmij.org/ftp/Haskell/tr-15-04.pdf
15:00:43 <ctesiphon> dmwit: I appreciate your assistance but it works now, thanks a lot.
15:01:04 <ertes> maerwald: the paper would suggest it's slow, but the actual implementation uses a hack that makes it fast
15:01:08 <maerwald> also mind that the reflection package uses a GHC trick which is even faster than what the paper describes
15:01:12 <maerwald> yes
15:02:05 <ertes> danilo2: do you have something that is actually type-bound?  i.e. do you have a specific reason to communicate the value as a type?
15:02:45 <ctesiphon> ertes: that map type needs to be up top as IsMap (map a), doesn't it?
15:05:29 <ertes> ctesiphon: note that IsMap now takes an argument of kind * -> *, if you use my design
15:05:46 <ertes> instance (Eq k, Hashable k) => IsMap (HashMap k)
15:06:02 <danilo2_> ertes: yes, if I understand the question correctly. I've got many types defined in the library and want to give ability to users to define their types. There is a great type level machinery that uses the types and that have to be distinct types.
15:07:03 <ertes> danilo2_: could you be more specific?
15:07:49 <Gurkenglas> Requesting "MonadState s m => Traversal' s a -> (a -> m a) -> m ()"
15:08:20 <ctesiphon> ertes: does this have any impact on performance? if it doesn't, then I think I'll focus on these changes after I actually get the benchmarks to work
15:08:35 <Gurkenglas> Like %=, only monadic.
15:08:56 <danilo2_> ertes: sure! I've got types: T1, T2, ... T10. It is a binary that is compiled and have an API that allows for creating plugins that will be loaded in the future in runtime as object files or sometihng similar. Anywa users can define their types and declare - hey, this is the type that will have the Int associated. An algorithm would collect these types, compute these ints on the beginning and then use it frequently - alwyas just ba
15:08:59 <ertes> ctesiphon: it has an impact on reasoning about performance, but not on the performance itself
15:09:21 <danilo2_> I want to access these ints as fast as possible - so I was talking about something similar to memory references from C++ 
15:09:34 <danilo2_> ertes: is it more clear now ?
15:10:12 <ertes> danilo2_: in part yeah…  the essence of the problem is to compute something at the beginning and then reuse it
15:10:26 <Koterpillar> danilo2_: when would the numbers change?
15:10:31 <ertes> danilo2_: that's not in itself a type-level problem, and personally i'd just pass the computed value along
15:10:45 <danilo2_> ertes: exactly. Koterpillar never - they will be computed on the beginning based on all collected types. 
15:10:51 <Koterpillar> ...
15:11:08 <Koterpillar> so they are only computed once, when everything is loaded?
15:11:23 <danilo2_> Koterpillar: but it has to be done in runtime, because the libraries that are compiled and loaded in runtime doesnt know about types defined in other libraries
15:11:29 <ertes> danilo2_: by using any kind of reference type you're not only making the code harder to write, but also some optimisations (notably unboxing) become impossible
15:11:51 <Koterpillar> danilo2_: I don't think you can access type information from other libraries at runtime
15:12:00 <danilo2_> Koterpillar: yes. I'm sorry If I described something that confused you. They are computed once, after everything is loaded in runtime
15:12:04 <importantshock> Is there a function that's dual to evalFree :: (a -> b) -> (f (Free f a) -> b) -> Free f a -> b, but over Cofree?
15:12:07 <importantshock> It's easy to define: buildCofree f g t = (f t) <: (g t)
15:12:09 <Koterpillar> danilo2_: you'll have to bundle a compiler for that
15:12:10 <importantshock> with type signature (t -> a) -> (t -> f (Cofree f a)) -> t -> Cofree f a
15:12:11 <Gurkenglas> Oh hey. You could, apply, the traversal, to the function. ..............
15:12:15 <importantshock> It just seems so obvious that I'm convinced there must be a preexisting combinator for it.
15:12:45 <Koterpillar> danilo2_: I suggest you look into that first, as maybe your design will have to change
15:13:58 <ertes> danilo2_: so you have a program that loads plugins…  who initialises?  the program or the plugin itself?
15:13:59 <danilo2_> ertes, Koterpillar : ok, thank you for your time and this conversation. I was thinking it could be impossible. The guys on #ghc channel told me just a minute ago that it will not be possible without changing the GHC memory management, beause it could be theoreticlly possible but it needs some kind of global variables associated with types
15:14:24 <danilo2_> ertes: these plugins are ininitialised by the main program
15:14:39 <ertes> danilo2_: by doing what?  invoking an action from the module?
15:14:41 <Koterpillar> danilo2_: by the time a (GHC compiled) program is run, it has no type information
15:15:13 <ertes> s/module/plugin/
15:15:43 <Koterpillar> danilo2_: you can allow users to write more modules and call your main with extended options, xmonad-style
15:15:51 <ertes> danilo2_: let me just ask the important question:  does the program ever need to know the *type* of that value?
15:16:09 <danilo2_> ertes: it would not be possible to just assign a value to a type, so we could access it having only type information as fast as using memory reference
15:16:18 <buglebudabey> does anyone think that the State monad is appropriate here to keep track of the learning material in my program? http://lpaste.net/172345
15:16:29 <danilo2_> ertes: yes, there is some type level machinery involved
15:16:39 <danilo2_> Koterpillar: exactly
15:16:56 <Koterpillar> danilo2_: if you're doing that, you can compute everything at compile time
15:17:03 <Koterpillar> danilo2_: including your numbers
15:17:20 <ertes> danilo2_: well, i don't understand your program enough to make any educated suggestions, but in general you should try using a bare value with no reference wrapper (no IORef, no pointers)
15:17:49 <Koterpillar> danilo2_: your T1..T10 will be in a type level list, which can be extended by the user
15:18:27 <ertes> buglebudabey: for what purpose?
15:19:02 <Koterpillar> danilo2_: I've done a similar thing to register plugins: https://github.com/koterpillar/tianbar/blob/master/src/System/Tianbar/Plugin/All.hs (by the way, critique welcome)
15:19:03 <buglebudabey> i want to make classify a reusable function ertes 
15:19:13 <ertes> buglebudabey: isn't it reusable already?
15:19:14 <danilo2_> Koterpillar: it would require users to re-compile the main program. I would love to avoid it
15:19:25 <buglebudabey> ertes not sure, to be honest
15:19:40 <Koterpillar> danilo2_: yes, you'll need to recompile; you *have to* compile if you want type information
15:19:40 <ertes> buglebudabey: let myClassify = classify mat  -- now use myClassify
15:19:45 <danilo2_> Koterpillar: but yes, having assumption that users can writing the module / plugin  - change this type level list, it sovles the problem.
15:20:05 <ertes> buglebudabey: that's why you rewrote it to share the intermediate values
15:20:26 <buglebudabey> but what if the material changes over time?
15:20:41 <ertes> buglebudabey: does it change in an incremental manner?
15:20:42 <Koterpillar> danilo2_: what you can do instead is convert each type into a set of functions
15:20:52 <Koterpillar> danilo2_: and associate that with a number
15:21:08 <buglebudabey> ertes it could, as more text is classified
15:21:11 <danilo2_> Koterpillar: what do you mean by set of functions ?
15:21:20 <buglebudabey> ertes incrementally with each classification
15:21:42 <ertes> buglebudabey: in that case (and also to be able to serialise the current counts) you should have a type for your model
15:21:46 <Koterpillar> danilo2_: well, what operations would the main program perform on the user-supplied types?
15:22:34 <buglebudabey> ertes not sure what you mean by serialize the current counts
15:22:46 <buglebudabey> ertes the calculated data?
15:22:57 <ertes> buglebudabey: data BayesModel;  learn :: [Text] -> Class -> BayesModel -> BayesModel
15:23:12 <Koterpillar> danilo2_: do those types have to implement some typeclass currently?
15:23:17 <ertes> buglebudabey: classify :: BayesModel -> Text -> Map Class Double
15:23:17 <danilo2_> Koterpillar: it is a complex one to be honest. It is an internal API of a custom compiler and these plugins ar just compiler extensions
15:23:34 <Koterpillar> danilo2_: well, tough, but I'll still give you an example
15:23:48 <danilo2_> Koterpillar: they could have to implement. Its ok. The only thing important to me is not to force to recompile the compiler when compiling a plugin
15:24:01 <ertes> buglebudabey: now the model is a first-class value that you can reuse and serialise (turn into a string e.g. to save in a file or transfer over the network)
15:24:22 <ertes> buglebudabey: no State
15:24:46 <Koterpillar> danilo2_: http://lpaste.net/172349
15:25:27 <ertes> buglebudabey: if in doubt, don't use State…  you never *need* it, and very often when it's tempting to use it, you probably shouldn't
15:25:31 <Koterpillar> danilo2_: I'm sure this pattern has a name, but I forgot it
15:25:38 <ertes> buglebudabey: same with Reader and Writer
15:26:26 <buglebudabey> ertes alright, thank you a bunch. so with BayesModel, is learn an accessor for the constructor?
15:27:02 <Gurkenglas> Can I ask ghc, which failed to compile a file, what types it thinks any given name to have?
15:27:09 <Gurkenglas> (-name+term?)
15:27:18 <Gurkenglas> -types+type
15:27:26 <Koterpillar> Gurkenglas: add a type annotation with _ for the type (a "hole")
15:27:27 <ertes> Gurkenglas: prefix the name with _
15:27:44 <ertes> buglebudabey: 'learn' is a function
15:28:01 * hackagebot gnss-converters 0.1.13 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.13 (markfine)
15:28:02 <danilo2_> Koterpillar: I see what you are talking about, but it isnt relative to my problem. It is not your foult - I jsut didnt want dig to deeply into description, so I'm sorry for that. I could explain it in detal, but I didnt want to take too much of your time. Additionaly I'm sure right now that what I want is not possible right now in Haskell, but could be theoretically
15:28:03 * hackagebot hw-json 0.2.0.3 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.2.0.3 (haskellworks)
15:28:09 <ertes> buglebudabey: it learns the given training sample and returns an updated BayesModel
15:28:09 <buglebudabey> ertes what i mean is data BM = BM {learn :: ..}?
15:28:15 <ertes> buglebudabey: nope
15:28:35 <buglebudabey> should BM contain anything then?
15:28:48 <ertes> buglebudabey: most likely:  newtype BayesModel = BayesModel { Map Class (Map Text Int, Int) }  -- something along these lines
15:28:55 <ertes> buglebudabey: sure, it should contain the counts
15:29:14 <ertes> along with the totals (makes classification a lot faster)
15:29:58 <buglebudabey> ertes alright, thanks 
15:32:09 <danilo2_> Koterpillar: thank you for your time. If I will not find any solution and you will be willing to look into it in detail, I would love to make some detailed examples then :)
15:32:23 <Koterpillar> danilo2_: looks interesting, feel free to
15:33:01 * hackagebot haskell-src-exts 1.18.2 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  https://hackage.haskell.org/package/haskell-src-exts-1.18.2 (mpickering)
15:38:01 * hackagebot layout 0.0.0.2 - Turn values into pretty text or markup  https://hackage.haskell.org/package/layout-0.0.0.2 (RobertHensing)
15:48:02 * hackagebot hw-json 0.2.0.4 - Conduits for tokenizing streams.  https://hackage.haskell.org/package/hw-json-0.2.0.4 (haskellworks)
15:50:59 <Gurkenglas> http://lpaste.net/172363 <- If I comment out line 58, line 86 also stops tracing. What?
15:51:14 <slack1256> what are the implications of type families being functional relations on types instead of type functions?
15:51:36 <slack1256> And how does that affect the "doing functional programming at type level" instead of "doing logic programming at type level"
15:52:46 <slack1256> BTW to me an easy way to get this is doing (T a ~ b) everywhere so that unification (logic programming) really becomes reduction (functional programming)
16:03:02 * hackagebot table-layout 0.7.0.0 - Layout text as grid or table.  https://hackage.haskell.org/package/table-layout-0.7.0.0 (muesli4)
16:07:45 <hrumph> what module should i use if want to use a state monad?
16:08:51 <hrumph> there is control.monad.state.lazy control.monad.trans.state
16:09:02 <hrumph> maybe a million others
16:09:10 <hrumph> which one should i be using?
16:09:20 <Koterpillar> Control.Monad.State
16:09:21 <geekosaur> Control.Monad.State usually.
16:10:34 <geekosaur> Control.Monad.Trans.State is part of the implementation that you normally don't have to worry about. the distinction between strict and lazy is also usually not very important; most things just take the default from Control.Monad.State
16:11:24 <hrumph> geekosaur, whatis control.monad.st all about?
16:12:02 <geekosaur> I don't understand the question
16:12:27 <hrumph> https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad-ST.html
16:12:43 <hrumph> comes with the base package
16:13:37 <geekosaur> that's not related to state monads. a "state thread" is essentially a collection of data that is required to remain in the current computation, and cannot be exposed to any other computation
16:13:46 <hrumph> ah
16:13:49 <geekosaur> this is how we hide mutable algorithms inside of pure code
16:13:54 <hrumph> ok
16:13:58 <geekosaur> because the mutation is all done inside of ST
16:13:59 <hrumph> thanks
16:14:21 <hrumph> ok got it
16:38:04 * hackagebot postgrest-ws 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/postgrest-ws-0.1.0.0 (diogob)
16:38:28 <Koterpillar> nice package description
16:38:38 <jle`> lol
16:39:42 <hpc> that's like the time i uploaded a totally empty package by accident
16:39:58 <hpc> turns out 'cabal check' didn't tell me i wasn't exposing any modules
16:43:04 * hackagebot pasta 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/pasta-0.1.0.0 (diogob)
16:43:44 <geekosaur> heheh
16:43:58 <geekosaur> maybe some sanity checking is needed somewhere >.>
16:44:22 <glguy> Good thing your test-suite caught it!
16:44:45 <Koterpillar> yeah, like if the description is the default, send an email to Author name here <example@example.com>
16:48:04 * hackagebot pasta 0.1.0.1 - PostgreSQL Abstract Syntax Tree Assember  https://hackage.haskell.org/package/pasta-0.1.0.1 (diogob)
16:48:06 * hackagebot postgrest-ws 0.1.0.1 - PostgREST extension to map LISTEN/NOTIFY messages to Websockets  https://hackage.haskell.org/package/postgrest-ws-0.1.0.1 (diogob)
16:53:04 * hackagebot QuickCheckVariant 0.1.1.0 - Generator of "valid" and "invalid" data in a type class  https://hackage.haskell.org/package/QuickCheckVariant-0.1.1.0 (sanjorgek)
17:15:33 <cloudhead> is there a better way to write this: https://gist.github.com/cloudhead/fe0055549ccfa2c3e1d81045f78860ce ?
17:17:03 <cloudhead> and will it actually build the whole list, even if the first slot is free?
17:17:25 <monochrom> it won't. that's one thing you don't have to worry about.
17:17:49 <monochrom> I'm wondering if you have to write "go" yourself.
17:18:05 * hackagebot gnss-converters 0.1.14 - GNSS Converters.  https://hackage.haskell.org/package/gnss-converters-0.1.14 (markfine)
17:18:26 <monochrom> Actually I'm also wondering if you don't need IntMap (Maybe Item)
17:19:50 <cloudhead> monochrom: I see, so it will build the list lazily?
17:19:58 <monochrom> yes
17:20:15 <cloudhead> because toAscList/assoc says it's O(n), but that's assuming it's strict
17:20:42 <cloudhead> or rather, that's assuming it runs through
17:21:13 <monochrom> you do have a worst case where the free slot is at the end so you go through the whole thing
17:21:27 <cloudhead> yeah, I'm fine with that
17:21:35 <cloudhead> so now the question is if there's a more concise way to express it
17:21:53 <cloudhead> the closest function I found is `find`, but it returns the value instead of the key
17:22:35 <monochrom> it looks like you can replace your own "go" by foldrWithKey
17:22:36 <cloudhead> and uses foldMap internally
17:23:08 <cloudhead> I started that way, but the problem is that will give me the /last/ free slot, no?
17:23:21 <cloudhead> because it won't return when I'm done
17:23:46 <monochrom> how do you know it's the last slot not the first slot?
17:24:41 <cloudhead> oh wait will foldr iterate the map from largest to smallest key?
17:25:28 <cloudhead> I'm just thinking of it in terms of the `b`/result being overwritten until it reaches the last free slot
17:25:43 <cloudhead> because foldr doesn't exit after the first one
17:26:06 <cloudhead> it would only work if it went through the intmap in reverse
17:27:11 <monochrom> OK. I have this expression, it's about [] not IntMap but its lesson extends to foldrWithKey.  foldr (&&) undefined [False, undefined, undefined].  Predict its answer (or lack thereof).
17:27:46 <monochrom> (The scientific method asserts that if your prediction mismatches with reality, your mental model is wrong.)
17:27:58 <cloudhead> :o
17:29:04 <cloudhead> I'd say False
17:29:15 <monochrom> That's correct.
17:29:37 <cloudhead> ok, good
17:29:51 <monochrom> It totally does not care about "the end" or "the last slot" or whatever you call it, right?
17:30:10 <cloudhead> oh I see
17:30:15 <cloudhead> hold on let me think about this
17:31:05 <cloudhead> but that's because once it finds a 'False', it's always going to be False
17:31:08 <cloudhead> right?
17:31:17 <cloudhead> False && _ = False
17:32:11 <monochrom> So foldrWithKey will find the first free slot and it's always going to return that slot and never bother the rest of the slots.
17:32:55 <cloudhead> that's what doesn't make sense to me
17:33:01 <cloudhead> why won't it bother with the rest?
17:33:28 <cloudhead> if I do foldr (+) 0 xs
17:33:32 <cloudhead> it'll go through the whole list
17:34:00 <monochrom> (+) is different from (&&)
17:34:21 <monochrom> (+) doesn't have a clause that says "4 + _ = 4"
17:34:36 <cloudhead> right
17:35:20 <cloudhead> but `k` will be different in every (k, Nothing) case
17:35:44 <cloudhead> if I get a False at the beginning or at the end, it's the same false
17:36:17 <erisco> monochrom, what is such an object called?
17:36:30 <monochrom> consider "foldrWithKey f Nothing" where f is defined by: f k Nothing _ = Just k; f _ (Just _) r = r
17:37:04 <monochrom> the first clause "f k Nothing _ = Just k" is analogous to "False && _ = False".
17:37:43 <cloudhead> but won't it keep iterating after that?
17:38:00 <cloudhead> and then the first `Just k` will be replaced by the next `Just k`
17:38:04 <monochrom> []'s foldr certainly doesn't keep iteration after False.
17:39:20 <monochrom> In fact let's go more extreme. foldr (\_ _ -> ()) undefined (repeat undefined)
17:39:32 <monochrom> does this even terminate?
17:40:00 <monochrom> erisco: What object? I am not OO.
17:40:08 <erisco> monochrom, xy = x  what is x called?
17:40:15 <cloudhead> hmm that would be an infinite list, no?
17:40:20 <erisco> monochrom, as in,  xy = y  x is a left-identity
17:40:33 <monochrom> yes, I have an infinite list. will my code terminate?
17:40:55 <erisco> @let inf ~(x:xs) = x : inf xs
17:40:57 <lambdabot>  Defined.
17:41:06 <monochrom> erisco, do you have quantifiers? for all x? exists x? for all y? exists y?
17:41:11 <cloudhead> I guess in my intuition it won't
17:41:14 <erisco> monochrom, foralls
17:41:23 <monochrom> OK, let's check with reality
17:41:31 <cloudhead> this also doesn't make sense to me now that I think of it:
17:41:34 <monochrom> > foldr (\_ _ -> ()) undefined (repeat undefined)
17:41:36 <lambdabot>  ()
17:41:41 <cloudhead> > foldr (\a b -> a) [1,2,3]
17:41:42 <lambdabot>      No instance for (Typeable t0)
17:41:42 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
17:41:42 <lambdabot>        arising from a use of ‘show_M35382402752272523320206’
17:41:48 <cloudhead> > foldr (\a b -> a) 0 [1,2,3]
17:41:50 <lambdabot>  1
17:42:07 <erisco> monochrom, no no… x is the object, ∀y xy = x  is the law
17:42:09 <cloudhead> yeah it's the same thing I guess
17:42:16 <cloudhead> I would have said it should return 3
17:42:39 <erisco> what is 0 to multiplication?
17:42:47 <monochrom> See how a few tests and easily refute 99% of humanity's mental models?
17:42:57 <cloudhead> heh yeah.
17:43:10 <cloudhead> > foldl (\a b -> a) 0 [1,2,3]
17:43:11 <lambdabot>  0
17:43:23 <monochrom> foldl is the one that will walk the whole list
17:43:38 <cloudhead> but then why do I get 0 here
17:43:44 <cloudhead> > foldl (\a b -> b) 0 [1,2,3]
17:43:45 <lambdabot>  3
17:43:47 <monochrom> (and then regret that it's unnecessary. but the damage is done.)
17:44:14 <erisco> > foldr (+) a [b,c,d]
17:44:16 <lambdabot>  b + (c + (d + a))
17:44:21 <erisco> > foldl (+) a [b,c,d]
17:44:23 <lambdabot>  a + b + c + d
17:44:38 <erisco> well that's a little unhelpful lambdabot but okay :P
17:44:47 <monochrom> erisco: It is called "zero" in the general setting.
17:45:01 <erisco> monochrom, really? interesting
17:45:29 <monochrom> they ran out of fancy names. "A ring has an identity and a zero", etc.
17:46:32 <erisco> cloudhead, note the second example reads  (a + b) + c + d
17:46:43 <erisco> I mean  ((a + b) + c) + d
17:46:51 <cloudhead> right
17:46:59 <erisco> well, left actually, but yes
17:47:05 <cloudhead> :D
17:47:24 <erisco> \a b -> a  this is const
17:47:46 <erisco> so what is  const (const (const 0 1) 2) 3?
17:48:01 <cloudhead> hah
17:48:12 <cloudhead> 3
17:48:22 <cloudhead> wait no
17:48:33 <cloudhead> const drops the second argument
17:48:57 <cloudhead> so it's 0
17:49:18 <erisco> so what is why you get zero :)
17:49:22 <erisco> so that*
17:49:59 <cloudhead> yeah, makes sense now!
17:50:12 <cloudhead> but now with foldr
17:50:18 <erisco> and why does foldl go through the whole list? well, look at how much work you have to do to get to the zero
17:50:38 <cloudhead> yeah, you have to evaluate the left argument until you reach the end
17:50:42 <erisco> what is  const 0 (const 1 (const 2 3))
17:50:46 <monochrom> foldr const 0 [1,2,3] = const 1 (const 2 (const 3 0))  So this time it's different
17:50:49 <cloudhead> 0
17:50:53 <cloudhead> and no need to evaluate the rest
17:51:01 <erisco> const is not strict on the second argument, so it is not evaluated
17:51:29 <cloudhead> monochrom: I think that resets my mental model of foldr
17:51:49 <erisco> this is the characteristic property of foldr that you need to know
17:51:57 <erisco> foldr (:) [] ≡ id
17:52:30 <dibblego> http://functionaltalks.org/2013/06/19/tony-morris-explain-list-folds-to-yourself/
17:52:40 <erisco> there are other functions like this.  either Left Right ≡ id, maybe Nothing Just ≡ id, bool True False ≡ id
17:53:31 <cloudhead> I understand those, but not so much the foldr one
17:53:51 <dibblego> (foldr f z list) replaces (:) with (f) and [] with (z) in (list)
17:53:55 <erisco> lists are recursive, so that is why they are more complicated
17:54:34 <kj_> kjke4e5pwd
17:54:43 <erisco> another good explanation dibblego :)
17:56:02 <bburd> Hello. I'm looking for someone to review about 15 slides that I made about monads. The slides are supposed to be language-agnostic. It's for a video program that I'm doing. I don't need them to be faithful to Haskell, only a reasonably good introduction to monads. Any help?
17:56:16 <dibblego> bburd: ok
17:56:43 <cloudhead> dibblego: thanks, will check that
17:56:52 <bburd> dibblego: Should I send them to you somehow?
17:57:05 <dibblego> bburd: sure, tonymorris at the gmail
17:57:28 <erisco> I suppose my way is a poor way to characterise them
17:57:42 <shachaf> You would do better to post them for anyone to comment, rather than getting one person to commit to helping you sight-unseen.
17:57:44 <erisco> it is just an important observation then
17:58:02 <dibblego> also, what shachaf said is true, just post a link with the ability to make comments/patches
17:58:06 * hackagebot isobmff-builder 0.10.0.0 - A (bytestring-) builder for the ISO-14496-12 base media file format  https://hackage.haskell.org/package/isobmff-builder-0.10.0.0 (SvenHeyll)
17:58:08 * hackagebot gloss-rendering 1.10.3.3 - Gloss picture data types and rendering functions.  https://hackage.haskell.org/package/gloss-rendering-1.10.3.3 (BenLippmeier)
17:58:10 * hackagebot gloss 1.10.2.3 - Painless 2D vector graphics, animations and simulations.  https://hackage.haskell.org/package/gloss-1.10.2.3 (BenLippmeier)
17:59:14 <erisco> cloudhead, data BinTree a = Branch a (BinTree a) (BinTree a) | Leaf    you can write a fold for this to test your knowledge
18:00:25 <erisco> also, look at this
18:00:31 <erisco> :t curry
18:00:32 <lambdabot> ((a, b) -> c) -> a -> b -> c
18:00:47 <erisco> I mean the other one -.-
18:00:49 <erisco> :t uncurry
18:00:50 <lambdabot> (a -> b -> c) -> (a, b) -> c
18:01:07 <erisco> uncurry is fold for 2-tuples
18:02:09 <cloudhead> hmm in what way?
18:02:30 <c_wraith> It certainly follows the fold pattern.
18:02:35 <erisco> well, look at the types of 'either', 'maybe', 'bool', 'foldr', and 'uncurry'
18:03:02 <c_wraith> It's important to note that (,) is the only one there with only a single constructor.
18:03:07 * hackagebot gloss-raster 1.10.2.3 - Parallel rendering of raster images.  https://hackage.haskell.org/package/gloss-raster-1.10.2.3 (BenLippmeier)
18:03:09 * hackagebot gloss-algorithms 1.10.2.3 - Data structures and algorithms for working with 2D graphics.  https://hackage.haskell.org/package/gloss-algorithms-1.10.2.3 (BenLippmeier)
18:03:15 <c_wraith> Which changes the way it works to some extent
18:03:21 <erisco> :t runIdentity
18:03:23 <lambdabot> Identity a -> a
18:03:31 <erisco> well, that doesn't work
18:03:47 <c_wraith> it's not a fold. :)
18:04:02 <erisco> indeed not
18:04:02 <c_wraith> :t (. runIdentity)
18:04:04 <lambdabot> (b -> c) -> Identity b -> c
18:04:09 <erisco> much better
18:04:41 <monochrom> The (,) case is much less obvious until you have seen a lot of other examples and then come back to see that the (,) case is degenerate.
18:05:14 <erisco> ah, here is a tricky one
18:05:15 <erisco> :t id
18:05:17 <lambdabot> a -> a
18:05:26 <erisco> I suppose that is a little unfair
18:05:35 <c_wraith> would that be the fold of Void?
18:05:41 <monochrom> But if you get Maybe, Either, [], BinTree, then you're pretty good already, and they're the more important examples anyway.
18:06:09 <erisco> c_wraith, perhaps. I don't know what happens at this big bang XD
18:06:21 <cloudhead> I'm going to try doing the BinTree one tomorrow to improve my intuition
18:06:51 <erisco> :t const :: a -> () -> a
18:06:53 <lambdabot> a -> () -> a
18:07:25 <erisco> cloudhead, if you're ambitious look up "Church encoding"
18:08:07 * hackagebot hspecVariant 0.1.0.0 - Spec for testing properties for variant types  https://hackage.haskell.org/package/hspecVariant-0.1.0.0 (sanjorgek)
18:08:09 * hackagebot gloss-examples 1.10.2.3 - Examples using the gloss library  https://hackage.haskell.org/package/gloss-examples-1.10.2.3 (BenLippmeier)
18:08:16 <cloudhead> ah I remember that in the lisp paper
18:08:53 <cloudhead> when I understood how it's possible to create lists via lambdas only, it was pretty illuminating
18:09:09 <c_wraith> turns out folds are the same thing.
18:09:25 * cloudhead ponders
18:09:45 <cloudhead> yes I see why you would say that :D
18:11:36 <cloudhead> the structure looks identical
18:13:56 <c_wraith> well. more precisely, a fold converts a data structure to its church encoding 
18:14:15 <erisco> though the data structure comes last in Haskell *shrug*
18:14:18 <cloudhead> right, exactly!
18:14:45 <erisco> then the constructors convert the Church encoding back into the data
18:15:09 <cloudhead> what would be an identity fold then?
18:15:12 <cloudhead> is there such a thing?
18:15:19 <erisco> foldr (:) []
18:15:45 <erisco> I listed quite a few earlier if you recall :)
18:15:45 <cloudhead> ah, we come back to that
18:15:48 <cloudhead> it's making more sense now
18:15:48 <cloudhead> yes
18:16:39 <cloudhead> it's obvious in hindsight
18:16:42 <cloudhead> :D
18:17:12 <cloudhead> > foldr (:) [] [a,b,c]
18:17:14 <lambdabot>  [a,b,c]
18:17:18 <cloudhead> hmm
18:17:23 * cloudhead wants the church encoding
18:21:18 <erisco> the strange thing of Church encoding is it demonstrates you do not need branching
18:21:32 <erisco> the strange thing to me, that is. For some reason I had the implicit assumption you needed branching
18:26:24 <erisco> though it is still a fine option
18:48:15 <cloudhead> yeah, it's very strange/unintuitive at first, and just overall as a form of describing computation
19:23:09 * hackagebot simple-download 0.0.1 - A simple wrapper of http-conduit for file download.  https://hackage.haskell.org/package/simple-download-0.0.1 (terrorjack)
19:28:10 * hackagebot simple-download 0.0.2 - A simple wrapper of http-conduit for file download.  https://hackage.haskell.org/package/simple-download-0.0.2 (terrorjack)
19:42:14 <Guest42619> can someone explain to be why (/1) 2 is 2 and (1/) 2 is 0.5 the mechanics of how it works?
19:43:07 <Koterpillar> Guest42619: (/1) is \x -> x / 1
19:43:16 <Koterpillar> Guest42619: (1/) is \x -> 1 / x
19:43:37 <Guest42619> thanks man! wow am i slow
19:43:54 <dustmote> is there a nicer way to write this: `fmap (uncurry (*)) $ zip [3,4,5] [1,9,0]` .. perhaps using applicative? is zip & uncurry "more conventional" or is another way?
19:44:14 <dustmote> zipwith...
19:44:15 <geekosaur> :t zipWith
19:44:16 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
19:44:33 * dustmote facepalm
19:47:04 <Guest42619> so there is an invisible x right next ot the /
19:47:23 <Koterpillar> Guest42619: yes, that's the syntax
19:47:47 <Koterpillar> Guest42619: (/) is an infix operator; whichever side you fill, the other becomes the argument
19:48:10 <Guest42619> so like that is the lambda?
19:48:51 <Koterpillar> :t 1 `elem` -- Guest42619
19:48:52 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
19:48:57 <Koterpillar> :t (1 `elem`) -- Guest42619
19:48:58 <lambdabot> (Eq a, Num a, Foldable t) => t a -> Bool
19:49:19 <Koterpillar> Guest42619: any function can be called like that
19:49:35 <Guest42619> but where would the lamda be
19:49:48 <Guest42619> in terms of reducing
19:49:56 <Koterpillar> lambda (\x ...) is another way of making functions
19:50:30 <Guest42619> (\x...) <-- is the whole binding/
19:50:47 <Koterpillar> if you have f :: a -> b -> c, then (a `f`) :: b -> c, and (`f` b) :: a -> c
19:52:07 <Guest42619> thankss
20:01:55 <Guest42619> koterpillar you said any function can be called by that but the number is the number of times the  argument is applied right
20:02:42 <Koterpillar> what number?
20:03:36 <Guest42619> like when u said :t (1 `elem`) 
20:03:49 <Guest42619> the 1 is one times 'elem'
20:04:23 <Koterpillar> err
20:04:33 <Koterpillar> > 1 `elem` [1,2,3]
20:04:36 <lambdabot>  True
20:04:38 <Koterpillar> > 1 `elem` [4,5,6]
20:04:40 <lambdabot>  False
20:04:49 <Koterpillar> this is what elem is
20:04:55 <Koterpillar> > elem 1 [4,5,6]
20:04:56 <lambdabot>  False
20:05:09 <Koterpillar> I just called it infix-ly
20:05:39 <Guest42619> but what does the 1`elem` vs `elem` have 
20:06:27 <Koterpillar> 1 `elem` is the same as elem 1
20:06:32 <Koterpillar> :t 1 `elem`
20:06:34 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
20:06:36 <Koterpillar> :t elem 1
20:06:38 <lambdabot> (Eq a, Num a, Foldable t) => t a -> Bool
20:06:40 <Koterpillar> :t (1 `elem`)
20:06:41 <lambdabot> (Eq a, Num a, Foldable t) => t a -> Bool
20:06:52 <Koterpillar> :t (/) 1
20:06:53 <lambdabot> Fractional a => a -> a
20:06:58 <Koterpillar> :t (1 /)
20:06:59 <lambdabot> Fractional a => a -> a
20:07:17 <Koterpillar> both of these are ways to partially apply a function
20:07:47 <Guest42619> but what is the binding being evaluated
20:07:56 <Guest42619> thats the part im missing out
20:08:06 <Koterpillar> I'm sorry, what binding?
20:08:43 <Guest42619> like the part that gets evaluated removing the lamda symbol
20:08:55 <Koterpillar> where do you see the lambda symbol?
20:09:03 <Guest42619> isnt it implied?
20:09:46 <Koterpillar> ...no? certainly not the symbol
20:09:57 <Koterpillar> (/) is a value of type Fractional a => a -> a
20:10:03 <Guest42619> ooo i thought everything had to go through that
20:10:40 <Koterpillar> when compiling, technically, yes - in some sense
20:10:51 <Koterpillar> but this is just syntax sugar
20:11:15 <Guest42619> λ(x)  i thoguht wass   λ(1/)
20:11:20 <Guest42619> replacing the x
20:11:30 <Koterpillar> what is λ(x)?
20:11:54 <Koterpillar> I know what \x -> x is
20:11:55 <shachaf> Where did you read about that?
20:12:27 <Guest42619> λ is \?
20:12:46 <Koterpillar> yeah, I don't have an easy way of typing it
20:12:56 <Koterpillar> so still, what's λ(x)?
20:13:24 <Guest42619> ya so i thought \(x) was \(1/)
20:13:41 <Koterpillar> neither of those is a valid Haskell expression
20:16:41 <Guest42619> nonetheless thanks i finally get it lol
20:17:00 <Koterpillar> you're welcome
20:17:21 <Guest42619> i tend to overanalyze stuff lol
20:22:23 <isBEKaml> Hi, I recently compiled ghc 8.0.1 and it comes without cabal. Can stack be used without a cabal dependency?
20:22:50 <Koterpillar> isBEKaml: stack will even get itself GHC if it's not there
20:23:19 <ctesiphon> hey guys - if I have the union `un` of two structures (i.e. Data.Map.union) and I want to force that structure to be evaluated (benchmarking purposes), does `seq un un` work?
20:23:22 <glguy> isBEKaml: Yes, you can use stack without a cabal-install executable and cabal-install without stack
20:23:35 <dmj`> isBEKaml: stack depends on the Cabal library
20:23:46 <glguy> ctesiphon: No, seq un un is the same as just un
20:23:56 <isBEKaml> glguy: dmj`: good, to know. Thanks!
20:24:19 <ctesiphon> ah, this is a problem. bang patterns aren't working here. I'll take a look at what other functions I can use
20:25:23 <glguy> ctesiphon: When you're using 'nf' from criterion, it makes sure that the result is fully evaluated
20:25:50 <ctesiphon> glguy: alright, thanks. but for future reference : would `id $! un` work?
20:26:01 <glguy> No, id $! un is un
20:26:13 <ctesiphon> alright, thanks again.
20:26:47 <glguy> seq only evaluates its first argument to "weak head normal form", just far enough to find out what the outermost constructor is
20:27:03 <glguy> same for bang patterns, same for $!
20:28:06 <ctesiphon> glguy: so if I want to benchmark operations on containers, I should use `nf` and not `whnf`
20:28:27 <geekosaur> on most things, really
20:28:40 <glguy> ctesiphon: It mostly depends on which operations you're benchmarking, most containers are "spine strict"
20:28:57 <glguy> so if you're benchmarking an operation on the structure of the container, whnf is probably best
20:29:25 <glguy> but if you're operating on the elements then you'd want to make sure all the computation in the elements of the container are evaluated to, so nf
20:30:40 <ctesiphon> glguy: and does benchmarking a union between two `Data.Map`s or `Data.IntMap`s count as operating on the structure's elements?
20:31:40 <glguy> Normal unions are just left-biased unions, they don't compute on the elements
20:31:48 <glguy> normal in the containers package, at least
20:32:37 <glguy> so whnf should be enough there. I don't think you'd actually get much of a different answer just using nf, though
20:33:48 <isBEKaml> hmm, stack downloaded the lts configuration, which requires ghc 7.10. Can I not use stack with ghc-8.0.1 that I already have?
20:34:38 <glguy> There are other resolvers like ghc-8.0 and nightly-DATE that require GHC 8.0.1
20:37:31 <isBEKaml> glguy: let me try that
20:39:27 <isBEKaml> glguy: resolver ghc-8.0 requires cabal-install :-)
20:40:02 <Koterpillar> isBEKaml: what do you want all this for?
20:41:02 <kadoban> isBEKaml: Hmm? Why would that require cabal-install? stackage nightly uses ghc8, or there is an actual ghc-8.0 resolver
20:41:24 <isBEKaml> kadoban: no idea
20:42:26 <glguy> ghc-8.0 is an empty or mostly empty resolver where you can specify the packages you want
20:42:37 <kadoban> isBEKaml: I am confused what you're asking for/talking about.
20:43:45 <isBEKaml> kadoban: glguy mentioned that I can use ghc-8.0 resolver, which requires that I have cabal-install available. Switching to nightly-2016-07-27 got me going. Thanks
20:43:57 <glguy> I don't know if the ghc-8.0 resolver requires cabal-install or not, I've never tried not having it
20:44:50 <kadoban> I've never had stack require I have cabal-install around, what was the actual message?
20:46:33 <lpaste> isBEKaml pasted “stack resolver ghc-8.0” at http://lpaste.net/172425
20:46:49 <isBEKaml> kadoban: ^^
20:49:08 <kadoban> Huh, never knew that, maybe it does?
20:49:19 <kadoban> Well you can always just do 'stack install cabal-install'
20:49:21 <glguy> Oh, right, it uses it to resolve the dependencies
20:55:33 <isBEKaml> Well, it's okay. I'll continue using nightly, thanks
20:56:59 <kadoban> Nightly is usually better anyway, the ghc- resolvers are pretty limited, it's usually only if you're specifying like all of your dependencies manually, which I'm not sure why you'd really do. Maybe if you have a ton of conflicts and none of the real resolvers even close to match.
20:57:37 <glguy> They certainly aren't limited, they just use the normal resolver with the version of GHC you specified
20:58:00 <glguy> and you don't have to specify them manually, the solver automates that and saves the result to the stack.yaml
20:58:13 * hackagebot goatee 0.3.1.2 - A monadic take on a 2,500-year-old board game - library.  https://hackage.haskell.org/package/goatee-0.3.1.2 (khumba)
20:59:55 <kadoban> Huh, haskell SGF editor, neat.
21:03:13 <martinium_laptop> did anyone here start with haskell as their first language? If you did, was it difficult to learn an imperative or OOP paradigm language afterwards?
21:07:06 <Cale> martinium_laptop: I didn't, but some people I know did and didn't seem to have any trouble with it
21:07:58 <martinium_laptop> Good to know. Everything seems to point to learning FP helping you as a programmer in basically any paradigm afterwards.
21:29:02 <jamiejamiejamie> could anyone help me understand this type signature? (&&&) :: a b c -> a b c' -> a b (c, c') 
21:29:15 <jamiejamiejamie> I don't understand the role of the spaces in "a b c"
21:29:34 <Xnuk> It's like "Either a b"
21:29:48 <qmm> if I type Num into ghci and press enter, i get this error:     Not in scope: data constructor ‘Num’
21:29:51 <qmm> why is that?
21:30:15 <qmm> where can I import the Num data contructor?
21:30:19 <jamiejamiejamie> Either a b? then is the whole thing read as "a or b or c"?
21:30:20 <glguy> Because it's not a data constructor. The stuff you type into GHCi is typically an expression, a value
21:30:39 <Zemyla> :t \f g -> (\x -> f x) &&& g -- jamiejamiejamie 
21:30:40 <geekosaur> qmm, there isn't one. Num is a typeclass, not a type and not a value
21:30:40 <lambdabot> (b -> c) -> (b -> c') -> b -> (c, c')
21:31:04 <Zemyla> In that example, "a" is (->).
21:31:06 <kadoban> jamiejamiejamie: If it helps, just about the only instance of Arrow that people usually use is (->), so another way to write that (monomorphically) would be:   (&&&) :: (b -> c) -> (b -> 'c) -> (b -> (c, c'))
21:31:28 <glguy> jamiejamiejamie: The spaces are application. a applied to b, the result of that applied to c
21:31:37 <Zemyla> :t \f g -> Kleisli (runKleisli f) &&& g
21:31:38 <lambdabot> Monad m => Kleisli m a c -> Kleisli m a c' -> Kleisli m a (c, c')
21:31:47 <qmm> where can i get the definition of Num? is it in ghc? 
21:31:51 <geekosaur> otherwise thought of as a type a parameterized by types b and c
21:32:13 <jamiejamiejamie> qmm, try :info Num in ghci
21:32:28 <geekosaur> https://downloads.haskell.org/~ghc/7.10.3/docs/html/libraries/base-4.8.2.0/Prelude.html#t:Num
21:32:30 <glguy> jamiejamiejamie: if we instantiate a to be Either, then a b c is Either b c
21:32:32 <jamiejamiejamie> glguy, so it's regular function application? 
21:32:40 <Xnuk> :t Left
21:32:41 <lambdabot> a -> Either a b
21:32:42 <geekosaur> at the type level, yes
21:34:21 <Xnuk> > (*2) &&& (+2) $ 4
21:34:22 <geekosaur> "Either" can be thought of as a type function which takes two types as parameters and produces a type that can represent either of those parameter types.
21:34:23 <lambdabot>  (8,6)
21:35:34 <jamiejamiejamie> that's a cool example, Xnuk
21:35:59 <jamiejamiejamie> hold on for a second though, where did "Either" come into this? how do you guys know that for &&& we're using Eithers?
21:36:16 <jamiejamiejamie> sorry if that's a dumb question
21:36:33 <glguy> jamiejamiejamie: You just used Either in your question
21:36:48 <kadoban> Either a b  is just something that could unify with   z x y   at the type level, since that's something you were asking about. It's separate from the (&&&) thing.
21:36:54 <pavonia> :t (&&&)
21:36:55 <glguy> so I hoped you knew what Either was and used it as an example choice of a
21:36:55 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
21:36:56 <jamiejamiejamie> ohh, that was in response to what Xnuk said
21:37:22 <jamiejamiejamie> ah, thanks for the clarification
21:37:44 <jamiejamiejamie> now that I think about it, I think I see where you're going with this
21:38:32 <jamiejamiejamie> to be sure, data constructors are just regular functions, right? hence why you could use Either as a, because "Either" is just a function
21:39:18 <glguy> jamiejamiejamie: "Data constructors" are the capitalized names of types, not related directly to functions
21:39:36 <kadoban> Either is a *type* constructor. So it's like a function on the type level.
21:39:45 <glguy> err
21:39:53 <jamiejamiejamie> oh, it's a type constructor... sorry. I always get them mixed up
21:39:56 <glguy> err I meant "Type constructors"
21:39:58 <kadoban> You give it two types as arguments and it gives you a concrete type.
21:40:27 <glguy> Int and Either are type constructors. Because Either has kind * -> * -> *, you can apply it to types of kind *
21:40:31 <glguy> Either Int Char
21:40:46 <jamiejamiejamie> very cooooool 
21:40:59 <jamiejamiejamie> so, what is a "data constructor" then? is that even a thing or did I make that up?
21:41:06 <glguy> data constructor is what Left and False are
21:41:12 <glguy> they are value-level things
21:41:13 <jamiejamiejamie> OH
21:41:35 <jamiejamiejamie> thank you!
21:41:54 <kadoban> data Blah a = Foo a   ---   Foo is a data constructor. Blah is a type constructor.
21:43:33 <jamiejamiejamie> now I'm starting to understand this example a bit more: (*2) &&& (+2) $ 4
21:44:01 <jamiejamiejamie> though it's still beyond me how that returns a function that can then be applied to `4`
21:44:43 <jle`> jamiejamiejamie: just plug in the inputs to the function :)
21:44:47 <geekosaur> an arrow is an abstraction over function-like things, letting you combine functions in various ways to make new functions
21:44:54 <jle`> jamiejamiejamie: f &&& g = \x -> (f x, g x)
21:45:00 <jle`> that's the definition of &&& for (->)
21:45:32 <jle`> so ((*2) &&& (+2)) 4 = (\x -> (x * 2, 4 + 2)) 4
21:45:40 <jle`>  = (4 * 2, 4 + 2)
21:45:45 <jle`>  = (8, 6)
21:46:32 <jle`> jamiejamiejamie: most evaluation in haskell can be understood as just substitution :)
21:46:46 <Xnuk> s/(x \* 2, 4 + 2)/(x * 2, x + 2)/
21:46:54 <jle`> mhm
21:47:01 <jamiejamiejamie> the lambda calculus, I see
21:47:29 <jle`> do you understand the definition (f &&& g) x = (f x, g x) ?
21:47:42 <jle`> if so, you'll understand why ((*2) &&& (+2)) 4 does waht it does :)
21:48:05 <jamiejamiejamie> I understood it when you used the lambda function, though I guess it's still mysterious to me how `x` appears in there
21:48:23 <jle`> hm?  that's just the definition
21:48:32 <jle`> if you look in the source code, it'll just be defined that way
21:48:48 <monochrom> "f &&& g = \x -> whatever" can be rewritten as "(f &&& g) x = whatever"
21:48:50 <jamiejamiejamie> oh, sorry
21:49:09 <monochrom> generally "blah = \x -> whatever" can be rewritten as "blah x = whatever"
21:49:15 <jamiejamiejamie> haha, thanks, I missed the `x` in the (f &&& g) x = (f x, g x
21:49:41 <jamiejamiejamie> that's a useful insight monochrom, thank you
21:49:45 <jamiejamiejamie> and you too jle`
21:50:15 <jle`> np!
21:50:18 <tippenein> how would I cast an optional $ strOption to a type aliased type? like type VersionInfo = String
21:50:21 <cromachina> (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
21:50:21 <jle`> it's really easy to get lost in typeclass abstractions
21:50:21 <cromachina>  turns into (&&&) :: ((->) Integer Integer) -> ((->) Integer Integer) -> ((->) Integer (Interger, Integer))
21:50:39 <jle`> but for the most part, it's usually really easy to understand if you just look at the implementation for your specific type
21:50:48 <jle`> remember that every type gets to provide its own implementation
21:51:06 <jle`> looking at the specific implementaiton is a lot more insightful than trying to understand the general case, especially if you only care about the specfiic case
21:52:04 <kadoban> tippenein: A type alias is what it sounds like, they're the exact same thing. VersionInfo is just another name for String. No cast would make any sense.
21:52:23 <jamiejamiejamie> you guys are both very smart and very helpful
21:52:30 <jamiejamiejamie> I have to read about typeclasses again >.> 
21:52:43 <tippenein> so, I have a Parser (Maybe String) but I want it to be a Parser (Maybe VersionInfo) .. but that doesn't type check
21:53:14 <monochrom> then you misunderstood VersionInfo. or String.
21:53:23 <qmm> thanks jamiejamiejamie 
21:53:28 <kadoban> tippenein: Parser (Maybe String) is exactly the same thing as Parser (Maybe VersionInfo), if  type VersionInfo = String
21:54:45 <pavonia> tippenein: What is VersionInfo?
21:54:50 <tippenein> kadoban: you're right. 
21:55:02 <monochrom> also possible you have two things both called "Parser"
21:55:06 <tippenein> kadoban: I must've changed something else, because now it's compiling just like that
21:55:59 <jamiejamiejamie> thanks everyone :) 
21:59:30 <qmm> how do you create a single line if statement?
21:59:57 <dmj`> :t bool
21:59:58 <lambdabot> a -> a -> Bool -> a
22:00:02 <monochrom> just write it on a single line
22:00:06 <glguy> You can make a single line if expression with: if this then that else theother
22:00:07 <monochrom> > if True then () else ()
22:00:09 <lambdabot>  ()
22:00:14 <monochrom> single line
22:00:51 <dmj`> > (\x -> bool "no" "yes" (even x)) $ 1
22:00:53 <lambdabot>  "no"
22:00:56 <dmj`> > (\x -> bool "no" "yes" (even x)) $ 2
22:00:58 <lambdabot>  "yes"
22:06:25 <joe9> cabal is failing while installing haskell-src-exts 1.17.1 . How do I go about debugging why cabal is failing? I cannot find much info on how to go about debugging install issues.
22:06:42 <joe9>  error: http://codepad.org/KPQ8mdfq
22:07:29 <glguy> joe9: Did you delete the cabal executable while it was installing?
22:07:37 <qmm> > let my_test x = if x == 'e' then x
22:07:38 <lambdabot>  <hint>:1:17:
22:07:39 <lambdabot>      parse error in if statement: missing required else clause
22:07:48 <qmm> > let my_test x = if x == 'e' then x else False
22:07:49 <lambdabot>  <no location info>:
22:07:49 <lambdabot>      not an expression: ‘let my_test x = if x == 'e' then x else False’
22:08:04 <dmj`> "The exception was: /home/j/local/cabal/bin/cabal (deleted)"
22:08:07 <glguy> qmm: You need to finish the let expression in lambdabot
22:08:14 <joe9> qmm, dmj` : gotcha. Thanks a lot.
22:08:16 <glguy> let my_test .... in something
22:08:49 <joe9> qmm: dmj` cabal was trying to install cabal-install and cabal in parallel with other packages and that must have messed it up.
22:08:50 <qmm> > let an_e_test x = if x == 'e' then x else False in an_e_test 'f'
22:08:51 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘Bool’
22:08:51 <lambdabot>      In the expression: False
22:08:51 <lambdabot>      In the expression: if x == 'e' then x else False
22:09:05 <qmm> > let an_e_test x = if x == 'e' then x else 'f' in an_e_test 'f'
22:09:07 <lambdabot>  'f'
22:09:21 <qmm> > let an_e_test x = if x == 'e' then True else False in an_e_test 'f'
22:09:23 <lambdabot>  False
22:09:32 <qmm> thanks glguy
22:09:39 <qmm> thanks dmj` 
22:09:54 <qmm> oh and monochrom 
22:10:19 <qmm> sorry if my thanking is annoying, i guess it could get annoying after awhile
22:10:32 <monochrom> don't worry
22:56:22 <joe9> I am trying to use ghc-mod with emacs. When I start emacs with a haskell file, I get this message:  http://codepad.org/VrL801sr . I could not figure out how to add -v to the ghc-mod executable.
22:56:35 <joe9> I installed groom and it is fine.
22:56:45 <joe9> any kind thoughts on what I am missing, please?
23:02:21 <joe9> ghc-mod: <command line>: cannot satisfy -package-id groom-0.1.2-1VSm8L29xmT4qZIqlM8ub0
23:02:26 <joe9> is the error message
23:02:37 <joe9> ghc-pkg list | grep --colour=auto --ignore-case groom
23:02:38 <joe9>     groom-0.1.2
23:02:38 <joe9> -
23:02:42 <joe9> is the groom package installed.
23:19:01 <joe9> got it, had to clean up the dist directory
23:20:40 <eklavya> the default stack template uses which testing framework?
23:25:26 <fr33domlover> eklavya, take a look in the stack templates source repo
23:25:45 <eklavya> I did
23:26:06 <eklavya> mentions both hspec and quickcheck
23:42:13 <Halla> Hey! Does anybody have a better way of writing this function? http://pastebin.com/NhetPSjz
23:42:22 <Halla> I feel like there should be a way to write it in one line, with something like a fold
23:43:19 * hackagebot text-all 0.3.0.1 - Everything Data.Text related in one package  https://hackage.haskell.org/package/text-all-0.3.0.1 (Artyom)
23:44:16 <Koterpillar> Halla: use unfoldr?
23:44:44 <Koterpillar> Halla: or cheat and use show
23:45:23 <Halla> Koterpillar, fair... I was worried that might be less efficient, though?
23:45:32 <Koterpillar> which one?
23:45:35 <Halla> using show
23:45:56 <Halla> purely because I'm still not entirely sure how laziness affects things like this
23:46:04 <Koterpillar> exactly
23:46:57 <Koterpillar> try unfoldr then
23:47:24 <Halla> so I've never encountered unfoldr before. I just hoogled it, and I'm not really sure how it's useful
23:47:49 <Halla> slash is there any way to reason about efficiency with laziness?
23:48:08 <Koterpillar> > unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10)) 1234
23:48:09 <lambdabot>  [4,3,2,1]
23:48:27 <Koterpillar> why, yes
23:49:04 <Koterpillar> you still perform some operations, and laziness limits how much
23:49:56 <BartAdv> https://hackage.haskell.org/package/bifunctors-5.3/docs/Data-Bifunctor-Tannen.html#t:Tannen <- is it a reference to back to the future?
23:50:48 <Koterpillar> BartAdv: try https://hackage.haskell.org/package/tardis-0.4.1.0/docs/Control-Monad-Tardis.html ?
23:51:16 <BartAdv> :)
23:51:54 <Halla> Koterpillar, so what is the point of unfoldr? slash is it standard?
23:52:03 <Halla> I used to find reading foldr difficult, but now it looks way cleaner
23:52:10 <Koterpillar> it's the opposite to foldr?
23:52:15 <Halla> will the same thing happen with unfoldr, and I just haven't looked at enough code?
23:52:26 <Halla> or is it fairly uncommon
23:53:42 <jle`> Halla: btw, be aware that 'if foo then True else ...' is just `foo || ...'
23:53:58 <jle`> the "(x == y) == True" thing happens in a lot of languages :)
23:54:13 <Koterpillar> for me, thinking of it as the opposite of foldr helps; also, your function basically illustrates the need for it
23:55:52 <Halla> jle` thanks! it's funny, I would never put something like that in my c code, but suddenly it happens in haskell
23:56:03 <Halla> always learning :)
23:56:38 <jle`> i actaully sometimes do it accidentally, too
23:56:47 <jle`> it's kind of spooky how easy it is to accidentally do
23:56:49 <Koterpillar> does hlint pick that up?
23:58:40 <BartAdv> anyway, I think I've went too far: https://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor-Strong.html#t:Cotambara. "Cotambara cofreely constructs costrength" - no, I don't ask for explanation, it's most likely over my head, I just checked profunctors to see if they can be used with pairs
23:58:41 <srhb> Koterpillar: It picks up if foo then True else False and suggests: Why not: foo
